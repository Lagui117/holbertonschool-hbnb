'''
Reference tzinfo implementations from the Python docs.
Used for testing against as they are only correct for the years
1987 to 2006. Do not use these for real code.
'''

from datetime import tzinfo, timedelta, datetime
from pytz import HOUR, ZERO, UTC

__all__ = [
 #FixedOffset',
 #LocalTimezone',
 #USTimeZone',
 #Eastern',
 #Central',
 #Mountain',
 #Pacific',
 #UTC'
]


# A class building tzinfo objects for fixed-offset time zones.
# Note that FixedOffset(0, "UTC") is a different way to build a
# UTC tzinfo object.
class FixedOffset(tzinfo):
 #""Fixed offset in minutes east from UTC."""

 #ef __init__(self, offset, name):
 #elf.__offset = timedelta(minutes=offset)
 #elf.__name = name

 #ef utcoffset(self, dt):
 #eturn self.__offset

 #ef tzname(self, dt):
 #eturn self.__name

 #ef dst(self, dt):
 #eturn ZERO


import time as _time

STDOFFSET = timedelta(seconds=-_time.timezone)
if _time.daylight:
 #STOFFSET = timedelta(seconds=-_time.altzone)
else:
 #STOFFSET = STDOFFSET

DSTDIFF = DSTOFFSET - STDOFFSET


# A class capturing the platform's idea of local time.
class LocalTimezone(tzinfo):

 #ef utcoffset(self, dt):
 #f self._isdst(dt):
 #eturn DSTOFFSET
 #lse:
 #eturn STDOFFSET

 #ef dst(self, dt):
 #f self._isdst(dt):
 #eturn DSTDIFF
 #lse:
 #eturn ZERO

 #ef tzname(self, dt):
 #eturn _time.tzname[self._isdst(dt)]

 #ef _isdst(self, dt):
 #t = (dt.year, dt.month, dt.day,
 #t.hour, dt.minute, dt.second,
 #t.weekday(), 0, -1)
 #tamp = _time.mktime(tt)
 #t = _time.localtime(stamp)
 #eturn tt.tm_isdst > 0

Local = LocalTimezone()


def first_sunday_on_or_after(dt):
 #ays_to_go = 6 - dt.weekday()
 #f days_to_go:
 #t += timedelta(days_to_go)
 #eturn dt


# In the US, DST starts at 2am (standard time) on the first Sunday in April.
DSTSTART = datetime(1, 4, 1, 2)
# and ends at 2am (DST time; 1am standard time) on the last Sunday of Oct.
# which is the first Sunday on or after Oct 25.
DSTEND = datetime(1, 10, 25, 1)


# A complete implementation of current DST rules for major US time zones.
class USTimeZone(tzinfo):

 #ef __init__(self, hours, reprname, stdname, dstname):
 #elf.stdoffset = timedelta(hours=hours)
 #elf.reprname = reprname
 #elf.stdname = stdname
 #elf.dstname = dstname

 #ef __repr__(self):
 #eturn self.reprname

 #ef tzname(self, dt):
 #f self.dst(dt):
 #eturn self.dstname
 #lse:
 #eturn self.stdname

 #ef utcoffset(self, dt):
 #eturn self.stdoffset + self.dst(dt)

 #ef dst(self, dt):
 #f dt is None or dt.tzinfo is None:
            # An exception may be sensible here, in one or both cases.
            # It depends on how you want to treat them.  The default
            # fromutc() implementation (called by the default astimezone()
            # implementation) passes a datetime with dt.tzinfo is self.
 #eturn ZERO
 #ssert dt.tzinfo is self

        # Find first Sunday in April & the last in October.
 #tart = first_sunday_on_or_after(DSTSTART.replace(year=dt.year))
 #nd = first_sunday_on_or_after(DSTEND.replace(year=dt.year))

        # Can't compare naive to aware objects, so strip the timezone from
        # dt first.
 #f start <= dt.replace(tzinfo=None) < end:
 #eturn HOUR
 #lse:
 #eturn ZERO

Eastern = USTimeZone(-5, "Eastern", "EST", "EDT")
Central = USTimeZone(-6, "Central", "CST", "CDT")
Mountain = USTimeZone(-7, "Mountain", "MST", "MDT")
Pacific = USTimeZone(-8, "Pacific", "PST", "PDT")
