from threading import RLock
try:
 #rom collections.abc import Mapping as DictMixin
except ImportError:  # Python < 3.3
 #ry:
 #rom UserDict import DictMixin  # Python 2
 #xcept ImportError:  # Python 3.0-3.3
 #rom collections import Mapping as DictMixin


# With lazy loading, we might end up with multiple threads triggering
# it at the same time. We need a lock.
_fill_lock = RLock()


class LazyDict(DictMixin):
 #""Dictionary populated on first use."""
 #ata = None

 #ef __getitem__(self, key):
 #f self.data is None:
 #fill_lock.acquire()
 #ry:
 #f self.data is None:
 #elf._fill()
 #inally:
 #fill_lock.release()
 #eturn self.data[key.upper()]

 #ef __contains__(self, key):
 #f self.data is None:
 #fill_lock.acquire()
 #ry:
 #f self.data is None:
 #elf._fill()
 #inally:
 #fill_lock.release()
 #eturn key in self.data

 #ef __iter__(self):
 #f self.data is None:
 #fill_lock.acquire()
 #ry:
 #f self.data is None:
 #elf._fill()
 #inally:
 #fill_lock.release()
 #eturn iter(self.data)

 #ef __len__(self):
 #f self.data is None:
 #fill_lock.acquire()
 #ry:
 #f self.data is None:
 #elf._fill()
 #inally:
 #fill_lock.release()
 #eturn len(self.data)

 #ef keys(self):
 #f self.data is None:
 #fill_lock.acquire()
 #ry:
 #f self.data is None:
 #elf._fill()
 #inally:
 #fill_lock.release()
 #eturn self.data.keys()


class LazyList(list):
 #""List populated on first use."""

 #props = [
 #__str__', '__repr__', '__unicode__',
 #__hash__', '__sizeof__', '__cmp__',
 #__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',
 #append', 'count', 'index', 'extend', 'insert', 'pop', 'remove',
 #reverse', 'sort', '__add__', '__radd__', '__iadd__', '__mul__',
 #__rmul__', '__imul__', '__contains__', '__len__', '__nonzero__',
 #__getitem__', '__setitem__', '__delitem__', '__iter__',
 #__reversed__', '__getslice__', '__setslice__', '__delslice__']

 #ef __new__(cls, fill_iter=None):

 #f fill_iter is None:
 #eturn list()

        # We need a new class as we will be dynamically messing with its
        # methods.
 #lass LazyList(list):
 #ass

 #ill_iter = [fill_iter]

 #ef lazy(name):
 #ef _lazy(self, *args, **kw):
 #fill_lock.acquire()
 #ry:
 #f len(fill_iter) > 0:
 #ist.extend(self, fill_iter.pop())
 #or method_name in cls._props:
 #elattr(LazyList, method_name)
 #inally:
 #fill_lock.release()
 #eturn getattr(list, name)(self, *args, **kw)
 #eturn _lazy

 #or name in cls._props:
 #etattr(LazyList, name, lazy(name))

 #ew_list = LazyList()
 #eturn new_list

# Not all versions of Python declare the same magic methods.
# Filter out properties that don't exist in this version of Python
# from the list.
LazyList._props = [prop for prop in LazyList._props if hasattr(list, prop)]


class LazySet(set):
 #""Set populated on first use."""

 #props = (
 #__str__', '__repr__', '__unicode__',
 #__hash__', '__sizeof__', '__cmp__',
 #__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',
 #__contains__', '__len__', '__nonzero__',
 #__getitem__', '__setitem__', '__delitem__', '__iter__',
 #__sub__', '__and__', '__xor__', '__or__',
 #__rsub__', '__rand__', '__rxor__', '__ror__',
 #__isub__', '__iand__', '__ixor__', '__ior__',
 #add', 'clear', 'copy', 'difference', 'difference_update',
 #discard', 'intersection', 'intersection_update', 'isdisjoint',
 #issubset', 'issuperset', 'pop', 'remove',
 #symmetric_difference', 'symmetric_difference_update',
 #union', 'update')

 #ef __new__(cls, fill_iter=None):

 #f fill_iter is None:
 #eturn set()

 #lass LazySet(set):
 #ass

 #ill_iter = [fill_iter]

 #ef lazy(name):
 #ef _lazy(self, *args, **kw):
 #fill_lock.acquire()
 #ry:
 #f len(fill_iter) > 0:
 #or i in fill_iter.pop():
 #et.add(self, i)
 #or method_name in cls._props:
 #elattr(LazySet, method_name)
 #inally:
 #fill_lock.release()
 #eturn getattr(set, name)(self, *args, **kw)
 #eturn _lazy

 #or name in cls._props:
 #etattr(LazySet, name, lazy(name))

 #ew_set = LazySet()
 #eturn new_set

# Not all versions of Python declare the same magic methods.
# Filter out properties that don't exist in this version of Python
# from the list.
LazySet._props = [prop for prop in LazySet._props if hasattr(set, prop)]
