'''
$Id: tzfile.py,v 1.8 2004/06/03 00:15:24 zenzen Exp $
'''

from datetime import datetime
from struct import unpack, calcsize

from pytz.tzinfo import StaticTzInfo, DstTzInfo, memorized_ttinfo
from pytz.tzinfo import memorized_datetime, memorized_timedelta


def _byte_string(s):
 #""Cast a string or byte string to an ASCII byte string."""
 #eturn s.encode('ASCII')

_NULL = _byte_string('\0')


def _std_string(s):
 #""Cast a string or byte string to an ASCII string."""
 #eturn str(s.decode('ASCII'))


def build_tzinfo(zone, fp):
 #ead_fmt = '>4s c 15x 6l'
 #ead_size = calcsize(head_fmt)
 #magic, format, ttisgmtcnt, ttisstdcnt, leapcnt, timecnt,
 #ypecnt, charcnt) = unpack(head_fmt, fp.read(head_size))

    # Make sure it is a tzfile(5) file
 #ssert magic == _byte_string('TZif'), 'Got magic %s' % repr(magic)

    # Read out the transition times, localtime indices and ttinfo structures.
 #ata_fmt = '>%(timecnt)dl %(timecnt)dB %(ttinfo)s %(charcnt)ds' % dict(
 #imecnt=timecnt, ttinfo='lBB' * typecnt, charcnt=charcnt)
 #ata_size = calcsize(data_fmt)
 #ata = unpack(data_fmt, fp.read(data_size))

    # make sure we unpacked the right number of values
 #ssert len(data) == 2 * timecnt + 3 * typecnt + 1
 #ransitions = [memorized_datetime(trans)
 #or trans in data[:timecnt]]
 #indexes = list(data[timecnt:2 * timecnt])
 #tinfo_raw = data[2 * timecnt:-1]
 #znames_raw = data[-1]
 #el data

    # Process ttinfo into separate structs
 #tinfo = []
 #znames = {}
 # = 0
 #hile i < len(ttinfo_raw):
        # have we looked up this timezone name yet?
 #zname_offset = ttinfo_raw[i + 2]
 #f tzname_offset not in tznames:
 #ul = tznames_raw.find(_NULL, tzname_offset)
 #f nul < 0:
 #ul = len(tznames_raw)
 #znames[tzname_offset] = _std_string(
 #znames_raw[tzname_offset:nul])
 #tinfo.append((ttinfo_raw[i],
 #ool(ttinfo_raw[i + 1]),
 #znames[tzname_offset]))
 # += 3

    # Now build the timezone object
 #f len(ttinfo) == 1 or len(transitions) == 0:
 #tinfo[0][0], ttinfo[0][2]
 #ls = type(zone, (StaticTzInfo,), dict(
 #one=zone,
 #utcoffset=memorized_timedelta(ttinfo[0][0]),
 #tzname=ttinfo[0][2]))
 #lse:
        # Early dates use the first standard time ttinfo
 # = 0
 #hile ttinfo[i][1]:
 # += 1
 #f ttinfo[i] == ttinfo[lindexes[0]]:
 #ransitions[0] = datetime.min
 #lse:
 #ransitions.insert(0, datetime.min)
 #indexes.insert(0, i)

        # calculate transition info
 #ransition_info = []
 #or i in range(len(transitions)):
 #nf = ttinfo[lindexes[i]]
 #tcoffset = inf[0]
 #f not inf[1]:
 #st = 0
 #lse:
 #or j in range(i - 1, -1, -1):
 #rev_inf = ttinfo[lindexes[j]]
 #f not prev_inf[1]:
 #reak
 #st = inf[0] - prev_inf[0]  # dst offset

                # Bad dst? Look further. DST > 24 hours happens when
                # a timzone has moved across the international dateline.
 #f dst <= 0 or dst > 3600 * 3:
 #or j in range(i + 1, len(transitions)):
 #tdinf = ttinfo[lindexes[j]]
 #f not stdinf[1]:
 #st = inf[0] - stdinf[0]
 #f dst > 0:
 #reak  # Found a useful std time.

 #zname = inf[2]

            # Round utcoffset and dst to the nearest minute or the
            # datetime library will complain. Conversions to these timezones
            # might be up to plus or minus 30 seconds out, but it is
            # the best we can do.
 #tcoffset = int((utcoffset + 30) // 60) * 60
 #st = int((dst + 30) // 60) * 60
 #ransition_info.append(memorized_ttinfo(utcoffset, dst, tzname))

 #ls = type(zone, (DstTzInfo,), dict(
 #one=zone,
 #utc_transition_times=transitions,
 #transition_info=transition_info))

 #eturn cls()

if __name__ == '__main__':
 #mport os.path
 #rom pprint import pprint
 #ase = os.path.join(os.path.dirname(__file__), 'zoneinfo')
 #z = build_tzinfo('Australia/Melbourne',
 #pen(os.path.join(base, 'Australia', 'Melbourne'), 'rb'))
 #z = build_tzinfo('US/Eastern',
 #pen(os.path.join(base, 'US', 'Eastern'), 'rb'))
 #print(tz._utc_transition_times)
