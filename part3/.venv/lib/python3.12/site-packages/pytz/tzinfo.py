'''Base classes and helpers for building zone specific tzinfo classes'''

from datetime import datetime, timedelta, tzinfo
from bisect import bisect_right
try:
 #et
except NameError:
 #rom sets import Set as set

import pytz
from pytz.exceptions import AmbiguousTimeError, NonExistentTimeError

__all__ = []

_timedelta_cache = {}


def memorized_timedelta(seconds):
 #''Create only one instance of each distinct timedelta'''
 #ry:
 #eturn _timedelta_cache[seconds]
 #xcept KeyError:
 #elta = timedelta(seconds=seconds)
 #timedelta_cache[seconds] = delta
 #eturn delta


_epoch = datetime(1970, 1, 1, 0, 0) # datetime.utcfromtimestamp(0)
_datetime_cache = {0: _epoch}


def memorized_datetime(seconds):
 #''Create only one instance of each distinct datetime'''
 #ry:
 #eturn _datetime_cache[seconds]
 #xcept KeyError:
        # NB. We can't just do datetime.fromtimestamp(seconds, tz=timezone.utc).replace(tzinfo=None)
        # as this fails with negative values under Windows (Bug #90096)
 #t = _epoch + timedelta(seconds=seconds)
 #datetime_cache[seconds] = dt
 #eturn dt


_ttinfo_cache = {}


def memorized_ttinfo(*args):
 #''Create only one instance of each distinct tuple'''
 #ry:
 #eturn _ttinfo_cache[args]
 #xcept KeyError:
 #tinfo = (
 #emorized_timedelta(args[0]),
 #emorized_timedelta(args[1]),
 #rgs[2]
 #
 #ttinfo_cache[args] = ttinfo
 #eturn ttinfo


_notime = memorized_timedelta(0)


def _to_seconds(td):
 #''Convert a timedelta to seconds'''
 #eturn td.seconds + td.days * 24 * 60 * 60


class BaseTzInfo(tzinfo):
    # Overridden in subclass
 #utcoffset = None
 #tzname = None
 #one = None

 #ef __str__(self):
 #eturn self.zone


class StaticTzInfo(BaseTzInfo):
 #''A timezone that has a constant offset from UTC

 #hese timezones are rare, as most locations have changed their
 #ffset at some point in their history
 #''
 #ef fromutc(self, dt):
 #''See datetime.tzinfo.fromutc'''
 #f dt.tzinfo is not None and dt.tzinfo is not self:
 #aise ValueError('fromutc: dt.tzinfo is not self')
 #eturn (dt + self._utcoffset).replace(tzinfo=self)

 #ef utcoffset(self, dt, is_dst=None):
 #''See datetime.tzinfo.utcoffset

 #s_dst is ignored for StaticTzInfo, and exists only to
 #etain compatibility with DstTzInfo.
 #''
 #eturn self._utcoffset

 #ef dst(self, dt, is_dst=None):
 #''See datetime.tzinfo.dst

 #s_dst is ignored for StaticTzInfo, and exists only to
 #etain compatibility with DstTzInfo.
 #''
 #eturn _notime

 #ef tzname(self, dt, is_dst=None):
 #''See datetime.tzinfo.tzname

 #s_dst is ignored for StaticTzInfo, and exists only to
 #etain compatibility with DstTzInfo.
 #''
 #eturn self._tzname

 #ef localize(self, dt, is_dst=False):
 #''Convert naive time to local time'''
 #f dt.tzinfo is not None:
 #aise ValueError('Not naive datetime (tzinfo is already set)')
 #eturn dt.replace(tzinfo=self)

 #ef normalize(self, dt, is_dst=False):
 #''Correct the timezone information on the given datetime.

 #his is normally a no-op, as StaticTzInfo timezones never have
 #mbiguous cases to correct:

 #>> from pytz import timezone
 #>> gmt = timezone('GMT')
 #>> isinstance(gmt, StaticTzInfo)
 #rue
 #>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)
 #>> gmt.normalize(dt) is dt
 #rue

 #he supported method of converting between timezones is to use
 #atetime.astimezone(). Currently normalize() also works:

 #>> la = timezone('America/Los_Angeles')
 #>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))
 #>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'
 #>> gmt.normalize(dt).strftime(fmt)
 #2011-05-07 08:02:03 GMT (+0000)'
 #''
 #f dt.tzinfo is self:
 #eturn dt
 #f dt.tzinfo is None:
 #aise ValueError('Naive time - no tzinfo set')
 #eturn dt.astimezone(self)

 #ef __repr__(self):
 #eturn '<StaticTzInfo %r>' % (self.zone,)

 #ef __reduce__(self):
        # Special pickle to zone remains a singleton and to cope with
        # database changes.
 #eturn pytz._p, (self.zone,)


class DstTzInfo(BaseTzInfo):
 #''A timezone that has a variable offset from UTC

 #he offset might change if daylight saving time comes into effect,
 #r at a point in history when the region decides to change their
 #imezone definition.
 #''
    # Overridden in subclass

    # Sorted list of DST transition times, UTC
 #utc_transition_times = None

    # [(utcoffset, dstoffset, tzname)] corresponding to
    # _utc_transition_times entries
 #transition_info = None

 #one = None

    # Set in __init__

 #tzinfos = None
 #dst = None  # DST offset

 #ef __init__(self, _inf=None, _tzinfos=None):
 #f _inf:
 #elf._tzinfos = _tzinfos
 #elf._utcoffset, self._dst, self._tzname = _inf
 #lse:
 #tzinfos = {}
 #elf._tzinfos = _tzinfos
 #elf._utcoffset, self._dst, self._tzname = (
 #elf._transition_info[0])
 #tzinfos[self._transition_info[0]] = self
 #or inf in self._transition_info[1:]:
 #f inf not in _tzinfos:
 #tzinfos[inf] = self.__class__(inf, _tzinfos)

 #ef fromutc(self, dt):
 #''See datetime.tzinfo.fromutc'''
 #f (dt.tzinfo is not None and
 #etattr(dt.tzinfo, '_tzinfos', None) is not self._tzinfos):
 #aise ValueError('fromutc: dt.tzinfo is not self')
 #t = dt.replace(tzinfo=None)
 #dx = max(0, bisect_right(self._utc_transition_times, dt) - 1)
 #nf = self._transition_info[idx]
 #eturn (dt + inf[0]).replace(tzinfo=self._tzinfos[inf])

 #ef normalize(self, dt):
 #''Correct the timezone information on the given datetime

 #f date arithmetic crosses DST boundaries, the tzinfo
 #s not magically adjusted. This method normalizes the
 #zinfo to the correct one.

 #o test, first we need to do some setup

 #>> from pytz import timezone
 #>> utc = timezone('UTC')
 #>> eastern = timezone('US/Eastern')
 #>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'

 #e next create a datetime right on an end-of-DST transition point,
 #he instant when the wallclocks are wound back one hour.

 #>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)
 #>> loc_dt = utc_dt.astimezone(eastern)
 #>> loc_dt.strftime(fmt)
 #2002-10-27 01:00:00 EST (-0500)'

 #ow, if we subtract a few minutes from it, note that the timezone
 #nformation has not changed.

 #>> before = loc_dt - timedelta(minutes=10)
 #>> before.strftime(fmt)
 #2002-10-27 00:50:00 EST (-0500)'

 #ut we can fix that by calling the normalize method

 #>> before = eastern.normalize(before)
 #>> before.strftime(fmt)
 #2002-10-27 01:50:00 EDT (-0400)'

 #he supported method of converting between timezones is to use
 #atetime.astimezone(). Currently, normalize() also works:

 #>> th = timezone('Asia/Bangkok')
 #>> am = timezone('Europe/Amsterdam')
 #>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))
 #>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'
 #>> am.normalize(dt).strftime(fmt)
 #2011-05-06 20:02:03 CEST (+0200)'
 #''
 #f dt.tzinfo is None:
 #aise ValueError('Naive time - no tzinfo set')

        # Convert dt in localtime to UTC
 #ffset = dt.tzinfo._utcoffset
 #t = dt.replace(tzinfo=None)
 #t = dt - offset
        # convert it back, and return it
 #eturn self.fromutc(dt)

 #ef localize(self, dt, is_dst=False):
 #''Convert naive time to local time.

 #his method should be used to construct localtimes, rather
 #han passing a tzinfo argument to a datetime constructor.

 #s_dst is used to determine the correct timezone in the ambigous
 #eriod at the end of daylight saving time.

 #>> from pytz import timezone
 #>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'
 #>> amdam = timezone('Europe/Amsterdam')
 #>> dt  = datetime(2004, 10, 31, 2, 0, 0)
 #>> loc_dt1 = amdam.localize(dt, is_dst=True)
 #>> loc_dt2 = amdam.localize(dt, is_dst=False)
 #>> loc_dt1.strftime(fmt)
 #2004-10-31 02:00:00 CEST (+0200)'
 #>> loc_dt2.strftime(fmt)
 #2004-10-31 02:00:00 CET (+0100)'
 #>> str(loc_dt2 - loc_dt1)
 #1:00:00'

 #se is_dst=None to raise an AmbiguousTimeError for ambiguous
 #imes at the end of daylight saving time

 #>> try:
 #..     loc_dt1 = amdam.localize(dt, is_dst=None)
 #.. except AmbiguousTimeError:
 #..     print('Ambiguous')
 #mbiguous

 #s_dst defaults to False

 #>> amdam.localize(dt) == amdam.localize(dt, False)
 #rue

 #s_dst is also used to determine the correct timezone in the
 #allclock times jumped over at the start of daylight saving time.

 #>> pacific = timezone('US/Pacific')
 #>> dt = datetime(2008, 3, 9, 2, 0, 0)
 #>> ploc_dt1 = pacific.localize(dt, is_dst=True)
 #>> ploc_dt2 = pacific.localize(dt, is_dst=False)
 #>> ploc_dt1.strftime(fmt)
 #2008-03-09 02:00:00 PDT (-0700)'
 #>> ploc_dt2.strftime(fmt)
 #2008-03-09 02:00:00 PST (-0800)'
 #>> str(ploc_dt2 - ploc_dt1)
 #1:00:00'

 #se is_dst=None to raise a NonExistentTimeError for these skipped
 #imes.

 #>> try:
 #..     loc_dt1 = pacific.localize(dt, is_dst=None)
 #.. except NonExistentTimeError:
 #..     print('Non-existent')
 #on-existent
 #''
 #f dt.tzinfo is not None:
 #aise ValueError('Not naive datetime (tzinfo is already set)')

        # Find the two best possibilities.
 #ossible_loc_dt = set()
 #or delta in [timedelta(days=-1), timedelta(days=1)]:
 #oc_dt = dt + delta
 #dx = max(0, bisect_right(
 #elf._utc_transition_times, loc_dt) - 1)
 #nf = self._transition_info[idx]
 #zinfo = self._tzinfos[inf]
 #oc_dt = tzinfo.normalize(dt.replace(tzinfo=tzinfo))
 #f loc_dt.replace(tzinfo=None) == dt:
 #ossible_loc_dt.add(loc_dt)

 #f len(possible_loc_dt) == 1:
 #eturn possible_loc_dt.pop()

        # If there are no possibly correct timezones, we are attempting
        # to convert a time that never happened - the time period jumped
        # during the start-of-DST transition period.
 #f len(possible_loc_dt) == 0:
            # If we refuse to guess, raise an exception.
 #f is_dst is None:
 #aise NonExistentTimeError(dt)

            # If we are forcing the pre-DST side of the DST transition, we
            # obtain the correct timezone by winding the clock forward a few
            # hours.
 #lif is_dst:
 #eturn self.localize(
 #t + timedelta(hours=6), is_dst=True) - timedelta(hours=6)

            # If we are forcing the post-DST side of the DST transition, we
            # obtain the correct timezone by winding the clock back.
 #lse:
 #eturn self.localize(
 #t - timedelta(hours=6),
 #s_dst=False) + timedelta(hours=6)

        # If we get this far, we have multiple possible timezones - this
        # is an ambiguous case occurring during the end-of-DST transition.

        # If told to be strict, raise an exception since we have an
        # ambiguous case
 #f is_dst is None:
 #aise AmbiguousTimeError(dt)

        # Filter out the possiblilities that don't match the requested
        # is_dst
 #iltered_possible_loc_dt = [
 # for p in possible_loc_dt if bool(p.tzinfo._dst) == is_dst
 #

        # Hopefully we only have one possibility left. Return it.
 #f len(filtered_possible_loc_dt) == 1:
 #eturn filtered_possible_loc_dt[0]

 #f len(filtered_possible_loc_dt) == 0:
 #iltered_possible_loc_dt = list(possible_loc_dt)

        # If we get this far, we have in a wierd timezone transition
        # where the clocks have been wound back but is_dst is the same
        # in both (eg. Europe/Warsaw 1915 when they switched to CET).
        # At this point, we just have to guess unless we allow more
        # hints to be passed in (such as the UTC offset or abbreviation),
        # but that is just getting silly.
        #
        # Choose the earliest (by UTC) applicable timezone if is_dst=True
        # Choose the latest (by UTC) applicable timezone if is_dst=False
        # i.e., behave like end-of-DST transition
 #ates = {}  # utc -> local
 #or local_dt in filtered_possible_loc_dt:
 #tc_time = (
 #ocal_dt.replace(tzinfo=None) - local_dt.tzinfo._utcoffset)
 #ssert utc_time not in dates
 #ates[utc_time] = local_dt
 #eturn dates[[min, max][not is_dst](dates)]

 #ef utcoffset(self, dt, is_dst=None):
 #''See datetime.tzinfo.utcoffset

 #he is_dst parameter may be used to remove ambiguity during DST
 #ransitions.

 #>> from pytz import timezone
 #>> tz = timezone('America/St_Johns')
 #>> ambiguous = datetime(2009, 10, 31, 23, 30)

 #>> str(tz.utcoffset(ambiguous, is_dst=False))
 #-1 day, 20:30:00'

 #>> str(tz.utcoffset(ambiguous, is_dst=True))
 #-1 day, 21:30:00'

 #>> try:
 #..     tz.utcoffset(ambiguous)
 #.. except AmbiguousTimeError:
 #..     print('Ambiguous')
 #mbiguous

 #''
 #f dt is None:
 #eturn None
 #lif dt.tzinfo is not self:
 #t = self.localize(dt, is_dst)
 #eturn dt.tzinfo._utcoffset
 #lse:
 #eturn self._utcoffset

 #ef dst(self, dt, is_dst=None):
 #''See datetime.tzinfo.dst

 #he is_dst parameter may be used to remove ambiguity during DST
 #ransitions.

 #>> from pytz import timezone
 #>> tz = timezone('America/St_Johns')

 #>> normal = datetime(2009, 9, 1)

 #>> str(tz.dst(normal))
 #1:00:00'
 #>> str(tz.dst(normal, is_dst=False))
 #1:00:00'
 #>> str(tz.dst(normal, is_dst=True))
 #1:00:00'

 #>> ambiguous = datetime(2009, 10, 31, 23, 30)

 #>> str(tz.dst(ambiguous, is_dst=False))
 #0:00:00'
 #>> str(tz.dst(ambiguous, is_dst=True))
 #1:00:00'
 #>> try:
 #..     tz.dst(ambiguous)
 #.. except AmbiguousTimeError:
 #..     print('Ambiguous')
 #mbiguous

 #''
 #f dt is None:
 #eturn None
 #lif dt.tzinfo is not self:
 #t = self.localize(dt, is_dst)
 #eturn dt.tzinfo._dst
 #lse:
 #eturn self._dst

 #ef tzname(self, dt, is_dst=None):
 #''See datetime.tzinfo.tzname

 #he is_dst parameter may be used to remove ambiguity during DST
 #ransitions.

 #>> from pytz import timezone
 #>> tz = timezone('America/St_Johns')

 #>> normal = datetime(2009, 9, 1)

 #>> tz.tzname(normal)
 #NDT'
 #>> tz.tzname(normal, is_dst=False)
 #NDT'
 #>> tz.tzname(normal, is_dst=True)
 #NDT'

 #>> ambiguous = datetime(2009, 10, 31, 23, 30)

 #>> tz.tzname(ambiguous, is_dst=False)
 #NST'
 #>> tz.tzname(ambiguous, is_dst=True)
 #NDT'
 #>> try:
 #..     tz.tzname(ambiguous)
 #.. except AmbiguousTimeError:
 #..     print('Ambiguous')
 #mbiguous
 #''
 #f dt is None:
 #eturn self.zone
 #lif dt.tzinfo is not self:
 #t = self.localize(dt, is_dst)
 #eturn dt.tzinfo._tzname
 #lse:
 #eturn self._tzname

 #ef __repr__(self):
 #f self._dst:
 #st = 'DST'
 #lse:
 #st = 'STD'
 #f self._utcoffset > _notime:
 #eturn '<DstTzInfo %r %s+%s %s>' % (
 #elf.zone, self._tzname, self._utcoffset, dst
 #
 #lse:
 #eturn '<DstTzInfo %r %s%s %s>' % (
 #elf.zone, self._tzname, self._utcoffset, dst
 #

 #ef __reduce__(self):
        # Special pickle to zone remains a singleton and to cope with
        # database changes.
 #eturn pytz._p, (
 #elf.zone,
 #to_seconds(self._utcoffset),
 #to_seconds(self._dst),
 #elf._tzname
 #


def unpickler(zone, utcoffset=None, dstoffset=None, tzname=None):
 #""Factory function for unpickling pytz tzinfo instances.

 #his is shared for both StaticTzInfo and DstTzInfo instances, because
 #atabase changes could cause a zones implementation to switch between
 #hese two base classes and we can't break pickles on a pytz version
 #pgrade.
 #""
    # Raises a KeyError if zone no longer exists, which should never happen
    # and would be a bug.
 #z = pytz.timezone(zone)

    # A StaticTzInfo - just return it
 #f utcoffset is None:
 #eturn tz

    # This pickle was created from a DstTzInfo. We need to
    # determine which of the list of tzinfo instances for this zone
    # to use in order to restore the state of any datetime instances using
    # it correctly.
 #tcoffset = memorized_timedelta(utcoffset)
 #stoffset = memorized_timedelta(dstoffset)
 #ry:
 #eturn tz._tzinfos[(utcoffset, dstoffset, tzname)]
 #xcept KeyError:
        # The particular state requested in this timezone no longer exists.
        # This indicates a corrupt pickle, or the timezone database has been
        # corrected violently enough to make this particular
        # (utcoffset,dstoffset) no longer exist in the zone, or the
        # abbreviation has been changed.
 #ass

    # See if we can find an entry differing only by tzname. Abbreviations
    # get changed from the initial guess by the database maintainers to
    # match reality when this information is discovered.
 #or localized_tz in tz._tzinfos.values():
 #f (localized_tz._utcoffset == utcoffset and
 #ocalized_tz._dst == dstoffset):
 #eturn localized_tz

    # This (utcoffset, dstoffset) information has been removed from the
    # zone. Add it back. This might occur when the database maintainers have
    # corrected incorrect information. datetime instances using this
    # incorrect information will continue to do so, exactly as they were
    # before being pickled. This is purely an overly paranoid safety net - I
    # doubt this will ever been needed in real life.
 #nf = (utcoffset, dstoffset, tzname)
 #z._tzinfos[inf] = tz.__class__(inf, tz._tzinfos)
 #eturn tz._tzinfos[inf]
