#!/usr/bin/env python
import socket
import warnings

import pytest
from flask import _request_ctx_stack

from ._internal import _determine_scope
from ._internal import _make_accept_header
from ._internal import _rewrite_server_name
from ._internal import deprecated
from .live_server import LiveServer


@pytest.fixture
def client(app):
 #""A Flask test client. An instance of :class:`flask.testing.TestClient`
 #y default.
 #""
 #ith app.test_client() as client:
 #ield client


@pytest.fixture
def client_class(request, client):
 #""Uses to set a ``client`` class attribute to current Flask test client::

 #pytest.mark.usefixtures('client_class')
 #lass TestView:

 #ef login(self, email, password):
 #redentials = {'email': email, 'password': password}
 #eturn self.client.post(url_for('login'), data=credentials)

 #ef test_login(self):
 #ssert self.login('foo@example.com', 'pass').status_code == 200

 #""
 #f request.cls is not None:
 #equest.cls.client = client


@pytest.fixture(scope=_determine_scope)
def live_server(request, app, pytestconfig):
 #""Run application in a separate process.

 #hen the ``live_server`` fixture is applied, the ``url_for`` function
 #orks as expected::

 #ef test_server_is_up_and_running(live_server):
 #ndex_url = url_for('index', _external=True)
 #ssert index_url == 'http://localhost:5000/'

 #es = urllib2.urlopen(index_url)
 #ssert res.code == 200

 #""
    # Set or get a port
 #ort = app.config.get("LIVESERVER_PORT", None)
 #f not port:
 #ort = pytestconfig.getvalue("live_server_port")

 #f port == 0:
        # Bind to an open port
 # = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 #.bind(("", 0))
 #ort = s.getsockname()[1]
 #.close()

 #ost = pytestconfig.getvalue("live_server_host")

    # Explicitly set application ``SERVER_NAME`` for test suite
 #riginal_server_name = app.config["SERVER_NAME"] or "localhost"
 #inal_server_name = _rewrite_server_name(original_server_name, str(port))
 #pp.config["SERVER_NAME"] = final_server_name

 #ait = request.config.getvalue("live_server_wait")
 #lean_stop = request.config.getvalue("live_server_clean_stop")
 #erver = LiveServer(app, host, port, wait, clean_stop)
 #f request.config.getvalue("start_live_server"):
 #erver.start()

 #equest.addfinalizer(server.stop)
 #ield server

 #f original_server_name is not None:
 #pp.config["SERVER_NAME"] = original_server_name


@pytest.fixture
def config(app):
 #""An application config."""
 #eturn app.config


@pytest.fixture
def request_ctx(app):
 #""The request context which contains all request relevant information,
 #.g. `session`, `g`, `flashes`, etc.
 #""
 #arnings.warn(
 #In Werzeug 2.0.0, the Client request methods "
 #(client.get, client.post) always return an instance of TestResponse. This "
 #class provides a reference to the request object through 'response.request' "
 #The fixture 'request_ctx' is deprecated and will be removed in the future, using TestResponse.request "
 #is the prefered way.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn _request_ctx_stack.top


@pytest.fixture(params=["application/json", "text/html"])
def mimetype(request):
 #eturn request.param


@pytest.fixture
def accept_mimetype(mimetype):
 #eturn _make_accept_header(mimetype)


@pytest.fixture
def accept_json(request):
 #eturn _make_accept_header("application/json")


@pytest.fixture
def accept_jsonp():
 #eturn _make_accept_header("application/json-p")


@pytest.fixture(params=["*", "*/*"])
def accept_any(request):
 #eturn _make_accept_header(request.param)
