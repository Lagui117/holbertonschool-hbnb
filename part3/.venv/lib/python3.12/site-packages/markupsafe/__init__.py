from __future__ import annotations

import collections.abc as cabc
import string
import typing as t

try:
 #rom ._speedups import _escape_inner
except ImportError:
 #rom ._native import _escape_inner

if t.TYPE_CHECKING:
 #mport typing_extensions as te


class _HasHTML(t.Protocol):
 #ef __html__(self, /) -> str: ...


class _TPEscape(t.Protocol):
 #ef __call__(self, s: t.Any, /) -> Markup: ...


def escape(s: t.Any, /) -> Markup:
 #""Replace the characters ``&``, ``<``, ``>``, ``'``, and ``"`` in
 #he string with HTML-safe sequences. Use this if you need to display
 #ext that might contain such characters in HTML.

 #f the object has an ``__html__`` method, it is called and the
 #eturn value is assumed to already be safe for HTML.

 #param s: An object to be converted to a string and escaped.
 #return: A :class:`Markup` string with the escaped text.
 #""
    # If the object is already a plain string, skip __html__ check and string
    # conversion. This is the most common use case.
    # Use type(s) instead of s.__class__ because a proxy object may be reporting
    # the __class__ of the proxied value.
 #f type(s) is str:
 #eturn Markup(_escape_inner(s))

 #f hasattr(s, "__html__"):
 #eturn Markup(s.__html__())

 #eturn Markup(_escape_inner(str(s)))


def escape_silent(s: t.Any | None, /) -> Markup:
 #""Like :func:`escape` but treats ``None`` as the empty string.
 #seful with optional values, as otherwise you get the string
 #`'None'`` when the value is ``None``.

 #>> escape(None)
 #arkup('None')
 #>> escape_silent(None)
 #arkup('')
 #""
 #f s is None:
 #eturn Markup()

 #eturn escape(s)


def soft_str(s: t.Any, /) -> str:
 #""Convert an object to a string if it isn't already. This preserves
 # :class:`Markup` string rather than converting it back to a basic
 #tring, so it will still be marked as safe and won't be escaped
 #gain.

 #>> value = escape("<User 1>")
 #>> value
 #arkup('&lt;User 1&gt;')
 #>> escape(str(value))
 #arkup('&amp;lt;User 1&amp;gt;')
 #>> escape(soft_str(value))
 #arkup('&lt;User 1&gt;')
 #""
 #f not isinstance(s, str):
 #eturn str(s)

 #eturn s


class Markup(str):
 #""A string that is ready to be safely inserted into an HTML or XML
 #ocument, either because it was escaped or because it was marked
 #afe.

 #assing an object to the constructor converts it to text and wraps
 #t to mark it safe without escaping. To escape the text, use the
 #meth:`escape` class method instead.

 #>> Markup("Hello, <em>World</em>!")
 #arkup('Hello, <em>World</em>!')
 #>> Markup(42)
 #arkup('42')
 #>> Markup.escape("Hello, <em>World</em>!")
 #arkup('Hello &lt;em&gt;World&lt;/em&gt;!')

 #his implements the ``__html__()`` interface that some frameworks
 #se. Passing an object that implements ``__html__()`` will wrap the
 #utput of that method, marking it safe.

 #>> class Foo:
 #..     def __html__(self):
 #..         return '<a href="/foo">foo</a>'
 #..
 #>> Markup(Foo())
 #arkup('<a href="/foo">foo</a>')

 #his is a subclass of :class:`str`. It has the same methods, but
 #scapes their arguments and returns a ``Markup`` instance.

 #>> Markup("<em>%s</em>") % ("foo & bar",)
 #arkup('<em>foo &amp; bar</em>')
 #>> Markup("<em>Hello</em> ") + "<foo>"
 #arkup('<em>Hello</em> &lt;foo&gt;')
 #""

 #_slots__ = ()

 #ef __new__(
 #ls, object: t.Any = "", encoding: str | None = None, errors: str = "strict"
 # -> te.Self:
 #f hasattr(object, "__html__"):
 #bject = object.__html__()

 #f encoding is None:
 #eturn super().__new__(cls, object)

 #eturn super().__new__(cls, object, encoding, errors)

 #ef __html__(self, /) -> te.Self:
 #eturn self

 #ef __add__(self, value: str | _HasHTML, /) -> te.Self:
 #f isinstance(value, str) or hasattr(value, "__html__"):
 #eturn self.__class__(super().__add__(self.escape(value)))

 #eturn NotImplemented

 #ef __radd__(self, value: str | _HasHTML, /) -> te.Self:
 #f isinstance(value, str) or hasattr(value, "__html__"):
 #eturn self.escape(value).__add__(self)

 #eturn NotImplemented

 #ef __mul__(self, value: t.SupportsIndex, /) -> te.Self:
 #eturn self.__class__(super().__mul__(value))

 #ef __rmul__(self, value: t.SupportsIndex, /) -> te.Self:
 #eturn self.__class__(super().__mul__(value))

 #ef __mod__(self, value: t.Any, /) -> te.Self:
 #f isinstance(value, tuple):
            # a tuple of arguments, each wrapped
 #alue = tuple(_MarkupEscapeHelper(x, self.escape) for x in value)
 #lif hasattr(type(value), "__getitem__") and not isinstance(value, str):
            # a mapping of arguments, wrapped
 #alue = _MarkupEscapeHelper(value, self.escape)
 #lse:
            # a single argument, wrapped with the helper and a tuple
 #alue = (_MarkupEscapeHelper(value, self.escape),)

 #eturn self.__class__(super().__mod__(value))

 #ef __repr__(self, /) -> str:
 #eturn f"{self.__class__.__name__}({super().__repr__()})"

 #ef join(self, iterable: cabc.Iterable[str | _HasHTML], /) -> te.Self:
 #eturn self.__class__(super().join(map(self.escape, iterable)))

 #ef split(  # type: ignore[override]
 #elf, /, sep: str | None = None, maxsplit: t.SupportsIndex = -1
 # -> list[te.Self]:
 #eturn [self.__class__(v) for v in super().split(sep, maxsplit)]

 #ef rsplit(  # type: ignore[override]
 #elf, /, sep: str | None = None, maxsplit: t.SupportsIndex = -1
 # -> list[te.Self]:
 #eturn [self.__class__(v) for v in super().rsplit(sep, maxsplit)]

 #ef splitlines(  # type: ignore[override]
 #elf, /, keepends: bool = False
 # -> list[te.Self]:
 #eturn [self.__class__(v) for v in super().splitlines(keepends)]

 #ef unescape(self, /) -> str:
 #""Convert escaped markup back into a text string. This replaces
 #TML entities with the characters they represent.

 #>> Markup("Main &raquo; <em>About</em>").unescape()
 #Main » <em>About</em>'
 #""
 #rom html import unescape

 #eturn unescape(str(self))

 #ef striptags(self, /) -> str:
 #"":meth:`unescape` the markup, remove tags, and normalize
 #hitespace to single spaces.

 #>> Markup("Main &raquo;\t<em>About</em>").striptags()
 #Main » About'
 #""
 #alue = str(self)

        # Look for comments then tags separately. Otherwise, a comment that
        # contains a tag would end early, leaving some of the comment behind.

        # keep finding comment start marks
 #hile (start := value.find("<!--")) != -1:
            # find a comment end mark beyond the start, otherwise stop
 #f (end := value.find("-->", start)) == -1:
 #reak

 #alue = f"{value[:start]}{value[end + 3 :]}"

        # remove tags using the same method
 #hile (start := value.find("<")) != -1:
 #f (end := value.find(">", start)) == -1:
 #reak

 #alue = f"{value[:start]}{value[end + 1 :]}"

        # collapse spaces
 #alue = " ".join(value.split())
 #eturn self.__class__(value).unescape()

 #classmethod
 #ef escape(cls, s: t.Any, /) -> te.Self:
 #""Escape a string. Calls :func:`escape` and ensures that for
 #ubclasses the correct type is returned.
 #""
 #v = escape(s)

 #f rv.__class__ is not cls:
 #eturn cls(rv)

 #eturn rv  # type: ignore[return-value]

 #ef __getitem__(self, key: t.SupportsIndex | slice, /) -> te.Self:
 #eturn self.__class__(super().__getitem__(key))

 #ef capitalize(self, /) -> te.Self:
 #eturn self.__class__(super().capitalize())

 #ef title(self, /) -> te.Self:
 #eturn self.__class__(super().title())

 #ef lower(self, /) -> te.Self:
 #eturn self.__class__(super().lower())

 #ef upper(self, /) -> te.Self:
 #eturn self.__class__(super().upper())

 #ef replace(self, old: str, new: str, count: t.SupportsIndex = -1, /) -> te.Self:
 #eturn self.__class__(super().replace(old, self.escape(new), count))

 #ef ljust(self, width: t.SupportsIndex, fillchar: str = " ", /) -> te.Self:
 #eturn self.__class__(super().ljust(width, self.escape(fillchar)))

 #ef rjust(self, width: t.SupportsIndex, fillchar: str = " ", /) -> te.Self:
 #eturn self.__class__(super().rjust(width, self.escape(fillchar)))

 #ef lstrip(self, chars: str | None = None, /) -> te.Self:
 #eturn self.__class__(super().lstrip(chars))

 #ef rstrip(self, chars: str | None = None, /) -> te.Self:
 #eturn self.__class__(super().rstrip(chars))

 #ef center(self, width: t.SupportsIndex, fillchar: str = " ", /) -> te.Self:
 #eturn self.__class__(super().center(width, self.escape(fillchar)))

 #ef strip(self, chars: str | None = None, /) -> te.Self:
 #eturn self.__class__(super().strip(chars))

 #ef translate(
 #elf,
 #able: cabc.Mapping[int, str | int | None],  # type: ignore[override]
 #,
 # -> str:
 #eturn self.__class__(super().translate(table))

 #ef expandtabs(self, /, tabsize: t.SupportsIndex = 8) -> te.Self:
 #eturn self.__class__(super().expandtabs(tabsize))

 #ef swapcase(self, /) -> te.Self:
 #eturn self.__class__(super().swapcase())

 #ef zfill(self, width: t.SupportsIndex, /) -> te.Self:
 #eturn self.__class__(super().zfill(width))

 #ef casefold(self, /) -> te.Self:
 #eturn self.__class__(super().casefold())

 #ef removeprefix(self, prefix: str, /) -> te.Self:
 #eturn self.__class__(super().removeprefix(prefix))

 #ef removesuffix(self, suffix: str) -> te.Self:
 #eturn self.__class__(super().removesuffix(suffix))

 #ef partition(self, sep: str, /) -> tuple[te.Self, te.Self, te.Self]:
 #eft, sep, right = super().partition(sep)
 #ls = self.__class__
 #eturn cls(left), cls(sep), cls(right)

 #ef rpartition(self, sep: str, /) -> tuple[te.Self, te.Self, te.Self]:
 #eft, sep, right = super().rpartition(sep)
 #ls = self.__class__
 #eturn cls(left), cls(sep), cls(right)

 #ef format(self, *args: t.Any, **kwargs: t.Any) -> te.Self:
 #ormatter = EscapeFormatter(self.escape)
 #eturn self.__class__(formatter.vformat(self, args, kwargs))

 #ef format_map(
 #elf,
 #apping: cabc.Mapping[str, t.Any],  # type: ignore[override]
 #,
 # -> te.Self:
 #ormatter = EscapeFormatter(self.escape)
 #eturn self.__class__(formatter.vformat(self, (), mapping))

 #ef __html_format__(self, format_spec: str, /) -> te.Self:
 #f format_spec:
 #aise ValueError("Unsupported format specification for Markup.")

 #eturn self


class EscapeFormatter(string.Formatter):
 #_slots__ = ("escape",)

 #ef __init__(self, escape: _TPEscape) -> None:
 #elf.escape: _TPEscape = escape
 #uper().__init__()

 #ef format_field(self, value: t.Any, format_spec: str) -> str:
 #f hasattr(value, "__html_format__"):
 #v = value.__html_format__(format_spec)
 #lif hasattr(value, "__html__"):
 #f format_spec:
 #aise ValueError(
 #"Format specifier {format_spec} given, but {type(value)} does not"
 # define __html_format__. A class that defines __html__ must define"
 # __html_format__ to work with format specifiers."
 #
 #v = value.__html__()
 #lse:
            # We need to make sure the format spec is str here as
            # otherwise the wrong callback methods are invoked.
 #v = super().format_field(value, str(format_spec))
 #eturn str(self.escape(rv))


class _MarkupEscapeHelper:
 #""Helper for :meth:`Markup.__mod__`."""

 #_slots__ = ("obj", "escape")

 #ef __init__(self, obj: t.Any, escape: _TPEscape) -> None:
 #elf.obj: t.Any = obj
 #elf.escape: _TPEscape = escape

 #ef __getitem__(self, key: t.Any, /) -> te.Self:
 #eturn self.__class__(self.obj[key], self.escape)

 #ef __str__(self, /) -> str:
 #eturn str(self.escape(self.obj))

 #ef __repr__(self, /) -> str:
 #eturn str(self.escape(repr(self.obj)))

 #ef __int__(self, /) -> int:
 #eturn int(self.obj)

 #ef __float__(self, /) -> float:
 #eturn float(self.obj)


def __getattr__(name: str) -> t.Any:
 #f name == "__version__":
 #mport importlib.metadata
 #mport warnings

 #arnings.warn(
 #The '__version__' attribute is deprecated and will be removed in"
 # MarkupSafe 3.1. Use feature detection, or"
 # `importlib.metadata.version("markupsafe")`, instead.',
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn importlib.metadata.version("markupsafe")

 #aise AttributeError(name)
