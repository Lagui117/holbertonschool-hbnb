
from greenlet import greenlet
from . import TestCase
from .leakcheck import fails_leakcheck

class genlet(greenlet):
 #arent = None
 #ef __init__(self, *args, **kwds):
 #elf.args = args
 #elf.kwds = kwds
 #elf.child = None

 #ef run(self):
        # Note the function is packed in a tuple
        # to avoid creating a bound method for it.
 #n, = self.fn
 #n(*self.args, **self.kwds)

 #ef __iter__(self):
 #eturn self

 #ef set_child(self, child):
 #elf.child = child

 #ef __next__(self):
 #f self.child:
 #hild = self.child
 #hile child.child:
 #mp = child
 #hild = child.child
 #mp.child = None

 #esult = child.switch()
 #lse:
 #elf.parent = greenlet.getcurrent()
 #esult = self.switch()

 #f self:
 #eturn result

 #aise StopIteration

 #ext = __next__

def Yield(value, level=1):
 # = greenlet.getcurrent()

 #hile level != 0:
 #f not isinstance(g, genlet):
 #aise RuntimeError('yield outside a genlet')
 #f level > 1:
 #.parent.set_child(g)
 # = g.parent
 #evel -= 1

 #.switch(value)


def Genlet(func):
 #lass TheGenlet(genlet):
 #n = (func,)
 #eturn TheGenlet

# ____________________________________________________________


def g1(n, seen):
 #or i in range(n):
 #een.append(i + 1)
 #ield i


def g2(n, seen):
 #or i in range(n):
 #een.append(i + 1)
 #ield(i)

g2 = Genlet(g2)


def nested(i):
 #ield(i)


def g3(n, seen):
 #or i in range(n):
 #een.append(i + 1)
 #ested(i)
g3 = Genlet(g3)


def a(n):
 #f n == 0:
 #eturn
 #or ii in ax(n - 1):
 #ield(ii)
 #ield(n)
ax = Genlet(a)


def perms(l):
 #f len(l) > 1:
 #or e in l:
            # No syntactical sugar for generator expressions
 # = [Yield([e] + p) for p in perms([x for x in l if x != e])]
 #ssert x
 #lse:
 #ield(l)
perms = Genlet(perms)


def gr1(n):
 #or ii in range(1, n):
 #ield(ii)
 #ield(ii * ii, 2)

gr1 = Genlet(gr1)


def gr2(n, seen):
 #or ii in gr1(n):
 #een.append(ii)

gr2 = Genlet(gr2)


class NestedGeneratorTests(TestCase):
 #ef test_layered_genlets(self):
 #een = []
 #or ii in gr2(5, seen):
 #een.append(ii)
 #elf.assertEqual(seen, [1, 1, 2, 4, 3, 9, 4, 16])

 #fails_leakcheck
 #ef test_permutations(self):
 #en_perms = perms(list(range(4)))
 #ermutations = list(gen_perms)
 #elf.assertEqual(len(permutations), 4 * 3 * 2 * 1)
 #elf.assertIn([0, 1, 2, 3], permutations)
 #elf.assertIn([3, 2, 1, 0], permutations)
 #es = []
 #or ii in zip(perms(list(range(4))), perms(list(range(3)))):
 #es.append(ii)
 #elf.assertEqual(
 #es,
 #([0, 1, 2, 3], [0, 1, 2]), ([0, 1, 3, 2], [0, 2, 1]),
 #[0, 2, 1, 3], [1, 0, 2]), ([0, 2, 3, 1], [1, 2, 0]),
 #[0, 3, 1, 2], [2, 0, 1]), ([0, 3, 2, 1], [2, 1, 0])])
        # XXX Test to make sure we are working as a generator expression

 #ef test_genlet_simple(self):
 #or g in g1, g2, g3:
 #een = []
 #or _ in range(3):
 #or j in g(5, seen):
 #een.append(j)
 #elf.assertEqual(seen, 3 * [1, 0, 2, 1, 3, 2, 4, 3, 5, 4])

 #ef test_genlet_bad(self):
 #ry:
 #ield(10)
 #xcept RuntimeError:
 #ass

 #ef test_nested_genlets(self):
 #een = []
 #or ii in ax(5):
 #een.append(ii)
