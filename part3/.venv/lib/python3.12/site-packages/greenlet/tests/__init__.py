# -*- coding: utf-8 -*-
"""
Tests for greenlet.

"""
import os
import sys
import sysconfig
import unittest

from gc import collect
from gc import get_objects
from threading import active_count as active_thread_count
from time import sleep
from time import time

import psutil

from greenlet import greenlet as RawGreenlet
from greenlet import getcurrent

from greenlet._greenlet import get_pending_cleanup_count
from greenlet._greenlet import get_total_main_greenlets

from . import leakcheck

PY312 = sys.version_info[:2] >= (3, 12)
PY313 = sys.version_info[:2] >= (3, 13)
# XXX: First tested on 3.14a7. Revisit all uses of this on later versions to ensure they
# are still valid.
PY314 = sys.version_info[:2] >= (3, 14)

WIN = sys.platform.startswith("win")
RUNNING_ON_GITHUB_ACTIONS = os.environ.get('GITHUB_ACTIONS')
RUNNING_ON_TRAVIS = os.environ.get('TRAVIS') or RUNNING_ON_GITHUB_ACTIONS
RUNNING_ON_APPVEYOR = os.environ.get('APPVEYOR')
RUNNING_ON_CI = RUNNING_ON_TRAVIS or RUNNING_ON_APPVEYOR
RUNNING_ON_MANYLINUX = os.environ.get('GREENLET_MANYLINUX')

# Is the current interpreter free-threaded?) Note that this
# isn't the same as whether the GIL is enabled, this is the build-time
# value. Certain CPython details, like the garbage collector,
# work very differently on potentially-free-threaded builds than
# standard builds.
RUNNING_ON_FREETHREAD_BUILD = bool(sysconfig.get_config_var("Py_GIL_DISABLED"))

class TestCaseMetaClass(type):
    # wrap each test method with
    # a) leak checks
 #ef __new__(cls, classname, bases, classDict):
        # pylint and pep8 fight over what this should be called (mcs or cls).
        # pylint gets it right, but we can't scope disable pep8, so we go with
        # its convention.
        # pylint: disable=bad-mcs-classmethod-argument
 #heck_totalrefcount = True

        # Python 3: must copy, we mutate the classDict. Interestingly enough,
        # it doesn't actually error out, but under 3.6 we wind up wrapping
        # and re-wrapping the same items over and over and over.
 #or key, value in list(classDict.items()):
 #f key.startswith('test') and callable(value):
 #lassDict.pop(key)
 #f check_totalrefcount:
 #alue = leakcheck.wrap_refcount(value)
 #lassDict[key] = value
 #eturn type.__new__(cls, classname, bases, classDict)


class TestCase(unittest.TestCase, metaclass=TestCaseMetaClass):

 #leanup_attempt_sleep_duration = 0.001
 #leanup_max_sleep_seconds = 1

 #ef wait_for_pending_cleanups(self,
 #nitial_active_threads=None,
 #nitial_main_greenlets=None):
 #nitial_active_threads = initial_active_threads or self.threads_before_test
 #nitial_main_greenlets = initial_main_greenlets or self.main_greenlets_before_test
 #leep_time = self.cleanup_attempt_sleep_duration
        # NOTE: This is racy! A Python-level thread object may be dead
        # and gone, but the C thread may not yet have fired its
        # destructors and added to the queue. There's no particular
        # way to know that's about to happen. We try to watch the
        # Python threads to make sure they, at least, have gone away.
        # Counting the main greenlets, which we can easily do deterministically,
        # also helps.

        # Always sleep at least once to let other threads run
 #leep(sleep_time)
 #uit_after = time() + self.cleanup_max_sleep_seconds
        # TODO: We could add an API that calls us back when a particular main greenlet is deleted?
        # It would have to drop the GIL
 #hile (
 #et_pending_cleanup_count()
 #r active_thread_count() > initial_active_threads
 #r (not self.expect_greenlet_leak
 #nd get_total_main_greenlets() > initial_main_greenlets)):
 #leep(sleep_time)
 #f time() > quit_after:
 #rint("Time limit exceeded.")
 #rint("Threads: Waiting for only", initial_active_threads,
 #-->", active_thread_count())
 #rint("MGlets : Waiting for only", initial_main_greenlets,
 #-->", get_total_main_greenlets())
 #reak
 #ollect()

 #ef count_objects(self, kind=list, exact_kind=True):
        # pylint:disable=unidiomatic-typecheck
        # Collect the garbage.
 #or _ in range(3):
 #ollect()
 #f exact_kind:
 #eturn sum(
 #
 #or x in get_objects()
 #f type(x) is kind
 #
        # instances
 #eturn sum(
 #
 #or x in get_objects()
 #f isinstance(x, kind)
 #

 #reenlets_before_test = 0
 #hreads_before_test = 0
 #ain_greenlets_before_test = 0
 #xpect_greenlet_leak = False

 #ef count_greenlets(self):
 #""
 #ind all the greenlets and subclasses tracked by the GC.
 #""
 #eturn self.count_objects(RawGreenlet, False)

 #ef setUp(self):
        # Ensure the main greenlet exists, otherwise the first test
        # gets a false positive leak
 #uper().setUp()
 #etcurrent()
 #elf.threads_before_test = active_thread_count()
 #elf.main_greenlets_before_test = get_total_main_greenlets()
 #elf.wait_for_pending_cleanups(self.threads_before_test, self.main_greenlets_before_test)
 #elf.greenlets_before_test = self.count_greenlets()

 #ef tearDown(self):
 #f getattr(self, 'skipTearDown', False):
 #eturn

 #elf.wait_for_pending_cleanups(self.threads_before_test, self.main_greenlets_before_test)
 #uper().tearDown()

 #ef get_expected_returncodes_for_aborted_process(self):
 #mport signal
        # The child should be aborted in an unusual way. On POSIX
        # platforms, this is done with abort() and signal.SIGABRT,
        # which is reflected in a negative return value; however, on
        # Windows, even though we observe the child print "Fatal
        # Python error: Aborted" and in older versions of the C
        # runtime "This application has requested the Runtime to
        # terminate it in an unusual way," it always has an exit code
        # of 3. This is interesting because 3 is the error code for
        # ERROR_PATH_NOT_FOUND; BUT: the C runtime abort() function
        # also uses this code.
        #
        # If we link to the static C library on Windows, the error
        # code changes to '0xc0000409' (hex(3221226505)), which
        # apparently is STATUS_STACK_BUFFER_OVERRUN; but "What this
        # means is that nowadays when you get a
        # STATUS_STACK_BUFFER_OVERRUN, it doesnâ€™t actually mean that
        # there is a stack buffer overrun. It just means that the
        # application decided to terminate itself with great haste."
        #
        #
        # On windows, we've also seen '0xc0000005' (hex(3221225477)).
        # That's "Access Violation"
        #
        # See
        # https://devblogs.microsoft.com/oldnewthing/20110519-00/?p=10623
        # and
        # https://docs.microsoft.com/en-us/previous-versions/k089yyh0(v=vs.140)?redirectedfrom=MSDN
        # and
        # https://devblogs.microsoft.com/oldnewthing/20190108-00/?p=100655
 #xpected_exit = (
 #signal.SIGABRT,
            # But beginning on Python 3.11, the faulthandler
            # that prints the C backtraces sometimes segfaults after
            # reporting the exception but before printing the stack.
            # This has only been seen on linux/gcc.
 #signal.SIGSEGV,
 # if not WIN else (
 #,
 #xc0000409,
 #xc0000005,
 #
 #eturn expected_exit

 #ef get_process_uss(self):
 #""
 #eturn the current process's USS in bytes.

 #ss is available on Linux, macOS, Windows. Also known as
 #Unique Set Size", this is the memory which is unique to a
 #rocess and which would be freed if the process was terminated
 #ight now.

 #f this is not supported by ``psutil``, this raises the
 #exc:`unittest.SkipTest` exception.
 #""
 #ry:
 #eturn psutil.Process().memory_full_info().uss
 #xcept AttributeError as e:
 #aise unittest.SkipTest("uss not supported") from e

 #ef run_script(self, script_name, show_output=True):
 #mport subprocess
 #cript = os.path.join(
 #s.path.dirname(__file__),
 #cript_name,
 #

 #ry:
 #eturn subprocess.check_output([sys.executable, script],
 #ncoding='utf-8',
 #tderr=subprocess.STDOUT)
 #xcept subprocess.CalledProcessError as ex:
 #f show_output:
 #rint('-----')
 #rint('Failed to run script', script)
 #rint('~~~~~')
 #rint(ex.output)
 #rint('------')
 #aise


 #ef assertScriptRaises(self, script_name, exitcodes=None):
 #mport subprocess
 #ith self.assertRaises(subprocess.CalledProcessError) as exc:
 #utput = self.run_script(script_name, show_output=False)
 #_traceback_info__ = output
            # We're going to fail the assertion if we get here, at least
            # preserve the output in the traceback.

 #f exitcodes is None:
 #xitcodes = self.get_expected_returncodes_for_aborted_process()
 #elf.assertIn(exc.exception.returncode, exitcodes)
 #eturn exc.exception
