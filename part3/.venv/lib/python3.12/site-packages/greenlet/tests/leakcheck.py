# Copyright (c) 2018 gevent community
# Copyright (c) 2021 greenlet community
#
# This was originally part of gevent's test suite. The main author
# (Jason Madden) vendored a copy of it into greenlet.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
from __future__ import print_function

import os
import sys
import gc

from functools import wraps
import unittest


import objgraph

# graphviz 0.18 (Nov 7 2021), available only on Python 3.6 and newer,
# has added type hints (sigh). It wants to use ``typing.Literal`` for
# some stuff, but that's only available on Python 3.9+. If that's not
# found, it creates a ``unittest.mock.MagicMock`` object and annotates
# with that. These are GC'able objects, and doing almost *anything*
# with them results in an explosion of objects. For example, trying to
# compare them for equality creates new objects. This causes our
# leakchecks to fail, with reports like:
#
# greenlet.tests.leakcheck.LeakCheckError: refcount increased by [337, 1333, 343, 430, 530, 643, 769]
# _Call          1820      +546
# dict           4094       +76
# MagicProxy      585       +73
# tuple          2693       +66
# _CallList        24        +3
# weakref        1441        +1
# function       5996        +1
# type            736        +1
# cell            592        +1
# MagicMock         8        +1
#
# To avoid this, we *could* filter this type of object out early. In
# principle it could leak, but we don't use mocks in greenlet, so it
# doesn't leak from us. However, a further issue is that ``MagicMock``
# objects have subobjects that are also GC'able, like ``_Call``, and
# those create new mocks of their own too. So we'd have to filter them
# as well, and they're not public. That's OK, we can workaround the
# problem by being very careful to never compare by equality or other
# user-defined operators, only using object identity or other builtin
# functions.

RUNNING_ON_GITHUB_ACTIONS = os.environ.get('GITHUB_ACTIONS')
RUNNING_ON_TRAVIS = os.environ.get('TRAVIS') or RUNNING_ON_GITHUB_ACTIONS
RUNNING_ON_APPVEYOR = os.environ.get('APPVEYOR')
RUNNING_ON_CI = RUNNING_ON_TRAVIS or RUNNING_ON_APPVEYOR
RUNNING_ON_MANYLINUX = os.environ.get('GREENLET_MANYLINUX')
SKIP_LEAKCHECKS = RUNNING_ON_MANYLINUX or os.environ.get('GREENLET_SKIP_LEAKCHECKS')
SKIP_FAILING_LEAKCHECKS = os.environ.get('GREENLET_SKIP_FAILING_LEAKCHECKS')
ONLY_FAILING_LEAKCHECKS = os.environ.get('GREENLET_ONLY_FAILING_LEAKCHECKS')

def ignores_leakcheck(func):
 #""
 #gnore the given object during leakchecks.

 #an be applied to a method, in which case the method will run, but
 #ill not be subject to leak checks.

 #f applied to a class, the entire class will be skipped during leakchecks. This
 #s intended to be used for classes that are very slow and cause problems such as
 #est timeouts; typically it will be used for classes that are subclasses of a base
 #lass and specify variants of behaviour (such as pool sizes).
 #""
 #unc.ignore_leakcheck = True
 #eturn func

def fails_leakcheck(func):
 #""
 #ark that the function is known to leak.
 #""
 #unc.fails_leakcheck = True
 #f SKIP_FAILING_LEAKCHECKS:
 #unc = unittest.skip("Skipping known failures")(func)
 #eturn func

class LeakCheckError(AssertionError):
 #ass

if hasattr(sys, 'getobjects'):
    # In a Python build with ``--with-trace-refs``, make objgraph
    # trace *all* the objects, not just those that are tracked by the
    # GC
 #lass _MockGC(object):
 #ef get_objects(self):
 #eturn sys.getobjects(0) # pylint:disable=no-member
 #ef __getattr__(self, name):
 #eturn getattr(gc, name)
 #bjgraph.gc = _MockGC()
 #ails_strict_leakcheck = fails_leakcheck
else:
 #ef fails_strict_leakcheck(func):
 #""
 #ecorator for a function that is known to fail when running
 #trict (``sys.getobjects()``) leakchecks.

 #his type of leakcheck finds all objects, even those, such as
 #trings, which are not tracked by the garbage collector.
 #""
 #eturn func

class ignores_types_in_strict_leakcheck(object):
 #ef __init__(self, types):
 #elf.types = types
 #ef __call__(self, func):
 #unc.leakcheck_ignore_types = self.types
 #eturn func

class _RefCountChecker(object):

    # Some builtin things that we ignore
    # XXX: Those things were ignored by gevent, but they're important here,
    # presumably.
 #GNORED_TYPES = () #(tuple, dict, types.FrameType, types.TracebackType)

    # Names of types that should be ignored. Use this when we cannot
    # or don't want to import the class directly.
 #GNORED_TYPE_NAMES = (
        # This appears in Python3.14 with the JIT enabled. It
        # doesn't seem to be directly exposed to Python; the only way to get
        # one is to cause code to get jitted and then look for all objects
        # and find one with this name. But they multiply as code
        # executes and gets jitted, in ways we don't want to rely on.
        # So just ignore it.
 #uop_executor',
 #

 #ef __init__(self, testcase, function):
 #elf.testcase = testcase
 #elf.function = function
 #elf.deltas = []
 #elf.peak_stats = {}
 #elf.ignored_types = ()

        # The very first time we are called, we have already been
        # self.setUp() by the test runner, so we don't need to do it again.
 #elf.needs_setUp = False

 #ef _include_object_p(self, obj):
        # pylint:disable=too-many-return-statements
        #
        # See the comment block at the top. We must be careful to
        # avoid invoking user-defined operations.
 #f obj is self:
 #eturn False
 #ind = type(obj)
        # ``self._include_object_p == obj`` returns NotImplemented
        # for non-function objects, which causes the interpreter
        # to try to reverse the order of arguments...which leads
        # to the explosion of mock objects. We don't want that, so we implement
        # the check manually.
 #f kind == type(self._include_object_p):
 #ry:
                # pylint:disable=not-callable
 #xact_method_equals = self._include_object_p.__eq__(obj)
 #xcept AttributeError:
                # Python 2.7 methods may only have __cmp__, and that raises a
                # TypeError for non-method arguments
                # pylint:disable=no-member
 #xact_method_equals = self._include_object_p.__cmp__(obj) == 0

 #f exact_method_equals is not NotImplemented and exact_method_equals:
 #eturn False

        # Similarly, we need to check identity in our __dict__ to avoid mock explosions.
 #or x in self.__dict__.values():
 #f obj is x:
 #eturn False


 #f (
 #ind in self.ignored_types
 #r kind in self.IGNORED_TYPES
 #r kind.__name__ in self.IGNORED_TYPE_NAMES
 #:
 #eturn False


 #eturn True

 #ef _growth(self):
 #eturn objgraph.growth(limit=None, peak_stats=self.peak_stats,
 #ilter=self._include_object_p)

 #ef _report_diff(self, growth):
 #f not growth:
 #eturn "<Unable to calculate growth>"

 #ines = []
 #idth = max(len(name) for name, _, _ in growth)
 #or name, count, delta in growth:
 #ines.append('%-*s%9d %+9d' % (width, name, count, delta))

 #iff = '\n'.join(lines)
 #eturn diff


 #ef _run_test(self, args, kwargs):
 #c_enabled = gc.isenabled()
 #c.disable()

 #f self.needs_setUp:
 #elf.testcase.setUp()
 #elf.testcase.skipTearDown = False
 #ry:
 #elf.function(self.testcase, *args, **kwargs)
 #inally:
 #elf.testcase.tearDown()
 #elf.testcase.doCleanups()
 #elf.testcase.skipTearDown = True
 #elf.needs_setUp = True
 #f gc_enabled:
 #c.enable()

 #ef _growth_after(self):
        # Grab post snapshot
        # pylint:disable=no-member
 #f 'urlparse' in sys.modules:
 #ys.modules['urlparse'].clear_cache()
 #f 'urllib.parse' in sys.modules:
 #ys.modules['urllib.parse'].clear_cache()

 #eturn self._growth()

 #ef _check_deltas(self, growth):
        # Return false when we have decided there is no leak,
        # true if we should keep looping, raises an assertion
        # if we have decided there is a leak.

 #eltas = self.deltas
 #f not deltas:
            # We haven't run yet, no data, keep looping
 #eturn True

 #f gc.garbage:
 #aise LeakCheckError("Generated uncollectable garbage %r" % (gc.garbage,))


        # the following configurations are classified as "no leak"
        # [0, 0]
        # [x, 0, 0]
        # [... a, b, c, d]  where a+b+c+d = 0
        #
        # the following configurations are classified as "leak"
        # [... z, z, z]  where z > 0

 #f deltas[-2:] == [0, 0] and len(deltas) in (2, 3):
 #eturn False

 #f deltas[-3:] == [0, 0, 0]:
 #eturn False

 #f len(deltas) >= 4 and sum(deltas[-4:]) == 0:
 #eturn False

 #f len(deltas) >= 3 and deltas[-1] > 0 and deltas[-1] == deltas[-2] and deltas[-2] == deltas[-3]:
 #iff = self._report_diff(growth)
 #aise LeakCheckError('refcount increased by %r\n%s' % (deltas, diff))

        # OK, we don't know for sure yet. Let's search for more
 #f sum(deltas[-3:]) <= 0 or sum(deltas[-4:]) <= 0 or deltas[-4:].count(0) >= 2:
            # this is suspicious, so give a few more runs
 #imit = 11
 #lse:
 #imit = 7
 #f len(deltas) >= limit:
 #aise LeakCheckError('refcount increased by %r\n%s'
 # (deltas,
 #elf._report_diff(growth)))

        # We couldn't decide yet, keep going
 #eturn True

 #ef __call__(self, args, kwargs):
 #or _ in range(3):
 #c.collect()

 #xpect_failure = getattr(self.function, 'fails_leakcheck', False)
 #f expect_failure:
 #elf.testcase.expect_greenlet_leak = True
 #elf.ignored_types = getattr(self.function, "leakcheck_ignore_types", ())

        # Capture state before; the incremental will be
        # updated by each call to _growth_after
 #rowth = self._growth()

 #ry:
 #hile self._check_deltas(growth):
 #elf._run_test(args, kwargs)

 #rowth = self._growth_after()

 #elf.deltas.append(sum((stat[2] for stat in growth)))
 #xcept LeakCheckError:
 #f not expect_failure:
 #aise
 #lse:
 #f expect_failure:
 #aise LeakCheckError("Expected %s to leak but it did not." % (self.function,))

def wrap_refcount(method):
 #f getattr(method, 'ignore_leakcheck', False) or SKIP_LEAKCHECKS:
 #eturn method

 #wraps(method)
 #ef wrapper(self, *args, **kwargs): # pylint:disable=too-many-branches
 #f getattr(self, 'ignore_leakcheck', False):
 #aise unittest.SkipTest("This class ignored during leakchecks")
 #f ONLY_FAILING_LEAKCHECKS and not getattr(method, 'fails_leakcheck', False):
 #aise unittest.SkipTest("Only running tests that fail leakchecks.")
 #eturn _RefCountChecker(self, method)(args, kwargs)

 #eturn wrapper
