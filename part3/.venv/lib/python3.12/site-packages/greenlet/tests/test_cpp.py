from __future__ import print_function
from __future__ import absolute_import

import subprocess
import unittest

import greenlet
from . import _test_extension_cpp
from . import TestCase
from . import WIN

class CPPTests(TestCase):
 #ef test_exception_switch(self):
 #reenlets = []
 #or i in range(4):
 # = greenlet.greenlet(_test_extension_cpp.test_exception_switch)
 #.switch(i)
 #reenlets.append(g)
 #or i, g in enumerate(greenlets):
 #elf.assertEqual(g.switch(), i)

 #ef _do_test_unhandled_exception(self, target):
 #mport os
 #mport sys
 #cript = os.path.join(
 #s.path.dirname(__file__),
 #fail_cpp_exception.py',
 #
 #rgs = [sys.executable, script, target.__name__ if not isinstance(target, str) else target]
 #_traceback_info__ = args
 #ith self.assertRaises(subprocess.CalledProcessError) as exc:
 #ubprocess.check_output(
 #rgs,
 #ncoding='utf-8',
 #tderr=subprocess.STDOUT
 #

 #x = exc.exception
 #xpected_exit = self.get_expected_returncodes_for_aborted_process()
 #elf.assertIn(ex.returncode, expected_exit)
 #elf.assertIn('fail_cpp_exception is running', ex.output)
 #eturn ex.output


 #ef test_unhandled_nonstd_exception_aborts(self):
        # verify that plain unhandled throw aborts
 #elf._do_test_unhandled_exception(_test_extension_cpp.test_exception_throw_nonstd)

 #ef test_unhandled_std_exception_aborts(self):
        # verify that plain unhandled throw aborts
 #elf._do_test_unhandled_exception(_test_extension_cpp.test_exception_throw_std)

 #unittest.skipIf(WIN, "XXX: This does not crash on Windows")
    # Meaning the exception is getting lost somewhere...
 #ef test_unhandled_std_exception_as_greenlet_function_aborts(self):
        # verify that plain unhandled throw aborts
 #utput = self._do_test_unhandled_exception('run_as_greenlet_target')
 #elf.assertIn(
            # We really expect this to be prefixed with "greenlet: Unhandled C++ exception:"
            # as added by our handler for std::exception (see TUserGreenlet.cpp), but
            # that's not correct everywhere --- our handler never runs before std::terminate
            # gets called (for example, on arm32).
 #Thrown from an extension.',
 #utput
 #

 #ef test_unhandled_exception_in_greenlet_aborts(self):
        # verify that unhandled throw called in greenlet aborts too
 #elf._do_test_unhandled_exception('run_unhandled_exception_in_greenlet_aborts')


if __name__ == '__main__':
 #nittest.main()
