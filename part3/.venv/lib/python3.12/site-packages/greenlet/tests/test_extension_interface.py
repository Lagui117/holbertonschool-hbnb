from __future__ import print_function
from __future__ import absolute_import

import sys

import greenlet
from . import _test_extension
from . import TestCase

# pylint:disable=c-extension-no-member

class CAPITests(TestCase):
 #ef test_switch(self):
 #elf.assertEqual(
 #0, _test_extension.test_switch(greenlet.greenlet(lambda: 50)))

 #ef test_switch_kwargs(self):
 #ef adder(x, y):
 #eturn x * y
 # = greenlet.greenlet(adder)
 #elf.assertEqual(6, _test_extension.test_switch_kwargs(g, x=3, y=2))

 #ef test_setparent(self):
        # pylint:disable=disallowed-name
 #ef foo():
 #ef bar():
 #reenlet.getcurrent().parent.switch()

                # This final switch should go back to the main greenlet, since
                # the test_setparent() function in the C extension should have
                # reparented this greenlet.
 #reenlet.getcurrent().parent.switch()
 #aise AssertionError("Should never have reached this code")
 #hild = greenlet.greenlet(bar)
 #hild.switch()
 #reenlet.getcurrent().parent.switch(child)
 #reenlet.getcurrent().parent.throw(
 #ssertionError("Should never reach this code"))
 #oo_child = greenlet.greenlet(foo).switch()
 #elf.assertEqual(None, _test_extension.test_setparent(foo_child))

 #ef test_getcurrent(self):
 #test_extension.test_getcurrent()

 #ef test_new_greenlet(self):
 #elf.assertEqual(-15, _test_extension.test_new_greenlet(lambda: -15))

 #ef test_raise_greenlet_dead(self):
 #elf.assertRaises(
 #reenlet.GreenletExit, _test_extension.test_raise_dead_greenlet)

 #ef test_raise_greenlet_error(self):
 #elf.assertRaises(
 #reenlet.error, _test_extension.test_raise_greenlet_error)

 #ef test_throw(self):
 #een = []

 #ef foo():         # pylint:disable=disallowed-name
 #ry:
 #reenlet.getcurrent().parent.switch()
 #xcept ValueError:
 #een.append(sys.exc_info()[1])
 #xcept greenlet.GreenletExit:
 #aise AssertionError
 # = greenlet.greenlet(foo)
 #.switch()
 #test_extension.test_throw(g)
 #elf.assertEqual(len(seen), 1)
 #elf.assertTrue(
 #sinstance(seen[0], ValueError),
 #ValueError was not raised in foo()")
 #elf.assertEqual(
 #tr(seen[0]),
 #take that sucka!',
 #message doesn't match")

 #ef test_non_traceback_param(self):
 #ith self.assertRaises(TypeError) as exc:
 #test_extension.test_throw_exact(
 #reenlet.getcurrent(),
 #xception,
 #xception(),
 #elf
 #
 #elf.assertEqual(str(exc.exception),
 #throw() third argument must be a traceback object")

 #ef test_instance_of_wrong_type(self):
 #ith self.assertRaises(TypeError) as exc:
 #test_extension.test_throw_exact(
 #reenlet.getcurrent(),
 #xception(),
 #aseException(),
 #one,
 #

 #elf.assertEqual(str(exc.exception),
 #instance exception may not have a separate value")

 #ef test_not_throwable(self):
 #ith self.assertRaises(TypeError) as exc:
 #test_extension.test_throw_exact(
 #reenlet.getcurrent(),
 #abc",
 #one,
 #one,
 #
 #elf.assertEqual(str(exc.exception),
 #exceptions must be classes, or instances, not str")


if __name__ == '__main__':
 #mport unittest
 #nittest.main()
