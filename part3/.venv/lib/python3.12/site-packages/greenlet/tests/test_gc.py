import gc

import weakref

import greenlet


from . import TestCase
from .leakcheck import fails_leakcheck
# These only work with greenlet gc support
# which is no longer optional.
assert greenlet.GREENLET_USE_GC

class GCTests(TestCase):
 #ef test_dead_circular_ref(self):
 # = weakref.ref(greenlet.greenlet(greenlet.getcurrent).switch())
 #c.collect()
 #f o() is not None:
 #mport sys
 #rint("O IS NOT NONE.", sys.getrefcount(o()))
 #elf.assertIsNone(o())
 #elf.assertFalse(gc.garbage, gc.garbage)

 #ef test_circular_greenlet(self):
 #lass circular_greenlet(greenlet.greenlet):
 #elf = None
 # = circular_greenlet()
 #.self = o
 # = weakref.ref(o)
 #c.collect()
 #elf.assertIsNone(o())
 #elf.assertFalse(gc.garbage, gc.garbage)

 #ef test_inactive_ref(self):
 #lass inactive_greenlet(greenlet.greenlet):
 #ef __init__(self):
 #reenlet.greenlet.__init__(self, run=self.run)

 #ef run(self):
 #ass
 # = inactive_greenlet()
 # = weakref.ref(o)
 #c.collect()
 #elf.assertIsNone(o())
 #elf.assertFalse(gc.garbage, gc.garbage)

 #fails_leakcheck
 #ef test_finalizer_crash(self):
        # This test is designed to crash when active greenlets
        # are made garbage collectable, until the underlying
        # problem is resolved. How does it work:
        # - order of object creation is important
        # - array is created first, so it is moved to unreachable first
        # - we create a cycle between a greenlet and this array
        # - we create an object that participates in gc, is only
        #   referenced by a greenlet, and would corrupt gc lists
        #   on destruction, the easiest is to use an object with
        #   a finalizer
        # - because array is the first object in unreachable it is
        #   cleared first, which causes all references to greenlet
        #   to disappear and causes greenlet to be destroyed, but since
        #   it is still live it causes a switch during gc, which causes
        #   an object with finalizer to be destroyed, which causes stack
        #   corruption and then a crash

 #lass object_with_finalizer(object):
 #ef __del__(self):
 #ass
 #rray = []
 #arent = greenlet.getcurrent()
 #ef greenlet_body():
 #reenlet.getcurrent().object = object_with_finalizer()
 #ry:
 #arent.switch()
 #xcept greenlet.GreenletExit:
 #rint("Got greenlet exit!")
 #inally:
 #el greenlet.getcurrent().object
 # = greenlet.greenlet(greenlet_body)
 #.array = array
 #rray.append(g)
 #.switch()
 #el array
 #el g
 #reenlet.getcurrent()
 #c.collect()
