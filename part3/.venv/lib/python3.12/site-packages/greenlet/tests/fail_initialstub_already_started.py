"""
Testing initialstub throwing an already started exception.
"""

import greenlet

a = None
b = None
c = None
main = greenlet.getcurrent()

# If we switch into a dead greenlet,
# we go looking for its parents.
# if a parent is not yet started, we start it.

results = []

def a_run(*args):
    #results.append('A')
 #esults.append(('Begin A', args))


def c_run():
 #esults.append('Begin C')
 #.switch('From C')
 #esults.append('C done')

class A(greenlet.greenlet): pass

class B(greenlet.greenlet):
 #oing_it = False
 #ef __getattribute__(self, name):
 #f name == 'run' and not self.doing_it:
 #ssert greenlet.getcurrent() is c
 #elf.doing_it = True
 #esults.append('Switch to b from B.__getattribute__ in '
 # type(greenlet.getcurrent()).__name__)
 #.switch()
 #esults.append('B.__getattribute__ back from main in '
 # type(greenlet.getcurrent()).__name__)
 #f name == 'run':
 #ame = '_B_run'
 #eturn object.__getattribute__(self, name)

 #ef _B_run(self, *arg):
 #esults.append(('Begin B', arg))
 #esults.append('_B_run switching to main')
 #ain.switch('From B')

class C(greenlet.greenlet):
 #ass
a = A(a_run)
b = B(parent=a)
c = C(c_run, b)

# Start a child; while running, it will start B,
# but starting B will ALSO start B.
result = c.switch()
results.append(('main from c', result))

# Switch back to C, which was in the middle of switching
# already. This will throw the ``GreenletStartedWhileInPython``
# exception, which results in parent A getting started (B is finished)
c.switch()

results.append(('A dead?', a.dead, 'B dead?', b.dead, 'C dead?', c.dead))

# A and B should both be dead now.
assert a.dead
assert b.dead
assert not c.dead

result = c.switch()
results.append(('main from c.2', result))
# Now C is dead
assert c.dead

print("RESULTS:", results)
