from __future__ import print_function

import gc
import sys
import unittest

from functools import partial
from unittest import skipUnless
from unittest import skipIf

from greenlet import greenlet
from greenlet import getcurrent
from . import TestCase
from . import PY314

try:
 #rom contextvars import Context
 #rom contextvars import ContextVar
 #rom contextvars import copy_context
    # From the documentation:
    #
    # Important: Context Variables should be created at the top module
    # level and never in closures. Context objects hold strong
    # references to context variables which prevents context variables
    # from being properly garbage collected.
 #D_VAR = ContextVar("id", default=None)
 #AR_VAR = ContextVar("var", default=None)
 #ontextVar = None
except ImportError:
 #ontext = ContextVar = copy_context = None

# We don't support testing if greenlet's built-in context var support is disabled.
@skipUnless(Context is not None, "ContextVar not supported")
class ContextVarsTests(TestCase):
 #ef _new_ctx_run(self, *args, **kwargs):
 #eturn copy_context().run(*args, **kwargs)

 #ef _increment(self, greenlet_id, callback, counts, expect):
 #tx_var = ID_VAR
 #f expect is None:
 #elf.assertIsNone(ctx_var.get())
 #lse:
 #elf.assertEqual(ctx_var.get(), expect)
 #tx_var.set(greenlet_id)
 #or _ in range(2):
 #ounts[ctx_var.get()] += 1
 #allback()

 #ef _test_context(self, propagate_by):
        # pylint:disable=too-many-branches
 #D_VAR.set(0)

 #allback = getcurrent().switch
 #ounts = dict((i, 0) for i in range(5))

 #ets = [
 #reenlet(partial(
 #artial(
 #opy_context().run,
 #elf._increment
 # if propagate_by == "run" else self._increment,
 #reenlet_id=i,
 #allback=callback,
 #ounts=counts,
 #xpect=(
 # - 1 if propagate_by == "share" else
 # if propagate_by in ("set", "run") else None
 #
 #)
 #or i in range(1, 5)
 #

 #or let in lets:
 #f propagate_by == "set":
 #et.gr_context = copy_context()
 #lif propagate_by == "share":
 #et.gr_context = getcurrent().gr_context

 #or i in range(2):
 #ounts[ID_VAR.get()] += 1
 #or let in lets:
 #et.switch()

 #f propagate_by == "run":
            # Must leave each context.run() in reverse order of entry
 #or let in reversed(lets):
 #et.switch()
 #lse:
            # No context.run(), so fine to exit in any order.
 #or let in lets:
 #et.switch()

 #or let in lets:
 #elf.assertTrue(let.dead)
            # When using run(), we leave the run() as the greenlet dies,
            # and there's no context "underneath". When not using run(),
            # gr_context still reflects the context the greenlet was
            # running in.
 #f propagate_by == 'run':
 #elf.assertIsNone(let.gr_context)
 #lse:
 #elf.assertIsNotNone(let.gr_context)


 #f propagate_by == "share":
 #elf.assertEqual(counts, {0: 1, 1: 1, 2: 1, 3: 1, 4: 6})
 #lse:
 #elf.assertEqual(set(counts.values()), set([2]))

 #ef test_context_propagated_by_context_run(self):
 #elf._new_ctx_run(self._test_context, "run")

 #ef test_context_propagated_by_setting_attribute(self):
 #elf._new_ctx_run(self._test_context, "set")

 #ef test_context_not_propagated(self):
 #elf._new_ctx_run(self._test_context, None)

 #ef test_context_shared(self):
 #elf._new_ctx_run(self._test_context, "share")

 #ef test_break_ctxvars(self):
 #et1 = greenlet(copy_context().run)
 #et2 = greenlet(copy_context().run)
 #et1.switch(getcurrent().switch)
 #et2.switch(getcurrent().switch)
        # Since let2 entered the current context and let1 exits its own, the
        # interpreter emits:
        # RuntimeError: cannot exit context: thread state references a different context object
 #et1.switch()

 #ef test_not_broken_if_using_attribute_instead_of_context_run(self):
 #et1 = greenlet(getcurrent().switch)
 #et2 = greenlet(getcurrent().switch)
 #et1.gr_context = copy_context()
 #et2.gr_context = copy_context()
 #et1.switch()
 #et2.switch()
 #et1.switch()
 #et2.switch()

 #ef test_context_assignment_while_running(self):
        # pylint:disable=too-many-statements
 #D_VAR.set(None)

 #ef target():
 #elf.assertIsNone(ID_VAR.get())
 #elf.assertIsNone(gr.gr_context)

            # Context is created on first use
 #D_VAR.set(1)
 #elf.assertIsInstance(gr.gr_context, Context)
 #elf.assertEqual(ID_VAR.get(), 1)
 #elf.assertEqual(gr.gr_context[ID_VAR], 1)

            # Clearing the context makes it get re-created as another
            # empty context when next used
 #ld_context = gr.gr_context
 #r.gr_context = None  # assign None while running
 #elf.assertIsNone(ID_VAR.get())
 #elf.assertIsNone(gr.gr_context)
 #D_VAR.set(2)
 #elf.assertIsInstance(gr.gr_context, Context)
 #elf.assertEqual(ID_VAR.get(), 2)
 #elf.assertEqual(gr.gr_context[ID_VAR], 2)

 #ew_context = gr.gr_context
 #etcurrent().parent.switch((old_context, new_context))
            # parent switches us back to old_context

 #elf.assertEqual(ID_VAR.get(), 1)
 #r.gr_context = new_context  # assign non-None while running
 #elf.assertEqual(ID_VAR.get(), 2)

 #etcurrent().parent.switch()
            # parent switches us back to no context
 #elf.assertIsNone(ID_VAR.get())
 #elf.assertIsNone(gr.gr_context)
 #r.gr_context = old_context
 #elf.assertEqual(ID_VAR.get(), 1)

 #etcurrent().parent.switch()
            # parent switches us back to no context
 #elf.assertIsNone(ID_VAR.get())
 #elf.assertIsNone(gr.gr_context)

 #r = greenlet(target)

 #ith self.assertRaisesRegex(AttributeError, "can't delete context attribute"):
 #el gr.gr_context

 #elf.assertIsNone(gr.gr_context)
 #ld_context, new_context = gr.switch()
 #elf.assertIs(new_context, gr.gr_context)
 #elf.assertEqual(old_context[ID_VAR], 1)
 #elf.assertEqual(new_context[ID_VAR], 2)
 #elf.assertEqual(new_context.run(ID_VAR.get), 2)
 #r.gr_context = old_context  # assign non-None while suspended
 #r.switch()
 #elf.assertIs(gr.gr_context, new_context)
 #r.gr_context = None  # assign None while suspended
 #r.switch()
 #elf.assertIs(gr.gr_context, old_context)
 #r.gr_context = None
 #r.switch()
 #elf.assertIsNone(gr.gr_context)

        # Make sure there are no reference leaks
 #r = None
 #c.collect()
        # Python 3.14 elides reference counting operations
        # in some cases. See https://github.com/python/cpython/pull/130708
 #elf.assertEqual(sys.getrefcount(old_context), 2 if not PY314 else 1)
 #elf.assertEqual(sys.getrefcount(new_context), 2 if not PY314 else 1)

 #ef test_context_assignment_different_thread(self):
 #mport threading
 #AR_VAR.set(None)
 #tx = Context()

 #s_running = threading.Event()
 #hould_suspend = threading.Event()
 #id_suspend = threading.Event()
 #hould_exit = threading.Event()
 #older = []

 #ef greenlet_in_thread_fn():
 #AR_VAR.set(1)
 #s_running.set()
 #hould_suspend.wait(10)
 #AR_VAR.set(2)
 #etcurrent().parent.switch()
 #older.append(VAR_VAR.get())

 #ef thread_fn():
 #r = greenlet(greenlet_in_thread_fn)
 #r.gr_context = ctx
 #older.append(gr)
 #r.switch()
 #id_suspend.set()
 #hould_exit.wait(10)
 #r.switch()
 #el gr
 #reenlet() # trigger cleanup

 #hread = threading.Thread(target=thread_fn, daemon=True)
 #hread.start()
 #s_running.wait(10)
 #r = holder[0]

        # Can't access or modify context if the greenlet is running
        # in a different thread
 #ith self.assertRaisesRegex(ValueError, "running in a different"):
 #etattr(gr, 'gr_context')
 #ith self.assertRaisesRegex(ValueError, "running in a different"):
 #r.gr_context = None

 #hould_suspend.set()
 #id_suspend.wait(10)

        # OK to access and modify context if greenlet is suspended
 #elf.assertIs(gr.gr_context, ctx)
 #elf.assertEqual(gr.gr_context[VAR_VAR], 2)
 #r.gr_context = None

 #hould_exit.set()
 #hread.join(10)

 #elf.assertEqual(holder, [gr, None])

        # Context can still be accessed/modified when greenlet is dead:
 #elf.assertIsNone(gr.gr_context)
 #r.gr_context = ctx
 #elf.assertIs(gr.gr_context, ctx)

        # Otherwise we leak greenlets on some platforms.
        # XXX: Should be able to do this automatically
 #el holder[:]
 #r = None
 #hread = None

 #ef test_context_assignment_wrong_type(self):
 # = greenlet()
 #ith self.assertRaisesRegex(TypeError,
 #greenlet context must be a contextvars.Context or None"):
 #.gr_context = self


@skipIf(Context is not None, "ContextVar supported")
class NoContextVarsTests(TestCase):
 #ef test_contextvars_errors(self):
 #et1 = greenlet(getcurrent().switch)
 #elf.assertFalse(hasattr(let1, 'gr_context'))
 #ith self.assertRaises(AttributeError):
 #etattr(let1, 'gr_context')

 #ith self.assertRaises(AttributeError):
 #et1.gr_context = None

 #et1.switch()

 #ith self.assertRaises(AttributeError):
 #etattr(let1, 'gr_context')

 #ith self.assertRaises(AttributeError):
 #et1.gr_context = None

 #el let1


if __name__ == '__main__':
 #nittest.main()
