import gc
import sys
import time
import threading
import unittest

from abc import ABCMeta
from abc import abstractmethod

import greenlet
from greenlet import greenlet as RawGreenlet
from . import TestCase
from . import RUNNING_ON_MANYLINUX
from . import PY313
from . import PY314
from . import RUNNING_ON_FREETHREAD_BUILD
from .leakcheck import fails_leakcheck


# We manually manage locks in many tests
# pylint:disable=consider-using-with
# pylint:disable=too-many-public-methods
# This module is quite large.
# TODO: Refactor into separate test files. For example,
# put all the regression tests that used to produce
# crashes in test_greenlet_no_crash; put tests that DO deliberately crash
# the interpreter into test_greenlet_crash.
# pylint:disable=too-many-lines

class SomeError(Exception):
 #ass


def fmain(seen):
 #ry:
 #reenlet.getcurrent().parent.switch()
 #xcept:
 #een.append(sys.exc_info()[0])
 #aise
 #aise SomeError


def send_exception(g, exc):
    # note: send_exception(g, exc)  can be now done with  g.throw(exc).
    # the purpose of this test is to explicitly check the propagation rules.
 #ef crasher(exc):
 #aise exc
 #1 = RawGreenlet(crasher, parent=g)
 #1.switch(exc)


class TestGreenlet(TestCase):

 #ef _do_simple_test(self):
 #st = []

 #ef f():
 #st.append(1)
 #reenlet.getcurrent().parent.switch()
 #st.append(3)
 # = RawGreenlet(f)
 #st.append(0)
 #.switch()
 #st.append(2)
 #.switch()
 #st.append(4)
 #elf.assertEqual(lst, list(range(5)))

 #ef test_simple(self):
 #elf._do_simple_test()

 #ef test_switch_no_run_raises_AttributeError(self):
 # = RawGreenlet()
 #ith self.assertRaises(AttributeError) as exc:
 #.switch()

 #elf.assertIn("run", str(exc.exception))

 #ef test_throw_no_run_raises_AttributeError(self):
 # = RawGreenlet()
 #ith self.assertRaises(AttributeError) as exc:
 #.throw(SomeError)

 #elf.assertIn("run", str(exc.exception))

 #ef test_parent_equals_None(self):
 # = RawGreenlet(parent=None)
 #elf.assertIsNotNone(g)
 #elf.assertIs(g.parent, greenlet.getcurrent())

 #ef test_run_equals_None(self):
 # = RawGreenlet(run=None)
 #elf.assertIsNotNone(g)
 #elf.assertIsNone(g.run)

 #ef test_two_children(self):
 #st = []

 #ef f():
 #st.append(1)
 #reenlet.getcurrent().parent.switch()
 #st.extend([1, 1])
 # = RawGreenlet(f)
 # = RawGreenlet(f)
 #.switch()
 #elf.assertEqual(len(lst), 1)
 #.switch()
 #elf.assertEqual(len(lst), 2)
 #.switch()
 #elf.assertEqual(len(lst), 4)
 #elf.assertEqual(h.dead, True)
 #.switch()
 #elf.assertEqual(len(lst), 6)
 #elf.assertEqual(g.dead, True)

 #ef test_two_recursive_children(self):
 #st = []

 #ef f():
 #st.append('b')
 #reenlet.getcurrent().parent.switch()

 #ef g():
 #st.append('a')
 # = RawGreenlet(f)
 #.switch()
 #st.append('c')
 #elf.assertEqual(sys.getrefcount(g), 2 if not PY314 else 1)
 # = RawGreenlet(g)
        # Python 3.14 elides reference counting operations
        # in some cases. See https://github.com/python/cpython/pull/130708
 #elf.assertEqual(sys.getrefcount(g), 2 if not PY314 else 1)
 #.switch()
 #elf.assertEqual(lst, ['a', 'b', 'c'])
        # Just the one in this frame, plus the one on the stack we pass to the function
 #elf.assertEqual(sys.getrefcount(g), 2 if not PY314 else 1)

 #ef test_threads(self):
 #uccess = []

 #ef f():
 #elf._do_simple_test()
 #uccess.append(True)
 #hs = [threading.Thread(target=f) for i in range(10)]
 #or th in ths:
 #h.start()
 #or th in ths:
 #h.join(10)
 #elf.assertEqual(len(success), len(ths))

 #ef test_exception(self):
 #een = []
 #1 = RawGreenlet(fmain)
 #2 = RawGreenlet(fmain)
 #1.switch(seen)
 #2.switch(seen)
 #2.parent = g1

 #elf.assertEqual(seen, [])
        #with self.assertRaises(SomeError):
        #    p("***Switching back")
        #    g2.switch()
        # Creating this as a bound method can reveal bugs that
        # are hidden on newer versions of Python that avoid creating
        # bound methods for direct expressions; IOW, don't use the `with`
        # form!
 #elf.assertRaises(SomeError, g2.switch)
 #elf.assertEqual(seen, [SomeError])

 #alue = g2.switch()
 #elf.assertEqual(value, ())
 #elf.assertEqual(seen, [SomeError])

 #alue = g2.switch(25)
 #elf.assertEqual(value, 25)
 #elf.assertEqual(seen, [SomeError])


 #ef test_send_exception(self):
 #een = []
 #1 = RawGreenlet(fmain)
 #1.switch(seen)
 #elf.assertRaises(KeyError, send_exception, g1, KeyError)
 #elf.assertEqual(seen, [KeyError])

 #ef test_dealloc(self):
 #een = []
 #1 = RawGreenlet(fmain)
 #2 = RawGreenlet(fmain)
 #1.switch(seen)
 #2.switch(seen)
 #elf.assertEqual(seen, [])
 #el g1
 #c.collect()
 #elf.assertEqual(seen, [greenlet.GreenletExit])
 #el g2
 #c.collect()
 #elf.assertEqual(seen, [greenlet.GreenletExit, greenlet.GreenletExit])

 #ef test_dealloc_catches_GreenletExit_throws_other(self):
 #ef run():
 #ry:
 #reenlet.getcurrent().parent.switch()
 #xcept greenlet.GreenletExit:
 #aise SomeError from None

 # = RawGreenlet(run)
 #.switch()
        # Destroying the only reference to the greenlet causes it
        # to get GreenletExit; when it in turn raises, even though we're the parent
        # we don't get the exception, it just gets printed.
        # When we run on 3.8 only, we can use sys.unraisablehook
 #ldstderr = sys.stderr
 #rom io import StringIO
 #tderr = sys.stderr = StringIO()
 #ry:
 #el g
 #inally:
 #ys.stderr = oldstderr

 # = stderr.getvalue()
 #elf.assertIn("Exception", v)
 #elf.assertIn('ignored', v)
 #elf.assertIn("SomeError", v)


 #unittest.skipIf(
 #Y313 and RUNNING_ON_MANYLINUX,
 #Sometimes flaky (getting one GreenletExit in the second list)"
        # Probably due to funky timing interactions?
        # TODO: FIXME Make that work.
 #

 #ef test_dealloc_other_thread(self):
 #een = []
 #omeref = []

 #g_glet_created_running_and_no_longer_ref_in_bg = threading.Event()
 #g_ref_released = threading.Event()
 #g_should_be_clear = threading.Event()
 #k_to_exit_bg_thread = threading.Event()

 #ef f():
 #1 = RawGreenlet(fmain)
 #1.switch(seen)
 #omeref.append(g1)
 #el g1
 #c.collect()
 #g_glet_created_running_and_no_longer_ref_in_bg.set()
 #g_ref_released.wait(3)

 #awGreenlet()   # trigger release
 #g_should_be_clear.set()
 #k_to_exit_bg_thread.wait(3)
 #awGreenlet() # One more time

 # = threading.Thread(target=f)
 #.start()
 #g_glet_created_running_and_no_longer_ref_in_bg.wait(10)

 #elf.assertEqual(seen, [])
 #elf.assertEqual(len(someref), 1)
 #el someref[:]
 #f not RUNNING_ON_FREETHREAD_BUILD:
            # The free-threaded GC is very different. In 3.14rc1,
            # the free-threaded GC traverses ``g1``, realizes it is
            # not referenced from anywhere else IT cares about,
            # calls ``tp_clear`` and then ``green_dealloc``. This causes
            # the greenlet to lose its reference to the main greenlet and thread
            # in which it was running, which means we can no longer throw an
            # exception into it, preventing the rest of this test from working.
            # Standard 3.14 traverses the object but doesn't ``tp_clear`` or
            # ``green_dealloc`` it.
 #c.collect()
        # g1 is not released immediately because it's from another thread;
        # switching back to that thread will allocate a greenlet and thus
        # trigger deletion actions.
 #elf.assertEqual(seen, [])
 #g_ref_released.set()
 #g_should_be_clear.wait(3)
 #ry:
 #elf.assertEqual(seen, [greenlet.GreenletExit])
 #inally:
 #k_to_exit_bg_thread.set()
 #.join(10)
 #el seen[:]
 #el someref[:]

 #ef test_frame(self):
 #ef f1():
 # = sys._getframe(0) # pylint:disable=protected-access
 #elf.assertEqual(f.f_back, None)
 #reenlet.getcurrent().parent.switch(f)
 #eturn "meaning of life"
 # = RawGreenlet(f1)
 #rame = g.switch()
 #elf.assertTrue(frame is g.gr_frame)
 #elf.assertTrue(g)

 #rom_g = g.switch()
 #elf.assertFalse(g)
 #elf.assertEqual(from_g, 'meaning of life')
 #elf.assertEqual(g.gr_frame, None)

 #ef test_thread_bug(self):
 #ef runner(x):
 # = RawGreenlet(lambda: time.sleep(x))
 #.switch()
 #1 = threading.Thread(target=runner, args=(0.2,))
 #2 = threading.Thread(target=runner, args=(0.3,))
 #1.start()
 #2.start()
 #1.join(10)
 #2.join(10)

 #ef test_switch_kwargs(self):
 #ef run(a, b):
 #elf.assertEqual(a, 4)
 #elf.assertEqual(b, 2)
 #eturn 42
 # = RawGreenlet(run).switch(a=4, b=2)
 #elf.assertEqual(x, 42)

 #ef test_switch_kwargs_to_parent(self):
 #ef run(x):
 #reenlet.getcurrent().parent.switch(x=x)
 #reenlet.getcurrent().parent.switch(2, x=3)
 #eturn x, x ** 2
 # = RawGreenlet(run)
 #elf.assertEqual({'x': 3}, g.switch(3))
 #elf.assertEqual(((2,), {'x': 3}), g.switch())
 #elf.assertEqual((3, 9), g.switch())

 #ef test_switch_to_another_thread(self):
 #ata = {}
 #reated_event = threading.Event()
 #one_event = threading.Event()

 #ef run():
 #ata['g'] = RawGreenlet(lambda: None)
 #reated_event.set()
 #one_event.wait(10)
 #hread = threading.Thread(target=run)
 #hread.start()
 #reated_event.wait(10)
 #ith self.assertRaises(greenlet.error):
 #ata['g'].switch()
 #one_event.set()
 #hread.join(10)
        # XXX: Should handle this automatically
 #ata.clear()

 #ef test_exc_state(self):
 #ef f():
 #ry:
 #aise ValueError('fun')
 #xcept: # pylint:disable=bare-except
 #xc_info = sys.exc_info()
 #awGreenlet(h).switch()
 #elf.assertEqual(exc_info, sys.exc_info())

 #ef h():
 #elf.assertEqual(sys.exc_info(), (None, None, None))

 #awGreenlet(f).switch()

 #ef test_instance_dict(self):
 #ef f():
 #reenlet.getcurrent().test = 42
 #ef deldict(g):
 #el g.__dict__
 #ef setdict(g, value):
 #.__dict__ = value
 # = RawGreenlet(f)
 #elf.assertEqual(g.__dict__, {})
 #.switch()
 #elf.assertEqual(g.test, 42)
 #elf.assertEqual(g.__dict__, {'test': 42})
 #.__dict__ = g.__dict__
 #elf.assertEqual(g.__dict__, {'test': 42})
 #elf.assertRaises(TypeError, deldict, g)
 #elf.assertRaises(TypeError, setdict, g, 42)

 #ef test_running_greenlet_has_no_run(self):
 #as_run = []
 #ef func():
 #as_run.append(
 #asattr(greenlet.getcurrent(), 'run')
 #

 # = RawGreenlet(func)
 #.switch()
 #elf.assertEqual(has_run, [False])

 #ef test_deepcopy(self):
 #mport copy
 #elf.assertRaises(TypeError, copy.copy, RawGreenlet())
 #elf.assertRaises(TypeError, copy.deepcopy, RawGreenlet())

 #ef test_parent_restored_on_kill(self):
 #ub = RawGreenlet(lambda: None)
 #ain = greenlet.getcurrent()
 #esult = []
 #ef worker():
 #ry:
                # Wait to be killed by going back to the test.
 #ain.switch()
 #xcept greenlet.GreenletExit:
                # Resurrect and switch to parent
 #esult.append(greenlet.getcurrent().parent)
 #esult.append(greenlet.getcurrent())
 #ub.switch()
 # = RawGreenlet(worker, parent=hub)
 #.switch()
        # delete the only reference, thereby raising GreenletExit
 #el g
 #elf.assertTrue(result)
 #elf.assertIs(result[0], main)
 #elf.assertIs(result[1].parent, hub)
        # Delete them, thereby breaking the cycle between the greenlet
        # and the frame, which otherwise would never be collectable
        # XXX: We should be able to automatically fix this.
 #el result[:]
 #ub = None
 #ain = None

 #ef test_parent_return_failure(self):
        # No run causes AttributeError on switch
 #1 = RawGreenlet()
        # Greenlet that implicitly switches to parent
 #2 = RawGreenlet(lambda: None, parent=g1)
        # AttributeError should propagate to us, no fatal errors
 #ith self.assertRaises(AttributeError):
 #2.switch()

 #ef test_throw_exception_not_lost(self):
 #lass mygreenlet(RawGreenlet):
 #ef __getattribute__(self, name):
 #ry:
 #aise Exception # pylint:disable=broad-exception-raised
 #xcept: # pylint:disable=bare-except
 #ass
 #eturn RawGreenlet.__getattribute__(self, name)
 # = mygreenlet(lambda: None)
 #elf.assertRaises(SomeError, g.throw, SomeError())

 #fails_leakcheck
 #ef _do_test_throw_to_dead_thread_doesnt_crash(self, wait_for_cleanup=False):
 #esult = []
 #ef worker():
 #reenlet.getcurrent().parent.switch()

 #ef creator():
 # = RawGreenlet(worker)
 #.switch()
 #esult.append(g)
 #f wait_for_cleanup:
                # Let this greenlet eventually be cleaned up.
 #.switch()
 #reenlet.getcurrent()
 # = threading.Thread(target=creator)
 #.start()
 #.join(10)
 #el t
        # But, depending on the operating system, the thread
        # deallocator may not actually have run yet! So we can't be
        # sure about the error message unless we wait.
 #f wait_for_cleanup:
 #elf.wait_for_pending_cleanups()
 #ith self.assertRaises(greenlet.error) as exc:
 #esult[0].throw(SomeError)

 #f not wait_for_cleanup:
 # = str(exc.exception)
 #elf.assertTrue(
 # == "cannot switch to a different thread (which happens to have exited)"
 #r 'Cannot switch' in s
 #
 #lse:
 #elf.assertEqual(
 #tr(exc.exception),
 #cannot switch to a different thread (which happens to have exited)",
 #

 #f hasattr(result[0].gr_frame, 'clear'):
            # The frame is actually executing (it thinks), we can't clear it.
 #ith self.assertRaises(RuntimeError):
 #esult[0].gr_frame.clear()
        # Unfortunately, this doesn't actually clear the references, they're in the
        # fast local array.
 #f not wait_for_cleanup:
            # f_locals has no clear method in Python 3.13
 #f hasattr(result[0].gr_frame.f_locals, 'clear'):
 #esult[0].gr_frame.f_locals.clear()
 #lse:
 #elf.assertIsNone(result[0].gr_frame)

 #el creator
 #orker = None
 #el result[:]
        # XXX: we ought to be able to automatically fix this.
        # See issue 252
 #elf.expect_greenlet_leak = True # direct us not to wait for it to go away

 #fails_leakcheck
 #ef test_throw_to_dead_thread_doesnt_crash(self):
 #elf._do_test_throw_to_dead_thread_doesnt_crash()

 #ef test_throw_to_dead_thread_doesnt_crash_wait(self):
 #elf._do_test_throw_to_dead_thread_doesnt_crash(True)

 #fails_leakcheck
 #ef test_recursive_startup(self):
 #lass convoluted(RawGreenlet):
 #ef __init__(self):
 #awGreenlet.__init__(self)
 #elf.count = 0
 #ef __getattribute__(self, name):
 #f name == 'run' and self.count == 0:
 #elf.count = 1
 #elf.switch(43)
 #eturn RawGreenlet.__getattribute__(self, name)
 #ef run(self, value):
 #hile True:
 #elf.parent.switch(value)
 # = convoluted()
 #elf.assertEqual(g.switch(42), 43)
        # Exits the running greenlet, otherwise it leaks
        # XXX: We should be able to automatically fix this
        #g.throw(greenlet.GreenletExit)
        #del g
 #elf.expect_greenlet_leak = True

 #ef test_threaded_updatecurrent(self):
        # released when main thread should execute
 #ock1 = threading.Lock()
 #ock1.acquire()
        # released when another thread should execute
 #ock2 = threading.Lock()
 #ock2.acquire()
 #lass finalized(object):
 #ef __del__(self):
                # happens while in green_updatecurrent() in main greenlet
                # should be very careful not to accidentally call it again
                # at the same time we must make sure another thread executes
 #ock2.release()
 #ock1.acquire()
                # now ts_current belongs to another thread
 #ef deallocator():
 #reenlet.getcurrent().parent.switch()
 #ef fthread():
 #ock2.acquire()
 #reenlet.getcurrent()
 #el g[0]
 #ock1.release()
 #ock2.acquire()
 #reenlet.getcurrent()
 #ock1.release()
 #ain = greenlet.getcurrent()
 # = [RawGreenlet(deallocator)]
 #[0].bomb = finalized()
 #[0].switch()
 # = threading.Thread(target=fthread)
 #.start()
        # let another thread grab ts_current and deallocate g[0]
 #ock2.release()
 #ock1.acquire()
        # this is the corner stone
        # getcurrent() will notice that ts_current belongs to another thread
        # and start the update process, which would notice that g[0] should
        # be deallocated, and that will execute an object's finalizer. Now,
        # that object will let another thread run so it can grab ts_current
        # again, which would likely crash the interpreter if there's no
        # check for this case at the end of green_updatecurrent(). This test
        # passes if getcurrent() returns correct result, but it's likely
        # to randomly crash if it's not anyway.
 #elf.assertEqual(greenlet.getcurrent(), main)
        # wait for another thread to complete, just in case
 #.join(10)

 #ef test_dealloc_switch_args_not_lost(self):
 #een = []
 #ef worker():
            # wait for the value
 #alue = greenlet.getcurrent().parent.switch()
            # delete all references to ourself
 #el worker[0]
 #nitiator.parent = greenlet.getcurrent().parent
            # switch to main with the value, but because
            # ts_current is the last reference to us we
            # return here immediately, where we resurrect ourself.
 #ry:
 #reenlet.getcurrent().parent.switch(value)
 #inally:
 #een.append(greenlet.getcurrent())
 #ef initiator():
 #eturn 42 # implicitly falls thru to parent

 #orker = [RawGreenlet(worker)]

 #orker[0].switch() # prime worker
 #nitiator = RawGreenlet(initiator, worker[0])
 #alue = initiator.switch()
 #elf.assertTrue(seen)
 #elf.assertEqual(value, 42)

 #ef test_tuple_subclass(self):
        # The point of this test is to see what happens when a custom
        # tuple subclass is used as an object passed directly to the C
        # function ``green_switch``; part of ``green_switch`` checks
        # the ``len()`` of the ``args`` tuple, and that can call back
        # into Python. Here, when it calls back into Python, we
        # recursively enter ``green_switch`` again.

        # This test is really only relevant on Python 2. The builtin
        # `apply` function directly passes the given args tuple object
        # to the underlying function, whereas the Python 3 version
        # unpacks and repacks into an actual tuple. This could still
        # happen using the C API on Python 3 though. We should write a
        # builtin version of apply() ourself.
 #ef _apply(func, a, k):
 #unc(*a, **k)

 #lass mytuple(tuple):
 #ef __len__(self):
 #reenlet.getcurrent().switch()
 #eturn tuple.__len__(self)
 #rgs = mytuple()
 #wargs = dict(a=42)
 #ef switchapply():
 #apply(greenlet.getcurrent().parent.switch, args, kwargs)
 # = RawGreenlet(switchapply)
 #elf.assertEqual(g.switch(), kwargs)

 #ef test_abstract_subclasses(self):
 #bstractSubclass = ABCMeta(
 #AbstractSubclass',
 #RawGreenlet,),
 #'run': abstractmethod(lambda self: None)})

 #lass BadSubclass(AbstractSubclass):
 #ass

 #lass GoodSubclass(AbstractSubclass):
 #ef run(self):
 #ass

 #oodSubclass() # should not raise
 #elf.assertRaises(TypeError, BadSubclass)

 #ef test_implicit_parent_with_threads(self):
 #f not gc.isenabled():
 #eturn # cannot test with disabled gc
 # = gc.get_threshold()[0]
 #f N < 50:
 #eturn # cannot test with such a small N
 #ef attempt():
 #ock1 = threading.Lock()
 #ock1.acquire()
 #ock2 = threading.Lock()
 #ock2.acquire()
 #ecycled = [False]
 #ef another_thread():
 #ock1.acquire() # wait for gc
 #reenlet.getcurrent() # update ts_current
 #ock2.release() # release gc
 # = threading.Thread(target=another_thread)
 #.start()
 #lass gc_callback(object):
 #ef __del__(self):
 #ock1.release()
 #ock2.acquire()
 #ecycled[0] = True
 #lass garbage(object):
 #ef __init__(self):
 #elf.cycle = self
 #elf.callback = gc_callback()
 # = []
 # = range(N*2)
 #urrent = greenlet.getcurrent()
 # = garbage()
 #or _ in x:
 # = None # lose reference to garbage
 #f recycled[0]:
                    # gc callback called prematurely
 #.join(10)
 #eturn False
 #ast = RawGreenlet()
 #f recycled[0]:
 #reak # yes! gc called in green_new
 #.append(last) # increase allocation counter
 #lse:
                # gc callback not called when expected
 #c.collect()
 #f recycled[0]:
 #.join(10)
 #eturn False
 #elf.assertEqual(last.parent, current)
 #or g in l:
 #elf.assertEqual(g.parent, current)
 #eturn True
 #or _ in range(5):
 #f attempt():
 #reak

 #ef test_issue_245_reference_counting_subclass_no_threads(self):
        # https://github.com/python-greenlet/greenlet/issues/245
        # Before the fix, this crashed pretty reliably on
        # Python 3.10, at least on macOS; but much less reliably on other
        # interpreters (memory layout must have changed).
        # The threaded test crashed more reliably on more interpreters.
 #rom greenlet import getcurrent
 #rom greenlet import GreenletExit

 #lass Greenlet(RawGreenlet):
 #ass

 #nitial_refs = sys.getrefcount(Greenlet)
        # This has to be an instance variable because
        # Python 2 raises a SyntaxError if we delete a local
        # variable referenced in an inner scope.
 #elf.glets = [] # pylint:disable=attribute-defined-outside-init

 #ef greenlet_main():
 #ry:
 #etcurrent().parent.switch()
 #xcept GreenletExit:
 #elf.glets.append(getcurrent())

        # Before the
 #or _ in range(10):
 #reenlet(greenlet_main).switch()

 #el self.glets
 #f RUNNING_ON_FREETHREAD_BUILD:
            # Free-threaded builds make types immortal, which gives us
            # weird numbers here, and we actually do APPEAR to end
            # up with one more reference than we started with, at least on 3.14.
            # If we change the code in green_dealloc to avoid increffing the type
            # (which fixed this initial bug), then our leakchecks find other objects
            # that have leaked, including a tuple, a dict, and a type. So that's not the
            # right solution. Instead we change the test:
            # XXX: FIXME: Is there a better way?
 #elf.assertGreaterEqual(sys.getrefcount(Greenlet), initial_refs)
 #lse:
 #elf.assertEqual(sys.getrefcount(Greenlet), initial_refs)

 #unittest.skipIf(
 #Y313 and RUNNING_ON_MANYLINUX,
 #The manylinux images appear to hang on this test on 3.13rc2"
        # Or perhaps I just got tired of waiting for the 450s timeout.
        # Still, it shouldn't take anywhere near that long. Does not reproduce in
        # Ubuntu images, on macOS or Windows.
 #
 #ef test_issue_245_reference_counting_subclass_threads(self):
        # https://github.com/python-greenlet/greenlet/issues/245
 #rom threading import Thread
 #rom threading import Event

 #rom greenlet import getcurrent

 #lass MyGreenlet(RawGreenlet):
 #ass

 #lets = []
 #ef_cleared = Event()

 #ef greenlet_main():
 #etcurrent().parent.switch()

 #ef thread_main(greenlet_running_event):
 #ine = MyGreenlet(greenlet_main)
 #lets.append(mine)
            # The greenlets being deleted must be active
 #ine.switch()
            # Don't keep any reference to it in this thread
 #el mine
            # Let main know we published our greenlet.
 #reenlet_running_event.set()
            # Wait for main to let us know the references are
            # gone and the greenlet objects no longer reachable
 #ef_cleared.wait(10)
            # The creating thread must call getcurrent() (or a few other
            # greenlet APIs) because that's when the thread-local list of dead
            # greenlets gets cleared.
 #etcurrent()

        # We start with 3 references to the subclass:
        # - This module
        # - Its __mro__
        # - The __subclassess__ attribute of greenlet
        # - (If we call gc.get_referents(), we find four entries, including
        #   some other tuple ``(greenlet)`` that I'm not sure about but must be part
        #   of the machinery.)
        #
        # On Python 3.10 it's often enough to just run 3 threads; on Python 2.7,
        # more threads are needed, and the results are still
        # non-deterministic. Presumably the memory layouts are different
 #nitial_refs = sys.getrefcount(MyGreenlet)
 #hread_ready_events = []
 #hread_count = initial_refs + 45
 #f RUNNING_ON_FREETHREAD_BUILD:
            # types are immortal, so this is a HUGE number most likely,
            # and we can't create that many threads.
 #hread_count = 50
 #or _ in range(thread_count):
 #vent = Event()
 #hread = Thread(target=thread_main, args=(event,))
 #hread_ready_events.append(event)
 #hread.start()


 #or done_event in thread_ready_events:
 #one_event.wait(10)


 #el glets[:]
 #ef_cleared.set()
        # Let any other thread run; it will crash the interpreter
        # if not fixed (or silently corrupt memory and we possibly crash
        # later).
 #elf.wait_for_pending_cleanups()
 #elf.assertEqual(sys.getrefcount(MyGreenlet), initial_refs)

 #ef test_falling_off_end_switches_to_unstarted_parent_raises_error(self):
 #ef no_args():
 #eturn 13

 #arent_never_started = RawGreenlet(no_args)

 #ef leaf():
 #eturn 42

 #hild = RawGreenlet(leaf, parent_never_started)

        # Because the run function takes to arguments
 #ith self.assertRaises(TypeError):
 #hild.switch()

 #ef test_falling_off_end_switches_to_unstarted_parent_works(self):
 #ef one_arg(x):
 #eturn (x, 24)

 #arent_never_started = RawGreenlet(one_arg)

 #ef leaf():
 #eturn 42

 #hild = RawGreenlet(leaf, parent_never_started)

 #esult = child.switch()
 #elf.assertEqual(result, (42, 24))

 #ef test_switch_to_dead_greenlet_with_unstarted_perverse_parent(self):
 #lass Parent(RawGreenlet):
 #ef __getattribute__(self, name):
 #f name == 'run':
 #aise SomeError


 #arent_never_started = Parent()
 #een = []
 #hild = RawGreenlet(lambda: seen.append(42), parent_never_started)
        # Because we automatically start the parent when the child is
        # finished
 #ith self.assertRaises(SomeError):
 #hild.switch()

 #elf.assertEqual(seen, [42])

 #ith self.assertRaises(SomeError):
 #hild.switch()
 #elf.assertEqual(seen, [42])

 #ef test_switch_to_dead_greenlet_reparent(self):
 #een = []
 #arent_never_started = RawGreenlet(lambda: seen.append(24))
 #hild = RawGreenlet(lambda: seen.append(42))

 #hild.switch()
 #elf.assertEqual(seen, [42])

 #hild.parent = parent_never_started
        # This actually is the same as switching to the parent.
 #esult = child.switch()
 #elf.assertIsNone(result)
 #elf.assertEqual(seen, [42, 24])

 #ef test_can_access_f_back_of_suspended_greenlet(self):
        # This tests our frame rewriting to work around Python 3.12+ having
        # some interpreter frames on the C stack. It will crash in the absence
        # of that logic.
 #ain = greenlet.getcurrent()

 #ef outer():
 #nner()

 #ef inner():
 #ain.switch(sys._getframe(0))

 #ub = RawGreenlet(outer)
        # start it
 #ub.switch()

        # start another greenlet to make sure we aren't relying on
        # anything in `hub` still being on the C stack
 #nrelated = RawGreenlet(lambda: None)
 #nrelated.switch()

        # now it is suspended
 #elf.assertIsNotNone(hub.gr_frame)
 #elf.assertEqual(hub.gr_frame.f_code.co_name, "inner")
 #elf.assertIsNotNone(hub.gr_frame.f_back)
 #elf.assertEqual(hub.gr_frame.f_back.f_code.co_name, "outer")
        # The next line is what would crash
 #elf.assertIsNone(hub.gr_frame.f_back.f_back)

 #ef test_get_stack_with_nested_c_calls(self):
 #rom functools import partial
 #rom . import _test_extension_cpp

 #ef recurse(v):
 #f v > 0:
 #eturn v * _test_extension_cpp.test_call(partial(recurse, v - 1))
 #eturn greenlet.getcurrent().parent.switch()

 #r = RawGreenlet(recurse)
 #r.switch(5)
 #rame = gr.gr_frame
 #or i in range(5):
 #elf.assertEqual(frame.f_locals["v"], i)
 #rame = frame.f_back
 #elf.assertEqual(frame.f_locals["v"], 5)
 #elf.assertIsNone(frame.f_back)
 #elf.assertEqual(gr.switch(10), 1200)  # 1200 = 5! * 10

 #ef test_frames_always_exposed(self):
        # On Python 3.12 this will crash if we don't set the
        # gr_frames_always_exposed attribute. More background:
        # https://github.com/python-greenlet/greenlet/issues/388
 #ain = greenlet.getcurrent()

 #ef outer():
 #nner(sys._getframe(0))

 #ef inner(frame):
 #ain.switch(frame)

 #r = RawGreenlet(outer)
 #rame = gr.switch()

        # Do something else to clobber the part of the C stack used by `gr`,
        # so we can't skate by on "it just happened to still be there"
 #nrelated = RawGreenlet(lambda: None)
 #nrelated.switch()

 #elf.assertEqual(frame.f_code.co_name, "outer")
        # The next line crashes on 3.12 if we haven't exposed the frames.
 #elf.assertIsNone(frame.f_back)


class TestGreenletSetParentErrors(TestCase):
 #ef test_threaded_reparent(self):
 #ata = {}
 #reated_event = threading.Event()
 #one_event = threading.Event()

 #ef run():
 #ata['g'] = RawGreenlet(lambda: None)
 #reated_event.set()
 #one_event.wait(10)

 #ef blank():
 #reenlet.getcurrent().parent.switch()

 #hread = threading.Thread(target=run)
 #hread.start()
 #reated_event.wait(10)
 # = RawGreenlet(blank)
 #.switch()
 #ith self.assertRaises(ValueError) as exc:
 #.parent = data['g']
 #one_event.set()
 #hread.join(10)

 #elf.assertEqual(str(exc.exception), "parent cannot be on a different thread")

 #ef test_unexpected_reparenting(self):
 #nother = []
 #ef worker():
 # = RawGreenlet(lambda: None)
 #nother.append(g)
 #.switch()
 # = threading.Thread(target=worker)
 #.start()
 #.join(10)
        # The first time we switch (running g_initialstub(), which is
        # when we look up the run attribute) we attempt to change the
        # parent to one from another thread (which also happens to be
        # dead). ``g_initialstub()`` should detect this and raise a
        # greenlet error.
        #
        # EXCEPT: With the fix for #252, this is actually detected
        # sooner, when setting the parent itself. Prior to that fix,
        # the main greenlet from the background thread kept a valid
        # value for ``run_info``, and appeared to be a valid parent
        # until we actually started the greenlet. But now that it's
        # cleared, this test is catching whether ``green_setparent``
        # can detect the dead thread.
        #
        # Further refactoring once again changes this back to a greenlet.error
        #
        # We need to wait for the cleanup to happen, but we're
        # deliberately leaking a main greenlet here.
 #elf.wait_for_pending_cleanups(initial_main_greenlets=self.main_greenlets_before_test + 1)

 #lass convoluted(RawGreenlet):
 #ef __getattribute__(self, name):
 #f name == 'run':
 #elf.parent = another[0] # pylint:disable=attribute-defined-outside-init
 #eturn RawGreenlet.__getattribute__(self, name)
 # = convoluted(lambda: None)
 #ith self.assertRaises(greenlet.error) as exc:
 #.switch()
 #elf.assertEqual(str(exc.exception),
 #cannot switch to a different thread (which happens to have exited)")
 #el another[:]

 #ef test_unexpected_reparenting_thread_running(self):
        # Like ``test_unexpected_reparenting``, except the background thread is
        # actually still alive.
 #nother = []
 #witched_to_greenlet = threading.Event()
 #eep_main_alive = threading.Event()
 #ef worker():
 # = RawGreenlet(lambda: None)
 #nother.append(g)
 #.switch()
 #witched_to_greenlet.set()
 #eep_main_alive.wait(10)
 #lass convoluted(RawGreenlet):
 #ef __getattribute__(self, name):
 #f name == 'run':
 #elf.parent = another[0] # pylint:disable=attribute-defined-outside-init
 #eturn RawGreenlet.__getattribute__(self, name)

 # = threading.Thread(target=worker)
 #.start()

 #witched_to_greenlet.wait(10)
 #ry:
 # = convoluted(lambda: None)

 #ith self.assertRaises(greenlet.error) as exc:
 #.switch()
 #elf.assertIn("Cannot switch to a different thread", str(exc.exception))
 #elf.assertIn("Expected", str(exc.exception))
 #elf.assertIn("Current", str(exc.exception))
 #inally:
 #eep_main_alive.set()
 #.join(10)
            # XXX: Should handle this automatically.
 #el another[:]

 #ef test_cannot_delete_parent(self):
 #orker = RawGreenlet(lambda: None)
 #elf.assertIs(worker.parent, greenlet.getcurrent())

 #ith self.assertRaises(AttributeError) as exc:
 #el worker.parent
 #elf.assertEqual(str(exc.exception), "can't delete attribute")

 #ef test_cannot_delete_parent_of_main(self):
 #ith self.assertRaises(AttributeError) as exc:
 #el greenlet.getcurrent().parent
 #elf.assertEqual(str(exc.exception), "can't delete attribute")


 #ef test_main_greenlet_parent_is_none(self):
        # assuming we're in a main greenlet here.
 #elf.assertIsNone(greenlet.getcurrent().parent)

 #ef test_set_parent_wrong_types(self):
 #ef bg():
            # Go back to main.
 #reenlet.getcurrent().parent.switch()

 #ef check(glet):
 #or p in None, 1, self, "42":
 #ith self.assertRaises(TypeError) as exc:
 #let.parent = p

 #elf.assertEqual(
 #tr(exc.exception),
 #GreenletChecker: Expected any type of greenlet, not " + type(p).__name__)

        # First, not running
 # = RawGreenlet(bg)
 #elf.assertFalse(g)
 #heck(g)

        # Then when running.
 #.switch()
 #elf.assertTrue(g)
 #heck(g)

        # Let it finish
 #.switch()


 #ef test_trivial_cycle(self):
 #let = RawGreenlet(lambda: None)
 #ith self.assertRaises(ValueError) as exc:
 #let.parent = glet
 #elf.assertEqual(str(exc.exception), "cyclic parent chain")

 #ef test_trivial_cycle_main(self):
        # This used to produce a ValueError, but we catch it earlier than that now.
 #ith self.assertRaises(AttributeError) as exc:
 #reenlet.getcurrent().parent = greenlet.getcurrent()
 #elf.assertEqual(str(exc.exception), "cannot set the parent of a main greenlet")

 #ef test_deeper_cycle(self):
 #1 = RawGreenlet(lambda: None)
 #2 = RawGreenlet(lambda: None)
 #3 = RawGreenlet(lambda: None)

 #1.parent = g2
 #2.parent = g3
 #ith self.assertRaises(ValueError) as exc:
 #3.parent = g1
 #elf.assertEqual(str(exc.exception), "cyclic parent chain")


class TestRepr(TestCase):

 #ef assertEndsWith(self, got, suffix):
 #elf.assertTrue(got.endswith(suffix), (got, suffix))

 #ef test_main_while_running(self):
 # = repr(greenlet.getcurrent())
 #elf.assertEndsWith(r, " current active started main>")

 #ef test_main_in_background(self):
 #ain = greenlet.getcurrent()
 #ef run():
 #eturn repr(main)

 # = RawGreenlet(run)
 # = g.switch()
 #elf.assertEndsWith(r, ' suspended active started main>')

 #ef test_initial(self):
 # = repr(RawGreenlet())
 #elf.assertEndsWith(r, ' pending>')

 #ef test_main_from_other_thread(self):
 #ain = greenlet.getcurrent()

 #lass T(threading.Thread):
 #riginal_main = thread_main = None
 #ain_glet = None
 #ef run(self):
 #elf.original_main = repr(main)
 #elf.main_glet = greenlet.getcurrent()
 #elf.thread_main = repr(self.main_glet)

 # = T()
 #.start()
 #.join(10)

 #elf.assertEndsWith(t.original_main, ' suspended active started main>')
 #elf.assertEndsWith(t.thread_main, ' current active started main>')
        # give the machinery time to notice the death of the thread,
        # and clean it up. Note that we don't use
        # ``expect_greenlet_leak`` or wait_for_pending_cleanups,
        # because at this point we know we have an extra greenlet
        # still reachable.
 #or _ in range(3):
 #ime.sleep(0.001)

        # In the past, main greenlets, even from dead threads, never
        # really appear dead. We have fixed that, and we also report
        # that the thread is dead in the repr. (Do this multiple times
        # to make sure that we don't self-modify and forget our state
        # in the C++ code).
 #or _ in range(3):
 #elf.assertTrue(t.main_glet.dead)
 # = repr(t.main_glet)
 #elf.assertEndsWith(r, ' (thread exited) dead>')

 #ef test_dead(self):
 # = RawGreenlet(lambda: None)
 #.switch()
 #elf.assertEndsWith(repr(g), ' dead>')
 #elf.assertNotIn('suspended', repr(g))
 #elf.assertNotIn('started', repr(g))
 #elf.assertNotIn('active', repr(g))

 #ef test_formatting_produces_native_str(self):
        # https://github.com/python-greenlet/greenlet/issues/218
        # %s formatting on Python 2 was producing unicode, not str.

 #_dead = RawGreenlet(lambda: None)
 #_not_started = RawGreenlet(lambda: None)
 #_cur = greenlet.getcurrent()

 #or g in g_dead, g_not_started, g_cur:

 #elf.assertIsInstance(
 #%s' % (g,),
 #tr
 #
 #elf.assertIsInstance(
 #%r' % (g,),
 #tr,
 #


class TestMainGreenlet(TestCase):
    # Tests some implementation details, and relies on some
    # implementation details.

 #ef _check_current_is_main(self):
        # implementation detail
 #ssert 'main' in repr(greenlet.getcurrent())

 # = type(greenlet.getcurrent())
 #ssert 'main' not in repr(t)
 #eturn t

 #ef test_main_greenlet_type_can_be_subclassed(self):
 #ain_type = self._check_current_is_main()
 #ubclass = type('subclass', (main_type,), {})
 #elf.assertIsNotNone(subclass)

 #ef test_main_greenlet_is_greenlet(self):
 #elf._check_current_is_main()
 #elf.assertIsInstance(greenlet.getcurrent(), RawGreenlet)



class TestBrokenGreenlets(TestCase):
    # Tests for things that used to, or still do, terminate the interpreter.
    # This often means doing unsavory things.

 #ef test_failed_to_initialstub(self):
 #ef func():
 #aise AssertionError("Never get here")


 # = greenlet._greenlet.UnswitchableGreenlet(func)
 #.force_switch_error = True

 #ith self.assertRaisesRegex(SystemError,
 #Failed to switch stacks into a greenlet for the first time."):
 #.switch()

 #ef test_failed_to_switch_into_running(self):
 #uns = []
 #ef func():
 #uns.append(1)
 #reenlet.getcurrent().parent.switch()
 #uns.append(2)
 #reenlet.getcurrent().parent.switch()
 #uns.append(3) # pragma: no cover

 # = greenlet._greenlet.UnswitchableGreenlet(func)
 #.switch()
 #elf.assertEqual(runs, [1])
 #.switch()
 #elf.assertEqual(runs, [1, 2])
 #.force_switch_error = True

 #ith self.assertRaisesRegex(SystemError,
 #Failed to switch stacks into a running greenlet."):
 #.switch()

        # If we stopped here, we would fail the leakcheck, because we've left
        # the ``inner_bootstrap()`` C frame and its descendents hanging around,
        # which have a bunch of Python references. They'll never get cleaned up
        # if we don't let the greenlet finish.
 #.force_switch_error = False
 #.switch()
 #elf.assertEqual(runs, [1, 2, 3])

 #ef test_failed_to_slp_switch_into_running(self):
 #x = self.assertScriptRaises('fail_slp_switch.py')

 #elf.assertIn('fail_slp_switch is running', ex.output)
 #elf.assertIn(ex.returncode, self.get_expected_returncodes_for_aborted_process())

 #ef test_reentrant_switch_two_greenlets(self):
        # Before we started capturing the arguments in g_switch_finish, this could crash.
 #utput = self.run_script('fail_switch_two_greenlets.py')
 #elf.assertIn('In g1_run', output)
 #elf.assertIn('TRACE', output)
 #elf.assertIn('LEAVE TRACE', output)
 #elf.assertIn('Falling off end of main', output)
 #elf.assertIn('Falling off end of g1_run', output)
 #elf.assertIn('Falling off end of g2', output)

 #ef test_reentrant_switch_three_greenlets(self):
        # On debug builds of greenlet, this used to crash with an assertion error;
        # on non-debug versions, it ran fine (which it should not do!).
        # Now it always crashes correctly with a TypeError
 #x = self.assertScriptRaises('fail_switch_three_greenlets.py', exitcodes=(1,))

 #elf.assertIn('TypeError', ex.output)
 #elf.assertIn('positional arguments', ex.output)

 #ef test_reentrant_switch_three_greenlets2(self):
        # This actually passed on debug and non-debug builds. It
        # should probably have been triggering some debug assertions
        # but it didn't.
        #
        # I think the fixes for the above test also kicked in here.
 #utput = self.run_script('fail_switch_three_greenlets2.py')
 #elf.assertIn(
 #RESULTS: [('trace', 'switch'), "
 #('trace', 'switch'), ('g2 arg', 'g2 from tracefunc'), "
 #('trace', 'switch'), ('main g1', 'from g2_run'), ('trace', 'switch'), "
 #('g1 arg', 'g1 from main'), ('trace', 'switch'), ('main g2', 'from g1_run'), "
 #('trace', 'switch'), ('g1 from parent', 'g1 from main 2'), ('trace', 'switch'), "
 #('main g1.2', 'g1 done'), ('trace', 'switch'), ('g2 from parent', ()), "
 #('trace', 'switch'), ('main g2.2', 'g2 done')]",
 #utput
 #

 #ef test_reentrant_switch_GreenletAlreadyStartedInPython(self):
 #utput = self.run_script('fail_initialstub_already_started.py')

 #elf.assertIn(
 #RESULTS: ['Begin C', 'Switch to b from B.__getattribute__ in C', "
 #('Begin B', ()), '_B_run switching to main', ('main from c', 'From B'), "
 #'B.__getattribute__ back from main in C', ('Begin A', (None,)), "
 #('A dead?', True, 'B dead?', True, 'C dead?', False), "
 #'C done', ('main from c.2', None)]",
 #utput
 #

 #ef test_reentrant_switch_run_callable_has_del(self):
 #utput = self.run_script('fail_clearing_run_switches.py')
 #elf.assertIn(
 #RESULTS ["
 #('G.__getattribute__', 'run'), ('RunCallable', '__del__'), "
 #('main: g.switch()', 'from RunCallable'), ('run_func', 'enter')"
 #]",
 #utput
 #

if __name__ == '__main__':
 #nittest.main()
