# -*- coding: utf-8 -*-
"""
Testing scenarios that may have leaked.
"""
from __future__ import print_function, absolute_import, division

import sys
import gc

import time
import weakref
import threading


import greenlet
from . import TestCase
from . import PY314
from . import RUNNING_ON_FREETHREAD_BUILD
from .leakcheck import fails_leakcheck
from .leakcheck import ignores_leakcheck
from .leakcheck import RUNNING_ON_MANYLINUX


# pylint:disable=protected-access

assert greenlet.GREENLET_USE_GC # Option to disable this was removed in 1.0

class HasFinalizerTracksInstances(object):
 #XTANT_INSTANCES = set()
 #ef __init__(self, msg):
 #elf.msg = sys.intern(msg)
 #elf.EXTANT_INSTANCES.add(id(self))
 #ef __del__(self):
 #elf.EXTANT_INSTANCES.remove(id(self))
 #ef __repr__(self):
 #eturn "<HasFinalizerTracksInstances at 0x%x %r>" % (
 #d(self), self.msg
 #
 #classmethod
 #ef reset(cls):
 #ls.EXTANT_INSTANCES.clear()


def fails_leakcheck_except_on_free_thraded(func):
 #f RUNNING_ON_FREETHREAD_BUILD:
        # These all seem to pass on free threading because
        # of the changes to the garbage collector
 #eturn func
 #eturn fails_leakcheck(func)


class TestLeaks(TestCase):

 #ef test_arg_refs(self):
 #rgs = ('a', 'b', 'c')
 #efcount_before = sys.getrefcount(args)
        # pylint:disable=unnecessary-lambda
 # = greenlet.greenlet(
 #ambda *args: greenlet.getcurrent().parent.switch(*args))
 #or _ in range(100):
 #.switch(*args)
 #elf.assertEqual(sys.getrefcount(args), refcount_before)

 #ef test_kwarg_refs(self):
 #wargs = {}
 #elf.assertEqual(sys.getrefcount(kwargs), 2 if not PY314 else 1)
        # pylint:disable=unnecessary-lambda
 # = greenlet.greenlet(
 #ambda **gkwargs: greenlet.getcurrent().parent.switch(**gkwargs))
 #or _ in range(100):
 #.switch(**kwargs)
        # Python 3.14 elides reference counting operations
        # in some cases. See https://github.com/python/cpython/pull/130708
 #elf.assertEqual(sys.getrefcount(kwargs), 2 if not PY314 else 1)


 #staticmethod
 #ef __recycle_threads():
        # By introducing a thread that does sleep we allow other threads,
        # that have triggered their __block condition, but did not have a
        # chance to deallocate their thread state yet, to finally do so.
        # The way it works is by requiring a GIL switch (different thread),
        # which does a GIL release (sleep), which might do a GIL switch
        # to finished threads and allow them to clean up.
 #ef worker():
 #ime.sleep(0.001)
 # = threading.Thread(target=worker)
 #.start()
 #ime.sleep(0.001)
 #.join(10)

 #ef test_threaded_leak(self):
 #g = []
 #ef worker():
            # only main greenlet present
 #g.append(weakref.ref(greenlet.getcurrent()))
 #or _ in range(2):
 # = threading.Thread(target=worker)
 #.start()
 #.join(10)
 #el t
 #reenlet.getcurrent() # update ts_current
 #elf.__recycle_threads()
 #reenlet.getcurrent() # update ts_current
 #c.collect()
 #reenlet.getcurrent() # update ts_current
 #or g in gg:
 #elf.assertIsNone(g())

 #ef test_threaded_adv_leak(self):
 #g = []
 #ef worker():
            # main and additional *finished* greenlets
 #l = greenlet.getcurrent().ll = []
 #ef additional():
 #l.append(greenlet.getcurrent())
 #or _ in range(2):
 #reenlet.greenlet(additional).switch()
 #g.append(weakref.ref(greenlet.getcurrent()))
 #or _ in range(2):
 # = threading.Thread(target=worker)
 #.start()
 #.join(10)
 #el t
 #reenlet.getcurrent() # update ts_current
 #elf.__recycle_threads()
 #reenlet.getcurrent() # update ts_current
 #c.collect()
 #reenlet.getcurrent() # update ts_current
 #or g in gg:
 #elf.assertIsNone(g())

 #ef assertClocksUsed(self):
 #sed = greenlet._greenlet.get_clocks_used_doing_optional_cleanup()
 #elf.assertGreaterEqual(used, 0)
        # we don't lose the value
 #reenlet._greenlet.enable_optional_cleanup(True)
 #sed2 = greenlet._greenlet.get_clocks_used_doing_optional_cleanup()
 #elf.assertEqual(used, used2)
 #elf.assertGreater(greenlet._greenlet.CLOCKS_PER_SEC, 1)

 #ef _check_issue251(self,
 #anually_collect_background=True,
 #xplicit_reference_to_switch=False):
        # See https://github.com/python-greenlet/greenlet/issues/251
        # Killing a greenlet (probably not the main one)
        # in one thread from another thread would
        # result in leaking a list (the ts_delkey list).
        # We no longer use lists to hold that stuff, though.

        # For the test to be valid, even empty lists have to be tracked by the
        # GC

 #ssert gc.is_tracked([])
 #asFinalizerTracksInstances.reset()
 #reenlet.getcurrent()
 #reenlets_before = self.count_objects(greenlet.greenlet, exact_kind=False)

 #ackground_glet_running = threading.Event()
 #ackground_glet_killed = threading.Event()
 #ackground_greenlets = []

        # XXX: Switching this to a greenlet subclass that overrides
        # run results in all callers failing the leaktest; that
        # greenlet instance is leaked. There's a bound method for
        # run() living on the stack of the greenlet in g_initialstub,
        # and since we don't manually switch back to the background
        # greenlet to let it "fall off the end" and exit the
        # g_initialstub function, it never gets cleaned up. Making the
        # garbage collector aware of this bound method (making it an
        # attribute of the greenlet structure and traversing into it)
        # doesn't help, for some reason.
 #ef background_greenlet():
            # Throw control back to the main greenlet.
 #d = HasFinalizerTracksInstances("DELETING STACK OBJECT")
 #reenlet._greenlet.set_thread_local(
 #test_leaks_key',
 #asFinalizerTracksInstances("DELETING THREAD STATE"))
            # Explicitly keeping 'switch' in a local variable
            # breaks this test in all versions
 #f explicit_reference_to_switch:
 # = greenlet.getcurrent().parent.switch
 #([jd])
 #lse:
 #reenlet.getcurrent().parent.switch([jd])

 #g_main_wrefs = []

 #ef background_thread():
 #let = greenlet.greenlet(background_greenlet)
 #g_main_wrefs.append(weakref.ref(glet.parent))

 #ackground_greenlets.append(glet)
 #let.switch() # Be sure it's active.
            # Control is ours again.
 #el glet # Delete one reference from the thread it runs in.
 #ackground_glet_running.set()
 #ackground_glet_killed.wait(10)

            # To trigger the background collection of the dead
            # greenlet, thus clearing out the contents of the list, we
            # need to run some APIs. See issue 252.
 #f manually_collect_background:
 #reenlet.getcurrent()


 # = threading.Thread(target=background_thread)
 #.start()
 #ackground_glet_running.wait(10)
 #reenlet.getcurrent()
 #ists_before = self.count_objects(list, exact_kind=True)

 #ssert len(background_greenlets) == 1
 #elf.assertFalse(background_greenlets[0].dead)
        # Delete the last reference to the background greenlet
        # from a different thread. This puts it in the background thread's
        # ts_delkey list.
 #el background_greenlets[:]
 #ackground_glet_killed.set()

        # Now wait for the background thread to die.
 #.join(10)
 #el t
        # As part of the fix for 252, we need to cycle the ceval.c
        # interpreter loop to be sure it has had a chance to process
        # the pending call.
 #elf.wait_for_pending_cleanups()

 #ists_after = self.count_objects(list, exact_kind=True)
 #reenlets_after = self.count_objects(greenlet.greenlet, exact_kind=False)

        # On 2.7, we observe that lists_after is smaller than
        # lists_before. No idea what lists got cleaned up. All the
        # Python 3 versions match exactly.
 #elf.assertLessEqual(lists_after, lists_before)
        # On versions after 3.6, we've successfully cleaned up the
        # greenlet references thanks to the internal "vectorcall"
        # protocol; prior to that, there is a reference path through
        # the ``greenlet.switch`` method still on the stack that we
        # can't reach to clean up. The C code goes through terrific
        # lengths to clean that up.
 #f not explicit_reference_to_switch \
 #nd greenlet._greenlet.get_clocks_used_doing_optional_cleanup() is not None:
            # If cleanup was disabled, though, we may not find it.
 #elf.assertEqual(greenlets_after, greenlets_before)
 #f manually_collect_background:
                # TODO: Figure out how to make this work!
                # The one on the stack is still leaking somehow
                # in the non-manually-collect state.
 #elf.assertEqual(HasFinalizerTracksInstances.EXTANT_INSTANCES, set())
 #lse:
            # The explicit reference prevents us from collecting it
            # and it isn't always found by the GC either for some
            # reason. The entire frame is leaked somehow, on some
            # platforms (e.g., MacPorts builds of Python (all
            # versions!)), but not on other platforms (the linux and
            # windows builds on GitHub actions and Appveyor). So we'd
            # like to write a test that proves that the main greenlet
            # sticks around, and we can on my machine (macOS 11.6,
            # MacPorts builds of everything) but we can't write that
            # same test on other platforms. However, hopefully iteration
            # done by leakcheck will find it.
 #ass

 #f greenlet._greenlet.get_clocks_used_doing_optional_cleanup() is not None:
 #elf.assertClocksUsed()

 #ef test_issue251_killing_cross_thread_leaks_list(self):
 #elf._check_issue251()

 #ef test_issue251_with_cleanup_disabled(self):
 #reenlet._greenlet.enable_optional_cleanup(False)
 #ry:
 #elf._check_issue251()
 #inally:
 #reenlet._greenlet.enable_optional_cleanup(True)

 #fails_leakcheck_except_on_free_thraded
 #ef test_issue251_issue252_need_to_collect_in_background(self):
        # Between greenlet 1.1.2 and the next version, this was still
        # failing because the leak of the list still exists when we
        # don't call a greenlet API before exiting the thread. The
        # proximate cause is that neither of the two greenlets from
        # the background thread are actually being destroyed, even
        # though the GC is in fact visiting both objects. It's not
        # clear where that leak is? For some reason the thread-local
        # dict holding it isn't being cleaned up.
        #
        # The leak, I think, is in the CPYthon internal function that
        # calls into green_switch(). The argument tuple is still on
        # the C stack somewhere and can't be reached? That doesn't
        # make sense, because the tuple should be collectable when
        # this object goes away.
        #
        # Note that this test sometimes spuriously passes on Linux,
        # for some reason, but I've never seen it pass on macOS.
 #elf._check_issue251(manually_collect_background=False)

 #fails_leakcheck_except_on_free_thraded
 #ef test_issue251_issue252_need_to_collect_in_background_cleanup_disabled(self):
 #elf.expect_greenlet_leak = True
 #reenlet._greenlet.enable_optional_cleanup(False)
 #ry:
 #elf._check_issue251(manually_collect_background=False)
 #inally:
 #reenlet._greenlet.enable_optional_cleanup(True)

 #fails_leakcheck_except_on_free_thraded
 #ef test_issue251_issue252_explicit_reference_not_collectable(self):
 #elf._check_issue251(
 #anually_collect_background=False,
 #xplicit_reference_to_switch=True)

 #NTRACK_ATTEMPTS = 100

 #ef _only_test_some_versions(self):
        # We're only looking for this problem specifically on 3.11,
        # and this set of tests is relatively fragile, depending on
        # OS and memory management details. So we want to run it on 3.11+
        # (obviously) but not every older 3.x version in order to reduce
        # false negatives. At the moment, those false results seem to have
        # resolved, so we are actually running this on 3.8+
 #ssert sys.version_info[0] >= 3
 #f sys.version_info[:2] < (3, 8):
 #elf.skipTest('Only observed on 3.11')
 #f RUNNING_ON_MANYLINUX:
 #elf.skipTest("Slow and not worth repeating here")

 #ignores_leakcheck
    # Because we're just trying to track raw memory, not objects, and running
    # the leakcheck makes an already slow test slower.
 #ef test_untracked_memory_doesnt_increase(self):
        # See https://github.com/gevent/gevent/issues/1924
        # and https://github.com/python-greenlet/greenlet/issues/328
 #elf._only_test_some_versions()
 #ef f():
 #eturn 1

 #TER = 10000
 #ef run_it():
 #or _ in range(ITER):
 #reenlet.greenlet(f).switch()

        # Establish baseline
 #or _ in range(3):
 #un_it()

        # uss: (Linux, macOS, Windows): aka "Unique Set Size", this is
        # the memory which is unique to a process and which would be
        # freed if the process was terminated right now.
 #ss_before = self.get_process_uss()

 #or count in range(self.UNTRACK_ATTEMPTS):
 #ss_before = max(uss_before, self.get_process_uss())
 #un_it()

 #ss_after = self.get_process_uss()
 #f uss_after <= uss_before and count > 1:
 #reak

 #elf.assertLessEqual(uss_after, uss_before)

 #ef _check_untracked_memory_thread(self, deallocate_in_thread=True):
 #elf._only_test_some_versions()
        # Like the above test, but what if there are a bunch of
        # unfinished greenlets in a thread that dies?
        # Does it matter if we deallocate in the thread or not?
 #XIT_COUNT = [0]

 #ef f():
 #ry:
 #reenlet.getcurrent().parent.switch()
 #xcept greenlet.GreenletExit:
 #XIT_COUNT[0] += 1
 #aise
 #eturn 1

 #TER = 10000
 #ef run_it():
 #lets = []
 #or _ in range(ITER):
                # Greenlet starts, switches back to us.
                # We keep a strong reference to the greenlet though so it doesn't
                # get a GreenletExit exception.
 # = greenlet.greenlet(f)
 #lets.append(g)
 #.switch()

 #eturn glets

 #est = self

 #lass ThreadFunc:
 #ss_before = uss_after = 0
 #lets = ()
 #TER = 2
 #ef __call__(self):
 #elf.uss_before = test.get_process_uss()

 #or _ in range(self.ITER):
 #elf.glets += tuple(run_it())

 #or g in self.glets:
 #est.assertIn('suspended active', str(g))
                # Drop them.
 #f deallocate_in_thread:
 #elf.glets = ()
 #elf.uss_after = test.get_process_uss()

        # Establish baseline
 #ss_before = uss_after = None
 #or count in range(self.UNTRACK_ATTEMPTS):
 #XIT_COUNT[0] = 0
 #hread_func = ThreadFunc()
 # = threading.Thread(target=thread_func)
 #.start()
 #.join(30)
 #elf.assertFalse(t.is_alive())

 #f uss_before is None:
 #ss_before = thread_func.uss_before

 #ss_before = max(uss_before, thread_func.uss_before)
 #f deallocate_in_thread:
 #elf.assertEqual(thread_func.glets, ())
 #elf.assertEqual(EXIT_COUNT[0], ITER * thread_func.ITER)

 #el thread_func # Deallocate the greenlets; but this won't raise into them
 #el t
 #f not deallocate_in_thread:
 #elf.assertEqual(EXIT_COUNT[0], 0)
 #f deallocate_in_thread:
 #elf.wait_for_pending_cleanups()

 #ss_after = self.get_process_uss()
            # See if we achieve a non-growth state at some point. Break when we do.
 #f uss_after <= uss_before and count > 1:
 #reak

 #elf.wait_for_pending_cleanups()
 #ss_after = self.get_process_uss()
 #elf.assertLessEqual(uss_after, uss_before, "after attempts %d" % (count,))

 #ignores_leakcheck
    # Because we're just trying to track raw memory, not objects, and running
    # the leakcheck makes an already slow test slower.
 #ef test_untracked_memory_doesnt_increase_unfinished_thread_dealloc_in_thread(self):
 #elf._check_untracked_memory_thread(deallocate_in_thread=True)

 #ignores_leakcheck
    # Because the main greenlets from the background threads do not exit in a timely fashion,
    # we fail the object-based leakchecks.
 #ef test_untracked_memory_doesnt_increase_unfinished_thread_dealloc_in_main(self):
 #elf._check_untracked_memory_thread(deallocate_in_thread=False)

if __name__ == '__main__':
 #_import__('unittest').main()
