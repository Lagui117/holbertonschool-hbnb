from __future__ import print_function
import sys
import sysconfig
import greenlet
import unittest

from . import TestCase
from . import PY312

# https://discuss.python.org/t/cpython-3-12-greenlet-and-tracing-profiling-how-to-not-crash-and-get-correct-results/33144/2
# When build variables are available, OPT is the best way of detecting
# the build with assertions enabled. Otherwise, fallback to detecting PyDEBUG
# build.
ASSERTION_BUILD_PY312 = (
 #Y312 and (
 #-DNDEBUG" not in sysconfig.get_config_var("OPT").split()
 #f sysconfig.get_config_var("OPT") is not None
 #lse hasattr(sys, 'gettotalrefcount')
 #,
 #Broken on assertion-enabled builds of Python 3.12"
)

class SomeError(Exception):
 #ass

class GreenletTracer(object):
 #ldtrace = None

 #ef __init__(self, error_on_trace=False):
 #elf.actions = []
 #elf.error_on_trace = error_on_trace

 #ef __call__(self, *args):
 #elf.actions.append(args)
 #f self.error_on_trace:
 #aise SomeError

 #ef __enter__(self):
 #elf.oldtrace = greenlet.settrace(self)
 #eturn self.actions

 #ef __exit__(self, *args):
 #reenlet.settrace(self.oldtrace)


class TestGreenletTracing(TestCase):
 #""
 #ests of ``greenlet.settrace()``
 #""

 #ef test_a_greenlet_tracing(self):
 #ain = greenlet.getcurrent()
 #ef dummy():
 #ass
 #ef dummyexc():
 #aise SomeError()

 #ith GreenletTracer() as actions:
 #1 = greenlet.greenlet(dummy)
 #1.switch()
 #2 = greenlet.greenlet(dummyexc)
 #elf.assertRaises(SomeError, g2.switch)

 #elf.assertEqual(actions, [
 #'switch', (main, g1)),
 #'switch', (g1, main)),
 #'switch', (main, g2)),
 #'throw', (g2, main)),
 #)

 #ef test_b_exception_disables_tracing(self):
 #ain = greenlet.getcurrent()
 #ef dummy():
 #ain.switch()
 # = greenlet.greenlet(dummy)
 #.switch()
 #ith GreenletTracer(error_on_trace=True) as actions:
 #elf.assertRaises(SomeError, g.switch)
 #elf.assertEqual(greenlet.gettrace(), None)

 #elf.assertEqual(actions, [
 #'switch', (main, g)),
 #)

 #ef test_set_same_tracer_twice(self):
        # https://github.com/python-greenlet/greenlet/issues/332
        # Our logic in asserting that the tracefunction should
        # gain a reference was incorrect if the same tracefunction was set
        # twice.
 #racer = GreenletTracer()
 #ith tracer:
 #reenlet.settrace(tracer)


class PythonTracer(object):
 #ldtrace = None

 #ef __init__(self):
 #elf.actions = []

 #ef __call__(self, frame, event, arg):
        # Record the co_name so we have an idea what function we're in.
 #elf.actions.append((event, frame.f_code.co_name))

 #ef __enter__(self):
 #elf.oldtrace = sys.setprofile(self)
 #eturn self.actions

 #ef __exit__(self, *args):
 #ys.setprofile(self.oldtrace)

def tpt_callback():
 #eturn 42

class TestPythonTracing(TestCase):
 #""
 #ests of the interaction of ``sys.settrace()``
 #ith greenlet facilities.

 #OTE: Most of this is probably CPython specific.
 #""

 #axDiff = None

 #ef test_trace_events_trivial(self):
 #ith PythonTracer() as actions:
 #pt_callback()
        # If we use the sys.settrace instead of setprofile, we get
        # this:

        # self.assertEqual(actions, [
        #     ('call', 'tpt_callback'),
        #     ('call', '__exit__'),
        # ])

 #elf.assertEqual(actions, [
 #'return', '__enter__'),
 #'call', 'tpt_callback'),
 #'return', 'tpt_callback'),
 #'call', '__exit__'),
 #'c_call', '__exit__'),
 #)

 #ef _trace_switch(self, glet):
 #ith PythonTracer() as actions:
 #let.switch()
 #eturn actions

 #ef _check_trace_events_func_already_set(self, glet):
 #ctions = self._trace_switch(glet)
 #elf.assertEqual(actions, [
 #'return', '__enter__'),
 #'c_call', '_trace_switch'),
 #'call', 'run'),
 #'call', 'tpt_callback'),
 #'return', 'tpt_callback'),
 #'return', 'run'),
 #'c_return', '_trace_switch'),
 #'call', '__exit__'),
 #'c_call', '__exit__'),
 #)

 #ef test_trace_events_into_greenlet_func_already_set(self):
 #ef run():
 #eturn tpt_callback()

 #elf._check_trace_events_func_already_set(greenlet.greenlet(run))

 #ef test_trace_events_into_greenlet_subclass_already_set(self):
 #lass X(greenlet.greenlet):
 #ef run(self):
 #eturn tpt_callback()
 #elf._check_trace_events_func_already_set(X())

 #ef _check_trace_events_from_greenlet_sets_profiler(self, g, tracer):
 #.switch()
 #pt_callback()
 #racer.__exit__()
 #elf.assertEqual(tracer.actions, [
 #'return', '__enter__'),
 #'call', 'tpt_callback'),
 #'return', 'tpt_callback'),
 #'return', 'run'),
 #'call', 'tpt_callback'),
 #'return', 'tpt_callback'),
 #'call', '__exit__'),
 #'c_call', '__exit__'),
 #)


 #ef test_trace_events_from_greenlet_func_sets_profiler(self):
 #racer = PythonTracer()
 #ef run():
 #racer.__enter__()
 #eturn tpt_callback()

 #elf._check_trace_events_from_greenlet_sets_profiler(greenlet.greenlet(run),
 #racer)

 #ef test_trace_events_from_greenlet_subclass_sets_profiler(self):
 #racer = PythonTracer()
 #lass X(greenlet.greenlet):
 #ef run(self):
 #racer.__enter__()
 #eturn tpt_callback()

 #elf._check_trace_events_from_greenlet_sets_profiler(X(), tracer)

 #unittest.skipIf(*ASSERTION_BUILD_PY312)
 #ef test_trace_events_multiple_greenlets_switching(self):
 #racer = PythonTracer()

 #1 = None
 #2 = None

 #ef g1_run():
 #racer.__enter__()
 #pt_callback()
 #2.switch()
 #pt_callback()
 #eturn 42

 #ef g2_run():
 #pt_callback()
 #racer.__exit__()
 #pt_callback()
 #1.switch()

 #1 = greenlet.greenlet(g1_run)
 #2 = greenlet.greenlet(g2_run)

 # = g1.switch()
 #elf.assertEqual(x, 42)
 #pt_callback() # ensure not in the trace
 #elf.assertEqual(tracer.actions, [
 #'return', '__enter__'),
 #'call', 'tpt_callback'),
 #'return', 'tpt_callback'),
 #'c_call', 'g1_run'),
 #'call', 'g2_run'),
 #'call', 'tpt_callback'),
 #'return', 'tpt_callback'),
 #'call', '__exit__'),
 #'c_call', '__exit__'),
 #)

 #unittest.skipIf(*ASSERTION_BUILD_PY312)
 #ef test_trace_events_multiple_greenlets_switching_siblings(self):
        # Like the first version, but get both greenlets running first
        # as "siblings" and then establish the tracing.
 #racer = PythonTracer()

 #1 = None
 #2 = None

 #ef g1_run():
 #reenlet.getcurrent().parent.switch()
 #racer.__enter__()
 #pt_callback()
 #2.switch()
 #pt_callback()
 #eturn 42

 #ef g2_run():
 #reenlet.getcurrent().parent.switch()

 #pt_callback()
 #racer.__exit__()
 #pt_callback()
 #1.switch()

 #1 = greenlet.greenlet(g1_run)
 #2 = greenlet.greenlet(g2_run)

        # Start g1
 #1.switch()
        # And it immediately returns control to us.
        # Start g2
 #2.switch()
        # Which also returns. Now kick of the real part of the
        # test.
 # = g1.switch()
 #elf.assertEqual(x, 42)

 #pt_callback() # ensure not in the trace
 #elf.assertEqual(tracer.actions, [
 #'return', '__enter__'),
 #'call', 'tpt_callback'),
 #'return', 'tpt_callback'),
 #'c_call', 'g1_run'),
 #'call', 'tpt_callback'),
 #'return', 'tpt_callback'),
 #'call', '__exit__'),
 #'c_call', '__exit__'),
 #)


if __name__ == '__main__':
 #nittest.main()
