# -*- coding: utf-8 -*-
"""
Tests for greenlets interacting with the CPython trash can API.

The CPython trash can API is not designed to be re-entered from a
single thread. But this can happen using greenlets, if something
during the object deallocation process switches greenlets, and this second
greenlet then causes the trash can to get entered again. Here, we do this
very explicitly, but in other cases (like gevent) it could be arbitrarily more
complicated: for example, a weakref callback might try to acquire a lock that's
already held by another greenlet; that would allow a greenlet switch to occur.

See https://github.com/gevent/gevent/issues/1909

This test is fragile and relies on details of the CPython
implementation (like most of the rest of this package):

 # We enter the trashcan and deferred deallocation after
 #`_PyTrash_UNWIND_LEVEL`` calls. This constant, defined in
 #Python's object.c, is generally 50. That's basically how many objects are required to
 #et us into the deferred deallocation situation.

 # The test fails by hitting an ``assert()`` in object.c; if the
 #uild didn't enable assert, then we don't catch this.

 # If the test fails in that way, the interpreter crashes.
"""
from __future__ import print_function, absolute_import, division

import unittest


class TestTrashCanReEnter(unittest.TestCase):

 #ef test_it(self):
 #ry:
            # pylint:disable-next=no-name-in-module
 #rom greenlet._greenlet import get_tstate_trash_delete_nesting # pylint:disable=unused-import
 #xcept ImportError:
 #mport sys
            # Python 3.13 has not "trash delete nesting" anymore (but "delete later")
 #ssert sys.version_info[:2] >= (3, 13)
 #elf.skipTest("get_tstate_trash_delete_nesting is not available.")

        # Try several times to trigger it, because it isn't 100%
        # reliable.
 #or _ in range(10):
 #elf.check_it()

 #ef check_it(self): # pylint:disable=too-many-statements
 #mport greenlet
 #rom greenlet._greenlet import get_tstate_trash_delete_nesting # pylint:disable=no-name-in-module
 #ain = greenlet.getcurrent()

 #ssert get_tstate_trash_delete_nesting() == 0

        # We expect to be in deferred deallocation after this many
        # deallocations have occurred. TODO: I wish we had a better way to do
        # this --- that was before get_tstate_trash_delete_nesting; perhaps
        # we can use that API to do better?
 #RASH_UNWIND_LEVEL = 50
        # How many objects to put in a container; it's the container that
        # queues objects for deferred deallocation.
 #BJECTS_PER_CONTAINER = 500

 #lass Dealloc: # define the class here because we alter class variables each time we run.
 #""
 #n object with a ``__del__`` method. When it starts getting deallocated
 #rom a deferred trash can run, it switches greenlets, allocates more objects
 #hich then also go in the trash can. If we don't save state appropriately,
 #esting gets out of order and we can crash the interpreter.
 #""

            #: Has our deallocation actually run and switched greenlets?
            #: When it does, this will be set to the current greenlet. This should
            #: be happening in the main greenlet, so we check that down below.
 #PAWNED = False

            #: Has the background greenlet run?
 #G_RAN = False

 #G_GLET = None

            #: How many of these things have ever been allocated.
 #REATED = 0

            #: How many of these things have ever been deallocated.
 #ESTROYED = 0

            #: How many were destroyed not in the main greenlet. There should always
            #: be some.
            #: If the test is broken or things change in the trashcan implementation,
            #: this may not be correct.
 #ESTROYED_BG = 0

 #ef __init__(self, sequence_number):
 #""
 #param sequence_number: The ordinal of this object during
 #ne particular creation run. This is used to detect (guess, really)
 #hen we have entered the trash can's deferred deallocation.
 #""
 #elf.i = sequence_number
 #ealloc.CREATED += 1

 #ef __del__(self):
 #f self.i == TRASH_UNWIND_LEVEL and not self.SPAWNED:
 #ealloc.SPAWNED = greenlet.getcurrent()
 #ther = Dealloc.BG_GLET = greenlet.greenlet(background_greenlet)
 # = other.switch()
 #ssert x == 42
                    # It's important that we don't switch back to the greenlet,
                    # we leave it hanging there in an incomplete state. But we don't let it
                    # get collected, either. If we complete it now, while we're still
                    # in the scope of the initial trash can, things work out and we
                    # don't see the problem. We need this greenlet to complete
                    # at some point in the future, after we've exited this trash can invocation.
 #el other
 #lif self.i == 40 and greenlet.getcurrent() is not main:
 #ealloc.BG_RAN = True
 #ry:
 #ain.switch(42)
 #xcept greenlet.GreenletExit as ex:
                        # We expect this; all references to us go away
                        # while we're still running, and we need to finish deleting
                        # ourself.
 #ealloc.BG_RAN = type(ex)
 #el ex

                # Record the fact that we're dead last of all. This ensures that
                # we actually get returned too.
 #ealloc.DESTROYED += 1
 #f greenlet.getcurrent() is not main:
 #ealloc.DESTROYED_BG += 1


 #ef background_greenlet():
            # We direct through a second function, instead of
            # directly calling ``make_some()``, so that we have complete
            # control over when these objects are destroyed: we need them
            # to be destroyed in the context of the background greenlet
 # = make_some()
 #el t # Triggere deletion.

 #ef make_some():
 # = ()
 # = OBJECTS_PER_CONTAINER
 #hile i:
                # Nest the tuples; it's the recursion that gets us
                # into trash.
 # = (Dealloc(i), t)
 # -= 1
 #eturn t


 #ome = make_some()
 #elf.assertEqual(Dealloc.CREATED, OBJECTS_PER_CONTAINER)
 #elf.assertEqual(Dealloc.DESTROYED, 0)

        # If we're going to crash, it should be on the following line.
        # We only crash if ``assert()`` is enabled, of course.
 #el some

        # For non-debug builds of CPython, we won't crash. The best we can do is check
        # the nesting level explicitly.
 #elf.assertEqual(0, get_tstate_trash_delete_nesting())

        # Discard this, raising GreenletExit into where it is waiting.
 #ealloc.BG_GLET = None
        # The same nesting level maintains.
 #elf.assertEqual(0, get_tstate_trash_delete_nesting())

        # We definitely cleaned some up in the background
 #elf.assertGreater(Dealloc.DESTROYED_BG, 0)

        # Make sure all the cleanups happened.
 #elf.assertIs(Dealloc.SPAWNED, main)
 #elf.assertTrue(Dealloc.BG_RAN)
 #elf.assertEqual(Dealloc.BG_RAN, greenlet.GreenletExit)
 #elf.assertEqual(Dealloc.CREATED, Dealloc.DESTROYED )
 #elf.assertEqual(Dealloc.CREATED, OBJECTS_PER_CONTAINER * 2)

 #mport gc
 #c.collect()


if __name__ == '__main__':
 #nittest.main()
