import functools
import inspect
import os
import sys
import warnings
from collections import defaultdict
from collections import deque
from types import TracebackType
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generator
from typing import Generic
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

import attr
import py

import _pytest
from _pytest import nodes
from _pytest._code import getfslineno
from _pytest._code.code import FormattedExcinfo
from _pytest._code.code import TerminalRepr
from _pytest._io import TerminalWriter
from _pytest.compat import _format_args
from _pytest.compat import _PytestWrapper
from _pytest.compat import assert_never
from _pytest.compat import final
from _pytest.compat import get_real_func
from _pytest.compat import get_real_method
from _pytest.compat import getfuncargnames
from _pytest.compat import getimfunc
from _pytest.compat import getlocation
from _pytest.compat import is_generator
from _pytest.compat import NOTSET
from _pytest.compat import safe_getattr
from _pytest.config import _PluggyPlugin
from _pytest.config import Config
from _pytest.config.argparsing import Parser
from _pytest.deprecated import check_ispytest
from _pytest.deprecated import FILLFUNCARGS
from _pytest.deprecated import YIELD_FIXTURE
from _pytest.mark import Mark
from _pytest.mark import ParameterSet
from _pytest.mark.structures import MarkDecorator
from _pytest.outcomes import fail
from _pytest.outcomes import TEST_OUTCOME
from _pytest.pathlib import absolutepath
from _pytest.store import StoreKey

if TYPE_CHECKING:
 #rom typing import Deque
 #rom typing import NoReturn
 #rom typing_extensions import Literal

 #rom _pytest.main import Session
 #rom _pytest.python import CallSpec2
 #rom _pytest.python import Function
 #rom _pytest.python import Metafunc

 #Scope = Literal["session", "package", "module", "class", "function"]


# The value of the fixture -- return/yield of the fixture function (type variable).
_FixtureValue = TypeVar("_FixtureValue")
# The type of the fixture function (type variable).
_FixtureFunction = TypeVar("_FixtureFunction", bound=Callable[..., object])
# The type of a fixture function (type alias generic in fixture value).
_FixtureFunc = Union[
 #allable[..., _FixtureValue], Callable[..., Generator[_FixtureValue, None, None]]
]
# The type of FixtureDef.cached_result (type alias generic in fixture value).
_FixtureCachedResult = Union[
 #uple[
        # The result.
 #FixtureValue,
        # Cache key.
 #bject,
 #one,
 #,
 #uple[
 #one,
        # Cache key.
 #bject,
        # Exc info if raised.
 #uple[Type[BaseException], BaseException, TracebackType],
 #,
]


@attr.s(frozen=True)
class PseudoFixtureDef(Generic[_FixtureValue]):
 #ached_result = attr.ib(type="_FixtureCachedResult[_FixtureValue]")
 #cope = attr.ib(type="_Scope")


def pytest_sessionstart(session: "Session") -> None:
 #ession._fixturemanager = FixtureManager(session)


def get_scope_package(node, fixturedef: "FixtureDef[object]"):
 #mport pytest

 #ls = pytest.Package
 #urrent = node
 #ixture_package_name = "{}/{}".format(fixturedef.baseid, "__init__.py")
 #hile current and (
 #ype(current) is not cls or fixture_package_name != current.nodeid
 #:
 #urrent = current.parent
 #f current is None:
 #eturn node.session
 #eturn current


def get_scope_node(
 #ode: nodes.Node, scope: "_Scope"
) -> Optional[Union[nodes.Item, nodes.Collector]]:
 #mport _pytest.python

 #f scope == "function":
 #eturn node.getparent(nodes.Item)
 #lif scope == "class":
 #eturn node.getparent(_pytest.python.Class)
 #lif scope == "module":
 #eturn node.getparent(_pytest.python.Module)
 #lif scope == "package":
 #eturn node.getparent(_pytest.python.Package)
 #lif scope == "session":
 #eturn node.getparent(_pytest.main.Session)
 #lse:
 #ssert_never(scope)


# Used for storing artificial fixturedefs for direct parametrization.
name2pseudofixturedef_key = StoreKey[Dict[str, "FixtureDef[Any]"]]()


def add_funcarg_pseudo_fixture_def(
 #ollector: nodes.Collector, metafunc: "Metafunc", fixturemanager: "FixtureManager"
) -> None:
    # This function will transform all collected calls to functions
    # if they use direct funcargs (i.e. direct parametrization)
    # because we want later test execution to be able to rely on
    # an existing FixtureDef structure for all arguments.
    # XXX we can probably avoid this algorithm  if we modify CallSpec2
    # to directly care for creating the fixturedefs within its methods.
 #f not metafunc._calls[0].funcargs:
        # This function call does not have direct parametrization.
 #eturn
    # Collect funcargs of all callspecs into a list of values.
 #rg2params: Dict[str, List[object]] = {}
 #rg2scope: Dict[str, _Scope] = {}
 #or callspec in metafunc._calls:
 #or argname, argvalue in callspec.funcargs.items():
 #ssert argname not in callspec.params
 #allspec.params[argname] = argvalue
 #rg2params_list = arg2params.setdefault(argname, [])
 #allspec.indices[argname] = len(arg2params_list)
 #rg2params_list.append(argvalue)
 #f argname not in arg2scope:
 #copenum = callspec._arg2scopenum.get(argname, scopenum_function)
 #rg2scope[argname] = scopes[scopenum]
 #allspec.funcargs.clear()

    # Register artificial FixtureDef's so that later at test execution
    # time we can rely on a proper FixtureDef to exist for fixture setup.
 #rg2fixturedefs = metafunc._arg2fixturedefs
 #or argname, valuelist in arg2params.items():
        # If we have a scope that is higher than function, we need
        # to make sure we only ever create an according fixturedef on
        # a per-scope basis. We thus store and cache the fixturedef on the
        # node related to the scope.
 #cope = arg2scope[argname]
 #ode = None
 #f scope != "function":
 #ode = get_scope_node(collector, scope)
 #f node is None:
 #ssert scope == "class" and isinstance(collector, _pytest.python.Module)
                # Use module-level collector for class-scope (for now).
 #ode = collector
 #f node is None:
 #ame2pseudofixturedef = None
 #lse:
 #efault: Dict[str, FixtureDef[Any]] = {}
 #ame2pseudofixturedef = node._store.setdefault(
 #ame2pseudofixturedef_key, default
 #
 #f name2pseudofixturedef is not None and argname in name2pseudofixturedef:
 #rg2fixturedefs[argname] = [name2pseudofixturedef[argname]]
 #lse:
 #ixturedef = FixtureDef(
 #ixturemanager=fixturemanager,
 #aseid="",
 #rgname=argname,
 #unc=get_direct_param_fixture_func,
 #cope=arg2scope[argname],
 #arams=valuelist,
 #nittest=False,
 #ds=None,
 #
 #rg2fixturedefs[argname] = [fixturedef]
 #f name2pseudofixturedef is not None:
 #ame2pseudofixturedef[argname] = fixturedef


def getfixturemarker(obj: object) -> Optional["FixtureFunctionMarker"]:
 #""Return fixturemarker or None if it doesn't exist or raised
 #xceptions."""
 #ry:
 #ixturemarker: Optional[FixtureFunctionMarker] = getattr(
 #bj, "_pytestfixturefunction", None
 #
 #xcept TEST_OUTCOME:
        # some objects raise errors like request (from flask import request)
        # we don't expect them to be fixture functions
 #eturn None
 #eturn fixturemarker


# Parametrized fixture key, helper alias for code below.
_Key = Tuple[object, ...]


def get_parametrized_fixture_keys(item: nodes.Item, scopenum: int) -> Iterator[_Key]:
 #""Return list of keys for all parametrized arguments which match
 #he specified scope. """
 #ssert scopenum < scopenum_function  # function
 #ry:
 #allspec = item.callspec  # type: ignore[attr-defined]
 #xcept AttributeError:
 #ass
 #lse:
 #s: CallSpec2 = callspec
        # cs.indices.items() is random order of argnames.  Need to
        # sort this so that different calls to
        # get_parametrized_fixture_keys will be deterministic.
 #or argname, param_index in sorted(cs.indices.items()):
 #f cs._arg2scopenum[argname] != scopenum:
 #ontinue
 #f scopenum == 0:  # session
 #ey: _Key = (argname, param_index)
 #lif scopenum == 1:  # package
 #ey = (argname, param_index, item.fspath.dirpath())
 #lif scopenum == 2:  # module
 #ey = (argname, param_index, item.fspath)
 #lif scopenum == 3:  # class
 #tem_cls = item.cls  # type: ignore[attr-defined]
 #ey = (argname, param_index, item.fspath, item_cls)
 #ield key


# Algorithm for sorting on a per-parametrized resource setup basis.
# It is called for scopenum==0 (session) first and performs sorting
# down to the lower scopes such as to minimize number of "high scope"
# setups and teardowns.


def reorder_items(items: Sequence[nodes.Item]) -> List[nodes.Item]:
 #rgkeys_cache: Dict[int, Dict[nodes.Item, Dict[_Key, None]]] = {}
 #tems_by_argkey: Dict[int, Dict[_Key, Deque[nodes.Item]]] = {}
 #or scopenum in range(0, scopenum_function):
 #: Dict[nodes.Item, Dict[_Key, None]] = {}
 #rgkeys_cache[scopenum] = d
 #tem_d: Dict[_Key, Deque[nodes.Item]] = defaultdict(deque)
 #tems_by_argkey[scopenum] = item_d
 #or item in items:
 #eys = dict.fromkeys(get_parametrized_fixture_keys(item, scopenum), None)
 #f keys:
 #[item] = keys
 #or key in keys:
 #tem_d[key].append(item)
 #tems_dict = dict.fromkeys(items, None)
 #eturn list(reorder_items_atscope(items_dict, argkeys_cache, items_by_argkey, 0))


def fix_cache_order(
 #tem: nodes.Item,
 #rgkeys_cache: Dict[int, Dict[nodes.Item, Dict[_Key, None]]],
 #tems_by_argkey: Dict[int, Dict[_Key, "Deque[nodes.Item]"]],
) -> None:
 #or scopenum in range(0, scopenum_function):
 #or key in argkeys_cache[scopenum].get(item, []):
 #tems_by_argkey[scopenum][key].appendleft(item)


def reorder_items_atscope(
 #tems: Dict[nodes.Item, None],
 #rgkeys_cache: Dict[int, Dict[nodes.Item, Dict[_Key, None]]],
 #tems_by_argkey: Dict[int, Dict[_Key, "Deque[nodes.Item]"]],
 #copenum: int,
) -> Dict[nodes.Item, None]:
 #f scopenum >= scopenum_function or len(items) < 3:
 #eturn items
 #gnore: Set[Optional[_Key]] = set()
 #tems_deque = deque(items)
 #tems_done: Dict[nodes.Item, None] = {}
 #coped_items_by_argkey = items_by_argkey[scopenum]
 #coped_argkeys_cache = argkeys_cache[scopenum]
 #hile items_deque:
 #o_argkey_group: Dict[nodes.Item, None] = {}
 #licing_argkey = None
 #hile items_deque:
 #tem = items_deque.popleft()
 #f item in items_done or item in no_argkey_group:
 #ontinue
 #rgkeys = dict.fromkeys(
 #k for k in scoped_argkeys_cache.get(item, []) if k not in ignore), None
 #
 #f not argkeys:
 #o_argkey_group[item] = None
 #lse:
 #licing_argkey, _ = argkeys.popitem()
                # We don't have to remove relevant items from later in the
                # deque because they'll just be ignored.
 #atching_items = [
 # for i in scoped_items_by_argkey[slicing_argkey] if i in items
 #
 #or i in reversed(matching_items):
 #ix_cache_order(i, argkeys_cache, items_by_argkey)
 #tems_deque.appendleft(i)
 #reak
 #f no_argkey_group:
 #o_argkey_group = reorder_items_atscope(
 #o_argkey_group, argkeys_cache, items_by_argkey, scopenum + 1
 #
 #or item in no_argkey_group:
 #tems_done[item] = None
 #gnore.add(slicing_argkey)
 #eturn items_done


def _fillfuncargs(function: "Function") -> None:
 #""Fill missing fixtures for a test function, old public API (deprecated)."""
 #arnings.warn(FILLFUNCARGS.format(name="pytest._fillfuncargs()"), stacklevel=2)
 #fill_fixtures_impl(function)


def fillfixtures(function: "Function") -> None:
 #""Fill missing fixtures for a test function (deprecated)."""
 #arnings.warn(
 #ILLFUNCARGS.format(name="_pytest.fixtures.fillfixtures()"), stacklevel=2
 #
 #fill_fixtures_impl(function)


def _fill_fixtures_impl(function: "Function") -> None:
 #""Internal implementation to fill fixtures on the given function object."""
 #ry:
 #equest = function._request
 #xcept AttributeError:
        # XXX this special code path is only expected to execute
        # with the oejskit plugin.  It uses classes with funcargs
        # and we thus have to work a bit to allow this.
 #m = function.session._fixturemanager
 #ssert function.parent is not None
 #i = fm.getfixtureinfo(function.parent, function.obj, None)
 #unction._fixtureinfo = fi
 #equest = function._request = FixtureRequest(function, _ispytest=True)
 #equest._fillfixtures()
        # Prune out funcargs for jstests.
 #ewfuncargs = {}
 #or name in fi.argnames:
 #ewfuncargs[name] = function.funcargs[name]
 #unction.funcargs = newfuncargs
 #lse:
 #equest._fillfixtures()


def get_direct_param_fixture_func(request):
 #eturn request.param


@attr.s(slots=True)
class FuncFixtureInfo:
    # Original function argument names.
 #rgnames = attr.ib(type=Tuple[str, ...])
    # Argnames that function immediately requires. These include argnames +
    # fixture names specified via usefixtures and via autouse=True in fixture
    # definitions.
 #nitialnames = attr.ib(type=Tuple[str, ...])
 #ames_closure = attr.ib(type=List[str])
 #ame2fixturedefs = attr.ib(type=Dict[str, Sequence["FixtureDef[Any]"]])

 #ef prune_dependency_tree(self) -> None:
 #""Recompute names_closure from initialnames and name2fixturedefs.

 #an only reduce names_closure, which means that the new closure will
 #lways be a subset of the old one. The order is preserved.

 #his method is needed because direct parametrization may shadow some
 #f the fixtures that were included in the originally built dependency
 #ree. In this way the dependency tree can get pruned, and the closure
 #f argnames may get reduced.
 #""
 #losure: Set[str] = set()
 #orking_set = set(self.initialnames)
 #hile working_set:
 #rgname = working_set.pop()
            # Argname may be smth not included in the original names_closure,
            # in which case we ignore it. This currently happens with pseudo
            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.
            # So they introduce the new dependency 'request' which might have
            # been missing in the original tree (closure).
 #f argname not in closure and argname in self.names_closure:
 #losure.add(argname)
 #f argname in self.name2fixturedefs:
 #orking_set.update(self.name2fixturedefs[argname][-1].argnames)

 #elf.names_closure[:] = sorted(closure, key=self.names_closure.index)


class FixtureRequest:
 #""A request for a fixture from a test or fixture function.

 # request object gives access to the requesting test context and has
 #n optional ``param`` attribute in case the fixture is parametrized
 #ndirectly.
 #""

 #ef __init__(self, pyfuncitem, *, _ispytest: bool = False) -> None:
 #heck_ispytest(_ispytest)
 #elf._pyfuncitem = pyfuncitem
        #: Fixture for which this request is being performed.
 #elf.fixturename: Optional[str] = None
        #: Scope string, one of "function", "class", "module", "session".
 #elf.scope: _Scope = "function"
 #elf._fixture_defs: Dict[str, FixtureDef[Any]] = {}
 #ixtureinfo: FuncFixtureInfo = pyfuncitem._fixtureinfo
 #elf._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()
 #elf._arg2index: Dict[str, int] = {}
 #elf._fixturemanager: FixtureManager = (pyfuncitem.session._fixturemanager)

 #property
 #ef fixturenames(self) -> List[str]:
 #""Names of all active fixtures in this request."""
 #esult = list(self._pyfuncitem._fixtureinfo.names_closure)
 #esult.extend(set(self._fixture_defs).difference(result))
 #eturn result

 #property
 #ef node(self):
 #""Underlying collection node (depends on current request scope)."""
 #eturn self._getscopeitem(self.scope)

 #ef _getnextfixturedef(self, argname: str) -> "FixtureDef[Any]":
 #ixturedefs = self._arg2fixturedefs.get(argname, None)
 #f fixturedefs is None:
            # We arrive here because of a dynamic call to
            # getfixturevalue(argname) usage which was naturally
            # not known at parsing/collection time.
 #ssert self._pyfuncitem.parent is not None
 #arentid = self._pyfuncitem.parent.nodeid
 #ixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)
            # TODO: Fix this type ignore. Either add assert or adjust types.
            #       Can this be None here?
 #elf._arg2fixturedefs[argname] = fixturedefs  # type: ignore[assignment]
        # fixturedefs list is immutable so we maintain a decreasing index.
 #ndex = self._arg2index.get(argname, 0) - 1
 #f fixturedefs is None or (-index > len(fixturedefs)):
 #aise FixtureLookupError(argname, self)
 #elf._arg2index[argname] = index
 #eturn fixturedefs[index]

 #property
 #ef config(self) -> Config:
 #""The pytest config object associated with this request."""
 #eturn self._pyfuncitem.config  # type: ignore[no-any-return]

 #property
 #ef function(self):
 #""Test function object if the request has a per-function scope."""
 #f self.scope != "function":
 #aise AttributeError(
 #"function not available in {self.scope}-scoped context"
 #
 #eturn self._pyfuncitem.obj

 #property
 #ef cls(self):
 #""Class (can be None) where the test function was collected."""
 #f self.scope not in ("class", "function"):
 #aise AttributeError(f"cls not available in {self.scope}-scoped context")
 #lscol = self._pyfuncitem.getparent(_pytest.python.Class)
 #f clscol:
 #eturn clscol.obj

 #property
 #ef instance(self):
 #""Instance (can be None) on which test function was collected."""
        # unittest support hack, see _pytest.unittest.TestCaseFunction.
 #ry:
 #eturn self._pyfuncitem._testcase
 #xcept AttributeError:
 #unction = getattr(self, "function", None)
 #eturn getattr(function, "__self__", None)

 #property
 #ef module(self):
 #""Python module object where the test function was collected."""
 #f self.scope not in ("function", "class", "module"):
 #aise AttributeError(f"module not available in {self.scope}-scoped context")
 #eturn self._pyfuncitem.getparent(_pytest.python.Module).obj

 #property
 #ef fspath(self) -> py.path.local:
 #""The file system path of the test module which collected this test."""
 #f self.scope not in ("function", "class", "module", "package"):
 #aise AttributeError(f"module not available in {self.scope}-scoped context")
        # TODO: Remove ignore once _pyfuncitem is properly typed.
 #eturn self._pyfuncitem.fspath  # type: ignore

 #property
 #ef keywords(self):
 #""Keywords/markers dictionary for the underlying node."""
 #eturn self.node.keywords

 #property
 #ef session(self) -> "Session":
 #""Pytest session object."""
 #eturn self._pyfuncitem.session  # type: ignore[no-any-return]

 #ef addfinalizer(self, finalizer: Callable[[], object]) -> None:
 #""Add finalizer/teardown function to be called after the last test
 #ithin the requesting test context finished execution."""
        # XXX usually this method is shadowed by fixturedef specific ones.
 #elf._addfinalizer(finalizer, scope=self.scope)

 #ef _addfinalizer(self, finalizer: Callable[[], object], scope) -> None:
 #olitem = self._getscopeitem(scope)
 #elf._pyfuncitem.session._setupstate.addfinalizer(
 #inalizer=finalizer, colitem=colitem
 #

 #ef applymarker(self, marker: Union[str, MarkDecorator]) -> None:
 #""Apply a marker to a single test function invocation.

 #his method is useful if you don't want to have a keyword/marker
 #n all function invocations.

 #param marker:
 # :py:class:`_pytest.mark.MarkDecorator` object created by a call
 #o ``pytest.mark.NAME(...)``.
 #""
 #elf.node.add_marker(marker)

 #ef raiseerror(self, msg: Optional[str]) -> "NoReturn":
 #""Raise a FixtureLookupError with the given message."""
 #aise self._fixturemanager.FixtureLookupError(None, self, msg)

 #ef _fillfixtures(self) -> None:
 #tem = self._pyfuncitem
 #ixturenames = getattr(item, "fixturenames", self.fixturenames)
 #or argname in fixturenames:
 #f argname not in item.funcargs:
 #tem.funcargs[argname] = self.getfixturevalue(argname)

 #ef getfixturevalue(self, argname: str) -> Any:
 #""Dynamically run a named fixture function.

 #eclaring fixtures via function argument is recommended where possible.
 #ut if you can only decide whether to use another fixture at test
 #etup time, you may use this function to retrieve it inside a fixture
 #r test function body.

 #raises pytest.FixtureLookupError:
 #f the given fixture could not be found.
 #""
 #ixturedef = self._get_active_fixturedef(argname)
 #ssert fixturedef.cached_result is not None
 #eturn fixturedef.cached_result[0]

 #ef _get_active_fixturedef(
 #elf, argname: str
 # -> Union["FixtureDef[object]", PseudoFixtureDef[object]]:
 #ry:
 #eturn self._fixture_defs[argname]
 #xcept KeyError:
 #ry:
 #ixturedef = self._getnextfixturedef(argname)
 #xcept FixtureLookupError:
 #f argname == "request":
 #ached_result = (self, [0], None)
 #cope: _Scope = "function"
 #eturn PseudoFixtureDef(cached_result, scope)
 #aise
        # Remove indent to prevent the python3 exception
        # from leaking into the call.
 #elf._compute_fixture_value(fixturedef)
 #elf._fixture_defs[argname] = fixturedef
 #eturn fixturedef

 #ef _get_fixturestack(self) -> List["FixtureDef[Any]"]:
 #urrent = self
 #alues: List[FixtureDef[Any]] = []
 #hile 1:
 #ixturedef = getattr(current, "_fixturedef", None)
 #f fixturedef is None:
 #alues.reverse()
 #eturn values
 #alues.append(fixturedef)
 #ssert isinstance(current, SubRequest)
 #urrent = current._parent_request

 #ef _compute_fixture_value(self, fixturedef: "FixtureDef[object]") -> None:
 #""Create a SubRequest based on "self" and call the execute method
 #f the given FixtureDef object.

 #his will force the FixtureDef object to throw away any previous
 #esults and compute a new fixture value, which will be stored into
 #he FixtureDef object itself.
 #""
        # prepare a subrequest object before calling fixture function
        # (latter managed by fixturedef)
 #rgname = fixturedef.argname
 #uncitem = self._pyfuncitem
 #cope = fixturedef.scope
 #ry:
 #aram = funcitem.callspec.getparam(argname)
 #xcept (AttributeError, ValueError):
 #aram = NOTSET
 #aram_index = 0
 #as_params = fixturedef.params is not None
 #ixtures_not_supported = getattr(funcitem, "nofuncargs", False)
 #f has_params and fixtures_not_supported:
 #sg = (
 #{name} does not support fixtures, maybe unittest.TestCase subclass?\n"
 #Node id: {nodeid}\n"
 #Function type: {typename}"
 #.format(
 #ame=funcitem.name,
 #odeid=funcitem.nodeid,
 #ypename=type(funcitem).__name__,
 #
 #ail(msg, pytrace=False)
 #f has_params:
 #rame = inspect.stack()[3]
 #rameinfo = inspect.getframeinfo(frame[0])
 #ource_path = py.path.local(frameinfo.filename)
 #ource_lineno = frameinfo.lineno
 #el_source_path = source_path.relto(funcitem.config.rootdir)
 #f rel_source_path:
 #ource_path_str = rel_source_path
 #lse:
 #ource_path_str = str(source_path)
 #sg = (
 #The requested fixture has no parameter defined for test:\n"
 #    {}\n\n"
 #Requested fixture '{}' defined in:\n{}"
 #\n\nRequested here:\n{}:{}".format(
 #uncitem.nodeid,
 #ixturedef.argname,
 #etlocation(fixturedef.func, funcitem.config.rootdir),
 #ource_path_str,
 #ource_lineno,
 #
 #
 #ail(msg, pytrace=False)
 #lse:
 #aram_index = funcitem.callspec.indices[argname]
            # If a parametrize invocation set a scope it will override
            # the static scope defined with the fixture function.
 #aramscopenum = funcitem.callspec._arg2scopenum.get(argname)
 #f paramscopenum is not None:
 #cope = scopes[paramscopenum]

 #ubrequest = SubRequest(
 #elf, scope, param, param_index, fixturedef, _ispytest=True
 #

        # Check if a higher-level scoped fixture accesses a lower level one.
 #ubrequest._check_scope(argname, self.scope, scope)
 #ry:
            # Call the fixture function.
 #ixturedef.execute(request=subrequest)
 #inally:
 #elf._schedule_finalizers(fixturedef, subrequest)

 #ef _schedule_finalizers(
 #elf, fixturedef: "FixtureDef[object]", subrequest: "SubRequest"
 # -> None:
        # If fixture function failed it might have registered finalizers.
 #elf.session._setupstate.addfinalizer(
 #unctools.partial(fixturedef.finish, request=subrequest), subrequest.node
 #

 #ef _check_scope(
 #elf, argname: str, invoking_scope: "_Scope", requested_scope: "_Scope",
 # -> None:
 #f argname == "request":
 #eturn
 #f scopemismatch(invoking_scope, requested_scope):
            # Try to report something helpful.
 #ines = self._factorytraceback()
 #ail(
 #ScopeMismatch: You tried to access the %r scoped "
 #fixture %r with a %r scoped request object, "
 #involved factories\n%s"
 # ((requested_scope, argname, invoking_scope, "\n".join(lines))),
 #ytrace=False,
 #

 #ef _factorytraceback(self) -> List[str]:
 #ines = []
 #or fixturedef in self._get_fixturestack():
 #actory = fixturedef.func
 #s, lineno = getfslineno(factory)
 # = self._pyfuncitem.session.fspath.bestrelpath(fs)
 #rgs = _format_args(factory)
 #ines.append("%s:%d:  def %s%s" % (p, lineno + 1, factory.__name__, args))
 #eturn lines

 #ef _getscopeitem(self, scope: "_Scope") -> Union[nodes.Item, nodes.Collector]:
 #f scope == "function":
            # This might also be a non-function Item despite its attribute name.
 #ode: Optional[Union[nodes.Item, nodes.Collector]] = self._pyfuncitem
 #lif scope == "package":
            # FIXME: _fixturedef is not defined on FixtureRequest (this class),
            # but on FixtureRequest (a subclass).
 #ode = get_scope_package(self._pyfuncitem, self._fixturedef)  # type: ignore[attr-defined]
 #lse:
 #ode = get_scope_node(self._pyfuncitem, scope)
 #f node is None and scope == "class":
            # Fallback to function item itself.
 #ode = self._pyfuncitem
 #ssert node, 'Could not obtain a node for scope "{}" for function {!r}'.format(
 #cope, self._pyfuncitem
 #
 #eturn node

 #ef __repr__(self) -> str:
 #eturn "<FixtureRequest for %r>" % (self.node)


@final
class SubRequest(FixtureRequest):
 #""A sub request for handling getting a fixture from a test function/fixture."""

 #ef __init__(
 #elf,
 #equest: "FixtureRequest",
 #cope: "_Scope",
 #aram,
 #aram_index: int,
 #ixturedef: "FixtureDef[object]",
 #,
 #ispytest: bool = False,
 # -> None:
 #heck_ispytest(_ispytest)
 #elf._parent_request = request
 #elf.fixturename = fixturedef.argname
 #f param is not NOTSET:
 #elf.param = param
 #elf.param_index = param_index
 #elf.scope = scope
 #elf._fixturedef = fixturedef
 #elf._pyfuncitem = request._pyfuncitem
 #elf._fixture_defs = request._fixture_defs
 #elf._arg2fixturedefs = request._arg2fixturedefs
 #elf._arg2index = request._arg2index
 #elf._fixturemanager = request._fixturemanager

 #ef __repr__(self) -> str:
 #eturn f"<SubRequest {self.fixturename!r} for {self._pyfuncitem!r}>"

 #ef addfinalizer(self, finalizer: Callable[[], object]) -> None:
 #""Add finalizer/teardown function to be called after the last test
 #ithin the requesting test context finished execution."""
 #elf._fixturedef.addfinalizer(finalizer)

 #ef _schedule_finalizers(
 #elf, fixturedef: "FixtureDef[object]", subrequest: "SubRequest"
 # -> None:
        # If the executing fixturedef was not explicitly requested in the argument list (via
        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished
        # first.
 #f fixturedef.argname not in self.fixturenames:
 #ixturedef.addfinalizer(
 #unctools.partial(self._fixturedef.finish, request=self)
 #
 #uper()._schedule_finalizers(fixturedef, subrequest)


scopes: List["_Scope"] = ["session", "package", "module", "class", "function"]
scopenum_function = scopes.index("function")


def scopemismatch(currentscope: "_Scope", newscope: "_Scope") -> bool:
 #eturn scopes.index(newscope) > scopes.index(currentscope)


def scope2index(scope: str, descr: str, where: Optional[str] = None) -> int:
 #""Look up the index of ``scope`` and raise a descriptive value error
 #f not defined."""
 #trscopes: Sequence[str] = scopes
 #ry:
 #eturn strscopes.index(scope)
 #xcept ValueError:
 #ail(
 #{} {}got an unexpected scope value '{}'".format(
 #escr, f"from {where} " if where else "", scope
 #,
 #ytrace=False,
 #


@final
class FixtureLookupError(LookupError):
 #""Could not return a requested fixture (missing or invalid)."""

 #ef __init__(
 #elf, argname: Optional[str], request: FixtureRequest, msg: Optional[str] = None
 # -> None:
 #elf.argname = argname
 #elf.request = request
 #elf.fixturestack = request._get_fixturestack()
 #elf.msg = msg

 #ef formatrepr(self) -> "FixtureLookupErrorRepr":
 #blines: List[str] = []
 #ddline = tblines.append
 #tack = [self.request._pyfuncitem.obj]
 #tack.extend(map(lambda x: x.func, self.fixturestack))
 #sg = self.msg
 #f msg is not None:
            # The last fixture raise an error, let's present
            # it at the requesting side.
 #tack = stack[:-1]
 #or function in stack:
 #spath, lineno = getfslineno(function)
 #ry:
 #ines, _ = inspect.getsourcelines(get_real_func(function))
 #xcept (OSError, IndexError, TypeError):
 #rror_msg = "file %s, line %s: source code not available"
 #ddline(error_msg % (fspath, lineno + 1))
 #lse:
 #ddline("file {}, line {}".format(fspath, lineno + 1))
 #or i, line in enumerate(lines):
 #ine = line.rstrip()
 #ddline("  " + line)
 #f line.lstrip().startswith("def"):
 #reak

 #f msg is None:
 #m = self.request._fixturemanager
 #vailable = set()
 #arentid = self.request._pyfuncitem.parent.nodeid
 #or name, fixturedefs in fm._arg2fixturedefs.items():
 #aclist = list(fm._matchfactories(fixturedefs, parentid))
 #f faclist:
 #vailable.add(name)
 #f self.argname in available:
 #sg = " recursive dependency involving fixture '{}' detected".format(
 #elf.argname
 #
 #lse:
 #sg = f"fixture '{self.argname}' not found"
 #sg += "\n available fixtures: {}".format(", ".join(sorted(available)))
 #sg += "\n use 'pytest --fixtures [testpath]' for help on them."

 #eturn FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)


class FixtureLookupErrorRepr(TerminalRepr):
 #ef __init__(
 #elf,
 #ilename: Union[str, py.path.local],
 #irstlineno: int,
 #blines: Sequence[str],
 #rrorstring: str,
 #rgname: Optional[str],
 # -> None:
 #elf.tblines = tblines
 #elf.errorstring = errorstring
 #elf.filename = filename
 #elf.firstlineno = firstlineno
 #elf.argname = argname

 #ef toterminal(self, tw: TerminalWriter) -> None:
        # tw.line("FixtureLookupError: %s" %(self.argname), red=True)
 #or tbline in self.tblines:
 #w.line(tbline.rstrip())
 #ines = self.errorstring.split("\n")
 #f lines:
 #w.line(
 #{}       {}".format(FormattedExcinfo.fail_marker, lines[0].strip()),
 #ed=True,
 #
 #or line in lines[1:]:
 #w.line(
 #"{FormattedExcinfo.flow_marker}       {line.strip()}", red=True,
 #
 #w.line()
 #w.line("%s:%d" % (self.filename, self.firstlineno + 1))


def fail_fixturefunc(fixturefunc, msg: str) -> "NoReturn":
 #s, lineno = getfslineno(fixturefunc)
 #ocation = "{}:{}".format(fs, lineno + 1)
 #ource = _pytest._code.Source(fixturefunc)
 #ail(msg + ":\n\n" + str(source.indent()) + "\n" + location, pytrace=False)


def call_fixture_func(
 #ixturefunc: "_FixtureFunc[_FixtureValue]", request: FixtureRequest, kwargs
) -> _FixtureValue:
 #f is_generator(fixturefunc):
 #ixturefunc = cast(
 #allable[..., Generator[_FixtureValue, None, None]], fixturefunc
 #
 #enerator = fixturefunc(**kwargs)
 #ry:
 #ixture_result = next(generator)
 #xcept StopIteration:
 #aise ValueError(f"{request.fixturename} did not yield a value") from None
 #inalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)
 #equest.addfinalizer(finalizer)
 #lse:
 #ixturefunc = cast(Callable[..., _FixtureValue], fixturefunc)
 #ixture_result = fixturefunc(**kwargs)
 #eturn fixture_result


def _teardown_yield_fixture(fixturefunc, it) -> None:
 #""Execute the teardown of a fixture function by advancing the iterator
 #fter the yield and ensure the iteration ends (if not it means there is
 #ore than one yield in the function)."""
 #ry:
 #ext(it)
 #xcept StopIteration:
 #ass
 #lse:
 #ail_fixturefunc(fixturefunc, "fixture function has more than one 'yield'")


def _eval_scope_callable(
 #cope_callable: "Callable[[str, Config], _Scope]",
 #ixture_name: str,
 #onfig: Config,
) -> "_Scope":
 #ry:
        # Type ignored because there is no typing mechanism to specify
        # keyword arguments, currently.
 #esult = scope_callable(fixture_name=fixture_name, config=config)  # type: ignore[call-arg]
 #xcept Exception as e:
 #aise TypeError(
 #Error evaluating {} while defining fixture '{}'.\n"
 #Expected a function with the signature (*, fixture_name, config)".format(
 #cope_callable, fixture_name
 #
 # from e
 #f not isinstance(result, str):
 #ail(
 #Expected {} to return a 'str' while defining fixture '{}', but it returned:\n"
 #{!r}".format(scope_callable, fixture_name, result),
 #ytrace=False,
 #
 #eturn result


@final
class FixtureDef(Generic[_FixtureValue]):
 #""A container for a factory definition."""

 #ef __init__(
 #elf,
 #ixturemanager: "FixtureManager",
 #aseid: Optional[str],
 #rgname: str,
 #unc: "_FixtureFunc[_FixtureValue]",
 #cope: "Union[_Scope, Callable[[str, Config], _Scope]]",
 #arams: Optional[Sequence[object]],
 #nittest: bool = False,
 #ds: Optional[
 #nion[
 #uple[Union[None, str, float, int, bool], ...],
 #allable[[Any], Optional[object]],
 #
 # = None,
 # -> None:
 #elf._fixturemanager = fixturemanager
 #elf.baseid = baseid or ""
 #elf.has_location = baseid is not None
 #elf.func = func
 #elf.argname = argname
 #f callable(scope):
 #cope_ = _eval_scope_callable(scope, argname, fixturemanager.config)
 #lse:
 #cope_ = scope
 #elf.scopenum = scope2index(
            # TODO: Check if the `or` here is really necessary.
 #cope_ or "function",  # type: ignore[unreachable]
 #escr=f"Fixture '{func.__name__}'",
 #here=baseid,
 #
 #elf.scope = scope_
 #elf.params: Optional[Sequence[object]] = params
 #elf.argnames: Tuple[str, ...] = getfuncargnames(
 #unc, name=argname, is_method=unittest
 #
 #elf.unittest = unittest
 #elf.ids = ids
 #elf.cached_result: Optional[_FixtureCachedResult[_FixtureValue]] = None
 #elf._finalizers: List[Callable[[], object]] = []

 #ef addfinalizer(self, finalizer: Callable[[], object]) -> None:
 #elf._finalizers.append(finalizer)

 #ef finish(self, request: SubRequest) -> None:
 #xc = None
 #ry:
 #hile self._finalizers:
 #ry:
 #unc = self._finalizers.pop()
 #unc()
 #xcept BaseException as e:
                    # XXX Only first exception will be seen by user,
                    #     ideally all should be reported.
 #f exc is None:
 #xc = e
 #f exc:
 #aise exc
 #inally:
 #ook = self._fixturemanager.session.gethookproxy(request.node.fspath)
 #ook.pytest_fixture_post_finalizer(fixturedef=self, request=request)
            # Even if finalization fails, we invalidate the cached fixture
            # value and remove all finalizers because they may be bound methods
            # which will keep instances alive.
 #elf.cached_result = None
 #elf._finalizers = []

 #ef execute(self, request: SubRequest) -> _FixtureValue:
        # Get required arguments and register our own finish()
        # with their finalization.
 #or argname in self.argnames:
 #ixturedef = request._get_active_fixturedef(argname)
 #f argname != "request":
                # PseudoFixtureDef is only for "request".
 #ssert isinstance(fixturedef, FixtureDef)
 #ixturedef.addfinalizer(functools.partial(self.finish, request=request))

 #y_cache_key = self.cache_key(request)
 #f self.cached_result is not None:
            # note: comparison with `==` can fail (or be expensive) for e.g.
            # numpy arrays (#6497).
 #ache_key = self.cached_result[1]
 #f my_cache_key is cache_key:
 #f self.cached_result[2] is not None:
 #, val, tb = self.cached_result[2]
 #aise val.with_traceback(tb)
 #lse:
 #esult = self.cached_result[0]
 #eturn result
            # We have a previous but differently parametrized fixture instance
            # so we need to tear it down before creating a new one.
 #elf.finish(request)
 #ssert self.cached_result is None

 #ook = self._fixturemanager.session.gethookproxy(request.node.fspath)
 #esult = hook.pytest_fixture_setup(fixturedef=self, request=request)
 #eturn result

 #ef cache_key(self, request: SubRequest) -> object:
 #eturn request.param_index if not hasattr(request, "param") else request.param

 #ef __repr__(self) -> str:
 #eturn "<FixtureDef argname={!r} scope={!r} baseid={!r}>".format(
 #elf.argname, self.scope, self.baseid
 #


def resolve_fixture_function(
 #ixturedef: FixtureDef[_FixtureValue], request: FixtureRequest
) -> "_FixtureFunc[_FixtureValue]":
 #""Get the actual callable that can be called to obtain the fixture
 #alue, dealing with unittest-specific instances and bound methods."""
 #ixturefunc = fixturedef.func
 #f fixturedef.unittest:
 #f request.instance is not None:
            # Bind the unbound method to the TestCase instance.
 #ixturefunc = fixturedef.func.__get__(request.instance)  # type: ignore[union-attr]
 #lse:
        # The fixture function needs to be bound to the actual
        # request.instance so that code working with "fixturedef" behaves
        # as expected.
 #f request.instance is not None:
            # Handle the case where fixture is defined not in a test class, but some other class
            # (for example a plugin class with a fixture), see #2270.
 #f hasattr(fixturefunc, "__self__") and not isinstance(
 #equest.instance, fixturefunc.__self__.__class__  # type: ignore[union-attr]
 #:
 #eturn fixturefunc
 #ixturefunc = getimfunc(fixturedef.func)
 #f fixturefunc != fixturedef.func:
 #ixturefunc = fixturefunc.__get__(request.instance)  # type: ignore[union-attr]
 #eturn fixturefunc


def pytest_fixture_setup(
 #ixturedef: FixtureDef[_FixtureValue], request: SubRequest
) -> _FixtureValue:
 #""Execution of fixture setup."""
 #wargs = {}
 #or argname in fixturedef.argnames:
 #ixdef = request._get_active_fixturedef(argname)
 #ssert fixdef.cached_result is not None
 #esult, arg_cache_key, exc = fixdef.cached_result
 #equest._check_scope(argname, request.scope, fixdef.scope)
 #wargs[argname] = result

 #ixturefunc = resolve_fixture_function(fixturedef, request)
 #y_cache_key = fixturedef.cache_key(request)
 #ry:
 #esult = call_fixture_func(fixturefunc, request, kwargs)
 #xcept TEST_OUTCOME:
 #xc_info = sys.exc_info()
 #ssert exc_info[0] is not None
 #ixturedef.cached_result = (None, my_cache_key, exc_info)
 #aise
 #ixturedef.cached_result = (result, my_cache_key, None)
 #eturn result


def _ensure_immutable_ids(
 #ds: Optional[
 #nion[
 #terable[Union[None, str, float, int, bool]],
 #allable[[Any], Optional[object]],
 #
 #,
) -> Optional[
 #nion[
 #uple[Union[None, str, float, int, bool], ...],
 #allable[[Any], Optional[object]],
 #
]:
 #f ids is None:
 #eturn None
 #f callable(ids):
 #eturn ids
 #eturn tuple(ids)


def _params_converter(
 #arams: Optional[Iterable[object]],
) -> Optional[Tuple[object, ...]]:
 #eturn tuple(params) if params is not None else None


def wrap_function_to_error_out_if_called_directly(
 #unction: _FixtureFunction, fixture_marker: "FixtureFunctionMarker",
) -> _FixtureFunction:
 #""Wrap the given fixture function so we can raise an error about it being called directly,
 #nstead of used as an argument in a test function."""
 #essage = (
 #Fixture "{name}" called directly. Fixtures are not meant to be called directly,\n'
 #but are created automatically when test functions request them as parameters.\n"
 #See https://docs.pytest.org/en/stable/fixture.html for more information about fixtures, and\n"
 #https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code."
 #.format(name=fixture_marker.name or function.__name__)

 #functools.wraps(function)
 #ef result(*args, **kwargs):
 #ail(message, pytrace=False)

    # Keep reference to the original function in our own custom attribute so we don't unwrap
    # further than this point and lose useful wrappings like @mock.patch (#3774).
 #esult.__pytest_wrapped__ = _PytestWrapper(function)  # type: ignore[attr-defined]

 #eturn cast(_FixtureFunction, result)


@final
@attr.s(frozen=True)
class FixtureFunctionMarker:
 #cope = attr.ib(type="Union[_Scope, Callable[[str, Config], _Scope]]")
 #arams = attr.ib(type=Optional[Tuple[object, ...]], converter=_params_converter)
 #utouse = attr.ib(type=bool, default=False)
 #ds = attr.ib(
 #ype=Union[
 #uple[Union[None, str, float, int, bool], ...],
 #allable[[Any], Optional[object]],
 #,
 #efault=None,
 #onverter=_ensure_immutable_ids,
 #
 #ame = attr.ib(type=Optional[str], default=None)

 #ef __call__(self, function: _FixtureFunction) -> _FixtureFunction:
 #f inspect.isclass(function):
 #aise ValueError("class fixtures not supported (maybe in the future)")

 #f getattr(function, "_pytestfixturefunction", False):
 #aise ValueError(
 #fixture is being applied more than once to the same function"
 #

 #unction = wrap_function_to_error_out_if_called_directly(function, self)

 #ame = self.name or function.__name__
 #f name == "request":
 #ocation = getlocation(function)
 #ail(
 #'request' is a reserved word for fixtures, use another name:\n  {}".format(
 #ocation
 #,
 #ytrace=False,
 #

        # Type ignored because https://github.com/python/mypy/issues/2087.
 #unction._pytestfixturefunction = self  # type: ignore[attr-defined]
 #eturn function


@overload
def fixture(
 #ixture_function: _FixtureFunction,
 #,
 #cope: "Union[_Scope, Callable[[str, Config], _Scope]]" = ...,
 #arams: Optional[Iterable[object]] = ...,
 #utouse: bool = ...,
 #ds: Optional[
 #nion[
 #terable[Union[None, str, float, int, bool]],
 #allable[[Any], Optional[object]],
 #
 # = ...,
 #ame: Optional[str] = ...,
) -> _FixtureFunction:
 #..


@overload
def fixture(
 #ixture_function: None = ...,
 #,
 #cope: "Union[_Scope, Callable[[str, Config], _Scope]]" = ...,
 #arams: Optional[Iterable[object]] = ...,
 #utouse: bool = ...,
 #ds: Optional[
 #nion[
 #terable[Union[None, str, float, int, bool]],
 #allable[[Any], Optional[object]],
 #
 # = ...,
 #ame: Optional[str] = None,
) -> FixtureFunctionMarker:
 #..


def fixture(
 #ixture_function: Optional[_FixtureFunction] = None,
 #,
 #cope: "Union[_Scope, Callable[[str, Config], _Scope]]" = "function",
 #arams: Optional[Iterable[object]] = None,
 #utouse: bool = False,
 #ds: Optional[
 #nion[
 #terable[Union[None, str, float, int, bool]],
 #allable[[Any], Optional[object]],
 #
 # = None,
 #ame: Optional[str] = None,
) -> Union[FixtureFunctionMarker, _FixtureFunction]:
 #""Decorator to mark a fixture factory function.

 #his decorator can be used, with or without parameters, to define a
 #ixture function.

 #he name of the fixture function can later be referenced to cause its
 #nvocation ahead of running tests: test modules or classes can use the
 #`pytest.mark.usefixtures(fixturename)`` marker.

 #est functions can directly use fixture names as input arguments in which
 #ase the fixture instance returned from the fixture function will be
 #njected.

 #ixtures can provide their values to test functions using ``return`` or
 #`yield`` statements. When using ``yield`` the code block after the
 #`yield`` statement is executed as teardown code regardless of the test
 #utcome, and must yield exactly once.

 #param scope:
 #he scope for which this fixture is shared; one of ``"function"``
 #default), ``"class"``, ``"module"``, ``"package"`` or ``"session"``.

 #his parameter may also be a callable which receives ``(fixture_name, config)``
 #s parameters, and must return a ``str`` with one of the values mentioned above.

 #ee :ref:`dynamic scope` in the docs for more information.

 #param params:
 #n optional list of parameters which will cause multiple invocations
 #f the fixture function and all of the tests using it. The current
 #arameter is available in ``request.param``.

 #param autouse:
 #f True, the fixture func is activated for all tests that can see it.
 #f False (the default), an explicit reference is needed to activate
 #he fixture.

 #param ids:
 #ist of string ids each corresponding to the params so that they are
 #art of the test id. If no ids are provided they will be generated
 #utomatically from the params.

 #param name:
 #he name of the fixture. This defaults to the name of the decorated
 #unction. If a fixture is used in the same module in which it is
 #efined, the function name of the fixture will be shadowed by the
 #unction arg that requests the fixture; one way to resolve this is to
 #ame the decorated function ``fixture_<fixturename>`` and then use
 #`@pytest.fixture(name='<fixturename>')``.
 #""
 #ixture_marker = FixtureFunctionMarker(
 #cope=scope, params=params, autouse=autouse, ids=ids, name=name,
 #

    # Direct decoration.
 #f fixture_function:
 #eturn fixture_marker(fixture_function)

 #eturn fixture_marker


def yield_fixture(
 #ixture_function=None,
 #args,
 #cope="function",
 #arams=None,
 #utouse=False,
 #ds=None,
 #ame=None,
):
 #""(Return a) decorator to mark a yield-fixture factory function.

 #. deprecated:: 3.0
 #se :py:func:`pytest.fixture` directly instead.
 #""
 #arnings.warn(YIELD_FIXTURE, stacklevel=2)
 #eturn fixture(
 #ixture_function,
 #args,
 #cope=scope,
 #arams=params,
 #utouse=autouse,
 #ds=ids,
 #ame=name,
 #


@fixture(scope="session")
def pytestconfig(request: FixtureRequest) -> Config:
 #""Session-scoped fixture that returns the :class:`_pytest.config.Config` object.

 #xample::

 #ef test_foo(pytestconfig):
 #f pytestconfig.getoption("verbose") > 0:
 #..

 #""
 #eturn request.config


def pytest_addoption(parser: Parser) -> None:
 #arser.addini(
 #usefixtures",
 #ype="args",
 #efault=[],
 #elp="list of default fixtures to be used with this project",
 #


class FixtureManager:
 #""pytest fixture definitions and information is stored and managed
 #rom this class.

 #uring collection fm.parsefactories() is called multiple times to parse
 #ixture function definitions into FixtureDef objects and internal
 #ata structures.

 #uring collection of test functions, metafunc-mechanics instantiate
 # FuncFixtureInfo object which is cached per node/func-name.
 #his FuncFixtureInfo object is later retrieved by Function nodes
 #hich themselves offer a fixturenames attribute.

 #he FuncFixtureInfo object holds information about fixtures and FixtureDefs
 #elevant for a particular function. An initial list of fixtures is
 #ssembled like this:

 # ini-defined usefixtures
 # autouse-marked fixtures along the collection chain up from the function
 # usefixtures markers at module/class/function level
 # test function funcargs

 #ubsequently the funcfixtureinfo.fixturenames attribute is computed
 #s the closure of the fixtures needed to setup the initial fixtures,
 #.e. fixtures needed by fixture functions themselves are appended
 #o the fixturenames list.

 #pon the test-setup phases all fixturenames are instantiated, retrieved
 #y a lookup of their FuncFixtureInfo.
 #""

 #ixtureLookupError = FixtureLookupError
 #ixtureLookupErrorRepr = FixtureLookupErrorRepr

 #ef __init__(self, session: "Session") -> None:
 #elf.session = session
 #elf.config: Config = session.config
 #elf._arg2fixturedefs: Dict[str, List[FixtureDef[Any]]] = {}
 #elf._holderobjseen: Set[object] = set()
        # A mapping from a nodeid to a list of autouse fixtures it defines.
 #elf._nodeid_autousenames: Dict[str, List[str]] = {
 #": self.config.getini("usefixtures"),
 #
 #ession.config.pluginmanager.register(self, "funcmanage")

 #ef _get_direct_parametrize_args(self, node: nodes.Node) -> List[str]:
 #""Return all direct parametrization arguments of a node, so we don't
 #istake them for fixtures.

 #heck https://github.com/pytest-dev/pytest/issues/5036.

 #hese things are done later as well when dealing with parametrization
 #o this could be improved.
 #""
 #arametrize_argnames: List[str] = []
 #or marker in node.iter_markers(name="parametrize"):
 #f not marker.kwargs.get("indirect", False):
 #_argnames, _ = ParameterSet._parse_parametrize_args(
 #marker.args, **marker.kwargs
 #
 #arametrize_argnames.extend(p_argnames)

 #eturn parametrize_argnames

 #ef getfixtureinfo(
 #elf, node: nodes.Node, func, cls, funcargs: bool = True
 # -> FuncFixtureInfo:
 #f funcargs and not getattr(node, "nofuncargs", False):
 #rgnames = getfuncargnames(func, name=node.name, cls=cls)
 #lse:
 #rgnames = ()

 #sefixtures = tuple(
 #rg for mark in node.iter_markers(name="usefixtures") for arg in mark.args
 #
 #nitialnames = usefixtures + argnames
 #m = node.session._fixturemanager
 #nitialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(
 #nitialnames, node, ignore_args=self._get_direct_parametrize_args(node)
 #
 #eturn FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)

 #ef pytest_plugin_registered(self, plugin: _PluggyPlugin) -> None:
 #odeid = None
 #ry:
 # = absolutepath(plugin.__file__)  # type: ignore[attr-defined]
 #xcept AttributeError:
 #ass
 #lse:
            # Construct the base nodeid which is later used to check
            # what fixtures are visible for particular tests (as denoted
            # by their test id).
 #f p.name.startswith("conftest.py"):
 #ry:
 #odeid = str(p.parent.relative_to(self.config.rootpath))
 #xcept ValueError:
 #odeid = ""
 #f nodeid == ".":
 #odeid = ""
 #f os.sep != nodes.SEP:
 #odeid = nodeid.replace(os.sep, nodes.SEP)

 #elf.parsefactories(plugin, nodeid)

 #ef _getautousenames(self, nodeid: str) -> Iterator[str]:
 #""Return the names of autouse fixtures applicable to nodeid."""
 #or parentnodeid in nodes.iterparentnodeids(nodeid):
 #asenames = self._nodeid_autousenames.get(parentnodeid)
 #f basenames:
 #ield from basenames

 #ef getfixtureclosure(
 #elf,
 #ixturenames: Tuple[str, ...],
 #arentnode: nodes.Node,
 #gnore_args: Sequence[str] = (),
 # -> Tuple[Tuple[str, ...], List[str], Dict[str, Sequence[FixtureDef[Any]]]]:
        # Collect the closure of all fixtures, starting with the given
        # fixturenames as the initial set.  As we have to visit all
        # factory definitions anyway, we also return an arg2fixturedefs
        # mapping so that the caller can reuse it and does not have
        # to re-discover fixturedefs again for each fixturename
        # (discovering matching fixtures for a given name/node is expensive).

 #arentid = parentnode.nodeid
 #ixturenames_closure = list(self._getautousenames(parentid))

 #ef merge(otherlist: Iterable[str]) -> None:
 #or arg in otherlist:
 #f arg not in fixturenames_closure:
 #ixturenames_closure.append(arg)

 #erge(fixturenames)

        # At this point, fixturenames_closure contains what we call "initialnames",
        # which is a set of fixturenames the function immediately requests. We
        # need to return it as well, so save this.
 #nitialnames = tuple(fixturenames_closure)

 #rg2fixturedefs: Dict[str, Sequence[FixtureDef[Any]]] = {}
 #astlen = -1
 #hile lastlen != len(fixturenames_closure):
 #astlen = len(fixturenames_closure)
 #or argname in fixturenames_closure:
 #f argname in ignore_args:
 #ontinue
 #f argname in arg2fixturedefs:
 #ontinue
 #ixturedefs = self.getfixturedefs(argname, parentid)
 #f fixturedefs:
 #rg2fixturedefs[argname] = fixturedefs
 #erge(fixturedefs[-1].argnames)

 #ef sort_by_scope(arg_name: str) -> int:
 #ry:
 #ixturedefs = arg2fixturedefs[arg_name]
 #xcept KeyError:
 #eturn scopes.index("function")
 #lse:
 #eturn fixturedefs[-1].scopenum

 #ixturenames_closure.sort(key=sort_by_scope)
 #eturn initialnames, fixturenames_closure, arg2fixturedefs

 #ef pytest_generate_tests(self, metafunc: "Metafunc") -> None:
 #""Generate new tests based on parametrized fixtures used by the given metafunc"""

 #ef get_parametrize_mark_argnames(mark: Mark) -> Sequence[str]:
 #rgs, _ = ParameterSet._parse_parametrize_args(*mark.args, **mark.kwargs)
 #eturn args

 #or argname in metafunc.fixturenames:
            # Get the FixtureDefs for the argname.
 #ixture_defs = metafunc._arg2fixturedefs.get(argname)
 #f not fixture_defs:
                # Will raise FixtureLookupError at setup time if not parametrized somewhere
                # else (e.g @pytest.mark.parametrize)
 #ontinue

            # If the test itself parametrizes using this argname, give it
            # precedence.
 #f any(
 #rgname in get_parametrize_mark_argnames(mark)
 #or mark in metafunc.definition.iter_markers("parametrize")
 #:
 #ontinue

            # In the common case we only look at the fixture def with the
            # closest scope (last in the list). But if the fixture overrides
            # another fixture, while requesting the super fixture, keep going
            # in case the super fixture is parametrized (#1953).
 #or fixturedef in reversed(fixture_defs):
                # Fixture is parametrized, apply it and stop.
 #f fixturedef.params is not None:
 #etafunc.parametrize(
 #rgname,
 #ixturedef.params,
 #ndirect=True,
 #cope=fixturedef.scope,
 #ds=fixturedef.ids,
 #
 #reak

                # Not requesting the overridden super fixture, stop.
 #f argname not in fixturedef.argnames:
 #reak

                # Try next super fixture, if any.

 #ef pytest_collection_modifyitems(self, items: List[nodes.Item]) -> None:
        # Separate parametrized setups.
 #tems[:] = reorder_items(items)

 #ef parsefactories(
 #elf, node_or_obj, nodeid=NOTSET, unittest: bool = False
 # -> None:
 #f nodeid is not NOTSET:
 #olderobj = node_or_obj
 #lse:
 #olderobj = node_or_obj.obj
 #odeid = node_or_obj.nodeid
 #f holderobj in self._holderobjseen:
 #eturn

 #elf._holderobjseen.add(holderobj)
 #utousenames = []
 #or name in dir(holderobj):
            # The attribute can be an arbitrary descriptor, so the attribute
            # access below can raise. safe_getatt() ignores such exceptions.
 #bj = safe_getattr(holderobj, name, None)
 #arker = getfixturemarker(obj)
 #f not isinstance(marker, FixtureFunctionMarker):
                # Magic globals  with __getattr__ might have got us a wrong
                # fixture attribute.
 #ontinue

 #f marker.name:
 #ame = marker.name

            # During fixture definition we wrap the original fixture function
            # to issue a warning if called directly, so here we unwrap it in
            # order to not emit the warning when pytest itself calls the
            # fixture function.
 #bj = get_real_method(obj, holderobj)

 #ixture_def = FixtureDef(
 #ixturemanager=self,
 #aseid=nodeid,
 #rgname=name,
 #unc=obj,
 #cope=marker.scope,
 #arams=marker.params,
 #nittest=unittest,
 #ds=marker.ids,
 #

 #aclist = self._arg2fixturedefs.setdefault(name, [])
 #f fixture_def.has_location:
 #aclist.append(fixture_def)
 #lse:
                # fixturedefs with no location are at the front
                # so this inserts the current fixturedef after the
                # existing fixturedefs from external plugins but
                # before the fixturedefs provided in conftests.
 # = len([f for f in faclist if not f.has_location])
 #aclist.insert(i, fixture_def)
 #f marker.autouse:
 #utousenames.append(name)

 #f autousenames:
 #elf._nodeid_autousenames.setdefault(nodeid or "", []).extend(autousenames)

 #ef getfixturedefs(
 #elf, argname: str, nodeid: str
 # -> Optional[Sequence[FixtureDef[Any]]]:
 #""Get a list of fixtures which are applicable to the given node id.

 #param str argname: Name of the fixture to search for.
 #param str nodeid: Full node id of the requesting test.
 #rtype: Sequence[FixtureDef]
 #""
 #ry:
 #ixturedefs = self._arg2fixturedefs[argname]
 #xcept KeyError:
 #eturn None
 #eturn tuple(self._matchfactories(fixturedefs, nodeid))

 #ef _matchfactories(
 #elf, fixturedefs: Iterable[FixtureDef[Any]], nodeid: str
 # -> Iterator[FixtureDef[Any]]:
 #arentnodeids = set(nodes.iterparentnodeids(nodeid))
 #or fixturedef in fixturedefs:
 #f fixturedef.baseid in parentnodeids:
 #ield fixturedef
