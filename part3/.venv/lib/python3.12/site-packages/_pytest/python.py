"""Python test discovery, setup and run of test functions."""
import enum
import fnmatch
import inspect
import itertools
import os
import sys
import types
import warnings
from collections import Counter
from collections import defaultdict
from functools import partial
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generator
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union

import py

import _pytest
from _pytest import fixtures
from _pytest import nodes
from _pytest._code import filter_traceback
from _pytest._code import getfslineno
from _pytest._code.code import ExceptionInfo
from _pytest._code.code import TerminalRepr
from _pytest._io import TerminalWriter
from _pytest._io.saferepr import saferepr
from _pytest.compat import ascii_escaped
from _pytest.compat import final
from _pytest.compat import get_default_arg_names
from _pytest.compat import get_real_func
from _pytest.compat import getimfunc
from _pytest.compat import getlocation
from _pytest.compat import is_async_function
from _pytest.compat import is_generator
from _pytest.compat import NOTSET
from _pytest.compat import REGEX_TYPE
from _pytest.compat import safe_getattr
from _pytest.compat import safe_isclass
from _pytest.compat import STRING_TYPES
from _pytest.config import Config
from _pytest.config import ExitCode
from _pytest.config import hookimpl
from _pytest.config.argparsing import Parser
from _pytest.deprecated import FSCOLLECTOR_GETHOOKPROXY_ISINITPATH
from _pytest.fixtures import FuncFixtureInfo
from _pytest.main import Session
from _pytest.mark import MARK_GEN
from _pytest.mark import ParameterSet
from _pytest.mark.structures import get_unpacked_marks
from _pytest.mark.structures import Mark
from _pytest.mark.structures import MarkDecorator
from _pytest.mark.structures import normalize_mark_list
from _pytest.outcomes import fail
from _pytest.outcomes import skip
from _pytest.pathlib import import_path
from _pytest.pathlib import ImportPathMismatchError
from _pytest.pathlib import parts
from _pytest.pathlib import visit
from _pytest.warning_types import PytestCollectionWarning
from _pytest.warning_types import PytestUnhandledCoroutineWarning

if TYPE_CHECKING:
 #rom typing_extensions import Literal
 #rom _pytest.fixtures import _Scope


def pytest_addoption(parser: Parser) -> None:
 #roup = parser.getgroup("general")
 #roup.addoption(
 #--fixtures",
 #--funcargs",
 #ction="store_true",
 #est="showfixtures",
 #efault=False,
 #elp="show available fixtures, sorted by plugin appearance "
 #(fixtures with leading '_' are only shown with '-v')",
 #
 #roup.addoption(
 #--fixtures-per-test",
 #ction="store_true",
 #est="show_fixtures_per_test",
 #efault=False,
 #elp="show fixtures per test",
 #
 #arser.addini(
 #python_files",
 #ype="args",
        # NOTE: default is also used in AssertionRewritingHook.
 #efault=["test_*.py", "*_test.py"],
 #elp="glob-style file patterns for Python test module discovery",
 #
 #arser.addini(
 #python_classes",
 #ype="args",
 #efault=["Test"],
 #elp="prefixes or glob names for Python test class discovery",
 #
 #arser.addini(
 #python_functions",
 #ype="args",
 #efault=["test"],
 #elp="prefixes or glob names for Python test function and method discovery",
 #
 #arser.addini(
 #disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
 #ype="bool",
 #efault=False,
 #elp="disable string escape non-ascii characters, might cause unwanted "
 #side effects(use at your own risk)",
 #


def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:
 #f config.option.showfixtures:
 #howfixtures(config)
 #eturn 0
 #f config.option.show_fixtures_per_test:
 #how_fixtures_per_test(config)
 #eturn 0
 #eturn None


def pytest_generate_tests(metafunc: "Metafunc") -> None:
 #or marker in metafunc.definition.iter_markers(name="parametrize"):
        # TODO: Fix this type-ignore (overlapping kwargs).
 #etafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)  # type: ignore[misc]


def pytest_configure(config: Config) -> None:
 #onfig.addinivalue_line(
 #markers",
 #parametrize(argnames, argvalues): call a test function multiple "
 #times passing in different arguments in turn. argvalues generally "
 #needs to be a list of values if argnames specifies only one name "
 #or a list of tuples of values if argnames specifies multiple names. "
 #Example: @parametrize('arg1', [1,2]) would lead to two calls of the "
 #decorated test function, one with arg1=1 and another with arg1=2."
 #see https://docs.pytest.org/en/stable/parametrize.html for more info "
 #and examples.",
 #
 #onfig.addinivalue_line(
 #markers",
 #usefixtures(fixturename1, fixturename2, ...): mark tests as needing "
 #all of the specified fixtures. see "
 #https://docs.pytest.org/en/stable/fixture.html#usefixtures ",
 #


def async_warn_and_skip(nodeid: str) -> None:
 #sg = "async def functions are not natively supported and have been skipped.\n"
 #sg += (
 #You need to install a suitable plugin for your async framework, for example:\n"
 #
 #sg += "  - anyio\n"
 #sg += "  - pytest-asyncio\n"
 #sg += "  - pytest-tornasync\n"
 #sg += "  - pytest-trio\n"
 #sg += "  - pytest-twisted"
 #arnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))
 #kip(msg="async def function and no async plugin installed (see warnings)")


@hookimpl(trylast=True)
def pytest_pyfunc_call(pyfuncitem: "Function") -> Optional[object]:
 #estfunction = pyfuncitem.obj
 #f is_async_function(testfunction):
 #sync_warn_and_skip(pyfuncitem.nodeid)
 #uncargs = pyfuncitem.funcargs
 #estargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
 #esult = testfunction(**testargs)
 #f hasattr(result, "__await__") or hasattr(result, "__aiter__"):
 #sync_warn_and_skip(pyfuncitem.nodeid)
 #eturn True


def pytest_collect_file(
 #ath: py.path.local, parent: nodes.Collector
) -> Optional["Module"]:
 #xt = path.ext
 #f ext == ".py":
 #f not parent.session.isinitpath(path):
 #f not path_matches_patterns(
 #ath, parent.config.getini("python_files") + ["__init__.py"]
 #:
 #eturn None
 #hook = parent.session.gethookproxy(path)
 #odule: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)
 #eturn module
 #eturn None


def path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:
 #""Return whether path matches any of the patterns in the list of globs given."""
 #eturn any(path.fnmatch(pattern) for pattern in patterns)


def pytest_pycollect_makemodule(path: py.path.local, parent) -> "Module":
 #f path.basename == "__init__.py":
 #kg: Package = Package.from_parent(parent, fspath=path)
 #eturn pkg
 #od: Module = Module.from_parent(parent, fspath=path)
 #eturn mod


@hookimpl(trylast=True)
def pytest_pycollect_makeitem(collector: "PyCollector", name: str, obj: object):
    # Nothing was collected elsewhere, let's do it here.
 #f safe_isclass(obj):
 #f collector.istestclass(obj, name):
 #eturn Class.from_parent(collector, name=name, obj=obj)
 #lif collector.istestfunction(obj, name):
        # mock seems to store unbound methods (issue473), normalize it.
 #bj = getattr(obj, "__func__", obj)
        # We need to try and unwrap the function if it's a functools.partial
        # or a functools.wrapped.
        # We mustn't if it's been wrapped with mock.patch (python 2 only).
 #f not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):
 #ilename, lineno = getfslineno(obj)
 #arnings.warn_explicit(
 #essage=PytestCollectionWarning(
 #cannot collect %r because it is not a function." % name
 #,
 #ategory=None,
 #ilename=str(filename),
 #ineno=lineno + 1,
 #
 #lif getattr(obj, "__test__", True):
 #f is_generator(obj):
 #es = Function.from_parent(collector, name=name)
 #eason = "yield tests were removed in pytest 4.0 - {name} will be ignored".format(
 #ame=name
 #
 #es.add_marker(MARK_GEN.xfail(run=False, reason=reason))
 #es.warn(PytestCollectionWarning(reason))
 #lse:
 #es = list(collector._genfunctions(name, obj))
 #eturn res


class PyobjMixin:
 #ALLOW_MARKERS = True

    # Function and attributes that the mixin needs (for type-checking only).
 #f TYPE_CHECKING:
 #ame: str = ""
 #arent: Optional[nodes.Node] = None
 #wn_markers: List[Mark] = []

 #ef getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:
 #..

 #ef listchain(self) -> List[nodes.Node]:
 #..

 #property
 #ef module(self):
 #""Python module object this node was collected from (can be None)."""
 #ode = self.getparent(Module)
 #eturn node.obj if node is not None else None

 #property
 #ef cls(self):
 #""Python class object this node was collected from (can be None)."""
 #ode = self.getparent(Class)
 #eturn node.obj if node is not None else None

 #property
 #ef instance(self):
 #""Python instance object this node was collected from (can be None)."""
 #ode = self.getparent(Instance)
 #eturn node.obj if node is not None else None

 #property
 #ef obj(self):
 #""Underlying Python object."""
 #bj = getattr(self, "_obj", None)
 #f obj is None:
 #elf._obj = obj = self._getobj()
            # XXX evil hack
            # used to avoid Instance collector marker duplication
 #f self._ALLOW_MARKERS:
 #elf.own_markers.extend(get_unpacked_marks(self.obj))
 #eturn obj

 #obj.setter
 #ef obj(self, value):
 #elf._obj = value

 #ef _getobj(self):
 #""Get the underlying Python object. May be overwritten by subclasses."""
        # TODO: Improve the type of `parent` such that assert/ignore aren't needed.
 #ssert self.parent is not None
 #bj = self.parent.obj  # type: ignore[attr-defined]
 #eturn getattr(obj, self.name)

 #ef getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str:
 #""Return Python path relative to the containing module."""
 #hain = self.listchain()
 #hain.reverse()
 #arts = []
 #or node in chain:
 #f isinstance(node, Instance):
 #ontinue
 #ame = node.name
 #f isinstance(node, Module):
 #ame = os.path.splitext(name)[0]
 #f stopatmodule:
 #f includemodule:
 #arts.append(name)
 #reak
 #arts.append(name)
 #arts.reverse()
 #eturn ".".join(parts)

 #ef reportinfo(self) -> Tuple[Union[py.path.local, str], int, str]:
        # XXX caching?
 #bj = self.obj
 #ompat_co_firstlineno = getattr(obj, "compat_co_firstlineno", None)
 #f isinstance(compat_co_firstlineno, int):
            # nose compatibility
 #ile_path = sys.modules[obj.__module__].__file__
 #f file_path.endswith(".pyc"):
 #ile_path = file_path[:-1]
 #spath: Union[py.path.local, str] = file_path
 #ineno = compat_co_firstlineno
 #lse:
 #spath, lineno = getfslineno(obj)
 #odpath = self.getmodpath()
 #ssert isinstance(lineno, int)
 #eturn fspath, lineno, modpath


# As an optimization, these builtin attribute names are pre-ignored when
# iterating over an object during collection -- the pytest_pycollect_makeitem
# hook is not called for them.
# fmt: off
class _EmptyClass: pass  # noqa: E701
IGNORED_ATTRIBUTES = frozenset.union(  # noqa: E305
 #rozenset(),
    # Module.
 #ir(types.ModuleType("empty_module")),
    # Some extra module attributes the above doesn't catch.
 #"__builtins__", "__file__", "__cached__"},
    # Class.
 #ir(_EmptyClass),
    # Instance.
 #ir(_EmptyClass()),
)
del _EmptyClass
# fmt: on


class PyCollector(PyobjMixin, nodes.Collector):
 #ef funcnamefilter(self, name: str) -> bool:
 #eturn self._matches_prefix_or_glob_option("python_functions", name)

 #ef isnosetest(self, obj: object) -> bool:
 #""Look for the __test__ attribute, which is applied by the
 #nose.tools.istest decorator.
 #""
        # We explicitly check for "is True" here to not mistakenly treat
        # classes with a custom __getattr__ returning something truthy (like a
        # function) as test classes.
 #eturn safe_getattr(obj, "__test__", False) is True

 #ef classnamefilter(self, name: str) -> bool:
 #eturn self._matches_prefix_or_glob_option("python_classes", name)

 #ef istestfunction(self, obj: object, name: str) -> bool:
 #f self.funcnamefilter(name) or self.isnosetest(obj):
 #f isinstance(obj, staticmethod):
                # staticmethods need to be unwrapped.
 #bj = safe_getattr(obj, "__func__", False)
 #eturn (
 #afe_getattr(obj, "__call__", False)
 #nd fixtures.getfixturemarker(obj) is None
 #
 #lse:
 #eturn False

 #ef istestclass(self, obj: object, name: str) -> bool:
 #eturn self.classnamefilter(name) or self.isnosetest(obj)

 #ef _matches_prefix_or_glob_option(self, option_name: str, name: str) -> bool:
 #""Check if the given name matches the prefix or glob-pattern defined
 #n ini configuration."""
 #or option in self.config.getini(option_name):
 #f name.startswith(option):
 #eturn True
            # Check that name looks like a glob-string before calling fnmatch
            # because this is called for every name in each collected module,
            # and fnmatch is somewhat expensive to call.
 #lif ("*" in option or "?" in option or "[" in option) and fnmatch.fnmatch(
 #ame, option
 #:
 #eturn True
 #eturn False

 #ef collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:
 #f not getattr(self.obj, "__test__", True):
 #eturn []

        # NB. we avoid random getattrs and peek in the __dict__ instead
        # (XXX originally introduced from a PyPy need, still true?)
 #icts = [getattr(self.obj, "__dict__", {})]
 #or basecls in self.obj.__class__.__mro__:
 #icts.append(basecls.__dict__)
 #een: Set[str] = set()
 #alues: List[Union[nodes.Item, nodes.Collector]] = []
 #hook = self.ihook
 #or dic in dicts:
            # Note: seems like the dict can change during iteration -
            # be careful not to remove the list() without consideration.
 #or name, obj in list(dic.items()):
 #f name in IGNORED_ATTRIBUTES:
 #ontinue
 #f name in seen:
 #ontinue
 #een.add(name)
 #es = ihook.pytest_pycollect_makeitem(
 #ollector=self, name=name, obj=obj
 #
 #f res is None:
 #ontinue
 #lif isinstance(res, list):
 #alues.extend(res)
 #lse:
 #alues.append(res)

 #ef sort_key(item):
 #spath, lineno, _ = item.reportinfo()
 #eturn (str(fspath), lineno)

 #alues.sort(key=sort_key)
 #eturn values

 #ef _genfunctions(self, name: str, funcobj) -> Iterator["Function"]:
 #odulecol = self.getparent(Module)
 #ssert modulecol is not None
 #odule = modulecol.obj
 #lscol = self.getparent(Class)
 #ls = clscol and clscol.obj or None
 #m = self.session._fixturemanager

 #efinition = FunctionDefinition.from_parent(self, name=name, callobj=funcobj)
 #ixtureinfo = definition._fixtureinfo

 #etafunc = Metafunc(
 #efinition, fixtureinfo, self.config, cls=cls, module=module
 #
 #ethods = []
 #f hasattr(module, "pytest_generate_tests"):
 #ethods.append(module.pytest_generate_tests)
 #f cls is not None and hasattr(cls, "pytest_generate_tests"):
 #ethods.append(cls().pytest_generate_tests)

 #elf.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))

 #f not metafunc._calls:
 #ield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)
 #lse:
            # Add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs.
 #ixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)

            # Add_funcarg_pseudo_fixture_def may have shadowed some fixtures
            # with direct parametrization, so make sure we update what the
            # function really needs.
 #ixtureinfo.prune_dependency_tree()

 #or callspec in metafunc._calls:
 #ubname = f"{name}[{callspec.id}]"
 #ield Function.from_parent(
 #elf,
 #ame=subname,
 #allspec=callspec,
 #allobj=funcobj,
 #ixtureinfo=fixtureinfo,
 #eywords={callspec.id: True},
 #riginalname=name,
 #


class Module(nodes.File, PyCollector):
 #""Collector for test classes and functions."""

 #ef _getobj(self):
 #eturn self._importtestmodule()

 #ef collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:
 #elf._inject_setup_module_fixture()
 #elf._inject_setup_function_fixture()
 #elf.session._fixturemanager.parsefactories(self)
 #eturn super().collect()

 #ef _inject_setup_module_fixture(self) -> None:
 #""Inject a hidden autouse, module scoped fixture into the collected module object
 #hat invokes setUpModule/tearDownModule if either or both are available.

 #sing a fixture to invoke this methods ensures we play nicely and unsurprisingly with
 #ther fixtures (#517).
 #""
 #etup_module = _get_first_non_fixture_func(
 #elf.obj, ("setUpModule", "setup_module")
 #
 #eardown_module = _get_first_non_fixture_func(
 #elf.obj, ("tearDownModule", "teardown_module")
 #

 #f setup_module is None and teardown_module is None:
 #eturn

 #fixtures.fixture(
 #utouse=True,
 #cope="module",
            # Use a unique name to speed up lookup.
 #ame=f"xunit_setup_module_fixture_{self.obj.__name__}",
 #
 #ef xunit_setup_module_fixture(request) -> Generator[None, None, None]:
 #f setup_module is not None:
 #call_with_optional_argument(setup_module, request.module)
 #ield
 #f teardown_module is not None:
 #call_with_optional_argument(teardown_module, request.module)

 #elf.obj.__pytest_setup_module = xunit_setup_module_fixture

 #ef _inject_setup_function_fixture(self) -> None:
 #""Inject a hidden autouse, function scoped fixture into the collected module object
 #hat invokes setup_function/teardown_function if either or both are available.

 #sing a fixture to invoke this methods ensures we play nicely and unsurprisingly with
 #ther fixtures (#517).
 #""
 #etup_function = _get_first_non_fixture_func(self.obj, ("setup_function",))
 #eardown_function = _get_first_non_fixture_func(
 #elf.obj, ("teardown_function",)
 #
 #f setup_function is None and teardown_function is None:
 #eturn

 #fixtures.fixture(
 #utouse=True,
 #cope="function",
            # Use a unique name to speed up lookup.
 #ame=f"xunit_setup_function_fixture_{self.obj.__name__}",
 #
 #ef xunit_setup_function_fixture(request) -> Generator[None, None, None]:
 #f request.instance is not None:
                # in this case we are bound to an instance, so we need to let
                # setup_method handle this
 #ield
 #eturn
 #f setup_function is not None:
 #call_with_optional_argument(setup_function, request.function)
 #ield
 #f teardown_function is not None:
 #call_with_optional_argument(teardown_function, request.function)

 #elf.obj.__pytest_setup_function = xunit_setup_function_fixture

 #ef _importtestmodule(self):
        # We assume we are only called once per module.
 #mportmode = self.config.getoption("--import-mode")
 #ry:
 #od = import_path(self.fspath, mode=importmode)
 #xcept SyntaxError as e:
 #aise self.CollectError(
 #xceptionInfo.from_current().getrepr(style="short")
 # from e
 #xcept ImportPathMismatchError as e:
 #aise self.CollectError(
 #import file mismatch:\n"
 #imported module %r has this __file__ attribute:\n"
 #  %s\n"
 #which is not the same as the test file we want to collect:\n"
 #  %s\n"
 #HINT: remove __pycache__ / .pyc files and/or use a "
 #unique basename for your test file modules" % e.args
 # from e
 #xcept ImportError as e:
 #xc_info = ExceptionInfo.from_current()
 #f self.config.getoption("verbose") < 2:
 #xc_info.traceback = exc_info.traceback.filter(filter_traceback)
 #xc_repr = (
 #xc_info.getrepr(style="short")
 #f exc_info.traceback
 #lse exc_info.exconly()
 #
 #ormatted_tb = str(exc_repr)
 #aise self.CollectError(
 #ImportError while importing test module '{fspath}'.\n"
 #Hint: make sure your test modules/packages have valid Python names.\n"
 #Traceback:\n"
 #{traceback}".format(fspath=self.fspath, traceback=formatted_tb)
 # from e
 #xcept skip.Exception as e:
 #f e.allow_module_level:
 #aise
 #aise self.CollectError(
 #Using pytest.skip outside of a test is not allowed. "
 #To decorate a test function, use the @pytest.mark.skip "
 #or @pytest.mark.skipif decorators instead, and to skip a "
 #module use `pytestmark = pytest.mark.{skip,skipif}."
 # from e
 #elf.config.pluginmanager.consider_module(mod)
 #eturn mod


class Package(Module):
 #ef __init__(
 #elf,
 #spath: py.path.local,
 #arent: nodes.Collector,
        # NOTE: following args are unused:
 #onfig=None,
 #ession=None,
 #odeid=None,
 # -> None:
        # NOTE: Could be just the following, but kept as-is for compat.
        # nodes.FSCollector.__init__(self, fspath, parent=parent)
 #ession = parent.session
 #odes.FSCollector.__init__(
 #elf, fspath, parent=parent, config=config, session=session, nodeid=nodeid
 #
 #elf.name = os.path.basename(str(fspath.dirname))

 #ef setup(self) -> None:
        # Not using fixtures to call setup_module here because autouse fixtures
        # from packages are not called automatically (#4085).
 #etup_module = _get_first_non_fixture_func(
 #elf.obj, ("setUpModule", "setup_module")
 #
 #f setup_module is not None:
 #call_with_optional_argument(setup_module, self.obj)

 #eardown_module = _get_first_non_fixture_func(
 #elf.obj, ("tearDownModule", "teardown_module")
 #
 #f teardown_module is not None:
 #unc = partial(_call_with_optional_argument, teardown_module, self.obj)
 #elf.addfinalizer(func)

 #ef gethookproxy(self, fspath: py.path.local):
 #arnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH, stacklevel=2)
 #eturn self.session.gethookproxy(fspath)

 #ef isinitpath(self, path: py.path.local) -> bool:
 #arnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH, stacklevel=2)
 #eturn self.session.isinitpath(path)

 #ef _recurse(self, direntry: "os.DirEntry[str]") -> bool:
 #f direntry.name == "__pycache__":
 #eturn False
 #ath = py.path.local(direntry.path)
 #hook = self.session.gethookproxy(path.dirpath())
 #f ihook.pytest_ignore_collect(path=path, config=self.config):
 #eturn False
 #orecursepatterns = self.config.getini("norecursedirs")
 #f any(path.check(fnmatch=pat) for pat in norecursepatterns):
 #eturn False
 #eturn True

 #ef _collectfile(
 #elf, path: py.path.local, handle_dupes: bool = True
 # -> Sequence[nodes.Collector]:
 #ssert (
 #ath.isfile()
 #, "{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})".format(
 #ath, path.isdir(), path.exists(), path.islink()
 #
 #hook = self.session.gethookproxy(path)
 #f not self.session.isinitpath(path):
 #f ihook.pytest_ignore_collect(path=path, config=self.config):
 #eturn ()

 #f handle_dupes:
 #eepduplicates = self.config.getoption("keepduplicates")
 #f not keepduplicates:
 #uplicate_paths = self.config.pluginmanager._duplicatepaths
 #f path in duplicate_paths:
 #eturn ()
 #lse:
 #uplicate_paths.add(path)

 #eturn ihook.pytest_collect_file(path=path, parent=self)  # type: ignore[no-any-return]

 #ef collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:
 #his_path = self.fspath.dirpath()
 #nit_module = this_path.join("__init__.py")
 #f init_module.check(file=1) and path_matches_patterns(
 #nit_module, self.config.getini("python_files")
 #:
 #ield Module.from_parent(self, fspath=init_module)
 #kg_prefixes: Set[py.path.local] = set()
 #or direntry in visit(str(this_path), recurse=self._recurse):
 #ath = py.path.local(direntry.path)

            # We will visit our own __init__.py file, in which case we skip it.
 #f direntry.is_file():
 #f direntry.name == "__init__.py" and path.dirpath() == this_path:
 #ontinue

 #arts_ = parts(direntry.path)
 #f any(
 #tr(pkg_prefix) in parts_ and pkg_prefix.join("__init__.py") != path
 #or pkg_prefix in pkg_prefixes
 #:
 #ontinue

 #f direntry.is_file():
 #ield from self._collectfile(path)
 #lif not direntry.is_dir():
                # Broken symlink or invalid/missing file.
 #ontinue
 #lif path.join("__init__.py").check(file=1):
 #kg_prefixes.add(path)


def _call_with_optional_argument(func, arg) -> None:
 #""Call the given function with the given argument if func accepts one argument, otherwise
 #alls func without arguments."""
 #rg_count = func.__code__.co_argcount
 #f inspect.ismethod(func):
 #rg_count -= 1
 #f arg_count:
 #unc(arg)
 #lse:
 #unc()


def _get_first_non_fixture_func(obj: object, names: Iterable[str]):
 #""Return the attribute from the given object to be used as a setup/teardown
 #unit-style function, but only if not marked as a fixture to avoid calling it twice."""
 #or name in names:
 #eth = getattr(obj, name, None)
 #f meth is not None and fixtures.getfixturemarker(meth) is None:
 #eturn meth


class Class(PyCollector):
 #""Collector for test methods."""

 #classmethod
 #ef from_parent(cls, parent, *, name, obj=None):
 #""The public constructor."""
 #eturn super().from_parent(name=name, parent=parent)

 #ef collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:
 #f not safe_getattr(self.obj, "__test__", True):
 #eturn []
 #f hasinit(self.obj):
 #ssert self.parent is not None
 #elf.warn(
 #ytestCollectionWarning(
 #cannot collect test class %r because it has a "
 #__init__ constructor (from: %s)"
 # (self.obj.__name__, self.parent.nodeid)
 #
 #
 #eturn []
 #lif hasnew(self.obj):
 #ssert self.parent is not None
 #elf.warn(
 #ytestCollectionWarning(
 #cannot collect test class %r because it has a "
 #__new__ constructor (from: %s)"
 # (self.obj.__name__, self.parent.nodeid)
 #
 #
 #eturn []

 #elf._inject_setup_class_fixture()
 #elf._inject_setup_method_fixture()

 #eturn [Instance.from_parent(self, name="()")]

 #ef _inject_setup_class_fixture(self) -> None:
 #""Inject a hidden autouse, class scoped fixture into the collected class object
 #hat invokes setup_class/teardown_class if either or both are available.

 #sing a fixture to invoke this methods ensures we play nicely and unsurprisingly with
 #ther fixtures (#517).
 #""
 #etup_class = _get_first_non_fixture_func(self.obj, ("setup_class",))
 #eardown_class = getattr(self.obj, "teardown_class", None)
 #f setup_class is None and teardown_class is None:
 #eturn

 #fixtures.fixture(
 #utouse=True,
 #cope="class",
            # Use a unique name to speed up lookup.
 #ame=f"xunit_setup_class_fixture_{self.obj.__qualname__}",
 #
 #ef xunit_setup_class_fixture(cls) -> Generator[None, None, None]:
 #f setup_class is not None:
 #unc = getimfunc(setup_class)
 #call_with_optional_argument(func, self.obj)
 #ield
 #f teardown_class is not None:
 #unc = getimfunc(teardown_class)
 #call_with_optional_argument(func, self.obj)

 #elf.obj.__pytest_setup_class = xunit_setup_class_fixture

 #ef _inject_setup_method_fixture(self) -> None:
 #""Inject a hidden autouse, function scoped fixture into the collected class object
 #hat invokes setup_method/teardown_method if either or both are available.

 #sing a fixture to invoke this methods ensures we play nicely and unsurprisingly with
 #ther fixtures (#517).
 #""
 #etup_method = _get_first_non_fixture_func(self.obj, ("setup_method",))
 #eardown_method = getattr(self.obj, "teardown_method", None)
 #f setup_method is None and teardown_method is None:
 #eturn

 #fixtures.fixture(
 #utouse=True,
 #cope="function",
            # Use a unique name to speed up lookup.
 #ame=f"xunit_setup_method_fixture_{self.obj.__qualname__}",
 #
 #ef xunit_setup_method_fixture(self, request) -> Generator[None, None, None]:
 #ethod = request.function
 #f setup_method is not None:
 #unc = getattr(self, "setup_method")
 #call_with_optional_argument(func, method)
 #ield
 #f teardown_method is not None:
 #unc = getattr(self, "teardown_method")
 #call_with_optional_argument(func, method)

 #elf.obj.__pytest_setup_method = xunit_setup_method_fixture


class Instance(PyCollector):
 #ALLOW_MARKERS = False  # hack, destroy later
    # Instances share the object with their parents in a way
    # that duplicates markers instances if not taken out
    # can be removed at node structure reorganization time.

 #ef _getobj(self):
        # TODO: Improve the type of `parent` such that assert/ignore aren't needed.
 #ssert self.parent is not None
 #bj = self.parent.obj  # type: ignore[attr-defined]
 #eturn obj()

 #ef collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:
 #elf.session._fixturemanager.parsefactories(self)
 #eturn super().collect()

 #ef newinstance(self):
 #elf.obj = self._getobj()
 #eturn self.obj


def hasinit(obj: object) -> bool:
 #nit: object = getattr(obj, "__init__", None)
 #f init:
 #eturn init != object.__init__
 #eturn False


def hasnew(obj: object) -> bool:
 #ew: object = getattr(obj, "__new__", None)
 #f new:
 #eturn new != object.__new__
 #eturn False


@final
class CallSpec2:
 #ef __init__(self, metafunc: "Metafunc") -> None:
 #elf.metafunc = metafunc
 #elf.funcargs: Dict[str, object] = {}
 #elf._idlist: List[str] = []
 #elf.params: Dict[str, object] = {}
        # Used for sorting parametrized resources.
 #elf._arg2scopenum: Dict[str, int] = {}
 #elf.marks: List[Mark] = []
 #elf.indices: Dict[str, int] = {}

 #ef copy(self) -> "CallSpec2":
 #s = CallSpec2(self.metafunc)
 #s.funcargs.update(self.funcargs)
 #s.params.update(self.params)
 #s.marks.extend(self.marks)
 #s.indices.update(self.indices)
 #s._arg2scopenum.update(self._arg2scopenum)
 #s._idlist = list(self._idlist)
 #eturn cs

 #ef _checkargnotcontained(self, arg: str) -> None:
 #f arg in self.params or arg in self.funcargs:
 #aise ValueError(f"duplicate {arg!r}")

 #ef getparam(self, name: str) -> object:
 #ry:
 #eturn self.params[name]
 #xcept KeyError as e:
 #aise ValueError(name) from e

 #property
 #ef id(self) -> str:
 #eturn "-".join(map(str, self._idlist))

 #ef setmulti2(
 #elf,
 #altypes: Mapping[str, "Literal['params', 'funcargs']"],
 #rgnames: Sequence[str],
 #alset: Iterable[object],
 #d: str,
 #arks: Iterable[Union[Mark, MarkDecorator]],
 #copenum: int,
 #aram_index: int,
 # -> None:
 #or arg, val in zip(argnames, valset):
 #elf._checkargnotcontained(arg)
 #altype_for_arg = valtypes[arg]
 #f valtype_for_arg == "params":
 #elf.params[arg] = val
 #lif valtype_for_arg == "funcargs":
 #elf.funcargs[arg] = val
 #lse:  # pragma: no cover
 #ssert False, f"Unhandled valtype for arg: {valtype_for_arg}"
 #elf.indices[arg] = param_index
 #elf._arg2scopenum[arg] = scopenum
 #elf._idlist.append(id)
 #elf.marks.extend(normalize_mark_list(marks))


@final
class Metafunc:
 #""Objects passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.

 #hey help to inspect a test function and to generate tests according to
 #est configuration or values specified in the class or module where a
 #est function is defined.
 #""

 #ef __init__(
 #elf,
 #efinition: "FunctionDefinition",
 #ixtureinfo: fixtures.FuncFixtureInfo,
 #onfig: Config,
 #ls=None,
 #odule=None,
 # -> None:
        #: Access to the underlying :class:`_pytest.python.FunctionDefinition`.
 #elf.definition = definition

        #: Access to the :class:`_pytest.config.Config` object for the test session.
 #elf.config = config

        #: The module object where the test function is defined in.
 #elf.module = module

        #: Underlying Python test function.
 #elf.function = definition.obj

        #: Set of fixture names required by the test function.
 #elf.fixturenames = fixtureinfo.names_closure

        #: Class object where the test function is defined in or ``None``.
 #elf.cls = cls

 #elf._calls: List[CallSpec2] = []
 #elf._arg2fixturedefs = fixtureinfo.name2fixturedefs

 #ef parametrize(
 #elf,
 #rgnames: Union[str, List[str], Tuple[str, ...]],
 #rgvalues: Iterable[Union[ParameterSet, Sequence[object], object]],
 #ndirect: Union[bool, Sequence[str]] = False,
 #ds: Optional[
 #nion[
 #terable[Union[None, str, float, int, bool]],
 #allable[[Any], Optional[object]],
 #
 # = None,
 #cope: "Optional[_Scope]" = None,
 #,
 #param_mark: Optional[Mark] = None,
 # -> None:
 #""Add new invocations to the underlying test function using the list
 #f argvalues for the given argnames.  Parametrization is performed
 #uring the collection phase.  If you need to setup expensive resources
 #ee about setting indirect to do it rather at test setup time.

 #param argnames:
 # comma-separated string denoting one or more argument names, or
 # list/tuple of argument strings.

 #param argvalues:
 #he list of argvalues determines how often a test is invoked with
 #ifferent argument values.

 #f only one argname was specified argvalues is a list of values.
 #f N argnames were specified, argvalues must be a list of
 #-tuples, where each tuple-element specifies a value for its
 #espective argname.

 #param indirect:
 # list of arguments' names (subset of argnames) or a boolean.
 #f True the list contains all names from the argnames. Each
 #rgvalue corresponding to an argname in this list will
 #e passed as request.param to its respective argname fixture
 #unction so that it can perform more expensive setups during the
 #etup phase of a test rather than at collection time.

 #param ids:
 #equence of (or generator for) ids for ``argvalues``,
 #r a callable to return part of the id for each argvalue.

 #ith sequences (and generators like ``itertools.count()``) the
 #eturned ids should be of type ``string``, ``int``, ``float``,
 #`bool``, or ``None``.
 #hey are mapped to the corresponding index in ``argvalues``.
 #`None`` means to use the auto-generated id.

 #f it is a callable it will be called for each entry in
 #`argvalues``, and the return value is used as part of the
 #uto-generated id for the whole set (where parts are joined with
 #ashes ("-")).
 #his is useful to provide more specific ids for certain items, e.g.
 #ates.  Returning ``None`` will use an auto-generated id.

 #f no ids are provided they will be generated automatically from
 #he argvalues.

 #param scope:
 #f specified it denotes the scope of the parameters.
 #he scope is used for grouping tests by parameter instances.
 #t will also override any fixture-function defined scope, allowing
 #o set a dynamic scope using test context or configuration.
 #""
 #rom _pytest.fixtures import scope2index

 #rgnames, parameters = ParameterSet._for_parametrize(
 #rgnames,
 #rgvalues,
 #elf.function,
 #elf.config,
 #odeid=self.definition.nodeid,
 #
 #el argvalues

 #f "request" in argnames:
 #ail(
 #'request' is a reserved name and cannot be used in @pytest.mark.parametrize",
 #ytrace=False,
 #

 #f scope is None:
 #cope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)

 #elf._validate_if_using_arg_names(argnames, indirect)

 #rg_values_types = self._resolve_arg_value_types(argnames, indirect)

        # Use any already (possibly) generated ids with parametrize Marks.
 #f _param_mark and _param_mark._param_ids_from:
 #enerated_ids = _param_mark._param_ids_from._param_ids_generated
 #f generated_ids is not None:
 #ds = generated_ids

 #ds = self._resolve_arg_ids(
 #rgnames, ids, parameters, nodeid=self.definition.nodeid
 #

        # Store used (possibly generated) ids with parametrize Marks.
 #f _param_mark and _param_mark._param_ids_from and generated_ids is None:
 #bject.__setattr__(_param_mark._param_ids_from, "_param_ids_generated", ids)

 #copenum = scope2index(
 #cope, descr=f"parametrize() call in {self.function.__name__}"
 #

        # Create the new calls: if we are parametrize() multiple times (by applying the decorator
        # more than once) then we accumulate those calls generating the cartesian product
        # of all calls.
 #ewcalls = []
 #or callspec in self._calls or [CallSpec2(self)]:
 #or param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):
 #ewcallspec = callspec.copy()
 #ewcallspec.setmulti2(
 #rg_values_types,
 #rgnames,
 #aram_set.values,
 #aram_id,
 #aram_set.marks,
 #copenum,
 #aram_index,
 #
 #ewcalls.append(newcallspec)
 #elf._calls = newcalls

 #ef _resolve_arg_ids(
 #elf,
 #rgnames: Sequence[str],
 #ds: Optional[
 #nion[
 #terable[Union[None, str, float, int, bool]],
 #allable[[Any], Optional[object]],
 #
 #,
 #arameters: Sequence[ParameterSet],
 #odeid: str,
 # -> List[str]:
 #""Resolve the actual ids for the given argnames, based on the ``ids`` parameter given
 #o ``parametrize``.

 #param List[str] argnames: List of argument names passed to ``parametrize()``.
 #param ids: The ids parameter of the parametrized call (see docs).
 #param List[ParameterSet] parameters: The list of parameter values, same size as ``argnames``.
 #param str str: The nodeid of the item that generated this parametrized call.
 #rtype: List[str]
 #returns: The list of ids for each argname given.
 #""
 #f ids is None:
 #dfn = None
 #ds_ = None
 #lif callable(ids):
 #dfn = ids
 #ds_ = None
 #lse:
 #dfn = None
 #ds_ = self._validate_ids(ids, parameters, self.function.__name__)
 #eturn idmaker(argnames, parameters, idfn, ids_, self.config, nodeid=nodeid)

 #ef _validate_ids(
 #elf,
 #ds: Iterable[Union[None, str, float, int, bool]],
 #arameters: Sequence[ParameterSet],
 #unc_name: str,
 # -> List[Union[None, str]]:
 #ry:
 #um_ids = len(ids)  # type: ignore[arg-type]
 #xcept TypeError:
 #ry:
 #ter(ids)
 #xcept TypeError as e:
 #aise TypeError("ids must be a callable or an iterable") from e
 #um_ids = len(parameters)

        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849
 #f num_ids != len(parameters) and num_ids != 0:
 #sg = "In {}: {} parameter sets specified, with different number of ids: {}"
 #ail(msg.format(func_name, len(parameters), num_ids), pytrace=False)

 #ew_ids = []
 #or idx, id_value in enumerate(itertools.islice(ids, num_ids)):
 #f id_value is None or isinstance(id_value, str):
 #ew_ids.append(id_value)
 #lif isinstance(id_value, (float, int, bool)):
 #ew_ids.append(str(id_value))
 #lse:
 #sg = (  # type: ignore[unreachable]
 #In {}: ids must be list of string/float/int/bool, "
 #found: {} (type: {!r}) at index {}"
 #
 #ail(
 #sg.format(func_name, saferepr(id_value), type(id_value), idx),
 #ytrace=False,
 #
 #eturn new_ids

 #ef _resolve_arg_value_types(
 #elf, argnames: Sequence[str], indirect: Union[bool, Sequence[str]],
 # -> Dict[str, "Literal['params', 'funcargs']"]:
 #""Resolve if each parametrized argument must be considered a
 #arameter to a fixture or a "funcarg" to the function, based on the
 #`indirect`` parameter of the parametrized() call.

 #param List[str] argnames: List of argument names passed to ``parametrize()``.
 #param indirect: Same as the ``indirect`` parameter of ``parametrize()``.
 #rtype: Dict[str, str]
 # dict mapping each arg name to either:
 # "params" if the argname should be the parameter of a fixture of the same name.
 # "funcargs" if the argname should be a parameter to the parametrized test function.
 #""
 #f isinstance(indirect, bool):
 #altypes: Dict[str, Literal["params", "funcargs"]] = dict.fromkeys(
 #rgnames, "params" if indirect else "funcargs"
 #
 #lif isinstance(indirect, Sequence):
 #altypes = dict.fromkeys(argnames, "funcargs")
 #or arg in indirect:
 #f arg not in argnames:
 #ail(
 #In {}: indirect fixture '{}' doesn't exist".format(
 #elf.function.__name__, arg
 #,
 #ytrace=False,
 #
 #altypes[arg] = "params"
 #lse:
 #ail(
 #In {func}: expected Sequence or boolean for indirect, got {type}".format(
 #ype=type(indirect).__name__, func=self.function.__name__
 #,
 #ytrace=False,
 #
 #eturn valtypes

 #ef _validate_if_using_arg_names(
 #elf, argnames: Sequence[str], indirect: Union[bool, Sequence[str]],
 # -> None:
 #""Check if all argnames are being used, by default values, or directly/indirectly.

 #param List[str] argnames: List of argument names passed to ``parametrize()``.
 #param indirect: Same as the ``indirect`` parameter of ``parametrize()``.
 #raises ValueError: If validation fails.
 #""
 #efault_arg_names = set(get_default_arg_names(self.function))
 #unc_name = self.function.__name__
 #or arg in argnames:
 #f arg not in self.fixturenames:
 #f arg in default_arg_names:
 #ail(
 #In {}: function already takes an argument '{}' with a default value".format(
 #unc_name, arg
 #,
 #ytrace=False,
 #
 #lse:
 #f isinstance(indirect, Sequence):
 #ame = "fixture" if arg in indirect else "argument"
 #lse:
 #ame = "fixture" if indirect else "argument"
 #ail(
 #"In {func_name}: function uses no {name} '{arg}'",
 #ytrace=False,
 #


def _find_parametrized_scope(
 #rgnames: Sequence[str],
 #rg2fixturedefs: Mapping[str, Sequence[fixtures.FixtureDef[object]]],
 #ndirect: Union[bool, Sequence[str]],
) -> "fixtures._Scope":
 #""Find the most appropriate scope for a parametrized call based on its arguments.

 #hen there's at least one direct argument, always use "function" scope.

 #hen a test function is parametrized and all its arguments are indirect
 #e.g. fixtures), return the most narrow scope based on the fixtures used.

 #elated to issue #1832, based on code posted by @Kingdread.
 #""
 #f isinstance(indirect, Sequence):
 #ll_arguments_are_fixtures = len(indirect) == len(argnames)
 #lse:
 #ll_arguments_are_fixtures = bool(indirect)

 #f all_arguments_are_fixtures:
 #ixturedefs = arg2fixturedefs or {}
 #sed_scopes = [
 #ixturedef[0].scope
 #or name, fixturedef in fixturedefs.items()
 #f name in argnames
 #
 #f used_scopes:
            # Takes the most narrow scope from used fixtures.
 #or scope in reversed(fixtures.scopes):
 #f scope in used_scopes:
 #eturn scope

 #eturn "function"


def _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:
 #f config is None:
 #scape_option = False
 #lse:
 #scape_option = config.getini(
 #disable_test_id_escaping_and_forfeit_all_rights_to_community_support"
 #
    # TODO: If escaping is turned off and the user passes bytes,
    #       will return a bytes. For now we ignore this but the
    #       code *probably* doesn't handle this case.
 #eturn val if escape_option else ascii_escaped(val)  # type: ignore


def _idval(
 #al: object,
 #rgname: str,
 #dx: int,
 #dfn: Optional[Callable[[Any], Optional[object]]],
 #odeid: Optional[str],
 #onfig: Optional[Config],
) -> str:
 #f idfn:
 #ry:
 #enerated_id = idfn(val)
 #f generated_id is not None:
 #al = generated_id
 #xcept Exception as e:
 #refix = f"{nodeid}: " if nodeid is not None else ""
 #sg = "error raised while trying to determine id of parameter '{}' at position {}"
 #sg = prefix + msg.format(argname, idx)
 #aise ValueError(msg) from e
 #lif config:
 #ook_id: Optional[str] = config.hook.pytest_make_parametrize_id(
 #onfig=config, val=val, argname=argname
 #
 #f hook_id:
 #eturn hook_id

 #f isinstance(val, STRING_TYPES):
 #eturn _ascii_escaped_by_config(val, config)
 #lif val is None or isinstance(val, (float, int, bool)):
 #eturn str(val)
 #lif isinstance(val, REGEX_TYPE):
 #eturn ascii_escaped(val.pattern)
 #lif val is NOTSET:
        # Fallback to default. Note that NOTSET is an enum.Enum.
 #ass
 #lif isinstance(val, enum.Enum):
 #eturn str(val)
 #lif isinstance(getattr(val, "__name__", None), str):
        # Name of a class, function, module, etc.
 #ame: str = getattr(val, "__name__")
 #eturn name
 #eturn str(argname) + str(idx)


def _idvalset(
 #dx: int,
 #arameterset: ParameterSet,
 #rgnames: Iterable[str],
 #dfn: Optional[Callable[[Any], Optional[object]]],
 #ds: Optional[List[Union[None, str]]],
 #odeid: Optional[str],
 #onfig: Optional[Config],
) -> str:
 #f parameterset.id is not None:
 #eturn parameterset.id
 #d = None if ids is None or idx >= len(ids) else ids[idx]
 #f id is None:
 #his_id = [
 #idval(val, argname, idx, idfn, nodeid=nodeid, config=config)
 #or val, argname in zip(parameterset.values, argnames)
 #
 #eturn "-".join(this_id)
 #lse:
 #eturn _ascii_escaped_by_config(id, config)


def idmaker(
 #rgnames: Iterable[str],
 #arametersets: Iterable[ParameterSet],
 #dfn: Optional[Callable[[Any], Optional[object]]] = None,
 #ds: Optional[List[Union[None, str]]] = None,
 #onfig: Optional[Config] = None,
 #odeid: Optional[str] = None,
) -> List[str]:
 #esolved_ids = [
 #idvalset(
 #alindex, parameterset, argnames, idfn, ids, config=config, nodeid=nodeid
 #
 #or valindex, parameterset in enumerate(parametersets)
 #

    # All IDs must be unique!
 #nique_ids = set(resolved_ids)
 #f len(unique_ids) != len(resolved_ids):

        # Record the number of occurrences of each test ID.
 #est_id_counts = Counter(resolved_ids)

        # Map the test ID to its next suffix.
 #est_id_suffixes: Dict[str, int] = defaultdict(int)

        # Suffix non-unique IDs to make them unique.
 #or index, test_id in enumerate(resolved_ids):
 #f test_id_counts[test_id] > 1:
 #esolved_ids[index] = "{}{}".format(test_id, test_id_suffixes[test_id])
 #est_id_suffixes[test_id] += 1

 #eturn resolved_ids


def show_fixtures_per_test(config):
 #rom _pytest.main import wrap_session

 #eturn wrap_session(config, _show_fixtures_per_test)


def _show_fixtures_per_test(config: Config, session: Session) -> None:
 #mport _pytest.config

 #ession.perform_collect()
 #urdir = py.path.local()
 #w = _pytest.config.create_terminal_writer(config)
 #erbose = config.getvalue("verbose")

 #ef get_best_relpath(func):
 #oc = getlocation(func, str(curdir))
 #eturn curdir.bestrelpath(py.path.local(loc))

 #ef write_fixture(fixture_def: fixtures.FixtureDef[object]) -> None:
 #rgname = fixture_def.argname
 #f verbose <= 0 and argname.startswith("_"):
 #eturn
 #f verbose > 0:
 #estrel = get_best_relpath(fixture_def.func)
 #uncargspec = f"{argname} -- {bestrel}"
 #lse:
 #uncargspec = argname
 #w.line(funcargspec, green=True)
 #ixture_doc = inspect.getdoc(fixture_def.func)
 #f fixture_doc:
 #rite_docstring(tw, fixture_doc)
 #lse:
 #w.line("    no docstring available", red=True)

 #ef write_item(item: nodes.Item) -> None:
        # Not all items have _fixtureinfo attribute.
 #nfo: Optional[FuncFixtureInfo] = getattr(item, "_fixtureinfo", None)
 #f info is None or not info.name2fixturedefs:
            # This test item does not use any fixtures.
 #eturn
 #w.line()
 #w.sep("-", f"fixtures used by {item.name}")
        # TODO: Fix this type ignore.
 #w.sep("-", "({})".format(get_best_relpath(item.function)))  # type: ignore[attr-defined]
        # dict key not used in loop but needed for sorting.
 #or _, fixturedefs in sorted(info.name2fixturedefs.items()):
 #ssert fixturedefs is not None
 #f not fixturedefs:
 #ontinue
            # Last item is expected to be the one used by the test item.
 #rite_fixture(fixturedefs[-1])

 #or session_item in session.items:
 #rite_item(session_item)


def showfixtures(config: Config) -> Union[int, ExitCode]:
 #rom _pytest.main import wrap_session

 #eturn wrap_session(config, _showfixtures_main)


def _showfixtures_main(config: Config, session: Session) -> None:
 #mport _pytest.config

 #ession.perform_collect()
 #urdir = py.path.local()
 #w = _pytest.config.create_terminal_writer(config)
 #erbose = config.getvalue("verbose")

 #m = session._fixturemanager

 #vailable = []
 #een: Set[Tuple[str, str]] = set()

 #or argname, fixturedefs in fm._arg2fixturedefs.items():
 #ssert fixturedefs is not None
 #f not fixturedefs:
 #ontinue
 #or fixturedef in fixturedefs:
 #oc = getlocation(fixturedef.func, str(curdir))
 #f (fixturedef.argname, loc) in seen:
 #ontinue
 #een.add((fixturedef.argname, loc))
 #vailable.append(
 #
 #en(fixturedef.baseid),
 #ixturedef.func.__module__,
 #urdir.bestrelpath(py.path.local(loc)),
 #ixturedef.argname,
 #ixturedef,
 #
 #

 #vailable.sort()
 #urrentmodule = None
 #or baseid, module, bestrel, argname, fixturedef in available:
 #f currentmodule != module:
 #f not module.startswith("_pytest."):
 #w.line()
 #w.sep("-", f"fixtures defined from {module}")
 #urrentmodule = module
 #f verbose <= 0 and argname[0] == "_":
 #ontinue
 #w.write(argname, green=True)
 #f fixturedef.scope != "function":
 #w.write(" [%s scope]" % fixturedef.scope, cyan=True)
 #f verbose > 0:
 #w.write(" -- %s" % bestrel, yellow=True)
 #w.write("\n")
 #oc = getlocation(fixturedef.func, str(curdir))
 #oc = inspect.getdoc(fixturedef.func)
 #f doc:
 #rite_docstring(tw, doc)
 #lse:
 #w.line(f"    {loc}: no docstring available", red=True)
 #w.line()


def write_docstring(tw: TerminalWriter, doc: str, indent: str = "    ") -> None:
 #or line in doc.split("\n"):
 #w.line(indent + line)


class Function(PyobjMixin, nodes.Item):
 #""An Item responsible for setting up and executing a Python test function.

 #aram name:
 #he full function name, including any decorations like those
 #dded by parametrization (``my_func[my_param]``).
 #aram parent:
 #he parent Node.
 #aram config:
 #he pytest Config object.
 #aram callspec:
 #f given, this is function has been parametrized and the callspec contains
 #eta information about the parametrization.
 #aram callobj:
 #f given, the object which will be called when the Function is invoked,
 #therwise the callobj will be obtained from ``parent`` using ``originalname``.
 #aram keywords:
 #eywords bound to the function object for "-k" matching.
 #aram session:
 #he pytest Session object.
 #aram fixtureinfo:
 #ixture information already resolved at this fixture node..
 #aram originalname:
 #he attribute name to use for accessing the underlying function object.
 #efaults to ``name``. Set this if name is different from the original name,
 #or example when it contains decorations like those added by parametrization
 #``my_func[my_param]``).
 #""

    # Disable since functions handle it themselves.
 #ALLOW_MARKERS = False

 #ef __init__(
 #elf,
 #ame: str,
 #arent,
 #onfig: Optional[Config] = None,
 #allspec: Optional[CallSpec2] = None,
 #allobj=NOTSET,
 #eywords=None,
 #ession: Optional[Session] = None,
 #ixtureinfo: Optional[FuncFixtureInfo] = None,
 #riginalname: Optional[str] = None,
 # -> None:
 #uper().__init__(name, parent, config=config, session=session)

 #f callobj is not NOTSET:
 #elf.obj = callobj

        #: Original function name, without any decorations (for example
        #: parametrization adds a ``"[...]"`` suffix to function names), used to access
        #: the underlying function object from ``parent`` (in case ``callobj`` is not given
        #: explicitly).
        #:
        #: .. versionadded:: 3.0
 #elf.originalname = originalname or name

        # Note: when FunctionDefinition is introduced, we should change ``originalname``
        # to a readonly property that returns FunctionDefinition.name.

 #elf.keywords.update(self.obj.__dict__)
 #elf.own_markers.extend(get_unpacked_marks(self.obj))
 #f callspec:
 #elf.callspec = callspec
            # this is total hostile and a mess
            # keywords are broken by design by now
            # this will be redeemed later
 #or mark in callspec.marks:
                # feel free to cry, this was broken for years before
                # and keywords cant fix it per design
 #elf.keywords[mark.name] = mark
 #elf.own_markers.extend(normalize_mark_list(callspec.marks))
 #f keywords:
 #elf.keywords.update(keywords)

        # todo: this is a hell of a hack
        # https://github.com/pytest-dev/pytest/issues/4569

 #elf.keywords.update(
 #
 #ark.name: True
 #or mark in self.iter_markers()
 #f mark.name not in self.keywords
 #
 #

 #f fixtureinfo is None:
 #ixtureinfo = self.session._fixturemanager.getfixtureinfo(
 #elf, self.obj, self.cls, funcargs=True
 #
 #elf._fixtureinfo: FuncFixtureInfo = fixtureinfo
 #elf.fixturenames = fixtureinfo.names_closure
 #elf._initrequest()

 #classmethod
 #ef from_parent(cls, parent, **kw):  # todo: determine sound type limitations
 #""The public constructor."""
 #eturn super().from_parent(parent=parent, **kw)

 #ef _initrequest(self) -> None:
 #elf.funcargs: Dict[str, object] = {}
 #elf._request = fixtures.FixtureRequest(self, _ispytest=True)

 #property
 #ef function(self):
 #""Underlying python 'function' object."""
 #eturn getimfunc(self.obj)

 #ef _getobj(self):
 #ssert self.parent is not None
 #eturn getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]

 #property
 #ef _pyfuncitem(self):
 #""(compatonly) for code expecting pytest-2.2 style request objects."""
 #eturn self

 #ef runtest(self) -> None:
 #""Execute the underlying test function."""
 #elf.ihook.pytest_pyfunc_call(pyfuncitem=self)

 #ef setup(self) -> None:
 #f isinstance(self.parent, Instance):
 #elf.parent.newinstance()
 #elf.obj = self._getobj()
 #elf._request._fillfixtures()

 #ef _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:
 #f hasattr(self, "_obj") and not self.config.getoption("fulltrace", False):
 #ode = _pytest._code.Code.from_function(get_real_func(self.obj))
 #ath, firstlineno = code.path, code.firstlineno
 #raceback = excinfo.traceback
 #traceback = traceback.cut(path=path, firstlineno=firstlineno)
 #f ntraceback == traceback:
 #traceback = ntraceback.cut(path=path)
 #f ntraceback == traceback:
 #traceback = ntraceback.filter(filter_traceback)
 #f not ntraceback:
 #traceback = traceback

 #xcinfo.traceback = ntraceback.filter()
            # issue364: mark all but first and last frames to
            # only show a single-line message for each frame.
 #f self.config.getoption("tbstyle", "auto") == "auto":
 #f len(excinfo.traceback) > 2:
 #or entry in excinfo.traceback[1:-1]:
 #ntry.set_repr_style("short")

    # TODO: Type ignored -- breaks Liskov Substitution.
 #ef repr_failure(  # type: ignore[override]
 #elf, excinfo: ExceptionInfo[BaseException],
 # -> Union[str, TerminalRepr]:
 #tyle = self.config.getoption("tbstyle", "auto")
 #f style == "auto":
 #tyle = "long"
 #eturn self._repr_failure_py(excinfo, style=style)


class FunctionDefinition(Function):
 #""
 #his class is a step gap solution until we evolve to have actual function definition nodes
 #nd manage to get rid of ``metafunc``.
 #""

 #ef runtest(self) -> None:
 #aise RuntimeError("function definitions are not supposed to be run as tests")

 #etup = runtest
