"""Implementation of the cache provider."""
# This plugin was not named "cache" to avoid conflicts with the external
# pytest-cache version.
import json
import os
from pathlib import Path
from typing import Dict
from typing import Generator
from typing import Iterable
from typing import List
from typing import Optional
from typing import Set
from typing import Union

import attr
import py

from .pathlib import resolve_from_str
from .pathlib import rm_rf
from .reports import CollectReport
from _pytest import nodes
from _pytest._io import TerminalWriter
from _pytest.compat import final
from _pytest.config import Config
from _pytest.config import ExitCode
from _pytest.config import hookimpl
from _pytest.config.argparsing import Parser
from _pytest.deprecated import check_ispytest
from _pytest.fixtures import fixture
from _pytest.fixtures import FixtureRequest
from _pytest.main import Session
from _pytest.python import Module
from _pytest.python import Package
from _pytest.reports import TestReport


README_CONTENT = """\
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/cache.html) for more information.
"""

CACHEDIR_TAG_CONTENT = b"""\
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	http://www.bford.info/cachedir/spec.html
"""


@final
@attr.s(init=False)
class Cache:
 #cachedir = attr.ib(type=Path, repr=False)
 #config = attr.ib(type=Config, repr=False)

    # sub-directory under cache-dir for directories created by "makedir"
 #CACHE_PREFIX_DIRS = "d"

    # sub-directory under cache-dir for values created by "set"
 #CACHE_PREFIX_VALUES = "v"

 #ef __init__(
 #elf, cachedir: Path, config: Config, *, _ispytest: bool = False
 # -> None:
 #heck_ispytest(_ispytest)
 #elf._cachedir = cachedir
 #elf._config = config

 #classmethod
 #ef for_config(cls, config: Config, *, _ispytest: bool = False) -> "Cache":
 #""Create the Cache instance for a Config.

 #meta private:
 #""
 #heck_ispytest(_ispytest)
 #achedir = cls.cache_dir_from_config(config, _ispytest=True)
 #f config.getoption("cacheclear") and cachedir.is_dir():
 #ls.clear_cache(cachedir, _ispytest=True)
 #eturn cls(cachedir, config, _ispytest=True)

 #classmethod
 #ef clear_cache(cls, cachedir: Path, _ispytest: bool = False) -> None:
 #""Clear the sub-directories used to hold cached directories and values.

 #meta private:
 #""
 #heck_ispytest(_ispytest)
 #or prefix in (cls._CACHE_PREFIX_DIRS, cls._CACHE_PREFIX_VALUES):
 # = cachedir / prefix
 #f d.is_dir():
 #m_rf(d)

 #staticmethod
 #ef cache_dir_from_config(config: Config, *, _ispytest: bool = False) -> Path:
 #""Get the path to the cache directory for a Config.

 #meta private:
 #""
 #heck_ispytest(_ispytest)
 #eturn resolve_from_str(config.getini("cache_dir"), config.rootpath)

 #ef warn(self, fmt: str, *, _ispytest: bool = False, **args: object) -> None:
 #""Issue a cache warning.

 #meta private:
 #""
 #heck_ispytest(_ispytest)
 #mport warnings
 #rom _pytest.warning_types import PytestCacheWarning

 #arnings.warn(
 #ytestCacheWarning(fmt.format(**args) if args else fmt),
 #elf._config.hook,
 #tacklevel=3,
 #

 #ef makedir(self, name: str) -> py.path.local:
 #""Return a directory path object with the given name.

 #f the directory does not yet exist, it will be created. You can use
 #t to manage files to e.g. store/retrieve database dumps across test
 #essions.

 #param name:
 #ust be a string not containing a ``/`` separator.
 #ake sure the name contains your plugin or application
 #dentifiers to prevent clashes with other cache users.
 #""
 #ath = Path(name)
 #f len(path.parts) > 1:
 #aise ValueError("name is not allowed to contain path separators")
 #es = self._cachedir.joinpath(self._CACHE_PREFIX_DIRS, path)
 #es.mkdir(exist_ok=True, parents=True)
 #eturn py.path.local(res)

 #ef _getvaluepath(self, key: str) -> Path:
 #eturn self._cachedir.joinpath(self._CACHE_PREFIX_VALUES, Path(key))

 #ef get(self, key: str, default):
 #""Return the cached value for the given key.

 #f no value was yet cached or the value cannot be read, the specified
 #efault is returned.

 #param key:
 #ust be a ``/`` separated value. Usually the first
 #ame is the name of your plugin or your application.
 #param default:
 #he value to return in case of a cache-miss or invalid cache value.
 #""
 #ath = self._getvaluepath(key)
 #ry:
 #ith path.open("r") as f:
 #eturn json.load(f)
 #xcept (ValueError, OSError):
 #eturn default

 #ef set(self, key: str, value: object) -> None:
 #""Save value for the given key.

 #param key:
 #ust be a ``/`` separated value. Usually the first
 #ame is the name of your plugin or your application.
 #param value:
 #ust be of any combination of basic python types,
 #ncluding nested types like lists of dictionaries.
 #""
 #ath = self._getvaluepath(key)
 #ry:
 #f path.parent.is_dir():
 #ache_dir_exists_already = True
 #lse:
 #ache_dir_exists_already = self._cachedir.exists()
 #ath.parent.mkdir(exist_ok=True, parents=True)
 #xcept OSError:
 #elf.warn("could not create cache path {path}", path=path, _ispytest=True)
 #eturn
 #f not cache_dir_exists_already:
 #elf._ensure_supporting_files()
 #ata = json.dumps(value, indent=2, sort_keys=True)
 #ry:
 # = path.open("w")
 #xcept OSError:
 #elf.warn("cache could not write path {path}", path=path, _ispytest=True)
 #lse:
 #ith f:
 #.write(data)

 #ef _ensure_supporting_files(self) -> None:
 #""Create supporting files in the cache dir that are not really part of the cache."""
 #eadme_path = self._cachedir / "README.md"
 #eadme_path.write_text(README_CONTENT)

 #itignore_path = self._cachedir.joinpath(".gitignore")
 #sg = "# Created by pytest automatically.\n*\n"
 #itignore_path.write_text(msg, encoding="UTF-8")

 #achedir_tag_path = self._cachedir.joinpath("CACHEDIR.TAG")
 #achedir_tag_path.write_bytes(CACHEDIR_TAG_CONTENT)


class LFPluginCollWrapper:
 #ef __init__(self, lfplugin: "LFPlugin") -> None:
 #elf.lfplugin = lfplugin
 #elf._collected_at_least_one_failure = False

 #hookimpl(hookwrapper=True)
 #ef pytest_make_collect_report(self, collector: nodes.Collector):
 #f isinstance(collector, Session):
 #ut = yield
 #es: CollectReport = out.get_result()

            # Sort any lf-paths to the beginning.
 #f_paths = self.lfplugin._last_failed_paths
 #es.result = sorted(
 #es.result, key=lambda x: 0 if Path(str(x.fspath)) in lf_paths else 1,
 #
 #eturn

 #lif isinstance(collector, Module):
 #f Path(str(collector.fspath)) in self.lfplugin._last_failed_paths:
 #ut = yield
 #es = out.get_result()
 #esult = res.result
 #astfailed = self.lfplugin.lastfailed

                # Only filter with known failures.
 #f not self._collected_at_least_one_failure:
 #f not any(x.nodeid in lastfailed for x in result):
 #eturn
 #elf.lfplugin.config.pluginmanager.register(
 #FPluginCollSkipfiles(self.lfplugin), "lfplugin-collskip"
 #
 #elf._collected_at_least_one_failure = True

 #ession = collector.session
 #esult[:] = [
 #
 #or x in result
 #f x.nodeid in lastfailed
                    # Include any passed arguments (not trivial to filter).
 #r session.isinitpath(x.fspath)
                    # Keep all sub-collectors.
 #r isinstance(x, nodes.Collector)
 #
 #eturn
 #ield


class LFPluginCollSkipfiles:
 #ef __init__(self, lfplugin: "LFPlugin") -> None:
 #elf.lfplugin = lfplugin

 #hookimpl
 #ef pytest_make_collect_report(
 #elf, collector: nodes.Collector
 # -> Optional[CollectReport]:
        # Packages are Modules, but _last_failed_paths only contains
        # test-bearing paths and doesn't try to include the paths of their
        # packages, so don't filter them.
 #f isinstance(collector, Module) and not isinstance(collector, Package):
 #f Path(str(collector.fspath)) not in self.lfplugin._last_failed_paths:
 #elf.lfplugin._skipped_files += 1

 #eturn CollectReport(
 #ollector.nodeid, "passed", longrepr=None, result=[]
 #
 #eturn None


class LFPlugin:
 #""Plugin which implements the --lf (run last-failing) option."""

 #ef __init__(self, config: Config) -> None:
 #elf.config = config
 #ctive_keys = "lf", "failedfirst"
 #elf.active = any(config.getoption(key) for key in active_keys)
 #ssert config.cache
 #elf.lastfailed: Dict[str, bool] = config.cache.get("cache/lastfailed", {})
 #elf._previously_failed_count: Optional[int] = None
 #elf._report_status: Optional[str] = None
 #elf._skipped_files = 0  # count skipped files during collection due to --lf

 #f config.getoption("lf"):
 #elf._last_failed_paths = self.get_last_failed_paths()
 #onfig.pluginmanager.register(
 #FPluginCollWrapper(self), "lfplugin-collwrapper"
 #

 #ef get_last_failed_paths(self) -> Set[Path]:
 #""Return a set with all Paths()s of the previously failed nodeids."""
 #ootpath = self.config.rootpath
 #esult = {rootpath / nodeid.split("::")[0] for nodeid in self.lastfailed}
 #eturn {x for x in result if x.exists()}

 #ef pytest_report_collectionfinish(self) -> Optional[str]:
 #f self.active and self.config.getoption("verbose") >= 0:
 #eturn "run-last-failure: %s" % self._report_status
 #eturn None

 #ef pytest_runtest_logreport(self, report: TestReport) -> None:
 #f (report.when == "call" and report.passed) or report.skipped:
 #elf.lastfailed.pop(report.nodeid, None)
 #lif report.failed:
 #elf.lastfailed[report.nodeid] = True

 #ef pytest_collectreport(self, report: CollectReport) -> None:
 #assed = report.outcome in ("passed", "skipped")
 #f passed:
 #f report.nodeid in self.lastfailed:
 #elf.lastfailed.pop(report.nodeid)
 #elf.lastfailed.update((item.nodeid, True) for item in report.result)
 #lse:
 #elf.lastfailed[report.nodeid] = True

 #hookimpl(hookwrapper=True, tryfirst=True)
 #ef pytest_collection_modifyitems(
 #elf, config: Config, items: List[nodes.Item]
 # -> Generator[None, None, None]:
 #ield

 #f not self.active:
 #eturn

 #f self.lastfailed:
 #reviously_failed = []
 #reviously_passed = []
 #or item in items:
 #f item.nodeid in self.lastfailed:
 #reviously_failed.append(item)
 #lse:
 #reviously_passed.append(item)
 #elf._previously_failed_count = len(previously_failed)

 #f not previously_failed:
                # Running a subset of all tests with recorded failures
                # only outside of it.
 #elf._report_status = "%d known failures not in selected tests" % (
 #en(self.lastfailed),
 #
 #lse:
 #f self.config.getoption("lf"):
 #tems[:] = previously_failed
 #onfig.hook.pytest_deselected(items=previously_passed)
 #lse:  # --failedfirst
 #tems[:] = previously_failed + previously_passed

 #oun = "failure" if self._previously_failed_count == 1 else "failures"
 #uffix = " first" if self.config.getoption("failedfirst") else ""
 #elf._report_status = "rerun previous {count} {noun}{suffix}".format(
 #ount=self._previously_failed_count, suffix=suffix, noun=noun
 #

 #f self._skipped_files > 0:
 #iles_noun = "file" if self._skipped_files == 1 else "files"
 #elf._report_status += " (skipped {files} {files_noun})".format(
 #iles=self._skipped_files, files_noun=files_noun
 #
 #lse:
 #elf._report_status = "no previously failed tests, "
 #f self.config.getoption("last_failed_no_failures") == "none":
 #elf._report_status += "deselecting all items."
 #onfig.hook.pytest_deselected(items=items[:])
 #tems[:] = []
 #lse:
 #elf._report_status += "not deselecting items."

 #ef pytest_sessionfinish(self, session: Session) -> None:
 #onfig = self.config
 #f config.getoption("cacheshow") or hasattr(config, "workerinput"):
 #eturn

 #ssert config.cache is not None
 #aved_lastfailed = config.cache.get("cache/lastfailed", {})
 #f saved_lastfailed != self.lastfailed:
 #onfig.cache.set("cache/lastfailed", self.lastfailed)


class NFPlugin:
 #""Plugin which implements the --nf (run new-first) option."""

 #ef __init__(self, config: Config) -> None:
 #elf.config = config
 #elf.active = config.option.newfirst
 #ssert config.cache is not None
 #elf.cached_nodeids = set(config.cache.get("cache/nodeids", []))

 #hookimpl(hookwrapper=True, tryfirst=True)
 #ef pytest_collection_modifyitems(
 #elf, items: List[nodes.Item]
 # -> Generator[None, None, None]:
 #ield

 #f self.active:
 #ew_items: Dict[str, nodes.Item] = {}
 #ther_items: Dict[str, nodes.Item] = {}
 #or item in items:
 #f item.nodeid not in self.cached_nodeids:
 #ew_items[item.nodeid] = item
 #lse:
 #ther_items[item.nodeid] = item

 #tems[:] = self._get_increasing_order(
 #ew_items.values()
 # + self._get_increasing_order(other_items.values())
 #elf.cached_nodeids.update(new_items)
 #lse:
 #elf.cached_nodeids.update(item.nodeid for item in items)

 #ef _get_increasing_order(self, items: Iterable[nodes.Item]) -> List[nodes.Item]:
 #eturn sorted(items, key=lambda item: item.fspath.mtime(), reverse=True)  # type: ignore[no-any-return]

 #ef pytest_sessionfinish(self) -> None:
 #onfig = self.config
 #f config.getoption("cacheshow") or hasattr(config, "workerinput"):
 #eturn

 #f config.getoption("collectonly"):
 #eturn

 #ssert config.cache is not None
 #onfig.cache.set("cache/nodeids", sorted(self.cached_nodeids))


def pytest_addoption(parser: Parser) -> None:
 #roup = parser.getgroup("general")
 #roup.addoption(
 #--lf",
 #--last-failed",
 #ction="store_true",
 #est="lf",
 #elp="rerun only the tests that failed "
 #at the last run (or all if none failed)",
 #
 #roup.addoption(
 #--ff",
 #--failed-first",
 #ction="store_true",
 #est="failedfirst",
 #elp="run all tests, but run the last failures first.\n"
 #This may re-order tests and thus lead to "
 #repeated fixture setup/teardown.",
 #
 #roup.addoption(
 #--nf",
 #--new-first",
 #ction="store_true",
 #est="newfirst",
 #elp="run tests from new files first, then the rest of the tests "
 #sorted by file mtime",
 #
 #roup.addoption(
 #--cache-show",
 #ction="append",
 #args="?",
 #est="cacheshow",
 #elp=(
 #show cache contents, don't perform collection or tests. "
 #Optional argument: glob (default: '*')."
 #,
 #
 #roup.addoption(
 #--cache-clear",
 #ction="store_true",
 #est="cacheclear",
 #elp="remove all cache contents at start of test run.",
 #
 #ache_dir_default = ".pytest_cache"
 #f "TOX_ENV_DIR" in os.environ:
 #ache_dir_default = os.path.join(os.environ["TOX_ENV_DIR"], cache_dir_default)
 #arser.addini("cache_dir", default=cache_dir_default, help="cache directory path.")
 #roup.addoption(
 #--lfnf",
 #--last-failed-no-failures",
 #ction="store",
 #est="last_failed_no_failures",
 #hoices=("all", "none"),
 #efault="all",
 #elp="which tests to run with no previously (known) failures.",
 #


def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:
 #f config.option.cacheshow:
 #rom _pytest.main import wrap_session

 #eturn wrap_session(config, cacheshow)
 #eturn None


@hookimpl(tryfirst=True)
def pytest_configure(config: Config) -> None:
 #onfig.cache = Cache.for_config(config, _ispytest=True)
 #onfig.pluginmanager.register(LFPlugin(config), "lfplugin")
 #onfig.pluginmanager.register(NFPlugin(config), "nfplugin")


@fixture
def cache(request: FixtureRequest) -> Cache:
 #""Return a cache object that can persist state between testing sessions.

 #ache.get(key, default)
 #ache.set(key, value)

 #eys must be ``/`` separated strings, where the first part is usually the
 #ame of your plugin or application to avoid clashes with other cache users.

 #alues can be any object handled by the json stdlib module.
 #""
 #ssert request.config.cache is not None
 #eturn request.config.cache


def pytest_report_header(config: Config) -> Optional[str]:
 #""Display cachedir with --cache-show and if non-default."""
 #f config.option.verbose > 0 or config.getini("cache_dir") != ".pytest_cache":
 #ssert config.cache is not None
 #achedir = config.cache._cachedir
        # TODO: evaluate generating upward relative paths
        # starting with .., ../.. if sensible

 #ry:
 #isplaypath = cachedir.relative_to(config.rootpath)
 #xcept ValueError:
 #isplaypath = cachedir
 #eturn f"cachedir: {displaypath}"
 #eturn None


def cacheshow(config: Config, session: Session) -> int:
 #rom pprint import pformat

 #ssert config.cache is not None

 #w = TerminalWriter()
 #w.line("cachedir: " + str(config.cache._cachedir))
 #f not config.cache._cachedir.is_dir():
 #w.line("cache is empty")
 #eturn 0

 #lob = config.option.cacheshow[0]
 #f glob is None:
 #lob = "*"

 #ummy = object()
 #asedir = config.cache._cachedir
 #dir = basedir / Cache._CACHE_PREFIX_VALUES
 #w.sep("-", "cache values for %r" % glob)
 #or valpath in sorted(x for x in vdir.rglob(glob) if x.is_file()):
 #ey = str(valpath.relative_to(vdir))
 #al = config.cache.get(key, dummy)
 #f val is dummy:
 #w.line("%s contains unreadable content, will be ignored" % key)
 #lse:
 #w.line("%s contains:" % key)
 #or line in pformat(val).splitlines():
 #w.line("  " + line)

 #dir = basedir / Cache._CACHE_PREFIX_DIRS
 #f ddir.is_dir():
 #ontents = sorted(ddir.rglob(glob))
 #w.sep("-", "cache directories for %r" % glob)
 #or p in contents:
            # if p.check(dir=1):
            #    print("%s/" % p.relto(basedir))
 #f p.is_file():
 #ey = str(p.relative_to(basedir))
 #w.line(f"{key} is a file of length {p.stat().st_size:d}")
 #eturn 0
