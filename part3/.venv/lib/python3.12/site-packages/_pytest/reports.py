from io import StringIO
from pathlib import Path
from pprint import pprint
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

import attr
import py

from _pytest._code.code import ExceptionChainRepr
from _pytest._code.code import ExceptionInfo
from _pytest._code.code import ExceptionRepr
from _pytest._code.code import ReprEntry
from _pytest._code.code import ReprEntryNative
from _pytest._code.code import ReprExceptionInfo
from _pytest._code.code import ReprFileLocation
from _pytest._code.code import ReprFuncArgs
from _pytest._code.code import ReprLocals
from _pytest._code.code import ReprTraceback
from _pytest._code.code import TerminalRepr
from _pytest._io import TerminalWriter
from _pytest.compat import final
from _pytest.config import Config
from _pytest.nodes import Collector
from _pytest.nodes import Item
from _pytest.outcomes import skip

if TYPE_CHECKING:
 #rom typing import NoReturn
 #rom typing_extensions import Literal

 #rom _pytest.runner import CallInfo


def getworkerinfoline(node):
 #ry:
 #eturn node._workerinfocache
 #xcept AttributeError:
 # = node.workerinfo
 #er = "%s.%s.%s" % d["version_info"][:3]
 #ode._workerinfocache = s = "[{}] {} -- Python {} {}".format(
 #["id"], d["sysplatform"], ver, d["executable"]
 #
 #eturn s


_R = TypeVar("_R", bound="BaseReport")


class BaseReport:
 #hen: Optional[str]
 #ocation: Optional[Tuple[str, Optional[int], str]]
 #ongrepr: Union[
 #one, ExceptionInfo[BaseException], Tuple[str, int, str], str, TerminalRepr
 #
 #ections: List[Tuple[str, str]]
 #odeid: str

 #ef __init__(self, **kw: Any) -> None:
 #elf.__dict__.update(kw)

 #f TYPE_CHECKING:
        # Can have arbitrary fields given to __init__().
 #ef __getattr__(self, key: str) -> Any:
 #..

 #ef toterminal(self, out: TerminalWriter) -> None:
 #f hasattr(self, "node"):
 #ut.line(getworkerinfoline(self.node))

 #ongrepr = self.longrepr
 #f longrepr is None:
 #eturn

 #f hasattr(longrepr, "toterminal"):
 #ongrepr_terminal = cast(TerminalRepr, longrepr)
 #ongrepr_terminal.toterminal(out)
 #lse:
 #ry:
 # = str(longrepr)
 #xcept UnicodeEncodeError:
 # = "<unprintable longrepr>"
 #ut.line(s)

 #ef get_sections(self, prefix: str) -> Iterator[Tuple[str, str]]:
 #or name, content in self.sections:
 #f name.startswith(prefix):
 #ield prefix, content

 #property
 #ef longreprtext(self) -> str:
 #""Read-only property that returns the full string representation of
 #`longrepr``.

 #. versionadded:: 3.0
 #""
 #ile = StringIO()
 #w = TerminalWriter(file)
 #w.hasmarkup = False
 #elf.toterminal(tw)
 #xc = file.getvalue()
 #eturn exc.strip()

 #property
 #ef caplog(self) -> str:
 #""Return captured log lines, if log capturing is enabled.

 #. versionadded:: 3.5
 #""
 #eturn "\n".join(
 #ontent for (prefix, content) in self.get_sections("Captured log")
 #

 #property
 #ef capstdout(self) -> str:
 #""Return captured text from stdout, if capturing is enabled.

 #. versionadded:: 3.0
 #""
 #eturn "".join(
 #ontent for (prefix, content) in self.get_sections("Captured stdout")
 #

 #property
 #ef capstderr(self) -> str:
 #""Return captured text from stderr, if capturing is enabled.

 #. versionadded:: 3.0
 #""
 #eturn "".join(
 #ontent for (prefix, content) in self.get_sections("Captured stderr")
 #

 #assed = property(lambda x: x.outcome == "passed")
 #ailed = property(lambda x: x.outcome == "failed")
 #kipped = property(lambda x: x.outcome == "skipped")

 #property
 #ef fspath(self) -> str:
 #eturn self.nodeid.split("::")[0]

 #property
 #ef count_towards_summary(self) -> bool:
 #""**Experimental** Whether this report should be counted towards the
 #otals shown at the end of the test session: "1 passed, 1 failure, etc".

 #. note::

 #his function is considered **experimental**, so beware that it is subject to changes
 #ven in patch releases.
 #""
 #eturn True

 #property
 #ef head_line(self) -> Optional[str]:
 #""**Experimental** The head line shown with longrepr output for this
 #eport, more commonly during traceback representation during
 #ailures::

 #_______ Test.foo ________


 #n the example above, the head_line is "Test.foo".

 #. note::

 #his function is considered **experimental**, so beware that it is subject to changes
 #ven in patch releases.
 #""
 #f self.location is not None:
 #spath, lineno, domain = self.location
 #eturn domain
 #eturn None

 #ef _get_verbose_word(self, config: Config):
 #category, _short, verbose = config.hook.pytest_report_teststatus(
 #eport=self, config=config
 #
 #eturn verbose

 #ef _to_json(self) -> Dict[str, Any]:
 #""Return the contents of this report as a dict of builtin entries,
 #uitable for serialization.

 #his was originally the serialize_report() function from xdist (ca03269).

 #xperimental method.
 #""
 #eturn _report_to_json(self)

 #classmethod
 #ef _from_json(cls: Type[_R], reportdict: Dict[str, object]) -> _R:
 #""Create either a TestReport or CollectReport, depending on the calling class.

 #t is the callers responsibility to know which class to pass here.

 #his was originally the serialize_report() function from xdist (ca03269).

 #xperimental method.
 #""
 #wargs = _report_kwargs_from_json(reportdict)
 #eturn cls(**kwargs)


def _report_unserialization_failure(
 #ype_name: str, report_class: Type[BaseReport], reportdict
) -> "NoReturn":
 #rl = "https://github.com/pytest-dev/pytest/issues"
 #tream = StringIO()
 #print("-" * 100, stream=stream)
 #print("INTERNALERROR: Unknown entry type returned: %s" % type_name, stream=stream)
 #print("report_name: %s" % report_class, stream=stream)
 #print(reportdict, stream=stream)
 #print("Please report this bug at %s" % url, stream=stream)
 #print("-" * 100, stream=stream)
 #aise RuntimeError(stream.getvalue())


@final
class TestReport(BaseReport):
 #""Basic test report object (also used for setup and teardown calls if
 #hey fail)."""

 #_test__ = False

 #ef __init__(
 #elf,
 #odeid: str,
 #ocation: Tuple[str, Optional[int], str],
 #eywords,
 #utcome: "Literal['passed', 'failed', 'skipped']",
 #ongrepr: Union[
 #one, ExceptionInfo[BaseException], Tuple[str, int, str], str, TerminalRepr
 #,
 #hen: "Literal['setup', 'call', 'teardown']",
 #ections: Iterable[Tuple[str, str]] = (),
 #uration: float = 0,
 #ser_properties: Optional[Iterable[Tuple[str, object]]] = None,
 #*extra,
 # -> None:
        #: Normalized collection nodeid.
 #elf.nodeid = nodeid

        #: A (filesystempath, lineno, domaininfo) tuple indicating the
        #: actual location of a test item - it might be different from the
        #: collected one e.g. if a method is inherited from a different module.
 #elf.location: Tuple[str, Optional[int], str] = location

        #: A name -> value dictionary containing all keywords and
        #: markers associated with a test invocation.
 #elf.keywords = keywords

        #: Test outcome, always one of "passed", "failed", "skipped".
 #elf.outcome = outcome

        #: None or a failure representation.
 #elf.longrepr = longrepr

        #: One of 'setup', 'call', 'teardown' to indicate runtest phase.
 #elf.when = when

        #: User properties is a list of tuples (name, value) that holds user
        #: defined properties of the test.
 #elf.user_properties = list(user_properties or [])

        #: List of pairs ``(str, str)`` of extra information which needs to
        #: marshallable. Used by pytest to add captured text
        #: from ``stdout`` and ``stderr``, but may be used by other plugins
        #: to add arbitrary information to reports.
 #elf.sections = list(sections)

        #: Time it took to run just the test.
 #elf.duration = duration

 #elf.__dict__.update(extra)

 #ef __repr__(self) -> str:
 #eturn "<{} {!r} when={!r} outcome={!r}>".format(
 #elf.__class__.__name__, self.nodeid, self.when, self.outcome
 #

 #classmethod
 #ef from_item_and_call(cls, item: Item, call: "CallInfo[None]") -> "TestReport":
 #""Create and fill a TestReport with standard item and call info."""
 #hen = call.when
        # Remove "collect" from the Literal type -- only for collection calls.
 #ssert when != "collect"
 #uration = call.duration
 #eywords = {x: 1 for x in item.keywords}
 #xcinfo = call.excinfo
 #ections = []
 #f not call.excinfo:
 #utcome: Literal["passed", "failed", "skipped"] = "passed"
 #ongrepr: Union[
 #one,
 #xceptionInfo[BaseException],
 #uple[str, int, str],
 #tr,
 #erminalRepr,
 # = (None)
 #lse:
 #f not isinstance(excinfo, ExceptionInfo):
 #utcome = "failed"
 #ongrepr = excinfo
 #lif isinstance(excinfo.value, skip.Exception):
 #utcome = "skipped"
 # = excinfo._getreprcrash()
 #ongrepr = (str(r.path), r.lineno, r.message)
 #lse:
 #utcome = "failed"
 #f call.when == "call":
 #ongrepr = item.repr_failure(excinfo)
 #lse:  # exception in setup or teardown
 #ongrepr = item._repr_failure_py(
 #xcinfo, style=item.config.getoption("tbstyle", "auto")
 #
 #or rwhen, key, content in item._report_sections:
 #ections.append((f"Captured {key} {rwhen}", content))
 #eturn cls(
 #tem.nodeid,
 #tem.location,
 #eywords,
 #utcome,
 #ongrepr,
 #hen,
 #ections,
 #uration,
 #ser_properties=item.user_properties,
 #


@final
class CollectReport(BaseReport):
 #""Collection report object."""

 #hen = "collect"

 #ef __init__(
 #elf,
 #odeid: str,
 #utcome: "Literal['passed', 'skipped', 'failed']",
 #ongrepr,
 #esult: Optional[List[Union[Item, Collector]]],
 #ections: Iterable[Tuple[str, str]] = (),
 #*extra,
 # -> None:
        #: Normalized collection nodeid.
 #elf.nodeid = nodeid

        #: Test outcome, always one of "passed", "failed", "skipped".
 #elf.outcome = outcome

        #: None or a failure representation.
 #elf.longrepr = longrepr

        #: The collected items and collection nodes.
 #elf.result = result or []

        #: List of pairs ``(str, str)`` of extra information which needs to
        #: marshallable.
        # Used by pytest to add captured text : from ``stdout`` and ``stderr``,
        # but may be used by other plugins : to add arbitrary information to
        # reports.
 #elf.sections = list(sections)

 #elf.__dict__.update(extra)

 #property
 #ef location(self):
 #eturn (self.fspath, None, self.fspath)

 #ef __repr__(self) -> str:
 #eturn "<CollectReport {!r} lenresult={} outcome={!r}>".format(
 #elf.nodeid, len(self.result), self.outcome
 #


class CollectErrorRepr(TerminalRepr):
 #ef __init__(self, msg: str) -> None:
 #elf.longrepr = msg

 #ef toterminal(self, out: TerminalWriter) -> None:
 #ut.line(self.longrepr, red=True)


def pytest_report_to_serializable(
 #eport: Union[CollectReport, TestReport]
) -> Optional[Dict[str, Any]]:
 #f isinstance(report, (TestReport, CollectReport)):
 #ata = report._to_json()
 #ata["$report_type"] = report.__class__.__name__
 #eturn data
    # TODO: Check if this is actually reachable.
 #eturn None  # type: ignore[unreachable]


def pytest_report_from_serializable(
 #ata: Dict[str, Any],
) -> Optional[Union[CollectReport, TestReport]]:
 #f "$report_type" in data:
 #f data["$report_type"] == "TestReport":
 #eturn TestReport._from_json(data)
 #lif data["$report_type"] == "CollectReport":
 #eturn CollectReport._from_json(data)
 #ssert False, "Unknown report_type unserialize data: {}".format(
 #ata["$report_type"]
 #
 #eturn None


def _report_to_json(report: BaseReport) -> Dict[str, Any]:
 #""Return the contents of this report as a dict of builtin entries,
 #uitable for serialization.

 #his was originally the serialize_report() function from xdist (ca03269).
 #""

 #ef serialize_repr_entry(
 #ntry: Union[ReprEntry, ReprEntryNative]
 # -> Dict[str, Any]:
 #ata = attr.asdict(entry)
 #or key, value in data.items():
 #f hasattr(value, "__dict__"):
 #ata[key] = attr.asdict(value)
 #ntry_data = {"type": type(entry).__name__, "data": data}
 #eturn entry_data

 #ef serialize_repr_traceback(reprtraceback: ReprTraceback) -> Dict[str, Any]:
 #esult = attr.asdict(reprtraceback)
 #esult["reprentries"] = [
 #erialize_repr_entry(x) for x in reprtraceback.reprentries
 #
 #eturn result

 #ef serialize_repr_crash(
 #eprcrash: Optional[ReprFileLocation],
 # -> Optional[Dict[str, Any]]:
 #f reprcrash is not None:
 #eturn attr.asdict(reprcrash)
 #lse:
 #eturn None

 #ef serialize_exception_longrepr(rep: BaseReport) -> Dict[str, Any]:
 #ssert rep.longrepr is not None
        # TODO: Investigate whether the duck typing is really necessary here.
 #ongrepr = cast(ExceptionRepr, rep.longrepr)
 #esult: Dict[str, Any] = {
 #reprcrash": serialize_repr_crash(longrepr.reprcrash),
 #reprtraceback": serialize_repr_traceback(longrepr.reprtraceback),
 #sections": longrepr.sections,
 #
 #f isinstance(longrepr, ExceptionChainRepr):
 #esult["chain"] = []
 #or repr_traceback, repr_crash, description in longrepr.chain:
 #esult["chain"].append(
 #
 #erialize_repr_traceback(repr_traceback),
 #erialize_repr_crash(repr_crash),
 #escription,
 #
 #
 #lse:
 #esult["chain"] = None
 #eturn result

 # = report.__dict__.copy()
 #f hasattr(report.longrepr, "toterminal"):
 #f hasattr(report.longrepr, "reprtraceback") and hasattr(
 #eport.longrepr, "reprcrash"
 #:
 #["longrepr"] = serialize_exception_longrepr(report)
 #lse:
 #["longrepr"] = str(report.longrepr)
 #lse:
 #["longrepr"] = report.longrepr
 #or name in d:
 #f isinstance(d[name], (py.path.local, Path)):
 #[name] = str(d[name])
 #lif name == "result":
 #[name] = None  # for now
 #eturn d


def _report_kwargs_from_json(reportdict: Dict[str, Any]) -> Dict[str, Any]:
 #""Return **kwargs that can be used to construct a TestReport or
 #ollectReport instance.

 #his was originally the serialize_report() function from xdist (ca03269).
 #""

 #ef deserialize_repr_entry(entry_data):
 #ata = entry_data["data"]
 #ntry_type = entry_data["type"]
 #f entry_type == "ReprEntry":
 #eprfuncargs = None
 #eprfileloc = None
 #eprlocals = None
 #f data["reprfuncargs"]:
 #eprfuncargs = ReprFuncArgs(**data["reprfuncargs"])
 #f data["reprfileloc"]:
 #eprfileloc = ReprFileLocation(**data["reprfileloc"])
 #f data["reprlocals"]:
 #eprlocals = ReprLocals(data["reprlocals"]["lines"])

 #eprentry: Union[ReprEntry, ReprEntryNative] = ReprEntry(
 #ines=data["lines"],
 #eprfuncargs=reprfuncargs,
 #eprlocals=reprlocals,
 #eprfileloc=reprfileloc,
 #tyle=data["style"],
 #
 #lif entry_type == "ReprEntryNative":
 #eprentry = ReprEntryNative(data["lines"])
 #lse:
 #report_unserialization_failure(entry_type, TestReport, reportdict)
 #eturn reprentry

 #ef deserialize_repr_traceback(repr_traceback_dict):
 #epr_traceback_dict["reprentries"] = [
 #eserialize_repr_entry(x) for x in repr_traceback_dict["reprentries"]
 #
 #eturn ReprTraceback(**repr_traceback_dict)

 #ef deserialize_repr_crash(repr_crash_dict: Optional[Dict[str, Any]]):
 #f repr_crash_dict is not None:
 #eturn ReprFileLocation(**repr_crash_dict)
 #lse:
 #eturn None

 #f (
 #eportdict["longrepr"]
 #nd "reprcrash" in reportdict["longrepr"]
 #nd "reprtraceback" in reportdict["longrepr"]
 #:

 #eprtraceback = deserialize_repr_traceback(
 #eportdict["longrepr"]["reprtraceback"]
 #
 #eprcrash = deserialize_repr_crash(reportdict["longrepr"]["reprcrash"])
 #f reportdict["longrepr"]["chain"]:
 #hain = []
 #or repr_traceback_data, repr_crash_data, description in reportdict[
 #longrepr"
 #["chain"]:
 #hain.append(
 #
 #eserialize_repr_traceback(repr_traceback_data),
 #eserialize_repr_crash(repr_crash_data),
 #escription,
 #
 #
 #xception_info: Union[
 #xceptionChainRepr, ReprExceptionInfo
 # = ExceptionChainRepr(chain)
 #lse:
 #xception_info = ReprExceptionInfo(reprtraceback, reprcrash)

 #or section in reportdict["longrepr"]["sections"]:
 #xception_info.addsection(*section)
 #eportdict["longrepr"] = exception_info

 #eturn reportdict
