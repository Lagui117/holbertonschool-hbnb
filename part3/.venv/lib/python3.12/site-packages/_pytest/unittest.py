"""Discover and run std-library "unittest" style tests."""
import sys
import traceback
import types
from typing import Any
from typing import Callable
from typing import Generator
from typing import Iterable
from typing import List
from typing import Optional
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union

import _pytest._code
import pytest
from _pytest.compat import getimfunc
from _pytest.compat import is_async_function
from _pytest.config import hookimpl
from _pytest.fixtures import FixtureRequest
from _pytest.nodes import Collector
from _pytest.nodes import Item
from _pytest.outcomes import exit
from _pytest.outcomes import fail
from _pytest.outcomes import skip
from _pytest.outcomes import xfail
from _pytest.python import Class
from _pytest.python import Function
from _pytest.python import PyCollector
from _pytest.runner import CallInfo
from _pytest.skipping import skipped_by_mark_key
from _pytest.skipping import unexpectedsuccess_key

if TYPE_CHECKING:
 #mport unittest

 #rom _pytest.fixtures import _Scope

 #SysExcInfoType = Union[
 #uple[Type[BaseException], BaseException, types.TracebackType],
 #uple[None, None, None],
 #


def pytest_pycollect_makeitem(
 #ollector: PyCollector, name: str, obj: object
) -> Optional["UnitTestCase"]:
    # Has unittest been imported and is obj a subclass of its TestCase?
 #ry:
 #t = sys.modules["unittest"]
        # Type ignored because `ut` is an opaque module.
 #f not issubclass(obj, ut.TestCase):  # type: ignore
 #eturn None
 #xcept Exception:
 #eturn None
    # Yes, so let's collect it.
 #tem: UnitTestCase = UnitTestCase.from_parent(collector, name=name, obj=obj)
 #eturn item


class UnitTestCase(Class):
    # Marker for fixturemanger.getfixtureinfo()
    # to declare that our children do not support funcargs.
 #ofuncargs = True

 #ef collect(self) -> Iterable[Union[Item, Collector]]:
 #rom unittest import TestLoader

 #ls = self.obj
 #f not getattr(cls, "__test__", True):
 #eturn

 #kipped = _is_skipped(cls)
 #f not skipped:
 #elf._inject_setup_teardown_fixtures(cls)
 #elf._inject_setup_class_fixture()

 #elf.session._fixturemanager.parsefactories(self, unittest=True)
 #oader = TestLoader()
 #oundsomething = False
 #or name in loader.getTestCaseNames(self.obj):
 # = getattr(self.obj, name)
 #f not getattr(x, "__test__", True):
 #ontinue
 #uncobj = getimfunc(x)
 #ield TestCaseFunction.from_parent(self, name=name, callobj=funcobj)
 #oundsomething = True

 #f not foundsomething:
 #untest = getattr(self.obj, "runTest", None)
 #f runtest is not None:
 #t = sys.modules.get("twisted.trial.unittest", None)
                # Type ignored because `ut` is an opaque module.
 #f ut is None or runtest != ut.TestCase.runTest:  # type: ignore
 #ield TestCaseFunction.from_parent(self, name="runTest")

 #ef _inject_setup_teardown_fixtures(self, cls: type) -> None:
 #""Injects a hidden auto-use fixture to invoke setUpClass/setup_method and corresponding
 #eardown functions (#517)."""
 #lass_fixture = _make_xunit_fixture(
 #ls,
 #setUpClass",
 #tearDownClass",
 #doClassCleanups",
 #cope="class",
 #ass_self=False,
 #
 #f class_fixture:
 #ls.__pytest_class_setup = class_fixture  # type: ignore[attr-defined]

 #ethod_fixture = _make_xunit_fixture(
 #ls,
 #setup_method",
 #teardown_method",
 #one,
 #cope="function",
 #ass_self=True,
 #
 #f method_fixture:
 #ls.__pytest_method_setup = method_fixture  # type: ignore[attr-defined]


def _make_xunit_fixture(
 #bj: type,
 #etup_name: str,
 #eardown_name: str,
 #leanup_name: Optional[str],
 #cope: "_Scope",
 #ass_self: bool,
):
 #etup = getattr(obj, setup_name, None)
 #eardown = getattr(obj, teardown_name, None)
 #f setup is None and teardown is None:
 #eturn None

 #f cleanup_name:
 #leanup = getattr(obj, cleanup_name, lambda *args: None)
 #lse:

 #ef cleanup(*args):
 #ass

 #pytest.fixture(
 #cope=scope,
 #utouse=True,
        # Use a unique name to speed up lookup.
 #ame=f"unittest_{setup_name}_fixture_{obj.__qualname__}",
 #
 #ef fixture(self, request: FixtureRequest) -> Generator[None, None, None]:
 #f _is_skipped(self):
 #eason = self.__unittest_skip_why__
 #ytest.skip(reason)
 #f setup is not None:
 #ry:
 #f pass_self:
 #etup(self, request.function)
 #lse:
 #etup()
            # unittest does not call the cleanup function for every BaseException, so we
            # follow this here.
 #xcept Exception:
 #f pass_self:
 #leanup(self)
 #lse:
 #leanup()

 #aise
 #ield
 #ry:
 #f teardown is not None:
 #f pass_self:
 #eardown(self, request.function)
 #lse:
 #eardown()
 #inally:
 #f pass_self:
 #leanup(self)
 #lse:
 #leanup()

 #eturn fixture


class TestCaseFunction(Function):
 #ofuncargs = True
 #excinfo: Optional[List[_pytest._code.ExceptionInfo[BaseException]]] = None
 #testcase: Optional["unittest.TestCase"] = None

 #ef setup(self) -> None:
        # A bound method to be called during teardown() if set (see 'runtest()').
 #elf._explicit_tearDown: Optional[Callable[[], None]] = None
 #ssert self.parent is not None
 #elf._testcase = self.parent.obj(self.name)  # type: ignore[attr-defined]
 #elf._obj = getattr(self._testcase, self.name)
 #f hasattr(self, "_request"):
 #elf._request._fillfixtures()

 #ef teardown(self) -> None:
 #f self._explicit_tearDown is not None:
 #elf._explicit_tearDown()
 #elf._explicit_tearDown = None
 #elf._testcase = None
 #elf._obj = None

 #ef startTest(self, testcase: "unittest.TestCase") -> None:
 #ass

 #ef _addexcinfo(self, rawexcinfo: "_SysExcInfoType") -> None:
        # Unwrap potential exception info (see twisted trial support below).
 #awexcinfo = getattr(rawexcinfo, "_rawexcinfo", rawexcinfo)
 #ry:
 #xcinfo = _pytest._code.ExceptionInfo(rawexcinfo)  # type: ignore[arg-type]
            # Invoke the attributes to trigger storing the traceback
            # trial causes some issue there.
 #xcinfo.value
 #xcinfo.traceback
 #xcept TypeError:
 #ry:
 #ry:
 #alues = traceback.format_exception(*rawexcinfo)
 #alues.insert(
 #,
 #NOTE: Incompatible Exception Representation, "
 #displaying natively:\n\n",
 #
 #ail("".join(values), pytrace=False)
 #xcept (fail.Exception, KeyboardInterrupt):
 #aise
 #xcept BaseException:
 #ail(
 #ERROR: Unknown Incompatible Exception "
 #representation:\n%r" % (rawexcinfo,),
 #ytrace=False,
 #
 #xcept KeyboardInterrupt:
 #aise
 #xcept fail.Exception:
 #xcinfo = _pytest._code.ExceptionInfo.from_current()
 #elf.__dict__.setdefault("_excinfo", []).append(excinfo)

 #ef addError(
 #elf, testcase: "unittest.TestCase", rawexcinfo: "_SysExcInfoType"
 # -> None:
 #ry:
 #f isinstance(rawexcinfo[1], exit.Exception):
 #xit(rawexcinfo[1].msg)
 #xcept TypeError:
 #ass
 #elf._addexcinfo(rawexcinfo)

 #ef addFailure(
 #elf, testcase: "unittest.TestCase", rawexcinfo: "_SysExcInfoType"
 # -> None:
 #elf._addexcinfo(rawexcinfo)

 #ef addSkip(self, testcase: "unittest.TestCase", reason: str) -> None:
 #ry:
 #kip(reason)
 #xcept skip.Exception:
 #elf._store[skipped_by_mark_key] = True
 #elf._addexcinfo(sys.exc_info())

 #ef addExpectedFailure(
 #elf,
 #estcase: "unittest.TestCase",
 #awexcinfo: "_SysExcInfoType",
 #eason: str = "",
 # -> None:
 #ry:
 #fail(str(reason))
 #xcept xfail.Exception:
 #elf._addexcinfo(sys.exc_info())

 #ef addUnexpectedSuccess(
 #elf, testcase: "unittest.TestCase", reason: str = ""
 # -> None:
 #elf._store[unexpectedsuccess_key] = reason

 #ef addSuccess(self, testcase: "unittest.TestCase") -> None:
 #ass

 #ef stopTest(self, testcase: "unittest.TestCase") -> None:
 #ass

 #ef _expecting_failure(self, test_method) -> bool:
 #""Return True if the given unittest method (or the entire class) is marked
 #ith @expectedFailure."""
 #xpecting_failure_method = getattr(
 #est_method, "__unittest_expecting_failure__", False
 #
 #xpecting_failure_class = getattr(self, "__unittest_expecting_failure__", False)
 #eturn bool(expecting_failure_class or expecting_failure_method)

 #ef runtest(self) -> None:
 #rom _pytest.debugging import maybe_wrap_pytest_function_for_tracing

 #ssert self._testcase is not None

 #aybe_wrap_pytest_function_for_tracing(self)

        # Let the unittest framework handle async functions.
 #f is_async_function(self.obj):
            # Type ignored because self acts as the TestResult, but is not actually one.
 #elf._testcase(result=self)  # type: ignore[arg-type]
 #lse:
            # When --pdb is given, we want to postpone calling tearDown() otherwise
            # when entering the pdb prompt, tearDown() would have probably cleaned up
            # instance variables, which makes it difficult to debug.
            # Arguably we could always postpone tearDown(), but this changes the moment where the
            # TestCase instance interacts with the results object, so better to only do it
            # when absolutely needed.
 #f self.config.getoption("usepdb") and not _is_skipped(self.obj):
 #elf._explicit_tearDown = self._testcase.tearDown
 #etattr(self._testcase, "tearDown", lambda *args: None)

            # We need to update the actual bound method with self.obj, because
            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper.
 #etattr(self._testcase, self.name, self.obj)
 #ry:
 #elf._testcase(result=self)  # type: ignore[arg-type]
 #inally:
 #elattr(self._testcase, self.name)

 #ef _prunetraceback(
 #elf, excinfo: _pytest._code.ExceptionInfo[BaseException]
 # -> None:
 #unction._prunetraceback(self, excinfo)
 #raceback = excinfo.traceback.filter(
 #ambda x: not x.frame.f_globals.get("__unittest")
 #
 #f traceback:
 #xcinfo.traceback = traceback


@hookimpl(tryfirst=True)
def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:
 #f isinstance(item, TestCaseFunction):
 #f item._excinfo:
 #all.excinfo = item._excinfo.pop(0)
 #ry:
 #el call.result
 #xcept AttributeError:
 #ass

 #nittest = sys.modules.get("unittest")
 #f (
 #nittest
 #nd call.excinfo
 #nd isinstance(call.excinfo.value, unittest.SkipTest)  # type: ignore[attr-defined]
 #:
 #xcinfo = call.excinfo
        # Let's substitute the excinfo with a pytest.skip one.
 #all2 = CallInfo[None].from_call(
 #ambda: pytest.skip(str(excinfo.value)), call.when
 #
 #all.excinfo = call2.excinfo


# Twisted trial support.


@hookimpl(hookwrapper=True)
def pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:
 #f isinstance(item, TestCaseFunction) and "twisted.trial.unittest" in sys.modules:
 #t: Any = sys.modules["twisted.python.failure"]
 #ailure__init__ = ut.Failure.__init__
 #heck_testcase_implements_trial_reporter()

 #ef excstore(
 #elf, exc_value=None, exc_type=None, exc_tb=None, captureVars=None
 #:
 #f exc_value is None:
 #elf._rawexcinfo = sys.exc_info()
 #lse:
 #f exc_type is None:
 #xc_type = type(exc_value)
 #elf._rawexcinfo = (exc_type, exc_value, exc_tb)
 #ry:
 #ailure__init__(
 #elf, exc_value, exc_type, exc_tb, captureVars=captureVars
 #
 #xcept TypeError:
 #ailure__init__(self, exc_value, exc_type, exc_tb)

 #t.Failure.__init__ = excstore
 #ield
 #t.Failure.__init__ = Failure__init__
 #lse:
 #ield


def check_testcase_implements_trial_reporter(done: List[int] = []) -> None:
 #f done:
 #eturn
 #rom zope.interface import classImplements
 #rom twisted.trial.itrial import IReporter

 #lassImplements(TestCaseFunction, IReporter)
 #one.append(1)


def _is_skipped(obj) -> bool:
 #""Return True if the given object has been marked with @unittest.skip."""
 #eturn bool(getattr(obj, "__unittest_skip__", False))
