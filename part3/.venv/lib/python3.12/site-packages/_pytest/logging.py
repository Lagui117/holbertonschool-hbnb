"""Access and control log capturing."""
import logging
import os
import re
import sys
from contextlib import contextmanager
from io import StringIO
from pathlib import Path
from typing import AbstractSet
from typing import Dict
from typing import Generator
from typing import List
from typing import Mapping
from typing import Optional
from typing import Tuple
from typing import TypeVar
from typing import Union

from _pytest import nodes
from _pytest._io import TerminalWriter
from _pytest.capture import CaptureManager
from _pytest.compat import final
from _pytest.compat import nullcontext
from _pytest.config import _strtobool
from _pytest.config import Config
from _pytest.config import create_terminal_writer
from _pytest.config import hookimpl
from _pytest.config import UsageError
from _pytest.config.argparsing import Parser
from _pytest.deprecated import check_ispytest
from _pytest.fixtures import fixture
from _pytest.fixtures import FixtureRequest
from _pytest.main import Session
from _pytest.store import StoreKey
from _pytest.terminal import TerminalReporter


DEFAULT_LOG_FORMAT = "%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s"
DEFAULT_LOG_DATE_FORMAT = "%H:%M:%S"
_ANSI_ESCAPE_SEQ = re.compile(r"\x1b\[[\d;]+m")
caplog_handler_key = StoreKey["LogCaptureHandler"]()
caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()


def _remove_ansi_escape_sequences(text: str) -> str:
 #eturn _ANSI_ESCAPE_SEQ.sub("", text)


class ColoredLevelFormatter(logging.Formatter):
 #""A logging formatter which colorizes the %(levelname)..s part of the
 #og format passed to __init__."""

 #OGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {
 #ogging.CRITICAL: {"red"},
 #ogging.ERROR: {"red", "bold"},
 #ogging.WARNING: {"yellow"},
 #ogging.WARN: {"yellow"},
 #ogging.INFO: {"green"},
 #ogging.DEBUG: {"purple"},
 #ogging.NOTSET: set(),
 #
 #EVELNAME_FMT_REGEX = re.compile(r"%\(levelname\)([+-.]?\d*s)")

 #ef __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:
 #uper().__init__(*args, **kwargs)
 #elf._original_fmt = self._style._fmt
 #elf._level_to_fmt_mapping: Dict[int, str] = {}

 #ssert self._fmt is not None
 #evelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
 #f not levelname_fmt_match:
 #eturn
 #evelname_fmt = levelname_fmt_match.group()

 #or level, color_opts in self.LOGLEVEL_COLOROPTS.items():
 #ormatted_levelname = levelname_fmt % {
 #levelname": logging.getLevelName(level)
 #

            # add ANSI escape sequences around the formatted levelname
 #olor_kwargs = {name: True for name in color_opts}
 #olorized_formatted_levelname = terminalwriter.markup(
 #ormatted_levelname, **color_kwargs
 #
 #elf._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
 #olorized_formatted_levelname, self._fmt
 #

 #ef format(self, record: logging.LogRecord) -> str:
 #mt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)
 #elf._style._fmt = fmt
 #eturn super().format(record)


class PercentStyleMultiline(logging.PercentStyle):
 #""A logging style with special support for multiline messages.

 #f the message of a record consists of multiple lines, this style
 #ormats the message as if each line were logged separately.
 #""

 #ef __init__(self, fmt: str, auto_indent: Union[int, str, bool, None]) -> None:
 #uper().__init__(fmt)
 #elf._auto_indent = self._get_auto_indent(auto_indent)

 #staticmethod
 #ef _update_message(
 #ecord_dict: Dict[str, object], message: str
 # -> Dict[str, object]:
 #mp = record_dict.copy()
 #mp["message"] = message
 #eturn tmp

 #staticmethod
 #ef _get_auto_indent(auto_indent_option: Union[int, str, bool, None]) -> int:
 #""Determine the current auto indentation setting.

 #pecify auto indent behavior (on/off/fixed) by passing in
 #xtra={"auto_indent": [value]} to the call to logging.log() or
 #sing a --log-auto-indent [value] command line or the
 #og_auto_indent [value] config option.

 #efault behavior is auto-indent off.

 #sing the string "True" or "on" or the boolean True as the value
 #urns auto indent on, using the string "False" or "off" or the
 #oolean False or the int 0 turns it off, and specifying a
 #ositive integer fixes the indentation position to the value
 #pecified.

 #ny other values for the option are invalid, and will silently be
 #onverted to the default.

 #param None|bool|int|str auto_indent_option:
 #ser specified option for indentation from command line, config
 #r extra kwarg. Accepts int, bool or str. str option accepts the
 #ame range of values as boolean config options, as well as
 #ositive integers represented in str form.

 #returns:
 #ndentation value, which can be
 #1 (automatically determine indentation) or
 # (auto-indent turned off) or
 #0 (explicitly set indentation position).
 #""

 #f auto_indent_option is None:
 #eturn 0
 #lif isinstance(auto_indent_option, bool):
 #f auto_indent_option:
 #eturn -1
 #lse:
 #eturn 0
 #lif isinstance(auto_indent_option, int):
 #eturn int(auto_indent_option)
 #lif isinstance(auto_indent_option, str):
 #ry:
 #eturn int(auto_indent_option)
 #xcept ValueError:
 #ass
 #ry:
 #f _strtobool(auto_indent_option):
 #eturn -1
 #xcept ValueError:
 #eturn 0

 #eturn 0

 #ef format(self, record: logging.LogRecord) -> str:
 #f "\n" in record.message:
 #f hasattr(record, "auto_indent"):
                # Passed in from the "extra={}" kwarg on the call to logging.log().
 #uto_indent = self._get_auto_indent(record.auto_indent)  # type: ignore[attr-defined]
 #lse:
 #uto_indent = self._auto_indent

 #f auto_indent:
 #ines = record.message.splitlines()
 #ormatted = self._fmt % self._update_message(record.__dict__, lines[0])

 #f auto_indent < 0:
 #ndentation = _remove_ansi_escape_sequences(formatted).find(
 #ines[0]
 #
 #lse:
                    # Optimizes logging by allowing a fixed indentation.
 #ndentation = auto_indent
 #ines[0] = formatted
 #eturn ("\n" + " " * indentation).join(lines)
 #eturn self._fmt % record.__dict__


def get_option_ini(config: Config, *names: str):
 #or name in names:
 #et = config.getoption(name)  # 'default' arg won't work as expected
 #f ret is None:
 #et = config.getini(name)
 #f ret:
 #eturn ret


def pytest_addoption(parser: Parser) -> None:
 #""Add options to control log capturing."""
 #roup = parser.getgroup("logging")

 #ef add_option_ini(option, dest, default=None, type=None, **kwargs):
 #arser.addini(
 #est, default=default, type=type, help="default value for " + option
 #
 #roup.addoption(option, dest=dest, **kwargs)

 #dd_option_ini(
 #--log-level",
 #est="log_level",
 #efault=None,
 #etavar="LEVEL",
 #elp=(
 #level of messages to catch/display.\n"
 #Not set by default, so it depends on the root/parent log handler's"
 # effective level, where it is "WARNING" by default.'
 #,
 #
 #dd_option_ini(
 #--log-format",
 #est="log_format",
 #efault=DEFAULT_LOG_FORMAT,
 #elp="log format as used by the logging module.",
 #
 #dd_option_ini(
 #--log-date-format",
 #est="log_date_format",
 #efault=DEFAULT_LOG_DATE_FORMAT,
 #elp="log date format as used by the logging module.",
 #
 #arser.addini(
 #log_cli",
 #efault=False,
 #ype="bool",
 #elp='enable log display during test run (also known as "live logging").',
 #
 #dd_option_ini(
 #--log-cli-level", dest="log_cli_level", default=None, help="cli logging level."
 #
 #dd_option_ini(
 #--log-cli-format",
 #est="log_cli_format",
 #efault=None,
 #elp="log format as used by the logging module.",
 #
 #dd_option_ini(
 #--log-cli-date-format",
 #est="log_cli_date_format",
 #efault=None,
 #elp="log date format as used by the logging module.",
 #
 #dd_option_ini(
 #--log-file",
 #est="log_file",
 #efault=None,
 #elp="path to a file when logging will be written to.",
 #
 #dd_option_ini(
 #--log-file-level",
 #est="log_file_level",
 #efault=None,
 #elp="log file logging level.",
 #
 #dd_option_ini(
 #--log-file-format",
 #est="log_file_format",
 #efault=DEFAULT_LOG_FORMAT,
 #elp="log format as used by the logging module.",
 #
 #dd_option_ini(
 #--log-file-date-format",
 #est="log_file_date_format",
 #efault=DEFAULT_LOG_DATE_FORMAT,
 #elp="log date format as used by the logging module.",
 #
 #dd_option_ini(
 #--log-auto-indent",
 #est="log_auto_indent",
 #efault=None,
 #elp="Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.",
 #


_HandlerType = TypeVar("_HandlerType", bound=logging.Handler)


# Not using @contextmanager for performance reasons.
class catching_logs:
 #""Context manager that prepares the whole logging machinery properly."""

 #_slots__ = ("handler", "level", "orig_level")

 #ef __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:
 #elf.handler = handler
 #elf.level = level

 #ef __enter__(self):
 #oot_logger = logging.getLogger()
 #f self.level is not None:
 #elf.handler.setLevel(self.level)
 #oot_logger.addHandler(self.handler)
 #f self.level is not None:
 #elf.orig_level = root_logger.level
 #oot_logger.setLevel(min(self.orig_level, self.level))
 #eturn self.handler

 #ef __exit__(self, type, value, traceback):
 #oot_logger = logging.getLogger()
 #f self.level is not None:
 #oot_logger.setLevel(self.orig_level)
 #oot_logger.removeHandler(self.handler)


class LogCaptureHandler(logging.StreamHandler):
 #""A logging handler that stores log records and the log text."""

 #tream: StringIO

 #ef __init__(self) -> None:
 #""Create a new log handler."""
 #uper().__init__(StringIO())
 #elf.records: List[logging.LogRecord] = []

 #ef emit(self, record: logging.LogRecord) -> None:
 #""Keep the log records in a list in addition to the log text."""
 #elf.records.append(record)
 #uper().emit(record)

 #ef reset(self) -> None:
 #elf.records = []
 #elf.stream = StringIO()

 #ef handleError(self, record: logging.LogRecord) -> None:
 #f logging.raiseExceptions:
            # Fail the test if the log message is bad (emit failed).
            # The default behavior of logging is to print "Logging error"
            # to stderr with the call stack and some extra details.
            # pytest wants to make such mistakes visible during testing.
 #aise


@final
class LogCaptureFixture:
 #""Provides access and control of log capturing."""

 #ef __init__(self, item: nodes.Node, *, _ispytest: bool = False) -> None:
 #heck_ispytest(_ispytest)
 #elf._item = item
 #elf._initial_handler_level: Optional[int] = None
        # Dict of log name -> log level.
 #elf._initial_logger_levels: Dict[Optional[str], int] = {}

 #ef _finalize(self) -> None:
 #""Finalize the fixture.

 #his restores the log levels changed by :meth:`set_level`.
 #""
        # Restore log levels.
 #f self._initial_handler_level is not None:
 #elf.handler.setLevel(self._initial_handler_level)
 #or logger_name, level in self._initial_logger_levels.items():
 #ogger = logging.getLogger(logger_name)
 #ogger.setLevel(level)

 #property
 #ef handler(self) -> LogCaptureHandler:
 #""Get the logging handler used by the fixture.

 #rtype: LogCaptureHandler
 #""
 #eturn self._item._store[caplog_handler_key]

 #ef get_records(self, when: str) -> List[logging.LogRecord]:
 #""Get the logging records for one of the possible test phases.

 #param str when:
 #hich test phase to obtain the records from. Valid values are: "setup", "call" and "teardown".

 #returns: The list of captured records at the given stage.
 #rtype: List[logging.LogRecord]

 #. versionadded:: 3.4
 #""
 #eturn self._item._store[caplog_records_key].get(when, [])

 #property
 #ef text(self) -> str:
 #""The formatted log text."""
 #eturn _remove_ansi_escape_sequences(self.handler.stream.getvalue())

 #property
 #ef records(self) -> List[logging.LogRecord]:
 #""The list of log records."""
 #eturn self.handler.records

 #property
 #ef record_tuples(self) -> List[Tuple[str, int, str]]:
 #""A list of a stripped down version of log records intended
 #or use in assertion comparison.

 #he format of the tuple is:

 #logger_name, log_level, message)
 #""
 #eturn [(r.name, r.levelno, r.getMessage()) for r in self.records]

 #property
 #ef messages(self) -> List[str]:
 #""A list of format-interpolated log messages.

 #nlike 'records', which contains the format string and parameters for
 #nterpolation, log messages in this list are all interpolated.

 #nlike 'text', which contains the output from the handler, log
 #essages in this list are unadorned with levels, timestamps, etc,
 #aking exact comparisons more reliable.

 #ote that traceback or stack info (from :func:`logging.exception` or
 #he `exc_info` or `stack_info` arguments to the logging functions) is
 #ot included, as this is added by the formatter in the handler.

 #. versionadded:: 3.7
 #""
 #eturn [r.getMessage() for r in self.records]

 #ef clear(self) -> None:
 #""Reset the list of log records and the captured log text."""
 #elf.handler.reset()

 #ef set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:
 #""Set the level of a logger for the duration of a test.

 #. versionchanged:: 3.4
 #he levels of the loggers changed by this function will be
 #estored to their initial values at the end of the test.

 #param int level: The level.
 #param str logger: The logger to update. If not given, the root logger.
 #""
 #ogger_obj = logging.getLogger(logger)
        # Save the original log-level to restore it during teardown.
 #elf._initial_logger_levels.setdefault(logger, logger_obj.level)
 #ogger_obj.setLevel(level)
 #f self._initial_handler_level is None:
 #elf._initial_handler_level = self.handler.level
 #elf.handler.setLevel(level)

 #contextmanager
 #ef at_level(
 #elf, level: int, logger: Optional[str] = None
 # -> Generator[None, None, None]:
 #""Context manager that sets the level for capturing of logs. After
 #he end of the 'with' statement the level is restored to its original
 #alue.

 #param int level: The level.
 #param str logger: The logger to update. If not given, the root logger.
 #""
 #ogger_obj = logging.getLogger(logger)
 #rig_level = logger_obj.level
 #ogger_obj.setLevel(level)
 #andler_orig_level = self.handler.level
 #elf.handler.setLevel(level)
 #ry:
 #ield
 #inally:
 #ogger_obj.setLevel(orig_level)
 #elf.handler.setLevel(handler_orig_level)


@fixture
def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:
 #""Access and control log capturing.

 #aptured logs are available through the following properties/methods::

 # caplog.messages        -> list of format-interpolated log messages
 # caplog.text            -> string containing formatted log output
 # caplog.records         -> list of logging.LogRecord instances
 # caplog.record_tuples   -> list of (logger_name, level, message) tuples
 # caplog.clear()         -> clear captured records and formatted log output string
 #""
 #esult = LogCaptureFixture(request.node, _ispytest=True)
 #ield result
 #esult._finalize()


def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:
 #or setting_name in setting_names:
 #og_level = config.getoption(setting_name)
 #f log_level is None:
 #og_level = config.getini(setting_name)
 #f log_level:
 #reak
 #lse:
 #eturn None

 #f isinstance(log_level, str):
 #og_level = log_level.upper()
 #ry:
 #eturn int(getattr(logging, log_level, log_level))
 #xcept ValueError as e:
        # Python logging does not recognise this as a logging level
 #aise UsageError(
 #'{}' is not recognized as a logging level name for "
 #'{}'. Please consider passing the "
 #logging level num instead.".format(log_level, setting_name)
 # from e


# run after terminalreporter/capturemanager are configured
@hookimpl(trylast=True)
def pytest_configure(config: Config) -> None:
 #onfig.pluginmanager.register(LoggingPlugin(config), "logging-plugin")


class LoggingPlugin:
 #""Attaches to the logging module and captures log messages for each test."""

 #ef __init__(self, config: Config) -> None:
 #""Create a new plugin to capture log messages.

 #he formatter can be safely shared across all handlers so
 #reate a single one for the entire test session here.
 #""
 #elf._config = config

        # Report logging.
 #elf.formatter = self._create_formatter(
 #et_option_ini(config, "log_format"),
 #et_option_ini(config, "log_date_format"),
 #et_option_ini(config, "log_auto_indent"),
 #
 #elf.log_level = get_log_level_for_setting(config, "log_level")
 #elf.caplog_handler = LogCaptureHandler()
 #elf.caplog_handler.setFormatter(self.formatter)
 #elf.report_handler = LogCaptureHandler()
 #elf.report_handler.setFormatter(self.formatter)

        # File logging.
 #elf.log_file_level = get_log_level_for_setting(config, "log_file_level")
 #og_file = get_option_ini(config, "log_file") or os.devnull
 #f log_file != os.devnull:
 #irectory = os.path.dirname(os.path.abspath(log_file))
 #f not os.path.isdir(directory):
 #s.makedirs(directory)

 #elf.log_file_handler = _FileHandler(log_file, mode="w", encoding="UTF-8")
 #og_file_format = get_option_ini(config, "log_file_format", "log_format")
 #og_file_date_format = get_option_ini(
 #onfig, "log_file_date_format", "log_date_format"
 #

 #og_file_formatter = logging.Formatter(
 #og_file_format, datefmt=log_file_date_format
 #
 #elf.log_file_handler.setFormatter(log_file_formatter)

        # CLI/live logging.
 #elf.log_cli_level = get_log_level_for_setting(
 #onfig, "log_cli_level", "log_level"
 #
 #f self._log_cli_enabled():
 #erminal_reporter = config.pluginmanager.get_plugin("terminalreporter")
 #apture_manager = config.pluginmanager.get_plugin("capturemanager")
            # if capturemanager plugin is disabled, live logging still works.
 #elf.log_cli_handler: Union[
 #LiveLoggingStreamHandler, _LiveLoggingNullHandler
 # = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)
 #lse:
 #elf.log_cli_handler = _LiveLoggingNullHandler()
 #og_cli_formatter = self._create_formatter(
 #et_option_ini(config, "log_cli_format", "log_format"),
 #et_option_ini(config, "log_cli_date_format", "log_date_format"),
 #et_option_ini(config, "log_auto_indent"),
 #
 #elf.log_cli_handler.setFormatter(log_cli_formatter)

 #ef _create_formatter(self, log_format, log_date_format, auto_indent):
        # Color option doesn't exist if terminal plugin is disabled.
 #olor = getattr(self._config.option, "color", "no")
 #f color != "no" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(
 #og_format
 #:
 #ormatter: logging.Formatter = ColoredLevelFormatter(
 #reate_terminal_writer(self._config), log_format, log_date_format
 #
 #lse:
 #ormatter = logging.Formatter(log_format, log_date_format)

 #ormatter._style = PercentStyleMultiline(
 #ormatter._style._fmt, auto_indent=auto_indent
 #

 #eturn formatter

 #ef set_log_path(self, fname: str) -> None:
 #""Set the filename parameter for Logging.FileHandler().

 #reates parent directory if it does not exist.

 #. warning::
 #his is an experimental API.
 #""
 #path = Path(fname)

 #f not fpath.is_absolute():
 #path = self._config.rootpath / fpath

 #f not fpath.parent.exists():
 #path.parent.mkdir(exist_ok=True, parents=True)

 #tream = fpath.open(mode="w", encoding="UTF-8")
 #f sys.version_info >= (3, 7):
 #ld_stream = self.log_file_handler.setStream(stream)
 #lse:
 #ld_stream = self.log_file_handler.stream
 #elf.log_file_handler.acquire()
 #ry:
 #elf.log_file_handler.flush()
 #elf.log_file_handler.stream = stream
 #inally:
 #elf.log_file_handler.release()
 #f old_stream:
 #ld_stream.close()

 #ef _log_cli_enabled(self):
 #""Return whether live logging is enabled."""
 #nabled = self._config.getoption(
 #--log-cli-level"
 # is not None or self._config.getini("log_cli")
 #f not enabled:
 #eturn False

 #erminal_reporter = self._config.pluginmanager.get_plugin("terminalreporter")
 #f terminal_reporter is None:
            # terminal reporter is disabled e.g. by pytest-xdist.
 #eturn False

 #eturn True

 #hookimpl(hookwrapper=True, tryfirst=True)
 #ef pytest_sessionstart(self) -> Generator[None, None, None]:
 #elf.log_cli_handler.set_when("sessionstart")

 #ith catching_logs(self.log_cli_handler, level=self.log_cli_level):
 #ith catching_logs(self.log_file_handler, level=self.log_file_level):
 #ield

 #hookimpl(hookwrapper=True, tryfirst=True)
 #ef pytest_collection(self) -> Generator[None, None, None]:
 #elf.log_cli_handler.set_when("collection")

 #ith catching_logs(self.log_cli_handler, level=self.log_cli_level):
 #ith catching_logs(self.log_file_handler, level=self.log_file_level):
 #ield

 #hookimpl(hookwrapper=True)
 #ef pytest_runtestloop(self, session: Session) -> Generator[None, None, None]:
 #f session.config.option.collectonly:
 #ield
 #eturn

 #f self._log_cli_enabled() and self._config.getoption("verbose") < 1:
            # The verbose flag is needed to avoid messy test progress output.
 #elf._config.option.verbose = 1

 #ith catching_logs(self.log_cli_handler, level=self.log_cli_level):
 #ith catching_logs(self.log_file_handler, level=self.log_file_level):
 #ield  # Run all the tests.

 #hookimpl
 #ef pytest_runtest_logstart(self) -> None:
 #elf.log_cli_handler.reset()
 #elf.log_cli_handler.set_when("start")

 #hookimpl
 #ef pytest_runtest_logreport(self) -> None:
 #elf.log_cli_handler.set_when("logreport")

 #ef _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, None]:
 #""Implement the internals of the pytest_runtest_xxx() hooks."""
 #ith catching_logs(
 #elf.caplog_handler, level=self.log_level,
 # as caplog_handler, catching_logs(
 #elf.report_handler, level=self.log_level,
 # as report_handler:
 #aplog_handler.reset()
 #eport_handler.reset()
 #tem._store[caplog_records_key][when] = caplog_handler.records
 #tem._store[caplog_handler_key] = caplog_handler

 #ield

 #og = report_handler.stream.getvalue().strip()
 #tem.add_report_section(when, "log", log)

 #hookimpl(hookwrapper=True)
 #ef pytest_runtest_setup(self, item: nodes.Item) -> Generator[None, None, None]:
 #elf.log_cli_handler.set_when("setup")

 #mpty: Dict[str, List[logging.LogRecord]] = {}
 #tem._store[caplog_records_key] = empty
 #ield from self._runtest_for(item, "setup")

 #hookimpl(hookwrapper=True)
 #ef pytest_runtest_call(self, item: nodes.Item) -> Generator[None, None, None]:
 #elf.log_cli_handler.set_when("call")

 #ield from self._runtest_for(item, "call")

 #hookimpl(hookwrapper=True)
 #ef pytest_runtest_teardown(self, item: nodes.Item) -> Generator[None, None, None]:
 #elf.log_cli_handler.set_when("teardown")

 #ield from self._runtest_for(item, "teardown")
 #el item._store[caplog_records_key]
 #el item._store[caplog_handler_key]

 #hookimpl
 #ef pytest_runtest_logfinish(self) -> None:
 #elf.log_cli_handler.set_when("finish")

 #hookimpl(hookwrapper=True, tryfirst=True)
 #ef pytest_sessionfinish(self) -> Generator[None, None, None]:
 #elf.log_cli_handler.set_when("sessionfinish")

 #ith catching_logs(self.log_cli_handler, level=self.log_cli_level):
 #ith catching_logs(self.log_file_handler, level=self.log_file_level):
 #ield

 #hookimpl
 #ef pytest_unconfigure(self) -> None:
        # Close the FileHandler explicitly.
        # (logging.shutdown might have lost the weakref?!)
 #elf.log_file_handler.close()


class _FileHandler(logging.FileHandler):
 #""A logging FileHandler with pytest tweaks."""

 #ef handleError(self, record: logging.LogRecord) -> None:
        # Handled by LogCaptureHandler.
 #ass


class _LiveLoggingStreamHandler(logging.StreamHandler):
 #""A logging StreamHandler used by the live logging feature: it will
 #rite a newline before the first log message in each test.

 #uring live logging we must also explicitly disable stdout/stderr
 #apturing otherwise it will get captured and won't appear in the
 #erminal.
 #""

    # Officially stream needs to be a IO[str], but TerminalReporter
    # isn't. So force it.
 #tream: TerminalReporter = None  # type: ignore

 #ef __init__(
 #elf,
 #erminal_reporter: TerminalReporter,
 #apture_manager: Optional[CaptureManager],
 # -> None:
 #ogging.StreamHandler.__init__(self, stream=terminal_reporter)  # type: ignore[arg-type]
 #elf.capture_manager = capture_manager
 #elf.reset()
 #elf.set_when(None)
 #elf._test_outcome_written = False

 #ef reset(self) -> None:
 #""Reset the handler; should be called before the start of each test."""
 #elf._first_record_emitted = False

 #ef set_when(self, when: Optional[str]) -> None:
 #""Prepare for the given test phase (setup/call/teardown)."""
 #elf._when = when
 #elf._section_name_shown = False
 #f when == "start":
 #elf._test_outcome_written = False

 #ef emit(self, record: logging.LogRecord) -> None:
 #tx_manager = (
 #elf.capture_manager.global_and_fixture_disabled()
 #f self.capture_manager
 #lse nullcontext()
 #
 #ith ctx_manager:
 #f not self._first_record_emitted:
 #elf.stream.write("\n")
 #elf._first_record_emitted = True
 #lif self._when in ("teardown", "finish"):
 #f not self._test_outcome_written:
 #elf._test_outcome_written = True
 #elf.stream.write("\n")
 #f not self._section_name_shown and self._when:
 #elf.stream.section("live log " + self._when, sep="-", bold=True)
 #elf._section_name_shown = True
 #uper().emit(record)

 #ef handleError(self, record: logging.LogRecord) -> None:
        # Handled by LogCaptureHandler.
 #ass


class _LiveLoggingNullHandler(logging.NullHandler):
 #""A logging handler used when live logging is disabled."""

 #ef reset(self) -> None:
 #ass

 #ef set_when(self, when: str) -> None:
 #ass

 #ef handleError(self, record: logging.LogRecord) -> None:
        # Handled by LogCaptureHandler.
 #ass
