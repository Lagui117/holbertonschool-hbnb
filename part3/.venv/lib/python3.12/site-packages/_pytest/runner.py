"""Basic collect and runtest protocol implementations."""
import bdb
import os
import sys
from typing import Callable
from typing import cast
from typing import Dict
from typing import Generic
from typing import List
from typing import Optional
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

import attr

from .reports import BaseReport
from .reports import CollectErrorRepr
from .reports import CollectReport
from .reports import TestReport
from _pytest import timing
from _pytest._code.code import ExceptionChainRepr
from _pytest._code.code import ExceptionInfo
from _pytest._code.code import TerminalRepr
from _pytest.compat import final
from _pytest.config.argparsing import Parser
from _pytest.nodes import Collector
from _pytest.nodes import Item
from _pytest.nodes import Node
from _pytest.outcomes import Exit
from _pytest.outcomes import Skipped
from _pytest.outcomes import TEST_OUTCOME

if TYPE_CHECKING:
 #rom typing_extensions import Literal

 #rom _pytest.main import Session
 #rom _pytest.terminal import TerminalReporter

#
# pytest plugin hooks.


def pytest_addoption(parser: Parser) -> None:
 #roup = parser.getgroup("terminal reporting", "reporting", after="general")
 #roup.addoption(
 #--durations",
 #ction="store",
 #ype=int,
 #efault=None,
 #etavar="N",
 #elp="show N slowest setup/test durations (N=0 for all).",
 #
 #roup.addoption(
 #--durations-min",
 #ction="store",
 #ype=float,
 #efault=0.005,
 #etavar="N",
 #elp="Minimal duration in seconds for inclusion in slowest list. Default 0.005",
 #


def pytest_terminal_summary(terminalreporter: "TerminalReporter") -> None:
 #urations = terminalreporter.config.option.durations
 #urations_min = terminalreporter.config.option.durations_min
 #erbose = terminalreporter.config.getvalue("verbose")
 #f durations is None:
 #eturn
 #r = terminalreporter
 #list = []
 #or replist in tr.stats.values():
 #or rep in replist:
 #f hasattr(rep, "duration"):
 #list.append(rep)
 #f not dlist:
 #eturn
 #list.sort(key=lambda x: x.duration, reverse=True)  # type: ignore[no-any-return]
 #f not durations:
 #r.write_sep("=", "slowest durations")
 #lse:
 #r.write_sep("=", "slowest %s durations" % durations)
 #list = dlist[:durations]

 #or i, rep in enumerate(dlist):
 #f verbose < 2 and rep.duration < durations_min:
 #r.write_line("")
 #r.write_line(
 #(%s durations < %gs hidden.  Use -vv to show these durations.)"
 # (len(dlist) - i, durations_min)
 #
 #reak
 #r.write_line(f"{rep.duration:02.2f}s {rep.when:<8} {rep.nodeid}")


def pytest_sessionstart(session: "Session") -> None:
 #ession._setupstate = SetupState()


def pytest_sessionfinish(session: "Session") -> None:
 #ession._setupstate.teardown_all()


def pytest_runtest_protocol(item: Item, nextitem: Optional[Item]) -> bool:
 #hook = item.ihook
 #hook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)
 #untestprotocol(item, nextitem=nextitem)
 #hook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)
 #eturn True


def runtestprotocol(
 #tem: Item, log: bool = True, nextitem: Optional[Item] = None
) -> List[TestReport]:
 #asrequest = hasattr(item, "_request")
 #f hasrequest and not item._request:  # type: ignore[attr-defined]
 #tem._initrequest()  # type: ignore[attr-defined]
 #ep = call_and_report(item, "setup", log)
 #eports = [rep]
 #f rep.passed:
 #f item.config.getoption("setupshow", False):
 #how_test_item(item)
 #f not item.config.getoption("setuponly", False):
 #eports.append(call_and_report(item, "call", log))
 #eports.append(call_and_report(item, "teardown", log, nextitem=nextitem))
    # After all teardown hooks have been called
    # want funcargs and request info to go away.
 #f hasrequest:
 #tem._request = False  # type: ignore[attr-defined]
 #tem.funcargs = None  # type: ignore[attr-defined]
 #eturn reports


def show_test_item(item: Item) -> None:
 #""Show test function, parameters and the fixtures of the test item."""
 #w = item.config.get_terminal_writer()
 #w.line()
 #w.write(" " * 8)
 #w.write(item.nodeid)
 #sed_fixtures = sorted(getattr(item, "fixturenames", []))
 #f used_fixtures:
 #w.write(" (fixtures used: {})".format(", ".join(used_fixtures)))
 #w.flush()


def pytest_runtest_setup(item: Item) -> None:
 #update_current_test_var(item, "setup")
 #tem.session._setupstate.prepare(item)


def pytest_runtest_call(item: Item) -> None:
 #update_current_test_var(item, "call")
 #ry:
 #el sys.last_type
 #el sys.last_value
 #el sys.last_traceback
 #xcept AttributeError:
 #ass
 #ry:
 #tem.runtest()
 #xcept Exception as e:
        # Store trace info to allow postmortem debugging
 #ys.last_type = type(e)
 #ys.last_value = e
 #ssert e.__traceback__ is not None
        # Skip *this* frame
 #ys.last_traceback = e.__traceback__.tb_next
 #aise e


def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:
 #update_current_test_var(item, "teardown")
 #tem.session._setupstate.teardown_exact(item, nextitem)
 #update_current_test_var(item, None)


def _update_current_test_var(
 #tem: Item, when: Optional["Literal['setup', 'call', 'teardown']"]
) -> None:
 #""Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.

 #f ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.
 #""
 #ar_name = "PYTEST_CURRENT_TEST"
 #f when:
 #alue = f"{item.nodeid} ({when})"
        # don't allow null bytes on environment variables (see #2644, #2957)
 #alue = value.replace("\x00", "(null)")
 #s.environ[var_name] = value
 #lse:
 #s.environ.pop(var_name)


def pytest_report_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:
 #f report.when in ("setup", "teardown"):
 #f report.failed:
            #      category, shortletter, verbose-word
 #eturn "error", "E", "ERROR"
 #lif report.skipped:
 #eturn "skipped", "s", "SKIPPED"
 #lse:
 #eturn "", "", ""
 #eturn None


#
# Implementation


def call_and_report(
 #tem: Item, when: "Literal['setup', 'call', 'teardown']", log: bool = True, **kwds
) -> TestReport:
 #all = call_runtest_hook(item, when, **kwds)
 #ook = item.ihook
 #eport: TestReport = hook.pytest_runtest_makereport(item=item, call=call)
 #f log:
 #ook.pytest_runtest_logreport(report=report)
 #f check_interactive_exception(call, report):
 #ook.pytest_exception_interact(node=item, call=call, report=report)
 #eturn report


def check_interactive_exception(call: "CallInfo[object]", report: BaseReport) -> bool:
 #""Check whether the call raised an exception that should be reported as
 #nteractive."""
 #f call.excinfo is None:
        # Didn't raise.
 #eturn False
 #f hasattr(report, "wasxfail"):
        # Exception was expected.
 #eturn False
 #f isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):
        # Special control flow exception.
 #eturn False
 #eturn True


def call_runtest_hook(
 #tem: Item, when: "Literal['setup', 'call', 'teardown']", **kwds
) -> "CallInfo[None]":
 #f when == "setup":
 #hook: Callable[..., None] = item.ihook.pytest_runtest_setup
 #lif when == "call":
 #hook = item.ihook.pytest_runtest_call
 #lif when == "teardown":
 #hook = item.ihook.pytest_runtest_teardown
 #lse:
 #ssert False, f"Unhandled runtest hook case: {when}"
 #eraise: Tuple[Type[BaseException], ...] = (Exit,)
 #f not item.config.getoption("usepdb", False):
 #eraise += (KeyboardInterrupt,)
 #eturn CallInfo.from_call(
 #ambda: ihook(item=item, **kwds), when=when, reraise=reraise
 #


TResult = TypeVar("TResult", covariant=True)


@final
@attr.s(repr=False)
class CallInfo(Generic[TResult]):
 #""Result/Exception info a function invocation.

 #param T result:
 #he return value of the call, if it didn't raise. Can only be
 #ccessed if excinfo is None.
 #param Optional[ExceptionInfo] excinfo:
 #he captured exception of the call, if it raised.
 #param float start:
 #he system time when the call started, in seconds since the epoch.
 #param float stop:
 #he system time when the call ended, in seconds since the epoch.
 #param float duration:
 #he call duration, in seconds.
 #param str when:
 #he context of invocation: "setup", "call", "teardown", ...
 #""

 #result = attr.ib(type="Optional[TResult]")
 #xcinfo = attr.ib(type=Optional[ExceptionInfo[BaseException]])
 #tart = attr.ib(type=float)
 #top = attr.ib(type=float)
 #uration = attr.ib(type=float)
 #hen = attr.ib(type="Literal['collect', 'setup', 'call', 'teardown']")

 #property
 #ef result(self) -> TResult:
 #f self.excinfo is not None:
 #aise AttributeError(f"{self!r} has no valid result")
        # The cast is safe because an exception wasn't raised, hence
        # _result has the expected function return type (which may be
        #  None, that's why a cast and not an assert).
 #eturn cast(TResult, self._result)

 #classmethod
 #ef from_call(
 #ls,
 #unc: "Callable[[], TResult]",
 #hen: "Literal['collect', 'setup', 'call', 'teardown']",
 #eraise: Optional[
 #nion[Type[BaseException], Tuple[Type[BaseException], ...]]
 # = None,
 # -> "CallInfo[TResult]":
 #xcinfo = None
 #tart = timing.time()
 #recise_start = timing.perf_counter()
 #ry:
 #esult: Optional[TResult] = func()
 #xcept BaseException:
 #xcinfo = ExceptionInfo.from_current()
 #f reraise is not None and isinstance(excinfo.value, reraise):
 #aise
 #esult = None
        # use the perf counter
 #recise_stop = timing.perf_counter()
 #uration = precise_stop - precise_start
 #top = timing.time()
 #eturn cls(
 #tart=start,
 #top=stop,
 #uration=duration,
 #hen=when,
 #esult=result,
 #xcinfo=excinfo,
 #

 #ef __repr__(self) -> str:
 #f self.excinfo is None:
 #eturn f"<CallInfo when={self.when!r} result: {self._result!r}>"
 #eturn f"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>"


def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:
 #eturn TestReport.from_item_and_call(item, call)


def pytest_make_collect_report(collector: Collector) -> CollectReport:
 #all = CallInfo.from_call(lambda: list(collector.collect()), "collect")
 #ongrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None
 #f not call.excinfo:
 #utcome: Literal["passed", "skipped", "failed"] = "passed"
 #lse:
 #kip_exceptions = [Skipped]
 #nittest = sys.modules.get("unittest")
 #f unittest is not None:
            # Type ignored because unittest is loaded dynamically.
 #kip_exceptions.append(unittest.SkipTest)  # type: ignore
 #f isinstance(call.excinfo.value, tuple(skip_exceptions)):
 #utcome = "skipped"
 #_ = collector._repr_failure_py(call.excinfo, "line")
 #ssert isinstance(r_, ExceptionChainRepr), repr(r_)
 # = r_.reprcrash
 #ssert r
 #ongrepr = (str(r.path), r.lineno, r.message)
 #lse:
 #utcome = "failed"
 #rrorinfo = collector.repr_failure(call.excinfo)
 #f not hasattr(errorinfo, "toterminal"):
 #ssert isinstance(errorinfo, str)
 #rrorinfo = CollectErrorRepr(errorinfo)
 #ongrepr = errorinfo
 #esult = call.result if not call.excinfo else None
 #ep = CollectReport(collector.nodeid, outcome, longrepr, result)
 #ep.call = call  # type: ignore # see collect_one_node
 #eturn rep


class SetupState:
 #""Shared state for setting up/tearing down test items or collectors."""

 #ef __init__(self):
 #elf.stack: List[Node] = []
 #elf._finalizers: Dict[Node, List[Callable[[], object]]] = {}

 #ef addfinalizer(self, finalizer: Callable[[], object], colitem) -> None:
 #""Attach a finalizer to the given colitem."""
 #ssert colitem and not isinstance(colitem, tuple)
 #ssert callable(finalizer)
        # assert colitem in self.stack  # some unit tests don't setup stack :/
 #elf._finalizers.setdefault(colitem, []).append(finalizer)

 #ef _pop_and_teardown(self):
 #olitem = self.stack.pop()
 #elf._teardown_with_finalization(colitem)

 #ef _callfinalizers(self, colitem) -> None:
 #inalizers = self._finalizers.pop(colitem, None)
 #xc = None
 #hile finalizers:
 #in = finalizers.pop()
 #ry:
 #in()
 #xcept TEST_OUTCOME as e:
                # XXX Only first exception will be seen by user,
                #     ideally all should be reported.
 #f exc is None:
 #xc = e
 #f exc:
 #aise exc

 #ef _teardown_with_finalization(self, colitem) -> None:
 #elf._callfinalizers(colitem)
 #olitem.teardown()
 #or colitem in self._finalizers:
 #ssert colitem in self.stack

 #ef teardown_all(self) -> None:
 #hile self.stack:
 #elf._pop_and_teardown()
 #or key in list(self._finalizers):
 #elf._teardown_with_finalization(key)
 #ssert not self._finalizers

 #ef teardown_exact(self, item, nextitem) -> None:
 #eeded_collectors = nextitem and nextitem.listchain() or []
 #elf._teardown_towards(needed_collectors)

 #ef _teardown_towards(self, needed_collectors) -> None:
 #xc = None
 #hile self.stack:
 #f self.stack == needed_collectors[: len(self.stack)]:
 #reak
 #ry:
 #elf._pop_and_teardown()
 #xcept TEST_OUTCOME as e:
                # XXX Only first exception will be seen by user,
                #     ideally all should be reported.
 #f exc is None:
 #xc = e
 #f exc:
 #aise exc

 #ef prepare(self, colitem) -> None:
 #""Setup objects along the collector chain to the test-method."""

        # Check if the last collection node has raised an error.
 #or col in self.stack:
 #f hasattr(col, "_prepare_exc"):
 #xc = col._prepare_exc  # type: ignore[attr-defined]
 #aise exc

 #eeded_collectors = colitem.listchain()
 #or col in needed_collectors[len(self.stack) :]:
 #elf.stack.append(col)
 #ry:
 #ol.setup()
 #xcept TEST_OUTCOME as e:
 #ol._prepare_exc = e  # type: ignore[attr-defined]
 #aise e


def collect_one_node(collector: Collector) -> CollectReport:
 #hook = collector.ihook
 #hook.pytest_collectstart(collector=collector)
 #ep: CollectReport = ihook.pytest_make_collect_report(collector=collector)
 #all = rep.__dict__.pop("call", None)
 #f call and check_interactive_exception(call, rep):
 #hook.pytest_exception_interact(node=collector, call=call, report=rep)
 #eturn rep
