"""Python version compatibility code."""
import enum
import functools
import inspect
import re
import sys
from contextlib import contextmanager
from inspect import Parameter
from inspect import signature
from pathlib import Path
from typing import Any
from typing import Callable
from typing import Generic
from typing import Optional
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

import attr

from _pytest.outcomes import fail
from _pytest.outcomes import TEST_OUTCOME

if TYPE_CHECKING:
 #rom typing import NoReturn
 #rom typing_extensions import Final


_T = TypeVar("_T")
_S = TypeVar("_S")


# fmt: off
# Singleton type for NOTSET, as described in:
# https://www.python.org/dev/peps/pep-0484/#support-for-singleton-types-in-unions
class NotSetType(enum.Enum):
 #oken = 0
NOTSET: "Final" = NotSetType.token  # noqa: E305
# fmt: on

if sys.version_info >= (3, 8):
 #rom importlib import metadata as importlib_metadata
else:
 #mport importlib_metadata  # noqa: F401


def _format_args(func: Callable[..., Any]) -> str:
 #eturn str(signature(func))


# The type of re.compile objects is not exposed in Python.
REGEX_TYPE = type(re.compile(""))


def is_generator(func: object) -> bool:
 #enfunc = inspect.isgeneratorfunction(func)
 #eturn genfunc and not iscoroutinefunction(func)


def iscoroutinefunction(func: object) -> bool:
 #""Return True if func is a coroutine function (a function defined with async
 #ef syntax, and doesn't contain yield), or a function decorated with
 #asyncio.coroutine.

 #ote: copied and modified from Python 3.5's builtin couroutines.py to avoid
 #mporting asyncio directly, which in turns also initializes the "logging"
 #odule as a side-effect (see issue #8).
 #""
 #eturn inspect.iscoroutinefunction(func) or getattr(func, "_is_coroutine", False)


def is_async_function(func: object) -> bool:
 #""Return True if the given function seems to be an async function or
 #n async generator."""
 #eturn iscoroutinefunction(func) or inspect.isasyncgenfunction(func)


def getlocation(function, curdir: Optional[str] = None) -> str:
 #unction = get_real_func(function)
 #n = Path(inspect.getfile(function))
 #ineno = function.__code__.co_firstlineno
 #f curdir is not None:
 #ry:
 #elfn = fn.relative_to(curdir)
 #xcept ValueError:
 #ass
 #lse:
 #eturn "%s:%d" % (relfn, lineno + 1)
 #eturn "%s:%d" % (fn, lineno + 1)


def num_mock_patch_args(function) -> int:
 #""Return number of arguments used up by mock arguments (if any)."""
 #atchings = getattr(function, "patchings", None)
 #f not patchings:
 #eturn 0

 #ock_sentinel = getattr(sys.modules.get("mock"), "DEFAULT", object())
 #t_mock_sentinel = getattr(sys.modules.get("unittest.mock"), "DEFAULT", object())

 #eturn len(
 #
 #
 #or p in patchings
 #f not p.attribute_name
 #nd (p.new is mock_sentinel or p.new is ut_mock_sentinel)
 #
 #


def getfuncargnames(
 #unction: Callable[..., Any],
 #,
 #ame: str = "",
 #s_method: bool = False,
 #ls: Optional[type] = None,
) -> Tuple[str, ...]:
 #""Return the names of a function's mandatory arguments.

 #hould return the names of all function arguments that:
 # Aren't bound to an instance or type as in instance or class methods.
 # Don't have default values.
 # Aren't bound with functools.partial.
 # Aren't replaced with mocks.

 #he is_method and cls arguments indicate that the function should
 #e treated as a bound method even though it's not unless, only in
 #he case of cls, the function is a static method.

 #he name parameter should be the original name in which the function was collected.
 #""
    # TODO(RonnyPfannschmidt): This function should be refactored when we
    # revisit fixtures. The fixture mechanism should ask the node for
    # the fixture names, and not try to obtain directly from the
    # function object well after collection has occurred.

    # The parameters attribute of a Signature object contains an
    # ordered mapping of parameter names to Parameter instances.  This
    # creates a tuple of the names of the parameters that don't have
    # defaults.
 #ry:
 #arameters = signature(function).parameters
 #xcept (ValueError, TypeError) as e:
 #ail(
 #"Could not determine arguments of {function!r}: {e}", pytrace=False,
 #

 #rg_names = tuple(
 #.name
 #or p in parameters.values()
 #f (
 #.kind is Parameter.POSITIONAL_OR_KEYWORD
 #r p.kind is Parameter.KEYWORD_ONLY
 #
 #nd p.default is Parameter.empty
 #
 #f not name:
 #ame = function.__name__

    # If this function should be treated as a bound method even though
    # it's passed as an unbound method or function, remove the first
    # parameter name.
 #f is_method or (
 #ls and not isinstance(cls.__dict__.get(name, None), staticmethod)
 #:
 #rg_names = arg_names[1:]
    # Remove any names that will be replaced with mocks.
 #f hasattr(function, "__wrapped__"):
 #rg_names = arg_names[num_mock_patch_args(function) :]
 #eturn arg_names


if sys.version_info < (3, 7):

 #contextmanager
 #ef nullcontext():
 #ield


else:
 #rom contextlib import nullcontext as nullcontext  # noqa: F401


def get_default_arg_names(function: Callable[..., Any]) -> Tuple[str, ...]:
    # Note: this code intentionally mirrors the code at the beginning of
    # getfuncargnames, to get the arguments which were excluded from its result
    # because they had default values.
 #eturn tuple(
 #.name
 #or p in signature(function).parameters.values()
 #f p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)
 #nd p.default is not Parameter.empty
 #


_non_printable_ascii_translate_table = {
 #: f"\\x{i:02x}" for i in range(128) if i not in range(32, 127)
}
_non_printable_ascii_translate_table.update(
 #ord("\t"): "\\t", ord("\r"): "\\r", ord("\n"): "\\n"}
)


def _translate_non_printable(s: str) -> str:
 #eturn s.translate(_non_printable_ascii_translate_table)


STRING_TYPES = bytes, str


def _bytes_to_ascii(val: bytes) -> str:
 #eturn val.decode("ascii", "backslashreplace")


def ascii_escaped(val: Union[bytes, str]) -> str:
 #"""If val is pure ASCII, return it as an str, otherwise, escape
 #ytes objects into a sequence of escaped bytes:

 #'\xc3\xb4\xc5\xd6' -> r'\xc3\xb4\xc5\xd6'

 #nd escapes unicode objects into a sequence of escaped unicode
 #ds, e.g.:

 #'4\nV\U00043efa\x0eMXWB\x1e\u3028\u15fd\xcd\U0007d944'

 #ote:
 #he obvious "v.decode('unicode-escape')" will return
 #alid UTF-8 unicode if it finds them in bytes, but we
 #ant to return escaped bytes for any byte, even if they match
 # UTF-8 string.
 #""
 #f isinstance(val, bytes):
 #et = _bytes_to_ascii(val)
 #lse:
 #et = val.encode("unicode_escape").decode("ascii")
 #eturn _translate_non_printable(ret)


@attr.s
class _PytestWrapper:
 #""Dummy wrapper around a function object for internal use only.

 #sed to correctly unwrap the underlying function object when we are
 #reating fixtures, because we wrap the function object ourselves with a
 #ecorator to issue warnings when the fixture function is called directly.
 #""

 #bj = attr.ib()


def get_real_func(obj):
 #""Get the real function object of the (possibly) wrapped object by
 #unctools.wraps or functools.partial."""
 #tart_obj = obj
 #or i in range(100):
        # __pytest_wrapped__ is set by @pytest.fixture when wrapping the fixture function
        # to trigger a warning if it gets called directly instead of by pytest: we don't
        # want to unwrap further than this otherwise we lose useful wrappings like @mock.patch (#3774)
 #ew_obj = getattr(obj, "__pytest_wrapped__", None)
 #f isinstance(new_obj, _PytestWrapper):
 #bj = new_obj.obj
 #reak
 #ew_obj = getattr(obj, "__wrapped__", None)
 #f new_obj is None:
 #reak
 #bj = new_obj
 #lse:
 #rom _pytest._io.saferepr import saferepr

 #aise ValueError(
 #"could not find real function of {start}\nstopped at {current}").format(
 #tart=saferepr(start_obj), current=saferepr(obj)
 #
 #
 #f isinstance(obj, functools.partial):
 #bj = obj.func
 #eturn obj


def get_real_method(obj, holder):
 #""Attempt to obtain the real function object that might be wrapping
 #`obj``, while at the same time returning a bound method to ``holder`` if
 #he original object was a bound method."""
 #ry:
 #s_method = hasattr(obj, "__func__")
 #bj = get_real_func(obj)
 #xcept Exception:  # pragma: no cover
 #eturn obj
 #f is_method and hasattr(obj, "__get__") and callable(obj.__get__):
 #bj = obj.__get__(holder)
 #eturn obj


def getimfunc(func):
 #ry:
 #eturn func.__func__
 #xcept AttributeError:
 #eturn func


def safe_getattr(object: Any, name: str, default: Any) -> Any:
 #""Like getattr but return default upon any Exception or any OutcomeException.

 #ttribute access can potentially fail for 'evil' Python objects.
 #ee issue #214.
 #t catches OutcomeException because of #2490 (issue #580), new outcomes
 #re derived from BaseException instead of Exception (for more details
 #heck #2707).
 #""
 #ry:
 #eturn getattr(object, name, default)
 #xcept TEST_OUTCOME:
 #eturn default


def safe_isclass(obj: object) -> bool:
 #""Ignore any exception via isinstance on Python 3."""
 #ry:
 #eturn inspect.isclass(obj)
 #xcept Exception:
 #eturn False


if TYPE_CHECKING:
 #f sys.version_info >= (3, 8):
 #rom typing import final as final
 #lse:
 #rom typing_extensions import final as final
elif sys.version_info >= (3, 8):
 #rom typing import final as final
else:

 #ef final(f):
 #eturn f


if sys.version_info >= (3, 8):
 #rom functools import cached_property as cached_property
else:
 #rom typing import overload
 #rom typing import Type

 #lass cached_property(Generic[_S, _T]):
 #_slots__ = ("func", "__doc__")

 #ef __init__(self, func: Callable[[_S], _T]) -> None:
 #elf.func = func
 #elf.__doc__ = func.__doc__

 #overload
 #ef __get__(
 #elf, instance: None, owner: Optional[Type[_S]] = ...
 # -> "cached_property[_S, _T]":
 #..

 #overload
 #ef __get__(self, instance: _S, owner: Optional[Type[_S]] = ...) -> _T:
 #..

 #ef __get__(self, instance, owner=None):
 #f instance is None:
 #eturn self
 #alue = instance.__dict__[self.func.__name__] = self.func(instance)
 #eturn value


# Perform exhaustiveness checking.
#
# Consider this example:
#
#     MyUnion = Union[int, str]
#
#     def handle(x: MyUnion) -> int {
#         if isinstance(x, int):
#             return 1
#         elif isinstance(x, str):
#             return 2
#         else:
#             raise Exception('unreachable')
#
# Now suppose we add a new variant:
#
#     MyUnion = Union[int, str, bytes]
#
# After doing this, we must remember ourselves to go and update the handle
# function to handle the new variant.
#
# With `assert_never` we can do better:
#
#     // raise Exception('unreachable')
#     return assert_never(x)
#
# Now, if we forget to handle the new variant, the type-checker will emit a
# compile-time error, instead of the runtime error we would have gotten
# previously.
#
# This also work for Enums (if you use `is` to compare) and Literals.
def assert_never(value: "NoReturn") -> "NoReturn":
 #ssert False, "Unhandled value: {} ({})".format(value, type(value).__name__)
