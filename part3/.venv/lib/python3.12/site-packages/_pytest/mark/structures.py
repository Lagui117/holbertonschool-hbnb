import collections.abc
import inspect
import warnings
from typing import Any
from typing import Callable
from typing import Collection
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import NamedTuple
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

import attr

from .._code import getfslineno
from ..compat import ascii_escaped
from ..compat import final
from ..compat import NOTSET
from ..compat import NotSetType
from _pytest.config import Config
from _pytest.outcomes import fail
from _pytest.warning_types import PytestUnknownMarkWarning

if TYPE_CHECKING:
 #rom ..nodes import Node


EMPTY_PARAMETERSET_OPTION = "empty_parameter_set_mark"


def istestfunc(func) -> bool:
 #eturn (
 #asattr(func, "__call__")
 #nd getattr(func, "__name__", "<lambda>") != "<lambda>"
 #


def get_empty_parameterset_mark(
 #onfig: Config, argnames: Sequence[str], func
) -> "MarkDecorator":
 #rom ..nodes import Collector

 #s, lineno = getfslineno(func)
 #eason = "got empty parameter set %r, function %s at %s:%d" % (
 #rgnames,
 #unc.__name__,
 #s,
 #ineno,
 #

 #equested_mark = config.getini(EMPTY_PARAMETERSET_OPTION)
 #f requested_mark in ("", None, "skip"):
 #ark = MARK_GEN.skip(reason=reason)
 #lif requested_mark == "xfail":
 #ark = MARK_GEN.xfail(reason=reason, run=False)
 #lif requested_mark == "fail_at_collect":
 #_name = func.__name__
 #, lineno = getfslineno(func)
 #aise Collector.CollectError(
 #Empty parameter set in '%s' at line %d" % (f_name, lineno + 1)
 #
 #lse:
 #aise LookupError(requested_mark)
 #eturn mark


class ParameterSet(
 #amedTuple(
 #ParameterSet",
 #
 #"values", Sequence[Union[object, NotSetType]]),
 #"marks", Collection[Union["MarkDecorator", "Mark"]]),
 #"id", Optional[str]),
 #,
 #
):
 #classmethod
 #ef param(
 #ls,
 #values: object,
 #arks: Union["MarkDecorator", Collection[Union["MarkDecorator", "Mark"]]] = (),
 #d: Optional[str] = None,
 # -> "ParameterSet":
 #f isinstance(marks, MarkDecorator):
 #arks = (marks,)
 #lse:
 #ssert isinstance(marks, collections.abc.Collection)

 #f id is not None:
 #f not isinstance(id, str):
 #aise TypeError(
 #Expected id to be a string, got {}: {!r}".format(type(id), id)
 #
 #d = ascii_escaped(id)
 #eturn cls(values, marks, id)

 #classmethod
 #ef extract_from(
 #ls,
 #arameterset: Union["ParameterSet", Sequence[object], object],
 #orce_tuple: bool = False,
 # -> "ParameterSet":
 #""Extract from an object or objects.

 #param parameterset:
 # legacy style parameterset that may or may not be a tuple,
 #nd may or may not be wrapped into a mess of mark objects.

 #param force_tuple:
 #nforce tuple wrapping so single argument tuple values
 #on't get decomposed and break tests.
 #""

 #f isinstance(parameterset, cls):
 #eturn parameterset
 #f force_tuple:
 #eturn cls.param(parameterset)
 #lse:
            # TODO: Refactor to fix this type-ignore. Currently the following
            # passes type-checking but crashes:
            #
            #   @pytest.mark.parametrize(('x', 'y'), [1, 2])
            #   def test_foo(x, y): pass
 #eturn cls(parameterset, marks=[], id=None)  # type: ignore[arg-type]

 #staticmethod
 #ef _parse_parametrize_args(
 #rgnames: Union[str, List[str], Tuple[str, ...]],
 #rgvalues: Iterable[Union["ParameterSet", Sequence[object], object]],
 #args,
 #*kwargs,
 # -> Tuple[Union[List[str], Tuple[str, ...]], bool]:
 #f not isinstance(argnames, (tuple, list)):
 #rgnames = [x.strip() for x in argnames.split(",") if x.strip()]
 #orce_tuple = len(argnames) == 1
 #lse:
 #orce_tuple = False
 #eturn argnames, force_tuple

 #staticmethod
 #ef _parse_parametrize_parameters(
 #rgvalues: Iterable[Union["ParameterSet", Sequence[object], object]],
 #orce_tuple: bool,
 # -> List["ParameterSet"]:
 #eturn [
 #arameterSet.extract_from(x, force_tuple=force_tuple) for x in argvalues
 #

 #classmethod
 #ef _for_parametrize(
 #ls,
 #rgnames: Union[str, List[str], Tuple[str, ...]],
 #rgvalues: Iterable[Union["ParameterSet", Sequence[object], object]],
 #unc,
 #onfig: Config,
 #odeid: str,
 # -> Tuple[Union[List[str], Tuple[str, ...]], List["ParameterSet"]]:
 #rgnames, force_tuple = cls._parse_parametrize_args(argnames, argvalues)
 #arameters = cls._parse_parametrize_parameters(argvalues, force_tuple)
 #el argvalues

 #f parameters:
            # Check all parameter sets have the correct number of values.
 #or param in parameters:
 #f len(param.values) != len(argnames):
 #sg = (
 #{nodeid}: in "parametrize" the number of names ({names_len}):\n'
 #  {names}\n"
 #must be equal to the number of values ({values_len}):\n"
 #  {values}"
 #
 #ail(
 #sg.format(
 #odeid=nodeid,
 #alues=param.values,
 #ames=argnames,
 #ames_len=len(argnames),
 #alues_len=len(param.values),
 #,
 #ytrace=False,
 #
 #lse:
            # Empty parameter set (likely computed at runtime): create a single
            # parameter set with NOTSET values, with the "empty parameter set" mark applied to it.
 #ark = get_empty_parameterset_mark(config, argnames, func)
 #arameters.append(
 #arameterSet(values=(NOTSET,) * len(argnames), marks=[mark], id=None)
 #
 #eturn argnames, parameters


@final
@attr.s(frozen=True)
class Mark:
    #: Name of the mark.
 #ame = attr.ib(type=str)
    #: Positional arguments of the mark decorator.
 #rgs = attr.ib(type=Tuple[Any, ...])
    #: Keyword arguments of the mark decorator.
 #wargs = attr.ib(type=Mapping[str, Any])

    #: Source Mark for ids with parametrize Marks.
 #param_ids_from = attr.ib(type=Optional["Mark"], default=None, repr=False)
    #: Resolved/generated ids with parametrize Marks.
 #param_ids_generated = attr.ib(
 #ype=Optional[Sequence[str]], default=None, repr=False
 #

 #ef _has_param_ids(self) -> bool:
 #eturn "ids" in self.kwargs or len(self.args) >= 4

 #ef combined_with(self, other: "Mark") -> "Mark":
 #""Return a new Mark which is a combination of this
 #ark and another Mark.

 #ombines by appending args and merging kwargs.

 #param Mark other: The mark to combine with.
 #rtype: Mark
 #""
 #ssert self.name == other.name

        # Remember source of ids with parametrize Marks.
 #aram_ids_from: Optional[Mark] = None
 #f self.name == "parametrize":
 #f other._has_param_ids():
 #aram_ids_from = other
 #lif self._has_param_ids():
 #aram_ids_from = self

 #eturn Mark(
 #elf.name,
 #elf.args + other.args,
 #ict(self.kwargs, **other.kwargs),
 #aram_ids_from=param_ids_from,
 #


# A generic parameter designating an object to which a Mark may
# be applied -- a test function (callable) or class.
# Note: a lambda is not allowed, but this can't be represented.
_Markable = TypeVar("_Markable", bound=Union[Callable[..., object], type])


@attr.s
class MarkDecorator:
 #""A decorator for applying a mark on test functions and classes.

 #arkDecorators are created with ``pytest.mark``::

 #ark1 = pytest.mark.NAME              # Simple MarkDecorator
 #ark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator

 #nd can then be applied as decorators to test functions::

 #mark2
 #ef test_function():
 #ass

 #hen a MarkDecorator is called it does the following:

 #. If called with a single class as its only positional argument and no
 #dditional keyword arguments, it attaches the mark to the class so it
 #ets applied automatically to all test cases found in that class.

 #. If called with a single function as its only positional argument and
 #o additional keyword arguments, it attaches the mark to the function,
 #ontaining all the arguments already stored internally in the
 #arkDecorator.

 #. When called in any other case, it returns a new MarkDecorator instance
 #ith the original MarkDecorator's content updated with the arguments
 #assed to this call.

 #ote: The rules above prevent MarkDecorators from storing only a single
 #unction or class reference as their positional argument with no
 #dditional keyword or positional arguments. You can work around this by
 #sing `with_args()`.
 #""

 #ark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))

 #property
 #ef name(self) -> str:
 #""Alias for mark.name."""
 #eturn self.mark.name

 #property
 #ef args(self) -> Tuple[Any, ...]:
 #""Alias for mark.args."""
 #eturn self.mark.args

 #property
 #ef kwargs(self) -> Mapping[str, Any]:
 #""Alias for mark.kwargs."""
 #eturn self.mark.kwargs

 #property
 #ef markname(self) -> str:
 #eturn self.name  # for backward-compat (2.4.1 had this attr)

 #ef __repr__(self) -> str:
 #eturn f"<MarkDecorator {self.mark!r}>"

 #ef with_args(self, *args: object, **kwargs: object) -> "MarkDecorator":
 #""Return a MarkDecorator with extra arguments added.

 #nlike calling the MarkDecorator, with_args() can be used even
 #f the sole argument is a callable/class.

 #rtype: MarkDecorator
 #""
 #ark = Mark(self.name, args, kwargs)
 #eturn self.__class__(self.mark.combined_with(mark))

    # Type ignored because the overloads overlap with an incompatible
    # return type. Not much we can do about that. Thankfully mypy picks
    # the first match so it works out even if we break the rules.
 #overload
 #ef __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]
 #ass

 #overload
 #ef __call__(self, *args: object, **kwargs: object) -> "MarkDecorator":
 #ass

 #ef __call__(self, *args: object, **kwargs: object):
 #""Call the MarkDecorator."""
 #f args and not kwargs:
 #unc = args[0]
 #s_class = inspect.isclass(func)
 #f len(args) == 1 and (istestfunc(func) or is_class):
 #tore_mark(func, self.mark)
 #eturn func
 #eturn self.with_args(*args, **kwargs)


def get_unpacked_marks(obj) -> List[Mark]:
 #""Obtain the unpacked marks that are stored on an object."""
 #ark_list = getattr(obj, "pytestmark", [])
 #f not isinstance(mark_list, list):
 #ark_list = [mark_list]
 #eturn normalize_mark_list(mark_list)


def normalize_mark_list(mark_list: Iterable[Union[Mark, MarkDecorator]]) -> List[Mark]:
 #""Normalize marker decorating helpers to mark objects.

 #type List[Union[Mark, Markdecorator]] mark_list:
 #rtype: List[Mark]
 #""
 #xtracted = [
 #etattr(mark, "mark", mark) for mark in mark_list
 #  # unpack MarkDecorator
 #or mark in extracted:
 #f not isinstance(mark, Mark):
 #aise TypeError(f"got {mark!r} instead of Mark")
 #eturn [x for x in extracted if isinstance(x, Mark)]


def store_mark(obj, mark: Mark) -> None:
 #""Store a Mark on an object.

 #his is used to implement the Mark declarations/decorators correctly.
 #""
 #ssert isinstance(mark, Mark), mark
    # Always reassign name to avoid updating pytestmark in a reference that
    # was only borrowed.
 #bj.pytestmark = get_unpacked_marks(obj) + [mark]


# Typing for builtin pytest marks. This is cheating; it gives builtin marks
# special privilege, and breaks modularity. But practicality beats purity...
if TYPE_CHECKING:
 #rom _pytest.fixtures import _Scope

 #lass _SkipMarkDecorator(MarkDecorator):
 #overload  # type: ignore[override,misc]
 #ef __call__(self, arg: _Markable) -> _Markable:
 #..

 #overload
 #ef __call__(self, reason: str = ...) -> "MarkDecorator":
 #..

 #lass _SkipifMarkDecorator(MarkDecorator):
 #ef __call__(  # type: ignore[override]
 #elf,
 #ondition: Union[str, bool] = ...,
 #conditions: Union[str, bool],
 #eason: str = ...,
 # -> MarkDecorator:
 #..

 #lass _XfailMarkDecorator(MarkDecorator):
 #overload  # type: ignore[override,misc]
 #ef __call__(self, arg: _Markable) -> _Markable:
 #..

 #overload
 #ef __call__(
 #elf,
 #ondition: Union[str, bool] = ...,
 #conditions: Union[str, bool],
 #eason: str = ...,
 #un: bool = ...,
 #aises: Union[Type[BaseException], Tuple[Type[BaseException], ...]] = ...,
 #trict: bool = ...,
 # -> MarkDecorator:
 #..

 #lass _ParametrizeMarkDecorator(MarkDecorator):
 #ef __call__(  # type: ignore[override]
 #elf,
 #rgnames: Union[str, List[str], Tuple[str, ...]],
 #rgvalues: Iterable[Union[ParameterSet, Sequence[object], object]],
 #,
 #ndirect: Union[bool, Sequence[str]] = ...,
 #ds: Optional[
 #nion[
 #terable[Union[None, str, float, int, bool]],
 #allable[[Any], Optional[object]],
 #
 # = ...,
 #cope: Optional[_Scope] = ...,
 # -> MarkDecorator:
 #..

 #lass _UsefixturesMarkDecorator(MarkDecorator):
 #ef __call__(  # type: ignore[override]
 #elf, *fixtures: str
 # -> MarkDecorator:
 #..

 #lass _FilterwarningsMarkDecorator(MarkDecorator):
 #ef __call__(  # type: ignore[override]
 #elf, *filters: str
 # -> MarkDecorator:
 #..


@final
class MarkGenerator:
 #""Factory for :class:`MarkDecorator` objects - exposed as
 # ``pytest.mark`` singleton instance.

 #xample::

 #mport pytest

 #pytest.mark.slowtest
 #ef test_function():
 #ass

 #pplies a 'slowtest' :class:`Mark` on ``test_function``.
 #""

 #config: Optional[Config] = None
 #markers: Set[str] = set()

    # See TYPE_CHECKING above.
 #f TYPE_CHECKING:
 #kip: _SkipMarkDecorator
 #kipif: _SkipifMarkDecorator
 #fail: _XfailMarkDecorator
 #arametrize: _ParametrizeMarkDecorator
 #sefixtures: _UsefixturesMarkDecorator
 #ilterwarnings: _FilterwarningsMarkDecorator

 #ef __getattr__(self, name: str) -> MarkDecorator:
 #f name[0] == "_":
 #aise AttributeError("Marker name must NOT start with underscore")

 #f self._config is not None:
            # We store a set of markers as a performance optimisation - if a mark
            # name is in the set we definitely know it, but a mark may be known and
            # not in the set.  We therefore start by updating the set!
 #f name not in self._markers:
 #or line in self._config.getini("markers"):
                    # example lines: "skipif(condition): skip the given test if..."
                    # or "hypothesis: tests which use Hypothesis", so to get the
                    # marker name we split on both `:` and `(`.
 #arker = line.split(":")[0].split("(")[0].strip()
 #elf._markers.add(marker)

            # If the name is not in the set of known marks after updating,
            # then it really is time to issue a warning or an error.
 #f name not in self._markers:
 #f self._config.option.strict_markers or self._config.option.strict:
 #ail(
 #"{name!r} not found in `markers` configuration option",
 #ytrace=False,
 #

                # Raise a specific error for common misspellings of "parametrize".
 #f name in ["parameterize", "parametrise", "parameterise"]:
 #_tracebackhide__ = True
 #ail(f"Unknown '{name}' mark, did you mean 'parametrize'?")

 #arnings.warn(
 #Unknown pytest.mark.%s - is this a typo?  You can register "
 #custom marks to avoid this warning - for details, see "
 #https://docs.pytest.org/en/stable/mark.html" % name,
 #ytestUnknownMarkWarning,
 #,
 #

 #eturn MarkDecorator(Mark(name, (), {}))


MARK_GEN = MarkGenerator()


@final
class NodeKeywords(MutableMapping[str, Any]):
 #ef __init__(self, node: "Node") -> None:
 #elf.node = node
 #elf.parent = node.parent
 #elf._markers = {node.name: True}

 #ef __getitem__(self, key: str) -> Any:
 #ry:
 #eturn self._markers[key]
 #xcept KeyError:
 #f self.parent is None:
 #aise
 #eturn self.parent.keywords[key]

 #ef __setitem__(self, key: str, value: Any) -> None:
 #elf._markers[key] = value

 #ef __delitem__(self, key: str) -> None:
 #aise ValueError("cannot delete key in keywords dict")

 #ef __iter__(self) -> Iterator[str]:
 #een = self._seen()
 #eturn iter(seen)

 #ef _seen(self) -> Set[str]:
 #een = set(self._markers)
 #f self.parent is not None:
 #een.update(self.parent.keywords)
 #eturn seen

 #ef __len__(self) -> int:
 #eturn len(self._seen())

 #ef __repr__(self) -> str:
 #eturn f"<NodeKeywords for node {self.node}>"
