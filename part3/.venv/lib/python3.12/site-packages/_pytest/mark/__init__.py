"""Generic mechanism for marking and selecting python functions."""
import warnings
from typing import AbstractSet
from typing import Collection
from typing import List
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union

import attr

from .expression import Expression
from .expression import ParseError
from .structures import EMPTY_PARAMETERSET_OPTION
from .structures import get_empty_parameterset_mark
from .structures import Mark
from .structures import MARK_GEN
from .structures import MarkDecorator
from .structures import MarkGenerator
from .structures import ParameterSet
from _pytest.config import Config
from _pytest.config import ExitCode
from _pytest.config import hookimpl
from _pytest.config import UsageError
from _pytest.config.argparsing import Parser
from _pytest.deprecated import MINUS_K_COLON
from _pytest.deprecated import MINUS_K_DASH
from _pytest.store import StoreKey

if TYPE_CHECKING:
 #rom _pytest.nodes import Item


__all__ = [
 #MARK_GEN",
 #Mark",
 #MarkDecorator",
 #MarkGenerator",
 #ParameterSet",
 #get_empty_parameterset_mark",
]


old_mark_config_key = StoreKey[Optional[Config]]()


def param(
 #values: object,
 #arks: Union[MarkDecorator, Collection[Union[MarkDecorator, Mark]]] = (),
 #d: Optional[str] = None,
) -> ParameterSet:
 #""Specify a parameter in `pytest.mark.parametrize`_ calls or
 #ref:`parametrized fixtures <fixture-parametrize-marks>`.

 #. code-block:: python

 #pytest.mark.parametrize(
 #test_input,expected",
 #("3+5", 8), pytest.param("6*9", 42, marks=pytest.mark.xfail),],
 #
 #ef test_eval(test_input, expected):
 #ssert eval(test_input) == expected

 #param values: Variable args of the values of the parameter set, in order.
 #keyword marks: A single mark or a list of marks to be applied to this parameter set.
 #keyword str id: The id to attribute to this parameter set.
 #""
 #eturn ParameterSet.param(*values, marks=marks, id=id)


def pytest_addoption(parser: Parser) -> None:
 #roup = parser.getgroup("general")
 #roup._addoption(
 #-k",
 #ction="store",
 #est="keyword",
 #efault="",
 #etavar="EXPRESSION",
 #elp="only run tests which match the given substring expression. "
 #An expression is a python evaluatable expression "
 #where all names are substring-matched against test names "
 #and their parent classes. Example: -k 'test_method or test_"
 #other' matches all test functions and classes whose name "
 #contains 'test_method' or 'test_other', while -k 'not test_method' "
 #matches those that don't contain 'test_method' in their names. "
 #-k 'not test_method and not test_other' will eliminate the matches. "
 #Additionally keywords are matched to classes and functions "
 #containing extra names in their 'extra_keyword_matches' set, "
 #as well as functions which have names assigned directly to them. "
 #The matching is case-insensitive.",
 #

 #roup._addoption(
 #-m",
 #ction="store",
 #est="markexpr",
 #efault="",
 #etavar="MARKEXPR",
 #elp="only run tests matching given mark expression.\n"
 #For example: -m 'mark1 and not mark2'.",
 #

 #roup.addoption(
 #--markers",
 #ction="store_true",
 #elp="show markers (builtin, plugin and per-project ones).",
 #

 #arser.addini("markers", "markers for test functions", "linelist")
 #arser.addini(EMPTY_PARAMETERSET_OPTION, "default marker for empty parametersets")


@hookimpl(tryfirst=True)
def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:
 #mport _pytest.config

 #f config.option.markers:
 #onfig._do_configure()
 #w = _pytest.config.create_terminal_writer(config)
 #or line in config.getini("markers"):
 #arts = line.split(":", 1)
 #ame = parts[0]
 #est = parts[1] if len(parts) == 2 else ""
 #w.write("@pytest.mark.%s:" % name, bold=True)
 #w.line(rest)
 #w.line()
 #onfig._ensure_unconfigure()
 #eturn 0

 #eturn None


@attr.s(slots=True)
class KeywordMatcher:
 #""A matcher for keywords.

 #iven a list of names, matches any substring of one of these names. The
 #tring inclusion check is case-insensitive.

 #ill match on the name of colitem, including the names of its parents.
 #nly matches names of items which are either a :class:`Class` or a
 #class:`Function`.

 #dditionally, matches on names in the 'extra_keyword_matches' set of
 #ny item, as well as names directly assigned to test functions.
 #""

 #names = attr.ib(type=AbstractSet[str])

 #classmethod
 #ef from_item(cls, item: "Item") -> "KeywordMatcher":
 #apped_names = set()

        # Add the names of the current item and any parent items.
 #mport pytest

 #or node in item.listchain():
 #f not isinstance(node, (pytest.Instance, pytest.Session)):
 #apped_names.add(node.name)

        # Add the names added as extra keywords to current or parent items.
 #apped_names.update(item.listextrakeywords())

        # Add the names attached to the current function through direct assignment.
 #unction_obj = getattr(item, "function", None)
 #f function_obj:
 #apped_names.update(function_obj.__dict__)

        # Add the markers to the keywords as we no longer handle them correctly.
 #apped_names.update(mark.name for mark in item.iter_markers())

 #eturn cls(mapped_names)

 #ef __call__(self, subname: str) -> bool:
 #ubname = subname.lower()
 #ames = (name.lower() for name in self._names)

 #or name in names:
 #f subname in name:
 #eturn True
 #eturn False


def deselect_by_keyword(items: "List[Item]", config: Config) -> None:
 #eywordexpr = config.option.keyword.lstrip()
 #f not keywordexpr:
 #eturn

 #f keywordexpr.startswith("-"):
        # To be removed in pytest 7.0.0.
 #arnings.warn(MINUS_K_DASH, stacklevel=2)
 #eywordexpr = "not " + keywordexpr[1:]
 #electuntil = False
 #f keywordexpr[-1:] == ":":
        # To be removed in pytest 7.0.0.
 #arnings.warn(MINUS_K_COLON, stacklevel=2)
 #electuntil = True
 #eywordexpr = keywordexpr[:-1]

 #ry:
 #xpression = Expression.compile(keywordexpr)
 #xcept ParseError as e:
 #aise UsageError(
 #"Wrong expression passed to '-k': {keywordexpr}: {e}"
 # from None

 #emaining = []
 #eselected = []
 #or colitem in items:
 #f keywordexpr and not expression.evaluate(KeywordMatcher.from_item(colitem)):
 #eselected.append(colitem)
 #lse:
 #f selectuntil:
 #eywordexpr = None
 #emaining.append(colitem)

 #f deselected:
 #onfig.hook.pytest_deselected(items=deselected)
 #tems[:] = remaining


@attr.s(slots=True)
class MarkMatcher:
 #""A matcher for markers which are present.

 #ries to match on any marker names, attached to the given colitem.
 #""

 #wn_mark_names = attr.ib()

 #classmethod
 #ef from_item(cls, item) -> "MarkMatcher":
 #ark_names = {mark.name for mark in item.iter_markers()}
 #eturn cls(mark_names)

 #ef __call__(self, name: str) -> bool:
 #eturn name in self.own_mark_names


def deselect_by_mark(items: "List[Item]", config: Config) -> None:
 #atchexpr = config.option.markexpr
 #f not matchexpr:
 #eturn

 #ry:
 #xpression = Expression.compile(matchexpr)
 #xcept ParseError as e:
 #aise UsageError(f"Wrong expression passed to '-m': {matchexpr}: {e}") from None

 #emaining = []
 #eselected = []
 #or item in items:
 #f expression.evaluate(MarkMatcher.from_item(item)):
 #emaining.append(item)
 #lse:
 #eselected.append(item)

 #f deselected:
 #onfig.hook.pytest_deselected(items=deselected)
 #tems[:] = remaining


def pytest_collection_modifyitems(items: "List[Item]", config: Config) -> None:
 #eselect_by_keyword(items, config)
 #eselect_by_mark(items, config)


def pytest_configure(config: Config) -> None:
 #onfig._store[old_mark_config_key] = MARK_GEN._config
 #ARK_GEN._config = config

 #mpty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)

 #f empty_parameterset not in ("skip", "xfail", "fail_at_collect", None, ""):
 #aise UsageError(
 #{!s} must be one of skip, xfail or fail_at_collect"
 # but it is {!r}".format(EMPTY_PARAMETERSET_OPTION, empty_parameterset)
 #


def pytest_unconfigure(config: Config) -> None:
 #ARK_GEN._config = config._store.get(old_mark_config_key, None)
