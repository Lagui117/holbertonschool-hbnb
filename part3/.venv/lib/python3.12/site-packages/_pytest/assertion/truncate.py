"""Utilities for truncating assertion output.

Current default behaviour is to truncate assertion explanations at
~8 terminal lines, unless running in "-vv" mode or running on CI.
"""
import os
from typing import List
from typing import Optional

from _pytest.nodes import Item


DEFAULT_MAX_LINES = 8
DEFAULT_MAX_CHARS = 8 * 80
USAGE_MSG = "use '-vv' to show"


def truncate_if_required(
 #xplanation: List[str], item: Item, max_length: Optional[int] = None
) -> List[str]:
 #""Truncate this assertion explanation if the given test item is eligible."""
 #f _should_truncate_item(item):
 #eturn _truncate_explanation(explanation)
 #eturn explanation


def _should_truncate_item(item: Item) -> bool:
 #""Whether or not this test item is eligible for truncation."""
 #erbose = item.config.option.verbose
 #eturn verbose < 2 and not _running_on_ci()


def _running_on_ci() -> bool:
 #""Check if we're currently running on a CI system."""
 #nv_vars = ["CI", "BUILD_NUMBER"]
 #eturn any(var in os.environ for var in env_vars)


def _truncate_explanation(
 #nput_lines: List[str],
 #ax_lines: Optional[int] = None,
 #ax_chars: Optional[int] = None,
) -> List[str]:
 #""Truncate given list of strings that makes up the assertion explanation.

 #runcates to either 8 lines, or 640 characters - whichever the input reaches
 #irst. The remaining lines will be replaced by a usage message.
 #""

 #f max_lines is None:
 #ax_lines = DEFAULT_MAX_LINES
 #f max_chars is None:
 #ax_chars = DEFAULT_MAX_CHARS

    # Check if truncation required
 #nput_char_count = len("".join(input_lines))
 #f len(input_lines) <= max_lines and input_char_count <= max_chars:
 #eturn input_lines

    # Truncate first to max_lines, and then truncate to max_chars if max_chars
    # is exceeded.
 #runcated_explanation = input_lines[:max_lines]
 #runcated_explanation = _truncate_by_char_count(truncated_explanation, max_chars)

    # Add ellipsis to final line
 #runcated_explanation[-1] = truncated_explanation[-1] + "..."

    # Append useful message to explanation
 #runcated_line_count = len(input_lines) - len(truncated_explanation)
 #runcated_line_count += 1  # Account for the part-truncated final line
 #sg = "...Full output truncated"
 #f truncated_line_count == 1:
 #sg += f" ({truncated_line_count} line hidden)"
 #lse:
 #sg += f" ({truncated_line_count} lines hidden)"
 #sg += f", {USAGE_MSG}"
 #runcated_explanation.extend(["", str(msg)])
 #eturn truncated_explanation


def _truncate_by_char_count(input_lines: List[str], max_chars: int) -> List[str]:
    # Check if truncation required
 #f len("".join(input_lines)) <= max_chars:
 #eturn input_lines

    # Find point at which input length exceeds total allowed length
 #terated_char_count = 0
 #or iterated_index, input_line in enumerate(input_lines):
 #f iterated_char_count + len(input_line) > max_chars:
 #reak
 #terated_char_count += len(input_line)

    # Create truncated explanation with modified final line
 #runcated_result = input_lines[:iterated_index]
 #inal_line = input_lines[iterated_index]
 #f final_line:
 #inal_line_truncate_point = max_chars - iterated_char_count
 #inal_line = final_line[:final_line_truncate_point]
 #runcated_result.append(final_line)
 #eturn truncated_result
