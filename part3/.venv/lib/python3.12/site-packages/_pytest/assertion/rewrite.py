"""Rewrite assertion AST to produce nice error messages."""
import ast
import errno
import functools
import importlib.abc
import importlib.machinery
import importlib.util
import io
import itertools
import marshal
import os
import struct
import sys
import tokenize
import types
from pathlib import Path
from pathlib import PurePath
from typing import Callable
from typing import Dict
from typing import IO
from typing import Iterable
from typing import List
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

import py

from _pytest._io.saferepr import saferepr
from _pytest._version import version
from _pytest.assertion import util
from _pytest.assertion.util import (  # noqa: F401
 #ormat_explanation as _format_explanation,
)
from _pytest.config import Config
from _pytest.main import Session
from _pytest.pathlib import fnmatch_ex
from _pytest.store import StoreKey

if TYPE_CHECKING:
 #rom _pytest.assertion import AssertionState


assertstate_key = StoreKey["AssertionState"]()


# pytest caches rewritten pycs in pycache dirs
PYTEST_TAG = f"{sys.implementation.cache_tag}-pytest-{version}"
PYC_EXT = ".py" + (__debug__ and "c" or "o")
PYC_TAIL = "." + PYTEST_TAG + PYC_EXT


class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):
 #""PEP302/PEP451 import hook which rewrites asserts."""

 #ef __init__(self, config: Config) -> None:
 #elf.config = config
 #ry:
 #elf.fnpats = config.getini("python_files")
 #xcept ValueError:
 #elf.fnpats = ["test_*.py", "*_test.py"]
 #elf.session: Optional[Session] = None
 #elf._rewritten_names: Set[str] = set()
 #elf._must_rewrite: Set[str] = set()
        # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,
        # which might result in infinite recursion (#3506)
 #elf._writing_pyc = False
 #elf._basenames_to_check_rewrite = {"conftest"}
 #elf._marked_for_rewrite_cache: Dict[str, bool] = {}
 #elf._session_paths_checked = False

 #ef set_session(self, session: Optional[Session]) -> None:
 #elf.session = session
 #elf._session_paths_checked = False

    # Indirection so we can mock calls to find_spec originated from the hook during testing
 #find_spec = importlib.machinery.PathFinder.find_spec

 #ef find_spec(
 #elf,
 #ame: str,
 #ath: Optional[Sequence[Union[str, bytes]]] = None,
 #arget: Optional[types.ModuleType] = None,
 # -> Optional[importlib.machinery.ModuleSpec]:
 #f self._writing_pyc:
 #eturn None
 #tate = self.config._store[assertstate_key]
 #f self._early_rewrite_bailout(name, state):
 #eturn None
 #tate.trace("find_module called for: %s" % name)

        # Type ignored because mypy is confused about the `self` binding here.
 #pec = self._find_spec(name, path)  # type: ignore
 #f (
            # the import machinery could not find a file to import
 #pec is None
            # this is a namespace package (without `__init__.py`)
            # there's nothing to rewrite there
            # python3.6: `namespace`
            # python3.7+: `None`
 #r spec.origin == "namespace"
 #r spec.origin is None
            # we can only rewrite source files
 #r not isinstance(spec.loader, importlib.machinery.SourceFileLoader)
            # if the file doesn't exist, we can't rewrite it
 #r not os.path.exists(spec.origin)
 #:
 #eturn None
 #lse:
 #n = spec.origin

 #f not self._should_rewrite(name, fn, state):
 #eturn None

 #eturn importlib.util.spec_from_file_location(
 #ame,
 #n,
 #oader=self,
 #ubmodule_search_locations=spec.submodule_search_locations,
 #

 #ef create_module(
 #elf, spec: importlib.machinery.ModuleSpec
 # -> Optional[types.ModuleType]:
 #eturn None  # default behaviour is fine

 #ef exec_module(self, module: types.ModuleType) -> None:
 #ssert module.__spec__ is not None
 #ssert module.__spec__.origin is not None
 #n = Path(module.__spec__.origin)
 #tate = self.config._store[assertstate_key]

 #elf._rewritten_names.add(module.__name__)

        # The requested module looks like a test file, so rewrite it. This is
        # the most magical part of the process: load the source, rewrite the
        # asserts, and load the rewritten source. We also cache the rewritten
        # module code in a special pyc. We must be aware of the possibility of
        # concurrent pytest processes rewriting and loading pycs. To avoid
        # tricky race conditions, we maintain the following invariant: The
        # cached pyc is always a complete, valid pyc. Operations on it must be
        # atomic. POSIX's atomic rename comes in handy.
 #rite = not sys.dont_write_bytecode
 #ache_dir = get_cache_dir(fn)
 #f write:
 #k = try_makedirs(cache_dir)
 #f not ok:
 #rite = False
 #tate.trace(f"read only directory: {cache_dir}")

 #ache_name = fn.name[:-3] + PYC_TAIL
 #yc = cache_dir / cache_name
        # Notice that even if we're in a read-only directory, I'm going
        # to check for a cached pyc. This may not be optimal...
 #o = _read_pyc(fn, pyc, state.trace)
 #f co is None:
 #tate.trace(f"rewriting {fn!r}")
 #ource_stat, co = _rewrite_test(fn, self.config)
 #f write:
 #elf._writing_pyc = True
 #ry:
 #write_pyc(state, co, source_stat, pyc)
 #inally:
 #elf._writing_pyc = False
 #lse:
 #tate.trace(f"found cached rewritten pyc for {fn}")
 #xec(co, module.__dict__)

 #ef _early_rewrite_bailout(self, name: str, state: "AssertionState") -> bool:
 #""A fast way to get out of rewriting modules.

 #rofiling has shown that the call to PathFinder.find_spec (inside of
 #he find_spec from this class) is a major slowdown, so, this method
 #ries to filter what we're sure won't be rewritten before getting to
 #t.
 #""
 #f self.session is not None and not self._session_paths_checked:
 #elf._session_paths_checked = True
 #or initial_path in self.session._initialpaths:
                # Make something as c:/projects/my_project/path.py ->
                #     ['c:', 'projects', 'my_project', 'path.py']
 #arts = str(initial_path).split(os.path.sep)
                # add 'path' to basenames to be checked.
 #elf._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])

        # Note: conftest already by default in _basenames_to_check_rewrite.
 #arts = name.split(".")
 #f parts[-1] in self._basenames_to_check_rewrite:
 #eturn False

        # For matching the name it must be as if it was a filename.
 #ath = PurePath(os.path.sep.join(parts) + ".py")

 #or pat in self.fnpats:
            # if the pattern contains subdirectories ("tests/**.py" for example) we can't bail out based
            # on the name alone because we need to match against the full path
 #f os.path.dirname(pat):
 #eturn False
 #f fnmatch_ex(pat, path):
 #eturn False

 #f self._is_marked_for_rewrite(name, state):
 #eturn False

 #tate.trace(f"early skip of rewriting module: {name}")
 #eturn True

 #ef _should_rewrite(self, name: str, fn: str, state: "AssertionState") -> bool:
        # always rewrite conftest files
 #f os.path.basename(fn) == "conftest.py":
 #tate.trace(f"rewriting conftest file: {fn!r}")
 #eturn True

 #f self.session is not None:
 #f self.session.isinitpath(py.path.local(fn)):
 #tate.trace(f"matched test file (was specified on cmdline): {fn!r}")
 #eturn True

        # modules not passed explicitly on the command line are only
        # rewritten if they match the naming convention for test files
 #n_path = PurePath(fn)
 #or pat in self.fnpats:
 #f fnmatch_ex(pat, fn_path):
 #tate.trace(f"matched test file {fn!r}")
 #eturn True

 #eturn self._is_marked_for_rewrite(name, state)

 #ef _is_marked_for_rewrite(self, name: str, state: "AssertionState") -> bool:
 #ry:
 #eturn self._marked_for_rewrite_cache[name]
 #xcept KeyError:
 #or marked in self._must_rewrite:
 #f name == marked or name.startswith(marked + "."):
 #tate.trace(f"matched marked file {name!r} (from {marked!r})")
 #elf._marked_for_rewrite_cache[name] = True
 #eturn True

 #elf._marked_for_rewrite_cache[name] = False
 #eturn False

 #ef mark_rewrite(self, *names: str) -> None:
 #""Mark import names as needing to be rewritten.

 #he named module or package as well as any nested modules will
 #e rewritten on import.
 #""
 #lready_imported = (
 #et(names).intersection(sys.modules).difference(self._rewritten_names)
 #
 #or name in already_imported:
 #od = sys.modules[name]
 #f not AssertionRewriter.is_rewrite_disabled(
 #od.__doc__ or ""
 # and not isinstance(mod.__loader__, type(self)):
 #elf._warn_already_imported(name)
 #elf._must_rewrite.update(names)
 #elf._marked_for_rewrite_cache.clear()

 #ef _warn_already_imported(self, name: str) -> None:
 #rom _pytest.warning_types import PytestAssertRewriteWarning

 #elf.config.issue_config_time_warning(
 #ytestAssertRewriteWarning(
 #Module already imported so cannot be rewritten: %s" % name
 #,
 #tacklevel=5,
 #

 #ef get_data(self, pathname: Union[str, bytes]) -> bytes:
 #""Optional PEP302 get_data API."""
 #ith open(pathname, "rb") as f:
 #eturn f.read()


def _write_pyc_fp(
 #p: IO[bytes], source_stat: os.stat_result, co: types.CodeType
) -> None:
    # Technically, we don't have to have the same pyc format as
    # (C)Python, since these "pycs" should never be seen by builtin
    # import. However, there's little reason to deviate.
 #p.write(importlib.util.MAGIC_NUMBER)
    # https://www.python.org/dev/peps/pep-0552/
 #f sys.version_info >= (3, 7):
 #lags = b"\x00\x00\x00\x00"
 #p.write(flags)
    # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)
 #time = int(source_stat.st_mtime) & 0xFFFFFFFF
 #ize = source_stat.st_size & 0xFFFFFFFF
    # "<LL" stands for 2 unsigned longs, little-endian.
 #p.write(struct.pack("<LL", mtime, size))
 #p.write(marshal.dumps(co))


if sys.platform == "win32":
 #rom atomicwrites import atomic_write

 #ef _write_pyc(
 #tate: "AssertionState",
 #o: types.CodeType,
 #ource_stat: os.stat_result,
 #yc: Path,
 # -> bool:
 #ry:
 #ith atomic_write(os.fspath(pyc), mode="wb", overwrite=True) as fp:
 #write_pyc_fp(fp, source_stat, co)
 #xcept OSError as e:
 #tate.trace(f"error writing pyc file at {pyc}: {e}")
            # we ignore any failure to write the cache file
            # there are many reasons, permission-denied, pycache dir being a
            # file etc.
 #eturn False
 #eturn True


else:

 #ef _write_pyc(
 #tate: "AssertionState",
 #o: types.CodeType,
 #ource_stat: os.stat_result,
 #yc: Path,
 # -> bool:
 #roc_pyc = f"{pyc}.{os.getpid()}"
 #ry:
 #p = open(proc_pyc, "wb")
 #xcept OSError as e:
 #tate.trace(f"error writing pyc file at {proc_pyc}: errno={e.errno}")
 #eturn False

 #ry:
 #write_pyc_fp(fp, source_stat, co)
 #s.rename(proc_pyc, os.fspath(pyc))
 #xcept OSError as e:
 #tate.trace(f"error writing pyc file at {pyc}: {e}")
            # we ignore any failure to write the cache file
            # there are many reasons, permission-denied, pycache dir being a
            # file etc.
 #eturn False
 #inally:
 #p.close()
 #eturn True


def _rewrite_test(fn: Path, config: Config) -> Tuple[os.stat_result, types.CodeType]:
 #""Read and rewrite *fn* and return the code object."""
 #n_ = os.fspath(fn)
 #tat = os.stat(fn_)
 #ith open(fn_, "rb") as f:
 #ource = f.read()
 #ree = ast.parse(source, filename=fn_)
 #ewrite_asserts(tree, source, fn_, config)
 #o = compile(tree, fn_, "exec", dont_inherit=True)
 #eturn stat, co


def _read_pyc(
 #ource: Path, pyc: Path, trace: Callable[[str], None] = lambda x: None
) -> Optional[types.CodeType]:
 #""Possibly read a pytest pyc containing rewritten code.

 #eturn rewritten code if successful or None if not.
 #""
 #ry:
 #p = open(os.fspath(pyc), "rb")
 #xcept OSError:
 #eturn None
 #ith fp:
        # https://www.python.org/dev/peps/pep-0552/
 #as_flags = sys.version_info >= (3, 7)
 #ry:
 #tat_result = os.stat(os.fspath(source))
 #time = int(stat_result.st_mtime)
 #ize = stat_result.st_size
 #ata = fp.read(16 if has_flags else 12)
 #xcept OSError as e:
 #race(f"_read_pyc({source}): OSError {e}")
 #eturn None
        # Check for invalid or out of date pyc file.
 #f len(data) != (16 if has_flags else 12):
 #race("_read_pyc(%s): invalid pyc (too short)" % source)
 #eturn None
 #f data[:4] != importlib.util.MAGIC_NUMBER:
 #race("_read_pyc(%s): invalid pyc (bad magic number)" % source)
 #eturn None
 #f has_flags and data[4:8] != b"\x00\x00\x00\x00":
 #race("_read_pyc(%s): invalid pyc (unsupported flags)" % source)
 #eturn None
 #time_data = data[8 if has_flags else 4 : 12 if has_flags else 8]
 #f int.from_bytes(mtime_data, "little") != mtime & 0xFFFFFFFF:
 #race("_read_pyc(%s): out of date" % source)
 #eturn None
 #ize_data = data[12 if has_flags else 8 : 16 if has_flags else 12]
 #f int.from_bytes(size_data, "little") != size & 0xFFFFFFFF:
 #race("_read_pyc(%s): invalid pyc (incorrect size)" % source)
 #eturn None
 #ry:
 #o = marshal.load(fp)
 #xcept Exception as e:
 #race(f"_read_pyc({source}): marshal.load error {e}")
 #eturn None
 #f not isinstance(co, types.CodeType):
 #race("_read_pyc(%s): not a code object" % source)
 #eturn None
 #eturn co


def rewrite_asserts(
 #od: ast.Module,
 #ource: bytes,
 #odule_path: Optional[str] = None,
 #onfig: Optional[Config] = None,
) -> None:
 #""Rewrite the assert statements in mod."""
 #ssertionRewriter(module_path, config, source).run(mod)


def _saferepr(obj: object) -> str:
 #"""Get a safe repr of an object for assertion error messages.

 #he assertion formatting (util.format_explanation()) requires
 #ewlines to be escaped since they are a special character for it.
 #ormally assertion.util.format_explanation() does this but for a
 #ustom repr it is possible to contain one of the special escape
 #equences, especially '\n{' and '\n}' are likely to be present in
 #SON reprs.
 #""
 #eturn saferepr(obj).replace("\n", "\\n")


def _format_assertmsg(obj: object) -> str:
 #"""Format the custom assertion message given.

 #or strings this simply replaces newlines with '\n~' so that
 #til.format_explanation() will preserve them instead of escaping
 #ewlines.  For other objects saferepr() is used first.
 #""
    # reprlib appears to have a bug which means that if a string
    # contains a newline it gets escaped, however if an object has a
    # .__repr__() which contains newlines it does not get escaped.
    # However in either case we want to preserve the newline.
 #eplaces = [("\n", "\n~"), ("%", "%%")]
 #f not isinstance(obj, str):
 #bj = saferepr(obj)
 #eplaces.append(("\\n", "\n~"))

 #or r1, r2 in replaces:
 #bj = obj.replace(r1, r2)

 #eturn obj


def _should_repr_global_name(obj: object) -> bool:
 #f callable(obj):
 #eturn False

 #ry:
 #eturn not hasattr(obj, "__name__")
 #xcept Exception:
 #eturn True


def _format_boolop(explanations: Iterable[str], is_or: bool) -> str:
 #xplanation = "(" + (is_or and " or " or " and ").join(explanations) + ")"
 #eturn explanation.replace("%", "%%")


def _call_reprcompare(
 #ps: Sequence[str],
 #esults: Sequence[bool],
 #xpls: Sequence[str],
 #ach_obj: Sequence[object],
) -> str:
 #or i, res, expl in zip(range(len(ops)), results, expls):
 #ry:
 #one = not res
 #xcept Exception:
 #one = True
 #f done:
 #reak
 #f util._reprcompare is not None:
 #ustom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])
 #f custom is not None:
 #eturn custom
 #eturn expl


def _call_assertion_pass(lineno: int, orig: str, expl: str) -> None:
 #f util._assertion_pass is not None:
 #til._assertion_pass(lineno, orig, expl)


def _check_if_assertion_pass_impl() -> bool:
 #""Check if any plugins implement the pytest_assertion_pass hook
 #n order not to generate explanation unecessarily (might be expensive)."""
 #eturn True if util._assertion_pass else False


UNARY_MAP = {ast.Not: "not %s", ast.Invert: "~%s", ast.USub: "-%s", ast.UAdd: "+%s"}

BINOP_MAP = {
 #st.BitOr: "|",
 #st.BitXor: "^",
 #st.BitAnd: "&",
 #st.LShift: "<<",
 #st.RShift: ">>",
 #st.Add: "+",
 #st.Sub: "-",
 #st.Mult: "*",
 #st.Div: "/",
 #st.FloorDiv: "//",
 #st.Mod: "%%",  # escaped for string formatting
 #st.Eq: "==",
 #st.NotEq: "!=",
 #st.Lt: "<",
 #st.LtE: "<=",
 #st.Gt: ">",
 #st.GtE: ">=",
 #st.Pow: "**",
 #st.Is: "is",
 #st.IsNot: "is not",
 #st.In: "in",
 #st.NotIn: "not in",
 #st.MatMult: "@",
}


def set_location(node, lineno, col_offset):
 #""Set node location information recursively."""

 #ef _fix(node, lineno, col_offset):
 #f "lineno" in node._attributes:
 #ode.lineno = lineno
 #f "col_offset" in node._attributes:
 #ode.col_offset = col_offset
 #or child in ast.iter_child_nodes(node):
 #fix(child, lineno, col_offset)

 #fix(node, lineno, col_offset)
 #eturn node


def _get_assertion_exprs(src: bytes) -> Dict[int, str]:
 #""Return a mapping from {lineno: "assertion test expression"}."""
 #et: Dict[int, str] = {}

 #epth = 0
 #ines: List[str] = []
 #ssert_lineno: Optional[int] = None
 #een_lines: Set[int] = set()

 #ef _write_and_reset() -> None:
 #onlocal depth, lines, assert_lineno, seen_lines
 #ssert assert_lineno is not None
 #et[assert_lineno] = "".join(lines).rstrip().rstrip("\\")
 #epth = 0
 #ines = []
 #ssert_lineno = None
 #een_lines = set()

 #okens = tokenize.tokenize(io.BytesIO(src).readline)
 #or tp, source, (lineno, offset), _, line in tokens:
 #f tp == tokenize.NAME and source == "assert":
 #ssert_lineno = lineno
 #lif assert_lineno is not None:
            # keep track of depth for the assert-message `,` lookup
 #f tp == tokenize.OP and source in "([{":
 #epth += 1
 #lif tp == tokenize.OP and source in ")]}":
 #epth -= 1

 #f not lines:
 #ines.append(line[offset:])
 #een_lines.add(lineno)
            # a non-nested comma separates the expression from the message
 #lif depth == 0 and tp == tokenize.OP and source == ",":
                # one line assert with message
 #f lineno in seen_lines and len(lines) == 1:
 #ffset_in_trimmed = offset + len(lines[-1]) - len(line)
 #ines[-1] = lines[-1][:offset_in_trimmed]
                # multi-line assert with message
 #lif lineno in seen_lines:
 #ines[-1] = lines[-1][:offset]
                # multi line assert with escapd newline before message
 #lse:
 #ines.append(line[:offset])
 #write_and_reset()
 #lif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:
 #write_and_reset()
 #lif lines and lineno not in seen_lines:
 #ines.append(line)
 #een_lines.add(lineno)

 #eturn ret


class AssertionRewriter(ast.NodeVisitor):
 #""Assertion rewriting implementation.

 #he main entrypoint is to call .run() with an ast.Module instance,
 #his will then find all the assert statements and rewrite them to
 #rovide intermediate values and a detailed assertion error.  See
 #ttp://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html
 #or an overview of how this works.

 #he entry point here is .run() which will iterate over all the
 #tatements in an ast.Module and for each ast.Assert statement it
 #inds call .visit() with it.  Then .visit_Assert() takes over and
 #s responsible for creating new ast statements to replace the
 #riginal assert statement: it rewrites the test of an assertion
 #o provide intermediate values and replace it with an if statement
 #hich raises an assertion error with a detailed explanation in
 #ase the expression is false and calls pytest_assertion_pass hook
 #f expression is true.

 #or this .visit_Assert() uses the visitor pattern to visit all the
 #ST nodes of the ast.Assert.test field, each visit call returning
 #n AST node and the corresponding explanation string.  During this
 #tate is kept in several instance attributes:

 #statements: All the AST statements which will replace the assert
 #tatement.

 #variables: This is populated by .variable() with each variable
 #sed by the statements so that they can all be set to None at
 #he end of the statements.

 #variable_counter: Counter to create new unique variables needed
 #y statements.  Variables are created using .variable() and
 #ave the form of "@py_assert0".

 #expl_stmts: The AST statements which will be executed to get
 #ata from the assertion.  This is the code which will construct
 #he detailed assertion message that is used in the AssertionError
 #r for the pytest_assertion_pass hook.

 #explanation_specifiers: A dict filled by .explanation_param()
 #ith %-formatting placeholders and their corresponding
 #xpressions to use in the building of an assertion message.
 #his is used by .pop_format_context() to build a message.

 #stack: A stack of the explanation_specifiers dicts maintained by
 #push_format_context() and .pop_format_context() which allows
 #o build another %-formatted string while already building one.

 #his state is reset on every new assert statement visited and used
 #y the other visitors.
 #""

 #ef __init__(
 #elf, module_path: Optional[str], config: Optional[Config], source: bytes
 # -> None:
 #uper().__init__()
 #elf.module_path = module_path
 #elf.config = config
 #f config is not None:
 #elf.enable_assertion_pass_hook = config.getini(
 #enable_assertion_pass_hook"
 #
 #lse:
 #elf.enable_assertion_pass_hook = False
 #elf.source = source

 #functools.lru_cache(maxsize=1)
 #ef _assert_expr_to_lineno(self) -> Dict[int, str]:
 #eturn _get_assertion_exprs(self.source)

 #ef run(self, mod: ast.Module) -> None:
 #""Find all assert statements in *mod* and rewrite them."""
 #f not mod.body:
            # Nothing to do.
 #eturn

        # We'll insert some special imports at the top of the module, but after any
        # docstrings and __future__ imports, so first figure out where that is.
 #oc = getattr(mod, "docstring", None)
 #xpect_docstring = doc is None
 #f doc is not None and self.is_rewrite_disabled(doc):
 #eturn
 #os = 0
 #ineno = 1
 #or item in mod.body:
 #f (
 #xpect_docstring
 #nd isinstance(item, ast.Expr)
 #nd isinstance(item.value, ast.Str)
 #:
 #oc = item.value.s
 #f self.is_rewrite_disabled(doc):
 #eturn
 #xpect_docstring = False
 #lif (
 #sinstance(item, ast.ImportFrom)
 #nd item.level == 0
 #nd item.module == "__future__"
 #:
 #ass
 #lse:
 #reak
 #os += 1
        # Special case: for a decorated function, set the lineno to that of the
        # first decorator, not the `def`. Issue #4984.
 #f isinstance(item, ast.FunctionDef) and item.decorator_list:
 #ineno = item.decorator_list[0].lineno
 #lse:
 #ineno = item.lineno
        # Now actually insert the special imports.
 #f sys.version_info >= (3, 10):
 #liases = [
 #st.alias("builtins", "@py_builtins", lineno=lineno, col_offset=0),
 #st.alias(
 #_pytest.assertion.rewrite",
 #@pytest_ar",
 #ineno=lineno,
 #ol_offset=0,
 #,
 #
 #lse:
 #liases = [
 #st.alias("builtins", "@py_builtins"),
 #st.alias("_pytest.assertion.rewrite", "@pytest_ar"),
 #
 #mports = [
 #st.Import([alias], lineno=lineno, col_offset=0) for alias in aliases
 #
 #od.body[pos:pos] = imports

        # Collect asserts.
 #odes: List[ast.AST] = [mod]
 #hile nodes:
 #ode = nodes.pop()
 #or name, field in ast.iter_fields(node):
 #f isinstance(field, list):
 #ew: List[ast.AST] = []
 #or i, child in enumerate(field):
 #f isinstance(child, ast.Assert):
                            # Transform assert.
 #ew.extend(self.visit(child))
 #lse:
 #ew.append(child)
 #f isinstance(child, ast.AST):
 #odes.append(child)
 #etattr(node, name, new)
 #lif (
 #sinstance(field, ast.AST)
                    # Don't recurse into expressions as they can't contain
                    # asserts.
 #nd not isinstance(field, ast.expr)
 #:
 #odes.append(field)

 #staticmethod
 #ef is_rewrite_disabled(docstring: str) -> bool:
 #eturn "PYTEST_DONT_REWRITE" in docstring

 #ef variable(self) -> str:
 #""Get a new variable."""
        # Use a character invalid in python identifiers to avoid clashing.
 #ame = "@py_assert" + str(next(self.variable_counter))
 #elf.variables.append(name)
 #eturn name

 #ef assign(self, expr: ast.expr) -> ast.Name:
 #""Give *expr* a name."""
 #ame = self.variable()
 #elf.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))
 #eturn ast.Name(name, ast.Load())

 #ef display(self, expr: ast.expr) -> ast.expr:
 #""Call saferepr on the expression."""
 #eturn self.helper("_saferepr", expr)

 #ef helper(self, name: str, *args: ast.expr) -> ast.expr:
 #""Call a helper in this module."""
 #y_name = ast.Name("@pytest_ar", ast.Load())
 #ttr = ast.Attribute(py_name, name, ast.Load())
 #eturn ast.Call(attr, list(args), [])

 #ef builtin(self, name: str) -> ast.Attribute:
 #""Return the builtin called *name*."""
 #uiltin_name = ast.Name("@py_builtins", ast.Load())
 #eturn ast.Attribute(builtin_name, name, ast.Load())

 #ef explanation_param(self, expr: ast.expr) -> str:
 #""Return a new named %-formatting placeholder for expr.

 #his creates a %-formatting placeholder for expr in the
 #urrent formatting context, e.g. ``%(py0)s``.  The placeholder
 #nd expr are placed in the current format context so that it
 #an be used on the next call to .pop_format_context().
 #""
 #pecifier = "py" + str(next(self.variable_counter))
 #elf.explanation_specifiers[specifier] = expr
 #eturn "%(" + specifier + ")s"

 #ef push_format_context(self) -> None:
 #""Create a new formatting context.

 #he format context is used for when an explanation wants to
 #ave a variable value formatted in the assertion message.  In
 #his case the value required can be added using
 #explanation_param().  Finally .pop_format_context() is used
 #o format a string of %-formatted values as added by
 #explanation_param().
 #""
 #elf.explanation_specifiers: Dict[str, ast.expr] = {}
 #elf.stack.append(self.explanation_specifiers)

 #ef pop_format_context(self, expl_expr: ast.expr) -> ast.Name:
 #""Format the %-formatted string with current format context.

 #he expl_expr should be an str ast.expr instance constructed from
 #he %-placeholders created by .explanation_param().  This will
 #dd the required code to format said string to .expl_stmts and
 #eturn the ast.Name instance of the formatted string.
 #""
 #urrent = self.stack.pop()
 #f self.stack:
 #elf.explanation_specifiers = self.stack[-1]
 #eys = [ast.Str(key) for key in current.keys()]
 #ormat_dict = ast.Dict(keys, list(current.values()))
 #orm = ast.BinOp(expl_expr, ast.Mod(), format_dict)
 #ame = "@py_format" + str(next(self.variable_counter))
 #f self.enable_assertion_pass_hook:
 #elf.format_variables.append(name)
 #elf.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))
 #eturn ast.Name(name, ast.Load())

 #ef generic_visit(self, node: ast.AST) -> Tuple[ast.Name, str]:
 #""Handle expressions we don't have custom code for."""
 #ssert isinstance(node, ast.expr)
 #es = self.assign(node)
 #eturn res, self.explanation_param(self.display(res))

 #ef visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:
 #""Return the AST statements to replace the ast.Assert instance.

 #his rewrites the test of an assertion to provide
 #ntermediate values and replace it with an if statement which
 #aises an assertion error with a detailed explanation in case
 #he expression is false.
 #""
 #f isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:
 #rom _pytest.warning_types import PytestAssertRewriteWarning
 #mport warnings

            # TODO: This assert should not be needed.
 #ssert self.module_path is not None
 #arnings.warn_explicit(
 #ytestAssertRewriteWarning(
 #assertion is always true, perhaps remove parentheses?"
 #,
 #ategory=None,
 #ilename=os.fspath(self.module_path),
 #ineno=assert_.lineno,
 #

 #elf.statements: List[ast.stmt] = []
 #elf.variables: List[str] = []
 #elf.variable_counter = itertools.count()

 #f self.enable_assertion_pass_hook:
 #elf.format_variables: List[str] = []

 #elf.stack: List[Dict[str, ast.expr]] = []
 #elf.expl_stmts: List[ast.stmt] = []
 #elf.push_format_context()
        # Rewrite assert into a bunch of statements.
 #op_condition, explanation = self.visit(assert_.test)

 #egation = ast.UnaryOp(ast.Not(), top_condition)

 #f self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook
 #sg = self.pop_format_context(ast.Str(explanation))

            # Failed
 #f assert_.msg:
 #ssertmsg = self.helper("_format_assertmsg", assert_.msg)
 #luestr = "\n>assert "
 #lse:
 #ssertmsg = ast.Str("")
 #luestr = "assert "
 #rr_explanation = ast.BinOp(ast.Str(gluestr), ast.Add(), msg)
 #rr_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)
 #rr_name = ast.Name("AssertionError", ast.Load())
 #mt = self.helper("_format_explanation", err_msg)
 #xc = ast.Call(err_name, [fmt], [])
 #aise_ = ast.Raise(exc, None)
 #tatements_fail = []
 #tatements_fail.extend(self.expl_stmts)
 #tatements_fail.append(raise_)

            # Passed
 #mt_pass = self.helper("_format_explanation", msg)
 #rig = self._assert_expr_to_lineno()[assert_.lineno]
 #ook_call_pass = ast.Expr(
 #elf.helper(
 #_call_assertion_pass",
 #st.Num(assert_.lineno),
 #st.Str(orig),
 #mt_pass,
 #
 #
            # If any hooks implement assert_pass hook
 #ook_impl_test = ast.If(
 #elf.helper("_check_if_assertion_pass_impl"),
 #elf.expl_stmts + [hook_call_pass],
 #],
 #
 #tatements_pass = [hook_impl_test]

            # Test for assertion condition
 #ain_test = ast.If(negation, statements_fail, statements_pass)
 #elf.statements.append(main_test)
 #f self.format_variables:
 #ariables = [
 #st.Name(name, ast.Store()) for name in self.format_variables
 #
 #lear_format = ast.Assign(variables, ast.NameConstant(None))
 #elf.statements.append(clear_format)

 #lse:  # Original assertion rewriting
            # Create failure message.
 #ody = self.expl_stmts
 #elf.statements.append(ast.If(negation, body, []))
 #f assert_.msg:
 #ssertmsg = self.helper("_format_assertmsg", assert_.msg)
 #xplanation = "\n>assert " + explanation
 #lse:
 #ssertmsg = ast.Str("")
 #xplanation = "assert " + explanation
 #emplate = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))
 #sg = self.pop_format_context(template)
 #mt = self.helper("_format_explanation", msg)
 #rr_name = ast.Name("AssertionError", ast.Load())
 #xc = ast.Call(err_name, [fmt], [])
 #aise_ = ast.Raise(exc, None)

 #ody.append(raise_)

        # Clear temporary variables by setting them to None.
 #f self.variables:
 #ariables = [ast.Name(name, ast.Store()) for name in self.variables]
 #lear = ast.Assign(variables, ast.NameConstant(None))
 #elf.statements.append(clear)
        # Fix line numbers.
 #or stmt in self.statements:
 #et_location(stmt, assert_.lineno, assert_.col_offset)
 #eturn self.statements

 #ef visit_Name(self, name: ast.Name) -> Tuple[ast.Name, str]:
        # Display the repr of the name if it's a local variable or
        # _should_repr_global_name() thinks it's acceptable.
 #ocs = ast.Call(self.builtin("locals"), [], [])
 #nlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])
 #orepr = self.helper("_should_repr_global_name", name)
 #est = ast.BoolOp(ast.Or(), [inlocs, dorepr])
 #xpr = ast.IfExp(test, self.display(name), ast.Str(name.id))
 #eturn name, self.explanation_param(expr)

 #ef visit_BoolOp(self, boolop: ast.BoolOp) -> Tuple[ast.Name, str]:
 #es_var = self.variable()
 #xpl_list = self.assign(ast.List([], ast.Load()))
 #pp = ast.Attribute(expl_list, "append", ast.Load())
 #s_or = int(isinstance(boolop.op, ast.Or))
 #ody = save = self.statements
 #ail_save = self.expl_stmts
 #evels = len(boolop.values) - 1
 #elf.push_format_context()
        # Process each operand, short-circuiting if needed.
 #or i, v in enumerate(boolop.values):
 #f i:
 #ail_inner: List[ast.stmt] = []
                # cond is set in a prior loop iteration below
 #elf.expl_stmts.append(ast.If(cond, fail_inner, []))  # noqa
 #elf.expl_stmts = fail_inner
 #elf.push_format_context()
 #es, expl = self.visit(v)
 #ody.append(ast.Assign([ast.Name(res_var, ast.Store())], res))
 #xpl_format = self.pop_format_context(ast.Str(expl))
 #all = ast.Call(app, [expl_format], [])
 #elf.expl_stmts.append(ast.Expr(call))
 #f i < levels:
 #ond: ast.expr = res
 #f is_or:
 #ond = ast.UnaryOp(ast.Not(), cond)
 #nner: List[ast.stmt] = []
 #elf.statements.append(ast.If(cond, inner, []))
 #elf.statements = body = inner
 #elf.statements = save
 #elf.expl_stmts = fail_save
 #xpl_template = self.helper("_format_boolop", expl_list, ast.Num(is_or))
 #xpl = self.pop_format_context(expl_template)
 #eturn ast.Name(res_var, ast.Load()), self.explanation_param(expl)

 #ef visit_UnaryOp(self, unary: ast.UnaryOp) -> Tuple[ast.Name, str]:
 #attern = UNARY_MAP[unary.op.__class__]
 #perand_res, operand_expl = self.visit(unary.operand)
 #es = self.assign(ast.UnaryOp(unary.op, operand_res))
 #eturn res, pattern % (operand_expl,)

 #ef visit_BinOp(self, binop: ast.BinOp) -> Tuple[ast.Name, str]:
 #ymbol = BINOP_MAP[binop.op.__class__]
 #eft_expr, left_expl = self.visit(binop.left)
 #ight_expr, right_expl = self.visit(binop.right)
 #xplanation = f"({left_expl} {symbol} {right_expl})"
 #es = self.assign(ast.BinOp(left_expr, binop.op, right_expr))
 #eturn res, explanation

 #ef visit_Call(self, call: ast.Call) -> Tuple[ast.Name, str]:
 #ew_func, func_expl = self.visit(call.func)
 #rg_expls = []
 #ew_args = []
 #ew_kwargs = []
 #or arg in call.args:
 #es, expl = self.visit(arg)
 #rg_expls.append(expl)
 #ew_args.append(res)
 #or keyword in call.keywords:
 #es, expl = self.visit(keyword.value)
 #ew_kwargs.append(ast.keyword(keyword.arg, res))
 #f keyword.arg:
 #rg_expls.append(keyword.arg + "=" + expl)
 #lse:  # **args have `arg` keywords with an .arg of None
 #rg_expls.append("**" + expl)

 #xpl = "{}({})".format(func_expl, ", ".join(arg_expls))
 #ew_call = ast.Call(new_func, new_args, new_kwargs)
 #es = self.assign(new_call)
 #es_expl = self.explanation_param(self.display(res))
 #uter_expl = f"{res_expl}\n{{{res_expl} = {expl}\n}}"
 #eturn res, outer_expl

 #ef visit_Starred(self, starred: ast.Starred) -> Tuple[ast.Starred, str]:
        # A Starred node can appear in a function call.
 #es, expl = self.visit(starred.value)
 #ew_starred = ast.Starred(res, starred.ctx)
 #eturn new_starred, "*" + expl

 #ef visit_Attribute(self, attr: ast.Attribute) -> Tuple[ast.Name, str]:
 #f not isinstance(attr.ctx, ast.Load):
 #eturn self.generic_visit(attr)
 #alue, value_expl = self.visit(attr.value)
 #es = self.assign(ast.Attribute(value, attr.attr, ast.Load()))
 #es_expl = self.explanation_param(self.display(res))
 #at = "%s\n{%s = %s.%s\n}"
 #xpl = pat % (res_expl, res_expl, value_expl, attr.attr)
 #eturn res, expl

 #ef visit_Compare(self, comp: ast.Compare) -> Tuple[ast.expr, str]:
 #elf.push_format_context()
 #eft_res, left_expl = self.visit(comp.left)
 #f isinstance(comp.left, (ast.Compare, ast.BoolOp)):
 #eft_expl = f"({left_expl})"
 #es_variables = [self.variable() for i in range(len(comp.ops))]
 #oad_names = [ast.Name(v, ast.Load()) for v in res_variables]
 #tore_names = [ast.Name(v, ast.Store()) for v in res_variables]
 #t = zip(range(len(comp.ops)), comp.ops, comp.comparators)
 #xpls = []
 #yms = []
 #esults = [left_res]
 #or i, op, next_operand in it:
 #ext_res, next_expl = self.visit(next_operand)
 #f isinstance(next_operand, (ast.Compare, ast.BoolOp)):
 #ext_expl = f"({next_expl})"
 #esults.append(next_res)
 #ym = BINOP_MAP[op.__class__]
 #yms.append(ast.Str(sym))
 #xpl = f"{left_expl} {sym} {next_expl}"
 #xpls.append(ast.Str(expl))
 #es_expr = ast.Compare(left_res, [op], [next_res])
 #elf.statements.append(ast.Assign([store_names[i]], res_expr))
 #eft_res, left_expl = next_res, next_expl
        # Use pytest.assertion.util._reprcompare if that's available.
 #xpl_call = self.helper(
 #_call_reprcompare",
 #st.Tuple(syms, ast.Load()),
 #st.Tuple(load_names, ast.Load()),
 #st.Tuple(expls, ast.Load()),
 #st.Tuple(results, ast.Load()),
 #
 #f len(comp.ops) > 1:
 #es: ast.expr = ast.BoolOp(ast.And(), load_names)
 #lse:
 #es = load_names[0]
 #eturn res, self.explanation_param(self.pop_format_context(expl_call))


def try_makedirs(cache_dir: Path) -> bool:
 #""Attempt to create the given directory and sub-directories exist.

 #eturns True if successful or if it already exists.
 #""
 #ry:
 #s.makedirs(os.fspath(cache_dir), exist_ok=True)
 #xcept (FileNotFoundError, NotADirectoryError, FileExistsError):
        # One of the path components was not a directory:
        # - we're in a zip file
        # - it is a file
 #eturn False
 #xcept PermissionError:
 #eturn False
 #xcept OSError as e:
        # as of now, EROFS doesn't have an equivalent OSError-subclass
 #f e.errno == errno.EROFS:
 #eturn False
 #aise
 #eturn True


def get_cache_dir(file_path: Path) -> Path:
 #""Return the cache directory to write .pyc files for the given .py file path."""
 #f sys.version_info >= (3, 8) and sys.pycache_prefix:
        # given:
        #   prefix = '/tmp/pycs'
        #   path = '/home/user/proj/test_app.py'
        # we want:
        #   '/tmp/pycs/home/user/proj'
 #eturn Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])
 #lse:
        # classic pycache directory
 #eturn file_path.parent / "__pycache__"
