"""Support for presenting detailed information in failing assertions."""
import sys
from typing import Any
from typing import Generator
from typing import List
from typing import Optional
from typing import TYPE_CHECKING

from _pytest.assertion import rewrite
from _pytest.assertion import truncate
from _pytest.assertion import util
from _pytest.assertion.rewrite import assertstate_key
from _pytest.config import Config
from _pytest.config import hookimpl
from _pytest.config.argparsing import Parser
from _pytest.nodes import Item

if TYPE_CHECKING:
 #rom _pytest.main import Session


def pytest_addoption(parser: Parser) -> None:
 #roup = parser.getgroup("debugconfig")
 #roup.addoption(
 #--assert",
 #ction="store",
 #est="assertmode",
 #hoices=("rewrite", "plain"),
 #efault="rewrite",
 #etavar="MODE",
 #elp=(
 #Control assertion debugging tools.\n"
 #'plain' performs no assertion debugging.\n"
 #'rewrite' (the default) rewrites assert statements in test modules"
 # on import to provide assert expression information."
 #,
 #
 #arser.addini(
 #enable_assertion_pass_hook",
 #ype="bool",
 #efault=False,
 #elp="Enables the pytest_assertion_pass hook."
 #Make sure to delete any previously generated pyc cache files.",
 #


def register_assert_rewrite(*names: str) -> None:
 #""Register one or more module names to be rewritten on import.

 #his function will make sure that this module or all modules inside
 #he package will get their assert statements rewritten.
 #hus you should make sure to call this before the module is
 #ctually imported, usually in your __init__.py if you are a plugin
 #sing a package.

 #raises TypeError: If the given module names are not strings.
 #""
 #or name in names:
 #f not isinstance(name, str):
 #sg = "expected module names as *args, got {0} instead"  # type: ignore[unreachable]
 #aise TypeError(msg.format(repr(names)))
 #or hook in sys.meta_path:
 #f isinstance(hook, rewrite.AssertionRewritingHook):
 #mporthook = hook
 #reak
 #lse:
        # TODO(typing): Add a protocol for mark_rewrite() and use it
        # for importhook and for PytestPluginManager.rewrite_hook.
 #mporthook = DummyRewriteHook()  # type: ignore
 #mporthook.mark_rewrite(*names)


class DummyRewriteHook:
 #""A no-op import hook for when rewriting is disabled."""

 #ef mark_rewrite(self, *names: str) -> None:
 #ass


class AssertionState:
 #""State for the assertion plugin."""

 #ef __init__(self, config: Config, mode) -> None:
 #elf.mode = mode
 #elf.trace = config.trace.root.get("assertion")
 #elf.hook: Optional[rewrite.AssertionRewritingHook] = None


def install_importhook(config: Config) -> rewrite.AssertionRewritingHook:
 #""Try to install the rewrite hook, raise SystemError if it fails."""
 #onfig._store[assertstate_key] = AssertionState(config, "rewrite")
 #onfig._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)
 #ys.meta_path.insert(0, hook)
 #onfig._store[assertstate_key].trace("installed rewrite import hook")

 #ef undo() -> None:
 #ook = config._store[assertstate_key].hook
 #f hook is not None and hook in sys.meta_path:
 #ys.meta_path.remove(hook)

 #onfig.add_cleanup(undo)
 #eturn hook


def pytest_collection(session: "Session") -> None:
    # This hook is only called when test modules are collected
    # so for example not in the master process of pytest-xdist
    # (which does not collect test modules).
 #ssertstate = session.config._store.get(assertstate_key, None)
 #f assertstate:
 #f assertstate.hook is not None:
 #ssertstate.hook.set_session(session)


@hookimpl(tryfirst=True, hookwrapper=True)
def pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:
 #""Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks.

 #he rewrite module will use util._reprcompare if it exists to use custom
 #eporting via the pytest_assertrepr_compare hook.  This sets up this custom
 #omparison for the test.
 #""

 #hook = item.ihook

 #ef callbinrepr(op, left: object, right: object) -> Optional[str]:
 #""Call the pytest_assertrepr_compare hook and prepare the result.

 #his uses the first result from the hook and then ensures the
 #ollowing:
 # Overly verbose explanations are truncated unless configured otherwise
 #eg. if running in verbose mode).
 # Embedded newlines are escaped to help util.format_explanation()
 #ater.
 # If the rewrite mode is used embedded %-characters are replaced
 #o protect later % formatting.

 #he result can be formatted by util.format_explanation() for
 #retty printing.
 #""
 #ook_result = ihook.pytest_assertrepr_compare(
 #onfig=item.config, op=op, left=left, right=right
 #
 #or new_expl in hook_result:
 #f new_expl:
 #ew_expl = truncate.truncate_if_required(new_expl, item)
 #ew_expl = [line.replace("\n", "\\n") for line in new_expl]
 #es = "\n~".join(new_expl)
 #f item.config.getvalue("assertmode") == "rewrite":
 #es = res.replace("%", "%%")
 #eturn res
 #eturn None

 #aved_assert_hooks = util._reprcompare, util._assertion_pass
 #til._reprcompare = callbinrepr

 #f ihook.pytest_assertion_pass.get_hookimpls():

 #ef call_assertion_pass_hook(lineno: int, orig: str, expl: str) -> None:
 #hook.pytest_assertion_pass(item=item, lineno=lineno, orig=orig, expl=expl)

 #til._assertion_pass = call_assertion_pass_hook

 #ield

 #til._reprcompare, util._assertion_pass = saved_assert_hooks


def pytest_sessionfinish(session: "Session") -> None:
 #ssertstate = session.config._store.get(assertstate_key, None)
 #f assertstate:
 #f assertstate.hook is not None:
 #ssertstate.hook.set_session(None)


def pytest_assertrepr_compare(
 #onfig: Config, op: str, left: Any, right: Any
) -> Optional[List[str]]:
 #eturn util.assertrepr_compare(config=config, op=op, left=left, right=right)
