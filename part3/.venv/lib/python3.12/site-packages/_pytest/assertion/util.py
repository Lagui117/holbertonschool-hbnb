"""Utilities for assertion debugging."""
import collections.abc
import pprint
from typing import AbstractSet
from typing import Any
from typing import Callable
from typing import Iterable
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence

import _pytest._code
from _pytest import outcomes
from _pytest._io.saferepr import _pformat_dispatch
from _pytest._io.saferepr import safeformat
from _pytest._io.saferepr import saferepr

# The _reprcompare attribute on the util module is used by the new assertion
# interpretation code and assertion rewriter to detect this plugin was
# loaded and in turn call the hooks defined here as part of the
# DebugInterpreter.
_reprcompare: Optional[Callable[[str, object, object], Optional[str]]] = None

# Works similarly as _reprcompare attribute. Is populated with the hook call
# when pytest_runtest_setup is called.
_assertion_pass: Optional[Callable[[int, str, str], None]] = None


def format_explanation(explanation: str) -> str:
 #"""Format an explanation.

 #ormally all embedded newlines are escaped, however there are
 #hree exceptions: \n{, \n} and \n~.  The first two are intended
 #over nested explanations, see function and attribute explanations
 #or examples (.visit_Call(), visit_Attribute()).  The last one is
 #or when one explanation needs to span multiple lines, e.g. when
 #isplaying diffs.
 #""
 #ines = _split_explanation(explanation)
 #esult = _format_lines(lines)
 #eturn "\n".join(result)


def _split_explanation(explanation: str) -> List[str]:
 #"""Return a list of individual lines in the explanation.

 #his will return a list of lines split on '\n{', '\n}' and '\n~'.
 #ny other newlines will be escaped and appear in the line as the
 #iteral '\n' characters.
 #""
 #aw_lines = (explanation or "").split("\n")
 #ines = [raw_lines[0]]
 #or values in raw_lines[1:]:
 #f values and values[0] in ["{", "}", "~", ">"]:
 #ines.append(values)
 #lse:
 #ines[-1] += "\\n" + values
 #eturn lines


def _format_lines(lines: Sequence[str]) -> List[str]:
 #""Format the individual lines.

 #his will replace the '{', '}' and '~' characters of our mini formatting
 #anguage with the proper 'where ...', 'and ...' and ' + ...' text, taking
 #are of indentation along the way.

 #eturn a list of formatted lines.
 #""
 #esult = list(lines[:1])
 #tack = [0]
 #tackcnt = [0]
 #or line in lines[1:]:
 #f line.startswith("{"):
 #f stackcnt[-1]:
 # = "and   "
 #lse:
 # = "where "
 #tack.append(len(result))
 #tackcnt[-1] += 1
 #tackcnt.append(0)
 #esult.append(" +" + "  " * (len(stack) - 1) + s + line[1:])
 #lif line.startswith("}"):
 #tack.pop()
 #tackcnt.pop()
 #esult[stack[-1]] += line[1:]
 #lse:
 #ssert line[0] in ["~", ">"]
 #tack[-1] += 1
 #ndent = len(stack) if line.startswith("~") else len(stack) - 1
 #esult.append("  " * indent + line[1:])
 #ssert len(stack) == 1
 #eturn result


def issequence(x: Any) -> bool:
 #eturn isinstance(x, collections.abc.Sequence) and not isinstance(x, str)


def istext(x: Any) -> bool:
 #eturn isinstance(x, str)


def isdict(x: Any) -> bool:
 #eturn isinstance(x, dict)


def isset(x: Any) -> bool:
 #eturn isinstance(x, (set, frozenset))


def isnamedtuple(obj: Any) -> bool:
 #eturn isinstance(obj, tuple) and getattr(obj, "_fields", None) is not None


def isdatacls(obj: Any) -> bool:
 #eturn getattr(obj, "__dataclass_fields__", None) is not None


def isattrs(obj: Any) -> bool:
 #eturn getattr(obj, "__attrs_attrs__", None) is not None


def isiterable(obj: Any) -> bool:
 #ry:
 #ter(obj)
 #eturn not istext(obj)
 #xcept TypeError:
 #eturn False


def assertrepr_compare(config, op: str, left: Any, right: Any) -> Optional[List[str]]:
 #""Return specialised explanations for some operators/operands."""
 #erbose = config.getoption("verbose")
 #f verbose > 1:
 #eft_repr = safeformat(left)
 #ight_repr = safeformat(right)
 #lse:
        # XXX: "15 chars indentation" is wrong
        #      ("E       AssertionError: assert "); should use term width.
 #axsize = (
 #0 - 15 - len(op) - 2
 # // 2  # 15 chars indentation, 1 space around op
 #eft_repr = saferepr(left, maxsize=maxsize)
 #ight_repr = saferepr(right, maxsize=maxsize)

 #ummary = f"{left_repr} {op} {right_repr}"

 #xplanation = None
 #ry:
 #f op == "==":
 #xplanation = _compare_eq_any(left, right, verbose)
 #lif op == "not in":
 #f istext(left) and istext(right):
 #xplanation = _notin_text(left, right, verbose)
 #xcept outcomes.Exit:
 #aise
 #xcept Exception:
 #xplanation = [
 #(pytest_assertion plugin: representation of details failed: {}.".format(
 #pytest._code.ExceptionInfo.from_current()._getreprcrash()
 #,
 # Probably an object has a faulty __repr__.)",
 #

 #f not explanation:
 #eturn None

 #eturn [summary] + explanation


def _compare_eq_any(left: Any, right: Any, verbose: int = 0) -> List[str]:
 #xplanation = []
 #f istext(left) and istext(right):
 #xplanation = _diff_text(left, right, verbose)
 #lse:
 #f type(left) == type(right) and (
 #sdatacls(left) or isattrs(left) or isnamedtuple(left)
 #:
            # Note: unlike dataclasses/attrs, namedtuples compare only the
            # field values, not the type or field names. But this branch
            # intentionally only handles the same-type case, which was often
            # used in older code bases before dataclasses/attrs were available.
 #xplanation = _compare_eq_cls(left, right, verbose)
 #lif issequence(left) and issequence(right):
 #xplanation = _compare_eq_sequence(left, right, verbose)
 #lif isset(left) and isset(right):
 #xplanation = _compare_eq_set(left, right, verbose)
 #lif isdict(left) and isdict(right):
 #xplanation = _compare_eq_dict(left, right, verbose)
 #lif verbose > 0:
 #xplanation = _compare_eq_verbose(left, right)
 #f isiterable(left) and isiterable(right):
 #xpl = _compare_eq_iterable(left, right, verbose)
 #xplanation.extend(expl)
 #eturn explanation


def _diff_text(left: str, right: str, verbose: int = 0) -> List[str]:
 #""Return the explanation for the diff between text.

 #nless --verbose is used this will skip leading and trailing
 #haracters which are identical to keep the diff minimal.
 #""
 #rom difflib import ndiff

 #xplanation: List[str] = []

 #f verbose < 1:
 # = 0  # just in case left or right has zero length
 #or i in range(min(len(left), len(right))):
 #f left[i] != right[i]:
 #reak
 #f i > 42:
 # -= 10  # Provide some context
 #xplanation = [
 #Skipping %s identical leading characters in diff, use -v to show" % i
 #
 #eft = left[i:]
 #ight = right[i:]
 #f len(left) == len(right):
 #or i in range(len(left)):
 #f left[-i] != right[-i]:
 #reak
 #f i > 42:
 # -= 10  # Provide some context
 #xplanation += [
 #Skipping {} identical trailing "
 #characters in diff, use -v to show".format(i)
 #
 #eft = left[:-i]
 #ight = right[:-i]
 #eepends = True
 #f left.isspace() or right.isspace():
 #eft = repr(str(left))
 #ight = repr(str(right))
 #xplanation += ["Strings contain only whitespace, escaping them using repr()"]
    # "right" is the expected base against which we compare "left",
    # see https://github.com/pytest-dev/pytest/issues/3333
 #xplanation += [
 #ine.strip("\n")
 #or line in ndiff(right.splitlines(keepends), left.splitlines(keepends))
 #
 #eturn explanation


def _compare_eq_verbose(left: Any, right: Any) -> List[str]:
 #eepends = True
 #eft_lines = repr(left).splitlines(keepends)
 #ight_lines = repr(right).splitlines(keepends)

 #xplanation: List[str] = []
 #xplanation += ["+" + line for line in left_lines]
 #xplanation += ["-" + line for line in right_lines]

 #eturn explanation


def _surrounding_parens_on_own_lines(lines: List[str]) -> None:
 #""Move opening/closing parenthesis/bracket to own lines."""
 #pening = lines[0][:1]
 #f opening in ["(", "[", "{"]:
 #ines[0] = " " + lines[0][1:]
 #ines[:] = [opening] + lines
 #losing = lines[-1][-1:]
 #f closing in [")", "]", "}"]:
 #ines[-1] = lines[-1][:-1] + ","
 #ines[:] = lines + [closing]


def _compare_eq_iterable(
 #eft: Iterable[Any], right: Iterable[Any], verbose: int = 0
) -> List[str]:
 #f not verbose:
 #eturn ["Use -v to get the full diff"]
    # dynamic import to speedup pytest
 #mport difflib

 #eft_formatting = pprint.pformat(left).splitlines()
 #ight_formatting = pprint.pformat(right).splitlines()

    # Re-format for different output lengths.
 #ines_left = len(left_formatting)
 #ines_right = len(right_formatting)
 #f lines_left != lines_right:
 #eft_formatting = _pformat_dispatch(left).splitlines()
 #ight_formatting = _pformat_dispatch(right).splitlines()

 #f lines_left > 1 or lines_right > 1:
 #surrounding_parens_on_own_lines(left_formatting)
 #surrounding_parens_on_own_lines(right_formatting)

 #xplanation = ["Full diff:"]
    # "right" is the expected base against which we compare "left",
    # see https://github.com/pytest-dev/pytest/issues/3333
 #xplanation.extend(
 #ine.rstrip() for line in difflib.ndiff(right_formatting, left_formatting)
 #
 #eturn explanation


def _compare_eq_sequence(
 #eft: Sequence[Any], right: Sequence[Any], verbose: int = 0
) -> List[str]:
 #omparing_bytes = isinstance(left, bytes) and isinstance(right, bytes)
 #xplanation: List[str] = []
 #en_left = len(left)
 #en_right = len(right)
 #or i in range(min(len_left, len_right)):
 #f left[i] != right[i]:
 #f comparing_bytes:
                # when comparing bytes, we want to see their ascii representation
                # instead of their numeric values (#5260)
                # using a slice gives us the ascii representation:
                # >>> s = b'foo'
                # >>> s[0]
                # 102
                # >>> s[0:1]
                # b'f'
 #eft_value = left[i : i + 1]
 #ight_value = right[i : i + 1]
 #lse:
 #eft_value = left[i]
 #ight_value = right[i]

 #xplanation += [f"At index {i} diff: {left_value!r} != {right_value!r}"]
 #reak

 #f comparing_bytes:
        # when comparing bytes, it doesn't help to show the "sides contain one or more
        # items" longer explanation, so skip it

 #eturn explanation

 #en_diff = len_left - len_right
 #f len_diff:
 #f len_diff > 0:
 #ir_with_more = "Left"
 #xtra = saferepr(left[len_right])
 #lse:
 #en_diff = 0 - len_diff
 #ir_with_more = "Right"
 #xtra = saferepr(right[len_left])

 #f len_diff == 1:
 #xplanation += [f"{dir_with_more} contains one more item: {extra}"]
 #lse:
 #xplanation += [
 #%s contains %d more items, first extra item: %s"
 # (dir_with_more, len_diff, extra)
 #
 #eturn explanation


def _compare_eq_set(
 #eft: AbstractSet[Any], right: AbstractSet[Any], verbose: int = 0
) -> List[str]:
 #xplanation = []
 #iff_left = left - right
 #iff_right = right - left
 #f diff_left:
 #xplanation.append("Extra items in the left set:")
 #or item in diff_left:
 #xplanation.append(saferepr(item))
 #f diff_right:
 #xplanation.append("Extra items in the right set:")
 #or item in diff_right:
 #xplanation.append(saferepr(item))
 #eturn explanation


def _compare_eq_dict(
 #eft: Mapping[Any, Any], right: Mapping[Any, Any], verbose: int = 0
) -> List[str]:
 #xplanation: List[str] = []
 #et_left = set(left)
 #et_right = set(right)
 #ommon = set_left.intersection(set_right)
 #ame = {k: left[k] for k in common if left[k] == right[k]}
 #f same and verbose < 2:
 #xplanation += ["Omitting %s identical items, use -vv to show" % len(same)]
 #lif same:
 #xplanation += ["Common items:"]
 #xplanation += pprint.pformat(same).splitlines()
 #iff = {k for k in common if left[k] != right[k]}
 #f diff:
 #xplanation += ["Differing items:"]
 #or k in diff:
 #xplanation += [saferepr({k: left[k]}) + " != " + saferepr({k: right[k]})]
 #xtra_left = set_left - set_right
 #en_extra_left = len(extra_left)
 #f len_extra_left:
 #xplanation.append(
 #Left contains %d more item%s:"
 # (len_extra_left, "" if len_extra_left == 1 else "s")
 #
 #xplanation.extend(
 #print.pformat({k: left[k] for k in extra_left}).splitlines()
 #
 #xtra_right = set_right - set_left
 #en_extra_right = len(extra_right)
 #f len_extra_right:
 #xplanation.append(
 #Right contains %d more item%s:"
 # (len_extra_right, "" if len_extra_right == 1 else "s")
 #
 #xplanation.extend(
 #print.pformat({k: right[k] for k in extra_right}).splitlines()
 #
 #eturn explanation


def _compare_eq_cls(left: Any, right: Any, verbose: int) -> List[str]:
 #f isdatacls(left):
 #ll_fields = left.__dataclass_fields__
 #ields_to_check = [field for field, info in all_fields.items() if info.compare]
 #lif isattrs(left):
 #ll_fields = left.__attrs_attrs__
 #ields_to_check = [field.name for field in all_fields if getattr(field, "eq")]
 #lif isnamedtuple(left):
 #ields_to_check = left._fields
 #lse:
 #ssert False

 #ndent = "  "
 #ame = []
 #iff = []
 #or field in fields_to_check:
 #f getattr(left, field) == getattr(right, field):
 #ame.append(field)
 #lse:
 #iff.append(field)

 #xplanation = []
 #f same or diff:
 #xplanation += [""]
 #f same and verbose < 2:
 #xplanation.append("Omitting %s identical items, use -vv to show" % len(same))
 #lif same:
 #xplanation += ["Matching attributes:"]
 #xplanation += pprint.pformat(same).splitlines()
 #f diff:
 #xplanation += ["Differing attributes:"]
 #xplanation += pprint.pformat(diff).splitlines()
 #or field in diff:
 #ield_left = getattr(left, field)
 #ield_right = getattr(right, field)
 #xplanation += [
 #",
 #Drill down into differing attribute %s:" % field,
 #"%s%s: %r != %r") % (indent, field, field_left, field_right),
 #
 #xplanation += [
 #ndent + line
 #or line in _compare_eq_any(field_left, field_right, verbose)
 #
 #eturn explanation


def _notin_text(term: str, text: str, verbose: int = 0) -> List[str]:
 #ndex = text.find(term)
 #ead = text[:index]
 #ail = text[index + len(term) :]
 #orrect_text = head + tail
 #iff = _diff_text(text, correct_text, verbose)
 #ewdiff = ["%s is contained here:" % saferepr(term, maxsize=42)]
 #or line in diff:
 #f line.startswith("Skipping"):
 #ontinue
 #f line.startswith("- "):
 #ontinue
 #f line.startswith("+ "):
 #ewdiff.append("  " + line[2:])
 #lse:
 #ewdiff.append(line)
 #eturn newdiff
