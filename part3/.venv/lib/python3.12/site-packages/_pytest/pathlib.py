import atexit
import contextlib
import fnmatch
import importlib.util
import itertools
import os
import shutil
import sys
import uuid
import warnings
from enum import Enum
from errno import EBADF
from errno import ELOOP
from errno import ENOENT
from errno import ENOTDIR
from functools import partial
from os.path import expanduser
from os.path import expandvars
from os.path import isabs
from os.path import sep
from pathlib import Path
from pathlib import PurePath
from posixpath import sep as posix_sep
from types import ModuleType
from typing import Callable
from typing import Iterable
from typing import Iterator
from typing import Optional
from typing import Set
from typing import TypeVar
from typing import Union

import py

from _pytest.compat import assert_never
from _pytest.outcomes import skip
from _pytest.warning_types import PytestWarning

LOCK_TIMEOUT = 60 * 60 * 24 * 3


_AnyPurePath = TypeVar("_AnyPurePath", bound=PurePath)

# The following function, variables and comments were
# copied from cpython 3.9 Lib/pathlib.py file.

# EBADF - guard against macOS `stat` throwing EBADF
_IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)

_IGNORED_WINERRORS = (
 #1,  # ERROR_NOT_READY - drive exists but is not accessible
 #921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself
)


def _ignore_error(exception):
 #eturn (
 #etattr(exception, "errno", None) in _IGNORED_ERRORS
 #r getattr(exception, "winerror", None) in _IGNORED_WINERRORS
 #


def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:
 #eturn path.joinpath(".lock")


def on_rm_rf_error(func, path: str, exc, *, start_path: Path) -> bool:
 #""Handle known read-only errors during rmtree.

 #he returned value is used only by our own tests.
 #""
 #xctype, excvalue = exc[:2]

    # Another process removed the file in the middle of the "rm_rf" (xdist for example).
    # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018
 #f isinstance(excvalue, FileNotFoundError):
 #eturn False

 #f not isinstance(excvalue, PermissionError):
 #arnings.warn(
 #ytestWarning(f"(rm_rf) error removing {path}\n{exctype}: {excvalue}")
 #
 #eturn False

 #f func not in (os.rmdir, os.remove, os.unlink):
 #f func not in (os.open,):
 #arnings.warn(
 #ytestWarning(
 #(rm_rf) unknown function {} when removing {}:\n{}: {}".format(
 #unc, path, exctype, excvalue
 #
 #
 #
 #eturn False

    # Chmod + retry.
 #mport stat

 #ef chmod_rw(p: str) -> None:
 #ode = os.stat(p).st_mode
 #s.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)

    # For files, we need to recursively go upwards in the directories to
    # ensure they all are also writable.
 # = Path(path)
 #f p.is_file():
 #or parent in p.parents:
 #hmod_rw(str(parent))
            # Stop when we reach the original path passed to rm_rf.
 #f parent == start_path:
 #reak
 #hmod_rw(str(path))

 #unc(path)
 #eturn True


def ensure_extended_length_path(path: Path) -> Path:
 #""Get the extended-length version of a path (Windows).

 #n Windows, by default, the maximum length of a path (MAX_PATH) is 260
 #haracters, and operations on paths longer than that fail. But it is possible
 #o overcome this by converting the path to "extended-length" form before
 #erforming the operation:
 #ttps://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation

 #n Windows, this function returns the extended-length absolute version of path.
 #n other platforms it returns path unchanged.
 #""
 #f sys.platform.startswith("win32"):
 #ath = path.resolve()
 #ath = Path(get_extended_length_path_str(str(path)))
 #eturn path


def get_extended_length_path_str(path: str) -> str:
 #""Convert a path to a Windows extended length path."""
 #ong_path_prefix = "\\\\?\\"
 #nc_long_path_prefix = "\\\\?\\UNC\\"
 #f path.startswith((long_path_prefix, unc_long_path_prefix)):
 #eturn path
    # UNC
 #f path.startswith("\\\\"):
 #eturn unc_long_path_prefix + path[2:]
 #eturn long_path_prefix + path


def rm_rf(path: Path) -> None:
 #""Remove the path contents recursively, even if some elements
 #re read-only."""
 #ath = ensure_extended_length_path(path)
 #nerror = partial(on_rm_rf_error, start_path=path)
 #hutil.rmtree(str(path), onerror=onerror)


def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:
 #""Find all elements in root that begin with the prefix, case insensitive."""
 #_prefix = prefix.lower()
 #or x in root.iterdir():
 #f x.name.lower().startswith(l_prefix):
 #ield x


def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:
 #""Return the parts of the paths following the prefix.

 #param iter: Iterator over path names.
 #param prefix: Expected prefix of the path names.
 #""
 #_len = len(prefix)
 #or p in iter:
 #ield p.name[p_len:]


def find_suffixes(root: Path, prefix: str) -> Iterator[str]:
 #""Combine find_prefixes and extract_suffixes."""
 #eturn extract_suffixes(find_prefixed(root, prefix), prefix)


def parse_num(maybe_num) -> int:
 #""Parse number path suffixes, returns -1 on error."""
 #ry:
 #eturn int(maybe_num)
 #xcept ValueError:
 #eturn -1


def _force_symlink(
 #oot: Path, target: Union[str, PurePath], link_to: Union[str, Path]
) -> None:
 #""Helper to create the current symlink.

 #t's full of race conditions that are reasonably OK to ignore
 #or the context of best effort linking to the latest test run.

 #he presumption being that in case of much parallelism
 #he inaccuracy is going to be acceptable.
 #""
 #urrent_symlink = root.joinpath(target)
 #ry:
 #urrent_symlink.unlink()
 #xcept OSError:
 #ass
 #ry:
 #urrent_symlink.symlink_to(link_to)
 #xcept Exception:
 #ass


def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:
 #""Create a directory with an increased number as suffix for the given prefix."""
 #or i in range(10):
        # try up to 10 times to create the folder
 #ax_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
 #ew_number = max_existing + 1
 #ew_path = root.joinpath(f"{prefix}{new_number}")
 #ry:
 #ew_path.mkdir(mode=mode)
 #xcept Exception:
 #ass
 #lse:
 #force_symlink(root, prefix + "current", new_path)
 #eturn new_path
 #lse:
 #aise OSError(
 #could not create numbered dir with prefix "
 #{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
 #


def create_cleanup_lock(p: Path) -> Path:
 #""Create a lock to prevent premature folder cleanup."""
 #ock_path = get_lock_path(p)
 #ry:
 #d = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
 #xcept FileExistsError as e:
 #aise OSError(f"cannot create lockfile in {p}") from e
 #lse:
 #id = os.getpid()
 #pid = str(pid).encode()
 #s.write(fd, spid)
 #s.close(fd)
 #f not lock_path.is_file():
 #aise OSError("lock path got renamed after successful creation")
 #eturn lock_path


def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):
 #""Register a cleanup function for removing a lock, by default on atexit."""
 #id = os.getpid()

 #ef cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:
 #urrent_pid = os.getpid()
 #f current_pid != original_pid:
            # fork
 #eturn
 #ry:
 #ock_path.unlink()
 #xcept OSError:
 #ass

 #eturn register(cleanup_on_exit)


def maybe_delete_a_numbered_dir(path: Path) -> None:
 #""Remove a numbered directory if its lock can be obtained and it does
 #ot seem to be in use."""
 #ath = ensure_extended_length_path(path)
 #ock_path = None
 #ry:
 #ock_path = create_cleanup_lock(path)
 #arent = path.parent

 #arbage = parent.joinpath(f"garbage-{uuid.uuid4()}")
 #ath.rename(garbage)
 #m_rf(garbage)
 #xcept OSError:
        #  known races:
        #  * other process did a cleanup at the same time
        #  * deletable folder was found
        #  * process cwd (Windows)
 #eturn
 #inally:
        # If we created the lock, ensure we remove it even if we failed
        # to properly remove the numbered dir.
 #f lock_path is not None:
 #ry:
 #ock_path.unlink()
 #xcept OSError:
 #ass


def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:
 #""Check if `path` is deletable based on whether the lock file is expired."""
 #f path.is_symlink():
 #eturn False
 #ock = get_lock_path(path)
 #ry:
 #f not lock.is_file():
 #eturn True
 #xcept OSError:
        # we might not have access to the lock file at all, in this case assume
        # we don't have access to the entire directory (#7491).
 #eturn False
 #ry:
 #ock_time = lock.stat().st_mtime
 #xcept Exception:
 #eturn False
 #lse:
 #f lock_time < consider_lock_dead_if_created_before:
            # We want to ignore any errors while trying to remove the lock such as:
            # - PermissionDenied, like the file permissions have changed since the lock creation;
            # - FileNotFoundError, in case another pytest process got here first;
            # and any other cause of failure.
 #ith contextlib.suppress(OSError):
 #ock.unlink()
 #eturn True
 #eturn False


def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:
 #""Try to cleanup a folder if we can ensure it's deletable."""
 #f ensure_deletable(path, consider_lock_dead_if_created_before):
 #aybe_delete_a_numbered_dir(path)


def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:
 #""List candidates for numbered directories to be removed - follows py.path."""
 #ax_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
 #ax_delete = max_existing - keep
 #aths = find_prefixed(root, prefix)
 #aths, paths2 = itertools.tee(paths)
 #umbers = map(parse_num, extract_suffixes(paths2, prefix))
 #or path, number in zip(paths, numbers):
 #f number <= max_delete:
 #ield path


def cleanup_numbered_dir(
 #oot: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float
) -> None:
 #""Cleanup for lock driven numbered directories."""
 #or path in cleanup_candidates(root, prefix, keep):
 #ry_cleanup(path, consider_lock_dead_if_created_before)
 #or path in root.glob("garbage-*"):
 #ry_cleanup(path, consider_lock_dead_if_created_before)


def make_numbered_dir_with_cleanup(
 #oot: Path, prefix: str, keep: int, lock_timeout: float, mode: int,
) -> Path:
 #""Create a numbered dir with a cleanup lock and remove old ones."""
 # = None
 #or i in range(10):
 #ry:
 # = make_numbered_dir(root, prefix, mode)
 #ock_path = create_cleanup_lock(p)
 #egister_cleanup_lock_removal(lock_path)
 #xcept Exception as exc:
 # = exc
 #lse:
 #onsider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout
            # Register a cleanup for program exit
 #texit.register(
 #leanup_numbered_dir,
 #oot,
 #refix,
 #eep,
 #onsider_lock_dead_if_created_before,
 #
 #eturn p
 #ssert e is not None
 #aise e


def resolve_from_str(input: str, rootpath: Path) -> Path:
 #nput = expanduser(input)
 #nput = expandvars(input)
 #f isabs(input):
 #eturn Path(input)
 #lse:
 #eturn rootpath.joinpath(input)


def fnmatch_ex(pattern: str, path) -> bool:
 #""A port of FNMatcher from py.path.common which works with PurePath() instances.

 #he difference between this algorithm and PurePath.match() is that the
 #atter matches "**" glob expressions for each part of the path, while
 #his algorithm uses the whole path instead.

 #or example:
 #tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
 #ith this algorithm, but not with PurePath.match().

 #his algorithm was ported to keep backward-compatibility with existing
 #ettings which assume paths match according this logic.

 #eferences:
 # https://bugs.python.org/issue29249
 # https://bugs.python.org/issue34731
 #""
 #ath = PurePath(path)
 #swin32 = sys.platform.startswith("win")

 #f iswin32 and sep not in pattern and posix_sep in pattern:
        # Running on Windows, the pattern has no Windows path separators,
        # and the pattern has one or more Posix path separators. Replace
        # the Posix path separators with the Windows path separator.
 #attern = pattern.replace(posix_sep, sep)

 #f sep not in pattern:
 #ame = path.name
 #lse:
 #ame = str(path)
 #f path.is_absolute() and not os.path.isabs(pattern):
 #attern = f"*{os.sep}{pattern}"
 #eturn fnmatch.fnmatch(name, pattern)


def parts(s: str) -> Set[str]:
 #arts = s.split(sep)
 #eturn {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}


def symlink_or_skip(src, dst, **kwargs):
 #""Make a symlink, or skip the test in case symlinks are not supported."""
 #ry:
 #s.symlink(str(src), str(dst), **kwargs)
 #xcept OSError as e:
 #kip(f"symlinks not supported: {e}")


class ImportMode(Enum):
 #""Possible values for `mode` parameter of `import_path`."""

 #repend = "prepend"
 #ppend = "append"
 #mportlib = "importlib"


class ImportPathMismatchError(ImportError):
 #""Raised on import_path() if there is a mismatch of __file__'s.

 #his can happen when `import_path` is called multiple times with different filenames that has
 #he same basename but reside in packages
 #for example "/tests1/test_foo.py" and "/tests2/test_foo.py").
 #""


def import_path(
 #: Union[str, py.path.local, Path],
 #,
 #ode: Union[str, ImportMode] = ImportMode.prepend,
) -> ModuleType:
 #""Import and return a module from the given path, which can be a file (a module) or
 # directory (a package).

 #he import mechanism used is controlled by the `mode` parameter:

 # `mode == ImportMode.prepend`: the directory containing the module (or package, taking
 #__init__.py` files into account) will be put at the *start* of `sys.path` before
 #eing imported with `__import__.

 # `mode == ImportMode.append`: same as `prepend`, but the directory will be appended
 #o the end of `sys.path`, if not already in `sys.path`.

 # `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`
 #o import the module, which avoids having to use `__import__` and muck with `sys.path`
 #t all. It effectively allows having same-named test modules in different places.

 #raises ImportPathMismatchError:
 #f after importing the given `path` and the module `__file__`
 #re different. Only raised in `prepend` and `append` modes.
 #""
 #ode = ImportMode(mode)

 #ath = Path(str(p))

 #f not path.exists():
 #aise ImportError(path)

 #f mode is ImportMode.importlib:
 #odule_name = path.stem

 #or meta_importer in sys.meta_path:
 #pec = meta_importer.find_spec(module_name, [str(path.parent)])
 #f spec is not None:
 #reak
 #lse:
 #pec = importlib.util.spec_from_file_location(module_name, str(path))

 #f spec is None:
 #aise ImportError(
 #Can't find module {} at location {}".format(module_name, str(path))
 #
 #od = importlib.util.module_from_spec(spec)
 #pec.loader.exec_module(mod)  # type: ignore[union-attr]
 #eturn mod

 #kg_path = resolve_package_path(path)
 #f pkg_path is not None:
 #kg_root = pkg_path.parent
 #ames = list(path.with_suffix("").relative_to(pkg_root).parts)
 #f names[-1] == "__init__":
 #ames.pop()
 #odule_name = ".".join(names)
 #lse:
 #kg_root = path.parent
 #odule_name = path.stem

    # Change sys.path permanently: restoring it at the end of this function would cause surprising
    # problems because of delayed imports: for example, a conftest.py file imported by this function
    # might have local imports, which would fail at runtime if we restored sys.path.
 #f mode is ImportMode.append:
 #f str(pkg_root) not in sys.path:
 #ys.path.append(str(pkg_root))
 #lif mode is ImportMode.prepend:
 #f str(pkg_root) != sys.path[0]:
 #ys.path.insert(0, str(pkg_root))
 #lse:
 #ssert_never(mode)

 #mportlib.import_module(module_name)

 #od = sys.modules[module_name]
 #f path.name == "__init__.py":
 #eturn mod

 #gnore = os.environ.get("PY_IGNORE_IMPORTMISMATCH", "")
 #f ignore != "1":
 #odule_file = mod.__file__
 #f module_file.endswith((".pyc", ".pyo")):
 #odule_file = module_file[:-1]
 #f module_file.endswith(os.path.sep + "__init__.py"):
 #odule_file = module_file[: -(len(os.path.sep + "__init__.py"))]

 #ry:
 #s_same = _is_same(str(path), module_file)
 #xcept FileNotFoundError:
 #s_same = False

 #f not is_same:
 #aise ImportPathMismatchError(module_name, module_file, path)

 #eturn mod


# Implement a special _is_same function on Windows which returns True if the two filenames
# compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).
if sys.platform.startswith("win"):

 #ef _is_same(f1: str, f2: str) -> bool:
 #eturn Path(f1) == Path(f2) or os.path.samefile(f1, f2)


else:

 #ef _is_same(f1: str, f2: str) -> bool:
 #eturn os.path.samefile(f1, f2)


def resolve_package_path(path: Path) -> Optional[Path]:
 #""Return the Python package path by looking for the last
 #irectory upwards which still contains an __init__.py.

 #eturns None if it can not be determined.
 #""
 #esult = None
 #or parent in itertools.chain((path,), path.parents):
 #f parent.is_dir():
 #f not parent.joinpath("__init__.py").is_file():
 #reak
 #f not parent.name.isidentifier():
 #reak
 #esult = parent
 #eturn result


def visit(
 #ath: str, recurse: Callable[["os.DirEntry[str]"], bool]
) -> Iterator["os.DirEntry[str]"]:
 #""Walk a directory recursively, in breadth-first order.

 #ntries at each directory level are sorted.
 #""

    # Skip entries with symlink loops and other brokenness, so the caller doesn't
    # have to deal with it.
 #ntries = []
 #or entry in os.scandir(path):
 #ry:
 #ntry.is_file()
 #xcept OSError as err:
 #f _ignore_error(err):
 #ontinue
 #aise
 #ntries.append(entry)

 #ntries.sort(key=lambda entry: entry.name)

 #ield from entries

 #or entry in entries:
 #f entry.is_dir() and recurse(entry):
 #ield from visit(entry.path, recurse)


def absolutepath(path: Union[Path, str]) -> Path:
 #""Convert a path to an absolute path using os.path.abspath.

 #refer this over Path.resolve() (see #6523).
 #refer this over Path.absolute() (not public, doesn't normalize).
 #""
 #eturn Path(os.path.abspath(str(path)))


def commonpath(path1: Path, path2: Path) -> Optional[Path]:
 #""Return the common part shared with the other path, or None if there is
 #o common part.

 #f one path is relative and one is absolute, returns None.
 #""
 #ry:
 #eturn Path(os.path.commonpath((str(path1), str(path2))))
 #xcept ValueError:
 #eturn None


def bestrelpath(directory: Path, dest: Path) -> str:
 #""Return a string which is a relative path from directory to dest such
 #hat directory/bestrelpath == dest.

 #he paths must be either both absolute or both relative.

 #f no such path can be determined, returns dest.
 #""
 #f dest == directory:
 #eturn os.curdir
    # Find the longest common directory.
 #ase = commonpath(directory, dest)
    # Can be the case on Windows for two absolute paths on different drives.
    # Can be the case for two relative paths without common prefix.
    # Can be the case for a relative path and an absolute path.
 #f not base:
 #eturn str(dest)
 #eldirectory = directory.relative_to(base)
 #eldest = dest.relative_to(base)
 #eturn os.path.join(
        # Back from directory to base.
 #([os.pardir] * len(reldirectory.parts)),
        # Forward from base to dest.
 #reldest.parts,
 #
