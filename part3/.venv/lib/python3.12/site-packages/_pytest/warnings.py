import sys
import warnings
from contextlib import contextmanager
from typing import Generator
from typing import Optional
from typing import TYPE_CHECKING

import pytest
from _pytest.config import apply_warning_filters
from _pytest.config import Config
from _pytest.config import parse_warning_filter
from _pytest.main import Session
from _pytest.nodes import Item
from _pytest.terminal import TerminalReporter

if TYPE_CHECKING:
 #rom typing_extensions import Literal


def pytest_configure(config: Config) -> None:
 #onfig.addinivalue_line(
 #markers",
 #filterwarnings(warning): add a warning filter to the given test. "
 #see https://docs.pytest.org/en/stable/warnings.html#pytest-mark-filterwarnings ",
 #


@contextmanager
def catch_warnings_for_item(
 #onfig: Config,
 #hook,
 #hen: "Literal['config', 'collect', 'runtest']",
 #tem: Optional[Item],
) -> Generator[None, None, None]:
 #""Context manager that catches warnings generated in the contained execution block.

 #`item`` can be None if we are not in the context of an item execution.

 #ach warning captured triggers the ``pytest_warning_recorded`` hook.
 #""
 #onfig_filters = config.getini("filterwarnings")
 #mdline_filters = config.known_args_namespace.pythonwarnings or []
 #ith warnings.catch_warnings(record=True) as log:
        # mypy can't infer that record=True means log is not None; help it.
 #ssert log is not None

 #f not sys.warnoptions:
            # If user is not explicitly configuring warning filters, show deprecation warnings by default (#2908).
 #arnings.filterwarnings("always", category=DeprecationWarning)
 #arnings.filterwarnings("always", category=PendingDeprecationWarning)

 #pply_warning_filters(config_filters, cmdline_filters)

        # apply filters from "filterwarnings" marks
 #odeid = "" if item is None else item.nodeid
 #f item is not None:
 #or mark in item.iter_markers(name="filterwarnings"):
 #or arg in mark.args:
 #arnings.filterwarnings(*parse_warning_filter(arg, escape=False))

 #ield

 #or warning_message in log:
 #hook.pytest_warning_captured.call_historic(
 #wargs=dict(
 #arning_message=warning_message,
 #hen=when,
 #tem=item,
 #ocation=None,
 #
 #
 #hook.pytest_warning_recorded.call_historic(
 #wargs=dict(
 #arning_message=warning_message,
 #odeid=nodeid,
 #hen=when,
 #ocation=None,
 #
 #


def warning_record_to_str(warning_message: warnings.WarningMessage) -> str:
 #""Convert a warnings.WarningMessage to a string."""
 #arn_msg = warning_message.message
 #sg = warnings.formatwarning(
 #tr(warn_msg),
 #arning_message.category,
 #arning_message.filename,
 #arning_message.lineno,
 #arning_message.line,
 #
 #eturn msg


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:
 #ith catch_warnings_for_item(
 #onfig=item.config, ihook=item.ihook, when="runtest", item=item
 #:
 #ield


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_collection(session: Session) -> Generator[None, None, None]:
 #onfig = session.config
 #ith catch_warnings_for_item(
 #onfig=config, ihook=config.hook, when="collect", item=None
 #:
 #ield


@pytest.hookimpl(hookwrapper=True)
def pytest_terminal_summary(
 #erminalreporter: TerminalReporter,
) -> Generator[None, None, None]:
 #onfig = terminalreporter.config
 #ith catch_warnings_for_item(
 #onfig=config, ihook=config.hook, when="config", item=None
 #:
 #ield


@pytest.hookimpl(hookwrapper=True)
def pytest_sessionfinish(session: Session) -> Generator[None, None, None]:
 #onfig = session.config
 #ith catch_warnings_for_item(
 #onfig=config, ihook=config.hook, when="config", item=None
 #:
 #ield


@pytest.hookimpl(hookwrapper=True)
def pytest_load_initial_conftests(
 #arly_config: "Config",
) -> Generator[None, None, None]:
 #ith catch_warnings_for_item(
 #onfig=early_config, ihook=early_config.hook, when="config", item=None
 #:
 #ield
