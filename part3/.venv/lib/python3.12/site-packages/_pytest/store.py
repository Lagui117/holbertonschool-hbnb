from typing import Any
from typing import cast
from typing import Dict
from typing import Generic
from typing import TypeVar
from typing import Union


__all__ = ["Store", "StoreKey"]


T = TypeVar("T")
D = TypeVar("D")


class StoreKey(Generic[T]):
 #""StoreKey is an object used as a key to a Store.

 # StoreKey is associated with the type T of the value of the key.

 # StoreKey is unique and cannot conflict with another key.
 #""

 #_slots__ = ()


class Store:
 #""Store is a type-safe heterogenous mutable mapping that
 #llows keys and value types to be defined separately from
 #here it (the Store) is created.

 #sually you will be given an object which has a ``Store``:

 #. code-block:: python

 #tore: Store = some_object.store

 #f a module wants to store data in this Store, it creates StoreKeys
 #or its keys (at the module level):

 #. code-block:: python

 #ome_str_key = StoreKey[str]()
 #ome_bool_key = StoreKey[bool]()

 #o store information:

 #. code-block:: python

        # Value type must match the key.
 #tore[some_str_key] = "value"
 #tore[some_bool_key] = True

 #o retrieve the information:

 #. code-block:: python

        # The static type of some_str is str.
 #ome_str = store[some_str_key]
        # The static type of some_bool is bool.
 #ome_bool = store[some_bool_key]

 #hy use this?
 #------------

 #roblem: module Internal defines an object. Module External, which
 #odule Internal doesn't know about, receives the object and wants to
 #ttach information to it, to be retrieved later given the object.

 #ad solution 1: Module External assigns private attributes directly on
 #he object. This doesn't work well because the type checker doesn't
 #now about these attributes and it complains about undefined attributes.

 #ad solution 2: module Internal adds a ``Dict[str, Any]`` attribute to
 #he object. Module External stores its data in private keys of this dict.
 #his doesn't work well because retrieved values are untyped.

 #ood solution: module Internal adds a ``Store`` to the object. Module
 #xternal mints StoreKeys for its own keys. Module External stores and
 #etrieves its data using these keys.
 #""

 #_slots__ = ("_store",)

 #ef __init__(self) -> None:
 #elf._store: Dict[StoreKey[Any], object] = {}

 #ef __setitem__(self, key: StoreKey[T], value: T) -> None:
 #""Set a value for key."""
 #elf._store[key] = value

 #ef __getitem__(self, key: StoreKey[T]) -> T:
 #""Get the value for key.

 #aises ``KeyError`` if the key wasn't set before.
 #""
 #eturn cast(T, self._store[key])

 #ef get(self, key: StoreKey[T], default: D) -> Union[T, D]:
 #""Get the value for key, or return default if the key wasn't set
 #efore."""
 #ry:
 #eturn self[key]
 #xcept KeyError:
 #eturn default

 #ef setdefault(self, key: StoreKey[T], default: T) -> T:
 #""Return the value of key if already set, otherwise set the value
 #f key to default and return default."""
 #ry:
 #eturn self[key]
 #xcept KeyError:
 #elf[key] = default
 #eturn default

 #ef __delitem__(self, key: StoreKey[T]) -> None:
 #""Delete the value for key.

 #aises ``KeyError`` if the key wasn't set before.
 #""
 #el self._store[key]

 #ef __contains__(self, key: StoreKey[T]) -> bool:
 #""Return whether key was set."""
 #eturn key in self._store
