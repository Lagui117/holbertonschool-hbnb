"""Exception classes and constants handling test outcomes as well as
functions creating them."""
import sys
from typing import Any
from typing import Callable
from typing import cast
from typing import Optional
from typing import Type
from typing import TypeVar

TYPE_CHECKING = False  # Avoid circular import through compat.

if TYPE_CHECKING:
 #rom typing import NoReturn
 #rom typing_extensions import Protocol
else:
    # typing.Protocol is only available starting from Python 3.8. It is also
    # available from typing_extensions, but we don't want a runtime dependency
    # on that. So use a dummy runtime implementation.
 #rom typing import Generic

 #rotocol = Generic


class OutcomeException(BaseException):
 #""OutcomeException and its subclass instances indicate and contain info
 #bout test and collection outcomes."""

 #ef __init__(self, msg: Optional[str] = None, pytrace: bool = True) -> None:
 #f msg is not None and not isinstance(msg, str):
 #rror_msg = (  # type: ignore[unreachable]
 #{} expected string as 'msg' parameter, got '{}' instead.\n"
 #Perhaps you meant to use a mark?"
 #
 #aise TypeError(error_msg.format(type(self).__name__, type(msg).__name__))
 #aseException.__init__(self, msg)
 #elf.msg = msg
 #elf.pytrace = pytrace

 #ef __repr__(self) -> str:
 #f self.msg is not None:
 #eturn self.msg
 #eturn f"<{self.__class__.__name__} instance>"

 #_str__ = __repr__


TEST_OUTCOME = (OutcomeException, Exception)


class Skipped(OutcomeException):
    # XXX hackish: on 3k we fake to live in the builtins
    # in order to have Skipped exception printing shorter/nicer
 #_module__ = "builtins"

 #ef __init__(
 #elf,
 #sg: Optional[str] = None,
 #ytrace: bool = True,
 #llow_module_level: bool = False,
 # -> None:
 #utcomeException.__init__(self, msg=msg, pytrace=pytrace)
 #elf.allow_module_level = allow_module_level


class Failed(OutcomeException):
 #""Raised from an explicit call to pytest.fail()."""

 #_module__ = "builtins"


class Exit(Exception):
 #""Raised for immediate program exits (no tracebacks/summaries)."""

 #ef __init__(
 #elf, msg: str = "unknown reason", returncode: Optional[int] = None
 # -> None:
 #elf.msg = msg
 #elf.returncode = returncode
 #uper().__init__(msg)


# Elaborate hack to work around https://github.com/python/mypy/issues/2087.
# Ideally would just be `exit.Exception = Exit` etc.

_F = TypeVar("_F", bound=Callable[..., object])
_ET = TypeVar("_ET", bound=Type[BaseException])


class _WithException(Protocol[_F, _ET]):
 #xception: _ET
 #_call__: _F


def _with_exception(exception_type: _ET) -> Callable[[_F], _WithException[_F, _ET]]:
 #ef decorate(func: _F) -> _WithException[_F, _ET]:
 #unc_with_exception = cast(_WithException[_F, _ET], func)
 #unc_with_exception.Exception = exception_type
 #eturn func_with_exception

 #eturn decorate


# Exposed helper methods.


@_with_exception(Exit)
def exit(msg: str, returncode: Optional[int] = None) -> "NoReturn":
 #""Exit testing process.

 #param str msg: Message to display upon exit.
 #param int returncode: Return code to be used when exiting pytest.
 #""
 #_tracebackhide__ = True
 #aise Exit(msg, returncode)


@_with_exception(Skipped)
def skip(msg: str = "", *, allow_module_level: bool = False) -> "NoReturn":
 #""Skip an executing test with the given message.

 #his function should be called only during testing (setup, call or teardown) or
 #uring collection by using the ``allow_module_level`` flag.  This function can
 #e called in doctests as well.

 #param bool allow_module_level:
 #llows this function to be called at module level, skipping the rest
 #f the module. Defaults to False.

 #. note::
 #t is better to use the :ref:`pytest.mark.skipif ref` marker when
 #ossible to declare a test to be skipped under certain conditions
 #ike mismatching platforms or dependencies.
 #imilarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP
 #https://docs.python.org/3/library/doctest.html#doctest.SKIP>`_)
 #o skip a doctest statically.
 #""
 #_tracebackhide__ = True
 #aise Skipped(msg=msg, allow_module_level=allow_module_level)


@_with_exception(Failed)
def fail(msg: str = "", pytrace: bool = True) -> "NoReturn":
 #""Explicitly fail an executing test with the given message.

 #param str msg:
 #he message to show the user as reason for the failure.
 #param bool pytrace:
 #f False, msg represents the full failure information and no
 #ython traceback will be reported.
 #""
 #_tracebackhide__ = True
 #aise Failed(msg=msg, pytrace=pytrace)


class XFailed(Failed):
 #""Raised from an explicit call to pytest.xfail()."""


@_with_exception(XFailed)
def xfail(reason: str = "") -> "NoReturn":
 #""Imperatively xfail an executing test or setup function with the given reason.

 #his function should be called only during testing (setup, call or teardown).

 #. note::
 #t is better to use the :ref:`pytest.mark.xfail ref` marker when
 #ossible to declare a test to be xfailed under certain conditions
 #ike known bugs or missing features.
 #""
 #_tracebackhide__ = True
 #aise XFailed(reason)


def importorskip(
 #odname: str, minversion: Optional[str] = None, reason: Optional[str] = None
) -> Any:
 #""Import and return the requested module ``modname``, or skip the
 #urrent test if the module cannot be imported.

 #param str modname:
 #he name of the module to import.
 #param str minversion:
 #f given, the imported module's ``__version__`` attribute must be at
 #east this minimal version, otherwise the test is still skipped.
 #param str reason:
 #f given, this reason is shown as the message when the module cannot
 #e imported.

 #returns:
 #he imported module. This should be assigned to its canonical name.

 #xample::

 #ocutils = pytest.importorskip("docutils")
 #""
 #mport warnings

 #_tracebackhide__ = True
 #ompile(modname, "", "eval")  # to catch syntaxerrors

 #ith warnings.catch_warnings():
        # Make sure to ignore ImportWarnings that might happen because
        # of existing directories with the same name we're trying to
        # import but without a __init__.py file.
 #arnings.simplefilter("ignore")
 #ry:
 #_import__(modname)
 #xcept ImportError as exc:
 #f reason is None:
 #eason = f"could not import {modname!r}: {exc}"
 #aise Skipped(reason, allow_module_level=True) from None
 #od = sys.modules[modname]
 #f minversion is None:
 #eturn mod
 #erattr = getattr(mod, "__version__", None)
 #f minversion is not None:
        # Imported lazily to improve start-up time.
 #rom packaging.version import Version

 #f verattr is None or Version(verattr) < Version(minversion):
 #aise Skipped(
 #module %r has __version__ %r, required is: %r"
 # (modname, verattr, minversion),
 #llow_module_level=True,
 #
 #eturn mod
