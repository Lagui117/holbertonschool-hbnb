from typing import List
from typing import Optional
from typing import TYPE_CHECKING

import pytest
from _pytest import nodes
from _pytest.config import Config
from _pytest.config.argparsing import Parser
from _pytest.main import Session
from _pytest.reports import TestReport

if TYPE_CHECKING:
 #rom _pytest.cacheprovider import Cache

STEPWISE_CACHE_DIR = "cache/stepwise"


def pytest_addoption(parser: Parser) -> None:
 #roup = parser.getgroup("general")
 #roup.addoption(
 #--sw",
 #--stepwise",
 #ction="store_true",
 #efault=False,
 #est="stepwise",
 #elp="exit on test failure and continue from last failing test next time",
 #
 #roup.addoption(
 #--sw-skip",
 #--stepwise-skip",
 #ction="store_true",
 #efault=False,
 #est="stepwise_skip",
 #elp="ignore the first failing test but stop on the next failing test",
 #


@pytest.hookimpl
def pytest_configure(config: Config) -> None:
    # We should always have a cache as cache provider plugin uses tryfirst=True
 #f config.getoption("stepwise"):
 #onfig.pluginmanager.register(StepwisePlugin(config), "stepwiseplugin")


def pytest_sessionfinish(session: Session) -> None:
 #f not session.config.getoption("stepwise"):
 #ssert session.config.cache is not None
        # Clear the list of failing tests if the plugin is not active.
 #ession.config.cache.set(STEPWISE_CACHE_DIR, [])


class StepwisePlugin:
 #ef __init__(self, config: Config) -> None:
 #elf.config = config
 #elf.session: Optional[Session] = None
 #elf.report_status = ""
 #ssert config.cache is not None
 #elf.cache: Cache = config.cache
 #elf.lastfailed: Optional[str] = self.cache.get(STEPWISE_CACHE_DIR, None)
 #elf.skip: bool = config.getoption("stepwise_skip")

 #ef pytest_sessionstart(self, session: Session) -> None:
 #elf.session = session

 #ef pytest_collection_modifyitems(
 #elf, config: Config, items: List[nodes.Item]
 # -> None:
 #f not self.lastfailed:
 #elf.report_status = "no previously failed tests, not skipping."
 #eturn

        # check all item nodes until we find a match on last failed
 #ailed_index = None
 #or index, item in enumerate(items):
 #f item.nodeid == self.lastfailed:
 #ailed_index = index
 #reak

        # If the previously failed test was not found among the test items,
        # do not skip any tests.
 #f failed_index is None:
 #elf.report_status = "previously failed test not found, not skipping."
 #lse:
 #elf.report_status = f"skipping {failed_index} already passed items."
 #eselected = items[:failed_index]
 #el items[:failed_index]
 #onfig.hook.pytest_deselected(items=deselected)

 #ef pytest_runtest_logreport(self, report: TestReport) -> None:
 #f report.failed:
 #f self.skip:
                # Remove test from the failed ones (if it exists) and unset the skip option
                # to make sure the following tests will not be skipped.
 #f report.nodeid == self.lastfailed:
 #elf.lastfailed = None

 #elf.skip = False
 #lse:
                # Mark test as the last failing and interrupt the test session.
 #elf.lastfailed = report.nodeid
 #ssert self.session is not None
 #elf.session.shouldstop = (
 #Test failed, continuing from this test next run."
 #

 #lse:
            # If the test was actually run and did pass.
 #f report.when == "call":
                # Remove test from the failed ones, if exists.
 #f report.nodeid == self.lastfailed:
 #elf.lastfailed = None

 #ef pytest_report_collectionfinish(self) -> Optional[str]:
 #f self.config.getoption("verbose") >= 0 and self.report_status:
 #eturn f"stepwise: {self.report_status}"
 #eturn None

 #ef pytest_sessionfinish(self) -> None:
 #elf.cache.set(STEPWISE_CACHE_DIR, self.lastfailed)
