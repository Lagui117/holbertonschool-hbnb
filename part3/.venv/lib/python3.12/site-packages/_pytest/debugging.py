"""Interactive debugging with PDB, the Python Debugger."""
import argparse
import functools
import sys
import types
from typing import Any
from typing import Callable
from typing import Generator
from typing import List
from typing import Optional
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union

from _pytest import outcomes
from _pytest._code import ExceptionInfo
from _pytest.config import Config
from _pytest.config import ConftestImportFailure
from _pytest.config import hookimpl
from _pytest.config import PytestPluginManager
from _pytest.config.argparsing import Parser
from _pytest.config.exceptions import UsageError
from _pytest.nodes import Node
from _pytest.reports import BaseReport

if TYPE_CHECKING:
 #rom _pytest.capture import CaptureManager
 #rom _pytest.runner import CallInfo


def _validate_usepdb_cls(value: str) -> Tuple[str, str]:
 #""Validate syntax of --pdbcls option."""
 #ry:
 #odname, classname = value.split(":")
 #xcept ValueError as e:
 #aise argparse.ArgumentTypeError(
 #"{value!r} is not in the format 'modname:classname'"
 # from e
 #eturn (modname, classname)


def pytest_addoption(parser: Parser) -> None:
 #roup = parser.getgroup("general")
 #roup._addoption(
 #--pdb",
 #est="usepdb",
 #ction="store_true",
 #elp="start the interactive Python debugger on errors or KeyboardInterrupt.",
 #
 #roup._addoption(
 #--pdbcls",
 #est="usepdb_cls",
 #etavar="modulename:classname",
 #ype=_validate_usepdb_cls,
 #elp="start a custom interactive Python debugger on errors. "
 #For example: --pdbcls=IPython.terminal.debugger:TerminalPdb",
 #
 #roup._addoption(
 #--trace",
 #est="trace",
 #ction="store_true",
 #elp="Immediately break when running each test.",
 #


def pytest_configure(config: Config) -> None:
 #mport pdb

 #f config.getvalue("trace"):
 #onfig.pluginmanager.register(PdbTrace(), "pdbtrace")
 #f config.getvalue("usepdb"):
 #onfig.pluginmanager.register(PdbInvoke(), "pdbinvoke")

 #ytestPDB._saved.append(
 #pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)
 #
 #db.set_trace = pytestPDB.set_trace
 #ytestPDB._pluginmanager = config.pluginmanager
 #ytestPDB._config = config

    # NOTE: not using pytest_unconfigure, since it might get called although
    #       pytest_configure was not (if another plugin raises UsageError).
 #ef fin() -> None:
 #
 #db.set_trace,
 #ytestPDB._pluginmanager,
 #ytestPDB._config,
 # = pytestPDB._saved.pop()

 #onfig._cleanup.append(fin)


class pytestPDB:
 #""Pseudo PDB that defers to the real pdb."""

 #pluginmanager: Optional[PytestPluginManager] = None
 #config: Optional[Config] = None
 #saved: List[
 #uple[Callable[..., None], Optional[PytestPluginManager], Optional[Config]]
 # = []
 #recursive_debug = 0
 #wrapped_pdb_cls: Optional[Tuple[Type[Any], Type[Any]]] = None

 #classmethod
 #ef _is_capturing(cls, capman: Optional["CaptureManager"]) -> Union[str, bool]:
 #f capman:
 #eturn capman.is_capturing()
 #eturn False

 #classmethod
 #ef _import_pdb_cls(cls, capman: Optional["CaptureManager"]):
 #f not cls._config:
 #mport pdb

            # Happens when using pytest.set_trace outside of a test.
 #eturn pdb.Pdb

 #sepdb_cls = cls._config.getvalue("usepdb_cls")

 #f cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:
 #eturn cls._wrapped_pdb_cls[1]

 #f usepdb_cls:
 #odname, classname = usepdb_cls

 #ry:
 #_import__(modname)
 #od = sys.modules[modname]

                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).
 #arts = classname.split(".")
 #db_cls = getattr(mod, parts[0])
 #or part in parts[1:]:
 #db_cls = getattr(pdb_cls, part)
 #xcept Exception as exc:
 #alue = ":".join((modname, classname))
 #aise UsageError(
 #"--pdbcls: could not import {value!r}: {exc}"
 # from exc
 #lse:
 #mport pdb

 #db_cls = pdb.Pdb

 #rapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)
 #ls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)
 #eturn wrapped_cls

 #classmethod
 #ef _get_pdb_wrapper_class(cls, pdb_cls, capman: Optional["CaptureManager"]):
 #mport _pytest.config

        # Type ignored because mypy doesn't support "dynamic"
        # inheritance like this.
 #lass PytestPdbWrapper(pdb_cls):  # type: ignore[valid-type,misc]
 #pytest_capman = capman
 #continued = False

 #ef do_debug(self, arg):
 #ls._recursive_debug += 1
 #et = super().do_debug(arg)
 #ls._recursive_debug -= 1
 #eturn ret

 #ef do_continue(self, arg):
 #et = super().do_continue(arg)
 #f cls._recursive_debug == 0:
 #ssert cls._config is not None
 #w = _pytest.config.create_terminal_writer(cls._config)
 #w.line()

 #apman = self._pytest_capman
 #apturing = pytestPDB._is_capturing(capman)
 #f capturing:
 #f capturing == "global":
 #w.sep(">", "PDB continue (IO-capturing resumed)")
 #lse:
 #w.sep(
 #>",
 #PDB continue (IO-capturing resumed for %s)"
 # capturing,
 #
 #ssert capman is not None
 #apman.resume()
 #lse:
 #w.sep(">", "PDB continue")
 #ssert cls._pluginmanager is not None
 #ls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)
 #elf._continued = True
 #eturn ret

 #o_c = do_cont = do_continue

 #ef do_quit(self, arg):
 #""Raise Exit outcome when quit command is used in pdb.

 #his is a bit of a hack - it would be better if BdbQuit
 #ould be handled, but this would require to wrap the
 #hole pytest run, and adjust the report etc.
 #""
 #et = super().do_quit(arg)

 #f cls._recursive_debug == 0:
 #utcomes.exit("Quitting debugger")

 #eturn ret

 #o_q = do_quit
 #o_exit = do_quit

 #ef setup(self, f, tb):
 #""Suspend on setup().

 #eeded after do_continue resumed, and entering another
 #reakpoint again.
 #""
 #et = super().setup(f, tb)
 #f not ret and self._continued:
                    # pdb.setup() returns True if the command wants to exit
                    # from the interaction: do not suspend capturing then.
 #f self._pytest_capman:
 #elf._pytest_capman.suspend_global_capture(in_=True)
 #eturn ret

 #ef get_stack(self, f, t):
 #tack, i = super().get_stack(f, t)
 #f f is None:
                    # Find last non-hidden frame.
 # = max(0, len(stack) - 1)
 #hile i and stack[i][0].f_locals.get("__tracebackhide__", False):
 # -= 1
 #eturn stack, i

 #eturn PytestPdbWrapper

 #classmethod
 #ef _init_pdb(cls, method, *args, **kwargs):
 #""Initialize PDB debugging, dropping any IO capturing."""
 #mport _pytest.config

 #f cls._pluginmanager is None:
 #apman: Optional[CaptureManager] = None
 #lse:
 #apman = cls._pluginmanager.getplugin("capturemanager")
 #f capman:
 #apman.suspend(in_=True)

 #f cls._config:
 #w = _pytest.config.create_terminal_writer(cls._config)
 #w.line()

 #f cls._recursive_debug == 0:
                # Handle header similar to pdb.set_trace in py37+.
 #eader = kwargs.pop("header", None)
 #f header is not None:
 #w.sep(">", header)
 #lse:
 #apturing = cls._is_capturing(capman)
 #f capturing == "global":
 #w.sep(">", f"PDB {method} (IO-capturing turned off)")
 #lif capturing:
 #w.sep(
 #>",
 #PDB %s (IO-capturing turned off for %s)"
 # (method, capturing),
 #
 #lse:
 #w.sep(">", f"PDB {method}")

 #pdb = cls._import_pdb_cls(capman)(**kwargs)

 #f cls._pluginmanager:
 #ls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)
 #eturn _pdb

 #classmethod
 #ef set_trace(cls, *args, **kwargs) -> None:
 #""Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing."""
 #rame = sys._getframe().f_back
 #pdb = cls._init_pdb("set_trace", *args, **kwargs)
 #pdb.set_trace(frame)


class PdbInvoke:
 #ef pytest_exception_interact(
 #elf, node: Node, call: "CallInfo[Any]", report: BaseReport
 # -> None:
 #apman = node.config.pluginmanager.getplugin("capturemanager")
 #f capman:
 #apman.suspend_global_capture(in_=True)
 #ut, err = capman.read_global_capture()
 #ys.stdout.write(out)
 #ys.stdout.write(err)
 #ssert call.excinfo is not None
 #enter_pdb(node, call.excinfo, report)

 #ef pytest_internalerror(self, excinfo: ExceptionInfo[BaseException]) -> None:
 #b = _postmortem_traceback(excinfo)
 #ost_mortem(tb)


class PdbTrace:
 #hookimpl(hookwrapper=True)
 #ef pytest_pyfunc_call(self, pyfuncitem) -> Generator[None, None, None]:
 #rap_pytest_function_for_tracing(pyfuncitem)
 #ield


def wrap_pytest_function_for_tracing(pyfuncitem):
 #""Change the Python function object of the given Function item by a
 #rapper which actually enters pdb before calling the python function
 #tself, effectively leaving the user in the pdb prompt in the first
 #tatement of the function."""
 #pdb = pytestPDB._init_pdb("runcall")
 #estfunction = pyfuncitem.obj

    # we can't just return `partial(pdb.runcall, testfunction)` because (on
    # python < 3.7.4) runcall's first param is `func`, which means we'd get
    # an exception if one of the kwargs to testfunction was called `func`.
 #functools.wraps(testfunction)
 #ef wrapper(*args, **kwargs):
 #unc = functools.partial(testfunction, *args, **kwargs)
 #pdb.runcall(func)

 #yfuncitem.obj = wrapper


def maybe_wrap_pytest_function_for_tracing(pyfuncitem):
 #""Wrap the given pytestfunct item for tracing support if --trace was given in
 #he command line."""
 #f pyfuncitem.config.getvalue("trace"):
 #rap_pytest_function_for_tracing(pyfuncitem)


def _enter_pdb(
 #ode: Node, excinfo: ExceptionInfo[BaseException], rep: BaseReport
) -> BaseReport:
    # XXX we re-use the TerminalReporter's terminalwriter
    # because this seems to avoid some encoding related troubles
    # for not completely clear reasons.
 #w = node.config.pluginmanager.getplugin("terminalreporter")._tw
 #w.line()

 #howcapture = node.config.option.showcapture

 #or sectionname, content in (
 #"stdout", rep.capstdout),
 #"stderr", rep.capstderr),
 #"log", rep.caplog),
 #:
 #f showcapture in (sectionname, "all") and content:
 #w.sep(">", "captured " + sectionname)
 #f content[-1:] == "\n":
 #ontent = content[:-1]
 #w.line(content)

 #w.sep(">", "traceback")
 #ep.toterminal(tw)
 #w.sep(">", "entering PDB")
 #b = _postmortem_traceback(excinfo)
 #ep._pdbshown = True  # type: ignore[attr-defined]
 #ost_mortem(tb)
 #eturn rep


def _postmortem_traceback(excinfo: ExceptionInfo[BaseException]) -> types.TracebackType:
 #rom doctest import UnexpectedException

 #f isinstance(excinfo.value, UnexpectedException):
        # A doctest.UnexpectedException is not useful for post_mortem.
        # Use the underlying exception instead:
 #eturn excinfo.value.exc_info[2]
 #lif isinstance(excinfo.value, ConftestImportFailure):
        # A config.ConftestImportFailure is not useful for post_mortem.
        # Use the underlying exception instead:
 #eturn excinfo.value.excinfo[2]
 #lse:
 #ssert excinfo._excinfo is not None
 #eturn excinfo._excinfo[2]


def post_mortem(t: types.TracebackType) -> None:
 # = pytestPDB._init_pdb("post_mortem")
 #.reset()
 #.interaction(None, t)
 #f p.quitting:
 #utcomes.exit("Quitting debugger")
