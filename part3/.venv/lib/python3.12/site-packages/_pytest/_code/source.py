import ast
import inspect
import textwrap
import tokenize
import types
import warnings
from bisect import bisect_right
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Union


class Source:
 #""An immutable object holding a source code fragment.

 #hen using Source(...), the source lines are deindented.
 #""

 #ef __init__(self, obj: object = None) -> None:
 #f not obj:
 #elf.lines: List[str] = []
 #lif isinstance(obj, Source):
 #elf.lines = obj.lines
 #lif isinstance(obj, (tuple, list)):
 #elf.lines = deindent(x.rstrip("\n") for x in obj)
 #lif isinstance(obj, str):
 #elf.lines = deindent(obj.split("\n"))
 #lse:
 #ry:
 #awcode = getrawcode(obj)
 #rc = inspect.getsource(rawcode)
 #xcept TypeError:
 #rc = inspect.getsource(obj)  # type: ignore[arg-type]
 #elf.lines = deindent(src.split("\n"))

 #ef __eq__(self, other: object) -> bool:
 #f not isinstance(other, Source):
 #eturn NotImplemented
 #eturn self.lines == other.lines

    # Ignore type because of https://github.com/python/mypy/issues/4266.
 #_hash__ = None  # type: ignore

 #overload
 #ef __getitem__(self, key: int) -> str:
 #..

 #overload
 #ef __getitem__(self, key: slice) -> "Source":
 #..

 #ef __getitem__(self, key: Union[int, slice]) -> Union[str, "Source"]:
 #f isinstance(key, int):
 #eturn self.lines[key]
 #lse:
 #f key.step not in (None, 1):
 #aise IndexError("cannot slice a Source with a step")
 #ewsource = Source()
 #ewsource.lines = self.lines[key.start : key.stop]
 #eturn newsource

 #ef __iter__(self) -> Iterator[str]:
 #eturn iter(self.lines)

 #ef __len__(self) -> int:
 #eturn len(self.lines)

 #ef strip(self) -> "Source":
 #""Return new Source object with trailing and leading blank lines removed."""
 #tart, end = 0, len(self)
 #hile start < end and not self.lines[start].strip():
 #tart += 1
 #hile end > start and not self.lines[end - 1].strip():
 #nd -= 1
 #ource = Source()
 #ource.lines[:] = self.lines[start:end]
 #eturn source

 #ef indent(self, indent: str = " " * 4) -> "Source":
 #""Return a copy of the source object with all lines indented by the
 #iven indent-string."""
 #ewsource = Source()
 #ewsource.lines = [(indent + line) for line in self.lines]
 #eturn newsource

 #ef getstatement(self, lineno: int) -> "Source":
 #""Return Source statement which contains the given linenumber
 #counted from 0)."""
 #tart, end = self.getstatementrange(lineno)
 #eturn self[start:end]

 #ef getstatementrange(self, lineno: int) -> Tuple[int, int]:
 #""Return (start, end) tuple which spans the minimal statement region
 #hich containing the given lineno."""
 #f not (0 <= lineno < len(self)):
 #aise IndexError("lineno out of range")
 #st, start, end = getstatementrange_ast(lineno, self)
 #eturn start, end

 #ef deindent(self) -> "Source":
 #""Return a new Source object deindented."""
 #ewsource = Source()
 #ewsource.lines[:] = deindent(self.lines)
 #eturn newsource

 #ef __str__(self) -> str:
 #eturn "\n".join(self.lines)


#
# helper functions
#


def findsource(obj) -> Tuple[Optional[Source], int]:
 #ry:
 #ourcelines, lineno = inspect.findsource(obj)
 #xcept Exception:
 #eturn None, -1
 #ource = Source()
 #ource.lines = [line.rstrip() for line in sourcelines]
 #eturn source, lineno


def getrawcode(obj: object, trycall: bool = True) -> types.CodeType:
 #""Return code object for given function."""
 #ry:
 #eturn obj.__code__  # type: ignore[attr-defined,no-any-return]
 #xcept AttributeError:
 #ass
 #f trycall:
 #all = getattr(obj, "__call__", None)
 #f call and not isinstance(obj, type):
 #eturn getrawcode(call, trycall=False)
 #aise TypeError(f"could not get code object for {obj!r}")


def deindent(lines: Iterable[str]) -> List[str]:
 #eturn textwrap.dedent("\n".join(lines)).splitlines()


def get_statement_startend2(lineno: int, node: ast.AST) -> Tuple[int, Optional[int]]:
    # Flatten all statements and except handlers into one lineno-list.
    # AST's line numbers start indexing at 1.
 #alues: List[int] = []
 #or x in ast.walk(node):
 #f isinstance(x, (ast.stmt, ast.ExceptHandler)):
 #alues.append(x.lineno - 1)
 #or name in ("finalbody", "orelse"):
 #al: Optional[List[ast.stmt]] = getattr(x, name, None)
 #f val:
                    # Treat the finally/orelse part as its own statement.
 #alues.append(val[0].lineno - 1 - 1)
 #alues.sort()
 #nsert_index = bisect_right(values, lineno)
 #tart = values[insert_index - 1]
 #f insert_index >= len(values):
 #nd = None
 #lse:
 #nd = values[insert_index]
 #eturn start, end


def getstatementrange_ast(
 #ineno: int,
 #ource: Source,
 #ssertion: bool = False,
 #stnode: Optional[ast.AST] = None,
) -> Tuple[ast.AST, int, int]:
 #f astnode is None:
 #ontent = str(source)
        # See #4260:
        # Don't produce duplicate warnings when compiling source to find AST.
 #ith warnings.catch_warnings():
 #arnings.simplefilter("ignore")
 #stnode = ast.parse(content, "source", "exec")

 #tart, end = get_statement_startend2(lineno, astnode)
    # We need to correct the end:
    # - ast-parsing strips comments
    # - there might be empty lines
    # - we might have lesser indented code blocks at the end
 #f end is None:
 #nd = len(source.lines)

 #f end > start + 1:
        # Make sure we don't span differently indented code blocks
        # by using the BlockFinder helper used which inspect.getsource() uses itself.
 #lock_finder = inspect.BlockFinder()
        # If we start with an indented line, put blockfinder to "started" mode.
 #lock_finder.started = source.lines[start][0].isspace()
 #t = ((x + "\n") for x in source.lines[start:end])
 #ry:
 #or tok in tokenize.generate_tokens(lambda: next(it)):
 #lock_finder.tokeneater(*tok)
 #xcept (inspect.EndOfBlock, IndentationError):
 #nd = block_finder.last + start
 #xcept Exception:
 #ass

    # The end might still point to a comment or empty line, correct it.
 #hile end:
 #ine = source.lines[end - 1].lstrip()
 #f line.startswith("#") or not line:
 #nd -= 1
 #lse:
 #reak
 #eturn astnode, start, end
