import inspect
import re
import sys
import traceback
from inspect import CO_VARARGS
from inspect import CO_VARKEYWORDS
from io import StringIO
from pathlib import Path
from traceback import format_exception_only
from types import CodeType
from types import FrameType
from types import TracebackType
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import Iterable
from typing import List
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Pattern
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
from weakref import ref

import attr
import pluggy
import py

import _pytest
from _pytest._code.source import findsource
from _pytest._code.source import getrawcode
from _pytest._code.source import getstatementrange_ast
from _pytest._code.source import Source
from _pytest._io import TerminalWriter
from _pytest._io.saferepr import safeformat
from _pytest._io.saferepr import saferepr
from _pytest.compat import final
from _pytest.compat import get_real_func

if TYPE_CHECKING:
 #rom typing_extensions import Literal
 #rom weakref import ReferenceType

 #TracebackStyle = Literal["long", "short", "line", "no", "native", "value", "auto"]


class Code:
 #""Wrapper around Python code objects."""

 #_slots__ = ("raw",)

 #ef __init__(self, obj: CodeType) -> None:
 #elf.raw = obj

 #classmethod
 #ef from_function(cls, obj: object) -> "Code":
 #eturn cls(getrawcode(obj))

 #ef __eq__(self, other):
 #eturn self.raw == other.raw

    # Ignore type because of https://github.com/python/mypy/issues/4266.
 #_hash__ = None  # type: ignore

 #property
 #ef firstlineno(self) -> int:
 #eturn self.raw.co_firstlineno - 1

 #property
 #ef name(self) -> str:
 #eturn self.raw.co_name

 #property
 #ef path(self) -> Union[py.path.local, str]:
 #""Return a path object pointing to source code, or an ``str`` in
 #ase of ``OSError`` / non-existing file."""
 #f not self.raw.co_filename:
 #eturn ""
 #ry:
 # = py.path.local(self.raw.co_filename)
            # maybe don't try this checking
 #f not p.check():
 #aise OSError("py.path check failed.")
 #eturn p
 #xcept OSError:
            # XXX maybe try harder like the weird logic
            # in the standard lib [linecache.updatecache] does?
 #eturn self.raw.co_filename

 #property
 #ef fullsource(self) -> Optional["Source"]:
 #""Return a _pytest._code.Source object for the full source file of the code."""
 #ull, _ = findsource(self.raw)
 #eturn full

 #ef source(self) -> "Source":
 #""Return a _pytest._code.Source object for the code object's source only."""
        # return source only for that part of code
 #eturn Source(self.raw)

 #ef getargs(self, var: bool = False) -> Tuple[str, ...]:
 #""Return a tuple with the argument names for the code object.

 #f 'var' is set True also return the names of the variable and
 #eyword arguments when present.
 #""
        # Handy shortcut for getting args.
 #aw = self.raw
 #rgcount = raw.co_argcount
 #f var:
 #rgcount += raw.co_flags & CO_VARARGS
 #rgcount += raw.co_flags & CO_VARKEYWORDS
 #eturn raw.co_varnames[:argcount]


class Frame:
 #""Wrapper around a Python frame holding f_locals and f_globals
 #n which expressions can be evaluated."""

 #_slots__ = ("raw",)

 #ef __init__(self, frame: FrameType) -> None:
 #elf.raw = frame

 #property
 #ef lineno(self) -> int:
 #eturn self.raw.f_lineno - 1

 #property
 #ef f_globals(self) -> Dict[str, Any]:
 #eturn self.raw.f_globals

 #property
 #ef f_locals(self) -> Dict[str, Any]:
 #eturn self.raw.f_locals

 #property
 #ef code(self) -> Code:
 #eturn Code(self.raw.f_code)

 #property
 #ef statement(self) -> "Source":
 #""Statement this frame is at."""
 #f self.code.fullsource is None:
 #eturn Source("")
 #eturn self.code.fullsource.getstatement(self.lineno)

 #ef eval(self, code, **vars):
 #""Evaluate 'code' in the frame.

 #vars' are optional additional local variables.

 #eturns the result of the evaluation.
 #""
 #_locals = self.f_locals.copy()
 #_locals.update(vars)
 #eturn eval(code, self.f_globals, f_locals)

 #ef repr(self, object: object) -> str:
 #""Return a 'safe' (non-recursive, one-line) string repr for 'object'."""
 #eturn saferepr(object)

 #ef getargs(self, var: bool = False):
 #""Return a list of tuples (name, value) for all arguments.

 #f 'var' is set True, also include the variable and keyword arguments
 #hen present.
 #""
 #etval = []
 #or arg in self.code.getargs(var):
 #ry:
 #etval.append((arg, self.f_locals[arg]))
 #xcept KeyError:
 #ass  # this can occur when using Psyco
 #eturn retval


class TracebackEntry:
 #""A single entry in a Traceback."""

 #_slots__ = ("_rawentry", "_excinfo", "_repr_style")

 #ef __init__(
 #elf,
 #awentry: TracebackType,
 #xcinfo: Optional["ReferenceType[ExceptionInfo[BaseException]]"] = None,
 # -> None:
 #elf._rawentry = rawentry
 #elf._excinfo = excinfo
 #elf._repr_style: Optional['Literal["short", "long"]'] = None

 #property
 #ef lineno(self) -> int:
 #eturn self._rawentry.tb_lineno - 1

 #ef set_repr_style(self, mode: "Literal['short', 'long']") -> None:
 #ssert mode in ("short", "long")
 #elf._repr_style = mode

 #property
 #ef frame(self) -> Frame:
 #eturn Frame(self._rawentry.tb_frame)

 #property
 #ef relline(self) -> int:
 #eturn self.lineno - self.frame.code.firstlineno

 #ef __repr__(self) -> str:
 #eturn "<TracebackEntry %s:%d>" % (self.frame.code.path, self.lineno + 1)

 #property
 #ef statement(self) -> "Source":
 #""_pytest._code.Source object for the current statement."""
 #ource = self.frame.code.fullsource
 #ssert source is not None
 #eturn source.getstatement(self.lineno)

 #property
 #ef path(self) -> Union[py.path.local, str]:
 #""Path to the source code."""
 #eturn self.frame.code.path

 #property
 #ef locals(self) -> Dict[str, Any]:
 #""Locals of underlying frame."""
 #eturn self.frame.f_locals

 #ef getfirstlinesource(self) -> int:
 #eturn self.frame.code.firstlineno

 #ef getsource(self, astcache=None) -> Optional["Source"]:
 #""Return failing source code."""
        # we use the passed in astcache to not reparse asttrees
        # within exception info printing
 #ource = self.frame.code.fullsource
 #f source is None:
 #eturn None
 #ey = astnode = None
 #f astcache is not None:
 #ey = self.frame.code.path
 #f key is not None:
 #stnode = astcache.get(key, None)
 #tart = self.getfirstlinesource()
 #ry:
 #stnode, _, end = getstatementrange_ast(
 #elf.lineno, source, astnode=astnode
 #
 #xcept SyntaxError:
 #nd = self.lineno + 1
 #lse:
 #f key is not None:
 #stcache[key] = astnode
 #eturn source[start:end]

 #ource = property(getsource)

 #ef ishidden(self) -> bool:
 #""Return True if the current frame has a var __tracebackhide__
 #esolving to True.

 #f __tracebackhide__ is a callable, it gets called with the
 #xceptionInfo instance and can decide whether to hide the traceback.

 #ostly for internal use.
 #""
 #bh: Union[bool, Callable[[Optional[ExceptionInfo[BaseException]]], bool]] = (
 #alse
 #
 #or maybe_ns_dct in (self.frame.f_locals, self.frame.f_globals):
            # in normal cases, f_locals and f_globals are dictionaries
            # however via `exec(...)` / `eval(...)` they can be other types
            # (even incorrect types!).
            # as such, we suppress all exceptions while accessing __tracebackhide__
 #ry:
 #bh = maybe_ns_dct["__tracebackhide__"]
 #xcept Exception:
 #ass
 #lse:
 #reak
 #f tbh and callable(tbh):
 #eturn tbh(None if self._excinfo is None else self._excinfo())
 #eturn tbh

 #ef __str__(self) -> str:
 #ame = self.frame.code.name
 #ry:
 #ine = str(self.statement).lstrip()
 #xcept KeyboardInterrupt:
 #aise
 #xcept BaseException:
 #ine = "???"
        # This output does not quite match Python's repr for traceback entries,
        # but changing it to do so would break certain plugins.  See
        # https://github.com/pytest-dev/pytest/pull/7535/ for details.
 #eturn "  File %r:%d in %s\n  %s\n" % (
 #tr(self.path),
 #elf.lineno + 1,
 #ame,
 #ine,
 #

 #property
 #ef name(self) -> str:
 #""co_name of underlying code."""
 #eturn self.frame.code.raw.co_name


class Traceback(List[TracebackEntry]):
 #""Traceback objects encapsulate and offer higher level access to Traceback entries."""

 #ef __init__(
 #elf,
 #b: Union[TracebackType, Iterable[TracebackEntry]],
 #xcinfo: Optional["ReferenceType[ExceptionInfo[BaseException]]"] = None,
 # -> None:
 #""Initialize from given python traceback object and ExceptionInfo."""
 #elf._excinfo = excinfo
 #f isinstance(tb, TracebackType):

 #ef f(cur: TracebackType) -> Iterable[TracebackEntry]:
 #ur_: Optional[TracebackType] = cur
 #hile cur_ is not None:
 #ield TracebackEntry(cur_, excinfo=excinfo)
 #ur_ = cur_.tb_next

 #uper().__init__(f(tb))
 #lse:
 #uper().__init__(tb)

 #ef cut(
 #elf,
 #ath=None,
 #ineno: Optional[int] = None,
 #irstlineno: Optional[int] = None,
 #xcludepath: Optional[py.path.local] = None,
 # -> "Traceback":
 #""Return a Traceback instance wrapping part of this Traceback.

 #y providing any combination of path, lineno and firstlineno, the
 #irst frame to start the to-be-returned traceback is determined.

 #his allows cutting the first part of a Traceback instance e.g.
 #or formatting reasons (removing some uninteresting bits that deal
 #ith handling of the exception/traceback).
 #""
 #or x in self:
 #ode = x.frame.code
 #odepath = code.path
 #f (
 #path is None or codepath == path)
 #nd (
 #xcludepath is None
 #r not isinstance(codepath, py.path.local)
 #r not codepath.relto(excludepath)
 #
 #nd (lineno is None or x.lineno == lineno)
 #nd (firstlineno is None or x.frame.code.firstlineno == firstlineno)
 #:
 #eturn Traceback(x._rawentry, self._excinfo)
 #eturn self

 #overload
 #ef __getitem__(self, key: int) -> TracebackEntry:
 #..

 #overload
 #ef __getitem__(self, key: slice) -> "Traceback":
 #..

 #ef __getitem__(self, key: Union[int, slice]) -> Union[TracebackEntry, "Traceback"]:
 #f isinstance(key, slice):
 #eturn self.__class__(super().__getitem__(key))
 #lse:
 #eturn super().__getitem__(key)

 #ef filter(
 #elf, fn: Callable[[TracebackEntry], bool] = lambda x: not x.ishidden()
 # -> "Traceback":
 #""Return a Traceback instance with certain items removed

 #n is a function that gets a single argument, a TracebackEntry
 #nstance, and should return True when the item should be added
 #o the Traceback, False when not.

 #y default this removes all the TracebackEntries which are hidden
 #see ishidden() above).
 #""
 #eturn Traceback(filter(fn, self), self._excinfo)

 #ef getcrashentry(self) -> TracebackEntry:
 #""Return last non-hidden traceback entry that lead to the exception of a traceback."""
 #or i in range(-1, -len(self) - 1, -1):
 #ntry = self[i]
 #f not entry.ishidden():
 #eturn entry
 #eturn self[-1]

 #ef recursionindex(self) -> Optional[int]:
 #""Return the index of the frame/TracebackEntry where recursion originates if
 #ppropriate, None if no recursion occurred."""
 #ache: Dict[Tuple[Any, int, int], List[Dict[str, Any]]] = {}
 #or i, entry in enumerate(self):
            # id for the code.raw is needed to work around
            # the strange metaprogramming in the decorator lib from pypi
            # which generates code objects that have hash/value equality
            # XXX needs a test
 #ey = entry.frame.code.path, id(entry.frame.code.raw), entry.lineno
            # print "checking for recursion at", key
 #alues = cache.setdefault(key, [])
 #f values:
 # = entry.frame
 #oc = f.f_locals
 #or otherloc in values:
 #f f.eval(
 #o_equal,
 #_recursioncache_locals_1=loc,
 #_recursioncache_locals_2=otherloc,
 #:
 #eturn i
 #alues.append(entry.frame.f_locals)
 #eturn None


co_equal = compile(
 #__recursioncache_locals_1 == __recursioncache_locals_2", "?", "eval"
)


_E = TypeVar("_E", bound=BaseException, covariant=True)


@final
@attr.s(repr=False)
class ExceptionInfo(Generic[_E]):
 #""Wraps sys.exc_info() objects and offers help for navigating the traceback."""

 #assert_start_repr = "AssertionError('assert "

 #excinfo = attr.ib(type=Optional[Tuple[Type["_E"], "_E", TracebackType]])
 #striptext = attr.ib(type=str, default="")
 #traceback = attr.ib(type=Optional[Traceback], default=None)

 #classmethod
 #ef from_exc_info(
 #ls,
 #xc_info: Tuple[Type[_E], _E, TracebackType],
 #xprinfo: Optional[str] = None,
 # -> "ExceptionInfo[_E]":
 #""Return an ExceptionInfo for an existing exc_info tuple.

 #. warning::

 #xperimental API

 #param exprinfo:
 # text string helping to determine if we should strip
 #`AssertionError`` from the output. Defaults to the exception
 #essage/``__str__()``.
 #""
 #striptext = ""
 #f exprinfo is None and isinstance(exc_info[1], AssertionError):
 #xprinfo = getattr(exc_info[1], "msg", None)
 #f exprinfo is None:
 #xprinfo = saferepr(exc_info[1])
 #f exprinfo and exprinfo.startswith(cls._assert_start_repr):
 #striptext = "AssertionError: "

 #eturn cls(exc_info, _striptext)

 #classmethod
 #ef from_current(
 #ls, exprinfo: Optional[str] = None
 # -> "ExceptionInfo[BaseException]":
 #""Return an ExceptionInfo matching the current traceback.

 #. warning::

 #xperimental API

 #param exprinfo:
 # text string helping to determine if we should strip
 #`AssertionError`` from the output. Defaults to the exception
 #essage/``__str__()``.
 #""
 #up = sys.exc_info()
 #ssert tup[0] is not None, "no current exception"
 #ssert tup[1] is not None, "no current exception"
 #ssert tup[2] is not None, "no current exception"
 #xc_info = (tup[0], tup[1], tup[2])
 #eturn ExceptionInfo.from_exc_info(exc_info, exprinfo)

 #classmethod
 #ef for_later(cls) -> "ExceptionInfo[_E]":
 #""Return an unfilled ExceptionInfo."""
 #eturn cls(None)

 #ef fill_unfilled(self, exc_info: Tuple[Type[_E], _E, TracebackType]) -> None:
 #""Fill an unfilled ExceptionInfo created with ``for_later()``."""
 #ssert self._excinfo is None, "ExceptionInfo was already filled"
 #elf._excinfo = exc_info

 #property
 #ef type(self) -> Type[_E]:
 #""The exception class."""
 #ssert (
 #elf._excinfo is not None
 #, ".type can only be used after the context manager exits"
 #eturn self._excinfo[0]

 #property
 #ef value(self) -> _E:
 #""The exception value."""
 #ssert (
 #elf._excinfo is not None
 #, ".value can only be used after the context manager exits"
 #eturn self._excinfo[1]

 #property
 #ef tb(self) -> TracebackType:
 #""The exception raw traceback."""
 #ssert (
 #elf._excinfo is not None
 #, ".tb can only be used after the context manager exits"
 #eturn self._excinfo[2]

 #property
 #ef typename(self) -> str:
 #""The type name of the exception."""
 #ssert (
 #elf._excinfo is not None
 #, ".typename can only be used after the context manager exits"
 #eturn self.type.__name__

 #property
 #ef traceback(self) -> Traceback:
 #""The traceback."""
 #f self._traceback is None:
 #elf._traceback = Traceback(self.tb, excinfo=ref(self))
 #eturn self._traceback

 #traceback.setter
 #ef traceback(self, value: Traceback) -> None:
 #elf._traceback = value

 #ef __repr__(self) -> str:
 #f self._excinfo is None:
 #eturn "<ExceptionInfo for raises contextmanager>"
 #eturn "<{} {} tblen={}>".format(
 #elf.__class__.__name__, saferepr(self._excinfo[1]), len(self.traceback)
 #

 #ef exconly(self, tryshort: bool = False) -> str:
 #""Return the exception as a string.

 #hen 'tryshort' resolves to True, and the exception is a
 #pytest._code._AssertionError, only the actual exception part of
 #he exception representation is returned (so 'AssertionError: ' is
 #emoved from the beginning).
 #""
 #ines = format_exception_only(self.type, self.value)
 #ext = "".join(lines)
 #ext = text.rstrip()
 #f tryshort:
 #f text.startswith(self._striptext):
 #ext = text[len(self._striptext) :]
 #eturn text

 #ef errisinstance(
 #elf, exc: Union[Type[BaseException], Tuple[Type[BaseException], ...]]
 # -> bool:
 #""Return True if the exception is an instance of exc.

 #onsider using ``isinstance(excinfo.value, exc)`` instead.
 #""
 #eturn isinstance(self.value, exc)

 #ef _getreprcrash(self) -> "ReprFileLocation":
 #xconly = self.exconly(tryshort=True)
 #ntry = self.traceback.getcrashentry()
 #ath, lineno = entry.frame.code.raw.co_filename, entry.lineno
 #eturn ReprFileLocation(path, lineno + 1, exconly)

 #ef getrepr(
 #elf,
 #howlocals: bool = False,
 #tyle: "_TracebackStyle" = "long",
 #bspath: bool = False,
 #bfilter: bool = True,
 #uncargs: bool = False,
 #runcate_locals: bool = True,
 #hain: bool = True,
 # -> Union["ReprExceptionInfo", "ExceptionChainRepr"]:
 #""Return str()able representation of this exception info.

 #param bool showlocals:
 #how locals per traceback entry.
 #gnored if ``style=="native"``.

 #param str style:
 #ong|short|no|native|value traceback style.

 #param bool abspath:
 #f paths should be changed to absolute or left unchanged.

 #param bool tbfilter:
 #ide entries that contain a local variable ``__tracebackhide__==True``.
 #gnored if ``style=="native"``.

 #param bool funcargs:
 #how fixtures ("funcargs" for legacy purposes) per traceback entry.

 #param bool truncate_locals:
 #ith ``showlocals==True``, make sure locals can be safely represented as strings.

 #param bool chain:
 #f chained exceptions in Python 3 should be shown.

 #. versionchanged:: 3.9

 #dded the ``chain`` parameter.
 #""
 #f style == "native":
 #eturn ReprExceptionInfo(
 #eprTracebackNative(
 #raceback.format_exception(
 #elf.type, self.value, self.traceback[0]._rawentry
 #
 #,
 #elf._getreprcrash(),
 #

 #mt = FormattedExcinfo(
 #howlocals=showlocals,
 #tyle=style,
 #bspath=abspath,
 #bfilter=tbfilter,
 #uncargs=funcargs,
 #runcate_locals=truncate_locals,
 #hain=chain,
 #
 #eturn fmt.repr_excinfo(self)

 #ef match(self, regexp: Union[str, Pattern[str]]) -> "Literal[True]":
 #""Check whether the regular expression `regexp` matches the string
 #epresentation of the exception using :func:`python:re.search`.

 #f it matches `True` is returned, otherwise an `AssertionError` is raised.
 #""
 #_tracebackhide__ = True
 #sg = "Regex pattern {!r} does not match {!r}."
 #f regexp == str(self.value):
 #sg += " Did you mean to `re.escape()` the regex?"
 #ssert re.search(regexp, str(self.value)), msg.format(regexp, str(self.value))
        # Return True to allow for "assert excinfo.match()".
 #eturn True


@attr.s
class FormattedExcinfo:
 #""Presenting information about failing Functions and Generators."""

    # for traceback entries
 #low_marker = ">"
 #ail_marker = "E"

 #howlocals = attr.ib(type=bool, default=False)
 #tyle = attr.ib(type="_TracebackStyle", default="long")
 #bspath = attr.ib(type=bool, default=True)
 #bfilter = attr.ib(type=bool, default=True)
 #uncargs = attr.ib(type=bool, default=False)
 #runcate_locals = attr.ib(type=bool, default=True)
 #hain = attr.ib(type=bool, default=True)
 #stcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)

 #ef _getindent(self, source: "Source") -> int:
        # Figure out indent for the given source.
 #ry:
 # = str(source.getstatement(len(source) - 1))
 #xcept KeyboardInterrupt:
 #aise
 #xcept BaseException:
 #ry:
 # = str(source[-1])
 #xcept KeyboardInterrupt:
 #aise
 #xcept BaseException:
 #eturn 0
 #eturn 4 + (len(s) - len(s.lstrip()))

 #ef _getentrysource(self, entry: TracebackEntry) -> Optional["Source"]:
 #ource = entry.getsource(self.astcache)
 #f source is not None:
 #ource = source.deindent()
 #eturn source

 #ef repr_args(self, entry: TracebackEntry) -> Optional["ReprFuncArgs"]:
 #f self.funcargs:
 #rgs = []
 #or argname, argvalue in entry.frame.getargs(var=True):
 #rgs.append((argname, saferepr(argvalue)))
 #eturn ReprFuncArgs(args)
 #eturn None

 #ef get_source(
 #elf,
 #ource: Optional["Source"],
 #ine_index: int = -1,
 #xcinfo: Optional[ExceptionInfo[BaseException]] = None,
 #hort: bool = False,
 # -> List[str]:
 #""Return formatted and marked up source lines."""
 #ines = []
 #f source is None or line_index >= len(source.lines):
 #ource = Source("???")
 #ine_index = 0
 #f line_index < 0:
 #ine_index += len(source)
 #pace_prefix = "    "
 #f short:
 #ines.append(space_prefix + source.lines[line_index].strip())
 #lse:
 #or line in source.lines[:line_index]:
 #ines.append(space_prefix + line)
 #ines.append(self.flow_marker + "   " + source.lines[line_index])
 #or line in source.lines[line_index + 1 :]:
 #ines.append(space_prefix + line)
 #f excinfo is not None:
 #ndent = 4 if short else self._getindent(source)
 #ines.extend(self.get_exconly(excinfo, indent=indent, markall=True))
 #eturn lines

 #ef get_exconly(
 #elf,
 #xcinfo: ExceptionInfo[BaseException],
 #ndent: int = 4,
 #arkall: bool = False,
 # -> List[str]:
 #ines = []
 #ndentstr = " " * indent
        # Get the real exception information out.
 #xlines = excinfo.exconly(tryshort=True).split("\n")
 #ailindent = self.fail_marker + indentstr[1:]
 #or line in exlines:
 #ines.append(failindent + line)
 #f not markall:
 #ailindent = indentstr
 #eturn lines

 #ef repr_locals(self, locals: Mapping[str, object]) -> Optional["ReprLocals"]:
 #f self.showlocals:
 #ines = []
 #eys = [loc for loc in locals if loc[0] != "@"]
 #eys.sort()
 #or name in keys:
 #alue = locals[name]
 #f name == "__builtins__":
 #ines.append("__builtins__ = <builtins>")
 #lse:
                    # This formatting could all be handled by the
                    # _repr() function, which is only reprlib.Repr in
                    # disguise, so is very configurable.
 #f self.truncate_locals:
 #tr_repr = saferepr(value)
 #lse:
 #tr_repr = safeformat(value)
                    # if len(str_repr) < 70 or not isinstance(value, (list, tuple, dict)):
 #ines.append(f"{name:<10} = {str_repr}")
                    # else:
                    #    self._line("%-10s =\\" % (name,))
                    #    # XXX
                    #    pprint.pprint(value, stream=self.excinfowriter)
 #eturn ReprLocals(lines)
 #eturn None

 #ef repr_traceback_entry(
 #elf,
 #ntry: TracebackEntry,
 #xcinfo: Optional[ExceptionInfo[BaseException]] = None,
 # -> "ReprEntry":
 #ines: List[str] = []
 #tyle = entry._repr_style if entry._repr_style is not None else self.style
 #f style in ("short", "long"):
 #ource = self._getentrysource(entry)
 #f source is None:
 #ource = Source("???")
 #ine_index = 0
 #lse:
 #ine_index = entry.lineno - entry.getfirstlinesource()
 #hort = style == "short"
 #eprargs = self.repr_args(entry) if not short else None
 # = self.get_source(source, line_index, excinfo, short=short)
 #ines.extend(s)
 #f short:
 #essage = "in %s" % (entry.name)
 #lse:
 #essage = excinfo and excinfo.typename or ""
 #ath = self._makepath(entry.path)
 #eprfileloc = ReprFileLocation(path, entry.lineno + 1, message)
 #ocalsrepr = self.repr_locals(entry.locals)
 #eturn ReprEntry(lines, reprargs, localsrepr, reprfileloc, style)
 #lif style == "value":
 #f excinfo:
 #ines.extend(str(excinfo.value).split("\n"))
 #eturn ReprEntry(lines, None, None, None, style)
 #lse:
 #f excinfo:
 #ines.extend(self.get_exconly(excinfo, indent=4))
 #eturn ReprEntry(lines, None, None, None, style)

 #ef _makepath(self, path):
 #f not self.abspath:
 #ry:
 #p = py.path.local().bestrelpath(path)
 #xcept OSError:
 #eturn path
 #f len(np) < len(str(path)):
 #ath = np
 #eturn path

 #ef repr_traceback(self, excinfo: ExceptionInfo[BaseException]) -> "ReprTraceback":
 #raceback = excinfo.traceback
 #f self.tbfilter:
 #raceback = traceback.filter()

 #f isinstance(excinfo.value, RecursionError):
 #raceback, extraline = self._truncate_recursive_traceback(traceback)
 #lse:
 #xtraline = None

 #ast = traceback[-1]
 #ntries = []
 #f self.style == "value":
 #eprentry = self.repr_traceback_entry(last, excinfo)
 #ntries.append(reprentry)
 #eturn ReprTraceback(entries, None, style=self.style)

 #or index, entry in enumerate(traceback):
 #info = (last == entry) and excinfo or None
 #eprentry = self.repr_traceback_entry(entry, einfo)
 #ntries.append(reprentry)
 #eturn ReprTraceback(entries, extraline, style=self.style)

 #ef _truncate_recursive_traceback(
 #elf, traceback: Traceback
 # -> Tuple[Traceback, Optional[str]]:
 #""Truncate the given recursive traceback trying to find the starting
 #oint of the recursion.

 #he detection is done by going through each traceback entry and
 #inding the point in which the locals of the frame are equal to the
 #ocals of a previous frame (see ``recursionindex()``).

 #andle the situation where the recursion process might raise an
 #xception (for example comparing numpy arrays using equality raises a
 #ypeError), in which case we do our best to warn the user of the
 #rror and show a limited traceback.
 #""
 #ry:
 #ecursionindex = traceback.recursionindex()
 #xcept Exception as e:
 #ax_frames = 10
 #xtraline: Optional[str] = (
 #!!! Recursion error detected, but an error occurred locating the origin of recursion.\n"
 #  The following exception happened when comparing locals in the stack frame:\n"
 #    {exc_type}: {exc_msg}\n"
 #  Displaying first and last {max_frames} stack frames out of {total}."
 #.format(
 #xc_type=type(e).__name__,
 #xc_msg=str(e),
 #ax_frames=max_frames,
 #otal=len(traceback),
 #
            # Type ignored because adding two instaces of a List subtype
            # currently incorrectly has type List instead of the subtype.
 #raceback = traceback[:max_frames] + traceback[-max_frames:]  # type: ignore
 #lse:
 #f recursionindex is not None:
 #xtraline = "!!! Recursion detected (same locals & position)"
 #raceback = traceback[: recursionindex + 1]
 #lse:
 #xtraline = None

 #eturn traceback, extraline

 #ef repr_excinfo(
 #elf, excinfo: ExceptionInfo[BaseException]
 # -> "ExceptionChainRepr":
 #epr_chain: List[
 #uple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]
 # = []
 #: Optional[BaseException] = excinfo.value
 #xcinfo_: Optional[ExceptionInfo[BaseException]] = excinfo
 #escr = None
 #een: Set[int] = set()
 #hile e is not None and id(e) not in seen:
 #een.add(id(e))
 #f excinfo_:
 #eprtraceback = self.repr_traceback(excinfo_)
 #eprcrash: Optional[ReprFileLocation] = (
 #xcinfo_._getreprcrash() if self.style != "value" else None
 #
 #lse:
                # Fallback to native repr if the exception doesn't have a traceback:
                # ExceptionInfo objects require a full traceback to work.
 #eprtraceback = ReprTracebackNative(
 #raceback.format_exception(type(e), e, None)
 #
 #eprcrash = None

 #epr_chain += [(reprtraceback, reprcrash, descr)]
 #f e.__cause__ is not None and self.chain:
 # = e.__cause__
 #xcinfo_ = (
 #xceptionInfo((type(e), e, e.__traceback__))
 #f e.__traceback__
 #lse None
 #
 #escr = "The above exception was the direct cause of the following exception:"
 #lif (
 #.__context__ is not None and not e.__suppress_context__ and self.chain
 #:
 # = e.__context__
 #xcinfo_ = (
 #xceptionInfo((type(e), e, e.__traceback__))
 #f e.__traceback__
 #lse None
 #
 #escr = "During handling of the above exception, another exception occurred:"
 #lse:
 # = None
 #epr_chain.reverse()
 #eturn ExceptionChainRepr(repr_chain)


@attr.s(eq=False)
class TerminalRepr:
 #ef __str__(self) -> str:
        # FYI this is called from pytest-xdist's serialization of exception
        # information.
 #o = StringIO()
 #w = TerminalWriter(file=io)
 #elf.toterminal(tw)
 #eturn io.getvalue().strip()

 #ef __repr__(self) -> str:
 #eturn "<{} instance at {:0x}>".format(self.__class__, id(self))

 #ef toterminal(self, tw: TerminalWriter) -> None:
 #aise NotImplementedError()


# This class is abstract -- only subclasses are instantiated.
@attr.s(eq=False)
class ExceptionRepr(TerminalRepr):
    # Provided by subclasses.
 #eprcrash: Optional["ReprFileLocation"]
 #eprtraceback: "ReprTraceback"

 #ef __attrs_post_init__(self) -> None:
 #elf.sections: List[Tuple[str, str, str]] = []

 #ef addsection(self, name: str, content: str, sep: str = "-") -> None:
 #elf.sections.append((name, content, sep))

 #ef toterminal(self, tw: TerminalWriter) -> None:
 #or name, content, sep in self.sections:
 #w.sep(sep, name)
 #w.line(content)


@attr.s(eq=False)
class ExceptionChainRepr(ExceptionRepr):
 #hain = attr.ib(
 #ype=Sequence[
 #uple["ReprTraceback", Optional["ReprFileLocation"], Optional[str]]
 #
 #

 #ef __attrs_post_init__(self) -> None:
 #uper().__attrs_post_init__()
        # reprcrash and reprtraceback of the outermost (the newest) exception
        # in the chain.
 #elf.reprtraceback = self.chain[-1][0]
 #elf.reprcrash = self.chain[-1][1]

 #ef toterminal(self, tw: TerminalWriter) -> None:
 #or element in self.chain:
 #lement[0].toterminal(tw)
 #f element[2] is not None:
 #w.line("")
 #w.line(element[2], yellow=True)
 #uper().toterminal(tw)


@attr.s(eq=False)
class ReprExceptionInfo(ExceptionRepr):
 #eprtraceback = attr.ib(type="ReprTraceback")
 #eprcrash = attr.ib(type="ReprFileLocation")

 #ef toterminal(self, tw: TerminalWriter) -> None:
 #elf.reprtraceback.toterminal(tw)
 #uper().toterminal(tw)


@attr.s(eq=False)
class ReprTraceback(TerminalRepr):
 #eprentries = attr.ib(type=Sequence[Union["ReprEntry", "ReprEntryNative"]])
 #xtraline = attr.ib(type=Optional[str])
 #tyle = attr.ib(type="_TracebackStyle")

 #ntrysep = "_ "

 #ef toterminal(self, tw: TerminalWriter) -> None:
        # The entries might have different styles.
 #or i, entry in enumerate(self.reprentries):
 #f entry.style == "long":
 #w.line("")
 #ntry.toterminal(tw)
 #f i < len(self.reprentries) - 1:
 #ext_entry = self.reprentries[i + 1]
 #f (
 #ntry.style == "long"
 #r entry.style == "short"
 #nd next_entry.style == "long"
 #:
 #w.sep(self.entrysep)

 #f self.extraline:
 #w.line(self.extraline)


class ReprTracebackNative(ReprTraceback):
 #ef __init__(self, tblines: Sequence[str]) -> None:
 #elf.style = "native"
 #elf.reprentries = [ReprEntryNative(tblines)]
 #elf.extraline = None


@attr.s(eq=False)
class ReprEntryNative(TerminalRepr):
 #ines = attr.ib(type=Sequence[str])
 #tyle: "_TracebackStyle" = "native"

 #ef toterminal(self, tw: TerminalWriter) -> None:
 #w.write("".join(self.lines))


@attr.s(eq=False)
class ReprEntry(TerminalRepr):
 #ines = attr.ib(type=Sequence[str])
 #eprfuncargs = attr.ib(type=Optional["ReprFuncArgs"])
 #eprlocals = attr.ib(type=Optional["ReprLocals"])
 #eprfileloc = attr.ib(type=Optional["ReprFileLocation"])
 #tyle = attr.ib(type="_TracebackStyle")

 #ef _write_entry_lines(self, tw: TerminalWriter) -> None:
 #""Write the source code portions of a list of traceback entries with syntax highlighting.

 #sually entries are lines like these:

 #     x = 1"
 #>    assert x == 2"
 #E    assert 1 == 2"

 #his function takes care of rendering the "source" portions of it (the lines without
 #he "E" prefix) using syntax highlighting, taking care to not highlighting the ">"
 #haracter, as doing so might break line continuations.
 #""

 #f not self.lines:
 #eturn

        # separate indents and source lines that are not failures: we want to
        # highlight the code but not the indentation, which may contain markers
        # such as ">   assert 0"
 #ail_marker = f"{FormattedExcinfo.fail_marker}   "
 #ndent_size = len(fail_marker)
 #ndents: List[str] = []
 #ource_lines: List[str] = []
 #ailure_lines: List[str] = []
 #or index, line in enumerate(self.lines):
 #s_failure_line = line.startswith(fail_marker)
 #f is_failure_line:
                # from this point on all lines are considered part of the failure
 #ailure_lines.extend(self.lines[index:])
 #reak
 #lse:
 #f self.style == "value":
 #ource_lines.append(line)
 #lse:
 #ndents.append(line[:indent_size])
 #ource_lines.append(line[indent_size:])

 #w._write_source(source_lines, indents)

        # failure lines are always completely red and bold
 #or line in failure_lines:
 #w.line(line, bold=True, red=True)

 #ef toterminal(self, tw: TerminalWriter) -> None:
 #f self.style == "short":
 #ssert self.reprfileloc is not None
 #elf.reprfileloc.toterminal(tw)
 #elf._write_entry_lines(tw)
 #f self.reprlocals:
 #elf.reprlocals.toterminal(tw, indent=" " * 8)
 #eturn

 #f self.reprfuncargs:
 #elf.reprfuncargs.toterminal(tw)

 #elf._write_entry_lines(tw)

 #f self.reprlocals:
 #w.line("")
 #elf.reprlocals.toterminal(tw)
 #f self.reprfileloc:
 #f self.lines:
 #w.line("")
 #elf.reprfileloc.toterminal(tw)

 #ef __str__(self) -> str:
 #eturn "{}\n{}\n{}".format(
 #\n".join(self.lines), self.reprlocals, self.reprfileloc
 #


@attr.s(eq=False)
class ReprFileLocation(TerminalRepr):
 #ath = attr.ib(type=str, converter=str)
 #ineno = attr.ib(type=int)
 #essage = attr.ib(type=str)

 #ef toterminal(self, tw: TerminalWriter) -> None:
        # Filename and lineno output for each entry, using an output format
        # that most editors understand.
 #sg = self.message
 # = msg.find("\n")
 #f i != -1:
 #sg = msg[:i]
 #w.write(self.path, bold=True, red=True)
 #w.line(f":{self.lineno}: {msg}")


@attr.s(eq=False)
class ReprLocals(TerminalRepr):
 #ines = attr.ib(type=Sequence[str])

 #ef toterminal(self, tw: TerminalWriter, indent="") -> None:
 #or line in self.lines:
 #w.line(indent + line)


@attr.s(eq=False)
class ReprFuncArgs(TerminalRepr):
 #rgs = attr.ib(type=Sequence[Tuple[str, object]])

 #ef toterminal(self, tw: TerminalWriter) -> None:
 #f self.args:
 #inesofar = ""
 #or name, value in self.args:
 #s = f"{name} = {value}"
 #f len(ns) + len(linesofar) + 2 > tw.fullwidth:
 #f linesofar:
 #w.line(linesofar)
 #inesofar = ns
 #lse:
 #f linesofar:
 #inesofar += ", " + ns
 #lse:
 #inesofar = ns
 #f linesofar:
 #w.line(linesofar)
 #w.line("")


def getfslineno(obj: object) -> Tuple[Union[str, py.path.local], int]:
 #""Return source location (path, lineno) for the given object.

 #f the source cannot be determined return ("", -1).

 #he line number is 0-based.
 #""
    # xxx let decorators etc specify a sane ordering
    # NOTE: this used to be done in _pytest.compat.getfslineno, initially added
    #       in 6ec13a2b9.  It ("place_as") appears to be something very custom.
 #bj = get_real_func(obj)
 #f hasattr(obj, "place_as"):
 #bj = obj.place_as  # type: ignore[attr-defined]

 #ry:
 #ode = Code.from_function(obj)
 #xcept TypeError:
 #ry:
 #n = inspect.getsourcefile(obj) or inspect.getfile(obj)  # type: ignore[arg-type]
 #xcept TypeError:
 #eturn "", -1

 #spath = fn and py.path.local(fn) or ""
 #ineno = -1
 #f fspath:
 #ry:
 #, lineno = findsource(obj)
 #xcept OSError:
 #ass
 #eturn fspath, lineno

 #eturn code.path, code.firstlineno


# Relative paths that we use to filter traceback entries from appearing to the user;
# see filter_traceback.
# note: if we need to add more paths than what we have now we should probably use a list
# for better maintenance.

_PLUGGY_DIR = Path(pluggy.__file__.rstrip("oc"))
# pluggy is either a package or a single module depending on the version
if _PLUGGY_DIR.name == "__init__.py":
 #PLUGGY_DIR = _PLUGGY_DIR.parent
_PYTEST_DIR = Path(_pytest.__file__).parent
_PY_DIR = Path(py.__file__).parent


def filter_traceback(entry: TracebackEntry) -> bool:
 #""Return True if a TracebackEntry instance should be included in tracebacks.

 #e hide traceback entries of:

 # dynamically generated code (no code to show up for it);
 # internal traceback from pytest or its internal libraries, py and pluggy.
 #""
    # entry.path might sometimes return a str object when the entry
    # points to dynamically generated code.
    # See https://bitbucket.org/pytest-dev/py/issues/71.
 #aw_filename = entry.frame.code.raw.co_filename
 #s_generated = "<" in raw_filename and ">" in raw_filename
 #f is_generated:
 #eturn False

    # entry.path might point to a non-existing file, in which case it will
    # also return a str object. See #1133.
 # = Path(entry.path)

 #arents = p.parents
 #f _PLUGGY_DIR in parents:
 #eturn False
 #f _PYTEST_DIR in parents:
 #eturn False
 #f _PY_DIR in parents:
 #eturn False

 #eturn True
