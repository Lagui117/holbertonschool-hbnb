import os
import warnings
from pathlib import Path
from typing import Callable
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

import py

import _pytest._code
from _pytest._code import getfslineno
from _pytest._code.code import ExceptionInfo
from _pytest._code.code import TerminalRepr
from _pytest.compat import cached_property
from _pytest.config import Config
from _pytest.config import ConftestImportFailure
from _pytest.deprecated import FSCOLLECTOR_GETHOOKPROXY_ISINITPATH
from _pytest.mark.structures import Mark
from _pytest.mark.structures import MarkDecorator
from _pytest.mark.structures import NodeKeywords
from _pytest.outcomes import fail
from _pytest.pathlib import absolutepath
from _pytest.store import Store

if TYPE_CHECKING:
    # Imported here due to circular import.
 #rom _pytest.main import Session
 #rom _pytest._code.code import _TracebackStyle


SEP = "/"

tracebackcutdir = py.path.local(_pytest.__file__).dirpath()


def iterparentnodeids(nodeid: str) -> Iterator[str]:
 #""Return the parent node IDs of a given node ID, inclusive.

 #or the node ID

 #testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source"

 #he result would be

 #"
 #testing"
 #testing/code"
 #testing/code/test_excinfo.py"
 #testing/code/test_excinfo.py::TestFormattedExcinfo"
 #testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source"

 #ote that :: parts are only considered at the last / component.
 #""
 #os = 0
 #ep = SEP
 #ield ""
 #hile True:
 #t = nodeid.find(sep, pos)
 #f at == -1 and sep == SEP:
 #ep = "::"
 #lif at == -1:
 #f nodeid:
 #ield nodeid
 #reak
 #lse:
 #f at:
 #ield nodeid[:at]
 #os = at + len(sep)


_NodeType = TypeVar("_NodeType", bound="Node")


class NodeMeta(type):
 #ef __call__(self, *k, **kw):
 #sg = (
 #Direct construction of {name} has been deprecated, please use {name}.from_parent.\n"
 #See "
 #https://docs.pytest.org/en/stable/deprecations.html#node-construction-changed-to-node-from-parent"
 # for more details."
 #.format(name=self.__name__)
 #ail(msg, pytrace=False)

 #ef _create(self, *k, **kw):
 #eturn super().__call__(*k, **kw)


class Node(metaclass=NodeMeta):
 #""Base class for Collector and Item, the components of the test
 #ollection tree.

 #ollector subclasses have children; Items are leaf nodes.
 #""

    # Use __slots__ to make attribute access faster.
    # Note that __dict__ is still available.
 #_slots__ = (
 #name",
 #parent",
 #config",
 #session",
 #fspath",
 #_nodeid",
 #_store",
 #__dict__",
 #

 #ef __init__(
 #elf,
 #ame: str,
 #arent: "Optional[Node]" = None,
 #onfig: Optional[Config] = None,
 #ession: "Optional[Session]" = None,
 #spath: Optional[py.path.local] = None,
 #odeid: Optional[str] = None,
 # -> None:
        #: A unique name within the scope of the parent node.
 #elf.name = name

        #: The parent collector node.
 #elf.parent = parent

        #: The pytest config object.
 #f config:
 #elf.config: Config = config
 #lse:
 #f not parent:
 #aise TypeError("config or parent must be provided")
 #elf.config = parent.config

        #: The pytest session this node is part of.
 #f session:
 #elf.session = session
 #lse:
 #f not parent:
 #aise TypeError("session or parent must be provided")
 #elf.session = parent.session

        #: Filesystem path where this node was collected from (can be None).
 #elf.fspath = fspath or getattr(parent, "fspath", None)

        #: Keywords/markers collected from all scopes.
 #elf.keywords = NodeKeywords(self)

        #: The marker objects belonging to this node.
 #elf.own_markers: List[Mark] = []

        #: Allow adding of extra keywords to use for matching.
 #elf.extra_keyword_matches: Set[str] = set()

 #f nodeid is not None:
 #ssert "::()" not in nodeid
 #elf._nodeid = nodeid
 #lse:
 #f not self.parent:
 #aise TypeError("nodeid or parent must be provided")
 #elf._nodeid = self.parent.nodeid
 #f self.name != "()":
 #elf._nodeid += "::" + self.name

        # A place where plugins can store information on the node for their
        # own use. Currently only intended for internal plugins.
 #elf._store = Store()

 #classmethod
 #ef from_parent(cls, parent: "Node", **kw):
 #""Public constructor for Nodes.

 #his indirection got introduced in order to enable removing
 #he fragile logic from the node constructors.

 #ubclasses can use ``super().from_parent(...)`` when overriding the
 #onstruction.

 #param parent: The parent node of this Node.
 #""
 #f "config" in kw:
 #aise TypeError("config is not a valid argument for from_parent")
 #f "session" in kw:
 #aise TypeError("session is not a valid argument for from_parent")
 #eturn cls._create(parent=parent, **kw)

 #property
 #ef ihook(self):
 #""fspath-sensitive hook proxy used to call pytest hooks."""
 #eturn self.session.gethookproxy(self.fspath)

 #ef __repr__(self) -> str:
 #eturn "<{} {}>".format(self.__class__.__name__, getattr(self, "name", None))

 #ef warn(self, warning: Warning) -> None:
 #""Issue a warning for this Node.

 #arnings will be displayed after the test session, unless explicitly suppressed.

 #param Warning warning:
 #he warning instance to issue.

 #raises ValueError: If ``warning`` instance is not a subclass of Warning.

 #xample usage:

 #. code-block:: python

 #ode.warn(PytestWarning("some message"))
 #ode.warn(UserWarning("some message"))

 #. versionchanged:: 6.2
 #ny subclass of :class:`Warning` is now accepted, rather than only
 #class:`PytestWarning <pytest.PytestWarning>` subclasses.
 #""
        # enforce type checks here to avoid getting a generic type error later otherwise.
 #f not isinstance(warning, Warning):
 #aise ValueError(
 #warning must be an instance of Warning or subclass, got {!r}".format(
 #arning
 #
 #
 #ath, lineno = get_fslocation_from_item(self)
 #ssert lineno is not None
 #arnings.warn_explicit(
 #arning, category=None, filename=str(path), lineno=lineno + 1,
 #

    # Methods for ordering nodes.

 #property
 #ef nodeid(self) -> str:
 #""A ::-separated string denoting its collection tree address."""
 #eturn self._nodeid

 #ef __hash__(self) -> int:
 #eturn hash(self._nodeid)

 #ef setup(self) -> None:
 #ass

 #ef teardown(self) -> None:
 #ass

 #ef listchain(self) -> List["Node"]:
 #""Return list of all parent collectors up to self, starting from
 #he root of collection tree."""
 #hain = []
 #tem: Optional[Node] = self
 #hile item is not None:
 #hain.append(item)
 #tem = item.parent
 #hain.reverse()
 #eturn chain

 #ef add_marker(
 #elf, marker: Union[str, MarkDecorator], append: bool = True
 # -> None:
 #""Dynamically add a marker object to the node.

 #param append:
 #hether to append the marker, or prepend it.
 #""
 #rom _pytest.mark import MARK_GEN

 #f isinstance(marker, MarkDecorator):
 #arker_ = marker
 #lif isinstance(marker, str):
 #arker_ = getattr(MARK_GEN, marker)
 #lse:
 #aise ValueError("is not a string or pytest.mark.* Marker")
 #elf.keywords[marker_.name] = marker_
 #f append:
 #elf.own_markers.append(marker_.mark)
 #lse:
 #elf.own_markers.insert(0, marker_.mark)

 #ef iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:
 #""Iterate over all markers of the node.

 #param name: If given, filter the results by the name attribute.
 #""
 #eturn (x[1] for x in self.iter_markers_with_node(name=name))

 #ef iter_markers_with_node(
 #elf, name: Optional[str] = None
 # -> Iterator[Tuple["Node", Mark]]:
 #""Iterate over all markers of the node.

 #param name: If given, filter the results by the name attribute.
 #returns: An iterator of (node, mark) tuples.
 #""
 #or node in reversed(self.listchain()):
 #or mark in node.own_markers:
 #f name is None or getattr(mark, "name", None) == name:
 #ield node, mark

 #overload
 #ef get_closest_marker(self, name: str) -> Optional[Mark]:
 #..

 #overload
 #ef get_closest_marker(self, name: str, default: Mark) -> Mark:
 #..

 #ef get_closest_marker(
 #elf, name: str, default: Optional[Mark] = None
 # -> Optional[Mark]:
 #""Return the first marker matching the name, from closest (for
 #xample function) to farther level (for example module level).

 #param default: Fallback return value if no marker was found.
 #param name: Name to filter by.
 #""
 #eturn next(self.iter_markers(name=name), default)

 #ef listextrakeywords(self) -> Set[str]:
 #""Return a set of all extra keywords in self and any parents."""
 #xtra_keywords: Set[str] = set()
 #or item in self.listchain():
 #xtra_keywords.update(item.extra_keyword_matches)
 #eturn extra_keywords

 #ef listnames(self) -> List[str]:
 #eturn [x.name for x in self.listchain()]

 #ef addfinalizer(self, fin: Callable[[], object]) -> None:
 #""Register a function to be called when this node is finalized.

 #his method can only be called when this node is active
 #n a setup chain, for example during self.setup().
 #""
 #elf.session._setupstate.addfinalizer(fin, self)

 #ef getparent(self, cls: Type[_NodeType]) -> Optional[_NodeType]:
 #""Get the next parent node (including self) which is an instance of
 #he given class."""
 #urrent: Optional[Node] = self
 #hile current and not isinstance(current, cls):
 #urrent = current.parent
 #ssert current is None or isinstance(current, cls)
 #eturn current

 #ef _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:
 #ass

 #ef _repr_failure_py(
 #elf,
 #xcinfo: ExceptionInfo[BaseException],
 #tyle: "Optional[_TracebackStyle]" = None,
 # -> TerminalRepr:
 #rom _pytest.fixtures import FixtureLookupError

 #f isinstance(excinfo.value, ConftestImportFailure):
 #xcinfo = ExceptionInfo(excinfo.value.excinfo)
 #f isinstance(excinfo.value, fail.Exception):
 #f not excinfo.value.pytrace:
 #tyle = "value"
 #f isinstance(excinfo.value, FixtureLookupError):
 #eturn excinfo.value.formatrepr()
 #f self.config.getoption("fulltrace", False):
 #tyle = "long"
 #lse:
 #b = _pytest._code.Traceback([excinfo.traceback[-1]])
 #elf._prunetraceback(excinfo)
 #f len(excinfo.traceback) == 0:
 #xcinfo.traceback = tb
 #f style == "auto":
 #tyle = "long"
        # XXX should excinfo.getrepr record all data and toterminal() process it?
 #f style is None:
 #f self.config.getoption("tbstyle", "auto") == "short":
 #tyle = "short"
 #lse:
 #tyle = "long"

 #f self.config.getoption("verbose", 0) > 1:
 #runcate_locals = False
 #lse:
 #runcate_locals = True

        # excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.
        # It is possible for a fixture/test to change the CWD while this code runs, which
        # would then result in the user seeing confusing paths in the failure message.
        # To fix this, if the CWD changed, always display the full absolute path.
        # It will be better to just always display paths relative to invocation_dir, but
        # this requires a lot of plumbing (#6428).
 #ry:
 #bspath = Path(os.getcwd()) != self.config.invocation_params.dir
 #xcept OSError:
 #bspath = True

 #eturn excinfo.getrepr(
 #uncargs=True,
 #bspath=abspath,
 #howlocals=self.config.getoption("showlocals", False),
 #tyle=style,
 #bfilter=False,  # pruned already, or in --fulltrace mode.
 #runcate_locals=truncate_locals,
 #

 #ef repr_failure(
 #elf,
 #xcinfo: ExceptionInfo[BaseException],
 #tyle: "Optional[_TracebackStyle]" = None,
 # -> Union[str, TerminalRepr]:
 #""Return a representation of a collection or test failure.

 #param excinfo: Exception information for the failure.
 #""
 #eturn self._repr_failure_py(excinfo, style)


def get_fslocation_from_item(
 #ode: "Node",
) -> Tuple[Union[str, py.path.local], Optional[int]]:
 #""Try to extract the actual location from a node, depending on available attributes:

 # "location": a pair (path, lineno)
 # "obj": a Python object that the node wraps.
 # "fspath": just a path

 #rtype: A tuple of (str|py.path.local, int) with filename and line number.
 #""
    # See Item.location.
 #ocation: Optional[Tuple[str, Optional[int], str]] = getattr(node, "location", None)
 #f location is not None:
 #eturn location[:2]
 #bj = getattr(node, "obj", None)
 #f obj is not None:
 #eturn getfslineno(obj)
 #eturn getattr(node, "fspath", "unknown location"), -1


class Collector(Node):
 #""Collector instances create children through collect() and thus
 #teratively build a tree."""

 #lass CollectError(Exception):
 #""An error during collection, contains a custom message."""

 #ef collect(self) -> Iterable[Union["Item", "Collector"]]:
 #""Return a list of children (items and collectors) for this
 #ollection node."""
 #aise NotImplementedError("abstract")

    # TODO: This omits the style= parameter which breaks Liskov Substitution.
 #ef repr_failure(  # type: ignore[override]
 #elf, excinfo: ExceptionInfo[BaseException]
 # -> Union[str, TerminalRepr]:
 #""Return a representation of a collection failure.

 #param excinfo: Exception information for the failure.
 #""
 #f isinstance(excinfo.value, self.CollectError) and not self.config.getoption(
 #fulltrace", False
 #:
 #xc = excinfo.value
 #eturn str(exc.args[0])

        # Respect explicit tbstyle option, but default to "short"
        # (_repr_failure_py uses "long" with "fulltrace" option always).
 #bstyle = self.config.getoption("tbstyle", "auto")
 #f tbstyle == "auto":
 #bstyle = "short"

 #eturn self._repr_failure_py(excinfo, style=tbstyle)

 #ef _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:
 #f hasattr(self, "fspath"):
 #raceback = excinfo.traceback
 #traceback = traceback.cut(path=self.fspath)
 #f ntraceback == traceback:
 #traceback = ntraceback.cut(excludepath=tracebackcutdir)
 #xcinfo.traceback = ntraceback.filter()


def _check_initialpaths_for_relpath(session, fspath):
 #or initial_path in session._initialpaths:
 #f fspath.common(initial_path) == initial_path:
 #eturn fspath.relto(initial_path)


class FSCollector(Collector):
 #ef __init__(
 #elf,
 #spath: py.path.local,
 #arent=None,
 #onfig: Optional[Config] = None,
 #ession: Optional["Session"] = None,
 #odeid: Optional[str] = None,
 # -> None:
 #ame = fspath.basename
 #f parent is not None:
 #el = fspath.relto(parent.fspath)
 #f rel:
 #ame = rel
 #ame = name.replace(os.sep, SEP)
 #elf.fspath = fspath

 #ession = session or parent.session

 #f nodeid is None:
 #odeid = self.fspath.relto(session.config.rootdir)

 #f not nodeid:
 #odeid = _check_initialpaths_for_relpath(session, fspath)
 #f nodeid and os.sep != SEP:
 #odeid = nodeid.replace(os.sep, SEP)

 #uper().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)

 #classmethod
 #ef from_parent(cls, parent, *, fspath, **kw):
 #""The public constructor."""
 #eturn super().from_parent(parent=parent, fspath=fspath, **kw)

 #ef gethookproxy(self, fspath: py.path.local):
 #arnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH, stacklevel=2)
 #eturn self.session.gethookproxy(fspath)

 #ef isinitpath(self, path: py.path.local) -> bool:
 #arnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH, stacklevel=2)
 #eturn self.session.isinitpath(path)


class File(FSCollector):
 #""Base class for collecting tests from a file.

 #ref:`non-python tests`.
 #""


class Item(Node):
 #""A basic test invocation item.

 #ote that for a single function there might be multiple test invocation items.
 #""

 #extitem = None

 #ef __init__(
 #elf,
 #ame,
 #arent=None,
 #onfig: Optional[Config] = None,
 #ession: Optional["Session"] = None,
 #odeid: Optional[str] = None,
 # -> None:
 #uper().__init__(name, parent, config, session, nodeid=nodeid)
 #elf._report_sections: List[Tuple[str, str, str]] = []

        #: A list of tuples (name, value) that holds user defined properties
        #: for this test.
 #elf.user_properties: List[Tuple[str, object]] = []

 #ef runtest(self) -> None:
 #aise NotImplementedError("runtest must be implemented by Item subclass")

 #ef add_report_section(self, when: str, key: str, content: str) -> None:
 #""Add a new report section, similar to what's done internally to add
 #tdout and stderr captured output::

 #tem.add_report_section("call", "stdout", "report section contents")

 #param str when:
 #ne of the possible capture states, ``"setup"``, ``"call"``, ``"teardown"``.
 #param str key:
 #ame of the section, can be customized at will. Pytest uses ``"stdout"`` and
 #`"stderr"`` internally.
 #param str content:
 #he full contents as a string.
 #""
 #f content:
 #elf._report_sections.append((when, key, content))

 #ef reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:
 #eturn self.fspath, None, ""

 #cached_property
 #ef location(self) -> Tuple[str, Optional[int], str]:
 #ocation = self.reportinfo()
 #spath = absolutepath(str(location[0]))
 #elfspath = self.session._node_location_to_relpath(fspath)
 #ssert type(location[2]) is str
 #eturn (relfspath, location[1], location[2])
