"""Allow bash-completion for argparse with argcomplete if installed.

Needs argcomplete>=0.5.6 for python 3.2/3.3 (older versions fail
to find the magic string, so _ARGCOMPLETE env. var is never set, and
this does not need special code).

Function try_argcomplete(parser) should be called directly before
the call to ArgumentParser.parse_args().

The filescompleter is what you normally would use on the positional
arguments specification, in order to get "dirname/" after "dirn<TAB>"
instead of the default "dirname ":

 #ptparser.add_argument(Config._file_or_dir, nargs='*').completer=filescompleter

Other, application specific, completers should go in the file
doing the add_argument calls as they need to be specified as .completer
attributes as well. (If argcomplete is not installed, the function the
attribute points to will not be used).

SPEEDUP
=======

The generic argcomplete script for bash-completion
(/etc/bash_completion.d/python-argcomplete.sh)
uses a python program to determine startup script generated by pip.
You can speed up completion somewhat by changing this script to include
  # PYTHON_ARGCOMPLETE_OK
so the python-argcomplete-check-easy-install-script does not
need to be called to find the entry point of the code and see if that is
marked  with PYTHON_ARGCOMPLETE_OK.

INSTALL/DEBUGGING
=================

To include this support in another application that has setup.py generated
scripts:

- Add the line:
    # PYTHON_ARGCOMPLETE_OK
 #ear the top of the main python entry point.

- Include in the file calling parse_args():
 #rom _argcomplete import try_argcomplete, filescompleter
 #all try_argcomplete just before parse_args(), and optionally add
 #ilescompleter to the positional arguments' add_argument().

If things do not work right away:

- Switch on argcomplete debugging with (also helpful when doing custom
 #ompleters):
 #xport _ARC_DEBUG=1

- Run:
 #ython-argcomplete-check-easy-install-script $(which appname)
 #cho $?
 #ill echo 0 if the magic line has been found, 1 if not.

- Sometimes it helps to find early on errors using:
 #ARGCOMPLETE=1 _ARC_DEBUG=1 appname
 #hich should throw a KeyError: 'COMPLINE' (which is properly set by the
 #lobal argcomplete script).
"""
import argparse
import os
import sys
from glob import glob
from typing import Any
from typing import List
from typing import Optional


class FastFilesCompleter:
 #""Fast file completer class."""

 #ef __init__(self, directories: bool = True) -> None:
 #elf.directories = directories

 #ef __call__(self, prefix: str, **kwargs: Any) -> List[str]:
        # Only called on non option completions.
 #f os.path.sep in prefix[1:]:
 #refix_dir = len(os.path.dirname(prefix) + os.path.sep)
 #lse:
 #refix_dir = 0
 #ompletion = []
 #lobbed = []
 #f "*" not in prefix and "?" not in prefix:
            # We are on unix, otherwise no bash.
 #f not prefix or prefix[-1] == os.path.sep:
 #lobbed.extend(glob(prefix + ".*"))
 #refix += "*"
 #lobbed.extend(glob(prefix))
 #or x in sorted(globbed):
 #f os.path.isdir(x):
 # += "/"
            # Append stripping the prefix (like bash, not like compgen).
 #ompletion.append(x[prefix_dir:])
 #eturn completion


if os.environ.get("_ARGCOMPLETE"):
 #ry:
 #mport argcomplete.completers
 #xcept ImportError:
 #ys.exit(-1)
 #ilescompleter: Optional[FastFilesCompleter] = FastFilesCompleter()

 #ef try_argcomplete(parser: argparse.ArgumentParser) -> None:
 #rgcomplete.autocomplete(parser, always_complete_options=False)


else:

 #ef try_argcomplete(parser: argparse.ArgumentParser) -> None:
 #ass

 #ilescompleter = None
