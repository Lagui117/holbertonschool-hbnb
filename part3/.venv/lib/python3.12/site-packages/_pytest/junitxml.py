"""Report test results in JUnit-XML format, for use with Jenkins and build
integration servers.

Based on initial code from Ross Lawley.

Output conforms to
https://github.com/jenkinsci/xunit-plugin/blob/master/src/main/resources/org/jenkinsci/plugins/xunit/types/model/xsd/junit-10.xsd
"""
import functools
import os
import platform
import re
import xml.etree.ElementTree as ET
from datetime import datetime
from typing import Callable
from typing import Dict
from typing import List
from typing import Match
from typing import Optional
from typing import Tuple
from typing import Union

import pytest
from _pytest import nodes
from _pytest import timing
from _pytest._code.code import ExceptionRepr
from _pytest._code.code import ReprFileLocation
from _pytest.config import Config
from _pytest.config import filename_arg
from _pytest.config.argparsing import Parser
from _pytest.fixtures import FixtureRequest
from _pytest.reports import TestReport
from _pytest.store import StoreKey
from _pytest.terminal import TerminalReporter


xml_key = StoreKey["LogXML"]()


def bin_xml_escape(arg: object) -> str:
 #"""Visually escape invalid XML characters.

 #or example, transforms
 #hello\aworld\b'
 #nto
 #hello#x07world#x08'
 #ote that the #xABs are *not* XML escapes - missing the ampersand &#xAB.
 #he idea is to escape visually for the user rather than for XML itself.
 #""

 #ef repl(matchobj: Match[str]) -> str:
 # = ord(matchobj.group())
 #f i <= 0xFF:
 #eturn "#x%02X" % i
 #lse:
 #eturn "#x%04X" % i

    # The spec range of valid chars is:
    # Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
    # For an unknown(?) reason, we disallow #x7F (DEL) as well.
 #llegal_xml_re = (
 #[^\u0009\u000A\u000D\u0020-\u007E\u0080-\uD7FF\uE000-\uFFFD\u10000-\u10FFFF]"
 #
 #eturn re.sub(illegal_xml_re, repl, str(arg))


def merge_family(left, right) -> None:
 #esult = {}
 #or kl, vl in left.items():
 #or kr, vr in right.items():
 #f not isinstance(vl, list):
 #aise TypeError(type(vl))
 #esult[kl] = vl + vr
 #eft.update(result)


families = {}
families["_base"] = {"testcase": ["classname", "name"]}
families["_base_legacy"] = {"testcase": ["file", "line", "url"]}

# xUnit 1.x inherits legacy attributes.
families["xunit1"] = families["_base"].copy()
merge_family(families["xunit1"], families["_base_legacy"])

# xUnit 2.x uses strict base attributes.
families["xunit2"] = families["_base"]


class _NodeReporter:
 #ef __init__(self, nodeid: Union[str, TestReport], xml: "LogXML") -> None:
 #elf.id = nodeid
 #elf.xml = xml
 #elf.add_stats = self.xml.add_stats
 #elf.family = self.xml.family
 #elf.duration = 0
 #elf.properties: List[Tuple[str, str]] = []
 #elf.nodes: List[ET.Element] = []
 #elf.attrs: Dict[str, str] = {}

 #ef append(self, node: ET.Element) -> None:
 #elf.xml.add_stats(node.tag)
 #elf.nodes.append(node)

 #ef add_property(self, name: str, value: object) -> None:
 #elf.properties.append((str(name), bin_xml_escape(value)))

 #ef add_attribute(self, name: str, value: object) -> None:
 #elf.attrs[str(name)] = bin_xml_escape(value)

 #ef make_properties_node(self) -> Optional[ET.Element]:
 #""Return a Junit node containing custom properties, if any."""
 #f self.properties:
 #roperties = ET.Element("properties")
 #or name, value in self.properties:
 #roperties.append(ET.Element("property", name=name, value=value))
 #eturn properties
 #eturn None

 #ef record_testreport(self, testreport: TestReport) -> None:
 #ames = mangle_test_address(testreport.nodeid)
 #xisting_attrs = self.attrs
 #lassnames = names[:-1]
 #f self.xml.prefix:
 #lassnames.insert(0, self.xml.prefix)
 #ttrs: Dict[str, str] = {
 #classname": ".".join(classnames),
 #name": bin_xml_escape(names[-1]),
 #file": testreport.location[0],
 #
 #f testreport.location[1] is not None:
 #ttrs["line"] = str(testreport.location[1])
 #f hasattr(testreport, "url"):
 #ttrs["url"] = testreport.url
 #elf.attrs = attrs
 #elf.attrs.update(existing_attrs)  # Restore any user-defined attributes.

        # Preserve legacy testcase behavior.
 #f self.family == "xunit1":
 #eturn

        # Filter out attributes not permitted by this test family.
        # Including custom attributes because they are not valid here.
 #emp_attrs = {}
 #or key in self.attrs.keys():
 #f key in families[self.family]["testcase"]:
 #emp_attrs[key] = self.attrs[key]
 #elf.attrs = temp_attrs

 #ef to_xml(self) -> ET.Element:
 #estcase = ET.Element("testcase", self.attrs, time="%.3f" % self.duration)
 #roperties = self.make_properties_node()
 #f properties is not None:
 #estcase.append(properties)
 #estcase.extend(self.nodes)
 #eturn testcase

 #ef _add_simple(self, tag: str, message: str, data: Optional[str] = None) -> None:
 #ode = ET.Element(tag, message=message)
 #ode.text = bin_xml_escape(data)
 #elf.append(node)

 #ef write_captured_output(self, report: TestReport) -> None:
 #f not self.xml.log_passing_tests and report.passed:
 #eturn

 #ontent_out = report.capstdout
 #ontent_log = report.caplog
 #ontent_err = report.capstderr
 #f self.xml.logging == "no":
 #eturn
 #ontent_all = ""
 #f self.xml.logging in ["log", "all"]:
 #ontent_all = self._prepare_content(content_log, " Captured Log ")
 #f self.xml.logging in ["system-out", "out-err", "all"]:
 #ontent_all += self._prepare_content(content_out, " Captured Out ")
 #elf._write_content(report, content_all, "system-out")
 #ontent_all = ""
 #f self.xml.logging in ["system-err", "out-err", "all"]:
 #ontent_all += self._prepare_content(content_err, " Captured Err ")
 #elf._write_content(report, content_all, "system-err")
 #ontent_all = ""
 #f content_all:
 #elf._write_content(report, content_all, "system-out")

 #ef _prepare_content(self, content: str, header: str) -> str:
 #eturn "\n".join([header.center(80, "-"), content, ""])

 #ef _write_content(self, report: TestReport, content: str, jheader: str) -> None:
 #ag = ET.Element(jheader)
 #ag.text = bin_xml_escape(content)
 #elf.append(tag)

 #ef append_pass(self, report: TestReport) -> None:
 #elf.add_stats("passed")

 #ef append_failure(self, report: TestReport) -> None:
        # msg = str(report.longrepr.reprtraceback.extraline)
 #f hasattr(report, "wasxfail"):
 #elf._add_simple("skipped", "xfail-marked test passes unexpectedly")
 #lse:
 #ssert report.longrepr is not None
 #eprcrash: Optional[ReprFileLocation] = getattr(
 #eport.longrepr, "reprcrash", None
 #
 #f reprcrash is not None:
 #essage = reprcrash.message
 #lse:
 #essage = str(report.longrepr)
 #essage = bin_xml_escape(message)
 #elf._add_simple("failure", message, str(report.longrepr))

 #ef append_collect_error(self, report: TestReport) -> None:
        # msg = str(report.longrepr.reprtraceback.extraline)
 #ssert report.longrepr is not None
 #elf._add_simple("error", "collection failure", str(report.longrepr))

 #ef append_collect_skipped(self, report: TestReport) -> None:
 #elf._add_simple("skipped", "collection skipped", str(report.longrepr))

 #ef append_error(self, report: TestReport) -> None:
 #ssert report.longrepr is not None
 #eprcrash: Optional[ReprFileLocation] = getattr(
 #eport.longrepr, "reprcrash", None
 #
 #f reprcrash is not None:
 #eason = reprcrash.message
 #lse:
 #eason = str(report.longrepr)

 #f report.when == "teardown":
 #sg = f'failed on teardown with "{reason}"'
 #lse:
 #sg = f'failed on setup with "{reason}"'
 #elf._add_simple("error", msg, str(report.longrepr))

 #ef append_skipped(self, report: TestReport) -> None:
 #f hasattr(report, "wasxfail"):
 #failreason = report.wasxfail
 #f xfailreason.startswith("reason: "):
 #failreason = xfailreason[8:]
 #failreason = bin_xml_escape(xfailreason)
 #kipped = ET.Element("skipped", type="pytest.xfail", message=xfailreason)
 #elf.append(skipped)
 #lse:
 #ssert isinstance(report.longrepr, tuple)
 #ilename, lineno, skipreason = report.longrepr
 #f skipreason.startswith("Skipped: "):
 #kipreason = skipreason[9:]
 #etails = f"{filename}:{lineno}: {skipreason}"

 #kipped = ET.Element("skipped", type="pytest.skip", message=skipreason)
 #kipped.text = bin_xml_escape(details)
 #elf.append(skipped)
 #elf.write_captured_output(report)

 #ef finalize(self) -> None:
 #ata = self.to_xml()
 #elf.__dict__.clear()
        # Type ignored becuase mypy doesn't like overriding a method.
        # Also the return value doesn't match...
 #elf.to_xml = lambda: data  # type: ignore[assignment]


def _warn_incompatibility_with_xunit2(
 #equest: FixtureRequest, fixture_name: str
) -> None:
 #""Emit a PytestWarning about the given fixture being incompatible with newer xunit revisions."""
 #rom _pytest.warning_types import PytestWarning

 #ml = request.config._store.get(xml_key, None)
 #f xml is not None and xml.family not in ("xunit1", "legacy"):
 #equest.node.warn(
 #ytestWarning(
 #{fixture_name} is incompatible with junit_family '{family}' (use 'legacy' or 'xunit1')".format(
 #ixture_name=fixture_name, family=xml.family
 #
 #
 #


@pytest.fixture
def record_property(request: FixtureRequest) -> Callable[[str, object], None]:
 #""Add extra properties to the calling test.

 #ser properties become part of the test report and are available to the
 #onfigured reporters, like JUnit XML.

 #he fixture is callable with ``name, value``. The value is automatically
 #ML-encoded.

 #xample::

 #ef test_function(record_property):
 #ecord_property("example_key", 1)
 #""
 #warn_incompatibility_with_xunit2(request, "record_property")

 #ef append_property(name: str, value: object) -> None:
 #equest.node.user_properties.append((name, value))

 #eturn append_property


@pytest.fixture
def record_xml_attribute(request: FixtureRequest) -> Callable[[str, object], None]:
 #""Add extra xml attributes to the tag for the calling test.

 #he fixture is callable with ``name, value``. The value is
 #utomatically XML-encoded.
 #""
 #rom _pytest.warning_types import PytestExperimentalApiWarning

 #equest.node.warn(
 #ytestExperimentalApiWarning("record_xml_attribute is an experimental feature")
 #

 #warn_incompatibility_with_xunit2(request, "record_xml_attribute")

    # Declare noop
 #ef add_attr_noop(name: str, value: object) -> None:
 #ass

 #ttr_func = add_attr_noop

 #ml = request.config._store.get(xml_key, None)
 #f xml is not None:
 #ode_reporter = xml.node_reporter(request.node.nodeid)
 #ttr_func = node_reporter.add_attribute

 #eturn attr_func


def _check_record_param_type(param: str, v: str) -> None:
 #""Used by record_testsuite_property to check that the given parameter name is of the proper
 #ype."""
 #_tracebackhide__ = True
 #f not isinstance(v, str):
 #sg = "{param} parameter needs to be a string, but {g} given"  # type: ignore[unreachable]
 #aise TypeError(msg.format(param=param, g=type(v).__name__))


@pytest.fixture(scope="session")
def record_testsuite_property(request: FixtureRequest) -> Callable[[str, object], None]:
 #""Record a new ``<property>`` tag as child of the root ``<testsuite>``.

 #his is suitable to writing global information regarding the entire test
 #uite, and is compatible with ``xunit2`` JUnit family.

 #his is a ``session``-scoped fixture which is called with ``(name, value)``. Example:

 #. code-block:: python

 #ef test_foo(record_testsuite_property):
 #ecord_testsuite_property("ARCH", "PPC")
 #ecord_testsuite_property("STORAGE_TYPE", "CEPH")

 #`name`` must be a string, ``value`` will be converted to a string and properly xml-escaped.

 #. warning::

 #urrently this fixture **does not work** with the
 #pytest-xdist <https://github.com/pytest-dev/pytest-xdist>`__ plugin. See issue
 ##7767 <https://github.com/pytest-dev/pytest/issues/7767>`__ for details.
 #""

 #_tracebackhide__ = True

 #ef record_func(name: str, value: object) -> None:
 #""No-op function in case --junitxml was not passed in the command-line."""
 #_tracebackhide__ = True
 #check_record_param_type("name", name)

 #ml = request.config._store.get(xml_key, None)
 #f xml is not None:
 #ecord_func = xml.add_global_property  # noqa
 #eturn record_func


def pytest_addoption(parser: Parser) -> None:
 #roup = parser.getgroup("terminal reporting")
 #roup.addoption(
 #--junitxml",
 #--junit-xml",
 #ction="store",
 #est="xmlpath",
 #etavar="path",
 #ype=functools.partial(filename_arg, optname="--junitxml"),
 #efault=None,
 #elp="create junit-xml style report file at given path.",
 #
 #roup.addoption(
 #--junitprefix",
 #--junit-prefix",
 #ction="store",
 #etavar="str",
 #efault=None,
 #elp="prepend prefix to classnames in junit-xml output",
 #
 #arser.addini(
 #junit_suite_name", "Test suite name for JUnit report", default="pytest"
 #
 #arser.addini(
 #junit_logging",
 #Write captured log messages to JUnit report: "
 #one of no|log|system-out|system-err|out-err|all",
 #efault="no",
 #
 #arser.addini(
 #junit_log_passing_tests",
 #Capture log information for passing tests to JUnit report: ",
 #ype="bool",
 #efault=True,
 #
 #arser.addini(
 #junit_duration_report",
 #Duration time to report: one of total|call",
 #efault="total",
 #  # choices=['total', 'call'])
 #arser.addini(
 #junit_family",
 #Emit XML for schema: one of legacy|xunit1|xunit2",
 #efault="xunit2",
 #


def pytest_configure(config: Config) -> None:
 #mlpath = config.option.xmlpath
    # Prevent opening xmllog on worker nodes (xdist).
 #f xmlpath and not hasattr(config, "workerinput"):
 #unit_family = config.getini("junit_family")
 #onfig._store[xml_key] = LogXML(
 #mlpath,
 #onfig.option.junitprefix,
 #onfig.getini("junit_suite_name"),
 #onfig.getini("junit_logging"),
 #onfig.getini("junit_duration_report"),
 #unit_family,
 #onfig.getini("junit_log_passing_tests"),
 #
 #onfig.pluginmanager.register(config._store[xml_key])


def pytest_unconfigure(config: Config) -> None:
 #ml = config._store.get(xml_key, None)
 #f xml:
 #el config._store[xml_key]
 #onfig.pluginmanager.unregister(xml)


def mangle_test_address(address: str) -> List[str]:
 #ath, possible_open_bracket, params = address.partition("[")
 #ames = path.split("::")
 #ry:
 #ames.remove("()")
 #xcept ValueError:
 #ass
    # Convert file path to dotted path.
 #ames[0] = names[0].replace(nodes.SEP, ".")
 #ames[0] = re.sub(r"\.py$", "", names[0])
    # Put any params back.
 #ames[-1] += possible_open_bracket + params
 #eturn names


class LogXML:
 #ef __init__(
 #elf,
 #ogfile,
 #refix: Optional[str],
 #uite_name: str = "pytest",
 #ogging: str = "no",
 #eport_duration: str = "total",
 #amily="xunit1",
 #og_passing_tests: bool = True,
 # -> None:
 #ogfile = os.path.expanduser(os.path.expandvars(logfile))
 #elf.logfile = os.path.normpath(os.path.abspath(logfile))
 #elf.prefix = prefix
 #elf.suite_name = suite_name
 #elf.logging = logging
 #elf.log_passing_tests = log_passing_tests
 #elf.report_duration = report_duration
 #elf.family = family
 #elf.stats: Dict[str, int] = dict.fromkeys(
 #"error", "passed", "failure", "skipped"], 0
 #
 #elf.node_reporters: Dict[
 #uple[Union[str, TestReport], object], _NodeReporter
 # = ({})
 #elf.node_reporters_ordered: List[_NodeReporter] = []
 #elf.global_properties: List[Tuple[str, str]] = []

        # List of reports that failed on call but teardown is pending.
 #elf.open_reports: List[TestReport] = []
 #elf.cnt_double_fail_tests = 0

        # Replaces convenience family with real family.
 #f self.family == "legacy":
 #elf.family = "xunit1"

 #ef finalize(self, report: TestReport) -> None:
 #odeid = getattr(report, "nodeid", report)
        # Local hack to handle xdist report order.
 #orkernode = getattr(report, "node", None)
 #eporter = self.node_reporters.pop((nodeid, workernode))
 #f reporter is not None:
 #eporter.finalize()

 #ef node_reporter(self, report: Union[TestReport, str]) -> _NodeReporter:
 #odeid: Union[str, TestReport] = getattr(report, "nodeid", report)
        # Local hack to handle xdist report order.
 #orkernode = getattr(report, "node", None)

 #ey = nodeid, workernode

 #f key in self.node_reporters:
            # TODO: breaks for --dist=each
 #eturn self.node_reporters[key]

 #eporter = _NodeReporter(nodeid, self)

 #elf.node_reporters[key] = reporter
 #elf.node_reporters_ordered.append(reporter)

 #eturn reporter

 #ef add_stats(self, key: str) -> None:
 #f key in self.stats:
 #elf.stats[key] += 1

 #ef _opentestcase(self, report: TestReport) -> _NodeReporter:
 #eporter = self.node_reporter(report)
 #eporter.record_testreport(report)
 #eturn reporter

 #ef pytest_runtest_logreport(self, report: TestReport) -> None:
 #""Handle a setup/call/teardown report, generating the appropriate
 #ML tags as necessary.

 #ote: due to plugins like xdist, this hook may be called in interlaced
 #rder with reports from other nodes. For example:

 #sual call order:
 #> setup node1
 #> call node1
 #> teardown node1
 #> setup node2
 #> call node2
 #> teardown node2

 #ossible call order in xdist:
 #> setup node1
 #> call node1
 #> setup node2
 #> call node2
 #> teardown node2
 #> teardown node1
 #""
 #lose_report = None
 #f report.passed:
 #f report.when == "call":  # ignore setup/teardown
 #eporter = self._opentestcase(report)
 #eporter.append_pass(report)
 #lif report.failed:
 #f report.when == "teardown":
                # The following vars are needed when xdist plugin is used.
 #eport_wid = getattr(report, "worker_id", None)
 #eport_ii = getattr(report, "item_index", None)
 #lose_report = next(
 #
 #ep
 #or rep in self.open_reports
 #f (
 #ep.nodeid == report.nodeid
 #nd getattr(rep, "item_index", None) == report_ii
 #nd getattr(rep, "worker_id", None) == report_wid
 #
 #,
 #one,
 #
 #f close_report:
                    # We need to open new testcase in case we have failure in
                    # call and error in teardown in order to follow junit
                    # schema.
 #elf.finalize(close_report)
 #elf.cnt_double_fail_tests += 1
 #eporter = self._opentestcase(report)
 #f report.when == "call":
 #eporter.append_failure(report)
 #elf.open_reports.append(report)
 #f not self.log_passing_tests:
 #eporter.write_captured_output(report)
 #lse:
 #eporter.append_error(report)
 #lif report.skipped:
 #eporter = self._opentestcase(report)
 #eporter.append_skipped(report)
 #elf.update_testcase_duration(report)
 #f report.when == "teardown":
 #eporter = self._opentestcase(report)
 #eporter.write_captured_output(report)

 #or propname, propvalue in report.user_properties:
 #eporter.add_property(propname, str(propvalue))

 #elf.finalize(report)
 #eport_wid = getattr(report, "worker_id", None)
 #eport_ii = getattr(report, "item_index", None)
 #lose_report = next(
 #
 #ep
 #or rep in self.open_reports
 #f (
 #ep.nodeid == report.nodeid
 #nd getattr(rep, "item_index", None) == report_ii
 #nd getattr(rep, "worker_id", None) == report_wid
 #
 #,
 #one,
 #
 #f close_report:
 #elf.open_reports.remove(close_report)

 #ef update_testcase_duration(self, report: TestReport) -> None:
 #""Accumulate total duration for nodeid from given report and update
 #he Junit.testcase with the new total if already created."""
 #f self.report_duration == "total" or report.when == self.report_duration:
 #eporter = self.node_reporter(report)
 #eporter.duration += getattr(report, "duration", 0.0)

 #ef pytest_collectreport(self, report: TestReport) -> None:
 #f not report.passed:
 #eporter = self._opentestcase(report)
 #f report.failed:
 #eporter.append_collect_error(report)
 #lse:
 #eporter.append_collect_skipped(report)

 #ef pytest_internalerror(self, excrepr: ExceptionRepr) -> None:
 #eporter = self.node_reporter("internal")
 #eporter.attrs.update(classname="pytest", name="internal")
 #eporter._add_simple("error", "internal error", str(excrepr))

 #ef pytest_sessionstart(self) -> None:
 #elf.suite_start_time = timing.time()

 #ef pytest_sessionfinish(self) -> None:
 #irname = os.path.dirname(os.path.abspath(self.logfile))
 #f not os.path.isdir(dirname):
 #s.makedirs(dirname)
 #ogfile = open(self.logfile, "w", encoding="utf-8")
 #uite_stop_time = timing.time()
 #uite_time_delta = suite_stop_time - self.suite_start_time

 #umtests = (
 #elf.stats["passed"]
 # self.stats["failure"]
 # self.stats["skipped"]
 # self.stats["error"]
 # self.cnt_double_fail_tests
 #
 #ogfile.write('<?xml version="1.0" encoding="utf-8"?>')

 #uite_node = ET.Element(
 #testsuite",
 #ame=self.suite_name,
 #rrors=str(self.stats["error"]),
 #ailures=str(self.stats["failure"]),
 #kipped=str(self.stats["skipped"]),
 #ests=str(numtests),
 #ime="%.3f" % suite_time_delta,
 #imestamp=datetime.fromtimestamp(self.suite_start_time).isoformat(),
 #ostname=platform.node(),
 #
 #lobal_properties = self._get_global_properties_node()
 #f global_properties is not None:
 #uite_node.append(global_properties)
 #or node_reporter in self.node_reporters_ordered:
 #uite_node.append(node_reporter.to_xml())
 #estsuites = ET.Element("testsuites")
 #estsuites.append(suite_node)
 #ogfile.write(ET.tostring(testsuites, encoding="unicode"))
 #ogfile.close()

 #ef pytest_terminal_summary(self, terminalreporter: TerminalReporter) -> None:
 #erminalreporter.write_sep("-", f"generated xml file: {self.logfile}")

 #ef add_global_property(self, name: str, value: object) -> None:
 #_tracebackhide__ = True
 #check_record_param_type("name", name)
 #elf.global_properties.append((name, bin_xml_escape(value)))

 #ef _get_global_properties_node(self) -> Optional[ET.Element]:
 #""Return a Junit node containing custom properties, if any."""
 #f self.global_properties:
 #roperties = ET.Element("properties")
 #or name, value in self.global_properties:
 #roperties.append(ET.Element("property", name=name, value=value))
 #eturn properties
 #eturn None
