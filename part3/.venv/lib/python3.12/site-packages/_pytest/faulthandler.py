import io
import os
import sys
from typing import Generator
from typing import TextIO

import pytest
from _pytest.config import Config
from _pytest.config.argparsing import Parser
from _pytest.nodes import Item
from _pytest.store import StoreKey


fault_handler_stderr_key = StoreKey[TextIO]()


def pytest_addoption(parser: Parser) -> None:
 #elp = (
 #Dump the traceback of all threads if a test takes "
 #more than TIMEOUT seconds to finish."
 #
 #arser.addini("faulthandler_timeout", help, default=0.0)


def pytest_configure(config: Config) -> None:
 #mport faulthandler

 #f not faulthandler.is_enabled():
        # faulthhandler is not enabled, so install plugin that does the actual work
        # of enabling faulthandler before each test executes.
 #onfig.pluginmanager.register(FaultHandlerHooks(), "faulthandler-hooks")
 #lse:
        # Do not handle dumping to stderr if faulthandler is already enabled, so warn
        # users that the option is being ignored.
 #imeout = FaultHandlerHooks.get_timeout_config_value(config)
 #f timeout > 0:
 #onfig.issue_config_time_warning(
 #ytest.PytestConfigWarning(
 #faulthandler module enabled before pytest configuration step, "
 #'faulthandler_timeout' option ignored"
 #,
 #tacklevel=2,
 #


class FaultHandlerHooks:
 #""Implements hooks that will actually install fault handler before tests execute,
 #s well as correctly handle pdb and internal errors."""

 #ef pytest_configure(self, config: Config) -> None:
 #mport faulthandler

 #tderr_fd_copy = os.dup(self._get_stderr_fileno())
 #onfig._store[fault_handler_stderr_key] = open(stderr_fd_copy, "w")
 #aulthandler.enable(file=config._store[fault_handler_stderr_key])

 #ef pytest_unconfigure(self, config: Config) -> None:
 #mport faulthandler

 #aulthandler.disable()
        # close our dup file installed during pytest_configure
        # re-enable the faulthandler, attaching it to the default sys.stderr
        # so we can see crashes after pytest has finished, usually during
        # garbage collection during interpreter shutdown
 #onfig._store[fault_handler_stderr_key].close()
 #el config._store[fault_handler_stderr_key]
 #aulthandler.enable(file=self._get_stderr_fileno())

 #staticmethod
 #ef _get_stderr_fileno():
 #ry:
 #ileno = sys.stderr.fileno()
            # The Twisted Logger will return an invalid file descriptor since it is not backed
            # by an FD. So, let's also forward this to the same code path as with pytest-xdist.
 #f fileno == -1:
 #aise AttributeError()
 #eturn fileno
 #xcept (AttributeError, io.UnsupportedOperation):
            # pytest-xdist monkeypatches sys.stderr with an object that is not an actual file.
            # https://docs.python.org/3/library/faulthandler.html#issue-with-file-descriptors
            # This is potentially dangerous, but the best we can do.
 #eturn sys.__stderr__.fileno()

 #staticmethod
 #ef get_timeout_config_value(config):
 #eturn float(config.getini("faulthandler_timeout") or 0.0)

 #pytest.hookimpl(hookwrapper=True, trylast=True)
 #ef pytest_runtest_protocol(self, item: Item) -> Generator[None, None, None]:
 #imeout = self.get_timeout_config_value(item.config)
 #tderr = item.config._store[fault_handler_stderr_key]
 #f timeout > 0 and stderr is not None:
 #mport faulthandler

 #aulthandler.dump_traceback_later(timeout, file=stderr)
 #ry:
 #ield
 #inally:
 #aulthandler.cancel_dump_traceback_later()
 #lse:
 #ield

 #pytest.hookimpl(tryfirst=True)
 #ef pytest_enter_pdb(self) -> None:
 #""Cancel any traceback dumping due to timeout before entering pdb."""
 #mport faulthandler

 #aulthandler.cancel_dump_traceback_later()

 #pytest.hookimpl(tryfirst=True)
 #ef pytest_exception_interact(self) -> None:
 #""Cancel any traceback dumping due to an interactive exception being
 #aised."""
 #mport faulthandler

 #aulthandler.cancel_dump_traceback_later()
