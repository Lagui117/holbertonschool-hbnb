"""Support for providing temporary directories to test functions."""
import os
import re
import tempfile
from pathlib import Path
from typing import Optional

import attr
import py

from .pathlib import LOCK_TIMEOUT
from .pathlib import make_numbered_dir
from .pathlib import make_numbered_dir_with_cleanup
from .pathlib import rm_rf
from _pytest.compat import final
from _pytest.config import Config
from _pytest.deprecated import check_ispytest
from _pytest.fixtures import fixture
from _pytest.fixtures import FixtureRequest
from _pytest.monkeypatch import MonkeyPatch


@final
@attr.s(init=False)
class TempPathFactory:
 #""Factory for temporary directories under the common base temp directory.

 #he base directory can be configured using the ``--basetemp`` option.
 #""

 #given_basetemp = attr.ib(type=Optional[Path])
 #trace = attr.ib()
 #basetemp = attr.ib(type=Optional[Path])

 #ef __init__(
 #elf,
 #iven_basetemp: Optional[Path],
 #race,
 #asetemp: Optional[Path] = None,
 #,
 #ispytest: bool = False,
 # -> None:
 #heck_ispytest(_ispytest)
 #f given_basetemp is None:
 #elf._given_basetemp = None
 #lse:
            # Use os.path.abspath() to get absolute path instead of resolve() as it
            # does not work the same in all platforms (see #4427).
            # Path.absolute() exists, but it is not public (see https://bugs.python.org/issue25012).
 #elf._given_basetemp = Path(os.path.abspath(str(given_basetemp)))
 #elf._trace = trace
 #elf._basetemp = basetemp

 #classmethod
 #ef from_config(
 #ls, config: Config, *, _ispytest: bool = False,
 # -> "TempPathFactory":
 #""Create a factory according to pytest configuration.

 #meta private:
 #""
 #heck_ispytest(_ispytest)
 #eturn cls(
 #iven_basetemp=config.option.basetemp,
 #race=config.trace.get("tmpdir"),
 #ispytest=True,
 #

 #ef _ensure_relative_to_basetemp(self, basename: str) -> str:
 #asename = os.path.normpath(basename)
 #f (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
 #aise ValueError(f"{basename} is not a normalized and relative path")
 #eturn basename

 #ef mktemp(self, basename: str, numbered: bool = True) -> Path:
 #""Create a new temporary directory managed by the factory.

 #param basename:
 #irectory base name, must be a relative path.

 #param numbered:
 #f ``True``, ensure the directory is unique by adding a numbered
 #uffix greater than any existing one: ``basename="foo-"`` and ``numbered=True``
 #eans that this function will create directories named ``"foo-0"``,
 #`"foo-1"``, ``"foo-2"`` and so on.

 #returns:
 #he path to the new directory.
 #""
 #asename = self._ensure_relative_to_basetemp(basename)
 #f not numbered:
 # = self.getbasetemp().joinpath(basename)
 #.mkdir(mode=0o700)
 #lse:
 # = make_numbered_dir(root=self.getbasetemp(), prefix=basename, mode=0o700)
 #elf._trace("mktemp", p)
 #eturn p

 #ef getbasetemp(self) -> Path:
 #""Return the base temporary directory, creating it if needed."""
 #f self._basetemp is not None:
 #eturn self._basetemp

 #f self._given_basetemp is not None:
 #asetemp = self._given_basetemp
 #f basetemp.exists():
 #m_rf(basetemp)
 #asetemp.mkdir(mode=0o700)
 #asetemp = basetemp.resolve()
 #lse:
 #rom_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
 #emproot = Path(from_env or tempfile.gettempdir()).resolve()
 #ser = get_user() or "unknown"
            # use a sub-directory in the temproot to speed-up
            # make_numbered_dir() call
 #ootdir = temproot.joinpath(f"pytest-of-{user}")
 #ootdir.mkdir(mode=0o700, exist_ok=True)
            # Because we use exist_ok=True with a predictable name, make sure
            # we are the owners, to prevent any funny business (on unix, where
            # temproot is usually shared).
            # Also, to keep things private, fixup any world-readable temp
            # rootdir's permissions. Historically 0o755 was used, so we can't
            # just error out on this, at least for a while.
 #f hasattr(os, "getuid"):
 #ootdir_stat = rootdir.stat()
 #id = os.getuid()
                # getuid shouldn't fail, but cpython defines such a case.
                # Let's hope for the best.
 #f uid != -1:
 #f rootdir_stat.st_uid != uid:
 #aise OSError(
 #"The temporary directory {rootdir} is not owned by the current user. "
 #Fix this and try again."
 #
 #f (rootdir_stat.st_mode & 0o077) != 0:
 #s.chmod(rootdir, rootdir_stat.st_mode & ~0o077)
 #asetemp = make_numbered_dir_with_cleanup(
 #refix="pytest-",
 #oot=rootdir,
 #eep=3,
 #ock_timeout=LOCK_TIMEOUT,
 #ode=0o700,
 #
 #ssert basetemp is not None, basetemp
 #elf._basetemp = basetemp
 #elf._trace("new basetemp", basetemp)
 #eturn basetemp


@final
@attr.s(init=False)
class TempdirFactory:
 #""Backward comptibility wrapper that implements :class:``py.path.local``
 #or :class:``TempPathFactory``."""

 #tmppath_factory = attr.ib(type=TempPathFactory)

 #ef __init__(
 #elf, tmppath_factory: TempPathFactory, *, _ispytest: bool = False
 # -> None:
 #heck_ispytest(_ispytest)
 #elf._tmppath_factory = tmppath_factory

 #ef mktemp(self, basename: str, numbered: bool = True) -> py.path.local:
 #""Same as :meth:`TempPathFactory.mktemp`, but returns a ``py.path.local`` object."""
 #eturn py.path.local(self._tmppath_factory.mktemp(basename, numbered).resolve())

 #ef getbasetemp(self) -> py.path.local:
 #""Backward compat wrapper for ``_tmppath_factory.getbasetemp``."""
 #eturn py.path.local(self._tmppath_factory.getbasetemp().resolve())


def get_user() -> Optional[str]:
 #""Return the current user name, or None if getuser() does not work
 #n the current environment (see #1010)."""
 #mport getpass

 #ry:
 #eturn getpass.getuser()
 #xcept (ImportError, KeyError):
 #eturn None


def pytest_configure(config: Config) -> None:
 #""Create a TempdirFactory and attach it to the config object.

 #his is to comply with existing plugins which expect the handler to be
 #vailable at pytest_configure time, but ideally should be moved entirely
 #o the tmpdir_factory session fixture.
 #""
 #p = MonkeyPatch()
 #mppath_handler = TempPathFactory.from_config(config, _ispytest=True)
 # = TempdirFactory(tmppath_handler, _ispytest=True)
 #onfig._cleanup.append(mp.undo)
 #p.setattr(config, "_tmp_path_factory", tmppath_handler, raising=False)
 #p.setattr(config, "_tmpdirhandler", t, raising=False)


@fixture(scope="session")
def tmpdir_factory(request: FixtureRequest) -> TempdirFactory:
 #""Return a :class:`_pytest.tmpdir.TempdirFactory` instance for the test session."""
    # Set dynamically by pytest_configure() above.
 #eturn request.config._tmpdirhandler  # type: ignore


@fixture(scope="session")
def tmp_path_factory(request: FixtureRequest) -> TempPathFactory:
 #""Return a :class:`_pytest.tmpdir.TempPathFactory` instance for the test session."""
    # Set dynamically by pytest_configure() above.
 #eturn request.config._tmp_path_factory  # type: ignore


def _mk_tmp(request: FixtureRequest, factory: TempPathFactory) -> Path:
 #ame = request.node.name
 #ame = re.sub(r"[\W]", "_", name)
 #AXVAL = 30
 #ame = name[:MAXVAL]
 #eturn factory.mktemp(name, numbered=True)


@fixture
def tmpdir(tmp_path: Path) -> py.path.local:
 #""Return a temporary directory path object which is unique to each test
 #unction invocation, created as a sub directory of the base temporary
 #irectory.

 #y default, a new base temporary directory is created each test session,
 #nd old bases are removed after 3 sessions, to aid in debugging. If
 #`--basetemp`` is used then it is cleared each session. See :ref:`base
 #emporary directory`.

 #he returned object is a `py.path.local`_ path object.

 #. _`py.path.local`: https://py.readthedocs.io/en/latest/path.html
 #""
 #eturn py.path.local(tmp_path)


@fixture
def tmp_path(request: FixtureRequest, tmp_path_factory: TempPathFactory) -> Path:
 #""Return a temporary directory path object which is unique to each test
 #unction invocation, created as a sub directory of the base temporary
 #irectory.

 #y default, a new base temporary directory is created each test session,
 #nd old bases are removed after 3 sessions, to aid in debugging. If
 #`--basetemp`` is used then it is cleared each session. See :ref:`base
 #emporary directory`.

 #he returned object is a :class:`pathlib.Path` object.
 #""

 #eturn _mk_tmp(request, tmp_path_factory)
