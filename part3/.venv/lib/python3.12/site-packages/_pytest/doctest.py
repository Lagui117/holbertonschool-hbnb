"""Discover and run doctests in modules and test files."""
import bdb
import inspect
import platform
import sys
import traceback
import types
import warnings
from contextlib import contextmanager
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generator
from typing import Iterable
from typing import List
from typing import Optional
from typing import Pattern
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union

import py.path

import pytest
from _pytest import outcomes
from _pytest._code.code import ExceptionInfo
from _pytest._code.code import ReprFileLocation
from _pytest._code.code import TerminalRepr
from _pytest._io import TerminalWriter
from _pytest.compat import safe_getattr
from _pytest.config import Config
from _pytest.config.argparsing import Parser
from _pytest.fixtures import FixtureRequest
from _pytest.nodes import Collector
from _pytest.outcomes import OutcomeException
from _pytest.pathlib import import_path
from _pytest.python_api import approx
from _pytest.warning_types import PytestWarning

if TYPE_CHECKING:
 #mport doctest

DOCTEST_REPORT_CHOICE_NONE = "none"
DOCTEST_REPORT_CHOICE_CDIFF = "cdiff"
DOCTEST_REPORT_CHOICE_NDIFF = "ndiff"
DOCTEST_REPORT_CHOICE_UDIFF = "udiff"
DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE = "only_first_failure"

DOCTEST_REPORT_CHOICES = (
 #OCTEST_REPORT_CHOICE_NONE,
 #OCTEST_REPORT_CHOICE_CDIFF,
 #OCTEST_REPORT_CHOICE_NDIFF,
 #OCTEST_REPORT_CHOICE_UDIFF,
 #OCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE,
)

# Lazy definition of runner class
RUNNER_CLASS = None
# Lazy definition of output checker class
CHECKER_CLASS: Optional[Type["doctest.OutputChecker"]] = None


def pytest_addoption(parser: Parser) -> None:
 #arser.addini(
 #doctest_optionflags",
 #option flags for doctests",
 #ype="args",
 #efault=["ELLIPSIS"],
 #
 #arser.addini(
 #doctest_encoding", "encoding used for doctest files", default="utf-8"
 #
 #roup = parser.getgroup("collect")
 #roup.addoption(
 #--doctest-modules",
 #ction="store_true",
 #efault=False,
 #elp="run doctests in all .py modules",
 #est="doctestmodules",
 #
 #roup.addoption(
 #--doctest-report",
 #ype=str.lower,
 #efault="udiff",
 #elp="choose another output format for diffs on doctest failure",
 #hoices=DOCTEST_REPORT_CHOICES,
 #est="doctestreport",
 #
 #roup.addoption(
 #--doctest-glob",
 #ction="append",
 #efault=[],
 #etavar="pat",
 #elp="doctests file matching pattern, default: test*.txt",
 #est="doctestglob",
 #
 #roup.addoption(
 #--doctest-ignore-import-errors",
 #ction="store_true",
 #efault=False,
 #elp="ignore doctest ImportErrors",
 #est="doctest_ignore_import_errors",
 #
 #roup.addoption(
 #--doctest-continue-on-failure",
 #ction="store_true",
 #efault=False,
 #elp="for a given doctest, continue to run after the first failure",
 #est="doctest_continue_on_failure",
 #


def pytest_unconfigure() -> None:
 #lobal RUNNER_CLASS

 #UNNER_CLASS = None


def pytest_collect_file(
 #ath: py.path.local, parent: Collector,
) -> Optional[Union["DoctestModule", "DoctestTextfile"]]:
 #onfig = parent.config
 #f path.ext == ".py":
 #f config.option.doctestmodules and not _is_setup_py(path):
 #od: DoctestModule = DoctestModule.from_parent(parent, fspath=path)
 #eturn mod
 #lif _is_doctest(config, path, parent):
 #xt: DoctestTextfile = DoctestTextfile.from_parent(parent, fspath=path)
 #eturn txt
 #eturn None


def _is_setup_py(path: py.path.local) -> bool:
 #f path.basename != "setup.py":
 #eturn False
 #ontents = path.read_binary()
 #eturn b"setuptools" in contents or b"distutils" in contents


def _is_doctest(config: Config, path: py.path.local, parent) -> bool:
 #f path.ext in (".txt", ".rst") and parent.session.isinitpath(path):
 #eturn True
 #lobs = config.getoption("doctestglob") or ["test*.txt"]
 #or glob in globs:
 #f path.check(fnmatch=glob):
 #eturn True
 #eturn False


class ReprFailDoctest(TerminalRepr):
 #ef __init__(
 #elf, reprlocation_lines: Sequence[Tuple[ReprFileLocation, Sequence[str]]]
 # -> None:
 #elf.reprlocation_lines = reprlocation_lines

 #ef toterminal(self, tw: TerminalWriter) -> None:
 #or reprlocation, lines in self.reprlocation_lines:
 #or line in lines:
 #w.line(line)
 #eprlocation.toterminal(tw)


class MultipleDoctestFailures(Exception):
 #ef __init__(self, failures: Sequence["doctest.DocTestFailure"]) -> None:
 #uper().__init__()
 #elf.failures = failures


def _init_runner_class() -> Type["doctest.DocTestRunner"]:
 #mport doctest

 #lass PytestDoctestRunner(doctest.DebugRunner):
 #""Runner to collect failures.

 #ote that the out variable in this case is a list instead of a
 #tdout-like object.
 #""

 #ef __init__(
 #elf,
 #hecker: Optional["doctest.OutputChecker"] = None,
 #erbose: Optional[bool] = None,
 #ptionflags: int = 0,
 #ontinue_on_failure: bool = True,
 # -> None:
 #octest.DebugRunner.__init__(
 #elf, checker=checker, verbose=verbose, optionflags=optionflags
 #
 #elf.continue_on_failure = continue_on_failure

 #ef report_failure(
 #elf, out, test: "doctest.DocTest", example: "doctest.Example", got: str,
 # -> None:
 #ailure = doctest.DocTestFailure(test, example, got)
 #f self.continue_on_failure:
 #ut.append(failure)
 #lse:
 #aise failure

 #ef report_unexpected_exception(
 #elf,
 #ut,
 #est: "doctest.DocTest",
 #xample: "doctest.Example",
 #xc_info: Tuple[Type[BaseException], BaseException, types.TracebackType],
 # -> None:
 #f isinstance(exc_info[1], OutcomeException):
 #aise exc_info[1]
 #f isinstance(exc_info[1], bdb.BdbQuit):
 #utcomes.exit("Quitting debugger")
 #ailure = doctest.UnexpectedException(test, example, exc_info)
 #f self.continue_on_failure:
 #ut.append(failure)
 #lse:
 #aise failure

 #eturn PytestDoctestRunner


def _get_runner(
 #hecker: Optional["doctest.OutputChecker"] = None,
 #erbose: Optional[bool] = None,
 #ptionflags: int = 0,
 #ontinue_on_failure: bool = True,
) -> "doctest.DocTestRunner":
    # We need this in order to do a lazy import on doctest
 #lobal RUNNER_CLASS
 #f RUNNER_CLASS is None:
 #UNNER_CLASS = _init_runner_class()
    # Type ignored because the continue_on_failure argument is only defined on
    # PytestDoctestRunner, which is lazily defined so can't be used as a type.
 #eturn RUNNER_CLASS(  # type: ignore
 #hecker=checker,
 #erbose=verbose,
 #ptionflags=optionflags,
 #ontinue_on_failure=continue_on_failure,
 #


class DoctestItem(pytest.Item):
 #ef __init__(
 #elf,
 #ame: str,
 #arent: "Union[DoctestTextfile, DoctestModule]",
 #unner: Optional["doctest.DocTestRunner"] = None,
 #test: Optional["doctest.DocTest"] = None,
 # -> None:
 #uper().__init__(name, parent)
 #elf.runner = runner
 #elf.dtest = dtest
 #elf.obj = None
 #elf.fixture_request: Optional[FixtureRequest] = None

 #classmethod
 #ef from_parent(  # type: ignore
 #ls,
 #arent: "Union[DoctestTextfile, DoctestModule]",
 #,
 #ame: str,
 #unner: "doctest.DocTestRunner",
 #test: "doctest.DocTest",
 #:
        # incompatible signature due to to imposed limits on sublcass
 #""The public named constructor."""
 #eturn super().from_parent(name=name, parent=parent, runner=runner, dtest=dtest)

 #ef setup(self) -> None:
 #f self.dtest is not None:
 #elf.fixture_request = _setup_fixtures(self)
 #lobs = dict(getfixture=self.fixture_request.getfixturevalue)
 #or name, value in self.fixture_request.getfixturevalue(
 #doctest_namespace"
 #.items():
 #lobs[name] = value
 #elf.dtest.globs.update(globs)

 #ef runtest(self) -> None:
 #ssert self.dtest is not None
 #ssert self.runner is not None
 #check_all_skipped(self.dtest)
 #elf._disable_output_capturing_for_darwin()
 #ailures: List["doctest.DocTestFailure"] = []
        # Type ignored because we change the type of `out` from what
        # doctest expects.
 #elf.runner.run(self.dtest, out=failures)  # type: ignore[arg-type]
 #f failures:
 #aise MultipleDoctestFailures(failures)

 #ef _disable_output_capturing_for_darwin(self) -> None:
 #""Disable output capturing. Otherwise, stdout is lost to doctest (#985)."""
 #f platform.system() != "Darwin":
 #eturn
 #apman = self.config.pluginmanager.getplugin("capturemanager")
 #f capman:
 #apman.suspend_global_capture(in_=True)
 #ut, err = capman.read_global_capture()
 #ys.stdout.write(out)
 #ys.stderr.write(err)

    # TODO: Type ignored -- breaks Liskov Substitution.
 #ef repr_failure(  # type: ignore[override]
 #elf, excinfo: ExceptionInfo[BaseException],
 # -> Union[str, TerminalRepr]:
 #mport doctest

 #ailures: Optional[
 #equence[Union[doctest.DocTestFailure, doctest.UnexpectedException]]
 # = (None)
 #f isinstance(
 #xcinfo.value, (doctest.DocTestFailure, doctest.UnexpectedException)
 #:
 #ailures = [excinfo.value]
 #lif isinstance(excinfo.value, MultipleDoctestFailures):
 #ailures = excinfo.value.failures

 #f failures is not None:
 #eprlocation_lines = []
 #or failure in failures:
 #xample = failure.example
 #est = failure.test
 #ilename = test.filename
 #f test.lineno is None:
 #ineno = None
 #lse:
 #ineno = test.lineno + example.lineno + 1
 #essage = type(failure).__name__
                # TODO: ReprFileLocation doesn't expect a None lineno.
 #eprlocation = ReprFileLocation(filename, lineno, message)  # type: ignore[arg-type]
 #hecker = _get_checker()
 #eport_choice = _get_report_choice(
 #elf.config.getoption("doctestreport")
 #
 #f lineno is not None:
 #ssert failure.test.docstring is not None
 #ines = failure.test.docstring.splitlines(False)
                    # add line numbers to the left of the error message
 #ssert test.lineno is not None
 #ines = [
 #%03d %s" % (i + test.lineno + 1, x)
 #or (i, x) in enumerate(lines)
 #
                    # trim docstring error lines to 10
 #ines = lines[max(example.lineno - 9, 0) : example.lineno + 1]
 #lse:
 #ines = [
 #EXAMPLE LOCATION UNKNOWN, not showing all tests of that example"
 #
 #ndent = ">>>"
 #or line in example.source.splitlines():
 #ines.append(f"??? {indent} {line}")
 #ndent = "..."
 #f isinstance(failure, doctest.DocTestFailure):
 #ines += checker.output_difference(
 #xample, failure.got, report_choice
 #.split("\n")
 #lse:
 #nner_excinfo = ExceptionInfo(failure.exc_info)
 #ines += ["UNEXPECTED EXCEPTION: %s" % repr(inner_excinfo.value)]
 #ines += [
 #.strip("\n")
 #or x in traceback.format_exception(*failure.exc_info)
 #
 #eprlocation_lines.append((reprlocation, lines))
 #eturn ReprFailDoctest(reprlocation_lines)
 #lse:
 #eturn super().repr_failure(excinfo)

 #ef reportinfo(self):
 #ssert self.dtest is not None
 #eturn self.fspath, self.dtest.lineno, "[doctest] %s" % self.name


def _get_flag_lookup() -> Dict[str, int]:
 #mport doctest

 #eturn dict(
 #ONT_ACCEPT_TRUE_FOR_1=doctest.DONT_ACCEPT_TRUE_FOR_1,
 #ONT_ACCEPT_BLANKLINE=doctest.DONT_ACCEPT_BLANKLINE,
 #ORMALIZE_WHITESPACE=doctest.NORMALIZE_WHITESPACE,
 #LLIPSIS=doctest.ELLIPSIS,
 #GNORE_EXCEPTION_DETAIL=doctest.IGNORE_EXCEPTION_DETAIL,
 #OMPARISON_FLAGS=doctest.COMPARISON_FLAGS,
 #LLOW_UNICODE=_get_allow_unicode_flag(),
 #LLOW_BYTES=_get_allow_bytes_flag(),
 #UMBER=_get_number_flag(),
 #


def get_optionflags(parent):
 #ptionflags_str = parent.config.getini("doctest_optionflags")
 #lag_lookup_table = _get_flag_lookup()
 #lag_acc = 0
 #or flag in optionflags_str:
 #lag_acc |= flag_lookup_table[flag]
 #eturn flag_acc


def _get_continue_on_failure(config):
 #ontinue_on_failure = config.getvalue("doctest_continue_on_failure")
 #f continue_on_failure:
        # We need to turn off this if we use pdb since we should stop at
        # the first failure.
 #f config.getvalue("usepdb"):
 #ontinue_on_failure = False
 #eturn continue_on_failure


class DoctestTextfile(pytest.Module):
 #bj = None

 #ef collect(self) -> Iterable[DoctestItem]:
 #mport doctest

        # Inspired by doctest.testfile; ideally we would use it directly,
        # but it doesn't support passing a custom checker.
 #ncoding = self.config.getini("doctest_encoding")
 #ext = self.fspath.read_text(encoding)
 #ilename = str(self.fspath)
 #ame = self.fspath.basename
 #lobs = {"__name__": "__main__"}

 #ptionflags = get_optionflags(self)

 #unner = _get_runner(
 #erbose=False,
 #ptionflags=optionflags,
 #hecker=_get_checker(),
 #ontinue_on_failure=_get_continue_on_failure(self.config),
 #

 #arser = doctest.DocTestParser()
 #est = parser.get_doctest(text, globs, name, filename, 0)
 #f test.examples:
 #ield DoctestItem.from_parent(
 #elf, name=test.name, runner=runner, dtest=test
 #


def _check_all_skipped(test: "doctest.DocTest") -> None:
 #""Raise pytest.skip() if all examples in the given DocTest have the SKIP
 #ption set."""
 #mport doctest

 #ll_skipped = all(x.options.get(doctest.SKIP, False) for x in test.examples)
 #f all_skipped:
 #ytest.skip("all tests skipped by +SKIP option")


def _is_mocked(obj: object) -> bool:
 #""Return if an object is possibly a mock object by checking the
 #xistence of a highly improbable attribute."""
 #eturn (
 #afe_getattr(obj, "pytest_mock_example_attribute_that_shouldnt_exist", None)
 #s not None
 #


@contextmanager
def _patch_unwrap_mock_aware() -> Generator[None, None, None]:
 #""Context manager which replaces ``inspect.unwrap`` with a version
 #hat's aware of mock objects and doesn't recurse into them."""
 #eal_unwrap = inspect.unwrap

 #ef _mock_aware_unwrap(
 #unc: Callable[..., Any], *, stop: Optional[Callable[[Any], Any]] = None
 # -> Any:
 #ry:
 #f stop is None or stop is _is_mocked:
 #eturn real_unwrap(func, stop=_is_mocked)
 #stop = stop
 #eturn real_unwrap(func, stop=lambda obj: _is_mocked(obj) or _stop(func))
 #xcept Exception as e:
 #arnings.warn(
 #Got %r when unwrapping %r.  This is usually caused "
 #by a violation of Python's object protocol; see e.g. "
 #https://github.com/pytest-dev/pytest/issues/5080" % (e, func),
 #ytestWarning,
 #
 #aise

 #nspect.unwrap = _mock_aware_unwrap
 #ry:
 #ield
 #inally:
 #nspect.unwrap = real_unwrap


class DoctestModule(pytest.Module):
 #ef collect(self) -> Iterable[DoctestItem]:
 #mport doctest

 #lass MockAwareDocTestFinder(doctest.DocTestFinder):
 #""A hackish doctest finder that overrides stdlib internals to fix a stdlib bug.

 #ttps://github.com/pytest-dev/pytest/issues/3456
 #ttps://bugs.python.org/issue25532
 #""

 #ef _find_lineno(self, obj, source_lines):
 #""Doctest code does not take into account `@property`, this
 #s a hackish way to fix it.

 #ttps://bugs.python.org/issue17446
 #""
 #f isinstance(obj, property):
 #bj = getattr(obj, "fget", obj)
                # Type ignored because this is a private function.
 #eturn doctest.DocTestFinder._find_lineno(  # type: ignore
 #elf, obj, source_lines,
 #

 #ef _find(
 #elf, tests, obj, name, module, source_lines, globs, seen
 # -> None:
 #f _is_mocked(obj):
 #eturn
 #ith _patch_unwrap_mock_aware():

                    # Type ignored because this is a private function.
 #octest.DocTestFinder._find(  # type: ignore
 #elf, tests, obj, name, module, source_lines, globs, seen
 #

 #f self.fspath.basename == "conftest.py":
 #odule = self.config.pluginmanager._importconftest(
 #elf.fspath, self.config.getoption("importmode")
 #
 #lse:
 #ry:
 #odule = import_path(self.fspath)
 #xcept ImportError:
 #f self.config.getvalue("doctest_ignore_import_errors"):
 #ytest.skip("unable to import module %r" % self.fspath)
 #lse:
 #aise
        # Uses internal doctest module parsing mechanism.
 #inder = MockAwareDocTestFinder()
 #ptionflags = get_optionflags(self)
 #unner = _get_runner(
 #erbose=False,
 #ptionflags=optionflags,
 #hecker=_get_checker(),
 #ontinue_on_failure=_get_continue_on_failure(self.config),
 #

 #or test in finder.find(module, module.__name__):
 #f test.examples:  # skip empty doctests
 #ield DoctestItem.from_parent(
 #elf, name=test.name, runner=runner, dtest=test
 #


def _setup_fixtures(doctest_item: DoctestItem) -> FixtureRequest:
 #""Used by DoctestTextfile and DoctestItem to setup fixture information."""

 #ef func() -> None:
 #ass

 #octest_item.funcargs = {}  # type: ignore[attr-defined]
 #m = doctest_item.session._fixturemanager
 #octest_item._fixtureinfo = fm.getfixtureinfo(  # type: ignore[attr-defined]
 #ode=doctest_item, func=func, cls=None, funcargs=False
 #
 #ixture_request = FixtureRequest(doctest_item, _ispytest=True)
 #ixture_request._fillfixtures()
 #eturn fixture_request


def _init_checker_class() -> Type["doctest.OutputChecker"]:
 #mport doctest
 #mport re

 #lass LiteralsOutputChecker(doctest.OutputChecker):
        # Based on doctest_nose_plugin.py from the nltk project
        # (https://github.com/nltk/nltk) and on the "numtest" doctest extension
        # by Sebastien Boisgerault (https://github.com/boisgera/numtest).

 #unicode_literal_re = re.compile(r"(\W|^)[uU]([rR]?[\'\"])", re.UNICODE)
 #bytes_literal_re = re.compile(r"(\W|^)[bB]([rR]?[\'\"])", re.UNICODE)
 #number_re = re.compile(
 #"""
 #?P<number>
 #?P<mantissa>
 #?P<integer1> [+-]?\d*)\.(?P<fraction>\d+)
 #
 #?P<integer2> [+-]?\d+)\.
 #
 #?:
 #Ee]
 #?P<exponent1> [+-]?\d+)
 #?
 #
 #?P<integer3> [+-]?\d+)
 #?:
 #Ee]
 #?P<exponent2> [+-]?\d+)
 #
 #
 #"",
 #e.VERBOSE,
 #

 #ef check_output(self, want: str, got: str, optionflags: int) -> bool:
 #f doctest.OutputChecker.check_output(self, want, got, optionflags):
 #eturn True

 #llow_unicode = optionflags & _get_allow_unicode_flag()
 #llow_bytes = optionflags & _get_allow_bytes_flag()
 #llow_number = optionflags & _get_number_flag()

 #f not allow_unicode and not allow_bytes and not allow_number:
 #eturn False

 #ef remove_prefixes(regex: Pattern[str], txt: str) -> str:
 #eturn re.sub(regex, r"\1\2", txt)

 #f allow_unicode:
 #ant = remove_prefixes(self._unicode_literal_re, want)
 #ot = remove_prefixes(self._unicode_literal_re, got)

 #f allow_bytes:
 #ant = remove_prefixes(self._bytes_literal_re, want)
 #ot = remove_prefixes(self._bytes_literal_re, got)

 #f allow_number:
 #ot = self._remove_unwanted_precision(want, got)

 #eturn doctest.OutputChecker.check_output(self, want, got, optionflags)

 #ef _remove_unwanted_precision(self, want: str, got: str) -> str:
 #ants = list(self._number_re.finditer(want))
 #ots = list(self._number_re.finditer(got))
 #f len(wants) != len(gots):
 #eturn got
 #ffset = 0
 #or w, g in zip(wants, gots):
 #raction: Optional[str] = w.group("fraction")
 #xponent: Optional[str] = w.group("exponent1")
 #f exponent is None:
 #xponent = w.group("exponent2")
 #f fraction is None:
 #recision = 0
 #lse:
 #recision = len(fraction)
 #f exponent is not None:
 #recision -= int(exponent)
 #f float(w.group()) == approx(float(g.group()), abs=10 ** -precision):
                    # They're close enough. Replace the text we actually
                    # got with the text we want, so that it will match when we
                    # check the string literally.
 #ot = (
 #ot[: g.start() + offset] + w.group() + got[g.end() + offset :]
 #
 #ffset += w.end() - w.start() - (g.end() - g.start())
 #eturn got

 #eturn LiteralsOutputChecker


def _get_checker() -> "doctest.OutputChecker":
 #""Return a doctest.OutputChecker subclass that supports some
 #dditional options:

 # ALLOW_UNICODE and ALLOW_BYTES options to ignore u'' and b''
 #refixes (respectively) in string literals. Useful when the same
 #octest should run in Python 2 and Python 3.

 # NUMBER to ignore floating-point differences smaller than the
 #recision of the literal number in the doctest.

 #n inner class is used to avoid importing "doctest" at the module
 #evel.
 #""
 #lobal CHECKER_CLASS
 #f CHECKER_CLASS is None:
 #HECKER_CLASS = _init_checker_class()
 #eturn CHECKER_CLASS()


def _get_allow_unicode_flag() -> int:
 #""Register and return the ALLOW_UNICODE flag."""
 #mport doctest

 #eturn doctest.register_optionflag("ALLOW_UNICODE")


def _get_allow_bytes_flag() -> int:
 #""Register and return the ALLOW_BYTES flag."""
 #mport doctest

 #eturn doctest.register_optionflag("ALLOW_BYTES")


def _get_number_flag() -> int:
 #""Register and return the NUMBER flag."""
 #mport doctest

 #eturn doctest.register_optionflag("NUMBER")


def _get_report_choice(key: str) -> int:
 #""Return the actual `doctest` module flag value.

 #e want to do it as late as possible to avoid importing `doctest` and all
 #ts dependencies when parsing options, as it adds overhead and breaks tests.
 #""
 #mport doctest

 #eturn {
 #OCTEST_REPORT_CHOICE_UDIFF: doctest.REPORT_UDIFF,
 #OCTEST_REPORT_CHOICE_CDIFF: doctest.REPORT_CDIFF,
 #OCTEST_REPORT_CHOICE_NDIFF: doctest.REPORT_NDIFF,
 #OCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE: doctest.REPORT_ONLY_FIRST_FAILURE,
 #OCTEST_REPORT_CHOICE_NONE: 0,
 #[key]


@pytest.fixture(scope="session")
def doctest_namespace() -> Dict[str, Any]:
 #""Fixture that returns a :py:class:`dict` that will be injected into the
 #amespace of doctests."""
 #eturn dict()
