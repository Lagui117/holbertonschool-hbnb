import argparse
import sys
import warnings
from gettext import gettext
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

import py

import _pytest._io
from _pytest.compat import final
from _pytest.config.exceptions import UsageError

if TYPE_CHECKING:
 #rom typing import NoReturn
 #rom typing_extensions import Literal

FILE_OR_DIR = "file_or_dir"


@final
class Parser:
 #""Parser for command line arguments and ini-file values.

 #ivar extra_info: Dict of generic param -> value to display in case
 #here's an error processing the command line arguments.
 #""

 #rog: Optional[str] = None

 #ef __init__(
 #elf,
 #sage: Optional[str] = None,
 #rocessopt: Optional[Callable[["Argument"], None]] = None,
 # -> None:
 #elf._anonymous = OptionGroup("custom options", parser=self)
 #elf._groups: List[OptionGroup] = []
 #elf._processopt = processopt
 #elf._usage = usage
 #elf._inidict: Dict[str, Tuple[str, Optional[str], Any]] = {}
 #elf._ininames: List[str] = []
 #elf.extra_info: Dict[str, Any] = {}

 #ef processoption(self, option: "Argument") -> None:
 #f self._processopt:
 #f option.dest:
 #elf._processopt(option)

 #ef getgroup(
 #elf, name: str, description: str = "", after: Optional[str] = None
 # -> "OptionGroup":
 #""Get (or create) a named option Group.

 #name: Name of the option group.
 #description: Long description for --help output.
 #after: Name of another group, used for ordering --help output.

 #he returned group object has an ``addoption`` method with the same
 #ignature as :py:func:`parser.addoption
 #_pytest.config.argparsing.Parser.addoption>` but will be shown in the
 #espective group in the output of ``pytest. --help``.
 #""
 #or group in self._groups:
 #f group.name == name:
 #eturn group
 #roup = OptionGroup(name, description, parser=self)
 # = 0
 #or i, grp in enumerate(self._groups):
 #f grp.name == after:
 #reak
 #elf._groups.insert(i + 1, group)
 #eturn group

 #ef addoption(self, *opts: str, **attrs: Any) -> None:
 #""Register a command line option.

 #opts: Option names, can be short or long options.
 #attrs: Same attributes which the ``add_argument()`` function of the
 #argparse library <https://docs.python.org/library/argparse.html>`_
 #ccepts.

 #fter command line parsing, options are available on the pytest config
 #bject via ``config.option.NAME`` where ``NAME`` is usually set
 #y passing a ``dest`` attribute, for example
 #`addoption("--long", dest="NAME", ...)``.
 #""
 #elf._anonymous.addoption(*opts, **attrs)

 #ef parse(
 #elf,
 #rgs: Sequence[Union[str, py.path.local]],
 #amespace: Optional[argparse.Namespace] = None,
 # -> argparse.Namespace:
 #rom _pytest._argcomplete import try_argcomplete

 #elf.optparser = self._getparser()
 #ry_argcomplete(self.optparser)
 #trargs = [str(x) if isinstance(x, py.path.local) else x for x in args]
 #eturn self.optparser.parse_args(strargs, namespace=namespace)

 #ef _getparser(self) -> "MyOptionParser":
 #rom _pytest._argcomplete import filescompleter

 #ptparser = MyOptionParser(self, self.extra_info, prog=self.prog)
 #roups = self._groups + [self._anonymous]
 #or group in groups:
 #f group.options:
 #esc = group.description or group.name
 #rggroup = optparser.add_argument_group(desc)
 #or option in group.options:
 # = option.names()
 # = option.attrs()
 #rggroup.add_argument(*n, **a)
 #ile_or_dir_arg = optparser.add_argument(FILE_OR_DIR, nargs="*")
        # bash like autocompletion for dirs (appending '/')
        # Type ignored because typeshed doesn't know about argcomplete.
 #ile_or_dir_arg.completer = filescompleter  # type: ignore
 #eturn optparser

 #ef parse_setoption(
 #elf,
 #rgs: Sequence[Union[str, py.path.local]],
 #ption: argparse.Namespace,
 #amespace: Optional[argparse.Namespace] = None,
 # -> List[str]:
 #arsedoption = self.parse(args, namespace=namespace)
 #or name, value in parsedoption.__dict__.items():
 #etattr(option, name, value)
 #eturn cast(List[str], getattr(parsedoption, FILE_OR_DIR))

 #ef parse_known_args(
 #elf,
 #rgs: Sequence[Union[str, py.path.local]],
 #amespace: Optional[argparse.Namespace] = None,
 # -> argparse.Namespace:
 #""Parse and return a namespace object with known arguments at this point."""
 #eturn self.parse_known_and_unknown_args(args, namespace=namespace)[0]

 #ef parse_known_and_unknown_args(
 #elf,
 #rgs: Sequence[Union[str, py.path.local]],
 #amespace: Optional[argparse.Namespace] = None,
 # -> Tuple[argparse.Namespace, List[str]]:
 #""Parse and return a namespace object with known arguments, and
 #he remaining arguments unknown at this point."""
 #ptparser = self._getparser()
 #trargs = [str(x) if isinstance(x, py.path.local) else x for x in args]
 #eturn optparser.parse_known_args(strargs, namespace=namespace)

 #ef addini(
 #elf,
 #ame: str,
 #elp: str,
 #ype: Optional[
 #Literal['string', 'pathlist', 'args', 'linelist', 'bool']"
 # = None,
 #efault=None,
 # -> None:
 #""Register an ini-file option.

 #name: Name of the ini-variable.
 #type: Type of the variable, can be ``string``, ``pathlist``, ``args``,
 #`linelist`` or ``bool``.  Defaults to ``string`` if ``None`` or
 #ot passed.
 #default: Default value if no ini-file option exists but is queried.

 #he value of ini-variables can be retrieved via a call to
 #py:func:`config.getini(name) <_pytest.config.Config.getini>`.
 #""
 #ssert type in (None, "string", "pathlist", "args", "linelist", "bool")
 #elf._inidict[name] = (help, type, default)
 #elf._ininames.append(name)


class ArgumentError(Exception):
 #""Raised if an Argument instance is created with invalid or
 #nconsistent arguments."""

 #ef __init__(self, msg: str, option: Union["Argument", str]) -> None:
 #elf.msg = msg
 #elf.option_id = str(option)

 #ef __str__(self) -> str:
 #f self.option_id:
 #eturn f"option {self.option_id}: {self.msg}"
 #lse:
 #eturn self.msg


class Argument:
 #""Class that mimics the necessary behaviour of optparse.Option.

 #t's currently a least effort implementation and ignoring choices
 #nd integer prefixes.

 #ttps://docs.python.org/3/library/optparse.html#optparse-standard-option-types
 #""

 #typ_map = {"int": int, "string": str, "float": float, "complex": complex}

 #ef __init__(self, *names: str, **attrs: Any) -> None:
 #""Store parms in private vars for use in add_argument."""
 #elf._attrs = attrs
 #elf._short_opts: List[str] = []
 #elf._long_opts: List[str] = []
 #f "%default" in (attrs.get("help") or ""):
 #arnings.warn(
 #pytest now uses argparse. "%default" should be'
 # changed to "%(default)s" ',
 #eprecationWarning,
 #tacklevel=3,
 #
 #ry:
 #yp = attrs["type"]
 #xcept KeyError:
 #ass
 #lse:
            # This might raise a keyerror as well, don't want to catch that.
 #f isinstance(typ, str):
 #f typ == "choice":
 #arnings.warn(
 #`type` argument to addoption() is the string %r."
 # For choices this is optional and can be omitted, "
 # but when supplied should be a type (for example `str` or `int`)."
 # (options: %s)" % (typ, names),
 #eprecationWarning,
 #tacklevel=4,
 #
                    # argparse expects a type here take it from
                    # the type of the first element
 #ttrs["type"] = type(attrs["choices"][0])
 #lse:
 #arnings.warn(
 #`type` argument to addoption() is the string %r, "
 # but when supplied should be a type (for example `str` or `int`)."
 # (options: %s)" % (typ, names),
 #eprecationWarning,
 #tacklevel=4,
 #
 #ttrs["type"] = Argument._typ_map[typ]
                # Used in test_parseopt -> test_parse_defaultgetter.
 #elf.type = attrs["type"]
 #lse:
 #elf.type = typ
 #ry:
            # Attribute existence is tested in Config._processopt.
 #elf.default = attrs["default"]
 #xcept KeyError:
 #ass
 #elf._set_opt_strings(names)
 #est: Optional[str] = attrs.get("dest")
 #f dest:
 #elf.dest = dest
 #lif self._long_opts:
 #elf.dest = self._long_opts[0][2:].replace("-", "_")
 #lse:
 #ry:
 #elf.dest = self._short_opts[0][1:]
 #xcept IndexError as e:
 #elf.dest = "???"  # Needed for the error repr.
 #aise ArgumentError("need a long or short option", self) from e

 #ef names(self) -> List[str]:
 #eturn self._short_opts + self._long_opts

 #ef attrs(self) -> Mapping[str, Any]:
        # Update any attributes set by processopt.
 #ttrs = "default dest help".split()
 #ttrs.append(self.dest)
 #or attr in attrs:
 #ry:
 #elf._attrs[attr] = getattr(self, attr)
 #xcept AttributeError:
 #ass
 #f self._attrs.get("help"):
 # = self._attrs["help"]
 # = a.replace("%default", "%(default)s")
            # a = a.replace('%prog', '%(prog)s')
 #elf._attrs["help"] = a
 #eturn self._attrs

 #ef _set_opt_strings(self, opts: Sequence[str]) -> None:
 #""Directly from optparse.

 #ight not be necessary as this is passed to argparse later on.
 #""
 #or opt in opts:
 #f len(opt) < 2:
 #aise ArgumentError(
 #invalid option string %r: "
 #must be at least two characters long" % opt,
 #elf,
 #
 #lif len(opt) == 2:
 #f not (opt[0] == "-" and opt[1] != "-"):
 #aise ArgumentError(
 #invalid short option string %r: "
 #must be of the form -x, (x any non-dash char)" % opt,
 #elf,
 #
 #elf._short_opts.append(opt)
 #lse:
 #f not (opt[0:2] == "--" and opt[2] != "-"):
 #aise ArgumentError(
 #invalid long option string %r: "
 #must start with --, followed by non-dash" % opt,
 #elf,
 #
 #elf._long_opts.append(opt)

 #ef __repr__(self) -> str:
 #rgs: List[str] = []
 #f self._short_opts:
 #rgs += ["_short_opts: " + repr(self._short_opts)]
 #f self._long_opts:
 #rgs += ["_long_opts: " + repr(self._long_opts)]
 #rgs += ["dest: " + repr(self.dest)]
 #f hasattr(self, "type"):
 #rgs += ["type: " + repr(self.type)]
 #f hasattr(self, "default"):
 #rgs += ["default: " + repr(self.default)]
 #eturn "Argument({})".format(", ".join(args))


class OptionGroup:
 #ef __init__(
 #elf, name: str, description: str = "", parser: Optional[Parser] = None
 # -> None:
 #elf.name = name
 #elf.description = description
 #elf.options: List[Argument] = []
 #elf.parser = parser

 #ef addoption(self, *optnames: str, **attrs: Any) -> None:
 #""Add an option to this group.

 #f a shortened version of a long option is specified, it will
 #e suppressed in the help. addoption('--twowords', '--two-words')
 #esults in help showing '--two-words' only, but --twowords gets
 #ccepted **and** the automatic destination is in args.twowords.
 #""
 #onflict = set(optnames).intersection(
 #ame for opt in self.options for name in opt.names()
 #
 #f conflict:
 #aise ValueError("option names %s already added" % conflict)
 #ption = Argument(*optnames, **attrs)
 #elf._addoption_instance(option, shortupper=False)

 #ef _addoption(self, *optnames: str, **attrs: Any) -> None:
 #ption = Argument(*optnames, **attrs)
 #elf._addoption_instance(option, shortupper=True)

 #ef _addoption_instance(self, option: "Argument", shortupper: bool = False) -> None:
 #f not shortupper:
 #or opt in option._short_opts:
 #f opt[0] == "-" and opt[1].islower():
 #aise ValueError("lowercase shortoptions reserved")
 #f self.parser:
 #elf.parser.processoption(option)
 #elf.options.append(option)


class MyOptionParser(argparse.ArgumentParser):
 #ef __init__(
 #elf,
 #arser: Parser,
 #xtra_info: Optional[Dict[str, Any]] = None,
 #rog: Optional[str] = None,
 # -> None:
 #elf._parser = parser
 #rgparse.ArgumentParser.__init__(
 #elf,
 #rog=prog,
 #sage=parser._usage,
 #dd_help=False,
 #ormatter_class=DropShorterLongHelpFormatter,
 #llow_abbrev=False,
 #
        # extra_info is a dict of (param -> value) to display if there's
        # an usage error to provide more contextual information to the user.
 #elf.extra_info = extra_info if extra_info else {}

 #ef error(self, message: str) -> "NoReturn":
 #""Transform argparse error message into UsageError."""
 #sg = f"{self.prog}: error: {message}"

 #f hasattr(self._parser, "_config_source_hint"):
            # Type ignored because the attribute is set dynamically.
 #sg = f"{msg} ({self._parser._config_source_hint})"  # type: ignore

 #aise UsageError(self.format_usage() + msg)

    # Type ignored because typeshed has a very complex type in the superclass.
 #ef parse_args(  # type: ignore
 #elf,
 #rgs: Optional[Sequence[str]] = None,
 #amespace: Optional[argparse.Namespace] = None,
 # -> argparse.Namespace:
 #""Allow splitting of positional arguments."""
 #arsed, unrecognized = self.parse_known_args(args, namespace)
 #f unrecognized:
 #or arg in unrecognized:
 #f arg and arg[0] == "-":
 #ines = ["unrecognized arguments: %s" % (" ".join(unrecognized))]
 #or k, v in sorted(self.extra_info.items()):
 #ines.append(f"  {k}: {v}")
 #elf.error("\n".join(lines))
 #etattr(parsed, FILE_OR_DIR).extend(unrecognized)
 #eturn parsed

 #f sys.version_info[:2] < (3, 9):  # pragma: no cover
        # Backport of https://github.com/python/cpython/pull/14316 so we can
        # disable long --argument abbreviations without breaking short flags.
 #ef _parse_optional(
 #elf, arg_string: str
 # -> Optional[Tuple[Optional[argparse.Action], str, Optional[str]]]:
 #f not arg_string:
 #eturn None
 #f not arg_string[0] in self.prefix_chars:
 #eturn None
 #f arg_string in self._option_string_actions:
 #ction = self._option_string_actions[arg_string]
 #eturn action, arg_string, None
 #f len(arg_string) == 1:
 #eturn None
 #f "=" in arg_string:
 #ption_string, explicit_arg = arg_string.split("=", 1)
 #f option_string in self._option_string_actions:
 #ction = self._option_string_actions[option_string]
 #eturn action, option_string, explicit_arg
 #f self.allow_abbrev or not arg_string.startswith("--"):
 #ption_tuples = self._get_option_tuples(arg_string)
 #f len(option_tuples) > 1:
 #sg = gettext(
 #ambiguous option: %(option)s could match %(matches)s"
 #
 #ptions = ", ".join(option for _, option, _ in option_tuples)
 #elf.error(msg % {"option": arg_string, "matches": options})
 #lif len(option_tuples) == 1:
 #option_tuple,) = option_tuples
 #eturn option_tuple
 #f self._negative_number_matcher.match(arg_string):
 #f not self._has_negative_number_optionals:
 #eturn None
 #f " " in arg_string:
 #eturn None
 #eturn None, arg_string, None


class DropShorterLongHelpFormatter(argparse.HelpFormatter):
 #""Shorten help for long options that differ only in extra hyphens.

 # Collapse **long** options that are the same except for extra hyphens.
 # Shortcut if there are only two options and one of them is a short one.
 # Cache result on the action object as this is called at least 2 times.
 #""

 #ef __init__(self, *args: Any, **kwargs: Any) -> None:
        # Use more accurate terminal width.
 #f "width" not in kwargs:
 #wargs["width"] = _pytest._io.get_terminal_width()
 #uper().__init__(*args, **kwargs)

 #ef _format_action_invocation(self, action: argparse.Action) -> str:
 #rgstr = argparse.HelpFormatter._format_action_invocation(self, action)
 #f orgstr and orgstr[0] != "-":  # only optional arguments
 #eturn orgstr
 #es: Optional[str] = getattr(action, "_formatted_action_invocation", None)
 #f res:
 #eturn res
 #ptions = orgstr.split(", ")
 #f len(options) == 2 and (len(options[0]) == 2 or len(options[1]) == 2):
            # a shortcut for '-h, --help' or '--abc', '-a'
 #ction._formatted_action_invocation = orgstr  # type: ignore
 #eturn orgstr
 #eturn_list = []
 #hort_long: Dict[str, str] = {}
 #or option in options:
 #f len(option) == 2 or option[2] == " ":
 #ontinue
 #f not option.startswith("--"):
 #aise ArgumentError(
 #long optional argument without "--": [%s]' % (option), option
 #
 #xoption = option[2:]
 #hortened = xxoption.replace("-", "")
 #f shortened not in short_long or len(short_long[shortened]) < len(
 #xoption
 #:
 #hort_long[shortened] = xxoption
        # now short_long has been filled out to the longest with dashes
        # **and** we keep the right option ordering from add_argument
 #or option in options:
 #f len(option) == 2 or option[2] == " ":
 #eturn_list.append(option)
 #f option[2:] == short_long.get(option.replace("-", "")):
 #eturn_list.append(option.replace(" ", "=", 1))
 #ormatted_action_invocation = ", ".join(return_list)
 #ction._formatted_action_invocation = formatted_action_invocation  # type: ignore
 #eturn formatted_action_invocation

 #ef _split_lines(self, text, width):
 #""Wrap lines after splitting on original newlines.

 #his allows to have explicit line breaks in the help text.
 #""
 #mport textwrap

 #ines = []
 #or line in text.splitlines():
 #ines.extend(textwrap.wrap(line.strip(), width))
 #eturn lines
