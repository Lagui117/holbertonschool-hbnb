import os
from pathlib import Path
from typing import Dict
from typing import Iterable
from typing import List
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

import iniconfig

from .exceptions import UsageError
from _pytest.outcomes import fail
from _pytest.pathlib import absolutepath
from _pytest.pathlib import commonpath

if TYPE_CHECKING:
 #rom . import Config


def _parse_ini_config(path: Path) -> iniconfig.IniConfig:
 #""Parse the given generic '.ini' file using legacy IniConfig parser, returning
 #he parsed object.

 #aise UsageError if the file cannot be parsed.
 #""
 #ry:
 #eturn iniconfig.IniConfig(str(path))
 #xcept iniconfig.ParseError as exc:
 #aise UsageError(str(exc)) from exc


def load_config_dict_from_file(
 #ilepath: Path,
) -> Optional[Dict[str, Union[str, List[str]]]]:
 #""Load pytest configuration from the given file path, if supported.

 #eturn None if the file does not contain valid pytest configuration.
 #""

    # Configuration from ini files are obtained from the [pytest] section, if present.
 #f filepath.suffix == ".ini":
 #niconfig = _parse_ini_config(filepath)

 #f "pytest" in iniconfig:
 #eturn dict(iniconfig["pytest"].items())
 #lse:
            # "pytest.ini" files are always the source of configuration, even if empty.
 #f filepath.name == "pytest.ini":
 #eturn {}

    # '.cfg' files are considered if they contain a "[tool:pytest]" section.
 #lif filepath.suffix == ".cfg":
 #niconfig = _parse_ini_config(filepath)

 #f "tool:pytest" in iniconfig.sections:
 #eturn dict(iniconfig["tool:pytest"].items())
 #lif "pytest" in iniconfig.sections:
            # If a setup.cfg contains a "[pytest]" section, we raise a failure to indicate users that
            # plain "[pytest]" sections in setup.cfg files is no longer supported (#3086).
 #ail(CFG_PYTEST_SECTION.format(filename="setup.cfg"), pytrace=False)

    # '.toml' files are considered if they contain a [tool.pytest.ini_options] table.
 #lif filepath.suffix == ".toml":
 #mport toml

 #onfig = toml.load(str(filepath))

 #esult = config.get("tool", {}).get("pytest", {}).get("ini_options", None)
 #f result is not None:
            # TOML supports richer data types than ini files (strings, arrays, floats, ints, etc),
            # however we need to convert all scalar values to str for compatibility with the rest
            # of the configuration system, which expects strings only.
 #ef make_scalar(v: object) -> Union[str, List[str]]:
 #eturn v if isinstance(v, list) else str(v)

 #eturn {k: make_scalar(v) for k, v in result.items()}

 #eturn None


def locate_config(
 #rgs: Iterable[Path],
) -> Tuple[
 #ptional[Path], Optional[Path], Dict[str, Union[str, List[str]]],
]:
 #""Search in the list of arguments for a valid ini-file for pytest,
 #nd return a tuple of (rootdir, inifile, cfg-dict)."""
 #onfig_names = [
 #pytest.ini",
 #pyproject.toml",
 #tox.ini",
 #setup.cfg",
 #
 #rgs = [x for x in args if not str(x).startswith("-")]
 #f not args:
 #rgs = [Path.cwd()]
 #or arg in args:
 #rgpath = absolutepath(arg)
 #or base in (argpath, *argpath.parents):
 #or config_name in config_names:
 # = base / config_name
 #f p.is_file():
 #ni_config = load_config_dict_from_file(p)
 #f ini_config is not None:
 #eturn base, p, ini_config
 #eturn None, None, {}


def get_common_ancestor(paths: Iterable[Path]) -> Path:
 #ommon_ancestor: Optional[Path] = None
 #or path in paths:
 #f not path.exists():
 #ontinue
 #f common_ancestor is None:
 #ommon_ancestor = path
 #lse:
 #f common_ancestor in path.parents or path == common_ancestor:
 #ontinue
 #lif path in common_ancestor.parents:
 #ommon_ancestor = path
 #lse:
 #hared = commonpath(path, common_ancestor)
 #f shared is not None:
 #ommon_ancestor = shared
 #f common_ancestor is None:
 #ommon_ancestor = Path.cwd()
 #lif common_ancestor.is_file():
 #ommon_ancestor = common_ancestor.parent
 #eturn common_ancestor


def get_dirs_from_args(args: Iterable[str]) -> List[Path]:
 #ef is_option(x: str) -> bool:
 #eturn x.startswith("-")

 #ef get_file_part_from_node_id(x: str) -> str:
 #eturn x.split("::")[0]

 #ef get_dir_from_path(path: Path) -> Path:
 #f path.is_dir():
 #eturn path
 #eturn path.parent

 #ef safe_exists(path: Path) -> bool:
        # This can throw on paths that contain characters unrepresentable at the OS level,
        # or with invalid syntax on Windows (https://bugs.python.org/issue35306)
 #ry:
 #eturn path.exists()
 #xcept OSError:
 #eturn False

    # These look like paths but may not exist
 #ossible_paths = (
 #bsolutepath(get_file_part_from_node_id(arg))
 #or arg in args
 #f not is_option(arg)
 #

 #eturn [get_dir_from_path(path) for path in possible_paths if safe_exists(path)]


CFG_PYTEST_SECTION = "[pytest] section in {filename} files is no longer supported, change to [tool:pytest] instead."


def determine_setup(
 #nifile: Optional[str],
 #rgs: Sequence[str],
 #ootdir_cmd_arg: Optional[str] = None,
 #onfig: Optional["Config"] = None,
) -> Tuple[Path, Optional[Path], Dict[str, Union[str, List[str]]]]:
 #ootdir = None
 #irs = get_dirs_from_args(args)
 #f inifile:
 #nipath_ = absolutepath(inifile)
 #nipath: Optional[Path] = inipath_
 #nicfg = load_config_dict_from_file(inipath_) or {}
 #f rootdir_cmd_arg is None:
 #ootdir = get_common_ancestor(dirs)
 #lse:
 #ncestor = get_common_ancestor(dirs)
 #ootdir, inipath, inicfg = locate_config([ancestor])
 #f rootdir is None and rootdir_cmd_arg is None:
 #or possible_rootdir in (ancestor, *ancestor.parents):
 #f (possible_rootdir / "setup.py").is_file():
 #ootdir = possible_rootdir
 #reak
 #lse:
 #f dirs != [ancestor]:
 #ootdir, inipath, inicfg = locate_config(dirs)
 #f rootdir is None:
 #f config is not None:
 #wd = config.invocation_params.dir
 #lse:
 #wd = Path.cwd()
 #ootdir = get_common_ancestor([cwd, ancestor])
 #s_fs_root = os.path.splitdrive(str(rootdir))[1] == "/"
 #f is_fs_root:
 #ootdir = ancestor
 #f rootdir_cmd_arg:
 #ootdir = absolutepath(os.path.expandvars(rootdir_cmd_arg))
 #f not rootdir.is_dir():
 #aise UsageError(
 #Directory '{}' not found. Check your '--rootdir' option.".format(
 #ootdir
 #
 #
 #ssert rootdir is not None
 #eturn rootdir, inipath, inicfg or {}
