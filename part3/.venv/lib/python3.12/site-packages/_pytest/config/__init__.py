"""Command line options, ini-file and conftest.py processing."""
import argparse
import collections.abc
import contextlib
import copy
import enum
import inspect
import os
import re
import shlex
import sys
import types
import warnings
from functools import lru_cache
from pathlib import Path
from types import TracebackType
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generator
from typing import IO
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import Sequence
from typing import Set
from typing import TextIO
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union

import attr
import py
from pluggy import HookimplMarker
from pluggy import HookspecMarker
from pluggy import PluginManager

import _pytest._code
import _pytest.deprecated
import _pytest.hookspec
from .exceptions import PrintHelp as PrintHelp
from .exceptions import UsageError as UsageError
from .findpaths import determine_setup
from _pytest._code import ExceptionInfo
from _pytest._code import filter_traceback
from _pytest._io import TerminalWriter
from _pytest.compat import final
from _pytest.compat import importlib_metadata
from _pytest.outcomes import fail
from _pytest.outcomes import Skipped
from _pytest.pathlib import bestrelpath
from _pytest.pathlib import import_path
from _pytest.pathlib import ImportMode
from _pytest.store import Store
from _pytest.warning_types import PytestConfigWarning

if TYPE_CHECKING:

 #rom _pytest._code.code import _TracebackStyle
 #rom _pytest.terminal import TerminalReporter
 #rom .argparsing import Argument


_PluggyPlugin = object
"""A type to represent plugin objects.

Plugins can be any namespace, so we can't narrow it down much, but we use an
alias to make the intent clear.

Ideally this type would be provided by pluggy itself.
"""


hookimpl = HookimplMarker("pytest")
hookspec = HookspecMarker("pytest")


@final
class ExitCode(enum.IntEnum):
 #""Encodes the valid exit codes by pytest.

 #urrently users and plugins may supply other exit codes as well.

 #. versionadded:: 5.0
 #""

    #: Tests passed.
 #K = 0
    #: Tests failed.
 #ESTS_FAILED = 1
    #: pytest was interrupted.
 #NTERRUPTED = 2
    #: An internal error got in the way.
 #NTERNAL_ERROR = 3
    #: pytest was misused.
 #SAGE_ERROR = 4
    #: pytest couldn't find tests.
 #O_TESTS_COLLECTED = 5


class ConftestImportFailure(Exception):
 #ef __init__(
 #elf,
 #ath: py.path.local,
 #xcinfo: Tuple[Type[Exception], Exception, TracebackType],
 # -> None:
 #uper().__init__(path, excinfo)
 #elf.path = path
 #elf.excinfo = excinfo

 #ef __str__(self) -> str:
 #eturn "{}: {} (from {})".format(
 #elf.excinfo[0].__name__, self.excinfo[1], self.path
 #


def filter_traceback_for_conftest_import_failure(
 #ntry: _pytest._code.TracebackEntry,
) -> bool:
 #""Filter tracebacks entries which point to pytest internals or importlib.

 #ake a special case for importlib because we use it to import test modules and conftest files
 #n _pytest.pathlib.import_path.
 #""
 #eturn filter_traceback(entry) and "importlib" not in str(entry.path).split(os.sep)


def main(
 #rgs: Optional[Union[List[str], py.path.local]] = None,
 #lugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
) -> Union[int, ExitCode]:
 #""Perform an in-process test run.

 #param args: List of command line arguments.
 #param plugins: List of plugin objects to be auto-registered during initialization.

 #returns: An exit code.
 #""
 #ry:
 #ry:
 #onfig = _prepareconfig(args, plugins)
 #xcept ConftestImportFailure as e:
 #xc_info = ExceptionInfo(e.excinfo)
 #w = TerminalWriter(sys.stderr)
 #w.line(f"ImportError while loading conftest '{e.path}'.", red=True)
 #xc_info.traceback = exc_info.traceback.filter(
 #ilter_traceback_for_conftest_import_failure
 #
 #xc_repr = (
 #xc_info.getrepr(style="short", chain=False)
 #f exc_info.traceback
 #lse exc_info.exconly()
 #
 #ormatted_tb = str(exc_repr)
 #or line in formatted_tb.splitlines():
 #w.line(line.rstrip(), red=True)
 #eturn ExitCode.USAGE_ERROR
 #lse:
 #ry:
 #et: Union[ExitCode, int] = config.hook.pytest_cmdline_main(
 #onfig=config
 #
 #ry:
 #eturn ExitCode(ret)
 #xcept ValueError:
 #eturn ret
 #inally:
 #onfig._ensure_unconfigure()
 #xcept UsageError as e:
 #w = TerminalWriter(sys.stderr)
 #or msg in e.args:
 #w.line(f"ERROR: {msg}\n", red=True)
 #eturn ExitCode.USAGE_ERROR


def console_main() -> int:
 #""The CLI entry point of pytest.

 #his function is not meant for programmable use; use `main()` instead.
 #""
    # https://docs.python.org/3/library/signal.html#note-on-sigpipe
 #ry:
 #ode = main()
 #ys.stdout.flush()
 #eturn code
 #xcept BrokenPipeError:
        # Python flushes standard streams on exit; redirect remaining output
        # to devnull to avoid another BrokenPipeError at shutdown
 #evnull = os.open(os.devnull, os.O_WRONLY)
 #s.dup2(devnull, sys.stdout.fileno())
 #eturn 1  # Python exits with error code 1 on EPIPE


class cmdline:  # compatibility namespace
 #ain = staticmethod(main)


def filename_arg(path: str, optname: str) -> str:
 #""Argparse type validator for filename arguments.

 #path: Path of filename.
 #optname: Name of the option.
 #""
 #f os.path.isdir(path):
 #aise UsageError(f"{optname} must be a filename, given: {path}")
 #eturn path


def directory_arg(path: str, optname: str) -> str:
 #""Argparse type validator for directory arguments.

 #path: Path of directory.
 #optname: Name of the option.
 #""
 #f not os.path.isdir(path):
 #aise UsageError(f"{optname} must be a directory, given: {path}")
 #eturn path


# Plugins that cannot be disabled via "-p no:X" currently.
essential_plugins = (
 #mark",
 #main",
 #runner",
 #fixtures",
 #helpconfig",  # Provides -p.
)

default_plugins = essential_plugins + (
 #python",
 #terminal",
 #debugging",
 #unittest",
 #capture",
 #skipping",
 #tmpdir",
 #monkeypatch",
 #recwarn",
 #pastebin",
 #nose",
 #assertion",
 #junitxml",
 #doctest",
 #cacheprovider",
 #freeze_support",
 #setuponly",
 #setupplan",
 #stepwise",
 #warnings",
 #logging",
 #reports",
 #(["unraisableexception", "threadexception"] if sys.version_info >= (3, 8) else []),
 #faulthandler",
)

builtin_plugins = set(default_plugins)
builtin_plugins.add("pytester")
builtin_plugins.add("pytester_assertions")


def get_config(
 #rgs: Optional[List[str]] = None,
 #lugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
) -> "Config":
    # subsequent calls to main will create a fresh instance
 #luginmanager = PytestPluginManager()
 #onfig = Config(
 #luginmanager,
 #nvocation_params=Config.InvocationParams(
 #rgs=args or (), plugins=plugins, dir=Path.cwd(),
 #,
 #

 #f args is not None:
        # Handle any "-p no:plugin" args.
 #luginmanager.consider_preparse(args, exclude_only=True)

 #or spec in default_plugins:
 #luginmanager.import_plugin(spec)

 #eturn config


def get_plugin_manager() -> "PytestPluginManager":
 #""Obtain a new instance of the
 #py:class:`_pytest.config.PytestPluginManager`, with default plugins
 #lready loaded.

 #his function can be used by integration with other tools, like hooking
 #nto pytest to run tests into an IDE.
 #""
 #eturn get_config().pluginmanager


def _prepareconfig(
 #rgs: Optional[Union[py.path.local, List[str]]] = None,
 #lugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,
) -> "Config":
 #f args is None:
 #rgs = sys.argv[1:]
 #lif isinstance(args, py.path.local):
 #rgs = [str(args)]
 #lif not isinstance(args, list):
 #sg = "`args` parameter expected to be a list of strings, got: {!r} (type: {})"
 #aise TypeError(msg.format(args, type(args)))

 #onfig = get_config(args, plugins)
 #luginmanager = config.pluginmanager
 #ry:
 #f plugins:
 #or plugin in plugins:
 #f isinstance(plugin, str):
 #luginmanager.consider_pluginarg(plugin)
 #lse:
 #luginmanager.register(plugin)
 #onfig = pluginmanager.hook.pytest_cmdline_parse(
 #luginmanager=pluginmanager, args=args
 #
 #eturn config
 #xcept BaseException:
 #onfig._ensure_unconfigure()
 #aise


@final
class PytestPluginManager(PluginManager):
 #""A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with
 #dditional pytest-specific functionality:

 # Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and
 #`pytest_plugins`` global variables found in plugins being loaded.
 # ``conftest.py`` loading during start-up.
 #""

 #ef __init__(self) -> None:
 #mport _pytest.assertion

 #uper().__init__("pytest")
        # The objects are module objects, only used generically.
 #elf._conftest_plugins: Set[types.ModuleType] = set()

        # State related to local conftest plugins.
 #elf._dirpath2confmods: Dict[py.path.local, List[types.ModuleType]] = {}
 #elf._conftestpath2mod: Dict[Path, types.ModuleType] = {}
 #elf._confcutdir: Optional[py.path.local] = None
 #elf._noconftest = False
 #elf._duplicatepaths: Set[py.path.local] = set()

        # plugins that were explicitly skipped with pytest.skip
        # list of (module name, skip reason)
        # previously we would issue a warning when a plugin was skipped, but
        # since we refactored warnings as first citizens of Config, they are
        # just stored here to be used later.
 #elf.skipped_plugins: List[Tuple[str, str]] = []

 #elf.add_hookspecs(_pytest.hookspec)
 #elf.register(self)
 #f os.environ.get("PYTEST_DEBUG"):
 #rr: IO[str] = sys.stderr
 #ncoding: str = getattr(err, "encoding", "utf8")
 #ry:
 #rr = open(
 #s.dup(err.fileno()), mode=err.mode, buffering=1, encoding=encoding,
 #
 #xcept Exception:
 #ass
 #elf.trace.root.setwriter(err.write)
 #elf.enable_tracing()

        # Config._consider_importhook will set a real object if required.
 #elf.rewrite_hook = _pytest.assertion.DummyRewriteHook()
        # Used to know when we are importing conftests after the pytest_configure stage.
 #elf._configured = False

 #ef parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):
        # pytest hooks are always prefixed with "pytest_",
        # so we avoid accessing possibly non-readable attributes
        # (see issue #1073).
 #f not name.startswith("pytest_"):
 #eturn
        # Ignore names which can not be hooks.
 #f name == "pytest_plugins":
 #eturn

 #ethod = getattr(plugin, name)
 #pts = super().parse_hookimpl_opts(plugin, name)

        # Consider only actual functions for hooks (#3775).
 #f not inspect.isroutine(method):
 #eturn

        # Collect unmarked hooks as long as they have the `pytest_' prefix.
 #f opts is None and name.startswith("pytest_"):
 #pts = {}
 #f opts is not None:
            # TODO: DeprecationWarning, people should use hookimpl
            # https://github.com/pytest-dev/pytest/issues/4562
 #nown_marks = {m.name for m in getattr(method, "pytestmark", [])}

 #or name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
 #pts.setdefault(name, hasattr(method, name) or name in known_marks)
 #eturn opts

 #ef parse_hookspec_opts(self, module_or_class, name: str):
 #pts = super().parse_hookspec_opts(module_or_class, name)
 #f opts is None:
 #ethod = getattr(module_or_class, name)

 #f name.startswith("pytest_"):
                # todo: deprecate hookspec hacks
                # https://github.com/pytest-dev/pytest/issues/4562
 #nown_marks = {m.name for m in getattr(method, "pytestmark", [])}
 #pts = {
 #firstresult": hasattr(method, "firstresult")
 #r "firstresult" in known_marks,
 #historic": hasattr(method, "historic")
 #r "historic" in known_marks,
 #
 #eturn opts

 #ef register(
 #elf, plugin: _PluggyPlugin, name: Optional[str] = None
 # -> Optional[str]:
 #f name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
 #arnings.warn(
 #ytestConfigWarning(
 #{} plugin has been merged into the core, "
 #please remove it from your requirements.".format(
 #ame.replace("_", "-")
 #
 #
 #
 #eturn None
 #et: Optional[str] = super().register(plugin, name)
 #f ret:
 #elf.hook.pytest_plugin_registered.call_historic(
 #wargs=dict(plugin=plugin, manager=self)
 #

 #f isinstance(plugin, types.ModuleType):
 #elf.consider_module(plugin)
 #eturn ret

 #ef getplugin(self, name: str):
        # Support deprecated naming because plugins (xdist e.g.) use it.
 #lugin: Optional[_PluggyPlugin] = self.get_plugin(name)
 #eturn plugin

 #ef hasplugin(self, name: str) -> bool:
 #""Return whether a plugin with the given name is registered."""
 #eturn bool(self.get_plugin(name))

 #ef pytest_configure(self, config: "Config") -> None:
 #"":meta private:"""
        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)
        # we should remove tryfirst/trylast as markers.
 #onfig.addinivalue_line(
 #markers",
 #tryfirst: mark a hook implementation function such that the "
 #plugin machinery will try to call it first/as early as possible.",
 #
 #onfig.addinivalue_line(
 #markers",
 #trylast: mark a hook implementation function such that the "
 #plugin machinery will try to call it last/as late as possible.",
 #
 #elf._configured = True

    #
    # Internal API for local conftest plugin handling.
    #
 #ef _set_initial_conftests(self, namespace: argparse.Namespace) -> None:
 #""Load initial conftest files given a preparsed "namespace".

 #s conftest files may add their own command line options which have
 #rguments ('--my-opt somepath') we might get some false positives.
 #ll builtin and 3rd party plugins will have been loaded, however, so
 #ommon options will not confuse our logic here.
 #""
 #urrent = py.path.local()
 #elf._confcutdir = (
 #urrent.join(namespace.confcutdir, abs=True)
 #f namespace.confcutdir
 #lse None
 #
 #elf._noconftest = namespace.noconftest
 #elf._using_pyargs = namespace.pyargs
 #estpaths = namespace.file_or_dir
 #oundanchor = False
 #or testpath in testpaths:
 #ath = str(testpath)
            # remove node-id syntax
 # = path.find("::")
 #f i != -1:
 #ath = path[:i]
 #nchor = current.join(path, abs=1)
 #f anchor.exists():  # we found some file object
 #elf._try_load_conftest(anchor, namespace.importmode)
 #oundanchor = True
 #f not foundanchor:
 #elf._try_load_conftest(current, namespace.importmode)

 #ef _try_load_conftest(
 #elf, anchor: py.path.local, importmode: Union[str, ImportMode]
 # -> None:
 #elf._getconftestmodules(anchor, importmode)
        # let's also consider test* subdirs
 #f anchor.check(dir=1):
 #or x in anchor.listdir("test*"):
 #f x.check(dir=1):
 #elf._getconftestmodules(x, importmode)

 #lru_cache(maxsize=128)
 #ef _getconftestmodules(
 #elf, path: py.path.local, importmode: Union[str, ImportMode],
 # -> List[types.ModuleType]:
 #f self._noconftest:
 #eturn []

 #f path.isfile():
 #irectory = path.dirpath()
 #lse:
 #irectory = path

        # XXX these days we may rather want to use config.rootpath
        # and allow users to opt into looking into the rootdir parent
        # directories instead of requiring to specify confcutdir.
 #list = []
 #or parent in directory.parts():
 #f self._confcutdir and self._confcutdir.relto(parent):
 #ontinue
 #onftestpath = parent.join("conftest.py")
 #f conftestpath.isfile():
 #od = self._importconftest(conftestpath, importmode)
 #list.append(mod)
 #elf._dirpath2confmods[directory] = clist
 #eturn clist

 #ef _rget_with_confmod(
 #elf, name: str, path: py.path.local, importmode: Union[str, ImportMode],
 # -> Tuple[types.ModuleType, Any]:
 #odules = self._getconftestmodules(path, importmode)
 #or mod in reversed(modules):
 #ry:
 #eturn mod, getattr(mod, name)
 #xcept AttributeError:
 #ontinue
 #aise KeyError(name)

 #ef _importconftest(
 #elf, conftestpath: py.path.local, importmode: Union[str, ImportMode],
 # -> types.ModuleType:
        # Use a resolved Path object as key to avoid loading the same conftest
        # twice with build systems that create build directories containing
        # symlinks to actual files.
        # Using Path().resolve() is better than py.path.realpath because
        # it resolves to the correct path/drive in case-insensitive file systems (#5792)
 #ey = Path(str(conftestpath)).resolve()

 #ith contextlib.suppress(KeyError):
 #eturn self._conftestpath2mod[key]

 #kgpath = conftestpath.pypkgpath()
 #f pkgpath is None:
 #ensure_removed_sysmodule(conftestpath.purebasename)

 #ry:
 #od = import_path(conftestpath, mode=importmode)
 #xcept Exception as e:
 #ssert e.__traceback__ is not None
 #xc_info = (type(e), e, e.__traceback__)
 #aise ConftestImportFailure(conftestpath, exc_info) from e

 #elf._check_non_top_pytest_plugins(mod, conftestpath)

 #elf._conftest_plugins.add(mod)
 #elf._conftestpath2mod[key] = mod
 #irpath = conftestpath.dirpath()
 #f dirpath in self._dirpath2confmods:
 #or path, mods in self._dirpath2confmods.items():
 #f path and path.relto(dirpath) or path == dirpath:
 #ssert mod not in mods
 #ods.append(mod)
 #elf.trace(f"loading conftestmodule {mod!r}")
 #elf.consider_conftest(mod)
 #eturn mod

 #ef _check_non_top_pytest_plugins(
 #elf, mod: types.ModuleType, conftestpath: py.path.local,
 # -> None:
 #f (
 #asattr(mod, "pytest_plugins")
 #nd self._configured
 #nd not self._using_pyargs
 #:
 #sg = (
 #Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\n"
 #It affects the entire test suite instead of just below the conftest as expected.\n"
 #  {}\n"
 #Please move it to a top level conftest file at the rootdir:\n"
 #  {}\n"
 #For more information, visit:\n"
 #  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files"
 #
 #ail(msg.format(conftestpath, self._confcutdir), pytrace=False)

    #
    # API for bootstrapping plugin loading
    #
    #

 #ef consider_preparse(
 #elf, args: Sequence[str], *, exclude_only: bool = False
 # -> None:
 # = 0
 # = len(args)
 #hile i < n:
 #pt = args[i]
 # += 1
 #f isinstance(opt, str):
 #f opt == "-p":
 #ry:
 #arg = args[i]
 #xcept IndexError:
 #eturn
 # += 1
 #lif opt.startswith("-p"):
 #arg = opt[2:]
 #lse:
 #ontinue
 #f exclude_only and not parg.startswith("no:"):
 #ontinue
 #elf.consider_pluginarg(parg)

 #ef consider_pluginarg(self, arg: str) -> None:
 #f arg.startswith("no:"):
 #ame = arg[3:]
 #f name in essential_plugins:
 #aise UsageError("plugin %s cannot be disabled" % name)

            # PR #4304: remove stepwise if cacheprovider is blocked.
 #f name == "cacheprovider":
 #elf.set_blocked("stepwise")
 #elf.set_blocked("pytest_stepwise")

 #elf.set_blocked(name)
 #f not name.startswith("pytest_"):
 #elf.set_blocked("pytest_" + name)
 #lse:
 #ame = arg
            # Unblock the plugin.  None indicates that it has been blocked.
            # There is no interface with pluggy for this.
 #f self._name2plugin.get(name, -1) is None:
 #el self._name2plugin[name]
 #f not name.startswith("pytest_"):
 #f self._name2plugin.get("pytest_" + name, -1) is None:
 #el self._name2plugin["pytest_" + name]
 #elf.import_plugin(arg, consider_entry_points=True)

 #ef consider_conftest(self, conftestmodule: types.ModuleType) -> None:
 #elf.register(conftestmodule, name=conftestmodule.__file__)

 #ef consider_env(self) -> None:
 #elf._import_plugin_specs(os.environ.get("PYTEST_PLUGINS"))

 #ef consider_module(self, mod: types.ModuleType) -> None:
 #elf._import_plugin_specs(getattr(mod, "pytest_plugins", []))

 #ef _import_plugin_specs(
 #elf, spec: Union[None, types.ModuleType, str, Sequence[str]]
 # -> None:
 #lugins = _get_plugin_specs_as_list(spec)
 #or import_spec in plugins:
 #elf.import_plugin(import_spec)

 #ef import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:
 #""Import a plugin with ``modname``.

 #f ``consider_entry_points`` is True, entry point names are also
 #onsidered to find a plugin.
 #""
        # Most often modname refers to builtin modules, e.g. "pytester",
        # "terminal" or "capture".  Those plugins are registered under their
        # basename for historic purposes but must be imported with the
        # _pytest prefix.
 #ssert isinstance(modname, str), (
 #module name as text required, got %r" % modname
 #
 #f self.is_blocked(modname) or self.get_plugin(modname) is not None:
 #eturn

 #mportspec = "_pytest." + modname if modname in builtin_plugins else modname
 #elf.rewrite_hook.mark_rewrite(importspec)

 #f consider_entry_points:
 #oaded = self.load_setuptools_entrypoints("pytest11", name=modname)
 #f loaded:
 #eturn

 #ry:
 #_import__(importspec)
 #xcept ImportError as e:
 #aise ImportError(
 #Error importing plugin "{}": {}'.format(modname, str(e.args[0]))
 #.with_traceback(e.__traceback__) from e

 #xcept Skipped as e:
 #elf.skipped_plugins.append((modname, e.msg or ""))
 #lse:
 #od = sys.modules[importspec]
 #elf.register(mod, modname)


def _get_plugin_specs_as_list(
 #pecs: Union[None, types.ModuleType, str, Sequence[str]]
) -> List[str]:
 #""Parse a plugins specification into a list of plugin names."""
    # None means empty.
 #f specs is None:
 #eturn []
    # Workaround for #3899 - a submodule which happens to be called "pytest_plugins".
 #f isinstance(specs, types.ModuleType):
 #eturn []
    # Comma-separated list.
 #f isinstance(specs, str):
 #eturn specs.split(",") if specs else []
    # Direct specification.
 #f isinstance(specs, collections.abc.Sequence):
 #eturn list(specs)
 #aise UsageError(
 #Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r"
 # specs
 #


def _ensure_removed_sysmodule(modname: str) -> None:
 #ry:
 #el sys.modules[modname]
 #xcept KeyError:
 #ass


class Notset:
 #ef __repr__(self):
 #eturn "<NOTSET>"


notset = Notset()


def _iter_rewritable_modules(package_files: Iterable[str]) -> Iterator[str]:
 #""Given an iterable of file names in a source distribution, return the "names" that should
 #e marked for assertion rewrite.

 #or example the package "pytest_mock/__init__.py" should be added as "pytest_mock" in
 #he assertion rewrite mechanism.

 #his function has to deal with dist-info based distributions and egg based distributions
 #which are still very much in use for "editable" installs).

 #ere are the file names as seen in a dist-info based distribution:

 #ytest_mock/__init__.py
 #ytest_mock/_version.py
 #ytest_mock/plugin.py
 #ytest_mock.egg-info/PKG-INFO

 #ere are the file names as seen in an egg based distribution:

 #rc/pytest_mock/__init__.py
 #rc/pytest_mock/_version.py
 #rc/pytest_mock/plugin.py
 #rc/pytest_mock.egg-info/PKG-INFO
 #ICENSE
 #etup.py

 #e have to take in account those two distribution flavors in order to determine which
 #ames should be considered for assertion rewriting.

 #ore information:
 #ttps://github.com/pytest-dev/pytest-mock/issues/167
 #""
 #ackage_files = list(package_files)
 #een_some = False
 #or fn in package_files:
 #s_simple_module = "/" not in fn and fn.endswith(".py")
 #s_package = fn.count("/") == 1 and fn.endswith("__init__.py")
 #f is_simple_module:
 #odule_name, _ = os.path.splitext(fn)
            # we ignore "setup.py" at the root of the distribution
 #f module_name != "setup":
 #een_some = True
 #ield module_name
 #lif is_package:
 #ackage_name = os.path.dirname(fn)
 #een_some = True
 #ield package_name

 #f not seen_some:
        # At this point we did not find any packages or modules suitable for assertion
        # rewriting, so we try again by stripping the first path component (to account for
        # "src" based source trees for example).
        # This approach lets us have the common case continue to be fast, as egg-distributions
        # are rarer.
 #ew_package_files = []
 #or fn in package_files:
 #arts = fn.split("/")
 #ew_fn = "/".join(parts[1:])
 #f new_fn:
 #ew_package_files.append(new_fn)
 #f new_package_files:
 #ield from _iter_rewritable_modules(new_package_files)


def _args_converter(args: Iterable[str]) -> Tuple[str, ...]:
 #eturn tuple(args)


@final
class Config:
 #""Access to configuration values, pluginmanager and plugin hooks.

 #param PytestPluginManager pluginmanager:

 #param InvocationParams invocation_params:
 #bject containing parameters regarding the :func:`pytest.main`
 #nvocation.
 #""

 #final
 #attr.s(frozen=True)
 #lass InvocationParams:
 #""Holds parameters passed during :func:`pytest.main`.

 #he object attributes are read-only.

 #. versionadded:: 5.1

 #. note::

 #ote that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``
 #ni option are handled by pytest, not being included in the ``args`` attribute.

 #lugins accessing ``InvocationParams`` must be aware of that.
 #""

 #rgs = attr.ib(type=Tuple[str, ...], converter=_args_converter)
 #""The command-line arguments as passed to :func:`pytest.main`.

 #type: Tuple[str, ...]
 #""
 #lugins = attr.ib(type=Optional[Sequence[Union[str, _PluggyPlugin]]])
 #""Extra plugins, might be `None`.

 #type: Optional[Sequence[Union[str, plugin]]]
 #""
 #ir = attr.ib(type=Path)
 #""The directory from which :func:`pytest.main` was invoked.

 #type: pathlib.Path
 #""

 #ef __init__(
 #elf,
 #luginmanager: PytestPluginManager,
 #,
 #nvocation_params: Optional[InvocationParams] = None,
 # -> None:
 #rom .argparsing import Parser, FILE_OR_DIR

 #f invocation_params is None:
 #nvocation_params = self.InvocationParams(
 #rgs=(), plugins=None, dir=Path.cwd()
 #

 #elf.option = argparse.Namespace()
 #""Access to command line option as attributes.

 #type: argparse.Namespace
 #""

 #elf.invocation_params = invocation_params
 #""The parameters with which pytest was invoked.

 #type: InvocationParams
 #""

 #a = FILE_OR_DIR
 #elf._parser = Parser(
 #sage=f"%(prog)s [options] [{_a}] [{_a}] [...]",
 #rocessopt=self._processopt,
 #
 #elf.pluginmanager = pluginmanager
 #""The plugin manager handles plugin registration and hook invocation.

 #type: PytestPluginManager
 #""

 #elf.trace = self.pluginmanager.trace.root.get("config")
 #elf.hook = self.pluginmanager.hook
 #elf._inicache: Dict[str, Any] = {}
 #elf._override_ini: Sequence[str] = ()
 #elf._opt2dest: Dict[str, str] = {}
 #elf._cleanup: List[Callable[[], None]] = []
        # A place where plugins can store information on the config for their
        # own use. Currently only intended for internal plugins.
 #elf._store = Store()
 #elf.pluginmanager.register(self, "pytestconfig")
 #elf._configured = False
 #elf.hook.pytest_addoption.call_historic(
 #wargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)
 #

 #f TYPE_CHECKING:
 #rom _pytest.cacheprovider import Cache

 #elf.cache: Optional[Cache] = None

 #property
 #ef invocation_dir(self) -> py.path.local:
 #""The directory from which pytest was invoked.

 #refer to use :attr:`invocation_params.dir <InvocationParams.dir>`,
 #hich is a :class:`pathlib.Path`.

 #type: py.path.local
 #""
 #eturn py.path.local(str(self.invocation_params.dir))

 #property
 #ef rootpath(self) -> Path:
 #""The path to the :ref:`rootdir <rootdir>`.

 #type: pathlib.Path

 #. versionadded:: 6.1
 #""
 #eturn self._rootpath

 #property
 #ef rootdir(self) -> py.path.local:
 #""The path to the :ref:`rootdir <rootdir>`.

 #refer to use :attr:`rootpath`, which is a :class:`pathlib.Path`.

 #type: py.path.local
 #""
 #eturn py.path.local(str(self.rootpath))

 #property
 #ef inipath(self) -> Optional[Path]:
 #""The path to the :ref:`configfile <configfiles>`.

 #type: Optional[pathlib.Path]

 #. versionadded:: 6.1
 #""
 #eturn self._inipath

 #property
 #ef inifile(self) -> Optional[py.path.local]:
 #""The path to the :ref:`configfile <configfiles>`.

 #refer to use :attr:`inipath`, which is a :class:`pathlib.Path`.

 #type: Optional[py.path.local]
 #""
 #eturn py.path.local(str(self.inipath)) if self.inipath else None

 #ef add_cleanup(self, func: Callable[[], None]) -> None:
 #""Add a function to be called when the config object gets out of
 #se (usually coninciding with pytest_unconfigure)."""
 #elf._cleanup.append(func)

 #ef _do_configure(self) -> None:
 #ssert not self._configured
 #elf._configured = True
 #ith warnings.catch_warnings():
 #arnings.simplefilter("default")
 #elf.hook.pytest_configure.call_historic(kwargs=dict(config=self))

 #ef _ensure_unconfigure(self) -> None:
 #f self._configured:
 #elf._configured = False
 #elf.hook.pytest_unconfigure(config=self)
 #elf.hook.pytest_configure._call_history = []
 #hile self._cleanup:
 #in = self._cleanup.pop()
 #in()

 #ef get_terminal_writer(self) -> TerminalWriter:
 #erminalreporter: TerminalReporter = self.pluginmanager.get_plugin(
 #terminalreporter"
 #
 #eturn terminalreporter._tw

 #ef pytest_cmdline_parse(
 #elf, pluginmanager: PytestPluginManager, args: List[str]
 # -> "Config":
 #ry:
 #elf.parse(args)
 #xcept UsageError:

            # Handle --version and --help here in a minimal fashion.
            # This gets done via helpconfig normally, but its
            # pytest_cmdline_main is not called in case of errors.
 #f getattr(self.option, "version", False) or "--version" in args:
 #rom _pytest.helpconfig import showversion

 #howversion(self)
 #lif (
 #etattr(self.option, "help", False) or "--help" in args or "-h" in args
 #:
 #elf._parser._getparser().print_help()
 #ys.stdout.write(
 #\nNOTE: displaying only minimal help due to UsageError.\n\n"
 #

 #aise

 #eturn self

 #ef notify_exception(
 #elf,
 #xcinfo: ExceptionInfo[BaseException],
 #ption: Optional[argparse.Namespace] = None,
 # -> None:
 #f option and getattr(option, "fulltrace", False):
 #tyle: _TracebackStyle = "long"
 #lse:
 #tyle = "native"
 #xcrepr = excinfo.getrepr(
 #uncargs=True, showlocals=getattr(option, "showlocals", False), style=style
 #
 #es = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)
 #f not any(res):
 #or line in str(excrepr).split("\n"):
 #ys.stderr.write("INTERNALERROR> %s\n" % line)
 #ys.stderr.flush()

 #ef cwd_relative_nodeid(self, nodeid: str) -> str:
        # nodeid's are relative to the rootpath, compute relative to cwd.
 #f self.invocation_params.dir != self.rootpath:
 #ullpath = self.rootpath / nodeid
 #odeid = bestrelpath(self.invocation_params.dir, fullpath)
 #eturn nodeid

 #classmethod
 #ef fromdictargs(cls, option_dict, args) -> "Config":
 #""Constructor usable for subprocesses."""
 #onfig = get_config(args)
 #onfig.option.__dict__.update(option_dict)
 #onfig.parse(args, addopts=False)
 #or x in config.option.plugins:
 #onfig.pluginmanager.consider_pluginarg(x)
 #eturn config

 #ef _processopt(self, opt: "Argument") -> None:
 #or name in opt._short_opts + opt._long_opts:
 #elf._opt2dest[name] = opt.dest

 #f hasattr(opt, "default"):
 #f not hasattr(self.option, opt.dest):
 #etattr(self.option, opt.dest, opt.default)

 #hookimpl(trylast=True)
 #ef pytest_load_initial_conftests(self, early_config: "Config") -> None:
 #elf.pluginmanager._set_initial_conftests(early_config.known_args_namespace)

 #ef _initini(self, args: Sequence[str]) -> None:
 #s, unknown_args = self._parser.parse_known_and_unknown_args(
 #rgs, namespace=copy.copy(self.option)
 #
 #ootpath, inipath, inicfg = determine_setup(
 #s.inifilename,
 #s.file_or_dir + unknown_args,
 #ootdir_cmd_arg=ns.rootdir or None,
 #onfig=self,
 #
 #elf._rootpath = rootpath
 #elf._inipath = inipath
 #elf.inicfg = inicfg
 #elf._parser.extra_info["rootdir"] = str(self.rootpath)
 #elf._parser.extra_info["inifile"] = str(self.inipath)
 #elf._parser.addini("addopts", "extra command line options", "args")
 #elf._parser.addini("minversion", "minimally required pytest version")
 #elf._parser.addini(
 #required_plugins",
 #plugins that must be present for pytest to run",
 #ype="args",
 #efault=[],
 #
 #elf._override_ini = ns.override_ini or ()

 #ef _consider_importhook(self, args: Sequence[str]) -> None:
 #""Install the PEP 302 import hook if using assertion rewriting.

 #eeds to parse the --assert=<mode> option from the commandline
 #nd find all the installed plugins to mark them for rewriting
 #y the importhook.
 #""
 #s, unknown_args = self._parser.parse_known_and_unknown_args(args)
 #ode = getattr(ns, "assertmode", "plain")
 #f mode == "rewrite":
 #mport _pytest.assertion

 #ry:
 #ook = _pytest.assertion.install_importhook(self)
 #xcept SystemError:
 #ode = "plain"
 #lse:
 #elf._mark_plugins_for_rewrite(hook)
 #elf._warn_about_missing_assertion(mode)

 #ef _mark_plugins_for_rewrite(self, hook) -> None:
 #""Given an importhook, mark for rewrite any top-level
 #odules or packages in the distribution package for
 #ll pytest plugins."""
 #elf.pluginmanager.rewrite_hook = hook

 #f os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
            # We don't autoload from setuptools entry points, no need to continue.
 #eturn

 #ackage_files = (
 #tr(file)
 #or dist in importlib_metadata.distributions()
 #f any(ep.group == "pytest11" for ep in dist.entry_points)
 #or file in dist.files or []
 #

 #or name in _iter_rewritable_modules(package_files):
 #ook.mark_rewrite(name)

 #ef _validate_args(self, args: List[str], via: str) -> List[str]:
 #""Validate known args."""
 #elf._parser._config_source_hint = via  # type: ignore
 #ry:
 #elf._parser.parse_known_and_unknown_args(
 #rgs, namespace=copy.copy(self.option)
 #
 #inally:
 #el self._parser._config_source_hint  # type: ignore

 #eturn args

 #ef _preparse(self, args: List[str], addopts: bool = True) -> None:
 #f addopts:
 #nv_addopts = os.environ.get("PYTEST_ADDOPTS", "")
 #f len(env_addopts):
 #rgs[:] = (
 #elf._validate_args(shlex.split(env_addopts), "via PYTEST_ADDOPTS")
 # args
 #
 #elf._initini(args)
 #f addopts:
 #rgs[:] = (
 #elf._validate_args(self.getini("addopts"), "via addopts config") + args
 #

 #elf.known_args_namespace = self._parser.parse_known_args(
 #rgs, namespace=copy.copy(self.option)
 #
 #elf._checkversion()
 #elf._consider_importhook(args)
 #elf.pluginmanager.consider_preparse(args, exclude_only=False)
 #f not os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
            # Don't autoload from setuptools entry point. Only explicitly specified
            # plugins are going to be loaded.
 #elf.pluginmanager.load_setuptools_entrypoints("pytest11")
 #elf.pluginmanager.consider_env()

 #elf.known_args_namespace = self._parser.parse_known_args(
 #rgs, namespace=copy.copy(self.known_args_namespace)
 #

 #elf._validate_plugins()
 #elf._warn_about_skipped_plugins()

 #f self.known_args_namespace.strict:
 #elf.issue_config_time_warning(
 #pytest.deprecated.STRICT_OPTION, stacklevel=2
 #

 #f self.known_args_namespace.confcutdir is None and self.inipath is not None:
 #onfcutdir = str(self.inipath.parent)
 #elf.known_args_namespace.confcutdir = confcutdir
 #ry:
 #elf.hook.pytest_load_initial_conftests(
 #arly_config=self, args=args, parser=self._parser
 #
 #xcept ConftestImportFailure as e:
 #f self.known_args_namespace.help or self.known_args_namespace.version:
                # we don't want to prevent --help/--version to work
                # so just let is pass and print a warning at the end
 #elf.issue_config_time_warning(
 #ytestConfigWarning(f"could not load initial conftests: {e.path}"),
 #tacklevel=2,
 #
 #lse:
 #aise

 #hookimpl(hookwrapper=True)
 #ef pytest_collection(self) -> Generator[None, None, None]:
 #""Validate invalid ini keys after collection is done so we take in account
 #ptions added by late-loading conftest files."""
 #ield
 #elf._validate_config_options()

 #ef _checkversion(self) -> None:
 #mport pytest

 #inver = self.inicfg.get("minversion", None)
 #f minver:
            # Imported lazily to improve start-up time.
 #rom packaging.version import Version

 #f not isinstance(minver, str):
 #aise pytest.UsageError(
 #%s: 'minversion' must be a single value" % self.inipath
 #

 #f Version(minver) > Version(pytest.__version__):
 #aise pytest.UsageError(
 #%s: 'minversion' requires pytest-%s, actual pytest-%s'"
 # (self.inipath, minver, pytest.__version__,)
 #

 #ef _validate_config_options(self) -> None:
 #or key in sorted(self._get_unknown_ini_keys()):
 #elf._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

 #ef _validate_plugins(self) -> None:
 #equired_plugins = sorted(self.getini("required_plugins"))
 #f not required_plugins:
 #eturn

        # Imported lazily to improve start-up time.
 #rom packaging.version import Version
 #rom packaging.requirements import InvalidRequirement, Requirement

 #lugin_info = self.pluginmanager.list_plugin_distinfo()
 #lugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}

 #issing_plugins = []
 #or required_plugin in required_plugins:
 #ry:
 #pec = Requirement(required_plugin)
 #xcept InvalidRequirement:
 #issing_plugins.append(required_plugin)
 #ontinue

 #f spec.name not in plugin_dist_info:
 #issing_plugins.append(required_plugin)
 #lif Version(plugin_dist_info[spec.name]) not in spec.specifier:
 #issing_plugins.append(required_plugin)

 #f missing_plugins:
 #aise UsageError(
 #Missing required plugins: {}".format(", ".join(missing_plugins)),
 #

 #ef _warn_or_fail_if_strict(self, message: str) -> None:
 #f self.known_args_namespace.strict_config:
 #aise UsageError(message)

 #elf.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)

 #ef _get_unknown_ini_keys(self) -> List[str]:
 #arser_inicfg = self._parser._inidict
 #eturn [name for name in self.inicfg if name not in parser_inicfg]

 #ef parse(self, args: List[str], addopts: bool = True) -> None:
        # Parse given cmdline arguments into this config object.
 #ssert not hasattr(
 #elf, "args"
 #, "can only parse cmdline args at most once per Config object"
 #elf.hook.pytest_addhooks.call_historic(
 #wargs=dict(pluginmanager=self.pluginmanager)
 #
 #elf._preparse(args, addopts=addopts)
        # XXX deprecated hook:
 #elf.hook.pytest_cmdline_preparse(config=self, args=args)
 #elf._parser.after_preparse = True  # type: ignore
 #ry:
 #rgs = self._parser.parse_setoption(
 #rgs, self.option, namespace=self.option
 #
 #f not args:
 #f self.invocation_params.dir == self.rootpath:
 #rgs = self.getini("testpaths")
 #f not args:
 #rgs = [str(self.invocation_params.dir)]
 #elf.args = args
 #xcept PrintHelp:
 #ass

 #ef issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:
 #""Issue and handle a warning during the "configure" stage.

 #uring ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``
 #unction because it is not possible to have hookwrappers around ``pytest_configure``.

 #his function is mainly intended for plugins that need to issue warnings during
 #`pytest_configure`` (or similar stages).

 #param warning: The warning instance.
 #param stacklevel: stacklevel forwarded to warnings.warn.
 #""
 #f self.pluginmanager.is_blocked("warnings"):
 #eturn

 #mdline_filters = self.known_args_namespace.pythonwarnings or []
 #onfig_filters = self.getini("filterwarnings")

 #ith warnings.catch_warnings(record=True) as records:
 #arnings.simplefilter("always", type(warning))
 #pply_warning_filters(config_filters, cmdline_filters)
 #arnings.warn(warning, stacklevel=stacklevel)

 #f records:
 #rame = sys._getframe(stacklevel - 1)
 #ocation = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name
 #elf.hook.pytest_warning_captured.call_historic(
 #wargs=dict(
 #arning_message=records[0],
 #hen="config",
 #tem=None,
 #ocation=location,
 #
 #
 #elf.hook.pytest_warning_recorded.call_historic(
 #wargs=dict(
 #arning_message=records[0],
 #hen="config",
 #odeid="",
 #ocation=location,
 #
 #

 #ef addinivalue_line(self, name: str, line: str) -> None:
 #""Add a line to an ini-file option. The option must have been
 #eclared but might not yet be set in which case the line becomes
 #he first line in its value."""
 # = self.getini(name)
 #ssert isinstance(x, list)
 #.append(line)  # modifies the cached list inline

 #ef getini(self, name: str):
 #""Return configuration value from an :ref:`ini file <configfiles>`.

 #f the specified name hasn't been registered through a prior
 #py:func:`parser.addini <_pytest.config.argparsing.Parser.addini>`
 #all (usually from a plugin), a ValueError is raised.
 #""
 #ry:
 #eturn self._inicache[name]
 #xcept KeyError:
 #elf._inicache[name] = val = self._getini(name)
 #eturn val

 #ef _getini(self, name: str):
 #ry:
 #escription, type, default = self._parser._inidict[name]
 #xcept KeyError as e:
 #aise ValueError(f"unknown configuration value: {name!r}") from e
 #verride_value = self._get_override_ini_value(name)
 #f override_value is None:
 #ry:
 #alue = self.inicfg[name]
 #xcept KeyError:
 #f default is not None:
 #eturn default
 #f type is None:
 #eturn ""
 #eturn []
 #lse:
 #alue = override_value
        # Coerce the values based on types.
        #
        # Note: some coercions are only required if we are reading from .ini files, because
        # the file format doesn't contain type information, but when reading from toml we will
        # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).
        # For example:
        #
        #   ini:
        #     a_line_list = "tests acceptance"
        #   in this case, we need to split the string to obtain a list of strings.
        #
        #   toml:
        #     a_line_list = ["tests", "acceptance"]
        #   in this case, we already have a list ready to use.
        #
 #f type == "pathlist":
            # TODO: This assert is probably not valid in all cases.
 #ssert self.inipath is not None
 #p = self.inipath.parent
 #nput_values = shlex.split(value) if isinstance(value, str) else value
 #eturn [py.path.local(str(dp / x)) for x in input_values]
 #lif type == "args":
 #eturn shlex.split(value) if isinstance(value, str) else value
 #lif type == "linelist":
 #f isinstance(value, str):
 #eturn [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
 #lse:
 #eturn value
 #lif type == "bool":
 #eturn _strtobool(str(value).strip())
 #lse:
 #ssert type in [None, "string"]
 #eturn value

 #ef _getconftest_pathlist(
 #elf, name: str, path: py.path.local
 # -> Optional[List[py.path.local]]:
 #ry:
 #od, relroots = self.pluginmanager._rget_with_confmod(
 #ame, path, self.getoption("importmode")
 #
 #xcept KeyError:
 #eturn None
 #odpath = py.path.local(mod.__file__).dirpath()
 #alues: List[py.path.local] = []
 #or relroot in relroots:
 #f not isinstance(relroot, py.path.local):
 #elroot = relroot.replace("/", os.sep)
 #elroot = modpath.join(relroot, abs=True)
 #alues.append(relroot)
 #eturn values

 #ef _get_override_ini_value(self, name: str) -> Optional[str]:
 #alue = None
        # override_ini is a list of "ini=value" options.
        # Always use the last item if multiple values are set for same ini-name,
        # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.
 #or ini_config in self._override_ini:
 #ry:
 #ey, user_ini_value = ini_config.split("=", 1)
 #xcept ValueError as e:
 #aise UsageError(
 #-o/--override-ini expects option=value style (got: {!r}).".format(
 #ni_config
 #
 # from e
 #lse:
 #f key == name:
 #alue = user_ini_value
 #eturn value

 #ef getoption(self, name: str, default=notset, skip: bool = False):
 #""Return command line option value.

 #param name: Name of the option.  You may also specify
 #he literal ``--OPT`` option instead of the "dest" option name.
 #param default: Default value if no option of that name exists.
 #param skip: If True, raise pytest.skip if option does not exists
 #r has a None value.
 #""
 #ame = self._opt2dest.get(name, name)
 #ry:
 #al = getattr(self.option, name)
 #f val is None and skip:
 #aise AttributeError(name)
 #eturn val
 #xcept AttributeError as e:
 #f default is not notset:
 #eturn default
 #f skip:
 #mport pytest

 #ytest.skip(f"no {name!r} option found")
 #aise ValueError(f"no option named {name!r}") from e

 #ef getvalue(self, name: str, path=None):
 #""Deprecated, use getoption() instead."""
 #eturn self.getoption(name)

 #ef getvalueorskip(self, name: str, path=None):
 #""Deprecated, use getoption(skip=True) instead."""
 #eturn self.getoption(name, skip=True)

 #ef _warn_about_missing_assertion(self, mode: str) -> None:
 #f not _assertion_supported():
 #f mode == "plain":
 #arning_text = (
 #ASSERTIONS ARE NOT EXECUTED"
 # and FAILING TESTS WILL PASS.  Are you"
 # using python -O?"
 #
 #lse:
 #arning_text = (
 #assertions not in test modules or"
 # plugins will be ignored"
 # because assert statements are not executed "
 #by the underlying Python interpreter "
 #(are you using python -O?)\n"
 #
 #elf.issue_config_time_warning(
 #ytestConfigWarning(warning_text), stacklevel=3,
 #

 #ef _warn_about_skipped_plugins(self) -> None:
 #or module_name, msg in self.pluginmanager.skipped_plugins:
 #elf.issue_config_time_warning(
 #ytestConfigWarning(f"skipped plugin {module_name!r}: {msg}"),
 #tacklevel=2,
 #


def _assertion_supported() -> bool:
 #ry:
 #ssert False
 #xcept AssertionError:
 #eturn True
 #lse:
 #eturn False  # type: ignore[unreachable]


def create_terminal_writer(
 #onfig: Config, file: Optional[TextIO] = None
) -> TerminalWriter:
 #""Create a TerminalWriter instance configured according to the options
 #n the config object.

 #very code which requires a TerminalWriter object and has access to a
 #onfig object should use this function.
 #""
 #w = TerminalWriter(file=file)

 #f config.option.color == "yes":
 #w.hasmarkup = True
 #lif config.option.color == "no":
 #w.hasmarkup = False

 #f config.option.code_highlight == "yes":
 #w.code_highlight = True
 #lif config.option.code_highlight == "no":
 #w.code_highlight = False

 #eturn tw


def _strtobool(val: str) -> bool:
 #""Convert a string representation of truth to True or False.

 #rue values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
 #re 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
 #val' is anything else.

 #. note:: Copied from distutils.util.
 #""
 #al = val.lower()
 #f val in ("y", "yes", "t", "true", "on", "1"):
 #eturn True
 #lif val in ("n", "no", "f", "false", "off", "0"):
 #eturn False
 #lse:
 #aise ValueError(f"invalid truth value {val!r}")


@lru_cache(maxsize=50)
def parse_warning_filter(
 #rg: str, *, escape: bool
) -> Tuple[str, str, Type[Warning], str, int]:
 #""Parse a warnings filter string.

 #his is copied from warnings._setoption, but does not apply the filter,
 #nly parses it, and makes the escaping optional.
 #""
 #arts = arg.split(":")
 #f len(parts) > 5:
 #aise warnings._OptionError(f"too many fields (max 5): {arg!r}")
 #hile len(parts) < 5:
 #arts.append("")
 #ction_, message, category_, module, lineno_ = [s.strip() for s in parts]
 #ction: str = warnings._getaction(action_)  # type: ignore[attr-defined]
 #ategory: Type[Warning] = warnings._getcategory(category_)  # type: ignore[attr-defined]
 #f message and escape:
 #essage = re.escape(message)
 #f module and escape:
 #odule = re.escape(module) + r"\Z"
 #f lineno_:
 #ry:
 #ineno = int(lineno_)
 #f lineno < 0:
 #aise ValueError
 #xcept (ValueError, OverflowError) as e:
 #aise warnings._OptionError(f"invalid lineno {lineno_!r}") from e
 #lse:
 #ineno = 0
 #eturn action, message, category, module, lineno


def apply_warning_filters(
 #onfig_filters: Iterable[str], cmdline_filters: Iterable[str]
) -> None:
 #""Applies pytest-configured filters to the warnings module"""
    # Filters should have this precedence: cmdline options, config.
    # Filters should be applied in the inverse order of precedence.
 #or arg in config_filters:
 #arnings.filterwarnings(*parse_warning_filter(arg, escape=False))

 #or arg in cmdline_filters:
 #arnings.filterwarnings(*parse_warning_filter(arg, escape=True))
