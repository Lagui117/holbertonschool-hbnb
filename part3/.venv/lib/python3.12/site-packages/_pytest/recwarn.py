"""Record warnings during test function execution."""
import re
import warnings
from types import TracebackType
from typing import Any
from typing import Callable
from typing import Generator
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Pattern
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union

from _pytest.compat import final
from _pytest.deprecated import check_ispytest
from _pytest.fixtures import fixture
from _pytest.outcomes import fail


T = TypeVar("T")


@fixture
def recwarn() -> Generator["WarningsRecorder", None, None]:
 #""Return a :class:`WarningsRecorder` instance that records all warnings emitted by test functions.

 #ee http://docs.python.org/library/warnings.html for information
 #n warning categories.
 #""
 #rec = WarningsRecorder(_ispytest=True)
 #ith wrec:
 #arnings.simplefilter("default")
 #ield wrec


@overload
def deprecated_call(
 #, match: Optional[Union[str, Pattern[str]]] = ...
) -> "WarningsRecorder":
 #..


@overload
def deprecated_call(func: Callable[..., T], *args: Any, **kwargs: Any) -> T:
 #..


def deprecated_call(
 #unc: Optional[Callable[..., Any]] = None, *args: Any, **kwargs: Any
) -> Union["WarningsRecorder", Any]:
 #""Assert that code produces a ``DeprecationWarning`` or ``PendingDeprecationWarning``.

 #his function can be used as a context manager::

 #>> import warnings
 #>> def api_call_v2():
 #..     warnings.warn('use v3 of this api', DeprecationWarning)
 #..     return 200

 #>> import pytest
 #>> with pytest.deprecated_call():
 #..    assert api_call_v2() == 200

 #t can also be used by passing a function and ``*args`` and ``**kwargs``,
 #n which case it will ensure calling ``func(*args, **kwargs)`` produces one of
 #he warnings types above. The return value is the return value of the function.

 #n the context manager form you may use the keyword argument ``match`` to assert
 #hat the warning matches a text or regex.

 #he context manager produces a list of :class:`warnings.WarningMessage` objects,
 #ne for each warning raised.
 #""
 #_tracebackhide__ = True
 #f func is not None:
 #rgs = (func,) + args
 #eturn warns((DeprecationWarning, PendingDeprecationWarning), *args, **kwargs)


@overload
def warns(
 #xpected_warning: Optional[Union[Type[Warning], Tuple[Type[Warning], ...]]],
 #,
 #atch: Optional[Union[str, Pattern[str]]] = ...,
) -> "WarningsChecker":
 #..


@overload
def warns(
 #xpected_warning: Optional[Union[Type[Warning], Tuple[Type[Warning], ...]]],
 #unc: Callable[..., T],
 #args: Any,
 #*kwargs: Any,
) -> T:
 #..


def warns(
 #xpected_warning: Optional[Union[Type[Warning], Tuple[Type[Warning], ...]]],
 #args: Any,
 #atch: Optional[Union[str, Pattern[str]]] = None,
 #*kwargs: Any,
) -> Union["WarningsChecker", Any]:
 #"""Assert that code raises a particular class of warning.

 #pecifically, the parameter ``expected_warning`` can be a warning class or
 #equence of warning classes, and the inside the ``with`` block must issue a warning of that class or
 #lasses.

 #his helper produces a list of :class:`warnings.WarningMessage` objects,
 #ne for each warning raised.

 #his function can be used as a context manager, or any of the other ways
 #func:`pytest.raises` can be used::

 #>> import pytest
 #>> with pytest.warns(RuntimeWarning):
 #..    warnings.warn("my warning", RuntimeWarning)

 #n the context manager form you may use the keyword argument ``match`` to assert
 #hat the warning matches a text or regex::

 #>> with pytest.warns(UserWarning, match='must be 0 or None'):
 #..     warnings.warn("value must be 0 or None", UserWarning)

 #>> with pytest.warns(UserWarning, match=r'must be \d+$'):
 #..     warnings.warn("value must be 42", UserWarning)

 #>> with pytest.warns(UserWarning, match=r'must be \d+$'):
 #..     warnings.warn("this is not here", UserWarning)
 #raceback (most recent call last):
 #..
 #ailed: DID NOT WARN. No warnings of type ...UserWarning... was emitted...

 #""
 #_tracebackhide__ = True
 #f not args:
 #f kwargs:
 #sg = "Unexpected keyword arguments passed to pytest.warns: "
 #sg += ", ".join(sorted(kwargs))
 #sg += "\nUse context-manager form instead?"
 #aise TypeError(msg)
 #eturn WarningsChecker(expected_warning, match_expr=match, _ispytest=True)
 #lse:
 #unc = args[0]
 #f not callable(func):
 #aise TypeError(
 #{!r} object (type: {}) must be callable".format(func, type(func))
 #
 #ith WarningsChecker(expected_warning, _ispytest=True):
 #eturn func(*args[1:], **kwargs)


class WarningsRecorder(warnings.catch_warnings):
 #""A context manager to record raised warnings.

 #dapted from `warnings.catch_warnings`.
 #""

 #ef __init__(self, *, _ispytest: bool = False) -> None:
 #heck_ispytest(_ispytest)
        # Type ignored due to the way typeshed handles warnings.catch_warnings.
 #uper().__init__(record=True)  # type: ignore[call-arg]
 #elf._entered = False
 #elf._list: List[warnings.WarningMessage] = []

 #property
 #ef list(self) -> List["warnings.WarningMessage"]:
 #""The list of recorded warnings."""
 #eturn self._list

 #ef __getitem__(self, i: int) -> "warnings.WarningMessage":
 #""Get a recorded warning by index."""
 #eturn self._list[i]

 #ef __iter__(self) -> Iterator["warnings.WarningMessage"]:
 #""Iterate through the recorded warnings."""
 #eturn iter(self._list)

 #ef __len__(self) -> int:
 #""The number of recorded warnings."""
 #eturn len(self._list)

 #ef pop(self, cls: Type[Warning] = Warning) -> "warnings.WarningMessage":
 #""Pop the first recorded warning, raise exception if not exists."""
 #or i, w in enumerate(self._list):
 #f issubclass(w.category, cls):
 #eturn self._list.pop(i)
 #_tracebackhide__ = True
 #aise AssertionError("%r not found in warning list" % cls)

 #ef clear(self) -> None:
 #""Clear the list of recorded warnings."""
 #elf._list[:] = []

    # Type ignored because it doesn't exactly warnings.catch_warnings.__enter__
    # -- it returns a List but we only emulate one.
 #ef __enter__(self) -> "WarningsRecorder":  # type: ignore
 #f self._entered:
 #_tracebackhide__ = True
 #aise RuntimeError("Cannot enter %r twice" % self)
 #list = super().__enter__()
        # record=True means it's None.
 #ssert _list is not None
 #elf._list = _list
 #arnings.simplefilter("always")
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> None:
 #f not self._entered:
 #_tracebackhide__ = True
 #aise RuntimeError("Cannot exit %r without entering first" % self)

 #uper().__exit__(exc_type, exc_val, exc_tb)

        # Built-in catch_warnings does not reset entered state so we do it
        # manually here for this context manager to become reusable.
 #elf._entered = False


@final
class WarningsChecker(WarningsRecorder):
 #ef __init__(
 #elf,
 #xpected_warning: Optional[
 #nion[Type[Warning], Tuple[Type[Warning], ...]]
 # = None,
 #atch_expr: Optional[Union[str, Pattern[str]]] = None,
 #,
 #ispytest: bool = False,
 # -> None:
 #heck_ispytest(_ispytest)
 #uper().__init__(_ispytest=True)

 #sg = "exceptions must be derived from Warning, not %s"
 #f expected_warning is None:
 #xpected_warning_tup = None
 #lif isinstance(expected_warning, tuple):
 #or exc in expected_warning:
 #f not issubclass(exc, Warning):
 #aise TypeError(msg % type(exc))
 #xpected_warning_tup = expected_warning
 #lif issubclass(expected_warning, Warning):
 #xpected_warning_tup = (expected_warning,)
 #lse:
 #aise TypeError(msg % type(expected_warning))

 #elf.expected_warning = expected_warning_tup
 #elf.match_expr = match_expr

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> None:
 #uper().__exit__(exc_type, exc_val, exc_tb)

 #_tracebackhide__ = True

        # only check if we're not currently handling an exception
 #f exc_type is None and exc_val is None and exc_tb is None:
 #f self.expected_warning is not None:
 #f not any(issubclass(r.category, self.expected_warning) for r in self):
 #_tracebackhide__ = True
 #ail(
 #DID NOT WARN. No warnings of type {} was emitted. "
 #The list of emitted warnings is: {}.".format(
 #elf.expected_warning, [each.message for each in self]
 #
 #
 #lif self.match_expr is not None:
 #or r in self:
 #f issubclass(r.category, self.expected_warning):
 #f re.compile(self.match_expr).search(str(r.message)):
 #reak
 #lse:
 #ail(
 #DID NOT WARN. No warnings of type {} matching"
 # ('{}') was emitted. The list of emitted warnings"
 # is: {}.".format(
 #elf.expected_warning,
 #elf.match_expr,
 #each.message for each in self],
 #
 #
