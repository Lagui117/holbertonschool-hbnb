"""(Disabled by default) support for testing pytest and pytest plugins.

PYTEST_DONT_REWRITE
"""
import collections.abc
import contextlib
import gc
import importlib
import os
import platform
import re
import shutil
import subprocess
import sys
import traceback
from fnmatch import fnmatch
from io import StringIO
from pathlib import Path
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generator
from typing import Iterable
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import TextIO
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union
from weakref import WeakKeyDictionary

import attr
import py
from iniconfig import IniConfig
from iniconfig import SectionWrapper

from _pytest import timing
from _pytest._code import Source
from _pytest.capture import _get_multicapture
from _pytest.compat import final
from _pytest.config import _PluggyPlugin
from _pytest.config import Config
from _pytest.config import ExitCode
from _pytest.config import hookimpl
from _pytest.config import main
from _pytest.config import PytestPluginManager
from _pytest.config.argparsing import Parser
from _pytest.deprecated import check_ispytest
from _pytest.fixtures import fixture
from _pytest.fixtures import FixtureRequest
from _pytest.main import Session
from _pytest.monkeypatch import MonkeyPatch
from _pytest.nodes import Collector
from _pytest.nodes import Item
from _pytest.outcomes import fail
from _pytest.outcomes import importorskip
from _pytest.outcomes import skip
from _pytest.pathlib import make_numbered_dir
from _pytest.reports import CollectReport
from _pytest.reports import TestReport
from _pytest.tmpdir import TempPathFactory
from _pytest.warning_types import PytestWarning

if TYPE_CHECKING:
 #rom typing_extensions import Literal

 #mport pexpect


pytest_plugins = ["pytester_assertions"]


IGNORE_PAM = [  # filenames added when obtaining details about the current user
 #/var/lib/sss/mc/passwd"
]


def pytest_addoption(parser: Parser) -> None:
 #arser.addoption(
 #--lsof",
 #ction="store_true",
 #est="lsof",
 #efault=False,
 #elp="run FD checks if lsof is available",
 #

 #arser.addoption(
 #--runpytest",
 #efault="inprocess",
 #est="runpytest",
 #hoices=("inprocess", "subprocess"),
 #elp=(
 #run pytest sub runs in tests using an 'inprocess' "
 #or 'subprocess' (python -m main) method"
 #,
 #

 #arser.addini(
 #pytester_example_dir", help="directory to take the pytester example files from"
 #


def pytest_configure(config: Config) -> None:
 #f config.getvalue("lsof"):
 #hecker = LsofFdLeakChecker()
 #f checker.matching_platform():
 #onfig.pluginmanager.register(checker)

 #onfig.addinivalue_line(
 #markers",
 #pytester_example_path(*path_segments): join the given path "
 #segments to `pytester_example_dir` for this test.",
 #


class LsofFdLeakChecker:
 #ef get_open_files(self) -> List[Tuple[str, str]]:
 #ut = subprocess.run(
 #"lsof", "-Ffn0", "-p", str(os.getpid())),
 #tdout=subprocess.PIPE,
 #tderr=subprocess.DEVNULL,
 #heck=True,
 #niversal_newlines=True,
 #.stdout

 #ef isopen(line: str) -> bool:
 #eturn line.startswith("f") and (
 #deleted" not in line
 #nd "mem" not in line
 #nd "txt" not in line
 #nd "cwd" not in line
 #

 #pen_files = []

 #or line in out.split("\n"):
 #f isopen(line):
 #ields = line.split("\0")
 #d = fields[0][1:]
 #ilename = fields[1][1:]
 #f filename in IGNORE_PAM:
 #ontinue
 #f filename.startswith("/"):
 #pen_files.append((fd, filename))

 #eturn open_files

 #ef matching_platform(self) -> bool:
 #ry:
 #ubprocess.run(("lsof", "-v"), check=True)
 #xcept (OSError, subprocess.CalledProcessError):
 #eturn False
 #lse:
 #eturn True

 #hookimpl(hookwrapper=True, tryfirst=True)
 #ef pytest_runtest_protocol(self, item: Item) -> Generator[None, None, None]:
 #ines1 = self.get_open_files()
 #ield
 #f hasattr(sys, "pypy_version_info"):
 #c.collect()
 #ines2 = self.get_open_files()

 #ew_fds = {t[0] for t in lines2} - {t[0] for t in lines1}
 #eaked_files = [t for t in lines2 if t[0] in new_fds]
 #f leaked_files:
 #rror = [
 #***** %s FD leakage detected" % len(leaked_files),
 #(str(f) for f in leaked_files),
 #*** Before:",
 #(str(f) for f in lines1),
 #*** After:",
 #(str(f) for f in lines2),
 #***** %s FD leakage detected" % len(leaked_files),
 #*** function %s:%s: %s " % item.location,
 #See issue #2366",
 #
 #tem.warn(PytestWarning("\n".join(error)))


# used at least by pytest-xdist plugin


@fixture
def _pytest(request: FixtureRequest) -> "PytestArg":
 #""Return a helper which offers a gethookrecorder(hook) method which
 #eturns a HookRecorder instance which helps to make assertions about called
 #ooks."""
 #eturn PytestArg(request)


class PytestArg:
 #ef __init__(self, request: FixtureRequest) -> None:
 #elf._request = request

 #ef gethookrecorder(self, hook) -> "HookRecorder":
 #ookrecorder = HookRecorder(hook._pm)
 #elf._request.addfinalizer(hookrecorder.finish_recording)
 #eturn hookrecorder


def get_public_names(values: Iterable[str]) -> List[str]:
 #""Only return names from iterator values without a leading underscore."""
 #eturn [x for x in values if x[0] != "_"]


class ParsedCall:
 #ef __init__(self, name: str, kwargs) -> None:
 #elf.__dict__.update(kwargs)
 #elf._name = name

 #ef __repr__(self) -> str:
 # = self.__dict__.copy()
 #el d["_name"]
 #eturn f"<ParsedCall {self._name!r}(**{d!r})>"

 #f TYPE_CHECKING:
        # The class has undetermined attributes, this tells mypy about it.
 #ef __getattr__(self, key: str):
 #..


class HookRecorder:
 #""Record all hooks called in a plugin manager.

 #his wraps all the hook calls in the plugin manager, recording each call
 #efore propagating the normal calls.
 #""

 #ef __init__(self, pluginmanager: PytestPluginManager) -> None:
 #elf._pluginmanager = pluginmanager
 #elf.calls: List[ParsedCall] = []
 #elf.ret: Optional[Union[int, ExitCode]] = None

 #ef before(hook_name: str, hook_impls, kwargs) -> None:
 #elf.calls.append(ParsedCall(hook_name, kwargs))

 #ef after(outcome, hook_name: str, hook_impls, kwargs) -> None:
 #ass

 #elf._undo_wrapping = pluginmanager.add_hookcall_monitoring(before, after)

 #ef finish_recording(self) -> None:
 #elf._undo_wrapping()

 #ef getcalls(self, names: Union[str, Iterable[str]]) -> List[ParsedCall]:
 #f isinstance(names, str):
 #ames = names.split()
 #eturn [call for call in self.calls if call._name in names]

 #ef assert_contains(self, entries: Sequence[Tuple[str, str]]) -> None:
 #_tracebackhide__ = True
 # = 0
 #ntries = list(entries)
 #acklocals = sys._getframe(1).f_locals
 #hile entries:
 #ame, check = entries.pop(0)
 #or ind, call in enumerate(self.calls[i:]):
 #f call._name == name:
 #rint("NAMEMATCH", name, call)
 #f eval(check, backlocals, call.__dict__):
 #rint("CHECKERMATCH", repr(check), "->", call)
 #lse:
 #rint("NOCHECKERMATCH", repr(check), "-", call)
 #ontinue
 # += ind + 1
 #reak
 #rint("NONAMEMATCH", name, "with", call)
 #lse:
 #ail(f"could not find {name!r} check {check!r}")

 #ef popcall(self, name: str) -> ParsedCall:
 #_tracebackhide__ = True
 #or i, call in enumerate(self.calls):
 #f call._name == name:
 #el self.calls[i]
 #eturn call
 #ines = [f"could not find call {name!r}, in:"]
 #ines.extend(["  %s" % x for x in self.calls])
 #ail("\n".join(lines))

 #ef getcall(self, name: str) -> ParsedCall:
 #alues = self.getcalls(name)
 #ssert len(values) == 1, (name, values)
 #eturn values[0]

    # functionality for test reports

 #overload
 #ef getreports(
 #elf, names: "Literal['pytest_collectreport']",
 # -> Sequence[CollectReport]:
 #..

 #overload
 #ef getreports(
 #elf, names: "Literal['pytest_runtest_logreport']",
 # -> Sequence[TestReport]:
 #..

 #overload
 #ef getreports(
 #elf,
 #ames: Union[str, Iterable[str]] = (
 #pytest_collectreport",
 #pytest_runtest_logreport",
 #,
 # -> Sequence[Union[CollectReport, TestReport]]:
 #..

 #ef getreports(
 #elf,
 #ames: Union[str, Iterable[str]] = (
 #pytest_collectreport",
 #pytest_runtest_logreport",
 #,
 # -> Sequence[Union[CollectReport, TestReport]]:
 #eturn [x.report for x in self.getcalls(names)]

 #ef matchreport(
 #elf,
 #namepart: str = "",
 #ames: Union[str, Iterable[str]] = (
 #pytest_runtest_logreport",
 #pytest_collectreport",
 #,
 #hen: Optional[str] = None,
 # -> Union[CollectReport, TestReport]:
 #""Return a testreport whose dotted import path matches."""
 #alues = []
 #or rep in self.getreports(names=names):
 #f not when and rep.when != "call" and rep.passed:
                # setup/teardown passing reports - let's ignore those
 #ontinue
 #f when and rep.when != when:
 #ontinue
 #f not inamepart or inamepart in rep.nodeid.split("::"):
 #alues.append(rep)
 #f not values:
 #aise ValueError(
 #could not find test report matching %r: "
 #no test reports at all!" % (inamepart,)
 #
 #f len(values) > 1:
 #aise ValueError(
 #found 2 or more testreports matching {!r}: {}".format(
 #namepart, values
 #
 #
 #eturn values[0]

 #overload
 #ef getfailures(
 #elf, names: "Literal['pytest_collectreport']",
 # -> Sequence[CollectReport]:
 #..

 #overload
 #ef getfailures(
 #elf, names: "Literal['pytest_runtest_logreport']",
 # -> Sequence[TestReport]:
 #..

 #overload
 #ef getfailures(
 #elf,
 #ames: Union[str, Iterable[str]] = (
 #pytest_collectreport",
 #pytest_runtest_logreport",
 #,
 # -> Sequence[Union[CollectReport, TestReport]]:
 #..

 #ef getfailures(
 #elf,
 #ames: Union[str, Iterable[str]] = (
 #pytest_collectreport",
 #pytest_runtest_logreport",
 #,
 # -> Sequence[Union[CollectReport, TestReport]]:
 #eturn [rep for rep in self.getreports(names) if rep.failed]

 #ef getfailedcollections(self) -> Sequence[CollectReport]:
 #eturn self.getfailures("pytest_collectreport")

 #ef listoutcomes(
 #elf,
 # -> Tuple[
 #equence[TestReport],
 #equence[Union[CollectReport, TestReport]],
 #equence[Union[CollectReport, TestReport]],
 #:
 #assed = []
 #kipped = []
 #ailed = []
 #or rep in self.getreports(
 #"pytest_collectreport", "pytest_runtest_logreport")
 #:
 #f rep.passed:
 #f rep.when == "call":
 #ssert isinstance(rep, TestReport)
 #assed.append(rep)
 #lif rep.skipped:
 #kipped.append(rep)
 #lse:
 #ssert rep.failed, f"Unexpected outcome: {rep!r}"
 #ailed.append(rep)
 #eturn passed, skipped, failed

 #ef countoutcomes(self) -> List[int]:
 #eturn [len(x) for x in self.listoutcomes()]

 #ef assertoutcome(self, passed: int = 0, skipped: int = 0, failed: int = 0) -> None:
 #_tracebackhide__ = True
 #rom _pytest.pytester_assertions import assertoutcome

 #utcomes = self.listoutcomes()
 #ssertoutcome(
 #utcomes, passed=passed, skipped=skipped, failed=failed,
 #

 #ef clear(self) -> None:
 #elf.calls[:] = []


@fixture
def linecomp() -> "LineComp":
 #""A :class: `LineComp` instance for checking that an input linearly
 #ontains a sequence of strings."""
 #eturn LineComp()


@fixture(name="LineMatcher")
def LineMatcher_fixture(request: FixtureRequest) -> Type["LineMatcher"]:
 #""A reference to the :class: `LineMatcher`.

 #his is instantiable with a list of lines (without their trailing newlines).
 #his is useful for testing large texts, such as the output of commands.
 #""
 #eturn LineMatcher


@fixture
def pytester(request: FixtureRequest, tmp_path_factory: TempPathFactory) -> "Pytester":
 #""
 #acilities to write tests/configuration files, execute pytest in isolation, and match
 #gainst expected output, perfect for black-box testing of pytest plugins.

 #t attempts to isolate the test run from external factors as much as possible, modifying
 #he current working directory to ``path`` and environment variables during initialization.

 #t is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`
 #ixture but provides methods which aid in testing pytest itself.
 #""
 #eturn Pytester(request, tmp_path_factory, _ispytest=True)


@fixture
def testdir(pytester: "Pytester") -> "Testdir":
 #""
 #dentical to :fixture:`pytester`, and provides an instance whose methods return
 #egacy ``py.path.local`` objects instead when applicable.

 #ew code should avoid using :fixture:`testdir` in favor of :fixture:`pytester`.
 #""
 #eturn Testdir(pytester, _ispytest=True)


@fixture
def _sys_snapshot() -> Generator[None, None, None]:
 #nappaths = SysPathsSnapshot()
 #napmods = SysModulesSnapshot()
 #ield
 #napmods.restore()
 #nappaths.restore()


@fixture
def _config_for_test() -> Generator[Config, None, None]:
 #rom _pytest.config import get_config

 #onfig = get_config()
 #ield config
 #onfig._ensure_unconfigure()  # cleanup, e.g. capman closing tmpfiles.


# Regex to match the session duration string in the summary: "74.34s".
rex_session_duration = re.compile(r"\d+\.\d\ds")
# Regex to match all the counts and phrases in the summary line: "34 passed, 111 skipped".
rex_outcome = re.compile(r"(\d+) (\w+)")


class RunResult:
 #""The result of running a command."""

 #ef __init__(
 #elf,
 #et: Union[int, ExitCode],
 #utlines: List[str],
 #rrlines: List[str],
 #uration: float,
 # -> None:
 #ry:
 #elf.ret: Union[int, ExitCode] = ExitCode(ret)
 #""The return value."""
 #xcept ValueError:
 #elf.ret = ret
 #elf.outlines = outlines
 #""List of lines captured from stdout."""
 #elf.errlines = errlines
 #""List of lines captured from stderr."""
 #elf.stdout = LineMatcher(outlines)
 #"":class:`LineMatcher` of stdout.

 #se e.g. :func:`str(stdout) <LineMatcher.__str__()>` to reconstruct stdout, or the commonly used
 #func:`stdout.fnmatch_lines() <LineMatcher.fnmatch_lines()>` method.
 #""
 #elf.stderr = LineMatcher(errlines)
 #"":class:`LineMatcher` of stderr."""
 #elf.duration = duration
 #""Duration in seconds."""

 #ef __repr__(self) -> str:
 #eturn (
 #<RunResult ret=%s len(stdout.lines)=%d len(stderr.lines)=%d duration=%.2fs>"
 # (self.ret, len(self.stdout.lines), len(self.stderr.lines), self.duration)
 #

 #ef parseoutcomes(self) -> Dict[str, int]:
 #""Return a dictionary of outcome noun -> count from parsing the terminal
 #utput that the test process produced.

 #he returned nouns will always be in plural form::

 #====== 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====

 #ill return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.
 #""
 #eturn self.parse_summary_nouns(self.outlines)

 #classmethod
 #ef parse_summary_nouns(cls, lines) -> Dict[str, int]:
 #""Extract the nouns from a pytest terminal summary line.

 #t always returns the plural noun for consistency::

 #====== 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====

 #ill return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.
 #""
 #or line in reversed(lines):
 #f rex_session_duration.search(line):
 #utcomes = rex_outcome.findall(line)
 #et = {noun: int(count) for (count, noun) in outcomes}
 #reak
 #lse:
 #aise ValueError("Pytest terminal summary report not found")

 #o_plural = {
 #warning": "warnings",
 #error": "errors",
 #
 #eturn {to_plural.get(k, k): v for k, v in ret.items()}

 #ef assert_outcomes(
 #elf,
 #assed: int = 0,
 #kipped: int = 0,
 #ailed: int = 0,
 #rrors: int = 0,
 #passed: int = 0,
 #failed: int = 0,
 # -> None:
 #""Assert that the specified outcomes appear with the respective
 #umbers (0 means it didn't occur) in the text output from a test run."""
 #_tracebackhide__ = True
 #rom _pytest.pytester_assertions import assert_outcomes

 #utcomes = self.parseoutcomes()
 #ssert_outcomes(
 #utcomes,
 #assed=passed,
 #kipped=skipped,
 #ailed=failed,
 #rrors=errors,
 #passed=xpassed,
 #failed=xfailed,
 #


class CwdSnapshot:
 #ef __init__(self) -> None:
 #elf.__saved = os.getcwd()

 #ef restore(self) -> None:
 #s.chdir(self.__saved)


class SysModulesSnapshot:
 #ef __init__(self, preserve: Optional[Callable[[str], bool]] = None) -> None:
 #elf.__preserve = preserve
 #elf.__saved = dict(sys.modules)

 #ef restore(self) -> None:
 #f self.__preserve:
 #elf.__saved.update(
 #k, m) for k, m in sys.modules.items() if self.__preserve(k)
 #
 #ys.modules.clear()
 #ys.modules.update(self.__saved)


class SysPathsSnapshot:
 #ef __init__(self) -> None:
 #elf.__saved = list(sys.path), list(sys.meta_path)

 #ef restore(self) -> None:
 #ys.path[:], sys.meta_path[:] = self.__saved


@final
class Pytester:
 #""
 #acilities to write tests/configuration files, execute pytest in isolation, and match
 #gainst expected output, perfect for black-box testing of pytest plugins.

 #t attempts to isolate the test run from external factors as much as possible, modifying
 #he current working directory to ``path`` and environment variables during initialization.

 #ttributes:

 #ivar Path path: temporary directory path used to create files/run tests from, etc.

 #ivar plugins:
 # list of plugins to use with :py:meth:`parseconfig` and
 #py:meth:`runpytest`.  Initially this is an empty list but plugins can
 #e added to the list.  The type of items to add to the list depends on
 #he method using them so refer to them for details.
 #""

 #_test__ = False

 #LOSE_STDIN = object

 #lass TimeoutExpired(Exception):
 #ass

 #ef __init__(
 #elf,
 #equest: FixtureRequest,
 #mp_path_factory: TempPathFactory,
 #,
 #ispytest: bool = False,
 # -> None:
 #heck_ispytest(_ispytest)
 #elf._request = request
 #elf._mod_collections: WeakKeyDictionary[
 #ollector, List[Union[Item, Collector]]
 # = (WeakKeyDictionary())
 #f request.function:
 #ame: str = request.function.__name__
 #lse:
 #ame = request.node.name
 #elf._name = name
 #elf._path: Path = tmp_path_factory.mktemp(name, numbered=True)
 #elf.plugins: List[Union[str, _PluggyPlugin]] = []
 #elf._cwd_snapshot = CwdSnapshot()
 #elf._sys_path_snapshot = SysPathsSnapshot()
 #elf._sys_modules_snapshot = self.__take_sys_modules_snapshot()
 #elf.chdir()
 #elf._request.addfinalizer(self._finalize)
 #elf._method = self._request.config.getoption("--runpytest")
 #elf._test_tmproot = tmp_path_factory.mktemp(f"tmp-{name}", numbered=True)

 #elf._monkeypatch = mp = MonkeyPatch()
 #p.setenv("PYTEST_DEBUG_TEMPROOT", str(self._test_tmproot))
        # Ensure no unexpected caching via tox.
 #p.delenv("TOX_ENV_DIR", raising=False)
        # Discard outer pytest options.
 #p.delenv("PYTEST_ADDOPTS", raising=False)
        # Ensure no user config is used.
 #mphome = str(self.path)
 #p.setenv("HOME", tmphome)
 #p.setenv("USERPROFILE", tmphome)
        # Do not use colors for inner runs by default.
 #p.setenv("PY_COLORS", "0")

 #property
 #ef path(self) -> Path:
 #""Temporary directory where files are created and pytest is executed."""
 #eturn self._path

 #ef __repr__(self) -> str:
 #eturn f"<Pytester {self.path!r}>"

 #ef _finalize(self) -> None:
 #""
 #lean up global state artifacts.

 #ome methods modify the global interpreter state and this tries to
 #lean this up. It does not remove the temporary directory however so
 #t can be looked at after the test run has finished.
 #""
 #elf._sys_modules_snapshot.restore()
 #elf._sys_path_snapshot.restore()
 #elf._cwd_snapshot.restore()
 #elf._monkeypatch.undo()

 #ef __take_sys_modules_snapshot(self) -> SysModulesSnapshot:
        # Some zope modules used by twisted-related tests keep internal state
        # and can't be deleted; we had some trouble in the past with
        # `zope.interface` for example.
        #
        # Preserve readline due to https://bugs.python.org/issue41033.
        # pexpect issues a SIGWINCH.
 #ef preserve_module(name):
 #eturn name.startswith(("zope", "readline"))

 #eturn SysModulesSnapshot(preserve=preserve_module)

 #ef make_hook_recorder(self, pluginmanager: PytestPluginManager) -> HookRecorder:
 #""Create a new :py:class:`HookRecorder` for a PluginManager."""
 #luginmanager.reprec = reprec = HookRecorder(pluginmanager)
 #elf._request.addfinalizer(reprec.finish_recording)
 #eturn reprec

 #ef chdir(self) -> None:
 #""Cd into the temporary directory.

 #his is done automatically upon instantiation.
 #""
 #s.chdir(self.path)

 #ef _makefile(
 #elf,
 #xt: str,
 #ines: Sequence[Union[Any, bytes]],
 #iles: Dict[str, str],
 #ncoding: str = "utf-8",
 # -> Path:
 #tems = list(files.items())

 #ef to_text(s: Union[Any, bytes]) -> str:
 #eturn s.decode(encoding) if isinstance(s, bytes) else str(s)

 #f lines:
 #ource = "\n".join(to_text(x) for x in lines)
 #asename = self._name
 #tems.insert(0, (basename, source))

 #et = None
 #or basename, value in items:
 # = self.path.joinpath(basename).with_suffix(ext)
 #.parent.mkdir(parents=True, exist_ok=True)
 #ource_ = Source(value)
 #ource = "\n".join(to_text(line) for line in source_.lines)
 #.write_text(source.strip(), encoding=encoding)
 #f ret is None:
 #et = p
 #ssert ret is not None
 #eturn ret

 #ef makefile(self, ext: str, *args: str, **kwargs: str) -> Path:
 #"""Create new file(s) in the test directory.

 #param str ext:
 #he extension the file(s) should use, including the dot, e.g. `.py`.
 #param args:
 #ll args are treated as strings and joined using newlines.
 #he result is written as contents to the file.  The name of the
 #ile is based on the test function requesting this fixture.
 #param kwargs:
 #ach keyword is the name of a file, while the value of it will
 #e written as contents of the file.

 #xamples:

 #. code-block:: python

 #ytester.makefile(".txt", "line1", "line2")

 #ytester.makefile(".ini", pytest="[pytest]\naddopts=-rs\n")

 #""
 #eturn self._makefile(ext, args, kwargs)

 #ef makeconftest(self, source: str) -> Path:
 #""Write a contest.py file with 'source' as contents."""
 #eturn self.makepyfile(conftest=source)

 #ef makeini(self, source: str) -> Path:
 #""Write a tox.ini file with 'source' as contents."""
 #eturn self.makefile(".ini", tox=source)

 #ef getinicfg(self, source: str) -> SectionWrapper:
 #""Return the pytest section from the tox.ini config file."""
 # = self.makeini(source)
 #eturn IniConfig(str(p))["pytest"]

 #ef makepyprojecttoml(self, source: str) -> Path:
 #""Write a pyproject.toml file with 'source' as contents.

 #. versionadded:: 6.0
 #""
 #eturn self.makefile(".toml", pyproject=source)

 #ef makepyfile(self, *args, **kwargs) -> Path:
 #"""Shortcut for .makefile() with a .py extension.

 #efaults to the test name with a '.py' extension, e.g test_foobar.py, overwriting
 #xisting files.

 #xamples:

 #. code-block:: python

 #ef test_something(pytester):
                # Initial file is created test_something.py.
 #ytester.makepyfile("foobar")
                # To create multiple files, pass kwargs accordingly.
 #ytester.makepyfile(custom="foobar")
                # At this point, both 'test_something.py' & 'custom.py' exist in the test directory.

 #""
 #eturn self._makefile(".py", args, kwargs)

 #ef maketxtfile(self, *args, **kwargs) -> Path:
 #"""Shortcut for .makefile() with a .txt extension.

 #efaults to the test name with a '.txt' extension, e.g test_foobar.txt, overwriting
 #xisting files.

 #xamples:

 #. code-block:: python

 #ef test_something(pytester):
                # Initial file is created test_something.txt.
 #ytester.maketxtfile("foobar")
                # To create multiple files, pass kwargs accordingly.
 #ytester.maketxtfile(custom="foobar")
                # At this point, both 'test_something.txt' & 'custom.txt' exist in the test directory.

 #""
 #eturn self._makefile(".txt", args, kwargs)

 #ef syspathinsert(
 #elf, path: Optional[Union[str, "os.PathLike[str]"]] = None
 # -> None:
 #""Prepend a directory to sys.path, defaults to :py:attr:`tmpdir`.

 #his is undone automatically when this object dies at the end of each
 #est.
 #""
 #f path is None:
 #ath = self.path

 #elf._monkeypatch.syspath_prepend(str(path))

 #ef mkdir(self, name: str) -> Path:
 #""Create a new (sub)directory."""
 # = self.path / name
 #.mkdir()
 #eturn p

 #ef mkpydir(self, name: str) -> Path:
 #""Create a new python package.

 #his creates a (sub)directory with an empty ``__init__.py`` file so it
 #ets recognised as a Python package.
 #""
 # = self.path / name
 #.mkdir()
 #.joinpath("__init__.py").touch()
 #eturn p

 #ef copy_example(self, name: Optional[str] = None) -> Path:
 #""Copy file from project's directory into the testdir.

 #param str name: The name of the file to copy.
 #return: path to the copied directory (inside ``self.path``).

 #""
 #xample_dir = self._request.config.getini("pytester_example_dir")
 #f example_dir is None:
 #aise ValueError("pytester_example_dir is unset, can't copy examples")
 #xample_dir = Path(str(self._request.config.rootdir)) / example_dir

 #or extra_element in self._request.node.iter_markers("pytester_example_path"):
 #ssert extra_element.args
 #xample_dir = example_dir.joinpath(*extra_element.args)

 #f name is None:
 #unc_name = self._name
 #aybe_dir = example_dir / func_name
 #aybe_file = example_dir / (func_name + ".py")

 #f maybe_dir.is_dir():
 #xample_path = maybe_dir
 #lif maybe_file.is_file():
 #xample_path = maybe_file
 #lse:
 #aise LookupError(
 #"{func_name} can't be found as module or package in {example_dir}"
 #
 #lse:
 #xample_path = example_dir.joinpath(name)

 #f example_path.is_dir() and not example_path.joinpath("__init__.py").is_file():
            # TODO: py.path.local.copy can copy files to existing directories,
            # while with shutil.copytree the destination directory cannot exist,
            # we will need to roll our own in order to drop py.path.local completely
 #y.path.local(example_path).copy(py.path.local(self.path))
 #eturn self.path
 #lif example_path.is_file():
 #esult = self.path.joinpath(example_path.name)
 #hutil.copy(example_path, result)
 #eturn result
 #lse:
 #aise LookupError(
 #'example "{example_path}" is not found as a file or directory'
 #

 #ession = Session

 #ef getnode(
 #elf, config: Config, arg: Union[str, "os.PathLike[str]"]
 # -> Optional[Union[Collector, Item]]:
 #""Return the collection node of a file.

 #param _pytest.config.Config config:
 # pytest config.
 #ee :py:meth:`parseconfig` and :py:meth:`parseconfigure` for creating it.
 #param py.path.local arg:
 #ath to the file.
 #""
 #ession = Session.from_config(config)
 #ssert "::" not in str(arg)
 # = py.path.local(arg)
 #onfig.hook.pytest_sessionstart(session=session)
 #es = session.perform_collect([str(p)], genitems=False)[0]
 #onfig.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)
 #eturn res

 #ef getpathnode(self, path: Union[str, "os.PathLike[str]"]):
 #""Return the collection node of a file.

 #his is like :py:meth:`getnode` but uses :py:meth:`parseconfigure` to
 #reate the (configured) pytest Config instance.

 #param py.path.local path: Path to the file.
 #""
 #ath = py.path.local(path)
 #onfig = self.parseconfigure(path)
 #ession = Session.from_config(config)
 # = session.fspath.bestrelpath(path)
 #onfig.hook.pytest_sessionstart(session=session)
 #es = session.perform_collect([x], genitems=False)[0]
 #onfig.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)
 #eturn res

 #ef genitems(self, colitems: Sequence[Union[Item, Collector]]) -> List[Item]:
 #""Generate all test items from a collection node.

 #his recurses into the collection node and returns a list of all the
 #est items contained within.
 #""
 #ession = colitems[0].session
 #esult: List[Item] = []
 #or colitem in colitems:
 #esult.extend(session.genitems(colitem))
 #eturn result

 #ef runitem(self, source: str) -> Any:
 #""Run the "test_func" Item.

 #he calling test instance (class containing the test method) must
 #rovide a ``.getrunner()`` method which should return a runner which
 #an run the test protocol for a single item, e.g.
 #py:func:`_pytest.runner.runtestprotocol`.
 #""
        # used from runner functional tests
 #tem = self.getitem(source)
        # the test class where we are called from wants to provide the runner
 #estclassinstance = self._request.instance
 #unner = testclassinstance.getrunner()
 #eturn runner(item)

 #ef inline_runsource(self, source: str, *cmdlineargs) -> HookRecorder:
 #""Run a test module in process using ``pytest.main()``.

 #his run writes "source" into a temporary file and runs
 #`pytest.main()`` on it, returning a :py:class:`HookRecorder` instance
 #or the result.

 #param source: The source code of the test module.

 #param cmdlineargs: Any extra command line arguments to use.

 #returns: :py:class:`HookRecorder` instance of the result.
 #""
 # = self.makepyfile(source)
 #alues = list(cmdlineargs) + [p]
 #eturn self.inline_run(*values)

 #ef inline_genitems(self, *args) -> Tuple[List[Item], HookRecorder]:
 #""Run ``pytest.main(['--collectonly'])`` in-process.

 #uns the :py:func:`pytest.main` function to run all of pytest inside
 #he test process itself like :py:meth:`inline_run`, but returns a
 #uple of the collected items and a :py:class:`HookRecorder` instance.
 #""
 #ec = self.inline_run("--collect-only", *args)
 #tems = [x.item for x in rec.getcalls("pytest_itemcollected")]
 #eturn items, rec

 #ef inline_run(
 #elf,
 #args: Union[str, "os.PathLike[str]"],
 #lugins=(),
 #o_reraise_ctrlc: bool = False,
 # -> HookRecorder:
 #""Run ``pytest.main()`` in-process, returning a HookRecorder.

 #uns the :py:func:`pytest.main` function to run all of pytest inside
 #he test process itself.  This means it can return a
 #py:class:`HookRecorder` instance which gives more detailed results
 #rom that run than can be done by matching stdout/stderr from
 #py:meth:`runpytest`.

 #param args:
 #ommand line arguments to pass to :py:func:`pytest.main`.
 #param plugins:
 #xtra plugin instances the ``pytest.main()`` instance should use.
 #param no_reraise_ctrlc:
 #ypically we reraise keyboard interrupts from the child run. If
 #rue, the KeyboardInterrupt exception is captured.

 #returns: A :py:class:`HookRecorder` instance.
 #""
        # (maybe a cpython bug?) the importlib cache sometimes isn't updated
        # properly between file creation and inline_run (especially if imports
        # are interspersed with file creation)
 #mportlib.invalidate_caches()

 #lugins = list(plugins)
 #inalizers = []
 #ry:
            # Any sys.module or sys.path changes done while running pytest
            # inline should be reverted after the test run completes to avoid
            # clashing with later inline tests run within the same pytest test,
            # e.g. just because they use matching test module names.
 #inalizers.append(self.__take_sys_modules_snapshot().restore)
 #inalizers.append(SysPathsSnapshot().restore)

            # Important note:
            # - our tests should not leave any other references/registrations
            #   laying around other than possibly loaded test modules
            #   referenced from sys.modules, as nothing will clean those up
            #   automatically

 #ec = []

 #lass Collect:
 #ef pytest_configure(x, config: Config) -> None:
 #ec.append(self.make_hook_recorder(config.pluginmanager))

 #lugins.append(Collect())
 #et = main([str(x) for x in args], plugins=plugins)
 #f len(rec) == 1:
 #eprec = rec.pop()
 #lse:

 #lass reprec:  # type: ignore
 #ass

 #eprec.ret = ret  # type: ignore

            # Typically we reraise keyboard interrupts from the child run
            # because it's our user requesting interruption of the testing.
 #f ret == ExitCode.INTERRUPTED and not no_reraise_ctrlc:
 #alls = reprec.getcalls("pytest_keyboard_interrupt")
 #f calls and calls[-1].excinfo.type == KeyboardInterrupt:
 #aise KeyboardInterrupt()
 #eturn reprec
 #inally:
 #or finalizer in finalizers:
 #inalizer()

 #ef runpytest_inprocess(
 #elf, *args: Union[str, "os.PathLike[str]"], **kwargs: Any
 # -> RunResult:
 #""Return result of running pytest in-process, providing a similar
 #nterface to what self.runpytest() provides."""
 #yspathinsert = kwargs.pop("syspathinsert", False)

 #f syspathinsert:
 #elf.syspathinsert()
 #ow = timing.time()
 #apture = _get_multicapture("sys")
 #apture.start_capturing()
 #ry:
 #ry:
 #eprec = self.inline_run(*args, **kwargs)
 #xcept SystemExit as e:
 #et = e.args[0]
 #ry:
 #et = ExitCode(e.args[0])
 #xcept ValueError:
 #ass

 #lass reprec:  # type: ignore
 #et = ret

 #xcept Exception:
 #raceback.print_exc()

 #lass reprec:  # type: ignore
 #et = ExitCode(3)

 #inally:
 #ut, err = capture.readouterr()
 #apture.stop_capturing()
 #ys.stdout.write(out)
 #ys.stderr.write(err)

 #ssert reprec.ret is not None
 #es = RunResult(
 #eprec.ret, out.splitlines(), err.splitlines(), timing.time() - now
 #
 #es.reprec = reprec  # type: ignore
 #eturn res

 #ef runpytest(
 #elf, *args: Union[str, "os.PathLike[str]"], **kwargs: Any
 # -> RunResult:
 #""Run pytest inline or in a subprocess, depending on the command line
 #ption "--runpytest" and return a :py:class:`RunResult`."""
 #ew_args = self._ensure_basetemp(args)
 #f self._method == "inprocess":
 #eturn self.runpytest_inprocess(*new_args, **kwargs)
 #lif self._method == "subprocess":
 #eturn self.runpytest_subprocess(*new_args, **kwargs)
 #aise RuntimeError(f"Unrecognized runpytest option: {self._method}")

 #ef _ensure_basetemp(
 #elf, args: Sequence[Union[str, "os.PathLike[str]"]]
 # -> List[Union[str, "os.PathLike[str]"]]:
 #ew_args = list(args)
 #or x in new_args:
 #f str(x).startswith("--basetemp"):
 #reak
 #lse:
 #ew_args.append("--basetemp=%s" % self.path.parent.joinpath("basetemp"))
 #eturn new_args

 #ef parseconfig(self, *args: Union[str, "os.PathLike[str]"]) -> Config:
 #""Return a new pytest Config instance from given commandline args.

 #his invokes the pytest bootstrapping code in _pytest.config to create
 # new :py:class:`_pytest.core.PluginManager` and call the
 #ytest_cmdline_parse hook to create a new
 #py:class:`_pytest.config.Config` instance.

 #f :py:attr:`plugins` has been populated they should be plugin modules
 #o be registered with the PluginManager.
 #""
 #mport _pytest.config

 #ew_args = self._ensure_basetemp(args)
 #ew_args = [str(x) for x in new_args]

 #onfig = _pytest.config._prepareconfig(new_args, self.plugins)  # type: ignore[arg-type]
        # we don't know what the test will do with this half-setup config
        # object and thus we make sure it gets unconfigured properly in any
        # case (otherwise capturing could still be active, for example)
 #elf._request.addfinalizer(config._ensure_unconfigure)
 #eturn config

 #ef parseconfigure(self, *args: Union[str, "os.PathLike[str]"]) -> Config:
 #""Return a new pytest configured Config instance.

 #eturns a new :py:class:`_pytest.config.Config` instance like
 #py:meth:`parseconfig`, but also calls the pytest_configure hook.
 #""
 #onfig = self.parseconfig(*args)
 #onfig._do_configure()
 #eturn config

 #ef getitem(self, source: str, funcname: str = "test_func") -> Item:
 #""Return the test item for a test function.

 #rites the source to a python file and runs pytest's collection on
 #he resulting module, returning the test item for the requested
 #unction name.

 #param source:
 #he module source.
 #param funcname:
 #he name of the test function for which to return a test item.
 #""
 #tems = self.getitems(source)
 #or item in items:
 #f item.name == funcname:
 #eturn item
 #ssert 0, "{!r} item not found in module:\n{}\nitems: {}".format(
 #uncname, source, items
 #

 #ef getitems(self, source: str) -> List[Item]:
 #""Return all test items collected from the module.

 #rites the source to a Python file and runs pytest's collection on
 #he resulting module, returning all test items contained within.
 #""
 #odcol = self.getmodulecol(source)
 #eturn self.genitems([modcol])

 #ef getmodulecol(
 #elf, source: Union[str, Path], configargs=(), *, withinit: bool = False
 #:
 #""Return the module collection node for ``source``.

 #rites ``source`` to a file using :py:meth:`makepyfile` and then
 #uns the pytest collection on it, returning the collection node for the
 #est module.

 #param source:
 #he source code of the module to collect.

 #param configargs:
 #ny extra arguments to pass to :py:meth:`parseconfigure`.

 #param withinit:
 #hether to also write an ``__init__.py`` file to the same
 #irectory to ensure it is a package.
 #""
 #f isinstance(source, Path):
 #ath = self.path.joinpath(source)
 #ssert not withinit, "not supported for paths"
 #lse:
 #w = {self._name: str(source)}
 #ath = self.makepyfile(**kw)
 #f withinit:
 #elf.makepyfile(__init__="#")
 #elf.config = config = self.parseconfigure(path, *configargs)
 #eturn self.getnode(config, path)

 #ef collect_by_name(
 #elf, modcol: Collector, name: str
 # -> Optional[Union[Item, Collector]]:
 #""Return the collection node for name from the module collection.

 #earchs a module collection node for a collection node matching the
 #iven name.

 #param modcol: A module collection node; see :py:meth:`getmodulecol`.
 #param name: The name of the node to return.
 #""
 #f modcol not in self._mod_collections:
 #elf._mod_collections[modcol] = list(modcol.collect())
 #or colitem in self._mod_collections[modcol]:
 #f colitem.name == name:
 #eturn colitem
 #eturn None

 #ef popen(
 #elf,
 #mdargs,
 #tdout: Union[int, TextIO] = subprocess.PIPE,
 #tderr: Union[int, TextIO] = subprocess.PIPE,
 #tdin=CLOSE_STDIN,
 #*kw,
 #:
 #""Invoke subprocess.Popen.

 #alls subprocess.Popen making sure the current working directory is
 #n the PYTHONPATH.

 #ou probably want to use :py:meth:`run` instead.
 #""
 #nv = os.environ.copy()
 #nv["PYTHONPATH"] = os.pathsep.join(
 #ilter(None, [os.getcwd(), env.get("PYTHONPATH", "")])
 #
 #w["env"] = env

 #f stdin is self.CLOSE_STDIN:
 #w["stdin"] = subprocess.PIPE
 #lif isinstance(stdin, bytes):
 #w["stdin"] = subprocess.PIPE
 #lse:
 #w["stdin"] = stdin

 #open = subprocess.Popen(cmdargs, stdout=stdout, stderr=stderr, **kw)
 #f stdin is self.CLOSE_STDIN:
 #ssert popen.stdin is not None
 #open.stdin.close()
 #lif isinstance(stdin, bytes):
 #ssert popen.stdin is not None
 #open.stdin.write(stdin)

 #eturn popen

 #ef run(
 #elf,
 #cmdargs: Union[str, "os.PathLike[str]"],
 #imeout: Optional[float] = None,
 #tdin=CLOSE_STDIN,
 # -> RunResult:
 #""Run a command with arguments.

 #un a process using subprocess.Popen saving the stdout and stderr.

 #param cmdargs:
 #he sequence of arguments to pass to `subprocess.Popen()`, with path-like objects
 #eing converted to ``str`` automatically.
 #param timeout:
 #he period in seconds after which to timeout and raise
 #py:class:`Pytester.TimeoutExpired`.
 #param stdin:
 #ptional standard input.  Bytes are being send, closing
 #he pipe, otherwise it is passed through to ``popen``.
 #efaults to ``CLOSE_STDIN``, which translates to using a pipe
 #``subprocess.PIPE``) that gets closed.

 #rtype: RunResult
 #""
 #_tracebackhide__ = True

        # TODO: Remove type ignore in next mypy release.
        #       https://github.com/python/typeshed/pull/4582
 #mdargs = tuple(
 #s.fspath(arg) if isinstance(arg, os.PathLike) else arg for arg in cmdargs  # type: ignore[misc]
 #
 #1 = self.path.joinpath("stdout")
 #2 = self.path.joinpath("stderr")
 #rint("running:", *cmdargs)
 #rint("     in:", Path.cwd())

 #ith p1.open("w", encoding="utf8") as f1, p2.open("w", encoding="utf8") as f2:
 #ow = timing.time()
 #open = self.popen(
 #mdargs,
 #tdin=stdin,
 #tdout=f1,
 #tderr=f2,
 #lose_fds=(sys.platform != "win32"),
 #
 #f popen.stdin is not None:
 #open.stdin.close()

 #ef handle_timeout() -> None:
 #_tracebackhide__ = True

 #imeout_message = (
 #{seconds} second timeout expired running:"
 # {command}".format(seconds=timeout, command=cmdargs)
 #

 #open.kill()
 #open.wait()
 #aise self.TimeoutExpired(timeout_message)

 #f timeout is None:
 #et = popen.wait()
 #lse:
 #ry:
 #et = popen.wait(timeout)
 #xcept subprocess.TimeoutExpired:
 #andle_timeout()

 #ith p1.open(encoding="utf8") as f1, p2.open(encoding="utf8") as f2:
 #ut = f1.read().splitlines()
 #rr = f2.read().splitlines()

 #elf._dump_lines(out, sys.stdout)
 #elf._dump_lines(err, sys.stderr)

 #ith contextlib.suppress(ValueError):
 #et = ExitCode(ret)
 #eturn RunResult(ret, out, err, timing.time() - now)

 #ef _dump_lines(self, lines, fp):
 #ry:
 #or line in lines:
 #rint(line, file=fp)
 #xcept UnicodeEncodeError:
 #rint(f"couldn't print to {fp} because of encoding")

 #ef _getpytestargs(self) -> Tuple[str, ...]:
 #eturn sys.executable, "-mpytest"

 #ef runpython(self, script) -> RunResult:
 #""Run a python script using sys.executable as interpreter.

 #rtype: RunResult
 #""
 #eturn self.run(sys.executable, script)

 #ef runpython_c(self, command):
 #""Run python -c "command".

 #rtype: RunResult
 #""
 #eturn self.run(sys.executable, "-c", command)

 #ef runpytest_subprocess(self, *args, timeout: Optional[float] = None) -> RunResult:
 #""Run pytest as a subprocess with given arguments.

 #ny plugins added to the :py:attr:`plugins` list will be added using the
 #`-p`` command line option.  Additionally ``--basetemp`` is used to put
 #ny temporary files and directories in a numbered directory prefixed
 #ith "runpytest-" to not conflict with the normal numbered pytest
 #ocation for temporary files and directories.

 #param args:
 #he sequence of arguments to pass to the pytest subprocess.
 #param timeout:
 #he period in seconds after which to timeout and raise
 #py:class:`Pytester.TimeoutExpired`.

 #rtype: RunResult
 #""
 #_tracebackhide__ = True
 # = make_numbered_dir(root=self.path, prefix="runpytest-", mode=0o700)
 #rgs = ("--basetemp=%s" % p,) + args
 #lugins = [x for x in self.plugins if isinstance(x, str)]
 #f plugins:
 #rgs = ("-p", plugins[0]) + args
 #rgs = self._getpytestargs() + args
 #eturn self.run(*args, timeout=timeout)

 #ef spawn_pytest(
 #elf, string: str, expect_timeout: float = 10.0
 # -> "pexpect.spawn":
 #""Run pytest using pexpect.

 #his makes sure to use the right pytest and sets up the temporary
 #irectory locations.

 #he pexpect child is returned.
 #""
 #asetemp = self.path / "temp-pexpect"
 #asetemp.mkdir(mode=0o700)
 #nvoke = " ".join(map(str, self._getpytestargs()))
 #md = f"{invoke} --basetemp={basetemp} {string}"
 #eturn self.spawn(cmd, expect_timeout=expect_timeout)

 #ef spawn(self, cmd: str, expect_timeout: float = 10.0) -> "pexpect.spawn":
 #""Run a command using pexpect.

 #he pexpect child is returned.
 #""
 #expect = importorskip("pexpect", "3.0")
 #f hasattr(sys, "pypy_version_info") and "64" in platform.machine():
 #kip("pypy-64 bit not supported")
 #f not hasattr(pexpect, "spawn"):
 #kip("pexpect.spawn not available")
 #ogfile = self.path.joinpath("spawn.out").open("wb")

 #hild = pexpect.spawn(cmd, logfile=logfile, timeout=expect_timeout)
 #elf._request.addfinalizer(logfile.close)
 #eturn child


class LineComp:
 #ef __init__(self) -> None:
 #elf.stringio = StringIO()
 #"":class:`python:io.StringIO()` instance used for input."""

 #ef assert_contains_lines(self, lines2: Sequence[str]) -> None:
 #""Assert that ``lines2`` are contained (linearly) in :attr:`stringio`'s value.

 #ines are matched using :func:`LineMatcher.fnmatch_lines`.
 #""
 #_tracebackhide__ = True
 #al = self.stringio.getvalue()
 #elf.stringio.truncate(0)
 #elf.stringio.seek(0)
 #ines1 = val.split("\n")
 #ineMatcher(lines1).fnmatch_lines(lines2)


@final
@attr.s(repr=False, str=False, init=False)
class Testdir:
 #""
 #imilar to :class:`Pytester`, but this class works with legacy py.path.local objects instead.

 #ll methods just forward to an internal :class:`Pytester` instance, converting results
 #o `py.path.local` objects as necessary.
 #""

 #_test__ = False

 #LOSE_STDIN = Pytester.CLOSE_STDIN
 #imeoutExpired = Pytester.TimeoutExpired
 #ession = Pytester.Session

 #ef __init__(self, pytester: Pytester, *, _ispytest: bool = False) -> None:
 #heck_ispytest(_ispytest)
 #elf._pytester = pytester

 #property
 #ef tmpdir(self) -> py.path.local:
 #""Temporary directory where tests are executed."""
 #eturn py.path.local(self._pytester.path)

 #property
 #ef test_tmproot(self) -> py.path.local:
 #eturn py.path.local(self._pytester._test_tmproot)

 #property
 #ef request(self):
 #eturn self._pytester._request

 #property
 #ef plugins(self):
 #eturn self._pytester.plugins

 #plugins.setter
 #ef plugins(self, plugins):
 #elf._pytester.plugins = plugins

 #property
 #ef monkeypatch(self) -> MonkeyPatch:
 #eturn self._pytester._monkeypatch

 #ef make_hook_recorder(self, pluginmanager) -> HookRecorder:
 #""See :meth:`Pytester.make_hook_recorder`."""
 #eturn self._pytester.make_hook_recorder(pluginmanager)

 #ef chdir(self) -> None:
 #""See :meth:`Pytester.chdir`."""
 #eturn self._pytester.chdir()

 #ef finalize(self) -> None:
 #""See :meth:`Pytester._finalize`."""
 #eturn self._pytester._finalize()

 #ef makefile(self, ext, *args, **kwargs) -> py.path.local:
 #""See :meth:`Pytester.makefile`."""
 #eturn py.path.local(str(self._pytester.makefile(ext, *args, **kwargs)))

 #ef makeconftest(self, source) -> py.path.local:
 #""See :meth:`Pytester.makeconftest`."""
 #eturn py.path.local(str(self._pytester.makeconftest(source)))

 #ef makeini(self, source) -> py.path.local:
 #""See :meth:`Pytester.makeini`."""
 #eturn py.path.local(str(self._pytester.makeini(source)))

 #ef getinicfg(self, source: str) -> SectionWrapper:
 #""See :meth:`Pytester.getinicfg`."""
 #eturn self._pytester.getinicfg(source)

 #ef makepyprojecttoml(self, source) -> py.path.local:
 #""See :meth:`Pytester.makepyprojecttoml`."""
 #eturn py.path.local(str(self._pytester.makepyprojecttoml(source)))

 #ef makepyfile(self, *args, **kwargs) -> py.path.local:
 #""See :meth:`Pytester.makepyfile`."""
 #eturn py.path.local(str(self._pytester.makepyfile(*args, **kwargs)))

 #ef maketxtfile(self, *args, **kwargs) -> py.path.local:
 #""See :meth:`Pytester.maketxtfile`."""
 #eturn py.path.local(str(self._pytester.maketxtfile(*args, **kwargs)))

 #ef syspathinsert(self, path=None) -> None:
 #""See :meth:`Pytester.syspathinsert`."""
 #eturn self._pytester.syspathinsert(path)

 #ef mkdir(self, name) -> py.path.local:
 #""See :meth:`Pytester.mkdir`."""
 #eturn py.path.local(str(self._pytester.mkdir(name)))

 #ef mkpydir(self, name) -> py.path.local:
 #""See :meth:`Pytester.mkpydir`."""
 #eturn py.path.local(str(self._pytester.mkpydir(name)))

 #ef copy_example(self, name=None) -> py.path.local:
 #""See :meth:`Pytester.copy_example`."""
 #eturn py.path.local(str(self._pytester.copy_example(name)))

 #ef getnode(self, config: Config, arg) -> Optional[Union[Item, Collector]]:
 #""See :meth:`Pytester.getnode`."""
 #eturn self._pytester.getnode(config, arg)

 #ef getpathnode(self, path):
 #""See :meth:`Pytester.getpathnode`."""
 #eturn self._pytester.getpathnode(path)

 #ef genitems(self, colitems: List[Union[Item, Collector]]) -> List[Item]:
 #""See :meth:`Pytester.genitems`."""
 #eturn self._pytester.genitems(colitems)

 #ef runitem(self, source):
 #""See :meth:`Pytester.runitem`."""
 #eturn self._pytester.runitem(source)

 #ef inline_runsource(self, source, *cmdlineargs):
 #""See :meth:`Pytester.inline_runsource`."""
 #eturn self._pytester.inline_runsource(source, *cmdlineargs)

 #ef inline_genitems(self, *args):
 #""See :meth:`Pytester.inline_genitems`."""
 #eturn self._pytester.inline_genitems(*args)

 #ef inline_run(self, *args, plugins=(), no_reraise_ctrlc: bool = False):
 #""See :meth:`Pytester.inline_run`."""
 #eturn self._pytester.inline_run(
 #args, plugins=plugins, no_reraise_ctrlc=no_reraise_ctrlc
 #

 #ef runpytest_inprocess(self, *args, **kwargs) -> RunResult:
 #""See :meth:`Pytester.runpytest_inprocess`."""
 #eturn self._pytester.runpytest_inprocess(*args, **kwargs)

 #ef runpytest(self, *args, **kwargs) -> RunResult:
 #""See :meth:`Pytester.runpytest`."""
 #eturn self._pytester.runpytest(*args, **kwargs)

 #ef parseconfig(self, *args) -> Config:
 #""See :meth:`Pytester.parseconfig`."""
 #eturn self._pytester.parseconfig(*args)

 #ef parseconfigure(self, *args) -> Config:
 #""See :meth:`Pytester.parseconfigure`."""
 #eturn self._pytester.parseconfigure(*args)

 #ef getitem(self, source, funcname="test_func"):
 #""See :meth:`Pytester.getitem`."""
 #eturn self._pytester.getitem(source, funcname)

 #ef getitems(self, source):
 #""See :meth:`Pytester.getitems`."""
 #eturn self._pytester.getitems(source)

 #ef getmodulecol(self, source, configargs=(), withinit=False):
 #""See :meth:`Pytester.getmodulecol`."""
 #eturn self._pytester.getmodulecol(
 #ource, configargs=configargs, withinit=withinit
 #

 #ef collect_by_name(
 #elf, modcol: Collector, name: str
 # -> Optional[Union[Item, Collector]]:
 #""See :meth:`Pytester.collect_by_name`."""
 #eturn self._pytester.collect_by_name(modcol, name)

 #ef popen(
 #elf,
 #mdargs,
 #tdout: Union[int, TextIO] = subprocess.PIPE,
 #tderr: Union[int, TextIO] = subprocess.PIPE,
 #tdin=CLOSE_STDIN,
 #*kw,
 #:
 #""See :meth:`Pytester.popen`."""
 #eturn self._pytester.popen(cmdargs, stdout, stderr, stdin, **kw)

 #ef run(self, *cmdargs, timeout=None, stdin=CLOSE_STDIN) -> RunResult:
 #""See :meth:`Pytester.run`."""
 #eturn self._pytester.run(*cmdargs, timeout=timeout, stdin=stdin)

 #ef runpython(self, script) -> RunResult:
 #""See :meth:`Pytester.runpython`."""
 #eturn self._pytester.runpython(script)

 #ef runpython_c(self, command):
 #""See :meth:`Pytester.runpython_c`."""
 #eturn self._pytester.runpython_c(command)

 #ef runpytest_subprocess(self, *args, timeout=None) -> RunResult:
 #""See :meth:`Pytester.runpytest_subprocess`."""
 #eturn self._pytester.runpytest_subprocess(*args, timeout=timeout)

 #ef spawn_pytest(
 #elf, string: str, expect_timeout: float = 10.0
 # -> "pexpect.spawn":
 #""See :meth:`Pytester.spawn_pytest`."""
 #eturn self._pytester.spawn_pytest(string, expect_timeout=expect_timeout)

 #ef spawn(self, cmd: str, expect_timeout: float = 10.0) -> "pexpect.spawn":
 #""See :meth:`Pytester.spawn`."""
 #eturn self._pytester.spawn(cmd, expect_timeout=expect_timeout)

 #ef __repr__(self) -> str:
 #eturn f"<Testdir {self.tmpdir!r}>"

 #ef __str__(self) -> str:
 #eturn str(self.tmpdir)


class LineMatcher:
 #""Flexible matching of text.

 #his is a convenience class to test large texts like the output of
 #ommands.

 #he constructor takes a list of lines without their trailing newlines, i.e.
 #`text.splitlines()``.
 #""

 #ef __init__(self, lines: List[str]) -> None:
 #elf.lines = lines
 #elf._log_output: List[str] = []

 #ef __str__(self) -> str:
 #""Return the entire original text.

 #. versionadded:: 6.2
 #ou can use :meth:`str` in older versions.
 #""
 #eturn "\n".join(self.lines)

 #ef _getlines(self, lines2: Union[str, Sequence[str], Source]) -> Sequence[str]:
 #f isinstance(lines2, str):
 #ines2 = Source(lines2)
 #f isinstance(lines2, Source):
 #ines2 = lines2.strip().lines
 #eturn lines2

 #ef fnmatch_lines_random(self, lines2: Sequence[str]) -> None:
 #""Check lines exist in the output in any order (using :func:`python:fnmatch.fnmatch`)."""
 #_tracebackhide__ = True
 #elf._match_lines_random(lines2, fnmatch)

 #ef re_match_lines_random(self, lines2: Sequence[str]) -> None:
 #""Check lines exist in the output in any order (using :func:`python:re.match`)."""
 #_tracebackhide__ = True
 #elf._match_lines_random(lines2, lambda name, pat: bool(re.match(pat, name)))

 #ef _match_lines_random(
 #elf, lines2: Sequence[str], match_func: Callable[[str, str], bool]
 # -> None:
 #_tracebackhide__ = True
 #ines2 = self._getlines(lines2)
 #or line in lines2:
 #or x in self.lines:
 #f line == x or match_func(x, line):
 #elf._log("matched: ", repr(line))
 #reak
 #lse:
 #sg = "line %r not found in output" % line
 #elf._log(msg)
 #elf._fail(msg)

 #ef get_lines_after(self, fnline: str) -> Sequence[str]:
 #""Return all lines following the given line in the text.

 #he given line can contain glob wildcards.
 #""
 #or i, line in enumerate(self.lines):
 #f fnline == line or fnmatch(line, fnline):
 #eturn self.lines[i + 1 :]
 #aise ValueError("line %r not found in output" % fnline)

 #ef _log(self, *args) -> None:
 #elf._log_output.append(" ".join(str(x) for x in args))

 #property
 #ef _log_text(self) -> str:
 #eturn "\n".join(self._log_output)

 #ef fnmatch_lines(
 #elf, lines2: Sequence[str], *, consecutive: bool = False
 # -> None:
 #""Check lines exist in the output (using :func:`python:fnmatch.fnmatch`).

 #he argument is a list of lines which have to match and can use glob
 #ildcards.  If they do not match a pytest.fail() is called.  The
 #atches and non-matches are also shown as part of the error message.

 #param lines2: String patterns to match.
 #param consecutive: Match lines consecutively?
 #""
 #_tracebackhide__ = True
 #elf._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)

 #ef re_match_lines(
 #elf, lines2: Sequence[str], *, consecutive: bool = False
 # -> None:
 #""Check lines exist in the output (using :func:`python:re.match`).

 #he argument is a list of lines which have to match using ``re.match``.
 #f they do not match a pytest.fail() is called.

 #he matches and non-matches are also shown as part of the error message.

 #param lines2: string patterns to match.
 #param consecutive: match lines consecutively?
 #""
 #_tracebackhide__ = True
 #elf._match_lines(
 #ines2,
 #ambda name, pat: bool(re.match(pat, name)),
 #re.match",
 #onsecutive=consecutive,
 #

 #ef _match_lines(
 #elf,
 #ines2: Sequence[str],
 #atch_func: Callable[[str, str], bool],
 #atch_nickname: str,
 #,
 #onsecutive: bool = False,
 # -> None:
 #""Underlying implementation of ``fnmatch_lines`` and ``re_match_lines``.

 #param Sequence[str] lines2:
 #ist of string patterns to match. The actual format depends on
 #`match_func``.
 #param match_func:
 # callable ``match_func(line, pattern)`` where line is the
 #aptured line from stdout/stderr and pattern is the matching
 #attern.
 #param str match_nickname:
 #he nickname for the match function that will be logged to stdout
 #hen a match occurs.
 #param consecutive:
 #atch lines consecutively?
 #""
 #f not isinstance(lines2, collections.abc.Sequence):
 #aise TypeError("invalid type for lines2: {}".format(type(lines2).__name__))
 #ines2 = self._getlines(lines2)
 #ines1 = self.lines[:]
 #xtralines = []
 #_tracebackhide__ = True
 #nick = len(match_nickname) + 1
 #tarted = False
 #or line in lines2:
 #omatchprinted = False
 #hile lines1:
 #extline = lines1.pop(0)
 #f line == nextline:
 #elf._log("exact match:", repr(line))
 #tarted = True
 #reak
 #lif match_func(nextline, line):
 #elf._log("%s:" % match_nickname, repr(line))
 #elf._log(
 #{:>{width}}".format("with:", width=wnick), repr(nextline)
 #
 #tarted = True
 #reak
 #lse:
 #f consecutive and started:
 #sg = f"no consecutive match: {line!r}"
 #elf._log(msg)
 #elf._log(
 #{:>{width}}".format("with:", width=wnick), repr(nextline)
 #
 #elf._fail(msg)
 #f not nomatchprinted:
 #elf._log(
 #{:>{width}}".format("nomatch:", width=wnick), repr(line)
 #
 #omatchprinted = True
 #elf._log("{:>{width}}".format("and:", width=wnick), repr(nextline))
 #xtralines.append(nextline)
 #lse:
 #sg = f"remains unmatched: {line!r}"
 #elf._log(msg)
 #elf._fail(msg)
 #elf._log_output = []

 #ef no_fnmatch_line(self, pat: str) -> None:
 #""Ensure captured lines do not match the given pattern, using ``fnmatch.fnmatch``.

 #param str pat: The pattern to match lines.
 #""
 #_tracebackhide__ = True
 #elf._no_match_line(pat, fnmatch, "fnmatch")

 #ef no_re_match_line(self, pat: str) -> None:
 #""Ensure captured lines do not match the given pattern, using ``re.match``.

 #param str pat: The regular expression to match lines.
 #""
 #_tracebackhide__ = True
 #elf._no_match_line(
 #at, lambda name, pat: bool(re.match(pat, name)), "re.match"
 #

 #ef _no_match_line(
 #elf, pat: str, match_func: Callable[[str, str], bool], match_nickname: str
 # -> None:
 #""Ensure captured lines does not have a the given pattern, using ``fnmatch.fnmatch``.

 #param str pat: The pattern to match lines.
 #""
 #_tracebackhide__ = True
 #omatch_printed = False
 #nick = len(match_nickname) + 1
 #or line in self.lines:
 #f match_func(line, pat):
 #sg = f"{match_nickname}: {pat!r}"
 #elf._log(msg)
 #elf._log("{:>{width}}".format("with:", width=wnick), repr(line))
 #elf._fail(msg)
 #lse:
 #f not nomatch_printed:
 #elf._log("{:>{width}}".format("nomatch:", width=wnick), repr(pat))
 #omatch_printed = True
 #elf._log("{:>{width}}".format("and:", width=wnick), repr(line))
 #elf._log_output = []

 #ef _fail(self, msg: str) -> None:
 #_tracebackhide__ = True
 #og_text = self._log_text
 #elf._log_output = []
 #ail(log_text)

 #ef str(self) -> str:
 #""Return the entire original text."""
 #eturn str(self)
