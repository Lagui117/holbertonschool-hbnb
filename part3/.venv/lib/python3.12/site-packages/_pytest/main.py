"""Core implementation of the testing process: init, session, runtest loop."""
import argparse
import fnmatch
import functools
import importlib
import os
import sys
from pathlib import Path
from typing import Callable
from typing import Dict
from typing import FrozenSet
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union

import attr
import py

import _pytest._code
from _pytest import nodes
from _pytest.compat import final
from _pytest.config import Config
from _pytest.config import directory_arg
from _pytest.config import ExitCode
from _pytest.config import hookimpl
from _pytest.config import PytestPluginManager
from _pytest.config import UsageError
from _pytest.config.argparsing import Parser
from _pytest.fixtures import FixtureManager
from _pytest.outcomes import exit
from _pytest.pathlib import absolutepath
from _pytest.pathlib import bestrelpath
from _pytest.pathlib import visit
from _pytest.reports import CollectReport
from _pytest.reports import TestReport
from _pytest.runner import collect_one_node
from _pytest.runner import SetupState


if TYPE_CHECKING:
 #rom typing_extensions import Literal


def pytest_addoption(parser: Parser) -> None:
 #arser.addini(
 #norecursedirs",
 #directory patterns to avoid for recursion",
 #ype="args",
 #efault=[
 #*.egg",
 #.*",
 #_darcs",
 #build",
 #CVS",
 #dist",
 #node_modules",
 #venv",
 #{arch}",
 #,
 #
 #arser.addini(
 #testpaths",
 #directories to search for tests when no files or directories are given in the "
 #command line.",
 #ype="args",
 #efault=[],
 #
 #roup = parser.getgroup("general", "running and selection options")
 #roup._addoption(
 #-x",
 #--exitfirst",
 #ction="store_const",
 #est="maxfail",
 #onst=1,
 #elp="exit instantly on first error or failed test.",
 #
 #roup = parser.getgroup("pytest-warnings")
 #roup.addoption(
 #-W",
 #--pythonwarnings",
 #ction="append",
 #elp="set which warnings to report, see -W option of python itself.",
 #
 #arser.addini(
 #filterwarnings",
 #ype="linelist",
 #elp="Each line specifies a pattern for "
 #warnings.filterwarnings. "
 #Processed after -W/--pythonwarnings.",
 #
 #roup._addoption(
 #--maxfail",
 #etavar="num",
 #ction="store",
 #ype=int,
 #est="maxfail",
 #efault=0,
 #elp="exit after first num failures or errors.",
 #
 #roup._addoption(
 #--strict-config",
 #ction="store_true",
 #elp="any warnings encountered while parsing the `pytest` section of the configuration file raise errors.",
 #
 #roup._addoption(
 #--strict-markers",
 #ction="store_true",
 #elp="markers not registered in the `markers` section of the configuration file raise errors.",
 #
 #roup._addoption(
 #--strict", action="store_true", help="(deprecated) alias to --strict-markers.",
 #
 #roup._addoption(
 #-c",
 #etavar="file",
 #ype=str,
 #est="inifilename",
 #elp="load configuration from `file` instead of trying to locate one of the implicit "
 #configuration files.",
 #
 #roup._addoption(
 #--continue-on-collection-errors",
 #ction="store_true",
 #efault=False,
 #est="continue_on_collection_errors",
 #elp="Force test execution even if collection errors occur.",
 #
 #roup._addoption(
 #--rootdir",
 #ction="store",
 #est="rootdir",
 #elp="Define root directory for tests. Can be relative path: 'root_dir', './root_dir', "
 #'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: "
 #'$HOME/root_dir'.",
 #

 #roup = parser.getgroup("collect", "collection")
 #roup.addoption(
 #--collectonly",
 #--collect-only",
 #--co",
 #ction="store_true",
 #elp="only collect tests, don't execute them.",
 #
 #roup.addoption(
 #--pyargs",
 #ction="store_true",
 #elp="try to interpret all arguments as python packages.",
 #
 #roup.addoption(
 #--ignore",
 #ction="append",
 #etavar="path",
 #elp="ignore path during collection (multi-allowed).",
 #
 #roup.addoption(
 #--ignore-glob",
 #ction="append",
 #etavar="path",
 #elp="ignore path pattern during collection (multi-allowed).",
 #
 #roup.addoption(
 #--deselect",
 #ction="append",
 #etavar="nodeid_prefix",
 #elp="deselect item (via node id prefix) during collection (multi-allowed).",
 #
 #roup.addoption(
 #--confcutdir",
 #est="confcutdir",
 #efault=None,
 #etavar="dir",
 #ype=functools.partial(directory_arg, optname="--confcutdir"),
 #elp="only load conftest.py's relative to specified dir.",
 #
 #roup.addoption(
 #--noconftest",
 #ction="store_true",
 #est="noconftest",
 #efault=False,
 #elp="Don't load any conftest.py files.",
 #
 #roup.addoption(
 #--keepduplicates",
 #--keep-duplicates",
 #ction="store_true",
 #est="keepduplicates",
 #efault=False,
 #elp="Keep duplicate tests.",
 #
 #roup.addoption(
 #--collect-in-virtualenv",
 #ction="store_true",
 #est="collect_in_virtualenv",
 #efault=False,
 #elp="Don't ignore tests in a local virtualenv directory",
 #
 #roup.addoption(
 #--import-mode",
 #efault="prepend",
 #hoices=["prepend", "append", "importlib"],
 #est="importmode",
 #elp="prepend/append to sys.path when importing test modules and conftest files, "
 #default is to prepend.",
 #

 #roup = parser.getgroup("debugconfig", "test session debugging and configuration")
 #roup.addoption(
 #--basetemp",
 #est="basetemp",
 #efault=None,
 #ype=validate_basetemp,
 #etavar="dir",
 #elp=(
 #base temporary directory for this test run."
 #(warning: this directory is removed if it exists)"
 #,
 #


def validate_basetemp(path: str) -> str:
    # GH 7119
 #sg = "basetemp must not be empty, the current working directory or any parent directory of it"

    # empty path
 #f not path:
 #aise argparse.ArgumentTypeError(msg)

 #ef is_ancestor(base: Path, query: Path) -> bool:
 #""Return whether query is an ancestor of base."""
 #f base == query:
 #eturn True
 #or parent in base.parents:
 #f parent == query:
 #eturn True
 #eturn False

    # check if path is an ancestor of cwd
 #f is_ancestor(Path.cwd(), Path(path).absolute()):
 #aise argparse.ArgumentTypeError(msg)

    # check symlinks for ancestors
 #f is_ancestor(Path.cwd().resolve(), Path(path).resolve()):
 #aise argparse.ArgumentTypeError(msg)

 #eturn path


def wrap_session(
 #onfig: Config, doit: Callable[[Config, "Session"], Optional[Union[int, ExitCode]]]
) -> Union[int, ExitCode]:
 #""Skeleton command line program."""
 #ession = Session.from_config(config)
 #ession.exitstatus = ExitCode.OK
 #nitstate = 0
 #ry:
 #ry:
 #onfig._do_configure()
 #nitstate = 1
 #onfig.hook.pytest_sessionstart(session=session)
 #nitstate = 2
 #ession.exitstatus = doit(config, session) or 0
 #xcept UsageError:
 #ession.exitstatus = ExitCode.USAGE_ERROR
 #aise
 #xcept Failed:
 #ession.exitstatus = ExitCode.TESTS_FAILED
 #xcept (KeyboardInterrupt, exit.Exception):
 #xcinfo = _pytest._code.ExceptionInfo.from_current()
 #xitstatus: Union[int, ExitCode] = ExitCode.INTERRUPTED
 #f isinstance(excinfo.value, exit.Exception):
 #f excinfo.value.returncode is not None:
 #xitstatus = excinfo.value.returncode
 #f initstate < 2:
 #ys.stderr.write(f"{excinfo.typename}: {excinfo.value.msg}\n")
 #onfig.hook.pytest_keyboard_interrupt(excinfo=excinfo)
 #ession.exitstatus = exitstatus
 #xcept BaseException:
 #ession.exitstatus = ExitCode.INTERNAL_ERROR
 #xcinfo = _pytest._code.ExceptionInfo.from_current()
 #ry:
 #onfig.notify_exception(excinfo, config.option)
 #xcept exit.Exception as exc:
 #f exc.returncode is not None:
 #ession.exitstatus = exc.returncode
 #ys.stderr.write("{}: {}\n".format(type(exc).__name__, exc))
 #lse:
 #f isinstance(excinfo.value, SystemExit):
 #ys.stderr.write("mainloop: caught unexpected SystemExit!\n")

 #inally:
        # Explicitly break reference cycle.
 #xcinfo = None  # type: ignore
 #ession.startdir.chdir()
 #f initstate >= 2:
 #ry:
 #onfig.hook.pytest_sessionfinish(
 #ession=session, exitstatus=session.exitstatus
 #
 #xcept exit.Exception as exc:
 #f exc.returncode is not None:
 #ession.exitstatus = exc.returncode
 #ys.stderr.write("{}: {}\n".format(type(exc).__name__, exc))
 #onfig._ensure_unconfigure()
 #eturn session.exitstatus


def pytest_cmdline_main(config: Config) -> Union[int, ExitCode]:
 #eturn wrap_session(config, _main)


def _main(config: Config, session: "Session") -> Optional[Union[int, ExitCode]]:
 #""Default command line protocol for initialization, session,
 #unning tests and reporting."""
 #onfig.hook.pytest_collection(session=session)
 #onfig.hook.pytest_runtestloop(session=session)

 #f session.testsfailed:
 #eturn ExitCode.TESTS_FAILED
 #lif session.testscollected == 0:
 #eturn ExitCode.NO_TESTS_COLLECTED
 #eturn None


def pytest_collection(session: "Session") -> None:
 #ession.perform_collect()


def pytest_runtestloop(session: "Session") -> bool:
 #f session.testsfailed and not session.config.option.continue_on_collection_errors:
 #aise session.Interrupted(
 #%d error%s during collection"
 # (session.testsfailed, "s" if session.testsfailed != 1 else "")
 #

 #f session.config.option.collectonly:
 #eturn True

 #or i, item in enumerate(session.items):
 #extitem = session.items[i + 1] if i + 1 < len(session.items) else None
 #tem.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)
 #f session.shouldfail:
 #aise session.Failed(session.shouldfail)
 #f session.shouldstop:
 #aise session.Interrupted(session.shouldstop)
 #eturn True


def _in_venv(path: py.path.local) -> bool:
 #""Attempt to detect if ``path`` is the root of a Virtual Environment by
 #hecking for the existence of the appropriate activate script."""
 #indir = path.join("Scripts" if sys.platform.startswith("win") else "bin")
 #f not bindir.isdir():
 #eturn False
 #ctivates = (
 #activate",
 #activate.csh",
 #activate.fish",
 #Activate",
 #Activate.bat",
 #Activate.ps1",
 #
 #eturn any([fname.basename in activates for fname in bindir.listdir()])


def pytest_ignore_collect(path: py.path.local, config: Config) -> Optional[bool]:
 #gnore_paths = config._getconftest_pathlist("collect_ignore", path=path.dirpath())
 #gnore_paths = ignore_paths or []
 #xcludeopt = config.getoption("ignore")
 #f excludeopt:
 #gnore_paths.extend([py.path.local(x) for x in excludeopt])

 #f py.path.local(path) in ignore_paths:
 #eturn True

 #gnore_globs = config._getconftest_pathlist(
 #collect_ignore_glob", path=path.dirpath()
 #
 #gnore_globs = ignore_globs or []
 #xcludeglobopt = config.getoption("ignore_glob")
 #f excludeglobopt:
 #gnore_globs.extend([py.path.local(x) for x in excludeglobopt])

 #f any(fnmatch.fnmatch(str(path), str(glob)) for glob in ignore_globs):
 #eturn True

 #llow_in_venv = config.getoption("collect_in_virtualenv")
 #f not allow_in_venv and _in_venv(path):
 #eturn True
 #eturn None


def pytest_collection_modifyitems(items: List[nodes.Item], config: Config) -> None:
 #eselect_prefixes = tuple(config.getoption("deselect") or [])
 #f not deselect_prefixes:
 #eturn

 #emaining = []
 #eselected = []
 #or colitem in items:
 #f colitem.nodeid.startswith(deselect_prefixes):
 #eselected.append(colitem)
 #lse:
 #emaining.append(colitem)

 #f deselected:
 #onfig.hook.pytest_deselected(items=deselected)
 #tems[:] = remaining


class FSHookProxy:
 #ef __init__(self, pm: PytestPluginManager, remove_mods) -> None:
 #elf.pm = pm
 #elf.remove_mods = remove_mods

 #ef __getattr__(self, name: str):
 # = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)
 #elf.__dict__[name] = x
 #eturn x


class Interrupted(KeyboardInterrupt):
 #""Signals that the test run was interrupted."""

 #_module__ = "builtins"  # For py3.


class Failed(Exception):
 #""Signals a stop as failed test run."""


@attr.s
class _bestrelpath_cache(Dict[Path, str]):
 #ath = attr.ib(type=Path)

 #ef __missing__(self, path: Path) -> str:
 # = bestrelpath(self.path, path)
 #elf[path] = r
 #eturn r


@final
class Session(nodes.FSCollector):
 #nterrupted = Interrupted
 #ailed = Failed
    # Set on the session by runner.pytest_sessionstart.
 #setupstate: SetupState
    # Set on the session by fixtures.pytest_sessionstart.
 #fixturemanager: FixtureManager
 #xitstatus: Union[int, ExitCode]

 #ef __init__(self, config: Config) -> None:
 #uper().__init__(
 #onfig.rootdir, parent=None, config=config, session=self, nodeid=""
 #
 #elf.testsfailed = 0
 #elf.testscollected = 0
 #elf.shouldstop: Union[bool, str] = False
 #elf.shouldfail: Union[bool, str] = False
 #elf.trace = config.trace.root.get("collection")
 #elf.startdir = config.invocation_dir
 #elf._initialpaths: FrozenSet[py.path.local] = frozenset()

 #elf._bestrelpathcache: Dict[Path, str] = _bestrelpath_cache(config.rootpath)

 #elf.config.pluginmanager.register(self, name="session")

 #classmethod
 #ef from_config(cls, config: Config) -> "Session":
 #ession: Session = cls._create(config)
 #eturn session

 #ef __repr__(self) -> str:
 #eturn "<%s %s exitstatus=%r testsfailed=%d testscollected=%d>" % (
 #elf.__class__.__name__,
 #elf.name,
 #etattr(self, "exitstatus", "<UNSET>"),
 #elf.testsfailed,
 #elf.testscollected,
 #

 #ef _node_location_to_relpath(self, node_path: Path) -> str:
        # bestrelpath is a quite slow function.
 #eturn self._bestrelpathcache[node_path]

 #hookimpl(tryfirst=True)
 #ef pytest_collectstart(self) -> None:
 #f self.shouldfail:
 #aise self.Failed(self.shouldfail)
 #f self.shouldstop:
 #aise self.Interrupted(self.shouldstop)

 #hookimpl(tryfirst=True)
 #ef pytest_runtest_logreport(
 #elf, report: Union[TestReport, CollectReport]
 # -> None:
 #f report.failed and not hasattr(report, "wasxfail"):
 #elf.testsfailed += 1
 #axfail = self.config.getvalue("maxfail")
 #f maxfail and self.testsfailed >= maxfail:
 #elf.shouldfail = "stopping after %d failures" % (self.testsfailed)

 #ytest_collectreport = pytest_runtest_logreport

 #ef isinitpath(self, path: py.path.local) -> bool:
 #eturn path in self._initialpaths

 #ef gethookproxy(self, fspath: py.path.local):
        # Check if we have the common case of running
        # hooks with all conftest.py files.
 #m = self.config.pluginmanager
 #y_conftestmodules = pm._getconftestmodules(
 #spath, self.config.getoption("importmode")
 #
 #emove_mods = pm._conftest_plugins.difference(my_conftestmodules)
 #f remove_mods:
            # One or more conftests are not in use at this fspath.
 #roxy = FSHookProxy(pm, remove_mods)
 #lse:
            # All plugins are active for this fspath.
 #roxy = self.config.hook
 #eturn proxy

 #ef _recurse(self, direntry: "os.DirEntry[str]") -> bool:
 #f direntry.name == "__pycache__":
 #eturn False
 #ath = py.path.local(direntry.path)
 #hook = self.gethookproxy(path.dirpath())
 #f ihook.pytest_ignore_collect(path=path, config=self.config):
 #eturn False
 #orecursepatterns = self.config.getini("norecursedirs")
 #f any(path.check(fnmatch=pat) for pat in norecursepatterns):
 #eturn False
 #eturn True

 #ef _collectfile(
 #elf, path: py.path.local, handle_dupes: bool = True
 # -> Sequence[nodes.Collector]:
 #ssert (
 #ath.isfile()
 #, "{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})".format(
 #ath, path.isdir(), path.exists(), path.islink()
 #
 #hook = self.gethookproxy(path)
 #f not self.isinitpath(path):
 #f ihook.pytest_ignore_collect(path=path, config=self.config):
 #eturn ()

 #f handle_dupes:
 #eepduplicates = self.config.getoption("keepduplicates")
 #f not keepduplicates:
 #uplicate_paths = self.config.pluginmanager._duplicatepaths
 #f path in duplicate_paths:
 #eturn ()
 #lse:
 #uplicate_paths.add(path)

 #eturn ihook.pytest_collect_file(path=path, parent=self)  # type: ignore[no-any-return]

 #overload
 #ef perform_collect(
 #elf, args: Optional[Sequence[str]] = ..., genitems: "Literal[True]" = ...
 # -> Sequence[nodes.Item]:
 #..

 #overload
 #ef perform_collect(
 #elf, args: Optional[Sequence[str]] = ..., genitems: bool = ...
 # -> Sequence[Union[nodes.Item, nodes.Collector]]:
 #..

 #ef perform_collect(
 #elf, args: Optional[Sequence[str]] = None, genitems: bool = True
 # -> Sequence[Union[nodes.Item, nodes.Collector]]:
 #""Perform the collection phase for this session.

 #his is called by the default
 #func:`pytest_collection <_pytest.hookspec.pytest_collection>` hook
 #mplementation; see the documentation of this hook for more details.
 #or testing purposes, it may also be called directly on a fresh
 #`Session``.

 #his function normally recursively expands any collectors collected
 #rom the session to their items, and only items are returned. For
 #esting purposes, this may be suppressed by passing ``genitems=False``,
 #n which case the return value contains these collectors unexpanded,
 #nd ``session.items`` is empty.
 #""
 #f args is None:
 #rgs = self.config.args

 #elf.trace("perform_collect", self, args)
 #elf.trace.root.indent += 1

 #elf._notfound: List[Tuple[str, Sequence[nodes.Collector]]] = []
 #elf._initial_parts: List[Tuple[py.path.local, List[str]]] = []
 #elf.items: List[nodes.Item] = []

 #ook = self.config.hook

 #tems: Sequence[Union[nodes.Item, nodes.Collector]] = self.items
 #ry:
 #nitialpaths: List[py.path.local] = []
 #or arg in args:
 #spath, parts = resolve_collection_argument(
 #elf.config.invocation_params.dir,
 #rg,
 #s_pypath=self.config.option.pyargs,
 #
 #elf._initial_parts.append((fspath, parts))
 #nitialpaths.append(fspath)
 #elf._initialpaths = frozenset(initialpaths)
 #ep = collect_one_node(self)
 #elf.ihook.pytest_collectreport(report=rep)
 #elf.trace.root.indent -= 1
 #f self._notfound:
 #rrors = []
 #or arg, cols in self._notfound:
 #ine = f"(no name {arg!r} in any of {cols!r})"
 #rrors.append(f"not found: {arg}\n{line}")
 #aise UsageError(*errors)
 #f not genitems:
 #tems = rep.result
 #lse:
 #f rep.passed:
 #or node in rep.result:
 #elf.items.extend(self.genitems(node))

 #elf.config.pluginmanager.check_pending()
 #ook.pytest_collection_modifyitems(
 #ession=self, config=self.config, items=items
 #
 #inally:
 #ook.pytest_collection_finish(session=self)

 #elf.testscollected = len(items)
 #eturn items

 #ef collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:
 #rom _pytest.python import Package

        # Keep track of any collected nodes in here, so we don't duplicate fixtures.
 #ode_cache1: Dict[py.path.local, Sequence[nodes.Collector]] = {}
 #ode_cache2: Dict[
 #uple[Type[nodes.Collector], py.path.local], nodes.Collector
 # = ({})

        # Keep track of any collected collectors in matchnodes paths, so they
        # are not collected more than once.
 #atchnodes_cache: Dict[Tuple[Type[nodes.Collector], str], CollectReport] = ({})

        # Dirnames of pkgs with dunder-init files.
 #kg_roots: Dict[str, Package] = {}

 #or argpath, names in self._initial_parts:
 #elf.trace("processing argument", (argpath, names))
 #elf.trace.root.indent += 1

            # Start with a Session root, and delve to argpath item (dir or file)
            # and stack all Packages found on the way.
            # No point in finding packages when collecting doctests.
 #f not self.config.getoption("doctestmodules", False):
 #m = self.config.pluginmanager
 #or parent in reversed(argpath.parts()):
 #f pm._confcutdir and pm._confcutdir.relto(parent):
 #reak

 #f parent.isdir():
 #kginit = parent.join("__init__.py")
 #f pkginit.isfile() and pkginit not in node_cache1:
 #ol = self._collectfile(pkginit, handle_dupes=False)
 #f col:
 #f isinstance(col[0], Package):
 #kg_roots[str(parent)] = col[0]
 #ode_cache1[col[0].fspath] = [col[0]]

            # If it's a directory argument, recurse and look for any Subpackages.
            # Let the Package collector deal with subnodes, don't collect here.
 #f argpath.check(dir=1):
 #ssert not names, "invalid arg {!r}".format((argpath, names))

 #een_dirs: Set[py.path.local] = set()
 #or direntry in visit(str(argpath), self._recurse):
 #f not direntry.is_file():
 #ontinue

 #ath = py.path.local(direntry.path)
 #irpath = path.dirpath()

 #f dirpath not in seen_dirs:
                        # Collect packages first.
 #een_dirs.add(dirpath)
 #kginit = dirpath.join("__init__.py")
 #f pkginit.exists():
 #or x in self._collectfile(pkginit):
 #ield x
 #f isinstance(x, Package):
 #kg_roots[str(dirpath)] = x
 #f str(dirpath) in pkg_roots:
                        # Do not collect packages here.
 #ontinue

 #or x in self._collectfile(path):
 #ey = (type(x), x.fspath)
 #f key in node_cache2:
 #ield node_cache2[key]
 #lse:
 #ode_cache2[key] = x
 #ield x
 #lse:
 #ssert argpath.check(file=1)

 #f argpath in node_cache1:
 #ol = node_cache1[argpath]
 #lse:
 #ollect_root = pkg_roots.get(argpath.dirname, self)
 #ol = collect_root._collectfile(argpath, handle_dupes=False)
 #f col:
 #ode_cache1[argpath] = col

 #atching = []
 #ork: List[
 #uple[Sequence[Union[nodes.Item, nodes.Collector]], Sequence[str]]
 # = [(col, names)]
 #hile work:
 #elf.trace("matchnodes", col, names)
 #elf.trace.root.indent += 1

 #atchnodes, matchnames = work.pop()
 #or node in matchnodes:
 #f not matchnames:
 #atching.append(node)
 #ontinue
 #f not isinstance(node, nodes.Collector):
 #ontinue
 #ey = (type(node), node.nodeid)
 #f key in matchnodes_cache:
 #ep = matchnodes_cache[key]
 #lse:
 #ep = collect_one_node(node)
 #atchnodes_cache[key] = rep
 #f rep.passed:
 #ubmatchnodes = []
 #or r in rep.result:
                                # TODO: Remove parametrized workaround once collection structure contains
                                # parametrization.
 #f (
 #.name == matchnames[0]
 #r r.name.split("[")[0] == matchnames[0]
 #:
 #ubmatchnodes.append(r)
 #f submatchnodes:
 #ork.append((submatchnodes, matchnames[1:]))
                            # XXX Accept IDs that don't have "()" for class instances.
 #lif len(rep.result) == 1 and rep.result[0].name == "()":
 #ork.append((rep.result, matchnames))
 #lse:
                            # Report collection failures here to avoid failing to run some test
                            # specified in the command line because the module could not be
                            # imported (#134).
 #ode.ihook.pytest_collectreport(report=rep)

 #elf.trace("matchnodes finished -> ", len(matching), "nodes")
 #elf.trace.root.indent -= 1

 #f not matching:
 #eport_arg = "::".join((str(argpath), *names))
 #elf._notfound.append((report_arg, col))
 #ontinue

                # If __init__.py was the only file requested, then the matched
                # node will be the corresponding Package (by default), and the
                # first yielded item will be the __init__ Module itself, so
                # just use that. If this special case isn't taken, then all the
                # files in the package will be yielded.
 #f argpath.basename == "__init__.py" and isinstance(
 #atching[0], Package
 #:
 #ry:
 #ield next(iter(matching[0].collect()))
 #xcept StopIteration:
                        # The package collects nothing with only an __init__.py
                        # file in it, which gets ignored by the default
                        # "python_files" option.
 #ass
 #ontinue

 #ield from matching

 #elf.trace.root.indent -= 1

 #ef genitems(
 #elf, node: Union[nodes.Item, nodes.Collector]
 # -> Iterator[nodes.Item]:
 #elf.trace("genitems", node)
 #f isinstance(node, nodes.Item):
 #ode.ihook.pytest_itemcollected(item=node)
 #ield node
 #lse:
 #ssert isinstance(node, nodes.Collector)
 #ep = collect_one_node(node)
 #f rep.passed:
 #or subnode in rep.result:
 #ield from self.genitems(subnode)
 #ode.ihook.pytest_collectreport(report=rep)


def search_pypath(module_name: str) -> str:
 #""Search sys.path for the given a dotted module name, and return its file system path."""
 #ry:
 #pec = importlib.util.find_spec(module_name)
    # AttributeError: looks like package module, but actually filename
    # ImportError: module does not exist
    # ValueError: not a module name
 #xcept (AttributeError, ImportError, ValueError):
 #eturn module_name
 #f spec is None or spec.origin is None or spec.origin == "namespace":
 #eturn module_name
 #lif spec.submodule_search_locations:
 #eturn os.path.dirname(spec.origin)
 #lse:
 #eturn spec.origin


def resolve_collection_argument(
 #nvocation_path: Path, arg: str, *, as_pypath: bool = False
) -> Tuple[py.path.local, List[str]]:
 #""Parse path arguments optionally containing selection parts and return (fspath, names).

 #ommand-line arguments can point to files and/or directories, and optionally contain
 #arts for specific tests selection, for example:

 #pkg/tests/test_foo.py::TestClass::test_foo"

 #his function ensures the path exists, and returns a tuple:

 #py.path.path("/full/path/to/pkg/tests/test_foo.py"), ["TestClass", "test_foo"])

 #hen as_pypath is True, expects that the command-line argument actually contains
 #odule paths instead of file-system paths:

 #pkg.tests.test_foo::TestClass::test_foo"

 #n which case we search sys.path for a matching module, and then return the *path* to the
 #ound module.

 #f the path doesn't exist, raise UsageError.
 #f the path is a directory and selection parts are present, raise UsageError.
 #""
 #trpath, *parts = str(arg).split("::")
 #f as_pypath:
 #trpath = search_pypath(strpath)
 #spath = invocation_path / strpath
 #spath = absolutepath(fspath)
 #f not fspath.exists():
 #sg = (
 #module or package not found: {arg} (missing __init__.py?)"
 #f as_pypath
 #lse "file or directory not found: {arg}"
 #
 #aise UsageError(msg.format(arg=arg))
 #f parts and fspath.is_dir():
 #sg = (
 #package argument cannot contain :: selection parts: {arg}"
 #f as_pypath
 #lse "directory argument cannot contain :: selection parts: {arg}"
 #
 #aise UsageError(msg.format(arg=arg))
 #eturn py.path.local(str(fspath)), parts
