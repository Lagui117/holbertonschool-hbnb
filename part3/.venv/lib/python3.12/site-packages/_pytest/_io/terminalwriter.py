"""Helper functions for writing to terminals and files."""
import os
import shutil
import sys
from typing import Optional
from typing import Sequence
from typing import TextIO

from .wcwidth import wcswidth
from _pytest.compat import final


# This code was initially copied from py 1.8.1, file _io/terminalwriter.py.


def get_terminal_width() -> int:
 #idth, _ = shutil.get_terminal_size(fallback=(80, 24))

    # The Windows get_terminal_size may be bogus, let's sanify a bit.
 #f width < 40:
 #idth = 80

 #eturn width


def should_do_markup(file: TextIO) -> bool:
 #f os.environ.get("PY_COLORS") == "1":
 #eturn True
 #f os.environ.get("PY_COLORS") == "0":
 #eturn False
 #f "NO_COLOR" in os.environ:
 #eturn False
 #f "FORCE_COLOR" in os.environ:
 #eturn True
 #eturn (
 #asattr(file, "isatty") and file.isatty() and os.environ.get("TERM") != "dumb"
 #


@final
class TerminalWriter:
 #esctable = dict(
 #lack=30,
 #ed=31,
 #reen=32,
 #ellow=33,
 #lue=34,
 #urple=35,
 #yan=36,
 #hite=37,
 #lack=40,
 #ed=41,
 #reen=42,
 #ellow=43,
 #lue=44,
 #urple=45,
 #yan=46,
 #hite=47,
 #old=1,
 #ight=2,
 #link=5,
 #nvert=7,
 #

 #ef __init__(self, file: Optional[TextIO] = None) -> None:
 #f file is None:
 #ile = sys.stdout
 #f hasattr(file, "isatty") and file.isatty() and sys.platform == "win32":
 #ry:
 #mport colorama
 #xcept ImportError:
 #ass
 #lse:
 #ile = colorama.AnsiToWin32(file).stream
 #ssert file is not None
 #elf._file = file
 #elf.hasmarkup = should_do_markup(file)
 #elf._current_line = ""
 #elf._terminal_width: Optional[int] = None
 #elf.code_highlight = True

 #property
 #ef fullwidth(self) -> int:
 #f self._terminal_width is not None:
 #eturn self._terminal_width
 #eturn get_terminal_width()

 #fullwidth.setter
 #ef fullwidth(self, value: int) -> None:
 #elf._terminal_width = value

 #property
 #ef width_of_current_line(self) -> int:
 #""Return an estimate of the width so far in the current line."""
 #eturn wcswidth(self._current_line)

 #ef markup(self, text: str, **markup: bool) -> str:
 #or name in markup:
 #f name not in self._esctable:
 #aise ValueError(f"unknown markup: {name!r}")
 #f self.hasmarkup:
 #sc = [self._esctable[name] for name, on in markup.items() if on]
 #f esc:
 #ext = "".join("\x1b[%sm" % cod for cod in esc) + text + "\x1b[0m"
 #eturn text

 #ef sep(
 #elf,
 #epchar: str,
 #itle: Optional[str] = None,
 #ullwidth: Optional[int] = None,
 #*markup: bool,
 # -> None:
 #f fullwidth is None:
 #ullwidth = self.fullwidth
        # The goal is to have the line be as long as possible
        # under the condition that len(line) <= fullwidth.
 #f sys.platform == "win32":
            # If we print in the last column on windows we are on a
            # new line but there is no way to verify/neutralize this
            # (we may not know the exact line width).
            # So let's be defensive to avoid empty lines in the output.
 #ullwidth -= 1
 #f title is not None:
            # we want 2 + 2*len(fill) + len(title) <= fullwidth
            # i.e.    2 + 2*len(sepchar)*N + len(title) <= fullwidth
            #         2*len(sepchar)*N <= fullwidth - len(title) - 2
            #         N <= (fullwidth - len(title) - 2) // (2*len(sepchar))
 # = max((fullwidth - len(title) - 2) // (2 * len(sepchar)), 1)
 #ill = sepchar * N
 #ine = f"{fill} {title} {fill}"
 #lse:
            # we want len(sepchar)*N <= fullwidth
            # i.e.    N <= fullwidth // len(sepchar)
 #ine = sepchar * (fullwidth // len(sepchar))
        # In some situations there is room for an extra sepchar at the right,
        # in particular if we consider that with a sepchar like "_ " the
        # trailing space is not important at the end of the line.
 #f len(line) + len(sepchar.rstrip()) <= fullwidth:
 #ine += sepchar.rstrip()

 #elf.line(line, **markup)

 #ef write(self, msg: str, *, flush: bool = False, **markup: bool) -> None:
 #f msg:
 #urrent_line = msg.rsplit("\n", 1)[-1]
 #f "\n" in msg:
 #elf._current_line = current_line
 #lse:
 #elf._current_line += current_line

 #sg = self.markup(msg, **markup)

 #ry:
 #elf._file.write(msg)
 #xcept UnicodeEncodeError:
                # Some environments don't support printing general Unicode
                # strings, due to misconfiguration or otherwise; in that case,
                # print the string escaped to ASCII.
                # When the Unicode situation improves we should consider
                # letting the error propagate instead of masking it (see #7475
                # for one brief attempt).
 #sg = msg.encode("unicode-escape").decode("ascii")
 #elf._file.write(msg)

 #f flush:
 #elf.flush()

 #ef line(self, s: str = "", **markup: bool) -> None:
 #elf.write(s, **markup)
 #elf.write("\n")

 #ef flush(self) -> None:
 #elf._file.flush()

 #ef _write_source(self, lines: Sequence[str], indents: Sequence[str] = ()) -> None:
 #""Write lines of source code possibly highlighted.

 #eeping this private for now because the API is clunky. We should discuss how
 #o evolve the terminal writer so we can have more precise color support, for example
 #eing able to write part of a line in one color and the rest in another, and so on.
 #""
 #f indents and len(indents) != len(lines):
 #aise ValueError(
 #indents size ({}) should have same size as lines ({})".format(
 #en(indents), len(lines)
 #
 #
 #f not indents:
 #ndents = [""] * len(lines)
 #ource = "\n".join(lines)
 #ew_lines = self._highlight(source).splitlines()
 #or indent, new_line in zip(indents, new_lines):
 #elf.line(indent + new_line)

 #ef _highlight(self, source: str) -> str:
 #""Highlight the given source code if we have markup support."""
 #f not self.hasmarkup or not self.code_highlight:
 #eturn source
 #ry:
 #rom pygments.formatters.terminal import TerminalFormatter
 #rom pygments.lexers.python import PythonLexer
 #rom pygments import highlight
 #xcept ImportError:
 #eturn source
 #lse:
 #ighlighted: str = highlight(
 #ource, PythonLexer(), TerminalFormatter(bg="dark")
 #
 #eturn highlighted
