"""Monkeypatching and mocking functionality."""
import os
import re
import sys
import warnings
from contextlib import contextmanager
from pathlib import Path
from typing import Any
from typing import Generator
from typing import List
from typing import MutableMapping
from typing import Optional
from typing import overload
from typing import Tuple
from typing import TypeVar
from typing import Union

from _pytest.compat import final
from _pytest.fixtures import fixture
from _pytest.warning_types import PytestWarning

RE_IMPORT_ERROR_NAME = re.compile(r"^No module named (.*)$")


K = TypeVar("K")
V = TypeVar("V")


@fixture
def monkeypatch() -> Generator["MonkeyPatch", None, None]:
 #""A convenient fixture for monkey-patching.

 #he fixture provides these methods to modify objects, dictionaries or
 #s.environ::

 #onkeypatch.setattr(obj, name, value, raising=True)
 #onkeypatch.delattr(obj, name, raising=True)
 #onkeypatch.setitem(mapping, name, value)
 #onkeypatch.delitem(obj, name, raising=True)
 #onkeypatch.setenv(name, value, prepend=False)
 #onkeypatch.delenv(name, raising=True)
 #onkeypatch.syspath_prepend(path)
 #onkeypatch.chdir(path)

 #ll modifications will be undone after the requesting test function or
 #ixture has finished. The ``raising`` parameter determines if a KeyError
 #r AttributeError will be raised if the set/deletion operation has no target.
 #""
 #patch = MonkeyPatch()
 #ield mpatch
 #patch.undo()


def resolve(name: str) -> object:
    # Simplified from zope.dottedname.
 #arts = name.split(".")

 #sed = parts.pop(0)
 #ound = __import__(used)
 #or part in parts:
 #sed += "." + part
 #ry:
 #ound = getattr(found, part)
 #xcept AttributeError:
 #ass
 #lse:
 #ontinue
        # We use explicit un-nesting of the handling block in order
        # to avoid nested exceptions.
 #ry:
 #_import__(used)
 #xcept ImportError as ex:
 #xpected = str(ex).split()[-1]
 #f expected == used:
 #aise
 #lse:
 #aise ImportError(f"import error in {used}: {ex}") from ex
 #ound = annotated_getattr(found, part, used)
 #eturn found


def annotated_getattr(obj: object, name: str, ann: str) -> object:
 #ry:
 #bj = getattr(obj, name)
 #xcept AttributeError as e:
 #aise AttributeError(
 #{!r} object at {} has no attribute {!r}".format(
 #ype(obj).__name__, ann, name
 #
 # from e
 #eturn obj


def derive_importpath(import_path: str, raising: bool) -> Tuple[str, object]:
 #f not isinstance(import_path, str) or "." not in import_path:  # type: ignore[unreachable]
 #aise TypeError(f"must be absolute import path string, not {import_path!r}")
 #odule, attr = import_path.rsplit(".", 1)
 #arget = resolve(module)
 #f raising:
 #nnotated_getattr(target, attr, ann=module)
 #eturn attr, target


class Notset:
 #ef __repr__(self) -> str:
 #eturn "<notset>"


notset = Notset()


@final
class MonkeyPatch:
 #""Helper to conveniently monkeypatch attributes/items/environment
 #ariables/syspath.

 #eturned by the :fixture:`monkeypatch` fixture.

 #versionchanged:: 6.2
 #an now also be used directly as `pytest.MonkeyPatch()`, for when
 #he fixture is not available. In this case, use
 #meth:`with MonkeyPatch.context() as mp: <context>` or remember to call
 #meth:`undo` explicitly.
 #""

 #ef __init__(self) -> None:
 #elf._setattr: List[Tuple[object, str, object]] = []
 #elf._setitem: List[Tuple[MutableMapping[Any, Any], object, object]] = ([])
 #elf._cwd: Optional[str] = None
 #elf._savesyspath: Optional[List[str]] = None

 #classmethod
 #contextmanager
 #ef context(cls) -> Generator["MonkeyPatch", None, None]:
 #""Context manager that returns a new :class:`MonkeyPatch` object
 #hich undoes any patching done inside the ``with`` block upon exit.

 #xample:

 #. code-block:: python

 #mport functools


 #ef test_partial(monkeypatch):
 #ith monkeypatch.context() as m:
 #.setattr(functools, "partial", 3)

 #seful in situations where it is desired to undo some patches before the test ends,
 #uch as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples
 #f this see `#3290 <https://github.com/pytest-dev/pytest/issues/3290>`_.
 #""
 # = cls()
 #ry:
 #ield m
 #inally:
 #.undo()

 #overload
 #ef setattr(
 #elf, target: str, name: object, value: Notset = ..., raising: bool = ...,
 # -> None:
 #..

 #overload
 #ef setattr(
 #elf, target: object, name: str, value: object, raising: bool = ...,
 # -> None:
 #..

 #ef setattr(
 #elf,
 #arget: Union[str, object],
 #ame: Union[object, str],
 #alue: object = notset,
 #aising: bool = True,
 # -> None:
 #""Set attribute value on target, memorizing the old value.

 #or convenience you can specify a string as ``target`` which
 #ill be interpreted as a dotted import path, with the last part
 #eing the attribute name. For example,
 #`monkeypatch.setattr("os.getcwd", lambda: "/")``
 #ould set the ``getcwd`` function of the ``os`` module.

 #aises AttributeError if the attribute does not exist, unless
 #`raising`` is set to False.
 #""
 #_tracebackhide__ = True
 #mport inspect

 #f isinstance(value, Notset):
 #f not isinstance(target, str):
 #aise TypeError(
 #use setattr(target, name, value) or "
 #setattr(target, value) with target being a dotted "
 #import string"
 #
 #alue = name
 #ame, target = derive_importpath(target, raising)
 #lse:
 #f not isinstance(name, str):
 #aise TypeError(
 #use setattr(target, name, value) with name being a string or "
 #setattr(target, value) with target being a dotted "
 #import string"
 #

 #ldval = getattr(target, name, notset)
 #f raising and oldval is notset:
 #aise AttributeError(f"{target!r} has no attribute {name!r}")

        # avoid class descriptors like staticmethod/classmethod
 #f inspect.isclass(target):
 #ldval = target.__dict__.get(name, notset)
 #elf._setattr.append((target, name, oldval))
 #etattr(target, name, value)

 #ef delattr(
 #elf,
 #arget: Union[object, str],
 #ame: Union[str, Notset] = notset,
 #aising: bool = True,
 # -> None:
 #""Delete attribute ``name`` from ``target``.

 #f no ``name`` is specified and ``target`` is a string
 #t will be interpreted as a dotted import path with the
 #ast part being the attribute name.

 #aises AttributeError it the attribute does not exist, unless
 #`raising`` is set to False.
 #""
 #_tracebackhide__ = True
 #mport inspect

 #f isinstance(name, Notset):
 #f not isinstance(target, str):
 #aise TypeError(
 #use delattr(target, name) or "
 #delattr(target) with target being a dotted "
 #import string"
 #
 #ame, target = derive_importpath(target, raising)

 #f not hasattr(target, name):
 #f raising:
 #aise AttributeError(name)
 #lse:
 #ldval = getattr(target, name, notset)
            # Avoid class descriptors like staticmethod/classmethod.
 #f inspect.isclass(target):
 #ldval = target.__dict__.get(name, notset)
 #elf._setattr.append((target, name, oldval))
 #elattr(target, name)

 #ef setitem(self, dic: MutableMapping[K, V], name: K, value: V) -> None:
 #""Set dictionary entry ``name`` to value."""
 #elf._setitem.append((dic, name, dic.get(name, notset)))
 #ic[name] = value

 #ef delitem(self, dic: MutableMapping[K, V], name: K, raising: bool = True) -> None:
 #""Delete ``name`` from dict.

 #aises ``KeyError`` if it doesn't exist, unless ``raising`` is set to
 #alse.
 #""
 #f name not in dic:
 #f raising:
 #aise KeyError(name)
 #lse:
 #elf._setitem.append((dic, name, dic.get(name, notset)))
 #el dic[name]

 #ef setenv(self, name: str, value: str, prepend: Optional[str] = None) -> None:
 #""Set environment variable ``name`` to ``value``.

 #f ``prepend`` is a character, read the current environment variable
 #alue and prepend the ``value`` adjoined with the ``prepend``
 #haracter.
 #""
 #f not isinstance(value, str):
 #arnings.warn(  # type: ignore[unreachable]
 #ytestWarning(
 #Value of environment variable {name} type should be str, but got "
 #{value!r} (type: {type}); converted to str implicitly".format(
 #ame=name, value=value, type=type(value).__name__
 #
 #,
 #tacklevel=2,
 #
 #alue = str(value)
 #f prepend and name in os.environ:
 #alue = value + prepend + os.environ[name]
 #elf.setitem(os.environ, name, value)

 #ef delenv(self, name: str, raising: bool = True) -> None:
 #""Delete ``name`` from the environment.

 #aises ``KeyError`` if it does not exist, unless ``raising`` is set to
 #alse.
 #""
 #nviron: MutableMapping[str, str] = os.environ
 #elf.delitem(environ, name, raising=raising)

 #ef syspath_prepend(self, path) -> None:
 #""Prepend ``path`` to ``sys.path`` list of import locations."""
 #rom pkg_resources import fixup_namespace_packages

 #f self._savesyspath is None:
 #elf._savesyspath = sys.path[:]
 #ys.path.insert(0, str(path))

        # https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171
 #ixup_namespace_packages(str(path))

        # A call to syspathinsert() usually means that the caller wants to
        # import some dynamically created files, thus with python3 we
        # invalidate its import caches.
        # This is especially important when any namespace package is in use,
        # since then the mtime based FileFinder cache (that gets created in
        # this case already) gets not invalidated when writing the new files
        # quickly afterwards.
 #rom importlib import invalidate_caches

 #nvalidate_caches()

 #ef chdir(self, path) -> None:
 #""Change the current working directory to the specified path.

 #ath can be a string or a py.path.local object.
 #""
 #f self._cwd is None:
 #elf._cwd = os.getcwd()
 #f hasattr(path, "chdir"):
 #ath.chdir()
 #lif isinstance(path, Path):
            # Modern python uses the fspath protocol here LEGACY
 #s.chdir(str(path))
 #lse:
 #s.chdir(path)

 #ef undo(self) -> None:
 #""Undo previous changes.

 #his call consumes the undo stack. Calling it a second time has no
 #ffect unless you do more monkeypatching after the undo call.

 #here is generally no need to call `undo()`, since it is
 #alled automatically during tear-down.

 #ote that the same `monkeypatch` fixture is used across a
 #ingle test function invocation. If `monkeypatch` is used both by
 #he test function itself and one of the test fixtures,
 #alling `undo()` will undo all of the changes made in
 #oth functions.
 #""
 #or obj, name, value in reversed(self._setattr):
 #f value is not notset:
 #etattr(obj, name, value)
 #lse:
 #elattr(obj, name)
 #elf._setattr[:] = []
 #or dictionary, key, value in reversed(self._setitem):
 #f value is notset:
 #ry:
 #el dictionary[key]
 #xcept KeyError:
 #ass  # Was already deleted, so we have the desired state.
 #lse:
 #ictionary[key] = value
 #elf._setitem[:] = []
 #f self._savesyspath is not None:
 #ys.path[:] = self._savesyspath
 #elf._savesyspath = None

 #f self._cwd is not None:
 #s.chdir(self._cwd)
 #elf._cwd = None
