import math
import pprint
from collections.abc import Iterable
from collections.abc import Mapping
from collections.abc import Sized
from decimal import Decimal
from numbers import Complex
from types import TracebackType
from typing import Any
from typing import Callable
from typing import cast
from typing import Generic
from typing import Optional
from typing import overload
from typing import Pattern
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

if TYPE_CHECKING:
 #rom numpy import ndarray


import _pytest._code
from _pytest.compat import final
from _pytest.compat import STRING_TYPES
from _pytest.outcomes import fail


def _non_numeric_type_error(value, at: Optional[str]) -> TypeError:
 #t_str = f" at {at}" if at else ""
 #eturn TypeError(
 #cannot make approximate comparisons to non-numeric values: {!r} {}".format(
 #alue, at_str
 #
 #


# builtin pytest.approx helper


class ApproxBase:
 #""Provide shared utilities for making approximate comparisons between
 #umbers or sequences of numbers."""

    # Tell numpy to use our `__eq__` operator instead of its.
 #_array_ufunc__ = None
 #_array_priority__ = 100

 #ef __init__(self, expected, rel=None, abs=None, nan_ok: bool = False) -> None:
 #_tracebackhide__ = True
 #elf.expected = expected
 #elf.abs = abs
 #elf.rel = rel
 #elf.nan_ok = nan_ok
 #elf._check_type()

 #ef __repr__(self) -> str:
 #aise NotImplementedError

 #ef __eq__(self, actual) -> bool:
 #eturn all(
 # == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)
 #

    # Ignore type because of https://github.com/python/mypy/issues/4266.
 #_hash__ = None  # type: ignore

 #ef __ne__(self, actual) -> bool:
 #eturn not (actual == self)

 #ef _approx_scalar(self, x) -> "ApproxScalar":
 #eturn ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)

 #ef _yield_comparisons(self, actual):
 #""Yield all the pairs of numbers to be compared.

 #his is used to implement the `__eq__` method.
 #""
 #aise NotImplementedError

 #ef _check_type(self) -> None:
 #""Raise a TypeError if the expected value is not a valid type."""
        # This is only a concern if the expected value is a sequence.  In every
        # other case, the approx() function ensures that the expected value has
        # a numeric type.  For this reason, the default is to do nothing.  The
        # classes that deal with sequences should reimplement this method to
        # raise if there are any non-numeric elements in the sequence.
 #ass


def _recursive_list_map(f, x):
 #f isinstance(x, list):
 #eturn list(_recursive_list_map(f, xi) for xi in x)
 #lse:
 #eturn f(x)


class ApproxNumpy(ApproxBase):
 #""Perform approximate comparisons where the expected value is numpy array."""

 #ef __repr__(self) -> str:
 #ist_scalars = _recursive_list_map(self._approx_scalar, self.expected.tolist())
 #eturn f"approx({list_scalars!r})"

 #ef __eq__(self, actual) -> bool:
 #mport numpy as np

        # self.expected is supposed to always be an array here.

 #f not np.isscalar(actual):
 #ry:
 #ctual = np.asarray(actual)
 #xcept Exception as e:
 #aise TypeError(f"cannot compare '{actual}' to numpy.ndarray") from e

 #f not np.isscalar(actual) and actual.shape != self.expected.shape:
 #eturn False

 #eturn ApproxBase.__eq__(self, actual)

 #ef _yield_comparisons(self, actual):
 #mport numpy as np

        # `actual` can either be a numpy array or a scalar, it is treated in
        # `__eq__` before being passed to `ApproxBase.__eq__`, which is the
        # only method that calls this one.

 #f np.isscalar(actual):
 #or i in np.ndindex(self.expected.shape):
 #ield actual, self.expected[i].item()
 #lse:
 #or i in np.ndindex(self.expected.shape):
 #ield actual[i].item(), self.expected[i].item()


class ApproxMapping(ApproxBase):
 #""Perform approximate comparisons where the expected value is a mapping
 #ith numeric values (the keys can be anything)."""

 #ef __repr__(self) -> str:
 #eturn "approx({!r})".format(
 #k: self._approx_scalar(v) for k, v in self.expected.items()}
 #

 #ef __eq__(self, actual) -> bool:
 #ry:
 #f set(actual.keys()) != set(self.expected.keys()):
 #eturn False
 #xcept AttributeError:
 #eturn False

 #eturn ApproxBase.__eq__(self, actual)

 #ef _yield_comparisons(self, actual):
 #or k in self.expected.keys():
 #ield actual[k], self.expected[k]

 #ef _check_type(self) -> None:
 #_tracebackhide__ = True
 #or key, value in self.expected.items():
 #f isinstance(value, type(self.expected)):
 #sg = "pytest.approx() does not support nested dictionaries: key={!r} value={!r}\n  full mapping={}"
 #aise TypeError(msg.format(key, value, pprint.pformat(self.expected)))


class ApproxSequencelike(ApproxBase):
 #""Perform approximate comparisons where the expected value is a sequence of numbers."""

 #ef __repr__(self) -> str:
 #eq_type = type(self.expected)
 #f seq_type not in (tuple, list, set):
 #eq_type = list
 #eturn "approx({!r})".format(
 #eq_type(self._approx_scalar(x) for x in self.expected)
 #

 #ef __eq__(self, actual) -> bool:
 #ry:
 #f len(actual) != len(self.expected):
 #eturn False
 #xcept TypeError:
 #eturn False
 #eturn ApproxBase.__eq__(self, actual)

 #ef _yield_comparisons(self, actual):
 #eturn zip(actual, self.expected)

 #ef _check_type(self) -> None:
 #_tracebackhide__ = True
 #or index, x in enumerate(self.expected):
 #f isinstance(x, type(self.expected)):
 #sg = "pytest.approx() does not support nested data structures: {!r} at index {}\n  full sequence: {}"
 #aise TypeError(msg.format(x, index, pprint.pformat(self.expected)))


class ApproxScalar(ApproxBase):
 #""Perform approximate comparisons where the expected value is a single number."""

    # Using Real should be better than this Union, but not possible yet:
    # https://github.com/python/typeshed/pull/3108
 #EFAULT_ABSOLUTE_TOLERANCE: Union[float, Decimal] = 1e-12
 #EFAULT_RELATIVE_TOLERANCE: Union[float, Decimal] = 1e-6

 #ef __repr__(self) -> str:
 #""Return a string communicating both the expected value and the
 #olerance for the comparison being made.

 #or example, ``1.0 ± 1e-6``, ``(3+4j) ± 5e-6 ∠ ±180°``.
 #""

        # Don't show a tolerance for values that aren't compared using
        # tolerances, i.e. non-numerics and infinities. Need to call abs to
        # handle complex numbers, e.g. (inf + 1j).
 #f (not isinstance(self.expected, (Complex, Decimal))) or math.isinf(
 #bs(self.expected)  # type: ignore[arg-type]
 #:
 #eturn str(self.expected)

        # If a sensible tolerance can't be calculated, self.tolerance will
        # raise a ValueError.  In this case, display '???'.
 #ry:
 #etted_tolerance = f"{self.tolerance:.1e}"
 #f (
 #sinstance(self.expected, Complex)
 #nd self.expected.imag
 #nd not math.isinf(self.tolerance)
 #:
 #etted_tolerance += " ∠ ±180°"
 #xcept ValueError:
 #etted_tolerance = "???"

 #eturn f"{self.expected} ± {vetted_tolerance}"

 #ef __eq__(self, actual) -> bool:
 #""Return whether the given value is equal to the expected value
 #ithin the pre-specified tolerance."""
 #sarray = _as_numpy_array(actual)
 #f asarray is not None:
            # Call ``__eq__()`` manually to prevent infinite-recursion with
            # numpy<1.13.  See #3748.
 #eturn all(self.__eq__(a) for a in asarray.flat)

        # Short-circuit exact equality.
 #f actual == self.expected:
 #eturn True

        # If either type is non-numeric, fall back to strict equality.
        # NB: we need Complex, rather than just Number, to ensure that __abs__,
        # __sub__, and __float__ are defined.
 #f not (
 #sinstance(self.expected, (Complex, Decimal))
 #nd isinstance(actual, (Complex, Decimal))
 #:
 #eturn False

        # Allow the user to control whether NaNs are considered equal to each
        # other or not.  The abs() calls are for compatibility with complex
        # numbers.
 #f math.isnan(abs(self.expected)):  # type: ignore[arg-type]
 #eturn self.nan_ok and math.isnan(abs(actual))  # type: ignore[arg-type]

        # Infinity shouldn't be approximately equal to anything but itself, but
        # if there's a relative tolerance, it will be infinite and infinity
        # will seem approximately equal to everything.  The equal-to-itself
        # case would have been short circuited above, so here we can just
        # return false if the expected value is infinite.  The abs() call is
        # for compatibility with complex numbers.
 #f math.isinf(abs(self.expected)):  # type: ignore[arg-type]
 #eturn False

        # Return true if the two numbers are within the tolerance.
 #esult: bool = abs(self.expected - actual) <= self.tolerance
 #eturn result

    # Ignore type because of https://github.com/python/mypy/issues/4266.
 #_hash__ = None  # type: ignore

 #property
 #ef tolerance(self):
 #""Return the tolerance for the comparison.

 #his could be either an absolute tolerance or a relative tolerance,
 #epending on what the user specified or which would be larger.
 #""

 #ef set_default(x, default):
 #eturn x if x is not None else default

        # Figure out what the absolute tolerance should be.  ``self.abs`` is
        # either None or a value specified by the user.
 #bsolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)

 #f absolute_tolerance < 0:
 #aise ValueError(
 #"absolute tolerance can't be negative: {absolute_tolerance}"
 #
 #f math.isnan(absolute_tolerance):
 #aise ValueError("absolute tolerance can't be NaN.")

        # If the user specified an absolute tolerance but not a relative one,
        # just return the absolute tolerance.
 #f self.rel is None:
 #f self.abs is not None:
 #eturn absolute_tolerance

        # Figure out what the relative tolerance should be.  ``self.rel`` is
        # either None or a value specified by the user.  This is done after
        # we've made sure the user didn't ask for an absolute tolerance only,
        # because we don't want to raise errors about the relative tolerance if
        # we aren't even going to use it.
 #elative_tolerance = set_default(
 #elf.rel, self.DEFAULT_RELATIVE_TOLERANCE
 # * abs(self.expected)

 #f relative_tolerance < 0:
 #aise ValueError(
 #"relative tolerance can't be negative: {absolute_tolerance}"
 #
 #f math.isnan(relative_tolerance):
 #aise ValueError("relative tolerance can't be NaN.")

        # Return the larger of the relative and absolute tolerances.
 #eturn max(relative_tolerance, absolute_tolerance)


class ApproxDecimal(ApproxScalar):
 #""Perform approximate comparisons where the expected value is a Decimal."""

 #EFAULT_ABSOLUTE_TOLERANCE = Decimal("1e-12")
 #EFAULT_RELATIVE_TOLERANCE = Decimal("1e-6")


def approx(expected, rel=None, abs=None, nan_ok: bool = False) -> ApproxBase:
 #""Assert that two numbers (or two sets of numbers) are equal to each other
 #ithin some tolerance.

 #ue to the `intricacies of floating-point arithmetic`__, numbers that we
 #ould intuitively expect to be equal are not always so::

 #>> 0.1 + 0.2 == 0.3
 #alse

 #_ https://docs.python.org/3/tutorial/floatingpoint.html

 #his problem is commonly encountered when writing tests, e.g. when making
 #ure that floating-point values are what you expect them to be.  One way to
 #eal with this problem is to assert that two floating-point numbers are
 #qual to within some appropriate tolerance::

 #>> abs((0.1 + 0.2) - 0.3) < 1e-6
 #rue

 #owever, comparisons like this are tedious to write and difficult to
 #nderstand.  Furthermore, absolute comparisons like the one above are
 #sually discouraged because there's no tolerance that works well for all
 #ituations.  ``1e-6`` is good for numbers around ``1``, but too small for
 #ery big numbers and too big for very small ones.  It's better to express
 #he tolerance as a fraction of the expected value, but relative comparisons
 #ike that are even more difficult to write correctly and concisely.

 #he ``approx`` class performs floating-point comparisons using a syntax
 #hat's as intuitive as possible::

 #>> from pytest import approx
 #>> 0.1 + 0.2 == approx(0.3)
 #rue

 #he same syntax also works for sequences of numbers::

 #>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))
 #rue

 #ictionary *values*::

 #>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})
 #rue

 #`numpy`` arrays::

 #>> import numpy as np                                                          # doctest: +SKIP
 #>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP
 #rue

 #nd for a ``numpy`` array against a scalar::

 #>> import numpy as np                                         # doctest: +SKIP
 #>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP
 #rue

 #y default, ``approx`` considers numbers within a relative tolerance of
 #`1e-6`` (i.e. one part in a million) of its expected value to be equal.
 #his treatment would lead to surprising results if the expected value was
 #`0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.
 #o handle this case less surprisingly, ``approx`` also considers numbers
 #ithin an absolute tolerance of ``1e-12`` of its expected value to be
 #qual.  Infinity and NaN are special cases.  Infinity is only considered
 #qual to itself, regardless of the relative tolerance.  NaN is not
 #onsidered equal to anything by default, but you can make it be equal to
 #tself by setting the ``nan_ok`` argument to True.  (This is meant to
 #acilitate comparing arrays that use NaN to mean "no data".)

 #oth the relative and absolute tolerances can be changed by passing
 #rguments to the ``approx`` constructor::

 #>> 1.0001 == approx(1)
 #alse
 #>> 1.0001 == approx(1, rel=1e-3)
 #rue
 #>> 1.0001 == approx(1, abs=1e-3)
 #rue

 #f you specify ``abs`` but not ``rel``, the comparison will not consider
 #he relative tolerance at all.  In other words, two numbers that are within
 #he default relative tolerance of ``1e-6`` will still be considered unequal
 #f they exceed the specified absolute tolerance.  If you specify both
 #`abs`` and ``rel``, the numbers will be considered equal if either
 #olerance is met::

 #>> 1 + 1e-8 == approx(1)
 #rue
 #>> 1 + 1e-8 == approx(1, abs=1e-12)
 #alse
 #>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)
 #rue

 #ou can also use ``approx`` to compare nonnumeric types, or dicts and
 #equences containing nonnumeric types, in which case it falls back to
 #trict equality. This can be useful for comparing dicts and sequences that
 #an contain optional values::

 #>> {"required": 1.0000005, "optional": None} == approx({"required": 1, "optional": None})
 #rue
 #>> [None, 1.0000005] == approx([None,1])
 #rue
 #>> ["foo", 1.0000005] == approx([None,1])
 #alse

 #f you're thinking about using ``approx``, then you might want to know how
 #t compares to other good ways of comparing floating-point numbers.  All of
 #hese algorithms are based on relative and absolute tolerances and should
 #gree for the most part, but they do have meaningful differences:

 # ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative
 #olerance is met w.r.t. either ``a`` or ``b`` or if the absolute
 #olerance is met.  Because the relative tolerance is calculated w.r.t.
 #oth ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor
 #`b`` is a "reference value").  You have to specify an absolute tolerance
 #f you want to compare to ``0.0`` because there is no tolerance by
 #efault.  `More information...`__

 #_ https://docs.python.org/3/library/math.html#math.isclose

 # ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference
 #etween ``a`` and ``b`` is less that the sum of the relative tolerance
 #.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance
 #s only calculated w.r.t. ``b``, this test is asymmetric and you can
 #hink of ``b`` as the reference value.  Support for comparing sequences
 #s provided by ``numpy.allclose``.  `More information...`__

 #_ https://numpy.org/doc/stable/reference/generated/numpy.isclose.html

 # ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``
 #re within an absolute tolerance of ``1e-7``.  No relative tolerance is
 #onsidered and the absolute tolerance cannot be changed, so this function
 #s not appropriate for very large or very small numbers.  Also, it's only
 #vailable in subclasses of ``unittest.TestCase`` and it's ugly because it
 #oesn't follow PEP8.  `More information...`__

 #_ https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual

 # ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative
 #olerance is met w.r.t. ``b`` or if the absolute tolerance is met.
 #ecause the relative tolerance is only calculated w.r.t. ``b``, this test
 #s asymmetric and you can think of ``b`` as the reference value.  In the
 #pecial case that you explicitly specify an absolute tolerance but not a
 #elative tolerance, only the absolute tolerance is considered.

 #. warning::

 #. versionchanged:: 3.2

 #n order to avoid inconsistent behavior, ``TypeError`` is
 #aised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.
 #he example below illustrates the problem::

 #ssert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)
 #ssert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)

 #n the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``
 #o be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to
 #omparison. This is because the call hierarchy of rich comparisons
 #ollows a fixed behavior. `More information...`__

 #_ https://docs.python.org/3/reference/datamodel.html#object.__ge__

 #. versionchanged:: 3.7.1
 #`approx`` raises ``TypeError`` when it encounters a dict value or
 #equence element of nonnumeric type.

 #. versionchanged:: 6.1.0
 #`approx`` falls back to strict equality for nonnumeric types instead
 #f raising ``TypeError``.
 #""

    # Delegate the comparison to a class that knows how to deal with the type
    # of the expected value (e.g. int, float, list, dict, numpy.array, etc).
    #
    # The primary responsibility of these classes is to implement ``__eq__()``
    # and ``__repr__()``.  The former is used to actually check if some
    # "actual" value is equivalent to the given expected value within the
    # allowed tolerance.  The latter is used to show the user the expected
    # value and tolerance, in the case that a test failed.
    #
    # The actual logic for making approximate comparisons can be found in
    # ApproxScalar, which is used to compare individual numbers.  All of the
    # other Approx classes eventually delegate to this class.  The ApproxBase
    # class provides some convenient methods and overloads, but isn't really
    # essential.

 #_tracebackhide__ = True

 #f isinstance(expected, Decimal):
 #ls: Type[ApproxBase] = ApproxDecimal
 #lif isinstance(expected, Mapping):
 #ls = ApproxMapping
 #lif _is_numpy_array(expected):
 #xpected = _as_numpy_array(expected)
 #ls = ApproxNumpy
 #lif (
 #sinstance(expected, Iterable)
 #nd isinstance(expected, Sized)
        # Type ignored because the error is wrong -- not unreachable.
 #nd not isinstance(expected, STRING_TYPES)  # type: ignore[unreachable]
 #:
 #ls = ApproxSequencelike
 #lse:
 #ls = ApproxScalar

 #eturn cls(expected, rel, abs, nan_ok)


def _is_numpy_array(obj: object) -> bool:
 #""
 #eturn true if the given object is implicitly convertible to ndarray,
 #nd numpy is already imported.
 #""
 #eturn _as_numpy_array(obj) is not None


def _as_numpy_array(obj: object) -> Optional["ndarray"]:
 #""
 #eturn an ndarray if the given object is implicitly convertible to ndarray,
 #nd numpy is already imported, otherwise None.
 #""
 #mport sys

 #p: Any = sys.modules.get("numpy")
 #f np is not None:
        # avoid infinite recursion on numpy scalars, which have __array__
 #f np.isscalar(obj):
 #eturn None
 #lif isinstance(obj, np.ndarray):
 #eturn obj
 #lif hasattr(obj, "__array__") or hasattr("obj", "__array_interface__"):
 #eturn np.asarray(obj)
 #eturn None


# builtin pytest.raises helper

_E = TypeVar("_E", bound=BaseException)


@overload
def raises(
 #xpected_exception: Union[Type[_E], Tuple[Type[_E], ...]],
 #,
 #atch: Optional[Union[str, Pattern[str]]] = ...,
) -> "RaisesContext[_E]":
 #..


@overload
def raises(
 #xpected_exception: Union[Type[_E], Tuple[Type[_E], ...]],
 #unc: Callable[..., Any],
 #args: Any,
 #*kwargs: Any,
) -> _pytest._code.ExceptionInfo[_E]:
 #..


def raises(
 #xpected_exception: Union[Type[_E], Tuple[Type[_E], ...]], *args: Any, **kwargs: Any
) -> Union["RaisesContext[_E]", _pytest._code.ExceptionInfo[_E]]:
 #"""Assert that a code block/function call raises ``expected_exception``
 #r raise a failure exception otherwise.

 #kwparam match:
 #f specified, a string containing a regular expression,
 #r a regular expression object, that is tested against the string
 #epresentation of the exception using ``re.search``. To match a literal
 #tring that may contain `special characters`__, the pattern can
 #irst be escaped with ``re.escape``.

 #This is only used when ``pytest.raises`` is used as a context manager,
 #nd passed through to the function otherwise.
 #hen using ``pytest.raises`` as a function, you can use:
 #`pytest.raises(Exc, func, match="passed on").match("my pattern")``.)

 #_ https://docs.python.org/3/library/re.html#regular-expression-syntax

 #. currentmodule:: _pytest._code

 #se ``pytest.raises`` as a context manager, which will capture the exception of the given
 #ype::

 #>> import pytest
 #>> with pytest.raises(ZeroDivisionError):
 #..    1/0

 #f the code block does not raise the expected exception (``ZeroDivisionError`` in the example
 #bove), or no exception at all, the check will fail instead.

 #ou can also use the keyword argument ``match`` to assert that the
 #xception matches a text or regex::

 #>> with pytest.raises(ValueError, match='must be 0 or None'):
 #..     raise ValueError("value must be 0 or None")

 #>> with pytest.raises(ValueError, match=r'must be \d+$'):
 #..     raise ValueError("value must be 42")

 #he context manager produces an :class:`ExceptionInfo` object which can be used to inspect the
 #etails of the captured exception::

 #>> with pytest.raises(ValueError) as exc_info:
 #..     raise ValueError("value must be 42")
 #>> assert exc_info.type is ValueError
 #>> assert exc_info.value.args[0] == "value must be 42"

 #. note::

 #hen using ``pytest.raises`` as a context manager, it's worthwhile to
 #ote that normal context manager rules apply and that the exception
 #aised *must* be the final line in the scope of the context manager.
 #ines of code after that, within the scope of the context manager will
 #ot be executed. For example::

 #>> value = 15
 #>> with pytest.raises(ValueError) as exc_info:
 #..     if value > 10:
 #..         raise ValueError("value must be <= 10")
 #..     assert exc_info.type is ValueError  # this will not execute

 #nstead, the following approach must be taken (note the difference in
 #cope)::

 #>> with pytest.raises(ValueError) as exc_info:
 #..     if value > 10:
 #..         raise ValueError("value must be <= 10")
 #..
 #>> assert exc_info.type is ValueError

 #*Using with** ``pytest.mark.parametrize``

 #hen using :ref:`pytest.mark.parametrize ref`
 #t is possible to parametrize tests such that
 #ome runs raise an exception and others do not.

 #ee :ref:`parametrizing_conditional_raising` for an example.

 #*Legacy form**

 #t is possible to specify a callable by passing a to-be-called lambda::

 #>> raises(ZeroDivisionError, lambda: 1/0)
 #ExceptionInfo ...>

 #r you can specify an arbitrary callable with arguments::

 #>> def f(x): return 1/x
 #..
 #>> raises(ZeroDivisionError, f, 0)
 #ExceptionInfo ...>
 #>> raises(ZeroDivisionError, f, x=0)
 #ExceptionInfo ...>

 #he form above is fully supported but discouraged for new code because the
 #ontext manager form is regarded as more readable and less error-prone.

 #. note::
 #imilar to caught exception objects in Python, explicitly clearing
 #ocal references to returned ``ExceptionInfo`` objects can
 #elp the Python interpreter speed up its garbage collection.

 #learing those references breaks a reference cycle
 #``ExceptionInfo`` --> caught exception --> frame stack raising
 #he exception --> current frame stack --> local variables -->
 #`ExceptionInfo``) which makes Python keep all objects referenced
 #rom that cycle (including all local variables in the current
 #rame) alive until the next cyclic garbage collection run.
 #ore detailed information can be found in the official Python
 #ocumentation for :ref:`the try statement <python:try>`.
 #""
 #_tracebackhide__ = True

 #f isinstance(expected_exception, type):
 #xcepted_exceptions: Tuple[Type[_E], ...] = (expected_exception,)
 #lse:
 #xcepted_exceptions = expected_exception
 #or exc in excepted_exceptions:
 #f not isinstance(exc, type) or not issubclass(exc, BaseException):  # type: ignore[unreachable]
 #sg = "expected exception must be a BaseException type, not {}"  # type: ignore[unreachable]
 #ot_a = exc.__name__ if isinstance(exc, type) else type(exc).__name__
 #aise TypeError(msg.format(not_a))

 #essage = f"DID NOT RAISE {expected_exception}"

 #f not args:
 #atch: Optional[Union[str, Pattern[str]]] = kwargs.pop("match", None)
 #f kwargs:
 #sg = "Unexpected keyword arguments passed to pytest.raises: "
 #sg += ", ".join(sorted(kwargs))
 #sg += "\nUse context-manager form instead?"
 #aise TypeError(msg)
 #eturn RaisesContext(expected_exception, message, match)
 #lse:
 #unc = args[0]
 #f not callable(func):
 #aise TypeError(
 #{!r} object (type: {}) must be callable".format(func, type(func))
 #
 #ry:
 #unc(*args[1:], **kwargs)
 #xcept expected_exception as e:
            # We just caught the exception - there is a traceback.
 #ssert e.__traceback__ is not None
 #eturn _pytest._code.ExceptionInfo.from_exc_info(
 #type(e), e, e.__traceback__)
 #
 #ail(message)


# This doesn't work with mypy for now. Use fail.Exception instead.
raises.Exception = fail.Exception  # type: ignore


@final
class RaisesContext(Generic[_E]):
 #ef __init__(
 #elf,
 #xpected_exception: Union[Type[_E], Tuple[Type[_E], ...]],
 #essage: str,
 #atch_expr: Optional[Union[str, Pattern[str]]] = None,
 # -> None:
 #elf.expected_exception = expected_exception
 #elf.message = message
 #elf.match_expr = match_expr
 #elf.excinfo: Optional[_pytest._code.ExceptionInfo[_E]] = None

 #ef __enter__(self) -> _pytest._code.ExceptionInfo[_E]:
 #elf.excinfo = _pytest._code.ExceptionInfo.for_later()
 #eturn self.excinfo

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> bool:
 #_tracebackhide__ = True
 #f exc_type is None:
 #ail(self.message)
 #ssert self.excinfo is not None
 #f not issubclass(exc_type, self.expected_exception):
 #eturn False
        # Cast to narrow the exception type now that it's verified.
 #xc_info = cast(Tuple[Type[_E], _E, TracebackType], (exc_type, exc_val, exc_tb))
 #elf.excinfo.fill_unfilled(exc_info)
 #f self.match_expr is not None:
 #elf.excinfo.match(self.match_expr)
 #eturn True
