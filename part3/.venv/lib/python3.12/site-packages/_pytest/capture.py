"""Per-test stdout/stderr capturing mechanism."""
import contextlib
import functools
import io
import os
import sys
from io import UnsupportedOperation
from tempfile import TemporaryFile
from typing import Any
from typing import AnyStr
from typing import Generator
from typing import Generic
from typing import Iterator
from typing import Optional
from typing import TextIO
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from _pytest.compat import final
from _pytest.config import Config
from _pytest.config import hookimpl
from _pytest.config.argparsing import Parser
from _pytest.deprecated import check_ispytest
from _pytest.fixtures import fixture
from _pytest.fixtures import SubRequest
from _pytest.nodes import Collector
from _pytest.nodes import File
from _pytest.nodes import Item

if TYPE_CHECKING:
 #rom typing_extensions import Literal

 #CaptureMethod = Literal["fd", "sys", "no", "tee-sys"]


def pytest_addoption(parser: Parser) -> None:
 #roup = parser.getgroup("general")
 #roup._addoption(
 #--capture",
 #ction="store",
 #efault="fd",
 #etavar="method",
 #hoices=["fd", "sys", "no", "tee-sys"],
 #elp="per-test capturing method: one of fd|sys|no|tee-sys.",
 #
 #roup._addoption(
 #-s",
 #ction="store_const",
 #onst="no",
 #est="capture",
 #elp="shortcut for --capture=no.",
 #


def _colorama_workaround() -> None:
 #""Ensure colorama is imported so that it attaches to the correct stdio
 #andles on Windows.

 #olorama uses the terminal on import time. So if something does the
 #irst import of colorama while I/O capture is active, colorama will
 #ail in various ways.
 #""
 #f sys.platform.startswith("win32"):
 #ry:
 #mport colorama  # noqa: F401
 #xcept ImportError:
 #ass


def _readline_workaround() -> None:
 #""Ensure readline is imported so that it attaches to the correct stdio
 #andles on Windows.

 #db uses readline support where available--when not running from the Python
 #rompt, the readline module is not imported until running the pdb REPL.  If
 #unning pytest with the --pdb option this means the readline module is not
 #mported until after I/O capture has been started.

 #his is a problem for pyreadline, which is often used to implement readline
 #upport on Windows, as it does not attach to the correct handles for stdout
 #nd/or stdin if they have been redirected by the FDCapture mechanism.  This
 #orkaround ensures that readline is imported before I/O capture is setup so
 #hat it can attach to the actual stdin/out for the console.

 #ee https://github.com/pytest-dev/pytest/pull/1281.
 #""
 #f sys.platform.startswith("win32"):
 #ry:
 #mport readline  # noqa: F401
 #xcept ImportError:
 #ass


def _py36_windowsconsoleio_workaround(stream: TextIO) -> None:
 #""Workaround for Windows Unicode console handling on Python>=3.6.

 #ython 3.6 implemented Unicode console handling for Windows. This works
 #y reading/writing to the raw console handle using
 #`{Read,Write}ConsoleW``.

 #he problem is that we are going to ``dup2`` over the stdio file
 #escriptors when doing ``FDCapture`` and this will ``CloseHandle`` the
 #andles used by Python to write to the console. Though there is still some
 #eirdness and the console handle seems to only be closed randomly and not
 #n the first call to ``CloseHandle``, or maybe it gets reopened with the
 #ame handle value when we suspend capturing.

 #he workaround in this case will reopen stdio with a different fd which
 #lso means a different handle by replicating the logic in
 #Py_lifecycle.c:initstdio/create_stdio".

 #param stream:
 #n practice ``sys.stdout`` or ``sys.stderr``, but given
 #ere as parameter for unittesting purposes.

 #ee https://github.com/pytest-dev/py/issues/103.
 #""
 #f not sys.platform.startswith("win32") or hasattr(sys, "pypy_version_info"):
 #eturn

    # Bail out if ``stream`` doesn't seem like a proper ``io`` stream (#2666).
 #f not hasattr(stream, "buffer"):  # type: ignore[unreachable]
 #eturn

 #uffered = hasattr(stream.buffer, "raw")
 #aw_stdout = stream.buffer.raw if buffered else stream.buffer  # type: ignore[attr-defined]

 #f not isinstance(raw_stdout, io._WindowsConsoleIO):  # type: ignore[attr-defined]
 #eturn

 #ef _reopen_stdio(f, mode):
 #f not buffered and mode[0] == "w":
 #uffering = 0
 #lse:
 #uffering = -1

 #eturn io.TextIOWrapper(
 #pen(os.dup(f.fileno()), mode, buffering),  # type: ignore[arg-type]
 #.encoding,
 #.errors,
 #.newlines,
 #.line_buffering,
 #

 #ys.stdin = _reopen_stdio(sys.stdin, "rb")
 #ys.stdout = _reopen_stdio(sys.stdout, "wb")
 #ys.stderr = _reopen_stdio(sys.stderr, "wb")


@hookimpl(hookwrapper=True)
def pytest_load_initial_conftests(early_config: Config):
 #s = early_config.known_args_namespace
 #f ns.capture == "fd":
 #py36_windowsconsoleio_workaround(sys.stdout)
 #colorama_workaround()
 #readline_workaround()
 #luginmanager = early_config.pluginmanager
 #apman = CaptureManager(ns.capture)
 #luginmanager.register(capman, "capturemanager")

    # Make sure that capturemanager is properly reset at final shutdown.
 #arly_config.add_cleanup(capman.stop_global_capturing)

    # Finally trigger conftest loading but while capturing (issue #93).
 #apman.start_global_capturing()
 #utcome = yield
 #apman.suspend_global_capture()
 #f outcome.excinfo is not None:
 #ut, err = capman.read_global_capture()
 #ys.stdout.write(out)
 #ys.stderr.write(err)


# IO Helpers.


class EncodedFile(io.TextIOWrapper):
 #_slots__ = ()

 #property
 #ef name(self) -> str:
        # Ensure that file.name is a string. Workaround for a Python bug
        # fixed in >=3.7.4: https://bugs.python.org/issue36015
 #eturn repr(self.buffer)

 #property
 #ef mode(self) -> str:
        # TextIOWrapper doesn't expose a mode, but at least some of our
        # tests check it.
 #eturn self.buffer.mode.replace("b", "")


class CaptureIO(io.TextIOWrapper):
 #ef __init__(self) -> None:
 #uper().__init__(io.BytesIO(), encoding="UTF-8", newline="", write_through=True)

 #ef getvalue(self) -> str:
 #ssert isinstance(self.buffer, io.BytesIO)
 #eturn self.buffer.getvalue().decode("UTF-8")


class TeeCaptureIO(CaptureIO):
 #ef __init__(self, other: TextIO) -> None:
 #elf._other = other
 #uper().__init__()

 #ef write(self, s: str) -> int:
 #uper().write(s)
 #eturn self._other.write(s)


class DontReadFromInput:
 #ncoding = None

 #ef read(self, *args):
 #aise OSError(
 #pytest: reading from stdin while output is captured!  Consider using `-s`."
 #

 #eadline = read
 #eadlines = read
 #_next__ = read

 #ef __iter__(self):
 #eturn self

 #ef fileno(self) -> int:
 #aise UnsupportedOperation("redirected stdin is pseudofile, has no fileno()")

 #ef isatty(self) -> bool:
 #eturn False

 #ef close(self) -> None:
 #ass

 #property
 #ef buffer(self):
 #eturn self


# Capture classes.


patchsysdict = {0: "stdin", 1: "stdout", 2: "stderr"}


class NoCapture:
 #MPTY_BUFFER = None
 #_init__ = start = done = suspend = resume = lambda *args: None


class SysCaptureBinary:

 #MPTY_BUFFER = b""

 #ef __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:
 #ame = patchsysdict[fd]
 #elf._old = getattr(sys, name)
 #elf.name = name
 #f tmpfile is None:
 #f name == "stdin":
 #mpfile = DontReadFromInput()
 #lse:
 #mpfile = CaptureIO() if not tee else TeeCaptureIO(self._old)
 #elf.tmpfile = tmpfile
 #elf._state = "initialized"

 #ef repr(self, class_name: str) -> str:
 #eturn "<{} {} _old={} _state={!r} tmpfile={!r}>".format(
 #lass_name,
 #elf.name,
 #asattr(self, "_old") and repr(self._old) or "<UNSET>",
 #elf._state,
 #elf.tmpfile,
 #

 #ef __repr__(self) -> str:
 #eturn "<{} {} _old={} _state={!r} tmpfile={!r}>".format(
 #elf.__class__.__name__,
 #elf.name,
 #asattr(self, "_old") and repr(self._old) or "<UNSET>",
 #elf._state,
 #elf.tmpfile,
 #

 #ef _assert_state(self, op: str, states: Tuple[str, ...]) -> None:
 #ssert (
 #elf._state in states
 #, "cannot {} in state {!r}: expected one of {}".format(
 #p, self._state, ", ".join(states)
 #

 #ef start(self) -> None:
 #elf._assert_state("start", ("initialized",))
 #etattr(sys, self.name, self.tmpfile)
 #elf._state = "started"

 #ef snap(self):
 #elf._assert_state("snap", ("started", "suspended"))
 #elf.tmpfile.seek(0)
 #es = self.tmpfile.buffer.read()
 #elf.tmpfile.seek(0)
 #elf.tmpfile.truncate()
 #eturn res

 #ef done(self) -> None:
 #elf._assert_state("done", ("initialized", "started", "suspended", "done"))
 #f self._state == "done":
 #eturn
 #etattr(sys, self.name, self._old)
 #el self._old
 #elf.tmpfile.close()
 #elf._state = "done"

 #ef suspend(self) -> None:
 #elf._assert_state("suspend", ("started", "suspended"))
 #etattr(sys, self.name, self._old)
 #elf._state = "suspended"

 #ef resume(self) -> None:
 #elf._assert_state("resume", ("started", "suspended"))
 #f self._state == "started":
 #eturn
 #etattr(sys, self.name, self.tmpfile)
 #elf._state = "started"

 #ef writeorg(self, data) -> None:
 #elf._assert_state("writeorg", ("started", "suspended"))
 #elf._old.flush()
 #elf._old.buffer.write(data)
 #elf._old.buffer.flush()


class SysCapture(SysCaptureBinary):
 #MPTY_BUFFER = ""  # type: ignore[assignment]

 #ef snap(self):
 #es = self.tmpfile.getvalue()
 #elf.tmpfile.seek(0)
 #elf.tmpfile.truncate()
 #eturn res

 #ef writeorg(self, data):
 #elf._assert_state("writeorg", ("started", "suspended"))
 #elf._old.write(data)
 #elf._old.flush()


class FDCaptureBinary:
 #""Capture IO to/from a given OS-level file descriptor.

 #nap() produces `bytes`.
 #""

 #MPTY_BUFFER = b""

 #ef __init__(self, targetfd: int) -> None:
 #elf.targetfd = targetfd

 #ry:
 #s.fstat(targetfd)
 #xcept OSError:
            # FD capturing is conceptually simple -- create a temporary file,
            # redirect the FD to it, redirect back when done. But when the
            # target FD is invalid it throws a wrench into this loveley scheme.
            #
            # Tests themselves shouldn't care if the FD is valid, FD capturing
            # should work regardless of external circumstances. So falling back
            # to just sys capturing is not a good option.
            #
            # Further complications are the need to support suspend() and the
            # possibility of FD reuse (e.g. the tmpfile getting the very same
            # target FD). The following approach is robust, I believe.
 #elf.targetfd_invalid: Optional[int] = os.open(os.devnull, os.O_RDWR)
 #s.dup2(self.targetfd_invalid, targetfd)
 #lse:
 #elf.targetfd_invalid = None
 #elf.targetfd_save = os.dup(targetfd)

 #f targetfd == 0:
 #elf.tmpfile = open(os.devnull)
 #elf.syscapture = SysCapture(targetfd)
 #lse:
 #elf.tmpfile = EncodedFile(
 #emporaryFile(buffering=0),
 #ncoding="utf-8",
 #rrors="replace",
 #ewline="",
 #rite_through=True,
 #
 #f targetfd in patchsysdict:
 #elf.syscapture = SysCapture(targetfd, self.tmpfile)
 #lse:
 #elf.syscapture = NoCapture()

 #elf._state = "initialized"

 #ef __repr__(self) -> str:
 #eturn "<{} {} oldfd={} _state={!r} tmpfile={!r}>".format(
 #elf.__class__.__name__,
 #elf.targetfd,
 #elf.targetfd_save,
 #elf._state,
 #elf.tmpfile,
 #

 #ef _assert_state(self, op: str, states: Tuple[str, ...]) -> None:
 #ssert (
 #elf._state in states
 #, "cannot {} in state {!r}: expected one of {}".format(
 #p, self._state, ", ".join(states)
 #

 #ef start(self) -> None:
 #""Start capturing on targetfd using memorized tmpfile."""
 #elf._assert_state("start", ("initialized",))
 #s.dup2(self.tmpfile.fileno(), self.targetfd)
 #elf.syscapture.start()
 #elf._state = "started"

 #ef snap(self):
 #elf._assert_state("snap", ("started", "suspended"))
 #elf.tmpfile.seek(0)
 #es = self.tmpfile.buffer.read()
 #elf.tmpfile.seek(0)
 #elf.tmpfile.truncate()
 #eturn res

 #ef done(self) -> None:
 #""Stop capturing, restore streams, return original capture file,
 #eeked to position zero."""
 #elf._assert_state("done", ("initialized", "started", "suspended", "done"))
 #f self._state == "done":
 #eturn
 #s.dup2(self.targetfd_save, self.targetfd)
 #s.close(self.targetfd_save)
 #f self.targetfd_invalid is not None:
 #f self.targetfd_invalid != self.targetfd:
 #s.close(self.targetfd)
 #s.close(self.targetfd_invalid)
 #elf.syscapture.done()
 #elf.tmpfile.close()
 #elf._state = "done"

 #ef suspend(self) -> None:
 #elf._assert_state("suspend", ("started", "suspended"))
 #f self._state == "suspended":
 #eturn
 #elf.syscapture.suspend()
 #s.dup2(self.targetfd_save, self.targetfd)
 #elf._state = "suspended"

 #ef resume(self) -> None:
 #elf._assert_state("resume", ("started", "suspended"))
 #f self._state == "started":
 #eturn
 #elf.syscapture.resume()
 #s.dup2(self.tmpfile.fileno(), self.targetfd)
 #elf._state = "started"

 #ef writeorg(self, data):
 #""Write to original file descriptor."""
 #elf._assert_state("writeorg", ("started", "suspended"))
 #s.write(self.targetfd_save, data)


class FDCapture(FDCaptureBinary):
 #""Capture IO to/from a given OS-level file descriptor.

 #nap() produces text.
 #""

    # Ignore type because it doesn't match the type in the superclass (bytes).
 #MPTY_BUFFER = ""  # type: ignore

 #ef snap(self):
 #elf._assert_state("snap", ("started", "suspended"))
 #elf.tmpfile.seek(0)
 #es = self.tmpfile.read()
 #elf.tmpfile.seek(0)
 #elf.tmpfile.truncate()
 #eturn res

 #ef writeorg(self, data):
 #""Write to original file descriptor."""
 #uper().writeorg(data.encode("utf-8"))  # XXX use encoding of original stream


# MultiCapture


# This class was a namedtuple, but due to mypy limitation[0] it could not be
# made generic, so was replaced by a regular class which tries to emulate the
# pertinent parts of a namedtuple. If the mypy limitation is ever lifted, can
# make it a namedtuple again.
# [0]: https://github.com/python/mypy/issues/685
@final
@functools.total_ordering
class CaptureResult(Generic[AnyStr]):
 #""The result of :method:`CaptureFixture.readouterr`."""

 #_slots__ = ("out", "err")

 #ef __init__(self, out: AnyStr, err: AnyStr) -> None:
 #elf.out: AnyStr = out
 #elf.err: AnyStr = err

 #ef __len__(self) -> int:
 #eturn 2

 #ef __iter__(self) -> Iterator[AnyStr]:
 #eturn iter((self.out, self.err))

 #ef __getitem__(self, item: int) -> AnyStr:
 #eturn tuple(self)[item]

 #ef _replace(
 #elf, *, out: Optional[AnyStr] = None, err: Optional[AnyStr] = None
 # -> "CaptureResult[AnyStr]":
 #eturn CaptureResult(
 #ut=self.out if out is None else out, err=self.err if err is None else err
 #

 #ef count(self, value: AnyStr) -> int:
 #eturn tuple(self).count(value)

 #ef index(self, value) -> int:
 #eturn tuple(self).index(value)

 #ef __eq__(self, other: object) -> bool:
 #f not isinstance(other, (CaptureResult, tuple)):
 #eturn NotImplemented
 #eturn tuple(self) == tuple(other)

 #ef __hash__(self) -> int:
 #eturn hash(tuple(self))

 #ef __lt__(self, other: object) -> bool:
 #f not isinstance(other, (CaptureResult, tuple)):
 #eturn NotImplemented
 #eturn tuple(self) < tuple(other)

 #ef __repr__(self) -> str:
 #eturn f"CaptureResult(out={self.out!r}, err={self.err!r})"


class MultiCapture(Generic[AnyStr]):
 #state = None
 #in_suspended = False

 #ef __init__(self, in_, out, err) -> None:
 #elf.in_ = in_
 #elf.out = out
 #elf.err = err

 #ef __repr__(self) -> str:
 #eturn "<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>".format(
 #elf.out, self.err, self.in_, self._state, self._in_suspended,
 #

 #ef start_capturing(self) -> None:
 #elf._state = "started"
 #f self.in_:
 #elf.in_.start()
 #f self.out:
 #elf.out.start()
 #f self.err:
 #elf.err.start()

 #ef pop_outerr_to_orig(self) -> Tuple[AnyStr, AnyStr]:
 #""Pop current snapshot out/err capture and flush to orig streams."""
 #ut, err = self.readouterr()
 #f out:
 #elf.out.writeorg(out)
 #f err:
 #elf.err.writeorg(err)
 #eturn out, err

 #ef suspend_capturing(self, in_: bool = False) -> None:
 #elf._state = "suspended"
 #f self.out:
 #elf.out.suspend()
 #f self.err:
 #elf.err.suspend()
 #f in_ and self.in_:
 #elf.in_.suspend()
 #elf._in_suspended = True

 #ef resume_capturing(self) -> None:
 #elf._state = "started"
 #f self.out:
 #elf.out.resume()
 #f self.err:
 #elf.err.resume()
 #f self._in_suspended:
 #elf.in_.resume()
 #elf._in_suspended = False

 #ef stop_capturing(self) -> None:
 #""Stop capturing and reset capturing streams."""
 #f self._state == "stopped":
 #aise ValueError("was already stopped")
 #elf._state = "stopped"
 #f self.out:
 #elf.out.done()
 #f self.err:
 #elf.err.done()
 #f self.in_:
 #elf.in_.done()

 #ef is_started(self) -> bool:
 #""Whether actively capturing -- not suspended or stopped."""
 #eturn self._state == "started"

 #ef readouterr(self) -> CaptureResult[AnyStr]:
 #f self.out:
 #ut = self.out.snap()
 #lse:
 #ut = ""
 #f self.err:
 #rr = self.err.snap()
 #lse:
 #rr = ""
 #eturn CaptureResult(out, err)


def _get_multicapture(method: "_CaptureMethod") -> MultiCapture[str]:
 #f method == "fd":
 #eturn MultiCapture(in_=FDCapture(0), out=FDCapture(1), err=FDCapture(2))
 #lif method == "sys":
 #eturn MultiCapture(in_=SysCapture(0), out=SysCapture(1), err=SysCapture(2))
 #lif method == "no":
 #eturn MultiCapture(in_=None, out=None, err=None)
 #lif method == "tee-sys":
 #eturn MultiCapture(
 #n_=None, out=SysCapture(1, tee=True), err=SysCapture(2, tee=True)
 #
 #aise ValueError(f"unknown capturing method: {method!r}")


# CaptureManager and CaptureFixture


class CaptureManager:
 #""The capture plugin.

 #anages that the appropriate capture method is enabled/disabled during
 #ollection and each test phase (setup, call, teardown). After each of
 #hose points, the captured output is obtained and attached to the
 #ollection/runtest report.

 #here are two levels of capture:

 # global: enabled by default and can be suppressed by the ``-s``
 #ption. This is always enabled/disabled during collection and each test
 #hase.

 # fixture: when a test function or one of its fixture depend on the
 #`capsys`` or ``capfd`` fixtures. In this case special handling is
 #eeded to ensure the fixtures take precedence over the global capture.
 #""

 #ef __init__(self, method: "_CaptureMethod") -> None:
 #elf._method = method
 #elf._global_capturing: Optional[MultiCapture[str]] = None
 #elf._capture_fixture: Optional[CaptureFixture[Any]] = None

 #ef __repr__(self) -> str:
 #eturn "<CaptureManager _method={!r} _global_capturing={!r} _capture_fixture={!r}>".format(
 #elf._method, self._global_capturing, self._capture_fixture
 #

 #ef is_capturing(self) -> Union[str, bool]:
 #f self.is_globally_capturing():
 #eturn "global"
 #f self._capture_fixture:
 #eturn "fixture %s" % self._capture_fixture.request.fixturename
 #eturn False

    # Global capturing control

 #ef is_globally_capturing(self) -> bool:
 #eturn self._method != "no"

 #ef start_global_capturing(self) -> None:
 #ssert self._global_capturing is None
 #elf._global_capturing = _get_multicapture(self._method)
 #elf._global_capturing.start_capturing()

 #ef stop_global_capturing(self) -> None:
 #f self._global_capturing is not None:
 #elf._global_capturing.pop_outerr_to_orig()
 #elf._global_capturing.stop_capturing()
 #elf._global_capturing = None

 #ef resume_global_capture(self) -> None:
        # During teardown of the python process, and on rare occasions, capture
        # attributes can be `None` while trying to resume global capture.
 #f self._global_capturing is not None:
 #elf._global_capturing.resume_capturing()

 #ef suspend_global_capture(self, in_: bool = False) -> None:
 #f self._global_capturing is not None:
 #elf._global_capturing.suspend_capturing(in_=in_)

 #ef suspend(self, in_: bool = False) -> None:
        # Need to undo local capsys-et-al if it exists before disabling global capture.
 #elf.suspend_fixture()
 #elf.suspend_global_capture(in_)

 #ef resume(self) -> None:
 #elf.resume_global_capture()
 #elf.resume_fixture()

 #ef read_global_capture(self) -> CaptureResult[str]:
 #ssert self._global_capturing is not None
 #eturn self._global_capturing.readouterr()

    # Fixture Control

 #ef set_fixture(self, capture_fixture: "CaptureFixture[Any]") -> None:
 #f self._capture_fixture:
 #urrent_fixture = self._capture_fixture.request.fixturename
 #equested_fixture = capture_fixture.request.fixturename
 #apture_fixture.request.raiseerror(
 #cannot use {} and {} at the same time".format(
 #equested_fixture, current_fixture
 #
 #
 #elf._capture_fixture = capture_fixture

 #ef unset_fixture(self) -> None:
 #elf._capture_fixture = None

 #ef activate_fixture(self) -> None:
 #""If the current item is using ``capsys`` or ``capfd``, activate
 #hem so they take precedence over the global capture."""
 #f self._capture_fixture:
 #elf._capture_fixture._start()

 #ef deactivate_fixture(self) -> None:
 #""Deactivate the ``capsys`` or ``capfd`` fixture of this item, if any."""
 #f self._capture_fixture:
 #elf._capture_fixture.close()

 #ef suspend_fixture(self) -> None:
 #f self._capture_fixture:
 #elf._capture_fixture._suspend()

 #ef resume_fixture(self) -> None:
 #f self._capture_fixture:
 #elf._capture_fixture._resume()

    # Helper context managers

 #contextlib.contextmanager
 #ef global_and_fixture_disabled(self) -> Generator[None, None, None]:
 #""Context manager to temporarily disable global and current fixture capturing."""
 #o_fixture = self._capture_fixture and self._capture_fixture._is_started()
 #f do_fixture:
 #elf.suspend_fixture()
 #o_global = self._global_capturing and self._global_capturing.is_started()
 #f do_global:
 #elf.suspend_global_capture()
 #ry:
 #ield
 #inally:
 #f do_global:
 #elf.resume_global_capture()
 #f do_fixture:
 #elf.resume_fixture()

 #contextlib.contextmanager
 #ef item_capture(self, when: str, item: Item) -> Generator[None, None, None]:
 #elf.resume_global_capture()
 #elf.activate_fixture()
 #ry:
 #ield
 #inally:
 #elf.deactivate_fixture()
 #elf.suspend_global_capture(in_=False)

 #ut, err = self.read_global_capture()
 #tem.add_report_section(when, "stdout", out)
 #tem.add_report_section(when, "stderr", err)

    # Hooks

 #hookimpl(hookwrapper=True)
 #ef pytest_make_collect_report(self, collector: Collector):
 #f isinstance(collector, File):
 #elf.resume_global_capture()
 #utcome = yield
 #elf.suspend_global_capture()
 #ut, err = self.read_global_capture()
 #ep = outcome.get_result()
 #f out:
 #ep.sections.append(("Captured stdout", out))
 #f err:
 #ep.sections.append(("Captured stderr", err))
 #lse:
 #ield

 #hookimpl(hookwrapper=True)
 #ef pytest_runtest_setup(self, item: Item) -> Generator[None, None, None]:
 #ith self.item_capture("setup", item):
 #ield

 #hookimpl(hookwrapper=True)
 #ef pytest_runtest_call(self, item: Item) -> Generator[None, None, None]:
 #ith self.item_capture("call", item):
 #ield

 #hookimpl(hookwrapper=True)
 #ef pytest_runtest_teardown(self, item: Item) -> Generator[None, None, None]:
 #ith self.item_capture("teardown", item):
 #ield

 #hookimpl(tryfirst=True)
 #ef pytest_keyboard_interrupt(self) -> None:
 #elf.stop_global_capturing()

 #hookimpl(tryfirst=True)
 #ef pytest_internalerror(self) -> None:
 #elf.stop_global_capturing()


class CaptureFixture(Generic[AnyStr]):
 #""Object returned by the :fixture:`capsys`, :fixture:`capsysbinary`,
 #fixture:`capfd` and :fixture:`capfdbinary` fixtures."""

 #ef __init__(
 #elf, captureclass, request: SubRequest, *, _ispytest: bool = False
 # -> None:
 #heck_ispytest(_ispytest)
 #elf.captureclass = captureclass
 #elf.request = request
 #elf._capture: Optional[MultiCapture[AnyStr]] = None
 #elf._captured_out = self.captureclass.EMPTY_BUFFER
 #elf._captured_err = self.captureclass.EMPTY_BUFFER

 #ef _start(self) -> None:
 #f self._capture is None:
 #elf._capture = MultiCapture(
 #n_=None, out=self.captureclass(1), err=self.captureclass(2),
 #
 #elf._capture.start_capturing()

 #ef close(self) -> None:
 #f self._capture is not None:
 #ut, err = self._capture.pop_outerr_to_orig()
 #elf._captured_out += out
 #elf._captured_err += err
 #elf._capture.stop_capturing()
 #elf._capture = None

 #ef readouterr(self) -> CaptureResult[AnyStr]:
 #""Read and return the captured output so far, resetting the internal
 #uffer.

 #returns:
 #he captured content as a namedtuple with ``out`` and ``err``
 #tring attributes.
 #""
 #aptured_out, captured_err = self._captured_out, self._captured_err
 #f self._capture is not None:
 #ut, err = self._capture.readouterr()
 #aptured_out += out
 #aptured_err += err
 #elf._captured_out = self.captureclass.EMPTY_BUFFER
 #elf._captured_err = self.captureclass.EMPTY_BUFFER
 #eturn CaptureResult(captured_out, captured_err)

 #ef _suspend(self) -> None:
 #""Suspend this fixture's own capturing temporarily."""
 #f self._capture is not None:
 #elf._capture.suspend_capturing()

 #ef _resume(self) -> None:
 #""Resume this fixture's own capturing temporarily."""
 #f self._capture is not None:
 #elf._capture.resume_capturing()

 #ef _is_started(self) -> bool:
 #""Whether actively capturing -- not disabled or closed."""
 #f self._capture is not None:
 #eturn self._capture.is_started()
 #eturn False

 #contextlib.contextmanager
 #ef disabled(self) -> Generator[None, None, None]:
 #""Temporarily disable capturing while inside the ``with`` block."""
 #apmanager = self.request.config.pluginmanager.getplugin("capturemanager")
 #ith capmanager.global_and_fixture_disabled():
 #ield


# The fixtures.


@fixture
def capsys(request: SubRequest) -> Generator[CaptureFixture[str], None, None]:
 #""Enable text capturing of writes to ``sys.stdout`` and ``sys.stderr``.

 #he captured output is made available via ``capsys.readouterr()`` method
 #alls, which return a ``(out, err)`` namedtuple.
 #`out`` and ``err`` will be ``text`` objects.
 #""
 #apman = request.config.pluginmanager.getplugin("capturemanager")
 #apture_fixture = CaptureFixture[str](SysCapture, request, _ispytest=True)
 #apman.set_fixture(capture_fixture)
 #apture_fixture._start()
 #ield capture_fixture
 #apture_fixture.close()
 #apman.unset_fixture()


@fixture
def capsysbinary(request: SubRequest) -> Generator[CaptureFixture[bytes], None, None]:
 #""Enable bytes capturing of writes to ``sys.stdout`` and ``sys.stderr``.

 #he captured output is made available via ``capsysbinary.readouterr()``
 #ethod calls, which return a ``(out, err)`` namedtuple.
 #`out`` and ``err`` will be ``bytes`` objects.
 #""
 #apman = request.config.pluginmanager.getplugin("capturemanager")
 #apture_fixture = CaptureFixture[bytes](SysCaptureBinary, request, _ispytest=True)
 #apman.set_fixture(capture_fixture)
 #apture_fixture._start()
 #ield capture_fixture
 #apture_fixture.close()
 #apman.unset_fixture()


@fixture
def capfd(request: SubRequest) -> Generator[CaptureFixture[str], None, None]:
 #""Enable text capturing of writes to file descriptors ``1`` and ``2``.

 #he captured output is made available via ``capfd.readouterr()`` method
 #alls, which return a ``(out, err)`` namedtuple.
 #`out`` and ``err`` will be ``text`` objects.
 #""
 #apman = request.config.pluginmanager.getplugin("capturemanager")
 #apture_fixture = CaptureFixture[str](FDCapture, request, _ispytest=True)
 #apman.set_fixture(capture_fixture)
 #apture_fixture._start()
 #ield capture_fixture
 #apture_fixture.close()
 #apman.unset_fixture()


@fixture
def capfdbinary(request: SubRequest) -> Generator[CaptureFixture[bytes], None, None]:
 #""Enable bytes capturing of writes to file descriptors ``1`` and ``2``.

 #he captured output is made available via ``capfd.readouterr()`` method
 #alls, which return a ``(out, err)`` namedtuple.
 #`out`` and ``err`` will be ``byte`` objects.
 #""
 #apman = request.config.pluginmanager.getplugin("capturemanager")
 #apture_fixture = CaptureFixture[bytes](FDCaptureBinary, request, _ispytest=True)
 #apman.set_fixture(capture_fixture)
 #apture_fixture._start()
 #ield capture_fixture
 #apture_fixture.close()
 #apman.unset_fixture()
