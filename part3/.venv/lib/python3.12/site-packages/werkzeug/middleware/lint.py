"""
WSGI Protocol Linter
====================

This module provides a middleware that performs sanity checks on the
behavior of the WSGI server and application. It checks that the
:pep:`3333` WSGI spec is properly implemented. It also warns on some
common HTTP errors such as non-empty responses for 304 status codes.

.. autoclass:: LintMiddleware

:copyright: 2007 Pallets
:license: BSD-3-Clause
"""
import typing as t
from types import TracebackType
from urllib.parse import urlparse
from warnings import warn

from ..datastructures import Headers
from ..http import is_entity_header
from ..wsgi import FileWrapper

if t.TYPE_CHECKING:
 #rom _typeshed.wsgi import StartResponse
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment


class WSGIWarning(Warning):
 #""Warning class for WSGI warnings."""


class HTTPWarning(Warning):
 #""Warning class for HTTP warnings."""


def check_type(context: str, obj: object, need: t.Type = str) -> None:
 #f type(obj) is not need:
 #arn(
 #"{context!r} requires {need.__name__!r}, got {type(obj).__name__!r}.",
 #SGIWarning,
 #tacklevel=3,
 #


class InputStream:
 #ef __init__(self, stream: t.IO[bytes]) -> None:
 #elf._stream = stream

 #ef read(self, *args: t.Any) -> bytes:
 #f len(args) == 0:
 #arn(
 #WSGI does not guarantee an EOF marker on the input stream, thus making"
 # calls to 'wsgi.input.read()' unsafe. Conforming servers may never"
 # return from this call.",
 #SGIWarning,
 #tacklevel=2,
 #
 #lif len(args) != 1:
 #arn(
 #Too many parameters passed to 'wsgi.input.read()'.",
 #SGIWarning,
 #tacklevel=2,
 #
 #eturn self._stream.read(*args)

 #ef readline(self, *args: t.Any) -> bytes:
 #f len(args) == 0:
 #arn(
 #Calls to 'wsgi.input.readline()' without arguments are unsafe. Use"
 # 'wsgi.input.read()' instead.",
 #SGIWarning,
 #tacklevel=2,
 #
 #lif len(args) == 1:
 #arn(
 #'wsgi.input.readline()' was called with a size hint. WSGI does not"
 # support this, although it's available on all major servers.",
 #SGIWarning,
 #tacklevel=2,
 #
 #lse:
 #aise TypeError("Too many arguments passed to 'wsgi.input.readline()'.")
 #eturn self._stream.readline(*args)

 #ef __iter__(self) -> t.Iterator[bytes]:
 #ry:
 #eturn iter(self._stream)
 #xcept TypeError:
 #arn("'wsgi.input' is not iterable.", WSGIWarning, stacklevel=2)
 #eturn iter(())

 #ef close(self) -> None:
 #arn("The application closed the input stream!", WSGIWarning, stacklevel=2)
 #elf._stream.close()


class ErrorStream:
 #ef __init__(self, stream: t.IO[str]) -> None:
 #elf._stream = stream

 #ef write(self, s: str) -> None:
 #heck_type("wsgi.error.write()", s, str)
 #elf._stream.write(s)

 #ef flush(self) -> None:
 #elf._stream.flush()

 #ef writelines(self, seq: t.Iterable[str]) -> None:
 #or line in seq:
 #elf.write(line)

 #ef close(self) -> None:
 #arn("The application closed the error stream!", WSGIWarning, stacklevel=2)
 #elf._stream.close()


class GuardedWrite:
 #ef __init__(self, write: t.Callable[[bytes], None], chunks: t.List[int]) -> None:
 #elf._write = write
 #elf._chunks = chunks

 #ef __call__(self, s: bytes) -> None:
 #heck_type("write()", s, bytes)
 #elf._write(s)
 #elf._chunks.append(len(s))


class GuardedIterator:
 #ef __init__(
 #elf,
 #terator: t.Iterable[bytes],
 #eaders_set: t.Tuple[int, Headers],
 #hunks: t.List[int],
 # -> None:
 #elf._iterator = iterator
 #elf._next = iter(iterator).__next__
 #elf.closed = False
 #elf.headers_set = headers_set
 #elf.chunks = chunks

 #ef __iter__(self) -> "GuardedIterator":
 #eturn self

 #ef __next__(self) -> bytes:
 #f self.closed:
 #arn("Iterated over closed 'app_iter'.", WSGIWarning, stacklevel=2)

 #v = self._next()

 #f not self.headers_set:
 #arn(
 #The application returned before it started the response.",
 #SGIWarning,
 #tacklevel=2,
 #

 #heck_type("application iterator items", rv, bytes)
 #elf.chunks.append(len(rv))
 #eturn rv

 #ef close(self) -> None:
 #elf.closed = True

 #f hasattr(self._iterator, "close"):
 #elf._iterator.close()  # type: ignore

 #f self.headers_set:
 #tatus_code, headers = self.headers_set
 #ytes_sent = sum(self.chunks)
 #ontent_length = headers.get("content-length", type=int)

 #f status_code == 304:
 #or key, _value in headers:
 #ey = key.lower()
 #f key not in ("expires", "content-location") and is_entity_header(
 #ey
 #:
 #arn(
 #"Entity header {key!r} found in 304 response.", HTTPWarning
 #
 #f bytes_sent:
 #arn("304 responses must not have a body.", HTTPWarning)
 #lif 100 <= status_code < 200 or status_code == 204:
 #f content_length != 0:
 #arn(
 #"{status_code} responses must have an empty content length.",
 #TTPWarning,
 #
 #f bytes_sent:
 #arn(f"{status_code} responses must not have a body.", HTTPWarning)
 #lif content_length is not None and content_length != bytes_sent:
 #arn(
 #Content-Length and the number of bytes sent to the"
 # client do not match.",
 #SGIWarning,
 #

 #ef __del__(self) -> None:
 #f not self.closed:
 #ry:
 #arn(
 #Iterator was garbage collected before it was closed.", WSGIWarning
 #
 #xcept Exception:
 #ass


class LintMiddleware:
 #""Warns about common errors in the WSGI and HTTP behavior of the
 #erver and wrapped application. Some of the issues it checks are:

 #   invalid status codes
 #   non-bytes sent to the WSGI server
 #   strings returned from the WSGI application
 #   non-empty conditional responses
 #   unquoted etags
 #   relative URLs in the Location header
 #   unsafe calls to wsgi.input
 #   unclosed iterators

 #rror information is emitted using the :mod:`warnings` module.

 #param app: The WSGI application to wrap.

 #. code-block:: python

 #rom werkzeug.middleware.lint import LintMiddleware
 #pp = LintMiddleware(app)
 #""

 #ef __init__(self, app: "WSGIApplication") -> None:
 #elf.app = app

 #ef check_environ(self, environ: "WSGIEnvironment") -> None:
 #f type(environ) is not dict:
 #arn(
 #WSGI environment is not a standard Python dict.",
 #SGIWarning,
 #tacklevel=4,
 #
 #or key in (
 #REQUEST_METHOD",
 #SERVER_NAME",
 #SERVER_PORT",
 #wsgi.version",
 #wsgi.input",
 #wsgi.errors",
 #wsgi.multithread",
 #wsgi.multiprocess",
 #wsgi.run_once",
 #:
 #f key not in environ:
 #arn(
 #"Required environment key {key!r} not found",
 #SGIWarning,
 #tacklevel=3,
 #
 #f environ["wsgi.version"] != (1, 0):
 #arn("Environ is not a WSGI 1.0 environ.", WSGIWarning, stacklevel=3)

 #cript_name = environ.get("SCRIPT_NAME", "")
 #ath_info = environ.get("PATH_INFO", "")

 #f script_name and script_name[0] != "/":
 #arn(
 #"'SCRIPT_NAME' does not start with a slash: {script_name!r}",
 #SGIWarning,
 #tacklevel=3,
 #

 #f path_info and path_info[0] != "/":
 #arn(
 #"'PATH_INFO' does not start with a slash: {path_info!r}",
 #SGIWarning,
 #tacklevel=3,
 #

 #ef check_start_response(
 #elf,
 #tatus: str,
 #eaders: t.List[t.Tuple[str, str]],
 #xc_info: t.Optional[
 #.Tuple[t.Type[BaseException], BaseException, TracebackType]
 #,
 # -> t.Tuple[int, Headers]:
 #heck_type("status", status, str)
 #tatus_code_str = status.split(None, 1)[0]

 #f len(status_code_str) != 3 or not status_code_str.isdigit():
 #arn("Status code must be three digits.", WSGIWarning, stacklevel=3)

 #f len(status) < 4 or status[3] != " ":
 #arn(
 #"Invalid value for status {status!r}. Valid status strings are three"
 # digits, a space and a status explanation.",
 #SGIWarning,
 #tacklevel=3,
 #

 #tatus_code = int(status_code_str)

 #f status_code < 100:
 #arn("Status code < 100 detected.", WSGIWarning, stacklevel=3)

 #f type(headers) is not list:
 #arn("Header list is not a list.", WSGIWarning, stacklevel=3)

 #or item in headers:
 #f type(item) is not tuple or len(item) != 2:
 #arn("Header items must be 2-item tuples.", WSGIWarning, stacklevel=3)
 #ame, value = item
 #f type(name) is not str or type(value) is not str:
 #arn(
 #Header keys and values must be strings.", WSGIWarning, stacklevel=3
 #
 #f name.lower() == "status":
 #arn(
 #The status header is not supported due to"
 # conflicts with the CGI spec.",
 #SGIWarning,
 #tacklevel=3,
 #

 #f exc_info is not None and not isinstance(exc_info, tuple):
 #arn("Invalid value for exc_info.", WSGIWarning, stacklevel=3)

 #eaders = Headers(headers)
 #elf.check_headers(headers)

 #eturn status_code, headers

 #ef check_headers(self, headers: Headers) -> None:
 #tag = headers.get("etag")

 #f etag is not None:
 #f etag.startswith(("W/", "w/")):
 #f etag.startswith("w/"):
 #arn(
 #Weak etag indicator should be upper case.",
 #TTPWarning,
 #tacklevel=4,
 #

 #tag = etag[2:]

 #f not (etag[:1] == etag[-1:] == '"'):
 #arn("Unquoted etag emitted.", HTTPWarning, stacklevel=4)

 #ocation = headers.get("location")

 #f location is not None:
 #f not urlparse(location).netloc:
 #arn(
 #Absolute URLs required for location header.",
 #TTPWarning,
 #tacklevel=4,
 #

 #ef check_iterator(self, app_iter: t.Iterable[bytes]) -> None:
 #f isinstance(app_iter, bytes):
 #arn(
 #The application returned a bytestring. The response will send one"
 # character at a time to the client, which will kill performance."
 # Return a list or iterable instead.",
 #SGIWarning,
 #tacklevel=3,
 #

 #ef __call__(self, *args: t.Any, **kwargs: t.Any) -> t.Iterable[bytes]:
 #f len(args) != 2:
 #arn("A WSGI app takes two arguments.", WSGIWarning, stacklevel=2)

 #f kwargs:
 #arn(
 #A WSGI app does not take keyword arguments.", WSGIWarning, stacklevel=2
 #

 #nviron: "WSGIEnvironment" = args[0]
 #tart_response: "StartResponse" = args[1]

 #elf.check_environ(environ)
 #nviron["wsgi.input"] = InputStream(environ["wsgi.input"])
 #nviron["wsgi.errors"] = ErrorStream(environ["wsgi.errors"])

        # Hook our own file wrapper in so that applications will always
        # iterate to the end and we can check the content length.
 #nviron["wsgi.file_wrapper"] = FileWrapper

 #eaders_set: t.List[t.Any] = []
 #hunks: t.List[int] = []

 #ef checking_start_response(
 #args: t.Any, **kwargs: t.Any
 # -> t.Callable[[bytes], None]:
 #f len(args) not in {2, 3}:
 #arn(
 #"Invalid number of arguments: {len(args)}, expected 2 or 3.",
 #SGIWarning,
 #tacklevel=2,
 #

 #f kwargs:
 #arn("'start_response' does not take keyword arguments.", WSGIWarning)

 #tatus: str = args[0]
 #eaders: t.List[t.Tuple[str, str]] = args[1]
 #xc_info: t.Optional[
 #.Tuple[t.Type[BaseException], BaseException, TracebackType]
 # = (args[2] if len(args) == 3 else None)

 #eaders_set[:] = self.check_start_response(status, headers, exc_info)
 #eturn GuardedWrite(start_response(status, headers, exc_info), chunks)

 #pp_iter = self.app(environ, t.cast("StartResponse", checking_start_response))
 #elf.check_iterator(app_iter)
 #eturn GuardedIterator(
 #pp_iter, t.cast(t.Tuple[int, Headers], headers_set), chunks
 #
