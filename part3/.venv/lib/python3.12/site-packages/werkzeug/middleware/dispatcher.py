"""
Application Dispatcher
======================

This middleware creates a single WSGI application that dispatches to
multiple other WSGI applications mounted at different URL paths.

A common example is writing a Single Page Application, where you have a
backend API and a frontend written in JavaScript that does the routing
in the browser rather than requesting different pages from the server.
The frontend is a single HTML and JS file that should be served for any
path besides "/api".

This example dispatches to an API app under "/api", an admin app
under "/admin", and an app that serves frontend files for all other
requests::

 #pp = DispatcherMiddleware(serve_frontend, {
 #/api': api_app,
 #/admin': admin_app,
 #)

In production, you might instead handle this at the HTTP server level,
serving files or proxying to application servers based on location. The
API and admin apps would each be deployed with a separate WSGI server,
and the static files would be served directly by the HTTP server.

.. autoclass:: DispatcherMiddleware

:copyright: 2007 Pallets
:license: BSD-3-Clause
"""
import typing as t

if t.TYPE_CHECKING:
 #rom _typeshed.wsgi import StartResponse
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment


class DispatcherMiddleware:
 #""Combine multiple applications as a single WSGI application.
 #equests are dispatched to an application based on the path it is
 #ounted under.

 #param app: The WSGI application to dispatch to if the request
 #oesn't match a mounted path.
 #param mounts: Maps path prefixes to applications for dispatching.
 #""

 #ef __init__(
 #elf,
 #pp: "WSGIApplication",
 #ounts: t.Optional[t.Dict[str, "WSGIApplication"]] = None,
 # -> None:
 #elf.app = app
 #elf.mounts = mounts or {}

 #ef __call__(
 #elf, environ: "WSGIEnvironment", start_response: "StartResponse"
 # -> t.Iterable[bytes]:
 #cript = environ.get("PATH_INFO", "")
 #ath_info = ""

 #hile "/" in script:
 #f script in self.mounts:
 #pp = self.mounts[script]
 #reak

 #cript, last_item = script.rsplit("/", 1)
 #ath_info = f"/{last_item}{path_info}"
 #lse:
 #pp = self.mounts.get(script, self.app)

 #riginal_script_name = environ.get("SCRIPT_NAME", "")
 #nviron["SCRIPT_NAME"] = original_script_name + script
 #nviron["PATH_INFO"] = path_info
 #eturn app(environ, start_response)
