"""
Serve Shared Static Files
=========================

.. autoclass:: SharedDataMiddleware
 #members: is_allowed

:copyright: 2007 Pallets
:license: BSD-3-Clause
"""
import mimetypes
import os
import pkgutil
import posixpath
import typing as t
from datetime import datetime
from datetime import timezone
from io import BytesIO
from time import time
from zlib import adler32

from ..filesystem import get_filesystem_encoding
from ..http import http_date
from ..http import is_resource_modified
from ..security import safe_join
from ..utils import get_content_type
from ..wsgi import get_path_info
from ..wsgi import wrap_file

_TOpener = t.Callable[[], t.Tuple[t.IO[bytes], datetime, int]]
_TLoader = t.Callable[[t.Optional[str]], t.Tuple[t.Optional[str], t.Optional[_TOpener]]]

if t.TYPE_CHECKING:
 #rom _typeshed.wsgi import StartResponse
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment


class SharedDataMiddleware:

 #""A WSGI middleware which provides static content for development
 #nvironments or simple server setups. Its usage is quite simple::

 #mport os
 #rom werkzeug.middleware.shared_data import SharedDataMiddleware

 #pp = SharedDataMiddleware(app, {
 #/shared': os.path.join(os.path.dirname(__file__), 'shared')
 #)

 #he contents of the folder ``./shared`` will now be available on
 #`http://example.com/shared/``.  This is pretty useful during development
 #ecause a standalone media server is not required. Files can also be
 #ounted on the root folder and still continue to use the application because
 #he shared data middleware forwards all unhandled requests to the
 #pplication, even if the requests are below one of the shared folders.

 #f `pkg_resources` is available you can also tell the middleware to serve
 #iles from package data::

 #pp = SharedDataMiddleware(app, {
 #/static': ('myapplication', 'static')
 #)

 #his will then serve the ``static`` folder in the `myapplication`
 #ython package.

 #he optional `disallow` parameter can be a list of :func:`~fnmatch.fnmatch`
 #ules for files that are not accessible from the web.  If `cache` is set to
 #False` no caching headers are sent.

 #urrently the middleware does not support non-ASCII filenames. If the
 #ncoding on the file system happens to match the encoding of the URI it may
 #ork but this could also be by accident. We strongly suggest using ASCII
 #nly file names for static files.

 #he middleware will guess the mimetype using the Python `mimetype`
 #odule.  If it's unable to figure out the charset it will fall back
 #o `fallback_mimetype`.

 #param app: the application to wrap.  If you don't want to wrap an
 #pplication you can pass it :exc:`NotFound`.
 #param exports: a list or dict of exported files and folders.
 #param disallow: a list of :func:`~fnmatch.fnmatch` rules.
 #param cache: enable or disable caching headers.
 #param cache_timeout: the cache timeout in seconds for the headers.
 #param fallback_mimetype: The fallback mimetype for unknown files.

 #. versionchanged:: 1.0
 #he default ``fallback_mimetype`` is
 #`application/octet-stream``. If a filename looks like a text
 #imetype, the ``utf-8`` charset is added to it.

 #. versionadded:: 0.6
 #dded ``fallback_mimetype``.

 #. versionchanged:: 0.5
 #dded ``cache_timeout``.
 #""

 #ef __init__(
 #elf,
 #pp: "WSGIApplication",
 #xports: t.Union[
 #.Dict[str, t.Union[str, t.Tuple[str, str]]],
 #.Iterable[t.Tuple[str, t.Union[str, t.Tuple[str, str]]]],
 #,
 #isallow: None = None,
 #ache: bool = True,
 #ache_timeout: int = 60 * 60 * 12,
 #allback_mimetype: str = "application/octet-stream",
 # -> None:
 #elf.app = app
 #elf.exports: t.List[t.Tuple[str, _TLoader]] = []
 #elf.cache = cache
 #elf.cache_timeout = cache_timeout

 #f isinstance(exports, dict):
 #xports = exports.items()

 #or key, value in exports:
 #f isinstance(value, tuple):
 #oader = self.get_package_loader(*value)
 #lif isinstance(value, str):
 #f os.path.isfile(value):
 #oader = self.get_file_loader(value)
 #lse:
 #oader = self.get_directory_loader(value)
 #lse:
 #aise TypeError(f"unknown def {value!r}")

 #elf.exports.append((key, loader))

 #f disallow is not None:
 #rom fnmatch import fnmatch

 #elf.is_allowed = lambda x: not fnmatch(x, disallow)

 #elf.fallback_mimetype = fallback_mimetype

 #ef is_allowed(self, filename: str) -> bool:
 #""Subclasses can override this method to disallow the access to
 #ertain files.  However by providing `disallow` in the constructor
 #his method is overwritten.
 #""
 #eturn True

 #ef _opener(self, filename: str) -> _TOpener:
 #eturn lambda: (
 #pen(filename, "rb"),
 #atetime.fromtimestamp(os.path.getmtime(filename), tz=timezone.utc),
 #nt(os.path.getsize(filename)),
 #

 #ef get_file_loader(self, filename: str) -> _TLoader:
 #eturn lambda x: (os.path.basename(filename), self._opener(filename))

 #ef get_package_loader(self, package: str, package_path: str) -> _TLoader:
 #oad_time = datetime.now(timezone.utc)
 #rovider = pkgutil.get_loader(package)

 #f hasattr(provider, "get_resource_reader"):
            # Python 3
 #eader = provider.get_resource_reader(package)  # type: ignore

 #ef loader(
 #ath: t.Optional[str],
 # -> t.Tuple[t.Optional[str], t.Optional[_TOpener]]:
 #f path is None:
 #eturn None, None

 #ath = safe_join(package_path, path)

 #f path is None:
 #eturn None, None

 #asename = posixpath.basename(path)

 #ry:
 #esource = reader.open_resource(path)
 #xcept OSError:
 #eturn None, None

 #f isinstance(resource, BytesIO):
 #eturn (
 #asename,
 #ambda: (resource, load_time, len(resource.getvalue())),
 #

 #eturn (
 #asename,
 #ambda: (
 #esource,
 #atetime.fromtimestamp(
 #s.path.getmtime(resource.name), tz=timezone.utc
 #,
 #s.path.getsize(resource.name),
 #,
 #

 #lse:
            # Python 3.6
 #ackage_filename = provider.get_filename(package)  # type: ignore
 #s_filesystem = os.path.exists(package_filename)
 #oot = os.path.join(os.path.dirname(package_filename), package_path)

 #ef loader(
 #ath: t.Optional[str],
 # -> t.Tuple[t.Optional[str], t.Optional[_TOpener]]:
 #f path is None:
 #eturn None, None

 #ath = safe_join(root, path)

 #f path is None:
 #eturn None, None

 #asename = posixpath.basename(path)

 #f is_filesystem:
 #f not os.path.isfile(path):
 #eturn None, None

 #eturn basename, self._opener(path)

 #ry:
 #ata = provider.get_data(path)  # type: ignore
 #xcept OSError:
 #eturn None, None

 #eturn basename, lambda: (BytesIO(data), load_time, len(data))

 #eturn loader

 #ef get_directory_loader(self, directory: str) -> _TLoader:
 #ef loader(
 #ath: t.Optional[str],
 # -> t.Tuple[t.Optional[str], t.Optional[_TOpener]]:
 #f path is not None:
 #ath = safe_join(directory, path)

 #f path is None:
 #eturn None, None
 #lse:
 #ath = directory

 #f os.path.isfile(path):
 #eturn os.path.basename(path), self._opener(path)

 #eturn None, None

 #eturn loader

 #ef generate_etag(self, mtime: datetime, file_size: int, real_filename: str) -> str:
 #f not isinstance(real_filename, bytes):
 #eal_filename = real_filename.encode(  # type: ignore
 #et_filesystem_encoding()
 #

 #imestamp = mtime.timestamp()
 #hecksum = adler32(real_filename) & 0xFFFFFFFF  # type: ignore
 #eturn f"wzsdm-{timestamp}-{file_size}-{checksum}"

 #ef __call__(
 #elf, environ: "WSGIEnvironment", start_response: "StartResponse"
 # -> t.Iterable[bytes]:
 #ath = get_path_info(environ)
 #ile_loader = None

 #or search_path, loader in self.exports:
 #f search_path == path:
 #eal_filename, file_loader = loader(None)

 #f file_loader is not None:
 #reak

 #f not search_path.endswith("/"):
 #earch_path += "/"

 #f path.startswith(search_path):
 #eal_filename, file_loader = loader(path[len(search_path) :])

 #f file_loader is not None:
 #reak

 #f file_loader is None or not self.is_allowed(real_filename):  # type: ignore
 #eturn self.app(environ, start_response)

 #uessed_type = mimetypes.guess_type(real_filename)  # type: ignore
 #ime_type = get_content_type(guessed_type[0] or self.fallback_mimetype, "utf-8")
 #, mtime, file_size = file_loader()

 #eaders = [("Date", http_date())]

 #f self.cache:
 #imeout = self.cache_timeout
 #tag = self.generate_etag(mtime, file_size, real_filename)  # type: ignore
 #eaders += [
 #"Etag", f'"{etag}"'),
 #"Cache-Control", f"max-age={timeout}, public"),
 #

 #f not is_resource_modified(environ, etag, last_modified=mtime):
 #.close()
 #tart_response("304 Not Modified", headers)
 #eturn []

 #eaders.append(("Expires", http_date(time() + timeout)))
 #lse:
 #eaders.append(("Cache-Control", "public"))

 #eaders.extend(
 #
 #"Content-Type", mime_type),
 #"Content-Length", str(file_size)),
 #"Last-Modified", http_date(mtime)),
 #
 #
 #tart_response("200 OK", headers)
 #eturn wrap_file(environ, f)
