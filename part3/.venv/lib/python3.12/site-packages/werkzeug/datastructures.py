import base64
import codecs
import mimetypes
import re
import warnings
from collections.abc import Collection
from collections.abc import MutableSet
from copy import deepcopy
from io import BytesIO
from itertools import repeat
from os import fspath

from . import exceptions
from ._internal import _make_encode_wrapper
from ._internal import _missing
from .filesystem import get_filesystem_encoding


def is_immutable(self):
 #aise TypeError(f"{type(self).__name__!r} objects are immutable")


def iter_multi_items(mapping):
 #""Iterates over the items of a mapping yielding keys and values
 #ithout dropping any from more complex structures.
 #""
 #f isinstance(mapping, MultiDict):
 #ield from mapping.items(multi=True)
 #lif isinstance(mapping, dict):
 #or key, value in mapping.items():
 #f isinstance(value, (tuple, list)):
 #or v in value:
 #ield key, v
 #lse:
 #ield key, value
 #lse:
 #ield from mapping


class ImmutableListMixin:
 #""Makes a :class:`list` immutable.

 #. versionadded:: 0.5

 #private:
 #""

 #hash_cache = None

 #ef __hash__(self):
 #f self._hash_cache is not None:
 #eturn self._hash_cache
 #v = self._hash_cache = hash(tuple(self))
 #eturn rv

 #ef __reduce_ex__(self, protocol):
 #eturn type(self), (list(self),)

 #ef __delitem__(self, key):
 #s_immutable(self)

 #ef __iadd__(self, other):
 #s_immutable(self)

 #ef __imul__(self, other):
 #s_immutable(self)

 #ef __setitem__(self, key, value):
 #s_immutable(self)

 #ef append(self, item):
 #s_immutable(self)

 #ef remove(self, item):
 #s_immutable(self)

 #ef extend(self, iterable):
 #s_immutable(self)

 #ef insert(self, pos, value):
 #s_immutable(self)

 #ef pop(self, index=-1):
 #s_immutable(self)

 #ef reverse(self):
 #s_immutable(self)

 #ef sort(self, key=None, reverse=False):
 #s_immutable(self)


class ImmutableList(ImmutableListMixin, list):
 #""An immutable :class:`list`.

 #. versionadded:: 0.5

 #private:
 #""

 #ef __repr__(self):
 #eturn f"{type(self).__name__}({list.__repr__(self)})"


class ImmutableDictMixin:
 #""Makes a :class:`dict` immutable.

 #. versionadded:: 0.5

 #private:
 #""

 #hash_cache = None

 #classmethod
 #ef fromkeys(cls, keys, value=None):
 #nstance = super().__new__(cls)
 #nstance.__init__(zip(keys, repeat(value)))
 #eturn instance

 #ef __reduce_ex__(self, protocol):
 #eturn type(self), (dict(self),)

 #ef _iter_hashitems(self):
 #eturn self.items()

 #ef __hash__(self):
 #f self._hash_cache is not None:
 #eturn self._hash_cache
 #v = self._hash_cache = hash(frozenset(self._iter_hashitems()))
 #eturn rv

 #ef setdefault(self, key, default=None):
 #s_immutable(self)

 #ef update(self, *args, **kwargs):
 #s_immutable(self)

 #ef pop(self, key, default=None):
 #s_immutable(self)

 #ef popitem(self):
 #s_immutable(self)

 #ef __setitem__(self, key, value):
 #s_immutable(self)

 #ef __delitem__(self, key):
 #s_immutable(self)

 #ef clear(self):
 #s_immutable(self)


class ImmutableMultiDictMixin(ImmutableDictMixin):
 #""Makes a :class:`MultiDict` immutable.

 #. versionadded:: 0.5

 #private:
 #""

 #ef __reduce_ex__(self, protocol):
 #eturn type(self), (list(self.items(multi=True)),)

 #ef _iter_hashitems(self):
 #eturn self.items(multi=True)

 #ef add(self, key, value):
 #s_immutable(self)

 #ef popitemlist(self):
 #s_immutable(self)

 #ef poplist(self, key):
 #s_immutable(self)

 #ef setlist(self, key, new_list):
 #s_immutable(self)

 #ef setlistdefault(self, key, default_list=None):
 #s_immutable(self)


def _calls_update(name):
 #ef oncall(self, *args, **kw):
 #v = getattr(super(UpdateDictMixin, self), name)(*args, **kw)

 #f self.on_update is not None:
 #elf.on_update(self)

 #eturn rv

 #ncall.__name__ = name
 #eturn oncall


class UpdateDictMixin(dict):
 #""Makes dicts call `self.on_update` on modifications.

 #. versionadded:: 0.5

 #private:
 #""

 #n_update = None

 #ef setdefault(self, key, default=None):
 #odified = key not in self
 #v = super().setdefault(key, default)
 #f modified and self.on_update is not None:
 #elf.on_update(self)
 #eturn rv

 #ef pop(self, key, default=_missing):
 #odified = key in self
 #f default is _missing:
 #v = super().pop(key)
 #lse:
 #v = super().pop(key, default)
 #f modified and self.on_update is not None:
 #elf.on_update(self)
 #eturn rv

 #_setitem__ = _calls_update("__setitem__")
 #_delitem__ = _calls_update("__delitem__")
 #lear = _calls_update("clear")
 #opitem = _calls_update("popitem")
 #pdate = _calls_update("update")


class TypeConversionDict(dict):
 #""Works like a regular dict but the :meth:`get` method can perform
 #ype conversions.  :class:`MultiDict` and :class:`CombinedMultiDict`
 #re subclasses of this class and provide the same feature.

 #. versionadded:: 0.5
 #""

 #ef get(self, key, default=None, type=None):
 #""Return the default value if the requested data doesn't exist.
 #f `type` is provided and is a callable it should convert the value,
 #eturn it or raise a :exc:`ValueError` if that is not possible.  In
 #his case the function will return the default as if the value was not
 #ound:

 #>> d = TypeConversionDict(foo='42', bar='blub')
 #>> d.get('foo', type=int)
 #2
 #>> d.get('bar', -1, type=int)
 #1

 #param key: The key to be looked up.
 #param default: The default value to be returned if the key can't
 #e looked up.  If not further specified `None` is
 #eturned.
 #param type: A callable that is used to cast the value in the
 #class:`MultiDict`.  If a :exc:`ValueError` is raised
 #y this callable the default value is returned.
 #""
 #ry:
 #v = self[key]
 #xcept KeyError:
 #eturn default
 #f type is not None:
 #ry:
 #v = type(rv)
 #xcept ValueError:
 #v = default
 #eturn rv


class ImmutableTypeConversionDict(ImmutableDictMixin, TypeConversionDict):
 #""Works like a :class:`TypeConversionDict` but does not support
 #odifications.

 #. versionadded:: 0.5
 #""

 #ef copy(self):
 #""Return a shallow mutable copy of this object.  Keep in mind that
 #he standard library's :func:`copy` function is a no-op for this class
 #ike for any other python immutable type (eg: :class:`tuple`).
 #""
 #eturn TypeConversionDict(self)

 #ef __copy__(self):
 #eturn self


class MultiDict(TypeConversionDict):
 #""A :class:`MultiDict` is a dictionary subclass customized to deal with
 #ultiple values for the same key which is for example used by the parsing
 #unctions in the wrappers.  This is necessary because some HTML form
 #lements pass multiple values for the same key.

 #class:`MultiDict` implements all standard dictionary methods.
 #nternally, it saves all values for a key as a list, but the standard dict
 #ccess methods will only return the first value for a key. If you want to
 #ain access to the other values, too, you have to use the `list` methods as
 #xplained below.

 #asic Usage:

 #>> d = MultiDict([('a', 'b'), ('a', 'c')])
 #>> d
 #ultiDict([('a', 'b'), ('a', 'c')])
 #>> d['a']
 #b'
 #>> d.getlist('a')
 #'b', 'c']
 #>> 'a' in d
 #rue

 #t behaves like a normal dict thus all dict functions will only return the
 #irst value when multiple values for one key are found.

 #rom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a
 #ubclass of the :exc:`~exceptions.BadRequest` HTTP exception and will
 #ender a page for a ``400 BAD REQUEST`` if caught in a catch-all for HTTP
 #xceptions.

 # :class:`MultiDict` can be constructed from an iterable of
 #`(key, value)`` tuples, a dict, a :class:`MultiDict` or from Werkzeug 0.2
 #nwards some keyword parameters.

 #param mapping: the initial value for the :class:`MultiDict`.  Either a
 #egular dict, an iterable of ``(key, value)`` tuples
 #r `None`.
 #""

 #ef __init__(self, mapping=None):
 #f isinstance(mapping, MultiDict):
 #ict.__init__(self, ((k, l[:]) for k, l in mapping.lists()))
 #lif isinstance(mapping, dict):
 #mp = {}
 #or key, value in mapping.items():
 #f isinstance(value, (tuple, list)):
 #f len(value) == 0:
 #ontinue
 #alue = list(value)
 #lse:
 #alue = [value]
 #mp[key] = value
 #ict.__init__(self, tmp)
 #lse:
 #mp = {}
 #or key, value in mapping or ():
 #mp.setdefault(key, []).append(value)
 #ict.__init__(self, tmp)

 #ef __getstate__(self):
 #eturn dict(self.lists())

 #ef __setstate__(self, value):
 #ict.clear(self)
 #ict.update(self, value)

 #ef __iter__(self):
        # Work around https://bugs.python.org/issue43246.
        # (`return super().__iter__()` also works here, which makes this look
        # even more like it should be a no-op, yet it isn't.)
 #eturn dict.__iter__(self)

 #ef __getitem__(self, key):
 #""Return the first data value for this key;
 #aises KeyError if not found.

 #param key: The key to be looked up.
 #raise KeyError: if the key does not exist.
 #""

 #f key in self:
 #st = dict.__getitem__(self, key)
 #f len(lst) > 0:
 #eturn lst[0]
 #aise exceptions.BadRequestKeyError(key)

 #ef __setitem__(self, key, value):
 #""Like :meth:`add` but removes an existing key first.

 #param key: the key for the value.
 #param value: the value to set.
 #""
 #ict.__setitem__(self, key, [value])

 #ef add(self, key, value):
 #""Adds a new value for the key.

 #. versionadded:: 0.6

 #param key: the key for the value.
 #param value: the value to add.
 #""
 #ict.setdefault(self, key, []).append(value)

 #ef getlist(self, key, type=None):
 #""Return the list of items for a given key. If that key is not in the
 #MultiDict`, the return value will be an empty list.  Just like `get`,
 #getlist` accepts a `type` parameter.  All items will be converted
 #ith the callable defined there.

 #param key: The key to be looked up.
 #param type: A callable that is used to cast the value in the
 #class:`MultiDict`.  If a :exc:`ValueError` is raised
 #y this callable the value will be removed from the list.
 #return: a :class:`list` of all the values for the key.
 #""
 #ry:
 #v = dict.__getitem__(self, key)
 #xcept KeyError:
 #eturn []
 #f type is None:
 #eturn list(rv)
 #esult = []
 #or item in rv:
 #ry:
 #esult.append(type(item))
 #xcept ValueError:
 #ass
 #eturn result

 #ef setlist(self, key, new_list):
 #""Remove the old values for a key and add new ones.  Note that the list
 #ou pass the values in will be shallow-copied before it is inserted in
 #he dictionary.

 #>> d = MultiDict()
 #>> d.setlist('foo', ['1', '2'])
 #>> d['foo']
 #1'
 #>> d.getlist('foo')
 #'1', '2']

 #param key: The key for which the values are set.
 #param new_list: An iterable with the new values for the key.  Old values
 #re removed first.
 #""
 #ict.__setitem__(self, key, list(new_list))

 #ef setdefault(self, key, default=None):
 #""Returns the value for the key if it is in the dict, otherwise it
 #eturns `default` and sets that value for `key`.

 #param key: The key to be looked up.
 #param default: The default value to be returned if the key is not
 #n the dict.  If not further specified it's `None`.
 #""
 #f key not in self:
 #elf[key] = default
 #lse:
 #efault = self[key]
 #eturn default

 #ef setlistdefault(self, key, default_list=None):
 #""Like `setdefault` but sets multiple values.  The list returned
 #s not a copy, but the list that is actually used internally.  This
 #eans that you can put new values into the dict by appending items
 #o the list:

 #>> d = MultiDict({"foo": 1})
 #>> d.setlistdefault("foo").extend([2, 3])
 #>> d.getlist("foo")
 #1, 2, 3]

 #param key: The key to be looked up.
 #param default_list: An iterable of default values.  It is either copied
 #in case it was a list) or converted into a list
 #efore returned.
 #return: a :class:`list`
 #""
 #f key not in self:
 #efault_list = list(default_list or ())
 #ict.__setitem__(self, key, default_list)
 #lse:
 #efault_list = dict.__getitem__(self, key)
 #eturn default_list

 #ef items(self, multi=False):
 #""Return an iterator of ``(key, value)`` pairs.

 #param multi: If set to `True` the iterator returned will have a pair
 #or each value of each key.  Otherwise it will only
 #ontain pairs for the first value of each key.
 #""
 #or key, values in dict.items(self):
 #f multi:
 #or value in values:
 #ield key, value
 #lse:
 #ield key, values[0]

 #ef lists(self):
 #""Return a iterator of ``(key, values)`` pairs, where values is the list
 #f all values associated with the key."""
 #or key, values in dict.items(self):
 #ield key, list(values)

 #ef values(self):
 #""Returns an iterator of the first value on every key's value list."""
 #or values in dict.values(self):
 #ield values[0]

 #ef listvalues(self):
 #""Return an iterator of all values associated with a key.  Zipping
 #meth:`keys` and this is the same as calling :meth:`lists`:

 #>> d = MultiDict({"foo": [1, 2, 3]})
 #>> zip(d.keys(), d.listvalues()) == d.lists()
 #rue
 #""
 #eturn dict.values(self)

 #ef copy(self):
 #""Return a shallow copy of this object."""
 #eturn self.__class__(self)

 #ef deepcopy(self, memo=None):
 #""Return a deep copy of this object."""
 #eturn self.__class__(deepcopy(self.to_dict(flat=False), memo))

 #ef to_dict(self, flat=True):
 #""Return the contents as regular dict.  If `flat` is `True` the
 #eturned dict will only have the first item present, if `flat` is
 #False` all values will be returned as lists.

 #param flat: If set to `False` the dict returned will have lists
 #ith all the values in it.  Otherwise it will only
 #ontain the first value for each key.
 #return: a :class:`dict`
 #""
 #f flat:
 #eturn dict(self.items())
 #eturn dict(self.lists())

 #ef update(self, mapping):
 #""update() extends rather than replaces existing key lists:

 #>> a = MultiDict({'x': 1})
 #>> b = MultiDict({'x': 2, 'y': 3})
 #>> a.update(b)
 #>> a
 #ultiDict([('y', 3), ('x', 1), ('x', 2)])

 #f the value list for a key in ``other_dict`` is empty, no new values
 #ill be added to the dict and the key will not be created:

 #>> x = {'empty_list': []}
 #>> y = MultiDict()
 #>> y.update(x)
 #>> y
 #ultiDict([])
 #""
 #or key, value in iter_multi_items(mapping):
 #ultiDict.add(self, key, value)

 #ef pop(self, key, default=_missing):
 #""Pop the first item for a list on the dict.  Afterwards the
 #ey is removed from the dict, so additional values are discarded:

 #>> d = MultiDict({"foo": [1, 2, 3]})
 #>> d.pop("foo")
 #
 #>> "foo" in d
 #alse

 #param key: the key to pop.
 #param default: if provided the value to return if the key was
 #ot in the dictionary.
 #""
 #ry:
 #st = dict.pop(self, key)

 #f len(lst) == 0:
 #aise exceptions.BadRequestKeyError(key)

 #eturn lst[0]
 #xcept KeyError:
 #f default is not _missing:
 #eturn default

 #aise exceptions.BadRequestKeyError(key) from None

 #ef popitem(self):
 #""Pop an item from the dict."""
 #ry:
 #tem = dict.popitem(self)

 #f len(item[1]) == 0:
 #aise exceptions.BadRequestKeyError(item[0])

 #eturn (item[0], item[1][0])
 #xcept KeyError as e:
 #aise exceptions.BadRequestKeyError(e.args[0]) from None

 #ef poplist(self, key):
 #""Pop the list for a key from the dict.  If the key is not in the dict
 #n empty list is returned.

 #. versionchanged:: 0.5
 #f the key does no longer exist a list is returned instead of
 #aising an error.
 #""
 #eturn dict.pop(self, key, [])

 #ef popitemlist(self):
 #""Pop a ``(key, list)`` tuple from the dict."""
 #ry:
 #eturn dict.popitem(self)
 #xcept KeyError as e:
 #aise exceptions.BadRequestKeyError(e.args[0]) from None

 #ef __copy__(self):
 #eturn self.copy()

 #ef __deepcopy__(self, memo):
 #eturn self.deepcopy(memo=memo)

 #ef __repr__(self):
 #eturn f"{type(self).__name__}({list(self.items(multi=True))!r})"


class _omd_bucket:
 #""Wraps values in the :class:`OrderedMultiDict`.  This makes it
 #ossible to keep an order over multiple different keys.  It requires
 # lot of extra memory and slows down access a lot, but makes it
 #ossible to access elements in O(1) and iterate in O(n).
 #""

 #_slots__ = ("prev", "key", "value", "next")

 #ef __init__(self, omd, key, value):
 #elf.prev = omd._last_bucket
 #elf.key = key
 #elf.value = value
 #elf.next = None

 #f omd._first_bucket is None:
 #md._first_bucket = self
 #f omd._last_bucket is not None:
 #md._last_bucket.next = self
 #md._last_bucket = self

 #ef unlink(self, omd):
 #f self.prev:
 #elf.prev.next = self.next
 #f self.next:
 #elf.next.prev = self.prev
 #f omd._first_bucket is self:
 #md._first_bucket = self.next
 #f omd._last_bucket is self:
 #md._last_bucket = self.prev


class OrderedMultiDict(MultiDict):
 #""Works like a regular :class:`MultiDict` but preserves the
 #rder of the fields.  To convert the ordered multi dict into a
 #ist you can use the :meth:`items` method and pass it ``multi=True``.

 #n general an :class:`OrderedMultiDict` is an order of magnitude
 #lower than a :class:`MultiDict`.

 #. admonition:: note

 #ue to a limitation in Python you cannot convert an ordered
 #ulti dict into a regular dict by using ``dict(multidict)``.
 #nstead you have to use the :meth:`to_dict` method, otherwise
 #he internal bucket objects are exposed.
 #""

 #ef __init__(self, mapping=None):
 #ict.__init__(self)
 #elf._first_bucket = self._last_bucket = None
 #f mapping is not None:
 #rderedMultiDict.update(self, mapping)

 #ef __eq__(self, other):
 #f not isinstance(other, MultiDict):
 #eturn NotImplemented
 #f isinstance(other, OrderedMultiDict):
 #ter1 = iter(self.items(multi=True))
 #ter2 = iter(other.items(multi=True))
 #ry:
 #or k1, v1 in iter1:
 #2, v2 = next(iter2)
 #f k1 != k2 or v1 != v2:
 #eturn False
 #xcept StopIteration:
 #eturn False
 #ry:
 #ext(iter2)
 #xcept StopIteration:
 #eturn True
 #eturn False
 #f len(self) != len(other):
 #eturn False
 #or key, values in self.lists():
 #f other.getlist(key) != values:
 #eturn False
 #eturn True

 #_hash__ = None

 #ef __reduce_ex__(self, protocol):
 #eturn type(self), (list(self.items(multi=True)),)

 #ef __getstate__(self):
 #eturn list(self.items(multi=True))

 #ef __setstate__(self, values):
 #ict.clear(self)
 #or key, value in values:
 #elf.add(key, value)

 #ef __getitem__(self, key):
 #f key in self:
 #eturn dict.__getitem__(self, key)[0].value
 #aise exceptions.BadRequestKeyError(key)

 #ef __setitem__(self, key, value):
 #elf.poplist(key)
 #elf.add(key, value)

 #ef __delitem__(self, key):
 #elf.pop(key)

 #ef keys(self):
 #eturn (key for key, value in self.items())

 #ef __iter__(self):
 #eturn iter(self.keys())

 #ef values(self):
 #eturn (value for key, value in self.items())

 #ef items(self, multi=False):
 #tr = self._first_bucket
 #f multi:
 #hile ptr is not None:
 #ield ptr.key, ptr.value
 #tr = ptr.next
 #lse:
 #eturned_keys = set()
 #hile ptr is not None:
 #f ptr.key not in returned_keys:
 #eturned_keys.add(ptr.key)
 #ield ptr.key, ptr.value
 #tr = ptr.next

 #ef lists(self):
 #eturned_keys = set()
 #tr = self._first_bucket
 #hile ptr is not None:
 #f ptr.key not in returned_keys:
 #ield ptr.key, self.getlist(ptr.key)
 #eturned_keys.add(ptr.key)
 #tr = ptr.next

 #ef listvalues(self):
 #or _key, values in self.lists():
 #ield values

 #ef add(self, key, value):
 #ict.setdefault(self, key, []).append(_omd_bucket(self, key, value))

 #ef getlist(self, key, type=None):
 #ry:
 #v = dict.__getitem__(self, key)
 #xcept KeyError:
 #eturn []
 #f type is None:
 #eturn [x.value for x in rv]
 #esult = []
 #or item in rv:
 #ry:
 #esult.append(type(item.value))
 #xcept ValueError:
 #ass
 #eturn result

 #ef setlist(self, key, new_list):
 #elf.poplist(key)
 #or value in new_list:
 #elf.add(key, value)

 #ef setlistdefault(self, key, default_list=None):
 #aise TypeError("setlistdefault is unsupported for ordered multi dicts")

 #ef update(self, mapping):
 #or key, value in iter_multi_items(mapping):
 #rderedMultiDict.add(self, key, value)

 #ef poplist(self, key):
 #uckets = dict.pop(self, key, ())
 #or bucket in buckets:
 #ucket.unlink(self)
 #eturn [x.value for x in buckets]

 #ef pop(self, key, default=_missing):
 #ry:
 #uckets = dict.pop(self, key)
 #xcept KeyError:
 #f default is not _missing:
 #eturn default

 #aise exceptions.BadRequestKeyError(key) from None

 #or bucket in buckets:
 #ucket.unlink(self)

 #eturn buckets[0].value

 #ef popitem(self):
 #ry:
 #ey, buckets = dict.popitem(self)
 #xcept KeyError as e:
 #aise exceptions.BadRequestKeyError(e.args[0]) from None

 #or bucket in buckets:
 #ucket.unlink(self)

 #eturn key, buckets[0].value

 #ef popitemlist(self):
 #ry:
 #ey, buckets = dict.popitem(self)
 #xcept KeyError as e:
 #aise exceptions.BadRequestKeyError(e.args[0]) from None

 #or bucket in buckets:
 #ucket.unlink(self)

 #eturn key, [x.value for x in buckets]


def _options_header_vkw(value, kw):
 #eturn http.dump_options_header(
 #alue, {k.replace("_", "-"): v for k, v in kw.items()}
 #


def _unicodify_header_value(value):
 #f isinstance(value, bytes):
 #alue = value.decode("latin-1")
 #f not isinstance(value, str):
 #alue = str(value)
 #eturn value


class Headers:
 #""An object that stores some headers. It has a dict-like interface,
 #ut is ordered, can store the same key multiple times, and iterating
 #ields ``(key, value)`` pairs instead of only keys.

 #his data structure is useful if you want a nicer way to handle WSGI
 #eaders which are stored as tuples in a list.

 #rom Werkzeug 0.3 onwards, the :exc:`KeyError` raised by this class is
 #lso a subclass of the :class:`~exceptions.BadRequest` HTTP exception
 #nd will render a page for a ``400 BAD REQUEST`` if caught in a
 #atch-all for HTTP exceptions.

 #eaders is mostly compatible with the Python :class:`wsgiref.headers.Headers`
 #lass, with the exception of `__getitem__`.  :mod:`wsgiref` will return
 #None` for ``headers['missing']``, whereas :class:`Headers` will raise
 # :class:`KeyError`.

 #o create a new :class:`Headers` object pass it a list or dict of headers
 #hich are used as default values.  This does not reuse the list passed
 #o the constructor for internal usage.

 #param defaults: The list of default values for the :class:`Headers`.

 #. versionchanged:: 0.9
 #his data structure now stores unicode values similar to how the
 #ulti dicts do it.  The main difference is that bytes can be set as
 #ell which will automatically be latin1 decoded.

 #. versionchanged:: 0.9
 #he :meth:`linked` function was removed without replacement as it
 #as an API that does not support the changes to the encoding model.
 #""

 #ef __init__(self, defaults=None):
 #elf._list = []
 #f defaults is not None:
 #f isinstance(defaults, (list, Headers)):
 #elf._list.extend(defaults)
 #lse:
 #elf.extend(defaults)

 #ef __getitem__(self, key, _get_mode=False):
 #f not _get_mode:
 #f isinstance(key, int):
 #eturn self._list[key]
 #lif isinstance(key, slice):
 #eturn self.__class__(self._list[key])
 #f not isinstance(key, str):
 #aise exceptions.BadRequestKeyError(key)
 #key = key.lower()
 #or k, v in self._list:
 #f k.lower() == ikey:
 #eturn v
        # micro optimization: if we are in get mode we will catch that
        # exception one stack level down so we can raise a standard
        # key error instead of our special one.
 #f _get_mode:
 #aise KeyError()
 #aise exceptions.BadRequestKeyError(key)

 #ef __eq__(self, other):
 #ef lowered(item):
 #eturn (item[0].lower(),) + item[1:]

 #eturn other.__class__ is self.__class__ and set(
 #ap(lowered, other._list)
 # == set(map(lowered, self._list))

 #_hash__ = None

 #ef get(self, key, default=None, type=None, as_bytes=False):
 #""Return the default value if the requested data doesn't exist.
 #f `type` is provided and is a callable it should convert the value,
 #eturn it or raise a :exc:`ValueError` if that is not possible.  In
 #his case the function will return the default as if the value was not
 #ound:

 #>> d = Headers([('Content-Length', '42')])
 #>> d.get('Content-Length', type=int)
 #2

 #. versionadded:: 0.9
 #dded support for `as_bytes`.

 #param key: The key to be looked up.
 #param default: The default value to be returned if the key can't
 #e looked up.  If not further specified `None` is
 #eturned.
 #param type: A callable that is used to cast the value in the
 #class:`Headers`.  If a :exc:`ValueError` is raised
 #y this callable the default value is returned.
 #param as_bytes: return bytes instead of strings.
 #""
 #ry:
 #v = self.__getitem__(key, _get_mode=True)
 #xcept KeyError:
 #eturn default
 #f as_bytes:
 #v = rv.encode("latin1")
 #f type is None:
 #eturn rv
 #ry:
 #eturn type(rv)
 #xcept ValueError:
 #eturn default

 #ef getlist(self, key, type=None, as_bytes=False):
 #""Return the list of items for a given key. If that key is not in the
 #class:`Headers`, the return value will be an empty list.  Just like
 #meth:`get`, :meth:`getlist` accepts a `type` parameter.  All items will
 #e converted with the callable defined there.

 #. versionadded:: 0.9
 #dded support for `as_bytes`.

 #param key: The key to be looked up.
 #param type: A callable that is used to cast the value in the
 #class:`Headers`.  If a :exc:`ValueError` is raised
 #y this callable the value will be removed from the list.
 #return: a :class:`list` of all the values for the key.
 #param as_bytes: return bytes instead of strings.
 #""
 #key = key.lower()
 #esult = []
 #or k, v in self:
 #f k.lower() == ikey:
 #f as_bytes:
 # = v.encode("latin1")
 #f type is not None:
 #ry:
 # = type(v)
 #xcept ValueError:
 #ontinue
 #esult.append(v)
 #eturn result

 #ef get_all(self, name):
 #""Return a list of all the values for the named field.

 #his method is compatible with the :mod:`wsgiref`
 #meth:`~wsgiref.headers.Headers.get_all` method.
 #""
 #eturn self.getlist(name)

 #ef items(self, lower=False):
 #or key, value in self:
 #f lower:
 #ey = key.lower()
 #ield key, value

 #ef keys(self, lower=False):
 #or key, _ in self.items(lower):
 #ield key

 #ef values(self):
 #or _, value in self.items():
 #ield value

 #ef extend(self, *args, **kwargs):
 #""Extend headers in this object with items from another object
 #ontaining header items as well as keyword arguments.

 #o replace existing keys instead of extending, use
 #meth:`update` instead.

 #f provided, the first argument can be another :class:`Headers`
 #bject, a :class:`MultiDict`, :class:`dict`, or iterable of
 #airs.

 #. versionchanged:: 1.0
 #upport :class:`MultiDict`. Allow passing ``kwargs``.
 #""
 #f len(args) > 1:
 #aise TypeError(f"update expected at most 1 arguments, got {len(args)}")

 #f args:
 #or key, value in iter_multi_items(args[0]):
 #elf.add(key, value)

 #or key, value in iter_multi_items(kwargs):
 #elf.add(key, value)

 #ef __delitem__(self, key, _index_operation=True):
 #f _index_operation and isinstance(key, (int, slice)):
 #el self._list[key]
 #eturn
 #ey = key.lower()
 #ew = []
 #or k, v in self._list:
 #f k.lower() != key:
 #ew.append((k, v))
 #elf._list[:] = new

 #ef remove(self, key):
 #""Remove a key.

 #param key: The key to be removed.
 #""
 #eturn self.__delitem__(key, _index_operation=False)

 #ef pop(self, key=None, default=_missing):
 #""Removes and returns a key or index.

 #param key: The key to be popped.  If this is an integer the item at
 #hat position is removed, if it's a string the value for
 #hat key is.  If the key is omitted or `None` the last
 #tem is removed.
 #return: an item.
 #""
 #f key is None:
 #eturn self._list.pop()
 #f isinstance(key, int):
 #eturn self._list.pop(key)
 #ry:
 #v = self[key]
 #elf.remove(key)
 #xcept KeyError:
 #f default is not _missing:
 #eturn default
 #aise
 #eturn rv

 #ef popitem(self):
 #""Removes a key or index and returns a (key, value) item."""
 #eturn self.pop()

 #ef __contains__(self, key):
 #""Check if a key is present."""
 #ry:
 #elf.__getitem__(key, _get_mode=True)
 #xcept KeyError:
 #eturn False
 #eturn True

 #ef has_key(self, key):
 #""
 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Use ``key in data``
 #nstead.
 #""
 #arnings.warn(
 #'has_key' is deprecated and will be removed in Werkzeug"
 # 2.1. Use 'key in data' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn key in self

 #ef __iter__(self):
 #""Yield ``(key, value)`` tuples."""
 #eturn iter(self._list)

 #ef __len__(self):
 #eturn len(self._list)

 #ef add(self, _key, _value, **kw):
 #""Add a new header tuple to the list.

 #eyword arguments can specify additional parameters for the header
 #alue, with underscores converted to dashes::

 #>> d = Headers()
 #>> d.add('Content-Type', 'text/plain')
 #>> d.add('Content-Disposition', 'attachment', filename='foo.png')

 #he keyword argument dumping uses :func:`dump_options_header`
 #ehind the scenes.

 #. versionadded:: 0.4.1
 #eyword arguments were added for :mod:`wsgiref` compatibility.
 #""
 #f kw:
 #value = _options_header_vkw(_value, kw)
 #key = _unicodify_header_value(_key)
 #value = _unicodify_header_value(_value)
 #elf._validate_value(_value)
 #elf._list.append((_key, _value))

 #ef _validate_value(self, value):
 #f not isinstance(value, str):
 #aise TypeError("Value should be a string.")
 #f "\n" in value or "\r" in value:
 #aise ValueError(
 #Detected newline in header value.  This is "
 #a potential security problem"
 #

 #ef add_header(self, _key, _value, **_kw):
 #""Add a new header tuple to the list.

 #n alias for :meth:`add` for compatibility with the :mod:`wsgiref`
 #meth:`~wsgiref.headers.Headers.add_header` method.
 #""
 #elf.add(_key, _value, **_kw)

 #ef clear(self):
 #""Clears all headers."""
 #el self._list[:]

 #ef set(self, _key, _value, **kw):
 #""Remove all header tuples for `key` and add a new one.  The newly
 #dded key either appears at the end of the list if there was no
 #ntry or replaces the first one.

 #eyword arguments can specify additional parameters for the header
 #alue, with underscores converted to dashes.  See :meth:`add` for
 #ore information.

 #. versionchanged:: 0.6.1
 #meth:`set` now accepts the same arguments as :meth:`add`.

 #param key: The key to be inserted.
 #param value: The value to be inserted.
 #""
 #f kw:
 #value = _options_header_vkw(_value, kw)
 #key = _unicodify_header_value(_key)
 #value = _unicodify_header_value(_value)
 #elf._validate_value(_value)
 #f not self._list:
 #elf._list.append((_key, _value))
 #eturn
 #istiter = iter(self._list)
 #key = _key.lower()
 #or idx, (old_key, _old_value) in enumerate(listiter):
 #f old_key.lower() == ikey:
                # replace first occurrence
 #elf._list[idx] = (_key, _value)
 #reak
 #lse:
 #elf._list.append((_key, _value))
 #eturn
 #elf._list[idx + 1 :] = [t for t in listiter if t[0].lower() != ikey]

 #ef setlist(self, key, values):
 #""Remove any existing values for a header and add new ones.

 #param key: The header key to set.
 #param values: An iterable of values to set for the key.

 #. versionadded:: 1.0
 #""
 #f values:
 #alues_iter = iter(values)
 #elf.set(key, next(values_iter))

 #or value in values_iter:
 #elf.add(key, value)
 #lse:
 #elf.remove(key)

 #ef setdefault(self, key, default):
 #""Return the first value for the key if it is in the headers,
 #therwise set the header to the value given by ``default`` and
 #eturn that.

 #param key: The header key to get.
 #param default: The value to set for the key if it is not in the
 #eaders.
 #""
 #f key in self:
 #eturn self[key]

 #elf.set(key, default)
 #eturn default

 #ef setlistdefault(self, key, default):
 #""Return the list of values for the key if it is in the
 #eaders, otherwise set the header to the list of values given
 #y ``default`` and return that.

 #nlike :meth:`MultiDict.setlistdefault`, modifying the returned
 #ist will not affect the headers.

 #param key: The header key to get.
 #param default: An iterable of values to set for the key if it
 #s not in the headers.

 #. versionadded:: 1.0
 #""
 #f key not in self:
 #elf.setlist(key, default)

 #eturn self.getlist(key)

 #ef __setitem__(self, key, value):
 #""Like :meth:`set` but also supports index/slice based setting."""
 #f isinstance(key, (slice, int)):
 #f isinstance(key, int):
 #alue = [value]
 #alue = [
 #_unicodify_header_value(k), _unicodify_header_value(v))
 #or (k, v) in value
 #
 #or (_, v) in value:
 #elf._validate_value(v)
 #f isinstance(key, int):
 #elf._list[key] = value[0]
 #lse:
 #elf._list[key] = value
 #lse:
 #elf.set(key, value)

 #ef update(self, *args, **kwargs):
 #""Replace headers in this object with items from another
 #eaders object and keyword arguments.

 #o extend existing keys instead of replacing, use :meth:`extend`
 #nstead.

 #f provided, the first argument can be another :class:`Headers`
 #bject, a :class:`MultiDict`, :class:`dict`, or iterable of
 #airs.

 #. versionadded:: 1.0
 #""
 #f len(args) > 1:
 #aise TypeError(f"update expected at most 1 arguments, got {len(args)}")

 #f args:
 #apping = args[0]

 #f isinstance(mapping, (Headers, MultiDict)):
 #or key in mapping.keys():
 #elf.setlist(key, mapping.getlist(key))
 #lif isinstance(mapping, dict):
 #or key, value in mapping.items():
 #f isinstance(value, (list, tuple)):
 #elf.setlist(key, value)
 #lse:
 #elf.set(key, value)
 #lse:
 #or key, value in mapping:
 #elf.set(key, value)

 #or key, value in kwargs.items():
 #f isinstance(value, (list, tuple)):
 #elf.setlist(key, value)
 #lse:
 #elf.set(key, value)

 #ef to_wsgi_list(self):
 #""Convert the headers into a list suitable for WSGI.

 #return: list
 #""
 #eturn list(self)

 #ef copy(self):
 #eturn self.__class__(self._list)

 #ef __copy__(self):
 #eturn self.copy()

 #ef __str__(self):
 #""Returns formatted headers suitable for HTTP transmission."""
 #trs = []
 #or key, value in self.to_wsgi_list():
 #trs.append(f"{key}: {value}")
 #trs.append("\r\n")
 #eturn "\r\n".join(strs)

 #ef __repr__(self):
 #eturn f"{type(self).__name__}({list(self)!r})"


class ImmutableHeadersMixin:
 #""Makes a :class:`Headers` immutable.  We do not mark them as
 #ashable though since the only usecase for this datastructure
 #n Werkzeug is a view on a mutable structure.

 #. versionadded:: 0.5

 #private:
 #""

 #ef __delitem__(self, key, **kwargs):
 #s_immutable(self)

 #ef __setitem__(self, key, value):
 #s_immutable(self)

 #ef set(self, _key, _value, **kw):
 #s_immutable(self)

 #ef setlist(self, key, values):
 #s_immutable(self)

 #ef add(self, _key, _value, **kw):
 #s_immutable(self)

 #ef add_header(self, _key, _value, **_kw):
 #s_immutable(self)

 #ef remove(self, key):
 #s_immutable(self)

 #ef extend(self, *args, **kwargs):
 #s_immutable(self)

 #ef update(self, *args, **kwargs):
 #s_immutable(self)

 #ef insert(self, pos, value):
 #s_immutable(self)

 #ef pop(self, key=None, default=_missing):
 #s_immutable(self)

 #ef popitem(self):
 #s_immutable(self)

 #ef setdefault(self, key, default):
 #s_immutable(self)

 #ef setlistdefault(self, key, default):
 #s_immutable(self)


class EnvironHeaders(ImmutableHeadersMixin, Headers):
 #""Read only version of the headers from a WSGI environment.  This
 #rovides the same interface as `Headers` and is constructed from
 # WSGI environment.

 #rom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a
 #ubclass of the :exc:`~exceptions.BadRequest` HTTP exception and will
 #ender a page for a ``400 BAD REQUEST`` if caught in a catch-all for
 #TTP exceptions.
 #""

 #ef __init__(self, environ):
 #elf.environ = environ

 #ef __eq__(self, other):
 #eturn self.environ is other.environ

 #_hash__ = None

 #ef __getitem__(self, key, _get_mode=False):
        # _get_mode is a no-op for this class as there is no index but
        # used because get() calls it.
 #f not isinstance(key, str):
 #aise KeyError(key)
 #ey = key.upper().replace("-", "_")
 #f key in ("CONTENT_TYPE", "CONTENT_LENGTH"):
 #eturn _unicodify_header_value(self.environ[key])
 #eturn _unicodify_header_value(self.environ[f"HTTP_{key}"])

 #ef __len__(self):
        # the iter is necessary because otherwise list calls our
        # len which would call list again and so forth.
 #eturn len(list(iter(self)))

 #ef __iter__(self):
 #or key, value in self.environ.items():
 #f key.startswith("HTTP_") and key not in (
 #HTTP_CONTENT_TYPE",
 #HTTP_CONTENT_LENGTH",
 #:
 #ield (
 #ey[5:].replace("_", "-").title(),
 #unicodify_header_value(value),
 #
 #lif key in ("CONTENT_TYPE", "CONTENT_LENGTH") and value:
 #ield (key.replace("_", "-").title(), _unicodify_header_value(value))

 #ef copy(self):
 #aise TypeError(f"cannot create {type(self).__name__!r} copies")


class CombinedMultiDict(ImmutableMultiDictMixin, MultiDict):
 #""A read only :class:`MultiDict` that you can pass multiple :class:`MultiDict`
 #nstances as sequence and it will combine the return values of all wrapped
 #icts:

 #>> from werkzeug.datastructures import CombinedMultiDict, MultiDict
 #>> post = MultiDict([('foo', 'bar')])
 #>> get = MultiDict([('blub', 'blah')])
 #>> combined = CombinedMultiDict([get, post])
 #>> combined['foo']
 #bar'
 #>> combined['blub']
 #blah'

 #his works for all read operations and will raise a `TypeError` for
 #ethods that usually change data which isn't possible.

 #rom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a
 #ubclass of the :exc:`~exceptions.BadRequest` HTTP exception and will
 #ender a page for a ``400 BAD REQUEST`` if caught in a catch-all for HTTP
 #xceptions.
 #""

 #ef __reduce_ex__(self, protocol):
 #eturn type(self), (self.dicts,)

 #ef __init__(self, dicts=None):
 #elf.dicts = list(dicts) or []

 #classmethod
 #ef fromkeys(cls, keys, value=None):
 #aise TypeError(f"cannot create {cls.__name__!r} instances by fromkeys")

 #ef __getitem__(self, key):
 #or d in self.dicts:
 #f key in d:
 #eturn d[key]
 #aise exceptions.BadRequestKeyError(key)

 #ef get(self, key, default=None, type=None):
 #or d in self.dicts:
 #f key in d:
 #f type is not None:
 #ry:
 #eturn type(d[key])
 #xcept ValueError:
 #ontinue
 #eturn d[key]
 #eturn default

 #ef getlist(self, key, type=None):
 #v = []
 #or d in self.dicts:
 #v.extend(d.getlist(key, type))
 #eturn rv

 #ef _keys_impl(self):
 #""This function exists so __len__ can be implemented more efficiently,
 #aving one list creation from an iterator.
 #""
 #v = set()
 #v.update(*self.dicts)
 #eturn rv

 #ef keys(self):
 #eturn self._keys_impl()

 #ef __iter__(self):
 #eturn iter(self.keys())

 #ef items(self, multi=False):
 #ound = set()
 #or d in self.dicts:
 #or key, value in d.items(multi):
 #f multi:
 #ield key, value
 #lif key not in found:
 #ound.add(key)
 #ield key, value

 #ef values(self):
 #or _key, value in self.items():
 #ield value

 #ef lists(self):
 #v = {}
 #or d in self.dicts:
 #or key, values in d.lists():
 #v.setdefault(key, []).extend(values)
 #eturn list(rv.items())

 #ef listvalues(self):
 #eturn (x[1] for x in self.lists())

 #ef copy(self):
 #""Return a shallow mutable copy of this object.

 #his returns a :class:`MultiDict` representing the data at the
 #ime of copying. The copy will no longer reflect changes to the
 #rapped dicts.

 #. versionchanged:: 0.15
 #eturn a mutable :class:`MultiDict`.
 #""
 #eturn MultiDict(self)

 #ef to_dict(self, flat=True):
 #""Return the contents as regular dict.  If `flat` is `True` the
 #eturned dict will only have the first item present, if `flat` is
 #False` all values will be returned as lists.

 #param flat: If set to `False` the dict returned will have lists
 #ith all the values in it.  Otherwise it will only
 #ontain the first item for each key.
 #return: a :class:`dict`
 #""
 #f flat:
 #eturn dict(self.items())

 #eturn dict(self.lists())

 #ef __len__(self):
 #eturn len(self._keys_impl())

 #ef __contains__(self, key):
 #or d in self.dicts:
 #f key in d:
 #eturn True
 #eturn False

 #ef has_key(self, key):
 #""
 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Use ``key in data``
 #nstead.
 #""
 #arnings.warn(
 #'has_key' is deprecated and will be removed in Werkzeug"
 # 2.1. Use 'key in data' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn key in self

 #ef __repr__(self):
 #eturn f"{type(self).__name__}({self.dicts!r})"


class FileMultiDict(MultiDict):
 #""A special :class:`MultiDict` that has convenience methods to add
 #iles to it.  This is used for :class:`EnvironBuilder` and generally
 #seful for unittesting.

 #. versionadded:: 0.5
 #""

 #ef add_file(self, name, file, filename=None, content_type=None):
 #""Adds a new file to the dict.  `file` can be a file name or
 # :class:`file`-like or a :class:`FileStorage` object.

 #param name: the name of the field.
 #param file: a filename or :class:`file`-like object
 #param filename: an optional filename
 #param content_type: an optional content type
 #""
 #f isinstance(file, FileStorage):
 #alue = file
 #lse:
 #f isinstance(file, str):
 #f filename is None:
 #ilename = file
 #ile = open(file, "rb")
 #f filename and content_type is None:
 #ontent_type = (
 #imetypes.guess_type(filename)[0] or "application/octet-stream"
 #
 #alue = FileStorage(file, filename, name, content_type)

 #elf.add(name, value)


class ImmutableDict(ImmutableDictMixin, dict):
 #""An immutable :class:`dict`.

 #. versionadded:: 0.5
 #""

 #ef __repr__(self):
 #eturn f"{type(self).__name__}({dict.__repr__(self)})"

 #ef copy(self):
 #""Return a shallow mutable copy of this object.  Keep in mind that
 #he standard library's :func:`copy` function is a no-op for this class
 #ike for any other python immutable type (eg: :class:`tuple`).
 #""
 #eturn dict(self)

 #ef __copy__(self):
 #eturn self


class ImmutableMultiDict(ImmutableMultiDictMixin, MultiDict):
 #""An immutable :class:`MultiDict`.

 #. versionadded:: 0.5
 #""

 #ef copy(self):
 #""Return a shallow mutable copy of this object.  Keep in mind that
 #he standard library's :func:`copy` function is a no-op for this class
 #ike for any other python immutable type (eg: :class:`tuple`).
 #""
 #eturn MultiDict(self)

 #ef __copy__(self):
 #eturn self


class ImmutableOrderedMultiDict(ImmutableMultiDictMixin, OrderedMultiDict):
 #""An immutable :class:`OrderedMultiDict`.

 #. versionadded:: 0.6
 #""

 #ef _iter_hashitems(self):
 #eturn enumerate(self.items(multi=True))

 #ef copy(self):
 #""Return a shallow mutable copy of this object.  Keep in mind that
 #he standard library's :func:`copy` function is a no-op for this class
 #ike for any other python immutable type (eg: :class:`tuple`).
 #""
 #eturn OrderedMultiDict(self)

 #ef __copy__(self):
 #eturn self


class Accept(ImmutableList):
 #""An :class:`Accept` object is just a list subclass for lists of
 #`(value, quality)`` tuples.  It is automatically sorted by specificity
 #nd quality.

 #ll :class:`Accept` objects work similar to a list but provide extra
 #unctionality for working with the data.  Containment checks are
 #ormalized to the rules of that header:

 #>> a = CharsetAccept([('ISO-8859-1', 1), ('utf-8', 0.7)])
 #>> a.best
 #ISO-8859-1'
 #>> 'iso-8859-1' in a
 #rue
 #>> 'UTF8' in a
 #rue
 #>> 'utf7' in a
 #alse

 #o get the quality for an item you can use normal item lookup:

 #>> print a['utf-8']
 #.7
 #>> a['utf7']
 #

 #. versionchanged:: 0.5
 #class:`Accept` objects are forced immutable now.

 #. versionchanged:: 1.0.0
 #class:`Accept` internal values are no longer ordered
 #lphabetically for equal quality tags. Instead the initial
 #rder is preserved.

 #""

 #ef __init__(self, values=()):
 #f values is None:
 #ist.__init__(self)
 #elf.provided = False
 #lif isinstance(values, Accept):
 #elf.provided = values.provided
 #ist.__init__(self, values)
 #lse:
 #elf.provided = True
 #alues = sorted(
 #alues, key=lambda x: (self._specificity(x[0]), x[1]), reverse=True
 #
 #ist.__init__(self, values)

 #ef _specificity(self, value):
 #""Returns a tuple describing the value's specificity."""
 #eturn (value != "*",)

 #ef _value_matches(self, value, item):
 #""Check if a value matches a given accept item."""
 #eturn item == "*" or item.lower() == value.lower()

 #ef __getitem__(self, key):
 #""Besides index lookup (getting item n) you can also pass it a string
 #o get the quality for the item.  If the item is not in the list, the
 #eturned quality is ``0``.
 #""
 #f isinstance(key, str):
 #eturn self.quality(key)
 #eturn list.__getitem__(self, key)

 #ef quality(self, key):
 #""Returns the quality of the key.

 #. versionadded:: 0.6
 #n previous versions you had to use the item-lookup syntax
 #eg: ``obj[key]`` instead of ``obj.quality(key)``)
 #""
 #or item, quality in self:
 #f self._value_matches(key, item):
 #eturn quality
 #eturn 0

 #ef __contains__(self, value):
 #or item, _quality in self:
 #f self._value_matches(value, item):
 #eturn True
 #eturn False

 #ef __repr__(self):
 #airs_str = ", ".join(f"({x!r}, {y})" for x, y in self)
 #eturn f"{type(self).__name__}([{pairs_str}])"

 #ef index(self, key):
 #""Get the position of an entry or raise :exc:`ValueError`.

 #param key: The key to be looked up.

 #. versionchanged:: 0.5
 #his used to raise :exc:`IndexError`, which was inconsistent
 #ith the list API.
 #""
 #f isinstance(key, str):
 #or idx, (item, _quality) in enumerate(self):
 #f self._value_matches(key, item):
 #eturn idx
 #aise ValueError(key)
 #eturn list.index(self, key)

 #ef find(self, key):
 #""Get the position of an entry or return -1.

 #param key: The key to be looked up.
 #""
 #ry:
 #eturn self.index(key)
 #xcept ValueError:
 #eturn -1

 #ef values(self):
 #""Iterate over all values."""
 #or item in self:
 #ield item[0]

 #ef to_header(self):
 #""Convert the header set into an HTTP header string."""
 #esult = []
 #or value, quality in self:
 #f quality != 1:
 #alue = f"{value};q={quality}"
 #esult.append(value)
 #eturn ",".join(result)

 #ef __str__(self):
 #eturn self.to_header()

 #ef _best_single_match(self, match):
 #or client_item, quality in self:
 #f self._value_matches(match, client_item):
                # self is sorted by specificity descending, we can exit
 #eturn client_item, quality
 #eturn None

 #ef best_match(self, matches, default=None):
 #""Returns the best match from a list of possible matches based
 #n the specificity and quality of the client. If two items have the
 #ame quality and specificity, the one is returned that comes first.

 #param matches: a list of matches to check for
 #param default: the value that is returned if none match
 #""
 #esult = default
 #est_quality = -1
 #est_specificity = (-1,)
 #or server_item in matches:
 #atch = self._best_single_match(server_item)
 #f not match:
 #ontinue
 #lient_item, quality = match
 #pecificity = self._specificity(client_item)
 #f quality <= 0 or quality < best_quality:
 #ontinue
            # better quality or same quality but more specific => better match
 #f quality > best_quality or specificity > best_specificity:
 #esult = server_item
 #est_quality = quality
 #est_specificity = specificity
 #eturn result

 #property
 #ef best(self):
 #""The best match as value."""
 #f self:
 #eturn self[0][0]


_mime_split_re = re.compile(r"/|(?:\s*;\s*)")


def _normalize_mime(value):
 #eturn _mime_split_re.split(value.lower())


class MIMEAccept(Accept):
 #""Like :class:`Accept` but with special methods and behavior for
 #imetypes.
 #""

 #ef _specificity(self, value):
 #eturn tuple(x != "*" for x in _mime_split_re.split(value))

 #ef _value_matches(self, value, item):
        # item comes from the client, can't match if it's invalid.
 #f "/" not in item:
 #eturn False

        # value comes from the application, tell the developer when it
        # doesn't look valid.
 #f "/" not in value:
 #aise ValueError(f"invalid mimetype {value!r}")

        # Split the match value into type, subtype, and a sorted list of parameters.
 #ormalized_value = _normalize_mime(value)
 #alue_type, value_subtype = normalized_value[:2]
 #alue_params = sorted(normalized_value[2:])

        # "*/*" is the only valid value that can start with "*".
 #f value_type == "*" and value_subtype != "*":
 #aise ValueError(f"invalid mimetype {value!r}")

        # Split the accept item into type, subtype, and parameters.
 #ormalized_item = _normalize_mime(item)
 #tem_type, item_subtype = normalized_item[:2]
 #tem_params = sorted(normalized_item[2:])

        # "*/not-*" from the client is invalid, can't match.
 #f item_type == "*" and item_subtype != "*":
 #eturn False

 #eturn (
 #item_type == "*" and item_subtype == "*")
 #r (value_type == "*" and value_subtype == "*")
 # or (
 #tem_type == value_type
 #nd (
 #tem_subtype == "*"
 #r value_subtype == "*"
 #r (item_subtype == value_subtype and item_params == value_params)
 #
 #

 #property
 #ef accept_html(self):
 #""True if this object accepts HTML."""
 #eturn (
 #text/html" in self or "application/xhtml+xml" in self or self.accept_xhtml
 #

 #property
 #ef accept_xhtml(self):
 #""True if this object accepts XHTML."""
 #eturn "application/xhtml+xml" in self or "application/xml" in self

 #property
 #ef accept_json(self):
 #""True if this object accepts JSON."""
 #eturn "application/json" in self


_locale_delim_re = re.compile(r"[_-]")


def _normalize_lang(value):
 #""Process a language tag for matching."""
 #eturn _locale_delim_re.split(value.lower())


class LanguageAccept(Accept):
 #""Like :class:`Accept` but with normalization for language tags."""

 #ef _value_matches(self, value, item):
 #eturn item == "*" or _normalize_lang(value) == _normalize_lang(item)

 #ef best_match(self, matches, default=None):
 #""Given a list of supported values, finds the best match from
 #he list of accepted values.

 #anguage tags are normalized for the purpose of matching, but
 #re returned unchanged.

 #f no exact match is found, this will fall back to matching
 #he first subtag (primary language only), first with the
 #ccepted values then with the match values. This partial is not
 #pplied to any other language subtags.

 #he default is returned if no exact or fallback match is found.

 #param matches: A list of supported languages to find a match.
 #param default: The value that is returned if none match.
 #""
        # Look for an exact match first. If a client accepts "en-US",
        # "en-US" is a valid match at this point.
 #esult = super().best_match(matches)

 #f result is not None:
 #eturn result

        # Fall back to accepting primary tags. If a client accepts
        # "en-US", "en" is a valid match at this point. Need to use
        # re.split to account for 2 or 3 letter codes.
 #allback = Accept(
 #(_locale_delim_re.split(item[0], 1)[0], item[1]) for item in self]
 #
 #esult = fallback.best_match(matches)

 #f result is not None:
 #eturn result

        # Fall back to matching primary tags. If the client accepts
        # "en", "en-US" is a valid match at this point.
 #allback_matches = [_locale_delim_re.split(item, 1)[0] for item in matches]
 #esult = super().best_match(fallback_matches)

        # Return a value from the original match list. Find the first
        # original value that starts with the matched primary tag.
 #f result is not None:
 #eturn next(item for item in matches if item.startswith(result))

 #eturn default


class CharsetAccept(Accept):
 #""Like :class:`Accept` but with normalization for charsets."""

 #ef _value_matches(self, value, item):
 #ef _normalize(name):
 #ry:
 #eturn codecs.lookup(name).name
 #xcept LookupError:
 #eturn name.lower()

 #eturn item == "*" or _normalize(value) == _normalize(item)


def cache_control_property(key, empty, type):
 #""Return a new property object for a cache header. Useful if you
 #ant to add support for a cache extension in a subclass.

 #. versionchanged:: 2.0
 #enamed from ``cache_property``.
 #""
 #eturn property(
 #ambda x: x._get_cache_value(key, empty, type),
 #ambda x, v: x._set_cache_value(key, v, type),
 #ambda x: x._del_cache_value(key),
 #"accessor for {key!r}",
 #


def cache_property(key, empty, type):
 #arnings.warn(
 #'cache_property' is renamed to 'cache_control_property'. The"
 # old name is deprecated and will be removed in Werkzeug 2.1.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn cache_control_property(key, empty, type)


class _CacheControl(UpdateDictMixin, dict):
 #""Subclass of a dict that stores values for a Cache-Control header.  It
 #as accessors for all the cache-control directives specified in RFC 2616.
 #he class does not differentiate between request and response directives.

 #ecause the cache-control directives in the HTTP header use dashes the
 #ython descriptors use underscores for that.

 #o get a header of the :class:`CacheControl` object again you can convert
 #he object into a string or call the :meth:`to_header` method.  If you plan
 #o subclass it and add your own items have a look at the sourcecode for
 #hat class.

 #. versionchanged:: 0.4

 #etting `no_cache` or `private` to boolean `True` will set the implicit
 #one-value which is ``*``:

 #>> cc = ResponseCacheControl()
 #>> cc.no_cache = True
 #>> cc
 #ResponseCacheControl 'no-cache'>
 #>> cc.no_cache
 #*'
 #>> cc.no_cache = None
 #>> cc
 #ResponseCacheControl ''>

 #n versions before 0.5 the behavior documented here affected the now
 #o longer existing `CacheControl` class.
 #""

 #o_cache = cache_control_property("no-cache", "*", None)
 #o_store = cache_control_property("no-store", None, bool)
 #ax_age = cache_control_property("max-age", -1, int)
 #o_transform = cache_control_property("no-transform", None, None)

 #ef __init__(self, values=(), on_update=None):
 #ict.__init__(self, values or ())
 #elf.on_update = on_update
 #elf.provided = values is not None

 #ef _get_cache_value(self, key, empty, type):
 #""Used internally by the accessor properties."""
 #f type is bool:
 #eturn key in self
 #f key in self:
 #alue = self[key]
 #f value is None:
 #eturn empty
 #lif type is not None:
 #ry:
 #alue = type(value)
 #xcept ValueError:
 #ass
 #eturn value
 #eturn None

 #ef _set_cache_value(self, key, value, type):
 #""Used internally by the accessor properties."""
 #f type is bool:
 #f value:
 #elf[key] = None
 #lse:
 #elf.pop(key, None)
 #lse:
 #f value is None:
 #elf.pop(key, None)
 #lif value is True:
 #elf[key] = None
 #lse:
 #elf[key] = value

 #ef _del_cache_value(self, key):
 #""Used internally by the accessor properties."""
 #f key in self:
 #el self[key]

 #ef to_header(self):
 #""Convert the stored values into a cache control header."""
 #eturn http.dump_header(self)

 #ef __str__(self):
 #eturn self.to_header()

 #ef __repr__(self):
 #v_str = " ".join(f"{k}={v!r}" for k, v in sorted(self.items()))
 #eturn f"<{type(self).__name__} {kv_str}>"

 #ache_property = staticmethod(cache_control_property)


class RequestCacheControl(ImmutableDictMixin, _CacheControl):
 #""A cache control for requests.  This is immutable and gives access
 #o all the request-relevant cache control headers.

 #o get a header of the :class:`RequestCacheControl` object again you can
 #onvert the object into a string or call the :meth:`to_header` method.  If
 #ou plan to subclass it and add your own items have a look at the sourcecode
 #or that class.

 #. versionadded:: 0.5
 #n previous versions a `CacheControl` class existed that was used
 #oth for request and response.
 #""

 #ax_stale = cache_control_property("max-stale", "*", int)
 #in_fresh = cache_control_property("min-fresh", "*", int)
 #nly_if_cached = cache_control_property("only-if-cached", None, bool)


class ResponseCacheControl(_CacheControl):
 #""A cache control for responses.  Unlike :class:`RequestCacheControl`
 #his is mutable and gives access to response-relevant cache control
 #eaders.

 #o get a header of the :class:`ResponseCacheControl` object again you can
 #onvert the object into a string or call the :meth:`to_header` method.  If
 #ou plan to subclass it and add your own items have a look at the sourcecode
 #or that class.

 #. versionadded:: 0.5
 #n previous versions a `CacheControl` class existed that was used
 #oth for request and response.
 #""

 #ublic = cache_control_property("public", None, bool)
 #rivate = cache_control_property("private", "*", None)
 #ust_revalidate = cache_control_property("must-revalidate", None, bool)
 #roxy_revalidate = cache_control_property("proxy-revalidate", None, bool)
 #_maxage = cache_control_property("s-maxage", None, None)
 #mmutable = cache_control_property("immutable", None, bool)


def csp_property(key):
 #""Return a new property object for a content security policy header.
 #seful if you want to add support for a csp extension in a
 #ubclass.
 #""
 #eturn property(
 #ambda x: x._get_value(key),
 #ambda x, v: x._set_value(key, v),
 #ambda x: x._del_value(key),
 #"accessor for {key!r}",
 #


class ContentSecurityPolicy(UpdateDictMixin, dict):
 #""Subclass of a dict that stores values for a Content Security Policy
 #eader. It has accessors for all the level 3 policies.

 #ecause the csp directives in the HTTP header use dashes the
 #ython descriptors use underscores for that.

 #o get a header of the :class:`ContentSecuirtyPolicy` object again
 #ou can convert the object into a string or call the
 #meth:`to_header` method.  If you plan to subclass it and add your
 #wn items have a look at the sourcecode for that class.

 #. versionadded:: 1.0.0
 #upport for Content Security Policy headers was added.

 #""

 #ase_uri = csp_property("base-uri")
 #hild_src = csp_property("child-src")
 #onnect_src = csp_property("connect-src")
 #efault_src = csp_property("default-src")
 #ont_src = csp_property("font-src")
 #orm_action = csp_property("form-action")
 #rame_ancestors = csp_property("frame-ancestors")
 #rame_src = csp_property("frame-src")
 #mg_src = csp_property("img-src")
 #anifest_src = csp_property("manifest-src")
 #edia_src = csp_property("media-src")
 #avigate_to = csp_property("navigate-to")
 #bject_src = csp_property("object-src")
 #refetch_src = csp_property("prefetch-src")
 #lugin_types = csp_property("plugin-types")
 #eport_to = csp_property("report-to")
 #eport_uri = csp_property("report-uri")
 #andbox = csp_property("sandbox")
 #cript_src = csp_property("script-src")
 #cript_src_attr = csp_property("script-src-attr")
 #cript_src_elem = csp_property("script-src-elem")
 #tyle_src = csp_property("style-src")
 #tyle_src_attr = csp_property("style-src-attr")
 #tyle_src_elem = csp_property("style-src-elem")
 #orker_src = csp_property("worker-src")

 #ef __init__(self, values=(), on_update=None):
 #ict.__init__(self, values or ())
 #elf.on_update = on_update
 #elf.provided = values is not None

 #ef _get_value(self, key):
 #""Used internally by the accessor properties."""
 #eturn self.get(key)

 #ef _set_value(self, key, value):
 #""Used internally by the accessor properties."""
 #f value is None:
 #elf.pop(key, None)
 #lse:
 #elf[key] = value

 #ef _del_value(self, key):
 #""Used internally by the accessor properties."""
 #f key in self:
 #el self[key]

 #ef to_header(self):
 #""Convert the stored values into a cache control header."""
 #eturn http.dump_csp_header(self)

 #ef __str__(self):
 #eturn self.to_header()

 #ef __repr__(self):
 #v_str = " ".join(f"{k}={v!r}" for k, v in sorted(self.items()))
 #eturn f"<{type(self).__name__} {kv_str}>"


class CallbackDict(UpdateDictMixin, dict):
 #""A dict that calls a function passed every time something is changed.
 #he function is passed the dict instance.
 #""

 #ef __init__(self, initial=None, on_update=None):
 #ict.__init__(self, initial or ())
 #elf.on_update = on_update

 #ef __repr__(self):
 #eturn f"<{type(self).__name__} {dict.__repr__(self)}>"


class HeaderSet(MutableSet):
 #""Similar to the :class:`ETags` class this implements a set-like structure.
 #nlike :class:`ETags` this is case insensitive and used for vary, allow, and
 #ontent-language headers.

 #f not constructed using the :func:`parse_set_header` function the
 #nstantiation works like this:

 #>> hs = HeaderSet(['foo', 'bar', 'baz'])
 #>> hs
 #eaderSet(['foo', 'bar', 'baz'])
 #""

 #ef __init__(self, headers=None, on_update=None):
 #elf._headers = list(headers or ())
 #elf._set = {x.lower() for x in self._headers}
 #elf.on_update = on_update

 #ef add(self, header):
 #""Add a new header to the set."""
 #elf.update((header,))

 #ef remove(self, header):
 #""Remove a header from the set.  This raises an :exc:`KeyError` if the
 #eader is not in the set.

 #. versionchanged:: 0.5
 #n older versions a :exc:`IndexError` was raised instead of a
 #exc:`KeyError` if the object was missing.

 #param header: the header to be removed.
 #""
 #ey = header.lower()
 #f key not in self._set:
 #aise KeyError(header)
 #elf._set.remove(key)
 #or idx, key in enumerate(self._headers):
 #f key.lower() == header:
 #el self._headers[idx]
 #reak
 #f self.on_update is not None:
 #elf.on_update(self)

 #ef update(self, iterable):
 #""Add all the headers from the iterable to the set.

 #param iterable: updates the set with the items from the iterable.
 #""
 #nserted_any = False
 #or header in iterable:
 #ey = header.lower()
 #f key not in self._set:
 #elf._headers.append(header)
 #elf._set.add(key)
 #nserted_any = True
 #f inserted_any and self.on_update is not None:
 #elf.on_update(self)

 #ef discard(self, header):
 #""Like :meth:`remove` but ignores errors.

 #param header: the header to be discarded.
 #""
 #ry:
 #elf.remove(header)
 #xcept KeyError:
 #ass

 #ef find(self, header):
 #""Return the index of the header in the set or return -1 if not found.

 #param header: the header to be looked up.
 #""
 #eader = header.lower()
 #or idx, item in enumerate(self._headers):
 #f item.lower() == header:
 #eturn idx
 #eturn -1

 #ef index(self, header):
 #""Return the index of the header in the set or raise an
 #exc:`IndexError`.

 #param header: the header to be looked up.
 #""
 #v = self.find(header)
 #f rv < 0:
 #aise IndexError(header)
 #eturn rv

 #ef clear(self):
 #""Clear the set."""
 #elf._set.clear()
 #el self._headers[:]
 #f self.on_update is not None:
 #elf.on_update(self)

 #ef as_set(self, preserve_casing=False):
 #""Return the set as real python set type.  When calling this, all
 #he items are converted to lowercase and the ordering is lost.

 #param preserve_casing: if set to `True` the items in the set returned
 #ill have the original case like in the
 #class:`HeaderSet`, otherwise they will
 #e lowercase.
 #""
 #f preserve_casing:
 #eturn set(self._headers)
 #eturn set(self._set)

 #ef to_header(self):
 #""Convert the header set into an HTTP header string."""
 #eturn ", ".join(map(http.quote_header_value, self._headers))

 #ef __getitem__(self, idx):
 #eturn self._headers[idx]

 #ef __delitem__(self, idx):
 #v = self._headers.pop(idx)
 #elf._set.remove(rv.lower())
 #f self.on_update is not None:
 #elf.on_update(self)

 #ef __setitem__(self, idx, value):
 #ld = self._headers[idx]
 #elf._set.remove(old.lower())
 #elf._headers[idx] = value
 #elf._set.add(value.lower())
 #f self.on_update is not None:
 #elf.on_update(self)

 #ef __contains__(self, header):
 #eturn header.lower() in self._set

 #ef __len__(self):
 #eturn len(self._set)

 #ef __iter__(self):
 #eturn iter(self._headers)

 #ef __bool__(self):
 #eturn bool(self._set)

 #ef __str__(self):
 #eturn self.to_header()

 #ef __repr__(self):
 #eturn f"{type(self).__name__}({self._headers!r})"


class ETags(Collection):
 #""A set that can be used to check if one etag is present in a collection
 #f etags.
 #""

 #ef __init__(self, strong_etags=None, weak_etags=None, star_tag=False):
 #f not star_tag and strong_etags:
 #elf._strong = frozenset(strong_etags)
 #lse:
 #elf._strong = frozenset()

 #elf._weak = frozenset(weak_etags or ())
 #elf.star_tag = star_tag

 #ef as_set(self, include_weak=False):
 #""Convert the `ETags` object into a python set.  Per default all the
 #eak etags are not part of this set."""
 #v = set(self._strong)
 #f include_weak:
 #v.update(self._weak)
 #eturn rv

 #ef is_weak(self, etag):
 #""Check if an etag is weak."""
 #eturn etag in self._weak

 #ef is_strong(self, etag):
 #""Check if an etag is strong."""
 #eturn etag in self._strong

 #ef contains_weak(self, etag):
 #""Check if an etag is part of the set including weak and strong tags."""
 #eturn self.is_weak(etag) or self.contains(etag)

 #ef contains(self, etag):
 #""Check if an etag is part of the set ignoring weak tags.
 #t is also possible to use the ``in`` operator.
 #""
 #f self.star_tag:
 #eturn True
 #eturn self.is_strong(etag)

 #ef contains_raw(self, etag):
 #""When passed a quoted tag it will check if this tag is part of the
 #et.  If the tag is weak it is checked against weak and strong tags,
 #therwise strong only."""
 #tag, weak = http.unquote_etag(etag)
 #f weak:
 #eturn self.contains_weak(etag)
 #eturn self.contains(etag)

 #ef to_header(self):
 #""Convert the etags set into a HTTP header string."""
 #f self.star_tag:
 #eturn "*"
 #eturn ", ".join(
 #f'"{x}"' for x in self._strong] + [f'W/"{x}"' for x in self._weak]
 #

 #ef __call__(self, etag=None, data=None, include_weak=False):
 #f [etag, data].count(None) != 1:
 #aise TypeError("either tag or data required, but at least one")
 #f etag is None:
 #tag = http.generate_etag(data)
 #f include_weak:
 #f etag in self._weak:
 #eturn True
 #eturn etag in self._strong

 #ef __bool__(self):
 #eturn bool(self.star_tag or self._strong or self._weak)

 #ef __str__(self):
 #eturn self.to_header()

 #ef __len__(self):
 #eturn len(self._strong)

 #ef __iter__(self):
 #eturn iter(self._strong)

 #ef __contains__(self, etag):
 #eturn self.contains(etag)

 #ef __repr__(self):
 #eturn f"<{type(self).__name__} {str(self)!r}>"


class IfRange:
 #""Very simple object that represents the `If-Range` header in parsed
 #orm.  It will either have neither a etag or date or one of either but
 #ever both.

 #. versionadded:: 0.7
 #""

 #ef __init__(self, etag=None, date=None):
        #: The etag parsed and unquoted.  Ranges always operate on strong
        #: etags so the weakness information is not necessary.
 #elf.etag = etag
        #: The date in parsed format or `None`.
 #elf.date = date

 #ef to_header(self):
 #""Converts the object back into an HTTP header."""
 #f self.date is not None:
 #eturn http.http_date(self.date)
 #f self.etag is not None:
 #eturn http.quote_etag(self.etag)
 #eturn ""

 #ef __str__(self):
 #eturn self.to_header()

 #ef __repr__(self):
 #eturn f"<{type(self).__name__} {str(self)!r}>"


class Range:
 #""Represents a ``Range`` header. All methods only support only
 #ytes as the unit. Stores a list of ranges if given, but the methods
 #nly work if only one range is provided.

 #raise ValueError: If the ranges provided are invalid.

 #. versionchanged:: 0.15
 #he ranges passed in are validated.

 #. versionadded:: 0.7
 #""

 #ef __init__(self, units, ranges):
        #: The units of this range.  Usually "bytes".
 #elf.units = units
        #: A list of ``(begin, end)`` tuples for the range header provided.
        #: The ranges are non-inclusive.
 #elf.ranges = ranges

 #or start, end in ranges:
 #f start is None or (end is not None and (start < 0 or start >= end)):
 #aise ValueError(f"{(start, end)} is not a valid range.")

 #ef range_for_length(self, length):
 #""If the range is for bytes, the length is not None and there is
 #xactly one range and it is satisfiable it returns a ``(start, stop)``
 #uple, otherwise `None`.
 #""
 #f self.units != "bytes" or length is None or len(self.ranges) != 1:
 #eturn None
 #tart, end = self.ranges[0]
 #f end is None:
 #nd = length
 #f start < 0:
 #tart += length
 #f http.is_byte_range_valid(start, end, length):
 #eturn start, min(end, length)
 #eturn None

 #ef make_content_range(self, length):
 #""Creates a :class:`~werkzeug.datastructures.ContentRange` object
 #rom the current range and given content length.
 #""
 #ng = self.range_for_length(length)
 #f rng is not None:
 #eturn ContentRange(self.units, rng[0], rng[1], length)
 #eturn None

 #ef to_header(self):
 #""Converts the object back into an HTTP header."""
 #anges = []
 #or begin, end in self.ranges:
 #f end is None:
 #anges.append(f"{begin}-" if begin >= 0 else str(begin))
 #lse:
 #anges.append(f"{begin}-{end - 1}")
 #eturn f"{self.units}={','.join(ranges)}"

 #ef to_content_range_header(self, length):
 #""Converts the object into `Content-Range` HTTP header,
 #ased on given length
 #""
 #ange = self.range_for_length(length)
 #f range is not None:
 #eturn f"{self.units} {range[0]}-{range[1] - 1}/{length}"
 #eturn None

 #ef __str__(self):
 #eturn self.to_header()

 #ef __repr__(self):
 #eturn f"<{type(self).__name__} {str(self)!r}>"


def _callback_property(name):
 #ef fget(self):
 #eturn getattr(self, name)

 #ef fset(self, value):
 #etattr(self, name, value)
 #f self.on_update is not None:
 #elf.on_update(self)

 #eturn property(fget, fset)


class ContentRange:
 #""Represents the content range header.

 #. versionadded:: 0.7
 #""

 #ef __init__(self, units, start, stop, length=None, on_update=None):
 #ssert http.is_byte_range_valid(start, stop, length), "Bad range provided"
 #elf.on_update = on_update
 #elf.set(start, stop, length, units)

    #: The units to use, usually "bytes"
 #nits = _callback_property("_units")
    #: The start point of the range or `None`.
 #tart = _callback_property("_start")
    #: The stop point of the range (non-inclusive) or `None`.  Can only be
    #: `None` if also start is `None`.
 #top = _callback_property("_stop")
    #: The length of the range or `None`.
 #ength = _callback_property("_length")

 #ef set(self, start, stop, length=None, units="bytes"):
 #""Simple method to update the ranges."""
 #ssert http.is_byte_range_valid(start, stop, length), "Bad range provided"
 #elf._units = units
 #elf._start = start
 #elf._stop = stop
 #elf._length = length
 #f self.on_update is not None:
 #elf.on_update(self)

 #ef unset(self):
 #""Sets the units to `None` which indicates that the header should
 #o longer be used.
 #""
 #elf.set(None, None, units=None)

 #ef to_header(self):
 #f self.units is None:
 #eturn ""
 #f self.length is None:
 #ength = "*"
 #lse:
 #ength = self.length
 #f self.start is None:
 #eturn f"{self.units} */{length}"
 #eturn f"{self.units} {self.start}-{self.stop - 1}/{length}"

 #ef __bool__(self):
 #eturn self.units is not None

 #ef __str__(self):
 #eturn self.to_header()

 #ef __repr__(self):
 #eturn f"<{type(self).__name__} {str(self)!r}>"


class Authorization(ImmutableDictMixin, dict):
 #""Represents an ``Authorization`` header sent by the client.

 #his is returned by
 #func:`~werkzeug.http.parse_authorization_header`. It can be useful
 #o create the object manually to pass to the test
 #class:`~werkzeug.test.Client`.

 #. versionchanged:: 0.5
 #his object became immutable.
 #""

 #ef __init__(self, auth_type, data=None):
 #ict.__init__(self, data or {})
 #elf.type = auth_type

 #property
 #ef username(self):
 #""The username transmitted.  This is set for both basic and digest
 #uth all the time.
 #""
 #eturn self.get("username")

 #property
 #ef password(self):
 #""When the authentication type is basic this is the password
 #ransmitted by the client, else `None`.
 #""
 #eturn self.get("password")

 #property
 #ef realm(self):
 #""This is the server realm sent back for HTTP digest auth."""
 #eturn self.get("realm")

 #property
 #ef nonce(self):
 #""The nonce the server sent for digest auth, sent back by the client.
 # nonce should be unique for every 401 response for HTTP digest auth.
 #""
 #eturn self.get("nonce")

 #property
 #ef uri(self):
 #""The URI from Request-URI of the Request-Line; duplicated because
 #roxies are allowed to change the Request-Line in transit.  HTTP
 #igest auth only.
 #""
 #eturn self.get("uri")

 #property
 #ef nc(self):
 #""The nonce count value transmitted by clients if a qop-header is
 #lso transmitted.  HTTP digest auth only.
 #""
 #eturn self.get("nc")

 #property
 #ef cnonce(self):
 #""If the server sent a qop-header in the ``WWW-Authenticate``
 #eader, the client has to provide this value for HTTP digest auth.
 #ee the RFC for more details.
 #""
 #eturn self.get("cnonce")

 #property
 #ef response(self):
 #""A string of 32 hex digits computed as defined in RFC 2617, which
 #roves that the user knows a password.  Digest auth only.
 #""
 #eturn self.get("response")

 #property
 #ef opaque(self):
 #""The opaque header from the server returned unchanged by the client.
 #t is recommended that this string be base64 or hexadecimal data.
 #igest auth only.
 #""
 #eturn self.get("opaque")

 #property
 #ef qop(self):
 #""Indicates what "quality of protection" the client has applied to
 #he message for HTTP digest auth. Note that this is a single token,
 #ot a quoted list of alternatives as in WWW-Authenticate.
 #""
 #eturn self.get("qop")

 #ef to_header(self):
 #""Convert to a string value for an ``Authorization`` header.

 #. versionadded:: 2.0
 #dded to support passing authorization to the test client.
 #""
 #f self.type == "basic":
 #alue = base64.b64encode(
 #"{self.username}:{self.password}".encode()
 #.decode("utf8")
 #eturn f"Basic {value}"

 #f self.type == "digest":
 #eturn f"Digest {http.dump_header(self)}"

 #aise ValueError(f"Unsupported type {self.type!r}.")


def auth_property(name, doc=None):
 #""A static helper function for Authentication subclasses to add
 #xtra authentication system properties onto a class::

 #lass FooAuthenticate(WWWAuthenticate):
 #pecial_realm = auth_property('special_realm')

 #or more information have a look at the sourcecode to see how the
 #egular properties (:attr:`realm` etc.) are implemented.
 #""

 #ef _set_value(self, value):
 #f value is None:
 #elf.pop(name, None)
 #lse:
 #elf[name] = str(value)

 #eturn property(lambda x: x.get(name), _set_value, doc=doc)


def _set_property(name, doc=None):
 #ef fget(self):
 #ef on_update(header_set):
 #f not header_set and name in self:
 #el self[name]
 #lif header_set:
 #elf[name] = header_set.to_header()

 #eturn http.parse_set_header(self.get(name), on_update)

 #eturn property(fget, doc=doc)


class WWWAuthenticate(UpdateDictMixin, dict):
 #""Provides simple access to `WWW-Authenticate` headers."""

    #: list of keys that require quoting in the generated header
 #require_quoting = frozenset(["domain", "nonce", "opaque", "realm", "qop"])

 #ef __init__(self, auth_type=None, values=None, on_update=None):
 #ict.__init__(self, values or ())
 #f auth_type:
 #elf["__auth_type__"] = auth_type
 #elf.on_update = on_update

 #ef set_basic(self, realm="authentication required"):
 #""Clear the auth info and enable basic auth."""
 #ict.clear(self)
 #ict.update(self, {"__auth_type__": "basic", "realm": realm})
 #f self.on_update:
 #elf.on_update(self)

 #ef set_digest(
 #elf, realm, nonce, qop=("auth",), opaque=None, algorithm=None, stale=False
 #:
 #""Clear the auth info and enable digest auth."""
 # = {
 #__auth_type__": "digest",
 #realm": realm,
 #nonce": nonce,
 #qop": http.dump_header(qop),
 #
 #f stale:
 #["stale"] = "TRUE"
 #f opaque is not None:
 #["opaque"] = opaque
 #f algorithm is not None:
 #["algorithm"] = algorithm
 #ict.clear(self)
 #ict.update(self, d)
 #f self.on_update:
 #elf.on_update(self)

 #ef to_header(self):
 #""Convert the stored values into a WWW-Authenticate header."""
 # = dict(self)
 #uth_type = d.pop("__auth_type__", None) or "basic"
 #v_items = (
 #k, http.quote_header_value(v, allow_token=k not in self._require_quoting))
 #or k, v in d.items()
 #
 #v_string = ", ".join([f"{k}={v}" for k, v in kv_items])
 #eturn f"{auth_type.title()} {kv_string}"

 #ef __str__(self):
 #eturn self.to_header()

 #ef __repr__(self):
 #eturn f"<{type(self).__name__} {self.to_header()!r}>"

 #ype = auth_property(
 #__auth_type__",
 #oc="""The type of the auth mechanism. HTTP currently specifies
 #`Basic`` and ``Digest``.""",
 #
 #ealm = auth_property(
 #realm",
 #oc="""A string to be displayed to users so they know which
 #sername and password to use. This string should contain at
 #east the name of the host performing the authentication and
 #ight additionally indicate the collection of users who might
 #ave access.""",
 #
 #omain = _set_property(
 #domain",
 #oc="""A list of URIs that define the protection space. If a URI
 #s an absolute path, it is relative to the canonical root URL of
 #he server being accessed.""",
 #
 #once = auth_property(
 #nonce",
 #oc="""
 # server-specified data string which should be uniquely generated
 #ach time a 401 response is made. It is recommended that this
 #tring be base64 or hexadecimal data.""",
 #
 #paque = auth_property(
 #opaque",
 #oc="""A string of data, specified by the server, which should
 #e returned by the client unchanged in the Authorization header
 #f subsequent requests with URIs in the same protection space.
 #t is recommended that this string be base64 or hexadecimal
 #ata.""",
 #
 #lgorithm = auth_property(
 #algorithm",
 #oc="""A string indicating a pair of algorithms used to produce
 #he digest and a checksum. If this is not present it is assumed
 #o be "MD5". If the algorithm is not understood, the challenge
 #hould be ignored (and a different one used, if there is more
 #han one).""",
 #
 #op = _set_property(
 #qop",
 #oc="""A set of quality-of-privacy directives such as auth and
 #uth-int.""",
 #

 #property
 #ef stale(self):
 #""A flag, indicating that the previous request from the client
 #as rejected because the nonce value was stale.
 #""
 #al = self.get("stale")
 #f val is not None:
 #eturn val.lower() == "true"

 #stale.setter
 #ef stale(self, value):
 #f value is None:
 #elf.pop("stale", None)
 #lse:
 #elf["stale"] = "TRUE" if value else "FALSE"

 #uth_property = staticmethod(auth_property)


class FileStorage:
 #""The :class:`FileStorage` class is a thin wrapper over incoming files.
 #t is used by the request object to represent uploaded files.  All the
 #ttributes of the wrapper stream are proxied by the file storage so
 #t's possible to do ``storage.read()`` instead of the long form
 #`storage.stream.read()``.
 #""

 #ef __init__(
 #elf,
 #tream=None,
 #ilename=None,
 #ame=None,
 #ontent_type=None,
 #ontent_length=None,
 #eaders=None,
 #:
 #elf.name = name
 #elf.stream = stream or BytesIO()

        # if no filename is provided we can attempt to get the filename
        # from the stream object passed.  There we have to be careful to
        # skip things like <fdopen>, <stderr> etc.  Python marks these
        # special filenames with angular brackets.
 #f filename is None:
 #ilename = getattr(stream, "name", None)
 # = _make_encode_wrapper(filename)
 #f filename and filename[0] == s("<") and filename[-1] == s(">"):
 #ilename = None

            # Make sure the filename is not bytes. This might happen if
            # the file was opened from the bytes API.
 #f isinstance(filename, bytes):
 #ilename = filename.decode(get_filesystem_encoding(), "replace")

 #elf.filename = filename
 #f headers is None:
 #eaders = Headers()
 #elf.headers = headers
 #f content_type is not None:
 #eaders["Content-Type"] = content_type
 #f content_length is not None:
 #eaders["Content-Length"] = str(content_length)

 #ef _parse_content_type(self):
 #f not hasattr(self, "_parsed_content_type"):
 #elf._parsed_content_type = http.parse_options_header(self.content_type)

 #property
 #ef content_type(self):
 #""The content-type sent in the header.  Usually not available"""
 #eturn self.headers.get("content-type")

 #property
 #ef content_length(self):
 #""The content-length sent in the header.  Usually not available"""
 #eturn int(self.headers.get("content-length") or 0)

 #property
 #ef mimetype(self):
 #""Like :attr:`content_type`, but without parameters (eg, without
 #harset, type etc.) and always lowercase.  For example if the content
 #ype is ``text/HTML; charset=utf-8`` the mimetype would be
 #`'text/html'``.

 #. versionadded:: 0.7
 #""
 #elf._parse_content_type()
 #eturn self._parsed_content_type[0].lower()

 #property
 #ef mimetype_params(self):
 #""The mimetype parameters as dict.  For example if the content
 #ype is ``text/html; charset=utf-8`` the params would be
 #`{'charset': 'utf-8'}``.

 #. versionadded:: 0.7
 #""
 #elf._parse_content_type()
 #eturn self._parsed_content_type[1]

 #ef save(self, dst, buffer_size=16384):
 #""Save the file to a destination path or file object.  If the
 #estination is a file object you have to close it yourself after the
 #all.  The buffer size is the number of bytes held in memory during
 #he copy process.  It defaults to 16KB.

 #or secure file saving also have a look at :func:`secure_filename`.

 #param dst: a filename, :class:`os.PathLike`, or open file
 #bject to write to.
 #param buffer_size: Passed as the ``length`` parameter of
 #func:`shutil.copyfileobj`.

 #. versionchanged:: 1.0
 #upports :mod:`pathlib`.
 #""
 #rom shutil import copyfileobj

 #lose_dst = False

 #f hasattr(dst, "__fspath__"):
 #st = fspath(dst)

 #f isinstance(dst, str):
 #st = open(dst, "wb")
 #lose_dst = True

 #ry:
 #opyfileobj(self.stream, dst, buffer_size)
 #inally:
 #f close_dst:
 #st.close()

 #ef close(self):
 #""Close the underlying file if possible."""
 #ry:
 #elf.stream.close()
 #xcept Exception:
 #ass

 #ef __bool__(self):
 #eturn bool(self.filename)

 #ef __getattr__(self, name):
 #ry:
 #eturn getattr(self.stream, name)
 #xcept AttributeError:
            # SpooledTemporaryFile doesn't implement IOBase, get the
            # attribute from its backing file instead.
            # https://github.com/python/cpython/pull/3249
 #f hasattr(self.stream, "_file"):
 #eturn getattr(self.stream._file, name)
 #aise

 #ef __iter__(self):
 #eturn iter(self.stream)

 #ef __repr__(self):
 #eturn f"<{type(self).__name__}: {self.filename!r} ({self.content_type!r})>"


# circular dependencies
from . import http
