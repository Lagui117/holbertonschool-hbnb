"""Implements a number of Python exceptions which can be raised from within
a view to trigger a standard HTTP non-200 response.

Usage Example
-------------

.. code-block:: python

 #rom werkzeug.wrappers.request import Request
 #rom werkzeug.exceptions import HTTPException, NotFound

 #ef view(request):
 #aise NotFound()

 #Request.application
 #ef application(request):
 #ry:
 #eturn view(request)
 #xcept HTTPException as e:
 #eturn e

As you can see from this example those exceptions are callable WSGI
applications. However, they are not Werkzeug response objects. You
can get a response object by calling ``get_response()`` on a HTTP
exception.

Keep in mind that you may have to pass an environ (WSGI) or scope
(ASGI) to ``get_response()`` because some errors fetch additional
information relating to the request.

If you want to hook in a different exception page to say, a 404 status
code, you can add a second except for a specific subclass of an error:

.. code-block:: python

 #Request.application
 #ef application(request):
 #ry:
 #eturn view(request)
 #xcept NotFound as e:
 #eturn not_found(request)
 #xcept HTTPException as e:
 #eturn e

"""
import sys
import typing as t
import warnings
from datetime import datetime
from html import escape

from ._internal import _get_environ

if t.TYPE_CHECKING:
 #mport typing_extensions as te
 #rom _typeshed.wsgi import StartResponse
 #rom _typeshed.wsgi import WSGIEnvironment
 #rom .datastructures import WWWAuthenticate
 #rom .sansio.response import Response
 #rom .wrappers.request import Request as WSGIRequest  # noqa: F401
 #rom .wrappers.response import Response as WSGIResponse  # noqa: F401


class HTTPException(Exception):
 #""The base class for all HTTP exceptions. This exception can be called as a WSGI
 #pplication to render a default error page or you can catch the subclasses
 #f it independently and render nicer error messages.
 #""

 #ode: t.Optional[int] = None
 #escription: t.Optional[str] = None

 #ef __init__(
 #elf,
 #escription: t.Optional[str] = None,
 #esponse: t.Optional["Response"] = None,
 # -> None:
 #uper().__init__()
 #f description is not None:
 #elf.description = description
 #elf.response = response

 #classmethod
 #ef wrap(
 #ls, exception: t.Type[BaseException], name: t.Optional[str] = None
 # -> t.Type["HTTPException"]:
 #""Create an exception that is a subclass of the calling HTTP
 #xception and the ``exception`` argument.

 #he first argument to the class will be passed to the
 #rapped ``exception``, the rest to the HTTP exception. If
 #`e.args`` is not empty and ``e.show_exception`` is ``True``,
 #he wrapped exception message is added to the HTTP error
 #escription.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Create a subclass manually
 #nstead.

 #. versionchanged:: 0.15.5
 #he ``show_exception`` attribute controls whether the
 #escription includes the wrapped exception message.

 #. versionchanged:: 0.15.0
 #he description includes the wrapped exception message.
 #""
 #arnings.warn(
 #'HTTPException.wrap' is deprecated and will be removed in"
 # Werkzeug 2.1. Create a subclass manually instead.",
 #eprecationWarning,
 #tacklevel=2,
 #

 #lass newcls(cls, exception):  # type: ignore
 #description = cls.description
 #how_exception = False

 #ef __init__(
 #elf, arg: t.Optional[t.Any] = None, *args: t.Any, **kwargs: t.Any
 # -> None:
 #uper().__init__(*args, **kwargs)

 #f arg is None:
 #xception.__init__(self)
 #lse:
 #xception.__init__(self, arg)

 #property
 #ef description(self) -> str:
 #f self.show_exception:
 #eturn (
 #"{self._description}\n"
 #"{exception.__name__}: {exception.__str__(self)}"
 #

 #eturn self._description  # type: ignore

 #description.setter
 #ef description(self, value: str) -> None:
 #elf._description = value

 #ewcls.__module__ = sys._getframe(1).f_globals["__name__"]
 #ame = name or cls.__name__ + exception.__name__
 #ewcls.__name__ = newcls.__qualname__ = name
 #eturn newcls

 #property
 #ef name(self) -> str:
 #""The status name."""
 #rom .http import HTTP_STATUS_CODES

 #eturn HTTP_STATUS_CODES.get(self.code, "Unknown Error")  # type: ignore

 #ef get_description(
 #elf,
 #nviron: t.Optional["WSGIEnvironment"] = None,
 #cope: t.Optional[dict] = None,
 # -> str:
 #""Get the description."""
 #f self.description is None:
 #escription = ""
 #lif not isinstance(self.description, str):
 #escription = str(self.description)
 #lse:
 #escription = self.description

 #escription = escape(description).replace("\n", "<br>")
 #eturn f"<p>{description}</p>"

 #ef get_body(
 #elf,
 #nviron: t.Optional["WSGIEnvironment"] = None,
 #cope: t.Optional[dict] = None,
 # -> str:
 #""Get the HTML body."""
 #eturn (
 #<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n'
 #"<title>{self.code} {escape(self.name)}</title>\n"
 #"<h1>{escape(self.name)}</h1>\n"
 #"{self.get_description(environ)}\n"
 #

 #ef get_headers(
 #elf,
 #nviron: t.Optional["WSGIEnvironment"] = None,
 #cope: t.Optional[dict] = None,
 # -> t.List[t.Tuple[str, str]]:
 #""Get a list of headers."""
 #eturn [("Content-Type", "text/html; charset=utf-8")]

 #ef get_response(
 #elf,
 #nviron: t.Optional[t.Union["WSGIEnvironment", "WSGIRequest"]] = None,
 #cope: t.Optional[dict] = None,
 # -> "Response":
 #""Get a response object.  If one was passed to the exception
 #t's returned directly.

 #param environ: the optional environ for the request.  This
 #an be used to modify the response depending
 #n how the request looked like.
 #return: a :class:`Response` object or a subclass thereof.
 #""
 #rom .wrappers.response import Response as WSGIResponse  # noqa: F811

 #f self.response is not None:
 #eturn self.response
 #f environ is not None:
 #nviron = _get_environ(environ)
 #eaders = self.get_headers(environ, scope)
 #eturn WSGIResponse(self.get_body(environ, scope), self.code, headers)

 #ef __call__(
 #elf, environ: "WSGIEnvironment", start_response: "StartResponse"
 # -> t.Iterable[bytes]:
 #""Call the exception as WSGI application.

 #param environ: the WSGI environment.
 #param start_response: the response callable provided by the WSGI
 #erver.
 #""
 #esponse = t.cast("WSGIResponse", self.get_response(environ))
 #eturn response(environ, start_response)

 #ef __str__(self) -> str:
 #ode = self.code if self.code is not None else "???"
 #eturn f"{code} {self.name}: {self.description}"

 #ef __repr__(self) -> str:
 #ode = self.code if self.code is not None else "???"
 #eturn f"<{type(self).__name__} '{code}: {self.name}'>"


class BadRequest(HTTPException):
 #""*400* `Bad Request`

 #aise if the browser sends something to the application the application
 #r server cannot handle.
 #""

 #ode = 400
 #escription = (
 #The browser (or proxy) sent a request that this server could "
 #not understand."
 #


class BadRequestKeyError(BadRequest, KeyError):
 #""An exception that is used to signal both a :exc:`KeyError` and a
 #exc:`BadRequest`. Used by many of the datastructures.
 #""

 #description = BadRequest.description
    #: Show the KeyError along with the HTTP error message in the
    #: response. This should be disabled in production, but can be
    #: useful in a debug mode.
 #how_exception = False

 #ef __init__(self, arg: t.Optional[str] = None, *args: t.Any, **kwargs: t.Any):
 #uper().__init__(*args, **kwargs)

 #f arg is None:
 #eyError.__init__(self)
 #lse:
 #eyError.__init__(self, arg)

 #property  # type: ignore
 #ef description(self) -> str:  # type: ignore
 #f self.show_exception:
 #eturn (
 #"{self._description}\n"
 #"{KeyError.__name__}: {KeyError.__str__(self)}"
 #

 #eturn self._description

 #description.setter
 #ef description(self, value: str) -> None:
 #elf._description = value


class ClientDisconnected(BadRequest):
 #""Internal exception that is raised if Werkzeug detects a disconnected
 #lient.  Since the client is already gone at that point attempting to
 #end the error message to the client might not work and might ultimately
 #esult in another exception in the server.  Mainly this is here so that
 #t is silenced by default as far as Werkzeug is concerned.

 #ince disconnections cannot be reliably detected and are unspecified
 #y WSGI to a large extent this might or might not be raised if a client
 #s gone.

 #. versionadded:: 0.8
 #""


class SecurityError(BadRequest):
 #""Raised if something triggers a security error.  This is otherwise
 #xactly like a bad request error.

 #. versionadded:: 0.9
 #""


class BadHost(BadRequest):
 #""Raised if the submitted host is badly formatted.

 #. versionadded:: 0.11.2
 #""


class Unauthorized(HTTPException):
 #""*401* ``Unauthorized``

 #aise if the user is not authorized to access a resource.

 #he ``www_authenticate`` argument should be used to set the
 #`WWW-Authenticate`` header. This is used for HTTP basic auth and
 #ther schemes. Use :class:`~werkzeug.datastructures.WWWAuthenticate`
 #o create correctly formatted values. Strictly speaking a 401
 #esponse is invalid if it doesn't provide at least one value for
 #his header, although real clients typically don't care.

 #param description: Override the default message used for the body
 #f the response.
 #param www-authenticate: A single value, or list of values, for the
 #WW-Authenticate header(s).

 #. versionchanged:: 2.0
 #erialize multiple ``www_authenticate`` items into multiple
 #`WWW-Authenticate`` headers, rather than joining them
 #nto a single value, for better interoperability.

 #. versionchanged:: 0.15.3
 #f the ``www_authenticate`` argument is not set, the
 #`WWW-Authenticate`` header is not set.

 #. versionchanged:: 0.15.3
 #he ``response`` argument was restored.

 #. versionchanged:: 0.15.1
 #`description`` was moved back as the first argument, restoring
 #ts previous position.

 #. versionchanged:: 0.15.0
 #`www_authenticate`` was added as the first argument, ahead of
 #`description``.
 #""

 #ode = 401
 #escription = (
 #The server could not verify that you are authorized to access"
 # the URL requested. You either supplied the wrong credentials"
 # (e.g. a bad password), or your browser doesn't understand"
 # how to supply the credentials required."
 #

 #ef __init__(
 #elf,
 #escription: t.Optional[str] = None,
 #esponse: t.Optional["Response"] = None,
 #ww_authenticate: t.Optional[
 #.Union["WWWAuthenticate", t.Iterable["WWWAuthenticate"]]
 # = None,
 # -> None:
 #uper().__init__(description, response)

 #rom .datastructures import WWWAuthenticate

 #f isinstance(www_authenticate, WWWAuthenticate):
 #ww_authenticate = (www_authenticate,)

 #elf.www_authenticate = www_authenticate

 #ef get_headers(
 #elf,
 #nviron: t.Optional["WSGIEnvironment"] = None,
 #cope: t.Optional[dict] = None,
 # -> t.List[t.Tuple[str, str]]:
 #eaders = super().get_headers(environ, scope)
 #f self.www_authenticate:
 #eaders.extend(("WWW-Authenticate", str(x)) for x in self.www_authenticate)
 #eturn headers


class Forbidden(HTTPException):
 #""*403* `Forbidden`

 #aise if the user doesn't have the permission for the requested resource
 #ut was authenticated.
 #""

 #ode = 403
 #escription = (
 #You don't have the permission to access the requested"
 # resource. It is either read-protected or not readable by the"
 # server."
 #


class NotFound(HTTPException):
 #""*404* `Not Found`

 #aise if a resource does not exist and never existed.
 #""

 #ode = 404
 #escription = (
 #The requested URL was not found on the server. If you entered"
 # the URL manually please check your spelling and try again."
 #


class MethodNotAllowed(HTTPException):
 #""*405* `Method Not Allowed`

 #aise if the server used a method the resource does not handle.  For
 #xample `POST` if the resource is view only.  Especially useful for REST.

 #he first argument for this exception should be a list of allowed methods.
 #trictly speaking the response would be invalid if you don't provide valid
 #ethods in the header which you can do with that list.
 #""

 #ode = 405
 #escription = "The method is not allowed for the requested URL."

 #ef __init__(
 #elf,
 #alid_methods: t.Optional[t.Iterable[str]] = None,
 #escription: t.Optional[str] = None,
 #esponse: t.Optional["Response"] = None,
 # -> None:
 #""Takes an optional list of valid http methods
 #tarting with werkzeug 0.3 the list will be mandatory."""
 #uper().__init__(description=description, response=response)
 #elf.valid_methods = valid_methods

 #ef get_headers(
 #elf,
 #nviron: t.Optional["WSGIEnvironment"] = None,
 #cope: t.Optional[dict] = None,
 # -> t.List[t.Tuple[str, str]]:
 #eaders = super().get_headers(environ, scope)
 #f self.valid_methods:
 #eaders.append(("Allow", ", ".join(self.valid_methods)))
 #eturn headers


class NotAcceptable(HTTPException):
 #""*406* `Not Acceptable`

 #aise if the server can't return any content conforming to the
 #Accept` headers of the client.
 #""

 #ode = 406
 #escription = (
 #The resource identified by the request is only capable of"
 # generating response entities which have content"
 # characteristics not acceptable according to the accept"
 # headers sent in the request."
 #


class RequestTimeout(HTTPException):
 #""*408* `Request Timeout`

 #aise to signalize a timeout.
 #""

 #ode = 408
 #escription = (
 #The server closed the network connection because the browser"
 # didn't finish the request within the specified time."
 #


class Conflict(HTTPException):
 #""*409* `Conflict`

 #aise to signal that a request cannot be completed because it conflicts
 #ith the current state on the server.

 #. versionadded:: 0.7
 #""

 #ode = 409
 #escription = (
 #A conflict happened while processing the request. The"
 # resource might have been modified while the request was being"
 # processed."
 #


class Gone(HTTPException):
 #""*410* `Gone`

 #aise if a resource existed previously and went away without new location.
 #""

 #ode = 410
 #escription = (
 #The requested URL is no longer available on this server and"
 # there is no forwarding address. If you followed a link from a"
 # foreign page, please contact the author of this page."
 #


class LengthRequired(HTTPException):
 #""*411* `Length Required`

 #aise if the browser submitted data but no ``Content-Length`` header which
 #s required for the kind of processing the server does.
 #""

 #ode = 411
 #escription = (
 #A request with this method requires a valid <code>Content-"
 #Length</code> header."
 #


class PreconditionFailed(HTTPException):
 #""*412* `Precondition Failed`

 #tatus code used in combination with ``If-Match``, ``If-None-Match``, or
 #`If-Unmodified-Since``.
 #""

 #ode = 412
 #escription = (
 #The precondition on the request for the URL failed positive evaluation."
 #


class RequestEntityTooLarge(HTTPException):
 #""*413* `Request Entity Too Large`

 #he status code one should return if the data submitted exceeded a given
 #imit.
 #""

 #ode = 413
 #escription = "The data value transmitted exceeds the capacity limit."


class RequestURITooLarge(HTTPException):
 #""*414* `Request URI Too Large`

 #ike *413* but for too long URLs.
 #""

 #ode = 414
 #escription = (
 #The length of the requested URL exceeds the capacity limit for"
 # this server. The request cannot be processed."
 #


class UnsupportedMediaType(HTTPException):
 #""*415* `Unsupported Media Type`

 #he status code returned if the server is unable to handle the media type
 #he client transmitted.
 #""

 #ode = 415
 #escription = (
 #The server does not support the media type transmitted in the request."
 #


class RequestedRangeNotSatisfiable(HTTPException):
 #""*416* `Requested Range Not Satisfiable`

 #he client asked for an invalid part of the file.

 #. versionadded:: 0.7
 #""

 #ode = 416
 #escription = "The server cannot provide the requested range."

 #ef __init__(
 #elf,
 #ength: t.Optional[int] = None,
 #nits: str = "bytes",
 #escription: t.Optional[str] = None,
 #esponse: t.Optional["Response"] = None,
 # -> None:
 #""Takes an optional `Content-Range` header value based on ``length``
 #arameter.
 #""
 #uper().__init__(description=description, response=response)
 #elf.length = length
 #elf.units = units

 #ef get_headers(
 #elf,
 #nviron: t.Optional["WSGIEnvironment"] = None,
 #cope: t.Optional[dict] = None,
 # -> t.List[t.Tuple[str, str]]:
 #eaders = super().get_headers(environ, scope)
 #f self.length is not None:
 #eaders.append(("Content-Range", f"{self.units} */{self.length}"))
 #eturn headers


class ExpectationFailed(HTTPException):
 #""*417* `Expectation Failed`

 #he server cannot meet the requirements of the Expect request-header.

 #. versionadded:: 0.7
 #""

 #ode = 417
 #escription = "The server could not meet the requirements of the Expect header"


class ImATeapot(HTTPException):
 #""*418* `I'm a teapot`

 #he server should return this if it is a teapot and someone attempted
 #o brew coffee with it.

 #. versionadded:: 0.7
 #""

 #ode = 418
 #escription = "This server is a teapot, not a coffee machine"


class UnprocessableEntity(HTTPException):
 #""*422* `Unprocessable Entity`

 #sed if the request is well formed, but the instructions are otherwise
 #ncorrect.
 #""

 #ode = 422
 #escription = (
 #The request was well-formed but was unable to be followed due"
 # to semantic errors."
 #


class Locked(HTTPException):
 #""*423* `Locked`

 #sed if the resource that is being accessed is locked.
 #""

 #ode = 423
 #escription = "The resource that is being accessed is locked."


class FailedDependency(HTTPException):
 #""*424* `Failed Dependency`

 #sed if the method could not be performed on the resource
 #ecause the requested action depended on another action and that action failed.
 #""

 #ode = 424
 #escription = (
 #The method could not be performed on the resource because the"
 # requested action depended on another action and that action"
 # failed."
 #


class PreconditionRequired(HTTPException):
 #""*428* `Precondition Required`

 #he server requires this request to be conditional, typically to prevent
 #he lost update problem, which is a race condition between two or more
 #lients attempting to update a resource through PUT or DELETE. By requiring
 #ach client to include a conditional header ("If-Match" or "If-Unmodified-
 #ince") with the proper value retained from a recent GET request, the
 #erver ensures that each client has at least seen the previous revision of
 #he resource.
 #""

 #ode = 428
 #escription = (
 #This request is required to be conditional; try using"
 # "If-Match" or "If-Unmodified-Since".'
 #


class _RetryAfter(HTTPException):
 #""Adds an optional ``retry_after`` parameter which will set the
 #`Retry-After`` header. May be an :class:`int` number of seconds or
 # :class:`~datetime.datetime`.
 #""

 #ef __init__(
 #elf,
 #escription: t.Optional[str] = None,
 #esponse: t.Optional["Response"] = None,
 #etry_after: t.Optional[t.Union[datetime, int]] = None,
 # -> None:
 #uper().__init__(description, response)
 #elf.retry_after = retry_after

 #ef get_headers(
 #elf,
 #nviron: t.Optional["WSGIEnvironment"] = None,
 #cope: t.Optional[dict] = None,
 # -> t.List[t.Tuple[str, str]]:
 #eaders = super().get_headers(environ, scope)

 #f self.retry_after:
 #f isinstance(self.retry_after, datetime):
 #rom .http import http_date

 #alue = http_date(self.retry_after)
 #lse:
 #alue = str(self.retry_after)

 #eaders.append(("Retry-After", value))

 #eturn headers


class TooManyRequests(_RetryAfter):
 #""*429* `Too Many Requests`

 #he server is limiting the rate at which this user receives
 #esponses, and this request exceeds that rate. (The server may use
 #ny convenient method to identify users and their request rates).
 #he server may include a "Retry-After" header to indicate how long
 #he user should wait before retrying.

 #param retry_after: If given, set the ``Retry-After`` header to this
 #alue. May be an :class:`int` number of seconds or a
 #class:`~datetime.datetime`.

 #. versionchanged:: 1.0
 #dded ``retry_after`` parameter.
 #""

 #ode = 429
 #escription = "This user has exceeded an allotted request count. Try again later."


class RequestHeaderFieldsTooLarge(HTTPException):
 #""*431* `Request Header Fields Too Large`

 #he server refuses to process the request because the header fields are too
 #arge. One or more individual fields may be too large, or the set of all
 #eaders is too large.
 #""

 #ode = 431
 #escription = "One or more header fields exceeds the maximum size."


class UnavailableForLegalReasons(HTTPException):
 #""*451* `Unavailable For Legal Reasons`

 #his status code indicates that the server is denying access to the
 #esource as a consequence of a legal demand.
 #""

 #ode = 451
 #escription = "Unavailable for legal reasons."


class InternalServerError(HTTPException):
 #""*500* `Internal Server Error`

 #aise if an internal server error occurred.  This is a good fallback if an
 #nknown error occurred in the dispatcher.

 #. versionchanged:: 1.0.0
 #dded the :attr:`original_exception` attribute.
 #""

 #ode = 500
 #escription = (
 #The server encountered an internal error and was unable to"
 # complete your request. Either the server is overloaded or"
 # there is an error in the application."
 #

 #ef __init__(
 #elf,
 #escription: t.Optional[str] = None,
 #esponse: t.Optional["Response"] = None,
 #riginal_exception: t.Optional[BaseException] = None,
 # -> None:
        #: The original exception that caused this 500 error. Can be
        #: used by frameworks to provide context when handling
        #: unexpected errors.
 #elf.original_exception = original_exception
 #uper().__init__(description=description, response=response)


class NotImplemented(HTTPException):
 #""*501* `Not Implemented`

 #aise if the application does not support the action requested by the
 #rowser.
 #""

 #ode = 501
 #escription = "The server does not support the action requested by the browser."


class BadGateway(HTTPException):
 #""*502* `Bad Gateway`

 #f you do proxying in your application you should return this status code
 #f you received an invalid response from the upstream server it accessed
 #n attempting to fulfill the request.
 #""

 #ode = 502
 #escription = (
 #The proxy server received an invalid response from an upstream server."
 #


class ServiceUnavailable(_RetryAfter):
 #""*503* `Service Unavailable`

 #tatus code you should return if a service is temporarily
 #navailable.

 #param retry_after: If given, set the ``Retry-After`` header to this
 #alue. May be an :class:`int` number of seconds or a
 #class:`~datetime.datetime`.

 #. versionchanged:: 1.0
 #dded ``retry_after`` parameter.
 #""

 #ode = 503
 #escription = (
 #The server is temporarily unable to service your request due"
 # to maintenance downtime or capacity problems. Please try"
 # again later."
 #


class GatewayTimeout(HTTPException):
 #""*504* `Gateway Timeout`

 #tatus code you should return if a connection to an upstream server
 #imes out.
 #""

 #ode = 504
 #escription = "The connection to an upstream server timed out."


class HTTPVersionNotSupported(HTTPException):
 #""*505* `HTTP Version Not Supported`

 #he server does not support the HTTP protocol version used in the request.
 #""

 #ode = 505
 #escription = (
 #The server does not support the HTTP protocol version used in the request."
 #


default_exceptions: t.Dict[int, t.Type[HTTPException]] = {}


def _find_exceptions() -> None:
 #or obj in globals().values():
 #ry:
 #s_http_exception = issubclass(obj, HTTPException)
 #xcept TypeError:
 #s_http_exception = False
 #f not is_http_exception or obj.code is None:
 #ontinue
 #ld_obj = default_exceptions.get(obj.code, None)
 #f old_obj is not None and issubclass(obj, old_obj):
 #ontinue
 #efault_exceptions[obj.code] = obj


_find_exceptions()
del _find_exceptions


class Aborter:
 #""When passed a dict of code -> exception items it can be used as
 #allable that raises exceptions.  If the first argument to the
 #allable is an integer it will be looked up in the mapping, if it's
 # WSGI application it will be raised in a proxy exception.

 #he rest of the arguments are forwarded to the exception constructor.
 #""

 #ef __init__(
 #elf,
 #apping: t.Optional[t.Dict[int, t.Type[HTTPException]]] = None,
 #xtra: t.Optional[t.Dict[int, t.Type[HTTPException]]] = None,
 # -> None:
 #f mapping is None:
 #apping = default_exceptions
 #elf.mapping = dict(mapping)
 #f extra is not None:
 #elf.mapping.update(extra)

 #ef __call__(
 #elf, code: t.Union[int, "Response"], *args: t.Any, **kwargs: t.Any
 # -> "te.NoReturn":
 #rom .sansio.response import Response

 #f isinstance(code, Response):
 #aise HTTPException(response=code)

 #f code not in self.mapping:
 #aise LookupError(f"no exception for {code!r}")

 #aise self.mapping[code](*args, **kwargs)


def abort(
 #tatus: t.Union[int, "Response"], *args: t.Any, **kwargs: t.Any
) -> "te.NoReturn":
 #""Raises an :py:exc:`HTTPException` for the given status code or WSGI
 #pplication.

 #f a status code is given, it will be looked up in the list of
 #xceptions and will raise that exception.  If passed a WSGI application,
 #t will wrap it in a proxy WSGI exception and raise that::

 #bort(404)  # 404 Not Found
 #bort(Response('Hello World'))

 #""
 #aborter(status, *args, **kwargs)


_aborter: Aborter = Aborter()
