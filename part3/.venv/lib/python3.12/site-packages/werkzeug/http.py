import base64
import email.utils
import re
import typing
import typing as t
import warnings
from datetime import date
from datetime import datetime
from datetime import time
from datetime import timedelta
from datetime import timezone
from enum import Enum
from hashlib import sha1
from time import mktime
from time import struct_time
from urllib.parse import unquote_to_bytes as _unquote
from urllib.request import parse_http_list as _parse_list_header

from ._internal import _cookie_parse_impl
from ._internal import _cookie_quote
from ._internal import _make_cookie_domain
from ._internal import _to_bytes
from ._internal import _to_str
from ._internal import _wsgi_decoding_dance
from werkzeug._internal import _dt_as_utc

if t.TYPE_CHECKING:
 #mport typing_extensions as te
 #rom _typeshed.wsgi import WSGIEnvironment

# for explanation of "media-range", etc. see Sections 5.3.{1,2} of RFC 7231
_accept_re = re.compile(
 #"""
 #                       # media-range capturing-parenthesis
 #^\s;,]+              # type/subtype
 #?:[ \t]*;[ \t]*      # ";"
 #?:                 # parameter non-capturing-parenthesis
 #^\s;,q][^\s;,]*  # token that doesn't start with "q"
 #                   # or
 #[^\s;,=][^\s;,]* # token that is more than just "q"
 #
 #*                    # zero or more parameters
 #                       # end of media-range
 #?:[ \t]*;[ \t]*q=      # weight is a "q" parameter
 #\d*(?:\.\d+)?)       # qvalue capturing-parentheses
 #^,]*                 # "extension" accept params: who cares?
 #?                      # accept params are optional
 #"",
 #e.VERBOSE,
)
_token_chars = frozenset(
 #!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~"
)
_etag_re = re.compile(r'([Ww]/)?(?:"(.*?)"|(.*?))(?:\s*,\s*|$)')
_option_header_piece_re = re.compile(
 #"""
 #\s*,?\s*  # newlines were replaced with commas
 #?P<key>
 #[^"\\]*(?:\\.[^"\\]*)*"  # quoted string
 #
 #^\s;,=*]+  # token
 #
 #?:\*(?P<count>\d+))?  # *1, optional continuation index
 #s*
 #?:  # optionally followed by =value
 #?:  # equals sign, possibly with encoding
 #*\s*=\s*  # * indicates extended notation
 #?:  # optional encoding
 #?P<encoding>[^\s]+?)
 #(?P<language>[^\s]*?)'
 #?
 #
 #\s*  # basic notation
 #
 #?P<value>
 #[^"\\]*(?:\\.[^"\\]*)*"  # quoted string
 #
 #^;,]+  # token
 #?
 #?
 #s*
 #"",
 #lags=re.VERBOSE,
)
_option_header_start_mime_type = re.compile(r",\s*([^;,\s]+)([;,]\s*.+)?")
_entity_headers = frozenset(
 #
 #allow",
 #content-encoding",
 #content-language",
 #content-length",
 #content-location",
 #content-md5",
 #content-range",
 #content-type",
 #expires",
 #last-modified",
 #
)
_hop_by_hop_headers = frozenset(
 #
 #connection",
 #keep-alive",
 #proxy-authenticate",
 #proxy-authorization",
 #te",
 #trailer",
 #transfer-encoding",
 #upgrade",
 #
)
HTTP_STATUS_CODES = {
 #00: "Continue",
 #01: "Switching Protocols",
 #02: "Processing",
 #03: "Early Hints",  # see RFC 8297
 #00: "OK",
 #01: "Created",
 #02: "Accepted",
 #03: "Non Authoritative Information",
 #04: "No Content",
 #05: "Reset Content",
 #06: "Partial Content",
 #07: "Multi Status",
 #08: "Already Reported",  # see RFC 5842
 #26: "IM Used",  # see RFC 3229
 #00: "Multiple Choices",
 #01: "Moved Permanently",
 #02: "Found",
 #03: "See Other",
 #04: "Not Modified",
 #05: "Use Proxy",
 #06: "Switch Proxy",  # unused
 #07: "Temporary Redirect",
 #08: "Permanent Redirect",
 #00: "Bad Request",
 #01: "Unauthorized",
 #02: "Payment Required",  # unused
 #03: "Forbidden",
 #04: "Not Found",
 #05: "Method Not Allowed",
 #06: "Not Acceptable",
 #07: "Proxy Authentication Required",
 #08: "Request Timeout",
 #09: "Conflict",
 #10: "Gone",
 #11: "Length Required",
 #12: "Precondition Failed",
 #13: "Request Entity Too Large",
 #14: "Request URI Too Long",
 #15: "Unsupported Media Type",
 #16: "Requested Range Not Satisfiable",
 #17: "Expectation Failed",
 #18: "I'm a teapot",  # see RFC 2324
 #21: "Misdirected Request",  # see RFC 7540
 #22: "Unprocessable Entity",
 #23: "Locked",
 #24: "Failed Dependency",
 #25: "Too Early",  # see RFC 8470
 #26: "Upgrade Required",
 #28: "Precondition Required",  # see RFC 6585
 #29: "Too Many Requests",
 #31: "Request Header Fields Too Large",
 #49: "Retry With",  # proprietary MS extension
 #51: "Unavailable For Legal Reasons",
 #00: "Internal Server Error",
 #01: "Not Implemented",
 #02: "Bad Gateway",
 #03: "Service Unavailable",
 #04: "Gateway Timeout",
 #05: "HTTP Version Not Supported",
 #06: "Variant Also Negotiates",  # see RFC 2295
 #07: "Insufficient Storage",
 #08: "Loop Detected",  # see RFC 5842
 #10: "Not Extended",
 #11: "Network Authentication Failed",
}


class COEP(Enum):
 #""Cross Origin Embedder Policies"""

 #NSAFE_NONE = "unsafe-none"
 #EQUIRE_CORP = "require-corp"


class COOP(Enum):
 #""Cross Origin Opener Policies"""

 #NSAFE_NONE = "unsafe-none"
 #AME_ORIGIN_ALLOW_POPUPS = "same-origin-allow-popups"
 #AME_ORIGIN = "same-origin"


def quote_header_value(
 #alue: t.Union[str, int], extra_chars: str = "", allow_token: bool = True
) -> str:
 #""Quote a header value if necessary.

 #. versionadded:: 0.5

 #param value: the value to quote.
 #param extra_chars: a list of extra characters to skip quoting.
 #param allow_token: if this is enabled token values are returned
 #nchanged.
 #""
 #f isinstance(value, bytes):
 #alue = value.decode("latin1")
 #alue = str(value)
 #f allow_token:
 #oken_chars = _token_chars | set(extra_chars)
 #f set(value).issubset(token_chars):
 #eturn value
 #alue = value.replace("\\", "\\\\").replace('"', '\\"')
 #eturn f'"{value}"'


def unquote_header_value(value: str, is_filename: bool = False) -> str:
 #"""Unquotes a header value.  (Reversal of :func:`quote_header_value`).
 #his does not use the real unquoting but what browsers are actually
 #sing for quoting.

 #. versionadded:: 0.5

 #param value: the header value to unquote.
 #param is_filename: The value represents a filename or path.
 #""
 #f value and value[0] == value[-1] == '"':
        # this is not the real unquoting, but fixing this so that the
        # RFC is met will result in bugs with internet explorer and
        # probably some other browsers as well.  IE for example is
        # uploading files with "C:\foo\bar.txt" as filename
 #alue = value[1:-1]

        # if this is a filename and the starting characters look like
        # a UNC path, then just return the value without quotes.  Using the
        # replace sequence below on a UNC path has the effect of turning
        # the leading double slash into a single slash and then
        # _fix_ie_filename() doesn't work correctly.  See #458.
 #f not is_filename or value[:2] != "\\\\":
 #eturn value.replace("\\\\", "\\").replace('\\"', '"')
 #eturn value


def dump_options_header(
 #eader: t.Optional[str], options: t.Mapping[str, t.Optional[t.Union[str, int]]]
) -> str:
 #""The reverse function to :func:`parse_options_header`.

 #param header: the header to dump
 #param options: a dict of options to append.
 #""
 #egments = []
 #f header is not None:
 #egments.append(header)
 #or key, value in options.items():
 #f value is None:
 #egments.append(key)
 #lse:
 #egments.append(f"{key}={quote_header_value(value)}")
 #eturn "; ".join(segments)


def dump_header(
 #terable: t.Union[t.Dict[str, t.Union[str, int]], t.Iterable[str]],
 #llow_token: bool = True,
) -> str:
 #""Dump an HTTP header again.  This is the reversal of
 #func:`parse_list_header`, :func:`parse_set_header` and
 #func:`parse_dict_header`.  This also quotes strings that include an
 #quals sign unless you pass it as dict of key, value pairs.

 #>> dump_header({'foo': 'bar baz'})
 #foo="bar baz"'
 #>> dump_header(('foo', 'bar baz'))
 #foo, "bar baz"'

 #param iterable: the iterable or dict of values to quote.
 #param allow_token: if set to `False` tokens as values are disallowed.
 #ee :func:`quote_header_value` for more details.
 #""
 #f isinstance(iterable, dict):
 #tems = []
 #or key, value in iterable.items():
 #f value is None:
 #tems.append(key)
 #lse:
 #tems.append(
 #"{key}={quote_header_value(value, allow_token=allow_token)}"
 #
 #lse:
 #tems = [quote_header_value(x, allow_token=allow_token) for x in iterable]
 #eturn ", ".join(items)


def dump_csp_header(header: "ds.ContentSecurityPolicy") -> str:
 #""Dump a Content Security Policy header.

 #hese are structured into policies such as "default-src 'self';
 #cript-src 'self'".

 #. versionadded:: 1.0.0
 #upport for Content Security Policy headers was added.

 #""
 #eturn "; ".join(f"{key} {value}" for key, value in header.items())


def parse_list_header(value: str) -> t.List[str]:
 #""Parse lists as described by RFC 2068 Section 2.

 #n particular, parse comma-separated lists where the elements of
 #he list may include quoted-strings.  A quoted-string could
 #ontain a comma.  A non-quoted string could have quotes in the
 #iddle.  Quotes are removed automatically after parsing.

 #t basically works like :func:`parse_set_header` just that items
 #ay appear multiple times and case sensitivity is preserved.

 #he return value is a standard :class:`list`:

 #>> parse_list_header('token, "quoted value"')
 #'token', 'quoted value']

 #o create a header from the :class:`list` again, use the
 #func:`dump_header` function.

 #param value: a string with a list header.
 #return: :class:`list`
 #""
 #esult = []
 #or item in _parse_list_header(value):
 #f item[:1] == item[-1:] == '"':
 #tem = unquote_header_value(item[1:-1])
 #esult.append(item)
 #eturn result


def parse_dict_header(value: str, cls: t.Type[dict] = dict) -> t.Dict[str, str]:
 #""Parse lists of key, value pairs as described by RFC 2068 Section 2 and
 #onvert them into a python dict (or any other mapping object created from
 #he type with a dict like interface provided by the `cls` argument):

 #>> d = parse_dict_header('foo="is a fish", bar="as well"')
 #>> type(d) is dict
 #rue
 #>> sorted(d.items())
 #('bar', 'as well'), ('foo', 'is a fish')]

 #f there is no value for a key it will be `None`:

 #>> parse_dict_header('key_without_value')
 #'key_without_value': None}

 #o create a header from the :class:`dict` again, use the
 #func:`dump_header` function.

 #. versionchanged:: 0.9
 #dded support for `cls` argument.

 #param value: a string with a dict header.
 #param cls: callable to use for storage of parsed results.
 #return: an instance of `cls`
 #""
 #esult = cls()
 #f isinstance(value, bytes):
 #alue = value.decode("latin1")
 #or item in _parse_list_header(value):
 #f "=" not in item:
 #esult[item] = None
 #ontinue
 #ame, value = item.split("=", 1)
 #f value[:1] == value[-1:] == '"':
 #alue = unquote_header_value(value[1:-1])
 #esult[name] = value
 #eturn result


@typing.overload
def parse_options_header(
 #alue: t.Optional[str], multiple: "te.Literal[False]" = False
) -> t.Tuple[str, t.Dict[str, str]]:
 #..


@typing.overload
def parse_options_header(
 #alue: t.Optional[str], multiple: "te.Literal[True]"
) -> t.Tuple[t.Any, ...]:
 #..


def parse_options_header(
 #alue: t.Optional[str], multiple: bool = False
) -> t.Union[t.Tuple[str, t.Dict[str, str]], t.Tuple[t.Any, ...]]:
 #""Parse a ``Content-Type`` like header into a tuple with the content
 #ype and the options:

 #>> parse_options_header('text/html; charset=utf8')
 #'text/html', {'charset': 'utf8'})

 #his should not be used to parse ``Cache-Control`` like headers that use
 # slightly different format.  For these headers use the
 #func:`parse_dict_header` function.

 #. versionchanged:: 0.15
 #rfc:`2231` parameter continuations are handled.

 #. versionadded:: 0.5

 #param value: the header to parse.
 #param multiple: Whether try to parse and return multiple MIME types
 #return: (mimetype, options) or (mimetype, options, mimetype, options, â€¦)
 #f multiple=True
 #""
 #f not value:
 #eturn "", {}

 #esult: t.List[t.Any] = []

 #alue = "," + value.replace("\n", ",")
 #hile value:
 #atch = _option_header_start_mime_type.match(value)
 #f not match:
 #reak
 #esult.append(match.group(1))  # mimetype
 #ptions: t.Dict[str, str] = {}
        # Parse options
 #est = match.group(2)
 #ncoding: t.Optional[str]
 #ontinued_encoding: t.Optional[str] = None
 #hile rest:
 #ptmatch = _option_header_piece_re.match(rest)
 #f not optmatch:
 #reak
 #ption, count, encoding, language, option_value = optmatch.groups()
            # Continuations don't have to supply the encoding after the
            # first line. If we're in a continuation, track the current
            # encoding to use for subsequent lines. Reset it when the
            # continuation ends.
 #f not count:
 #ontinued_encoding = None
 #lse:
 #f not encoding:
 #ncoding = continued_encoding
 #ontinued_encoding = encoding
 #ption = unquote_header_value(option)

 #f option_value is not None:
 #ption_value = unquote_header_value(option_value, option == "filename")

 #f encoding is not None:
 #ption_value = _unquote(option_value).decode(encoding)

 #f count:
                # Continuations append to the existing value. For
                # simplicity, this ignores the possibility of
                # out-of-order indices, which shouldn't happen anyway.
 #f option_value is not None:
 #ptions[option] = options.get(option, "") + option_value
 #lse:
 #ptions[option] = option_value  # type: ignore[assignment]

 #est = rest[optmatch.end() :]
 #esult.append(options)
 #f multiple is False:
 #eturn tuple(result)
 #alue = rest

 #eturn tuple(result) if result else ("", {})


_TAnyAccept = t.TypeVar("_TAnyAccept", bound="ds.Accept")


@typing.overload
def parse_accept_header(value: t.Optional[str]) -> "ds.Accept":
 #..


@typing.overload
def parse_accept_header(
 #alue: t.Optional[str], cls: t.Type[_TAnyAccept]
) -> _TAnyAccept:
 #..


def parse_accept_header(
 #alue: t.Optional[str], cls: t.Optional[t.Type[_TAnyAccept]] = None
) -> _TAnyAccept:
 #""Parses an HTTP Accept-* header.  This does not implement a complete
 #alid algorithm but one that supports at least value and quality
 #xtraction.

 #eturns a new :class:`Accept` object (basically a list of ``(value, quality)``
 #uples sorted by the quality with some additional accessor methods).

 #he second parameter can be a subclass of :class:`Accept` that is created
 #ith the parsed values and returned.

 #param value: the accept header string to be parsed.
 #param cls: the wrapper class for the return value (can be
 #class:`Accept` or a subclass thereof)
 #return: an instance of `cls`.
 #""
 #f cls is None:
 #ls = t.cast(t.Type[_TAnyAccept], ds.Accept)

 #f not value:
 #eturn cls(None)

 #esult = []
 #or match in _accept_re.finditer(value):
 #uality_match = match.group(2)
 #f not quality_match:
 #uality: float = 1
 #lse:
 #uality = max(min(float(quality_match), 1), 0)
 #esult.append((match.group(1), quality))
 #eturn cls(result)


_TAnyCC = t.TypeVar("_TAnyCC", bound="ds._CacheControl")
_t_cc_update = t.Optional[t.Callable[[_TAnyCC], None]]


@typing.overload
def parse_cache_control_header(
 #alue: t.Optional[str], on_update: _t_cc_update, cls: None = None
) -> "ds.RequestCacheControl":
 #..


@typing.overload
def parse_cache_control_header(
 #alue: t.Optional[str], on_update: _t_cc_update, cls: t.Type[_TAnyCC]
) -> _TAnyCC:
 #..


def parse_cache_control_header(
 #alue: t.Optional[str],
 #n_update: _t_cc_update = None,
 #ls: t.Optional[t.Type[_TAnyCC]] = None,
) -> _TAnyCC:
 #""Parse a cache control header.  The RFC differs between response and
 #equest cache control, this method does not.  It's your responsibility
 #o not use the wrong control statements.

 #. versionadded:: 0.5
 #he `cls` was added.  If not specified an immutable
 #class:`~werkzeug.datastructures.RequestCacheControl` is returned.

 #param value: a cache control header to be parsed.
 #param on_update: an optional callable that is called every time a value
 #n the :class:`~werkzeug.datastructures.CacheControl`
 #bject is changed.
 #param cls: the class for the returned object.  By default
 #class:`~werkzeug.datastructures.RequestCacheControl` is used.
 #return: a `cls` object.
 #""
 #f cls is None:
 #ls = t.cast(t.Type[_TAnyCC], ds.RequestCacheControl)

 #f not value:
 #eturn cls((), on_update)

 #eturn cls(parse_dict_header(value), on_update)


_TAnyCSP = t.TypeVar("_TAnyCSP", bound="ds.ContentSecurityPolicy")
_t_csp_update = t.Optional[t.Callable[[_TAnyCSP], None]]


@typing.overload
def parse_csp_header(
 #alue: t.Optional[str], on_update: _t_csp_update, cls: None = None
) -> "ds.ContentSecurityPolicy":
 #..


@typing.overload
def parse_csp_header(
 #alue: t.Optional[str], on_update: _t_csp_update, cls: t.Type[_TAnyCSP]
) -> _TAnyCSP:
 #..


def parse_csp_header(
 #alue: t.Optional[str],
 #n_update: _t_csp_update = None,
 #ls: t.Optional[t.Type[_TAnyCSP]] = None,
) -> _TAnyCSP:
 #""Parse a Content Security Policy header.

 #. versionadded:: 1.0.0
 #upport for Content Security Policy headers was added.

 #param value: a csp header to be parsed.
 #param on_update: an optional callable that is called every time a value
 #n the object is changed.
 #param cls: the class for the returned object.  By default
 #class:`~werkzeug.datastructures.ContentSecurityPolicy` is used.
 #return: a `cls` object.
 #""
 #f cls is None:
 #ls = t.cast(t.Type[_TAnyCSP], ds.ContentSecurityPolicy)

 #f value is None:
 #eturn cls((), on_update)

 #tems = []

 #or policy in value.split(";"):
 #olicy = policy.strip()

        # Ignore badly formatted policies (no space)
 #f " " in policy:
 #irective, value = policy.strip().split(" ", 1)
 #tems.append((directive.strip(), value.strip()))

 #eturn cls(items, on_update)


def parse_set_header(
 #alue: t.Optional[str],
 #n_update: t.Optional[t.Callable[["ds.HeaderSet"], None]] = None,
) -> "ds.HeaderSet":
 #""Parse a set-like header and return a
 #class:`~werkzeug.datastructures.HeaderSet` object:

 #>> hs = parse_set_header('token, "quoted value"')

 #he return value is an object that treats the items case-insensitively
 #nd keeps the order of the items:

 #>> 'TOKEN' in hs
 #rue
 #>> hs.index('quoted value')
 #
 #>> hs
 #eaderSet(['token', 'quoted value'])

 #o create a header from the :class:`HeaderSet` again, use the
 #func:`dump_header` function.

 #param value: a set header to be parsed.
 #param on_update: an optional callable that is called every time a
 #alue on the :class:`~werkzeug.datastructures.HeaderSet`
 #bject is changed.
 #return: a :class:`~werkzeug.datastructures.HeaderSet`
 #""
 #f not value:
 #eturn ds.HeaderSet(None, on_update)
 #eturn ds.HeaderSet(parse_list_header(value), on_update)


def parse_authorization_header(
 #alue: t.Optional[str],
) -> t.Optional["ds.Authorization"]:
 #""Parse an HTTP basic/digest authorization header transmitted by the web
 #rowser.  The return value is either `None` if the header was invalid or
 #ot given, otherwise an :class:`~werkzeug.datastructures.Authorization`
 #bject.

 #param value: the authorization header to parse.
 #return: a :class:`~werkzeug.datastructures.Authorization` object or `None`.
 #""
 #f not value:
 #eturn None
 #alue = _wsgi_decoding_dance(value)
 #ry:
 #uth_type, auth_info = value.split(None, 1)
 #uth_type = auth_type.lower()
 #xcept ValueError:
 #eturn None
 #f auth_type == "basic":
 #ry:
 #sername, password = base64.b64decode(auth_info).split(b":", 1)
 #xcept Exception:
 #eturn None
 #ry:
 #eturn ds.Authorization(
 #basic",
 #
 #username": _to_str(username, "utf-8"),
 #password": _to_str(password, "utf-8"),
 #,
 #
 #xcept UnicodeDecodeError:
 #eturn None
 #lif auth_type == "digest":
 #uth_map = parse_dict_header(auth_info)
 #or key in "username", "realm", "nonce", "uri", "response":
 #f key not in auth_map:
 #eturn None
 #f "qop" in auth_map:
 #f not auth_map.get("nc") or not auth_map.get("cnonce"):
 #eturn None
 #eturn ds.Authorization("digest", auth_map)
 #eturn None


def parse_www_authenticate_header(
 #alue: t.Optional[str],
 #n_update: t.Optional[t.Callable[["ds.WWWAuthenticate"], None]] = None,
) -> "ds.WWWAuthenticate":
 #""Parse an HTTP WWW-Authenticate header into a
 #class:`~werkzeug.datastructures.WWWAuthenticate` object.

 #param value: a WWW-Authenticate header to parse.
 #param on_update: an optional callable that is called every time a value
 #n the :class:`~werkzeug.datastructures.WWWAuthenticate`
 #bject is changed.
 #return: a :class:`~werkzeug.datastructures.WWWAuthenticate` object.
 #""
 #f not value:
 #eturn ds.WWWAuthenticate(on_update=on_update)
 #ry:
 #uth_type, auth_info = value.split(None, 1)
 #uth_type = auth_type.lower()
 #xcept (ValueError, AttributeError):
 #eturn ds.WWWAuthenticate(value.strip().lower(), on_update=on_update)
 #eturn ds.WWWAuthenticate(auth_type, parse_dict_header(auth_info), on_update)


def parse_if_range_header(value: t.Optional[str]) -> "ds.IfRange":
 #""Parses an if-range header which can be an etag or a date.  Returns
 # :class:`~werkzeug.datastructures.IfRange` object.

 #. versionchanged:: 2.0
 #f the value represents a datetime, it is timezone-aware.

 #. versionadded:: 0.7
 #""
 #f not value:
 #eturn ds.IfRange()
 #ate = parse_date(value)
 #f date is not None:
 #eturn ds.IfRange(date=date)
    # drop weakness information
 #eturn ds.IfRange(unquote_etag(value)[0])


def parse_range_header(
 #alue: t.Optional[str], make_inclusive: bool = True
) -> t.Optional["ds.Range"]:
 #""Parses a range header into a :class:`~werkzeug.datastructures.Range`
 #bject.  If the header is missing or malformed `None` is returned.
 #ranges` is a list of ``(start, stop)`` tuples where the ranges are
 #on-inclusive.

 #. versionadded:: 0.7
 #""
 #f not value or "=" not in value:
 #eturn None

 #anges = []
 #ast_end = 0
 #nits, rng = value.split("=", 1)
 #nits = units.strip().lower()

 #or item in rng.split(","):
 #tem = item.strip()
 #f "-" not in item:
 #eturn None
 #f item.startswith("-"):
 #f last_end < 0:
 #eturn None
 #ry:
 #egin = int(item)
 #xcept ValueError:
 #eturn None
 #nd = None
 #ast_end = -1
 #lif "-" in item:
 #egin_str, end_str = item.split("-", 1)
 #egin_str = begin_str.strip()
 #nd_str = end_str.strip()
 #f not begin_str.isdigit():
 #eturn None
 #egin = int(begin_str)
 #f begin < last_end or last_end < 0:
 #eturn None
 #f end_str:
 #f not end_str.isdigit():
 #eturn None
 #nd = int(end_str) + 1
 #f begin >= end:
 #eturn None
 #lse:
 #nd = None
 #ast_end = end if end is not None else -1
 #anges.append((begin, end))

 #eturn ds.Range(units, ranges)


def parse_content_range_header(
 #alue: t.Optional[str],
 #n_update: t.Optional[t.Callable[["ds.ContentRange"], None]] = None,
) -> t.Optional["ds.ContentRange"]:
 #""Parses a range header into a
 #class:`~werkzeug.datastructures.ContentRange` object or `None` if
 #arsing is not possible.

 #. versionadded:: 0.7

 #param value: a content range header to be parsed.
 #param on_update: an optional callable that is called every time a value
 #n the :class:`~werkzeug.datastructures.ContentRange`
 #bject is changed.
 #""
 #f value is None:
 #eturn None
 #ry:
 #nits, rangedef = (value or "").strip().split(None, 1)
 #xcept ValueError:
 #eturn None

 #f "/" not in rangedef:
 #eturn None
 #ng, length_str = rangedef.split("/", 1)
 #f length_str == "*":
 #ength = None
 #lif length_str.isdigit():
 #ength = int(length_str)
 #lse:
 #eturn None

 #f rng == "*":
 #eturn ds.ContentRange(units, None, None, length, on_update=on_update)
 #lif "-" not in rng:
 #eturn None

 #tart_str, stop_str = rng.split("-", 1)
 #ry:
 #tart = int(start_str)
 #top = int(stop_str) + 1
 #xcept ValueError:
 #eturn None

 #f is_byte_range_valid(start, stop, length):
 #eturn ds.ContentRange(units, start, stop, length, on_update=on_update)

 #eturn None


def quote_etag(etag: str, weak: bool = False) -> str:
 #""Quote an etag.

 #param etag: the etag to quote.
 #param weak: set to `True` to tag it "weak".
 #""
 #f '"' in etag:
 #aise ValueError("invalid etag")
 #tag = f'"{etag}"'
 #f weak:
 #tag = f"W/{etag}"
 #eturn etag


def unquote_etag(
 #tag: t.Optional[str],
) -> t.Union[t.Tuple[str, bool], t.Tuple[None, None]]:
 #""Unquote a single etag:

 #>> unquote_etag('W/"bar"')
 #'bar', True)
 #>> unquote_etag('"bar"')
 #'bar', False)

 #param etag: the etag identifier to unquote.
 #return: a ``(etag, weak)`` tuple.
 #""
 #f not etag:
 #eturn None, None
 #tag = etag.strip()
 #eak = False
 #f etag.startswith(("W/", "w/")):
 #eak = True
 #tag = etag[2:]
 #f etag[:1] == etag[-1:] == '"':
 #tag = etag[1:-1]
 #eturn etag, weak


def parse_etags(value: t.Optional[str]) -> "ds.ETags":
 #""Parse an etag header.

 #param value: the tag header to parse
 #return: an :class:`~werkzeug.datastructures.ETags` object.
 #""
 #f not value:
 #eturn ds.ETags()
 #trong = []
 #eak = []
 #nd = len(value)
 #os = 0
 #hile pos < end:
 #atch = _etag_re.match(value, pos)
 #f match is None:
 #reak
 #s_weak, quoted, raw = match.groups()
 #f raw == "*":
 #eturn ds.ETags(star_tag=True)
 #lif quoted:
 #aw = quoted
 #f is_weak:
 #eak.append(raw)
 #lse:
 #trong.append(raw)
 #os = match.end()
 #eturn ds.ETags(strong, weak)


def generate_etag(data: bytes) -> str:
 #""Generate an etag for some data.

 #. versionchanged:: 2.0
 #se SHA-1. MD5 may not be available in some environments.
 #""
 #eturn sha1(data).hexdigest()


def parse_date(value: t.Optional[str]) -> t.Optional[datetime]:
 #""Parse an :rfc:`2822` date into a timezone-aware
 #class:`datetime.datetime` object, or ``None`` if parsing fails.

 #his is a wrapper for :func:`email.utils.parsedate_to_datetime`. It
 #eturns ``None`` if parsing fails instead of raising an exception,
 #nd always returns a timezone-aware datetime object. If the string
 #oesn't have timezone information, it is assumed to be UTC.

 #param value: A string with a supported date format.

 #. versionchanged:: 2.0
 #eturn a timezone-aware datetime object. Use
 #`email.utils.parsedate_to_datetime``.
 #""
 #f value is None:
 #eturn None

 #ry:
 #t = email.utils.parsedate_to_datetime(value)
 #xcept (TypeError, ValueError):
 #eturn None

 #f dt.tzinfo is None:
 #eturn dt.replace(tzinfo=timezone.utc)

 #eturn dt


def cookie_date(
 #xpires: t.Optional[t.Union[datetime, date, int, float, struct_time]] = None
) -> str:
 #""Format a datetime object or timestamp into an :rfc:`2822` date
 #tring for ``Set-Cookie expires``.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Use :func:`http_date` instead.
 #""
 #arnings.warn(
 #'cookie_date' is deprecated and will be removed in Werkzeug"
 # 2.1. Use 'http_date' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn http_date(expires)


def http_date(
 #imestamp: t.Optional[t.Union[datetime, date, int, float, struct_time]] = None
) -> str:
 #""Format a datetime object or timestamp into an :rfc:`2822` date
 #tring.

 #his is a wrapper for :func:`email.utils.format_datetime`. It
 #ssumes naive datetime objects are in UTC instead of raising an
 #xception.

 #param timestamp: The datetime or timestamp to format. Defaults to
 #he current time.

 #. versionchanged:: 2.0
 #se ``email.utils.format_datetime``. Accept ``date`` objects.
 #""
 #f isinstance(timestamp, date):
 #f not isinstance(timestamp, datetime):
            # Assume plain date is midnight UTC.
 #imestamp = datetime.combine(timestamp, time(), tzinfo=timezone.utc)
 #lse:
            # Ensure datetime is timezone-aware.
 #imestamp = _dt_as_utc(timestamp)

 #eturn email.utils.format_datetime(timestamp, usegmt=True)

 #f isinstance(timestamp, struct_time):
 #imestamp = mktime(timestamp)

 #eturn email.utils.formatdate(timestamp, usegmt=True)


def parse_age(value: t.Optional[str] = None) -> t.Optional[timedelta]:
 #""Parses a base-10 integer count of seconds into a timedelta.

 #f parsing fails, the return value is `None`.

 #param value: a string consisting of an integer represented in base-10
 #return: a :class:`datetime.timedelta` object or `None`.
 #""
 #f not value:
 #eturn None
 #ry:
 #econds = int(value)
 #xcept ValueError:
 #eturn None
 #f seconds < 0:
 #eturn None
 #ry:
 #eturn timedelta(seconds=seconds)
 #xcept OverflowError:
 #eturn None


def dump_age(age: t.Optional[t.Union[timedelta, int]] = None) -> t.Optional[str]:
 #""Formats the duration as a base-10 integer.

 #param age: should be an integer number of seconds,
 # :class:`datetime.timedelta` object, or,
 #f the age is unknown, `None` (default).
 #""
 #f age is None:
 #eturn None
 #f isinstance(age, timedelta):
 #ge = int(age.total_seconds())
 #lse:
 #ge = int(age)

 #f age < 0:
 #aise ValueError("age cannot be negative")

 #eturn str(age)


def is_resource_modified(
 #nviron: "WSGIEnvironment",
 #tag: t.Optional[str] = None,
 #ata: t.Optional[bytes] = None,
 #ast_modified: t.Optional[t.Union[datetime, str]] = None,
 #gnore_if_range: bool = True,
) -> bool:
 #""Convenience method for conditional requests.

 #param environ: the WSGI environment of the request to be checked.
 #param etag: the etag for the response for comparison.
 #param data: or alternatively the data of the response to automatically
 #enerate an etag using :func:`generate_etag`.
 #param last_modified: an optional date of the last modification.
 #param ignore_if_range: If `False`, `If-Range` header will be taken into
 #ccount.
 #return: `True` if the resource was modified, otherwise `False`.

 #. versionchanged:: 2.0
 #HA-1 is used to generate an etag value for the data. MD5 may
 #ot be available in some environments.

 #. versionchanged:: 1.0.0
 #he check is run for methods other than ``GET`` and ``HEAD``.
 #""
 #f etag is None and data is not None:
 #tag = generate_etag(data)
 #lif data is not None:
 #aise TypeError("both data and etag given")

 #nmodified = False
 #f isinstance(last_modified, str):
 #ast_modified = parse_date(last_modified)

    # HTTP doesn't use microsecond, remove it to avoid false positive
    # comparisons. Mark naive datetimes as UTC.
 #f last_modified is not None:
 #ast_modified = _dt_as_utc(last_modified.replace(microsecond=0))

 #f_range = None
 #f not ignore_if_range and "HTTP_RANGE" in environ:
        # https://tools.ietf.org/html/rfc7233#section-3.2
        # A server MUST ignore an If-Range header field received in a request
        # that does not contain a Range header field.
 #f_range = parse_if_range_header(environ.get("HTTP_IF_RANGE"))

 #f if_range is not None and if_range.date is not None:
 #odified_since: t.Optional[datetime] = if_range.date
 #lse:
 #odified_since = parse_date(environ.get("HTTP_IF_MODIFIED_SINCE"))

 #f modified_since and last_modified and last_modified <= modified_since:
 #nmodified = True

 #f etag:
 #tag, _ = unquote_etag(etag)
 #tag = t.cast(str, etag)

 #f if_range is not None and if_range.etag is not None:
 #nmodified = parse_etags(if_range.etag).contains(etag)
 #lse:
 #f_none_match = parse_etags(environ.get("HTTP_IF_NONE_MATCH"))
 #f if_none_match:
                # https://tools.ietf.org/html/rfc7232#section-3.2
                # "A recipient MUST use the weak comparison function when comparing
                # entity-tags for If-None-Match"
 #nmodified = if_none_match.contains_weak(etag)

            # https://tools.ietf.org/html/rfc7232#section-3.1
            # "Origin server MUST use the strong comparison function when
            # comparing entity-tags for If-Match"
 #f_match = parse_etags(environ.get("HTTP_IF_MATCH"))
 #f if_match:
 #nmodified = not if_match.is_strong(etag)

 #eturn not unmodified


def remove_entity_headers(
 #eaders: t.Union["ds.Headers", t.List[t.Tuple[str, str]]],
 #llowed: t.Iterable[str] = ("expires", "content-location"),
) -> None:
 #""Remove all entity headers from a list or :class:`Headers` object.  This
 #peration works in-place.  `Expires` and `Content-Location` headers are
 #y default not removed.  The reason for this is :rfc:`2616` section
 #0.3.5 which specifies some entity headers that should be sent.

 #. versionchanged:: 0.5
 #dded `allowed` parameter.

 #param headers: a list or :class:`Headers` object.
 #param allowed: a list of headers that should still be allowed even though
 #hey are entity headers.
 #""
 #llowed = {x.lower() for x in allowed}
 #eaders[:] = [
 #key, value)
 #or key, value in headers
 #f not is_entity_header(key) or key.lower() in allowed
 #


def remove_hop_by_hop_headers(
 #eaders: t.Union["ds.Headers", t.List[t.Tuple[str, str]]]
) -> None:
 #""Remove all HTTP/1.1 "Hop-by-Hop" headers from a list or
 #class:`Headers` object.  This operation works in-place.

 #. versionadded:: 0.5

 #param headers: a list or :class:`Headers` object.
 #""
 #eaders[:] = [
 #key, value) for key, value in headers if not is_hop_by_hop_header(key)
 #


def is_entity_header(header: str) -> bool:
 #""Check if a header is an entity header.

 #. versionadded:: 0.5

 #param header: the header to test.
 #return: `True` if it's an entity header, `False` otherwise.
 #""
 #eturn header.lower() in _entity_headers


def is_hop_by_hop_header(header: str) -> bool:
 #""Check if a header is an HTTP/1.1 "Hop-by-Hop" header.

 #. versionadded:: 0.5

 #param header: the header to test.
 #return: `True` if it's an HTTP/1.1 "Hop-by-Hop" header, `False` otherwise.
 #""
 #eturn header.lower() in _hop_by_hop_headers


def parse_cookie(
 #eader: t.Union["WSGIEnvironment", str, bytes, None],
 #harset: str = "utf-8",
 #rrors: str = "replace",
 #ls: t.Optional[t.Type["ds.MultiDict"]] = None,
) -> "ds.MultiDict[str, str]":
 #""Parse a cookie from a string or WSGI environ.

 #he same key can be provided multiple times, the values are stored
 #n-order. The default :class:`MultiDict` will have the first value
 #irst, and all values can be retrieved with
 #meth:`MultiDict.getlist`.

 #param header: The cookie header as a string, or a WSGI environ dict
 #ith a ``HTTP_COOKIE`` key.
 #param charset: The charset for the cookie values.
 #param errors: The error behavior for the charset decoding.
 #param cls: A dict-like class to store the parsed cookies in.
 #efaults to :class:`MultiDict`.

 #. versionchanged:: 1.0.0
 #eturns a :class:`MultiDict` instead of a
 #`TypeConversionDict``.

 #. versionchanged:: 0.5
 #eturns a :class:`TypeConversionDict` instead of a regular dict.
 #he ``cls`` parameter was added.
 #""
 #f isinstance(header, dict):
 #eader = header.get("HTTP_COOKIE", "")
 #lif header is None:
 #eader = ""

    # PEP 3333 sends headers through the environ as latin1 decoded
    # strings. Encode strings back to bytes for parsing.
 #f isinstance(header, str):
 #eader = header.encode("latin1", "replace")

 #f cls is None:
 #ls = ds.MultiDict

 #ef _parse_pairs() -> t.Iterator[t.Tuple[str, str]]:
 #or key, val in _cookie_parse_impl(header):  # type: ignore
 #ey_str = _to_str(key, charset, errors, allow_none_charset=True)

 #f not key_str:
 #ontinue

 #al_str = _to_str(val, charset, errors, allow_none_charset=True)
 #ield key_str, val_str

 #eturn cls(_parse_pairs())


def dump_cookie(
 #ey: str,
 #alue: t.Union[bytes, str] = "",
 #ax_age: t.Optional[t.Union[timedelta, int]] = None,
 #xpires: t.Optional[t.Union[str, datetime, int, float]] = None,
 #ath: t.Optional[str] = "/",
 #omain: t.Optional[str] = None,
 #ecure: bool = False,
 #ttponly: bool = False,
 #harset: str = "utf-8",
 #ync_expires: bool = True,
 #ax_size: int = 4093,
 #amesite: t.Optional[str] = None,
) -> str:
 #""Create a Set-Cookie header without the ``Set-Cookie`` prefix.

 #he return value is usually restricted to ascii as the vast majority
 #f values are properly escaped, but that is no guarantee. It's
 #unneled through latin1 as required by :pep:`3333`.

 #he return value is not ASCII safe if the key contains unicode
 #haracters.  This is technically against the specification but
 #appens in the wild.  It's strongly recommended to not use
 #on-ASCII values for the keys.

 #param max_age: should be a number of seconds, or `None` (default) if
 #he cookie should last only as long as the client's
 #rowser session.  Additionally `timedelta` objects
 #re accepted, too.
 #param expires: should be a `datetime` object or unix timestamp.
 #param path: limits the cookie to a given path, per default it will
 #pan the whole domain.
 #param domain: Use this if you want to set a cross-domain cookie. For
 #xample, ``domain=".example.com"`` will set a cookie
 #hat is readable by the domain ``www.example.com``,
 #`foo.example.com`` etc. Otherwise, a cookie will only
 #e readable by the domain that set it.
 #param secure: The cookie will only be available via HTTPS
 #param httponly: disallow JavaScript to access the cookie.  This is an
 #xtension to the cookie standard and probably not
 #upported by all browsers.
 #param charset: the encoding for string values.
 #param sync_expires: automatically set expires if max_age is defined
 #ut expires not.
 #param max_size: Warn if the final header value exceeds this size. The
 #efault, 4093, should be safely `supported by most browsers
 #cookie_>`_. Set to 0 to disable this check.
 #param samesite: Limits the scope of the cookie such that it will
 #nly be attached to requests if those requests are same-site.

 #. _`cookie`: http://browsercookielimits.squawky.net/

 #. versionchanged:: 1.0.0
 #he string ``'None'`` is accepted for ``samesite``.
 #""
 #ey = _to_bytes(key, charset)
 #alue = _to_bytes(value, charset)

 #f path is not None:
 #rom .urls import iri_to_uri

 #ath = iri_to_uri(path, charset)

 #omain = _make_cookie_domain(domain)

 #f isinstance(max_age, timedelta):
 #ax_age = int(max_age.total_seconds())

 #f expires is not None:
 #f not isinstance(expires, str):
 #xpires = http_date(expires)
 #lif max_age is not None and sync_expires:
 #xpires = http_date(datetime.now(tz=timezone.utc).timestamp() + max_age)

 #f samesite is not None:
 #amesite = samesite.title()

 #f samesite not in {"Strict", "Lax", "None"}:
 #aise ValueError("SameSite must be 'Strict', 'Lax', or 'None'.")

 #uf = [key + b"=" + _cookie_quote(value)]

    # XXX: In theory all of these parameters that are not marked with `None`
    # should be quoted.  Because stdlib did not quote it before I did not
    # want to introduce quoting there now.
 #or k, v, q in (
 #b"Domain", domain, True),
 #b"Expires", expires, False),
 #b"Max-Age", max_age, False),
 #b"Secure", secure, None),
 #b"HttpOnly", httponly, None),
 #b"Path", path, False),
 #b"SameSite", samesite, False),
 #:
 #f q is None:
 #f v:
 #uf.append(k)
 #ontinue

 #f v is None:
 #ontinue

 #mp = bytearray(k)
 #f not isinstance(v, (bytes, bytearray)):
 # = _to_bytes(str(v), charset)
 #f q:
 # = _cookie_quote(v)
 #mp += b"=" + v
 #uf.append(bytes(tmp))

    # The return value will be an incorrectly encoded latin1 header for
    # consistency with the headers object.
 #v = b"; ".join(buf)
 #v = rv.decode("latin1")

    # Warn if the final value of the cookie is larger than the limit. If the
    # cookie is too large, then it may be silently ignored by the browser,
    # which can be quite hard to debug.
 #ookie_size = len(rv)

 #f max_size and cookie_size > max_size:
 #alue_size = len(value)
 #arnings.warn(
 #"The {key.decode(charset)!r} cookie is too large: the value was"
 #" {value_size} bytes but the"
 #" header required {cookie_size - value_size} extra bytes. The final size"
 #" was {cookie_size} bytes but the limit is {max_size} bytes. Browsers may"
 #" silently ignore cookies larger than this.",
 #tacklevel=2,
 #

 #eturn rv


def is_byte_range_valid(
 #tart: t.Optional[int], stop: t.Optional[int], length: t.Optional[int]
) -> bool:
 #""Checks if a given byte content range is valid for the given length.

 #. versionadded:: 0.7
 #""
 #f (start is None) != (stop is None):
 #eturn False
 #lif start is None:
 #eturn length is None or length >= 0
 #lif length is None:
 #eturn 0 <= start < stop  # type: ignore
 #lif start >= stop:  # type: ignore
 #eturn False
 #eturn 0 <= start < length


# circular dependencies
from . import datastructures as ds
