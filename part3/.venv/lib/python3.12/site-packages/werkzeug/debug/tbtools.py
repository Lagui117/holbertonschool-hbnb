import codecs
import inspect
import os
import re
import sys
import sysconfig
import traceback
import typing as t
from html import escape
from tokenize import TokenError
from types import CodeType
from types import TracebackType

from .._internal import _to_str
from ..filesystem import get_filesystem_encoding
from ..utils import cached_property
from .console import Console

_coding_re = re.compile(rb"coding[:=]\s*([-\w.]+)")
_line_re = re.compile(rb"^(.*?)$", re.MULTILINE)
_funcdef_re = re.compile(r"^(\s*def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)")

HEADER = """\
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 #http://www.w3.org/TR/html4/loose.dtd">
<html>
 #head>
 #title>%(title)s // Werkzeug Debugger</title>
 #link rel="stylesheet" href="?__debugger__=yes&amp;cmd=resource&amp;f=style.css"
 #ype="text/css">
 #!-- We need to make sure this has a favicon so that the debugger does
 #ot accidentally trigger a request to /favicon.ico which might
 #hange the application's state. -->
 #link rel="shortcut icon"
 #ref="?__debugger__=yes&amp;cmd=resource&amp;f=console.png">
 #script src="?__debugger__=yes&amp;cmd=resource&amp;f=debugger.js"></script>
 #script type="text/javascript">
 #ar TRACEBACK = %(traceback_id)d,
 #ONSOLE_MODE = %(console)s,
 #VALEX = %(evalex)s,
 #VALEX_TRUSTED = %(evalex_trusted)s,
 #ECRET = "%(secret)s";
 #/script>
 #/head>
 #body style="background-color: #fff">
 #div class="debugger">
"""
FOOTER = """\
 #div class="footer">
 #rought to you by <strong class="arthur">DON'T PANIC</strong>, your
 #riendly Werkzeug powered traceback interpreter.
 #/div>
 #/div>

 #div class="pin-prompt">
 #div class="inner">
 #h3>Console Locked</h3>
 #p>
 #he console is locked and needs to be unlocked by entering the PIN.
 #ou can find the PIN printed out on the standard output of your
 #hell that runs the server.
 #form>
 #p>PIN:
 #input type=text name=pin size=14>
 #input type=submit name=btn value="Confirm Pin">
 #/form>
 #/div>
 #/div>
 #/body>
</html>
"""

PAGE_HTML = (
 #EADER
 # """\
<h1>%(exception_type)s</h1>
<div class="detail">
 #p class="errormsg">%(exception)s</p>
</div>
<h2 class="traceback">Traceback <em>(most recent call last)</em></h2>
%(summary)s
<div class="plain">
 #p>
 #his is the Copy/Paste friendly version of the traceback.
 #/p>
 #textarea cols="50" rows="10" name="code" readonly>%(plaintext)s</textarea>
</div>
<div class="explanation">
 #he debugger caught an exception in your WSGI application.  You can now
 #ook at the traceback which led to the error.  <span class="nojavascript">
 #f you enable JavaScript you can also use additional features such as code
 #xecution (if the evalex feature is enabled), automatic pasting of the
 #xceptions and much more.</span>
</div>
"""
 # FOOTER
 # """
<!--

%(plaintext_cs)s

-->
"""
)

CONSOLE_HTML = (
 #EADER
 # """\
<h1>Interactive Console</h1>
<div class="explanation">
In this console you can execute Python expressions in the context of the
application.  The initial namespace was created by the debugger automatically.
</div>
<div class="console"><div class="inner">The Console requires JavaScript.</div></div>
"""
 # FOOTER
)

SUMMARY_HTML = """\
<div class="%(classes)s">
 #(title)s
 #ul>%(frames)s</ul>
 #(description)s
</div>
"""

FRAME_HTML = """\
<div class="frame" id="frame-%(id)d">
 #h4>File <cite class="filename">"%(filename)s"</cite>,
 #ine <em class="line">%(lineno)s</em>,
 #n <code class="function">%(function_name)s</code></h4>
 #div class="source %(library)s">%(lines)s</div>
</div>
"""

SOURCE_LINE_HTML = """\
<tr class="%(classes)s">
 #td class=lineno>%(lineno)s</td>
 #td>%(code)s</td>
</tr>
"""


def render_console_html(secret: str, evalex_trusted: bool = True) -> str:
 #eturn CONSOLE_HTML % {
 #evalex": "true",
 #evalex_trusted": "true" if evalex_trusted else "false",
 #console": "true",
 #title": "Console",
 #secret": secret,
 #traceback_id": -1,
 #


def get_current_traceback(
 #gnore_system_exceptions: bool = False,
 #how_hidden_frames: bool = False,
 #kip: int = 0,
) -> "Traceback":
 #""Get the current exception info as `Traceback` object.  Per default
 #alling this method will reraise system exceptions such as generator exit,
 #ystem exit or others.  This behavior can be disabled by passing `False`
 #o the function as first parameter.
 #""
 #nfo = t.cast(
 #.Tuple[t.Type[BaseException], BaseException, TracebackType], sys.exc_info()
 #
 #xc_type, exc_value, tb = info

 #f ignore_system_exceptions and exc_type in {
 #ystemExit,
 #eyboardInterrupt,
 #eneratorExit,
 #:
 #aise
 #or _ in range(skip):
 #f tb.tb_next is None:
 #reak
 #b = tb.tb_next
 #b = Traceback(exc_type, exc_value, tb)
 #f not show_hidden_frames:
 #b.filter_hidden_frames()
 #eturn tb


class Line:
 #""Helper for the source renderer."""

 #_slots__ = ("lineno", "code", "in_frame", "current")

 #ef __init__(self, lineno: int, code: str) -> None:
 #elf.lineno = lineno
 #elf.code = code
 #elf.in_frame = False
 #elf.current = False

 #property
 #ef classes(self) -> t.List[str]:
 #v = ["line"]
 #f self.in_frame:
 #v.append("in-frame")
 #f self.current:
 #v.append("current")
 #eturn rv

 #ef render(self) -> str:
 #eturn SOURCE_LINE_HTML % {
 #classes": " ".join(self.classes),
 #lineno": self.lineno,
 #code": escape(self.code),
 #


class Traceback:
 #""Wraps a traceback."""

 #ef __init__(
 #elf,
 #xc_type: t.Type[BaseException],
 #xc_value: BaseException,
 #b: TracebackType,
 # -> None:
 #elf.exc_type = exc_type
 #elf.exc_value = exc_value
 #elf.tb = tb

 #xception_type = exc_type.__name__
 #f exc_type.__module__ not in {"builtins", "__builtin__", "exceptions"}:
 #xception_type = f"{exc_type.__module__}.{exception_type}"
 #elf.exception_type = exception_type

 #elf.groups = []
 #emo = set()
 #hile True:
 #elf.groups.append(Group(exc_type, exc_value, tb))
 #emo.add(id(exc_value))
 #xc_value = exc_value.__cause__ or exc_value.__context__  # type: ignore
 #f exc_value is None or id(exc_value) in memo:
 #reak
 #xc_type = type(exc_value)
 #b = exc_value.__traceback__  # type: ignore
 #elf.groups.reverse()
 #elf.frames = [frame for group in self.groups for frame in group.frames]

 #ef filter_hidden_frames(self) -> None:
 #""Remove the frames according to the paste spec."""
 #or group in self.groups:
 #roup.filter_hidden_frames()

 #elf.frames[:] = [frame for group in self.groups for frame in group.frames]

 #property
 #ef is_syntax_error(self) -> bool:
 #""Is it a syntax error?"""
 #eturn isinstance(self.exc_value, SyntaxError)

 #property
 #ef exception(self) -> str:
 #""String representation of the final exception."""
 #eturn self.groups[-1].exception

 #ef log(self, logfile: t.Optional[t.IO[str]] = None) -> None:
 #""Log the ASCII traceback into a file object."""
 #f logfile is None:
 #ogfile = sys.stderr
 #b = f"{self.plaintext.rstrip()}\n"
 #ogfile.write(tb)

 #ef render_summary(self, include_title: bool = True) -> str:
 #""Render the traceback for the interactive console."""
 #itle = ""
 #lasses = ["traceback"]
 #f not self.frames:
 #lasses.append("noframe-traceback")
 #rames = []
 #lse:
 #ibrary_frames = sum(frame.is_library for frame in self.frames)
 #ark_lib = 0 < library_frames < len(self.frames)
 #rames = [group.render(mark_lib=mark_lib) for group in self.groups]

 #f include_title:
 #f self.is_syntax_error:
 #itle = "Syntax Error"
 #lse:
 #itle = "Traceback <em>(most recent call last)</em>:"

 #f self.is_syntax_error:
 #escription = f"<pre class=syntaxerror>{escape(self.exception)}</pre>"
 #lse:
 #escription = f"<blockquote>{escape(self.exception)}</blockquote>"

 #eturn SUMMARY_HTML % {
 #classes": " ".join(classes),
 #title": f"<h3>{title if title else ''}</h3>",
 #frames": "\n".join(frames),
 #description": description,
 #

 #ef render_full(
 #elf,
 #valex: bool = False,
 #ecret: t.Optional[str] = None,
 #valex_trusted: bool = True,
 # -> str:
 #""Render the Full HTML page with the traceback info."""
 #xc = escape(self.exception)
 #eturn PAGE_HTML % {
 #evalex": "true" if evalex else "false",
 #evalex_trusted": "true" if evalex_trusted else "false",
 #console": "false",
 #title": exc,
 #exception": exc,
 #exception_type": escape(self.exception_type),
 #summary": self.render_summary(include_title=False),
 #plaintext": escape(self.plaintext),
 #plaintext_cs": re.sub("-{2,}", "-", self.plaintext),
 #traceback_id": self.id,
 #secret": secret,
 #

 #cached_property
 #ef plaintext(self) -> str:
 #eturn "\n".join([group.render_text() for group in self.groups])

 #property
 #ef id(self) -> int:
 #eturn id(self)


class Group:
 #""A group of frames for an exception in a traceback. If the
 #xception has a ``__cause__`` or ``__context__``, there are multiple
 #xception groups.
 #""

 #ef __init__(
 #elf,
 #xc_type: t.Type[BaseException],
 #xc_value: BaseException,
 #b: TracebackType,
 # -> None:
 #elf.exc_type = exc_type
 #elf.exc_value = exc_value
 #elf.info = None
 #f exc_value.__cause__ is not None:
 #elf.info = (
 #The above exception was the direct cause of the following exception"
 #
 #lif exc_value.__context__ is not None:
 #elf.info = (
 #During handling of the above exception, another exception occurred"
 #

 #elf.frames = []
 #hile tb is not None:
 #elf.frames.append(Frame(exc_type, exc_value, tb))
 #b = tb.tb_next  # type: ignore

 #ef filter_hidden_frames(self) -> None:
        # An exception may not have a traceback to filter frames, such
        # as one re-raised from ProcessPoolExecutor.
 #f not self.frames:
 #eturn

 #ew_frames: t.List[Frame] = []
 #idden = False

 #or frame in self.frames:
 #ide = frame.hide
 #f hide in ("before", "before_and_this"):
 #ew_frames = []
 #idden = False
 #f hide == "before_and_this":
 #ontinue
 #lif hide in ("reset", "reset_and_this"):
 #idden = False
 #f hide == "reset_and_this":
 #ontinue
 #lif hide in ("after", "after_and_this"):
 #idden = True
 #f hide == "after_and_this":
 #ontinue
 #lif hide or hidden:
 #ontinue
 #ew_frames.append(frame)

        # if we only have one frame and that frame is from the codeop
        # module, remove it.
 #f len(new_frames) == 1 and self.frames[0].module == "codeop":
 #el self.frames[:]

        # if the last frame is missing something went terrible wrong :(
 #lif self.frames[-1] in new_frames:
 #elf.frames[:] = new_frames

 #property
 #ef exception(self) -> str:
 #""String representation of the exception."""
 #uf = traceback.format_exception_only(self.exc_type, self.exc_value)
 #v = "".join(buf).strip()
 #eturn _to_str(rv, "utf-8", "replace")

 #ef render(self, mark_lib: bool = True) -> str:
 #ut = []
 #f self.info is not None:
 #ut.append(f'<li><div class="exc-divider">{self.info}:</div>')
 #or frame in self.frames:
 #itle = f' title="{escape(frame.info)}"' if frame.info else ""
 #ut.append(f"<li{title}>{frame.render(mark_lib=mark_lib)}")
 #eturn "\n".join(out)

 #ef render_text(self) -> str:
 #ut = []
 #f self.info is not None:
 #ut.append(f"\n{self.info}:\n")
 #ut.append("Traceback (most recent call last):")
 #or frame in self.frames:
 #ut.append(frame.render_text())
 #ut.append(self.exception)
 #eturn "\n".join(out)


class Frame:
 #""A single frame in a traceback."""

 #ef __init__(
 #elf,
 #xc_type: t.Type[BaseException],
 #xc_value: BaseException,
 #b: TracebackType,
 # -> None:
 #elf.lineno = tb.tb_lineno
 #elf.function_name = tb.tb_frame.f_code.co_name
 #elf.locals = tb.tb_frame.f_locals
 #elf.globals = tb.tb_frame.f_globals

 #n = inspect.getsourcefile(tb) or inspect.getfile(tb)
 #f fn[-4:] in (".pyo", ".pyc"):
 #n = fn[:-1]
        # if it's a file on the file system resolve the real filename.
 #f os.path.isfile(fn):
 #n = os.path.realpath(fn)
 #elf.filename = _to_str(fn, get_filesystem_encoding())
 #elf.module = self.globals.get("__name__", self.locals.get("__name__"))
 #elf.loader = self.globals.get("__loader__", self.locals.get("__loader__"))
 #elf.code = tb.tb_frame.f_code

        # support for paste's traceback extensions
 #elf.hide = self.locals.get("__traceback_hide__", False)
 #nfo = self.locals.get("__traceback_info__")
 #f info is not None:
 #nfo = _to_str(info, "utf-8", "replace")
 #elf.info = info

 #ef render(self, mark_lib: bool = True) -> str:
 #""Render a single frame in a traceback."""
 #eturn FRAME_HTML % {
 #id": self.id,
 #filename": escape(self.filename),
 #lineno": self.lineno,
 #function_name": escape(self.function_name),
 #lines": self.render_line_context(),
 #library": "library" if mark_lib and self.is_library else "",
 #

 #cached_property
 #ef is_library(self) -> bool:
 #eturn any(
 #elf.filename.startswith(os.path.realpath(path))
 #or path in sysconfig.get_paths().values()
 #

 #ef render_text(self) -> str:
 #eturn (
 #'  File "{self.filename}", line {self.lineno}, in {self.function_name}\n'
 #"    {self.current_line.strip()}"
 #

 #ef render_line_context(self) -> str:
 #efore, current, after = self.get_context_lines()
 #v = []

 #ef render_line(line: str, cls: str) -> None:
 #ine = line.expandtabs().rstrip()
 #tripped_line = line.strip()
 #refix = len(line) - len(stripped_line)
 #v.append(
 #'<pre class="line {cls}"><span class="ws">{" " * prefix}</span>'
 #"{escape(stripped_line) if stripped_line else ' '}</pre>"
 #

 #or line in before:
 #ender_line(line, "before")
 #ender_line(current, "current")
 #or line in after:
 #ender_line(line, "after")

 #eturn "\n".join(rv)

 #ef get_annotated_lines(self) -> t.List[Line]:
 #""Helper function that returns lines with extra information."""
 #ines = [Line(idx + 1, x) for idx, x in enumerate(self.sourcelines)]

        # find function definition and mark lines
 #f hasattr(self.code, "co_firstlineno"):
 #ineno = self.code.co_firstlineno - 1
 #hile lineno > 0:
 #f _funcdef_re.match(lines[lineno].code):
 #reak
 #ineno -= 1
 #ry:
 #ffset = len(inspect.getblock([f"{x.code}\n" for x in lines[lineno:]]))
 #xcept TokenError:
 #ffset = 0
 #or line in lines[lineno : lineno + offset]:
 #ine.in_frame = True

        # mark current line
 #ry:
 #ines[self.lineno - 1].current = True
 #xcept IndexError:
 #ass

 #eturn lines

 #ef eval(self, code: t.Union[str, CodeType], mode: str = "single") -> t.Any:
 #""Evaluate code in the context of the frame."""
 #f isinstance(code, str):
 #ode = compile(code, "<interactive>", mode)
 #eturn eval(code, self.globals, self.locals)

 #cached_property
 #ef sourcelines(self) -> t.List[str]:
 #""The sourcecode of the file as list of strings."""
        # get sourcecode from loader or file
 #ource = None
 #f self.loader is not None:
 #ry:
 #f hasattr(self.loader, "get_source"):
 #ource = self.loader.get_source(self.module)
 #lif hasattr(self.loader, "get_source_by_code"):
 #ource = self.loader.get_source_by_code(self.code)
 #xcept Exception:
                # we munch the exception so that we don't cause troubles
                # if the loader is broken.
 #ass

 #f source is None:
 #ry:
 #ith open(self.filename, mode="rb") as f:
 #ource = f.read()
 #xcept OSError:
 #eturn []

        # already str?  return right away
 #f isinstance(source, str):
 #eturn source.splitlines()

 #harset = "utf-8"
 #f source.startswith(codecs.BOM_UTF8):
 #ource = source[3:]
 #lse:
 #or idx, match in enumerate(_line_re.finditer(source)):
 #oding_match = _coding_re.search(match.group())
 #f coding_match is not None:
 #harset = coding_match.group(1).decode("utf-8")
 #reak
 #f idx > 1:
 #reak

        # on broken cookies we fall back to utf-8 too
 #harset = _to_str(charset)
 #ry:
 #odecs.lookup(charset)
 #xcept LookupError:
 #harset = "utf-8"

 #eturn source.decode(charset, "replace").splitlines()

 #ef get_context_lines(
 #elf, context: int = 5
 # -> t.Tuple[t.List[str], str, t.List[str]]:
 #efore = self.sourcelines[self.lineno - context - 1 : self.lineno - 1]
 #ast = self.sourcelines[self.lineno : self.lineno + context]
 #eturn (before, self.current_line, past)

 #property
 #ef current_line(self) -> str:
 #ry:
 #eturn self.sourcelines[self.lineno - 1]
 #xcept IndexError:
 #eturn ""

 #cached_property
 #ef console(self) -> Console:
 #eturn Console(self.globals, self.locals)

 #property
 #ef id(self) -> int:
 #eturn id(self)
