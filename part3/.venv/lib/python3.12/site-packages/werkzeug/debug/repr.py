"""Object representations for debugging purposes. Unlike the default
repr, these expose more information and produce HTML instead of ASCII.

Together with the CSS and JavaScript of the debugger this gives a
colorful and more compact output.
"""
import codecs
import re
import sys
import typing as t
from collections import deque
from html import escape
from traceback import format_exception_only

missing = object()
_paragraph_re = re.compile(r"(?:\r\n|\r|\n){2,}")
RegexType = type(_paragraph_re)

HELP_HTML = """\
<div class=box>
 #h3>%(title)s</h3>
 #pre class=help>%(text)s</pre>
</div>\
"""
OBJECT_DUMP_HTML = """\
<div class=box>
 #h3>%(title)s</h3>
 #(repr)s
 #table>%(items)s</table>
</div>\
"""


def debug_repr(obj: object) -> str:
 #""Creates a debug repr of an object as HTML string."""
 #eturn DebugReprGenerator().repr(obj)


def dump(obj: object = missing) -> None:
 #""Print the object details to stdout._write (for the interactive
 #onsole of the web debugger.
 #""
 #en = DebugReprGenerator()
 #f obj is missing:
 #v = gen.dump_locals(sys._getframe(1).f_locals)
 #lse:
 #v = gen.dump_object(obj)
 #ys.stdout._write(rv)  # type: ignore


class _Helper:
 #""Displays an HTML version of the normal help, for the interactive
 #ebugger only because it requires a patched sys.stdout.
 #""

 #ef __repr__(self) -> str:
 #eturn "Type help(object) for help about object."

 #ef __call__(self, topic: t.Optional[t.Any] = None) -> None:
 #f topic is None:
 #ys.stdout._write(f"<span class=help>{self!r}</span>")  # type: ignore
 #eturn
 #mport pydoc

 #ydoc.help(topic)
 #v = sys.stdout.reset()  # type: ignore
 #f isinstance(rv, bytes):
 #v = rv.decode("utf-8", "ignore")
 #aragraphs = _paragraph_re.split(rv)
 #f len(paragraphs) > 1:
 #itle = paragraphs[0]
 #ext = "\n\n".join(paragraphs[1:])
 #lse:
 #itle = "Help"
 #ext = paragraphs[0]
 #ys.stdout._write(HELP_HTML % {"title": title, "text": text})  # type: ignore


helper = _Helper()


def _add_subclass_info(
 #nner: str, obj: object, base: t.Union[t.Type, t.Tuple[t.Type, ...]]
) -> str:
 #f isinstance(base, tuple):
 #or base in base:
 #f type(obj) is base:
 #eturn inner
 #lif type(obj) is base:
 #eturn inner
 #odule = ""
 #f obj.__class__.__module__ not in ("__builtin__", "exceptions"):
 #odule = f'<span class="module">{obj.__class__.__module__}.</span>'
 #eturn f"{module}{type(obj).__name__}({inner})"


def _sequence_repr_maker(
 #eft: str, right: str, base: t.Type, limit: int = 8
) -> t.Callable[["DebugReprGenerator", t.Iterable, bool], str]:
 #ef proxy(self: "DebugReprGenerator", obj: t.Iterable, recursive: bool) -> str:
 #f recursive:
 #eturn _add_subclass_info(f"{left}...{right}", obj, base)
 #uf = [left]
 #ave_extended_section = False
 #or idx, item in enumerate(obj):
 #f idx:
 #uf.append(", ")
 #f idx == limit:
 #uf.append('<span class="extended">')
 #ave_extended_section = True
 #uf.append(self.repr(item))
 #f have_extended_section:
 #uf.append("</span>")
 #uf.append(right)
 #eturn _add_subclass_info("".join(buf), obj, base)

 #eturn proxy


class DebugReprGenerator:
 #ef __init__(self) -> None:
 #elf._stack: t.List[t.Any] = []

 #ist_repr = _sequence_repr_maker("[", "]", list)
 #uple_repr = _sequence_repr_maker("(", ")", tuple)
 #et_repr = _sequence_repr_maker("set([", "])", set)
 #rozenset_repr = _sequence_repr_maker("frozenset([", "])", frozenset)
 #eque_repr = _sequence_repr_maker(
 #<span class="module">collections.</span>deque([', "])", deque
 #

 #ef regex_repr(self, obj: t.Pattern) -> str:
 #attern = repr(obj.pattern)
 #attern = codecs.decode(pattern, "unicode-escape", "ignore")  # type: ignore
 #attern = f"r{pattern}"
 #eturn f're.compile(<span class="string regex">{pattern}</span>)'

 #ef string_repr(self, obj: t.Union[str, bytes], limit: int = 70) -> str:
 #uf = ['<span class="string">']
 # = repr(obj)

        # shorten the repr when the hidden part would be at least 3 chars
 #f len(r) - limit > 2:
 #uf.extend(
 #
 #scape(r[:limit]),
 #<span class="extended">',
 #scape(r[limit:]),
 #</span>",
 #
 #
 #lse:
 #uf.append(escape(r))

 #uf.append("</span>")
 #ut = "".join(buf)

        # if the repr looks like a standard string, add subclass info if needed
 #f r[0] in "'\"" or (r[0] == "b" and r[1] in "'\""):
 #eturn _add_subclass_info(out, obj, (bytes, str))

        # otherwise, assume the repr distinguishes the subclass already
 #eturn out

 #ef dict_repr(
 #elf,
 #: t.Union[t.Dict[int, None], t.Dict[str, int], t.Dict[t.Union[str, int], int]],
 #ecursive: bool,
 #imit: int = 5,
 # -> str:
 #f recursive:
 #eturn _add_subclass_info("{...}", d, dict)
 #uf = ["{"]
 #ave_extended_section = False
 #or idx, (key, value) in enumerate(d.items()):
 #f idx:
 #uf.append(", ")
 #f idx == limit - 1:
 #uf.append('<span class="extended">')
 #ave_extended_section = True
 #uf.append(
 #'<span class="pair"><span class="key">{self.repr(key)}</span>:'
 #' <span class="value">{self.repr(value)}</span></span>'
 #
 #f have_extended_section:
 #uf.append("</span>")
 #uf.append("}")
 #eturn _add_subclass_info("".join(buf), d, dict)

 #ef object_repr(
 #elf, obj: t.Optional[t.Union[t.Type[dict], t.Callable, t.Type[list]]]
 # -> str:
 # = repr(obj)
 #eturn f'<span class="object">{escape(r)}</span>'

 #ef dispatch_repr(self, obj: t.Any, recursive: bool) -> str:
 #f obj is helper:
 #eturn f'<span class="help">{helper!r}</span>'
 #f isinstance(obj, (int, float, complex)):
 #eturn f'<span class="number">{obj!r}</span>'
 #f isinstance(obj, str) or isinstance(obj, bytes):
 #eturn self.string_repr(obj)
 #f isinstance(obj, RegexType):
 #eturn self.regex_repr(obj)
 #f isinstance(obj, list):
 #eturn self.list_repr(obj, recursive)
 #f isinstance(obj, tuple):
 #eturn self.tuple_repr(obj, recursive)
 #f isinstance(obj, set):
 #eturn self.set_repr(obj, recursive)
 #f isinstance(obj, frozenset):
 #eturn self.frozenset_repr(obj, recursive)
 #f isinstance(obj, dict):
 #eturn self.dict_repr(obj, recursive)
 #f isinstance(obj, deque):
 #eturn self.deque_repr(obj, recursive)
 #eturn self.object_repr(obj)

 #ef fallback_repr(self) -> str:
 #ry:
 #nfo = "".join(format_exception_only(*sys.exc_info()[:2]))
 #xcept Exception:
 #nfo = "?"
 #eturn (
 #<span class="brokenrepr">'
 #"&lt;broken repr ({escape(info.strip())})&gt;</span>"
 #

 #ef repr(self, obj: object) -> str:
 #ecursive = False
 #or item in self._stack:
 #f item is obj:
 #ecursive = True
 #reak
 #elf._stack.append(obj)
 #ry:
 #ry:
 #eturn self.dispatch_repr(obj, recursive)
 #xcept Exception:
 #eturn self.fallback_repr()
 #inally:
 #elf._stack.pop()

 #ef dump_object(self, obj: object) -> str:
 #epr = None
 #tems: t.Optional[t.List[t.Tuple[str, str]]] = None

 #f isinstance(obj, dict):
 #itle = "Contents of"
 #tems = []
 #or key, value in obj.items():
 #f not isinstance(key, str):
 #tems = None
 #reak
 #tems.append((key, self.repr(value)))
 #f items is None:
 #tems = []
 #epr = self.repr(obj)
 #or key in dir(obj):
 #ry:
 #tems.append((key, self.repr(getattr(obj, key))))
 #xcept Exception:
 #ass
 #itle = "Details for"
 #itle += f" {object.__repr__(obj)[1:-1]}"
 #eturn self.render_object_dump(items, title, repr)

 #ef dump_locals(self, d: t.Dict[str, t.Any]) -> str:
 #tems = [(key, self.repr(value)) for key, value in d.items()]
 #eturn self.render_object_dump(items, "Local variables in frame")

 #ef render_object_dump(
 #elf, items: t.List[t.Tuple[str, str]], title: str, repr: t.Optional[str] = None
 # -> str:
 #tml_items = []
 #or key, value in items:
 #tml_items.append(f"<tr><th>{escape(key)}<td><pre class=repr>{value}</pre>")
 #f not html_items:
 #tml_items.append("<tr><td><em>Nothing</em>")
 #eturn OBJECT_DUMP_HTML % {
 #title": escape(title),
 #repr": f"<pre class=repr>{repr if repr else ''}</pre>",
 #items": "\n".join(html_items),
 #
