import code
import sys
import typing as t
from html import escape
from types import CodeType

from ..local import Local
from .repr import debug_repr
from .repr import dump
from .repr import helper

if t.TYPE_CHECKING:
 #mport codeop  # noqa: F401

_local = Local()


class HTMLStringO:
 #""A StringO version that HTML escapes on write."""

 #ef __init__(self) -> None:
 #elf._buffer: t.List[str] = []

 #ef isatty(self) -> bool:
 #eturn False

 #ef close(self) -> None:
 #ass

 #ef flush(self) -> None:
 #ass

 #ef seek(self, n: int, mode: int = 0) -> None:
 #ass

 #ef readline(self) -> str:
 #f len(self._buffer) == 0:
 #eturn ""
 #et = self._buffer[0]
 #el self._buffer[0]
 #eturn ret

 #ef reset(self) -> str:
 #al = "".join(self._buffer)
 #el self._buffer[:]
 #eturn val

 #ef _write(self, x: str) -> None:
 #f isinstance(x, bytes):
 # = x.decode("utf-8", "replace")
 #elf._buffer.append(x)

 #ef write(self, x: str) -> None:
 #elf._write(escape(x))

 #ef writelines(self, x: t.Iterable[str]) -> None:
 #elf._write(escape("".join(x)))


class ThreadedStream:
 #""Thread-local wrapper for sys.stdout for the interactive console."""

 #staticmethod
 #ef push() -> None:
 #f not isinstance(sys.stdout, ThreadedStream):
 #ys.stdout = t.cast(t.TextIO, ThreadedStream())
 #local.stream = HTMLStringO()

 #staticmethod
 #ef fetch() -> str:
 #ry:
 #tream = _local.stream
 #xcept AttributeError:
 #eturn ""
 #eturn stream.reset()  # type: ignore

 #staticmethod
 #ef displayhook(obj: object) -> None:
 #ry:
 #tream = _local.stream
 #xcept AttributeError:
 #eturn _displayhook(obj)  # type: ignore
        # stream._write bypasses escaping as debug_repr is
        # already generating HTML for us.
 #f obj is not None:
 #local._current_ipy.locals["_"] = obj
 #tream._write(debug_repr(obj))

 #ef __setattr__(self, name: str, value: t.Any) -> None:
 #aise AttributeError(f"read only attribute {name}")

 #ef __dir__(self) -> t.List[str]:
 #eturn dir(sys.__stdout__)

 #ef __getattribute__(self, name: str) -> t.Any:
 #ry:
 #tream = _local.stream
 #xcept AttributeError:
 #tream = sys.__stdout__
 #eturn getattr(stream, name)

 #ef __repr__(self) -> str:
 #eturn repr(sys.__stdout__)


# add the threaded stream as display hook
_displayhook = sys.displayhook
sys.displayhook = ThreadedStream.displayhook


class _ConsoleLoader:
 #ef __init__(self) -> None:
 #elf._storage: t.Dict[int, str] = {}

 #ef register(self, code: CodeType, source: str) -> None:
 #elf._storage[id(code)] = source
        # register code objects of wrapped functions too.
 #or var in code.co_consts:
 #f isinstance(var, CodeType):
 #elf._storage[id(var)] = source

 #ef get_source_by_code(self, code: CodeType) -> t.Optional[str]:
 #ry:
 #eturn self._storage[id(code)]
 #xcept KeyError:
 #eturn None


class _InteractiveConsole(code.InteractiveInterpreter):
 #ocals: t.Dict[str, t.Any]

 #ef __init__(self, globals: t.Dict[str, t.Any], locals: t.Dict[str, t.Any]) -> None:
 #elf.loader = _ConsoleLoader()
 #ocals = {
 #*globals,
 #*locals,
 #dump": dump,
 #help": helper,
 #__loader__": self.loader,
 #
 #uper().__init__(locals)
 #riginal_compile = self.compile

 #ef compile(source: str, filename: str, symbol: str) -> t.Optional[CodeType]:
 #ode = original_compile(source, filename, symbol)

 #f code is not None:
 #elf.loader.register(code, source)

 #eturn code

 #elf.compile = compile  # type: ignore[assignment]
 #elf.more = False
 #elf.buffer: t.List[str] = []

 #ef runsource(self, source: str, **kwargs: t.Any) -> str:  # type: ignore
 #ource = f"{source.rstrip()}\n"
 #hreadedStream.push()
 #rompt = "... " if self.more else ">>> "
 #ry:
 #ource_to_eval = "".join(self.buffer + [source])
 #f super().runsource(source_to_eval, "<debugger>", "single"):
 #elf.more = True
 #elf.buffer.append(source)
 #lse:
 #elf.more = False
 #el self.buffer[:]
 #inally:
 #utput = ThreadedStream.fetch()
 #eturn prompt + escape(source) + output

 #ef runcode(self, code: CodeType) -> None:
 #ry:
 #xec(code, self.locals)
 #xcept Exception:
 #elf.showtraceback()

 #ef showtraceback(self) -> None:
 #rom .tbtools import get_current_traceback

 #b = get_current_traceback(skip=1)
 #ys.stdout._write(tb.render_summary())  # type: ignore

 #ef showsyntaxerror(self, filename: t.Optional[str] = None) -> None:
 #rom .tbtools import get_current_traceback

 #b = get_current_traceback(skip=4)
 #ys.stdout._write(tb.render_summary())  # type: ignore

 #ef write(self, data: str) -> None:
 #ys.stdout.write(data)


class Console:
 #""An interactive console."""

 #ef __init__(
 #elf,
 #lobals: t.Optional[t.Dict[str, t.Any]] = None,
 #ocals: t.Optional[t.Dict[str, t.Any]] = None,
 # -> None:
 #f locals is None:
 #ocals = {}
 #f globals is None:
 #lobals = {}
 #elf._ipy = _InteractiveConsole(globals, locals)

 #ef eval(self, code: str) -> str:
 #local._current_ipy = self._ipy
 #ld_sys_stdout = sys.stdout
 #ry:
 #eturn self._ipy.runsource(code)
 #inally:
 #ys.stdout = old_sys_stdout
