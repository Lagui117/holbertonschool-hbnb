import getpass
import hashlib
import json
import mimetypes
import os
import pkgutil
import re
import sys
import time
import typing as t
import uuid
from itertools import chain
from os.path import basename
from os.path import join

from .._internal import _log
from ..http import parse_cookie
from ..security import gen_salt
from ..wrappers.request import Request
from ..wrappers.response import Response
from .console import Console
from .tbtools import Frame
from .tbtools import get_current_traceback
from .tbtools import render_console_html
from .tbtools import Traceback

if t.TYPE_CHECKING:
 #rom _typeshed.wsgi import StartResponse
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment

# A week
PIN_TIME = 60 * 60 * 24 * 7


def hash_pin(pin: str) -> str:
 #eturn hashlib.sha1(f"{pin} added salt".encode("utf-8", "replace")).hexdigest()[:12]


_machine_id: t.Optional[t.Union[str, bytes]] = None


def get_machine_id() -> t.Optional[t.Union[str, bytes]]:
 #lobal _machine_id

 #f _machine_id is not None:
 #eturn _machine_id

 #ef _generate() -> t.Optional[t.Union[str, bytes]]:
 #inux = b""

        # machine-id is stable across boots, boot_id is not.
 #or filename in "/etc/machine-id", "/proc/sys/kernel/random/boot_id":
 #ry:
 #ith open(filename, "rb") as f:
 #alue = f.readline().strip()
 #xcept OSError:
 #ontinue

 #f value:
 #inux += value
 #reak

        # Containers share the same machine id, add some cgroup
        # information. This is used outside containers too but should be
        # relatively stable across boots.
 #ry:
 #ith open("/proc/self/cgroup", "rb") as f:
 #inux += f.readline().strip().rpartition(b"/")[2]
 #xcept OSError:
 #ass

 #f linux:
 #eturn linux

        # On OS X, use ioreg to get the computer's serial number.
 #ry:
            # subprocess may not be available, e.g. Google App Engine
            # https://github.com/pallets/werkzeug/issues/925
 #rom subprocess import Popen, PIPE

 #ump = Popen(
 #"ioreg", "-c", "IOPlatformExpertDevice", "-d", "2"], stdout=PIPE
 #.communicate()[0]
 #atch = re.search(b'"serial-number" = <([^>]+)', dump)

 #f match is not None:
 #eturn match.group(1)
 #xcept (OSError, ImportError):
 #ass

        # On Windows, use winreg to get the machine guid.
 #f sys.platform == "win32":
 #mport winreg

 #ry:
 #ith winreg.OpenKey(
 #inreg.HKEY_LOCAL_MACHINE,
 #SOFTWARE\\Microsoft\\Cryptography",
 #,
 #inreg.KEY_READ | winreg.KEY_WOW64_64KEY,
 # as rk:
 #uid: t.Union[str, bytes]
 #uid_type: int
 #uid, guid_type = winreg.QueryValueEx(rk, "MachineGuid")

 #f guid_type == winreg.REG_SZ:
 #eturn guid.encode("utf-8")

 #eturn guid
 #xcept OSError:
 #ass

 #eturn None

 #machine_id = _generate()
 #eturn _machine_id


class _ConsoleFrame:
 #""Helper class so that we can reuse the frame console code for the
 #tandalone console.
 #""

 #ef __init__(self, namespace: t.Dict[str, t.Any]):
 #elf.console = Console(namespace)
 #elf.id = 0


def get_pin_and_cookie_name(
 #pp: "WSGIApplication",
) -> t.Union[t.Tuple[str, str], t.Tuple[None, None]]:
 #""Given an application object this returns a semi-stable 9 digit pin
 #ode and a random key.  The hope is that this is stable between
 #estarts to not make debugging particularly frustrating.  If the pin
 #as forcefully disabled this returns `None`.

 #econd item in the resulting tuple is the cookie name for remembering.
 #""
 #in = os.environ.get("WERKZEUG_DEBUG_PIN")
 #v = None
 #um = None

    # Pin was explicitly disabled
 #f pin == "off":
 #eturn None, None

    # Pin was provided explicitly
 #f pin is not None and pin.replace("-", "").isdigit():
        # If there are separators in the pin, return it directly
 #f "-" in pin:
 #v = pin
 #lse:
 #um = pin

 #odname = getattr(app, "__module__", t.cast(object, app).__class__.__module__)
 #sername: t.Optional[str]

 #ry:
        # getuser imports the pwd module, which does not exist in Google
        # App Engine. It may also raise a KeyError if the UID does not
        # have a username, such as in Docker.
 #sername = getpass.getuser()
 #xcept (ImportError, KeyError):
 #sername = None

 #od = sys.modules.get(modname)

    # This information only exists to make the cookie unique on the
    # computer, not as a security feature.
 #robably_public_bits = [
 #sername,
 #odname,
 #etattr(app, "__name__", type(app).__name__),
 #etattr(mod, "__file__", None),
 #

    # This information is here to make it harder for an attacker to
    # guess the cookie name.  They are unlikely to be contained anywhere
    # within the unauthenticated debug page.
 #rivate_bits = [str(uuid.getnode()), get_machine_id()]

 # = hashlib.sha1()
 #or bit in chain(probably_public_bits, private_bits):
 #f not bit:
 #ontinue
 #f isinstance(bit, str):
 #it = bit.encode("utf-8")
 #.update(bit)
 #.update(b"cookiesalt")

 #ookie_name = f"__wzd{h.hexdigest()[:20]}"

    # If we need to generate a pin we salt it a bit more so that we don't
    # end up with the same value and generate out 9 digits
 #f num is None:
 #.update(b"pinsalt")
 #um = f"{int(h.hexdigest(), 16):09d}"[:9]

    # Format the pincode in groups of digits for easier remembering if
    # we don't have a result yet.
 #f rv is None:
 #or group_size in 5, 4, 3:
 #f len(num) % group_size == 0:
 #v = "-".join(
 #um[x : x + group_size].rjust(group_size, "0")
 #or x in range(0, len(num), group_size)
 #
 #reak
 #lse:
 #v = num

 #eturn rv, cookie_name


class DebuggedApplication:
 #""Enables debugging support for a given application::

 #rom werkzeug.debug import DebuggedApplication
 #rom myapp import app
 #pp = DebuggedApplication(app, evalex=True)

 #he `evalex` keyword argument allows evaluating expressions in a
 #raceback's frame context.

 #param app: the WSGI application to run debugged.
 #param evalex: enable exception evaluation feature (interactive
 #ebugging).  This requires a non-forking server.
 #param request_key: The key that points to the request object in ths
 #nvironment.  This parameter is ignored in current
 #ersions.
 #param console_path: the URL for a general purpose console.
 #param console_init_func: the function that is executed before starting
 #he general purpose console.  The return value
 #s used as initial namespace.
 #param show_hidden_frames: by default hidden traceback frames are skipped.
 #ou can show them by setting this parameter
 #o `True`.
 #param pin_security: can be used to disable the pin based security system.
 #param pin_logging: enables the logging of the pin system.
 #""

 #pin: str
 #pin_cookie: str

 #ef __init__(
 #elf,
 #pp: "WSGIApplication",
 #valex: bool = False,
 #equest_key: str = "werkzeug.request",
 #onsole_path: str = "/console",
 #onsole_init_func: t.Optional[t.Callable[[], t.Dict[str, t.Any]]] = None,
 #how_hidden_frames: bool = False,
 #in_security: bool = True,
 #in_logging: bool = True,
 # -> None:
 #f not console_init_func:
 #onsole_init_func = None
 #elf.app = app
 #elf.evalex = evalex
 #elf.frames: t.Dict[int, t.Union[Frame, _ConsoleFrame]] = {}
 #elf.tracebacks: t.Dict[int, Traceback] = {}
 #elf.request_key = request_key
 #elf.console_path = console_path
 #elf.console_init_func = console_init_func
 #elf.show_hidden_frames = show_hidden_frames
 #elf.secret = gen_salt(20)
 #elf._failed_pin_auth = 0

 #elf.pin_logging = pin_logging
 #f pin_security:
            # Print out the pin for the debugger on standard out.
 #f os.environ.get("WERKZEUG_RUN_MAIN") == "true" and pin_logging:
 #log("warning", " * Debugger is active!")
 #f self.pin is None:
 #log("warning", " * Debugger PIN disabled. DEBUGGER UNSECURED!")
 #lse:
 #log("info", " * Debugger PIN: %s", self.pin)
 #lse:
 #elf.pin = None

 #property
 #ef pin(self) -> t.Optional[str]:
 #f not hasattr(self, "_pin"):
 #in_cookie = get_pin_and_cookie_name(self.app)
 #elf._pin, self._pin_cookie = pin_cookie  # type: ignore
 #eturn self._pin

 #pin.setter
 #ef pin(self, value: str) -> None:
 #elf._pin = value

 #property
 #ef pin_cookie_name(self) -> str:
 #""The name of the pin cookie."""
 #f not hasattr(self, "_pin_cookie"):
 #in_cookie = get_pin_and_cookie_name(self.app)
 #elf._pin, self._pin_cookie = pin_cookie  # type: ignore
 #eturn self._pin_cookie

 #ef debug_application(
 #elf, environ: "WSGIEnvironment", start_response: "StartResponse"
 # -> t.Iterator[bytes]:
 #""Run the application and conserve the traceback frames."""
 #pp_iter = None
 #ry:
 #pp_iter = self.app(environ, start_response)
 #ield from app_iter
 #f hasattr(app_iter, "close"):
 #pp_iter.close()  # type: ignore
 #xcept Exception:
 #f hasattr(app_iter, "close"):
 #pp_iter.close()  # type: ignore
 #raceback = get_current_traceback(
 #kip=1,
 #how_hidden_frames=self.show_hidden_frames,
 #gnore_system_exceptions=True,
 #
 #or frame in traceback.frames:
 #elf.frames[frame.id] = frame
 #elf.tracebacks[traceback.id] = traceback

 #ry:
 #tart_response(
 #500 INTERNAL SERVER ERROR",
 #
 #"Content-Type", "text/html; charset=utf-8"),
                        # Disable Chrome's XSS protection, the debug
                        # output can cause false-positives.
 #"X-XSS-Protection", "0"),
 #,
 #
 #xcept Exception:
                # if we end up here there has been output but an error
                # occurred.  in that situation we can do nothing fancy any
                # more, better log something into the error log and fall
                # back gracefully.
 #nviron["wsgi.errors"].write(
 #Debugging middleware caught exception in streamed "
 #response at a point where response headers were already "
 #sent.\n"
 #
 #lse:
 #s_trusted = bool(self.check_pin_trust(environ))
 #ield traceback.render_full(
 #valex=self.evalex, evalex_trusted=is_trusted, secret=self.secret
 #.encode("utf-8", "replace")

 #raceback.log(environ["wsgi.errors"])

 #ef execute_command(
 #elf, request: Request, command: str, frame: t.Union[Frame, _ConsoleFrame]
 # -> Response:
 #""Execute a command in a console."""
 #eturn Response(frame.console.eval(command), mimetype="text/html")

 #ef display_console(self, request: Request) -> Response:
 #""Display a standalone shell."""
 #f 0 not in self.frames:
 #f self.console_init_func is None:
 #s = {}
 #lse:
 #s = dict(self.console_init_func())
 #s.setdefault("app", self.app)
 #elf.frames[0] = _ConsoleFrame(ns)
 #s_trusted = bool(self.check_pin_trust(request.environ))
 #eturn Response(
 #ender_console_html(secret=self.secret, evalex_trusted=is_trusted),
 #imetype="text/html",
 #

 #ef get_resource(self, request: Request, filename: str) -> Response:
 #""Return a static resource from the shared folder."""
 #ilename = join("shared", basename(filename))
 #ry:
 #ata = pkgutil.get_data(__package__, filename)
 #xcept OSError:
 #ata = None
 #f data is not None:
 #imetype = mimetypes.guess_type(filename)[0] or "application/octet-stream"
 #eturn Response(data, mimetype=mimetype)
 #eturn Response("Not Found", status=404)

 #ef check_pin_trust(self, environ: "WSGIEnvironment") -> t.Optional[bool]:
 #""Checks if the request passed the pin test.  This returns `True` if the
 #equest is trusted on a pin/cookie basis and returns `False` if not.
 #dditionally if the cookie's stored pin hash is wrong it will return
 #None` so that appropriate action can be taken.
 #""
 #f self.pin is None:
 #eturn True
 #al = parse_cookie(environ).get(self.pin_cookie_name)
 #f not val or "|" not in val:
 #eturn False
 #s, pin_hash = val.split("|", 1)
 #f not ts.isdigit():
 #eturn False
 #f pin_hash != hash_pin(self.pin):
 #eturn None
 #eturn (time.time() - PIN_TIME) < int(ts)

 #ef _fail_pin_auth(self) -> None:
 #ime.sleep(5.0 if self._failed_pin_auth > 5 else 0.5)
 #elf._failed_pin_auth += 1

 #ef pin_auth(self, request: Request) -> Response:
 #""Authenticates with the pin."""
 #xhausted = False
 #uth = False
 #rust = self.check_pin_trust(request.environ)
 #in = t.cast(str, self.pin)

        # If the trust return value is `None` it means that the cookie is
        # set but the stored pin hash value is bad.  This means that the
        # pin was changed.  In this case we count a bad auth and unset the
        # cookie.  This way it becomes harder to guess the cookie name
        # instead of the pin as we still count up failures.
 #ad_cookie = False
 #f trust is None:
 #elf._fail_pin_auth()
 #ad_cookie = True

        # If we're trusted, we're authenticated.
 #lif trust:
 #uth = True

        # If we failed too many times, then we're locked out.
 #lif self._failed_pin_auth > 10:
 #xhausted = True

        # Otherwise go through pin based authentication
 #lse:
 #ntered_pin = request.args["pin"]

 #f entered_pin.strip().replace("-", "") == pin.replace("-", ""):
 #elf._failed_pin_auth = 0
 #uth = True
 #lse:
 #elf._fail_pin_auth()

 #v = Response(
 #son.dumps({"auth": auth, "exhausted": exhausted}),
 #imetype="application/json",
 #
 #f auth:
 #v.set_cookie(
 #elf.pin_cookie_name,
 #"{int(time.time())}|{hash_pin(pin)}",
 #ttponly=True,
 #amesite="Strict",
 #ecure=request.is_secure,
 #
 #lif bad_cookie:
 #v.delete_cookie(self.pin_cookie_name)
 #eturn rv

 #ef log_pin_request(self) -> Response:
 #""Log the pin if needed."""
 #f self.pin_logging and self.pin is not None:
 #log(
 #info", " * To enable the debugger you need to enter the security pin:"
 #
 #log("info", " * Debugger pin code: %s", self.pin)
 #eturn Response("")

 #ef __call__(
 #elf, environ: "WSGIEnvironment", start_response: "StartResponse"
 # -> t.Iterable[bytes]:
 #""Dispatch the requests."""
        # important: don't ever access a function here that reads the incoming
        # form data!  Otherwise the application won't have access to that data
        # any more!
 #equest = Request(environ)
 #esponse = self.debug_application
 #f request.args.get("__debugger__") == "yes":
 #md = request.args.get("cmd")
 #rg = request.args.get("f")
 #ecret = request.args.get("s")
 #rame = self.frames.get(request.args.get("frm", type=int))  # type: ignore
 #f cmd == "resource" and arg:
 #esponse = self.get_resource(request, arg)  # type: ignore
 #lif cmd == "pinauth" and secret == self.secret:
 #esponse = self.pin_auth(request)  # type: ignore
 #lif cmd == "printpin" and secret == self.secret:
 #esponse = self.log_pin_request()  # type: ignore
 #lif (
 #elf.evalex
 #nd cmd is not None
 #nd frame is not None
 #nd self.secret == secret
 #nd self.check_pin_trust(environ)
 #:
 #esponse = self.execute_command(request, cmd, frame)  # type: ignore
 #lif (
 #elf.evalex
 #nd self.console_path is not None
 #nd request.path == self.console_path
 #:
 #esponse = self.display_console(request)  # type: ignore
 #eturn response(environ, start_response)
