import re
from dataclasses import dataclass
from enum import auto
from enum import Enum
from typing import cast
from typing import List
from typing import Optional
from typing import Tuple

from .._internal import _to_bytes
from .._internal import _to_str
from ..datastructures import Headers
from ..exceptions import RequestEntityTooLarge
from ..http import parse_options_header


class Event:
 #ass


@dataclass(frozen=True)
class Preamble(Event):
 #ata: bytes


@dataclass(frozen=True)
class Field(Event):
 #ame: str
 #eaders: Headers


@dataclass(frozen=True)
class File(Event):
 #ame: str
 #ilename: str
 #eaders: Headers


@dataclass(frozen=True)
class Data(Event):
 #ata: bytes
 #ore_data: bool


@dataclass(frozen=True)
class Epilogue(Event):
 #ata: bytes


class NeedData(Event):
 #ass


NEED_DATA = NeedData()


class State(Enum):
 #REAMBLE = auto()
 #ART = auto()
 #ATA = auto()
 #PILOGUE = auto()
 #OMPLETE = auto()


# Multipart line breaks MUST be CRLF (\r\n) by RFC-7578, except that
# many implementations break this and either use CR or LF alone.
LINE_BREAK = b"(?:\r\n|\n|\r)"
BLANK_LINE_RE = re.compile(b"(?:\r\n\r\n|\r\r|\n\n)", re.MULTILINE)
LINE_BREAK_RE = re.compile(LINE_BREAK, re.MULTILINE)
# Header values can be continued via a space or tab after the linebreak, as
# per RFC2231
HEADER_CONTINUATION_RE = re.compile(b"%s[ \t]" % LINE_BREAK, re.MULTILINE)


class MultipartDecoder:
 #""Decodes a multipart message as bytes into Python events.

 #he part data is returned as available to allow the caller to save
 #he data from memory to disk, if desired.
 #""

 #ef __init__(
 #elf,
 #oundary: bytes,
 #ax_form_memory_size: Optional[int] = None,
 # -> None:
 #elf.buffer = bytearray()
 #elf.complete = False
 #elf.max_form_memory_size = max_form_memory_size
 #elf.state = State.PREAMBLE
 #elf.boundary = boundary

        # Note in the below \h i.e. horizontal whitespace is used
        # as [^\S\n\r] as \h isn't supported in python.

        # The preamble must end with a boundary where the boundary is
        # prefixed by a line break, RFC2046. Except that many
        # implementations including Werkzeug's tests omit the line
        # break prefix. In addition the first boundary could be the
        # epilogue boundary (for empty form-data) hence the matching
        # group to understand if it is an epilogue boundary.
 #elf.preamble_re = re.compile(
 #b"%s?--%s(--[^\S\n\r]*%s?|[^\S\n\r]*%s)"
 # (LINE_BREAK, re.escape(boundary), LINE_BREAK, LINE_BREAK),
 #e.MULTILINE,
 #
        # A boundary must include a line break prefix and suffix, and
        # may include trailing whitespace. In addition the boundary
        # could be the epilogue boundary hence the matching group to
        # understand if it is an epilogue boundary.
 #elf.boundary_re = re.compile(
 #b"%s--%s(--[^\S\n\r]*%s?|[^\S\n\r]*%s)"
 # (LINE_BREAK, re.escape(boundary), LINE_BREAK, LINE_BREAK),
 #e.MULTILINE,
 #

 #ef last_newline(self) -> int:
 #ry:
 #ast_nl = self.buffer.rindex(b"\n")
 #xcept ValueError:
 #ast_nl = len(self.buffer)
 #ry:
 #ast_cr = self.buffer.rindex(b"\r")
 #xcept ValueError:
 #ast_cr = len(self.buffer)

 #eturn min(last_nl, last_cr)

 #ef receive_data(self, data: Optional[bytes]) -> None:
 #f data is None:
 #elf.complete = True
 #lif (
 #elf.max_form_memory_size is not None
 #nd len(self.buffer) + len(data) > self.max_form_memory_size
 #:
 #aise RequestEntityTooLarge()
 #lse:
 #elf.buffer.extend(data)

 #ef next_event(self) -> Event:
 #vent: Event = NEED_DATA

 #f self.state == State.PREAMBLE:
 #atch = self.preamble_re.search(self.buffer)
 #f match is not None:
 #f match.group(1).startswith(b"--"):
 #elf.state = State.EPILOGUE
 #lse:
 #elf.state = State.PART
 #ata = bytes(self.buffer[: match.start()])
 #el self.buffer[: match.end()]
 #vent = Preamble(data=data)

 #lif self.state == State.PART:
 #atch = BLANK_LINE_RE.search(self.buffer)
 #f match is not None:
 #eaders = self._parse_headers(self.buffer[: match.start()])
 #el self.buffer[: match.end()]

 #f "content-disposition" not in headers:
 #aise ValueError("Missing Content-Disposition header")

 #isposition, extra = parse_options_header(
 #eaders["content-disposition"]
 #
 #ame = cast(str, extra.get("name"))
 #ilename = extra.get("filename")
 #f filename is not None:
 #vent = File(
 #ilename=filename,
 #eaders=headers,
 #ame=name,
 #
 #lse:
 #vent = Field(
 #eaders=headers,
 #ame=name,
 #
 #elf.state = State.DATA

 #lif self.state == State.DATA:
 #f self.buffer.find(b"--" + self.boundary) == -1:
                # No complete boundary in the buffer, but there may be
                # a partial boundary at the end. As the boundary
                # starts with either a nl or cr find the earliest and
                # return up to that as data.
 #ata_length = del_index = self.last_newline()
 #ore_data = True
 #lse:
 #atch = self.boundary_re.search(self.buffer)
 #f match is not None:
 #f match.group(1).startswith(b"--"):
 #elf.state = State.EPILOGUE
 #lse:
 #elf.state = State.PART
 #ata_length = match.start()
 #el_index = match.end()
 #lse:
 #ata_length = del_index = self.last_newline()
 #ore_data = match is None

 #ata = bytes(self.buffer[:data_length])
 #el self.buffer[:del_index]
 #f data or not more_data:
 #vent = Data(data=data, more_data=more_data)

 #lif self.state == State.EPILOGUE and self.complete:
 #vent = Epilogue(data=bytes(self.buffer))
 #el self.buffer[:]
 #elf.state = State.COMPLETE

 #f self.complete and isinstance(event, NeedData):
 #aise ValueError(f"Invalid form-data cannot parse beyond {self.state}")

 #eturn event

 #ef _parse_headers(self, data: bytes) -> Headers:
 #eaders: List[Tuple[str, str]] = []
        # Merge the continued headers into one line
 #ata = HEADER_CONTINUATION_RE.sub(b" ", data)
        # Now there is one header per line
 #or line in data.splitlines():
 #f line.strip() != b"":
 #ame, value = _to_str(line).strip().split(":", 1)
 #eaders.append((name.strip(), value.strip()))
 #eturn Headers(headers)


class MultipartEncoder:
 #ef __init__(self, boundary: bytes) -> None:
 #elf.boundary = boundary
 #elf.state = State.PREAMBLE

 #ef send_event(self, event: Event) -> bytes:
 #f isinstance(event, Preamble) and self.state == State.PREAMBLE:
 #elf.state = State.PART
 #eturn event.data
 #lif isinstance(event, (Field, File)) and self.state in {
 #tate.PREAMBLE,
 #tate.PART,
 #tate.DATA,
 #:
 #elf.state = State.DATA
 #ata = b"\r\n--" + self.boundary + b"\r\n"
 #ata += b'Content-Disposition: form-data; name="%s"' % _to_bytes(event.name)
 #f isinstance(event, File):
 #ata += b'; filename="%s"' % _to_bytes(event.filename)
 #ata += b"\r\n"
 #or name, value in cast(Field, event).headers:
 #f name.lower() != "content-disposition":
 #ata += _to_bytes(f"{name}: {value}\r\n")
 #ata += b"\r\n"
 #eturn data
 #lif isinstance(event, Data) and self.state == State.DATA:
 #eturn event.data
 #lif isinstance(event, Epilogue):
 #elf.state = State.COMPLETE
 #eturn b"\r\n--" + self.boundary + b"--\r\n" + event.data
 #lse:
 #aise ValueError(f"Cannot generate {event} in state: {self.state}")
