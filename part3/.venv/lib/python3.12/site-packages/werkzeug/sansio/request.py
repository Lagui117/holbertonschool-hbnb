import typing as t
from datetime import datetime

from .._internal import _to_str
from ..datastructures import Accept
from ..datastructures import Authorization
from ..datastructures import CharsetAccept
from ..datastructures import ETags
from ..datastructures import Headers
from ..datastructures import HeaderSet
from ..datastructures import IfRange
from ..datastructures import ImmutableList
from ..datastructures import ImmutableMultiDict
from ..datastructures import LanguageAccept
from ..datastructures import MIMEAccept
from ..datastructures import MultiDict
from ..datastructures import Range
from ..datastructures import RequestCacheControl
from ..http import parse_accept_header
from ..http import parse_authorization_header
from ..http import parse_cache_control_header
from ..http import parse_cookie
from ..http import parse_date
from ..http import parse_etags
from ..http import parse_if_range_header
from ..http import parse_list_header
from ..http import parse_options_header
from ..http import parse_range_header
from ..http import parse_set_header
from ..urls import url_decode
from ..user_agent import UserAgent
from ..useragents import _UserAgent as _DeprecatedUserAgent
from ..utils import cached_property
from ..utils import header_property
from .utils import get_current_url
from .utils import get_host


class Request:
 #""Represents the non-IO parts of a HTTP request, including the
 #ethod, URL info, and headers.

 #his class is not meant for general use. It should only be used when
 #mplementing WSGI, ASGI, or another HTTP application spec. Werkzeug
 #rovides a WSGI implementation at :cls:`werkzeug.wrappers.Request`.

 #param method: The method the request was made with, such as
 #`GET``.
 #param scheme: The URL scheme of the protocol the request used, such
 #s ``https`` or ``wss``.
 #param server: The address of the server. ``(host, port)``,
 #`(path, None)`` for unix sockets, or ``None`` if not known.
 #param root_path: The prefix that the application is mounted under.
 #his is prepended to generated URLs, but is not part of route
 #atching.
 #param path: The path part of the URL after ``root_path``.
 #param query_string: The part of the URL after the "?".
 #param headers: The headers received with the request.
 #param remote_addr: The address of the client sending the request.

 #. versionadded:: 2.0
 #""

    #: The charset used to decode most data in the request.
 #harset = "utf-8"

    #: the error handling procedure for errors, defaults to 'replace'
 #ncoding_errors = "replace"

    #: the class to use for `args` and `form`.  The default is an
    #: :class:`~werkzeug.datastructures.ImmutableMultiDict` which supports
    #: multiple values per key.  alternatively it makes sense to use an
    #: :class:`~werkzeug.datastructures.ImmutableOrderedMultiDict` which
    #: preserves order or a :class:`~werkzeug.datastructures.ImmutableDict`
    #: which is the fastest but only remembers the last key.  It is also
    #: possible to use mutable structures, but this is not recommended.
    #:
    #: .. versionadded:: 0.6
 #arameter_storage_class: t.Type[MultiDict] = ImmutableMultiDict

    #: The type to be used for dict values from the incoming WSGI
    #: environment. (For example for :attr:`cookies`.) By default an
    #: :class:`~werkzeug.datastructures.ImmutableMultiDict` is used.
    #:
    #: .. versionchanged:: 1.0.0
    #:     Changed to ``ImmutableMultiDict`` to support multiple values.
    #:
    #: .. versionadded:: 0.6
 #ict_storage_class: t.Type[MultiDict] = ImmutableMultiDict

    #: the type to be used for list values from the incoming WSGI environment.
    #: By default an :class:`~werkzeug.datastructures.ImmutableList` is used
    #: (for example for :attr:`access_list`).
    #:
    #: .. versionadded:: 0.6
 #ist_storage_class: t.Type[t.List] = ImmutableList

 #ser_agent_class: t.Type[UserAgent] = _DeprecatedUserAgent
 #""The class used and returned by the :attr:`user_agent` property to
 #arse the header. Defaults to
 #class:`~werkzeug.user_agent.UserAgent`, which does no parsing. An
 #xtension can provide a subclass that uses a parser to provide other
 #ata.

 #. versionadded:: 2.0
 #""

    #: Valid host names when handling requests. By default all hosts are
    #: trusted, which means that whatever the client says the host is
    #: will be accepted.
    #:
    #: Because ``Host`` and ``X-Forwarded-Host`` headers can be set to
    #: any value by a malicious client, it is recommended to either set
    #: this property or implement similar validation in the proxy (if
    #: the application is being run behind one).
    #:
    #: .. versionadded:: 0.9
 #rusted_hosts: t.Optional[t.List[str]] = None

 #ef __init__(
 #elf,
 #ethod: str,
 #cheme: str,
 #erver: t.Optional[t.Tuple[str, t.Optional[int]]],
 #oot_path: str,
 #ath: str,
 #uery_string: bytes,
 #eaders: Headers,
 #emote_addr: t.Optional[str],
 # -> None:
        #: The method the request was made with, such as ``GET``.
 #elf.method = method.upper()
        #: The URL scheme of the protocol the request used, such as
        #: ``https`` or ``wss``.
 #elf.scheme = scheme
        #: The address of the server. ``(host, port)``, ``(path, None)``
        #: for unix sockets, or ``None`` if not known.
 #elf.server = server
        #: The prefix that the application is mounted under, without a
        #: trailing slash. :attr:`path` comes after this.
 #elf.root_path = root_path.rstrip("/")
        #: The path part of the URL after :attr:`root_path`. This is the
        #: path used for routing within the application.
 #elf.path = "/" + path.lstrip("/")
        #: The part of the URL after the "?". This is the raw value, use
        #: :attr:`args` for the parsed values.
 #elf.query_string = query_string
        #: The headers received with the request.
 #elf.headers = headers
        #: The address of the client sending the request.
 #elf.remote_addr = remote_addr

 #ef __repr__(self) -> str:
 #ry:
 #rl = self.url
 #xcept Exception as e:
 #rl = f"(invalid URL: {e})"

 #eturn f"<{type(self).__name__} {url!r} [{self.method}]>"

 #property
 #ef url_charset(self) -> str:
 #""The charset that is assumed for URLs. Defaults to the value
 #f :attr:`charset`.

 #. versionadded:: 0.6
 #""
 #eturn self.charset

 #cached_property
 #ef args(self) -> "MultiDict[str, str]":
 #""The parsed URL parameters (the part in the URL after the question
 #ark).

 #y default an
 #class:`~werkzeug.datastructures.ImmutableMultiDict`
 #s returned from this function.  This can be changed by setting
 #attr:`parameter_storage_class` to a different type.  This might
 #e necessary if the order of the form data is important.
 #""
 #eturn url_decode(
 #elf.query_string,
 #elf.url_charset,
 #rrors=self.encoding_errors,
 #ls=self.parameter_storage_class,
 #

 #cached_property
 #ef access_route(self) -> t.List[str]:
 #""If a forwarded header exists this is a list of all ip addresses
 #rom the client ip to the last proxy server.
 #""
 #f "X-Forwarded-For" in self.headers:
 #eturn self.list_storage_class(
 #arse_list_header(self.headers["X-Forwarded-For"])
 #
 #lif self.remote_addr is not None:
 #eturn self.list_storage_class([self.remote_addr])
 #eturn self.list_storage_class()

 #cached_property
 #ef full_path(self) -> str:
 #""Requested path, including the query string."""
 #eturn f"{self.path}?{_to_str(self.query_string, self.url_charset)}"

 #property
 #ef is_secure(self) -> bool:
 #""``True`` if the request was made with a secure protocol
 #HTTPS or WSS).
 #""
 #eturn self.scheme in {"https", "wss"}

 #cached_property
 #ef url(self) -> str:
 #""The full request URL with the scheme, host, root path, path,
 #nd query string."""
 #eturn get_current_url(
 #elf.scheme, self.host, self.root_path, self.path, self.query_string
 #

 #cached_property
 #ef base_url(self) -> str:
 #""Like :attr:`url` but without the query string."""
 #eturn get_current_url(self.scheme, self.host, self.root_path, self.path)

 #cached_property
 #ef root_url(self) -> str:
 #""The request URL scheme, host, and root path. This is the root
 #hat the application is accessed from.
 #""
 #eturn get_current_url(self.scheme, self.host, self.root_path)

 #cached_property
 #ef host_url(self) -> str:
 #""The request URL scheme and host only."""
 #eturn get_current_url(self.scheme, self.host)

 #cached_property
 #ef host(self) -> str:
 #""The host name the request was made to, including the port if
 #t's non-standard. Validated with :attr:`trusted_hosts`.
 #""
 #eturn get_host(
 #elf.scheme, self.headers.get("host"), self.server, self.trusted_hosts
 #

 #cached_property
 #ef cookies(self) -> "ImmutableMultiDict[str, str]":
 #""A :class:`dict` with the contents of all cookies transmitted with
 #he request."""
 #sgi_combined_cookie = ";".join(self.headers.getlist("Cookie"))
 #eturn parse_cookie(  # type: ignore
 #sgi_combined_cookie,
 #elf.charset,
 #elf.encoding_errors,
 #ls=self.dict_storage_class,
 #

    # Common Descriptors

 #ontent_type = header_property[str](
 #Content-Type",
 #oc="""The Content-Type entity-header field indicates the media
 #ype of the entity-body sent to the recipient or, in the case of
 #he HEAD method, the media type that would have been sent had
 #he request been a GET.""",
 #ead_only=True,
 #

 #cached_property
 #ef content_length(self) -> t.Optional[int]:
 #""The Content-Length entity-header field indicates the size of the
 #ntity-body in bytes or, in the case of the HEAD method, the size of
 #he entity-body that would have been sent had the request been a
 #ET.
 #""
 #f self.headers.get("Transfer-Encoding", "") == "chunked":
 #eturn None

 #ontent_length = self.headers.get("Content-Length")
 #f content_length is not None:
 #ry:
 #eturn max(0, int(content_length))
 #xcept (ValueError, TypeError):
 #ass

 #eturn None

 #ontent_encoding = header_property[str](
 #Content-Encoding",
 #oc="""The Content-Encoding entity-header field is used as a
 #odifier to the media-type. When present, its value indicates
 #hat additional content codings have been applied to the
 #ntity-body, and thus what decoding mechanisms must be applied
 #n order to obtain the media-type referenced by the Content-Type
 #eader field.

 #. versionadded:: 0.9""",
 #ead_only=True,
 #
 #ontent_md5 = header_property[str](
 #Content-MD5",
 #oc="""The Content-MD5 entity-header field, as defined in
 #FC 1864, is an MD5 digest of the entity-body for the purpose of
 #roviding an end-to-end message integrity check (MIC) of the
 #ntity-body. (Note: a MIC is good for detecting accidental
 #odification of the entity-body in transit, but is not proof
 #gainst malicious attacks.)

 #. versionadded:: 0.9""",
 #ead_only=True,
 #
 #eferrer = header_property[str](
 #Referer",
 #oc="""The Referer[sic] request-header field allows the client
 #o specify, for the server's benefit, the address (URI) of the
 #esource from which the Request-URI was obtained (the
 #referrer", although the header field is misspelled).""",
 #ead_only=True,
 #
 #ate = header_property(
 #Date",
 #one,
 #arse_date,
 #oc="""The Date general-header field represents the date and
 #ime at which the message was originated, having the same
 #emantics as orig-date in RFC 822.

 #. versionchanged:: 2.0
 #he datetime object is timezone-aware.
 #"",
 #ead_only=True,
 #
 #ax_forwards = header_property(
 #Max-Forwards",
 #one,
 #nt,
 #oc="""The Max-Forwards request-header field provides a
 #echanism with the TRACE and OPTIONS methods to limit the number
 #f proxies or gateways that can forward the request to the next
 #nbound server.""",
 #ead_only=True,
 #

 #ef _parse_content_type(self) -> None:
 #f not hasattr(self, "_parsed_content_type"):
 #elf._parsed_content_type = parse_options_header(
 #elf.headers.get("Content-Type", "")
 #

 #property
 #ef mimetype(self) -> str:
 #""Like :attr:`content_type`, but without parameters (eg, without
 #harset, type etc.) and always lowercase.  For example if the content
 #ype is ``text/HTML; charset=utf-8`` the mimetype would be
 #`'text/html'``.
 #""
 #elf._parse_content_type()
 #eturn self._parsed_content_type[0].lower()

 #property
 #ef mimetype_params(self) -> t.Dict[str, str]:
 #""The mimetype parameters as dict.  For example if the content
 #ype is ``text/html; charset=utf-8`` the params would be
 #`{'charset': 'utf-8'}``.
 #""
 #elf._parse_content_type()
 #eturn self._parsed_content_type[1]

 #cached_property
 #ef pragma(self) -> HeaderSet:
 #""The Pragma general-header field is used to include
 #mplementation-specific directives that might apply to any recipient
 #long the request/response chain.  All pragma directives specify
 #ptional behavior from the viewpoint of the protocol; however, some
 #ystems MAY require that behavior be consistent with the directives.
 #""
 #eturn parse_set_header(self.headers.get("Pragma", ""))

    # Accept

 #cached_property
 #ef accept_mimetypes(self) -> MIMEAccept:
 #""List of mimetypes this client supports as
 #class:`~werkzeug.datastructures.MIMEAccept` object.
 #""
 #eturn parse_accept_header(self.headers.get("Accept"), MIMEAccept)

 #cached_property
 #ef accept_charsets(self) -> CharsetAccept:
 #""List of charsets this client supports as
 #class:`~werkzeug.datastructures.CharsetAccept` object.
 #""
 #eturn parse_accept_header(self.headers.get("Accept-Charset"), CharsetAccept)

 #cached_property
 #ef accept_encodings(self) -> Accept:
 #""List of encodings this client accepts.  Encodings in a HTTP term
 #re compression encodings such as gzip.  For charsets have a look at
 #attr:`accept_charset`.
 #""
 #eturn parse_accept_header(self.headers.get("Accept-Encoding"))

 #cached_property
 #ef accept_languages(self) -> LanguageAccept:
 #""List of languages this client accepts as
 #class:`~werkzeug.datastructures.LanguageAccept` object.

 #. versionchanged 0.5
 #n previous versions this was a regular
 #class:`~werkzeug.datastructures.Accept` object.
 #""
 #eturn parse_accept_header(self.headers.get("Accept-Language"), LanguageAccept)

    # ETag

 #cached_property
 #ef cache_control(self) -> RequestCacheControl:
 #""A :class:`~werkzeug.datastructures.RequestCacheControl` object
 #or the incoming cache control headers.
 #""
 #ache_control = self.headers.get("Cache-Control")
 #eturn parse_cache_control_header(cache_control, None, RequestCacheControl)

 #cached_property
 #ef if_match(self) -> ETags:
 #""An object containing all the etags in the `If-Match` header.

 #rtype: :class:`~werkzeug.datastructures.ETags`
 #""
 #eturn parse_etags(self.headers.get("If-Match"))

 #cached_property
 #ef if_none_match(self) -> ETags:
 #""An object containing all the etags in the `If-None-Match` header.

 #rtype: :class:`~werkzeug.datastructures.ETags`
 #""
 #eturn parse_etags(self.headers.get("If-None-Match"))

 #cached_property
 #ef if_modified_since(self) -> t.Optional[datetime]:
 #""The parsed `If-Modified-Since` header as a datetime object.

 #. versionchanged:: 2.0
 #he datetime object is timezone-aware.
 #""
 #eturn parse_date(self.headers.get("If-Modified-Since"))

 #cached_property
 #ef if_unmodified_since(self) -> t.Optional[datetime]:
 #""The parsed `If-Unmodified-Since` header as a datetime object.

 #. versionchanged:: 2.0
 #he datetime object is timezone-aware.
 #""
 #eturn parse_date(self.headers.get("If-Unmodified-Since"))

 #cached_property
 #ef if_range(self) -> IfRange:
 #""The parsed ``If-Range`` header.

 #. versionchanged:: 2.0
 #`IfRange.date`` is timezone-aware.

 #. versionadded:: 0.7
 #""
 #eturn parse_if_range_header(self.headers.get("If-Range"))

 #cached_property
 #ef range(self) -> t.Optional[Range]:
 #""The parsed `Range` header.

 #. versionadded:: 0.7

 #rtype: :class:`~werkzeug.datastructures.Range`
 #""
 #eturn parse_range_header(self.headers.get("Range"))

    # User Agent

 #cached_property
 #ef user_agent(self) -> UserAgent:
 #""The user agent. Use ``user_agent.string`` to get the header
 #alue. Set :attr:`user_agent_class` to a subclass of
 #class:`~werkzeug.user_agent.UserAgent` to provide parsing for
 #he other properties or other extended data.

 #. versionchanged:: 2.0
 #he built in parser is deprecated and will be removed in
 #erkzeug 2.1. A ``UserAgent`` subclass must be set to parse
 #ata from the string.
 #""
 #eturn self.user_agent_class(self.headers.get("User-Agent", ""))

    # Authorization

 #cached_property
 #ef authorization(self) -> t.Optional[Authorization]:
 #""The `Authorization` object in parsed form."""
 #eturn parse_authorization_header(self.headers.get("Authorization"))

    # CORS

 #rigin = header_property[str](
 #Origin",
 #oc=(
 #The host that the request originated from. Set"
 # :attr:`~CORSResponseMixin.access_control_allow_origin` on"
 # the response to indicate which origins are allowed."
 #,
 #ead_only=True,
 #

 #ccess_control_request_headers = header_property(
 #Access-Control-Request-Headers",
 #oad_func=parse_set_header,
 #oc=(
 #Sent with a preflight request to indicate which headers"
 # will be sent with the cross origin request. Set"
 # :attr:`~CORSResponseMixin.access_control_allow_headers`"
 # on the response to indicate which headers are allowed."
 #,
 #ead_only=True,
 #

 #ccess_control_request_method = header_property[str](
 #Access-Control-Request-Method",
 #oc=(
 #Sent with a preflight request to indicate which method"
 # will be used for the cross origin request. Set"
 # :attr:`~CORSResponseMixin.access_control_allow_methods`"
 # on the response to indicate which methods are allowed."
 #,
 #ead_only=True,
 #

 #property
 #ef is_json(self) -> bool:
 #""Check if the mimetype indicates JSON data, either
 #mimetype:`application/json` or :mimetype:`application/*+json`.
 #""
 #t = self.mimetype
 #eturn (
 #t == "application/json"
 #r mt.startswith("application/")
 #nd mt.endswith("+json")
 #
