import typing as t
from datetime import datetime
from datetime import timedelta
from datetime import timezone
from http import HTTPStatus

from .._internal import _to_str
from ..datastructures import Headers
from ..datastructures import HeaderSet
from ..http import dump_cookie
from ..http import HTTP_STATUS_CODES
from ..utils import get_content_type
from werkzeug.datastructures import CallbackDict
from werkzeug.datastructures import ContentRange
from werkzeug.datastructures import ContentSecurityPolicy
from werkzeug.datastructures import ResponseCacheControl
from werkzeug.datastructures import WWWAuthenticate
from werkzeug.http import COEP
from werkzeug.http import COOP
from werkzeug.http import dump_age
from werkzeug.http import dump_header
from werkzeug.http import dump_options_header
from werkzeug.http import http_date
from werkzeug.http import parse_age
from werkzeug.http import parse_cache_control_header
from werkzeug.http import parse_content_range_header
from werkzeug.http import parse_csp_header
from werkzeug.http import parse_date
from werkzeug.http import parse_options_header
from werkzeug.http import parse_set_header
from werkzeug.http import parse_www_authenticate_header
from werkzeug.http import quote_etag
from werkzeug.http import unquote_etag
from werkzeug.utils import header_property


def _set_property(name: str, doc: t.Optional[str] = None) -> property:
 #ef fget(self: "Response") -> HeaderSet:
 #ef on_update(header_set: HeaderSet) -> None:
 #f not header_set and name in self.headers:
 #el self.headers[name]
 #lif header_set:
 #elf.headers[name] = header_set.to_header()

 #eturn parse_set_header(self.headers.get(name), on_update)

 #ef fset(
 #elf: "Response",
 #alue: t.Optional[
 #.Union[str, t.Dict[str, t.Union[str, int]], t.Iterable[str]]
 #,
 # -> None:
 #f not value:
 #el self.headers[name]
 #lif isinstance(value, str):
 #elf.headers[name] = value
 #lse:
 #elf.headers[name] = dump_header(value)

 #eturn property(fget, fset, doc=doc)


class Response:
 #""Represents the non-IO parts of an HTTP response, specifically the
 #tatus and headers but not the body.

 #his class is not meant for general use. It should only be used when
 #mplementing WSGI, ASGI, or another HTTP application spec. Werkzeug
 #rovides a WSGI implementation at :cls:`werkzeug.wrappers.Response`.

 #param status: The status code for the response. Either an int, in
 #hich case the default status message is added, or a string in
 #he form ``{code} {message}``, like ``404 Not Found``. Defaults
 #o 200.
 #param headers: A :class:`~werkzeug.datastructures.Headers` object,
 #r a list of ``(key, value)`` tuples that will be converted to a
 #`Headers`` object.
 #param mimetype: The mime type (content type without charset or
 #ther parameters) of the response. If the value starts with
 #`text/`` (or matches some other special cases), the charset
 #ill be added to create the ``content_type``.
 #param content_type: The full content type of the response.
 #verrides building the value from ``mimetype``.

 #. versionadded:: 2.0
 #""

    #: the charset of the response.
 #harset = "utf-8"

    #: the default status if none is provided.
 #efault_status = 200

    #: the default mimetype if none is provided.
 #efault_mimetype = "text/plain"

    #: Warn if a cookie header exceeds this size. The default, 4093, should be
    #: safely `supported by most browsers <cookie_>`_. A cookie larger than
    #: this size will still be sent, but it may be ignored or handled
    #: incorrectly by some browsers. Set to 0 to disable this check.
    #:
    #: .. versionadded:: 0.13
    #:
    #: .. _`cookie`: http://browsercookielimits.squawky.net/
 #ax_cookie_size = 4093

    # A :class:`Headers` object representing the response headers.
 #eaders: Headers

 #ef __init__(
 #elf,
 #tatus: t.Optional[t.Union[int, str, HTTPStatus]] = None,
 #eaders: t.Optional[
 #.Union[
 #.Mapping[str, t.Union[str, int, t.Iterable[t.Union[str, int]]]],
 #.Iterable[t.Tuple[str, t.Union[str, int]]],
 #
 # = None,
 #imetype: t.Optional[str] = None,
 #ontent_type: t.Optional[str] = None,
 # -> None:
 #f isinstance(headers, Headers):
 #elf.headers = headers
 #lif not headers:
 #elf.headers = Headers()
 #lse:
 #elf.headers = Headers(headers)

 #f content_type is None:
 #f mimetype is None and "content-type" not in self.headers:
 #imetype = self.default_mimetype
 #f mimetype is not None:
 #imetype = get_content_type(mimetype, self.charset)
 #ontent_type = mimetype
 #f content_type is not None:
 #elf.headers["Content-Type"] = content_type
 #f status is None:
 #tatus = self.default_status
 #elf.status = status  # type: ignore

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__} [{self.status}]>"

 #property
 #ef status_code(self) -> int:
 #""The HTTP status code as a number."""
 #eturn self._status_code

 #status_code.setter
 #ef status_code(self, code: int) -> None:
 #elf.status = code  # type: ignore

 #property
 #ef status(self) -> str:
 #""The HTTP status code as a string."""
 #eturn self._status

 #status.setter
 #ef status(self, value: t.Union[str, int, HTTPStatus]) -> None:
 #f not isinstance(value, (str, bytes, int, HTTPStatus)):
 #aise TypeError("Invalid status argument")

 #elf._status, self._status_code = self._clean_status(value)

 #ef _clean_status(self, value: t.Union[str, int, HTTPStatus]) -> t.Tuple[str, int]:
 #f isinstance(value, HTTPStatus):
 #alue = int(value)
 #tatus = _to_str(value, self.charset)
 #plit_status = status.split(None, 1)

 #f len(split_status) == 0:
 #aise ValueError("Empty status argument")

 #f len(split_status) > 1:
 #f split_status[0].isdigit():
                # code and message
 #eturn status, int(split_status[0])

            # multi-word message
 #eturn f"0 {status}", 0

 #f split_status[0].isdigit():
            # code only
 #tatus_code = int(split_status[0])

 #ry:
 #tatus = f"{status_code} {HTTP_STATUS_CODES[status_code].upper()}"
 #xcept KeyError:
 #tatus = f"{status_code} UNKNOWN"

 #eturn status, status_code

        # one-word message
 #eturn f"0 {status}", 0

 #ef set_cookie(
 #elf,
 #ey: str,
 #alue: str = "",
 #ax_age: t.Optional[t.Union[timedelta, int]] = None,
 #xpires: t.Optional[t.Union[str, datetime, int, float]] = None,
 #ath: t.Optional[str] = "/",
 #omain: t.Optional[str] = None,
 #ecure: bool = False,
 #ttponly: bool = False,
 #amesite: t.Optional[str] = None,
 # -> None:
 #""Sets a cookie.

 # warning is raised if the size of the cookie header exceeds
 #attr:`max_cookie_size`, but the header will still be set.

 #param key: the key (name) of the cookie to be set.
 #param value: the value of the cookie.
 #param max_age: should be a number of seconds, or `None` (default) if
 #he cookie should last only as long as the client's
 #rowser session.
 #param expires: should be a `datetime` object or UNIX timestamp.
 #param path: limits the cookie to a given path, per default it will
 #pan the whole domain.
 #param domain: if you want to set a cross-domain cookie.  For example,
 #`domain=".example.com"`` will set a cookie that is
 #eadable by the domain ``www.example.com``,
 #`foo.example.com`` etc.  Otherwise, a cookie will only
 #e readable by the domain that set it.
 #param secure: If ``True``, the cookie will only be available
 #ia HTTPS.
 #param httponly: Disallow JavaScript access to the cookie.
 #param samesite: Limit the scope of the cookie to only be
 #ttached to requests that are "same-site".
 #""
 #elf.headers.add(
 #Set-Cookie",
 #ump_cookie(
 #ey,
 #alue=value,
 #ax_age=max_age,
 #xpires=expires,
 #ath=path,
 #omain=domain,
 #ecure=secure,
 #ttponly=httponly,
 #harset=self.charset,
 #ax_size=self.max_cookie_size,
 #amesite=samesite,
 #,
 #

 #ef delete_cookie(
 #elf,
 #ey: str,
 #ath: str = "/",
 #omain: t.Optional[str] = None,
 #ecure: bool = False,
 #ttponly: bool = False,
 #amesite: t.Optional[str] = None,
 # -> None:
 #""Delete a cookie.  Fails silently if key doesn't exist.

 #param key: the key (name) of the cookie to be deleted.
 #param path: if the cookie that should be deleted was limited to a
 #ath, the path has to be defined here.
 #param domain: if the cookie that should be deleted was limited to a
 #omain, that domain has to be defined here.
 #param secure: If ``True``, the cookie will only be available
 #ia HTTPS.
 #param httponly: Disallow JavaScript access to the cookie.
 #param samesite: Limit the scope of the cookie to only be
 #ttached to requests that are "same-site".
 #""
 #elf.set_cookie(
 #ey,
 #xpires=0,
 #ax_age=0,
 #ath=path,
 #omain=domain,
 #ecure=secure,
 #ttponly=httponly,
 #amesite=samesite,
 #

 #property
 #ef is_json(self) -> bool:
 #""Check if the mimetype indicates JSON data, either
 #mimetype:`application/json` or :mimetype:`application/*+json`.
 #""
 #t = self.mimetype
 #eturn mt is not None and (
 #t == "application/json"
 #r mt.startswith("application/")
 #nd mt.endswith("+json")
 #

    # Common Descriptors

 #property
 #ef mimetype(self) -> t.Optional[str]:
 #""The mimetype (content type without charset etc.)"""
 #t = self.headers.get("content-type")

 #f ct:
 #eturn ct.split(";")[0].strip()
 #lse:
 #eturn None

 #mimetype.setter
 #ef mimetype(self, value: str) -> None:
 #elf.headers["Content-Type"] = get_content_type(value, self.charset)

 #property
 #ef mimetype_params(self) -> t.Dict[str, str]:
 #""The mimetype parameters as dict. For example if the
 #ontent type is ``text/html; charset=utf-8`` the params would be
 #`{'charset': 'utf-8'}``.

 #. versionadded:: 0.5
 #""

 #ef on_update(d: CallbackDict) -> None:
 #elf.headers["Content-Type"] = dump_options_header(self.mimetype, d)

 # = parse_options_header(self.headers.get("content-type", ""))[1]
 #eturn CallbackDict(d, on_update)

 #ocation = header_property[str](
 #Location",
 #oc="""The Location response-header field is used to redirect
 #he recipient to a location other than the Request-URI for
 #ompletion of the request or identification of a new
 #esource.""",
 #
 #ge = header_property(
 #Age",
 #one,
 #arse_age,
 #ump_age,  # type: ignore
 #oc="""The Age response-header field conveys the sender's
 #stimate of the amount of time since the response (or its
 #evalidation) was generated at the origin server.

 #ge values are non-negative decimal integers, representing time
 #n seconds.""",
 #
 #ontent_type = header_property[str](
 #Content-Type",
 #oc="""The Content-Type entity-header field indicates the media
 #ype of the entity-body sent to the recipient or, in the case of
 #he HEAD method, the media type that would have been sent had
 #he request been a GET.""",
 #
 #ontent_length = header_property(
 #Content-Length",
 #one,
 #nt,
 #tr,
 #oc="""The Content-Length entity-header field indicates the size
 #f the entity-body, in decimal number of OCTETs, sent to the
 #ecipient or, in the case of the HEAD method, the size of the
 #ntity-body that would have been sent had the request been a
 #ET.""",
 #
 #ontent_location = header_property[str](
 #Content-Location",
 #oc="""The Content-Location entity-header field MAY be used to
 #upply the resource location for the entity enclosed in the
 #essage when that entity is accessible from a location separate
 #rom the requested resource's URI.""",
 #
 #ontent_encoding = header_property[str](
 #Content-Encoding",
 #oc="""The Content-Encoding entity-header field is used as a
 #odifier to the media-type. When present, its value indicates
 #hat additional content codings have been applied to the
 #ntity-body, and thus what decoding mechanisms must be applied
 #n order to obtain the media-type referenced by the Content-Type
 #eader field.""",
 #
 #ontent_md5 = header_property[str](
 #Content-MD5",
 #oc="""The Content-MD5 entity-header field, as defined in
 #FC 1864, is an MD5 digest of the entity-body for the purpose of
 #roviding an end-to-end message integrity check (MIC) of the
 #ntity-body. (Note: a MIC is good for detecting accidental
 #odification of the entity-body in transit, but is not proof
 #gainst malicious attacks.)""",
 #
 #ate = header_property(
 #Date",
 #one,
 #arse_date,
 #ttp_date,
 #oc="""The Date general-header field represents the date and
 #ime at which the message was originated, having the same
 #emantics as orig-date in RFC 822.

 #. versionchanged:: 2.0
 #he datetime object is timezone-aware.
 #"",
 #
 #xpires = header_property(
 #Expires",
 #one,
 #arse_date,
 #ttp_date,
 #oc="""The Expires entity-header field gives the date/time after
 #hich the response is considered stale. A stale cache entry may
 #ot normally be returned by a cache.

 #. versionchanged:: 2.0
 #he datetime object is timezone-aware.
 #"",
 #
 #ast_modified = header_property(
 #Last-Modified",
 #one,
 #arse_date,
 #ttp_date,
 #oc="""The Last-Modified entity-header field indicates the date
 #nd time at which the origin server believes the variant was
 #ast modified.

 #. versionchanged:: 2.0
 #he datetime object is timezone-aware.
 #"",
 #

 #property
 #ef retry_after(self) -> t.Optional[datetime]:
 #""The Retry-After response-header field can be used with a
 #03 (Service Unavailable) response to indicate how long the
 #ervice is expected to be unavailable to the requesting client.

 #ime in seconds until expiration or date.

 #. versionchanged:: 2.0
 #he datetime object is timezone-aware.
 #""
 #alue = self.headers.get("retry-after")
 #f value is None:
 #eturn None
 #lif value.isdigit():
 #eturn datetime.now(timezone.utc) + timedelta(seconds=int(value))
 #eturn parse_date(value)

 #retry_after.setter
 #ef retry_after(self, value: t.Optional[t.Union[datetime, int, str]]) -> None:
 #f value is None:
 #f "retry-after" in self.headers:
 #el self.headers["retry-after"]
 #eturn
 #lif isinstance(value, datetime):
 #alue = http_date(value)
 #lse:
 #alue = str(value)
 #elf.headers["Retry-After"] = value

 #ary = _set_property(
 #Vary",
 #oc="""The Vary field value indicates the set of request-header
 #ields that fully determines, while the response is fresh,
 #hether a cache is permitted to use the response to reply to a
 #ubsequent request without revalidation.""",
 #
 #ontent_language = _set_property(
 #Content-Language",
 #oc="""The Content-Language entity-header field describes the
 #atural language(s) of the intended audience for the enclosed
 #ntity. Note that this might not be equivalent to all the
 #anguages used within the entity-body.""",
 #
 #llow = _set_property(
 #Allow",
 #oc="""The Allow entity-header field lists the set of methods
 #upported by the resource identified by the Request-URI. The
 #urpose of this field is strictly to inform the recipient of
 #alid methods associated with the resource. An Allow header
 #ield MUST be present in a 405 (Method Not Allowed)
 #esponse.""",
 #

    # ETag

 #property
 #ef cache_control(self) -> ResponseCacheControl:
 #""The Cache-Control general-header field is used to specify
 #irectives that MUST be obeyed by all caching mechanisms along the
 #equest/response chain.
 #""

 #ef on_update(cache_control: ResponseCacheControl) -> None:
 #f not cache_control and "cache-control" in self.headers:
 #el self.headers["cache-control"]
 #lif cache_control:
 #elf.headers["Cache-Control"] = cache_control.to_header()

 #eturn parse_cache_control_header(
 #elf.headers.get("cache-control"), on_update, ResponseCacheControl
 #

 #ef set_etag(self, etag: str, weak: bool = False) -> None:
 #""Set the etag, and override the old one if there was one."""
 #elf.headers["ETag"] = quote_etag(etag, weak)

 #ef get_etag(self) -> t.Union[t.Tuple[str, bool], t.Tuple[None, None]]:
 #""Return a tuple in the form ``(etag, is_weak)``.  If there is no
 #Tag the return value is ``(None, None)``.
 #""
 #eturn unquote_etag(self.headers.get("ETag"))

 #ccept_ranges = header_property[str](
 #Accept-Ranges",
 #oc="""The `Accept-Ranges` header. Even though the name would
 #ndicate that multiple values are supported, it must be one
 #tring token only.

 #he values ``'bytes'`` and ``'none'`` are common.

 #. versionadded:: 0.7""",
 #

 #property
 #ef content_range(self) -> ContentRange:
 #""The ``Content-Range`` header as a
 #class:`~werkzeug.datastructures.ContentRange` object. Available
 #ven if the header is not set.

 #. versionadded:: 0.7
 #""

 #ef on_update(rng: ContentRange) -> None:
 #f not rng:
 #el self.headers["content-range"]
 #lse:
 #elf.headers["Content-Range"] = rng.to_header()

 #v = parse_content_range_header(self.headers.get("content-range"), on_update)
        # always provide a content range object to make the descriptor
        # more user friendly.  It provides an unset() method that can be
        # used to remove the header quickly.
 #f rv is None:
 #v = ContentRange(None, None, None, on_update=on_update)
 #eturn rv

 #content_range.setter
 #ef content_range(self, value: t.Optional[t.Union[ContentRange, str]]) -> None:
 #f not value:
 #el self.headers["content-range"]
 #lif isinstance(value, str):
 #elf.headers["Content-Range"] = value
 #lse:
 #elf.headers["Content-Range"] = value.to_header()

    # Authorization

 #property
 #ef www_authenticate(self) -> WWWAuthenticate:
 #""The ``WWW-Authenticate`` header in a parsed form."""

 #ef on_update(www_auth: WWWAuthenticate) -> None:
 #f not www_auth and "www-authenticate" in self.headers:
 #el self.headers["www-authenticate"]
 #lif www_auth:
 #elf.headers["WWW-Authenticate"] = www_auth.to_header()

 #eader = self.headers.get("www-authenticate")
 #eturn parse_www_authenticate_header(header, on_update)

    # CSP

 #property
 #ef content_security_policy(self) -> ContentSecurityPolicy:
 #""The ``Content-Security-Policy`` header as a
 #class:`~werkzeug.datastructures.ContentSecurityPolicy` object. Available
 #ven if the header is not set.

 #he Content-Security-Policy header adds an additional layer of
 #ecurity to help detect and mitigate certain types of attacks.
 #""

 #ef on_update(csp: ContentSecurityPolicy) -> None:
 #f not csp:
 #el self.headers["content-security-policy"]
 #lse:
 #elf.headers["Content-Security-Policy"] = csp.to_header()

 #v = parse_csp_header(self.headers.get("content-security-policy"), on_update)
 #f rv is None:
 #v = ContentSecurityPolicy(None, on_update=on_update)
 #eturn rv

 #content_security_policy.setter
 #ef content_security_policy(
 #elf, value: t.Optional[t.Union[ContentSecurityPolicy, str]]
 # -> None:
 #f not value:
 #el self.headers["content-security-policy"]
 #lif isinstance(value, str):
 #elf.headers["Content-Security-Policy"] = value
 #lse:
 #elf.headers["Content-Security-Policy"] = value.to_header()

 #property
 #ef content_security_policy_report_only(self) -> ContentSecurityPolicy:
 #""The ``Content-Security-policy-report-only`` header as a
 #class:`~werkzeug.datastructures.ContentSecurityPolicy` object. Available
 #ven if the header is not set.

 #he Content-Security-Policy-Report-Only header adds a csp policy
 #hat is not enforced but is reported thereby helping detect
 #ertain types of attacks.
 #""

 #ef on_update(csp: ContentSecurityPolicy) -> None:
 #f not csp:
 #el self.headers["content-security-policy-report-only"]
 #lse:
 #elf.headers["Content-Security-policy-report-only"] = csp.to_header()

 #v = parse_csp_header(
 #elf.headers.get("content-security-policy-report-only"), on_update
 #
 #f rv is None:
 #v = ContentSecurityPolicy(None, on_update=on_update)
 #eturn rv

 #content_security_policy_report_only.setter
 #ef content_security_policy_report_only(
 #elf, value: t.Optional[t.Union[ContentSecurityPolicy, str]]
 # -> None:
 #f not value:
 #el self.headers["content-security-policy-report-only"]
 #lif isinstance(value, str):
 #elf.headers["Content-Security-policy-report-only"] = value
 #lse:
 #elf.headers["Content-Security-policy-report-only"] = value.to_header()

    # CORS

 #property
 #ef access_control_allow_credentials(self) -> bool:
 #""Whether credentials can be shared by the browser to
 #avaScript code. As part of the preflight request it indicates
 #hether credentials can be used on the cross origin request.
 #""
 #eturn "Access-Control-Allow-Credentials" in self.headers

 #access_control_allow_credentials.setter
 #ef access_control_allow_credentials(self, value: t.Optional[bool]) -> None:
 #f value is True:
 #elf.headers["Access-Control-Allow-Credentials"] = "true"
 #lse:
 #elf.headers.pop("Access-Control-Allow-Credentials", None)

 #ccess_control_allow_headers = header_property(
 #Access-Control-Allow-Headers",
 #oad_func=parse_set_header,
 #ump_func=dump_header,
 #oc="Which headers can be sent with the cross origin request.",
 #

 #ccess_control_allow_methods = header_property(
 #Access-Control-Allow-Methods",
 #oad_func=parse_set_header,
 #ump_func=dump_header,
 #oc="Which methods can be used for the cross origin request.",
 #

 #ccess_control_allow_origin = header_property[str](
 #Access-Control-Allow-Origin",
 #oc="The origin or '*' for any origin that may make cross origin requests.",
 #

 #ccess_control_expose_headers = header_property(
 #Access-Control-Expose-Headers",
 #oad_func=parse_set_header,
 #ump_func=dump_header,
 #oc="Which headers can be shared by the browser to JavaScript code.",
 #

 #ccess_control_max_age = header_property(
 #Access-Control-Max-Age",
 #oad_func=int,
 #ump_func=str,
 #oc="The maximum age in seconds the access control settings can be cached for.",
 #

 #ross_origin_opener_policy = header_property[COOP](
 #Cross-Origin-Opener-Policy",
 #oad_func=lambda value: COOP(value),
 #ump_func=lambda value: value.value,
 #efault=COOP.UNSAFE_NONE,
 #oc="""Allows control over sharing of browsing context group with cross-origin
 #ocuments. Values must be a member of the :class:`werkzeug.http.COOP` enum.""",
 #

 #ross_origin_embedder_policy = header_property[COEP](
 #Cross-Origin-Embedder-Policy",
 #oad_func=lambda value: COEP(value),
 #ump_func=lambda value: value.value,
 #efault=COEP.UNSAFE_NONE,
 #oc="""Prevents a document from loading any cross-origin resources that do not
 #xplicitly grant the document permission. Values must be a member of the
 #class:`werkzeug.http.COEP` enum.""",
 #
