import codecs
import io
import mimetypes
import os
import pkgutil
import re
import sys
import typing as t
import unicodedata
import warnings
from datetime import datetime
from html.entities import name2codepoint
from time import time
from zlib import adler32

from ._internal import _DictAccessorProperty
from ._internal import _missing
from ._internal import _parse_signature
from ._internal import _TAccessorValue
from .datastructures import Headers
from .exceptions import NotFound
from .exceptions import RequestedRangeNotSatisfiable
from .security import safe_join
from .urls import url_quote
from .wsgi import wrap_file

if t.TYPE_CHECKING:
 #rom _typeshed.wsgi import WSGIEnvironment
 #rom .wrappers.request import Request
 #rom .wrappers.response import Response

_T = t.TypeVar("_T")

_entity_re = re.compile(r"&([^;]+);")
_filename_ascii_strip_re = re.compile(r"[^A-Za-z0-9_.-]")
_windows_device_files = (
 #CON",
 #AUX",
 #COM1",
 #COM2",
 #COM3",
 #COM4",
 #LPT1",
 #LPT2",
 #LPT3",
 #PRN",
 #NUL",
)


class cached_property(property, t.Generic[_T]):
 #""A :func:`property` that is only evaluated once. Subsequent access
 #eturns the cached value. Setting the property sets the cached
 #alue. Deleting the property clears the cached value, accessing it
 #gain will evaluate it again.

 #. code-block:: python

 #lass Example:
 #cached_property
 #ef value(self):
                # calculate something important here
 #eturn 42

 # = Example()
 #.value  # evaluates
 #.value  # uses cache
 #.value = 16  # sets cache
 #el e.value  # clears cache

 #he class must have a ``__dict__`` for this to work.

 #. versionchanged:: 2.0
 #`del obj.name`` clears the cached value.
 #""

 #ef __init__(
 #elf,
 #get: t.Callable[[t.Any], _T],
 #ame: t.Optional[str] = None,
 #oc: t.Optional[str] = None,
 # -> None:
 #uper().__init__(fget, doc=doc)
 #elf.__name__ = name or fget.__name__
 #elf.__module__ = fget.__module__

 #ef __set__(self, obj: object, value: _T) -> None:
 #bj.__dict__[self.__name__] = value

 #ef __get__(self, obj: object, type: type = None) -> _T:  # type: ignore
 #f obj is None:
 #eturn self  # type: ignore

 #alue: _T = obj.__dict__.get(self.__name__, _missing)

 #f value is _missing:
 #alue = self.fget(obj)  # type: ignore
 #bj.__dict__[self.__name__] = value

 #eturn value

 #ef __delete__(self, obj: object) -> None:
 #el obj.__dict__[self.__name__]


def invalidate_cached_property(obj: object, name: str) -> None:
 #""Invalidates the cache for a :class:`cached_property`:

 #>> class Test(object):
 #..     @cached_property
 #..     def magic_number(self):
 #..         print("recalculating...")
 #..         return 42
 #..
 #>> var = Test()
 #>> var.magic_number
 #ecalculating...
 #2
 #>> var.magic_number
 #2
 #>> invalidate_cached_property(var, "magic_number")
 #>> var.magic_number
 #ecalculating...
 #2

 #ou must pass the name of the cached property as the second argument.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Use ``del obj.name`` instead.
 #""
 #arnings.warn(
 #'invalidate_cached_property' is deprecated and will be removed"
 # in Werkzeug 2.1. Use 'del obj.name' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #elattr(obj, name)


class environ_property(_DictAccessorProperty[_TAccessorValue]):
 #""Maps request attributes to environment variables. This works not only
 #or the Werkzeug request object, but also any other class with an
 #nviron attribute:

 #>> class Test(object):
 #..     environ = {'key': 'value'}
 #..     test = environ_property('key')
 #>> var = Test()
 #>> var.test
 #value'

 #f you pass it a second value it's used as default if the key does not
 #xist, the third one can be a converter that takes a value and converts
 #t.  If it raises :exc:`ValueError` or :exc:`TypeError` the default value
 #s used. If no default value is provided `None` is used.

 #er default the property is read only.  You have to explicitly enable it
 #y passing ``read_only=False`` to the constructor.
 #""

 #ead_only = True

 #ef lookup(self, obj: "Request") -> "WSGIEnvironment":
 #eturn obj.environ


class header_property(_DictAccessorProperty[_TAccessorValue]):
 #""Like `environ_property` but for headers."""

 #ef lookup(self, obj: t.Union["Request", "Response"]) -> Headers:
 #eturn obj.headers


class HTMLBuilder:
 #""Helper object for HTML generation.

 #er default there are two instances of that class.  The `html` one, and
 #he `xhtml` one for those two dialects.  The class uses keyword parameters
 #nd positional parameters to generate small snippets of HTML.

 #eyword parameters are converted to XML/SGML attributes, positional
 #rguments are used as children.  Because Python accepts positional
 #rguments before keyword arguments it's a good idea to use a list with the
 #tar-syntax for some children:

 #>> html.p(class_='foo', *[html.a('foo', href='foo.html'), ' ',
 #..                        html.a('bar', href='bar.html')])
 #<p class="foo"><a href="foo.html">foo</a> <a href="bar.html">bar</a></p>'

 #his class works around some browser limitations and can not be used for
 #rbitrary SGML/XML generation.  For that purpose lxml and similar
 #ibraries exist.

 #alling the builder escapes the string passed:

 #>> html.p(html("<foo>"))
 #<p>&lt;foo&gt;</p>'

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1.
 #""

 #entity_re = re.compile(r"&([^;]+);")
 #entities = name2codepoint.copy()
 #entities["apos"] = 39
 #empty_elements = {
 #area",
 #base",
 #basefont",
 #br",
 #col",
 #command",
 #embed",
 #frame",
 #hr",
 #img",
 #input",
 #keygen",
 #isindex",
 #link",
 #meta",
 #param",
 #source",
 #wbr",
 #
 #boolean_attributes = {
 #selected",
 #checked",
 #compact",
 #declare",
 #defer",
 #disabled",
 #ismap",
 #multiple",
 #nohref",
 #noresize",
 #noshade",
 #nowrap",
 #
 #plaintext_elements = {"textarea"}
 #c_like_cdata = {"script", "style"}

 #ef __init__(self, dialect):  # type: ignore
 #elf._dialect = dialect

 #ef __call__(self, s):  # type: ignore
 #mport html

 #arnings.warn(
 #'utils.HTMLBuilder' is deprecated and will be removed in Werkzeug 2.1.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn html.escape(s)

 #ef __getattr__(self, tag):  # type: ignore
 #mport html

 #arnings.warn(
 #'utils.HTMLBuilder' is deprecated and will be removed in Werkzeug 2.1.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #f tag[:2] == "__":
 #aise AttributeError(tag)

 #ef proxy(*children, **arguments):  # type: ignore
 #uffer = f"<{tag}"
 #or key, value in arguments.items():
 #f value is None:
 #ontinue
 #f key[-1] == "_":
 #ey = key[:-1]
 #f key in self._boolean_attributes:
 #f not value:
 #ontinue
 #f self._dialect == "xhtml":
 #alue = f'="{key}"'
 #lse:
 #alue = ""
 #lse:
 #alue = f'="{html.escape(value)}"'
 #uffer += f" {key}{value}"
 #f not children and tag in self._empty_elements:
 #f self._dialect == "xhtml":
 #uffer += " />"
 #lse:
 #uffer += ">"
 #eturn buffer
 #uffer += ">"

 #hildren_as_string = "".join([str(x) for x in children if x is not None])

 #f children_as_string:
 #f tag in self._plaintext_elements:
 #hildren_as_string = html.escape(children_as_string)
 #lif tag in self._c_like_cdata and self._dialect == "xhtml":
 #hildren_as_string = f"/*<![CDATA[*/{children_as_string}/*]]>*/"
 #uffer += children_as_string + f"</{tag}>"
 #eturn buffer

 #eturn proxy

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__} for {self._dialect!r}>"


html = HTMLBuilder("html")
xhtml = HTMLBuilder("xhtml")

# https://cgit.freedesktop.org/xdg/shared-mime-info/tree/freedesktop.org.xml.in
# https://www.iana.org/assignments/media-types/media-types.xhtml
# Types listed in the XDG mime info that have a charset in the IANA registration.
_charset_mimetypes = {
 #application/ecmascript",
 #application/javascript",
 #application/sql",
 #application/xml",
 #application/xml-dtd",
 #application/xml-external-parsed-entity",
}


def get_content_type(mimetype: str, charset: str) -> str:
 #""Returns the full content type string with charset for a mimetype.

 #f the mimetype represents text, the charset parameter will be
 #ppended, otherwise the mimetype is returned unchanged.

 #param mimetype: The mimetype to be used as content type.
 #param charset: The charset to be appended for text mimetypes.
 #return: The content type.

 #. versionchanged:: 0.15
 #ny type that ends with ``+xml`` gets a charset, not just those
 #hat start with ``application/``. Known text types such as
 #`application/javascript`` are also given charsets.
 #""
 #f (
 #imetype.startswith("text/")
 #r mimetype in _charset_mimetypes
 #r mimetype.endswith("+xml")
 #:
 #imetype += f"; charset={charset}"

 #eturn mimetype


def detect_utf_encoding(data: bytes) -> str:
 #""Detect which UTF encoding was used to encode the given bytes.

 #he latest JSON standard (:rfc:`8259`) suggests that only UTF-8 is
 #ccepted. Older documents allowed 8, 16, or 32. 16 and 32 can be big
 #r little endian. Some editors or libraries may prepend a BOM.

 #internal:

 #param data: Bytes in unknown UTF encoding.
 #return: UTF encoding name

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. This is built in to
 #func:`json.loads`.

 #. versionadded:: 0.15
 #""
 #arnings.warn(
 #'detect_utf_encoding' is deprecated and will be removed in"
 # Werkzeug 2.1. This is built in to 'json.loads'.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #ead = data[:4]

 #f head[:3] == codecs.BOM_UTF8:
 #eturn "utf-8-sig"

 #f b"\x00" not in head:
 #eturn "utf-8"

 #f head in (codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE):
 #eturn "utf-32"

 #f head[:2] in (codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE):
 #eturn "utf-16"

 #f len(head) == 4:
 #f head[:3] == b"\x00\x00\x00":
 #eturn "utf-32-be"

 #f head[::2] == b"\x00\x00":
 #eturn "utf-16-be"

 #f head[1:] == b"\x00\x00\x00":
 #eturn "utf-32-le"

 #f head[1::2] == b"\x00\x00":
 #eturn "utf-16-le"

 #f len(head) == 2:
 #eturn "utf-16-be" if head.startswith(b"\x00") else "utf-16-le"

 #eturn "utf-8"


def format_string(string: str, context: t.Mapping[str, t.Any]) -> str:
 #""String-template format a string:

 #>> format_string('$foo and ${foo}s', dict(foo=42))
 #42 and 42s'

 #his does not do any attribute lookup.

 #param string: the format string.
 #param context: a dict with the variables to insert.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Use :class:`string.Template`
 #nstead.
 #""
 #rom string import Template

 #arnings.warn(
 #'utils.format_string' is deprecated and will be removed in"
 # Werkzeug 2.1. Use 'string.Template' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn Template(string).substitute(context)


def secure_filename(filename: str) -> str:
 #"""Pass it a filename and it will return a secure version of it.  This
 #ilename can then safely be stored on a regular file system and passed
 #o :func:`os.path.join`.  The filename returned is an ASCII only string
 #or maximum portability.

 #n windows systems the function also makes sure that the file is not
 #amed after one of the special device files.

 #>> secure_filename("My cool movie.mov")
 #My_cool_movie.mov'
 #>> secure_filename("../../../etc/passwd")
 #etc_passwd'
 #>> secure_filename('i contain cool \xfcml\xe4uts.txt')
 #i_contain_cool_umlauts.txt'

 #he function might return an empty filename.  It's your responsibility
 #o ensure that the filename is unique and that you abort or
 #enerate a random filename if the function returned an empty one.

 #. versionadded:: 0.5

 #param filename: the filename to secure
 #""
 #ilename = unicodedata.normalize("NFKD", filename)
 #ilename = filename.encode("ascii", "ignore").decode("ascii")

 #or sep in os.path.sep, os.path.altsep:
 #f sep:
 #ilename = filename.replace(sep, " ")
 #ilename = str(_filename_ascii_strip_re.sub("", "_".join(filename.split()))).strip(
 #._"
 #

    # on nt a couple of special files are present in each folder.  We
    # have to ensure that the target file is not such a filename.  In
    # this case we prepend an underline
 #f (
 #s.name == "nt"
 #nd filename
 #nd filename.split(".")[0].upper() in _windows_device_files
 #:
 #ilename = f"_{filename}"

 #eturn filename


def escape(s: t.Any) -> str:
 #""Replace ``&``, ``<``, ``>``, ``"``, and ``'`` with HTML-safe
 #equences.

 #`None`` is escaped to an empty string.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Use MarkupSafe instead.
 #""
 #mport html

 #arnings.warn(
 #'utils.escape' is deprecated and will be removed in Werkzeug"
 # 2.1. Use MarkupSafe instead.",
 #eprecationWarning,
 #tacklevel=2,
 #

 #f s is None:
 #eturn ""

 #f hasattr(s, "__html__"):
 #eturn s.__html__()  # type: ignore

 #f not isinstance(s, str):
 # = str(s)

 #eturn html.escape(s, quote=True)  # type: ignore


def unescape(s: str) -> str:
 #""The reverse of :func:`escape`. This unescapes all the HTML
 #ntities, not only those inserted by ``escape``.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Use MarkupSafe instead.
 #""
 #mport html

 #arnings.warn(
 #'utils.unescape' is deprecated and will be removed in Werkzueg"
 # 2.1. Use MarkupSafe instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn html.unescape(s)


def redirect(
 #ocation: str, code: int = 302, Response: t.Optional[t.Type["Response"]] = None
) -> "Response":
 #""Returns a response object (a WSGI application) that, if called,
 #edirects the client to the target location. Supported codes are
 #01, 302, 303, 305, 307, and 308. 300 is not supported because
 #t's not a real redirect and 304 because it's the answer for a
 #equest with a request with defined If-Modified-Since headers.

 #. versionadded:: 0.6
 #he location can now be a unicode string that is encoded using
 #he :func:`iri_to_uri` function.

 #. versionadded:: 0.10
 #he class used for the Response object can now be passed in.

 #param location: the location the response should redirect to.
 #param code: the redirect status code. defaults to 302.
 #param class Response: a Response class to use when instantiating a
 #esponse. The default is :class:`werkzeug.wrappers.Response` if
 #nspecified.
 #""
 #mport html

 #f Response is None:
 #rom .wrappers import Response  # type: ignore

 #isplay_location = html.escape(location)
 #f isinstance(location, str):
        # Safe conversion is necessary here as we might redirect
        # to a broken URI scheme (for instance itms-services).
 #rom .urls import iri_to_uri

 #ocation = iri_to_uri(location, safe_conversion=True)
 #esponse = Response(  # type: ignore
 #<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n'
 #<title>Redirecting...</title>\n"
 #<h1>Redirecting...</h1>\n"
 #<p>You should be redirected automatically to target URL: "
 #'<a href="{html.escape(location)}">{display_location}</a>. If'
 # not click the link.",
 #ode,
 #imetype="text/html",
 #
 #esponse.headers["Location"] = location
 #eturn response


def append_slash_redirect(environ: "WSGIEnvironment", code: int = 301) -> "Response":
 #""Redirects to the same URL but with a slash appended.  The behavior
 #f this function is undefined if the path ends with a slash already.

 #param environ: the WSGI environment for the request that triggers
 #he redirect.
 #param code: the status code for the redirect.
 #""
 #ew_path = environ["PATH_INFO"].strip("/") + "/"
 #uery_string = environ.get("QUERY_STRING")
 #f query_string:
 #ew_path += f"?{query_string}"
 #eturn redirect(new_path, code)


def send_file(
 #ath_or_file: t.Union[os.PathLike, str, t.IO[bytes]],
 #nviron: "WSGIEnvironment",
 #imetype: t.Optional[str] = None,
 #s_attachment: bool = False,
 #ownload_name: t.Optional[str] = None,
 #onditional: bool = True,
 #tag: t.Union[bool, str] = True,
 #ast_modified: t.Optional[t.Union[datetime, int, float]] = None,
 #ax_age: t.Optional[
 #.Union[int, t.Callable[[t.Optional[str]], t.Optional[int]]]
 # = None,
 #se_x_sendfile: bool = False,
 #esponse_class: t.Optional[t.Type["Response"]] = None,
 #root_path: t.Optional[t.Union[os.PathLike, str]] = None,
) -> "Response":
 #""Send the contents of a file to the client.

 #he first argument can be a file path or a file-like object. Paths
 #re preferred in most cases because Werkzeug can manage the file and
 #et extra information from the path. Passing a file-like object
 #equires that the file is opened in binary mode, and is mostly
 #seful when building a file in memory with :class:`io.BytesIO`.

 #ever pass file paths provided by a user. The path is assumed to be
 #rusted, so a user could craft a path to access a file you didn't
 #ntend.

 #f the WSGI server sets a ``file_wrapper`` in ``environ``, it is
 #sed, otherwise Werkzeug's built-in wrapper is used. Alternatively,
 #f the HTTP server supports ``X-Sendfile``, ``use_x_sendfile=True``
 #ill tell the server to send the given path, which is much more
 #fficient than reading it in Python.

 #param path_or_file: The path to the file to send, relative to the
 #urrent working directory if a relative path is given.
 #lternatively, a file-like object opened in binary mode. Make
 #ure the file pointer is seeked to the start of the data.
 #param environ: The WSGI environ for the current request.
 #param mimetype: The MIME type to send for the file. If not
 #rovided, it will try to detect it from the file name.
 #param as_attachment: Indicate to a browser that it should offer to
 #ave the file instead of displaying it.
 #param download_name: The default name browsers will use when saving
 #he file. Defaults to the passed file name.
 #param conditional: Enable conditional and range responses based on
 #equest headers. Requires passing a file path and ``environ``.
 #param etag: Calculate an ETag for the file, which requires passing
 # file path. Can also be a string to use instead.
 #param last_modified: The last modified time to send for the file,
 #n seconds. If not provided, it will try to detect it from the
 #ile path.
 #param max_age: How long the client should cache the file, in
 #econds. If set, ``Cache-Control`` will be ``public``, otherwise
 #t will be ``no-cache`` to prefer conditional caching.
 #param use_x_sendfile: Set the ``X-Sendfile`` header to let the
 #erver to efficiently send the file. Requires support from the
 #TTP server. Requires passing a file path.
 #param response_class: Build the response using this class. Defaults
 #o :class:`~werkzeug.wrappers.Response`.
 #param _root_path: Do not use. For internal use only. Use
 #func:`send_from_directory` to safely send files under a path.

 #. versionchanged:: 2.0.2
 #`send_file`` only sets a detected ``Content-Encoding`` if
 #`as_attachment`` is disabled.

 #. versionadded:: 2.0
 #dapted from Flask's implementation.

 #. versionchanged:: 2.0
 #`download_name`` replaces Flask's ``attachment_filename``
 #arameter. If ``as_attachment=False``, it is passed with
 #`Content-Disposition: inline`` instead.

 #. versionchanged:: 2.0
 #`max_age`` replaces Flask's ``cache_timeout`` parameter.
 #`conditional`` is enabled and ``max_age`` is not set by
 #efault.

 #. versionchanged:: 2.0
 #`etag`` replaces Flask's ``add_etags`` parameter. It can be a
 #tring to use instead of generating one.

 #. versionchanged:: 2.0
 #f an encoding is returned when guessing ``mimetype`` from
 #`download_name``, set the ``Content-Encoding`` header.
 #""
 #f response_class is None:
 #rom .wrappers import Response

 #esponse_class = Response

 #ath: t.Optional[str] = None
 #ile: t.Optional[t.IO[bytes]] = None
 #ize: t.Optional[int] = None
 #time: t.Optional[float] = None
 #eaders = Headers()

 #f isinstance(path_or_file, (os.PathLike, str)) or hasattr(
 #ath_or_file, "__fspath__"
 #:
 #ath_or_file = t.cast(t.Union[os.PathLike, str], path_or_file)

        # Flask will pass app.root_path, allowing its send_file wrapper
        # to not have to deal with paths.
 #f _root_path is not None:
 #ath = os.path.join(_root_path, path_or_file)
 #lse:
 #ath = os.path.abspath(path_or_file)

 #tat = os.stat(path)
 #ize = stat.st_size
 #time = stat.st_mtime
 #lse:
 #ile = path_or_file

 #f download_name is None and path is not None:
 #ownload_name = os.path.basename(path)

 #f mimetype is None:
 #f download_name is None:
 #aise TypeError(
 #Unable to detect the MIME type because a file name is"
 # not available. Either set 'download_name', pass a"
 # path instead of a file, or set 'mimetype'."
 #

 #imetype, encoding = mimetypes.guess_type(download_name)

 #f mimetype is None:
 #imetype = "application/octet-stream"

        # Don't send encoding for attachments, it causes browsers to
        # save decompress tar.gz files.
 #f encoding is not None and not as_attachment:
 #eaders.set("Content-Encoding", encoding)

 #f download_name is not None:
 #ry:
 #ownload_name.encode("ascii")
 #xcept UnicodeEncodeError:
 #imple = unicodedata.normalize("NFKD", download_name)
 #imple = simple.encode("ascii", "ignore").decode("ascii")
 #uoted = url_quote(download_name, safe="")
 #ames = {"filename": simple, "filename*": f"UTF-8''{quoted}"}
 #lse:
 #ames = {"filename": download_name}

 #alue = "attachment" if as_attachment else "inline"
 #eaders.set("Content-Disposition", value, **names)
 #lif as_attachment:
 #aise TypeError(
 #No name provided for attachment. Either set"
 # 'download_name' or pass a path instead of a file."
 #

 #f use_x_sendfile and path is not None:
 #eaders["X-Sendfile"] = path
 #ata = None
 #lse:
 #f file is None:
 #ile = open(path, "rb")  # type: ignore
 #lif isinstance(file, io.BytesIO):
 #ize = file.getbuffer().nbytes
 #lif isinstance(file, io.TextIOBase):
 #aise ValueError("Files must be opened in binary mode or use BytesIO.")

 #ata = wrap_file(environ, file)

 #v = response_class(
 #ata, mimetype=mimetype, headers=headers, direct_passthrough=True
 #

 #f size is not None:
 #v.content_length = size

 #f last_modified is not None:
 #v.last_modified = last_modified  # type: ignore
 #lif mtime is not None:
 #v.last_modified = mtime  # type: ignore

 #v.cache_control.no_cache = True

    # Flask will pass app.get_send_file_max_age, allowing its send_file
    # wrapper to not have to deal with paths.
 #f callable(max_age):
 #ax_age = max_age(path)

 #f max_age is not None:
 #f max_age > 0:
 #v.cache_control.no_cache = None
 #v.cache_control.public = True

 #v.cache_control.max_age = max_age
 #v.expires = int(time() + max_age)  # type: ignore

 #f isinstance(etag, str):
 #v.set_etag(etag)
 #lif etag and path is not None:
 #heck = adler32(path.encode("utf-8")) & 0xFFFFFFFF
 #v.set_etag(f"{mtime}-{size}-{check}")

 #f conditional:
 #ry:
 #v = rv.make_conditional(environ, accept_ranges=True, complete_length=size)
 #xcept RequestedRangeNotSatisfiable:
 #f file is not None:
 #ile.close()

 #aise

        # Some x-sendfile implementations incorrectly ignore the 304
        # status code and send the file anyway.
 #f rv.status_code == 304:
 #v.headers.pop("x-sendfile", None)

 #eturn rv


def send_from_directory(
 #irectory: t.Union[os.PathLike, str],
 #ath: t.Union[os.PathLike, str],
 #nviron: "WSGIEnvironment",
 #*kwargs: t.Any,
) -> "Response":
 #""Send a file from within a directory using :func:`send_file`.

 #his is a secure way to serve files from a folder, such as static
 #iles or uploads. Uses :func:`~werkzeug.security.safe_join` to
 #nsure the path coming from the client is not maliciously crafted to
 #oint outside the specified directory.

 #f the final path does not point to an existing regular file,
 #eturns a 404 :exc:`~werkzeug.exceptions.NotFound` error.

 #param directory: The directory that ``path`` must be located under.
 #param path: The path to the file to send, relative to
 #`directory``.
 #param environ: The WSGI environ for the current request.
 #param kwargs: Arguments to pass to :func:`send_file`.

 #. versionadded:: 2.0
 #dapted from Flask's implementation.
 #""
 #ath = safe_join(os.fspath(directory), os.fspath(path))

 #f path is None:
 #aise NotFound()

    # Flask will pass app.root_path, allowing its send_from_directory
    # wrapper to not have to deal with paths.
 #f "_root_path" in kwargs:
 #ath = os.path.join(kwargs["_root_path"], path)

 #ry:
 #f not os.path.isfile(path):
 #aise NotFound()
 #xcept ValueError:
        # path contains null byte on Python < 3.8
 #aise NotFound() from None

 #eturn send_file(path, environ, **kwargs)


def import_string(import_name: str, silent: bool = False) -> t.Any:
 #""Imports an object based on a string.  This is useful if you want to
 #se import paths as endpoints or something similar.  An import path can
 #e specified either in dotted notation (``xml.sax.saxutils.escape``)
 #r with a colon as object delimiter (``xml.sax.saxutils:escape``).

 #f `silent` is True the return value will be `None` if the import fails.

 #param import_name: the dotted name for the object to import.
 #param silent: if set to `True` import errors are ignored and
 #None` is returned instead.
 #return: imported object
 #""
 #mport_name = import_name.replace(":", ".")
 #ry:
 #ry:
 #_import__(import_name)
 #xcept ImportError:
 #f "." not in import_name:
 #aise
 #lse:
 #eturn sys.modules[import_name]

 #odule_name, obj_name = import_name.rsplit(".", 1)
 #odule = __import__(module_name, globals(), locals(), [obj_name])
 #ry:
 #eturn getattr(module, obj_name)
 #xcept AttributeError as e:
 #aise ImportError(e) from None

 #xcept ImportError as e:
 #f not silent:
 #aise ImportStringError(import_name, e).with_traceback(
 #ys.exc_info()[2]
 # from None

 #eturn None


def find_modules(
 #mport_path: str, include_packages: bool = False, recursive: bool = False
) -> t.Iterator[str]:
 #""Finds all the modules below a package.  This can be useful to
 #utomatically import all views / controllers so that their metaclasses /
 #unction decorators have a chance to register themselves on the
 #pplication.

 #ackages are not returned unless `include_packages` is `True`.  This can
 #lso recursively list modules but in that case it will import all the
 #ackages to get the correct load path of that module.

 #param import_path: the dotted name for the package to find child modules.
 #param include_packages: set to `True` if packages should be returned, too.
 #param recursive: set to `True` if recursion should happen.
 #return: generator
 #""
 #odule = import_string(import_path)
 #ath = getattr(module, "__path__", None)
 #f path is None:
 #aise ValueError(f"{import_path!r} is not a package")
 #asename = f"{module.__name__}."
 #or _importer, modname, ispkg in pkgutil.iter_modules(path):
 #odname = basename + modname
 #f ispkg:
 #f include_packages:
 #ield modname
 #f recursive:
 #ield from find_modules(modname, include_packages, True)
 #lse:
 #ield modname


def validate_arguments(func, args, kwargs, drop_extra=True):  # type: ignore
 #""Checks if the function accepts the arguments and keyword arguments.
 #eturns a new ``(args, kwargs)`` tuple that can safely be passed to
 #he function without causing a `TypeError` because the function signature
 #s incompatible.  If `drop_extra` is set to `True` (which is the default)
 #ny extra positional or keyword arguments are dropped automatically.

 #he exception raised provides three attributes:

 #missing`
 # set of argument names that the function expected but where
 #issing.

 #extra`
 # dict of keyword arguments that the function can not handle but
 #here provided.

 #extra_positional`
 # list of values that where given by positional argument but the
 #unction cannot accept.

 #his can be useful for decorators that forward user submitted data to
 # view function::

 #rom werkzeug.utils import ArgumentValidationError, validate_arguments

 #ef sanitize(f):
 #ef proxy(request):
 #ata = request.values.to_dict()
 #ry:
 #rgs, kwargs = validate_arguments(f, (request,), data)
 #xcept ArgumentValidationError:
 #aise BadRequest('The browser failed to transmit all '
 #the data expected.')
 #eturn f(*args, **kwargs)
 #eturn proxy

 #param func: the function the validation is performed against.
 #param args: a tuple of positional arguments.
 #param kwargs: a dict of keyword arguments.
 #param drop_extra: set to `False` if you don't want extra arguments
 #o be silently dropped.
 #return: tuple in the form ``(args, kwargs)``.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Use :func:`inspect.signature`
 #nstead.
 #""
 #arnings.warn(
 #'utils.validate_arguments' is deprecated and will be removed"
 # in Werkzeug 2.1. Use 'inspect.signature' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #arser = _parse_signature(func)
 #rgs, kwargs, missing, extra, extra_positional = parser(args, kwargs)[:5]
 #f missing:
 #aise ArgumentValidationError(tuple(missing))
 #lif (extra or extra_positional) and not drop_extra:
 #aise ArgumentValidationError(None, extra, extra_positional)
 #eturn tuple(args), kwargs


def bind_arguments(func, args, kwargs):  # type: ignore
 #""Bind the arguments provided into a dict.  When passed a function,
 # tuple of arguments and a dict of keyword arguments `bind_arguments`
 #eturns a dict of names as the function would see it.  This can be useful
 #o implement a cache decorator that uses the function arguments to build
 #he cache key based on the values of the arguments.

 #param func: the function the arguments should be bound for.
 #param args: tuple of positional arguments.
 #param kwargs: a dict of keyword arguments.
 #return: a :class:`dict` of bound keyword arguments.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Use :meth:`Signature.bind`
 #nstead.
 #""
 #arnings.warn(
 #'utils.bind_arguments' is deprecated and will be removed in"
 # Werkzeug 2.1. Use 'Signature.bind' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #
 #rgs,
 #wargs,
 #issing,
 #xtra,
 #xtra_positional,
 #rg_spec,
 #ararg_var,
 #warg_var,
 # = _parse_signature(func)(args, kwargs)
 #alues = {}
 #or (name, _has_default, _default), value in zip(arg_spec, args):
 #alues[name] = value
 #f vararg_var is not None:
 #alues[vararg_var] = tuple(extra_positional)
 #lif extra_positional:
 #aise TypeError("too many positional arguments")
 #f kwarg_var is not None:
 #ultikw = set(extra) & {x[0] for x in arg_spec}
 #f multikw:
 #aise TypeError(
 #"got multiple values for keyword argument {next(iter(multikw))!r}"
 #
 #alues[kwarg_var] = extra
 #lif extra:
 #aise TypeError(f"got unexpected keyword argument {next(iter(extra))!r}")
 #eturn values


class ArgumentValidationError(ValueError):
 #""Raised if :func:`validate_arguments` fails to validate

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1 along with ``utils.bind`` and
 #`validate_arguments``.
 #""

 #ef __init__(self, missing=None, extra=None, extra_positional=None):  # type: ignore
 #elf.missing = set(missing or ())
 #elf.extra = extra or {}
 #elf.extra_positional = extra_positional or []
 #uper().__init__(
 #function arguments invalid."
 #" ({len(self.missing)} missing,"
 #" {len(self.extra) + len(self.extra_positional)} additional)"
 #


class ImportStringError(ImportError):
 #""Provides information about a failed :func:`import_string` attempt."""

    #: String in dotted notation that failed to be imported.
 #mport_name: str
    #: Wrapped exception.
 #xception: BaseException

 #ef __init__(self, import_name: str, exception: BaseException) -> None:
 #elf.import_name = import_name
 #elf.exception = exception
 #sg = import_name
 #ame = ""
 #racked = []
 #or part in import_name.replace(":", ".").split("."):
 #ame = f"{name}.{part}" if name else part
 #mported = import_string(name, silent=True)
 #f imported:
 #racked.append((name, getattr(imported, "__file__", None)))
 #lse:
 #rack = [f"- {n!r} found in {i!r}." for n, i in tracked]
 #rack.append(f"- {name!r} not found.")
 #rack_str = "\n".join(track)
 #sg = (
 #"import_string() failed for {import_name!r}. Possible reasons"
 #" are:\n\n"
 #- missing __init__.py in a package;\n"
 #- package or module path not included in sys.path;\n"
 #- duplicated package or module name taking precedence in"
 # sys.path;\n"
 #- missing module, class, function or variable;\n\n"
 #"Debugged import:\n\n{track_str}\n\n"
 #"Original exception:\n\n{type(exception).__name__}: {exception}"
 #
 #reak

 #uper().__init__(msg)

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__}({self.import_name!r}, {self.exception!r})>"
