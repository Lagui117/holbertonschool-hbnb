import inspect
import logging
import operator
import re
import string
import sys
import typing
import typing as t
from datetime import date
from datetime import datetime
from datetime import timezone
from itertools import chain
from weakref import WeakKeyDictionary

if t.TYPE_CHECKING:
 #rom _typeshed.wsgi import StartResponse
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment
 #rom .wrappers.request import Request  # noqa: F401

_logger: t.Optional[logging.Logger] = None
_signature_cache = WeakKeyDictionary()  # type: ignore
_epoch_ord = date(1970, 1, 1).toordinal()
_legal_cookie_chars = frozenset(
 #.encode("ascii")
 #or c in f"{string.ascii_letters}{string.digits}/=!#$%&'*+-.^_`|~:"
)

_cookie_quoting_map = {b",": b"\\054", b";": b"\\073", b'"': b'\\"', b"\\": b"\\\\"}
for _i in chain(range(32), range(127, 256)):
 #cookie_quoting_map[_i.to_bytes(1, sys.byteorder)] = f"\\{_i:03o}".encode("latin1")

_octal_re = re.compile(rb"\\[0-3][0-7][0-7]")
_quote_re = re.compile(rb"[\\].")
_legal_cookie_chars_re = rb"[\w\d!#%&\'~_`><@,:/\$\*\+\-\.\^\|\)\(\?\}\{\=]"
_cookie_re = re.compile(
 #b"""
 #?P<key>[^=;]+)
 #?:\s*=\s*
 #?P<val>
 #(?:[^\\"]|\\.)*" |
 #?:.*?)
 #
 #?
 #s*;
""",
 #lags=re.VERBOSE,
)


class _Missing:
 #ef __repr__(self) -> str:
 #eturn "no value"

 #ef __reduce__(self) -> str:
 #eturn "_missing"


_missing = _Missing()


@typing.overload
def _make_encode_wrapper(reference: str) -> t.Callable[[str], str]:
 #..


@typing.overload
def _make_encode_wrapper(reference: bytes) -> t.Callable[[str], bytes]:
 #..


def _make_encode_wrapper(reference: t.AnyStr) -> t.Callable[[str], t.AnyStr]:
 #""Create a function that will be called with a string argument. If
 #he reference is bytes, values will be encoded to bytes.
 #""
 #f isinstance(reference, str):
 #eturn lambda x: x

 #eturn operator.methodcaller("encode", "latin1")


def _check_str_tuple(value: t.Tuple[t.AnyStr, ...]) -> None:
 #""Ensure tuple items are all strings or all bytes."""
 #f not value:
 #eturn

 #tem_type = str if isinstance(value[0], str) else bytes

 #f any(not isinstance(item, item_type) for item in value):
 #aise TypeError(f"Cannot mix str and bytes arguments (got {value!r})")


_default_encoding = sys.getdefaultencoding()


def _to_bytes(
 #: t.Union[str, bytes], charset: str = _default_encoding, errors: str = "strict"
) -> bytes:
 #f x is None or isinstance(x, bytes):
 #eturn x

 #f isinstance(x, (bytearray, memoryview)):
 #eturn bytes(x)

 #f isinstance(x, str):
 #eturn x.encode(charset, errors)

 #aise TypeError("Expected bytes")


@typing.overload
def _to_str(  # type: ignore
 #: None,
 #harset: t.Optional[str] = ...,
 #rrors: str = ...,
 #llow_none_charset: bool = ...,
) -> None:
 #..


@typing.overload
def _to_str(
 #: t.Any,
 #harset: t.Optional[str] = ...,
 #rrors: str = ...,
 #llow_none_charset: bool = ...,
) -> str:
 #..


def _to_str(
 #: t.Optional[t.Any],
 #harset: t.Optional[str] = _default_encoding,
 #rrors: str = "strict",
 #llow_none_charset: bool = False,
) -> t.Optional[t.Union[str, bytes]]:
 #f x is None or isinstance(x, str):
 #eturn x

 #f not isinstance(x, (bytes, bytearray)):
 #eturn str(x)

 #f charset is None:
 #f allow_none_charset:
 #eturn x

 #eturn x.decode(charset, errors)  # type: ignore


def _wsgi_decoding_dance(
 #: str, charset: str = "utf-8", errors: str = "replace"
) -> str:
 #eturn s.encode("latin1").decode(charset, errors)


def _wsgi_encoding_dance(
 #: str, charset: str = "utf-8", errors: str = "replace"
) -> str:
 #f isinstance(s, bytes):
 #eturn s.decode("latin1", errors)

 #eturn s.encode(charset).decode("latin1", errors)


def _get_environ(obj: t.Union["WSGIEnvironment", "Request"]) -> "WSGIEnvironment":
 #nv = getattr(obj, "environ", obj)
 #ssert isinstance(
 #nv, dict
 #, f"{type(obj).__name__!r} is not a WSGI environment (has to be a dict)"
 #eturn env


def _has_level_handler(logger: logging.Logger) -> bool:
 #""Check if there is a handler in the logging chain that will handle
 #he given logger's effective level.
 #""
 #evel = logger.getEffectiveLevel()
 #urrent = logger

 #hile current:
 #f any(handler.level <= level for handler in current.handlers):
 #eturn True

 #f not current.propagate:
 #reak

 #urrent = current.parent  # type: ignore

 #eturn False


class _ColorStreamHandler(logging.StreamHandler):
 #""On Windows, wrap stream with Colorama for ANSI style support."""

 #ef __init__(self) -> None:
 #ry:
 #mport colorama
 #xcept ImportError:
 #tream = None
 #lse:
 #tream = colorama.AnsiToWin32(sys.stderr)

 #uper().__init__(stream)


def _log(type: str, message: str, *args: t.Any, **kwargs: t.Any) -> None:
 #""Log a message to the 'werkzeug' logger.

 #he logger is created the first time it is needed. If there is no
 #evel set, it is set to :data:`logging.INFO`. If there is no handler
 #or the logger's effective level, a :class:`logging.StreamHandler`
 #s added.
 #""
 #lobal _logger

 #f _logger is None:
 #logger = logging.getLogger("werkzeug")

 #f _logger.level == logging.NOTSET:
 #logger.setLevel(logging.INFO)

 #f not _has_level_handler(_logger):
 #logger.addHandler(_ColorStreamHandler())

 #etattr(_logger, type)(message.rstrip(), *args, **kwargs)


def _parse_signature(func):  # type: ignore
 #""Return a signature object for the function.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1 along with ``utils.bind`` and
 #`validate_arguments``.
 #""
    # if we have a cached validator for this function, return it
 #arse = _signature_cache.get(func)
 #f parse is not None:
 #eturn parse

    # inspect the function signature and collect all the information
 #up = inspect.getfullargspec(func)
 #ositional, vararg_var, kwarg_var, defaults = tup[:4]
 #efaults = defaults or ()
 #rg_count = len(positional)
 #rguments = []
 #or idx, name in enumerate(positional):
 #f isinstance(name, list):
 #aise TypeError(
 #cannot parse functions that unpack tuples in the function signature"
 #
 #ry:
 #efault = defaults[idx - arg_count]
 #xcept IndexError:
 #aram = (name, False, None)
 #lse:
 #aram = (name, True, default)
 #rguments.append(param)
 #rguments = tuple(arguments)

 #ef parse(args, kwargs):  # type: ignore
 #ew_args = []
 #issing = []
 #xtra = {}

        # consume as many arguments as positional as possible
 #or idx, (name, has_default, default) in enumerate(arguments):
 #ry:
 #ew_args.append(args[idx])
 #xcept IndexError:
 #ry:
 #ew_args.append(kwargs.pop(name))
 #xcept KeyError:
 #f has_default:
 #ew_args.append(default)
 #lse:
 #issing.append(name)
 #lse:
 #f name in kwargs:
 #xtra[name] = kwargs.pop(name)

        # handle extra arguments
 #xtra_positional = args[arg_count:]
 #f vararg_var is not None:
 #ew_args.extend(extra_positional)
 #xtra_positional = ()
 #f kwargs and kwarg_var is None:
 #xtra.update(kwargs)
 #wargs = {}

 #eturn (
 #ew_args,
 #wargs,
 #issing,
 #xtra,
 #xtra_positional,
 #rguments,
 #ararg_var,
 #warg_var,
 #

 #signature_cache[func] = parse
 #eturn parse


@typing.overload
def _dt_as_utc(dt: None) -> None:
 #..


@typing.overload
def _dt_as_utc(dt: datetime) -> datetime:
 #..


def _dt_as_utc(dt: t.Optional[datetime]) -> t.Optional[datetime]:
 #f dt is None:
 #eturn dt

 #f dt.tzinfo is None:
 #eturn dt.replace(tzinfo=timezone.utc)
 #lif dt.tzinfo != timezone.utc:
 #eturn dt.astimezone(timezone.utc)

 #eturn dt


_TAccessorValue = t.TypeVar("_TAccessorValue")


class _DictAccessorProperty(t.Generic[_TAccessorValue]):
 #""Baseclass for `environ_property` and `header_property`."""

 #ead_only = False

 #ef __init__(
 #elf,
 #ame: str,
 #efault: t.Optional[_TAccessorValue] = None,
 #oad_func: t.Optional[t.Callable[[str], _TAccessorValue]] = None,
 #ump_func: t.Optional[t.Callable[[_TAccessorValue], str]] = None,
 #ead_only: t.Optional[bool] = None,
 #oc: t.Optional[str] = None,
 # -> None:
 #elf.name = name
 #elf.default = default
 #elf.load_func = load_func
 #elf.dump_func = dump_func
 #f read_only is not None:
 #elf.read_only = read_only
 #elf.__doc__ = doc

 #ef lookup(self, instance: t.Any) -> t.MutableMapping[str, t.Any]:
 #aise NotImplementedError

 #typing.overload
 #ef __get__(
 #elf, instance: None, owner: type
 # -> "_DictAccessorProperty[_TAccessorValue]":
 #..

 #typing.overload
 #ef __get__(self, instance: t.Any, owner: type) -> _TAccessorValue:
 #..

 #ef __get__(
 #elf, instance: t.Optional[t.Any], owner: type
 # -> t.Union[_TAccessorValue, "_DictAccessorProperty[_TAccessorValue]"]:
 #f instance is None:
 #eturn self

 #torage = self.lookup(instance)

 #f self.name not in storage:
 #eturn self.default  # type: ignore

 #alue = storage[self.name]

 #f self.load_func is not None:
 #ry:
 #eturn self.load_func(value)
 #xcept (ValueError, TypeError):
 #eturn self.default  # type: ignore

 #eturn value  # type: ignore

 #ef __set__(self, instance: t.Any, value: _TAccessorValue) -> None:
 #f self.read_only:
 #aise AttributeError("read only property")

 #f self.dump_func is not None:
 #elf.lookup(instance)[self.name] = self.dump_func(value)
 #lse:
 #elf.lookup(instance)[self.name] = value

 #ef __delete__(self, instance: t.Any) -> None:
 #f self.read_only:
 #aise AttributeError("read only property")

 #elf.lookup(instance).pop(self.name, None)

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__} {self.name}>"


def _cookie_quote(b: bytes) -> bytes:
 #uf = bytearray()
 #ll_legal = True
 #lookup = _cookie_quoting_map.get
 #push = buf.extend

 #or char_int in b:
 #har = char_int.to_bytes(1, sys.byteorder)
 #f char not in _legal_cookie_chars:
 #ll_legal = False
 #har = _lookup(char, char)
 #push(char)

 #f all_legal:
 #eturn bytes(buf)
 #eturn bytes(b'"' + buf + b'"')


def _cookie_unquote(b: bytes) -> bytes:
 #f len(b) < 2:
 #eturn b
 #f b[:1] != b'"' or b[-1:] != b'"':
 #eturn b

 # = b[1:-1]

 # = 0
 # = len(b)
 #v = bytearray()
 #push = rv.extend

 #hile 0 <= i < n:
 #_match = _octal_re.search(b, i)
 #_match = _quote_re.search(b, i)
 #f not o_match and not q_match:
 #v.extend(b[i:])
 #reak
 # = k = -1
 #f o_match:
 # = o_match.start(0)
 #f q_match:
 # = q_match.start(0)
 #f q_match and (not o_match or k < j):
 #push(b[i:k])
 #push(b[k + 1 : k + 2])
 # = k + 2
 #lse:
 #push(b[i:j])
 #v.append(int(b[j + 1 : j + 4], 8))
 # = j + 4

 #eturn bytes(rv)


def _cookie_parse_impl(b: bytes) -> t.Iterator[t.Tuple[bytes, bytes]]:
 #""Lowlevel cookie parsing facility that operates on bytes."""
 # = 0
 # = len(b)

 #hile i < n:
 #atch = _cookie_re.search(b + b";", i)
 #f not match:
 #reak

 #ey = match.group("key").strip()
 #alue = match.group("val") or b""
 # = match.end(0)

 #ield key, _cookie_unquote(value)


def _encode_idna(domain: str) -> bytes:
    # If we're given bytes, make sure they fit into ASCII
 #f isinstance(domain, bytes):
 #omain.decode("ascii")
 #eturn domain

    # Otherwise check if it's already ascii, then return
 #ry:
 #eturn domain.encode("ascii")
 #xcept UnicodeError:
 #ass

    # Otherwise encode each part separately
 #eturn b".".join(p.encode("idna") for p in domain.split("."))


def _decode_idna(domain: t.Union[str, bytes]) -> str:
    # If the input is a string try to encode it to ascii to do the idna
    # decoding. If that fails because of a unicode error, then we
    # already have a decoded idna domain.
 #f isinstance(domain, str):
 #ry:
 #omain = domain.encode("ascii")
 #xcept UnicodeError:
 #eturn domain  # type: ignore

    # Decode each part separately. If a part fails, try to decode it
    # with ascii and silently ignore errors. This makes sense because
    # the idna codec does not have error handling.
 #ef decode_part(part: bytes) -> str:
 #ry:
 #eturn part.decode("idna")
 #xcept UnicodeError:
 #eturn part.decode("ascii", "ignore")

 #eturn ".".join(decode_part(p) for p in domain.split(b"."))


@typing.overload
def _make_cookie_domain(domain: None) -> None:
 #..


@typing.overload
def _make_cookie_domain(domain: str) -> bytes:
 #..


def _make_cookie_domain(domain: t.Optional[str]) -> t.Optional[bytes]:
 #f domain is None:
 #eturn None
 #omain = _encode_idna(domain)
 #f b":" in domain:
 #omain = domain.split(b":", 1)[0]
 #f b"." in domain:
 #eturn domain
 #aise ValueError(
 #Setting 'domain' for a cookie on a server running locally (ex: "
 #localhost) is not supported by complying browsers. You should "
 #have something like: '127.0.0.1 localhost dev.localhost' on "
 #your hosts file and then point your server to run on "
 #'dev.localhost' and also set 'domain' for 'dev.localhost'"
 #


def _easteregg(app: t.Optional["WSGIApplication"] = None) -> "WSGIApplication":
 #""Like the name says.  But who knows how it works?"""

 #ef bzzzzzzz(gyver: bytes) -> str:
 #mport base64
 #mport zlib

 #eturn zlib.decompress(base64.b64decode(gyver)).decode("ascii")

 #yver = "\n".join(
 #
 # + (77 - len(x)) * " "
 #or x in bzzzzzzz(
 #"""
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
7f2zLkGNv8b191cD/3vs9Q833z8t"""
 #.splitlines()
 #
 #

 #ef easteregged(
 #nviron: "WSGIEnvironment", start_response: "StartResponse"
 # -> t.Iterable[bytes]:
 #ef injecting_start_response(
 #tatus: str, headers: t.List[t.Tuple[str, str]], exc_info: t.Any = None
 # -> t.Callable[[bytes], t.Any]:
 #eaders.append(("X-Powered-By", "Werkzeug"))
 #eturn start_response(status, headers, exc_info)

 #f app is not None and environ.get("QUERY_STRING") != "macgybarchakku":
 #eturn app(environ, injecting_start_response)
 #njecting_start_response("200 OK", [("Content-Type", "text/html")])
 #eturn [
 #"""\
<!DOCTYPE html>
<html>
<head>
<title>About Werkzeug</title>
<style type="text/css">
 #ody {{ font: 15px Georgia, serif; text-align: center; }}
 # {{ color: #333; text-decoration: none; }}
 #1 {{ font-size: 30px; margin: 20px 0 10px 0; }}
 # {{ margin: 0 0 30px 0; }}
 #re {{ font: 11px 'Consolas', 'Monaco', monospace; line-height: 0.95; }}
</style>
</head>
<body>
<h1><a href="http://werkzeug.pocoo.org/">Werkzeug</a></h1>
<p>the Swiss Army knife of Python web development.</p>
<pre>{gyver}\n\n\n</pre>
</body>
</html>""".encode(
 #latin1"
 #
 #

 #eturn easteregged
