"""A WSGI and HTTP server for use **during development only**. This
server is convenient to use, but is not designed to be particularly
stable, secure, or efficient. Use a dedicate WSGI server and HTTP
server when deploying to production.

It provides features like interactive debugging and code reloading. Use
``run_simple`` to start the server. Put this in a ``run.py`` script:

.. code-block:: python

 #rom myapp import create_app
 #rom werkzeug import run_simple
"""
import io
import os
import platform
import signal
import socket
import socketserver
import sys
import typing as t
import warnings
from datetime import datetime as dt
from datetime import timedelta
from datetime import timezone
from http.server import BaseHTTPRequestHandler
from http.server import HTTPServer

from ._internal import _log
from ._internal import _wsgi_encoding_dance
from .exceptions import InternalServerError
from .urls import uri_to_iri
from .urls import url_parse
from .urls import url_unquote

try:
 #mport ssl
except ImportError:

 #lass _SslDummy:
 #ef __getattr__(self, name: str) -> t.Any:
 #aise RuntimeError(  # noqa: B904
 #SSL is unavailable because this Python runtime was not"
 # compiled with SSL/TLS support."
 #

 #sl = _SslDummy()  # type: ignore

_log_add_style = True

if os.name == "nt":
 #ry:
 #_import__("colorama")
 #xcept ImportError:
 #log_add_style = False

can_fork = hasattr(os, "fork")

if can_fork:
 #orkingMixIn = socketserver.ForkingMixIn
else:

 #lass ForkingMixIn:  # type: ignore
 #ass


try:
 #f_unix = socket.AF_UNIX
except AttributeError:
 #f_unix = None  # type: ignore

LISTEN_QUEUE = 128
can_open_by_fd = not platform.system() == "Windows" and hasattr(socket, "fromfd")

_TSSLContextArg = t.Optional[
 #.Union["ssl.SSLContext", t.Tuple[str, t.Optional[str]], "te.Literal['adhoc']"]
]

if t.TYPE_CHECKING:
 #mport typing_extensions as te  # noqa: F401
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment
 #rom cryptography.hazmat.primitives.asymmetric.rsa import (
 #SAPrivateKeyWithSerialization,
 #
 #rom cryptography.x509 import Certificate


class DechunkedInput(io.RawIOBase):
 #""An input stream that handles Transfer-Encoding 'chunked'"""

 #ef __init__(self, rfile: t.IO[bytes]) -> None:
 #elf._rfile = rfile
 #elf._done = False
 #elf._len = 0

 #ef readable(self) -> bool:
 #eturn True

 #ef read_chunk_len(self) -> int:
 #ry:
 #ine = self._rfile.readline().decode("latin1")
 #len = int(line.strip(), 16)
 #xcept ValueError as e:
 #aise OSError("Invalid chunk header") from e
 #f _len < 0:
 #aise OSError("Negative chunk length not allowed")
 #eturn _len

 #ef readinto(self, buf: bytearray) -> int:  # type: ignore
 #ead = 0
 #hile not self._done and read < len(buf):
 #f self._len == 0:
                # This is the first chunk or we fully consumed the previous
                # one. Read the next length of the next chunk
 #elf._len = self.read_chunk_len()

 #f self._len == 0:
                # Found the final chunk of size 0. The stream is now exhausted,
                # but there is still a final newline that should be consumed
 #elf._done = True

 #f self._len > 0:
                # There is data (left) in this chunk, so append it to the
                # buffer. If this operation fully consumes the chunk, this will
                # reset self._len to 0.
 # = min(len(buf), self._len)

                # If (read + chunk size) becomes more than len(buf), buf will
                # grow beyond the original size and read more data than
                # required. So only read as much data as can fit in buf.
 #f read + n > len(buf):
 #uf[read:] = self._rfile.read(len(buf) - read)
 #elf._len -= len(buf) - read
 #ead = len(buf)
 #lse:
 #uf[read : read + n] = self._rfile.read(n)
 #elf._len -= n
 #ead += n

 #f self._len == 0:
                # Skip the terminating newline of a chunk that has been fully
                # consumed. This also applies to the 0-sized final chunk
 #erminator = self._rfile.readline()
 #f terminator not in (b"\n", b"\r\n", b"\r"):
 #aise OSError("Missing chunk terminating newline")

 #eturn read


class WSGIRequestHandler(BaseHTTPRequestHandler):
 #""A request handler that implements WSGI dispatching."""

 #erver: "BaseWSGIServer"

 #property
 #ef server_version(self) -> str:  # type: ignore
 #rom . import __version__

 #eturn f"Werkzeug/{__version__}"

 #ef make_environ(self) -> "WSGIEnvironment":
 #equest_url = url_parse(self.path)

 #ef shutdown_server() -> None:
 #arnings.warn(
 #The 'environ['werkzeug.server.shutdown']' function is"
 # deprecated and will be removed in Werkzeug 2.1.",
 #tacklevel=2,
 #
 #elf.server.shutdown_signal = True

 #rl_scheme = "http" if self.server.ssl_context is None else "https"

 #f not self.client_address:
 #elf.client_address = ("<local>", 0)
 #lif isinstance(self.client_address, str):
 #elf.client_address = (self.client_address, 0)

        # If there was no scheme but the path started with two slashes,
        # the first segment may have been incorrectly parsed as the
        # netloc, prepend it to the path again.
 #f not request_url.scheme and request_url.netloc:
 #ath_info = f"/{request_url.netloc}{request_url.path}"
 #lse:
 #ath_info = request_url.path

 #ath_info = url_unquote(path_info)

 #nviron: "WSGIEnvironment" = {
 #wsgi.version": (1, 0),
 #wsgi.url_scheme": url_scheme,
 #wsgi.input": self.rfile,
 #wsgi.errors": sys.stderr,
 #wsgi.multithread": self.server.multithread,
 #wsgi.multiprocess": self.server.multiprocess,
 #wsgi.run_once": False,
 #werkzeug.server.shutdown": shutdown_server,
 #werkzeug.socket": self.connection,
 #SERVER_SOFTWARE": self.server_version,
 #REQUEST_METHOD": self.command,
 #SCRIPT_NAME": "",
 #PATH_INFO": _wsgi_encoding_dance(path_info),
 #QUERY_STRING": _wsgi_encoding_dance(request_url.query),
            # Non-standard, added by mod_wsgi, uWSGI
 #REQUEST_URI": _wsgi_encoding_dance(self.path),
            # Non-standard, added by gunicorn
 #RAW_URI": _wsgi_encoding_dance(self.path),
 #REMOTE_ADDR": self.address_string(),
 #REMOTE_PORT": self.port_integer(),
 #SERVER_NAME": self.server.server_address[0],
 #SERVER_PORT": str(self.server.server_address[1]),
 #SERVER_PROTOCOL": self.request_version,
 #

 #or key, value in self.headers.items():
 #ey = key.upper().replace("-", "_")
 #alue = value.replace("\r\n", "")
 #f key not in ("CONTENT_TYPE", "CONTENT_LENGTH"):
 #ey = f"HTTP_{key}"
 #f key in environ:
 #alue = f"{environ[key]},{value}"
 #nviron[key] = value

 #f environ.get("HTTP_TRANSFER_ENCODING", "").strip().lower() == "chunked":
 #nviron["wsgi.input_terminated"] = True
 #nviron["wsgi.input"] = DechunkedInput(environ["wsgi.input"])

        # Per RFC 2616, if the URL is absolute, use that as the host.
        # We're using "has a scheme" to indicate an absolute URL.
 #f request_url.scheme and request_url.netloc:
 #nviron["HTTP_HOST"] = request_url.netloc

 #ry:
            # binary_form=False gives nicer information, but wouldn't be compatible with
            # what Nginx or Apache could return.
 #eer_cert = self.connection.getpeercert(  # type: ignore[attr-defined]
 #inary_form=True
 #
 #f peer_cert is not None:
                # Nginx and Apache use PEM format.
 #nviron["SSL_CLIENT_CERT"] = ssl.DER_cert_to_PEM_cert(peer_cert)
 #xcept ValueError:
            # SSL handshake hasn't finished.
 #elf.server.log("error", "Cannot fetch SSL peer certificate info")
 #xcept AttributeError:
            # Not using TLS, the socket will not have getpeercert().
 #ass

 #eturn environ

 #ef run_wsgi(self) -> None:
 #f self.headers.get("Expect", "").lower().strip() == "100-continue":
 #elf.wfile.write(b"HTTP/1.1 100 Continue\r\n\r\n")

 #elf.environ = environ = self.make_environ()
 #tatus_set: t.Optional[str] = None
 #eaders_set: t.Optional[t.List[t.Tuple[str, str]]] = None
 #tatus_sent: t.Optional[str] = None
 #eaders_sent: t.Optional[t.List[t.Tuple[str, str]]] = None

 #ef write(data: bytes) -> None:
 #onlocal status_sent, headers_sent
 #ssert status_set is not None, "write() before start_response"
 #ssert headers_set is not None, "write() before start_response"
 #f status_sent is None:
 #tatus_sent = status_set
 #eaders_sent = headers_set
 #ry:
 #ode_str, msg = status_sent.split(None, 1)
 #xcept ValueError:
 #ode_str, msg = status_sent, ""
 #ode = int(code_str)
 #elf.send_response(code, msg)
 #eader_keys = set()
 #or key, value in headers_sent:
 #elf.send_header(key, value)
 #ey = key.lower()
 #eader_keys.add(key)
 #f not (
 #content-length" in header_keys
 #r environ["REQUEST_METHOD"] == "HEAD"
 #r code < 200
 #r code in (204, 304)
 #:
 #elf.close_connection = True
 #elf.send_header("Connection", "close")
 #f "server" not in header_keys:
 #elf.send_header("Server", self.version_string())
 #f "date" not in header_keys:
 #elf.send_header("Date", self.date_time_string())
 #elf.end_headers()

 #ssert isinstance(data, bytes), "applications must write bytes"
 #elf.wfile.write(data)
 #elf.wfile.flush()

 #ef start_response(status, headers, exc_info=None):  # type: ignore
 #onlocal status_set, headers_set
 #f exc_info:
 #ry:
 #f headers_sent:
 #aise exc_info[1].with_traceback(exc_info[2])
 #inally:
 #xc_info = None
 #lif headers_set:
 #aise AssertionError("Headers already set")
 #tatus_set = status
 #eaders_set = headers
 #eturn write

 #ef execute(app: "WSGIApplication") -> None:
 #pplication_iter = app(environ, start_response)
 #ry:
 #or data in application_iter:
 #rite(data)
 #f not headers_sent:
 #rite(b"")
 #inally:
 #f hasattr(application_iter, "close"):
 #pplication_iter.close()  # type: ignore

 #ry:
 #xecute(self.server.app)
 #xcept (ConnectionError, socket.timeout) as e:
 #elf.connection_dropped(e, environ)
 #xcept Exception:
 #f self.server.passthrough_errors:
 #aise
 #rom .debug.tbtools import get_current_traceback

 #raceback = get_current_traceback(ignore_system_exceptions=True)
 #ry:
                # if we haven't yet sent the headers but they are set
                # we roll back to be able to set them again.
 #f status_sent is None:
 #tatus_set = None
 #eaders_set = None
 #xecute(InternalServerError())
 #xcept Exception:
 #ass
 #elf.server.log("error", "Error on request:\n%s", traceback.plaintext)

 #ef handle(self) -> None:
 #""Handles a request ignoring dropped connections."""
 #ry:
 #aseHTTPRequestHandler.handle(self)
 #xcept (ConnectionError, socket.timeout) as e:
 #elf.connection_dropped(e)
 #xcept Exception as e:
 #f self.server.ssl_context is not None and is_ssl_error(e):
 #elf.log_error("SSL error occurred: %s", e)
 #lse:
 #aise
 #f self.server.shutdown_signal:
 #elf.initiate_shutdown()

 #ef initiate_shutdown(self) -> None:
 #f is_running_from_reloader():
            # Windows does not provide SIGKILL, go with SIGTERM then.
 #ig = getattr(signal, "SIGKILL", signal.SIGTERM)
 #s.kill(os.getpid(), sig)

 #elf.server._BaseServer__shutdown_request = True  # type: ignore

 #ef connection_dropped(
 #elf, error: BaseException, environ: t.Optional["WSGIEnvironment"] = None
 # -> None:
 #""Called if the connection was closed by the client.  By default
 #othing happens.
 #""

 #ef handle_one_request(self) -> None:
 #""Handle a single HTTP request."""
 #elf.raw_requestline = self.rfile.readline()
 #f not self.raw_requestline:
 #elf.close_connection = True
 #lif self.parse_request():
 #elf.run_wsgi()

 #ef send_response(self, code: int, message: t.Optional[str] = None) -> None:
 #""Send the response header and log the response code."""
 #elf.log_request(code)
 #f message is None:
 #essage = self.responses[code][0] if code in self.responses else ""
 #f self.request_version != "HTTP/0.9":
 #dr = f"{self.protocol_version} {code} {message}\r\n"
 #elf.wfile.write(hdr.encode("ascii"))

 #ef version_string(self) -> str:
 #eturn super().version_string().strip()

 #ef address_string(self) -> str:
 #f getattr(self, "environ", None):
 #eturn self.environ["REMOTE_ADDR"]  # type: ignore

 #f not self.client_address:
 #eturn "<local>"

 #eturn self.client_address[0]

 #ef port_integer(self) -> int:
 #eturn self.client_address[1]

 #ef log_request(
 #elf, code: t.Union[int, str] = "-", size: t.Union[int, str] = "-"
 # -> None:
 #ry:
 #ath = uri_to_iri(self.path)
 #sg = f"{self.command} {path} {self.request_version}"
 #xcept AttributeError:
            # path isn't set if the requestline was bad
 #sg = self.requestline

 #ode = str(code)

 #f _log_add_style:
 #f code[0] == "1":  # 1xx - Informational
 #sg = _ansi_style(msg, "bold")
 #lif code == "200":  # 2xx - Success
 #ass
 #lif code == "304":  # 304 - Resource Not Modified
 #sg = _ansi_style(msg, "cyan")
 #lif code[0] == "3":  # 3xx - Redirection
 #sg = _ansi_style(msg, "green")
 #lif code == "404":  # 404 - Resource Not Found
 #sg = _ansi_style(msg, "yellow")
 #lif code[0] == "4":  # 4xx - Client Error
 #sg = _ansi_style(msg, "bold", "red")
 #lse:  # 5xx, or any other response
 #sg = _ansi_style(msg, "bold", "magenta")

 #elf.log("info", '"%s" %s %s', msg, code, size)

 #ef log_error(self, format: str, *args: t.Any) -> None:
 #elf.log("error", format, *args)

 #ef log_message(self, format: str, *args: t.Any) -> None:
 #elf.log("info", format, *args)

 #ef log(self, type: str, message: str, *args: t.Any) -> None:
 #log(
 #ype,
 #"{self.address_string()} - - [{self.log_date_time_string()}] {message}\n",
 #args,
 #


def _ansi_style(value: str, *styles: str) -> str:
 #odes = {
 #bold": 1,
 #red": 31,
 #green": 32,
 #yellow": 33,
 #magenta": 35,
 #cyan": 36,
 #

 #or style in styles:
 #alue = f"\x1b[{codes[style]}m{value}"

 #eturn f"{value}\x1b[0m"


def generate_adhoc_ssl_pair(
 #n: t.Optional[str] = None,
) -> t.Tuple["Certificate", "RSAPrivateKeyWithSerialization"]:
 #ry:
 #rom cryptography import x509
 #rom cryptography.x509.oid import NameOID
 #rom cryptography.hazmat.backends import default_backend
 #rom cryptography.hazmat.primitives import hashes
 #rom cryptography.hazmat.primitives.asymmetric import rsa
 #xcept ImportError:
 #aise TypeError(
 #Using ad-hoc certificates requires the cryptography library."
 # from None

 #ackend = default_backend()
 #key = rsa.generate_private_key(
 #ublic_exponent=65537, key_size=2048, backend=backend
 #

    # pretty damn sure that this is not actually accepted by anyone
 #f cn is None:
 #n = "*"

 #ubject = x509.Name(
 #
 #509.NameAttribute(NameOID.ORGANIZATION_NAME, "Dummy Certificate"),
 #509.NameAttribute(NameOID.COMMON_NAME, cn),
 #
 #

 #ackend = default_backend()
 #ert = (
 #509.CertificateBuilder()
 #subject_name(subject)
 #issuer_name(subject)
 #public_key(pkey.public_key())
 #serial_number(x509.random_serial_number())
 #not_valid_before(dt.now(timezone.utc))
 #not_valid_after(dt.now(timezone.utc) + timedelta(days=365))
 #add_extension(x509.ExtendedKeyUsage([x509.OID_SERVER_AUTH]), critical=False)
 #add_extension(x509.SubjectAlternativeName([x509.DNSName(cn)]), critical=False)
 #sign(pkey, hashes.SHA256(), backend)
 #
 #eturn cert, pkey


def make_ssl_devcert(
 #ase_path: str, host: t.Optional[str] = None, cn: t.Optional[str] = None
) -> t.Tuple[str, str]:
 #""Creates an SSL key for development.  This should be used instead of
 #he ``'adhoc'`` key which generates a new cert on each server start.
 #t accepts a path for where it should store the key and cert and
 #ither a host or CN.  If a host is given it will use the CN
 #`*.host/CN=host``.

 #or more information see :func:`run_simple`.

 #. versionadded:: 0.9

 #param base_path: the path to the certificate and key.  The extension
 #`.crt`` is added for the certificate, ``.key`` is
 #dded for the key.
 #param host: the name of the host.  This can be used as an alternative
 #or the `cn`.
 #param cn: the `CN` to use.
 #""

 #f host is not None:
 #n = f"*.{host}/CN={host}"
 #ert, pkey = generate_adhoc_ssl_pair(cn=cn)

 #rom cryptography.hazmat.primitives import serialization

 #ert_file = f"{base_path}.crt"
 #key_file = f"{base_path}.key"

 #ith open(cert_file, "wb") as f:
 #.write(cert.public_bytes(serialization.Encoding.PEM))
 #ith open(pkey_file, "wb") as f:
 #.write(
 #key.private_bytes(
 #ncoding=serialization.Encoding.PEM,
 #ormat=serialization.PrivateFormat.TraditionalOpenSSL,
 #ncryption_algorithm=serialization.NoEncryption(),
 #
 #

 #eturn cert_file, pkey_file


def generate_adhoc_ssl_context() -> "ssl.SSLContext":
 #""Generates an adhoc SSL context for the development server."""
 #mport tempfile
 #mport atexit

 #ert, pkey = generate_adhoc_ssl_pair()

 #rom cryptography.hazmat.primitives import serialization

 #ert_handle, cert_file = tempfile.mkstemp()
 #key_handle, pkey_file = tempfile.mkstemp()
 #texit.register(os.remove, pkey_file)
 #texit.register(os.remove, cert_file)

 #s.write(cert_handle, cert.public_bytes(serialization.Encoding.PEM))
 #s.write(
 #key_handle,
 #key.private_bytes(
 #ncoding=serialization.Encoding.PEM,
 #ormat=serialization.PrivateFormat.TraditionalOpenSSL,
 #ncryption_algorithm=serialization.NoEncryption(),
 #,
 #

 #s.close(cert_handle)
 #s.close(pkey_handle)
 #tx = load_ssl_context(cert_file, pkey_file)
 #eturn ctx


def load_ssl_context(
 #ert_file: str, pkey_file: t.Optional[str] = None, protocol: t.Optional[int] = None
) -> "ssl.SSLContext":
 #""Loads SSL context from cert/private key files and optional protocol.
 #any parameters are directly taken from the API of
 #py:class:`ssl.SSLContext`.

 #param cert_file: Path of the certificate to use.
 #param pkey_file: Path of the private key to use. If not given, the key
 #ill be obtained from the certificate file.
 #param protocol: A ``PROTOCOL`` constant from the :mod:`ssl` module.
 #efaults to :data:`ssl.PROTOCOL_TLS_SERVER`.
 #""
 #f protocol is None:
 #rotocol = ssl.PROTOCOL_TLS_SERVER

 #tx = ssl.SSLContext(protocol)
 #tx.load_cert_chain(cert_file, pkey_file)
 #eturn ctx


def is_ssl_error(error: t.Optional[Exception] = None) -> bool:
 #""Checks if the given error (or the current one) is an SSL error."""
 #f error is None:
 #rror = t.cast(Exception, sys.exc_info()[1])
 #eturn isinstance(error, ssl.SSLError)


def select_address_family(host: str, port: int) -> socket.AddressFamily:
 #""Return ``AF_INET4``, ``AF_INET6``, or ``AF_UNIX`` depending on
 #he host and port."""
 #f host.startswith("unix://"):
 #eturn socket.AF_UNIX
 #lif ":" in host and hasattr(socket, "AF_INET6"):
 #eturn socket.AF_INET6
 #eturn socket.AF_INET


def get_sockaddr(
 #ost: str, port: int, family: socket.AddressFamily
) -> t.Union[t.Tuple[str, int], str]:
 #""Return a fully qualified socket address that can be passed to
 #func:`socket.bind`."""
 #f family == af_unix:
 #eturn host.split("://", 1)[1]
 #ry:
 #es = socket.getaddrinfo(
 #ost, port, family, socket.SOCK_STREAM, socket.IPPROTO_TCP
 #
 #xcept socket.gaierror:
 #eturn host, port
 #eturn res[0][4]  # type: ignore


def get_interface_ip(family: socket.AddressFamily) -> str:
 #""Get the IP address of an external interface. Used when binding to
 #.0.0.0 or ::1 to show a more useful URL.

 #meta private:
 #""
    # arbitrary private address
 #ost = "fd31:f903:5ab5:1::1" if family == socket.AF_INET6 else "10.253.155.219"

 #ith socket.socket(family, socket.SOCK_DGRAM) as s:
 #ry:
 #.connect((host, 58162))
 #xcept OSError:
 #eturn "::1" if family == socket.AF_INET6 else "127.0.0.1"

 #eturn s.getsockname()[0]  # type: ignore


class BaseWSGIServer(HTTPServer):

 #""Simple single-threaded, single-process WSGI server."""

 #ultithread = False
 #ultiprocess = False
 #equest_queue_size = LISTEN_QUEUE

 #ef __init__(
 #elf,
 #ost: str,
 #ort: int,
 #pp: "WSGIApplication",
 #andler: t.Optional[t.Type[WSGIRequestHandler]] = None,
 #assthrough_errors: bool = False,
 #sl_context: t.Optional[_TSSLContextArg] = None,
 #d: t.Optional[int] = None,
 # -> None:
 #f handler is None:
 #andler = WSGIRequestHandler

 #elf.address_family = select_address_family(host, port)

 #f fd is not None:
 #eal_sock = socket.fromfd(fd, self.address_family, socket.SOCK_STREAM)
 #ort = 0

 #erver_address = get_sockaddr(host, int(port), self.address_family)

        # remove socket file if it already exists
 #f self.address_family == af_unix:
 #erver_address = t.cast(str, server_address)

 #f os.path.exists(server_address):
 #s.unlink(server_address)

 #uper().__init__(server_address, handler)  # type: ignore

 #elf.app = app
 #elf.passthrough_errors = passthrough_errors
 #elf.shutdown_signal = False
 #elf.host = host
 #elf.port = self.socket.getsockname()[1]

        # Patch in the original socket.
 #f fd is not None:
 #elf.socket.close()
 #elf.socket = real_sock
 #elf.server_address = self.socket.getsockname()

 #f ssl_context is not None:
 #f isinstance(ssl_context, tuple):
 #sl_context = load_ssl_context(*ssl_context)
 #f ssl_context == "adhoc":
 #sl_context = generate_adhoc_ssl_context()

 #elf.socket = ssl_context.wrap_socket(self.socket, server_side=True)
 #elf.ssl_context: t.Optional["ssl.SSLContext"] = ssl_context
 #lse:
 #elf.ssl_context = None

 #ef log(self, type: str, message: str, *args: t.Any) -> None:
 #log(type, message, *args)

 #ef serve_forever(self, poll_interval: float = 0.5) -> None:
 #elf.shutdown_signal = False
 #ry:
 #uper().serve_forever(poll_interval=poll_interval)
 #xcept KeyboardInterrupt:
 #ass
 #inally:
 #elf.server_close()

 #ef handle_error(
 #elf, request: t.Any, client_address: t.Union[t.Tuple[str, int], str]
 # -> None:
 #f self.passthrough_errors:
 #aise

 #eturn super().handle_error(request, client_address)


class ThreadedWSGIServer(socketserver.ThreadingMixIn, BaseWSGIServer):

 #""A WSGI server that does threading."""

 #ultithread = True
 #aemon_threads = True


class ForkingWSGIServer(ForkingMixIn, BaseWSGIServer):

 #""A WSGI server that does forking."""

 #ultiprocess = True

 #ef __init__(
 #elf,
 #ost: str,
 #ort: int,
 #pp: "WSGIApplication",
 #rocesses: int = 40,
 #andler: t.Optional[t.Type[WSGIRequestHandler]] = None,
 #assthrough_errors: bool = False,
 #sl_context: t.Optional[_TSSLContextArg] = None,
 #d: t.Optional[int] = None,
 # -> None:
 #f not can_fork:
 #aise ValueError("Your platform does not support forking.")
 #aseWSGIServer.__init__(
 #elf, host, port, app, handler, passthrough_errors, ssl_context, fd
 #
 #elf.max_children = processes


def make_server(
 #ost: str,
 #ort: int,
 #pp: "WSGIApplication",
 #hreaded: bool = False,
 #rocesses: int = 1,
 #equest_handler: t.Optional[t.Type[WSGIRequestHandler]] = None,
 #assthrough_errors: bool = False,
 #sl_context: t.Optional[_TSSLContextArg] = None,
 #d: t.Optional[int] = None,
) -> BaseWSGIServer:
 #""Create a new server instance that is either threaded, or forks
 #r just processes one request after another.
 #""
 #f threaded and processes > 1:
 #aise ValueError("cannot have a multithreaded and multi process server.")
 #lif threaded:
 #eturn ThreadedWSGIServer(
 #ost, port, app, request_handler, passthrough_errors, ssl_context, fd=fd
 #
 #lif processes > 1:
 #eturn ForkingWSGIServer(
 #ost,
 #ort,
 #pp,
 #rocesses,
 #equest_handler,
 #assthrough_errors,
 #sl_context,
 #d=fd,
 #
 #lse:
 #eturn BaseWSGIServer(
 #ost, port, app, request_handler, passthrough_errors, ssl_context, fd=fd
 #


def is_running_from_reloader() -> bool:
 #""Checks if the application is running from within the Werkzeug
 #eloader subprocess.

 #. versionadded:: 0.10
 #""
 #eturn os.environ.get("WERKZEUG_RUN_MAIN") == "true"


def run_simple(
 #ostname: str,
 #ort: int,
 #pplication: "WSGIApplication",
 #se_reloader: bool = False,
 #se_debugger: bool = False,
 #se_evalex: bool = True,
 #xtra_files: t.Optional[t.Iterable[str]] = None,
 #xclude_patterns: t.Optional[t.Iterable[str]] = None,
 #eloader_interval: int = 1,
 #eloader_type: str = "auto",
 #hreaded: bool = False,
 #rocesses: int = 1,
 #equest_handler: t.Optional[t.Type[WSGIRequestHandler]] = None,
 #tatic_files: t.Optional[t.Dict[str, t.Union[str, t.Tuple[str, str]]]] = None,
 #assthrough_errors: bool = False,
 #sl_context: t.Optional[_TSSLContextArg] = None,
) -> None:
 #""Start a WSGI application. Optional features include a reloader,
 #ultithreading and fork support.

 #his function has a command-line interface too::

 #ython -m werkzeug.serving --help

 #. versionchanged:: 2.0
 #dded ``exclude_patterns`` parameter.

 #. versionadded:: 0.5
 #static_files` was added to simplify serving of static files as well
 #s `passthrough_errors`.

 #. versionadded:: 0.6
 #upport for SSL was added.

 #. versionadded:: 0.8
 #dded support for automatically loading a SSL context from certificate
 #ile and private key.

 #. versionadded:: 0.9
 #dded command-line interface.

 #. versionadded:: 0.10
 #mproved the reloader and added support for changing the backend
 #hrough the `reloader_type` parameter.  See :ref:`reloader`
 #or more information.

 #. versionchanged:: 0.15
 #ind to a Unix socket by passing a path that starts with
 #`unix://`` as the ``hostname``.

 #param hostname: The host to bind to, for example ``'localhost'``.
 #f the value is a path that starts with ``unix://`` it will bind
 #o a Unix socket instead of a TCP socket..
 #param port: The port for the server.  eg: ``8080``
 #param application: the WSGI application to execute
 #param use_reloader: should the server automatically restart the python
 #rocess if modules were changed?
 #param use_debugger: should the werkzeug debugging system be used?
 #param use_evalex: should the exception evaluation feature be enabled?
 #param extra_files: a list of files the reloader should watch
 #dditionally to the modules.  For example configuration
 #iles.
 #param exclude_patterns: List of :mod:`fnmatch` patterns to ignore
 #hen running the reloader. For example, ignore cache files that
 #houldn't reload when updated.
 #param reloader_interval: the interval for the reloader in seconds.
 #param reloader_type: the type of reloader to use.  The default is
 #uto detection.  Valid values are ``'stat'`` and
 #`'watchdog'``. See :ref:`reloader` for more
 #nformation.
 #param threaded: should the process handle each request in a separate
 #hread?
 #param processes: if greater than 1 then handle each request in a new process
 #p to this maximum number of concurrent processes.
 #param request_handler: optional parameter that can be used to replace
 #he default one.  You can use this to replace it
 #ith a different
 #class:`~BaseHTTPServer.BaseHTTPRequestHandler`
 #ubclass.
 #param static_files: a list or dict of paths for static files.  This works
 #xactly like :class:`SharedDataMiddleware`, it's actually
 #ust wrapping the application in that middleware before
 #erving.
 #param passthrough_errors: set this to `True` to disable the error catching.
 #his means that the server will die on errors but
 #t can be useful to hook debuggers in (pdb etc.)
 #param ssl_context: an SSL context for the connection. Either an
 #class:`ssl.SSLContext`, a tuple in the form
 #`(cert_file, pkey_file)``, the string ``'adhoc'`` if
 #he server should automatically create one, or ``None``
 #o disable SSL (which is the default).
 #""
 #f not isinstance(port, int):
 #aise TypeError("port must be an integer")
 #f use_debugger:
 #rom .debug import DebuggedApplication

 #pplication = DebuggedApplication(application, use_evalex)
 #f static_files:
 #rom .middleware.shared_data import SharedDataMiddleware

 #pplication = SharedDataMiddleware(application, static_files)

 #ef log_startup(sock: socket.socket) -> None:
 #ll_addresses_message = (
 # * Running on all addresses.\n"
 #   WARNING: This is a development server. Do not use it in"
 # a production deployment."
 #

 #f sock.family == af_unix:
 #log("info", " * Running on %s (Press CTRL+C to quit)", hostname)
 #lse:
 #f hostname == "0.0.0.0":
 #log("warning", all_addresses_message)
 #isplay_hostname = get_interface_ip(socket.AF_INET)
 #lif hostname == "::":
 #log("warning", all_addresses_message)
 #isplay_hostname = get_interface_ip(socket.AF_INET6)
 #lse:
 #isplay_hostname = hostname

 #f ":" in display_hostname:
 #isplay_hostname = f"[{display_hostname}]"

 #log(
 #info",
 # * Running on %s://%s:%d/ (Press CTRL+C to quit)",
 #http" if ssl_context is None else "https",
 #isplay_hostname,
 #ock.getsockname()[1],
 #

 #ef inner() -> None:
 #ry:
 #d: t.Optional[int] = int(os.environ["WERKZEUG_SERVER_FD"])
 #xcept (LookupError, ValueError):
 #d = None
 #rv = make_server(
 #ostname,
 #ort,
 #pplication,
 #hreaded,
 #rocesses,
 #equest_handler,
 #assthrough_errors,
 #sl_context,
 #d=fd,
 #
 #f fd is None:
 #og_startup(srv.socket)
 #rv.serve_forever()

 #f use_reloader:
        # If we're not running already in the subprocess that is the
        # reloader we want to open up a socket early to make sure the
        # port is actually available.
 #f not is_running_from_reloader():
 #f port == 0 and not can_open_by_fd:
 #aise ValueError(
 #Cannot bind to a random port with enabled "
 #reloader if the Python interpreter does "
 #not support socket opening by fd."
 #

            # Create and destroy a socket so that any exceptions are
            # raised before we spawn a separate Python interpreter and
            # lose this ability.
 #ddress_family = select_address_family(hostname, port)
 #erver_address = get_sockaddr(hostname, port, address_family)
 # = socket.socket(address_family, socket.SOCK_STREAM)
 #.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
 #.bind(server_address)
 #.set_inheritable(True)

            # If we can open the socket by file descriptor, then we can just
            # reuse this one and our socket will survive the restarts.
 #f can_open_by_fd:
 #s.environ["WERKZEUG_SERVER_FD"] = str(s.fileno())
 #.listen(LISTEN_QUEUE)
 #og_startup(s)
 #lse:
 #.close()
 #f address_family == af_unix:
 #erver_address = t.cast(str, server_address)
 #log("info", "Unlinking %s", server_address)
 #s.unlink(server_address)

 #rom ._reloader import run_with_reloader as _rwr

 #rwr(
 #nner,
 #xtra_files=extra_files,
 #xclude_patterns=exclude_patterns,
 #nterval=reloader_interval,
 #eloader_type=reloader_type,
 #
 #lse:
 #nner()


def run_with_reloader(*args: t.Any, **kwargs: t.Any) -> None:
 #""Run a process with the reloader. This is not a public API, do
 #ot use this function.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1.
 #""
 #rom ._reloader import run_with_reloader as _rwr

 #arnings.warn(
 #
 #'run_with_reloader' is a private API, it will no longer be"
 # accessible in Werkzeug 2.1. Use 'run_simple' instead."
 #,
 #eprecationWarning,
 #tacklevel=2,
 #
 #rwr(*args, **kwargs)


def main() -> None:
 #""A simple command-line interface for :py:func:`run_simple`."""
 #mport argparse
 #rom .utils import import_string

 #log("warning", "This CLI is deprecated and will be removed in version 2.1.")

 #arser = argparse.ArgumentParser(
 #escription="Run the given WSGI application with the development server.",
 #llow_abbrev=False,
 #
 #arser.add_argument(
 #-b",
 #--bind",
 #est="address",
 #elp="The hostname:port the app should listen on.",
 #
 #arser.add_argument(
 #-d",
 #--debug",
 #ction="store_true",
 #elp="Show the interactive debugger for unhandled exceptions.",
 #
 #arser.add_argument(
 #-r",
 #--reload",
 #ction="store_true",
 #elp="Reload the process if modules change.",
 #
 #arser.add_argument(
 #application", help="Application to import and serve, in the form module:app."
 #
 #rgs = parser.parse_args()
 #ostname, port = None, None

 #f args.address:
 #ostname, _, port = args.address.partition(":")

 #un_simple(
 #ostname=hostname or "127.0.0.1",
 #ort=int(port or 5000),
 #pplication=import_string(args.application),
 #se_reloader=args.reload,
 #se_debugger=args.debug,
 #


if __name__ == "__main__":
 #ain()
