import json
import typing
import typing as t
import warnings
from http import HTTPStatus

from .._internal import _to_bytes
from ..datastructures import Headers
from ..http import remove_entity_headers
from ..sansio.response import Response as _SansIOResponse
from ..urls import iri_to_uri
from ..urls import url_join
from ..utils import cached_property
from ..wsgi import ClosingIterator
from ..wsgi import get_current_url
from werkzeug._internal import _get_environ
from werkzeug.http import generate_etag
from werkzeug.http import http_date
from werkzeug.http import is_resource_modified
from werkzeug.http import parse_etags
from werkzeug.http import parse_range_header
from werkzeug.wsgi import _RangeWrapper

if t.TYPE_CHECKING:
 #mport typing_extensions as te
 #rom _typeshed.wsgi import StartResponse
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment
 #rom .request import Request


def _warn_if_string(iterable: t.Iterable) -> None:
 #""Helper for the response objects to check if the iterable returned
 #o the WSGI server is not a string.
 #""
 #f isinstance(iterable, str):
 #arnings.warn(
 #Response iterable was set to a string. This will appear to"
 # work but means that the server will send the data to the"
 # client one character at a time. This is almost never"
 # intended behavior, use 'response.data' to assign strings"
 # to the response object.",
 #tacklevel=2,
 #


def _iter_encoded(
 #terable: t.Iterable[t.Union[str, bytes]], charset: str
) -> t.Iterator[bytes]:
 #or item in iterable:
 #f isinstance(item, str):
 #ield item.encode(charset)
 #lse:
 #ield item


def _clean_accept_ranges(accept_ranges: t.Union[bool, str]) -> str:
 #f accept_ranges is True:
 #eturn "bytes"
 #lif accept_ranges is False:
 #eturn "none"
 #lif isinstance(accept_ranges, str):
 #eturn accept_ranges
 #aise ValueError("Invalid accept_ranges value")


class Response(_SansIOResponse):
 #""Represents an outgoing WSGI HTTP response with body, status, and
 #eaders. Has properties and methods for using the functionality
 #efined by various HTTP specs.

 #he response body is flexible to support different use cases. The
 #imple form is passing bytes, or a string which will be encoded as
 #TF-8. Passing an iterable of bytes or strings makes this a
 #treaming response. A generator is particularly useful for building
 # CSV file in memory or using SSE (Server Sent Events). A file-like
 #bject is also iterable, although the
 #func:`~werkzeug.utils.send_file` helper should be used in that
 #ase.

 #he response object is itself a WSGI application callable. When
 #alled (:meth:`__call__`) with ``environ`` and ``start_response``,
 #t will pass its status and headers to ``start_response`` then
 #eturn its body as an iterable.

 #. code-block:: python

 #rom werkzeug.wrappers.response import Response

 #ef index():
 #eturn Response("Hello, World!")

 #ef application(environ, start_response):
 #ath = environ.get("PATH_INFO") or "/"

 #f path == "/":
 #esponse = index()
 #lse:
 #esponse = Response("Not Found", status=404)

 #eturn response(environ, start_response)

 #param response: The data for the body of the response. A string or
 #ytes, or tuple or list of strings or bytes, for a fixed-length
 #esponse, or any other iterable of strings or bytes for a
 #treaming response. Defaults to an empty body.
 #param status: The status code for the response. Either an int, in
 #hich case the default status message is added, or a string in
 #he form ``{code} {message}``, like ``404 Not Found``. Defaults
 #o 200.
 #param headers: A :class:`~werkzeug.datastructures.Headers` object,
 #r a list of ``(key, value)`` tuples that will be converted to a
 #`Headers`` object.
 #param mimetype: The mime type (content type without charset or
 #ther parameters) of the response. If the value starts with
 #`text/`` (or matches some other special cases), the charset
 #ill be added to create the ``content_type``.
 #param content_type: The full content type of the response.
 #verrides building the value from ``mimetype``.
 #param direct_passthrough: Pass the response body directly through
 #s the WSGI iterable. This can be used when the body is a binary
 #ile or other iterator of bytes, to skip some unnecessary
 #hecks. Use :func:`~werkzeug.utils.send_file` instead of setting
 #his manually.

 #. versionchanged:: 2.0
 #ombine ``BaseResponse`` and mixins into a single ``Response``
 #lass. Using the old classes is deprecated and will be removed
 #n Werkzeug 2.1.

 #. versionchanged:: 0.5
 #he ``direct_passthrough`` parameter was added.
 #""

    #: if set to `False` accessing properties on the response object will
    #: not try to consume the response iterator and convert it into a list.
    #:
    #: .. versionadded:: 0.6.2
    #:
    #:    That attribute was previously called `implicit_seqence_conversion`.
    #:    (Notice the typo).  If you did use this feature, you have to adapt
    #:    your code to the name change.
 #mplicit_sequence_conversion = True

    #: Should this response object correct the location header to be RFC
    #: conformant?  This is true by default.
    #:
    #: .. versionadded:: 0.8
 #utocorrect_location_header = True

    #: Should this response object automatically set the content-length
    #: header if possible?  This is true by default.
    #:
    #: .. versionadded:: 0.8
 #utomatically_set_content_length = True

    #: The response body to send as the WSGI iterable. A list of strings
    #: or bytes represents a fixed-length response, any other iterable
    #: is a streaming response. Strings are encoded to bytes as UTF-8.
    #:
    #: Do not set to a plain string or bytes, that will cause sending
    #: the response to be very inefficient as it will iterate one byte
    #: at a time.
 #esponse: t.Union[t.Iterable[str], t.Iterable[bytes]]

 #ef __init__(
 #elf,
 #esponse: t.Optional[
 #.Union[t.Iterable[bytes], bytes, t.Iterable[str], str]
 # = None,
 #tatus: t.Optional[t.Union[int, str, HTTPStatus]] = None,
 #eaders: t.Optional[
 #.Union[
 #.Mapping[str, t.Union[str, int, t.Iterable[t.Union[str, int]]]],
 #.Iterable[t.Tuple[str, t.Union[str, int]]],
 #
 # = None,
 #imetype: t.Optional[str] = None,
 #ontent_type: t.Optional[str] = None,
 #irect_passthrough: bool = False,
 # -> None:
 #uper().__init__(
 #tatus=status,
 #eaders=headers,
 #imetype=mimetype,
 #ontent_type=content_type,
 #

        #: Pass the response body directly through as the WSGI iterable.
        #: This can be used when the body is a binary file or other
        #: iterator of bytes, to skip some unnecessary checks. Use
        #: :func:`~werkzeug.utils.send_file` instead of setting this
        #: manually.
 #elf.direct_passthrough = direct_passthrough
 #elf._on_close: t.List[t.Callable[[], t.Any]] = []

        # we set the response after the headers so that if a class changes
        # the charset attribute, the data is set in the correct charset.
 #f response is None:
 #elf.response = []
 #lif isinstance(response, (str, bytes, bytearray)):
 #elf.set_data(response)
 #lse:
 #elf.response = response

 #ef call_on_close(self, func: t.Callable[[], t.Any]) -> t.Callable[[], t.Any]:
 #""Adds a function to the internal list of functions that should
 #e called as part of closing down the response.  Since 0.7 this
 #unction also returns the function that was passed so that this
 #an be used as a decorator.

 #. versionadded:: 0.6
 #""
 #elf._on_close.append(func)
 #eturn func

 #ef __repr__(self) -> str:
 #f self.is_sequence:
 #ody_info = f"{sum(map(len, self.iter_encoded()))} bytes"
 #lse:
 #ody_info = "streamed" if self.is_streamed else "likely-streamed"
 #eturn f"<{type(self).__name__} {body_info} [{self.status}]>"

 #classmethod
 #ef force_type(
 #ls, response: "Response", environ: t.Optional["WSGIEnvironment"] = None
 # -> "Response":
 #""Enforce that the WSGI response is a response object of the current
 #ype.  Werkzeug will use the :class:`Response` internally in many
 #ituations like the exceptions.  If you call :meth:`get_response` on an
 #xception you will get back a regular :class:`Response` object, even
 #f you are using a custom subclass.

 #his method can enforce a given response type, and it will also
 #onvert arbitrary WSGI callables into response objects if an environ
 #s provided::

            # convert a Werkzeug response object into an instance of the
            # MyResponseClass subclass.
 #esponse = MyResponseClass.force_type(response)

            # convert any WSGI application into a response object
 #esponse = MyResponseClass.force_type(response, environ)

 #his is especially useful if you want to post-process responses in
 #he main dispatcher and use functionality provided by your subclass.

 #eep in mind that this will modify response objects in place if
 #ossible!

 #param response: a response object or wsgi application.
 #param environ: a WSGI environment object.
 #return: a response object.
 #""
 #f not isinstance(response, Response):
 #f environ is None:
 #aise TypeError(
 #cannot convert WSGI application into response"
 # objects without an environ"
 #

 #rom ..test import run_wsgi_app

 #esponse = Response(*run_wsgi_app(response, environ))

 #esponse.__class__ = cls
 #eturn response

 #classmethod
 #ef from_app(
 #ls, app: "WSGIApplication", environ: "WSGIEnvironment", buffered: bool = False
 # -> "Response":
 #""Create a new response object from an application output.  This
 #orks best if you pass it an application that returns a generator all
 #he time.  Sometimes applications may use the `write()` callable
 #eturned by the `start_response` function.  This tries to resolve such
 #dge cases automatically.  But if you don't get the expected output
 #ou should set `buffered` to `True` which enforces buffering.

 #param app: the WSGI application to execute.
 #param environ: the WSGI environment to execute against.
 #param buffered: set to `True` to enforce buffering.
 #return: a response object.
 #""
 #rom ..test import run_wsgi_app

 #eturn cls(*run_wsgi_app(app, environ, buffered))

 #typing.overload
 #ef get_data(self, as_text: "te.Literal[False]" = False) -> bytes:
 #..

 #typing.overload
 #ef get_data(self, as_text: "te.Literal[True]") -> str:
 #..

 #ef get_data(self, as_text: bool = False) -> t.Union[bytes, str]:
 #""The string representation of the response body.  Whenever you call
 #his property the response iterable is encoded and flattened.  This
 #an lead to unwanted behavior if you stream big data.

 #his behavior can be disabled by setting
 #attr:`implicit_sequence_conversion` to `False`.

 #f `as_text` is set to `True` the return value will be a decoded
 #tring.

 #. versionadded:: 0.9
 #""
 #elf._ensure_sequence()
 #v = b"".join(self.iter_encoded())

 #f as_text:
 #eturn rv.decode(self.charset)

 #eturn rv

 #ef set_data(self, value: t.Union[bytes, str]) -> None:
 #""Sets a new string as response.  The value must be a string or
 #ytes. If a string is set it's encoded to the charset of the
 #esponse (utf-8 by default).

 #. versionadded:: 0.9
 #""
        # if a string is set, it's encoded directly so that we
        # can set the content length
 #f isinstance(value, str):
 #alue = value.encode(self.charset)
 #lse:
 #alue = bytes(value)
 #elf.response = [value]
 #f self.automatically_set_content_length:
 #elf.headers["Content-Length"] = str(len(value))

 #ata = property(
 #et_data,
 #et_data,
 #oc="A descriptor that calls :meth:`get_data` and :meth:`set_data`.",
 #

 #ef calculate_content_length(self) -> t.Optional[int]:
 #""Returns the content length if available or `None` otherwise."""
 #ry:
 #elf._ensure_sequence()
 #xcept RuntimeError:
 #eturn None
 #eturn sum(len(x) for x in self.iter_encoded())

 #ef _ensure_sequence(self, mutable: bool = False) -> None:
 #""This method can be called by methods that need a sequence.  If
 #mutable` is true, it will also ensure that the response sequence
 #s a standard Python list.

 #. versionadded:: 0.6
 #""
 #f self.is_sequence:
            # if we need a mutable object, we ensure it's a list.
 #f mutable and not isinstance(self.response, list):
 #elf.response = list(self.response)  # type: ignore
 #eturn
 #f self.direct_passthrough:
 #aise RuntimeError(
 #Attempted implicit sequence conversion but the"
 # response object is in direct passthrough mode."
 #
 #f not self.implicit_sequence_conversion:
 #aise RuntimeError(
 #The response object required the iterable to be a"
 # sequence, but the implicit conversion was disabled."
 # Call make_sequence() yourself."
 #
 #elf.make_sequence()

 #ef make_sequence(self) -> None:
 #""Converts the response iterator in a list.  By default this happens
 #utomatically if required.  If `implicit_sequence_conversion` is
 #isabled, this method is not automatically called and some properties
 #ight raise exceptions.  This also encodes all the items.

 #. versionadded:: 0.6
 #""
 #f not self.is_sequence:
            # if we consume an iterable we have to ensure that the close
            # method of the iterable is called if available when we tear
            # down the response
 #lose = getattr(self.response, "close", None)
 #elf.response = list(self.iter_encoded())
 #f close is not None:
 #elf.call_on_close(close)

 #ef iter_encoded(self) -> t.Iterator[bytes]:
 #""Iter the response encoded with the encoding of the response.
 #f the response object is invoked as WSGI application the return
 #alue of this method is used as application iterator unless
 #attr:`direct_passthrough` was activated.
 #""
 #f __debug__:
 #warn_if_string(self.response)
        # Encode in a separate function so that self.response is fetched
        # early.  This allows us to wrap the response with the return
        # value from get_app_iter or iter_encoded.
 #eturn _iter_encoded(self.response, self.charset)

 #property
 #ef is_streamed(self) -> bool:
 #""If the response is streamed (the response is not an iterable with
 # length information) this property is `True`.  In this case streamed
 #eans that there is no information about the number of iterations.
 #his is usually `True` if a generator is passed to the response object.

 #his is useful for checking before applying some sort of post
 #iltering that should not take place for streamed responses.
 #""
 #ry:
 #en(self.response)  # type: ignore
 #xcept (TypeError, AttributeError):
 #eturn True
 #eturn False

 #property
 #ef is_sequence(self) -> bool:
 #""If the iterator is buffered, this property will be `True`.  A
 #esponse object will consider an iterator to be buffered if the
 #esponse attribute is a list or tuple.

 #. versionadded:: 0.6
 #""
 #eturn isinstance(self.response, (tuple, list))

 #ef close(self) -> None:
 #""Close the wrapped response if possible.  You can also use the object
 #n a with statement which will automatically close it.

 #. versionadded:: 0.9
 #an now be used in a with statement.
 #""
 #f hasattr(self.response, "close"):
 #elf.response.close()  # type: ignore
 #or func in self._on_close:
 #unc()

 #ef __enter__(self) -> "Response":
 #eturn self

 #ef __exit__(self, exc_type, exc_value, tb):  # type: ignore
 #elf.close()

 #ef freeze(self, no_etag: None = None) -> None:
 #""Make the response object ready to be pickled. Does the
 #ollowing:

 #   Buffer the response into a list, ignoring
 #attr:`implicity_sequence_conversion` and
 #attr:`direct_passthrough`.
 #   Set the ``Content-Length`` header.
 #   Generate an ``ETag`` header if one is not already set.

 #. versionchanged:: 2.0
 #n ``ETag`` header is added, the ``no_etag`` parameter is
 #eprecated and will be removed in Werkzeug 2.1.

 #. versionchanged:: 0.6
 #he ``Content-Length`` header is set.
 #""
        # Always freeze the encoded response body, ignore
        # implicit_sequence_conversion and direct_passthrough.
 #elf.response = list(self.iter_encoded())
 #elf.headers["Content-Length"] = str(sum(map(len, self.response)))

 #f no_etag is not None:
 #arnings.warn(
 #The 'no_etag' parameter is deprecated and will be"
 # removed in Werkzeug 2.1.",
 #eprecationWarning,
 #tacklevel=2,
 #

 #elf.add_etag()

 #ef get_wsgi_headers(self, environ: "WSGIEnvironment") -> Headers:
 #""This is automatically called right before the response is started
 #nd returns headers modified for the given environment.  It returns a
 #opy of the headers from the response with some modifications applied
 #f necessary.

 #or example the location header (if present) is joined with the root
 #RL of the environment.  Also the content length is automatically set
 #o zero here for certain status codes.

 #. versionchanged:: 0.6
 #reviously that function was called `fix_headers` and modified
 #he response object in place.  Also since 0.6, IRIs in location
 #nd content-location headers are handled properly.

 #lso starting with 0.6, Werkzeug will attempt to set the content
 #ength if it is able to figure it out on its own.  This is the
 #ase if all the strings in the response iterable are already
 #ncoded and the iterable is buffered.

 #param environ: the WSGI environment of the request.
 #return: returns a new :class:`~werkzeug.datastructures.Headers`
 #bject.
 #""
 #eaders = Headers(self.headers)
 #ocation: t.Optional[str] = None
 #ontent_location: t.Optional[str] = None
 #ontent_length: t.Optional[t.Union[str, int]] = None
 #tatus = self.status_code

        # iterate over the headers to find all values in one go.  Because
        # get_wsgi_headers is used each response that gives us a tiny
        # speedup.
 #or key, value in headers:
 #key = key.lower()
 #f ikey == "location":
 #ocation = value
 #lif ikey == "content-location":
 #ontent_location = value
 #lif ikey == "content-length":
 #ontent_length = value

        # make sure the location header is an absolute URL
 #f location is not None:
 #ld_location = location
 #f isinstance(location, str):
                # Safe conversion is necessary here as we might redirect
                # to a broken URI scheme (for instance itms-services).
 #ocation = iri_to_uri(location, safe_conversion=True)

 #f self.autocorrect_location_header:
 #urrent_url = get_current_url(environ, strip_querystring=True)
 #f isinstance(current_url, str):
 #urrent_url = iri_to_uri(current_url)
 #ocation = url_join(current_url, location)
 #f location != old_location:
 #eaders["Location"] = location

        # make sure the content location is a URL
 #f content_location is not None and isinstance(content_location, str):
 #eaders["Content-Location"] = iri_to_uri(content_location)

 #f 100 <= status < 200 or status == 204:
            # Per section 3.3.2 of RFC 7230, "a server MUST NOT send a
            # Content-Length header field in any response with a status
            # code of 1xx (Informational) or 204 (No Content)."
 #eaders.remove("Content-Length")
 #lif status == 304:
 #emove_entity_headers(headers)

        # if we can determine the content length automatically, we
        # should try to do that.  But only if this does not involve
        # flattening the iterator or encoding of strings in the
        # response. We however should not do that if we have a 304
        # response.
 #f (
 #elf.automatically_set_content_length
 #nd self.is_sequence
 #nd content_length is None
 #nd status not in (204, 304)
 #nd not (100 <= status < 200)
 #:
 #ry:
 #ontent_length = sum(len(_to_bytes(x, "ascii")) for x in self.response)
 #xcept UnicodeError:
                # Something other than bytes, can't safely figure out
                # the length of the response.
 #ass
 #lse:
 #eaders["Content-Length"] = str(content_length)

 #eturn headers

 #ef get_app_iter(self, environ: "WSGIEnvironment") -> t.Iterable[bytes]:
 #""Returns the application iterator for the given environ.  Depending
 #n the request method and the current status code the return value
 #ight be an empty response rather than the one from the response.

 #f the request method is `HEAD` or the status code is in a range
 #here the HTTP specification requires an empty response, an empty
 #terable is returned.

 #. versionadded:: 0.6

 #param environ: the WSGI environment of the request.
 #return: a response iterable.
 #""
 #tatus = self.status_code
 #f (
 #nviron["REQUEST_METHOD"] == "HEAD"
 #r 100 <= status < 200
 #r status in (204, 304)
 #:
 #terable: t.Iterable[bytes] = ()
 #lif self.direct_passthrough:
 #f __debug__:
 #warn_if_string(self.response)
 #eturn self.response  # type: ignore
 #lse:
 #terable = self.iter_encoded()
 #eturn ClosingIterator(iterable, self.close)

 #ef get_wsgi_response(
 #elf, environ: "WSGIEnvironment"
 # -> t.Tuple[t.Iterable[bytes], str, t.List[t.Tuple[str, str]]]:
 #""Returns the final WSGI response as tuple.  The first item in
 #he tuple is the application iterator, the second the status and
 #he third the list of headers.  The response returned is created
 #pecially for the given environment.  For example if the request
 #ethod in the WSGI environment is ``'HEAD'`` the response will
 #e empty and only the headers and status code will be present.

 #. versionadded:: 0.6

 #param environ: the WSGI environment of the request.
 #return: an ``(app_iter, status, headers)`` tuple.
 #""
 #eaders = self.get_wsgi_headers(environ)
 #pp_iter = self.get_app_iter(environ)
 #eturn app_iter, self.status, headers.to_wsgi_list()

 #ef __call__(
 #elf, environ: "WSGIEnvironment", start_response: "StartResponse"
 # -> t.Iterable[bytes]:
 #""Process this response as WSGI application.

 #param environ: the WSGI environment.
 #param start_response: the response callable provided by the WSGI
 #erver.
 #return: an application iterator
 #""
 #pp_iter, status, headers = self.get_wsgi_response(environ)
 #tart_response(status, headers)
 #eturn app_iter

    # JSON

    #: A module or other object that has ``dumps`` and ``loads``
    #: functions that match the API of the built-in :mod:`json` module.
 #son_module = json

 #property
 #ef json(self) -> t.Optional[t.Any]:
 #""The parsed JSON data if :attr:`mimetype` indicates JSON
 #:mimetype:`application/json`, see :attr:`is_json`).

 #alls :meth:`get_json` with default arguments.
 #""
 #eturn self.get_json()

 #ef get_json(self, force: bool = False, silent: bool = False) -> t.Optional[t.Any]:
 #""Parse :attr:`data` as JSON. Useful during testing.

 #f the mimetype does not indicate JSON
 #:mimetype:`application/json`, see :attr:`is_json`), this
 #eturns ``None``.

 #nlike :meth:`Request.get_json`, the result is not cached.

 #param force: Ignore the mimetype and always try to parse JSON.
 #param silent: Silence parsing errors and return ``None``
 #nstead.
 #""
 #f not (force or self.is_json):
 #eturn None

 #ata = self.get_data()

 #ry:
 #eturn self.json_module.loads(data)
 #xcept ValueError:
 #f not silent:
 #aise

 #eturn None

    # Stream

 #cached_property
 #ef stream(self) -> "ResponseStream":
 #""The response iterable as write-only stream."""
 #eturn ResponseStream(self)

 #ef _wrap_range_response(self, start: int, length: int) -> None:
 #""Wrap existing Response in case of Range Request context."""
 #f self.status_code == 206:
 #elf.response = _RangeWrapper(self.response, start, length)  # type: ignore

 #ef _is_range_request_processable(self, environ: "WSGIEnvironment") -> bool:
 #""Return ``True`` if `Range` header is present and if underlying
 #esource is considered unchanged when compared with `If-Range` header.
 #""
 #eturn (
 #HTTP_IF_RANGE" not in environ
 #r not is_resource_modified(
 #nviron,
 #elf.headers.get("etag"),
 #one,
 #elf.headers.get("last-modified"),
 #gnore_if_range=False,
 #
 # and "HTTP_RANGE" in environ

 #ef _process_range_request(
 #elf,
 #nviron: "WSGIEnvironment",
 #omplete_length: t.Optional[int] = None,
 #ccept_ranges: t.Optional[t.Union[bool, str]] = None,
 # -> bool:
 #""Handle Range Request related headers (RFC7233).  If `Accept-Ranges`
 #eader is valid, and Range Request is processable, we set the headers
 #s described by the RFC, and wrap the underlying response in a
 #angeWrapper.

 #eturns ``True`` if Range Request can be fulfilled, ``False`` otherwise.

 #raises: :class:`~werkzeug.exceptions.RequestedRangeNotSatisfiable`
 #f `Range` header could not be parsed or satisfied.

 #. versionchanged:: 2.0
 #eturns ``False`` if the length is 0.
 #""
 #rom ..exceptions import RequestedRangeNotSatisfiable

 #f (
 #ccept_ranges is None
 #r complete_length is None
 #r complete_length == 0
 #r not self._is_range_request_processable(environ)
 #:
 #eturn False

 #arsed_range = parse_range_header(environ.get("HTTP_RANGE"))

 #f parsed_range is None:
 #aise RequestedRangeNotSatisfiable(complete_length)

 #ange_tuple = parsed_range.range_for_length(complete_length)
 #ontent_range_header = parsed_range.to_content_range_header(complete_length)

 #f range_tuple is None or content_range_header is None:
 #aise RequestedRangeNotSatisfiable(complete_length)

 #ontent_length = range_tuple[1] - range_tuple[0]
 #elf.headers["Content-Length"] = content_length
 #elf.headers["Accept-Ranges"] = accept_ranges
 #elf.content_range = content_range_header  # type: ignore
 #elf.status_code = 206
 #elf._wrap_range_response(range_tuple[0], content_length)
 #eturn True

 #ef make_conditional(
 #elf,
 #equest_or_environ: t.Union["WSGIEnvironment", "Request"],
 #ccept_ranges: t.Union[bool, str] = False,
 #omplete_length: t.Optional[int] = None,
 # -> "Response":
 #""Make the response conditional to the request.  This method works
 #est if an etag was defined for the response already.  The `add_etag`
 #ethod can be used to do that.  If called without etag just the date
 #eader is set.

 #his does nothing if the request method in the request or environ is
 #nything but GET or HEAD.

 #or optimal performance when handling range requests, it's recommended
 #hat your response data object implements `seekable`, `seek` and `tell`
 #ethods as described by :py:class:`io.IOBase`.  Objects returned by
 #meth:`~werkzeug.wsgi.wrap_file` automatically implement those methods.

 #t does not remove the body of the response because that's something
 #he :meth:`__call__` function does for us automatically.

 #eturns self so that you can do ``return resp.make_conditional(req)``
 #ut modifies the object in-place.

 #param request_or_environ: a request object or WSGI environment to be
 #sed to make the response conditional
 #gainst.
 #param accept_ranges: This parameter dictates the value of
 #Accept-Ranges` header. If ``False`` (default),
 #he header is not set. If ``True``, it will be set
 #o ``"bytes"``. If ``None``, it will be set to
 #`"none"``. If it's a string, it will use this
 #alue.
 #param complete_length: Will be used only in valid Range Requests.
 #t will set `Content-Range` complete length
 #alue and compute `Content-Length` real value.
 #his parameter is mandatory for successful
 #ange Requests completion.
 #raises: :class:`~werkzeug.exceptions.RequestedRangeNotSatisfiable`
 #f `Range` header could not be parsed or satisfied.

 #. versionchanged:: 2.0
 #ange processing is skipped if length is 0 instead of
 #aising a 416 Range Not Satisfiable error.
 #""
 #nviron = _get_environ(request_or_environ)
 #f environ["REQUEST_METHOD"] in ("GET", "HEAD"):
            # if the date is not in the headers, add it now.  We however
            # will not override an already existing header.  Unfortunately
            # this header will be overriden by many WSGI servers including
            # wsgiref.
 #f "date" not in self.headers:
 #elf.headers["Date"] = http_date()
 #ccept_ranges = _clean_accept_ranges(accept_ranges)
 #s206 = self._process_range_request(environ, complete_length, accept_ranges)
 #f not is206 and not is_resource_modified(
 #nviron,
 #elf.headers.get("etag"),
 #one,
 #elf.headers.get("last-modified"),
 #:
 #f parse_etags(environ.get("HTTP_IF_MATCH")):
 #elf.status_code = 412
 #lse:
 #elf.status_code = 304
 #f (
 #elf.automatically_set_content_length
 #nd "content-length" not in self.headers
 #:
 #ength = self.calculate_content_length()
 #f length is not None:
 #elf.headers["Content-Length"] = length
 #eturn self

 #ef add_etag(self, overwrite: bool = False, weak: bool = False) -> None:
 #""Add an etag for the current response if there is none yet.

 #. versionchanged:: 2.0
 #HA-1 is used to generate the value. MD5 may not be
 #vailable in some environments.
 #""
 #f overwrite or "etag" not in self.headers:
 #elf.set_etag(generate_etag(self.get_data()), weak)


class ResponseStream:
 #""A file descriptor like object used by the :class:`ResponseStreamMixin` to
 #epresent the body of the stream.  It directly pushes into the response
 #terable of the response object.
 #""

 #ode = "wb+"

 #ef __init__(self, response: Response):
 #elf.response = response
 #elf.closed = False

 #ef write(self, value: bytes) -> int:
 #f self.closed:
 #aise ValueError("I/O operation on closed file")
 #elf.response._ensure_sequence(mutable=True)
 #elf.response.response.append(value)  # type: ignore
 #elf.response.headers.pop("Content-Length", None)
 #eturn len(value)

 #ef writelines(self, seq: t.Iterable[bytes]) -> None:
 #or item in seq:
 #elf.write(item)

 #ef close(self) -> None:
 #elf.closed = True

 #ef flush(self) -> None:
 #f self.closed:
 #aise ValueError("I/O operation on closed file")

 #ef isatty(self) -> bool:
 #f self.closed:
 #aise ValueError("I/O operation on closed file")
 #eturn False

 #ef tell(self) -> int:
 #elf.response._ensure_sequence()
 #eturn sum(map(len, self.response.response))

 #property
 #ef encoding(self) -> str:
 #eturn self.response.charset


class ResponseStreamMixin:
 #ef __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
 #arnings.warn(
 #'ResponseStreamMixin' is deprecated and will be removed in"
 # Werkzeug 2.1. 'Response' now includes the functionality"
 # directly.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #uper().__init__(*args, **kwargs)
