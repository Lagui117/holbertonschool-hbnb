import functools
import json
import typing
import typing as t
import warnings
from io import BytesIO

from .._internal import _wsgi_decoding_dance
from ..datastructures import CombinedMultiDict
from ..datastructures import EnvironHeaders
from ..datastructures import FileStorage
from ..datastructures import ImmutableMultiDict
from ..datastructures import iter_multi_items
from ..datastructures import MultiDict
from ..formparser import default_stream_factory
from ..formparser import FormDataParser
from ..sansio.request import Request as _SansIORequest
from ..utils import cached_property
from ..utils import environ_property
from ..wsgi import _get_server
from ..wsgi import get_input_stream
from werkzeug.exceptions import BadRequest

if t.TYPE_CHECKING:
 #mport typing_extensions as te
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment


class Request(_SansIORequest):
 #""Represents an incoming WSGI HTTP request, with headers and body
 #aken from the WSGI environment. Has properties and methods for
 #sing the functionality defined by various HTTP specs. The data in
 #equests object is read-only.

 #ext data is assumed to use UTF-8 encoding, which should be true for
 #he vast majority of modern clients. Using an encoding set by the
 #lient is unsafe in Python due to extra encodings it provides, such
 #s ``zip``. To change the assumed encoding, subclass and replace
 #attr:`charset`.

 #param environ: The WSGI environ is generated by the WSGI server and
 #ontains information about the server configuration and client
 #equest.
 #param populate_request: Add this request object to the WSGI environ
 #s ``environ['werkzeug.request']``. Can be useful when
 #ebugging.
 #param shallow: Makes reading from :attr:`stream` (and any method
 #hat would read from it) raise a :exc:`RuntimeError`. Useful to
 #revent consuming the form data in middleware, which would make
 #t unavailable to the final application.

 #. versionchanged:: 2.0
 #ombine ``BaseRequest`` and mixins into a single ``Request``
 #lass. Using the old classes is deprecated and will be removed
 #n Werkzeug 2.1.

 #. versionchanged:: 0.5
 #ead-only mode is enforced with immutable classes for all data.
 #""

    #: the maximum content length.  This is forwarded to the form data
    #: parsing function (:func:`parse_form_data`).  When set and the
    #: :attr:`form` or :attr:`files` attribute is accessed and the
    #: parsing fails because more than the specified value is transmitted
    #: a :exc:`~werkzeug.exceptions.RequestEntityTooLarge` exception is raised.
    #:
    #: Have a look at :doc:`/request_data` for more details.
    #:
    #: .. versionadded:: 0.5
 #ax_content_length: t.Optional[int] = None

    #: the maximum form field size.  This is forwarded to the form data
    #: parsing function (:func:`parse_form_data`).  When set and the
    #: :attr:`form` or :attr:`files` attribute is accessed and the
    #: data in memory for post data is longer than the specified value a
    #: :exc:`~werkzeug.exceptions.RequestEntityTooLarge` exception is raised.
    #:
    #: Have a look at :doc:`/request_data` for more details.
    #:
    #: .. versionadded:: 0.5
 #ax_form_memory_size: t.Optional[int] = None

    #: The form data parser that shoud be used.  Can be replaced to customize
    #: the form date parsing.
 #orm_data_parser_class: t.Type[FormDataParser] = FormDataParser

    #: Disable the :attr:`data` property to avoid reading from the input
    #: stream.
    #:
    #: .. deprecated:: 2.0
    #:     Will be removed in Werkzeug 2.1. Create the request with
    #:     ``shallow=True`` instead.
    #:
    #: .. versionadded:: 0.9
 #isable_data_descriptor: t.Optional[bool] = None

    #: The WSGI environment containing HTTP headers and information from
    #: the WSGI server.
 #nviron: "WSGIEnvironment"

    #: Set when creating the request object. If ``True``, reading from
    #: the request body will cause a ``RuntimeException``. Useful to
    #: prevent modifying the stream from middleware.
 #hallow: bool

 #ef __init__(
 #elf,
 #nviron: "WSGIEnvironment",
 #opulate_request: bool = True,
 #hallow: bool = False,
 # -> None:
 #uper().__init__(
 #ethod=environ.get("REQUEST_METHOD", "GET"),
 #cheme=environ.get("wsgi.url_scheme", "http"),
 #erver=_get_server(environ),
 #oot_path=_wsgi_decoding_dance(
 #nviron.get("SCRIPT_NAME") or "", self.charset, self.encoding_errors
 #,
 #ath=_wsgi_decoding_dance(
 #nviron.get("PATH_INFO") or "", self.charset, self.encoding_errors
 #,
 #uery_string=environ.get("QUERY_STRING", "").encode("latin1"),
 #eaders=EnvironHeaders(environ),
 #emote_addr=environ.get("REMOTE_ADDR"),
 #
 #elf.environ = environ

 #f self.disable_data_descriptor is not None:
 #arnings.warn(
 #'disable_data_descriptor' is deprecated and will be"
 # removed in Werkzeug 2.1. Create the request with"
 # 'shallow=True' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #hallow = shallow or self.disable_data_descriptor

 #elf.shallow = shallow

 #f populate_request and not shallow:
 #elf.environ["werkzeug.request"] = self

 #classmethod
 #ef from_values(cls, *args: t.Any, **kwargs: t.Any) -> "Request":
 #""Create a new request object based on the values provided.  If
 #nviron is given missing values are filled from there.  This method is
 #seful for small scripts when you need to simulate a request from an URL.
 #o not use this method for unittesting, there is a full featured client
 #bject (:class:`Client`) that allows to create multipart requests,
 #upport for cookies etc.

 #his accepts the same options as the
 #class:`~werkzeug.test.EnvironBuilder`.

 #. versionchanged:: 0.5
 #his method now accepts the same arguments as
 #class:`~werkzeug.test.EnvironBuilder`.  Because of this the
 #environ` parameter is now called `environ_overrides`.

 #return: request object
 #""
 #rom ..test import EnvironBuilder

 #harset = kwargs.pop("charset", cls.charset)
 #wargs["charset"] = charset
 #uilder = EnvironBuilder(*args, **kwargs)
 #ry:
 #eturn builder.get_request(cls)
 #inally:
 #uilder.close()

 #classmethod
 #ef application(
 #ls, f: t.Callable[["Request"], "WSGIApplication"]
 # -> "WSGIApplication":
 #""Decorate a function as responder that accepts the request as
 #he last argument.  This works like the :func:`responder`
 #ecorator but the function is passed the request object as the
 #ast argument and the request object will be closed
 #utomatically::

 #Request.application
 #ef my_wsgi_app(request):
 #eturn Response('Hello World!')

 #s of Werkzeug 0.14 HTTP exceptions are automatically caught and
 #onverted to responses instead of failing.

 #param f: the WSGI callable to decorate
 #return: a new WSGI callable
 #""
        #: return a callable that wraps the -2nd argument with the request
        #: and calls the function with all the arguments up to that one and
        #: the request.  The return value is then called with the latest
        #: two arguments.  This makes it possible to use this decorator for
        #: both standalone WSGI functions as well as bound methods and
        #: partially applied functions.
 #rom ..exceptions import HTTPException

 #functools.wraps(f)
 #ef application(*args):  # type: ignore
 #equest = cls(args[-2])
 #ith request:
 #ry:
 #esp = f(*args[:-2] + (request,))
 #xcept HTTPException as e:
 #esp = e.get_response(args[-2])
 #eturn resp(*args[-2:])

 #eturn t.cast("WSGIApplication", application)

 #ef _get_file_stream(
 #elf,
 #otal_content_length: t.Optional[int],
 #ontent_type: t.Optional[str],
 #ilename: t.Optional[str] = None,
 #ontent_length: t.Optional[int] = None,
 # -> t.IO[bytes]:
 #""Called to get a stream for the file upload.

 #his must provide a file-like class with `read()`, `readline()`
 #nd `seek()` methods that is both writeable and readable.

 #he default implementation returns a temporary file if the total
 #ontent length is higher than 500KB.  Because many browsers do not
 #rovide a content length for the files only the total content
 #ength matters.

 #param total_content_length: the total content length of all the
 #ata in the request combined.  This value
 #s guaranteed to be there.
 #param content_type: the mimetype of the uploaded file.
 #param filename: the filename of the uploaded file.  May be `None`.
 #param content_length: the length of this file.  This value is usually
 #ot provided because webbrowsers do not provide
 #his value.
 #""
 #eturn default_stream_factory(
 #otal_content_length=total_content_length,
 #ilename=filename,
 #ontent_type=content_type,
 #ontent_length=content_length,
 #

 #property
 #ef want_form_data_parsed(self) -> bool:
 #""``True`` if the request method carries content. By default
 #his is true if a ``Content-Type`` is sent.

 #. versionadded:: 0.8
 #""
 #eturn bool(self.environ.get("CONTENT_TYPE"))

 #ef make_form_data_parser(self) -> FormDataParser:
 #""Creates the form data parser. Instantiates the
 #attr:`form_data_parser_class` with some parameters.

 #. versionadded:: 0.8
 #""
 #eturn self.form_data_parser_class(
 #elf._get_file_stream,
 #elf.charset,
 #elf.encoding_errors,
 #elf.max_form_memory_size,
 #elf.max_content_length,
 #elf.parameter_storage_class,
 #

 #ef _load_form_data(self) -> None:
 #""Method used internally to retrieve submitted data.  After calling
 #his sets `form` and `files` on the request object to multi dicts
 #illed with the incoming form data.  As a matter of fact the input
 #tream will be empty afterwards.  You can also call this method to
 #orce the parsing of the form data.

 #. versionadded:: 0.8
 #""
        # abort early if we have already consumed the stream
 #f "form" in self.__dict__:
 #eturn

 #f self.want_form_data_parsed:
 #arser = self.make_form_data_parser()
 #ata = parser.parse(
 #elf._get_stream_for_parsing(),
 #elf.mimetype,
 #elf.content_length,
 #elf.mimetype_params,
 #
 #lse:
 #ata = (
 #elf.stream,
 #elf.parameter_storage_class(),
 #elf.parameter_storage_class(),
 #

        # inject the values into the instance dict so that we bypass
        # our cached_property non-data descriptor.
 # = self.__dict__
 #["stream"], d["form"], d["files"] = data

 #ef _get_stream_for_parsing(self) -> t.IO[bytes]:
 #""This is the same as accessing :attr:`stream` with the difference
 #hat if it finds cached data from calling :meth:`get_data` first it
 #ill create a new stream out of the cached data.

 #. versionadded:: 0.9.3
 #""
 #ached_data = getattr(self, "_cached_data", None)
 #f cached_data is not None:
 #eturn BytesIO(cached_data)
 #eturn self.stream

 #ef close(self) -> None:
 #""Closes associated resources of this request object.  This
 #loses all file handles explicitly.  You can also use the request
 #bject in a with statement which will automatically close it.

 #. versionadded:: 0.9
 #""
 #iles = self.__dict__.get("files")
 #or _key, value in iter_multi_items(files or ()):
 #alue.close()

 #ef __enter__(self) -> "Request":
 #eturn self

 #ef __exit__(self, exc_type, exc_value, tb) -> None:  # type: ignore
 #elf.close()

 #cached_property
 #ef stream(self) -> t.IO[bytes]:
 #""
 #f the incoming form data was not encoded with a known mimetype
 #he data is stored unmodified in this stream for consumption.  Most
 #f the time it is a better idea to use :attr:`data` which will give
 #ou that data as a string.  The stream only returns the data once.

 #nlike :attr:`input_stream` this stream is properly guarded that you
 #an't accidentally read past the length of the input.  Werkzeug will
 #nternally always refer to this stream to read data which makes it
 #ossible to wrap this object with a stream that does filtering.

 #. versionchanged:: 0.9
 #his stream is now always available but might be consumed by the
 #orm parser later on.  Previously the stream was only set if no
 #arsing happened.
 #""
 #f self.shallow:
 #aise RuntimeError(
 #This request was created with 'shallow=True', reading"
 # from the input stream is disabled."
 #

 #eturn get_input_stream(self.environ)

 #nput_stream = environ_property[t.IO[bytes]](
 #wsgi.input",
 #oc="""The WSGI input stream.

 #n general it's a bad idea to use this one because you can
 #asily read past the boundary.  Use the :attr:`stream`
 #nstead.""",
 #

 #cached_property
 #ef data(self) -> bytes:
 #""
 #ontains the incoming request data as string in case it came with
 # mimetype Werkzeug does not handle.
 #""
 #eturn self.get_data(parse_form_data=True)

 #typing.overload
 #ef get_data(  # type: ignore
 #elf,
 #ache: bool = True,
 #s_text: "te.Literal[False]" = False,
 #arse_form_data: bool = False,
 # -> bytes:
 #..

 #typing.overload
 #ef get_data(
 #elf,
 #ache: bool = True,
 #s_text: "te.Literal[True]" = ...,
 #arse_form_data: bool = False,
 # -> str:
 #..

 #ef get_data(
 #elf, cache: bool = True, as_text: bool = False, parse_form_data: bool = False
 # -> t.Union[bytes, str]:
 #""This reads the buffered incoming data from the client into one
 #ytes object.  By default this is cached but that behavior can be
 #hanged by setting `cache` to `False`.

 #sually it's a bad idea to call this method without checking the
 #ontent length first as a client could send dozens of megabytes or more
 #o cause memory problems on the server.

 #ote that if the form data was already parsed this method will not
 #eturn anything as form data parsing does not cache the data like
 #his method does.  To implicitly invoke form data parsing function
 #et `parse_form_data` to `True`.  When this is done the return value
 #f this method will be an empty string if the form parser handles
 #he data.  This generally is not necessary as if the whole data is
 #ached (which is the default) the form parser will used the cached
 #ata to parse the form data.  Please be generally aware of checking
 #he content length first in any case before calling this method
 #o avoid exhausting server memory.

 #f `as_text` is set to `True` the return value will be a decoded
 #tring.

 #. versionadded:: 0.9
 #""
 #v = getattr(self, "_cached_data", None)
 #f rv is None:
 #f parse_form_data:
 #elf._load_form_data()
 #v = self.stream.read()
 #f cache:
 #elf._cached_data = rv
 #f as_text:
 #v = rv.decode(self.charset, self.encoding_errors)
 #eturn rv

 #cached_property
 #ef form(self) -> "ImmutableMultiDict[str, str]":
 #""The form parameters.  By default an
 #class:`~werkzeug.datastructures.ImmutableMultiDict`
 #s returned from this function.  This can be changed by setting
 #attr:`parameter_storage_class` to a different type.  This might
 #e necessary if the order of the form data is important.

 #lease keep in mind that file uploads will not end up here, but instead
 #n the :attr:`files` attribute.

 #. versionchanged:: 0.9

 #revious to Werkzeug 0.9 this would only contain form data for POST
 #nd PUT requests.
 #""
 #elf._load_form_data()
 #eturn self.form

 #cached_property
 #ef values(self) -> "CombinedMultiDict[str, str]":
 #""A :class:`werkzeug.datastructures.CombinedMultiDict` that
 #ombines :attr:`args` and :attr:`form`.

 #or GET requests, only ``args`` are present, not ``form``.

 #. versionchanged:: 2.0
 #or GET requests, only ``args`` are present, not ``form``.
 #""
 #ources = [self.args]

 #f self.method != "GET":
            # GET requests can have a body, and some caching proxies
            # might not treat that differently than a normal GET
            # request, allowing form data to "invisibly" affect the
            # cache without indication in the query string / URL.
 #ources.append(self.form)

 #rgs = []

 #or d in sources:
 #f not isinstance(d, MultiDict):
 # = MultiDict(d)

 #rgs.append(d)

 #eturn CombinedMultiDict(args)

 #cached_property
 #ef files(self) -> "ImmutableMultiDict[str, FileStorage]":
 #"":class:`~werkzeug.datastructures.MultiDict` object containing
 #ll uploaded files.  Each key in :attr:`files` is the name from the
 #`<input type="file" name="">``.  Each value in :attr:`files` is a
 #erkzeug :class:`~werkzeug.datastructures.FileStorage` object.

 #t basically behaves like a standard file object you know from Python,
 #ith the difference that it also has a
 #meth:`~werkzeug.datastructures.FileStorage.save` function that can
 #tore the file on the filesystem.

 #ote that :attr:`files` will only contain data if the request method was
 #OST, PUT or PATCH and the ``<form>`` that posted to the request had
 #`enctype="multipart/form-data"``.  It will be empty otherwise.

 #ee the :class:`~werkzeug.datastructures.MultiDict` /
 #class:`~werkzeug.datastructures.FileStorage` documentation for
 #ore details about the used data structure.
 #""
 #elf._load_form_data()
 #eturn self.files

 #property
 #ef script_root(self) -> str:
 #""Alias for :attr:`self.root_path`. ``environ["SCRIPT_ROOT"]``
 #ithout a trailing slash.
 #""
 #eturn self.root_path

 #cached_property
 #ef url_root(self) -> str:
 #""Alias for :attr:`root_url`. The URL with scheme, host, and
 #oot path. For example, ``https://example.com/app/``.
 #""
 #eturn self.root_url

 #emote_user = environ_property[str](
 #REMOTE_USER",
 #oc="""If the server supports user authentication, and the
 #cript is protected, this attribute contains the username the
 #ser has authenticated as.""",
 #
 #s_multithread = environ_property[bool](
 #wsgi.multithread",
 #oc="""boolean that is `True` if the application is served by a
 #ultithreaded WSGI server.""",
 #
 #s_multiprocess = environ_property[bool](
 #wsgi.multiprocess",
 #oc="""boolean that is `True` if the application is served by a
 #SGI server that spawns multiple processes.""",
 #
 #s_run_once = environ_property[bool](
 #wsgi.run_once",
 #oc="""boolean that is `True` if the application will be
 #xecuted only once in a process lifetime.  This is the case for
 #GI for example, but it's not guaranteed that the execution only
 #appens one time.""",
 #

    # JSON

    #: A module or other object that has ``dumps`` and ``loads``
    #: functions that match the API of the built-in :mod:`json` module.
 #son_module = json

 #property
 #ef json(self) -> t.Optional[t.Any]:
 #""The parsed JSON data if :attr:`mimetype` indicates JSON
 #:mimetype:`application/json`, see :attr:`is_json`).

 #alls :meth:`get_json` with default arguments.
 #""
 #eturn self.get_json()

    # Cached values for ``(silent=False, silent=True)``. Initialized
    # with sentinel values.
 #cached_json: t.Tuple[t.Any, t.Any] = (Ellipsis, Ellipsis)

 #ef get_json(
 #elf, force: bool = False, silent: bool = False, cache: bool = True
 # -> t.Optional[t.Any]:
 #""Parse :attr:`data` as JSON.

 #f the mimetype does not indicate JSON
 #:mimetype:`application/json`, see :attr:`is_json`), this
 #eturns ``None``.

 #f parsing fails, :meth:`on_json_loading_failed` is called and
 #ts return value is used as the return value.

 #param force: Ignore the mimetype and always try to parse JSON.
 #param silent: Silence parsing errors and return ``None``
 #nstead.
 #param cache: Store the parsed JSON to return for subsequent
 #alls.
 #""
 #f cache and self._cached_json[silent] is not Ellipsis:
 #eturn self._cached_json[silent]

 #f not (force or self.is_json):
 #eturn None

 #ata = self.get_data(cache=cache)

 #ry:
 #v = self.json_module.loads(data)
 #xcept ValueError as e:
 #f silent:
 #v = None

 #f cache:
 #ormal_rv, _ = self._cached_json
 #elf._cached_json = (normal_rv, rv)
 #lse:
 #v = self.on_json_loading_failed(e)

 #f cache:
 #, silent_rv = self._cached_json
 #elf._cached_json = (rv, silent_rv)
 #lse:
 #f cache:
 #elf._cached_json = (rv, rv)

 #eturn rv

 #ef on_json_loading_failed(self, e: ValueError) -> t.Any:
 #""Called if :meth:`get_json` parsing fails and isn't silenced.
 #f this method returns a value, it is used as the return value
 #or :meth:`get_json`. The default implementation raises
 #exc:`~werkzeug.exceptions.BadRequest`.
 #""
 #aise BadRequest(f"Failed to decode JSON object: {e}")


class StreamOnlyMixin:
 #""Mixin to create a ``Request`` that disables the ``data``,
 #`form``, and ``files`` properties. Only ``stream`` is available.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Create the request with
 #`shallow=True`` instead.

 #. versionadded:: 0.9
 #""

 #ef __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
 #arnings.warn(
 #'StreamOnlyMixin' is deprecated and will be removed in"
 # Werkzeug 2.1. Create the request with 'shallow=True'"
 # instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #wargs["shallow"] = True
 #uper().__init__(*args, **kwargs)


class PlainRequest(StreamOnlyMixin, Request):
 #""A request object without ``data``, ``form``, and ``files``.

 #. deprecated:: 2.0
 #ill be removed in Werkzeug 2.1. Create the request with
 #`shallow=True`` instead.

 #. versionadded:: 0.9
 #""

 #ef __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
 #arnings.warn(
 #'PlainRequest' is deprecated and will be removed in"
 # Werkzeug 2.1. Create the request with 'shallow=True'"
 # instead.",
 #eprecationWarning,
 #tacklevel=2,
 #

        # Don't show the DeprecationWarning for StreamOnlyMixin.
 #ith warnings.catch_warnings():
 #arnings.simplefilter("ignore", DeprecationWarning)
 #uper().__init__(*args, **kwargs)
