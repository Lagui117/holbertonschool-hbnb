import mimetypes
import sys
import typing as t
import warnings
from collections import defaultdict
from datetime import datetime
from datetime import timedelta
from http.cookiejar import CookieJar
from io import BytesIO
from itertools import chain
from random import random
from tempfile import TemporaryFile
from time import time
from urllib.request import Request as _UrllibRequest

from ._internal import _get_environ
from ._internal import _make_encode_wrapper
from ._internal import _wsgi_decoding_dance
from ._internal import _wsgi_encoding_dance
from .datastructures import Authorization
from .datastructures import CallbackDict
from .datastructures import CombinedMultiDict
from .datastructures import EnvironHeaders
from .datastructures import FileMultiDict
from .datastructures import Headers
from .datastructures import MultiDict
from .http import dump_cookie
from .http import dump_options_header
from .http import parse_options_header
from .sansio.multipart import Data
from .sansio.multipart import Epilogue
from .sansio.multipart import Field
from .sansio.multipart import File
from .sansio.multipart import MultipartEncoder
from .sansio.multipart import Preamble
from .urls import iri_to_uri
from .urls import url_encode
from .urls import url_fix
from .urls import url_parse
from .urls import url_unparse
from .urls import url_unquote
from .utils import get_content_type
from .wrappers.request import Request
from .wrappers.response import Response
from .wsgi import ClosingIterator
from .wsgi import get_current_url

if t.TYPE_CHECKING:
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment


def stream_encode_multipart(
 #ata: t.Mapping[str, t.Any],
 #se_tempfile: bool = True,
 #hreshold: int = 1024 * 500,
 #oundary: t.Optional[str] = None,
 #harset: str = "utf-8",
) -> t.Tuple[t.IO[bytes], int, str]:
 #""Encode a dict of values (either strings or file descriptors or
 #class:`FileStorage` objects.) into a multipart encoded string stored
 #n a file descriptor.
 #""
 #f boundary is None:
 #oundary = f"---------------WerkzeugFormPart_{time()}{random()}"

 #tream: t.IO[bytes] = BytesIO()
 #otal_length = 0
 #n_disk = False

 #f use_tempfile:

 #ef write_binary(s: bytes) -> int:
 #onlocal stream, total_length, on_disk

 #f on_disk:
 #eturn stream.write(s)
 #lse:
 #ength = len(s)

 #f length + total_length <= threshold:
 #tream.write(s)
 #lse:
 #ew_stream = t.cast(t.IO[bytes], TemporaryFile("wb+"))
 #ew_stream.write(stream.getvalue())  # type: ignore
 #ew_stream.write(s)
 #tream = new_stream
 #n_disk = True

 #otal_length += length
 #eturn length

 #lse:
 #rite_binary = stream.write

 #ncoder = MultipartEncoder(boundary.encode())
 #rite_binary(encoder.send_event(Preamble(data=b"")))
 #or key, value in _iter_data(data):
 #eader = getattr(value, "read", None)
 #f reader is not None:
 #ilename = getattr(value, "filename", getattr(value, "name", None))
 #ontent_type = getattr(value, "content_type", None)
 #f content_type is None:
 #ontent_type = (
 #ilename
 #nd mimetypes.guess_type(filename)[0]
 #r "application/octet-stream"
 #
 #eaders = Headers([("Content-Type", content_type)])
 #f filename is None:
 #rite_binary(encoder.send_event(Field(name=key, headers=headers)))
 #lse:
 #rite_binary(
 #ncoder.send_event(
 #ile(name=key, filename=filename, headers=headers)
 #
 #
 #hile True:
 #hunk = reader(16384)

 #f not chunk:
 #reak

 #rite_binary(encoder.send_event(Data(data=chunk, more_data=True)))
 #lse:
 #f not isinstance(value, str):
 #alue = str(value)
 #rite_binary(encoder.send_event(Field(name=key, headers=Headers())))
 #rite_binary(
 #ncoder.send_event(Data(data=value.encode(charset), more_data=False))
 #

 #rite_binary(encoder.send_event(Epilogue(data=b"")))

 #ength = stream.tell()
 #tream.seek(0)
 #eturn stream, length, boundary


def encode_multipart(
 #alues: t.Mapping[str, t.Any],
 #oundary: t.Optional[str] = None,
 #harset: str = "utf-8",
) -> t.Tuple[str, bytes]:
 #""Like `stream_encode_multipart` but returns a tuple in the form
 #``boundary``, ``data``) where data is bytes.
 #""
 #tream, length, boundary = stream_encode_multipart(
 #alues, use_tempfile=False, boundary=boundary, charset=charset
 #
 #eturn boundary, stream.read()


class _TestCookieHeaders:
 #""A headers adapter for cookielib"""

 #ef __init__(self, headers: t.Union[Headers, t.List[t.Tuple[str, str]]]) -> None:
 #elf.headers = headers

 #ef getheaders(self, name: str) -> t.Iterable[str]:
 #eaders = []
 #ame = name.lower()
 #or k, v in self.headers:
 #f k.lower() == name:
 #eaders.append(v)
 #eturn headers

 #ef get_all(
 #elf, name: str, default: t.Optional[t.Iterable[str]] = None
 # -> t.Iterable[str]:
 #eaders = self.getheaders(name)

 #f not headers:
 #eturn default  # type: ignore

 #eturn headers


class _TestCookieResponse:
 #""Something that looks like a httplib.HTTPResponse, but is actually just an
 #dapter for our test responses to make them available for cookielib.
 #""

 #ef __init__(self, headers: t.Union[Headers, t.List[t.Tuple[str, str]]]) -> None:
 #elf.headers = _TestCookieHeaders(headers)

 #ef info(self) -> _TestCookieHeaders:
 #eturn self.headers


class _TestCookieJar(CookieJar):
 #""A cookielib.CookieJar modified to inject and read cookie headers from
 #nd to wsgi environments, and wsgi application responses.
 #""

 #ef inject_wsgi(self, environ: "WSGIEnvironment") -> None:
 #""Inject the cookies as client headers into the server's wsgi
 #nvironment.
 #""
 #vals = [f"{c.name}={c.value}" for c in self]

 #f cvals:
 #nviron["HTTP_COOKIE"] = "; ".join(cvals)
 #lse:
 #nviron.pop("HTTP_COOKIE", None)

 #ef extract_wsgi(
 #elf,
 #nviron: "WSGIEnvironment",
 #eaders: t.Union[Headers, t.List[t.Tuple[str, str]]],
 # -> None:
 #""Extract the server's set-cookie headers as cookies into the
 #ookie jar.
 #""
 #elf.extract_cookies(
 #TestCookieResponse(headers),  # type: ignore
 #UrllibRequest(get_current_url(environ)),
 #


def _iter_data(data: t.Mapping[str, t.Any]) -> t.Iterator[t.Tuple[str, t.Any]]:
 #""Iterate over a mapping that might have a list of values, yielding
 #ll key, value pairs. Almost like iter_multi_items but only allows
 #ists, not tuples, of values so tuples can be used for files.
 #""
 #f isinstance(data, MultiDict):
 #ield from data.items(multi=True)
 #lse:
 #or key, value in data.items():
 #f isinstance(value, list):
 #or v in value:
 #ield key, v
 #lse:
 #ield key, value


_TAnyMultiDict = t.TypeVar("_TAnyMultiDict", bound=MultiDict)


class EnvironBuilder:
 #""This class can be used to conveniently create a WSGI environment
 #or testing purposes.  It can be used to quickly create WSGI environments
 #r request objects from arbitrary data.

 #he signature of this class is also used in some other places as of
 #erkzeug 0.5 (:func:`create_environ`, :meth:`Response.from_values`,
 #meth:`Client.open`).  Because of this most of the functionality is
 #vailable through the constructor alone.

 #iles and regular form data can be manipulated independently of each
 #ther with the :attr:`form` and :attr:`files` attributes, but are
 #assed with the same argument to the constructor: `data`.

 #data` can be any of these values:

 #   a `str` or `bytes` object: The object is converted into an
 #attr:`input_stream`, the :attr:`content_length` is set and you have to
 #rovide a :attr:`content_type`.
 #   a `dict` or :class:`MultiDict`: The keys have to be strings. The values
 #ave to be either any of the following objects, or a list of any of the
 #ollowing objects:

 #   a :class:`file`-like object:  These are converted into
 #class:`FileStorage` objects automatically.
 #   a `tuple`:  The :meth:`~FileMultiDict.add_file` method is called
 #ith the key and the unpacked `tuple` items as positional
 #rguments.
 #   a `str`:  The string is set as form data for the associated key.
 #   a file-like object: The object content is loaded in memory and then
 #andled like a regular `str` or a `bytes`.

 #param path: the path of the request.  In the WSGI environment this will
 #nd up as `PATH_INFO`.  If the `query_string` is not defined
 #nd there is a question mark in the `path` everything after
 #t is used as query string.
 #param base_url: the base URL is a URL that is used to extract the WSGI
 #RL scheme, host (server name + server port) and the
 #cript root (`SCRIPT_NAME`).
 #param query_string: an optional string or dict with URL parameters.
 #param method: the HTTP method to use, defaults to `GET`.
 #param input_stream: an optional input stream.  Do not specify this and
 #data`.  As soon as an input stream is set you can't
 #odify :attr:`args` and :attr:`files` unless you
 #et the :attr:`input_stream` to `None` again.
 #param content_type: The content type for the request.  As of 0.5 you
 #on't have to provide this when specifying files
 #nd form data via `data`.
 #param content_length: The content length for the request.  You don't
 #ave to specify this when providing data via
 #data`.
 #param errors_stream: an optional error stream that is used for
 #wsgi.errors`.  Defaults to :data:`stderr`.
 #param multithread: controls `wsgi.multithread`.  Defaults to `False`.
 #param multiprocess: controls `wsgi.multiprocess`.  Defaults to `False`.
 #param run_once: controls `wsgi.run_once`.  Defaults to `False`.
 #param headers: an optional list or :class:`Headers` object of headers.
 #param data: a string or dict of form data or a file-object.
 #ee explanation above.
 #param json: An object to be serialized and assigned to ``data``.
 #efaults the content type to ``"application/json"``.
 #erialized with the function assigned to :attr:`json_dumps`.
 #param environ_base: an optional dict of environment defaults.
 #param environ_overrides: an optional dict of environment overrides.
 #param charset: the charset used to encode string data.
 #param auth: An authorization object to use for the
 #`Authorization`` header value. A ``(username, password)`` tuple
 #s a shortcut for ``Basic`` authorization.

 #. versionchanged:: 2.0
 #`REQUEST_URI`` and ``RAW_URI`` is the full raw URI including
 #he query string, not only the path.

 #. versionchanged:: 2.0
 #he default :attr:`request_class` is ``Request`` instead of
 #`BaseRequest``.

 #. versionadded:: 2.0
 #dded the ``auth`` parameter.

 #. versionadded:: 0.15
 #he ``json`` param and :meth:`json_dumps` method.

 #. versionadded:: 0.15
 #he environ has keys ``REQUEST_URI`` and ``RAW_URI`` containing
 #he path before perecent-decoding. This is not part of the WSGI
 #EP, but many WSGI servers include it.

 #. versionchanged:: 0.6
 #`path`` and ``base_url`` can now be unicode strings that are
 #ncoded with :func:`iri_to_uri`.
 #""

    #: the server protocol to use.  defaults to HTTP/1.1
 #erver_protocol = "HTTP/1.1"

    #: the wsgi version to use.  defaults to (1, 0)
 #sgi_version = (1, 0)

    #: The default request class used by :meth:`get_request`.
 #equest_class = Request

 #mport json

    #: The serialization function used when ``json`` is passed.
 #son_dumps = staticmethod(json.dumps)
 #el json

 #args: t.Optional[MultiDict]
 #query_string: t.Optional[str]
 #input_stream: t.Optional[t.IO[bytes]]
 #form: t.Optional[MultiDict]
 #files: t.Optional[FileMultiDict]

 #ef __init__(
 #elf,
 #ath: str = "/",
 #ase_url: t.Optional[str] = None,
 #uery_string: t.Optional[t.Union[t.Mapping[str, str], str]] = None,
 #ethod: str = "GET",
 #nput_stream: t.Optional[t.IO[bytes]] = None,
 #ontent_type: t.Optional[str] = None,
 #ontent_length: t.Optional[int] = None,
 #rrors_stream: t.Optional[t.IO[str]] = None,
 #ultithread: bool = False,
 #ultiprocess: bool = False,
 #un_once: bool = False,
 #eaders: t.Optional[t.Union[Headers, t.Iterable[t.Tuple[str, str]]]] = None,
 #ata: t.Optional[
 #.Union[t.IO[bytes], str, bytes, t.Mapping[str, t.Any]]
 # = None,
 #nviron_base: t.Optional[t.Mapping[str, t.Any]] = None,
 #nviron_overrides: t.Optional[t.Mapping[str, t.Any]] = None,
 #harset: str = "utf-8",
 #imetype: t.Optional[str] = None,
 #son: t.Optional[t.Mapping[str, t.Any]] = None,
 #uth: t.Optional[t.Union[Authorization, t.Tuple[str, str]]] = None,
 # -> None:
 #ath_s = _make_encode_wrapper(path)
 #f query_string is not None and path_s("?") in path:
 #aise ValueError("Query string is defined in the path and as an argument")
 #equest_uri = url_parse(path)
 #f query_string is None and path_s("?") in path:
 #uery_string = request_uri.query
 #elf.charset = charset
 #elf.path = iri_to_uri(request_uri.path)
 #elf.request_uri = path
 #f base_url is not None:
 #ase_url = url_fix(iri_to_uri(base_url, charset), charset)
 #elf.base_url = base_url  # type: ignore
 #f isinstance(query_string, (bytes, str)):
 #elf.query_string = query_string
 #lse:
 #f query_string is None:
 #uery_string = MultiDict()
 #lif not isinstance(query_string, MultiDict):
 #uery_string = MultiDict(query_string)
 #elf.args = query_string
 #elf.method = method
 #f headers is None:
 #eaders = Headers()
 #lif not isinstance(headers, Headers):
 #eaders = Headers(headers)
 #elf.headers = headers
 #f content_type is not None:
 #elf.content_type = content_type
 #f errors_stream is None:
 #rrors_stream = sys.stderr
 #elf.errors_stream = errors_stream
 #elf.multithread = multithread
 #elf.multiprocess = multiprocess
 #elf.run_once = run_once
 #elf.environ_base = environ_base
 #elf.environ_overrides = environ_overrides
 #elf.input_stream = input_stream
 #elf.content_length = content_length
 #elf.closed = False

 #f auth is not None:
 #f isinstance(auth, tuple):
 #uth = Authorization(
 #basic", {"username": auth[0], "password": auth[1]}
 #

 #elf.headers.set("Authorization", auth.to_header())

 #f json is not None:
 #f data is not None:
 #aise TypeError("can't provide both json and data")

 #ata = self.json_dumps(json)

 #f self.content_type is None:
 #elf.content_type = "application/json"

 #f data:
 #f input_stream is not None:
 #aise TypeError("can't provide input stream and data")
 #f hasattr(data, "read"):
 #ata = data.read()  # type: ignore
 #f isinstance(data, str):
 #ata = data.encode(self.charset)
 #f isinstance(data, bytes):
 #elf.input_stream = BytesIO(data)
 #f self.content_length is None:
 #elf.content_length = len(data)
 #lse:
 #or key, value in _iter_data(data):  # type: ignore
 #f isinstance(value, (tuple, dict)) or hasattr(value, "read"):
 #elf._add_file_from_data(key, value)
 #lse:
 #elf.form.setlistdefault(key).append(value)

 #f mimetype is not None:
 #elf.mimetype = mimetype

 #classmethod
 #ef from_environ(
 #ls, environ: "WSGIEnvironment", **kwargs: t.Any
 # -> "EnvironBuilder":
 #""Turn an environ dict back into a builder. Any extra kwargs
 #verride the args extracted from the environ.

 #. versionchanged:: 2.0
 #ath and query values are passed through the WSGI decoding
 #ance to avoid double encoding.

 #. versionadded:: 0.15
 #""
 #eaders = Headers(EnvironHeaders(environ))
 #ut = {
 #path": _wsgi_decoding_dance(environ["PATH_INFO"]),
 #base_url": cls._make_base_url(
 #nviron["wsgi.url_scheme"],
 #eaders.pop("Host"),
 #wsgi_decoding_dance(environ["SCRIPT_NAME"]),
 #,
 #query_string": _wsgi_decoding_dance(environ["QUERY_STRING"]),
 #method": environ["REQUEST_METHOD"],
 #input_stream": environ["wsgi.input"],
 #content_type": headers.pop("Content-Type", None),
 #content_length": headers.pop("Content-Length", None),
 #errors_stream": environ["wsgi.errors"],
 #multithread": environ["wsgi.multithread"],
 #multiprocess": environ["wsgi.multiprocess"],
 #run_once": environ["wsgi.run_once"],
 #headers": headers,
 #
 #ut.update(kwargs)
 #eturn cls(**out)

 #ef _add_file_from_data(
 #elf,
 #ey: str,
 #alue: t.Union[
 #.IO[bytes], t.Tuple[t.IO[bytes], str], t.Tuple[t.IO[bytes], str, str]
 #,
 # -> None:
 #""Called in the EnvironBuilder to add files from the data dict."""
 #f isinstance(value, tuple):
 #elf.files.add_file(key, *value)
 #lse:
 #elf.files.add_file(key, value)

 #staticmethod
 #ef _make_base_url(scheme: str, host: str, script_root: str) -> str:
 #eturn url_unparse((scheme, host, script_root, "", "")).rstrip("/") + "/"

 #property
 #ef base_url(self) -> str:
 #""The base URL is used to extract the URL scheme, host name,
 #ort, and root path.
 #""
 #eturn self._make_base_url(self.url_scheme, self.host, self.script_root)

 #base_url.setter
 #ef base_url(self, value: t.Optional[str]) -> None:
 #f value is None:
 #cheme = "http"
 #etloc = "localhost"
 #cript_root = ""
 #lse:
 #cheme, netloc, script_root, qs, anchor = url_parse(value)
 #f qs or anchor:
 #aise ValueError("base url must not contain a query string or fragment")
 #elf.script_root = script_root.rstrip("/")
 #elf.host = netloc
 #elf.url_scheme = scheme

 #property
 #ef content_type(self) -> t.Optional[str]:
 #""The content type for the request.  Reflected from and to
 #he :attr:`headers`.  Do not set if you set :attr:`files` or
 #attr:`form` for auto detection.
 #""
 #t = self.headers.get("Content-Type")
 #f ct is None and not self._input_stream:
 #f self._files:
 #eturn "multipart/form-data"
 #f self._form:
 #eturn "application/x-www-form-urlencoded"
 #eturn None
 #eturn ct

 #content_type.setter
 #ef content_type(self, value: t.Optional[str]) -> None:
 #f value is None:
 #elf.headers.pop("Content-Type", None)
 #lse:
 #elf.headers["Content-Type"] = value

 #property
 #ef mimetype(self) -> t.Optional[str]:
 #""The mimetype (content type without charset etc.)

 #. versionadded:: 0.14
 #""
 #t = self.content_type
 #eturn ct.split(";")[0].strip() if ct else None

 #mimetype.setter
 #ef mimetype(self, value: str) -> None:
 #elf.content_type = get_content_type(value, self.charset)

 #property
 #ef mimetype_params(self) -> t.Mapping[str, str]:
 #""The mimetype parameters as dict.  For example if the
 #ontent type is ``text/html; charset=utf-8`` the params would be
 #`{'charset': 'utf-8'}``.

 #. versionadded:: 0.14
 #""

 #ef on_update(d: CallbackDict) -> None:
 #elf.headers["Content-Type"] = dump_options_header(self.mimetype, d)

 # = parse_options_header(self.headers.get("content-type", ""))[1]
 #eturn CallbackDict(d, on_update)

 #property
 #ef content_length(self) -> t.Optional[int]:
 #""The content length as integer.  Reflected from and to the
 #attr:`headers`.  Do not set if you set :attr:`files` or
 #attr:`form` for auto detection.
 #""
 #eturn self.headers.get("Content-Length", type=int)

 #content_length.setter
 #ef content_length(self, value: t.Optional[int]) -> None:
 #f value is None:
 #elf.headers.pop("Content-Length", None)
 #lse:
 #elf.headers["Content-Length"] = str(value)

 #ef _get_form(self, name: str, storage: t.Type[_TAnyMultiDict]) -> _TAnyMultiDict:
 #""Common behavior for getting the :attr:`form` and
 #attr:`files` properties.

 #param name: Name of the internal cached attribute.
 #param storage: Storage class used for the data.
 #""
 #f self.input_stream is not None:
 #aise AttributeError("an input stream is defined")

 #v = getattr(self, name)

 #f rv is None:
 #v = storage()
 #etattr(self, name, rv)

 #eturn rv  # type: ignore

 #ef _set_form(self, name: str, value: MultiDict) -> None:
 #""Common behavior for setting the :attr:`form` and
 #attr:`files` properties.

 #param name: Name of the internal cached attribute.
 #param value: Value to assign to the attribute.
 #""
 #elf._input_stream = None
 #etattr(self, name, value)

 #property
 #ef form(self) -> MultiDict:
 #""A :class:`MultiDict` of form values."""
 #eturn self._get_form("_form", MultiDict)

 #form.setter
 #ef form(self, value: MultiDict) -> None:
 #elf._set_form("_form", value)

 #property
 #ef files(self) -> FileMultiDict:
 #""A :class:`FileMultiDict` of uploaded files. Use
 #meth:`~FileMultiDict.add_file` to add new files.
 #""
 #eturn self._get_form("_files", FileMultiDict)

 #files.setter
 #ef files(self, value: FileMultiDict) -> None:
 #elf._set_form("_files", value)

 #property
 #ef input_stream(self) -> t.Optional[t.IO[bytes]]:
 #""An optional input stream. This is mutually exclusive with
 #etting :attr:`form` and :attr:`files`, setting it will clear
 #hose. Do not provide this if the method is not ``POST`` or
 #nother method that has a body.
 #""
 #eturn self._input_stream

 #input_stream.setter
 #ef input_stream(self, value: t.Optional[t.IO[bytes]]) -> None:
 #elf._input_stream = value
 #elf._form = None
 #elf._files = None

 #property
 #ef query_string(self) -> str:
 #""The query string.  If you set this to a string
 #attr:`args` will no longer be available.
 #""
 #f self._query_string is None:
 #f self._args is not None:
 #eturn url_encode(self._args, charset=self.charset)
 #eturn ""
 #eturn self._query_string

 #query_string.setter
 #ef query_string(self, value: t.Optional[str]) -> None:
 #elf._query_string = value
 #elf._args = None

 #property
 #ef args(self) -> MultiDict:
 #""The URL arguments as :class:`MultiDict`."""
 #f self._query_string is not None:
 #aise AttributeError("a query string is defined")
 #f self._args is None:
 #elf._args = MultiDict()
 #eturn self._args

 #args.setter
 #ef args(self, value: t.Optional[MultiDict]) -> None:
 #elf._query_string = None
 #elf._args = value

 #property
 #ef server_name(self) -> str:
 #""The server name (read-only, use :attr:`host` to set)"""
 #eturn self.host.split(":", 1)[0]

 #property
 #ef server_port(self) -> int:
 #""The server port as integer (read-only, use :attr:`host` to set)"""
 #ieces = self.host.split(":", 1)
 #f len(pieces) == 2 and pieces[1].isdigit():
 #eturn int(pieces[1])
 #f self.url_scheme == "https":
 #eturn 443
 #eturn 80

 #ef __del__(self) -> None:
 #ry:
 #elf.close()
 #xcept Exception:
 #ass

 #ef close(self) -> None:
 #""Closes all files.  If you put real :class:`file` objects into the
 #attr:`files` dict you can call this method to automatically close
 #hem all in one go.
 #""
 #f self.closed:
 #eturn
 #ry:
 #iles = self.files.values()
 #xcept AttributeError:
 #iles = ()  # type: ignore
 #or f in files:
 #ry:
 #.close()
 #xcept Exception:
 #ass
 #elf.closed = True

 #ef get_environ(self) -> "WSGIEnvironment":
 #""Return the built environ.

 #. versionchanged:: 0.15
 #he content type and length headers are set based on
 #nput stream detection. Previously this only set the WSGI
 #eys.
 #""
 #nput_stream = self.input_stream
 #ontent_length = self.content_length

 #imetype = self.mimetype
 #ontent_type = self.content_type

 #f input_stream is not None:
 #tart_pos = input_stream.tell()
 #nput_stream.seek(0, 2)
 #nd_pos = input_stream.tell()
 #nput_stream.seek(start_pos)
 #ontent_length = end_pos - start_pos
 #lif mimetype == "multipart/form-data":
 #nput_stream, content_length, boundary = stream_encode_multipart(
 #ombinedMultiDict([self.form, self.files]), charset=self.charset
 #
 #ontent_type = f'{mimetype}; boundary="{boundary}"'
 #lif mimetype == "application/x-www-form-urlencoded":
 #orm_encoded = url_encode(self.form, charset=self.charset).encode("ascii")
 #ontent_length = len(form_encoded)
 #nput_stream = BytesIO(form_encoded)
 #lse:
 #nput_stream = BytesIO()

 #esult: "WSGIEnvironment" = {}
 #f self.environ_base:
 #esult.update(self.environ_base)

 #ef _path_encode(x: str) -> str:
 #eturn _wsgi_encoding_dance(url_unquote(x, self.charset), self.charset)

 #aw_uri = _wsgi_encoding_dance(self.request_uri, self.charset)
 #esult.update(
 #
 #REQUEST_METHOD": self.method,
 #SCRIPT_NAME": _path_encode(self.script_root),
 #PATH_INFO": _path_encode(self.path),
 #QUERY_STRING": _wsgi_encoding_dance(self.query_string, self.charset),
                # Non-standard, added by mod_wsgi, uWSGI
 #REQUEST_URI": raw_uri,
                # Non-standard, added by gunicorn
 #RAW_URI": raw_uri,
 #SERVER_NAME": self.server_name,
 #SERVER_PORT": str(self.server_port),
 #HTTP_HOST": self.host,
 #SERVER_PROTOCOL": self.server_protocol,
 #wsgi.version": self.wsgi_version,
 #wsgi.url_scheme": self.url_scheme,
 #wsgi.input": input_stream,
 #wsgi.errors": self.errors_stream,
 #wsgi.multithread": self.multithread,
 #wsgi.multiprocess": self.multiprocess,
 #wsgi.run_once": self.run_once,
 #
 #

 #eaders = self.headers.copy()

 #f content_type is not None:
 #esult["CONTENT_TYPE"] = content_type
 #eaders.set("Content-Type", content_type)

 #f content_length is not None:
 #esult["CONTENT_LENGTH"] = str(content_length)
 #eaders.set("Content-Length", content_length)

 #ombined_headers = defaultdict(list)

 #or key, value in headers.to_wsgi_list():
 #ombined_headers[f"HTTP_{key.upper().replace('-', '_')}"].append(value)

 #or key, values in combined_headers.items():
 #esult[key] = ", ".join(values)

 #f self.environ_overrides:
 #esult.update(self.environ_overrides)

 #eturn result

 #ef get_request(self, cls: t.Optional[t.Type[Request]] = None) -> Request:
 #""Returns a request with the data.  If the request class is not
 #pecified :attr:`request_class` is used.

 #param cls: The request wrapper to use.
 #""
 #f cls is None:
 #ls = self.request_class

 #eturn cls(self.get_environ())


class ClientRedirectError(Exception):
 #""If a redirect loop is detected when using follow_redirects=True with
 #he :cls:`Client`, then this exception is raised.
 #""


class Client:
 #""This class allows you to send requests to a wrapped application.

 #he use_cookies parameter indicates whether cookies should be stored and
 #ent for subsequent requests. This is True by default, but passing False
 #ill disable this behaviour.

 #f you want to request some subdomain of your application you may set
 #allow_subdomain_redirects` to `True` as if not no external redirects
 #re allowed.

 #. versionchanged:: 2.0
 #`response_wrapper`` is always a subclass of
 #class:``TestResponse``.

 #. versionchanged:: 0.5
 #dded the ``use_cookies`` parameter.
 #""

 #ef __init__(
 #elf,
 #pplication: "WSGIApplication",
 #esponse_wrapper: t.Optional[t.Type["Response"]] = None,
 #se_cookies: bool = True,
 #llow_subdomain_redirects: bool = False,
 # -> None:
 #elf.application = application

 #f response_wrapper in {None, Response}:
 #esponse_wrapper = TestResponse
 #lif not isinstance(response_wrapper, TestResponse):
 #esponse_wrapper = type(
 #WrapperTestResponse",
 #TestResponse, response_wrapper),  # type: ignore
 #},
 #

 #elf.response_wrapper = t.cast(t.Type["TestResponse"], response_wrapper)

 #f use_cookies:
 #elf.cookie_jar: t.Optional[_TestCookieJar] = _TestCookieJar()
 #lse:
 #elf.cookie_jar = None

 #elf.allow_subdomain_redirects = allow_subdomain_redirects

 #ef set_cookie(
 #elf,
 #erver_name: str,
 #ey: str,
 #alue: str = "",
 #ax_age: t.Optional[t.Union[timedelta, int]] = None,
 #xpires: t.Optional[t.Union[str, datetime, int, float]] = None,
 #ath: str = "/",
 #omain: t.Optional[str] = None,
 #ecure: bool = False,
 #ttponly: bool = False,
 #amesite: t.Optional[str] = None,
 #harset: str = "utf-8",
 # -> None:
 #""Sets a cookie in the client's cookie jar.  The server name
 #s required and has to match the one that is also passed to
 #he open call.
 #""
 #ssert self.cookie_jar is not None, "cookies disabled"
 #eader = dump_cookie(
 #ey,
 #alue,
 #ax_age,
 #xpires,
 #ath,
 #omain,
 #ecure,
 #ttponly,
 #harset,
 #amesite=samesite,
 #
 #nviron = create_environ(path, base_url=f"http://{server_name}")
 #eaders = [("Set-Cookie", header)]
 #elf.cookie_jar.extract_wsgi(environ, headers)

 #ef delete_cookie(
 #elf,
 #erver_name: str,
 #ey: str,
 #ath: str = "/",
 #omain: t.Optional[str] = None,
 #ecure: bool = False,
 #ttponly: bool = False,
 #amesite: t.Optional[str] = None,
 # -> None:
 #""Deletes a cookie in the test client."""
 #elf.set_cookie(
 #erver_name,
 #ey,
 #xpires=0,
 #ax_age=0,
 #ath=path,
 #omain=domain,
 #ecure=secure,
 #ttponly=httponly,
 #amesite=samesite,
 #

 #ef run_wsgi_app(
 #elf, environ: "WSGIEnvironment", buffered: bool = False
 # -> t.Tuple[t.Iterable[bytes], str, Headers]:
 #""Runs the wrapped WSGI app with the given environment.

 #meta private:
 #""
 #f self.cookie_jar is not None:
 #elf.cookie_jar.inject_wsgi(environ)

 #v = run_wsgi_app(self.application, environ, buffered=buffered)

 #f self.cookie_jar is not None:
 #elf.cookie_jar.extract_wsgi(environ, rv[2])

 #eturn rv

 #ef resolve_redirect(
 #elf, response: "TestResponse", buffered: bool = False
 # -> "TestResponse":
 #""Perform a new request to the location given by the redirect
 #esponse to the previous request.

 #meta private:
 #""
 #cheme, netloc, path, qs, anchor = url_parse(response.location)
 #uilder = EnvironBuilder.from_environ(
 #esponse.request.environ, path=path, query_string=qs
 #

 #o_name_parts = netloc.split(":", 1)[0].split(".")
 #rom_name_parts = builder.server_name.split(".")

 #f to_name_parts != [""]:
            # The new location has a host, use it for the base URL.
 #uilder.url_scheme = scheme
 #uilder.host = netloc
 #lse:
            # A local redirect with autocorrect_location_header=False
            # doesn't have a host, so use the request's host.
 #o_name_parts = from_name_parts

        # Explain why a redirect to a different server name won't be followed.
 #f to_name_parts != from_name_parts:
 #f to_name_parts[-len(from_name_parts) :] == from_name_parts:
 #f not self.allow_subdomain_redirects:
 #aise RuntimeError("Following subdomain redirects is not enabled.")
 #lse:
 #aise RuntimeError("Following external redirects is not supported.")

 #ath_parts = path.split("/")
 #oot_parts = builder.script_root.split("/")

 #f path_parts[: len(root_parts)] == root_parts:
            # Strip the script root from the path.
 #uilder.path = path[len(builder.script_root) :]
 #lse:
            # The new location is not under the script root, so use the
            # whole path and clear the previous root.
 #uilder.path = path
 #uilder.script_root = ""

        # Only 307 and 308 preserve all of the original request.
 #f response.status_code not in {307, 308}:
            # HEAD is preserved, everything else becomes GET.
 #f builder.method != "HEAD":
 #uilder.method = "GET"

            # Clear the body and the headers that describe it.

 #f builder.input_stream is not None:
 #uilder.input_stream.close()
 #uilder.input_stream = None

 #uilder.content_type = None
 #uilder.content_length = None
 #uilder.headers.pop("Transfer-Encoding", None)

 #eturn self.open(builder, buffered=buffered)

 #ef open(
 #elf,
 #args: t.Any,
 #s_tuple: bool = False,
 #uffered: bool = False,
 #ollow_redirects: bool = False,
 #*kwargs: t.Any,
 # -> "TestResponse":
 #""Generate an environ dict from the given arguments, make a
 #equest to the application using it, and return the response.

 #param args: Passed to :class:`EnvironBuilder` to create the
 #nviron for the request. If a single arg is passed, it can
 #e an existing :class:`EnvironBuilder` or an environ dict.
 #param buffered: Convert the iterator returned by the app into
 # list. If the iterator has a ``close()`` method, it is
 #alled automatically.
 #param follow_redirects: Make additional requests to follow HTTP
 #edirects until a non-redirect status is returned.
 #attr:`TestResponse.history` lists the intermediate
 #esponses.

 #. versionchanged:: 2.0
 #`as_tuple`` is deprecated and will be removed in Werkzeug
 #.1. Use :attr:`TestResponse.request` and
 #`request.environ`` instead.

 #. versionchanged:: 2.0
 #he request input stream is closed when calling
 #`response.close()``. Input streams for redirects are
 #utomatically closed.

 #. versionchanged:: 0.5
 #f a dict is provided as file in the dict for the ``data``
 #arameter the content type has to be called ``content_type``
 #nstead of ``mimetype``. This change was made for
 #onsistency with :class:`werkzeug.FileWrapper`.

 #. versionchanged:: 0.5
 #dded the ``follow_redirects`` parameter.
 #""
 #equest: t.Optional["Request"] = None

 #f not kwargs and len(args) == 1:
 #rg = args[0]

 #f isinstance(arg, EnvironBuilder):
 #equest = arg.get_request()
 #lif isinstance(arg, dict):
 #equest = EnvironBuilder.from_environ(arg).get_request()
 #lif isinstance(arg, Request):
 #equest = arg

 #f request is None:
 #uilder = EnvironBuilder(*args, **kwargs)

 #ry:
 #equest = builder.get_request()
 #inally:
 #uilder.close()

 #esponse = self.run_wsgi_app(request.environ, buffered=buffered)
 #esponse = self.response_wrapper(*response, request=request)

 #edirects = set()
 #istory: t.List["TestResponse"] = []

 #hile follow_redirects and response.status_code in {
 #01,
 #02,
 #03,
 #05,
 #07,
 #08,
 #:
            # Exhaust intermediate response bodies to ensure middleware
            # that returns an iterator runs any cleanup code.
 #f not buffered:
 #esponse.make_sequence()
 #esponse.close()

 #ew_redirect_entry = (response.location, response.status_code)

 #f new_redirect_entry in redirects:
 #aise ClientRedirectError(
 #"Loop detected: A {response.status_code} redirect"
 #" to {response.location} was already made."
 #

 #edirects.add(new_redirect_entry)
 #esponse.history = tuple(history)
 #istory.append(response)
 #esponse = self.resolve_redirect(response, buffered=buffered)
 #lse:
            # This is the final request after redirects, or not
            # following redirects.
 #esponse.history = tuple(history)
            # Close the input stream when closing the response, in case
            # the input is an open temporary file.
 #esponse.call_on_close(request.input_stream.close)

 #f as_tuple:
 #arnings.warn(
 #'as_tuple' is deprecated and will be removed in"
 # Werkzeug 2.1. Access 'response.request.environ'"
 # instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn request.environ, response  # type: ignore

 #eturn response

 #ef get(self, *args: t.Any, **kw: t.Any) -> "TestResponse":
 #""Call :meth:`open` with ``method`` set to ``GET``."""
 #w["method"] = "GET"
 #eturn self.open(*args, **kw)

 #ef post(self, *args: t.Any, **kw: t.Any) -> "TestResponse":
 #""Call :meth:`open` with ``method`` set to ``POST``."""
 #w["method"] = "POST"
 #eturn self.open(*args, **kw)

 #ef put(self, *args: t.Any, **kw: t.Any) -> "TestResponse":
 #""Call :meth:`open` with ``method`` set to ``PUT``."""
 #w["method"] = "PUT"
 #eturn self.open(*args, **kw)

 #ef delete(self, *args: t.Any, **kw: t.Any) -> "TestResponse":
 #""Call :meth:`open` with ``method`` set to ``DELETE``."""
 #w["method"] = "DELETE"
 #eturn self.open(*args, **kw)

 #ef patch(self, *args: t.Any, **kw: t.Any) -> "TestResponse":
 #""Call :meth:`open` with ``method`` set to ``PATCH``."""
 #w["method"] = "PATCH"
 #eturn self.open(*args, **kw)

 #ef options(self, *args: t.Any, **kw: t.Any) -> "TestResponse":
 #""Call :meth:`open` with ``method`` set to ``OPTIONS``."""
 #w["method"] = "OPTIONS"
 #eturn self.open(*args, **kw)

 #ef head(self, *args: t.Any, **kw: t.Any) -> "TestResponse":
 #""Call :meth:`open` with ``method`` set to ``HEAD``."""
 #w["method"] = "HEAD"
 #eturn self.open(*args, **kw)

 #ef trace(self, *args: t.Any, **kw: t.Any) -> "TestResponse":
 #""Call :meth:`open` with ``method`` set to ``TRACE``."""
 #w["method"] = "TRACE"
 #eturn self.open(*args, **kw)

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__} {self.application!r}>"


def create_environ(*args: t.Any, **kwargs: t.Any) -> "WSGIEnvironment":
 #""Create a new WSGI environ dict based on the values passed.  The first
 #arameter should be the path of the request which defaults to '/'.  The
 #econd one can either be an absolute path (in that case the host is
 #ocalhost:80) or a full path to the request with scheme, netloc port and
 #he path to the script.

 #his accepts the same arguments as the :class:`EnvironBuilder`
 #onstructor.

 #. versionchanged:: 0.5
 #his function is now a thin wrapper over :class:`EnvironBuilder` which
 #as added in 0.5.  The `headers`, `environ_base`, `environ_overrides`
 #nd `charset` parameters were added.
 #""
 #uilder = EnvironBuilder(*args, **kwargs)

 #ry:
 #eturn builder.get_environ()
 #inally:
 #uilder.close()


def run_wsgi_app(
 #pp: "WSGIApplication", environ: "WSGIEnvironment", buffered: bool = False
) -> t.Tuple[t.Iterable[bytes], str, Headers]:
 #""Return a tuple in the form (app_iter, status, headers) of the
 #pplication output.  This works best if you pass it an application that
 #eturns an iterator all the time.

 #ometimes applications may use the `write()` callable returned
 #y the `start_response` function.  This tries to resolve such edge
 #ases automatically.  But if you don't get the expected output you
 #hould set `buffered` to `True` which enforces buffering.

 #f passed an invalid WSGI application the behavior of this function is
 #ndefined.  Never pass non-conforming WSGI applications to this function.

 #param app: the application to execute.
 #param buffered: set to `True` to enforce buffering.
 #return: tuple in the form ``(app_iter, status, headers)``
 #""
    # Copy environ to ensure any mutations by the app (ProxyFix, for
    # example) don't affect subsequent requests (such as redirects).
 #nviron = _get_environ(environ).copy()
 #tatus: str
 #esponse: t.Optional[t.Tuple[str, t.List[t.Tuple[str, str]]]] = None
 #uffer: t.List[bytes] = []

 #ef start_response(status, headers, exc_info=None):  # type: ignore
 #onlocal response

 #f exc_info:
 #ry:
 #aise exc_info[1].with_traceback(exc_info[2])
 #inally:
 #xc_info = None

 #esponse = (status, headers)
 #eturn buffer.append

 #pp_rv = app(environ, start_response)
 #lose_func = getattr(app_rv, "close", None)
 #pp_iter: t.Iterable[bytes] = iter(app_rv)

    # when buffering we emit the close call early and convert the
    # application iterator into a regular list
 #f buffered:
 #ry:
 #pp_iter = list(app_iter)
 #inally:
 #f close_func is not None:
 #lose_func()

    # otherwise we iterate the application iter until we have a response, chain
    # the already received data with the already collected data and wrap it in
    # a new `ClosingIterator` if we need to restore a `close` callable from the
    # original return value.
 #lse:
 #or item in app_iter:
 #uffer.append(item)

 #f response is not None:
 #reak

 #f buffer:
 #pp_iter = chain(buffer, app_iter)

 #f close_func is not None and app_iter is not app_rv:
 #pp_iter = ClosingIterator(app_iter, close_func)

 #tatus, headers = response  # type: ignore
 #eturn app_iter, status, Headers(headers)


class TestResponse(Response):
 #"":class:`~werkzeug.wrappers.Response` subclass that provides extra
 #nformation about requests made with the test :class:`Client`.

 #est client requests will always return an instance of this class.
 #f a custom response class is passed to the client, it is
 #ubclassed along with this to support test information.

 #f the test request included large files, or if the application is
 #erving a file, call :meth:`close` to close any open files and
 #revent Python showing a ``ResourceWarning``.
 #""

 #equest: Request
 #""A request object with the environ used to make the request that
 #esulted in this response.
 #""

 #istory: t.Tuple["TestResponse", ...]
 #""A list of intermediate responses. Populated when the test request
 #s made with ``follow_redirects`` enabled.
 #""

    # Tell Pytest to ignore this, it's not a test class.
 #_test__ = False

 #ef __init__(
 #elf,
 #esponse: t.Iterable[bytes],
 #tatus: str,
 #eaders: Headers,
 #equest: Request,
 #istory: t.Tuple["TestResponse"] = (),  # type: ignore
 #*kwargs: t.Any,
 # -> None:
 #uper().__init__(response, status, headers, **kwargs)
 #elf.request = request
 #elf.history = history
 #elf._compat_tuple = response, status, headers

 #ef __iter__(self) -> t.Iterator:
 #arnings.warn(
 #
 #The test client no longer returns a tuple, it returns"
 # a 'TestResponse'. Tuple unpacking is deprecated and"
 # will be removed in Werkzeug 2.1. Access the"
 # attributes 'data', 'status', and 'headers' instead."
 #,
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn iter(self._compat_tuple)

 #ef __getitem__(self, item: int) -> t.Any:
 #arnings.warn(
 #
 #The test client no longer returns a tuple, it returns"
 # a 'TestResponse'. Item indexing is deprecated and"
 # will be removed in Werkzeug 2.1. Access the"
 # attributes 'data', 'status', and 'headers' instead."
 #,
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn self._compat_tuple[item]
