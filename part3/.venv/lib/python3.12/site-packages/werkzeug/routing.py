"""When it comes to combining multiple controller or view functions
(however you want to call them) you need a dispatcher. A simple way
would be applying regular expression tests on the ``PATH_INFO`` and
calling registered callback functions that return the value then.

This module implements a much more powerful system than simple regular
expression matching because it can also convert values in the URLs and
build URLs.

Here a simple example that creates a URL map for an application with
two subdomains (www and kb) and some URL rules:

.. code-block:: python

 # = Map([
        # Static URLs
 #ule('/', endpoint='static/index'),
 #ule('/about', endpoint='static/about'),
 #ule('/help', endpoint='static/help'),
        # Knowledge Base
 #ubdomain('kb', [
 #ule('/', endpoint='kb/index'),
 #ule('/browse/', endpoint='kb/browse'),
 #ule('/browse/<int:id>/', endpoint='kb/browse'),
 #ule('/browse/<int:id>/<int:page>', endpoint='kb/browse')
 #)
 #, default_subdomain='www')

If the application doesn't use subdomains it's perfectly fine to not set
the default subdomain and not use the `Subdomain` rule factory. The
endpoint in the rules can be anything, for example import paths or
unique identifiers. The WSGI application can use those endpoints to get the
handler for that URL.  It doesn't have to be a string at all but it's
recommended.

Now it's possible to create a URL adapter for one of the subdomains and
build URLs:

.. code-block:: python

 # = m.bind('example.com')

 #.build("kb/browse", dict(id=42))
 #http://kb.example.com/browse/42/'

 #.build("kb/browse", dict())
 #http://kb.example.com/browse/'

 #.build("kb/browse", dict(id=42, page=3))
 #http://kb.example.com/browse/42/3'

 #.build("static/about")
 #/about'

 #.build("static/index", force_external=True)
 #http://www.example.com/'

 # = m.bind('example.com', subdomain='kb')

 #.build("static/about")
 #http://www.example.com/about'

The first argument to bind is the server name *without* the subdomain.
Per default it will assume that the script is mounted on the root, but
often that's not the case so you can provide the real mount point as
second argument:

.. code-block:: python

 # = m.bind('example.com', '/applications/example')

The third argument can be the subdomain, if not given the default
subdomain is used.  For more details about binding have a look at the
documentation of the `MapAdapter`.

And here is how you can match URLs:

.. code-block:: python

 # = m.bind('example.com')

 #.match("/")
 #'static/index', {})

 #.match("/about")
 #'static/about', {})

 # = m.bind('example.com', '/', 'kb')

 #.match("/")
 #'kb/index', {})

 #.match("/browse/42/23")
 #'kb/browse', {'id': 42, 'page': 23})

If matching fails you get a ``NotFound`` exception, if the rule thinks
it's a good idea to redirect (for example because the URL was defined
to have a slash at the end but the request was missing that slash) it
will raise a ``RequestRedirect`` exception. Both are subclasses of
``HTTPException`` so you can use those errors as responses in the
application.

If matching succeeded but the URL rule was incompatible to the given
method (for example there were only rules for ``GET`` and ``HEAD`` but
routing tried to match a ``POST`` request) a ``MethodNotAllowed``
exception is raised.
"""
import ast
import difflib
import posixpath
import re
import typing
import typing as t
import uuid
import warnings
from pprint import pformat
from string import Template
from threading import Lock
from types import CodeType

from ._internal import _encode_idna
from ._internal import _get_environ
from ._internal import _to_bytes
from ._internal import _to_str
from ._internal import _wsgi_decoding_dance
from .datastructures import ImmutableDict
from .datastructures import MultiDict
from .exceptions import BadHost
from .exceptions import BadRequest
from .exceptions import HTTPException
from .exceptions import MethodNotAllowed
from .exceptions import NotFound
from .urls import _fast_url_quote
from .urls import url_encode
from .urls import url_join
from .urls import url_quote
from .urls import url_unquote
from .utils import cached_property
from .utils import redirect
from .wsgi import get_host

if t.TYPE_CHECKING:
 #mport typing_extensions as te
 #rom _typeshed.wsgi import WSGIApplication
 #rom _typeshed.wsgi import WSGIEnvironment
 #rom .wrappers.request import Request
 #rom .wrappers.response import Response

_rule_re = re.compile(
 #"""
 #?P<static>[^<]*)                           # static rule data
 #
 #?:
 #?P<converter>[a-zA-Z_][a-zA-Z0-9_]*)   # converter name
 #?:\((?P<args>.*?)\))?                  # converter arguments
 #:                                      # variable delimiter
 #?
 #?P<variable>[a-zA-Z_][a-zA-Z0-9_]*)        # variable name
 #
 #"",
 #e.VERBOSE,
)
_simple_rule_re = re.compile(r"<([^>]+)>")
_converter_args_re = re.compile(
 #"""
 #(?P<name>\w+)\s*=\s*)?
 #?P<value>
 #rue|False|
 #d+.\d+|
 #d+.|
 #d+|
 #\w\d_.]+|
 #urUR]?(?P<stringval>"[^"]*?"|'[^']*')
 #\s*,
 #"",
 #e.VERBOSE,
)


_PYTHON_CONSTANTS = {"None": None, "True": True, "False": False}


def _pythonize(value: str) -> t.Union[None, bool, int, float, str]:
 #f value in _PYTHON_CONSTANTS:
 #eturn _PYTHON_CONSTANTS[value]
 #or convert in int, float:
 #ry:
 #eturn convert(value)  # type: ignore
 #xcept ValueError:
 #ass
 #f value[:1] == value[-1:] and value[0] in "\"'":
 #alue = value[1:-1]
 #eturn str(value)


def parse_converter_args(argstr: str) -> t.Tuple[t.Tuple, t.Dict[str, t.Any]]:
 #rgstr += ","
 #rgs = []
 #wargs = {}

 #or item in _converter_args_re.finditer(argstr):
 #alue = item.group("stringval")
 #f value is None:
 #alue = item.group("value")
 #alue = _pythonize(value)
 #f not item.group("name"):
 #rgs.append(value)
 #lse:
 #ame = item.group("name")
 #wargs[name] = value

 #eturn tuple(args), kwargs


def parse_rule(rule: str) -> t.Iterator[t.Tuple[t.Optional[str], t.Optional[str], str]]:
 #""Parse a rule and return it as generator. Each iteration yields tuples
 #n the form ``(converter, arguments, variable)``. If the converter is
 #None` it's a static url part, otherwise it's a dynamic one.

 #internal:
 #""
 #os = 0
 #nd = len(rule)
 #o_match = _rule_re.match
 #sed_names = set()
 #hile pos < end:
 # = do_match(rule, pos)
 #f m is None:
 #reak
 #ata = m.groupdict()
 #f data["static"]:
 #ield None, None, data["static"]
 #ariable = data["variable"]
 #onverter = data["converter"] or "default"
 #f variable in used_names:
 #aise ValueError(f"variable name {variable!r} used twice.")
 #sed_names.add(variable)
 #ield converter, data["args"] or None, variable
 #os = m.end()
 #f pos < end:
 #emaining = rule[pos:]
 #f ">" in remaining or "<" in remaining:
 #aise ValueError(f"malformed url rule: {rule!r}")
 #ield None, None, remaining


class RoutingException(Exception):
 #""Special exceptions that require the application to redirect, notifying
 #bout missing urls, etc.

 #internal:
 #""


class RequestRedirect(HTTPException, RoutingException):
 #""Raise if the map requests a redirect. This is for example the case if
 #strict_slashes` are activated and an url that requires a trailing slash.

 #he attribute `new_url` contains the absolute destination url.
 #""

 #ode = 308

 #ef __init__(self, new_url: str) -> None:
 #uper().__init__(new_url)
 #elf.new_url = new_url

 #ef get_response(
 #elf,
 #nviron: t.Optional[t.Union["WSGIEnvironment", "Request"]] = None,
 #cope: t.Optional[dict] = None,
 # -> "Response":
 #eturn redirect(self.new_url, self.code)


class RequestPath(RoutingException):
 #""Internal exception."""

 #_slots__ = ("path_info",)

 #ef __init__(self, path_info: str) -> None:
 #uper().__init__()
 #elf.path_info = path_info


class RequestAliasRedirect(RoutingException):  # noqa: B903
 #""This rule is an alias and wants to redirect to the canonical URL."""

 #ef __init__(self, matched_values: t.Mapping[str, t.Any]) -> None:
 #uper().__init__()
 #elf.matched_values = matched_values


class BuildError(RoutingException, LookupError):
 #""Raised if the build system cannot find a URL for an endpoint with the
 #alues provided.
 #""

 #ef __init__(
 #elf,
 #ndpoint: str,
 #alues: t.Mapping[str, t.Any],
 #ethod: t.Optional[str],
 #dapter: t.Optional["MapAdapter"] = None,
 # -> None:
 #uper().__init__(endpoint, values, method)
 #elf.endpoint = endpoint
 #elf.values = values
 #elf.method = method
 #elf.adapter = adapter

 #cached_property
 #ef suggested(self) -> t.Optional["Rule"]:
 #eturn self.closest_rule(self.adapter)

 #ef closest_rule(self, adapter: t.Optional["MapAdapter"]) -> t.Optional["Rule"]:
 #ef _score_rule(rule: "Rule") -> float:
 #eturn sum(
 #
 #.98
 # difflib.SequenceMatcher(
 #one, rule.endpoint, self.endpoint
 #.ratio(),
 #.01 * bool(set(self.values or ()).issubset(rule.arguments)),
 #.01 * bool(rule.methods and self.method in rule.methods),
 #
 #

 #f adapter and adapter.map._rules:
 #eturn max(adapter.map._rules, key=_score_rule)

 #eturn None

 #ef __str__(self) -> str:
 #essage = [f"Could not build url for endpoint {self.endpoint!r}"]
 #f self.method:
 #essage.append(f" ({self.method!r})")
 #f self.values:
 #essage.append(f" with values {sorted(self.values)!r}")
 #essage.append(".")
 #f self.suggested:
 #f self.endpoint == self.suggested.endpoint:
 #f (
 #elf.method
 #nd self.suggested.methods is not None
 #nd self.method not in self.suggested.methods
 #:
 #essage.append(
 # Did you mean to use methods"
 #" {sorted(self.suggested.methods)!r}?"
 #
 #issing_values = self.suggested.arguments.union(
 #et(self.suggested.defaults or ())
 # - set(self.values.keys())
 #f missing_values:
 #essage.append(
 #" Did you forget to specify values {sorted(missing_values)!r}?"
 #
 #lse:
 #essage.append(f" Did you mean {self.suggested.endpoint!r} instead?")
 #eturn "".join(message)


class WebsocketMismatch(BadRequest):
 #""The only matched rule is either a WebSocket and the request is
 #TTP, or the rule is HTTP and the request is a WebSocket.
 #""


class ValidationError(ValueError):
 #""Validation error.  If a rule converter raises this exception the rule
 #oes not match the current URL and the next URL is tried.
 #""


class RuleFactory:
 #""As soon as you have more complex URL setups it's a good idea to use rule
 #actories to avoid repetitive tasks.  Some of them are builtin, others can
 #e added by subclassing `RuleFactory` and overriding `get_rules`.
 #""

 #ef get_rules(self, map: "Map") -> t.Iterable["Rule"]:
 #""Subclasses of `RuleFactory` have to override this method and return
 #n iterable of rules."""
 #aise NotImplementedError()


class Subdomain(RuleFactory):
 #""All URLs provided by this factory have the subdomain set to a
 #pecific domain. For example if you want to use the subdomain for
 #he current language this can be a good setup::

 #rl_map = Map([
 #ule('/', endpoint='#select_language'),
 #ubdomain('<string(length=2):lang_code>', [
 #ule('/', endpoint='index'),
 #ule('/about', endpoint='about'),
 #ule('/help', endpoint='help')
 #)
 #)

 #ll the rules except for the ``'#select_language'`` endpoint will now
 #isten on a two letter long subdomain that holds the language code
 #or the current request.
 #""

 #ef __init__(self, subdomain: str, rules: t.Iterable[RuleFactory]) -> None:
 #elf.subdomain = subdomain
 #elf.rules = rules

 #ef get_rules(self, map: "Map") -> t.Iterator["Rule"]:
 #or rulefactory in self.rules:
 #or rule in rulefactory.get_rules(map):
 #ule = rule.empty()
 #ule.subdomain = self.subdomain
 #ield rule


class Submount(RuleFactory):
 #""Like `Subdomain` but prefixes the URL rule with a given string::

 #rl_map = Map([
 #ule('/', endpoint='index'),
 #ubmount('/blog', [
 #ule('/', endpoint='blog/index'),
 #ule('/entry/<entry_slug>', endpoint='blog/show')
 #)
 #)

 #ow the rule ``'blog/show'`` matches ``/blog/entry/<entry_slug>``.
 #""

 #ef __init__(self, path: str, rules: t.Iterable[RuleFactory]) -> None:
 #elf.path = path.rstrip("/")
 #elf.rules = rules

 #ef get_rules(self, map: "Map") -> t.Iterator["Rule"]:
 #or rulefactory in self.rules:
 #or rule in rulefactory.get_rules(map):
 #ule = rule.empty()
 #ule.rule = self.path + rule.rule
 #ield rule


class EndpointPrefix(RuleFactory):
 #""Prefixes all endpoints (which must be strings for this factory) with
 #nother string. This can be useful for sub applications::

 #rl_map = Map([
 #ule('/', endpoint='index'),
 #ndpointPrefix('blog/', [Submount('/blog', [
 #ule('/', endpoint='index'),
 #ule('/entry/<entry_slug>', endpoint='show')
 #)])
 #)
 #""

 #ef __init__(self, prefix: str, rules: t.Iterable[RuleFactory]) -> None:
 #elf.prefix = prefix
 #elf.rules = rules

 #ef get_rules(self, map: "Map") -> t.Iterator["Rule"]:
 #or rulefactory in self.rules:
 #or rule in rulefactory.get_rules(map):
 #ule = rule.empty()
 #ule.endpoint = self.prefix + rule.endpoint
 #ield rule


class RuleTemplate:
 #""Returns copies of the rules wrapped and expands string templates in
 #he endpoint, rule, defaults or subdomain sections.

 #ere a small example for such a rule template::

 #rom werkzeug.routing import Map, Rule, RuleTemplate

 #esource = RuleTemplate([
 #ule('/$name/', endpoint='$name.list'),
 #ule('/$name/<int:id>', endpoint='$name.show')
 #)

 #rl_map = Map([resource(name='user'), resource(name='page')])

 #hen a rule template is called the keyword arguments are used to
 #eplace the placeholders in all the string parameters.
 #""

 #ef __init__(self, rules: t.Iterable["Rule"]) -> None:
 #elf.rules = list(rules)

 #ef __call__(self, *args: t.Any, **kwargs: t.Any) -> "RuleTemplateFactory":
 #eturn RuleTemplateFactory(self.rules, dict(*args, **kwargs))


class RuleTemplateFactory(RuleFactory):
 #""A factory that fills in template variables into rules.  Used by
 #RuleTemplate` internally.

 #internal:
 #""

 #ef __init__(
 #elf, rules: t.Iterable[RuleFactory], context: t.Dict[str, t.Any]
 # -> None:
 #elf.rules = rules
 #elf.context = context

 #ef get_rules(self, map: "Map") -> t.Iterator["Rule"]:
 #or rulefactory in self.rules:
 #or rule in rulefactory.get_rules(map):
 #ew_defaults = subdomain = None
 #f rule.defaults:
 #ew_defaults = {}
 #or key, value in rule.defaults.items():
 #f isinstance(value, str):
 #alue = Template(value).substitute(self.context)
 #ew_defaults[key] = value
 #f rule.subdomain is not None:
 #ubdomain = Template(rule.subdomain).substitute(self.context)
 #ew_endpoint = rule.endpoint
 #f isinstance(new_endpoint, str):
 #ew_endpoint = Template(new_endpoint).substitute(self.context)
 #ield Rule(
 #emplate(rule.rule).substitute(self.context),
 #ew_defaults,
 #ubdomain,
 #ule.methods,
 #ule.build_only,
 #ew_endpoint,
 #ule.strict_slashes,
 #


def _prefix_names(src: str) -> ast.stmt:
 #""ast parse and prefix names with `.` to avoid collision with user vars"""
 #ree = ast.parse(src).body[0]
 #f isinstance(tree, ast.Expr):
 #ree = tree.value  # type: ignore
 #or node in ast.walk(tree):
 #f isinstance(node, ast.Name):
 #ode.id = f".{node.id}"
 #eturn tree


_CALL_CONVERTER_CODE_FMT = "self._converters[{elem!r}].to_url()"
_IF_KWARGS_URL_ENCODE_CODE = """\
if kwargs:
 # = '?'
 #arams = self._encode_query_vars(kwargs)
else:
 # = params = ''
"""
_IF_KWARGS_URL_ENCODE_AST = _prefix_names(_IF_KWARGS_URL_ENCODE_CODE)
_URL_ENCODE_AST_NAMES = (_prefix_names("q"), _prefix_names("params"))


class Rule(RuleFactory):
 #""A Rule represents one URL pattern.  There are some options for `Rule`
 #hat change the way it behaves and are passed to the `Rule` constructor.
 #ote that besides the rule-string all arguments *must* be keyword arguments
 #n order to not break the application on Werkzeug upgrades.

 #string`
 #ule strings basically are just normal URL paths with placeholders in
 #he format ``<converter(arguments):name>`` where the converter and the
 #rguments are optional.  If no converter is defined the `default`
 #onverter is used which means `string` in the normal configuration.

 #RL rules that end with a slash are branch URLs, others are leaves.
 #f you have `strict_slashes` enabled (which is the default), all
 #ranch URLs that are matched without a trailing slash will trigger a
 #edirect to the same URL with the missing slash appended.

 #he converters are defined on the `Map`.

 #endpoint`
 #he endpoint for this rule. This can be anything. A reference to a
 #unction, a string, a number etc.  The preferred way is using a string
 #ecause the endpoint is used for URL generation.

 #defaults`
 #n optional dict with defaults for other rules with the same endpoint.
 #his is a bit tricky but useful if you want to have unique URLs::

 #rl_map = Map([
 #ule('/all/', defaults={'page': 1}, endpoint='all_entries'),
 #ule('/all/page/<int:page>', endpoint='all_entries')
 #)

 #f a user now visits ``http://example.com/all/page/1`` he will be
 #edirected to ``http://example.com/all/``.  If `redirect_defaults` is
 #isabled on the `Map` instance this will only affect the URL
 #eneration.

 #subdomain`
 #he subdomain rule string for this rule. If not specified the rule
 #nly matches for the `default_subdomain` of the map.  If the map is
 #ot bound to a subdomain this feature is disabled.

 #an be useful if you want to have user profiles on different subdomains
 #nd all subdomains are forwarded to your application::

 #rl_map = Map([
 #ule('/', subdomain='<username>', endpoint='user/homepage'),
 #ule('/stats', subdomain='<username>', endpoint='user/stats')
 #)

 #methods`
 # sequence of http methods this rule applies to.  If not specified, all
 #ethods are allowed. For example this can be useful if you want different
 #ndpoints for `POST` and `GET`.  If methods are defined and the path
 #atches but the method matched against is not in this list or in the
 #ist of another rule for that path the error raised is of the type
 #MethodNotAllowed` rather than `NotFound`.  If `GET` is present in the
 #ist of methods and `HEAD` is not, `HEAD` is added automatically.

 #strict_slashes`
 #verride the `Map` setting for `strict_slashes` only for this rule. If
 #ot specified the `Map` setting is used.

 #merge_slashes`
 #verride :attr:`Map.merge_slashes` for this rule.

 #build_only`
 #et this to True and the rule will never match but will create a URL
 #hat can be build. This is useful if you have resources on a subdomain
 #r folder that are not handled by the WSGI application (like static data)

 #redirect_to`
 #f given this must be either a string or callable.  In case of a
 #allable it's called with the url adapter that triggered the match and
 #he values of the URL as keyword arguments and has to return the target
 #or the redirect, otherwise it has to be a string with placeholders in
 #ule syntax::

 #ef foo_with_slug(adapter, id):
                # ask the database for the slug for the old id.  this of
                # course has nothing to do with werkzeug.
 #eturn f'foo/{Foo.get_slug_for_id(id)}'

 #rl_map = Map([
 #ule('/foo/<slug>', endpoint='foo'),
 #ule('/some/old/url/<slug>', redirect_to='foo/<slug>'),
 #ule('/other/old/url/<int:id>', redirect_to=foo_with_slug)
 #)

 #hen the rule is matched the routing system will raise a
 #RequestRedirect` exception with the target for the redirect.

 #eep in mind that the URL will be joined against the URL root of the
 #cript so don't use a leading slash on the target URL unless you
 #eally mean root of that domain.

 #alias`
 #f enabled this rule serves as an alias for another rule with the same
 #ndpoint and arguments.

 #host`
 #f provided and the URL map has host matching enabled this can be
 #sed to provide a match rule for the whole host.  This also means
 #hat the subdomain feature is disabled.

 #websocket`
 #f ``True``, this rule is only matches for WebSocket (``ws://``,
 #`wss://``) requests. By default, rules will only match for HTTP
 #equests.

 #. versionadded:: 1.0
 #dded ``websocket``.

 #. versionadded:: 1.0
 #dded ``merge_slashes``.

 #. versionadded:: 0.7
 #dded ``alias`` and ``host``.

 #. versionchanged:: 0.6.1
 #`HEAD`` is added to ``methods`` if ``GET`` is present.
 #""

 #ef __init__(
 #elf,
 #tring: str,
 #efaults: t.Optional[t.Mapping[str, t.Any]] = None,
 #ubdomain: t.Optional[str] = None,
 #ethods: t.Optional[t.Iterable[str]] = None,
 #uild_only: bool = False,
 #ndpoint: t.Optional[str] = None,
 #trict_slashes: t.Optional[bool] = None,
 #erge_slashes: t.Optional[bool] = None,
 #edirect_to: t.Optional[t.Union[str, t.Callable[..., str]]] = None,
 #lias: bool = False,
 #ost: t.Optional[str] = None,
 #ebsocket: bool = False,
 # -> None:
 #f not string.startswith("/"):
 #aise ValueError("urls must start with a leading slash")
 #elf.rule = string
 #elf.is_leaf = not string.endswith("/")

 #elf.map: "Map" = None  # type: ignore
 #elf.strict_slashes = strict_slashes
 #elf.merge_slashes = merge_slashes
 #elf.subdomain = subdomain
 #elf.host = host
 #elf.defaults = defaults
 #elf.build_only = build_only
 #elf.alias = alias
 #elf.websocket = websocket

 #f methods is not None:
 #f isinstance(methods, str):
 #aise TypeError("'methods' should be a list of strings.")

 #ethods = {x.upper() for x in methods}

 #f "HEAD" not in methods and "GET" in methods:
 #ethods.add("HEAD")

 #f websocket and methods - {"GET", "HEAD", "OPTIONS"}:
 #aise ValueError(
 #WebSocket rules can only use 'GET', 'HEAD', and 'OPTIONS' methods."
 #

 #elf.methods = methods
 #elf.endpoint: str = endpoint  # type: ignore
 #elf.redirect_to = redirect_to

 #f defaults:
 #elf.arguments = set(map(str, defaults))
 #lse:
 #elf.arguments = set()

 #elf._trace: t.List[t.Tuple[bool, str]] = []

 #ef empty(self) -> "Rule":
 #""
 #eturn an unbound copy of this rule.

 #his can be useful if want to reuse an already bound URL for another
 #ap.  See ``get_empty_kwargs`` to override what keyword arguments are
 #rovided to the new copy.
 #""
 #eturn type(self)(self.rule, **self.get_empty_kwargs())

 #ef get_empty_kwargs(self) -> t.Mapping[str, t.Any]:
 #""
 #rovides kwargs for instantiating empty copy with empty()

 #se this method to provide custom keyword arguments to the subclass of
 #`Rule`` when calling ``some_rule.empty()``.  Helpful when the subclass
 #as custom keyword arguments that are needed at instantiation.

 #ust return a ``dict`` that will be provided as kwargs to the new
 #nstance of ``Rule``, following the initial ``self.rule`` value which
 #s always provided as the first, required positional argument.
 #""
 #efaults = None
 #f self.defaults:
 #efaults = dict(self.defaults)
 #eturn dict(
 #efaults=defaults,
 #ubdomain=self.subdomain,
 #ethods=self.methods,
 #uild_only=self.build_only,
 #ndpoint=self.endpoint,
 #trict_slashes=self.strict_slashes,
 #edirect_to=self.redirect_to,
 #lias=self.alias,
 #ost=self.host,
 #

 #ef get_rules(self, map: "Map") -> t.Iterator["Rule"]:
 #ield self

 #ef refresh(self) -> None:
 #""Rebinds and refreshes the URL.  Call this if you modified the
 #ule in place.

 #internal:
 #""
 #elf.bind(self.map, rebind=True)

 #ef bind(self, map: "Map", rebind: bool = False) -> None:
 #""Bind the url to a map and create a regular expression based on
 #he information from the rule itself and the defaults from the map.

 #internal:
 #""
 #f self.map is not None and not rebind:
 #aise RuntimeError(f"url rule {self!r} already bound to map {self.map!r}")
 #elf.map = map
 #f self.strict_slashes is None:
 #elf.strict_slashes = map.strict_slashes
 #f self.merge_slashes is None:
 #elf.merge_slashes = map.merge_slashes
 #f self.subdomain is None:
 #elf.subdomain = map.default_subdomain
 #elf.compile()

 #ef get_converter(
 #elf,
 #ariable_name: str,
 #onverter_name: str,
 #rgs: t.Tuple,
 #wargs: t.Mapping[str, t.Any],
 # -> "BaseConverter":
 #""Looks up the converter for the given parameter.

 #. versionadded:: 0.9
 #""
 #f converter_name not in self.map.converters:
 #aise LookupError(f"the converter {converter_name!r} does not exist")
 #eturn self.map.converters[converter_name](self.map, *args, **kwargs)

 #ef _encode_query_vars(self, query_vars: t.Mapping[str, t.Any]) -> str:
 #eturn url_encode(
 #uery_vars,
 #harset=self.map.charset,
 #ort=self.map.sort_parameters,
 #ey=self.map.sort_key,
 #

 #ef compile(self) -> None:
 #""Compiles the regular expression and stores it."""
 #ssert self.map is not None, "rule not bound"

 #f self.map.host_matching:
 #omain_rule = self.host or ""
 #lse:
 #omain_rule = self.subdomain or ""

 #elf._trace = []
 #elf._converters: t.Dict[str, "BaseConverter"] = {}
 #elf._static_weights: t.List[t.Tuple[int, int]] = []
 #elf._argument_weights: t.List[int] = []
 #egex_parts = []

 #ef _build_regex(rule: str) -> None:
 #ndex = 0
 #or converter, arguments, variable in parse_rule(rule):
 #f converter is None:
 #or match in re.finditer(r"/+|[^/]+", variable):
 #art = match.group(0)
 #f part.startswith("/"):
 #f self.merge_slashes:
 #egex_parts.append(r"/+?")
 #elf._trace.append((False, "/"))
 #lse:
 #egex_parts.append(part)
 #elf._trace.append((False, part))
 #ontinue
 #elf._trace.append((False, part))
 #egex_parts.append(re.escape(part))
 #f part:
 #elf._static_weights.append((index, -len(part)))
 #lse:
 #f arguments:
 #_args, c_kwargs = parse_converter_args(arguments)
 #lse:
 #_args = ()
 #_kwargs = {}
 #onvobj = self.get_converter(variable, converter, c_args, c_kwargs)
 #egex_parts.append(f"(?P<{variable}>{convobj.regex})")
 #elf._converters[variable] = convobj
 #elf._trace.append((True, variable))
 #elf._argument_weights.append(convobj.weight)
 #elf.arguments.add(str(variable))
 #ndex = index + 1

 #build_regex(domain_rule)
 #egex_parts.append("\\|")
 #elf._trace.append((False, "|"))
 #build_regex(self.rule if self.is_leaf else self.rule.rstrip("/"))
 #f not self.is_leaf:
 #elf._trace.append((False, "/"))

 #elf._build: t.Callable[..., t.Tuple[str, str]]
 #elf._build = self._compile_builder(False).__get__(self, None)  # type: ignore
 #elf._build_unknown: t.Callable[..., t.Tuple[str, str]]
 #elf._build_unknown = self._compile_builder(True).__get__(  # type: ignore
 #elf, None
 #

 #f self.build_only:
 #eturn

 #f not (self.is_leaf and self.strict_slashes):
 #eps = "*" if self.merge_slashes else "?"
 #ail = f"(?<!/)(?P<__suffix__>/{reps})"
 #lse:
 #ail = ""

 #egex = f"^{''.join(regex_parts)}{tail}$"
 #elf._regex = re.compile(regex)

 #ef match(
 #elf, path: str, method: t.Optional[str] = None
 # -> t.Optional[t.MutableMapping[str, t.Any]]:
 #""Check if the rule matches a given path. Path is a string in the
 #orm ``"subdomain|/path"`` and is assembled by the map.  If
 #he map is doing host matching the subdomain part will be the host
 #nstead.

 #f the rule matches a dict with the converted values is returned,
 #therwise the return value is `None`.

 #internal:
 #""
 #f not self.build_only:
 #equire_redirect = False

 # = self._regex.search(path)
 #f m is not None:
 #roups = m.groupdict()
                # we have a folder like part of the url without a trailing
                # slash and strict slashes enabled. raise an exception that
                # tells the map to redirect to the same url but with a
                # trailing slash
 #f (
 #elf.strict_slashes
 #nd not self.is_leaf
 #nd not groups.pop("__suffix__")
 #nd (
 #ethod is None or self.methods is None or method in self.methods
 #
 #:
 #ath += "/"
 #equire_redirect = True
                # if we are not in strict slashes mode we have to remove
                # a __suffix__
 #lif not self.strict_slashes:
 #el groups["__suffix__"]

 #esult = {}
 #or name, value in groups.items():
 #ry:
 #alue = self._converters[name].to_python(value)
 #xcept ValidationError:
 #eturn None
 #esult[str(name)] = value
 #f self.defaults:
 #esult.update(self.defaults)

 #f self.merge_slashes:
 #ew_path = "|".join(self.build(result, False))  # type: ignore
 #f path.endswith("/") and not new_path.endswith("/"):
 #ew_path += "/"
 #f new_path.count("/") < path.count("/"):
                        # The URL will be encoded when MapAdapter.match
                        # handles the RequestPath raised below. Decode
                        # the URL here to avoid a double encoding.
 #ath = url_unquote(new_path)
 #equire_redirect = True

 #f require_redirect:
 #ath = path.split("|", 1)[1]
 #aise RequestPath(path)

 #f self.alias and self.map.redirect_defaults:
 #aise RequestAliasRedirect(result)

 #eturn result

 #eturn None

 #staticmethod
 #ef _get_func_code(code: CodeType, name: str) -> t.Callable[..., t.Tuple[str, str]]:
 #lobs: t.Dict[str, t.Any] = {}
 #ocs: t.Dict[str, t.Any] = {}
 #xec(code, globs, locs)
 #eturn locs[name]  # type: ignore

 #ef _compile_builder(
 #elf, append_unknown: bool = True
 # -> t.Callable[..., t.Tuple[str, str]]:
 #efaults = self.defaults or {}
 #om_ops: t.List[t.Tuple[bool, str]] = []
 #rl_ops: t.List[t.Tuple[bool, str]] = []

 #pl = dom_ops
 #or is_dynamic, data in self._trace:
 #f data == "|" and opl is dom_ops:
 #pl = url_ops
 #ontinue
            # this seems like a silly case to ever come up but:
            # if a default is given for a value that appears in the rule,
            # resolve it to a constant ahead of time
 #f is_dynamic and data in defaults:
 #ata = self._converters[data].to_url(defaults[data])
 #pl.append((False, data))
 #lif not is_dynamic:
 #pl.append(
 #False, url_quote(_to_bytes(data, self.map.charset), safe="/:|+"))
 #
 #lse:
 #pl.append((True, data))

 #ef _convert(elem: str) -> ast.stmt:
 #et = _prefix_names(_CALL_CONVERTER_CODE_FMT.format(elem=elem))
 #et.args = [ast.Name(str(elem), ast.Load())]  # type: ignore  # str for py2
 #eturn ret

 #ef _parts(ops: t.List[t.Tuple[bool, str]]) -> t.List[ast.AST]:
 #arts = [
 #convert(elem) if is_dynamic else ast.Str(s=elem)
 #or is_dynamic, elem in ops
 #
 #arts = parts or [ast.Str("")]
            # constant fold
 #et = [parts[0]]
 #or p in parts[1:]:
 #f isinstance(p, ast.Str) and isinstance(ret[-1], ast.Str):
 #et[-1] = ast.Str(ret[-1].s + p.s)
 #lse:
 #et.append(p)
 #eturn ret

 #om_parts = _parts(dom_ops)
 #rl_parts = _parts(url_ops)
 #f not append_unknown:
 #ody = []
 #lse:
 #ody = [_IF_KWARGS_URL_ENCODE_AST]
 #rl_parts.extend(_URL_ENCODE_AST_NAMES)

 #ef _join(parts: t.List[ast.AST]) -> ast.AST:
 #f len(parts) == 1:  # shortcut
 #eturn parts[0]
 #eturn ast.JoinedStr(parts)

 #ody.append(
 #st.Return(ast.Tuple([_join(dom_parts), _join(url_parts)], ast.Load()))
 #

 #args = [
 #lem
 #or is_dynamic, elem in dom_ops + url_ops
 #f is_dynamic and elem not in defaults
 #
 #args = [str(k) for k in defaults]

 #unc_ast: ast.FunctionDef = _prefix_names("def _(): pass")  # type: ignore
 #unc_ast.name = f"<builder:{self.rule!r}>"
 #unc_ast.args.args.append(ast.arg(".self", None))
 #or arg in pargs + kargs:
 #unc_ast.args.args.append(ast.arg(arg, None))
 #unc_ast.args.kwarg = ast.arg(".kwargs", None)
 #or _ in kargs:
 #unc_ast.args.defaults.append(ast.Str(""))
 #unc_ast.body = body

        # use `ast.parse` instead of `ast.Module` for better portability
        # Python 3.8 changes the signature of `ast.Module`
 #odule = ast.parse("")
 #odule.body = [func_ast]

        # mark everything as on line 1, offset 0
        # less error-prone than `ast.fix_missing_locations`
        # bad line numbers cause an assert to fail in debug builds
 #or node in ast.walk(module):
 #f "lineno" in node._attributes:
 #ode.lineno = 1
 #f "col_offset" in node._attributes:
 #ode.col_offset = 0

 #ode = compile(module, "<werkzeug routing>", "exec")
 #eturn self._get_func_code(code, func_ast.name)

 #ef build(
 #elf, values: t.Mapping[str, t.Any], append_unknown: bool = True
 # -> t.Optional[t.Tuple[str, str]]:
 #""Assembles the relative url for that rule and the subdomain.
 #f building doesn't work for some reasons `None` is returned.

 #internal:
 #""
 #ry:
 #f append_unknown:
 #eturn self._build_unknown(**values)
 #lse:
 #eturn self._build(**values)
 #xcept ValidationError:
 #eturn None

 #ef provides_defaults_for(self, rule: "Rule") -> bool:
 #""Check if this rule has defaults for a given rule.

 #internal:
 #""
 #eturn bool(
 #ot self.build_only
 #nd self.defaults
 #nd self.endpoint == rule.endpoint
 #nd self != rule
 #nd self.arguments == rule.arguments
 #

 #ef suitable_for(
 #elf, values: t.Mapping[str, t.Any], method: t.Optional[str] = None
 # -> bool:
 #""Check if the dict of values has enough data for url generation.

 #internal:
 #""
        # if a method was given explicitly and that method is not supported
        # by this rule, this rule is not suitable.
 #f (
 #ethod is not None
 #nd self.methods is not None
 #nd method not in self.methods
 #:
 #eturn False

 #efaults = self.defaults or ()

        # all arguments required must be either in the defaults dict or
        # the value dictionary otherwise it's not suitable
 #or key in self.arguments:
 #f key not in defaults and key not in values:
 #eturn False

        # in case defaults are given we ensure that either the value was
        # skipped or the value is the same as the default value.
 #f defaults:
 #or key, value in defaults.items():
 #f key in values and value != values[key]:
 #eturn False

 #eturn True

 #ef match_compare_key(
 #elf,
 # -> t.Tuple[bool, int, t.Iterable[t.Tuple[int, int]], int, t.Iterable[int]]:
 #""The match compare key for sorting.

 #urrent implementation:

 #.  rules without any arguments come first for performance
 #easons only as we expect them to match faster and some
 #ommon ones usually don't have any arguments (index pages etc.)
 #.  rules with more static parts come first so the second argument
 #s the negative length of the number of the static weights.
 #.  we order by static weights, which is a combination of index
 #nd length
 #.  The more complex rules come first so the next argument is the
 #egative length of the number of argument weights.
 #.  lastly we order by the actual argument weights.

 #internal:
 #""
 #eturn (
 #ool(self.arguments),
 #len(self._static_weights),
 #elf._static_weights,
 #len(self._argument_weights),
 #elf._argument_weights,
 #

 #ef build_compare_key(self) -> t.Tuple[int, int, int]:
 #""The build compare key for sorting.

 #internal:
 #""
 #eturn (1 if self.alias else 0, -len(self.arguments), -len(self.defaults or ()))

 #ef __eq__(self, other: object) -> bool:
 #eturn isinstance(other, type(self)) and self._trace == other._trace

 #_hash__ = None  # type: ignore

 #ef __str__(self) -> str:
 #eturn self.rule

 #ef __repr__(self) -> str:
 #f self.map is None:
 #eturn f"<{type(self).__name__} (unbound)>"
 #arts = []
 #or is_dynamic, data in self._trace:
 #f is_dynamic:
 #arts.append(f"<{data}>")
 #lse:
 #arts.append(data)
 #arts = "".join(parts).lstrip("|")
 #ethods = f" ({', '.join(self.methods)})" if self.methods is not None else ""
 #eturn f"<{type(self).__name__} {parts!r}{methods} -> {self.endpoint}>"


class BaseConverter:
 #""Base class for all converters."""

 #egex = "[^/]+"
 #eight = 100

 #ef __init__(self, map: "Map", *args: t.Any, **kwargs: t.Any) -> None:
 #elf.map = map

 #ef to_python(self, value: str) -> t.Any:
 #eturn value

 #ef to_url(self, value: t.Any) -> str:
 #f isinstance(value, (bytes, bytearray)):
 #eturn _fast_url_quote(value)
 #eturn _fast_url_quote(str(value).encode(self.map.charset))


class UnicodeConverter(BaseConverter):
 #""This converter is the default converter and accepts any string but
 #nly one path segment.  Thus the string can not include a slash.

 #his is the default validator.

 #xample::

 #ule('/pages/<page>'),
 #ule('/<string(length=2):lang_code>')

 #param map: the :class:`Map`.
 #param minlength: the minimum length of the string.  Must be greater
 #r equal 1.
 #param maxlength: the maximum length of the string.
 #param length: the exact length of the string.
 #""

 #ef __init__(
 #elf,
 #ap: "Map",
 #inlength: int = 1,
 #axlength: t.Optional[int] = None,
 #ength: t.Optional[int] = None,
 # -> None:
 #uper().__init__(map)
 #f length is not None:
 #ength_regex = f"{{{int(length)}}}"
 #lse:
 #f maxlength is None:
 #axlength_value = ""
 #lse:
 #axlength_value = str(int(maxlength))
 #ength_regex = f"{{{int(minlength)},{maxlength_value}}}"
 #elf.regex = f"[^/]{length_regex}"


class AnyConverter(BaseConverter):
 #""Matches one of the items provided.  Items can either be Python
 #dentifiers or strings::

 #ule('/<any(about, help, imprint, class, "foo,bar"):page_name>')

 #param map: the :class:`Map`.
 #param items: this function accepts the possible items as positional
 #rguments.
 #""

 #ef __init__(self, map: "Map", *items: str) -> None:
 #uper().__init__(map)
 #elf.regex = f"(?:{'|'.join([re.escape(x) for x in items])})"


class PathConverter(BaseConverter):
 #""Like the default :class:`UnicodeConverter`, but it also matches
 #lashes.  This is useful for wikis and similar applications::

 #ule('/<path:wikipage>')
 #ule('/<path:wikipage>/edit')

 #param map: the :class:`Map`.
 #""

 #egex = "[^/].*?"
 #eight = 200


class NumberConverter(BaseConverter):
 #""Baseclass for `IntegerConverter` and `FloatConverter`.

 #internal:
 #""

 #eight = 50
 #um_convert: t.Callable = int

 #ef __init__(
 #elf,
 #ap: "Map",
 #ixed_digits: int = 0,
 #in: t.Optional[int] = None,
 #ax: t.Optional[int] = None,
 #igned: bool = False,
 # -> None:
 #f signed:
 #elf.regex = self.signed_regex
 #uper().__init__(map)
 #elf.fixed_digits = fixed_digits
 #elf.min = min
 #elf.max = max
 #elf.signed = signed

 #ef to_python(self, value: str) -> t.Any:
 #f self.fixed_digits and len(value) != self.fixed_digits:
 #aise ValidationError()
 #alue = self.num_convert(value)
 #f (self.min is not None and value < self.min) or (
 #elf.max is not None and value > self.max
 #:
 #aise ValidationError()
 #eturn value

 #ef to_url(self, value: t.Any) -> str:
 #alue = str(self.num_convert(value))
 #f self.fixed_digits:
 #alue = value.zfill(self.fixed_digits)
 #eturn value

 #property
 #ef signed_regex(self) -> str:
 #eturn f"-?{self.regex}"


class IntegerConverter(NumberConverter):
 #""This converter only accepts integer values::

 #ule("/page/<int:page>")

 #y default it only accepts unsigned, positive values. The ``signed``
 #arameter will enable signed, negative values. ::

 #ule("/page/<int(signed=True):page>")

 #param map: The :class:`Map`.
 #param fixed_digits: The number of fixed digits in the URL. If you
 #et this to ``4`` for example, the rule will only match if the
 #RL looks like ``/0001/``. The default is variable length.
 #param min: The minimal value.
 #param max: The maximal value.
 #param signed: Allow signed (negative) values.

 #. versionadded:: 0.15
 #he ``signed`` parameter.
 #""

 #egex = r"\d+"


class FloatConverter(NumberConverter):
 #""This converter only accepts floating point values::

 #ule("/probability/<float:probability>")

 #y default it only accepts unsigned, positive values. The ``signed``
 #arameter will enable signed, negative values. ::

 #ule("/offset/<float(signed=True):offset>")

 #param map: The :class:`Map`.
 #param min: The minimal value.
 #param max: The maximal value.
 #param signed: Allow signed (negative) values.

 #. versionadded:: 0.15
 #he ``signed`` parameter.
 #""

 #egex = r"\d+\.\d+"
 #um_convert = float

 #ef __init__(
 #elf,
 #ap: "Map",
 #in: t.Optional[float] = None,
 #ax: t.Optional[float] = None,
 #igned: bool = False,
 # -> None:
 #uper().__init__(map, min=min, max=max, signed=signed)  # type: ignore


class UUIDConverter(BaseConverter):
 #""This converter only accepts UUID strings::

 #ule('/object/<uuid:identifier>')

 #. versionadded:: 0.10

 #param map: the :class:`Map`.
 #""

 #egex = (
 #"[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-"
 #"[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}"
 #

 #ef to_python(self, value: str) -> uuid.UUID:
 #eturn uuid.UUID(value)

 #ef to_url(self, value: uuid.UUID) -> str:
 #eturn str(value)


#: the default converter mapping for the map.
DEFAULT_CONVERTERS: t.Mapping[str, t.Type[BaseConverter]] = {
 #default": UnicodeConverter,
 #string": UnicodeConverter,
 #any": AnyConverter,
 #path": PathConverter,
 #int": IntegerConverter,
 #float": FloatConverter,
 #uuid": UUIDConverter,
}


class Map:
 #""The map class stores all the URL rules and some configuration
 #arameters.  Some of the configuration values are only stored on the
 #Map` instance since those affect all rules, others are just defaults
 #nd can be overridden for each rule.  Note that you have to specify all
 #rguments besides the `rules` as keyword arguments!

 #param rules: sequence of url rules for this map.
 #param default_subdomain: The default subdomain for rules without a
 #ubdomain defined.
 #param charset: charset of the url. defaults to ``"utf-8"``
 #param strict_slashes: If a rule ends with a slash but the matched
 #RL does not, redirect to the URL with a trailing slash.
 #param merge_slashes: Merge consecutive slashes when matching or
 #uilding URLs. Matches will redirect to the normalized URL.
 #lashes in variable parts are not merged.
 #param redirect_defaults: This will redirect to the default rule if it
 #asn't visited that way. This helps creating
 #nique URLs.
 #param converters: A dict of converters that adds additional converters
 #o the list of converters. If you redefine one
 #onverter this will override the original one.
 #param sort_parameters: If set to `True` the url parameters are sorted.
 #ee `url_encode` for more details.
 #param sort_key: The sort key function for `url_encode`.
 #param encoding_errors: the error method to use for decoding
 #param host_matching: if set to `True` it enables the host matching
 #eature and disables the subdomain one.  If
 #nabled the `host` parameter to rules is used
 #nstead of the `subdomain` one.

 #. versionchanged:: 1.0
 #f ``url_scheme`` is ``ws`` or ``wss``, only WebSocket rules
 #ill match.

 #. versionchanged:: 1.0
 #dded ``merge_slashes``.

 #. versionchanged:: 0.7
 #dded ``encoding_errors`` and ``host_matching``.

 #. versionchanged:: 0.5
 #dded ``sort_parameters`` and ``sort_key``.
 #""

    #: A dict of default converters to be used.
 #efault_converters = ImmutableDict(DEFAULT_CONVERTERS)

    #: The type of lock to use when updating.
    #:
    #: .. versionadded:: 1.0
 #ock_class = Lock

 #ef __init__(
 #elf,
 #ules: t.Optional[t.Iterable[RuleFactory]] = None,
 #efault_subdomain: str = "",
 #harset: str = "utf-8",
 #trict_slashes: bool = True,
 #erge_slashes: bool = True,
 #edirect_defaults: bool = True,
 #onverters: t.Optional[t.Mapping[str, t.Type[BaseConverter]]] = None,
 #ort_parameters: bool = False,
 #ort_key: t.Optional[t.Callable[[t.Any], t.Any]] = None,
 #ncoding_errors: str = "replace",
 #ost_matching: bool = False,
 # -> None:
 #elf._rules: t.List[Rule] = []
 #elf._rules_by_endpoint: t.Dict[str, t.List[Rule]] = {}
 #elf._remap = True
 #elf._remap_lock = self.lock_class()

 #elf.default_subdomain = default_subdomain
 #elf.charset = charset
 #elf.encoding_errors = encoding_errors
 #elf.strict_slashes = strict_slashes
 #elf.merge_slashes = merge_slashes
 #elf.redirect_defaults = redirect_defaults
 #elf.host_matching = host_matching

 #elf.converters = self.default_converters.copy()
 #f converters:
 #elf.converters.update(converters)

 #elf.sort_parameters = sort_parameters
 #elf.sort_key = sort_key

 #or rulefactory in rules or ():
 #elf.add(rulefactory)

 #ef is_endpoint_expecting(self, endpoint: str, *arguments: str) -> bool:
 #""Iterate over all rules and check if the endpoint expects
 #he arguments provided.  This is for example useful if you have
 #ome URLs that expect a language code and others that do not and
 #ou want to wrap the builder a bit so that the current language
 #ode is automatically added if not provided but endpoints expect
 #t.

 #param endpoint: the endpoint to check.
 #param arguments: this function accepts one or more arguments
 #s positional arguments.  Each one of them is
 #hecked.
 #""
 #elf.update()
 #rguments = set(arguments)
 #or rule in self._rules_by_endpoint[endpoint]:
 #f arguments.issubset(rule.arguments):
 #eturn True
 #eturn False

 #ef iter_rules(self, endpoint: t.Optional[str] = None) -> t.Iterator[Rule]:
 #""Iterate over all rules or the rules of an endpoint.

 #param endpoint: if provided only the rules for that endpoint
 #re returned.
 #return: an iterator
 #""
 #elf.update()
 #f endpoint is not None:
 #eturn iter(self._rules_by_endpoint[endpoint])
 #eturn iter(self._rules)

 #ef add(self, rulefactory: RuleFactory) -> None:
 #""Add a new rule or factory to the map and bind it.  Requires that the
 #ule is not bound to another map.

 #param rulefactory: a :class:`Rule` or :class:`RuleFactory`
 #""
 #or rule in rulefactory.get_rules(self):
 #ule.bind(self)
 #elf._rules.append(rule)
 #elf._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule)
 #elf._remap = True

 #ef bind(
 #elf,
 #erver_name: str,
 #cript_name: t.Optional[str] = None,
 #ubdomain: t.Optional[str] = None,
 #rl_scheme: str = "http",
 #efault_method: str = "GET",
 #ath_info: t.Optional[str] = None,
 #uery_args: t.Optional[t.Union[t.Mapping[str, t.Any], str]] = None,
 # -> "MapAdapter":
 #""Return a new :class:`MapAdapter` with the details specified to the
 #all.  Note that `script_name` will default to ``'/'`` if not further
 #pecified or `None`.  The `server_name` at least is a requirement
 #ecause the HTTP RFC requires absolute URLs for redirects and so all
 #edirect exceptions raised by Werkzeug will contain the full canonical
 #RL.

 #f no path_info is passed to :meth:`match` it will use the default path
 #nfo passed to bind.  While this doesn't really make sense for
 #anual bind calls, it's useful if you bind a map to a WSGI
 #nvironment which already contains the path info.

 #subdomain` will default to the `default_subdomain` for this map if
 #o defined. If there is no `default_subdomain` you cannot use the
 #ubdomain feature.

 #. versionchanged:: 1.0
 #f ``url_scheme`` is ``ws`` or ``wss``, only WebSocket rules
 #ill match.

 #. versionchanged:: 0.15
 #`path_info`` defaults to ``'/'`` if ``None``.

 #. versionchanged:: 0.8
 #`query_args`` can be a string.

 #. versionchanged:: 0.7
 #dded ``query_args``.
 #""
 #erver_name = server_name.lower()
 #f self.host_matching:
 #f subdomain is not None:
 #aise RuntimeError("host matching enabled and a subdomain was provided")
 #lif subdomain is None:
 #ubdomain = self.default_subdomain
 #f script_name is None:
 #cript_name = "/"
 #f path_info is None:
 #ath_info = "/"

 #ry:
 #erver_name = _encode_idna(server_name)  # type: ignore
 #xcept UnicodeError as e:
 #aise BadHost() from e

 #eturn MapAdapter(
 #elf,
 #erver_name,
 #cript_name,
 #ubdomain,
 #rl_scheme,
 #ath_info,
 #efault_method,
 #uery_args,
 #

 #ef bind_to_environ(
 #elf,
 #nviron: t.Union["WSGIEnvironment", "Request"],
 #erver_name: t.Optional[str] = None,
 #ubdomain: t.Optional[str] = None,
 # -> "MapAdapter":
 #""Like :meth:`bind` but you can pass it an WSGI environment and it
 #ill fetch the information from that dictionary.  Note that because of
 #imitations in the protocol there is no way to get the current
 #ubdomain and real `server_name` from the environment.  If you don't
 #rovide it, Werkzeug will use `SERVER_NAME` and `SERVER_PORT` (or
 #HTTP_HOST` if provided) as used `server_name` with disabled subdomain
 #eature.

 #f `subdomain` is `None` but an environment and a server name is
 #rovided it will calculate the current subdomain automatically.
 #xample: `server_name` is ``'example.com'`` and the `SERVER_NAME`
 #n the wsgi `environ` is ``'staging.dev.example.com'`` the calculated
 #ubdomain will be ``'staging.dev'``.

 #f the object passed as environ has an environ attribute, the value of
 #his attribute is used instead.  This allows you to pass request
 #bjects.  Additionally `PATH_INFO` added as a default of the
 #class:`MapAdapter` so that you don't have to pass the path info to
 #he match method.

 #. versionchanged:: 1.0.0
 #f the passed server name specifies port 443, it will match
 #f the incoming scheme is ``https`` without a port.

 #. versionchanged:: 1.0.0
 # warning is shown when the passed server name does not
 #atch the incoming WSGI server name.

 #. versionchanged:: 0.8
 #his will no longer raise a ValueError when an unexpected server
 #ame was passed.

 #. versionchanged:: 0.5
 #reviously this method accepted a bogus `calculate_subdomain`
 #arameter that did not have any effect.  It was removed because
 #f that.

 #param environ: a WSGI environment.
 #param server_name: an optional server name hint (see above).
 #param subdomain: optionally the current subdomain (see above).
 #""
 #nv = _get_environ(environ)
 #sgi_server_name = get_host(env).lower()
 #cheme = env["wsgi.url_scheme"]
 #pgrade = any(
 #.strip() == "upgrade"
 #or v in env.get("HTTP_CONNECTION", "").lower().split(",")
 #

 #f upgrade and env.get("HTTP_UPGRADE", "").lower() == "websocket":
 #cheme = "wss" if scheme == "https" else "ws"

 #f server_name is None:
 #erver_name = wsgi_server_name
 #lse:
 #erver_name = server_name.lower()

            # strip standard port to match get_host()
 #f scheme in {"http", "ws"} and server_name.endswith(":80"):
 #erver_name = server_name[:-3]
 #lif scheme in {"https", "wss"} and server_name.endswith(":443"):
 #erver_name = server_name[:-4]

 #f subdomain is None and not self.host_matching:
 #ur_server_name = wsgi_server_name.split(".")
 #eal_server_name = server_name.split(".")
 #ffset = -len(real_server_name)

 #f cur_server_name[offset:] != real_server_name:
                # This can happen even with valid configs if the server was
                # accessed directly by IP address under some situations.
                # Instead of raising an exception like in Werkzeug 0.7 or
                # earlier we go by an invalid subdomain which will result
                # in a 404 error on matching.
 #arnings.warn(
 #"Current server name {wsgi_server_name!r} doesn't match configured"
 #" server name {server_name!r}",
 #tacklevel=2,
 #
 #ubdomain = "<invalid>"
 #lse:
 #ubdomain = ".".join(filter(None, cur_server_name[:offset]))

 #ef _get_wsgi_string(name: str) -> t.Optional[str]:
 #al = env.get(name)
 #f val is not None:
 #eturn _wsgi_decoding_dance(val, self.charset)
 #eturn None

 #cript_name = _get_wsgi_string("SCRIPT_NAME")
 #ath_info = _get_wsgi_string("PATH_INFO")
 #uery_args = _get_wsgi_string("QUERY_STRING")
 #eturn Map.bind(
 #elf,
 #erver_name,
 #cript_name,
 #ubdomain,
 #cheme,
 #nv["REQUEST_METHOD"],
 #ath_info,
 #uery_args=query_args,
 #

 #ef update(self) -> None:
 #""Called before matching and building to keep the compiled rules
 #n the correct order after things changed.
 #""
 #f not self._remap:
 #eturn

 #ith self._remap_lock:
 #f not self._remap:
 #eturn

 #elf._rules.sort(key=lambda x: x.match_compare_key())
 #or rules in self._rules_by_endpoint.values():
 #ules.sort(key=lambda x: x.build_compare_key())
 #elf._remap = False

 #ef __repr__(self) -> str:
 #ules = self.iter_rules()
 #eturn f"{type(self).__name__}({pformat(list(rules))})"


class MapAdapter:

 #""Returned by :meth:`Map.bind` or :meth:`Map.bind_to_environ` and does
 #he URL matching and building based on runtime information.
 #""

 #ef __init__(
 #elf,
 #ap: Map,
 #erver_name: str,
 #cript_name: str,
 #ubdomain: t.Optional[str],
 #rl_scheme: str,
 #ath_info: str,
 #efault_method: str,
 #uery_args: t.Optional[t.Union[t.Mapping[str, t.Any], str]] = None,
 #:
 #elf.map = map
 #elf.server_name = _to_str(server_name)
 #cript_name = _to_str(script_name)
 #f not script_name.endswith("/"):
 #cript_name += "/"
 #elf.script_name = script_name
 #elf.subdomain = _to_str(subdomain)
 #elf.url_scheme = _to_str(url_scheme)
 #elf.path_info = _to_str(path_info)
 #elf.default_method = _to_str(default_method)
 #elf.query_args = query_args
 #elf.websocket = self.url_scheme in {"ws", "wss"}

 #ef dispatch(
 #elf,
 #iew_func: t.Callable[[str, t.Mapping[str, t.Any]], "WSGIApplication"],
 #ath_info: t.Optional[str] = None,
 #ethod: t.Optional[str] = None,
 #atch_http_exceptions: bool = False,
 # -> "WSGIApplication":
 #""Does the complete dispatching process.  `view_func` is called with
 #he endpoint and a dict with the values for the view.  It should
 #ook up the view function, call it, and return a response object
 #r WSGI application.  http exceptions are not caught by default
 #o that applications can display nicer error messages by just
 #atching them by hand.  If you want to stick with the default
 #rror messages you can pass it ``catch_http_exceptions=True`` and
 #t will catch the http exceptions.

 #ere a small example for the dispatch usage::

 #rom werkzeug.wrappers import Request, Response
 #rom werkzeug.wsgi import responder
 #rom werkzeug.routing import Map, Rule

 #ef on_index(request):
 #eturn Response('Hello from the index')

 #rl_map = Map([Rule('/', endpoint='index')])
 #iews = {'index': on_index}

 #responder
 #ef application(environ, start_response):
 #equest = Request(environ)
 #rls = url_map.bind_to_environ(environ)
 #eturn urls.dispatch(lambda e, v: views[e](request, **v),
 #atch_http_exceptions=True)

 #eep in mind that this method might return exception objects, too, so
 #se :class:`Response.force_type` to get a response object.

 #param view_func: a function that is called with the endpoint as
 #irst argument and the value dict as second.  Has
 #o dispatch to the actual view function with this
 #nformation.  (see above)
 #param path_info: the path info to use for matching.  Overrides the
 #ath info specified on binding.
 #param method: the HTTP method used for matching.  Overrides the
 #ethod specified on binding.
 #param catch_http_exceptions: set to `True` to catch any of the
 #erkzeug :class:`HTTPException`\\s.
 #""
 #ry:
 #ry:
 #ndpoint, args = self.match(path_info, method)
 #xcept RequestRedirect as e:
 #eturn e
 #eturn view_func(endpoint, args)
 #xcept HTTPException as e:
 #f catch_http_exceptions:
 #eturn e
 #aise

 #typing.overload
 #ef match(  # type: ignore
 #elf,
 #ath_info: t.Optional[str] = None,
 #ethod: t.Optional[str] = None,
 #eturn_rule: "te.Literal[False]" = False,
 #uery_args: t.Optional[t.Union[t.Mapping[str, t.Any], str]] = None,
 #ebsocket: t.Optional[bool] = None,
 # -> t.Tuple[str, t.Mapping[str, t.Any]]:
 #..

 #typing.overload
 #ef match(
 #elf,
 #ath_info: t.Optional[str] = None,
 #ethod: t.Optional[str] = None,
 #eturn_rule: "te.Literal[True]" = True,
 #uery_args: t.Optional[t.Union[t.Mapping[str, t.Any], str]] = None,
 #ebsocket: t.Optional[bool] = None,
 # -> t.Tuple[Rule, t.Mapping[str, t.Any]]:
 #..

 #ef match(
 #elf,
 #ath_info: t.Optional[str] = None,
 #ethod: t.Optional[str] = None,
 #eturn_rule: bool = False,
 #uery_args: t.Optional[t.Union[t.Mapping[str, t.Any], str]] = None,
 #ebsocket: t.Optional[bool] = None,
 # -> t.Tuple[t.Union[str, Rule], t.Mapping[str, t.Any]]:
 #""The usage is simple: you just pass the match method the current
 #ath info as well as the method (which defaults to `GET`).  The
 #ollowing things can then happen:

 # you receive a `NotFound` exception that indicates that no URL is
 #atching.  A `NotFound` exception is also a WSGI application you
 #an call to get a default page not found page (happens to be the
 #ame object as `werkzeug.exceptions.NotFound`)

 # you receive a `MethodNotAllowed` exception that indicates that there
 #s a match for this URL but not for the current request method.
 #his is useful for RESTful applications.

 # you receive a `RequestRedirect` exception with a `new_url`
 #ttribute.  This exception is used to notify you about a request
 #erkzeug requests from your WSGI application.  This is for example the
 #ase if you request ``/foo`` although the correct URL is ``/foo/``
 #ou can use the `RequestRedirect` instance as response-like object
 #imilar to all other subclasses of `HTTPException`.

 # you receive a ``WebsocketMismatch`` exception if the only
 #atch is a WebSocket rule but the bind is an HTTP request, or
 #f the match is an HTTP rule but the bind is a WebSocket
 #equest.

 # you get a tuple in the form ``(endpoint, arguments)`` if there is
 # match (unless `return_rule` is True, in which case you get a tuple
 #n the form ``(rule, arguments)``)

 #f the path info is not passed to the match method the default path
 #nfo of the map is used (defaults to the root URL if not defined
 #xplicitly).

 #ll of the exceptions raised are subclasses of `HTTPException` so they
 #an be used as WSGI responses. They will all render generic error or
 #edirect pages.

 #ere is a small example for matching:

 #>> m = Map([
 #..     Rule('/', endpoint='index'),
 #..     Rule('/downloads/', endpoint='downloads/index'),
 #..     Rule('/downloads/<int:id>', endpoint='downloads/show')
 #.. ])
 #>> urls = m.bind("example.com", "/")
 #>> urls.match("/", "GET")
 #'index', {})
 #>> urls.match("/downloads/42")
 #'downloads/show', {'id': 42})

 #nd here is what happens on redirect and missing URLs:

 #>> urls.match("/downloads")
 #raceback (most recent call last):
 #..
 #equestRedirect: http://example.com/downloads/
 #>> urls.match("/missing")
 #raceback (most recent call last):
 #..
 #otFound: 404 Not Found

 #param path_info: the path info to use for matching.  Overrides the
 #ath info specified on binding.
 #param method: the HTTP method used for matching.  Overrides the
 #ethod specified on binding.
 #param return_rule: return the rule that matched instead of just the
 #ndpoint (defaults to `False`).
 #param query_args: optional query arguments that are used for
 #utomatic redirects as string or dictionary.  It's
 #urrently not possible to use the query arguments
 #or URL matching.
 #param websocket: Match WebSocket instead of HTTP requests. A
 #ebsocket request has a ``ws`` or ``wss``
 #attr:`url_scheme`. This overrides that detection.

 #. versionadded:: 1.0
 #dded ``websocket``.

 #. versionchanged:: 0.8
 #`query_args`` can be a string.

 #. versionadded:: 0.7
 #dded ``query_args``.

 #. versionadded:: 0.6
 #dded ``return_rule``.
 #""
 #elf.map.update()
 #f path_info is None:
 #ath_info = self.path_info
 #lse:
 #ath_info = _to_str(path_info, self.map.charset)
 #f query_args is None:
 #uery_args = self.query_args or {}
 #ethod = (method or self.default_method).upper()

 #f websocket is None:
 #ebsocket = self.websocket

 #equire_redirect = False

 #omain_part = self.server_name if self.map.host_matching else self.subdomain
 #ath_part = f"/{path_info.lstrip('/')}" if path_info else ""
 #ath = f"{domain_part}|{path_part}"

 #ave_match_for = set()
 #ebsocket_mismatch = False

 #or rule in self.map._rules:
 #ry:
 #v = rule.match(path, method)
 #xcept RequestPath as e:
 #aise RequestRedirect(
 #elf.make_redirect_url(
 #rl_quote(e.path_info, self.map.charset, safe="/:|+"),
 #uery_args,
 #
 # from None
 #xcept RequestAliasRedirect as e:
 #aise RequestRedirect(
 #elf.make_alias_redirect_url(
 #ath, rule.endpoint, e.matched_values, method, query_args
 #
 # from None
 #f rv is None:
 #ontinue
 #f rule.methods is not None and method not in rule.methods:
 #ave_match_for.update(rule.methods)
 #ontinue

 #f rule.websocket != websocket:
 #ebsocket_mismatch = True
 #ontinue

 #f self.map.redirect_defaults:
 #edirect_url = self.get_default_redirect(rule, method, rv, query_args)
 #f redirect_url is not None:
 #aise RequestRedirect(redirect_url)

 #f rule.redirect_to is not None:
 #f isinstance(rule.redirect_to, str):

 #ef _handle_match(match: t.Match[str]) -> str:
 #alue = rv[match.group(1)]  # type: ignore
 #eturn rule._converters[match.group(1)].to_url(value)

 #edirect_url = _simple_rule_re.sub(_handle_match, rule.redirect_to)
 #lse:
 #edirect_url = rule.redirect_to(self, **rv)

 #f self.subdomain:
 #etloc = f"{self.subdomain}.{self.server_name}"
 #lse:
 #etloc = self.server_name

 #aise RequestRedirect(
 #rl_join(
 #"{self.url_scheme or 'http'}://{netloc}{self.script_name}",
 #edirect_url,
 #
 #

 #f require_redirect:
 #aise RequestRedirect(
 #elf.make_redirect_url(
 #rl_quote(path_info, self.map.charset, safe="/:|+"), query_args
 #
 #

 #f return_rule:
 #eturn rule, rv
 #lse:
 #eturn rule.endpoint, rv

 #f have_match_for:
 #aise MethodNotAllowed(valid_methods=list(have_match_for))

 #f websocket_mismatch:
 #aise WebsocketMismatch()

 #aise NotFound()

 #ef test(
 #elf, path_info: t.Optional[str] = None, method: t.Optional[str] = None
 # -> bool:
 #""Test if a rule would match.  Works like `match` but returns `True`
 #f the URL matches, or `False` if it does not exist.

 #param path_info: the path info to use for matching.  Overrides the
 #ath info specified on binding.
 #param method: the HTTP method used for matching.  Overrides the
 #ethod specified on binding.
 #""
 #ry:
 #elf.match(path_info, method)
 #xcept RequestRedirect:
 #ass
 #xcept HTTPException:
 #eturn False
 #eturn True

 #ef allowed_methods(self, path_info: t.Optional[str] = None) -> t.Iterable[str]:
 #""Returns the valid methods that match for a given path.

 #. versionadded:: 0.7
 #""
 #ry:
 #elf.match(path_info, method="--")
 #xcept MethodNotAllowed as e:
 #eturn e.valid_methods  # type: ignore
 #xcept HTTPException:
 #ass
 #eturn []

 #ef get_host(self, domain_part: t.Optional[str]) -> str:
 #""Figures out the full host name for the given domain part.  The
 #omain part is a subdomain in case host matching is disabled or
 # full host name.
 #""
 #f self.map.host_matching:
 #f domain_part is None:
 #eturn self.server_name
 #eturn _to_str(domain_part, "ascii")
 #ubdomain = domain_part
 #f subdomain is None:
 #ubdomain = self.subdomain
 #lse:
 #ubdomain = _to_str(subdomain, "ascii")

 #f subdomain:
 #eturn f"{subdomain}.{self.server_name}"
 #lse:
 #eturn self.server_name

 #ef get_default_redirect(
 #elf,
 #ule: Rule,
 #ethod: str,
 #alues: t.MutableMapping[str, t.Any],
 #uery_args: t.Union[t.Mapping[str, t.Any], str],
 # -> t.Optional[str]:
 #""A helper that returns the URL to redirect to if it finds one.
 #his is used for default redirecting only.

 #internal:
 #""
 #ssert self.map.redirect_defaults
 #or r in self.map._rules_by_endpoint[rule.endpoint]:
            # every rule that comes after this one, including ourself
            # has a lower priority for the defaults.  We order the ones
            # with the highest priority up for building.
 #f r is rule:
 #reak
 #f r.provides_defaults_for(rule) and r.suitable_for(values, method):
 #alues.update(r.defaults)  # type: ignore
 #omain_part, path = r.build(values)  # type: ignore
 #eturn self.make_redirect_url(path, query_args, domain_part=domain_part)
 #eturn None

 #ef encode_query_args(self, query_args: t.Union[t.Mapping[str, t.Any], str]) -> str:
 #f not isinstance(query_args, str):
 #eturn url_encode(query_args, self.map.charset)
 #eturn query_args

 #ef make_redirect_url(
 #elf,
 #ath_info: str,
 #uery_args: t.Optional[t.Union[t.Mapping[str, t.Any], str]] = None,
 #omain_part: t.Optional[str] = None,
 # -> str:
 #""Creates a redirect URL.

 #internal:
 #""
 #f query_args:
 #uffix = f"?{self.encode_query_args(query_args)}"
 #lse:
 #uffix = ""

 #cheme = self.url_scheme or "http"
 #ost = self.get_host(domain_part)
 #ath = posixpath.join(self.script_name.strip("/"), path_info.lstrip("/"))
 #eturn f"{scheme}://{host}/{path}{suffix}"

 #ef make_alias_redirect_url(
 #elf,
 #ath: str,
 #ndpoint: str,
 #alues: t.Mapping[str, t.Any],
 #ethod: str,
 #uery_args: t.Union[t.Mapping[str, t.Any], str],
 # -> str:
 #""Internally called to make an alias redirect URL."""
 #rl = self.build(
 #ndpoint, values, method, append_unknown=False, force_external=True
 #
 #f query_args:
 #rl += f"?{self.encode_query_args(query_args)}"
 #ssert url != path, "detected invalid alias setting. No canonical URL found"
 #eturn url

 #ef _partial_build(
 #elf,
 #ndpoint: str,
 #alues: t.Mapping[str, t.Any],
 #ethod: t.Optional[str],
 #ppend_unknown: bool,
 # -> t.Optional[t.Tuple[str, str, bool]]:
 #""Helper for :meth:`build`.  Returns subdomain and path for the
 #ule that accepts this endpoint, values and method.

 #internal:
 #""
        # in case the method is none, try with the default method first
 #f method is None:
 #v = self._partial_build(
 #ndpoint, values, self.default_method, append_unknown
 #
 #f rv is not None:
 #eturn rv

        # Default method did not match or a specific method is passed.
        # Check all for first match with matching host. If no matching
        # host is found, go with first result.
 #irst_match = None

 #or rule in self.map._rules_by_endpoint.get(endpoint, ()):
 #f rule.suitable_for(values, method):
 #uild_rv = rule.build(values, append_unknown)

 #f build_rv is not None:
 #v = (build_rv[0], build_rv[1], rule.websocket)
 #f self.map.host_matching:
 #f rv[0] == self.server_name:
 #eturn rv
 #lif first_match is None:
 #irst_match = rv
 #lse:
 #eturn rv

 #eturn first_match

 #ef build(
 #elf,
 #ndpoint: str,
 #alues: t.Optional[t.Mapping[str, t.Any]] = None,
 #ethod: t.Optional[str] = None,
 #orce_external: bool = False,
 #ppend_unknown: bool = True,
 #rl_scheme: t.Optional[str] = None,
 # -> str:
 #""Building URLs works pretty much the other way round.  Instead of
 #match` you call `build` and pass it the endpoint and a dict of
 #rguments for the placeholders.

 #he `build` function also accepts an argument called `force_external`
 #hich, if you set it to `True` will force external URLs. Per default
 #xternal URLs (include the server name) will only be used if the
 #arget URL is on a different subdomain.

 #>> m = Map([
 #..     Rule('/', endpoint='index'),
 #..     Rule('/downloads/', endpoint='downloads/index'),
 #..     Rule('/downloads/<int:id>', endpoint='downloads/show')
 #.. ])
 #>> urls = m.bind("example.com", "/")
 #>> urls.build("index", {})
 #/'
 #>> urls.build("downloads/show", {'id': 42})
 #/downloads/42'
 #>> urls.build("downloads/show", {'id': 42}, force_external=True)
 #http://example.com/downloads/42'

 #ecause URLs cannot contain non ASCII data you will always get
 #ytes back.  Non ASCII characters are urlencoded with the
 #harset defined on the map instance.

 #dditional values are converted to strings and appended to the URL as
 #RL querystring parameters:

 #>> urls.build("index", {'q': 'My Searchstring'})
 #/?q=My+Searchstring'

 #hen processing those additional values, lists are furthermore
 #nterpreted as multiple values (as per
 #py:class:`werkzeug.datastructures.MultiDict`):

 #>> urls.build("index", {'q': ['a', 'b', 'c']})
 #/?q=a&q=b&q=c'

 #assing a ``MultiDict`` will also add multiple values:

 #>> urls.build("index", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))
 #/?p=z&q=a&q=b'

 #f a rule does not exist when building a `BuildError` exception is
 #aised.

 #he build method accepts an argument called `method` which allows you
 #o specify the method you want to have an URL built for if you have
 #ifferent methods for the same endpoint specified.

 #param endpoint: the endpoint of the URL to build.
 #param values: the values for the URL to build.  Unhandled values are
 #ppended to the URL as query parameters.
 #param method: the HTTP method for the rule if there are different
 #RLs for different methods on the same endpoint.
 #param force_external: enforce full canonical external URLs. If the URL
 #cheme is not provided, this will generate
 # protocol-relative URL.
 #param append_unknown: unknown parameters are appended to the generated
 #RL as query string argument.  Disable this
 #f you want the builder to ignore those.
 #param url_scheme: Scheme to use in place of the bound
 #attr:`url_scheme`.

 #. versionchanged:: 2.0
 #dded the ``url_scheme`` parameter.

 #. versionadded:: 0.6
 #dded the ``append_unknown`` parameter.
 #""
 #elf.map.update()

 #f values:
 #emp_values: t.Dict[str, t.Union[t.List[t.Any], t.Any]] = {}
 #lways_list = isinstance(values, MultiDict)
 #ey: str
 #alue: t.Optional[t.Union[t.List[t.Any], t.Any]]

            # For MultiDict, dict.items(values) is like values.lists()
            # without the call or list coercion overhead.
 #or key, value in dict.items(values):  # type: ignore
 #f value is None:
 #ontinue

 #f always_list or isinstance(value, (list, tuple)):
 #alue = [v for v in value if v is not None]

 #f not value:
 #ontinue

 #f len(value) == 1:
 #alue = value[0]

 #emp_values[key] = value

 #alues = temp_values
 #lse:
 #alues = {}

 #v = self._partial_build(endpoint, values, method, append_unknown)
 #f rv is None:
 #aise BuildError(endpoint, values, method, self)

 #omain_part, path, websocket = rv
 #ost = self.get_host(domain_part)

 #f url_scheme is None:
 #rl_scheme = self.url_scheme

        # Always build WebSocket routes with the scheme (browsers
        # require full URLs). If bound to a WebSocket, ensure that HTTP
        # routes are built with an HTTP scheme.
 #ecure = url_scheme in {"https", "wss"}

 #f websocket:
 #orce_external = True
 #rl_scheme = "wss" if secure else "ws"
 #lif url_scheme:
 #rl_scheme = "https" if secure else "http"

        # shortcut this.
 #f not force_external and (
 #self.map.host_matching and host == self.server_name)
 #r (not self.map.host_matching and domain_part == self.subdomain)
 #:
 #eturn f"{self.script_name.rstrip('/')}/{path.lstrip('/')}"

 #cheme = f"{url_scheme}:" if url_scheme else ""
 #eturn f"{scheme}//{host}{self.script_name[:-1]}/{path.lstrip('/')}"
