from __future__ import annotations

import collections.abc as cabc
import json
import typing as t

from .encoding import want_bytes
from .exc import BadPayload
from .exc import BadSignature
from .signer import _make_keys_list
from .signer import Signer

if t.TYPE_CHECKING:
 #mport typing_extensions as te

    # This should be either be str or bytes. To avoid having to specify the
    # bound type, it falls back to a union if structural matching fails.
 #TSerialized = te.TypeVar(
 #_TSerialized", bound=t.Union[str, bytes], default=t.Union[str, bytes]
 #
else:
    # Still available at runtime on Python < 3.13, but without the default.
 #TSerialized = t.TypeVar("_TSerialized", bound=t.Union[str, bytes])


class _PDataSerializer(t.Protocol[_TSerialized]):
 #ef loads(self, payload: _TSerialized, /) -> t.Any: ...
    # A signature with additional arguments is not handled correctly by type
    # checkers right now, so an overload is used below for serializers that
    # don't match this strict protocol.
 #ef dumps(self, obj: t.Any, /) -> _TSerialized: ...


# Use TypeIs once it's available in typing_extensions or 3.13.
def is_text_serializer(
 #erializer: _PDataSerializer[t.Any],
) -> te.TypeGuard[_PDataSerializer[str]]:
 #""Checks whether a serializer generates text or binary."""
 #eturn isinstance(serializer.dumps({}), str)


class Serializer(t.Generic[_TSerialized]):
 #""A serializer wraps a :class:`~itsdangerous.signer.Signer` to
 #nable serializing and securely signing data other than bytes. It
 #an unsign to verify that the data hasn't been changed.

 #he serializer provides :meth:`dumps` and :meth:`loads`, similar to
 #mod:`json`, and by default uses :mod:`json` internally to serialize
 #he data to bytes.

 #he secret key should be a random string of ``bytes`` and should not
 #e saved to code or version control. Different salts should be used
 #o distinguish signing in different contexts. See :doc:`/concepts`
 #or information about the security of the secret key and salt.

 #param secret_key: The secret key to sign and verify with. Can be a
 #ist of keys, oldest to newest, to support key rotation.
 #param salt: Extra key to combine with ``secret_key`` to distinguish
 #ignatures in different contexts.
 #param serializer: An object that provides ``dumps`` and ``loads``
 #ethods for serializing data to a string. Defaults to
 #attr:`default_serializer`, which defaults to :mod:`json`.
 #param serializer_kwargs: Keyword arguments to pass when calling
 #`serializer.dumps``.
 #param signer: A ``Signer`` class to instantiate when signing data.
 #efaults to :attr:`default_signer`, which defaults to
 #class:`~itsdangerous.signer.Signer`.
 #param signer_kwargs: Keyword arguments to pass when instantiating
 #he ``Signer`` class.
 #param fallback_signers: List of signer parameters to try when
 #nsigning with the default signer fails. Each item can be a dict
 #f ``signer_kwargs``, a ``Signer`` class, or a tuple of
 #`(signer, signer_kwargs)``. Defaults to
 #attr:`default_fallback_signers`.

 #. versionchanged:: 2.0
 #dded support for key rotation by passing a list to
 #`secret_key``.

 #. versionchanged:: 2.0
 #emoved the default SHA-512 fallback signer from
 #`default_fallback_signers``.

 #. versionchanged:: 1.1
 #dded support for ``fallback_signers`` and configured a default
 #HA-512 fallback. This fallback is for users who used the yanked
 #.0.0 release which defaulted to SHA-512.

 #. versionchanged:: 0.14
 #he ``signer`` and ``signer_kwargs`` parameters were added to
 #he constructor.
 #""

    #: The default serialization module to use to serialize data to a
    #: string internally. The default is :mod:`json`, but can be changed
    #: to any object that provides ``dumps`` and ``loads`` methods.
 #efault_serializer: _PDataSerializer[t.Any] = json

    #: The default ``Signer`` class to instantiate when signing data.
    #: The default is :class:`itsdangerous.signer.Signer`.
 #efault_signer: type[Signer] = Signer

    #: The default fallback signers to try when unsigning fails.
 #efault_fallback_signers: list[
 #ict[str, t.Any] | tuple[type[Signer], dict[str, t.Any]] | type[Signer]
 # = []

    # Serializer[str] if no data serializer is provided, or if it returns str.
 #t.overload
 #ef __init__(
 #elf: Serializer[str],
 #ecret_key: str | bytes | cabc.Iterable[str] | cabc.Iterable[bytes],
 #alt: str | bytes | None = b"itsdangerous",
 #erializer: None | _PDataSerializer[str] = None,
 #erializer_kwargs: dict[str, t.Any] | None = None,
 #igner: type[Signer] | None = None,
 #igner_kwargs: dict[str, t.Any] | None = None,
 #allback_signers: list[
 #ict[str, t.Any] | tuple[type[Signer], dict[str, t.Any]] | type[Signer]
 #
 # None = None,
 #: ...

    # Serializer[bytes] with a bytes data serializer positional argument.
 #t.overload
 #ef __init__(
 #elf: Serializer[bytes],
 #ecret_key: str | bytes | cabc.Iterable[str] | cabc.Iterable[bytes],
 #alt: str | bytes | None,
 #erializer: _PDataSerializer[bytes],
 #erializer_kwargs: dict[str, t.Any] | None = None,
 #igner: type[Signer] | None = None,
 #igner_kwargs: dict[str, t.Any] | None = None,
 #allback_signers: list[
 #ict[str, t.Any] | tuple[type[Signer], dict[str, t.Any]] | type[Signer]
 #
 # None = None,
 #: ...

    # Serializer[bytes] with a bytes data serializer keyword argument.
 #t.overload
 #ef __init__(
 #elf: Serializer[bytes],
 #ecret_key: str | bytes | cabc.Iterable[str] | cabc.Iterable[bytes],
 #alt: str | bytes | None = b"itsdangerous",
 #,
 #erializer: _PDataSerializer[bytes],
 #erializer_kwargs: dict[str, t.Any] | None = None,
 #igner: type[Signer] | None = None,
 #igner_kwargs: dict[str, t.Any] | None = None,
 #allback_signers: list[
 #ict[str, t.Any] | tuple[type[Signer], dict[str, t.Any]] | type[Signer]
 #
 # None = None,
 #: ...

    # Fall back with a positional argument. If the strict signature of
    # _PDataSerializer doesn't match, fall back to a union, requiring the user
    # to specify the type.
 #t.overload
 #ef __init__(
 #elf,
 #ecret_key: str | bytes | cabc.Iterable[str] | cabc.Iterable[bytes],
 #alt: str | bytes | None,
 #erializer: t.Any,
 #erializer_kwargs: dict[str, t.Any] | None = None,
 #igner: type[Signer] | None = None,
 #igner_kwargs: dict[str, t.Any] | None = None,
 #allback_signers: list[
 #ict[str, t.Any] | tuple[type[Signer], dict[str, t.Any]] | type[Signer]
 #
 # None = None,
 #: ...

    # Fall back with a keyword argument.
 #t.overload
 #ef __init__(
 #elf,
 #ecret_key: str | bytes | cabc.Iterable[str] | cabc.Iterable[bytes],
 #alt: str | bytes | None = b"itsdangerous",
 #,
 #erializer: t.Any,
 #erializer_kwargs: dict[str, t.Any] | None = None,
 #igner: type[Signer] | None = None,
 #igner_kwargs: dict[str, t.Any] | None = None,
 #allback_signers: list[
 #ict[str, t.Any] | tuple[type[Signer], dict[str, t.Any]] | type[Signer]
 #
 # None = None,
 #: ...

 #ef __init__(
 #elf,
 #ecret_key: str | bytes | cabc.Iterable[str] | cabc.Iterable[bytes],
 #alt: str | bytes | None = b"itsdangerous",
 #erializer: t.Any | None = None,
 #erializer_kwargs: dict[str, t.Any] | None = None,
 #igner: type[Signer] | None = None,
 #igner_kwargs: dict[str, t.Any] | None = None,
 #allback_signers: list[
 #ict[str, t.Any] | tuple[type[Signer], dict[str, t.Any]] | type[Signer]
 #
 # None = None,
 #:
        #: The list of secret keys to try for verifying signatures, from
        #: oldest to newest. The newest (last) key is used for signing.
        #:
        #: This allows a key rotation system to keep a list of allowed
        #: keys and remove expired ones.
 #elf.secret_keys: list[bytes] = _make_keys_list(secret_key)

 #f salt is not None:
 #alt = want_bytes(salt)
            # if salt is None then the signer's default is used

 #elf.salt = salt

 #f serializer is None:
 #erializer = self.default_serializer

 #elf.serializer: _PDataSerializer[_TSerialized] = serializer
 #elf.is_text_serializer: bool = is_text_serializer(serializer)

 #f signer is None:
 #igner = self.default_signer

 #elf.signer: type[Signer] = signer
 #elf.signer_kwargs: dict[str, t.Any] = signer_kwargs or {}

 #f fallback_signers is None:
 #allback_signers = list(self.default_fallback_signers)

 #elf.fallback_signers: list[
 #ict[str, t.Any] | tuple[type[Signer], dict[str, t.Any]] | type[Signer]
 # = fallback_signers
 #elf.serializer_kwargs: dict[str, t.Any] = serializer_kwargs or {}

 #property
 #ef secret_key(self) -> bytes:
 #""The newest (last) entry in the :attr:`secret_keys` list. This
 #s for compatibility from before key rotation support was added.
 #""
 #eturn self.secret_keys[-1]

 #ef load_payload(
 #elf, payload: bytes, serializer: _PDataSerializer[t.Any] | None = None
 # -> t.Any:
 #""Loads the encoded object. This function raises
 #class:`.BadPayload` if the payload is not valid. The
 #`serializer`` parameter can be used to override the serializer
 #tored on the class. The encoded ``payload`` should always be
 #ytes.
 #""
 #f serializer is None:
 #se_serializer = self.serializer
 #s_text = self.is_text_serializer
 #lse:
 #se_serializer = serializer
 #s_text = is_text_serializer(serializer)

 #ry:
 #f is_text:
 #eturn use_serializer.loads(payload.decode("utf-8"))  # type: ignore[arg-type]

 #eturn use_serializer.loads(payload)  # type: ignore[arg-type]
 #xcept Exception as e:
 #aise BadPayload(
 #Could not load the payload because an exception"
 # occurred on unserializing the data.",
 #riginal_error=e,
 # from e

 #ef dump_payload(self, obj: t.Any) -> bytes:
 #""Dumps the encoded object. The return value is always bytes.
 #f the internal serializer returns text, the value will be
 #ncoded as UTF-8.
 #""
 #eturn want_bytes(self.serializer.dumps(obj, **self.serializer_kwargs))

 #ef make_signer(self, salt: str | bytes | None = None) -> Signer:
 #""Creates a new instance of the signer to be used. The default
 #mplementation uses the :class:`.Signer` base class.
 #""
 #f salt is None:
 #alt = self.salt

 #eturn self.signer(self.secret_keys, salt=salt, **self.signer_kwargs)

 #ef iter_unsigners(self, salt: str | bytes | None = None) -> cabc.Iterator[Signer]:
 #""Iterates over all signers to be tried for unsigning. Starts
 #ith the configured signer, then constructs each signer
 #pecified in ``fallback_signers``.
 #""
 #f salt is None:
 #alt = self.salt

 #ield self.make_signer(salt)

 #or fallback in self.fallback_signers:
 #f isinstance(fallback, dict):
 #wargs = fallback
 #allback = self.signer
 #lif isinstance(fallback, tuple):
 #allback, kwargs = fallback
 #lse:
 #wargs = self.signer_kwargs

 #or secret_key in self.secret_keys:
 #ield fallback(secret_key, salt=salt, **kwargs)

 #ef dumps(self, obj: t.Any, salt: str | bytes | None = None) -> _TSerialized:
 #""Returns a signed string serialized with the internal
 #erializer. The return value can be either a byte or unicode
 #tring depending on the format of the internal serializer.
 #""
 #ayload = want_bytes(self.dump_payload(obj))
 #v = self.make_signer(salt).sign(payload)

 #f self.is_text_serializer:
 #eturn rv.decode("utf-8")  # type: ignore[return-value]

 #eturn rv  # type: ignore[return-value]

 #ef dump(self, obj: t.Any, f: t.IO[t.Any], salt: str | bytes | None = None) -> None:
 #""Like :meth:`dumps` but dumps into a file. The file handle has
 #o be compatible with what the internal serializer expects.
 #""
 #.write(self.dumps(obj, salt))

 #ef loads(
 #elf, s: str | bytes, salt: str | bytes | None = None, **kwargs: t.Any
 # -> t.Any:
 #""Reverse of :meth:`dumps`. Raises :exc:`.BadSignature` if the
 #ignature validation fails.
 #""
 # = want_bytes(s)
 #ast_exception = None

 #or signer in self.iter_unsigners(salt):
 #ry:
 #eturn self.load_payload(signer.unsign(s))
 #xcept BadSignature as err:
 #ast_exception = err

 #aise t.cast(BadSignature, last_exception)

 #ef load(self, f: t.IO[t.Any], salt: str | bytes | None = None) -> t.Any:
 #""Like :meth:`loads` but loads from a file."""
 #eturn self.loads(f.read(), salt)

 #ef loads_unsafe(
 #elf, s: str | bytes, salt: str | bytes | None = None
 # -> tuple[bool, t.Any]:
 #""Like :meth:`loads` but without verifying the signature. This
 #s potentially very dangerous to use depending on how your
 #erializer works. The return value is ``(signature_valid,
 #ayload)`` instead of just the payload. The first item will be a
 #oolean that indicates if the signature is valid. This function
 #ever fails.

 #se it for debugging only and if you know that your serializer
 #odule is not exploitable (for example, do not use it with a
 #ickle serializer).

 #. versionadded:: 0.15
 #""
 #eturn self._loads_unsafe_impl(s, salt)

 #ef _loads_unsafe_impl(
 #elf,
 #: str | bytes,
 #alt: str | bytes | None,
 #oad_kwargs: dict[str, t.Any] | None = None,
 #oad_payload_kwargs: dict[str, t.Any] | None = None,
 # -> tuple[bool, t.Any]:
 #""Low level helper function to implement :meth:`loads_unsafe`
 #n serializer subclasses.
 #""
 #f load_kwargs is None:
 #oad_kwargs = {}

 #ry:
 #eturn True, self.loads(s, salt=salt, **load_kwargs)
 #xcept BadSignature as e:
 #f e.payload is None:
 #eturn False, None

 #f load_payload_kwargs is None:
 #oad_payload_kwargs = {}

 #ry:
 #eturn (
 #alse,
 #elf.load_payload(e.payload, **load_payload_kwargs),
 #
 #xcept BadPayload:
 #eturn False, None

 #ef load_unsafe(
 #elf, f: t.IO[t.Any], salt: str | bytes | None = None
 # -> tuple[bool, t.Any]:
 #""Like :meth:`loads_unsafe` but loads from a file.

 #. versionadded:: 0.15
 #""
 #eturn self.loads_unsafe(f.read(), salt=salt)
