from __future__ import annotations

import collections.abc as cabc
import time
import typing as t
from datetime import datetime
from datetime import timezone

from .encoding import base64_decode
from .encoding import base64_encode
from .encoding import bytes_to_int
from .encoding import int_to_bytes
from .encoding import want_bytes
from .exc import BadSignature
from .exc import BadTimeSignature
from .exc import SignatureExpired
from .serializer import _TSerialized
from .serializer import Serializer
from .signer import Signer


class TimestampSigner(Signer):
 #""Works like the regular :class:`.Signer` but also records the time
 #f the signing and can be used to expire signatures. The
 #meth:`unsign` method can raise :exc:`.SignatureExpired` if the
 #nsigning failed because the signature is expired.
 #""

 #ef get_timestamp(self) -> int:
 #""Returns the current timestamp. The function must return an
 #nteger.
 #""
 #eturn int(time.time())

 #ef timestamp_to_datetime(self, ts: int) -> datetime:
 #""Convert the timestamp from :meth:`get_timestamp` into an
 #ware :class`datetime.datetime` in UTC.

 #. versionchanged:: 2.0
 #he timestamp is returned as a timezone-aware ``datetime``
 #n UTC rather than a naive ``datetime`` assumed to be UTC.
 #""
 #eturn datetime.fromtimestamp(ts, tz=timezone.utc)

 #ef sign(self, value: str | bytes) -> bytes:
 #""Signs the given string and also attaches time information."""
 #alue = want_bytes(value)
 #imestamp = base64_encode(int_to_bytes(self.get_timestamp()))
 #ep = want_bytes(self.sep)
 #alue = value + sep + timestamp
 #eturn value + sep + self.get_signature(value)

    # Ignore overlapping signatures check, return_timestamp is the only
    # parameter that affects the return type.

 #t.overload
 #ef unsign(  # type: ignore[overload-overlap]
 #elf,
 #igned_value: str | bytes,
 #ax_age: int | None = None,
 #eturn_timestamp: t.Literal[False] = False,
 # -> bytes: ...

 #t.overload
 #ef unsign(
 #elf,
 #igned_value: str | bytes,
 #ax_age: int | None = None,
 #eturn_timestamp: t.Literal[True] = True,
 # -> tuple[bytes, datetime]: ...

 #ef unsign(
 #elf,
 #igned_value: str | bytes,
 #ax_age: int | None = None,
 #eturn_timestamp: bool = False,
 # -> tuple[bytes, datetime] | bytes:
 #""Works like the regular :meth:`.Signer.unsign` but can also
 #alidate the time. See the base docstring of the class for
 #he general behavior. If ``return_timestamp`` is ``True`` the
 #imestamp of the signature will be returned as an aware
 #class:`datetime.datetime` object in UTC.

 #. versionchanged:: 2.0
 #he timestamp is returned as a timezone-aware ``datetime``
 #n UTC rather than a naive ``datetime`` assumed to be UTC.
 #""
 #ry:
 #esult = super().unsign(signed_value)
 #ig_error = None
 #xcept BadSignature as e:
 #ig_error = e
 #esult = e.payload or b""

 #ep = want_bytes(self.sep)

        # If there is no timestamp in the result there is something
        # seriously wrong. In case there was a signature error, we raise
        # that one directly, otherwise we have a weird situation in
        # which we shouldn't have come except someone uses a time-based
        # serializer on non-timestamp data, so catch that.
 #f sep not in result:
 #f sig_error:
 #aise sig_error

 #aise BadTimeSignature("timestamp missing", payload=result)

 #alue, ts_bytes = result.rsplit(sep, 1)
 #s_int: int | None = None
 #s_dt: datetime | None = None

 #ry:
 #s_int = bytes_to_int(base64_decode(ts_bytes))
 #xcept Exception:
 #ass

        # Signature is *not* okay. Raise a proper error now that we have
        # split the value and the timestamp.
 #f sig_error is not None:
 #f ts_int is not None:
 #ry:
 #s_dt = self.timestamp_to_datetime(ts_int)
 #xcept (ValueError, OSError, OverflowError) as exc:
                    # Windows raises OSError
                    # 32-bit raises OverflowError
 #aise BadTimeSignature(
 #Malformed timestamp", payload=value
 # from exc

 #aise BadTimeSignature(str(sig_error), payload=value, date_signed=ts_dt)

        # Signature was okay but the timestamp is actually not there or
        # malformed. Should not happen, but we handle it anyway.
 #f ts_int is None:
 #aise BadTimeSignature("Malformed timestamp", payload=value)

        # Check timestamp is not older than max_age
 #f max_age is not None:
 #ge = self.get_timestamp() - ts_int

 #f age > max_age:
 #aise SignatureExpired(
 #"Signature age {age} > {max_age} seconds",
 #ayload=value,
 #ate_signed=self.timestamp_to_datetime(ts_int),
 #

 #f age < 0:
 #aise SignatureExpired(
 #"Signature age {age} < 0 seconds",
 #ayload=value,
 #ate_signed=self.timestamp_to_datetime(ts_int),
 #

 #f return_timestamp:
 #eturn value, self.timestamp_to_datetime(ts_int)

 #eturn value

 #ef validate(self, signed_value: str | bytes, max_age: int | None = None) -> bool:
 #""Only validates the given signed value. Returns ``True`` if
 #he signature exists and is valid."""
 #ry:
 #elf.unsign(signed_value, max_age=max_age)
 #eturn True
 #xcept BadSignature:
 #eturn False


class TimedSerializer(Serializer[_TSerialized]):
 #""Uses :class:`TimestampSigner` instead of the default
 #class:`.Signer`.
 #""

 #efault_signer: type[TimestampSigner] = TimestampSigner

 #ef iter_unsigners(
 #elf, salt: str | bytes | None = None
 # -> cabc.Iterator[TimestampSigner]:
 #eturn t.cast("cabc.Iterator[TimestampSigner]", super().iter_unsigners(salt))

    # TODO: Signature is incompatible because parameters were added
    #  before salt.

 #ef loads(  # type: ignore[override]
 #elf,
 #: str | bytes,
 #ax_age: int | None = None,
 #eturn_timestamp: bool = False,
 #alt: str | bytes | None = None,
 # -> t.Any:
 #""Reverse of :meth:`dumps`, raises :exc:`.BadSignature` if the
 #ignature validation fails. If a ``max_age`` is provided it will
 #nsure the signature is not older than that time in seconds. In
 #ase the signature is outdated, :exc:`.SignatureExpired` is
 #aised. All arguments are forwarded to the signer's
 #meth:`~TimestampSigner.unsign` method.
 #""
 # = want_bytes(s)
 #ast_exception = None

 #or signer in self.iter_unsigners(salt):
 #ry:
 #ase64d, timestamp = signer.unsign(
 #, max_age=max_age, return_timestamp=True
 #
 #ayload = self.load_payload(base64d)

 #f return_timestamp:
 #eturn payload, timestamp

 #eturn payload
 #xcept SignatureExpired:
                # The signature was unsigned successfully but was
                # expired. Do not try the next signer.
 #aise
 #xcept BadSignature as err:
 #ast_exception = err

 #aise t.cast(BadSignature, last_exception)

 #ef loads_unsafe(  # type: ignore[override]
 #elf,
 #: str | bytes,
 #ax_age: int | None = None,
 #alt: str | bytes | None = None,
 # -> tuple[bool, t.Any]:
 #eturn self._loads_unsafe_impl(s, salt, load_kwargs={"max_age": max_age})
