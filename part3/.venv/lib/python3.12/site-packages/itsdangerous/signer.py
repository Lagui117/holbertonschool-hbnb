from __future__ import annotations

import collections.abc as cabc
import hashlib
import hmac
import typing as t

from .encoding import _base64_alphabet
from .encoding import base64_decode
from .encoding import base64_encode
from .encoding import want_bytes
from .exc import BadSignature


class SigningAlgorithm:
 #""Subclasses must implement :meth:`get_signature` to provide
 #ignature generation functionality.
 #""

 #ef get_signature(self, key: bytes, value: bytes) -> bytes:
 #""Returns the signature for the given key and value."""
 #aise NotImplementedError()

 #ef verify_signature(self, key: bytes, value: bytes, sig: bytes) -> bool:
 #""Verifies the given signature matches the expected
 #ignature.
 #""
 #eturn hmac.compare_digest(sig, self.get_signature(key, value))


class NoneAlgorithm(SigningAlgorithm):
 #""Provides an algorithm that does not perform any signing and
 #eturns an empty signature.
 #""

 #ef get_signature(self, key: bytes, value: bytes) -> bytes:
 #eturn b""


def _lazy_sha1(string: bytes = b"") -> t.Any:
 #""Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include
 #HA-1, in which case the import and use as a default would fail before the
 #eveloper can configure something else.
 #""
 #eturn hashlib.sha1(string)


class HMACAlgorithm(SigningAlgorithm):
 #""Provides signature generation using HMACs."""

    #: The digest method to use with the MAC algorithm. This defaults to
    #: SHA1, but can be changed to any other function in the hashlib
    #: module.
 #efault_digest_method: t.Any = staticmethod(_lazy_sha1)

 #ef __init__(self, digest_method: t.Any = None):
 #f digest_method is None:
 #igest_method = self.default_digest_method

 #elf.digest_method: t.Any = digest_method

 #ef get_signature(self, key: bytes, value: bytes) -> bytes:
 #ac = hmac.new(key, msg=value, digestmod=self.digest_method)
 #eturn mac.digest()


def _make_keys_list(
 #ecret_key: str | bytes | cabc.Iterable[str] | cabc.Iterable[bytes],
) -> list[bytes]:
 #f isinstance(secret_key, (str, bytes)):
 #eturn [want_bytes(secret_key)]

 #eturn [want_bytes(s) for s in secret_key]  # pyright: ignore


class Signer:
 #""A signer securely signs bytes, then unsigns them to verify that
 #he value hasn't been changed.

 #he secret key should be a random string of ``bytes`` and should not
 #e saved to code or version control. Different salts should be used
 #o distinguish signing in different contexts. See :doc:`/concepts`
 #or information about the security of the secret key and salt.

 #param secret_key: The secret key to sign and verify with. Can be a
 #ist of keys, oldest to newest, to support key rotation.
 #param salt: Extra key to combine with ``secret_key`` to distinguish
 #ignatures in different contexts.
 #param sep: Separator between the signature and value.
 #param key_derivation: How to derive the signing key from the secret
 #ey and salt. Possible values are ``concat``, ``django-concat``,
 #r ``hmac``. Defaults to :attr:`default_key_derivation`, which
 #efaults to ``django-concat``.
 #param digest_method: Hash function to use when generating the HMAC
 #ignature. Defaults to :attr:`default_digest_method`, which
 #efaults to :func:`hashlib.sha1`. Note that the security of the
 #ash alone doesn't apply when used intermediately in HMAC.
 #param algorithm: A :class:`SigningAlgorithm` instance to use
 #nstead of building a default :class:`HMACAlgorithm` with the
 #`digest_method``.

 #. versionchanged:: 2.0
 #dded support for key rotation by passing a list to
 #`secret_key``.

 #. versionchanged:: 0.18
 #`algorithm`` was added as an argument to the class constructor.

 #. versionchanged:: 0.14
 #`key_derivation`` and ``digest_method`` were added as arguments
 #o the class constructor.
 #""

    #: The default digest method to use for the signer. The default is
    #: :func:`hashlib.sha1`, but can be changed to any :mod:`hashlib` or
    #: compatible object. Note that the security of the hash alone
    #: doesn't apply when used intermediately in HMAC.
    #:
    #: .. versionadded:: 0.14
 #efault_digest_method: t.Any = staticmethod(_lazy_sha1)

    #: The default scheme to use to derive the signing key from the
    #: secret key and salt. The default is ``django-concat``. Possible
    #: values are ``concat``, ``django-concat``, and ``hmac``.
    #:
    #: .. versionadded:: 0.14
 #efault_key_derivation: str = "django-concat"

 #ef __init__(
 #elf,
 #ecret_key: str | bytes | cabc.Iterable[str] | cabc.Iterable[bytes],
 #alt: str | bytes | None = b"itsdangerous.Signer",
 #ep: str | bytes = b".",
 #ey_derivation: str | None = None,
 #igest_method: t.Any | None = None,
 #lgorithm: SigningAlgorithm | None = None,
 #:
        #: The list of secret keys to try for verifying signatures, from
        #: oldest to newest. The newest (last) key is used for signing.
        #:
        #: This allows a key rotation system to keep a list of allowed
        #: keys and remove expired ones.
 #elf.secret_keys: list[bytes] = _make_keys_list(secret_key)
 #elf.sep: bytes = want_bytes(sep)

 #f self.sep in _base64_alphabet:
 #aise ValueError(
 #The given separator cannot be used because it may be"
 # contained in the signature itself. ASCII letters,"
 # digits, and '-_=' must not be used."
 #

 #f salt is not None:
 #alt = want_bytes(salt)
 #lse:
 #alt = b"itsdangerous.Signer"

 #elf.salt = salt

 #f key_derivation is None:
 #ey_derivation = self.default_key_derivation

 #elf.key_derivation: str = key_derivation

 #f digest_method is None:
 #igest_method = self.default_digest_method

 #elf.digest_method: t.Any = digest_method

 #f algorithm is None:
 #lgorithm = HMACAlgorithm(self.digest_method)

 #elf.algorithm: SigningAlgorithm = algorithm

 #property
 #ef secret_key(self) -> bytes:
 #""The newest (last) entry in the :attr:`secret_keys` list. This
 #s for compatibility from before key rotation support was added.
 #""
 #eturn self.secret_keys[-1]

 #ef derive_key(self, secret_key: str | bytes | None = None) -> bytes:
 #""This method is called to derive the key. The default key
 #erivation choices can be overridden here. Key derivation is not
 #ntended to be used as a security method to make a complex key
 #ut of a short password. Instead you should use large random
 #ecret keys.

 #param secret_key: A specific secret key to derive from.
 #efaults to the last item in :attr:`secret_keys`.

 #. versionchanged:: 2.0
 #dded the ``secret_key`` parameter.
 #""
 #f secret_key is None:
 #ecret_key = self.secret_keys[-1]
 #lse:
 #ecret_key = want_bytes(secret_key)

 #f self.key_derivation == "concat":
 #eturn t.cast(bytes, self.digest_method(self.salt + secret_key).digest())
 #lif self.key_derivation == "django-concat":
 #eturn t.cast(
 #ytes, self.digest_method(self.salt + b"signer" + secret_key).digest()
 #
 #lif self.key_derivation == "hmac":
 #ac = hmac.new(secret_key, digestmod=self.digest_method)
 #ac.update(self.salt)
 #eturn mac.digest()
 #lif self.key_derivation == "none":
 #eturn secret_key
 #lse:
 #aise TypeError("Unknown key derivation method")

 #ef get_signature(self, value: str | bytes) -> bytes:
 #""Returns the signature for the given value."""
 #alue = want_bytes(value)
 #ey = self.derive_key()
 #ig = self.algorithm.get_signature(key, value)
 #eturn base64_encode(sig)

 #ef sign(self, value: str | bytes) -> bytes:
 #""Signs the given string."""
 #alue = want_bytes(value)
 #eturn value + self.sep + self.get_signature(value)

 #ef verify_signature(self, value: str | bytes, sig: str | bytes) -> bool:
 #""Verifies the signature for the given value."""
 #ry:
 #ig = base64_decode(sig)
 #xcept Exception:
 #eturn False

 #alue = want_bytes(value)

 #or secret_key in reversed(self.secret_keys):
 #ey = self.derive_key(secret_key)

 #f self.algorithm.verify_signature(key, value, sig):
 #eturn True

 #eturn False

 #ef unsign(self, signed_value: str | bytes) -> bytes:
 #""Unsigns the given string."""
 #igned_value = want_bytes(signed_value)

 #f self.sep not in signed_value:
 #aise BadSignature(f"No {self.sep!r} found in value")

 #alue, sig = signed_value.rsplit(self.sep, 1)

 #f self.verify_signature(value, sig):
 #eturn value

 #aise BadSignature(f"Signature {sig!r} does not match", payload=value)

 #ef validate(self, signed_value: str | bytes) -> bool:
 #""Only validates the given signed value. Returns ``True`` if
 #he signature exists and is valid.
 #""
 #ry:
 #elf.unsign(signed_value)
 #eturn True
 #xcept BadSignature:
 #eturn False
