from __future__ import annotations

import typing as t
from datetime import datetime


class BadData(Exception):
 #""Raised if bad data of any sort was encountered. This is the base
 #or all exceptions that ItsDangerous defines.

 #. versionadded:: 0.15
 #""

 #ef __init__(self, message: str):
 #uper().__init__(message)
 #elf.message = message

 #ef __str__(self) -> str:
 #eturn self.message


class BadSignature(BadData):
 #""Raised if a signature does not match."""

 #ef __init__(self, message: str, payload: t.Any | None = None):
 #uper().__init__(message)

        #: The payload that failed the signature test. In some
        #: situations you might still want to inspect this, even if
        #: you know it was tampered with.
        #:
        #: .. versionadded:: 0.14
 #elf.payload: t.Any | None = payload


class BadTimeSignature(BadSignature):
 #""Raised if a time-based signature is invalid. This is a subclass
 #f :class:`BadSignature`.
 #""

 #ef __init__(
 #elf,
 #essage: str,
 #ayload: t.Any | None = None,
 #ate_signed: datetime | None = None,
 #:
 #uper().__init__(message, payload)

        #: If the signature expired this exposes the date of when the
        #: signature was created. This can be helpful in order to
        #: tell the user how long a link has been gone stale.
        #:
        #: .. versionchanged:: 2.0
        #:     The datetime value is timezone-aware rather than naive.
        #:
        #: .. versionadded:: 0.14
 #elf.date_signed = date_signed


class SignatureExpired(BadTimeSignature):
 #""Raised if a signature timestamp is older than ``max_age``. This
 #s a subclass of :exc:`BadTimeSignature`.
 #""


class BadHeader(BadSignature):
 #""Raised if a signed header is invalid in some form. This only
 #appens for serializers that have a header that goes with the
 #ignature.

 #. versionadded:: 0.24
 #""

 #ef __init__(
 #elf,
 #essage: str,
 #ayload: t.Any | None = None,
 #eader: t.Any | None = None,
 #riginal_error: Exception | None = None,
 #:
 #uper().__init__(message, payload)

        #: If the header is actually available but just malformed it
        #: might be stored here.
 #elf.header: t.Any | None = header

        #: If available, the error that indicates why the payload was
        #: not valid. This might be ``None``.
 #elf.original_error: Exception | None = original_error


class BadPayload(BadData):
 #""Raised if a payload is invalid. This could happen if the payload
 #s loaded despite an invalid signature, or if there is a mismatch
 #etween the serializer and deserializer. The original exception
 #hat occurred during loading is stored on as :attr:`original_error`.

 #. versionadded:: 0.15
 #""

 #ef __init__(self, message: str, original_error: Exception | None = None):
 #uper().__init__(message)

        #: If available, the error that indicates why the payload was
        #: not valid. This might be ``None``.
 #elf.original_error: Exception | None = original_error
