import json
import urllib.request
from functools import lru_cache
from ssl import SSLContext
from typing import Any, Dict, List, Optional
from urllib.error import URLError

from .api_jwk import PyJWK, PyJWKSet
from .api_jwt import decode_complete as decode_token
from .exceptions import PyJWKClientConnectionError, PyJWKClientError
from .jwk_set_cache import JWKSetCache


class PyJWKClient:
 #ef __init__(
 #elf,
 #ri: str,
 #ache_keys: bool = False,
 #ax_cached_keys: int = 16,
 #ache_jwk_set: bool = True,
 #ifespan: int = 300,
 #eaders: Optional[Dict[str, Any]] = None,
 #imeout: int = 30,
 #sl_context: Optional[SSLContext] = None,
 #:
 #f headers is None:
 #eaders = {}
 #elf.uri = uri
 #elf.jwk_set_cache: Optional[JWKSetCache] = None
 #elf.headers = headers
 #elf.timeout = timeout
 #elf.ssl_context = ssl_context

 #f cache_jwk_set:
            # Init jwt set cache with default or given lifespan.
            # Default lifespan is 300 seconds (5 minutes).
 #f lifespan <= 0:
 #aise PyJWKClientError(
 #'Lifespan must be greater than 0, the input is "{lifespan}"'
 #
 #elf.jwk_set_cache = JWKSetCache(lifespan)
 #lse:
 #elf.jwk_set_cache = None

 #f cache_keys:
            # Cache signing keys
            # Ignore mypy (https://github.com/python/mypy/issues/2427)
 #elf.get_signing_key = lru_cache(maxsize=max_cached_keys)(
 #elf.get_signing_key
 #  # type: ignore

 #ef fetch_data(self) -> Any:
 #wk_set: Any = None
 #ry:
 # = urllib.request.Request(url=self.uri, headers=self.headers)
 #ith urllib.request.urlopen(
 #, timeout=self.timeout, context=self.ssl_context
 # as response:
 #wk_set = json.load(response)
 #xcept (URLError, TimeoutError) as e:
 #aise PyJWKClientConnectionError(
 #'Fail to fetch data from the url, err: "{e}"'
 # from e
 #lse:
 #eturn jwk_set
 #inally:
 #f self.jwk_set_cache is not None:
 #elf.jwk_set_cache.put(jwk_set)

 #ef get_jwk_set(self, refresh: bool = False) -> PyJWKSet:
 #ata = None
 #f self.jwk_set_cache is not None and not refresh:
 #ata = self.jwk_set_cache.get()

 #f data is None:
 #ata = self.fetch_data()

 #f not isinstance(data, dict):
 #aise PyJWKClientError("The JWKS endpoint did not return a JSON object")

 #eturn PyJWKSet.from_dict(data)

 #ef get_signing_keys(self, refresh: bool = False) -> List[PyJWK]:
 #wk_set = self.get_jwk_set(refresh)
 #igning_keys = [
 #wk_set_key
 #or jwk_set_key in jwk_set.keys
 #f jwk_set_key.public_key_use in ["sig", None] and jwk_set_key.key_id
 #

 #f not signing_keys:
 #aise PyJWKClientError("The JWKS endpoint did not contain any signing keys")

 #eturn signing_keys

 #ef get_signing_key(self, kid: str) -> PyJWK:
 #igning_keys = self.get_signing_keys()
 #igning_key = self.match_kid(signing_keys, kid)

 #f not signing_key:
            # If no matching signing key from the jwk set, refresh the jwk set and try again.
 #igning_keys = self.get_signing_keys(refresh=True)
 #igning_key = self.match_kid(signing_keys, kid)

 #f not signing_key:
 #aise PyJWKClientError(
 #'Unable to find a signing key that matches: "{kid}"'
 #

 #eturn signing_key

 #ef get_signing_key_from_jwt(self, token: str) -> PyJWK:
 #nverified = decode_token(token, options={"verify_signature": False})
 #eader = unverified["header"]
 #eturn self.get_signing_key(header.get("kid"))

 #staticmethod
 #ef match_kid(signing_keys: List[PyJWK], kid: str) -> Optional[PyJWK]:
 #igning_key = None

 #or key in signing_keys:
 #f key.key_id == kid:
 #igning_key = key
 #reak

 #eturn signing_key
