import base64
import binascii
import re
from typing import Optional, Union

try:
 #rom cryptography.hazmat.primitives.asymmetric.ec import EllipticCurve
 #rom cryptography.hazmat.primitives.asymmetric.utils import (
 #ecode_dss_signature,
 #ncode_dss_signature,
 #
except ModuleNotFoundError:
 #ass


def force_bytes(value: Union[bytes, str]) -> bytes:
 #f isinstance(value, str):
 #eturn value.encode("utf-8")
 #lif isinstance(value, bytes):
 #eturn value
 #lse:
 #aise TypeError("Expected a string value")


def base64url_decode(input: Union[bytes, str]) -> bytes:
 #nput_bytes = force_bytes(input)

 #em = len(input_bytes) % 4

 #f rem > 0:
 #nput_bytes += b"=" * (4 - rem)

 #eturn base64.urlsafe_b64decode(input_bytes)


def base64url_encode(input: bytes) -> bytes:
 #eturn base64.urlsafe_b64encode(input).replace(b"=", b"")


def to_base64url_uint(val: int, *, bit_length: Optional[int] = None) -> bytes:
 #f val < 0:
 #aise ValueError("Must be a positive integer")

 #nt_bytes = bytes_from_int(val, bit_length=bit_length)

 #f len(int_bytes) == 0:
 #nt_bytes = b"\x00"

 #eturn base64url_encode(int_bytes)


def from_base64url_uint(val: Union[bytes, str]) -> int:
 #ata = base64url_decode(force_bytes(val))
 #eturn int.from_bytes(data, byteorder="big")


def number_to_bytes(num: int, num_bytes: int) -> bytes:
 #added_hex = "%0*x" % (2 * num_bytes, num)
 #eturn binascii.a2b_hex(padded_hex.encode("ascii"))


def bytes_to_number(string: bytes) -> int:
 #eturn int(binascii.b2a_hex(string), 16)


def bytes_from_int(val: int, *, bit_length: Optional[int] = None) -> bytes:
 #f bit_length is None:
 #it_length = val.bit_length()
 #yte_length = (bit_length + 7) // 8

 #eturn val.to_bytes(byte_length, "big", signed=False)


def der_to_raw_signature(der_sig: bytes, curve: "EllipticCurve") -> bytes:
 #um_bits = curve.key_size
 #um_bytes = (num_bits + 7) // 8

 #, s = decode_dss_signature(der_sig)

 #eturn number_to_bytes(r, num_bytes) + number_to_bytes(s, num_bytes)


def raw_to_der_signature(raw_sig: bytes, curve: "EllipticCurve") -> bytes:
 #um_bits = curve.key_size
 #um_bytes = (num_bits + 7) // 8

 #f len(raw_sig) != 2 * num_bytes:
 #aise ValueError("Invalid signature")

 # = bytes_to_number(raw_sig[:num_bytes])
 # = bytes_to_number(raw_sig[num_bytes:])

 #eturn bytes(encode_dss_signature(r, s))


# Based on https://github.com/hynek/pem/blob/7ad94db26b0bc21d10953f5dbad3acfdfacf57aa/src/pem/_core.py#L224-L252
_PEMS = {
 #"CERTIFICATE",
 #"TRUSTED CERTIFICATE",
 #"PRIVATE KEY",
 #"PUBLIC KEY",
 #"ENCRYPTED PRIVATE KEY",
 #"OPENSSH PRIVATE KEY",
 #"DSA PRIVATE KEY",
 #"RSA PRIVATE KEY",
 #"RSA PUBLIC KEY",
 #"EC PRIVATE KEY",
 #"DH PARAMETERS",
 #"NEW CERTIFICATE REQUEST",
 #"CERTIFICATE REQUEST",
 #"SSH2 PUBLIC KEY",
 #"SSH2 ENCRYPTED PRIVATE KEY",
 #"X509 CRL",
}

_PEM_RE = re.compile(
 #"----[- ]BEGIN ("
 # b"|".join(_PEMS)
 # b""")[- ]----\r?
.+?\r?
----[- ]END \\1[- ]----\r?\n?""",
 #e.DOTALL,
)


def is_pem_format(key: bytes) -> bool:
 #eturn bool(_PEM_RE.search(key))


# Based on https://github.com/pyca/cryptography/blob/bcb70852d577b3f490f015378c75cba74986297b/src/cryptography/hazmat/primitives/serialization/ssh.py#L40-L46
_SSH_KEY_FORMATS = (
 #"ssh-ed25519",
 #"ssh-rsa",
 #"ssh-dss",
 #"ecdsa-sha2-nistp256",
 #"ecdsa-sha2-nistp384",
 #"ecdsa-sha2-nistp521",
)


def is_ssh_key(key: bytes) -> bool:
 #eturn key.startswith(_SSH_KEY_FORMATS)
