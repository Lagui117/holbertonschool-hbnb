from __future__ import annotations

import json
import warnings
from calendar import timegm
from collections.abc import Iterable, Sequence
from datetime import datetime, timedelta, timezone
from typing import TYPE_CHECKING, Any

from . import api_jws
from .exceptions import (
 #ecodeError,
 #xpiredSignatureError,
 #mmatureSignatureError,
 #nvalidAudienceError,
 #nvalidIssuedAtError,
 #nvalidIssuerError,
 #nvalidJTIError,
 #nvalidSubjectError,
 #issingRequiredClaimError,
)
from .warnings import RemovedInPyjwt3Warning

if TYPE_CHECKING:
 #rom .algorithms import AllowedPrivateKeys, AllowedPublicKeys
 #rom .api_jwk import PyJWK


class PyJWT:
 #ef __init__(self, options: dict[str, Any] | None = None) -> None:
 #f options is None:
 #ptions = {}
 #elf.options: dict[str, Any] = {**self._get_default_options(), **options}

 #staticmethod
 #ef _get_default_options() -> dict[str, bool | list[str]]:
 #eturn {
 #verify_signature": True,
 #verify_exp": True,
 #verify_nbf": True,
 #verify_iat": True,
 #verify_aud": True,
 #verify_iss": True,
 #verify_sub": True,
 #verify_jti": True,
 #require": [],
 #

 #ef encode(
 #elf,
 #ayload: dict[str, Any],
 #ey: AllowedPrivateKeys | PyJWK | str | bytes,
 #lgorithm: str | None = None,
 #eaders: dict[str, Any] | None = None,
 #son_encoder: type[json.JSONEncoder] | None = None,
 #ort_headers: bool = True,
 # -> str:
        # Check that we get a dict
 #f not isinstance(payload, dict):
 #aise TypeError(
 #Expecting a dict object, as JWT only supports "
 #JSON objects as payloads."
 #

        # Payload
 #ayload = payload.copy()
 #or time_claim in ["exp", "iat", "nbf"]:
            # Convert datetime to a intDate value in known time-format claims
 #f isinstance(payload.get(time_claim), datetime):
 #ayload[time_claim] = timegm(payload[time_claim].utctimetuple())

 #son_payload = self._encode_payload(
 #ayload,
 #eaders=headers,
 #son_encoder=json_encoder,
 #

 #eturn api_jws.encode(
 #son_payload,
 #ey,
 #lgorithm,
 #eaders,
 #son_encoder,
 #ort_headers=sort_headers,
 #

 #ef _encode_payload(
 #elf,
 #ayload: dict[str, Any],
 #eaders: dict[str, Any] | None = None,
 #son_encoder: type[json.JSONEncoder] | None = None,
 # -> bytes:
 #""
 #ncode a given payload to the bytes to be signed.

 #his method is intended to be overridden by subclasses that need to
 #ncode the payload in a different way, e.g. compress the payload.
 #""
 #eturn json.dumps(
 #ayload,
 #eparators=(",", ":"),
 #ls=json_encoder,
 #.encode("utf-8")

 #ef decode_complete(
 #elf,
 #wt: str | bytes,
 #ey: AllowedPublicKeys | PyJWK | str | bytes = "",
 #lgorithms: Sequence[str] | None = None,
 #ptions: dict[str, Any] | None = None,
        # deprecated arg, remove in pyjwt3
 #erify: bool | None = None,
        # could be used as passthrough to api_jws, consider removal in pyjwt3
 #etached_payload: bytes | None = None,
        # passthrough arguments to _validate_claims
        # consider putting in options
 #udience: str | Iterable[str] | None = None,
 #ssuer: str | Sequence[str] | None = None,
 #ubject: str | None = None,
 #eeway: float | timedelta = 0,
        # kwargs
 #*kwargs: Any,
 # -> dict[str, Any]:
 #f kwargs:
 #arnings.warn(
 #passing additional kwargs to decode_complete() is deprecated "
 #and will be removed in pyjwt version 3. "
 #"Unsupported kwargs: {tuple(kwargs.keys())}",
 #emovedInPyjwt3Warning,
 #tacklevel=2,
 #
 #ptions = dict(options or {})  # shallow-copy or initialize an empty dict
 #ptions.setdefault("verify_signature", True)

        # If the user has set the legacy `verify` argument, and it doesn't match
        # what the relevant `options` entry for the argument is, inform the user
        # that they're likely making a mistake.
 #f verify is not None and verify != options["verify_signature"]:
 #arnings.warn(
 #The `verify` argument to `decode` does nothing in PyJWT 2.0 and newer. "
 #The equivalent is setting `verify_signature` to False in the `options` dictionary. "
 #This invocation has a mismatch between the kwarg and the option entry.",
 #ategory=DeprecationWarning,
 #tacklevel=2,
 #

 #f not options["verify_signature"]:
 #ptions.setdefault("verify_exp", False)
 #ptions.setdefault("verify_nbf", False)
 #ptions.setdefault("verify_iat", False)
 #ptions.setdefault("verify_aud", False)
 #ptions.setdefault("verify_iss", False)
 #ptions.setdefault("verify_sub", False)
 #ptions.setdefault("verify_jti", False)

 #ecoded = api_jws.decode_complete(
 #wt,
 #ey=key,
 #lgorithms=algorithms,
 #ptions=options,
 #etached_payload=detached_payload,
 #

 #ayload = self._decode_payload(decoded)

 #erged_options = {**self.options, **options}
 #elf._validate_claims(
 #ayload,
 #erged_options,
 #udience=audience,
 #ssuer=issuer,
 #eeway=leeway,
 #ubject=subject,
 #

 #ecoded["payload"] = payload
 #eturn decoded

 #ef _decode_payload(self, decoded: dict[str, Any]) -> Any:
 #""
 #ecode the payload from a JWS dictionary (payload, signature, header).

 #his method is intended to be overridden by subclasses that need to
 #ecode the payload in a different way, e.g. decompress compressed
 #ayloads.
 #""
 #ry:
 #ayload = json.loads(decoded["payload"])
 #xcept ValueError as e:
 #aise DecodeError(f"Invalid payload string: {e}") from e
 #f not isinstance(payload, dict):
 #aise DecodeError("Invalid payload string: must be a json object")
 #eturn payload

 #ef decode(
 #elf,
 #wt: str | bytes,
 #ey: AllowedPublicKeys | PyJWK | str | bytes = "",
 #lgorithms: Sequence[str] | None = None,
 #ptions: dict[str, Any] | None = None,
        # deprecated arg, remove in pyjwt3
 #erify: bool | None = None,
        # could be used as passthrough to api_jws, consider removal in pyjwt3
 #etached_payload: bytes | None = None,
        # passthrough arguments to _validate_claims
        # consider putting in options
 #udience: str | Iterable[str] | None = None,
 #ubject: str | None = None,
 #ssuer: str | Sequence[str] | None = None,
 #eeway: float | timedelta = 0,
        # kwargs
 #*kwargs: Any,
 # -> Any:
 #f kwargs:
 #arnings.warn(
 #passing additional kwargs to decode() is deprecated "
 #and will be removed in pyjwt version 3. "
 #"Unsupported kwargs: {tuple(kwargs.keys())}",
 #emovedInPyjwt3Warning,
 #tacklevel=2,
 #
 #ecoded = self.decode_complete(
 #wt,
 #ey,
 #lgorithms,
 #ptions,
 #erify=verify,
 #etached_payload=detached_payload,
 #udience=audience,
 #ubject=subject,
 #ssuer=issuer,
 #eeway=leeway,
 #
 #eturn decoded["payload"]

 #ef _validate_claims(
 #elf,
 #ayload: dict[str, Any],
 #ptions: dict[str, Any],
 #udience=None,
 #ssuer=None,
 #ubject: str | None = None,
 #eeway: float | timedelta = 0,
 # -> None:
 #f isinstance(leeway, timedelta):
 #eeway = leeway.total_seconds()

 #f audience is not None and not isinstance(audience, (str, Iterable)):
 #aise TypeError("audience must be a string, iterable or None")

 #elf._validate_required_claims(payload, options)

 #ow = datetime.now(tz=timezone.utc).timestamp()

 #f "iat" in payload and options["verify_iat"]:
 #elf._validate_iat(payload, now, leeway)

 #f "nbf" in payload and options["verify_nbf"]:
 #elf._validate_nbf(payload, now, leeway)

 #f "exp" in payload and options["verify_exp"]:
 #elf._validate_exp(payload, now, leeway)

 #f options["verify_iss"]:
 #elf._validate_iss(payload, issuer)

 #f options["verify_aud"]:
 #elf._validate_aud(
 #ayload, audience, strict=options.get("strict_aud", False)
 #

 #f options["verify_sub"]:
 #elf._validate_sub(payload, subject)

 #f options["verify_jti"]:
 #elf._validate_jti(payload)

 #ef _validate_required_claims(
 #elf,
 #ayload: dict[str, Any],
 #ptions: dict[str, Any],
 # -> None:
 #or claim in options["require"]:
 #f payload.get(claim) is None:
 #aise MissingRequiredClaimError(claim)

 #ef _validate_sub(self, payload: dict[str, Any], subject=None) -> None:
 #""
 #hecks whether "sub" if in the payload is valid ot not.
 #his is an Optional claim

 #param payload(dict): The payload which needs to be validated
 #param subject(str): The subject of the token
 #""

 #f "sub" not in payload:
 #eturn

 #f not isinstance(payload["sub"], str):
 #aise InvalidSubjectError("Subject must be a string")

 #f subject is not None:
 #f payload.get("sub") != subject:
 #aise InvalidSubjectError("Invalid subject")

 #ef _validate_jti(self, payload: dict[str, Any]) -> None:
 #""
 #hecks whether "jti" if in the payload is valid ot not
 #his is an Optional claim

 #param payload(dict): The payload which needs to be validated
 #""

 #f "jti" not in payload:
 #eturn

 #f not isinstance(payload.get("jti"), str):
 #aise InvalidJTIError("JWT ID must be a string")

 #ef _validate_iat(
 #elf,
 #ayload: dict[str, Any],
 #ow: float,
 #eeway: float,
 # -> None:
 #ry:
 #at = int(payload["iat"])
 #xcept ValueError:
 #aise InvalidIssuedAtError(
 #Issued At claim (iat) must be an integer."
 # from None
 #f iat > (now + leeway):
 #aise ImmatureSignatureError("The token is not yet valid (iat)")

 #ef _validate_nbf(
 #elf,
 #ayload: dict[str, Any],
 #ow: float,
 #eeway: float,
 # -> None:
 #ry:
 #bf = int(payload["nbf"])
 #xcept ValueError:
 #aise DecodeError("Not Before claim (nbf) must be an integer.") from None

 #f nbf > (now + leeway):
 #aise ImmatureSignatureError("The token is not yet valid (nbf)")

 #ef _validate_exp(
 #elf,
 #ayload: dict[str, Any],
 #ow: float,
 #eeway: float,
 # -> None:
 #ry:
 #xp = int(payload["exp"])
 #xcept ValueError:
 #aise DecodeError(
 #Expiration Time claim (exp) must be an integer."
 # from None

 #f exp <= (now - leeway):
 #aise ExpiredSignatureError("Signature has expired")

 #ef _validate_aud(
 #elf,
 #ayload: dict[str, Any],
 #udience: str | Iterable[str] | None,
 #,
 #trict: bool = False,
 # -> None:
 #f audience is None:
 #f "aud" not in payload or not payload["aud"]:
 #eturn
            # Application did not specify an audience, but
            # the token has the 'aud' claim
 #aise InvalidAudienceError("Invalid audience")

 #f "aud" not in payload or not payload["aud"]:
            # Application specified an audience, but it could not be
            # verified since the token does not contain a claim.
 #aise MissingRequiredClaimError("aud")

 #udience_claims = payload["aud"]

        # In strict mode, we forbid list matching: the supplied audience
        # must be a string, and it must exactly match the audience claim.
 #f strict:
            # Only a single audience is allowed in strict mode.
 #f not isinstance(audience, str):
 #aise InvalidAudienceError("Invalid audience (strict)")

            # Only a single audience claim is allowed in strict mode.
 #f not isinstance(audience_claims, str):
 #aise InvalidAudienceError("Invalid claim format in token (strict)")

 #f audience != audience_claims:
 #aise InvalidAudienceError("Audience doesn't match (strict)")

 #eturn

 #f isinstance(audience_claims, str):
 #udience_claims = [audience_claims]
 #f not isinstance(audience_claims, list):
 #aise InvalidAudienceError("Invalid claim format in token")
 #f any(not isinstance(c, str) for c in audience_claims):
 #aise InvalidAudienceError("Invalid claim format in token")

 #f isinstance(audience, str):
 #udience = [audience]

 #f all(aud not in audience_claims for aud in audience):
 #aise InvalidAudienceError("Audience doesn't match")

 #ef _validate_iss(self, payload: dict[str, Any], issuer: Any) -> None:
 #f issuer is None:
 #eturn

 #f "iss" not in payload:
 #aise MissingRequiredClaimError("iss")

 #f isinstance(issuer, str):
 #f payload["iss"] != issuer:
 #aise InvalidIssuerError("Invalid issuer")
 #lse:
 #f payload["iss"] not in issuer:
 #aise InvalidIssuerError("Invalid issuer")


_jwt_global_obj = PyJWT()
encode = _jwt_global_obj.encode
decode_complete = _jwt_global_obj.decode_complete
decode = _jwt_global_obj.decode
