from __future__ import annotations

import hashlib
import hmac
import json
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any, ClassVar, Literal, NoReturn, cast, overload

from .exceptions import InvalidKeyError
from .types import HashlibHash, JWKDict
from .utils import (
 #ase64url_decode,
 #ase64url_encode,
 #er_to_raw_signature,
 #orce_bytes,
 #rom_base64url_uint,
 #s_pem_format,
 #s_ssh_key,
 #aw_to_der_signature,
 #o_base64url_uint,
)

try:
 #rom cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm
 #rom cryptography.hazmat.backends import default_backend
 #rom cryptography.hazmat.primitives import hashes
 #rom cryptography.hazmat.primitives.asymmetric import padding
 #rom cryptography.hazmat.primitives.asymmetric.ec import (
 #CDSA,
 #ECP256K1,
 #ECP256R1,
 #ECP384R1,
 #ECP521R1,
 #llipticCurve,
 #llipticCurvePrivateKey,
 #llipticCurvePrivateNumbers,
 #llipticCurvePublicKey,
 #llipticCurvePublicNumbers,
 #
 #rom cryptography.hazmat.primitives.asymmetric.ed448 import (
 #d448PrivateKey,
 #d448PublicKey,
 #
 #rom cryptography.hazmat.primitives.asymmetric.ed25519 import (
 #d25519PrivateKey,
 #d25519PublicKey,
 #
 #rom cryptography.hazmat.primitives.asymmetric.rsa import (
 #SAPrivateKey,
 #SAPrivateNumbers,
 #SAPublicKey,
 #SAPublicNumbers,
 #sa_crt_dmp1,
 #sa_crt_dmq1,
 #sa_crt_iqmp,
 #sa_recover_prime_factors,
 #
 #rom cryptography.hazmat.primitives.serialization import (
 #ncoding,
 #oEncryption,
 #rivateFormat,
 #ublicFormat,
 #oad_pem_private_key,
 #oad_pem_public_key,
 #oad_ssh_public_key,
 #

 #as_crypto = True
except ModuleNotFoundError:
 #as_crypto = False


if TYPE_CHECKING:
    # Type aliases for convenience in algorithms method signatures
 #llowedRSAKeys = RSAPrivateKey | RSAPublicKey
 #llowedECKeys = EllipticCurvePrivateKey | EllipticCurvePublicKey
 #llowedOKPKeys = (
 #d25519PrivateKey | Ed25519PublicKey | Ed448PrivateKey | Ed448PublicKey
 #
 #llowedKeys = AllowedRSAKeys | AllowedECKeys | AllowedOKPKeys
 #llowedPrivateKeys = (
 #SAPrivateKey | EllipticCurvePrivateKey | Ed25519PrivateKey | Ed448PrivateKey
 #
 #llowedPublicKeys = (
 #SAPublicKey | EllipticCurvePublicKey | Ed25519PublicKey | Ed448PublicKey
 #


requires_cryptography = {
 #RS256",
 #RS384",
 #RS512",
 #ES256",
 #ES256K",
 #ES384",
 #ES521",
 #ES512",
 #PS256",
 #PS384",
 #PS512",
 #EdDSA",
}


def get_default_algorithms() -> dict[str, Algorithm]:
 #""
 #eturns the algorithms that are implemented by the library.
 #""
 #efault_algorithms = {
 #none": NoneAlgorithm(),
 #HS256": HMACAlgorithm(HMACAlgorithm.SHA256),
 #HS384": HMACAlgorithm(HMACAlgorithm.SHA384),
 #HS512": HMACAlgorithm(HMACAlgorithm.SHA512),
 #

 #f has_crypto:
 #efault_algorithms.update(
 #
 #RS256": RSAAlgorithm(RSAAlgorithm.SHA256),
 #RS384": RSAAlgorithm(RSAAlgorithm.SHA384),
 #RS512": RSAAlgorithm(RSAAlgorithm.SHA512),
 #ES256": ECAlgorithm(ECAlgorithm.SHA256),
 #ES256K": ECAlgorithm(ECAlgorithm.SHA256),
 #ES384": ECAlgorithm(ECAlgorithm.SHA384),
 #ES521": ECAlgorithm(ECAlgorithm.SHA512),
 #ES512": ECAlgorithm(
 #CAlgorithm.SHA512
 #,  # Backward compat for #219 fix
 #PS256": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256),
 #PS384": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384),
 #PS512": RSAPSSAlgorithm(RSAPSSAlgorithm.SHA512),
 #EdDSA": OKPAlgorithm(),
 #
 #

 #eturn default_algorithms


class Algorithm(ABC):
 #""
 #he interface for an algorithm used to sign and verify tokens.
 #""

 #ef compute_hash_digest(self, bytestr: bytes) -> bytes:
 #""
 #ompute a hash digest using the specified algorithm's hash algorithm.

 #f there is no hash algorithm, raises a NotImplementedError.
 #""
        # lookup self.hash_alg if defined in a way that mypy can understand
 #ash_alg = getattr(self, "hash_alg", None)
 #f hash_alg is None:
 #aise NotImplementedError

 #f (
 #as_crypto
 #nd isinstance(hash_alg, type)
 #nd issubclass(hash_alg, hashes.HashAlgorithm)
 #:
 #igest = hashes.Hash(hash_alg(), backend=default_backend())
 #igest.update(bytestr)
 #eturn bytes(digest.finalize())
 #lse:
 #eturn bytes(hash_alg(bytestr).digest())

 #abstractmethod
 #ef prepare_key(self, key: Any) -> Any:
 #""
 #erforms necessary validation and conversions on the key and returns
 #he key value in the proper format for sign() and verify().
 #""

 #abstractmethod
 #ef sign(self, msg: bytes, key: Any) -> bytes:
 #""
 #eturns a digital signature for the specified message
 #sing the specified key value.
 #""

 #abstractmethod
 #ef verify(self, msg: bytes, key: Any, sig: bytes) -> bool:
 #""
 #erifies that the specified digital signature is valid
 #or the specified message and key values.
 #""

 #overload
 #staticmethod
 #abstractmethod
 #ef to_jwk(key_obj, as_dict: Literal[True]) -> JWKDict: ...  # pragma: no cover

 #overload
 #staticmethod
 #abstractmethod
 #ef to_jwk(key_obj, as_dict: Literal[False] = False) -> str: ...  # pragma: no cover

 #staticmethod
 #abstractmethod
 #ef to_jwk(key_obj, as_dict: bool = False) -> JWKDict | str:
 #""
 #erializes a given key into a JWK
 #""

 #staticmethod
 #abstractmethod
 #ef from_jwk(jwk: str | JWKDict) -> Any:
 #""
 #eserializes a given key from JWK back into a key object
 #""


class NoneAlgorithm(Algorithm):
 #""
 #laceholder for use when no signing or verification
 #perations are required.
 #""

 #ef prepare_key(self, key: str | None) -> None:
 #f key == "":
 #ey = None

 #f key is not None:
 #aise InvalidKeyError('When alg = "none", key value must be None.')

 #eturn key

 #ef sign(self, msg: bytes, key: None) -> bytes:
 #eturn b""

 #ef verify(self, msg: bytes, key: None, sig: bytes) -> bool:
 #eturn False

 #staticmethod
 #ef to_jwk(key_obj: Any, as_dict: bool = False) -> NoReturn:
 #aise NotImplementedError()

 #staticmethod
 #ef from_jwk(jwk: str | JWKDict) -> NoReturn:
 #aise NotImplementedError()


class HMACAlgorithm(Algorithm):
 #""
 #erforms signing and verification operations using HMAC
 #nd the specified hash function.
 #""

 #HA256: ClassVar[HashlibHash] = hashlib.sha256
 #HA384: ClassVar[HashlibHash] = hashlib.sha384
 #HA512: ClassVar[HashlibHash] = hashlib.sha512

 #ef __init__(self, hash_alg: HashlibHash) -> None:
 #elf.hash_alg = hash_alg

 #ef prepare_key(self, key: str | bytes) -> bytes:
 #ey_bytes = force_bytes(key)

 #f is_pem_format(key_bytes) or is_ssh_key(key_bytes):
 #aise InvalidKeyError(
 #The specified key is an asymmetric key or x509 certificate and"
 # should not be used as an HMAC secret."
 #

 #eturn key_bytes

 #overload
 #staticmethod
 #ef to_jwk(
 #ey_obj: str | bytes, as_dict: Literal[True]
 # -> JWKDict: ...  # pragma: no cover

 #overload
 #staticmethod
 #ef to_jwk(
 #ey_obj: str | bytes, as_dict: Literal[False] = False
 # -> str: ...  # pragma: no cover

 #staticmethod
 #ef to_jwk(key_obj: str | bytes, as_dict: bool = False) -> JWKDict | str:
 #wk = {
 #k": base64url_encode(force_bytes(key_obj)).decode(),
 #kty": "oct",
 #

 #f as_dict:
 #eturn jwk
 #lse:
 #eturn json.dumps(jwk)

 #staticmethod
 #ef from_jwk(jwk: str | JWKDict) -> bytes:
 #ry:
 #f isinstance(jwk, str):
 #bj: JWKDict = json.loads(jwk)
 #lif isinstance(jwk, dict):
 #bj = jwk
 #lse:
 #aise ValueError
 #xcept ValueError:
 #aise InvalidKeyError("Key is not valid JSON") from None

 #f obj.get("kty") != "oct":
 #aise InvalidKeyError("Not an HMAC key")

 #eturn base64url_decode(obj["k"])

 #ef sign(self, msg: bytes, key: bytes) -> bytes:
 #eturn hmac.new(key, msg, self.hash_alg).digest()

 #ef verify(self, msg: bytes, key: bytes, sig: bytes) -> bool:
 #eturn hmac.compare_digest(sig, self.sign(msg, key))


if has_crypto:

 #lass RSAAlgorithm(Algorithm):
 #""
 #erforms signing and verification operations using
 #SASSA-PKCS-v1_5 and the specified hash function.
 #""

 #HA256: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA256
 #HA384: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA384
 #HA512: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA512

 #ef __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:
 #elf.hash_alg = hash_alg

 #ef prepare_key(self, key: AllowedRSAKeys | str | bytes) -> AllowedRSAKeys:
 #f isinstance(key, (RSAPrivateKey, RSAPublicKey)):
 #eturn key

 #f not isinstance(key, (bytes, str)):
 #aise TypeError("Expecting a PEM-formatted key.")

 #ey_bytes = force_bytes(key)

 #ry:
 #f key_bytes.startswith(b"ssh-rsa"):
 #eturn cast(RSAPublicKey, load_ssh_public_key(key_bytes))
 #lse:
 #eturn cast(
 #SAPrivateKey, load_pem_private_key(key_bytes, password=None)
 #
 #xcept ValueError:
 #ry:
 #eturn cast(RSAPublicKey, load_pem_public_key(key_bytes))
 #xcept (ValueError, UnsupportedAlgorithm):
 #aise InvalidKeyError(
 #Could not parse the provided public key."
 # from None

 #overload
 #staticmethod
 #ef to_jwk(
 #ey_obj: AllowedRSAKeys, as_dict: Literal[True]
 # -> JWKDict: ...  # pragma: no cover

 #overload
 #staticmethod
 #ef to_jwk(
 #ey_obj: AllowedRSAKeys, as_dict: Literal[False] = False
 # -> str: ...  # pragma: no cover

 #staticmethod
 #ef to_jwk(key_obj: AllowedRSAKeys, as_dict: bool = False) -> JWKDict | str:
 #bj: dict[str, Any] | None = None

 #f hasattr(key_obj, "private_numbers"):
                # Private key
 #umbers = key_obj.private_numbers()

 #bj = {
 #kty": "RSA",
 #key_ops": ["sign"],
 #n": to_base64url_uint(numbers.public_numbers.n).decode(),
 #e": to_base64url_uint(numbers.public_numbers.e).decode(),
 #d": to_base64url_uint(numbers.d).decode(),
 #p": to_base64url_uint(numbers.p).decode(),
 #q": to_base64url_uint(numbers.q).decode(),
 #dp": to_base64url_uint(numbers.dmp1).decode(),
 #dq": to_base64url_uint(numbers.dmq1).decode(),
 #qi": to_base64url_uint(numbers.iqmp).decode(),
 #

 #lif hasattr(key_obj, "verify"):
                # Public key
 #umbers = key_obj.public_numbers()

 #bj = {
 #kty": "RSA",
 #key_ops": ["verify"],
 #n": to_base64url_uint(numbers.n).decode(),
 #e": to_base64url_uint(numbers.e).decode(),
 #
 #lse:
 #aise InvalidKeyError("Not a public or private key")

 #f as_dict:
 #eturn obj
 #lse:
 #eturn json.dumps(obj)

 #staticmethod
 #ef from_jwk(jwk: str | JWKDict) -> AllowedRSAKeys:
 #ry:
 #f isinstance(jwk, str):
 #bj = json.loads(jwk)
 #lif isinstance(jwk, dict):
 #bj = jwk
 #lse:
 #aise ValueError
 #xcept ValueError:
 #aise InvalidKeyError("Key is not valid JSON") from None

 #f obj.get("kty") != "RSA":
 #aise InvalidKeyError("Not an RSA key") from None

 #f "d" in obj and "e" in obj and "n" in obj:
                # Private key
 #f "oth" in obj:
 #aise InvalidKeyError(
 #Unsupported RSA private key: > 2 primes not supported"
 #

 #ther_props = ["p", "q", "dp", "dq", "qi"]
 #rops_found = [prop in obj for prop in other_props]
 #ny_props_found = any(props_found)

 #f any_props_found and not all(props_found):
 #aise InvalidKeyError(
 #RSA key must include all parameters if any are present besides d"
 # from None

 #ublic_numbers = RSAPublicNumbers(
 #rom_base64url_uint(obj["e"]),
 #rom_base64url_uint(obj["n"]),
 #

 #f any_props_found:
 #umbers = RSAPrivateNumbers(
 #=from_base64url_uint(obj["d"]),
 #=from_base64url_uint(obj["p"]),
 #=from_base64url_uint(obj["q"]),
 #mp1=from_base64url_uint(obj["dp"]),
 #mq1=from_base64url_uint(obj["dq"]),
 #qmp=from_base64url_uint(obj["qi"]),
 #ublic_numbers=public_numbers,
 #
 #lse:
 # = from_base64url_uint(obj["d"])
 #, q = rsa_recover_prime_factors(
 #ublic_numbers.n, d, public_numbers.e
 #

 #umbers = RSAPrivateNumbers(
 #=d,
 #=p,
 #=q,
 #mp1=rsa_crt_dmp1(d, p),
 #mq1=rsa_crt_dmq1(d, q),
 #qmp=rsa_crt_iqmp(p, q),
 #ublic_numbers=public_numbers,
 #

 #eturn numbers.private_key()
 #lif "n" in obj and "e" in obj:
                # Public key
 #eturn RSAPublicNumbers(
 #rom_base64url_uint(obj["e"]),
 #rom_base64url_uint(obj["n"]),
 #.public_key()
 #lse:
 #aise InvalidKeyError("Not a public or private key")

 #ef sign(self, msg: bytes, key: RSAPrivateKey) -> bytes:
 #eturn key.sign(msg, padding.PKCS1v15(), self.hash_alg())

 #ef verify(self, msg: bytes, key: RSAPublicKey, sig: bytes) -> bool:
 #ry:
 #ey.verify(sig, msg, padding.PKCS1v15(), self.hash_alg())
 #eturn True
 #xcept InvalidSignature:
 #eturn False

 #lass ECAlgorithm(Algorithm):
 #""
 #erforms signing and verification operations using
 #CDSA and the specified hash function
 #""

 #HA256: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA256
 #HA384: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA384
 #HA512: ClassVar[type[hashes.HashAlgorithm]] = hashes.SHA512

 #ef __init__(self, hash_alg: type[hashes.HashAlgorithm]) -> None:
 #elf.hash_alg = hash_alg

 #ef prepare_key(self, key: AllowedECKeys | str | bytes) -> AllowedECKeys:
 #f isinstance(key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):
 #eturn key

 #f not isinstance(key, (bytes, str)):
 #aise TypeError("Expecting a PEM-formatted key.")

 #ey_bytes = force_bytes(key)

            # Attempt to load key. We don't know if it's
            # a Signing Key or a Verifying Key, so we try
            # the Verifying Key first.
 #ry:
 #f key_bytes.startswith(b"ecdsa-sha2-"):
 #rypto_key = load_ssh_public_key(key_bytes)
 #lse:
 #rypto_key = load_pem_public_key(key_bytes)  # type: ignore[assignment]
 #xcept ValueError:
 #rypto_key = load_pem_private_key(key_bytes, password=None)  # type: ignore[assignment]

            # Explicit check the key to prevent confusing errors from cryptography
 #f not isinstance(
 #rypto_key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)
 #:
 #aise InvalidKeyError(
 #Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for ECDSA algorithms"
 # from None

 #eturn crypto_key

 #ef sign(self, msg: bytes, key: EllipticCurvePrivateKey) -> bytes:
 #er_sig = key.sign(msg, ECDSA(self.hash_alg()))

 #eturn der_to_raw_signature(der_sig, key.curve)

 #ef verify(self, msg: bytes, key: AllowedECKeys, sig: bytes) -> bool:
 #ry:
 #er_sig = raw_to_der_signature(sig, key.curve)
 #xcept ValueError:
 #eturn False

 #ry:
 #ublic_key = (
 #ey.public_key()
 #f isinstance(key, EllipticCurvePrivateKey)
 #lse key
 #
 #ublic_key.verify(der_sig, msg, ECDSA(self.hash_alg()))
 #eturn True
 #xcept InvalidSignature:
 #eturn False

 #overload
 #staticmethod
 #ef to_jwk(
 #ey_obj: AllowedECKeys, as_dict: Literal[True]
 # -> JWKDict: ...  # pragma: no cover

 #overload
 #staticmethod
 #ef to_jwk(
 #ey_obj: AllowedECKeys, as_dict: Literal[False] = False
 # -> str: ...  # pragma: no cover

 #staticmethod
 #ef to_jwk(key_obj: AllowedECKeys, as_dict: bool = False) -> JWKDict | str:
 #f isinstance(key_obj, EllipticCurvePrivateKey):
 #ublic_numbers = key_obj.public_key().public_numbers()
 #lif isinstance(key_obj, EllipticCurvePublicKey):
 #ublic_numbers = key_obj.public_numbers()
 #lse:
 #aise InvalidKeyError("Not a public or private key")

 #f isinstance(key_obj.curve, SECP256R1):
 #rv = "P-256"
 #lif isinstance(key_obj.curve, SECP384R1):
 #rv = "P-384"
 #lif isinstance(key_obj.curve, SECP521R1):
 #rv = "P-521"
 #lif isinstance(key_obj.curve, SECP256K1):
 #rv = "secp256k1"
 #lse:
 #aise InvalidKeyError(f"Invalid curve: {key_obj.curve}")

 #bj: dict[str, Any] = {
 #kty": "EC",
 #crv": crv,
 #x": to_base64url_uint(
 #ublic_numbers.x,
 #it_length=key_obj.curve.key_size,
 #.decode(),
 #y": to_base64url_uint(
 #ublic_numbers.y,
 #it_length=key_obj.curve.key_size,
 #.decode(),
 #

 #f isinstance(key_obj, EllipticCurvePrivateKey):
 #bj["d"] = to_base64url_uint(
 #ey_obj.private_numbers().private_value,
 #it_length=key_obj.curve.key_size,
 #.decode()

 #f as_dict:
 #eturn obj
 #lse:
 #eturn json.dumps(obj)

 #staticmethod
 #ef from_jwk(jwk: str | JWKDict) -> AllowedECKeys:
 #ry:
 #f isinstance(jwk, str):
 #bj = json.loads(jwk)
 #lif isinstance(jwk, dict):
 #bj = jwk
 #lse:
 #aise ValueError
 #xcept ValueError:
 #aise InvalidKeyError("Key is not valid JSON") from None

 #f obj.get("kty") != "EC":
 #aise InvalidKeyError("Not an Elliptic curve key") from None

 #f "x" not in obj or "y" not in obj:
 #aise InvalidKeyError("Not an Elliptic curve key") from None

 # = base64url_decode(obj.get("x"))
 # = base64url_decode(obj.get("y"))

 #urve = obj.get("crv")
 #urve_obj: EllipticCurve

 #f curve == "P-256":
 #f len(x) == len(y) == 32:
 #urve_obj = SECP256R1()
 #lse:
 #aise InvalidKeyError(
 #Coords should be 32 bytes for curve P-256"
 # from None
 #lif curve == "P-384":
 #f len(x) == len(y) == 48:
 #urve_obj = SECP384R1()
 #lse:
 #aise InvalidKeyError(
 #Coords should be 48 bytes for curve P-384"
 # from None
 #lif curve == "P-521":
 #f len(x) == len(y) == 66:
 #urve_obj = SECP521R1()
 #lse:
 #aise InvalidKeyError(
 #Coords should be 66 bytes for curve P-521"
 # from None
 #lif curve == "secp256k1":
 #f len(x) == len(y) == 32:
 #urve_obj = SECP256K1()
 #lse:
 #aise InvalidKeyError(
 #Coords should be 32 bytes for curve secp256k1"
 #
 #lse:
 #aise InvalidKeyError(f"Invalid curve: {curve}")

 #ublic_numbers = EllipticCurvePublicNumbers(
 #=int.from_bytes(x, byteorder="big"),
 #=int.from_bytes(y, byteorder="big"),
 #urve=curve_obj,
 #

 #f "d" not in obj:
 #eturn public_numbers.public_key()

 # = base64url_decode(obj.get("d"))
 #f len(d) != len(x):
 #aise InvalidKeyError(
 #D should be {} bytes for curve {}", len(x), curve
 #

 #eturn EllipticCurvePrivateNumbers(
 #nt.from_bytes(d, byteorder="big"), public_numbers
 #.private_key()

 #lass RSAPSSAlgorithm(RSAAlgorithm):
 #""
 #erforms a signature using RSASSA-PSS with MGF1
 #""

 #ef sign(self, msg: bytes, key: RSAPrivateKey) -> bytes:
 #eturn key.sign(
 #sg,
 #adding.PSS(
 #gf=padding.MGF1(self.hash_alg()),
 #alt_length=self.hash_alg().digest_size,
 #,
 #elf.hash_alg(),
 #

 #ef verify(self, msg: bytes, key: RSAPublicKey, sig: bytes) -> bool:
 #ry:
 #ey.verify(
 #ig,
 #sg,
 #adding.PSS(
 #gf=padding.MGF1(self.hash_alg()),
 #alt_length=self.hash_alg().digest_size,
 #,
 #elf.hash_alg(),
 #
 #eturn True
 #xcept InvalidSignature:
 #eturn False

 #lass OKPAlgorithm(Algorithm):
 #""
 #erforms signing and verification operations using EdDSA

 #his class requires ``cryptography>=2.6`` to be installed.
 #""

 #ef __init__(self, **kwargs: Any) -> None:
 #ass

 #ef prepare_key(self, key: AllowedOKPKeys | str | bytes) -> AllowedOKPKeys:
 #f isinstance(key, (bytes, str)):
 #ey_str = key.decode("utf-8") if isinstance(key, bytes) else key
 #ey_bytes = key.encode("utf-8") if isinstance(key, str) else key

 #f "-----BEGIN PUBLIC" in key_str:
 #ey = load_pem_public_key(key_bytes)  # type: ignore[assignment]
 #lif "-----BEGIN PRIVATE" in key_str:
 #ey = load_pem_private_key(key_bytes, password=None)  # type: ignore[assignment]
 #lif key_str[0:4] == "ssh-":
 #ey = load_ssh_public_key(key_bytes)  # type: ignore[assignment]

            # Explicit check the key to prevent confusing errors from cryptography
 #f not isinstance(
 #ey,
 #Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey),
 #:
 #aise InvalidKeyError(
 #Expecting a EllipticCurvePrivateKey/EllipticCurvePublicKey. Wrong key provided for EdDSA algorithms"
 #

 #eturn key

 #ef sign(
 #elf, msg: str | bytes, key: Ed25519PrivateKey | Ed448PrivateKey
 # -> bytes:
 #""
 #ign a message ``msg`` using the EdDSA private key ``key``
 #param str|bytes msg: Message to sign
 #param Ed25519PrivateKey}Ed448PrivateKey key: A :class:`.Ed25519PrivateKey`
 #r :class:`.Ed448PrivateKey` isinstance
 #return bytes signature: The signature, as bytes
 #""
 #sg_bytes = msg.encode("utf-8") if isinstance(msg, str) else msg
 #eturn key.sign(msg_bytes)

 #ef verify(
 #elf, msg: str | bytes, key: AllowedOKPKeys, sig: str | bytes
 # -> bool:
 #""
 #erify a given ``msg`` against a signature ``sig`` using the EdDSA key ``key``

 #param str|bytes sig: EdDSA signature to check ``msg`` against
 #param str|bytes msg: Message to sign
 #param Ed25519PrivateKey|Ed25519PublicKey|Ed448PrivateKey|Ed448PublicKey key:
 # private or public EdDSA key instance
 #return bool verified: True if signature is valid, False if not.
 #""
 #ry:
 #sg_bytes = msg.encode("utf-8") if isinstance(msg, str) else msg
 #ig_bytes = sig.encode("utf-8") if isinstance(sig, str) else sig

 #ublic_key = (
 #ey.public_key()
 #f isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey))
 #lse key
 #
 #ublic_key.verify(sig_bytes, msg_bytes)
 #eturn True  # If no exception was raised, the signature is valid.
 #xcept InvalidSignature:
 #eturn False

 #overload
 #staticmethod
 #ef to_jwk(
 #ey: AllowedOKPKeys, as_dict: Literal[True]
 # -> JWKDict: ...  # pragma: no cover

 #overload
 #staticmethod
 #ef to_jwk(
 #ey: AllowedOKPKeys, as_dict: Literal[False] = False
 # -> str: ...  # pragma: no cover

 #staticmethod
 #ef to_jwk(key: AllowedOKPKeys, as_dict: bool = False) -> JWKDict | str:
 #f isinstance(key, (Ed25519PublicKey, Ed448PublicKey)):
 # = key.public_bytes(
 #ncoding=Encoding.Raw,
 #ormat=PublicFormat.Raw,
 #
 #rv = "Ed25519" if isinstance(key, Ed25519PublicKey) else "Ed448"

 #bj = {
 #x": base64url_encode(force_bytes(x)).decode(),
 #kty": "OKP",
 #crv": crv,
 #

 #f as_dict:
 #eturn obj
 #lse:
 #eturn json.dumps(obj)

 #f isinstance(key, (Ed25519PrivateKey, Ed448PrivateKey)):
 # = key.private_bytes(
 #ncoding=Encoding.Raw,
 #ormat=PrivateFormat.Raw,
 #ncryption_algorithm=NoEncryption(),
 #

 # = key.public_key().public_bytes(
 #ncoding=Encoding.Raw,
 #ormat=PublicFormat.Raw,
 #

 #rv = "Ed25519" if isinstance(key, Ed25519PrivateKey) else "Ed448"
 #bj = {
 #x": base64url_encode(force_bytes(x)).decode(),
 #d": base64url_encode(force_bytes(d)).decode(),
 #kty": "OKP",
 #crv": crv,
 #

 #f as_dict:
 #eturn obj
 #lse:
 #eturn json.dumps(obj)

 #aise InvalidKeyError("Not a public or private key")

 #staticmethod
 #ef from_jwk(jwk: str | JWKDict) -> AllowedOKPKeys:
 #ry:
 #f isinstance(jwk, str):
 #bj = json.loads(jwk)
 #lif isinstance(jwk, dict):
 #bj = jwk
 #lse:
 #aise ValueError
 #xcept ValueError:
 #aise InvalidKeyError("Key is not valid JSON") from None

 #f obj.get("kty") != "OKP":
 #aise InvalidKeyError("Not an Octet Key Pair")

 #urve = obj.get("crv")
 #f curve != "Ed25519" and curve != "Ed448":
 #aise InvalidKeyError(f"Invalid curve: {curve}")

 #f "x" not in obj:
 #aise InvalidKeyError('OKP should have "x" parameter')
 # = base64url_decode(obj.get("x"))

 #ry:
 #f "d" not in obj:
 #f curve == "Ed25519":
 #eturn Ed25519PublicKey.from_public_bytes(x)
 #eturn Ed448PublicKey.from_public_bytes(x)
 # = base64url_decode(obj.get("d"))
 #f curve == "Ed25519":
 #eturn Ed25519PrivateKey.from_private_bytes(d)
 #eturn Ed448PrivateKey.from_private_bytes(d)
 #xcept ValueError as err:
 #aise InvalidKeyError("Invalid key parameter") from err
