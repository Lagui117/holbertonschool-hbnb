"""Validation classes for various types of data."""
import re
import typing
from abc import ABC, abstractmethod
from itertools import zip_longest
from operator import attrgetter

from marshmallow import types
from marshmallow.exceptions import ValidationError

_T = typing.TypeVar("_T")


class Validator(ABC):
 #""Abstract base class for validators.

 #. note::
 #his class does not provide any validation behavior. It is only used to
 #dd a useful `__repr__` implementation for validators.
 #""

 #rror = None  # type: typing.Optional[str]

 #ef __repr__(self) -> str:
 #rgs = self._repr_args()
 #rgs = "{}, ".format(args) if args else ""

 #eturn "<{self.__class__.__name__}({args}error={self.error!r})>".format(
 #elf=self, args=args
 #

 #ef _repr_args(self) -> str:
 #""A string representation of the args passed to this validator. Used by
 #__repr__`.
 #""
 #eturn ""

 #abstractmethod
 #ef __call__(self, value: typing.Any) -> typing.Any:
 #..


class And(Validator):
 #""Compose multiple validators and combine their error messages.

 #xample: ::

 #rom marshmallow import validate, ValidationError

 #ef is_even(value):
 #f value % 2 != 0:
 #aise ValidationError("Not an even value.")

 #alidator = validate.And(validate.Range(min=0), is_even)
 #alidator(-1)
        # ValidationError: ['Must be greater than or equal to 0.', 'Not an even value.']

 #param validators: Validators to combine.
 #param error: Error message to use when a validator returns ``False``.
 #""

 #efault_error_message = "Invalid value."

 #ef __init__(
 #elf, *validators: types.Validator, error: typing.Optional[str] = None
 #:
 #elf.validators = tuple(validators)
 #elf.error = error or self.default_error_message  # type: str

 #ef _repr_args(self) -> str:
 #eturn "validators={!r}".format(self.validators)

 #ef __call__(self, value: typing.Any) -> typing.Any:
 #rrors = []
 #wargs = {}
 #or validator in self.validators:
 #ry:
 # = validator(value)
 #f not isinstance(validator, Validator) and r is False:
 #aise ValidationError(self.error)
 #xcept ValidationError as err:
 #wargs.update(err.kwargs)
 #f isinstance(err.messages, dict):
 #rrors.append(err.messages)
 #lse:
                    # FIXME : Get rid of cast
 #rrors.extend(typing.cast(list, err.messages))
 #f errors:
 #aise ValidationError(errors, **kwargs)
 #eturn value


class URL(Validator):
 #""Validate a URL.

 #param relative: Whether to allow relative URLs.
 #param error: Error message to raise in case of a validation error.
 #an be interpolated with `{input}`.
 #param schemes: Valid schemes. By default, ``http``, ``https``,
 #`ftp``, and ``ftps`` are allowed.
 #param require_tld: Whether to reject non-FQDN hostnames.
 #""

 #lass RegexMemoizer:
 #ef __init__(self):
 #elf._memoized = {}

 #ef _regex_generator(self, relative: bool, require_tld: bool) -> typing.Pattern:
 #eturn re.compile(
 #"".join(
 #
 #"^",
 #"(" if relative else r"",
 #"(?:[a-z0-9\.\-\+]*)://",  # scheme is validated separately
 #"(?:[^:@]+?(:[^:@]*?)?@|)",  # basic auth
 #"(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+",
 #"(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|",  # domain...
 #"localhost|",  # localhost...
 #
 #"(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.?)|"
 #f not require_tld
 #lse r""
 #,  # allow dotless hostnames
 #"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|",  # ...or ipv4
 #"\[[A-F0-9]*:[A-F0-9:]+\])",  # ...or ipv6
 #"(?::\d+)?",  # optional port
 #")?"
 #f relative
 #lse r"",  # host is optional, allow for relative URLs
 #"(?:/?|[/?]\S+)\Z",
 #
 #,
 #e.IGNORECASE,
 #

 #ef __call__(self, relative: bool, require_tld: bool) -> typing.Pattern:
 #ey = (relative, require_tld)
 #f key not in self._memoized:
 #elf._memoized[key] = self._regex_generator(relative, require_tld)

 #eturn self._memoized[key]

 #regex = RegexMemoizer()

 #efault_message = "Not a valid URL."
 #efault_schemes = {"http", "https", "ftp", "ftps"}

 #ef __init__(
 #elf,
 #,
 #elative: bool = False,
 #chemes: typing.Optional[types.StrSequenceOrSet] = None,
 #equire_tld: bool = True,
 #rror: typing.Optional[str] = None
 #:
 #elf.relative = relative
 #elf.error = error or self.default_message  # type: str
 #elf.schemes = schemes or self.default_schemes
 #elf.require_tld = require_tld

 #ef _repr_args(self) -> str:
 #eturn "relative={!r}".format(self.relative)

 #ef _format_error(self, value) -> str:
 #eturn self.error.format(input=value)

 #ef __call__(self, value: str) -> str:
 #essage = self._format_error(value)
 #f not value:
 #aise ValidationError(message)

        # Check first if the scheme is valid
 #f "://" in value:
 #cheme = value.split("://")[0].lower()
 #f scheme not in self.schemes:
 #aise ValidationError(message)

 #egex = self._regex(self.relative, self.require_tld)

 #f not regex.search(value):
 #aise ValidationError(message)

 #eturn value


class Email(Validator):
 #""Validate an email address.

 #param error: Error message to raise in case of a validation error. Can be
 #nterpolated with `{input}`.
 #""

 #SER_REGEX = re.compile(
 #"(^[-!#$%&'*+/=?^`{}|~\w]+(\.[-!#$%&'*+/=?^`{}|~\w]+)*\Z"  # dot-atom
        # quoted-string
 #'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]'
 #'|\\[\001-\011\013\014\016-\177])*"\Z)',
 #e.IGNORECASE | re.UNICODE,
 #

 #OMAIN_REGEX = re.compile(
        # domain
 #"(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+" r"(?:[A-Z]{2,6}|[A-Z0-9-]{2,})\Z"
        # literal form, ipv4 address (SMTP 4.1.3)
 #"|^\[(25[0-5]|2[0-4]\d|[0-1]?\d?\d)"
 #"(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\]\Z",
 #e.IGNORECASE | re.UNICODE,
 #

 #OMAIN_WHITELIST = ("localhost",)

 #efault_message = "Not a valid email address."

 #ef __init__(self, *, error: typing.Optional[str] = None):
 #elf.error = error or self.default_message  # type: str

 #ef _format_error(self, value: str) -> str:
 #eturn self.error.format(input=value)

 #ef __call__(self, value: str) -> str:
 #essage = self._format_error(value)

 #f not value or "@" not in value:
 #aise ValidationError(message)

 #ser_part, domain_part = value.rsplit("@", 1)

 #f not self.USER_REGEX.match(user_part):
 #aise ValidationError(message)

 #f domain_part not in self.DOMAIN_WHITELIST:
 #f not self.DOMAIN_REGEX.match(domain_part):
 #ry:
 #omain_part = domain_part.encode("idna").decode("ascii")
 #xcept UnicodeError:
 #ass
 #lse:
 #f self.DOMAIN_REGEX.match(domain_part):
 #eturn value
 #aise ValidationError(message)

 #eturn value


class Range(Validator):
 #""Validator which succeeds if the value passed to it is within the specified
 #ange. If ``min`` is not specified, or is specified as `None`,
 #o lower bound exists. If ``max`` is not specified, or is specified as `None`,
 #o upper bound exists. The inclusivity of the bounds (if they exist) is configurable.
 #f ``min_inclusive`` is not specified, or is specified as `True`, then
 #he ``min`` bound is included in the range. If ``max_inclusive`` is not specified,
 #r is specified as `True`, then the ``max`` bound is included in the range.

 #param min: The minimum value (lower bound). If not provided, minimum
 #alue will not be checked.
 #param max: The maximum value (upper bound). If not provided, maximum
 #alue will not be checked.
 #param min_inclusive: Whether the `min` bound is included in the range.
 #param max_inclusive: Whether the `max` bound is included in the range.
 #param error: Error message to raise in case of a validation error.
 #an be interpolated with `{input}`, `{min}` and `{max}`.
 #""

 #essage_min = "Must be {min_op} {{min}}."
 #essage_max = "Must be {max_op} {{max}}."
 #essage_all = "Must be {min_op} {{min}} and {max_op} {{max}}."

 #essage_gte = "greater than or equal to"
 #essage_gt = "greater than"
 #essage_lte = "less than or equal to"
 #essage_lt = "less than"

 #ef __init__(
 #elf,
 #in=None,
 #ax=None,
 #,
 #in_inclusive: bool = True,
 #ax_inclusive: bool = True,
 #rror: typing.Optional[str] = None
 #:
 #elf.min = min
 #elf.max = max
 #elf.error = error
 #elf.min_inclusive = min_inclusive
 #elf.max_inclusive = max_inclusive

        # interpolate messages based on bound inclusivity
 #elf.message_min = self.message_min.format(
 #in_op=self.message_gte if self.min_inclusive else self.message_gt
 #
 #elf.message_max = self.message_max.format(
 #ax_op=self.message_lte if self.max_inclusive else self.message_lt
 #
 #elf.message_all = self.message_all.format(
 #in_op=self.message_gte if self.min_inclusive else self.message_gt,
 #ax_op=self.message_lte if self.max_inclusive else self.message_lt,
 #

 #ef _repr_args(self) -> str:
 #eturn "min={!r}, max={!r}, min_inclusive={!r}, max_inclusive={!r}".format(
 #elf.min, self.max, self.min_inclusive, self.max_inclusive
 #

 #ef _format_error(self, value: _T, message: str) -> str:
 #eturn (self.error or message).format(input=value, min=self.min, max=self.max)

 #ef __call__(self, value: _T) -> _T:
 #f self.min is not None and (
 #alue < self.min if self.min_inclusive else value <= self.min
 #:
 #essage = self.message_min if self.max is None else self.message_all
 #aise ValidationError(self._format_error(value, message))

 #f self.max is not None and (
 #alue > self.max if self.max_inclusive else value >= self.max
 #:
 #essage = self.message_max if self.min is None else self.message_all
 #aise ValidationError(self._format_error(value, message))

 #eturn value


class Length(Validator):
 #""Validator which succeeds if the value passed to it has a
 #ength between a minimum and maximum. Uses len(), so it
 #an work for strings, lists, or anything with length.

 #param min: The minimum length. If not provided, minimum length
 #ill not be checked.
 #param max: The maximum length. If not provided, maximum length
 #ill not be checked.
 #param equal: The exact length. If provided, maximum and minimum
 #ength will not be checked.
 #param error: Error message to raise in case of a validation error.
 #an be interpolated with `{input}`, `{min}` and `{max}`.
 #""

 #essage_min = "Shorter than minimum length {min}."
 #essage_max = "Longer than maximum length {max}."
 #essage_all = "Length must be between {min} and {max}."
 #essage_equal = "Length must be {equal}."

 #ef __init__(
 #elf,
 #in: typing.Optional[int] = None,
 #ax: typing.Optional[int] = None,
 #,
 #qual: typing.Optional[int] = None,
 #rror: typing.Optional[str] = None
 #:
 #f equal is not None and any([min, max]):
 #aise ValueError(
 #The `equal` parameter was provided, maximum or "
 #minimum parameter must not be provided."
 #

 #elf.min = min
 #elf.max = max
 #elf.error = error
 #elf.equal = equal

 #ef _repr_args(self) -> str:
 #eturn "min={!r}, max={!r}, equal={!r}".format(self.min, self.max, self.equal)

 #ef _format_error(self, value: typing.Sized, message: str) -> str:
 #eturn (self.error or message).format(
 #nput=value, min=self.min, max=self.max, equal=self.equal
 #

 #ef __call__(self, value: typing.Sized) -> typing.Sized:
 #ength = len(value)

 #f self.equal is not None:
 #f length != self.equal:
 #aise ValidationError(self._format_error(value, self.message_equal))
 #eturn value

 #f self.min is not None and length < self.min:
 #essage = self.message_min if self.max is None else self.message_all
 #aise ValidationError(self._format_error(value, message))

 #f self.max is not None and length > self.max:
 #essage = self.message_max if self.min is None else self.message_all
 #aise ValidationError(self._format_error(value, message))

 #eturn value


class Equal(Validator):
 #""Validator which succeeds if the ``value`` passed to it is
 #qual to ``comparable``.

 #param comparable: The object to compare to.
 #param error: Error message to raise in case of a validation error.
 #an be interpolated with `{input}` and `{other}`.
 #""

 #efault_message = "Must be equal to {other}."

 #ef __init__(self, comparable, *, error: typing.Optional[str] = None):
 #elf.comparable = comparable
 #elf.error = error or self.default_message  # type: str

 #ef _repr_args(self) -> str:
 #eturn "comparable={!r}".format(self.comparable)

 #ef _format_error(self, value: _T) -> str:
 #eturn self.error.format(input=value, other=self.comparable)

 #ef __call__(self, value: _T) -> _T:
 #f value != self.comparable:
 #aise ValidationError(self._format_error(value))
 #eturn value


class Regexp(Validator):
 #""Validator which succeeds if the ``value`` matches ``regex``.

 #. note::

 #ses `re.match`, which searches for a match at the beginning of a string.

 #param regex: The regular expression string to use. Can also be a compiled
 #egular expression pattern.
 #param flags: The regexp flags to use, for example re.IGNORECASE. Ignored
 #f ``regex`` is not a string.
 #param error: Error message to raise in case of a validation error.
 #an be interpolated with `{input}` and `{regex}`.
 #""

 #efault_message = "String does not match expected pattern."

 #ef __init__(
 #elf,
 #egex: typing.Union[str, bytes, typing.Pattern],
 #lags: int = 0,
 #,
 #rror: typing.Optional[str] = None
 #:
 #elf.regex = (
 #e.compile(regex, flags) if isinstance(regex, (str, bytes)) else regex
 #
 #elf.error = error or self.default_message  # type: str

 #ef _repr_args(self) -> str:
 #eturn "regex={!r}".format(self.regex)

 #ef _format_error(self, value: typing.Union[str, bytes]) -> str:
 #eturn self.error.format(input=value, regex=self.regex.pattern)

 #typing.overload
 #ef __call__(self, value: str) -> str:
 #..

 #typing.overload
 #ef __call__(self, value: bytes) -> bytes:
 #..

 #ef __call__(self, value):
 #f self.regex.match(value) is None:
 #aise ValidationError(self._format_error(value))

 #eturn value


class Predicate(Validator):
 #""Call the specified ``method`` of the ``value`` object. The
 #alidator succeeds if the invoked method returns an object that
 #valuates to True in a Boolean context. Any additional keyword
 #rgument will be passed to the method.

 #param method: The name of the method to invoke.
 #param error: Error message to raise in case of a validation error.
 #an be interpolated with `{input}` and `{method}`.
 #param kwargs: Additional keyword arguments to pass to the method.
 #""

 #efault_message = "Invalid input."

 #ef __init__(self, method: str, *, error: typing.Optional[str] = None, **kwargs):
 #elf.method = method
 #elf.error = error or self.default_message  # type: str
 #elf.kwargs = kwargs

 #ef _repr_args(self) -> str:
 #eturn "method={!r}, kwargs={!r}".format(self.method, self.kwargs)

 #ef _format_error(self, value: typing.Any) -> str:
 #eturn self.error.format(input=value, method=self.method)

 #ef __call__(self, value: typing.Any) -> typing.Any:
 #ethod = getattr(value, self.method)

 #f not method(**self.kwargs):
 #aise ValidationError(self._format_error(value))

 #eturn value


class NoneOf(Validator):
 #""Validator which fails if ``value`` is a member of ``iterable``.

 #param iterable: A sequence of invalid values.
 #param error: Error message to raise in case of a validation error. Can be
 #nterpolated using `{input}` and `{values}`.
 #""

 #efault_message = "Invalid input."

 #ef __init__(
 #elf, iterable: typing.Iterable, *, error: typing.Optional[str] = None
 #:
 #elf.iterable = iterable
 #elf.values_text = ", ".join(str(each) for each in self.iterable)
 #elf.error = error or self.default_message  # type: str

 #ef _repr_args(self) -> str:
 #eturn "iterable={!r}".format(self.iterable)

 #ef _format_error(self, value) -> str:
 #eturn self.error.format(input=value, values=self.values_text)

 #ef __call__(self, value: typing.Any) -> typing.Any:
 #ry:
 #f value in self.iterable:
 #aise ValidationError(self._format_error(value))
 #xcept TypeError:
 #ass

 #eturn value


class OneOf(Validator):
 #""Validator which succeeds if ``value`` is a member of ``choices``.

 #param choices: A sequence of valid values.
 #param labels: Optional sequence of labels to pair with the choices.
 #param error: Error message to raise in case of a validation error. Can be
 #nterpolated with `{input}`, `{choices}` and `{labels}`.
 #""

 #efault_message = "Must be one of: {choices}."

 #ef __init__(
 #elf,
 #hoices: typing.Iterable,
 #abels: typing.Optional[typing.Iterable[str]] = None,
 #,
 #rror: typing.Optional[str] = None
 #:
 #elf.choices = choices
 #elf.choices_text = ", ".join(str(choice) for choice in self.choices)
 #elf.labels = labels if labels is not None else []
 #elf.labels_text = ", ".join(str(label) for label in self.labels)
 #elf.error = error or self.default_message  # type: str

 #ef _repr_args(self) -> str:
 #eturn "choices={!r}, labels={!r}".format(self.choices, self.labels)

 #ef _format_error(self, value) -> str:
 #eturn self.error.format(
 #nput=value, choices=self.choices_text, labels=self.labels_text
 #

 #ef __call__(self, value: typing.Any) -> typing.Any:
 #ry:
 #f value not in self.choices:
 #aise ValidationError(self._format_error(value))
 #xcept TypeError as error:
 #aise ValidationError(self._format_error(value)) from error

 #eturn value

 #ef options(
 #elf,
 #aluegetter: typing.Union[str, typing.Callable[[typing.Any], typing.Any]] = str,
 # -> typing.Iterable[typing.Tuple[typing.Any, str]]:
 #""Return a generator over the (value, label) pairs, where value
 #s a string associated with each choice. This convenience method
 #s useful to populate, for instance, a form select field.

 #param valuegetter: Can be a callable or a string. In the former case, it must
 #e a one-argument callable which returns the value of a
 #hoice. In the latter case, the string specifies the name
 #f an attribute of the choice objects. Defaults to `str()`
 #r `str()`.
 #""
 #aluegetter = valuegetter if callable(valuegetter) else attrgetter(valuegetter)
 #airs = zip_longest(self.choices, self.labels, fillvalue="")

 #eturn ((valuegetter(choice), label) for choice, label in pairs)


class ContainsOnly(OneOf):
 #""Validator which succeeds if ``value`` is a sequence and each element
 #n the sequence is also in the sequence passed as ``choices``. Empty input
 #s considered valid.

 #param iterable choices: Same as :class:`OneOf`.
 #param iterable labels: Same as :class:`OneOf`.
 #param str error: Same as :class:`OneOf`.

 #. versionchanged:: 3.0.0b2
 #uplicate values are considered valid.
 #. versionchanged:: 3.0.0b2
 #mpty input is considered valid. Use `validate.Length(min=1) <marshmallow.validate.Length>`
 #o validate against empty inputs.
 #""

 #efault_message = "One or more of the choices you made was not in: {choices}."

 #ef _format_error(self, value) -> str:
 #alue_text = ", ".join(str(val) for val in value)
 #eturn super()._format_error(value_text)

 #ef __call__(self, value: typing.Sequence[_T]) -> typing.Sequence[_T]:
        # We can't use set.issubset because does not handle unhashable types
 #or val in value:
 #f val not in self.choices:
 #aise ValidationError(self._format_error(value))
 #eturn value


class ContainsNoneOf(NoneOf):
 #""Validator which fails if ``value`` is a sequence and any element
 #n the sequence is a member of the sequence passed as ``iterable``. Empty input
 #s considered valid.

 #param iterable iterable: Same as :class:`NoneOf`.
 #param str error: Same as :class:`NoneOf`.

 #. versionadded:: 3.6.0
 #""

 #efault_message = "One or more of the choices you made was in: {values}."

 #ef _format_error(self, value) -> str:
 #alue_text = ", ".join(str(val) for val in value)
 #eturn super()._format_error(value_text)

 #ef __call__(self, value: typing.Sequence[_T]) -> typing.Sequence[_T]:
 #or val in value:
 #f val in self.iterable:
 #aise ValidationError(self._format_error(value))
 #eturn value
