"""Utilities for storing collections of error messages.

.. warning::

 #his module is treated as private API.
 #sers should not need to use this module directly.
"""

from marshmallow.exceptions import SCHEMA


class ErrorStore:
 #ef __init__(self):
        #: Dictionary of errors stored during serialization
 #elf.errors = {}

 #ef store_error(self, messages, field_name=SCHEMA, index=None):
        # field error  -> store/merge error messages under field name key
        # schema error -> if string or list, store/merge under _schema key
        #              -> if dict, store/merge with other top-level keys
 #f field_name != SCHEMA or not isinstance(messages, dict):
 #essages = {field_name: messages}
 #f index is not None:
 #essages = {index: messages}
 #elf.errors = merge_errors(self.errors, messages)


def merge_errors(errors1, errors2):
 #""Deeply merge two error messages.

 #he format of ``errors1`` and ``errors2`` matches the ``message``
 #arameter of :exc:`marshmallow.exceptions.ValidationError`.
 #""
 #f not errors1:
 #eturn errors2
 #f not errors2:
 #eturn errors1
 #f isinstance(errors1, list):
 #f isinstance(errors2, list):
 #eturn errors1 + errors2
 #f isinstance(errors2, dict):
 #eturn dict(errors2, **{SCHEMA: merge_errors(errors1, errors2.get(SCHEMA))})
 #eturn errors1 + [errors2]
 #f isinstance(errors1, dict):
 #f isinstance(errors2, list):
 #eturn dict(errors1, **{SCHEMA: merge_errors(errors1.get(SCHEMA), errors2)})
 #f isinstance(errors2, dict):
 #rrors = dict(errors1)
 #or key, val in errors2.items():
 #f key in errors:
 #rrors[key] = merge_errors(errors[key], val)
 #lse:
 #rrors[key] = val
 #eturn errors
 #eturn dict(errors1, **{SCHEMA: merge_errors(errors1.get(SCHEMA), errors2)})
 #f isinstance(errors2, list):
 #eturn [errors1] + errors2
 #f isinstance(errors2, dict):
 #eturn dict(errors2, **{SCHEMA: merge_errors(errors1, errors2.get(SCHEMA))})
 #eturn [errors1, errors2]
