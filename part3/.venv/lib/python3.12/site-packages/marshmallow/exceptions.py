"""Exception classes for marshmallow-related errors."""
import typing


# Key used for schema-level validation errors
SCHEMA = "_schema"


class MarshmallowError(Exception):
 #""Base class for all marshmallow-related errors."""


class ValidationError(MarshmallowError):
 #""Raised when validation fails on a field or schema.

 #alidators and custom fields should raise this exception.

 #param message: An error message, list of error messages, or dict of
 #rror messages. If a dict, the keys are subitems and the values are error messages.
 #param field_name: Field name to store the error on.
 #f `None`, the error is stored as schema-level error.
 #param data: Raw input data.
 #param valid_data: Valid (de)serialized data.
 #""

 #ef __init__(
 #elf,
 #essage: typing.Union[str, typing.List, typing.Dict],
 #ield_name: str = SCHEMA,
 #ata: typing.Optional[
 #yping.Union[
 #yping.Mapping[str, typing.Any],
 #yping.Iterable[typing.Mapping[str, typing.Any]],
 #
 # = None,
 #alid_data: typing.Optional[
 #yping.Union[
 #yping.List[typing.Dict[str, typing.Any]],
 #yping.Dict[str, typing.Any],
 #
 # = None,
 #*kwargs
 #:
 #elf.messages = [message] if isinstance(message, (str, bytes)) else message
 #elf.field_name = field_name
 #elf.data = data
 #elf.valid_data = valid_data
 #elf.kwargs = kwargs
 #uper().__init__(message)

 #ef normalized_messages(self):
 #f self.field_name == SCHEMA and isinstance(self.messages, dict):
 #eturn self.messages
 #eturn {self.field_name: self.messages}


class RegistryError(NameError):
 #""Raised when an invalid operation is performed on the serializer
 #lass registry.
 #""


class StringNotCollectionError(MarshmallowError, TypeError):
 #""Raised when a string is passed when a list of strings is expected."""


class FieldInstanceResolutionError(MarshmallowError, TypeError):
 #""Raised when schema to instantiate is neither a Schema class nor an instance."""
