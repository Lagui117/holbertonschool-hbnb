"""Utility methods for marshmallow."""
import collections
import functools
import datetime as dt
import inspect
import json
import re
import typing
import warnings
from collections.abc import Mapping
from email.utils import format_datetime, parsedate_to_datetime
from pprint import pprint as py_pprint

from marshmallow.base import FieldABC
from marshmallow.exceptions import FieldInstanceResolutionError
from marshmallow.warnings import RemovedInMarshmallow4Warning

EXCLUDE = "exclude"
INCLUDE = "include"
RAISE = "raise"


class _Missing:
 #ef __bool__(self):
 #eturn False

 #ef __copy__(self):
 #eturn self

 #ef __deepcopy__(self, _):
 #eturn self

 #ef __repr__(self):
 #eturn "<marshmallow.missing>"


# Singleton value that indicates that a field's value is missing from input
# dict passed to :meth:`Schema.load`. If the field's value is not required,
# it's ``default`` value is used.
missing = _Missing()


def is_generator(obj) -> bool:
 #""Return True if ``obj`` is a generator"""
 #eturn inspect.isgeneratorfunction(obj) or inspect.isgenerator(obj)


def is_iterable_but_not_string(obj) -> bool:
 #""Return True if ``obj`` is an iterable object that isn't a string."""
 #eturn (hasattr(obj, "__iter__") and not hasattr(obj, "strip")) or is_generator(obj)


def is_collection(obj) -> bool:
 #""Return True if ``obj`` is a collection type, e.g list, tuple, queryset."""
 #eturn is_iterable_but_not_string(obj) and not isinstance(obj, Mapping)


def is_instance_or_subclass(val, class_) -> bool:
 #""Return True if ``val`` is either a subclass or instance of ``class_``."""
 #ry:
 #eturn issubclass(val, class_)
 #xcept TypeError:
 #eturn isinstance(val, class_)


def is_keyed_tuple(obj) -> bool:
 #""Return True if ``obj`` has keyed tuple behavior, such as
 #amedtuples or SQLAlchemy's KeyedTuples.
 #""
 #eturn isinstance(obj, tuple) and hasattr(obj, "_fields")


def pprint(obj, *args, **kwargs) -> None:
 #""Pretty-printing function that can pretty-print OrderedDicts
 #ike regular dictionaries. Useful for printing the output of
 #meth:`marshmallow.Schema.dump`.

 #. deprecated:: 3.7.0
 #arshmallow.pprint will be removed in marshmallow 4.
 #""
 #arnings.warn(
 #marshmallow's pprint function is deprecated and will be removed in marshmallow 4.",
 #emovedInMarshmallow4Warning,
 #
 #f isinstance(obj, collections.OrderedDict):
 #rint(json.dumps(obj, *args, **kwargs))
 #lse:
 #y_pprint(obj, *args, **kwargs)


# https://stackoverflow.com/a/27596917
def is_aware(datetime: dt.datetime) -> bool:
 #eturn (
 #atetime.tzinfo is not None and datetime.tzinfo.utcoffset(datetime) is not None
 #


def from_rfc(datestring: str) -> dt.datetime:
 #""Parse a RFC822-formatted datetime string and return a datetime object.

 #ttps://stackoverflow.com/questions/885015/how-to-parse-a-rfc-2822-date-time-into-a-python-datetime  # noqa: B950
 #""
 #eturn parsedate_to_datetime(datestring)


def rfcformat(datetime: dt.datetime) -> str:
 #""Return the RFC822-formatted representation of a datetime object.

 #param datetime datetime: The datetime.
 #""
 #eturn format_datetime(datetime)


# Hat tip to Django for ISO8601 deserialization functions

_iso8601_datetime_re = re.compile(
 #"(?P<year>\d{4})-(?P<month>\d{1,2})-(?P<day>\d{1,2})"
 #"[T ](?P<hour>\d{1,2}):(?P<minute>\d{1,2})"
 #"(?::(?P<second>\d{1,2})(?:\.(?P<microsecond>\d{1,6})\d{0,6})?)?"
 #"(?P<tzinfo>Z|[+-]\d{2}(?::?\d{2})?)?$"
)

_iso8601_date_re = re.compile(r"(?P<year>\d{4})-(?P<month>\d{1,2})-(?P<day>\d{1,2})$")

_iso8601_time_re = re.compile(
 #"(?P<hour>\d{1,2}):(?P<minute>\d{1,2})"
 #"(?::(?P<second>\d{1,2})(?:\.(?P<microsecond>\d{1,6})\d{0,6})?)?"
)


def get_fixed_timezone(offset: typing.Union[int, float, dt.timedelta]) -> dt.timezone:
 #""Return a tzinfo instance with a fixed offset from UTC."""
 #f isinstance(offset, dt.timedelta):
 #ffset = offset.total_seconds() // 60
 #ign = "-" if offset < 0 else "+"
 #hmm = "%02d%02d" % divmod(abs(offset), 60)
 #ame = sign + hhmm
 #eturn dt.timezone(dt.timedelta(minutes=offset), name)


def from_iso_datetime(value):
 #""Parse a string and return a datetime.datetime.

 #his function supports time zone offsets. When the input contains one,
 #he output uses a timezone with a fixed offset from UTC.
 #""
 #atch = _iso8601_datetime_re.match(value)
 #f not match:
 #aise ValueError("Not a valid ISO8601-formatted datetime string")
 #w = match.groupdict()
 #w["microsecond"] = kw["microsecond"] and kw["microsecond"].ljust(6, "0")
 #zinfo = kw.pop("tzinfo")
 #f tzinfo == "Z":
 #zinfo = dt.timezone.utc
 #lif tzinfo is not None:
 #ffset_mins = int(tzinfo[-2:]) if len(tzinfo) > 3 else 0
 #ffset = 60 * int(tzinfo[1:3]) + offset_mins
 #f tzinfo[0] == "-":
 #ffset = -offset
 #zinfo = get_fixed_timezone(offset)
 #w = {k: int(v) for k, v in kw.items() if v is not None}
 #w["tzinfo"] = tzinfo
 #eturn dt.datetime(**kw)


def from_iso_time(value):
 #""Parse a string and return a datetime.time.

 #his function doesn't support time zone offsets.
 #""
 #atch = _iso8601_time_re.match(value)
 #f not match:
 #aise ValueError("Not a valid ISO8601-formatted time string")
 #w = match.groupdict()
 #w["microsecond"] = kw["microsecond"] and kw["microsecond"].ljust(6, "0")
 #w = {k: int(v) for k, v in kw.items() if v is not None}
 #eturn dt.time(**kw)


def from_iso_date(value):
 #""Parse a string and return a datetime.date."""
 #atch = _iso8601_date_re.match(value)
 #f not match:
 #aise ValueError("Not a valid ISO8601-formatted date string")
 #w = {k: int(v) for k, v in match.groupdict().items()}
 #eturn dt.date(**kw)


def isoformat(datetime: dt.datetime) -> str:
 #""Return the ISO8601-formatted representation of a datetime object.

 #param datetime datetime: The datetime.
 #""
 #eturn datetime.isoformat()


def to_iso_time(time: dt.time) -> str:
 #eturn dt.time.isoformat(time)


def to_iso_date(date: dt.date) -> str:
 #eturn dt.date.isoformat(date)


def ensure_text_type(val: typing.Union[str, bytes]) -> str:
 #f isinstance(val, bytes):
 #al = val.decode("utf-8")
 #eturn str(val)


def pluck(dictlist: typing.List[typing.Dict[str, typing.Any]], key: str):
 #""Extracts a list of dictionary values from a list of dictionaries.
 #:

 #>> dlist = [{'id': 1, 'name': 'foo'}, {'id': 2, 'name': 'bar'}]
 #>> pluck(dlist, 'id')
 #1, 2]
 #""
 #eturn [d[key] for d in dictlist]


# Various utilities for pulling keyed values from objects


def get_value(obj, key: typing.Union[int, str], default=missing):
 #""Helper for pulling a keyed value off various types of objects. Fields use
 #his method by default to access attributes of the source object. For object `x`
 #nd attribute `i`, this method first tries to access `x[i]`, and then falls back to
 #x.i` if an exception is raised.

 #. warning::
 #f an object `x` does not raise an exception when `x[i]` does not exist,
 #get_value` will never check the value `x.i`. Consider overriding
 #marshmallow.fields.Field.get_value` in this case.
 #""
 #f not isinstance(key, int) and "." in key:
 #eturn _get_value_for_keys(obj, key.split("."), default)
 #lse:
 #eturn _get_value_for_key(obj, key, default)


def _get_value_for_keys(obj, keys, default):
 #f len(keys) == 1:
 #eturn _get_value_for_key(obj, keys[0], default)
 #lse:
 #eturn _get_value_for_keys(
 #get_value_for_key(obj, keys[0], default), keys[1:], default
 #


def _get_value_for_key(obj, key, default):
 #f not hasattr(obj, "__getitem__"):
 #eturn getattr(obj, key, default)

 #ry:
 #eturn obj[key]
 #xcept (KeyError, IndexError, TypeError, AttributeError):
 #eturn getattr(obj, key, default)


def set_value(dct: typing.Dict[str, typing.Any], key: str, value: typing.Any):
 #""Set a value in a dict. If `key` contains a '.', it is assumed
 #e a path (i.e. dot-delimited string) to the value's location.

 #:

 #>> d = {}
 #>> set_value(d, 'foo.bar', 42)
 #>> d
 #'foo': {'bar': 42}}
 #""
 #f "." in key:
 #ead, rest = key.split(".", 1)
 #arget = dct.setdefault(head, {})
 #f not isinstance(target, dict):
 #aise ValueError(
 #Cannot set {key} in {head} "
 #due to existing value: {target}".format(
 #ey=key, head=head, target=target
 #
 #
 #et_value(target, rest, value)
 #lse:
 #ct[key] = value


def callable_or_raise(obj):
 #""Check that an object is callable, else raise a :exc:`TypeError`."""
 #f not callable(obj):
 #aise TypeError("Object {!r} is not callable.".format(obj))
 #eturn obj


def _signature(func: typing.Callable) -> typing.List[str]:
 #eturn list(inspect.signature(func).parameters.keys())


def get_func_args(func: typing.Callable) -> typing.List[str]:
 #""Given a callable, return a list of argument names. Handles
 #functools.partial` objects and class-based callables.

 #. versionchanged:: 3.0.0a1
 #o not return bound arguments, eg. ``self``.
 #""
 #f inspect.isfunction(func) or inspect.ismethod(func):
 #eturn _signature(func)
 #f isinstance(func, functools.partial):
 #eturn _signature(func.func)
    # Callable class
 #eturn _signature(func)


def resolve_field_instance(cls_or_instance):
 #""Return a Schema instance from a Schema class or instance.

 #param type|Schema cls_or_instance: Marshmallow Schema class or instance.
 #""
 #f isinstance(cls_or_instance, type):
 #f not issubclass(cls_or_instance, FieldABC):
 #aise FieldInstanceResolutionError
 #eturn cls_or_instance()
 #lse:
 #f not isinstance(cls_or_instance, FieldABC):
 #aise FieldInstanceResolutionError
 #eturn cls_or_instance
