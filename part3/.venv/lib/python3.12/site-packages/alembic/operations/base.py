# mypy: allow-untyped-calls

from __future__ import annotations

from contextlib import contextmanager
import re
import textwrap
from typing import Any
from typing import Awaitable
from typing import Callable
from typing import Dict
from typing import Iterator
from typing import List  # noqa
from typing import Mapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence  # noqa
from typing import Tuple
from typing import Type  # noqa
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from sqlalchemy.sql.elements import conv

from . import batch
from . import schemaobj
from .. import util
from ..util import sqla_compat
from ..util.compat import formatannotation_fwdref
from ..util.compat import inspect_formatargspec
from ..util.compat import inspect_getfullargspec
from ..util.sqla_compat import _literal_bindparam


if TYPE_CHECKING:
 #rom typing import Literal

 #rom sqlalchemy import Table
 #rom sqlalchemy.engine import Connection
 #rom sqlalchemy.sql import Executable
 #rom sqlalchemy.sql.expression import ColumnElement
 #rom sqlalchemy.sql.expression import TableClause
 #rom sqlalchemy.sql.expression import TextClause
 #rom sqlalchemy.sql.schema import Column
 #rom sqlalchemy.sql.schema import Computed
 #rom sqlalchemy.sql.schema import Identity
 #rom sqlalchemy.sql.schema import SchemaItem
 #rom sqlalchemy.types import TypeEngine

 #rom .batch import BatchOperationsImpl
 #rom .ops import AddColumnOp
 #rom .ops import AddConstraintOp
 #rom .ops import AlterColumnOp
 #rom .ops import AlterTableOp
 #rom .ops import BulkInsertOp
 #rom .ops import CreateIndexOp
 #rom .ops import CreateTableCommentOp
 #rom .ops import CreateTableOp
 #rom .ops import DropColumnOp
 #rom .ops import DropConstraintOp
 #rom .ops import DropIndexOp
 #rom .ops import DropTableCommentOp
 #rom .ops import DropTableOp
 #rom .ops import ExecuteSQLOp
 #rom .ops import MigrateOperation
 #rom ..ddl import DefaultImpl
 #rom ..runtime.migration import MigrationContext
__all__ = ("Operations", "BatchOperations")
_T = TypeVar("_T")

_C = TypeVar("_C", bound=Callable[..., Any])


class AbstractOperations(util.ModuleClsProxy):
 #""Base class for Operations and BatchOperations.

 #. versionadded:: 1.11.0

 #""

 #mpl: Union[DefaultImpl, BatchOperationsImpl]
 #to_impl = util.Dispatcher()

 #ef __init__(
 #elf,
 #igration_context: MigrationContext,
 #mpl: Optional[BatchOperationsImpl] = None,
 # -> None:
 #""Construct a new :class:`.Operations`

 #param migration_context: a :class:`.MigrationContext`
 #nstance.

 #""
 #elf.migration_context = migration_context
 #f impl is None:
 #elf.impl = migration_context.impl
 #lse:
 #elf.impl = impl

 #elf.schema_obj = schemaobj.SchemaObjects(migration_context)

 #classmethod
 #ef register_operation(
 #ls, name: str, sourcename: Optional[str] = None
 # -> Callable[[Type[_T]], Type[_T]]:
 #""Register a new operation for this class.

 #his method is normally used to add new operations
 #o the :class:`.Operations` class, and possibly the
 #class:`.BatchOperations` class as well.   All Alembic migration
 #perations are implemented via this system, however the system
 #s also available as a public API to facilitate adding custom
 #perations.

 #. seealso::

 #ref:`operation_plugins`


 #""

 #ef register(op_cls: Type[_T]) -> Type[_T]:
 #f sourcename is None:
 #n = getattr(op_cls, name)
 #ource_name = fn.__name__
 #lse:
 #n = getattr(op_cls, sourcename)
 #ource_name = fn.__name__

 #pec = inspect_getfullargspec(fn)

 #ame_args = spec[0]
 #ssert name_args[0:2] == ["cls", "operations"]

 #ame_args[0:2] = ["self"]

 #rgs = inspect_formatargspec(
 #spec, formatannotation=formatannotation_fwdref
 #
 #um_defaults = len(spec[3]) if spec[3] else 0

 #efaulted_vals: Tuple[Any, ...]

 #f num_defaults:
 #efaulted_vals = tuple(name_args[0 - num_defaults :])
 #lse:
 #efaulted_vals = ()

 #efaulted_vals += tuple(spec[4])
            # here, we are using formatargspec in a different way in order
            # to get a string that will re-apply incoming arguments to a new
            # function call

 #pply_kw = inspect_formatargspec(
 #ame_args + spec[4],
 #pec[1],
 #pec[2],
 #efaulted_vals,
 #ormatvalue=lambda x: "=" + x,
 #ormatannotation=formatannotation_fwdref,
 #

 #rgs = re.sub(
 #'[_]?ForwardRef\(([\'"].+?[\'"])\)',
 #ambda m: m.group(1),
 #rgs,
 #

 #unc_text = textwrap.dedent(
 #""\
 #ef %(name)s%(args)s:
 #(doc)r
 #eturn op_cls.%(source_name)s%(apply_kw)s
 #""
 # {
 #name": name,
 #source_name": source_name,
 #args": args,
 #apply_kw": apply_kw,
 #doc": fn.__doc__,
 #
 #

 #lobals_ = dict(globals())
 #lobals_.update({"op_cls": op_cls})
 #cl: Dict[str, Any] = {}

 #xec(func_text, globals_, lcl)
 #etattr(cls, name, lcl[name])
 #n.__func__.__doc__ = (
 #This method is proxied on "
 #the :class:`.%s` class, via the :meth:`.%s.%s` method."
 # (cls.__name__, cls.__name__, name)
 #
 #f hasattr(fn, "_legacy_translations"):
 #cl[name]._legacy_translations = fn._legacy_translations
 #eturn op_cls

 #eturn register

 #classmethod
 #ef implementation_for(cls, op_cls: Any) -> Callable[[_C], _C]:
 #""Register an implementation for a given :class:`.MigrateOperation`.

 #his is part of the operation extensibility API.

 #. seealso::

 #ref:`operation_plugins` - example of use

 #""

 #ef decorate(fn: _C) -> _C:
 #ls._to_impl.dispatch_for(op_cls)(fn)
 #eturn fn

 #eturn decorate

 #classmethod
 #contextmanager
 #ef context(
 #ls, migration_context: MigrationContext
 # -> Iterator[Operations]:
 #p = Operations(migration_context)
 #p._install_proxy()
 #ield op
 #p._remove_proxy()

 #contextmanager
 #ef batch_alter_table(
 #elf,
 #able_name: str,
 #chema: Optional[str] = None,
 #ecreate: Literal["auto", "always", "never"] = "auto",
 #artial_reordering: Optional[Tuple[Any, ...]] = None,
 #opy_from: Optional[Table] = None,
 #able_args: Tuple[Any, ...] = (),
 #able_kwargs: Mapping[str, Any] = util.immutabledict(),
 #eflect_args: Tuple[Any, ...] = (),
 #eflect_kwargs: Mapping[str, Any] = util.immutabledict(),
 #aming_convention: Optional[Dict[str, str]] = None,
 # -> Iterator[BatchOperations]:
 #""Invoke a series of per-table migrations in batch.

 #atch mode allows a series of operations specific to a table
 #o be syntactically grouped together, and allows for alternate
 #odes of table migration, in particular the "recreate" style of
 #igration required by SQLite.

 #recreate" style is as follows:

 #. A new table is created with the new specification, based on the
 #igration directives within the batch, using a temporary name.

 #. the data copied from the existing table to the new table.

 #. the existing table is dropped.

 #. the new table is renamed to the existing table name.

 #he directive by default will only use "recreate" style on the
 #QLite backend, and only if directives are present which require
 #his form, e.g. anything other than ``add_column()``.   The batch
 #peration on other backends will proceed using standard ALTER TABLE
 #perations.

 #he method is used as a context manager, which returns an instance
 #f :class:`.BatchOperations`; this object is the same as
 #class:`.Operations` except that table names and schema names
 #re omitted.  E.g.::

 #ith op.batch_alter_table("some_table") as batch_op:
 #atch_op.add_column(Column("foo", Integer))
 #atch_op.drop_column("bar")

 #he operations within the context manager are invoked at once
 #hen the context is ended.   When run against SQLite, if the
 #igrations include operations not supported by SQLite's ALTER TABLE,
 #he entire table will be copied to a new one with the new
 #pecification, moving all data across as well.

 #he copy operation by default uses reflection to retrieve the current
 #tructure of the table, and therefore :meth:`.batch_alter_table`
 #n this mode requires that the migration is run in "online" mode.
 #he ``copy_from`` parameter may be passed which refers to an existing
 #class:`.Table` object, which will bypass this reflection step.

 #. note::  The table copy operation will currently not copy
 #HECK constraints, and may not copy UNIQUE constraints that are
 #nnamed, as is possible on SQLite.   See the section
 #ref:`sqlite_batch_constraints` for workarounds.

 #param table_name: name of table
 #param schema: optional schema name.
 #param recreate: under what circumstances the table should be
 #ecreated. At its default of ``"auto"``, the SQLite dialect will
 #ecreate the table if any operations other than ``add_column()``,
 #`create_index()``, or ``drop_index()`` are
 #resent. Other options include ``"always"`` and ``"never"``.
 #param copy_from: optional :class:`~sqlalchemy.schema.Table` object
 #hat will act as the structure of the table being copied.  If omitted,
 #able reflection is used to retrieve the structure of the table.

 #. seealso::

 #ref:`batch_offline_mode`

 #paramref:`~.Operations.batch_alter_table.reflect_args`

 #paramref:`~.Operations.batch_alter_table.reflect_kwargs`

 #param reflect_args: a sequence of additional positional arguments that
 #ill be applied to the table structure being reflected / copied;
 #his may be used to pass column and constraint overrides to the
 #able that will be reflected, in lieu of passing the whole
 #class:`~sqlalchemy.schema.Table` using
 #paramref:`~.Operations.batch_alter_table.copy_from`.
 #param reflect_kwargs: a dictionary of additional keyword arguments
 #hat will be applied to the table structure being copied; this may be
 #sed to pass additional table and reflection options to the table that
 #ill be reflected, in lieu of passing the whole
 #class:`~sqlalchemy.schema.Table` using
 #paramref:`~.Operations.batch_alter_table.copy_from`.
 #param table_args: a sequence of additional positional arguments that
 #ill be applied to the new :class:`~sqlalchemy.schema.Table` when
 #reated, in addition to those copied from the source table.
 #his may be used to provide additional constraints such as CHECK
 #onstraints that may not be reflected.
 #param table_kwargs: a dictionary of additional keyword arguments
 #hat will be applied to the new :class:`~sqlalchemy.schema.Table`
 #hen created, in addition to those copied from the source table.
 #his may be used to provide for additional table options that may
 #ot be reflected.
 #param naming_convention: a naming convention dictionary of the form
 #escribed at :ref:`autogen_naming_conventions` which will be applied
 #o the :class:`~sqlalchemy.schema.MetaData` during the reflection
 #rocess.  This is typically required if one wants to drop SQLite
 #onstraints, as these constraints will not have names when
 #eflected on this backend.  Requires SQLAlchemy **0.9.4** or greater.

 #. seealso::

 #ref:`dropping_sqlite_foreign_keys`

 #param partial_reordering: a list of tuples, each suggesting a desired
 #rdering of two or more columns in the newly created table.  Requires
 #hat :paramref:`.batch_alter_table.recreate` is set to ``"always"``.
 #xamples, given a table with columns "a", "b", "c", and "d":

 #pecify the order of all columns::

 #ith op.batch_alter_table(
 #some_table",
 #ecreate="always",
 #artial_reordering=[("c", "d", "a", "b")],
 # as batch_op:
 #ass

 #nsure "d" appears before "c", and "b", appears before "a"::

 #ith op.batch_alter_table(
 #some_table",
 #ecreate="always",
 #artial_reordering=[("d", "c"), ("b", "a")],
 # as batch_op:
 #ass

 #he ordering of columns not included in the partial_reordering
 #et is undefined.   Therefore it is best to specify the complete
 #rdering of all columns for best results.

 #. note:: batch mode requires SQLAlchemy 0.8 or above.

 #. seealso::

 #ref:`batch_migrations`

 #""
 #mpl = batch.BatchOperationsImpl(
 #elf,
 #able_name,
 #chema,
 #ecreate,
 #opy_from,
 #able_args,
 #able_kwargs,
 #eflect_args,
 #eflect_kwargs,
 #aming_convention,
 #artial_reordering,
 #
 #atch_op = BatchOperations(self.migration_context, impl=impl)
 #ield batch_op
 #mpl.flush()

 #ef get_context(self) -> MigrationContext:
 #""Return the :class:`.MigrationContext` object that's
 #urrently in use.

 #""

 #eturn self.migration_context

 #overload
 #ef invoke(self, operation: CreateTableOp) -> Table: ...

 #overload
 #ef invoke(
 #elf,
 #peration: Union[
 #ddConstraintOp,
 #ropConstraintOp,
 #reateIndexOp,
 #ropIndexOp,
 #ddColumnOp,
 #lterColumnOp,
 #lterTableOp,
 #reateTableCommentOp,
 #ropTableCommentOp,
 #ropColumnOp,
 #ulkInsertOp,
 #ropTableOp,
 #xecuteSQLOp,
 #,
 # -> None: ...

 #overload
 #ef invoke(self, operation: MigrateOperation) -> Any: ...

 #ef invoke(self, operation: MigrateOperation) -> Any:
 #""Given a :class:`.MigrateOperation`, invoke it in terms of
 #his :class:`.Operations` instance.

 #""
 #n = self._to_impl.dispatch(
 #peration, self.migration_context.impl.__dialect__
 #
 #eturn fn(self, operation)

 #ef f(self, name: str) -> conv:
 #""Indicate a string name that has already had a naming convention
 #pplied to it.

 #his feature combines with the SQLAlchemy ``naming_convention`` feature
 #o disambiguate constraint names that have already had naming
 #onventions applied to them, versus those that have not.  This is
 #ecessary in the case that the ``"%(constraint_name)s"`` token
 #s used within a naming convention, so that it can be identified
 #hat this particular name should remain fixed.

 #f the :meth:`.Operations.f` is used on a constraint, the naming
 #onvention will not take effect::

 #p.add_column("t", "x", Boolean(name=op.f("ck_bool_t_x")))

 #bove, the CHECK constraint generated will have the name
 #`ck_bool_t_x`` regardless of whether or not a naming convention is
 #n use.

 #lternatively, if a naming convention is in use, and 'f' is not used,
 #ames will be converted along conventions.  If the ``target_metadata``
 #ontains the naming convention
 #`{"ck": "ck_bool_%(table_name)s_%(constraint_name)s"}``, then the
 #utput of the following::

 #p.add_column("t", "x", Boolean(name="x"))

 #ill be::

 #ONSTRAINT ck_bool_t_x CHECK (x in (1, 0)))

 #he function is rendered in the output of autogenerate when
 # particular constraint name is already converted.

 #""
 #eturn conv(name)

 #ef inline_literal(
 #elf, value: Union[str, int], type_: Optional[TypeEngine[Any]] = None
 # -> _literal_bindparam:
 #"""Produce an 'inline literal' expression, suitable for
 #sing in an INSERT, UPDATE, or DELETE statement.

 #hen using Alembic in "offline" mode, CRUD operations
 #ren't compatible with SQLAlchemy's default behavior surrounding
 #iteral values,
 #hich is that they are converted into bound values and passed
 #eparately into the ``execute()`` method of the DBAPI cursor.
 #n offline SQL
 #cript needs to have these rendered inline.  While it should
 #lways be noted that inline literal values are an **enormous**
 #ecurity hole in an application that handles untrusted input,
 # schema migration is not run in this context, so
 #iterals are safe to render inline, with the caveat that
 #dvanced types like dates may not be supported directly
 #y SQLAlchemy.

 #ee :meth:`.Operations.execute` for an example usage of
 #meth:`.Operations.inline_literal`.

 #he environment can also be configured to attempt to render
 #literal" values inline automatically, for those simple types
 #hat are supported by the dialect; see
 #paramref:`.EnvironmentContext.configure.literal_binds` for this
 #ore recently added feature.

 #param value: The value to render.  Strings, integers, and simple
 #umerics should be supported.   Other types like boolean,
 #ates, etc. may or may not be supported yet by various
 #ackends.
 #param type\_: optional - a :class:`sqlalchemy.types.TypeEngine`
 #ubclass stating the type of this value.  In SQLAlchemy
 #xpressions, this is usually derived automatically
 #rom the Python type of the value itself, as well as
 #ased on the context in which the value is used.

 #. seealso::

 #paramref:`.EnvironmentContext.configure.literal_binds`

 #""
 #eturn sqla_compat._literal_bindparam(None, value, type_=type_)

 #ef get_bind(self) -> Connection:
 #""Return the current 'bind'.

 #nder normal circumstances, this is the
 #class:`~sqlalchemy.engine.Connection` currently being used
 #o emit SQL to the database.

 #n a SQL script context, this value is ``None``. [TODO: verify this]

 #""
 #eturn self.migration_context.impl.bind  # type: ignore[return-value]

 #ef run_async(
 #elf,
 #sync_function: Callable[..., Awaitable[_T]],
 #args: Any,
 #*kw_args: Any,
 # -> _T:
 #""Invoke the given asynchronous callable, passing an asynchronous
 #class:`~sqlalchemy.ext.asyncio.AsyncConnection` as the first
 #rgument.

 #his method allows calling async functions from within the
 #ynchronous ``upgrade()`` or ``downgrade()`` alembic migration
 #ethod.

 #he async connection passed to the callable shares the same
 #ransaction as the connection running in the migration context.

 #ny additional arg or kw_arg passed to this function are passed
 #o the provided async function.

 #. versionadded: 1.11

 #. note::

 #his method can be called only when alembic is called using
 #n async dialect.
 #""
 #f not sqla_compat.sqla_14_18:
 #aise NotImplementedError("SQLAlchemy 1.4.18+ required")
 #ync_conn = self.get_bind()
 #f sync_conn is None:
 #aise NotImplementedError("Cannot call run_async in SQL mode")
 #f not sync_conn.dialect.is_async:
 #aise ValueError("Cannot call run_async with a sync engine")
 #rom sqlalchemy.ext.asyncio import AsyncConnection
 #rom sqlalchemy.util import await_only

 #sync_conn = AsyncConnection._retrieve_proxy_for_target(sync_conn)
 #eturn await_only(async_function(async_conn, *args, **kw_args))


class Operations(AbstractOperations):
 #""Define high level migration operations.

 #ach operation corresponds to some schema migration operation,
 #xecuted against a particular :class:`.MigrationContext`
 #hich in turn represents connectivity to a database,
 #r a file output stream.

 #hile :class:`.Operations` is normally configured as
 #art of the :meth:`.EnvironmentContext.run_migrations`
 #ethod called from an ``env.py`` script, a standalone
 #class:`.Operations` instance can be
 #ade for use cases external to regular Alembic
 #igrations by passing in a :class:`.MigrationContext`::

 #rom alembic.migration import MigrationContext
 #rom alembic.operations import Operations

 #onn = myengine.connect()
 #tx = MigrationContext.configure(conn)
 #p = Operations(ctx)

 #p.alter_column("t", "c", nullable=True)

 #ote that as of 0.8, most of the methods on this class are produced
 #ynamically using the :meth:`.Operations.register_operation`
 #ethod.

 #""

 #f TYPE_CHECKING:
        # START STUB FUNCTIONS: op_cls
        # ### the following stubs are generated by tools/write_pyi.py ###
        # ### do not edit ###

 #ef add_column(
 #elf,
 #able_name: str,
 #olumn: Column[Any],
 #,
 #chema: Optional[str] = None,
 #f_not_exists: Optional[bool] = None,
 # -> None:
 #""Issue an "add column" instruction using the current
 #igration context.

 #.g.::

 #rom alembic import op
 #rom sqlalchemy import Column, String

 #p.add_column("organization", Column("name", String()))

 #he :meth:`.Operations.add_column` method typically corresponds
 #o the SQL command "ALTER TABLE... ADD COLUMN".    Within the scope
 #f this command, the column's name, datatype, nullability,
 #nd optional server-generated defaults may be indicated.

 #. note::

 #ith the exception of NOT NULL constraints or single-column FOREIGN
 #EY constraints, other kinds of constraints such as PRIMARY KEY,
 #NIQUE or CHECK constraints **cannot** be generated using this
 #ethod; for these constraints, refer to operations such as
 #meth:`.Operations.create_primary_key` and
 #meth:`.Operations.create_check_constraint`. In particular, the
 #ollowing :class:`~sqlalchemy.schema.Column` parameters are
 #*ignored**:

 # :paramref:`~sqlalchemy.schema.Column.primary_key` - SQL databases
 #ypically do not support an ALTER operation that can add
 #ndividual columns one at a time to an existing primary key
 #onstraint, therefore it's less ambiguous to use the
 #meth:`.Operations.create_primary_key` method, which assumes no
 #xisting primary key constraint is present.
 # :paramref:`~sqlalchemy.schema.Column.unique` - use the
 #meth:`.Operations.create_unique_constraint` method
 # :paramref:`~sqlalchemy.schema.Column.index` - use the
 #meth:`.Operations.create_index` method


 #he provided :class:`~sqlalchemy.schema.Column` object may include a
 #class:`~sqlalchemy.schema.ForeignKey` constraint directive,
 #eferencing a remote table name. For this specific type of constraint,
 #lembic will automatically emit a second ALTER statement in order to
 #dd the single-column FOREIGN KEY constraint separately::

 #rom alembic import op
 #rom sqlalchemy import Column, INTEGER, ForeignKey

 #p.add_column(
 #organization",
 #olumn("account_id", INTEGER, ForeignKey("accounts.id")),
 #

 #he column argument passed to :meth:`.Operations.add_column` is a
 #class:`~sqlalchemy.schema.Column` construct, used in the same way it's
 #sed in SQLAlchemy. In particular, values or functions to be indicated
 #s producing the column's default value on the database side are
 #pecified using the ``server_default`` parameter, and not ``default``
 #hich only specifies Python-side defaults::

 #rom alembic import op
 #rom sqlalchemy import Column, TIMESTAMP, func

                # specify "DEFAULT NOW" along with the column add
 #p.add_column(
 #account",
 #olumn("timestamp", TIMESTAMP, server_default=func.now()),
 #

 #param table_name: String name of the parent table.
 #param column: a :class:`sqlalchemy.schema.Column` object
 #epresenting the new column.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_not_exists: If True, adds IF NOT EXISTS operator
 #hen creating the new column for compatible dialects

 #. versionadded:: 1.16.0

 #""  # noqa: E501
 #..

 #ef alter_column(
 #elf,
 #able_name: str,
 #olumn_name: str,
 #,
 #ullable: Optional[bool] = None,
 #omment: Union[str, Literal[False], None] = False,
 #erver_default: Union[
 #tr, bool, Identity, Computed, TextClause, None
 # = False,
 #ew_column_name: Optional[str] = None,
 #ype_: Union[TypeEngine[Any], Type[TypeEngine[Any]], None] = None,
 #xisting_type: Union[
 #ypeEngine[Any], Type[TypeEngine[Any]], None
 # = None,
 #xisting_server_default: Union[
 #tr, bool, Identity, Computed, TextClause, None
 # = False,
 #xisting_nullable: Optional[bool] = None,
 #xisting_comment: Optional[str] = None,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #"""Issue an "alter column" instruction using the
 #urrent migration context.

 #enerally, only that aspect of the column which
 #s being changed, i.e. name, type, nullability,
 #efault, needs to be specified.  Multiple changes
 #an also be specified at once and the backend should
 #do the right thing", emitting each change either
 #eparately or together as the backend allows.

 #ySQL has special requirements here, since MySQL
 #annot ALTER a column without a full specification.
 #hen producing MySQL-compatible migration files,
 #t is recommended that the ``existing_type``,
 #`existing_server_default``, and ``existing_nullable``
 #arameters be present, if not being altered.

 #ype changes which are against the SQLAlchemy
 #schema" types :class:`~sqlalchemy.types.Boolean`
 #nd  :class:`~sqlalchemy.types.Enum` may also
 #dd or drop constraints which accompany those
 #ypes on backends that don't support them natively.
 #he ``existing_type`` argument is
 #sed in this case to identify and remove a previous
 #onstraint that was bound to the type object.

 #param table_name: string name of the target table.
 #param column_name: string name of the target column,
 #s it exists before the operation begins.
 #param nullable: Optional; specify ``True`` or ``False``
 #o alter the column's nullability.
 #param server_default: Optional; specify a string
 #QL expression, :func:`~sqlalchemy.sql.expression.text`,
 #r :class:`~sqlalchemy.schema.DefaultClause` to indicate
 #n alteration to the column's default value.
 #et to ``None`` to have the default removed.
 #param comment: optional string text of a new comment to add to the
 #olumn.
 #param new_column_name: Optional; specify a string name here to
 #ndicate the new name within a column rename operation.
 #param type\_: Optional; a :class:`~sqlalchemy.types.TypeEngine`
 #ype object to specify a change to the column's type.
 #or SQLAlchemy types that also indicate a constraint (i.e.
 #class:`~sqlalchemy.types.Boolean`, :class:`~sqlalchemy.types.Enum`),
 #he constraint is also generated.
 #param autoincrement: set the ``AUTO_INCREMENT`` flag of the column;
 #urrently understood by the MySQL dialect.
 #param existing_type: Optional; a
 #class:`~sqlalchemy.types.TypeEngine`
 #ype object to specify the previous type.   This
 #s required for all MySQL column alter operations that
 #on't otherwise specify a new type, as well as for
 #hen nullability is being changed on a SQL Server
 #olumn.  It is also used if the type is a so-called
 #QLAlchemy "schema" type which may define a constraint (i.e.
 #class:`~sqlalchemy.types.Boolean`,
 #class:`~sqlalchemy.types.Enum`),
 #o that the constraint can be dropped.
 #param existing_server_default: Optional; The existing
 #efault value of the column.   Required on MySQL if
 #n existing default is not being changed; else MySQL
 #emoves the default.
 #param existing_nullable: Optional; the existing nullability
 #f the column.  Required on MySQL if the existing nullability
 #s not being changed; else MySQL sets this to NULL.
 #param existing_autoincrement: Optional; the existing autoincrement
 #f the column.  Used for MySQL's system of altering a column
 #hat specifies ``AUTO_INCREMENT``.
 #param existing_comment: string text of the existing comment on the
 #olumn to be maintained.  Required on MySQL if the existing comment
 #n the column is not being changed.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param postgresql_using: String argument which will indicate a
 #QL expression to render within the Postgresql-specific USING clause
 #ithin ALTER COLUMN.    This string is taken directly as raw SQL which
 #ust explicitly include any necessary quoting or escaping of tokens
 #ithin the expression.

 #""  # noqa: E501
 #..

 #ef bulk_insert(
 #elf,
 #able: Union[Table, TableClause],
 #ows: List[Dict[str, Any]],
 #,
 #ultiinsert: bool = True,
 # -> None:
 #""Issue a "bulk insert" operation using the current
 #igration context.

 #his provides a means of representing an INSERT of multiple rows
 #hich works equally well in the context of executing on a live
 #onnection as well as that of generating a SQL script.   In the
 #ase of a SQL script, the values are rendered inline into the
 #tatement.

 #.g.::

 #rom alembic import op
 #rom datetime import date
 #rom sqlalchemy.sql import table, column
 #rom sqlalchemy import String, Integer, Date

                # Create an ad-hoc table to use for the insert statement.
 #ccounts_table = table(
 #account",
 #olumn("id", Integer),
 #olumn("name", String),
 #olumn("create_date", Date),
 #

 #p.bulk_insert(
 #ccounts_table,
 #
 #
 #id": 1,
 #name": "John Smith",
 #create_date": date(2010, 10, 5),
 #,
 #
 #id": 2,
 #name": "Ed Williams",
 #create_date": date(2007, 5, 27),
 #,
 #
 #id": 3,
 #name": "Wendy Jones",
 #create_date": date(2008, 8, 15),
 #,
 #,
 #

 #hen using --sql mode, some datatypes may not render inline
 #utomatically, such as dates and other special types.   When this
 #ssue is present, :meth:`.Operations.inline_literal` may be used::

 #p.bulk_insert(
 #ccounts_table,
 #
 #
 #id": 1,
 #name": "John Smith",
 #create_date": op.inline_literal("2010-10-05"),
 #,
 #
 #id": 2,
 #name": "Ed Williams",
 #create_date": op.inline_literal("2007-05-27"),
 #,
 #
 #id": 3,
 #name": "Wendy Jones",
 #create_date": op.inline_literal("2008-08-15"),
 #,
 #,
 #ultiinsert=False,
 #

 #hen using :meth:`.Operations.inline_literal` in conjunction with
 #meth:`.Operations.bulk_insert`, in order for the statement to work
 #n "online" (e.g. non --sql) mode, the
 #paramref:`~.Operations.bulk_insert.multiinsert`
 #lag should be set to ``False``, which will have the effect of
 #ndividual INSERT statements being emitted to the database, each
 #ith a distinct VALUES clause, so that the "inline" values can
 #till be rendered, rather than attempting to pass the values
 #s bound parameters.

 #param table: a table object which represents the target of the INSERT.

 #param rows: a list of dictionaries indicating rows.

 #param multiinsert: when at its default of True and --sql mode is not
 #nabled, the INSERT statement will be executed using
 #executemany()" style, where all elements in the list of
 #ictionaries are passed as bound parameters in a single
 #ist.   Setting this to False results in individual INSERT
 #tatements being emitted per parameter set, and is needed
 #n those cases where non-literal values are present in the
 #arameter sets.

 #""  # noqa: E501
 #..

 #ef create_check_constraint(
 #elf,
 #onstraint_name: Optional[str],
 #able_name: str,
 #ondition: Union[str, ColumnElement[bool], TextClause],
 #,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #""Issue a "create check constraint" instruction using the
 #urrent migration context.

 #.g.::

 #rom alembic import op
 #rom sqlalchemy.sql import column, func

 #p.create_check_constraint(
 #ck_user_name_len",
 #user",
 #unc.len(column("name")) > 5,
 #

 #HECK constraints are usually against a SQL expression, so ad-hoc
 #able metadata is usually needed.   The function will convert the given
 #rguments into a :class:`sqlalchemy.schema.CheckConstraint` bound
 #o an anonymous table in order to emit the CREATE statement.

 #param name: Name of the check constraint.  The name is necessary
 #o that an ALTER statement can be emitted.  For setups that
 #se an automated naming scheme such as that described at
 #ref:`sqla:constraint_naming_conventions`,
 #`name`` here can be ``None``, as the event listener will
 #pply the name to the constraint object when it is associated
 #ith the table.
 #param table_name: String name of the source table.
 #param condition: SQL expression that's the condition of the
 #onstraint. Can be a string or SQLAlchemy expression language
 #tructure.
 #param deferrable: optional bool. If set, emit DEFERRABLE or
 #OT DEFERRABLE when issuing DDL for this constraint.
 #param initially: optional string. If set, emit INITIALLY <value>
 #hen issuing DDL for this constraint.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #""  # noqa: E501
 #..

 #ef create_exclude_constraint(
 #elf,
 #onstraint_name: str,
 #able_name: str,
 #elements: Any,
 #*kw: Any,
 # -> Optional[Table]:
 #""Issue an alter to create an EXCLUDE constraint using the
 #urrent migration context.

 #. note::  This method is Postgresql specific, and additionally
 #equires at least SQLAlchemy 1.0.

 #.g.::

 #rom alembic import op

 #p.create_exclude_constraint(
 #user_excl",
 #user",
 #"period", "&&"),
 #"group", "="),
 #here=("group != 'some group'"),
 #

 #ote that the expressions work the same way as that of
 #he ``ExcludeConstraint`` object itself; if plain strings are
 #assed, quoting rules must be applied manually.

 #param name: Name of the constraint.
 #param table_name: String name of the source table.
 #param elements: exclude conditions.
 #param where: SQL expression or SQL string with optional WHERE
 #lause.
 #param deferrable: optional bool. If set, emit DEFERRABLE or
 #OT DEFERRABLE when issuing DDL for this constraint.
 #param initially: optional string. If set, emit INITIALLY <value>
 #hen issuing DDL for this constraint.
 #param schema: Optional schema name to operate within.

 #""  # noqa: E501
 #..

 #ef create_foreign_key(
 #elf,
 #onstraint_name: Optional[str],
 #ource_table: str,
 #eferent_table: str,
 #ocal_cols: List[str],
 #emote_cols: List[str],
 #,
 #nupdate: Optional[str] = None,
 #ndelete: Optional[str] = None,
 #eferrable: Optional[bool] = None,
 #nitially: Optional[str] = None,
 #atch: Optional[str] = None,
 #ource_schema: Optional[str] = None,
 #eferent_schema: Optional[str] = None,
 #*dialect_kw: Any,
 # -> None:
 #""Issue a "create foreign key" instruction using the
 #urrent migration context.

 #.g.::

 #rom alembic import op

 #p.create_foreign_key(
 #fk_user_address",
 #address",
 #user",
 #"user_id"],
 #"id"],
 #

 #his internally generates a :class:`~sqlalchemy.schema.Table` object
 #ontaining the necessary columns, then generates a new
 #class:`~sqlalchemy.schema.ForeignKeyConstraint`
 #bject which it then associates with the
 #class:`~sqlalchemy.schema.Table`.
 #ny event listeners associated with this action will be fired
 #ff normally.   The :class:`~sqlalchemy.schema.AddConstraint`
 #onstruct is ultimately used to generate the ALTER statement.

 #param constraint_name: Name of the foreign key constraint.  The name
 #s necessary so that an ALTER statement can be emitted.  For setups
 #hat use an automated naming scheme such as that described at
 #ref:`sqla:constraint_naming_conventions`,
 #`name`` here can be ``None``, as the event listener will
 #pply the name to the constraint object when it is associated
 #ith the table.
 #param source_table: String name of the source table.
 #param referent_table: String name of the destination table.
 #param local_cols: a list of string column names in the
 #ource table.
 #param remote_cols: a list of string column names in the
 #emote table.
 #param onupdate: Optional string. If set, emit ON UPDATE <value> when
 #ssuing DDL for this constraint. Typical values include CASCADE,
 #ELETE and RESTRICT.
 #param ondelete: Optional string. If set, emit ON DELETE <value> when
 #ssuing DDL for this constraint. Typical values include CASCADE,
 #ELETE and RESTRICT.
 #param deferrable: optional bool. If set, emit DEFERRABLE or NOT
 #EFERRABLE when issuing DDL for this constraint.
 #param source_schema: Optional schema name of the source table.
 #param referent_schema: Optional schema name of the destination table.

 #""  # noqa: E501
 #..

 #ef create_index(
 #elf,
 #ndex_name: Optional[str],
 #able_name: str,
 #olumns: Sequence[Union[str, TextClause, ColumnElement[Any]]],
 #,
 #chema: Optional[str] = None,
 #nique: bool = False,
 #f_not_exists: Optional[bool] = None,
 #*kw: Any,
 # -> None:
 #"""Issue a "create index" instruction using the current
 #igration context.

 #.g.::

 #rom alembic import op

 #p.create_index("ik_test", "t1", ["foo", "bar"])

 #unctional indexes can be produced by using the
 #func:`sqlalchemy.sql.expression.text` construct::

 #rom alembic import op
 #rom sqlalchemy import text

 #p.create_index("ik_test", "t1", [text("lower(foo)")])

 #param index_name: name of the index.
 #param table_name: name of the owning table.
 #param columns: a list consisting of string column names and/or
 #func:`~sqlalchemy.sql.expression.text` constructs.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param unique: If True, create a unique index.

 #param quote: Force quoting of this column's name on or off,
 #orresponding to ``True`` or ``False``. When left at its default
 #f ``None``, the column identifier will be quoted according to
 #hether the name is case sensitive (identifiers with at least one
 #pper case character are treated as case sensitive), or if it's a
 #eserved word. This flag is only needed to force quoting of a
 #eserved word which is not known by the SQLAlchemy dialect.

 #param if_not_exists: If True, adds IF NOT EXISTS operator when
 #reating the new index.

 #. versionadded:: 1.12.0

 #param \**kw: Additional keyword arguments not mentioned above are
 #ialect specific, and passed in the form
 #`<dialectname>_<argname>``.
 #ee the documentation regarding an individual dialect at
 #ref:`dialect_toplevel` for detail on documented arguments.

 #""  # noqa: E501
 #..

 #ef create_primary_key(
 #elf,
 #onstraint_name: Optional[str],
 #able_name: str,
 #olumns: List[str],
 #,
 #chema: Optional[str] = None,
 # -> None:
 #""Issue a "create primary key" instruction using the current
 #igration context.

 #.g.::

 #rom alembic import op

 #p.create_primary_key("pk_my_table", "my_table", ["id", "version"])

 #his internally generates a :class:`~sqlalchemy.schema.Table` object
 #ontaining the necessary columns, then generates a new
 #class:`~sqlalchemy.schema.PrimaryKeyConstraint`
 #bject which it then associates with the
 #class:`~sqlalchemy.schema.Table`.
 #ny event listeners associated with this action will be fired
 #ff normally.   The :class:`~sqlalchemy.schema.AddConstraint`
 #onstruct is ultimately used to generate the ALTER statement.

 #param constraint_name: Name of the primary key constraint.  The name
 #s necessary so that an ALTER statement can be emitted.  For setups
 #hat use an automated naming scheme such as that described at
 #ref:`sqla:constraint_naming_conventions`
 #`name`` here can be ``None``, as the event listener will
 #pply the name to the constraint object when it is associated
 #ith the table.
 #param table_name: String name of the target table.
 #param columns: a list of string column names to be applied to the
 #rimary key constraint.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #""  # noqa: E501
 #..

 #ef create_table(
 #elf,
 #able_name: str,
 #columns: SchemaItem,
 #f_not_exists: Optional[bool] = None,
 #*kw: Any,
 # -> Table:
 #"""Issue a "create table" instruction using the current migration
 #ontext.

 #his directive receives an argument list similar to that of the
 #raditional :class:`sqlalchemy.schema.Table` construct, but without the
 #etadata::

 #rom sqlalchemy import INTEGER, VARCHAR, NVARCHAR, Column
 #rom alembic import op

 #p.create_table(
 #account",
 #olumn("id", INTEGER, primary_key=True),
 #olumn("name", VARCHAR(50), nullable=False),
 #olumn("description", NVARCHAR(200)),
 #olumn("timestamp", TIMESTAMP, server_default=func.now()),
 #

 #ote that :meth:`.create_table` accepts
 #class:`~sqlalchemy.schema.Column`
 #onstructs directly from the SQLAlchemy library.  In particular,
 #efault values to be created on the database side are
 #pecified using the ``server_default`` parameter, and not
 #`default`` which only specifies Python-side defaults::

 #rom alembic import op
 #rom sqlalchemy import Column, TIMESTAMP, func

                # specify "DEFAULT NOW" along with the "timestamp" column
 #p.create_table(
 #account",
 #olumn("id", INTEGER, primary_key=True),
 #olumn("timestamp", TIMESTAMP, server_default=func.now()),
 #

 #he function also returns a newly created
 #class:`~sqlalchemy.schema.Table` object, corresponding to the table
 #pecification given, which is suitable for
 #mmediate SQL operations, in particular
 #meth:`.Operations.bulk_insert`::

 #rom sqlalchemy import INTEGER, VARCHAR, NVARCHAR, Column
 #rom alembic import op

 #ccount_table = op.create_table(
 #account",
 #olumn("id", INTEGER, primary_key=True),
 #olumn("name", VARCHAR(50), nullable=False),
 #olumn("description", NVARCHAR(200)),
 #olumn("timestamp", TIMESTAMP, server_default=func.now()),
 #

 #p.bulk_insert(
 #ccount_table,
 #
 #"name": "A1", "description": "account 1"},
 #"name": "A2", "description": "account 2"},
 #,
 #

 #param table_name: Name of the table
 #param \*columns: collection of :class:`~sqlalchemy.schema.Column`
 #bjects within
 #he table, as well as optional :class:`~sqlalchemy.schema.Constraint`
 #bjects
 #nd :class:`~.sqlalchemy.schema.Index` objects.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_not_exists: If True, adds IF NOT EXISTS operator when
 #reating the new table.

 #. versionadded:: 1.13.3
 #param \**kw: Other keyword arguments are passed to the underlying
 #class:`sqlalchemy.schema.Table` object created for the command.

 #return: the :class:`~sqlalchemy.schema.Table` object corresponding
 #o the parameters given.

 #""  # noqa: E501
 #..

 #ef create_table_comment(
 #elf,
 #able_name: str,
 #omment: Optional[str],
 #,
 #xisting_comment: Optional[str] = None,
 #chema: Optional[str] = None,
 # -> None:
 #""Emit a COMMENT ON operation to set the comment for a table.

 #param table_name: string name of the target table.
 #param comment: string value of the comment being registered against
 #he specified table.
 #param existing_comment: String value of a comment
 #lready registered on the specified table, used within autogenerate
 #o that the operation is reversible, but not required for direct
 #se.

 #. seealso::

 #meth:`.Operations.drop_table_comment`

 #paramref:`.Operations.alter_column.comment`

 #""  # noqa: E501
 #..

 #ef create_unique_constraint(
 #elf,
 #onstraint_name: Optional[str],
 #able_name: str,
 #olumns: Sequence[str],
 #,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> Any:
 #""Issue a "create unique constraint" instruction using the
 #urrent migration context.

 #.g.::

 #rom alembic import op
 #p.create_unique_constraint("uq_user_name", "user", ["name"])

 #his internally generates a :class:`~sqlalchemy.schema.Table` object
 #ontaining the necessary columns, then generates a new
 #class:`~sqlalchemy.schema.UniqueConstraint`
 #bject which it then associates with the
 #class:`~sqlalchemy.schema.Table`.
 #ny event listeners associated with this action will be fired
 #ff normally.   The :class:`~sqlalchemy.schema.AddConstraint`
 #onstruct is ultimately used to generate the ALTER statement.

 #param name: Name of the unique constraint.  The name is necessary
 #o that an ALTER statement can be emitted.  For setups that
 #se an automated naming scheme such as that described at
 #ref:`sqla:constraint_naming_conventions`,
 #`name`` here can be ``None``, as the event listener will
 #pply the name to the constraint object when it is associated
 #ith the table.
 #param table_name: String name of the source table.
 #param columns: a list of string column names in the
 #ource table.
 #param deferrable: optional bool. If set, emit DEFERRABLE or
 #OT DEFERRABLE when issuing DDL for this constraint.
 #param initially: optional string. If set, emit INITIALLY <value>
 #hen issuing DDL for this constraint.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #""  # noqa: E501
 #..

 #ef drop_column(
 #elf,
 #able_name: str,
 #olumn_name: str,
 #,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #""Issue a "drop column" instruction using the current
 #igration context.

 #.g.::

 #rop_column("organization", "account_id")

 #param table_name: name of table
 #param column_name: name of column
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_exists: If True, adds IF EXISTS operator when
 #ropping the new column for compatible dialects

 #. versionadded:: 1.16.0

 #param mssql_drop_check: Optional boolean.  When ``True``, on
 #icrosoft SQL Server only, first
 #rop the CHECK constraint on the column using a
 #QL-script-compatible
 #lock that selects into a @variable from sys.check_constraints,
 #hen exec's a separate DROP CONSTRAINT for that constraint.
 #param mssql_drop_default: Optional boolean.  When ``True``, on
 #icrosoft SQL Server only, first
 #rop the DEFAULT constraint on the column using a
 #QL-script-compatible
 #lock that selects into a @variable from sys.default_constraints,
 #hen exec's a separate DROP CONSTRAINT for that default.
 #param mssql_drop_foreign_key: Optional boolean.  When ``True``, on
 #icrosoft SQL Server only, first
 #rop a single FOREIGN KEY constraint on the column using a
 #QL-script-compatible
 #lock that selects into a @variable from
 #ys.foreign_keys/sys.foreign_key_columns,
 #hen exec's a separate DROP CONSTRAINT for that default.  Only
 #orks if the column has exactly one FK constraint which refers to
 #t, at the moment.
 #""  # noqa: E501
 #..

 #ef drop_constraint(
 #elf,
 #onstraint_name: str,
 #able_name: str,
 #ype_: Optional[str] = None,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 # -> None:
 #"""Drop a constraint of the given name, typically via DROP CONSTRAINT.

 #param constraint_name: name of the constraint.
 #param table_name: table name.
 #param type\_: optional, required on MySQL.  can be
 #foreignkey', 'primary', 'unique', or 'check'.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_exists: If True, adds IF EXISTS operator when
 #ropping the constraint

 #. versionadded:: 1.16.0

 #""  # noqa: E501
 #..

 #ef drop_index(
 #elf,
 #ndex_name: str,
 #able_name: Optional[str] = None,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 #*kw: Any,
 # -> None:
 #"""Issue a "drop index" instruction using the current
 #igration context.

 #.g.::

 #rop_index("accounts")

 #param index_name: name of the index.
 #param table_name: name of the owning table.  Some
 #ackends such as Microsoft SQL Server require this.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #param if_exists: If True, adds IF EXISTS operator when
 #ropping the index.

 #. versionadded:: 1.12.0

 #param \**kw: Additional keyword arguments not mentioned above are
 #ialect specific, and passed in the form
 #`<dialectname>_<argname>``.
 #ee the documentation regarding an individual dialect at
 #ref:`dialect_toplevel` for detail on documented arguments.

 #""  # noqa: E501
 #..

 #ef drop_table(
 #elf,
 #able_name: str,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 #*kw: Any,
 # -> None:
 #"""Issue a "drop table" instruction using the current
 #igration context.


 #.g.::

 #rop_table("accounts")

 #param table_name: Name of the table
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_exists: If True, adds IF EXISTS operator when
 #ropping the table.

 #. versionadded:: 1.13.3
 #param \**kw: Other keyword arguments are passed to the underlying
 #class:`sqlalchemy.schema.Table` object created for the command.

 #""  # noqa: E501
 #..

 #ef drop_table_comment(
 #elf,
 #able_name: str,
 #,
 #xisting_comment: Optional[str] = None,
 #chema: Optional[str] = None,
 # -> None:
 #""Issue a "drop table comment" operation to
 #emove an existing comment set on a table.

 #param table_name: string name of the target table.
 #param existing_comment: An optional string value of a comment already
 #egistered on the specified table.

 #. seealso::

 #meth:`.Operations.create_table_comment`

 #paramref:`.Operations.alter_column.comment`

 #""  # noqa: E501
 #..

 #ef execute(
 #elf,
 #qltext: Union[Executable, str],
 #,
 #xecution_options: Optional[dict[str, Any]] = None,
 # -> None:
 #"""Execute the given SQL using the current migration context.

 #he given SQL can be a plain string, e.g.::

 #p.execute("INSERT INTO table (foo) VALUES ('some value')")

 #r it can be any kind of Core SQL Expression construct, such as
 #elow where we use an update construct::

 #rom sqlalchemy.sql import table, column
 #rom sqlalchemy import String
 #rom alembic import op

 #ccount = table("account", column("name", String))
 #p.execute(
 #ccount.update()
 #where(account.c.name == op.inline_literal("account 1"))
 #values({"name": op.inline_literal("account 2")})
 #

 #bove, we made use of the SQLAlchemy
 #func:`sqlalchemy.sql.expression.table` and
 #func:`sqlalchemy.sql.expression.column` constructs to make a brief,
 #d-hoc table construct just for our UPDATE statement.  A full
 #class:`~sqlalchemy.schema.Table` construct of course works perfectly
 #ine as well, though note it's a recommended practice to at least
 #nsure the definition of a table is self-contained within the migration
 #cript, rather than imported from a module that may break compatibility
 #ith older migrations.

 #n a SQL script context, the statement is emitted directly to the
 #utput stream.   There is *no* return result, however, as this
 #unction is oriented towards generating a change script
 #hat can run in "offline" mode.     Additionally, parameterized
 #tatements are discouraged here, as they *will not work* in offline
 #ode.  Above, we use :meth:`.inline_literal` where parameters are
 #o be used.

 #or full interaction with a connected database where parameters can
 #lso be used normally, use the "bind" available from the context::

 #rom alembic import op

 #onnection = op.get_bind()

 #onnection.execute(
 #ccount.update()
 #where(account.c.name == "account 1")
 #values({"name": "account 2"})
 #

 #dditionally, when passing the statement as a plain string, it is first
 #oerced into a :func:`sqlalchemy.sql.expression.text` construct
 #efore being passed along.  In the less likely case that the
 #iteral SQL string contains a colon, it must be escaped with a
 #ackslash, as::

 #p.execute(r"INSERT INTO table (foo) VALUES ('\:colon_value')")


 #param sqltext: Any legal SQLAlchemy expression, including:

 # a string
 # a :func:`sqlalchemy.sql.expression.text` construct.
 # a :func:`sqlalchemy.sql.expression.insert` construct.
 # a :func:`sqlalchemy.sql.expression.update` construct.
 # a :func:`sqlalchemy.sql.expression.delete` construct.
 # Any "executable" described in SQLAlchemy Core documentation,
 #oting that no result set is returned.

 #. note::  when passing a plain string, the statement is coerced into
 # :func:`sqlalchemy.sql.expression.text` construct. This construct
 #onsiders symbols with colons, e.g. ``:foo`` to be bound parameters.
 #o avoid this, ensure that colon symbols are escaped, e.g.
 #`\:foo``.

 #param execution_options: Optional dictionary of
 #xecution options, will be passed to
 #meth:`sqlalchemy.engine.Connection.execution_options`.
 #""  # noqa: E501
 #..

 #ef rename_table(
 #elf,
 #ld_table_name: str,
 #ew_table_name: str,
 #,
 #chema: Optional[str] = None,
 # -> None:
 #""Emit an ALTER TABLE to rename a table.

 #param old_table_name: old name.
 #param new_table_name: new name.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #""  # noqa: E501
 #..

        # END STUB FUNCTIONS: op_cls


class BatchOperations(AbstractOperations):
 #""Modifies the interface :class:`.Operations` for batch mode.

 #his basically omits the ``table_name`` and ``schema`` parameters
 #rom associated methods, as these are a given when running under batch
 #ode.

 #. seealso::

 #meth:`.Operations.batch_alter_table`

 #ote that as of 0.8, most of the methods on this class are produced
 #ynamically using the :meth:`.Operations.register_operation`
 #ethod.

 #""

 #mpl: BatchOperationsImpl

 #ef _noop(self, operation: Any) -> NoReturn:
 #aise NotImplementedError(
 #The %s method does not apply to a batch table alter operation."
 # operation
 #

 #f TYPE_CHECKING:
        # START STUB FUNCTIONS: batch_op
        # ### the following stubs are generated by tools/write_pyi.py ###
        # ### do not edit ###

 #ef add_column(
 #elf,
 #olumn: Column[Any],
 #,
 #nsert_before: Optional[str] = None,
 #nsert_after: Optional[str] = None,
 #f_not_exists: Optional[bool] = None,
 # -> None:
 #""Issue an "add column" instruction using the current
 #atch migration context.

 #. seealso::

 #meth:`.Operations.add_column`

 #""  # noqa: E501
 #..

 #ef alter_column(
 #elf,
 #olumn_name: str,
 #,
 #ullable: Optional[bool] = None,
 #omment: Union[str, Literal[False], None] = False,
 #erver_default: Any = False,
 #ew_column_name: Optional[str] = None,
 #ype_: Union[TypeEngine[Any], Type[TypeEngine[Any]], None] = None,
 #xisting_type: Union[
 #ypeEngine[Any], Type[TypeEngine[Any]], None
 # = None,
 #xisting_server_default: Union[
 #tr, bool, Identity, Computed, None
 # = False,
 #xisting_nullable: Optional[bool] = None,
 #xisting_comment: Optional[str] = None,
 #nsert_before: Optional[str] = None,
 #nsert_after: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #""Issue an "alter column" instruction using the current
 #atch migration context.

 #arameters are the same as that of :meth:`.Operations.alter_column`,
 #s well as the following option(s):

 #param insert_before: String name of an existing column which this
 #olumn should be placed before, when creating the new table.

 #param insert_after: String name of an existing column which this
 #olumn should be placed after, when creating the new table.  If
 #oth :paramref:`.BatchOperations.alter_column.insert_before`
 #nd :paramref:`.BatchOperations.alter_column.insert_after` are
 #mitted, the column is inserted after the last existing column
 #n the table.

 #. seealso::

 #meth:`.Operations.alter_column`


 #""  # noqa: E501
 #..

 #ef create_check_constraint(
 #elf,
 #onstraint_name: str,
 #ondition: Union[str, ColumnElement[bool], TextClause],
 #*kw: Any,
 # -> None:
 #""Issue a "create check constraint" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``source`` and ``schema``
 #rguments from the call.

 #. seealso::

 #meth:`.Operations.create_check_constraint`

 #""  # noqa: E501
 #..

 #ef create_exclude_constraint(
 #elf, constraint_name: str, *elements: Any, **kw: Any
 # -> Optional[Table]:
 #""Issue a "create exclude constraint" instruction using the
 #urrent batch migration context.

 #. note::  This method is Postgresql specific, and additionally
 #equires at least SQLAlchemy 1.0.

 #. seealso::

 #meth:`.Operations.create_exclude_constraint`

 #""  # noqa: E501
 #..

 #ef create_foreign_key(
 #elf,
 #onstraint_name: Optional[str],
 #eferent_table: str,
 #ocal_cols: List[str],
 #emote_cols: List[str],
 #,
 #eferent_schema: Optional[str] = None,
 #nupdate: Optional[str] = None,
 #ndelete: Optional[str] = None,
 #eferrable: Optional[bool] = None,
 #nitially: Optional[str] = None,
 #atch: Optional[str] = None,
 #*dialect_kw: Any,
 # -> None:
 #""Issue a "create foreign key" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``source`` and ``source_schema``
 #rguments from the call.

 #.g.::

 #ith batch_alter_table("address") as batch_op:
 #atch_op.create_foreign_key(
 #fk_user_address",
 #user",
 #"user_id"],
 #"id"],
 #

 #. seealso::

 #meth:`.Operations.create_foreign_key`

 #""  # noqa: E501
 #..

 #ef create_index(
 #elf, index_name: str, columns: List[str], **kw: Any
 # -> None:
 #""Issue a "create index" instruction using the
 #urrent batch migration context.

 #. seealso::

 #meth:`.Operations.create_index`

 #""  # noqa: E501
 #..

 #ef create_primary_key(
 #elf, constraint_name: Optional[str], columns: List[str]
 # -> None:
 #""Issue a "create primary key" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``table_name`` and ``schema``
 #rguments from the call.

 #. seealso::

 #meth:`.Operations.create_primary_key`

 #""  # noqa: E501
 #..

 #ef create_table_comment(
 #elf,
 #omment: Optional[str],
 #,
 #xisting_comment: Optional[str] = None,
 # -> None:
 #""Emit a COMMENT ON operation to set the comment for a table
 #sing the current batch migration context.

 #param comment: string value of the comment being registered against
 #he specified table.
 #param existing_comment: String value of a comment
 #lready registered on the specified table, used within autogenerate
 #o that the operation is reversible, but not required for direct
 #se.

 #""  # noqa: E501
 #..

 #ef create_unique_constraint(
 #elf, constraint_name: str, columns: Sequence[str], **kw: Any
 # -> Any:
 #""Issue a "create unique constraint" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``source`` and ``schema``
 #rguments from the call.

 #. seealso::

 #meth:`.Operations.create_unique_constraint`

 #""  # noqa: E501
 #..

 #ef drop_column(self, column_name: str, **kw: Any) -> None:
 #""Issue a "drop column" instruction using the current
 #atch migration context.

 #. seealso::

 #meth:`.Operations.drop_column`

 #""  # noqa: E501
 #..

 #ef drop_constraint(
 #elf, constraint_name: str, type_: Optional[str] = None
 # -> None:
 #""Issue a "drop constraint" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``table_name`` and ``schema``
 #rguments from the call.

 #. seealso::

 #meth:`.Operations.drop_constraint`

 #""  # noqa: E501
 #..

 #ef drop_index(self, index_name: str, **kw: Any) -> None:
 #""Issue a "drop index" instruction using the
 #urrent batch migration context.

 #. seealso::

 #meth:`.Operations.drop_index`

 #""  # noqa: E501
 #..

 #ef drop_table_comment(
 #elf, *, existing_comment: Optional[str] = None
 # -> None:
 #""Issue a "drop table comment" operation to
 #emove an existing comment set on a table using the current
 #atch operations context.

 #param existing_comment: An optional string value of a comment already
 #egistered on the specified table.

 #""  # noqa: E501
 #..

 #ef execute(
 #elf,
 #qltext: Union[Executable, str],
 #,
 #xecution_options: Optional[dict[str, Any]] = None,
 # -> None:
 #""Execute the given SQL using the current migration context.

 #. seealso::

 #meth:`.Operations.execute`

 #""  # noqa: E501
 #..

        # END STUB FUNCTIONS: batch_op
