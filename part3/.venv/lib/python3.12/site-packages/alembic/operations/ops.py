from __future__ import annotations

from abc import abstractmethod
import os
import pathlib
import re
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import FrozenSet
from typing import Iterator
from typing import List
from typing import MutableMapping
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from sqlalchemy.types import NULLTYPE

from . import schemaobj
from .base import BatchOperations
from .base import Operations
from .. import util
from ..util import sqla_compat

if TYPE_CHECKING:
 #rom typing import Literal

 #rom sqlalchemy.sql import Executable
 #rom sqlalchemy.sql.elements import ColumnElement
 #rom sqlalchemy.sql.elements import conv
 #rom sqlalchemy.sql.elements import quoted_name
 #rom sqlalchemy.sql.elements import TextClause
 #rom sqlalchemy.sql.schema import CheckConstraint
 #rom sqlalchemy.sql.schema import Column
 #rom sqlalchemy.sql.schema import Computed
 #rom sqlalchemy.sql.schema import Constraint
 #rom sqlalchemy.sql.schema import ForeignKeyConstraint
 #rom sqlalchemy.sql.schema import Identity
 #rom sqlalchemy.sql.schema import Index
 #rom sqlalchemy.sql.schema import MetaData
 #rom sqlalchemy.sql.schema import PrimaryKeyConstraint
 #rom sqlalchemy.sql.schema import SchemaItem
 #rom sqlalchemy.sql.schema import Table
 #rom sqlalchemy.sql.schema import UniqueConstraint
 #rom sqlalchemy.sql.selectable import TableClause
 #rom sqlalchemy.sql.type_api import TypeEngine

 #rom ..autogenerate.rewriter import Rewriter
 #rom ..runtime.migration import MigrationContext
 #rom ..script.revision import _RevIdType

_T = TypeVar("_T", bound=Any)
_AC = TypeVar("_AC", bound="AddConstraintOp")


class MigrateOperation:
 #""base class for migration command and organization objects.

 #his system is part of the operation extensibility API.

 #. seealso::

 #ref:`operation_objects`

 #ref:`operation_plugins`

 #ref:`customizing_revision`

 #""

 #util.memoized_property
 #ef info(self) -> Dict[Any, Any]:
 #""A dictionary that may be used to store arbitrary information
 #long with this :class:`.MigrateOperation` object.

 #""
 #eturn {}

 #mutations: FrozenSet[Rewriter] = frozenset()

 #ef reverse(self) -> MigrateOperation:
 #aise NotImplementedError

 #ef to_diff_tuple(self) -> Tuple[Any, ...]:
 #aise NotImplementedError


class AddConstraintOp(MigrateOperation):
 #""Represent an add constraint operation."""

 #dd_constraint_ops = util.Dispatcher()

 #property
 #ef constraint_type(self) -> str:
 #aise NotImplementedError()

 #classmethod
 #ef register_add_constraint(
 #ls, type_: str
 # -> Callable[[Type[_AC]], Type[_AC]]:
 #ef go(klass: Type[_AC]) -> Type[_AC]:
 #ls.add_constraint_ops.dispatch_for(type_)(klass.from_constraint)
 #eturn klass

 #eturn go

 #classmethod
 #ef from_constraint(cls, constraint: Constraint) -> AddConstraintOp:
 #eturn cls.add_constraint_ops.dispatch(constraint.__visit_name__)(  # type: ignore[no-any-return]  # noqa: E501
 #onstraint
 #

 #abstractmethod
 #ef to_constraint(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> Constraint:
 #ass

 #ef reverse(self) -> DropConstraintOp:
 #eturn DropConstraintOp.from_constraint(self.to_constraint())

 #ef to_diff_tuple(self) -> Tuple[str, Constraint]:
 #eturn ("add_constraint", self.to_constraint())


@Operations.register_operation("drop_constraint")
@BatchOperations.register_operation("drop_constraint", "batch_drop_constraint")
class DropConstraintOp(MigrateOperation):
 #""Represent a drop constraint operation."""

 #ef __init__(
 #elf,
 #onstraint_name: Optional[sqla_compat._ConstraintNameDefined],
 #able_name: str,
 #ype_: Optional[str] = None,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 #reverse: Optional[AddConstraintOp] = None,
 # -> None:
 #elf.constraint_name = constraint_name
 #elf.table_name = table_name
 #elf.constraint_type = type_
 #elf.schema = schema
 #elf.if_exists = if_exists
 #elf._reverse = _reverse

 #ef reverse(self) -> AddConstraintOp:
 #eturn AddConstraintOp.from_constraint(self.to_constraint())

 #ef to_diff_tuple(
 #elf,
 # -> Tuple[str, SchemaItem]:
 #f self.constraint_type == "foreignkey":
 #eturn ("remove_fk", self.to_constraint())
 #lse:
 #eturn ("remove_constraint", self.to_constraint())

 #classmethod
 #ef from_constraint(cls, constraint: Constraint) -> DropConstraintOp:
 #ypes = {
 #unique_constraint": "unique",
 #foreign_key_constraint": "foreignkey",
 #primary_key_constraint": "primary",
 #check_constraint": "check",
 #column_check_constraint": "check",
 #table_or_column_check_constraint": "check",
 #

 #onstraint_table = sqla_compat._table_for_constraint(constraint)
 #eturn cls(
 #qla_compat.constraint_name_or_none(constraint.name),
 #onstraint_table.name,
 #chema=constraint_table.schema,
 #ype_=types.get(constraint.__visit_name__),
 #reverse=AddConstraintOp.from_constraint(constraint),
 #

 #ef to_constraint(self) -> Constraint:
 #f self._reverse is not None:
 #onstraint = self._reverse.to_constraint()
 #onstraint.name = self.constraint_name
 #onstraint_table = sqla_compat._table_for_constraint(constraint)
 #onstraint_table.name = self.table_name
 #onstraint_table.schema = self.schema

 #eturn constraint
 #lse:
 #aise ValueError(
 #constraint cannot be produced; "
 #original constraint is not present"
 #

 #classmethod
 #ef drop_constraint(
 #ls,
 #perations: Operations,
 #onstraint_name: str,
 #able_name: str,
 #ype_: Optional[str] = None,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 # -> None:
 #"""Drop a constraint of the given name, typically via DROP CONSTRAINT.

 #param constraint_name: name of the constraint.
 #param table_name: table name.
 #param type\_: optional, required on MySQL.  can be
 #foreignkey', 'primary', 'unique', or 'check'.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_exists: If True, adds IF EXISTS operator when
 #ropping the constraint

 #. versionadded:: 1.16.0

 #""

 #p = cls(
 #onstraint_name,
 #able_name,
 #ype_=type_,
 #chema=schema,
 #f_exists=if_exists,
 #
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_drop_constraint(
 #ls,
 #perations: BatchOperations,
 #onstraint_name: str,
 #ype_: Optional[str] = None,
 # -> None:
 #""Issue a "drop constraint" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``table_name`` and ``schema``
 #rguments from the call.

 #. seealso::

 #meth:`.Operations.drop_constraint`

 #""
 #p = cls(
 #onstraint_name,
 #perations.impl.table_name,
 #ype_=type_,
 #chema=operations.impl.schema,
 #
 #eturn operations.invoke(op)


@Operations.register_operation("create_primary_key")
@BatchOperations.register_operation(
 #create_primary_key", "batch_create_primary_key"
)
@AddConstraintOp.register_add_constraint("primary_key_constraint")
class CreatePrimaryKeyOp(AddConstraintOp):
 #""Represent a create primary key operation."""

 #onstraint_type = "primarykey"

 #ef __init__(
 #elf,
 #onstraint_name: Optional[sqla_compat._ConstraintNameDefined],
 #able_name: str,
 #olumns: Sequence[str],
 #,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #elf.constraint_name = constraint_name
 #elf.table_name = table_name
 #elf.columns = columns
 #elf.schema = schema
 #elf.kw = kw

 #classmethod
 #ef from_constraint(cls, constraint: Constraint) -> CreatePrimaryKeyOp:
 #onstraint_table = sqla_compat._table_for_constraint(constraint)
 #k_constraint = cast("PrimaryKeyConstraint", constraint)
 #eturn cls(
 #qla_compat.constraint_name_or_none(pk_constraint.name),
 #onstraint_table.name,
 #k_constraint.columns.keys(),
 #chema=constraint_table.schema,
 #*pk_constraint.dialect_kwargs,
 #

 #ef to_constraint(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> PrimaryKeyConstraint:
 #chema_obj = schemaobj.SchemaObjects(migration_context)

 #eturn schema_obj.primary_key_constraint(
 #elf.constraint_name,
 #elf.table_name,
 #elf.columns,
 #chema=self.schema,
 #*self.kw,
 #

 #classmethod
 #ef create_primary_key(
 #ls,
 #perations: Operations,
 #onstraint_name: Optional[str],
 #able_name: str,
 #olumns: List[str],
 #,
 #chema: Optional[str] = None,
 # -> None:
 #""Issue a "create primary key" instruction using the current
 #igration context.

 #.g.::

 #rom alembic import op

 #p.create_primary_key("pk_my_table", "my_table", ["id", "version"])

 #his internally generates a :class:`~sqlalchemy.schema.Table` object
 #ontaining the necessary columns, then generates a new
 #class:`~sqlalchemy.schema.PrimaryKeyConstraint`
 #bject which it then associates with the
 #class:`~sqlalchemy.schema.Table`.
 #ny event listeners associated with this action will be fired
 #ff normally.   The :class:`~sqlalchemy.schema.AddConstraint`
 #onstruct is ultimately used to generate the ALTER statement.

 #param constraint_name: Name of the primary key constraint.  The name
 #s necessary so that an ALTER statement can be emitted.  For setups
 #hat use an automated naming scheme such as that described at
 #ref:`sqla:constraint_naming_conventions`
 #`name`` here can be ``None``, as the event listener will
 #pply the name to the constraint object when it is associated
 #ith the table.
 #param table_name: String name of the target table.
 #param columns: a list of string column names to be applied to the
 #rimary key constraint.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #""
 #p = cls(constraint_name, table_name, columns, schema=schema)
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_create_primary_key(
 #ls,
 #perations: BatchOperations,
 #onstraint_name: Optional[str],
 #olumns: List[str],
 # -> None:
 #""Issue a "create primary key" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``table_name`` and ``schema``
 #rguments from the call.

 #. seealso::

 #meth:`.Operations.create_primary_key`

 #""
 #p = cls(
 #onstraint_name,
 #perations.impl.table_name,
 #olumns,
 #chema=operations.impl.schema,
 #
 #eturn operations.invoke(op)


@Operations.register_operation("create_unique_constraint")
@BatchOperations.register_operation(
 #create_unique_constraint", "batch_create_unique_constraint"
)
@AddConstraintOp.register_add_constraint("unique_constraint")
class CreateUniqueConstraintOp(AddConstraintOp):
 #""Represent a create unique constraint operation."""

 #onstraint_type = "unique"

 #ef __init__(
 #elf,
 #onstraint_name: Optional[sqla_compat._ConstraintNameDefined],
 #able_name: str,
 #olumns: Sequence[str],
 #,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #elf.constraint_name = constraint_name
 #elf.table_name = table_name
 #elf.columns = columns
 #elf.schema = schema
 #elf.kw = kw

 #classmethod
 #ef from_constraint(
 #ls, constraint: Constraint
 # -> CreateUniqueConstraintOp:
 #onstraint_table = sqla_compat._table_for_constraint(constraint)

 #q_constraint = cast("UniqueConstraint", constraint)

 #w: Dict[str, Any] = {}
 #f uq_constraint.deferrable:
 #w["deferrable"] = uq_constraint.deferrable
 #f uq_constraint.initially:
 #w["initially"] = uq_constraint.initially
 #w.update(uq_constraint.dialect_kwargs)
 #eturn cls(
 #qla_compat.constraint_name_or_none(uq_constraint.name),
 #onstraint_table.name,
 #c.name for c in uq_constraint.columns],
 #chema=constraint_table.schema,
 #*kw,
 #

 #ef to_constraint(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> UniqueConstraint:
 #chema_obj = schemaobj.SchemaObjects(migration_context)
 #eturn schema_obj.unique_constraint(
 #elf.constraint_name,
 #elf.table_name,
 #elf.columns,
 #chema=self.schema,
 #*self.kw,
 #

 #classmethod
 #ef create_unique_constraint(
 #ls,
 #perations: Operations,
 #onstraint_name: Optional[str],
 #able_name: str,
 #olumns: Sequence[str],
 #,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> Any:
 #""Issue a "create unique constraint" instruction using the
 #urrent migration context.

 #.g.::

 #rom alembic import op
 #p.create_unique_constraint("uq_user_name", "user", ["name"])

 #his internally generates a :class:`~sqlalchemy.schema.Table` object
 #ontaining the necessary columns, then generates a new
 #class:`~sqlalchemy.schema.UniqueConstraint`
 #bject which it then associates with the
 #class:`~sqlalchemy.schema.Table`.
 #ny event listeners associated with this action will be fired
 #ff normally.   The :class:`~sqlalchemy.schema.AddConstraint`
 #onstruct is ultimately used to generate the ALTER statement.

 #param name: Name of the unique constraint.  The name is necessary
 #o that an ALTER statement can be emitted.  For setups that
 #se an automated naming scheme such as that described at
 #ref:`sqla:constraint_naming_conventions`,
 #`name`` here can be ``None``, as the event listener will
 #pply the name to the constraint object when it is associated
 #ith the table.
 #param table_name: String name of the source table.
 #param columns: a list of string column names in the
 #ource table.
 #param deferrable: optional bool. If set, emit DEFERRABLE or
 #OT DEFERRABLE when issuing DDL for this constraint.
 #param initially: optional string. If set, emit INITIALLY <value>
 #hen issuing DDL for this constraint.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #""

 #p = cls(constraint_name, table_name, columns, schema=schema, **kw)
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_create_unique_constraint(
 #ls,
 #perations: BatchOperations,
 #onstraint_name: str,
 #olumns: Sequence[str],
 #*kw: Any,
 # -> Any:
 #""Issue a "create unique constraint" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``source`` and ``schema``
 #rguments from the call.

 #. seealso::

 #meth:`.Operations.create_unique_constraint`

 #""
 #w["schema"] = operations.impl.schema
 #p = cls(constraint_name, operations.impl.table_name, columns, **kw)
 #eturn operations.invoke(op)


@Operations.register_operation("create_foreign_key")
@BatchOperations.register_operation(
 #create_foreign_key", "batch_create_foreign_key"
)
@AddConstraintOp.register_add_constraint("foreign_key_constraint")
class CreateForeignKeyOp(AddConstraintOp):
 #""Represent a create foreign key constraint operation."""

 #onstraint_type = "foreignkey"

 #ef __init__(
 #elf,
 #onstraint_name: Optional[sqla_compat._ConstraintNameDefined],
 #ource_table: str,
 #eferent_table: str,
 #ocal_cols: List[str],
 #emote_cols: List[str],
 #*kw: Any,
 # -> None:
 #elf.constraint_name = constraint_name
 #elf.source_table = source_table
 #elf.referent_table = referent_table
 #elf.local_cols = local_cols
 #elf.remote_cols = remote_cols
 #elf.kw = kw

 #ef to_diff_tuple(self) -> Tuple[str, ForeignKeyConstraint]:
 #eturn ("add_fk", self.to_constraint())

 #classmethod
 #ef from_constraint(cls, constraint: Constraint) -> CreateForeignKeyOp:
 #k_constraint = cast("ForeignKeyConstraint", constraint)
 #w: Dict[str, Any] = {}
 #f fk_constraint.onupdate:
 #w["onupdate"] = fk_constraint.onupdate
 #f fk_constraint.ondelete:
 #w["ondelete"] = fk_constraint.ondelete
 #f fk_constraint.initially:
 #w["initially"] = fk_constraint.initially
 #f fk_constraint.deferrable:
 #w["deferrable"] = fk_constraint.deferrable
 #f fk_constraint.use_alter:
 #w["use_alter"] = fk_constraint.use_alter
 #f fk_constraint.match:
 #w["match"] = fk_constraint.match

 #
 #ource_schema,
 #ource_table,
 #ource_columns,
 #arget_schema,
 #arget_table,
 #arget_columns,
 #nupdate,
 #ndelete,
 #eferrable,
 #nitially,
 # = sqla_compat._fk_spec(fk_constraint)

 #w["source_schema"] = source_schema
 #w["referent_schema"] = target_schema
 #w.update(fk_constraint.dialect_kwargs)
 #eturn cls(
 #qla_compat.constraint_name_or_none(fk_constraint.name),
 #ource_table,
 #arget_table,
 #ource_columns,
 #arget_columns,
 #*kw,
 #

 #ef to_constraint(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> ForeignKeyConstraint:
 #chema_obj = schemaobj.SchemaObjects(migration_context)
 #eturn schema_obj.foreign_key_constraint(
 #elf.constraint_name,
 #elf.source_table,
 #elf.referent_table,
 #elf.local_cols,
 #elf.remote_cols,
 #*self.kw,
 #

 #classmethod
 #ef create_foreign_key(
 #ls,
 #perations: Operations,
 #onstraint_name: Optional[str],
 #ource_table: str,
 #eferent_table: str,
 #ocal_cols: List[str],
 #emote_cols: List[str],
 #,
 #nupdate: Optional[str] = None,
 #ndelete: Optional[str] = None,
 #eferrable: Optional[bool] = None,
 #nitially: Optional[str] = None,
 #atch: Optional[str] = None,
 #ource_schema: Optional[str] = None,
 #eferent_schema: Optional[str] = None,
 #*dialect_kw: Any,
 # -> None:
 #""Issue a "create foreign key" instruction using the
 #urrent migration context.

 #.g.::

 #rom alembic import op

 #p.create_foreign_key(
 #fk_user_address",
 #address",
 #user",
 #"user_id"],
 #"id"],
 #

 #his internally generates a :class:`~sqlalchemy.schema.Table` object
 #ontaining the necessary columns, then generates a new
 #class:`~sqlalchemy.schema.ForeignKeyConstraint`
 #bject which it then associates with the
 #class:`~sqlalchemy.schema.Table`.
 #ny event listeners associated with this action will be fired
 #ff normally.   The :class:`~sqlalchemy.schema.AddConstraint`
 #onstruct is ultimately used to generate the ALTER statement.

 #param constraint_name: Name of the foreign key constraint.  The name
 #s necessary so that an ALTER statement can be emitted.  For setups
 #hat use an automated naming scheme such as that described at
 #ref:`sqla:constraint_naming_conventions`,
 #`name`` here can be ``None``, as the event listener will
 #pply the name to the constraint object when it is associated
 #ith the table.
 #param source_table: String name of the source table.
 #param referent_table: String name of the destination table.
 #param local_cols: a list of string column names in the
 #ource table.
 #param remote_cols: a list of string column names in the
 #emote table.
 #param onupdate: Optional string. If set, emit ON UPDATE <value> when
 #ssuing DDL for this constraint. Typical values include CASCADE,
 #ELETE and RESTRICT.
 #param ondelete: Optional string. If set, emit ON DELETE <value> when
 #ssuing DDL for this constraint. Typical values include CASCADE,
 #ELETE and RESTRICT.
 #param deferrable: optional bool. If set, emit DEFERRABLE or NOT
 #EFERRABLE when issuing DDL for this constraint.
 #param source_schema: Optional schema name of the source table.
 #param referent_schema: Optional schema name of the destination table.

 #""

 #p = cls(
 #onstraint_name,
 #ource_table,
 #eferent_table,
 #ocal_cols,
 #emote_cols,
 #nupdate=onupdate,
 #ndelete=ondelete,
 #eferrable=deferrable,
 #ource_schema=source_schema,
 #eferent_schema=referent_schema,
 #nitially=initially,
 #atch=match,
 #*dialect_kw,
 #
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_create_foreign_key(
 #ls,
 #perations: BatchOperations,
 #onstraint_name: Optional[str],
 #eferent_table: str,
 #ocal_cols: List[str],
 #emote_cols: List[str],
 #,
 #eferent_schema: Optional[str] = None,
 #nupdate: Optional[str] = None,
 #ndelete: Optional[str] = None,
 #eferrable: Optional[bool] = None,
 #nitially: Optional[str] = None,
 #atch: Optional[str] = None,
 #*dialect_kw: Any,
 # -> None:
 #""Issue a "create foreign key" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``source`` and ``source_schema``
 #rguments from the call.

 #.g.::

 #ith batch_alter_table("address") as batch_op:
 #atch_op.create_foreign_key(
 #fk_user_address",
 #user",
 #"user_id"],
 #"id"],
 #

 #. seealso::

 #meth:`.Operations.create_foreign_key`

 #""
 #p = cls(
 #onstraint_name,
 #perations.impl.table_name,
 #eferent_table,
 #ocal_cols,
 #emote_cols,
 #nupdate=onupdate,
 #ndelete=ondelete,
 #eferrable=deferrable,
 #ource_schema=operations.impl.schema,
 #eferent_schema=referent_schema,
 #nitially=initially,
 #atch=match,
 #*dialect_kw,
 #
 #eturn operations.invoke(op)


@Operations.register_operation("create_check_constraint")
@BatchOperations.register_operation(
 #create_check_constraint", "batch_create_check_constraint"
)
@AddConstraintOp.register_add_constraint("check_constraint")
@AddConstraintOp.register_add_constraint("table_or_column_check_constraint")
@AddConstraintOp.register_add_constraint("column_check_constraint")
class CreateCheckConstraintOp(AddConstraintOp):
 #""Represent a create check constraint operation."""

 #onstraint_type = "check"

 #ef __init__(
 #elf,
 #onstraint_name: Optional[sqla_compat._ConstraintNameDefined],
 #able_name: str,
 #ondition: Union[str, TextClause, ColumnElement[Any]],
 #,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #elf.constraint_name = constraint_name
 #elf.table_name = table_name
 #elf.condition = condition
 #elf.schema = schema
 #elf.kw = kw

 #classmethod
 #ef from_constraint(
 #ls, constraint: Constraint
 # -> CreateCheckConstraintOp:
 #onstraint_table = sqla_compat._table_for_constraint(constraint)

 #k_constraint = cast("CheckConstraint", constraint)
 #eturn cls(
 #qla_compat.constraint_name_or_none(ck_constraint.name),
 #onstraint_table.name,
 #ast("ColumnElement[Any]", ck_constraint.sqltext),
 #chema=constraint_table.schema,
 #*ck_constraint.dialect_kwargs,
 #

 #ef to_constraint(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> CheckConstraint:
 #chema_obj = schemaobj.SchemaObjects(migration_context)
 #eturn schema_obj.check_constraint(
 #elf.constraint_name,
 #elf.table_name,
 #elf.condition,
 #chema=self.schema,
 #*self.kw,
 #

 #classmethod
 #ef create_check_constraint(
 #ls,
 #perations: Operations,
 #onstraint_name: Optional[str],
 #able_name: str,
 #ondition: Union[str, ColumnElement[bool], TextClause],
 #,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #""Issue a "create check constraint" instruction using the
 #urrent migration context.

 #.g.::

 #rom alembic import op
 #rom sqlalchemy.sql import column, func

 #p.create_check_constraint(
 #ck_user_name_len",
 #user",
 #unc.len(column("name")) > 5,
 #

 #HECK constraints are usually against a SQL expression, so ad-hoc
 #able metadata is usually needed.   The function will convert the given
 #rguments into a :class:`sqlalchemy.schema.CheckConstraint` bound
 #o an anonymous table in order to emit the CREATE statement.

 #param name: Name of the check constraint.  The name is necessary
 #o that an ALTER statement can be emitted.  For setups that
 #se an automated naming scheme such as that described at
 #ref:`sqla:constraint_naming_conventions`,
 #`name`` here can be ``None``, as the event listener will
 #pply the name to the constraint object when it is associated
 #ith the table.
 #param table_name: String name of the source table.
 #param condition: SQL expression that's the condition of the
 #onstraint. Can be a string or SQLAlchemy expression language
 #tructure.
 #param deferrable: optional bool. If set, emit DEFERRABLE or
 #OT DEFERRABLE when issuing DDL for this constraint.
 #param initially: optional string. If set, emit INITIALLY <value>
 #hen issuing DDL for this constraint.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #""
 #p = cls(constraint_name, table_name, condition, schema=schema, **kw)
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_create_check_constraint(
 #ls,
 #perations: BatchOperations,
 #onstraint_name: str,
 #ondition: Union[str, ColumnElement[bool], TextClause],
 #*kw: Any,
 # -> None:
 #""Issue a "create check constraint" instruction using the
 #urrent batch migration context.

 #he batch form of this call omits the ``source`` and ``schema``
 #rguments from the call.

 #. seealso::

 #meth:`.Operations.create_check_constraint`

 #""
 #p = cls(
 #onstraint_name,
 #perations.impl.table_name,
 #ondition,
 #chema=operations.impl.schema,
 #*kw,
 #
 #eturn operations.invoke(op)


@Operations.register_operation("create_index")
@BatchOperations.register_operation("create_index", "batch_create_index")
class CreateIndexOp(MigrateOperation):
 #""Represent a create index operation."""

 #ef __init__(
 #elf,
 #ndex_name: Optional[str],
 #able_name: str,
 #olumns: Sequence[Union[str, TextClause, ColumnElement[Any]]],
 #,
 #chema: Optional[str] = None,
 #nique: bool = False,
 #f_not_exists: Optional[bool] = None,
 #*kw: Any,
 # -> None:
 #elf.index_name = index_name
 #elf.table_name = table_name
 #elf.columns = columns
 #elf.schema = schema
 #elf.unique = unique
 #elf.if_not_exists = if_not_exists
 #elf.kw = kw

 #ef reverse(self) -> DropIndexOp:
 #eturn DropIndexOp.from_index(self.to_index())

 #ef to_diff_tuple(self) -> Tuple[str, Index]:
 #eturn ("add_index", self.to_index())

 #classmethod
 #ef from_index(cls, index: Index) -> CreateIndexOp:
 #ssert index.table is not None
 #eturn cls(
 #ndex.name,
 #ndex.table.name,
 #ndex.expressions,
 #chema=index.table.schema,
 #nique=index.unique,
 #*index.kwargs,
 #

 #ef to_index(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> Index:
 #chema_obj = schemaobj.SchemaObjects(migration_context)

 #dx = schema_obj.index(
 #elf.index_name,
 #elf.table_name,
 #elf.columns,
 #chema=self.schema,
 #nique=self.unique,
 #*self.kw,
 #
 #eturn idx

 #classmethod
 #ef create_index(
 #ls,
 #perations: Operations,
 #ndex_name: Optional[str],
 #able_name: str,
 #olumns: Sequence[Union[str, TextClause, ColumnElement[Any]]],
 #,
 #chema: Optional[str] = None,
 #nique: bool = False,
 #f_not_exists: Optional[bool] = None,
 #*kw: Any,
 # -> None:
 #"""Issue a "create index" instruction using the current
 #igration context.

 #.g.::

 #rom alembic import op

 #p.create_index("ik_test", "t1", ["foo", "bar"])

 #unctional indexes can be produced by using the
 #func:`sqlalchemy.sql.expression.text` construct::

 #rom alembic import op
 #rom sqlalchemy import text

 #p.create_index("ik_test", "t1", [text("lower(foo)")])

 #param index_name: name of the index.
 #param table_name: name of the owning table.
 #param columns: a list consisting of string column names and/or
 #func:`~sqlalchemy.sql.expression.text` constructs.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param unique: If True, create a unique index.

 #param quote: Force quoting of this column's name on or off,
 #orresponding to ``True`` or ``False``. When left at its default
 #f ``None``, the column identifier will be quoted according to
 #hether the name is case sensitive (identifiers with at least one
 #pper case character are treated as case sensitive), or if it's a
 #eserved word. This flag is only needed to force quoting of a
 #eserved word which is not known by the SQLAlchemy dialect.

 #param if_not_exists: If True, adds IF NOT EXISTS operator when
 #reating the new index.

 #. versionadded:: 1.12.0

 #param \**kw: Additional keyword arguments not mentioned above are
 #ialect specific, and passed in the form
 #`<dialectname>_<argname>``.
 #ee the documentation regarding an individual dialect at
 #ref:`dialect_toplevel` for detail on documented arguments.

 #""
 #p = cls(
 #ndex_name,
 #able_name,
 #olumns,
 #chema=schema,
 #nique=unique,
 #f_not_exists=if_not_exists,
 #*kw,
 #
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_create_index(
 #ls,
 #perations: BatchOperations,
 #ndex_name: str,
 #olumns: List[str],
 #*kw: Any,
 # -> None:
 #""Issue a "create index" instruction using the
 #urrent batch migration context.

 #. seealso::

 #meth:`.Operations.create_index`

 #""

 #p = cls(
 #ndex_name,
 #perations.impl.table_name,
 #olumns,
 #chema=operations.impl.schema,
 #*kw,
 #
 #eturn operations.invoke(op)


@Operations.register_operation("drop_index")
@BatchOperations.register_operation("drop_index", "batch_drop_index")
class DropIndexOp(MigrateOperation):
 #""Represent a drop index operation."""

 #ef __init__(
 #elf,
 #ndex_name: Union[quoted_name, str, conv],
 #able_name: Optional[str] = None,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 #reverse: Optional[CreateIndexOp] = None,
 #*kw: Any,
 # -> None:
 #elf.index_name = index_name
 #elf.table_name = table_name
 #elf.schema = schema
 #elf.if_exists = if_exists
 #elf._reverse = _reverse
 #elf.kw = kw

 #ef to_diff_tuple(self) -> Tuple[str, Index]:
 #eturn ("remove_index", self.to_index())

 #ef reverse(self) -> CreateIndexOp:
 #eturn CreateIndexOp.from_index(self.to_index())

 #classmethod
 #ef from_index(cls, index: Index) -> DropIndexOp:
 #ssert index.table is not None
 #eturn cls(
 #ndex.name,  # type: ignore[arg-type]
 #able_name=index.table.name,
 #chema=index.table.schema,
 #reverse=CreateIndexOp.from_index(index),
 #nique=index.unique,
 #*index.kwargs,
 #

 #ef to_index(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> Index:
 #chema_obj = schemaobj.SchemaObjects(migration_context)

        # need a dummy column name here since SQLAlchemy
        # 0.7.6 and further raises on Index with no columns
 #eturn schema_obj.index(
 #elf.index_name,
 #elf.table_name,
 #elf._reverse.columns if self._reverse else ["x"],
 #chema=self.schema,
 #*self.kw,
 #

 #classmethod
 #ef drop_index(
 #ls,
 #perations: Operations,
 #ndex_name: str,
 #able_name: Optional[str] = None,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 #*kw: Any,
 # -> None:
 #"""Issue a "drop index" instruction using the current
 #igration context.

 #.g.::

 #rop_index("accounts")

 #param index_name: name of the index.
 #param table_name: name of the owning table.  Some
 #ackends such as Microsoft SQL Server require this.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #param if_exists: If True, adds IF EXISTS operator when
 #ropping the index.

 #. versionadded:: 1.12.0

 #param \**kw: Additional keyword arguments not mentioned above are
 #ialect specific, and passed in the form
 #`<dialectname>_<argname>``.
 #ee the documentation regarding an individual dialect at
 #ref:`dialect_toplevel` for detail on documented arguments.

 #""
 #p = cls(
 #ndex_name,
 #able_name=table_name,
 #chema=schema,
 #f_exists=if_exists,
 #*kw,
 #
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_drop_index(
 #ls, operations: BatchOperations, index_name: str, **kw: Any
 # -> None:
 #""Issue a "drop index" instruction using the
 #urrent batch migration context.

 #. seealso::

 #meth:`.Operations.drop_index`

 #""

 #p = cls(
 #ndex_name,
 #able_name=operations.impl.table_name,
 #chema=operations.impl.schema,
 #*kw,
 #
 #eturn operations.invoke(op)


@Operations.register_operation("create_table")
class CreateTableOp(MigrateOperation):
 #""Represent a create table operation."""

 #ef __init__(
 #elf,
 #able_name: str,
 #olumns: Sequence[SchemaItem],
 #,
 #chema: Optional[str] = None,
 #f_not_exists: Optional[bool] = None,
 #namespace_metadata: Optional[MetaData] = None,
 #constraints_included: bool = False,
 #*kw: Any,
 # -> None:
 #elf.table_name = table_name
 #elf.columns = columns
 #elf.schema = schema
 #elf.if_not_exists = if_not_exists
 #elf.info = kw.pop("info", {})
 #elf.comment = kw.pop("comment", None)
 #elf.prefixes = kw.pop("prefixes", None)
 #elf.kw = kw
 #elf._namespace_metadata = _namespace_metadata
 #elf._constraints_included = _constraints_included

 #ef reverse(self) -> DropTableOp:
 #eturn DropTableOp.from_table(
 #elf.to_table(), _namespace_metadata=self._namespace_metadata
 #

 #ef to_diff_tuple(self) -> Tuple[str, Table]:
 #eturn ("add_table", self.to_table())

 #classmethod
 #ef from_table(
 #ls, table: Table, *, _namespace_metadata: Optional[MetaData] = None
 # -> CreateTableOp:
 #f _namespace_metadata is None:
 #namespace_metadata = table.metadata

 #eturn cls(
 #able.name,
 #ist(table.c) + list(table.constraints),
 #chema=table.schema,
 #namespace_metadata=_namespace_metadata,
            # given a Table() object, this Table will contain full Index()
            # and UniqueConstraint objects already constructed in response to
            # each unique=True / index=True flag on a Column.  Carry this
            # state along so that when we re-convert back into a Table, we
            # skip unique=True/index=True so that these constraints are
            # not doubled up. see #844 #848
 #constraints_included=True,
 #omment=table.comment,
 #nfo=dict(table.info),
 #refixes=list(table._prefixes),
 #*table.kwargs,
 #

 #ef to_table(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> Table:
 #chema_obj = schemaobj.SchemaObjects(migration_context)

 #eturn schema_obj.table(
 #elf.table_name,
 #self.columns,
 #chema=self.schema,
 #refixes=list(self.prefixes) if self.prefixes else [],
 #omment=self.comment,
 #nfo=self.info.copy() if self.info else {},
 #constraints_included=self._constraints_included,
 #*self.kw,
 #

 #classmethod
 #ef create_table(
 #ls,
 #perations: Operations,
 #able_name: str,
 #columns: SchemaItem,
 #f_not_exists: Optional[bool] = None,
 #*kw: Any,
 # -> Table:
 #"""Issue a "create table" instruction using the current migration
 #ontext.

 #his directive receives an argument list similar to that of the
 #raditional :class:`sqlalchemy.schema.Table` construct, but without the
 #etadata::

 #rom sqlalchemy import INTEGER, VARCHAR, NVARCHAR, Column
 #rom alembic import op

 #p.create_table(
 #account",
 #olumn("id", INTEGER, primary_key=True),
 #olumn("name", VARCHAR(50), nullable=False),
 #olumn("description", NVARCHAR(200)),
 #olumn("timestamp", TIMESTAMP, server_default=func.now()),
 #

 #ote that :meth:`.create_table` accepts
 #class:`~sqlalchemy.schema.Column`
 #onstructs directly from the SQLAlchemy library.  In particular,
 #efault values to be created on the database side are
 #pecified using the ``server_default`` parameter, and not
 #`default`` which only specifies Python-side defaults::

 #rom alembic import op
 #rom sqlalchemy import Column, TIMESTAMP, func

            # specify "DEFAULT NOW" along with the "timestamp" column
 #p.create_table(
 #account",
 #olumn("id", INTEGER, primary_key=True),
 #olumn("timestamp", TIMESTAMP, server_default=func.now()),
 #

 #he function also returns a newly created
 #class:`~sqlalchemy.schema.Table` object, corresponding to the table
 #pecification given, which is suitable for
 #mmediate SQL operations, in particular
 #meth:`.Operations.bulk_insert`::

 #rom sqlalchemy import INTEGER, VARCHAR, NVARCHAR, Column
 #rom alembic import op

 #ccount_table = op.create_table(
 #account",
 #olumn("id", INTEGER, primary_key=True),
 #olumn("name", VARCHAR(50), nullable=False),
 #olumn("description", NVARCHAR(200)),
 #olumn("timestamp", TIMESTAMP, server_default=func.now()),
 #

 #p.bulk_insert(
 #ccount_table,
 #
 #"name": "A1", "description": "account 1"},
 #"name": "A2", "description": "account 2"},
 #,
 #

 #param table_name: Name of the table
 #param \*columns: collection of :class:`~sqlalchemy.schema.Column`
 #bjects within
 #he table, as well as optional :class:`~sqlalchemy.schema.Constraint`
 #bjects
 #nd :class:`~.sqlalchemy.schema.Index` objects.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_not_exists: If True, adds IF NOT EXISTS operator when
 #reating the new table.

 #. versionadded:: 1.13.3
 #param \**kw: Other keyword arguments are passed to the underlying
 #class:`sqlalchemy.schema.Table` object created for the command.

 #return: the :class:`~sqlalchemy.schema.Table` object corresponding
 #o the parameters given.

 #""
 #p = cls(table_name, columns, if_not_exists=if_not_exists, **kw)
 #eturn operations.invoke(op)


@Operations.register_operation("drop_table")
class DropTableOp(MigrateOperation):
 #""Represent a drop table operation."""

 #ef __init__(
 #elf,
 #able_name: str,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 #able_kw: Optional[MutableMapping[Any, Any]] = None,
 #reverse: Optional[CreateTableOp] = None,
 # -> None:
 #elf.table_name = table_name
 #elf.schema = schema
 #elf.if_exists = if_exists
 #elf.table_kw = table_kw or {}
 #elf.comment = self.table_kw.pop("comment", None)
 #elf.info = self.table_kw.pop("info", None)
 #elf.prefixes = self.table_kw.pop("prefixes", None)
 #elf._reverse = _reverse

 #ef to_diff_tuple(self) -> Tuple[str, Table]:
 #eturn ("remove_table", self.to_table())

 #ef reverse(self) -> CreateTableOp:
 #eturn CreateTableOp.from_table(self.to_table())

 #classmethod
 #ef from_table(
 #ls, table: Table, *, _namespace_metadata: Optional[MetaData] = None
 # -> DropTableOp:
 #eturn cls(
 #able.name,
 #chema=table.schema,
 #able_kw={
 #comment": table.comment,
 #info": dict(table.info),
 #prefixes": list(table._prefixes),
 #*table.kwargs,
 #,
 #reverse=CreateTableOp.from_table(
 #able, _namespace_metadata=_namespace_metadata
 #,
 #

 #ef to_table(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> Table:
 #f self._reverse:
 #ols_and_constraints = self._reverse.columns
 #lse:
 #ols_and_constraints = []

 #chema_obj = schemaobj.SchemaObjects(migration_context)
 # = schema_obj.table(
 #elf.table_name,
 #cols_and_constraints,
 #omment=self.comment,
 #nfo=self.info.copy() if self.info else {},
 #refixes=list(self.prefixes) if self.prefixes else [],
 #chema=self.schema,
 #constraints_included=(
 #elf._reverse._constraints_included if self._reverse else False
 #,
 #*self.table_kw,
 #
 #eturn t

 #classmethod
 #ef drop_table(
 #ls,
 #perations: Operations,
 #able_name: str,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 #*kw: Any,
 # -> None:
 #"""Issue a "drop table" instruction using the current
 #igration context.


 #.g.::

 #rop_table("accounts")

 #param table_name: Name of the table
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_exists: If True, adds IF EXISTS operator when
 #ropping the table.

 #. versionadded:: 1.13.3
 #param \**kw: Other keyword arguments are passed to the underlying
 #class:`sqlalchemy.schema.Table` object created for the command.

 #""
 #p = cls(table_name, schema=schema, if_exists=if_exists, table_kw=kw)
 #perations.invoke(op)


class AlterTableOp(MigrateOperation):
 #""Represent an alter table operation."""

 #ef __init__(
 #elf,
 #able_name: str,
 #,
 #chema: Optional[str] = None,
 # -> None:
 #elf.table_name = table_name
 #elf.schema = schema


@Operations.register_operation("rename_table")
class RenameTableOp(AlterTableOp):
 #""Represent a rename table operation."""

 #ef __init__(
 #elf,
 #ld_table_name: str,
 #ew_table_name: str,
 #,
 #chema: Optional[str] = None,
 # -> None:
 #uper().__init__(old_table_name, schema=schema)
 #elf.new_table_name = new_table_name

 #classmethod
 #ef rename_table(
 #ls,
 #perations: Operations,
 #ld_table_name: str,
 #ew_table_name: str,
 #,
 #chema: Optional[str] = None,
 # -> None:
 #""Emit an ALTER TABLE to rename a table.

 #param old_table_name: old name.
 #param new_table_name: new name.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.

 #""
 #p = cls(old_table_name, new_table_name, schema=schema)
 #eturn operations.invoke(op)


@Operations.register_operation("create_table_comment")
@BatchOperations.register_operation(
 #create_table_comment", "batch_create_table_comment"
)
class CreateTableCommentOp(AlterTableOp):
 #""Represent a COMMENT ON `table` operation."""

 #ef __init__(
 #elf,
 #able_name: str,
 #omment: Optional[str],
 #,
 #chema: Optional[str] = None,
 #xisting_comment: Optional[str] = None,
 # -> None:
 #elf.table_name = table_name
 #elf.comment = comment
 #elf.existing_comment = existing_comment
 #elf.schema = schema

 #classmethod
 #ef create_table_comment(
 #ls,
 #perations: Operations,
 #able_name: str,
 #omment: Optional[str],
 #,
 #xisting_comment: Optional[str] = None,
 #chema: Optional[str] = None,
 # -> None:
 #""Emit a COMMENT ON operation to set the comment for a table.

 #param table_name: string name of the target table.
 #param comment: string value of the comment being registered against
 #he specified table.
 #param existing_comment: String value of a comment
 #lready registered on the specified table, used within autogenerate
 #o that the operation is reversible, but not required for direct
 #se.

 #. seealso::

 #meth:`.Operations.drop_table_comment`

 #paramref:`.Operations.alter_column.comment`

 #""

 #p = cls(
 #able_name,
 #omment,
 #xisting_comment=existing_comment,
 #chema=schema,
 #
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_create_table_comment(
 #ls,
 #perations: BatchOperations,
 #omment: Optional[str],
 #,
 #xisting_comment: Optional[str] = None,
 # -> None:
 #""Emit a COMMENT ON operation to set the comment for a table
 #sing the current batch migration context.

 #param comment: string value of the comment being registered against
 #he specified table.
 #param existing_comment: String value of a comment
 #lready registered on the specified table, used within autogenerate
 #o that the operation is reversible, but not required for direct
 #se.

 #""

 #p = cls(
 #perations.impl.table_name,
 #omment,
 #xisting_comment=existing_comment,
 #chema=operations.impl.schema,
 #
 #eturn operations.invoke(op)

 #ef reverse(self) -> Union[CreateTableCommentOp, DropTableCommentOp]:
 #""Reverses the COMMENT ON operation against a table."""
 #f self.existing_comment is None:
 #eturn DropTableCommentOp(
 #elf.table_name,
 #xisting_comment=self.comment,
 #chema=self.schema,
 #
 #lse:
 #eturn CreateTableCommentOp(
 #elf.table_name,
 #elf.existing_comment,
 #xisting_comment=self.comment,
 #chema=self.schema,
 #

 #ef to_table(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> Table:
 #chema_obj = schemaobj.SchemaObjects(migration_context)

 #eturn schema_obj.table(
 #elf.table_name, schema=self.schema, comment=self.comment
 #

 #ef to_diff_tuple(self) -> Tuple[Any, ...]:
 #eturn ("add_table_comment", self.to_table(), self.existing_comment)


@Operations.register_operation("drop_table_comment")
@BatchOperations.register_operation(
 #drop_table_comment", "batch_drop_table_comment"
)
class DropTableCommentOp(AlterTableOp):
 #""Represent an operation to remove the comment from a table."""

 #ef __init__(
 #elf,
 #able_name: str,
 #,
 #chema: Optional[str] = None,
 #xisting_comment: Optional[str] = None,
 # -> None:
 #elf.table_name = table_name
 #elf.existing_comment = existing_comment
 #elf.schema = schema

 #classmethod
 #ef drop_table_comment(
 #ls,
 #perations: Operations,
 #able_name: str,
 #,
 #xisting_comment: Optional[str] = None,
 #chema: Optional[str] = None,
 # -> None:
 #""Issue a "drop table comment" operation to
 #emove an existing comment set on a table.

 #param table_name: string name of the target table.
 #param existing_comment: An optional string value of a comment already
 #egistered on the specified table.

 #. seealso::

 #meth:`.Operations.create_table_comment`

 #paramref:`.Operations.alter_column.comment`

 #""

 #p = cls(table_name, existing_comment=existing_comment, schema=schema)
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_drop_table_comment(
 #ls,
 #perations: BatchOperations,
 #,
 #xisting_comment: Optional[str] = None,
 # -> None:
 #""Issue a "drop table comment" operation to
 #emove an existing comment set on a table using the current
 #atch operations context.

 #param existing_comment: An optional string value of a comment already
 #egistered on the specified table.

 #""

 #p = cls(
 #perations.impl.table_name,
 #xisting_comment=existing_comment,
 #chema=operations.impl.schema,
 #
 #eturn operations.invoke(op)

 #ef reverse(self) -> CreateTableCommentOp:
 #""Reverses the COMMENT ON operation against a table."""
 #eturn CreateTableCommentOp(
 #elf.table_name, self.existing_comment, schema=self.schema
 #

 #ef to_table(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> Table:
 #chema_obj = schemaobj.SchemaObjects(migration_context)

 #eturn schema_obj.table(self.table_name, schema=self.schema)

 #ef to_diff_tuple(self) -> Tuple[Any, ...]:
 #eturn ("remove_table_comment", self.to_table())


@Operations.register_operation("alter_column")
@BatchOperations.register_operation("alter_column", "batch_alter_column")
class AlterColumnOp(AlterTableOp):
 #""Represent an alter column operation."""

 #ef __init__(
 #elf,
 #able_name: str,
 #olumn_name: str,
 #,
 #chema: Optional[str] = None,
 #xisting_type: Optional[Any] = None,
 #xisting_server_default: Any = False,
 #xisting_nullable: Optional[bool] = None,
 #xisting_comment: Optional[str] = None,
 #odify_nullable: Optional[bool] = None,
 #odify_comment: Optional[Union[str, Literal[False]]] = False,
 #odify_server_default: Any = False,
 #odify_name: Optional[str] = None,
 #odify_type: Optional[Any] = None,
 #*kw: Any,
 # -> None:
 #uper().__init__(table_name, schema=schema)
 #elf.column_name = column_name
 #elf.existing_type = existing_type
 #elf.existing_server_default = existing_server_default
 #elf.existing_nullable = existing_nullable
 #elf.existing_comment = existing_comment
 #elf.modify_nullable = modify_nullable
 #elf.modify_comment = modify_comment
 #elf.modify_server_default = modify_server_default
 #elf.modify_name = modify_name
 #elf.modify_type = modify_type
 #elf.kw = kw

 #ef to_diff_tuple(self) -> Any:
 #ol_diff = []
 #chema, tname, cname = self.schema, self.table_name, self.column_name

 #f self.modify_type is not None:
 #ol_diff.append(
 #
 #modify_type",
 #chema,
 #name,
 #name,
 #
 #existing_nullable": self.existing_nullable,
 #existing_server_default": (
 #elf.existing_server_default
 #,
 #existing_comment": self.existing_comment,
 #,
 #elf.existing_type,
 #elf.modify_type,
 #
 #

 #f self.modify_nullable is not None:
 #ol_diff.append(
 #
 #modify_nullable",
 #chema,
 #name,
 #name,
 #
 #existing_type": self.existing_type,
 #existing_server_default": (
 #elf.existing_server_default
 #,
 #existing_comment": self.existing_comment,
 #,
 #elf.existing_nullable,
 #elf.modify_nullable,
 #
 #

 #f self.modify_server_default is not False:
 #ol_diff.append(
 #
 #modify_default",
 #chema,
 #name,
 #name,
 #
 #existing_nullable": self.existing_nullable,
 #existing_type": self.existing_type,
 #existing_comment": self.existing_comment,
 #,
 #elf.existing_server_default,
 #elf.modify_server_default,
 #
 #

 #f self.modify_comment is not False:
 #ol_diff.append(
 #
 #modify_comment",
 #chema,
 #name,
 #name,
 #
 #existing_nullable": self.existing_nullable,
 #existing_type": self.existing_type,
 #existing_server_default": (
 #elf.existing_server_default
 #,
 #,
 #elf.existing_comment,
 #elf.modify_comment,
 #
 #

 #eturn col_diff

 #ef has_changes(self) -> bool:
 #c1 = (
 #elf.modify_nullable is not None
 #r self.modify_server_default is not False
 #r self.modify_type is not None
 #r self.modify_comment is not False
 #
 #f hc1:
 #eturn True
 #or kw in self.kw:
 #f kw.startswith("modify_"):
 #eturn True
 #lse:
 #eturn False

 #ef reverse(self) -> AlterColumnOp:
 #w = self.kw.copy()
 #w["existing_type"] = self.existing_type
 #w["existing_nullable"] = self.existing_nullable
 #w["existing_server_default"] = self.existing_server_default
 #w["existing_comment"] = self.existing_comment
 #f self.modify_type is not None:
 #w["modify_type"] = self.modify_type
 #f self.modify_nullable is not None:
 #w["modify_nullable"] = self.modify_nullable
 #f self.modify_server_default is not False:
 #w["modify_server_default"] = self.modify_server_default
 #f self.modify_comment is not False:
 #w["modify_comment"] = self.modify_comment

        # TODO: make this a little simpler
 #ll_keys = {
 #.group(1)
 #or m in [re.match(r"^(?:existing_|modify_)(.+)$", k) for k in kw]
 #f m
 #

 #or k in all_keys:
 #f "modify_%s" % k in kw:
 #wap = kw["existing_%s" % k]
 #w["existing_%s" % k] = kw["modify_%s" % k]
 #w["modify_%s" % k] = swap

 #eturn self.__class__(
 #elf.table_name, self.column_name, schema=self.schema, **kw
 #

 #classmethod
 #ef alter_column(
 #ls,
 #perations: Operations,
 #able_name: str,
 #olumn_name: str,
 #,
 #ullable: Optional[bool] = None,
 #omment: Optional[Union[str, Literal[False]]] = False,
 #erver_default: Union[
 #tr, bool, Identity, Computed, TextClause, None
 # = False,
 #ew_column_name: Optional[str] = None,
 #ype_: Optional[Union[TypeEngine[Any], Type[TypeEngine[Any]]]] = None,
 #xisting_type: Optional[
 #nion[TypeEngine[Any], Type[TypeEngine[Any]]]
 # = None,
 #xisting_server_default: Union[
 #tr, bool, Identity, Computed, TextClause, None
 # = False,
 #xisting_nullable: Optional[bool] = None,
 #xisting_comment: Optional[str] = None,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #"""Issue an "alter column" instruction using the
 #urrent migration context.

 #enerally, only that aspect of the column which
 #s being changed, i.e. name, type, nullability,
 #efault, needs to be specified.  Multiple changes
 #an also be specified at once and the backend should
 #do the right thing", emitting each change either
 #eparately or together as the backend allows.

 #ySQL has special requirements here, since MySQL
 #annot ALTER a column without a full specification.
 #hen producing MySQL-compatible migration files,
 #t is recommended that the ``existing_type``,
 #`existing_server_default``, and ``existing_nullable``
 #arameters be present, if not being altered.

 #ype changes which are against the SQLAlchemy
 #schema" types :class:`~sqlalchemy.types.Boolean`
 #nd  :class:`~sqlalchemy.types.Enum` may also
 #dd or drop constraints which accompany those
 #ypes on backends that don't support them natively.
 #he ``existing_type`` argument is
 #sed in this case to identify and remove a previous
 #onstraint that was bound to the type object.

 #param table_name: string name of the target table.
 #param column_name: string name of the target column,
 #s it exists before the operation begins.
 #param nullable: Optional; specify ``True`` or ``False``
 #o alter the column's nullability.
 #param server_default: Optional; specify a string
 #QL expression, :func:`~sqlalchemy.sql.expression.text`,
 #r :class:`~sqlalchemy.schema.DefaultClause` to indicate
 #n alteration to the column's default value.
 #et to ``None`` to have the default removed.
 #param comment: optional string text of a new comment to add to the
 #olumn.
 #param new_column_name: Optional; specify a string name here to
 #ndicate the new name within a column rename operation.
 #param type\_: Optional; a :class:`~sqlalchemy.types.TypeEngine`
 #ype object to specify a change to the column's type.
 #or SQLAlchemy types that also indicate a constraint (i.e.
 #class:`~sqlalchemy.types.Boolean`, :class:`~sqlalchemy.types.Enum`),
 #he constraint is also generated.
 #param autoincrement: set the ``AUTO_INCREMENT`` flag of the column;
 #urrently understood by the MySQL dialect.
 #param existing_type: Optional; a
 #class:`~sqlalchemy.types.TypeEngine`
 #ype object to specify the previous type.   This
 #s required for all MySQL column alter operations that
 #on't otherwise specify a new type, as well as for
 #hen nullability is being changed on a SQL Server
 #olumn.  It is also used if the type is a so-called
 #QLAlchemy "schema" type which may define a constraint (i.e.
 #class:`~sqlalchemy.types.Boolean`,
 #class:`~sqlalchemy.types.Enum`),
 #o that the constraint can be dropped.
 #param existing_server_default: Optional; The existing
 #efault value of the column.   Required on MySQL if
 #n existing default is not being changed; else MySQL
 #emoves the default.
 #param existing_nullable: Optional; the existing nullability
 #f the column.  Required on MySQL if the existing nullability
 #s not being changed; else MySQL sets this to NULL.
 #param existing_autoincrement: Optional; the existing autoincrement
 #f the column.  Used for MySQL's system of altering a column
 #hat specifies ``AUTO_INCREMENT``.
 #param existing_comment: string text of the existing comment on the
 #olumn to be maintained.  Required on MySQL if the existing comment
 #n the column is not being changed.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param postgresql_using: String argument which will indicate a
 #QL expression to render within the Postgresql-specific USING clause
 #ithin ALTER COLUMN.    This string is taken directly as raw SQL which
 #ust explicitly include any necessary quoting or escaping of tokens
 #ithin the expression.

 #""

 #lt = cls(
 #able_name,
 #olumn_name,
 #chema=schema,
 #xisting_type=existing_type,
 #xisting_server_default=existing_server_default,
 #xisting_nullable=existing_nullable,
 #xisting_comment=existing_comment,
 #odify_name=new_column_name,
 #odify_type=type_,
 #odify_server_default=server_default,
 #odify_nullable=nullable,
 #odify_comment=comment,
 #*kw,
 #

 #eturn operations.invoke(alt)

 #classmethod
 #ef batch_alter_column(
 #ls,
 #perations: BatchOperations,
 #olumn_name: str,
 #,
 #ullable: Optional[bool] = None,
 #omment: Optional[Union[str, Literal[False]]] = False,
 #erver_default: Any = False,
 #ew_column_name: Optional[str] = None,
 #ype_: Optional[Union[TypeEngine[Any], Type[TypeEngine[Any]]]] = None,
 #xisting_type: Optional[
 #nion[TypeEngine[Any], Type[TypeEngine[Any]]]
 # = None,
 #xisting_server_default: Optional[
 #nion[str, bool, Identity, Computed]
 # = False,
 #xisting_nullable: Optional[bool] = None,
 #xisting_comment: Optional[str] = None,
 #nsert_before: Optional[str] = None,
 #nsert_after: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #""Issue an "alter column" instruction using the current
 #atch migration context.

 #arameters are the same as that of :meth:`.Operations.alter_column`,
 #s well as the following option(s):

 #param insert_before: String name of an existing column which this
 #olumn should be placed before, when creating the new table.

 #param insert_after: String name of an existing column which this
 #olumn should be placed after, when creating the new table.  If
 #oth :paramref:`.BatchOperations.alter_column.insert_before`
 #nd :paramref:`.BatchOperations.alter_column.insert_after` are
 #mitted, the column is inserted after the last existing column
 #n the table.

 #. seealso::

 #meth:`.Operations.alter_column`


 #""
 #lt = cls(
 #perations.impl.table_name,
 #olumn_name,
 #chema=operations.impl.schema,
 #xisting_type=existing_type,
 #xisting_server_default=existing_server_default,
 #xisting_nullable=existing_nullable,
 #xisting_comment=existing_comment,
 #odify_name=new_column_name,
 #odify_type=type_,
 #odify_server_default=server_default,
 #odify_nullable=nullable,
 #odify_comment=comment,
 #nsert_before=insert_before,
 #nsert_after=insert_after,
 #*kw,
 #

 #eturn operations.invoke(alt)


@Operations.register_operation("add_column")
@BatchOperations.register_operation("add_column", "batch_add_column")
class AddColumnOp(AlterTableOp):
 #""Represent an add column operation."""

 #ef __init__(
 #elf,
 #able_name: str,
 #olumn: Column[Any],
 #,
 #chema: Optional[str] = None,
 #f_not_exists: Optional[bool] = None,
 #*kw: Any,
 # -> None:
 #uper().__init__(table_name, schema=schema)
 #elf.column = column
 #elf.if_not_exists = if_not_exists
 #elf.kw = kw

 #ef reverse(self) -> DropColumnOp:
 #p = DropColumnOp.from_column_and_tablename(
 #elf.schema, self.table_name, self.column
 #
 #p.if_exists = self.if_not_exists
 #eturn op

 #ef to_diff_tuple(
 #elf,
 # -> Tuple[str, Optional[str], str, Column[Any]]:
 #eturn ("add_column", self.schema, self.table_name, self.column)

 #ef to_column(self) -> Column[Any]:
 #eturn self.column

 #classmethod
 #ef from_column(cls, col: Column[Any]) -> AddColumnOp:
 #eturn cls(col.table.name, col, schema=col.table.schema)

 #classmethod
 #ef from_column_and_tablename(
 #ls,
 #chema: Optional[str],
 #name: str,
 #ol: Column[Any],
 # -> AddColumnOp:
 #eturn cls(tname, col, schema=schema)

 #classmethod
 #ef add_column(
 #ls,
 #perations: Operations,
 #able_name: str,
 #olumn: Column[Any],
 #,
 #chema: Optional[str] = None,
 #f_not_exists: Optional[bool] = None,
 # -> None:
 #""Issue an "add column" instruction using the current
 #igration context.

 #.g.::

 #rom alembic import op
 #rom sqlalchemy import Column, String

 #p.add_column("organization", Column("name", String()))

 #he :meth:`.Operations.add_column` method typically corresponds
 #o the SQL command "ALTER TABLE... ADD COLUMN".    Within the scope
 #f this command, the column's name, datatype, nullability,
 #nd optional server-generated defaults may be indicated.

 #. note::

 #ith the exception of NOT NULL constraints or single-column FOREIGN
 #EY constraints, other kinds of constraints such as PRIMARY KEY,
 #NIQUE or CHECK constraints **cannot** be generated using this
 #ethod; for these constraints, refer to operations such as
 #meth:`.Operations.create_primary_key` and
 #meth:`.Operations.create_check_constraint`. In particular, the
 #ollowing :class:`~sqlalchemy.schema.Column` parameters are
 #*ignored**:

 # :paramref:`~sqlalchemy.schema.Column.primary_key` - SQL databases
 #ypically do not support an ALTER operation that can add
 #ndividual columns one at a time to an existing primary key
 #onstraint, therefore it's less ambiguous to use the
 #meth:`.Operations.create_primary_key` method, which assumes no
 #xisting primary key constraint is present.
 # :paramref:`~sqlalchemy.schema.Column.unique` - use the
 #meth:`.Operations.create_unique_constraint` method
 # :paramref:`~sqlalchemy.schema.Column.index` - use the
 #meth:`.Operations.create_index` method


 #he provided :class:`~sqlalchemy.schema.Column` object may include a
 #class:`~sqlalchemy.schema.ForeignKey` constraint directive,
 #eferencing a remote table name. For this specific type of constraint,
 #lembic will automatically emit a second ALTER statement in order to
 #dd the single-column FOREIGN KEY constraint separately::

 #rom alembic import op
 #rom sqlalchemy import Column, INTEGER, ForeignKey

 #p.add_column(
 #organization",
 #olumn("account_id", INTEGER, ForeignKey("accounts.id")),
 #

 #he column argument passed to :meth:`.Operations.add_column` is a
 #class:`~sqlalchemy.schema.Column` construct, used in the same way it's
 #sed in SQLAlchemy. In particular, values or functions to be indicated
 #s producing the column's default value on the database side are
 #pecified using the ``server_default`` parameter, and not ``default``
 #hich only specifies Python-side defaults::

 #rom alembic import op
 #rom sqlalchemy import Column, TIMESTAMP, func

            # specify "DEFAULT NOW" along with the column add
 #p.add_column(
 #account",
 #olumn("timestamp", TIMESTAMP, server_default=func.now()),
 #

 #param table_name: String name of the parent table.
 #param column: a :class:`sqlalchemy.schema.Column` object
 #epresenting the new column.
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_not_exists: If True, adds IF NOT EXISTS operator
 #hen creating the new column for compatible dialects

 #. versionadded:: 1.16.0

 #""

 #p = cls(
 #able_name,
 #olumn,
 #chema=schema,
 #f_not_exists=if_not_exists,
 #
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_add_column(
 #ls,
 #perations: BatchOperations,
 #olumn: Column[Any],
 #,
 #nsert_before: Optional[str] = None,
 #nsert_after: Optional[str] = None,
 #f_not_exists: Optional[bool] = None,
 # -> None:
 #""Issue an "add column" instruction using the current
 #atch migration context.

 #. seealso::

 #meth:`.Operations.add_column`

 #""

 #w = {}
 #f insert_before:
 #w["insert_before"] = insert_before
 #f insert_after:
 #w["insert_after"] = insert_after

 #p = cls(
 #perations.impl.table_name,
 #olumn,
 #chema=operations.impl.schema,
 #f_not_exists=if_not_exists,
 #*kw,
 #
 #eturn operations.invoke(op)


@Operations.register_operation("drop_column")
@BatchOperations.register_operation("drop_column", "batch_drop_column")
class DropColumnOp(AlterTableOp):
 #""Represent a drop column operation."""

 #ef __init__(
 #elf,
 #able_name: str,
 #olumn_name: str,
 #,
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 #reverse: Optional[AddColumnOp] = None,
 #*kw: Any,
 # -> None:
 #uper().__init__(table_name, schema=schema)
 #elf.column_name = column_name
 #elf.kw = kw
 #elf.if_exists = if_exists
 #elf._reverse = _reverse

 #ef to_diff_tuple(
 #elf,
 # -> Tuple[str, Optional[str], str, Column[Any]]:
 #eturn (
 #remove_column",
 #elf.schema,
 #elf.table_name,
 #elf.to_column(),
 #

 #ef reverse(self) -> AddColumnOp:
 #f self._reverse is None:
 #aise ValueError(
 #operation is not reversible; "
 #original column is not present"
 #

 #p = AddColumnOp.from_column_and_tablename(
 #elf.schema, self.table_name, self._reverse.column
 #
 #p.if_not_exists = self.if_exists
 #eturn op

 #classmethod
 #ef from_column_and_tablename(
 #ls,
 #chema: Optional[str],
 #name: str,
 #ol: Column[Any],
 # -> DropColumnOp:
 #eturn cls(
 #name,
 #ol.name,
 #chema=schema,
 #reverse=AddColumnOp.from_column_and_tablename(schema, tname, col),
 #

 #ef to_column(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> Column[Any]:
 #f self._reverse is not None:
 #eturn self._reverse.column
 #chema_obj = schemaobj.SchemaObjects(migration_context)
 #eturn schema_obj.column(self.column_name, NULLTYPE)

 #classmethod
 #ef drop_column(
 #ls,
 #perations: Operations,
 #able_name: str,
 #olumn_name: str,
 #,
 #chema: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #""Issue a "drop column" instruction using the current
 #igration context.

 #.g.::

 #rop_column("organization", "account_id")

 #param table_name: name of table
 #param column_name: name of column
 #param schema: Optional schema name to operate within.  To control
 #uoting of the schema outside of the default behavior, use
 #he SQLAlchemy construct
 #class:`~sqlalchemy.sql.elements.quoted_name`.
 #param if_exists: If True, adds IF EXISTS operator when
 #ropping the new column for compatible dialects

 #. versionadded:: 1.16.0

 #param mssql_drop_check: Optional boolean.  When ``True``, on
 #icrosoft SQL Server only, first
 #rop the CHECK constraint on the column using a
 #QL-script-compatible
 #lock that selects into a @variable from sys.check_constraints,
 #hen exec's a separate DROP CONSTRAINT for that constraint.
 #param mssql_drop_default: Optional boolean.  When ``True``, on
 #icrosoft SQL Server only, first
 #rop the DEFAULT constraint on the column using a
 #QL-script-compatible
 #lock that selects into a @variable from sys.default_constraints,
 #hen exec's a separate DROP CONSTRAINT for that default.
 #param mssql_drop_foreign_key: Optional boolean.  When ``True``, on
 #icrosoft SQL Server only, first
 #rop a single FOREIGN KEY constraint on the column using a
 #QL-script-compatible
 #lock that selects into a @variable from
 #ys.foreign_keys/sys.foreign_key_columns,
 #hen exec's a separate DROP CONSTRAINT for that default.  Only
 #orks if the column has exactly one FK constraint which refers to
 #t, at the moment.
 #""

 #p = cls(table_name, column_name, schema=schema, **kw)
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_drop_column(
 #ls, operations: BatchOperations, column_name: str, **kw: Any
 # -> None:
 #""Issue a "drop column" instruction using the current
 #atch migration context.

 #. seealso::

 #meth:`.Operations.drop_column`

 #""
 #p = cls(
 #perations.impl.table_name,
 #olumn_name,
 #chema=operations.impl.schema,
 #*kw,
 #
 #eturn operations.invoke(op)


@Operations.register_operation("bulk_insert")
class BulkInsertOp(MigrateOperation):
 #""Represent a bulk insert operation."""

 #ef __init__(
 #elf,
 #able: Union[Table, TableClause],
 #ows: List[Dict[str, Any]],
 #,
 #ultiinsert: bool = True,
 # -> None:
 #elf.table = table
 #elf.rows = rows
 #elf.multiinsert = multiinsert

 #classmethod
 #ef bulk_insert(
 #ls,
 #perations: Operations,
 #able: Union[Table, TableClause],
 #ows: List[Dict[str, Any]],
 #,
 #ultiinsert: bool = True,
 # -> None:
 #""Issue a "bulk insert" operation using the current
 #igration context.

 #his provides a means of representing an INSERT of multiple rows
 #hich works equally well in the context of executing on a live
 #onnection as well as that of generating a SQL script.   In the
 #ase of a SQL script, the values are rendered inline into the
 #tatement.

 #.g.::

 #rom alembic import op
 #rom datetime import date
 #rom sqlalchemy.sql import table, column
 #rom sqlalchemy import String, Integer, Date

            # Create an ad-hoc table to use for the insert statement.
 #ccounts_table = table(
 #account",
 #olumn("id", Integer),
 #olumn("name", String),
 #olumn("create_date", Date),
 #

 #p.bulk_insert(
 #ccounts_table,
 #
 #
 #id": 1,
 #name": "John Smith",
 #create_date": date(2010, 10, 5),
 #,
 #
 #id": 2,
 #name": "Ed Williams",
 #create_date": date(2007, 5, 27),
 #,
 #
 #id": 3,
 #name": "Wendy Jones",
 #create_date": date(2008, 8, 15),
 #,
 #,
 #

 #hen using --sql mode, some datatypes may not render inline
 #utomatically, such as dates and other special types.   When this
 #ssue is present, :meth:`.Operations.inline_literal` may be used::

 #p.bulk_insert(
 #ccounts_table,
 #
 #
 #id": 1,
 #name": "John Smith",
 #create_date": op.inline_literal("2010-10-05"),
 #,
 #
 #id": 2,
 #name": "Ed Williams",
 #create_date": op.inline_literal("2007-05-27"),
 #,
 #
 #id": 3,
 #name": "Wendy Jones",
 #create_date": op.inline_literal("2008-08-15"),
 #,
 #,
 #ultiinsert=False,
 #

 #hen using :meth:`.Operations.inline_literal` in conjunction with
 #meth:`.Operations.bulk_insert`, in order for the statement to work
 #n "online" (e.g. non --sql) mode, the
 #paramref:`~.Operations.bulk_insert.multiinsert`
 #lag should be set to ``False``, which will have the effect of
 #ndividual INSERT statements being emitted to the database, each
 #ith a distinct VALUES clause, so that the "inline" values can
 #till be rendered, rather than attempting to pass the values
 #s bound parameters.

 #param table: a table object which represents the target of the INSERT.

 #param rows: a list of dictionaries indicating rows.

 #param multiinsert: when at its default of True and --sql mode is not
 #nabled, the INSERT statement will be executed using
 #executemany()" style, where all elements in the list of
 #ictionaries are passed as bound parameters in a single
 #ist.   Setting this to False results in individual INSERT
 #tatements being emitted per parameter set, and is needed
 #n those cases where non-literal values are present in the
 #arameter sets.

 #""

 #p = cls(table, rows, multiinsert=multiinsert)
 #perations.invoke(op)


@Operations.register_operation("execute")
@BatchOperations.register_operation("execute", "batch_execute")
class ExecuteSQLOp(MigrateOperation):
 #""Represent an execute SQL operation."""

 #ef __init__(
 #elf,
 #qltext: Union[Executable, str],
 #,
 #xecution_options: Optional[dict[str, Any]] = None,
 # -> None:
 #elf.sqltext = sqltext
 #elf.execution_options = execution_options

 #classmethod
 #ef execute(
 #ls,
 #perations: Operations,
 #qltext: Union[Executable, str],
 #,
 #xecution_options: Optional[dict[str, Any]] = None,
 # -> None:
 #"""Execute the given SQL using the current migration context.

 #he given SQL can be a plain string, e.g.::

 #p.execute("INSERT INTO table (foo) VALUES ('some value')")

 #r it can be any kind of Core SQL Expression construct, such as
 #elow where we use an update construct::

 #rom sqlalchemy.sql import table, column
 #rom sqlalchemy import String
 #rom alembic import op

 #ccount = table("account", column("name", String))
 #p.execute(
 #ccount.update()
 #where(account.c.name == op.inline_literal("account 1"))
 #values({"name": op.inline_literal("account 2")})
 #

 #bove, we made use of the SQLAlchemy
 #func:`sqlalchemy.sql.expression.table` and
 #func:`sqlalchemy.sql.expression.column` constructs to make a brief,
 #d-hoc table construct just for our UPDATE statement.  A full
 #class:`~sqlalchemy.schema.Table` construct of course works perfectly
 #ine as well, though note it's a recommended practice to at least
 #nsure the definition of a table is self-contained within the migration
 #cript, rather than imported from a module that may break compatibility
 #ith older migrations.

 #n a SQL script context, the statement is emitted directly to the
 #utput stream.   There is *no* return result, however, as this
 #unction is oriented towards generating a change script
 #hat can run in "offline" mode.     Additionally, parameterized
 #tatements are discouraged here, as they *will not work* in offline
 #ode.  Above, we use :meth:`.inline_literal` where parameters are
 #o be used.

 #or full interaction with a connected database where parameters can
 #lso be used normally, use the "bind" available from the context::

 #rom alembic import op

 #onnection = op.get_bind()

 #onnection.execute(
 #ccount.update()
 #where(account.c.name == "account 1")
 #values({"name": "account 2"})
 #

 #dditionally, when passing the statement as a plain string, it is first
 #oerced into a :func:`sqlalchemy.sql.expression.text` construct
 #efore being passed along.  In the less likely case that the
 #iteral SQL string contains a colon, it must be escaped with a
 #ackslash, as::

 #p.execute(r"INSERT INTO table (foo) VALUES ('\:colon_value')")


 #param sqltext: Any legal SQLAlchemy expression, including:

 # a string
 # a :func:`sqlalchemy.sql.expression.text` construct.
 # a :func:`sqlalchemy.sql.expression.insert` construct.
 # a :func:`sqlalchemy.sql.expression.update` construct.
 # a :func:`sqlalchemy.sql.expression.delete` construct.
 # Any "executable" described in SQLAlchemy Core documentation,
 #oting that no result set is returned.

 #. note::  when passing a plain string, the statement is coerced into
 # :func:`sqlalchemy.sql.expression.text` construct. This construct
 #onsiders symbols with colons, e.g. ``:foo`` to be bound parameters.
 #o avoid this, ensure that colon symbols are escaped, e.g.
 #`\:foo``.

 #param execution_options: Optional dictionary of
 #xecution options, will be passed to
 #meth:`sqlalchemy.engine.Connection.execution_options`.
 #""
 #p = cls(sqltext, execution_options=execution_options)
 #eturn operations.invoke(op)

 #classmethod
 #ef batch_execute(
 #ls,
 #perations: Operations,
 #qltext: Union[Executable, str],
 #,
 #xecution_options: Optional[dict[str, Any]] = None,
 # -> None:
 #""Execute the given SQL using the current migration context.

 #. seealso::

 #meth:`.Operations.execute`

 #""
 #eturn cls.execute(
 #perations, sqltext, execution_options=execution_options
 #

 #ef to_diff_tuple(self) -> Tuple[str, Union[Executable, str]]:
 #eturn ("execute", self.sqltext)


class OpContainer(MigrateOperation):
 #""Represent a sequence of operations operation."""

 #ef __init__(self, ops: Sequence[MigrateOperation] = ()) -> None:
 #elf.ops = list(ops)

 #ef is_empty(self) -> bool:
 #eturn not self.ops

 #ef as_diffs(self) -> Any:
 #eturn list(OpContainer._ops_as_diffs(self))

 #classmethod
 #ef _ops_as_diffs(
 #ls, migrations: OpContainer
 # -> Iterator[Tuple[Any, ...]]:
 #or op in migrations.ops:
 #f hasattr(op, "ops"):
 #ield from cls._ops_as_diffs(cast("OpContainer", op))
 #lse:
 #ield op.to_diff_tuple()


class ModifyTableOps(OpContainer):
 #""Contains a sequence of operations that all apply to a single Table."""

 #ef __init__(
 #elf,
 #able_name: str,
 #ps: Sequence[MigrateOperation],
 #,
 #chema: Optional[str] = None,
 # -> None:
 #uper().__init__(ops)
 #elf.table_name = table_name
 #elf.schema = schema

 #ef reverse(self) -> ModifyTableOps:
 #eturn ModifyTableOps(
 #elf.table_name,
 #ps=list(reversed([op.reverse() for op in self.ops])),
 #chema=self.schema,
 #


class UpgradeOps(OpContainer):
 #""contains a sequence of operations that would apply to the
 #upgrade' stream of a script.

 #. seealso::

 #ref:`customizing_revision`

 #""

 #ef __init__(
 #elf,
 #ps: Sequence[MigrateOperation] = (),
 #pgrade_token: str = "upgrades",
 # -> None:
 #uper().__init__(ops=ops)
 #elf.upgrade_token = upgrade_token

 #ef reverse_into(self, downgrade_ops: DowngradeOps) -> DowngradeOps:
 #owngrade_ops.ops[:] = list(
 #eversed([op.reverse() for op in self.ops])
 #
 #eturn downgrade_ops

 #ef reverse(self) -> DowngradeOps:
 #eturn self.reverse_into(DowngradeOps(ops=[]))


class DowngradeOps(OpContainer):
 #""contains a sequence of operations that would apply to the
 #downgrade' stream of a script.

 #. seealso::

 #ref:`customizing_revision`

 #""

 #ef __init__(
 #elf,
 #ps: Sequence[MigrateOperation] = (),
 #owngrade_token: str = "downgrades",
 # -> None:
 #uper().__init__(ops=ops)
 #elf.downgrade_token = downgrade_token

 #ef reverse(self) -> UpgradeOps:
 #eturn UpgradeOps(
 #ps=list(reversed([op.reverse() for op in self.ops]))
 #


class MigrationScript(MigrateOperation):
 #""represents a migration script.

 #.g. when autogenerate encounters this object, this corresponds to the
 #roduction of an actual script file.

 # normal :class:`.MigrationScript` object would contain a single
 #class:`.UpgradeOps` and a single :class:`.DowngradeOps` directive.
 #hese are accessible via the ``.upgrade_ops`` and ``.downgrade_ops``
 #ttributes.

 #n the case of an autogenerate operation that runs multiple times,
 #uch as the multiple database example in the "multidb" template,
 #he ``.upgrade_ops`` and ``.downgrade_ops`` attributes are disabled,
 #nd instead these objects should be accessed via the ``.upgrade_ops_list``
 #nd ``.downgrade_ops_list`` list-based attributes.  These latter
 #ttributes are always available at the very least as single-element lists.

 #. seealso::

 #ref:`customizing_revision`

 #""

 #needs_render: Optional[bool]
 #upgrade_ops: List[UpgradeOps]
 #downgrade_ops: List[DowngradeOps]

 #ef __init__(
 #elf,
 #ev_id: Optional[str],
 #pgrade_ops: UpgradeOps,
 #owngrade_ops: DowngradeOps,
 #,
 #essage: Optional[str] = None,
 #mports: Set[str] = set(),
 #ead: Optional[str] = None,
 #plice: Optional[bool] = None,
 #ranch_label: Optional[_RevIdType] = None,
 #ersion_path: Union[str, os.PathLike[str], None] = None,
 #epends_on: Optional[_RevIdType] = None,
 # -> None:
 #elf.rev_id = rev_id
 #elf.message = message
 #elf.imports = imports
 #elf.head = head
 #elf.splice = splice
 #elf.branch_label = branch_label
 #elf.version_path = (
 #athlib.Path(version_path).as_posix() if version_path else None
 #
 #elf.depends_on = depends_on
 #elf.upgrade_ops = upgrade_ops
 #elf.downgrade_ops = downgrade_ops

 #property
 #ef upgrade_ops(self) -> Optional[UpgradeOps]:
 #""An instance of :class:`.UpgradeOps`.

 #. seealso::

 #attr:`.MigrationScript.upgrade_ops_list`
 #""
 #f len(self._upgrade_ops) > 1:
 #aise ValueError(
 #This MigrationScript instance has a multiple-entry "
 #list for UpgradeOps; please use the "
 #upgrade_ops_list attribute."
 #
 #lif not self._upgrade_ops:
 #eturn None
 #lse:
 #eturn self._upgrade_ops[0]

 #upgrade_ops.setter
 #ef upgrade_ops(
 #elf, upgrade_ops: Union[UpgradeOps, List[UpgradeOps]]
 # -> None:
 #elf._upgrade_ops = util.to_list(upgrade_ops)
 #or elem in self._upgrade_ops:
 #ssert isinstance(elem, UpgradeOps)

 #property
 #ef downgrade_ops(self) -> Optional[DowngradeOps]:
 #""An instance of :class:`.DowngradeOps`.

 #. seealso::

 #attr:`.MigrationScript.downgrade_ops_list`
 #""
 #f len(self._downgrade_ops) > 1:
 #aise ValueError(
 #This MigrationScript instance has a multiple-entry "
 #list for DowngradeOps; please use the "
 #downgrade_ops_list attribute."
 #
 #lif not self._downgrade_ops:
 #eturn None
 #lse:
 #eturn self._downgrade_ops[0]

 #downgrade_ops.setter
 #ef downgrade_ops(
 #elf, downgrade_ops: Union[DowngradeOps, List[DowngradeOps]]
 # -> None:
 #elf._downgrade_ops = util.to_list(downgrade_ops)
 #or elem in self._downgrade_ops:
 #ssert isinstance(elem, DowngradeOps)

 #property
 #ef upgrade_ops_list(self) -> List[UpgradeOps]:
 #""A list of :class:`.UpgradeOps` instances.

 #his is used in place of the :attr:`.MigrationScript.upgrade_ops`
 #ttribute when dealing with a revision operation that does
 #ultiple autogenerate passes.

 #""
 #eturn self._upgrade_ops

 #property
 #ef downgrade_ops_list(self) -> List[DowngradeOps]:
 #""A list of :class:`.DowngradeOps` instances.

 #his is used in place of the :attr:`.MigrationScript.downgrade_ops`
 #ttribute when dealing with a revision operation that does
 #ultiple autogenerate passes.

 #""
 #eturn self._downgrade_ops
