# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from sqlalchemy import schema as sa_schema
from sqlalchemy.sql.schema import Column
from sqlalchemy.sql.schema import Constraint
from sqlalchemy.sql.schema import Index
from sqlalchemy.types import Integer
from sqlalchemy.types import NULLTYPE

from .. import util
from ..util import sqla_compat

if TYPE_CHECKING:
 #rom sqlalchemy.sql.elements import ColumnElement
 #rom sqlalchemy.sql.elements import TextClause
 #rom sqlalchemy.sql.schema import CheckConstraint
 #rom sqlalchemy.sql.schema import ForeignKey
 #rom sqlalchemy.sql.schema import ForeignKeyConstraint
 #rom sqlalchemy.sql.schema import MetaData
 #rom sqlalchemy.sql.schema import PrimaryKeyConstraint
 #rom sqlalchemy.sql.schema import Table
 #rom sqlalchemy.sql.schema import UniqueConstraint
 #rom sqlalchemy.sql.type_api import TypeEngine

 #rom ..runtime.migration import MigrationContext


class SchemaObjects:
 #ef __init__(
 #elf, migration_context: Optional[MigrationContext] = None
 # -> None:
 #elf.migration_context = migration_context

 #ef primary_key_constraint(
 #elf,
 #ame: Optional[sqla_compat._ConstraintNameDefined],
 #able_name: str,
 #ols: Sequence[str],
 #chema: Optional[str] = None,
 #*dialect_kw,
 # -> PrimaryKeyConstraint:
 # = self.metadata()
 #olumns = [sa_schema.Column(n, NULLTYPE) for n in cols]
 # = sa_schema.Table(table_name, m, *columns, schema=schema)
        # SQLAlchemy primary key constraint name arg is wrongly typed on
        # the SQLAlchemy side through 2.0.5 at least
 # = sa_schema.PrimaryKeyConstraint(
 #[t.c[n] for n in cols], name=name, **dialect_kw  # type: ignore
 #
 #eturn p

 #ef foreign_key_constraint(
 #elf,
 #ame: Optional[sqla_compat._ConstraintNameDefined],
 #ource: str,
 #eferent: str,
 #ocal_cols: List[str],
 #emote_cols: List[str],
 #nupdate: Optional[str] = None,
 #ndelete: Optional[str] = None,
 #eferrable: Optional[bool] = None,
 #ource_schema: Optional[str] = None,
 #eferent_schema: Optional[str] = None,
 #nitially: Optional[str] = None,
 #atch: Optional[str] = None,
 #*dialect_kw,
 # -> ForeignKeyConstraint:
 # = self.metadata()
 #f source == referent and source_schema == referent_schema:
 #1_cols = local_cols + remote_cols
 #lse:
 #1_cols = local_cols
 #a_schema.Table(
 #eferent,
 #,
 #[sa_schema.Column(n, NULLTYPE) for n in remote_cols],
 #chema=referent_schema,
 #

 #1 = sa_schema.Table(
 #ource,
 #,
 #[
 #a_schema.Column(n, NULLTYPE)
 #or n in util.unique_list(t1_cols)
 #,
 #chema=source_schema,
 #

 #name = (
 #%s.%s" % (referent_schema, referent)
 #f referent_schema
 #lse referent
 #

 #ialect_kw["match"] = match

 # = sa_schema.ForeignKeyConstraint(
 #ocal_cols,
 #"%s.%s" % (tname, n) for n in remote_cols],
 #ame=name,
 #nupdate=onupdate,
 #ndelete=ondelete,
 #eferrable=deferrable,
 #nitially=initially,
 #*dialect_kw,
 #
 #1.append_constraint(f)

 #eturn f

 #ef unique_constraint(
 #elf,
 #ame: Optional[sqla_compat._ConstraintNameDefined],
 #ource: str,
 #ocal_cols: Sequence[str],
 #chema: Optional[str] = None,
 #*kw,
 # -> UniqueConstraint:
 # = sa_schema.Table(
 #ource,
 #elf.metadata(),
 #[sa_schema.Column(n, NULLTYPE) for n in local_cols],
 #chema=schema,
 #
 #w["name"] = name
 #q = sa_schema.UniqueConstraint(*[t.c[n] for n in local_cols], **kw)
        # TODO: need event tests to ensure the event
        # is fired off here
 #.append_constraint(uq)
 #eturn uq

 #ef check_constraint(
 #elf,
 #ame: Optional[sqla_compat._ConstraintNameDefined],
 #ource: str,
 #ondition: Union[str, TextClause, ColumnElement[Any]],
 #chema: Optional[str] = None,
 #*kw,
 # -> Union[CheckConstraint]:
 # = sa_schema.Table(
 #ource,
 #elf.metadata(),
 #a_schema.Column("x", Integer),
 #chema=schema,
 #
 #k = sa_schema.CheckConstraint(condition, name=name, **kw)
 #.append_constraint(ck)
 #eturn ck

 #ef generic_constraint(
 #elf,
 #ame: Optional[sqla_compat._ConstraintNameDefined],
 #able_name: str,
 #ype_: Optional[str],
 #chema: Optional[str] = None,
 #*kw,
 # -> Any:
 # = self.table(table_name, schema=schema)
 #ypes: Dict[Optional[str], Any] = {
 #foreignkey": lambda name: sa_schema.ForeignKeyConstraint(
 #], [], name=name
 #,
 #primary": sa_schema.PrimaryKeyConstraint,
 #unique": sa_schema.UniqueConstraint,
 #check": lambda name: sa_schema.CheckConstraint("", name=name),
 #one: sa_schema.Constraint,
 #
 #ry:
 #onst = types[type_]
 #xcept KeyError as ke:
 #aise TypeError(
 #'type' can be one of %s"
 # ", ".join(sorted(repr(x) for x in types))
 # from ke
 #lse:
 #onst = const(name=name)
 #.append_constraint(const)
 #eturn const

 #ef metadata(self) -> MetaData:
 #w = {}
 #f (
 #elf.migration_context is not None
 #nd "target_metadata" in self.migration_context.opts
 #:
 #t = self.migration_context.opts["target_metadata"]
 #f hasattr(mt, "naming_convention"):
 #w["naming_convention"] = mt.naming_convention
 #eturn sa_schema.MetaData(**kw)

 #ef table(self, name: str, *columns, **kw) -> Table:
 # = self.metadata()

 #ols = [
 #qla_compat._copy(c) if c.table is not None else c
 #or c in columns
 #f isinstance(c, Column)
 #
        # these flags have already added their UniqueConstraint /
        # Index objects to the table, so flip them off here.
        # SQLAlchemy tometadata() avoids this instead by preserving the
        # flags and skipping the constraints that have _type_bound on them,
        # but for a migration we'd rather list out the constraints
        # explicitly.
 #constraints_included = kw.pop("_constraints_included", False)
 #f _constraints_included:
 #or c in cols:
 #.unique = c.index = False

 # = sa_schema.Table(name, m, *cols, **kw)

 #onstraints = [
 #
 #qla_compat._copy(elem, target_table=t)
 #f getattr(elem, "parent", None) is not t
 #nd getattr(elem, "parent", None) is not None
 #lse elem
 #
 #or elem in columns
 #f isinstance(elem, (Constraint, Index))
 #

 #or const in constraints:
 #.append_constraint(const)

 #or f in t.foreign_keys:
 #elf._ensure_table_for_fk(m, f)
 #eturn t

 #ef column(self, name: str, type_: TypeEngine, **kw) -> Column:
 #eturn sa_schema.Column(name, type_, **kw)

 #ef index(
 #elf,
 #ame: Optional[str],
 #ablename: Optional[str],
 #olumns: Sequence[Union[str, TextClause, ColumnElement[Any]]],
 #chema: Optional[str] = None,
 #*kw,
 # -> Index:
 # = sa_schema.Table(
 #ablename or "no_table",
 #elf.metadata(),
 #chema=schema,
 #
 #w["_table"] = t
 #dx = sa_schema.Index(
 #ame,
 #[util.sqla_compat._textual_index_column(t, n) for n in columns],
 #*kw,
 #
 #eturn idx

 #ef _parse_table_key(self, table_key: str) -> Tuple[Optional[str], str]:
 #f "." in table_key:
 #okens = table_key.split(".")
 #name: Optional[str] = ".".join(tokens[0:-1])
 #name = tokens[-1]
 #lse:
 #name = table_key
 #name = None
 #eturn (sname, tname)

 #ef _ensure_table_for_fk(self, metadata: MetaData, fk: ForeignKey) -> None:
 #""create a placeholder Table object for the referent of a
 #oreignKey.

 #""
 #f isinstance(fk._colspec, str):
 #able_key, cname = fk._colspec.rsplit(".", 1)
 #name, tname = self._parse_table_key(table_key)
 #f table_key not in metadata.tables:
 #el_t = sa_schema.Table(tname, metadata, schema=sname)
 #lse:
 #el_t = metadata.tables[table_key]
 #f cname not in rel_t.c:
 #el_t.append_column(sa_schema.Column(cname, NULLTYPE))
