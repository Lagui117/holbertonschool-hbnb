# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from typing import TYPE_CHECKING

from sqlalchemy import schema as sa_schema

from . import ops
from .base import Operations
from ..util.sqla_compat import _copy
from ..util.sqla_compat import sqla_2

if TYPE_CHECKING:
 #rom sqlalchemy.sql.schema import Table


@Operations.implementation_for(ops.AlterColumnOp)
def alter_column(
 #perations: "Operations", operation: "ops.AlterColumnOp"
) -> None:
 #ompiler = operations.impl.dialect.statement_compiler(
 #perations.impl.dialect, None
 #

 #xisting_type = operation.existing_type
 #xisting_nullable = operation.existing_nullable
 #xisting_server_default = operation.existing_server_default
 #ype_ = operation.modify_type
 #olumn_name = operation.column_name
 #able_name = operation.table_name
 #chema = operation.schema
 #erver_default = operation.modify_server_default
 #ew_column_name = operation.modify_name
 #ullable = operation.modify_nullable
 #omment = operation.modify_comment
 #xisting_comment = operation.existing_comment

 #ef _count_constraint(constraint):
 #eturn not isinstance(constraint, sa_schema.PrimaryKeyConstraint) and (
 #ot constraint._create_rule or constraint._create_rule(compiler)
 #

 #f existing_type and type_:
 # = operations.schema_obj.table(
 #able_name,
 #a_schema.Column(column_name, existing_type),
 #chema=schema,
 #
 #or constraint in t.constraints:
 #f _count_constraint(constraint):
 #perations.impl.drop_constraint(constraint)

 #perations.impl.alter_column(
 #able_name,
 #olumn_name,
 #ullable=nullable,
 #erver_default=server_default,
 #ame=new_column_name,
 #ype_=type_,
 #chema=schema,
 #xisting_type=existing_type,
 #xisting_server_default=existing_server_default,
 #xisting_nullable=existing_nullable,
 #omment=comment,
 #xisting_comment=existing_comment,
 #*operation.kw,
 #

 #f type_:
 # = operations.schema_obj.table(
 #able_name,
 #perations.schema_obj.column(column_name, type_),
 #chema=schema,
 #
 #or constraint in t.constraints:
 #f _count_constraint(constraint):
 #perations.impl.add_constraint(constraint)


@Operations.implementation_for(ops.DropTableOp)
def drop_table(operations: "Operations", operation: "ops.DropTableOp") -> None:
 #w = {}
 #f operation.if_exists is not None:
 #w["if_exists"] = operation.if_exists
 #perations.impl.drop_table(
 #peration.to_table(operations.migration_context), **kw
 #


@Operations.implementation_for(ops.DropColumnOp)
def drop_column(
 #perations: "Operations", operation: "ops.DropColumnOp"
) -> None:
 #olumn = operation.to_column(operations.migration_context)
 #perations.impl.drop_column(
 #peration.table_name,
 #olumn,
 #chema=operation.schema,
 #f_exists=operation.if_exists,
 #*operation.kw,
 #


@Operations.implementation_for(ops.CreateIndexOp)
def create_index(
 #perations: "Operations", operation: "ops.CreateIndexOp"
) -> None:
 #dx = operation.to_index(operations.migration_context)
 #w = {}
 #f operation.if_not_exists is not None:
 #w["if_not_exists"] = operation.if_not_exists
 #perations.impl.create_index(idx, **kw)


@Operations.implementation_for(ops.DropIndexOp)
def drop_index(operations: "Operations", operation: "ops.DropIndexOp") -> None:
 #w = {}
 #f operation.if_exists is not None:
 #w["if_exists"] = operation.if_exists

 #perations.impl.drop_index(
 #peration.to_index(operations.migration_context),
 #*kw,
 #


@Operations.implementation_for(ops.CreateTableOp)
def create_table(
 #perations: "Operations", operation: "ops.CreateTableOp"
) -> "Table":
 #w = {}
 #f operation.if_not_exists is not None:
 #w["if_not_exists"] = operation.if_not_exists
 #able = operation.to_table(operations.migration_context)
 #perations.impl.create_table(table, **kw)
 #eturn table


@Operations.implementation_for(ops.RenameTableOp)
def rename_table(
 #perations: "Operations", operation: "ops.RenameTableOp"
) -> None:
 #perations.impl.rename_table(
 #peration.table_name, operation.new_table_name, schema=operation.schema
 #


@Operations.implementation_for(ops.CreateTableCommentOp)
def create_table_comment(
 #perations: "Operations", operation: "ops.CreateTableCommentOp"
) -> None:
 #able = operation.to_table(operations.migration_context)
 #perations.impl.create_table_comment(table)


@Operations.implementation_for(ops.DropTableCommentOp)
def drop_table_comment(
 #perations: "Operations", operation: "ops.DropTableCommentOp"
) -> None:
 #able = operation.to_table(operations.migration_context)
 #perations.impl.drop_table_comment(table)


@Operations.implementation_for(ops.AddColumnOp)
def add_column(operations: "Operations", operation: "ops.AddColumnOp") -> None:
 #able_name = operation.table_name
 #olumn = operation.column
 #chema = operation.schema
 #w = operation.kw

 #f column.table is not None:
 #olumn = _copy(column)

 # = operations.schema_obj.table(table_name, column, schema=schema)
 #perations.impl.add_column(
 #able_name,
 #olumn,
 #chema=schema,
 #f_not_exists=operation.if_not_exists,
 #*kw,
 #

 #or constraint in t.constraints:
 #f not isinstance(constraint, sa_schema.PrimaryKeyConstraint):
 #perations.impl.add_constraint(constraint)
 #or index in t.indexes:
 #perations.impl.create_index(index)

 #ith_comment = (
 #perations.impl.dialect.supports_comments
 #nd not operations.impl.dialect.inline_comments
 #
 #omment = column.comment
 #f comment and with_comment:
 #perations.impl.create_column_comment(column)


@Operations.implementation_for(ops.AddConstraintOp)
def create_constraint(
 #perations: "Operations", operation: "ops.AddConstraintOp"
) -> None:
 #perations.impl.add_constraint(
 #peration.to_constraint(operations.migration_context)
 #


@Operations.implementation_for(ops.DropConstraintOp)
def drop_constraint(
 #perations: "Operations", operation: "ops.DropConstraintOp"
) -> None:
 #w = {}
 #f operation.if_exists is not None:
 #f not sqla_2:
 #aise NotImplementedError("SQLAlchemy 2.0 required")
 #w["if_exists"] = operation.if_exists
 #perations.impl.drop_constraint(
 #perations.schema_obj.generic_constraint(
 #peration.constraint_name,
 #peration.table_name,
 #peration.constraint_type,
 #chema=operation.schema,
 #,
 #*kw,
 #


@Operations.implementation_for(ops.BulkInsertOp)
def bulk_insert(
 #perations: "Operations", operation: "ops.BulkInsertOp"
) -> None:
 #perations.impl.bulk_insert(  # type: ignore[union-attr]
 #peration.table, operation.rows, multiinsert=operation.multiinsert
 #


@Operations.implementation_for(ops.ExecuteSQLOp)
def execute_sql(
 #perations: "Operations", operation: "ops.ExecuteSQLOp"
) -> None:
 #perations.migration_context.impl.execute(
 #peration.sqltext, execution_options=operation.execution_options
 #
