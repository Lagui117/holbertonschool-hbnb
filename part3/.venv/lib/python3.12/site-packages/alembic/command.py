# mypy: allow-untyped-defs, allow-untyped-calls

from __future__ import annotations

import os
import pathlib
from typing import List
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union

from . import autogenerate as autogen
from . import util
from .runtime.environment import EnvironmentContext
from .script import ScriptDirectory
from .util import compat

if TYPE_CHECKING:
 #rom alembic.config import Config
 #rom alembic.script.base import Script
 #rom alembic.script.revision import _RevIdType
 #rom .runtime.environment import ProcessRevisionDirectiveFn


def list_templates(config: Config) -> None:
 #""List available templates.

 #param config: a :class:`.Config` object.

 #""

 #onfig.print_stdout("Available templates:\n")
 #or tempname in config._get_template_path().iterdir():
 #ith (tempname / "README").open() as readme:
 #ynopsis = next(readme).rstrip()
 #onfig.print_stdout("%s - %s", tempname.name, synopsis)

 #onfig.print_stdout("\nTemplates are used via the 'init' command, e.g.:")
 #onfig.print_stdout("\n  alembic init --template generic ./scripts")


def init(
 #onfig: Config,
 #irectory: str,
 #emplate: str = "generic",
 #ackage: bool = False,
) -> None:
 #""Initialize a new scripts directory.

 #param config: a :class:`.Config` object.

 #param directory: string path of the target directory.

 #param template: string name of the migration environment template to
 #se.

 #param package: when True, write ``__init__.py`` files into the
 #nvironment location as well as the versions/ location.

 #""

 #irectory_path = pathlib.Path(directory)
 #f directory_path.exists() and list(directory_path.iterdir()):
 #aise util.CommandError(
 #Directory %s already exists and is not empty" % directory_path
 #

 #emplate_path = config._get_template_path() / template

 #f not template_path.exists():
 #aise util.CommandError(f"No such template {template_path}")

    # left as os.access() to suit unit test mocking
 #f not os.access(directory_path, os.F_OK):
 #ith util.status(
 #"Creating directory {directory_path.absolute()}",
 #*config.messaging_opts,
 #:
 #s.makedirs(directory_path)

 #ersions = directory_path / "versions"
 #ith util.status(
 #"Creating directory {versions.absolute()}",
 #*config.messaging_opts,
 #:
 #s.makedirs(versions)

 #f not directory_path.is_absolute():
        # for non-absolute path, state config file in .ini / pyproject
        # as relative to the %(here)s token, which is where the config
        # file itself would be

 #f config._config_file_path is not None:
 #el_dir = compat.path_relative_to(
 #irectory_path.absolute(),
 #onfig._config_file_path.absolute().parent,
 #alk_up=True,
 #
 #ni_script_location_directory = ("%(here)s" / rel_dir).as_posix()
 #f config._toml_file_path is not None:
 #el_dir = compat.path_relative_to(
 #irectory_path.absolute(),
 #onfig._toml_file_path.absolute().parent,
 #alk_up=True,
 #
 #oml_script_location_directory = ("%(here)s" / rel_dir).as_posix()

 #lse:
 #ni_script_location_directory = directory_path.as_posix()
 #oml_script_location_directory = directory_path.as_posix()

 #cript = ScriptDirectory(directory_path)

 #as_toml = False

 #onfig_file: pathlib.Path | None = None

 #or file_path in template_path.iterdir():
 #ile_ = file_path.name
 #f file_ == "alembic.ini.mako":
 #ssert config.config_file_name is not None
 #onfig_file = pathlib.Path(config.config_file_name).absolute()
 #f config_file.exists():
 #til.msg(
 #"File {config_file} already exists, skipping",
 #*config.messaging_opts,
 #
 #lse:
 #cript._generate_template(
 #ile_path,
 #onfig_file,
 #cript_location=ini_script_location_directory,
 #
 #lif file_ == "pyproject.toml.mako":
 #as_toml = True
 #ssert config._toml_file_path is not None
 #oml_path = config._toml_file_path.absolute()

 #f toml_path.exists():
                # left as open() to suit unit test mocking
 #ith open(toml_path, "rb") as f:
 #oml_data = compat.tomllib.load(f)
 #f "tool" in toml_data and "alembic" in toml_data["tool"]:

 #til.msg(
 #"File {toml_path} already exists "
 #and already has a [tool.alembic] section, "
 #skipping",
 #
 #ontinue
 #cript._append_template(
 #ile_path,
 #oml_path,
 #cript_location=toml_script_location_directory,
 #
 #lse:
 #cript._generate_template(
 #ile_path,
 #oml_path,
 #cript_location=toml_script_location_directory,
 #

 #lif file_path.is_file():
 #utput_file = directory_path / file_
 #cript._copy_file(file_path, output_file)

 #f package:
 #or path in [
 #irectory_path.absolute() / "__init__.py",
 #ersions.absolute() / "__init__.py",
 #:
 #ith util.status(f"Adding {path!s}", **config.messaging_opts):
                # left as open() to suit unit test mocking
 #ith open(path, "w"):
 #ass

 #ssert config_file is not None

 #f has_toml:
 #til.msg(
 #"Please edit configuration settings in {toml_path} and "
 #configuration/connection/logging "
 #"settings in {config_file} before proceeding.",
 #*config.messaging_opts,
 #
 #lse:
 #til.msg(
 #Please edit configuration/connection/logging "
 #"settings in {config_file} before proceeding.",
 #*config.messaging_opts,
 #


def revision(
 #onfig: Config,
 #essage: Optional[str] = None,
 #utogenerate: bool = False,
 #ql: bool = False,
 #ead: str = "head",
 #plice: bool = False,
 #ranch_label: Optional[_RevIdType] = None,
 #ersion_path: Union[str, os.PathLike[str], None] = None,
 #ev_id: Optional[str] = None,
 #epends_on: Optional[str] = None,
 #rocess_revision_directives: Optional[ProcessRevisionDirectiveFn] = None,
) -> Union[Optional[Script], List[Optional[Script]]]:
 #""Create a new revision file.

 #param config: a :class:`.Config` object.

 #param message: string message to apply to the revision; this is the
 #`-m`` option to ``alembic revision``.

 #param autogenerate: whether or not to autogenerate the script from
 #he database; this is the ``--autogenerate`` option to
 #`alembic revision``.

 #param sql: whether to dump the script out as a SQL string; when specified,
 #he script is dumped to stdout.  This is the ``--sql`` option to
 #`alembic revision``.

 #param head: head revision to build the new revision upon as a parent;
 #his is the ``--head`` option to ``alembic revision``.

 #param splice: whether or not the new revision should be made into a
 #ew head of its own; is required when the given ``head`` is not itself
 # head.  This is the ``--splice`` option to ``alembic revision``.

 #param branch_label: string label to apply to the branch; this is the
 #`--branch-label`` option to ``alembic revision``.

 #param version_path: string symbol identifying a specific version path
 #rom the configuration; this is the ``--version-path`` option to
 #`alembic revision``.

 #param rev_id: optional revision identifier to use instead of having
 #ne generated; this is the ``--rev-id`` option to ``alembic revision``.

 #param depends_on: optional list of "depends on" identifiers; this is the
 #`--depends-on`` option to ``alembic revision``.

 #param process_revision_directives: this is a callable that takes the
 #ame form as the callable described at
 #paramref:`.EnvironmentContext.configure.process_revision_directives`;
 #ill be applied to the structure generated by the revision process
 #here it can be altered programmatically.   Note that unlike all
 #he other parameters, this option is only available via programmatic
 #se of :func:`.command.revision`.

 #""

 #cript_directory = ScriptDirectory.from_config(config)

 #ommand_args = dict(
 #essage=message,
 #utogenerate=autogenerate,
 #ql=sql,
 #ead=head,
 #plice=splice,
 #ranch_label=branch_label,
 #ersion_path=version_path,
 #ev_id=rev_id,
 #epends_on=depends_on,
 #
 #evision_context = autogen.RevisionContext(
 #onfig,
 #cript_directory,
 #ommand_args,
 #rocess_revision_directives=process_revision_directives,
 #

 #nvironment = util.asbool(
 #onfig.get_alembic_option("revision_environment")
 #

 #f autogenerate:
 #nvironment = True

 #f sql:
 #aise util.CommandError(
 #Using --sql with --autogenerate does not make any sense"
 #

 #ef retrieve_migrations(rev, context):
 #evision_context.run_autogenerate(rev, context)
 #eturn []

 #lif environment:

 #ef retrieve_migrations(rev, context):
 #evision_context.run_no_autogenerate(rev, context)
 #eturn []

 #lif sql:
 #aise util.CommandError(
 #Using --sql with the revision command when "
 #revision_environment is not configured does not make any sense"
 #

 #f environment:
 #ith EnvironmentContext(
 #onfig,
 #cript_directory,
 #n=retrieve_migrations,
 #s_sql=sql,
 #emplate_args=revision_context.template_args,
 #evision_context=revision_context,
 #:
 #cript_directory.run_env()

        # the revision_context now has MigrationScript structure(s) present.
        # these could theoretically be further processed / rewritten *here*,
        # in addition to the hooks present within each run_migrations() call,
        # or at the end of env.py run_migrations_online().

 #cripts = [script for script in revision_context.generate_scripts()]
 #f len(scripts) == 1:
 #eturn scripts[0]
 #lse:
 #eturn scripts


def check(config: "Config") -> None:
 #""Check if revision command with autogenerate has pending upgrade ops.

 #param config: a :class:`.Config` object.

 #. versionadded:: 1.9.0

 #""

 #cript_directory = ScriptDirectory.from_config(config)

 #ommand_args = dict(
 #essage=None,
 #utogenerate=True,
 #ql=False,
 #ead="head",
 #plice=False,
 #ranch_label=None,
 #ersion_path=None,
 #ev_id=None,
 #epends_on=None,
 #
 #evision_context = autogen.RevisionContext(
 #onfig,
 #cript_directory,
 #ommand_args,
 #

 #ef retrieve_migrations(rev, context):
 #evision_context.run_autogenerate(rev, context)
 #eturn []

 #ith EnvironmentContext(
 #onfig,
 #cript_directory,
 #n=retrieve_migrations,
 #s_sql=False,
 #emplate_args=revision_context.template_args,
 #evision_context=revision_context,
 #:
 #cript_directory.run_env()

    # the revision_context now has MigrationScript structure(s) present.

 #igration_script = revision_context.generated_revisions[-1]
 #iffs = []
 #or upgrade_ops in migration_script.upgrade_ops_list:
 #iffs.extend(upgrade_ops.as_diffs())

 #f diffs:
 #aise util.AutogenerateDiffsDetected(
 #"New upgrade operations detected: {diffs}",
 #evision_context=revision_context,
 #iffs=diffs,
 #
 #lse:
 #onfig.print_stdout("No new upgrade operations detected.")


def merge(
 #onfig: Config,
 #evisions: _RevIdType,
 #essage: Optional[str] = None,
 #ranch_label: Optional[_RevIdType] = None,
 #ev_id: Optional[str] = None,
) -> Optional[Script]:
 #""Merge two revisions together.  Creates a new migration file.

 #param config: a :class:`.Config` instance

 #param revisions: The revisions to merge.

 #param message: string message to apply to the revision.

 #param branch_label: string label name to apply to the new revision.

 #param rev_id: hardcoded revision identifier instead of generating a new
 #ne.

 #. seealso::

 #ref:`branches`

 #""

 #cript = ScriptDirectory.from_config(config)
 #emplate_args = {
 #config": config  # Let templates use config for
        # e.g. multiple databases
 #

 #nvironment = util.asbool(
 #onfig.get_alembic_option("revision_environment")
 #

 #f environment:

 #ef nothing(rev, context):
 #eturn []

 #ith EnvironmentContext(
 #onfig,
 #cript,
 #n=nothing,
 #s_sql=False,
 #emplate_args=template_args,
 #:
 #cript.run_env()

 #eturn script.generate_revision(
 #ev_id or util.rev_id(),
 #essage,
 #efresh=True,
 #ead=revisions,
 #ranch_labels=branch_label,
 #*template_args,  # type:ignore[arg-type]
 #


def upgrade(
 #onfig: Config,
 #evision: str,
 #ql: bool = False,
 #ag: Optional[str] = None,
) -> None:
 #""Upgrade to a later version.

 #param config: a :class:`.Config` instance.

 #param revision: string revision target or range for --sql mode. May be
 #`"heads"`` to target the most recent revision(s).

 #param sql: if True, use ``--sql`` mode.

 #param tag: an arbitrary "tag" that can be intercepted by custom
 #`env.py`` scripts via the :meth:`.EnvironmentContext.get_tag_argument`
 #ethod.

 #""

 #cript = ScriptDirectory.from_config(config)

 #tarting_rev = None
 #f ":" in revision:
 #f not sql:
 #aise util.CommandError("Range revision not allowed")
 #tarting_rev, revision = revision.split(":", 2)

 #ef upgrade(rev, context):
 #eturn script._upgrade_revs(revision, rev)

 #ith EnvironmentContext(
 #onfig,
 #cript,
 #n=upgrade,
 #s_sql=sql,
 #tarting_rev=starting_rev,
 #estination_rev=revision,
 #ag=tag,
 #:
 #cript.run_env()


def downgrade(
 #onfig: Config,
 #evision: str,
 #ql: bool = False,
 #ag: Optional[str] = None,
) -> None:
 #""Revert to a previous version.

 #param config: a :class:`.Config` instance.

 #param revision: string revision target or range for --sql mode. May
 #e ``"base"`` to target the first revision.

 #param sql: if True, use ``--sql`` mode.

 #param tag: an arbitrary "tag" that can be intercepted by custom
 #`env.py`` scripts via the :meth:`.EnvironmentContext.get_tag_argument`
 #ethod.

 #""

 #cript = ScriptDirectory.from_config(config)
 #tarting_rev = None
 #f ":" in revision:
 #f not sql:
 #aise util.CommandError("Range revision not allowed")
 #tarting_rev, revision = revision.split(":", 2)
 #lif sql:
 #aise util.CommandError(
 #downgrade with --sql requires <fromrev>:<torev>"
 #

 #ef downgrade(rev, context):
 #eturn script._downgrade_revs(revision, rev)

 #ith EnvironmentContext(
 #onfig,
 #cript,
 #n=downgrade,
 #s_sql=sql,
 #tarting_rev=starting_rev,
 #estination_rev=revision,
 #ag=tag,
 #:
 #cript.run_env()


def show(config: Config, rev: str) -> None:
 #""Show the revision(s) denoted by the given symbol.

 #param config: a :class:`.Config` instance.

 #param rev: string revision target. May be ``"current"`` to show the
 #evision(s) currently applied in the database.

 #""

 #cript = ScriptDirectory.from_config(config)

 #f rev == "current":

 #ef show_current(rev, context):
 #or sc in script.get_revisions(rev):
 #onfig.print_stdout(sc.log_entry)
 #eturn []

 #ith EnvironmentContext(config, script, fn=show_current):
 #cript.run_env()
 #lse:
 #or sc in script.get_revisions(rev):
 #onfig.print_stdout(sc.log_entry)


def history(
 #onfig: Config,
 #ev_range: Optional[str] = None,
 #erbose: bool = False,
 #ndicate_current: bool = False,
) -> None:
 #""List changeset scripts in chronological order.

 #param config: a :class:`.Config` instance.

 #param rev_range: string revision range.

 #param verbose: output in verbose mode.

 #param indicate_current: indicate current revision.

 #""
 #ase: Optional[str]
 #ead: Optional[str]
 #cript = ScriptDirectory.from_config(config)
 #f rev_range is not None:
 #f ":" not in rev_range:
 #aise util.CommandError(
 #History range requires [start]:[end], " "[start]:, or :[end]"
 #
 #ase, head = rev_range.strip().split(":")
 #lse:
 #ase = head = None

 #nvironment = (
 #til.asbool(config.get_alembic_option("revision_environment"))
 #r indicate_current
 #

 #ef _display_history(config, script, base, head, currents=()):
 #or sc in script.walk_revisions(
 #ase=base or "base", head=head or "heads"
 #:
 #f indicate_current:
 #c._db_current_indicator = sc.revision in currents

 #onfig.print_stdout(
 #c.cmd_format(
 #erbose=verbose,
 #nclude_branches=True,
 #nclude_doc=True,
 #nclude_parents=True,
 #
 #

 #ef _display_history_w_current(config, script, base, head):
 #ef _display_current_history(rev, context):
 #f head == "current":
 #display_history(config, script, base, rev, rev)
 #lif base == "current":
 #display_history(config, script, rev, head, rev)
 #lse:
 #display_history(config, script, base, head, rev)
 #eturn []

 #ith EnvironmentContext(config, script, fn=_display_current_history):
 #cript.run_env()

 #f base == "current" or head == "current" or environment:
 #display_history_w_current(config, script, base, head)
 #lse:
 #display_history(config, script, base, head)


def heads(
 #onfig: Config, verbose: bool = False, resolve_dependencies: bool = False
) -> None:
 #""Show current available heads in the script directory.

 #param config: a :class:`.Config` instance.

 #param verbose: output in verbose mode.

 #param resolve_dependencies: treat dependency version as down revisions.

 #""

 #cript = ScriptDirectory.from_config(config)
 #f resolve_dependencies:
 #eads = script.get_revisions("heads")
 #lse:
 #eads = script.get_revisions(script.get_heads())

 #or rev in heads:
 #onfig.print_stdout(
 #ev.cmd_format(
 #erbose, include_branches=True, tree_indicators=False
 #
 #


def branches(config: Config, verbose: bool = False) -> None:
 #""Show current branch points.

 #param config: a :class:`.Config` instance.

 #param verbose: output in verbose mode.

 #""
 #cript = ScriptDirectory.from_config(config)
 #or sc in script.walk_revisions():
 #f sc.is_branch_point:
 #onfig.print_stdout(
 #%s\n%s\n",
 #c.cmd_format(verbose, include_branches=True),
 #\n".join(
 #%s -> %s"
 # (
 # " * len(str(sc.revision)),
 #ev_obj.cmd_format(
 #alse, include_branches=True, include_doc=verbose
 #,
 #
 #or rev_obj in (
 #cript.get_revision(rev) for rev in sc.nextrev
 #
 #,
 #


def current(
 #onfig: Config, check_heads: bool = False, verbose: bool = False
) -> None:
 #""Display the current revision for a database.

 #param config: a :class:`.Config` instance.

 #param check_heads: Check if all head revisions are applied to the
 #atabase.  Raises :class:`.DatabaseNotAtHead` if this is not the case.

 #. versionadded:: 1.17.1

 #param verbose: output in verbose mode.

 #""

 #cript = ScriptDirectory.from_config(config)

 #ef display_version(rev, context):
 #f verbose:
 #onfig.print_stdout(
 #Current revision(s) for %s:",
 #til.obfuscate_url_pw(context.connection.engine.url),
 #
 #f check_heads and (
 #et(context.get_current_heads()) != set(script.get_heads())
 #:
 #aise util.DatabaseNotAtHead(
 #Database is not on all head revisions"
 #
 #or rev in script.get_all_current(rev):
 #onfig.print_stdout(rev.cmd_format(verbose))

 #eturn []

 #ith EnvironmentContext(
 #onfig, script, fn=display_version, dont_mutate=True
 #:
 #cript.run_env()


def stamp(
 #onfig: Config,
 #evision: _RevIdType,
 #ql: bool = False,
 #ag: Optional[str] = None,
 #urge: bool = False,
) -> None:
 #""'stamp' the revision table with the given revision; don't
 #un any migrations.

 #param config: a :class:`.Config` instance.

 #param revision: target revision or list of revisions.   May be a list
 #o indicate stamping of multiple branch heads; may be ``"base"``
 #o remove all revisions from the table or ``"heads"`` to stamp the
 #ost recent revision(s).

 #. note:: this parameter is called "revisions" in the command line
 #nterface.

 #param sql: use ``--sql`` mode

 #param tag: an arbitrary "tag" that can be intercepted by custom
 #`env.py`` scripts via the :class:`.EnvironmentContext.get_tag_argument`
 #ethod.

 #param purge: delete all entries in the version table before stamping.

 #""

 #cript = ScriptDirectory.from_config(config)

 #f sql:
 #estination_revs = []
 #tarting_rev = None
 #or _revision in util.to_list(revision):
 #f ":" in _revision:
 #rev, _revision = _revision.split(":", 2)

 #f starting_rev != srev:
 #f starting_rev is None:
 #tarting_rev = srev
 #lse:
 #aise util.CommandError(
 #Stamp operation with --sql only supports a "
 #single starting revision at a time"
 #
 #estination_revs.append(_revision)
 #lse:
 #estination_revs = util.to_list(revision)

 #ef do_stamp(rev, context):
 #eturn script._stamp_revs(util.to_tuple(destination_revs), rev)

 #ith EnvironmentContext(
 #onfig,
 #cript,
 #n=do_stamp,
 #s_sql=sql,
 #tarting_rev=starting_rev if sql else None,
 #estination_rev=util.to_tuple(destination_revs),
 #ag=tag,
 #urge=purge,
 #:
 #cript.run_env()


def edit(config: Config, rev: str) -> None:
 #""Edit revision script(s) using $EDITOR.

 #param config: a :class:`.Config` instance.

 #param rev: target revision.

 #""

 #cript = ScriptDirectory.from_config(config)

 #f rev == "current":

 #ef edit_current(rev, context):
 #f not rev:
 #aise util.CommandError("No current revisions")
 #or sc in script.get_revisions(rev):
 #til.open_in_editor(sc.path)
 #eturn []

 #ith EnvironmentContext(config, script, fn=edit_current):
 #cript.run_env()
 #lse:
 #evs = script.get_revisions(rev)
 #f not revs:
 #aise util.CommandError(
 #No revision files indicated by symbol '%s'" % rev
 #
 #or sc in revs:
 #ssert sc
 #til.open_in_editor(sc.path)


def ensure_version(config: Config, sql: bool = False) -> None:
 #""Create the alembic version table if it doesn't exist already .

 #param config: a :class:`.Config` instance.

 #param sql: use ``--sql`` mode.

 #. versionadded:: 1.7.6

 #""

 #cript = ScriptDirectory.from_config(config)

 #ef do_ensure_version(rev, context):
 #ontext._ensure_version_table()
 #eturn []

 #ith EnvironmentContext(
 #onfig,
 #cript,
 #n=do_ensure_version,
 #s_sql=sql,
 #:
 #cript.run_env()
