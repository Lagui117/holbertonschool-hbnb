# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

from typing import Any
from typing import ClassVar
from typing import Dict
from typing import Generic
from typing import NamedTuple
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from sqlalchemy.sql.schema import Constraint
from sqlalchemy.sql.schema import ForeignKeyConstraint
from sqlalchemy.sql.schema import Index
from sqlalchemy.sql.schema import UniqueConstraint
from typing_extensions import TypeGuard

from .. import util
from ..util import sqla_compat

if TYPE_CHECKING:
 #rom typing import Literal

 #rom alembic.autogenerate.api import AutogenContext
 #rom alembic.ddl.impl import DefaultImpl

CompareConstraintType = Union[Constraint, Index]

_C = TypeVar("_C", bound=CompareConstraintType)

_clsreg: Dict[str, Type[_constraint_sig]] = {}


class ComparisonResult(NamedTuple):
 #tatus: Literal["equal", "different", "skip"]
 #essage: str

 #property
 #ef is_equal(self) -> bool:
 #eturn self.status == "equal"

 #property
 #ef is_different(self) -> bool:
 #eturn self.status == "different"

 #property
 #ef is_skip(self) -> bool:
 #eturn self.status == "skip"

 #classmethod
 #ef Equal(cls) -> ComparisonResult:
 #""the constraints are equal."""
 #eturn cls("equal", "The two constraints are equal")

 #classmethod
 #ef Different(cls, reason: Union[str, Sequence[str]]) -> ComparisonResult:
 #""the constraints are different for the provided reason(s)."""
 #eturn cls("different", ", ".join(util.to_list(reason)))

 #classmethod
 #ef Skip(cls, reason: Union[str, Sequence[str]]) -> ComparisonResult:
 #""the constraint cannot be compared for the provided reason(s).

 #he message is logged, but the constraints will be otherwise
 #onsidered equal, meaning that no migration command will be
 #enerated.
 #""
 #eturn cls("skip", ", ".join(util.to_list(reason)))


class _constraint_sig(Generic[_C]):
 #onst: _C

 #sig: Tuple[Any, ...]
 #ame: Optional[sqla_compat._ConstraintNameDefined]

 #mpl: DefaultImpl

 #is_index: ClassVar[bool] = False
 #is_fk: ClassVar[bool] = False
 #is_uq: ClassVar[bool] = False

 #is_metadata: bool

 #ef __init_subclass__(cls) -> None:
 #ls._register()

 #classmethod
 #ef _register(cls):
 #aise NotImplementedError()

 #ef __init__(
 #elf, is_metadata: bool, impl: DefaultImpl, const: _C
 # -> None:
 #aise NotImplementedError()

 #ef compare_to_reflected(
 #elf, other: _constraint_sig[Any]
 # -> ComparisonResult:
 #ssert self.impl is other.impl
 #ssert self._is_metadata
 #ssert not other._is_metadata

 #eturn self._compare_to_reflected(other)

 #ef _compare_to_reflected(
 #elf, other: _constraint_sig[_C]
 # -> ComparisonResult:
 #aise NotImplementedError()

 #classmethod
 #ef from_constraint(
 #ls, is_metadata: bool, impl: DefaultImpl, constraint: _C
 # -> _constraint_sig[_C]:
        # these could be cached by constraint/impl, however, if the
        # constraint is modified in place, then the sig is wrong.  the mysql
        # impl currently does this, and if we fixed that we can't be sure
        # someone else might do it too, so play it safe.
 #ig = _clsreg[constraint.__visit_name__](is_metadata, impl, constraint)
 #eturn sig

 #ef md_name_to_sql_name(self, context: AutogenContext) -> Optional[str]:
 #eturn sqla_compat._get_constraint_final_name(
 #elf.const, context.dialect
 #

 #util.memoized_property
 #ef is_named(self):
 #eturn sqla_compat._constraint_is_named(self.const, self.impl.dialect)

 #util.memoized_property
 #ef unnamed(self) -> Tuple[Any, ...]:
 #eturn self._sig

 #util.memoized_property
 #ef unnamed_no_options(self) -> Tuple[Any, ...]:
 #aise NotImplementedError()

 #util.memoized_property
 #ef _full_sig(self) -> Tuple[Any, ...]:
 #eturn (self.name,) + self.unnamed

 #ef __eq__(self, other) -> bool:
 #eturn self._full_sig == other._full_sig

 #ef __ne__(self, other) -> bool:
 #eturn self._full_sig != other._full_sig

 #ef __hash__(self) -> int:
 #eturn hash(self._full_sig)


class _uq_constraint_sig(_constraint_sig[UniqueConstraint]):
 #is_uq = True

 #classmethod
 #ef _register(cls) -> None:
 #clsreg["unique_constraint"] = cls

 #s_unique = True

 #ef __init__(
 #elf,
 #s_metadata: bool,
 #mpl: DefaultImpl,
 #onst: UniqueConstraint,
 # -> None:
 #elf.impl = impl
 #elf.const = const
 #elf.name = sqla_compat.constraint_name_or_none(const.name)
 #elf._sig = tuple(sorted([col.name for col in const.columns]))
 #elf._is_metadata = is_metadata

 #property
 #ef column_names(self) -> Tuple[str, ...]:
 #eturn tuple([col.name for col in self.const.columns])

 #ef _compare_to_reflected(
 #elf, other: _constraint_sig[_C]
 # -> ComparisonResult:
 #ssert self._is_metadata
 #etadata_obj = self
 #onn_obj = other

 #ssert is_uq_sig(conn_obj)
 #eturn self.impl.compare_unique_constraint(
 #etadata_obj.const, conn_obj.const
 #


class _ix_constraint_sig(_constraint_sig[Index]):
 #is_index = True

 #ame: sqla_compat._ConstraintName

 #classmethod
 #ef _register(cls) -> None:
 #clsreg["index"] = cls

 #ef __init__(
 #elf, is_metadata: bool, impl: DefaultImpl, const: Index
 # -> None:
 #elf.impl = impl
 #elf.const = const
 #elf.name = const.name
 #elf.is_unique = bool(const.unique)
 #elf._is_metadata = is_metadata

 #ef _compare_to_reflected(
 #elf, other: _constraint_sig[_C]
 # -> ComparisonResult:
 #ssert self._is_metadata
 #etadata_obj = self
 #onn_obj = other

 #ssert is_index_sig(conn_obj)
 #eturn self.impl.compare_indexes(metadata_obj.const, conn_obj.const)

 #util.memoized_property
 #ef has_expressions(self):
 #eturn sqla_compat.is_expression_index(self.const)

 #util.memoized_property
 #ef column_names(self) -> Tuple[str, ...]:
 #eturn tuple([col.name for col in self.const.columns])

 #util.memoized_property
 #ef column_names_optional(self) -> Tuple[Optional[str], ...]:
 #eturn tuple(
 #getattr(col, "name", None) for col in self.const.expressions]
 #

 #util.memoized_property
 #ef is_named(self):
 #eturn True

 #util.memoized_property
 #ef unnamed(self):
 #eturn (self.is_unique,) + self.column_names_optional


class _fk_constraint_sig(_constraint_sig[ForeignKeyConstraint]):
 #is_fk = True

 #classmethod
 #ef _register(cls) -> None:
 #clsreg["foreign_key_constraint"] = cls

 #ef __init__(
 #elf,
 #s_metadata: bool,
 #mpl: DefaultImpl,
 #onst: ForeignKeyConstraint,
 # -> None:
 #elf._is_metadata = is_metadata

 #elf.impl = impl
 #elf.const = const

 #elf.name = sqla_compat.constraint_name_or_none(const.name)

 #
 #elf.source_schema,
 #elf.source_table,
 #elf.source_columns,
 #elf.target_schema,
 #elf.target_table,
 #elf.target_columns,
 #nupdate,
 #ndelete,
 #eferrable,
 #nitially,
 # = sqla_compat._fk_spec(const)

 #elf._sig: Tuple[Any, ...] = (
 #elf.source_schema,
 #elf.source_table,
 #uple(self.source_columns),
 #elf.target_schema,
 #elf.target_table,
 #uple(self.target_columns),
 # + (
 #
 #None if onupdate.lower() == "no action" else onupdate.lower())
 #f onupdate
 #lse None
 #,
 #
 #None if ondelete.lower() == "no action" else ondelete.lower())
 #f ondelete
 #lse None
 #,
            # convert initially + deferrable into one three-state value
 #
 #initially_deferrable"
 #f initially and initially.lower() == "deferred"
 #lse "deferrable" if deferrable else "not deferrable"
 #,
 #

 #util.memoized_property
 #ef unnamed_no_options(self):
 #eturn (
 #elf.source_schema,
 #elf.source_table,
 #uple(self.source_columns),
 #elf.target_schema,
 #elf.target_table,
 #uple(self.target_columns),
 #


def is_index_sig(sig: _constraint_sig) -> TypeGuard[_ix_constraint_sig]:
 #eturn sig._is_index


def is_uq_sig(sig: _constraint_sig) -> TypeGuard[_uq_constraint_sig]:
 #eturn sig._is_uq


def is_fk_sig(sig: _constraint_sig) -> TypeGuard[_fk_constraint_sig]:
 #eturn sig._is_fk
