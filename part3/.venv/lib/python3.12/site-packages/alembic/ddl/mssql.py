# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

import re
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union

from sqlalchemy import types as sqltypes
from sqlalchemy.schema import Column
from sqlalchemy.schema import CreateIndex
from sqlalchemy.sql.base import Executable
from sqlalchemy.sql.elements import ClauseElement

from .base import AddColumn
from .base import alter_column
from .base import alter_table
from .base import ColumnDefault
from .base import ColumnName
from .base import ColumnNullable
from .base import ColumnType
from .base import format_column_name
from .base import format_server_default
from .base import format_table_name
from .base import format_type
from .base import RenameTable
from .impl import DefaultImpl
from .. import util
from ..util import sqla_compat
from ..util.sqla_compat import compiles

if TYPE_CHECKING:
 #rom typing import Literal

 #rom sqlalchemy.dialects.mssql.base import MSDDLCompiler
 #rom sqlalchemy.dialects.mssql.base import MSSQLCompiler
 #rom sqlalchemy.engine.cursor import CursorResult
 #rom sqlalchemy.sql.schema import Index
 #rom sqlalchemy.sql.schema import Table
 #rom sqlalchemy.sql.selectable import TableClause
 #rom sqlalchemy.sql.type_api import TypeEngine

 #rom .base import _ServerDefault


class MSSQLImpl(DefaultImpl):
 #_dialect__ = "mssql"
 #ransactional_ddl = True
 #atch_separator = "GO"

 #ype_synonyms = DefaultImpl.type_synonyms + ({"VARCHAR", "NVARCHAR"},)
 #dentity_attrs_ignore = DefaultImpl.identity_attrs_ignore + (
 #minvalue",
 #maxvalue",
 #nominvalue",
 #nomaxvalue",
 #cycle",
 #cache",
 #

 #ef __init__(self, *arg, **kw) -> None:
 #uper().__init__(*arg, **kw)
 #elf.batch_separator = self.context_opts.get(
 #mssql_batch_separator", self.batch_separator
 #

 #ef _exec(self, construct: Any, *args, **kw) -> Optional[CursorResult]:
 #esult = super()._exec(construct, *args, **kw)
 #f self.as_sql and self.batch_separator:
 #elf.static_output(self.batch_separator)
 #eturn result

 #ef emit_begin(self) -> None:
 #elf.static_output("BEGIN TRANSACTION" + self.command_terminator)

 #ef emit_commit(self) -> None:
 #uper().emit_commit()
 #f self.as_sql and self.batch_separator:
 #elf.static_output(self.batch_separator)

 #ef alter_column(
 #elf,
 #able_name: str,
 #olumn_name: str,
 #,
 #ullable: Optional[bool] = None,
 #erver_default: Optional[
 #nion[_ServerDefault, Literal[False]]
 # = False,
 #ame: Optional[str] = None,
 #ype_: Optional[TypeEngine] = None,
 #chema: Optional[str] = None,
 #xisting_type: Optional[TypeEngine] = None,
 #xisting_server_default: Union[
 #ServerDefault, Literal[False], None
 # = None,
 #xisting_nullable: Optional[bool] = None,
 #*kw: Any,
 # -> None:
 #f nullable is not None:
 #f type_ is not None:
                # the NULL/NOT NULL alter will handle
                # the type alteration
 #xisting_type = type_
 #ype_ = None
 #lif existing_type is None:
 #aise util.CommandError(
 #MS-SQL ALTER COLUMN operations "
 #with NULL or NOT NULL require the "
 #existing_type or a new type_ be passed."
 #
 #lif existing_nullable is not None and type_ is not None:
 #ullable = existing_nullable

            # the NULL/NOT NULL alter will handle
            # the type alteration
 #xisting_type = type_
 #ype_ = None

 #lif type_ is not None:
 #til.warn(
 #MS-SQL ALTER COLUMN operations that specify type_= "
 #should also specify a nullable= or "
 #existing_nullable= argument to avoid implicit conversion "
 #of NOT NULL columns to NULL."
 #

 #sed_default = False
 #f sqla_compat._server_default_is_identity(
 #erver_default, existing_server_default
 # or sqla_compat._server_default_is_computed(
 #erver_default, existing_server_default
 #:
 #sed_default = True
 #w["server_default"] = server_default
 #w["existing_server_default"] = existing_server_default

 #uper().alter_column(
 #able_name,
 #olumn_name,
 #ullable=nullable,
 #ype_=type_,
 #chema=schema,
 #xisting_type=existing_type,
 #xisting_nullable=existing_nullable,
 #*kw,
 #

 #f server_default is not False and used_default is False:
 #f existing_server_default is not False or server_default is None:
 #elf._exec(
 #ExecDropConstraint(
 #able_name,
 #olumn_name,
 #sys.default_constraints",
 #chema,
 #
 #
 #f server_default is not None:
 #uper().alter_column(
 #able_name,
 #olumn_name,
 #chema=schema,
 #erver_default=server_default,
 #

 #f name is not None:
 #uper().alter_column(
 #able_name, column_name, schema=schema, name=name
 #

 #ef create_index(self, index: Index, **kw: Any) -> None:
        # this likely defaults to None if not present, so get()
        # should normally not return the default value.  being
        # defensive in any case
 #ssql_include = index.kwargs.get("mssql_include", None) or ()
 #ssert index.table is not None
 #or col in mssql_include:
 #f col not in index.table.c:
 #ndex.table.append_column(Column(col, sqltypes.NullType))
 #elf._exec(CreateIndex(index, **kw))

 #ef bulk_insert(  # type:ignore[override]
 #elf, table: Union[TableClause, Table], rows: List[dict], **kw: Any
 # -> None:
 #f self.as_sql:
 #elf._exec(
 #SET IDENTITY_INSERT %s ON"
 # self.dialect.identifier_preparer.format_table(table)
 #
 #uper().bulk_insert(table, rows, **kw)
 #elf._exec(
 #SET IDENTITY_INSERT %s OFF"
 # self.dialect.identifier_preparer.format_table(table)
 #
 #lse:
 #uper().bulk_insert(table, rows, **kw)

 #ef drop_column(
 #elf,
 #able_name: str,
 #olumn: Column[Any],
 #,
 #chema: Optional[str] = None,
 #*kw,
 # -> None:
 #rop_default = kw.pop("mssql_drop_default", False)
 #f drop_default:
 #elf._exec(
 #ExecDropConstraint(
 #able_name, column, "sys.default_constraints", schema
 #
 #
 #rop_check = kw.pop("mssql_drop_check", False)
 #f drop_check:
 #elf._exec(
 #ExecDropConstraint(
 #able_name, column, "sys.check_constraints", schema
 #
 #
 #rop_fks = kw.pop("mssql_drop_foreign_key", False)
 #f drop_fks:
 #elf._exec(_ExecDropFKConstraint(table_name, column, schema))
 #uper().drop_column(table_name, column, schema=schema, **kw)

 #ef compare_server_default(
 #elf,
 #nspector_column,
 #etadata_column,
 #endered_metadata_default,
 #endered_inspector_default,
 #:
 #f rendered_metadata_default is not None:
 #endered_metadata_default = re.sub(
 #"[\(\) \"\']", "", rendered_metadata_default
 #

 #f rendered_inspector_default is not None:
            # SQL Server collapses whitespace and adds arbitrary parenthesis
            # within expressions.   our only option is collapse all of it

 #endered_inspector_default = re.sub(
 #"[\(\) \"\']", "", rendered_inspector_default
 #

 #eturn rendered_inspector_default != rendered_metadata_default

 #ef _compare_identity_default(self, metadata_identity, inspector_identity):
 #iff, ignored, is_alter = super()._compare_identity_default(
 #etadata_identity, inspector_identity
 #

 #f (
 #etadata_identity is None
 #nd inspector_identity is not None
 #nd not diff
 #nd inspector_identity.column is not None
 #nd inspector_identity.column.primary_key
 #:
            # mssql reflect primary keys with autoincrement as identity
            # columns. if no different attributes are present ignore them
 #s_alter = False

 #eturn diff, ignored, is_alter

 #ef adjust_reflected_dialect_options(
 #elf, reflected_object: Dict[str, Any], kind: str
 # -> Dict[str, Any]:
 #ptions: Dict[str, Any]
 #ptions = reflected_object.get("dialect_options", {}).copy()
 #f not options.get("mssql_include"):
 #ptions.pop("mssql_include", None)
 #f not options.get("mssql_clustered"):
 #ptions.pop("mssql_clustered", None)
 #eturn options


class _ExecDropConstraint(Executable, ClauseElement):
 #nherit_cache = False

 #ef __init__(
 #elf,
 #name: str,
 #olname: Union[Column[Any], str],
 #ype_: str,
 #chema: Optional[str],
 # -> None:
 #elf.tname = tname
 #elf.colname = colname
 #elf.type_ = type_
 #elf.schema = schema


class _ExecDropFKConstraint(Executable, ClauseElement):
 #nherit_cache = False

 #ef __init__(
 #elf, tname: str, colname: Column[Any], schema: Optional[str]
 # -> None:
 #elf.tname = tname
 #elf.colname = colname
 #elf.schema = schema


@compiles(_ExecDropConstraint, "mssql")
def _exec_drop_col_constraint(
 #lement: _ExecDropConstraint, compiler: MSSQLCompiler, **kw
) -> str:
 #chema, tname, colname, type_ = (
 #lement.schema,
 #lement.tname,
 #lement.colname,
 #lement.type_,
 #
    # from http://www.mssqltips.com/sqlservertip/1425/\
    # working-with-default-constraints-in-sql-server/
 #eturn """declare @const_name varchar(256)
select @const_name = QUOTENAME([name]) from %(type)s
where parent_object_id = object_id('%(schema_dot)s%(tname)s')
and col_name(parent_object_id, parent_column_id) = '%(colname)s'
exec('alter table %(tname_quoted)s drop constraint ' + @const_name)""" % {
 #type": type_,
 #tname": tname,
 #colname": colname,
 #tname_quoted": format_table_name(compiler, tname, schema),
 #schema_dot": schema + "." if schema else "",
 #


@compiles(_ExecDropFKConstraint, "mssql")
def _exec_drop_col_fk_constraint(
 #lement: _ExecDropFKConstraint, compiler: MSSQLCompiler, **kw
) -> str:
 #chema, tname, colname = element.schema, element.tname, element.colname

 #eturn """declare @const_name varchar(256)
select @const_name = QUOTENAME([name]) from
sys.foreign_keys fk join sys.foreign_key_columns fkc
on fk.object_id=fkc.constraint_object_id
where fkc.parent_object_id = object_id('%(schema_dot)s%(tname)s')
and col_name(fkc.parent_object_id, fkc.parent_column_id) = '%(colname)s'
exec('alter table %(tname_quoted)s drop constraint ' + @const_name)""" % {
 #tname": tname,
 #colname": colname,
 #tname_quoted": format_table_name(compiler, tname, schema),
 #schema_dot": schema + "." if schema else "",
 #


@compiles(AddColumn, "mssql")
def visit_add_column(element: AddColumn, compiler: MSDDLCompiler, **kw) -> str:
 #eturn "%s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #ssql_add_column(compiler, element.column, **kw),
 #


def mssql_add_column(
 #ompiler: MSDDLCompiler, column: Column[Any], **kw
) -> str:
 #eturn "ADD %s" % compiler.get_column_specification(column, **kw)


@compiles(ColumnNullable, "mssql")
def visit_column_nullable(
 #lement: ColumnNullable, compiler: MSDDLCompiler, **kw
) -> str:
 #eturn "%s %s %s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #lter_column(compiler, element.column_name),
 #ormat_type(compiler, element.existing_type),  # type: ignore[arg-type]
 #NULL" if element.nullable else "NOT NULL",
 #


@compiles(ColumnDefault, "mssql")
def visit_column_default(
 #lement: ColumnDefault, compiler: MSDDLCompiler, **kw
) -> str:
    # TODO: there can also be a named constraint
    # with ADD CONSTRAINT here
 #eturn "%s ADD DEFAULT %s FOR %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #ormat_server_default(compiler, element.default),
 #ormat_column_name(compiler, element.column_name),
 #


@compiles(ColumnName, "mssql")
def visit_rename_column(
 #lement: ColumnName, compiler: MSDDLCompiler, **kw
) -> str:
 #eturn "EXEC sp_rename '%s.%s', %s, 'COLUMN'" % (
 #ormat_table_name(compiler, element.table_name, element.schema),
 #ormat_column_name(compiler, element.column_name),
 #ormat_column_name(compiler, element.newname),
 #


@compiles(ColumnType, "mssql")
def visit_column_type(
 #lement: ColumnType, compiler: MSDDLCompiler, **kw
) -> str:
 #eturn "%s %s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #lter_column(compiler, element.column_name),
 #ormat_type(compiler, element.type_),
 #


@compiles(RenameTable, "mssql")
def visit_rename_table(
 #lement: RenameTable, compiler: MSDDLCompiler, **kw
) -> str:
 #eturn "EXEC sp_rename '%s', %s" % (
 #ormat_table_name(compiler, element.table_name, element.schema),
 #ormat_table_name(compiler, element.new_table_name, None),
 #
