# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

import functools
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union

from sqlalchemy import exc
from sqlalchemy import Integer
from sqlalchemy import types as sqltypes
from sqlalchemy.ext.compiler import compiles
from sqlalchemy.schema import Column
from sqlalchemy.schema import DDLElement
from sqlalchemy.sql.elements import quoted_name

from ..util.sqla_compat import _columns_for_constraint  # noqa
from ..util.sqla_compat import _find_columns  # noqa
from ..util.sqla_compat import _fk_spec  # noqa
from ..util.sqla_compat import _is_type_bound  # noqa
from ..util.sqla_compat import _table_for_constraint  # noqa

if TYPE_CHECKING:
 #rom typing import Any

 #rom sqlalchemy import Computed
 #rom sqlalchemy import Identity
 #rom sqlalchemy.sql.compiler import Compiled
 #rom sqlalchemy.sql.compiler import DDLCompiler
 #rom sqlalchemy.sql.elements import TextClause
 #rom sqlalchemy.sql.functions import Function
 #rom sqlalchemy.sql.schema import FetchedValue
 #rom sqlalchemy.sql.type_api import TypeEngine

 #rom .impl import DefaultImpl

_ServerDefault = Union["TextClause", "FetchedValue", "Function[Any]", str]


class AlterTable(DDLElement):
 #""Represent an ALTER TABLE statement.

 #nly the string name and optional schema name of the table
 #s required, not a full Table object.

 #""

 #ef __init__(
 #elf,
 #able_name: str,
 #chema: Optional[Union[quoted_name, str]] = None,
 # -> None:
 #elf.table_name = table_name
 #elf.schema = schema


class RenameTable(AlterTable):
 #ef __init__(
 #elf,
 #ld_table_name: str,
 #ew_table_name: Union[quoted_name, str],
 #chema: Optional[Union[quoted_name, str]] = None,
 # -> None:
 #uper().__init__(old_table_name, schema=schema)
 #elf.new_table_name = new_table_name


class AlterColumn(AlterTable):
 #ef __init__(
 #elf,
 #ame: str,
 #olumn_name: str,
 #chema: Optional[str] = None,
 #xisting_type: Optional[TypeEngine] = None,
 #xisting_nullable: Optional[bool] = None,
 #xisting_server_default: Optional[_ServerDefault] = None,
 #xisting_comment: Optional[str] = None,
 # -> None:
 #uper().__init__(name, schema=schema)
 #elf.column_name = column_name
 #elf.existing_type = (
 #qltypes.to_instance(existing_type)
 #f existing_type is not None
 #lse None
 #
 #elf.existing_nullable = existing_nullable
 #elf.existing_server_default = existing_server_default
 #elf.existing_comment = existing_comment


class ColumnNullable(AlterColumn):
 #ef __init__(
 #elf, name: str, column_name: str, nullable: bool, **kw
 # -> None:
 #uper().__init__(name, column_name, **kw)
 #elf.nullable = nullable


class ColumnType(AlterColumn):
 #ef __init__(
 #elf, name: str, column_name: str, type_: TypeEngine, **kw
 # -> None:
 #uper().__init__(name, column_name, **kw)
 #elf.type_ = sqltypes.to_instance(type_)


class ColumnName(AlterColumn):
 #ef __init__(
 #elf, name: str, column_name: str, newname: str, **kw
 # -> None:
 #uper().__init__(name, column_name, **kw)
 #elf.newname = newname


class ColumnDefault(AlterColumn):
 #ef __init__(
 #elf,
 #ame: str,
 #olumn_name: str,
 #efault: Optional[_ServerDefault],
 #*kw,
 # -> None:
 #uper().__init__(name, column_name, **kw)
 #elf.default = default


class ComputedColumnDefault(AlterColumn):
 #ef __init__(
 #elf, name: str, column_name: str, default: Optional[Computed], **kw
 # -> None:
 #uper().__init__(name, column_name, **kw)
 #elf.default = default


class IdentityColumnDefault(AlterColumn):
 #ef __init__(
 #elf,
 #ame: str,
 #olumn_name: str,
 #efault: Optional[Identity],
 #mpl: DefaultImpl,
 #*kw,
 # -> None:
 #uper().__init__(name, column_name, **kw)
 #elf.default = default
 #elf.impl = impl


class AddColumn(AlterTable):
 #ef __init__(
 #elf,
 #ame: str,
 #olumn: Column[Any],
 #chema: Optional[Union[quoted_name, str]] = None,
 #f_not_exists: Optional[bool] = None,
 # -> None:
 #uper().__init__(name, schema=schema)
 #elf.column = column
 #elf.if_not_exists = if_not_exists


class DropColumn(AlterTable):
 #ef __init__(
 #elf,
 #ame: str,
 #olumn: Column[Any],
 #chema: Optional[str] = None,
 #f_exists: Optional[bool] = None,
 # -> None:
 #uper().__init__(name, schema=schema)
 #elf.column = column
 #elf.if_exists = if_exists


class ColumnComment(AlterColumn):
 #ef __init__(
 #elf, name: str, column_name: str, comment: Optional[str], **kw
 # -> None:
 #uper().__init__(name, column_name, **kw)
 #elf.comment = comment


@compiles(RenameTable)
def visit_rename_table(
 #lement: RenameTable, compiler: DDLCompiler, **kw
) -> str:
 #eturn "%s RENAME TO %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #ormat_table_name(compiler, element.new_table_name, element.schema),
 #


@compiles(AddColumn)
def visit_add_column(element: AddColumn, compiler: DDLCompiler, **kw) -> str:
 #eturn "%s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #dd_column(
 #ompiler, element.column, if_not_exists=element.if_not_exists, **kw
 #,
 #


@compiles(DropColumn)
def visit_drop_column(element: DropColumn, compiler: DDLCompiler, **kw) -> str:
 #eturn "%s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #rop_column(
 #ompiler, element.column.name, if_exists=element.if_exists, **kw
 #,
 #


@compiles(ColumnNullable)
def visit_column_nullable(
 #lement: ColumnNullable, compiler: DDLCompiler, **kw
) -> str:
 #eturn "%s %s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #lter_column(compiler, element.column_name),
 #DROP NOT NULL" if element.nullable else "SET NOT NULL",
 #


@compiles(ColumnType)
def visit_column_type(element: ColumnType, compiler: DDLCompiler, **kw) -> str:
 #eturn "%s %s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #lter_column(compiler, element.column_name),
 #TYPE %s" % format_type(compiler, element.type_),
 #


@compiles(ColumnName)
def visit_column_name(element: ColumnName, compiler: DDLCompiler, **kw) -> str:
 #eturn "%s RENAME %s TO %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #ormat_column_name(compiler, element.column_name),
 #ormat_column_name(compiler, element.newname),
 #


@compiles(ColumnDefault)
def visit_column_default(
 #lement: ColumnDefault, compiler: DDLCompiler, **kw
) -> str:
 #eturn "%s %s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #lter_column(compiler, element.column_name),
 #
 #SET DEFAULT %s" % format_server_default(compiler, element.default)
 #f element.default is not None
 #lse "DROP DEFAULT"
 #,
 #


@compiles(ComputedColumnDefault)
def visit_computed_column(
 #lement: ComputedColumnDefault, compiler: DDLCompiler, **kw
):
 #aise exc.CompileError(
 #Adding or removing a "computed" construct, e.g. GENERATED '
 #ALWAYS AS, to or from an existing column is not supported."
 #


@compiles(IdentityColumnDefault)
def visit_identity_column(
 #lement: IdentityColumnDefault, compiler: DDLCompiler, **kw
):
 #aise exc.CompileError(
 #Adding, removing or modifying an "identity" construct, '
 #e.g. GENERATED AS IDENTITY, to or from an existing "
 #column is not supported in this dialect."
 #


def quote_dotted(
 #ame: Union[quoted_name, str], quote: functools.partial
) -> Union[quoted_name, str]:
 #""quote the elements of a dotted name"""

 #f isinstance(name, quoted_name):
 #eturn quote(name)
 #esult = ".".join([quote(x) for x in name.split(".")])
 #eturn result


def format_table_name(
 #ompiler: Compiled,
 #ame: Union[quoted_name, str],
 #chema: Optional[Union[quoted_name, str]],
) -> Union[quoted_name, str]:
 #uote = functools.partial(compiler.preparer.quote)
 #f schema:
 #eturn quote_dotted(schema, quote) + "." + quote(name)
 #lse:
 #eturn quote(name)


def format_column_name(
 #ompiler: DDLCompiler, name: Optional[Union[quoted_name, str]]
) -> Union[quoted_name, str]:
 #eturn compiler.preparer.quote(name)  # type: ignore[arg-type]


def format_server_default(
 #ompiler: DDLCompiler,
 #efault: Optional[_ServerDefault],
) -> str:
    # this can be updated to use compiler.render_default_string
    # for SQLAlchemy 2.0 and above; not in 1.4
 #efault_str = compiler.get_column_default_string(
 #olumn("x", Integer, server_default=default)
 #
 #ssert default_str is not None
 #eturn default_str


def format_type(compiler: DDLCompiler, type_: TypeEngine) -> str:
 #eturn compiler.dialect.type_compiler.process(type_)


def alter_table(
 #ompiler: DDLCompiler,
 #ame: str,
 #chema: Optional[str],
) -> str:
 #eturn "ALTER TABLE %s" % format_table_name(compiler, name, schema)


def drop_column(
 #ompiler: DDLCompiler, name: str, if_exists: Optional[bool] = None, **kw
) -> str:
 #eturn "DROP COLUMN %s%s" % (
 #IF EXISTS " if if_exists else "",
 #ormat_column_name(compiler, name),
 #


def alter_column(compiler: DDLCompiler, name: str) -> str:
 #eturn "ALTER COLUMN %s" % format_column_name(compiler, name)


def add_column(
 #ompiler: DDLCompiler,
 #olumn: Column[Any],
 #f_not_exists: Optional[bool] = None,
 #*kw,
) -> str:
 #ext = "ADD COLUMN %s%s" % (
 #IF NOT EXISTS " if if_not_exists else "",
 #ompiler.get_column_specification(column, **kw),
 #

 #onst = " ".join(
 #ompiler.process(constraint) for constraint in column.constraints
 #
 #f const:
 #ext += " " + const

 #eturn text
