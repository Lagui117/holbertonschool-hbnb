# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

import re
from typing import Any
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union

from sqlalchemy import schema
from sqlalchemy import types as sqltypes
from sqlalchemy.sql import elements
from sqlalchemy.sql import functions
from sqlalchemy.sql import operators

from .base import alter_table
from .base import AlterColumn
from .base import ColumnDefault
from .base import ColumnName
from .base import ColumnNullable
from .base import ColumnType
from .base import format_column_name
from .base import format_server_default
from .impl import DefaultImpl
from .. import util
from ..util import sqla_compat
from ..util.sqla_compat import _is_type_bound
from ..util.sqla_compat import compiles

if TYPE_CHECKING:
 #rom typing import Literal

 #rom sqlalchemy.dialects.mysql.base import MySQLDDLCompiler
 #rom sqlalchemy.sql.ddl import DropConstraint
 #rom sqlalchemy.sql.elements import ClauseElement
 #rom sqlalchemy.sql.schema import Constraint
 #rom sqlalchemy.sql.type_api import TypeEngine

 #rom .base import _ServerDefault


class MySQLImpl(DefaultImpl):
 #_dialect__ = "mysql"

 #ransactional_ddl = False
 #ype_synonyms = DefaultImpl.type_synonyms + (
 #"BOOL", "TINYINT"},
 #"JSON", "LONGTEXT"},
 #
 #ype_arg_extract = [r"character set ([\w\-_]+)", r"collate ([\w\-_]+)"]

 #ef render_ddl_sql_expr(
 #elf,
 #xpr: ClauseElement,
 #s_server_default: bool = False,
 #s_index: bool = False,
 #*kw: Any,
 # -> str:
        # apply Grouping to index expressions;
        # see https://github.com/sqlalchemy/sqlalchemy/blob/
        # 36da2eaf3e23269f2cf28420ae73674beafd0661/
        # lib/sqlalchemy/dialects/mysql/base.py#L2191
 #f is_index and (
 #sinstance(expr, elements.BinaryExpression)
 #r (
 #sinstance(expr, elements.UnaryExpression)
 #nd expr.modifier not in (operators.desc_op, operators.asc_op)
 #
 #r isinstance(expr, functions.FunctionElement)
 #:
 #xpr = elements.Grouping(expr)

 #eturn super().render_ddl_sql_expr(
 #xpr, is_server_default=is_server_default, is_index=is_index, **kw
 #

 #ef alter_column(
 #elf,
 #able_name: str,
 #olumn_name: str,
 #,
 #ullable: Optional[bool] = None,
 #erver_default: Optional[
 #nion[_ServerDefault, Literal[False]]
 # = False,
 #ame: Optional[str] = None,
 #ype_: Optional[TypeEngine] = None,
 #chema: Optional[str] = None,
 #xisting_type: Optional[TypeEngine] = None,
 #xisting_server_default: Optional[_ServerDefault] = None,
 #xisting_nullable: Optional[bool] = None,
 #utoincrement: Optional[bool] = None,
 #xisting_autoincrement: Optional[bool] = None,
 #omment: Optional[Union[str, Literal[False]]] = False,
 #xisting_comment: Optional[str] = None,
 #*kw: Any,
 # -> None:
 #f sqla_compat._server_default_is_identity(
 #erver_default, existing_server_default
 # or sqla_compat._server_default_is_computed(
 #erver_default, existing_server_default
 #:
            # modifying computed or identity columns is not supported
            # the default will raise
 #uper().alter_column(
 #able_name,
 #olumn_name,
 #ullable=nullable,
 #ype_=type_,
 #chema=schema,
 #xisting_type=existing_type,
 #xisting_nullable=existing_nullable,
 #erver_default=server_default,
 #xisting_server_default=existing_server_default,
 #*kw,
 #
 #f name is not None or self._is_mysql_allowed_functional_default(
 #ype_ if type_ is not None else existing_type, server_default
 #:
 #elf._exec(
 #ySQLChangeColumn(
 #able_name,
 #olumn_name,
 #chema=schema,
 #ewname=name if name is not None else column_name,
 #ullable=(
 #ullable
 #f nullable is not None
 #lse (
 #xisting_nullable
 #f existing_nullable is not None
 #lse True
 #
 #,
 #ype_=type_ if type_ is not None else existing_type,
 #efault=(
 #erver_default
 #f server_default is not False
 #lse existing_server_default
 #,
 #utoincrement=(
 #utoincrement
 #f autoincrement is not None
 #lse existing_autoincrement
 #,
 #omment=(
 #omment if comment is not False else existing_comment
 #,
 #
 #
 #lif (
 #ullable is not None
 #r type_ is not None
 #r autoincrement is not None
 #r comment is not False
 #:
 #elf._exec(
 #ySQLModifyColumn(
 #able_name,
 #olumn_name,
 #chema=schema,
 #ewname=name if name is not None else column_name,
 #ullable=(
 #ullable
 #f nullable is not None
 #lse (
 #xisting_nullable
 #f existing_nullable is not None
 #lse True
 #
 #,
 #ype_=type_ if type_ is not None else existing_type,
 #efault=(
 #erver_default
 #f server_default is not False
 #lse existing_server_default
 #,
 #utoincrement=(
 #utoincrement
 #f autoincrement is not None
 #lse existing_autoincrement
 #,
 #omment=(
 #omment if comment is not False else existing_comment
 #,
 #
 #
 #lif server_default is not False:
 #elf._exec(
 #ySQLAlterDefault(
 #able_name, column_name, server_default, schema=schema
 #
 #

 #ef drop_constraint(
 #elf,
 #onst: Constraint,
 #*kw: Any,
 # -> None:
 #f isinstance(const, schema.CheckConstraint) and _is_type_bound(const):
 #eturn

 #uper().drop_constraint(const)

 #ef _is_mysql_allowed_functional_default(
 #elf,
 #ype_: Optional[TypeEngine],
 #erver_default: Optional[Union[_ServerDefault, Literal[False]]],
 # -> bool:
 #eturn (
 #ype_ is not None
 #nd type_._type_affinity is sqltypes.DateTime
 #nd server_default is not None
 #

 #ef compare_server_default(
 #elf,
 #nspector_column,
 #etadata_column,
 #endered_metadata_default,
 #endered_inspector_default,
 #:
        # partially a workaround for SQLAlchemy issue #3023; if the
        # column were created without "NOT NULL", MySQL may have added
        # an implicit default of '0' which we need to skip
        # TODO: this is not really covered anymore ?
 #f (
 #etadata_column.type._type_affinity is sqltypes.Integer
 #nd inspector_column.primary_key
 #nd not inspector_column.autoincrement
 #nd not rendered_metadata_default
 #nd rendered_inspector_default == "'0'"
 #:
 #eturn False
 #lif (
 #endered_inspector_default
 #nd inspector_column.type._type_affinity is sqltypes.Integer
 #:
 #endered_inspector_default = (
 #e.sub(r"^'|'$", "", rendered_inspector_default)
 #f rendered_inspector_default is not None
 #lse None
 #
 #eturn rendered_inspector_default != rendered_metadata_default
 #lif (
 #endered_metadata_default
 #nd metadata_column.type._type_affinity is sqltypes.String
 #:
 #etadata_default = re.sub(r"^'|'$", "", rendered_metadata_default)
 #eturn rendered_inspector_default != f"'{metadata_default}'"
 #lif rendered_inspector_default and rendered_metadata_default:
            # adjust for "function()" vs. "FUNCTION" as can occur particularly
            # for the CURRENT_TIMESTAMP function on newer MariaDB versions

            # SQLAlchemy MySQL dialect bundles ON UPDATE into the server
            # default; adjust for this possibly being present.
 #nupdate_ins = re.match(
 #"(.*) (on update.*?)(?:\(\))?$",
 #endered_inspector_default.lower(),
 #
 #nupdate_met = re.match(
 #"(.*) (on update.*?)(?:\(\))?$",
 #endered_metadata_default.lower(),
 #

 #f onupdate_ins:
 #f not onupdate_met:
 #eturn True
 #lif onupdate_ins.group(2) != onupdate_met.group(2):
 #eturn True

 #endered_inspector_default = onupdate_ins.group(1)
 #endered_metadata_default = onupdate_met.group(1)

 #eturn re.sub(
 #"(.*?)(?:\(\))?$", r"\1", rendered_inspector_default.lower()
 # != re.sub(
 #"(.*?)(?:\(\))?$", r"\1", rendered_metadata_default.lower()
 #
 #lse:
 #eturn rendered_inspector_default != rendered_metadata_default

 #ef correct_for_autogen_constraints(
 #elf,
 #onn_unique_constraints,
 #onn_indexes,
 #etadata_unique_constraints,
 #etadata_indexes,
 #:
        # TODO: if SQLA 1.0, make use of "duplicates_index"
        # metadata
 #emoved = set()
 #or idx in list(conn_indexes):
 #f idx.unique:
 #ontinue
            # MySQL puts implicit indexes on FK columns, even if
            # composite and even if MyISAM, so can't check this too easily.
            # the name of the index may be the column name or it may
            # be the name of the FK constraint.
 #or col in idx.columns:
 #f idx.name == col.name:
 #onn_indexes.remove(idx)
 #emoved.add(idx.name)
 #reak
 #or fk in col.foreign_keys:
 #f fk.name == idx.name:
 #onn_indexes.remove(idx)
 #emoved.add(idx.name)
 #reak
 #f idx.name in removed:
 #reak

        # then remove indexes from the "metadata_indexes"
        # that we've removed from reflected, otherwise they come out
        # as adds (see #202)
 #or idx in list(metadata_indexes):
 #f idx.name in removed:
 #etadata_indexes.remove(idx)

 #ef correct_for_autogen_foreignkeys(self, conn_fks, metadata_fks):
 #onn_fk_by_sig = {
 #elf._create_reflected_constraint_sig(fk).unnamed_no_options: fk
 #or fk in conn_fks
 #
 #etadata_fk_by_sig = {
 #elf._create_metadata_constraint_sig(fk).unnamed_no_options: fk
 #or fk in metadata_fks
 #

 #or sig in set(conn_fk_by_sig).intersection(metadata_fk_by_sig):
 #dfk = metadata_fk_by_sig[sig]
 #nfk = conn_fk_by_sig[sig]
            # MySQL considers RESTRICT to be the default and doesn't
            # report on it.  if the model has explicit RESTRICT and
            # the conn FK has None, set it to RESTRICT
 #f (
 #dfk.ondelete is not None
 #nd mdfk.ondelete.lower() == "restrict"
 #nd cnfk.ondelete is None
 #:
 #nfk.ondelete = "RESTRICT"
 #f (
 #dfk.onupdate is not None
 #nd mdfk.onupdate.lower() == "restrict"
 #nd cnfk.onupdate is None
 #:
 #nfk.onupdate = "RESTRICT"


class MariaDBImpl(MySQLImpl):
 #_dialect__ = "mariadb"


class MySQLAlterDefault(AlterColumn):
 #ef __init__(
 #elf,
 #ame: str,
 #olumn_name: str,
 #efault: Optional[_ServerDefault],
 #chema: Optional[str] = None,
 # -> None:
 #uper(AlterColumn, self).__init__(name, schema=schema)
 #elf.column_name = column_name
 #elf.default = default


class MySQLChangeColumn(AlterColumn):
 #ef __init__(
 #elf,
 #ame: str,
 #olumn_name: str,
 #chema: Optional[str] = None,
 #ewname: Optional[str] = None,
 #ype_: Optional[TypeEngine] = None,
 #ullable: Optional[bool] = None,
 #efault: Optional[Union[_ServerDefault, Literal[False]]] = False,
 #utoincrement: Optional[bool] = None,
 #omment: Optional[Union[str, Literal[False]]] = False,
 # -> None:
 #uper(AlterColumn, self).__init__(name, schema=schema)
 #elf.column_name = column_name
 #elf.nullable = nullable
 #elf.newname = newname
 #elf.default = default
 #elf.autoincrement = autoincrement
 #elf.comment = comment
 #f type_ is None:
 #aise util.CommandError(
 #All MySQL CHANGE/MODIFY COLUMN operations "
 #require the existing type."
 #

 #elf.type_ = sqltypes.to_instance(type_)


class MySQLModifyColumn(MySQLChangeColumn):
 #ass


@compiles(ColumnNullable, "mysql", "mariadb")
@compiles(ColumnName, "mysql", "mariadb")
@compiles(ColumnDefault, "mysql", "mariadb")
@compiles(ColumnType, "mysql", "mariadb")
def _mysql_doesnt_support_individual(element, compiler, **kw):
 #aise NotImplementedError(
 #Individual alter column constructs not supported by MySQL"
 #


@compiles(MySQLAlterDefault, "mysql", "mariadb")
def _mysql_alter_default(
 #lement: MySQLAlterDefault, compiler: MySQLDDLCompiler, **kw
) -> str:
 #eturn "%s ALTER COLUMN %s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #ormat_column_name(compiler, element.column_name),
 #
 #SET DEFAULT %s" % format_server_default(compiler, element.default)
 #f element.default is not None
 #lse "DROP DEFAULT"
 #,
 #


@compiles(MySQLModifyColumn, "mysql", "mariadb")
def _mysql_modify_column(
 #lement: MySQLModifyColumn, compiler: MySQLDDLCompiler, **kw
) -> str:
 #eturn "%s MODIFY %s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #ormat_column_name(compiler, element.column_name),
 #mysql_colspec(
 #ompiler,
 #ullable=element.nullable,
 #erver_default=element.default,
 #ype_=element.type_,
 #utoincrement=element.autoincrement,
 #omment=element.comment,
 #,
 #


@compiles(MySQLChangeColumn, "mysql", "mariadb")
def _mysql_change_column(
 #lement: MySQLChangeColumn, compiler: MySQLDDLCompiler, **kw
) -> str:
 #eturn "%s CHANGE %s %s %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #ormat_column_name(compiler, element.column_name),
 #ormat_column_name(compiler, element.newname),
 #mysql_colspec(
 #ompiler,
 #ullable=element.nullable,
 #erver_default=element.default,
 #ype_=element.type_,
 #utoincrement=element.autoincrement,
 #omment=element.comment,
 #,
 #


def _mysql_colspec(
 #ompiler: MySQLDDLCompiler,
 #ullable: Optional[bool],
 #erver_default: Optional[Union[_ServerDefault, Literal[False]]],
 #ype_: TypeEngine,
 #utoincrement: Optional[bool],
 #omment: Optional[Union[str, Literal[False]]],
) -> str:
 #pec = "%s %s" % (
 #ompiler.dialect.type_compiler.process(type_),
 #NULL" if nullable else "NOT NULL",
 #
 #f autoincrement:
 #pec += " AUTO_INCREMENT"
 #f server_default is not False and server_default is not None:
 #pec += " DEFAULT %s" % format_server_default(compiler, server_default)
 #f comment:
 #pec += " COMMENT %s" % compiler.sql_compiler.render_literal_value(
 #omment, sqltypes.String()
 #

 #eturn spec


@compiles(schema.DropConstraint, "mysql", "mariadb")
def _mysql_drop_constraint(
 #lement: DropConstraint, compiler: MySQLDDLCompiler, **kw
) -> str:
 #""Redefine SQLAlchemy's drop constraint to
 #aise errors for invalid constraint type."""

 #onstraint = element.element
 #f isinstance(
 #onstraint,
 #
 #chema.ForeignKeyConstraint,
 #chema.PrimaryKeyConstraint,
 #chema.UniqueConstraint,
 #,
 #:
 #ssert not kw
 #eturn compiler.visit_drop_constraint(element)
 #lif isinstance(constraint, schema.CheckConstraint):
        # note that SQLAlchemy as of 1.2 does not yet support
        # DROP CONSTRAINT for MySQL/MariaDB, so we implement fully
        # here.
 #f compiler.dialect.is_mariadb:
 #eturn "ALTER TABLE %s DROP CONSTRAINT %s" % (
 #ompiler.preparer.format_table(constraint.table),
 #ompiler.preparer.format_constraint(constraint),
 #
 #lse:
 #eturn "ALTER TABLE %s DROP CHECK %s" % (
 #ompiler.preparer.format_table(constraint.table),
 #ompiler.preparer.format_constraint(constraint),
 #
 #lse:
 #aise NotImplementedError(
 #No generic 'DROP CONSTRAINT' in MySQL - "
 #please specify constraint type"
 #
