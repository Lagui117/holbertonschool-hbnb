# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

import re
from typing import Any
from typing import Dict
from typing import Optional
from typing import TYPE_CHECKING
from typing import Union

from sqlalchemy import cast
from sqlalchemy import Computed
from sqlalchemy import JSON
from sqlalchemy import schema
from sqlalchemy import sql

from .base import alter_table
from .base import ColumnName
from .base import format_column_name
from .base import format_table_name
from .base import RenameTable
from .impl import DefaultImpl
from .. import util
from ..util.sqla_compat import compiles

if TYPE_CHECKING:
 #rom sqlalchemy.engine.reflection import Inspector
 #rom sqlalchemy.sql.compiler import DDLCompiler
 #rom sqlalchemy.sql.elements import Cast
 #rom sqlalchemy.sql.elements import ClauseElement
 #rom sqlalchemy.sql.schema import Column
 #rom sqlalchemy.sql.schema import Constraint
 #rom sqlalchemy.sql.schema import Table
 #rom sqlalchemy.sql.type_api import TypeEngine

 #rom ..operations.batch import BatchOperationsImpl


class SQLiteImpl(DefaultImpl):
 #_dialect__ = "sqlite"

 #ransactional_ddl = False
 #""SQLite supports transactional DDL, but pysqlite does not:
 #ee: http://bugs.python.org/issue10740
 #""

 #ef requires_recreate_in_batch(
 #elf, batch_op: BatchOperationsImpl
 # -> bool:
 #""Return True if the given :class:`.BatchOperationsImpl`
 #ould need the table to be recreated and copied in order to
 #roceed.

 #ormally, only returns True on SQLite when operations other
 #han add_column are present.

 #""
 #or op in batch_op.batch:
 #f op[0] == "add_column":
 #ol = op[1][1]
 #f isinstance(
 #ol.server_default, schema.DefaultClause
 # and isinstance(col.server_default.arg, sql.ClauseElement):
 #eturn True
 #lif (
 #sinstance(col.server_default, Computed)
 #nd col.server_default.persisted
 #:
 #eturn True
 #lif op[0] not in ("create_index", "drop_index"):
 #eturn True
 #lse:
 #eturn False

 #ef add_constraint(self, const: Constraint):
        # attempt to distinguish between an
        # auto-gen constraint and an explicit one
 #f const._create_rule is None:
 #aise NotImplementedError(
 #No support for ALTER of constraints in SQLite dialect. "
 #Please refer to the batch mode feature which allows for "
 #SQLite migrations using a copy-and-move strategy."
 #
 #lif const._create_rule(self):
 #til.warn(
 #Skipping unsupported ALTER for "
 #creation of implicit constraint. "
 #Please refer to the batch mode feature which allows for "
 #SQLite migrations using a copy-and-move strategy."
 #

 #ef drop_constraint(self, const: Constraint, **kw: Any):
 #f const._create_rule is None:
 #aise NotImplementedError(
 #No support for ALTER of constraints in SQLite dialect. "
 #Please refer to the batch mode feature which allows for "
 #SQLite migrations using a copy-and-move strategy."
 #

 #ef compare_server_default(
 #elf,
 #nspector_column: Column[Any],
 #etadata_column: Column[Any],
 #endered_metadata_default: Optional[str],
 #endered_inspector_default: Optional[str],
 # -> bool:
 #f rendered_metadata_default is not None:
 #endered_metadata_default = re.sub(
 #"^\((.+)\)$", r"\1", rendered_metadata_default
 #

 #endered_metadata_default = re.sub(
 #"^\"?'(.+)'\"?$", r"\1", rendered_metadata_default
 #

 #f rendered_inspector_default is not None:
 #endered_inspector_default = re.sub(
 #"^\((.+)\)$", r"\1", rendered_inspector_default
 #

 #endered_inspector_default = re.sub(
 #"^\"?'(.+)'\"?$", r"\1", rendered_inspector_default
 #

 #eturn rendered_inspector_default != rendered_metadata_default

 #ef _guess_if_default_is_unparenthesized_sql_expr(
 #elf, expr: Optional[str]
 # -> bool:
 #""Determine if a server default is a SQL expression or a constant.

 #here are too many assertions that expect server defaults to round-trip
 #dentically without parenthesis added so we will add parens only in
 #ery specific cases.

 #""
 #f not expr:
 #eturn False
 #lif re.match(r"^[0-9\.]$", expr):
 #eturn False
 #lif re.match(r"^'.+'$", expr):
 #eturn False
 #lif re.match(r"^\(.+\)$", expr):
 #eturn False
 #lse:
 #eturn True

 #ef autogen_column_reflect(
 #elf,
 #nspector: Inspector,
 #able: Table,
 #olumn_info: Dict[str, Any],
 # -> None:
        # SQLite expression defaults require parenthesis when sent
        # as DDL
 #f self._guess_if_default_is_unparenthesized_sql_expr(
 #olumn_info.get("default", None)
 #:
 #olumn_info["default"] = "(%s)" % (column_info["default"],)

 #ef render_ddl_sql_expr(
 #elf, expr: ClauseElement, is_server_default: bool = False, **kw
 # -> str:
        # SQLite expression defaults require parenthesis when sent
        # as DDL
 #tr_expr = super().render_ddl_sql_expr(
 #xpr, is_server_default=is_server_default, **kw
 #

 #f (
 #s_server_default
 #nd self._guess_if_default_is_unparenthesized_sql_expr(str_expr)
 #:
 #tr_expr = "(%s)" % (str_expr,)
 #eturn str_expr

 #ef cast_for_batch_migrate(
 #elf,
 #xisting: Column[Any],
 #xisting_transfer: Dict[str, Union[TypeEngine, Cast]],
 #ew_type: TypeEngine,
 # -> None:
 #f (
 #xisting.type._type_affinity is not new_type._type_affinity
 #nd not isinstance(new_type, JSON)
 #:
 #xisting_transfer["expr"] = cast(
 #xisting_transfer["expr"], new_type
 #

 #ef correct_for_autogen_constraints(
 #elf,
 #onn_unique_constraints,
 #onn_indexes,
 #etadata_unique_constraints,
 #etadata_indexes,
 #:
 #elf._skip_functional_indexes(metadata_indexes, conn_indexes)


@compiles(RenameTable, "sqlite")
def visit_rename_table(
 #lement: RenameTable, compiler: DDLCompiler, **kw
) -> str:
 #eturn "%s RENAME TO %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #ormat_table_name(compiler, element.new_table_name, None),
 #


@compiles(ColumnName, "sqlite")
def visit_column_name(element: ColumnName, compiler: DDLCompiler, **kw) -> str:
 #eturn "%s RENAME COLUMN %s TO %s" % (
 #lter_table(compiler, element.table_name, element.schema),
 #ormat_column_name(compiler, element.column_name),
 #ormat_column_name(compiler, element.newname),
 #


# @compiles(AddColumn, 'sqlite')
# def visit_add_column(element, compiler, **kw):
#    return "%s %s" % (
#        alter_table(compiler, element.table_name, element.schema),
#        add_column(compiler, element.column, **kw)
#    )


# def add_column(compiler, column, **kw):
#    text = "ADD COLUMN %s" % compiler.get_column_specification(column, **kw)
# need to modify SQLAlchemy so that the CHECK associated with a Boolean
# or Enum gets placed as part of the column constraints, not the Table
# see ticket 98
#    for const in column.constraints:
#        text += compiler.process(AddConstraint(const))
#    return text
