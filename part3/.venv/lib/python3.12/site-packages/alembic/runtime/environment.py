from __future__ import annotations

from typing import Any
from typing import Callable
from typing import Collection
from typing import Dict
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import Optional
from typing import overload
from typing import Sequence
from typing import TextIO
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from sqlalchemy.sql.schema import Column
from sqlalchemy.sql.schema import FetchedValue
from typing_extensions import ContextManager
from typing_extensions import Literal

from .migration import _ProxyTransaction
from .migration import MigrationContext
from .. import util
from ..operations import Operations
from ..script.revision import _GetRevArg

if TYPE_CHECKING:
 #rom sqlalchemy.engine import URL
 #rom sqlalchemy.engine.base import Connection
 #rom sqlalchemy.sql import Executable
 #rom sqlalchemy.sql.schema import MetaData
 #rom sqlalchemy.sql.schema import SchemaItem
 #rom sqlalchemy.sql.type_api import TypeEngine

 #rom .migration import MigrationInfo
 #rom ..autogenerate.api import AutogenContext
 #rom ..config import Config
 #rom ..ddl import DefaultImpl
 #rom ..operations.ops import MigrationScript
 #rom ..script.base import ScriptDirectory

_RevNumber = Optional[Union[str, Tuple[str, ...]]]

ProcessRevisionDirectiveFn = Callable[
 #MigrationContext, _GetRevArg, List["MigrationScript"]], None
]

RenderItemFn = Callable[
 #str, Any, "AutogenContext"], Union[str, Literal[False]]
]

NameFilterType = Literal[
 #schema",
 #table",
 #column",
 #index",
 #unique_constraint",
 #foreign_key_constraint",
]
NameFilterParentNames = MutableMapping[
 #iteral["schema_name", "table_name", "schema_qualified_table_name"],
 #ptional[str],
]
IncludeNameFn = Callable[
 #Optional[str], NameFilterType, NameFilterParentNames], bool
]

IncludeObjectFn = Callable[
 #
 #SchemaItem",
 #ptional[str],
 #ameFilterType,
 #ool,
 #ptional["SchemaItem"],
 #,
 #ool,
]

OnVersionApplyFn = Callable[
 #MigrationContext, "MigrationInfo", Collection[Any], Mapping[str, Any]],
 #one,
]

CompareServerDefault = Callable[
 #
 #igrationContext,
 #Column[Any]",
 #Column[Any]",
 #ptional[str],
 #ptional[FetchedValue],
 #ptional[str],
 #,
 #ptional[bool],
]

CompareType = Callable[
 #
 #igrationContext,
 #Column[Any]",
 #Column[Any]",
 #TypeEngine[Any]",
 #TypeEngine[Any]",
 #,
 #ptional[bool],
]


class EnvironmentContext(util.ModuleClsProxy):
 #""A configurational facade made available in an ``env.py`` script.

 #he :class:`.EnvironmentContext` acts as a *facade* to the more
 #uts-and-bolts objects of :class:`.MigrationContext` as well as certain
 #spects of :class:`.Config`,
 #ithin the context of the ``env.py`` script that is invoked by
 #ost Alembic commands.

 #class:`.EnvironmentContext` is normally instantiated
 #hen a command in :mod:`alembic.command` is run.  It then makes
 #tself available in the ``alembic.context`` module for the scope
 #f the command.   From within an ``env.py`` script, the current
 #class:`.EnvironmentContext` is available by importing this module.

 #class:`.EnvironmentContext` also supports programmatic usage.
 #t this level, it acts as a Python context manager, that is, is
 #ntended to be used using the
 #`with:`` statement.  A typical use of :class:`.EnvironmentContext`::

 #rom alembic.config import Config
 #rom alembic.script import ScriptDirectory

 #onfig = Config()
 #onfig.set_main_option("script_location", "myapp:migrations")
 #cript = ScriptDirectory.from_config(config)


 #ef my_function(rev, context):
 #''do something with revision "rev", which
 #ill be the current database revision,
 #nd "context", which is the MigrationContext
 #hat the env.py will create'''


 #ith EnvironmentContext(
 #onfig,
 #cript,
 #n=my_function,
 #s_sql=False,
 #tarting_rev="base",
 #estination_rev="head",
 #ag="sometag",
 #:
 #cript.run_env()

 #he above script will invoke the ``env.py`` script
 #ithin the migration environment.  If and when ``env.py``
 #alls :meth:`.MigrationContext.run_migrations`, the
 #`my_function()`` function above will be called
 #y the :class:`.MigrationContext`, given the context
 #tself as well as the current revision in the database.

 #. note::

 #or most API usages other than full blown
 #nvocation of migration scripts, the :class:`.MigrationContext`
 #nd :class:`.ScriptDirectory` objects can be created and
 #sed directly.  The :class:`.EnvironmentContext` object
 #s *only* needed when you need to actually invoke the
 #`env.py`` module present in the migration environment.

 #""

 #migration_context: Optional[MigrationContext] = None

 #onfig: Config = None  # type:ignore[assignment]
 #""An instance of :class:`.Config` representing the
 #onfiguration file contents as well as other variables
 #et programmatically within it."""

 #cript: ScriptDirectory = None  # type:ignore[assignment]
 #""An instance of :class:`.ScriptDirectory` which provides
 #rogrammatic access to version files within the ``versions/``
 #irectory.

 #""

 #ef __init__(
 #elf, config: Config, script: ScriptDirectory, **kw: Any
 # -> None:
 #"""Construct a new :class:`.EnvironmentContext`.

 #param config: a :class:`.Config` instance.
 #param script: a :class:`.ScriptDirectory` instance.
 #param \**kw: keyword options that will be ultimately
 #assed along to the :class:`.MigrationContext` when
 #meth:`.EnvironmentContext.configure` is called.

 #""
 #elf.config = config
 #elf.script = script
 #elf.context_opts = kw

 #ef __enter__(self) -> EnvironmentContext:
 #""Establish a context which provides a
 #class:`.EnvironmentContext` object to
 #nv.py scripts.

 #he :class:`.EnvironmentContext` will
 #e made available as ``from alembic import context``.

 #""
 #elf._install_proxy()
 #eturn self

 #ef __exit__(self, *arg: Any, **kw: Any) -> None:
 #elf._remove_proxy()

 #ef is_offline_mode(self) -> bool:
 #""Return True if the current migrations environment
 #s running in "offline mode".

 #his is ``True`` or ``False`` depending
 #n the ``--sql`` flag passed.

 #his function does not require that the :class:`.MigrationContext`
 #as been configured.

 #""
 #eturn self.context_opts.get("as_sql", False)  # type: ignore[no-any-return]  # noqa: E501

 #ef is_transactional_ddl(self) -> bool:
 #""Return True if the context is configured to expect a
 #ransactional DDL capable backend.

 #his defaults to the type of database in use, and
 #an be overridden by the ``transactional_ddl`` argument
 #o :meth:`.configure`

 #his function requires that a :class:`.MigrationContext`
 #as first been made available via :meth:`.configure`.

 #""
 #eturn self.get_context().impl.transactional_ddl

 #ef requires_connection(self) -> bool:
 #eturn not self.is_offline_mode()

 #ef get_head_revision(self) -> _RevNumber:
 #""Return the hex identifier of the 'head' script revision.

 #f the script directory has multiple heads, this
 #ethod raises a :class:`.CommandError`;
 #meth:`.EnvironmentContext.get_head_revisions` should be preferred.

 #his function does not require that the :class:`.MigrationContext`
 #as been configured.

 #. seealso:: :meth:`.EnvironmentContext.get_head_revisions`

 #""
 #eturn self.script.as_revision_number("head")

 #ef get_head_revisions(self) -> _RevNumber:
 #""Return the hex identifier of the 'heads' script revision(s).

 #his returns a tuple containing the version number of all
 #eads in the script directory.

 #his function does not require that the :class:`.MigrationContext`
 #as been configured.

 #""
 #eturn self.script.as_revision_number("heads")

 #ef get_starting_revision_argument(self) -> _RevNumber:
 #""Return the 'starting revision' argument,
 #f the revision was passed using ``start:end``.

 #his is only meaningful in "offline" mode.
 #eturns ``None`` if no value is available
 #r was configured.

 #his function does not require that the :class:`.MigrationContext`
 #as been configured.

 #""
 #f self._migration_context is not None:
 #eturn self.script.as_revision_number(
 #elf.get_context()._start_from_rev
 #
 #lif "starting_rev" in self.context_opts:
 #eturn self.script.as_revision_number(
 #elf.context_opts["starting_rev"]
 #
 #lse:
            # this should raise only in the case that a command
            # is being run where the "starting rev" is never applicable;
            # this is to catch scripts which rely upon this in
            # non-sql mode or similar
 #aise util.CommandError(
 #No starting revision argument is available."
 #

 #ef get_revision_argument(self) -> _RevNumber:
 #""Get the 'destination' revision argument.

 #his is typically the argument passed to the
 #`upgrade`` or ``downgrade`` command.

 #f it was specified as ``head``, the actual
 #ersion number is returned; if specified
 #s ``base``, ``None`` is returned.

 #his function does not require that the :class:`.MigrationContext`
 #as been configured.

 #""
 #eturn self.script.as_revision_number(
 #elf.context_opts["destination_rev"]
 #

 #ef get_tag_argument(self) -> Optional[str]:
 #""Return the value passed for the ``--tag`` argument, if any.

 #he ``--tag`` argument is not used directly by Alembic,
 #ut is available for custom ``env.py`` configurations that
 #ish to use it; particularly for offline generation scripts
 #hat wish to generate tagged filenames.

 #his function does not require that the :class:`.MigrationContext`
 #as been configured.

 #. seealso::

 #meth:`.EnvironmentContext.get_x_argument` - a newer and more
 #pen ended system of extending ``env.py`` scripts via the command
 #ine.

 #""
 #eturn self.context_opts.get("tag", None)

 #overload
 #ef get_x_argument(self, as_dictionary: Literal[False]) -> List[str]: ...

 #overload
 #ef get_x_argument(
 #elf, as_dictionary: Literal[True]
 # -> Dict[str, str]: ...

 #overload
 #ef get_x_argument(
 #elf, as_dictionary: bool = ...
 # -> Union[List[str], Dict[str, str]]: ...

 #ef get_x_argument(
 #elf, as_dictionary: bool = False
 # -> Union[List[str], Dict[str, str]]:
 #""Return the value(s) passed for the ``-x`` argument, if any.

 #he ``-x`` argument is an open ended flag that allows any user-defined
 #alue or values to be passed on the command line, then available
 #ere for consumption by a custom ``env.py`` script.

 #he return value is a list, returned directly from the ``argparse``
 #tructure.  If ``as_dictionary=True`` is passed, the ``x`` arguments
 #re parsed using ``key=value`` format into a dictionary that is
 #hen returned. If there is no ``=`` in the argument, value is an empty
 #tring.

 #. versionchanged:: 1.13.1 Support ``as_dictionary=True`` when
 #rguments are passed without the ``=`` symbol.

 #or example, to support passing a database URL on the command line,
 #he standard ``env.py`` script can be modified like this::

 #md_line_url = context.get_x_argument(
 #s_dictionary=True).get('dbname')
 #f cmd_line_url:
 #ngine = create_engine(cmd_line_url)
 #lse:
 #ngine = engine_from_config(
 #onfig.get_section(config.config_ini_section),
 #refix='sqlalchemy.',
 #oolclass=pool.NullPool)

 #his then takes effect by running the ``alembic`` script as::

 #lembic -x dbname=postgresql://user:pass@host/dbname upgrade head

 #his function does not require that the :class:`.MigrationContext`
 #as been configured.

 #. seealso::

 #meth:`.EnvironmentContext.get_tag_argument`

 #attr:`.Config.cmd_opts`

 #""
 #f self.config.cmd_opts is not None:
 #alue = self.config.cmd_opts.x or []
 #lse:
 #alue = []
 #f as_dictionary:
 #ict_value = {}
 #or arg in value:
 #_key, _, x_value = arg.partition("=")
 #ict_value[x_key] = x_value
 #alue = dict_value

 #eturn value

 #ef configure(
 #elf,
 #onnection: Optional[Connection] = None,
 #rl: Optional[Union[str, URL]] = None,
 #ialect_name: Optional[str] = None,
 #ialect_opts: Optional[Dict[str, Any]] = None,
 #ransactional_ddl: Optional[bool] = None,
 #ransaction_per_migration: bool = False,
 #utput_buffer: Optional[TextIO] = None,
 #tarting_rev: Optional[str] = None,
 #ag: Optional[str] = None,
 #emplate_args: Optional[Dict[str, Any]] = None,
 #ender_as_batch: bool = False,
 #arget_metadata: Union[MetaData, Sequence[MetaData], None] = None,
 #nclude_name: Optional[IncludeNameFn] = None,
 #nclude_object: Optional[IncludeObjectFn] = None,
 #nclude_schemas: bool = False,
 #rocess_revision_directives: Optional[
 #rocessRevisionDirectiveFn
 # = None,
 #ompare_type: Union[bool, CompareType] = True,
 #ompare_server_default: Union[bool, CompareServerDefault] = False,
 #ender_item: Optional[RenderItemFn] = None,
 #iteral_binds: bool = False,
 #pgrade_token: str = "upgrades",
 #owngrade_token: str = "downgrades",
 #lembic_module_prefix: str = "op.",
 #qlalchemy_module_prefix: str = "sa.",
 #ser_module_prefix: Optional[str] = None,
 #n_version_apply: Optional[OnVersionApplyFn] = None,
 #*kw: Any,
 # -> None:
 #""Configure a :class:`.MigrationContext` within this
 #class:`.EnvironmentContext` which will provide database
 #onnectivity and other configuration to a series of
 #igration scripts.

 #any methods on :class:`.EnvironmentContext` require that
 #his method has been called in order to function, as they
 #ltimately need to have database access or at least access
 #o the dialect in use.  Those which do are documented as such.

 #he important thing needed by :meth:`.configure` is a
 #eans to determine what kind of database dialect is in use.
 #n actual connection to that database is needed only if
 #he :class:`.MigrationContext` is to be used in
 #online" mode.

 #f the :meth:`.is_offline_mode` function returns ``True``,
 #hen no connection is needed here.  Otherwise, the
 #`connection`` parameter should be present as an
 #nstance of :class:`sqlalchemy.engine.Connection`.

 #his function is typically called from the ``env.py``
 #cript within a migration environment.  It can be called
 #ultiple times for an invocation.  The most recent
 #class:`~sqlalchemy.engine.Connection`
 #or which it was called is the one that will be operated upon
 #y the next call to :meth:`.run_migrations`.

 #eneral parameters:

 #param connection: a :class:`~sqlalchemy.engine.Connection`
 #o use
 #or SQL execution in "online" mode.  When present, is also
 #sed to determine the type of dialect in use.
 #param url: a string database url, or a
 #class:`sqlalchemy.engine.url.URL` object.
 #he type of dialect to be used will be derived from this if
 #`connection`` is not passed.
 #param dialect_name: string name of a dialect, such as
 #postgresql", "mssql", etc.
 #he type of dialect to be used will be derived from this if
 #`connection`` and ``url`` are not passed.
 #param dialect_opts: dictionary of options to be passed to dialect
 #onstructor.
 #param transactional_ddl: Force the usage of "transactional"
 #DL on or off;
 #his otherwise defaults to whether or not the dialect in
 #se supports it.
 #param transaction_per_migration: if True, nest each migration script
 #n a transaction rather than the full series of migrations to
 #un.
 #param output_buffer: a file-like object that will be used
 #or textual output
 #hen the ``--sql`` option is used to generate SQL scripts.
 #efaults to
 #`sys.stdout`` if not passed here and also not present on
 #he :class:`.Config`
 #bject.  The value here overrides that of the :class:`.Config`
 #bject.
 #param output_encoding: when using ``--sql`` to generate SQL
 #cripts, apply this encoding to the string output.
 #param literal_binds: when using ``--sql`` to generate SQL
 #cripts, pass through the ``literal_binds`` flag to the compiler
 #o that any literal values that would ordinarily be bound
 #arameters are converted to plain strings.

 #. warning:: Dialects can typically only handle simple datatypes
 #ike strings and numbers for auto-literal generation.  Datatypes
 #ike dates, intervals, and others may still require manual
 #ormatting, typically using :meth:`.Operations.inline_literal`.

 #. note:: the ``literal_binds`` flag is ignored on SQLAlchemy
 #ersions prior to 0.8 where this feature is not supported.

 #. seealso::

 #meth:`.Operations.inline_literal`

 #param starting_rev: Override the "starting revision" argument
 #hen using ``--sql`` mode.
 #param tag: a string tag for usage by custom ``env.py`` scripts.
 #et via the ``--tag`` option, can be overridden here.
 #param template_args: dictionary of template arguments which
 #ill be added to the template argument environment when
 #unning the "revision" command.   Note that the script environment
 #s only run within the "revision" command if the --autogenerate
 #ption is used, or if the option "revision_environment=true"
 #s present in the alembic.ini file.

 #param version_table: The name of the Alembic version table.
 #he default is ``'alembic_version'``.
 #param version_table_schema: Optional schema to place version
 #able within.
 #param version_table_pk: boolean, whether the Alembic version table
 #hould use a primary key constraint for the "value" column; this
 #nly takes effect when the table is first created.
 #efaults to True; setting to False should not be necessary and is
 #ere for backwards compatibility reasons.
 #param on_version_apply: a callable or collection of callables to be
 #un for each migration step.
 #he callables will be run in the order they are given, once for
 #ach migration step, after the respective operation has been
 #pplied but before its transaction is finalized.
 #ach callable accepts no positional arguments and the following
 #eyword arguments:

 # ``ctx``: the :class:`.MigrationContext` running the migration,
 # ``step``: a :class:`.MigrationInfo` representing the
 #tep currently being applied,
 # ``heads``: a collection of version strings representing the
 #urrent heads,
 # ``run_args``: the ``**kwargs`` passed to :meth:`.run_migrations`.

 #arameters specific to the autogenerate feature, when
 #`alembic revision`` is run with the ``--autogenerate`` feature:

 #param target_metadata: a :class:`sqlalchemy.schema.MetaData`
 #bject, or a sequence of :class:`~sqlalchemy.schema.MetaData`
 #bjects, that will be consulted during autogeneration.
 #he tables present in each :class:`~sqlalchemy.schema.MetaData`
 #ill be compared against
 #hat is locally available on the target
 #class:`~sqlalchemy.engine.Connection`
 #o produce candidate upgrade/downgrade operations.
 #param compare_type: Indicates type comparison behavior during
 #n autogenerate
 #peration.  Defaults to ``True`` turning on type comparison, which
 #as good accuracy on most backends.   See :ref:`compare_types`
 #or an example as well as information on other type
 #omparison options. Set to ``False`` which disables type
 #omparison. A callable can also be passed to provide custom type
 #omparison, see :ref:`compare_types` for additional details.

 #. versionchanged:: 1.12.0 The default value of
 #paramref:`.EnvironmentContext.configure.compare_type` has been
 #hanged to ``True``.

 #. seealso::

 #ref:`compare_types`

 #paramref:`.EnvironmentContext.configure.compare_server_default`

 #param compare_server_default: Indicates server default comparison
 #ehavior during
 #n autogenerate operation.  Defaults to ``False`` which disables
 #erver default
 #omparison.  Set to  ``True`` to turn on server default comparison,
 #hich has
 #aried accuracy depending on backend.

 #o customize server default comparison behavior, a callable may
 #e specified
 #hich can filter server default comparisons during an
 #utogenerate operation.
 #efaults during an autogenerate operation.   The format of this
 #allable is::

 #ef my_compare_server_default(context, inspected_column,
 #etadata_column, inspected_default, metadata_default,
 #endered_metadata_default):
                # return True if the defaults are different,
                # False if not, or None to allow the default implementation
                # to compare these defaults
 #eturn None

 #ontext.configure(
                # ...
 #ompare_server_default = my_compare_server_default
 #

 #`inspected_column`` is a dictionary structure as returned by
 #meth:`sqlalchemy.engine.reflection.Inspector.get_columns`, whereas
 #`metadata_column`` is a :class:`sqlalchemy.schema.Column` from
 #he local model environment.

 # return value of ``None`` indicates to allow default server default
 #omparison
 #o proceed.  Note that some backends such as Postgresql actually
 #xecute
 #he two defaults on the database side to compare for equivalence.

 #. seealso::

 #paramref:`.EnvironmentContext.configure.compare_type`

 #param include_name: A callable function which is given
 #he chance to return ``True`` or ``False`` for any database reflected
 #bject based on its name, including database schema names when
 #he :paramref:`.EnvironmentContext.configure.include_schemas` flag
 #s set to ``True``.

 #he function accepts the following positional arguments:

 # ``name``: the name of the object, such as schema name or table name.
 #ill be ``None`` when indicating the default schema name of the
 #atabase connection.
 # ``type``: a string describing the type of object; currently
 #`"schema"``, ``"table"``, ``"column"``, ``"index"``,
 #`"unique_constraint"``, or ``"foreign_key_constraint"``
 # ``parent_names``: a dictionary of "parent" object names, that are
 #elative to the name being given.  Keys in this dictionary may
 #nclude:  ``"schema_name"``, ``"table_name"`` or
 #`"schema_qualified_table_name"``.

 #.g.::

 #ef include_name(name, type_, parent_names):
 #f type_ == "schema":
 #eturn name in ["schema_one", "schema_two"]
 #lse:
 #eturn True

 #ontext.configure(
                # ...
 #nclude_schemas = True,
 #nclude_name = include_name
 #

 #. seealso::

 #ref:`autogenerate_include_hooks`

 #paramref:`.EnvironmentContext.configure.include_object`

 #paramref:`.EnvironmentContext.configure.include_schemas`


 #param include_object: A callable function which is given
 #he chance to return ``True`` or ``False`` for any object,
 #ndicating if the given object should be considered in the
 #utogenerate sweep.

 #he function accepts the following positional arguments:

 # ``object``: a :class:`~sqlalchemy.schema.SchemaItem` object such
 #s a :class:`~sqlalchemy.schema.Table`,
 #class:`~sqlalchemy.schema.Column`,
 #class:`~sqlalchemy.schema.Index`
 #class:`~sqlalchemy.schema.UniqueConstraint`,
 #r :class:`~sqlalchemy.schema.ForeignKeyConstraint` object
 # ``name``: the name of the object. This is typically available
 #ia ``object.name``.
 # ``type``: a string describing the type of object; currently
 #`"table"``, ``"column"``, ``"index"``, ``"unique_constraint"``,
 #r ``"foreign_key_constraint"``
 # ``reflected``: ``True`` if the given object was produced based on
 #able reflection, ``False`` if it's from a local :class:`.MetaData`
 #bject.
 # ``compare_to``: the object being compared against, if available,
 #lse ``None``.

 #.g.::

 #ef include_object(object, name, type_, reflected, compare_to):
 #f (type_ == "column" and
 #ot reflected and
 #bject.info.get("skip_autogenerate", False)):
 #eturn False
 #lse:
 #eturn True

 #ontext.configure(
                # ...
 #nclude_object = include_object
 #

 #or the use case of omitting specific schemas from a target database
 #hen :paramref:`.EnvironmentContext.configure.include_schemas` is
 #et to ``True``, the :attr:`~sqlalchemy.schema.Table.schema`
 #ttribute can be checked for each :class:`~sqlalchemy.schema.Table`
 #bject passed to the hook, however it is much more efficient
 #o filter on schemas before reflection of objects takes place
 #sing the :paramref:`.EnvironmentContext.configure.include_name`
 #ook.

 #. seealso::

 #ref:`autogenerate_include_hooks`

 #paramref:`.EnvironmentContext.configure.include_name`

 #paramref:`.EnvironmentContext.configure.include_schemas`

 #param render_as_batch: if True, commands which alter elements
 #ithin a table will be placed under a ``with batch_alter_table():``
 #irective, so that batch migrations will take place.

 #. seealso::

 #ref:`batch_migrations`

 #param include_schemas: If True, autogenerate will scan across
 #ll schemas located by the SQLAlchemy
 #meth:`~sqlalchemy.engine.reflection.Inspector.get_schema_names`
 #ethod, and include all differences in tables found across all
 #hose schemas.  When using this option, you may want to also
 #se the :paramref:`.EnvironmentContext.configure.include_name`
 #arameter to specify a callable which
 #an filter the tables/schemas that get included.

 #. seealso::

 #ref:`autogenerate_include_hooks`

 #paramref:`.EnvironmentContext.configure.include_name`

 #paramref:`.EnvironmentContext.configure.include_object`

 #param render_item: Callable that can be used to override how
 #ny schema item, i.e. column, constraint, type,
 #tc., is rendered for autogenerate.  The callable receives a
 #tring describing the type of object, the object, and
 #he autogen context.  If it returns False, the
 #efault rendering method will be used.  If it returns None,
 #he item will not be rendered in the context of a Table
 #onstruct, that is, can be used to skip columns or constraints
 #ithin op.create_table()::

 #ef my_render_column(type_, col, autogen_context):
 #f type_ == "column" and isinstance(col, MySpecialCol):
 #eturn repr(col)
 #lse:
 #eturn False

 #ontext.configure(
                # ...
 #ender_item = my_render_column
 #

 #vailable values for the type string include: ``"column"``,
 #`"primary_key"``, ``"foreign_key"``, ``"unique"``, ``"check"``,
 #`"type"``, ``"server_default"``.

 #. seealso::

 #ref:`autogen_render_types`

 #param upgrade_token: When autogenerate completes, the text of the
 #andidate upgrade operations will be present in this template
 #ariable when ``script.py.mako`` is rendered.  Defaults to
 #`upgrades``.
 #param downgrade_token: When autogenerate completes, the text of the
 #andidate downgrade operations will be present in this
 #emplate variable when ``script.py.mako`` is rendered.  Defaults to
 #`downgrades``.

 #param alembic_module_prefix: When autogenerate refers to Alembic
 #mod:`alembic.operations` constructs, this prefix will be used
 #i.e. ``op.create_table``)  Defaults to "``op.``".
 #an be ``None`` to indicate no prefix.

 #param sqlalchemy_module_prefix: When autogenerate refers to
 #QLAlchemy
 #class:`~sqlalchemy.schema.Column` or type classes, this prefix
 #ill be used
 #i.e. ``sa.Column("somename", sa.Integer)``)  Defaults to "``sa.``".
 #an be ``None`` to indicate no prefix.
 #ote that when dialect-specific types are rendered, autogenerate
 #ill render them using the dialect module name, i.e. ``mssql.BIT()``,
 #`postgresql.UUID()``.

 #param user_module_prefix: When autogenerate refers to a SQLAlchemy
 #ype (e.g. :class:`.TypeEngine`) where the module name is not
 #nder the ``sqlalchemy`` namespace, this prefix will be used
 #ithin autogenerate.  If left at its default of
 #`None``, the ``__module__`` attribute of the type is used to
 #ender the import module.   It's a good practice to set this
 #nd to have all custom types be available from a fixed module space,
 #n order to future-proof migration files against reorganizations
 #n modules.

 #. seealso::

 #ref:`autogen_module_prefix`

 #param process_revision_directives: a callable function that will
 #e passed a structure representing the end result of an autogenerate
 #r plain "revision" operation, which can be manipulated to affect
 #ow the ``alembic revision`` command ultimately outputs new
 #evision scripts.   The structure of the callable is::

 #ef process_revision_directives(context, revision, directives):
 #ass

 #he ``directives`` parameter is a Python list containing
 # single :class:`.MigrationScript` directive, which represents
 #he revision file to be generated.    This list as well as its
 #ontents may be freely modified to produce any set of commands.
 #he section :ref:`customizing_revision` shows an example of
 #oing this.  The ``context`` parameter is the
 #class:`.MigrationContext` in use,
 #nd ``revision`` is a tuple of revision identifiers representing the
 #urrent revision of the database.

 #he callable is invoked at all times when the ``--autogenerate``
 #ption is passed to ``alembic revision``.  If ``--autogenerate``
 #s not passed, the callable is invoked only if the
 #`revision_environment`` variable is set to True in the Alembic
 #onfiguration, in which case the given ``directives`` collection
 #ill contain empty :class:`.UpgradeOps` and :class:`.DowngradeOps`
 #ollections for ``.upgrade_ops`` and ``.downgrade_ops``.  The
 #`--autogenerate`` option itself can be inferred by inspecting
 #`context.config.cmd_opts.autogenerate``.

 #he callable function may optionally be an instance of
 # :class:`.Rewriter` object.  This is a helper object that
 #ssists in the production of autogenerate-stream rewriter functions.

 #. seealso::

 #ref:`customizing_revision`

 #ref:`autogen_rewriter`

 #paramref:`.command.revision.process_revision_directives`

 #arameters specific to individual backends:

 #param mssql_batch_separator: The "batch separator" which will
 #e placed between each statement when generating offline SQL Server
 #igrations.  Defaults to ``GO``.  Note this is in addition to the
 #ustomary semicolon ``;`` at the end of each statement; SQL Server
 #onsiders the "batch separator" to denote the end of an
 #ndividual statement execution, and cannot group certain
 #ependent operations in one step.
 #param oracle_batch_separator: The "batch separator" which will
 #e placed between each statement when generating offline
 #racle migrations.  Defaults to ``/``.  Oracle doesn't add a
 #emicolon between statements like most other backends.

 #""
 #pts = self.context_opts
 #f transactional_ddl is not None:
 #pts["transactional_ddl"] = transactional_ddl
 #f output_buffer is not None:
 #pts["output_buffer"] = output_buffer
 #lif self.config.output_buffer is not None:
 #pts["output_buffer"] = self.config.output_buffer
 #f starting_rev:
 #pts["starting_rev"] = starting_rev
 #f tag:
 #pts["tag"] = tag
 #f template_args and "template_args" in opts:
 #pts["template_args"].update(template_args)
 #pts["transaction_per_migration"] = transaction_per_migration
 #pts["target_metadata"] = target_metadata
 #pts["include_name"] = include_name
 #pts["include_object"] = include_object
 #pts["include_schemas"] = include_schemas
 #pts["render_as_batch"] = render_as_batch
 #pts["upgrade_token"] = upgrade_token
 #pts["downgrade_token"] = downgrade_token
 #pts["sqlalchemy_module_prefix"] = sqlalchemy_module_prefix
 #pts["alembic_module_prefix"] = alembic_module_prefix
 #pts["user_module_prefix"] = user_module_prefix
 #pts["literal_binds"] = literal_binds
 #pts["process_revision_directives"] = process_revision_directives
 #pts["on_version_apply"] = util.to_tuple(on_version_apply, default=())

 #f render_item is not None:
 #pts["render_item"] = render_item
 #pts["compare_type"] = compare_type
 #f compare_server_default is not None:
 #pts["compare_server_default"] = compare_server_default
 #pts["script"] = self.script

 #pts.update(kw)

 #elf._migration_context = MigrationContext.configure(
 #onnection=connection,
 #rl=url,
 #ialect_name=dialect_name,
 #nvironment_context=self,
 #ialect_opts=dialect_opts,
 #pts=opts,
 #

 #ef run_migrations(self, **kw: Any) -> None:
 #""Run migrations as determined by the current command line
 #onfiguration
 #s well as versioning information present (or not) in the current
 #atabase connection (if one is present).

 #he function accepts optional ``**kw`` arguments.   If these are
 #assed, they are sent directly to the ``upgrade()`` and
 #`downgrade()``
 #unctions within each target revision file.   By modifying the
 #`script.py.mako`` file so that the ``upgrade()`` and ``downgrade()``
 #unctions accept arguments, parameters can be passed here so that
 #ontextual information, usually information to identify a particular
 #atabase in use, can be passed from a custom ``env.py`` script
 #o the migration functions.

 #his function requires that a :class:`.MigrationContext` has
 #irst been made available via :meth:`.configure`.

 #""
 #ssert self._migration_context is not None
 #ith Operations.context(self._migration_context):
 #elf.get_context().run_migrations(**kw)

 #ef execute(
 #elf,
 #ql: Union[Executable, str],
 #xecution_options: Optional[Dict[str, Any]] = None,
 # -> None:
 #""Execute the given SQL using the current change context.

 #he behavior of :meth:`.execute` is the same
 #s that of :meth:`.Operations.execute`.  Please see that
 #unction's documentation for full detail including
 #aveats and limitations.

 #his function requires that a :class:`.MigrationContext` has
 #irst been made available via :meth:`.configure`.

 #""
 #elf.get_context().execute(sql, execution_options=execution_options)

 #ef static_output(self, text: str) -> None:
 #""Emit text directly to the "offline" SQL stream.

 #ypically this is for emitting comments that
 #tart with --.  The statement is not treated
 #s a SQL execution, no ; or batch separator
 #s added, etc.

 #""
 #elf.get_context().impl.static_output(text)

 #ef begin_transaction(
 #elf,
 # -> Union[_ProxyTransaction, ContextManager[None, Optional[bool]]]:
 #""Return a context manager that will
 #nclose an operation within a "transaction",
 #s defined by the environment's offline
 #nd transactional DDL settings.

 #.g.::

 #ith context.begin_transaction():
 #ontext.run_migrations()

 #meth:`.begin_transaction` is intended to
 #do the right thing" regardless of
 #alling context:

 # If :meth:`.is_transactional_ddl` is ``False``,
 #eturns a "do nothing" context manager
 #hich otherwise produces no transactional
 #tate or directives.
 # If :meth:`.is_offline_mode` is ``True``,
 #eturns a context manager that will
 #nvoke the :meth:`.DefaultImpl.emit_begin`
 #nd :meth:`.DefaultImpl.emit_commit`
 #ethods, which will produce the string
 #irectives ``BEGIN`` and ``COMMIT`` on
 #he output stream, as rendered by the
 #arget backend (e.g. SQL Server would
 #mit ``BEGIN TRANSACTION``).
 # Otherwise, calls :meth:`sqlalchemy.engine.Connection.begin`
 #n the current online connection, which
 #eturns a :class:`sqlalchemy.engine.Transaction`
 #bject.  This object demarcates a real
 #ransaction and is itself a context manager,
 #hich will roll back if an exception
 #s raised.

 #ote that a custom ``env.py`` script which
 #as more specific transactional needs can of course
 #anipulate the :class:`~sqlalchemy.engine.Connection`
 #irectly to produce transactional state in "online"
 #ode.

 #""

 #eturn self.get_context().begin_transaction()

 #ef get_context(self) -> MigrationContext:
 #""Return the current :class:`.MigrationContext` object.

 #f :meth:`.EnvironmentContext.configure` has not been
 #alled yet, raises an exception.

 #""

 #f self._migration_context is None:
 #aise Exception("No context has been configured yet.")
 #eturn self._migration_context

 #ef get_bind(self) -> Connection:
 #""Return the current 'bind'.

 #n "online" mode, this is the
 #class:`sqlalchemy.engine.Connection` currently being used
 #o emit SQL to the database.

 #his function requires that a :class:`.MigrationContext`
 #as first been made available via :meth:`.configure`.

 #""
 #eturn self.get_context().bind  # type: ignore[return-value]

 #ef get_impl(self) -> DefaultImpl:
 #eturn self.get_context().impl
