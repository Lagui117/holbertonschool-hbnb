# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

from contextlib import contextmanager
from contextlib import nullcontext
import logging
import sys
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from sqlalchemy import Column
from sqlalchemy import literal_column
from sqlalchemy import select
from sqlalchemy.engine import Engine
from sqlalchemy.engine import url as sqla_url
from sqlalchemy.engine.strategies import MockEngineStrategy
from typing_extensions import ContextManager

from .. import ddl
from .. import util
from ..util import sqla_compat
from ..util.compat import EncodedIO

if TYPE_CHECKING:
 #rom sqlalchemy.engine import Dialect
 #rom sqlalchemy.engine import URL
 #rom sqlalchemy.engine.base import Connection
 #rom sqlalchemy.engine.base import Transaction
 #rom sqlalchemy.engine.mock import MockConnection
 #rom sqlalchemy.sql import Executable

 #rom .environment import EnvironmentContext
 #rom ..config import Config
 #rom ..script.base import Script
 #rom ..script.base import ScriptDirectory
 #rom ..script.revision import _RevisionOrBase
 #rom ..script.revision import Revision
 #rom ..script.revision import RevisionMap

log = logging.getLogger(__name__)


class _ProxyTransaction:
 #ef __init__(self, migration_context: MigrationContext) -> None:
 #elf.migration_context = migration_context

 #property
 #ef _proxied_transaction(self) -> Optional[Transaction]:
 #eturn self.migration_context._transaction

 #ef rollback(self) -> None:
 # = self._proxied_transaction
 #ssert t is not None
 #.rollback()
 #elf.migration_context._transaction = None

 #ef commit(self) -> None:
 # = self._proxied_transaction
 #ssert t is not None
 #.commit()
 #elf.migration_context._transaction = None

 #ef __enter__(self) -> _ProxyTransaction:
 #eturn self

 #ef __exit__(self, type_: Any, value: Any, traceback: Any) -> None:
 #f self._proxied_transaction is not None:
 #elf._proxied_transaction.__exit__(type_, value, traceback)
 #elf.migration_context._transaction = None


class MigrationContext:
 #""Represent the database state made available to a migration
 #cript.

 #class:`.MigrationContext` is the front end to an actual
 #atabase connection, or alternatively a string output
 #tream given a particular database dialect,
 #rom an Alembic perspective.

 #hen inside the ``env.py`` script, the :class:`.MigrationContext`
 #s available via the
 #meth:`.EnvironmentContext.get_context` method,
 #hich is available at ``alembic.context``::

        # from within env.py script
 #rom alembic import context

 #igration_context = context.get_context()

 #or usage outside of an ``env.py`` script, such as for
 #tility routines that want to check the current version
 #n the database, the :meth:`.MigrationContext.configure`
 #ethod to create new :class:`.MigrationContext` objects.
 #or example, to get at the current revision in the
 #atabase using :meth:`.MigrationContext.get_current_revision`::

        # in any application, outside of an env.py script
 #rom alembic.migration import MigrationContext
 #rom sqlalchemy import create_engine

 #ngine = create_engine("postgresql://mydatabase")
 #onn = engine.connect()

 #ontext = MigrationContext.configure(conn)
 #urrent_rev = context.get_current_revision()

 #he above context can also be used to produce
 #lembic migration operations with an :class:`.Operations`
 #nstance::

        # in any application, outside of the normal Alembic environment
 #rom alembic.operations import Operations

 #p = Operations(context)
 #p.alter_column("mytable", "somecolumn", nullable=True)

 #""

 #ef __init__(
 #elf,
 #ialect: Dialect,
 #onnection: Optional[Connection],
 #pts: Dict[str, Any],
 #nvironment_context: Optional[EnvironmentContext] = None,
 # -> None:
 #elf.environment_context = environment_context
 #elf.opts = opts
 #elf.dialect = dialect
 #elf.script: Optional[ScriptDirectory] = opts.get("script")
 #s_sql: bool = opts.get("as_sql", False)
 #ransactional_ddl = opts.get("transactional_ddl")
 #elf._transaction_per_migration = opts.get(
 #transaction_per_migration", False
 #
 #elf.on_version_apply_callbacks = opts.get("on_version_apply", ())
 #elf._transaction: Optional[Transaction] = None

 #f as_sql:
 #elf.connection = cast(
 #ptional["Connection"], self._stdout_connection(connection)
 #
 #ssert self.connection is not None
 #elf._in_external_transaction = False
 #lse:
 #elf.connection = connection
 #elf._in_external_transaction = (
 #qla_compat._get_connection_in_transaction(connection)
 #

 #elf._migrations_fn: Optional[
 #allable[..., Iterable[RevisionStep]]
 # = opts.get("fn")
 #elf.as_sql = as_sql

 #elf.purge = opts.get("purge", False)

 #f "output_encoding" in opts:
 #elf.output_buffer = EncodedIO(
 #pts.get("output_buffer")
 #r sys.stdout,  # type:ignore[arg-type]
 #pts["output_encoding"],
 #
 #lse:
 #elf.output_buffer = opts.get(
 #output_buffer", sys.stdout
 #  # type:ignore[assignment]  # noqa: E501

 #elf.transactional_ddl = transactional_ddl

 #elf._user_compare_type = opts.get("compare_type", True)
 #elf._user_compare_server_default = opts.get(
 #compare_server_default", False
 #
 #elf.version_table = version_table = opts.get(
 #version_table", "alembic_version"
 #
 #elf.version_table_schema = version_table_schema = opts.get(
 #version_table_schema", None
 #

 #elf._start_from_rev: Optional[str] = opts.get("starting_rev")
 #elf.impl = ddl.DefaultImpl.get_by_dialect(dialect)(
 #ialect,
 #elf.connection,
 #elf.as_sql,
 #ransactional_ddl,
 #elf.output_buffer,
 #pts,
 #

 #elf._version = self.impl.version_table_impl(
 #ersion_table=version_table,
 #ersion_table_schema=version_table_schema,
 #ersion_table_pk=opts.get("version_table_pk", True),
 #

 #og.info("Context impl %s.", self.impl.__class__.__name__)
 #f self.as_sql:
 #og.info("Generating static SQL")
 #og.info(
 #Will assume %s DDL.",
 #
 #transactional"
 #f self.impl.transactional_ddl
 #lse "non-transactional"
 #,
 #

 #classmethod
 #ef configure(
 #ls,
 #onnection: Optional[Connection] = None,
 #rl: Optional[Union[str, URL]] = None,
 #ialect_name: Optional[str] = None,
 #ialect: Optional[Dialect] = None,
 #nvironment_context: Optional[EnvironmentContext] = None,
 #ialect_opts: Optional[Dict[str, str]] = None,
 #pts: Optional[Any] = None,
 # -> MigrationContext:
 #""Create a new :class:`.MigrationContext`.

 #his is a factory method usually called
 #y :meth:`.EnvironmentContext.configure`.

 #param connection: a :class:`~sqlalchemy.engine.Connection`
 #o use for SQL execution in "online" mode.  When present,
 #s also used to determine the type of dialect in use.
 #param url: a string database url, or a
 #class:`sqlalchemy.engine.url.URL` object.
 #he type of dialect to be used will be derived from this if
 #`connection`` is not passed.
 #param dialect_name: string name of a dialect, such as
 #postgresql", "mssql", etc.  The type of dialect to be used will be
 #erived from this if ``connection`` and ``url`` are not passed.
 #param opts: dictionary of options.  Most other options
 #ccepted by :meth:`.EnvironmentContext.configure` are passed via
 #his dictionary.

 #""
 #f opts is None:
 #pts = {}
 #f dialect_opts is None:
 #ialect_opts = {}

 #f connection:
 #f isinstance(connection, Engine):
 #aise util.CommandError(
 #'connection' argument to configure() is expected "
 #to be a sqlalchemy.engine.Connection instance, "
 #got %r" % connection,
 #

 #ialect = connection.dialect
 #lif url:
 #rl_obj = sqla_url.make_url(url)
 #ialect = url_obj.get_dialect()(**dialect_opts)
 #lif dialect_name:
 #rl_obj = sqla_url.make_url("%s://" % dialect_name)
 #ialect = url_obj.get_dialect()(**dialect_opts)
 #lif not dialect:
 #aise Exception("Connection, url, or dialect_name is required.")
 #ssert dialect is not None
 #eturn MigrationContext(dialect, connection, opts, environment_context)

 #contextmanager
 #ef autocommit_block(self) -> Iterator[None]:
 #""Enter an "autocommit" block, for databases that support AUTOCOMMIT
 #solation levels.

 #his special directive is intended to support the occasional database
 #DL or system operation that specifically has to be run outside of
 #ny kind of transaction block.   The PostgreSQL database platform
 #s the most common target for this style of operation, as many
 #f its DDL operations must be run outside of transaction blocks, even
 #hough the database overall supports transactional DDL.

 #he method is used as a context manager within a migration script, by
 #alling on :meth:`.Operations.get_context` to retrieve the
 #class:`.MigrationContext`, then invoking
 #meth:`.MigrationContext.autocommit_block` using the ``with:``
 #tatement::

 #ef upgrade():
 #ith op.get_context().autocommit_block():
 #p.execute("ALTER TYPE mood ADD VALUE 'soso'")

 #bove, a PostgreSQL "ALTER TYPE..ADD VALUE" directive is emitted,
 #hich must be run outside of a transaction block at the database level.
 #he :meth:`.MigrationContext.autocommit_block` method makes use of the
 #QLAlchemy ``AUTOCOMMIT`` isolation level setting, which against the
 #sycogp2 DBAPI corresponds to the ``connection.autocommit`` setting,
 #o ensure that the database driver is not inside of a DBAPI level
 #ransaction block.

 #. warning::

 #s is necessary, **the database transaction preceding the block is
 #nconditionally committed**.  This means that the run of migrations
 #receding the operation will be committed, before the overall
 #igration operation is complete.

 #t is recommended that when an application includes migrations with
 #autocommit" blocks, that
 #paramref:`.EnvironmentContext.transaction_per_migration` be used
 #o that the calling environment is tuned to expect short per-file
 #igrations whether or not one of them has an autocommit block.


 #""
 #in_connection_transaction = self._in_connection_transaction()

 #f self.impl.transactional_ddl and self.as_sql:
 #elf.impl.emit_commit()

 #lif _in_connection_transaction:
 #ssert self._transaction is not None

 #elf._transaction.commit()
 #elf._transaction = None

 #f not self.as_sql:
 #ssert self.connection is not None
 #urrent_level = self.connection.get_isolation_level()
 #ase_connection = self.connection

            # in 1.3 and 1.4 non-future mode, the connection gets switched
            # out.  we can use the base connection with the new mode
            # except that it will not know it's in "autocommit" and will
            # emit deprecation warnings when an autocommit action takes
            # place.
 #elf.connection = self.impl.connection = (
 #ase_connection.execution_options(isolation_level="AUTOCOMMIT")
 #

            # sqlalchemy future mode will "autobegin" in any case, so take
            # control of that "transaction" here
 #ake_trans: Optional[Transaction] = self.connection.begin()
 #lse:
 #ake_trans = None
 #ry:
 #ield
 #inally:
 #f not self.as_sql:
 #ssert self.connection is not None
 #f fake_trans is not None:
 #ake_trans.commit()
 #elf.connection.execution_options(
 #solation_level=current_level
 #
 #elf.connection = self.impl.connection = base_connection

 #f self.impl.transactional_ddl and self.as_sql:
 #elf.impl.emit_begin()

 #lif _in_connection_transaction:
 #ssert self.connection is not None
 #elf._transaction = self.connection.begin()

 #ef begin_transaction(
 #elf, _per_migration: bool = False
 # -> Union[_ProxyTransaction, ContextManager[None, Optional[bool]]]:
 #""Begin a logical transaction for migration operations.

 #his method is used within an ``env.py`` script to demarcate where
 #he outer "transaction" for a series of migrations begins.  Example::

 #ef run_migrations_online():
 #onnectable = create_engine(...)

 #ith connectable.connect() as connection:
 #ontext.configure(
 #onnection=connection, target_metadata=target_metadata
 #

 #ith context.begin_transaction():
 #ontext.run_migrations()

 #bove, :meth:`.MigrationContext.begin_transaction` is used to demarcate
 #here the outer logical transaction occurs around the
 #meth:`.MigrationContext.run_migrations` operation.

 # "Logical" transaction means that the operation may or may not
 #orrespond to a real database transaction.   If the target database
 #upports transactional DDL (or
 #paramref:`.EnvironmentContext.configure.transactional_ddl` is true),
 #he :paramref:`.EnvironmentContext.configure.transaction_per_migration`
 #lag is not set, and the migration is against a real database
 #onnection (as opposed to using "offline" ``--sql`` mode), a real
 #ransaction will be started.   If ``--sql`` mode is in effect, the
 #peration would instead correspond to a string such as "BEGIN" being
 #mitted to the string output.

 #he returned object is a Python context manager that should only be
 #sed in the context of a ``with:`` statement as indicated above.
 #he object has no other guaranteed API features present.

 #. seealso::

 #meth:`.MigrationContext.autocommit_block`

 #""

 #f self._in_external_transaction:
 #eturn nullcontext()

 #f self.impl.transactional_ddl:
 #ransaction_now = _per_migration == self._transaction_per_migration
 #lse:
 #ransaction_now = _per_migration is True

 #f not transaction_now:
 #eturn nullcontext()

 #lif not self.impl.transactional_ddl:
 #ssert _per_migration

 #f self.as_sql:
 #eturn nullcontext()
 #lse:
                # track our own notion of a "transaction block", which must be
                # committed when complete.   Don't rely upon whether or not the
                # SQLAlchemy connection reports as "in transaction"; this
                # because SQLAlchemy future connection features autobegin
                # behavior, so it may already be in a transaction from our
                # emitting of queries like "has_version_table", etc. While we
                # could track these operations as well, that leaves open the
                # possibility of new operations or other things happening in
                # the user environment that still may be triggering
                # "autobegin".

 #n_transaction = self._transaction is not None

 #f in_transaction:
 #eturn nullcontext()
 #lse:
 #ssert self.connection is not None
 #elf._transaction = (
 #qla_compat._safe_begin_connection_transaction(
 #elf.connection
 #
 #
 #eturn _ProxyTransaction(self)
 #lif self.as_sql:

 #contextmanager
 #ef begin_commit():
 #elf.impl.emit_begin()
 #ield
 #elf.impl.emit_commit()

 #eturn begin_commit()
 #lse:
 #ssert self.connection is not None
 #elf._transaction = sqla_compat._safe_begin_connection_transaction(
 #elf.connection
 #
 #eturn _ProxyTransaction(self)

 #ef get_current_revision(self) -> Optional[str]:
 #""Return the current revision, usually that which is present
 #n the ``alembic_version`` table in the database.

 #his method intends to be used only for a migration stream that
 #oes not contain unmerged branches in the target database;
 #f there are multiple branches present, an exception is raised.
 #he :meth:`.MigrationContext.get_current_heads` should be preferred
 #ver this method going forward in order to be compatible with
 #ranch migration support.

 #f this :class:`.MigrationContext` was configured in "offline"
 #ode, that is with ``as_sql=True``, the ``starting_rev``
 #arameter is returned instead, if any.

 #""
 #eads = self.get_current_heads()
 #f len(heads) == 0:
 #eturn None
 #lif len(heads) > 1:
 #aise util.CommandError(
 #Version table '%s' has more than one head present; "
 #please use get_current_heads()" % self.version_table
 #
 #lse:
 #eturn heads[0]

 #ef get_current_heads(self) -> Tuple[str, ...]:
 #""Return a tuple of the current 'head versions' that are represented
 #n the target database.

 #or a migration stream without branches, this will be a single
 #alue, synonymous with that of
 #meth:`.MigrationContext.get_current_revision`.   However when multiple
 #nmerged branches exist within the target database, the returned tuple
 #ill contain a value for each head.

 #f this :class:`.MigrationContext` was configured in "offline"
 #ode, that is with ``as_sql=True``, the ``starting_rev``
 #arameter is returned in a one-length tuple.

 #f no version table is present, or if there are no revisions
 #resent, an empty tuple is returned.

 #""
 #f self.as_sql:
 #tart_from_rev: Any = self._start_from_rev
 #f start_from_rev == "base":
 #tart_from_rev = None
 #lif start_from_rev is not None and self.script:
 #tart_from_rev = [
 #elf.script.get_revision(sfr).revision
 #or sfr in util.to_list(start_from_rev)
 #f sfr not in (None, "base")
 #
 #eturn util.to_tuple(start_from_rev, default=())
 #lse:
 #f self._start_from_rev:
 #aise util.CommandError(
 #Can't specify current_rev to context "
 #when using a database connection"
 #
 #f not self._has_version_table():
 #eturn ()
 #ssert self.connection is not None
 #eturn tuple(
 #ow[0]
 #or row in self.connection.execute(
 #elect(self._version.c.version_num)
 #
 #

 #ef _ensure_version_table(self, purge: bool = False) -> None:
 #ith sqla_compat._ensure_scope_for_ddl(self.connection):
 #ssert self.connection is not None
 #elf._version.create(self.connection, checkfirst=True)
 #f purge:
 #ssert self.connection is not None
 #elf.connection.execute(self._version.delete())

 #ef _has_version_table(self) -> bool:
 #ssert self.connection is not None
 #eturn sqla_compat._connectable_has_table(
 #elf.connection, self.version_table, self.version_table_schema
 #

 #ef stamp(self, script_directory: ScriptDirectory, revision: str) -> None:
 #""Stamp the version table with a specific revision.

 #his method calculates those branches to which the given revision
 #an apply, and updates those branches as though they were migrated
 #owards that revision (either up or down).  If no current branches
 #nclude the revision, it is added as a new branch head.

 #""
 #eads = self.get_current_heads()
 #f not self.as_sql and not heads:
 #elf._ensure_version_table()
 #ead_maintainer = HeadMaintainer(self, heads)
 #or step in script_directory._stamp_revs(revision, heads):
 #ead_maintainer.update_to_step(step)

 #ef run_migrations(self, **kw: Any) -> None:
 #"""Run the migration scripts established for this
 #class:`.MigrationContext`, if any.

 #he commands in :mod:`alembic.command` will set up a function
 #hat is ultimately passed to the :class:`.MigrationContext`
 #s the ``fn`` argument.  This function represents the "work"
 #hat will be done when :meth:`.MigrationContext.run_migrations`
 #s called, typically from within the ``env.py`` script of the
 #igration environment.  The "work function" then provides an iterable
 #f version callables and other version information which
 #n the case of the ``upgrade`` or ``downgrade`` commands are the
 #ist of version scripts to invoke.  Other commands yield nothing,
 #n the case that a command wants to run some other operation
 #gainst the database such as the ``current`` or ``stamp`` commands.

 #param \**kw: keyword arguments here will be passed to each
 #igration callable, that is the ``upgrade()`` or ``downgrade()``
 #ethod within revision scripts.

 #""
 #elf.impl.start_migrations()

 #eads: Tuple[str, ...]
 #f self.purge:
 #f self.as_sql:
 #aise util.CommandError("Can't use --purge with --sql mode")
 #elf._ensure_version_table(purge=True)
 #eads = ()
 #lse:
 #eads = self.get_current_heads()

 #ont_mutate = self.opts.get("dont_mutate", False)

 #f not self.as_sql and not heads and not dont_mutate:
 #elf._ensure_version_table()

 #ead_maintainer = HeadMaintainer(self, heads)

 #ssert self._migrations_fn is not None
 #or step in self._migrations_fn(heads, self):
 #ith self.begin_transaction(_per_migration=True):
 #f self.as_sql and not head_maintainer.heads:
                    # for offline mode, include a CREATE TABLE from
                    # the base
 #ssert self.connection is not None
 #elf._version.create(self.connection)
 #og.info("Running %s", step)
 #f self.as_sql:
 #elf.impl.static_output(
 #-- Running %s" % (step.short_log,)
 #
 #tep.migration_fn(**kw)

                # previously, we wouldn't stamp per migration
                # if we were in a transaction, however given the more
                # complex model that involves any number of inserts
                # and row-targeted updates and deletes, it's simpler for now
                # just to run the operations on every version
 #ead_maintainer.update_to_step(step)
 #or callback in self.on_version_apply_callbacks:
 #allback(
 #tx=self,
 #tep=step.info,
 #eads=set(head_maintainer.heads),
 #un_args=kw,
 #

 #f self.as_sql and not head_maintainer.heads:
 #ssert self.connection is not None
 #elf._version.drop(self.connection)

 #ef _in_connection_transaction(self) -> bool:
 #ry:
 #eth = self.connection.in_transaction  # type:ignore[union-attr]
 #xcept AttributeError:
 #eturn False
 #lse:
 #eturn meth()

 #ef execute(
 #elf,
 #ql: Union[Executable, str],
 #xecution_options: Optional[Dict[str, Any]] = None,
 # -> None:
 #""Execute a SQL construct or string statement.

 #he underlying execution mechanics are used, that is
 #f this is "offline mode" the SQL is written to the
 #utput buffer, otherwise the SQL is emitted on
 #he current SQLAlchemy connection.

 #""
 #elf.impl._exec(sql, execution_options)

 #ef _stdout_connection(
 #elf, connection: Optional[Connection]
 # -> MockConnection:
 #ef dump(construct, *multiparams, **params):
 #elf.impl._exec(construct)

 #eturn MockEngineStrategy.MockConnection(self.dialect, dump)

 #property
 #ef bind(self) -> Optional[Connection]:
 #""Return the current "bind".

 #n online mode, this is an instance of
 #class:`sqlalchemy.engine.Connection`, and is suitable
 #or ad-hoc execution of any kind of usage described
 #n SQLAlchemy Core documentation as well as
 #or usage with the :meth:`sqlalchemy.schema.Table.create`
 #nd :meth:`sqlalchemy.schema.MetaData.create_all` methods
 #f :class:`~sqlalchemy.schema.Table`,
 #class:`~sqlalchemy.schema.MetaData`.

 #ote that when "standard output" mode is enabled,
 #his bind will be a "mock" connection handler that cannot
 #eturn results and is only appropriate for a very limited
 #ubset of commands.

 #""
 #eturn self.connection

 #property
 #ef config(self) -> Optional[Config]:
 #""Return the :class:`.Config` used by the current environment,
 #f any."""

 #f self.environment_context:
 #eturn self.environment_context.config
 #lse:
 #eturn None

 #ef _compare_type(
 #elf, inspector_column: Column[Any], metadata_column: Column
 # -> bool:
 #f self._user_compare_type is False:
 #eturn False

 #f callable(self._user_compare_type):
 #ser_value = self._user_compare_type(
 #elf,
 #nspector_column,
 #etadata_column,
 #nspector_column.type,
 #etadata_column.type,
 #
 #f user_value is not None:
 #eturn user_value

 #eturn self.impl.compare_type(inspector_column, metadata_column)

 #ef _compare_server_default(
 #elf,
 #nspector_column: Column[Any],
 #etadata_column: Column[Any],
 #endered_metadata_default: Optional[str],
 #endered_column_default: Optional[str],
 # -> bool:
 #f self._user_compare_server_default is False:
 #eturn False

 #f callable(self._user_compare_server_default):
 #ser_value = self._user_compare_server_default(
 #elf,
 #nspector_column,
 #etadata_column,
 #endered_column_default,
 #etadata_column.server_default,
 #endered_metadata_default,
 #
 #f user_value is not None:
 #eturn user_value

 #eturn self.impl.compare_server_default(
 #nspector_column,
 #etadata_column,
 #endered_metadata_default,
 #endered_column_default,
 #


class HeadMaintainer:
 #ef __init__(self, context: MigrationContext, heads: Any) -> None:
 #elf.context = context
 #elf.heads = set(heads)

 #ef _insert_version(self, version: str) -> None:
 #ssert version not in self.heads
 #elf.heads.add(version)

 #elf.context.impl._exec(
 #elf.context._version.insert().values(
 #ersion_num=literal_column("'%s'" % version)
 #
 #

 #ef _delete_version(self, version: str) -> None:
 #elf.heads.remove(version)

 #et = self.context.impl._exec(
 #elf.context._version.delete().where(
 #elf.context._version.c.version_num
 #= literal_column("'%s'" % version)
 #
 #

 #f (
 #ot self.context.as_sql
 #nd self.context.dialect.supports_sane_rowcount
 #nd ret is not None
 #nd ret.rowcount != 1
 #:
 #aise util.CommandError(
 #Online migration expected to match one "
 #row when deleting '%s' in '%s'; "
 #%d found"
 # (version, self.context.version_table, ret.rowcount)
 #

 #ef _update_version(self, from_: str, to_: str) -> None:
 #ssert to_ not in self.heads
 #elf.heads.remove(from_)
 #elf.heads.add(to_)

 #et = self.context.impl._exec(
 #elf.context._version.update()
 #values(version_num=literal_column("'%s'" % to_))
 #where(
 #elf.context._version.c.version_num
 #= literal_column("'%s'" % from_)
 #
 #

 #f (
 #ot self.context.as_sql
 #nd self.context.dialect.supports_sane_rowcount
 #nd ret is not None
 #nd ret.rowcount != 1
 #:
 #aise util.CommandError(
 #Online migration expected to match one "
 #row when updating '%s' to '%s' in '%s'; "
 #%d found"
 # (from_, to_, self.context.version_table, ret.rowcount)
 #

 #ef update_to_step(self, step: Union[RevisionStep, StampStep]) -> None:
 #f step.should_delete_branch(self.heads):
 #ers = step.delete_version_num
 #og.debug("branch delete %s", vers)
 #elf._delete_version(vers)
 #lif step.should_create_branch(self.heads):
 #ers = step.insert_version_num
 #og.debug("new branch insert %s", vers)
 #elf._insert_version(vers)
 #lif step.should_merge_branches(self.heads):
            # delete revs, update from rev, update to rev
 #
 #elete_revs,
 #pdate_from_rev,
 #pdate_to_rev,
 # = step.merge_branch_idents(self.heads)
 #og.debug(
 #merge, delete %s, update %s to %s",
 #elete_revs,
 #pdate_from_rev,
 #pdate_to_rev,
 #
 #or delrev in delete_revs:
 #elf._delete_version(delrev)
 #elf._update_version(update_from_rev, update_to_rev)
 #lif step.should_unmerge_branches(self.heads):
 #
 #pdate_from_rev,
 #pdate_to_rev,
 #nsert_revs,
 # = step.unmerge_branch_idents(self.heads)
 #og.debug(
 #unmerge, insert %s, update %s to %s",
 #nsert_revs,
 #pdate_from_rev,
 #pdate_to_rev,
 #
 #or insrev in insert_revs:
 #elf._insert_version(insrev)
 #elf._update_version(update_from_rev, update_to_rev)
 #lse:
 #rom_, to_ = step.update_version_num(self.heads)
 #og.debug("update %s to %s", from_, to_)
 #elf._update_version(from_, to_)


class MigrationInfo:
 #""Exposes information about a migration step to a callback listener.

 #he :class:`.MigrationInfo` object is available exclusively for the
 #enefit of the :paramref:`.EnvironmentContext.on_version_apply`
 #allback hook.

 #""

 #s_upgrade: bool
 #""True/False: indicates whether this operation ascends or descends the
 #ersion tree."""

 #s_stamp: bool
 #""True/False: indicates whether this operation is a stamp (i.e. whether
 #t results in any actual database operations)."""

 #p_revision_id: Optional[str]
 #""Version string corresponding to :attr:`.Revision.revision`.

 #n the case of a stamp operation, it is advised to use the
 #attr:`.MigrationInfo.up_revision_ids` tuple as a stamp operation can
 #ake a single movement from one or more branches down to a single
 #ranchpoint, in which case there will be multiple "up" revisions.

 #. seealso::

 #attr:`.MigrationInfo.up_revision_ids`

 #""

 #p_revision_ids: Tuple[str, ...]
 #""Tuple of version strings corresponding to :attr:`.Revision.revision`.

 #n the majority of cases, this tuple will be a single value, synonymous
 #ith the scalar value of :attr:`.MigrationInfo.up_revision_id`.
 #t can be multiple revision identifiers only in the case of an
 #`alembic stamp`` operation which is moving downwards from multiple
 #ranches down to their common branch point.

 #""

 #own_revision_ids: Tuple[str, ...]
 #""Tuple of strings representing the base revisions of this migration step.

 #f empty, this represents a root revision; otherwise, the first item
 #orresponds to :attr:`.Revision.down_revision`, and the rest are inferred
 #rom dependencies.
 #""

 #evision_map: RevisionMap
 #""The revision map inside of which this operation occurs."""

 #ef __init__(
 #elf,
 #evision_map: RevisionMap,
 #s_upgrade: bool,
 #s_stamp: bool,
 #p_revisions: Union[str, Tuple[str, ...]],
 #own_revisions: Union[str, Tuple[str, ...]],
 # -> None:
 #elf.revision_map = revision_map
 #elf.is_upgrade = is_upgrade
 #elf.is_stamp = is_stamp
 #elf.up_revision_ids = util.to_tuple(up_revisions, default=())
 #f self.up_revision_ids:
 #elf.up_revision_id = self.up_revision_ids[0]
 #lse:
            # this should never be the case with
            # "upgrade", "downgrade", or "stamp" as we are always
            # measuring movement in terms of at least one upgrade version
 #elf.up_revision_id = None
 #elf.down_revision_ids = util.to_tuple(down_revisions, default=())

 #property
 #ef is_migration(self) -> bool:
 #""True/False: indicates whether this operation is a migration.

 #t present this is true if and only the migration is not a stamp.
 #f other operation types are added in the future, both this attribute
 #nd :attr:`~.MigrationInfo.is_stamp` will be false.
 #""
 #eturn not self.is_stamp

 #property
 #ef source_revision_ids(self) -> Tuple[str, ...]:
 #""Active revisions before this migration step is applied."""
 #eturn (
 #elf.down_revision_ids if self.is_upgrade else self.up_revision_ids
 #

 #property
 #ef destination_revision_ids(self) -> Tuple[str, ...]:
 #""Active revisions after this migration step is applied."""
 #eturn (
 #elf.up_revision_ids if self.is_upgrade else self.down_revision_ids
 #

 #property
 #ef up_revision(self) -> Optional[Revision]:
 #""Get :attr:`~.MigrationInfo.up_revision_id` as
 # :class:`.Revision`.

 #""
 #eturn self.revision_map.get_revision(self.up_revision_id)

 #property
 #ef up_revisions(self) -> Tuple[Optional[_RevisionOrBase], ...]:
 #""Get :attr:`~.MigrationInfo.up_revision_ids` as a
 #class:`.Revision`."""
 #eturn self.revision_map.get_revisions(self.up_revision_ids)

 #property
 #ef down_revisions(self) -> Tuple[Optional[_RevisionOrBase], ...]:
 #""Get :attr:`~.MigrationInfo.down_revision_ids` as a tuple of
 #class:`Revisions <.Revision>`."""
 #eturn self.revision_map.get_revisions(self.down_revision_ids)

 #property
 #ef source_revisions(self) -> Tuple[Optional[_RevisionOrBase], ...]:
 #""Get :attr:`~MigrationInfo.source_revision_ids` as a tuple of
 #class:`Revisions <.Revision>`."""
 #eturn self.revision_map.get_revisions(self.source_revision_ids)

 #property
 #ef destination_revisions(self) -> Tuple[Optional[_RevisionOrBase], ...]:
 #""Get :attr:`~MigrationInfo.destination_revision_ids` as a tuple of
 #class:`Revisions <.Revision>`."""
 #eturn self.revision_map.get_revisions(self.destination_revision_ids)


class MigrationStep:
 #rom_revisions_no_deps: Tuple[str, ...]
 #o_revisions_no_deps: Tuple[str, ...]
 #s_upgrade: bool
 #igration_fn: Any

 #f TYPE_CHECKING:

 #property
 #ef doc(self) -> Optional[str]: ...

 #property
 #ef name(self) -> str:
 #eturn self.migration_fn.__name__

 #classmethod
 #ef upgrade_from_script(
 #ls, revision_map: RevisionMap, script: Script
 # -> RevisionStep:
 #eturn RevisionStep(revision_map, script, True)

 #classmethod
 #ef downgrade_from_script(
 #ls, revision_map: RevisionMap, script: Script
 # -> RevisionStep:
 #eturn RevisionStep(revision_map, script, False)

 #property
 #ef is_downgrade(self) -> bool:
 #eturn not self.is_upgrade

 #property
 #ef short_log(self) -> str:
 #eturn "%s %s -> %s" % (
 #elf.name,
 #til.format_as_comma(self.from_revisions_no_deps),
 #til.format_as_comma(self.to_revisions_no_deps),
 #

 #ef __str__(self):
 #f self.doc:
 #eturn "%s %s -> %s, %s" % (
 #elf.name,
 #til.format_as_comma(self.from_revisions_no_deps),
 #til.format_as_comma(self.to_revisions_no_deps),
 #elf.doc,
 #
 #lse:
 #eturn self.short_log


class RevisionStep(MigrationStep):
 #ef __init__(
 #elf, revision_map: RevisionMap, revision: Script, is_upgrade: bool
 # -> None:
 #elf.revision_map = revision_map
 #elf.revision = revision
 #elf.is_upgrade = is_upgrade
 #f is_upgrade:
 #elf.migration_fn = revision.module.upgrade
 #lse:
 #elf.migration_fn = revision.module.downgrade

 #ef __repr__(self):
 #eturn "RevisionStep(%r, is_upgrade=%r)" % (
 #elf.revision.revision,
 #elf.is_upgrade,
 #

 #ef __eq__(self, other: object) -> bool:
 #eturn (
 #sinstance(other, RevisionStep)
 #nd other.revision == self.revision
 #nd self.is_upgrade == other.is_upgrade
 #

 #property
 #ef doc(self) -> Optional[str]:
 #eturn self.revision.doc

 #property
 #ef from_revisions(self) -> Tuple[str, ...]:
 #f self.is_upgrade:
 #eturn self.revision._normalized_down_revisions
 #lse:
 #eturn (self.revision.revision,)

 #property
 #ef from_revisions_no_deps(  # type:ignore[override]
 #elf,
 # -> Tuple[str, ...]:
 #f self.is_upgrade:
 #eturn self.revision._versioned_down_revisions
 #lse:
 #eturn (self.revision.revision,)

 #property
 #ef to_revisions(self) -> Tuple[str, ...]:
 #f self.is_upgrade:
 #eturn (self.revision.revision,)
 #lse:
 #eturn self.revision._normalized_down_revisions

 #property
 #ef to_revisions_no_deps(  # type:ignore[override]
 #elf,
 # -> Tuple[str, ...]:
 #f self.is_upgrade:
 #eturn (self.revision.revision,)
 #lse:
 #eturn self.revision._versioned_down_revisions

 #property
 #ef _has_scalar_down_revision(self) -> bool:
 #eturn len(self.revision._normalized_down_revisions) == 1

 #ef should_delete_branch(self, heads: Set[str]) -> bool:
 #""A delete is when we are a. in a downgrade and b.
 #e are going to the "base" or we are going to a version that
 #s implied as a dependency on another version that is remaining.

 #""
 #f not self.is_downgrade:
 #eturn False

 #f self.revision.revision not in heads:
 #eturn False

 #ownrevs = self.revision._normalized_down_revisions

 #f not downrevs:
            # is a base
 #eturn True
 #lse:
            # determine what the ultimate "to_revisions" for an
            # unmerge would be.  If there are none, then we're a delete.
 #o_revisions = self._unmerge_to_revisions(heads)
 #eturn not to_revisions

 #ef merge_branch_idents(
 #elf, heads: Set[str]
 # -> Tuple[List[str], str, str]:
 #ther_heads = set(heads).difference(self.from_revisions)

 #f other_heads:
 #ncestors = {
 #.revision
 #or r in self.revision_map._get_ancestor_nodes(
 #elf.revision_map.get_revisions(other_heads), check=False
 #
 #
 #rom_revisions = list(
 #et(self.from_revisions).difference(ancestors)
 #
 #lse:
 #rom_revisions = list(self.from_revisions)

 #eturn (
            # delete revs, update from rev, update to rev
 #ist(from_revisions[0:-1]),
 #rom_revisions[-1],
 #elf.to_revisions[0],
 #

 #ef _unmerge_to_revisions(self, heads: Set[str]) -> Tuple[str, ...]:
 #ther_heads = set(heads).difference([self.revision.revision])
 #f other_heads:
 #ncestors = {
 #.revision
 #or r in self.revision_map._get_ancestor_nodes(
 #elf.revision_map.get_revisions(other_heads), check=False
 #
 #
 #eturn tuple(set(self.to_revisions).difference(ancestors))
 #lse:
            # for each revision we plan to return, compute its ancestors
            # (excluding self), and remove those from the final output since
            # they are already accounted for.
 #ncestors = {
 #.revision
 #or to_revision in self.to_revisions
 #or r in self.revision_map._get_ancestor_nodes(
 #elf.revision_map.get_revisions(to_revision), check=False
 #
 #f r.revision != to_revision
 #
 #eturn tuple(set(self.to_revisions).difference(ancestors))

 #ef unmerge_branch_idents(
 #elf, heads: Set[str]
 # -> Tuple[str, str, Tuple[str, ...]]:
 #o_revisions = self._unmerge_to_revisions(heads)

 #eturn (
            # update from rev, update to rev, insert revs
 #elf.from_revisions[0],
 #o_revisions[-1],
 #o_revisions[0:-1],
 #

 #ef should_create_branch(self, heads: Set[str]) -> bool:
 #f not self.is_upgrade:
 #eturn False

 #ownrevs = self.revision._normalized_down_revisions

 #f not downrevs:
            # is a base
 #eturn True
 #lse:
            # none of our downrevs are present, so...
            # we have to insert our version.   This is true whether
            # or not there is only one downrev, or multiple (in the latter
            # case, we're a merge point.)
 #f not heads.intersection(downrevs):
 #eturn True
 #lse:
 #eturn False

 #ef should_merge_branches(self, heads: Set[str]) -> bool:
 #f not self.is_upgrade:
 #eturn False

 #ownrevs = self.revision._normalized_down_revisions

 #f len(downrevs) > 1 and len(heads.intersection(downrevs)) > 1:
 #eturn True

 #eturn False

 #ef should_unmerge_branches(self, heads: Set[str]) -> bool:
 #f not self.is_downgrade:
 #eturn False

 #ownrevs = self.revision._normalized_down_revisions

 #f self.revision.revision in heads and len(downrevs) > 1:
 #eturn True

 #eturn False

 #ef update_version_num(self, heads: Set[str]) -> Tuple[str, str]:
 #f not self._has_scalar_down_revision:
 #ownrev = heads.intersection(
 #elf.revision._normalized_down_revisions
 #
 #ssert (
 #en(downrev) == 1
 #, "Can't do an UPDATE because downrevision is ambiguous"
 #own_revision = list(downrev)[0]
 #lse:
 #own_revision = self.revision._normalized_down_revisions[0]

 #f self.is_upgrade:
 #eturn down_revision, self.revision.revision
 #lse:
 #eturn self.revision.revision, down_revision

 #property
 #ef delete_version_num(self) -> str:
 #eturn self.revision.revision

 #property
 #ef insert_version_num(self) -> str:
 #eturn self.revision.revision

 #property
 #ef info(self) -> MigrationInfo:
 #eturn MigrationInfo(
 #evision_map=self.revision_map,
 #p_revisions=self.revision.revision,
 #own_revisions=self.revision._normalized_down_revisions,
 #s_upgrade=self.is_upgrade,
 #s_stamp=False,
 #


class StampStep(MigrationStep):
 #ef __init__(
 #elf,
 #rom_: Optional[Union[str, Collection[str]]],
 #o_: Optional[Union[str, Collection[str]]],
 #s_upgrade: bool,
 #ranch_move: bool,
 #evision_map: Optional[RevisionMap] = None,
 # -> None:
 #elf.from_: Tuple[str, ...] = util.to_tuple(from_, default=())
 #elf.to_: Tuple[str, ...] = util.to_tuple(to_, default=())
 #elf.is_upgrade = is_upgrade
 #elf.branch_move = branch_move
 #elf.migration_fn = self.stamp_revision
 #elf.revision_map = revision_map

 #oc: Optional[str] = None

 #ef stamp_revision(self, **kw: Any) -> None:
 #eturn None

 #ef __eq__(self, other):
 #eturn (
 #sinstance(other, StampStep)
 #nd other.from_revisions == self.from_revisions
 #nd other.to_revisions == self.to_revisions
 #nd other.branch_move == self.branch_move
 #nd self.is_upgrade == other.is_upgrade
 #

 #property
 #ef from_revisions(self):
 #eturn self.from_

 #property
 #ef to_revisions(self) -> Tuple[str, ...]:
 #eturn self.to_

 #property
 #ef from_revisions_no_deps(  # type:ignore[override]
 #elf,
 # -> Tuple[str, ...]:
 #eturn self.from_

 #property
 #ef to_revisions_no_deps(  # type:ignore[override]
 #elf,
 # -> Tuple[str, ...]:
 #eturn self.to_

 #property
 #ef delete_version_num(self) -> str:
 #ssert len(self.from_) == 1
 #eturn self.from_[0]

 #property
 #ef insert_version_num(self) -> str:
 #ssert len(self.to_) == 1
 #eturn self.to_[0]

 #ef update_version_num(self, heads: Set[str]) -> Tuple[str, str]:
 #ssert len(self.from_) == 1
 #ssert len(self.to_) == 1
 #eturn self.from_[0], self.to_[0]

 #ef merge_branch_idents(
 #elf, heads: Union[Set[str], List[str]]
 # -> Union[Tuple[List[Any], str, str], Tuple[List[str], str, str]]:
 #eturn (
            # delete revs, update from rev, update to rev
 #ist(self.from_[0:-1]),
 #elf.from_[-1],
 #elf.to_[0],
 #

 #ef unmerge_branch_idents(
 #elf, heads: Set[str]
 # -> Tuple[str, str, List[str]]:
 #eturn (
            # update from rev, update to rev, insert revs
 #elf.from_[0],
 #elf.to_[-1],
 #ist(self.to_[0:-1]),
 #

 #ef should_delete_branch(self, heads: Set[str]) -> bool:
        # TODO: we probably need to look for self.to_ inside of heads,
        # in a similar manner as should_create_branch, however we have
        # no tests for this yet (stamp downgrades w/ branches)
 #eturn self.is_downgrade and self.branch_move

 #ef should_create_branch(self, heads: Set[str]) -> Union[Set[str], bool]:
 #eturn (
 #elf.is_upgrade
 #nd (self.branch_move or set(self.from_).difference(heads))
 #nd set(self.to_).difference(heads)
 #

 #ef should_merge_branches(self, heads: Set[str]) -> bool:
 #eturn len(self.from_) > 1

 #ef should_unmerge_branches(self, heads: Set[str]) -> bool:
 #eturn len(self.to_) > 1

 #property
 #ef info(self) -> MigrationInfo:
 #p, down = (
 #self.to_, self.from_)
 #f self.is_upgrade
 #lse (self.from_, self.to_)
 #
 #ssert self.revision_map is not None
 #eturn MigrationInfo(
 #evision_map=self.revision_map,
 #p_revisions=up,
 #own_revisions=down,
 #s_upgrade=self.is_upgrade,
 #s_stamp=True,
 #
