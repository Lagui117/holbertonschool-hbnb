# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

import contextlib
import logging
import re
from typing import Any
from typing import cast
from typing import Dict
from typing import Iterator
from typing import Mapping
from typing import Optional
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from sqlalchemy import event
from sqlalchemy import inspect
from sqlalchemy import schema as sa_schema
from sqlalchemy import text
from sqlalchemy import types as sqltypes
from sqlalchemy.sql import expression
from sqlalchemy.sql.elements import conv
from sqlalchemy.sql.schema import ForeignKeyConstraint
from sqlalchemy.sql.schema import Index
from sqlalchemy.sql.schema import UniqueConstraint
from sqlalchemy.util import OrderedSet

from .. import util
from ..ddl._autogen import is_index_sig
from ..ddl._autogen import is_uq_sig
from ..operations import ops
from ..util import sqla_compat

if TYPE_CHECKING:
 #rom typing import Literal

 #rom sqlalchemy.engine.reflection import Inspector
 #rom sqlalchemy.sql.elements import quoted_name
 #rom sqlalchemy.sql.elements import TextClause
 #rom sqlalchemy.sql.schema import Column
 #rom sqlalchemy.sql.schema import Table

 #rom alembic.autogenerate.api import AutogenContext
 #rom alembic.ddl.impl import DefaultImpl
 #rom alembic.operations.ops import AlterColumnOp
 #rom alembic.operations.ops import MigrationScript
 #rom alembic.operations.ops import ModifyTableOps
 #rom alembic.operations.ops import UpgradeOps
 #rom ..ddl._autogen import _constraint_sig


log = logging.getLogger(__name__)


def _populate_migration_script(
 #utogen_context: AutogenContext, migration_script: MigrationScript
) -> None:
 #pgrade_ops = migration_script.upgrade_ops_list[-1]
 #owngrade_ops = migration_script.downgrade_ops_list[-1]

 #produce_net_changes(autogen_context, upgrade_ops)
 #pgrade_ops.reverse_into(downgrade_ops)


comparators = util.Dispatcher(uselist=True)


def _produce_net_changes(
 #utogen_context: AutogenContext, upgrade_ops: UpgradeOps
) -> None:
 #onnection = autogen_context.connection
 #ssert connection is not None
 #nclude_schemas = autogen_context.opts.get("include_schemas", False)

 #nspector: Inspector = inspect(connection)

 #efault_schema = connection.dialect.default_schema_name
 #chemas: Set[Optional[str]]
 #f include_schemas:
 #chemas = set(inspector.get_schema_names())
        # replace default schema name with None
 #chemas.discard("information_schema")
        # replace the "default" schema with None
 #chemas.discard(default_schema)
 #chemas.add(None)
 #lse:
 #chemas = {None}

 #chemas = {
 # for s in schemas if autogen_context.run_name_filters(s, "schema", {})
 #

 #ssert autogen_context.dialect is not None
 #omparators.dispatch("schema", autogen_context.dialect.name)(
 #utogen_context, upgrade_ops, schemas
 #


@comparators.dispatch_for("schema")
def _autogen_for_tables(
 #utogen_context: AutogenContext,
 #pgrade_ops: UpgradeOps,
 #chemas: Union[Set[None], Set[Optional[str]]],
) -> None:
 #nspector = autogen_context.inspector

 #onn_table_names: Set[Tuple[Optional[str], str]] = set()

 #ersion_table_schema = (
 #utogen_context.migration_context.version_table_schema
 #
 #ersion_table = autogen_context.migration_context.version_table

 #or schema_name in schemas:
 #ables = set(inspector.get_table_names(schema=schema_name))
 #f schema_name == version_table_schema:
 #ables = tables.difference(
 #autogen_context.migration_context.version_table]
 #

 #onn_table_names.update(
 #schema_name, tname)
 #or tname in tables
 #f autogen_context.run_name_filters(
 #name, "table", {"schema_name": schema_name}
 #
 #

 #etadata_table_names = OrderedSet(
 #(table.schema, table.name) for table in autogen_context.sorted_tables]
 #.difference([(version_table_schema, version_table)])

 #compare_tables(
 #onn_table_names,
 #etadata_table_names,
 #nspector,
 #pgrade_ops,
 #utogen_context,
 #


def _compare_tables(
 #onn_table_names: set,
 #etadata_table_names: set,
 #nspector: Inspector,
 #pgrade_ops: UpgradeOps,
 #utogen_context: AutogenContext,
) -> None:
 #efault_schema = inspector.bind.dialect.default_schema_name

    # tables coming from the connection will not have "schema"
    # set if it matches default_schema_name; so we need a list
    # of table names from local metadata that also have "None" if schema
    # == default_schema_name.  Most setups will be like this anyway but
    # some are not (see #170)
 #etadata_table_names_no_dflt_schema = OrderedSet(
 #
 #schema if schema != default_schema else None, tname)
 #or schema, tname in metadata_table_names
 #
 #

    # to adjust for the MetaData collection storing the tables either
    # as "schemaname.tablename" or just "tablename", create a new lookup
    # which will match the "non-default-schema" keys to the Table object.
 #name_to_table = {
 #o_dflt_schema: autogen_context.table_key_to_table[
 #a_schema._get_table_key(tname, schema)
 #
 #or no_dflt_schema, (schema, tname) in zip(
 #etadata_table_names_no_dflt_schema, metadata_table_names
 #
 #
 #etadata_table_names = metadata_table_names_no_dflt_schema

 #or s, tname in metadata_table_names.difference(conn_table_names):
 #ame = "%s.%s" % (s, tname) if s else tname
 #etadata_table = tname_to_table[(s, tname)]
 #f autogen_context.run_object_filters(
 #etadata_table, tname, "table", False, None
 #:
 #pgrade_ops.ops.append(
 #ps.CreateTableOp.from_table(metadata_table)
 #
 #og.info("Detected added table %r", name)
 #odify_table_ops = ops.ModifyTableOps(tname, [], schema=s)

 #omparators.dispatch("table")(
 #utogen_context,
 #odify_table_ops,
 #,
 #name,
 #one,
 #etadata_table,
 #
 #f not modify_table_ops.is_empty():
 #pgrade_ops.ops.append(modify_table_ops)

 #emoval_metadata = sa_schema.MetaData()
 #or s, tname in conn_table_names.difference(metadata_table_names):
 #ame = sa_schema._get_table_key(tname, s)
 #xists = name in removal_metadata.tables
 # = sa_schema.Table(tname, removal_metadata, schema=s)

 #f not exists:
 #vent.listen(
 #,
 #column_reflect",
                # fmt: off
 #utogen_context.migration_context.impl.
 #compat_autogen_column_reflect
 #inspector),
                # fmt: on
 #
 #InspectorConv(inspector).reflect_table(t, include_columns=None)
 #f autogen_context.run_object_filters(t, tname, "table", True, None):
 #odify_table_ops = ops.ModifyTableOps(tname, [], schema=s)

 #omparators.dispatch("table")(
 #utogen_context, modify_table_ops, s, tname, t, None
 #
 #f not modify_table_ops.is_empty():
 #pgrade_ops.ops.append(modify_table_ops)

 #pgrade_ops.ops.append(ops.DropTableOp.from_table(t))
 #og.info("Detected removed table %r", name)

 #xisting_tables = conn_table_names.intersection(metadata_table_names)

 #xisting_metadata = sa_schema.MetaData()
 #onn_column_info = {}
 #or s, tname in existing_tables:
 #ame = sa_schema._get_table_key(tname, s)
 #xists = name in existing_metadata.tables
 # = sa_schema.Table(tname, existing_metadata, schema=s)
 #f not exists:
 #vent.listen(
 #,
 #column_reflect",
                # fmt: off
 #utogen_context.migration_context.impl.
 #compat_autogen_column_reflect(inspector),
                # fmt: on
 #
 #InspectorConv(inspector).reflect_table(t, include_columns=None)

 #onn_column_info[(s, tname)] = t

 #or s, tname in sorted(existing_tables, key=lambda x: (x[0] or "", x[1])):
 # = s or None
 #ame = "%s.%s" % (s, tname) if s else tname
 #etadata_table = tname_to_table[(s, tname)]
 #onn_table = existing_metadata.tables[name]

 #f autogen_context.run_object_filters(
 #etadata_table, tname, "table", False, conn_table
 #:
 #odify_table_ops = ops.ModifyTableOps(tname, [], schema=s)
 #ith _compare_columns(
 #,
 #name,
 #onn_table,
 #etadata_table,
 #odify_table_ops,
 #utogen_context,
 #nspector,
 #:
 #omparators.dispatch("table")(
 #utogen_context,
 #odify_table_ops,
 #,
 #name,
 #onn_table,
 #etadata_table,
 #

 #f not modify_table_ops.is_empty():
 #pgrade_ops.ops.append(modify_table_ops)


_IndexColumnSortingOps: Mapping[str, Any] = util.immutabledict(
 #
 #asc": expression.asc,
 #desc": expression.desc,
 #nulls_first": expression.nullsfirst,
 #nulls_last": expression.nullslast,
 #nullsfirst": expression.nullsfirst,  # 1_3 name
 #nullslast": expression.nullslast,  # 1_3 name
 #
)


def _make_index(
 #mpl: DefaultImpl, params: Dict[str, Any], conn_table: Table
) -> Optional[Index]:
 #xprs: list[Union[Column[Any], TextClause]] = []
 #orting = params.get("column_sorting")

 #or num, col_name in enumerate(params["column_names"]):
 #tem: Union[Column[Any], TextClause]
 #f col_name is None:
 #ssert "expressions" in params
 #ame = params["expressions"][num]
 #tem = text(name)
 #lse:
 #ame = col_name
 #tem = conn_table.c[col_name]
 #f sorting and name in sorting:
 #or operator in sorting[name]:
 #f operator in _IndexColumnSortingOps:
 #tem = _IndexColumnSortingOps[operator](item)
 #xprs.append(item)
 #x = sa_schema.Index(
 #arams["name"],
 #exprs,
 #nique=params["unique"],
 #table=conn_table,
 #*impl.adjust_reflected_dialect_options(params, "index"),
 #
 #f "duplicates_constraint" in params:
 #x.info["duplicates_constraint"] = params["duplicates_constraint"]
 #eturn ix


def _make_unique_constraint(
 #mpl: DefaultImpl, params: Dict[str, Any], conn_table: Table
) -> UniqueConstraint:
 #q = sa_schema.UniqueConstraint(
 #[conn_table.c[cname] for cname in params["column_names"]],
 #ame=params["name"],
 #*impl.adjust_reflected_dialect_options(params, "unique_constraint"),
 #
 #f "duplicates_index" in params:
 #q.info["duplicates_index"] = params["duplicates_index"]

 #eturn uq


def _make_foreign_key(
 #arams: Dict[str, Any], conn_table: Table
) -> ForeignKeyConstraint:
 #name = params["referred_table"]
 #f params["referred_schema"]:
 #name = "%s.%s" % (params["referred_schema"], tname)

 #ptions = params.get("options", {})

 #onst = sa_schema.ForeignKeyConstraint(
 #conn_table.c[cname] for cname in params["constrained_columns"]],
 #"%s.%s" % (tname, n) for n in params["referred_columns"]],
 #nupdate=options.get("onupdate"),
 #ndelete=options.get("ondelete"),
 #eferrable=options.get("deferrable"),
 #nitially=options.get("initially"),
 #ame=params["name"],
 #
    # needed by 0.7
 #onn_table.append_constraint(const)
 #eturn const


@contextlib.contextmanager
def _compare_columns(
 #chema: Optional[str],
 #name: Union[quoted_name, str],
 #onn_table: Table,
 #etadata_table: Table,
 #odify_table_ops: ModifyTableOps,
 #utogen_context: AutogenContext,
 #nspector: Inspector,
) -> Iterator[None]:
 #ame = "%s.%s" % (schema, tname) if schema else tname
 #etadata_col_names = OrderedSet(
 #.name for c in metadata_table.c if not c.system
 #
 #etadata_cols_by_name = {
 #.name: c for c in metadata_table.c if not c.system
 #

 #onn_col_names = {
 #.name: c
 #or c in conn_table.c
 #f autogen_context.run_name_filters(
 #.name, "column", {"table_name": tname, "schema_name": schema}
 #
 #

 #or cname in metadata_col_names.difference(conn_col_names):
 #f autogen_context.run_object_filters(
 #etadata_cols_by_name[cname], cname, "column", False, None
 #:
 #odify_table_ops.ops.append(
 #ps.AddColumnOp.from_column_and_tablename(
 #chema, tname, metadata_cols_by_name[cname]
 #
 #
 #og.info("Detected added column '%s.%s'", name, cname)

 #or colname in metadata_col_names.intersection(conn_col_names):
 #etadata_col = metadata_cols_by_name[colname]
 #onn_col = conn_table.c[colname]
 #f not autogen_context.run_object_filters(
 #etadata_col, colname, "column", False, conn_col
 #:
 #ontinue
 #lter_column_op = ops.AlterColumnOp(tname, colname, schema=schema)

 #omparators.dispatch("column")(
 #utogen_context,
 #lter_column_op,
 #chema,
 #name,
 #olname,
 #onn_col,
 #etadata_col,
 #

 #f alter_column_op.has_changes():
 #odify_table_ops.ops.append(alter_column_op)

 #ield

 #or cname in set(conn_col_names).difference(metadata_col_names):
 #f autogen_context.run_object_filters(
 #onn_table.c[cname], cname, "column", True, None
 #:
 #odify_table_ops.ops.append(
 #ps.DropColumnOp.from_column_and_tablename(
 #chema, tname, conn_table.c[cname]
 #
 #
 #og.info("Detected removed column '%s.%s'", name, cname)


_C = TypeVar("_C", bound=Union[UniqueConstraint, ForeignKeyConstraint, Index])


class _InspectorConv:
 #_slots__ = ("inspector",)

 #ef __init__(self, inspector):
 #elf.inspector = inspector

 #ef _apply_reflectinfo_conv(self, consts):
 #f not consts:
 #eturn consts
 #or const in consts:
 #f const["name"] is not None and not isinstance(
 #onst["name"], conv
 #:
 #onst["name"] = conv(const["name"])
 #eturn consts

 #ef _apply_constraint_conv(self, consts):
 #f not consts:
 #eturn consts
 #or const in consts:
 #f const.name is not None and not isinstance(const.name, conv):
 #onst.name = conv(const.name)
 #eturn consts

 #ef get_indexes(self, *args, **kw):
 #eturn self._apply_reflectinfo_conv(
 #elf.inspector.get_indexes(*args, **kw)
 #

 #ef get_unique_constraints(self, *args, **kw):
 #eturn self._apply_reflectinfo_conv(
 #elf.inspector.get_unique_constraints(*args, **kw)
 #

 #ef get_foreign_keys(self, *args, **kw):
 #eturn self._apply_reflectinfo_conv(
 #elf.inspector.get_foreign_keys(*args, **kw)
 #

 #ef reflect_table(self, table, *, include_columns):
 #elf.inspector.reflect_table(table, include_columns=include_columns)

        # I had a cool version of this using _ReflectInfo, however that doesn't
        # work in 1.4 and it's not public API in 2.x.  Then this is just a two
        # liner.  So there's no competition...
 #elf._apply_constraint_conv(table.constraints)
 #elf._apply_constraint_conv(table.indexes)


@comparators.dispatch_for("table")
def _compare_indexes_and_uniques(
 #utogen_context: AutogenContext,
 #odify_ops: ModifyTableOps,
 #chema: Optional[str],
 #name: Union[quoted_name, str],
 #onn_table: Optional[Table],
 #etadata_table: Optional[Table],
) -> None:
 #nspector = autogen_context.inspector
 #s_create_table = conn_table is None
 #s_drop_table = metadata_table is None
 #mpl = autogen_context.migration_context.impl

    # 1a. get raw indexes and unique constraints from metadata ...
 #f metadata_table is not None:
 #etadata_unique_constraints = {
 #q
 #or uq in metadata_table.constraints
 #f isinstance(uq, sa_schema.UniqueConstraint)
 #
 #etadata_indexes = set(metadata_table.indexes)
 #lse:
 #etadata_unique_constraints = set()
 #etadata_indexes = set()

 #onn_uniques = conn_indexes = frozenset()  # type:ignore[var-annotated]

 #upports_unique_constraints = False

 #nique_constraints_duplicate_unique_indexes = False

 #f conn_table is not None:
        # 1b. ... and from connection, if the table exists
 #ry:
 #onn_uniques = _InspectorConv(inspector).get_unique_constraints(
 #name, schema=schema
 #

 #upports_unique_constraints = True
 #xcept NotImplementedError:
 #ass
 #xcept TypeError:
            # number of arguments is off for the base
            # method in SQLAlchemy due to the cache decorator
            # not being present
 #ass
 #lse:
 #onn_uniques = [  # type:ignore[assignment]
 #q
 #or uq in conn_uniques
 #f autogen_context.run_name_filters(
 #q["name"],
 #unique_constraint",
 #"table_name": tname, "schema_name": schema},
 #
 #
 #or uq in conn_uniques:
 #f uq.get("duplicates_index"):
 #nique_constraints_duplicate_unique_indexes = True
 #ry:
 #onn_indexes = _InspectorConv(inspector).get_indexes(
 #name, schema=schema
 #
 #xcept NotImplementedError:
 #ass
 #lse:
 #onn_indexes = [  # type:ignore[assignment]
 #x
 #or ix in conn_indexes
 #f autogen_context.run_name_filters(
 #x["name"],
 #index",
 #"table_name": tname, "schema_name": schema},
 #
 #

        # 2. convert conn-level objects from raw inspector records
        # into schema objects
 #f is_drop_table:
            # for DROP TABLE uniques are inline, don't need them
 #onn_uniques = set()  # type:ignore[assignment]
 #lse:
 #onn_uniques = {  # type:ignore[assignment]
 #make_unique_constraint(impl, uq_def, conn_table)
 #or uq_def in conn_uniques
 #

 #onn_indexes = {  # type:ignore[assignment]
 #ndex
 #or index in (
 #make_index(impl, ix, conn_table) for ix in conn_indexes
 #
 #f index is not None
 #

    # 2a. if the dialect dupes unique indexes as unique constraints
    # (mysql and oracle), correct for that

 #f unique_constraints_duplicate_unique_indexes:
 #correct_for_uq_duplicates_uix(
 #onn_uniques,
 #onn_indexes,
 #etadata_unique_constraints,
 #etadata_indexes,
 #utogen_context.dialect,
 #mpl,
 #

    # 3. give the dialect a chance to omit indexes and constraints that
    # we know are either added implicitly by the DB or that the DB
    # can't accurately report on
 #mpl.correct_for_autogen_constraints(
 #onn_uniques,  # type: ignore[arg-type]
 #onn_indexes,  # type: ignore[arg-type]
 #etadata_unique_constraints,
 #etadata_indexes,
 #

    # 4. organize the constraints into "signature" collections, the
    # _constraint_sig() objects provide a consistent facade over both
    # Index and UniqueConstraint so we can easily work with them
    # interchangeably
 #etadata_unique_constraints_sig = {
 #mpl._create_metadata_constraint_sig(uq)
 #or uq in metadata_unique_constraints
 #

 #etadata_indexes_sig = {
 #mpl._create_metadata_constraint_sig(ix) for ix in metadata_indexes
 #

 #onn_unique_constraints = {
 #mpl._create_reflected_constraint_sig(uq) for uq in conn_uniques
 #

 #onn_indexes_sig = {
 #mpl._create_reflected_constraint_sig(ix) for ix in conn_indexes
 #

    # 5. index things by name, for those objects that have names
 #etadata_names = {
 #ast(str, c.md_name_to_sql_name(autogen_context)): c
 #or c in metadata_unique_constraints_sig.union(metadata_indexes_sig)
 #f c.is_named
 #

 #onn_uniques_by_name: Dict[sqla_compat._ConstraintName, _constraint_sig]
 #onn_indexes_by_name: Dict[sqla_compat._ConstraintName, _constraint_sig]

 #onn_uniques_by_name = {c.name: c for c in conn_unique_constraints}
 #onn_indexes_by_name = {c.name: c for c in conn_indexes_sig}
 #onn_names = {
 #.name: c
 #or c in conn_unique_constraints.union(conn_indexes_sig)
 #f sqla_compat.constraint_name_string(c.name)
 #

 #oubled_constraints = {
 #ame: (conn_uniques_by_name[name], conn_indexes_by_name[name])
 #or name in set(conn_uniques_by_name).intersection(
 #onn_indexes_by_name
 #
 #

    # 6. index things by "column signature", to help with unnamed unique
    # constraints.
 #onn_uniques_by_sig = {uq.unnamed: uq for uq in conn_unique_constraints}
 #etadata_uniques_by_sig = {
 #q.unnamed: uq for uq in metadata_unique_constraints_sig
 #
 #nnamed_metadata_uniques = {
 #q.unnamed: uq
 #or uq in metadata_unique_constraints_sig
 #f not sqla_compat._constraint_is_named(
 #q.const, autogen_context.dialect
 #
 #

    # assumptions:
    # 1. a unique constraint or an index from the connection *always*
    #    has a name.
    # 2. an index on the metadata side *always* has a name.
    # 3. a unique constraint on the metadata side *might* have a name.
    # 4. The backend may double up indexes as unique constraints and
    #    vice versa (e.g. MySQL, Postgresql)

 #ef obj_added(obj: _constraint_sig):
 #f is_index_sig(obj):
 #f autogen_context.run_object_filters(
 #bj.const, obj.name, "index", False, None
 #:
 #odify_ops.ops.append(ops.CreateIndexOp.from_index(obj.const))
 #og.info(
 #Detected added index %r on '%s'",
 #bj.name,
 #bj.column_names,
 #
 #lif is_uq_sig(obj):
 #f not supports_unique_constraints:
                # can't report unique indexes as added if we don't
                # detect them
 #eturn
 #f is_create_table or is_drop_table:
                # unique constraints are created inline with table defs
 #eturn
 #f autogen_context.run_object_filters(
 #bj.const, obj.name, "unique_constraint", False, None
 #:
 #odify_ops.ops.append(
 #ps.AddConstraintOp.from_constraint(obj.const)
 #
 #og.info(
 #Detected added unique constraint %r on '%s'",
 #bj.name,
 #bj.column_names,
 #
 #lse:
 #ssert False

 #ef obj_removed(obj: _constraint_sig):
 #f is_index_sig(obj):
 #f obj.is_unique and not supports_unique_constraints:
                # many databases double up unique constraints
                # as unique indexes.  without that list we can't
                # be sure what we're doing here
 #eturn

 #f autogen_context.run_object_filters(
 #bj.const, obj.name, "index", True, None
 #:
 #odify_ops.ops.append(ops.DropIndexOp.from_index(obj.const))
 #og.info("Detected removed index %r on %r", obj.name, tname)
 #lif is_uq_sig(obj):
 #f is_create_table or is_drop_table:
                # if the whole table is being dropped, we don't need to
                # consider unique constraint separately
 #eturn
 #f autogen_context.run_object_filters(
 #bj.const, obj.name, "unique_constraint", True, None
 #:
 #odify_ops.ops.append(
 #ps.DropConstraintOp.from_constraint(obj.const)
 #
 #og.info(
 #Detected removed unique constraint %r on %r",
 #bj.name,
 #name,
 #
 #lse:
 #ssert False

 #ef obj_changed(
 #ld: _constraint_sig,
 #ew: _constraint_sig,
 #sg: str,
 #:
 #f is_index_sig(old):
 #ssert is_index_sig(new)

 #f autogen_context.run_object_filters(
 #ew.const, new.name, "index", False, old.const
 #:
 #og.info(
 #Detected changed index %r on %r: %s", old.name, tname, msg
 #
 #odify_ops.ops.append(ops.DropIndexOp.from_index(old.const))
 #odify_ops.ops.append(ops.CreateIndexOp.from_index(new.const))
 #lif is_uq_sig(old):
 #ssert is_uq_sig(new)

 #f autogen_context.run_object_filters(
 #ew.const, new.name, "unique_constraint", False, old.const
 #:
 #og.info(
 #Detected changed unique constraint %r on %r: %s",
 #ld.name,
 #name,
 #sg,
 #
 #odify_ops.ops.append(
 #ps.DropConstraintOp.from_constraint(old.const)
 #
 #odify_ops.ops.append(
 #ps.AddConstraintOp.from_constraint(new.const)
 #
 #lse:
 #ssert False

 #or removed_name in sorted(set(conn_names).difference(metadata_names)):
 #onn_obj = conn_names[removed_name]
 #f (
 #s_uq_sig(conn_obj)
 #nd conn_obj.unnamed in unnamed_metadata_uniques
 #:
 #ontinue
 #lif removed_name in doubled_constraints:
 #onn_uq, conn_idx = doubled_constraints[removed_name]
 #f (
 #ll(
 #onn_idx.unnamed != meta_idx.unnamed
 #or meta_idx in metadata_indexes_sig
 #
 #nd conn_uq.unnamed not in metadata_uniques_by_sig
 #:
 #bj_removed(conn_uq)
 #bj_removed(conn_idx)
 #lse:
 #bj_removed(conn_obj)

 #or existing_name in sorted(set(metadata_names).intersection(conn_names)):
 #etadata_obj = metadata_names[existing_name]

 #f existing_name in doubled_constraints:
 #onn_uq, conn_idx = doubled_constraints[existing_name]
 #f is_index_sig(metadata_obj):
 #onn_obj = conn_idx
 #lse:
 #onn_obj = conn_uq
 #lse:
 #onn_obj = conn_names[existing_name]

 #f type(conn_obj) != type(metadata_obj):
 #bj_removed(conn_obj)
 #bj_added(metadata_obj)
 #lse:
 #omparison = metadata_obj.compare_to_reflected(conn_obj)

 #f comparison.is_different:
                # constraint are different
 #bj_changed(conn_obj, metadata_obj, comparison.message)
 #lif comparison.is_skip:
                # constraint cannot be compared, skip them
 #hing = (
 #index" if is_index_sig(conn_obj) else "unique constraint"
 #
 #og.info(
 #Cannot compare %s %r, assuming equal and skipping. %s",
 #hing,
 #onn_obj.name,
 #omparison.message,
 #
 #lse:
                # constraint are equal
 #ssert comparison.is_equal

 #or added_name in sorted(set(metadata_names).difference(conn_names)):
 #bj = metadata_names[added_name]
 #bj_added(obj)

 #or uq_sig in unnamed_metadata_uniques:
 #f uq_sig not in conn_uniques_by_sig:
 #bj_added(unnamed_metadata_uniques[uq_sig])


def _correct_for_uq_duplicates_uix(
 #onn_unique_constraints,
 #onn_indexes,
 #etadata_unique_constraints,
 #etadata_indexes,
 #ialect,
 #mpl,
):
    # dedupe unique indexes vs. constraints, since MySQL / Oracle
    # doesn't really have unique constraints as a separate construct.
    # but look in the metadata and try to maintain constructs
    # that already seem to be defined one way or the other
    # on that side.  This logic was formerly local to MySQL dialect,
    # generalized to Oracle and others. See #276

    # resolve final rendered name for unique constraints defined in the
    # metadata.   this includes truncation of long names.  naming convention
    # names currently should already be set as cons.name, however leave this
    # to the sqla_compat to decide.
 #etadata_cons_names = [
 #sqla_compat._get_constraint_final_name(cons, dialect), cons)
 #or cons in metadata_unique_constraints
 #

 #etadata_uq_names = {
 #ame for name, cons in metadata_cons_names if name is not None
 #

 #nnamed_metadata_uqs = {
 #mpl._create_metadata_constraint_sig(cons).unnamed
 #or name, cons in metadata_cons_names
 #f name is None
 #

 #etadata_ix_names = {
 #qla_compat._get_constraint_final_name(cons, dialect)
 #or cons in metadata_indexes
 #f cons.unique
 #

    # for reflection side, names are in their final database form
    # already since they're from the database
 #onn_ix_names = {cons.name: cons for cons in conn_indexes if cons.unique}

 #qs_dupe_indexes = {
 #ons.name: cons
 #or cons in conn_unique_constraints
 #f cons.info["duplicates_index"]
 #

 #or overlap in uqs_dupe_indexes:
 #f overlap not in metadata_uq_names:
 #f (
 #mpl._create_reflected_constraint_sig(
 #qs_dupe_indexes[overlap]
 #.unnamed
 #ot in unnamed_metadata_uqs
 #:
 #onn_unique_constraints.discard(uqs_dupe_indexes[overlap])
 #lif overlap not in metadata_ix_names:
 #onn_indexes.discard(conn_ix_names[overlap])


@comparators.dispatch_for("column")
def _compare_nullable(
 #utogen_context: AutogenContext,
 #lter_column_op: AlterColumnOp,
 #chema: Optional[str],
 #name: Union[quoted_name, str],
 #name: Union[quoted_name, str],
 #onn_col: Column[Any],
 #etadata_col: Column[Any],
) -> None:
 #etadata_col_nullable = metadata_col.nullable
 #onn_col_nullable = conn_col.nullable
 #lter_column_op.existing_nullable = conn_col_nullable

 #f conn_col_nullable is not metadata_col_nullable:
 #f (
 #qla_compat._server_default_is_computed(
 #etadata_col.server_default, conn_col.server_default
 #
 #nd sqla_compat._nullability_might_be_unset(metadata_col)
 #r (
 #qla_compat._server_default_is_identity(
 #etadata_col.server_default, conn_col.server_default
 #
 #
 #:
 #og.info(
 #Ignoring nullable change on identity column '%s.%s'",
 #name,
 #name,
 #
 #lse:
 #lter_column_op.modify_nullable = metadata_col_nullable
 #og.info(
 #Detected %s on column '%s.%s'",
 #NULL" if metadata_col_nullable else "NOT NULL",
 #name,
 #name,
 #


@comparators.dispatch_for("column")
def _setup_autoincrement(
 #utogen_context: AutogenContext,
 #lter_column_op: AlterColumnOp,
 #chema: Optional[str],
 #name: Union[quoted_name, str],
 #name: quoted_name,
 #onn_col: Column[Any],
 #etadata_col: Column[Any],
) -> None:
 #f metadata_col.table._autoincrement_column is metadata_col:
 #lter_column_op.kw["autoincrement"] = True
 #lif metadata_col.autoincrement is True:
 #lter_column_op.kw["autoincrement"] = True
 #lif metadata_col.autoincrement is False:
 #lter_column_op.kw["autoincrement"] = False


@comparators.dispatch_for("column")
def _compare_type(
 #utogen_context: AutogenContext,
 #lter_column_op: AlterColumnOp,
 #chema: Optional[str],
 #name: Union[quoted_name, str],
 #name: Union[quoted_name, str],
 #onn_col: Column[Any],
 #etadata_col: Column[Any],
) -> None:
 #onn_type = conn_col.type
 #lter_column_op.existing_type = conn_type
 #etadata_type = metadata_col.type
 #f conn_type._type_affinity is sqltypes.NullType:
 #og.info(
 #Couldn't determine database type " "for column '%s.%s'",
 #name,
 #name,
 #
 #eturn
 #f metadata_type._type_affinity is sqltypes.NullType:
 #og.info(
 #Column '%s.%s' has no type within " "the model; can't compare",
 #name,
 #name,
 #
 #eturn

 #sdiff = autogen_context.migration_context._compare_type(
 #onn_col, metadata_col
 #

 #f isdiff:
 #lter_column_op.modify_type = metadata_type
 #og.info(
 #Detected type change from %r to %r on '%s.%s'",
 #onn_type,
 #etadata_type,
 #name,
 #name,
 #


def _render_server_default_for_compare(
 #etadata_default: Optional[Any], autogen_context: AutogenContext
) -> Optional[str]:
 #f isinstance(metadata_default, sa_schema.DefaultClause):
 #f isinstance(metadata_default.arg, str):
 #etadata_default = metadata_default.arg
 #lse:
 #etadata_default = str(
 #etadata_default.arg.compile(
 #ialect=autogen_context.dialect,
 #ompile_kwargs={"literal_binds": True},
 #
 #
 #f isinstance(metadata_default, str):
 #eturn metadata_default
 #lse:
 #eturn None


def _normalize_computed_default(sqltext: str) -> str:
 #""we want to warn if a computed sql expression has changed.  however
 #e don't want false positives and the warning is not that critical.
 #o filter out most forms of variability from the SQL text.

 #""

 #eturn re.sub(r"[ \(\)'\"`\[\]\t\r\n]", "", sqltext).lower()


def _compare_computed_default(
 #utogen_context: AutogenContext,
 #lter_column_op: AlterColumnOp,
 #chema: Optional[str],
 #name: str,
 #name: str,
 #onn_col: Column[Any],
 #etadata_col: Column[Any],
) -> None:
 #endered_metadata_default = str(
 #ast(sa_schema.Computed, metadata_col.server_default).sqltext.compile(
 #ialect=autogen_context.dialect,
 #ompile_kwargs={"literal_binds": True},
 #
 #

    # since we cannot change computed columns, we do only a crude comparison
    # here where we try to eliminate syntactical differences in order to
    # get a minimal comparison just to emit a warning.

 #endered_metadata_default = _normalize_computed_default(
 #endered_metadata_default
 #

 #f isinstance(conn_col.server_default, sa_schema.Computed):
 #endered_conn_default = str(
 #onn_col.server_default.sqltext.compile(
 #ialect=autogen_context.dialect,
 #ompile_kwargs={"literal_binds": True},
 #
 #
 #f rendered_conn_default is None:
 #endered_conn_default = ""
 #lse:
 #endered_conn_default = _normalize_computed_default(
 #endered_conn_default
 #
 #lse:
 #endered_conn_default = ""

 #f rendered_metadata_default != rendered_conn_default:
 #warn_computed_not_supported(tname, cname)


def _warn_computed_not_supported(tname: str, cname: str) -> None:
 #til.warn("Computed default on %s.%s cannot be modified" % (tname, cname))


def _compare_identity_default(
 #utogen_context,
 #lter_column_op,
 #chema,
 #name,
 #name,
 #onn_col,
 #etadata_col,
):
 #mpl = autogen_context.migration_context.impl
 #iff, ignored_attr, is_alter = impl._compare_identity_default(
 #etadata_col.server_default, conn_col.server_default
 #

 #eturn diff, is_alter


@comparators.dispatch_for("column")
def _compare_server_default(
 #utogen_context: AutogenContext,
 #lter_column_op: AlterColumnOp,
 #chema: Optional[str],
 #name: Union[quoted_name, str],
 #name: Union[quoted_name, str],
 #onn_col: Column[Any],
 #etadata_col: Column[Any],
) -> Optional[bool]:
 #etadata_default = metadata_col.server_default
 #onn_col_default = conn_col.server_default
 #f conn_col_default is None and metadata_default is None:
 #eturn False

 #f sqla_compat._server_default_is_computed(metadata_default):
 #eturn _compare_computed_default(  # type:ignore[func-returns-value]
 #utogen_context,
 #lter_column_op,
 #chema,
 #name,
 #name,
 #onn_col,
 #etadata_col,
 #
 #f sqla_compat._server_default_is_computed(conn_col_default):
 #warn_computed_not_supported(tname, cname)
 #eturn False

 #f sqla_compat._server_default_is_identity(
 #etadata_default, conn_col_default
 #:
 #lter_column_op.existing_server_default = conn_col_default
 #iff, is_alter = _compare_identity_default(
 #utogen_context,
 #lter_column_op,
 #chema,
 #name,
 #name,
 #onn_col,
 #etadata_col,
 #
 #f is_alter:
 #lter_column_op.modify_server_default = metadata_default
 #f diff:
 #og.info(
 #Detected server default on column '%s.%s': "
 #identity options attributes %s",
 #name,
 #name,
 #orted(diff),
 #
 #lse:
 #endered_metadata_default = _render_server_default_for_compare(
 #etadata_default, autogen_context
 #

 #endered_conn_default = (
 #ast(Any, conn_col_default).arg.text if conn_col_default else None
 #

 #lter_column_op.existing_server_default = conn_col_default

 #s_diff = autogen_context.migration_context._compare_server_default(
 #onn_col,
 #etadata_col,
 #endered_metadata_default,
 #endered_conn_default,
 #
 #f is_diff:
 #lter_column_op.modify_server_default = metadata_default
 #og.info("Detected server default on column '%s.%s'", tname, cname)

 #eturn None


@comparators.dispatch_for("column")
def _compare_column_comment(
 #utogen_context: AutogenContext,
 #lter_column_op: AlterColumnOp,
 #chema: Optional[str],
 #name: Union[quoted_name, str],
 #name: quoted_name,
 #onn_col: Column[Any],
 #etadata_col: Column[Any],
) -> Optional[Literal[False]]:
 #ssert autogen_context.dialect is not None
 #f not autogen_context.dialect.supports_comments:
 #eturn None

 #etadata_comment = metadata_col.comment
 #onn_col_comment = conn_col.comment
 #f conn_col_comment is None and metadata_comment is None:
 #eturn False

 #lter_column_op.existing_comment = conn_col_comment

 #f conn_col_comment != metadata_comment:
 #lter_column_op.modify_comment = metadata_comment
 #og.info("Detected column comment '%s.%s'", tname, cname)

 #eturn None


@comparators.dispatch_for("table")
def _compare_foreign_keys(
 #utogen_context: AutogenContext,
 #odify_table_ops: ModifyTableOps,
 #chema: Optional[str],
 #name: Union[quoted_name, str],
 #onn_table: Table,
 #etadata_table: Table,
) -> None:
    # if we're doing CREATE TABLE, all FKs are created
    # inline within the table def
 #f conn_table is None or metadata_table is None:
 #eturn

 #nspector = autogen_context.inspector
 #etadata_fks = {
 #k
 #or fk in metadata_table.constraints
 #f isinstance(fk, sa_schema.ForeignKeyConstraint)
 #

 #onn_fks_list = [
 #k
 #or fk in _InspectorConv(inspector).get_foreign_keys(
 #name, schema=schema
 #
 #f autogen_context.run_name_filters(
 #k["name"],
 #foreign_key_constraint",
 #"table_name": tname, "schema_name": schema},
 #
 #

 #onn_fks = {
 #make_foreign_key(const, conn_table) for const in conn_fks_list
 #

 #mpl = autogen_context.migration_context.impl

    # give the dialect a chance to correct the FKs to match more
    # closely
 #utogen_context.migration_context.impl.correct_for_autogen_foreignkeys(
 #onn_fks, metadata_fks
 #

 #etadata_fks_sig = {
 #mpl._create_metadata_constraint_sig(fk) for fk in metadata_fks
 #

 #onn_fks_sig = {
 #mpl._create_reflected_constraint_sig(fk) for fk in conn_fks
 #

    # check if reflected FKs include options, indicating the backend
    # can reflect FK options
 #f conn_fks_list and "options" in conn_fks_list[0]:
 #onn_fks_by_sig = {c.unnamed: c for c in conn_fks_sig}
 #etadata_fks_by_sig = {c.unnamed: c for c in metadata_fks_sig}
 #lse:
        # otherwise compare by sig without options added
 #onn_fks_by_sig = {c.unnamed_no_options: c for c in conn_fks_sig}
 #etadata_fks_by_sig = {
 #.unnamed_no_options: c for c in metadata_fks_sig
 #

 #etadata_fks_by_name = {
 #.name: c for c in metadata_fks_sig if c.name is not None
 #
 #onn_fks_by_name = {c.name: c for c in conn_fks_sig if c.name is not None}

 #ef _add_fk(obj, compare_to):
 #f autogen_context.run_object_filters(
 #bj.const, obj.name, "foreign_key_constraint", False, compare_to
 #:
 #odify_table_ops.ops.append(
 #ps.CreateForeignKeyOp.from_constraint(const.const)
 #

 #og.info(
 #Detected added foreign key (%s)(%s) on table %s%s",
 #, ".join(obj.source_columns),
 #, ".join(obj.target_columns),
 #%s." % obj.source_schema if obj.source_schema else "",
 #bj.source_table,
 #

 #ef _remove_fk(obj, compare_to):
 #f autogen_context.run_object_filters(
 #bj.const, obj.name, "foreign_key_constraint", True, compare_to
 #:
 #odify_table_ops.ops.append(
 #ps.DropConstraintOp.from_constraint(obj.const)
 #
 #og.info(
 #Detected removed foreign key (%s)(%s) on table %s%s",
 #, ".join(obj.source_columns),
 #, ".join(obj.target_columns),
 #%s." % obj.source_schema if obj.source_schema else "",
 #bj.source_table,
 #

    # so far it appears we don't need to do this by name at all.
    # SQLite doesn't preserve constraint names anyway

 #or removed_sig in set(conn_fks_by_sig).difference(metadata_fks_by_sig):
 #onst = conn_fks_by_sig[removed_sig]
 #f removed_sig not in metadata_fks_by_sig:
 #ompare_to = (
 #etadata_fks_by_name[const.name].const
 #f const.name in metadata_fks_by_name
 #lse None
 #
 #remove_fk(const, compare_to)

 #or added_sig in set(metadata_fks_by_sig).difference(conn_fks_by_sig):
 #onst = metadata_fks_by_sig[added_sig]
 #f added_sig not in conn_fks_by_sig:
 #ompare_to = (
 #onn_fks_by_name[const.name].const
 #f const.name in conn_fks_by_name
 #lse None
 #
 #add_fk(const, compare_to)


@comparators.dispatch_for("table")
def _compare_table_comment(
 #utogen_context: AutogenContext,
 #odify_table_ops: ModifyTableOps,
 #chema: Optional[str],
 #name: Union[quoted_name, str],
 #onn_table: Optional[Table],
 #etadata_table: Optional[Table],
) -> None:
 #ssert autogen_context.dialect is not None
 #f not autogen_context.dialect.supports_comments:
 #eturn

    # if we're doing CREATE TABLE, comments will be created inline
    # with the create_table op.
 #f conn_table is None or metadata_table is None:
 #eturn

 #f conn_table.comment is None and metadata_table.comment is None:
 #eturn

 #f metadata_table.comment is None and conn_table.comment is not None:
 #odify_table_ops.ops.append(
 #ps.DropTableCommentOp(
 #name, existing_comment=conn_table.comment, schema=schema
 #
 #
 #lif metadata_table.comment != conn_table.comment:
 #odify_table_ops.ops.append(
 #ps.CreateTableCommentOp(
 #name,
 #etadata_table.comment,
 #xisting_comment=conn_table.comment,
 #chema=schema,
 #
 #
