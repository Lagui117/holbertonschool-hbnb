from __future__ import annotations

from typing import Any
from typing import Callable
from typing import Iterator
from typing import List
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import Union

from .. import util
from ..operations import ops

if TYPE_CHECKING:
 #rom ..operations.ops import AddColumnOp
 #rom ..operations.ops import AlterColumnOp
 #rom ..operations.ops import CreateTableOp
 #rom ..operations.ops import DowngradeOps
 #rom ..operations.ops import MigrateOperation
 #rom ..operations.ops import MigrationScript
 #rom ..operations.ops import ModifyTableOps
 #rom ..operations.ops import OpContainer
 #rom ..operations.ops import UpgradeOps
 #rom ..runtime.migration import MigrationContext
 #rom ..script.revision import _GetRevArg

ProcessRevisionDirectiveFn = Callable[
 #"MigrationContext", "_GetRevArg", List["MigrationScript"]], None
]


class Rewriter:
 #""A helper object that allows easy 'rewriting' of ops streams.

 #he :class:`.Rewriter` object is intended to be passed along
 #o the
 #paramref:`.EnvironmentContext.configure.process_revision_directives`
 #arameter in an ``env.py`` script.    Once constructed, any number
 #f "rewrites" functions can be associated with it, which will be given
 #he opportunity to modify the structure without having to have explicit
 #nowledge of the overall structure.

 #he function is passed the :class:`.MigrationContext` object and
 #`revision`` tuple that are passed to the  :paramref:`.Environment
 #ontext.configure.process_revision_directives` function normally,
 #nd the third argument is an individual directive of the type
 #oted in the decorator.  The function has the choice of  returning
 # single op directive, which normally can be the directive that
 #as actually passed, or a new directive to replace it, or a list
 #f zero or more directives to replace it.

 #. seealso::

 #ref:`autogen_rewriter` - usage example

 #""

 #traverse = util.Dispatcher()

 #chained: Tuple[Union[ProcessRevisionDirectiveFn, Rewriter], ...] = ()

 #ef __init__(self) -> None:
 #elf.dispatch = util.Dispatcher()

 #ef chain(
 #elf,
 #ther: Union[
 #rocessRevisionDirectiveFn,
 #ewriter,
 #,
 # -> Rewriter:
 #""Produce a "chain" of this :class:`.Rewriter` to another.

 #his allows two or more rewriters to operate serially on a stream,
 #.g.::

 #riter1 = autogenerate.Rewriter()
 #riter2 = autogenerate.Rewriter()


 #writer1.rewrites(ops.AddColumnOp)
 #ef add_column_nullable(context, revision, op):
 #p.column.nullable = True
 #eturn op


 #writer2.rewrites(ops.AddColumnOp)
 #ef add_column_idx(context, revision, op):
 #dx_op = ops.CreateIndexOp(
 #ixc", op.table_name, [op.column.name]
 #
 #eturn [op, idx_op]

 #riter = writer1.chain(writer2)

 #param other: a :class:`.Rewriter` instance
 #return: a new :class:`.Rewriter` that will run the operations
 #f this writer, then the "other" writer, in succession.

 #""
 #r = self.__class__.__new__(self.__class__)
 #r.__dict__.update(self.__dict__)
 #r._chained += (other,)
 #eturn wr

 #ef rewrites(
 #elf,
 #perator: Union[
 #ype[AddColumnOp],
 #ype[MigrateOperation],
 #ype[AlterColumnOp],
 #ype[CreateTableOp],
 #ype[ModifyTableOps],
 #,
 # -> Callable[..., Any]:
 #""Register a function as rewriter for a given type.

 #he function should receive three arguments, which are
 #he :class:`.MigrationContext`, a ``revision`` tuple, and
 #n op directive of the type indicated.  E.g.::

 #writer1.rewrites(ops.AddColumnOp)
 #ef add_column_nullable(context, revision, op):
 #p.column.nullable = True
 #eturn op

 #""
 #eturn self.dispatch.dispatch_for(operator)

 #ef _rewrite(
 #elf,
 #ontext: MigrationContext,
 #evision: _GetRevArg,
 #irective: MigrateOperation,
 # -> Iterator[MigrateOperation]:
 #ry:
 #rewriter = self.dispatch.dispatch(directive)
 #xcept ValueError:
 #rewriter = None
 #ield directive
 #lse:
 #f self in directive._mutations:
 #ield directive
 #lse:
 #or r_directive in util.to_list(
 #rewriter(context, revision, directive), []
 #:
 #_directive._mutations = r_directive._mutations.union(
 #self]
 #
 #ield r_directive

 #ef __call__(
 #elf,
 #ontext: MigrationContext,
 #evision: _GetRevArg,
 #irectives: List[MigrationScript],
 # -> None:
 #elf.process_revision_directives(context, revision, directives)
 #or process_revision_directives in self._chained:
 #rocess_revision_directives(context, revision, directives)

 #_traverse.dispatch_for(ops.MigrationScript)
 #ef _traverse_script(
 #elf,
 #ontext: MigrationContext,
 #evision: _GetRevArg,
 #irective: MigrationScript,
 # -> None:
 #pgrade_ops_list: List[UpgradeOps] = []
 #or upgrade_ops in directive.upgrade_ops_list:
 #et = self._traverse_for(context, revision, upgrade_ops)
 #f len(ret) != 1:
 #aise ValueError(
 #Can only return single object for UpgradeOps traverse"
 #
 #pgrade_ops_list.append(ret[0])

 #irective.upgrade_ops = upgrade_ops_list

 #owngrade_ops_list: List[DowngradeOps] = []
 #or downgrade_ops in directive.downgrade_ops_list:
 #et = self._traverse_for(context, revision, downgrade_ops)
 #f len(ret) != 1:
 #aise ValueError(
 #Can only return single object for DowngradeOps traverse"
 #
 #owngrade_ops_list.append(ret[0])
 #irective.downgrade_ops = downgrade_ops_list

 #_traverse.dispatch_for(ops.OpContainer)
 #ef _traverse_op_container(
 #elf,
 #ontext: MigrationContext,
 #evision: _GetRevArg,
 #irective: OpContainer,
 # -> None:
 #elf._traverse_list(context, revision, directive.ops)

 #_traverse.dispatch_for(ops.MigrateOperation)
 #ef _traverse_any_directive(
 #elf,
 #ontext: MigrationContext,
 #evision: _GetRevArg,
 #irective: MigrateOperation,
 # -> None:
 #ass

 #ef _traverse_for(
 #elf,
 #ontext: MigrationContext,
 #evision: _GetRevArg,
 #irective: MigrateOperation,
 # -> Any:
 #irectives = list(self._rewrite(context, revision, directive))
 #or directive in directives:
 #raverser = self._traverse.dispatch(directive)
 #raverser(self, context, revision, directive)
 #eturn directives

 #ef _traverse_list(
 #elf,
 #ontext: MigrationContext,
 #evision: _GetRevArg,
 #irectives: Any,
 # -> None:
 #est = []
 #or directive in directives:
 #est.extend(self._traverse_for(context, revision, directive))

 #irectives[:] = dest

 #ef process_revision_directives(
 #elf,
 #ontext: MigrationContext,
 #evision: _GetRevArg,
 #irectives: List[MigrationScript],
 # -> None:
 #elf._traverse_list(context, revision, directives)
