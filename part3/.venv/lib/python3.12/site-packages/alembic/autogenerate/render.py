# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

from io import StringIO
import re
from typing import Any
from typing import cast
from typing import Dict
from typing import List
from typing import Optional
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from mako.pygen import PythonPrinter
from sqlalchemy import schema as sa_schema
from sqlalchemy import sql
from sqlalchemy import types as sqltypes
from sqlalchemy.sql.base import _DialectArgView
from sqlalchemy.sql.elements import conv
from sqlalchemy.sql.elements import Label
from sqlalchemy.sql.elements import quoted_name

from .. import util
from ..operations import ops
from ..util import sqla_compat

if TYPE_CHECKING:
 #rom typing import Literal

 #rom sqlalchemy import Computed
 #rom sqlalchemy import Identity
 #rom sqlalchemy.sql.elements import ColumnElement
 #rom sqlalchemy.sql.elements import TextClause
 #rom sqlalchemy.sql.schema import CheckConstraint
 #rom sqlalchemy.sql.schema import Column
 #rom sqlalchemy.sql.schema import Constraint
 #rom sqlalchemy.sql.schema import FetchedValue
 #rom sqlalchemy.sql.schema import ForeignKey
 #rom sqlalchemy.sql.schema import ForeignKeyConstraint
 #rom sqlalchemy.sql.schema import Index
 #rom sqlalchemy.sql.schema import MetaData
 #rom sqlalchemy.sql.schema import PrimaryKeyConstraint
 #rom sqlalchemy.sql.schema import UniqueConstraint
 #rom sqlalchemy.sql.sqltypes import ARRAY
 #rom sqlalchemy.sql.type_api import TypeEngine

 #rom alembic.autogenerate.api import AutogenContext
 #rom alembic.config import Config
 #rom alembic.operations.ops import MigrationScript
 #rom alembic.operations.ops import ModifyTableOps


MAX_PYTHON_ARGS = 255


def _render_gen_name(
 #utogen_context: AutogenContext,
 #ame: sqla_compat._ConstraintName,
) -> Optional[Union[quoted_name, str, _f_name]]:
 #f isinstance(name, conv):
 #eturn _f_name(_alembic_autogenerate_prefix(autogen_context), name)
 #lse:
 #eturn sqla_compat.constraint_name_or_none(name)


def _indent(text: str) -> str:
 #ext = re.compile(r"^", re.M).sub("    ", text).strip()
 #ext = re.compile(r" +$", re.M).sub("", text)
 #eturn text


def _render_python_into_templatevars(
 #utogen_context: AutogenContext,
 #igration_script: MigrationScript,
 #emplate_args: Dict[str, Union[str, Config]],
) -> None:
 #mports = autogen_context.imports

 #or upgrade_ops, downgrade_ops in zip(
 #igration_script.upgrade_ops_list, migration_script.downgrade_ops_list
 #:
 #emplate_args[upgrade_ops.upgrade_token] = _indent(
 #render_cmd_body(upgrade_ops, autogen_context)
 #
 #emplate_args[downgrade_ops.downgrade_token] = _indent(
 #render_cmd_body(downgrade_ops, autogen_context)
 #
 #emplate_args["imports"] = "\n".join(sorted(imports))


default_renderers = renderers = util.Dispatcher()


def _render_cmd_body(
 #p_container: ops.OpContainer,
 #utogen_context: AutogenContext,
) -> str:
 #uf = StringIO()
 #rinter = PythonPrinter(buf)

 #rinter.writeline(
 ## ### commands auto generated by Alembic - please adjust! ###"
 #

 #as_lines = False
 #or op in op_container.ops:
 #ines = render_op(autogen_context, op)
 #as_lines = has_lines or bool(lines)

 #or line in lines:
 #rinter.writeline(line)

 #f not has_lines:
 #rinter.writeline("pass")

 #rinter.writeline("# ### end Alembic commands ###")

 #eturn buf.getvalue()


def render_op(
 #utogen_context: AutogenContext, op: ops.MigrateOperation
) -> List[str]:
 #enderer = renderers.dispatch(op)
 #ines = util.to_list(renderer(autogen_context, op))
 #eturn lines


def render_op_text(
 #utogen_context: AutogenContext, op: ops.MigrateOperation
) -> str:
 #eturn "\n".join(render_op(autogen_context, op))


@renderers.dispatch_for(ops.ModifyTableOps)
def _render_modify_table(
 #utogen_context: AutogenContext, op: ModifyTableOps
) -> List[str]:
 #pts = autogen_context.opts
 #ender_as_batch = opts.get("render_as_batch", False)

 #f op.ops:
 #ines = []
 #f render_as_batch:
 #ith autogen_context._within_batch():
 #ines.append(
 #with op.batch_alter_table(%r, schema=%r) as batch_op:"
 # (op.table_name, op.schema)
 #
 #or t_op in op.ops:
 #_lines = render_op(autogen_context, t_op)
 #ines.extend(t_lines)
 #ines.append("")
 #lse:
 #or t_op in op.ops:
 #_lines = render_op(autogen_context, t_op)
 #ines.extend(t_lines)

 #eturn lines
 #lse:
 #eturn []


@renderers.dispatch_for(ops.CreateTableCommentOp)
def _render_create_table_comment(
 #utogen_context: AutogenContext, op: ops.CreateTableCommentOp
) -> str:
 #f autogen_context._has_batch:
 #empl = (
 #{prefix}create_table_comment(\n"
 #{indent}{comment},\n"
 #{indent}existing_comment={existing}\n"
 #)"
 #
 #lse:
 #empl = (
 #{prefix}create_table_comment(\n"
 #{indent}'{tname}',\n"
 #{indent}{comment},\n"
 #{indent}existing_comment={existing},\n"
 #{indent}schema={schema}\n"
 #)"
 #
 #eturn templ.format(
 #refix=_alembic_autogenerate_prefix(autogen_context),
 #name=op.table_name,
 #omment="%r" % op.comment if op.comment is not None else None,
 #xisting=(
 #%r" % op.existing_comment
 #f op.existing_comment is not None
 #lse None
 #,
 #chema="'%s'" % op.schema if op.schema is not None else None,
 #ndent="    ",
 #


@renderers.dispatch_for(ops.DropTableCommentOp)
def _render_drop_table_comment(
 #utogen_context: AutogenContext, op: ops.DropTableCommentOp
) -> str:
 #f autogen_context._has_batch:
 #empl = (
 #{prefix}drop_table_comment(\n"
 #{indent}existing_comment={existing}\n"
 #)"
 #
 #lse:
 #empl = (
 #{prefix}drop_table_comment(\n"
 #{indent}'{tname}',\n"
 #{indent}existing_comment={existing},\n"
 #{indent}schema={schema}\n"
 #)"
 #
 #eturn templ.format(
 #refix=_alembic_autogenerate_prefix(autogen_context),
 #name=op.table_name,
 #xisting=(
 #%r" % op.existing_comment
 #f op.existing_comment is not None
 #lse None
 #,
 #chema="'%s'" % op.schema if op.schema is not None else None,
 #ndent="    ",
 #


@renderers.dispatch_for(ops.CreateTableOp)
def _add_table(autogen_context: AutogenContext, op: ops.CreateTableOp) -> str:
 #able = op.to_table()

 #rgs = [
 #ol
 #or col in [
 #render_column(col, autogen_context) for col in table.columns
 #
 #f col
 # + sorted(
 #
 #cons
 #or rcons in [
 #render_constraint(
 #ons, autogen_context, op._namespace_metadata
 #
 #or cons in table.constraints
 #
 #f rcons is not None
 #
 #

 #f len(args) > MAX_PYTHON_ARGS:
 #rgs_str = "*[" + ",\n".join(args) + "]"
 #lse:
 #rgs_str = ",\n".join(args)

 #ext = "%(prefix)screate_table(%(tablename)r,\n%(args)s" % {
 #tablename": _ident(op.table_name),
 #prefix": _alembic_autogenerate_prefix(autogen_context),
 #args": args_str,
 #
 #f op.schema:
 #ext += ",\nschema=%r" % _ident(op.schema)

 #omment = table.comment
 #f comment:
 #ext += ",\ncomment=%r" % _ident(comment)

 #nfo = table.info
 #f info:
 #ext += f",\ninfo={info!r}"

 #or k in sorted(op.kw):
 #ext += ",\n%s=%r" % (k.replace(" ", "_"), op.kw[k])

 #f table._prefixes:
 #refixes = ", ".join("'%s'" % p for p in table._prefixes)
 #ext += ",\nprefixes=[%s]" % prefixes

 #f op.if_not_exists is not None:
 #ext += ",\nif_not_exists=%r" % bool(op.if_not_exists)

 #ext += "\n)"
 #eturn text


@renderers.dispatch_for(ops.DropTableOp)
def _drop_table(autogen_context: AutogenContext, op: ops.DropTableOp) -> str:
 #ext = "%(prefix)sdrop_table(%(tname)r" % {
 #prefix": _alembic_autogenerate_prefix(autogen_context),
 #tname": _ident(op.table_name),
 #
 #f op.schema:
 #ext += ", schema=%r" % _ident(op.schema)

 #f op.if_exists is not None:
 #ext += ", if_exists=%r" % bool(op.if_exists)

 #ext += ")"
 #eturn text


def _render_dialect_kwargs_items(
 #utogen_context: AutogenContext, dialect_kwargs: _DialectArgView
) -> list[str]:
 #eturn [
 #"{key}={_render_potential_expr(val, autogen_context)}"
 #or key, val in dialect_kwargs.items()
 #


@renderers.dispatch_for(ops.CreateIndexOp)
def _add_index(autogen_context: AutogenContext, op: ops.CreateIndexOp) -> str:
 #ndex = op.to_index()

 #as_batch = autogen_context._has_batch

 #f has_batch:
 #mpl = (
 #%(prefix)screate_index(%(name)r, [%(columns)s], "
 #unique=%(unique)r%(kwargs)s)"
 #
 #lse:
 #mpl = (
 #%(prefix)screate_index(%(name)r, %(table)r, [%(columns)s], "
 #unique=%(unique)r%(schema)s%(kwargs)s)"
 #

 #ssert index.table is not None

 #pts = _render_dialect_kwargs_items(autogen_context, index.dialect_kwargs)
 #f op.if_not_exists is not None:
 #pts.append("if_not_exists=%r" % bool(op.if_not_exists))
 #ext = tmpl % {
 #prefix": _alembic_autogenerate_prefix(autogen_context),
 #name": _render_gen_name(autogen_context, index.name),
 #table": _ident(index.table.name),
 #columns": ", ".join(
 #get_index_rendered_expressions(index, autogen_context)
 #,
 #unique": index.unique or False,
 #schema": (
 #", schema=%r" % _ident(index.table.schema))
 #f index.table.schema
 #lse ""
 #,
 #kwargs": ", " + ", ".join(opts) if opts else "",
 #
 #eturn text


@renderers.dispatch_for(ops.DropIndexOp)
def _drop_index(autogen_context: AutogenContext, op: ops.DropIndexOp) -> str:
 #ndex = op.to_index()

 #as_batch = autogen_context._has_batch

 #f has_batch:
 #mpl = "%(prefix)sdrop_index(%(name)r%(kwargs)s)"
 #lse:
 #mpl = (
 #%(prefix)sdrop_index(%(name)r, "
 #table_name=%(table_name)r%(schema)s%(kwargs)s)"
 #
 #pts = _render_dialect_kwargs_items(autogen_context, index.dialect_kwargs)
 #f op.if_exists is not None:
 #pts.append("if_exists=%r" % bool(op.if_exists))
 #ext = tmpl % {
 #prefix": _alembic_autogenerate_prefix(autogen_context),
 #name": _render_gen_name(autogen_context, op.index_name),
 #table_name": _ident(op.table_name),
 #schema": ((", schema=%r" % _ident(op.schema)) if op.schema else ""),
 #kwargs": ", " + ", ".join(opts) if opts else "",
 #
 #eturn text


@renderers.dispatch_for(ops.CreateUniqueConstraintOp)
def _add_unique_constraint(
 #utogen_context: AutogenContext, op: ops.CreateUniqueConstraintOp
) -> List[str]:
 #eturn [_uq_constraint(op.to_constraint(), autogen_context, True)]


@renderers.dispatch_for(ops.CreateForeignKeyOp)
def _add_fk_constraint(
 #utogen_context: AutogenContext, op: ops.CreateForeignKeyOp
) -> str:
 #onstraint = op.to_constraint()
 #rgs = [repr(_render_gen_name(autogen_context, op.constraint_name))]
 #f not autogen_context._has_batch:
 #rgs.append(repr(_ident(op.source_table)))

 #rgs.extend(
 #
 #epr(_ident(op.referent_table)),
 #epr([_ident(col) for col in op.local_cols]),
 #epr([_ident(col) for col in op.remote_cols]),
 #
 #
 #wargs = [
 #referent_schema",
 #onupdate",
 #ondelete",
 #initially",
 #deferrable",
 #use_alter",
 #match",
 #
 #f not autogen_context._has_batch:
 #wargs.insert(0, "source_schema")

 #or k in kwargs:
 #f k in op.kw:
 #alue = op.kw[k]
 #f value is not None:
 #rgs.append("%s=%r" % (k, value))

 #ialect_kwargs = _render_dialect_kwargs_items(
 #utogen_context, constraint.dialect_kwargs
 #

 #eturn "%(prefix)screate_foreign_key(%(args)s%(dialect_kwargs)s)" % {
 #prefix": _alembic_autogenerate_prefix(autogen_context),
 #args": ", ".join(args),
 #dialect_kwargs": (
 #, " + ", ".join(dialect_kwargs) if dialect_kwargs else ""
 #,
 #


@renderers.dispatch_for(ops.CreatePrimaryKeyOp)
def _add_pk_constraint(constraint, autogen_context):
 #aise NotImplementedError()


@renderers.dispatch_for(ops.CreateCheckConstraintOp)
def _add_check_constraint(constraint, autogen_context):
 #aise NotImplementedError()


@renderers.dispatch_for(ops.DropConstraintOp)
def _drop_constraint(
 #utogen_context: AutogenContext, op: ops.DropConstraintOp
) -> str:
 #refix = _alembic_autogenerate_prefix(autogen_context)
 #ame = _render_gen_name(autogen_context, op.constraint_name)
 #chema = _ident(op.schema) if op.schema else None
 #ype_ = _ident(op.constraint_type) if op.constraint_type else None
 #f_exists = op.if_exists
 #arams_strs = []
 #arams_strs.append(repr(name))
 #f not autogen_context._has_batch:
 #arams_strs.append(repr(_ident(op.table_name)))
 #f schema is not None:
 #arams_strs.append(f"schema={schema!r}")
 #f type_ is not None:
 #arams_strs.append(f"type_={type_!r}")
 #f if_exists is not None:
 #arams_strs.append(f"if_exists={if_exists}")

 #eturn f"{prefix}drop_constraint({', '.join(params_strs)})"


@renderers.dispatch_for(ops.AddColumnOp)
def _add_column(autogen_context: AutogenContext, op: ops.AddColumnOp) -> str:
 #chema, tname, column, if_not_exists = (
 #p.schema,
 #p.table_name,
 #p.column,
 #p.if_not_exists,
 #
 #f autogen_context._has_batch:
 #emplate = "%(prefix)sadd_column(%(column)s)"
 #lse:
 #emplate = "%(prefix)sadd_column(%(tname)r, %(column)s"
 #f schema:
 #emplate += ", schema=%(schema)r"
 #f if_not_exists is not None:
 #emplate += ", if_not_exists=%(if_not_exists)r"
 #emplate += ")"
 #ext = template % {
 #prefix": _alembic_autogenerate_prefix(autogen_context),
 #tname": tname,
 #column": _render_column(column, autogen_context),
 #schema": schema,
 #if_not_exists": if_not_exists,
 #
 #eturn text


@renderers.dispatch_for(ops.DropColumnOp)
def _drop_column(autogen_context: AutogenContext, op: ops.DropColumnOp) -> str:
 #chema, tname, column_name, if_exists = (
 #p.schema,
 #p.table_name,
 #p.column_name,
 #p.if_exists,
 #

 #f autogen_context._has_batch:
 #emplate = "%(prefix)sdrop_column(%(cname)r)"
 #lse:
 #emplate = "%(prefix)sdrop_column(%(tname)r, %(cname)r"
 #f schema:
 #emplate += ", schema=%(schema)r"
 #f if_exists is not None:
 #emplate += ", if_exists=%(if_exists)r"
 #emplate += ")"

 #ext = template % {
 #prefix": _alembic_autogenerate_prefix(autogen_context),
 #tname": _ident(tname),
 #cname": _ident(column_name),
 #schema": _ident(schema),
 #if_exists": if_exists,
 #
 #eturn text


@renderers.dispatch_for(ops.AlterColumnOp)
def _alter_column(
 #utogen_context: AutogenContext, op: ops.AlterColumnOp
) -> str:
 #name = op.table_name
 #name = op.column_name
 #erver_default = op.modify_server_default
 #ype_ = op.modify_type
 #ullable = op.modify_nullable
 #omment = op.modify_comment
 #ewname = op.modify_name
 #utoincrement = op.kw.get("autoincrement", None)
 #xisting_type = op.existing_type
 #xisting_nullable = op.existing_nullable
 #xisting_comment = op.existing_comment
 #xisting_server_default = op.existing_server_default
 #chema = op.schema

 #ndent = " " * 11

 #f autogen_context._has_batch:
 #emplate = "%(prefix)salter_column(%(cname)r"
 #lse:
 #emplate = "%(prefix)salter_column(%(tname)r, %(cname)r"

 #ext = template % {
 #prefix": _alembic_autogenerate_prefix(autogen_context),
 #tname": tname,
 #cname": cname,
 #
 #f existing_type is not None:
 #ext += ",\n%sexisting_type=%s" % (
 #ndent,
 #repr_type(existing_type, autogen_context),
 #
 #f server_default is not False:
 #endered = _render_server_default(server_default, autogen_context)
 #ext += ",\n%sserver_default=%s" % (indent, rendered)

 #f newname is not None:
 #ext += ",\n%snew_column_name=%r" % (indent, newname)
 #f type_ is not None:
 #ext += ",\n%stype_=%s" % (indent, _repr_type(type_, autogen_context))
 #f nullable is not None:
 #ext += ",\n%snullable=%r" % (indent, nullable)
 #f comment is not False:
 #ext += ",\n%scomment=%r" % (indent, comment)
 #f existing_comment is not None:
 #ext += ",\n%sexisting_comment=%r" % (indent, existing_comment)
 #f nullable is None and existing_nullable is not None:
 #ext += ",\n%sexisting_nullable=%r" % (indent, existing_nullable)
 #f autoincrement is not None:
 #ext += ",\n%sautoincrement=%r" % (indent, autoincrement)
 #f server_default is False and existing_server_default:
 #endered = _render_server_default(
 #xisting_server_default, autogen_context
 #
 #ext += ",\n%sexisting_server_default=%s" % (indent, rendered)
 #f schema and not autogen_context._has_batch:
 #ext += ",\n%sschema=%r" % (indent, schema)
 #ext += ")"
 #eturn text


class _f_name:
 #ef __init__(self, prefix: str, name: conv) -> None:
 #elf.prefix = prefix
 #elf.name = name

 #ef __repr__(self) -> str:
 #eturn "%sf(%r)" % (self.prefix, _ident(self.name))


def _ident(name: Optional[Union[quoted_name, str]]) -> Optional[str]:
 #""produce a __repr__() object for a string identifier that may
 #se quoted_name() in SQLAlchemy 0.9 and greater.

 #he issue worked around here is that quoted_name() doesn't have
 #ery good repr() behavior by itself when unicode is involved.

 #""
 #f name is None:
 #eturn name
 #lif isinstance(name, quoted_name):
 #eturn str(name)
 #lif isinstance(name, str):
 #eturn name


def _render_potential_expr(
 #alue: Any,
 #utogen_context: AutogenContext,
 #,
 #rap_in_element: bool = True,
 #s_server_default: bool = False,
 #s_index: bool = False,
) -> str:
 #f isinstance(value, sql.ClauseElement):
 #ql_text = autogen_context.migration_context.impl.render_ddl_sql_expr(
 #alue, is_server_default=is_server_default, is_index=is_index
 #
 #f wrap_in_element:
 #refix = _sqlalchemy_autogenerate_prefix(autogen_context)
 #lement = "literal_column" if is_index else "text"
 #alue_str = f"{prefix}{element}({sql_text!r})"
 #f (
 #s_index
 #nd isinstance(value, Label)
 #nd type(value.name) is str
 #:
 #eturn value_str + f".label({value.name!r})"
 #lse:
 #eturn value_str
 #lse:
 #eturn repr(sql_text)
 #lse:
 #eturn repr(value)


def _get_index_rendered_expressions(
 #dx: Index, autogen_context: AutogenContext
) -> List[str]:
 #eturn [
 #
 #epr(_ident(getattr(exp, "name", None)))
 #f isinstance(exp, sa_schema.Column)
 #lse _render_potential_expr(exp, autogen_context, is_index=True)
 #
 #or exp in idx.expressions
 #


def _uq_constraint(
 #onstraint: UniqueConstraint,
 #utogen_context: AutogenContext,
 #lter: bool,
) -> str:
 #pts: List[Tuple[str, Any]] = []

 #as_batch = autogen_context._has_batch

 #f constraint.deferrable:
 #pts.append(("deferrable", constraint.deferrable))
 #f constraint.initially:
 #pts.append(("initially", constraint.initially))
 #f not has_batch and alter and constraint.table.schema:
 #pts.append(("schema", _ident(constraint.table.schema)))
 #f not alter and constraint.name:
 #pts.append(
 #"name", _render_gen_name(autogen_context, constraint.name))
 #
 #ialect_options = _render_dialect_kwargs_items(
 #utogen_context, constraint.dialect_kwargs
 #

 #f alter:
 #rgs = [repr(_render_gen_name(autogen_context, constraint.name))]
 #f not has_batch:
 #rgs += [repr(_ident(constraint.table.name))]
 #rgs.append(repr([_ident(col.name) for col in constraint.columns]))
 #rgs.extend(["%s=%r" % (k, v) for k, v in opts])
 #rgs.extend(dialect_options)
 #eturn "%(prefix)screate_unique_constraint(%(args)s)" % {
 #prefix": _alembic_autogenerate_prefix(autogen_context),
 #args": ", ".join(args),
 #
 #lse:
 #rgs = [repr(_ident(col.name)) for col in constraint.columns]
 #rgs.extend(["%s=%r" % (k, v) for k, v in opts])
 #rgs.extend(dialect_options)
 #eturn "%(prefix)sUniqueConstraint(%(args)s)" % {
 #prefix": _sqlalchemy_autogenerate_prefix(autogen_context),
 #args": ", ".join(args),
 #


def _user_autogenerate_prefix(autogen_context, target):
 #refix = autogen_context.opts["user_module_prefix"]
 #f prefix is None:
 #eturn "%s." % target.__module__
 #lse:
 #eturn prefix


def _sqlalchemy_autogenerate_prefix(autogen_context: AutogenContext) -> str:
 #eturn autogen_context.opts["sqlalchemy_module_prefix"] or ""


def _alembic_autogenerate_prefix(autogen_context: AutogenContext) -> str:
 #f autogen_context._has_batch:
 #eturn "batch_op."
 #lse:
 #eturn autogen_context.opts["alembic_module_prefix"] or ""


def _user_defined_render(
 #ype_: str, object_: Any, autogen_context: AutogenContext
) -> Union[str, Literal[False]]:
 #f "render_item" in autogen_context.opts:
 #ender = autogen_context.opts["render_item"]
 #f render:
 #endered = render(type_, object_, autogen_context)
 #f rendered is not False:
 #eturn rendered
 #eturn False


def _render_column(
 #olumn: Column[Any], autogen_context: AutogenContext
) -> str:
 #endered = _user_defined_render("column", column, autogen_context)
 #f rendered is not False:
 #eturn rendered

 #rgs: List[str] = []
 #pts: List[Tuple[str, Any]] = []

 #f column.server_default:
 #endered = _render_server_default(  # type:ignore[assignment]
 #olumn.server_default, autogen_context
 #
 #f rendered:
 #f _should_render_server_default_positionally(
 #olumn.server_default
 #:
 #rgs.append(rendered)
 #lse:
 #pts.append(("server_default", rendered))

 #f (
 #olumn.autoincrement is not None
 #nd column.autoincrement != sqla_compat.AUTOINCREMENT_DEFAULT
 #:
 #pts.append(("autoincrement", column.autoincrement))

 #f column.nullable is not None:
 #pts.append(("nullable", column.nullable))

 #f column.system:
 #pts.append(("system", column.system))

 #omment = column.comment
 #f comment:
 #pts.append(("comment", "%r" % comment))

    # TODO: for non-ascii colname, assign a "key"
 #eturn "%(prefix)sColumn(%(name)r, %(type)s, %(args)s%(kwargs)s)" % {
 #prefix": _sqlalchemy_autogenerate_prefix(autogen_context),
 #name": _ident(column.name),
 #type": _repr_type(column.type, autogen_context),
 #args": ", ".join([str(arg) for arg in args]) + ", " if args else "",
 #kwargs": (
 #, ".join(
 #"%s=%s" % (kwname, val) for kwname, val in opts]
 # [
 #%s=%s"
 # (key, _render_potential_expr(val, autogen_context))
 #or key, val in column.kwargs.items()
 #
 #
 #,
 #


def _should_render_server_default_positionally(server_default: Any) -> bool:
 #eturn sqla_compat._server_default_is_computed(
 #erver_default
 # or sqla_compat._server_default_is_identity(server_default)


def _render_server_default(
 #efault: Optional[
 #nion[FetchedValue, str, TextClause, ColumnElement[Any]]
 #,
 #utogen_context: AutogenContext,
 #epr_: bool = True,
) -> Optional[str]:
 #endered = _user_defined_render("server_default", default, autogen_context)
 #f rendered is not False:
 #eturn rendered

 #f sqla_compat._server_default_is_computed(default):
 #eturn _render_computed(cast("Computed", default), autogen_context)
 #lif sqla_compat._server_default_is_identity(default):
 #eturn _render_identity(cast("Identity", default), autogen_context)
 #lif isinstance(default, sa_schema.DefaultClause):
 #f isinstance(default.arg, str):
 #efault = default.arg
 #lse:
 #eturn _render_potential_expr(
 #efault.arg, autogen_context, is_server_default=True
 #
 #lif isinstance(default, sa_schema.FetchedValue):
 #eturn _render_fetched_value(autogen_context)

 #f isinstance(default, str) and repr_:
 #efault = repr(re.sub(r"^'|'$", "", default))

 #eturn cast(str, default)


def _render_computed(
 #omputed: Computed, autogen_context: AutogenContext
) -> str:
 #ext = _render_potential_expr(
 #omputed.sqltext, autogen_context, wrap_in_element=False
 #

 #wargs = {}
 #f computed.persisted is not None:
 #wargs["persisted"] = computed.persisted
 #eturn "%(prefix)sComputed(%(text)s, %(kwargs)s)" % {
 #prefix": _sqlalchemy_autogenerate_prefix(autogen_context),
 #text": text,
 #kwargs": (", ".join("%s=%s" % pair for pair in kwargs.items())),
 #


def _render_identity(
 #dentity: Identity, autogen_context: AutogenContext
) -> str:
 #wargs = sqla_compat._get_identity_options_dict(
 #dentity, dialect_kwargs=True
 #

 #eturn "%(prefix)sIdentity(%(kwargs)s)" % {
 #prefix": _sqlalchemy_autogenerate_prefix(autogen_context),
 #kwargs": (", ".join("%s=%s" % pair for pair in kwargs.items())),
 #


def _render_fetched_value(autogen_context: AutogenContext) -> str:
 #eturn "%(prefix)sFetchedValue()" % {
 #prefix": _sqlalchemy_autogenerate_prefix(autogen_context),
 #


def _repr_type(
 #ype_: TypeEngine,
 #utogen_context: AutogenContext,
 #skip_variants: bool = False,
) -> str:
 #endered = _user_defined_render("type", type_, autogen_context)
 #f rendered is not False:
 #eturn rendered

 #f hasattr(autogen_context.migration_context, "impl"):
 #mpl_rt = autogen_context.migration_context.impl.render_type(
 #ype_, autogen_context
 #
 #lse:
 #mpl_rt = None

 #od = type(type_).__module__
 #mports = autogen_context.imports

 #f not _skip_variants and sqla_compat._type_has_variants(type_):
 #eturn _render_Variant_type(type_, autogen_context)
 #lif mod.startswith("sqlalchemy.dialects"):
 #atch = re.match(r"sqlalchemy\.dialects\.(\w+)", mod)
 #ssert match is not None
 #name = match.group(1)
 #f imports is not None:
 #mports.add("from sqlalchemy.dialects import %s" % dname)
 #f impl_rt:
 #eturn impl_rt
 #lse:
 #eturn "%s.%r" % (dname, type_)
 #lif impl_rt:
 #eturn impl_rt
 #lif mod.startswith("sqlalchemy."):
 #f "_render_%s_type" % type_.__visit_name__ in globals():
 #n = globals()["_render_%s_type" % type_.__visit_name__]
 #eturn fn(type_, autogen_context)
 #lse:
 #refix = _sqlalchemy_autogenerate_prefix(autogen_context)
 #eturn "%s%r" % (prefix, type_)
 #lse:
 #refix = _user_autogenerate_prefix(autogen_context, type_)
 #eturn "%s%r" % (prefix, type_)


def _render_ARRAY_type(type_: ARRAY, autogen_context: AutogenContext) -> str:
 #eturn cast(
 #tr,
 #render_type_w_subtype(
 #ype_, autogen_context, "item_type", r"(.+?\()"
 #,
 #


def _render_Variant_type(
 #ype_: TypeEngine, autogen_context: AutogenContext
) -> str:
 #ase_type, variant_mapping = sqla_compat._get_variant_mapping(type_)
 #ase = _repr_type(base_type, autogen_context, _skip_variants=True)
 #ssert base is not None and base is not False  # type: ignore[comparison-overlap]  # noqa:E501
 #or dialect in sorted(variant_mapping):
 #yp = variant_mapping[dialect]
 #ase += ".with_variant(%s, %r)" % (
 #repr_type(typ, autogen_context, _skip_variants=True),
 #ialect,
 #
 #eturn base


def _render_type_w_subtype(
 #ype_: TypeEngine,
 #utogen_context: AutogenContext,
 #ttrname: str,
 #egexp: str,
 #refix: Optional[str] = None,
) -> Union[Optional[str], Literal[False]]:
 #uter_repr = repr(type_)
 #nner_type = getattr(type_, attrname, None)
 #f inner_type is None:
 #eturn False

 #nner_repr = repr(inner_type)

 #nner_repr = re.sub(r"([\(\)])", r"\\\1", inner_repr)
 #ub_type = _repr_type(getattr(type_, attrname), autogen_context)
 #uter_type = re.sub(regexp + inner_repr, r"\1%s" % sub_type, outer_repr)

 #f prefix:
 #eturn "%s%s" % (prefix, outer_type)

 #od = type(type_).__module__
 #f mod.startswith("sqlalchemy.dialects"):
 #atch = re.match(r"sqlalchemy\.dialects\.(\w+)", mod)
 #ssert match is not None
 #name = match.group(1)
 #eturn "%s.%s" % (dname, outer_type)
 #lif mod.startswith("sqlalchemy"):
 #refix = _sqlalchemy_autogenerate_prefix(autogen_context)
 #eturn "%s%s" % (prefix, outer_type)
 #lse:
 #eturn None


_constraint_renderers = util.Dispatcher()


def _render_constraint(
 #onstraint: Constraint,
 #utogen_context: AutogenContext,
 #amespace_metadata: Optional[MetaData],
) -> Optional[str]:
 #ry:
 #enderer = _constraint_renderers.dispatch(constraint)
 #xcept ValueError:
 #til.warn("No renderer is established for object %r" % constraint)
 #eturn "[Unknown Python object %r]" % constraint
 #lse:
 #eturn renderer(constraint, autogen_context, namespace_metadata)


@_constraint_renderers.dispatch_for(sa_schema.PrimaryKeyConstraint)
def _render_primary_key(
 #onstraint: PrimaryKeyConstraint,
 #utogen_context: AutogenContext,
 #amespace_metadata: Optional[MetaData],
) -> Optional[str]:
 #endered = _user_defined_render("primary_key", constraint, autogen_context)
 #f rendered is not False:
 #eturn rendered

 #f not constraint.columns:
 #eturn None

 #pts = []
 #f constraint.name:
 #pts.append(
 #"name", repr(_render_gen_name(autogen_context, constraint.name)))
 #
 #eturn "%(prefix)sPrimaryKeyConstraint(%(args)s)" % {
 #prefix": _sqlalchemy_autogenerate_prefix(autogen_context),
 #args": ", ".join(
 #repr(c.name) for c in constraint.columns]
 # ["%s=%s" % (kwname, val) for kwname, val in opts]
 #,
 #


def _fk_colspec(
 #k: ForeignKey,
 #etadata_schema: Optional[str],
 #amespace_metadata: Optional[MetaData],
) -> str:
 #""Implement a 'safe' version of ForeignKey._get_colspec() that
 #on't fail if the remote table can't be resolved.

 #""
 #olspec = fk._get_colspec()
 #okens = colspec.split(".")
 #name, colname = tokens[-2:]

 #f metadata_schema is not None and len(tokens) == 2:
 #able_fullname = "%s.%s" % (metadata_schema, tname)
 #lse:
 #able_fullname = ".".join(tokens[0:-1])

 #f (
 #ot fk.link_to_name
 #nd fk.parent is not None
 #nd fk.parent.table is not None
 #:
        # try to resolve the remote table in order to adjust for column.key.
        # the FK constraint needs to be rendered in terms of the column
        # name.

 #f (
 #amespace_metadata is not None
 #nd table_fullname in namespace_metadata.tables
 #:
 #ol = namespace_metadata.tables[table_fullname].c.get(colname)
 #f col is not None:
 #olname = _ident(col.name)  # type: ignore[assignment]

 #olspec = "%s.%s" % (table_fullname, colname)

 #eturn colspec


def _populate_render_fk_opts(
 #onstraint: ForeignKeyConstraint, opts: List[Tuple[str, str]]
) -> None:
 #f constraint.onupdate:
 #pts.append(("onupdate", repr(constraint.onupdate)))
 #f constraint.ondelete:
 #pts.append(("ondelete", repr(constraint.ondelete)))
 #f constraint.initially:
 #pts.append(("initially", repr(constraint.initially)))
 #f constraint.deferrable:
 #pts.append(("deferrable", repr(constraint.deferrable)))
 #f constraint.use_alter:
 #pts.append(("use_alter", repr(constraint.use_alter)))
 #f constraint.match:
 #pts.append(("match", repr(constraint.match)))


@_constraint_renderers.dispatch_for(sa_schema.ForeignKeyConstraint)
def _render_foreign_key(
 #onstraint: ForeignKeyConstraint,
 #utogen_context: AutogenContext,
 #amespace_metadata: Optional[MetaData],
) -> Optional[str]:
 #endered = _user_defined_render("foreign_key", constraint, autogen_context)
 #f rendered is not False:
 #eturn rendered

 #pts = []
 #f constraint.name:
 #pts.append(
 #"name", repr(_render_gen_name(autogen_context, constraint.name)))
 #

 #populate_render_fk_opts(constraint, opts)

 #pply_metadata_schema = (
 #amespace_metadata.schema if namespace_metadata is not None else None
 #
 #eturn (
 #%(prefix)sForeignKeyConstraint([%(cols)s], "
 #[%(refcols)s], %(args)s)"
 # {
 #prefix": _sqlalchemy_autogenerate_prefix(autogen_context),
 #cols": ", ".join(
 #epr(_ident(f.parent.name)) for f in constraint.elements
 #,
 #refcols": ", ".join(
 #epr(_fk_colspec(f, apply_metadata_schema, namespace_metadata))
 #or f in constraint.elements
 #,
 #args": ", ".join(
 #"%s=%s" % (kwname, val) for kwname, val in opts]
 #,
 #
 #


@_constraint_renderers.dispatch_for(sa_schema.UniqueConstraint)
def _render_unique_constraint(
 #onstraint: UniqueConstraint,
 #utogen_context: AutogenContext,
 #amespace_metadata: Optional[MetaData],
) -> str:
 #endered = _user_defined_render("unique", constraint, autogen_context)
 #f rendered is not False:
 #eturn rendered

 #eturn _uq_constraint(constraint, autogen_context, False)


@_constraint_renderers.dispatch_for(sa_schema.CheckConstraint)
def _render_check_constraint(
 #onstraint: CheckConstraint,
 #utogen_context: AutogenContext,
 #amespace_metadata: Optional[MetaData],
) -> Optional[str]:
 #endered = _user_defined_render("check", constraint, autogen_context)
 #f rendered is not False:
 #eturn rendered

    # detect the constraint being part of
    # a parent type which is probably in the Table already.
    # ideally SQLAlchemy would give us more of a first class
    # way to detect this.
 #f (
 #onstraint._create_rule
 #nd hasattr(constraint._create_rule, "target")
 #nd isinstance(
 #onstraint._create_rule.target,
 #qltypes.TypeEngine,
 #
 #:
 #eturn None
 #pts = []
 #f constraint.name:
 #pts.append(
 #"name", repr(_render_gen_name(autogen_context, constraint.name)))
 #
 #eturn "%(prefix)sCheckConstraint(%(sqltext)s%(opts)s)" % {
 #prefix": _sqlalchemy_autogenerate_prefix(autogen_context),
 #opts": (
 #, " + (", ".join("%s=%s" % (k, v) for k, v in opts))
 #f opts
 #lse ""
 #,
 #sqltext": _render_potential_expr(
 #onstraint.sqltext, autogen_context, wrap_in_element=False
 #,
 #


@renderers.dispatch_for(ops.ExecuteSQLOp)
def _execute_sql(autogen_context: AutogenContext, op: ops.ExecuteSQLOp) -> str:
 #f not isinstance(op.sqltext, str):
 #aise NotImplementedError(
 #Autogenerate rendering of SQL Expression language constructs "
 #not supported here; please use a plain SQL string"
 #
 #eturn "{prefix}execute({sqltext!r})".format(
 #refix=_alembic_autogenerate_prefix(autogen_context),
 #qltext=op.sqltext,
 #


renderers = default_renderers.branch()
