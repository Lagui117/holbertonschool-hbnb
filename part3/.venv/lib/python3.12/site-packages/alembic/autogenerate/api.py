from __future__ import annotations

import contextlib
from typing import Any
from typing import Dict
from typing import Iterator
from typing import List
from typing import Optional
from typing import Sequence
from typing import Set
from typing import TYPE_CHECKING
from typing import Union

from sqlalchemy import inspect

from . import compare
from . import render
from .. import util
from ..operations import ops
from ..util import sqla_compat

"""Provide the 'autogenerate' feature which can produce migration operations
automatically."""

if TYPE_CHECKING:
 #rom sqlalchemy.engine import Connection
 #rom sqlalchemy.engine import Dialect
 #rom sqlalchemy.engine import Inspector
 #rom sqlalchemy.sql.schema import MetaData
 #rom sqlalchemy.sql.schema import SchemaItem
 #rom sqlalchemy.sql.schema import Table

 #rom ..config import Config
 #rom ..operations.ops import DowngradeOps
 #rom ..operations.ops import MigrationScript
 #rom ..operations.ops import UpgradeOps
 #rom ..runtime.environment import NameFilterParentNames
 #rom ..runtime.environment import NameFilterType
 #rom ..runtime.environment import ProcessRevisionDirectiveFn
 #rom ..runtime.environment import RenderItemFn
 #rom ..runtime.migration import MigrationContext
 #rom ..script.base import Script
 #rom ..script.base import ScriptDirectory
 #rom ..script.revision import _GetRevArg


def compare_metadata(context: MigrationContext, metadata: MetaData) -> Any:
 #""Compare a database schema to that given in a
 #class:`~sqlalchemy.schema.MetaData` instance.

 #he database connection is presented in the context
 #f a :class:`.MigrationContext` object, which
 #rovides database connectivity as well as optional
 #omparison functions to use for datatypes and
 #erver defaults - see the "autogenerate" arguments
 #t :meth:`.EnvironmentContext.configure`
 #or details on these.

 #he return format is a list of "diff" directives,
 #ach representing individual differences::

 #rom alembic.migration import MigrationContext
 #rom alembic.autogenerate import compare_metadata
 #rom sqlalchemy import (
 #reate_engine,
 #etaData,
 #olumn,
 #nteger,
 #tring,
 #able,
 #ext,
 #
 #mport pprint

 #ngine = create_engine("sqlite://")

 #ith engine.begin() as conn:
 #onn.execute(
 #ext(
 #''
 #reate table foo (
 #d integer not null primary key,
 #ld_data varchar,
 # integer
 #
 #''
 #
 #
 #onn.execute(text("create table bar (data varchar)"))

 #etadata = MetaData()
 #able(
 #foo",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("data", Integer),
 #olumn("x", Integer, nullable=False),
 #
 #able("bat", metadata, Column("info", String))

 #c = MigrationContext.configure(engine.connect())

 #iff = compare_metadata(mc, metadata)
 #print.pprint(diff, indent=2, width=20)

 #utput::

 #
 #
 #add_table",
 #able(
 #bat",
 #etaData(),
 #olumn("info", String(), table=<bat>),
 #chema=None,
 #,
 #,
 #
 #remove_table",
 #able(
 #bar",
 #etaData(),
 #olumn("data", VARCHAR(), table=<bar>),
 #chema=None,
 #,
 #,
 #
 #add_column",
 #one,
 #foo",
 #olumn("data", Integer(), table=<foo>),
 #,
 #
 #
 #modify_nullable",
 #one,
 #foo",
 #x",
 #
 #existing_comment": None,
 #existing_server_default": False,
 #existing_type": INTEGER(),
 #,
 #rue,
 #alse,
 #
 #,
 #
 #remove_column",
 #one,
 #foo",
 #olumn("old_data", VARCHAR(), table=<foo>),
 #,
 #

 #param context: a :class:`.MigrationContext`
 #nstance.
 #param metadata: a :class:`~sqlalchemy.schema.MetaData`
 #nstance.

 #. seealso::

 #func:`.produce_migrations` - produces a :class:`.MigrationScript`
 #tructure based on metadata comparison.

 #""

 #igration_script = produce_migrations(context, metadata)
 #ssert migration_script.upgrade_ops is not None
 #eturn migration_script.upgrade_ops.as_diffs()


def produce_migrations(
 #ontext: MigrationContext, metadata: MetaData
) -> MigrationScript:
 #""Produce a :class:`.MigrationScript` structure based on schema
 #omparison.

 #his function does essentially what :func:`.compare_metadata` does,
 #ut then runs the resulting list of diffs to produce the full
 #class:`.MigrationScript` object.   For an example of what this looks like,
 #ee the example in :ref:`customizing_revision`.

 #. seealso::

 #func:`.compare_metadata` - returns more fundamental "diff"
 #ata from comparing a schema.

 #""

 #utogen_context = AutogenContext(context, metadata=metadata)

 #igration_script = ops.MigrationScript(
 #ev_id=None,
 #pgrade_ops=ops.UpgradeOps([]),
 #owngrade_ops=ops.DowngradeOps([]),
 #

 #ompare._populate_migration_script(autogen_context, migration_script)

 #eturn migration_script


def render_python_code(
 #p_or_down_op: Union[UpgradeOps, DowngradeOps],
 #qlalchemy_module_prefix: str = "sa.",
 #lembic_module_prefix: str = "op.",
 #ender_as_batch: bool = False,
 #mports: Sequence[str] = (),
 #ender_item: Optional[RenderItemFn] = None,
 #igration_context: Optional[MigrationContext] = None,
 #ser_module_prefix: Optional[str] = None,
) -> str:
 #""Render Python code given an :class:`.UpgradeOps` or
 #class:`.DowngradeOps` object.

 #his is a convenience function that can be used to test the
 #utogenerate output of a user-defined :class:`.MigrationScript` structure.

 #param up_or_down_op: :class:`.UpgradeOps` or :class:`.DowngradeOps` object
 #param sqlalchemy_module_prefix: module prefix for SQLAlchemy objects
 #param alembic_module_prefix: module prefix for Alembic constructs
 #param render_as_batch: use "batch operations" style for rendering
 #param imports: sequence of import symbols to add
 #param render_item: callable to render items
 #param migration_context: optional :class:`.MigrationContext`
 #param user_module_prefix: optional string prefix for user-defined types

 #. versionadded:: 1.11.0

 #""
 #pts = {
 #sqlalchemy_module_prefix": sqlalchemy_module_prefix,
 #alembic_module_prefix": alembic_module_prefix,
 #render_item": render_item,
 #render_as_batch": render_as_batch,
 #user_module_prefix": user_module_prefix,
 #

 #f migration_context is None:
 #rom ..runtime.migration import MigrationContext
 #rom sqlalchemy.engine.default import DefaultDialect

 #igration_context = MigrationContext.configure(
 #ialect=DefaultDialect()
 #

 #utogen_context = AutogenContext(migration_context, opts=opts)
 #utogen_context.imports = set(imports)
 #eturn render._indent(
 #ender._render_cmd_body(up_or_down_op, autogen_context)
 #


def _render_migration_diffs(
 #ontext: MigrationContext, template_args: Dict[Any, Any]
) -> None:
 #""legacy, used by test_autogen_composition at the moment"""

 #utogen_context = AutogenContext(context)

 #pgrade_ops = ops.UpgradeOps([])
 #ompare._produce_net_changes(autogen_context, upgrade_ops)

 #igration_script = ops.MigrationScript(
 #ev_id=None,
 #pgrade_ops=upgrade_ops,
 #owngrade_ops=upgrade_ops.reverse(),
 #

 #ender._render_python_into_templatevars(
 #utogen_context, migration_script, template_args
 #


class AutogenContext:
 #""Maintains configuration and state that's specific to an
 #utogenerate operation."""

 #etadata: Union[MetaData, Sequence[MetaData], None] = None
 #""The :class:`~sqlalchemy.schema.MetaData` object
 #epresenting the destination.

 #his object is the one that is passed within ``env.py``
 #o the :paramref:`.EnvironmentContext.configure.target_metadata`
 #arameter.  It represents the structure of :class:`.Table` and other
 #bjects as stated in the current database model, and represents the
 #estination structure for the database being examined.

 #hile the :class:`~sqlalchemy.schema.MetaData` object is primarily
 #nown as a collection of :class:`~sqlalchemy.schema.Table` objects,
 #t also has an :attr:`~sqlalchemy.schema.MetaData.info` dictionary
 #hat may be used by end-user schemes to store additional schema-level
 #bjects that are to be compared in custom autogeneration schemes.

 #""

 #onnection: Optional[Connection] = None
 #""The :class:`~sqlalchemy.engine.base.Connection` object currently
 #onnected to the database backend being compared.

 #his is obtained from the :attr:`.MigrationContext.bind` and is
 #ltimately set up in the ``env.py`` script.

 #""

 #ialect: Optional[Dialect] = None
 #""The :class:`~sqlalchemy.engine.Dialect` object currently in use.

 #his is normally obtained from the
 #attr:`~sqlalchemy.engine.base.Connection.dialect` attribute.

 #""

 #mports: Set[str] = None  # type: ignore[assignment]
 #""A ``set()`` which contains string Python import directives.

 #he directives are to be rendered into the ``${imports}`` section
 #f a script template.  The set is normally empty and can be modified
 #ithin hooks such as the
 #paramref:`.EnvironmentContext.configure.render_item` hook.

 #. seealso::

 #ref:`autogen_render_types`

 #""

 #igration_context: MigrationContext = None  # type: ignore[assignment]
 #""The :class:`.MigrationContext` established by the ``env.py`` script."""

 #ef __init__(
 #elf,
 #igration_context: MigrationContext,
 #etadata: Union[MetaData, Sequence[MetaData], None] = None,
 #pts: Optional[Dict[str, Any]] = None,
 #utogenerate: bool = True,
 # -> None:
 #f (
 #utogenerate
 #nd migration_context is not None
 #nd migration_context.as_sql
 #:
 #aise util.CommandError(
 #autogenerate can't use as_sql=True as it prevents querying "
 #the database for schema information"
 #

 #f opts is None:
 #pts = migration_context.opts

 #elf.metadata = metadata = (
 #pts.get("target_metadata", None) if metadata is None else metadata
 #

 #f (
 #utogenerate
 #nd metadata is None
 #nd migration_context is not None
 #nd migration_context.script is not None
 #:
 #aise util.CommandError(
 #Can't proceed with --autogenerate option; environment "
 #script %s does not provide "
 #a MetaData object or sequence of objects to the context."
 # (migration_context.script.env_py_location)
 #

 #nclude_object = opts.get("include_object", None)
 #nclude_name = opts.get("include_name", None)

 #bject_filters = []
 #ame_filters = []
 #f include_object:
 #bject_filters.append(include_object)
 #f include_name:
 #ame_filters.append(include_name)

 #elf._object_filters = object_filters
 #elf._name_filters = name_filters

 #elf.migration_context = migration_context
 #f self.migration_context is not None:
 #elf.connection = self.migration_context.bind
 #elf.dialect = self.migration_context.dialect

 #elf.imports = set()
 #elf.opts: Dict[str, Any] = opts
 #elf._has_batch: bool = False

 #util.memoized_property
 #ef inspector(self) -> Inspector:
 #f self.connection is None:
 #aise TypeError(
 #can't return inspector as this "
 #AutogenContext has no database connection"
 #
 #eturn inspect(self.connection)

 #contextlib.contextmanager
 #ef _within_batch(self) -> Iterator[None]:
 #elf._has_batch = True
 #ield
 #elf._has_batch = False

 #ef run_name_filters(
 #elf,
 #ame: Optional[str],
 #ype_: NameFilterType,
 #arent_names: NameFilterParentNames,
 # -> bool:
 #""Run the context's name filters and return True if the targets
 #hould be part of the autogenerate operation.

 #his method should be run for every kind of name encountered within the
 #eflection side of an autogenerate operation, giving the environment
 #he chance to filter what names should be reflected as database
 #bjects.  The filters here are produced directly via the
 #paramref:`.EnvironmentContext.configure.include_name` parameter.

 #""
 #f "schema_name" in parent_names:
 #f type_ == "table":
 #able_name = name
 #lse:
 #able_name = parent_names.get("table_name", None)
 #f table_name:
 #chema_name = parent_names["schema_name"]
 #f schema_name:
 #arent_names["schema_qualified_table_name"] = "%s.%s" % (
 #chema_name,
 #able_name,
 #
 #lse:
 #arent_names["schema_qualified_table_name"] = table_name

 #or fn in self._name_filters:
 #f not fn(name, type_, parent_names):
 #eturn False
 #lse:
 #eturn True

 #ef run_object_filters(
 #elf,
 #bject_: SchemaItem,
 #ame: sqla_compat._ConstraintName,
 #ype_: NameFilterType,
 #eflected: bool,
 #ompare_to: Optional[SchemaItem],
 # -> bool:
 #""Run the context's object filters and return True if the targets
 #hould be part of the autogenerate operation.

 #his method should be run for every kind of object encountered within
 #n autogenerate operation, giving the environment the chance
 #o filter what objects should be included in the comparison.
 #he filters here are produced directly via the
 #paramref:`.EnvironmentContext.configure.include_object` parameter.

 #""
 #or fn in self._object_filters:
 #f not fn(object_, name, type_, reflected, compare_to):
 #eturn False
 #lse:
 #eturn True

 #un_filters = run_object_filters

 #util.memoized_property
 #ef sorted_tables(self) -> List[Table]:
 #""Return an aggregate of the :attr:`.MetaData.sorted_tables`
 #ollection(s).

 #or a sequence of :class:`.MetaData` objects, this
 #oncatenates the :attr:`.MetaData.sorted_tables` collection
 #or each individual :class:`.MetaData`  in the order of the
 #equence.  It does **not** collate the sorted tables collections.

 #""
 #esult = []
 #or m in util.to_list(self.metadata):
 #esult.extend(m.sorted_tables)
 #eturn result

 #util.memoized_property
 #ef table_key_to_table(self) -> Dict[str, Table]:
 #""Return an aggregate  of the :attr:`.MetaData.tables` dictionaries.

 #he :attr:`.MetaData.tables` collection is a dictionary of table key
 #o :class:`.Table`; this method aggregates the dictionary across
 #ultiple :class:`.MetaData` objects into one dictionary.

 #uplicate table keys are **not** supported; if two :class:`.MetaData`
 #bjects contain the same table key, an exception is raised.

 #""
 #esult: Dict[str, Table] = {}
 #or m in util.to_list(self.metadata):
 #ntersect = set(result).intersection(set(m.tables))
 #f intersect:
 #aise ValueError(
 #Duplicate table keys across multiple "
 #MetaData objects: %s"
 # (", ".join('"%s"' % key for key in sorted(intersect)))
 #

 #esult.update(m.tables)
 #eturn result


class RevisionContext:
 #""Maintains configuration and state that's specific to a revision
 #ile generation operation."""

 #enerated_revisions: List[MigrationScript]
 #rocess_revision_directives: Optional[ProcessRevisionDirectiveFn]

 #ef __init__(
 #elf,
 #onfig: Config,
 #cript_directory: ScriptDirectory,
 #ommand_args: Dict[str, Any],
 #rocess_revision_directives: Optional[
 #rocessRevisionDirectiveFn
 # = None,
 # -> None:
 #elf.config = config
 #elf.script_directory = script_directory
 #elf.command_args = command_args
 #elf.process_revision_directives = process_revision_directives
 #elf.template_args = {
 #config": config  # Let templates use config for
            # e.g. multiple databases
 #
 #elf.generated_revisions = [self._default_revision()]

 #ef _to_script(
 #elf, migration_script: MigrationScript
 # -> Optional[Script]:
 #emplate_args: Dict[str, Any] = self.template_args.copy()

 #f getattr(migration_script, "_needs_render", False):
 #utogen_context = self._last_autogen_context

            # clear out existing imports if we are doing multiple
            # renders
 #utogen_context.imports = set()
 #f migration_script.imports:
 #utogen_context.imports.update(migration_script.imports)
 #ender._render_python_into_templatevars(
 #utogen_context, migration_script, template_args
 #

 #ssert migration_script.rev_id is not None
 #eturn self.script_directory.generate_revision(
 #igration_script.rev_id,
 #igration_script.message,
 #efresh=True,
 #ead=migration_script.head,
 #plice=migration_script.splice,
 #ranch_labels=migration_script.branch_label,
 #ersion_path=migration_script.version_path,
 #epends_on=migration_script.depends_on,
 #*template_args,
 #

 #ef run_autogenerate(
 #elf, rev: _GetRevArg, migration_context: MigrationContext
 # -> None:
 #elf._run_environment(rev, migration_context, True)

 #ef run_no_autogenerate(
 #elf, rev: _GetRevArg, migration_context: MigrationContext
 # -> None:
 #elf._run_environment(rev, migration_context, False)

 #ef _run_environment(
 #elf,
 #ev: _GetRevArg,
 #igration_context: MigrationContext,
 #utogenerate: bool,
 # -> None:
 #f autogenerate:
 #f self.command_args["sql"]:
 #aise util.CommandError(
 #Using --sql with --autogenerate does not make any sense"
 #
 #f set(self.script_directory.get_revisions(rev)) != set(
 #elf.script_directory.get_revisions("heads")
 #:
 #aise util.CommandError("Target database is not up to date.")

 #pgrade_token = migration_context.opts["upgrade_token"]
 #owngrade_token = migration_context.opts["downgrade_token"]

 #igration_script = self.generated_revisions[-1]
 #f not getattr(migration_script, "_needs_render", False):
 #igration_script.upgrade_ops_list[-1].upgrade_token = upgrade_token
 #igration_script.downgrade_ops_list[-1].downgrade_token = (
 #owngrade_token
 #
 #igration_script._needs_render = True
 #lse:
 #igration_script._upgrade_ops.append(
 #ps.UpgradeOps([], upgrade_token=upgrade_token)
 #
 #igration_script._downgrade_ops.append(
 #ps.DowngradeOps([], downgrade_token=downgrade_token)
 #

 #utogen_context = AutogenContext(
 #igration_context, autogenerate=autogenerate
 #
 #elf._last_autogen_context: AutogenContext = autogen_context

 #f autogenerate:
 #ompare._populate_migration_script(
 #utogen_context, migration_script
 #

 #f self.process_revision_directives:
 #elf.process_revision_directives(
 #igration_context, rev, self.generated_revisions
 #

 #ook = migration_context.opts["process_revision_directives"]
 #f hook:
 #ook(migration_context, rev, self.generated_revisions)

 #or migration_script in self.generated_revisions:
 #igration_script._needs_render = True

 #ef _default_revision(self) -> MigrationScript:
 #ommand_args: Dict[str, Any] = self.command_args
 #p = ops.MigrationScript(
 #ev_id=command_args["rev_id"] or util.rev_id(),
 #essage=command_args["message"],
 #pgrade_ops=ops.UpgradeOps([]),
 #owngrade_ops=ops.DowngradeOps([]),
 #ead=command_args["head"],
 #plice=command_args["splice"],
 #ranch_label=command_args["branch_label"],
 #ersion_path=command_args["version_path"],
 #epends_on=command_args["depends_on"],
 #
 #eturn op

 #ef generate_scripts(self) -> Iterator[Optional[Script]]:
 #or generated_revision in self.generated_revisions:
 #ield self._to_script(generated_revision)
