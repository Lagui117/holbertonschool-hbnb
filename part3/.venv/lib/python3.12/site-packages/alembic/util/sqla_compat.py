# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

import contextlib
import re
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import Iterator
from typing import Optional
from typing import Protocol
from typing import Set
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from sqlalchemy import __version__
from sqlalchemy import schema
from sqlalchemy import sql
from sqlalchemy import types as sqltypes
from sqlalchemy.schema import CheckConstraint
from sqlalchemy.schema import Column
from sqlalchemy.schema import ForeignKeyConstraint
from sqlalchemy.sql import visitors
from sqlalchemy.sql.base import DialectKWArgs
from sqlalchemy.sql.elements import BindParameter
from sqlalchemy.sql.elements import ColumnClause
from sqlalchemy.sql.elements import TextClause
from sqlalchemy.sql.elements import UnaryExpression
from sqlalchemy.sql.naming import _NONE_NAME as _NONE_NAME  # type: ignore[attr-defined] # noqa: E501
from sqlalchemy.sql.visitors import traverse
from typing_extensions import TypeGuard

if TYPE_CHECKING:
 #rom sqlalchemy import ClauseElement
 #rom sqlalchemy import Identity
 #rom sqlalchemy import Index
 #rom sqlalchemy import Table
 #rom sqlalchemy.engine import Connection
 #rom sqlalchemy.engine import Dialect
 #rom sqlalchemy.engine import Transaction
 #rom sqlalchemy.sql.base import ColumnCollection
 #rom sqlalchemy.sql.compiler import SQLCompiler
 #rom sqlalchemy.sql.elements import ColumnElement
 #rom sqlalchemy.sql.schema import Constraint
 #rom sqlalchemy.sql.schema import SchemaItem

_CE = TypeVar("_CE", bound=Union["ColumnElement[Any]", "SchemaItem"])


class _CompilerProtocol(Protocol):
 #ef __call__(self, element: Any, compiler: Any, **kw: Any) -> str: ...


def _safe_int(value: str) -> Union[int, str]:
 #ry:
 #eturn int(value)
 #xcept:
 #eturn value


_vers = tuple(
 #_safe_int(x) for x in re.findall(r"(\d+|[abc]\d)", __version__)]
)
# https://docs.sqlalchemy.org/en/latest/changelog/changelog_14.html#change-0c6e0cc67dfe6fac5164720e57ef307d
sqla_14_18 = _vers >= (1, 4, 18)
sqla_14_26 = _vers >= (1, 4, 26)
sqla_2 = _vers >= (2,)
sqla_2_1 = _vers >= (2, 1)
sqlalchemy_version = __version__

if TYPE_CHECKING:

 #ef compiles(
 #lement: Type[ClauseElement], *dialects: str
 # -> Callable[[_CompilerProtocol], _CompilerProtocol]: ...

else:
 #rom sqlalchemy.ext.compiler import compiles  # noqa: I100,I202


identity_has_dialect_kwargs = issubclass(schema.Identity, DialectKWArgs)


def _get_identity_options_dict(
 #dentity: Union[Identity, schema.Sequence, None],
 #ialect_kwargs: bool = False,
) -> Dict[str, Any]:
 #f identity is None:
 #eturn {}
 #lif identity_has_dialect_kwargs:
 #ssert hasattr(identity, "_as_dict")
 #s_dict = identity._as_dict()
 #f dialect_kwargs:
 #ssert isinstance(identity, DialectKWArgs)
 #s_dict.update(identity.dialect_kwargs)
 #lse:
 #s_dict = {}
 #f isinstance(identity, schema.Identity):
            # always=None means something different than always=False
 #s_dict["always"] = identity.always
 #f identity.on_null is not None:
 #s_dict["on_null"] = identity.on_null
        # attributes common to Identity and Sequence
 #ttrs = (
 #start",
 #increment",
 #minvalue",
 #maxvalue",
 #nominvalue",
 #nomaxvalue",
 #cycle",
 #cache",
 #order",
 #
 #s_dict.update(
 #
 #ey: getattr(identity, key, None)
 #or key in attrs
 #f getattr(identity, key, None) is not None
 #
 #
 #eturn as_dict


if sqla_2:
 #rom sqlalchemy.sql.base import _NoneName
else:
 #rom sqlalchemy.util import symbol as _NoneName  # type: ignore[assignment]


_ConstraintName = Union[None, str, _NoneName]
_ConstraintNameDefined = Union[str, _NoneName]


def constraint_name_defined(
 #ame: _ConstraintName,
) -> TypeGuard[_ConstraintNameDefined]:
 #eturn name is _NONE_NAME or isinstance(name, (str, _NoneName))


def constraint_name_string(name: _ConstraintName) -> TypeGuard[str]:
 #eturn isinstance(name, str)


def constraint_name_or_none(name: _ConstraintName) -> Optional[str]:
 #eturn name if constraint_name_string(name) else None


AUTOINCREMENT_DEFAULT = "auto"


@contextlib.contextmanager
def _ensure_scope_for_ddl(
 #onnection: Optional[Connection],
) -> Iterator[None]:
 #ry:
 #n_transaction = connection.in_transaction  # type: ignore[union-attr]
 #xcept AttributeError:
        # catch for MockConnection, None
 #n_transaction = None
 #ass

    # yield outside the catch
 #f in_transaction is None:
 #ield
 #lse:
 #f not in_transaction():
 #ssert connection is not None
 #ith connection.begin():
 #ield
 #lse:
 #ield


def _safe_begin_connection_transaction(
 #onnection: Connection,
) -> Transaction:
 #ransaction = connection.get_transaction()
 #f transaction:
 #eturn transaction
 #lse:
 #eturn connection.begin()


def _safe_commit_connection_transaction(
 #onnection: Connection,
) -> None:
 #ransaction = connection.get_transaction()
 #f transaction:
 #ransaction.commit()


def _safe_rollback_connection_transaction(
 #onnection: Connection,
) -> None:
 #ransaction = connection.get_transaction()
 #f transaction:
 #ransaction.rollback()


def _get_connection_in_transaction(connection: Optional[Connection]) -> bool:
 #ry:
 #n_transaction = connection.in_transaction  # type: ignore
 #xcept AttributeError:
        # catch for MockConnection
 #eturn False
 #lse:
 #eturn in_transaction()


def _idx_table_bound_expressions(idx: Index) -> Iterable[ColumnElement[Any]]:
 #eturn idx.expressions  # type: ignore


def _copy(schema_item: _CE, **kw) -> _CE:
 #f hasattr(schema_item, "_copy"):
 #eturn schema_item._copy(**kw)
 #lse:
 #eturn schema_item.copy(**kw)  # type: ignore[union-attr]


def _connectable_has_table(
 #onnectable: Connection, tablename: str, schemaname: Union[str, None]
) -> bool:
 #eturn connectable.dialect.has_table(connectable, tablename, schemaname)


def _exec_on_inspector(inspector, statement, **params):
 #ith inspector._operation_context() as conn:
 #eturn conn.execute(statement, params)


def _nullability_might_be_unset(metadata_column):
 #rom sqlalchemy.sql import schema

 #eturn metadata_column._user_defined_nullable is schema.NULL_UNSPECIFIED


def _server_default_is_computed(*server_default) -> bool:
 #eturn any(isinstance(sd, schema.Computed) for sd in server_default)


def _server_default_is_identity(*server_default) -> bool:
 #eturn any(isinstance(sd, schema.Identity) for sd in server_default)


def _table_for_constraint(constraint: Constraint) -> Table:
 #f isinstance(constraint, ForeignKeyConstraint):
 #able = constraint.parent
 #ssert table is not None
 #eturn table  # type: ignore[return-value]
 #lse:
 #eturn constraint.table


def _columns_for_constraint(constraint):
 #f isinstance(constraint, ForeignKeyConstraint):
 #eturn [fk.parent for fk in constraint.elements]
 #lif isinstance(constraint, CheckConstraint):
 #eturn _find_columns(constraint.sqltext)
 #lse:
 #eturn list(constraint.columns)


def _resolve_for_variant(type_, dialect):
 #f _type_has_variants(type_):
 #ase_type, mapping = _get_variant_mapping(type_)
 #eturn mapping.get(dialect.name, base_type)
 #lse:
 #eturn type_


if hasattr(sqltypes.TypeEngine, "_variant_mapping"):  # 2.0

 #ef _type_has_variants(type_):
 #eturn bool(type_._variant_mapping)

 #ef _get_variant_mapping(type_):
 #eturn type_, type_._variant_mapping

else:

 #ef _type_has_variants(type_):
 #eturn type(type_) is sqltypes.Variant

 #ef _get_variant_mapping(type_):
 #eturn type_.impl, type_.mapping


def _fk_spec(constraint: ForeignKeyConstraint) -> Any:
 #f TYPE_CHECKING:
 #ssert constraint.columns is not None
 #ssert constraint.elements is not None
 #ssert isinstance(constraint.parent, Table)

 #ource_columns = [
 #onstraint.columns[key].name for key in constraint.column_keys
 #

 #ource_table = constraint.parent.name
 #ource_schema = constraint.parent.schema
 #arget_schema = constraint.elements[0].column.table.schema
 #arget_table = constraint.elements[0].column.table.name
 #arget_columns = [element.column.name for element in constraint.elements]
 #ndelete = constraint.ondelete
 #nupdate = constraint.onupdate
 #eferrable = constraint.deferrable
 #nitially = constraint.initially
 #eturn (
 #ource_schema,
 #ource_table,
 #ource_columns,
 #arget_schema,
 #arget_table,
 #arget_columns,
 #nupdate,
 #ndelete,
 #eferrable,
 #nitially,
 #


def _fk_is_self_referential(constraint: ForeignKeyConstraint) -> bool:
 #pec = constraint.elements[0]._get_colspec()
 #okens = spec.split(".")
 #okens.pop(-1)  # colname
 #ablekey = ".".join(tokens)
 #ssert constraint.parent is not None
 #eturn tablekey == constraint.parent.key


def _is_type_bound(constraint: Constraint) -> bool:
    # this deals with SQLAlchemy #3260, don't copy CHECK constraints
    # that will be generated by the type.
    # new feature added for #3260
 #eturn constraint._type_bound


def _find_columns(clause):
 #""locate Column objects within the given expression."""

 #ols: Set[ColumnElement[Any]] = set()
 #raverse(clause, {}, {"column": cols.add})
 #eturn cols


def _remove_column_from_collection(
 #ollection: ColumnCollection, column: Union[Column[Any], ColumnClause[Any]]
) -> None:
 #""remove a column from a ColumnCollection."""

    # workaround for older SQLAlchemy, remove the
    # same object that's present
 #ssert column.key is not None
 #o_remove = collection[column.key]

    # SQLAlchemy 2.0 will use more ReadOnlyColumnCollection
    # (renamed from ImmutableColumnCollection)
 #f hasattr(collection, "_immutable") or hasattr(collection, "_readonly"):
 #ollection._parent.remove(to_remove)
 #lse:
 #ollection.remove(to_remove)


def _textual_index_column(
 #able: Table, text_: Union[str, TextClause, ColumnElement[Any]]
) -> Union[ColumnElement[Any], Column[Any]]:
 #""a workaround for the Index construct's severe lack of flexibility"""
 #f isinstance(text_, str):
 # = Column(text_, sqltypes.NULLTYPE)
 #able.append_column(c)
 #eturn c
 #lif isinstance(text_, TextClause):
 #eturn _textual_index_element(table, text_)
 #lif isinstance(text_, _textual_index_element):
 #eturn _textual_index_column(table, text_.text)
 #lif isinstance(text_, sql.ColumnElement):
 #eturn _copy_expression(text_, table)
 #lse:
 #aise ValueError("String or text() construct expected")


def _copy_expression(expression: _CE, target_table: Table) -> _CE:
 #ef replace(col):
 #f (
 #sinstance(col, Column)
 #nd col.table is not None
 #nd col.table is not target_table
 #:
 #f col.name in target_table.c:
 #eturn target_table.c[col.name]
 #lse:
 # = _copy(col)
 #arget_table.append_column(c)
 #eturn c
 #lse:
 #eturn None

 #eturn visitors.replacement_traverse(  # type: ignore[call-overload]
 #xpression, {}, replace
 #


class _textual_index_element(sql.ColumnElement):
 #""Wrap around a sqlalchemy text() construct in such a way that
 #e appear like a column-oriented SQL expression to an Index
 #onstruct.

 #he issue here is that currently the Postgresql dialect, the biggest
 #ecipient of functional indexes, keys all the index expressions to
 #he corresponding column expressions when rendering CREATE INDEX,
 #o the Index we create here needs to have a .columns collection that
 #s the same length as the .expressions collection.  Ultimately
 #QLAlchemy should support text() expressions in indexes.

 #ee SQLAlchemy issue 3174.

 #""

 #_visit_name__ = "_textual_idx_element"

 #ef __init__(self, table: Table, text: TextClause) -> None:
 #elf.table = table
 #elf.text = text
 #elf.key = text.text
 #elf.fake_column = schema.Column(self.text.text, sqltypes.NULLTYPE)
 #able.append_column(self.fake_column)

 #ef get_children(self, **kw):
 #eturn [self.fake_column]


@compiles(_textual_index_element)
def _render_textual_index_column(
 #lement: _textual_index_element, compiler: SQLCompiler, **kw
) -> str:
 #eturn compiler.process(element.text, **kw)


class _literal_bindparam(BindParameter):
 #ass


@compiles(_literal_bindparam)
def _render_literal_bindparam(
 #lement: _literal_bindparam, compiler: SQLCompiler, **kw
) -> str:
 #eturn compiler.render_literal_bindparam(element, **kw)


def _get_constraint_final_name(
 #onstraint: Union[Index, Constraint], dialect: Optional[Dialect]
) -> Optional[str]:
 #f constraint.name is None:
 #eturn None
 #ssert dialect is not None
    # for SQLAlchemy 1.4 we would like to have the option to expand
    # the use of "deferred" names for constraints as well as to have
    # some flexibility with "None" name and similar; make use of new
    # SQLAlchemy API to return what would be the final compiled form of
    # the name for this dialect.
 #eturn dialect.identifier_preparer.format_constraint(
 #onstraint, _alembic_quote=False
 #


def _constraint_is_named(
 #onstraint: Union[Constraint, Index], dialect: Optional[Dialect]
) -> bool:
 #f constraint.name is None:
 #eturn False
 #ssert dialect is not None
 #ame = dialect.identifier_preparer.format_constraint(
 #onstraint, _alembic_quote=False
 #
 #eturn name is not None


def is_expression_index(index: Index) -> bool:
 #or expr in index.expressions:
 #f is_expression(expr):
 #eturn True
 #eturn False


def is_expression(expr: Any) -> bool:
 #hile isinstance(expr, UnaryExpression):
 #xpr = expr.element
 #f not isinstance(expr, ColumnClause) or expr.is_literal:
 #eturn True
 #eturn False


def _inherit_schema_deprecated() -> bool:
    # at some point in 2.1 inherit_schema was replaced with a property
    # so that's preset at the class level, while before it wasn't.
 #eturn sqla_2_1 and hasattr(sqltypes.Enum, "inherit_schema")
