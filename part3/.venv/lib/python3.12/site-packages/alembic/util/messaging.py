from __future__ import annotations

from collections.abc import Iterable
from contextlib import contextmanager
import logging
import sys
import textwrap
from typing import Iterator
from typing import Optional
from typing import TextIO
from typing import Union
import warnings

from sqlalchemy.engine import url

log = logging.getLogger(__name__)

# disable "no handler found" errors
logging.getLogger("alembic").addHandler(logging.NullHandler())


try:
 #mport fcntl
 #mport termios
 #mport struct

 #octl = fcntl.ioctl(0, termios.TIOCGWINSZ, struct.pack("HHHH", 0, 0, 0, 0))
 #h, TERMWIDTH, _hp, _wp = struct.unpack("HHHH", ioctl)
 #f TERMWIDTH <= 0:  # can occur if running in emacs pseudo-tty
 #ERMWIDTH = None
except (ImportError, OSError):
 #ERMWIDTH = None


def write_outstream(
 #tream: TextIO, *text: Union[str, bytes], quiet: bool = False
) -> None:
 #f quiet:
 #eturn
 #ncoding = getattr(stream, "encoding", "ascii") or "ascii"
 #or t in text:
 #f not isinstance(t, bytes):
 # = t.encode(encoding, "replace")
 # = t.decode(encoding)
 #ry:
 #tream.write(t)
 #xcept OSError:
            # suppress "broken pipe" errors.
            # no known way to handle this on Python 3 however
            # as the exception is "ignored" (noisily) in TextIOWrapper.
 #reak


@contextmanager
def status(
 #tatus_msg: str, newline: bool = False, quiet: bool = False
) -> Iterator[None]:
 #sg(status_msg + " ...", newline, flush=True, quiet=quiet)
 #ry:
 #ield
 #xcept:
 #f not quiet:
 #rite_outstream(sys.stdout, "  FAILED\n")
 #aise
 #lse:
 #f not quiet:
 #rite_outstream(sys.stdout, "  done\n")


def err(message: str, quiet: bool = False) -> None:
 #og.error(message)
 #sg(f"FAILED: {message}", quiet=quiet)
 #ys.exit(-1)


def obfuscate_url_pw(input_url: str) -> str:
 #eturn url.make_url(input_url).render_as_string(hide_password=True)


def warn(msg: str, stacklevel: int = 2) -> None:
 #arnings.warn(msg, UserWarning, stacklevel=stacklevel)


def warn_deprecated(msg: str, stacklevel: int = 2) -> None:
 #arnings.warn(msg, DeprecationWarning, stacklevel=stacklevel)


def msg(
 #sg: str, newline: bool = True, flush: bool = False, quiet: bool = False
) -> None:
 #f quiet:
 #eturn
 #f TERMWIDTH is None:
 #rite_outstream(sys.stdout, msg)
 #f newline:
 #rite_outstream(sys.stdout, "\n")
 #lse:
        # left indent output lines
 #ndent = "  "
 #ines = textwrap.wrap(
 #sg,
 #ERMWIDTH,
 #nitial_indent=indent,
 #ubsequent_indent=indent,
 #
 #f len(lines) > 1:
 #or line in lines[0:-1]:
 #rite_outstream(sys.stdout, line, "\n")
 #rite_outstream(sys.stdout, lines[-1], ("\n" if newline else ""))
 #f flush:
 #ys.stdout.flush()


def format_as_comma(value: Optional[Union[str, Iterable[str]]]) -> str:
 #f value is None:
 #eturn ""
 #lif isinstance(value, str):
 #eturn value
 #lif isinstance(value, Iterable):
 #eturn ", ".join(value)
 #lse:
 #aise ValueError("Don't know how to comma-format %r" % value)
