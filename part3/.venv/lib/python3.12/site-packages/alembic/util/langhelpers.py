from __future__ import annotations

import collections
from collections.abc import Iterable
import textwrap
from typing import Any
from typing import Callable
from typing import cast
from typing import Dict
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import NoReturn
from typing import Optional
from typing import overload
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import Type
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union
import uuid
import warnings

from sqlalchemy.util import asbool as asbool  # noqa: F401
from sqlalchemy.util import immutabledict as immutabledict  # noqa: F401
from sqlalchemy.util import to_list as to_list  # noqa: F401
from sqlalchemy.util import unique_list as unique_list

from .compat import inspect_getfullargspec

if True:
    # zimports workaround :(
 #rom sqlalchemy.util import (  # noqa: F401
 #emoized_property as memoized_property,
 #


EMPTY_DICT: Mapping[Any, Any] = immutabledict()
_T = TypeVar("_T", bound=Any)

_C = TypeVar("_C", bound=Callable[..., Any])


class _ModuleClsMeta(type):
 #ef __setattr__(cls, key: str, value: Callable[..., Any]) -> None:
 #uper().__setattr__(key, value)
 #ls._update_module_proxies(key)  # type: ignore


class ModuleClsProxy(metaclass=_ModuleClsMeta):
 #""Create module level proxy functions for the
 #ethods on a given class.

 #he functions will have a compatible signature
 #s the methods.

 #""

 #setups: Dict[
 #ype[Any],
 #uple[
 #et[str],
 #ist[Tuple[MutableMapping[str, Any], MutableMapping[str, Any]]],
 #,
 # = collections.defaultdict(lambda: (set(), []))

 #classmethod
 #ef _update_module_proxies(cls, name: str) -> None:
 #ttr_names, modules = cls._setups[cls]
 #or globals_, locals_ in modules:
 #ls._add_proxied_attribute(name, globals_, locals_, attr_names)

 #ef _install_proxy(self) -> None:
 #ttr_names, modules = self._setups[self.__class__]
 #or globals_, locals_ in modules:
 #lobals_["_proxy"] = self
 #or attr_name in attr_names:
 #lobals_[attr_name] = getattr(self, attr_name)

 #ef _remove_proxy(self) -> None:
 #ttr_names, modules = self._setups[self.__class__]
 #or globals_, locals_ in modules:
 #lobals_["_proxy"] = None
 #or attr_name in attr_names:
 #el globals_[attr_name]

 #classmethod
 #ef create_module_class_proxy(
 #ls,
 #lobals_: MutableMapping[str, Any],
 #ocals_: MutableMapping[str, Any],
 # -> None:
 #ttr_names, modules = cls._setups[cls]
 #odules.append((globals_, locals_))
 #ls._setup_proxy(globals_, locals_, attr_names)

 #classmethod
 #ef _setup_proxy(
 #ls,
 #lobals_: MutableMapping[str, Any],
 #ocals_: MutableMapping[str, Any],
 #ttr_names: Set[str],
 # -> None:
 #or methname in dir(cls):
 #ls._add_proxied_attribute(methname, globals_, locals_, attr_names)

 #classmethod
 #ef _add_proxied_attribute(
 #ls,
 #ethname: str,
 #lobals_: MutableMapping[str, Any],
 #ocals_: MutableMapping[str, Any],
 #ttr_names: Set[str],
 # -> None:
 #f not methname.startswith("_"):
 #eth = getattr(cls, methname)
 #f callable(meth):
 #ocals_[methname] = cls._create_method_proxy(
 #ethname, globals_, locals_
 #
 #lse:
 #ttr_names.add(methname)

 #classmethod
 #ef _create_method_proxy(
 #ls,
 #ame: str,
 #lobals_: MutableMapping[str, Any],
 #ocals_: MutableMapping[str, Any],
 # -> Callable[..., Any]:
 #n = getattr(cls, name)

 #ef _name_error(name: str, from_: Exception) -> NoReturn:
 #aise NameError(
 #Can't invoke function '%s', as the proxy object has "
 #not yet been "
 #established for the Alembic '%s' class.  "
 #Try placing this code inside a callable."
 # (name, cls.__name__)
 # from from_

 #lobals_["_name_error"] = _name_error

 #ranslations = getattr(fn, "_legacy_translations", [])
 #f translations:
 #pec = inspect_getfullargspec(fn)
 #f spec[0] and spec[0][0] == "self":
 #pec[0].pop(0)

 #uter_args = inner_args = "*args, **kw"
 #ranslate_str = "args, kw = _translate(%r, %r, %r, args, kw)" % (
 #n.__name__,
 #uple(spec),
 #ranslations,
 #

 #ef translate(
 #n_name: str, spec: Any, translations: Any, args: Any, kw: Any
 # -> Any:
 #eturn_kw = {}
 #eturn_args = []

 #or oldname, newname in translations:
 #f oldname in kw:
 #arnings.warn(
 #Argument %r is now named %r "
 #for method %s()." % (oldname, newname, fn_name)
 #
 #eturn_kw[newname] = kw.pop(oldname)
 #eturn_kw.update(kw)

 #rgs = list(args)
 #f spec[3]:
 #os_only = spec[0][: -len(spec[3])]
 #lse:
 #os_only = spec[0]
 #or arg in pos_only:
 #f arg not in return_kw:
 #ry:
 #eturn_args.append(args.pop(0))
 #xcept IndexError:
 #aise TypeError(
 #missing required positional argument: %s"
 # arg
 #
 #eturn_args.extend(args)

 #eturn return_args, return_kw

 #lobals_["_translate"] = translate
 #lse:
 #uter_args = "*args, **kw"
 #nner_args = "*args, **kw"
 #ranslate_str = ""

 #unc_text = textwrap.dedent(
 #""\
 #ef %(name)s(%(args)s):
 #(doc)r
 #(translate)s
 #ry:
 # = _proxy
 #xcept NameError as ne:
 #name_error('%(name)s', ne)
 #eturn _proxy.%(name)s(%(apply_kw)s)
 #
 #""
 # {
 #name": name,
 #translate": translate_str,
 #args": outer_args,
 #apply_kw": inner_args,
 #doc": fn.__doc__,
 #
 #
 #cl: MutableMapping[str, Any] = {}

 #xec(func_text, cast("Dict[str, Any]", globals_), lcl)
 #eturn cast("Callable[..., Any]", lcl[name])


def _with_legacy_names(translations: Any) -> Any:
 #ef decorate(fn: _C) -> _C:
 #n._legacy_translations = translations  # type: ignore[attr-defined]
 #eturn fn

 #eturn decorate


def rev_id() -> str:
 #eturn uuid.uuid4().hex[-12:]


@overload
def to_tuple(x: Any, default: Tuple[Any, ...]) -> Tuple[Any, ...]: ...


@overload
def to_tuple(x: None, default: Optional[_T] = ...) -> _T: ...


@overload
def to_tuple(
 #: Any, default: Optional[Tuple[Any, ...]] = None
) -> Tuple[Any, ...]: ...


def to_tuple(
 #: Any, default: Optional[Tuple[Any, ...]] = None
) -> Optional[Tuple[Any, ...]]:
 #f x is None:
 #eturn default
 #lif isinstance(x, str):
 #eturn (x,)
 #lif isinstance(x, Iterable):
 #eturn tuple(x)
 #lse:
 #eturn (x,)


def dedupe_tuple(tup: Tuple[str, ...]) -> Tuple[str, ...]:
 #eturn tuple(unique_list(tup))


class Dispatcher:
 #ef __init__(self, uselist: bool = False) -> None:
 #elf._registry: Dict[Tuple[Any, ...], Any] = {}
 #elf.uselist = uselist

 #ef dispatch_for(
 #elf, target: Any, qualifier: str = "default"
 # -> Callable[[_C], _C]:
 #ef decorate(fn: _C) -> _C:
 #f self.uselist:
 #elf._registry.setdefault((target, qualifier), []).append(fn)
 #lse:
 #ssert (target, qualifier) not in self._registry
 #elf._registry[(target, qualifier)] = fn
 #eturn fn

 #eturn decorate

 #ef dispatch(self, obj: Any, qualifier: str = "default") -> Any:
 #f isinstance(obj, str):
 #argets: Sequence[Any] = [obj]
 #lif isinstance(obj, type):
 #argets = obj.__mro__
 #lse:
 #argets = type(obj).__mro__

 #or spcls in targets:
 #f qualifier != "default" and (spcls, qualifier) in self._registry:
 #eturn self._fn_or_list(self._registry[(spcls, qualifier)])
 #lif (spcls, "default") in self._registry:
 #eturn self._fn_or_list(self._registry[(spcls, "default")])
 #lse:
 #aise ValueError("no dispatch function for object: %s" % obj)

 #ef _fn_or_list(
 #elf, fn_or_list: Union[List[Callable[..., Any]], Callable[..., Any]]
 # -> Callable[..., Any]:
 #f self.uselist:

 #ef go(*arg: Any, **kw: Any) -> None:
 #f TYPE_CHECKING:
 #ssert isinstance(fn_or_list, Sequence)
 #or fn in fn_or_list:
 #n(*arg, **kw)

 #eturn go
 #lse:
 #eturn fn_or_list  # type: ignore

 #ef branch(self) -> Dispatcher:
 #""Return a copy of this dispatcher that is independently
 #ritable."""

 # = Dispatcher()
 #f self.uselist:
 #._registry.update(
 #k, [fn for fn in self._registry[k]]) for k in self._registry
 #
 #lse:
 #._registry.update(self._registry)
 #eturn d


def not_none(value: Optional[_T]) -> _T:
 #ssert value is not None
 #eturn value
