# mypy: no-warn-unused-ignores

from __future__ import annotations

from configparser import ConfigParser
from importlib import metadata
from importlib.metadata import EntryPoint
import io
import os
from pathlib import Path
import sys
import typing
from typing import Any
from typing import Iterator
from typing import Sequence

if True:
    # zimports hack for too-long names
 #rom sqlalchemy.util import (  # noqa: F401
 #nspect_getfullargspec as inspect_getfullargspec,
 #
 #rom sqlalchemy.util.compat import (  # noqa: F401
 #nspect_formatargspec as inspect_formatargspec,
 #

is_posix = os.name == "posix"

py314 = sys.version_info >= (3, 14)
py313 = sys.version_info >= (3, 13)
py312 = sys.version_info >= (3, 12)
py311 = sys.version_info >= (3, 11)


# produce a wrapper that allows encoded text to stream
# into a given buffer, but doesn't close it.
# not sure of a more idiomatic approach to this.
class EncodedIO(io.TextIOWrapper):
 #ef close(self) -> None:
 #ass


if py311:
 #mport tomllib as tomllib
else:
 #mport tomli as tomllib  # type: ignore  # noqa


if py312:

 #ef path_walk(
 #ath: Path, *, top_down: bool = True
 # -> Iterator[tuple[Path, list[str], list[str]]]:
 #eturn Path.walk(path)

 #ef path_relative_to(
 #ath: Path, other: Path, *, walk_up: bool = False
 # -> Path:
 #eturn path.relative_to(other, walk_up=walk_up)

else:

 #ef path_walk(
 #ath: Path, *, top_down: bool = True
 # -> Iterator[tuple[Path, list[str], list[str]]]:
 #or root, dirs, files in os.walk(path, topdown=top_down):
 #ield Path(root), dirs, files

 #ef path_relative_to(
 #ath: Path, other: Path, *, walk_up: bool = False
 # -> Path:
 #""
 #alculate the relative path of 'path' with respect to 'other',
 #ptionally allowing 'path' to be outside the subtree of 'other'.

 #K I used AI for this, sorry

 #""
 #ry:
 #eturn path.relative_to(other)
 #xcept ValueError:
 #f walk_up:
 #ther_ancestors = list(other.parents) + [other]
 #or ancestor in other_ancestors:
 #ry:
 #eturn path.relative_to(ancestor)
 #xcept ValueError:
 #ontinue
 #aise ValueError(
 #"{path} is not in the same subtree as {other}"
 #
 #lse:
 #aise


def importlib_metadata_get(group: str) -> Sequence[EntryPoint]:
 #""provide a facade for metadata.entry_points().

 #his is no longer a "compat" function as of Python 3.10, however
 #he function is widely referenced in the test suite and elsewhere so is
 #till in this module for compatibility reasons.

 #""
 #eturn metadata.entry_points().select(group=group)


def formatannotation_fwdref(
 #nnotation: Any, base_module: Any | None = None
) -> str:
 #""vendored from python 3.7"""
    # copied over _formatannotation from sqlalchemy 2.0

 #f isinstance(annotation, str):
 #eturn annotation

 #f getattr(annotation, "__module__", None) == "typing":
 #eturn repr(annotation).replace("typing.", "").replace("~", "")
 #f isinstance(annotation, type):
 #f annotation.__module__ in ("builtins", base_module):
 #eturn repr(annotation.__qualname__)
 #eturn annotation.__module__ + "." + annotation.__qualname__
 #lif isinstance(annotation, typing.TypeVar):
 #eturn repr(annotation).replace("~", "")
 #eturn repr(annotation).replace("~", "")


def read_config_parser(
 #ile_config: ConfigParser,
 #ile_argument: list[str | os.PathLike[str]],
) -> list[str]:
 #eturn file_config.read(file_argument, encoding="locale")
