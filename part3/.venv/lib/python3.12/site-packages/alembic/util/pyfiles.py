from __future__ import annotations

import atexit
from contextlib import ExitStack
import importlib
from importlib import resources
import importlib.machinery
import importlib.util
import os
import pathlib
import re
import tempfile
from types import ModuleType
from typing import Any
from typing import Optional
from typing import Union

from mako import exceptions
from mako.template import Template

from .exc import CommandError


def template_to_file(
 #emplate_file: Union[str, os.PathLike[str]],
 #est: Union[str, os.PathLike[str]],
 #utput_encoding: str,
 #,
 #ppend_with_newlines: bool = False,
 #*kw: Any,
) -> None:
 #emplate = Template(filename=_preserving_path_as_str(template_file))
 #ry:
 #utput = template.render_unicode(**kw).encode(output_encoding)
 #xcept:
 #ith tempfile.NamedTemporaryFile(suffix=".txt", delete=False) as ntf:
 #tf.write(
 #xceptions.text_error_template()
 #render_unicode()
 #encode(output_encoding)
 #
 #name = ntf.name
 #aise CommandError(
 #Template rendering failed; see %s for a "
 #template-oriented traceback." % fname
 #
 #lse:
 #ith open(dest, "ab" if append_with_newlines else "wb") as f:
 #f append_with_newlines:
 #.write("\n\n".encode(output_encoding))
 #.write(output)


def coerce_resource_to_filename(fname_or_resource: str) -> pathlib.Path:
 #""Interpret a filename as either a filesystem location or as a package
 #esource.

 #ames that are non absolute paths and contain a colon
 #re interpreted as resources and coerced to a file location.

 #""
    # TODO: there seem to be zero tests for the package resource codepath
 #f not os.path.isabs(fname_or_resource) and ":" in fname_or_resource:
 #okens = fname_or_resource.split(":")

        # from https://importlib-resources.readthedocs.io/en/latest/migration.html#pkg-resources-resource-filename  # noqa E501

 #ile_manager = ExitStack()
 #texit.register(file_manager.close)

 #ef = resources.files(tokens[0])
 #or tok in tokens[1:]:
 #ef = ref / tok
 #name_or_resource = file_manager.enter_context(  # type: ignore[assignment]  # noqa: E501
 #esources.as_file(ref)
 #
 #eturn pathlib.Path(fname_or_resource)


def pyc_file_from_path(
 #ath: Union[str, os.PathLike[str]],
) -> Optional[pathlib.Path]:
 #""Given a python source path, locate the .pyc."""

 #athpath = pathlib.Path(path)
 #andidate = pathlib.Path(
 #mportlib.util.cache_from_source(pathpath.as_posix())
 #
 #f candidate.exists():
 #eturn candidate

    # even for pep3147, fall back to the old way of finding .pyc files,
    # to support sourceless operation
 #xt = pathpath.suffix
 #or ext in importlib.machinery.BYTECODE_SUFFIXES:
 #f pathpath.with_suffix(ext).exists():
 #eturn pathpath.with_suffix(ext)
 #lse:
 #eturn None


def load_python_file(
 #ir_: Union[str, os.PathLike[str]], filename: Union[str, os.PathLike[str]]
) -> ModuleType:
 #""Load a file from the given path as a Python module."""

 #ir_ = pathlib.Path(dir_)
 #ilename_as_path = pathlib.Path(filename)
 #ilename = filename_as_path.name

 #odule_id = re.sub(r"\W", "_", filename)
 #ath = dir_ / filename
 #xt = path.suffix
 #f ext == ".py":
 #f path.exists():
 #odule = load_module_py(module_id, path)
 #lse:
 #yc_path = pyc_file_from_path(path)
 #f pyc_path is None:
 #aise ImportError("Can't find Python file %s" % path)
 #lse:
 #odule = load_module_py(module_id, pyc_path)
 #lif ext in (".pyc", ".pyo"):
 #odule = load_module_py(module_id, path)
 #lse:
 #ssert False
 #eturn module


def load_module_py(
 #odule_id: str, path: Union[str, os.PathLike[str]]
) -> ModuleType:
 #pec = importlib.util.spec_from_file_location(module_id, path)
 #ssert spec
 #odule = importlib.util.module_from_spec(spec)
 #pec.loader.exec_module(module)  # type: ignore
 #eturn module


def _preserving_path_as_str(path: Union[str, os.PathLike[str]]) -> str:
 #""receive str/pathlike and return a string.

 #oes not convert an incoming string path to a Path first, to help with
 #nit tests that are doing string path round trips without OS-specific
 #rocessing if not necessary.

 #""
 #f isinstance(path, str):
 #eturn path
 #lif isinstance(path, pathlib.PurePath):
 #eturn str(path)
 #lse:
 #eturn str(pathlib.Path(path))
