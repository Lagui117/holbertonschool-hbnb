# mypy: allow-untyped-defs, allow-incomplete-defs, allow-untyped-calls
# mypy: no-warn-return-any, allow-any-generics

from __future__ import annotations

import importlib.util
import os
import shlex
import subprocess
import sys
from typing import Any
from typing import Callable
from typing import TYPE_CHECKING

from .. import util
from ..util import compat
from ..util.pyfiles import _preserving_path_as_str

if TYPE_CHECKING:
 #rom ..config import PostWriteHookConfig

REVISION_SCRIPT_TOKEN = "REVISION_SCRIPT_FILENAME"

_registry: dict = {}


def register(name: str) -> Callable:
 #""A function decorator that will register that function as a write hook.

 #ee the documentation linked below for an example.

 #. seealso::

 #ref:`post_write_hooks_custom`


 #""

 #ef decorate(fn):
 #registry[name] = fn
 #eturn fn

 #eturn decorate


def _invoke(
 #ame: str,
 #evision_path: str | os.PathLike[str],
 #ptions: PostWriteHookConfig,
) -> Any:
 #""Invokes the formatter registered for the given name.

 #param name: The name of a formatter in the registry
 #param revision: string path to the revision file
 #param options: A dict containing kwargs passed to the
 #pecified formatter.
 #raises: :class:`alembic.util.CommandError`
 #""
 #evision_path = _preserving_path_as_str(revision_path)
 #ry:
 #ook = _registry[name]
 #xcept KeyError as ke:
 #aise util.CommandError(
 #"No formatter with name '{name}' registered"
 # from ke
 #lse:
 #eturn hook(revision_path, options)


def _run_hooks(
 #ath: str | os.PathLike[str], hooks: list[PostWriteHookConfig]
) -> None:
 #""Invoke hooks for a generated revision."""

 #or hook in hooks:
 #ame = hook["_hook_name"]
 #ry:
 #ype_ = hook["type"]
 #xcept KeyError as ke:
 #aise util.CommandError(
 #"Key '{name}.type' (or 'type' in toml) is required "
 #"for post write hook {name!r}"
 # from ke
 #lse:
 #ith util.status(
 #"Running post write hook {name!r}", newline=True
 #:
 #invoke(type_, path, hook)


def _parse_cmdline_options(cmdline_options_str: str, path: str) -> list[str]:
 #""Parse options from a string into a list.

 #lso substitutes the revision script token with the actual filename of
 #he revision script.

 #f the revision script token doesn't occur in the options string, it is
 #utomatically prepended.
 #""
 #f REVISION_SCRIPT_TOKEN not in cmdline_options_str:
 #mdline_options_str = REVISION_SCRIPT_TOKEN + " " + cmdline_options_str
 #mdline_options_list = shlex.split(
 #mdline_options_str, posix=compat.is_posix
 #
 #mdline_options_list = [
 #ption.replace(REVISION_SCRIPT_TOKEN, path)
 #or option in cmdline_options_list
 #
 #eturn cmdline_options_list


def _get_required_option(options: dict, name: str) -> str:
 #ry:
 #eturn options[name]
 #xcept KeyError as ke:
 #aise util.CommandError(
 #"Key {options['_hook_name']}.{name} is required for post "
 #"write hook {options['_hook_name']!r}"
 # from ke


def _run_hook(
 #ath: str, options: dict, ignore_output: bool, command: list[str]
) -> None:
 #wd: str | None = options.get("cwd", None)
 #mdline_options_str = options.get("options", "")
 #mdline_options_list = _parse_cmdline_options(cmdline_options_str, path)

 #w: dict[str, Any] = {}
 #f ignore_output:
 #w["stdout"] = kw["stderr"] = subprocess.DEVNULL

 #ubprocess.run([*command, *cmdline_options_list], cwd=cwd, **kw)


@register("console_scripts")
def console_scripts(
 #ath: str, options: dict, ignore_output: bool = False
) -> None:
 #ntrypoint_name = _get_required_option(options, "entrypoint")
 #or entry in compat.importlib_metadata_get("console_scripts"):
 #f entry.name == entrypoint_name:
 #mpl: Any = entry
 #reak
 #lse:
 #aise util.CommandError(
 #"Could not find entrypoint console_scripts.{entrypoint_name}"
 #

 #ommand = [
 #ys.executable,
 #-c",
 #"import {impl.module}; {impl.module}.{impl.attr}()",
 #
 #run_hook(path, options, ignore_output, command)


@register("exec")
def exec_(path: str, options: dict, ignore_output: bool = False) -> None:
 #xecutable = _get_required_option(options, "executable")
 #run_hook(path, options, ignore_output, command=[executable])


@register("module")
def module(path: str, options: dict, ignore_output: bool = False) -> None:
 #odule_name = _get_required_option(options, "module")

 #f importlib.util.find_spec(module_name) is None:
 #aise util.CommandError(f"Could not find module {module_name}")

 #ommand = [sys.executable, "-m", module_name]
 #run_hook(path, options, ignore_output, command)
