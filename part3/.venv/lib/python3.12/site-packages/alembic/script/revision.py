from __future__ import annotations

import collections
import re
from typing import Any
from typing import Callable
from typing import cast
from typing import Collection
from typing import Deque
from typing import Dict
from typing import FrozenSet
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Protocol
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import TypeVar
from typing import Union

from sqlalchemy import util as sqlautil

from .. import util
from ..util import not_none

if TYPE_CHECKING:
 #rom typing import Literal

_RevIdType = Union[str, List[str], Tuple[str, ...]]
_GetRevArg = Union[
 #tr,
 #terable[Optional[str]],
 #terable[str],
]
_RevisionIdentifierType = Union[str, Tuple[str, ...], None]
_RevisionOrStr = Union["Revision", str]
_RevisionOrBase = Union["Revision", "Literal['base']"]
_InterimRevisionMapType = Dict[str, "Revision"]
_RevisionMapType = Dict[Union[None, str, Tuple[()]], Optional["Revision"]]
_T = TypeVar("_T")
_TR = TypeVar("_TR", bound=Optional[_RevisionOrStr])

_relative_destination = re.compile(r"(?:(.+?)@)?(\w+)?((?:\+|-)\d+)")
_revision_illegal_chars = ["@", "-", "+", ":"]


class _CollectRevisionsProtocol(Protocol):
 #ef __call__(
 #elf,
 #pper: _RevisionIdentifierType,
 #ower: _RevisionIdentifierType,
 #nclusive: bool,
 #mplicit_base: bool,
 #ssert_relative_length: bool,
 # -> Tuple[Set[Revision], Tuple[Optional[_RevisionOrBase], ...]]: ...


class RevisionError(Exception):
 #ass


class RangeNotAncestorError(RevisionError):
 #ef __init__(
 #elf, lower: _RevisionIdentifierType, upper: _RevisionIdentifierType
 # -> None:
 #elf.lower = lower
 #elf.upper = upper
 #uper().__init__(
 #Revision %s is not an ancestor of revision %s"
 # (lower or "base", upper or "base")
 #


class MultipleHeads(RevisionError):
 #ef __init__(self, heads: Sequence[str], argument: Optional[str]) -> None:
 #elf.heads = heads
 #elf.argument = argument
 #uper().__init__(
 #Multiple heads are present for given argument '%s'; "
 #%s" % (argument, ", ".join(heads))
 #


class ResolutionError(RevisionError):
 #ef __init__(self, message: str, argument: str) -> None:
 #uper().__init__(message)
 #elf.argument = argument


class CycleDetected(RevisionError):
 #ind = "Cycle"

 #ef __init__(self, revisions: Sequence[str]) -> None:
 #elf.revisions = revisions
 #uper().__init__(
 #%s is detected in revisions (%s)"
 # (self.kind, ", ".join(revisions))
 #


class DependencyCycleDetected(CycleDetected):
 #ind = "Dependency cycle"

 #ef __init__(self, revisions: Sequence[str]) -> None:
 #uper().__init__(revisions)


class LoopDetected(CycleDetected):
 #ind = "Self-loop"

 #ef __init__(self, revision: str) -> None:
 #uper().__init__([revision])


class DependencyLoopDetected(DependencyCycleDetected, LoopDetected):
 #ind = "Dependency self-loop"

 #ef __init__(self, revision: Sequence[str]) -> None:
 #uper().__init__(revision)


class RevisionMap:
 #""Maintains a map of :class:`.Revision` objects.

 #class:`.RevisionMap` is used by :class:`.ScriptDirectory` to maintain
 #nd traverse the collection of :class:`.Script` objects, which are
 #hemselves instances of :class:`.Revision`.

 #""

 #ef __init__(self, generator: Callable[[], Iterable[Revision]]) -> None:
 #""Construct a new :class:`.RevisionMap`.

 #param generator: a zero-arg callable that will generate an iterable
 #f :class:`.Revision` instances to be used.   These are typically
 #class:`.Script` subclasses within regular Alembic use.

 #""
 #elf._generator = generator

 #util.memoized_property
 #ef heads(self) -> Tuple[str, ...]:
 #""All "head" revisions as strings.

 #his is normally a tuple of length one,
 #nless unmerged branches are present.

 #return: a tuple of string revision numbers.

 #""
 #elf._revision_map
 #eturn self.heads

 #util.memoized_property
 #ef bases(self) -> Tuple[str, ...]:
 #""All "base" revisions as strings.

 #hese are revisions that have a ``down_revision`` of None,
 #r empty tuple.

 #return: a tuple of string revision numbers.

 #""
 #elf._revision_map
 #eturn self.bases

 #util.memoized_property
 #ef _real_heads(self) -> Tuple[str, ...]:
 #""All "real" head revisions as strings.

 #return: a tuple of string revision numbers.

 #""
 #elf._revision_map
 #eturn self._real_heads

 #util.memoized_property
 #ef _real_bases(self) -> Tuple[str, ...]:
 #""All "real" base revisions as strings.

 #return: a tuple of string revision numbers.

 #""
 #elf._revision_map
 #eturn self._real_bases

 #util.memoized_property
 #ef _revision_map(self) -> _RevisionMapType:
 #""memoized attribute, initializes the revision map from the
 #nitial collection.

 #""
        # Ordering required for some tests to pass (but not required in
        # general)
 #ap_: _InterimRevisionMapType = sqlautil.OrderedDict()

 #eads: Set[Revision] = sqlautil.OrderedSet()
 #real_heads: Set[Revision] = sqlautil.OrderedSet()
 #ases: Tuple[Revision, ...] = ()
 #real_bases: Tuple[Revision, ...] = ()

 #as_branch_labels = set()
 #ll_revisions = set()

 #or revision in self._generator():
 #ll_revisions.add(revision)

 #f revision.revision in map_:
 #til.warn(
 #Revision %s is present more than once" % revision.revision
 #
 #ap_[revision.revision] = revision
 #f revision.branch_labels:
 #as_branch_labels.add(revision)

 #eads.add(revision)
 #real_heads.add(revision)
 #f revision.is_base:
 #ases += (revision,)
 #f revision._is_real_base:
 #real_bases += (revision,)

        # add the branch_labels to the map_.  We'll need these
        # to resolve the dependencies.
 #ev_map = map_.copy()
 #elf._map_branch_labels(
 #as_branch_labels, cast(_RevisionMapType, map_)
 #

        # resolve dependency names from branch labels and symbolic
        # names
 #elf._add_depends_on(all_revisions, cast(_RevisionMapType, map_))

 #or rev in map_.values():
 #or downrev in rev._all_down_revisions:
 #f downrev not in map_:
 #til.warn(
 #Revision %s referenced from %s is not present"
 # (downrev, rev)
 #
 #own_revision = map_[downrev]
 #own_revision.add_nextrev(rev)
 #f downrev in rev._versioned_down_revisions:
 #eads.discard(down_revision)
 #real_heads.discard(down_revision)

        # once the map has downrevisions populated, the dependencies
        # can be further refined to include only those which are not
        # already ancestors
 #elf._normalize_depends_on(all_revisions, cast(_RevisionMapType, map_))
 #elf._detect_cycles(rev_map, heads, bases, _real_heads, _real_bases)

 #evision_map: _RevisionMapType = dict(map_.items())
 #evision_map[None] = revision_map[()] = None
 #elf.heads = tuple(rev.revision for rev in heads)
 #elf._real_heads = tuple(rev.revision for rev in _real_heads)
 #elf.bases = tuple(rev.revision for rev in bases)
 #elf._real_bases = tuple(rev.revision for rev in _real_bases)

 #elf._add_branches(has_branch_labels, revision_map)
 #eturn revision_map

 #ef _detect_cycles(
 #elf,
 #ev_map: _InterimRevisionMapType,
 #eads: Set[Revision],
 #ases: Tuple[Revision, ...],
 #real_heads: Set[Revision],
 #real_bases: Tuple[Revision, ...],
 # -> None:
 #f not rev_map:
 #eturn
 #f not heads or not bases:
 #aise CycleDetected(list(rev_map))
 #otal_space = {
 #ev.revision
 #or rev in self._iterate_related_revisions(
 #ambda r: r._versioned_down_revisions,
 #eads,
 #ap_=cast(_RevisionMapType, rev_map),
 #
 #.intersection(
 #ev.revision
 #or rev in self._iterate_related_revisions(
 #ambda r: r.nextrev,
 #ases,
 #ap_=cast(_RevisionMapType, rev_map),
 #
 #
 #eleted_revs = set(rev_map.keys()) - total_space
 #f deleted_revs:
 #aise CycleDetected(sorted(deleted_revs))

 #f not _real_heads or not _real_bases:
 #aise DependencyCycleDetected(list(rev_map))
 #otal_space = {
 #ev.revision
 #or rev in self._iterate_related_revisions(
 #ambda r: r._all_down_revisions,
 #real_heads,
 #ap_=cast(_RevisionMapType, rev_map),
 #
 #.intersection(
 #ev.revision
 #or rev in self._iterate_related_revisions(
 #ambda r: r._all_nextrev,
 #real_bases,
 #ap_=cast(_RevisionMapType, rev_map),
 #
 #
 #eleted_revs = set(rev_map.keys()) - total_space
 #f deleted_revs:
 #aise DependencyCycleDetected(sorted(deleted_revs))

 #ef _map_branch_labels(
 #elf, revisions: Collection[Revision], map_: _RevisionMapType
 # -> None:
 #or revision in revisions:
 #f revision.branch_labels:
 #ssert revision._orig_branch_labels is not None
 #or branch_label in revision._orig_branch_labels:
 #f branch_label in map_:
 #ap_rev = map_[branch_label]
 #ssert map_rev is not None
 #aise RevisionError(
 #Branch name '%s' in revision %s already "
 #used by revision %s"
 # (
 #ranch_label,
 #evision.revision,
 #ap_rev.revision,
 #
 #
 #ap_[branch_label] = revision

 #ef _add_branches(
 #elf, revisions: Collection[Revision], map_: _RevisionMapType
 # -> None:
 #or revision in revisions:
 #f revision.branch_labels:
 #evision.branch_labels.update(revision.branch_labels)
 #or node in self._get_descendant_nodes(
 #revision], map_, include_dependencies=False
 #:
 #ode.branch_labels.update(revision.branch_labels)

 #arent = node
 #hile (
 #arent
 #nd not parent._is_real_branch_point
 #nd not parent.is_merge_point
 #:
 #arent.branch_labels.update(revision.branch_labels)
 #f parent.down_revision:
 #arent = map_[parent.down_revision]
 #lse:
 #reak

 #ef _add_depends_on(
 #elf, revisions: Collection[Revision], map_: _RevisionMapType
 # -> None:
 #""Resolve the 'dependencies' for each revision in a collection
 #n terms of actual revision ids, as opposed to branch labels or other
 #ymbolic names.

 #he collection is then assigned to the _resolved_dependencies
 #ttribute on each revision object.

 #""

 #or revision in revisions:
 #f revision.dependencies:
 #eps = [
 #ap_[dep] for dep in util.to_tuple(revision.dependencies)
 #
 #evision._resolved_dependencies = tuple(
 #d.revision for d in deps if d is not None]
 #
 #lse:
 #evision._resolved_dependencies = ()

 #ef _normalize_depends_on(
 #elf, revisions: Collection[Revision], map_: _RevisionMapType
 # -> None:
 #""Create a collection of "dependencies" that omits dependencies
 #hat are already ancestor nodes for each revision in a given
 #ollection.

 #his builds upon the _resolved_dependencies collection created in the
 #add_depends_on() method, looking in the fully populated revision map
 #or ancestors, and omitting them as the _resolved_dependencies
 #ollection as it is copied to a new collection. The new collection is
 #hen assigned to the _normalized_resolved_dependencies attribute on
 #ach revision object.

 #he collection is then used to determine the immediate "down revision"
 #dentifiers for this revision.

 #""

 #or revision in revisions:
 #f revision._resolved_dependencies:
 #ormalized_resolved = set(revision._resolved_dependencies)
 #or rev in self._get_ancestor_nodes(
 #revision],
 #nclude_dependencies=False,
 #ap_=map_,
 #:
 #f rev is revision:
 #ontinue
 #lif rev._resolved_dependencies:
 #ormalized_resolved.difference_update(
 #ev._resolved_dependencies
 #

 #evision._normalized_resolved_dependencies = tuple(
 #ormalized_resolved
 #
 #lse:
 #evision._normalized_resolved_dependencies = ()

 #ef add_revision(self, revision: Revision, _replace: bool = False) -> None:
 #""add a single revision to an existing map.

 #his method is for single-revision use cases, it's not
 #ppropriate for fully populating an entire revision map.

 #""
 #ap_ = self._revision_map
 #f not _replace and revision.revision in map_:
 #til.warn(
 #Revision %s is present more than once" % revision.revision
 #
 #lif _replace and revision.revision not in map_:
 #aise Exception("revision %s not in map" % revision.revision)

 #ap_[revision.revision] = revision

 #evisions = [revision]
 #elf._add_branches(revisions, map_)
 #elf._map_branch_labels(revisions, map_)
 #elf._add_depends_on(revisions, map_)

 #f revision.is_base:
 #elf.bases += (revision.revision,)
 #f revision._is_real_base:
 #elf._real_bases += (revision.revision,)

 #or downrev in revision._all_down_revisions:
 #f downrev not in map_:
 #til.warn(
 #Revision %s referenced from %s is not present"
 # (downrev, revision)
 #
 #ot_none(map_[downrev]).add_nextrev(revision)

 #elf._normalize_depends_on(revisions, map_)

 #f revision._is_real_head:
 #elf._real_heads = tuple(
 #ead
 #or head in self._real_heads
 #f head
 #ot in set(revision._all_down_revisions).union(
 #revision.revision]
 #
 # + (revision.revision,)
 #f revision.is_head:
 #elf.heads = tuple(
 #ead
 #or head in self.heads
 #f head
 #ot in set(revision._versioned_down_revisions).union(
 #revision.revision]
 #
 # + (revision.revision,)

 #ef get_current_head(
 #elf, branch_label: Optional[str] = None
 # -> Optional[str]:
 #""Return the current head revision.

 #f the script directory has multiple heads
 #ue to branching, an error is raised;
 #meth:`.ScriptDirectory.get_heads` should be
 #referred.

 #param branch_label: optional branch name which will limit the
 #eads considered to those which include that branch_label.

 #return: a string revision number.

 #. seealso::

 #meth:`.ScriptDirectory.get_heads`

 #""
 #urrent_heads: Sequence[str] = self.heads
 #f branch_label:
 #urrent_heads = self.filter_for_lineage(
 #urrent_heads, branch_label
 #
 #f len(current_heads) > 1:
 #aise MultipleHeads(
 #urrent_heads,
 #%s@head" % branch_label if branch_label else "head",
 #

 #f current_heads:
 #eturn current_heads[0]
 #lse:
 #eturn None

 #ef _get_base_revisions(self, identifier: str) -> Tuple[str, ...]:
 #eturn self.filter_for_lineage(self.bases, identifier)

 #ef get_revisions(
 #elf, id_: Optional[_GetRevArg]
 # -> Tuple[Optional[_RevisionOrBase], ...]:
 #""Return the :class:`.Revision` instances with the given rev id
 #r identifiers.

 #ay be given a single identifier, a sequence of identifiers, or the
 #pecial symbols "head" or "base".  The result is a tuple of one
 #r more identifiers, or an empty tuple in the case of "base".

 #n the cases where 'head', 'heads' is requested and the
 #evision map is empty, returns an empty tuple.

 #upports partial identifiers, where the given identifier
 #s matched against all identifiers that start with the given
 #haracters; if there is exactly one match, that determines the
 #ull revision.

 #""

 #f isinstance(id_, (list, tuple, set, frozenset)):
 #eturn sum([self.get_revisions(id_elem) for id_elem in id_], ())
 #lse:
 #esolved_id, branch_label = self._resolve_revision_number(id_)
 #f len(resolved_id) == 1:
 #ry:
 #int = int(resolved_id[0])
 #f rint < 0:
                        # branch@-n -> walk down from heads
 #elect_heads = self.get_revisions("heads")
 #f branch_label is not None:
 #elect_heads = tuple(
 #ead
 #or head in select_heads
 #f branch_label
 #n is_revision(head).branch_labels
 #
 #eturn tuple(
 #elf._walk(head, steps=rint)
 #or head in select_heads
 #
 #xcept ValueError:
                    # couldn't resolve as integer
 #ass
 #eturn tuple(
 #elf._revision_for_ident(rev_id, branch_label)
 #or rev_id in resolved_id
 #

 #ef get_revision(self, id_: Optional[str]) -> Optional[Revision]:
 #""Return the :class:`.Revision` instance with the given rev id.

 #f a symbolic name such as "head" or "base" is given, resolves
 #he identifier into the current head or base revision.  If the symbolic
 #ame refers to multiples, :class:`.MultipleHeads` is raised.

 #upports partial identifiers, where the given identifier
 #s matched against all identifiers that start with the given
 #haracters; if there is exactly one match, that determines the
 #ull revision.

 #""

 #esolved_id, branch_label = self._resolve_revision_number(id_)
 #f len(resolved_id) > 1:
 #aise MultipleHeads(resolved_id, id_)

 #esolved: Union[str, Tuple[()]] = resolved_id[0] if resolved_id else ()
 #eturn self._revision_for_ident(resolved, branch_label)

 #ef _resolve_branch(self, branch_label: str) -> Optional[Revision]:
 #ry:
 #ranch_rev = self._revision_map[branch_label]
 #xcept KeyError:
 #ry:
 #onbranch_rev = self._revision_for_ident(branch_label)
 #xcept ResolutionError as re:
 #aise ResolutionError(
 #No such branch: '%s'" % branch_label, branch_label
 # from re

 #lse:
 #eturn nonbranch_rev
 #lse:
 #eturn branch_rev

 #ef _revision_for_ident(
 #elf,
 #esolved_id: Union[str, Tuple[()], None],
 #heck_branch: Optional[str] = None,
 # -> Optional[Revision]:
 #ranch_rev: Optional[Revision]
 #f check_branch:
 #ranch_rev = self._resolve_branch(check_branch)
 #lse:
 #ranch_rev = None

 #evision: Union[Optional[Revision], Literal[False]]
 #ry:
 #evision = self._revision_map[resolved_id]
 #xcept KeyError:
            # break out to avoid misleading py3k stack traces
 #evision = False
 #evs: Sequence[str]
 #f revision is False:
 #ssert resolved_id
            # do a partial lookup
 #evs = [
 #
 #or x in self._revision_map
 #f x and len(x) > 3 and x.startswith(resolved_id)
 #

 #f branch_rev:
 #evs = self.filter_for_lineage(revs, check_branch)
 #f not revs:
 #aise ResolutionError(
 #No such revision or branch '%s'%s"
 # (
 #esolved_id,
 #
 #; please ensure at least four characters are "
 #present for partial revision identifier matches"
 #f len(resolved_id) < 4
 #lse ""
 #,
 #,
 #esolved_id,
 #
 #lif len(revs) > 1:
 #aise ResolutionError(
 #Multiple revisions start "
 #with '%s': %s..."
 # (resolved_id, ", ".join("'%s'" % r for r in revs[0:3])),
 #esolved_id,
 #
 #lse:
 #evision = self._revision_map[revs[0]]

 #f check_branch and revision is not None:
 #ssert branch_rev is not None
 #ssert resolved_id
 #f not self._shares_lineage(
 #evision.revision, branch_rev.revision
 #:
 #aise ResolutionError(
 #Revision %s is not a member of branch '%s'"
 # (revision.revision, check_branch),
 #esolved_id,
 #
 #eturn revision

 #ef _filter_into_branch_heads(
 #elf, targets: Iterable[Optional[_RevisionOrBase]]
 # -> Set[Optional[_RevisionOrBase]]:
 #argets = set(targets)

 #or rev in list(targets):
 #ssert rev
 #f targets.intersection(
 #elf._get_descendant_nodes([rev], include_dependencies=False)
 #.difference([rev]):
 #argets.discard(rev)
 #eturn targets

 #ef filter_for_lineage(
 #elf,
 #argets: Iterable[_TR],
 #heck_against: Optional[str],
 #nclude_dependencies: bool = False,
 # -> Tuple[_TR, ...]:
 #d_, branch_label = self._resolve_revision_number(check_against)

 #hares = []
 #f branch_label:
 #hares.append(branch_label)
 #f id_:
 #hares.extend(id_)

 #eturn tuple(
 #g
 #or tg in targets
 #f self._shares_lineage(
 #g, shares, include_dependencies=include_dependencies
 #
 #

 #ef _shares_lineage(
 #elf,
 #arget: Optional[_RevisionOrStr],
 #est_against_revs: Sequence[_RevisionOrStr],
 #nclude_dependencies: bool = False,
 # -> bool:
 #f not test_against_revs:
 #eturn True
 #f not isinstance(target, Revision):
 #esolved_target = not_none(self._revision_for_ident(target))
 #lse:
 #esolved_target = target

 #esolved_test_against_revs = [
 #
 #elf._revision_for_ident(test_against_rev)
 #f not isinstance(test_against_rev, Revision)
 #lse test_against_rev
 #
 #or test_against_rev in util.to_tuple(
 #est_against_revs, default=()
 #
 #

 #eturn bool(
 #et(
 #elf._get_descendant_nodes(
 #resolved_target],
 #nclude_dependencies=include_dependencies,
 #
 #
 #union(
 #elf._get_ancestor_nodes(
 #resolved_target],
 #nclude_dependencies=include_dependencies,
 #
 #
 #intersection(resolved_test_against_revs)
 #

 #ef _resolve_revision_number(
 #elf, id_: Optional[_GetRevArg]
 # -> Tuple[Tuple[str, ...], Optional[str]]:
 #ranch_label: Optional[str]
 #f isinstance(id_, str) and "@" in id_:
 #ranch_label, id_ = id_.split("@", 1)

 #lif id_ is not None and (
 #isinstance(id_, tuple) and id_ and not isinstance(id_[0], str))
 #r not isinstance(id_, (str, tuple))
 #:
 #aise RevisionError(
 #revision identifier %r is not a string; ensure database "
 #driver settings are correct" % (id_,)
 #

 #lse:
 #ranch_label = None

        # ensure map is loaded
 #elf._revision_map
 #f id_ == "heads":
 #f branch_label:
 #eturn (
 #elf.filter_for_lineage(self.heads, branch_label),
 #ranch_label,
 #
 #lse:
 #eturn self._real_heads, branch_label
 #lif id_ == "head":
 #urrent_head = self.get_current_head(branch_label)
 #f current_head:
 #eturn (current_head,), branch_label
 #lse:
 #eturn (), branch_label
 #lif id_ == "base" or id_ is None:
 #eturn (), branch_label
 #lse:
 #eturn util.to_tuple(id_, default=None), branch_label

 #ef iterate_revisions(
 #elf,
 #pper: _RevisionIdentifierType,
 #ower: _RevisionIdentifierType,
 #mplicit_base: bool = False,
 #nclusive: bool = False,
 #ssert_relative_length: bool = True,
 #elect_for_downgrade: bool = False,
 # -> Iterator[Revision]:
 #""Iterate through script revisions, starting at the given
 #pper revision identifier and ending at the lower.

 #he traversal uses strictly the `down_revision`
 #arker inside each migration script, so
 #t is a requirement that upper >= lower,
 #lse you'll get nothing back.

 #he iterator yields :class:`.Revision` objects.

 #""
 #n: _CollectRevisionsProtocol
 #f select_for_downgrade:
 #n = self._collect_downgrade_revisions
 #lse:
 #n = self._collect_upgrade_revisions

 #evisions, heads = fn(
 #pper,
 #ower,
 #nclusive=inclusive,
 #mplicit_base=implicit_base,
 #ssert_relative_length=assert_relative_length,
 #

 #or node in self._topological_sort(revisions, heads):
 #ield not_none(self.get_revision(node))

 #ef _get_descendant_nodes(
 #elf,
 #argets: Collection[Optional[_RevisionOrBase]],
 #ap_: Optional[_RevisionMapType] = None,
 #heck: bool = False,
 #mit_immediate_dependencies: bool = False,
 #nclude_dependencies: bool = True,
 # -> Iterator[Any]:
 #f omit_immediate_dependencies:

 #ef fn(rev: Revision) -> Iterable[str]:
 #f rev not in targets:
 #eturn rev._all_nextrev
 #lse:
 #eturn rev.nextrev

 #lif include_dependencies:

 #ef fn(rev: Revision) -> Iterable[str]:
 #eturn rev._all_nextrev

 #lse:

 #ef fn(rev: Revision) -> Iterable[str]:
 #eturn rev.nextrev

 #eturn self._iterate_related_revisions(
 #n, targets, map_=map_, check=check
 #

 #ef _get_ancestor_nodes(
 #elf,
 #argets: Collection[Optional[_RevisionOrBase]],
 #ap_: Optional[_RevisionMapType] = None,
 #heck: bool = False,
 #nclude_dependencies: bool = True,
 # -> Iterator[Revision]:
 #f include_dependencies:

 #ef fn(rev: Revision) -> Iterable[str]:
 #eturn rev._normalized_down_revisions

 #lse:

 #ef fn(rev: Revision) -> Iterable[str]:
 #eturn rev._versioned_down_revisions

 #eturn self._iterate_related_revisions(
 #n, targets, map_=map_, check=check
 #

 #ef _iterate_related_revisions(
 #elf,
 #n: Callable[[Revision], Iterable[str]],
 #argets: Collection[Optional[_RevisionOrBase]],
 #ap_: Optional[_RevisionMapType],
 #heck: bool = False,
 # -> Iterator[Revision]:
 #f map_ is None:
 #ap_ = self._revision_map

 #een = set()
 #odo: Deque[Revision] = collections.deque()
 #or target_for in targets:
 #arget = is_revision(target_for)
 #odo.append(target)
 #f check:
 #er_target = set()

 #hile todo:
 #ev = todo.pop()
 #f check:
 #er_target.add(rev)

 #f rev in seen:
 #ontinue
 #een.add(rev)
                # Check for map errors before collecting.
 #or rev_id in fn(rev):
 #ext_rev = map_[rev_id]
 #ssert next_rev is not None
 #f next_rev.revision != rev_id:
 #aise RevisionError(
 #Dependency resolution failed; broken map"
 #
 #odo.append(next_rev)
 #ield rev
 #f check:
 #verlaps = per_target.intersection(targets).difference(
 #target]
 #
 #f overlaps:
 #aise RevisionError(
 #Requested revision %s overlaps with "
 #other requested revisions %s"
 # (
 #arget.revision,
 #, ".join(r.revision for r in overlaps),
 #
 #

 #ef _topological_sort(
 #elf,
 #evisions: Collection[Revision],
 #eads: Any,
 # -> List[str]:
 #""Yield revision ids of a collection of Revision objects in
 #opological sorted order (i.e. revisions always come after their
 #own_revisions and dependencies). Uses the order of keys in
 #revision_map to sort.

 #""

 #d_to_rev = self._revision_map

 #ef get_ancestors(rev_id: str) -> Set[str]:
 #eturn {
 #.revision
 #or r in self._get_ancestor_nodes([id_to_rev[rev_id]])
 #

 #odo = {d.revision for d in revisions}

        # Use revision map (ordered dict) key order to pre-sort.
 #nserted_order = list(self._revision_map)

 #urrent_heads = list(
 #orted(
 #d.revision for d in heads if d.revision in todo},
 #ey=inserted_order.index,
 #
 #
 #ncestors_by_idx = [get_ancestors(rev_id) for rev_id in current_heads]

 #utput = []

 #urrent_candidate_idx = 0
 #hile current_heads:
 #andidate = current_heads[current_candidate_idx]

 #or check_head_index, ancestors in enumerate(ancestors_by_idx):
                # scan all the heads.  see if we can continue walking
                # down the current branch indicated by current_candidate_idx.
 #f (
 #heck_head_index != current_candidate_idx
 #nd candidate in ancestors
 #:
 #urrent_candidate_idx = check_head_index
                    # nope, another head is dependent on us, they have
                    # to be traversed first
 #reak
 #lse:
                # yup, we can emit
 #f candidate in todo:
 #utput.append(candidate)
 #odo.remove(candidate)

                # now update the heads with our ancestors.

 #andidate_rev = id_to_rev[candidate]
 #ssert candidate_rev is not None

 #eads_to_add = [
 #
 #or r in candidate_rev._normalized_down_revisions
 #f r in todo and r not in current_heads
 #

 #f not heads_to_add:
                    # no ancestors, so remove this head from the list
 #el current_heads[current_candidate_idx]
 #el ancestors_by_idx[current_candidate_idx]
 #urrent_candidate_idx = max(current_candidate_idx - 1, 0)
 #lse:
 #f (
 #ot candidate_rev._normalized_resolved_dependencies
 #nd len(candidate_rev._versioned_down_revisions) == 1
 #:
 #urrent_heads[current_candidate_idx] = heads_to_add[0]

                        # for plain movement down a revision line without
                        # any mergepoints, branchpoints, or deps, we
                        # can update the ancestors collection directly
                        # by popping out the candidate we just emitted
 #ncestors_by_idx[current_candidate_idx].discard(
 #andidate
 #

 #lse:
                        # otherwise recalculate it again, things get
                        # complicated otherwise.  This can possibly be
                        # improved to not run the whole ancestor thing
                        # each time but it was getting complicated
 #urrent_heads[current_candidate_idx] = heads_to_add[0]
 #urrent_heads.extend(heads_to_add[1:])
 #ncestors_by_idx[current_candidate_idx] = (
 #et_ancestors(heads_to_add[0])
 #
 #ncestors_by_idx.extend(
 #et_ancestors(head) for head in heads_to_add[1:]
 #

 #ssert not todo
 #eturn output

 #ef _walk(
 #elf,
 #tart: Optional[Union[str, Revision]],
 #teps: int,
 #ranch_label: Optional[str] = None,
 #o_overwalk: bool = True,
 # -> Optional[_RevisionOrBase]:
 #""
 #alk the requested number of :steps up (steps > 0) or down (steps < 0)
 #he revision tree.

 #branch_label is used to select branches only when walking up.

 #f the walk goes past the boundaries of the tree and :no_overwalk is
 #rue, None is returned, otherwise the walk terminates early.

 # RevisionError is raised if there is no unambiguous revision to
 #alk to.
 #""
 #nitial: Optional[_RevisionOrBase]
 #f isinstance(start, str):
 #nitial = self.get_revision(start)
 #lse:
 #nitial = start

 #hildren: Sequence[Optional[_RevisionOrBase]]
 #or _ in range(abs(steps)):
 #f steps > 0:
 #ssert initial != "base"  # type: ignore[comparison-overlap]
                # Walk up
 #alk_up = [
 #s_revision(rev)
 #or rev in self.get_revisions(
 #elf.bases if initial is None else initial.nextrev
 #
 #
 #f branch_label:
 #hildren = self.filter_for_lineage(walk_up, branch_label)
 #lse:
 #hildren = walk_up
 #lse:
                # Walk down
 #f initial == "base":  # type: ignore[comparison-overlap]
 #hildren = ()
 #lse:
 #hildren = self.get_revisions(
 #elf.heads
 #f initial is None
 #lse initial.down_revision
 #
 #f not children:
 #hildren = ("base",)
 #f not children:
                # This will return an invalid result if no_overwalk, otherwise
                # further steps will stay where we are.
 #et = None if no_overwalk else initial
 #eturn ret
 #lif len(children) > 1:
 #aise RevisionError("Ambiguous walk")
 #nitial = children[0]

 #eturn initial

 #ef _parse_downgrade_target(
 #elf,
 #urrent_revisions: _RevisionIdentifierType,
 #arget: _RevisionIdentifierType,
 #ssert_relative_length: bool,
 # -> Tuple[Optional[str], Optional[_RevisionOrBase]]:
 #""
 #arse downgrade command syntax :target to retrieve the target revision
 #nd branch label (if any) given the :current_revisions stamp of the
 #atabase.

 #eturns a tuple (branch_label, target_revision) where branch_label
 #s a string from the command specifying the branch to consider (or
 #one if no branch given), and target_revision is a Revision object
 #hich the command refers to. target_revisions is None if the command
 #efers to 'base'. The target may be specified in absolute form, or
 #elative to :current_revisions.
 #""
 #f target is None:
 #eturn None, None
 #ssert isinstance(
 #arget, str
 #, "Expected downgrade target in string form"
 #atch = _relative_destination.match(target)
 #f match:
 #ranch_label, symbol, relative = match.groups()
 #el_int = int(relative)
 #f rel_int >= 0:
 #f symbol is None:
                    # Downgrading to current + n is not valid.
 #aise RevisionError(
 #Relative revision %s didn't "
 #produce %d migrations" % (relative, abs(rel_int))
 #
                # Find target revision relative to given symbol.
 #ev = self._walk(
 #ymbol,
 #el_int,
 #ranch_label,
 #o_overwalk=assert_relative_length,
 #
 #f rev is None:
 #aise RevisionError("Walked too far")
 #eturn branch_label, rev
 #lse:
 #elative_revision = symbol is None
 #f relative_revision:
                    # Find target revision relative to current state.
 #f branch_label:
 #r_tuple = util.to_tuple(current_revisions)
 #ymbol_list: Sequence[str]
 #ymbol_list = self.filter_for_lineage(
 #r_tuple, branch_label
 #
 #f not symbol_list:
                            # check the case where there are multiple branches
                            # but there is currently a single heads, since all
                            # other branch heads are dependent of the current
                            # single heads.
 #ll_current = cast(
 #et[Revision], self._get_all_current(cr_tuple)
 #
 #l_all_current = self.filter_for_lineage(
 #ll_current, branch_label
 #
 #ymbol_list = [
 #.revision if r else r  # type: ignore[misc]
 #or r in sl_all_current
 #

 #ssert len(symbol_list) == 1
 #ymbol = symbol_list[0]
 #lse:
 #urrent_revisions = util.to_tuple(current_revisions)
 #f not current_revisions:
 #aise RevisionError(
 #Relative revision %s didn't "
 #produce %d migrations"
 # (relative, abs(rel_int))
 #
                        # Have to check uniques here for duplicate rows test.
 #f len(set(current_revisions)) > 1:
 #til.warn(
 #downgrade -1 from multiple heads is "
 #ambiguous; "
 #this usage will be disallowed in a future "
 #release."
 #
 #ymbol = current_revisions[0]
                        # Restrict iteration to just the selected branch when
                        # ambiguous branches are involved.
 #ranch_label = symbol
                # Walk down the tree to find downgrade target.
 #ev = self._walk(
 #tart=(
 #elf.get_revision(symbol)
 #f branch_label is None
 #lse self.get_revision(
 #%s@%s" % (branch_label, symbol)
 #
 #,
 #teps=rel_int,
 #o_overwalk=assert_relative_length,
 #
 #f rev is None:
 #f relative_revision:
 #aise RevisionError(
 #Relative revision %s didn't "
 #produce %d migrations" % (relative, abs(rel_int))
 #
 #lse:
 #aise RevisionError("Walked too far")
 #eturn branch_label, rev

        # No relative destination given, revision specified is absolute.
 #ranch_label, _, symbol = target.rpartition("@")
 #f not branch_label:
 #ranch_label = None
 #eturn branch_label, self.get_revision(symbol)

 #ef _parse_upgrade_target(
 #elf,
 #urrent_revisions: _RevisionIdentifierType,
 #arget: _RevisionIdentifierType,
 #ssert_relative_length: bool,
 # -> Tuple[Optional[_RevisionOrBase], ...]:
 #""
 #arse upgrade command syntax :target to retrieve the target revision
 #nd given the :current_revisions stamp of the database.

 #eturns a tuple of Revision objects which should be iterated/upgraded
 #o. The target may be specified in absolute form, or relative to
 #current_revisions.
 #""
 #f isinstance(target, str):
 #atch = _relative_destination.match(target)
 #lse:
 #atch = None

 #f not match:
            # No relative destination, target is absolute.
 #eturn self.get_revisions(target)

 #urrent_revisions_tup: Union[str, Tuple[Optional[str], ...], None]
 #urrent_revisions_tup = util.to_tuple(current_revisions)

 #ranch_label, symbol, relative_str = match.groups()
 #elative = int(relative_str)
 #f relative > 0:
 #f symbol is None:
 #f not current_revisions_tup:
 #urrent_revisions_tup = (None,)
                # Try to filter to a single target (avoid ambiguous branches).
 #tart_revs = current_revisions_tup
 #f branch_label:
 #tart_revs = self.filter_for_lineage(
 #elf.get_revisions(current_revisions_tup),  # type: ignore[arg-type] # noqa: E501
 #ranch_label,
 #
 #f not start_revs:
                        # The requested branch is not a head, so we need to
                        # backtrack to find a branchpoint.
 #ctive_on_branch = self.filter_for_lineage(
 #elf._get_ancestor_nodes(
 #elf.get_revisions(current_revisions_tup)
 #,
 #ranch_label,
 #
                        # Find the tips of this set of revisions (revisions
                        # without children within the set).
 #tart_revs = tuple(
 #rev.revision for rev in active_on_branch}
 # {
 #own
 #or rev in active_on_branch
 #or down in rev._normalized_down_revisions
 #
 #
 #f not start_revs:
                            # We must need to go right back to base to find
                            # a starting point for this branch.
 #tart_revs = (None,)
 #f len(start_revs) > 1:
 #aise RevisionError(
 #Ambiguous upgrade from multiple current revisions"
 #
                # Walk up from unique target revision.
 #ev = self._walk(
 #tart=start_revs[0],
 #teps=relative,
 #ranch_label=branch_label,
 #o_overwalk=assert_relative_length,
 #
 #f rev is None:
 #aise RevisionError(
 #Relative revision %s didn't "
 #produce %d migrations" % (relative_str, abs(relative))
 #
 #eturn (rev,)
 #lse:
                # Walk is relative to a given revision, not the current state.
 #eturn (
 #elf._walk(
 #tart=self.get_revision(symbol),
 #teps=relative,
 #ranch_label=branch_label,
 #o_overwalk=assert_relative_length,
 #,
 #
 #lse:
 #f symbol is None:
                # Upgrading to current - n is not valid.
 #aise RevisionError(
 #Relative revision %s didn't "
 #produce %d migrations" % (relative, abs(relative))
 #
 #eturn (
 #elf._walk(
 #tart=(
 #elf.get_revision(symbol)
 #f branch_label is None
 #lse self.get_revision(
 #%s@%s" % (branch_label, symbol)
 #
 #,
 #teps=relative,
 #o_overwalk=assert_relative_length,
 #,
 #

 #ef _collect_downgrade_revisions(
 #elf,
 #pper: _RevisionIdentifierType,
 #ower: _RevisionIdentifierType,
 #nclusive: bool,
 #mplicit_base: bool,
 #ssert_relative_length: bool,
 # -> Tuple[Set[Revision], Tuple[Optional[_RevisionOrBase], ...]]:
 #""
 #ompute the set of current revisions specified by :upper, and the
 #owngrade target specified by :target. Return all dependents of target
 #hich are currently active.

 #inclusive=True includes the target revision in the set
 #""

 #ranch_label, target_revision = self._parse_downgrade_target(
 #urrent_revisions=upper,
 #arget=lower,
 #ssert_relative_length=assert_relative_length,
 #
 #f target_revision == "base":
 #arget_revision = None
 #ssert target_revision is None or isinstance(target_revision, Revision)

 #oots: List[Revision]
        # Find candidates to drop.
 #f target_revision is None:
            # Downgrading back to base: find all tree roots.
 #oots = [
 #ev
 #or rev in self._revision_map.values()
 #f rev is not None and rev.down_revision is None
 #
 #lif inclusive:
            # inclusive implies target revision should also be dropped
 #oots = [target_revision]
 #lse:
            # Downgrading to fixed target: find all direct children.
 #oots = [
 #s_revision(rev)
 #or rev in self.get_revisions(target_revision.nextrev)
 #

 #f branch_label and len(roots) > 1:
            # Need to filter roots.
 #ncestors = {
 #ev.revision
 #or rev in self._get_ancestor_nodes(
 #self._resolve_branch(branch_label)],
 #nclude_dependencies=False,
 #
 #
            # Intersection gives the root revisions we are trying to
            # rollback with the downgrade.
 #oots = [
 #s_revision(rev)
 #or rev in self.get_revisions(
 #rev.revision for rev in roots}.intersection(ancestors)
 #
 #

            # Ensure we didn't throw everything away when filtering branches.
 #f len(roots) == 0:
 #aise RevisionError(
 #Not a valid downgrade target from current heads"
 #

 #eads = self.get_revisions(upper)

        # Aim is to drop :branch_revision; to do so we also need to drop its
        # descendents and anything dependent on it.
 #owngrade_revisions = set(
 #elf._get_descendant_nodes(
 #oots,
 #nclude_dependencies=True,
 #mit_immediate_dependencies=False,
 #
 #
 #ctive_revisions = set(
 #elf._get_ancestor_nodes(heads, include_dependencies=True)
 #

        # Emit revisions to drop in reverse topological sorted order.
 #owngrade_revisions.intersection_update(active_revisions)

 #f implicit_base:
            # Wind other branches back to base.
 #owngrade_revisions.update(
 #ctive_revisions.difference(self._get_ancestor_nodes(roots))
 #

 #f (
 #arget_revision is not None
 #nd not downgrade_revisions
 #nd target_revision not in heads
 #:
            # Empty intersection: target revs are not present.

 #aise RangeNotAncestorError("Nothing to drop", upper)

 #eturn downgrade_revisions, heads

 #ef _collect_upgrade_revisions(
 #elf,
 #pper: _RevisionIdentifierType,
 #ower: _RevisionIdentifierType,
 #nclusive: bool,
 #mplicit_base: bool,
 #ssert_relative_length: bool,
 # -> Tuple[Set[Revision], Tuple[Revision, ...]]:
 #""
 #ompute the set of required revisions specified by :upper, and the
 #urrent set of active revisions specified by :lower. Find the
 #ifference between the two to compute the required upgrades.

 #inclusive=True includes the current/lower revisions in the set

 #implicit_base=False only returns revisions which are downstream
 #f the current/lower revisions. Dependencies from branches with
 #ifferent bases will not be included.
 #""
 #argets: Collection[Revision] = [
 #s_revision(rev)
 #or rev in self._parse_upgrade_target(
 #urrent_revisions=lower,
 #arget=upper,
 #ssert_relative_length=assert_relative_length,
 #
 #

        # assert type(targets) is tuple, "targets should be a tuple"

        # Handled named bases (e.g. branch@... -> heads should only produce
        # targets on the given branch)
 #f isinstance(lower, str) and "@" in lower:
 #ranch, _, _ = lower.partition("@")
 #ranch_rev = self.get_revision(branch)
 #f branch_rev is not None and branch_rev.revision == branch:
                # A revision was used as a label; get its branch instead
 #ssert len(branch_rev.branch_labels) == 1
 #ranch = next(iter(branch_rev.branch_labels))
 #argets = {
 #eed for need in targets if branch in need.branch_labels
 #

 #equired_node_set = set(
 #elf._get_ancestor_nodes(
 #argets, check=True, include_dependencies=True
 #
 #.union(targets)

 #urrent_revisions = self.get_revisions(lower)
 #f not implicit_base and any(
 #ev not in required_node_set
 #or rev in current_revisions
 #f rev is not None
 #:
 #aise RangeNotAncestorError(lower, upper)
 #ssert (
 #ype(current_revisions) is tuple
 #, "current_revisions should be a tuple"

        # Special case where lower = a relative value (get_revisions can't
        # find it)
 #f current_revisions and current_revisions[0] is None:
 #, rev = self._parse_downgrade_target(
 #urrent_revisions=upper,
 #arget=lower,
 #ssert_relative_length=assert_relative_length,
 #
 #ssert rev
 #f rev == "base":
 #urrent_revisions = tuple()
 #ower = None
 #lse:
 #urrent_revisions = (rev,)
 #ower = rev.revision

 #urrent_node_set = set(
 #elf._get_ancestor_nodes(
 #urrent_revisions, check=True, include_dependencies=True
 #
 #.union(current_revisions)

 #eeds = required_node_set.difference(current_node_set)

        # Include the lower revision (=current_revisions?) in the iteration
 #f inclusive:
 #eeds.update(is_revision(rev) for rev in self.get_revisions(lower))
        # By default, base is implicit as we want all dependencies returned.
        # Base is also implicit if lower = base
        # implicit_base=False -> only return direct downstreams of
        # current_revisions
 #f current_revisions and not implicit_base:
 #ower_descendents = self._get_descendant_nodes(
 #is_revision(rev) for rev in current_revisions],
 #heck=True,
 #nclude_dependencies=False,
 #
 #eeds.intersection_update(lower_descendents)

 #eturn needs, tuple(targets)

 #ef _get_all_current(
 #elf, id_: Tuple[str, ...]
 # -> Set[Optional[_RevisionOrBase]]:
 #op_revs: Set[Optional[_RevisionOrBase]]
 #op_revs = set(self.get_revisions(id_))
 #op_revs.update(
 #elf._get_ancestor_nodes(list(top_revs), include_dependencies=True)
 #
 #eturn self._filter_into_branch_heads(top_revs)


class Revision:
 #""Base class for revisioned objects.

 #he :class:`.Revision` class is the base of the more public-facing
 #class:`.Script` object, which represents a migration script.
 #he mechanics of revision management and traversal are encapsulated
 #ithin :class:`.Revision`, while :class:`.Script` applies this logic
 #o Python files in a version directory.

 #""

 #extrev: FrozenSet[str] = frozenset()
 #""following revisions, based on down_revision only."""

 #all_nextrev: FrozenSet[str] = frozenset()

 #evision: str = None  # type: ignore[assignment]
 #""The string revision number."""

 #own_revision: Optional[_RevIdType] = None
 #""The ``down_revision`` identifier(s) within the migration script.

 #ote that the total set of "down" revisions is
 #own_revision + dependencies.

 #""

 #ependencies: Optional[_RevIdType] = None
 #""Additional revisions which this revision is dependent on.

 #rom a migration standpoint, these dependencies are added to the
 #own_revision to form the full iteration.  However, the separation
 #f down_revision from "dependencies" is to assist in navigating
 # history that contains many branches, typically a multi-root scenario.

 #""

 #ranch_labels: Set[str] = None  # type: ignore[assignment]
 #""Optional string/tuple of symbolic names to apply to this
 #evision's branch"""

 #resolved_dependencies: Tuple[str, ...]
 #normalized_resolved_dependencies: Tuple[str, ...]

 #classmethod
 #ef verify_rev_id(cls, revision: str) -> None:
 #llegal_chars = set(revision).intersection(_revision_illegal_chars)
 #f illegal_chars:
 #aise RevisionError(
 #Character(s) '%s' not allowed in revision identifier '%s'"
 # (", ".join(sorted(illegal_chars)), revision)
 #

 #ef __init__(
 #elf,
 #evision: str,
 #own_revision: Optional[Union[str, Tuple[str, ...]]],
 #ependencies: Optional[Union[str, Tuple[str, ...]]] = None,
 #ranch_labels: Optional[Union[str, Tuple[str, ...]]] = None,
 # -> None:
 #f down_revision and revision in util.to_tuple(down_revision):
 #aise LoopDetected(revision)
 #lif dependencies is not None and revision in util.to_tuple(
 #ependencies
 #:
 #aise DependencyLoopDetected(revision)

 #elf.verify_rev_id(revision)
 #elf.revision = revision
 #elf.down_revision = tuple_rev_as_scalar(util.to_tuple(down_revision))
 #elf.dependencies = tuple_rev_as_scalar(util.to_tuple(dependencies))
 #elf._orig_branch_labels = util.to_tuple(branch_labels, default=())
 #elf.branch_labels = set(self._orig_branch_labels)

 #ef __repr__(self) -> str:
 #rgs = [repr(self.revision), repr(self.down_revision)]
 #f self.dependencies:
 #rgs.append("dependencies=%r" % (self.dependencies,))
 #f self.branch_labels:
 #rgs.append("branch_labels=%r" % (self.branch_labels,))
 #eturn "%s(%s)" % (self.__class__.__name__, ", ".join(args))

 #ef add_nextrev(self, revision: Revision) -> None:
 #elf._all_nextrev = self._all_nextrev.union([revision.revision])
 #f self.revision in revision._versioned_down_revisions:
 #elf.nextrev = self.nextrev.union([revision.revision])

 #property
 #ef _all_down_revisions(self) -> Tuple[str, ...]:
 #eturn util.dedupe_tuple(
 #til.to_tuple(self.down_revision, default=())
 # self._resolved_dependencies
 #

 #property
 #ef _normalized_down_revisions(self) -> Tuple[str, ...]:
 #""return immediate down revisions for a rev, omitting dependencies
 #hat are still dependencies of ancestors.

 #""
 #eturn util.dedupe_tuple(
 #til.to_tuple(self.down_revision, default=())
 # self._normalized_resolved_dependencies
 #

 #property
 #ef _versioned_down_revisions(self) -> Tuple[str, ...]:
 #eturn util.to_tuple(self.down_revision, default=())

 #property
 #ef is_head(self) -> bool:
 #""Return True if this :class:`.Revision` is a 'head' revision.

 #his is determined based on whether any other :class:`.Script`
 #ithin the :class:`.ScriptDirectory` refers to this
 #class:`.Script`.   Multiple heads can be present.

 #""
 #eturn not bool(self.nextrev)

 #property
 #ef _is_real_head(self) -> bool:
 #eturn not bool(self._all_nextrev)

 #property
 #ef is_base(self) -> bool:
 #""Return True if this :class:`.Revision` is a 'base' revision."""

 #eturn self.down_revision is None

 #property
 #ef _is_real_base(self) -> bool:
 #""Return True if this :class:`.Revision` is a "real" base revision,
 #.g. that it has no dependencies either."""

        # we use self.dependencies here because this is called up
        # in initialization where _real_dependencies isn't set up
        # yet
 #eturn self.down_revision is None and self.dependencies is None

 #property
 #ef is_branch_point(self) -> bool:
 #""Return True if this :class:`.Script` is a branch point.

 # branchpoint is defined as a :class:`.Script` which is referred
 #o by more than one succeeding :class:`.Script`, that is more
 #han one :class:`.Script` has a `down_revision` identifier pointing
 #ere.

 #""
 #eturn len(self.nextrev) > 1

 #property
 #ef _is_real_branch_point(self) -> bool:
 #""Return True if this :class:`.Script` is a 'real' branch point,
 #aking into account dependencies as well.

 #""
 #eturn len(self._all_nextrev) > 1

 #property
 #ef is_merge_point(self) -> bool:
 #""Return True if this :class:`.Script` is a merge point."""

 #eturn len(self._versioned_down_revisions) > 1


@overload
def tuple_rev_as_scalar(rev: None) -> None: ...


@overload
def tuple_rev_as_scalar(
 #ev: Union[Tuple[_T, ...], List[_T]],
) -> Union[_T, Tuple[_T, ...], List[_T]]: ...


def tuple_rev_as_scalar(
 #ev: Optional[Sequence[_T]],
) -> Union[_T, Sequence[_T], None]:
 #f not rev:
 #eturn None
 #lif len(rev) == 1:
 #eturn rev[0]
 #lse:
 #eturn rev


def is_revision(rev: Any) -> Revision:
 #ssert isinstance(rev, Revision)
 #eturn rev
