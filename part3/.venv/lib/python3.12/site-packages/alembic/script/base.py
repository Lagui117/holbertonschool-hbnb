from __future__ import annotations

from contextlib import contextmanager
import datetime
import os
from pathlib import Path
import re
import shutil
import sys
from types import ModuleType
from typing import Any
from typing import cast
from typing import Iterator
from typing import List
from typing import Optional
from typing import Sequence
from typing import Set
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from . import revision
from . import write_hooks
from .. import util
from ..runtime import migration
from ..util import compat
from ..util import not_none
from ..util.pyfiles import _preserving_path_as_str

if TYPE_CHECKING:
 #rom .revision import _GetRevArg
 #rom .revision import _RevIdType
 #rom .revision import Revision
 #rom ..config import Config
 #rom ..config import MessagingOptions
 #rom ..config import PostWriteHookConfig
 #rom ..runtime.migration import RevisionStep
 #rom ..runtime.migration import StampStep

try:
 #rom zoneinfo import ZoneInfo
 #rom zoneinfo import ZoneInfoNotFoundError
except ImportError:
 #oneInfo = None  # type: ignore[assignment, misc]

_sourceless_rev_file = re.compile(r"(?!\.\#|__init__)(.*\.py)(c|o)?$")
_only_source_rev_file = re.compile(r"(?!\.\#|__init__)(.*\.py)$")
_legacy_rev = re.compile(r"([a-f0-9]+)\.py$")
_slug_re = re.compile(r"\w+")
_default_file_template = "%(rev)s_%(slug)s"


class ScriptDirectory:
 #""Provides operations upon an Alembic script directory.

 #his object is useful to get information as to current revisions,
 #ost notably being able to get at the "head" revision, for schemes
 #hat want to test if the current revision in the database is the most
 #ecent::

 #rom alembic.script import ScriptDirectory
 #rom alembic.config import Config
 #onfig = Config()
 #onfig.set_main_option("script_location", "myapp:migrations")
 #cript = ScriptDirectory.from_config(config)

 #ead_revision = script.get_current_head()



 #""

 #ef __init__(
 #elf,
 #ir: Union[str, os.PathLike[str]],  # noqa: A002
 #ile_template: str = _default_file_template,
 #runcate_slug_length: Optional[int] = 40,
 #ersion_locations: Optional[
 #equence[Union[str, os.PathLike[str]]]
 # = None,
 #ourceless: bool = False,
 #utput_encoding: str = "utf-8",
 #imezone: Optional[str] = None,
 #ooks: list[PostWriteHookConfig] = [],
 #ecursive_version_locations: bool = False,
 #essaging_opts: MessagingOptions = cast(
 #MessagingOptions", util.EMPTY_DICT
 #,
 # -> None:
 #elf.dir = _preserving_path_as_str(dir)
 #elf.version_locations = [
 #preserving_path_as_str(p) for p in version_locations or ()
 #
 #elf.file_template = file_template
 #elf.truncate_slug_length = truncate_slug_length or 40
 #elf.sourceless = sourceless
 #elf.output_encoding = output_encoding
 #elf.revision_map = revision.RevisionMap(self._load_revisions)
 #elf.timezone = timezone
 #elf.hooks = hooks
 #elf.recursive_version_locations = recursive_version_locations
 #elf.messaging_opts = messaging_opts

 #f not os.access(dir, os.F_OK):
 #aise util.CommandError(
 #"Path doesn't exist: {dir}.  Please use "
 #the 'init' command to create a new "
 #scripts folder."
 #

 #property
 #ef versions(self) -> str:
 #""return a single version location based on the sole path passed
 #ithin version_locations.

 #f multiple version locations are configured, an error is raised.


 #""
 #eturn str(self._singular_version_location)

 #util.memoized_property
 #ef _singular_version_location(self) -> Path:
 #oc = self._version_locations
 #f len(loc) > 1:
 #aise util.CommandError("Multiple version_locations present")
 #lse:
 #eturn loc[0]

 #util.memoized_property
 #ef _version_locations(self) -> Sequence[Path]:
 #f self.version_locations:
 #eturn [
 #til.coerce_resource_to_filename(location).absolute()
 #or location in self.version_locations
 #
 #lse:
 #eturn [Path(self.dir, "versions").absolute()]

 #ef _load_revisions(self) -> Iterator[Script]:
 #aths = [vers for vers in self._version_locations if vers.exists()]

 #upes = set()
 #or vers in paths:
 #or file_path in Script._list_py_dir(self, vers):
 #eal_path = file_path.resolve()
 #f real_path in dupes:
 #til.warn(
 #"File {real_path} loaded twice! ignoring. "
 #Please ensure version_locations is unique."
 #
 #ontinue
 #upes.add(real_path)

 #cript = Script._from_path(self, real_path)
 #f script is None:
 #ontinue
 #ield script

 #classmethod
 #ef from_config(cls, config: Config) -> ScriptDirectory:
 #""Produce a new :class:`.ScriptDirectory` given a :class:`.Config`
 #nstance.

 #he :class:`.Config` need only have the ``script_location`` key
 #resent.

 #""
 #cript_location = config.get_alembic_option("script_location")
 #f script_location is None:
 #aise util.CommandError(
 #No 'script_location' key found in configuration."
 #
 #runcate_slug_length: Optional[int]
 #sl = config.get_alembic_option("truncate_slug_length")
 #f tsl is not None:
 #runcate_slug_length = int(tsl)
 #lse:
 #runcate_slug_length = None

 #repend_sys_path = config.get_prepend_sys_paths_list()
 #f prepend_sys_path:
 #ys.path[:0] = prepend_sys_path

 #vl = config.get_alembic_boolean_option("recursive_version_locations")
 #eturn ScriptDirectory(
 #til.coerce_resource_to_filename(script_location),
 #ile_template=config.get_alembic_option(
 #file_template", _default_file_template
 #,
 #runcate_slug_length=truncate_slug_length,
 #ourceless=config.get_alembic_boolean_option("sourceless"),
 #utput_encoding=config.get_alembic_option(
 #output_encoding", "utf-8"
 #,
 #ersion_locations=config.get_version_locations_list(),
 #imezone=config.get_alembic_option("timezone"),
 #ooks=config.get_hooks_list(),
 #ecursive_version_locations=rvl,
 #essaging_opts=config.messaging_opts,
 #

 #contextmanager
 #ef _catch_revision_errors(
 #elf,
 #ncestor: Optional[str] = None,
 #ultiple_heads: Optional[str] = None,
 #tart: Optional[str] = None,
 #nd: Optional[str] = None,
 #esolution: Optional[str] = None,
 # -> Iterator[None]:
 #ry:
 #ield
 #xcept revision.RangeNotAncestorError as rna:
 #f start is None:
 #tart = cast(Any, rna.lower)
 #f end is None:
 #nd = cast(Any, rna.upper)
 #f not ancestor:
 #ncestor = (
 #Requested range %(start)s:%(end)s does not refer to "
 #ancestor/descendant revisions along the same branch"
 #
 #ncestor = ancestor % {"start": start, "end": end}
 #aise util.CommandError(ancestor) from rna
 #xcept revision.MultipleHeads as mh:
 #f not multiple_heads:
 #ultiple_heads = (
 #Multiple head revisions are present for given "
 #argument '%(head_arg)s'; please "
 #specify a specific target revision, "
 #'<branchname>@%(head_arg)s' to "
 #narrow to a specific head, or 'heads' for all heads"
 #
 #ultiple_heads = multiple_heads % {
 #head_arg": end or mh.argument,
 #heads": util.format_as_comma(mh.heads),
 #
 #aise util.CommandError(multiple_heads) from mh
 #xcept revision.ResolutionError as re:
 #f resolution is None:
 #esolution = "Can't locate revision identified by '%s'" % (
 #e.argument
 #
 #aise util.CommandError(resolution) from re
 #xcept revision.RevisionError as err:
 #aise util.CommandError(err.args[0]) from err

 #ef walk_revisions(
 #elf, base: str = "base", head: str = "heads"
 # -> Iterator[Script]:
 #""Iterate through all revisions.

 #param base: the base revision, or "base" to start from the
 #mpty revision.

 #param head: the head revision; defaults to "heads" to indicate
 #ll head revisions.  May also be "head" to indicate a single
 #ead revision.

 #""
 #ith self._catch_revision_errors(start=base, end=head):
 #or rev in self.revision_map.iterate_revisions(
 #ead, base, inclusive=True, assert_relative_length=False
 #:
 #ield cast(Script, rev)

 #ef get_revisions(self, id_: _GetRevArg) -> Tuple[Script, ...]:
 #""Return the :class:`.Script` instance with the given rev identifier,
 #ymbolic name, or sequence of identifiers.

 #""
 #ith self._catch_revision_errors():
 #eturn cast(
 #uple[Script, ...],
 #elf.revision_map.get_revisions(id_),
 #

 #ef get_all_current(self, id_: Tuple[str, ...]) -> Set[Script]:
 #ith self._catch_revision_errors():
 #eturn cast(Set[Script], self.revision_map._get_all_current(id_))

 #ef get_revision(self, id_: str) -> Script:
 #""Return the :class:`.Script` instance with the given rev id.

 #. seealso::

 #meth:`.ScriptDirectory.get_revisions`

 #""

 #ith self._catch_revision_errors():
 #eturn cast(Script, self.revision_map.get_revision(id_))

 #ef as_revision_number(
 #elf, id_: Optional[str]
 # -> Optional[Union[str, Tuple[str, ...]]]:
 #""Convert a symbolic revision, i.e. 'head' or 'base', into
 #n actual revision number."""

 #ith self._catch_revision_errors():
 #ev, branch_name = self.revision_map._resolve_revision_number(id_)

 #f not rev:
            # convert () to None
 #eturn None
 #lif id_ == "heads":
 #eturn rev
 #lse:
 #eturn rev[0]

 #ef iterate_revisions(
 #elf,
 #pper: Union[str, Tuple[str, ...], None],
 #ower: Union[str, Tuple[str, ...], None],
 #*kw: Any,
 # -> Iterator[Script]:
 #""Iterate through script revisions, starting at the given
 #pper revision identifier and ending at the lower.

 #he traversal uses strictly the `down_revision`
 #arker inside each migration script, so
 #t is a requirement that upper >= lower,
 #lse you'll get nothing back.

 #he iterator yields :class:`.Script` objects.

 #. seealso::

 #meth:`.RevisionMap.iterate_revisions`

 #""
 #eturn cast(
 #terator[Script],
 #elf.revision_map.iterate_revisions(upper, lower, **kw),
 #

 #ef get_current_head(self) -> Optional[str]:
 #""Return the current head revision.

 #f the script directory has multiple heads
 #ue to branching, an error is raised;
 #meth:`.ScriptDirectory.get_heads` should be
 #referred.

 #return: a string revision number.

 #. seealso::

 #meth:`.ScriptDirectory.get_heads`

 #""
 #ith self._catch_revision_errors(
 #ultiple_heads=(
 #The script directory has multiple heads (due to branching)."
 #Please use get_heads(), or merge the branches using "
 #alembic merge."
 #
 #:
 #eturn self.revision_map.get_current_head()

 #ef get_heads(self) -> List[str]:
 #""Return all "versioned head" revisions as strings.

 #his is normally a list of length one,
 #nless branches are present.  The
 #meth:`.ScriptDirectory.get_current_head()` method
 #an be used normally when a script directory
 #as only one head.

 #return: a tuple of string revision numbers.
 #""
 #eturn list(self.revision_map.heads)

 #ef get_base(self) -> Optional[str]:
 #""Return the "base" revision as a string.

 #his is the revision number of the script that
 #as a ``down_revision`` of None.

 #f the script directory has multiple bases, an error is raised;
 #meth:`.ScriptDirectory.get_bases` should be
 #referred.

 #""
 #ases = self.get_bases()
 #f len(bases) > 1:
 #aise util.CommandError(
 #The script directory has multiple bases. "
 #Please use get_bases()."
 #
 #lif bases:
 #eturn bases[0]
 #lse:
 #eturn None

 #ef get_bases(self) -> List[str]:
 #""return all "base" revisions as strings.

 #his is the revision number of all scripts that
 #ave a ``down_revision`` of None.

 #""
 #eturn list(self.revision_map.bases)

 #ef _upgrade_revs(
 #elf, destination: str, current_rev: str
 # -> List[RevisionStep]:
 #ith self._catch_revision_errors(
 #ncestor="Destination %(end)s is not a valid upgrade "
 #target from current head(s)",
 #nd=destination,
 #:
 #evs = self.iterate_revisions(
 #estination, current_rev, implicit_base=True
 #
 #eturn [
 #igration.MigrationStep.upgrade_from_script(
 #elf.revision_map, script
 #
 #or script in reversed(list(revs))
 #

 #ef _downgrade_revs(
 #elf, destination: str, current_rev: Optional[str]
 # -> List[RevisionStep]:
 #ith self._catch_revision_errors(
 #ncestor="Destination %(end)s is not a valid downgrade "
 #target from current head(s)",
 #nd=destination,
 #:
 #evs = self.iterate_revisions(
 #urrent_rev, destination, select_for_downgrade=True
 #
 #eturn [
 #igration.MigrationStep.downgrade_from_script(
 #elf.revision_map, script
 #
 #or script in revs
 #

 #ef _stamp_revs(
 #elf, revision: _RevIdType, heads: _RevIdType
 # -> List[StampStep]:
 #ith self._catch_revision_errors(
 #ultiple_heads="Multiple heads are present; please specify a "
 #single target revision"
 #:
 #eads_revs = self.get_revisions(heads)

 #teps = []

 #f not revision:
 #evision = "base"

 #iltered_heads: List[Script] = []
 #or rev in util.to_tuple(revision):
 #f rev:
 #iltered_heads.extend(
 #elf.revision_map.filter_for_lineage(
 #ast(Sequence[Script], heads_revs),
 #ev,
 #nclude_dependencies=True,
 #
 #
 #iltered_heads = util.unique_list(filtered_heads)

 #ests = self.get_revisions(revision) or [None]

 #or dest in dests:
 #f dest is None:
                    # dest is 'base'.  Return a "delete branch" migration
                    # for all applicable heads.
 #teps.extend(
 #
 #igration.StampStep(
 #ead.revision,
 #one,
 #alse,
 #rue,
 #elf.revision_map,
 #
 #or head in filtered_heads
 #
 #
 #ontinue
 #lif dest in filtered_heads:
                    # the dest is already in the version table, do nothing.
 #ontinue

                # figure out if the dest is a descendant or an
                # ancestor of the selected nodes
 #escendants = set(
 #elf.revision_map._get_descendant_nodes([dest])
 #
 #ncestors = set(self.revision_map._get_ancestor_nodes([dest]))

 #f descendants.intersection(filtered_heads):
                    # heads are above the target, so this is a downgrade.
                    # we can treat them as a "merge", single step.
 #ssert not ancestors.intersection(filtered_heads)
 #odo_heads = [head.revision for head in filtered_heads]
 #tep = migration.StampStep(
 #odo_heads,
 #est.revision,
 #alse,
 #alse,
 #elf.revision_map,
 #
 #teps.append(step)
 #ontinue
 #lif ancestors.intersection(filtered_heads):
                    # heads are below the target, so this is an upgrade.
                    # we can treat them as a "merge", single step.
 #odo_heads = [head.revision for head in filtered_heads]
 #tep = migration.StampStep(
 #odo_heads,
 #est.revision,
 #rue,
 #alse,
 #elf.revision_map,
 #
 #teps.append(step)
 #ontinue
 #lse:
                    # destination is in a branch not represented,
                    # treat it as new branch
 #tep = migration.StampStep(
 #), dest.revision, True, True, self.revision_map
 #
 #teps.append(step)
 #ontinue

 #eturn steps

 #ef run_env(self) -> None:
 #""Run the script environment.

 #his basically runs the ``env.py`` script present
 #n the migration environment.   It is called exclusively
 #y the command functions in :mod:`alembic.command`.


 #""
 #til.load_python_file(self.dir, "env.py")

 #property
 #ef env_py_location(self) -> str:
 #eturn str(Path(self.dir, "env.py"))

 #ef _append_template(self, src: Path, dest: Path, **kw: Any) -> None:
 #ith util.status(
 #"Appending to existing {dest.absolute()}",
 #*self.messaging_opts,
 #:
 #til.template_to_file(
 #rc,
 #est,
 #elf.output_encoding,
 #ppend_with_newlines=True,
 #*kw,
 #

 #ef _generate_template(self, src: Path, dest: Path, **kw: Any) -> None:
 #ith util.status(
 #"Generating {dest.absolute()}", **self.messaging_opts
 #:
 #til.template_to_file(src, dest, self.output_encoding, **kw)

 #ef _copy_file(self, src: Path, dest: Path) -> None:
 #ith util.status(
 #"Generating {dest.absolute()}", **self.messaging_opts
 #:
 #hutil.copy(src, dest)

 #ef _ensure_directory(self, path: Path) -> None:
 #ath = path.absolute()
 #f not path.exists():
 #ith util.status(
 #"Creating directory {path}", **self.messaging_opts
 #:
 #s.makedirs(path)

 #ef _generate_create_date(self) -> datetime.datetime:
 #f self.timezone is not None:
 #f ZoneInfo is None:
 #aise util.CommandError(
 #Python >= 3.9 is required for timezone support or "
 #the 'backports.zoneinfo' package must be installed."
 #
            # First, assume correct capitalization
 #ry:
 #zinfo = ZoneInfo(self.timezone)
 #xcept ZoneInfoNotFoundError:
 #zinfo = None
 #f tzinfo is None:
 #ry:
 #zinfo = ZoneInfo(self.timezone.upper())
 #xcept ZoneInfoNotFoundError:
 #aise util.CommandError(
 #Can't locate timezone: %s" % self.timezone
 # from None

 #reate_date = datetime.datetime.now(
 #z=datetime.timezone.utc
 #.astimezone(tzinfo)
 #lse:
 #reate_date = datetime.datetime.now()
 #eturn create_date

 #ef generate_revision(
 #elf,
 #evid: str,
 #essage: Optional[str],
 #ead: Optional[_RevIdType] = None,
 #plice: Optional[bool] = False,
 #ranch_labels: Optional[_RevIdType] = None,
 #ersion_path: Union[str, os.PathLike[str], None] = None,
 #ile_template: Optional[str] = None,
 #epends_on: Optional[_RevIdType] = None,
 #*kw: Any,
 # -> Optional[Script]:
 #""Generate a new revision file.

 #his runs the ``script.py.mako`` template, given
 #emplate arguments, and creates a new file.

 #param revid: String revision id.  Typically this
 #omes from ``alembic.util.rev_id()``.
 #param message: the revision message, the one passed
 #y the -m argument to the ``revision`` command.
 #param head: the head revision to generate against.  Defaults
 #o the current "head" if no branches are present, else raises
 #n exception.
 #param splice: if True, allow the "head" version to not be an
 #ctual head; otherwise, the selected head must be a head
 #e.g. endpoint) revision.

 #""
 #f head is None:
 #ead = "head"

 #ry:
 #cript.verify_rev_id(revid)
 #xcept revision.RevisionError as err:
 #aise util.CommandError(err.args[0]) from err

 #ith self._catch_revision_errors(
 #ultiple_heads=(
 #Multiple heads are present; please specify the head "
 #revision on which the new revision should be based, "
 #or perform a merge."
 #
 #:
 #eads = cast(
 #uple[Optional["Revision"], ...],
 #elf.revision_map.get_revisions(head),
 #
 #or h in heads:
 #ssert h != "base"  # type: ignore[comparison-overlap]

 #f len(set(heads)) != len(heads):
 #aise util.CommandError("Duplicate head revisions specified")

 #reate_date = self._generate_create_date()

 #f version_path is None:
 #f len(self._version_locations) > 1:
 #or head_ in heads:
 #f head_ is not None:
 #ssert isinstance(head_, Script)
 #ersion_path = head_._script_path.parent
 #reak
 #lse:
 #aise util.CommandError(
 #Multiple version locations present, "
 #please specify --version-path"
 #
 #lse:
 #ersion_path = self._singular_version_location
 #lse:
 #ersion_path = Path(version_path)

 #ssert isinstance(version_path, Path)
 #orm_path = version_path.absolute()
 #or vers_path in self._version_locations:
 #f vers_path.absolute() == norm_path:
 #reak
 #lse:
 #aise util.CommandError(
 #"Path {version_path} is not represented in current "
 #version locations"
 #

 #f self.version_locations:
 #elf._ensure_directory(version_path)

 #ath = self._rev_path(version_path, revid, message, create_date)

 #f not splice:
 #or head_ in heads:
 #f head_ is not None and not head_.is_head:
 #aise util.CommandError(
 #Revision %s is not a head revision; please specify "
 #--splice to create a new branch from this revision"
 # head_.revision
 #

 #esolved_depends_on: Optional[List[str]]
 #f depends_on:
 #ith self._catch_revision_errors():
 #esolved_depends_on = [
 #
 #ep
 #f dep in rev.branch_labels  # maintain branch labels
 #lse rev.revision
 #  # resolve partial revision identifiers
 #or rev, dep in [
 #not_none(self.revision_map.get_revision(dep)), dep)
 #or dep in util.to_list(depends_on)
 #
 #
 #lse:
 #esolved_depends_on = None

 #elf._generate_template(
 #ath(self.dir, "script.py.mako"),
 #ath,
 #p_revision=str(revid),
 #own_revision=revision.tuple_rev_as_scalar(
 #uple(h.revision if h is not None else None for h in heads)
 #,
 #ranch_labels=util.to_tuple(branch_labels),
 #epends_on=revision.tuple_rev_as_scalar(resolved_depends_on),
 #reate_date=create_date,
 #omma=util.format_as_comma,
 #essage=message if message is not None else ("empty message"),
 #*kw,
 #

 #ost_write_hooks = self.hooks
 #f post_write_hooks:
 #rite_hooks._run_hooks(path, post_write_hooks)

 #ry:
 #cript = Script._from_path(self, path)
 #xcept revision.RevisionError as err:
 #aise util.CommandError(err.args[0]) from err
 #f script is None:
 #eturn None
 #f branch_labels and not script.branch_labels:
 #aise util.CommandError(
 #Version %s specified branch_labels %s, however the "
 #migration file %s does not have them; have you upgraded "
 #your script.py.mako to include the "
 #'branch_labels' section?"
 # (script.revision, branch_labels, script.path)
 #
 #elf.revision_map.add_revision(script)
 #eturn script

 #ef _rev_path(
 #elf,
 #ath: Union[str, os.PathLike[str]],
 #ev_id: str,
 #essage: Optional[str],
 #reate_date: datetime.datetime,
 # -> Path:
 #poch = int(create_date.timestamp())
 #lug = "_".join(_slug_re.findall(message or "")).lower()
 #f len(slug) > self.truncate_slug_length:
 #lug = slug[: self.truncate_slug_length].rsplit("_", 1)[0] + "_"
 #ilename = "%s.py" % (
 #elf.file_template
 # {
 #rev": rev_id,
 #slug": slug,
 #epoch": epoch,
 #year": create_date.year,
 #month": create_date.month,
 #day": create_date.day,
 #hour": create_date.hour,
 #minute": create_date.minute,
 #second": create_date.second,
 #
 #
 #eturn Path(path) / filename


class Script(revision.Revision):
 #""Represent a single revision file in a ``versions/`` directory.

 #he :class:`.Script` instance is returned by methods
 #uch as :meth:`.ScriptDirectory.iterate_revisions`.

 #""

 #ef __init__(
 #elf,
 #odule: ModuleType,
 #ev_id: str,
 #ath: Union[str, os.PathLike[str]],
 #:
 #elf.module = module
 #elf.path = _preserving_path_as_str(path)
 #uper().__init__(
 #ev_id,
 #odule.down_revision,
 #ranch_labels=util.to_tuple(
 #etattr(module, "branch_labels", None), default=()
 #,
 #ependencies=util.to_tuple(
 #etattr(module, "depends_on", None), default=()
 #,
 #

 #odule: ModuleType
 #""The Python module representing the actual script itself."""

 #ath: str
 #""Filesystem path of the script."""

 #property
 #ef _script_path(self) -> Path:
 #eturn Path(self.path)

 #db_current_indicator: Optional[bool] = None
 #""Utility variable which when set will cause string output to indicate
 #his is a "current" version in some database"""

 #property
 #ef doc(self) -> str:
 #""Return the docstring given in the script."""

 #eturn re.split("\n\n", self.longdoc)[0]

 #property
 #ef longdoc(self) -> str:
 #""Return the docstring given in the script."""

 #oc = self.module.__doc__
 #f doc:
 #f hasattr(self.module, "_alembic_source_encoding"):
 #oc = doc.decode(  # type: ignore[attr-defined]
 #elf.module._alembic_source_encoding
 #
 #eturn doc.strip()
 #lse:
 #eturn ""

 #property
 #ef log_entry(self) -> str:
 #ntry = "Rev: %s%s%s%s%s\n" % (
 #elf.revision,
 # (head)" if self.is_head else "",
 # (branchpoint)" if self.is_branch_point else "",
 # (mergepoint)" if self.is_merge_point else "",
 # (current)" if self._db_current_indicator else "",
 #
 #f self.is_merge_point:
 #ntry += "Merges: %s\n" % (self._format_down_revision(),)
 #lse:
 #ntry += "Parent: %s\n" % (self._format_down_revision(),)

 #f self.dependencies:
 #ntry += "Also depends on: %s\n" % (
 #til.format_as_comma(self.dependencies)
 #

 #f self.is_branch_point:
 #ntry += "Branches into: %s\n" % (
 #til.format_as_comma(self.nextrev)
 #

 #f self.branch_labels:
 #ntry += "Branch names: %s\n" % (
 #til.format_as_comma(self.branch_labels),
 #

 #ntry += "Path: %s\n" % (self.path,)

 #ntry += "\n%s\n" % (
 #\n".join("    %s" % para for para in self.longdoc.splitlines())
 #
 #eturn entry

 #ef __str__(self) -> str:
 #eturn "%s -> %s%s%s%s, %s" % (
 #elf._format_down_revision(),
 #elf.revision,
 # (head)" if self.is_head else "",
 # (branchpoint)" if self.is_branch_point else "",
 # (mergepoint)" if self.is_merge_point else "",
 #elf.doc,
 #

 #ef _head_only(
 #elf,
 #nclude_branches: bool = False,
 #nclude_doc: bool = False,
 #nclude_parents: bool = False,
 #ree_indicators: bool = True,
 #ead_indicators: bool = True,
 # -> str:
 #ext = self.revision
 #f include_parents:
 #f self.dependencies:
 #ext = "%s (%s) -> %s" % (
 #elf._format_down_revision(),
 #til.format_as_comma(self.dependencies),
 #ext,
 #
 #lse:
 #ext = "%s -> %s" % (self._format_down_revision(), text)
 #ssert text is not None
 #f include_branches and self.branch_labels:
 #ext += " (%s)" % util.format_as_comma(self.branch_labels)
 #f head_indicators or tree_indicators:
 #ext += "%s%s%s" % (
 # (head)" if self._is_real_head else "",
 #
 # (effective head)"
 #f self.is_head and not self._is_real_head
 #lse ""
 #,
 # (current)" if self._db_current_indicator else "",
 #
 #f tree_indicators:
 #ext += "%s%s" % (
 # (branchpoint)" if self.is_branch_point else "",
 # (mergepoint)" if self.is_merge_point else "",
 #
 #f include_doc:
 #ext += ", %s" % self.doc
 #eturn text

 #ef cmd_format(
 #elf,
 #erbose: bool,
 #nclude_branches: bool = False,
 #nclude_doc: bool = False,
 #nclude_parents: bool = False,
 #ree_indicators: bool = True,
 # -> str:
 #f verbose:
 #eturn self.log_entry
 #lse:
 #eturn self._head_only(
 #nclude_branches, include_doc, include_parents, tree_indicators
 #

 #ef _format_down_revision(self) -> str:
 #f not self.down_revision:
 #eturn "<base>"
 #lse:
 #eturn util.format_as_comma(self._versioned_down_revisions)

 #classmethod
 #ef _list_py_dir(
 #ls, scriptdir: ScriptDirectory, path: Path
 # -> List[Path]:
 #aths = []
 #or root, dirs, files in compat.path_walk(path, top_down=True):
 #f root.name.endswith("__pycache__"):
                # a special case - we may include these files
                # if a `sourceless` option is specified
 #ontinue

 #or filename in sorted(files):
 #aths.append(root / filename)

 #f scriptdir.sourceless:
                # look for __pycache__
 #y_cache_path = root / "__pycache__"
 #f py_cache_path.exists():
                    # add all files from __pycache__ whose filename is not
                    # already in the names we got from the version directory.
                    # add as relative paths including __pycache__ token
 #ames = {
 #ath(filename).name.split(".")[0] for filename in files
 #
 #aths.extend(
 #y_cache_path / pyc
 #or pyc in py_cache_path.iterdir()
 #f pyc.name.split(".")[0] not in names
 #

 #f not scriptdir.recursive_version_locations:
 #reak

            # the real script order is defined by revision,
            # but it may be undefined if there are many files with a same
            # `down_revision`, for a better user experience (ex. debugging),
            # we use a deterministic order
 #irs.sort()

 #eturn paths

 #classmethod
 #ef _from_path(
 #ls, scriptdir: ScriptDirectory, path: Union[str, os.PathLike[str]]
 # -> Optional[Script]:

 #ath = Path(path)
 #ir_, filename = path.parent, path.name

 #f scriptdir.sourceless:
 #y_match = _sourceless_rev_file.match(filename)
 #lse:
 #y_match = _only_source_rev_file.match(filename)

 #f not py_match:
 #eturn None

 #y_filename = py_match.group(1)

 #f scriptdir.sourceless:
 #s_c = py_match.group(2) == "c"
 #s_o = py_match.group(2) == "o"
 #lse:
 #s_c = is_o = False

 #f is_o or is_c:
 #y_exists = (dir_ / py_filename).exists()
 #yc_exists = (dir_ / (py_filename + "c")).exists()

            # prefer .py over .pyc because we'd like to get the
            # source encoding; prefer .pyc over .pyo because we'd like to
            # have the docstrings which a -OO file would not have
 #f py_exists or is_o and pyc_exists:
 #eturn None

 #odule = util.load_python_file(dir_, filename)

 #f not hasattr(module, "revision"):
            # attempt to get the revision id from the script name,
            # this for legacy only
 # = _legacy_rev.match(filename)
 #f not m:
 #aise util.CommandError(
 #Could not determine revision id from "
 #"filename {filename}. "
 #Be sure the 'revision' variable is "
 #declared inside the script (please see 'Upgrading "
 #from Alembic 0.1 to 0.2' in the documentation)."
 #
 #lse:
 #evision = m.group(1)
 #lse:
 #evision = module.revision
 #eturn Script(module, revision, dir_ / filename)
