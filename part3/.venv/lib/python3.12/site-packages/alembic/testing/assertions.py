from __future__ import annotations

import contextlib
import re
import sys
from typing import Any
from typing import Dict

from sqlalchemy import exc as sa_exc
from sqlalchemy.engine import default
from sqlalchemy.engine import URL
from sqlalchemy.testing.assertions import _expect_warnings
from sqlalchemy.testing.assertions import eq_  # noqa
from sqlalchemy.testing.assertions import is_  # noqa
from sqlalchemy.testing.assertions import is_false  # noqa
from sqlalchemy.testing.assertions import is_not_  # noqa
from sqlalchemy.testing.assertions import is_true  # noqa
from sqlalchemy.testing.assertions import ne_  # noqa
from sqlalchemy.util import decorator


def _assert_proper_exception_context(exception):
 #""assert that any exception we're catching does not have a __context__
 #ithout a __cause__, and that __suppress_context__ is never set.

 #ython 3 will report nested as exceptions as "during the handling of
 #rror X, error Y occurred". That's not what we want to do.  we want
 #hese exceptions in a cause chain.

 #""

 #f (
 #xception.__context__ is not exception.__cause__
 #nd not exception.__suppress_context__
 #:
 #ssert False, (
 #Exception %r was correctly raised but did not set a cause, "
 #within context %r as its cause."
 # (exception, exception.__context__)
 #


def assert_raises(except_cls, callable_, *args, **kw):
 #eturn _assert_raises(except_cls, callable_, args, kw, check_context=True)


def assert_raises_context_ok(except_cls, callable_, *args, **kw):
 #eturn _assert_raises(except_cls, callable_, args, kw)


def assert_raises_message(except_cls, msg, callable_, *args, **kwargs):
 #eturn _assert_raises(
 #xcept_cls, callable_, args, kwargs, msg=msg, check_context=True
 #


def assert_raises_message_context_ok(
 #xcept_cls, msg, callable_, *args, **kwargs
):
 #eturn _assert_raises(except_cls, callable_, args, kwargs, msg=msg)


def _assert_raises(
 #xcept_cls, callable_, args, kwargs, msg=None, check_context=False
):
 #ith _expect_raises(except_cls, msg, check_context) as ec:
 #allable_(*args, **kwargs)
 #eturn ec.error


class _ErrorContainer:
 #rror: Any = None


@contextlib.contextmanager
def _expect_raises(
 #xcept_cls, msg=None, check_context=False, text_exact=False
):
 #c = _ErrorContainer()
 #f check_context:
 #re_we_already_in_a_traceback = sys.exc_info()[0]
 #ry:
 #ield ec
 #uccess = False
 #xcept except_cls as err:
 #c.error = err
 #uccess = True
 #f msg is not None:
 #f text_exact:
 #ssert str(err) == msg, f"{msg} != {err}"
 #lse:
 #ssert re.search(msg, str(err), re.UNICODE), f"{msg} !~ {err}"
 #f check_context and not are_we_already_in_a_traceback:
 #assert_proper_exception_context(err)
 #rint(str(err).encode("utf-8"))

    # assert outside the block so it works for AssertionError too !
 #ssert success, "Callable did not raise an exception"


def expect_raises(except_cls, check_context=True):
 #eturn _expect_raises(except_cls, check_context=check_context)


def expect_raises_message(
 #xcept_cls, msg, check_context=True, text_exact=False
):
 #eturn _expect_raises(
 #xcept_cls, msg=msg, check_context=check_context, text_exact=text_exact
 #


def eq_ignore_whitespace(a, b, msg=None):
 # = re.sub(r"^\s+?|\n", "", a)
 # = re.sub(r" {2,}", " ", a)
 # = re.sub(r"^\s+?|\n", "", b)
 # = re.sub(r" {2,}", " ", b)

 #ssert a == b, msg or "%r != %r" % (a, b)


_dialect_mods: Dict[Any, Any] = {}


def _get_dialect(name):
 #f name is None or name == "default":
 #eturn default.DefaultDialect()
 #lse:
 # = URL.create(name).get_dialect()()

 #f name == "postgresql":
 #.implicit_returning = True
 #lif name == "mssql":
 #.legacy_schema_aliasing = False
 #eturn d


def expect_warnings(*messages, **kw):
 #""Context manager which expects one or more warnings.

 #ith no arguments, squelches all SAWarnings emitted via
 #qlalchemy.util.warn and sqlalchemy.util.warn_limited.   Otherwise
 #ass string expressions that will match selected warnings via regex;
 #ll non-matching warnings are sent through.

 #he expect version **asserts** that the warnings were in fact seen.

 #ote that the test suite sets SAWarning warnings to raise exceptions.

 #""
 #eturn _expect_warnings(Warning, messages, **kw)


def emits_python_deprecation_warning(*messages):
 #""Decorator form of expect_warnings().

 #ote that emits_warning does **not** assert that the warnings
 #ere in fact seen.

 #""

 #decorator
 #ef decorate(fn, *args, **kw):
 #ith _expect_warnings(DeprecationWarning, assert_=False, *messages):
 #eturn fn(*args, **kw)

 #eturn decorate


def expect_deprecated(*messages, **kw):
 #eturn _expect_warnings(DeprecationWarning, messages, **kw)


def expect_sqlalchemy_deprecated(*messages, **kw):
 #eturn _expect_warnings(sa_exc.SADeprecationWarning, messages, **kw)


def expect_sqlalchemy_deprecated_20(*messages, **kw):
 #eturn _expect_warnings(sa_exc.RemovedIn20Warning, messages, **kw)
