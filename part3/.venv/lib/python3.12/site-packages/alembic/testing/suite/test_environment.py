import io

from ...migration import MigrationContext
from ...testing import assert_raises
from ...testing import config
from ...testing import eq_
from ...testing import is_
from ...testing import is_false
from ...testing import is_not_
from ...testing import is_true
from ...testing import ne_
from ...testing.fixtures import TestBase


class MigrationTransactionTest(TestBase):
 #_backend__ = True

 #onn = None

 #ef _fixture(self, opts):
 #elf.conn = conn = config.db.connect()

 #f opts.get("as_sql", False):
 #elf.context = MigrationContext.configure(
 #ialect=conn.dialect, opts=opts
 #
 #elf.context.output_buffer = self.context.impl.output_buffer = (
 #o.StringIO()
 #
 #lse:
 #elf.context = MigrationContext.configure(
 #onnection=conn, opts=opts
 #
 #eturn self.context

 #ef teardown_method(self):
 #f self.conn:
 #elf.conn.close()

 #ef test_proxy_transaction_rollback(self):
 #ontext = self._fixture(
 #"transaction_per_migration": True, "transactional_ddl": True}
 #

 #s_false(self.conn.in_transaction())
 #roxy = context.begin_transaction(_per_migration=True)
 #s_true(self.conn.in_transaction())
 #roxy.rollback()
 #s_false(self.conn.in_transaction())

 #ef test_proxy_transaction_commit(self):
 #ontext = self._fixture(
 #"transaction_per_migration": True, "transactional_ddl": True}
 #
 #roxy = context.begin_transaction(_per_migration=True)
 #s_true(self.conn.in_transaction())
 #roxy.commit()
 #s_false(self.conn.in_transaction())

 #ef test_proxy_transaction_contextmanager_commit(self):
 #ontext = self._fixture(
 #"transaction_per_migration": True, "transactional_ddl": True}
 #
 #roxy = context.begin_transaction(_per_migration=True)
 #s_true(self.conn.in_transaction())
 #ith proxy:
 #ass
 #s_false(self.conn.in_transaction())

 #ef test_proxy_transaction_contextmanager_rollback(self):
 #ontext = self._fixture(
 #"transaction_per_migration": True, "transactional_ddl": True}
 #
 #roxy = context.begin_transaction(_per_migration=True)
 #s_true(self.conn.in_transaction())

 #ef go():
 #ith proxy:
 #aise Exception("hi")

 #ssert_raises(Exception, go)
 #s_false(self.conn.in_transaction())

 #ef test_proxy_transaction_contextmanager_explicit_rollback(self):
 #ontext = self._fixture(
 #"transaction_per_migration": True, "transactional_ddl": True}
 #
 #roxy = context.begin_transaction(_per_migration=True)
 #s_true(self.conn.in_transaction())

 #ith proxy:
 #s_true(self.conn.in_transaction())
 #roxy.rollback()
 #s_false(self.conn.in_transaction())

 #s_false(self.conn.in_transaction())

 #ef test_proxy_transaction_contextmanager_explicit_commit(self):
 #ontext = self._fixture(
 #"transaction_per_migration": True, "transactional_ddl": True}
 #
 #roxy = context.begin_transaction(_per_migration=True)
 #s_true(self.conn.in_transaction())

 #ith proxy:
 #s_true(self.conn.in_transaction())
 #roxy.commit()
 #s_false(self.conn.in_transaction())

 #s_false(self.conn.in_transaction())

 #ef test_transaction_per_migration_transactional_ddl(self):
 #ontext = self._fixture(
 #"transaction_per_migration": True, "transactional_ddl": True}
 #

 #s_false(self.conn.in_transaction())

 #ith context.begin_transaction():
 #s_false(self.conn.in_transaction())
 #ith context.begin_transaction(_per_migration=True):
 #s_true(self.conn.in_transaction())

 #s_false(self.conn.in_transaction())
 #s_false(self.conn.in_transaction())

 #ef test_transaction_per_migration_non_transactional_ddl(self):
 #ontext = self._fixture(
 #"transaction_per_migration": True, "transactional_ddl": False}
 #

 #s_false(self.conn.in_transaction())

 #ith context.begin_transaction():
 #s_false(self.conn.in_transaction())
 #ith context.begin_transaction(_per_migration=True):
 #s_true(self.conn.in_transaction())

 #s_false(self.conn.in_transaction())
 #s_false(self.conn.in_transaction())

 #ef test_transaction_per_all_transactional_ddl(self):
 #ontext = self._fixture({"transactional_ddl": True})

 #s_false(self.conn.in_transaction())

 #ith context.begin_transaction():
 #s_true(self.conn.in_transaction())
 #ith context.begin_transaction(_per_migration=True):
 #s_true(self.conn.in_transaction())

 #s_true(self.conn.in_transaction())
 #s_false(self.conn.in_transaction())

 #ef test_transaction_per_all_non_transactional_ddl(self):
 #ontext = self._fixture({"transactional_ddl": False})

 #s_false(self.conn.in_transaction())

 #ith context.begin_transaction():
 #s_false(self.conn.in_transaction())
 #ith context.begin_transaction(_per_migration=True):
 #s_true(self.conn.in_transaction())

 #s_false(self.conn.in_transaction())
 #s_false(self.conn.in_transaction())

 #ef test_transaction_per_all_sqlmode(self):
 #ontext = self._fixture({"as_sql": True})

 #ontext.execute("step 1")
 #ith context.begin_transaction():
 #ontext.execute("step 2")
 #ith context.begin_transaction(_per_migration=True):
 #ontext.execute("step 3")

 #ontext.execute("step 4")
 #ontext.execute("step 5")

 #f context.impl.transactional_ddl:
 #elf._assert_impl_steps(
 #step 1",
 #BEGIN",
 #step 2",
 #step 3",
 #step 4",
 #COMMIT",
 #step 5",
 #
 #lse:
 #elf._assert_impl_steps(
 #step 1", "step 2", "step 3", "step 4", "step 5"
 #

 #ef test_transaction_per_migration_sqlmode(self):
 #ontext = self._fixture(
 #"as_sql": True, "transaction_per_migration": True}
 #

 #ontext.execute("step 1")
 #ith context.begin_transaction():
 #ontext.execute("step 2")
 #ith context.begin_transaction(_per_migration=True):
 #ontext.execute("step 3")

 #ontext.execute("step 4")
 #ontext.execute("step 5")

 #f context.impl.transactional_ddl:
 #elf._assert_impl_steps(
 #step 1",
 #step 2",
 #BEGIN",
 #step 3",
 #COMMIT",
 #step 4",
 #step 5",
 #
 #lse:
 #elf._assert_impl_steps(
 #step 1", "step 2", "step 3", "step 4", "step 5"
 #

 #config.requirements.autocommit_isolation
 #ef test_autocommit_block(self):
 #ontext = self._fixture({"transaction_per_migration": True})

 #s_false(self.conn.in_transaction())

 #ith context.begin_transaction():
 #s_false(self.conn.in_transaction())
 #ith context.begin_transaction(_per_migration=True):
 #s_true(self.conn.in_transaction())

 #ith context.autocommit_block():
                    # in 1.x, self.conn is separate due to the
                    # execution_options call.  however for future they are the
                    # same connection and there is a "transaction" block
                    # despite autocommit
 #f self.is_sqlalchemy_future:
 #s_(context.connection, self.conn)
 #lse:
 #s_not_(context.connection, self.conn)
 #s_false(self.conn.in_transaction())

 #q_(
 #ontext.connection._execution_options[
 #isolation_level"
 #,
 #AUTOCOMMIT",
 #

 #e_(
 #ontext.connection._execution_options.get(
 #isolation_level", None
 #,
 #AUTOCOMMIT",
 #
 #s_true(self.conn.in_transaction())

 #s_false(self.conn.in_transaction())
 #s_false(self.conn.in_transaction())

 #config.requirements.autocommit_isolation
 #ef test_autocommit_block_no_transaction(self):
 #ontext = self._fixture({"transaction_per_migration": True})

 #s_false(self.conn.in_transaction())

 #ith context.autocommit_block():
 #s_true(context.connection.in_transaction())

            # in 1.x, self.conn is separate due to the execution_options
            # call.  however for future they are the same connection and there
            # is a "transaction" block despite autocommit
 #f self.is_sqlalchemy_future:
 #s_(context.connection, self.conn)
 #lse:
 #s_not_(context.connection, self.conn)
 #s_false(self.conn.in_transaction())

 #q_(
 #ontext.connection._execution_options["isolation_level"],
 #AUTOCOMMIT",
 #

 #e_(
 #ontext.connection._execution_options.get("isolation_level", None),
 #AUTOCOMMIT",
 #

 #s_false(self.conn.in_transaction())

 #ef test_autocommit_block_transactional_ddl_sqlmode(self):
 #ontext = self._fixture(
 #
 #transaction_per_migration": True,
 #transactional_ddl": True,
 #as_sql": True,
 #
 #

 #ith context.begin_transaction():
 #ontext.execute("step 1")
 #ith context.begin_transaction(_per_migration=True):
 #ontext.execute("step 2")

 #ith context.autocommit_block():
 #ontext.execute("step 3")

 #ontext.execute("step 4")

 #ontext.execute("step 5")

 #elf._assert_impl_steps(
 #step 1",
 #BEGIN",
 #step 2",
 #COMMIT",
 #step 3",
 #BEGIN",
 #step 4",
 #COMMIT",
 #step 5",
 #

 #ef test_autocommit_block_nontransactional_ddl_sqlmode(self):
 #ontext = self._fixture(
 #
 #transaction_per_migration": True,
 #transactional_ddl": False,
 #as_sql": True,
 #
 #

 #ith context.begin_transaction():
 #ontext.execute("step 1")
 #ith context.begin_transaction(_per_migration=True):
 #ontext.execute("step 2")

 #ith context.autocommit_block():
 #ontext.execute("step 3")

 #ontext.execute("step 4")

 #ontext.execute("step 5")

 #elf._assert_impl_steps(
 #step 1", "step 2", "step 3", "step 4", "step 5"
 #

 #ef _assert_impl_steps(self, *steps):
 #o_check = self.context.output_buffer.getvalue()

 #elf.context.impl.output_buffer = buf = io.StringIO()
 #or step in steps:
 #f step == "BEGIN":
 #elf.context.impl.emit_begin()
 #lif step == "COMMIT":
 #elf.context.impl.emit_commit()
 #lse:
 #elf.context.impl._exec(step)

 #q_(to_check, buf.getvalue())
