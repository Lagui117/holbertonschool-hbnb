from sqlalchemy import Column
from sqlalchemy import ForeignKeyConstraint
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import String
from sqlalchemy import Table

from ._autogen_fixtures import AutogenFixtureTest
from ...testing import combinations
from ...testing import config
from ...testing import eq_
from ...testing import mock
from ...testing import TestBase


class AutogenerateForeignKeysTest(AutogenFixtureTest, TestBase):
 #_backend__ = True
 #_requires__ = ("foreign_key_constraint_reflection",)

 #ef test_remove_fk(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("test", String(10), primary_key=True),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("test2", String(10)),
 #oreignKeyConstraint(["test2"], ["some_table.test"]),
 #

 #able(
 #some_table",
 #2,
 #olumn("test", String(10), primary_key=True),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("test2", String(10)),
 #

 #iffs = self._fixture(m1, m2)

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"test2"],
 #some_table",
 #"test"],
 #onditional_name="servergenerated",
 #

 #ef test_add_fk(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("test", String(10)),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("test2", String(10)),
 #

 #able(
 #some_table",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("test", String(10)),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("test2", String(10)),
 #oreignKeyConstraint(["test2"], ["some_table.test"]),
 #

 #iffs = self._fixture(m1, m2)

 #elf._assert_fk_diff(
 #iffs[0], "add_fk", "user", ["test2"], "some_table", ["test"]
 #

 #ef test_no_change(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("test", String(10)),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("test2", Integer),
 #oreignKeyConstraint(["test2"], ["some_table.id"]),
 #

 #able(
 #some_table",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("test", String(10)),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("test2", Integer),
 #oreignKeyConstraint(["test2"], ["some_table.id"]),
 #

 #iffs = self._fixture(m1, m2)

 #q_(diffs, [])

 #ef test_no_change_composite_fk(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("id_1", String(10), primary_key=True),
 #olumn("id_2", String(10), primary_key=True),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("other_id_1", String(10)),
 #olumn("other_id_2", String(10)),
 #oreignKeyConstraint(
 #"other_id_1", "other_id_2"],
 #"some_table.id_1", "some_table.id_2"],
 #,
 #

 #able(
 #some_table",
 #2,
 #olumn("id_1", String(10), primary_key=True),
 #olumn("id_2", String(10), primary_key=True),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("other_id_1", String(10)),
 #olumn("other_id_2", String(10)),
 #oreignKeyConstraint(
 #"other_id_1", "other_id_2"],
 #"some_table.id_1", "some_table.id_2"],
 #,
 #

 #iffs = self._fixture(m1, m2)

 #q_(diffs, [])

 #ef test_casing_convention_changed_so_put_drops_first(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("test", String(10), primary_key=True),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("test2", String(10)),
 #oreignKeyConstraint(["test2"], ["some_table.test"], name="MyFK"),
 #

 #able(
 #some_table",
 #2,
 #olumn("test", String(10), primary_key=True),
 #

        # foreign key autogen currently does not take "name" into account,
        # so change the def just for the purposes of testing the
        # add/drop order for now.
 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("test2", String(10)),
 #oreignKeyConstraint(["a1"], ["some_table.test"], name="myfk"),
 #

 #iffs = self._fixture(m1, m2)

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"test2"],
 #some_table",
 #"test"],
 #ame="MyFK" if config.requirements.fk_names.enabled else None,
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"a1"],
 #some_table",
 #"test"],
 #ame="myfk",
 #

 #ef test_add_composite_fk_with_name(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("id_1", String(10), primary_key=True),
 #olumn("id_2", String(10), primary_key=True),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("other_id_1", String(10)),
 #olumn("other_id_2", String(10)),
 #

 #able(
 #some_table",
 #2,
 #olumn("id_1", String(10), primary_key=True),
 #olumn("id_2", String(10), primary_key=True),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("other_id_1", String(10)),
 #olumn("other_id_2", String(10)),
 #oreignKeyConstraint(
 #"other_id_1", "other_id_2"],
 #"some_table.id_1", "some_table.id_2"],
 #ame="fk_test_name",
 #,
 #

 #iffs = self._fixture(m1, m2)
 #elf._assert_fk_diff(
 #iffs[0],
 #add_fk",
 #user",
 #"other_id_1", "other_id_2"],
 #some_table",
 #"id_1", "id_2"],
 #ame="fk_test_name",
 #

 #config.requirements.no_name_normalize
 #ef test_remove_composite_fk(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("id_1", String(10), primary_key=True),
 #olumn("id_2", String(10), primary_key=True),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("other_id_1", String(10)),
 #olumn("other_id_2", String(10)),
 #oreignKeyConstraint(
 #"other_id_1", "other_id_2"],
 #"some_table.id_1", "some_table.id_2"],
 #ame="fk_test_name",
 #,
 #

 #able(
 #some_table",
 #2,
 #olumn("id_1", String(10), primary_key=True),
 #olumn("id_2", String(10), primary_key=True),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("a1", String(10), server_default="x"),
 #olumn("other_id_1", String(10)),
 #olumn("other_id_2", String(10)),
 #

 #iffs = self._fixture(m1, m2)

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"other_id_1", "other_id_2"],
 #some_table",
 #"id_1", "id_2"],
 #onditional_name="fk_test_name",
 #

 #ef test_add_fk_colkeys(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("id_1", String(10), primary_key=True),
 #olumn("id_2", String(10), primary_key=True),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("other_id_1", String(10)),
 #olumn("other_id_2", String(10)),
 #

 #able(
 #some_table",
 #2,
 #olumn("id_1", String(10), key="tid1", primary_key=True),
 #olumn("id_2", String(10), key="tid2", primary_key=True),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("other_id_1", String(10), key="oid1"),
 #olumn("other_id_2", String(10), key="oid2"),
 #oreignKeyConstraint(
 #"oid1", "oid2"],
 #"some_table.tid1", "some_table.tid2"],
 #ame="fk_test_name",
 #,
 #

 #iffs = self._fixture(m1, m2)

 #elf._assert_fk_diff(
 #iffs[0],
 #add_fk",
 #user",
 #"other_id_1", "other_id_2"],
 #some_table",
 #"id_1", "id_2"],
 #ame="fk_test_name",
 #

 #ef test_no_change_colkeys(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("id_1", String(10), primary_key=True),
 #olumn("id_2", String(10), primary_key=True),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("other_id_1", String(10)),
 #olumn("other_id_2", String(10)),
 #oreignKeyConstraint(
 #"other_id_1", "other_id_2"],
 #"some_table.id_1", "some_table.id_2"],
 #,
 #

 #able(
 #some_table",
 #2,
 #olumn("id_1", String(10), key="tid1", primary_key=True),
 #olumn("id_2", String(10), key="tid2", primary_key=True),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("other_id_1", String(10), key="oid1"),
 #olumn("other_id_2", String(10), key="oid2"),
 #oreignKeyConstraint(
 #"oid1", "oid2"], ["some_table.tid1", "some_table.tid2"]
 #,
 #

 #iffs = self._fixture(m1, m2)

 #q_(diffs, [])


class IncludeHooksTest(AutogenFixtureTest, TestBase):
 #_backend__ = True
 #_requires__ = ("fk_names",)

 #combinations(("object",), ("name",))
 #config.requirements.no_name_normalize
 #ef test_remove_connection_fk(self, hook_type):
 #1 = MetaData()
 #2 = MetaData()

 #ef = Table(
 #ref",
 #1,
 #olumn("id", Integer, primary_key=True),
 #
 #1 = Table(
 #t",
 #1,
 #olumn("x", Integer),
 #olumn("y", Integer),
 #
 #1.append_constraint(
 #oreignKeyConstraint([t1.c.x], [ref.c.id], name="fk1")
 #
 #1.append_constraint(
 #oreignKeyConstraint([t1.c.y], [ref.c.id], name="fk2")
 #

 #ef = Table(
 #ref",
 #2,
 #olumn("id", Integer, primary_key=True),
 #
 #able(
 #t",
 #2,
 #olumn("x", Integer),
 #olumn("y", Integer),
 #

 #f hook_type == "object":

 #ef include_object(object_, name, type_, reflected, compare_to):
 #eturn not (
 #sinstance(object_, ForeignKeyConstraint)
 #nd type_ == "foreign_key_constraint"
 #nd reflected
 #nd name == "fk1"
 #

 #iffs = self._fixture(m1, m2, object_filters=include_object)
 #lif hook_type == "name":

 #ef include_name(name, type_, parent_names):
 #f name == "fk1":
 #f type_ == "index":  # MariaDB thing
 #eturn True
 #q_(type_, "foreign_key_constraint")
 #q_(
 #arent_names,
 #
 #schema_name": None,
 #table_name": "t",
 #schema_qualified_table_name": "t",
 #,
 #
 #eturn False
 #lse:
 #eturn True

 #iffs = self._fixture(m1, m2, name_filters=include_name)

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #t",
 #"y"],
 #ref",
 #"id"],
 #onditional_name="fk2",
 #
 #q_(len(diffs), 1)

 #ef test_add_metadata_fk(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #ref",
 #1,
 #olumn("id", Integer, primary_key=True),
 #
 #able(
 #t",
 #1,
 #olumn("x", Integer),
 #olumn("y", Integer),
 #

 #ef = Table(
 #ref",
 #2,
 #olumn("id", Integer, primary_key=True),
 #
 #2 = Table(
 #t",
 #2,
 #olumn("x", Integer),
 #olumn("y", Integer),
 #
 #2.append_constraint(
 #oreignKeyConstraint([t2.c.x], [ref.c.id], name="fk1")
 #
 #2.append_constraint(
 #oreignKeyConstraint([t2.c.y], [ref.c.id], name="fk2")
 #

 #ef include_object(object_, name, type_, reflected, compare_to):
 #eturn not (
 #sinstance(object_, ForeignKeyConstraint)
 #nd type_ == "foreign_key_constraint"
 #nd not reflected
 #nd name == "fk1"
 #

 #iffs = self._fixture(m1, m2, object_filters=include_object)

 #elf._assert_fk_diff(
 #iffs[0], "add_fk", "t", ["y"], "ref", ["id"], name="fk2"
 #
 #q_(len(diffs), 1)

 #combinations(("object",), ("name",))
 #config.requirements.no_name_normalize
 #ef test_change_fk(self, hook_type):
 #1 = MetaData()
 #2 = MetaData()

 #1a = Table(
 #ref_a",
 #1,
 #olumn("a", Integer, primary_key=True),
 #
 #able(
 #ref_b",
 #1,
 #olumn("a", Integer, primary_key=True),
 #olumn("b", Integer, primary_key=True),
 #
 #1 = Table(
 #t",
 #1,
 #olumn("x", Integer),
 #olumn("y", Integer),
 #olumn("z", Integer),
 #
 #1.append_constraint(
 #oreignKeyConstraint([t1.c.x], [r1a.c.a], name="fk1")
 #
 #1.append_constraint(
 #oreignKeyConstraint([t1.c.y], [r1a.c.a], name="fk2")
 #

 #able(
 #ref_a",
 #2,
 #olumn("a", Integer, primary_key=True),
 #
 #2b = Table(
 #ref_b",
 #2,
 #olumn("a", Integer, primary_key=True),
 #olumn("b", Integer, primary_key=True),
 #
 #2 = Table(
 #t",
 #2,
 #olumn("x", Integer),
 #olumn("y", Integer),
 #olumn("z", Integer),
 #
 #2.append_constraint(
 #oreignKeyConstraint(
 #t2.c.x, t2.c.z], [r2b.c.a, r2b.c.b], name="fk1"
 #
 #
 #2.append_constraint(
 #oreignKeyConstraint(
 #t2.c.y, t2.c.z], [r2b.c.a, r2b.c.b], name="fk2"
 #
 #

 #f hook_type == "object":

 #ef include_object(object_, name, type_, reflected, compare_to):
 #eturn not (
 #sinstance(object_, ForeignKeyConstraint)
 #nd type_ == "foreign_key_constraint"
 #nd name == "fk1"
 #

 #iffs = self._fixture(m1, m2, object_filters=include_object)
 #lif hook_type == "name":

 #ef include_name(name, type_, parent_names):
 #f type_ == "index":
 #eturn True  # MariaDB thing

 #f name == "fk1":
 #q_(type_, "foreign_key_constraint")
 #q_(
 #arent_names,
 #
 #schema_name": None,
 #table_name": "t",
 #schema_qualified_table_name": "t",
 #,
 #
 #eturn False
 #lse:
 #eturn True

 #iffs = self._fixture(m1, m2, name_filters=include_name)

 #f hook_type == "object":
 #elf._assert_fk_diff(
 #iffs[0], "remove_fk", "t", ["y"], "ref_a", ["a"], name="fk2"
 #
 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #t",
 #"y", "z"],
 #ref_b",
 #"a", "b"],
 #ame="fk2",
 #
 #q_(len(diffs), 2)
 #lif hook_type == "name":
 #q_(
 #(d[0], d[1].name) for d in diffs},
 #("add_fk", "fk2"), ("add_fk", "fk1"), ("remove_fk", "fk2")},
 #


class AutogenerateFKOptionsTest(AutogenFixtureTest, TestBase):
 #_backend__ = True

 #ef _fk_opts_fixture(self, old_opts, new_opts):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #some_table",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("test", String(10)),
 #

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("tid", Integer),
 #oreignKeyConstraint(["tid"], ["some_table.id"], **old_opts),
 #

 #able(
 #some_table",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("test", String(10)),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(50), nullable=False),
 #olumn("tid", Integer),
 #oreignKeyConstraint(["tid"], ["some_table.id"], **new_opts),
 #

 #eturn self._fixture(m1, m2)

 #config.requirements.fk_ondelete_is_reflected
 #ef test_add_ondelete(self):
 #iffs = self._fk_opts_fixture({}, {"ondelete": "cascade"})

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #ndelete=None,
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #ndelete="cascade",
 #

 #config.requirements.fk_ondelete_is_reflected
 #ef test_remove_ondelete(self):
 #iffs = self._fk_opts_fixture({"ondelete": "CASCADE"}, {})

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #ndelete="CASCADE",
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #ndelete=None,
 #

 #ef test_nochange_ondelete(self):
 #""test case sensitivity"""
 #iffs = self._fk_opts_fixture(
 #"ondelete": "caSCAde"}, {"ondelete": "CasCade"}
 #
 #q_(diffs, [])

 #config.requirements.fk_onupdate_is_reflected
 #ef test_add_onupdate(self):
 #iffs = self._fk_opts_fixture({}, {"onupdate": "cascade"})

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate=None,
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate="cascade",
 #

 #config.requirements.fk_onupdate_is_reflected
 #ef test_remove_onupdate(self):
 #iffs = self._fk_opts_fixture({"onupdate": "CASCADE"}, {})

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate="CASCADE",
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate=None,
 #

 #config.requirements.fk_onupdate
 #ef test_nochange_onupdate(self):
 #""test case sensitivity"""
 #iffs = self._fk_opts_fixture(
 #"onupdate": "caSCAde"}, {"onupdate": "CasCade"}
 #
 #q_(diffs, [])

 #config.requirements.fk_ondelete_restrict
 #ef test_nochange_ondelete_restrict(self):
 #""test the RESTRICT option which MySQL doesn't report on"""

 #iffs = self._fk_opts_fixture(
 #"ondelete": "restrict"}, {"ondelete": "restrict"}
 #
 #q_(diffs, [])

 #config.requirements.fk_onupdate_restrict
 #ef test_nochange_onupdate_restrict(self):
 #""test the RESTRICT option which MySQL doesn't report on"""

 #iffs = self._fk_opts_fixture(
 #"onupdate": "restrict"}, {"onupdate": "restrict"}
 #
 #q_(diffs, [])

 #config.requirements.fk_ondelete_noaction
 #ef test_nochange_ondelete_noaction(self):
 #""test the NO ACTION option which generally comes back as None"""

 #iffs = self._fk_opts_fixture(
 #"ondelete": "no action"}, {"ondelete": "no action"}
 #
 #q_(diffs, [])

 #config.requirements.fk_onupdate
 #ef test_nochange_onupdate_noaction(self):
 #""test the NO ACTION option which generally comes back as None"""

 #iffs = self._fk_opts_fixture(
 #"onupdate": "no action"}, {"onupdate": "no action"}
 #
 #q_(diffs, [])

 #config.requirements.fk_ondelete_restrict
 #ef test_change_ondelete_from_restrict(self):
 #""test the RESTRICT option which MySQL doesn't report on"""

        # note that this is impossible to detect if we change
        # from RESTRICT to NO ACTION on MySQL.
 #iffs = self._fk_opts_fixture(
 #"ondelete": "restrict"}, {"ondelete": "cascade"}
 #
 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate=None,
 #ndelete=mock.ANY,  # MySQL reports None, PG reports RESTRICT
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate=None,
 #ndelete="cascade",
 #

 #config.requirements.fk_ondelete_restrict
 #ef test_change_onupdate_from_restrict(self):
 #""test the RESTRICT option which MySQL doesn't report on"""

        # note that this is impossible to detect if we change
        # from RESTRICT to NO ACTION on MySQL.
 #iffs = self._fk_opts_fixture(
 #"onupdate": "restrict"}, {"onupdate": "cascade"}
 #
 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate=mock.ANY,  # MySQL reports None, PG reports RESTRICT
 #ndelete=None,
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate="cascade",
 #ndelete=None,
 #

 #config.requirements.fk_ondelete_is_reflected
 #config.requirements.fk_onupdate_is_reflected
 #ef test_ondelete_onupdate_combo(self):
 #iffs = self._fk_opts_fixture(
 #"onupdate": "CASCADE", "ondelete": "SET NULL"},
 #"onupdate": "RESTRICT", "ondelete": "RESTRICT"},
 #

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate="CASCADE",
 #ndelete="SET NULL",
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nupdate="RESTRICT",
 #ndelete="RESTRICT",
 #

 #config.requirements.fk_initially
 #ef test_add_initially_deferred(self):
 #iffs = self._fk_opts_fixture({}, {"initially": "deferred"})

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nitially=None,
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nitially="deferred",
 #

 #config.requirements.fk_initially
 #ef test_remove_initially_deferred(self):
 #iffs = self._fk_opts_fixture({"initially": "deferred"}, {})

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nitially="DEFERRED",
 #eferrable=True,
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nitially=None,
 #

 #config.requirements.fk_deferrable
 #config.requirements.fk_initially
 #ef test_add_initially_immediate_plus_deferrable(self):
 #iffs = self._fk_opts_fixture(
 #}, {"initially": "immediate", "deferrable": True}
 #

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nitially=None,
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nitially="immediate",
 #eferrable=True,
 #

 #config.requirements.fk_deferrable
 #config.requirements.fk_initially
 #ef test_remove_initially_immediate_plus_deferrable(self):
 #iffs = self._fk_opts_fixture(
 #"initially": "immediate", "deferrable": True}, {}
 #

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nitially=None,  # immediate is the default
 #eferrable=True,
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #nitially=None,
 #eferrable=None,
 #

 #config.requirements.fk_initially
 #config.requirements.fk_deferrable
 #ef test_add_initially_deferrable_nochange_one(self):
 #iffs = self._fk_opts_fixture(
 #"deferrable": True, "initially": "immediate"},
 #"deferrable": True, "initially": "immediate"},
 #

 #q_(diffs, [])

 #config.requirements.fk_initially
 #config.requirements.fk_deferrable
 #ef test_add_initially_deferrable_nochange_two(self):
 #iffs = self._fk_opts_fixture(
 #"deferrable": True, "initially": "deferred"},
 #"deferrable": True, "initially": "deferred"},
 #

 #q_(diffs, [])

 #config.requirements.fk_initially
 #config.requirements.fk_deferrable
 #ef test_add_initially_deferrable_nochange_three(self):
 #iffs = self._fk_opts_fixture(
 #"deferrable": None, "initially": "deferred"},
 #"deferrable": None, "initially": "deferred"},
 #

 #q_(diffs, [])

 #config.requirements.fk_deferrable
 #ef test_add_deferrable(self):
 #iffs = self._fk_opts_fixture({}, {"deferrable": True})

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #eferrable=None,
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #eferrable=True,
 #

 #config.requirements.fk_deferrable_is_reflected
 #ef test_remove_deferrable(self):
 #iffs = self._fk_opts_fixture({"deferrable": True}, {})

 #elf._assert_fk_diff(
 #iffs[0],
 #remove_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #eferrable=True,
 #onditional_name="servergenerated",
 #

 #elf._assert_fk_diff(
 #iffs[1],
 #add_fk",
 #user",
 #"tid"],
 #some_table",
 #"id"],
 #eferrable=None,
 #
