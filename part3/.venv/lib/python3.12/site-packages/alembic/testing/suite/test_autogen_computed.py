from contextlib import nullcontext

import sqlalchemy as sa
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import Table

from ._autogen_fixtures import AutogenFixtureTest
from ... import testing
from ...testing import config
from ...testing import eq_
from ...testing import expect_warnings
from ...testing import is_
from ...testing import is_true
from ...testing import mock
from ...testing import TestBase


class AutogenerateComputedTest(AutogenFixtureTest, TestBase):
 #_requires__ = ("computed_columns",)
 #_backend__ = True

 #ef _fixture_ctx(self):
 #f config.requirements.computed_columns_warn_no_persisted.enabled:
 #tx = expect_warnings()
 #lse:
 #tx = nullcontext()
 #eturn ctx

 #ef test_add_computed_column(self):
 #1 = MetaData()
 #2 = MetaData()

 #able("user", m1, Column("id", Integer, primary_key=True))

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("foo", Integer, sa.Computed("5")),
 #

 #ith self._fixture_ctx():
 #iffs = self._fixture(m1, m2)

 #q_(diffs[0][0], "add_column")
 #q_(diffs[0][2], "user")
 #q_(diffs[0][3].name, "foo")
 # = diffs[0][3].computed

 #s_true(isinstance(c, sa.Computed))
 #s_(c.persisted, None)
 #q_(str(c.sqltext), "5")

 #ef test_remove_computed_column(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("foo", Integer, sa.Computed("5")),
 #

 #able("user", m2, Column("id", Integer, primary_key=True))

 #ith self._fixture_ctx():
 #iffs = self._fixture(m1, m2)

 #q_(diffs[0][0], "remove_column")
 #q_(diffs[0][2], "user")
 # = diffs[0][3]
 #q_(c.name, "foo")

 #s_true(isinstance(c.computed, sa.Computed))
 #s_true(isinstance(c.server_default, sa.Computed))

 #testing.combinations(
 #ambda: (None, sa.Computed("bar*5")),
 #lambda: (sa.Computed("bar*5"), None)),
 #ambda: (
 #a.Computed("bar*5"),
 #a.Computed("bar * 42", persisted=True),
 #,
 #ambda: (sa.Computed("bar*5"), sa.Computed("bar * 42")),
 #
 #ef test_cant_change_computed_warning(self, test_case):
 #rg_before, arg_after = testing.resolve_lambda(test_case, **locals())
 #1 = MetaData()
 #2 = MetaData()

 #rg_before = [] if arg_before is None else [arg_before]
 #rg_after = [] if arg_after is None else [arg_after]

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("bar", Integer),
 #olumn("foo", Integer, *arg_before),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("bar", Integer),
 #olumn("foo", Integer, *arg_after),
 #

 #ith mock.patch("alembic.util.warn") as mock_warn, self._fixture_ctx():
 #iffs = self._fixture(m1, m2)

 #q_(
 #ock_warn.mock_calls,
 #mock.call("Computed default on user.foo cannot be modified")],
 #

 #q_(list(diffs), [])

 #testing.combinations(
 #ambda: (None, None),
 #ambda: (sa.Computed("5"), sa.Computed("5")),
 #ambda: (sa.Computed("bar*5"), sa.Computed("bar*5")),
 #ambda: (sa.Computed("bar*5"), sa.Computed("bar * \r\n\t5")),
 #
 #ef test_computed_unchanged(self, test_case):
 #rg_before, arg_after = testing.resolve_lambda(test_case, **locals())
 #1 = MetaData()
 #2 = MetaData()

 #rg_before = [] if arg_before is None else [arg_before]
 #rg_after = [] if arg_after is None else [arg_after]

 #able(
 #user",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("bar", Integer),
 #olumn("foo", Integer, *arg_before),
 #

 #able(
 #user",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("bar", Integer),
 #olumn("foo", Integer, *arg_after),
 #

 #ith mock.patch("alembic.util.warn") as mock_warn, self._fixture_ctx():
 #iffs = self._fixture(m1, m2)
 #q_(mock_warn.mock_calls, [])

 #q_(list(diffs), [])
