from sqlalchemy import BigInteger
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import Table
from sqlalchemy.testing import in_

from ._autogen_fixtures import AutogenFixtureTest
from ... import testing
from ...testing import config
from ...testing import eq_
from ...testing import is_
from ...testing import TestBase


class AlterColumnTest(AutogenFixtureTest, TestBase):
 #_backend__ = True

 #testing.combinations((True,), (False,))
 #config.requirements.comments
 #ef test_all_existings_filled(self, pk):
 #1 = MetaData()
 #2 = MetaData()

 #able("a", m1, Column("x", Integer, primary_key=pk))
 #able("a", m2, Column("x", Integer, comment="x", primary_key=pk))

 #lter_col = self._assert_alter_col(m1, m2, pk)
 #q_(alter_col.modify_comment, "x")

 #testing.combinations((True,), (False,))
 #config.requirements.comments
 #ef test_all_existings_filled_in_notnull(self, pk):
 #1 = MetaData()
 #2 = MetaData()

 #able("a", m1, Column("x", Integer, nullable=False, primary_key=pk))
 #able(
 #a",
 #2,
 #olumn("x", Integer, nullable=False, comment="x", primary_key=pk),
 #

 #elf._assert_alter_col(m1, m2, pk, nullable=False)

 #testing.combinations((True,), (False,))
 #config.requirements.comments
 #ef test_all_existings_filled_in_comment(self, pk):
 #1 = MetaData()
 #2 = MetaData()

 #able("a", m1, Column("x", Integer, comment="old", primary_key=pk))
 #able("a", m2, Column("x", Integer, comment="new", primary_key=pk))

 #lter_col = self._assert_alter_col(m1, m2, pk)
 #q_(alter_col.existing_comment, "old")

 #testing.combinations((True,), (False,))
 #config.requirements.comments
 #ef test_all_existings_filled_in_server_default(self, pk):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #a", m1, Column("x", Integer, server_default="5", primary_key=pk)
 #
 #able(
 #a",
 #2,
 #olumn(
 #x", Integer, server_default="5", comment="new", primary_key=pk
 #,
 #

 #lter_col = self._assert_alter_col(m1, m2, pk)
 #n_("5", alter_col.existing_server_default.arg.text)

 #ef _assert_alter_col(self, m1, m2, pk, nullable=None):
 #ps = self._fixture(m1, m2, return_ops=True)
 #odify_table = ops.ops[-1]
 #lter_col = modify_table.ops[0]

 #f nullable is None:
 #q_(alter_col.existing_nullable, not pk)
 #lse:
 #q_(alter_col.existing_nullable, nullable)
 #ssert alter_col.existing_type._compare_type_affinity(Integer())
 #eturn alter_col


class AutoincrementTest(AutogenFixtureTest, TestBase):
 #_backend__ = True
 #_requires__ = ("integer_subtype_comparisons",)

 #ef test_alter_column_autoincrement_none(self):
 #1 = MetaData()
 #2 = MetaData()

 #able("a", m1, Column("x", Integer, nullable=False))
 #able("a", m2, Column("x", Integer, nullable=True))

 #ps = self._fixture(m1, m2, return_ops=True)
 #ssert "autoincrement" not in ops.ops[0].ops[0].kw

 #ef test_alter_column_autoincrement_pk_false(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #a",
 #1,
 #olumn("x", Integer, primary_key=True, autoincrement=False),
 #
 #able(
 #a",
 #2,
 #olumn("x", BigInteger, primary_key=True, autoincrement=False),
 #

 #ps = self._fixture(m1, m2, return_ops=True)
 #s_(ops.ops[0].ops[0].kw["autoincrement"], False)

 #ef test_alter_column_autoincrement_pk_implicit_true(self):
 #1 = MetaData()
 #2 = MetaData()

 #able("a", m1, Column("x", Integer, primary_key=True))
 #able("a", m2, Column("x", BigInteger, primary_key=True))

 #ps = self._fixture(m1, m2, return_ops=True)
 #s_(ops.ops[0].ops[0].kw["autoincrement"], True)

 #ef test_alter_column_autoincrement_pk_explicit_true(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #a", m1, Column("x", Integer, primary_key=True, autoincrement=True)
 #
 #able(
 #a",
 #2,
 #olumn("x", BigInteger, primary_key=True, autoincrement=True),
 #

 #ps = self._fixture(m1, m2, return_ops=True)
 #s_(ops.ops[0].ops[0].kw["autoincrement"], True)

 #ef test_alter_column_autoincrement_nonpk_false(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #a",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer, autoincrement=False),
 #
 #able(
 #a",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", BigInteger, autoincrement=False),
 #

 #ps = self._fixture(m1, m2, return_ops=True)
 #s_(ops.ops[0].ops[0].kw["autoincrement"], False)

 #ef test_alter_column_autoincrement_nonpk_implicit_false(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #a",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer),
 #
 #able(
 #a",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", BigInteger),
 #

 #ps = self._fixture(m1, m2, return_ops=True)
 #ssert "autoincrement" not in ops.ops[0].ops[0].kw

 #ef test_alter_column_autoincrement_nonpk_explicit_true(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #a",
 #1,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("x", Integer, autoincrement=True),
 #
 #able(
 #a",
 #2,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("x", BigInteger, autoincrement=True),
 #

 #ps = self._fixture(m1, m2, return_ops=True)
 #s_(ops.ops[0].ops[0].kw["autoincrement"], True)

 #ef test_alter_column_autoincrement_compositepk_false(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #a",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer, primary_key=True, autoincrement=False),
 #
 #able(
 #a",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", BigInteger, primary_key=True, autoincrement=False),
 #

 #ps = self._fixture(m1, m2, return_ops=True)
 #s_(ops.ops[0].ops[0].kw["autoincrement"], False)

 #ef test_alter_column_autoincrement_compositepk_implicit_false(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #a",
 #1,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer, primary_key=True),
 #
 #able(
 #a",
 #2,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", BigInteger, primary_key=True),
 #

 #ps = self._fixture(m1, m2, return_ops=True)
 #ssert "autoincrement" not in ops.ops[0].ops[0].kw

 #config.requirements.autoincrement_on_composite_pk
 #ef test_alter_column_autoincrement_compositepk_explicit_true(self):
 #1 = MetaData()
 #2 = MetaData()

 #able(
 #a",
 #1,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("x", Integer, primary_key=True, autoincrement=True),
            # on SQLA 1.0 and earlier, this being present
            # trips the "add KEY for the primary key" so that the
            # AUTO_INCREMENT keyword is accepted by MySQL.  SQLA 1.1 and
            # greater the columns are just reorganized.
 #ysql_engine="InnoDB",
 #
 #able(
 #a",
 #2,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("x", BigInteger, primary_key=True, autoincrement=True),
 #

 #ps = self._fixture(m1, m2, return_ops=True)
 #s_(ops.ops[0].ops[0].kw["autoincrement"], True)
