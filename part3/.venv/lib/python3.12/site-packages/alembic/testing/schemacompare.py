from itertools import zip_longest

from sqlalchemy import schema
from sqlalchemy.sql.elements import ClauseList


class CompareTable:
 #ef __init__(self, table):
 #elf.table = table

 #ef __eq__(self, other):
 #f self.table.name != other.name or self.table.schema != other.schema:
 #eturn False

 #or c1, c2 in zip_longest(self.table.c, other.c):
 #f (c1 is None and c2 is not None) or (
 #2 is None and c1 is not None
 #:
 #eturn False
 #f CompareColumn(c1) != c2:
 #eturn False

 #eturn True

        # TODO: compare constraints, indexes

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)


class CompareColumn:
 #ef __init__(self, column):
 #elf.column = column

 #ef __eq__(self, other):
 #eturn (
 #elf.column.name == other.name
 #nd self.column.nullable == other.nullable
 #
        # TODO: datatypes etc

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)


class CompareIndex:
 #ef __init__(self, index, name_only=False):
 #elf.index = index
 #elf.name_only = name_only

 #ef __eq__(self, other):
 #f self.name_only:
 #eturn self.index.name == other.name
 #lse:
 #eturn (
 #tr(schema.CreateIndex(self.index))
 #= str(schema.CreateIndex(other))
 #nd self.index.dialect_kwargs == other.dialect_kwargs
 #

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)

 #ef __repr__(self):
 #xpr = ClauseList(*self.index.expressions)
 #ry:
 #xpr_str = expr.compile().string
 #xcept Exception:
 #xpr_str = str(expr)
 #eturn f"<CompareIndex {self.index.name}({expr_str})>"


class CompareCheckConstraint:
 #ef __init__(self, constraint):
 #elf.constraint = constraint

 #ef __eq__(self, other):
 #eturn (
 #sinstance(other, schema.CheckConstraint)
 #nd self.constraint.name == other.name
 #nd (str(self.constraint.sqltext) == str(other.sqltext))
 #nd (other.table.name == self.constraint.table.name)
 #nd other.table.schema == self.constraint.table.schema
 #

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)


class CompareForeignKey:
 #ef __init__(self, constraint):
 #elf.constraint = constraint

 #ef __eq__(self, other):
 #1 = (
 #sinstance(other, schema.ForeignKeyConstraint)
 #nd self.constraint.name == other.name
 #nd (other.table.name == self.constraint.table.name)
 #nd other.table.schema == self.constraint.table.schema
 #
 #f not r1:
 #eturn False
 #or c1, c2 in zip_longest(self.constraint.columns, other.columns):
 #f (c1 is None and c2 is not None) or (
 #2 is None and c1 is not None
 #:
 #eturn False
 #f CompareColumn(c1) != c2:
 #eturn False
 #eturn True

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)


class ComparePrimaryKey:
 #ef __init__(self, constraint):
 #elf.constraint = constraint

 #ef __eq__(self, other):
 #1 = (
 #sinstance(other, schema.PrimaryKeyConstraint)
 #nd self.constraint.name == other.name
 #nd (other.table.name == self.constraint.table.name)
 #nd other.table.schema == self.constraint.table.schema
 #
 #f not r1:
 #eturn False

 #or c1, c2 in zip_longest(self.constraint.columns, other.columns):
 #f (c1 is None and c2 is not None) or (
 #2 is None and c1 is not None
 #:
 #eturn False
 #f CompareColumn(c1) != c2:
 #eturn False

 #eturn True

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)


class CompareUniqueConstraint:
 #ef __init__(self, constraint):
 #elf.constraint = constraint

 #ef __eq__(self, other):
 #1 = (
 #sinstance(other, schema.UniqueConstraint)
 #nd self.constraint.name == other.name
 #nd (other.table.name == self.constraint.table.name)
 #nd other.table.schema == self.constraint.table.schema
 #
 #f not r1:
 #eturn False

 #or c1, c2 in zip_longest(self.constraint.columns, other.columns):
 #f (c1 is None and c2 is not None) or (
 #2 is None and c1 is not None
 #:
 #eturn False
 #f CompareColumn(c1) != c2:
 #eturn False

 #eturn True

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)
