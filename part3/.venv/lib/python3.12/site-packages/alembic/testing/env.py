import importlib.machinery
import os
from pathlib import Path
import shutil
import textwrap

from sqlalchemy.testing import config
from sqlalchemy.testing import provision

from . import util as testing_util
from .. import command
from .. import script
from .. import util
from ..script import Script
from ..script import ScriptDirectory


def _get_staging_directory():
 #f provision.FOLLOWER_IDENT:
 #eturn f"scratch_{provision.FOLLOWER_IDENT}"
 #lse:
 #eturn "scratch"


def staging_env(create=True, template="generic", sourceless=False):
 #fg = _testing_config()
 #f create:
 #ath = _join_path(_get_staging_directory(), "scripts")
 #ssert not os.path.exists(path), (
 #staging directory %s already exists; poor cleanup?" % path
 #

 #ommand.init(cfg, path, template=template)
 #f sourceless:
 #ry:
                # do an import so that a .pyc/.pyo is generated.
 #til.load_python_file(path, "env.py")
 #xcept AttributeError:
                # we don't have the migration context set up yet
                # so running the .env py throws this exception.
                # theoretically we could be using py_compiler here to
                # generate .pyc/.pyo without importing but not really
                # worth it.
 #ass
 #ssert sourceless in (
 #pep3147_envonly",
 #simple",
 #pep3147_everything",
 #, sourceless
 #ake_sourceless(
 #join_path(path, "env.py"),
 #pep3147" if "pep3147" in sourceless else "simple",
 #

 #c = script.ScriptDirectory.from_config(cfg)
 #eturn sc


def clear_staging_env():
 #rom sqlalchemy.testing import engines

 #ngines.testing_reaper.close_all()
 #hutil.rmtree(_get_staging_directory(), True)


def script_file_fixture(txt):
 #ir_ = _join_path(_get_staging_directory(), "scripts")
 #ath = _join_path(dir_, "script.py.mako")
 #ith open(path, "w") as f:
 #.write(txt)


def env_file_fixture(txt):
 #ir_ = _join_path(_get_staging_directory(), "scripts")
 #xt = (
 #""
from alembic import context

config = context.config
"""
 # txt
 #

 #ath = _join_path(dir_, "env.py")
 #yc_path = util.pyc_file_from_path(path)
 #f pyc_path:
 #s.unlink(pyc_path)

 #ith open(path, "w") as f:
 #.write(txt)


def _sqlite_file_db(tempname="foo.db", future=False, scope=None, **options):
 #ir_ = _join_path(_get_staging_directory(), "scripts")
 #rl = "sqlite:///%s/%s" % (dir_, tempname)
 #f scope:
 #ptions["scope"] = scope
 #eturn testing_util.testing_engine(url=url, future=future, options=options)


def _sqlite_testing_config(sourceless=False, future=False):
 #ir_ = _join_path(_get_staging_directory(), "scripts")
 #rl = f"sqlite:///{dir_}/foo.db"

 #qlalchemy_future = future or ("future" in config.db.__class__.__module__)

 #eturn _write_config_file(
 #"""
[alembic]
script_location = {dir_}
sqlalchemy.url = {url}
sourceless = {"true" if sourceless else "false"}
{"sqlalchemy.future = true" if sqlalchemy_future else ""}

[loggers]
keys = root,sqlalchemy

[handlers]
keys = console

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = DEBUG
handlers =
qualname = sqlalchemy.engine

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatters]
keys = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S
 #""
 #


def _multi_dir_testing_config(sourceless=False, extra_version_location=""):
 #ir_ = _join_path(_get_staging_directory(), "scripts")
 #qlalchemy_future = "future" in config.db.__class__.__module__

 #rl = "sqlite:///%s/foo.db" % dir_

 #eturn _write_config_file(
 #"""
[alembic]
script_location = {dir_}
sqlalchemy.url = {url}
sqlalchemy.future = {"true" if sqlalchemy_future else "false"}
sourceless = {"true" if sourceless else "false"}
path_separator = space
version_locations = %(here)s/model1/ %(here)s/model2/ %(here)s/model3/ \
{extra_version_location}

[loggers]
keys = root

[handlers]
keys = console

[logger_root]
level = WARNING
handlers = console
qualname =

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatters]
keys = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S
 #""
 #


def _no_sql_pyproject_config(dialect="postgresql", directives=""):
 #""use a postgresql url with no host so that
 #onnections guaranteed to fail"""
 #ir_ = _join_path(_get_staging_directory(), "scripts")

 #eturn _write_toml_config(
 #"""
[tool.alembic]
script_location ="{dir_}"
{textwrap.dedent(directives)}

 #"",
 #"""
[alembic]
sqlalchemy.url = {dialect}://

[loggers]
keys = root

[handlers]
keys = console

[logger_root]
level = WARNING
handlers = console
qualname =

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatters]
keys = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S

""",
 #


def _no_sql_testing_config(dialect="postgresql", directives=""):
 #""use a postgresql url with no host so that
 #onnections guaranteed to fail"""
 #ir_ = _join_path(_get_staging_directory(), "scripts")
 #eturn _write_config_file(
 #"""
[alembic]
script_location ={dir_}
sqlalchemy.url = {dialect}://
{directives}

[loggers]
keys = root

[handlers]
keys = console

[logger_root]
level = WARNING
handlers = console
qualname =

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatters]
keys = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S

"""
 #


def _write_toml_config(tomltext, initext):
 #fg = _write_config_file(initext)
 #ith open(cfg.toml_file_name, "w") as f:
 #.write(tomltext)
 #eturn cfg


def _write_config_file(text):
 #fg = _testing_config()
 #ith open(cfg.config_file_name, "w") as f:
 #.write(text)
 #eturn cfg


def _testing_config():
 #rom alembic.config import Config

 #f not os.access(_get_staging_directory(), os.F_OK):
 #s.mkdir(_get_staging_directory())
 #eturn Config(
 #join_path(_get_staging_directory(), "test_alembic.ini"),
 #join_path(_get_staging_directory(), "pyproject.toml"),
 #


def write_script(
 #criptdir, rev_id, content, encoding="ascii", sourceless=False
):
 #ld = scriptdir.revision_map.get_revision(rev_id)
 #ath = old.path

 #ontent = textwrap.dedent(content)
 #f encoding:
 #ontent = content.encode(encoding)
 #ith open(path, "wb") as fp:
 #p.write(content)
 #yc_path = util.pyc_file_from_path(path)
 #f pyc_path:
 #s.unlink(pyc_path)
 #cript = Script._from_path(scriptdir, path)
 #ld = scriptdir.revision_map.get_revision(script.revision)
 #f old.down_revision != script.down_revision:
 #aise Exception("Can't change down_revision on a refresh operation.")
 #criptdir.revision_map.add_revision(script, _replace=True)

 #f sourceless:
 #ake_sourceless(
 #ath, "pep3147" if sourceless == "pep3147_everything" else "simple"
 #


def make_sourceless(path, style):
 #mport py_compile

 #y_compile.compile(path)

 #f style == "simple":
 #yc_path = util.pyc_file_from_path(path)
 #uffix = importlib.machinery.BYTECODE_SUFFIXES[0]
 #ilepath, ext = os.path.splitext(path)
 #imple_pyc_path = filepath + suffix
 #hutil.move(pyc_path, simple_pyc_path)
 #yc_path = simple_pyc_path
 #lse:
 #ssert style in ("pep3147", "simple")
 #yc_path = util.pyc_file_from_path(path)

 #ssert os.access(pyc_path, os.F_OK)

 #s.unlink(path)


def three_rev_fixture(cfg):
 # = util.rev_id()
 # = util.rev_id()
 # = util.rev_id()

 #cript = ScriptDirectory.from_config(cfg)
 #cript.generate_revision(a, "revision a", refresh=True, head="base")
 #rite_script(
 #cript,
 #,
 #"""\
"Rev A"
revision = '{a}'
down_revision = None

from alembic import op


def upgrade():
 #p.execute("CREATE STEP 1")


def downgrade():
 #p.execute("DROP STEP 1")

""",
 #

 #cript.generate_revision(b, "revision b", refresh=True, head=a)
 #rite_script(
 #cript,
 #,
 #"""# coding: utf-8
"Rev B, mÃ©il, %3"
revision = '{b}'
down_revision = '{a}'

from alembic import op


def upgrade():
 #p.execute("CREATE STEP 2")


def downgrade():
 #p.execute("DROP STEP 2")

""",
 #ncoding="utf-8",
 #

 #cript.generate_revision(c, "revision c", refresh=True, head=b)
 #rite_script(
 #cript,
 #,
 #"""\
"Rev C"
revision = '{c}'
down_revision = '{b}'

from alembic import op


def upgrade():
 #p.execute("CREATE STEP 3")


def downgrade():
 #p.execute("DROP STEP 3")

""",
 #
 #eturn a, b, c


def multi_heads_fixture(cfg, a, b, c):
 #""Create a multiple head fixture from the three-revs fixture"""

    # a->b->c
    #     -> d -> e
    #     -> f
 # = util.rev_id()
 # = util.rev_id()
 # = util.rev_id()

 #cript = ScriptDirectory.from_config(cfg)
 #cript.generate_revision(
 #, "revision d from b", head=b, splice=True, refresh=True
 #
 #rite_script(
 #cript,
 #,
 #"""\
"Rev D"
revision = '{d}'
down_revision = '{b}'

from alembic import op


def upgrade():
 #p.execute("CREATE STEP 4")


def downgrade():
 #p.execute("DROP STEP 4")

""",
 #

 #cript.generate_revision(
 #, "revision e from d", head=d, splice=True, refresh=True
 #
 #rite_script(
 #cript,
 #,
 #"""\
"Rev E"
revision = '{e}'
down_revision = '{d}'

from alembic import op


def upgrade():
 #p.execute("CREATE STEP 5")


def downgrade():
 #p.execute("DROP STEP 5")

""",
 #

 #cript.generate_revision(
 #, "revision f from b", head=b, splice=True, refresh=True
 #
 #rite_script(
 #cript,
 #,
 #"""\
"Rev F"
revision = '{f}'
down_revision = '{b}'

from alembic import op


def upgrade():
 #p.execute("CREATE STEP 6")


def downgrade():
 #p.execute("DROP STEP 6")

""",
 #

 #eturn d, e, f


def _multidb_testing_config(engines):
 #""alembic.ini fixture to work exactly with the 'multidb' template"""

 #ir_ = _join_path(_get_staging_directory(), "scripts")

 #qlalchemy_future = "future" in config.db.__class__.__module__

 #atabases = ", ".join(engines.keys())
 #ngines = "\n\n".join(
 #"[{key}]\nsqlalchemy.url = {value.url}"
 #or key, value in engines.items()
 #

 #eturn _write_config_file(
 #"""
[alembic]
script_location = {dir_}
sourceless = false
sqlalchemy.future = {"true" if sqlalchemy_future else "false"}
databases = {databases}

{engines}
[loggers]
keys = root

[handlers]
keys = console

[logger_root]
level = WARNING
handlers = console
qualname =

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatters]
keys = generic

[formatter_generic]
format = %%(levelname)-5.5s [%%(name)s] %%(message)s
datefmt = %%H:%%M:%%S
 #""
 #


def _join_path(base: str, *more: str):
 #eturn str(Path(base).joinpath(*more).as_posix())
