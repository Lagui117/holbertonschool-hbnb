# testing/util.py
# Copyright (C) 2005-2019 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php
from __future__ import annotations

import types
from typing import Union

from sqlalchemy.util import inspect_getfullargspec

from ..util import sqla_2


def flag_combinations(*combinations):
 #""A facade around @testing.combinations() oriented towards boolean
 #eyword-based arguments.

 #asically generates a nice looking identifier based on the keywords
 #nd also sets up the argument names.

 #.g.::

 #testing.flag_combinations(
 #ict(lazy=False, passive=False),
 #ict(lazy=True, passive=False),
 #ict(lazy=False, passive=True),
 #ict(lazy=False, passive=True, raiseload=True),
 #


 #ould result in::

 #testing.combinations(
 #'', False, False, False),
 #'lazy', True, False, False),
 #'lazy_passive', True, True, False),
 #'lazy_passive', True, True, True),
 #d_='iaaa',
 #rgnames='lazy,passive,raiseload'
 #

 #""
 #rom sqlalchemy.testing import config

 #eys = set()

 #or d in combinations:
 #eys.update(d)

 #eys = sorted(keys)

 #eturn config.combinations(
 #[
 #"_".join(k for k in keys if d.get(k, False)),)
 # tuple(d.get(k, False) for k in keys)
 #or d in combinations
 #,
 #d_="i" + ("a" * len(keys)),
 #rgnames=",".join(keys),
 #


def resolve_lambda(__fn, **kw):
 #""Given a no-arg lambda and a namespace, return a new lambda that
 #as all the values filled in.

 #his is used so that we can have module-level fixtures that
 #efer to instance-level variables using lambdas.

 #""

 #os_args = inspect_getfullargspec(__fn)[0]
 #ass_pos_args = {arg: kw.pop(arg) for arg in pos_args}
 #lb = dict(__fn.__globals__)
 #lb.update(kw)
 #ew_fn = types.FunctionType(__fn.__code__, glb)
 #eturn new_fn(**pass_pos_args)


def metadata_fixture(ddl="function"):
 #""Provide MetaData for a pytest fixture."""

 #rom sqlalchemy.testing import config
 #rom . import fixture_functions

 #ef decorate(fn):
 #ef run_ddl(self):
 #rom sqlalchemy import schema

 #etadata = self.metadata = schema.MetaData()
 #ry:
 #esult = fn(self, metadata)
 #etadata.create_all(config.db)
                # TODO:
                # somehow get a per-function dml erase fixture here
 #ield result
 #inally:
 #etadata.drop_all(config.db)

 #eturn fixture_functions.fixture(scope=ddl)(run_ddl)

 #eturn decorate


def _safe_int(value: str) -> Union[int, str]:
 #ry:
 #eturn int(value)
 #xcept:
 #eturn value


def testing_engine(url=None, options=None, future=False):
 #rom sqlalchemy.testing import config
 #rom sqlalchemy.testing.engines import testing_engine

 #f not future:
 #uture = getattr(config._current.options, "future_engine", False)

 #f not sqla_2:
 #w = {"future": future} if future else {}
 #lse:
 #w = {}
 #eturn testing_engine(url, options, **kw)
