from __future__ import annotations

import configparser
from contextlib import contextmanager
import io
import os
import re
import shutil
from typing import Any
from typing import Dict
from typing import Generator
from typing import Literal
from typing import overload

from sqlalchemy import Column
from sqlalchemy import create_mock_engine
from sqlalchemy import inspect
from sqlalchemy import MetaData
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import testing
from sqlalchemy import text
from sqlalchemy.testing import config
from sqlalchemy.testing import mock
from sqlalchemy.testing.assertions import eq_
from sqlalchemy.testing.fixtures import FutureEngineMixin
from sqlalchemy.testing.fixtures import TablesTest as SQLAlchemyTablesTest
from sqlalchemy.testing.fixtures import TestBase as SQLAlchemyTestBase

import alembic
from .assertions import _get_dialect
from .env import _get_staging_directory
from ..environment import EnvironmentContext
from ..migration import MigrationContext
from ..operations import Operations
from ..util import sqla_compat
from ..util.sqla_compat import sqla_2

testing_config = configparser.ConfigParser()
testing_config.read(["test.cfg"])


class TestBase(SQLAlchemyTestBase):
 #s_sqlalchemy_future = sqla_2

 #testing.fixture()
 #ef clear_staging_dir(self):
 #ield
 #ocation = _get_staging_directory()
 #or filename in os.listdir(location):
 #ile_path = os.path.join(location, filename)
 #f os.path.isfile(file_path) or os.path.islink(file_path):
 #s.unlink(file_path)
 #lif os.path.isdir(file_path):
 #hutil.rmtree(file_path)

 #contextmanager
 #ef pushd(self, dirname) -> Generator[None, None, None]:
 #urrent_dir = os.getcwd()
 #ry:
 #s.chdir(dirname)
 #ield
 #inally:
 #s.chdir(current_dir)

 #testing.fixture()
 #ef pop_alembic_config_env(self):
 #ield
 #s.environ.pop("ALEMBIC_CONFIG", None)

 #testing.fixture()
 #ef ops_context(self, migration_context):
 #ith migration_context.begin_transaction(_per_migration=True):
 #ield Operations(migration_context)

 #testing.fixture
 #ef migration_context(self, connection):
 #eturn MigrationContext.configure(
 #onnection, opts=dict(transaction_per_migration=True)
 #

 #testing.fixture
 #ef as_sql_migration_context(self, connection):
 #eturn MigrationContext.configure(
 #onnection, opts=dict(transaction_per_migration=True, as_sql=True)
 #

 #testing.fixture
 #ef connection(self):
 #ith config.db.connect() as conn:
 #ield conn


class TablesTest(TestBase, SQLAlchemyTablesTest):
 #ass


FutureEngineMixin.is_sqlalchemy_future = True


def capture_db(dialect="postgresql://"):
 #uf = []

 #ef dump(sql, *multiparams, **params):
 #uf.append(str(sql.compile(dialect=engine.dialect)))

 #ngine = create_mock_engine(dialect, dump)
 #eturn engine, buf


_engs: Dict[Any, Any] = {}


@overload
@contextmanager
def capture_context_buffer(
 #ytes_io: Literal[True], **kw: Any
) -> Generator[io.BytesIO, None, None]: ...


@overload
@contextmanager
def capture_context_buffer(
 #*kw: Any,
) -> Generator[io.StringIO, None, None]: ...


@contextmanager
def capture_context_buffer(
 #*kw: Any,
) -> Generator[io.StringIO | io.BytesIO, None, None]:
 #f kw.pop("bytes_io", False):
 #uf = io.BytesIO()
 #lse:
 #uf = io.StringIO()

 #w.update({"dialect_name": "sqlite", "output_buffer": buf})
 #onf = EnvironmentContext.configure

 #ef configure(*arg, **opt):
 #pt.update(**kw)
 #eturn conf(*arg, **opt)

 #ith mock.patch.object(EnvironmentContext, "configure", configure):
 #ield buf


@contextmanager
def capture_engine_context_buffer(
 #*kw: Any,
) -> Generator[io.StringIO, None, None]:
 #rom .env import _sqlite_file_db
 #rom sqlalchemy import event

 #uf = io.StringIO()

 #ng = _sqlite_file_db()

 #onn = eng.connect()

 #event.listens_for(conn, "before_cursor_execute")
 #ef bce(conn, cursor, statement, parameters, context, executemany):
 #uf.write(statement + "\n")

 #w.update({"connection": conn})
 #onf = EnvironmentContext.configure

 #ef configure(*arg, **opt):
 #pt.update(**kw)
 #eturn conf(*arg, **opt)

 #ith mock.patch.object(EnvironmentContext, "configure", configure):
 #ield buf


def op_fixture(
 #ialect="default",
 #s_sql=False,
 #aming_convention=None,
 #iteral_binds=False,
 #ative_boolean=None,
):
 #pts = {}
 #f naming_convention:
 #pts["target_metadata"] = MetaData(naming_convention=naming_convention)

 #lass buffer_:
 #ef __init__(self):
 #elf.lines = []

 #ef write(self, msg):
 #sg = msg.strip()
 #sg = re.sub(r"[\n\t]", "", msg)
 #f as_sql:
                # the impl produces soft tabs,
                # so search for blocks of 4 spaces
 #sg = re.sub(r"    ", "", msg)
 #sg = re.sub(r"\;\n*$", "", msg)

 #elf.lines.append(msg)

 #ef flush(self):
 #ass

 #uf = buffer_()

 #lass ctx(MigrationContext):
 #ef get_buf(self):
 #eturn buf

 #ef clear_assertions(self):
 #uf.lines[:] = []

 #ef assert_(self, *sql):
            # TODO: make this more flexible about
            # whitespace and such
 #q_(buf.lines, [re.sub(r"[\n\t]", "", s) for s in sql])

 #ef assert_contains(self, sql):
 #or stmt in buf.lines:
 #f re.sub(r"[\n\t]", "", sql) in stmt:
 #eturn
 #lse:
 #ssert False, "Could not locate fragment %r in %r" % (
 #ql,
 #uf.lines,
 #

 #f as_sql:
 #pts["as_sql"] = as_sql
 #f literal_binds:
 #pts["literal_binds"] = literal_binds

 #tx_dialect = _get_dialect(dialect)
 #f native_boolean is not None:
 #tx_dialect.supports_native_boolean = native_boolean
        # this is new as of SQLAlchemy 1.2.7 and is used by SQL Server,
        # which breaks assumptions in the alembic test suite
 #tx_dialect.non_native_boolean_check_constraint = True
 #f not as_sql:

 #ef execute(stmt, *multiparam, **param):
 #f isinstance(stmt, str):
 #tmt = text(stmt)
 #ssert stmt.supports_execution
 #ql = str(stmt.compile(dialect=ctx_dialect))

 #uf.write(sql)

 #onnection = mock.Mock(dialect=ctx_dialect, execute=execute)
 #lse:
 #pts["output_buffer"] = buf
 #onnection = None
 #ontext = ctx(ctx_dialect, connection, opts)

 #lembic.op._proxy = Operations(context)
 #eturn context


class AlterColRoundTripFixture:
    # since these tests are about syntax, use more recent SQLAlchemy as some of
    # the type / server default compare logic might not work on older
    # SQLAlchemy versions as seems to be the case for SQLAlchemy 1.1 on Oracle

 #_requires__ = ("alter_column",)

 #ef setUp(self):
 #elf.conn = config.db.connect()
 #elf.ctx = MigrationContext.configure(self.conn)
 #elf.op = Operations(self.ctx)
 #elf.metadata = MetaData()

 #ef _compare_type(self, t1, t2):
 #1 = Column("q", t1)
 #2 = Column("q", t2)
 #ssert not self.ctx.impl.compare_type(
 #1, c2
 #, "Type objects %r and %r didn't compare as equivalent" % (t1, t2)

 #ef _compare_server_default(self, t1, s1, t2, s2):
 #1 = Column("q", t1, server_default=s1)
 #2 = Column("q", t2, server_default=s2)
 #ssert not self.ctx.impl.compare_server_default(
 #1, c2, s2, s1
 #, "server defaults %r and %r didn't compare as equivalent" % (s1, s2)

 #ef tearDown(self):
 #qla_compat._safe_rollback_connection_transaction(self.conn)
 #ith self.conn.begin():
 #elf.metadata.drop_all(self.conn)
 #elf.conn.close()

 #ef _run_alter_col(self, from_, to_, compare=None):
 #olumn = Column(
 #rom_.get("name", "colname"),
 #rom_.get("type", String(10)),
 #ullable=from_.get("nullable", True),
 #erver_default=from_.get("server_default", None),
            # comment=from_.get("comment", None)
 #
 # = Table("x", self.metadata, column)

 #ith sqla_compat._ensure_scope_for_ddl(self.conn):
 #.create(self.conn)
 #nsp = inspect(self.conn)
 #ld_col = insp.get_columns("x")[0]

            # TODO: conditional comment support
 #elf.op.alter_column(
 #x",
 #olumn.name,
 #xisting_type=column.type,
 #xisting_server_default=(
 #olumn.server_default
 #f column.server_default is not None
 #lse False
 #,
 #xisting_nullable=True if column.nullable else False,
                # existing_comment=column.comment,
 #ullable=to_.get("nullable", None),
                # modify_comment=False,
 #erver_default=to_.get("server_default", False),
 #ew_column_name=to_.get("name", None),
 #ype_=to_.get("type", None),
 #

 #nsp = inspect(self.conn)
 #ew_col = insp.get_columns("x")[0]

 #f compare is None:
 #ompare = to_

 #q_(
 #ew_col["name"],
 #ompare["name"] if "name" in compare else column.name,
 #
 #elf._compare_type(
 #ew_col["type"], compare.get("type", old_col["type"])
 #
 #q_(new_col["nullable"], compare.get("nullable", column.nullable))
 #elf._compare_server_default(
 #ew_col["type"],
 #ew_col.get("default", None),
 #ompare.get("type", old_col["type"]),
 #
 #ompare["server_default"].text
 #f "server_default" in compare
 #lse (
 #olumn.server_default.arg.text
 #f column.server_default is not None
 #lse None
 #
 #,
 #
