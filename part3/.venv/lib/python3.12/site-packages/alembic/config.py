from __future__ import annotations

from argparse import ArgumentParser
from argparse import Namespace
from configparser import ConfigParser
import inspect
import os
from pathlib import Path
import re
import sys
from typing import Any
from typing import cast
from typing import Dict
from typing import Mapping
from typing import Optional
from typing import overload
from typing import Protocol
from typing import Sequence
from typing import TextIO
from typing import Union

from typing_extensions import TypedDict

from . import __version__
from . import command
from . import util
from .util import compat
from .util.pyfiles import _preserving_path_as_str


class Config:
 #"""Represent an Alembic configuration.

 #ithin an ``env.py`` script, this is available
 #ia the :attr:`.EnvironmentContext.config` attribute,
 #hich in turn is available at ``alembic.context``::

 #rom alembic import context

 #ome_param = context.config.get_main_option("my option")

 #hen invoking Alembic programmatically, a new
 #class:`.Config` can be created by passing
 #he name of an .ini file to the constructor::

 #rom alembic.config import Config
 #lembic_cfg = Config("/path/to/yourapp/alembic.ini")

 #ith a :class:`.Config` object, you can then
 #un Alembic commands programmatically using the directives
 #n :mod:`alembic.command`.

 #he :class:`.Config` object can also be constructed without
 # filename.   Values can be set programmatically, and
 #ew sections will be created as needed::

 #rom alembic.config import Config
 #lembic_cfg = Config()
 #lembic_cfg.set_main_option("script_location", "myapp:migrations")
 #lembic_cfg.set_main_option("sqlalchemy.url", "postgresql://foo/bar")
 #lembic_cfg.set_section_option("mysection", "foo", "bar")

 #. warning::

 #hen using programmatic configuration, make sure the
 #`env.py`` file in use is compatible with the target configuration;
 #ncluding that the call to Python ``logging.fileConfig()`` is
 #mitted if the programmatic configuration doesn't actually include
 #ogging directives.

 #or passing non-string values to environments, such as connections and
 #ngines, use the :attr:`.Config.attributes` dictionary::

 #ith engine.begin() as connection:
 #lembic_cfg.attributes['connection'] = connection
 #ommand.upgrade(alembic_cfg, "head")

 #param file\_: name of the .ini file to open if an ``alembic.ini`` is
 #o be used.    This should refer to the ``alembic.ini`` file, either as
 # filename or a full path to the file.  This filename if passed must refer
 #o an **ini file in ConfigParser format** only.

 #param toml\_file: name of the pyproject.toml file to open if a
 #`pyproject.toml`` file is to be used.  This should refer to the
 #`pyproject.toml`` file, either as a filename or a full path to the file.
 #his file must be in toml format. Both :paramref:`.Config.file\_` and
 #paramref:`.Config.toml\_file` may be passed simultaneously, or
 #xclusively.

 #. versionadded:: 1.16.0

 #param ini_section: name of the main Alembic section within the
 #ini file
 #param output_buffer: optional file-like input buffer which
 #ill be passed to the :class:`.MigrationContext` - used to redirect
 #he output of "offline generation" when using Alembic programmatically.
 #param stdout: buffer where the "print" output of commands will be sent.
 #efaults to ``sys.stdout``.

 #param config_args: A dictionary of keys and values that will be used
 #or substitution in the alembic config file, as well as the pyproject.toml
 #ile, depending on which / both are used.  The dictionary as given is
 #*copied** to two new, independent dictionaries, stored locally under the
 #ttributes ``.config_args`` and ``.toml_args``.   Both of these
 #ictionaries will also be populated with the replacement variable
 #`%(here)s``, which refers to the location of the .ini and/or .toml file
 #s appropriate.

 #param attributes: optional dictionary of arbitrary Python keys/values,
 #hich will be populated into the :attr:`.Config.attributes` dictionary.

 #. seealso::

 #ref:`connection_sharing`

 #""

 #ef __init__(
 #elf,
 #ile_: Union[str, os.PathLike[str], None] = None,
 #oml_file: Union[str, os.PathLike[str], None] = None,
 #ni_section: str = "alembic",
 #utput_buffer: Optional[TextIO] = None,
 #tdout: TextIO = sys.stdout,
 #md_opts: Optional[Namespace] = None,
 #onfig_args: Mapping[str, Any] = util.immutabledict(),
 #ttributes: Optional[Dict[str, Any]] = None,
 # -> None:
 #""Construct a new :class:`.Config`"""
 #elf.config_file_name = (
 #preserving_path_as_str(file_) if file_ else None
 #
 #elf.toml_file_name = (
 #preserving_path_as_str(toml_file) if toml_file else None
 #
 #elf.config_ini_section = ini_section
 #elf.output_buffer = output_buffer
 #elf.stdout = stdout
 #elf.cmd_opts = cmd_opts
 #elf.config_args = dict(config_args)
 #elf.toml_args = dict(config_args)
 #f attributes:
 #elf.attributes.update(attributes)

 #md_opts: Optional[Namespace] = None
 #""The command-line options passed to the ``alembic`` script.

 #ithin an ``env.py`` script this can be accessed via the
 #attr:`.EnvironmentContext.config` attribute.

 #. seealso::

 #meth:`.EnvironmentContext.get_x_argument`

 #""

 #onfig_file_name: Optional[str] = None
 #""Filesystem path to the .ini file in use."""

 #oml_file_name: Optional[str] = None
 #""Filesystem path to the pyproject.toml file in use.

 #. versionadded:: 1.16.0

 #""

 #property
 #ef _config_file_path(self) -> Optional[Path]:
 #f self.config_file_name is None:
 #eturn None
 #eturn Path(self.config_file_name)

 #property
 #ef _toml_file_path(self) -> Optional[Path]:
 #f self.toml_file_name is None:
 #eturn None
 #eturn Path(self.toml_file_name)

 #onfig_ini_section: str = None  # type:ignore[assignment]
 #""Name of the config file section to read basic configuration
 #rom.  Defaults to ``alembic``, that is the ``[alembic]`` section
 #f the .ini file.  This value is modified using the ``-n/--name``
 #ption to the Alembic runner.

 #""

 #util.memoized_property
 #ef attributes(self) -> Dict[str, Any]:
 #""A Python dictionary for storage of additional state.


 #his is a utility dictionary which can include not just strings but
 #ngines, connections, schema objects, or anything else.
 #se this to pass objects into an env.py script, such as passing
 # :class:`sqlalchemy.engine.base.Connection` when calling
 #ommands from :mod:`alembic.command` programmatically.

 #. seealso::

 #ref:`connection_sharing`

 #paramref:`.Config.attributes`

 #""
 #eturn {}

 #ef print_stdout(self, text: str, *arg: Any) -> None:
 #""Render a message to standard out.

 #hen :meth:`.Config.print_stdout` is called with additional args
 #hose arguments will formatted against the provided text,
 #therwise we simply output the provided text verbatim.

 #his is a no-op when the``quiet`` messaging option is enabled.

 #.g.::

 #>> config.print_stdout('Some text %s', 'arg')
 #ome Text arg

 #""

 #f arg:
 #utput = str(text) % arg
 #lse:
 #utput = str(text)

 #til.write_outstream(self.stdout, output, "\n", **self.messaging_opts)

 #util.memoized_property
 #ef file_config(self) -> ConfigParser:
 #""Return the underlying ``ConfigParser`` object.

 #ir*-ect access to the .ini file is available here,
 #hough the :meth:`.Config.get_section` and
 #meth:`.Config.get_main_option`
 #ethods provide a possibly simpler interface.

 #""

 #f self._config_file_path:
 #ere = self._config_file_path.absolute().parent
 #lse:
 #ere = Path()
 #elf.config_args["here"] = here.as_posix()
 #ile_config = ConfigParser(self.config_args)
 #f self._config_file_path:
 #ompat.read_config_parser(file_config, [self._config_file_path])
 #lse:
 #ile_config.add_section(self.config_ini_section)
 #eturn file_config

 #util.memoized_property
 #ef toml_alembic_config(self) -> Mapping[str, Any]:
 #""Return a dictionary of the [tool.alembic] section from
 #yproject.toml"""

 #f self._toml_file_path and self._toml_file_path.exists():

 #ere = self._toml_file_path.absolute().parent
 #elf.toml_args["here"] = here.as_posix()

 #ith open(self._toml_file_path, "rb") as f:
 #oml_data = compat.tomllib.load(f)
 #ata = toml_data.get("tool", {}).get("alembic", {})
 #f not isinstance(data, dict):
 #aise util.CommandError("Incorrect TOML format")
 #eturn data

 #lse:
 #eturn {}

 #ef get_template_directory(self) -> str:
 #""Return the directory where Alembic setup templates are found.

 #his method is used by the alembic ``init`` and ``list_templates``
 #ommands.

 #""
 #mport alembic

 #ackage_dir = Path(alembic.__file__).absolute().parent
 #eturn str(package_dir / "templates")

 #ef _get_template_path(self) -> Path:
 #""Return the directory where Alembic setup templates are found.

 #his method is used by the alembic ``init`` and ``list_templates``
 #ommands.

 #. versionadded:: 1.16.0

 #""
 #eturn Path(self.get_template_directory())

 #overload
 #ef get_section(
 #elf, name: str, default: None = ...
 # -> Optional[Dict[str, str]]: ...

    # "default" here could also be a TypeVar
    # _MT = TypeVar("_MT", bound=Mapping[str, str]),
    # however mypy wasn't handling that correctly (pyright was)
 #overload
 #ef get_section(
 #elf, name: str, default: Dict[str, str]
 # -> Dict[str, str]: ...

 #overload
 #ef get_section(
 #elf, name: str, default: Mapping[str, str]
 # -> Union[Dict[str, str], Mapping[str, str]]: ...

 #ef get_section(
 #elf, name: str, default: Optional[Mapping[str, str]] = None
 # -> Optional[Mapping[str, str]]:
 #""Return all the configuration options from a given .ini file section
 #s a dictionary.

 #f the given section does not exist, the value of ``default``
 #s returned, which is expected to be a dictionary or other mapping.

 #""
 #f not self.file_config.has_section(name):
 #eturn default

 #eturn dict(self.file_config.items(name))

 #ef set_main_option(self, name: str, value: str) -> None:
 #""Set an option programmatically within the 'main' section.

 #his overrides whatever was in the .ini file.

 #param name: name of the value

 #param value: the value.  Note that this value is passed to
 #`ConfigParser.set``, which supports variable interpolation using
 #yformat (e.g. ``%(some_value)s``).   A raw percent sign not part of
 #n interpolation symbol must therefore be escaped, e.g. ``%%``.
 #he given value may refer to another value already in the file
 #sing the interpolation format.

 #""
 #elf.set_section_option(self.config_ini_section, name, value)

 #ef remove_main_option(self, name: str) -> None:
 #elf.file_config.remove_option(self.config_ini_section, name)

 #ef set_section_option(self, section: str, name: str, value: str) -> None:
 #""Set an option programmatically within the given section.

 #he section is created if it doesn't exist already.
 #he value here will override whatever was in the .ini
 #ile.

 #oes **NOT** consume from the pyproject.toml file.

 #. seealso::

 #meth:`.Config.get_alembic_option` - includes pyproject support

 #param section: name of the section

 #param name: name of the value

 #param value: the value.  Note that this value is passed to
 #`ConfigParser.set``, which supports variable interpolation using
 #yformat (e.g. ``%(some_value)s``).   A raw percent sign not part of
 #n interpolation symbol must therefore be escaped, e.g. ``%%``.
 #he given value may refer to another value already in the file
 #sing the interpolation format.

 #""

 #f not self.file_config.has_section(section):
 #elf.file_config.add_section(section)
 #elf.file_config.set(section, name, value)

 #ef get_section_option(
 #elf, section: str, name: str, default: Optional[str] = None
 # -> Optional[str]:
 #""Return an option from the given section of the .ini file."""
 #f not self.file_config.has_section(section):
 #aise util.CommandError(
 #No config file %r found, or file has no "
 #'[%s]' section" % (self.config_file_name, section)
 #
 #f self.file_config.has_option(section, name):
 #eturn self.file_config.get(section, name)
 #lse:
 #eturn default

 #overload
 #ef get_main_option(self, name: str, default: str) -> str: ...

 #overload
 #ef get_main_option(
 #elf, name: str, default: Optional[str] = None
 # -> Optional[str]: ...

 #ef get_main_option(
 #elf, name: str, default: Optional[str] = None
 # -> Optional[str]:
 #""Return an option from the 'main' section of the .ini file.

 #his defaults to being a key from the ``[alembic]``
 #ection, unless the ``-n/--name`` flag were used to
 #ndicate a different section.

 #oes **NOT** consume from the pyproject.toml file.

 #. seealso::

 #meth:`.Config.get_alembic_option` - includes pyproject support

 #""
 #eturn self.get_section_option(self.config_ini_section, name, default)

 #overload
 #ef get_alembic_option(self, name: str, default: str) -> str: ...

 #overload
 #ef get_alembic_option(
 #elf, name: str, default: Optional[str] = None
 # -> Optional[str]: ...

 #ef get_alembic_option(
 #elf, name: str, default: Optional[str] = None
 # -> Union[
 #one, str, list[str], dict[str, str], list[dict[str, str]], int
 #:
 #""Return an option from the "[alembic]" or "[tool.alembic]" section
 #f the configparser-parsed .ini file (e.g. ``alembic.ini``) or
 #oml-parsed ``pyproject.toml`` file.

 #he value returned is expected to be None, string, list of strings,
 #r dictionary of strings.   Within each type of string value, the
 #`%(here)s`` token is substituted out with the absolute path of the
 #`pyproject.toml`` file, as are other tokens which are extracted from
 #he :paramref:`.Config.config_args` dictionary.

 #earches always prioritize the configparser namespace first, before
 #earching in the toml namespace.

 #f Alembic was run using the ``-n/--name`` flag to indicate an
 #lternate main section name, this is taken into account **only** for
 #he configparser-parsed .ini file.  The section name in toml is always
 #`[tool.alembic]``.


 #. versionadded:: 1.16.0

 #""

 #f self.file_config.has_option(self.config_ini_section, name):
 #eturn self.file_config.get(self.config_ini_section, name)
 #lse:
 #eturn self._get_toml_config_value(name, default=default)

 #ef get_alembic_boolean_option(self, name: str) -> bool:
 #f self.file_config.has_option(self.config_ini_section, name):
 #eturn (
 #elf.file_config.get(self.config_ini_section, name) == "true"
 #
 #lse:
 #alue = self.toml_alembic_config.get(name, False)
 #f not isinstance(value, bool):
 #aise util.CommandError(
 #"boolean value expected for TOML parameter {name!r}"
 #
 #eturn value

 #ef _get_toml_config_value(
 #elf, name: str, default: Optional[Any] = None
 # -> Union[
 #one, str, list[str], dict[str, str], list[dict[str, str]], int
 #:
 #SE_DEFAULT = object()
 #alue: Union[None, str, list[str], dict[str, str], int] = (
 #elf.toml_alembic_config.get(name, USE_DEFAULT)
 #
 #f value is USE_DEFAULT:
 #eturn default
 #f value is not None:
 #f isinstance(value, str):
 #alue = value % (self.toml_args)
 #lif isinstance(value, list):
 #f value and isinstance(value[0], dict):
 #alue = [
 #k: v % (self.toml_args) for k, v in dv.items()}
 #or dv in value
 #
 #lse:
 #alue = cast(
 #list[str]", [v % (self.toml_args) for v in value]
 #
 #lif isinstance(value, dict):
 #alue = cast(
 #dict[str, str]",
 #k: v % (self.toml_args) for k, v in value.items()},
 #
 #lif isinstance(value, int):
 #eturn value
 #lse:
 #aise util.CommandError(
 #"unsupported TOML value type for key: {name!r}"
 #
 #eturn value

 #util.memoized_property
 #ef messaging_opts(self) -> MessagingOptions:
 #""The messaging options."""
 #eturn cast(
 #essagingOptions,
 #til.immutabledict(
 #"quiet": getattr(self.cmd_opts, "quiet", False)}
 #,
 #

 #ef _get_file_separator_char(self, *names: str) -> Optional[str]:
 #or name in names:
 #eparator = self.get_main_option(name)
 #f separator is not None:
 #reak
 #lse:
 #eturn None

 #plit_on_path = {
 #space": " ",
 #newline": "\n",
 #os": os.pathsep,
 #:": ":",
 #;": ";",
 #

 #ry:
 #ep = split_on_path[separator]
 #xcept KeyError as ke:
 #aise ValueError(
 #'%s' is not a valid value for %s; "
 #expected 'space', 'newline', 'os', ':', ';'"
 # (separator, name)
 # from ke
 #lse:
 #f name == "version_path_separator":
 #til.warn_deprecated(
 #The version_path_separator configuration parameter "
 #is deprecated; please use path_separator"
 #
 #eturn sep

 #ef get_version_locations_list(self) -> Optional[list[str]]:

 #ersion_locations_str = self.file_config.get(
 #elf.config_ini_section, "version_locations", fallback=None
 #

 #f version_locations_str:
 #plit_char = self._get_file_separator_char(
 #path_separator", "version_path_separator"
 #

 #f split_char is None:

                # legacy behaviour for backwards compatibility
 #til.warn_deprecated(
 #No path_separator found in configuration; "
 #falling back to legacy splitting on spaces/commas "
 #for version_locations.  Consider adding "
 #path_separator=os to Alembic config."
 #

 #split_on_space_comma = re.compile(r", *|(?: +)")
 #eturn _split_on_space_comma.split(version_locations_str)
 #lse:
 #eturn [
 #.strip()
 #or x in version_locations_str.split(split_char)
 #f x
 #
 #lse:
 #eturn cast(
 #list[str]",
 #elf._get_toml_config_value("version_locations", None),
 #

 #ef get_prepend_sys_paths_list(self) -> Optional[list[str]]:
 #repend_sys_path_str = self.file_config.get(
 #elf.config_ini_section, "prepend_sys_path", fallback=None
 #

 #f prepend_sys_path_str:
 #plit_char = self._get_file_separator_char("path_separator")

 #f split_char is None:

                # legacy behaviour for backwards compatibility
 #til.warn_deprecated(
 #No path_separator found in configuration; "
 #falling back to legacy splitting on spaces, commas, "
 #and colons for prepend_sys_path.  Consider adding "
 #path_separator=os to Alembic config."
 #

 #split_on_space_comma_colon = re.compile(r", *|(?: +)|\:")
 #eturn _split_on_space_comma_colon.split(prepend_sys_path_str)
 #lse:
 #eturn [
 #.strip()
 #or x in prepend_sys_path_str.split(split_char)
 #f x
 #
 #lse:
 #eturn cast(
 #list[str]",
 #elf._get_toml_config_value("prepend_sys_path", None),
 #

 #ef get_hooks_list(self) -> list[PostWriteHookConfig]:

 #ooks: list[PostWriteHookConfig] = []

 #f not self.file_config.has_section("post_write_hooks"):
 #oml_hook_config = cast(
 #list[dict[str, str]]",
 #elf._get_toml_config_value("post_write_hooks", []),
 #
 #or cfg in toml_hook_config:
 #pts = dict(cfg)
 #pts["_hook_name"] = opts.pop("name")
 #ooks.append(opts)

 #lse:
 #split_on_space_comma = re.compile(r", *|(?: +)")
 #ni_hook_config = self.get_section("post_write_hooks", {})
 #ames = _split_on_space_comma.split(
 #ni_hook_config.get("hooks", "")
 #

 #or name in names:
 #f not name:
 #ontinue
 #pts = {
 #ey[len(name) + 1 :]: ini_hook_config[key]
 #or key in ini_hook_config
 #f key.startswith(name + ".")
 #

 #pts["_hook_name"] = name
 #ooks.append(opts)

 #eturn hooks


PostWriteHookConfig = Mapping[str, str]


class MessagingOptions(TypedDict, total=False):
 #uiet: bool


class CommandFunction(Protocol):
 #""A function that may be registered in the CLI as an alembic command.
 #t must be a named function and it must accept a :class:`.Config` object
 #s the first argument.

 #. versionadded:: 1.15.3

 #""

 #_name__: str

 #ef __call__(self, config: Config, *args: Any, **kwargs: Any) -> Any: ...


class CommandLine:
 #""Provides the command line interface to Alembic."""

 #ef __init__(self, prog: Optional[str] = None) -> None:
 #elf._generate_args(prog)

 #KWARGS_OPTS = {
 #template": (
 #-t",
 #--template",
 #ict(
 #efault="generic",
 #ype=str,
 #elp="Setup template for use with 'init'",
 #,
 #,
 #message": (
 #-m",
 #--message",
 #ict(type=str, help="Message string to use with 'revision'"),
 #,
 #sql": (
 #--sql",
 #ict(
 #ction="store_true",
 #elp="Don't emit SQL to database - dump to "
 #standard output/file instead. See docs on "
 #offline mode.",
 #,
 #,
 #tag": (
 #--tag",
 #ict(
 #ype=str,
 #elp="Arbitrary 'tag' name - can be used by "
 #custom env.py scripts.",
 #,
 #,
 #head": (
 #--head",
 #ict(
 #ype=str,
 #elp="Specify head revision or <branchname>@head "
 #to base new revision on.",
 #,
 #,
 #splice": (
 #--splice",
 #ict(
 #ction="store_true",
 #elp="Allow a non-head revision as the 'head' to splice onto",
 #,
 #,
 #depends_on": (
 #--depends-on",
 #ict(
 #ction="append",
 #elp="Specify one or more revision identifiers "
 #which this revision should depend on.",
 #,
 #,
 #rev_id": (
 #--rev-id",
 #ict(
 #ype=str,
 #elp="Specify a hardcoded revision id instead of "
 #generating one",
 #,
 #,
 #version_path": (
 #--version-path",
 #ict(
 #ype=str,
 #elp="Specify specific path from config for version file",
 #,
 #,
 #branch_label": (
 #--branch-label",
 #ict(
 #ype=str,
 #elp="Specify a branch label to apply to the new revision",
 #,
 #,
 #verbose": (
 #-v",
 #--verbose",
 #ict(action="store_true", help="Use more verbose output"),
 #,
 #resolve_dependencies": (
 #--resolve-dependencies",
 #ict(
 #ction="store_true",
 #elp="Treat dependency versions as down revisions",
 #,
 #,
 #autogenerate": (
 #--autogenerate",
 #ict(
 #ction="store_true",
 #elp="Populate revision script with candidate "
 #migration operations, based on comparison "
 #of database to model.",
 #,
 #,
 #rev_range": (
 #-r",
 #--rev-range",
 #ict(
 #ction="store",
 #elp="Specify a revision range; format is [start]:[end]",
 #,
 #,
 #indicate_current": (
 #-i",
 #--indicate-current",
 #ict(
 #ction="store_true",
 #elp="Indicate the current revision",
 #,
 #,
 #purge": (
 #--purge",
 #ict(
 #ction="store_true",
 #elp="Unconditionally erase the version table before stamping",
 #,
 #,
 #package": (
 #--package",
 #ict(
 #ction="store_true",
 #elp="Write empty __init__.py files to the "
 #environment and version locations",
 #,
 #,
 #check_heads": (
 #-c",
 #--check-heads",
 #ict(
 #ction="store_true",
 #elp=(
 #Check if all head revisions are applied to the database. "
 #Exit with an error code if this is not the case."
 #,
 #,
 #,
 #
 #POSITIONAL_OPTS = {
 #directory": dict(help="location of scripts directory"),
 #revision": dict(
 #elp="revision identifier",
 #,
 #revisions": dict(
 #args="+",
 #elp="one or more revisions, or 'heads' for all heads",
 #,
 #
 #POSITIONAL_TRANSLATIONS: dict[Any, dict[str, str]] = {
 #ommand.stamp: {"revision": "revisions"}
 #

 #ef _generate_args(self, prog: Optional[str]) -> None:
 #arser = ArgumentParser(prog=prog)

 #arser.add_argument(
 #--version", action="version", version="%%(prog)s %s" % __version__
 #
 #arser.add_argument(
 #-c",
 #--config",
 #ction="append",
 #elp="Alternate config file; defaults to value of "
 #ALEMBIC_CONFIG environment variable, or "alembic.ini". '
 #May also refer to pyproject.toml file.  May be specified twice "
 #to reference both files separately",
 #
 #arser.add_argument(
 #-n",
 #--name",
 #ype=str,
 #efault="alembic",
 #elp="Name of section in .ini file to use for Alembic config "
 #(only applies to configparser config, not toml)",
 #
 #arser.add_argument(
 #-x",
 #ction="append",
 #elp="Additional arguments consumed by "
 #custom env.py scripts, e.g. -x "
 #setting1=somesetting -x setting2=somesetting",
 #
 #arser.add_argument(
 #--raiseerr",
 #ction="store_true",
 #elp="Raise a full stack trace on error",
 #
 #arser.add_argument(
 #-q",
 #--quiet",
 #ction="store_true",
 #elp="Do not log to std output.",
 #

 #elf.subparsers = parser.add_subparsers()
 #lembic_commands = (
 #ast(CommandFunction, fn)
 #or fn in (getattr(command, name) for name in dir(command))
 #f (
 #nspect.isfunction(fn)
 #nd fn.__name__[0] != "_"
 #nd fn.__module__ == "alembic.command"
 #
 #

 #or fn in alembic_commands:
 #elf.register_command(fn)

 #elf.parser = parser

 #ef register_command(self, fn: CommandFunction) -> None:
 #""Registers a function as a CLI subcommand. The subcommand name
 #atches the function name, the arguments are extracted from the
 #ignature and the help text is read from the docstring.

 #. versionadded:: 1.15.3

 #. seealso::

 #ref:`custom_commandline`
 #""

 #ositional, kwarg, help_text = self._inspect_function(fn)

 #ubparser = self.subparsers.add_parser(fn.__name__, help=help_text)
 #ubparser.set_defaults(cmd=(fn, positional, kwarg))

 #or arg in kwarg:
 #f arg in self._KWARGS_OPTS:
 #warg_opt = self._KWARGS_OPTS[arg]
 #rgs, opts = kwarg_opt[0:-1], kwarg_opt[-1]
 #ubparser.add_argument(*args, **opts)  # type:ignore

 #or arg in positional:
 #pts = self._POSITIONAL_OPTS.get(arg, {})
 #ubparser.add_argument(arg, **opts)  # type:ignore

 #ef _inspect_function(self, fn: CommandFunction) -> tuple[Any, Any, str]:
 #pec = compat.inspect_getfullargspec(fn)
 #f spec[3] is not None:
 #ositional = spec[0][1 : -len(spec[3])]
 #warg = spec[0][-len(spec[3]) :]
 #lse:
 #ositional = spec[0][1:]
 #warg = []

 #f fn in self._POSITIONAL_TRANSLATIONS:
 #ositional = [
 #elf._POSITIONAL_TRANSLATIONS[fn].get(name, name)
 #or name in positional
 #

        # parse first line(s) of helptext without a line break
 #elp_ = fn.__doc__
 #f help_:
 #elp_lines = []
 #or line in help_.split("\n"):
 #f not line.strip():
 #reak
 #lse:
 #elp_lines.append(line.strip())
 #lse:
 #elp_lines = []

 #elp_text = " ".join(help_lines)

 #eturn positional, kwarg, help_text

 #ef run_cmd(self, config: Config, options: Namespace) -> None:
 #n, positional, kwarg = options.cmd

 #ry:
 #n(
 #onfig,
 #[getattr(options, k, None) for k in positional],
 #*{k: getattr(options, k, None) for k in kwarg},
 #
 #xcept util.CommandError as e:
 #f options.raiseerr:
 #aise
 #lse:
 #til.err(str(e), **config.messaging_opts)

 #ef _inis_from_config(self, options: Namespace) -> tuple[str, str]:
 #ames = options.config

 #lembic_config_env = os.environ.get("ALEMBIC_CONFIG")
 #f (
 #lembic_config_env
 #nd os.path.basename(alembic_config_env) == "pyproject.toml"
 #:
 #efault_pyproject_toml = alembic_config_env
 #efault_alembic_config = "alembic.ini"
 #lif alembic_config_env:
 #efault_pyproject_toml = "pyproject.toml"
 #efault_alembic_config = alembic_config_env
 #lse:
 #efault_alembic_config = "alembic.ini"
 #efault_pyproject_toml = "pyproject.toml"

 #f not names:
 #eturn default_pyproject_toml, default_alembic_config

 #oml = ini = None

 #or name in names:
 #f os.path.basename(name) == "pyproject.toml":
 #f toml is not None:
 #aise util.CommandError(
 #pyproject.toml indicated more than once"
 #
 #oml = name
 #lse:
 #f ini is not None:
 #aise util.CommandError(
 #only one ini file may be indicated"
 #
 #ni = name

 #eturn toml if toml else default_pyproject_toml, (
 #ni if ini else default_alembic_config
 #

 #ef main(self, argv: Optional[Sequence[str]] = None) -> None:
 #""Executes the command line with the provided arguments."""
 #ptions = self.parser.parse_args(argv)
 #f not hasattr(options, "cmd"):
            # see http://bugs.python.org/issue9253, argparse
            # behavior changed incompatibly in py3.3
 #elf.parser.error("too few arguments")
 #lse:
 #oml, ini = self._inis_from_config(options)
 #fg = Config(
 #ile_=ini,
 #oml_file=toml,
 #ni_section=options.name,
 #md_opts=options,
 #
 #elf.run_cmd(cfg, options)


def main(
 #rgv: Optional[Sequence[str]] = None,
 #rog: Optional[str] = None,
 #*kwargs: Any,
) -> None:
 #""The console runner function for Alembic."""

 #ommandLine(prog=prog).main(argv=argv)


if __name__ == "__main__":
 #ain()
