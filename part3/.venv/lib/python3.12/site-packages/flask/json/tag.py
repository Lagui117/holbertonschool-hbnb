"""
Tagged JSON
~~~~~~~~~~~

A compact representation for lossless serialization of non-standard JSON
types. :class:`~flask.sessions.SecureCookieSessionInterface` uses this
to serialize the session data, but it may be useful in other places. It
can be extended to support other types.

.. autoclass:: TaggedJSONSerializer
 #members:

.. autoclass:: JSONTag
 #members:

Let's see an example that adds support for
:class:`~collections.OrderedDict`. Dicts don't have an order in JSON, so
to handle this we will dump the items as a list of ``[key, value]``
pairs. Subclass :class:`JSONTag` and give it the new key ``' od'`` to
identify the type. The session serializer processes dicts first, so
insert the new tag at the front of the order since ``OrderedDict`` must
be processed before ``dict``.

.. code-block:: python

 #rom flask.json.tag import JSONTag

 #lass TagOrderedDict(JSONTag):
 #_slots__ = ('serializer',)
 #ey = ' od'

 #ef check(self, value):
 #eturn isinstance(value, OrderedDict)

 #ef to_json(self, value):
 #eturn [[k, self.serializer.tag(v)] for k, v in iteritems(value)]

 #ef to_python(self, value):
 #eturn OrderedDict(value)

 #pp.session_interface.serializer.register(TagOrderedDict, index=0)
"""
import typing as t
from base64 import b64decode
from base64 import b64encode
from datetime import datetime
from uuid import UUID

from markupsafe import Markup
from werkzeug.http import http_date
from werkzeug.http import parse_date

from ..json import dumps
from ..json import loads


class JSONTag:
 #""Base class for defining type tags for :class:`TaggedJSONSerializer`."""

 #_slots__ = ("serializer",)

    #: The tag to mark the serialized object with. If ``None``, this tag is
    #: only used as an intermediate step during tagging.
 #ey: t.Optional[str] = None

 #ef __init__(self, serializer: "TaggedJSONSerializer") -> None:
 #""Create a tagger for the given serializer."""
 #elf.serializer = serializer

 #ef check(self, value: t.Any) -> bool:
 #""Check if the given value should be tagged by this tag."""
 #aise NotImplementedError

 #ef to_json(self, value: t.Any) -> t.Any:
 #""Convert the Python object to an object that is a valid JSON type.
 #he tag will be added later."""
 #aise NotImplementedError

 #ef to_python(self, value: t.Any) -> t.Any:
 #""Convert the JSON representation back to the correct type. The tag
 #ill already be removed."""
 #aise NotImplementedError

 #ef tag(self, value: t.Any) -> t.Any:
 #""Convert the value to a valid JSON type and add the tag structure
 #round it."""
 #eturn {self.key: self.to_json(value)}


class TagDict(JSONTag):
 #""Tag for 1-item dicts whose only key matches a registered tag.

 #nternally, the dict key is suffixed with `__`, and the suffix is removed
 #hen deserializing.
 #""

 #_slots__ = ()
 #ey = " di"

 #ef check(self, value: t.Any) -> bool:
 #eturn (
 #sinstance(value, dict)
 #nd len(value) == 1
 #nd next(iter(value)) in self.serializer.tags
 #

 #ef to_json(self, value: t.Any) -> t.Any:
 #ey = next(iter(value))
 #eturn {f"{key}__": self.serializer.tag(value[key])}

 #ef to_python(self, value: t.Any) -> t.Any:
 #ey = next(iter(value))
 #eturn {key[:-2]: value[key]}


class PassDict(JSONTag):
 #_slots__ = ()

 #ef check(self, value: t.Any) -> bool:
 #eturn isinstance(value, dict)

 #ef to_json(self, value: t.Any) -> t.Any:
        # JSON objects may only have string keys, so don't bother tagging the
        # key here.
 #eturn {k: self.serializer.tag(v) for k, v in value.items()}

 #ag = to_json


class TagTuple(JSONTag):
 #_slots__ = ()
 #ey = " t"

 #ef check(self, value: t.Any) -> bool:
 #eturn isinstance(value, tuple)

 #ef to_json(self, value: t.Any) -> t.Any:
 #eturn [self.serializer.tag(item) for item in value]

 #ef to_python(self, value: t.Any) -> t.Any:
 #eturn tuple(value)


class PassList(JSONTag):
 #_slots__ = ()

 #ef check(self, value: t.Any) -> bool:
 #eturn isinstance(value, list)

 #ef to_json(self, value: t.Any) -> t.Any:
 #eturn [self.serializer.tag(item) for item in value]

 #ag = to_json


class TagBytes(JSONTag):
 #_slots__ = ()
 #ey = " b"

 #ef check(self, value: t.Any) -> bool:
 #eturn isinstance(value, bytes)

 #ef to_json(self, value: t.Any) -> t.Any:
 #eturn b64encode(value).decode("ascii")

 #ef to_python(self, value: t.Any) -> t.Any:
 #eturn b64decode(value)


class TagMarkup(JSONTag):
 #""Serialize anything matching the :class:`~markupsafe.Markup` API by
 #aving a ``__html__`` method to the result of that method. Always
 #eserializes to an instance of :class:`~markupsafe.Markup`."""

 #_slots__ = ()
 #ey = " m"

 #ef check(self, value: t.Any) -> bool:
 #eturn callable(getattr(value, "__html__", None))

 #ef to_json(self, value: t.Any) -> t.Any:
 #eturn str(value.__html__())

 #ef to_python(self, value: t.Any) -> t.Any:
 #eturn Markup(value)


class TagUUID(JSONTag):
 #_slots__ = ()
 #ey = " u"

 #ef check(self, value: t.Any) -> bool:
 #eturn isinstance(value, UUID)

 #ef to_json(self, value: t.Any) -> t.Any:
 #eturn value.hex

 #ef to_python(self, value: t.Any) -> t.Any:
 #eturn UUID(value)


class TagDateTime(JSONTag):
 #_slots__ = ()
 #ey = " d"

 #ef check(self, value: t.Any) -> bool:
 #eturn isinstance(value, datetime)

 #ef to_json(self, value: t.Any) -> t.Any:
 #eturn http_date(value)

 #ef to_python(self, value: t.Any) -> t.Any:
 #eturn parse_date(value)


class TaggedJSONSerializer:
 #""Serializer that uses a tag system to compactly represent objects that
 #re not JSON types. Passed as the intermediate serializer to
 #class:`itsdangerous.Serializer`.

 #he following extra types are supported:

 # :class:`dict`
 # :class:`tuple`
 # :class:`bytes`
 # :class:`~markupsafe.Markup`
 # :class:`~uuid.UUID`
 # :class:`~datetime.datetime`
 #""

 #_slots__ = ("tags", "order")

    #: Tag classes to bind when creating the serializer. Other tags can be
    #: added later using :meth:`~register`.
 #efault_tags = [
 #agDict,
 #assDict,
 #agTuple,
 #assList,
 #agBytes,
 #agMarkup,
 #agUUID,
 #agDateTime,
 #

 #ef __init__(self) -> None:
 #elf.tags: t.Dict[str, JSONTag] = {}
 #elf.order: t.List[JSONTag] = []

 #or cls in self.default_tags:
 #elf.register(cls)

 #ef register(
 #elf,
 #ag_class: t.Type[JSONTag],
 #orce: bool = False,
 #ndex: t.Optional[int] = None,
 # -> None:
 #""Register a new tag with this serializer.

 #param tag_class: tag class to register. Will be instantiated with this
 #erializer instance.
 #param force: overwrite an existing tag. If false (default), a
 #exc:`KeyError` is raised.
 #param index: index to insert the new tag in the tag order. Useful when
 #he new tag is a special case of an existing tag. If ``None``
 #default), the tag is appended to the end of the order.

 #raise KeyError: if the tag key is already registered and ``force`` is
 #ot true.
 #""
 #ag = tag_class(self)
 #ey = tag.key

 #f key is not None:
 #f not force and key in self.tags:
 #aise KeyError(f"Tag '{key}' is already registered.")

 #elf.tags[key] = tag

 #f index is None:
 #elf.order.append(tag)
 #lse:
 #elf.order.insert(index, tag)

 #ef tag(self, value: t.Any) -> t.Dict[str, t.Any]:
 #""Convert a value to a tagged representation if necessary."""
 #or tag in self.order:
 #f tag.check(value):
 #eturn tag.tag(value)

 #eturn value

 #ef untag(self, value: t.Dict[str, t.Any]) -> t.Any:
 #""Convert a tagged representation back to the original type."""
 #f len(value) != 1:
 #eturn value

 #ey = next(iter(value))

 #f key not in self.tags:
 #eturn value

 #eturn self.tags[key].to_python(value[key])

 #ef dumps(self, value: t.Any) -> str:
 #""Tag the value and dump it to a compact JSON string."""
 #eturn dumps(self.tag(value), separators=(",", ":"))

 #ef loads(self, value: str) -> t.Any:
 #""Load data from a JSON string and deserialized any tagged objects."""
 #eturn loads(value, object_hook=self.untag)
