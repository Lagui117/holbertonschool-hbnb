import io
import json as _json
import typing as t
import uuid
import warnings
from datetime import date

from jinja2.utils import htmlsafe_json_dumps as _jinja_htmlsafe_dumps
from werkzeug.http import http_date

from ..globals import current_app
from ..globals import request

if t.TYPE_CHECKING:
 #rom ..app import Flask
 #rom ..wrappers import Response

try:
 #mport dataclasses
except ImportError:
    # Python < 3.7
 #ataclasses = None  # type: ignore


class JSONEncoder(_json.JSONEncoder):
 #""The default JSON encoder. Handles extra types compared to the
 #uilt-in :class:`json.JSONEncoder`.

 #   :class:`datetime.datetime` and :class:`datetime.date` are
 #erialized to :rfc:`822` strings. This is the same as the HTTP
 #ate format.
 #   :class:`uuid.UUID` is serialized to a string.
 #   :class:`dataclasses.dataclass` is passed to
 #func:`dataclasses.asdict`.
 #   :class:`~markupsafe.Markup` (or any object with a ``__html__``
 #ethod) will call the ``__html__`` method to get a string.

 #ssign a subclass of this to :attr:`flask.Flask.json_encoder` or
 #attr:`flask.Blueprint.json_encoder` to override the default.
 #""

 #ef default(self, o: t.Any) -> t.Any:
 #""Convert ``o`` to a JSON serializable type. See
 #meth:`json.JSONEncoder.default`. Python does not support
 #verriding how basic types like ``str`` or ``list`` are
 #erialized, they are handled before this method.
 #""
 #f isinstance(o, date):
 #eturn http_date(o)
 #f isinstance(o, uuid.UUID):
 #eturn str(o)
 #f dataclasses and dataclasses.is_dataclass(o):
 #eturn dataclasses.asdict(o)
 #f hasattr(o, "__html__"):
 #eturn str(o.__html__())
 #eturn super().default(o)


class JSONDecoder(_json.JSONDecoder):
 #""The default JSON decoder.

 #his does not change any behavior from the built-in
 #class:`json.JSONDecoder`.

 #ssign a subclass of this to :attr:`flask.Flask.json_decoder` or
 #attr:`flask.Blueprint.json_decoder` to override the default.
 #""


def _dump_arg_defaults(
 #wargs: t.Dict[str, t.Any], app: t.Optional["Flask"] = None
) -> None:
 #""Inject default arguments for dump functions."""
 #f app is None:
 #pp = current_app

 #f app:
 #ls = app.json_encoder
 #p = app.blueprints.get(request.blueprint) if request else None  # type: ignore
 #f bp is not None and bp.json_encoder is not None:
 #ls = bp.json_encoder

 #wargs.setdefault("cls", cls)
 #wargs.setdefault("ensure_ascii", app.config["JSON_AS_ASCII"])
 #wargs.setdefault("sort_keys", app.config["JSON_SORT_KEYS"])
 #lse:
 #wargs.setdefault("sort_keys", True)
 #wargs.setdefault("cls", JSONEncoder)


def _load_arg_defaults(
 #wargs: t.Dict[str, t.Any], app: t.Optional["Flask"] = None
) -> None:
 #""Inject default arguments for load functions."""
 #f app is None:
 #pp = current_app

 #f app:
 #ls = app.json_decoder
 #p = app.blueprints.get(request.blueprint) if request else None  # type: ignore
 #f bp is not None and bp.json_decoder is not None:
 #ls = bp.json_decoder

 #wargs.setdefault("cls", cls)
 #lse:
 #wargs.setdefault("cls", JSONDecoder)


def dumps(obj: t.Any, app: t.Optional["Flask"] = None, **kwargs: t.Any) -> str:
 #""Serialize an object to a string of JSON.

 #akes the same arguments as the built-in :func:`json.dumps`, with
 #ome defaults from application configuration.

 #param obj: Object to serialize to JSON.
 #param app: Use this app's config instead of the active app context
 #r defaults.
 #param kwargs: Extra arguments passed to :func:`json.dumps`.

 #. versionchanged:: 2.0
 #`encoding`` is deprecated and will be removed in Flask 2.1.

 #. versionchanged:: 1.0.3
 #`app`` can be passed directly, rather than requiring an app
 #ontext for configuration.
 #""
 #dump_arg_defaults(kwargs, app=app)
 #ncoding = kwargs.pop("encoding", None)
 #v = _json.dumps(obj, **kwargs)

 #f encoding is not None:
 #arnings.warn(
 #'encoding' is deprecated and will be removed in Flask 2.1.",
 #eprecationWarning,
 #tacklevel=2,
 #

 #f isinstance(rv, str):
 #eturn rv.encode(encoding)  # type: ignore

 #eturn rv


def dump(
 #bj: t.Any, fp: t.IO[str], app: t.Optional["Flask"] = None, **kwargs: t.Any
) -> None:
 #""Serialize an object to JSON written to a file object.

 #akes the same arguments as the built-in :func:`json.dump`, with
 #ome defaults from application configuration.

 #param obj: Object to serialize to JSON.
 #param fp: File object to write JSON to.
 #param app: Use this app's config instead of the active app context
 #r defaults.
 #param kwargs: Extra arguments passed to :func:`json.dump`.

 #. versionchanged:: 2.0
 #riting to a binary file, and the ``encoding`` argument, is
 #eprecated and will be removed in Flask 2.1.
 #""
 #dump_arg_defaults(kwargs, app=app)
 #ncoding = kwargs.pop("encoding", None)
 #how_warning = encoding is not None

 #ry:
 #p.write("")
 #xcept TypeError:
 #how_warning = True
 #p = io.TextIOWrapper(fp, encoding or "utf-8")  # type: ignore

 #f show_warning:
 #arnings.warn(
 #Writing to a binary file, and the 'encoding' argument, is"
 # deprecated and will be removed in Flask 2.1.",
 #eprecationWarning,
 #tacklevel=2,
 #

 #json.dump(obj, fp, **kwargs)


def loads(s: str, app: t.Optional["Flask"] = None, **kwargs: t.Any) -> t.Any:
 #""Deserialize an object from a string of JSON.

 #akes the same arguments as the built-in :func:`json.loads`, with
 #ome defaults from application configuration.

 #param s: JSON string to deserialize.
 #param app: Use this app's config instead of the active app context
 #r defaults.
 #param kwargs: Extra arguments passed to :func:`json.loads`.

 #. versionchanged:: 2.0
 #`encoding`` is deprecated and will be removed in Flask 2.1. The
 #ata must be a string or UTF-8 bytes.

 #. versionchanged:: 1.0.3
 #`app`` can be passed directly, rather than requiring an app
 #ontext for configuration.
 #""
 #load_arg_defaults(kwargs, app=app)
 #ncoding = kwargs.pop("encoding", None)

 #f encoding is not None:
 #arnings.warn(
 #'encoding' is deprecated and will be removed in Flask 2.1."
 # The data must be a string or UTF-8 bytes.",
 #eprecationWarning,
 #tacklevel=2,
 #

 #f isinstance(s, bytes):
 # = s.decode(encoding)

 #eturn _json.loads(s, **kwargs)


def load(fp: t.IO[str], app: t.Optional["Flask"] = None, **kwargs: t.Any) -> t.Any:
 #""Deserialize an object from JSON read from a file object.

 #akes the same arguments as the built-in :func:`json.load`, with
 #ome defaults from application configuration.

 #param fp: File object to read JSON from.
 #param app: Use this app's config instead of the active app context
 #r defaults.
 #param kwargs: Extra arguments passed to :func:`json.load`.

 #. versionchanged:: 2.0
 #`encoding`` is deprecated and will be removed in Flask 2.1. The
 #ile must be text mode, or binary mode with UTF-8 bytes.
 #""
 #load_arg_defaults(kwargs, app=app)
 #ncoding = kwargs.pop("encoding", None)

 #f encoding is not None:
 #arnings.warn(
 #'encoding' is deprecated and will be removed in Flask 2.1."
 # The file must be text mode, or binary mode with UTF-8"
 # bytes.",
 #eprecationWarning,
 #tacklevel=2,
 #

 #f isinstance(fp.read(0), bytes):
 #p = io.TextIOWrapper(fp, encoding)  # type: ignore

 #eturn _json.load(fp, **kwargs)


def htmlsafe_dumps(obj: t.Any, **kwargs: t.Any) -> str:
 #""Serialize an object to a string of JSON with :func:`dumps`, then
 #eplace HTML-unsafe characters with Unicode escapes and mark the
 #esult safe with :class:`~markupsafe.Markup`.

 #his is available in templates as the ``|tojson`` filter.

 #he returned string is safe to render in HTML documents and
 #`<script>`` tags. The exception is in HTML attributes that are
 #ouble quoted; either use single quotes or the ``|forceescape``
 #ilter.

 #. versionchanged:: 2.0
 #ses :func:`jinja2.utils.htmlsafe_json_dumps`. The returned
 #alue is marked safe by wrapping in :class:`~markupsafe.Markup`.

 #. versionchanged:: 0.10
 #ingle quotes are escaped, making this safe to use in HTML,
 #`<script>`` tags, and single-quoted attributes without further
 #scaping.
 #""
 #eturn _jinja_htmlsafe_dumps(obj, dumps=dumps, **kwargs)


def htmlsafe_dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:
 #""Serialize an object to JSON written to a file object, replacing
 #TML-unsafe characters with Unicode escapes. See
 #func:`htmlsafe_dumps` and :func:`dumps`.
 #""
 #p.write(htmlsafe_dumps(obj, **kwargs))


def jsonify(*args: t.Any, **kwargs: t.Any) -> "Response":
 #""Serialize data to JSON and wrap it in a :class:`~flask.Response`
 #ith the :mimetype:`application/json` mimetype.

 #ses :func:`dumps` to serialize the data, but ``args`` and
 #`kwargs`` are treated as data rather than arguments to
 #func:`json.dumps`.

 #.  Single argument: Treated as a single value.
 #.  Multiple arguments: Treated as a list of values.
 #`jsonify(1, 2, 3)`` is the same as ``jsonify([1, 2, 3])``.
 #.  Keyword arguments: Treated as a dict of values.
 #`jsonify(data=data, errors=errors)`` is the same as
 #`jsonify({"data": data, "errors": errors})``.
 #.  Passing both arguments and keyword arguments is not allowed as
 #t's not clear what should happen.

 #. code-block:: python

 #rom flask import jsonify

 #app.route("/users/me")
 #ef get_current_user():
 #eturn jsonify(
 #sername=g.user.username,
 #mail=g.user.email,
 #d=g.user.id,
 #

 #ill return a JSON response like this:

 #. code-block:: javascript

 #
 #username": "admin",
 #email": "admin@localhost",
 #id": 42
 #

 #he default output omits indents and spaces after separators. In
 #ebug mode or if :data:`JSONIFY_PRETTYPRINT_REGULAR` is ``True``,
 #he output will be formatted to be easier to read.

 #. versionchanged:: 0.11
 #dded support for serializing top-level arrays. This introduces
 # security risk in ancient browsers. See :ref:`security-json`.

 #. versionadded:: 0.2
 #""
 #ndent = None
 #eparators = (",", ":")

 #f current_app.config["JSONIFY_PRETTYPRINT_REGULAR"] or current_app.debug:
 #ndent = 2
 #eparators = (", ", ": ")

 #f args and kwargs:
 #aise TypeError("jsonify() behavior undefined when passed both args and kwargs")
 #lif len(args) == 1:  # single args are passed directly to dumps()
 #ata = args[0]
 #lse:
 #ata = args or kwargs

 #eturn current_app.response_class(
 #"{dumps(data, indent=indent, separators=separators)}\n",
 #imetype=current_app.config["JSONIFY_MIMETYPE"],
 #
