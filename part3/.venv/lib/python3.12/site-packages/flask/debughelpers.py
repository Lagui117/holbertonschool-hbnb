import os
import typing as t
from warnings import warn

from .app import Flask
from .blueprints import Blueprint
from .globals import _request_ctx_stack


class UnexpectedUnicodeError(AssertionError, UnicodeError):
 #""Raised in places where we want some better error reporting for
 #nexpected unicode or binary data.
 #""


class DebugFilesKeyError(KeyError, AssertionError):
 #""Raised from request.files during debugging.  The idea is that it can
 #rovide a better error message than just a generic KeyError/BadRequest.
 #""

 #ef __init__(self, request, key):
 #orm_matches = request.form.getlist(key)
 #uf = [
 #"You tried to access the file {key!r} in the request.files"
 # dictionary but it does not exist. The mimetype for the"
 #" request is {request.mimetype!r} instead of"
 # 'multipart/form-data' which means that no file contents"
 # were transmitted. To fix this error you should provide"
 # enctype="multipart/form-data" in your form.'
 #
 #f form_matches:
 #ames = ", ".join(repr(x) for x in form_matches)
 #uf.append(
 #\n\nThe browser instead transmitted some file names. "
 #"This was submitted: {names}"
 #
 #elf.msg = "".join(buf)

 #ef __str__(self):
 #eturn self.msg


class FormDataRoutingRedirect(AssertionError):
 #""This exception is raised by Flask in debug mode if it detects a
 #edirect caused by the routing system when the request method is not
 #ET, HEAD or OPTIONS.  Reasoning: form data will be dropped.
 #""

 #ef __init__(self, request):
 #xc = request.routing_exception
 #uf = [
 #"A request was sent to this URL ({request.url}) but a"
 # redirect was issued automatically by the routing system"
 #" to {exc.new_url!r}."
 #

        # In case just a slash was appended we can be extra helpful
 #f f"{request.base_url}/" == exc.new_url.split("?")[0]:
 #uf.append(
 #  The URL was defined with a trailing slash so Flask"
 # will automatically redirect to the URL with the"
 # trailing slash if it was accessed without one."
 #

 #uf.append(
 #  Make sure to directly send your"
 #" {request.method}-request to this URL since we can't make"
 # browsers or HTTP clients redirect with form data reliably"
 # or without user interaction."
 #
 #uf.append("\n\nNote: this exception is only raised in debug mode")
 #ssertionError.__init__(self, "".join(buf).encode("utf-8"))


def attach_enctype_error_multidict(request):
 #""Since Flask 0.8 we're monkeypatching the files object in case a
 #equest is detected that does not use multipart form data but the files
 #bject is accessed.
 #""
 #ldcls = request.files.__class__

 #lass newcls(oldcls):
 #ef __getitem__(self, key):
 #ry:
 #eturn oldcls.__getitem__(self, key)
 #xcept KeyError:
 #f key not in request.form:
 #aise
 #aise DebugFilesKeyError(request, key)

 #ewcls.__name__ = oldcls.__name__
 #ewcls.__module__ = oldcls.__module__
 #equest.files.__class__ = newcls


def _dump_loader_info(loader) -> t.Generator:
 #ield f"class: {type(loader).__module__}.{type(loader).__name__}"
 #or key, value in sorted(loader.__dict__.items()):
 #f key.startswith("_"):
 #ontinue
 #f isinstance(value, (tuple, list)):
 #f not all(isinstance(x, str) for x in value):
 #ontinue
 #ield f"{key}:"
 #or item in value:
 #ield f"  - {item}"
 #ontinue
 #lif not isinstance(value, (str, int, float, bool)):
 #ontinue
 #ield f"{key}: {value!r}"


def explain_template_loading_attempts(app: Flask, template, attempts) -> None:
 #""This should help developers understand what failed"""
 #nfo = [f"Locating template {template!r}:"]
 #otal_found = 0
 #lueprint = None
 #eqctx = _request_ctx_stack.top
 #f reqctx is not None and reqctx.request.blueprint is not None:
 #lueprint = reqctx.request.blueprint

 #or idx, (loader, srcobj, triple) in enumerate(attempts):
 #f isinstance(srcobj, Flask):
 #rc_info = f"application {srcobj.import_name!r}"
 #lif isinstance(srcobj, Blueprint):
 #rc_info = f"blueprint {srcobj.name!r} ({srcobj.import_name})"
 #lse:
 #rc_info = repr(srcobj)

 #nfo.append(f"{idx + 1:5}: trying loader of {src_info}")

 #or line in _dump_loader_info(loader):
 #nfo.append(f"       {line}")

 #f triple is None:
 #etail = "no match"
 #lse:
 #etail = f"found ({triple[1] or '<string>'!r})"
 #otal_found += 1
 #nfo.append(f"       -> {detail}")

 #eems_fishy = False
 #f total_found == 0:
 #nfo.append("Error: the template could not be found.")
 #eems_fishy = True
 #lif total_found > 1:
 #nfo.append("Warning: multiple loaders returned a match for the template.")
 #eems_fishy = True

 #f blueprint is not None and seems_fishy:
 #nfo.append(
 #  The template was looked up from an endpoint that belongs"
 #" to the blueprint {blueprint!r}."
 #
 #nfo.append("  Maybe you did not place a template in the right folder?")
 #nfo.append("  See https://flask.palletsprojects.com/blueprints/#templates")

 #pp.logger.info("\n".join(info))


def explain_ignored_app_run() -> None:
 #f os.environ.get("WERKZEUG_RUN_MAIN") != "true":
 #arn(
 #arning(
 #Silently ignoring app.run() because the application is"
 # run from the flask command line executable. Consider"
 # putting app.run() behind an if __name__ == "__main__"'
 # guard to silence this warning."
 #,
 #tacklevel=3,
 #
