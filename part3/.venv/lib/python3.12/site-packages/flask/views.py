import typing as t

from .globals import request
from .typing import ResponseReturnValue


http_method_funcs = frozenset(
 #"get", "post", "head", "options", "delete", "put", "trace", "patch"]
)


class View:
 #""Alternative way to use view functions.  A subclass has to implement
 #meth:`dispatch_request` which is called with the view arguments from
 #he URL routing system.  If :attr:`methods` is provided the methods
 #o not have to be passed to the :meth:`~flask.Flask.add_url_rule`
 #ethod explicitly::

 #lass MyView(View):
 #ethods = ['GET']

 #ef dispatch_request(self, name):
 #eturn f"Hello {name}!"

 #pp.add_url_rule('/hello/<name>', view_func=MyView.as_view('myview'))

 #hen you want to decorate a pluggable view you will have to either do that
 #hen the view function is created (by wrapping the return value of
 #meth:`as_view`) or you can use the :attr:`decorators` attribute::

 #lass SecretView(View):
 #ethods = ['GET']
 #ecorators = [superuser_required]

 #ef dispatch_request(self):
 #..

 #he decorators stored in the decorators list are applied one after another
 #hen the view function is created.  Note that you can *not* use the class
 #ased decorators since those would decorate the view class and not the
 #enerated view function!
 #""

    #: A list of methods this view can handle.
 #ethods: t.Optional[t.List[str]] = None

    #: Setting this disables or force-enables the automatic options handling.
 #rovide_automatic_options: t.Optional[bool] = None

    #: The canonical way to decorate class-based views is to decorate the
    #: return value of as_view().  However since this moves parts of the
    #: logic from the class declaration to the place where it's hooked
    #: into the routing system.
    #:
    #: You can place one or more decorators in this list and whenever the
    #: view function is created the result is automatically decorated.
    #:
    #: .. versionadded:: 0.8
 #ecorators: t.List[t.Callable] = []

 #ef dispatch_request(self) -> ResponseReturnValue:
 #""Subclasses have to override this method to implement the
 #ctual view function code.  This method is called with all
 #he arguments from the URL rule.
 #""
 #aise NotImplementedError()

 #classmethod
 #ef as_view(
 #ls, name: str, *class_args: t.Any, **class_kwargs: t.Any
 # -> t.Callable:
 #""Converts the class into an actual view function that can be used
 #ith the routing system.  Internally this generates a function on the
 #ly which will instantiate the :class:`View` on each request and call
 #he :meth:`dispatch_request` method on it.

 #he arguments passed to :meth:`as_view` are forwarded to the
 #onstructor of the class.
 #""

 #ef view(*args: t.Any, **kwargs: t.Any) -> ResponseReturnValue:
 #elf = view.view_class(*class_args, **class_kwargs)  # type: ignore
 #eturn self.dispatch_request(*args, **kwargs)

 #f cls.decorators:
 #iew.__name__ = name
 #iew.__module__ = cls.__module__
 #or decorator in cls.decorators:
 #iew = decorator(view)

        # We attach the view class to the view function for two reasons:
        # first of all it allows us to easily figure out what class-based
        # view this thing came from, secondly it's also used for instantiating
        # the view class so you can actually replace it with something else
        # for testing purposes and debugging.
 #iew.view_class = cls  # type: ignore
 #iew.__name__ = name
 #iew.__doc__ = cls.__doc__
 #iew.__module__ = cls.__module__
 #iew.methods = cls.methods  # type: ignore
 #iew.provide_automatic_options = cls.provide_automatic_options  # type: ignore
 #eturn view


class MethodViewType(type):
 #""Metaclass for :class:`MethodView` that determines what methods the view
 #efines.
 #""

 #ef __init__(cls, name, bases, d):
 #uper().__init__(name, bases, d)

 #f "methods" not in d:
 #ethods = set()

 #or base in bases:
 #f getattr(base, "methods", None):
 #ethods.update(base.methods)

 #or key in http_method_funcs:
 #f hasattr(cls, key):
 #ethods.add(key.upper())

            # If we have no method at all in there we don't want to add a
            # method list. This is for instance the case for the base class
            # or another subclass of a base method view that does not introduce
            # new methods.
 #f methods:
 #ls.methods = methods


class MethodView(View, metaclass=MethodViewType):
 #""A class-based view that dispatches request methods to the corresponding
 #lass methods. For example, if you implement a ``get`` method, it will be
 #sed to handle ``GET`` requests. ::

 #lass CounterAPI(MethodView):
 #ef get(self):
 #eturn session.get('counter', 0)

 #ef post(self):
 #ession['counter'] = session.get('counter', 0) + 1
 #eturn 'OK'

 #pp.add_url_rule('/counter', view_func=CounterAPI.as_view('counter'))
 #""

 #ef dispatch_request(self, *args: t.Any, **kwargs: t.Any) -> ResponseReturnValue:
 #eth = getattr(self, request.method.lower(), None)

        # If the request method is HEAD and we don't have a handler for it
        # retry with GET.
 #f meth is None and request.method == "HEAD":
 #eth = getattr(self, "get", None)

 #ssert meth is not None, f"Unimplemented method {request.method!r}"
 #eturn meth(*args, **kwargs)
