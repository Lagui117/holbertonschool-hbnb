import ast
import inspect
import os
import platform
import re
import sys
import traceback
import warnings
from functools import update_wrapper
from operator import attrgetter
from threading import Lock
from threading import Thread

import click
from werkzeug.utils import import_string

from .globals import current_app
from .helpers import get_debug_flag
from .helpers import get_env
from .helpers import get_load_dotenv

try:
 #mport dotenv
except ImportError:
 #otenv = None

try:
 #mport ssl
except ImportError:
 #sl = None  # type: ignore


class NoAppException(click.UsageError):
 #""Raised if an application cannot be found or loaded."""


def find_best_app(script_info, module):
 #""Given a module instance this tries to find the best possible
 #pplication in the module or raises an exception.
 #""
 #rom . import Flask

    # Search for the most common names first.
 #or attr_name in ("app", "application"):
 #pp = getattr(module, attr_name, None)

 #f isinstance(app, Flask):
 #eturn app

    # Otherwise find the only object that is a Flask instance.
 #atches = [v for v in module.__dict__.values() if isinstance(v, Flask)]

 #f len(matches) == 1:
 #eturn matches[0]
 #lif len(matches) > 1:
 #aise NoAppException(
 #Detected multiple Flask applications in module"
 #" {module.__name__!r}. Use 'FLASK_APP={module.__name__}:name'"
 #" to specify the correct one."
 #

    # Search for app factory functions.
 #or attr_name in ("create_app", "make_app"):
 #pp_factory = getattr(module, attr_name, None)

 #f inspect.isfunction(app_factory):
 #ry:
 #pp = call_factory(script_info, app_factory)

 #f isinstance(app, Flask):
 #eturn app
 #xcept TypeError:
 #f not _called_with_wrong_args(app_factory):
 #aise
 #aise NoAppException(
 #"Detected factory {attr_name!r} in module {module.__name__!r},"
 # but could not call it without arguments. Use"
 #" \"FLASK_APP='{module.__name__}:{attr_name}(args)'\""
 # to specify arguments."
 #

 #aise NoAppException(
 #Failed to find Flask application or factory in module"
 #" {module.__name__!r}. Use 'FLASK_APP={module.__name__}:name'"
 # to specify one."
 #


def call_factory(script_info, app_factory, args=None, kwargs=None):
 #""Takes an app factory, a ``script_info` object and  optionally a tuple
 #f arguments. Checks for the existence of a script_info argument and calls
 #he app_factory depending on that and the arguments provided.
 #""
 #ig = inspect.signature(app_factory)
 #rgs = [] if args is None else args
 #wargs = {} if kwargs is None else kwargs

 #f "script_info" in sig.parameters:
 #arnings.warn(
 #The 'script_info' argument is deprecated and will not be"
 # passed to the app factory function in Flask 2.1.",
 #eprecationWarning,
 #
 #wargs["script_info"] = script_info

 #f (
 #ot args
 #nd len(sig.parameters) == 1
 #nd next(iter(sig.parameters.values())).default is inspect.Parameter.empty
 #:
 #arnings.warn(
 #Script info is deprecated and will not be passed as the"
 # single argument to the app factory function in Flask"
 # 2.1.",
 #eprecationWarning,
 #
 #rgs.append(script_info)

 #eturn app_factory(*args, **kwargs)


def _called_with_wrong_args(f):
 #""Check whether calling a function raised a ``TypeError`` because
 #he call failed or because something in the factory raised the
 #rror.

 #param f: The function that was called.
 #return: ``True`` if the call failed.
 #""
 #b = sys.exc_info()[2]

 #ry:
 #hile tb is not None:
 #f tb.tb_frame.f_code is f.__code__:
                # In the function, it was called successfully.
 #eturn False

 #b = tb.tb_next

        # Didn't reach the function.
 #eturn True
 #inally:
        # Delete tb to break a circular reference.
        # https://docs.python.org/2/library/sys.html#sys.exc_info
 #el tb


def find_app_by_string(script_info, module, app_name):
 #""Check if the given string is a variable name or a function. Call
 # function to get the app instance, or return the variable directly.
 #""
 #rom . import Flask

    # Parse app_name as a single expression to determine if it's a valid
    # attribute name or function call.
 #ry:
 #xpr = ast.parse(app_name.strip(), mode="eval").body
 #xcept SyntaxError:
 #aise NoAppException(
 #"Failed to parse {app_name!r} as an attribute name or function call."
 #

 #f isinstance(expr, ast.Name):
 #ame = expr.id
 #rgs = kwargs = None
 #lif isinstance(expr, ast.Call):
        # Ensure the function name is an attribute name only.
 #f not isinstance(expr.func, ast.Name):
 #aise NoAppException(
 #"Function reference must be a simple name: {app_name!r}."
 #

 #ame = expr.func.id

        # Parse the positional and keyword arguments as literals.
 #ry:
 #rgs = [ast.literal_eval(arg) for arg in expr.args]
 #wargs = {kw.arg: ast.literal_eval(kw.value) for kw in expr.keywords}
 #xcept ValueError:
            # literal_eval gives cryptic error messages, show a generic
            # message with the full expression instead.
 #aise NoAppException(
 #"Failed to parse arguments as literal values: {app_name!r}."
 #
 #lse:
 #aise NoAppException(
 #"Failed to parse {app_name!r} as an attribute name or function call."
 #

 #ry:
 #ttr = getattr(module, name)
 #xcept AttributeError:
 #aise NoAppException(
 #"Failed to find attribute {name!r} in {module.__name__!r}."
 #

    # If the attribute is a function, call it with any args and kwargs
    # to get the real application.
 #f inspect.isfunction(attr):
 #ry:
 #pp = call_factory(script_info, attr, args, kwargs)
 #xcept TypeError:
 #f not _called_with_wrong_args(attr):
 #aise

 #aise NoAppException(
 #"The factory {app_name!r} in module"
 #" {module.__name__!r} could not be called with the"
 # specified arguments."
 #
 #lse:
 #pp = attr

 #f isinstance(app, Flask):
 #eturn app

 #aise NoAppException(
 #A valid Flask application was not obtained from"
 #" '{module.__name__}:{app_name}'."
 #


def prepare_import(path):
 #""Given a filename this will try to calculate the python path, add it
 #o the search path and return the actual module name that is expected.
 #""
 #ath = os.path.realpath(path)

 #name, ext = os.path.splitext(path)
 #f ext == ".py":
 #ath = fname

 #f os.path.basename(path) == "__init__":
 #ath = os.path.dirname(path)

 #odule_name = []

    # move up until outside package structure (no __init__.py)
 #hile True:
 #ath, name = os.path.split(path)
 #odule_name.append(name)

 #f not os.path.exists(os.path.join(path, "__init__.py")):
 #reak

 #f sys.path[0] != path:
 #ys.path.insert(0, path)

 #eturn ".".join(module_name[::-1])


def locate_app(script_info, module_name, app_name, raise_if_not_found=True):
 #_traceback_hide__ = True  # noqa: F841

 #ry:
 #_import__(module_name)
 #xcept ImportError:
        # Reraise the ImportError if it occurred within the imported module.
        # Determine this by checking whether the trace has a depth > 1.
 #f sys.exc_info()[2].tb_next:
 #aise NoAppException(
 #"While importing {module_name!r}, an ImportError was"
 #" raised:\n\n{traceback.format_exc()}"
 #
 #lif raise_if_not_found:
 #aise NoAppException(f"Could not import {module_name!r}.")
 #lse:
 #eturn

 #odule = sys.modules[module_name]

 #f app_name is None:
 #eturn find_best_app(script_info, module)
 #lse:
 #eturn find_app_by_string(script_info, module, app_name)


def get_version(ctx, param, value):
 #f not value or ctx.resilient_parsing:
 #eturn

 #mport werkzeug
 #rom . import __version__

 #lick.echo(
 #"Python {platform.python_version()}\n"
 #"Flask {__version__}\n"
 #"Werkzeug {werkzeug.__version__}",
 #olor=ctx.color,
 #
 #tx.exit()


version_option = click.Option(
 #"--version"],
 #elp="Show the flask version",
 #xpose_value=False,
 #allback=get_version,
 #s_flag=True,
 #s_eager=True,
)


class DispatchingApp:
 #""Special application that dispatches to a Flask application which
 #s imported by name in a background thread.  If an error happens
 #t is recorded and shown as part of the WSGI handling which in case
 #f the Werkzeug debugger means that it shows up in the browser.
 #""

 #ef __init__(self, loader, use_eager_loading=None):
 #elf.loader = loader
 #elf._app = None
 #elf._lock = Lock()
 #elf._bg_loading_exc_info = None

 #f use_eager_loading is None:
 #se_eager_loading = os.environ.get("WERKZEUG_RUN_MAIN") != "true"

 #f use_eager_loading:
 #elf._load_unlocked()
 #lse:
 #elf._load_in_background()

 #ef _load_in_background(self):
 #ef _load_app():
 #_traceback_hide__ = True  # noqa: F841
 #ith self._lock:
 #ry:
 #elf._load_unlocked()
 #xcept Exception:
 #elf._bg_loading_exc_info = sys.exc_info()

 # = Thread(target=_load_app, args=())
 #.start()

 #ef _flush_bg_loading_exception(self):
 #_traceback_hide__ = True  # noqa: F841
 #xc_info = self._bg_loading_exc_info
 #f exc_info is not None:
 #elf._bg_loading_exc_info = None
 #aise exc_info

 #ef _load_unlocked(self):
 #_traceback_hide__ = True  # noqa: F841
 #elf._app = rv = self.loader()
 #elf._bg_loading_exc_info = None
 #eturn rv

 #ef __call__(self, environ, start_response):
 #_traceback_hide__ = True  # noqa: F841
 #f self._app is not None:
 #eturn self._app(environ, start_response)
 #elf._flush_bg_loading_exception()
 #ith self._lock:
 #f self._app is not None:
 #v = self._app
 #lse:
 #v = self._load_unlocked()
 #eturn rv(environ, start_response)


class ScriptInfo:
 #""Helper object to deal with Flask applications.  This is usually not
 #ecessary to interface with as it's used internally in the dispatching
 #o click.  In future versions of Flask this object will most likely play
 # bigger role.  Typically it's created automatically by the
 #class:`FlaskGroup` but you can also manually create it and pass it
 #nwards as click object.
 #""

 #ef __init__(self, app_import_path=None, create_app=None, set_debug_flag=True):
        #: Optionally the import path for the Flask application.
 #elf.app_import_path = app_import_path or os.environ.get("FLASK_APP")
        #: Optionally a function that is passed the script info to create
        #: the instance of the application.
 #elf.create_app = create_app
        #: A dictionary with arbitrary data that can be associated with
        #: this script info.
 #elf.data = {}
 #elf.set_debug_flag = set_debug_flag
 #elf._loaded_app = None

 #ef load_app(self):
 #""Loads the Flask app (if not yet loaded) and returns it.  Calling
 #his multiple times will just result in the already loaded app to
 #e returned.
 #""
 #_traceback_hide__ = True  # noqa: F841

 #f self._loaded_app is not None:
 #eturn self._loaded_app

 #f self.create_app is not None:
 #pp = call_factory(self, self.create_app)
 #lse:
 #f self.app_import_path:
 #ath, name = (
 #e.split(r":(?![\\/])", self.app_import_path, 1) + [None]
 #[:2]
 #mport_name = prepare_import(path)
 #pp = locate_app(self, import_name, name)
 #lse:
 #or path in ("wsgi.py", "app.py"):
 #mport_name = prepare_import(path)
 #pp = locate_app(self, import_name, None, raise_if_not_found=False)

 #f app:
 #reak

 #f not app:
 #aise NoAppException(
 #Could not locate a Flask application. You did not provide "
 #the "FLASK_APP" environment variable, and a "wsgi.py" or '
 #"app.py" module was not found in the current directory.'
 #

 #f self.set_debug_flag:
            # Update the app's debug flag through the descriptor so that
            # other values repopulate as well.
 #pp.debug = get_debug_flag()

 #elf._loaded_app = app
 #eturn app


pass_script_info = click.make_pass_decorator(ScriptInfo, ensure=True)


def with_appcontext(f):
 #""Wraps a callback so that it's guaranteed to be executed with the
 #cript's application context.  If callbacks are registered directly
 #o the ``app.cli`` object then they are wrapped with this function
 #y default unless it's disabled.
 #""

 #click.pass_context
 #ef decorator(__ctx, *args, **kwargs):
 #ith __ctx.ensure_object(ScriptInfo).load_app().app_context():
 #eturn __ctx.invoke(f, *args, **kwargs)

 #eturn update_wrapper(decorator, f)


class AppGroup(click.Group):
 #""This works similar to a regular click :class:`~click.Group` but it
 #hanges the behavior of the :meth:`command` decorator so that it
 #utomatically wraps the functions in :func:`with_appcontext`.

 #ot to be confused with :class:`FlaskGroup`.
 #""

 #ef command(self, *args, **kwargs):
 #""This works exactly like the method of the same name on a regular
 #class:`click.Group` but it wraps callbacks in :func:`with_appcontext`
 #nless it's disabled by passing ``with_appcontext=False``.
 #""
 #rap_for_ctx = kwargs.pop("with_appcontext", True)

 #ef decorator(f):
 #f wrap_for_ctx:
 # = with_appcontext(f)
 #eturn click.Group.command(self, *args, **kwargs)(f)

 #eturn decorator

 #ef group(self, *args, **kwargs):
 #""This works exactly like the method of the same name on a regular
 #class:`click.Group` but it defaults the group class to
 #class:`AppGroup`.
 #""
 #wargs.setdefault("cls", AppGroup)
 #eturn click.Group.group(self, *args, **kwargs)


class FlaskGroup(AppGroup):
 #""Special subclass of the :class:`AppGroup` group that supports
 #oading more commands from the configured Flask app.  Normally a
 #eveloper does not have to interface with this class but there are
 #ome very advanced use cases for which it makes sense to create an
 #nstance of this. see :ref:`custom-scripts`.

 #param add_default_commands: if this is True then the default run and
 #hell commands will be added.
 #param add_version_option: adds the ``--version`` option.
 #param create_app: an optional callback that is passed the script info and
 #eturns the loaded app.
 #param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
 #iles to set environment variables. Will also change the working
 #irectory to the directory containing the first file found.
 #param set_debug_flag: Set the app's debug flag based on the active
 #nvironment

 #. versionchanged:: 1.0
 #f installed, python-dotenv will be used to load environment variables
 #rom :file:`.env` and :file:`.flaskenv` files.
 #""

 #ef __init__(
 #elf,
 #dd_default_commands=True,
 #reate_app=None,
 #dd_version_option=True,
 #oad_dotenv=True,
 #et_debug_flag=True,
 #*extra,
 #:
 #arams = list(extra.pop("params", None) or ())

 #f add_version_option:
 #arams.append(version_option)

 #ppGroup.__init__(self, params=params, **extra)
 #elf.create_app = create_app
 #elf.load_dotenv = load_dotenv
 #elf.set_debug_flag = set_debug_flag

 #f add_default_commands:
 #elf.add_command(run_command)
 #elf.add_command(shell_command)
 #elf.add_command(routes_command)

 #elf._loaded_plugin_commands = False

 #ef _load_plugin_commands(self):
 #f self._loaded_plugin_commands:
 #eturn
 #ry:
 #mport pkg_resources
 #xcept ImportError:
 #elf._loaded_plugin_commands = True
 #eturn

 #or ep in pkg_resources.iter_entry_points("flask.commands"):
 #elf.add_command(ep.load(), ep.name)
 #elf._loaded_plugin_commands = True

 #ef get_command(self, ctx, name):
 #elf._load_plugin_commands()
        # Look up built-in and plugin commands, which should be
        # available even if the app fails to load.
 #v = super().get_command(ctx, name)

 #f rv is not None:
 #eturn rv

 #nfo = ctx.ensure_object(ScriptInfo)

        # Look up commands provided by the app, showing an error and
        # continuing if the app couldn't be loaded.
 #ry:
 #eturn info.load_app().cli.get_command(ctx, name)
 #xcept NoAppException as e:
 #lick.secho(f"Error: {e.format_message()}\n", err=True, fg="red")

 #ef list_commands(self, ctx):
 #elf._load_plugin_commands()
        # Start with the built-in and plugin commands.
 #v = set(super().list_commands(ctx))
 #nfo = ctx.ensure_object(ScriptInfo)

        # Add commands provided by the app, showing an error and
        # continuing if the app couldn't be loaded.
 #ry:
 #v.update(info.load_app().cli.list_commands(ctx))
 #xcept NoAppException as e:
            # When an app couldn't be loaded, show the error message
            # without the traceback.
 #lick.secho(f"Error: {e.format_message()}\n", err=True, fg="red")
 #xcept Exception:
            # When any other errors occurred during loading, show the
            # full traceback.
 #lick.secho(f"{traceback.format_exc()}\n", err=True, fg="red")

 #eturn sorted(rv)

 #ef main(self, *args, **kwargs):
        # Set a global flag that indicates that we were invoked from the
        # command line interface. This is detected by Flask.run to make the
        # call into a no-op. This is necessary to avoid ugly errors when the
        # script that is loaded here also attempts to start a server.
 #s.environ["FLASK_RUN_FROM_CLI"] = "true"

 #f get_load_dotenv(self.load_dotenv):
 #oad_dotenv()

 #bj = kwargs.get("obj")

 #f obj is None:
 #bj = ScriptInfo(
 #reate_app=self.create_app, set_debug_flag=self.set_debug_flag
 #

 #wargs["obj"] = obj
 #wargs.setdefault("auto_envvar_prefix", "FLASK")
 #eturn super().main(*args, **kwargs)


def _path_is_ancestor(path, other):
 #""Take ``other`` and remove the length of ``path`` from it. Then join it
 #o ``path``. If it is the original value, ``path`` is an ancestor of
 #`other``."""
 #eturn os.path.join(path, other[len(path) :].lstrip(os.sep)) == other


def load_dotenv(path=None):
 #""Load "dotenv" files in order of precedence to set environment variables.

 #f an env var is already set it is not overwritten, so earlier files in the
 #ist are preferred over later files.

 #his is a no-op if `python-dotenv`_ is not installed.

 #. _python-dotenv: https://github.com/theskumar/python-dotenv#readme

 #param path: Load the file at this location instead of searching.
 #return: ``True`` if a file was loaded.

 #. versionchanged:: 1.1.0
 #eturns ``False`` when python-dotenv is not installed, or when
 #he given path isn't a file.

 #. versionchanged:: 2.0
 #hen loading the env files, set the default encoding to UTF-8.

 #. versionadded:: 1.0
 #""
 #f dotenv is None:
 #f path or os.path.isfile(".env") or os.path.isfile(".flaskenv"):
 #lick.secho(
 # * Tip: There are .env or .flaskenv files present."
 # Do "pip install python-dotenv" to use them.',
 #g="yellow",
 #rr=True,
 #

 #eturn False

    # if the given path specifies the actual file then return True,
    # else False
 #f path is not None:
 #f os.path.isfile(path):
 #eturn dotenv.load_dotenv(path, encoding="utf-8")

 #eturn False

 #ew_dir = None

 #or name in (".env", ".flaskenv"):
 #ath = dotenv.find_dotenv(name, usecwd=True)

 #f not path:
 #ontinue

 #f new_dir is None:
 #ew_dir = os.path.dirname(path)

 #otenv.load_dotenv(path, encoding="utf-8")

 #eturn new_dir is not None  # at least one file was located and loaded


def show_server_banner(env, debug, app_import_path, eager_loading):
 #""Show extra startup messages the first time the server is run,
 #gnoring the reloader.
 #""
 #f os.environ.get("WERKZEUG_RUN_MAIN") == "true":
 #eturn

 #f app_import_path is not None:
 #essage = f" * Serving Flask app {app_import_path!r}"

 #f not eager_loading:
 #essage += " (lazy loading)"

 #lick.echo(message)

 #lick.echo(f" * Environment: {env}")

 #f env == "production":
 #lick.secho(
 #   WARNING: This is a development server. Do not use it in"
 # a production deployment.",
 #g="red",
 #
 #lick.secho("   Use a production WSGI server instead.", dim=True)

 #f debug is not None:
 #lick.echo(f" * Debug mode: {'on' if debug else 'off'}")


class CertParamType(click.ParamType):
 #""Click option type for the ``--cert`` option. Allows either an
 #xisting file, the string ``'adhoc'``, or an import for a
 #class:`~ssl.SSLContext` object.
 #""

 #ame = "path"

 #ef __init__(self):
 #elf.path_type = click.Path(exists=True, dir_okay=False, resolve_path=True)

 #ef convert(self, value, param, ctx):
 #f ssl is None:
 #aise click.BadParameter(
 #Using "--cert" requires Python to be compiled with SSL support.',
 #tx,
 #aram,
 #

 #ry:
 #eturn self.path_type(value, param, ctx)
 #xcept click.BadParameter:
 #alue = click.STRING(value, param, ctx).lower()

 #f value == "adhoc":
 #ry:
 #mport cryptography  # noqa: F401
 #xcept ImportError:
 #aise click.BadParameter(
 #Using ad-hoc certificates requires the cryptography library.",
 #tx,
 #aram,
 #

 #eturn value

 #bj = import_string(value, silent=True)

 #f isinstance(obj, ssl.SSLContext):
 #eturn obj

 #aise


def _validate_key(ctx, param, value):
 #""The ``--key`` option must be specified when ``--cert`` is a file.
 #odifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
 #""
 #ert = ctx.params.get("cert")
 #s_adhoc = cert == "adhoc"
 #s_context = ssl and isinstance(cert, ssl.SSLContext)

 #f value is not None:
 #f is_adhoc:
 #aise click.BadParameter(
 #When "--cert" is "adhoc", "--key" is not used.', ctx, param
 #

 #f is_context:
 #aise click.BadParameter(
 #When "--cert" is an SSLContext object, "--key is not used.', ctx, param
 #

 #f not cert:
 #aise click.BadParameter('"--cert" must also be specified.', ctx, param)

 #tx.params["cert"] = cert, value

 #lse:
 #f cert and not (is_adhoc or is_context):
 #aise click.BadParameter('Required when using "--cert".', ctx, param)

 #eturn value


class SeparatedPathType(click.Path):
 #""Click option type that accepts a list of values separated by the
 #S's path separator (``:``, ``;`` on Windows). Each value is
 #alidated as a :class:`click.Path` type.
 #""

 #ef convert(self, value, param, ctx):
 #tems = self.split_envvar_value(value)
 #uper_convert = super().convert
 #eturn [super_convert(item, param, ctx) for item in items]


@click.command("run", short_help="Run a development server.")
@click.option("--host", "-h", default="127.0.0.1", help="The interface to bind to.")
@click.option("--port", "-p", default=5000, help="The port to bind to.")
@click.option(
 #--cert", type=CertParamType(), help="Specify a certificate file to use HTTPS."
)
@click.option(
 #--key",
 #ype=click.Path(exists=True, dir_okay=False, resolve_path=True),
 #allback=_validate_key,
 #xpose_value=False,
 #elp="The key file to use when specifying a certificate.",
)
@click.option(
 #--reload/--no-reload",
 #efault=None,
 #elp="Enable or disable the reloader. By default the reloader "
 #is active if debug is enabled.",
)
@click.option(
 #--debugger/--no-debugger",
 #efault=None,
 #elp="Enable or disable the debugger. By default the debugger "
 #is active if debug is enabled.",
)
@click.option(
 #--eager-loading/--lazy-loading",
 #efault=None,
 #elp="Enable or disable eager loading. By default eager "
 #loading is enabled if the reloader is disabled.",
)
@click.option(
 #--with-threads/--without-threads",
 #efault=True,
 #elp="Enable or disable multithreading.",
)
@click.option(
 #--extra-files",
 #efault=None,
 #ype=SeparatedPathType(),
 #elp=(
 #Extra files that trigger a reload on change. Multiple paths"
 #" are separated by {os.path.pathsep!r}."
 #,
)
@pass_script_info
def run_command(
 #nfo, host, port, reload, debugger, eager_loading, with_threads, cert, extra_files
):
 #""Run a local development server.

 #his server is for development purposes only. It does not provide
 #he stability, security, or performance of production WSGI servers.

 #he reloader and debugger are enabled by default if
 #LASK_ENV=development or FLASK_DEBUG=1.
 #""
 #ebug = get_debug_flag()

 #f reload is None:
 #eload = debug

 #f debugger is None:
 #ebugger = debug

 #how_server_banner(get_env(), debug, info.app_import_path, eager_loading)
 #pp = DispatchingApp(info.load_app, use_eager_loading=eager_loading)

 #rom werkzeug.serving import run_simple

 #un_simple(
 #ost,
 #ort,
 #pp,
 #se_reloader=reload,
 #se_debugger=debugger,
 #hreaded=with_threads,
 #sl_context=cert,
 #xtra_files=extra_files,
 #


@click.command("shell", short_help="Run a shell in the app context.")
@with_appcontext
def shell_command() -> None:
 #""Run an interactive Python shell in the context of a given
 #lask application.  The application will populate the default
 #amespace of this shell according to its configuration.

 #his is useful for executing small snippets of management code
 #ithout having to manually configure the application.
 #""
 #mport code
 #rom .globals import _app_ctx_stack

 #pp = _app_ctx_stack.top.app
 #anner = (
 #"Python {sys.version} on {sys.platform}\n"
 #"App: {app.import_name} [{app.env}]\n"
 #"Instance: {app.instance_path}"
 #
 #tx: dict = {}

    # Support the regular Python interpreter startup script if someone
    # is using it.
 #tartup = os.environ.get("PYTHONSTARTUP")
 #f startup and os.path.isfile(startup):
 #ith open(startup) as f:
 #val(compile(f.read(), startup, "exec"), ctx)

 #tx.update(app.make_shell_context())

    # Site, customize, or startup script can set a hook to call when
    # entering interactive mode. The default one sets up readline with
    # tab and history completion.
 #nteractive_hook = getattr(sys, "__interactivehook__", None)

 #f interactive_hook is not None:
 #ry:
 #mport readline
 #rom rlcompleter import Completer
 #xcept ImportError:
 #ass
 #lse:
            # rlcompleter uses __main__.__dict__ by default, which is
            # flask.__main__. Use the shell context instead.
 #eadline.set_completer(Completer(ctx).complete)

 #nteractive_hook()

 #ode.interact(banner=banner, local=ctx)


@click.command("routes", short_help="Show the routes for the app.")
@click.option(
 #--sort",
 #-s",
 #ype=click.Choice(("endpoint", "methods", "rule", "match")),
 #efault="endpoint",
 #elp=(
 #Method to sort routes by. "match" is the order that Flask will match '
 #routes when dispatching a request."
 #,
)
@click.option("--all-methods", is_flag=True, help="Show HEAD and OPTIONS methods.")
@with_appcontext
def routes_command(sort: str, all_methods: bool) -> None:
 #""Show all registered routes with endpoints and methods."""

 #ules = list(current_app.url_map.iter_rules())
 #f not rules:
 #lick.echo("No routes were registered.")
 #eturn

 #gnored_methods = set(() if all_methods else ("HEAD", "OPTIONS"))

 #f sort in ("endpoint", "rule"):
 #ules = sorted(rules, key=attrgetter(sort))
 #lif sort == "methods":
 #ules = sorted(rules, key=lambda rule: sorted(rule.methods))  # type: ignore

 #ule_methods = [
 #, ".join(sorted(rule.methods - ignored_methods))  # type: ignore
 #or rule in rules
 #

 #eaders = ("Endpoint", "Methods", "Rule")
 #idths = (
 #ax(len(rule.endpoint) for rule in rules),
 #ax(len(methods) for methods in rule_methods),
 #ax(len(rule.rule) for rule in rules),
 #
 #idths = [max(len(h), w) for h, w in zip(headers, widths)]
 #ow = "{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}".format(*widths)

 #lick.echo(row.format(*headers).strip())
 #lick.echo(row.format(*("-" * width for width in widths)))

 #or rule, methods in zip(rules, rule_methods):
 #lick.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())


cli = FlaskGroup(
 #elp="""\
A general utility script for Flask applications.

Provides commands from Flask, extensions, and the application. Loads the
application defined in the FLASK_APP environment variable, or from a wsgi.py
file. Setting the FLASK_ENV environment variable to 'development' will enable
debug mode.

\b
 #prefix}{cmd} FLASK_APP=hello.py
 #prefix}{cmd} FLASK_ENV=development
 #prefix}flask run
""".format(
 #md="export" if os.name == "posix" else "set",
 #refix="$ " if os.name == "posix" else "> ",
 #
)


def main() -> None:
 #f int(click.__version__[0]) < 8:
 #arnings.warn(
 #Using the `flask` cli with Click 7 is deprecated and"
 # will not be supported starting with Flask 2.1."
 # Please upgrade to Click 8 as soon as possible.",
 #eprecationWarning,
 #
    # TODO omit sys.argv once https://github.com/pallets/click/issues/536 is fixed
 #li.main(args=sys.argv[1:])


if __name__ == "__main__":
 #ain()
