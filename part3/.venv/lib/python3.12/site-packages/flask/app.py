import functools
import inspect
import logging
import os
import sys
import typing as t
import weakref
from datetime import timedelta
from itertools import chain
from threading import Lock
from types import TracebackType

from werkzeug.datastructures import Headers
from werkzeug.datastructures import ImmutableDict
from werkzeug.exceptions import BadRequest
from werkzeug.exceptions import BadRequestKeyError
from werkzeug.exceptions import HTTPException
from werkzeug.exceptions import InternalServerError
from werkzeug.local import ContextVar
from werkzeug.routing import BuildError
from werkzeug.routing import Map
from werkzeug.routing import MapAdapter
from werkzeug.routing import RequestRedirect
from werkzeug.routing import RoutingException
from werkzeug.routing import Rule
from werkzeug.wrappers import Response as BaseResponse

from . import cli
from . import json
from .config import Config
from .config import ConfigAttribute
from .ctx import _AppCtxGlobals
from .ctx import AppContext
from .ctx import RequestContext
from .globals import _request_ctx_stack
from .globals import g
from .globals import request
from .globals import session
from .helpers import _split_blueprint_path
from .helpers import get_debug_flag
from .helpers import get_env
from .helpers import get_flashed_messages
from .helpers import get_load_dotenv
from .helpers import locked_cached_property
from .helpers import url_for
from .json import jsonify
from .logging import create_logger
from .scaffold import _endpoint_from_view_func
from .scaffold import _sentinel
from .scaffold import find_package
from .scaffold import Scaffold
from .scaffold import setupmethod
from .sessions import SecureCookieSessionInterface
from .signals import appcontext_tearing_down
from .signals import got_request_exception
from .signals import request_finished
from .signals import request_started
from .signals import request_tearing_down
from .templating import DispatchingJinjaLoader
from .templating import Environment
from .typing import AfterRequestCallable
from .typing import BeforeRequestCallable
from .typing import ErrorHandlerCallable
from .typing import ResponseReturnValue
from .typing import TeardownCallable
from .typing import TemplateContextProcessorCallable
from .typing import TemplateFilterCallable
from .typing import TemplateGlobalCallable
from .typing import TemplateTestCallable
from .typing import URLDefaultCallable
from .typing import URLValuePreprocessorCallable
from .wrappers import Request
from .wrappers import Response

if t.TYPE_CHECKING:
 #mport typing_extensions as te
 #rom .blueprints import Blueprint
 #rom .testing import FlaskClient
 #rom .testing import FlaskCliRunner

if sys.version_info >= (3, 8):
 #scoroutinefunction = inspect.iscoroutinefunction
else:

 #ef iscoroutinefunction(func: t.Any) -> bool:
 #hile inspect.ismethod(func):
 #unc = func.__func__

 #hile isinstance(func, functools.partial):
 #unc = func.func

 #eturn inspect.iscoroutinefunction(func)


def _make_timedelta(value: t.Optional[timedelta]) -> t.Optional[timedelta]:
 #f value is None or isinstance(value, timedelta):
 #eturn value

 #eturn timedelta(seconds=value)


class Flask(Scaffold):
 #""The flask object implements a WSGI application and acts as the central
 #bject.  It is passed the name of the module or package of the
 #pplication.  Once it is created it will act as a central registry for
 #he view functions, the URL rules, template configuration and much more.

 #he name of the package is used to resolve resources from inside the
 #ackage or the folder the module is contained in depending on if the
 #ackage parameter resolves to an actual python package (a folder with
 #n :file:`__init__.py` file inside) or a standard module (just a ``.py`` file).

 #or more information about resource loading, see :func:`open_resource`.

 #sually you create a :class:`Flask` instance in your main module or
 #n the :file:`__init__.py` file of your package like this::

 #rom flask import Flask
 #pp = Flask(__name__)

 #. admonition:: About the First Parameter

 #he idea of the first parameter is to give Flask an idea of what
 #elongs to your application.  This name is used to find resources
 #n the filesystem, can be used by extensions to improve debugging
 #nformation and a lot more.

 #o it's important what you provide there.  If you are using a single
 #odule, `__name__` is always the correct value.  If you however are
 #sing a package, it's usually recommended to hardcode the name of
 #our package there.

 #or example if your application is defined in :file:`yourapplication/app.py`
 #ou should create it with one of the two versions below::

 #pp = Flask('yourapplication')
 #pp = Flask(__name__.split('.')[0])

 #hy is that?  The application will work even with `__name__`, thanks
 #o how resources are looked up.  However it will make debugging more
 #ainful.  Certain extensions can make assumptions based on the
 #mport name of your application.  For example the Flask-SQLAlchemy
 #xtension will look for the code in your application that triggered
 #n SQL query in debug mode.  If the import name is not properly set
 #p, that debugging information is lost.  (For example it would only
 #ick up SQL queries in `yourapplication.app` and not
 #yourapplication.views.frontend`)

 #. versionadded:: 0.7
 #he `static_url_path`, `static_folder`, and `template_folder`
 #arameters were added.

 #. versionadded:: 0.8
 #he `instance_path` and `instance_relative_config` parameters were
 #dded.

 #. versionadded:: 0.11
 #he `root_path` parameter was added.

 #. versionadded:: 1.0
 #he ``host_matching`` and ``static_host`` parameters were added.

 #. versionadded:: 1.0
 #he ``subdomain_matching`` parameter was added. Subdomain
 #atching needs to be enabled manually now. Setting
 #data:`SERVER_NAME` does not implicitly enable it.

 #param import_name: the name of the application package
 #param static_url_path: can be used to specify a different path for the
 #tatic files on the web.  Defaults to the name
 #f the `static_folder` folder.
 #param static_folder: The folder with static files that is served at
 #`static_url_path``. Relative to the application ``root_path``
 #r an absolute path. Defaults to ``'static'``.
 #param static_host: the host to use when adding the static route.
 #efaults to None. Required when using ``host_matching=True``
 #ith a ``static_folder`` configured.
 #param host_matching: set ``url_map.host_matching`` attribute.
 #efaults to False.
 #param subdomain_matching: consider the subdomain relative to
 #data:`SERVER_NAME` when matching routes. Defaults to False.
 #param template_folder: the folder that contains the templates that should
 #e used by the application.  Defaults to
 #`'templates'`` folder in the root path of the
 #pplication.
 #param instance_path: An alternative instance path for the application.
 #y default the folder ``'instance'`` next to the
 #ackage or module is assumed to be the instance
 #ath.
 #param instance_relative_config: if set to ``True`` relative filenames
 #or loading the config are assumed to
 #e relative to the instance path instead
 #f the application root.
 #param root_path: The path to the root of the application files.
 #his should only be set manually when it can't be detected
 #utomatically, such as for namespace packages.
 #""

    #: The class that is used for request objects.  See :class:`~flask.Request`
    #: for more information.
 #equest_class = Request

    #: The class that is used for response objects.  See
    #: :class:`~flask.Response` for more information.
 #esponse_class = Response

    #: The class that is used for the Jinja environment.
    #:
    #: .. versionadded:: 0.11
 #inja_environment = Environment

    #: The class that is used for the :data:`~flask.g` instance.
    #:
    #: Example use cases for a custom class:
    #:
    #: 1. Store arbitrary attributes on flask.g.
    #: 2. Add a property for lazy per-request database connectors.
    #: 3. Return None instead of AttributeError on unexpected attributes.
    #: 4. Raise exception if an unexpected attr is set, a "controlled" flask.g.
    #:
    #: In Flask 0.9 this property was called `request_globals_class` but it
    #: was changed in 0.10 to :attr:`app_ctx_globals_class` because the
    #: flask.g object is now application context scoped.
    #:
    #: .. versionadded:: 0.10
 #pp_ctx_globals_class = _AppCtxGlobals

    #: The class that is used for the ``config`` attribute of this app.
    #: Defaults to :class:`~flask.Config`.
    #:
    #: Example use cases for a custom class:
    #:
    #: 1. Default values for certain config options.
    #: 2. Access to config values through attributes in addition to keys.
    #:
    #: .. versionadded:: 0.11
 #onfig_class = Config

    #: The testing flag.  Set this to ``True`` to enable the test mode of
    #: Flask extensions (and in the future probably also Flask itself).
    #: For example this might activate test helpers that have an
    #: additional runtime cost which should not be enabled by default.
    #:
    #: If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the
    #: default it's implicitly enabled.
    #:
    #: This attribute can also be configured from the config with the
    #: ``TESTING`` configuration key.  Defaults to ``False``.
 #esting = ConfigAttribute("TESTING")

    #: If a secret key is set, cryptographic components can use this to
    #: sign cookies and other things. Set this to a complex random value
    #: when you want to use the secure cookie for instance.
    #:
    #: This attribute can also be configured from the config with the
    #: :data:`SECRET_KEY` configuration key. Defaults to ``None``.
 #ecret_key = ConfigAttribute("SECRET_KEY")

    #: The secure cookie uses this for the name of the session cookie.
    #:
    #: This attribute can also be configured from the config with the
    #: ``SESSION_COOKIE_NAME`` configuration key.  Defaults to ``'session'``
 #ession_cookie_name = ConfigAttribute("SESSION_COOKIE_NAME")

    #: A :class:`~datetime.timedelta` which is used to set the expiration
    #: date of a permanent session.  The default is 31 days which makes a
    #: permanent session survive for roughly one month.
    #:
    #: This attribute can also be configured from the config with the
    #: ``PERMANENT_SESSION_LIFETIME`` configuration key.  Defaults to
    #: ``timedelta(days=31)``
 #ermanent_session_lifetime = ConfigAttribute(
 #PERMANENT_SESSION_LIFETIME", get_converter=_make_timedelta
 #

    #: A :class:`~datetime.timedelta` or number of seconds which is used
    #: as the default ``max_age`` for :func:`send_file`. The default is
    #: ``None``, which tells the browser to use conditional requests
    #: instead of a timed cache.
    #:
    #: Configured with the :data:`SEND_FILE_MAX_AGE_DEFAULT`
    #: configuration key.
    #:
    #: .. versionchanged:: 2.0
    #:     Defaults to ``None`` instead of 12 hours.
 #end_file_max_age_default = ConfigAttribute(
 #SEND_FILE_MAX_AGE_DEFAULT", get_converter=_make_timedelta
 #

    #: Enable this if you want to use the X-Sendfile feature.  Keep in
    #: mind that the server has to support this.  This only affects files
    #: sent with the :func:`send_file` method.
    #:
    #: .. versionadded:: 0.2
    #:
    #: This attribute can also be configured from the config with the
    #: ``USE_X_SENDFILE`` configuration key.  Defaults to ``False``.
 #se_x_sendfile = ConfigAttribute("USE_X_SENDFILE")

    #: The JSON encoder class to use.  Defaults to :class:`~flask.json.JSONEncoder`.
    #:
    #: .. versionadded:: 0.10
 #son_encoder = json.JSONEncoder

    #: The JSON decoder class to use.  Defaults to :class:`~flask.json.JSONDecoder`.
    #:
    #: .. versionadded:: 0.10
 #son_decoder = json.JSONDecoder

    #: Options that are passed to the Jinja environment in
    #: :meth:`create_jinja_environment`. Changing these options after
    #: the environment is created (accessing :attr:`jinja_env`) will
    #: have no effect.
    #:
    #: .. versionchanged:: 1.1.0
    #:     This is a ``dict`` instead of an ``ImmutableDict`` to allow
    #:     easier configuration.
    #:
 #inja_options: dict = {}

    #: Default configuration parameters.
 #efault_config = ImmutableDict(
 #
 #ENV": None,
 #DEBUG": None,
 #TESTING": False,
 #PROPAGATE_EXCEPTIONS": None,
 #PRESERVE_CONTEXT_ON_EXCEPTION": None,
 #SECRET_KEY": None,
 #PERMANENT_SESSION_LIFETIME": timedelta(days=31),
 #USE_X_SENDFILE": False,
 #SERVER_NAME": None,
 #APPLICATION_ROOT": "/",
 #SESSION_COOKIE_NAME": "session",
 #SESSION_COOKIE_DOMAIN": None,
 #SESSION_COOKIE_PATH": None,
 #SESSION_COOKIE_HTTPONLY": True,
 #SESSION_COOKIE_SECURE": False,
 #SESSION_COOKIE_SAMESITE": None,
 #SESSION_REFRESH_EACH_REQUEST": True,
 #MAX_CONTENT_LENGTH": None,
 #SEND_FILE_MAX_AGE_DEFAULT": None,
 #TRAP_BAD_REQUEST_ERRORS": None,
 #TRAP_HTTP_EXCEPTIONS": False,
 #EXPLAIN_TEMPLATE_LOADING": False,
 #PREFERRED_URL_SCHEME": "http",
 #JSON_AS_ASCII": True,
 #JSON_SORT_KEYS": True,
 #JSONIFY_PRETTYPRINT_REGULAR": False,
 #JSONIFY_MIMETYPE": "application/json",
 #TEMPLATES_AUTO_RELOAD": None,
 #MAX_COOKIE_SIZE": 4093,
 #
 #

    #: The rule object to use for URL rules created.  This is used by
    #: :meth:`add_url_rule`.  Defaults to :class:`werkzeug.routing.Rule`.
    #:
    #: .. versionadded:: 0.7
 #rl_rule_class = Rule

    #: The map object to use for storing the URL rules and routing
    #: configuration parameters. Defaults to :class:`werkzeug.routing.Map`.
    #:
    #: .. versionadded:: 1.1.0
 #rl_map_class = Map

    #: the test client that is used with when `test_client` is used.
    #:
    #: .. versionadded:: 0.7
 #est_client_class: t.Optional[t.Type["FlaskClient"]] = None

    #: The :class:`~click.testing.CliRunner` subclass, by default
    #: :class:`~flask.testing.FlaskCliRunner` that is used by
    #: :meth:`test_cli_runner`. Its ``__init__`` method should take a
    #: Flask app object as the first argument.
    #:
    #: .. versionadded:: 1.0
 #est_cli_runner_class: t.Optional[t.Type["FlaskCliRunner"]] = None

    #: the session interface to use.  By default an instance of
    #: :class:`~flask.sessions.SecureCookieSessionInterface` is used here.
    #:
    #: .. versionadded:: 0.8
 #ession_interface = SecureCookieSessionInterface()

 #ef __init__(
 #elf,
 #mport_name: str,
 #tatic_url_path: t.Optional[str] = None,
 #tatic_folder: t.Optional[str] = "static",
 #tatic_host: t.Optional[str] = None,
 #ost_matching: bool = False,
 #ubdomain_matching: bool = False,
 #emplate_folder: t.Optional[str] = "templates",
 #nstance_path: t.Optional[str] = None,
 #nstance_relative_config: bool = False,
 #oot_path: t.Optional[str] = None,
 #:
 #uper().__init__(
 #mport_name=import_name,
 #tatic_folder=static_folder,
 #tatic_url_path=static_url_path,
 #emplate_folder=template_folder,
 #oot_path=root_path,
 #

 #f instance_path is None:
 #nstance_path = self.auto_find_instance_path()
 #lif not os.path.isabs(instance_path):
 #aise ValueError(
 #If an instance path is provided it must be absolute."
 # A relative path was given instead."
 #

        #: Holds the path to the instance folder.
        #:
        #: .. versionadded:: 0.8
 #elf.instance_path = instance_path

        #: The configuration dictionary as :class:`Config`.  This behaves
        #: exactly like a regular dictionary but supports additional methods
        #: to load a config from files.
 #elf.config = self.make_config(instance_relative_config)

        #: A list of functions that are called when :meth:`url_for` raises a
        #: :exc:`~werkzeug.routing.BuildError`.  Each function registered here
        #: is called with `error`, `endpoint` and `values`.  If a function
        #: returns ``None`` or raises a :exc:`BuildError` the next function is
        #: tried.
        #:
        #: .. versionadded:: 0.9
 #elf.url_build_error_handlers: t.List[
 #.Callable[[Exception, str, dict], str]
 # = []

        #: A list of functions that will be called at the beginning of the
        #: first request to this instance. To register a function, use the
        #: :meth:`before_first_request` decorator.
        #:
        #: .. versionadded:: 0.8
 #elf.before_first_request_funcs: t.List[BeforeRequestCallable] = []

        #: A list of functions that are called when the application context
        #: is destroyed.  Since the application context is also torn down
        #: if the request ends this is the place to store code that disconnects
        #: from databases.
        #:
        #: .. versionadded:: 0.9
 #elf.teardown_appcontext_funcs: t.List[TeardownCallable] = []

        #: A list of shell context processor functions that should be run
        #: when a shell context is created.
        #:
        #: .. versionadded:: 0.11
 #elf.shell_context_processors: t.List[t.Callable[[], t.Dict[str, t.Any]]] = []

        #: Maps registered blueprint names to blueprint objects. The
        #: dict retains the order the blueprints were registered in.
        #: Blueprints can be registered multiple times, this dict does
        #: not track how often they were attached.
        #:
        #: .. versionadded:: 0.7
 #elf.blueprints: t.Dict[str, "Blueprint"] = {}

        #: a place where extensions can store application specific state.  For
        #: example this is where an extension could store database engines and
        #: similar things.
        #:
        #: The key must match the name of the extension module. For example in
        #: case of a "Flask-Foo" extension in `flask_foo`, the key would be
        #: ``'foo'``.
        #:
        #: .. versionadded:: 0.7
 #elf.extensions: dict = {}

        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use
        #: this to change the routing converters after the class was created
        #: but before any routes are connected.  Example::
        #:
        #:    from werkzeug.routing import BaseConverter
        #:
        #:    class ListConverter(BaseConverter):
        #:        def to_python(self, value):
        #:            return value.split(',')
        #:        def to_url(self, values):
        #:            return ','.join(super(ListConverter, self).to_url(value)
        #:                            for value in values)
        #:
        #:    app = Flask(__name__)
        #:    app.url_map.converters['list'] = ListConverter
 #elf.url_map = self.url_map_class()

 #elf.url_map.host_matching = host_matching
 #elf.subdomain_matching = subdomain_matching

        # tracks internally if the application already handled at least one
        # request.
 #elf._got_first_request = False
 #elf._before_request_lock = Lock()

        # Add a static route using the provided static_url_path, static_host,
        # and static_folder if there is a configured static_folder.
        # Note we do this without checking if static_folder exists.
        # For one, it might be created while the server is running (e.g. during
        # development). Also, Google App Engine stores static files somewhere
 #f self.has_static_folder:
 #ssert (
 #ool(static_host) == host_matching
 #, "Invalid static_host/host_matching combination"
            # Use a weakref to avoid creating a reference cycle between the app
            # and the view function (see #3761).
 #elf_ref = weakref.ref(self)
 #elf.add_url_rule(
 #"{self.static_url_path}/<path:filename>",
 #ndpoint="static",
 #ost=static_host,
 #iew_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950
 #

        # Set the name of the Click group in case someone wants to add
        # the app's commands to another CLI tool.
 #elf.cli.name = self.name

 #ef _is_setup_finished(self) -> bool:
 #eturn self.debug and self._got_first_request

 #locked_cached_property
 #ef name(self) -> str:  # type: ignore
 #""The name of the application.  This is usually the import name
 #ith the difference that it's guessed from the run file if the
 #mport name is main.  This name is used as a display name when
 #lask needs the name of the application.  It can be set and overridden
 #o change the value.

 #. versionadded:: 0.8
 #""
 #f self.import_name == "__main__":
 #n = getattr(sys.modules["__main__"], "__file__", None)
 #f fn is None:
 #eturn "__main__"
 #eturn os.path.splitext(os.path.basename(fn))[0]
 #eturn self.import_name

 #property
 #ef propagate_exceptions(self) -> bool:
 #""Returns the value of the ``PROPAGATE_EXCEPTIONS`` configuration
 #alue in case it's set, otherwise a sensible default is returned.

 #. versionadded:: 0.7
 #""
 #v = self.config["PROPAGATE_EXCEPTIONS"]
 #f rv is not None:
 #eturn rv
 #eturn self.testing or self.debug

 #property
 #ef preserve_context_on_exception(self) -> bool:
 #""Returns the value of the ``PRESERVE_CONTEXT_ON_EXCEPTION``
 #onfiguration value in case it's set, otherwise a sensible default
 #s returned.

 #. versionadded:: 0.7
 #""
 #v = self.config["PRESERVE_CONTEXT_ON_EXCEPTION"]
 #f rv is not None:
 #eturn rv
 #eturn self.debug

 #locked_cached_property
 #ef logger(self) -> logging.Logger:
 #""A standard Python :class:`~logging.Logger` for the app, with
 #he same name as :attr:`name`.

 #n debug mode, the logger's :attr:`~logging.Logger.level` will
 #e set to :data:`~logging.DEBUG`.

 #f there are no handlers configured, a default handler will be
 #dded. See :doc:`/logging` for more information.

 #. versionchanged:: 1.1.0
 #he logger takes the same name as :attr:`name` rather than
 #ard-coding ``"flask.app"``.

 #. versionchanged:: 1.0.0
 #ehavior was simplified. The logger is always named
 #`"flask.app"``. The level is only set during configuration,
 #t doesn't check ``app.debug`` each time. Only one format is
 #sed, not different ones depending on ``app.debug``. No
 #andlers are removed, and a handler is only added if no
 #andlers are already configured.

 #. versionadded:: 0.3
 #""
 #eturn create_logger(self)

 #locked_cached_property
 #ef jinja_env(self) -> Environment:
 #""The Jinja environment used to load templates.

 #he environment is created the first time this property is
 #ccessed. Changing :attr:`jinja_options` after that will have no
 #ffect.
 #""
 #eturn self.create_jinja_environment()

 #property
 #ef got_first_request(self) -> bool:
 #""This attribute is set to ``True`` if the application started
 #andling the first request.

 #. versionadded:: 0.8
 #""
 #eturn self._got_first_request

 #ef make_config(self, instance_relative: bool = False) -> Config:
 #""Used to create the config attribute by the Flask constructor.
 #he `instance_relative` parameter is passed in from the constructor
 #f Flask (there named `instance_relative_config`) and indicates if
 #he config should be relative to the instance path or the root path
 #f the application.

 #. versionadded:: 0.8
 #""
 #oot_path = self.root_path
 #f instance_relative:
 #oot_path = self.instance_path
 #efaults = dict(self.default_config)
 #efaults["ENV"] = get_env()
 #efaults["DEBUG"] = get_debug_flag()
 #eturn self.config_class(root_path, defaults)

 #ef auto_find_instance_path(self) -> str:
 #""Tries to locate the instance path if it was not provided to the
 #onstructor of the application class.  It will basically calculate
 #he path to a folder named ``instance`` next to your main file or
 #he package.

 #. versionadded:: 0.8
 #""
 #refix, package_path = find_package(self.import_name)
 #f prefix is None:
 #eturn os.path.join(package_path, "instance")
 #eturn os.path.join(prefix, "var", f"{self.name}-instance")

 #ef open_instance_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
 #""Opens a resource from the application's instance folder
 #:attr:`instance_path`).  Otherwise works like
 #meth:`open_resource`.  Instance resources can also be opened for
 #riting.

 #param resource: the name of the resource.  To access resources within
 #ubfolders use forward slashes as separator.
 #param mode: resource file opening mode, default is 'rb'.
 #""
 #eturn open(os.path.join(self.instance_path, resource), mode)

 #property
 #ef templates_auto_reload(self) -> bool:
 #""Reload templates when they are changed. Used by
 #meth:`create_jinja_environment`.

 #his attribute can be configured with :data:`TEMPLATES_AUTO_RELOAD`. If
 #ot set, it will be enabled in debug mode.

 #. versionadded:: 1.0
 #his property was added but the underlying config and behavior
 #lready existed.
 #""
 #v = self.config["TEMPLATES_AUTO_RELOAD"]
 #eturn rv if rv is not None else self.debug

 #templates_auto_reload.setter
 #ef templates_auto_reload(self, value: bool) -> None:
 #elf.config["TEMPLATES_AUTO_RELOAD"] = value

 #ef create_jinja_environment(self) -> Environment:
 #""Create the Jinja environment based on :attr:`jinja_options`
 #nd the various Jinja-related methods of the app. Changing
 #attr:`jinja_options` after this will have no effect. Also adds
 #lask-related globals and filters to the environment.

 #. versionchanged:: 0.11
 #`Environment.auto_reload`` set in accordance with
 #`TEMPLATES_AUTO_RELOAD`` configuration option.

 #. versionadded:: 0.5
 #""
 #ptions = dict(self.jinja_options)

 #f "autoescape" not in options:
 #ptions["autoescape"] = self.select_jinja_autoescape

 #f "auto_reload" not in options:
 #ptions["auto_reload"] = self.templates_auto_reload

 #v = self.jinja_environment(self, **options)
 #v.globals.update(
 #rl_for=url_for,
 #et_flashed_messages=get_flashed_messages,
 #onfig=self.config,
            # request, session and g are normally added with the
            # context processor for efficiency reasons but for imported
            # templates we also want the proxies in there.
 #equest=request,
 #ession=session,
 #=g,
 #
 #v.policies["json.dumps_function"] = json.dumps
 #eturn rv

 #ef create_global_jinja_loader(self) -> DispatchingJinjaLoader:
 #""Creates the loader for the Jinja2 environment.  Can be used to
 #verride just the loader and keeping the rest unchanged.  It's
 #iscouraged to override this function.  Instead one should override
 #he :meth:`jinja_loader` function instead.

 #he global loader dispatches between the loaders of the application
 #nd the individual blueprints.

 #. versionadded:: 0.7
 #""
 #eturn DispatchingJinjaLoader(self)

 #ef select_jinja_autoescape(self, filename: str) -> bool:
 #""Returns ``True`` if autoescaping should be active for the given
 #emplate name. If no template name is given, returns `True`.

 #. versionadded:: 0.5
 #""
 #f filename is None:
 #eturn True
 #eturn filename.endswith((".html", ".htm", ".xml", ".xhtml"))

 #ef update_template_context(self, context: dict) -> None:
 #""Update the template context with some commonly used variables.
 #his injects request, session, config and g into the template
 #ontext as well as everything template context processors want
 #o inject.  Note that the as of Flask 0.6, the original values
 #n the context will not be overridden if a context processor
 #ecides to return a value with the same key.

 #param context: the context as a dictionary that is updated in place
 #o add extra variables.
 #""
 #uncs: t.Iterable[
 #emplateContextProcessorCallable
 # = self.template_context_processors[None]
 #eqctx = _request_ctx_stack.top
 #f reqctx is not None:
 #or bp in request.blueprints:
 #f bp in self.template_context_processors:
 #uncs = chain(funcs, self.template_context_processors[bp])
 #rig_ctx = context.copy()
 #or func in funcs:
 #ontext.update(func())
        # make sure the original values win.  This makes it possible to
        # easier add new variables in context processors without breaking
        # existing views.
 #ontext.update(orig_ctx)

 #ef make_shell_context(self) -> dict:
 #""Returns the shell context for an interactive shell for this
 #pplication.  This runs all the registered shell context
 #rocessors.

 #. versionadded:: 0.11
 #""
 #v = {"app": self, "g": g}
 #or processor in self.shell_context_processors:
 #v.update(processor())
 #eturn rv

    #: What environment the app is running in. Flask and extensions may
    #: enable behaviors based on the environment, such as enabling debug
    #: mode. This maps to the :data:`ENV` config key. This is set by the
    #: :envvar:`FLASK_ENV` environment variable and may not behave as
    #: expected if set in code.
    #:
    #: **Do not enable development when deploying in production.**
    #:
    #: Default: ``'production'``
 #nv = ConfigAttribute("ENV")

 #property
 #ef debug(self) -> bool:
 #""Whether debug mode is enabled. When using ``flask run`` to start
 #he development server, an interactive debugger will be shown for
 #nhandled exceptions, and the server will be reloaded when code
 #hanges. This maps to the :data:`DEBUG` config key. This is
 #nabled when :attr:`env` is ``'development'`` and is overridden
 #y the ``FLASK_DEBUG`` environment variable. It may not behave as
 #xpected if set in code.

 #*Do not enable debug mode when deploying in production.**

 #efault: ``True`` if :attr:`env` is ``'development'``, or
 #`False`` otherwise.
 #""
 #eturn self.config["DEBUG"]

 #debug.setter
 #ef debug(self, value: bool) -> None:
 #elf.config["DEBUG"] = value
 #elf.jinja_env.auto_reload = self.templates_auto_reload

 #ef run(
 #elf,
 #ost: t.Optional[str] = None,
 #ort: t.Optional[int] = None,
 #ebug: t.Optional[bool] = None,
 #oad_dotenv: bool = True,
 #*options: t.Any,
 # -> None:
 #""Runs the application on a local development server.

 #o not use ``run()`` in a production setting. It is not intended to
 #eet security and performance requirements for a production server.
 #nstead, see :doc:`/deploying/index` for WSGI server recommendations.

 #f the :attr:`debug` flag is set the server will automatically reload
 #or code changes and show a debugger in case an exception happened.

 #f you want to run the application in debug mode, but disable the
 #ode execution on the interactive debugger, you can pass
 #`use_evalex=False`` as parameter.  This will keep the debugger's
 #raceback screen active, but disable code execution.

 #t is not recommended to use this function for development with
 #utomatic reloading as this is badly supported.  Instead you should
 #e using the :command:`flask` command line script's ``run`` support.

 #. admonition:: Keep in Mind

 #lask will suppress any server error with a generic error page
 #nless it is in debug mode.  As such to enable just the
 #nteractive debugger without the code reloading, you have to
 #nvoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.
 #etting ``use_debugger`` to ``True`` without being in debug mode
 #on't catch any exceptions because there won't be any to
 #atch.

 #param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
 #ave the server available externally as well. Defaults to
 #`'127.0.0.1'`` or the host in the ``SERVER_NAME`` config variable
 #f present.
 #param port: the port of the webserver. Defaults to ``5000`` or the
 #ort defined in the ``SERVER_NAME`` config variable if present.
 #param debug: if given, enable or disable debug mode. See
 #attr:`debug`.
 #param load_dotenv: Load the nearest :file:`.env` and :file:`.flaskenv`
 #iles to set environment variables. Will also change the working
 #irectory to the directory containing the first file found.
 #param options: the options to be forwarded to the underlying Werkzeug
 #erver. See :func:`werkzeug.serving.run_simple` for more
 #nformation.

 #. versionchanged:: 1.0
 #f installed, python-dotenv will be used to load environment
 #ariables from :file:`.env` and :file:`.flaskenv` files.

 #f set, the :envvar:`FLASK_ENV` and :envvar:`FLASK_DEBUG`
 #nvironment variables will override :attr:`env` and
 #attr:`debug`.

 #hreaded mode is enabled by default.

 #. versionchanged:: 0.10
 #he default port is now picked from the ``SERVER_NAME``
 #ariable.
 #""
        # Change this into a no-op if the server is invoked from the
        # command line. Have a look at cli.py for more information.
 #f os.environ.get("FLASK_RUN_FROM_CLI") == "true":
 #rom .debughelpers import explain_ignored_app_run

 #xplain_ignored_app_run()
 #eturn

 #f get_load_dotenv(load_dotenv):
 #li.load_dotenv()

            # if set, let env vars override previous values
 #f "FLASK_ENV" in os.environ:
 #elf.env = get_env()
 #elf.debug = get_debug_flag()
 #lif "FLASK_DEBUG" in os.environ:
 #elf.debug = get_debug_flag()

        # debug passed to method overrides all other sources
 #f debug is not None:
 #elf.debug = bool(debug)

 #erver_name = self.config.get("SERVER_NAME")
 #n_host = sn_port = None

 #f server_name:
 #n_host, _, sn_port = server_name.partition(":")

 #f not host:
 #f sn_host:
 #ost = sn_host
 #lse:
 #ost = "127.0.0.1"

 #f port or port == 0:
 #ort = int(port)
 #lif sn_port:
 #ort = int(sn_port)
 #lse:
 #ort = 5000

 #ptions.setdefault("use_reloader", self.debug)
 #ptions.setdefault("use_debugger", self.debug)
 #ptions.setdefault("threaded", True)

 #li.show_server_banner(self.env, self.debug, self.name, False)

 #rom werkzeug.serving import run_simple

 #ry:
 #un_simple(t.cast(str, host), port, self, **options)
 #inally:
            # reset the first request information if the development server
            # reset normally.  This makes it possible to restart the server
            # without reloader and that stuff from an interactive shell.
 #elf._got_first_request = False

 #ef test_client(self, use_cookies: bool = True, **kwargs: t.Any) -> "FlaskClient":
 #""Creates a test client for this application.  For information
 #bout unit testing head over to :doc:`/testing`.

 #ote that if you are testing for assertions or exceptions in your
 #pplication code, you must set ``app.testing = True`` in order for the
 #xceptions to propagate to the test client.  Otherwise, the exception
 #ill be handled by the application (not visible to the test client) and
 #he only indication of an AssertionError or other exception will be a
 #00 status code response to the test client.  See the :attr:`testing`
 #ttribute.  For example::

 #pp.testing = True
 #lient = app.test_client()

 #he test client can be used in a ``with`` block to defer the closing down
 #f the context until the end of the ``with`` block.  This is useful if
 #ou want to access the context locals for testing::

 #ith app.test_client() as c:
 #v = c.get('/?vodka=42')
 #ssert request.args['vodka'] == '42'

 #dditionally, you may pass optional keyword arguments that will then
 #e passed to the application's :attr:`test_client_class` constructor.
 #or example::

 #rom flask.testing import FlaskClient

 #lass CustomClient(FlaskClient):
 #ef __init__(self, *args, **kwargs):
 #elf._authentication = kwargs.pop("authentication")
 #uper(CustomClient,self).__init__( *args, **kwargs)

 #pp.test_client_class = CustomClient
 #lient = app.test_client(authentication='Basic ....')

 #ee :class:`~flask.testing.FlaskClient` for more information.

 #. versionchanged:: 0.4
 #dded support for ``with`` block usage for the client.

 #. versionadded:: 0.7
 #he `use_cookies` parameter was added as well as the ability
 #o override the client to be used by setting the
 #attr:`test_client_class` attribute.

 #. versionchanged:: 0.11
 #dded `**kwargs` to support passing additional keyword arguments to
 #he constructor of :attr:`test_client_class`.
 #""
 #ls = self.test_client_class
 #f cls is None:
 #rom .testing import FlaskClient as cls  # type: ignore
 #eturn cls(  # type: ignore
 #elf, self.response_class, use_cookies=use_cookies, **kwargs
 #

 #ef test_cli_runner(self, **kwargs: t.Any) -> "FlaskCliRunner":
 #""Create a CLI runner for testing CLI commands.
 #ee :ref:`testing-cli`.

 #eturns an instance of :attr:`test_cli_runner_class`, by default
 #class:`~flask.testing.FlaskCliRunner`. The Flask app object is
 #assed as the first argument.

 #. versionadded:: 1.0
 #""
 #ls = self.test_cli_runner_class

 #f cls is None:
 #rom .testing import FlaskCliRunner as cls  # type: ignore

 #eturn cls(self, **kwargs)  # type: ignore

 #setupmethod
 #ef register_blueprint(self, blueprint: "Blueprint", **options: t.Any) -> None:
 #""Register a :class:`~flask.Blueprint` on the application. Keyword
 #rguments passed to this method will override the defaults set on the
 #lueprint.

 #alls the blueprint's :meth:`~flask.Blueprint.register` method after
 #ecording the blueprint in the application's :attr:`blueprints`.

 #param blueprint: The blueprint to register.
 #param url_prefix: Blueprint routes will be prefixed with this.
 #param subdomain: Blueprint routes will match on this subdomain.
 #param url_defaults: Blueprint routes will use these default values for
 #iew arguments.
 #param options: Additional keyword arguments are passed to
 #class:`~flask.blueprints.BlueprintSetupState`. They can be
 #ccessed in :meth:`~flask.Blueprint.record` callbacks.

 #. versionchanged:: 2.0.1
 #he ``name`` option can be used to change the (pre-dotted)
 #ame the blueprint is registered with. This allows the same
 #lueprint to be registered multiple times with unique names
 #or ``url_for``.

 #. versionadded:: 0.7
 #""
 #lueprint.register(self, options)

 #ef iter_blueprints(self) -> t.ValuesView["Blueprint"]:
 #""Iterates over all blueprints by the order they were registered.

 #. versionadded:: 0.11
 #""
 #eturn self.blueprints.values()

 #setupmethod
 #ef add_url_rule(
 #elf,
 #ule: str,
 #ndpoint: t.Optional[str] = None,
 #iew_func: t.Optional[t.Callable] = None,
 #rovide_automatic_options: t.Optional[bool] = None,
 #*options: t.Any,
 # -> None:
 #f endpoint is None:
 #ndpoint = _endpoint_from_view_func(view_func)  # type: ignore
 #ptions["endpoint"] = endpoint
 #ethods = options.pop("methods", None)

        # if the methods are not given and the view_func object knows its
        # methods we can use that instead.  If neither exists, we go with
        # a tuple of only ``GET`` as default.
 #f methods is None:
 #ethods = getattr(view_func, "methods", None) or ("GET",)
 #f isinstance(methods, str):
 #aise TypeError(
 #Allowed methods must be a list of strings, for"
 # example: @app.route(..., methods=["POST"])'
 #
 #ethods = {item.upper() for item in methods}

        # Methods that should always be added
 #equired_methods = set(getattr(view_func, "required_methods", ()))

        # starting with Flask 0.8 the view_func object can disable and
        # force-enable the automatic options handling.
 #f provide_automatic_options is None:
 #rovide_automatic_options = getattr(
 #iew_func, "provide_automatic_options", None
 #

 #f provide_automatic_options is None:
 #f "OPTIONS" not in methods:
 #rovide_automatic_options = True
 #equired_methods.add("OPTIONS")
 #lse:
 #rovide_automatic_options = False

        # Add the required methods now.
 #ethods |= required_methods

 #ule = self.url_rule_class(rule, methods=methods, **options)
 #ule.provide_automatic_options = provide_automatic_options  # type: ignore

 #elf.url_map.add(rule)
 #f view_func is not None:
 #ld_func = self.view_functions.get(endpoint)
 #f old_func is not None and old_func != view_func:
 #aise AssertionError(
 #View function mapping is overwriting an existing"
 #" endpoint function: {endpoint}"
 #
 #elf.view_functions[endpoint] = view_func

 #setupmethod
 #ef template_filter(
 #elf, name: t.Optional[str] = None
 # -> t.Callable[[TemplateFilterCallable], TemplateFilterCallable]:
 #""A decorator that is used to register custom template filter.
 #ou can specify a name for the filter, otherwise the function
 #ame will be used. Example::

 #app.template_filter()
 #ef reverse(s):
 #eturn s[::-1]

 #param name: the optional name of the filter, otherwise the
 #unction name will be used.
 #""

 #ef decorator(f: TemplateFilterCallable) -> TemplateFilterCallable:
 #elf.add_template_filter(f, name=name)
 #eturn f

 #eturn decorator

 #setupmethod
 #ef add_template_filter(
 #elf, f: TemplateFilterCallable, name: t.Optional[str] = None
 # -> None:
 #""Register a custom template filter.  Works exactly like the
 #meth:`template_filter` decorator.

 #param name: the optional name of the filter, otherwise the
 #unction name will be used.
 #""
 #elf.jinja_env.filters[name or f.__name__] = f

 #setupmethod
 #ef template_test(
 #elf, name: t.Optional[str] = None
 # -> t.Callable[[TemplateTestCallable], TemplateTestCallable]:
 #""A decorator that is used to register custom template test.
 #ou can specify a name for the test, otherwise the function
 #ame will be used. Example::

 #app.template_test()
 #ef is_prime(n):
 #f n == 2:
 #eturn True
 #or i in range(2, int(math.ceil(math.sqrt(n))) + 1):
 #f n % i == 0:
 #eturn False
 #eturn True

 #. versionadded:: 0.10

 #param name: the optional name of the test, otherwise the
 #unction name will be used.
 #""

 #ef decorator(f: TemplateTestCallable) -> TemplateTestCallable:
 #elf.add_template_test(f, name=name)
 #eturn f

 #eturn decorator

 #setupmethod
 #ef add_template_test(
 #elf, f: TemplateTestCallable, name: t.Optional[str] = None
 # -> None:
 #""Register a custom template test.  Works exactly like the
 #meth:`template_test` decorator.

 #. versionadded:: 0.10

 #param name: the optional name of the test, otherwise the
 #unction name will be used.
 #""
 #elf.jinja_env.tests[name or f.__name__] = f

 #setupmethod
 #ef template_global(
 #elf, name: t.Optional[str] = None
 # -> t.Callable[[TemplateGlobalCallable], TemplateGlobalCallable]:
 #""A decorator that is used to register a custom template global function.
 #ou can specify a name for the global function, otherwise the function
 #ame will be used. Example::

 #app.template_global()
 #ef double(n):
 #eturn 2 * n

 #. versionadded:: 0.10

 #param name: the optional name of the global function, otherwise the
 #unction name will be used.
 #""

 #ef decorator(f: TemplateGlobalCallable) -> TemplateGlobalCallable:
 #elf.add_template_global(f, name=name)
 #eturn f

 #eturn decorator

 #setupmethod
 #ef add_template_global(
 #elf, f: TemplateGlobalCallable, name: t.Optional[str] = None
 # -> None:
 #""Register a custom template global function. Works exactly like the
 #meth:`template_global` decorator.

 #. versionadded:: 0.10

 #param name: the optional name of the global function, otherwise the
 #unction name will be used.
 #""
 #elf.jinja_env.globals[name or f.__name__] = f

 #setupmethod
 #ef before_first_request(self, f: BeforeRequestCallable) -> BeforeRequestCallable:
 #""Registers a function to be run before the first request to this
 #nstance of the application.

 #he function will be called without any arguments and its return
 #alue is ignored.

 #. versionadded:: 0.8
 #""
 #elf.before_first_request_funcs.append(f)
 #eturn f

 #setupmethod
 #ef teardown_appcontext(self, f: TeardownCallable) -> TeardownCallable:
 #""Registers a function to be called when the application context
 #nds.  These functions are typically also called when the request
 #ontext is popped.

 #xample::

 #tx = app.app_context()
 #tx.push()
 #..
 #tx.pop()

 #hen ``ctx.pop()`` is executed in the above example, the teardown
 #unctions are called just before the app context moves from the
 #tack of active contexts.  This becomes relevant if you are using
 #uch constructs in tests.

 #ince a request context typically also manages an application
 #ontext it would also be called when you pop a request context.

 #hen a teardown function was called because of an unhandled exception
 #t will be passed an error object. If an :meth:`errorhandler` is
 #egistered, it will handle the exception and the teardown will not
 #eceive it.

 #he return values of teardown functions are ignored.

 #. versionadded:: 0.9
 #""
 #elf.teardown_appcontext_funcs.append(f)
 #eturn f

 #setupmethod
 #ef shell_context_processor(self, f: t.Callable) -> t.Callable:
 #""Registers a shell context processor function.

 #. versionadded:: 0.11
 #""
 #elf.shell_context_processors.append(f)
 #eturn f

 #ef _find_error_handler(self, e: Exception) -> t.Optional[ErrorHandlerCallable]:
 #""Return a registered error handler for an exception in this order:
 #lueprint handler for a specific code, app handler for a specific code,
 #lueprint handler for an exception class, app handler for an exception
 #lass, or ``None`` if a suitable handler is not found.
 #""
 #xc_class, code = self._get_exc_class_and_code(type(e))

 #or c in [code, None]:
 #or name in chain(request.blueprints, [None]):
 #andler_map = self.error_handler_spec[name][c]

 #f not handler_map:
 #ontinue

 #or cls in exc_class.__mro__:
 #andler = handler_map.get(cls)

 #f handler is not None:
 #eturn handler
 #eturn None

 #ef handle_http_exception(
 #elf, e: HTTPException
 # -> t.Union[HTTPException, ResponseReturnValue]:
 #""Handles an HTTP exception.  By default this will invoke the
 #egistered error handlers and fall back to returning the
 #xception as response.

 #. versionchanged:: 1.0.3
 #`RoutingException``, used internally for actions such as
 #lash redirects during routing, is not passed to error
 #andlers.

 #. versionchanged:: 1.0
 #xceptions are looked up by code *and* by MRO, so
 #`HTTPExcpetion`` subclasses can be handled with a catch-all
 #andler for the base ``HTTPException``.

 #. versionadded:: 0.3
 #""
        # Proxy exceptions don't have error codes.  We want to always return
        # those unchanged as errors
 #f e.code is None:
 #eturn e

        # RoutingExceptions are used internally to trigger routing
        # actions, such as slash redirects raising RequestRedirect. They
        # are not raised or handled in user code.
 #f isinstance(e, RoutingException):
 #eturn e

 #andler = self._find_error_handler(e)
 #f handler is None:
 #eturn e
 #eturn self.ensure_sync(handler)(e)

 #ef trap_http_exception(self, e: Exception) -> bool:
 #""Checks if an HTTP exception should be trapped or not.  By default
 #his will return ``False`` for all exceptions except for a bad request
 #ey error if ``TRAP_BAD_REQUEST_ERRORS`` is set to ``True``.  It
 #lso returns ``True`` if ``TRAP_HTTP_EXCEPTIONS`` is set to ``True``.

 #his is called for all HTTP exceptions raised by a view function.
 #f it returns ``True`` for any exception the error handler for this
 #xception is not called and it shows up as regular exception in the
 #raceback.  This is helpful for debugging implicitly raised HTTP
 #xceptions.

 #. versionchanged:: 1.0
 #ad request errors are not trapped by default in debug mode.

 #. versionadded:: 0.8
 #""
 #f self.config["TRAP_HTTP_EXCEPTIONS"]:
 #eturn True

 #rap_bad_request = self.config["TRAP_BAD_REQUEST_ERRORS"]

        # if unset, trap key errors in debug mode
 #f (
 #rap_bad_request is None
 #nd self.debug
 #nd isinstance(e, BadRequestKeyError)
 #:
 #eturn True

 #f trap_bad_request:
 #eturn isinstance(e, BadRequest)

 #eturn False

 #ef handle_user_exception(
 #elf, e: Exception
 # -> t.Union[HTTPException, ResponseReturnValue]:
 #""This method is called whenever an exception occurs that
 #hould be handled. A special case is :class:`~werkzeug
 #exceptions.HTTPException` which is forwarded to the
 #meth:`handle_http_exception` method. This function will either
 #eturn a response value or reraise the exception with the same
 #raceback.

 #. versionchanged:: 1.0
 #ey errors raised from request data like ``form`` show the
 #ad key in debug mode rather than a generic bad request
 #essage.

 #. versionadded:: 0.7
 #""
 #f isinstance(e, BadRequestKeyError) and (
 #elf.debug or self.config["TRAP_BAD_REQUEST_ERRORS"]
 #:
 #.show_exception = True

 #f isinstance(e, HTTPException) and not self.trap_http_exception(e):
 #eturn self.handle_http_exception(e)

 #andler = self._find_error_handler(e)

 #f handler is None:
 #aise

 #eturn self.ensure_sync(handler)(e)

 #ef handle_exception(self, e: Exception) -> Response:
 #""Handle an exception that did not have an error handler
 #ssociated with it, or that was raised from an error handler.
 #his always causes a 500 ``InternalServerError``.

 #lways sends the :data:`got_request_exception` signal.

 #f :attr:`propagate_exceptions` is ``True``, such as in debug
 #ode, the error will be re-raised so that the debugger can
 #isplay it. Otherwise, the original exception is logged, and
 #n :exc:`~werkzeug.exceptions.InternalServerError` is returned.

 #f an error handler is registered for ``InternalServerError`` or
 #`500``, it will be used. For consistency, the handler will
 #lways receive the ``InternalServerError``. The original
 #nhandled exception is available as ``e.original_exception``.

 #. versionchanged:: 1.1.0
 #lways passes the ``InternalServerError`` instance to the
 #andler, setting ``original_exception`` to the unhandled
 #rror.

 #. versionchanged:: 1.1.0
 #`after_request`` functions and other finalization is done
 #ven for the default 500 response when there is no handler.

 #. versionadded:: 0.3
 #""
 #xc_info = sys.exc_info()
 #ot_request_exception.send(self, exception=e)

 #f self.propagate_exceptions:
            # Re-raise if called with an active exception, otherwise
            # raise the passed in exception.
 #f exc_info[1] is e:
 #aise

 #aise e

 #elf.log_exception(exc_info)
 #erver_error: t.Union[InternalServerError, ResponseReturnValue]
 #erver_error = InternalServerError(original_exception=e)
 #andler = self._find_error_handler(server_error)

 #f handler is not None:
 #erver_error = self.ensure_sync(handler)(server_error)

 #eturn self.finalize_request(server_error, from_error_handler=True)

 #ef log_exception(
 #elf,
 #xc_info: t.Union[
 #.Tuple[type, BaseException, TracebackType], t.Tuple[None, None, None]
 #,
 # -> None:
 #""Logs an exception.  This is called by :meth:`handle_exception`
 #f debugging is disabled and right before the handler is called.
 #he default implementation logs the exception as error on the
 #attr:`logger`.

 #. versionadded:: 0.8
 #""
 #elf.logger.error(
 #"Exception on {request.path} [{request.method}]", exc_info=exc_info
 #

 #ef raise_routing_exception(self, request: Request) -> "te.NoReturn":
 #""Exceptions that are recording during routing are reraised with
 #his method.  During debug we are not reraising redirect requests
 #or non ``GET``, ``HEAD``, or ``OPTIONS`` requests and we're raising
 # different error instead to help debug situations.

 #internal:
 #""
 #f (
 #ot self.debug
 #r not isinstance(request.routing_exception, RequestRedirect)
 #r request.method in ("GET", "HEAD", "OPTIONS")
 #:
 #aise request.routing_exception  # type: ignore

 #rom .debughelpers import FormDataRoutingRedirect

 #aise FormDataRoutingRedirect(request)

 #ef dispatch_request(self) -> ResponseReturnValue:
 #""Does the request dispatching.  Matches the URL and returns the
 #eturn value of the view or error handler.  This does not have to
 #e a response object.  In order to convert the return value to a
 #roper response object, call :func:`make_response`.

 #. versionchanged:: 0.7
 #his no longer does the exception handling, this code was
 #oved to the new :meth:`full_dispatch_request`.
 #""
 #eq = _request_ctx_stack.top.request
 #f req.routing_exception is not None:
 #elf.raise_routing_exception(req)
 #ule = req.url_rule
        # if we provide automatic options for this URL and the
        # request came with the OPTIONS method, reply automatically
 #f (
 #etattr(rule, "provide_automatic_options", False)
 #nd req.method == "OPTIONS"
 #:
 #eturn self.make_default_options_response()
        # otherwise dispatch to the handler for that endpoint
 #eturn self.ensure_sync(self.view_functions[rule.endpoint])(**req.view_args)

 #ef full_dispatch_request(self) -> Response:
 #""Dispatches the request and on top of that performs request
 #re and postprocessing as well as HTTP exception catching and
 #rror handling.

 #. versionadded:: 0.7
 #""
 #elf.try_trigger_before_first_request_functions()
 #ry:
 #equest_started.send(self)
 #v = self.preprocess_request()
 #f rv is None:
 #v = self.dispatch_request()
 #xcept Exception as e:
 #v = self.handle_user_exception(e)
 #eturn self.finalize_request(rv)

 #ef finalize_request(
 #elf,
 #v: t.Union[ResponseReturnValue, HTTPException],
 #rom_error_handler: bool = False,
 # -> Response:
 #""Given the return value from a view function this finalizes
 #he request by converting it into a response and invoking the
 #ostprocessing functions.  This is invoked for both normal
 #equest dispatching as well as error handlers.

 #ecause this means that it might be called as a result of a
 #ailure a special safe mode is available which can be enabled
 #ith the `from_error_handler` flag.  If enabled, failures in
 #esponse processing will be logged and otherwise ignored.

 #internal:
 #""
 #esponse = self.make_response(rv)
 #ry:
 #esponse = self.process_response(response)
 #equest_finished.send(self, response=response)
 #xcept Exception:
 #f not from_error_handler:
 #aise
 #elf.logger.exception(
 #Request finalizing failed with an error while handling an error"
 #
 #eturn response

 #ef try_trigger_before_first_request_functions(self) -> None:
 #""Called before each request and will ensure that it triggers
 #he :attr:`before_first_request_funcs` and only exactly once per
 #pplication instance (which means process usually).

 #internal:
 #""
 #f self._got_first_request:
 #eturn
 #ith self._before_request_lock:
 #f self._got_first_request:
 #eturn
 #or func in self.before_first_request_funcs:
 #elf.ensure_sync(func)()
 #elf._got_first_request = True

 #ef make_default_options_response(self) -> Response:
 #""This method is called to create the default ``OPTIONS`` response.
 #his can be changed through subclassing to change the default
 #ehavior of ``OPTIONS`` responses.

 #. versionadded:: 0.7
 #""
 #dapter = _request_ctx_stack.top.url_adapter
 #ethods = adapter.allowed_methods()
 #v = self.response_class()
 #v.allow.update(methods)
 #eturn rv

 #ef should_ignore_error(self, error: t.Optional[BaseException]) -> bool:
 #""This is called to figure out if an error should be ignored
 #r not as far as the teardown system is concerned.  If this
 #unction returns ``True`` then the teardown handlers will not be
 #assed the error.

 #. versionadded:: 0.10
 #""
 #eturn False

 #ef ensure_sync(self, func: t.Callable) -> t.Callable:
 #""Ensure that the function is synchronous for WSGI workers.
 #lain ``def`` functions are returned as-is. ``async def``
 #unctions are wrapped to run and wait for the response.

 #verride this method to change how the app runs async views.

 #. versionadded:: 2.0
 #""
 #f iscoroutinefunction(func):
 #eturn self.async_to_sync(func)

 #eturn func

 #ef async_to_sync(
 #elf, func: t.Callable[..., t.Coroutine]
 # -> t.Callable[..., t.Any]:
 #""Return a sync function that will run the coroutine function.

 #. code-block:: python

 #esult = app.async_to_sync(func)(*args, **kwargs)

 #verride this method to change how the app converts async code
 #o be synchronously callable.

 #. versionadded:: 2.0
 #""
 #ry:
 #rom asgiref.sync import async_to_sync as asgiref_async_to_sync
 #xcept ImportError:
 #aise RuntimeError(
 #Install Flask with the 'async' extra in order to use async views."
 #

        # Check that Werkzeug isn't using its fallback ContextVar class.
 #f ContextVar.__module__ == "werkzeug.local":
 #aise RuntimeError(
 #Async cannot be used with this combination of Python "
 #and Greenlet versions."
 #

 #eturn asgiref_async_to_sync(func)

 #ef make_response(self, rv: ResponseReturnValue) -> Response:
 #""Convert the return value from a view function to an instance of
 #attr:`response_class`.

 #param rv: the return value from the view function. The view function
 #ust return a response. Returning ``None``, or the view ending
 #ithout returning, is not allowed. The following types are allowed
 #or ``view_rv``:

 #`str``
 # response object is created with the string encoded to UTF-8
 #s the body.

 #`bytes``
 # response object is created with the bytes as the body.

 #`dict``
 # dictionary that will be jsonify'd before being returned.

 #`tuple``
 #ither ``(body, status, headers)``, ``(body, status)``, or
 #`(body, headers)``, where ``body`` is any of the other types
 #llowed here, ``status`` is a string or an integer, and
 #`headers`` is a dictionary or a list of ``(key, value)``
 #uples. If ``body`` is a :attr:`response_class` instance,
 #`status`` overwrites the exiting value and ``headers`` are
 #xtended.

 #attr:`response_class`
 #he object is returned unchanged.

 #ther :class:`~werkzeug.wrappers.Response` class
 #he object is coerced to :attr:`response_class`.

 #func:`callable`
 #he function is called as a WSGI application. The result is
 #sed to create a response object.

 #. versionchanged:: 0.9
 #reviously a tuple was interpreted as the arguments for the
 #esponse object.
 #""

 #tatus = headers = None

        # unpack tuple returns
 #f isinstance(rv, tuple):
 #en_rv = len(rv)

            # a 3-tuple is unpacked directly
 #f len_rv == 3:
 #v, status, headers = rv
            # decide if a 2-tuple has status or headers
 #lif len_rv == 2:
 #f isinstance(rv[1], (Headers, dict, tuple, list)):
 #v, headers = rv
 #lse:
 #v, status = rv
            # other sized tuples are not allowed
 #lse:
 #aise TypeError(
 #The view function did not return a valid response tuple."
 # The tuple must have the form (body, status, headers),"
 # (body, status), or (body, headers)."
 #

        # the body must not be None
 #f rv is None:
 #aise TypeError(
 #"The view function for {request.endpoint!r} did not"
 # return a valid response. The function either returned"
 # None or ended without a return statement."
 #

        # make sure the body is an instance of the response class
 #f not isinstance(rv, self.response_class):
 #f isinstance(rv, (str, bytes, bytearray)):
                # let the response class set the status and headers instead of
                # waiting to do it manually, so that the class can handle any
                # special logic
 #v = self.response_class(rv, status=status, headers=headers)
 #tatus = headers = None
 #lif isinstance(rv, dict):
 #v = jsonify(rv)
 #lif isinstance(rv, BaseResponse) or callable(rv):
                # evaluate a WSGI callable, or coerce a different response
                # class to the correct type
 #ry:
 #v = self.response_class.force_type(rv, request.environ)  # type: ignore  # noqa: B950
 #xcept TypeError as e:
 #aise TypeError(
 #"{e}\nThe view function did not return a valid"
 # response. The return type must be a string,"
 # dict, tuple, Response instance, or WSGI"
 #" callable, but it was a {type(rv).__name__}."
 #.with_traceback(sys.exc_info()[2])
 #lse:
 #aise TypeError(
 #The view function did not return a valid"
 # response. The return type must be a string,"
 # dict, tuple, Response instance, or WSGI"
 #" callable, but it was a {type(rv).__name__}."
 #

 #v = t.cast(Response, rv)
        # prefer the status if it was provided
 #f status is not None:
 #f isinstance(status, (str, bytes, bytearray)):
 #v.status = status  # type: ignore
 #lse:
 #v.status_code = status

        # extend existing headers with provided headers
 #f headers:
 #v.headers.update(headers)

 #eturn rv

 #ef create_url_adapter(
 #elf, request: t.Optional[Request]
 # -> t.Optional[MapAdapter]:
 #""Creates a URL adapter for the given request. The URL adapter
 #s created at a point where the request context is not yet set
 #p so the request is passed explicitly.

 #. versionadded:: 0.6

 #. versionchanged:: 0.9
 #his can now also be called without a request object when the
 #RL adapter is created for the application context.

 #. versionchanged:: 1.0
 #data:`SERVER_NAME` no longer implicitly enables subdomain
 #atching. Use :attr:`subdomain_matching` instead.
 #""
 #f request is not None:
            # If subdomain matching is disabled (the default), use the
            # default subdomain in all cases. This should be the default
            # in Werkzeug but it currently does not have that feature.
 #f not self.subdomain_matching:
 #ubdomain = self.url_map.default_subdomain or None
 #lse:
 #ubdomain = None

 #eturn self.url_map.bind_to_environ(
 #equest.environ,
 #erver_name=self.config["SERVER_NAME"],
 #ubdomain=subdomain,
 #
        # We need at the very least the server name to be set for this
        # to work.
 #f self.config["SERVER_NAME"] is not None:
 #eturn self.url_map.bind(
 #elf.config["SERVER_NAME"],
 #cript_name=self.config["APPLICATION_ROOT"],
 #rl_scheme=self.config["PREFERRED_URL_SCHEME"],
 #

 #eturn None

 #ef inject_url_defaults(self, endpoint: str, values: dict) -> None:
 #""Injects the URL defaults for the given endpoint directly into
 #he values dictionary passed.  This is used internally and
 #utomatically called on URL building.

 #. versionadded:: 0.7
 #""
 #uncs: t.Iterable[URLDefaultCallable] = self.url_default_functions[None]

 #f "." in endpoint:
            # This is called by url_for, which can be called outside a
            # request, can't use request.blueprints.
 #ps = _split_blueprint_path(endpoint.rpartition(".")[0])
 #p_funcs = chain.from_iterable(self.url_default_functions[bp] for bp in bps)
 #uncs = chain(funcs, bp_funcs)

 #or func in funcs:
 #unc(endpoint, values)

 #ef handle_url_build_error(
 #elf, error: Exception, endpoint: str, values: dict
 # -> str:
 #""Handle :class:`~werkzeug.routing.BuildError` on
 #meth:`url_for`.
 #""
 #or handler in self.url_build_error_handlers:
 #ry:
 #v = handler(error, endpoint, values)
 #xcept BuildError as e:
                # make error available outside except block
 #rror = e
 #lse:
 #f rv is not None:
 #eturn rv

        # Re-raise if called with an active exception, otherwise raise
        # the passed in exception.
 #f error is sys.exc_info()[1]:
 #aise

 #aise error

 #ef preprocess_request(self) -> t.Optional[ResponseReturnValue]:
 #""Called before the request is dispatched. Calls
 #attr:`url_value_preprocessors` registered with the app and the
 #urrent blueprint (if any). Then calls :attr:`before_request_funcs`
 #egistered with the app and the blueprint.

 #f any :meth:`before_request` handler returns a non-None value, the
 #alue is handled as if it was the return value from the view, and
 #urther request handling is stopped.
 #""

 #uncs: t.Iterable[URLValuePreprocessorCallable] = self.url_value_preprocessors[
 #one
 #
 #or bp in request.blueprints:
 #f bp in self.url_value_preprocessors:
 #uncs = chain(funcs, self.url_value_preprocessors[bp])
 #or func in funcs:
 #unc(request.endpoint, request.view_args)

 #uncs: t.Iterable[BeforeRequestCallable] = self.before_request_funcs[None]
 #or bp in request.blueprints:
 #f bp in self.before_request_funcs:
 #uncs = chain(funcs, self.before_request_funcs[bp])
 #or func in funcs:
 #v = self.ensure_sync(func)()
 #f rv is not None:
 #eturn rv

 #eturn None

 #ef process_response(self, response: Response) -> Response:
 #""Can be overridden in order to modify the response object
 #efore it's sent to the WSGI server.  By default this will
 #all all the :meth:`after_request` decorated functions.

 #. versionchanged:: 0.5
 #s of Flask 0.5 the functions registered for after request
 #xecution are called in reverse order of registration.

 #param response: a :attr:`response_class` object.
 #return: a new response object or the same, has to be an
 #nstance of :attr:`response_class`.
 #""
 #tx = _request_ctx_stack.top
 #uncs: t.Iterable[AfterRequestCallable] = ctx._after_request_functions
 #or bp in request.blueprints:
 #f bp in self.after_request_funcs:
 #uncs = chain(funcs, reversed(self.after_request_funcs[bp]))
 #f None in self.after_request_funcs:
 #uncs = chain(funcs, reversed(self.after_request_funcs[None]))
 #or handler in funcs:
 #esponse = self.ensure_sync(handler)(response)
 #f not self.session_interface.is_null_session(ctx.session):
 #elf.session_interface.save_session(self, ctx.session, response)
 #eturn response

 #ef do_teardown_request(
 #elf, exc: t.Optional[BaseException] = _sentinel  # type: ignore
 # -> None:
 #""Called after the request is dispatched and the response is
 #eturned, right before the request context is popped.

 #his calls all functions decorated with
 #meth:`teardown_request`, and :meth:`Blueprint.teardown_request`
 #f a blueprint handled the request. Finally, the
 #data:`request_tearing_down` signal is sent.

 #his is called by
 #meth:`RequestContext.pop() <flask.ctx.RequestContext.pop>`,
 #hich may be delayed during testing to maintain access to
 #esources.

 #param exc: An unhandled exception raised while dispatching the
 #equest. Detected from the current exception information if
 #ot passed. Passed to each teardown function.

 #. versionchanged:: 0.9
 #dded the ``exc`` argument.
 #""
 #f exc is _sentinel:
 #xc = sys.exc_info()[1]
 #uncs: t.Iterable[TeardownCallable] = reversed(
 #elf.teardown_request_funcs[None]
 #
 #or bp in request.blueprints:
 #f bp in self.teardown_request_funcs:
 #uncs = chain(funcs, reversed(self.teardown_request_funcs[bp]))
 #or func in funcs:
 #elf.ensure_sync(func)(exc)
 #equest_tearing_down.send(self, exc=exc)

 #ef do_teardown_appcontext(
 #elf, exc: t.Optional[BaseException] = _sentinel  # type: ignore
 # -> None:
 #""Called right before the application context is popped.

 #hen handling a request, the application context is popped
 #fter the request context. See :meth:`do_teardown_request`.

 #his calls all functions decorated with
 #meth:`teardown_appcontext`. Then the
 #data:`appcontext_tearing_down` signal is sent.

 #his is called by
 #meth:`AppContext.pop() <flask.ctx.AppContext.pop>`.

 #. versionadded:: 0.9
 #""
 #f exc is _sentinel:
 #xc = sys.exc_info()[1]
 #or func in reversed(self.teardown_appcontext_funcs):
 #elf.ensure_sync(func)(exc)
 #ppcontext_tearing_down.send(self, exc=exc)

 #ef app_context(self) -> AppContext:
 #""Create an :class:`~flask.ctx.AppContext`. Use as a ``with``
 #lock to push the context, which will make :data:`current_app`
 #oint at this application.

 #n application context is automatically pushed by
 #meth:`RequestContext.push() <flask.ctx.RequestContext.push>`
 #hen handling a request, and when running a CLI command. Use
 #his to manually create a context outside of these situations.

 #:

 #ith app.app_context():
 #nit_db()

 #ee :doc:`/appcontext`.

 #. versionadded:: 0.9
 #""
 #eturn AppContext(self)

 #ef request_context(self, environ: dict) -> RequestContext:
 #""Create a :class:`~flask.ctx.RequestContext` representing a
 #SGI environment. Use a ``with`` block to push the context,
 #hich will make :data:`request` point at this request.

 #ee :doc:`/reqcontext`.

 #ypically you should not call this from your own code. A request
 #ontext is automatically pushed by the :meth:`wsgi_app` when
 #andling a request. Use :meth:`test_request_context` to create
 #n environment and context instead of this method.

 #param environ: a WSGI environment
 #""
 #eturn RequestContext(self, environ)

 #ef test_request_context(self, *args: t.Any, **kwargs: t.Any) -> RequestContext:
 #""Create a :class:`~flask.ctx.RequestContext` for a WSGI
 #nvironment created from the given values. This is mostly useful
 #uring testing, where you may want to run a function that uses
 #equest data without dispatching a full request.

 #ee :doc:`/reqcontext`.

 #se a ``with`` block to push the context, which will make
 #data:`request` point at the request for the created
 #nvironment. ::

 #ith test_request_context(...):
 #enerate_report()

 #hen using the shell, it may be easier to push and pop the
 #ontext manually to avoid indentation. ::

 #tx = app.test_request_context(...)
 #tx.push()
 #..
 #tx.pop()

 #akes the same arguments as Werkzeug's
 #class:`~werkzeug.test.EnvironBuilder`, with some defaults from
 #he application. See the linked Werkzeug docs for most of the
 #vailable arguments. Flask-specific behavior is listed here.

 #param path: URL path being requested.
 #param base_url: Base URL where the app is being served, which
 #`path`` is relative to. If not given, built from
 #data:`PREFERRED_URL_SCHEME`, ``subdomain``,
 #data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
 #param subdomain: Subdomain name to append to
 #data:`SERVER_NAME`.
 #param url_scheme: Scheme to use instead of
 #data:`PREFERRED_URL_SCHEME`.
 #param data: The request body, either as a string or a dict of
 #orm keys and values.
 #param json: If given, this is serialized as JSON and passed as
 #`data``. Also defaults ``content_type`` to
 #`application/json``.
 #param args: other positional arguments passed to
 #class:`~werkzeug.test.EnvironBuilder`.
 #param kwargs: other keyword arguments passed to
 #class:`~werkzeug.test.EnvironBuilder`.
 #""
 #rom .testing import EnvironBuilder

 #uilder = EnvironBuilder(self, *args, **kwargs)

 #ry:
 #eturn self.request_context(builder.get_environ())
 #inally:
 #uilder.close()

 #ef wsgi_app(self, environ: dict, start_response: t.Callable) -> t.Any:
 #""The actual WSGI application. This is not implemented in
 #meth:`__call__` so that middlewares can be applied without
 #osing a reference to the app object. Instead of doing this::

 #pp = MyMiddleware(app)

 #t's a better idea to do this instead::

 #pp.wsgi_app = MyMiddleware(app.wsgi_app)

 #hen you still have the original application object around and
 #an continue to call methods on it.

 #. versionchanged:: 0.7
 #eardown events for the request and app contexts are called
 #ven if an unhandled error occurs. Other events may not be
 #alled depending on when an error occurs during dispatch.
 #ee :ref:`callbacks-and-errors`.

 #param environ: A WSGI environment.
 #param start_response: A callable accepting a status code,
 # list of headers, and an optional exception context to
 #tart the response.
 #""
 #tx = self.request_context(environ)
 #rror: t.Optional[BaseException] = None
 #ry:
 #ry:
 #tx.push()
 #esponse = self.full_dispatch_request()
 #xcept Exception as e:
 #rror = e
 #esponse = self.handle_exception(e)
 #xcept:  # noqa: B001
 #rror = sys.exc_info()[1]
 #aise
 #eturn response(environ, start_response)
 #inally:
 #f self.should_ignore_error(error):
 #rror = None
 #tx.auto_pop(error)

 #ef __call__(self, environ: dict, start_response: t.Callable) -> t.Any:
 #""The WSGI server calls the Flask application object as the
 #SGI application. This calls :meth:`wsgi_app`, which can be
 #rapped to apply middleware.
 #""
 #eturn self.wsgi_app(environ, start_response)
