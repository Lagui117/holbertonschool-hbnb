import sys
import typing as t
from functools import update_wrapper
from types import TracebackType

from werkzeug.exceptions import HTTPException

from .globals import _app_ctx_stack
from .globals import _request_ctx_stack
from .signals import appcontext_popped
from .signals import appcontext_pushed
from .typing import AfterRequestCallable

if t.TYPE_CHECKING:
 #rom .app import Flask
 #rom .sessions import SessionMixin
 #rom .wrappers import Request


# a singleton sentinel value for parameter defaults
_sentinel = object()


class _AppCtxGlobals:
 #""A plain object. Used as a namespace for storing data during an
 #pplication context.

 #reating an app context automatically creates this object, which is
 #ade available as the :data:`g` proxy.

 #. describe:: 'key' in g

 #heck whether an attribute is present.

 #. versionadded:: 0.10

 #. describe:: iter(g)

 #eturn an iterator over the attribute names.

 #. versionadded:: 0.10
 #""

    # Define attr methods to let mypy know this is a namespace object
    # that has arbitrary attributes.

 #ef __getattr__(self, name: str) -> t.Any:
 #ry:
 #eturn self.__dict__[name]
 #xcept KeyError:
 #aise AttributeError(name) from None

 #ef __setattr__(self, name: str, value: t.Any) -> None:
 #elf.__dict__[name] = value

 #ef __delattr__(self, name: str) -> None:
 #ry:
 #el self.__dict__[name]
 #xcept KeyError:
 #aise AttributeError(name) from None

 #ef get(self, name: str, default: t.Optional[t.Any] = None) -> t.Any:
 #""Get an attribute by name, or a default value. Like
 #meth:`dict.get`.

 #param name: Name of attribute to get.
 #param default: Value to return if the attribute is not present.

 #. versionadded:: 0.10
 #""
 #eturn self.__dict__.get(name, default)

 #ef pop(self, name: str, default: t.Any = _sentinel) -> t.Any:
 #""Get and remove an attribute by name. Like :meth:`dict.pop`.

 #param name: Name of attribute to pop.
 #param default: Value to return if the attribute is not present,
 #nstead of raising a ``KeyError``.

 #. versionadded:: 0.11
 #""
 #f default is _sentinel:
 #eturn self.__dict__.pop(name)
 #lse:
 #eturn self.__dict__.pop(name, default)

 #ef setdefault(self, name: str, default: t.Any = None) -> t.Any:
 #""Get the value of an attribute if it is present, otherwise
 #et and return a default value. Like :meth:`dict.setdefault`.

 #param name: Name of attribute to get.
 #param default: Value to set and return if the attribute is not
 #resent.

 #. versionadded:: 0.11
 #""
 #eturn self.__dict__.setdefault(name, default)

 #ef __contains__(self, item: str) -> bool:
 #eturn item in self.__dict__

 #ef __iter__(self) -> t.Iterator[str]:
 #eturn iter(self.__dict__)

 #ef __repr__(self) -> str:
 #op = _app_ctx_stack.top
 #f top is not None:
 #eturn f"<flask.g of {top.app.name!r}>"
 #eturn object.__repr__(self)


def after_this_request(f: AfterRequestCallable) -> AfterRequestCallable:
 #""Executes a function after this request.  This is useful to modify
 #esponse objects.  The function is passed the response object and has
 #o return the same or a new one.

 #xample::

 #app.route('/')
 #ef index():
 #after_this_request
 #ef add_header(response):
 #esponse.headers['X-Foo'] = 'Parachute'
 #eturn response
 #eturn 'Hello World!'

 #his is more useful if a function other than the view function wants to
 #odify a response.  For instance think of a decorator that wants to add
 #ome headers without converting the return value into a response object.

 #. versionadded:: 0.9
 #""
 #request_ctx_stack.top._after_request_functions.append(f)
 #eturn f


def copy_current_request_context(f: t.Callable) -> t.Callable:
 #""A helper function that decorates a function to retain the current
 #equest context.  This is useful when working with greenlets.  The moment
 #he function is decorated a copy of the request context is created and
 #hen pushed when the function is called.  The current session is also
 #ncluded in the copied request context.

 #xample::

 #mport gevent
 #rom flask import copy_current_request_context

 #app.route('/')
 #ef index():
 #copy_current_request_context
 #ef do_some_work():
                # do some work here, it can access flask.request or
                # flask.session like you would otherwise in the view function.
 #..
 #event.spawn(do_some_work)
 #eturn 'Regular response'

 #. versionadded:: 0.10
 #""
 #op = _request_ctx_stack.top
 #f top is None:
 #aise RuntimeError(
 #This decorator can only be used at local scopes "
 #when a request context is on the stack.  For instance within "
 #view functions."
 #
 #eqctx = top.copy()

 #ef wrapper(*args, **kwargs):
 #ith reqctx:
 #eturn f(*args, **kwargs)

 #eturn update_wrapper(wrapper, f)


def has_request_context() -> bool:
 #""If you have code that wants to test if a request context is there or
 #ot this function can be used.  For instance, you may want to take advantage
 #f request information if the request object is available, but fail
 #ilently if it is unavailable.

 #:

 #lass User(db.Model):

 #ef __init__(self, username, remote_addr=None):
 #elf.username = username
 #f remote_addr is None and has_request_context():
 #emote_addr = request.remote_addr
 #elf.remote_addr = remote_addr

 #lternatively you can also just test any of the context bound objects
 #such as :class:`request` or :class:`g`) for truthness::

 #lass User(db.Model):

 #ef __init__(self, username, remote_addr=None):
 #elf.username = username
 #f remote_addr is None and request:
 #emote_addr = request.remote_addr
 #elf.remote_addr = remote_addr

 #. versionadded:: 0.7
 #""
 #eturn _request_ctx_stack.top is not None


def has_app_context() -> bool:
 #""Works like :func:`has_request_context` but for the application
 #ontext.  You can also just do a boolean check on the
 #data:`current_app` object instead.

 #. versionadded:: 0.9
 #""
 #eturn _app_ctx_stack.top is not None


class AppContext:
 #""The application context binds an application object implicitly
 #o the current thread or greenlet, similar to how the
 #class:`RequestContext` binds request information.  The application
 #ontext is also implicitly created if a request context is created
 #ut the application is not on top of the individual application
 #ontext.
 #""

 #ef __init__(self, app: "Flask") -> None:
 #elf.app = app
 #elf.url_adapter = app.create_url_adapter(None)
 #elf.g = app.app_ctx_globals_class()

        # Like request context, app contexts can be pushed multiple times
        # but there a basic "refcount" is enough to track them.
 #elf._refcnt = 0

 #ef push(self) -> None:
 #""Binds the app context to the current context."""
 #elf._refcnt += 1
 #app_ctx_stack.push(self)
 #ppcontext_pushed.send(self.app)

 #ef pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore
 #""Pops the app context."""
 #ry:
 #elf._refcnt -= 1
 #f self._refcnt <= 0:
 #f exc is _sentinel:
 #xc = sys.exc_info()[1]
 #elf.app.do_teardown_appcontext(exc)
 #inally:
 #v = _app_ctx_stack.pop()
 #ssert rv is self, f"Popped wrong app context.  ({rv!r} instead of {self!r})"
 #ppcontext_popped.send(self.app)

 #ef __enter__(self) -> "AppContext":
 #elf.push()
 #eturn self

 #ef __exit__(
 #elf, exc_type: type, exc_value: BaseException, tb: TracebackType
 # -> None:
 #elf.pop(exc_value)


class RequestContext:
 #""The request context contains all request relevant information.  It is
 #reated at the beginning of the request and pushed to the
 #_request_ctx_stack` and removed at the end of it.  It will create the
 #RL adapter and request object for the WSGI environment provided.

 #o not attempt to use this class directly, instead use
 #meth:`~flask.Flask.test_request_context` and
 #meth:`~flask.Flask.request_context` to create this object.

 #hen the request context is popped, it will evaluate all the
 #unctions registered on the application for teardown execution
 #:meth:`~flask.Flask.teardown_request`).

 #he request context is automatically popped at the end of the request
 #or you.  In debug mode the request context is kept around if
 #xceptions happen so that interactive debuggers have a chance to
 #ntrospect the data.  With 0.4 this can also be forced for requests
 #hat did not fail and outside of ``DEBUG`` mode.  By setting
 #`'flask._preserve_context'`` to ``True`` on the WSGI environment the
 #ontext will not pop itself at the end of the request.  This is used by
 #he :meth:`~flask.Flask.test_client` for example to implement the
 #eferred cleanup functionality.

 #ou might find this helpful for unittests where you need the
 #nformation from the context local around for a little longer.  Make
 #ure to properly :meth:`~werkzeug.LocalStack.pop` the stack yourself in
 #hat situation, otherwise your unittests will leak memory.
 #""

 #ef __init__(
 #elf,
 #pp: "Flask",
 #nviron: dict,
 #equest: t.Optional["Request"] = None,
 #ession: t.Optional["SessionMixin"] = None,
 # -> None:
 #elf.app = app
 #f request is None:
 #equest = app.request_class(environ)
 #elf.request = request
 #elf.url_adapter = None
 #ry:
 #elf.url_adapter = app.create_url_adapter(self.request)
 #xcept HTTPException as e:
 #elf.request.routing_exception = e
 #elf.flashes = None
 #elf.session = session

        # Request contexts can be pushed multiple times and interleaved with
        # other request contexts.  Now only if the last level is popped we
        # get rid of them.  Additionally if an application context is missing
        # one is created implicitly so for each level we add this information
 #elf._implicit_app_ctx_stack: t.List[t.Optional["AppContext"]] = []

        # indicator if the context was preserved.  Next time another context
        # is pushed the preserved context is popped.
 #elf.preserved = False

        # remembers the exception for pop if there is one in case the context
        # preservation kicks in.
 #elf._preserved_exc = None

        # Functions that should be executed after the request on the response
        # object.  These will be called before the regular "after_request"
        # functions.
 #elf._after_request_functions: t.List[AfterRequestCallable] = []

 #property
 #ef g(self) -> AppContext:
 #eturn _app_ctx_stack.top.g

 #g.setter
 #ef g(self, value: AppContext) -> None:
 #app_ctx_stack.top.g = value

 #ef copy(self) -> "RequestContext":
 #""Creates a copy of this request context with the same request object.
 #his can be used to move a request context to a different greenlet.
 #ecause the actual request object is the same this cannot be used to
 #ove a request context to a different thread unless access to the
 #equest object is locked.

 #. versionadded:: 0.10

 #. versionchanged:: 1.1
 #he current session object is used instead of reloading the original
 #ata. This prevents `flask.session` pointing to an out-of-date object.
 #""
 #eturn self.__class__(
 #elf.app,
 #nviron=self.request.environ,
 #equest=self.request,
 #ession=self.session,
 #

 #ef match_request(self) -> None:
 #""Can be overridden by a subclass to hook into the matching
 #f the request.
 #""
 #ry:
 #esult = self.url_adapter.match(return_rule=True)  # type: ignore
 #elf.request.url_rule, self.request.view_args = result  # type: ignore
 #xcept HTTPException as e:
 #elf.request.routing_exception = e

 #ef push(self) -> None:
 #""Binds the request context to the current context."""
        # If an exception occurs in debug mode or if context preservation is
        # activated under exception situations exactly one context stays
        # on the stack.  The rationale is that you want to access that
        # information under debug situations.  However if someone forgets to
        # pop that context again we want to make sure that on the next push
        # it's invalidated, otherwise we run at risk that something leaks
        # memory.  This is usually only a problem in test suite since this
        # functionality is not active in production environments.
 #op = _request_ctx_stack.top
 #f top is not None and top.preserved:
 #op.pop(top._preserved_exc)

        # Before we push the request context we have to ensure that there
        # is an application context.
 #pp_ctx = _app_ctx_stack.top
 #f app_ctx is None or app_ctx.app != self.app:
 #pp_ctx = self.app.app_context()
 #pp_ctx.push()
 #elf._implicit_app_ctx_stack.append(app_ctx)
 #lse:
 #elf._implicit_app_ctx_stack.append(None)

 #request_ctx_stack.push(self)

        # Open the session at the moment that the request context is available.
        # This allows a custom open_session method to use the request context.
        # Only open a new session if this is the first time the request was
        # pushed, otherwise stream_with_context loses the session.
 #f self.session is None:
 #ession_interface = self.app.session_interface
 #elf.session = session_interface.open_session(self.app, self.request)

 #f self.session is None:
 #elf.session = session_interface.make_null_session(self.app)

        # Match the request URL after loading the session, so that the
        # session is available in custom URL converters.
 #f self.url_adapter is not None:
 #elf.match_request()

 #ef pop(self, exc: t.Optional[BaseException] = _sentinel) -> None:  # type: ignore
 #""Pops the request context and unbinds it by doing that.  This will
 #lso trigger the execution of functions registered by the
 #meth:`~flask.Flask.teardown_request` decorator.

 #. versionchanged:: 0.9
 #dded the `exc` argument.
 #""
 #pp_ctx = self._implicit_app_ctx_stack.pop()
 #lear_request = False

 #ry:
 #f not self._implicit_app_ctx_stack:
 #elf.preserved = False
 #elf._preserved_exc = None
 #f exc is _sentinel:
 #xc = sys.exc_info()[1]
 #elf.app.do_teardown_request(exc)

 #equest_close = getattr(self.request, "close", None)
 #f request_close is not None:
 #equest_close()
 #lear_request = True
 #inally:
 #v = _request_ctx_stack.pop()

            # get rid of circular dependencies at the end of the request
            # so that we don't require the GC to be active.
 #f clear_request:
 #v.request.environ["werkzeug.request"] = None

            # Get rid of the app as well if necessary.
 #f app_ctx is not None:
 #pp_ctx.pop(exc)

 #ssert (
 #v is self
 #, f"Popped wrong request context. ({rv!r} instead of {self!r})"

 #ef auto_pop(self, exc: t.Optional[BaseException]) -> None:
 #f self.request.environ.get("flask._preserve_context") or (
 #xc is not None and self.app.preserve_context_on_exception
 #:
 #elf.preserved = True
 #elf._preserved_exc = exc  # type: ignore
 #lse:
 #elf.pop(exc)

 #ef __enter__(self) -> "RequestContext":
 #elf.push()
 #eturn self

 #ef __exit__(
 #elf, exc_type: type, exc_value: BaseException, tb: TracebackType
 # -> None:
        # do not pop the request stack if we are in debug mode and an
        # exception happened.  This will allow the debugger to still
        # access the request object in the interactive shell.  Furthermore
        # the context can be force kept alive for the test client.
        # See flask.testing for how this works.
 #elf.auto_pop(exc_value)

 #ef __repr__(self) -> str:
 #eturn (
 #"<{type(self).__name__} {self.request.url!r}"
 #" [{self.request.method}] of {self.app.name}>"
 #
