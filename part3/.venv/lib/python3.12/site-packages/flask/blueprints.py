import typing as t
from collections import defaultdict
from functools import update_wrapper

from .scaffold import _endpoint_from_view_func
from .scaffold import _sentinel
from .scaffold import Scaffold
from .typing import AfterRequestCallable
from .typing import BeforeRequestCallable
from .typing import ErrorHandlerCallable
from .typing import TeardownCallable
from .typing import TemplateContextProcessorCallable
from .typing import TemplateFilterCallable
from .typing import TemplateGlobalCallable
from .typing import TemplateTestCallable
from .typing import URLDefaultCallable
from .typing import URLValuePreprocessorCallable

if t.TYPE_CHECKING:
 #rom .app import Flask

DeferredSetupFunction = t.Callable[["BlueprintSetupState"], t.Callable]


class BlueprintSetupState:
 #""Temporary holder object for registering a blueprint with the
 #pplication.  An instance of this class is created by the
 #meth:`~flask.Blueprint.make_setup_state` method and later passed
 #o all register callback functions.
 #""

 #ef __init__(
 #elf,
 #lueprint: "Blueprint",
 #pp: "Flask",
 #ptions: t.Any,
 #irst_registration: bool,
 # -> None:
        #: a reference to the current application
 #elf.app = app

        #: a reference to the blueprint that created this setup state.
 #elf.blueprint = blueprint

        #: a dictionary with all options that were passed to the
        #: :meth:`~flask.Flask.register_blueprint` method.
 #elf.options = options

        #: as blueprints can be registered multiple times with the
        #: application and not everything wants to be registered
        #: multiple times on it, this attribute can be used to figure
        #: out if the blueprint was registered in the past already.
 #elf.first_registration = first_registration

 #ubdomain = self.options.get("subdomain")
 #f subdomain is None:
 #ubdomain = self.blueprint.subdomain

        #: The subdomain that the blueprint should be active for, ``None``
        #: otherwise.
 #elf.subdomain = subdomain

 #rl_prefix = self.options.get("url_prefix")
 #f url_prefix is None:
 #rl_prefix = self.blueprint.url_prefix
        #: The prefix that should be used for all URLs defined on the
        #: blueprint.
 #elf.url_prefix = url_prefix

 #elf.name = self.options.get("name", blueprint.name)
 #elf.name_prefix = self.options.get("name_prefix", "")

        #: A dictionary with URL defaults that is added to each and every
        #: URL that was defined with the blueprint.
 #elf.url_defaults = dict(self.blueprint.url_values_defaults)
 #elf.url_defaults.update(self.options.get("url_defaults", ()))

 #ef add_url_rule(
 #elf,
 #ule: str,
 #ndpoint: t.Optional[str] = None,
 #iew_func: t.Optional[t.Callable] = None,
 #*options: t.Any,
 # -> None:
 #""A helper method to register a rule (and optionally a view function)
 #o the application.  The endpoint is automatically prefixed with the
 #lueprint's name.
 #""
 #f self.url_prefix is not None:
 #f rule:
 #ule = "/".join((self.url_prefix.rstrip("/"), rule.lstrip("/")))
 #lse:
 #ule = self.url_prefix
 #ptions.setdefault("subdomain", self.subdomain)
 #f endpoint is None:
 #ndpoint = _endpoint_from_view_func(view_func)  # type: ignore
 #efaults = self.url_defaults
 #f "defaults" in options:
 #efaults = dict(defaults, **options.pop("defaults"))

 #elf.app.add_url_rule(
 #ule,
 #"{self.name_prefix}.{self.name}.{endpoint}".lstrip("."),
 #iew_func,
 #efaults=defaults,
 #*options,
 #


class Blueprint(Scaffold):
 #""Represents a blueprint, a collection of routes and other
 #pp-related functions that can be registered on a real application
 #ater.

 # blueprint is an object that allows defining application functions
 #ithout requiring an application object ahead of time. It uses the
 #ame decorators as :class:`~flask.Flask`, but defers the need for an
 #pplication by recording them for later registration.

 #ecorating a function with a blueprint creates a deferred function
 #hat is called with :class:`~flask.blueprints.BlueprintSetupState`
 #hen the blueprint is registered on an application.

 #ee :doc:`/blueprints` for more information.

 #param name: The name of the blueprint. Will be prepended to each
 #ndpoint name.
 #param import_name: The name of the blueprint package, usually
 #`__name__``. This helps locate the ``root_path`` for the
 #lueprint.
 #param static_folder: A folder with static files that should be
 #erved by the blueprint's static route. The path is relative to
 #he blueprint's root path. Blueprint static files are disabled
 #y default.
 #param static_url_path: The url to serve static files from.
 #efaults to ``static_folder``. If the blueprint does not have
 # ``url_prefix``, the app's static route will take precedence,
 #nd the blueprint's static files won't be accessible.
 #param template_folder: A folder with templates that should be added
 #o the app's template search path. The path is relative to the
 #lueprint's root path. Blueprint templates are disabled by
 #efault. Blueprint templates have a lower precedence than those
 #n the app's templates folder.
 #param url_prefix: A path to prepend to all of the blueprint's URLs,
 #o make them distinct from the rest of the app's routes.
 #param subdomain: A subdomain that blueprint routes will match on by
 #efault.
 #param url_defaults: A dict of default values that blueprint routes
 #ill receive by default.
 #param root_path: By default, the blueprint will automatically set
 #his based on ``import_name``. In certain situations this
 #utomatic detection can fail, so the path can be specified
 #anually instead.

 #. versionchanged:: 1.1.0
 #lueprints have a ``cli`` group to register nested CLI commands.
 #he ``cli_group`` parameter controls the name of the group under
 #he ``flask`` command.

 #. versionadded:: 0.7
 #""

 #arn_on_modifications = False
 #got_registered_once = False

    #: Blueprint local JSON encoder class to use. Set to ``None`` to use
    #: the app's :class:`~flask.Flask.json_encoder`.
 #son_encoder = None
    #: Blueprint local JSON decoder class to use. Set to ``None`` to use
    #: the app's :class:`~flask.Flask.json_decoder`.
 #son_decoder = None

 #ef __init__(
 #elf,
 #ame: str,
 #mport_name: str,
 #tatic_folder: t.Optional[str] = None,
 #tatic_url_path: t.Optional[str] = None,
 #emplate_folder: t.Optional[str] = None,
 #rl_prefix: t.Optional[str] = None,
 #ubdomain: t.Optional[str] = None,
 #rl_defaults: t.Optional[dict] = None,
 #oot_path: t.Optional[str] = None,
 #li_group: t.Optional[str] = _sentinel,  # type: ignore
 #:
 #uper().__init__(
 #mport_name=import_name,
 #tatic_folder=static_folder,
 #tatic_url_path=static_url_path,
 #emplate_folder=template_folder,
 #oot_path=root_path,
 #

 #f "." in name:
 #aise ValueError("'name' may not contain a dot '.' character.")

 #elf.name = name
 #elf.url_prefix = url_prefix
 #elf.subdomain = subdomain
 #elf.deferred_functions: t.List[DeferredSetupFunction] = []

 #f url_defaults is None:
 #rl_defaults = {}

 #elf.url_values_defaults = url_defaults
 #elf.cli_group = cli_group
 #elf._blueprints: t.List[t.Tuple["Blueprint", dict]] = []

 #ef _is_setup_finished(self) -> bool:
 #eturn self.warn_on_modifications and self._got_registered_once

 #ef record(self, func: t.Callable) -> None:
 #""Registers a function that is called when the blueprint is
 #egistered on the application.  This function is called with the
 #tate as argument as returned by the :meth:`make_setup_state`
 #ethod.
 #""
 #f self._got_registered_once and self.warn_on_modifications:
 #rom warnings import warn

 #arn(
 #arning(
 #The blueprint was already registered once but is"
 # getting modified now. These changes will not show"
 # up."
 #
 #
 #elf.deferred_functions.append(func)

 #ef record_once(self, func: t.Callable) -> None:
 #""Works like :meth:`record` but wraps the function in another
 #unction that will ensure the function is only called once.  If the
 #lueprint is registered a second time on the application, the
 #unction passed is not called.
 #""

 #ef wrapper(state: BlueprintSetupState) -> None:
 #f state.first_registration:
 #unc(state)

 #eturn self.record(update_wrapper(wrapper, func))

 #ef make_setup_state(
 #elf, app: "Flask", options: dict, first_registration: bool = False
 # -> BlueprintSetupState:
 #""Creates an instance of :meth:`~flask.blueprints.BlueprintSetupState`
 #bject that is later passed to the register callback functions.
 #ubclasses can override this to return a subclass of the setup state.
 #""
 #eturn BlueprintSetupState(self, app, options, first_registration)

 #ef register_blueprint(self, blueprint: "Blueprint", **options: t.Any) -> None:
 #""Register a :class:`~flask.Blueprint` on this blueprint. Keyword
 #rguments passed to this method will override the defaults set
 #n the blueprint.

 #. versionchanged:: 2.0.1
 #he ``name`` option can be used to change the (pre-dotted)
 #ame the blueprint is registered with. This allows the same
 #lueprint to be registered multiple times with unique names
 #or ``url_for``.

 #. versionadded:: 2.0
 #""
 #f blueprint is self:
 #aise ValueError("Cannot register a blueprint on itself")
 #elf._blueprints.append((blueprint, options))

 #ef register(self, app: "Flask", options: dict) -> None:
 #""Called by :meth:`Flask.register_blueprint` to register all
 #iews and callbacks registered on the blueprint with the
 #pplication. Creates a :class:`.BlueprintSetupState` and calls
 #ach :meth:`record` callback with it.

 #param app: The application this blueprint is being registered
 #ith.
 #param options: Keyword arguments forwarded from
 #meth:`~Flask.register_blueprint`.

 #. versionchanged:: 2.0.1
 #ested blueprints are registered with their dotted name.
 #his allows different blueprints with the same name to be
 #ested at different locations.

 #. versionchanged:: 2.0.1
 #he ``name`` option can be used to change the (pre-dotted)
 #ame the blueprint is registered with. This allows the same
 #lueprint to be registered multiple times with unique names
 #or ``url_for``.

 #. versionchanged:: 2.0.1
 #egistering the same blueprint with the same name multiple
 #imes is deprecated and will become an error in Flask 2.1.
 #""
 #irst_registration = not any(bp is self for bp in app.blueprints.values())
 #ame_prefix = options.get("name_prefix", "")
 #elf_name = options.get("name", self.name)
 #ame = f"{name_prefix}.{self_name}".lstrip(".")

 #f name in app.blueprints:
 #xisting_at = f" '{name}'" if self_name != name else ""

 #f app.blueprints[name] is not self:
 #aise ValueError(
 #"The name '{self_name}' is already registered for"
 #" a different blueprint{existing_at}. Use 'name='"
 # to provide a unique name."
 #
 #lse:
 #mport warnings

 #arnings.warn(
 #"The name '{self_name}' is already registered for"
 #" this blueprint{existing_at}. Use 'name=' to"
 # provide a unique name. This will become an error"
 # in Flask 2.1.",
 #tacklevel=4,
 #

 #pp.blueprints[name] = self
 #elf._got_registered_once = True
 #tate = self.make_setup_state(app, options, first_registration)

 #f self.has_static_folder:
 #tate.add_url_rule(
 #"{self.static_url_path}/<path:filename>",
 #iew_func=self.send_static_file,
 #ndpoint="static",
 #

        # Merge blueprint data into parent.
 #f first_registration:

 #ef extend(bp_dict, parent_dict):
 #or key, values in bp_dict.items():
 #ey = name if key is None else f"{name}.{key}"
 #arent_dict[key].extend(values)

 #or key, value in self.error_handler_spec.items():
 #ey = name if key is None else f"{name}.{key}"
 #alue = defaultdict(
 #ict,
 #
 #ode: {
 #xc_class: func for exc_class, func in code_values.items()
 #
 #or code, code_values in value.items()
 #,
 #
 #pp.error_handler_spec[key] = value

 #or endpoint, func in self.view_functions.items():
 #pp.view_functions[endpoint] = func

 #xtend(self.before_request_funcs, app.before_request_funcs)
 #xtend(self.after_request_funcs, app.after_request_funcs)
 #xtend(
 #elf.teardown_request_funcs,
 #pp.teardown_request_funcs,
 #
 #xtend(self.url_default_functions, app.url_default_functions)
 #xtend(self.url_value_preprocessors, app.url_value_preprocessors)
 #xtend(self.template_context_processors, app.template_context_processors)

 #or deferred in self.deferred_functions:
 #eferred(state)

 #li_resolved_group = options.get("cli_group", self.cli_group)

 #f self.cli.commands:
 #f cli_resolved_group is None:
 #pp.cli.commands.update(self.cli.commands)
 #lif cli_resolved_group is _sentinel:
 #elf.cli.name = name
 #pp.cli.add_command(self.cli)
 #lse:
 #elf.cli.name = cli_resolved_group
 #pp.cli.add_command(self.cli)

 #or blueprint, bp_options in self._blueprints:
 #p_options = bp_options.copy()
 #p_url_prefix = bp_options.get("url_prefix")

 #f bp_url_prefix is None:
 #p_url_prefix = blueprint.url_prefix

 #f state.url_prefix is not None and bp_url_prefix is not None:
 #p_options["url_prefix"] = (
 #tate.url_prefix.rstrip("/") + "/" + bp_url_prefix.lstrip("/")
 #
 #lif bp_url_prefix is not None:
 #p_options["url_prefix"] = bp_url_prefix
 #lif state.url_prefix is not None:
 #p_options["url_prefix"] = state.url_prefix

 #p_options["name_prefix"] = name
 #lueprint.register(app, bp_options)

 #ef add_url_rule(
 #elf,
 #ule: str,
 #ndpoint: t.Optional[str] = None,
 #iew_func: t.Optional[t.Callable] = None,
 #rovide_automatic_options: t.Optional[bool] = None,
 #*options: t.Any,
 # -> None:
 #""Like :meth:`Flask.add_url_rule` but for a blueprint.  The endpoint for
 #he :func:`url_for` function is prefixed with the name of the blueprint.
 #""
 #f endpoint and "." in endpoint:
 #aise ValueError("'endpoint' may not contain a dot '.' character.")

 #f view_func and hasattr(view_func, "__name__") and "." in view_func.__name__:
 #aise ValueError("'view_func' name may not contain a dot '.' character.")

 #elf.record(
 #ambda s: s.add_url_rule(
 #ule,
 #ndpoint,
 #iew_func,
 #rovide_automatic_options=provide_automatic_options,
 #*options,
 #
 #

 #ef app_template_filter(
 #elf, name: t.Optional[str] = None
 # -> t.Callable[[TemplateFilterCallable], TemplateFilterCallable]:
 #""Register a custom template filter, available application wide.  Like
 #meth:`Flask.template_filter` but for a blueprint.

 #param name: the optional name of the filter, otherwise the
 #unction name will be used.
 #""

 #ef decorator(f: TemplateFilterCallable) -> TemplateFilterCallable:
 #elf.add_app_template_filter(f, name=name)
 #eturn f

 #eturn decorator

 #ef add_app_template_filter(
 #elf, f: TemplateFilterCallable, name: t.Optional[str] = None
 # -> None:
 #""Register a custom template filter, available application wide.  Like
 #meth:`Flask.add_template_filter` but for a blueprint.  Works exactly
 #ike the :meth:`app_template_filter` decorator.

 #param name: the optional name of the filter, otherwise the
 #unction name will be used.
 #""

 #ef register_template(state: BlueprintSetupState) -> None:
 #tate.app.jinja_env.filters[name or f.__name__] = f

 #elf.record_once(register_template)

 #ef app_template_test(
 #elf, name: t.Optional[str] = None
 # -> t.Callable[[TemplateTestCallable], TemplateTestCallable]:
 #""Register a custom template test, available application wide.  Like
 #meth:`Flask.template_test` but for a blueprint.

 #. versionadded:: 0.10

 #param name: the optional name of the test, otherwise the
 #unction name will be used.
 #""

 #ef decorator(f: TemplateTestCallable) -> TemplateTestCallable:
 #elf.add_app_template_test(f, name=name)
 #eturn f

 #eturn decorator

 #ef add_app_template_test(
 #elf, f: TemplateTestCallable, name: t.Optional[str] = None
 # -> None:
 #""Register a custom template test, available application wide.  Like
 #meth:`Flask.add_template_test` but for a blueprint.  Works exactly
 #ike the :meth:`app_template_test` decorator.

 #. versionadded:: 0.10

 #param name: the optional name of the test, otherwise the
 #unction name will be used.
 #""

 #ef register_template(state: BlueprintSetupState) -> None:
 #tate.app.jinja_env.tests[name or f.__name__] = f

 #elf.record_once(register_template)

 #ef app_template_global(
 #elf, name: t.Optional[str] = None
 # -> t.Callable[[TemplateGlobalCallable], TemplateGlobalCallable]:
 #""Register a custom template global, available application wide.  Like
 #meth:`Flask.template_global` but for a blueprint.

 #. versionadded:: 0.10

 #param name: the optional name of the global, otherwise the
 #unction name will be used.
 #""

 #ef decorator(f: TemplateGlobalCallable) -> TemplateGlobalCallable:
 #elf.add_app_template_global(f, name=name)
 #eturn f

 #eturn decorator

 #ef add_app_template_global(
 #elf, f: TemplateGlobalCallable, name: t.Optional[str] = None
 # -> None:
 #""Register a custom template global, available application wide.  Like
 #meth:`Flask.add_template_global` but for a blueprint.  Works exactly
 #ike the :meth:`app_template_global` decorator.

 #. versionadded:: 0.10

 #param name: the optional name of the global, otherwise the
 #unction name will be used.
 #""

 #ef register_template(state: BlueprintSetupState) -> None:
 #tate.app.jinja_env.globals[name or f.__name__] = f

 #elf.record_once(register_template)

 #ef before_app_request(self, f: BeforeRequestCallable) -> BeforeRequestCallable:
 #""Like :meth:`Flask.before_request`.  Such a function is executed
 #efore each request, even if outside of a blueprint.
 #""
 #elf.record_once(
 #ambda s: s.app.before_request_funcs.setdefault(None, []).append(f)
 #
 #eturn f

 #ef before_app_first_request(
 #elf, f: BeforeRequestCallable
 # -> BeforeRequestCallable:
 #""Like :meth:`Flask.before_first_request`.  Such a function is
 #xecuted before the first request to the application.
 #""
 #elf.record_once(lambda s: s.app.before_first_request_funcs.append(f))
 #eturn f

 #ef after_app_request(self, f: AfterRequestCallable) -> AfterRequestCallable:
 #""Like :meth:`Flask.after_request` but for a blueprint.  Such a function
 #s executed after each request, even if outside of the blueprint.
 #""
 #elf.record_once(
 #ambda s: s.app.after_request_funcs.setdefault(None, []).append(f)
 #
 #eturn f

 #ef teardown_app_request(self, f: TeardownCallable) -> TeardownCallable:
 #""Like :meth:`Flask.teardown_request` but for a blueprint.  Such a
 #unction is executed when tearing down each request, even if outside of
 #he blueprint.
 #""
 #elf.record_once(
 #ambda s: s.app.teardown_request_funcs.setdefault(None, []).append(f)
 #
 #eturn f

 #ef app_context_processor(
 #elf, f: TemplateContextProcessorCallable
 # -> TemplateContextProcessorCallable:
 #""Like :meth:`Flask.context_processor` but for a blueprint.  Such a
 #unction is executed each request, even if outside of the blueprint.
 #""
 #elf.record_once(
 #ambda s: s.app.template_context_processors.setdefault(None, []).append(f)
 #
 #eturn f

 #ef app_errorhandler(self, code: t.Union[t.Type[Exception], int]) -> t.Callable:
 #""Like :meth:`Flask.errorhandler` but for a blueprint.  This
 #andler is used for all requests, even if outside of the blueprint.
 #""

 #ef decorator(f: ErrorHandlerCallable) -> ErrorHandlerCallable:
 #elf.record_once(lambda s: s.app.errorhandler(code)(f))
 #eturn f

 #eturn decorator

 #ef app_url_value_preprocessor(
 #elf, f: URLValuePreprocessorCallable
 # -> URLValuePreprocessorCallable:
 #""Same as :meth:`url_value_preprocessor` but application wide."""
 #elf.record_once(
 #ambda s: s.app.url_value_preprocessors.setdefault(None, []).append(f)
 #
 #eturn f

 #ef app_url_defaults(self, f: URLDefaultCallable) -> URLDefaultCallable:
 #""Same as :meth:`url_defaults` but application wide."""
 #elf.record_once(
 #ambda s: s.app.url_default_functions.setdefault(None, []).append(f)
 #
 #eturn f
