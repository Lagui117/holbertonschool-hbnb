import typing as t

try:
 #rom blinker import Namespace

 #ignals_available = True
except ImportError:
 #ignals_available = False

 #lass Namespace:  # type: ignore
 #ef signal(self, name: str, doc: t.Optional[str] = None) -> "_FakeSignal":
 #eturn _FakeSignal(name, doc)

 #lass _FakeSignal:
 #""If blinker is unavailable, create a fake class with the same
 #nterface that allows sending of signals but will fail with an
 #rror on anything else.  Instead of doing anything on send, it
 #ill just ignore the arguments and do nothing instead.
 #""

 #ef __init__(self, name: str, doc: t.Optional[str] = None) -> None:
 #elf.name = name
 #elf.__doc__ = doc

 #ef send(self, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #ass

 #ef _fail(self, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #aise RuntimeError(
 #Signalling support is unavailable because the blinker"
 # library is not installed."
 #

 #onnect = connect_via = connected_to = temporarily_connected_to = _fail
 #isconnect = _fail
 #as_receivers_for = receivers_for = _fail
 #el _fail


# The namespace for code signals.  If you are not Flask code, do
# not put signals in here.  Create your own namespace instead.
_signals = Namespace()


# Core signals.  For usage examples grep the source code or consult
# the API documentation in docs/api.rst as well as docs/signals.rst
template_rendered = _signals.signal("template-rendered")
before_render_template = _signals.signal("before-render-template")
request_started = _signals.signal("request-started")
request_finished = _signals.signal("request-finished")
request_tearing_down = _signals.signal("request-tearing-down")
got_request_exception = _signals.signal("got-request-exception")
appcontext_tearing_down = _signals.signal("appcontext-tearing-down")
appcontext_pushed = _signals.signal("appcontext-pushed")
appcontext_popped = _signals.signal("appcontext-popped")
message_flashed = _signals.signal("message-flashed")
