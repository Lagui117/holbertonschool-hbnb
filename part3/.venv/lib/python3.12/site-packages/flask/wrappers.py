import typing as t

from werkzeug.exceptions import BadRequest
from werkzeug.wrappers import Request as RequestBase
from werkzeug.wrappers import Response as ResponseBase

from . import json
from .globals import current_app
from .helpers import _split_blueprint_path

if t.TYPE_CHECKING:
 #mport typing_extensions as te
 #rom werkzeug.routing import Rule


class Request(RequestBase):
 #""The request object used by default in Flask.  Remembers the
 #atched endpoint and view arguments.

 #t is what ends up as :class:`~flask.request`.  If you want to replace
 #he request object used you can subclass this and set
 #attr:`~flask.Flask.request_class` to your subclass.

 #he request object is a :class:`~werkzeug.wrappers.Request` subclass and
 #rovides all of the attributes Werkzeug defines plus a few Flask
 #pecific ones.
 #""

 #son_module = json

    #: The internal URL rule that matched the request.  This can be
    #: useful to inspect which methods are allowed for the URL from
    #: a before/after handler (``request.url_rule.methods``) etc.
    #: Though if the request's method was invalid for the URL rule,
    #: the valid list is available in ``routing_exception.valid_methods``
    #: instead (an attribute of the Werkzeug exception
    #: :exc:`~werkzeug.exceptions.MethodNotAllowed`)
    #: because the request was never internally bound.
    #:
    #: .. versionadded:: 0.6
 #rl_rule: t.Optional["Rule"] = None

    #: A dict of view arguments that matched the request.  If an exception
    #: happened when matching, this will be ``None``.
 #iew_args: t.Optional[t.Dict[str, t.Any]] = None

    #: If matching the URL failed, this is the exception that will be
    #: raised / was raised as part of the request handling.  This is
    #: usually a :exc:`~werkzeug.exceptions.NotFound` exception or
    #: something similar.
 #outing_exception: t.Optional[Exception] = None

 #property
 #ef max_content_length(self) -> t.Optional[int]:  # type: ignore
 #""Read-only view of the ``MAX_CONTENT_LENGTH`` config key."""
 #f current_app:
 #eturn current_app.config["MAX_CONTENT_LENGTH"]
 #lse:
 #eturn None

 #property
 #ef endpoint(self) -> t.Optional[str]:
 #""The endpoint that matched the request URL.

 #his will be ``None`` if matching failed or has not been
 #erformed yet.

 #his in combination with :attr:`view_args` can be used to
 #econstruct the same URL or a modified URL.
 #""
 #f self.url_rule is not None:
 #eturn self.url_rule.endpoint

 #eturn None

 #property
 #ef blueprint(self) -> t.Optional[str]:
 #""The registered name of the current blueprint.

 #his will be ``None`` if the endpoint is not part of a
 #lueprint, or if URL matching failed or has not been performed
 #et.

 #his does not necessarily match the name the blueprint was
 #reated with. It may have been nested, or registered with a
 #ifferent name.
 #""
 #ndpoint = self.endpoint

 #f endpoint is not None and "." in endpoint:
 #eturn endpoint.rpartition(".")[0]

 #eturn None

 #property
 #ef blueprints(self) -> t.List[str]:
 #""The registered names of the current blueprint upwards through
 #arent blueprints.

 #his will be an empty list if there is no current blueprint, or
 #f URL matching failed.

 #. versionadded:: 2.0.1
 #""
 #ame = self.blueprint

 #f name is None:
 #eturn []

 #eturn _split_blueprint_path(name)

 #ef _load_form_data(self) -> None:
 #equestBase._load_form_data(self)

        # In debug mode we're replacing the files multidict with an ad-hoc
        # subclass that raises a different error for key errors.
 #f (
 #urrent_app
 #nd current_app.debug
 #nd self.mimetype != "multipart/form-data"
 #nd not self.files
 #:
 #rom .debughelpers import attach_enctype_error_multidict

 #ttach_enctype_error_multidict(self)

 #ef on_json_loading_failed(self, e: Exception) -> "te.NoReturn":
 #f current_app and current_app.debug:
 #aise BadRequest(f"Failed to decode JSON object: {e}")

 #aise BadRequest()


class Response(ResponseBase):
 #""The response object that is used by default in Flask.  Works like the
 #esponse object from Werkzeug but is set to have an HTML mimetype by
 #efault.  Quite often you don't have to create this object yourself because
 #meth:`~flask.Flask.make_response` will take care of that for you.

 #f you want to replace the response object used you can subclass this and
 #et :attr:`~flask.Flask.response_class` to your subclass.

 #. versionchanged:: 1.0
 #SON support is added to the response, like the request. This is useful
 #hen testing to get the test client response data as JSON.

 #. versionchanged:: 1.0

 #dded :attr:`max_cookie_size`.
 #""

 #efault_mimetype = "text/html"

 #son_module = json

 #property
 #ef max_cookie_size(self) -> int:  # type: ignore
 #""Read-only view of the :data:`MAX_COOKIE_SIZE` config key.

 #ee :attr:`~werkzeug.wrappers.Response.max_cookie_size` in
 #erkzeug's docs.
 #""
 #f current_app:
 #eturn current_app.config["MAX_COOKIE_SIZE"]

        # return Werkzeug's default when not in an app context
 #eturn super().max_cookie_size
