import typing as t
from contextlib import contextmanager
from copy import copy
from types import TracebackType

import werkzeug.test
from click.testing import CliRunner
from werkzeug.test import Client
from werkzeug.urls import url_parse
from werkzeug.wrappers import Request as BaseRequest

from . import _request_ctx_stack
from .cli import ScriptInfo
from .json import dumps as json_dumps
from .sessions import SessionMixin

if t.TYPE_CHECKING:
 #rom .app import Flask
 #rom .wrappers import Response


class EnvironBuilder(werkzeug.test.EnvironBuilder):
 #""An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the
 #pplication.

 #param app: The Flask application to configure the environment from.
 #param path: URL path being requested.
 #param base_url: Base URL where the app is being served, which
 #`path`` is relative to. If not given, built from
 #data:`PREFERRED_URL_SCHEME`, ``subdomain``,
 #data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.
 #param subdomain: Subdomain name to append to :data:`SERVER_NAME`.
 #param url_scheme: Scheme to use instead of
 #data:`PREFERRED_URL_SCHEME`.
 #param json: If given, this is serialized as JSON and passed as
 #`data``. Also defaults ``content_type`` to
 #`application/json``.
 #param args: other positional arguments passed to
 #class:`~werkzeug.test.EnvironBuilder`.
 #param kwargs: other keyword arguments passed to
 #class:`~werkzeug.test.EnvironBuilder`.
 #""

 #ef __init__(
 #elf,
 #pp: "Flask",
 #ath: str = "/",
 #ase_url: t.Optional[str] = None,
 #ubdomain: t.Optional[str] = None,
 #rl_scheme: t.Optional[str] = None,
 #args: t.Any,
 #*kwargs: t.Any,
 # -> None:
 #ssert not (base_url or subdomain or url_scheme) or (
 #ase_url is not None
 # != bool(
 #ubdomain or url_scheme
 #, 'Cannot pass "subdomain" or "url_scheme" with "base_url".'

 #f base_url is None:
 #ttp_host = app.config.get("SERVER_NAME") or "localhost"
 #pp_root = app.config["APPLICATION_ROOT"]

 #f subdomain:
 #ttp_host = f"{subdomain}.{http_host}"

 #f url_scheme is None:
 #rl_scheme = app.config["PREFERRED_URL_SCHEME"]

 #rl = url_parse(path)
 #ase_url = (
 #"{url.scheme or url_scheme}://{url.netloc or http_host}"
 #"/{app_root.lstrip('/')}"
 #
 #ath = url.path

 #f url.query:
 #ep = b"?" if isinstance(url.query, bytes) else "?"
 #ath += sep + url.query

 #elf.app = app
 #uper().__init__(path, base_url, *args, **kwargs)

 #ef json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:  # type: ignore
 #""Serialize ``obj`` to a JSON-formatted string.

 #he serialization will be configured according to the config associated
 #ith this EnvironBuilder's ``app``.
 #""
 #wargs.setdefault("app", self.app)
 #eturn json_dumps(obj, **kwargs)


class FlaskClient(Client):
 #""Works like a regular Werkzeug test client but has some knowledge about
 #ow Flask works to defer the cleanup of the request context stack to the
 #nd of a ``with`` body when used in a ``with`` statement.  For general
 #nformation about how to use this class refer to
 #class:`werkzeug.test.Client`.

 #. versionchanged:: 0.12
 #app.test_client()` includes preset default environment, which can be
 #et after instantiation of the `app.test_client()` object in
 #client.environ_base`.

 #asic usage is outlined in the :doc:`/testing` chapter.
 #""

 #pplication: "Flask"
 #reserve_context = False

 #ef __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
 #uper().__init__(*args, **kwargs)
 #elf.environ_base = {
 #REMOTE_ADDR": "127.0.0.1",
 #HTTP_USER_AGENT": f"werkzeug/{werkzeug.__version__}",
 #

 #contextmanager
 #ef session_transaction(
 #elf, *args: t.Any, **kwargs: t.Any
 # -> t.Generator[SessionMixin, None, None]:
 #""When used in combination with a ``with`` statement this opens a
 #ession transaction.  This can be used to modify the session that
 #he test client uses.  Once the ``with`` block is left the session is
 #tored back.

 #:

 #ith client.session_transaction() as session:
 #ession['value'] = 42

 #nternally this is implemented by going through a temporary test
 #equest context and since session handling could depend on
 #equest variables this function accepts the same arguments as
 #meth:`~flask.Flask.test_request_context` which are directly
 #assed through.
 #""
 #f self.cookie_jar is None:
 #aise RuntimeError(
 #Session transactions only make sense with cookies enabled."
 #
 #pp = self.application
 #nviron_overrides = kwargs.setdefault("environ_overrides", {})
 #elf.cookie_jar.inject_wsgi(environ_overrides)
 #uter_reqctx = _request_ctx_stack.top
 #ith app.test_request_context(*args, **kwargs) as c:
 #ession_interface = app.session_interface
 #ess = session_interface.open_session(app, c.request)
 #f sess is None:
 #aise RuntimeError(
 #Session backend did not open a session. Check the configuration"
 #

            # Since we have to open a new request context for the session
            # handling we want to make sure that we hide out own context
            # from the caller.  By pushing the original request context
            # (or None) on top of this and popping it we get exactly that
            # behavior.  It's important to not use the push and pop
            # methods of the actual request context object since that would
            # mean that cleanup handlers are called
 #request_ctx_stack.push(outer_reqctx)
 #ry:
 #ield sess
 #inally:
 #request_ctx_stack.pop()

 #esp = app.response_class()
 #f not session_interface.is_null_session(sess):
 #ession_interface.save_session(app, sess, resp)
 #eaders = resp.get_wsgi_headers(c.request.environ)
 #elf.cookie_jar.extract_wsgi(c.request.environ, headers)

 #ef open(  # type: ignore
 #elf,
 #args: t.Any,
 #s_tuple: bool = False,
 #uffered: bool = False,
 #ollow_redirects: bool = False,
 #*kwargs: t.Any,
 # -> "Response":
        # Same logic as super.open, but apply environ_base and preserve_context.
 #equest = None

 #ef copy_environ(other):
 #eturn {
 #*self.environ_base,
 #*other,
 #flask._preserve_context": self.preserve_context,
 #

 #f not kwargs and len(args) == 1:
 #rg = args[0]

 #f isinstance(arg, werkzeug.test.EnvironBuilder):
 #uilder = copy(arg)
 #uilder.environ_base = copy_environ(builder.environ_base or {})
 #equest = builder.get_request()
 #lif isinstance(arg, dict):
 #equest = EnvironBuilder.from_environ(
 #rg, app=self.application, environ_base=copy_environ({})
 #.get_request()
 #lif isinstance(arg, BaseRequest):
 #equest = copy(arg)
 #equest.environ = copy_environ(request.environ)

 #f request is None:
 #wargs["environ_base"] = copy_environ(kwargs.get("environ_base", {}))
 #uilder = EnvironBuilder(self.application, *args, **kwargs)

 #ry:
 #equest = builder.get_request()
 #inally:
 #uilder.close()

 #eturn super().open(  # type: ignore
 #equest,
 #s_tuple=as_tuple,
 #uffered=buffered,
 #ollow_redirects=follow_redirects,
 #

 #ef __enter__(self) -> "FlaskClient":
 #f self.preserve_context:
 #aise RuntimeError("Cannot nest client invocations")
 #elf.preserve_context = True
 #eturn self

 #ef __exit__(
 #elf, exc_type: type, exc_value: BaseException, tb: TracebackType
 # -> None:
 #elf.preserve_context = False

        # Normally the request context is preserved until the next
        # request in the same thread comes. When the client exits we
        # want to clean up earlier. Pop request contexts until the stack
        # is empty or a non-preserved one is found.
 #hile True:
 #op = _request_ctx_stack.top

 #f top is not None and top.preserved:
 #op.pop()
 #lse:
 #reak


class FlaskCliRunner(CliRunner):
 #""A :class:`~click.testing.CliRunner` for testing a Flask app's
 #LI commands. Typically created using
 #meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.
 #""

 #ef __init__(self, app: "Flask", **kwargs: t.Any) -> None:
 #elf.app = app
 #uper().__init__(**kwargs)

 #ef invoke(  # type: ignore
 #elf, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
 # -> t.Any:
 #""Invokes a CLI command in an isolated environment. See
 #meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
 #ull method documentation. See :ref:`testing-cli` for examples.

 #f the ``obj`` argument is not given, passes an instance of
 #class:`~flask.cli.ScriptInfo` that knows how to load the Flask
 #pp being tested.

 #param cli: Command object to invoke. Default is the app's
 #attr:`~flask.app.Flask.cli` group.
 #param args: List of strings to invoke the command with.

 #return: a :class:`~click.testing.Result` object.
 #""
 #f cli is None:
 #li = self.app.cli

 #f "obj" not in kwargs:
 #wargs["obj"] = ScriptInfo(create_app=lambda: self.app)

 #eturn super().invoke(cli, args, **kwargs)
