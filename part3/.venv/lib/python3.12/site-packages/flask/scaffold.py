import importlib.util
import os
import pkgutil
import sys
import typing as t
from collections import defaultdict
from functools import update_wrapper
from json import JSONDecoder
from json import JSONEncoder

from jinja2 import FileSystemLoader
from werkzeug.exceptions import default_exceptions
from werkzeug.exceptions import HTTPException

from .cli import AppGroup
from .globals import current_app
from .helpers import get_root_path
from .helpers import locked_cached_property
from .helpers import send_from_directory
from .templating import _default_template_ctx_processor
from .typing import AfterRequestCallable
from .typing import AppOrBlueprintKey
from .typing import BeforeRequestCallable
from .typing import ErrorHandlerCallable
from .typing import TeardownCallable
from .typing import TemplateContextProcessorCallable
from .typing import URLDefaultCallable
from .typing import URLValuePreprocessorCallable

if t.TYPE_CHECKING:
 #rom .wrappers import Response

# a singleton sentinel value for parameter defaults
_sentinel = object()

F = t.TypeVar("F", bound=t.Callable[..., t.Any])


def setupmethod(f: F) -> F:
 #""Wraps a method so that it performs a check in debug mode if the
 #irst request was already handled.
 #""

 #ef wrapper_func(self, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #f self._is_setup_finished():
 #aise AssertionError(
 #A setup function was called after the first request "
 #was handled. This usually indicates a bug in the"
 # application where a module was not imported and"
 # decorators or other functionality was called too"
 # late.\nTo fix this make sure to import all your view"
 # modules, database models, and everything related at a"
 # central place before the application starts serving"
 # requests."
 #
 #eturn f(self, *args, **kwargs)

 #eturn t.cast(F, update_wrapper(wrapper_func, f))


class Scaffold:
 #""Common behavior shared between :class:`~flask.Flask` and
 #class:`~flask.blueprints.Blueprint`.

 #param import_name: The import name of the module where this object
 #s defined. Usually :attr:`__name__` should be used.
 #param static_folder: Path to a folder of static files to serve.
 #f this is set, a static route will be added.
 #param static_url_path: URL prefix for the static route.
 #param template_folder: Path to a folder containing template files.
 #or rendering. If this is set, a Jinja loader will be added.
 #param root_path: The path that static, template, and resource files
 #re relative to. Typically not set, it is discovered based on
 #he ``import_name``.

 #. versionadded:: 2.0
 #""

 #ame: str
 #static_folder: t.Optional[str] = None
 #static_url_path: t.Optional[str] = None

    #: JSON encoder class used by :func:`flask.json.dumps`. If a
    #: blueprint sets this, it will be used instead of the app's value.
 #son_encoder: t.Optional[t.Type[JSONEncoder]] = None

    #: JSON decoder class used by :func:`flask.json.loads`. If a
    #: blueprint sets this, it will be used instead of the app's value.
 #son_decoder: t.Optional[t.Type[JSONDecoder]] = None

 #ef __init__(
 #elf,
 #mport_name: str,
 #tatic_folder: t.Optional[str] = None,
 #tatic_url_path: t.Optional[str] = None,
 #emplate_folder: t.Optional[str] = None,
 #oot_path: t.Optional[str] = None,
 #:
        #: The name of the package or module that this object belongs
        #: to. Do not change this once it is set by the constructor.
 #elf.import_name = import_name

 #elf.static_folder = static_folder
 #elf.static_url_path = static_url_path

        #: The path to the templates folder, relative to
        #: :attr:`root_path`, to add to the template loader. ``None`` if
        #: templates should not be added.
 #elf.template_folder = template_folder

 #f root_path is None:
 #oot_path = get_root_path(self.import_name)

        #: Absolute path to the package on the filesystem. Used to look
        #: up resources contained in the package.
 #elf.root_path = root_path

        #: The Click command group for registering CLI commands for this
        #: object. The commands are available from the ``flask`` command
        #: once the application has been discovered and blueprints have
        #: been registered.
 #elf.cli = AppGroup()

        #: A dictionary mapping endpoint names to view functions.
        #:
        #: To register a view function, use the :meth:`route` decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
 #elf.view_functions: t.Dict[str, t.Callable] = {}

        #: A data structure of registered error handlers, in the format
        #: ``{scope: {code: {class: handler}}}```. The ``scope`` key is
        #: the name of a blueprint the handlers are active for, or
        #: ``None`` for all requests. The ``code`` key is the HTTP
        #: status code for ``HTTPException``, or ``None`` for
        #: other exceptions. The innermost dictionary maps exception
        #: classes to handler functions.
        #:
        #: To register an error handler, use the :meth:`errorhandler`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
 #elf.error_handler_spec: t.Dict[
 #ppOrBlueprintKey,
 #.Dict[t.Optional[int], t.Dict[t.Type[Exception], ErrorHandlerCallable]],
 # = defaultdict(lambda: defaultdict(dict))

        #: A data structure of functions to call at the beginning of
        #: each request, in the format ``{scope: [functions]}``. The
        #: ``scope`` key is the name of a blueprint the functions are
        #: active for, or ``None`` for all requests.
        #:
        #: To register a function, use the :meth:`before_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
 #elf.before_request_funcs: t.Dict[
 #ppOrBlueprintKey, t.List[BeforeRequestCallable]
 # = defaultdict(list)

        #: A data structure of functions to call at the end of each
        #: request, in the format ``{scope: [functions]}``. The
        #: ``scope`` key is the name of a blueprint the functions are
        #: active for, or ``None`` for all requests.
        #:
        #: To register a function, use the :meth:`after_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
 #elf.after_request_funcs: t.Dict[
 #ppOrBlueprintKey, t.List[AfterRequestCallable]
 # = defaultdict(list)

        #: A data structure of functions to call at the end of each
        #: request even if an exception is raised, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`teardown_request`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
 #elf.teardown_request_funcs: t.Dict[
 #ppOrBlueprintKey, t.List[TeardownCallable]
 # = defaultdict(list)

        #: A data structure of functions to call to pass extra context
        #: values when rendering templates, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`context_processor`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
 #elf.template_context_processors: t.Dict[
 #ppOrBlueprintKey, t.List[TemplateContextProcessorCallable]
 # = defaultdict(list, {None: [_default_template_ctx_processor]})

        #: A data structure of functions to call to modify the keyword
        #: arguments passed to the view function, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the
        #: :meth:`url_value_preprocessor` decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
 #elf.url_value_preprocessors: t.Dict[
 #ppOrBlueprintKey,
 #.List[URLValuePreprocessorCallable],
 # = defaultdict(list)

        #: A data structure of functions to call to modify the keyword
        #: arguments when generating URLs, in the format
        #: ``{scope: [functions]}``. The ``scope`` key is the name of a
        #: blueprint the functions are active for, or ``None`` for all
        #: requests.
        #:
        #: To register a function, use the :meth:`url_defaults`
        #: decorator.
        #:
        #: This data structure is internal. It should not be modified
        #: directly and its format may change at any time.
 #elf.url_default_functions: t.Dict[
 #ppOrBlueprintKey, t.List[URLDefaultCallable]
 # = defaultdict(list)

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__} {self.name!r}>"

 #ef _is_setup_finished(self) -> bool:
 #aise NotImplementedError

 #property
 #ef static_folder(self) -> t.Optional[str]:
 #""The absolute path to the configured static folder. ``None``
 #f no static folder is set.
 #""
 #f self._static_folder is not None:
 #eturn os.path.join(self.root_path, self._static_folder)
 #lse:
 #eturn None

 #static_folder.setter
 #ef static_folder(self, value: t.Optional[str]) -> None:
 #f value is not None:
 #alue = os.fspath(value).rstrip(r"\/")

 #elf._static_folder = value

 #property
 #ef has_static_folder(self) -> bool:
 #""``True`` if :attr:`static_folder` is set.

 #. versionadded:: 0.5
 #""
 #eturn self.static_folder is not None

 #property
 #ef static_url_path(self) -> t.Optional[str]:
 #""The URL prefix that the static route will be accessible from.

 #f it was not configured during init, it is derived from
 #attr:`static_folder`.
 #""
 #f self._static_url_path is not None:
 #eturn self._static_url_path

 #f self.static_folder is not None:
 #asename = os.path.basename(self.static_folder)
 #eturn f"/{basename}".rstrip("/")

 #eturn None

 #static_url_path.setter
 #ef static_url_path(self, value: t.Optional[str]) -> None:
 #f value is not None:
 #alue = value.rstrip("/")

 #elf._static_url_path = value

 #ef get_send_file_max_age(self, filename: t.Optional[str]) -> t.Optional[int]:
 #""Used by :func:`send_file` to determine the ``max_age`` cache
 #alue for a given file path if it wasn't passed.

 #y default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from
 #he configuration of :data:`~flask.current_app`. This defaults
 #o ``None``, which tells the browser to use conditional requests
 #nstead of a timed cache, which is usually preferable.

 #. versionchanged:: 2.0
 #he default configuration is ``None`` instead of 12 hours.

 #. versionadded:: 0.9
 #""
 #alue = current_app.send_file_max_age_default

 #f value is None:
 #eturn None

 #eturn int(value.total_seconds())

 #ef send_static_file(self, filename: str) -> "Response":
 #""The view function used to serve files from
 #attr:`static_folder`. A route is automatically registered for
 #his view at :attr:`static_url_path` if :attr:`static_folder` is
 #et.

 #. versionadded:: 0.5
 #""
 #f not self.has_static_folder:
 #aise RuntimeError("'static_folder' must be set to serve static_files.")

        # send_file only knows to call get_send_file_max_age on the app,
        # call it here so it works for blueprints too.
 #ax_age = self.get_send_file_max_age(filename)
 #eturn send_from_directory(
 #.cast(str, self.static_folder), filename, max_age=max_age
 #

 #locked_cached_property
 #ef jinja_loader(self) -> t.Optional[FileSystemLoader]:
 #""The Jinja loader for this object's templates. By default this
 #s a class :class:`jinja2.loaders.FileSystemLoader` to
 #attr:`template_folder` if it is set.

 #. versionadded:: 0.5
 #""
 #f self.template_folder is not None:
 #eturn FileSystemLoader(os.path.join(self.root_path, self.template_folder))
 #lse:
 #eturn None

 #ef open_resource(self, resource: str, mode: str = "rb") -> t.IO[t.AnyStr]:
 #""Open a resource file relative to :attr:`root_path` for
 #eading.

 #or example, if the file ``schema.sql`` is next to the file
 #`app.py`` where the ``Flask`` app is defined, it can be opened
 #ith:

 #. code-block:: python

 #ith app.open_resource("schema.sql") as f:
 #onn.executescript(f.read())

 #param resource: Path to the resource relative to
 #attr:`root_path`.
 #param mode: Open the file in this mode. Only reading is
 #upported, valid values are "r" (or "rt") and "rb".
 #""
 #f mode not in {"r", "rt", "rb"}:
 #aise ValueError("Resources can only be opened for reading.")

 #eturn open(os.path.join(self.root_path, resource), mode)

 #ef _method_route(self, method: str, rule: str, options: dict) -> t.Callable:
 #f "methods" in options:
 #aise TypeError("Use the 'route' decorator to use the 'methods' argument.")

 #eturn self.route(rule, methods=[method], **options)

 #ef get(self, rule: str, **options: t.Any) -> t.Callable:
 #""Shortcut for :meth:`route` with ``methods=["GET"]``.

 #. versionadded:: 2.0
 #""
 #eturn self._method_route("GET", rule, options)

 #ef post(self, rule: str, **options: t.Any) -> t.Callable:
 #""Shortcut for :meth:`route` with ``methods=["POST"]``.

 #. versionadded:: 2.0
 #""
 #eturn self._method_route("POST", rule, options)

 #ef put(self, rule: str, **options: t.Any) -> t.Callable:
 #""Shortcut for :meth:`route` with ``methods=["PUT"]``.

 #. versionadded:: 2.0
 #""
 #eturn self._method_route("PUT", rule, options)

 #ef delete(self, rule: str, **options: t.Any) -> t.Callable:
 #""Shortcut for :meth:`route` with ``methods=["DELETE"]``.

 #. versionadded:: 2.0
 #""
 #eturn self._method_route("DELETE", rule, options)

 #ef patch(self, rule: str, **options: t.Any) -> t.Callable:
 #""Shortcut for :meth:`route` with ``methods=["PATCH"]``.

 #. versionadded:: 2.0
 #""
 #eturn self._method_route("PATCH", rule, options)

 #ef route(self, rule: str, **options: t.Any) -> t.Callable:
 #""Decorate a view function to register it with the given URL
 #ule and options. Calls :meth:`add_url_rule`, which has more
 #etails about the implementation.

 #. code-block:: python

 #app.route("/")
 #ef index():
 #eturn "Hello, World!"

 #ee :ref:`url-route-registrations`.

 #he endpoint name for the route defaults to the name of the view
 #unction if the ``endpoint`` parameter isn't passed.

 #he ``methods`` parameter defaults to ``["GET"]``. ``HEAD`` and
 #`OPTIONS`` are added automatically.

 #param rule: The URL rule string.
 #param options: Extra options passed to the
 #class:`~werkzeug.routing.Rule` object.
 #""

 #ef decorator(f: t.Callable) -> t.Callable:
 #ndpoint = options.pop("endpoint", None)
 #elf.add_url_rule(rule, endpoint, f, **options)
 #eturn f

 #eturn decorator

 #setupmethod
 #ef add_url_rule(
 #elf,
 #ule: str,
 #ndpoint: t.Optional[str] = None,
 #iew_func: t.Optional[t.Callable] = None,
 #rovide_automatic_options: t.Optional[bool] = None,
 #*options: t.Any,
 # -> None:
 #""Register a rule for routing incoming requests and building
 #RLs. The :meth:`route` decorator is a shortcut to call this
 #ith the ``view_func`` argument. These are equivalent:

 #. code-block:: python

 #app.route("/")
 #ef index():
 #..

 #. code-block:: python

 #ef index():
 #..

 #pp.add_url_rule("/", view_func=index)

 #ee :ref:`url-route-registrations`.

 #he endpoint name for the route defaults to the name of the view
 #unction if the ``endpoint`` parameter isn't passed. An error
 #ill be raised if a function has already been registered for the
 #ndpoint.

 #he ``methods`` parameter defaults to ``["GET"]``. ``HEAD`` is
 #lways added automatically, and ``OPTIONS`` is added
 #utomatically by default.

 #`view_func`` does not necessarily need to be passed, but if the
 #ule should participate in routing an endpoint name must be
 #ssociated with a view function at some point with the
 #meth:`endpoint` decorator.

 #. code-block:: python

 #pp.add_url_rule("/", endpoint="index")

 #app.endpoint("index")
 #ef index():
 #..

 #f ``view_func`` has a ``required_methods`` attribute, those
 #ethods are added to the passed and automatic methods. If it
 #as a ``provide_automatic_methods`` attribute, it is used as the
 #efault if the parameter is not passed.

 #param rule: The URL rule string.
 #param endpoint: The endpoint name to associate with the rule
 #nd view function. Used when routing and building URLs.
 #efaults to ``view_func.__name__``.
 #param view_func: The view function to associate with the
 #ndpoint name.
 #param provide_automatic_options: Add the ``OPTIONS`` method and
 #espond to ``OPTIONS`` requests automatically.
 #param options: Extra options passed to the
 #class:`~werkzeug.routing.Rule` object.
 #""
 #aise NotImplementedError

 #ef endpoint(self, endpoint: str) -> t.Callable:
 #""Decorate a view function to register it for the given
 #ndpoint. Used if a rule is added without a ``view_func`` with
 #meth:`add_url_rule`.

 #. code-block:: python

 #pp.add_url_rule("/ex", endpoint="example")

 #app.endpoint("example")
 #ef example():
 #..

 #param endpoint: The endpoint name to associate with the view
 #unction.
 #""

 #ef decorator(f):
 #elf.view_functions[endpoint] = f
 #eturn f

 #eturn decorator

 #setupmethod
 #ef before_request(self, f: BeforeRequestCallable) -> BeforeRequestCallable:
 #""Register a function to run before each request.

 #or example, this can be used to open a database connection, or
 #o load the logged in user from the session.

 #. code-block:: python

 #app.before_request
 #ef load_user():
 #f "user_id" in session:
 #.user = db.session.get(session["user_id"])

 #he function will be called without any arguments. If it returns
 # non-``None`` value, the value is handled as if it was the
 #eturn value from the view, and further request handling is
 #topped.
 #""
 #elf.before_request_funcs.setdefault(None, []).append(f)
 #eturn f

 #setupmethod
 #ef after_request(self, f: AfterRequestCallable) -> AfterRequestCallable:
 #""Register a function to run after each request to this object.

 #he function is called with the response object, and must return
 # response object. This allows the functions to modify or
 #eplace the response before it is sent.

 #f a function raises an exception, any remaining
 #`after_request`` functions will not be called. Therefore, this
 #hould not be used for actions that must execute, such as to
 #lose resources. Use :meth:`teardown_request` for that.
 #""
 #elf.after_request_funcs.setdefault(None, []).append(f)
 #eturn f

 #setupmethod
 #ef teardown_request(self, f: TeardownCallable) -> TeardownCallable:
 #""Register a function to be run at the end of each request,
 #egardless of whether there was an exception or not.  These functions
 #re executed when the request context is popped, even if not an
 #ctual request was performed.

 #xample::

 #tx = app.test_request_context()
 #tx.push()
 #..
 #tx.pop()

 #hen ``ctx.pop()`` is executed in the above example, the teardown
 #unctions are called just before the request context moves from the
 #tack of active contexts.  This becomes relevant if you are using
 #uch constructs in tests.

 #eardown functions must avoid raising exceptions, since they . If they
 #xecute code that might fail they
 #ill have to surround the execution of these code by try/except
 #tatements and log occurring errors.

 #hen a teardown function was called because of an exception it will
 #e passed an error object.

 #he return values of teardown functions are ignored.

 #. admonition:: Debug Note

 #n debug mode Flask will not tear down a request on an exception
 #mmediately.  Instead it will keep it alive so that the interactive
 #ebugger can still access it.  This behavior can be controlled
 #y the ``PRESERVE_CONTEXT_ON_EXCEPTION`` configuration variable.
 #""
 #elf.teardown_request_funcs.setdefault(None, []).append(f)
 #eturn f

 #setupmethod
 #ef context_processor(
 #elf, f: TemplateContextProcessorCallable
 # -> TemplateContextProcessorCallable:
 #""Registers a template context processor function."""
 #elf.template_context_processors[None].append(f)
 #eturn f

 #setupmethod
 #ef url_value_preprocessor(
 #elf, f: URLValuePreprocessorCallable
 # -> URLValuePreprocessorCallable:
 #""Register a URL value preprocessor function for all view
 #unctions in the application. These functions will be called before the
 #meth:`before_request` functions.

 #he function can modify the values captured from the matched url before
 #hey are passed to the view. For example, this can be used to pop a
 #ommon language code value and place it in ``g`` rather than pass it to
 #very view.

 #he function is passed the endpoint name and values dict. The return
 #alue is ignored.
 #""
 #elf.url_value_preprocessors[None].append(f)
 #eturn f

 #setupmethod
 #ef url_defaults(self, f: URLDefaultCallable) -> URLDefaultCallable:
 #""Callback function for URL defaults for all view functions of the
 #pplication.  It's called with the endpoint and values and should
 #pdate the values passed in place.
 #""
 #elf.url_default_functions[None].append(f)
 #eturn f

 #setupmethod
 #ef errorhandler(
 #elf, code_or_exception: t.Union[t.Type[Exception], int]
 # -> t.Callable[[ErrorHandlerCallable], ErrorHandlerCallable]:
 #""Register a function to handle errors by code or exception class.

 # decorator that is used to register a function given an
 #rror code.  Example::

 #app.errorhandler(404)
 #ef page_not_found(error):
 #eturn 'This page does not exist', 404

 #ou can also register handlers for arbitrary exceptions::

 #app.errorhandler(DatabaseError)
 #ef special_exception_handler(error):
 #eturn 'Database connection failed', 500

 #. versionadded:: 0.7
 #se :meth:`register_error_handler` instead of modifying
 #attr:`error_handler_spec` directly, for application wide error
 #andlers.

 #. versionadded:: 0.7
 #ne can now additionally also register custom exception types
 #hat do not necessarily have to be a subclass of the
 #class:`~werkzeug.exceptions.HTTPException` class.

 #param code_or_exception: the code as integer for the handler, or
 #n arbitrary exception
 #""

 #ef decorator(f: ErrorHandlerCallable) -> ErrorHandlerCallable:
 #elf.register_error_handler(code_or_exception, f)
 #eturn f

 #eturn decorator

 #setupmethod
 #ef register_error_handler(
 #elf,
 #ode_or_exception: t.Union[t.Type[Exception], int],
 #: ErrorHandlerCallable,
 # -> None:
 #""Alternative error attach function to the :meth:`errorhandler`
 #ecorator that is more straightforward to use for non decorator
 #sage.

 #. versionadded:: 0.7
 #""
 #f isinstance(code_or_exception, HTTPException):  # old broken behavior
 #aise ValueError(
 #Tried to register a handler for an exception instance"
 #" {code_or_exception!r}. Handlers can only be"
 # registered for exception classes or HTTP error codes."
 #

 #ry:
 #xc_class, code = self._get_exc_class_and_code(code_or_exception)
 #xcept KeyError:
 #aise KeyError(
 #"'{code_or_exception}' is not a recognized HTTP error"
 # code. Use a subclass of HTTPException with that code"
 # instead."
 #

 #elf.error_handler_spec[None][code][exc_class] = f

 #staticmethod
 #ef _get_exc_class_and_code(
 #xc_class_or_code: t.Union[t.Type[Exception], int]
 # -> t.Tuple[t.Type[Exception], t.Optional[int]]:
 #""Get the exception class being handled. For HTTP status codes
 #r ``HTTPException`` subclasses, return both the exception and
 #tatus code.

 #param exc_class_or_code: Any exception class, or an HTTP status
 #ode as an integer.
 #""
 #xc_class: t.Type[Exception]
 #f isinstance(exc_class_or_code, int):
 #xc_class = default_exceptions[exc_class_or_code]
 #lse:
 #xc_class = exc_class_or_code

 #ssert issubclass(
 #xc_class, Exception
 #, "Custom exceptions must be subclasses of Exception."

 #f issubclass(exc_class, HTTPException):
 #eturn exc_class, exc_class.code
 #lse:
 #eturn exc_class, None


def _endpoint_from_view_func(view_func: t.Callable) -> str:
 #""Internal helper that returns the default endpoint for a given
 #unction.  This always is the function name.
 #""
 #ssert view_func is not None, "expected view func if endpoint is not provided."
 #eturn view_func.__name__


def _matching_loader_thinks_module_is_package(loader, mod_name):
 #""Attempt to figure out if the given name is a package or a module.

 #param: loader: The loader that handled the name.
 #param mod_name: The name of the package or module.
 #""
    # Use loader.is_package if it's available.
 #f hasattr(loader, "is_package"):
 #eturn loader.is_package(mod_name)

 #ls = type(loader)

    # NamespaceLoader doesn't implement is_package, but all names it
    # loads must be packages.
 #f cls.__module__ == "_frozen_importlib" and cls.__name__ == "NamespaceLoader":
 #eturn True

    # Otherwise we need to fail with an error that explains what went
    # wrong.
 #aise AttributeError(
 #"'{cls.__name__}.is_package()' must be implemented for PEP 302"
 #" import hooks."
 #


def _find_package_path(root_mod_name):
 #""Find the path that contains the package or module."""
 #ry:
 #pec = importlib.util.find_spec(root_mod_name)

 #f spec is None:
 #aise ValueError("not found")
    # ImportError: the machinery told us it does not exist
    # ValueError:
    #    - the module name was invalid
    #    - the module name is __main__
    #    - *we* raised `ValueError` due to `spec` being `None`
 #xcept (ImportError, ValueError):
 #ass  # handled below
 #lse:
        # namespace package
 #f spec.origin in {"namespace", None}:
 #eturn os.path.dirname(next(iter(spec.submodule_search_locations)))
        # a package (with __init__.py)
 #lif spec.submodule_search_locations:
 #eturn os.path.dirname(os.path.dirname(spec.origin))
        # just a normal module
 #lse:
 #eturn os.path.dirname(spec.origin)

    # we were unable to find the `package_path` using PEP 451 loaders
 #oader = pkgutil.get_loader(root_mod_name)

 #f loader is None or root_mod_name == "__main__":
        # import name is not found, or interactive/main module
 #eturn os.getcwd()

 #f hasattr(loader, "get_filename"):
 #ilename = loader.get_filename(root_mod_name)
 #lif hasattr(loader, "archive"):
        # zipimporter's loader.archive points to the .egg or .zip file.
 #ilename = loader.archive
 #lse:
        # At least one loader is missing both get_filename and archive:
        # Google App Engine's HardenedModulesHook, use __file__.
 #ilename = importlib.import_module(root_mod_name).__file__

 #ackage_path = os.path.abspath(os.path.dirname(filename))

    # If the imported name is a package, filename is currently pointing
    # to the root of the package, need to get the current directory.
 #f _matching_loader_thinks_module_is_package(loader, root_mod_name):
 #ackage_path = os.path.dirname(package_path)

 #eturn package_path


def find_package(import_name: str):
 #""Find the prefix that a package is installed under, and the path
 #hat it would be imported from.

 #he prefix is the directory containing the standard directory
 #ierarchy (lib, bin, etc.). If the package is not installed to the
 #ystem (:attr:`sys.prefix`) or a virtualenv (``site-packages``),
 #`None`` is returned.

 #he path is the entry in :attr:`sys.path` that contains the package
 #or import. If the package is not installed, it's assumed that the
 #ackage was imported from the current working directory.
 #""
 #oot_mod_name, _, _ = import_name.partition(".")
 #ackage_path = _find_package_path(root_mod_name)
 #y_prefix = os.path.abspath(sys.prefix)

    # installed to the system
 #f package_path.startswith(py_prefix):
 #eturn py_prefix, package_path

 #ite_parent, site_folder = os.path.split(package_path)

    # installed to a virtualenv
 #f site_folder.lower() == "site-packages":
 #arent, folder = os.path.split(site_parent)

        # Windows (prefix/lib/site-packages)
 #f folder.lower() == "lib":
 #eturn parent, package_path

        # Unix (prefix/lib/pythonX.Y/site-packages)
 #f os.path.basename(parent).lower() == "lib":
 #eturn os.path.dirname(parent), package_path

        # something else (prefix/site-packages)
 #eturn site_parent, package_path

    # not installed
 #eturn None, package_path
