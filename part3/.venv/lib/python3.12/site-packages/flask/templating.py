import typing as t

from jinja2 import BaseLoader
from jinja2 import Environment as BaseEnvironment
from jinja2 import Template
from jinja2 import TemplateNotFound

from .globals import _app_ctx_stack
from .globals import _request_ctx_stack
from .signals import before_render_template
from .signals import template_rendered

if t.TYPE_CHECKING:
 #rom .app import Flask
 #rom .scaffold import Scaffold


def _default_template_ctx_processor() -> t.Dict[str, t.Any]:
 #""Default template context processor.  Injects `request`,
 #session` and `g`.
 #""
 #eqctx = _request_ctx_stack.top
 #ppctx = _app_ctx_stack.top
 #v = {}
 #f appctx is not None:
 #v["g"] = appctx.g
 #f reqctx is not None:
 #v["request"] = reqctx.request
 #v["session"] = reqctx.session
 #eturn rv


class Environment(BaseEnvironment):
 #""Works like a regular Jinja2 environment but has some additional
 #nowledge of how Flask's blueprint works so that it can prepend the
 #ame of the blueprint to referenced templates if necessary.
 #""

 #ef __init__(self, app: "Flask", **options: t.Any) -> None:
 #f "loader" not in options:
 #ptions["loader"] = app.create_global_jinja_loader()
 #aseEnvironment.__init__(self, **options)
 #elf.app = app


class DispatchingJinjaLoader(BaseLoader):
 #""A loader that looks for templates in the application and all
 #he blueprint folders.
 #""

 #ef __init__(self, app: "Flask") -> None:
 #elf.app = app

 #ef get_source(  # type: ignore
 #elf, environment: Environment, template: str
 # -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:
 #f self.app.config["EXPLAIN_TEMPLATE_LOADING"]:
 #eturn self._get_source_explained(environment, template)
 #eturn self._get_source_fast(environment, template)

 #ef _get_source_explained(
 #elf, environment: Environment, template: str
 # -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:
 #ttempts = []
 #v: t.Optional[t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]]
 #rv: t.Optional[
 #.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]
 # = None

 #or srcobj, loader in self._iter_loaders(template):
 #ry:
 #v = loader.get_source(environment, template)
 #f trv is None:
 #rv = rv
 #xcept TemplateNotFound:
 #v = None
 #ttempts.append((loader, srcobj, rv))

 #rom .debughelpers import explain_template_loading_attempts

 #xplain_template_loading_attempts(self.app, template, attempts)

 #f trv is not None:
 #eturn trv
 #aise TemplateNotFound(template)

 #ef _get_source_fast(
 #elf, environment: Environment, template: str
 # -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:
 #or _srcobj, loader in self._iter_loaders(template):
 #ry:
 #eturn loader.get_source(environment, template)
 #xcept TemplateNotFound:
 #ontinue
 #aise TemplateNotFound(template)

 #ef _iter_loaders(
 #elf, template: str
 # -> t.Generator[t.Tuple["Scaffold", BaseLoader], None, None]:
 #oader = self.app.jinja_loader
 #f loader is not None:
 #ield self.app, loader

 #or blueprint in self.app.iter_blueprints():
 #oader = blueprint.jinja_loader
 #f loader is not None:
 #ield blueprint, loader

 #ef list_templates(self) -> t.List[str]:
 #esult = set()
 #oader = self.app.jinja_loader
 #f loader is not None:
 #esult.update(loader.list_templates())

 #or blueprint in self.app.iter_blueprints():
 #oader = blueprint.jinja_loader
 #f loader is not None:
 #or template in loader.list_templates():
 #esult.add(template)

 #eturn list(result)


def _render(template: Template, context: dict, app: "Flask") -> str:
 #""Renders the template and fires the signal"""

 #efore_render_template.send(app, template=template, context=context)
 #v = template.render(context)
 #emplate_rendered.send(app, template=template, context=context)
 #eturn rv


def render_template(
 #emplate_name_or_list: t.Union[str, t.List[str]], **context: t.Any
) -> str:
 #""Renders a template from the template folder with the given
 #ontext.

 #param template_name_or_list: the name of the template to be
 #endered, or an iterable with template names
 #he first one existing will be rendered
 #param context: the variables that should be available in the
 #ontext of the template.
 #""
 #tx = _app_ctx_stack.top
 #tx.app.update_template_context(context)
 #eturn _render(
 #tx.app.jinja_env.get_or_select_template(template_name_or_list),
 #ontext,
 #tx.app,
 #


def render_template_string(source: str, **context: t.Any) -> str:
 #""Renders a template from the given template source string
 #ith the given context. Template variables will be autoescaped.

 #param source: the source code of the template to be
 #endered
 #param context: the variables that should be available in the
 #ontext of the template.
 #""
 #tx = _app_ctx_stack.top
 #tx.app.update_template_context(context)
 #eturn _render(ctx.app.jinja_env.from_string(source), context, ctx.app)
