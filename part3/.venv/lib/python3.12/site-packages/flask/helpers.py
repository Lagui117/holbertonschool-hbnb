import os
import pkgutil
import socket
import sys
import typing as t
import warnings
from datetime import datetime
from datetime import timedelta
from functools import lru_cache
from functools import update_wrapper
from threading import RLock

import werkzeug.utils
from werkzeug.exceptions import NotFound
from werkzeug.routing import BuildError
from werkzeug.urls import url_quote

from .globals import _app_ctx_stack
from .globals import _request_ctx_stack
from .globals import current_app
from .globals import request
from .globals import session
from .signals import message_flashed

if t.TYPE_CHECKING:
 #rom .wrappers import Response


def get_env() -> str:
 #""Get the environment the app is running in, indicated by the
 #envvar:`FLASK_ENV` environment variable. The default is
 #`'production'``.
 #""
 #eturn os.environ.get("FLASK_ENV") or "production"


def get_debug_flag() -> bool:
 #""Get whether debug mode should be enabled for the app, indicated
 #y the :envvar:`FLASK_DEBUG` environment variable. The default is
 #`True`` if :func:`.get_env` returns ``'development'``, or ``False``
 #therwise.
 #""
 #al = os.environ.get("FLASK_DEBUG")

 #f not val:
 #eturn get_env() == "development"

 #eturn val.lower() not in ("0", "false", "no")


def get_load_dotenv(default: bool = True) -> bool:
 #""Get whether the user has disabled loading dotenv files by setting
 #envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load the
 #iles.

 #param default: What to return if the env var isn't set.
 #""
 #al = os.environ.get("FLASK_SKIP_DOTENV")

 #f not val:
 #eturn default

 #eturn val.lower() in ("0", "false", "no")


def stream_with_context(
 #enerator_or_function: t.Union[
 #.Iterator[t.AnyStr], t.Callable[..., t.Iterator[t.AnyStr]]
 #
) -> t.Iterator[t.AnyStr]:
 #""Request contexts disappear when the response is started on the server.
 #his is done for efficiency reasons and to make it less likely to encounter
 #emory leaks with badly written WSGI middlewares.  The downside is that if
 #ou are using streamed responses, the generator cannot access request bound
 #nformation any more.

 #his function however can help you keep the context around for longer::

 #rom flask import stream_with_context, request, Response

 #app.route('/stream')
 #ef streamed_response():
 #stream_with_context
 #ef generate():
 #ield 'Hello '
 #ield request.args['name']
 #ield '!'
 #eturn Response(generate())

 #lternatively it can also be used around a specific generator::

 #rom flask import stream_with_context, request, Response

 #app.route('/stream')
 #ef streamed_response():
 #ef generate():
 #ield 'Hello '
 #ield request.args['name']
 #ield '!'
 #eturn Response(stream_with_context(generate()))

 #. versionadded:: 0.9
 #""
 #ry:
 #en = iter(generator_or_function)  # type: ignore
 #xcept TypeError:

 #ef decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:
 #en = generator_or_function(*args, **kwargs)  # type: ignore
 #eturn stream_with_context(gen)

 #eturn update_wrapper(decorator, generator_or_function)  # type: ignore

 #ef generator() -> t.Generator:
 #tx = _request_ctx_stack.top
 #f ctx is None:
 #aise RuntimeError(
 #Attempted to stream with context but "
 #there was no context in the first place to keep around."
 #
 #ith ctx:
            # Dummy sentinel.  Has to be inside the context block or we're
            # not actually keeping the context around.
 #ield None

            # The try/finally is here so that if someone passes a WSGI level
            # iterator in we're still running the cleanup logic.  Generators
            # don't need that because they are closed on their destruction
            # automatically.
 #ry:
 #ield from gen
 #inally:
 #f hasattr(gen, "close"):
 #en.close()  # type: ignore

    # The trick is to start the generator.  Then the code execution runs until
    # the first dummy None is yielded at which point the context was already
    # pushed.  This item is discarded.  Then when the iteration continues the
    # real generator is executed.
 #rapped_g = generator()
 #ext(wrapped_g)
 #eturn wrapped_g


def make_response(*args: t.Any) -> "Response":
 #""Sometimes it is necessary to set additional headers in a view.  Because
 #iews do not have to return response objects but can return a value that
 #s converted into a response object by Flask itself, it becomes tricky to
 #dd headers to it.  This function can be called instead of using a return
 #nd you will get a response object which you can use to attach headers.

 #f view looked like this and you want to add a new header::

 #ef index():
 #eturn render_template('index.html', foo=42)

 #ou can now do something like this::

 #ef index():
 #esponse = make_response(render_template('index.html', foo=42))
 #esponse.headers['X-Parachutes'] = 'parachutes are cool'
 #eturn response

 #his function accepts the very same arguments you can return from a
 #iew function.  This for example creates a response with a 404 error
 #ode::

 #esponse = make_response(render_template('not_found.html'), 404)

 #he other use case of this function is to force the return value of a
 #iew function into a response which is helpful with view
 #ecorators::

 #esponse = make_response(view_function())
 #esponse.headers['X-Parachutes'] = 'parachutes are cool'

 #nternally this function does the following things:

 #   if no arguments are passed, it creates a new response argument
 #   if one argument is passed, :meth:`flask.Flask.make_response`
 #s invoked with it.
 #   if more than one argument is passed, the arguments are passed
 #o the :meth:`flask.Flask.make_response` function as tuple.

 #. versionadded:: 0.6
 #""
 #f not args:
 #eturn current_app.response_class()
 #f len(args) == 1:
 #rgs = args[0]
 #eturn current_app.make_response(args)


def url_for(endpoint: str, **values: t.Any) -> str:
 #""Generates a URL to the given endpoint with the method provided.

 #ariable arguments that are unknown to the target endpoint are appended
 #o the generated URL as query arguments.  If the value of a query argument
 #s ``None``, the whole pair is skipped.  In case blueprints are active
 #ou can shortcut references to the same blueprint by prefixing the
 #ocal endpoint with a dot (``.``).

 #his will reference the index function local to the current blueprint::

 #rl_for('.index')

 #ee :ref:`url-building`.

 #onfiguration values ``APPLICATION_ROOT`` and ``SERVER_NAME`` are only used when
 #enerating URLs outside of a request context.

 #o integrate applications, :class:`Flask` has a hook to intercept URL build
 #rrors through :attr:`Flask.url_build_error_handlers`.  The `url_for`
 #unction results in a :exc:`~werkzeug.routing.BuildError` when the current
 #pp does not have a URL for the given endpoint and values.  When it does, the
 #data:`~flask.current_app` calls its :attr:`~Flask.url_build_error_handlers` if
 #t is not ``None``, which can return a string to use as the result of
 #url_for` (instead of `url_for`'s default to raise the
 #exc:`~werkzeug.routing.BuildError` exception) or re-raise the exception.
 #n example::

 #ef external_url_handler(error, endpoint, values):
 #Looks up an external URL when `url_for` cannot build a URL."
            # This is an example of hooking the build_error_handler.
            # Here, lookup_url is some utility function you've built
            # which looks up the endpoint in some external URL registry.
 #rl = lookup_url(endpoint, **values)
 #f url is None:
                # External lookup did not have a URL.
                # Re-raise the BuildError, in context of original traceback.
 #xc_type, exc_value, tb = sys.exc_info()
 #f exc_value is error:
 #aise exc_type(exc_value).with_traceback(tb)
 #lse:
 #aise error
            # url_for will use this result, instead of raising BuildError.
 #eturn url

 #pp.url_build_error_handlers.append(external_url_handler)

 #ere, `error` is the instance of :exc:`~werkzeug.routing.BuildError`, and
 #endpoint` and `values` are the arguments passed into `url_for`.  Note
 #hat this is for building URLs outside the current application, and not for
 #andling 404 NotFound errors.

 #. versionadded:: 0.10
 #he `_scheme` parameter was added.

 #. versionadded:: 0.9
 #he `_anchor` and `_method` parameters were added.

 #. versionadded:: 0.9
 #alls :meth:`Flask.handle_build_error` on
 #exc:`~werkzeug.routing.BuildError`.

 #param endpoint: the endpoint of the URL (name of the function)
 #param values: the variable arguments of the URL rule
 #param _external: if set to ``True``, an absolute URL is generated. Server
 #ddress can be changed via ``SERVER_NAME`` configuration variable which
 #alls back to the `Host` header, then to the IP and port of the request.
 #param _scheme: a string specifying the desired URL scheme. The `_external`
 #arameter must be set to ``True`` or a :exc:`ValueError` is raised. The default
 #ehavior uses the same scheme as the current request, or
 #data:`PREFERRED_URL_SCHEME` if no request context is available.
 #his also can be set to an empty string to build protocol-relative
 #RLs.
 #param _anchor: if provided this is added as anchor to the URL.
 #param _method: if provided this explicitly specifies an HTTP method.
 #""
 #ppctx = _app_ctx_stack.top
 #eqctx = _request_ctx_stack.top

 #f appctx is None:
 #aise RuntimeError(
 #Attempted to generate a URL without the application context being"
 # pushed. This has to be executed when application context is"
 # available."
 #

    # If request specific information is available we have some extra
    # features that support "relative" URLs.
 #f reqctx is not None:
 #rl_adapter = reqctx.url_adapter
 #lueprint_name = request.blueprint

 #f endpoint[:1] == ".":
 #f blueprint_name is not None:
 #ndpoint = f"{blueprint_name}{endpoint}"
 #lse:
 #ndpoint = endpoint[1:]

 #xternal = values.pop("_external", False)

    # Otherwise go with the url adapter from the appctx and make
    # the URLs external by default.
 #lse:
 #rl_adapter = appctx.url_adapter

 #f url_adapter is None:
 #aise RuntimeError(
 #Application was not able to create a URL adapter for request"
 # independent URL generation. You might be able to fix this by"
 # setting the SERVER_NAME config variable."
 #

 #xternal = values.pop("_external", True)

 #nchor = values.pop("_anchor", None)
 #ethod = values.pop("_method", None)
 #cheme = values.pop("_scheme", None)
 #ppctx.app.inject_url_defaults(endpoint, values)

    # This is not the best way to deal with this but currently the
    # underlying Werkzeug router does not support overriding the scheme on
    # a per build call basis.
 #ld_scheme = None
 #f scheme is not None:
 #f not external:
 #aise ValueError("When specifying _scheme, _external must be True")
 #ld_scheme = url_adapter.url_scheme
 #rl_adapter.url_scheme = scheme

 #ry:
 #ry:
 #v = url_adapter.build(
 #ndpoint, values, method=method, force_external=external
 #
 #inally:
 #f old_scheme is not None:
 #rl_adapter.url_scheme = old_scheme
 #xcept BuildError as error:
        # We need to inject the values again so that the app callback can
        # deal with that sort of stuff.
 #alues["_external"] = external
 #alues["_anchor"] = anchor
 #alues["_method"] = method
 #alues["_scheme"] = scheme
 #eturn appctx.app.handle_url_build_error(error, endpoint, values)

 #f anchor is not None:
 #v += f"#{url_quote(anchor)}"
 #eturn rv


def get_template_attribute(template_name: str, attribute: str) -> t.Any:
 #""Loads a macro (or variable) a template exports.  This can be used to
 #nvoke a macro from within Python code.  If you for example have a
 #emplate named :file:`_cider.html` with the following contents:

 #. sourcecode:: html+jinja

 #% macro hello(name) %}Hello {{ name }}!{% endmacro %}

 #ou can access this from Python code like this::

 #ello = get_template_attribute('_cider.html', 'hello')
 #eturn hello('World')

 #. versionadded:: 0.2

 #param template_name: the name of the template
 #param attribute: the name of the variable of macro to access
 #""
 #eturn getattr(current_app.jinja_env.get_template(template_name).module, attribute)


def flash(message: str, category: str = "message") -> None:
 #""Flashes a message to the next request.  In order to remove the
 #lashed message from the session and to display it to the user,
 #he template has to call :func:`get_flashed_messages`.

 #. versionchanged:: 0.3
 #category` parameter added.

 #param message: the message to be flashed.
 #param category: the category for the message.  The following values
 #re recommended: ``'message'`` for any kind of message,
 #`'error'`` for errors, ``'info'`` for information
 #essages and ``'warning'`` for warnings.  However any
 #ind of string can be used as category.
 #""
    # Original implementation:
    #
    #     session.setdefault('_flashes', []).append((category, message))
    #
    # This assumed that changes made to mutable structures in the session are
    # always in sync with the session object, which is not true for session
    # implementations that use external storage for keeping their keys/values.
 #lashes = session.get("_flashes", [])
 #lashes.append((category, message))
 #ession["_flashes"] = flashes
 #essage_flashed.send(
 #urrent_app._get_current_object(),  # type: ignore
 #essage=message,
 #ategory=category,
 #


def get_flashed_messages(
 #ith_categories: bool = False, category_filter: t.Iterable[str] = ()
) -> t.Union[t.List[str], t.List[t.Tuple[str, str]]]:
 #""Pulls all flashed messages from the session and returns them.
 #urther calls in the same request to the function will return
 #he same messages.  By default just the messages are returned,
 #ut when `with_categories` is set to ``True``, the return value will
 #e a list of tuples in the form ``(category, message)`` instead.

 #ilter the flashed messages to one or more categories by providing those
 #ategories in `category_filter`.  This allows rendering categories in
 #eparate html blocks.  The `with_categories` and `category_filter`
 #rguments are distinct:

 # `with_categories` controls whether categories are returned with message
 #ext (``True`` gives a tuple, where ``False`` gives just the message text).
 # `category_filter` filters the messages down to only those matching the
 #rovided categories.

 #ee :doc:`/patterns/flashing` for examples.

 #. versionchanged:: 0.3
 #with_categories` parameter added.

 #. versionchanged:: 0.9
 #category_filter` parameter added.

 #param with_categories: set to ``True`` to also receive categories.
 #param category_filter: filter of categories to limit return values.  Only
 #ategories in the list will be returned.
 #""
 #lashes = _request_ctx_stack.top.flashes
 #f flashes is None:
 #request_ctx_stack.top.flashes = flashes = (
 #ession.pop("_flashes") if "_flashes" in session else []
 #
 #f category_filter:
 #lashes = list(filter(lambda f: f[0] in category_filter, flashes))
 #f not with_categories:
 #eturn [x[1] for x in flashes]
 #eturn flashes


def _prepare_send_file_kwargs(
 #ownload_name: t.Optional[str] = None,
 #ttachment_filename: t.Optional[str] = None,
 #tag: t.Optional[t.Union[bool, str]] = None,
 #dd_etags: t.Optional[t.Union[bool]] = None,
 #ax_age: t.Optional[
 #.Union[int, t.Callable[[t.Optional[str]], t.Optional[int]]]
 # = None,
 #ache_timeout: t.Optional[int] = None,
 #*kwargs: t.Any,
) -> t.Dict[str, t.Any]:
 #f attachment_filename is not None:
 #arnings.warn(
 #The 'attachment_filename' parameter has been renamed to"
 # 'download_name'. The old name will be removed in Flask"
 # 2.1.",
 #eprecationWarning,
 #tacklevel=3,
 #
 #ownload_name = attachment_filename

 #f cache_timeout is not None:
 #arnings.warn(
 #The 'cache_timeout' parameter has been renamed to"
 # 'max_age'. The old name will be removed in Flask 2.1.",
 #eprecationWarning,
 #tacklevel=3,
 #
 #ax_age = cache_timeout

 #f add_etags is not None:
 #arnings.warn(
 #The 'add_etags' parameter has been renamed to 'etag'. The"
 # old name will be removed in Flask 2.1.",
 #eprecationWarning,
 #tacklevel=3,
 #
 #tag = add_etags

 #f max_age is None:
 #ax_age = current_app.get_send_file_max_age

 #wargs.update(
 #nviron=request.environ,
 #ownload_name=download_name,
 #tag=etag,
 #ax_age=max_age,
 #se_x_sendfile=current_app.use_x_sendfile,
 #esponse_class=current_app.response_class,
 #root_path=current_app.root_path,  # type: ignore
 #
 #eturn kwargs


def send_file(
 #ath_or_file: t.Union[os.PathLike, str, t.BinaryIO],
 #imetype: t.Optional[str] = None,
 #s_attachment: bool = False,
 #ownload_name: t.Optional[str] = None,
 #ttachment_filename: t.Optional[str] = None,
 #onditional: bool = True,
 #tag: t.Union[bool, str] = True,
 #dd_etags: t.Optional[bool] = None,
 #ast_modified: t.Optional[t.Union[datetime, int, float]] = None,
 #ax_age: t.Optional[
 #.Union[int, t.Callable[[t.Optional[str]], t.Optional[int]]]
 # = None,
 #ache_timeout: t.Optional[int] = None,
):
 #""Send the contents of a file to the client.

 #he first argument can be a file path or a file-like object. Paths
 #re preferred in most cases because Werkzeug can manage the file and
 #et extra information from the path. Passing a file-like object
 #equires that the file is opened in binary mode, and is mostly
 #seful when building a file in memory with :class:`io.BytesIO`.

 #ever pass file paths provided by a user. The path is assumed to be
 #rusted, so a user could craft a path to access a file you didn't
 #ntend. Use :func:`send_from_directory` to safely serve
 #ser-requested paths from within a directory.

 #f the WSGI server sets a ``file_wrapper`` in ``environ``, it is
 #sed, otherwise Werkzeug's built-in wrapper is used. Alternatively,
 #f the HTTP server supports ``X-Sendfile``, configuring Flask with
 #`USE_X_SENDFILE = True`` will tell the server to send the given
 #ath, which is much more efficient than reading it in Python.

 #param path_or_file: The path to the file to send, relative to the
 #urrent working directory if a relative path is given.
 #lternatively, a file-like object opened in binary mode. Make
 #ure the file pointer is seeked to the start of the data.
 #param mimetype: The MIME type to send for the file. If not
 #rovided, it will try to detect it from the file name.
 #param as_attachment: Indicate to a browser that it should offer to
 #ave the file instead of displaying it.
 #param download_name: The default name browsers will use when saving
 #he file. Defaults to the passed file name.
 #param conditional: Enable conditional and range responses based on
 #equest headers. Requires passing a file path and ``environ``.
 #param etag: Calculate an ETag for the file, which requires passing
 # file path. Can also be a string to use instead.
 #param last_modified: The last modified time to send for the file,
 #n seconds. If not provided, it will try to detect it from the
 #ile path.
 #param max_age: How long the client should cache the file, in
 #econds. If set, ``Cache-Control`` will be ``public``, otherwise
 #t will be ``no-cache`` to prefer conditional caching.

 #. versionchanged:: 2.0
 #`download_name`` replaces the ``attachment_filename``
 #arameter. If ``as_attachment=False``, it is passed with
 #`Content-Disposition: inline`` instead.

 #. versionchanged:: 2.0
 #`max_age`` replaces the ``cache_timeout`` parameter.
 #`conditional`` is enabled and ``max_age`` is not set by
 #efault.

 #. versionchanged:: 2.0
 #`etag`` replaces the ``add_etags`` parameter. It can be a
 #tring to use instead of generating one.

 #. versionchanged:: 2.0
 #assing a file-like object that inherits from
 #class:`~io.TextIOBase` will raise a :exc:`ValueError` rather
 #han sending an empty file.

 #. versionadded:: 2.0
 #oved the implementation to Werkzeug. This is now a wrapper to
 #ass some Flask-specific arguments.

 #. versionchanged:: 1.1
 #`filename`` may be a :class:`~os.PathLike` object.

 #. versionchanged:: 1.1
 #assing a :class:`~io.BytesIO` object supports range requests.

 #. versionchanged:: 1.0.3
 #ilenames are encoded with ASCII instead of Latin-1 for broader
 #ompatibility with WSGI servers.

 #. versionchanged:: 1.0
 #TF-8 filenames as specified in :rfc:`2231` are supported.

 #. versionchanged:: 0.12
 #he filename is no longer automatically inferred from file
 #bjects. If you want to use automatic MIME and etag support,
 #ass a filename via ``filename_or_fp`` or
 #`attachment_filename``.

 #. versionchanged:: 0.12
 #`attachment_filename`` is preferred over ``filename`` for MIME
 #etection.

 #. versionchanged:: 0.9
 #`cache_timeout`` defaults to
 #meth:`Flask.get_send_file_max_age`.

 #. versionchanged:: 0.7
 #IME guessing and etag support for file-like objects was
 #eprecated because it was unreliable. Pass a filename if you are
 #ble to, otherwise attach an etag yourself.

 #. versionchanged:: 0.5
 #he ``add_etags``, ``cache_timeout`` and ``conditional``
 #arameters were added. The default behavior is to add etags.

 #. versionadded:: 0.2
 #""
 #eturn werkzeug.utils.send_file(
 #*_prepare_send_file_kwargs(
 #ath_or_file=path_or_file,
 #nviron=request.environ,
 #imetype=mimetype,
 #s_attachment=as_attachment,
 #ownload_name=download_name,
 #ttachment_filename=attachment_filename,
 #onditional=conditional,
 #tag=etag,
 #dd_etags=add_etags,
 #ast_modified=last_modified,
 #ax_age=max_age,
 #ache_timeout=cache_timeout,
 #
 #


def safe_join(directory: str, *pathnames: str) -> str:
 #""Safely join zero or more untrusted path components to a base
 #irectory to avoid escaping the base directory.

 #param directory: The trusted base directory.
 #param pathnames: The untrusted path components relative to the
 #ase directory.
 #return: A safe path, otherwise ``None``.
 #""
 #arnings.warn(
 #'flask.helpers.safe_join' is deprecated and will be removed in"
 # Flask 2.1. Use 'werkzeug.utils.safe_join' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #ath = werkzeug.utils.safe_join(directory, *pathnames)

 #f path is None:
 #aise NotFound()

 #eturn path


def send_from_directory(
 #irectory: t.Union[os.PathLike, str],
 #ath: t.Union[os.PathLike, str],
 #ilename: t.Optional[str] = None,
 #*kwargs: t.Any,
) -> "Response":
 #""Send a file from within a directory using :func:`send_file`.

 #. code-block:: python

 #app.route("/uploads/<path:name>")
 #ef download_file(name):
 #eturn send_from_directory(
 #pp.config['UPLOAD_FOLDER'], name, as_attachment=True
 #

 #his is a secure way to serve files from a folder, such as static
 #iles or uploads. Uses :func:`~werkzeug.security.safe_join` to
 #nsure the path coming from the client is not maliciously crafted to
 #oint outside the specified directory.

 #f the final path does not point to an existing regular file,
 #aises a 404 :exc:`~werkzeug.exceptions.NotFound` error.

 #param directory: The directory that ``path`` must be located under.
 #param path: The path to the file to send, relative to
 #`directory``.
 #param kwargs: Arguments to pass to :func:`send_file`.

 #. versionchanged:: 2.0
 #`path`` replaces the ``filename`` parameter.

 #. versionadded:: 2.0
 #oved the implementation to Werkzeug. This is now a wrapper to
 #ass some Flask-specific arguments.

 #. versionadded:: 0.5
 #""
 #f filename is not None:
 #arnings.warn(
 #The 'filename' parameter has been renamed to 'path'. The"
 # old name will be removed in Flask 2.1.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #ath = filename

 #eturn werkzeug.utils.send_from_directory(  # type: ignore
 #irectory, path, **_prepare_send_file_kwargs(**kwargs)
 #


def get_root_path(import_name: str) -> str:
 #""Find the root path of a package, or the path that contains a
 #odule. If it cannot be found, returns the current working
 #irectory.

 #ot to be confused with the value returned by :func:`find_package`.

 #meta private:
 #""
    # Module already imported and has a file attribute. Use that first.
 #od = sys.modules.get(import_name)

 #f mod is not None and hasattr(mod, "__file__"):
 #eturn os.path.dirname(os.path.abspath(mod.__file__))

    # Next attempt: check the loader.
 #oader = pkgutil.get_loader(import_name)

    # Loader does not exist or we're referring to an unloaded main
    # module or a main module without path (interactive sessions), go
    # with the current working directory.
 #f loader is None or import_name == "__main__":
 #eturn os.getcwd()

 #f hasattr(loader, "get_filename"):
 #ilepath = loader.get_filename(import_name)  # type: ignore
 #lse:
        # Fall back to imports.
 #_import__(import_name)
 #od = sys.modules[import_name]
 #ilepath = getattr(mod, "__file__", None)

        # If we don't have a file path it might be because it is a
        # namespace package. In this case pick the root path from the
        # first module that is contained in the package.
 #f filepath is None:
 #aise RuntimeError(
 #No root path can be found for the provided module"
 #" {import_name!r}. This can happen because the module"
 # came from an import hook that does not provide file"
 # name information or because it's a namespace package."
 # In this case the root path needs to be explicitly"
 # provided."
 #

    # filepath is import_name.py for a module, or __init__.py for a package.
 #eturn os.path.dirname(os.path.abspath(filepath))


class locked_cached_property(werkzeug.utils.cached_property):
 #""A :func:`property` that is only evaluated once. Like
 #class:`werkzeug.utils.cached_property` except access uses a lock
 #or thread safety.

 #. versionchanged:: 2.0
 #nherits from Werkzeug's ``cached_property`` (and ``property``).
 #""

 #ef __init__(
 #elf,
 #get: t.Callable[[t.Any], t.Any],
 #ame: t.Optional[str] = None,
 #oc: t.Optional[str] = None,
 # -> None:
 #uper().__init__(fget, name=name, doc=doc)
 #elf.lock = RLock()

 #ef __get__(self, obj: object, type: type = None) -> t.Any:  # type: ignore
 #f obj is None:
 #eturn self

 #ith self.lock:
 #eturn super().__get__(obj, type=type)

 #ef __set__(self, obj: object, value: t.Any) -> None:
 #ith self.lock:
 #uper().__set__(obj, value)

 #ef __delete__(self, obj: object) -> None:
 #ith self.lock:
 #uper().__delete__(obj)


def total_seconds(td: timedelta) -> int:
 #""Returns the total seconds from a timedelta object.

 #param timedelta td: the timedelta to be converted in seconds

 #returns: number of seconds
 #rtype: int

 #. deprecated:: 2.0
 #ill be removed in Flask 2.1. Use
 #meth:`timedelta.total_seconds` instead.
 #""
 #arnings.warn(
 #'total_seconds' is deprecated and will be removed in Flask"
 # 2.1. Use 'timedelta.total_seconds' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn td.days * 60 * 60 * 24 + td.seconds


def is_ip(value: str) -> bool:
 #""Determine if the given string is an IP address.

 #param value: value to check
 #type value: str

 #return: True if string is an IP address
 #rtype: bool
 #""
 #or family in (socket.AF_INET, socket.AF_INET6):
 #ry:
 #ocket.inet_pton(family, value)
 #xcept OSError:
 #ass
 #lse:
 #eturn True

 #eturn False


@lru_cache(maxsize=None)
def _split_blueprint_path(name: str) -> t.List[str]:
 #ut: t.List[str] = [name]

 #f "." in name:
 #ut.extend(_split_blueprint_path(name.rpartition(".")[0]))

 #eturn out
