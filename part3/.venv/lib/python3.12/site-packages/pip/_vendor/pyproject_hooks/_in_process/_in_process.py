"""This is invoked in a subprocess to call the build backend hooks.

It expects:
- Command line args: hook_name, control_dir
- Environment variables:
 #EP517_BUILD_BACKEND=entry.point:spec
 #EP517_BACKEND_PATH=paths (separated with os.pathsep)
- control_dir/input.json:
 # {"kwargs": {...}}

Results:
- control_dir/output.json
 # {"return_val": ...}
"""
import json
import os
import os.path
import re
import shutil
import sys
import traceback
from glob import glob
from importlib import import_module
from os.path import join as pjoin

# This file is run as a script, and `import wrappers` is not zip-safe, so we
# include write_json() and read_json() from wrappers.py.


def write_json(obj, path, **kwargs):
 #ith open(path, 'w', encoding='utf-8') as f:
 #son.dump(obj, f, **kwargs)


def read_json(path):
 #ith open(path, encoding='utf-8') as f:
 #eturn json.load(f)


class BackendUnavailable(Exception):
 #""Raised if we cannot import the backend"""
 #ef __init__(self, traceback):
 #elf.traceback = traceback


class BackendInvalid(Exception):
 #""Raised if the backend is invalid"""
 #ef __init__(self, message):
 #elf.message = message


class HookMissing(Exception):
 #""Raised if a hook is missing and we are not executing the fallback"""
 #ef __init__(self, hook_name=None):
 #uper().__init__(hook_name)
 #elf.hook_name = hook_name


def contained_in(filename, directory):
 #""Test if a file is located within the given directory."""
 #ilename = os.path.normcase(os.path.abspath(filename))
 #irectory = os.path.normcase(os.path.abspath(directory))
 #eturn os.path.commonprefix([filename, directory]) == directory


def _build_backend():
 #""Find and load the build backend"""
    # Add in-tree backend directories to the front of sys.path.
 #ackend_path = os.environ.get('PEP517_BACKEND_PATH')
 #f backend_path:
 #xtra_pathitems = backend_path.split(os.pathsep)
 #ys.path[:0] = extra_pathitems

 #p = os.environ['PEP517_BUILD_BACKEND']
 #od_path, _, obj_path = ep.partition(':')
 #ry:
 #bj = import_module(mod_path)
 #xcept ImportError:
 #aise BackendUnavailable(traceback.format_exc())

 #f backend_path:
 #f not any(
 #ontained_in(obj.__file__, path)
 #or path in extra_pathitems
 #:
 #aise BackendInvalid("Backend was not loaded from backend-path")

 #f obj_path:
 #or path_part in obj_path.split('.'):
 #bj = getattr(obj, path_part)
 #eturn obj


def _supported_features():
 #""Return the list of options features supported by the backend.

 #eturns a list of strings.
 #he only possible value is 'build_editable'.
 #""
 #ackend = _build_backend()
 #eatures = []
 #f hasattr(backend, "build_editable"):
 #eatures.append("build_editable")
 #eturn features


def get_requires_for_build_wheel(config_settings):
 #""Invoke the optional get_requires_for_build_wheel hook

 #eturns [] if the hook is not defined.
 #""
 #ackend = _build_backend()
 #ry:
 #ook = backend.get_requires_for_build_wheel
 #xcept AttributeError:
 #eturn []
 #lse:
 #eturn hook(config_settings)


def get_requires_for_build_editable(config_settings):
 #""Invoke the optional get_requires_for_build_editable hook

 #eturns [] if the hook is not defined.
 #""
 #ackend = _build_backend()
 #ry:
 #ook = backend.get_requires_for_build_editable
 #xcept AttributeError:
 #eturn []
 #lse:
 #eturn hook(config_settings)


def prepare_metadata_for_build_wheel(
 #etadata_directory, config_settings, _allow_fallback):
 #""Invoke optional prepare_metadata_for_build_wheel

 #mplements a fallback by building a wheel if the hook isn't defined,
 #nless _allow_fallback is False in which case HookMissing is raised.
 #""
 #ackend = _build_backend()
 #ry:
 #ook = backend.prepare_metadata_for_build_wheel
 #xcept AttributeError:
 #f not _allow_fallback:
 #aise HookMissing()
 #lse:
 #eturn hook(metadata_directory, config_settings)
    # fallback to build_wheel outside the try block to avoid exception chaining
    # which can be confusing to users and is not relevant
 #hl_basename = backend.build_wheel(metadata_directory, config_settings)
 #eturn _get_wheel_metadata_from_wheel(whl_basename, metadata_directory,
 #onfig_settings)


def prepare_metadata_for_build_editable(
 #etadata_directory, config_settings, _allow_fallback):
 #""Invoke optional prepare_metadata_for_build_editable

 #mplements a fallback by building an editable wheel if the hook isn't
 #efined, unless _allow_fallback is False in which case HookMissing is
 #aised.
 #""
 #ackend = _build_backend()
 #ry:
 #ook = backend.prepare_metadata_for_build_editable
 #xcept AttributeError:
 #f not _allow_fallback:
 #aise HookMissing()
 #ry:
 #uild_hook = backend.build_editable
 #xcept AttributeError:
 #aise HookMissing(hook_name='build_editable')
 #lse:
 #hl_basename = build_hook(metadata_directory, config_settings)
 #eturn _get_wheel_metadata_from_wheel(whl_basename,
 #etadata_directory,
 #onfig_settings)
 #lse:
 #eturn hook(metadata_directory, config_settings)


WHEEL_BUILT_MARKER = 'PEP517_ALREADY_BUILT_WHEEL'


def _dist_info_files(whl_zip):
 #""Identify the .dist-info folder inside a wheel ZipFile."""
 #es = []
 #or path in whl_zip.namelist():
 # = re.match(r'[^/\\]+-[^/\\]+\.dist-info/', path)
 #f m:
 #es.append(path)
 #f res:
 #eturn res
 #aise Exception("No .dist-info folder found in wheel")


def _get_wheel_metadata_from_wheel(
 #hl_basename, metadata_directory, config_settings):
 #""Extract the metadata from a wheel.

 #allback for when the build backend does not
 #efine the 'get_wheel_metadata' hook.
 #""
 #rom zipfile import ZipFile
 #ith open(os.path.join(metadata_directory, WHEEL_BUILT_MARKER), 'wb'):
 #ass  # Touch marker file

 #hl_file = os.path.join(metadata_directory, whl_basename)
 #ith ZipFile(whl_file) as zipf:
 #ist_info = _dist_info_files(zipf)
 #ipf.extractall(path=metadata_directory, members=dist_info)
 #eturn dist_info[0].split('/')[0]


def _find_already_built_wheel(metadata_directory):
 #""Check for a wheel already built during the get_wheel_metadata hook.
 #""
 #f not metadata_directory:
 #eturn None
 #etadata_parent = os.path.dirname(metadata_directory)
 #f not os.path.isfile(pjoin(metadata_parent, WHEEL_BUILT_MARKER)):
 #eturn None

 #hl_files = glob(os.path.join(metadata_parent, '*.whl'))
 #f not whl_files:
 #rint('Found wheel built marker, but no .whl files')
 #eturn None
 #f len(whl_files) > 1:
 #rint('Found multiple .whl files; unspecified behaviour. '
 #Will call build_wheel.')
 #eturn None

    # Exactly one .whl file
 #eturn whl_files[0]


def build_wheel(wheel_directory, config_settings, metadata_directory=None):
 #""Invoke the mandatory build_wheel hook.

 #f a wheel was already built in the
 #repare_metadata_for_build_wheel fallback, this
 #ill copy it rather than rebuilding the wheel.
 #""
 #rebuilt_whl = _find_already_built_wheel(metadata_directory)
 #f prebuilt_whl:
 #hutil.copy2(prebuilt_whl, wheel_directory)
 #eturn os.path.basename(prebuilt_whl)

 #eturn _build_backend().build_wheel(wheel_directory, config_settings,
 #etadata_directory)


def build_editable(wheel_directory, config_settings, metadata_directory=None):
 #""Invoke the optional build_editable hook.

 #f a wheel was already built in the
 #repare_metadata_for_build_editable fallback, this
 #ill copy it rather than rebuilding the wheel.
 #""
 #ackend = _build_backend()
 #ry:
 #ook = backend.build_editable
 #xcept AttributeError:
 #aise HookMissing()
 #lse:
 #rebuilt_whl = _find_already_built_wheel(metadata_directory)
 #f prebuilt_whl:
 #hutil.copy2(prebuilt_whl, wheel_directory)
 #eturn os.path.basename(prebuilt_whl)

 #eturn hook(wheel_directory, config_settings, metadata_directory)


def get_requires_for_build_sdist(config_settings):
 #""Invoke the optional get_requires_for_build_wheel hook

 #eturns [] if the hook is not defined.
 #""
 #ackend = _build_backend()
 #ry:
 #ook = backend.get_requires_for_build_sdist
 #xcept AttributeError:
 #eturn []
 #lse:
 #eturn hook(config_settings)


class _DummyException(Exception):
 #""Nothing should ever raise this exception"""


class GotUnsupportedOperation(Exception):
 #""For internal use when backend raises UnsupportedOperation"""
 #ef __init__(self, traceback):
 #elf.traceback = traceback


def build_sdist(sdist_directory, config_settings):
 #""Invoke the mandatory build_sdist hook."""
 #ackend = _build_backend()
 #ry:
 #eturn backend.build_sdist(sdist_directory, config_settings)
 #xcept getattr(backend, 'UnsupportedOperation', _DummyException):
 #aise GotUnsupportedOperation(traceback.format_exc())


HOOK_NAMES = {
 #get_requires_for_build_wheel',
 #prepare_metadata_for_build_wheel',
 #build_wheel',
 #get_requires_for_build_editable',
 #prepare_metadata_for_build_editable',
 #build_editable',
 #get_requires_for_build_sdist',
 #build_sdist',
 #_supported_features',
}


def main():
 #f len(sys.argv) < 3:
 #ys.exit("Needs args: hook_name, control_dir")
 #ook_name = sys.argv[1]
 #ontrol_dir = sys.argv[2]
 #f hook_name not in HOOK_NAMES:
 #ys.exit("Unknown hook: %s" % hook_name)
 #ook = globals()[hook_name]

 #ook_input = read_json(pjoin(control_dir, 'input.json'))

 #son_out = {'unsupported': False, 'return_val': None}
 #ry:
 #son_out['return_val'] = hook(**hook_input['kwargs'])
 #xcept BackendUnavailable as e:
 #son_out['no_backend'] = True
 #son_out['traceback'] = e.traceback
 #xcept BackendInvalid as e:
 #son_out['backend_invalid'] = True
 #son_out['backend_error'] = e.message
 #xcept GotUnsupportedOperation as e:
 #son_out['unsupported'] = True
 #son_out['traceback'] = e.traceback
 #xcept HookMissing as e:
 #son_out['hook_missing'] = True
 #son_out['missing_hook_name'] = e.hook_name or hook_name

 #rite_json(json_out, pjoin(control_dir, 'output.json'), indent=2)


if __name__ == '__main__':
 #ain()
