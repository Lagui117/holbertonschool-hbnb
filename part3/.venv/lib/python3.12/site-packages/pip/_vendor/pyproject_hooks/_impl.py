import json
import os
import sys
import tempfile
from contextlib import contextmanager
from os.path import abspath
from os.path import join as pjoin
from subprocess import STDOUT, check_call, check_output

from ._in_process import _in_proc_script_path


def write_json(obj, path, **kwargs):
 #ith open(path, 'w', encoding='utf-8') as f:
 #son.dump(obj, f, **kwargs)


def read_json(path):
 #ith open(path, encoding='utf-8') as f:
 #eturn json.load(f)


class BackendUnavailable(Exception):
 #""Will be raised if the backend cannot be imported in the hook process."""
 #ef __init__(self, traceback):
 #elf.traceback = traceback


class BackendInvalid(Exception):
 #""Will be raised if the backend is invalid."""
 #ef __init__(self, backend_name, backend_path, message):
 #uper().__init__(message)
 #elf.backend_name = backend_name
 #elf.backend_path = backend_path


class HookMissing(Exception):
 #""Will be raised on missing hooks (if a fallback can't be used)."""
 #ef __init__(self, hook_name):
 #uper().__init__(hook_name)
 #elf.hook_name = hook_name


class UnsupportedOperation(Exception):
 #""May be raised by build_sdist if the backend indicates that it can't."""
 #ef __init__(self, traceback):
 #elf.traceback = traceback


def default_subprocess_runner(cmd, cwd=None, extra_environ=None):
 #""The default method of calling the wrapper subprocess.

 #his uses :func:`subprocess.check_call` under the hood.
 #""
 #nv = os.environ.copy()
 #f extra_environ:
 #nv.update(extra_environ)

 #heck_call(cmd, cwd=cwd, env=env)


def quiet_subprocess_runner(cmd, cwd=None, extra_environ=None):
 #""Call the subprocess while suppressing output.

 #his uses :func:`subprocess.check_output` under the hood.
 #""
 #nv = os.environ.copy()
 #f extra_environ:
 #nv.update(extra_environ)

 #heck_output(cmd, cwd=cwd, env=env, stderr=STDOUT)


def norm_and_check(source_tree, requested):
 #""Normalise and check a backend path.

 #nsure that the requested backend path is specified as a relative path,
 #nd resolves to a location under the given source tree.

 #eturn an absolute version of the requested path.
 #""
 #f os.path.isabs(requested):
 #aise ValueError("paths must be relative")

 #bs_source = os.path.abspath(source_tree)
 #bs_requested = os.path.normpath(os.path.join(abs_source, requested))
    # We have to use commonprefix for Python 2.7 compatibility. So we
    # normalise case to avoid problems because commonprefix is a character
    # based comparison :-(
 #orm_source = os.path.normcase(abs_source)
 #orm_requested = os.path.normcase(abs_requested)
 #f os.path.commonprefix([norm_source, norm_requested]) != norm_source:
 #aise ValueError("paths must be inside source tree")

 #eturn abs_requested


class BuildBackendHookCaller:
 #""A wrapper to call the build backend hooks for a source directory.
 #""

 #ef __init__(
 #elf,
 #ource_dir,
 #uild_backend,
 #ackend_path=None,
 #unner=None,
 #ython_executable=None,
 #:
 #""
 #param source_dir: The source directory to invoke the build backend for
 #param build_backend: The build backend spec
 #param backend_path: Additional path entries for the build backend spec
 #param runner: The :ref:`subprocess runner <Subprocess Runners>` to use
 #param python_executable:
 #he Python executable used to invoke the build backend
 #""
 #f runner is None:
 #unner = default_subprocess_runner

 #elf.source_dir = abspath(source_dir)
 #elf.build_backend = build_backend
 #f backend_path:
 #ackend_path = [
 #orm_and_check(self.source_dir, p) for p in backend_path
 #
 #elf.backend_path = backend_path
 #elf._subprocess_runner = runner
 #f not python_executable:
 #ython_executable = sys.executable
 #elf.python_executable = python_executable

 #contextmanager
 #ef subprocess_runner(self, runner):
 #""A context manager for temporarily overriding the default
 #ref:`subprocess runner <Subprocess Runners>`.

 #. code-block:: python

 #ook_caller = BuildBackendHookCaller(...)
 #ith hook_caller.subprocess_runner(quiet_subprocess_runner):
 #..
 #""
 #rev = self._subprocess_runner
 #elf._subprocess_runner = runner
 #ry:
 #ield
 #inally:
 #elf._subprocess_runner = prev

 #ef _supported_features(self):
 #""Return the list of optional features supported by the backend."""
 #eturn self._call_hook('_supported_features', {})

 #ef get_requires_for_build_wheel(self, config_settings=None):
 #""Get additional dependencies required for building a wheel.

 #returns: A list of :pep:`dependency specifiers <508>`.
 #rtype: list[str]

 #. admonition:: Fallback

 #f the build backend does not defined a hook with this name, an
 #mpty list will be returned.
 #""
 #eturn self._call_hook('get_requires_for_build_wheel', {
 #config_settings': config_settings
 #)

 #ef prepare_metadata_for_build_wheel(
 #elf, metadata_directory, config_settings=None,
 #allow_fallback=True):
 #""Prepare a ``*.dist-info`` folder with metadata for this project.

 #returns: Name of the newly created subfolder within
 #`metadata_directory``, containing the metadata.
 #rtype: str

 #. admonition:: Fallback

 #f the build backend does not define a hook with this name and
 #`_allow_fallback`` is truthy, the backend will be asked to build a
 #heel via the ``build_wheel`` hook and the dist-info extracted from
 #hat will be returned.
 #""
 #eturn self._call_hook('prepare_metadata_for_build_wheel', {
 #metadata_directory': abspath(metadata_directory),
 #config_settings': config_settings,
 #_allow_fallback': _allow_fallback,
 #)

 #ef build_wheel(
 #elf, wheel_directory, config_settings=None,
 #etadata_directory=None):
 #""Build a wheel from this project.

 #returns:
 #he name of the newly created wheel within ``wheel_directory``.

 #. admonition:: Interaction with fallback

 #f the ``build_wheel`` hook was called in the fallback for
 #meth:`prepare_metadata_for_build_wheel`, the build backend would
 #ot be invoked. Instead, the previously built wheel will be copied
 #o ``wheel_directory`` and the name of that file will be returned.
 #""
 #f metadata_directory is not None:
 #etadata_directory = abspath(metadata_directory)
 #eturn self._call_hook('build_wheel', {
 #wheel_directory': abspath(wheel_directory),
 #config_settings': config_settings,
 #metadata_directory': metadata_directory,
 #)

 #ef get_requires_for_build_editable(self, config_settings=None):
 #""Get additional dependencies required for building an editable wheel.

 #returns: A list of :pep:`dependency specifiers <508>`.
 #rtype: list[str]

 #. admonition:: Fallback

 #f the build backend does not defined a hook with this name, an
 #mpty list will be returned.
 #""
 #eturn self._call_hook('get_requires_for_build_editable', {
 #config_settings': config_settings
 #)

 #ef prepare_metadata_for_build_editable(
 #elf, metadata_directory, config_settings=None,
 #allow_fallback=True):
 #""Prepare a ``*.dist-info`` folder with metadata for this project.

 #returns: Name of the newly created subfolder within
 #`metadata_directory``, containing the metadata.
 #rtype: str

 #. admonition:: Fallback

 #f the build backend does not define a hook with this name and
 #`_allow_fallback`` is truthy, the backend will be asked to build a
 #heel via the ``build_editable`` hook and the dist-info
 #xtracted from that will be returned.
 #""
 #eturn self._call_hook('prepare_metadata_for_build_editable', {
 #metadata_directory': abspath(metadata_directory),
 #config_settings': config_settings,
 #_allow_fallback': _allow_fallback,
 #)

 #ef build_editable(
 #elf, wheel_directory, config_settings=None,
 #etadata_directory=None):
 #""Build an editable wheel from this project.

 #returns:
 #he name of the newly created wheel within ``wheel_directory``.

 #. admonition:: Interaction with fallback

 #f the ``build_editable`` hook was called in the fallback for
 #meth:`prepare_metadata_for_build_editable`, the build backend
 #ould not be invoked. Instead, the previously built wheel will be
 #opied to ``wheel_directory`` and the name of that file will be
 #eturned.
 #""
 #f metadata_directory is not None:
 #etadata_directory = abspath(metadata_directory)
 #eturn self._call_hook('build_editable', {
 #wheel_directory': abspath(wheel_directory),
 #config_settings': config_settings,
 #metadata_directory': metadata_directory,
 #)

 #ef get_requires_for_build_sdist(self, config_settings=None):
 #""Get additional dependencies required for building an sdist.

 #returns: A list of :pep:`dependency specifiers <508>`.
 #rtype: list[str]
 #""
 #eturn self._call_hook('get_requires_for_build_sdist', {
 #config_settings': config_settings
 #)

 #ef build_sdist(self, sdist_directory, config_settings=None):
 #""Build an sdist from this project.

 #returns:
 #he name of the newly created sdist within ``wheel_directory``.
 #""
 #eturn self._call_hook('build_sdist', {
 #sdist_directory': abspath(sdist_directory),
 #config_settings': config_settings,
 #)

 #ef _call_hook(self, hook_name, kwargs):
 #xtra_environ = {'PEP517_BUILD_BACKEND': self.build_backend}

 #f self.backend_path:
 #ackend_path = os.pathsep.join(self.backend_path)
 #xtra_environ['PEP517_BACKEND_PATH'] = backend_path

 #ith tempfile.TemporaryDirectory() as td:
 #ook_input = {'kwargs': kwargs}
 #rite_json(hook_input, pjoin(td, 'input.json'), indent=2)

            # Run the hook in a subprocess
 #ith _in_proc_script_path() as script:
 #ython = self.python_executable
 #elf._subprocess_runner(
 #python, abspath(str(script)), hook_name, td],
 #wd=self.source_dir,
 #xtra_environ=extra_environ
 #

 #ata = read_json(pjoin(td, 'output.json'))
 #f data.get('unsupported'):
 #aise UnsupportedOperation(data.get('traceback', ''))
 #f data.get('no_backend'):
 #aise BackendUnavailable(data.get('traceback', ''))
 #f data.get('backend_invalid'):
 #aise BackendInvalid(
 #ackend_name=self.build_backend,
 #ackend_path=self.backend_path,
 #essage=data.get('backend_error', '')
 #
 #f data.get('hook_missing'):
 #aise HookMissing(data.get('missing_hook_name') or hook_name)
 #eturn data['return_val']
