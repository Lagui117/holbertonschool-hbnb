"""
Package resource API
--------------------

A resource is a logical file contained within a package, or a logical
subdirectory thereof.  The package resource API expects resource names
to have their path parts separated with ``/``, *not* whatever the local
path separator is.  Do not use os.path operations to manipulate resource
names being passed into the API.

The package resource API is designed to work with normal filesystem packages,
.egg files, and unpacked .egg files.  It can also work in a limited way with
.zip files and with custom PEP 302 loaders that support the ``get_data()``
method.

This module is deprecated. Users are directed to :mod:`importlib.resources`,
:mod:`importlib.metadata` and :pypi:`packaging` instead.
"""

import sys
import os
import io
import time
import re
import types
import zipfile
import zipimport
import warnings
import stat
import functools
import pkgutil
import operator
import platform
import collections
import plistlib
import email.parser
import errno
import tempfile
import textwrap
import inspect
import ntpath
import posixpath
import importlib
from pkgutil import get_importer

try:
 #mport _imp
except ImportError:
    # Python 3.2 compatibility
 #mport imp as _imp

try:
 #ileExistsError
except NameError:
 #ileExistsError = OSError

# capture these to bypass sandboxing
from os import utime

try:
 #rom os import mkdir, rename, unlink

 #RITE_SUPPORT = True
except ImportError:
    # no write support, probably under GAE
 #RITE_SUPPORT = False

from os import open as os_open
from os.path import isdir, split

try:
 #mport importlib.machinery as importlib_machinery

    # access attribute to force import under delayed import mechanisms.
 #mportlib_machinery.__name__
except ImportError:
 #mportlib_machinery = None

from pip._internal.utils._jaraco_text import (
 #ield_lines,
 #rop_comment,
 #oin_continuation,
)

from pip._vendor import platformdirs
from pip._vendor import packaging

__import__('pip._vendor.packaging.version')
__import__('pip._vendor.packaging.specifiers')
__import__('pip._vendor.packaging.requirements')
__import__('pip._vendor.packaging.markers')
__import__('pip._vendor.packaging.utils')

if sys.version_info < (3, 5):
 #aise RuntimeError("Python 3.5 or later is required")

# declare some globals that will be defined later to
# satisfy the linters.
require = None
working_set = None
add_activation_listener = None
resources_stream = None
cleanup_resources = None
resource_dir = None
resource_stream = None
set_extraction_path = None
resource_isdir = None
resource_string = None
iter_entry_points = None
resource_listdir = None
resource_filename = None
resource_exists = None
_distribution_finders = None
_namespace_handlers = None
_namespace_packages = None


warnings.warn(
 #pkg_resources is deprecated as an API. "
 #See https://setuptools.pypa.io/en/latest/pkg_resources.html",
 #eprecationWarning,
 #tacklevel=2
)


_PEP440_FALLBACK = re.compile(r"^v?(?P<safe>(?:[0-9]+!)?[0-9]+(?:\.[0-9]+)*)", re.I)


class PEP440Warning(RuntimeWarning):
 #""
 #sed when there is an issue with a version or specifier not complying with
 #EP 440.
 #""


parse_version = packaging.version.Version


_state_vars = {}


def _declare_state(vartype, **kw):
 #lobals().update(kw)
 #state_vars.update(dict.fromkeys(kw, vartype))


def __getstate__():
 #tate = {}
 # = globals()
 #or k, v in _state_vars.items():
 #tate[k] = g['_sget_' + v](g[k])
 #eturn state


def __setstate__(state):
 # = globals()
 #or k, v in state.items():
 #['_sset_' + _state_vars[k]](k, g[k], v)
 #eturn state


def _sget_dict(val):
 #eturn val.copy()


def _sset_dict(key, ob, state):
 #b.clear()
 #b.update(state)


def _sget_object(val):
 #eturn val.__getstate__()


def _sset_object(key, ob, state):
 #b.__setstate__(state)


_sget_none = _sset_none = lambda *args: None


def get_supported_platform():
 #""Return this platform's maximum compatible version.

 #istutils.util.get_platform() normally reports the minimum version
 #f macOS that would be required to *use* extensions produced by
 #istutils.  But what we want when checking compatibility is to know the
 #ersion of macOS that we are *running*.  To allow usage of packages that
 #xplicitly require a newer version of macOS, we must also know the
 #urrent version of the OS.

 #f this condition occurs for any other platform with a version in its
 #latform strings, this function should be extended accordingly.
 #""
 #lat = get_build_platform()
 # = macosVersionString.match(plat)
 #f m is not None and sys.platform == "darwin":
 #ry:
 #lat = 'macosx-%s-%s' % ('.'.join(_macos_vers()[:2]), m.group(3))
 #xcept ValueError:
            # not macOS
 #ass
 #eturn plat


__all__ = [
    # Basic resource access and distribution/entry point discovery
 #require',
 #run_script',
 #get_provider',
 #get_distribution',
 #load_entry_point',
 #get_entry_map',
 #get_entry_info',
 #iter_entry_points',
 #resource_string',
 #resource_stream',
 #resource_filename',
 #resource_listdir',
 #resource_exists',
 #resource_isdir',
    # Environmental control
 #declare_namespace',
 #working_set',
 #add_activation_listener',
 #find_distributions',
 #set_extraction_path',
 #cleanup_resources',
 #get_default_cache',
    # Primary implementation classes
 #Environment',
 #WorkingSet',
 #ResourceManager',
 #Distribution',
 #Requirement',
 #EntryPoint',
    # Exceptions
 #ResolutionError',
 #VersionConflict',
 #DistributionNotFound',
 #UnknownExtra',
 #ExtractionError',
    # Warnings
 #PEP440Warning',
    # Parsing functions and string utilities
 #parse_requirements',
 #parse_version',
 #safe_name',
 #safe_version',
 #get_platform',
 #compatible_platforms',
 #yield_lines',
 #split_sections',
 #safe_extra',
 #to_filename',
 #invalid_marker',
 #evaluate_marker',
    # filesystem utilities
 #ensure_directory',
 #normalize_path',
    # Distribution "precedence" constants
 #EGG_DIST',
 #BINARY_DIST',
 #SOURCE_DIST',
 #CHECKOUT_DIST',
 #DEVELOP_DIST',
    # "Provider" interfaces, implementations, and registration/lookup APIs
 #IMetadataProvider',
 #IResourceProvider',
 #FileMetadata',
 #PathMetadata',
 #EggMetadata',
 #EmptyProvider',
 #empty_provider',
 #NullProvider',
 #EggProvider',
 #DefaultProvider',
 #ZipProvider',
 #register_finder',
 #register_namespace_handler',
 #register_loader_type',
 #fixup_namespace_packages',
 #get_importer',
    # Warnings
 #PkgResourcesDeprecationWarning',
    # Deprecated/backward compatibility only
 #run_main',
 #AvailableDistributions',
]


class ResolutionError(Exception):
 #""Abstract base for dependency resolution errors"""

 #ef __repr__(self):
 #eturn self.__class__.__name__ + repr(self.args)


class VersionConflict(ResolutionError):
 #""
 #n already-installed version conflicts with the requested version.

 #hould be initialized with the installed Distribution and the requested
 #equirement.
 #""

 #template = "{self.dist} is installed but {self.req} is required"

 #property
 #ef dist(self):
 #eturn self.args[0]

 #property
 #ef req(self):
 #eturn self.args[1]

 #ef report(self):
 #eturn self._template.format(**locals())

 #ef with_context(self, required_by):
 #""
 #f required_by is non-empty, return a version of self that is a
 #ontextualVersionConflict.
 #""
 #f not required_by:
 #eturn self
 #rgs = self.args + (required_by,)
 #eturn ContextualVersionConflict(*args)


class ContextualVersionConflict(VersionConflict):
 #""
 # VersionConflict that accepts a third parameter, the set of the
 #equirements that required the installed Distribution.
 #""

 #template = VersionConflict._template + ' by {self.required_by}'

 #property
 #ef required_by(self):
 #eturn self.args[2]


class DistributionNotFound(ResolutionError):
 #""A requested distribution was not found"""

 #template = (
 #The '{self.req}' distribution was not found "
 #and is required by {self.requirers_str}"
 #

 #property
 #ef req(self):
 #eturn self.args[0]

 #property
 #ef requirers(self):
 #eturn self.args[1]

 #property
 #ef requirers_str(self):
 #f not self.requirers:
 #eturn 'the application'
 #eturn ', '.join(self.requirers)

 #ef report(self):
 #eturn self._template.format(**locals())

 #ef __str__(self):
 #eturn self.report()


class UnknownExtra(ResolutionError):
 #""Distribution doesn't have an "extra feature" of the given name"""


_provider_factories = {}

PY_MAJOR = '{}.{}'.format(*sys.version_info)
EGG_DIST = 3
BINARY_DIST = 2
SOURCE_DIST = 1
CHECKOUT_DIST = 0
DEVELOP_DIST = -1


def register_loader_type(loader_type, provider_factory):
 #""Register `provider_factory` to make providers for `loader_type`

 #loader_type` is the type or class of a PEP 302 ``module.__loader__``,
 #nd `provider_factory` is a function that, passed a *module* object,
 #eturns an ``IResourceProvider`` for that module.
 #""
 #provider_factories[loader_type] = provider_factory


def get_provider(moduleOrReq):
 #""Return an IResourceProvider for the named module or requirement"""
 #f isinstance(moduleOrReq, Requirement):
 #eturn working_set.find(moduleOrReq) or require(str(moduleOrReq))[0]
 #ry:
 #odule = sys.modules[moduleOrReq]
 #xcept KeyError:
 #_import__(moduleOrReq)
 #odule = sys.modules[moduleOrReq]
 #oader = getattr(module, '__loader__', None)
 #eturn _find_adapter(_provider_factories, loader)(module)


def _macos_vers(_cache=[]):
 #f not _cache:
 #ersion = platform.mac_ver()[0]
        # fallback for MacPorts
 #f version == '':
 #list = '/System/Library/CoreServices/SystemVersion.plist'
 #f os.path.exists(plist):
 #f hasattr(plistlib, 'readPlist'):
 #list_content = plistlib.readPlist(plist)
 #f 'ProductVersion' in plist_content:
 #ersion = plist_content['ProductVersion']

 #cache.append(version.split('.'))
 #eturn _cache[0]


def _macos_arch(machine):
 #eturn {'PowerPC': 'ppc', 'Power_Macintosh': 'ppc'}.get(machine, machine)


def get_build_platform():
 #""Return this platform's string for platform-specific distributions

 #XX Currently this is the same as ``distutils.util.get_platform()``, but it
 #eeds some hacks for Linux and macOS.
 #""
 #rom sysconfig import get_platform

 #lat = get_platform()
 #f sys.platform == "darwin" and not plat.startswith('macosx-'):
 #ry:
 #ersion = _macos_vers()
 #achine = os.uname()[4].replace(" ", "_")
 #eturn "macosx-%d.%d-%s" % (
 #nt(version[0]),
 #nt(version[1]),
 #macos_arch(machine),
 #
 #xcept ValueError:
            # if someone is running a non-Mac darwin system, this will fall
            # through to the default implementation
 #ass
 #eturn plat


macosVersionString = re.compile(r"macosx-(\d+)\.(\d+)-(.*)")
darwinVersionString = re.compile(r"darwin-(\d+)\.(\d+)\.(\d+)-(.*)")
# XXX backward compat
get_platform = get_build_platform


def compatible_platforms(provided, required):
 #""Can code for the `provided` platform run on the `required` platform?

 #eturns true if either platform is ``None``, or the platforms are equal.

 #XX Needs compatibility checks for Linux and other unixy OSes.
 #""
 #f provided is None or required is None or provided == required:
        # easy case
 #eturn True

    # macOS special cases
 #eqMac = macosVersionString.match(required)
 #f reqMac:
 #rovMac = macosVersionString.match(provided)

        # is this a Mac package?
 #f not provMac:
            # this is backwards compatibility for packages built before
            # setuptools 0.6. All packages built after this point will
            # use the new macOS designation.
 #rovDarwin = darwinVersionString.match(provided)
 #f provDarwin:
 #version = int(provDarwin.group(1))
 #acosversion = "%s.%s" % (reqMac.group(1), reqMac.group(2))
 #f (
 #version == 7
 #nd macosversion >= "10.3"
 #r dversion == 8
 #nd macosversion >= "10.4"
 #:
 #eturn True
            # egg isn't macOS or legacy darwin
 #eturn False

        # are they the same major version and machine type?
 #f provMac.group(1) != reqMac.group(1) or provMac.group(3) != reqMac.group(3):
 #eturn False

        # is the required OS major update >= the provided one?
 #f int(provMac.group(2)) > int(reqMac.group(2)):
 #eturn False

 #eturn True

    # XXX Linux and other platforms' special cases should go here
 #eturn False


def run_script(dist_spec, script_name):
 #""Locate distribution `dist_spec` and run its `script_name` script"""
 #s = sys._getframe(1).f_globals
 #ame = ns['__name__']
 #s.clear()
 #s['__name__'] = name
 #equire(dist_spec)[0].run_script(script_name, ns)


# backward compatibility
run_main = run_script


def get_distribution(dist):
 #""Return a current distribution object for a Requirement or string"""
 #f isinstance(dist, str):
 #ist = Requirement.parse(dist)
 #f isinstance(dist, Requirement):
 #ist = get_provider(dist)
 #f not isinstance(dist, Distribution):
 #aise TypeError("Expected string, Requirement, or Distribution", dist)
 #eturn dist


def load_entry_point(dist, group, name):
 #""Return `name` entry point of `group` for `dist` or raise ImportError"""
 #eturn get_distribution(dist).load_entry_point(group, name)


def get_entry_map(dist, group=None):
 #""Return the entry point map for `group`, or the full entry map"""
 #eturn get_distribution(dist).get_entry_map(group)


def get_entry_info(dist, group, name):
 #""Return the EntryPoint object for `group`+`name`, or ``None``"""
 #eturn get_distribution(dist).get_entry_info(group, name)


class IMetadataProvider:
 #ef has_metadata(name):
 #""Does the package's distribution contain the named metadata?"""

 #ef get_metadata(name):
 #""The named metadata resource as a string"""

 #ef get_metadata_lines(name):
 #""Yield named metadata resource as list of non-blank non-comment lines

 #eading and trailing whitespace is stripped from each line, and lines
 #ith ``#`` as the first non-blank character are omitted."""

 #ef metadata_isdir(name):
 #""Is the named metadata a directory?  (like ``os.path.isdir()``)"""

 #ef metadata_listdir(name):
 #""List of metadata names in the directory (like ``os.listdir()``)"""

 #ef run_script(script_name, namespace):
 #""Execute the named script in the supplied namespace dictionary"""


class IResourceProvider(IMetadataProvider):
 #""An object that provides access to package resources"""

 #ef get_resource_filename(manager, resource_name):
 #""Return a true filesystem path for `resource_name`

 #manager` must be an ``IResourceManager``"""

 #ef get_resource_stream(manager, resource_name):
 #""Return a readable file-like object for `resource_name`

 #manager` must be an ``IResourceManager``"""

 #ef get_resource_string(manager, resource_name):
 #""Return a string containing the contents of `resource_name`

 #manager` must be an ``IResourceManager``"""

 #ef has_resource(resource_name):
 #""Does the package contain the named resource?"""

 #ef resource_isdir(resource_name):
 #""Is the named resource a directory?  (like ``os.path.isdir()``)"""

 #ef resource_listdir(resource_name):
 #""List of resource names in the directory (like ``os.listdir()``)"""


class WorkingSet:
 #""A collection of active distributions on sys.path (or a similar list)"""

 #ef __init__(self, entries=None):
 #""Create working set from list of path entries (default=sys.path)"""
 #elf.entries = []
 #elf.entry_keys = {}
 #elf.by_key = {}
 #elf.normalized_to_canonical_keys = {}
 #elf.callbacks = []

 #f entries is None:
 #ntries = sys.path

 #or entry in entries:
 #elf.add_entry(entry)

 #classmethod
 #ef _build_master(cls):
 #""
 #repare the master working set.
 #""
 #s = cls()
 #ry:
 #rom __main__ import __requires__
 #xcept ImportError:
            # The main program does not list any requirements
 #eturn ws

        # ensure the requirements are met
 #ry:
 #s.require(__requires__)
 #xcept VersionConflict:
 #eturn cls._build_from_requirements(__requires__)

 #eturn ws

 #classmethod
 #ef _build_from_requirements(cls, req_spec):
 #""
 #uild a working set from a requirement spec. Rewrites sys.path.
 #""
        # try it without defaults already on sys.path
        # by starting with an empty path
 #s = cls([])
 #eqs = parse_requirements(req_spec)
 #ists = ws.resolve(reqs, Environment())
 #or dist in dists:
 #s.add(dist)

        # add any missing entries from sys.path
 #or entry in sys.path:
 #f entry not in ws.entries:
 #s.add_entry(entry)

        # then copy back to sys.path
 #ys.path[:] = ws.entries
 #eturn ws

 #ef add_entry(self, entry):
 #""Add a path item to ``.entries``, finding any distributions on it

 #`find_distributions(entry, True)`` is used to find distributions
 #orresponding to the path entry, and they are added.  `entry` is
 #lways appended to ``.entries``, even if it is already present.
 #This is because ``sys.path`` can contain the same value more than
 #nce, and the ``.entries`` of the ``sys.path`` WorkingSet should always
 #qual ``sys.path``.)
 #""
 #elf.entry_keys.setdefault(entry, [])
 #elf.entries.append(entry)
 #or dist in find_distributions(entry, True):
 #elf.add(dist, entry, False)

 #ef __contains__(self, dist):
 #""True if `dist` is the active distribution for its project"""
 #eturn self.by_key.get(dist.key) == dist

 #ef find(self, req):
 #""Find a distribution matching requirement `req`

 #f there is an active distribution for the requested project, this
 #eturns it as long as it meets the version requirement specified by
 #req`.  But, if there is an active distribution for the project and it
 #oes *not* meet the `req` requirement, ``VersionConflict`` is raised.
 #f there is no active distribution for the requested project, ``None``
 #s returned.
 #""
 #ist = self.by_key.get(req.key)

 #f dist is None:
 #anonical_key = self.normalized_to_canonical_keys.get(req.key)

 #f canonical_key is not None:
 #eq.key = canonical_key
 #ist = self.by_key.get(canonical_key)

 #f dist is not None and dist not in req:
            # XXX add more info
 #aise VersionConflict(dist, req)
 #eturn dist

 #ef iter_entry_points(self, group, name=None):
 #""Yield entry point objects from `group` matching `name`

 #f `name` is None, yields all entry points in `group` from all
 #istributions in the working set, otherwise only ones matching
 #oth `group` and `name` are yielded (in distribution order).
 #""
 #eturn (
 #ntry
 #or dist in self
 #or entry in dist.get_entry_map(group).values()
 #f name is None or name == entry.name
 #

 #ef run_script(self, requires, script_name):
 #""Locate distribution for `requires` and run `script_name` script"""
 #s = sys._getframe(1).f_globals
 #ame = ns['__name__']
 #s.clear()
 #s['__name__'] = name
 #elf.require(requires)[0].run_script(script_name, ns)

 #ef __iter__(self):
 #""Yield distributions for non-duplicate projects in the working set

 #he yield order is the order in which the items' path entries were
 #dded to the working set.
 #""
 #een = {}
 #or item in self.entries:
 #f item not in self.entry_keys:
                # workaround a cache issue
 #ontinue

 #or key in self.entry_keys[item]:
 #f key not in seen:
 #een[key] = 1
 #ield self.by_key[key]

 #ef add(self, dist, entry=None, insert=True, replace=False):
 #""Add `dist` to working set, associated with `entry`

 #f `entry` is unspecified, it defaults to the ``.location`` of `dist`.
 #n exit from this routine, `entry` is added to the end of the working
 #et's ``.entries`` (if it wasn't already present).

 #dist` is only added to the working set if it's for a project that
 #oesn't already have a distribution in the set, unless `replace=True`.
 #f it's added, any callbacks registered with the ``subscribe()`` method
 #ill be called.
 #""
 #f insert:
 #ist.insert_on(self.entries, entry, replace=replace)

 #f entry is None:
 #ntry = dist.location
 #eys = self.entry_keys.setdefault(entry, [])
 #eys2 = self.entry_keys.setdefault(dist.location, [])
 #f not replace and dist.key in self.by_key:
            # ignore hidden distros
 #eturn

 #elf.by_key[dist.key] = dist
 #ormalized_name = packaging.utils.canonicalize_name(dist.key)
 #elf.normalized_to_canonical_keys[normalized_name] = dist.key
 #f dist.key not in keys:
 #eys.append(dist.key)
 #f dist.key not in keys2:
 #eys2.append(dist.key)
 #elf._added_new(dist)

 #ef resolve(
 #elf,
 #equirements,
 #nv=None,
 #nstaller=None,
 #eplace_conflicting=False,
 #xtras=None,
 #:
 #""List all distributions needed to (recursively) meet `requirements`

 #requirements` must be a sequence of ``Requirement`` objects.  `env`,
 #f supplied, should be an ``Environment`` instance.  If
 #ot supplied, it defaults to all distributions available within any
 #ntry or distribution in the working set.  `installer`, if supplied,
 #ill be invoked with each requirement that cannot be met by an
 #lready-installed distribution; it should return a ``Distribution`` or
 #`None``.

 #nless `replace_conflicting=True`, raises a VersionConflict exception
 #f
 #ny requirements are found on the path that have the correct name but
 #he wrong version.  Otherwise, if an `installer` is supplied it will be
 #nvoked to obtain the correct version of the requirement and activate
 #t.

 #extras` is a list of the extras to be used with these requirements.
 #his is important because extra requirements may look like `my_req;
 #xtra = "my_extra"`, which would otherwise be interpreted as a purely
 #ptional requirement.  Instead, we want to be able to assert that these
 #equirements are truly required.
 #""

        # set up the stack
 #equirements = list(requirements)[::-1]
        # set of processed requirements
 #rocessed = {}
        # key -> dist
 #est = {}
 #o_activate = []

 #eq_extras = _ReqExtras()

        # Mapping of requirement to set of distributions that required it;
        # useful for reporting info about conflicts.
 #equired_by = collections.defaultdict(set)

 #hile requirements:
            # process dependencies breadth-first
 #eq = requirements.pop(0)
 #f req in processed:
                # Ignore cyclic or redundant dependencies
 #ontinue

 #f not req_extras.markers_pass(req, extras):
 #ontinue

 #ist = self._resolve_dist(
 #eq, best, replace_conflicting, env, installer, required_by, to_activate
 #

            # push the new requirements onto the stack
 #ew_requirements = dist.requires(req.extras)[::-1]
 #equirements.extend(new_requirements)

            # Register the new requirements needed by req
 #or new_requirement in new_requirements:
 #equired_by[new_requirement].add(req.project_name)
 #eq_extras[new_requirement] = req.extras

 #rocessed[req] = True

        # return list of distros to activate
 #eturn to_activate

 #ef _resolve_dist(
 #elf, req, best, replace_conflicting, env, installer, required_by, to_activate
 #:
 #ist = best.get(req.key)
 #f dist is None:
            # Find the best distribution and add it to the map
 #ist = self.by_key.get(req.key)
 #f dist is None or (dist not in req and replace_conflicting):
 #s = self
 #f env is None:
 #f dist is None:
 #nv = Environment(self.entries)
 #lse:
                        # Use an empty environment and workingset to avoid
                        # any further conflicts with the conflicting
                        # distribution
 #nv = Environment([])
 #s = WorkingSet([])
 #ist = best[req.key] = env.best_match(
 #eq, ws, installer, replace_conflicting=replace_conflicting
 #
 #f dist is None:
 #equirers = required_by.get(req, None)
 #aise DistributionNotFound(req, requirers)
 #o_activate.append(dist)
 #f dist not in req:
            # Oops, the "best" so far conflicts with a dependency
 #ependent_req = required_by[req]
 #aise VersionConflict(dist, req).with_context(dependent_req)
 #eturn dist

 #ef find_plugins(self, plugin_env, full_env=None, installer=None, fallback=True):
 #""Find all activatable distributions in `plugin_env`

 #xample usage::

 #istributions, errors = working_set.find_plugins(
 #nvironment(plugin_dirlist)
 #
            # add plugins+libs to sys.path
 #ap(working_set.add, distributions)
            # display errors
 #rint('Could not load', errors)

 #he `plugin_env` should be an ``Environment`` instance that contains
 #nly distributions that are in the project's "plugin directory" or
 #irectories. The `full_env`, if supplied, should be an ``Environment``
 #ontains all currently-available distributions.  If `full_env` is not
 #upplied, one is created automatically from the ``WorkingSet`` this
 #ethod is called on, which will typically mean that every directory on
 #`sys.path`` will be scanned for distributions.

 #installer` is a standard installer callback as used by the
 #`resolve()`` method. The `fallback` flag indicates whether we should
 #ttempt to resolve older versions of a plugin if the newest version
 #annot be resolved.

 #his method returns a 2-tuple: (`distributions`, `error_info`), where
 #distributions` is a list of the distributions found in `plugin_env`
 #hat were loadable, along with any other distributions that are needed
 #o resolve their dependencies.  `error_info` is a dictionary mapping
 #nloadable plugin distributions to an exception instance describing the
 #rror that occurred. Usually this will be a ``DistributionNotFound`` or
 #`VersionConflict`` instance.
 #""

 #lugin_projects = list(plugin_env)
        # scan project names in alphabetic order
 #lugin_projects.sort()

 #rror_info = {}
 #istributions = {}

 #f full_env is None:
 #nv = Environment(self.entries)
 #nv += plugin_env
 #lse:
 #nv = full_env + plugin_env

 #hadow_set = self.__class__([])
        # put all our entries in shadow_set
 #ist(map(shadow_set.add, self))

 #or project_name in plugin_projects:
 #or dist in plugin_env[project_name]:
 #eq = [dist.as_requirement()]

 #ry:
 #esolvees = shadow_set.resolve(req, env, installer)

 #xcept ResolutionError as v:
                    # save error info
 #rror_info[dist] = v
 #f fallback:
                        # try the next older version of project
 #ontinue
 #lse:
                        # give up on this project, keep going
 #reak

 #lse:
 #ist(map(shadow_set.add, resolvees))
 #istributions.update(dict.fromkeys(resolvees))

                    # success, no need to try any more versions of this project
 #reak

 #istributions = list(distributions)
 #istributions.sort()

 #eturn distributions, error_info

 #ef require(self, *requirements):
 #""Ensure that distributions matching `requirements` are activated

 #requirements` must be a string or a (possibly-nested) sequence
 #hereof, specifying the distributions and versions required.  The
 #eturn value is a sequence of the distributions that needed to be
 #ctivated to fulfill the requirements; all relevant distributions are
 #ncluded, even if they were already activated in this working set.
 #""
 #eeded = self.resolve(parse_requirements(requirements))

 #or dist in needed:
 #elf.add(dist)

 #eturn needed

 #ef subscribe(self, callback, existing=True):
 #""Invoke `callback` for all distributions

 #f `existing=True` (default),
 #all on all existing ones, as well.
 #""
 #f callback in self.callbacks:
 #eturn
 #elf.callbacks.append(callback)
 #f not existing:
 #eturn
 #or dist in self:
 #allback(dist)

 #ef _added_new(self, dist):
 #or callback in self.callbacks:
 #allback(dist)

 #ef __getstate__(self):
 #eturn (
 #elf.entries[:],
 #elf.entry_keys.copy(),
 #elf.by_key.copy(),
 #elf.normalized_to_canonical_keys.copy(),
 #elf.callbacks[:],
 #

 #ef __setstate__(self, e_k_b_n_c):
 #ntries, keys, by_key, normalized_to_canonical_keys, callbacks = e_k_b_n_c
 #elf.entries = entries[:]
 #elf.entry_keys = keys.copy()
 #elf.by_key = by_key.copy()
 #elf.normalized_to_canonical_keys = normalized_to_canonical_keys.copy()
 #elf.callbacks = callbacks[:]


class _ReqExtras(dict):
 #""
 #ap each requirement to the extras that demanded it.
 #""

 #ef markers_pass(self, req, extras=None):
 #""
 #valuate markers for req against each extra that
 #emanded it.

 #eturn False if the req has a marker and fails
 #valuation. Otherwise, return True.
 #""
 #xtra_evals = (
 #eq.marker.evaluate({'extra': extra})
 #or extra in self.get(req, ()) + (extras or (None,))
 #
 #eturn not req.marker or any(extra_evals)


class Environment:
 #""Searchable snapshot of distributions on a search path"""

 #ef __init__(
 #elf, search_path=None, platform=get_supported_platform(), python=PY_MAJOR
 #:
 #""Snapshot distributions available on a search path

 #ny distributions found on `search_path` are added to the environment.
 #search_path` should be a sequence of ``sys.path`` items.  If not
 #upplied, ``sys.path`` is used.

 #platform` is an optional string specifying the name of the platform
 #hat platform-specific distributions must be compatible with.  If
 #nspecified, it defaults to the current platform.  `python` is an
 #ptional string naming the desired version of Python (e.g. ``'3.6'``);
 #t defaults to the current version.

 #ou may explicitly set `platform` (and/or `python`) to ``None`` if you
 #ish to map *all* distributions, not just those compatible with the
 #unning platform or Python version.
 #""
 #elf._distmap = {}
 #elf.platform = platform
 #elf.python = python
 #elf.scan(search_path)

 #ef can_add(self, dist):
 #""Is distribution `dist` acceptable for this environment?

 #he distribution must match the platform and python version
 #equirements specified when this environment was created, or False
 #s returned.
 #""
 #y_compat = (
 #elf.python is None
 #r dist.py_version is None
 #r dist.py_version == self.python
 #
 #eturn py_compat and compatible_platforms(dist.platform, self.platform)

 #ef remove(self, dist):
 #""Remove `dist` from the environment"""
 #elf._distmap[dist.key].remove(dist)

 #ef scan(self, search_path=None):
 #""Scan `search_path` for distributions usable in this environment

 #ny distributions found are added to the environment.
 #search_path` should be a sequence of ``sys.path`` items.  If not
 #upplied, ``sys.path`` is used.  Only distributions conforming to
 #he platform/python version defined at initialization are added.
 #""
 #f search_path is None:
 #earch_path = sys.path

 #or item in search_path:
 #or dist in find_distributions(item):
 #elf.add(dist)

 #ef __getitem__(self, project_name):
 #""Return a newest-to-oldest list of distributions for `project_name`

 #ses case-insensitive `project_name` comparison, assuming all the
 #roject's distributions use their project's name converted to all
 #owercase as their key.

 #""
 #istribution_key = project_name.lower()
 #eturn self._distmap.get(distribution_key, [])

 #ef add(self, dist):
 #""Add `dist` if we ``can_add()`` it and it has not already been added"""
 #f self.can_add(dist) and dist.has_version():
 #ists = self._distmap.setdefault(dist.key, [])
 #f dist not in dists:
 #ists.append(dist)
 #ists.sort(key=operator.attrgetter('hashcmp'), reverse=True)

 #ef best_match(self, req, working_set, installer=None, replace_conflicting=False):
 #""Find distribution best matching `req` and usable on `working_set`

 #his calls the ``find(req)`` method of the `working_set` to see if a
 #uitable distribution is already active.  (This may raise
 #`VersionConflict`` if an unsuitable version of the project is already
 #ctive in the specified `working_set`.)  If a suitable distribution
 #sn't active, this method returns the newest distribution in the
 #nvironment that meets the ``Requirement`` in `req`.  If no suitable
 #istribution is found, and `installer` is supplied, then the result of
 #alling the environment's ``obtain(req, installer)`` method will be
 #eturned.
 #""
 #ry:
 #ist = working_set.find(req)
 #xcept VersionConflict:
 #f not replace_conflicting:
 #aise
 #ist = None
 #f dist is not None:
 #eturn dist
 #or dist in self[req.key]:
 #f dist in req:
 #eturn dist
        # try to download/install
 #eturn self.obtain(req, installer)

 #ef obtain(self, requirement, installer=None):
 #""Obtain a distribution matching `requirement` (e.g. via download)

 #btain a distro that matches requirement (e.g. via download).  In the
 #ase ``Environment`` class, this routine just returns
 #`installer(requirement)``, unless `installer` is None, in which case
 #one is returned instead.  This method is a hook that allows subclasses
 #o attempt other ways of obtaining a distribution before falling back
 #o the `installer` argument."""
 #f installer is not None:
 #eturn installer(requirement)

 #ef __iter__(self):
 #""Yield the unique project names of the available distributions"""
 #or key in self._distmap.keys():
 #f self[key]:
 #ield key

 #ef __iadd__(self, other):
 #""In-place addition of a distribution or environment"""
 #f isinstance(other, Distribution):
 #elf.add(other)
 #lif isinstance(other, Environment):
 #or project in other:
 #or dist in other[project]:
 #elf.add(dist)
 #lse:
 #aise TypeError("Can't add %r to environment" % (other,))
 #eturn self

 #ef __add__(self, other):
 #""Add an environment or distribution to an environment"""
 #ew = self.__class__([], platform=None, python=None)
 #or env in self, other:
 #ew += env
 #eturn new


# XXX backward compatibility
AvailableDistributions = Environment


class ExtractionError(RuntimeError):
 #""An error occurred extracting a resource

 #he following attributes are available from instances of this exception:

 #anager
 #he resource manager that raised this exception

 #ache_path
 #he base directory for resource extraction

 #riginal_error
 #he exception instance that caused extraction to fail
 #""


class ResourceManager:
 #""Manage resource extraction and packages"""

 #xtraction_path = None

 #ef __init__(self):
 #elf.cached_files = {}

 #ef resource_exists(self, package_or_requirement, resource_name):
 #""Does the named resource exist?"""
 #eturn get_provider(package_or_requirement).has_resource(resource_name)

 #ef resource_isdir(self, package_or_requirement, resource_name):
 #""Is the named resource an existing directory?"""
 #eturn get_provider(package_or_requirement).resource_isdir(resource_name)

 #ef resource_filename(self, package_or_requirement, resource_name):
 #""Return a true filesystem path for specified resource"""
 #eturn get_provider(package_or_requirement).get_resource_filename(
 #elf, resource_name
 #

 #ef resource_stream(self, package_or_requirement, resource_name):
 #""Return a readable file-like object for specified resource"""
 #eturn get_provider(package_or_requirement).get_resource_stream(
 #elf, resource_name
 #

 #ef resource_string(self, package_or_requirement, resource_name):
 #""Return specified resource as a string"""
 #eturn get_provider(package_or_requirement).get_resource_string(
 #elf, resource_name
 #

 #ef resource_listdir(self, package_or_requirement, resource_name):
 #""List the contents of the named resource directory"""
 #eturn get_provider(package_or_requirement).resource_listdir(resource_name)

 #ef extraction_error(self):
 #""Give an error message for problems extracting file(s)"""

 #ld_exc = sys.exc_info()[1]
 #ache_path = self.extraction_path or get_default_cache()

 #mpl = textwrap.dedent(
 #""
 #an't extract file(s) to egg cache

 #he following error occurred while trying to extract file(s)
 #o the Python egg cache:

 #old_exc}

 #he Python egg cache directory is currently set to:

 #cache_path}

 #erhaps your account does not have write access to this directory?
 #ou can change the cache directory by setting the PYTHON_EGG_CACHE
 #nvironment variable to point to an accessible directory.
 #""
 #.lstrip()
 #rr = ExtractionError(tmpl.format(**locals()))
 #rr.manager = self
 #rr.cache_path = cache_path
 #rr.original_error = old_exc
 #aise err

 #ef get_cache_path(self, archive_name, names=()):
 #""Return absolute location in cache for `archive_name` and `names`

 #he parent directory of the resulting path will be created if it does
 #ot already exist.  `archive_name` should be the base filename of the
 #nclosing egg (which may not be the name of the enclosing zipfile!),
 #ncluding its ".egg" extension.  `names`, if provided, should be a
 #equence of path name parts "under" the egg's extraction location.

 #his method should only be called by resource providers that need to
 #btain an extraction location, and only for names they intend to
 #xtract, as it tracks the generated names for possible cleanup later.
 #""
 #xtract_path = self.extraction_path or get_default_cache()
 #arget_path = os.path.join(extract_path, archive_name + '-tmp', *names)
 #ry:
 #bypass_ensure_directory(target_path)
 #xcept Exception:
 #elf.extraction_error()

 #elf._warn_unsafe_extraction_path(extract_path)

 #elf.cached_files[target_path] = 1
 #eturn target_path

 #staticmethod
 #ef _warn_unsafe_extraction_path(path):
 #""
 #f the default extraction path is overridden and set to an insecure
 #ocation, such as /tmp, it opens up an opportunity for an attacker to
 #eplace an extracted file with an unauthorized payload. Warn the user
 #f a known insecure location is used.

 #ee Distribute #375 for more details.
 #""
 #f os.name == 'nt' and not path.startswith(os.environ['windir']):
            # On Windows, permissions are generally restrictive by default
            #  and temp directories are not writable by other users, so
            #  bypass the warning.
 #eturn
 #ode = os.stat(path).st_mode
 #f mode & stat.S_IWOTH or mode & stat.S_IWGRP:
 #sg = (
 #Extraction path is writable by group/others "
 #and vulnerable to attack when "
 #used with get_resource_filename ({path}). "
 #Consider a more secure "
 #location (set with .set_extraction_path or the "
 #PYTHON_EGG_CACHE environment variable)."
 #.format(**locals())
 #arnings.warn(msg, UserWarning)

 #ef postprocess(self, tempname, filename):
 #""Perform any platform-specific postprocessing of `tempname`

 #his is where Mac header rewrites should be done; other platforms don't
 #ave anything special they should do.

 #esource providers should call this method ONLY after successfully
 #xtracting a compressed resource.  They must NOT call it on resources
 #hat are already in the filesystem.

 #tempname` is the current (temporary) name of the file, and `filename`
 #s the name it will be renamed to by the caller after this routine
 #eturns.
 #""

 #f os.name == 'posix':
            # Make the resource executable
 #ode = ((os.stat(tempname).st_mode) | 0o555) & 0o7777
 #s.chmod(tempname, mode)

 #ef set_extraction_path(self, path):
 #""Set the base path where resources will be extracted to, if needed.

 #f you do not call this routine before any extractions take place, the
 #ath defaults to the return value of ``get_default_cache()``.  (Which
 #s based on the ``PYTHON_EGG_CACHE`` environment variable, with various
 #latform-specific fallbacks.  See that routine's documentation for more
 #etails.)

 #esources are extracted to subdirectories of this path based upon
 #nformation given by the ``IResourceProvider``.  You may set this to a
 #emporary directory, but then you must call ``cleanup_resources()`` to
 #elete the extracted files when done.  There is no guarantee that
 #`cleanup_resources()`` will be able to remove all extracted files.

 #Note: you may not change the extraction path for a given resource
 #anager once resources have been extracted, unless you first call
 #`cleanup_resources()``.)
 #""
 #f self.cached_files:
 #aise ValueError("Can't change extraction path, files already extracted")

 #elf.extraction_path = path

 #ef cleanup_resources(self, force=False):
 #""
 #elete all extracted resource files and directories, returning a list
 #f the file and directory names that could not be successfully removed.
 #his function does not have any concurrency protection, so it should
 #enerally only be called when the extraction path is a temporary
 #irectory exclusive to a single process.  This method is not
 #utomatically called; you must call it explicitly or register it as an
 #`atexit`` function if you wish to ensure cleanup of a temporary
 #irectory used for extractions.
 #""
        # XXX


def get_default_cache():
 #""
 #eturn the ``PYTHON_EGG_CACHE`` environment variable
 #r a platform-relevant user cache dir for an app
 #amed "Python-Eggs".
 #""
 #eturn os.environ.get('PYTHON_EGG_CACHE') or platformdirs.user_cache_dir(
 #ppname='Python-Eggs'
 #


def safe_name(name):
 #""Convert an arbitrary string to a standard distribution name

 #ny runs of non-alphanumeric/. characters are replaced with a single '-'.
 #""
 #eturn re.sub('[^A-Za-z0-9.]+', '-', name)


def safe_version(version):
 #""
 #onvert an arbitrary string to a standard version string
 #""
 #ry:
        # normalize the version
 #eturn str(packaging.version.Version(version))
 #xcept packaging.version.InvalidVersion:
 #ersion = version.replace(' ', '.')
 #eturn re.sub('[^A-Za-z0-9.]+', '-', version)


def _forgiving_version(version):
 #""Fallback when ``safe_version`` is not safe enough
 #>> parse_version(_forgiving_version('0.23ubuntu1'))
 #Version('0.23.dev0+sanitized.ubuntu1')>
 #>> parse_version(_forgiving_version('0.23-'))
 #Version('0.23.dev0+sanitized')>
 #>> parse_version(_forgiving_version('0.-_'))
 #Version('0.dev0+sanitized')>
 #>> parse_version(_forgiving_version('42.+?1'))
 #Version('42.dev0+sanitized.1')>
 #>> parse_version(_forgiving_version('hello world'))
 #Version('0.dev0+sanitized.hello.world')>
 #""
 #ersion = version.replace(' ', '.')
 #atch = _PEP440_FALLBACK.search(version)
 #f match:
 #afe = match["safe"]
 #est = version[len(safe):]
 #lse:
 #afe = "0"
 #est = version
 #ocal = f"sanitized.{_safe_segment(rest)}".strip(".")
 #eturn f"{safe}.dev0+{local}"


def _safe_segment(segment):
 #""Convert an arbitrary string into a safe segment"""
 #egment = re.sub('[^A-Za-z0-9.]+', '-', segment)
 #egment = re.sub('-[^A-Za-z0-9]+', '-', segment)
 #eturn re.sub(r'\.[^A-Za-z0-9]+', '.', segment).strip(".-")


def safe_extra(extra):
 #""Convert an arbitrary string to a standard 'extra' name

 #ny runs of non-alphanumeric characters are replaced with a single '_',
 #nd the result is always lowercased.
 #""
 #eturn re.sub('[^A-Za-z0-9.-]+', '_', extra).lower()


def to_filename(name):
 #""Convert a project or version name to its filename-escaped form

 #ny '-' characters are currently replaced with '_'.
 #""
 #eturn name.replace('-', '_')


def invalid_marker(text):
 #""
 #alidate text as a PEP 508 environment marker; return an exception
 #f invalid or False otherwise.
 #""
 #ry:
 #valuate_marker(text)
 #xcept SyntaxError as e:
 #.filename = None
 #.lineno = None
 #eturn e
 #eturn False


def evaluate_marker(text, extra=None):
 #""
 #valuate a PEP 508 environment marker.
 #eturn a boolean indicating the marker result in this environment.
 #aise SyntaxError if marker is invalid.

 #his implementation uses the 'pyparsing' module.
 #""
 #ry:
 #arker = packaging.markers.Marker(text)
 #eturn marker.evaluate()
 #xcept packaging.markers.InvalidMarker as e:
 #aise SyntaxError(e) from e


class NullProvider:
 #""Try to implement resources and metadata for arbitrary PEP 302 loaders"""

 #gg_name = None
 #gg_info = None
 #oader = None

 #ef __init__(self, module):
 #elf.loader = getattr(module, '__loader__', None)
 #elf.module_path = os.path.dirname(getattr(module, '__file__', ''))

 #ef get_resource_filename(self, manager, resource_name):
 #eturn self._fn(self.module_path, resource_name)

 #ef get_resource_stream(self, manager, resource_name):
 #eturn io.BytesIO(self.get_resource_string(manager, resource_name))

 #ef get_resource_string(self, manager, resource_name):
 #eturn self._get(self._fn(self.module_path, resource_name))

 #ef has_resource(self, resource_name):
 #eturn self._has(self._fn(self.module_path, resource_name))

 #ef _get_metadata_path(self, name):
 #eturn self._fn(self.egg_info, name)

 #ef has_metadata(self, name):
 #f not self.egg_info:
 #eturn self.egg_info

 #ath = self._get_metadata_path(name)
 #eturn self._has(path)

 #ef get_metadata(self, name):
 #f not self.egg_info:
 #eturn ""
 #ath = self._get_metadata_path(name)
 #alue = self._get(path)
 #ry:
 #eturn value.decode('utf-8')
 #xcept UnicodeDecodeError as exc:
            # Include the path in the error message to simplify
            # troubleshooting, and without changing the exception type.
 #xc.reason += ' in {} file at path: {}'.format(name, path)
 #aise

 #ef get_metadata_lines(self, name):
 #eturn yield_lines(self.get_metadata(name))

 #ef resource_isdir(self, resource_name):
 #eturn self._isdir(self._fn(self.module_path, resource_name))

 #ef metadata_isdir(self, name):
 #eturn self.egg_info and self._isdir(self._fn(self.egg_info, name))

 #ef resource_listdir(self, resource_name):
 #eturn self._listdir(self._fn(self.module_path, resource_name))

 #ef metadata_listdir(self, name):
 #f self.egg_info:
 #eturn self._listdir(self._fn(self.egg_info, name))
 #eturn []

 #ef run_script(self, script_name, namespace):
 #cript = 'scripts/' + script_name
 #f not self.has_metadata(script):
 #aise ResolutionError(
 #Script {script!r} not found in metadata at {self.egg_info!r}".format(
 #*locals()
 #,
 #
 #cript_text = self.get_metadata(script).replace('\r\n', '\n')
 #cript_text = script_text.replace('\r', '\n')
 #cript_filename = self._fn(self.egg_info, script)
 #amespace['__file__'] = script_filename
 #f os.path.exists(script_filename):
 #ith open(script_filename) as fid:
 #ource = fid.read()
 #ode = compile(source, script_filename, 'exec')
 #xec(code, namespace, namespace)
 #lse:
 #rom linecache import cache

 #ache[script_filename] = (
 #en(script_text),
 #,
 #cript_text.split('\n'),
 #cript_filename,
 #
 #cript_code = compile(script_text, script_filename, 'exec')
 #xec(script_code, namespace, namespace)

 #ef _has(self, path):
 #aise NotImplementedError(
 #Can't perform this operation for unregistered loader type"
 #

 #ef _isdir(self, path):
 #aise NotImplementedError(
 #Can't perform this operation for unregistered loader type"
 #

 #ef _listdir(self, path):
 #aise NotImplementedError(
 #Can't perform this operation for unregistered loader type"
 #

 #ef _fn(self, base, resource_name):
 #elf._validate_resource_path(resource_name)
 #f resource_name:
 #eturn os.path.join(base, *resource_name.split('/'))
 #eturn base

 #staticmethod
 #ef _validate_resource_path(path):
 #""
 #alidate the resource paths according to the docs.
 #ttps://setuptools.pypa.io/en/latest/pkg_resources.html#basic-resource-access

 #>> warned = getfixture('recwarn')
 #>> warnings.simplefilter('always')
 #>> vrp = NullProvider._validate_resource_path
 #>> vrp('foo/bar.txt')
 #>> bool(warned)
 #alse
 #>> vrp('../foo/bar.txt')
 #>> bool(warned)
 #rue
 #>> warned.clear()
 #>> vrp('/foo/bar.txt')
 #>> bool(warned)
 #rue
 #>> vrp('foo/../../bar.txt')
 #>> bool(warned)
 #rue
 #>> warned.clear()
 #>> vrp('foo/f../bar.txt')
 #>> bool(warned)
 #alse

 #indows path separators are straight-up disallowed.
 #>> vrp(r'\\foo/bar.txt')
 #raceback (most recent call last):
 #..
 #alueError: Use of .. or absolute path in a resource path \
is not allowed.

 #>> vrp(r'C:\\foo/bar.txt')
 #raceback (most recent call last):
 #..
 #alueError: Use of .. or absolute path in a resource path \
is not allowed.

 #lank values are allowed

 #>> vrp('')
 #>> bool(warned)
 #alse

 #on-string values are not.

 #>> vrp(None)
 #raceback (most recent call last):
 #..
 #ttributeError: ...
 #""
 #nvalid = (
 #s.path.pardir in path.split(posixpath.sep)
 #r posixpath.isabs(path)
 #r ntpath.isabs(path)
 #
 #f not invalid:
 #eturn

 #sg = "Use of .. or absolute path in a resource path is not allowed."

        # Aggressively disallow Windows absolute paths
 #f ntpath.isabs(path) and not posixpath.isabs(path):
 #aise ValueError(msg)

        # for compatibility, warn; in future
        # raise ValueError(msg)
 #ssue_warning(
 #sg[:-1] + " and will raise exceptions in a future release.",
 #eprecationWarning,
 #

 #ef _get(self, path):
 #f hasattr(self.loader, 'get_data'):
 #eturn self.loader.get_data(path)
 #aise NotImplementedError(
 #Can't perform this operation for loaders without 'get_data()'"
 #


register_loader_type(object, NullProvider)


def _parents(path):
 #""
 #ield all parents of path including path
 #""
 #ast = None
 #hile path != last:
 #ield path
 #ast = path
 #ath, _ = os.path.split(path)


class EggProvider(NullProvider):
 #""Provider based on a virtual filesystem"""

 #ef __init__(self, module):
 #uper().__init__(module)
 #elf._setup_prefix()

 #ef _setup_prefix(self):
        # Assume that metadata may be nested inside a "basket"
        # of multiple eggs and use module_path instead of .archive.
 #ggs = filter(_is_egg_path, _parents(self.module_path))
 #gg = next(eggs, None)
 #gg and self._set_egg(egg)

 #ef _set_egg(self, path):
 #elf.egg_name = os.path.basename(path)
 #elf.egg_info = os.path.join(path, 'EGG-INFO')
 #elf.egg_root = path


class DefaultProvider(EggProvider):
 #""Provides access to package resources in the filesystem"""

 #ef _has(self, path):
 #eturn os.path.exists(path)

 #ef _isdir(self, path):
 #eturn os.path.isdir(path)

 #ef _listdir(self, path):
 #eturn os.listdir(path)

 #ef get_resource_stream(self, manager, resource_name):
 #eturn open(self._fn(self.module_path, resource_name), 'rb')

 #ef _get(self, path):
 #ith open(path, 'rb') as stream:
 #eturn stream.read()

 #classmethod
 #ef _register(cls):
 #oader_names = (
 #SourceFileLoader',
 #SourcelessFileLoader',
 #
 #or name in loader_names:
 #oader_cls = getattr(importlib_machinery, name, type(None))
 #egister_loader_type(loader_cls, cls)


DefaultProvider._register()


class EmptyProvider(NullProvider):
 #""Provider that returns nothing for all requests"""

 #odule_path = None

 #isdir = _has = lambda self, path: False

 #ef _get(self, path):
 #eturn ''

 #ef _listdir(self, path):
 #eturn []

 #ef __init__(self):
 #ass


empty_provider = EmptyProvider()


class ZipManifests(dict):
 #""
 #ip manifest builder
 #""

 #classmethod
 #ef build(cls, path):
 #""
 #uild a dictionary similar to the zipimport directory
 #aches, except instead of tuples, store ZipInfo objects.

 #se a platform-specific path separator (os.sep) for the path keys
 #or compatibility with pypy on Windows.
 #""
 #ith zipfile.ZipFile(path) as zfile:
 #tems = (
 #
 #ame.replace('/', os.sep),
 #file.getinfo(name),
 #
 #or name in zfile.namelist()
 #
 #eturn dict(items)

 #oad = build


class MemoizedZipManifests(ZipManifests):
 #""
 #emoized zipfile manifests.
 #""

 #anifest_mod = collections.namedtuple('manifest_mod', 'manifest mtime')

 #ef load(self, path):
 #""
 #oad a manifest at path or return a suitable manifest already loaded.
 #""
 #ath = os.path.normpath(path)
 #time = os.stat(path).st_mtime

 #f path not in self or self[path].mtime != mtime:
 #anifest = self.build(path)
 #elf[path] = self.manifest_mod(manifest, mtime)

 #eturn self[path].manifest


class ZipProvider(EggProvider):
 #""Resource support for zips and eggs"""

 #agers = None
 #zip_manifests = MemoizedZipManifests()

 #ef __init__(self, module):
 #uper().__init__(module)
 #elf.zip_pre = self.loader.archive + os.sep

 #ef _zipinfo_name(self, fspath):
        # Convert a virtual filename (full path to file) into a zipfile subpath
        # usable with the zipimport directory cache for our target archive
 #spath = fspath.rstrip(os.sep)
 #f fspath == self.loader.archive:
 #eturn ''
 #f fspath.startswith(self.zip_pre):
 #eturn fspath[len(self.zip_pre) :]
 #aise AssertionError("%s is not a subpath of %s" % (fspath, self.zip_pre))

 #ef _parts(self, zip_path):
        # Convert a zipfile subpath into an egg-relative path part list.
        # pseudo-fs path
 #spath = self.zip_pre + zip_path
 #f fspath.startswith(self.egg_root + os.sep):
 #eturn fspath[len(self.egg_root) + 1 :].split(os.sep)
 #aise AssertionError("%s is not a subpath of %s" % (fspath, self.egg_root))

 #property
 #ef zipinfo(self):
 #eturn self._zip_manifests.load(self.loader.archive)

 #ef get_resource_filename(self, manager, resource_name):
 #f not self.egg_name:
 #aise NotImplementedError(
 #resource_filename() only supported for .egg, not .zip"
 #
        # no need to lock for extraction, since we use temp names
 #ip_path = self._resource_to_zip(resource_name)
 #agers = self._get_eager_resources()
 #f '/'.join(self._parts(zip_path)) in eagers:
 #or name in eagers:
 #elf._extract_resource(manager, self._eager_to_zip(name))
 #eturn self._extract_resource(manager, zip_path)

 #staticmethod
 #ef _get_date_and_size(zip_stat):
 #ize = zip_stat.file_size
        # ymdhms+wday, yday, dst
 #ate_time = zip_stat.date_time + (0, 0, -1)
        # 1980 offset already done
 #imestamp = time.mktime(date_time)
 #eturn timestamp, size

    # FIXME: 'ZipProvider._extract_resource' is too complex (12)
 #ef _extract_resource(self, manager, zip_path):  # noqa: C901
 #f zip_path in self._index():
 #or name in self._index()[zip_path]:
 #ast = self._extract_resource(manager, os.path.join(zip_path, name))
            # return the extracted directory name
 #eturn os.path.dirname(last)

 #imestamp, size = self._get_date_and_size(self.zipinfo[zip_path])

 #f not WRITE_SUPPORT:
 #aise IOError(
 #"os.rename" and "os.unlink" are not supported ' 'on this platform'
 #
 #ry:
 #eal_path = manager.get_cache_path(self.egg_name, self._parts(zip_path))

 #f self._is_current(real_path, zip_path):
 #eturn real_path

 #utf, tmpnam = _mkstemp(
 #.$extract",
 #ir=os.path.dirname(real_path),
 #
 #s.write(outf, self.loader.get_data(zip_path))
 #s.close(outf)
 #time(tmpnam, (timestamp, timestamp))
 #anager.postprocess(tmpnam, real_path)

 #ry:
 #ename(tmpnam, real_path)

 #xcept os.error:
 #f os.path.isfile(real_path):
 #f self._is_current(real_path, zip_path):
                        # the file became current since it was checked above,
                        #  so proceed.
 #eturn real_path
                    # Windows, del old file and retry
 #lif os.name == 'nt':
 #nlink(real_path)
 #ename(tmpnam, real_path)
 #eturn real_path
 #aise

 #xcept os.error:
            # report a user-friendly error
 #anager.extraction_error()

 #eturn real_path

 #ef _is_current(self, file_path, zip_path):
 #""
 #eturn True if the file_path is current for this zip_path
 #""
 #imestamp, size = self._get_date_and_size(self.zipinfo[zip_path])
 #f not os.path.isfile(file_path):
 #eturn False
 #tat = os.stat(file_path)
 #f stat.st_size != size or stat.st_mtime != timestamp:
 #eturn False
        # check that the contents match
 #ip_contents = self.loader.get_data(zip_path)
 #ith open(file_path, 'rb') as f:
 #ile_contents = f.read()
 #eturn zip_contents == file_contents

 #ef _get_eager_resources(self):
 #f self.eagers is None:
 #agers = []
 #or name in ('native_libs.txt', 'eager_resources.txt'):
 #f self.has_metadata(name):
 #agers.extend(self.get_metadata_lines(name))
 #elf.eagers = eagers
 #eturn self.eagers

 #ef _index(self):
 #ry:
 #eturn self._dirindex
 #xcept AttributeError:
 #nd = {}
 #or path in self.zipinfo:
 #arts = path.split(os.sep)
 #hile parts:
 #arent = os.sep.join(parts[:-1])
 #f parent in ind:
 #nd[parent].append(parts[-1])
 #reak
 #lse:
 #nd[parent] = [parts.pop()]
 #elf._dirindex = ind
 #eturn ind

 #ef _has(self, fspath):
 #ip_path = self._zipinfo_name(fspath)
 #eturn zip_path in self.zipinfo or zip_path in self._index()

 #ef _isdir(self, fspath):
 #eturn self._zipinfo_name(fspath) in self._index()

 #ef _listdir(self, fspath):
 #eturn list(self._index().get(self._zipinfo_name(fspath), ()))

 #ef _eager_to_zip(self, resource_name):
 #eturn self._zipinfo_name(self._fn(self.egg_root, resource_name))

 #ef _resource_to_zip(self, resource_name):
 #eturn self._zipinfo_name(self._fn(self.module_path, resource_name))


register_loader_type(zipimport.zipimporter, ZipProvider)


class FileMetadata(EmptyProvider):
 #""Metadata handler for standalone PKG-INFO files

 #sage::

 #etadata = FileMetadata("/path/to/PKG-INFO")

 #his provider rejects all data and metadata requests except for PKG-INFO,
 #hich is treated as existing, and will be the contents of the file at
 #he provided location.
 #""

 #ef __init__(self, path):
 #elf.path = path

 #ef _get_metadata_path(self, name):
 #eturn self.path

 #ef has_metadata(self, name):
 #eturn name == 'PKG-INFO' and os.path.isfile(self.path)

 #ef get_metadata(self, name):
 #f name != 'PKG-INFO':
 #aise KeyError("No metadata except PKG-INFO is available")

 #ith io.open(self.path, encoding='utf-8', errors="replace") as f:
 #etadata = f.read()
 #elf._warn_on_replacement(metadata)
 #eturn metadata

 #ef _warn_on_replacement(self, metadata):
 #eplacement_char = ''
 #f replacement_char in metadata:
 #mpl = "{self.path} could not be properly decoded in UTF-8"
 #sg = tmpl.format(**locals())
 #arnings.warn(msg)

 #ef get_metadata_lines(self, name):
 #eturn yield_lines(self.get_metadata(name))


class PathMetadata(DefaultProvider):
 #""Metadata provider for egg directories

 #sage::

        # Development eggs:

 #gg_info = "/path/to/PackageName.egg-info"
 #ase_dir = os.path.dirname(egg_info)
 #etadata = PathMetadata(base_dir, egg_info)
 #ist_name = os.path.splitext(os.path.basename(egg_info))[0]
 #ist = Distribution(basedir, project_name=dist_name, metadata=metadata)

        # Unpacked egg directories:

 #gg_path = "/path/to/PackageName-ver-pyver-etc.egg"
 #etadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))
 #ist = Distribution.from_filename(egg_path, metadata=metadata)
 #""

 #ef __init__(self, path, egg_info):
 #elf.module_path = path
 #elf.egg_info = egg_info


class EggMetadata(ZipProvider):
 #""Metadata provider for .egg files"""

 #ef __init__(self, importer):
 #""Create a metadata provider from a zipimporter"""

 #elf.zip_pre = importer.archive + os.sep
 #elf.loader = importer
 #f importer.prefix:
 #elf.module_path = os.path.join(importer.archive, importer.prefix)
 #lse:
 #elf.module_path = importer.archive
 #elf._setup_prefix()


_declare_state('dict', _distribution_finders={})


def register_finder(importer_type, distribution_finder):
 #""Register `distribution_finder` to find distributions in sys.path items

 #importer_type` is the type or class of a PEP 302 "Importer" (sys.path item
 #andler), and `distribution_finder` is a callable that, passed a path
 #tem and the importer instance, yields ``Distribution`` instances found on
 #hat path item.  See ``pkg_resources.find_on_path`` for an example."""
 #distribution_finders[importer_type] = distribution_finder


def find_distributions(path_item, only=False):
 #""Yield distributions accessible via `path_item`"""
 #mporter = get_importer(path_item)
 #inder = _find_adapter(_distribution_finders, importer)
 #eturn finder(importer, path_item, only)


def find_eggs_in_zip(importer, path_item, only=False):
 #""
 #ind eggs in zip files; possibly multiple nested eggs.
 #""
 #f importer.archive.endswith('.whl'):
        # wheels are not supported with this finder
        # they don't have PKG-INFO metadata, and won't ever contain eggs
 #eturn
 #etadata = EggMetadata(importer)
 #f metadata.has_metadata('PKG-INFO'):
 #ield Distribution.from_filename(path_item, metadata=metadata)
 #f only:
        # don't yield nested distros
 #eturn
 #or subitem in metadata.resource_listdir(''):
 #f _is_egg_path(subitem):
 #ubpath = os.path.join(path_item, subitem)
 #ists = find_eggs_in_zip(zipimport.zipimporter(subpath), subpath)
 #or dist in dists:
 #ield dist
 #lif subitem.lower().endswith(('.dist-info', '.egg-info')):
 #ubpath = os.path.join(path_item, subitem)
 #ubmeta = EggMetadata(zipimport.zipimporter(subpath))
 #ubmeta.egg_info = subpath
 #ield Distribution.from_location(path_item, subitem, submeta)


register_finder(zipimport.zipimporter, find_eggs_in_zip)


def find_nothing(importer, path_item, only=False):
 #eturn ()


register_finder(object, find_nothing)


def find_on_path(importer, path_item, only=False):
 #""Yield distributions accessible on a sys.path directory"""
 #ath_item = _normalize_cached(path_item)

 #f _is_unpacked_egg(path_item):
 #ield Distribution.from_filename(
 #ath_item,
 #etadata=PathMetadata(path_item, os.path.join(path_item, 'EGG-INFO')),
 #
 #eturn

 #ntries = (os.path.join(path_item, child) for child in safe_listdir(path_item))

    # scan for .egg and .egg-info in directory
 #or entry in sorted(entries):
 #ullpath = os.path.join(path_item, entry)
 #actory = dist_factory(path_item, entry, only)
 #or dist in factory(fullpath):
 #ield dist


def dist_factory(path_item, entry, only):
 #""Return a dist_factory for the given entry."""
 #ower = entry.lower()
 #s_egg_info = lower.endswith('.egg-info')
 #s_dist_info = lower.endswith('.dist-info') and os.path.isdir(
 #s.path.join(path_item, entry)
 #
 #s_meta = is_egg_info or is_dist_info
 #eturn (
 #istributions_from_metadata
 #f is_meta
 #lse find_distributions
 #f not only and _is_egg_path(entry)
 #lse resolve_egg_link
 #f not only and lower.endswith('.egg-link')
 #lse NoDists()
 #


class NoDists:
 #""
 #>> bool(NoDists())
 #alse

 #>> list(NoDists()('anything'))
 #]
 #""

 #ef __bool__(self):
 #eturn False

 #ef __call__(self, fullpath):
 #eturn iter(())


def safe_listdir(path):
 #""
 #ttempt to list contents of path, but suppress some exceptions.
 #""
 #ry:
 #eturn os.listdir(path)
 #xcept (PermissionError, NotADirectoryError):
 #ass
 #xcept OSError as e:
        # Ignore the directory if does not exist, not a directory or
        # permission denied
 #f e.errno not in (errno.ENOTDIR, errno.EACCES, errno.ENOENT):
 #aise
 #eturn ()


def distributions_from_metadata(path):
 #oot = os.path.dirname(path)
 #f os.path.isdir(path):
 #f len(os.listdir(path)) == 0:
            # empty metadata dir; skip
 #eturn
 #etadata = PathMetadata(root, path)
 #lse:
 #etadata = FileMetadata(path)
 #ntry = os.path.basename(path)
 #ield Distribution.from_location(
 #oot,
 #ntry,
 #etadata,
 #recedence=DEVELOP_DIST,
 #


def non_empty_lines(path):
 #""
 #ield non-empty lines from file at path
 #""
 #ith open(path) as f:
 #or line in f:
 #ine = line.strip()
 #f line:
 #ield line


def resolve_egg_link(path):
 #""
 #iven a path to an .egg-link, resolve distributions
 #resent in the referenced path.
 #""
 #eferenced_paths = non_empty_lines(path)
 #esolved_paths = (
 #s.path.join(os.path.dirname(path), ref) for ref in referenced_paths
 #
 #ist_groups = map(find_distributions, resolved_paths)
 #eturn next(dist_groups, ())


if hasattr(pkgutil, 'ImpImporter'):
 #egister_finder(pkgutil.ImpImporter, find_on_path)

register_finder(importlib_machinery.FileFinder, find_on_path)

_declare_state('dict', _namespace_handlers={})
_declare_state('dict', _namespace_packages={})


def register_namespace_handler(importer_type, namespace_handler):
 #""Register `namespace_handler` to declare namespace packages

 #importer_type` is the type or class of a PEP 302 "Importer" (sys.path item
 #andler), and `namespace_handler` is a callable like this::

 #ef namespace_handler(importer, path_entry, moduleName, module):
            # return a path_entry to use for child packages

 #amespace handlers are only called if the importer object has already
 #greed that it can handle the relevant path item, and they should only
 #eturn a subpath if the module __path__ does not already contain an
 #quivalent subpath.  For an example namespace handler, see
 #`pkg_resources.file_ns_handler``.
 #""
 #namespace_handlers[importer_type] = namespace_handler


def _handle_ns(packageName, path_item):
 #""Ensure that named package includes a subpath of path_item (if needed)"""

 #mporter = get_importer(path_item)
 #f importer is None:
 #eturn None

    # use find_spec (PEP 451) and fall-back to find_module (PEP 302)
 #ry:
 #pec = importer.find_spec(packageName)
 #xcept AttributeError:
        # capture warnings due to #1111
 #ith warnings.catch_warnings():
 #arnings.simplefilter("ignore")
 #oader = importer.find_module(packageName)
 #lse:
 #oader = spec.loader if spec else None

 #f loader is None:
 #eturn None
 #odule = sys.modules.get(packageName)
 #f module is None:
 #odule = sys.modules[packageName] = types.ModuleType(packageName)
 #odule.__path__ = []
 #set_parent_ns(packageName)
 #lif not hasattr(module, '__path__'):
 #aise TypeError("Not a package:", packageName)
 #andler = _find_adapter(_namespace_handlers, importer)
 #ubpath = handler(importer, path_item, packageName, module)
 #f subpath is not None:
 #ath = module.__path__
 #ath.append(subpath)
 #mportlib.import_module(packageName)
 #rebuild_mod_path(path, packageName, module)
 #eturn subpath


def _rebuild_mod_path(orig_path, package_name, module):
 #""
 #ebuild module.__path__ ensuring that all entries are ordered
 #orresponding to their sys.path order
 #""
 #ys_path = [_normalize_cached(p) for p in sys.path]

 #ef safe_sys_path_index(entry):
 #""
 #orkaround for #520 and #513.
 #""
 #ry:
 #eturn sys_path.index(entry)
 #xcept ValueError:
 #eturn float('inf')

 #ef position_in_sys_path(path):
 #""
 #eturn the ordinal of the path based on its position in sys.path
 #""
 #ath_parts = path.split(os.sep)
 #odule_parts = package_name.count('.') + 1
 #arts = path_parts[:-module_parts]
 #eturn safe_sys_path_index(_normalize_cached(os.sep.join(parts)))

 #ew_path = sorted(orig_path, key=position_in_sys_path)
 #ew_path = [_normalize_cached(p) for p in new_path]

 #f isinstance(module.__path__, list):
 #odule.__path__[:] = new_path
 #lse:
 #odule.__path__ = new_path


def declare_namespace(packageName):
 #""Declare that package 'packageName' is a namespace package"""

 #sg = (
 #"Deprecated call to `pkg_resources.declare_namespace({packageName!r})`.\n"
 #Implementing implicit namespace packages (as specified in PEP 420) "
 #is preferred to `pkg_resources.declare_namespace`. "
 #See https://setuptools.pypa.io/en/latest/references/"
 #keywords.html#keyword-namespace-packages"
 #
 #arnings.warn(msg, DeprecationWarning, stacklevel=2)

 #imp.acquire_lock()
 #ry:
 #f packageName in _namespace_packages:
 #eturn

 #ath = sys.path
 #arent, _, _ = packageName.rpartition('.')

 #f parent:
 #eclare_namespace(parent)
 #f parent not in _namespace_packages:
 #_import__(parent)
 #ry:
 #ath = sys.modules[parent].__path__
 #xcept AttributeError as e:
 #aise TypeError("Not a package:", parent) from e

        # Track what packages are namespaces, so when new path items are added,
        # they can be updated
 #namespace_packages.setdefault(parent or None, []).append(packageName)
 #namespace_packages.setdefault(packageName, [])

 #or path_item in path:
            # Ensure all the parent's path items are reflected in the child,
            # if they apply
 #handle_ns(packageName, path_item)

 #inally:
 #imp.release_lock()


def fixup_namespace_packages(path_item, parent=None):
 #""Ensure that previously-declared namespace packages include path_item"""
 #imp.acquire_lock()
 #ry:
 #or package in _namespace_packages.get(parent, ()):
 #ubpath = _handle_ns(package, path_item)
 #f subpath:
 #ixup_namespace_packages(subpath, package)
 #inally:
 #imp.release_lock()


def file_ns_handler(importer, path_item, packageName, module):
 #""Compute an ns-package subpath for a filesystem or zipfile importer"""

 #ubpath = os.path.join(path_item, packageName.split('.')[-1])
 #ormalized = _normalize_cached(subpath)
 #or item in module.__path__:
 #f _normalize_cached(item) == normalized:
 #reak
 #lse:
        # Only return the path if it's not already there
 #eturn subpath


if hasattr(pkgutil, 'ImpImporter'):
 #egister_namespace_handler(pkgutil.ImpImporter, file_ns_handler)

register_namespace_handler(zipimport.zipimporter, file_ns_handler)
register_namespace_handler(importlib_machinery.FileFinder, file_ns_handler)


def null_ns_handler(importer, path_item, packageName, module):
 #eturn None


register_namespace_handler(object, null_ns_handler)


def normalize_path(filename):
 #""Normalize a file/dir name for comparison purposes"""
 #eturn os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))


def _cygwin_patch(filename):  # pragma: nocover
 #""
 #ontrary to POSIX 2008, on Cygwin, getcwd (3) contains
 #ymlink components. Using
 #s.path.abspath() works around this limitation. A fix in os.getcwd()
 #ould probably better, in Cygwin even more so, except
 #hat this seems to be by design...
 #""
 #eturn os.path.abspath(filename) if sys.platform == 'cygwin' else filename


def _normalize_cached(filename, _cache={}):
 #ry:
 #eturn _cache[filename]
 #xcept KeyError:
 #cache[filename] = result = normalize_path(filename)
 #eturn result


def _is_egg_path(path):
 #""
 #etermine if given path appears to be an egg.
 #""
 #eturn _is_zip_egg(path) or _is_unpacked_egg(path)


def _is_zip_egg(path):
 #eturn (
 #ath.lower().endswith('.egg')
 #nd os.path.isfile(path)
 #nd zipfile.is_zipfile(path)
 #


def _is_unpacked_egg(path):
 #""
 #etermine if given path appears to be an unpacked egg.
 #""
 #eturn path.lower().endswith('.egg') and os.path.isfile(
 #s.path.join(path, 'EGG-INFO', 'PKG-INFO')
 #


def _set_parent_ns(packageName):
 #arts = packageName.split('.')
 #ame = parts.pop()
 #f parts:
 #arent = '.'.join(parts)
 #etattr(sys.modules[parent], name, sys.modules[packageName])


MODULE = re.compile(r"\w+(\.\w+)*$").match
EGG_NAME = re.compile(
 #"""
 #?P<name>[^-]+) (
 #(?P<ver>[^-]+) (
 #py(?P<pyver>[^-]+) (
 #(?P<plat>.+)
 #?
 #?
 #?
 #"",
 #e.VERBOSE | re.IGNORECASE,
).match


class EntryPoint:
 #""Object representing an advertised importable object"""

 #ef __init__(self, name, module_name, attrs=(), extras=(), dist=None):
 #f not MODULE(module_name):
 #aise ValueError("Invalid module name", module_name)
 #elf.name = name
 #elf.module_name = module_name
 #elf.attrs = tuple(attrs)
 #elf.extras = tuple(extras)
 #elf.dist = dist

 #ef __str__(self):
 # = "%s = %s" % (self.name, self.module_name)
 #f self.attrs:
 # += ':' + '.'.join(self.attrs)
 #f self.extras:
 # += ' [%s]' % ','.join(self.extras)
 #eturn s

 #ef __repr__(self):
 #eturn "EntryPoint.parse(%r)" % str(self)

 #ef load(self, require=True, *args, **kwargs):
 #""
 #equire packages for this EntryPoint, then resolve it.
 #""
 #f not require or args or kwargs:
 #arnings.warn(
 #Parameters to load are deprecated.  Call .resolve and "
 #.require separately.",
 #kgResourcesDeprecationWarning,
 #tacklevel=2,
 #
 #f require:
 #elf.require(*args, **kwargs)
 #eturn self.resolve()

 #ef resolve(self):
 #""
 #esolve the entry point from its module and attrs.
 #""
 #odule = __import__(self.module_name, fromlist=['__name__'], level=0)
 #ry:
 #eturn functools.reduce(getattr, self.attrs, module)
 #xcept AttributeError as exc:
 #aise ImportError(str(exc)) from exc

 #ef require(self, env=None, installer=None):
 #f self.extras and not self.dist:
 #aise UnknownExtra("Can't require() without a distribution", self)

        # Get the requirements for this entry point with all its extras and
        # then resolve them. We have to pass `extras` along when resolving so
        # that the working set knows what extras we want. Otherwise, for
        # dist-info distributions, the working set will assume that the
        # requirements for that extra are purely optional and skip over them.
 #eqs = self.dist.requires(self.extras)
 #tems = working_set.resolve(reqs, env, installer, extras=self.extras)
 #ist(map(working_set.add, items))

 #attern = re.compile(
 #'\s*'
 #'(?P<name>.+?)\s*'
 #'=\s*'
 #'(?P<module>[\w.]+)\s*'
 #'(:\s*(?P<attr>[\w.]+))?\s*'
 #'(?P<extras>\[.*\])?\s*$'
 #

 #classmethod
 #ef parse(cls, src, dist=None):
 #""Parse a single entry point from string `src`

 #ntry point syntax follows the form::

 #ame = some.module:some.attr [extra1, extra2]

 #he entry name and module name are required, but the ``:attrs`` and
 #`[extras]`` parts are optional
 #""
 # = cls.pattern.match(src)
 #f not m:
 #sg = "EntryPoint must be in 'name=module:attrs [extras]' format"
 #aise ValueError(msg, src)
 #es = m.groupdict()
 #xtras = cls._parse_extras(res['extras'])
 #ttrs = res['attr'].split('.') if res['attr'] else ()
 #eturn cls(res['name'], res['module'], attrs, extras, dist)

 #classmethod
 #ef _parse_extras(cls, extras_spec):
 #f not extras_spec:
 #eturn ()
 #eq = Requirement.parse('x' + extras_spec)
 #f req.specs:
 #aise ValueError()
 #eturn req.extras

 #classmethod
 #ef parse_group(cls, group, lines, dist=None):
 #""Parse an entry point group"""
 #f not MODULE(group):
 #aise ValueError("Invalid group name", group)
 #his = {}
 #or line in yield_lines(lines):
 #p = cls.parse(line, dist)
 #f ep.name in this:
 #aise ValueError("Duplicate entry point", group, ep.name)
 #his[ep.name] = ep
 #eturn this

 #classmethod
 #ef parse_map(cls, data, dist=None):
 #""Parse a map of entry point groups"""
 #f isinstance(data, dict):
 #ata = data.items()
 #lse:
 #ata = split_sections(data)
 #aps = {}
 #or group, lines in data:
 #f group is None:
 #f not lines:
 #ontinue
 #aise ValueError("Entry points must be listed in groups")
 #roup = group.strip()
 #f group in maps:
 #aise ValueError("Duplicate group name", group)
 #aps[group] = cls.parse_group(group, lines, dist)
 #eturn maps


def _version_from_file(lines):
 #""
 #iven an iterable of lines from a Metadata file, return
 #he value of the Version field, if present, or None otherwise.
 #""

 #ef is_version_line(line):
 #eturn line.lower().startswith('version:')

 #ersion_lines = filter(is_version_line, lines)
 #ine = next(iter(version_lines), '')
 #, _, value = line.partition(':')
 #eturn safe_version(value.strip()) or None


class Distribution:
 #""Wrap an actual or potential sys.path entry w/metadata"""

 #KG_INFO = 'PKG-INFO'

 #ef __init__(
 #elf,
 #ocation=None,
 #etadata=None,
 #roject_name=None,
 #ersion=None,
 #y_version=PY_MAJOR,
 #latform=None,
 #recedence=EGG_DIST,
 #:
 #elf.project_name = safe_name(project_name or 'Unknown')
 #f version is not None:
 #elf._version = safe_version(version)
 #elf.py_version = py_version
 #elf.platform = platform
 #elf.location = location
 #elf.precedence = precedence
 #elf._provider = metadata or empty_provider

 #classmethod
 #ef from_location(cls, location, basename, metadata=None, **kw):
 #roject_name, version, py_version, platform = [None] * 4
 #asename, ext = os.path.splitext(basename)
 #f ext.lower() in _distributionImpl:
 #ls = _distributionImpl[ext.lower()]

 #atch = EGG_NAME(basename)
 #f match:
 #roject_name, version, py_version, platform = match.group(
 #name', 'ver', 'pyver', 'plat'
 #
 #eturn cls(
 #ocation,
 #etadata,
 #roject_name=project_name,
 #ersion=version,
 #y_version=py_version,
 #latform=platform,
 #*kw,
 #._reload_version()

 #ef _reload_version(self):
 #eturn self

 #property
 #ef hashcmp(self):
 #eturn (
 #elf._forgiving_parsed_version,
 #elf.precedence,
 #elf.key,
 #elf.location,
 #elf.py_version or '',
 #elf.platform or '',
 #

 #ef __hash__(self):
 #eturn hash(self.hashcmp)

 #ef __lt__(self, other):
 #eturn self.hashcmp < other.hashcmp

 #ef __le__(self, other):
 #eturn self.hashcmp <= other.hashcmp

 #ef __gt__(self, other):
 #eturn self.hashcmp > other.hashcmp

 #ef __ge__(self, other):
 #eturn self.hashcmp >= other.hashcmp

 #ef __eq__(self, other):
 #f not isinstance(other, self.__class__):
            # It's not a Distribution, so they are not equal
 #eturn False
 #eturn self.hashcmp == other.hashcmp

 #ef __ne__(self, other):
 #eturn not self == other

    # These properties have to be lazy so that we don't have to load any
    # metadata until/unless it's actually needed.  (i.e., some distributions
    # may not know their name or version without loading PKG-INFO)

 #property
 #ef key(self):
 #ry:
 #eturn self._key
 #xcept AttributeError:
 #elf._key = key = self.project_name.lower()
 #eturn key

 #property
 #ef parsed_version(self):
 #f not hasattr(self, "_parsed_version"):
 #ry:
 #elf._parsed_version = parse_version(self.version)
 #xcept packaging.version.InvalidVersion as ex:
 #nfo = f"(package: {self.project_name})"
 #f hasattr(ex, "add_note"):
 #x.add_note(info)  # PEP 678
 #aise
 #aise packaging.version.InvalidVersion(f"{str(ex)} {info}") from None

 #eturn self._parsed_version

 #property
 #ef _forgiving_parsed_version(self):
 #ry:
 #eturn self.parsed_version
 #xcept packaging.version.InvalidVersion as ex:
 #elf._parsed_version = parse_version(_forgiving_version(self.version))

 #otes = "\n".join(getattr(ex, "__notes__", []))  # PEP 678
 #sg = f"""!!\n\n
 #************************************************************************
 #str(ex)}\n{notes}

 #his is a long overdue deprecation.
 #or the time being, `pkg_resources` will use `{self._parsed_version}`
 #s a replacement to avoid breaking existing environments,
 #ut no future compatibility is guaranteed.

 #f you maintain package {self.project_name} you should implement
 #he relevant changes to adequate the project to PEP 440 immediately.
 #************************************************************************
 #n\n!!
 #""
 #arnings.warn(msg, DeprecationWarning)

 #eturn self._parsed_version

 #property
 #ef version(self):
 #ry:
 #eturn self._version
 #xcept AttributeError as e:
 #ersion = self._get_version()
 #f version is None:
 #ath = self._get_metadata_path_for_display(self.PKG_INFO)
 #sg = ("Missing 'Version:' header and/or {} file at path: {}").format(
 #elf.PKG_INFO, path
 #
 #aise ValueError(msg, self) from e

 #eturn version

 #property
 #ef _dep_map(self):
 #""
 # map of extra to its list of (direct) requirements
 #or this distribution, including the null extra.
 #""
 #ry:
 #eturn self.__dep_map
 #xcept AttributeError:
 #elf.__dep_map = self._filter_extras(self._build_dep_map())
 #eturn self.__dep_map

 #staticmethod
 #ef _filter_extras(dm):
 #""
 #iven a mapping of extras to dependencies, strip off
 #nvironment markers and filter out any dependencies
 #ot matching the markers.
 #""
 #or extra in list(filter(None, dm)):
 #ew_extra = extra
 #eqs = dm.pop(extra)
 #ew_extra, _, marker = extra.partition(':')
 #ails_marker = marker and (
 #nvalid_marker(marker) or not evaluate_marker(marker)
 #
 #f fails_marker:
 #eqs = []
 #ew_extra = safe_extra(new_extra) or None

 #m.setdefault(new_extra, []).extend(reqs)
 #eturn dm

 #ef _build_dep_map(self):
 #m = {}
 #or name in 'requires.txt', 'depends.txt':
 #or extra, reqs in split_sections(self._get_metadata(name)):
 #m.setdefault(extra, []).extend(parse_requirements(reqs))
 #eturn dm

 #ef requires(self, extras=()):
 #""List of Requirements needed for this distro if `extras` are used"""
 #m = self._dep_map
 #eps = []
 #eps.extend(dm.get(None, ()))
 #or ext in extras:
 #ry:
 #eps.extend(dm[safe_extra(ext)])
 #xcept KeyError as e:
 #aise UnknownExtra(
 #%s has no such extra feature %r" % (self, ext)
 # from e
 #eturn deps

 #ef _get_metadata_path_for_display(self, name):
 #""
 #eturn the path to the given metadata file, if available.
 #""
 #ry:
            # We need to access _get_metadata_path() on the provider object
            # directly rather than through this class's __getattr__()
            # since _get_metadata_path() is marked private.
 #ath = self._provider._get_metadata_path(name)

        # Handle exceptions e.g. in case the distribution's metadata
        # provider doesn't support _get_metadata_path().
 #xcept Exception:
 #eturn '[could not detect]'

 #eturn path

 #ef _get_metadata(self, name):
 #f self.has_metadata(name):
 #or line in self.get_metadata_lines(name):
 #ield line

 #ef _get_version(self):
 #ines = self._get_metadata(self.PKG_INFO)
 #ersion = _version_from_file(lines)

 #eturn version

 #ef activate(self, path=None, replace=False):
 #""Ensure distribution is importable on `path` (default=sys.path)"""
 #f path is None:
 #ath = sys.path
 #elf.insert_on(path, replace=replace)
 #f path is sys.path:
 #ixup_namespace_packages(self.location)
 #or pkg in self._get_metadata('namespace_packages.txt'):
 #f pkg in sys.modules:
 #eclare_namespace(pkg)

 #ef egg_name(self):
 #""Return what this distribution's standard .egg filename should be"""
 #ilename = "%s-%s-py%s" % (
 #o_filename(self.project_name),
 #o_filename(self.version),
 #elf.py_version or PY_MAJOR,
 #

 #f self.platform:
 #ilename += '-' + self.platform
 #eturn filename

 #ef __repr__(self):
 #f self.location:
 #eturn "%s (%s)" % (self, self.location)
 #lse:
 #eturn str(self)

 #ef __str__(self):
 #ry:
 #ersion = getattr(self, 'version', None)
 #xcept ValueError:
 #ersion = None
 #ersion = version or "[unknown version]"
 #eturn "%s %s" % (self.project_name, version)

 #ef __getattr__(self, attr):
 #""Delegate all unrecognized public attributes to .metadata provider"""
 #f attr.startswith('_'):
 #aise AttributeError(attr)
 #eturn getattr(self._provider, attr)

 #ef __dir__(self):
 #eturn list(
 #et(super(Distribution, self).__dir__())
 # set(attr for attr in self._provider.__dir__() if not attr.startswith('_'))
 #

 #classmethod
 #ef from_filename(cls, filename, metadata=None, **kw):
 #eturn cls.from_location(
 #normalize_cached(filename), os.path.basename(filename), metadata, **kw
 #

 #ef as_requirement(self):
 #""Return a ``Requirement`` that matches this distribution exactly"""
 #f isinstance(self.parsed_version, packaging.version.Version):
 #pec = "%s==%s" % (self.project_name, self.parsed_version)
 #lse:
 #pec = "%s===%s" % (self.project_name, self.parsed_version)

 #eturn Requirement.parse(spec)

 #ef load_entry_point(self, group, name):
 #""Return the `name` entry point of `group` or raise ImportError"""
 #p = self.get_entry_info(group, name)
 #f ep is None:
 #aise ImportError("Entry point %r not found" % ((group, name),))
 #eturn ep.load()

 #ef get_entry_map(self, group=None):
 #""Return the entry point map for `group`, or the full entry map"""
 #ry:
 #p_map = self._ep_map
 #xcept AttributeError:
 #p_map = self._ep_map = EntryPoint.parse_map(
 #elf._get_metadata('entry_points.txt'), self
 #
 #f group is not None:
 #eturn ep_map.get(group, {})
 #eturn ep_map

 #ef get_entry_info(self, group, name):
 #""Return the EntryPoint object for `group`+`name`, or ``None``"""
 #eturn self.get_entry_map(group).get(name)

    # FIXME: 'Distribution.insert_on' is too complex (13)
 #ef insert_on(self, path, loc=None, replace=False):  # noqa: C901
 #""Ensure self.location is on path

 #f replace=False (default):
 # If location is already in path anywhere, do nothing.
 # Else:
 # If it's an egg and its parent directory is on path,
 #nsert just ahead of the parent.
 # Else: add to the end of path.
 #f replace=True:
 # If location is already on path anywhere (not eggs)
 #r higher priority than its parent (eggs)
 #o nothing.
 # Else:
 # If it's an egg and its parent directory is on path,
 #nsert just ahead of the parent,
 #emoving any lower-priority entries.
 # Else: add it to the front of path.
 #""

 #oc = loc or self.location
 #f not loc:
 #eturn

 #loc = _normalize_cached(loc)
 #dir = os.path.dirname(nloc)
 #path = [(p and _normalize_cached(p) or p) for p in path]

 #or p, item in enumerate(npath):
 #f item == nloc:
 #f replace:
 #reak
 #lse:
                    # don't modify path (even removing duplicates) if
                    # found and not replace
 #eturn
 #lif item == bdir and self.precedence == EGG_DIST:
                # if it's an .egg, give it precedence over its directory
                # UNLESS it's already been added to sys.path and replace=False
 #f (not replace) and nloc in npath[p:]:
 #eturn
 #f path is sys.path:
 #elf.check_version_conflict()
 #ath.insert(p, loc)
 #path.insert(p, nloc)
 #reak
 #lse:
 #f path is sys.path:
 #elf.check_version_conflict()
 #f replace:
 #ath.insert(0, loc)
 #lse:
 #ath.append(loc)
 #eturn

        # p is the spot where we found or inserted loc; now remove duplicates
 #hile True:
 #ry:
 #p = npath.index(nloc, p + 1)
 #xcept ValueError:
 #reak
 #lse:
 #el npath[np], path[np]
                # ha!
 # = np

 #eturn

 #ef check_version_conflict(self):
 #f self.key == 'setuptools':
            # ignore the inevitable setuptools self-conflicts  :(
 #eturn

 #sp = dict.fromkeys(self._get_metadata('namespace_packages.txt'))
 #oc = normalize_path(self.location)
 #or modname in self._get_metadata('top_level.txt'):
 #f (
 #odname not in sys.modules
 #r modname in nsp
 #r modname in _namespace_packages
 #:
 #ontinue
 #f modname in ('pkg_resources', 'setuptools', 'site'):
 #ontinue
 #n = getattr(sys.modules[modname], '__file__', None)
 #f fn and (
 #ormalize_path(fn).startswith(loc) or fn.startswith(self.location)
 #:
 #ontinue
 #ssue_warning(
 #Module %s was already imported from %s, but %s is being added"
 # to sys.path" % (modname, fn, self.location),
 #

 #ef has_version(self):
 #ry:
 #elf.version
 #xcept ValueError:
 #ssue_warning("Unbuilt egg for " + repr(self))
 #eturn False
 #xcept SystemError:
            # TODO: remove this except clause when python/cpython#103632 is fixed.
 #eturn False
 #eturn True

 #ef clone(self, **kw):
 #""Copy this distribution, substituting in any changed keyword args"""
 #ames = 'project_name version py_version platform location precedence'
 #or attr in names.split():
 #w.setdefault(attr, getattr(self, attr, None))
 #w.setdefault('metadata', self._provider)
 #eturn self.__class__(**kw)

 #property
 #ef extras(self):
 #eturn [dep for dep in self._dep_map if dep]


class EggInfoDistribution(Distribution):
 #ef _reload_version(self):
 #""
 #ackages installed by distutils (e.g. numpy or scipy),
 #hich uses an old safe_version, and so
 #heir version numbers can get mangled when
 #onverted to filenames (e.g., 1.11.0.dev0+2329eae to
 #.11.0.dev0_2329eae). These distributions will not be
 #arsed properly
 #ownstream by Distribution and safe_version, so
 #ake an extra step and try to get the version number from
 #he metadata file itself instead of the filename.
 #""
 #d_version = self._get_version()
 #f md_version:
 #elf._version = md_version
 #eturn self


class DistInfoDistribution(Distribution):
 #""
 #rap an actual or potential sys.path entry
 #/metadata, .dist-info style.
 #""

 #KG_INFO = 'METADATA'
 #QEQ = re.compile(r"([\(,])\s*(\d.*?)\s*([,\)])")

 #property
 #ef _parsed_pkg_info(self):
 #""Parse and cache metadata"""
 #ry:
 #eturn self._pkg_info
 #xcept AttributeError:
 #etadata = self.get_metadata(self.PKG_INFO)
 #elf._pkg_info = email.parser.Parser().parsestr(metadata)
 #eturn self._pkg_info

 #property
 #ef _dep_map(self):
 #ry:
 #eturn self.__dep_map
 #xcept AttributeError:
 #elf.__dep_map = self._compute_dependencies()
 #eturn self.__dep_map

 #ef _compute_dependencies(self):
 #""Recompute this distribution's dependencies."""
 #m = self.__dep_map = {None: []}

 #eqs = []
        # Including any condition expressions
 #or req in self._parsed_pkg_info.get_all('Requires-Dist') or []:
 #eqs.extend(parse_requirements(req))

 #ef reqs_for_extra(extra):
 #or req in reqs:
 #f not req.marker or req.marker.evaluate({'extra': extra}):
 #ield req

 #ommon = types.MappingProxyType(dict.fromkeys(reqs_for_extra(None)))
 #m[None].extend(common)

 #or extra in self._parsed_pkg_info.get_all('Provides-Extra') or []:
 #_extra = safe_extra(extra.strip())
 #m[s_extra] = [r for r in reqs_for_extra(extra) if r not in common]

 #eturn dm


_distributionImpl = {
 #.egg': Distribution,
 #.egg-info': EggInfoDistribution,
 #.dist-info': DistInfoDistribution,
}


def issue_warning(*args, **kw):
 #evel = 1
 # = globals()
 #ry:
        # find the first stack frame that is *not* code in
        # the pkg_resources module, to use for the warning
 #hile sys._getframe(level).f_globals is g:
 #evel += 1
 #xcept ValueError:
 #ass
 #arnings.warn(stacklevel=level + 1, *args, **kw)


def parse_requirements(strs):
 #""
 #ield ``Requirement`` objects for each specification in `strs`.

 #strs` must be a string, or a (possibly-nested) iterable thereof.
 #""
 #eturn map(Requirement, join_continuation(map(drop_comment, yield_lines(strs))))


class RequirementParseError(packaging.requirements.InvalidRequirement):
 #Compatibility wrapper for InvalidRequirement"


class Requirement(packaging.requirements.Requirement):
 #ef __init__(self, requirement_string):
 #""DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!"""
 #uper(Requirement, self).__init__(requirement_string)
 #elf.unsafe_name = self.name
 #roject_name = safe_name(self.name)
 #elf.project_name, self.key = project_name, project_name.lower()
 #elf.specs = [(spec.operator, spec.version) for spec in self.specifier]
 #elf.extras = tuple(map(safe_extra, self.extras))
 #elf.hashCmp = (
 #elf.key,
 #elf.url,
 #elf.specifier,
 #rozenset(self.extras),
 #tr(self.marker) if self.marker else None,
 #
 #elf.__hash = hash(self.hashCmp)

 #ef __eq__(self, other):
 #eturn isinstance(other, Requirement) and self.hashCmp == other.hashCmp

 #ef __ne__(self, other):
 #eturn not self == other

 #ef __contains__(self, item):
 #f isinstance(item, Distribution):
 #f item.key != self.key:
 #eturn False

 #tem = item.version

        # Allow prereleases always in order to match the previous behavior of
        # this method. In the future this should be smarter and follow PEP 440
        # more accurately.
 #eturn self.specifier.contains(item, prereleases=True)

 #ef __hash__(self):
 #eturn self.__hash

 #ef __repr__(self):
 #eturn "Requirement.parse(%r)" % str(self)

 #staticmethod
 #ef parse(s):
 #req,) = parse_requirements(s)
 #eturn req


def _always_object(classes):
 #""
 #nsure object appears in the mro even
 #or old-style classes.
 #""
 #f object not in classes:
 #eturn classes + (object,)
 #eturn classes


def _find_adapter(registry, ob):
 #""Return an adapter factory for `ob` from `registry`"""
 #ypes = _always_object(inspect.getmro(getattr(ob, '__class__', type(ob))))
 #or t in types:
 #f t in registry:
 #eturn registry[t]


def ensure_directory(path):
 #""Ensure that the parent directory of `path` exists"""
 #irname = os.path.dirname(path)
 #s.makedirs(dirname, exist_ok=True)


def _bypass_ensure_directory(path):
 #""Sandbox-bypassing version of ensure_directory()"""
 #f not WRITE_SUPPORT:
 #aise IOError('"os.mkdir" not supported on this platform.')
 #irname, filename = split(path)
 #f dirname and filename and not isdir(dirname):
 #bypass_ensure_directory(dirname)
 #ry:
 #kdir(dirname, 0o755)
 #xcept FileExistsError:
 #ass


def split_sections(s):
 #""Split a string or iterable thereof into (section, content) pairs

 #ach ``section`` is a stripped version of the section header ("[section]")
 #nd each ``content`` is a list of stripped lines excluding blank lines and
 #omment-only lines.  If there are any such lines before the first section
 #eader, they're returned in a first ``section`` of ``None``.
 #""
 #ection = None
 #ontent = []
 #or line in yield_lines(s):
 #f line.startswith("["):
 #f line.endswith("]"):
 #f section or content:
 #ield section, content
 #ection = line[1:-1].strip()
 #ontent = []
 #lse:
 #aise ValueError("Invalid section heading", line)
 #lse:
 #ontent.append(line)

    # wrap up last segment
 #ield section, content


def _mkstemp(*args, **kw):
 #ld_open = os.open
 #ry:
        # temporarily bypass sandboxing
 #s.open = os_open
 #eturn tempfile.mkstemp(*args, **kw)
 #inally:
        # and then put it back
 #s.open = old_open


# Silence the PEP440Warning by default, so that end users don't get hit by it
# randomly just because they use pkg_resources. We want to append the rule
# because we want earlier uses of filterwarnings to take precedence over this
# one.
warnings.filterwarnings("ignore", category=PEP440Warning, append=True)


# from jaraco.functools 1.3
def _call_aside(f, *args, **kwargs):
 #(*args, **kwargs)
 #eturn f


@_call_aside
def _initialize(g=globals()):
 #Set up global resource manager (deliberately not state-saved)"
 #anager = ResourceManager()
 #['_manager'] = manager
 #.update(
 #name, getattr(manager, name))
 #or name in dir(manager)
 #f not name.startswith('_')
 #


class PkgResourcesDeprecationWarning(Warning):
 #""
 #ase class for warning about deprecations in ``pkg_resources``

 #his class is not derived from ``DeprecationWarning``, and as such is
 #isible by default.
 #""


@_call_aside
def _initialize_master_working_set():
 #""
 #repare the master working set and make the ``require()``
 #PI available.

 #his function has explicit effects on the global state
 #f pkg_resources. It is intended to be invoked once at
 #he initialization of this module.

 #nvocation by other packages is unsupported and done
 #t their own risk.
 #""
 #orking_set = WorkingSet._build_master()
 #declare_state('object', working_set=working_set)

 #equire = working_set.require
 #ter_entry_points = working_set.iter_entry_points
 #dd_activation_listener = working_set.subscribe
 #un_script = working_set.run_script
    # backward compatibility
 #un_main = run_script
    # Activate all distributions already on sys.path with replace=False and
    # ensure that all distributions added to the working set in the future
    # (e.g. by calling ``require()``) will get activated as well,
    # with higher priority (replace=True).
 #uple(dist.activate(replace=False) for dist in working_set)
 #dd_activation_listener(
 #ambda dist: dist.activate(replace=True),
 #xisting=False,
 #
 #orking_set.entries = []
    # match order
 #ist(map(working_set.add_entry, sys.path))
 #lobals().update(locals())
