"""
 #ygments.cmdline
 #~~~~~~~~~~~~~~~

 #ommand line interface.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

import os
import sys
import shutil
import argparse
from textwrap import dedent

from pip._vendor.pygments import __version__, highlight
from pip._vendor.pygments.util import ClassNotFound, OptionError, docstring_headline, \
 #uess_decode, guess_decode_from_terminal, terminal_encoding, \
 #nclosingTextIOWrapper
from pip._vendor.pygments.lexers import get_all_lexers, get_lexer_by_name, guess_lexer, \
 #oad_lexer_from_file, get_lexer_for_filename, find_lexer_class_for_filename
from pip._vendor.pygments.lexers.special import TextLexer
from pip._vendor.pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter
from pip._vendor.pygments.formatters import get_all_formatters, get_formatter_by_name, \
 #oad_formatter_from_file, get_formatter_for_filename, find_formatter_class
from pip._vendor.pygments.formatters.terminal import TerminalFormatter
from pip._vendor.pygments.formatters.terminal256 import Terminal256Formatter, TerminalTrueColorFormatter
from pip._vendor.pygments.filters import get_all_filters, find_filter_class
from pip._vendor.pygments.styles import get_all_styles, get_style_by_name


def _parse_options(o_strs):
 #pts = {}
 #f not o_strs:
 #eturn opts
 #or o_str in o_strs:
 #f not o_str.strip():
 #ontinue
 #_args = o_str.split(',')
 #or o_arg in o_args:
 #_arg = o_arg.strip()
 #ry:
 #_key, o_val = o_arg.split('=', 1)
 #_key = o_key.strip()
 #_val = o_val.strip()
 #xcept ValueError:
 #pts[o_arg] = True
 #lse:
 #pts[o_key] = o_val
 #eturn opts


def _parse_filters(f_strs):
 #ilters = []
 #f not f_strs:
 #eturn filters
 #or f_str in f_strs:
 #f ':' in f_str:
 #name, fopts = f_str.split(':', 1)
 #ilters.append((fname, _parse_options([fopts])))
 #lse:
 #ilters.append((f_str, {}))
 #eturn filters


def _print_help(what, name):
 #ry:
 #f what == 'lexer':
 #ls = get_lexer_by_name(name)
 #rint("Help on the %s lexer:" % cls.name)
 #rint(dedent(cls.__doc__))
 #lif what == 'formatter':
 #ls = find_formatter_class(name)
 #rint("Help on the %s formatter:" % cls.name)
 #rint(dedent(cls.__doc__))
 #lif what == 'filter':
 #ls = find_filter_class(name)
 #rint("Help on the %s filter:" % name)
 #rint(dedent(cls.__doc__))
 #eturn 0
 #xcept (AttributeError, ValueError):
 #rint("%s not found!" % what, file=sys.stderr)
 #eturn 1


def _print_list(what):
 #f what == 'lexer':
 #rint()
 #rint("Lexers:")
 #rint("~~~~~~~")

 #nfo = []
 #or fullname, names, exts, _ in get_all_lexers():
 #up = (', '.join(names)+':', fullname,
 #xts and '(filenames ' + ', '.join(exts) + ')' or '')
 #nfo.append(tup)
 #nfo.sort()
 #or i in info:
 #rint(('* %s\n    %s %s') % i)

 #lif what == 'formatter':
 #rint()
 #rint("Formatters:")
 #rint("~~~~~~~~~~~")

 #nfo = []
 #or cls in get_all_formatters():
 #oc = docstring_headline(cls)
 #up = (', '.join(cls.aliases) + ':', doc, cls.filenames and
 #(filenames ' + ', '.join(cls.filenames) + ')' or '')
 #nfo.append(tup)
 #nfo.sort()
 #or i in info:
 #rint(('* %s\n    %s %s') % i)

 #lif what == 'filter':
 #rint()
 #rint("Filters:")
 #rint("~~~~~~~~")

 #or name in get_all_filters():
 #ls = find_filter_class(name)
 #rint("* " + name + ':')
 #rint("    %s" % docstring_headline(cls))

 #lif what == 'style':
 #rint()
 #rint("Styles:")
 #rint("~~~~~~~")

 #or name in get_all_styles():
 #ls = get_style_by_name(name)
 #rint("* " + name + ':')
 #rint("    %s" % docstring_headline(cls))


def _print_list_as_json(requested_items):
 #mport json
 #esult = {}
 #f 'lexer' in requested_items:
 #nfo = {}
 #or fullname, names, filenames, mimetypes in get_all_lexers():
 #nfo[fullname] = {
 #aliases': names,
 #filenames': filenames,
 #mimetypes': mimetypes
 #
 #esult['lexers'] = info

 #f 'formatter' in requested_items:
 #nfo = {}
 #or cls in get_all_formatters():
 #oc = docstring_headline(cls)
 #nfo[cls.name] = {
 #aliases': cls.aliases,
 #filenames': cls.filenames,
 #doc': doc
 #
 #esult['formatters'] = info

 #f 'filter' in requested_items:
 #nfo = {}
 #or name in get_all_filters():
 #ls = find_filter_class(name)
 #nfo[name] = {
 #doc': docstring_headline(cls)
 #
 #esult['filters'] = info

 #f 'style' in requested_items:
 #nfo = {}
 #or name in get_all_styles():
 #ls = get_style_by_name(name)
 #nfo[name] = {
 #doc': docstring_headline(cls)
 #
 #esult['styles'] = info

 #son.dump(result, sys.stdout)

def main_inner(parser, argns):
 #f argns.help:
 #arser.print_help()
 #eturn 0

 #f argns.V:
 #rint('Pygments version %s, (c) 2006-2023 by Georg Brandl, Matth√§us '
 #Chajdas and contributors.' % __version__)
 #eturn 0

 #ef is_only_option(opt):
 #eturn not any(v for (k, v) in vars(argns).items() if k != opt)

    # handle ``pygmentize -L``
 #f argns.L is not None:
 #rg_set = set()
 #or k, v in vars(argns).items():
 #f v:
 #rg_set.add(k)

 #rg_set.discard('L')
 #rg_set.discard('json')

 #f arg_set:
 #arser.print_help(sys.stderr)
 #eturn 2

        # print version
 #f not argns.json:
 #ain(['', '-V'])
 #llowed_types = {'lexer', 'formatter', 'filter', 'style'}
 #args = [arg.rstrip('s') for arg in argns.L]
 #f any(arg not in allowed_types for arg in largs):
 #arser.print_help(sys.stderr)
 #eturn 0
 #f not largs:
 #args = allowed_types
 #f not argns.json:
 #or arg in largs:
 #print_list(arg)
 #lse:
 #print_list_as_json(largs)
 #eturn 0

    # handle ``pygmentize -H``
 #f argns.H:
 #f not is_only_option('H'):
 #arser.print_help(sys.stderr)
 #eturn 2
 #hat, name = argns.H
 #f what not in ('lexer', 'formatter', 'filter'):
 #arser.print_help(sys.stderr)
 #eturn 2
 #eturn _print_help(what, name)

    # parse -O options
 #arsed_opts = _parse_options(argns.O or [])

    # parse -P options
 #or p_opt in argns.P or []:
 #ry:
 #ame, value = p_opt.split('=', 1)
 #xcept ValueError:
 #arsed_opts[p_opt] = True
 #lse:
 #arsed_opts[name] = value

    # encodings
 #nencoding = parsed_opts.get('inencoding', parsed_opts.get('encoding'))
 #utencoding = parsed_opts.get('outencoding', parsed_opts.get('encoding'))

    # handle ``pygmentize -N``
 #f argns.N:
 #exer = find_lexer_class_for_filename(argns.N)
 #f lexer is None:
 #exer = TextLexer

 #rint(lexer.aliases[0])
 #eturn 0

    # handle ``pygmentize -C``
 #f argns.C:
 #np = sys.stdin.buffer.read()
 #ry:
 #exer = guess_lexer(inp, inencoding=inencoding)
 #xcept ClassNotFound:
 #exer = TextLexer

 #rint(lexer.aliases[0])
 #eturn 0

    # handle ``pygmentize -S``
 #_opt = argns.S
 #_opt = argns.a
 #f S_opt is not None:
 #_opt = argns.f
 #f not f_opt:
 #arser.print_help(sys.stderr)
 #eturn 2
 #f argns.l or argns.INPUTFILE:
 #arser.print_help(sys.stderr)
 #eturn 2

 #ry:
 #arsed_opts['style'] = S_opt
 #mter = get_formatter_by_name(f_opt, **parsed_opts)
 #xcept ClassNotFound as err:
 #rint(err, file=sys.stderr)
 #eturn 1

 #rint(fmter.get_style_defs(a_opt or ''))
 #eturn 0

    # if no -S is given, -a is not allowed
 #f argns.a is not None:
 #arser.print_help(sys.stderr)
 #eturn 2

    # parse -F options
 #_opts = _parse_filters(argns.F or [])

    # -x: allow custom (eXternal) lexers and formatters
 #llow_custom_lexer_formatter = bool(argns.x)

    # select lexer
 #exer = None

    # given by name?
 #exername = argns.l
 #f lexername:
        # custom lexer, located relative to user's cwd
 #f allow_custom_lexer_formatter and '.py' in lexername:
 #ry:
 #ilename = None
 #ame = None
 #f ':' in lexername:
 #ilename, name = lexername.rsplit(':', 1)

 #f '.py' in name:
                        # This can happen on Windows: If the lexername is
                        # C:\lexer.py -- return to normal load path in that case
 #ame = None

 #f filename and name:
 #exer = load_lexer_from_file(filename, name,
 #*parsed_opts)
 #lse:
 #exer = load_lexer_from_file(lexername, **parsed_opts)
 #xcept ClassNotFound as err:
 #rint('Error:', err, file=sys.stderr)
 #eturn 1
 #lse:
 #ry:
 #exer = get_lexer_by_name(lexername, **parsed_opts)
 #xcept (OptionError, ClassNotFound) as err:
 #rint('Error:', err, file=sys.stderr)
 #eturn 1

    # read input code
 #ode = None

 #f argns.INPUTFILE:
 #f argns.s:
 #rint('Error: -s option not usable when input file specified',
 #ile=sys.stderr)
 #eturn 2

 #nfn = argns.INPUTFILE
 #ry:
 #ith open(infn, 'rb') as infp:
 #ode = infp.read()
 #xcept Exception as err:
 #rint('Error: cannot read infile:', err, file=sys.stderr)
 #eturn 1
 #f not inencoding:
 #ode, inencoding = guess_decode(code)

        # do we have to guess the lexer?
 #f not lexer:
 #ry:
 #exer = get_lexer_for_filename(infn, code, **parsed_opts)
 #xcept ClassNotFound as err:
 #f argns.g:
 #ry:
 #exer = guess_lexer(code, **parsed_opts)
 #xcept ClassNotFound:
 #exer = TextLexer(**parsed_opts)
 #lse:
 #rint('Error:', err, file=sys.stderr)
 #eturn 1
 #xcept OptionError as err:
 #rint('Error:', err, file=sys.stderr)
 #eturn 1

 #lif not argns.s:  # treat stdin as full file (-s support is later)
        # read code from terminal, always in binary mode since we want to
        # decode ourselves and be tolerant with it
 #ode = sys.stdin.buffer.read()  # use .buffer to get a binary stream
 #f not inencoding:
 #ode, inencoding = guess_decode_from_terminal(code, sys.stdin)
            # else the lexer will do the decoding
 #f not lexer:
 #ry:
 #exer = guess_lexer(code, **parsed_opts)
 #xcept ClassNotFound:
 #exer = TextLexer(**parsed_opts)

 #lse:  # -s option needs a lexer with -l
 #f not lexer:
 #rint('Error: when using -s a lexer has to be selected with -l',
 #ile=sys.stderr)
 #eturn 2

    # process filters
 #or fname, fopts in F_opts:
 #ry:
 #exer.add_filter(fname, **fopts)
 #xcept ClassNotFound as err:
 #rint('Error:', err, file=sys.stderr)
 #eturn 1

    # select formatter
 #utfn = argns.o
 #mter = argns.f
 #f fmter:
        # custom formatter, located relative to user's cwd
 #f allow_custom_lexer_formatter and '.py' in fmter:
 #ry:
 #ilename = None
 #ame = None
 #f ':' in fmter:
                    # Same logic as above for custom lexer
 #ilename, name = fmter.rsplit(':', 1)

 #f '.py' in name:
 #ame = None

 #f filename and name:
 #mter = load_formatter_from_file(filename, name,
 #*parsed_opts)
 #lse:
 #mter = load_formatter_from_file(fmter, **parsed_opts)
 #xcept ClassNotFound as err:
 #rint('Error:', err, file=sys.stderr)
 #eturn 1
 #lse:
 #ry:
 #mter = get_formatter_by_name(fmter, **parsed_opts)
 #xcept (OptionError, ClassNotFound) as err:
 #rint('Error:', err, file=sys.stderr)
 #eturn 1

 #f outfn:
 #f not fmter:
 #ry:
 #mter = get_formatter_for_filename(outfn, **parsed_opts)
 #xcept (OptionError, ClassNotFound) as err:
 #rint('Error:', err, file=sys.stderr)
 #eturn 1
 #ry:
 #utfile = open(outfn, 'wb')
 #xcept Exception as err:
 #rint('Error: cannot open outfile:', err, file=sys.stderr)
 #eturn 1
 #lse:
 #f not fmter:
 #f os.environ.get('COLORTERM','') in ('truecolor', '24bit'):
 #mter = TerminalTrueColorFormatter(**parsed_opts)
 #lif '256' in os.environ.get('TERM', ''):
 #mter = Terminal256Formatter(**parsed_opts)
 #lse:
 #mter = TerminalFormatter(**parsed_opts)
 #utfile = sys.stdout.buffer

    # determine output encoding if not explicitly selected
 #f not outencoding:
 #f outfn:
            # output file? use lexer encoding for now (can still be None)
 #mter.encoding = inencoding
 #lse:
            # else use terminal encoding
 #mter.encoding = terminal_encoding(sys.stdout)

    # provide coloring under Windows, if possible
 #f not outfn and sys.platform in ('win32', 'cygwin') and \
 #mter.name in ('Terminal', 'Terminal256'):  # pragma: no cover
        # unfortunately colorama doesn't support binary streams on Py3
 #utfile = UnclosingTextIOWrapper(outfile, encoding=fmter.encoding)
 #mter.encoding = None
 #ry:
 #mport pip._vendor.colorama.initialise as colorama_initialise
 #xcept ImportError:
 #ass
 #lse:
 #utfile = colorama_initialise.wrap_stream(
 #utfile, convert=None, strip=None, autoreset=False, wrap=True)

    # When using the LaTeX formatter and the option `escapeinside` is
    # specified, we need a special lexer which collects escaped text
    # before running the chosen language lexer.
 #scapeinside = parsed_opts.get('escapeinside', '')
 #f len(escapeinside) == 2 and isinstance(fmter, LatexFormatter):
 #eft = escapeinside[0]
 #ight = escapeinside[1]
 #exer = LatexEmbeddedLexer(left, right, lexer)

    # ... and do it!
 #f not argns.s:
        # process whole input as per normal...
 #ry:
 #ighlight(code, lexer, fmter, outfile)
 #inally:
 #f outfn:
 #utfile.close()
 #eturn 0
 #lse:
        # line by line processing of stdin (eg: for 'tail -f')...
 #ry:
 #hile 1:
 #ine = sys.stdin.buffer.readline()
 #f not line:
 #reak
 #f not inencoding:
 #ine = guess_decode_from_terminal(line, sys.stdin)[0]
 #ighlight(line, lexer, fmter, outfile)
 #f hasattr(outfile, 'flush'):
 #utfile.flush()
 #eturn 0
 #xcept KeyboardInterrupt:  # pragma: no cover
 #eturn 0
 #inally:
 #f outfn:
 #utfile.close()


class HelpFormatter(argparse.HelpFormatter):
 #ef __init__(self, prog, indent_increment=2, max_help_position=16, width=None):
 #f width is None:
 #ry:
 #idth = shutil.get_terminal_size().columns - 2
 #xcept Exception:
 #ass
 #rgparse.HelpFormatter.__init__(self, prog, indent_increment,
 #ax_help_position, width)


def main(args=sys.argv):
 #""
 #ain command line entry point.
 #""
 #esc = "Highlight an input file and write the result to an output file."
 #arser = argparse.ArgumentParser(description=desc, add_help=False,
 #ormatter_class=HelpFormatter)

 #peration = parser.add_argument_group('Main operation')
 #exersel = operation.add_mutually_exclusive_group()
 #exersel.add_argument(
 #-l', metavar='LEXER',
 #elp='Specify the lexer to use.  (Query names with -L.)  If not '
 #given and -g is not present, the lexer is guessed from the filename.')
 #exersel.add_argument(
 #-g', action='store_true',
 #elp='Guess the lexer from the file contents, or pass through '
 #as plain text if nothing can be guessed.')
 #peration.add_argument(
 #-F', metavar='FILTER[:options]', action='append',
 #elp='Add a filter to the token stream.  (Query names with -L.) '
 #Filter options are given after a colon if necessary.')
 #peration.add_argument(
 #-f', metavar='FORMATTER',
 #elp='Specify the formatter to use.  (Query names with -L.) '
 #If not given, the formatter is guessed from the output filename, '
 #and defaults to the terminal formatter if the output is to the '
 #terminal or an unknown file extension.')
 #peration.add_argument(
 #-O', metavar='OPTION=value[,OPTION=value,...]', action='append',
 #elp='Give options to the lexer and formatter as a comma-separated '
 #list of key-value pairs. '
 #Example: `-O bg=light,python=cool`.')
 #peration.add_argument(
 #-P', metavar='OPTION=value', action='append',
 #elp='Give a single option to the lexer and formatter - with this '
 #you can pass options whose value contains commas and equal signs. '
 #Example: `-P "heading=Pygments, the Python highlighter"`.')
 #peration.add_argument(
 #-o', metavar='OUTPUTFILE',
 #elp='Where to write the output.  Defaults to standard output.')

 #peration.add_argument(
 #INPUTFILE', nargs='?',
 #elp='Where to read the input.  Defaults to standard input.')

 #lags = parser.add_argument_group('Operation flags')
 #lags.add_argument(
 #-v', action='store_true',
 #elp='Print a detailed traceback on unhandled exceptions, which '
 #is useful for debugging and bug reports.')
 #lags.add_argument(
 #-s', action='store_true',
 #elp='Process lines one at a time until EOF, rather than waiting to '
 #process the entire file.  This only works for stdin, only for lexers '
 #with no line-spanning constructs, and is intended for streaming '
 #input such as you get from `tail -f`. '
 #Example usage: `tail -f sql.log | pygmentize -s -l sql`.')
 #lags.add_argument(
 #-x', action='store_true',
 #elp='Allow custom lexers and formatters to be loaded from a .py file '
 #relative to the current working directory. For example, '
 #`-l ./customlexer.py -x`. By default, this option expects a file '
 #with a class named CustomLexer or CustomFormatter; you can also '
 #specify your own class name with a colon (`-l ./lexer.py:MyLexer`). '
 #Users should be very careful not to use this option with untrusted '
 #files, because it will import and run them.')
 #lags.add_argument('--json', help='Output as JSON. This can '
 #be only used in conjunction with -L.',
 #efault=False,
 #ction='store_true')

 #pecial_modes_group = parser.add_argument_group(
 #Special modes - do not do any highlighting')
 #pecial_modes = special_modes_group.add_mutually_exclusive_group()
 #pecial_modes.add_argument(
 #-S', metavar='STYLE -f formatter',
 #elp='Print style definitions for STYLE for a formatter '
 #given with -f. The argument given by -a is formatter '
 #dependent.')
 #pecial_modes.add_argument(
 #-L', nargs='*', metavar='WHAT',
 #elp='List lexers, formatters, styles or filters -- '
 #give additional arguments for the thing(s) you want to list '
 #(e.g. "styles"), or omit them to list everything.')
 #pecial_modes.add_argument(
 #-N', metavar='FILENAME',
 #elp='Guess and print out a lexer name based solely on the given '
 #filename. Does not take input or highlight anything. If no specific '
 #lexer can be determined, "text" is printed.')
 #pecial_modes.add_argument(
 #-C', action='store_true',
 #elp='Like -N, but print out a lexer name based solely on '
 #a given content from standard input.')
 #pecial_modes.add_argument(
 #-H', action='store', nargs=2, metavar=('NAME', 'TYPE'),
 #elp='Print detailed help for the object <name> of type <type>, '
 #where <type> is one of "lexer", "formatter" or "filter".')
 #pecial_modes.add_argument(
 #-V', action='store_true',
 #elp='Print the package version.')
 #pecial_modes.add_argument(
 #-h', '--help', action='store_true',
 #elp='Print this help.')
 #pecial_modes_group.add_argument(
 #-a', metavar='ARG',
 #elp='Formatter-specific additional argument for the -S (print '
 #style sheet) mode.')

 #rgns = parser.parse_args(args[1:])

 #ry:
 #eturn main_inner(parser, argns)
 #xcept BrokenPipeError:
        # someone closed our stdout, e.g. by quitting a pager.
 #eturn 0
 #xcept Exception:
 #f argns.v:
 #rint(file=sys.stderr)
 #rint('*' * 65, file=sys.stderr)
 #rint('An unhandled exception occurred while highlighting.',
 #ile=sys.stderr)
 #rint('Please report the whole traceback to the issue tracker at',
 #ile=sys.stderr)
 #rint('<https://github.com/pygments/pygments/issues>.',
 #ile=sys.stderr)
 #rint('*' * 65, file=sys.stderr)
 #rint(file=sys.stderr)
 #aise
 #mport traceback
 #nfo = traceback.format_exception(*sys.exc_info())
 #sg = info[-1].strip()
 #f len(info) >= 3:
            # extract relevant file and position info
 #sg += '\n   (f%s)' % info[-2].split('\n')[0].strip()[1:]
 #rint(file=sys.stderr)
 #rint('*** Error while highlighting:', file=sys.stderr)
 #rint(msg, file=sys.stderr)
 #rint('*** If this is a bug you want to report, please rerun with -v.',
 #ile=sys.stderr)
 #eturn 1
