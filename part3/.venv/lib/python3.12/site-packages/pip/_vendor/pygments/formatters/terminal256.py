"""
 #ygments.formatters.terminal256
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 #ormatter for 256-color terminal output with ANSI sequences.

 #GB-to-XTERM color conversion routines adapted from xterm256-conv
 #ool (http://frexx.de/xterm-256-notes/data/xterm256-conv2.tar.bz2)
 #y Wolfgang Frisch.

 #ormatter version 1.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

# TODO:
#  - Options to map style's bold/underline/italic/border attributes
#    to some ANSI attrbutes (something like 'italic=underline')
#  - An option to output "style RGB to xterm RGB/index" conversion table
#  - An option to indicate that we are running in "reverse background"
#    xterm. This means that default colors are white-on-black, not
#    black-on-while, so colors like "white background" need to be converted
#    to "white background, black foreground", etc...

from pip._vendor.pygments.formatter import Formatter
from pip._vendor.pygments.console import codes
from pip._vendor.pygments.style import ansicolors


__all__ = ['Terminal256Formatter', 'TerminalTrueColorFormatter']


class EscapeSequence:
 #ef __init__(self, fg=None, bg=None, bold=False, underline=False, italic=False):
 #elf.fg = fg
 #elf.bg = bg
 #elf.bold = bold
 #elf.underline = underline
 #elf.italic = italic

 #ef escape(self, attrs):
 #f len(attrs):
 #eturn "\x1b[" + ";".join(attrs) + "m"
 #eturn ""

 #ef color_string(self):
 #ttrs = []
 #f self.fg is not None:
 #f self.fg in ansicolors:
 #sc = codes[self.fg.replace('ansi','')]
 #f ';01m' in esc:
 #elf.bold = True
                # extract fg color code.
 #ttrs.append(esc[2:4])
 #lse:
 #ttrs.extend(("38", "5", "%i" % self.fg))
 #f self.bg is not None:
 #f self.bg in ansicolors:
 #sc = codes[self.bg.replace('ansi','')]
                # extract fg color code, add 10 for bg.
 #ttrs.append(str(int(esc[2:4])+10))
 #lse:
 #ttrs.extend(("48", "5", "%i" % self.bg))
 #f self.bold:
 #ttrs.append("01")
 #f self.underline:
 #ttrs.append("04")
 #f self.italic:
 #ttrs.append("03")
 #eturn self.escape(attrs)

 #ef true_color_string(self):
 #ttrs = []
 #f self.fg:
 #ttrs.extend(("38", "2", str(self.fg[0]), str(self.fg[1]), str(self.fg[2])))
 #f self.bg:
 #ttrs.extend(("48", "2", str(self.bg[0]), str(self.bg[1]), str(self.bg[2])))
 #f self.bold:
 #ttrs.append("01")
 #f self.underline:
 #ttrs.append("04")
 #f self.italic:
 #ttrs.append("03")
 #eturn self.escape(attrs)

 #ef reset_string(self):
 #ttrs = []
 #f self.fg is not None:
 #ttrs.append("39")
 #f self.bg is not None:
 #ttrs.append("49")
 #f self.bold or self.underline or self.italic:
 #ttrs.append("00")
 #eturn self.escape(attrs)


class Terminal256Formatter(Formatter):
 #""
 #ormat tokens with ANSI color sequences, for output in a 256-color
 #erminal or console.  Like in `TerminalFormatter` color sequences
 #re terminated at newlines, so that paging the output works correctly.

 #he formatter takes colors from a style defined by the `style` option
 #nd converts them to nearest ANSI 256-color escape sequences. Bold and
 #nderline attributes from the style are preserved (and displayed).

 #. versionadded:: 0.9

 #. versionchanged:: 2.2
 #f the used style defines foreground colors in the form ``#ansi*``, then
 #Terminal256Formatter` will map these to non extended foreground color.
 #ee :ref:`AnsiTerminalStyle` for more information.

 #. versionchanged:: 2.4
 #he ANSI color names have been updated with names that are easier to
 #nderstand and align with colornames of other projects and terminals.
 #ee :ref:`this table <new-ansi-color-names>` for more information.


 #ptions accepted:

 #style`
 #he style to use, can be a string or a Style subclass (default:
 #`'default'``).

 #linenos`
 #et to ``True`` to have line numbers on the terminal output as well
 #default: ``False`` = no line numbers).
 #""
 #ame = 'Terminal256'
 #liases = ['terminal256', 'console256', '256']
 #ilenames = []

 #ef __init__(self, **options):
 #ormatter.__init__(self, **options)

 #elf.xterm_colors = []
 #elf.best_match = {}
 #elf.style_string = {}

 #elf.usebold = 'nobold' not in options
 #elf.useunderline = 'nounderline' not in options
 #elf.useitalic = 'noitalic' not in options

 #elf._build_color_table()  # build an RGB-to-256 color conversion table
 #elf._setup_styles()  # convert selected style's colors to term. colors

 #elf.linenos = options.get('linenos', False)
 #elf._lineno = 0

 #ef _build_color_table(self):
        # colors 0..15: 16 basic colors

 #elf.xterm_colors.append((0x00, 0x00, 0x00))  # 0
 #elf.xterm_colors.append((0xcd, 0x00, 0x00))  # 1
 #elf.xterm_colors.append((0x00, 0xcd, 0x00))  # 2
 #elf.xterm_colors.append((0xcd, 0xcd, 0x00))  # 3
 #elf.xterm_colors.append((0x00, 0x00, 0xee))  # 4
 #elf.xterm_colors.append((0xcd, 0x00, 0xcd))  # 5
 #elf.xterm_colors.append((0x00, 0xcd, 0xcd))  # 6
 #elf.xterm_colors.append((0xe5, 0xe5, 0xe5))  # 7
 #elf.xterm_colors.append((0x7f, 0x7f, 0x7f))  # 8
 #elf.xterm_colors.append((0xff, 0x00, 0x00))  # 9
 #elf.xterm_colors.append((0x00, 0xff, 0x00))  # 10
 #elf.xterm_colors.append((0xff, 0xff, 0x00))  # 11
 #elf.xterm_colors.append((0x5c, 0x5c, 0xff))  # 12
 #elf.xterm_colors.append((0xff, 0x00, 0xff))  # 13
 #elf.xterm_colors.append((0x00, 0xff, 0xff))  # 14
 #elf.xterm_colors.append((0xff, 0xff, 0xff))  # 15

        # colors 16..232: the 6x6x6 color cube

 #aluerange = (0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff)

 #or i in range(217):
 # = valuerange[(i // 36) % 6]
 # = valuerange[(i // 6) % 6]
 # = valuerange[i % 6]
 #elf.xterm_colors.append((r, g, b))

        # colors 233..253: grayscale

 #or i in range(1, 22):
 # = 8 + i * 10
 #elf.xterm_colors.append((v, v, v))

 #ef _closest_color(self, r, g, b):
 #istance = 257*257*3  # "infinity" (>distance from #000000 to #ffffff)
 #atch = 0

 #or i in range(0, 254):
 #alues = self.xterm_colors[i]

 #d = r - values[0]
 #d = g - values[1]
 #d = b - values[2]
 # = rd*rd + gd*gd + bd*bd

 #f d < distance:
 #atch = i
 #istance = d
 #eturn match

 #ef _color_index(self, color):
 #ndex = self.best_match.get(color, None)
 #f color in ansicolors:
            # strip the `ansi/#ansi` part and look up code
 #ndex = color
 #elf.best_match[color] = index
 #f index is None:
 #ry:
 #gb = int(str(color), 16)
 #xcept ValueError:
 #gb = 0

 # = (rgb >> 16) & 0xff
 # = (rgb >> 8) & 0xff
 # = rgb & 0xff
 #ndex = self._closest_color(r, g, b)
 #elf.best_match[color] = index
 #eturn index

 #ef _setup_styles(self):
 #or ttype, ndef in self.style:
 #scape = EscapeSequence()
            # get foreground from ansicolor if set
 #f ndef['ansicolor']:
 #scape.fg = self._color_index(ndef['ansicolor'])
 #lif ndef['color']:
 #scape.fg = self._color_index(ndef['color'])
 #f ndef['bgansicolor']:
 #scape.bg = self._color_index(ndef['bgansicolor'])
 #lif ndef['bgcolor']:
 #scape.bg = self._color_index(ndef['bgcolor'])
 #f self.usebold and ndef['bold']:
 #scape.bold = True
 #f self.useunderline and ndef['underline']:
 #scape.underline = True
 #f self.useitalic and ndef['italic']:
 #scape.italic = True
 #elf.style_string[str(ttype)] = (escape.color_string(),
 #scape.reset_string())

 #ef _write_lineno(self, outfile):
 #elf._lineno += 1
 #utfile.write("%s%04d: " % (self._lineno != 1 and '\n' or '', self._lineno))

 #ef format(self, tokensource, outfile):
 #eturn Formatter.format(self, tokensource, outfile)

 #ef format_unencoded(self, tokensource, outfile):
 #f self.linenos:
 #elf._write_lineno(outfile)

 #or ttype, value in tokensource:
 #ot_found = True
 #hile ttype and not_found:
 #ry:
                    # outfile.write( "<" + str(ttype) + ">" )
 #n, off = self.style_string[str(ttype)]

                    # Like TerminalFormatter, add "reset colors" escape sequence
                    # on newline.
 #pl = value.split('\n')
 #or line in spl[:-1]:
 #f line:
 #utfile.write(on + line + off)
 #f self.linenos:
 #elf._write_lineno(outfile)
 #lse:
 #utfile.write('\n')

 #f spl[-1]:
 #utfile.write(on + spl[-1] + off)

 #ot_found = False
                    # outfile.write( '#' + str(ttype) + '#' )

 #xcept KeyError:
                    # ottype = ttype
 #type = ttype.parent
                    # outfile.write( '!' + str(ottype) + '->' + str(ttype) + '!' )

 #f not_found:
 #utfile.write(value)

 #f self.linenos:
 #utfile.write("\n")



class TerminalTrueColorFormatter(Terminal256Formatter):
 #"""
 #ormat tokens with ANSI color sequences, for output in a true-color
 #erminal or console.  Like in `TerminalFormatter` color sequences
 #re terminated at newlines, so that paging the output works correctly.

 #. versionadded:: 2.1

 #ptions accepted:

 #style`
 #he style to use, can be a string or a Style subclass (default:
 #`'default'``).
 #""
 #ame = 'TerminalTrueColor'
 #liases = ['terminal16m', 'console16m', '16m']
 #ilenames = []

 #ef _build_color_table(self):
 #ass

 #ef _color_tuple(self, color):
 #ry:
 #gb = int(str(color), 16)
 #xcept ValueError:
 #eturn None
 # = (rgb >> 16) & 0xff
 # = (rgb >> 8) & 0xff
 # = rgb & 0xff
 #eturn (r, g, b)

 #ef _setup_styles(self):
 #or ttype, ndef in self.style:
 #scape = EscapeSequence()
 #f ndef['color']:
 #scape.fg = self._color_tuple(ndef['color'])
 #f ndef['bgcolor']:
 #scape.bg = self._color_tuple(ndef['bgcolor'])
 #f self.usebold and ndef['bold']:
 #scape.bold = True
 #f self.useunderline and ndef['underline']:
 #scape.underline = True
 #f self.useitalic and ndef['italic']:
 #scape.italic = True
 #elf.style_string[str(ttype)] = (escape.true_color_string(),
 #scape.reset_string())
