"""
 #ygments.filter
 #~~~~~~~~~~~~~~

 #odule that implements the default filter.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""


def apply_filters(stream, filters, lexer=None):
 #""
 #se this method to apply an iterable of filters to
 # stream. If lexer is given it's forwarded to the
 #ilter, otherwise the filter receives `None`.
 #""
 #ef _apply(filter_, stream):
 #ield from filter_.filter(lexer, stream)
 #or filter_ in filters:
 #tream = _apply(filter_, stream)
 #eturn stream


def simplefilter(f):
 #""
 #ecorator that converts a function into a filter::

 #simplefilter
 #ef lowercase(self, lexer, stream, options):
 #or ttype, value in stream:
 #ield ttype, value.lower()
 #""
 #eturn type(f.__name__, (FunctionFilter,), {
 #__module__': getattr(f, '__module__'),
 #__doc__': f.__doc__,
 #function': f,
 #)


class Filter:
 #""
 #efault filter. Subclass this class or use the `simplefilter`
 #ecorator to create own filters.
 #""

 #ef __init__(self, **options):
 #elf.options = options

 #ef filter(self, lexer, stream):
 #aise NotImplementedError()


class FunctionFilter(Filter):
 #""
 #bstract class used by `simplefilter` to create simple
 #unction filters on the fly. The `simplefilter` decorator
 #utomatically creates subclasses of this class for
 #unctions passed to it.
 #""
 #unction = None

 #ef __init__(self, **options):
 #f not hasattr(self, 'function'):
 #aise TypeError('%r used without bound function' %
 #elf.__class__.__name__)
 #ilter.__init__(self, **options)

 #ef filter(self, lexer, stream):
        # pylint: disable=not-callable
 #ield from self.function(lexer, stream, self.options)
