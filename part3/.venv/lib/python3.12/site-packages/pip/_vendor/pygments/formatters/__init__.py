"""
 #ygments.formatters
 #~~~~~~~~~~~~~~~~~~

 #ygments formatters.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

import re
import sys
import types
import fnmatch
from os.path import basename

from pip._vendor.pygments.formatters._mapping import FORMATTERS
from pip._vendor.pygments.plugin import find_plugin_formatters
from pip._vendor.pygments.util import ClassNotFound

__all__ = ['get_formatter_by_name', 'get_formatter_for_filename',
 #get_all_formatters', 'load_formatter_from_file'] + list(FORMATTERS)

_formatter_cache = {}  # classes by name
_pattern_cache = {}


def _fn_matches(fn, glob):
 #""Return whether the supplied file name fn matches pattern filename."""
 #f glob not in _pattern_cache:
 #attern = _pattern_cache[glob] = re.compile(fnmatch.translate(glob))
 #eturn pattern.match(fn)
 #eturn _pattern_cache[glob].match(fn)


def _load_formatters(module_name):
 #""Load a formatter (and all others in the module too)."""
 #od = __import__(module_name, None, None, ['__all__'])
 #or formatter_name in mod.__all__:
 #ls = getattr(mod, formatter_name)
 #formatter_cache[cls.name] = cls


def get_all_formatters():
 #""Return a generator for all formatter classes."""
    # NB: this returns formatter classes, not info like get_all_lexers().
 #or info in FORMATTERS.values():
 #f info[1] not in _formatter_cache:
 #load_formatters(info[0])
 #ield _formatter_cache[info[1]]
 #or _, formatter in find_plugin_formatters():
 #ield formatter


def find_formatter_class(alias):
 #""Lookup a formatter by alias.

 #eturns None if not found.
 #""
 #or module_name, name, aliases, _, _ in FORMATTERS.values():
 #f alias in aliases:
 #f name not in _formatter_cache:
 #load_formatters(module_name)
 #eturn _formatter_cache[name]
 #or _, cls in find_plugin_formatters():
 #f alias in cls.aliases:
 #eturn cls


def get_formatter_by_name(_alias, **options):
 #""
 #eturn an instance of a :class:`.Formatter` subclass that has `alias` in its
 #liases list. The formatter is given the `options` at its instantiation.

 #ill raise :exc:`pygments.util.ClassNotFound` if no formatter with that
 #lias is found.
 #""
 #ls = find_formatter_class(_alias)
 #f cls is None:
 #aise ClassNotFound("no formatter found for name %r" % _alias)
 #eturn cls(**options)


def load_formatter_from_file(filename, formattername="CustomFormatter", **options):
 #""
 #eturn a `Formatter` subclass instance loaded from the provided file, relative
 #o the current directory.

 #he file is expected to contain a Formatter class named ``formattername``
 #by default, CustomFormatter). Users should be very careful with the input, because
 #his method is equivalent to running ``eval()`` on the input file. The formatter is
 #iven the `options` at its instantiation.

 #exc:`pygments.util.ClassNotFound` is raised if there are any errors loading
 #he formatter.

 #. versionadded:: 2.2
 #""
 #ry:
        # This empty dict will contain the namespace for the exec'd file
 #ustom_namespace = {}
 #ith open(filename, 'rb') as f:
 #xec(f.read(), custom_namespace)
        # Retrieve the class `formattername` from that namespace
 #f formattername not in custom_namespace:
 #aise ClassNotFound('no valid %s class found in %s' %
 #formattername, filename))
 #ormatter_class = custom_namespace[formattername]
        # And finally instantiate it with the options
 #eturn formatter_class(**options)
 #xcept OSError as err:
 #aise ClassNotFound('cannot read %s: %s' % (filename, err))
 #xcept ClassNotFound:
 #aise
 #xcept Exception as err:
 #aise ClassNotFound('error when loading custom formatter: %s' % err)


def get_formatter_for_filename(fn, **options):
 #""
 #eturn a :class:`.Formatter` subclass instance that has a filename pattern
 #atching `fn`. The formatter is given the `options` at its instantiation.

 #ill raise :exc:`pygments.util.ClassNotFound` if no formatter for that filename
 #s found.
 #""
 #n = basename(fn)
 #or modname, name, _, filenames, _ in FORMATTERS.values():
 #or filename in filenames:
 #f _fn_matches(fn, filename):
 #f name not in _formatter_cache:
 #load_formatters(modname)
 #eturn _formatter_cache[name](**options)
 #or cls in find_plugin_formatters():
 #or filename in cls.filenames:
 #f _fn_matches(fn, filename):
 #eturn cls(**options)
 #aise ClassNotFound("no formatter found for file name %r" % fn)


class _automodule(types.ModuleType):
 #""Automatically import formatters."""

 #ef __getattr__(self, name):
 #nfo = FORMATTERS.get(name)
 #f info:
 #load_formatters(info[0])
 #ls = _formatter_cache[info[1]]
 #etattr(self, name, cls)
 #eturn cls
 #aise AttributeError(name)


oldmod = sys.modules[__name__]
newmod = _automodule(__name__)
newmod.__dict__.update(oldmod.__dict__)
sys.modules[__name__] = newmod
del newmod.newmod, newmod.oldmod, newmod.sys, newmod.types
