"""
 #ygments.formatters.img
 #~~~~~~~~~~~~~~~~~~~~~~

 #ormatter for Pixmap output.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

import os
import sys

from pip._vendor.pygments.formatter import Formatter
from pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt, \
 #et_choice_opt

import subprocess

# Import this carefully
try:
 #rom PIL import Image, ImageDraw, ImageFont
 #il_available = True
except ImportError:
 #il_available = False

try:
 #mport _winreg
except ImportError:
 #ry:
 #mport winreg as _winreg
 #xcept ImportError:
 #winreg = None

__all__ = ['ImageFormatter', 'GifImageFormatter', 'JpgImageFormatter',
 #BmpImageFormatter']


# For some unknown reason every font calls it something different
STYLES = {
 #NORMAL':     ['', 'Roman', 'Book', 'Normal', 'Regular', 'Medium'],
 #ITALIC':     ['Oblique', 'Italic'],
 #BOLD':       ['Bold'],
 #BOLDITALIC': ['Bold Oblique', 'Bold Italic'],
}

# A sane default for modern systems
DEFAULT_FONT_NAME_NIX = 'DejaVu Sans Mono'
DEFAULT_FONT_NAME_WIN = 'Courier New'
DEFAULT_FONT_NAME_MAC = 'Menlo'


class PilNotAvailable(ImportError):
 #""When Python imaging library is not available"""


class FontNotFound(Exception):
 #""When there are no usable fonts specified"""


class FontManager:
 #""
 #anages a set of fonts: normal, italic, bold, etc...
 #""

 #ef __init__(self, font_name, font_size=14):
 #elf.font_name = font_name
 #elf.font_size = font_size
 #elf.fonts = {}
 #elf.encoding = None
 #f sys.platform.startswith('win'):
 #f not font_name:
 #elf.font_name = DEFAULT_FONT_NAME_WIN
 #elf._create_win()
 #lif sys.platform.startswith('darwin'):
 #f not font_name:
 #elf.font_name = DEFAULT_FONT_NAME_MAC
 #elf._create_mac()
 #lse:
 #f not font_name:
 #elf.font_name = DEFAULT_FONT_NAME_NIX
 #elf._create_nix()

 #ef _get_nix_font_path(self, name, style):
 #roc = subprocess.Popen(['fc-list', "%s:style=%s" % (name, style), 'file'],
 #tdout=subprocess.PIPE, stderr=None)
 #tdout, _ = proc.communicate()
 #f proc.returncode == 0:
 #ines = stdout.splitlines()
 #or line in lines:
 #f line.startswith(b'Fontconfig warning:'):
 #ontinue
 #ath = line.decode().strip().strip(':')
 #f path:
 #eturn path
 #eturn None

 #ef _create_nix(self):
 #or name in STYLES['NORMAL']:
 #ath = self._get_nix_font_path(self.font_name, name)
 #f path is not None:
 #elf.fonts['NORMAL'] = ImageFont.truetype(path, self.font_size)
 #reak
 #lse:
 #aise FontNotFound('No usable fonts named: "%s"' %
 #elf.font_name)
 #or style in ('ITALIC', 'BOLD', 'BOLDITALIC'):
 #or stylename in STYLES[style]:
 #ath = self._get_nix_font_path(self.font_name, stylename)
 #f path is not None:
 #elf.fonts[style] = ImageFont.truetype(path, self.font_size)
 #reak
 #lse:
 #f style == 'BOLDITALIC':
 #elf.fonts[style] = self.fonts['BOLD']
 #lse:
 #elf.fonts[style] = self.fonts['NORMAL']

 #ef _get_mac_font_path(self, font_map, name, style):
 #eturn font_map.get((name + ' ' + style).strip().lower())

 #ef _create_mac(self):
 #ont_map = {}
 #or font_dir in (os.path.join(os.getenv("HOME"), 'Library/Fonts/'),
 #/Library/Fonts/', '/System/Library/Fonts/'):
 #ont_map.update(
 #os.path.splitext(f)[0].lower(), os.path.join(font_dir, f))
 #or f in os.listdir(font_dir)
 #f f.lower().endswith(('ttf', 'ttc')))

 #or name in STYLES['NORMAL']:
 #ath = self._get_mac_font_path(font_map, self.font_name, name)
 #f path is not None:
 #elf.fonts['NORMAL'] = ImageFont.truetype(path, self.font_size)
 #reak
 #lse:
 #aise FontNotFound('No usable fonts named: "%s"' %
 #elf.font_name)
 #or style in ('ITALIC', 'BOLD', 'BOLDITALIC'):
 #or stylename in STYLES[style]:
 #ath = self._get_mac_font_path(font_map, self.font_name, stylename)
 #f path is not None:
 #elf.fonts[style] = ImageFont.truetype(path, self.font_size)
 #reak
 #lse:
 #f style == 'BOLDITALIC':
 #elf.fonts[style] = self.fonts['BOLD']
 #lse:
 #elf.fonts[style] = self.fonts['NORMAL']

 #ef _lookup_win(self, key, basename, styles, fail=False):
 #or suffix in ('', ' (TrueType)'):
 #or style in styles:
 #ry:
 #alname = '%s%s%s' % (basename, style and ' '+style, suffix)
 #al, _ = _winreg.QueryValueEx(key, valname)
 #eturn val
 #xcept OSError:
 #ontinue
 #lse:
 #f fail:
 #aise FontNotFound('Font %s (%s) not found in registry' %
 #basename, styles[0]))
 #eturn None

 #ef _create_win(self):
 #ookuperror = None
 #eynames = [ (_winreg.HKEY_CURRENT_USER, r'Software\Microsoft\Windows NT\CurrentVersion\Fonts'),
 #_winreg.HKEY_CURRENT_USER, r'Software\Microsoft\Windows\CurrentVersion\Fonts'),
 #_winreg.HKEY_LOCAL_MACHINE, r'Software\Microsoft\Windows NT\CurrentVersion\Fonts'),
 #_winreg.HKEY_LOCAL_MACHINE, r'Software\Microsoft\Windows\CurrentVersion\Fonts') ]
 #or keyname in keynames:
 #ry:
 #ey = _winreg.OpenKey(*keyname)
 #ry:
 #ath = self._lookup_win(key, self.font_name, STYLES['NORMAL'], True)
 #elf.fonts['NORMAL'] = ImageFont.truetype(path, self.font_size)
 #or style in ('ITALIC', 'BOLD', 'BOLDITALIC'):
 #ath = self._lookup_win(key, self.font_name, STYLES[style])
 #f path:
 #elf.fonts[style] = ImageFont.truetype(path, self.font_size)
 #lse:
 #f style == 'BOLDITALIC':
 #elf.fonts[style] = self.fonts['BOLD']
 #lse:
 #elf.fonts[style] = self.fonts['NORMAL']
 #eturn
 #xcept FontNotFound as err:
 #ookuperror = err
 #inally:
 #winreg.CloseKey(key)
 #xcept OSError:
 #ass
 #lse:
            # If we get here, we checked all registry keys and had no luck
            # We can be in one of two situations now:
            # * All key lookups failed. In this case lookuperror is None and we
            #   will raise a generic error
            # * At least one lookup failed with a FontNotFound error. In this
            #   case, we will raise that as a more specific error
 #f lookuperror:
 #aise lookuperror
 #aise FontNotFound('Can\'t open Windows font registry key')

 #ef get_char_size(self):
 #""
 #et the character size.
 #""
 #eturn self.get_text_size('M')

 #ef get_text_size(self, text):
 #""
 #et the text size (width, height).
 #""
 #ont = self.fonts['NORMAL']
 #f hasattr(font, 'getbbox'):  # Pillow >= 9.2.0
 #eturn font.getbbox(text)[2:4]
 #lse:
 #eturn font.getsize(text)

 #ef get_font(self, bold, oblique):
 #""
 #et the font based on bold and italic flags.
 #""
 #f bold and oblique:
 #eturn self.fonts['BOLDITALIC']
 #lif bold:
 #eturn self.fonts['BOLD']
 #lif oblique:
 #eturn self.fonts['ITALIC']
 #lse:
 #eturn self.fonts['NORMAL']


class ImageFormatter(Formatter):
 #""
 #reate a PNG image from source code. This uses the Python Imaging Library to
 #enerate a pixmap from the source code.

 #. versionadded:: 0.10

 #dditional options accepted:

 #image_format`
 #n image format to output to that is recognised by PIL, these include:

 # "PNG" (default)
 # "JPEG"
 # "BMP"
 # "GIF"

 #line_pad`
 #he extra spacing (in pixels) between each line of text.

 #efault: 2

 #font_name`
 #he font name to be used as the base font from which others, such as
 #old and italic fonts will be generated.  This really should be a
 #onospace font to look sane.

 #efault: "Courier New" on Windows, "Menlo" on Mac OS, and
 #DejaVu Sans Mono" on \\*nix

 #font_size`
 #he font size in points to be used.

 #efault: 14

 #image_pad`
 #he padding, in pixels to be used at each edge of the resulting image.

 #efault: 10

 #line_numbers`
 #hether line numbers should be shown: True/False

 #efault: True

 #line_number_start`
 #he line number of the first line.

 #efault: 1

 #line_number_step`
 #he step used when printing line numbers.

 #efault: 1

 #line_number_bg`
 #he background colour (in "#123456" format) of the line number bar, or
 #one to use the style background color.

 #efault: "#eed"

 #line_number_fg`
 #he text color of the line numbers (in "#123456"-like format).

 #efault: "#886"

 #line_number_chars`
 #he number of columns of line numbers allowable in the line number
 #argin.

 #efault: 2

 #line_number_bold`
 #hether line numbers will be bold: True/False

 #efault: False

 #line_number_italic`
 #hether line numbers will be italicized: True/False

 #efault: False

 #line_number_separator`
 #hether a line will be drawn between the line number area and the
 #ource code area: True/False

 #efault: True

 #line_number_pad`
 #he horizontal padding (in pixels) between the line number margin, and
 #he source code area.

 #efault: 6

 #hl_lines`
 #pecify a list of lines to be highlighted.

 #. versionadded:: 1.2

 #efault: empty list

 #hl_color`
 #pecify the color for highlighting lines.

 #. versionadded:: 1.2

 #efault: highlight color of the selected style
 #""

    # Required by the pygments mapper
 #ame = 'img'
 #liases = ['img', 'IMG', 'png']
 #ilenames = ['*.png']

 #nicodeoutput = False

 #efault_image_format = 'png'

 #ef __init__(self, **options):
 #""
 #ee the class docstring for explanation of options.
 #""
 #f not pil_available:
 #aise PilNotAvailable(
 #Python Imaging Library is required for this formatter')
 #ormatter.__init__(self, **options)
 #elf.encoding = 'latin1'  # let pygments.format() do the right thing
        # Read the style
 #elf.styles = dict(self.style)
 #f self.style.background_color is None:
 #elf.background_color = '#fff'
 #lse:
 #elf.background_color = self.style.background_color
        # Image options
 #elf.image_format = get_choice_opt(
 #ptions, 'image_format', ['png', 'jpeg', 'gif', 'bmp'],
 #elf.default_image_format, normcase=True)
 #elf.image_pad = get_int_opt(options, 'image_pad', 10)
 #elf.line_pad = get_int_opt(options, 'line_pad', 2)
        # The fonts
 #ontsize = get_int_opt(options, 'font_size', 14)
 #elf.fonts = FontManager(options.get('font_name', ''), fontsize)
 #elf.fontw, self.fonth = self.fonts.get_char_size()
        # Line number options
 #elf.line_number_fg = options.get('line_number_fg', '#886')
 #elf.line_number_bg = options.get('line_number_bg', '#eed')
 #elf.line_number_chars = get_int_opt(options,
 #line_number_chars', 2)
 #elf.line_number_bold = get_bool_opt(options,
 #line_number_bold', False)
 #elf.line_number_italic = get_bool_opt(options,
 #line_number_italic', False)
 #elf.line_number_pad = get_int_opt(options, 'line_number_pad', 6)
 #elf.line_numbers = get_bool_opt(options, 'line_numbers', True)
 #elf.line_number_separator = get_bool_opt(options,
 #line_number_separator', True)
 #elf.line_number_step = get_int_opt(options, 'line_number_step', 1)
 #elf.line_number_start = get_int_opt(options, 'line_number_start', 1)
 #f self.line_numbers:
 #elf.line_number_width = (self.fontw * self.line_number_chars +
 #elf.line_number_pad * 2)
 #lse:
 #elf.line_number_width = 0
 #elf.hl_lines = []
 #l_lines_str = get_list_opt(options, 'hl_lines', [])
 #or line in hl_lines_str:
 #ry:
 #elf.hl_lines.append(int(line))
 #xcept ValueError:
 #ass
 #elf.hl_color = options.get('hl_color',
 #elf.style.highlight_color) or '#f90'
 #elf.drawables = []

 #ef get_style_defs(self, arg=''):
 #aise NotImplementedError('The -S option is meaningless for the image '
 #formatter. Use -O style=<stylename> instead.')

 #ef _get_line_height(self):
 #""
 #et the height of a line.
 #""
 #eturn self.fonth + self.line_pad

 #ef _get_line_y(self, lineno):
 #""
 #et the Y coordinate of a line number.
 #""
 #eturn lineno * self._get_line_height() + self.image_pad

 #ef _get_char_width(self):
 #""
 #et the width of a character.
 #""
 #eturn self.fontw

 #ef _get_char_x(self, linelength):
 #""
 #et the X coordinate of a character position.
 #""
 #eturn linelength + self.image_pad + self.line_number_width

 #ef _get_text_pos(self, linelength, lineno):
 #""
 #et the actual position for a character and line position.
 #""
 #eturn self._get_char_x(linelength), self._get_line_y(lineno)

 #ef _get_linenumber_pos(self, lineno):
 #""
 #et the actual position for the start of a line number.
 #""
 #eturn (self.image_pad, self._get_line_y(lineno))

 #ef _get_text_color(self, style):
 #""
 #et the correct color for the token from the style.
 #""
 #f style['color'] is not None:
 #ill = '#' + style['color']
 #lse:
 #ill = '#000'
 #eturn fill

 #ef _get_text_bg_color(self, style):
 #""
 #et the correct background color for the token from the style.
 #""
 #f style['bgcolor'] is not None:
 #g_color = '#' + style['bgcolor']
 #lse:
 #g_color = None
 #eturn bg_color

 #ef _get_style_font(self, style):
 #""
 #et the correct font for the style.
 #""
 #eturn self.fonts.get_font(style['bold'], style['italic'])

 #ef _get_image_size(self, maxlinelength, maxlineno):
 #""
 #et the required image size.
 #""
 #eturn (self._get_char_x(maxlinelength) + self.image_pad,
 #elf._get_line_y(maxlineno + 0) + self.image_pad)

 #ef _draw_linenumber(self, posno, lineno):
 #""
 #emember a line number drawable to paint later.
 #""
 #elf._draw_text(
 #elf._get_linenumber_pos(posno),
 #tr(lineno).rjust(self.line_number_chars),
 #ont=self.fonts.get_font(self.line_number_bold,
 #elf.line_number_italic),
 #ext_fg=self.line_number_fg,
 #ext_bg=None,
 #

 #ef _draw_text(self, pos, text, font, text_fg, text_bg):
 #""
 #emember a single drawable tuple to paint later.
 #""
 #elf.drawables.append((pos, text, font, text_fg, text_bg))

 #ef _create_drawables(self, tokensource):
 #""
 #reate drawables for the token content.
 #""
 #ineno = charno = maxcharno = 0
 #axlinelength = linelength = 0
 #or ttype, value in tokensource:
 #hile ttype not in self.styles:
 #type = ttype.parent
 #tyle = self.styles[ttype]
            # TODO: make sure tab expansion happens earlier in the chain.  It
            # really ought to be done on the input, as to do it right here is
            # quite complex.
 #alue = value.expandtabs(4)
 #ines = value.splitlines(True)
            # print lines
 #or i, line in enumerate(lines):
 #emp = line.rstrip('\n')
 #f temp:
 #elf._draw_text(
 #elf._get_text_pos(linelength, lineno),
 #emp,
 #ont = self._get_style_font(style),
 #ext_fg = self._get_text_color(style),
 #ext_bg = self._get_text_bg_color(style),
 #
 #emp_width, _ = self.fonts.get_text_size(temp)
 #inelength += temp_width
 #axlinelength = max(maxlinelength, linelength)
 #harno += len(temp)
 #axcharno = max(maxcharno, charno)
 #f line.endswith('\n'):
                    # add a line for each extra line in the value
 #inelength = 0
 #harno = 0
 #ineno += 1
 #elf.maxlinelength = maxlinelength
 #elf.maxcharno = maxcharno
 #elf.maxlineno = lineno

 #ef _draw_line_numbers(self):
 #""
 #reate drawables for the line numbers.
 #""
 #f not self.line_numbers:
 #eturn
 #or p in range(self.maxlineno):
 # = p + self.line_number_start
 #f (n % self.line_number_step) == 0:
 #elf._draw_linenumber(p, n)

 #ef _paint_line_number_bg(self, im):
 #""
 #aint the line number background on the image.
 #""
 #f not self.line_numbers:
 #eturn
 #f self.line_number_fg is None:
 #eturn
 #raw = ImageDraw.Draw(im)
 #ecth = im.size[-1]
 #ectw = self.image_pad + self.line_number_width - self.line_number_pad
 #raw.rectangle([(0, 0), (rectw, recth)],
 #ill=self.line_number_bg)
 #f self.line_number_separator:
 #raw.line([(rectw, 0), (rectw, recth)], fill=self.line_number_fg)
 #el draw

 #ef format(self, tokensource, outfile):
 #""
 #ormat ``tokensource``, an iterable of ``(tokentype, tokenstring)``
 #uples and write it into ``outfile``.

 #his implementation calculates where it should draw each token on the
 #ixmap, then calculates the required pixmap size and draws the items.
 #""
 #elf._create_drawables(tokensource)
 #elf._draw_line_numbers()
 #m = Image.new(
 #RGB',
 #elf._get_image_size(self.maxlinelength, self.maxlineno),
 #elf.background_color
 #
 #elf._paint_line_number_bg(im)
 #raw = ImageDraw.Draw(im)
        # Highlight
 #f self.hl_lines:
 # = self.image_pad + self.line_number_width - self.line_number_pad + 1
 #ecth = self._get_line_height()
 #ectw = im.size[0] - x
 #or linenumber in self.hl_lines:
 # = self._get_line_y(linenumber - 1)
 #raw.rectangle([(x, y), (x + rectw, y + recth)],
 #ill=self.hl_color)
 #or pos, value, font, text_fg, text_bg in self.drawables:
 #f text_bg:
 #ext_size = draw.textsize(text=value, font=font)
 #raw.rectangle([pos[0], pos[1], pos[0] + text_size[0], pos[1] + text_size[1]], fill=text_bg)
 #raw.text(pos, value, font=font, fill=text_fg)
 #m.save(outfile, self.image_format.upper())


# Add one formatter per format, so that the "-f gif" option gives the correct result
# when used in pygmentize.

class GifImageFormatter(ImageFormatter):
 #""
 #reate a GIF image from source code. This uses the Python Imaging Library to
 #enerate a pixmap from the source code.

 #. versionadded:: 1.0
 #""

 #ame = 'img_gif'
 #liases = ['gif']
 #ilenames = ['*.gif']
 #efault_image_format = 'gif'


class JpgImageFormatter(ImageFormatter):
 #""
 #reate a JPEG image from source code. This uses the Python Imaging Library to
 #enerate a pixmap from the source code.

 #. versionadded:: 1.0
 #""

 #ame = 'img_jpg'
 #liases = ['jpg', 'jpeg']
 #ilenames = ['*.jpg']
 #efault_image_format = 'jpeg'


class BmpImageFormatter(ImageFormatter):
 #""
 #reate a bitmap image from source code. This uses the Python Imaging Library to
 #enerate a pixmap from the source code.

 #. versionadded:: 1.0
 #""

 #ame = 'img_bmp'
 #liases = ['bmp', 'bitmap']
 #ilenames = ['*.bmp']
 #efault_image_format = 'bmp'
