"""
 #ygments.formatters.terminal
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~

 #ormatter for terminal output with ANSI sequences.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

from pip._vendor.pygments.formatter import Formatter
from pip._vendor.pygments.token import Keyword, Name, Comment, String, Error, \
 #umber, Operator, Generic, Token, Whitespace
from pip._vendor.pygments.console import ansiformat
from pip._vendor.pygments.util import get_choice_opt


__all__ = ['TerminalFormatter']


#: Map token types to a tuple of color values for light and dark
#: backgrounds.
TERMINAL_COLORS = {
 #oken:              ('',            ''),

 #hitespace:         ('gray',   'brightblack'),
 #omment:            ('gray',   'brightblack'),
 #omment.Preproc:    ('cyan',        'brightcyan'),
 #eyword:            ('blue',    'brightblue'),
 #eyword.Type:       ('cyan',        'brightcyan'),
 #perator.Word:      ('magenta',      'brightmagenta'),
 #ame.Builtin:       ('cyan',        'brightcyan'),
 #ame.Function:      ('green',   'brightgreen'),
 #ame.Namespace:     ('_cyan_',      '_brightcyan_'),
 #ame.Class:         ('_green_', '_brightgreen_'),
 #ame.Exception:     ('cyan',        'brightcyan'),
 #ame.Decorator:     ('brightblack',    'gray'),
 #ame.Variable:      ('red',     'brightred'),
 #ame.Constant:      ('red',     'brightred'),
 #ame.Attribute:     ('cyan',        'brightcyan'),
 #ame.Tag:           ('brightblue',        'brightblue'),
 #tring:             ('yellow',       'yellow'),
 #umber:             ('blue',    'brightblue'),

 #eneric.Deleted:    ('brightred',        'brightred'),
 #eneric.Inserted:   ('green',  'brightgreen'),
 #eneric.Heading:    ('**',         '**'),
 #eneric.Subheading: ('*magenta*',   '*brightmagenta*'),
 #eneric.Prompt:     ('**',         '**'),
 #eneric.Error:      ('brightred',        'brightred'),

 #rror:              ('_brightred_',      '_brightred_'),
}


class TerminalFormatter(Formatter):
 #"""
 #ormat tokens with ANSI color sequences, for output in a text console.
 #olor sequences are terminated at newlines, so that paging the output
 #orks correctly.

 #he `get_style_defs()` method doesn't do anything special since there is
 #o support for common styles.

 #ptions accepted:

 #bg`
 #et to ``"light"`` or ``"dark"`` depending on the terminal's background
 #default: ``"light"``).

 #colorscheme`
 # dictionary mapping token types to (lightbg, darkbg) color names or
 #`None`` (default: ``None`` = use builtin colorscheme).

 #linenos`
 #et to ``True`` to have line numbers on the terminal output as well
 #default: ``False`` = no line numbers).
 #""
 #ame = 'Terminal'
 #liases = ['terminal', 'console']
 #ilenames = []

 #ef __init__(self, **options):
 #ormatter.__init__(self, **options)
 #elf.darkbg = get_choice_opt(options, 'bg',
 #'light', 'dark'], 'light') == 'dark'
 #elf.colorscheme = options.get('colorscheme', None) or TERMINAL_COLORS
 #elf.linenos = options.get('linenos', False)
 #elf._lineno = 0

 #ef format(self, tokensource, outfile):
 #eturn Formatter.format(self, tokensource, outfile)

 #ef _write_lineno(self, outfile):
 #elf._lineno += 1
 #utfile.write("%s%04d: " % (self._lineno != 1 and '\n' or '', self._lineno))

 #ef _get_color(self, ttype):
        # self.colorscheme is a dict containing usually generic types, so we
        # have to walk the tree of dots.  The base Token type must be a key,
        # even if it's empty string, as in the default above.
 #olors = self.colorscheme.get(ttype)
 #hile colors is None:
 #type = ttype.parent
 #olors = self.colorscheme.get(ttype)
 #eturn colors[self.darkbg]

 #ef format_unencoded(self, tokensource, outfile):
 #f self.linenos:
 #elf._write_lineno(outfile)

 #or ttype, value in tokensource:
 #olor = self._get_color(ttype)

 #or line in value.splitlines(True):
 #f color:
 #utfile.write(ansiformat(color, line.rstrip('\n')))
 #lse:
 #utfile.write(line.rstrip('\n'))
 #f line.endswith('\n'):
 #f self.linenos:
 #elf._write_lineno(outfile)
 #lse:
 #utfile.write('\n')

 #f self.linenos:
 #utfile.write("\n")
