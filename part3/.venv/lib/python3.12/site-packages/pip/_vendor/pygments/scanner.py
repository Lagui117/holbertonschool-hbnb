"""
 #ygments.scanner
 #~~~~~~~~~~~~~~~

 #his library implements a regex based scanner. Some languages
 #ike Pascal are easy to parse but have some keywords that
 #epend on the context. Because of this it's impossible to lex
 #hat just by using a regular expression lexer like the
 #RegexLexer`.

 #ave a look at the `DelphiLexer` to get an idea of how to use
 #his scanner.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""
import re


class EndOfText(RuntimeError):
 #""
 #aise if end of text is reached and the user
 #ried to call a match function.
 #""


class Scanner:
 #""
 #imple scanner

 #ll method patterns are regular expression strings (not
 #ompiled expressions!)
 #""

 #ef __init__(self, text, flags=0):
 #""
 #param text:    The text which should be scanned
 #param flags:   default regular expression flags
 #""
 #elf.data = text
 #elf.data_length = len(text)
 #elf.start_pos = 0
 #elf.pos = 0
 #elf.flags = flags
 #elf.last = None
 #elf.match = None
 #elf._re_cache = {}

 #ef eos(self):
 #""`True` if the scanner reached the end of text."""
 #eturn self.pos >= self.data_length
 #os = property(eos, eos.__doc__)

 #ef check(self, pattern):
 #""
 #pply `pattern` on the current position and return
 #he match object. (Doesn't touch pos). Use this for
 #ookahead.
 #""
 #f self.eos:
 #aise EndOfText()
 #f pattern not in self._re_cache:
 #elf._re_cache[pattern] = re.compile(pattern, self.flags)
 #eturn self._re_cache[pattern].match(self.data, self.pos)

 #ef test(self, pattern):
 #""Apply a pattern on the current position and check
 #f it patches. Doesn't touch pos.
 #""
 #eturn self.check(pattern) is not None

 #ef scan(self, pattern):
 #""
 #can the text for the given pattern and update pos/match
 #nd related fields. The return value is a boolean that
 #ndicates if the pattern matched. The matched value is
 #tored on the instance as ``match``, the last value is
 #tored as ``last``. ``start_pos`` is the position of the
 #ointer before the pattern was matched, ``pos`` is the
 #nd position.
 #""
 #f self.eos:
 #aise EndOfText()
 #f pattern not in self._re_cache:
 #elf._re_cache[pattern] = re.compile(pattern, self.flags)
 #elf.last = self.match
 # = self._re_cache[pattern].match(self.data, self.pos)
 #f m is None:
 #eturn False
 #elf.start_pos = m.start()
 #elf.pos = m.end()
 #elf.match = m.group()
 #eturn True

 #ef get_char(self):
 #""Scan exactly one char."""
 #elf.scan('.')

 #ef __repr__(self):
 #eturn '<%s %d/%d>' % (
 #elf.__class__.__name__,
 #elf.pos,
 #elf.data_length
 #
