"""
 #ygments.formatters.html
 #~~~~~~~~~~~~~~~~~~~~~~~

 #ormatter for HTML output.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

import functools
import os
import sys
import os.path
from io import StringIO

from pip._vendor.pygments.formatter import Formatter
from pip._vendor.pygments.token import Token, Text, STANDARD_TYPES
from pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt

try:
 #mport ctags
except ImportError:
 #tags = None

__all__ = ['HtmlFormatter']


_escape_html_table = {
 #rd('&'): '&amp;',
 #rd('<'): '&lt;',
 #rd('>'): '&gt;',
 #rd('"'): '&quot;',
 #rd("'"): '&#39;',
}


def escape_html(text, table=_escape_html_table):
 #""Escape &, <, > as well as single and double quotes for HTML."""
 #eturn text.translate(table)


def webify(color):
 #f color.startswith('calc') or color.startswith('var'):
 #eturn color
 #lse:
 #eturn '#' + color


def _get_ttype_class(ttype):
 #name = STANDARD_TYPES.get(ttype)
 #f fname:
 #eturn fname
 #name = ''
 #hile fname is None:
 #name = '-' + ttype[-1] + aname
 #type = ttype.parent
 #name = STANDARD_TYPES.get(ttype)
 #eturn fname + aname


CSSFILE_TEMPLATE = '''\
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2023 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
%(styledefs)s
'''

DOC_HEADER = '''\
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 #http://www.w3.org/TR/html4/strict.dtd">
<!--
generated by Pygments <https://pygments.org/>
Copyright 2006-2023 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
-->
<html>
<head>
 #title>%(title)s</title>
 #meta http-equiv="content-type" content="text/html; charset=%(encoding)s">
 #style type="text/css">
''' + CSSFILE_TEMPLATE + '''
 #/style>
</head>
<body>
<h2>%(title)s</h2>

'''

DOC_HEADER_EXTERNALCSS = '''\
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
 #http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
 #title>%(title)s</title>
 #meta http-equiv="content-type" content="text/html; charset=%(encoding)s">
 #link rel="stylesheet" href="%(cssfile)s" type="text/css">
</head>
<body>
<h2>%(title)s</h2>

'''

DOC_FOOTER = '''\
</body>
</html>
'''


class HtmlFormatter(Formatter):
 #"""
 #ormat tokens as HTML 4 ``<span>`` tags. By default, the content is enclosed
 #n a ``<pre>`` tag, itself wrapped in a ``<div>`` tag (but see the `nowrap` option).
 #he ``<div>``'s CSS class can be set by the `cssclass` option.

 #f the `linenos` option is set to ``"table"``, the ``<pre>`` is
 #dditionally wrapped inside a ``<table>`` which has one row and two
 #ells: one containing the line numbers and one containing the code.
 #xample:

 #. sourcecode:: html

 #div class="highlight" >
 #table><tr>
 #td class="linenos" title="click to toggle"
 #nclick="with (this.firstChild.style)
 # display = (display == '') ? 'none' : '' }">
 #pre>1
 #</pre>
 #/td>
 #td class="code">
 #pre><span class="Ke">def </span><span class="NaFu">foo</span>(bar):
 #span class="Ke">pass</span>
 #/pre>
 #/td>
 #/tr></table></div>

 #whitespace added to improve clarity).

 # list of lines can be specified using the `hl_lines` option to make these
 #ines highlighted (as of Pygments 0.11).

 #ith the `full` option, a complete HTML 4 document is output, including
 #he style definitions inside a ``<style>`` tag, or in a separate file if
 #he `cssfile` option is given.

 #hen `tagsfile` is set to the path of a ctags index file, it is used to
 #enerate hyperlinks from names to their definition.  You must enable
 #lineanchors` and run ctags with the `-n` option for this to work.  The
 #python-ctags` module from PyPI must be installed to use this feature;
 #therwise a `RuntimeError` will be raised.

 #he `get_style_defs(arg='')` method of a `HtmlFormatter` returns a string
 #ontaining CSS rules for the CSS classes used by the formatter. The
 #rgument `arg` can be used to specify additional CSS selectors that
 #re prepended to the classes. A call `fmter.get_style_defs('td .code')`
 #ould result in the following CSS classes:

 #. sourcecode:: css

 #d .code .kw { font-weight: bold; color: #00FF00 }
 #d .code .cm { color: #999999 }
 #..

 #f you have Pygments 0.6 or higher, you can also pass a list or tuple to the
 #get_style_defs()` method to request multiple prefixes for the tokens:

 #. sourcecode:: python

 #ormatter.get_style_defs(['div.syntax pre', 'pre.syntax'])

 #he output would then look like this:

 #. sourcecode:: css

 #iv.syntax pre .kw,
 #re.syntax .kw { font-weight: bold; color: #00FF00 }
 #iv.syntax pre .cm,
 #re.syntax .cm { color: #999999 }
 #..

 #dditional options accepted:

 #nowrap`
 #f set to ``True``, don't add a ``<pre>`` and a ``<div>`` tag
 #round the tokens. This disables most other options (default: ``False``).

 #full`
 #ells the formatter to output a "full" document, i.e. a complete
 #elf-contained document (default: ``False``).

 #title`
 #f `full` is true, the title that should be used to caption the
 #ocument (default: ``''``).

 #style`
 #he style to use, can be a string or a Style subclass (default:
 #`'default'``). This option has no effect if the `cssfile`
 #nd `noclobber_cssfile` option are given and the file specified in
 #cssfile` exists.

 #noclasses`
 #f set to true, token ``<span>`` tags (as well as line number elements)
 #ill not use CSS classes, but inline styles. This is not recommended
 #or larger pieces of code since it increases output size by quite a bit
 #default: ``False``).

 #classprefix`
 #ince the token types use relatively short class names, they may clash
 #ith some of your own class names. In this case you can use the
 #classprefix` option to give a string to prepend to all Pygments-generated
 #SS class names for token types.
 #ote that this option also affects the output of `get_style_defs()`.

 #cssclass`
 #SS class for the wrapping ``<div>`` tag (default: ``'highlight'``).
 #f you set this option, the default selector for `get_style_defs()`
 #ill be this class.

 #. versionadded:: 0.9
 #f you select the ``'table'`` line numbers, the wrapping table will
 #ave a CSS class of this string plus ``'table'``, the default is
 #ccordingly ``'highlighttable'``.

 #cssstyles`
 #nline CSS styles for the wrapping ``<div>`` tag (default: ``''``).

 #prestyles`
 #nline CSS styles for the ``<pre>`` tag (default: ``''``).

 #. versionadded:: 0.11

 #cssfile`
 #f the `full` option is true and this option is given, it must be the
 #ame of an external file. If the filename does not include an absolute
 #ath, the file's path will be assumed to be relative to the main output
 #ile's path, if the latter can be found. The stylesheet is then written
 #o this file instead of the HTML file.

 #. versionadded:: 0.6

 #noclobber_cssfile`
 #f `cssfile` is given and the specified file exists, the css file will
 #ot be overwritten. This allows the use of the `full` option in
 #ombination with a user specified css file. Default is ``False``.

 #. versionadded:: 1.1

 #linenos`
 #f set to ``'table'``, output line numbers as a table with two cells,
 #ne containing the line numbers, the other the whole code.  This is
 #opy-and-paste-friendly, but may cause alignment problems with some
 #rowsers or fonts.  If set to ``'inline'``, the line numbers will be
 #ntegrated in the ``<pre>`` tag that contains the code (that setting
 #s *new in Pygments 0.8*).

 #or compatibility with Pygments 0.7 and earlier, every true value
 #xcept ``'inline'`` means the same as ``'table'`` (in particular, that
 #eans also ``True``).

 #he default value is ``False``, which means no line numbers at all.

 #*Note:** with the default ("table") line number mechanism, the line
 #umbers and code can have different line heights in Internet Explorer
 #nless you give the enclosing ``<pre>`` tags an explicit ``line-height``
 #SS property (you get the default line spacing with ``line-height:
 #25%``).

 #hl_lines`
 #pecify a list of lines to be highlighted. The line numbers are always
 #elative to the input (i.e. the first line is line 1) and are
 #ndependent of `linenostart`.

 #. versionadded:: 0.11

 #linenostart`
 #he line number for the first line (default: ``1``).

 #linenostep`
 #f set to a number n > 1, only every nth line number is printed.

 #linenospecial`
 #f set to a number n > 0, every nth line number is given the CSS
 #lass ``"special"`` (default: ``0``).

 #nobackground`
 #f set to ``True``, the formatter won't output the background color
 #or the wrapping element (this automatically defaults to ``False``
 #hen there is no wrapping element [eg: no argument for the
 #get_syntax_defs` method given]) (default: ``False``).

 #. versionadded:: 0.6

 #lineseparator`
 #his string is output between lines of code. It defaults to ``"\n"``,
 #hich is enough to break a line inside ``<pre>`` tags, but you can
 #.g. set it to ``"<br>"`` to get HTML line breaks.

 #. versionadded:: 0.7

 #lineanchors`
 #f set to a nonempty string, e.g. ``foo``, the formatter will wrap each
 #utput line in an anchor tag with an ``id`` (and `name`) of ``foo-linenumber``.
 #his allows easy linking to certain lines.

 #. versionadded:: 0.9

 #linespans`
 #f set to a nonempty string, e.g. ``foo``, the formatter will wrap each
 #utput line in a span tag with an ``id`` of ``foo-linenumber``.
 #his allows easy access to lines via javascript.

 #. versionadded:: 1.6

 #anchorlinenos`
 #f set to `True`, will wrap line numbers in <a> tags. Used in
 #ombination with `linenos` and `lineanchors`.

 #tagsfile`
 #f set to the path of a ctags file, wrap names in anchor tags that
 #ink to their definitions. `lineanchors` should be used, and the
 #ags file should specify line numbers (see the `-n` option to ctags).

 #. versionadded:: 1.6

 #tagurlformat`
 # string formatting pattern used to generate links to ctags definitions.
 #vailable variables are `%(path)s`, `%(fname)s` and `%(fext)s`.
 #efaults to an empty string, resulting in just `#prefix-number` links.

 #. versionadded:: 1.6

 #filename`
 # string used to generate a filename when rendering ``<pre>`` blocks,
 #or example if displaying source code. If `linenos` is set to
 #`'table'`` then the filename will be rendered in an initial row
 #ontaining a single `<th>` which spans both columns.

 #. versionadded:: 2.1

 #wrapcode`
 #rap the code inside ``<pre>`` blocks using ``<code>``, as recommended
 #y the HTML5 specification.

 #. versionadded:: 2.4

 #debug_token_types`
 #dd ``title`` attributes to all token ``<span>`` tags that show the
 #ame of the token.

 #. versionadded:: 2.10


 #*Subclassing the HTML formatter**

 #. versionadded:: 0.7

 #he HTML formatter is now built in a way that allows easy subclassing, thus
 #ustomizing the output HTML code. The `format()` method calls
 #self._format_lines()` which returns a generator that yields tuples of ``(1,
 #ine)``, where the ``1`` indicates that the ``line`` is a line of the
 #ormatted source code.

 #f the `nowrap` option is set, the generator is the iterated over and the
 #esulting HTML is output.

 #therwise, `format()` calls `self.wrap()`, which wraps the generator with
 #ther generators. These may add some HTML code to the one generated by
 #_format_lines()`, either by modifying the lines generated by the latter,
 #hen yielding them again with ``(1, line)``, and/or by yielding other HTML
 #ode before or after the lines, with ``(0, html)``. The distinction between
 #ource lines and other code makes it possible to wrap the generator multiple
 #imes.

 #he default `wrap()` implementation adds a ``<div>`` and a ``<pre>`` tag.

 # custom `HtmlFormatter` subclass could look like this:

 #. sourcecode:: python

 #lass CodeHtmlFormatter(HtmlFormatter):

 #ef wrap(self, source, *, include_div):
 #eturn self._wrap_code(source)

 #ef _wrap_code(self, source):
 #ield 0, '<code>'
 #or i, t in source:
 #f i == 1:
                        # it's a line of formatted code
 # += '<br>'
 #ield i, t
 #ield 0, '</code>'

 #his results in wrapping the formatted lines with a ``<code>`` tag, where the
 #ource lines are broken using ``<br>`` tags.

 #fter calling `wrap()`, the `format()` method also adds the "line numbers"
 #nd/or "full document" wrappers if the respective options are set. Then, all
 #TML yielded by the wrapped generator is output.
 #""

 #ame = 'HTML'
 #liases = ['html']
 #ilenames = ['*.html', '*.htm']

 #ef __init__(self, **options):
 #ormatter.__init__(self, **options)
 #elf.title = self._decodeifneeded(self.title)
 #elf.nowrap = get_bool_opt(options, 'nowrap', False)
 #elf.noclasses = get_bool_opt(options, 'noclasses', False)
 #elf.classprefix = options.get('classprefix', '')
 #elf.cssclass = self._decodeifneeded(options.get('cssclass', 'highlight'))
 #elf.cssstyles = self._decodeifneeded(options.get('cssstyles', ''))
 #elf.prestyles = self._decodeifneeded(options.get('prestyles', ''))
 #elf.cssfile = self._decodeifneeded(options.get('cssfile', ''))
 #elf.noclobber_cssfile = get_bool_opt(options, 'noclobber_cssfile', False)
 #elf.tagsfile = self._decodeifneeded(options.get('tagsfile', ''))
 #elf.tagurlformat = self._decodeifneeded(options.get('tagurlformat', ''))
 #elf.filename = self._decodeifneeded(options.get('filename', ''))
 #elf.wrapcode = get_bool_opt(options, 'wrapcode', False)
 #elf.span_element_openers = {}
 #elf.debug_token_types = get_bool_opt(options, 'debug_token_types', False)

 #f self.tagsfile:
 #f not ctags:
 #aise RuntimeError('The "ctags" package must to be installed '
 #to be able to use the "tagsfile" feature.')
 #elf._ctags = ctags.CTags(self.tagsfile)

 #inenos = options.get('linenos', False)
 #f linenos == 'inline':
 #elf.linenos = 2
 #lif linenos:
            # compatibility with <= 0.7
 #elf.linenos = 1
 #lse:
 #elf.linenos = 0
 #elf.linenostart = abs(get_int_opt(options, 'linenostart', 1))
 #elf.linenostep = abs(get_int_opt(options, 'linenostep', 1))
 #elf.linenospecial = abs(get_int_opt(options, 'linenospecial', 0))
 #elf.nobackground = get_bool_opt(options, 'nobackground', False)
 #elf.lineseparator = options.get('lineseparator', '\n')
 #elf.lineanchors = options.get('lineanchors', '')
 #elf.linespans = options.get('linespans', '')
 #elf.anchorlinenos = get_bool_opt(options, 'anchorlinenos', False)
 #elf.hl_lines = set()
 #or lineno in get_list_opt(options, 'hl_lines', []):
 #ry:
 #elf.hl_lines.add(int(lineno))
 #xcept ValueError:
 #ass

 #elf._create_stylesheet()

 #ef _get_css_class(self, ttype):
 #""Return the css class of this token type prefixed with
 #he classprefix option."""
 #typeclass = _get_ttype_class(ttype)
 #f ttypeclass:
 #eturn self.classprefix + ttypeclass
 #eturn ''

 #ef _get_css_classes(self, ttype):
 #""Return the CSS classes of this token type prefixed with the classprefix option."""
 #ls = self._get_css_class(ttype)
 #hile ttype not in STANDARD_TYPES:
 #type = ttype.parent
 #ls = self._get_css_class(ttype) + ' ' + cls
 #eturn cls or ''

 #ef _get_css_inline_styles(self, ttype):
 #""Return the inline CSS styles for this token type."""
 #class = self.ttype2class.get(ttype)
 #hile cclass is None:
 #type = ttype.parent
 #class = self.ttype2class.get(ttype)
 #eturn cclass or ''

 #ef _create_stylesheet(self):
 #2c = self.ttype2class = {Token: ''}
 #2s = self.class2style = {}
 #or ttype, ndef in self.style:
 #ame = self._get_css_class(ttype)
 #tyle = ''
 #f ndef['color']:
 #tyle += 'color: %s; ' % webify(ndef['color'])
 #f ndef['bold']:
 #tyle += 'font-weight: bold; '
 #f ndef['italic']:
 #tyle += 'font-style: italic; '
 #f ndef['underline']:
 #tyle += 'text-decoration: underline; '
 #f ndef['bgcolor']:
 #tyle += 'background-color: %s; ' % webify(ndef['bgcolor'])
 #f ndef['border']:
 #tyle += 'border: 1px solid %s; ' % webify(ndef['border'])
 #f style:
 #2c[ttype] = name
                # save len(ttype) to enable ordering the styles by
                # hierarchy (necessary for CSS cascading rules!)
 #2s[name] = (style[:-2], ttype, len(ttype))

 #ef get_style_defs(self, arg=None):
 #""
 #eturn CSS style definitions for the classes produced by the current
 #ighlighting style. ``arg`` can be a string or list of selectors to
 #nsert before the token type classes.
 #""
 #tyle_lines = []

 #tyle_lines.extend(self.get_linenos_style_defs())
 #tyle_lines.extend(self.get_background_style_defs(arg))
 #tyle_lines.extend(self.get_token_style_defs(arg))

 #eturn '\n'.join(style_lines)

 #ef get_token_style_defs(self, arg=None):
 #refix = self.get_css_prefix(arg)

 #tyles = [
 #level, ttype, cls, style)
 #or cls, (style, ttype, level) in self.class2style.items()
 #f cls and style
 #
 #tyles.sort()

 #ines = [
 #%s { %s } /* %s */' % (prefix(cls), style, repr(ttype)[6:])
 #or (level, ttype, cls, style) in styles
 #

 #eturn lines

 #ef get_background_style_defs(self, arg=None):
 #refix = self.get_css_prefix(arg)
 #g_color = self.style.background_color
 #l_color = self.style.highlight_color

 #ines = []

 #f arg and not self.nobackground and bg_color is not None:
 #ext_style = ''
 #f Text in self.ttype2class:
 #ext_style = ' ' + self.class2style[self.ttype2class[Text]][0]
 #ines.insert(
 #, '%s{ background: %s;%s }' % (
 #refix(''), bg_color, text_style
 #
 #
 #f hl_color is not None:
 #ines.insert(
 #, '%s { background-color: %s }' % (prefix('hll'), hl_color)
 #

 #eturn lines

 #ef get_linenos_style_defs(self):
 #ines = [
 #pre { %s }' % self._pre_style,
 #td.linenos .normal { %s }' % self._linenos_style,
 #span.linenos { %s }' % self._linenos_style,
 #td.linenos .special { %s }' % self._linenos_special_style,
 #span.linenos.special { %s }' % self._linenos_special_style,
 #

 #eturn lines

 #ef get_css_prefix(self, arg):
 #f arg is None:
 #rg = ('cssclass' in self.options and '.'+self.cssclass or '')
 #f isinstance(arg, str):
 #rgs = [arg]
 #lse:
 #rgs = list(arg)

 #ef prefix(cls):
 #f cls:
 #ls = '.' + cls
 #mp = []
 #or arg in args:
 #mp.append((arg and arg + ' ' or '') + cls)
 #eturn ', '.join(tmp)

 #eturn prefix

 #property
 #ef _pre_style(self):
 #eturn 'line-height: 125%;'

 #property
 #ef _linenos_style(self):
 #eturn 'color: %s; background-color: %s; padding-left: 5px; padding-right: 5px;' % (
 #elf.style.line_number_color,
 #elf.style.line_number_background_color
 #

 #property
 #ef _linenos_special_style(self):
 #eturn 'color: %s; background-color: %s; padding-left: 5px; padding-right: 5px;' % (
 #elf.style.line_number_special_color,
 #elf.style.line_number_special_background_color
 #

 #ef _decodeifneeded(self, value):
 #f isinstance(value, bytes):
 #f self.encoding:
 #eturn value.decode(self.encoding)
 #eturn value.decode()
 #eturn value

 #ef _wrap_full(self, inner, outfile):
 #f self.cssfile:
 #f os.path.isabs(self.cssfile):
                # it's an absolute filename
 #ssfilename = self.cssfile
 #lse:
 #ry:
 #ilename = outfile.name
 #f not filename or filename[0] == '<':
                        # pseudo files, e.g. name == '<fdopen>'
 #aise AttributeError
 #ssfilename = os.path.join(os.path.dirname(filename),
 #elf.cssfile)
 #xcept AttributeError:
 #rint('Note: Cannot determine output file name, '
 #using current directory as base for the CSS file name',
 #ile=sys.stderr)
 #ssfilename = self.cssfile
            # write CSS file only if noclobber_cssfile isn't given as an option.
 #ry:
 #f not os.path.exists(cssfilename) or not self.noclobber_cssfile:
 #ith open(cssfilename, "w", encoding="utf-8") as cf:
 #f.write(CSSFILE_TEMPLATE %
 #'styledefs': self.get_style_defs('body')})
 #xcept OSError as err:
 #rr.strerror = 'Error writing CSS file: ' + err.strerror
 #aise

 #ield 0, (DOC_HEADER_EXTERNALCSS %
 #ict(title=self.title,
 #ssfile=self.cssfile,
 #ncoding=self.encoding))
 #lse:
 #ield 0, (DOC_HEADER %
 #ict(title=self.title,
 #tyledefs=self.get_style_defs('body'),
 #ncoding=self.encoding))

 #ield from inner
 #ield 0, DOC_FOOTER

 #ef _wrap_tablelinenos(self, inner):
 #ummyoutfile = StringIO()
 #ncount = 0
 #or t, line in inner:
 #f t:
 #ncount += 1
 #ummyoutfile.write(line)

 #l = self.linenostart
 #w = len(str(lncount + fl - 1))
 #p = self.linenospecial
 #t = self.linenostep
 #nchor_name = self.lineanchors or self.linespans
 #ln = self.anchorlinenos
 #ocls = self.noclasses

 #ines = []

 #or i in range(fl, fl+lncount):
 #rint_line = i % st == 0
 #pecial_line = sp and i % sp == 0

 #f print_line:
 #ine = '%*d' % (mw, i)
 #f aln:
 #ine = '<a href="#%s-%d">%s</a>' % (anchor_name, i, line)
 #lse:
 #ine = ' ' * mw

 #f nocls:
 #f special_line:
 #tyle = ' style="%s"' % self._linenos_special_style
 #lse:
 #tyle = ' style="%s"' % self._linenos_style
 #lse:
 #f special_line:
 #tyle = ' class="special"'
 #lse:
 #tyle = ' class="normal"'

 #f style:
 #ine = '<span%s>%s</span>' % (style, line)

 #ines.append(line)

 #s = '\n'.join(lines)

        # If a filename was specified, we can't put it into the code table as it
        # would misalign the line numbers. Hence we emit a separate row for it.
 #ilename_tr = ""
 #f self.filename:
 #ilename_tr = (
 #<tr><th colspan="2" class="filename">'
 #<span class="filename">' + self.filename + '</span>'
 #</th></tr>')

        # in case you wonder about the seemingly redundant <div> here: since the
        # content in the other cell also is wrapped in a div, some browsers in
        # some configurations seem to mess up the formatting...
 #ield 0, (f'<table class="{self.cssclass}table">' + filename_tr +
 #<tr><td class="linenos"><div class="linenodiv"><pre>' +
 #s + '</pre></div></td><td class="code">')
 #ield 0, '<div>'
 #ield 0, dummyoutfile.getvalue()
 #ield 0, '</div>'
 #ield 0, '</td></tr></table>'


 #ef _wrap_inlinelinenos(self, inner):
        # need a list of lines since we need the width of a single number :(
 #nner_lines = list(inner)
 #p = self.linenospecial
 #t = self.linenostep
 #um = self.linenostart
 #w = len(str(len(inner_lines) + num - 1))
 #nchor_name = self.lineanchors or self.linespans
 #ln = self.anchorlinenos
 #ocls = self.noclasses

 #or _, inner_line in inner_lines:
 #rint_line = num % st == 0
 #pecial_line = sp and num % sp == 0

 #f print_line:
 #ine = '%*d' % (mw, num)
 #lse:
 #ine = ' ' * mw

 #f nocls:
 #f special_line:
 #tyle = ' style="%s"' % self._linenos_special_style
 #lse:
 #tyle = ' style="%s"' % self._linenos_style
 #lse:
 #f special_line:
 #tyle = ' class="linenos special"'
 #lse:
 #tyle = ' class="linenos"'

 #f style:
 #inenos = '<span%s>%s</span>' % (style, line)
 #lse:
 #inenos = line

 #f aln:
 #ield 1, ('<a href="#%s-%d">%s</a>' % (anchor_name, num, linenos) +
 #nner_line)
 #lse:
 #ield 1, linenos + inner_line
 #um += 1

 #ef _wrap_lineanchors(self, inner):
 # = self.lineanchors
        # subtract 1 since we have to increment i *before* yielding
 # = self.linenostart - 1
 #or t, line in inner:
 #f t:
 # += 1
 #ref = "" if self.linenos else ' href="#%s-%d"' % (s, i)
 #ield 1, '<a id="%s-%d" name="%s-%d"%s></a>' % (s, i, s, i, href) + line
 #lse:
 #ield 0, line

 #ef _wrap_linespans(self, inner):
 # = self.linespans
 # = self.linenostart - 1
 #or t, line in inner:
 #f t:
 # += 1
 #ield 1, '<span id="%s-%d">%s</span>' % (s, i, line)
 #lse:
 #ield 0, line

 #ef _wrap_div(self, inner):
 #tyle = []
 #f (self.noclasses and not self.nobackground and
 #elf.style.background_color is not None):
 #tyle.append('background: %s' % (self.style.background_color,))
 #f self.cssstyles:
 #tyle.append(self.cssstyles)
 #tyle = '; '.join(style)

 #ield 0, ('<div' + (self.cssclass and ' class="%s"' % self.cssclass) +
 #style and (' style="%s"' % style)) + '>')
 #ield from inner
 #ield 0, '</div>\n'

 #ef _wrap_pre(self, inner):
 #tyle = []
 #f self.prestyles:
 #tyle.append(self.prestyles)
 #f self.noclasses:
 #tyle.append(self._pre_style)
 #tyle = '; '.join(style)

 #f self.filename and self.linenos != 1:
 #ield 0, ('<span class="filename">' + self.filename + '</span>')

        # the empty span here is to keep leading empty lines from being
        # ignored by HTML parsers
 #ield 0, ('<pre' + (style and ' style="%s"' % style) + '><span></span>')
 #ield from inner
 #ield 0, '</pre>'

 #ef _wrap_code(self, inner):
 #ield 0, '<code>'
 #ield from inner
 #ield 0, '</code>'

 #functools.lru_cache(maxsize=100)
 #ef _translate_parts(self, value):
 #""HTML-escape a value and split it by newlines."""
 #eturn value.translate(_escape_html_table).split('\n')

 #ef _format_lines(self, tokensource):
 #""
 #ust format the tokens, without any wrapping tags.
 #ield individual lines.
 #""
 #ocls = self.noclasses
 #sep = self.lineseparator
 #agsfile = self.tagsfile

 #span = ''
 #ine = []
 #or ttype, value in tokensource:
 #ry:
 #span = self.span_element_openers[ttype]
 #xcept KeyError:
 #itle = ' title="%s"' % '.'.join(ttype) if self.debug_token_types else ''
 #f nocls:
 #ss_style = self._get_css_inline_styles(ttype)
 #f css_style:
 #ss_style = self.class2style[css_style][0]
 #span = '<span style="%s"%s>' % (css_style, title)
 #lse:
 #span = ''
 #lse:
 #ss_class = self._get_css_classes(ttype)
 #f css_class:
 #span = '<span class="%s"%s>' % (css_class, title)
 #lse:
 #span = ''
 #elf.span_element_openers[ttype] = cspan

 #arts = self._translate_parts(value)

 #f tagsfile and ttype in Token.Name:
 #ilename, linenumber = self._lookup_ctag(value)
 #f linenumber:
 #ase, filename = os.path.split(filename)
 #f base:
 #ase += '/'
 #ilename, extension = os.path.splitext(filename)
 #rl = self.tagurlformat % {'path': base, 'fname': filename,
 #fext': extension}
 #arts[0] = "<a href=\"%s#%s-%d\">%s" % \
 #url, self.lineanchors, linenumber, parts[0])
 #arts[-1] = parts[-1] + "</a>"

            # for all but the last line
 #or part in parts[:-1]:
 #f line:
                    # Also check for part being non-empty, so we avoid creating
                    # empty <span> tags
 #f lspan != cspan and part:
 #ine.extend(((lspan and '</span>'), cspan, part,
 #cspan and '</span>'), lsep))
 #lse:  # both are the same, or the current part was empty
 #ine.extend((part, (lspan and '</span>'), lsep))
 #ield 1, ''.join(line)
 #ine = []
 #lif part:
 #ield 1, ''.join((cspan, part, (cspan and '</span>'), lsep))
 #lse:
 #ield 1, lsep
            # for the last line
 #f line and parts[-1]:
 #f lspan != cspan:
 #ine.extend(((lspan and '</span>'), cspan, parts[-1]))
 #span = cspan
 #lse:
 #ine.append(parts[-1])
 #lif parts[-1]:
 #ine = [cspan, parts[-1]]
 #span = cspan
            # else we neither have to open a new span nor set lspan

 #f line:
 #ine.extend(((lspan and '</span>'), lsep))
 #ield 1, ''.join(line)

 #ef _lookup_ctag(self, token):
 #ntry = ctags.TagEntry()
 #f self._ctags.find(entry, token.encode(), 0):
 #eturn entry['file'], entry['lineNumber']
 #lse:
 #eturn None, None

 #ef _highlight_lines(self, tokensource):
 #""
 #ighlighted the lines specified in the `hl_lines` option by
 #ost-processing the token stream coming from `_format_lines`.
 #""
 #ls = self.hl_lines

 #or i, (t, value) in enumerate(tokensource):
 #f t != 1:
 #ield t, value
 #f i + 1 in hls:  # i + 1 because Python indexes start at 0
 #f self.noclasses:
 #tyle = ''
 #f self.style.highlight_color is not None:
 #tyle = (' style="background-color: %s"' %
 #self.style.highlight_color,))
 #ield 1, '<span%s>%s</span>' % (style, value)
 #lse:
 #ield 1, '<span class="hll">%s</span>' % value
 #lse:
 #ield 1, value

 #ef wrap(self, source):
 #""
 #rap the ``source``, which is a generator yielding
 #ndividual lines, in custom generators. See docstring
 #or `format`. Can be overridden.
 #""

 #utput = source
 #f self.wrapcode:
 #utput = self._wrap_code(output)

 #utput = self._wrap_pre(output)

 #eturn output

 #ef format_unencoded(self, tokensource, outfile):
 #""
 #he formatting process uses several nested generators; which of
 #hem are used is determined by the user's options.

 #ach generator should take at least one argument, ``inner``,
 #nd wrap the pieces of text generated by this.

 #lways yield 2-tuples: (code, text). If "code" is 1, the text
 #s part of the original tokensource being highlighted, if it's
 #, the text is some piece of wrapping. This makes it possible to
 #se several different wrappers that process the original source
 #inewise, e.g. line number generators.
 #""
 #ource = self._format_lines(tokensource)

        # As a special case, we wrap line numbers before line highlighting
        # so the line numbers get wrapped in the highlighting tag.
 #f not self.nowrap and self.linenos == 2:
 #ource = self._wrap_inlinelinenos(source)

 #f self.hl_lines:
 #ource = self._highlight_lines(source)

 #f not self.nowrap:
 #f self.lineanchors:
 #ource = self._wrap_lineanchors(source)
 #f self.linespans:
 #ource = self._wrap_linespans(source)
 #ource = self.wrap(source)
 #f self.linenos == 1:
 #ource = self._wrap_tablelinenos(source)
 #ource = self._wrap_div(source)
 #f self.full:
 #ource = self._wrap_full(source, outfile)

 #or t, piece in source:
 #utfile.write(piece)
