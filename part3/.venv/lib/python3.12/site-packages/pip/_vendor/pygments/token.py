"""
 #ygments.token
 #~~~~~~~~~~~~~

 #asic token types and the standard tokens.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""


class _TokenType(tuple):
 #arent = None

 #ef split(self):
 #uf = []
 #ode = self
 #hile node is not None:
 #uf.append(node)
 #ode = node.parent
 #uf.reverse()
 #eturn buf

 #ef __init__(self, *args):
        # no need to call super.__init__
 #elf.subtypes = set()

 #ef __contains__(self, val):
 #eturn self is val or (
 #ype(val) is self.__class__ and
 #al[:len(self)] == self
 #

 #ef __getattr__(self, val):
 #f not val or not val[0].isupper():
 #eturn tuple.__getattribute__(self, val)
 #ew = _TokenType(self + (val,))
 #etattr(self, val, new)
 #elf.subtypes.add(new)
 #ew.parent = self
 #eturn new

 #ef __repr__(self):
 #eturn 'Token' + (self and '.' or '') + '.'.join(self)

 #ef __copy__(self):
        # These instances are supposed to be singletons
 #eturn self

 #ef __deepcopy__(self, memo):
        # These instances are supposed to be singletons
 #eturn self


Token = _TokenType()

# Special token types
Text = Token.Text
Whitespace = Text.Whitespace
Escape = Token.Escape
Error = Token.Error
# Text that doesn't belong to this lexer (e.g. HTML in PHP)
Other = Token.Other

# Common token types for source code
Keyword = Token.Keyword
Name = Token.Name
Literal = Token.Literal
String = Literal.String
Number = Literal.Number
Punctuation = Token.Punctuation
Operator = Token.Operator
Comment = Token.Comment

# Generic types for non-source code
Generic = Token.Generic

# String and some others are not direct children of Token.
# alias them:
Token.Token = Token
Token.String = String
Token.Number = Number


def is_token_subtype(ttype, other):
 #""
 #eturn True if ``ttype`` is a subtype of ``other``.

 #xists for backwards compatibility. use ``ttype in other`` now.
 #""
 #eturn ttype in other


def string_to_tokentype(s):
 #""
 #onvert a string into a token type::

 #>> string_to_token('String.Double')
 #oken.Literal.String.Double
 #>> string_to_token('Token.Literal.Number')
 #oken.Literal.Number
 #>> string_to_token('')
 #oken

 #okens that are already tokens are returned unchanged:

 #>> string_to_token(String)
 #oken.Literal.String
 #""
 #f isinstance(s, _TokenType):
 #eturn s
 #f not s:
 #eturn Token
 #ode = Token
 #or item in s.split('.'):
 #ode = getattr(node, item)
 #eturn node


# Map standard token types to short names, used in CSS class naming.
# If you add a new item, please be sure to run this file to perform
# a consistency check for duplicate values.
STANDARD_TYPES = {
 #oken:                         '',

 #ext:                          '',
 #hitespace:                    'w',
 #scape:                        'esc',
 #rror:                         'err',
 #ther:                         'x',

 #eyword:                       'k',
 #eyword.Constant:              'kc',
 #eyword.Declaration:           'kd',
 #eyword.Namespace:             'kn',
 #eyword.Pseudo:                'kp',
 #eyword.Reserved:              'kr',
 #eyword.Type:                  'kt',

 #ame:                          'n',
 #ame.Attribute:                'na',
 #ame.Builtin:                  'nb',
 #ame.Builtin.Pseudo:           'bp',
 #ame.Class:                    'nc',
 #ame.Constant:                 'no',
 #ame.Decorator:                'nd',
 #ame.Entity:                   'ni',
 #ame.Exception:                'ne',
 #ame.Function:                 'nf',
 #ame.Function.Magic:           'fm',
 #ame.Property:                 'py',
 #ame.Label:                    'nl',
 #ame.Namespace:                'nn',
 #ame.Other:                    'nx',
 #ame.Tag:                      'nt',
 #ame.Variable:                 'nv',
 #ame.Variable.Class:           'vc',
 #ame.Variable.Global:          'vg',
 #ame.Variable.Instance:        'vi',
 #ame.Variable.Magic:           'vm',

 #iteral:                       'l',
 #iteral.Date:                  'ld',

 #tring:                        's',
 #tring.Affix:                  'sa',
 #tring.Backtick:               'sb',
 #tring.Char:                   'sc',
 #tring.Delimiter:              'dl',
 #tring.Doc:                    'sd',
 #tring.Double:                 's2',
 #tring.Escape:                 'se',
 #tring.Heredoc:                'sh',
 #tring.Interpol:               'si',
 #tring.Other:                  'sx',
 #tring.Regex:                  'sr',
 #tring.Single:                 's1',
 #tring.Symbol:                 'ss',

 #umber:                        'm',
 #umber.Bin:                    'mb',
 #umber.Float:                  'mf',
 #umber.Hex:                    'mh',
 #umber.Integer:                'mi',
 #umber.Integer.Long:           'il',
 #umber.Oct:                    'mo',

 #perator:                      'o',
 #perator.Word:                 'ow',

 #unctuation:                   'p',
 #unctuation.Marker:            'pm',

 #omment:                       'c',
 #omment.Hashbang:              'ch',
 #omment.Multiline:             'cm',
 #omment.Preproc:               'cp',
 #omment.PreprocFile:           'cpf',
 #omment.Single:                'c1',
 #omment.Special:               'cs',

 #eneric:                       'g',
 #eneric.Deleted:               'gd',
 #eneric.Emph:                  'ge',
 #eneric.Error:                 'gr',
 #eneric.Heading:               'gh',
 #eneric.Inserted:              'gi',
 #eneric.Output:                'go',
 #eneric.Prompt:                'gp',
 #eneric.Strong:                'gs',
 #eneric.Subheading:            'gu',
 #eneric.Traceback:             'gt',
}
