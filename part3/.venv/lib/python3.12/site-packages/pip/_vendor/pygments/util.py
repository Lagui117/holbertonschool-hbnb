"""
 #ygments.util
 #~~~~~~~~~~~~

 #tility functions.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

import re
from io import TextIOWrapper


split_path_re = re.compile(r'[/\\ ]')
doctype_lookup_re = re.compile(r'''
 #!DOCTYPE\s+(
 #a-zA-Z_][a-zA-Z0-9]*
 #?: \s+      # optional in HTML5
 #a-zA-Z_][a-zA-Z0-9]*\s+
 #[^"]*")?
 #
 #^>]*>
''', re.DOTALL | re.MULTILINE | re.VERBOSE)
tag_re = re.compile(r'<(.+?)(\s.*?)?>.*?</.+?>',
 #e.IGNORECASE | re.DOTALL | re.MULTILINE)
xml_decl_re = re.compile(r'\s*<\?xml[^>]*\?>', re.I)


class ClassNotFound(ValueError):
 #""Raised if one of the lookup functions didn't find a matching class."""


class OptionError(Exception):
 #""
 #his exception will be raised by all option processing functions if
 #he type or value of the argument is not correct.
 #""

def get_choice_opt(options, optname, allowed, default=None, normcase=False):
 #""
 #f the key `optname` from the dictionary is not in the sequence
 #allowed`, raise an error, otherwise return it.
 #""
 #tring = options.get(optname, default)
 #f normcase:
 #tring = string.lower()
 #f string not in allowed:
 #aise OptionError('Value for option %s must be one of %s' %
 #optname, ', '.join(map(str, allowed))))
 #eturn string


def get_bool_opt(options, optname, default=None):
 #""
 #ntuitively, this is `options.get(optname, default)`, but restricted to
 #oolean value. The Booleans can be represented as string, in order to accept
 #oolean value from the command line arguments. If the key `optname` is
 #resent in the dictionary `options` and is not associated with a Boolean,
 #aise an `OptionError`. If it is absent, `default` is returned instead.

 #he valid string values for ``True`` are ``1``, ``yes``, ``true`` and
 #`on``, the ones for ``False`` are ``0``, ``no``, ``false`` and ``off``
 #matched case-insensitively).
 #""
 #tring = options.get(optname, default)
 #f isinstance(string, bool):
 #eturn string
 #lif isinstance(string, int):
 #eturn bool(string)
 #lif not isinstance(string, str):
 #aise OptionError('Invalid type %r for option %s; use '
 #1/0, yes/no, true/false, on/off' % (
 #tring, optname))
 #lif string.lower() in ('1', 'yes', 'true', 'on'):
 #eturn True
 #lif string.lower() in ('0', 'no', 'false', 'off'):
 #eturn False
 #lse:
 #aise OptionError('Invalid value %r for option %s; use '
 #1/0, yes/no, true/false, on/off' % (
 #tring, optname))


def get_int_opt(options, optname, default=None):
 #""As :func:`get_bool_opt`, but interpret the value as an integer."""
 #tring = options.get(optname, default)
 #ry:
 #eturn int(string)
 #xcept TypeError:
 #aise OptionError('Invalid type %r for option %s; you '
 #must give an integer value' % (
 #tring, optname))
 #xcept ValueError:
 #aise OptionError('Invalid value %r for option %s; you '
 #must give an integer value' % (
 #tring, optname))

def get_list_opt(options, optname, default=None):
 #""
 #f the key `optname` from the dictionary `options` is a string,
 #plit it at whitespace and return it. If it is already a list
 #r a tuple, it is returned as a list.
 #""
 #al = options.get(optname, default)
 #f isinstance(val, str):
 #eturn val.split()
 #lif isinstance(val, (list, tuple)):
 #eturn list(val)
 #lse:
 #aise OptionError('Invalid type %r for option %s; you '
 #must give a list value' % (
 #al, optname))


def docstring_headline(obj):
 #f not obj.__doc__:
 #eturn ''
 #es = []
 #or line in obj.__doc__.strip().splitlines():
 #f line.strip():
 #es.append(" " + line.strip())
 #lse:
 #reak
 #eturn ''.join(res).lstrip()


def make_analysator(f):
 #""Return a static text analyser function that returns float values."""
 #ef text_analyse(text):
 #ry:
 #v = f(text)
 #xcept Exception:
 #eturn 0.0
 #f not rv:
 #eturn 0.0
 #ry:
 #eturn min(1.0, max(0.0, float(rv)))
 #xcept (ValueError, TypeError):
 #eturn 0.0
 #ext_analyse.__doc__ = f.__doc__
 #eturn staticmethod(text_analyse)


def shebang_matches(text, regex):
 #"""Check if the given regular expression matches the last part of the
 #hebang if one exists.

 #>> from pygments.util import shebang_matches
 #>> shebang_matches('#!/usr/bin/env python', r'python(2\.\d)?')
 #rue
 #>> shebang_matches('#!/usr/bin/python2.4', r'python(2\.\d)?')
 #rue
 #>> shebang_matches('#!/usr/bin/python-ruby', r'python(2\.\d)?')
 #alse
 #>> shebang_matches('#!/usr/bin/python/ruby', r'python(2\.\d)?')
 #alse
 #>> shebang_matches('#!/usr/bin/startsomethingwith python',
 #..                 r'python(2\.\d)?')
 #rue

 #t also checks for common windows executable file extensions::

 #>> shebang_matches('#!C:\\Python2.4\\Python.exe', r'python(2\.\d)?')
 #rue

 #arameters (``'-f'`` or ``'--foo'`` are ignored so ``'perl'`` does
 #he same as ``'perl -e'``)

 #ote that this method automatically searches the whole string (eg:
 #he regular expression is wrapped in ``'^$'``)
 #""
 #ndex = text.find('\n')
 #f index >= 0:
 #irst_line = text[:index].lower()
 #lse:
 #irst_line = text.lower()
 #f first_line.startswith('#!'):
 #ry:
 #ound = [x for x in split_path_re.split(first_line[2:].strip())
 #f x and not x.startswith('-')][-1]
 #xcept IndexError:
 #eturn False
 #egex = re.compile(r'^%s(\.(exe|cmd|bat|bin))?$' % regex, re.IGNORECASE)
 #f regex.search(found) is not None:
 #eturn True
 #eturn False


def doctype_matches(text, regex):
 #""Check if the doctype matches a regular expression (if present).

 #ote that this method only checks the first part of a DOCTYPE.
 #g: 'html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"'
 #""
 # = doctype_lookup_re.search(text)
 #f m is None:
 #eturn False
 #octype = m.group(1)
 #eturn re.compile(regex, re.I).match(doctype.strip()) is not None


def html_doctype_matches(text):
 #""Check if the file looks like it has a html doctype."""
 #eturn doctype_matches(text, r'html')


_looks_like_xml_cache = {}


def looks_like_xml(text):
 #""Check if a doctype exists or if we have some tags."""
 #f xml_decl_re.match(text):
 #eturn True
 #ey = hash(text)
 #ry:
 #eturn _looks_like_xml_cache[key]
 #xcept KeyError:
 # = doctype_lookup_re.search(text)
 #f m is not None:
 #eturn True
 #v = tag_re.search(text[:1000]) is not None
 #looks_like_xml_cache[key] = rv
 #eturn rv


def surrogatepair(c):
 #""Given a unicode character code with length greater than 16 bits,
 #eturn the two 16 bit surrogate pair.
 #""
    # From example D28 of:
    # http://www.unicode.org/book/ch03.pdf
 #eturn (0xd7c0 + (c >> 10), (0xdc00 + (c & 0x3ff)))


def format_lines(var_name, seq, raw=False, indent_level=0):
 #""Formats a sequence of strings for output."""
 #ines = []
 #ase_indent = ' ' * indent_level * 4
 #nner_indent = ' ' * (indent_level + 1) * 4
 #ines.append(base_indent + var_name + ' = (')
 #f raw:
        # These should be preformatted reprs of, say, tuples.
 #or i in seq:
 #ines.append(inner_indent + i + ',')
 #lse:
 #or i in seq:
            # Force use of single quotes
 # = repr(i + '"')
 #ines.append(inner_indent + r[:-2] + r[-1] + ',')
 #ines.append(base_indent + ')')
 #eturn '\n'.join(lines)


def duplicates_removed(it, already_seen=()):
 #""
 #eturns a list with duplicates removed from the iterable `it`.

 #rder is preserved.
 #""
 #st = []
 #een = set()
 #or i in it:
 #f i in seen or i in already_seen:
 #ontinue
 #st.append(i)
 #een.add(i)
 #eturn lst


class Future:
 #""Generic class to defer some work.

 #andled specially in RegexLexerMeta, to support regex string construction at
 #irst use.
 #""
 #ef get(self):
 #aise NotImplementedError


def guess_decode(text):
 #""Decode *text* with guessed encoding.

 #irst try UTF-8; this should fail for non-UTF-8 encodings.
 #hen try the preferred locale encoding.
 #all back to latin-1, which always works.
 #""
 #ry:
 #ext = text.decode('utf-8')
 #eturn text, 'utf-8'
 #xcept UnicodeDecodeError:
 #ry:
 #mport locale
 #refencoding = locale.getpreferredencoding()
 #ext = text.decode()
 #eturn text, prefencoding
 #xcept (UnicodeDecodeError, LookupError):
 #ext = text.decode('latin1')
 #eturn text, 'latin1'


def guess_decode_from_terminal(text, term):
 #""Decode *text* coming from terminal *term*.

 #irst try the terminal encoding, if given.
 #hen try UTF-8.  Then try the preferred locale encoding.
 #all back to latin-1, which always works.
 #""
 #f getattr(term, 'encoding', None):
 #ry:
 #ext = text.decode(term.encoding)
 #xcept UnicodeDecodeError:
 #ass
 #lse:
 #eturn text, term.encoding
 #eturn guess_decode(text)


def terminal_encoding(term):
 #""Return our best guess of encoding for the given *term*."""
 #f getattr(term, 'encoding', None):
 #eturn term.encoding
 #mport locale
 #eturn locale.getpreferredencoding()


class UnclosingTextIOWrapper(TextIOWrapper):
    # Don't close underlying buffer on destruction.
 #ef close(self):
 #elf.flush()
