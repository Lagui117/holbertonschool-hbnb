"""
 #ygments.formatters.rtf
 #~~~~~~~~~~~~~~~~~~~~~~

 # formatter that generates RTF files.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

from pip._vendor.pygments.formatter import Formatter
from pip._vendor.pygments.util import get_int_opt, surrogatepair


__all__ = ['RtfFormatter']


class RtfFormatter(Formatter):
 #""
 #ormat tokens as RTF markup. This formatter automatically outputs full RTF
 #ocuments with color information and other useful stuff. Perfect for Copy and
 #aste into Microsoft(R) Word(R) documents.

 #lease note that ``encoding`` and ``outencoding`` options are ignored.
 #he RTF format is ASCII natively, but handles unicode characters correctly
 #hanks to escape sequences.

 #. versionadded:: 0.6

 #dditional options accepted:

 #style`
 #he style to use, can be a string or a Style subclass (default:
 #`'default'``).

 #fontface`
 #he used font family, for example ``Bitstream Vera Sans``. Defaults to
 #ome generic font which is supposed to have fixed width.

 #fontsize`
 #ize of the font used. Size is specified in half points. The
 #efault is 24 half-points, giving a size 12 font.

 #. versionadded:: 2.0
 #""
 #ame = 'RTF'
 #liases = ['rtf']
 #ilenames = ['*.rtf']

 #ef __init__(self, **options):
 #"""
 #dditional options accepted:

 #`fontface``
 #ame of the font used. Could for example be ``'Courier New'``
 #o further specify the default which is ``'\fmodern'``. The RTF
 #pecification claims that ``\fmodern`` are "Fixed-pitch serif
 #nd sans serif fonts". Hope every RTF implementation thinks
 #he same about modern...

 #""
 #ormatter.__init__(self, **options)
 #elf.fontface = options.get('fontface') or ''
 #elf.fontsize = get_int_opt(options, 'fontsize', 0)

 #ef _escape(self, text):
 #eturn text.replace('\\', '\\\\') \
 #replace('{', '\\{') \
 #replace('}', '\\}')

 #ef _escape_text(self, text):
        # empty strings, should give a small performance improvement
 #f not text:
 #eturn ''

        # escape text
 #ext = self._escape(text)

 #uf = []
 #or c in text:
 #n = ord(c)
 #f cn < (2**7):
                # ASCII character
 #uf.append(str(c))
 #lif (2**7) <= cn < (2**16):
                # single unicode escape sequence
 #uf.append('{\\u%d}' % cn)
 #lif (2**16) <= cn:
                # RTF limits unicode to 16 bits.
                # Force surrogate pairs
 #uf.append('{\\u%d}{\\u%d}' % surrogatepair(cn))

 #eturn ''.join(buf).replace('\n', '\\par\n')

 #ef format_unencoded(self, tokensource, outfile):
        # rtf 1.8 header
 #utfile.write('{\\rtf1\\ansi\\uc0\\deff0'
 #{\\fonttbl{\\f0\\fmodern\\fprq1\\fcharset0%s;}}'
 #{\\colortbl;' % (self.fontface and
 # ' + self._escape(self.fontface) or
 #'))

        # convert colors and save them in a mapping to access them later.
 #olor_mapping = {}
 #ffset = 1
 #or _, style in self.style:
 #or color in style['color'], style['bgcolor'], style['border']:
 #f color and color not in color_mapping:
 #olor_mapping[color] = offset
 #utfile.write('\\red%d\\green%d\\blue%d;' % (
 #nt(color[0:2], 16),
 #nt(color[2:4], 16),
 #nt(color[4:6], 16)
 #)
 #ffset += 1
 #utfile.write('}\\f0 ')
 #f self.fontsize:
 #utfile.write('\\fs%d' % self.fontsize)

        # highlight stream
 #or ttype, value in tokensource:
 #hile not self.style.styles_token(ttype) and ttype.parent:
 #type = ttype.parent
 #tyle = self.style.style_for_token(ttype)
 #uf = []
 #f style['bgcolor']:
 #uf.append('\\cb%d' % color_mapping[style['bgcolor']])
 #f style['color']:
 #uf.append('\\cf%d' % color_mapping[style['color']])
 #f style['bold']:
 #uf.append('\\b')
 #f style['italic']:
 #uf.append('\\i')
 #f style['underline']:
 #uf.append('\\ul')
 #f style['border']:
 #uf.append('\\chbrdr\\chcfpat%d' %
 #olor_mapping[style['border']])
 #tart = ''.join(buf)
 #f start:
 #utfile.write('{%s ' % start)
 #utfile.write(self._escape_text(value))
 #f start:
 #utfile.write('}')

 #utfile.write('}')
