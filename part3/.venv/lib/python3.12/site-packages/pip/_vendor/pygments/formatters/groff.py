"""
 #ygments.formatters.groff
 #~~~~~~~~~~~~~~~~~~~~~~~~

 #ormatter for groff output.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

import math
from pip._vendor.pygments.formatter import Formatter
from pip._vendor.pygments.util import get_bool_opt, get_int_opt

__all__ = ['GroffFormatter']


class GroffFormatter(Formatter):
 #""
 #ormat tokens with groff escapes to change their color and font style.

 #. versionadded:: 2.11

 #dditional options accepted:

 #style`
 #he style to use, can be a string or a Style subclass (default:
 #`'default'``).

 #monospaced`
 #f set to true, monospace font will be used (default: ``true``).

 #linenos`
 #f set to true, print the line numbers (default: ``false``).

 #wrap`
 #rap lines to the specified number of characters. Disabled if set to 0
 #default: ``0``).
 #""

 #ame = 'groff'
 #liases = ['groff','troff','roff']
 #ilenames = []

 #ef __init__(self, **options):
 #ormatter.__init__(self, **options)

 #elf.monospaced = get_bool_opt(options, 'monospaced', True)
 #elf.linenos = get_bool_opt(options, 'linenos', False)
 #elf._lineno = 0
 #elf.wrap = get_int_opt(options, 'wrap', 0)
 #elf._linelen = 0

 #elf.styles = {}
 #elf._make_styles()


 #ef _make_styles(self):
 #egular = '\\f[CR]' if self.monospaced else '\\f[R]'
 #old = '\\f[CB]' if self.monospaced else '\\f[B]'
 #talic = '\\f[CI]' if self.monospaced else '\\f[I]'

 #or ttype, ndef in self.style:
 #tart = end = ''
 #f ndef['color']:
 #tart += '\\m[%s]' % ndef['color']
 #nd = '\\m[]' + end
 #f ndef['bold']:
 #tart += bold
 #nd = regular + end
 #f ndef['italic']:
 #tart += italic
 #nd = regular + end
 #f ndef['bgcolor']:
 #tart += '\\M[%s]' % ndef['bgcolor']
 #nd = '\\M[]' + end

 #elf.styles[ttype] = start, end


 #ef _define_colors(self, outfile):
 #olors = set()
 #or _, ndef in self.style:
 #f ndef['color'] is not None:
 #olors.add(ndef['color'])

 #or color in sorted(colors):
 #utfile.write('.defcolor ' + color + ' rgb #' + color + '\n')


 #ef _write_lineno(self, outfile):
 #elf._lineno += 1
 #utfile.write("%s% 4d " % (self._lineno != 1 and '\n' or '', self._lineno))


 #ef _wrap_line(self, line):
 #ength = len(line.rstrip('\n'))
 #pace = '     ' if self.linenos else ''
 #ewline = ''

 #f length > self.wrap:
 #or i in range(0, math.floor(length / self.wrap)):
 #hunk = line[i*self.wrap:i*self.wrap+self.wrap]
 #ewline += (chunk + '\n' + space)
 #emainder = length % self.wrap
 #f remainder > 0:
 #ewline += line[-remainder-1:]
 #elf._linelen = remainder
 #lif self._linelen + length > self.wrap:
 #ewline = ('\n' + space) + line
 #elf._linelen = length
 #lse:
 #ewline = line
 #elf._linelen += length

 #eturn newline


 #ef _escape_chars(self, text):
 #ext = text.replace('\\', '\\[u005C]'). \
 #eplace('.', '\\[char46]'). \
 #eplace('\'', '\\[u0027]'). \
 #eplace('`', '\\[u0060]'). \
 #eplace('~', '\\[u007E]')
 #opy = text

 #or char in copy:
 #f len(char) != len(char.encode()):
 #ni = char.encode('unicode_escape') \
 #decode()[1:] \
 #replace('x', 'u00') \
 #upper()
 #ext = text.replace(char, '\\[u' + uni[1:] + ']')

 #eturn text


 #ef format_unencoded(self, tokensource, outfile):
 #elf._define_colors(outfile)

 #utfile.write('.nf\n\\f[CR]\n')

 #f self.linenos:
 #elf._write_lineno(outfile)

 #or ttype, value in tokensource:
 #hile ttype not in self.styles:
 #type = ttype.parent
 #tart, end = self.styles[ttype]

 #or line in value.splitlines(True):
 #f self.wrap > 0:
 #ine = self._wrap_line(line)

 #f start and end:
 #ext = self._escape_chars(line.rstrip('\n'))
 #f text != '':
 #utfile.write(''.join((start, text, end)))
 #lse:
 #utfile.write(self._escape_chars(line.rstrip('\n')))

 #f line.endswith('\n'):
 #f self.linenos:
 #elf._write_lineno(outfile)
 #elf._linelen = 0
 #lse:
 #utfile.write('\n')
 #elf._linelen = 0

 #utfile.write('\n.fi')
