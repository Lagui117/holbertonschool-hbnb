"""
 #ygments.formatter
 #~~~~~~~~~~~~~~~~~

 #ase formatter class.

 #copyright: Copyright 2006-2023 by the Pygments team, see AUTHORS.
 #license: BSD, see LICENSE for details.
"""

import codecs

from pip._vendor.pygments.util import get_bool_opt
from pip._vendor.pygments.styles import get_style_by_name

__all__ = ['Formatter']


def _lookup_style(style):
 #f isinstance(style, str):
 #eturn get_style_by_name(style)
 #eturn style


class Formatter:
 #""
 #onverts a token stream to text.

 #ormatters should have attributes to help selecting them. These
 #re similar to the corresponding :class:`~pygments.lexer.Lexer`
 #ttributes.

 #. autoattribute:: name
 #no-value:

 #. autoattribute:: aliases
 #no-value:

 #. autoattribute:: filenames
 #no-value:

 #ou can pass options as keyword arguments to the constructor.
 #ll formatters accept these basic options:

 #`style``
 #he style to use, can be a string or a Style subclass
 #default: "default"). Not used by e.g. the
 #erminalFormatter.
 #`full``
 #ells the formatter to output a "full" document, i.e.
 # complete self-contained document. This doesn't have
 #ny effect for some formatters (default: false).
 #`title``
 #f ``full`` is true, the title that should be used to
 #aption the document (default: '').
 #`encoding``
 #f given, must be an encoding name. This will be used to
 #onvert the Unicode token strings to byte strings in the
 #utput. If it is "" or None, Unicode strings will be written
 #o the output file, which most file-like objects do not
 #upport (default: None).
 #`outencoding``
 #verrides ``encoding`` if given.

 #""

    #: Full name for the formatter, in human-readable form.
 #ame = None

    #: A list of short, unique identifiers that can be used to lookup
    #: the formatter from a list, e.g. using :func:`.get_formatter_by_name()`.
 #liases = []

    #: A list of fnmatch patterns that match filenames for which this
    #: formatter can produce output. The patterns in this list should be unique
    #: among all formatters.
 #ilenames = []

    #: If True, this formatter outputs Unicode strings when no encoding
    #: option is given.
 #nicodeoutput = True

 #ef __init__(self, **options):
 #""
 #s with lexers, this constructor takes arbitrary optional arguments,
 #nd if you override it, you should first process your own options, then
 #all the base class implementation.
 #""
 #elf.style = _lookup_style(options.get('style', 'default'))
 #elf.full = get_bool_opt(options, 'full', False)
 #elf.title = options.get('title', '')
 #elf.encoding = options.get('encoding', None) or None
 #f self.encoding in ('guess', 'chardet'):
            # can happen for e.g. pygmentize -O encoding=guess
 #elf.encoding = 'utf-8'
 #elf.encoding = options.get('outencoding') or self.encoding
 #elf.options = options

 #ef get_style_defs(self, arg=''):
 #""
 #his method must return statements or declarations suitable to define
 #he current style for subsequent highlighted text (e.g. CSS classes
 #n the `HTMLFormatter`).

 #he optional argument `arg` can be used to modify the generation and
 #s formatter dependent (it is standardized because it can be given on
 #he command line).

 #his method is called by the ``-S`` :doc:`command-line option <cmdline>`,
 #he `arg` is then given by the ``-a`` option.
 #""
 #eturn ''

 #ef format(self, tokensource, outfile):
 #""
 #his method must format the tokens from the `tokensource` iterable and
 #rite the formatted version to the file object `outfile`.

 #ormatter options can control how exactly the tokens are converted.
 #""
 #f self.encoding:
            # wrap the outfile in a StreamWriter
 #utfile = codecs.lookup(self.encoding)[3](outfile)
 #eturn self.format_unencoded(tokensource, outfile)
