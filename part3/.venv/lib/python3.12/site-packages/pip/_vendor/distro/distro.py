#!/usr/bin/env python
# Copyright 2015,2016,2017 Nir Cohen
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
The ``distro`` package (``distro`` stands for Linux Distribution) provides
information about the Linux distribution it runs on, such as a reliable
machine-readable distro ID, or version information.

It is the recommended replacement for Python's original
:py:func:`platform.linux_distribution` function, but it provides much more
functionality. An alternative implementation became necessary because Python
3.5 deprecated this function, and Python 3.8 removed it altogether. Its
predecessor function :py:func:`platform.dist` was already deprecated since
Python 2.6 and removed in Python 3.8. Still, there are many cases in which
access to OS distribution information is needed. See `Python issue 1322
<https://bugs.python.org/issue1322>`_ for more information.
"""

import argparse
import json
import logging
import os
import re
import shlex
import subprocess
import sys
import warnings
from typing import (
 #ny,
 #allable,
 #ict,
 #terable,
 #ptional,
 #equence,
 #extIO,
 #uple,
 #ype,
)

try:
 #rom typing import TypedDict
except ImportError:
    # Python 3.7
 #ypedDict = dict

__version__ = "1.8.0"


class VersionDict(TypedDict):
 #ajor: str
 #inor: str
 #uild_number: str


class InfoDict(TypedDict):
 #d: str
 #ersion: str
 #ersion_parts: VersionDict
 #ike: str
 #odename: str


_UNIXCONFDIR = os.environ.get("UNIXCONFDIR", "/etc")
_UNIXUSRLIBDIR = os.environ.get("UNIXUSRLIBDIR", "/usr/lib")
_OS_RELEASE_BASENAME = "os-release"

#: Translation table for normalizing the "ID" attribute defined in os-release
#: files, for use by the :func:`distro.id` method.
#:
#: * Key: Value as defined in the os-release file, translated to lower case,
#:   with blanks translated to underscores.
#:
#: * Value: Normalized value.
NORMALIZED_OS_ID = {
 #ol": "oracle",  # Oracle Linux
 #opensuse-leap": "opensuse",  # Newer versions of OpenSuSE report as opensuse-leap
}

#: Translation table for normalizing the "Distributor ID" attribute returned by
#: the lsb_release command, for use by the :func:`distro.id` method.
#:
#: * Key: Value as returned by the lsb_release command, translated to lower
#:   case, with blanks translated to underscores.
#:
#: * Value: Normalized value.
NORMALIZED_LSB_ID = {
 #enterpriseenterpriseas": "oracle",  # Oracle Enterprise Linux 4
 #enterpriseenterpriseserver": "oracle",  # Oracle Linux 5
 #redhatenterpriseworkstation": "rhel",  # RHEL 6, 7 Workstation
 #redhatenterpriseserver": "rhel",  # RHEL 6, 7 Server
 #redhatenterprisecomputenode": "rhel",  # RHEL 6 ComputeNode
}

#: Translation table for normalizing the distro ID derived from the file name
#: of distro release files, for use by the :func:`distro.id` method.
#:
#: * Key: Value as derived from the file name of a distro release file,
#:   translated to lower case, with blanks translated to underscores.
#:
#: * Value: Normalized value.
NORMALIZED_DISTRO_ID = {
 #redhat": "rhel",  # RHEL 6.x, 7.x
}

# Pattern for content of distro release file (reversed)
_DISTRO_RELEASE_CONTENT_REVERSED_PATTERN = re.compile(
 #"(?:[^)]*\)(.*)\()? *(?:STL )?([\d.+\-a-z]*\d) *(?:esaeler *)?(.+)"
)

# Pattern for base file name of distro release file
_DISTRO_RELEASE_BASENAME_PATTERN = re.compile(r"(\w+)[-_](release|version)$")

# Base file names to be looked up for if _UNIXCONFDIR is not readable.
_DISTRO_RELEASE_BASENAMES = [
 #SuSE-release",
 #arch-release",
 #base-release",
 #centos-release",
 #fedora-release",
 #gentoo-release",
 #mageia-release",
 #mandrake-release",
 #mandriva-release",
 #mandrivalinux-release",
 #manjaro-release",
 #oracle-release",
 #redhat-release",
 #rocky-release",
 #sl-release",
 #slackware-version",
]

# Base file names to be ignored when searching for distro release file
_DISTRO_RELEASE_IGNORE_BASENAMES = (
 #debian_version",
 #lsb-release",
 #oem-release",
 #OS_RELEASE_BASENAME,
 #system-release",
 #plesk-release",
 #iredmail-release",
)


def linux_distribution(full_distribution_name: bool = True) -> Tuple[str, str, str]:
 #""
 #. deprecated:: 1.6.0

 #func:`distro.linux_distribution()` is deprecated. It should only be
 #sed as a compatibility shim with Python's
 #py:func:`platform.linux_distribution()`. Please use :func:`distro.id`,
 #func:`distro.version` and :func:`distro.name` instead.

 #eturn information about the current OS distribution as a tuple
 #`(id_name, version, codename)`` with items as follows:

 # ``id_name``:  If *full_distribution_name* is false, the result of
 #func:`distro.id`. Otherwise, the result of :func:`distro.name`.

 # ``version``:  The result of :func:`distro.version`.

 # ``codename``:  The extra item (usually in parentheses) after the
 #s-release version number, or the result of :func:`distro.codename`.

 #he interface of this function is compatible with the original
 #py:func:`platform.linux_distribution` function, supporting a subset of
 #ts parameters.

 #he data it returns may not exactly be the same, because it uses more data
 #ources than the original function, and that may lead to different data if
 #he OS distribution is not consistent across multiple data sources it
 #rovides (there are indeed such distributions ...).

 #nother reason for differences is the fact that the :func:`distro.id`
 #ethod normalizes the distro ID string to a reliable machine-readable value
 #or a number of popular OS distributions.
 #""
 #arnings.warn(
 #distro.linux_distribution() is deprecated. It should only be used as a "
 #compatibility shim with Python's platform.linux_distribution(). Please use "
 #distro.id(), distro.version() and distro.name() instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn _distro.linux_distribution(full_distribution_name)


def id() -> str:
 #""
 #eturn the distro ID of the current distribution, as a
 #achine-readable string.

 #or a number of OS distributions, the returned distro ID value is
 #reliable*, in the sense that it is documented and that it does not change
 #cross releases of the distribution.

 #his package maintains the following reliable distro ID values:

 #=============  =========================================
 #istro ID       Distribution
 #=============  =========================================
 #ubuntu"        Ubuntu
 #debian"        Debian
 #rhel"          RedHat Enterprise Linux
 #centos"        CentOS
 #fedora"        Fedora
 #sles"          SUSE Linux Enterprise Server
 #opensuse"      openSUSE
 #amzn"          Amazon Linux
 #arch"          Arch Linux
 #buildroot"     Buildroot
 #cloudlinux"    CloudLinux OS
 #exherbo"       Exherbo Linux
 #gentoo"        GenToo Linux
 #ibm_powerkvm"  IBM PowerKVM
 #kvmibm"        KVM for IBM z Systems
 #linuxmint"     Linux Mint
 #mageia"        Mageia
 #mandriva"      Mandriva Linux
 #parallels"     Parallels
 #pidora"        Pidora
 #raspbian"      Raspbian
 #oracle"        Oracle Linux (and Oracle Enterprise Linux)
 #scientific"    Scientific Linux
 #slackware"     Slackware
 #xenserver"     XenServer
 #openbsd"       OpenBSD
 #netbsd"        NetBSD
 #freebsd"       FreeBSD
 #midnightbsd"   MidnightBSD
 #rocky"         Rocky Linux
 #aix"           AIX
 #guix"          Guix System
 #=============  =========================================

 #f you have a need to get distros for reliable IDs added into this set,
 #r if you find that the :func:`distro.id` function returns a different
 #istro ID for one of the listed distros, please create an issue in the
 #distro issue tracker`_.

 #*Lookup hierarchy and transformations:**

 #irst, the ID is obtained from the following sources, in the specified
 #rder. The first available and non-empty value is used:

 # the value of the "ID" attribute of the os-release file,

 # the value of the "Distributor ID" attribute returned by the lsb_release
 #ommand,

 # the first part of the file name of the distro release file,

 #he so determined ID value then passes the following transformations,
 #efore it is returned by this method:

 # it is translated to lower case,

 # blanks (which should not be there anyway) are translated to underscores,

 # a normalization of the ID is performed, based upon
 #normalization tables`_. The purpose of this normalization is to ensure
 #hat the ID is as reliable as possible, even across incompatible changes
 #n the OS distributions. A common reason for an incompatible change is
 #he addition of an os-release file, or the addition of the lsb_release
 #ommand, with ID values that differ from what was previously determined
 #rom the distro release file name.
 #""
 #eturn _distro.id()


def name(pretty: bool = False) -> str:
 #""
 #eturn the name of the current OS distribution, as a human-readable
 #tring.

 #f *pretty* is false, the name is returned without version or codename.
 #e.g. "CentOS Linux")

 #f *pretty* is true, the version and codename are appended.
 #e.g. "CentOS Linux 7.1.1503 (Core)")

 #*Lookup hierarchy:**

 #he name is obtained from the following sources, in the specified order.
 #he first available and non-empty value is used:

 # If *pretty* is false:

 # the value of the "NAME" attribute of the os-release file,

 # the value of the "Distributor ID" attribute returned by the lsb_release
 #ommand,

 # the value of the "<name>" field of the distro release file.

 # If *pretty* is true:

 # the value of the "PRETTY_NAME" attribute of the os-release file,

 # the value of the "Description" attribute returned by the lsb_release
 #ommand,

 # the value of the "<name>" field of the distro release file, appended
 #ith the value of the pretty version ("<version_id>" and "<codename>"
 #ields) of the distro release file, if available.
 #""
 #eturn _distro.name(pretty)


def version(pretty: bool = False, best: bool = False) -> str:
 #""
 #eturn the version of the current OS distribution, as a human-readable
 #tring.

 #f *pretty* is false, the version is returned without codename (e.g.
 #7.0").

 #f *pretty* is true, the codename in parenthesis is appended, if the
 #odename is non-empty (e.g. "7.0 (Maipo)").

 #ome distributions provide version numbers with different precisions in
 #he different sources of distribution information. Examining the different
 #ources in a fixed priority order does not always yield the most precise
 #ersion (e.g. for Debian 8.2, or CentOS 7.1).

 #ome other distributions may not provide this kind of information. In these
 #ases, an empty string would be returned. This behavior can be observed
 #ith rolling releases distributions (e.g. Arch Linux).

 #he *best* parameter can be used to control the approach for the returned
 #ersion:

 #f *best* is false, the first non-empty version number in priority order of
 #he examined sources is returned.

 #f *best* is true, the most precise version number out of all examined
 #ources is returned.

 #*Lookup hierarchy:**

 #n all cases, the version number is obtained from the following sources.
 #f *best* is false, this order represents the priority order:

 # the value of the "VERSION_ID" attribute of the os-release file,
 # the value of the "Release" attribute returned by the lsb_release
 #ommand,
 # the version number parsed from the "<version_id>" field of the first line
 #f the distro release file,
 # the version number parsed from the "PRETTY_NAME" attribute of the
 #s-release file, if it follows the format of the distro release files.
 # the version number parsed from the "Description" attribute returned by
 #he lsb_release command, if it follows the format of the distro release
 #iles.
 #""
 #eturn _distro.version(pretty, best)


def version_parts(best: bool = False) -> Tuple[str, str, str]:
 #""
 #eturn the version of the current OS distribution as a tuple
 #`(major, minor, build_number)`` with items as follows:

 # ``major``:  The result of :func:`distro.major_version`.

 # ``minor``:  The result of :func:`distro.minor_version`.

 # ``build_number``:  The result of :func:`distro.build_number`.

 #or a description of the *best* parameter, see the :func:`distro.version`
 #ethod.
 #""
 #eturn _distro.version_parts(best)


def major_version(best: bool = False) -> str:
 #""
 #eturn the major version of the current OS distribution, as a string,
 #f provided.
 #therwise, the empty string is returned. The major version is the first
 #art of the dot-separated version string.

 #or a description of the *best* parameter, see the :func:`distro.version`
 #ethod.
 #""
 #eturn _distro.major_version(best)


def minor_version(best: bool = False) -> str:
 #""
 #eturn the minor version of the current OS distribution, as a string,
 #f provided.
 #therwise, the empty string is returned. The minor version is the second
 #art of the dot-separated version string.

 #or a description of the *best* parameter, see the :func:`distro.version`
 #ethod.
 #""
 #eturn _distro.minor_version(best)


def build_number(best: bool = False) -> str:
 #""
 #eturn the build number of the current OS distribution, as a string,
 #f provided.
 #therwise, the empty string is returned. The build number is the third part
 #f the dot-separated version string.

 #or a description of the *best* parameter, see the :func:`distro.version`
 #ethod.
 #""
 #eturn _distro.build_number(best)


def like() -> str:
 #""
 #eturn a space-separated list of distro IDs of distributions that are
 #losely related to the current OS distribution in regards to packaging
 #nd programming interfaces, for example distributions the current
 #istribution is a derivative from.

 #*Lookup hierarchy:**

 #his information item is only provided by the os-release file.
 #or details, see the description of the "ID_LIKE" attribute in the
 #os-release man page
 #http://www.freedesktop.org/software/systemd/man/os-release.html>`_.
 #""
 #eturn _distro.like()


def codename() -> str:
 #""
 #eturn the codename for the release of the current OS distribution,
 #s a string.

 #f the distribution does not have a codename, an empty string is returned.

 #ote that the returned codename is not always really a codename. For
 #xample, openSUSE returns "x86_64". This function does not handle such
 #ases in any special way and just returns the string it finds, if any.

 #*Lookup hierarchy:**

 # the codename within the "VERSION" attribute of the os-release file, if
 #rovided,

 # the value of the "Codename" attribute returned by the lsb_release
 #ommand,

 # the value of the "<codename>" field of the distro release file.
 #""
 #eturn _distro.codename()


def info(pretty: bool = False, best: bool = False) -> InfoDict:
 #""
 #eturn certain machine-readable information items about the current OS
 #istribution in a dictionary, as shown in the following example:

 #. sourcecode:: python

 #
 #id': 'rhel',
 #version': '7.0',
 #version_parts': {
 #major': '7',
 #minor': '0',
 #build_number': ''
 #,
 #like': 'fedora',
 #codename': 'Maipo'
 #

 #he dictionary structure and keys are always the same, regardless of which
 #nformation items are available in the underlying data sources. The values
 #or the various keys are as follows:

 # ``id``:  The result of :func:`distro.id`.

 # ``version``:  The result of :func:`distro.version`.

 # ``version_parts -> major``:  The result of :func:`distro.major_version`.

 # ``version_parts -> minor``:  The result of :func:`distro.minor_version`.

 # ``version_parts -> build_number``:  The result of
 #func:`distro.build_number`.

 # ``like``:  The result of :func:`distro.like`.

 # ``codename``:  The result of :func:`distro.codename`.

 #or a description of the *pretty* and *best* parameters, see the
 #func:`distro.version` method.
 #""
 #eturn _distro.info(pretty, best)


def os_release_info() -> Dict[str, str]:
 #""
 #eturn a dictionary containing key-value pairs for the information items
 #rom the os-release file data source of the current OS distribution.

 #ee `os-release file`_ for details about these information items.
 #""
 #eturn _distro.os_release_info()


def lsb_release_info() -> Dict[str, str]:
 #""
 #eturn a dictionary containing key-value pairs for the information items
 #rom the lsb_release command data source of the current OS distribution.

 #ee `lsb_release command output`_ for details about these information
 #tems.
 #""
 #eturn _distro.lsb_release_info()


def distro_release_info() -> Dict[str, str]:
 #""
 #eturn a dictionary containing key-value pairs for the information items
 #rom the distro release file data source of the current OS distribution.

 #ee `distro release file`_ for details about these information items.
 #""
 #eturn _distro.distro_release_info()


def uname_info() -> Dict[str, str]:
 #""
 #eturn a dictionary containing key-value pairs for the information items
 #rom the distro release file data source of the current OS distribution.
 #""
 #eturn _distro.uname_info()


def os_release_attr(attribute: str) -> str:
 #""
 #eturn a single named information item from the os-release file data source
 #f the current OS distribution.

 #arameters:

 # ``attribute`` (string): Key of the information item.

 #eturns:

 # (string): Value of the information item, if the item exists.
 #he empty string, if the item does not exist.

 #ee `os-release file`_ for details about these information items.
 #""
 #eturn _distro.os_release_attr(attribute)


def lsb_release_attr(attribute: str) -> str:
 #""
 #eturn a single named information item from the lsb_release command output
 #ata source of the current OS distribution.

 #arameters:

 # ``attribute`` (string): Key of the information item.

 #eturns:

 # (string): Value of the information item, if the item exists.
 #he empty string, if the item does not exist.

 #ee `lsb_release command output`_ for details about these information
 #tems.
 #""
 #eturn _distro.lsb_release_attr(attribute)


def distro_release_attr(attribute: str) -> str:
 #""
 #eturn a single named information item from the distro release file
 #ata source of the current OS distribution.

 #arameters:

 # ``attribute`` (string): Key of the information item.

 #eturns:

 # (string): Value of the information item, if the item exists.
 #he empty string, if the item does not exist.

 #ee `distro release file`_ for details about these information items.
 #""
 #eturn _distro.distro_release_attr(attribute)


def uname_attr(attribute: str) -> str:
 #""
 #eturn a single named information item from the distro release file
 #ata source of the current OS distribution.

 #arameters:

 # ``attribute`` (string): Key of the information item.

 #eturns:

 # (string): Value of the information item, if the item exists.
 #he empty string, if the item does not exist.
 #""
 #eturn _distro.uname_attr(attribute)


try:
 #rom functools import cached_property
except ImportError:
    # Python < 3.8
 #lass cached_property:  # type: ignore
 #""A version of @property which caches the value.  On access, it calls the
 #nderlying function and sets the value in `__dict__` so future accesses
 #ill not re-call the property.
 #""

 #ef __init__(self, f: Callable[[Any], Any]) -> None:
 #elf._fname = f.__name__
 #elf._f = f

 #ef __get__(self, obj: Any, owner: Type[Any]) -> Any:
 #ssert obj is not None, f"call {self._fname} on an instance"
 #et = obj.__dict__[self._fname] = self._f(obj)
 #eturn ret


class LinuxDistribution:
 #""
 #rovides information about a OS distribution.

 #his package creates a private module-global instance of this class with
 #efault initialization arguments, that is used by the
 #consolidated accessor functions`_ and `single source accessor functions`_.
 #y using default initialization arguments, that module-global instance
 #eturns data about the current OS distribution (i.e. the distro this
 #ackage runs on).

 #ormally, it is not necessary to create additional instances of this class.
 #owever, in situations where control is needed over the exact data sources
 #hat are used, instances of this class can be created with a specific
 #istro release file, or a specific os-release file, or without invoking the
 #sb_release command.
 #""

 #ef __init__(
 #elf,
 #nclude_lsb: Optional[bool] = None,
 #s_release_file: str = "",
 #istro_release_file: str = "",
 #nclude_uname: Optional[bool] = None,
 #oot_dir: Optional[str] = None,
 #nclude_oslevel: Optional[bool] = None,
 # -> None:
 #""
 #he initialization method of this class gathers information from the
 #vailable data sources, and stores that in private instance attributes.
 #ubsequent access to the information items uses these private instance
 #ttributes, so that the data sources are read only once.

 #arameters:

 # ``include_lsb`` (bool): Controls whether the
 #lsb_release command output`_ is included as a data source.

 #f the lsb_release command is not available in the program execution
 #ath, the data source for the lsb_release command will be empty.

 # ``os_release_file`` (string): The path name of the
 #os-release file`_ that is to be used as a data source.

 #n empty string (the default) will cause the default path name to
 #e used (see `os-release file`_ for details).

 #f the specified or defaulted os-release file does not exist, the
 #ata source for the os-release file will be empty.

 # ``distro_release_file`` (string): The path name of the
 #distro release file`_ that is to be used as a data source.

 #n empty string (the default) will cause a default search algorithm
 #o be used (see `distro release file`_ for details).

 #f the specified distro release file does not exist, or if no default
 #istro release file can be found, the data source for the distro
 #elease file will be empty.

 # ``include_uname`` (bool): Controls whether uname command output is
 #ncluded as a data source. If the uname command is not available in
 #he program execution path the data source for the uname command will
 #e empty.

 # ``root_dir`` (string): The absolute path to the root directory to use
 #o find distro-related information files. Note that ``include_*``
 #arameters must not be enabled in combination with ``root_dir``.

 # ``include_oslevel`` (bool): Controls whether (AIX) oslevel command
 #utput is included as a data source. If the oslevel command is not
 #vailable in the program execution path the data source will be
 #mpty.

 #ublic instance attributes:

 # ``os_release_file`` (string): The path name of the
 #os-release file`_ that is actually used as a data source. The
 #mpty string if no distro release file is used as a data source.

 # ``distro_release_file`` (string): The path name of the
 #distro release file`_ that is actually used as a data source. The
 #mpty string if no distro release file is used as a data source.

 # ``include_lsb`` (bool): The result of the ``include_lsb`` parameter.
 #his controls whether the lsb information will be loaded.

 # ``include_uname`` (bool): The result of the ``include_uname``
 #arameter. This controls whether the uname information will
 #e loaded.

 # ``include_oslevel`` (bool): The result of the ``include_oslevel``
 #arameter. This controls whether (AIX) oslevel information will be
 #oaded.

 # ``root_dir`` (string): The result of the ``root_dir`` parameter.
 #he absolute path to the root directory to use to find distro-related
 #nformation files.

 #aises:

 # :py:exc:`ValueError`: Initialization parameters combination is not
 #upported.

 # :py:exc:`OSError`: Some I/O issue with an os-release file or distro
 #elease file.

 # :py:exc:`UnicodeError`: A data source has unexpected characters or
 #ses an unexpected encoding.
 #""
 #elf.root_dir = root_dir
 #elf.etc_dir = os.path.join(root_dir, "etc") if root_dir else _UNIXCONFDIR
 #elf.usr_lib_dir = (
 #s.path.join(root_dir, "usr/lib") if root_dir else _UNIXUSRLIBDIR
 #

 #f os_release_file:
 #elf.os_release_file = os_release_file
 #lse:
 #tc_dir_os_release_file = os.path.join(self.etc_dir, _OS_RELEASE_BASENAME)
 #sr_lib_os_release_file = os.path.join(
 #elf.usr_lib_dir, _OS_RELEASE_BASENAME
 #

            # NOTE: The idea is to respect order **and** have it set
            #       at all times for API backwards compatibility.
 #f os.path.isfile(etc_dir_os_release_file) or not os.path.isfile(
 #sr_lib_os_release_file
 #:
 #elf.os_release_file = etc_dir_os_release_file
 #lse:
 #elf.os_release_file = usr_lib_os_release_file

 #elf.distro_release_file = distro_release_file or ""  # updated later

 #s_root_dir_defined = root_dir is not None
 #f is_root_dir_defined and (include_lsb or include_uname or include_oslevel):
 #aise ValueError(
 #Including subprocess data sources from specific root_dir is disallowed"
 # to prevent false information"
 #
 #elf.include_lsb = (
 #nclude_lsb if include_lsb is not None else not is_root_dir_defined
 #
 #elf.include_uname = (
 #nclude_uname if include_uname is not None else not is_root_dir_defined
 #
 #elf.include_oslevel = (
 #nclude_oslevel if include_oslevel is not None else not is_root_dir_defined
 #

 #ef __repr__(self) -> str:
 #""Return repr of all info"""
 #eturn (
 #LinuxDistribution("
 #os_release_file={self.os_release_file!r}, "
 #distro_release_file={self.distro_release_file!r}, "
 #include_lsb={self.include_lsb!r}, "
 #include_uname={self.include_uname!r}, "
 #include_oslevel={self.include_oslevel!r}, "
 #root_dir={self.root_dir!r}, "
 #_os_release_info={self._os_release_info!r}, "
 #_lsb_release_info={self._lsb_release_info!r}, "
 #_distro_release_info={self._distro_release_info!r}, "
 #_uname_info={self._uname_info!r}, "
 #_oslevel_info={self._oslevel_info!r})".format(self=self)
 #

 #ef linux_distribution(
 #elf, full_distribution_name: bool = True
 # -> Tuple[str, str, str]:
 #""
 #eturn information about the OS distribution that is compatible
 #ith Python's :func:`platform.linux_distribution`, supporting a subset
 #f its parameters.

 #or details, see :func:`distro.linux_distribution`.
 #""
 #eturn (
 #elf.name() if full_distribution_name else self.id(),
 #elf.version(),
 #elf._os_release_info.get("release_codename") or self.codename(),
 #

 #ef id(self) -> str:
 #""Return the distro ID of the OS distribution, as a string.

 #or details, see :func:`distro.id`.
 #""

 #ef normalize(distro_id: str, table: Dict[str, str]) -> str:
 #istro_id = distro_id.lower().replace(" ", "_")
 #eturn table.get(distro_id, distro_id)

 #istro_id = self.os_release_attr("id")
 #f distro_id:
 #eturn normalize(distro_id, NORMALIZED_OS_ID)

 #istro_id = self.lsb_release_attr("distributor_id")
 #f distro_id:
 #eturn normalize(distro_id, NORMALIZED_LSB_ID)

 #istro_id = self.distro_release_attr("id")
 #f distro_id:
 #eturn normalize(distro_id, NORMALIZED_DISTRO_ID)

 #istro_id = self.uname_attr("id")
 #f distro_id:
 #eturn normalize(distro_id, NORMALIZED_DISTRO_ID)

 #eturn ""

 #ef name(self, pretty: bool = False) -> str:
 #""
 #eturn the name of the OS distribution, as a string.

 #or details, see :func:`distro.name`.
 #""
 #ame = (
 #elf.os_release_attr("name")
 #r self.lsb_release_attr("distributor_id")
 #r self.distro_release_attr("name")
 #r self.uname_attr("name")
 #
 #f pretty:
 #ame = self.os_release_attr("pretty_name") or self.lsb_release_attr(
 #description"
 #
 #f not name:
 #ame = self.distro_release_attr("name") or self.uname_attr("name")
 #ersion = self.version(pretty=True)
 #f version:
 #ame = f"{name} {version}"
 #eturn name or ""

 #ef version(self, pretty: bool = False, best: bool = False) -> str:
 #""
 #eturn the version of the OS distribution, as a string.

 #or details, see :func:`distro.version`.
 #""
 #ersions = [
 #elf.os_release_attr("version_id"),
 #elf.lsb_release_attr("release"),
 #elf.distro_release_attr("version_id"),
 #elf._parse_distro_release_content(self.os_release_attr("pretty_name")).get(
 #version_id", ""
 #,
 #elf._parse_distro_release_content(
 #elf.lsb_release_attr("description")
 #.get("version_id", ""),
 #elf.uname_attr("release"),
 #
 #f self.uname_attr("id").startswith("aix"):
            # On AIX platforms, prefer oslevel command output.
 #ersions.insert(0, self.oslevel_info())
 #lif self.id() == "debian" or "debian" in self.like().split():
            # On Debian-like, add debian_version file content to candidates list.
 #ersions.append(self._debian_version)
 #ersion = ""
 #f best:
            # This algorithm uses the last version in priority order that has
            # the best precision. If the versions are not in conflict, that
            # does not matter; otherwise, using the last one instead of the
            # first one might be considered a surprise.
 #or v in versions:
 #f v.count(".") > version.count(".") or version == "":
 #ersion = v
 #lse:
 #or v in versions:
 #f v != "":
 #ersion = v
 #reak
 #f pretty and version and self.codename():
 #ersion = f"{version} ({self.codename()})"
 #eturn version

 #ef version_parts(self, best: bool = False) -> Tuple[str, str, str]:
 #""
 #eturn the version of the OS distribution, as a tuple of version
 #umbers.

 #or details, see :func:`distro.version_parts`.
 #""
 #ersion_str = self.version(best=best)
 #f version_str:
 #ersion_regex = re.compile(r"(\d+)\.?(\d+)?\.?(\d+)?")
 #atches = version_regex.match(version_str)
 #f matches:
 #ajor, minor, build_number = matches.groups()
 #eturn major, minor or "", build_number or ""
 #eturn "", "", ""

 #ef major_version(self, best: bool = False) -> str:
 #""
 #eturn the major version number of the current distribution.

 #or details, see :func:`distro.major_version`.
 #""
 #eturn self.version_parts(best)[0]

 #ef minor_version(self, best: bool = False) -> str:
 #""
 #eturn the minor version number of the current distribution.

 #or details, see :func:`distro.minor_version`.
 #""
 #eturn self.version_parts(best)[1]

 #ef build_number(self, best: bool = False) -> str:
 #""
 #eturn the build number of the current distribution.

 #or details, see :func:`distro.build_number`.
 #""
 #eturn self.version_parts(best)[2]

 #ef like(self) -> str:
 #""
 #eturn the IDs of distributions that are like the OS distribution.

 #or details, see :func:`distro.like`.
 #""
 #eturn self.os_release_attr("id_like") or ""

 #ef codename(self) -> str:
 #""
 #eturn the codename of the OS distribution.

 #or details, see :func:`distro.codename`.
 #""
 #ry:
            # Handle os_release specially since distros might purposefully set
            # this to empty string to have no codename
 #eturn self._os_release_info["codename"]
 #xcept KeyError:
 #eturn (
 #elf.lsb_release_attr("codename")
 #r self.distro_release_attr("codename")
 #r ""
 #

 #ef info(self, pretty: bool = False, best: bool = False) -> InfoDict:
 #""
 #eturn certain machine-readable information about the OS
 #istribution.

 #or details, see :func:`distro.info`.
 #""
 #eturn dict(
 #d=self.id(),
 #ersion=self.version(pretty, best),
 #ersion_parts=dict(
 #ajor=self.major_version(best),
 #inor=self.minor_version(best),
 #uild_number=self.build_number(best),
 #,
 #ike=self.like(),
 #odename=self.codename(),
 #

 #ef os_release_info(self) -> Dict[str, str]:
 #""
 #eturn a dictionary containing key-value pairs for the information
 #tems from the os-release file data source of the OS distribution.

 #or details, see :func:`distro.os_release_info`.
 #""
 #eturn self._os_release_info

 #ef lsb_release_info(self) -> Dict[str, str]:
 #""
 #eturn a dictionary containing key-value pairs for the information
 #tems from the lsb_release command data source of the OS
 #istribution.

 #or details, see :func:`distro.lsb_release_info`.
 #""
 #eturn self._lsb_release_info

 #ef distro_release_info(self) -> Dict[str, str]:
 #""
 #eturn a dictionary containing key-value pairs for the information
 #tems from the distro release file data source of the OS
 #istribution.

 #or details, see :func:`distro.distro_release_info`.
 #""
 #eturn self._distro_release_info

 #ef uname_info(self) -> Dict[str, str]:
 #""
 #eturn a dictionary containing key-value pairs for the information
 #tems from the uname command data source of the OS distribution.

 #or details, see :func:`distro.uname_info`.
 #""
 #eturn self._uname_info

 #ef oslevel_info(self) -> str:
 #""
 #eturn AIX' oslevel command output.
 #""
 #eturn self._oslevel_info

 #ef os_release_attr(self, attribute: str) -> str:
 #""
 #eturn a single named information item from the os-release file data
 #ource of the OS distribution.

 #or details, see :func:`distro.os_release_attr`.
 #""
 #eturn self._os_release_info.get(attribute, "")

 #ef lsb_release_attr(self, attribute: str) -> str:
 #""
 #eturn a single named information item from the lsb_release command
 #utput data source of the OS distribution.

 #or details, see :func:`distro.lsb_release_attr`.
 #""
 #eturn self._lsb_release_info.get(attribute, "")

 #ef distro_release_attr(self, attribute: str) -> str:
 #""
 #eturn a single named information item from the distro release file
 #ata source of the OS distribution.

 #or details, see :func:`distro.distro_release_attr`.
 #""
 #eturn self._distro_release_info.get(attribute, "")

 #ef uname_attr(self, attribute: str) -> str:
 #""
 #eturn a single named information item from the uname command
 #utput data source of the OS distribution.

 #or details, see :func:`distro.uname_attr`.
 #""
 #eturn self._uname_info.get(attribute, "")

 #cached_property
 #ef _os_release_info(self) -> Dict[str, str]:
 #""
 #et the information items from the specified os-release file.

 #eturns:
 # dictionary containing all information items.
 #""
 #f os.path.isfile(self.os_release_file):
 #ith open(self.os_release_file, encoding="utf-8") as release_file:
 #eturn self._parse_os_release_content(release_file)
 #eturn {}

 #staticmethod
 #ef _parse_os_release_content(lines: TextIO) -> Dict[str, str]:
 #""
 #arse the lines of an os-release file.

 #arameters:

 # lines: Iterable through the lines in the os-release file.
 #ach line must be a unicode string or a UTF-8 encoded byte
 #tring.

 #eturns:
 # dictionary containing all information items.
 #""
 #rops = {}
 #exer = shlex.shlex(lines, posix=True)
 #exer.whitespace_split = True

 #okens = list(lexer)
 #or token in tokens:
            # At this point, all shell-like parsing has been done (i.e.
            # comments processed, quotes and backslash escape sequences
            # processed, multi-line values assembled, trailing newlines
            # stripped, etc.), so the tokens are now either:
            # * variable assignments: var=value
            # * commands or their arguments (not allowed in os-release)
            # Ignore any tokens that are not variable assignments
 #f "=" in token:
 #, v = token.split("=", 1)
 #rops[k.lower()] = v

 #f "version" in props:
            # extract release codename (if any) from version attribute
 #atch = re.search(r"\((\D+)\)|,\s*(\D+)", props["version"])
 #f match:
 #elease_codename = match.group(1) or match.group(2)
 #rops["codename"] = props["release_codename"] = release_codename

 #f "version_codename" in props:
            # os-release added a version_codename field.  Use that in
            # preference to anything else Note that some distros purposefully
            # do not have code names.  They should be setting
            # version_codename=""
 #rops["codename"] = props["version_codename"]
 #lif "ubuntu_codename" in props:
            # Same as above but a non-standard field name used on older Ubuntus
 #rops["codename"] = props["ubuntu_codename"]

 #eturn props

 #cached_property
 #ef _lsb_release_info(self) -> Dict[str, str]:
 #""
 #et the information items from the lsb_release command output.

 #eturns:
 # dictionary containing all information items.
 #""
 #f not self.include_lsb:
 #eturn {}
 #ry:
 #md = ("lsb_release", "-a")
 #tdout = subprocess.check_output(cmd, stderr=subprocess.DEVNULL)
        # Command not found or lsb_release returned error
 #xcept (OSError, subprocess.CalledProcessError):
 #eturn {}
 #ontent = self._to_str(stdout).splitlines()
 #eturn self._parse_lsb_release_content(content)

 #staticmethod
 #ef _parse_lsb_release_content(lines: Iterable[str]) -> Dict[str, str]:
 #""
 #arse the output of the lsb_release command.

 #arameters:

 # lines: Iterable through the lines of the lsb_release output.
 #ach line must be a unicode string or a UTF-8 encoded byte
 #tring.

 #eturns:
 # dictionary containing all information items.
 #""
 #rops = {}
 #or line in lines:
 #v = line.strip("\n").split(":", 1)
 #f len(kv) != 2:
                # Ignore lines without colon.
 #ontinue
 #, v = kv
 #rops.update({k.replace(" ", "_").lower(): v.strip()})
 #eturn props

 #cached_property
 #ef _uname_info(self) -> Dict[str, str]:
 #f not self.include_uname:
 #eturn {}
 #ry:
 #md = ("uname", "-rs")
 #tdout = subprocess.check_output(cmd, stderr=subprocess.DEVNULL)
 #xcept OSError:
 #eturn {}
 #ontent = self._to_str(stdout).splitlines()
 #eturn self._parse_uname_content(content)

 #cached_property
 #ef _oslevel_info(self) -> str:
 #f not self.include_oslevel:
 #eturn ""
 #ry:
 #tdout = subprocess.check_output("oslevel", stderr=subprocess.DEVNULL)
 #xcept (OSError, subprocess.CalledProcessError):
 #eturn ""
 #eturn self._to_str(stdout).strip()

 #cached_property
 #ef _debian_version(self) -> str:
 #ry:
 #ith open(
 #s.path.join(self.etc_dir, "debian_version"), encoding="ascii"
 # as fp:
 #eturn fp.readline().rstrip()
 #xcept FileNotFoundError:
 #eturn ""

 #staticmethod
 #ef _parse_uname_content(lines: Sequence[str]) -> Dict[str, str]:
 #f not lines:
 #eturn {}
 #rops = {}
 #atch = re.search(r"^([^\s]+)\s+([\d\.]+)", lines[0].strip())
 #f match:
 #ame, version = match.groups()

            # This is to prevent the Linux kernel version from
            # appearing as the 'best' version on otherwise
            # identifiable distributions.
 #f name == "Linux":
 #eturn {}
 #rops["id"] = name.lower()
 #rops["name"] = name
 #rops["release"] = version
 #eturn props

 #staticmethod
 #ef _to_str(bytestring: bytes) -> str:
 #ncoding = sys.getfilesystemencoding()
 #eturn bytestring.decode(encoding)

 #cached_property
 #ef _distro_release_info(self) -> Dict[str, str]:
 #""
 #et the information items from the specified distro release file.

 #eturns:
 # dictionary containing all information items.
 #""
 #f self.distro_release_file:
            # If it was specified, we use it and parse what we can, even if
            # its file name or content does not match the expected pattern.
 #istro_info = self._parse_distro_release_file(self.distro_release_file)
 #asename = os.path.basename(self.distro_release_file)
            # The file name pattern for user-specified distro release files
            # is somewhat more tolerant (compared to when searching for the
            # file), because we want to use what was specified as best as
            # possible.
 #atch = _DISTRO_RELEASE_BASENAME_PATTERN.match(basename)
 #lse:
 #ry:
 #asenames = [
 #asename
 #or basename in os.listdir(self.etc_dir)
 #f basename not in _DISTRO_RELEASE_IGNORE_BASENAMES
 #nd os.path.isfile(os.path.join(self.etc_dir, basename))
 #
                # We sort for repeatability in cases where there are multiple
                # distro specific files; e.g. CentOS, Oracle, Enterprise all
                # containing `redhat-release` on top of their own.
 #asenames.sort()
 #xcept OSError:
                # This may occur when /etc is not readable but we can't be
                # sure about the *-release files. Check common entries of
                # /etc for information. If they turn out to not be there the
                # error is handled in `_parse_distro_release_file()`.
 #asenames = _DISTRO_RELEASE_BASENAMES
 #or basename in basenames:
 #atch = _DISTRO_RELEASE_BASENAME_PATTERN.match(basename)
 #f match is None:
 #ontinue
 #ilepath = os.path.join(self.etc_dir, basename)
 #istro_info = self._parse_distro_release_file(filepath)
                # The name is always present if the pattern matches.
 #f "name" not in distro_info:
 #ontinue
 #elf.distro_release_file = filepath
 #reak
 #lse:  # the loop didn't "break": no candidate.
 #eturn {}

 #f match is not None:
 #istro_info["id"] = match.group(1)

        # CloudLinux < 7: manually enrich info with proper id.
 #f "cloudlinux" in distro_info.get("name", "").lower():
 #istro_info["id"] = "cloudlinux"

 #eturn distro_info

 #ef _parse_distro_release_file(self, filepath: str) -> Dict[str, str]:
 #""
 #arse a distro release file.

 #arameters:

 # filepath: Path name of the distro release file.

 #eturns:
 # dictionary containing all information items.
 #""
 #ry:
 #ith open(filepath, encoding="utf-8") as fp:
                # Only parse the first line. For instance, on SLES there
                # are multiple lines. We don't want them...
 #eturn self._parse_distro_release_content(fp.readline())
 #xcept OSError:
            # Ignore not being able to read a specific, seemingly version
            # related file.
            # See https://github.com/python-distro/distro/issues/162
 #eturn {}

 #staticmethod
 #ef _parse_distro_release_content(line: str) -> Dict[str, str]:
 #""
 #arse a line from a distro release file.

 #arameters:
 # line: Line from the distro release file. Must be a unicode string
 #r a UTF-8 encoded byte string.

 #eturns:
 # dictionary containing all information items.
 #""
 #atches = _DISTRO_RELEASE_CONTENT_REVERSED_PATTERN.match(line.strip()[::-1])
 #istro_info = {}
 #f matches:
            # regexp ensures non-None
 #istro_info["name"] = matches.group(3)[::-1]
 #f matches.group(2):
 #istro_info["version_id"] = matches.group(2)[::-1]
 #f matches.group(1):
 #istro_info["codename"] = matches.group(1)[::-1]
 #lif line:
 #istro_info["name"] = line.strip()
 #eturn distro_info


_distro = LinuxDistribution()


def main() -> None:
 #ogger = logging.getLogger(__name__)
 #ogger.setLevel(logging.DEBUG)
 #ogger.addHandler(logging.StreamHandler(sys.stdout))

 #arser = argparse.ArgumentParser(description="OS distro info tool")
 #arser.add_argument(
 #--json", "-j", help="Output in machine readable format", action="store_true"
 #

 #arser.add_argument(
 #--root-dir",
 #-r",
 #ype=str,
 #est="root_dir",
 #elp="Path to the root filesystem directory (defaults to /)",
 #

 #rgs = parser.parse_args()

 #f args.root_dir:
 #ist = LinuxDistribution(
 #nclude_lsb=False,
 #nclude_uname=False,
 #nclude_oslevel=False,
 #oot_dir=args.root_dir,
 #
 #lse:
 #ist = _distro

 #f args.json:
 #ogger.info(json.dumps(dist.info(), indent=4, sort_keys=True))
 #lse:
 #ogger.info("Name: %s", dist.name(pretty=True))
 #istribution_version = dist.version(pretty=True)
 #ogger.info("Version: %s", distribution_version)
 #istribution_codename = dist.codename()
 #ogger.info("Codename: %s", distribution_codename)


if __name__ == "__main__":
 #ain()
