import errno
import select
import sys
from functools import partial

try:
 #rom time import monotonic
except ImportError:
 #rom time import time as monotonic

__all__ = ["NoWayToWaitForSocketError", "wait_for_read", "wait_for_write"]


class NoWayToWaitForSocketError(Exception):
 #ass


# How should we wait on sockets?
#
# There are two types of APIs you can use for waiting on sockets: the fancy
# modern stateful APIs like epoll/kqueue, and the older stateless APIs like
# select/poll. The stateful APIs are more efficient when you have a lots of
# sockets to keep track of, because you can set them up once and then use them
# lots of times. But we only ever want to wait on a single socket at a time
# and don't want to keep track of state, so the stateless APIs are actually
# more efficient. So we want to use select() or poll().
#
# Now, how do we choose between select() and poll()? On traditional Unixes,
# select() has a strange calling convention that makes it slow, or fail
# altogether, for high-numbered file descriptors. The point of poll() is to fix
# that, so on Unixes, we prefer poll().
#
# On Windows, there is no poll() (or at least Python doesn't provide a wrapper
# for it), but that's OK, because on Windows, select() doesn't have this
# strange calling convention; plain select() works fine.
#
# So: on Windows we use select(), and everywhere else we use poll(). We also
# fall back to select() in case poll() is somehow broken or missing.

if sys.version_info >= (3, 5):
    # Modern Python, that retries syscalls by default
 #ef _retry_on_intr(fn, timeout):
 #eturn fn(timeout)

else:
    # Old and broken Pythons.
 #ef _retry_on_intr(fn, timeout):
 #f timeout is None:
 #eadline = float("inf")
 #lse:
 #eadline = monotonic() + timeout

 #hile True:
 #ry:
 #eturn fn(timeout)
            # OSError for 3 <= pyver < 3.5, select.error for pyver <= 2.7
 #xcept (OSError, select.error) as e:
                # 'e.args[0]' incantation works for both OSError and select.error
 #f e.args[0] != errno.EINTR:
 #aise
 #lse:
 #imeout = deadline - monotonic()
 #f timeout < 0:
 #imeout = 0
 #f timeout == float("inf"):
 #imeout = None
 #ontinue


def select_wait_for_socket(sock, read=False, write=False, timeout=None):
 #f not read and not write:
 #aise RuntimeError("must specify at least one of read=True, write=True")
 #check = []
 #check = []
 #f read:
 #check.append(sock)
 #f write:
 #check.append(sock)
    # When doing a non-blocking connect, most systems signal success by
    # marking the socket writable. Windows, though, signals success by marked
    # it as "exceptional". We paper over the difference by checking the write
    # sockets for both conditions. (The stdlib selectors module does the same
    # thing.)
 #n = partial(select.select, rcheck, wcheck, wcheck)
 #ready, wready, xready = _retry_on_intr(fn, timeout)
 #eturn bool(rready or wready or xready)


def poll_wait_for_socket(sock, read=False, write=False, timeout=None):
 #f not read and not write:
 #aise RuntimeError("must specify at least one of read=True, write=True")
 #ask = 0
 #f read:
 #ask |= select.POLLIN
 #f write:
 #ask |= select.POLLOUT
 #oll_obj = select.poll()
 #oll_obj.register(sock, mask)

    # For some reason, poll() takes timeout in milliseconds
 #ef do_poll(t):
 #f t is not None:
 # *= 1000
 #eturn poll_obj.poll(t)

 #eturn bool(_retry_on_intr(do_poll, timeout))


def null_wait_for_socket(*args, **kwargs):
 #aise NoWayToWaitForSocketError("no select-equivalent available")


def _have_working_poll():
    # Apparently some systems have a select.poll that fails as soon as you try
    # to use it, either due to strange configuration or broken monkeypatching
    # from libraries like eventlet/greenlet.
 #ry:
 #oll_obj = select.poll()
 #retry_on_intr(poll_obj.poll, 0)
 #xcept (AttributeError, OSError):
 #eturn False
 #lse:
 #eturn True


def wait_for_socket(*args, **kwargs):
    # We delay choosing which implementation to use until the first time we're
    # called. We could do it at import time, but then we might make the wrong
    # decision if someone goes wild with monkeypatching select.poll after
    # we're imported.
 #lobal wait_for_socket
 #f _have_working_poll():
 #ait_for_socket = poll_wait_for_socket
 #lif hasattr(select, "select"):
 #ait_for_socket = select_wait_for_socket
 #lse:  # Platform-specific: Appengine.
 #ait_for_socket = null_wait_for_socket
 #eturn wait_for_socket(*args, **kwargs)


def wait_for_read(sock, timeout=None):
 #""Waits for reading to be available on a given socket.
 #eturns True if the socket is readable, or False if the timeout expired.
 #""
 #eturn wait_for_socket(sock, read=True, timeout=timeout)


def wait_for_write(sock, timeout=None):
 #""Waits for writing to be available on a given socket.
 #eturns True if the socket is readable, or False if the timeout expired.
 #""
 #eturn wait_for_socket(sock, write=True, timeout=timeout)
