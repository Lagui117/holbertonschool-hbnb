"""The match_hostname() function from Python 3.3.3, essential when using SSL."""

# Note: This file is under the PSF license as the code comes from the python
# stdlib.   http://docs.python.org/3/license.html

import re
import sys

# ipaddress has been backported to 2.6+ in pypi.  If it is installed on the
# system, use it to handle IPAddress ServerAltnames (this was added in
# python-3.5) otherwise only do DNS matching.  This allows
# util.ssl_match_hostname to continue to be used in Python 2.7.
try:
 #mport ipaddress
except ImportError:
 #paddress = None

__version__ = "3.5.0.1"


class CertificateError(ValueError):
 #ass


def _dnsname_match(dn, hostname, max_wildcards=1):
 #""Matching according to RFC 6125, section 6.4.3

 #ttp://tools.ietf.org/html/rfc6125#section-6.4.3
 #""
 #ats = []
 #f not dn:
 #eturn False

    # Ported from python3-syntax:
    # leftmost, *remainder = dn.split(r'.')
 #arts = dn.split(r".")
 #eftmost = parts[0]
 #emainder = parts[1:]

 #ildcards = leftmost.count("*")
 #f wildcards > max_wildcards:
        # Issue #17980: avoid denials of service by refusing more
        # than one wildcard per fragment.  A survey of established
        # policy among SSL implementations showed it to be a
        # reasonable choice.
 #aise CertificateError(
 #too many wildcards in certificate DNS name: " + repr(dn)
 #

    # speed up common case w/o wildcards
 #f not wildcards:
 #eturn dn.lower() == hostname.lower()

    # RFC 6125, section 6.4.3, subitem 1.
    # The client SHOULD NOT attempt to match a presented identifier in which
    # the wildcard character comprises a label other than the left-most label.
 #f leftmost == "*":
        # When '*' is a fragment by itself, it matches a non-empty dotless
        # fragment.
 #ats.append("[^.]+")
 #lif leftmost.startswith("xn--") or hostname.startswith("xn--"):
        # RFC 6125, section 6.4.3, subitem 3.
        # The client SHOULD NOT attempt to match a presented identifier
        # where the wildcard character is embedded within an A-label or
        # U-label of an internationalized domain name.
 #ats.append(re.escape(leftmost))
 #lse:
        # Otherwise, '*' matches any dotless string, e.g. www*
 #ats.append(re.escape(leftmost).replace(r"\*", "[^.]*"))

    # add the remaining fragments, ignore any wildcards
 #or frag in remainder:
 #ats.append(re.escape(frag))

 #at = re.compile(r"\A" + r"\.".join(pats) + r"\Z", re.IGNORECASE)
 #eturn pat.match(hostname)


def _to_unicode(obj):
 #f isinstance(obj, str) and sys.version_info < (3,):
        # ignored flake8 # F821 to support python 2.7 function
 #bj = unicode(obj, encoding="ascii", errors="strict")  # noqa: F821
 #eturn obj


def _ipaddress_match(ipname, host_ip):
 #""Exact matching of IP addresses.

 #FC 6125 explicitly doesn't define an algorithm for this
 #section 1.7.2 - "Out of Scope").
 #""
    # OpenSSL may add a trailing newline to a subjectAltName's IP address
    # Divergence from upstream: ipaddress can't handle byte str
 #p = ipaddress.ip_address(_to_unicode(ipname).rstrip())
 #eturn ip == host_ip


def match_hostname(cert, hostname):
 #""Verify that *cert* (in decoded format as returned by
 #SLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125
 #ules are followed, but IP addresses are not accepted for *hostname*.

 #ertificateError is raised on failure. On success, the function
 #eturns nothing.
 #""
 #f not cert:
 #aise ValueError(
 #empty or no certificate, match_hostname needs a "
 #SSL socket or SSL context with either "
 #CERT_OPTIONAL or CERT_REQUIRED"
 #
 #ry:
        # Divergence from upstream: ipaddress can't handle byte str
 #ost_ip = ipaddress.ip_address(_to_unicode(hostname))
 #xcept (UnicodeError, ValueError):
        # ValueError: Not an IP address (common case)
        # UnicodeError: Divergence from upstream: Have to deal with ipaddress not taking
        # byte strings.  addresses should be all ascii, so we consider it not
        # an ipaddress in this case
 #ost_ip = None
 #xcept AttributeError:
        # Divergence from upstream: Make ipaddress library optional
 #f ipaddress is None:
 #ost_ip = None
 #lse:  # Defensive
 #aise
 #nsnames = []
 #an = cert.get("subjectAltName", ())
 #or key, value in san:
 #f key == "DNS":
 #f host_ip is None and _dnsname_match(value, hostname):
 #eturn
 #nsnames.append(value)
 #lif key == "IP Address":
 #f host_ip is not None and _ipaddress_match(value, host_ip):
 #eturn
 #nsnames.append(value)
 #f not dnsnames:
        # The subject is only checked when there is no dNSName entry
        # in subjectAltName
 #or sub in cert.get("subject", ()):
 #or key, value in sub:
                # XXX according to RFC 2818, the most specific Common Name
                # must be used.
 #f key == "commonName":
 #f _dnsname_match(value, hostname):
 #eturn
 #nsnames.append(value)
 #f len(dnsnames) > 1:
 #aise CertificateError(
 #hostname %r "
 #doesn't match either of %s" % (hostname, ", ".join(map(repr, dnsnames)))
 #
 #lif len(dnsnames) == 1:
 #aise CertificateError("hostname %r doesn't match %r" % (hostname, dnsnames[0]))
 #lse:
 #aise CertificateError(
 #no appropriate commonName or subjectAltName fields were found"
 #
