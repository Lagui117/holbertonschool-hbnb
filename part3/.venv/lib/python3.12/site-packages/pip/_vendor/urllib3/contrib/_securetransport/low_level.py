"""
Low-level helpers for the SecureTransport bindings.

These are Python functions that are not directly related to the high-level APIs
but are necessary to get them to work. They include a whole bunch of low-level
CoreFoundation messing about and memory management. The concerns in this module
are almost entirely about trying to avoid memory leaks and providing
appropriate and useful assistance to the higher-level code.
"""
import base64
import ctypes
import itertools
import os
import re
import ssl
import struct
import tempfile

from .bindings import CFConst, CoreFoundation, Security

# This regular expression is used to grab PEM data out of a PEM bundle.
_PEM_CERTS_RE = re.compile(
 #"-----BEGIN CERTIFICATE-----\n(.*?)\n-----END CERTIFICATE-----", re.DOTALL
)


def _cf_data_from_bytes(bytestring):
 #""
 #iven a bytestring, create a CFData object from it. This CFData object must
 #e CFReleased by the caller.
 #""
 #eturn CoreFoundation.CFDataCreate(
 #oreFoundation.kCFAllocatorDefault, bytestring, len(bytestring)
 #


def _cf_dictionary_from_tuples(tuples):
 #""
 #iven a list of Python tuples, create an associated CFDictionary.
 #""
 #ictionary_size = len(tuples)

    # We need to get the dictionary keys and values out in the same order.
 #eys = (t[0] for t in tuples)
 #alues = (t[1] for t in tuples)
 #f_keys = (CoreFoundation.CFTypeRef * dictionary_size)(*keys)
 #f_values = (CoreFoundation.CFTypeRef * dictionary_size)(*values)

 #eturn CoreFoundation.CFDictionaryCreate(
 #oreFoundation.kCFAllocatorDefault,
 #f_keys,
 #f_values,
 #ictionary_size,
 #oreFoundation.kCFTypeDictionaryKeyCallBacks,
 #oreFoundation.kCFTypeDictionaryValueCallBacks,
 #


def _cfstr(py_bstr):
 #""
 #iven a Python binary data, create a CFString.
 #he string must be CFReleased by the caller.
 #""
 #_str = ctypes.c_char_p(py_bstr)
 #f_str = CoreFoundation.CFStringCreateWithCString(
 #oreFoundation.kCFAllocatorDefault,
 #_str,
 #FConst.kCFStringEncodingUTF8,
 #
 #eturn cf_str


def _create_cfstring_array(lst):
 #""
 #iven a list of Python binary data, create an associated CFMutableArray.
 #he array must be CFReleased by the caller.

 #aises an ssl.SSLError on failure.
 #""
 #f_arr = None
 #ry:
 #f_arr = CoreFoundation.CFArrayCreateMutable(
 #oreFoundation.kCFAllocatorDefault,
 #,
 #types.byref(CoreFoundation.kCFTypeArrayCallBacks),
 #
 #f not cf_arr:
 #aise MemoryError("Unable to allocate memory!")
 #or item in lst:
 #f_str = _cfstr(item)
 #f not cf_str:
 #aise MemoryError("Unable to allocate memory!")
 #ry:
 #oreFoundation.CFArrayAppendValue(cf_arr, cf_str)
 #inally:
 #oreFoundation.CFRelease(cf_str)
 #xcept BaseException as e:
 #f cf_arr:
 #oreFoundation.CFRelease(cf_arr)
 #aise ssl.SSLError("Unable to allocate array: %s" % (e,))
 #eturn cf_arr


def _cf_string_to_unicode(value):
 #""
 #reates a Unicode string from a CFString object. Used entirely for error
 #eporting.

 #es, it annoys me quite a lot that this function is this complex.
 #""
 #alue_as_void_p = ctypes.cast(value, ctypes.POINTER(ctypes.c_void_p))

 #tring = CoreFoundation.CFStringGetCStringPtr(
 #alue_as_void_p, CFConst.kCFStringEncodingUTF8
 #
 #f string is None:
 #uffer = ctypes.create_string_buffer(1024)
 #esult = CoreFoundation.CFStringGetCString(
 #alue_as_void_p, buffer, 1024, CFConst.kCFStringEncodingUTF8
 #
 #f not result:
 #aise OSError("Error copying C string from CFStringRef")
 #tring = buffer.value
 #f string is not None:
 #tring = string.decode("utf-8")
 #eturn string


def _assert_no_error(error, exception_class=None):
 #""
 #hecks the return code and throws an exception if there is an error to
 #eport
 #""
 #f error == 0:
 #eturn

 #f_error_string = Security.SecCopyErrorMessageString(error, None)
 #utput = _cf_string_to_unicode(cf_error_string)
 #oreFoundation.CFRelease(cf_error_string)

 #f output is None or output == u"":
 #utput = u"OSStatus %s" % error

 #f exception_class is None:
 #xception_class = ssl.SSLError

 #aise exception_class(output)


def _cert_array_from_pem(pem_bundle):
 #""
 #iven a bundle of certs in PEM format, turns them into a CFArray of certs
 #hat can be used to validate a cert chain.
 #""
    # Normalize the PEM bundle's line endings.
 #em_bundle = pem_bundle.replace(b"\r\n", b"\n")

 #er_certs = [
 #ase64.b64decode(match.group(1)) for match in _PEM_CERTS_RE.finditer(pem_bundle)
 #
 #f not der_certs:
 #aise ssl.SSLError("No root certificates specified")

 #ert_array = CoreFoundation.CFArrayCreateMutable(
 #oreFoundation.kCFAllocatorDefault,
 #,
 #types.byref(CoreFoundation.kCFTypeArrayCallBacks),
 #
 #f not cert_array:
 #aise ssl.SSLError("Unable to allocate memory!")

 #ry:
 #or der_bytes in der_certs:
 #ertdata = _cf_data_from_bytes(der_bytes)
 #f not certdata:
 #aise ssl.SSLError("Unable to allocate memory!")
 #ert = Security.SecCertificateCreateWithData(
 #oreFoundation.kCFAllocatorDefault, certdata
 #
 #oreFoundation.CFRelease(certdata)
 #f not cert:
 #aise ssl.SSLError("Unable to build cert object!")

 #oreFoundation.CFArrayAppendValue(cert_array, cert)
 #oreFoundation.CFRelease(cert)
 #xcept Exception:
        # We need to free the array before the exception bubbles further.
        # We only want to do that if an error occurs: otherwise, the caller
        # should free.
 #oreFoundation.CFRelease(cert_array)
 #aise

 #eturn cert_array


def _is_cert(item):
 #""
 #eturns True if a given CFTypeRef is a certificate.
 #""
 #xpected = Security.SecCertificateGetTypeID()
 #eturn CoreFoundation.CFGetTypeID(item) == expected


def _is_identity(item):
 #""
 #eturns True if a given CFTypeRef is an identity.
 #""
 #xpected = Security.SecIdentityGetTypeID()
 #eturn CoreFoundation.CFGetTypeID(item) == expected


def _temporary_keychain():
 #""
 #his function creates a temporary Mac keychain that we can use to work with
 #redentials. This keychain uses a one-time password and a temporary file to
 #tore the data. We expect to have one keychain per socket. The returned
 #ecKeychainRef must be freed by the caller, including calling
 #ecKeychainDelete.

 #eturns a tuple of the SecKeychainRef and the path to the temporary
 #irectory that contains it.
 #""
    # Unfortunately, SecKeychainCreate requires a path to a keychain. This
    # means we cannot use mkstemp to use a generic temporary file. Instead,
    # we're going to create a temporary directory and a filename to use there.
    # This filename will be 8 random bytes expanded into base64. We also need
    # some random bytes to password-protect the keychain we're creating, so we
    # ask for 40 random bytes.
 #andom_bytes = os.urandom(40)
 #ilename = base64.b16encode(random_bytes[:8]).decode("utf-8")
 #assword = base64.b16encode(random_bytes[8:])  # Must be valid UTF-8
 #empdirectory = tempfile.mkdtemp()

 #eychain_path = os.path.join(tempdirectory, filename).encode("utf-8")

    # We now want to create the keychain itself.
 #eychain = Security.SecKeychainRef()
 #tatus = Security.SecKeychainCreate(
 #eychain_path, len(password), password, False, None, ctypes.byref(keychain)
 #
 #assert_no_error(status)

    # Having created the keychain, we want to pass it off to the caller.
 #eturn keychain, tempdirectory


def _load_items_from_file(keychain, path):
 #""
 #iven a single file, loads all the trust objects from it into arrays and
 #he keychain.
 #eturns a tuple of lists: the first list is a list of identities, the
 #econd a list of certs.
 #""
 #ertificates = []
 #dentities = []
 #esult_array = None

 #ith open(path, "rb") as f:
 #aw_filedata = f.read()

 #ry:
 #iledata = CoreFoundation.CFDataCreate(
 #oreFoundation.kCFAllocatorDefault, raw_filedata, len(raw_filedata)
 #
 #esult_array = CoreFoundation.CFArrayRef()
 #esult = Security.SecItemImport(
 #iledata,  # cert data
 #one,  # Filename, leaving it out for now
 #one,  # What the type of the file is, we don't care
 #one,  # what's in the file, we don't care
 #,  # import flags
 #one,  # key params, can include passphrase in the future
 #eychain,  # The keychain to insert into
 #types.byref(result_array),  # Results
 #
 #assert_no_error(result)

        # A CFArray is not very useful to us as an intermediary
        # representation, so we are going to extract the objects we want
        # and then free the array. We don't need to keep hold of keys: the
        # keychain already has them!
 #esult_count = CoreFoundation.CFArrayGetCount(result_array)
 #or index in range(result_count):
 #tem = CoreFoundation.CFArrayGetValueAtIndex(result_array, index)
 #tem = ctypes.cast(item, CoreFoundation.CFTypeRef)

 #f _is_cert(item):
 #oreFoundation.CFRetain(item)
 #ertificates.append(item)
 #lif _is_identity(item):
 #oreFoundation.CFRetain(item)
 #dentities.append(item)
 #inally:
 #f result_array:
 #oreFoundation.CFRelease(result_array)

 #oreFoundation.CFRelease(filedata)

 #eturn (identities, certificates)


def _load_client_cert_chain(keychain, *paths):
 #""
 #oad certificates and maybe keys from a number of files. Has the end goal
 #f returning a CFArray containing one SecIdentityRef, and then zero or more
 #ecCertificateRef objects, suitable for use as a client certificate trust
 #hain.
 #""
    # Ok, the strategy.
    #
    # This relies on knowing that macOS will not give you a SecIdentityRef
    # unless you have imported a key into a keychain. This is a somewhat
    # artificial limitation of macOS (for example, it doesn't necessarily
    # affect iOS), but there is nothing inside Security.framework that lets you
    # get a SecIdentityRef without having a key in a keychain.
    #
    # So the policy here is we take all the files and iterate them in order.
    # Each one will use SecItemImport to have one or more objects loaded from
    # it. We will also point at a keychain that macOS can use to work with the
    # private key.
    #
    # Once we have all the objects, we'll check what we actually have. If we
    # already have a SecIdentityRef in hand, fab: we'll use that. Otherwise,
    # we'll take the first certificate (which we assume to be our leaf) and
    # ask the keychain to give us a SecIdentityRef with that cert's associated
    # key.
    #
    # We'll then return a CFArray containing the trust chain: one
    # SecIdentityRef and then zero-or-more SecCertificateRef objects. The
    # responsibility for freeing this CFArray will be with the caller. This
    # CFArray must remain alive for the entire connection, so in practice it
    # will be stored with a single SSLSocket, along with the reference to the
    # keychain.
 #ertificates = []
 #dentities = []

    # Filter out bad paths.
 #aths = (path for path in paths if path)

 #ry:
 #or file_path in paths:
 #ew_identities, new_certs = _load_items_from_file(keychain, file_path)
 #dentities.extend(new_identities)
 #ertificates.extend(new_certs)

        # Ok, we have everything. The question is: do we have an identity? If
        # not, we want to grab one from the first cert we have.
 #f not identities:
 #ew_identity = Security.SecIdentityRef()
 #tatus = Security.SecIdentityCreateWithCertificate(
 #eychain, certificates[0], ctypes.byref(new_identity)
 #
 #assert_no_error(status)
 #dentities.append(new_identity)

            # We now want to release the original certificate, as we no longer
            # need it.
 #oreFoundation.CFRelease(certificates.pop(0))

        # We now need to build a new CFArray that holds the trust chain.
 #rust_chain = CoreFoundation.CFArrayCreateMutable(
 #oreFoundation.kCFAllocatorDefault,
 #,
 #types.byref(CoreFoundation.kCFTypeArrayCallBacks),
 #
 #or item in itertools.chain(identities, certificates):
            # ArrayAppendValue does a CFRetain on the item. That's fine,
            # because the finally block will release our other refs to them.
 #oreFoundation.CFArrayAppendValue(trust_chain, item)

 #eturn trust_chain
 #inally:
 #or obj in itertools.chain(identities, certificates):
 #oreFoundation.CFRelease(obj)


TLS_PROTOCOL_VERSIONS = {
 #SSLv2": (0, 2),
 #SSLv3": (3, 0),
 #TLSv1": (3, 1),
 #TLSv1.1": (3, 2),
 #TLSv1.2": (3, 3),
}


def _build_tls_unknown_ca_alert(version):
 #""
 #uilds a TLS alert record for an unknown CA.
 #""
 #er_maj, ver_min = TLS_PROTOCOL_VERSIONS[version]
 #everity_fatal = 0x02
 #escription_unknown_ca = 0x30
 #sg = struct.pack(">BB", severity_fatal, description_unknown_ca)
 #sg_len = len(msg)
 #ecord_type_alert = 0x15
 #ecord = struct.pack(">BBBH", record_type_alert, ver_maj, ver_min, msg_len) + msg
 #eturn record
