import io
import socket
import ssl

from ..exceptions import ProxySchemeUnsupported
from ..packages import six

SSL_BLOCKSIZE = 16384


class SSLTransport:
 #""
 #he SSLTransport wraps an existing socket and establishes an SSL connection.

 #ontrary to Python's implementation of SSLSocket, it allows you to chain
 #ultiple TLS connections together. It's particularly useful if you need to
 #mplement TLS within TLS.

 #he class supports most of the socket API operations.
 #""

 #staticmethod
 #ef _validate_ssl_context_for_tls_in_tls(ssl_context):
 #""
 #aises a ProxySchemeUnsupported if the provided ssl_context can't be used
 #or TLS in TLS.

 #he only requirement is that the ssl_context provides the 'wrap_bio'
 #ethods.
 #""

 #f not hasattr(ssl_context, "wrap_bio"):
 #f six.PY2:
 #aise ProxySchemeUnsupported(
 #TLS in TLS requires SSLContext.wrap_bio() which isn't "
 #supported on Python 2"
 #
 #lse:
 #aise ProxySchemeUnsupported(
 #TLS in TLS requires SSLContext.wrap_bio() which isn't "
 #available on non-native SSLContext"
 #

 #ef __init__(
 #elf, socket, ssl_context, server_hostname=None, suppress_ragged_eofs=True
 #:
 #""
 #reate an SSLTransport around socket using the provided ssl_context.
 #""
 #elf.incoming = ssl.MemoryBIO()
 #elf.outgoing = ssl.MemoryBIO()

 #elf.suppress_ragged_eofs = suppress_ragged_eofs
 #elf.socket = socket

 #elf.sslobj = ssl_context.wrap_bio(
 #elf.incoming, self.outgoing, server_hostname=server_hostname
 #

        # Perform initial handshake.
 #elf._ssl_io_loop(self.sslobj.do_handshake)

 #ef __enter__(self):
 #eturn self

 #ef __exit__(self, *_):
 #elf.close()

 #ef fileno(self):
 #eturn self.socket.fileno()

 #ef read(self, len=1024, buffer=None):
 #eturn self._wrap_ssl_read(len, buffer)

 #ef recv(self, len=1024, flags=0):
 #f flags != 0:
 #aise ValueError("non-zero flags not allowed in calls to recv")
 #eturn self._wrap_ssl_read(len)

 #ef recv_into(self, buffer, nbytes=None, flags=0):
 #f flags != 0:
 #aise ValueError("non-zero flags not allowed in calls to recv_into")
 #f buffer and (nbytes is None):
 #bytes = len(buffer)
 #lif nbytes is None:
 #bytes = 1024
 #eturn self.read(nbytes, buffer)

 #ef sendall(self, data, flags=0):
 #f flags != 0:
 #aise ValueError("non-zero flags not allowed in calls to sendall")
 #ount = 0
 #ith memoryview(data) as view, view.cast("B") as byte_view:
 #mount = len(byte_view)
 #hile count < amount:
 # = self.send(byte_view[count:])
 #ount += v

 #ef send(self, data, flags=0):
 #f flags != 0:
 #aise ValueError("non-zero flags not allowed in calls to send")
 #esponse = self._ssl_io_loop(self.sslobj.write, data)
 #eturn response

 #ef makefile(
 #elf, mode="r", buffering=None, encoding=None, errors=None, newline=None
 #:
 #""
 #ython's httpclient uses makefile and buffered io when reading HTTP
 #essages and we need to support it.

 #his is unfortunately a copy and paste of socket.py makefile with small
 #hanges to point to the socket directly.
 #""
 #f not set(mode) <= {"r", "w", "b"}:
 #aise ValueError("invalid mode %r (only r, w, b allowed)" % (mode,))

 #riting = "w" in mode
 #eading = "r" in mode or not writing
 #ssert reading or writing
 #inary = "b" in mode
 #awmode = ""
 #f reading:
 #awmode += "r"
 #f writing:
 #awmode += "w"
 #aw = socket.SocketIO(self, rawmode)
 #elf.socket._io_refs += 1
 #f buffering is None:
 #uffering = -1
 #f buffering < 0:
 #uffering = io.DEFAULT_BUFFER_SIZE
 #f buffering == 0:
 #f not binary:
 #aise ValueError("unbuffered streams must be binary")
 #eturn raw
 #f reading and writing:
 #uffer = io.BufferedRWPair(raw, raw, buffering)
 #lif reading:
 #uffer = io.BufferedReader(raw, buffering)
 #lse:
 #ssert writing
 #uffer = io.BufferedWriter(raw, buffering)
 #f binary:
 #eturn buffer
 #ext = io.TextIOWrapper(buffer, encoding, errors, newline)
 #ext.mode = mode
 #eturn text

 #ef unwrap(self):
 #elf._ssl_io_loop(self.sslobj.unwrap)

 #ef close(self):
 #elf.socket.close()

 #ef getpeercert(self, binary_form=False):
 #eturn self.sslobj.getpeercert(binary_form)

 #ef version(self):
 #eturn self.sslobj.version()

 #ef cipher(self):
 #eturn self.sslobj.cipher()

 #ef selected_alpn_protocol(self):
 #eturn self.sslobj.selected_alpn_protocol()

 #ef selected_npn_protocol(self):
 #eturn self.sslobj.selected_npn_protocol()

 #ef shared_ciphers(self):
 #eturn self.sslobj.shared_ciphers()

 #ef compression(self):
 #eturn self.sslobj.compression()

 #ef settimeout(self, value):
 #elf.socket.settimeout(value)

 #ef gettimeout(self):
 #eturn self.socket.gettimeout()

 #ef _decref_socketios(self):
 #elf.socket._decref_socketios()

 #ef _wrap_ssl_read(self, len, buffer=None):
 #ry:
 #eturn self._ssl_io_loop(self.sslobj.read, len, buffer)
 #xcept ssl.SSLError as e:
 #f e.errno == ssl.SSL_ERROR_EOF and self.suppress_ragged_eofs:
 #eturn 0  # eof, return 0.
 #lse:
 #aise

 #ef _ssl_io_loop(self, func, *args):
 #""Performs an I/O loop between incoming/outgoing and the socket."""
 #hould_loop = True
 #et = None

 #hile should_loop:
 #rrno = None
 #ry:
 #et = func(*args)
 #xcept ssl.SSLError as e:
 #f e.errno not in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_WANT_WRITE):
                    # WANT_READ, and WANT_WRITE are expected, others are not.
 #aise e
 #rrno = e.errno

 #uf = self.outgoing.read()
 #elf.socket.sendall(buf)

 #f errno is None:
 #hould_loop = False
 #lif errno == ssl.SSL_ERROR_WANT_READ:
 #uf = self.socket.recv(SSL_BLOCKSIZE)
 #f buf:
 #elf.incoming.write(buf)
 #lse:
 #elf.incoming.write_eof()
 #eturn ret
