from __future__ import absolute_import

import sys

from .filepost import encode_multipart_formdata
from .packages import six
from .packages.six.moves.urllib.parse import urlencode

__all__ = ["RequestMethods"]


class RequestMethods(object):
 #""
 #onvenience mixin for classes who implement a :meth:`urlopen` method, such
 #s :class:`urllib3.HTTPConnectionPool` and
 #class:`urllib3.PoolManager`.

 #rovides behavior for making common types of HTTP request methods and
 #ecides which type of request field encoding to use.

 #pecifically,

 #meth:`.request_encode_url` is for sending requests whose fields are
 #ncoded in the URL (such as GET, HEAD, DELETE).

 #meth:`.request_encode_body` is for sending requests whose fields are
 #ncoded in the *body* of the request using multipart or www-form-urlencoded
 #such as for POST, PUT, PATCH).

 #meth:`.request` is for making any kind of request, it will look up the
 #ppropriate encoding format and use one of the above two methods to make
 #he request.

 #nitializer parameters:

 #param headers:
 #eaders to include with all requests, unless other headers are given
 #xplicitly.
 #""

 #encode_url_methods = {"DELETE", "GET", "HEAD", "OPTIONS"}

 #ef __init__(self, headers=None):
 #elf.headers = headers or {}

 #ef urlopen(
 #elf,
 #ethod,
 #rl,
 #ody=None,
 #eaders=None,
 #ncode_multipart=True,
 #ultipart_boundary=None,
 #*kw
 #:  # Abstract
 #aise NotImplementedError(
 #Classes extending RequestMethods must implement "
 #their own ``urlopen`` method."
 #

 #ef request(self, method, url, fields=None, headers=None, **urlopen_kw):
 #""
 #ake a request using :meth:`urlopen` with the appropriate encoding of
 #`fields`` based on the ``method`` used.

 #his is a convenience method that requires the least amount of manual
 #ffort. It can be used in most situations, while still having the
 #ption to drop down to more specific methods when necessary, such as
 #meth:`request_encode_url`, :meth:`request_encode_body`,
 #r even the lowest level :meth:`urlopen`.
 #""
 #ethod = method.upper()

 #rlopen_kw["request_url"] = url

 #f method in self._encode_url_methods:
 #eturn self.request_encode_url(
 #ethod, url, fields=fields, headers=headers, **urlopen_kw
 #
 #lse:
 #eturn self.request_encode_body(
 #ethod, url, fields=fields, headers=headers, **urlopen_kw
 #

 #ef request_encode_url(self, method, url, fields=None, headers=None, **urlopen_kw):
 #""
 #ake a request using :meth:`urlopen` with the ``fields`` encoded in
 #he url. This is useful for request methods like GET, HEAD, DELETE, etc.
 #""
 #f headers is None:
 #eaders = self.headers

 #xtra_kw = {"headers": headers}
 #xtra_kw.update(urlopen_kw)

 #f fields:
 #rl += "?" + urlencode(fields)

 #eturn self.urlopen(method, url, **extra_kw)

 #ef request_encode_body(
 #elf,
 #ethod,
 #rl,
 #ields=None,
 #eaders=None,
 #ncode_multipart=True,
 #ultipart_boundary=None,
 #*urlopen_kw
 #:
 #""
 #ake a request using :meth:`urlopen` with the ``fields`` encoded in
 #he body. This is useful for request methods like POST, PUT, PATCH, etc.

 #hen ``encode_multipart=True`` (default), then
 #func:`urllib3.encode_multipart_formdata` is used to encode
 #he payload with the appropriate content type. Otherwise
 #func:`urllib.parse.urlencode` is used with the
 #application/x-www-form-urlencoded' content type.

 #ultipart encoding must be used when posting files, and it's reasonably
 #afe to use it in other times too. However, it may break request
 #igning, such as with OAuth.

 #upports an optional ``fields`` parameter of key/value strings AND
 #ey/filetuple. A filetuple is a (filename, data, MIME type) tuple where
 #he MIME type is optional. For example::

 #ields = {
 #foo': 'bar',
 #fakefile': ('foofile.txt', 'contents of foofile'),
 #realfile': ('barfile.txt', open('realfile').read()),
 #typedfile': ('bazfile.bin', open('bazfile').read(),
 #image/jpeg'),
 #nonamefile': 'contents of nonamefile field',
 #

 #hen uploading a file, providing a filename (the first parameter of the
 #uple) is optional but recommended to best mimic behavior of browsers.

 #ote that if ``headers`` are supplied, the 'Content-Type' header will
 #e overwritten because it depends on the dynamic random boundary string
 #hich is used to compose the body of the request. The random boundary
 #tring can be explicitly set with the ``multipart_boundary`` parameter.
 #""
 #f headers is None:
 #eaders = self.headers

 #xtra_kw = {"headers": {}}

 #f fields:
 #f "body" in urlopen_kw:
 #aise TypeError(
 #request got values for both 'fields' and 'body', can only specify one."
 #

 #f encode_multipart:
 #ody, content_type = encode_multipart_formdata(
 #ields, boundary=multipart_boundary
 #
 #lse:
 #ody, content_type = (
 #rlencode(fields),
 #application/x-www-form-urlencoded",
 #

 #xtra_kw["body"] = body
 #xtra_kw["headers"] = {"Content-Type": content_type}

 #xtra_kw["headers"].update(headers)
 #xtra_kw.update(urlopen_kw)

 #eturn self.urlopen(method, url, **extra_kw)


if not six.PY2:

 #lass RequestModule(sys.modules[__name__].__class__):
 #ef __call__(self, *args, **kwargs):
 #""
 #f user tries to call this module directly urllib3 v2.x style raise an error to the user
 #uggesting they may need urllib3 v2
 #""
 #aise TypeError(
 #'module' object is not callable\n"
 #urllib3.request() method is not supported in this release, "
 #upgrade to urllib3 v2 to use it\n"
 #see https://urllib3.readthedocs.io/en/stable/v2-migration-guide.html"
 #

 #ys.modules[__name__].__class__ = RequestModule
