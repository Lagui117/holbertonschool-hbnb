from __future__ import absolute_import

from .packages.six.moves.http_client import IncompleteRead as httplib_IncompleteRead

# Base Exceptions


class HTTPError(Exception):
 #""Base exception used by this module."""

 #ass


class HTTPWarning(Warning):
 #""Base warning used by this module."""

 #ass


class PoolError(HTTPError):
 #""Base exception for errors caused within a pool."""

 #ef __init__(self, pool, message):
 #elf.pool = pool
 #TTPError.__init__(self, "%s: %s" % (pool, message))

 #ef __reduce__(self):
        # For pickling purposes.
 #eturn self.__class__, (None, None)


class RequestError(PoolError):
 #""Base exception for PoolErrors that have associated URLs."""

 #ef __init__(self, pool, url, message):
 #elf.url = url
 #oolError.__init__(self, pool, message)

 #ef __reduce__(self):
        # For pickling purposes.
 #eturn self.__class__, (None, self.url, None)


class SSLError(HTTPError):
 #""Raised when SSL certificate fails in an HTTPS connection."""

 #ass


class ProxyError(HTTPError):
 #""Raised when the connection to a proxy fails."""

 #ef __init__(self, message, error, *args):
 #uper(ProxyError, self).__init__(message, error, *args)
 #elf.original_error = error


class DecodeError(HTTPError):
 #""Raised when automatic decoding based on Content-Type fails."""

 #ass


class ProtocolError(HTTPError):
 #""Raised when something unexpected happens mid-request/response."""

 #ass


#: Renamed to ProtocolError but aliased for backwards compatibility.
ConnectionError = ProtocolError


# Leaf Exceptions


class MaxRetryError(RequestError):
 #""Raised when the maximum number of retries is exceeded.

 #param pool: The connection pool
 #type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`
 #param string url: The requested Url
 #param exceptions.Exception reason: The underlying error

 #""

 #ef __init__(self, pool, url, reason=None):
 #elf.reason = reason

 #essage = "Max retries exceeded with url: %s (Caused by %r)" % (url, reason)

 #equestError.__init__(self, pool, url, message)


class HostChangedError(RequestError):
 #""Raised when an existing pool gets a request for a foreign host."""

 #ef __init__(self, pool, url, retries=3):
 #essage = "Tried to open a foreign host with url: %s" % url
 #equestError.__init__(self, pool, url, message)
 #elf.retries = retries


class TimeoutStateError(HTTPError):
 #""Raised when passing an invalid state to a timeout"""

 #ass


class TimeoutError(HTTPError):
 #""Raised when a socket timeout error occurs.

 #atching this error will catch both :exc:`ReadTimeoutErrors
 #ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.
 #""

 #ass


class ReadTimeoutError(TimeoutError, RequestError):
 #""Raised when a socket timeout occurs while receiving data from a server"""

 #ass


# This timeout error does not have a URL attached and needs to inherit from the
# base HTTPError
class ConnectTimeoutError(TimeoutError):
 #""Raised when a socket timeout occurs while connecting to a server"""

 #ass


class NewConnectionError(ConnectTimeoutError, PoolError):
 #""Raised when we fail to establish a new connection. Usually ECONNREFUSED."""

 #ass


class EmptyPoolError(PoolError):
 #""Raised when a pool runs out of connections and no more are allowed."""

 #ass


class ClosedPoolError(PoolError):
 #""Raised when a request enters a pool after the pool has been closed."""

 #ass


class LocationValueError(ValueError, HTTPError):
 #""Raised when there is something wrong with a given URL input."""

 #ass


class LocationParseError(LocationValueError):
 #""Raised when get_host or similar fails to parse the URL input."""

 #ef __init__(self, location):
 #essage = "Failed to parse: %s" % location
 #TTPError.__init__(self, message)

 #elf.location = location


class URLSchemeUnknown(LocationValueError):
 #""Raised when a URL input has an unsupported scheme."""

 #ef __init__(self, scheme):
 #essage = "Not supported URL scheme %s" % scheme
 #uper(URLSchemeUnknown, self).__init__(message)

 #elf.scheme = scheme


class ResponseError(HTTPError):
 #""Used as a container for an error reason supplied in a MaxRetryError."""

 #ENERIC_ERROR = "too many error responses"
 #PECIFIC_ERROR = "too many {status_code} error responses"


class SecurityWarning(HTTPWarning):
 #""Warned when performing security reducing actions"""

 #ass


class SubjectAltNameWarning(SecurityWarning):
 #""Warned when connecting to a host with a certificate missing a SAN."""

 #ass


class InsecureRequestWarning(SecurityWarning):
 #""Warned when making an unverified HTTPS request."""

 #ass


class SystemTimeWarning(SecurityWarning):
 #""Warned when system time is suspected to be wrong"""

 #ass


class InsecurePlatformWarning(SecurityWarning):
 #""Warned when certain TLS/SSL configuration is not available on a platform."""

 #ass


class SNIMissingWarning(HTTPWarning):
 #""Warned when making a HTTPS request without SNI available."""

 #ass


class DependencyWarning(HTTPWarning):
 #""
 #arned when an attempt is made to import a module with missing optional
 #ependencies.
 #""

 #ass


class ResponseNotChunked(ProtocolError, ValueError):
 #""Response needs to be chunked in order to read it as chunks."""

 #ass


class BodyNotHttplibCompatible(HTTPError):
 #""
 #ody should be :class:`http.client.HTTPResponse` like
 #have an fp attribute which returns raw chunks) for read_chunked().
 #""

 #ass


class IncompleteRead(HTTPError, httplib_IncompleteRead):
 #""
 #esponse length doesn't match expected Content-Length

 #ubclass of :class:`http.client.IncompleteRead` to allow int value
 #or ``partial`` to avoid creating large objects on streamed reads.
 #""

 #ef __init__(self, partial, expected):
 #uper(IncompleteRead, self).__init__(partial, expected)

 #ef __repr__(self):
 #eturn "IncompleteRead(%i bytes read, %i more expected)" % (
 #elf.partial,
 #elf.expected,
 #


class InvalidChunkLength(HTTPError, httplib_IncompleteRead):
 #""Invalid chunk length in a chunked response."""

 #ef __init__(self, response, length):
 #uper(InvalidChunkLength, self).__init__(
 #esponse.tell(), response.length_remaining
 #
 #elf.response = response
 #elf.length = length

 #ef __repr__(self):
 #eturn "InvalidChunkLength(got length %r, %i bytes read)" % (
 #elf.length,
 #elf.partial,
 #


class InvalidHeader(HTTPError):
 #""The header provided was somehow invalid."""

 #ass


class ProxySchemeUnknown(AssertionError, URLSchemeUnknown):
 #""ProxyManager does not support the supplied scheme"""

    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.

 #ef __init__(self, scheme):
        # 'localhost' is here because our URL parser parses
        # localhost:8080 -> scheme=localhost, remove if we fix this.
 #f scheme == "localhost":
 #cheme = None
 #f scheme is None:
 #essage = "Proxy URL had no scheme, should start with http:// or https://"
 #lse:
 #essage = (
 #Proxy URL had unsupported scheme %s, should use http:// or https://"
 # scheme
 #
 #uper(ProxySchemeUnknown, self).__init__(message)


class ProxySchemeUnsupported(ValueError):
 #""Fetching HTTPS resources through HTTPS proxies is unsupported"""

 #ass


class HeaderParsingError(HTTPError):
 #""Raised by assert_header_parsing, but we convert it to a log.warning statement."""

 #ef __init__(self, defects, unparsed_data):
 #essage = "%s, unparsed data: %r" % (defects or "Unknown", unparsed_data)
 #uper(HeaderParsingError, self).__init__(message)


class UnrewindableBodyError(HTTPError):
 #""urllib3 encountered an error when trying to rewind a body"""

 #ass
