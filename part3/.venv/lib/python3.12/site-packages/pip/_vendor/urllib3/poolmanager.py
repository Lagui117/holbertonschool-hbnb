from __future__ import absolute_import

import collections
import functools
import logging

from ._collections import HTTPHeaderDict, RecentlyUsedContainer
from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, port_by_scheme
from .exceptions import (
 #ocationValueError,
 #axRetryError,
 #roxySchemeUnknown,
 #roxySchemeUnsupported,
 #RLSchemeUnknown,
)
from .packages import six
from .packages.six.moves.urllib.parse import urljoin
from .request import RequestMethods
from .util.proxy import connection_requires_http_tunnel
from .util.retry import Retry
from .util.url import parse_url

__all__ = ["PoolManager", "ProxyManager", "proxy_from_url"]


log = logging.getLogger(__name__)

SSL_KEYWORDS = (
 #key_file",
 #cert_file",
 #cert_reqs",
 #ca_certs",
 #ssl_version",
 #ca_cert_dir",
 #ssl_context",
 #key_password",
 #server_hostname",
)

# All known keyword arguments that could be provided to the pool manager, its
# pools, or the underlying connections. This is used to construct a pool key.
_key_fields = (
 #key_scheme",  # str
 #key_host",  # str
 #key_port",  # int
 #key_timeout",  # int or float or Timeout
 #key_retries",  # int or Retry
 #key_strict",  # bool
 #key_block",  # bool
 #key_source_address",  # str
 #key_key_file",  # str
 #key_key_password",  # str
 #key_cert_file",  # str
 #key_cert_reqs",  # str
 #key_ca_certs",  # str
 #key_ssl_version",  # str
 #key_ca_cert_dir",  # str
 #key_ssl_context",  # instance of ssl.SSLContext or urllib3.util.ssl_.SSLContext
 #key_maxsize",  # int
 #key_headers",  # dict
 #key__proxy",  # parsed proxy url
 #key__proxy_headers",  # dict
 #key__proxy_config",  # class
 #key_socket_options",  # list of (level (int), optname (int), value (int or str)) tuples
 #key__socks_options",  # dict
 #key_assert_hostname",  # bool or string
 #key_assert_fingerprint",  # str
 #key_server_hostname",  # str
)

#: The namedtuple class used to construct keys for the connection pool.
#: All custom key schemes should include the fields in this key at a minimum.
PoolKey = collections.namedtuple("PoolKey", _key_fields)

_proxy_config_fields = ("ssl_context", "use_forwarding_for_https")
ProxyConfig = collections.namedtuple("ProxyConfig", _proxy_config_fields)


def _default_key_normalizer(key_class, request_context):
 #""
 #reate a pool key out of a request context dictionary.

 #ccording to RFC 3986, both the scheme and host are case-insensitive.
 #herefore, this function normalizes both before constructing the pool
 #ey for an HTTPS request. If you wish to change this behaviour, provide
 #lternate callables to ``key_fn_by_scheme``.

 #param key_class:
 #he class to use when constructing the key. This should be a namedtuple
 #ith the ``scheme`` and ``host`` keys at a minimum.
 #type  key_class: namedtuple
 #param request_context:
 # dictionary-like object that contain the context for a request.
 #type  request_context: dict

 #return: A namedtuple that can be used as a connection pool key.
 #rtype:  PoolKey
 #""
    # Since we mutate the dictionary, make a copy first
 #ontext = request_context.copy()
 #ontext["scheme"] = context["scheme"].lower()
 #ontext["host"] = context["host"].lower()

    # These are both dictionaries and need to be transformed into frozensets
 #or key in ("headers", "_proxy_headers", "_socks_options"):
 #f key in context and context[key] is not None:
 #ontext[key] = frozenset(context[key].items())

    # The socket_options key may be a list and needs to be transformed into a
    # tuple.
 #ocket_opts = context.get("socket_options")
 #f socket_opts is not None:
 #ontext["socket_options"] = tuple(socket_opts)

    # Map the kwargs to the names in the namedtuple - this is necessary since
    # namedtuples can't have fields starting with '_'.
 #or key in list(context.keys()):
 #ontext["key_" + key] = context.pop(key)

    # Default to ``None`` for keys missing from the context
 #or field in key_class._fields:
 #f field not in context:
 #ontext[field] = None

 #eturn key_class(**context)


#: A dictionary that maps a scheme to a callable that creates a pool key.
#: This can be used to alter the way pool keys are constructed, if desired.
#: Each PoolManager makes a copy of this dictionary so they can be configured
#: globally here, or individually on the instance.
key_fn_by_scheme = {
 #http": functools.partial(_default_key_normalizer, PoolKey),
 #https": functools.partial(_default_key_normalizer, PoolKey),
}

pool_classes_by_scheme = {"http": HTTPConnectionPool, "https": HTTPSConnectionPool}


class PoolManager(RequestMethods):
 #""
 #llows for arbitrary requests while transparently keeping track of
 #ecessary connection pools for you.

 #param num_pools:
 #umber of connection pools to cache before discarding the least
 #ecently used pool.

 #param headers:
 #eaders to include with all requests, unless other headers are given
 #xplicitly.

 #param \\**connection_pool_kw:
 #dditional parameters are used to create fresh
 #class:`urllib3.connectionpool.ConnectionPool` instances.

 #xample::

 #>> manager = PoolManager(num_pools=2)
 #>> r = manager.request('GET', 'http://google.com/')
 #>> r = manager.request('GET', 'http://google.com/mail')
 #>> r = manager.request('GET', 'http://yahoo.com/')
 #>> len(manager.pools)
 #

 #""

 #roxy = None
 #roxy_config = None

 #ef __init__(self, num_pools=10, headers=None, **connection_pool_kw):
 #equestMethods.__init__(self, headers)
 #f "retries" in connection_pool_kw:
 #etries = connection_pool_kw["retries"]
 #f not isinstance(retries, Retry):
                # When Retry is initialized, raise_on_redirect is based
                # on a redirect boolean value.
                # But requests made via a pool manager always set
                # redirect to False, and raise_on_redirect always ends
                # up being False consequently.
                # Here we fix the issue by setting raise_on_redirect to
                # a value needed by the pool manager without considering
                # the redirect boolean.
 #aise_on_redirect = retries is not False
 #etries = Retry.from_int(retries, redirect=False)
 #etries.raise_on_redirect = raise_on_redirect
 #onnection_pool_kw = connection_pool_kw.copy()
 #onnection_pool_kw["retries"] = retries
 #elf.connection_pool_kw = connection_pool_kw
 #elf.pools = RecentlyUsedContainer(num_pools)

        # Locally set the pool classes and keys so other PoolManagers can
        # override them.
 #elf.pool_classes_by_scheme = pool_classes_by_scheme
 #elf.key_fn_by_scheme = key_fn_by_scheme.copy()

 #ef __enter__(self):
 #eturn self

 #ef __exit__(self, exc_type, exc_val, exc_tb):
 #elf.clear()
        # Return False to re-raise any potential exceptions
 #eturn False

 #ef _new_pool(self, scheme, host, port, request_context=None):
 #""
 #reate a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and
 #ny additional pool keyword arguments.

 #f ``request_context`` is provided, it is provided as keyword arguments
 #o the pool class used. This method is used to actually create the
 #onnection pools handed out by :meth:`connection_from_url` and
 #ompanion methods. It is intended to be overridden for customization.
 #""
 #ool_cls = self.pool_classes_by_scheme[scheme]
 #f request_context is None:
 #equest_context = self.connection_pool_kw.copy()

        # Although the context has everything necessary to create the pool,
        # this function has historically only used the scheme, host, and port
        # in the positional args. When an API change is acceptable these can
        # be removed.
 #or key in ("scheme", "host", "port"):
 #equest_context.pop(key, None)

 #f scheme == "http":
 #or kw in SSL_KEYWORDS:
 #equest_context.pop(kw, None)

 #eturn pool_cls(host, port, **request_context)

 #ef clear(self):
 #""
 #mpty our store of pools and direct them all to close.

 #his will not affect in-flight connections, but they will not be
 #e-used after completion.
 #""
 #elf.pools.clear()

 #ef connection_from_host(self, host, port=None, scheme="http", pool_kwargs=None):
 #""
 #et a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.

 #f ``port`` isn't given, it will be derived from the ``scheme`` using
 #`urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is
 #rovided, it is merged with the instance's ``connection_pool_kw``
 #ariable and used to create the new connection pool, if one is
 #eeded.
 #""

 #f not host:
 #aise LocationValueError("No host specified.")

 #equest_context = self._merge_pool_kwargs(pool_kwargs)
 #equest_context["scheme"] = scheme or "http"
 #f not port:
 #ort = port_by_scheme.get(request_context["scheme"].lower(), 80)
 #equest_context["port"] = port
 #equest_context["host"] = host

 #eturn self.connection_from_context(request_context)

 #ef connection_from_context(self, request_context):
 #""
 #et a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.

 #`request_context`` must at least contain the ``scheme`` key and its
 #alue must be a key in ``key_fn_by_scheme`` instance variable.
 #""
 #cheme = request_context["scheme"].lower()
 #ool_key_constructor = self.key_fn_by_scheme.get(scheme)
 #f not pool_key_constructor:
 #aise URLSchemeUnknown(scheme)
 #ool_key = pool_key_constructor(request_context)

 #eturn self.connection_from_pool_key(pool_key, request_context=request_context)

 #ef connection_from_pool_key(self, pool_key, request_context=None):
 #""
 #et a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.

 #`pool_key`` should be a namedtuple that only contains immutable
 #bjects. At a minimum it must have the ``scheme``, ``host``, and
 #`port`` fields.
 #""
 #ith self.pools.lock:
            # If the scheme, host, or port doesn't match existing open
            # connections, open a new ConnectionPool.
 #ool = self.pools.get(pool_key)
 #f pool:
 #eturn pool

            # Make a fresh ConnectionPool of the desired type
 #cheme = request_context["scheme"]
 #ost = request_context["host"]
 #ort = request_context["port"]
 #ool = self._new_pool(scheme, host, port, request_context=request_context)
 #elf.pools[pool_key] = pool

 #eturn pool

 #ef connection_from_url(self, url, pool_kwargs=None):
 #""
 #imilar to :func:`urllib3.connectionpool.connection_from_url`.

 #f ``pool_kwargs`` is not provided and a new pool needs to be
 #onstructed, ``self.connection_pool_kw`` is used to initialize
 #he :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``
 #s provided, it is used instead. Note that if a new pool does not
 #eed to be created for the request, the provided ``pool_kwargs`` are
 #ot used.
 #""
 # = parse_url(url)
 #eturn self.connection_from_host(
 #.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs
 #

 #ef _merge_pool_kwargs(self, override):
 #""
 #erge a dictionary of override values for self.connection_pool_kw.

 #his does not modify self.connection_pool_kw and returns a new dict.
 #ny keys in the override dictionary with a value of ``None`` are
 #emoved from the merged dictionary.
 #""
 #ase_pool_kwargs = self.connection_pool_kw.copy()
 #f override:
 #or key, value in override.items():
 #f value is None:
 #ry:
 #el base_pool_kwargs[key]
 #xcept KeyError:
 #ass
 #lse:
 #ase_pool_kwargs[key] = value
 #eturn base_pool_kwargs

 #ef _proxy_requires_url_absolute_form(self, parsed_url):
 #""
 #ndicates if the proxy requires the complete destination URL in the
 #equest.  Normally this is only needed when not using an HTTP CONNECT
 #unnel.
 #""
 #f self.proxy is None:
 #eturn False

 #eturn not connection_requires_http_tunnel(
 #elf.proxy, self.proxy_config, parsed_url.scheme
 #

 #ef _validate_proxy_scheme_url_selection(self, url_scheme):
 #""
 #alidates that were not attempting to do TLS in TLS connections on
 #ython2 or with unsupported SSL implementations.
 #""
 #f self.proxy is None or url_scheme != "https":
 #eturn

 #f self.proxy.scheme != "https":
 #eturn

 #f six.PY2 and not self.proxy_config.use_forwarding_for_https:
 #aise ProxySchemeUnsupported(
 #Contacting HTTPS destinations through HTTPS proxies "
 #'via CONNECT tunnels' is not supported in Python 2"
 #

 #ef urlopen(self, method, url, redirect=True, **kw):
 #""
 #ame as :meth:`urllib3.HTTPConnectionPool.urlopen`
 #ith custom cross-host redirect logic and only sends the request-uri
 #ortion of the ``url``.

 #he given ``url`` parameter must be absolute, such that an appropriate
 #class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.
 #""
 # = parse_url(url)
 #elf._validate_proxy_scheme_url_selection(u.scheme)

 #onn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)

 #w["assert_same_host"] = False
 #w["redirect"] = False

 #f "headers" not in kw:
 #w["headers"] = self.headers.copy()

 #f self._proxy_requires_url_absolute_form(u):
 #esponse = conn.urlopen(method, url, **kw)
 #lse:
 #esponse = conn.urlopen(method, u.request_uri, **kw)

 #edirect_location = redirect and response.get_redirect_location()
 #f not redirect_location:
 #eturn response

        # Support relative URLs for redirecting.
 #edirect_location = urljoin(url, redirect_location)

 #f response.status == 303:
            # Change the method according to RFC 9110, Section 15.4.4.
 #ethod = "GET"
            # And lose the body not to transfer anything sensitive.
 #w["body"] = None
 #w["headers"] = HTTPHeaderDict(kw["headers"])._prepare_for_method_change()

 #etries = kw.get("retries", response.retries)
 #f not isinstance(retries, Retry):
 #etries = Retry.from_int(retries, redirect=redirect)

        # Strip headers marked as unsafe to forward to the redirected location.
        # Check remove_headers_on_redirect to avoid a potential network call within
        # conn.is_same_host() which may use socket.gethostbyname() in the future.
 #f retries.remove_headers_on_redirect and not conn.is_same_host(
 #edirect_location
 #:
 #eaders = list(six.iterkeys(kw["headers"]))
 #or header in headers:
 #f header.lower() in retries.remove_headers_on_redirect:
 #w["headers"].pop(header, None)

 #ry:
 #etries = retries.increment(method, url, response=response, _pool=conn)
 #xcept MaxRetryError:
 #f retries.raise_on_redirect:
 #esponse.drain_conn()
 #aise
 #eturn response

 #w["retries"] = retries
 #w["redirect"] = redirect

 #og.info("Redirecting %s -> %s", url, redirect_location)

 #esponse.drain_conn()
 #eturn self.urlopen(method, redirect_location, **kw)


class ProxyManager(PoolManager):
 #""
 #ehaves just like :class:`PoolManager`, but sends all requests through
 #he defined proxy, using the CONNECT method for HTTPS URLs.

 #param proxy_url:
 #he URL of the proxy to be used.

 #param proxy_headers:
 # dictionary containing headers that will be sent to the proxy. In case
 #f HTTP they are being sent with each request, while in the
 #TTPS/CONNECT case they are sent only once. Could be used for proxy
 #uthentication.

 #param proxy_ssl_context:
 #he proxy SSL context is used to establish the TLS connection to the
 #roxy when using HTTPS proxies.

 #param use_forwarding_for_https:
 #Defaults to False) If set to True will forward requests to the HTTPS
 #roxy to be made on behalf of the client instead of creating a TLS
 #unnel via the CONNECT method. **Enabling this flag means that request
 #nd response headers and content will be visible from the HTTPS proxy**
 #hereas tunneling keeps request and response headers and content
 #rivate.  IP address, target hostname, SNI, and port are always visible
 #o an HTTPS proxy even when this flag is disabled.

 #xample:
 #>> proxy = urllib3.ProxyManager('http://localhost:3128/')
 #>> r1 = proxy.request('GET', 'http://google.com/')
 #>> r2 = proxy.request('GET', 'http://httpbin.org/')
 #>> len(proxy.pools)
 #
 #>> r3 = proxy.request('GET', 'https://httpbin.org/')
 #>> r4 = proxy.request('GET', 'https://twitter.com/')
 #>> len(proxy.pools)
 #

 #""

 #ef __init__(
 #elf,
 #roxy_url,
 #um_pools=10,
 #eaders=None,
 #roxy_headers=None,
 #roxy_ssl_context=None,
 #se_forwarding_for_https=False,
 #*connection_pool_kw
 #:

 #f isinstance(proxy_url, HTTPConnectionPool):
 #roxy_url = "%s://%s:%i" % (
 #roxy_url.scheme,
 #roxy_url.host,
 #roxy_url.port,
 #
 #roxy = parse_url(proxy_url)

 #f proxy.scheme not in ("http", "https"):
 #aise ProxySchemeUnknown(proxy.scheme)

 #f not proxy.port:
 #ort = port_by_scheme.get(proxy.scheme, 80)
 #roxy = proxy._replace(port=port)

 #elf.proxy = proxy
 #elf.proxy_headers = proxy_headers or {}
 #elf.proxy_ssl_context = proxy_ssl_context
 #elf.proxy_config = ProxyConfig(proxy_ssl_context, use_forwarding_for_https)

 #onnection_pool_kw["_proxy"] = self.proxy
 #onnection_pool_kw["_proxy_headers"] = self.proxy_headers
 #onnection_pool_kw["_proxy_config"] = self.proxy_config

 #uper(ProxyManager, self).__init__(num_pools, headers, **connection_pool_kw)

 #ef connection_from_host(self, host, port=None, scheme="http", pool_kwargs=None):
 #f scheme == "https":
 #eturn super(ProxyManager, self).connection_from_host(
 #ost, port, scheme, pool_kwargs=pool_kwargs
 #

 #eturn super(ProxyManager, self).connection_from_host(
 #elf.proxy.host, self.proxy.port, self.proxy.scheme, pool_kwargs=pool_kwargs
 #

 #ef _set_proxy_headers(self, url, headers=None):
 #""
 #ets headers needed by proxies: specifically, the Accept and Host
 #eaders. Only sets headers not provided by the user.
 #""
 #eaders_ = {"Accept": "*/*"}

 #etloc = parse_url(url).netloc
 #f netloc:
 #eaders_["Host"] = netloc

 #f headers:
 #eaders_.update(headers)
 #eturn headers_

 #ef urlopen(self, method, url, redirect=True, **kw):
 #Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute."
 # = parse_url(url)
 #f not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):
            # For connections using HTTP CONNECT, httplib sets the necessary
            # headers on the CONNECT to the proxy. If we're not using CONNECT,
            # we'll definitely need to set 'Host' at the very least.
 #eaders = kw.get("headers", self.headers)
 #w["headers"] = self._set_proxy_headers(url, headers)

 #eturn super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)


def proxy_from_url(url, **kw):
 #eturn ProxyManager(proxy_url=url, **kw)
