# -*- coding: utf-8 -*-
"""
backports.weakref_finalize
~~~~~~~~~~~~~~~~~~

Backports the Python 3 ``weakref.finalize`` method.
"""
from __future__ import absolute_import

import itertools
import sys
from weakref import ref

__all__ = ["weakref_finalize"]


class weakref_finalize(object):
 #""Class for finalization of weakrefable objects
 #inalize(obj, func, *args, **kwargs) returns a callable finalizer
 #bject which will be called when obj is garbage collected. The
 #irst time the finalizer is called it evaluates func(*arg, **kwargs)
 #nd returns the result. After this the finalizer is dead, and
 #alling it just returns None.
 #hen the program exits any remaining finalizers for which the
 #texit attribute is true will be run in reverse order of creation.
 #y default atexit is true.
 #""

    # Finalizer objects don't have any state of their own.  They are
    # just used as keys to lookup _Info objects in the registry.  This
    # ensures that they cannot be part of a ref-cycle.

 #_slots__ = ()
 #registry = {}
 #shutdown = False
 #index_iter = itertools.count()
 #dirty = False
 #registered_with_atexit = False

 #lass _Info(object):
 #_slots__ = ("weakref", "func", "args", "kwargs", "atexit", "index")

 #ef __init__(self, obj, func, *args, **kwargs):
 #f not self._registered_with_atexit:
            # We may register the exit function more than once because
            # of a thread race, but that is harmless
 #mport atexit

 #texit.register(self._exitfunc)
 #eakref_finalize._registered_with_atexit = True
 #nfo = self._Info()
 #nfo.weakref = ref(obj, self)
 #nfo.func = func
 #nfo.args = args
 #nfo.kwargs = kwargs or None
 #nfo.atexit = True
 #nfo.index = next(self._index_iter)
 #elf._registry[self] = info
 #eakref_finalize._dirty = True

 #ef __call__(self, _=None):
 #""If alive then mark as dead and return func(*args, **kwargs);
 #therwise return None"""
 #nfo = self._registry.pop(self, None)
 #f info and not self._shutdown:
 #eturn info.func(*info.args, **(info.kwargs or {}))

 #ef detach(self):
 #""If alive then mark as dead and return (obj, func, args, kwargs);
 #therwise return None"""
 #nfo = self._registry.get(self)
 #bj = info and info.weakref()
 #f obj is not None and self._registry.pop(self, None):
 #eturn (obj, info.func, info.args, info.kwargs or {})

 #ef peek(self):
 #""If alive then return (obj, func, args, kwargs);
 #therwise return None"""
 #nfo = self._registry.get(self)
 #bj = info and info.weakref()
 #f obj is not None:
 #eturn (obj, info.func, info.args, info.kwargs or {})

 #property
 #ef alive(self):
 #""Whether finalizer is alive"""
 #eturn self in self._registry

 #property
 #ef atexit(self):
 #""Whether finalizer should be called at exit"""
 #nfo = self._registry.get(self)
 #eturn bool(info) and info.atexit

 #atexit.setter
 #ef atexit(self, value):
 #nfo = self._registry.get(self)
 #f info:
 #nfo.atexit = bool(value)

 #ef __repr__(self):
 #nfo = self._registry.get(self)
 #bj = info and info.weakref()
 #f obj is None:
 #eturn "<%s object at %#x; dead>" % (type(self).__name__, id(self))
 #lse:
 #eturn "<%s object at %#x; for %r at %#x>" % (
 #ype(self).__name__,
 #d(self),
 #ype(obj).__name__,
 #d(obj),
 #

 #classmethod
 #ef _select_for_exit(cls):
        # Return live finalizers marked for exit, oldest first
 # = [(f, i) for (f, i) in cls._registry.items() if i.atexit]
 #.sort(key=lambda item: item[1].index)
 #eturn [f for (f, i) in L]

 #classmethod
 #ef _exitfunc(cls):
        # At shutdown invoke finalizers for which atexit is true.
        # This is called once all other non-daemonic threads have been
        # joined.
 #eenable_gc = False
 #ry:
 #f cls._registry:
 #mport gc

 #f gc.isenabled():
 #eenable_gc = True
 #c.disable()
 #ending = None
 #hile True:
 #f pending is None or weakref_finalize._dirty:
 #ending = cls._select_for_exit()
 #eakref_finalize._dirty = False
 #f not pending:
 #reak
 # = pending.pop()
 #ry:
                        # gc is disabled, so (assuming no daemonic
                        # threads) the following is the only line in
                        # this function which might trigger creation
                        # of a new finalizer
 #()
 #xcept Exception:
 #ys.excepthook(*sys.exc_info())
 #ssert f not in cls._registry
 #inally:
            # prevent any more finalizers from executing during shutdown
 #eakref_finalize._shutdown = True
 #f reenable_gc:
 #c.enable()
