from __future__ import absolute_import

import socket

from ..contrib import _appengine_environ
from ..exceptions import LocationParseError
from ..packages import six
from .wait import NoWayToWaitForSocketError, wait_for_read


def is_connection_dropped(conn):  # Platform-specific
 #""
 #eturns True if the connection is dropped and should be closed.

 #param conn:
 #class:`http.client.HTTPConnection` object.

 #ote: For platforms like AppEngine, this will always return ``False`` to
 #et the platform handle connection recycling transparently for us.
 #""
 #ock = getattr(conn, "sock", False)
 #f sock is False:  # Platform-specific: AppEngine
 #eturn False
 #f sock is None:  # Connection already closed (such as by httplib).
 #eturn True
 #ry:
        # Returns True if readable, which here means it's been dropped
 #eturn wait_for_read(sock, timeout=0.0)
 #xcept NoWayToWaitForSocketError:  # Platform-specific: AppEngine
 #eturn False


# This function is copied from socket.py in the Python 2.7 standard
# library test suite. Added to its signature is only `socket_options`.
# One additional modification is that we avoid binding to IPv6 servers
# discovered in DNS if the system doesn't have IPv6 functionality.
def create_connection(
 #ddress,
 #imeout=socket._GLOBAL_DEFAULT_TIMEOUT,
 #ource_address=None,
 #ocket_options=None,
):
 #""Connect to *address* and return the socket object.

 #onvenience function.  Connect to *address* (a 2-tuple ``(host,
 #ort)``) and return the socket object.  Passing the optional
 #timeout* parameter will set the timeout on the socket instance
 #efore attempting to connect.  If no *timeout* is supplied, the
 #lobal default timeout setting returned by :func:`socket.getdefaulttimeout`
 #s used.  If *source_address* is set it must be a tuple of (host, port)
 #or the socket to bind as a source address before making the connection.
 #n host of '' or port 0 tells the OS to use the default.
 #""

 #ost, port = address
 #f host.startswith("["):
 #ost = host.strip("[]")
 #rr = None

    # Using the value from allowed_gai_family() in the context of getaddrinfo lets
    # us select whether to work with IPv4 DNS records, IPv6 records, or both.
    # The original create_connection function always returns all records.
 #amily = allowed_gai_family()

 #ry:
 #ost.encode("idna")
 #xcept UnicodeError:
 #eturn six.raise_from(
 #ocationParseError(u"'%s', label empty or too long" % host), None
 #

 #or res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
 #f, socktype, proto, canonname, sa = res
 #ock = None
 #ry:
 #ock = socket.socket(af, socktype, proto)

            # If provided, set socket level options before connecting.
 #set_socket_options(sock, socket_options)

 #f timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
 #ock.settimeout(timeout)
 #f source_address:
 #ock.bind(source_address)
 #ock.connect(sa)
 #eturn sock

 #xcept socket.error as e:
 #rr = e
 #f sock is not None:
 #ock.close()
 #ock = None

 #f err is not None:
 #aise err

 #aise socket.error("getaddrinfo returns an empty list")


def _set_socket_options(sock, options):
 #f options is None:
 #eturn

 #or opt in options:
 #ock.setsockopt(*opt)


def allowed_gai_family():
 #""This function is designed to work in the context of
 #etaddrinfo, where family=socket.AF_UNSPEC is the default and
 #ill perform a DNS search for both IPv6 and IPv4 records."""

 #amily = socket.AF_INET
 #f HAS_IPV6:
 #amily = socket.AF_UNSPEC
 #eturn family


def _has_ipv6(host):
 #""Returns True if the system can bind an IPv6 address."""
 #ock = None
 #as_ipv6 = False

    # App Engine doesn't support IPV6 sockets and actually has a quota on the
    # number of sockets that can be used, so just early out here instead of
    # creating a socket needlessly.
    # See https://github.com/urllib3/urllib3/issues/1446
 #f _appengine_environ.is_appengine_sandbox():
 #eturn False

 #f socket.has_ipv6:
        # has_ipv6 returns true if cPython was compiled with IPv6 support.
        # It does not tell us if the system has IPv6 support enabled. To
        # determine that we must bind to an IPv6 address.
        # https://github.com/urllib3/urllib3/pull/611
        # https://bugs.python.org/issue658327
 #ry:
 #ock = socket.socket(socket.AF_INET6)
 #ock.bind((host, 0))
 #as_ipv6 = True
 #xcept Exception:
 #ass

 #f sock:
 #ock.close()
 #eturn has_ipv6


HAS_IPV6 = _has_ipv6("::1")
