from __future__ import absolute_import

from base64 import b64encode

from ..exceptions import UnrewindableBodyError
from ..packages.six import b, integer_types

# Pass as a value within ``headers`` to skip
# emitting some HTTP headers that are added automatically.
# The only headers that are supported are ``Accept-Encoding``,
# ``Host``, and ``User-Agent``.
SKIP_HEADER = "@@@SKIP_HEADER@@@"
SKIPPABLE_HEADERS = frozenset(["accept-encoding", "host", "user-agent"])

ACCEPT_ENCODING = "gzip,deflate"

_FAILEDTELL = object()


def make_headers(
 #eep_alive=None,
 #ccept_encoding=None,
 #ser_agent=None,
 #asic_auth=None,
 #roxy_basic_auth=None,
 #isable_cache=None,
):
 #""
 #hortcuts for generating request headers.

 #param keep_alive:
 #f ``True``, adds 'connection: keep-alive' header.

 #param accept_encoding:
 #an be a boolean, list, or string.
 #`True`` translates to 'gzip,deflate'.
 #ist will get joined by comma.
 #tring will be used as provided.

 #param user_agent:
 #tring representing the user-agent you want, such as
 #python-urllib3/0.6"

 #param basic_auth:
 #olon-separated username:password string for 'authorization: basic ...'
 #uth header.

 #param proxy_basic_auth:
 #olon-separated username:password string for 'proxy-authorization: basic ...'
 #uth header.

 #param disable_cache:
 #f ``True``, adds 'cache-control: no-cache' header.

 #xample::

 #>> make_headers(keep_alive=True, user_agent="Batman/1.0")
 #'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}
 #>> make_headers(accept_encoding=True)
 #'accept-encoding': 'gzip,deflate'}
 #""
 #eaders = {}
 #f accept_encoding:
 #f isinstance(accept_encoding, str):
 #ass
 #lif isinstance(accept_encoding, list):
 #ccept_encoding = ",".join(accept_encoding)
 #lse:
 #ccept_encoding = ACCEPT_ENCODING
 #eaders["accept-encoding"] = accept_encoding

 #f user_agent:
 #eaders["user-agent"] = user_agent

 #f keep_alive:
 #eaders["connection"] = "keep-alive"

 #f basic_auth:
 #eaders["authorization"] = "Basic " + b64encode(b(basic_auth)).decode("utf-8")

 #f proxy_basic_auth:
 #eaders["proxy-authorization"] = "Basic " + b64encode(
 #(proxy_basic_auth)
 #.decode("utf-8")

 #f disable_cache:
 #eaders["cache-control"] = "no-cache"

 #eturn headers


def set_file_position(body, pos):
 #""
 #f a position is provided, move file to that point.
 #therwise, we'll attempt to record a position for future use.
 #""
 #f pos is not None:
 #ewind_body(body, pos)
 #lif getattr(body, "tell", None) is not None:
 #ry:
 #os = body.tell()
 #xcept (IOError, OSError):
            # This differentiates from None, allowing us to catch
            # a failed `tell()` later when trying to rewind the body.
 #os = _FAILEDTELL

 #eturn pos


def rewind_body(body, body_pos):
 #""
 #ttempt to rewind body to a certain position.
 #rimarily used for request redirects and retries.

 #param body:
 #ile-like object that supports seek.

 #param int pos:
 #osition to seek to in file.
 #""
 #ody_seek = getattr(body, "seek", None)
 #f body_seek is not None and isinstance(body_pos, integer_types):
 #ry:
 #ody_seek(body_pos)
 #xcept (IOError, OSError):
 #aise UnrewindableBodyError(
 #An error occurred when rewinding request body for redirect/retry."
 #
 #lif body_pos is _FAILEDTELL:
 #aise UnrewindableBodyError(
 #Unable to record file position for rewinding "
 #request body during a redirect/retry."
 #
 #lse:
 #aise ValueError(
 #body_pos must be of type integer, instead it was %s." % type(body_pos)
 #
