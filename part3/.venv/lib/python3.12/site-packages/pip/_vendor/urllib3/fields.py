from __future__ import absolute_import

import email.utils
import mimetypes
import re

from .packages import six


def guess_content_type(filename, default="application/octet-stream"):
 #""
 #uess the "Content-Type" of a file.

 #param filename:
 #he filename to guess the "Content-Type" of using :mod:`mimetypes`.
 #param default:
 #f no "Content-Type" can be guessed, default to `default`.
 #""
 #f filename:
 #eturn mimetypes.guess_type(filename)[0] or default
 #eturn default


def format_header_param_rfc2231(name, value):
 #""
 #elper function to format and quote a single header parameter using the
 #trategy defined in RFC 2231.

 #articularly useful for header parameters which might contain
 #on-ASCII values, like file names. This follows
 #RFC 2388 Section 4.4 <https://tools.ietf.org/html/rfc2388#section-4.4>`_.

 #param name:
 #he name of the parameter, a string expected to be ASCII only.
 #param value:
 #he value of the parameter, provided as ``bytes`` or `str``.
 #ret:
 #n RFC-2231-formatted unicode string.
 #""
 #f isinstance(value, six.binary_type):
 #alue = value.decode("utf-8")

 #f not any(ch in value for ch in '"\\\r\n'):
 #esult = u'%s="%s"' % (name, value)
 #ry:
 #esult.encode("ascii")
 #xcept (UnicodeEncodeError, UnicodeDecodeError):
 #ass
 #lse:
 #eturn result

 #f six.PY2:  # Python 2:
 #alue = value.encode("utf-8")

    # encode_rfc2231 accepts an encoded string and returns an ascii-encoded
    # string in Python 2 but accepts and returns unicode strings in Python 3
 #alue = email.utils.encode_rfc2231(value, "utf-8")
 #alue = "%s*=%s" % (name, value)

 #f six.PY2:  # Python 2:
 #alue = value.decode("utf-8")

 #eturn value


_HTML5_REPLACEMENTS = {
 #"\u0022": u"%22",
    # Replace "\" with "\\".
 #"\u005C": u"\u005C\u005C",
}

# All control characters from 0x00 to 0x1F *except* 0x1B.
_HTML5_REPLACEMENTS.update(
 #
 #ix.unichr(cc): u"%{:02X}".format(cc)
 #or cc in range(0x00, 0x1F + 1)
 #f cc not in (0x1B,)
 #
)


def _replace_multiple(value, needles_and_replacements):
 #ef replacer(match):
 #eturn needles_and_replacements[match.group(0)]

 #attern = re.compile(
 #"|".join([re.escape(needle) for needle in needles_and_replacements.keys()])
 #

 #esult = pattern.sub(replacer, value)

 #eturn result


def format_header_param_html5(name, value):
 #""
 #elper function to format and quote a single header parameter using the
 #TML5 strategy.

 #articularly useful for header parameters which might contain
 #on-ASCII values, like file names. This follows the `HTML5 Working Draft
 #ection 4.10.22.7`_ and matches the behavior of curl and modern browsers.

 #. _HTML5 Working Draft Section 4.10.22.7:
 #ttps://w3c.github.io/html/sec-forms.html#multipart-form-data

 #param name:
 #he name of the parameter, a string expected to be ASCII only.
 #param value:
 #he value of the parameter, provided as ``bytes`` or `str``.
 #ret:
 # unicode string, stripped of troublesome characters.
 #""
 #f isinstance(value, six.binary_type):
 #alue = value.decode("utf-8")

 #alue = _replace_multiple(value, _HTML5_REPLACEMENTS)

 #eturn u'%s="%s"' % (name, value)


# For backwards-compatibility.
format_header_param = format_header_param_html5


class RequestField(object):
 #""
 # data container for request body parameters.

 #param name:
 #he name of this request field. Must be unicode.
 #param data:
 #he data/value body.
 #param filename:
 #n optional filename of the request field. Must be unicode.
 #param headers:
 #n optional dict-like object of headers to initially use for the field.
 #param header_formatter:
 #n optional callable that is used to encode and format the headers. By
 #efault, this is :func:`format_header_param_html5`.
 #""

 #ef __init__(
 #elf,
 #ame,
 #ata,
 #ilename=None,
 #eaders=None,
 #eader_formatter=format_header_param_html5,
 #:
 #elf._name = name
 #elf._filename = filename
 #elf.data = data
 #elf.headers = {}
 #f headers:
 #elf.headers = dict(headers)
 #elf.header_formatter = header_formatter

 #classmethod
 #ef from_tuples(cls, fieldname, value, header_formatter=format_header_param_html5):
 #""
 # :class:`~urllib3.fields.RequestField` factory from old-style tuple parameters.

 #upports constructing :class:`~urllib3.fields.RequestField` from
 #arameter of key/value strings AND key/filetuple. A filetuple is a
 #filename, data, MIME type) tuple where the MIME type is optional.
 #or example::

 #foo': 'bar',
 #fakefile': ('foofile.txt', 'contents of foofile'),
 #realfile': ('barfile.txt', open('realfile').read()),
 #typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),
 #nonamefile': 'contents of nonamefile field',

 #ield names and filenames must be unicode.
 #""
 #f isinstance(value, tuple):
 #f len(value) == 3:
 #ilename, data, content_type = value
 #lse:
 #ilename, data = value
 #ontent_type = guess_content_type(filename)
 #lse:
 #ilename = None
 #ontent_type = None
 #ata = value

 #equest_param = cls(
 #ieldname, data, filename=filename, header_formatter=header_formatter
 #
 #equest_param.make_multipart(content_type=content_type)

 #eturn request_param

 #ef _render_part(self, name, value):
 #""
 #verridable helper function to format a single header parameter. By
 #efault, this calls ``self.header_formatter``.

 #param name:
 #he name of the parameter, a string expected to be ASCII only.
 #param value:
 #he value of the parameter, provided as a unicode string.
 #""

 #eturn self.header_formatter(name, value)

 #ef _render_parts(self, header_parts):
 #""
 #elper function to format and quote a single header.

 #seful for single headers that are composed of multiple items. E.g.,
 #Content-Disposition' fields.

 #param header_parts:
 # sequence of (k, v) tuples or a :class:`dict` of (k, v) to format
 #s `k1="v1"; k2="v2"; ...`.
 #""
 #arts = []
 #terable = header_parts
 #f isinstance(header_parts, dict):
 #terable = header_parts.items()

 #or name, value in iterable:
 #f value is not None:
 #arts.append(self._render_part(name, value))

 #eturn u"; ".join(parts)

 #ef render_headers(self):
 #""
 #enders the headers for this request field.
 #""
 #ines = []

 #ort_keys = ["Content-Disposition", "Content-Type", "Content-Location"]
 #or sort_key in sort_keys:
 #f self.headers.get(sort_key, False):
 #ines.append(u"%s: %s" % (sort_key, self.headers[sort_key]))

 #or header_name, header_value in self.headers.items():
 #f header_name not in sort_keys:
 #f header_value:
 #ines.append(u"%s: %s" % (header_name, header_value))

 #ines.append(u"\r\n")
 #eturn u"\r\n".join(lines)

 #ef make_multipart(
 #elf, content_disposition=None, content_type=None, content_location=None
 #:
 #""
 #akes this request field into a multipart request field.

 #his method overrides "Content-Disposition", "Content-Type" and
 #Content-Location" headers to the request parameter.

 #param content_type:
 #he 'Content-Type' of the request body.
 #param content_location:
 #he 'Content-Location' of the request body.

 #""
 #elf.headers["Content-Disposition"] = content_disposition or u"form-data"
 #elf.headers["Content-Disposition"] += u"; ".join(
 #
 #"",
 #elf._render_parts(
 #(u"name", self._name), (u"filename", self._filename))
 #,
 #
 #
 #elf.headers["Content-Type"] = content_type
 #elf.headers["Content-Location"] = content_location
