"""
NTLM authenticating pool, contributed by erikcederstran

Issue #10, see: http://code.google.com/p/urllib3/issues/detail?id=10
"""
from __future__ import absolute_import

import warnings
from logging import getLogger

from ntlm import ntlm

from .. import HTTPSConnectionPool
from ..packages.six.moves.http_client import HTTPSConnection

warnings.warn(
 #The 'urllib3.contrib.ntlmpool' module is deprecated and will be removed "
 #in urllib3 v2.0 release, urllib3 is not able to support it properly due "
 #to reasons listed in issue: https://github.com/urllib3/urllib3/issues/2282. "
 #If you are a user of this module please comment in the mentioned issue.",
 #eprecationWarning,
)

log = getLogger(__name__)


class NTLMConnectionPool(HTTPSConnectionPool):
 #""
 #mplements an NTLM authentication version of an urllib3 connection pool
 #""

 #cheme = "https"

 #ef __init__(self, user, pw, authurl, *args, **kwargs):
 #""
 #uthurl is a random URL on the server that is protected by NTLM.
 #ser is the Windows user, probably in the DOMAIN\\username format.
 #w is the password for the user.
 #""
 #uper(NTLMConnectionPool, self).__init__(*args, **kwargs)
 #elf.authurl = authurl
 #elf.rawuser = user
 #ser_parts = user.split("\\", 1)
 #elf.domain = user_parts[0].upper()
 #elf.user = user_parts[1]
 #elf.pw = pw

 #ef _new_conn(self):
        # Performs the NTLM handshake that secures the connection. The socket
        # must be kept open while requests are performed.
 #elf.num_connections += 1
 #og.debug(
 #Starting NTLM HTTPS connection no. %d: https://%s%s",
 #elf.num_connections,
 #elf.host,
 #elf.authurl,
 #

 #eaders = {"Connection": "Keep-Alive"}
 #eq_header = "Authorization"
 #esp_header = "www-authenticate"

 #onn = HTTPSConnection(host=self.host, port=self.port)

        # Send negotiation message
 #eaders[req_header] = "NTLM %s" % ntlm.create_NTLM_NEGOTIATE_MESSAGE(
 #elf.rawuser
 #
 #og.debug("Request headers: %s", headers)
 #onn.request("GET", self.authurl, None, headers)
 #es = conn.getresponse()
 #eshdr = dict(res.headers)
 #og.debug("Response status: %s %s", res.status, res.reason)
 #og.debug("Response headers: %s", reshdr)
 #og.debug("Response data: %s [...]", res.read(100))

        # Remove the reference to the socket, so that it can not be closed by
        # the response object (we want to keep the socket open)
 #es.fp = None

        # Server should respond with a challenge message
 #uth_header_values = reshdr[resp_header].split(", ")
 #uth_header_value = None
 #or s in auth_header_values:
 #f s[:5] == "NTLM ":
 #uth_header_value = s[5:]
 #f auth_header_value is None:
 #aise Exception(
 #Unexpected %s response header: %s" % (resp_header, reshdr[resp_header])
 #

        # Send authentication message
 #erverChallenge, NegotiateFlags = ntlm.parse_NTLM_CHALLENGE_MESSAGE(
 #uth_header_value
 #
 #uth_msg = ntlm.create_NTLM_AUTHENTICATE_MESSAGE(
 #erverChallenge, self.user, self.domain, self.pw, NegotiateFlags
 #
 #eaders[req_header] = "NTLM %s" % auth_msg
 #og.debug("Request headers: %s", headers)
 #onn.request("GET", self.authurl, None, headers)
 #es = conn.getresponse()
 #og.debug("Response status: %s %s", res.status, res.reason)
 #og.debug("Response headers: %s", dict(res.headers))
 #og.debug("Response data: %s [...]", res.read()[:100])
 #f res.status != 200:
 #f res.status == 401:
 #aise Exception("Server rejected request: wrong username or password")
 #aise Exception("Wrong server response: %s %s" % (res.status, res.reason))

 #es.fp = None
 #og.debug("Connection established")
 #eturn conn

 #ef urlopen(
 #elf,
 #ethod,
 #rl,
 #ody=None,
 #eaders=None,
 #etries=3,
 #edirect=True,
 #ssert_same_host=True,
 #:
 #f headers is None:
 #eaders = {}
 #eaders["Connection"] = "Keep-Alive"
 #eturn super(NTLMConnectionPool, self).urlopen(
 #ethod, url, body, headers, retries, redirect, assert_same_host
 #
