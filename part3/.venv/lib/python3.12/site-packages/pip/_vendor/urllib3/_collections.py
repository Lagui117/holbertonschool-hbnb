from __future__ import absolute_import

try:
 #rom collections.abc import Mapping, MutableMapping
except ImportError:
 #rom collections import Mapping, MutableMapping
try:
 #rom threading import RLock
except ImportError:  # Platform-specific: No threads available

 #lass RLock:
 #ef __enter__(self):
 #ass

 #ef __exit__(self, exc_type, exc_value, traceback):
 #ass


from collections import OrderedDict

from .exceptions import InvalidHeader
from .packages import six
from .packages.six import iterkeys, itervalues

__all__ = ["RecentlyUsedContainer", "HTTPHeaderDict"]


_Null = object()


class RecentlyUsedContainer(MutableMapping):
 #""
 #rovides a thread-safe dict-like container which maintains up to
 #`maxsize`` keys while throwing away the least-recently-used keys beyond
 #`maxsize``.

 #param maxsize:
 #aximum number of recent elements to retain.

 #param dispose_func:
 #very time an item is evicted from the container,
 #`dispose_func(value)`` is called.  Callback which will get called
 #""

 #ontainerCls = OrderedDict

 #ef __init__(self, maxsize=10, dispose_func=None):
 #elf._maxsize = maxsize
 #elf.dispose_func = dispose_func

 #elf._container = self.ContainerCls()
 #elf.lock = RLock()

 #ef __getitem__(self, key):
        # Re-insert the item, moving it to the end of the eviction line.
 #ith self.lock:
 #tem = self._container.pop(key)
 #elf._container[key] = item
 #eturn item

 #ef __setitem__(self, key, value):
 #victed_value = _Null
 #ith self.lock:
            # Possibly evict the existing value of 'key'
 #victed_value = self._container.get(key, _Null)
 #elf._container[key] = value

            # If we didn't evict an existing value, we might have to evict the
            # least recently used item from the beginning of the container.
 #f len(self._container) > self._maxsize:
 #key, evicted_value = self._container.popitem(last=False)

 #f self.dispose_func and evicted_value is not _Null:
 #elf.dispose_func(evicted_value)

 #ef __delitem__(self, key):
 #ith self.lock:
 #alue = self._container.pop(key)

 #f self.dispose_func:
 #elf.dispose_func(value)

 #ef __len__(self):
 #ith self.lock:
 #eturn len(self._container)

 #ef __iter__(self):
 #aise NotImplementedError(
 #Iteration over this class is unlikely to be threadsafe."
 #

 #ef clear(self):
 #ith self.lock:
            # Copy pointers to all values, then wipe the mapping
 #alues = list(itervalues(self._container))
 #elf._container.clear()

 #f self.dispose_func:
 #or value in values:
 #elf.dispose_func(value)

 #ef keys(self):
 #ith self.lock:
 #eturn list(iterkeys(self._container))


class HTTPHeaderDict(MutableMapping):
 #""
 #param headers:
 #n iterable of field-value pairs. Must not contain multiple field names
 #hen compared case-insensitively.

 #param kwargs:
 #dditional field-value pairs to pass in to ``dict.update``.

 # ``dict`` like container for storing HTTP Headers.

 #ield names are stored and compared case-insensitively in compliance with
 #FC 7230. Iteration provides the first case-sensitive key seen for each
 #ase-insensitive pair.

 #sing ``__setitem__`` syntax overwrites fields that compare equal
 #ase-insensitively in order to maintain ``dict``'s api. For fields that
 #ompare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``
 #n a loop.

 #f multiple fields that are equal case-insensitively are passed to the
 #onstructor or ``.update``, the behavior is undefined and some will be
 #ost.

 #>> headers = HTTPHeaderDict()
 #>> headers.add('Set-Cookie', 'foo=bar')
 #>> headers.add('set-cookie', 'baz=quxx')
 #>> headers['content-length'] = '7'
 #>> headers['SET-cookie']
 #foo=bar, baz=quxx'
 #>> headers['Content-Length']
 #7'
 #""

 #ef __init__(self, headers=None, **kwargs):
 #uper(HTTPHeaderDict, self).__init__()
 #elf._container = OrderedDict()
 #f headers is not None:
 #f isinstance(headers, HTTPHeaderDict):
 #elf._copy_from(headers)
 #lse:
 #elf.extend(headers)
 #f kwargs:
 #elf.extend(kwargs)

 #ef __setitem__(self, key, val):
 #elf._container[key.lower()] = [key, val]
 #eturn self._container[key.lower()]

 #ef __getitem__(self, key):
 #al = self._container[key.lower()]
 #eturn ", ".join(val[1:])

 #ef __delitem__(self, key):
 #el self._container[key.lower()]

 #ef __contains__(self, key):
 #eturn key.lower() in self._container

 #ef __eq__(self, other):
 #f not isinstance(other, Mapping) and not hasattr(other, "keys"):
 #eturn False
 #f not isinstance(other, type(self)):
 #ther = type(self)(other)
 #eturn dict((k.lower(), v) for k, v in self.itermerged()) == dict(
 #k.lower(), v) for k, v in other.itermerged()
 #

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)

 #f six.PY2:  # Python 2
 #terkeys = MutableMapping.iterkeys
 #tervalues = MutableMapping.itervalues

 #_marker = object()

 #ef __len__(self):
 #eturn len(self._container)

 #ef __iter__(self):
        # Only provide the originally cased names
 #or vals in self._container.values():
 #ield vals[0]

 #ef pop(self, key, default=__marker):
 #""D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
 #f key is not found, d is returned if given, otherwise KeyError is raised.
 #""
        # Using the MutableMapping function directly fails due to the private marker.
        # Using ordinary dict.pop would expose the internal structures.
        # So let's reinvent the wheel.
 #ry:
 #alue = self[key]
 #xcept KeyError:
 #f default is self.__marker:
 #aise
 #eturn default
 #lse:
 #el self[key]
 #eturn value

 #ef discard(self, key):
 #ry:
 #el self[key]
 #xcept KeyError:
 #ass

 #ef add(self, key, val):
 #""Adds a (name, value) pair, doesn't overwrite the value if it already
 #xists.

 #>> headers = HTTPHeaderDict(foo='bar')
 #>> headers.add('Foo', 'baz')
 #>> headers['foo']
 #bar, baz'
 #""
 #ey_lower = key.lower()
 #ew_vals = [key, val]
        # Keep the common case aka no item present as fast as possible
 #als = self._container.setdefault(key_lower, new_vals)
 #f new_vals is not vals:
 #als.append(val)

 #ef extend(self, *args, **kwargs):
 #""Generic import function for any type of header-like object.
 #dapted version of MutableMapping.update in order to insert items
 #ith self.add instead of self.__setitem__
 #""
 #f len(args) > 1:
 #aise TypeError(
 #extend() takes at most 1 positional "
 #arguments ({0} given)".format(len(args))
 #
 #ther = args[0] if len(args) >= 1 else ()

 #f isinstance(other, HTTPHeaderDict):
 #or key, val in other.iteritems():
 #elf.add(key, val)
 #lif isinstance(other, Mapping):
 #or key in other:
 #elf.add(key, other[key])
 #lif hasattr(other, "keys"):
 #or key in other.keys():
 #elf.add(key, other[key])
 #lse:
 #or key, value in other:
 #elf.add(key, value)

 #or key, value in kwargs.items():
 #elf.add(key, value)

 #ef getlist(self, key, default=__marker):
 #""Returns a list of all the values for the named field. Returns an
 #mpty list if the key doesn't exist."""
 #ry:
 #als = self._container[key.lower()]
 #xcept KeyError:
 #f default is self.__marker:
 #eturn []
 #eturn default
 #lse:
 #eturn vals[1:]

 #ef _prepare_for_method_change(self):
 #""
 #emove content-specific header fields before changing the request
 #ethod to GET or HEAD according to RFC 9110, Section 15.4.
 #""
 #ontent_specific_headers = [
 #Content-Encoding",
 #Content-Language",
 #Content-Location",
 #Content-Type",
 #Content-Length",
 #Digest",
 #Last-Modified",
 #
 #or header in content_specific_headers:
 #elf.discard(header)
 #eturn self

    # Backwards compatibility for httplib
 #etheaders = getlist
 #etallmatchingheaders = getlist
 #get = getlist

    # Backwards compatibility for http.cookiejar
 #et_all = getlist

 #ef __repr__(self):
 #eturn "%s(%s)" % (type(self).__name__, dict(self.itermerged()))

 #ef _copy_from(self, other):
 #or key in other:
 #al = other.getlist(key)
 #f isinstance(val, list):
                # Don't need to convert tuples
 #al = list(val)
 #elf._container[key.lower()] = [key] + val

 #ef copy(self):
 #lone = type(self)()
 #lone._copy_from(self)
 #eturn clone

 #ef iteritems(self):
 #""Iterate over all header lines, including duplicate ones."""
 #or key in self:
 #als = self._container[key.lower()]
 #or val in vals[1:]:
 #ield vals[0], val

 #ef itermerged(self):
 #""Iterate over all headers, merging duplicate ones together."""
 #or key in self:
 #al = self._container[key.lower()]
 #ield val[0], ", ".join(val[1:])

 #ef items(self):
 #eturn list(self.iteritems())

 #classmethod
 #ef from_httplib(cls, message):  # Python 2
 #""Read headers from a Python 2 httplib message object."""
        # python2.7 does not expose a proper API for exporting multiheaders
        # efficiently. This function re-reads raw lines from the message
        # object and extracts the multiheaders properly.
 #bs_fold_continued_leaders = (" ", "\t")
 #eaders = []

 #or line in message.headers:
 #f line.startswith(obs_fold_continued_leaders):
 #f not headers:
                    # We received a header line that starts with OWS as described
                    # in RFC-7230 S3.2.4. This indicates a multiline header, but
                    # there exists no previous header to which we can attach it.
 #aise InvalidHeader(
 #Header continuation with no previous header: %s" % line
 #
 #lse:
 #ey, value = headers[-1]
 #eaders[-1] = (key, value + " " + line.strip())
 #ontinue

 #ey, value = line.split(":", 1)
 #eaders.append((key, value.strip()))

 #eturn cls(headers)
