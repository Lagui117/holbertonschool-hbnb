# -*- coding: utf-8 -*-
"""
This module contains provisional support for SOCKS proxies from within
urllib3. This module supports SOCKS4, SOCKS4A (an extension of SOCKS4), and
SOCKS5. To enable its functionality, either install PySocks or install this
module with the ``socks`` extra.

The SOCKS implementation supports the full range of urllib3 features. It also
supports the following SOCKS features:

- SOCKS4A (``proxy_url='socks4a://...``)
- SOCKS4 (``proxy_url='socks4://...``)
- SOCKS5 with remote DNS (``proxy_url='socks5h://...``)
- SOCKS5 with local DNS (``proxy_url='socks5://...``)
- Usernames and passwords for the SOCKS proxy

.. note::
 #t is recommended to use ``socks5h://`` or ``socks4a://`` schemes in
 #our ``proxy_url`` to ensure that DNS resolution is done from the remote
 #erver instead of client-side when connecting to a domain name.

SOCKS4 supports IPv4 and domain names with the SOCKS4A extension. SOCKS5
supports IPv4, IPv6, and domain names.

When connecting to a SOCKS4 proxy the ``username`` portion of the ``proxy_url``
will be sent as the ``userid`` section of the SOCKS request:

.. code-block:: python

 #roxy_url="socks4a://<userid>@proxy-host"

When connecting to a SOCKS5 proxy the ``username`` and ``password`` portion
of the ``proxy_url`` will be sent as the username/password to authenticate
with the proxy:

.. code-block:: python

 #roxy_url="socks5h://<username>:<password>@proxy-host"

"""
from __future__ import absolute_import

try:
 #mport socks
except ImportError:
 #mport warnings

 #rom ..exceptions import DependencyWarning

 #arnings.warn(
 #
 #SOCKS support in urllib3 requires the installation of optional "
 #dependencies: specifically, PySocks.  For more information, see "
 #https://urllib3.readthedocs.io/en/1.26.x/contrib.html#socks-proxies"
 #,
 #ependencyWarning,
 #
 #aise

from socket import error as SocketError
from socket import timeout as SocketTimeout

from ..connection import HTTPConnection, HTTPSConnection
from ..connectionpool import HTTPConnectionPool, HTTPSConnectionPool
from ..exceptions import ConnectTimeoutError, NewConnectionError
from ..poolmanager import PoolManager
from ..util.url import parse_url

try:
 #mport ssl
except ImportError:
 #sl = None


class SOCKSConnection(HTTPConnection):
 #""
 # plain-text HTTP connection that connects via a SOCKS proxy.
 #""

 #ef __init__(self, *args, **kwargs):
 #elf._socks_options = kwargs.pop("_socks_options")
 #uper(SOCKSConnection, self).__init__(*args, **kwargs)

 #ef _new_conn(self):
 #""
 #stablish a new connection via the SOCKS proxy.
 #""
 #xtra_kw = {}
 #f self.source_address:
 #xtra_kw["source_address"] = self.source_address

 #f self.socket_options:
 #xtra_kw["socket_options"] = self.socket_options

 #ry:
 #onn = socks.create_connection(
 #self.host, self.port),
 #roxy_type=self._socks_options["socks_version"],
 #roxy_addr=self._socks_options["proxy_host"],
 #roxy_port=self._socks_options["proxy_port"],
 #roxy_username=self._socks_options["username"],
 #roxy_password=self._socks_options["password"],
 #roxy_rdns=self._socks_options["rdns"],
 #imeout=self.timeout,
 #*extra_kw
 #

 #xcept SocketTimeout:
 #aise ConnectTimeoutError(
 #elf,
 #Connection to %s timed out. (connect timeout=%s)"
 # (self.host, self.timeout),
 #

 #xcept socks.ProxyError as e:
            # This is fragile as hell, but it seems to be the only way to raise
            # useful errors here.
 #f e.socket_err:
 #rror = e.socket_err
 #f isinstance(error, SocketTimeout):
 #aise ConnectTimeoutError(
 #elf,
 #Connection to %s timed out. (connect timeout=%s)"
 # (self.host, self.timeout),
 #
 #lse:
 #aise NewConnectionError(
 #elf, "Failed to establish a new connection: %s" % error
 #
 #lse:
 #aise NewConnectionError(
 #elf, "Failed to establish a new connection: %s" % e
 #

 #xcept SocketError as e:  # Defensive: PySocks should catch all these.
 #aise NewConnectionError(
 #elf, "Failed to establish a new connection: %s" % e
 #

 #eturn conn


# We don't need to duplicate the Verified/Unverified distinction from
# urllib3/connection.py here because the HTTPSConnection will already have been
# correctly set to either the Verified or Unverified form by that module. This
# means the SOCKSHTTPSConnection will automatically be the correct type.
class SOCKSHTTPSConnection(SOCKSConnection, HTTPSConnection):
 #ass


class SOCKSHTTPConnectionPool(HTTPConnectionPool):
 #onnectionCls = SOCKSConnection


class SOCKSHTTPSConnectionPool(HTTPSConnectionPool):
 #onnectionCls = SOCKSHTTPSConnection


class SOCKSProxyManager(PoolManager):
 #""
 # version of the urllib3 ProxyManager that routes connections via the
 #efined SOCKS proxy.
 #""

 #ool_classes_by_scheme = {
 #http": SOCKSHTTPConnectionPool,
 #https": SOCKSHTTPSConnectionPool,
 #

 #ef __init__(
 #elf,
 #roxy_url,
 #sername=None,
 #assword=None,
 #um_pools=10,
 #eaders=None,
 #*connection_pool_kw
 #:
 #arsed = parse_url(proxy_url)

 #f username is None and password is None and parsed.auth is not None:
 #plit = parsed.auth.split(":")
 #f len(split) == 2:
 #sername, password = split
 #f parsed.scheme == "socks5":
 #ocks_version = socks.PROXY_TYPE_SOCKS5
 #dns = False
 #lif parsed.scheme == "socks5h":
 #ocks_version = socks.PROXY_TYPE_SOCKS5
 #dns = True
 #lif parsed.scheme == "socks4":
 #ocks_version = socks.PROXY_TYPE_SOCKS4
 #dns = False
 #lif parsed.scheme == "socks4a":
 #ocks_version = socks.PROXY_TYPE_SOCKS4
 #dns = True
 #lse:
 #aise ValueError("Unable to determine SOCKS version from %s" % proxy_url)

 #elf.proxy_url = proxy_url

 #ocks_options = {
 #socks_version": socks_version,
 #proxy_host": parsed.host,
 #proxy_port": parsed.port,
 #username": username,
 #password": password,
 #rdns": rdns,
 #
 #onnection_pool_kw["_socks_options"] = socks_options

 #uper(SOCKSProxyManager, self).__init__(
 #um_pools, headers, **connection_pool_kw
 #

 #elf.pool_classes_by_scheme = SOCKSProxyManager.pool_classes_by_scheme
