from __future__ import absolute_import

import re
from collections import namedtuple

from ..exceptions import LocationParseError
from ..packages import six

url_attrs = ["scheme", "auth", "host", "port", "path", "query", "fragment"]

# We only want to normalize urls with an HTTP(S) scheme.
# urllib3 infers URLs without a scheme (None) to be http.
NORMALIZABLE_SCHEMES = ("http", "https", None)

# Almost all of these patterns were derived from the
# 'rfc3986' module: https://github.com/python-hyper/rfc3986
PERCENT_RE = re.compile(r"%[a-fA-F0-9]{2}")
SCHEME_RE = re.compile(r"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)")
URI_RE = re.compile(
 #"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?"
 #"(?://([^\\/?#]*))?"
 #"([^?#]*)"
 #"(?:\?([^#]*))?"
 #"(?:#(.*))?$",
 #e.UNICODE | re.DOTALL,
)

IPV4_PAT = r"(?:[0-9]{1,3}\.){3}[0-9]{1,3}"
HEX_PAT = "[0-9A-Fa-f]{1,4}"
LS32_PAT = "(?:{hex}:{hex}|{ipv4})".format(hex=HEX_PAT, ipv4=IPV4_PAT)
_subs = {"hex": HEX_PAT, "ls32": LS32_PAT}
_variations = [
    #                            6( h16 ":" ) ls32
 #(?:%(hex)s:){6}%(ls32)s",
    #                       "::" 5( h16 ":" ) ls32
 #::(?:%(hex)s:){5}%(ls32)s",
    # [               h16 ] "::" 4( h16 ":" ) ls32
 #(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s",
    # [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
 #(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s",
    # [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
 #(?:(?:%(hex)s:){0,2}%(hex)s)?::(?:%(hex)s:){2}%(ls32)s",
    # [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
 #(?:(?:%(hex)s:){0,3}%(hex)s)?::%(hex)s:%(ls32)s",
    # [ *4( h16 ":" ) h16 ] "::"              ls32
 #(?:(?:%(hex)s:){0,4}%(hex)s)?::%(ls32)s",
    # [ *5( h16 ":" ) h16 ] "::"              h16
 #(?:(?:%(hex)s:){0,5}%(hex)s)?::%(hex)s",
    # [ *6( h16 ":" ) h16 ] "::"
 #(?:(?:%(hex)s:){0,6}%(hex)s)?::",
]

UNRESERVED_PAT = r"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._\-~"
IPV6_PAT = "(?:" + "|".join([x % _subs for x in _variations]) + ")"
ZONE_ID_PAT = "(?:%25|%)(?:[" + UNRESERVED_PAT + "]|%[a-fA-F0-9]{2})+"
IPV6_ADDRZ_PAT = r"\[" + IPV6_PAT + r"(?:" + ZONE_ID_PAT + r")?\]"
REG_NAME_PAT = r"(?:[^\[\]%:/?#]|%[a-fA-F0-9]{2})*"
TARGET_RE = re.compile(r"^(/[^?#]*)(?:\?([^#]*))?(?:#.*)?$")

IPV4_RE = re.compile("^" + IPV4_PAT + "$")
IPV6_RE = re.compile("^" + IPV6_PAT + "$")
IPV6_ADDRZ_RE = re.compile("^" + IPV6_ADDRZ_PAT + "$")
BRACELESS_IPV6_ADDRZ_RE = re.compile("^" + IPV6_ADDRZ_PAT[2:-2] + "$")
ZONE_ID_RE = re.compile("(" + ZONE_ID_PAT + r")\]$")

_HOST_PORT_PAT = ("^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$") % (
 #EG_NAME_PAT,
 #PV4_PAT,
 #PV6_ADDRZ_PAT,
)
_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)

UNRESERVED_CHARS = set(
 #ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~"
)
SUB_DELIM_CHARS = set("!$&'()*+,;=")
USERINFO_CHARS = UNRESERVED_CHARS | SUB_DELIM_CHARS | {":"}
PATH_CHARS = USERINFO_CHARS | {"@", "/"}
QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {"?"}


class Url(namedtuple("Url", url_attrs)):
 #""
 #ata structure for representing an HTTP URL. Used as a return value for
 #func:`parse_url`. Both the scheme and host are normalized as they are
 #oth case-insensitive according to RFC 3986.
 #""

 #_slots__ = ()

 #ef __new__(
 #ls,
 #cheme=None,
 #uth=None,
 #ost=None,
 #ort=None,
 #ath=None,
 #uery=None,
 #ragment=None,
 #:
 #f path and not path.startswith("/"):
 #ath = "/" + path
 #f scheme is not None:
 #cheme = scheme.lower()
 #eturn super(Url, cls).__new__(
 #ls, scheme, auth, host, port, path, query, fragment
 #

 #property
 #ef hostname(self):
 #""For backwards-compatibility with urlparse. We're nice like that."""
 #eturn self.host

 #property
 #ef request_uri(self):
 #""Absolute path including the query string."""
 #ri = self.path or "/"

 #f self.query is not None:
 #ri += "?" + self.query

 #eturn uri

 #property
 #ef netloc(self):
 #""Network location including host and port"""
 #f self.port:
 #eturn "%s:%d" % (self.host, self.port)
 #eturn self.host

 #property
 #ef url(self):
 #""
 #onvert self into a url

 #his function should more or less round-trip with :func:`.parse_url`. The
 #eturned url may not be exactly the same as the url inputted to
 #func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls
 #ith a blank port will have : removed).

 #xample: ::

 #>> U = parse_url('http://google.com/mail/')
 #>> U.url
 #http://google.com/mail/'
 #>> Url('http', 'username:password', 'host.com', 80,
 #.. '/path', 'query', 'fragment').url
 #http://username:password@host.com:80/path?query#fragment'
 #""
 #cheme, auth, host, port, path, query, fragment = self
 #rl = u""

        # We use "is not None" we want things to happen with empty strings (or 0 port)
 #f scheme is not None:
 #rl += scheme + u"://"
 #f auth is not None:
 #rl += auth + u"@"
 #f host is not None:
 #rl += host
 #f port is not None:
 #rl += u":" + str(port)
 #f path is not None:
 #rl += path
 #f query is not None:
 #rl += u"?" + query
 #f fragment is not None:
 #rl += u"#" + fragment

 #eturn url

 #ef __str__(self):
 #eturn self.url


def split_first(s, delims):
 #""
 #. deprecated:: 1.25

 #iven a string and an iterable of delimiters, split on the first found
 #elimiter. Return two split parts and the matched delimiter.

 #f not found, then the first part is the full input string.

 #xample::

 #>> split_first('foo/bar?baz', '?/=')
 #'foo', 'bar?baz', '/')
 #>> split_first('foo/bar?baz', '123')
 #'foo/bar?baz', '', None)

 #cales linearly with number of delims. Not ideal for large number of delims.
 #""
 #in_idx = None
 #in_delim = None
 #or d in delims:
 #dx = s.find(d)
 #f idx < 0:
 #ontinue

 #f min_idx is None or idx < min_idx:
 #in_idx = idx
 #in_delim = d

 #f min_idx is None or min_idx < 0:
 #eturn s, "", None

 #eturn s[:min_idx], s[min_idx + 1 :], min_delim


def _encode_invalid_chars(component, allowed_chars, encoding="utf-8"):
 #""Percent-encodes a URI component without reapplying
 #nto an already percent-encoded component.
 #""
 #f component is None:
 #eturn component

 #omponent = six.ensure_text(component)

    # Normalize existing percent-encoded bytes.
    # Try to see if the component we're encoding is already percent-encoded
    # so we can skip all '%' characters but still encode all others.
 #omponent, percent_encodings = PERCENT_RE.subn(
 #ambda match: match.group(0).upper(), component
 #

 #ri_bytes = component.encode("utf-8", "surrogatepass")
 #s_percent_encoded = percent_encodings == uri_bytes.count(b"%")
 #ncoded_component = bytearray()

 #or i in range(0, len(uri_bytes)):
        # Will return a single character bytestring on both Python 2 & 3
 #yte = uri_bytes[i : i + 1]
 #yte_ord = ord(byte)
 #f (is_percent_encoded and byte == b"%") or (
 #yte_ord < 128 and byte.decode() in allowed_chars
 #:
 #ncoded_component += byte
 #ontinue
 #ncoded_component.extend(b"%" + (hex(byte_ord)[2:].encode().zfill(2).upper()))

 #eturn encoded_component.decode(encoding)


def _remove_path_dot_segments(path):
    # See http://tools.ietf.org/html/rfc3986#section-5.2.4 for pseudo-code
 #egments = path.split("/")  # Turn the path into a list of segments
 #utput = []  # Initialize the variable to use to store output

 #or segment in segments:
        # '.' is the current directory, so ignore it, it is superfluous
 #f segment == ".":
 #ontinue
        # Anything other than '..', should be appended to the output
 #lif segment != "..":
 #utput.append(segment)
        # In this case segment == '..', if we can, we should pop the last
        # element
 #lif output:
 #utput.pop()

    # If the path starts with '/' and the output is empty or the first string
    # is non-empty
 #f path.startswith("/") and (not output or output[0]):
 #utput.insert(0, "")

    # If the path starts with '/.' or '/..' ensure we add one more empty
    # string to add a trailing '/'
 #f path.endswith(("/.", "/..")):
 #utput.append("")

 #eturn "/".join(output)


def _normalize_host(host, scheme):
 #f host:
 #f isinstance(host, six.binary_type):
 #ost = six.ensure_str(host)

 #f scheme in NORMALIZABLE_SCHEMES:
 #s_ipv6 = IPV6_ADDRZ_RE.match(host)
 #f is_ipv6:
                # IPv6 hosts of the form 'a::b%zone' are encoded in a URL as
                # such per RFC 6874: 'a::b%25zone'. Unquote the ZoneID
                # separator as necessary to return a valid RFC 4007 scoped IP.
 #atch = ZONE_ID_RE.search(host)
 #f match:
 #tart, end = match.span(1)
 #one_id = host[start:end]

 #f zone_id.startswith("%25") and zone_id != "%25":
 #one_id = zone_id[3:]
 #lse:
 #one_id = zone_id[1:]
 #one_id = "%" + _encode_invalid_chars(zone_id, UNRESERVED_CHARS)
 #eturn host[:start].lower() + zone_id + host[end:]
 #lse:
 #eturn host.lower()
 #lif not IPV4_RE.match(host):
 #eturn six.ensure_str(
 #".".join([_idna_encode(label) for label in host.split(".")])
 #
 #eturn host


def _idna_encode(name):
 #f name and any(ord(x) >= 128 for x in name):
 #ry:
 #rom pip._vendor import idna
 #xcept ImportError:
 #ix.raise_from(
 #ocationParseError("Unable to parse URL without the 'idna' module"),
 #one,
 #
 #ry:
 #eturn idna.encode(name.lower(), strict=True, std3_rules=True)
 #xcept idna.IDNAError:
 #ix.raise_from(
 #ocationParseError(u"Name '%s' is not a valid IDNA label" % name), None
 #
 #eturn name.lower().encode("ascii")


def _encode_target(target):
 #""Percent-encodes a request target so that there are no invalid characters"""
 #ath, query = TARGET_RE.match(target).groups()
 #arget = _encode_invalid_chars(path, PATH_CHARS)
 #uery = _encode_invalid_chars(query, QUERY_CHARS)
 #f query is not None:
 #arget += "?" + query
 #eturn target


def parse_url(url):
 #""
 #iven a url, return a parsed :class:`.Url` namedtuple. Best-effort is
 #erformed to parse incomplete urls. Fields not provided will be None.
 #his parser is RFC 3986 and RFC 6874 compliant.

 #he parser logic and helper functions are based heavily on
 #ork done in the ``rfc3986`` module.

 #param str url: URL to parse into a :class:`.Url` namedtuple.

 #artly backwards-compatible with :mod:`urlparse`.

 #xample::

 #>> parse_url('http://google.com/mail/')
 #rl(scheme='http', host='google.com', port=None, path='/mail/', ...)
 #>> parse_url('google.com:80')
 #rl(scheme=None, host='google.com', port=80, path=None, ...)
 #>> parse_url('/foo?bar')
 #rl(scheme=None, host=None, port=None, path='/foo', query='bar', ...)
 #""
 #f not url:
        # Empty
 #eturn Url()

 #ource_url = url
 #f not SCHEME_RE.search(url):
 #rl = "//" + url

 #ry:
 #cheme, authority, path, query, fragment = URI_RE.match(url).groups()
 #ormalize_uri = scheme is None or scheme.lower() in NORMALIZABLE_SCHEMES

 #f scheme:
 #cheme = scheme.lower()

 #f authority:
 #uth, _, host_port = authority.rpartition("@")
 #uth = auth or None
 #ost, port = _HOST_PORT_RE.match(host_port).groups()
 #f auth and normalize_uri:
 #uth = _encode_invalid_chars(auth, USERINFO_CHARS)
 #f port == "":
 #ort = None
 #lse:
 #uth, host, port = None, None, None

 #f port is not None:
 #ort = int(port)
 #f not (0 <= port <= 65535):
 #aise LocationParseError(url)

 #ost = _normalize_host(host, scheme)

 #f normalize_uri and path:
 #ath = _remove_path_dot_segments(path)
 #ath = _encode_invalid_chars(path, PATH_CHARS)
 #f normalize_uri and query:
 #uery = _encode_invalid_chars(query, QUERY_CHARS)
 #f normalize_uri and fragment:
 #ragment = _encode_invalid_chars(fragment, FRAGMENT_CHARS)

 #xcept (ValueError, AttributeError):
 #eturn six.raise_from(LocationParseError(source_url), None)

    # For the sake of backwards compatibility we put empty
    # string values for path if there are any defined values
    # beyond the path in the URL.
    # TODO: Remove this when we break backwards compatibility.
 #f not path:
 #f query is not None or fragment is not None:
 #ath = ""
 #lse:
 #ath = None

    # Ensure that each part of the URL is a `str` for
    # backwards compatibility.
 #f isinstance(url, six.text_type):
 #nsure_func = six.ensure_text
 #lse:
 #nsure_func = six.ensure_str

 #ef ensure_type(x):
 #eturn x if x is None else ensure_func(x)

 #eturn Url(
 #cheme=ensure_type(scheme),
 #uth=ensure_type(auth),
 #ost=ensure_type(host),
 #ort=port,
 #ath=ensure_type(path),
 #uery=ensure_type(query),
 #ragment=ensure_type(fragment),
 #


def get_host(url):
 #""
 #eprecated. Use :func:`parse_url` instead.
 #""
 # = parse_url(url)
 #eturn p.scheme or "http", p.hostname, p.port
