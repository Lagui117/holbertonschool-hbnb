from __future__ import absolute_import

import hmac
import os
import sys
import warnings
from binascii import hexlify, unhexlify
from hashlib import md5, sha1, sha256

from ..exceptions import (
 #nsecurePlatformWarning,
 #roxySchemeUnsupported,
 #NIMissingWarning,
 #SLError,
)
from ..packages import six
from .url import BRACELESS_IPV6_ADDRZ_RE, IPV4_RE

SSLContext = None
SSLTransport = None
HAS_SNI = False
IS_PYOPENSSL = False
IS_SECURETRANSPORT = False
ALPN_PROTOCOLS = ["http/1.1"]

# Maps the length of a digest to a possible hash function producing this digest
HASHFUNC_MAP = {32: md5, 40: sha1, 64: sha256}


def _const_compare_digest_backport(a, b):
 #""
 #ompare two digests of equal length in constant time.

 #he digests must be of type str/bytes.
 #eturns True if the digests match, and False otherwise.
 #""
 #esult = abs(len(a) - len(b))
 #or left, right in zip(bytearray(a), bytearray(b)):
 #esult |= left ^ right
 #eturn result == 0


_const_compare_digest = getattr(hmac, "compare_digest", _const_compare_digest_backport)

try:  # Test for SSL features
 #mport ssl
 #rom ssl import CERT_REQUIRED, wrap_socket
except ImportError:
 #ass

try:
 #rom ssl import HAS_SNI  # Has SNI?
except ImportError:
 #ass

try:
 #rom .ssltransport import SSLTransport
except ImportError:
 #ass


try:  # Platform-specific: Python 3.6
 #rom ssl import PROTOCOL_TLS

 #ROTOCOL_SSLv23 = PROTOCOL_TLS
except ImportError:
 #ry:
 #rom ssl import PROTOCOL_SSLv23 as PROTOCOL_TLS

 #ROTOCOL_SSLv23 = PROTOCOL_TLS
 #xcept ImportError:
 #ROTOCOL_SSLv23 = PROTOCOL_TLS = 2

try:
 #rom ssl import PROTOCOL_TLS_CLIENT
except ImportError:
 #ROTOCOL_TLS_CLIENT = PROTOCOL_TLS


try:
 #rom ssl import OP_NO_COMPRESSION, OP_NO_SSLv2, OP_NO_SSLv3
except ImportError:
 #P_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000
 #P_NO_COMPRESSION = 0x20000


try:  # OP_NO_TICKET was added in Python 3.6
 #rom ssl import OP_NO_TICKET
except ImportError:
 #P_NO_TICKET = 0x4000


# A secure default.
# Sources for more information on TLS ciphers:
#
# - https://wiki.mozilla.org/Security/Server_Side_TLS
# - https://www.ssllabs.com/projects/best-practices/index.html
# - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
#
# The general intent is:
# - prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),
# - prefer ECDHE over DHE for better performance,
# - prefer any AES-GCM and ChaCha20 over any AES-CBC for better performance and
#   security,
# - prefer AES-GCM over ChaCha20 because hardware-accelerated AES is common,
# - disable NULL authentication, MD5 MACs, DSS, and other
#   insecure ciphers for security reasons.
# - NOTE: TLS 1.3 cipher suites are managed through a different interface
#   not exposed by CPython (yet!) and are enabled by default if they're available.
DEFAULT_CIPHERS = ":".join(
 #
 #ECDHE+AESGCM",
 #ECDHE+CHACHA20",
 #DHE+AESGCM",
 #DHE+CHACHA20",
 #ECDH+AESGCM",
 #DH+AESGCM",
 #ECDH+AES",
 #DH+AES",
 #RSA+AESGCM",
 #RSA+AES",
 #!aNULL",
 #!eNULL",
 #!MD5",
 #!DSS",
 #
)

try:
 #rom ssl import SSLContext  # Modern SSL?
except ImportError:

 #lass SSLContext(object):  # Platform-specific: Python 2
 #ef __init__(self, protocol_version):
 #elf.protocol = protocol_version
            # Use default values from a real SSLContext
 #elf.check_hostname = False
 #elf.verify_mode = ssl.CERT_NONE
 #elf.ca_certs = None
 #elf.options = 0
 #elf.certfile = None
 #elf.keyfile = None
 #elf.ciphers = None

 #ef load_cert_chain(self, certfile, keyfile):
 #elf.certfile = certfile
 #elf.keyfile = keyfile

 #ef load_verify_locations(self, cafile=None, capath=None, cadata=None):
 #elf.ca_certs = cafile

 #f capath is not None:
 #aise SSLError("CA directories not supported in older Pythons")

 #f cadata is not None:
 #aise SSLError("CA data not supported in older Pythons")

 #ef set_ciphers(self, cipher_suite):
 #elf.ciphers = cipher_suite

 #ef wrap_socket(self, socket, server_hostname=None, server_side=False):
 #arnings.warn(
 #A true SSLContext object is not available. This prevents "
 #urllib3 from configuring SSL appropriately and may cause "
 #certain SSL connections to fail. You can upgrade to a newer "
 #version of Python to solve this. For more information, see "
 #https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html"
 ##ssl-warnings",
 #nsecurePlatformWarning,
 #
 #wargs = {
 #keyfile": self.keyfile,
 #certfile": self.certfile,
 #ca_certs": self.ca_certs,
 #cert_reqs": self.verify_mode,
 #ssl_version": self.protocol,
 #server_side": server_side,
 #
 #eturn wrap_socket(socket, ciphers=self.ciphers, **kwargs)


def assert_fingerprint(cert, fingerprint):
 #""
 #hecks if given fingerprint matches the supplied certificate.

 #param cert:
 #ertificate as bytes object.
 #param fingerprint:
 #ingerprint as string of hexdigits, can be interspersed by colons.
 #""

 #ingerprint = fingerprint.replace(":", "").lower()
 #igest_length = len(fingerprint)
 #ashfunc = HASHFUNC_MAP.get(digest_length)
 #f not hashfunc:
 #aise SSLError("Fingerprint of invalid length: {0}".format(fingerprint))

    # We need encode() here for py32; works on py2 and p33.
 #ingerprint_bytes = unhexlify(fingerprint.encode())

 #ert_digest = hashfunc(cert).digest()

 #f not _const_compare_digest(cert_digest, fingerprint_bytes):
 #aise SSLError(
 #Fingerprints did not match. Expected "{0}", got "{1}".'.format(
 #ingerprint, hexlify(cert_digest)
 #
 #


def resolve_cert_reqs(candidate):
 #""
 #esolves the argument to a numeric constant, which can be passed to
 #he wrap_socket function/method from the ssl module.
 #efaults to :data:`ssl.CERT_REQUIRED`.
 #f given a string it is assumed to be the name of the constant in the
 #mod:`ssl` module or its abbreviation.
 #So you can specify `REQUIRED` instead of `CERT_REQUIRED`.
 #f it's neither `None` nor a string we assume it is already the numeric
 #onstant which can directly be passed to wrap_socket.
 #""
 #f candidate is None:
 #eturn CERT_REQUIRED

 #f isinstance(candidate, str):
 #es = getattr(ssl, candidate, None)
 #f res is None:
 #es = getattr(ssl, "CERT_" + candidate)
 #eturn res

 #eturn candidate


def resolve_ssl_version(candidate):
 #""
 #ike resolve_cert_reqs
 #""
 #f candidate is None:
 #eturn PROTOCOL_TLS

 #f isinstance(candidate, str):
 #es = getattr(ssl, candidate, None)
 #f res is None:
 #es = getattr(ssl, "PROTOCOL_" + candidate)
 #eturn res

 #eturn candidate


def create_urllib3_context(
 #sl_version=None, cert_reqs=None, options=None, ciphers=None
):
 #""All arguments have the same meaning as ``ssl_wrap_socket``.

 #y default, this function does a lot of the same work that
 #`ssl.create_default_context`` does on Python 3.4+. It:

 # Disables SSLv2, SSLv3, and compression
 # Sets a restricted set of server ciphers

 #f you wish to enable SSLv3, you can do::

 #rom pip._vendor.urllib3.util import ssl_
 #ontext = ssl_.create_urllib3_context()
 #ontext.options &= ~ssl_.OP_NO_SSLv3

 #ou can do the same to enable compression (substituting ``COMPRESSION``
 #or ``SSLv3`` in the last line above).

 #param ssl_version:
 #he desired protocol version to use. This will default to
 #ROTOCOL_SSLv23 which will negotiate the highest protocol that both
 #he server and your installation of OpenSSL support.
 #param cert_reqs:
 #hether to require the certificate verification. This defaults to
 #`ssl.CERT_REQUIRED``.
 #param options:
 #pecific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,
 #`ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``, and ``ssl.OP_NO_TICKET``.
 #param ciphers:
 #hich cipher suites to allow the server to select.
 #returns:
 #onstructed SSLContext object with specified options
 #rtype: SSLContext
 #""
    # PROTOCOL_TLS is deprecated in Python 3.10
 #f not ssl_version or ssl_version == PROTOCOL_TLS:
 #sl_version = PROTOCOL_TLS_CLIENT

 #ontext = SSLContext(ssl_version)

 #ontext.set_ciphers(ciphers or DEFAULT_CIPHERS)

    # Setting the default here, as we may have no ssl module on import
 #ert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs

 #f options is None:
 #ptions = 0
        # SSLv2 is easily broken and is considered harmful and dangerous
 #ptions |= OP_NO_SSLv2
        # SSLv3 has several problems and is now dangerous
 #ptions |= OP_NO_SSLv3
        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+
        # (issue #309)
 #ptions |= OP_NO_COMPRESSION
        # TLSv1.2 only. Unless set explicitly, do not request tickets.
        # This may save some bandwidth on wire, and although the ticket is encrypted,
        # there is a risk associated with it being on wire,
        # if the server is not rotating its ticketing keys properly.
 #ptions |= OP_NO_TICKET

 #ontext.options |= options

    # Enable post-handshake authentication for TLS 1.3, see GH #1634. PHA is
    # necessary for conditional client cert authentication with TLS 1.3.
    # The attribute is None for OpenSSL <= 1.1.0 or does not exist in older
    # versions of Python.  We only enable on Python 3.7.4+ or if certificate
    # verification is enabled to work around Python issue #37428
    # See: https://bugs.python.org/issue37428
 #f (cert_reqs == ssl.CERT_REQUIRED or sys.version_info >= (3, 7, 4)) and getattr(
 #ontext, "post_handshake_auth", None
 # is not None:
 #ontext.post_handshake_auth = True

 #ef disable_check_hostname():
 #f (
 #etattr(context, "check_hostname", None) is not None
 #:  # Platform-specific: Python 3.2
            # We do our own verification, including fingerprints and alternative
            # hostnames. So disable it here
 #ontext.check_hostname = False

    # The order of the below lines setting verify_mode and check_hostname
    # matter due to safe-guards SSLContext has to prevent an SSLContext with
    # check_hostname=True, verify_mode=NONE/OPTIONAL. This is made even more
    # complex because we don't know whether PROTOCOL_TLS_CLIENT will be used
    # or not so we don't know the initial state of the freshly created SSLContext.
 #f cert_reqs == ssl.CERT_REQUIRED:
 #ontext.verify_mode = cert_reqs
 #isable_check_hostname()
 #lse:
 #isable_check_hostname()
 #ontext.verify_mode = cert_reqs

    # Enable logging of TLS session keys via defacto standard environment variable
    # 'SSLKEYLOGFILE', if the feature is available (Python 3.8+). Skip empty values.
 #f hasattr(context, "keylog_filename"):
 #slkeylogfile = os.environ.get("SSLKEYLOGFILE")
 #f sslkeylogfile:
 #ontext.keylog_filename = sslkeylogfile

 #eturn context


def ssl_wrap_socket(
 #ock,
 #eyfile=None,
 #ertfile=None,
 #ert_reqs=None,
 #a_certs=None,
 #erver_hostname=None,
 #sl_version=None,
 #iphers=None,
 #sl_context=None,
 #a_cert_dir=None,
 #ey_password=None,
 #a_cert_data=None,
 #ls_in_tls=False,
):
 #""
 #ll arguments except for server_hostname, ssl_context, and ca_cert_dir have
 #he same meaning as they do when using :func:`ssl.wrap_socket`.

 #param server_hostname:
 #hen SNI is supported, the expected hostname of the certificate
 #param ssl_context:
 # pre-made :class:`SSLContext` object. If none is provided, one will
 #e created using :func:`create_urllib3_context`.
 #param ciphers:
 # string of ciphers we wish the client to support.
 #param ca_cert_dir:
 # directory containing CA certificates in multiple separate files, as
 #upported by OpenSSL's -CApath flag or the capath argument to
 #SLContext.load_verify_locations().
 #param key_password:
 #ptional password if the keyfile is encrypted.
 #param ca_cert_data:
 #ptional string containing CA certificates in PEM format suitable for
 #assing as the cadata parameter to SSLContext.load_verify_locations()
 #param tls_in_tls:
 #se SSLTransport to wrap the existing socket.
 #""
 #ontext = ssl_context
 #f context is None:
        # Note: This branch of code and all the variables in it are no longer
        # used by urllib3 itself. We should consider deprecating and removing
        # this code.
 #ontext = create_urllib3_context(ssl_version, cert_reqs, ciphers=ciphers)

 #f ca_certs or ca_cert_dir or ca_cert_data:
 #ry:
 #ontext.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)
 #xcept (IOError, OSError) as e:
 #aise SSLError(e)

 #lif ssl_context is None and hasattr(context, "load_default_certs"):
        # try to load OS default certs; works well on Windows (require Python3.4+)
 #ontext.load_default_certs()

    # Attempt to detect if we get the goofy behavior of the
    # keyfile being encrypted and OpenSSL asking for the
    # passphrase via the terminal and instead error out.
 #f keyfile and key_password is None and _is_key_file_encrypted(keyfile):
 #aise SSLError("Client private key is encrypted, password is required")

 #f certfile:
 #f key_password is None:
 #ontext.load_cert_chain(certfile, keyfile)
 #lse:
 #ontext.load_cert_chain(certfile, keyfile, key_password)

 #ry:
 #f hasattr(context, "set_alpn_protocols"):
 #ontext.set_alpn_protocols(ALPN_PROTOCOLS)
 #xcept NotImplementedError:  # Defensive: in CI, we always have set_alpn_protocols
 #ass

    # If we detect server_hostname is an IP address then the SNI
    # extension should not be used according to RFC3546 Section 3.1
 #se_sni_hostname = server_hostname and not is_ipaddress(server_hostname)
    # SecureTransport uses server_hostname in certificate verification.
 #end_sni = (use_sni_hostname and HAS_SNI) or (
 #S_SECURETRANSPORT and server_hostname
 #
    # Do not warn the user if server_hostname is an invalid SNI hostname.
 #f not HAS_SNI and use_sni_hostname:
 #arnings.warn(
 #An HTTPS request has been made, but the SNI (Server Name "
 #Indication) extension to TLS is not available on this platform. "
 #This may cause the server to present an incorrect TLS "
 #certificate, which can cause validation failures. You can upgrade to "
 #a newer version of Python to solve this. For more information, see "
 #https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html"
 ##ssl-warnings",
 #NIMissingWarning,
 #

 #f send_sni:
 #sl_sock = _ssl_wrap_socket_impl(
 #ock, context, tls_in_tls, server_hostname=server_hostname
 #
 #lse:
 #sl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls)
 #eturn ssl_sock


def is_ipaddress(hostname):
 #""Detects whether the hostname given is an IPv4 or IPv6 address.
 #lso detects IPv6 addresses with Zone IDs.

 #param str hostname: Hostname to examine.
 #return: True if the hostname is an IP address, False otherwise.
 #""
 #f not six.PY2 and isinstance(hostname, bytes):
        # IDN A-label bytes are ASCII compatible.
 #ostname = hostname.decode("ascii")
 #eturn bool(IPV4_RE.match(hostname) or BRACELESS_IPV6_ADDRZ_RE.match(hostname))


def _is_key_file_encrypted(key_file):
 #""Detects if a key file is encrypted or not."""
 #ith open(key_file, "r") as f:
 #or line in f:
            # Look for Proc-Type: 4,ENCRYPTED
 #f "ENCRYPTED" in line:
 #eturn True

 #eturn False


def _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname=None):
 #f tls_in_tls:
 #f not SSLTransport:
            # Import error, ssl is not available.
 #aise ProxySchemeUnsupported(
 #TLS in TLS requires support for the 'ssl' module"
 #

 #SLTransport._validate_ssl_context_for_tls_in_tls(ssl_context)
 #eturn SSLTransport(sock, ssl_context, server_hostname)

 #f server_hostname:
 #eturn ssl_context.wrap_socket(sock, server_hostname=server_hostname)
 #lse:
 #eturn ssl_context.wrap_socket(sock)
