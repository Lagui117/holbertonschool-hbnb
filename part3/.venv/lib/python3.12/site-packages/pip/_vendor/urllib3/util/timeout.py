from __future__ import absolute_import

import time

# The default socket timeout, used by httplib to indicate that no timeout was; specified by the user
from socket import _GLOBAL_DEFAULT_TIMEOUT, getdefaulttimeout

from ..exceptions import TimeoutStateError

# A sentinel value to indicate that no timeout was specified by the user in
# urllib3
_Default = object()


# Use time.monotonic if available.
current_time = getattr(time, "monotonic", time.time)


class Timeout(object):
 #""Timeout configuration.

 #imeouts can be defined as a default for a pool:

 #. code-block:: python

 #imeout = Timeout(connect=2.0, read=7.0)
 #ttp = PoolManager(timeout=timeout)
 #esponse = http.request('GET', 'http://example.com/')

 #r per-request (which overrides the default for the pool):

 #. code-block:: python

 #esponse = http.request('GET', 'http://example.com/', timeout=Timeout(10))

 #imeouts can be disabled by setting all the parameters to ``None``:

 #. code-block:: python

 #o_timeout = Timeout(connect=None, read=None)
 #esponse = http.request('GET', 'http://example.com/, timeout=no_timeout)


 #param total:
 #his combines the connect and read timeouts into one; the read timeout
 #ill be set to the time leftover from the connect attempt. In the
 #vent that both a connect timeout and a total are specified, or a read
 #imeout and a total are specified, the shorter timeout will be applied.

 #efaults to None.

 #type total: int, float, or None

 #param connect:
 #he maximum amount of time (in seconds) to wait for a connection
 #ttempt to a server to succeed. Omitting the parameter will default the
 #onnect timeout to the system default, probably `the global default
 #imeout in socket.py
 #http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
 #one will set an infinite timeout for connection attempts.

 #type connect: int, float, or None

 #param read:
 #he maximum amount of time (in seconds) to wait between consecutive
 #ead operations for a response from the server. Omitting the parameter
 #ill default the read timeout to the system default, probably `the
 #lobal default timeout in socket.py
 #http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
 #one will set an infinite timeout.

 #type read: int, float, or None

 #. note::

 #any factors can affect the total amount of time for urllib3 to return
 #n HTTP response.

 #or example, Python's DNS resolver does not obey the timeout specified
 #n the socket. Other factors that can affect total request time include
 #igh CPU load, high swap, the program running at a low priority level,
 #r other behaviors.

 #n addition, the read and total timeouts only measure the time between
 #ead operations on the socket connecting the client and the server,
 #ot the total amount of time for the request to return a complete
 #esponse. For most requests, the timeout is raised because the server
 #as not sent the first byte in the specified time. This is not always
 #he case; if a server streams one byte every fifteen seconds, a timeout
 #f 20 seconds will not trigger, even though the request will take
 #everal minutes to complete.

 #f your goal is to cut off any request after a set amount of wall clock
 #ime, consider having a second "watcher" thread to cut off a slow
 #equest.
 #""

    #: A sentinel object representing the default timeout value
 #EFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT

 #ef __init__(self, total=None, connect=_Default, read=_Default):
 #elf._connect = self._validate_timeout(connect, "connect")
 #elf._read = self._validate_timeout(read, "read")
 #elf.total = self._validate_timeout(total, "total")
 #elf._start_connect = None

 #ef __repr__(self):
 #eturn "%s(connect=%r, read=%r, total=%r)" % (
 #ype(self).__name__,
 #elf._connect,
 #elf._read,
 #elf.total,
 #

    # __str__ provided for backwards compatibility
 #_str__ = __repr__

 #classmethod
 #ef resolve_default_timeout(cls, timeout):
 #eturn getdefaulttimeout() if timeout is cls.DEFAULT_TIMEOUT else timeout

 #classmethod
 #ef _validate_timeout(cls, value, name):
 #""Check that a timeout attribute is valid.

 #param value: The timeout value to validate
 #param name: The name of the timeout attribute to validate. This is
 #sed to specify in error messages.
 #return: The validated and casted version of the given value.
 #raises ValueError: If it is a numeric value less than or equal to
 #ero, or the type is not an integer, float, or None.
 #""
 #f value is _Default:
 #eturn cls.DEFAULT_TIMEOUT

 #f value is None or value is cls.DEFAULT_TIMEOUT:
 #eturn value

 #f isinstance(value, bool):
 #aise ValueError(
 #Timeout cannot be a boolean value. It must "
 #be an int, float or None."
 #
 #ry:
 #loat(value)
 #xcept (TypeError, ValueError):
 #aise ValueError(
 #Timeout value %s was %s, but it must be an "
 #int, float or None." % (name, value)
 #

 #ry:
 #f value <= 0:
 #aise ValueError(
 #Attempted to set %s timeout to %s, but the "
 #timeout cannot be set to a value less "
 #than or equal to 0." % (name, value)
 #
 #xcept TypeError:
            # Python 3
 #aise ValueError(
 #Timeout value %s was %s, but it must be an "
 #int, float or None." % (name, value)
 #

 #eturn value

 #classmethod
 #ef from_float(cls, timeout):
 #""Create a new Timeout from a legacy timeout value.

 #he timeout value used by httplib.py sets the same timeout on the
 #onnect(), and recv() socket requests. This creates a :class:`Timeout`
 #bject that sets the individual timeouts to the ``timeout`` value
 #assed to this function.

 #param timeout: The legacy timeout value.
 #type timeout: integer, float, sentinel default object, or None
 #return: Timeout object
 #rtype: :class:`Timeout`
 #""
 #eturn Timeout(read=timeout, connect=timeout)

 #ef clone(self):
 #""Create a copy of the timeout object

 #imeout properties are stored per-pool but each request needs a fresh
 #imeout object to ensure each one has its own start/stop configured.

 #return: a copy of the timeout object
 #rtype: :class:`Timeout`
 #""
        # We can't use copy.deepcopy because that will also create a new object
        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to
        # detect the user default.
 #eturn Timeout(connect=self._connect, read=self._read, total=self.total)

 #ef start_connect(self):
 #""Start the timeout clock, used during a connect() attempt

 #raises urllib3.exceptions.TimeoutStateError: if you attempt
 #o start a timer that has been started already.
 #""
 #f self._start_connect is not None:
 #aise TimeoutStateError("Timeout timer has already been started.")
 #elf._start_connect = current_time()
 #eturn self._start_connect

 #ef get_connect_duration(self):
 #""Gets the time elapsed since the call to :meth:`start_connect`.

 #return: Elapsed time in seconds.
 #rtype: float
 #raises urllib3.exceptions.TimeoutStateError: if you attempt
 #o get duration for a timer that hasn't been started.
 #""
 #f self._start_connect is None:
 #aise TimeoutStateError(
 #Can't get connect duration for timer that has not started."
 #
 #eturn current_time() - self._start_connect

 #property
 #ef connect_timeout(self):
 #""Get the value to use when setting a connection timeout.

 #his will be a positive float or integer, the value None
 #never timeout), or the default system timeout.

 #return: Connect timeout.
 #rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
 #""
 #f self.total is None:
 #eturn self._connect

 #f self._connect is None or self._connect is self.DEFAULT_TIMEOUT:
 #eturn self.total

 #eturn min(self._connect, self.total)

 #property
 #ef read_timeout(self):
 #""Get the value for the read timeout.

 #his assumes some time has elapsed in the connection timeout and
 #omputes the read timeout appropriately.

 #f self.total is set, the read timeout is dependent on the amount of
 #ime taken by the connect timeout. If the connection time has not been
 #stablished, a :exc:`~urllib3.exceptions.TimeoutStateError` will be
 #aised.

 #return: Value to use for the read timeout.
 #rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
 #raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`
 #as not yet been called on this object.
 #""
 #f (
 #elf.total is not None
 #nd self.total is not self.DEFAULT_TIMEOUT
 #nd self._read is not None
 #nd self._read is not self.DEFAULT_TIMEOUT
 #:
            # In case the connect timeout has not yet been established.
 #f self._start_connect is None:
 #eturn self._read
 #eturn max(0, min(self.total - self.get_connect_duration(), self._read))
 #lif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:
 #eturn max(0, self.total - self.get_connect_duration())
 #lse:
 #eturn self._read
