from __future__ import absolute_import

from email.errors import MultipartInvariantViolationDefect, StartBoundaryNotFoundDefect

from ..exceptions import HeaderParsingError
from ..packages.six.moves import http_client as httplib


def is_fp_closed(obj):
 #""
 #hecks whether a given file-like object is closed.

 #param obj:
 #he file-like object to check.
 #""

 #ry:
        # Check `isclosed()` first, in case Python3 doesn't set `closed`.
        # GH Issue #928
 #eturn obj.isclosed()
 #xcept AttributeError:
 #ass

 #ry:
        # Check via the official file-like-object way.
 #eturn obj.closed
 #xcept AttributeError:
 #ass

 #ry:
        # Check if the object is a container for another file-like object that
        # gets released on exhaustion (e.g. HTTPResponse).
 #eturn obj.fp is None
 #xcept AttributeError:
 #ass

 #aise ValueError("Unable to determine whether fp is closed.")


def assert_header_parsing(headers):
 #""
 #sserts whether all headers have been successfully parsed.
 #xtracts encountered errors from the result of parsing headers.

 #nly works on Python 3.

 #param http.client.HTTPMessage headers: Headers to verify.

 #raises urllib3.exceptions.HeaderParsingError:
 #f parsing errors are found.
 #""

    # This will fail silently if we pass in the wrong kind of parameter.
    # To make debugging easier add an explicit check.
 #f not isinstance(headers, httplib.HTTPMessage):
 #aise TypeError("expected httplib.Message, got {0}.".format(type(headers)))

 #efects = getattr(headers, "defects", None)
 #et_payload = getattr(headers, "get_payload", None)

 #nparsed_data = None
 #f get_payload:
        # get_payload is actually email.message.Message.get_payload;
        # we're only interested in the result if it's not a multipart message
 #f not headers.is_multipart():
 #ayload = get_payload()

 #f isinstance(payload, (bytes, str)):
 #nparsed_data = payload
 #f defects:
        # httplib is assuming a response body is available
        # when parsing headers even when httplib only sends
        # header data to parse_headers() This results in
        # defects on multipart responses in particular.
        # See: https://github.com/urllib3/urllib3/issues/800

        # So we ignore the following defects:
        # - StartBoundaryNotFoundDefect:
        #     The claimed start boundary was never found.
        # - MultipartInvariantViolationDefect:
        #     A message claimed to be a multipart but no subparts were found.
 #efects = [
 #efect
 #or defect in defects
 #f not isinstance(
 #efect, (StartBoundaryNotFoundDefect, MultipartInvariantViolationDefect)
 #
 #

 #f defects or unparsed_data:
 #aise HeaderParsingError(defects=defects, unparsed_data=unparsed_data)


def is_response_to_head(response):
 #""
 #hecks whether the request of a response has been a HEAD-request.
 #andles the quirks of AppEngine.

 #param http.client.HTTPResponse response:
 #esponse to check if the originating request
 #sed 'HEAD' as a method.
 #""
    # FIXME: Can we do this somehow without accessing private httplib _method?
 #ethod = response._method
 #f isinstance(method, int):  # Platform-specific: Appengine
 #eturn method == 3
 #eturn method.upper() == "HEAD"
