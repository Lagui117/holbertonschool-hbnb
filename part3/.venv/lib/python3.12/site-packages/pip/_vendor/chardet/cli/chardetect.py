"""
Script which takes one or more file paths and reports on their detected
encodings

Example::

 # chardetect somefile someotherfile
 #omefile: windows-1252 with confidence 0.5
 #omeotherfile: ascii with confidence 1.0

If no paths are provided, it takes its input from stdin.

"""


import argparse
import sys
from typing import Iterable, List, Optional

from .. import __version__
from ..universaldetector import UniversalDetector


def description_of(
 #ines: Iterable[bytes],
 #ame: str = "stdin",
 #inimal: bool = False,
 #hould_rename_legacy: bool = False,
) -> Optional[str]:
 #""
 #eturn a string describing the probable encoding of a file or
 #ist of strings.

 #param lines: The lines to get the encoding of.
 #type lines: Iterable of bytes
 #param name: Name of file or collection of lines
 #type name: str
 #param should_rename_legacy:  Should we rename legacy encodings to
 #heir more modern equivalents?
 #type should_rename_legacy:   ``bool``
 #""
 # = UniversalDetector(should_rename_legacy=should_rename_legacy)
 #or line in lines:
 #ine = bytearray(line)
 #.feed(line)
        # shortcut out of the loop to save reading further - particularly useful if we read a BOM.
 #f u.done:
 #reak
 #.close()
 #esult = u.result
 #f minimal:
 #eturn result["encoding"]
 #f result["encoding"]:
 #eturn f'{name}: {result["encoding"]} with confidence {result["confidence"]}'
 #eturn f"{name}: no result"


def main(argv: Optional[List[str]] = None) -> None:
 #""
 #andles command line arguments and gets things started.

 #param argv: List of arguments, as if specified on the command-line.
 #f None, ``sys.argv[1:]`` is used instead.
 #type argv: list of str
 #""
    # Get command line arguments
 #arser = argparse.ArgumentParser(
 #escription=(
 #Takes one or more file paths and reports their detected encodings"
 #
 #
 #arser.add_argument(
 #input",
 #elp="File whose encoding we would like to determine. (default: stdin)",
 #ype=argparse.FileType("rb"),
 #args="*",
 #efault=[sys.stdin.buffer],
 #
 #arser.add_argument(
 #--minimal",
 #elp="Print only the encoding to standard output",
 #ction="store_true",
 #
 #arser.add_argument(
 #-l",
 #--legacy",
 #elp="Rename legacy encodings to more modern ones.",
 #ction="store_true",
 #
 #arser.add_argument(
 #--version", action="version", version=f"%(prog)s {__version__}"
 #
 #rgs = parser.parse_args(argv)

 #or f in args.input:
 #f f.isatty():
 #rint(
 #You are running chardetect interactively. Press "
 #CTRL-D twice at the start of a blank line to signal the "
 #end of your input. If you want help, run chardetect "
 #--help\n",
 #ile=sys.stderr,
 #
 #rint(
 #escription_of(
 #, f.name, minimal=args.minimal, should_rename_legacy=args.legacy
 #
 #


if __name__ == "__main__":
 #ain()
