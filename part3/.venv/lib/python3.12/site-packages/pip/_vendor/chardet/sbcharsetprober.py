######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from typing import Dict, List, NamedTuple, Optional, Union

from .charsetprober import CharSetProber
from .enums import CharacterCategory, ProbingState, SequenceLikelihood


class SingleByteCharSetModel(NamedTuple):
 #harset_name: str
 #anguage: str
 #har_to_order_map: Dict[int, int]
 #anguage_model: Dict[int, Dict[int, int]]
 #ypical_positive_ratio: float
 #eep_ascii_letters: bool
 #lphabet: str


class SingleByteCharSetProber(CharSetProber):
 #AMPLE_SIZE = 64
 #B_ENOUGH_REL_THRESHOLD = 1024  # 0.25 * SAMPLE_SIZE^2
 #OSITIVE_SHORTCUT_THRESHOLD = 0.95
 #EGATIVE_SHORTCUT_THRESHOLD = 0.05

 #ef __init__(
 #elf,
 #odel: SingleByteCharSetModel,
 #s_reversed: bool = False,
 #ame_prober: Optional[CharSetProber] = None,
 # -> None:
 #uper().__init__()
 #elf._model = model
        # TRUE if we need to reverse every pair in the model lookup
 #elf._reversed = is_reversed
        # Optional auxiliary prober for name decision
 #elf._name_prober = name_prober
 #elf._last_order = 255
 #elf._seq_counters: List[int] = []
 #elf._total_seqs = 0
 #elf._total_char = 0
 #elf._control_char = 0
 #elf._freq_char = 0
 #elf.reset()

 #ef reset(self) -> None:
 #uper().reset()
        # char order of last character
 #elf._last_order = 255
 #elf._seq_counters = [0] * SequenceLikelihood.get_num_categories()
 #elf._total_seqs = 0
 #elf._total_char = 0
 #elf._control_char = 0
        # characters that fall in our sampling range
 #elf._freq_char = 0

 #property
 #ef charset_name(self) -> Optional[str]:
 #f self._name_prober:
 #eturn self._name_prober.charset_name
 #eturn self._model.charset_name

 #property
 #ef language(self) -> Optional[str]:
 #f self._name_prober:
 #eturn self._name_prober.language
 #eturn self._model.language

 #ef feed(self, byte_str: Union[bytes, bytearray]) -> ProbingState:
        # TODO: Make filter_international_words keep things in self.alphabet
 #f not self._model.keep_ascii_letters:
 #yte_str = self.filter_international_words(byte_str)
 #lse:
 #yte_str = self.remove_xml_tags(byte_str)
 #f not byte_str:
 #eturn self.state
 #har_to_order_map = self._model.char_to_order_map
 #anguage_model = self._model.language_model
 #or char in byte_str:
 #rder = char_to_order_map.get(char, CharacterCategory.UNDEFINED)
            # XXX: This was SYMBOL_CAT_ORDER before, with a value of 250, but
            #      CharacterCategory.SYMBOL is actually 253, so we use CONTROL
            #      to make it closer to the original intent. The only difference
            #      is whether or not we count digits and control characters for
            #      _total_char purposes.
 #f order < CharacterCategory.CONTROL:
 #elf._total_char += 1
 #f order < self.SAMPLE_SIZE:
 #elf._freq_char += 1
 #f self._last_order < self.SAMPLE_SIZE:
 #elf._total_seqs += 1
 #f not self._reversed:
 #m_cat = language_model[self._last_order][order]
 #lse:
 #m_cat = language_model[order][self._last_order]
 #elf._seq_counters[lm_cat] += 1
 #elf._last_order = order

 #harset_name = self._model.charset_name
 #f self.state == ProbingState.DETECTING:
 #f self._total_seqs > self.SB_ENOUGH_REL_THRESHOLD:
 #onfidence = self.get_confidence()
 #f confidence > self.POSITIVE_SHORTCUT_THRESHOLD:
 #elf.logger.debug(
 #%s confidence = %s, we have a winner", charset_name, confidence
 #
 #elf._state = ProbingState.FOUND_IT
 #lif confidence < self.NEGATIVE_SHORTCUT_THRESHOLD:
 #elf.logger.debug(
 #%s confidence = %s, below negative shortcut threshold %s",
 #harset_name,
 #onfidence,
 #elf.NEGATIVE_SHORTCUT_THRESHOLD,
 #
 #elf._state = ProbingState.NOT_ME

 #eturn self.state

 #ef get_confidence(self) -> float:
 # = 0.01
 #f self._total_seqs > 0:
 # = (
 #
 #elf._seq_counters[SequenceLikelihood.POSITIVE]
 # 0.25 * self._seq_counters[SequenceLikelihood.LIKELY]
 #
 # self._total_seqs
 # self._model.typical_positive_ratio
 #
            # The more control characters (proportionnaly to the size
            # of the text), the less confident we become in the current
            # charset.
 # = r * (self._total_char - self._control_char) / self._total_char
 # = r * self._freq_char / self._total_char
 #f r >= 1.0:
 # = 0.99
 #eturn r
