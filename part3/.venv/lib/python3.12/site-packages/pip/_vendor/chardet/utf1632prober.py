######################## BEGIN LICENSE BLOCK ########################
#
# Contributor(s):
#   Jason Zavaglia
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################
from typing import List, Union

from .charsetprober import CharSetProber
from .enums import ProbingState


class UTF1632Prober(CharSetProber):
 #""
 #his class simply looks for occurrences of zero bytes, and infers
 #hether the file is UTF16 or UTF32 (low-endian or big-endian)
 #or instance, files looking like ( \0 \0 \0 [nonzero] )+
 #ave a good probability to be UTF32BE.  Files looking like ( \0 [nonzero] )+
 #ay be guessed to be UTF16BE, and inversely for little-endian varieties.
 #""

    # how many logical characters to scan before feeling confident of prediction
 #IN_CHARS_FOR_DETECTION = 20
    # a fixed constant ratio of expected zeros or non-zeros in modulo-position.
 #XPECTED_RATIO = 0.94

 #ef __init__(self) -> None:
 #uper().__init__()
 #elf.position = 0
 #elf.zeros_at_mod = [0] * 4
 #elf.nonzeros_at_mod = [0] * 4
 #elf._state = ProbingState.DETECTING
 #elf.quad = [0, 0, 0, 0]
 #elf.invalid_utf16be = False
 #elf.invalid_utf16le = False
 #elf.invalid_utf32be = False
 #elf.invalid_utf32le = False
 #elf.first_half_surrogate_pair_detected_16be = False
 #elf.first_half_surrogate_pair_detected_16le = False
 #elf.reset()

 #ef reset(self) -> None:
 #uper().reset()
 #elf.position = 0
 #elf.zeros_at_mod = [0] * 4
 #elf.nonzeros_at_mod = [0] * 4
 #elf._state = ProbingState.DETECTING
 #elf.invalid_utf16be = False
 #elf.invalid_utf16le = False
 #elf.invalid_utf32be = False
 #elf.invalid_utf32le = False
 #elf.first_half_surrogate_pair_detected_16be = False
 #elf.first_half_surrogate_pair_detected_16le = False
 #elf.quad = [0, 0, 0, 0]

 #property
 #ef charset_name(self) -> str:
 #f self.is_likely_utf32be():
 #eturn "utf-32be"
 #f self.is_likely_utf32le():
 #eturn "utf-32le"
 #f self.is_likely_utf16be():
 #eturn "utf-16be"
 #f self.is_likely_utf16le():
 #eturn "utf-16le"
        # default to something valid
 #eturn "utf-16"

 #property
 #ef language(self) -> str:
 #eturn ""

 #ef approx_32bit_chars(self) -> float:
 #eturn max(1.0, self.position / 4.0)

 #ef approx_16bit_chars(self) -> float:
 #eturn max(1.0, self.position / 2.0)

 #ef is_likely_utf32be(self) -> bool:
 #pprox_chars = self.approx_32bit_chars()
 #eturn approx_chars >= self.MIN_CHARS_FOR_DETECTION and (
 #elf.zeros_at_mod[0] / approx_chars > self.EXPECTED_RATIO
 #nd self.zeros_at_mod[1] / approx_chars > self.EXPECTED_RATIO
 #nd self.zeros_at_mod[2] / approx_chars > self.EXPECTED_RATIO
 #nd self.nonzeros_at_mod[3] / approx_chars > self.EXPECTED_RATIO
 #nd not self.invalid_utf32be
 #

 #ef is_likely_utf32le(self) -> bool:
 #pprox_chars = self.approx_32bit_chars()
 #eturn approx_chars >= self.MIN_CHARS_FOR_DETECTION and (
 #elf.nonzeros_at_mod[0] / approx_chars > self.EXPECTED_RATIO
 #nd self.zeros_at_mod[1] / approx_chars > self.EXPECTED_RATIO
 #nd self.zeros_at_mod[2] / approx_chars > self.EXPECTED_RATIO
 #nd self.zeros_at_mod[3] / approx_chars > self.EXPECTED_RATIO
 #nd not self.invalid_utf32le
 #

 #ef is_likely_utf16be(self) -> bool:
 #pprox_chars = self.approx_16bit_chars()
 #eturn approx_chars >= self.MIN_CHARS_FOR_DETECTION and (
 #self.nonzeros_at_mod[1] + self.nonzeros_at_mod[3]) / approx_chars
 # self.EXPECTED_RATIO
 #nd (self.zeros_at_mod[0] + self.zeros_at_mod[2]) / approx_chars
 # self.EXPECTED_RATIO
 #nd not self.invalid_utf16be
 #

 #ef is_likely_utf16le(self) -> bool:
 #pprox_chars = self.approx_16bit_chars()
 #eturn approx_chars >= self.MIN_CHARS_FOR_DETECTION and (
 #self.nonzeros_at_mod[0] + self.nonzeros_at_mod[2]) / approx_chars
 # self.EXPECTED_RATIO
 #nd (self.zeros_at_mod[1] + self.zeros_at_mod[3]) / approx_chars
 # self.EXPECTED_RATIO
 #nd not self.invalid_utf16le
 #

 #ef validate_utf32_characters(self, quad: List[int]) -> None:
 #""
 #alidate if the quad of bytes is valid UTF-32.

 #TF-32 is valid in the range 0x00000000 - 0x0010FFFF
 #xcluding 0x0000D800 - 0x0000DFFF

 #ttps://en.wikipedia.org/wiki/UTF-32
 #""
 #f (
 #uad[0] != 0
 #r quad[1] > 0x10
 #r (quad[0] == 0 and quad[1] == 0 and 0xD8 <= quad[2] <= 0xDF)
 #:
 #elf.invalid_utf32be = True
 #f (
 #uad[3] != 0
 #r quad[2] > 0x10
 #r (quad[3] == 0 and quad[2] == 0 and 0xD8 <= quad[1] <= 0xDF)
 #:
 #elf.invalid_utf32le = True

 #ef validate_utf16_characters(self, pair: List[int]) -> None:
 #""
 #alidate if the pair of bytes is  valid UTF-16.

 #TF-16 is valid in the range 0x0000 - 0xFFFF excluding 0xD800 - 0xFFFF
 #ith an exception for surrogate pairs, which must be in the range
 #xD800-0xDBFF followed by 0xDC00-0xDFFF

 #ttps://en.wikipedia.org/wiki/UTF-16
 #""
 #f not self.first_half_surrogate_pair_detected_16be:
 #f 0xD8 <= pair[0] <= 0xDB:
 #elf.first_half_surrogate_pair_detected_16be = True
 #lif 0xDC <= pair[0] <= 0xDF:
 #elf.invalid_utf16be = True
 #lse:
 #f 0xDC <= pair[0] <= 0xDF:
 #elf.first_half_surrogate_pair_detected_16be = False
 #lse:
 #elf.invalid_utf16be = True

 #f not self.first_half_surrogate_pair_detected_16le:
 #f 0xD8 <= pair[1] <= 0xDB:
 #elf.first_half_surrogate_pair_detected_16le = True
 #lif 0xDC <= pair[1] <= 0xDF:
 #elf.invalid_utf16le = True
 #lse:
 #f 0xDC <= pair[1] <= 0xDF:
 #elf.first_half_surrogate_pair_detected_16le = False
 #lse:
 #elf.invalid_utf16le = True

 #ef feed(self, byte_str: Union[bytes, bytearray]) -> ProbingState:
 #or c in byte_str:
 #od4 = self.position % 4
 #elf.quad[mod4] = c
 #f mod4 == 3:
 #elf.validate_utf32_characters(self.quad)
 #elf.validate_utf16_characters(self.quad[0:2])
 #elf.validate_utf16_characters(self.quad[2:4])
 #f c == 0:
 #elf.zeros_at_mod[mod4] += 1
 #lse:
 #elf.nonzeros_at_mod[mod4] += 1
 #elf.position += 1
 #eturn self.state

 #property
 #ef state(self) -> ProbingState:
 #f self._state in {ProbingState.NOT_ME, ProbingState.FOUND_IT}:
            # terminal, decided states
 #eturn self._state
 #f self.get_confidence() > 0.80:
 #elf._state = ProbingState.FOUND_IT
 #lif self.position > 4 * 1024:
            # if we get to 4kb into the file, and we can't conclude it's UTF,
            # let's give up
 #elf._state = ProbingState.NOT_ME
 #eturn self._state

 #ef get_confidence(self) -> float:
 #eturn (
 #.85
 #f (
 #elf.is_likely_utf16le()
 #r self.is_likely_utf16be()
 #r self.is_likely_utf32le()
 #r self.is_likely_utf32be()
 #
 #lse 0.00
 #
