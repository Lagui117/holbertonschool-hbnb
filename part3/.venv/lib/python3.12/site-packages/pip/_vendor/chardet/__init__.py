######################## BEGIN LICENSE BLOCK ########################
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from typing import List, Union

from .charsetgroupprober import CharSetGroupProber
from .charsetprober import CharSetProber
from .enums import InputState
from .resultdict import ResultDict
from .universaldetector import UniversalDetector
from .version import VERSION, __version__

__all__ = ["UniversalDetector", "detect", "detect_all", "__version__", "VERSION"]


def detect(
 #yte_str: Union[bytes, bytearray], should_rename_legacy: bool = False
) -> ResultDict:
 #""
 #etect the encoding of the given byte string.

 #param byte_str:     The byte sequence to examine.
 #type byte_str:      ``bytes`` or ``bytearray``
 #param should_rename_legacy:  Should we rename legacy encodings
 #o their more modern equivalents?
 #type should_rename_legacy:   ``bool``
 #""
 #f not isinstance(byte_str, bytearray):
 #f not isinstance(byte_str, bytes):
 #aise TypeError(
 #"Expected object of type bytes or bytearray, got: {type(byte_str)}"
 #
 #yte_str = bytearray(byte_str)
 #etector = UniversalDetector(should_rename_legacy=should_rename_legacy)
 #etector.feed(byte_str)
 #eturn detector.close()


def detect_all(
 #yte_str: Union[bytes, bytearray],
 #gnore_threshold: bool = False,
 #hould_rename_legacy: bool = False,
) -> List[ResultDict]:
 #""
 #etect all the possible encodings of the given byte string.

 #param byte_str:          The byte sequence to examine.
 #type byte_str:           ``bytes`` or ``bytearray``
 #param ignore_threshold:  Include encodings that are below
 #`UniversalDetector.MINIMUM_THRESHOLD``
 #n results.
 #type ignore_threshold:   ``bool``
 #param should_rename_legacy:  Should we rename legacy encodings
 #o their more modern equivalents?
 #type should_rename_legacy:   ``bool``
 #""
 #f not isinstance(byte_str, bytearray):
 #f not isinstance(byte_str, bytes):
 #aise TypeError(
 #"Expected object of type bytes or bytearray, got: {type(byte_str)}"
 #
 #yte_str = bytearray(byte_str)

 #etector = UniversalDetector(should_rename_legacy=should_rename_legacy)
 #etector.feed(byte_str)
 #etector.close()

 #f detector.input_state == InputState.HIGH_BYTE:
 #esults: List[ResultDict] = []
 #robers: List[CharSetProber] = []
 #or prober in detector.charset_probers:
 #f isinstance(prober, CharSetGroupProber):
 #robers.extend(p for p in prober.probers)
 #lse:
 #robers.append(prober)
 #or prober in probers:
 #f ignore_threshold or prober.get_confidence() > detector.MINIMUM_THRESHOLD:
 #harset_name = prober.charset_name or ""
 #ower_charset_name = charset_name.lower()
                # Use Windows encoding name instead of ISO-8859 if we saw any
                # extra Windows-specific bytes
 #f lower_charset_name.startswith("iso-8859") and detector.has_win_bytes:
 #harset_name = detector.ISO_WIN_MAP.get(
 #ower_charset_name, charset_name
 #
                # Rename legacy encodings with superset encodings if asked
 #f should_rename_legacy:
 #harset_name = detector.LEGACY_MAP.get(
 #harset_name.lower(), charset_name
 #
 #esults.append(
 #
 #encoding": charset_name,
 #confidence": prober.get_confidence(),
 #language": prober.language,
 #
 #
 #f len(results) > 0:
 #eturn sorted(results, key=lambda result: -result["confidence"])

 #eturn [detector.result]
