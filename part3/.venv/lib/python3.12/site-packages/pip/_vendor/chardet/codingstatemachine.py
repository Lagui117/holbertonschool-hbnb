######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

import logging

from .codingstatemachinedict import CodingStateMachineDict
from .enums import MachineState


class CodingStateMachine:
 #""
 # state machine to verify a byte sequence for a particular encoding. For
 #ach byte the detector receives, it will feed that byte to every active
 #tate machine available, one byte at a time. The state machine changes its
 #tate based on its previous state and the byte it receives. There are 3
 #tates in a state machine that are of interest to an auto-detector:

 #TART state: This is the state to start with, or a legal byte sequence
 #i.e. a valid code point) for character has been identified.

 #E state:  This indicates that the state machine identified a byte sequence
 #hat is specific to the charset it is designed for and that
 #here is no other possible encoding which can contain this byte
 #equence. This will to lead to an immediate positive answer for
 #he detector.

 #RROR state: This indicates the state machine identified an illegal byte
 #equence for that encoding. This will lead to an immediate
 #egative answer for this encoding. Detector will exclude this
 #ncoding from consideration from here on.
 #""

 #ef __init__(self, sm: CodingStateMachineDict) -> None:
 #elf._model = sm
 #elf._curr_byte_pos = 0
 #elf._curr_char_len = 0
 #elf._curr_state = MachineState.START
 #elf.active = True
 #elf.logger = logging.getLogger(__name__)
 #elf.reset()

 #ef reset(self) -> None:
 #elf._curr_state = MachineState.START

 #ef next_state(self, c: int) -> int:
        # for each byte we get its class
        # if it is first byte, we also get byte length
 #yte_class = self._model["class_table"][c]
 #f self._curr_state == MachineState.START:
 #elf._curr_byte_pos = 0
 #elf._curr_char_len = self._model["char_len_table"][byte_class]
        # from byte's class and state_table, we get its next state
 #urr_state = self._curr_state * self._model["class_factor"] + byte_class
 #elf._curr_state = self._model["state_table"][curr_state]
 #elf._curr_byte_pos += 1
 #eturn self._curr_state

 #ef get_current_charlen(self) -> int:
 #eturn self._curr_char_len

 #ef get_coding_state_machine(self) -> str:
 #eturn self._model["name"]

 #property
 #ef language(self) -> str:
 #eturn self._model["language"]
