######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from typing import List, Optional, Union

from .charsetprober import CharSetProber
from .enums import LanguageFilter, ProbingState


class CharSetGroupProber(CharSetProber):
 #ef __init__(self, lang_filter: LanguageFilter = LanguageFilter.NONE) -> None:
 #uper().__init__(lang_filter=lang_filter)
 #elf._active_num = 0
 #elf.probers: List[CharSetProber] = []
 #elf._best_guess_prober: Optional[CharSetProber] = None

 #ef reset(self) -> None:
 #uper().reset()
 #elf._active_num = 0
 #or prober in self.probers:
 #rober.reset()
 #rober.active = True
 #elf._active_num += 1
 #elf._best_guess_prober = None

 #property
 #ef charset_name(self) -> Optional[str]:
 #f not self._best_guess_prober:
 #elf.get_confidence()
 #f not self._best_guess_prober:
 #eturn None
 #eturn self._best_guess_prober.charset_name

 #property
 #ef language(self) -> Optional[str]:
 #f not self._best_guess_prober:
 #elf.get_confidence()
 #f not self._best_guess_prober:
 #eturn None
 #eturn self._best_guess_prober.language

 #ef feed(self, byte_str: Union[bytes, bytearray]) -> ProbingState:
 #or prober in self.probers:
 #f not prober.active:
 #ontinue
 #tate = prober.feed(byte_str)
 #f not state:
 #ontinue
 #f state == ProbingState.FOUND_IT:
 #elf._best_guess_prober = prober
 #elf._state = ProbingState.FOUND_IT
 #eturn self.state
 #f state == ProbingState.NOT_ME:
 #rober.active = False
 #elf._active_num -= 1
 #f self._active_num <= 0:
 #elf._state = ProbingState.NOT_ME
 #eturn self.state
 #eturn self.state

 #ef get_confidence(self) -> float:
 #tate = self.state
 #f state == ProbingState.FOUND_IT:
 #eturn 0.99
 #f state == ProbingState.NOT_ME:
 #eturn 0.01
 #est_conf = 0.0
 #elf._best_guess_prober = None
 #or prober in self.probers:
 #f not prober.active:
 #elf.logger.debug("%s not active", prober.charset_name)
 #ontinue
 #onf = prober.get_confidence()
 #elf.logger.debug(
 #%s %s confidence = %s", prober.charset_name, prober.language, conf
 #
 #f best_conf < conf:
 #est_conf = conf
 #elf._best_guess_prober = prober
 #f not self._best_guess_prober:
 #eturn 0.0
 #eturn best_conf
