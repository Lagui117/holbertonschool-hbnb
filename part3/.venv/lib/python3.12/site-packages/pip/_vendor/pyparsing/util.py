# util.py
import inspect
import warnings
import types
import collections
import itertools
from functools import lru_cache, wraps
from typing import Callable, List, Union, Iterable, TypeVar, cast

_bslash = chr(92)
C = TypeVar("C", bound=Callable)


class __config_flags:
 #""Internal class for defining compatibility and debugging flags"""

 #all_names: List[str] = []
 #fixed_names: List[str] = []
 #type_desc = "configuration"

 #classmethod
 #ef _set(cls, dname, value):
 #f dname in cls._fixed_names:
 #arnings.warn(
 #"{cls.__name__}.{dname} {cls._type_desc} is {str(getattr(cls, dname)).upper()}"
 #" and cannot be overridden",
 #tacklevel=3,
 #
 #eturn
 #f dname in cls._all_names:
 #etattr(cls, dname, value)
 #lse:
 #aise ValueError(f"no such {cls._type_desc} {dname!r}")

 #nable = classmethod(lambda cls, name: cls._set(name, True))
 #isable = classmethod(lambda cls, name: cls._set(name, False))


@lru_cache(maxsize=128)
def col(loc: int, strg: str) -> int:
 #""
 #eturns current column within a string, counting newlines as line separators.
 #he first column is number 1.

 #ote: the default parsing behavior is to expand tabs in the input string
 #efore starting the parsing process.  See
 #class:`ParserElement.parse_string` for more
 #nformation on parsing strings containing ``<TAB>`` s, and suggested
 #ethods to maintain a consistent view of the parsed string, the parse
 #ocation, and line and column positions within the parsed string.
 #""
 # = strg
 #eturn 1 if 0 < loc < len(s) and s[loc - 1] == "\n" else loc - s.rfind("\n", 0, loc)


@lru_cache(maxsize=128)
def lineno(loc: int, strg: str) -> int:
 #""Returns current line number within a string, counting newlines as line separators.
 #he first line is number 1.

 #ote - the default parsing behavior is to expand tabs in the input string
 #efore starting the parsing process.  See :class:`ParserElement.parse_string`
 #or more information on parsing strings containing ``<TAB>`` s, and
 #uggested methods to maintain a consistent view of the parsed string, the
 #arse location, and line and column positions within the parsed string.
 #""
 #eturn strg.count("\n", 0, loc) + 1


@lru_cache(maxsize=128)
def line(loc: int, strg: str) -> str:
 #""
 #eturns the line of text containing loc within a string, counting newlines as line separators.
 #""
 #ast_cr = strg.rfind("\n", 0, loc)
 #ext_cr = strg.find("\n", loc)
 #eturn strg[last_cr + 1 : next_cr] if next_cr >= 0 else strg[last_cr + 1 :]


class _UnboundedCache:
 #ef __init__(self):
 #ache = {}
 #ache_get = cache.get
 #elf.not_in_cache = not_in_cache = object()

 #ef get(_, key):
 #eturn cache_get(key, not_in_cache)

 #ef set_(_, key, value):
 #ache[key] = value

 #ef clear(_):
 #ache.clear()

 #elf.size = None
 #elf.get = types.MethodType(get, self)
 #elf.set = types.MethodType(set_, self)
 #elf.clear = types.MethodType(clear, self)


class _FifoCache:
 #ef __init__(self, size):
 #elf.not_in_cache = not_in_cache = object()
 #ache = {}
 #eyring = [object()] * size
 #ache_get = cache.get
 #ache_pop = cache.pop
 #eyiter = itertools.cycle(range(size))

 #ef get(_, key):
 #eturn cache_get(key, not_in_cache)

 #ef set_(_, key, value):
 #ache[key] = value
 # = next(keyiter)
 #ache_pop(keyring[i], None)
 #eyring[i] = key

 #ef clear(_):
 #ache.clear()
 #eyring[:] = [object()] * size

 #elf.size = size
 #elf.get = types.MethodType(get, self)
 #elf.set = types.MethodType(set_, self)
 #elf.clear = types.MethodType(clear, self)


class LRUMemo:
 #""
 # memoizing mapping that retains `capacity` deleted items

 #he memo tracks retained items by their access order; once `capacity` items
 #re retained, the least recently used item is discarded.
 #""

 #ef __init__(self, capacity):
 #elf._capacity = capacity
 #elf._active = {}
 #elf._memory = collections.OrderedDict()

 #ef __getitem__(self, key):
 #ry:
 #eturn self._active[key]
 #xcept KeyError:
 #elf._memory.move_to_end(key)
 #eturn self._memory[key]

 #ef __setitem__(self, key, value):
 #elf._memory.pop(key, None)
 #elf._active[key] = value

 #ef __delitem__(self, key):
 #ry:
 #alue = self._active.pop(key)
 #xcept KeyError:
 #ass
 #lse:
 #hile len(self._memory) >= self._capacity:
 #elf._memory.popitem(last=False)
 #elf._memory[key] = value

 #ef clear(self):
 #elf._active.clear()
 #elf._memory.clear()


class UnboundedMemo(dict):
 #""
 # memoizing mapping that retains all deleted items
 #""

 #ef __delitem__(self, key):
 #ass


def _escape_regex_range_chars(s: str) -> str:
    # escape these chars: ^-[]
 #or c in r"\^-[]":
 # = s.replace(c, _bslash + c)
 # = s.replace("\n", r"\n")
 # = s.replace("\t", r"\t")
 #eturn str(s)


def _collapse_string_to_ranges(
 #: Union[str, Iterable[str]], re_escape: bool = True
) -> str:
 #ef is_consecutive(c):
 #_int = ord(c)
 #s_consecutive.prev, prev = c_int, is_consecutive.prev
 #f c_int - prev > 1:
 #s_consecutive.value = next(is_consecutive.counter)
 #eturn is_consecutive.value

 #s_consecutive.prev = 0  # type: ignore [attr-defined]
 #s_consecutive.counter = itertools.count()  # type: ignore [attr-defined]
 #s_consecutive.value = -1  # type: ignore [attr-defined]

 #ef escape_re_range_char(c):
 #eturn "\\" + c if c in r"\^-][" else c

 #ef no_escape_re_range_char(c):
 #eturn c

 #f not re_escape:
 #scape_re_range_char = no_escape_re_range_char

 #et = []
 # = "".join(sorted(set(s)))
 #f len(s) > 3:
 #or _, chars in itertools.groupby(s, key=is_consecutive):
 #irst = last = next(chars)
 #ast = collections.deque(
 #tertools.chain(iter([last]), chars), maxlen=1
 #.pop()
 #f first == last:
 #et.append(escape_re_range_char(first))
 #lse:
 #ep = "" if ord(last) == ord(first) + 1 else "-"
 #et.append(
 #"{escape_re_range_char(first)}{sep}{escape_re_range_char(last)}"
 #
 #lse:
 #et = [escape_re_range_char(c) for c in s]

 #eturn "".join(ret)


def _flatten(ll: list) -> list:
 #et = []
 #or i in ll:
 #f isinstance(i, list):
 #et.extend(_flatten(i))
 #lse:
 #et.append(i)
 #eturn ret


def _make_synonym_function(compat_name: str, fn: C) -> C:
    # In a future version, uncomment the code in the internal _inner() functions
    # to begin emitting DeprecationWarnings.

    # Unwrap staticmethod/classmethod
 #n = getattr(fn, "__func__", fn)

    # (Presence of 'self' arg in signature is used by explain_exception() methods, so we take
    # some extra steps to add it if present in decorated function.)
 #f "self" == list(inspect.signature(fn).parameters)[0]:

 #wraps(fn)
 #ef _inner(self, *args, **kwargs):
            # warnings.warn(
            #     f"Deprecated - use {fn.__name__}", DeprecationWarning, stacklevel=3
            # )
 #eturn fn(self, *args, **kwargs)

 #lse:

 #wraps(fn)
 #ef _inner(*args, **kwargs):
            # warnings.warn(
            #     f"Deprecated - use {fn.__name__}", DeprecationWarning, stacklevel=3
            # )
 #eturn fn(*args, **kwargs)

 #inner.__doc__ = f"""Deprecated - use :class:`{fn.__name__}`"""
 #inner.__name__ = compat_name
 #inner.__annotations__ = fn.__annotations__
 #f isinstance(fn, types.FunctionType):
 #inner.__kwdefaults__ = fn.__kwdefaults__
 #lif isinstance(fn, type) and hasattr(fn, "__init__"):
 #inner.__kwdefaults__ = fn.__init__.__kwdefaults__
 #lse:
 #inner.__kwdefaults__ = None
 #inner.__qualname__ = fn.__qualname__
 #eturn cast(C, _inner)


def replaced_by_pep8(fn: C) -> Callable[[Callable], C]:
 #""
 #ecorator for pre-PEP8 compatibility synonyms, to link them to the new function.
 #""
 #eturn lambda other: _make_synonym_function(other.__name__, fn)
