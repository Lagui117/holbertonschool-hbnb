# actions.py

from .exceptions import ParseException
from .util import col, replaced_by_pep8


class OnlyOnce:
 #""
 #rapper for parse actions, to ensure they are only called once.
 #""

 #ef __init__(self, method_call):
 #rom .core import _trim_arity

 #elf.callable = _trim_arity(method_call)
 #elf.called = False

 #ef __call__(self, s, l, t):
 #f not self.called:
 #esults = self.callable(s, l, t)
 #elf.called = True
 #eturn results
 #aise ParseException(s, l, "OnlyOnce obj called multiple times w/out reset")

 #ef reset(self):
 #""
 #llow the associated parse action to be called once more.
 #""

 #elf.called = False


def match_only_at_col(n):
 #""
 #elper method for defining parse actions that require matching at
 # specific column in the input text.
 #""

 #ef verify_col(strg, locn, toks):
 #f col(locn, strg) != n:
 #aise ParseException(strg, locn, f"matched token not at column {n}")

 #eturn verify_col


def replace_with(repl_str):
 #""
 #elper method for common parse actions that simply return
 # literal value.  Especially useful when used with
 #class:`transform_string<ParserElement.transform_string>` ().

 #xample::

 #um = Word(nums).set_parse_action(lambda toks: int(toks[0]))
 #a = one_of("N/A NA").set_parse_action(replace_with(math.nan))
 #erm = na | num

 #erm[1, ...].parse_string("324 234 N/A 234") # -> [324, 234, nan, 234]
 #""
 #eturn lambda s, l, t: [repl_str]


def remove_quotes(s, l, t):
 #""
 #elper parse action for removing quotation marks from parsed
 #uoted strings.

 #xample::

        # by default, quotation marks are included in parsed results
 #uoted_string.parse_string("'Now is the Winter of our Discontent'") # -> ["'Now is the Winter of our Discontent'"]

        # use remove_quotes to strip quotation marks from parsed results
 #uoted_string.set_parse_action(remove_quotes)
 #uoted_string.parse_string("'Now is the Winter of our Discontent'") # -> ["Now is the Winter of our Discontent"]
 #""
 #eturn t[0][1:-1]


def with_attribute(*args, **attr_dict):
 #""
 #elper to create a validating parse action to be used with start
 #ags created with :class:`make_xml_tags` or
 #class:`make_html_tags`. Use ``with_attribute`` to qualify
 # starting tag with a required attribute value, to avoid false
 #atches on common tags such as ``<TD>`` or ``<DIV>``.

 #all ``with_attribute`` with a series of attribute names and
 #alues. Specify the list of filter attributes names and values as:

 # keyword arguments, as in ``(align="right")``, or
 # as an explicit dict with ``**`` operator, when an attribute
 #ame is also a Python reserved word, as in ``**{"class":"Customer", "align":"right"}``
 # a list of name-value tuples, as in ``(("ns1:class", "Customer"), ("ns2:align", "right"))``

 #or attribute names with a namespace prefix, you must use the second
 #orm.  Attribute names are matched insensitive to upper/lower case.

 #f just testing for ``class`` (with or without a namespace), use
 #class:`with_class`.

 #o verify that the attribute exists, but without specifying a value,
 #ass ``with_attribute.ANY_VALUE`` as the value.

 #xample::

 #tml = '''
 #div>
 #ome text
 #div type="grid">1 4 0 1 0</div>
 #div type="graph">1,3 2,3 1,1</div>
 #div>this has no type</div>
 #/div>

 #''
 #iv,div_end = make_html_tags("div")

        # only match div tag having a type attribute with value "grid"
 #iv_grid = div().set_parse_action(with_attribute(type="grid"))
 #rid_expr = div_grid + SkipTo(div | div_end)("body")
 #or grid_header in grid_expr.search_string(html):
 #rint(grid_header.body)

        # construct a match with any div tag having a type attribute, regardless of the value
 #iv_any_type = div().set_parse_action(with_attribute(type=with_attribute.ANY_VALUE))
 #iv_expr = div_any_type + SkipTo(div | div_end)("body")
 #or div_header in div_expr.search_string(html):
 #rint(div_header.body)

 #rints::

 # 4 0 1 0

 # 4 0 1 0
 #,3 2,3 1,1
 #""
 #f args:
 #ttrs = args[:]
 #lse:
 #ttrs = attr_dict.items()
 #ttrs = [(k, v) for k, v in attrs]

 #ef pa(s, l, tokens):
 #or attrName, attrValue in attrs:
 #f attrName not in tokens:
 #aise ParseException(s, l, "no matching attribute " + attrName)
 #f attrValue != with_attribute.ANY_VALUE and tokens[attrName] != attrValue:
 #aise ParseException(
 #,
 #,
 #"attribute {attrName!r} has value {tokens[attrName]!r}, must be {attrValue!r}",
 #

 #eturn pa


with_attribute.ANY_VALUE = object()  # type: ignore [attr-defined]


def with_class(classname, namespace=""):
 #""
 #implified version of :class:`with_attribute` when
 #atching on a div class - made difficult because ``class`` is
 # reserved word in Python.

 #xample::

 #tml = '''
 #div>
 #ome text
 #div class="grid">1 4 0 1 0</div>
 #div class="graph">1,3 2,3 1,1</div>
 #div>this &lt;div&gt; has no class</div>
 #/div>

 #''
 #iv,div_end = make_html_tags("div")
 #iv_grid = div().set_parse_action(with_class("grid"))

 #rid_expr = div_grid + SkipTo(div | div_end)("body")
 #or grid_header in grid_expr.search_string(html):
 #rint(grid_header.body)

 #iv_any_type = div().set_parse_action(with_class(withAttribute.ANY_VALUE))
 #iv_expr = div_any_type + SkipTo(div | div_end)("body")
 #or div_header in div_expr.search_string(html):
 #rint(div_header.body)

 #rints::

 # 4 0 1 0

 # 4 0 1 0
 #,3 2,3 1,1
 #""
 #lassattr = f"{namespace}:class" if namespace else "class"
 #eturn with_attribute(**{classattr: classname})


# pre-PEP8 compatibility symbols
# fmt: off
@replaced_by_pep8(replace_with)
def replaceWith(): ...

@replaced_by_pep8(remove_quotes)
def removeQuotes(): ...

@replaced_by_pep8(with_attribute)
def withAttribute(): ...

@replaced_by_pep8(with_class)
def withClass(): ...

@replaced_by_pep8(match_only_at_col)
def matchOnlyAtCol(): ...

# fmt: on
