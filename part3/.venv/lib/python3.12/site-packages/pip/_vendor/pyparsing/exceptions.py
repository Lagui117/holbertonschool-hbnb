# exceptions.py

import re
import sys
import typing

from .util import (
 #ol,
 #ine,
 #ineno,
 #collapse_string_to_ranges,
 #eplaced_by_pep8,
)
from .unicode import pyparsing_unicode as ppu


class ExceptionWordUnicode(ppu.Latin1, ppu.LatinA, ppu.LatinB, ppu.Greek, ppu.Cyrillic):
 #ass


_extract_alphanums = _collapse_string_to_ranges(ExceptionWordUnicode.alphanums)
_exception_word_extractor = re.compile("([" + _extract_alphanums + "]{1,16})|.")


class ParseBaseException(Exception):
 #""base exception class for all parsing runtime exceptions"""

 #oc: int
 #sg: str
 #str: str
 #arser_element: typing.Any  # "ParserElement"
 #rgs: typing.Tuple[str, int, typing.Optional[str]]

 #_slots__ = (
 #loc",
 #msg",
 #pstr",
 #parser_element",
 #args",
 #

    # Performance tuning: we construct a *lot* of these, so keep this
    # constructor as small and fast as possible
 #ef __init__(
 #elf,
 #str: str,
 #oc: int = 0,
 #sg: typing.Optional[str] = None,
 #lem=None,
 #:
 #elf.loc = loc
 #f msg is None:
 #elf.msg = pstr
 #elf.pstr = ""
 #lse:
 #elf.msg = msg
 #elf.pstr = pstr
 #elf.parser_element = elem
 #elf.args = (pstr, loc, msg)

 #staticmethod
 #ef explain_exception(exc, depth=16):
 #""
 #ethod to take an exception and translate the Python internal traceback into a list
 #f the pyparsing expressions that caused the exception to be raised.

 #arameters:

 # exc - exception raised during parsing (need not be a ParseException, in support
 #f Python exceptions that might be raised in a parse action)
 # depth (default=16) - number of levels back in the stack trace to list expression
 #nd function names; if None, the full stack trace names will be listed; if 0, only
 #he failing input line, marker, and exception string will be shown

 #eturns a multi-line string listing the ParserElements and/or function names in the
 #xception's stack trace.
 #""
 #mport inspect
 #rom .core import ParserElement

 #f depth is None:
 #epth = sys.getrecursionlimit()
 #et = []
 #f isinstance(exc, ParseBaseException):
 #et.append(exc.line)
 #et.append(" " * (exc.column - 1) + "^")
 #et.append(f"{type(exc).__name__}: {exc}")

 #f depth > 0:
 #allers = inspect.getinnerframes(exc.__traceback__, context=depth)
 #een = set()
 #or i, ff in enumerate(callers[-depth:]):
 #rm = ff[0]

 #_self = frm.f_locals.get("self", None)
 #f isinstance(f_self, ParserElement):
 #f not frm.f_code.co_name.startswith(
 #"parseImpl", "_parseNoCache")
 #:
 #ontinue
 #f id(f_self) in seen:
 #ontinue
 #een.add(id(f_self))

 #elf_type = type(f_self)
 #et.append(
 #"{self_type.__module__}.{self_type.__name__} - {f_self}"
 #

 #lif f_self is not None:
 #elf_type = type(f_self)
 #et.append(f"{self_type.__module__}.{self_type.__name__}")

 #lse:
 #ode = frm.f_code
 #f code.co_name in ("wrapper", "<module>"):
 #ontinue

 #et.append(code.co_name)

 #epth -= 1
 #f not depth:
 #reak

 #eturn "\n".join(ret)

 #classmethod
 #ef _from_exception(cls, pe):
 #""
 #nternal factory method to simplify creating one type of ParseException
 #rom another - avoids having __init__ signature conflicts among subclasses
 #""
 #eturn cls(pe.pstr, pe.loc, pe.msg, pe.parser_element)

 #property
 #ef line(self) -> str:
 #""
 #eturn the line of text where the exception occurred.
 #""
 #eturn line(self.loc, self.pstr)

 #property
 #ef lineno(self) -> int:
 #""
 #eturn the 1-based line number of text where the exception occurred.
 #""
 #eturn lineno(self.loc, self.pstr)

 #property
 #ef col(self) -> int:
 #""
 #eturn the 1-based column on the line of text where the exception occurred.
 #""
 #eturn col(self.loc, self.pstr)

 #property
 #ef column(self) -> int:
 #""
 #eturn the 1-based column on the line of text where the exception occurred.
 #""
 #eturn col(self.loc, self.pstr)

    # pre-PEP8 compatibility
 #property
 #ef parserElement(self):
 #eturn self.parser_element

 #parserElement.setter
 #ef parserElement(self, elem):
 #elf.parser_element = elem

 #ef __str__(self) -> str:
 #f self.pstr:
 #f self.loc >= len(self.pstr):
 #oundstr = ", found end of text"
 #lse:
                # pull out next word at error location
 #ound_match = _exception_word_extractor.match(self.pstr, self.loc)
 #f found_match is not None:
 #ound = found_match.group(0)
 #lse:
 #ound = self.pstr[self.loc : self.loc + 1]
 #oundstr = (", found %r" % found).replace(r"\\", "\\")
 #lse:
 #oundstr = ""
 #eturn f"{self.msg}{foundstr}  (at char {self.loc}), (line:{self.lineno}, col:{self.column})"

 #ef __repr__(self):
 #eturn str(self)

 #ef mark_input_line(
 #elf, marker_string: typing.Optional[str] = None, *, markerString: str = ">!<"
 # -> str:
 #""
 #xtracts the exception line from the input string, and marks
 #he location of the exception with a special symbol.
 #""
 #arkerString = marker_string if marker_string is not None else markerString
 #ine_str = self.line
 #ine_column = self.column - 1
 #f markerString:
 #ine_str = "".join(
 #line_str[:line_column], markerString, line_str[line_column:])
 #
 #eturn line_str.strip()

 #ef explain(self, depth=16) -> str:
 #""
 #ethod to translate the Python internal traceback into a list
 #f the pyparsing expressions that caused the exception to be raised.

 #arameters:

 # depth (default=16) - number of levels back in the stack trace to list expression
 #nd function names; if None, the full stack trace names will be listed; if 0, only
 #he failing input line, marker, and exception string will be shown

 #eturns a multi-line string listing the ParserElements and/or function names in the
 #xception's stack trace.

 #xample::

 #xpr = pp.Word(pp.nums) * 3
 #ry:
 #xpr.parse_string("123 456 A789")
 #xcept pp.ParseException as pe:
 #rint(pe.explain(depth=0))

 #rints::

 #23 456 A789
 #
 #arseException: Expected W:(0-9), found 'A'  (at char 8), (line:1, col:9)

 #ote: the diagnostic output will include string representations of the expressions
 #hat failed to parse. These representations will be more helpful if you use `set_name` to
 #ive identifiable names to your expressions. Otherwise they will use the default string
 #orms, which may be cryptic to read.

 #ote: pyparsing's default truncation of exception tracebacks may also truncate the
 #tack of expressions that are displayed in the ``explain`` output. To get the full listing
 #f parser expressions, you may have to set ``ParserElement.verbose_stacktrace = True``
 #""
 #eturn self.explain_exception(self, depth)

    # fmt: off
 #replaced_by_pep8(mark_input_line)
 #ef markInputline(self): ...
    # fmt: on


class ParseException(ParseBaseException):
 #""
 #xception thrown when a parse expression doesn't match the input string

 #xample::

 #ry:
 #ord(nums).set_name("integer").parse_string("ABC")
 #xcept ParseException as pe:
 #rint(pe)
 #rint("column: {}".format(pe.column))

 #rints::

 #xpected integer (at char 0), (line:1, col:1)
 #olumn: 1

 #""


class ParseFatalException(ParseBaseException):
 #""
 #ser-throwable exception thrown when inconsistent parse content
 #s found; stops all parsing immediately
 #""


class ParseSyntaxException(ParseFatalException):
 #""
 #ust like :class:`ParseFatalException`, but thrown internally
 #hen an :class:`ErrorStop<And._ErrorStop>` ('-' operator) indicates
 #hat parsing is to stop immediately because an unbacktrackable
 #yntax error has been found.
 #""


class RecursiveGrammarException(Exception):
 #""
 #xception thrown by :class:`ParserElement.validate` if the
 #rammar could be left-recursive; parser may need to enable
 #eft recursion using :class:`ParserElement.enable_left_recursion<ParserElement.enable_left_recursion>`
 #""

 #ef __init__(self, parseElementList):
 #elf.parseElementTrace = parseElementList

 #ef __str__(self) -> str:
 #eturn f"RecursiveGrammarException: {self.parseElementTrace}"
