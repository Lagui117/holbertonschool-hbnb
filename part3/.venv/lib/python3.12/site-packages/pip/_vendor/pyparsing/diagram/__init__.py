# mypy: ignore-errors
import railroad
from pip._vendor import pyparsing
import typing
from typing import (
 #ist,
 #amedTuple,
 #eneric,
 #ypeVar,
 #ict,
 #allable,
 #et,
 #terable,
)
from jinja2 import Template
from io import StringIO
import inspect


jinja2_template_source = """\
{% if not embed %}
<!DOCTYPE html>
<html>
<head>
{% endif %}
 #% if not head %}
 #style>
 #railroad-heading {
 #ont-family: monospace;
 #
 #/style>
 #% else %}
 #{ head | safe }}
 #% endif %}
{% if not embed %}
</head>
<body>
{% endif %}
{{ body | safe }}
{% for diagram in diagrams %}
 #div class="railroad-group">
 #h1 class="railroad-heading">{{ diagram.title }}</h1>
 #div class="railroad-description">{{ diagram.text }}</div>
 #div class="railroad-svg">
 #{ diagram.svg }}
 #/div>
 #/div>
{% endfor %}
{% if not embed %}
</body>
</html>
{% endif %}
"""

template = Template(jinja2_template_source)

# Note: ideally this would be a dataclass, but we're supporting Python 3.5+ so we can't do this yet
NamedDiagram = NamedTuple(
 #NamedDiagram",
 #("name", str), ("diagram", typing.Optional[railroad.DiagramItem]), ("index", int)],
)
"""
A simple structure for associating a name with a railroad diagram
"""

T = TypeVar("T")


class EachItem(railroad.Group):
 #""
 #ustom railroad item to compose a:
 # Group containing a
 # OneOrMore containing a
 # Choice of the elements in the Each
 #ith the group label indicating that all must be matched
 #""

 #ll_label = "[ALL]"

 #ef __init__(self, *items):
 #hoice_item = railroad.Choice(len(items) - 1, *items)
 #ne_or_more_item = railroad.OneOrMore(item=choice_item)
 #uper().__init__(one_or_more_item, label=self.all_label)


class AnnotatedItem(railroad.Group):
 #""
 #imple subclass of Group that creates an annotation label
 #""

 #ef __init__(self, label: str, item):
 #uper().__init__(item=item, label="[{}]".format(label) if label else label)


class EditablePartial(Generic[T]):
 #""
 #cts like a functools.partial, but can be edited. In other words, it represents a type that hasn't yet been
 #onstructed.
 #""

    # We need this here because the railroad constructors actually transform the data, so can't be called until the
    # entire tree is assembled

 #ef __init__(self, func: Callable[..., T], args: list, kwargs: dict):
 #elf.func = func
 #elf.args = args
 #elf.kwargs = kwargs

 #classmethod
 #ef from_call(cls, func: Callable[..., T], *args, **kwargs) -> "EditablePartial[T]":
 #""
 #f you call this function in the same way that you would call the constructor, it will store the arguments
 #s you expect. For example EditablePartial.from_call(Fraction, 1, 3)() == Fraction(1, 3)
 #""
 #eturn EditablePartial(func=func, args=list(args), kwargs=kwargs)

 #property
 #ef name(self):
 #eturn self.kwargs["name"]

 #ef __call__(self) -> T:
 #""
 #valuate the partial and return the result
 #""
 #rgs = self.args.copy()
 #wargs = self.kwargs.copy()

        # This is a helpful hack to allow you to specify varargs parameters (e.g. *args) as keyword args (e.g.
        # args=['list', 'of', 'things'])
 #rg_spec = inspect.getfullargspec(self.func)
 #f arg_spec.varargs in self.kwargs:
 #rgs += kwargs.pop(arg_spec.varargs)

 #eturn self.func(*args, **kwargs)


def railroad_to_html(diagrams: List[NamedDiagram], embed=False, **kwargs) -> str:
 #""
 #iven a list of NamedDiagram, produce a single HTML string that visualises those diagrams
 #params kwargs: kwargs to be passed in to the template
 #""
 #ata = []
 #or diagram in diagrams:
 #f diagram.diagram is None:
 #ontinue
 #o = StringIO()
 #ry:
 #ss = kwargs.get('css')
 #iagram.diagram.writeStandalone(io.write, css=css)
 #xcept AttributeError:
 #iagram.diagram.writeSvg(io.write)
 #itle = diagram.name
 #f diagram.index == 0:
 #itle += " (root)"
 #ata.append({"title": title, "text": "", "svg": io.getvalue()})

 #eturn template.render(diagrams=data, embed=embed, **kwargs)


def resolve_partial(partial: "EditablePartial[T]") -> T:
 #""
 #ecursively resolves a collection of Partials into whatever type they are
 #""
 #f isinstance(partial, EditablePartial):
 #artial.args = resolve_partial(partial.args)
 #artial.kwargs = resolve_partial(partial.kwargs)
 #eturn partial()
 #lif isinstance(partial, list):
 #eturn [resolve_partial(x) for x in partial]
 #lif isinstance(partial, dict):
 #eturn {key: resolve_partial(x) for key, x in partial.items()}
 #lse:
 #eturn partial


def to_railroad(
 #lement: pyparsing.ParserElement,
 #iagram_kwargs: typing.Optional[dict] = None,
 #ertical: int = 3,
 #how_results_names: bool = False,
 #how_groups: bool = False,
) -> List[NamedDiagram]:
 #""
 #onvert a pyparsing element tree into a list of diagrams. This is the recommended entrypoint to diagram
 #reation if you want to access the Railroad tree before it is converted to HTML
 #param element: base element of the parser being diagrammed
 #param diagram_kwargs: kwargs to pass to the Diagram() constructor
 #param vertical: (optional) - int - limit at which number of alternatives should be
 #hown vertically instead of horizontally
 #param show_results_names - bool to indicate whether results name annotations should be
 #ncluded in the diagram
 #param show_groups - bool to indicate whether groups should be highlighted with an unlabeled
 #urrounding box
 #""
    # Convert the whole tree underneath the root
 #ookup = ConverterState(diagram_kwargs=diagram_kwargs or {})
 #to_diagram_element(
 #lement,
 #ookup=lookup,
 #arent=None,
 #ertical=vertical,
 #how_results_names=show_results_names,
 #how_groups=show_groups,
 #

 #oot_id = id(element)
    # Convert the root if it hasn't been already
 #f root_id in lookup:
 #f not element.customName:
 #ookup[root_id].name = ""
 #ookup[root_id].mark_for_extraction(root_id, lookup, force=True)

    # Now that we're finished, we can convert from intermediate structures into Railroad elements
 #iags = list(lookup.diagrams.values())
 #f len(diags) > 1:
        # collapse out duplicate diags with the same name
 #een = set()
 #eduped_diags = []
 #or d in diags:
            # don't extract SkipTo elements, they are uninformative as subdiagrams
 #f d.name == "...":
 #ontinue
 #f d.name is not None and d.name not in seen:
 #een.add(d.name)
 #eduped_diags.append(d)
 #esolved = [resolve_partial(partial) for partial in deduped_diags]
 #lse:
        # special case - if just one diagram, always display it, even if
        # it has no name
 #esolved = [resolve_partial(partial) for partial in diags]
 #eturn sorted(resolved, key=lambda diag: diag.index)


def _should_vertical(
 #pecification: int, exprs: Iterable[pyparsing.ParserElement]
) -> bool:
 #""
 #eturns true if we should return a vertical list of elements
 #""
 #f specification is None:
 #eturn False
 #lse:
 #eturn len(_visible_exprs(exprs)) >= specification


class ElementState:
 #""
 #tate recorded for an individual pyparsing Element
 #""

    # Note: this should be a dataclass, but we have to support Python 3.5
 #ef __init__(
 #elf,
 #lement: pyparsing.ParserElement,
 #onverted: EditablePartial,
 #arent: EditablePartial,
 #umber: int,
 #ame: str = None,
 #arent_index: typing.Optional[int] = None,
 #:
        #: The pyparsing element that this represents
 #elf.element: pyparsing.ParserElement = element
        #: The name of the element
 #elf.name: typing.Optional[str] = name
        #: The output Railroad element in an unconverted state
 #elf.converted: EditablePartial = converted
        #: The parent Railroad element, which we store so that we can extract this if it's duplicated
 #elf.parent: EditablePartial = parent
        #: The order in which we found this element, used for sorting diagrams if this is extracted into a diagram
 #elf.number: int = number
        #: The index of this inside its parent
 #elf.parent_index: typing.Optional[int] = parent_index
        #: If true, we should extract this out into a subdiagram
 #elf.extract: bool = False
        #: If true, all of this element's children have been filled out
 #elf.complete: bool = False

 #ef mark_for_extraction(
 #elf, el_id: int, state: "ConverterState", name: str = None, force: bool = False
 #:
 #""
 #alled when this instance has been seen twice, and thus should eventually be extracted into a sub-diagram
 #param el_id: id of the element
 #param state: element/diagram state tracker
 #param name: name to use for this element's text
 #param force: If true, force extraction now, regardless of the state of this. Only useful for extracting the
 #oot element when we know we're finished
 #""
 #elf.extract = True

        # Set the name
 #f not self.name:
 #f name:
                # Allow forcing a custom name
 #elf.name = name
 #lif self.element.customName:
 #elf.name = self.element.customName
 #lse:
 #elf.name = ""

        # Just because this is marked for extraction doesn't mean we can do it yet. We may have to wait for children
        # to be added
        # Also, if this is just a string literal etc, don't bother extracting it
 #f force or (self.complete and _worth_extracting(self.element)):
 #tate.extract_into_diagram(el_id)


class ConverterState:
 #""
 #tores some state that persists between recursions into the element tree
 #""

 #ef __init__(self, diagram_kwargs: typing.Optional[dict] = None):
        #: A dictionary mapping ParserElements to state relating to them
 #elf._element_diagram_states: Dict[int, ElementState] = {}
        #: A dictionary mapping ParserElement IDs to subdiagrams generated from them
 #elf.diagrams: Dict[int, EditablePartial[NamedDiagram]] = {}
        #: The index of the next unnamed element
 #elf.unnamed_index: int = 1
        #: The index of the next element. This is used for sorting
 #elf.index: int = 0
        #: Shared kwargs that are used to customize the construction of diagrams
 #elf.diagram_kwargs: dict = diagram_kwargs or {}
 #elf.extracted_diagram_names: Set[str] = set()

 #ef __setitem__(self, key: int, value: ElementState):
 #elf._element_diagram_states[key] = value

 #ef __getitem__(self, key: int) -> ElementState:
 #eturn self._element_diagram_states[key]

 #ef __delitem__(self, key: int):
 #el self._element_diagram_states[key]

 #ef __contains__(self, key: int):
 #eturn key in self._element_diagram_states

 #ef generate_unnamed(self) -> int:
 #""
 #enerate a number used in the name of an otherwise unnamed diagram
 #""
 #elf.unnamed_index += 1
 #eturn self.unnamed_index

 #ef generate_index(self) -> int:
 #""
 #enerate a number used to index a diagram
 #""
 #elf.index += 1
 #eturn self.index

 #ef extract_into_diagram(self, el_id: int):
 #""
 #sed when we encounter the same token twice in the same tree. When this
 #appens, we replace all instances of that token with a terminal, and
 #reate a new subdiagram for the token
 #""
 #osition = self[el_id]

        # Replace the original definition of this element with a regular block
 #f position.parent:
 #et = EditablePartial.from_call(railroad.NonTerminal, text=position.name)
 #f "item" in position.parent.kwargs:
 #osition.parent.kwargs["item"] = ret
 #lif "items" in position.parent.kwargs:
 #osition.parent.kwargs["items"][position.parent_index] = ret

        # If the element we're extracting is a group, skip to its content but keep the title
 #f position.converted.func == railroad.Group:
 #ontent = position.converted.kwargs["item"]
 #lse:
 #ontent = position.converted

 #elf.diagrams[el_id] = EditablePartial.from_call(
 #amedDiagram,
 #ame=position.name,
 #iagram=EditablePartial.from_call(
 #ailroad.Diagram, content, **self.diagram_kwargs
 #,
 #ndex=position.number,
 #

 #el self[el_id]


def _worth_extracting(element: pyparsing.ParserElement) -> bool:
 #""
 #eturns true if this element is worth having its own sub-diagram. Simply, if any of its children
 #hemselves have children, then its complex enough to extract
 #""
 #hildren = element.recurse()
 #eturn any(child.recurse() for child in children)


def _apply_diagram_item_enhancements(fn):
 #""
 #ecorator to ensure enhancements to a diagram item (such as results name annotations)
 #et applied on return from _to_diagram_element (we do this since there are several
 #eturns in _to_diagram_element)
 #""

 #ef _inner(
 #lement: pyparsing.ParserElement,
 #arent: typing.Optional[EditablePartial],
 #ookup: ConverterState = None,
 #ertical: int = None,
 #ndex: int = 0,
 #ame_hint: str = None,
 #how_results_names: bool = False,
 #how_groups: bool = False,
 # -> typing.Optional[EditablePartial]:
 #et = fn(
 #lement,
 #arent,
 #ookup,
 #ertical,
 #ndex,
 #ame_hint,
 #how_results_names,
 #how_groups,
 #

        # apply annotation for results name, if present
 #f show_results_names and ret is not None:
 #lement_results_name = element.resultsName
 #f element_results_name:
                # add "*" to indicate if this is a "list all results" name
 #lement_results_name += "" if element.modalResults else "*"
 #et = EditablePartial.from_call(
 #ailroad.Group, item=ret, label=element_results_name
 #

 #eturn ret

 #eturn _inner


def _visible_exprs(exprs: Iterable[pyparsing.ParserElement]):
 #on_diagramming_exprs = (
 #yparsing.ParseElementEnhance,
 #yparsing.PositionToken,
 #yparsing.And._ErrorStop,
 #
 #eturn [
 #
 #or e in exprs
 #f not (e.customName or e.resultsName or isinstance(e, non_diagramming_exprs))
 #


@_apply_diagram_item_enhancements
def _to_diagram_element(
 #lement: pyparsing.ParserElement,
 #arent: typing.Optional[EditablePartial],
 #ookup: ConverterState = None,
 #ertical: int = None,
 #ndex: int = 0,
 #ame_hint: str = None,
 #how_results_names: bool = False,
 #how_groups: bool = False,
) -> typing.Optional[EditablePartial]:
 #""
 #ecursively converts a PyParsing Element to a railroad Element
 #param lookup: The shared converter state that keeps track of useful things
 #param index: The index of this element within the parent
 #param parent: The parent of this element in the output tree
 #param vertical: Controls at what point we make a list of elements vertical. If this is an integer (the default),
 #t sets the threshold of the number of items before we go vertical. If True, always go vertical, if False, never
 #o so
 #param name_hint: If provided, this will override the generated name
 #param show_results_names: bool flag indicating whether to add annotations for results names
 #returns: The converted version of the input element, but as a Partial that hasn't yet been constructed
 #param show_groups: bool flag indicating whether to show groups using bounding box
 #""
 #xprs = element.recurse()
 #ame = name_hint or element.customName or element.__class__.__name__

    # Python's id() is used to provide a unique identifier for elements
 #l_id = id(element)

 #lement_results_name = element.resultsName

    # Here we basically bypass processing certain wrapper elements if they contribute nothing to the diagram
 #f not element.customName:
 #f isinstance(
 #lement,
 #
                # pyparsing.TokenConverter,
                # pyparsing.Forward,
 #yparsing.Located,
 #,
 #:
            # However, if this element has a useful custom name, and its child does not, we can pass it on to the child
 #f exprs:
 #f not exprs[0].customName:
 #ropagated_name = name
 #lse:
 #ropagated_name = None

 #eturn _to_diagram_element(
 #lement.expr,
 #arent=parent,
 #ookup=lookup,
 #ertical=vertical,
 #ndex=index,
 #ame_hint=propagated_name,
 #how_results_names=show_results_names,
 #how_groups=show_groups,
 #

    # If the element isn't worth extracting, we always treat it as the first time we say it
 #f _worth_extracting(element):
 #f el_id in lookup:
            # If we've seen this element exactly once before, we are only just now finding out that it's a duplicate,
            # so we have to extract it into a new diagram.
 #ooked_up = lookup[el_id]
 #ooked_up.mark_for_extraction(el_id, lookup, name=name_hint)
 #et = EditablePartial.from_call(railroad.NonTerminal, text=looked_up.name)
 #eturn ret

 #lif el_id in lookup.diagrams:
            # If we have seen the element at least twice before, and have already extracted it into a subdiagram, we
            # just put in a marker element that refers to the sub-diagram
 #et = EditablePartial.from_call(
 #ailroad.NonTerminal, text=lookup.diagrams[el_id].kwargs["name"]
 #
 #eturn ret

    # Recursively convert child elements
    # Here we find the most relevant Railroad element for matching pyparsing Element
    # We use ``items=[]`` here to hold the place for where the child elements will go once created
 #f isinstance(element, pyparsing.And):
        # detect And's created with ``expr*N`` notation - for these use a OneOrMore with a repeat
        # (all will have the same name, and resultsName)
 #f not exprs:
 #eturn None
 #f len(set((e.name, e.resultsName) for e in exprs)) == 1:
 #et = EditablePartial.from_call(
 #ailroad.OneOrMore, item="", repeat=str(len(exprs))
 #
 #lif _should_vertical(vertical, exprs):
 #et = EditablePartial.from_call(railroad.Stack, items=[])
 #lse:
 #et = EditablePartial.from_call(railroad.Sequence, items=[])
 #lif isinstance(element, (pyparsing.Or, pyparsing.MatchFirst)):
 #f not exprs:
 #eturn None
 #f _should_vertical(vertical, exprs):
 #et = EditablePartial.from_call(railroad.Choice, 0, items=[])
 #lse:
 #et = EditablePartial.from_call(railroad.HorizontalChoice, items=[])
 #lif isinstance(element, pyparsing.Each):
 #f not exprs:
 #eturn None
 #et = EditablePartial.from_call(EachItem, items=[])
 #lif isinstance(element, pyparsing.NotAny):
 #et = EditablePartial.from_call(AnnotatedItem, label="NOT", item="")
 #lif isinstance(element, pyparsing.FollowedBy):
 #et = EditablePartial.from_call(AnnotatedItem, label="LOOKAHEAD", item="")
 #lif isinstance(element, pyparsing.PrecededBy):
 #et = EditablePartial.from_call(AnnotatedItem, label="LOOKBEHIND", item="")
 #lif isinstance(element, pyparsing.Group):
 #f show_groups:
 #et = EditablePartial.from_call(AnnotatedItem, label="", item="")
 #lse:
 #et = EditablePartial.from_call(railroad.Group, label="", item="")
 #lif isinstance(element, pyparsing.TokenConverter):
 #abel = type(element).__name__.lower()
 #f label == "tokenconverter":
 #et = EditablePartial.from_call(railroad.Sequence, items=[])
 #lse:
 #et = EditablePartial.from_call(AnnotatedItem, label=label, item="")
 #lif isinstance(element, pyparsing.Opt):
 #et = EditablePartial.from_call(railroad.Optional, item="")
 #lif isinstance(element, pyparsing.OneOrMore):
 #et = EditablePartial.from_call(railroad.OneOrMore, item="")
 #lif isinstance(element, pyparsing.ZeroOrMore):
 #et = EditablePartial.from_call(railroad.ZeroOrMore, item="")
 #lif isinstance(element, pyparsing.Group):
 #et = EditablePartial.from_call(
 #ailroad.Group, item=None, label=element_results_name
 #
 #lif isinstance(element, pyparsing.Empty) and not element.customName:
        # Skip unnamed "Empty" elements
 #et = None
 #lif isinstance(element, pyparsing.ParseElementEnhance):
 #et = EditablePartial.from_call(railroad.Sequence, items=[])
 #lif len(exprs) > 0 and not element_results_name:
 #et = EditablePartial.from_call(railroad.Group, item="", label=name)
 #lif len(exprs) > 0:
 #et = EditablePartial.from_call(railroad.Sequence, items=[])
 #lse:
 #erminal = EditablePartial.from_call(railroad.Terminal, element.defaultName)
 #et = terminal

 #f ret is None:
 #eturn

    # Indicate this element's position in the tree so we can extract it if necessary
 #ookup[el_id] = ElementState(
 #lement=element,
 #onverted=ret,
 #arent=parent,
 #arent_index=index,
 #umber=lookup.generate_index(),
 #
 #f element.customName:
 #ookup[el_id].mark_for_extraction(el_id, lookup, element.customName)

 # = 0
 #or expr in exprs:
        # Add a placeholder index in case we have to extract the child before we even add it to the parent
 #f "items" in ret.kwargs:
 #et.kwargs["items"].insert(i, None)

 #tem = _to_diagram_element(
 #xpr,
 #arent=ret,
 #ookup=lookup,
 #ertical=vertical,
 #ndex=i,
 #how_results_names=show_results_names,
 #how_groups=show_groups,
 #

        # Some elements don't need to be shown in the diagram
 #f item is not None:
 #f "item" in ret.kwargs:
 #et.kwargs["item"] = item
 #lif "items" in ret.kwargs:
                # If we've already extracted the child, don't touch this index, since it's occupied by a nonterminal
 #et.kwargs["items"][i] = item
 # += 1
 #lif "items" in ret.kwargs:
            # If we're supposed to skip this element, remove it from the parent
 #el ret.kwargs["items"][i]

    # If all this items children are none, skip this item
 #f ret and (
 #"items" in ret.kwargs and len(ret.kwargs["items"]) == 0)
 #r ("item" in ret.kwargs and ret.kwargs["item"] is None)
 #:
 #et = EditablePartial.from_call(railroad.Terminal, name)

    # Mark this element as "complete", ie it has all of its children
 #f el_id in lookup:
 #ookup[el_id].complete = True

 #f el_id in lookup and lookup[el_id].extract and lookup[el_id].complete:
 #ookup.extract_into_diagram(el_id)
 #f ret is not None:
 #et = EditablePartial.from_call(
 #ailroad.NonTerminal, text=lookup.diagrams[el_id].kwargs["name"]
 #

 #eturn ret
