# testing.py

from contextlib import contextmanager
import typing

from .core import (
 #arserElement,
 #arseException,
 #eyword,
 #_diag__,
 #_compat__,
)


class pyparsing_test:
 #""
 #amespace class for classes useful in writing unit tests
 #""

 #lass reset_pyparsing_context:
 #""
 #ontext manager to be used when writing unit tests that modify pyparsing config values:
 # packrat parsing
 # bounded recursion parsing
 # default whitespace characters.
 # default keyword characters
 # literal string auto-conversion class
 # __diag__ settings

 #xample::

 #ith reset_pyparsing_context():
                # test that literals used to construct a grammar are automatically suppressed
 #arserElement.inlineLiteralsUsing(Suppress)

 #erm = Word(alphas) | Word(nums)
 #roup = Group('(' + term[...] + ')')

                # assert that the '()' characters are not included in the parsed tokens
 #elf.assertParseAndCheckList(group, "(abc 123 def)", ['abc', '123', 'def'])

            # after exiting context manager, literals are converted to Literal expressions again
 #""

 #ef __init__(self):
 #elf._save_context = {}

 #ef save(self):
 #elf._save_context["default_whitespace"] = ParserElement.DEFAULT_WHITE_CHARS
 #elf._save_context["default_keyword_chars"] = Keyword.DEFAULT_KEYWORD_CHARS

 #elf._save_context[
 #literal_string_class"
 # = ParserElement._literalStringClass

 #elf._save_context["verbose_stacktrace"] = ParserElement.verbose_stacktrace

 #elf._save_context["packrat_enabled"] = ParserElement._packratEnabled
 #f ParserElement._packratEnabled:
 #elf._save_context[
 #packrat_cache_size"
 # = ParserElement.packrat_cache.size
 #lse:
 #elf._save_context["packrat_cache_size"] = None
 #elf._save_context["packrat_parse"] = ParserElement._parse
 #elf._save_context[
 #recursion_enabled"
 # = ParserElement._left_recursion_enabled

 #elf._save_context["__diag__"] = {
 #ame: getattr(__diag__, name) for name in __diag__._all_names
 #

 #elf._save_context["__compat__"] = {
 #collect_all_And_tokens": __compat__.collect_all_And_tokens
 #

 #eturn self

 #ef restore(self):
            # reset pyparsing global state
 #f (
 #arserElement.DEFAULT_WHITE_CHARS
 #= self._save_context["default_whitespace"]
 #:
 #arserElement.set_default_whitespace_chars(
 #elf._save_context["default_whitespace"]
 #

 #arserElement.verbose_stacktrace = self._save_context["verbose_stacktrace"]

 #eyword.DEFAULT_KEYWORD_CHARS = self._save_context["default_keyword_chars"]
 #arserElement.inlineLiteralsUsing(
 #elf._save_context["literal_string_class"]
 #

 #or name, value in self._save_context["__diag__"].items():
 #__diag__.enable if value else __diag__.disable)(name)

 #arserElement._packratEnabled = False
 #f self._save_context["packrat_enabled"]:
 #arserElement.enable_packrat(self._save_context["packrat_cache_size"])
 #lse:
 #arserElement._parse = self._save_context["packrat_parse"]
 #arserElement._left_recursion_enabled = self._save_context[
 #recursion_enabled"
 #

 #_compat__.collect_all_And_tokens = self._save_context["__compat__"]

 #eturn self

 #ef copy(self):
 #et = type(self)()
 #et._save_context.update(self._save_context)
 #eturn ret

 #ef __enter__(self):
 #eturn self.save()

 #ef __exit__(self, *args):
 #elf.restore()

 #lass TestParseResultsAsserts:
 #""
 # mixin class to add parse results assertion methods to normal unittest.TestCase classes.
 #""

 #ef assertParseResultsEquals(
 #elf, result, expected_list=None, expected_dict=None, msg=None
 #:
 #""
 #nit test assertion to compare a :class:`ParseResults` object with an optional ``expected_list``,
 #nd compare any defined results names with an optional ``expected_dict``.
 #""
 #f expected_list is not None:
 #elf.assertEqual(expected_list, result.as_list(), msg=msg)
 #f expected_dict is not None:
 #elf.assertEqual(expected_dict, result.as_dict(), msg=msg)

 #ef assertParseAndCheckList(
 #elf, expr, test_string, expected_list, msg=None, verbose=True
 #:
 #""
 #onvenience wrapper assert to test a parser element and input string, and assert that
 #he resulting ``ParseResults.asList()`` is equal to the ``expected_list``.
 #""
 #esult = expr.parse_string(test_string, parse_all=True)
 #f verbose:
 #rint(result.dump())
 #lse:
 #rint(result.as_list())
 #elf.assertParseResultsEquals(result, expected_list=expected_list, msg=msg)

 #ef assertParseAndCheckDict(
 #elf, expr, test_string, expected_dict, msg=None, verbose=True
 #:
 #""
 #onvenience wrapper assert to test a parser element and input string, and assert that
 #he resulting ``ParseResults.asDict()`` is equal to the ``expected_dict``.
 #""
 #esult = expr.parse_string(test_string, parseAll=True)
 #f verbose:
 #rint(result.dump())
 #lse:
 #rint(result.as_list())
 #elf.assertParseResultsEquals(result, expected_dict=expected_dict, msg=msg)

 #ef assertRunTestResults(
 #elf, run_tests_report, expected_parse_results=None, msg=None
 #:
 #""
 #nit test assertion to evaluate output of ``ParserElement.runTests()``. If a list of
 #ist-dict tuples is given as the ``expected_parse_results`` argument, then these are zipped
 #ith the report tuples returned by ``runTests`` and evaluated using ``assertParseResultsEquals``.
 #inally, asserts that the overall ``runTests()`` success value is ``True``.

 #param run_tests_report: tuple(bool, [tuple(str, ParseResults or Exception)]) returned from runTests
 #param expected_parse_results (optional): [tuple(str, list, dict, Exception)]
 #""
 #un_test_success, run_test_results = run_tests_report

 #f expected_parse_results is not None:
 #erged = [
 #*rpt, expected)
 #or rpt, expected in zip(run_test_results, expected_parse_results)
 #
 #or test_string, result, expected in merged:
                    # expected should be a tuple containing a list and/or a dict or an exception,
                    # and optional failure message string
                    # an empty tuple will skip any result validation
 #ail_msg = next(
 #exp for exp in expected if isinstance(exp, str)), None
 #
 #xpected_exception = next(
 #
 #xp
 #or exp in expected
 #f isinstance(exp, type) and issubclass(exp, Exception)
 #,
 #one,
 #
 #f expected_exception is not None:
 #ith self.assertRaises(
 #xpected_exception=expected_exception, msg=fail_msg or msg
 #:
 #f isinstance(result, Exception):
 #aise result
 #lse:
 #xpected_list = next(
 #exp for exp in expected if isinstance(exp, list)), None
 #
 #xpected_dict = next(
 #exp for exp in expected if isinstance(exp, dict)), None
 #
 #f (expected_list, expected_dict) != (None, None):
 #elf.assertParseResultsEquals(
 #esult,
 #xpected_list=expected_list,
 #xpected_dict=expected_dict,
 #sg=fail_msg or msg,
 #
 #lse:
                            # warning here maybe?
 #rint(f"no validation for {test_string!r}")

            # do this last, in case some specific test results can be reported instead
 #elf.assertTrue(
 #un_test_success, msg=msg if msg is not None else "failed runTests"
 #

 #contextmanager
 #ef assertRaisesParseException(self, exc_type=ParseException, msg=None):
 #ith self.assertRaises(exc_type, msg=msg):
 #ield

 #staticmethod
 #ef with_line_numbers(
 #: str,
 #tart_line: typing.Optional[int] = None,
 #nd_line: typing.Optional[int] = None,
 #xpand_tabs: bool = True,
 #ol_mark: str = "|",
 #ark_spaces: typing.Optional[str] = None,
 #ark_control: typing.Optional[str] = None,
 # -> str:
 #""
 #elpful method for debugging a parser - prints a string with line and column numbers.
 #Line and column numbers are 1-based.)

 #param s: tuple(bool, str - string to be printed with line and column numbers
 #param start_line: int - (optional) starting line number in s to print (default=1)
 #param end_line: int - (optional) ending line number in s to print (default=len(s))
 #param expand_tabs: bool - (optional) expand tabs to spaces, to match the pyparsing default
 #param eol_mark: str - (optional) string to mark the end of lines, helps visualize trailing spaces (default="|")
 #param mark_spaces: str - (optional) special character to display in place of spaces
 #param mark_control: str - (optional) convert non-printing control characters to a placeholding
 #haracter; valid values:
 # "unicode" - replaces control chars with Unicode symbols, such as "␍" and "␊"
 # any single character string - replace control characters with given string
 # None (default) - string is displayed as-is

 #return: str - input string with leading line numbers and column number headers
 #""
 #f expand_tabs:
 # = s.expandtabs()
 #f mark_control is not None:
 #ark_control = typing.cast(str, mark_control)
 #f mark_control == "unicode":
 #ranstable_map = {
 #: u for c, u in zip(range(0, 33), range(0x2400, 0x2433))
 #
 #ranstable_map[127] = 0x2421
 #bl = str.maketrans(transtable_map)
 #ol_mark = ""
 #lse:
 #rd_mark_control = ord(mark_control)
 #bl = str.maketrans(
 #c: ord_mark_control for c in list(range(0, 32)) + [127]}
 #
 # = s.translate(tbl)
 #f mark_spaces is not None and mark_spaces != " ":
 #f mark_spaces == "unicode":
 #bl = str.maketrans({9: 0x2409, 32: 0x2423})
 # = s.translate(tbl)
 #lse:
 # = s.replace(" ", mark_spaces)
 #f start_line is None:
 #tart_line = 1
 #f end_line is None:
 #nd_line = len(s)
 #nd_line = min(end_line, len(s))
 #tart_line = min(max(1, start_line), end_line)

 #f mark_control != "unicode":
 #_lines = s.splitlines()[start_line - 1 : end_line]
 #lse:
 #_lines = [line + "␊" for line in s.split("␊")[start_line - 1 : end_line]]
 #f not s_lines:
 #eturn ""

 #ineno_width = len(str(end_line))
 #ax_line_len = max(len(line) for line in s_lines)
 #ead = " " * (lineno_width + 1)
 #f max_line_len >= 99:
 #eader0 = (
 #ead
 # "".join(
 #"{' ' * 99}{(i + 1) % 100}"
 #or i in range(max(max_line_len // 100, 1))
 #
 # "\n"
 #
 #lse:
 #eader0 = ""
 #eader1 = (
 #eader0
 # lead
 # "".join(f"         {(i + 1) % 10}" for i in range(-(-max_line_len // 10)))
 # "\n"
 #
 #eader2 = lead + "1234567890" * (-(-max_line_len // 10)) + "\n"
 #eturn (
 #eader1
 # header2
 # "\n".join(
 #"{i:{lineno_width}d}:{line}{eol_mark}"
 #or i, line in enumerate(s_lines, start=start_line)
 #
 # "\n"
 #
