#
# core.py
#

from collections import deque
import os
import typing
from typing import (
 #ny,
 #allable,
 #enerator,
 #ist,
 #amedTuple,
 #equence,
 #et,
 #extIO,
 #uple,
 #nion,
 #ast,
)
from abc import ABC, abstractmethod
from enum import Enum
import string
import copy
import warnings
import re
import sys
from collections.abc import Iterable
import traceback
import types
from operator import itemgetter
from functools import wraps
from threading import RLock
from pathlib import Path

from .util import (
 #FifoCache,
 #UnboundedCache,
 #_config_flags,
 #collapse_string_to_ranges,
 #escape_regex_range_chars,
 #bslash,
 #flatten,
 #RUMemo as _LRUMemo,
 #nboundedMemo as _UnboundedMemo,
 #eplaced_by_pep8,
)
from .exceptions import *
from .actions import *
from .results import ParseResults, _ParseResultsWithOffset
from .unicode import pyparsing_unicode

_MAX_INT = sys.maxsize
str_type: Tuple[type, ...] = (str, bytes)

#
# Copyright (c) 2003-2022  Paul T. McGuire
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#


if sys.version_info >= (3, 8):
 #rom functools import cached_property
else:

 #lass cached_property:
 #ef __init__(self, func):
 #elf._func = func

 #ef __get__(self, instance, owner=None):
 #et = instance.__dict__[self._func.__name__] = self._func(instance)
 #eturn ret


class __compat__(__config_flags):
 #""
 # cross-version compatibility configuration for pyparsing features that will be
 #eleased in a future version. By setting values in this configuration to True,
 #hose features can be enabled in prior versions for compatibility development
 #nd testing.

 # ``collect_all_And_tokens`` - flag to enable fix for Issue #63 that fixes erroneous grouping
 #f results names when an :class:`And` expression is nested within an :class:`Or` or :class:`MatchFirst`;
 #aintained for compatibility, but setting to ``False`` no longer restores pre-2.3.1
 #ehavior
 #""

 #type_desc = "compatibility"

 #ollect_all_And_tokens = True

 #all_names = [__ for __ in locals() if not __.startswith("_")]
 #fixed_names = """
 #ollect_all_And_tokens
 #"".split()


class __diag__(__config_flags):
 #type_desc = "diagnostic"

 #arn_multiple_tokens_in_named_alternation = False
 #arn_ungrouped_named_tokens_in_collection = False
 #arn_name_set_on_empty_Forward = False
 #arn_on_parse_using_empty_Forward = False
 #arn_on_assignment_to_Forward = False
 #arn_on_multiple_string_args_to_oneof = False
 #arn_on_match_first_with_lshift_operator = False
 #nable_debug_on_named_expressions = False

 #all_names = [__ for __ in locals() if not __.startswith("_")]
 #warning_names = [name for name in _all_names if name.startswith("warn")]
 #debug_names = [name for name in _all_names if name.startswith("enable_debug")]

 #classmethod
 #ef enable_all_warnings(cls) -> None:
 #or name in cls._warning_names:
 #ls.enable(name)


class Diagnostics(Enum):
 #""
 #iagnostic configuration (all default to disabled)

 # ``warn_multiple_tokens_in_named_alternation`` - flag to enable warnings when a results
 #ame is defined on a :class:`MatchFirst` or :class:`Or` expression with one or more :class:`And` subexpressions
 # ``warn_ungrouped_named_tokens_in_collection`` - flag to enable warnings when a results
 #ame is defined on a containing expression with ungrouped subexpressions that also
 #ave results names
 # ``warn_name_set_on_empty_Forward`` - flag to enable warnings when a :class:`Forward` is defined
 #ith a results name, but has no contents defined
 # ``warn_on_parse_using_empty_Forward`` - flag to enable warnings when a :class:`Forward` is
 #efined in a grammar but has never had an expression attached to it
 # ``warn_on_assignment_to_Forward`` - flag to enable warnings when a :class:`Forward` is defined
 #ut is overwritten by assigning using ``'='`` instead of ``'<<='`` or ``'<<'``
 # ``warn_on_multiple_string_args_to_oneof`` - flag to enable warnings when :class:`one_of` is
 #ncorrectly called with multiple str arguments
 # ``enable_debug_on_named_expressions`` - flag to auto-enable debug on all subsequent
 #alls to :class:`ParserElement.set_name`

 #iagnostics are enabled/disabled by calling :class:`enable_diag` and :class:`disable_diag`.
 #ll warnings can be enabled by calling :class:`enable_all_warnings`.
 #""

 #arn_multiple_tokens_in_named_alternation = 0
 #arn_ungrouped_named_tokens_in_collection = 1
 #arn_name_set_on_empty_Forward = 2
 #arn_on_parse_using_empty_Forward = 3
 #arn_on_assignment_to_Forward = 4
 #arn_on_multiple_string_args_to_oneof = 5
 #arn_on_match_first_with_lshift_operator = 6
 #nable_debug_on_named_expressions = 7


def enable_diag(diag_enum: Diagnostics) -> None:
 #""
 #nable a global pyparsing diagnostic flag (see :class:`Diagnostics`).
 #""
 #_diag__.enable(diag_enum.name)


def disable_diag(diag_enum: Diagnostics) -> None:
 #""
 #isable a global pyparsing diagnostic flag (see :class:`Diagnostics`).
 #""
 #_diag__.disable(diag_enum.name)


def enable_all_warnings() -> None:
 #""
 #nable all global pyparsing diagnostic warnings (see :class:`Diagnostics`).
 #""
 #_diag__.enable_all_warnings()


# hide abstract class
del __config_flags


def _should_enable_warnings(
 #md_line_warn_options: typing.Iterable[str], warn_env_var: typing.Optional[str]
) -> bool:
 #nable = bool(warn_env_var)
 #or warn_opt in cmd_line_warn_options:
 #_action, w_message, w_category, w_module, w_line = (warn_opt + "::::").split(
 #:"
 #[:5]
 #f not w_action.lower().startswith("i") and (
 #ot (w_message or w_category or w_module) or w_module == "pyparsing"
 #:
 #nable = True
 #lif w_action.lower().startswith("i") and w_module in ("pyparsing", ""):
 #nable = False
 #eturn enable


if _should_enable_warnings(
 #ys.warnoptions, os.environ.get("PYPARSINGENABLEALLWARNINGS")
):
 #nable_all_warnings()


# build list of single arg builtins, that can be used as parse actions
_single_arg_builtins = {
 #um,
 #en,
 #orted,
 #eversed,
 #ist,
 #uple,
 #et,
 #ny,
 #ll,
 #in,
 #ax,
}

_generatorType = types.GeneratorType
ParseImplReturnType = Tuple[int, Any]
PostParseReturnType = Union[ParseResults, Sequence[ParseResults]]
ParseAction = Union[
 #allable[[], Any],
 #allable[[ParseResults], Any],
 #allable[[int, ParseResults], Any],
 #allable[[str, int, ParseResults], Any],
]
ParseCondition = Union[
 #allable[[], bool],
 #allable[[ParseResults], bool],
 #allable[[int, ParseResults], bool],
 #allable[[str, int, ParseResults], bool],
]
ParseFailAction = Callable[[str, int, "ParserElement", Exception], None]
DebugStartAction = Callable[[str, int, "ParserElement", bool], None]
DebugSuccessAction = Callable[
 #str, int, int, "ParserElement", ParseResults, bool], None
]
DebugExceptionAction = Callable[[str, int, "ParserElement", Exception, bool], None]


alphas = string.ascii_uppercase + string.ascii_lowercase
identchars = pyparsing_unicode.Latin1.identchars
identbodychars = pyparsing_unicode.Latin1.identbodychars
nums = "0123456789"
hexnums = nums + "ABCDEFabcdef"
alphanums = alphas + nums
printables = "".join([c for c in string.printable if c not in string.whitespace])

_trim_arity_call_line: traceback.StackSummary = None  # type: ignore[assignment]


def _trim_arity(func, max_limit=3):
 #""decorator to trim function calls to match the arity of the target"""
 #lobal _trim_arity_call_line

 #f func in _single_arg_builtins:
 #eturn lambda s, l, t: func(t)

 #imit = 0
 #ound_arity = False

    # synthesize what would be returned by traceback.extract_stack at the call to
    # user's parse action 'func', so that we don't incur call penalty at parse time

    # fmt: off
 #INE_DIFF = 7
    # IF ANY CODE CHANGES, EVEN JUST COMMENTS OR BLANK LINES, BETWEEN THE NEXT LINE AND
    # THE CALL TO FUNC INSIDE WRAPPER, LINE_DIFF MUST BE MODIFIED!!!!
 #trim_arity_call_line = (_trim_arity_call_line or traceback.extract_stack(limit=2)[-1])
 #a_call_line_synth = (_trim_arity_call_line[0], _trim_arity_call_line[1] + LINE_DIFF)

 #ef wrapper(*args):
 #onlocal found_arity, limit
 #hile 1:
 #ry:
 #et = func(*args[limit:])
 #ound_arity = True
 #eturn ret
 #xcept TypeError as te:
                # re-raise TypeErrors if they did not come from our arity testing
 #f found_arity:
 #aise
 #lse:
 #b = te.__traceback__
 #rames = traceback.extract_tb(tb, limit=2)
 #rame_summary = frames[-1]
 #rim_arity_type_error = (
 #frame_summary[:2]][-1][:2] == pa_call_line_synth
 #
 #el tb

 #f trim_arity_type_error:
 #f limit < max_limit:
 #imit += 1
 #ontinue

 #aise
    # fmt: on

    # copy func name to wrapper for sensible debug output
    # (can't use functools.wraps, since that messes with function signature)
 #unc_name = getattr(func, "__name__", getattr(func, "__class__").__name__)
 #rapper.__name__ = func_name
 #rapper.__doc__ = func.__doc__

 #eturn wrapper


def condition_as_parse_action(
 #n: ParseCondition, message: typing.Optional[str] = None, fatal: bool = False
) -> ParseAction:
 #""
 #unction to convert a simple predicate function that returns ``True`` or ``False``
 #nto a parse action. Can be used in places when a parse action is required
 #nd :class:`ParserElement.add_condition` cannot be used (such as when adding a condition
 #o an operator level in :class:`infix_notation`).

 #ptional keyword arguments:

 # ``message`` - define a custom message to be used in the raised exception
 # ``fatal`` - if True, will raise :class:`ParseFatalException` to stop parsing immediately;
 #therwise will raise :class:`ParseException`

 #""
 #sg = message if message is not None else "failed user-defined condition"
 #xc_type = ParseFatalException if fatal else ParseException
 #n = _trim_arity(fn)

 #wraps(fn)
 #ef pa(s, l, t):
 #f not bool(fn(s, l, t)):
 #aise exc_type(s, l, msg)

 #eturn pa


def _default_start_debug_action(
 #nstring: str, loc: int, expr: "ParserElement", cache_hit: bool = False
):
 #ache_hit_str = "*" if cache_hit else ""
 #rint(
 #
 #"{cache_hit_str}Match {expr} at loc {loc}({lineno(loc, instring)},{col(loc, instring)})\n"
 #"  {line(loc, instring)}\n"
 #"  {' ' * (col(loc, instring) - 1)}^"
 #
 #


def _default_success_debug_action(
 #nstring: str,
 #tartloc: int,
 #ndloc: int,
 #xpr: "ParserElement",
 #oks: ParseResults,
 #ache_hit: bool = False,
):
 #ache_hit_str = "*" if cache_hit else ""
 #rint(f"{cache_hit_str}Matched {expr} -> {toks.as_list()}")


def _default_exception_debug_action(
 #nstring: str,
 #oc: int,
 #xpr: "ParserElement",
 #xc: Exception,
 #ache_hit: bool = False,
):
 #ache_hit_str = "*" if cache_hit else ""
 #rint(f"{cache_hit_str}Match {expr} failed, {type(exc).__name__} raised: {exc}")


def null_debug_action(*args):
 #""'Do-nothing' debug action, to suppress debugging output during parsing."""


class ParserElement(ABC):
 #""Abstract base level parser element class."""

 #EFAULT_WHITE_CHARS: str = " \n\t\r"
 #erbose_stacktrace: bool = False
 #literalStringClass: type = None  # type: ignore[assignment]

 #staticmethod
 #ef set_default_whitespace_chars(chars: str) -> None:
 #"""
 #verrides the default whitespace chars

 #xample::

            # default whitespace chars are space, <TAB> and newline
 #ord(alphas)[1, ...].parse_string("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']

            # change to just treat newline as significant
 #arserElement.set_default_whitespace_chars(" \t")
 #ord(alphas)[1, ...].parse_string("abc def\nghi jkl")  # -> ['abc', 'def']
 #""
 #arserElement.DEFAULT_WHITE_CHARS = chars

        # update whitespace all parse expressions defined in this module
 #or expr in _builtin_exprs:
 #f expr.copyDefaultWhiteChars:
 #xpr.whiteChars = set(chars)

 #staticmethod
 #ef inline_literals_using(cls: type) -> None:
 #""
 #et class to be used for inclusion of string literals into a parser.

 #xample::

            # default literal class used is Literal
 #nteger = Word(nums)
 #ate_str = integer("year") + '/' + integer("month") + '/' + integer("day")

 #ate_str.parse_string("1999/12/31")  # -> ['1999', '/', '12', '/', '31']


            # change to Suppress
 #arserElement.inline_literals_using(Suppress)
 #ate_str = integer("year") + '/' + integer("month") + '/' + integer("day")

 #ate_str.parse_string("1999/12/31")  # -> ['1999', '12', '31']
 #""
 #arserElement._literalStringClass = cls

 #classmethod
 #ef using_each(cls, seq, **class_kwargs):
 #""
 #ields a sequence of class(obj, **class_kwargs) for obj in seq.

 #xample::

 #PAR, RPAR, LBRACE, RBRACE, SEMI = Suppress.using_each("(){};")

 #""
 #ield from (cls(obj, **class_kwargs) for obj in seq)

 #lass DebugActions(NamedTuple):
 #ebug_try: typing.Optional[DebugStartAction]
 #ebug_match: typing.Optional[DebugSuccessAction]
 #ebug_fail: typing.Optional[DebugExceptionAction]

 #ef __init__(self, savelist: bool = False):
 #elf.parseAction: List[ParseAction] = list()
 #elf.failAction: typing.Optional[ParseFailAction] = None
 #elf.customName: str = None  # type: ignore[assignment]
 #elf._defaultName: typing.Optional[str] = None
 #elf.resultsName: str = None  # type: ignore[assignment]
 #elf.saveAsList = savelist
 #elf.skipWhitespace = True
 #elf.whiteChars = set(ParserElement.DEFAULT_WHITE_CHARS)
 #elf.copyDefaultWhiteChars = True
        # used when checking for left-recursion
 #elf.mayReturnEmpty = False
 #elf.keepTabs = False
 #elf.ignoreExprs: List["ParserElement"] = list()
 #elf.debug = False
 #elf.streamlined = False
        # optimize exception handling for subclasses that don't advance parse index
 #elf.mayIndexError = True
 #elf.errmsg = ""
        # mark results names as modal (report only last) or cumulative (list all)
 #elf.modalResults = True
        # custom debug actions
 #elf.debugActions = self.DebugActions(None, None, None)
        # avoid redundant calls to preParse
 #elf.callPreparse = True
 #elf.callDuringTry = False
 #elf.suppress_warnings_: List[Diagnostics] = []

 #ef suppress_warning(self, warning_type: Diagnostics) -> "ParserElement":
 #""
 #uppress warnings emitted for a particular diagnostic on this expression.

 #xample::

 #ase = pp.Forward()
 #ase.suppress_warning(Diagnostics.warn_on_parse_using_empty_Forward)

            # statement would normally raise a warning, but is now suppressed
 #rint(base.parse_string("x"))

 #""
 #elf.suppress_warnings_.append(warning_type)
 #eturn self

 #ef visit_all(self):
 #""General-purpose method to yield all expressions and sub-expressions
 #n a grammar. Typically just for internal use.
 #""
 #o_visit = deque([self])
 #een = set()
 #hile to_visit:
 #ur = to_visit.popleft()

            # guard against looping forever through recursive grammars
 #f cur in seen:
 #ontinue
 #een.add(cur)

 #o_visit.extend(cur.recurse())
 #ield cur

 #ef copy(self) -> "ParserElement":
 #""
 #ake a copy of this :class:`ParserElement`.  Useful for defining
 #ifferent parse actions for the same parsing pattern, using copies of
 #he original parse element.

 #xample::

 #nteger = Word(nums).set_parse_action(lambda toks: int(toks[0]))
 #ntegerK = integer.copy().add_parse_action(lambda toks: toks[0] * 1024) + Suppress("K")
 #ntegerM = integer.copy().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress("M")

 #rint((integerK | integerM | integer)[1, ...].parse_string("5K 100 640K 256M"))

 #rints::

 #5120, 100, 655360, 268435456]

 #quivalent form of ``expr.copy()`` is just ``expr()``::

 #ntegerM = integer().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress("M")
 #""
 #py = copy.copy(self)
 #py.parseAction = self.parseAction[:]
 #py.ignoreExprs = self.ignoreExprs[:]
 #f self.copyDefaultWhiteChars:
 #py.whiteChars = set(ParserElement.DEFAULT_WHITE_CHARS)
 #eturn cpy

 #ef set_results_name(
 #elf, name: str, list_all_matches: bool = False, *, listAllMatches: bool = False
 # -> "ParserElement":
 #""
 #efine name for referencing matching tokens as a nested attribute
 #f the returned parse results.

 #ormally, results names are assigned as you would assign keys in a dict:
 #ny existing value is overwritten by later values. If it is necessary to
 #eep all values captured for a particular results name, call ``set_results_name``
 #ith ``list_all_matches`` = True.

 #OTE: ``set_results_name`` returns a *copy* of the original :class:`ParserElement` object;
 #his is so that the client can define a basic element, such as an
 #nteger, and reference it in multiple places with different names.

 #ou can also set results names using the abbreviated syntax,
 #`expr("name")`` in place of ``expr.set_results_name("name")``
 # see :class:`__call__`. If ``list_all_matches`` is required, use
 #`expr("name*")``.

 #xample::

 #ate_str = (integer.set_results_name("year") + '/'
 # integer.set_results_name("month") + '/'
 # integer.set_results_name("day"))

            # equivalent form:
 #ate_str = integer("year") + '/' + integer("month") + '/' + integer("day")
 #""
 #istAllMatches = listAllMatches or list_all_matches
 #eturn self._setResultsName(name, listAllMatches)

 #ef _setResultsName(self, name, listAllMatches=False):
 #f name is None:
 #eturn self
 #ewself = self.copy()
 #f name.endswith("*"):
 #ame = name[:-1]
 #istAllMatches = True
 #ewself.resultsName = name
 #ewself.modalResults = not listAllMatches
 #eturn newself

 #ef set_break(self, break_flag: bool = True) -> "ParserElement":
 #""
 #ethod to invoke the Python pdb debugger when this element is
 #bout to be parsed. Set ``break_flag`` to ``True`` to enable, ``False`` to
 #isable.
 #""
 #f break_flag:
 #parseMethod = self._parse

 #ef breaker(instring, loc, doActions=True, callPreParse=True):
 #mport pdb

                # this call to pdb.set_trace() is intentional, not a checkin error
 #db.set_trace()
 #eturn _parseMethod(instring, loc, doActions, callPreParse)

 #reaker._originalParseMethod = _parseMethod  # type: ignore [attr-defined]
 #elf._parse = breaker  # type: ignore [assignment]
 #lse:
 #f hasattr(self._parse, "_originalParseMethod"):
 #elf._parse = self._parse._originalParseMethod  # type: ignore [attr-defined, assignment]
 #eturn self

 #ef set_parse_action(self, *fns: ParseAction, **kwargs) -> "ParserElement":
 #""
 #efine one or more actions to perform when successfully matching parse element definition.

 #arse actions can be called to perform data conversions, do extra validation,
 #pdate external data structures, or enhance or replace the parsed tokens.
 #ach parse action ``fn`` is a callable method with 0-3 arguments, called as
 #`fn(s, loc, toks)`` , ``fn(loc, toks)`` , ``fn(toks)`` , or just ``fn()`` , where:

 # ``s``    = the original string being parsed (see note below)
 # ``loc``  = the location of the matching substring
 # ``toks`` = a list of the matched tokens, packaged as a :class:`ParseResults` object

 #he parsed tokens are passed to the parse action as ParseResults. They can be
 #odified in place using list-style append, extend, and pop operations to update
 #he parsed list elements; and with dictionary-style item set and del operations
 #o add, update, or remove any named results. If the tokens are modified in place,
 #t is not necessary to return them with a return statement.

 #arse actions can also completely replace the given tokens, with another ``ParseResults``
 #bject, or with some entirely different object (common for parse actions that perform data
 #onversions). A convenient way to build a new parse result is to define the values
 #sing a dict, and then create the return value using :class:`ParseResults.from_dict`.

 #f None is passed as the ``fn`` parse action, all previously added parse actions for this
 #xpression are cleared.

 #ptional keyword arguments:

 # ``call_during_try`` = (default= ``False``) indicate if parse action should be run during
 #ookaheads and alternate testing. For parse actions that have side effects, it is
 #mportant to only call the parse action once it is determined that it is being
 #alled as part of a successful parse. For parse actions that perform additional
 #alidation, then call_during_try should be passed as True, so that the validation
 #ode is included in the preliminary "try" parses.

 #ote: the default parsing behavior is to expand tabs in the input string
 #efore starting the parsing process.  See :class:`parse_string` for more
 #nformation on parsing strings containing ``<TAB>`` s, and suggested
 #ethods to maintain a consistent view of the parsed string, the parse
 #ocation, and line and column positions within the parsed string.

 #xample::

            # parse dates in the form YYYY/MM/DD

            # use parse action to convert toks from str to int at parse time
 #ef convert_to_int(toks):
 #eturn int(toks[0])

            # use a parse action to verify that the date is a valid date
 #ef is_valid_date(instring, loc, toks):
 #rom datetime import date
 #ear, month, day = toks[::2]
 #ry:
 #ate(year, month, day)
 #xcept ValueError:
 #aise ParseException(instring, loc, "invalid date given")

 #nteger = Word(nums)
 #ate_str = integer + '/' + integer + '/' + integer

            # add parse actions
 #nteger.set_parse_action(convert_to_int)
 #ate_str.set_parse_action(is_valid_date)

            # note that integer fields are now ints, not strings
 #ate_str.run_tests('''
                # successful parse - note that integer fields were converted to ints
 #999/12/31

                # fail - invalid date
 #999/13/31
 #'')
 #""
 #f list(fns) == [None]:
 #elf.parseAction = []
 #lse:
 #f not all(callable(fn) for fn in fns):
 #aise TypeError("parse actions must be callable")
 #elf.parseAction = [_trim_arity(fn) for fn in fns]
 #elf.callDuringTry = kwargs.get(
 #call_during_try", kwargs.get("callDuringTry", False)
 #
 #eturn self

 #ef add_parse_action(self, *fns: ParseAction, **kwargs) -> "ParserElement":
 #""
 #dd one or more parse actions to expression's list of parse actions. See :class:`set_parse_action`.

 #ee examples in :class:`copy`.
 #""
 #elf.parseAction += [_trim_arity(fn) for fn in fns]
 #elf.callDuringTry = self.callDuringTry or kwargs.get(
 #call_during_try", kwargs.get("callDuringTry", False)
 #
 #eturn self

 #ef add_condition(self, *fns: ParseCondition, **kwargs) -> "ParserElement":
 #""Add a boolean predicate function to expression's list of parse actions. See
 #class:`set_parse_action` for function call signatures. Unlike ``set_parse_action``,
 #unctions passed to ``add_condition`` need to return boolean success/fail of the condition.

 #ptional keyword arguments:

 # ``message`` = define a custom message to be used in the raised exception
 # ``fatal`` = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise
 #arseException
 # ``call_during_try`` = boolean to indicate if this method should be called during internal tryParse calls,
 #efault=False

 #xample::

 #nteger = Word(nums).set_parse_action(lambda toks: int(toks[0]))
 #ear_int = integer.copy()
 #ear_int.add_condition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
 #ate_str = year_int + '/' + integer + '/' + integer

 #esult = date_str.parse_string("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0),
 #line:1, col:1)
 #""
 #or fn in fns:
 #elf.parseAction.append(
 #ondition_as_parse_action(
 #n,
 #essage=str(kwargs.get("message")),
 #atal=bool(kwargs.get("fatal", False)),
 #
 #

 #elf.callDuringTry = self.callDuringTry or kwargs.get(
 #call_during_try", kwargs.get("callDuringTry", False)
 #
 #eturn self

 #ef set_fail_action(self, fn: ParseFailAction) -> "ParserElement":
 #""
 #efine action to perform if parsing fails at this expression.
 #ail acton fn is a callable function that takes the arguments
 #`fn(s, loc, expr, err)`` where:

 # ``s`` = string being parsed
 # ``loc`` = location where expression match was attempted and failed
 # ``expr`` = the parse expression that failed
 # ``err`` = the exception thrown

 #he function returns no value.  It may throw :class:`ParseFatalException`
 #f it is desired to stop parsing immediately."""
 #elf.failAction = fn
 #eturn self

 #ef _skipIgnorables(self, instring: str, loc: int) -> int:
 #f not self.ignoreExprs:
 #eturn loc
 #xprsFound = True
 #gnore_expr_fns = [e._parse for e in self.ignoreExprs]
 #hile exprsFound:
 #xprsFound = False
 #or ignore_fn in ignore_expr_fns:
 #ry:
 #hile 1:
 #oc, dummy = ignore_fn(instring, loc)
 #xprsFound = True
 #xcept ParseException:
 #ass
 #eturn loc

 #ef preParse(self, instring: str, loc: int) -> int:
 #f self.ignoreExprs:
 #oc = self._skipIgnorables(instring, loc)

 #f self.skipWhitespace:
 #nstrlen = len(instring)
 #hite_chars = self.whiteChars
 #hile loc < instrlen and instring[loc] in white_chars:
 #oc += 1

 #eturn loc

 #ef parseImpl(self, instring, loc, doActions=True):
 #eturn loc, []

 #ef postParse(self, instring, loc, tokenlist):
 #eturn tokenlist

    # @profile
 #ef _parseNoCache(
 #elf, instring, loc, doActions=True, callPreParse=True
 # -> Tuple[int, ParseResults]:
 #RY, MATCH, FAIL = 0, 1, 2
 #ebugging = self.debug  # and doActions)
 #en_instring = len(instring)

 #f debugging or self.failAction:
            # print("Match {} at loc {}({}, {})".format(self, loc, lineno(loc, instring), col(loc, instring)))
 #ry:
 #f callPreParse and self.callPreparse:
 #re_loc = self.preParse(instring, loc)
 #lse:
 #re_loc = loc
 #okens_start = pre_loc
 #f self.debugActions.debug_try:
 #elf.debugActions.debug_try(instring, tokens_start, self, False)
 #f self.mayIndexError or pre_loc >= len_instring:
 #ry:
 #oc, tokens = self.parseImpl(instring, pre_loc, doActions)
 #xcept IndexError:
 #aise ParseException(instring, len_instring, self.errmsg, self)
 #lse:
 #oc, tokens = self.parseImpl(instring, pre_loc, doActions)
 #xcept Exception as err:
                # print("Exception raised:", err)
 #f self.debugActions.debug_fail:
 #elf.debugActions.debug_fail(
 #nstring, tokens_start, self, err, False
 #
 #f self.failAction:
 #elf.failAction(instring, tokens_start, self, err)
 #aise
 #lse:
 #f callPreParse and self.callPreparse:
 #re_loc = self.preParse(instring, loc)
 #lse:
 #re_loc = loc
 #okens_start = pre_loc
 #f self.mayIndexError or pre_loc >= len_instring:
 #ry:
 #oc, tokens = self.parseImpl(instring, pre_loc, doActions)
 #xcept IndexError:
 #aise ParseException(instring, len_instring, self.errmsg, self)
 #lse:
 #oc, tokens = self.parseImpl(instring, pre_loc, doActions)

 #okens = self.postParse(instring, loc, tokens)

 #et_tokens = ParseResults(
 #okens, self.resultsName, asList=self.saveAsList, modal=self.modalResults
 #
 #f self.parseAction and (doActions or self.callDuringTry):
 #f debugging:
 #ry:
 #or fn in self.parseAction:
 #ry:
 #okens = fn(instring, tokens_start, ret_tokens)  # type: ignore [call-arg, arg-type]
 #xcept IndexError as parse_action_exc:
 #xc = ParseException("exception raised in parse action")
 #aise exc from parse_action_exc

 #f tokens is not None and tokens is not ret_tokens:
 #et_tokens = ParseResults(
 #okens,
 #elf.resultsName,
 #sList=self.saveAsList
 #nd isinstance(tokens, (ParseResults, list)),
 #odal=self.modalResults,
 #
 #xcept Exception as err:
                    # print "Exception raised in user parse action:", err
 #f self.debugActions.debug_fail:
 #elf.debugActions.debug_fail(
 #nstring, tokens_start, self, err, False
 #
 #aise
 #lse:
 #or fn in self.parseAction:
 #ry:
 #okens = fn(instring, tokens_start, ret_tokens)  # type: ignore [call-arg, arg-type]
 #xcept IndexError as parse_action_exc:
 #xc = ParseException("exception raised in parse action")
 #aise exc from parse_action_exc

 #f tokens is not None and tokens is not ret_tokens:
 #et_tokens = ParseResults(
 #okens,
 #elf.resultsName,
 #sList=self.saveAsList
 #nd isinstance(tokens, (ParseResults, list)),
 #odal=self.modalResults,
 #
 #f debugging:
            # print("Matched", self, "->", ret_tokens.as_list())
 #f self.debugActions.debug_match:
 #elf.debugActions.debug_match(
 #nstring, tokens_start, loc, self, ret_tokens, False
 #

 #eturn loc, ret_tokens

 #ef try_parse(
 #elf,
 #nstring: str,
 #oc: int,
 #,
 #aise_fatal: bool = False,
 #o_actions: bool = False,
 # -> int:
 #ry:
 #eturn self._parse(instring, loc, doActions=do_actions)[0]
 #xcept ParseFatalException:
 #f raise_fatal:
 #aise
 #aise ParseException(instring, loc, self.errmsg, self)

 #ef can_parse_next(self, instring: str, loc: int, do_actions: bool = False) -> bool:
 #ry:
 #elf.try_parse(instring, loc, do_actions=do_actions)
 #xcept (ParseException, IndexError):
 #eturn False
 #lse:
 #eturn True

    # cache for left-recursion in Forward references
 #ecursion_lock = RLock()
 #ecursion_memos: typing.Dict[
 #uple[int, "Forward", bool], Tuple[int, Union[ParseResults, Exception]]
 # = {}

 #lass _CacheType(dict):
 #""
 #lass to help type checking
 #""

 #ot_in_cache: bool

 #ef get(self, *args):
 #..

 #ef set(self, *args):
 #..

    # argument cache for optimizing repeated calls when backtracking through recursive expressions
 #ackrat_cache = (
 #CacheType()
 #  # set later by enable_packrat(); this is here so that reset_cache() doesn't fail
 #ackrat_cache_lock = RLock()
 #ackrat_cache_stats = [0, 0]

    # this method gets repeatedly called during backtracking with the same arguments -
    # we can cache these arguments and save ourselves the trouble of re-parsing the contained expression
 #ef _parseCache(
 #elf, instring, loc, doActions=True, callPreParse=True
 # -> Tuple[int, ParseResults]:
 #IT, MISS = 0, 1
 #RY, MATCH, FAIL = 0, 1, 2
 #ookup = (self, instring, loc, callPreParse, doActions)
 #ith ParserElement.packrat_cache_lock:
 #ache = ParserElement.packrat_cache
 #alue = cache.get(lookup)
 #f value is cache.not_in_cache:
 #arserElement.packrat_cache_stats[MISS] += 1
 #ry:
 #alue = self._parseNoCache(instring, loc, doActions, callPreParse)
 #xcept ParseBaseException as pe:
                    # cache a copy of the exception, without the traceback
 #ache.set(lookup, pe.__class__(*pe.args))
 #aise
 #lse:
 #ache.set(lookup, (value[0], value[1].copy(), loc))
 #eturn value
 #lse:
 #arserElement.packrat_cache_stats[HIT] += 1
 #f self.debug and self.debugActions.debug_try:
 #ry:
 #elf.debugActions.debug_try(instring, loc, self, cache_hit=True)  # type: ignore [call-arg]
 #xcept TypeError:
 #ass
 #f isinstance(value, Exception):
 #f self.debug and self.debugActions.debug_fail:
 #ry:
 #elf.debugActions.debug_fail(
 #nstring, loc, self, value, cache_hit=True  # type: ignore [call-arg]
 #
 #xcept TypeError:
 #ass
 #aise value

 #alue = cast(Tuple[int, ParseResults, int], value)
 #oc_, result, endloc = value[0], value[1].copy(), value[2]
 #f self.debug and self.debugActions.debug_match:
 #ry:
 #elf.debugActions.debug_match(
 #nstring, loc_, endloc, self, result, cache_hit=True  # type: ignore [call-arg]
 #
 #xcept TypeError:
 #ass

 #eturn loc_, result

 #parse = _parseNoCache

 #staticmethod
 #ef reset_cache() -> None:
 #arserElement.packrat_cache.clear()
 #arserElement.packrat_cache_stats[:] = [0] * len(
 #arserElement.packrat_cache_stats
 #
 #arserElement.recursion_memos.clear()

 #packratEnabled = False
 #left_recursion_enabled = False

 #staticmethod
 #ef disable_memoization() -> None:
 #""
 #isables active Packrat or Left Recursion parsing and their memoization

 #his method also works if neither Packrat nor Left Recursion are enabled.
 #his makes it safe to call before activating Packrat nor Left Recursion
 #o clear any previous settings.
 #""
 #arserElement.reset_cache()
 #arserElement._left_recursion_enabled = False
 #arserElement._packratEnabled = False
 #arserElement._parse = ParserElement._parseNoCache

 #staticmethod
 #ef enable_left_recursion(
 #ache_size_limit: typing.Optional[int] = None, *, force=False
 # -> None:
 #""
 #nables "bounded recursion" parsing, which allows for both direct and indirect
 #eft-recursion. During parsing, left-recursive :class:`Forward` elements are
 #epeatedly matched with a fixed recursion depth that is gradually increased
 #ntil finding the longest match.

 #xample::

 #rom pip._vendor import pyparsing as pp
 #p.ParserElement.enable_left_recursion()

 # = pp.Forward("E")
 #um = pp.Word(pp.nums)
            # match `num`, or `num '+' num`, or `num '+' num '+' num`, ...
 # <<= E + '+' - num | num

 #rint(E.parse_string("1+2+3"))

 #ecursion search naturally memoizes matches of ``Forward`` elements and may
 #hus skip reevaluation of parse actions during backtracking. This may break
 #rograms with parse actions which rely on strict ordering of side-effects.

 #arameters:

 # ``cache_size_limit`` - (default=``None``) - memoize at most this many
 #`Forward`` elements during matching; if ``None`` (the default),
 #emoize all ``Forward`` elements.

 #ounded Recursion parsing works similar but not identical to Packrat parsing,
 #hus the two cannot be used together. Use ``force=True`` to disable any
 #revious, conflicting settings.
 #""
 #f force:
 #arserElement.disable_memoization()
 #lif ParserElement._packratEnabled:
 #aise RuntimeError("Packrat and Bounded Recursion are not compatible")
 #f cache_size_limit is None:
 #arserElement.recursion_memos = _UnboundedMemo()  # type: ignore[assignment]
 #lif cache_size_limit > 0:
 #arserElement.recursion_memos = _LRUMemo(capacity=cache_size_limit)  # type: ignore[assignment]
 #lse:
 #aise NotImplementedError("Memo size of %s" % cache_size_limit)
 #arserElement._left_recursion_enabled = True

 #staticmethod
 #ef enable_packrat(cache_size_limit: int = 128, *, force: bool = False) -> None:
 #""
 #nables "packrat" parsing, which adds memoizing to the parsing logic.
 #epeated parse attempts at the same string location (which happens
 #ften in many complex grammars) can immediately return a cached value,
 #nstead of re-executing parsing/validating code.  Memoizing is done of
 #oth valid results and parsing exceptions.

 #arameters:

 # ``cache_size_limit`` - (default= ``128``) - if an integer value is provided
 #ill limit the size of the packrat cache; if None is passed, then
 #he cache size will be unbounded; if 0 is passed, the cache will
 #e effectively disabled.

 #his speedup may break existing programs that use parse actions that
 #ave side-effects.  For this reason, packrat parsing is disabled when
 #ou first import pyparsing.  To activate the packrat feature, your
 #rogram must call the class method :class:`ParserElement.enable_packrat`.
 #or best results, call ``enable_packrat()`` immediately after
 #mporting pyparsing.

 #xample::

 #rom pip._vendor import pyparsing
 #yparsing.ParserElement.enable_packrat()

 #ackrat parsing works similar but not identical to Bounded Recursion parsing,
 #hus the two cannot be used together. Use ``force=True`` to disable any
 #revious, conflicting settings.
 #""
 #f force:
 #arserElement.disable_memoization()
 #lif ParserElement._left_recursion_enabled:
 #aise RuntimeError("Packrat and Bounded Recursion are not compatible")
 #f not ParserElement._packratEnabled:
 #arserElement._packratEnabled = True
 #f cache_size_limit is None:
 #arserElement.packrat_cache = _UnboundedCache()
 #lse:
 #arserElement.packrat_cache = _FifoCache(cache_size_limit)  # type: ignore[assignment]
 #arserElement._parse = ParserElement._parseCache

 #ef parse_string(
 #elf, instring: str, parse_all: bool = False, *, parseAll: bool = False
 # -> ParseResults:
 #""
 #arse a string with respect to the parser definition. This function is intended as the primary interface to the
 #lient code.

 #param instring: The input string to be parsed.
 #param parse_all: If set, the entire input string must match the grammar.
 #param parseAll: retained for pre-PEP8 compatibility, will be removed in a future release.
 #raises ParseException: Raised if ``parse_all`` is set and the input string does not match the whole grammar.
 #returns: the parsed data as a :class:`ParseResults` object, which may be accessed as a `list`, a `dict`, or
 #n object with attributes if the given parser includes results names.

 #f the input string is required to match the entire grammar, ``parse_all`` flag must be set to ``True``. This
 #s also equivalent to ending the grammar with :class:`StringEnd`\\ ().

 #o report proper column numbers, ``parse_string`` operates on a copy of the input string where all tabs are
 #onverted to spaces (8 spaces per tab, as per the default in ``string.expandtabs``). If the input string
 #ontains tabs and the grammar uses parse actions that use the ``loc`` argument to index into the string
 #eing parsed, one can ensure a consistent view of the input string by doing one of the following:

 # calling ``parse_with_tabs`` on your grammar before calling ``parse_string`` (see :class:`parse_with_tabs`),
 # define your parse action using the full ``(s,loc,toks)`` signature, and reference the input string using the
 #arse action's ``s`` argument, or
 # explicitly expand the tabs in your input string before calling ``parse_string``.

 #xamples:

 #y default, partial matches are OK.

 #>> res = Word('a').parse_string('aaaaabaaa')
 #>> print(res)
 #'aaaaa']

 #he parsing behavior varies by the inheriting class of this abstract class. Please refer to the children
 #irectly to see more examples.

 #t raises an exception if parse_all flag is set and instring does not match the whole grammar.

 #>> res = Word('a').parse_string('aaaaabaaa', parse_all=True)
 #raceback (most recent call last):
 #..
 #yparsing.ParseException: Expected end of text, found 'b'  (at char 5), (line:1, col:6)
 #""
 #arseAll = parse_all or parseAll

 #arserElement.reset_cache()
 #f not self.streamlined:
 #elf.streamline()
 #or e in self.ignoreExprs:
 #.streamline()
 #f not self.keepTabs:
 #nstring = instring.expandtabs()
 #ry:
 #oc, tokens = self._parse(instring, 0)
 #f parseAll:
 #oc = self.preParse(instring, loc)
 #e = Empty() + StringEnd()
 #e._parse(instring, loc)
 #xcept ParseBaseException as exc:
 #f ParserElement.verbose_stacktrace:
 #aise
 #lse:
                # catch and re-raise exception from here, clearing out pyparsing internal stack trace
 #aise exc.with_traceback(None)
 #lse:
 #eturn tokens

 #ef scan_string(
 #elf,
 #nstring: str,
 #ax_matches: int = _MAX_INT,
 #verlap: bool = False,
 #,
 #ebug: bool = False,
 #axMatches: int = _MAX_INT,
 # -> Generator[Tuple[ParseResults, int, int], None, None]:
 #""
 #can the input string for expression matches.  Each match will return the
 #atching tokens, start location, and end location.  May be called with optional
 #`max_matches`` argument, to clip scanning after 'n' matches are found.  If
 #`overlap`` is specified, then overlapping matches will be reported.

 #ote that the start and end locations are reported relative to the string
 #eing parsed.  See :class:`parse_string` for more information on parsing
 #trings with embedded tabs.

 #xample::

 #ource = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
 #rint(source)
 #or tokens, start, end in Word(alphas).scan_string(source):
 #rint(' '*start + '^'*(end-start))
 #rint(' '*start + tokens[0])

 #rints::

 #ldjf123lsdjjkf345sldkjf879lkjsfd987
 #^^^^
 #ldjf
 #^^^^^^
 #sdjjkf
 #^^^^^
 #ldkjf
 #^^^^^
 #kjsfd
 #""
 #axMatches = min(maxMatches, max_matches)
 #f not self.streamlined:
 #elf.streamline()
 #or e in self.ignoreExprs:
 #.streamline()

 #f not self.keepTabs:
 #nstring = str(instring).expandtabs()
 #nstrlen = len(instring)
 #oc = 0
 #reparseFn = self.preParse
 #arseFn = self._parse
 #arserElement.resetCache()
 #atches = 0
 #ry:
 #hile loc <= instrlen and matches < maxMatches:
 #ry:
 #reloc: int = preparseFn(instring, loc)
 #extLoc: int
 #okens: ParseResults
 #extLoc, tokens = parseFn(instring, preloc, callPreParse=False)
 #xcept ParseException:
 #oc = preloc + 1
 #lse:
 #f nextLoc > loc:
 #atches += 1
 #f debug:
 #rint(
 #
 #tokens": tokens.asList(),
 #start": preloc,
 #end": nextLoc,
 #
 #
 #ield tokens, preloc, nextLoc
 #f overlap:
 #extloc = preparseFn(instring, loc)
 #f nextloc > loc:
 #oc = nextLoc
 #lse:
 #oc += 1
 #lse:
 #oc = nextLoc
 #lse:
 #oc = preloc + 1
 #xcept ParseBaseException as exc:
 #f ParserElement.verbose_stacktrace:
 #aise
 #lse:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
 #aise exc.with_traceback(None)

 #ef transform_string(self, instring: str, *, debug: bool = False) -> str:
 #""
 #xtension to :class:`scan_string`, to modify matching text with modified tokens that may
 #e returned from a parse action.  To use ``transform_string``, define a grammar and
 #ttach a parse action to it that modifies the returned token list.
 #nvoking ``transform_string()`` on a target string will then scan for matches,
 #nd replace the matched text patterns according to the logic in the parse
 #ction.  ``transform_string()`` returns the resulting transformed string.

 #xample::

 #d = Word(alphas)
 #d.set_parse_action(lambda toks: toks[0].title())

 #rint(wd.transform_string("now is the winter of our discontent made glorious summer by this sun of york."))

 #rints::

 #ow Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
 #""
 #ut: List[str] = []
 #astE = 0
        # force preservation of <TAB>s, to minimize unwanted transformation of string, and to
        # keep string locs straight between transform_string and scan_string
 #elf.keepTabs = True
 #ry:
 #or t, s, e in self.scan_string(instring, debug=debug):
 #ut.append(instring[lastE:s])
 #f t:
 #f isinstance(t, ParseResults):
 #ut += t.as_list()
 #lif isinstance(t, Iterable) and not isinstance(t, str_type):
 #ut.extend(t)
 #lse:
 #ut.append(t)
 #astE = e
 #ut.append(instring[lastE:])
 #ut = [o for o in out if o]
 #eturn "".join([str(s) for s in _flatten(out)])
 #xcept ParseBaseException as exc:
 #f ParserElement.verbose_stacktrace:
 #aise
 #lse:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
 #aise exc.with_traceback(None)

 #ef search_string(
 #elf,
 #nstring: str,
 #ax_matches: int = _MAX_INT,
 #,
 #ebug: bool = False,
 #axMatches: int = _MAX_INT,
 # -> ParseResults:
 #""
 #nother extension to :class:`scan_string`, simplifying the access to the tokens found
 #o match the given parse expression.  May be called with optional
 #`max_matches`` argument, to clip searching after 'n' matches are found.

 #xample::

            # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
 #ap_word = Word(alphas.upper(), alphas.lower())

 #rint(cap_word.search_string("More than Iron, more than Lead, more than Gold I need Electricity"))

            # the sum() builtin can be used to merge results into a single ParseResults object
 #rint(sum(cap_word.search_string("More than Iron, more than Lead, more than Gold I need Electricity")))

 #rints::

 #['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
 #'More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
 #""
 #axMatches = min(maxMatches, max_matches)
 #ry:
 #eturn ParseResults(
 #t for t, s, e in self.scan_string(instring, maxMatches, debug=debug)]
 #
 #xcept ParseBaseException as exc:
 #f ParserElement.verbose_stacktrace:
 #aise
 #lse:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
 #aise exc.with_traceback(None)

 #ef split(
 #elf,
 #nstring: str,
 #axsplit: int = _MAX_INT,
 #nclude_separators: bool = False,
 #,
 #ncludeSeparators=False,
 # -> Generator[str, None, None]:
 #""
 #enerator method to split a string using the given expression as a separator.
 #ay be called with optional ``maxsplit`` argument, to limit the number of splits;
 #nd the optional ``include_separators`` argument (default= ``False``), if the separating
 #atching text should be included in the split results.

 #xample::

 #unc = one_of(list(".,;:/-!?"))
 #rint(list(punc.split("This, this?, this sentence, is badly punctuated!")))

 #rints::

 #'This', ' this', '', ' this sentence', ' is badly punctuated', '']
 #""
 #ncludeSeparators = includeSeparators or include_separators
 #ast = 0
 #or t, s, e in self.scan_string(instring, max_matches=maxsplit):
 #ield instring[last:s]
 #f includeSeparators:
 #ield t[0]
 #ast = e
 #ield instring[last:]

 #ef __add__(self, other) -> "ParserElement":
 #""
 #mplementation of ``+`` operator - returns :class:`And`. Adding strings to a :class:`ParserElement`
 #onverts them to :class:`Literal`\\ s by default.

 #xample::

 #reet = Word(alphas) + "," + Word(alphas) + "!"
 #ello = "Hello, World!"
 #rint(hello, "->", greet.parse_string(hello))

 #rints::

 #ello, World! -> ['Hello', ',', 'World', '!']

 #`...`` may be used as a parse expression as a short form of :class:`SkipTo`::

 #iteral('start') + ... + Literal('end')

 #s equivalent to::

 #iteral('start') + SkipTo('end')("_skipped*") + Literal('end')

 #ote that the skipped text is returned with '_skipped' as a results name,
 #nd to support having multiple skips in the same parser, the value returned is
 # list of all skipped text.
 #""
 #f other is Ellipsis:
 #eturn _PendingSkip(self)

 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn And([self, other])

 #ef __radd__(self, other) -> "ParserElement":
 #""
 #mplementation of ``+`` operator when left operand is not a :class:`ParserElement`
 #""
 #f other is Ellipsis:
 #eturn SkipTo(self)("_skipped*") + self

 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn other + self

 #ef __sub__(self, other) -> "ParserElement":
 #""
 #mplementation of ``-`` operator, returns :class:`And` with error stop
 #""
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn self + And._ErrorStop() + other

 #ef __rsub__(self, other) -> "ParserElement":
 #""
 #mplementation of ``-`` operator when left operand is not a :class:`ParserElement`
 #""
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn other - self

 #ef __mul__(self, other) -> "ParserElement":
 #""
 #mplementation of ``*`` operator, allows use of ``expr * 3`` in place of
 #`expr + expr + expr``.  Expressions may also be multiplied by a 2-integer
 #uple, similar to ``{min, max}`` multipliers in regular expressions.  Tuples
 #ay also include ``None`` as in:

 # ``expr*(n, None)`` or ``expr*(n, )`` is equivalent
 #o ``expr*n + ZeroOrMore(expr)``
 #read as "at least n instances of ``expr``")
 # ``expr*(None, n)`` is equivalent to ``expr*(0, n)``
 #read as "0 to n instances of ``expr``")
 # ``expr*(None, None)`` is equivalent to ``ZeroOrMore(expr)``
 # ``expr*(1, None)`` is equivalent to ``OneOrMore(expr)``

 #ote that ``expr*(None, n)`` does not raise an exception if
 #ore than n exprs exist in the input stream; that is,
 #`expr*(None, n)`` does not enforce a maximum number of expr
 #ccurrences.  If this behavior is desired, then write
 #`expr*(None, n) + ~expr``
 #""
 #f other is Ellipsis:
 #ther = (0, None)
 #lif isinstance(other, tuple) and other[:1] == (Ellipsis,):
 #ther = ((0,) + other[1:] + (None,))[:2]

 #f isinstance(other, int):
 #inElements, optElements = other, 0
 #lif isinstance(other, tuple):
 #ther = tuple(o if o is not Ellipsis else None for o in other)
 #ther = (other + (None, None))[:2]
 #f other[0] is None:
 #ther = (0, other[1])
 #f isinstance(other[0], int) and other[1] is None:
 #f other[0] == 0:
 #eturn ZeroOrMore(self)
 #f other[0] == 1:
 #eturn OneOrMore(self)
 #lse:
 #eturn self * other[0] + ZeroOrMore(self)
 #lif isinstance(other[0], int) and isinstance(other[1], int):
 #inElements, optElements = other
 #ptElements -= minElements
 #lse:
 #eturn NotImplemented
 #lse:
 #eturn NotImplemented

 #f minElements < 0:
 #aise ValueError("cannot multiply ParserElement by negative value")
 #f optElements < 0:
 #aise ValueError(
 #second tuple value must be greater or equal to first tuple value"
 #
 #f minElements == optElements == 0:
 #eturn And([])

 #f optElements:

 #ef makeOptionalList(n):
 #f n > 1:
 #eturn Opt(self + makeOptionalList(n - 1))
 #lse:
 #eturn Opt(self)

 #f minElements:
 #f minElements == 1:
 #et = self + makeOptionalList(optElements)
 #lse:
 #et = And([self] * minElements) + makeOptionalList(optElements)
 #lse:
 #et = makeOptionalList(optElements)
 #lse:
 #f minElements == 1:
 #et = self
 #lse:
 #et = And([self] * minElements)
 #eturn ret

 #ef __rmul__(self, other) -> "ParserElement":
 #eturn self.__mul__(other)

 #ef __or__(self, other) -> "ParserElement":
 #""
 #mplementation of ``|`` operator - returns :class:`MatchFirst`
 #""
 #f other is Ellipsis:
 #eturn _PendingSkip(self, must_skip=True)

 #f isinstance(other, str_type):
            # `expr | ""` is equivalent to `Opt(expr)`
 #f other == "":
 #eturn Opt(self)
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn MatchFirst([self, other])

 #ef __ror__(self, other) -> "ParserElement":
 #""
 #mplementation of ``|`` operator when left operand is not a :class:`ParserElement`
 #""
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn other | self

 #ef __xor__(self, other) -> "ParserElement":
 #""
 #mplementation of ``^`` operator - returns :class:`Or`
 #""
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn Or([self, other])

 #ef __rxor__(self, other) -> "ParserElement":
 #""
 #mplementation of ``^`` operator when left operand is not a :class:`ParserElement`
 #""
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn other ^ self

 #ef __and__(self, other) -> "ParserElement":
 #""
 #mplementation of ``&`` operator - returns :class:`Each`
 #""
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn Each([self, other])

 #ef __rand__(self, other) -> "ParserElement":
 #""
 #mplementation of ``&`` operator when left operand is not a :class:`ParserElement`
 #""
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn other & self

 #ef __invert__(self) -> "ParserElement":
 #""
 #mplementation of ``~`` operator - returns :class:`NotAny`
 #""
 #eturn NotAny(self)

    # disable __iter__ to override legacy use of sequential access to __getitem__ to
    # iterate over a sequence
 #_iter__ = None

 #ef __getitem__(self, key):
 #""
 #se ``[]`` indexing notation as a short form for expression repetition:

 # ``expr[n]`` is equivalent to ``expr*n``
 # ``expr[m, n]`` is equivalent to ``expr*(m, n)``
 # ``expr[n, ...]`` or ``expr[n,]`` is equivalent
 #o ``expr*n + ZeroOrMore(expr)``
 #read as "at least n instances of ``expr``")
 # ``expr[..., n]`` is equivalent to ``expr*(0, n)``
 #read as "0 to n instances of ``expr``")
 # ``expr[...]`` and ``expr[0, ...]`` are equivalent to ``ZeroOrMore(expr)``
 # ``expr[1, ...]`` is equivalent to ``OneOrMore(expr)``

 #`None`` may be used in place of ``...``.

 #ote that ``expr[..., n]`` and ``expr[m, n]`` do not raise an exception
 #f more than ``n`` ``expr``\\ s exist in the input stream.  If this behavior is
 #esired, then write ``expr[..., n] + ~expr``.

 #or repetition with a stop_on expression, use slice notation:

 # ``expr[...: end_expr]`` and ``expr[0, ...: end_expr]`` are equivalent to ``ZeroOrMore(expr, stop_on=end_expr)``
 # ``expr[1, ...: end_expr]`` is equivalent to ``OneOrMore(expr, stop_on=end_expr)``

 #""

 #top_on_defined = False
 #top_on = NoMatch()
 #f isinstance(key, slice):
 #ey, stop_on = key.start, key.stop
 #f key is None:
 #ey = ...
 #top_on_defined = True
 #lif isinstance(key, tuple) and isinstance(key[-1], slice):
 #ey, stop_on = (key[0], key[1].start), key[1].stop
 #top_on_defined = True

        # convert single arg keys to tuples
 #f isinstance(key, str_type):
 #ey = (key,)
 #ry:
 #ter(key)
 #xcept TypeError:
 #ey = (key, key)

 #f len(key) > 2:
 #aise TypeError(
 #"only 1 or 2 index arguments supported ({key[:5]}{f'... [{len(key)}]' if len(key) > 5 else ''})"
 #

        # clip to 2 elements
 #et = self * tuple(key[:2])
 #et = typing.cast(_MultipleMatch, ret)

 #f stop_on_defined:
 #et.stopOn(stop_on)

 #eturn ret

 #ef __call__(self, name: typing.Optional[str] = None) -> "ParserElement":
 #""
 #hortcut for :class:`set_results_name`, with ``list_all_matches=False``.

 #f ``name`` is given with a trailing ``'*'`` character, then ``list_all_matches`` will be
 #assed as ``True``.

 #f ``name`` is omitted, same as calling :class:`copy`.

 #xample::

            # these are equivalent
 #serdata = Word(alphas).set_results_name("name") + Word(nums + "-").set_results_name("socsecno")
 #serdata = Word(alphas)("name") + Word(nums + "-")("socsecno")
 #""
 #f name is not None:
 #eturn self._setResultsName(name)
 #lse:
 #eturn self.copy()

 #ef suppress(self) -> "ParserElement":
 #""
 #uppresses the output of this :class:`ParserElement`; useful to keep punctuation from
 #luttering up returned output.
 #""
 #eturn Suppress(self)

 #ef ignore_whitespace(self, recursive: bool = True) -> "ParserElement":
 #""
 #nables the skipping of whitespace before matching the characters in the
 #class:`ParserElement`'s defined pattern.

 #param recursive: If ``True`` (the default), also enable whitespace skipping in child elements (if any)
 #""
 #elf.skipWhitespace = True
 #eturn self

 #ef leave_whitespace(self, recursive: bool = True) -> "ParserElement":
 #""
 #isables the skipping of whitespace before matching the characters in the
 #class:`ParserElement`'s defined pattern.  This is normally only used internally by
 #he pyparsing module, but may be needed in some whitespace-sensitive grammars.

 #param recursive: If true (the default), also disable whitespace skipping in child elements (if any)
 #""
 #elf.skipWhitespace = False
 #eturn self

 #ef set_whitespace_chars(
 #elf, chars: Union[Set[str], str], copy_defaults: bool = False
 # -> "ParserElement":
 #""
 #verrides the default whitespace chars
 #""
 #elf.skipWhitespace = True
 #elf.whiteChars = set(chars)
 #elf.copyDefaultWhiteChars = copy_defaults
 #eturn self

 #ef parse_with_tabs(self) -> "ParserElement":
 #""
 #verrides default behavior to expand ``<TAB>`` s to spaces before parsing the input string.
 #ust be called before ``parse_string`` when the input grammar contains elements that
 #atch ``<TAB>`` characters.
 #""
 #elf.keepTabs = True
 #eturn self

 #ef ignore(self, other: "ParserElement") -> "ParserElement":
 #""
 #efine expression to be ignored (e.g., comments) while doing pattern
 #atching; may be called repeatedly, to define multiple comment or other
 #gnorable patterns.

 #xample::

 #att = Word(alphas)[1, ...]
 #att.parse_string('ablaj /* comment */ lskjd')
            # -> ['ablaj']

 #att.ignore(c_style_comment)
 #att.parse_string('ablaj /* comment */ lskjd')
            # -> ['ablaj', 'lskjd']
 #""
 #mport typing

 #f isinstance(other, str_type):
 #ther = Suppress(other)

 #f isinstance(other, Suppress):
 #f other not in self.ignoreExprs:
 #elf.ignoreExprs.append(other)
 #lse:
 #elf.ignoreExprs.append(Suppress(other.copy()))
 #eturn self

 #ef set_debug_actions(
 #elf,
 #tart_action: DebugStartAction,
 #uccess_action: DebugSuccessAction,
 #xception_action: DebugExceptionAction,
 # -> "ParserElement":
 #""
 #ustomize display of debugging messages while doing pattern matching:

 # ``start_action`` - method to be called when an expression is about to be parsed;
 #hould have the signature ``fn(input_string: str, location: int, expression: ParserElement, cache_hit: bool)``

 # ``success_action`` - method to be called when an expression has successfully parsed;
 #hould have the signature ``fn(input_string: str, start_location: int, end_location: int, expression: ParserELement, parsed_tokens: ParseResults, cache_hit: bool)``

 # ``exception_action`` - method to be called when expression fails to parse;
 #hould have the signature ``fn(input_string: str, location: int, expression: ParserElement, exception: Exception, cache_hit: bool)``
 #""
 #elf.debugActions = self.DebugActions(
 #tart_action or _default_start_debug_action,  # type: ignore[truthy-function]
 #uccess_action or _default_success_debug_action,  # type: ignore[truthy-function]
 #xception_action or _default_exception_debug_action,  # type: ignore[truthy-function]
 #
 #elf.debug = True
 #eturn self

 #ef set_debug(self, flag: bool = True, recurse: bool = False) -> "ParserElement":
 #""
 #nable display of debugging messages while doing pattern matching.
 #et ``flag`` to ``True`` to enable, ``False`` to disable.
 #et ``recurse`` to ``True`` to set the debug flag on this expression and all sub-expressions.

 #xample::

 #d = Word(alphas).set_name("alphaword")
 #nteger = Word(nums).set_name("numword")
 #erm = wd | integer

            # turn on debugging for wd
 #d.set_debug()

 #erm[1, ...].parse_string("abc 123 xyz 890")

 #rints::

 #atch alphaword at loc 0(1,1)
 #atched alphaword -> ['abc']
 #atch alphaword at loc 3(1,4)
 #xception raised:Expected alphaword (at char 4), (line:1, col:5)
 #atch alphaword at loc 7(1,8)
 #atched alphaword -> ['xyz']
 #atch alphaword at loc 11(1,12)
 #xception raised:Expected alphaword (at char 12), (line:1, col:13)
 #atch alphaword at loc 15(1,16)
 #xception raised:Expected alphaword (at char 15), (line:1, col:16)

 #he output shown is that produced by the default debug actions - custom debug actions can be
 #pecified using :class:`set_debug_actions`. Prior to attempting
 #o match the ``wd`` expression, the debugging message ``"Match <exprname> at loc <n>(<line>,<col>)"``
 #s shown. Then if the parse succeeds, a ``"Matched"`` message is shown, or an ``"Exception raised"``
 #essage is shown. Also note the use of :class:`set_name` to assign a human-readable name to the expression,
 #hich makes debugging and exception messages easier to understand - for instance, the default
 #ame created for the :class:`Word` expression without calling ``set_name`` is ``"W:(A-Za-z)"``.
 #""
 #f recurse:
 #or expr in self.visit_all():
 #xpr.set_debug(flag, recurse=False)
 #eturn self

 #f flag:
 #elf.set_debug_actions(
 #default_start_debug_action,
 #default_success_debug_action,
 #default_exception_debug_action,
 #
 #lse:
 #elf.debug = False
 #eturn self

 #property
 #ef default_name(self) -> str:
 #f self._defaultName is None:
 #elf._defaultName = self._generateDefaultName()
 #eturn self._defaultName

 #abstractmethod
 #ef _generateDefaultName(self) -> str:
 #""
 #hild classes must define this method, which defines how the ``default_name`` is set.
 #""

 #ef set_name(self, name: str) -> "ParserElement":
 #""
 #efine name for this expression, makes debugging and exception messages clearer.

 #xample::

 #ord(nums).parse_string("ABC")  # -> Exception: Expected W:(0-9) (at char 0), (line:1, col:1)
 #ord(nums).set_name("integer").parse_string("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
 #""
 #elf.customName = name
 #elf.errmsg = "Expected " + self.name
 #f __diag__.enable_debug_on_named_expressions:
 #elf.set_debug()
 #eturn self

 #property
 #ef name(self) -> str:
        # This will use a user-defined name if available, but otherwise defaults back to the auto-generated name
 #eturn self.customName if self.customName is not None else self.default_name

 #ef __str__(self) -> str:
 #eturn self.name

 #ef __repr__(self) -> str:
 #eturn str(self)

 #ef streamline(self) -> "ParserElement":
 #elf.streamlined = True
 #elf._defaultName = None
 #eturn self

 #ef recurse(self) -> List["ParserElement"]:
 #eturn []

 #ef _checkRecursion(self, parseElementList):
 #ubRecCheckList = parseElementList[:] + [self]
 #or e in self.recurse():
 #._checkRecursion(subRecCheckList)

 #ef validate(self, validateTrace=None) -> None:
 #""
 #heck defined expressions for valid structure, check for infinite recursive definitions.
 #""
 #arnings.warn(
 #ParserElement.validate() is deprecated, and should not be used to check for left recursion",
 #eprecationWarning,
 #tacklevel=2,
 #
 #elf._checkRecursion([])

 #ef parse_file(
 #elf,
 #ile_or_filename: Union[str, Path, TextIO],
 #ncoding: str = "utf-8",
 #arse_all: bool = False,
 #,
 #arseAll: bool = False,
 # -> ParseResults:
 #""
 #xecute the parse expression on the given file or filename.
 #f a filename is specified (instead of a file object),
 #he entire file is opened, read, and closed before parsing.
 #""
 #arseAll = parseAll or parse_all
 #ry:
 #ile_or_filename = typing.cast(TextIO, file_or_filename)
 #ile_contents = file_or_filename.read()
 #xcept AttributeError:
 #ile_or_filename = typing.cast(str, file_or_filename)
 #ith open(file_or_filename, "r", encoding=encoding) as f:
 #ile_contents = f.read()
 #ry:
 #eturn self.parse_string(file_contents, parseAll)
 #xcept ParseBaseException as exc:
 #f ParserElement.verbose_stacktrace:
 #aise
 #lse:
                # catch and re-raise exception from here, clears out pyparsing internal stack trace
 #aise exc.with_traceback(None)

 #ef __eq__(self, other):
 #f self is other:
 #eturn True
 #lif isinstance(other, str_type):
 #eturn self.matches(other, parse_all=True)
 #lif isinstance(other, ParserElement):
 #eturn vars(self) == vars(other)
 #eturn False

 #ef __hash__(self):
 #eturn id(self)

 #ef matches(
 #elf, test_string: str, parse_all: bool = True, *, parseAll: bool = True
 # -> bool:
 #""
 #ethod for quick testing of a parser against a test string. Good for simple
 #nline microtests of sub expressions while building up larger parser.

 #arameters:

 # ``test_string`` - to test against this expression for a match
 # ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests

 #xample::

 #xpr = Word(nums)
 #ssert expr.matches("100")
 #""
 #arseAll = parseAll and parse_all
 #ry:
 #elf.parse_string(str(test_string), parse_all=parseAll)
 #eturn True
 #xcept ParseBaseException:
 #eturn False

 #ef run_tests(
 #elf,
 #ests: Union[str, List[str]],
 #arse_all: bool = True,
 #omment: typing.Optional[Union["ParserElement", str]] = "#",
 #ull_dump: bool = True,
 #rint_results: bool = True,
 #ailure_tests: bool = False,
 #ost_parse: typing.Optional[Callable[[str, ParseResults], str]] = None,
 #ile: typing.Optional[TextIO] = None,
 #ith_line_numbers: bool = False,
 #,
 #arseAll: bool = True,
 #ullDump: bool = True,
 #rintResults: bool = True,
 #ailureTests: bool = False,
 #ostParse: typing.Optional[Callable[[str, ParseResults], str]] = None,
 # -> Tuple[bool, List[Tuple[str, Union[ParseResults, Exception]]]]:
 #""
 #xecute the parse expression on a series of test strings, showing each
 #est, the parsed results or where the parse failed. Quick and easy way to
 #un a parse expression against a list of sample strings.

 #arameters:

 # ``tests`` - a list of separate test strings, or a multiline string of test strings
 # ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests
 # ``comment`` - (default= ``'#'``) - expression for indicating embedded comments in the test
 #tring; pass None to disable comment filtering
 # ``full_dump`` - (default= ``True``) - dump results as list followed by results names in nested outline;
 #f False, only dump nested list
 # ``print_results`` - (default= ``True``) prints test output to stdout
 # ``failure_tests`` - (default= ``False``) indicates if these tests are expected to fail parsing
 # ``post_parse`` - (default= ``None``) optional callback for successful parse results; called as
 #fn(test_string, parse_results)` and returns a string to be added to the test output
 # ``file`` - (default= ``None``) optional file-like object to which test output will be written;
 #f None, will default to ``sys.stdout``
 # ``with_line_numbers`` - default= ``False``) show test strings with line and column numbers

 #eturns: a (success, results) tuple, where success indicates that all tests succeeded
 #or failed if ``failure_tests`` is True), and the results contain a list of lines of each
 #est's output

 #xample::

 #umber_expr = pyparsing_common.number.copy()

 #esult = number_expr.run_tests('''
                # unsigned integer
 #00
                # negative integer
 #100
                # float with scientific notation
 #.02e23
                # integer with scientific notation
 #e-12
 #'')
 #rint("Success" if result[0] else "Failed!")

 #esult = number_expr.run_tests('''
                # stray character
 #00Z
                # missing leading digit before '.'
 #.100
                # too many '.'
 #.14.159
 #'', failure_tests=True)
 #rint("Success" if result[0] else "Failed!")

 #rints::

            # unsigned integer
 #00
 #100]

            # negative integer
 #100
 #-100]

            # float with scientific notation
 #.02e23
 #6.02e+23]

            # integer with scientific notation
 #e-12
 #1e-12]

 #uccess

            # stray character
 #00Z
 #
 #AIL: Expected end of text (at char 3), (line:1, col:4)

            # missing leading digit before '.'
 #.100
 #
 #AIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)

            # too many '.'
 #.14.159
 #
 #AIL: Expected end of text (at char 4), (line:1, col:5)

 #uccess

 #ach test string must be on a single line. If you want to test a string that spans multiple
 #ines, create a test like this::

 #xpr.run_tests(r"this is a test\\n of strings that spans \\n 3 lines")

 #Note that this is a raw string literal, you must include the leading ``'r'``.)
 #""
 #rom .testing import pyparsing_test

 #arseAll = parseAll and parse_all
 #ullDump = fullDump and full_dump
 #rintResults = printResults and print_results
 #ailureTests = failureTests or failure_tests
 #ostParse = postParse or post_parse
 #f isinstance(tests, str_type):
 #ests = typing.cast(str, tests)
 #ine_strip = type(tests).strip
 #ests = [line_strip(test_line) for test_line in tests.rstrip().splitlines()]
 #omment_specified = comment is not None
 #f comment_specified:
 #f isinstance(comment, str_type):
 #omment = typing.cast(str, comment)
 #omment = Literal(comment)
 #omment = typing.cast(ParserElement, comment)
 #f file is None:
 #ile = sys.stdout
 #rint_ = file.write

 #esult: Union[ParseResults, Exception]
 #llResults: List[Tuple[str, Union[ParseResults, Exception]]] = []
 #omments: List[str] = []
 #uccess = True
 #L = Literal(r"\n").add_parse_action(replace_with("\n")).ignore(quoted_string)
 #OM = "\ufeff"
 #or t in tests:
 #f comment_specified and comment.matches(t, False) or comments and not t:
 #omments.append(
 #yparsing_test.with_line_numbers(t) if with_line_numbers else t
 #
 #ontinue
 #f not t:
 #ontinue
 #ut = [
 #\n" + "\n".join(comments) if comments else "",
 #yparsing_test.with_line_numbers(t) if with_line_numbers else t,
 #
 #omments = []
 #ry:
                # convert newline marks to actual newlines, and strip leading BOM if present
 # = NL.transform_string(t.lstrip(BOM))
 #esult = self.parse_string(t, parse_all=parseAll)
 #xcept ParseBaseException as pe:
 #atal = "(FATAL)" if isinstance(pe, ParseFatalException) else ""
 #ut.append(pe.explain())
 #ut.append("FAIL: " + str(pe))
 #f ParserElement.verbose_stacktrace:
 #ut.extend(traceback.format_tb(pe.__traceback__))
 #uccess = success and failureTests
 #esult = pe
 #xcept Exception as exc:
 #ut.append(f"FAIL-EXCEPTION: {type(exc).__name__}: {exc}")
 #f ParserElement.verbose_stacktrace:
 #ut.extend(traceback.format_tb(exc.__traceback__))
 #uccess = success and failureTests
 #esult = exc
 #lse:
 #uccess = success and not failureTests
 #f postParse is not None:
 #ry:
 #p_value = postParse(t, result)
 #f pp_value is not None:
 #f isinstance(pp_value, ParseResults):
 #ut.append(pp_value.dump())
 #lse:
 #ut.append(str(pp_value))
 #lse:
 #ut.append(result.dump())
 #xcept Exception as e:
 #ut.append(result.dump(full=fullDump))
 #ut.append(
 #"{postParse.__name__} failed: {type(e).__name__}: {e}"
 #
 #lse:
 #ut.append(result.dump(full=fullDump))
 #ut.append("")

 #f printResults:
 #rint_("\n".join(out))

 #llResults.append((t, result))

 #eturn success, allResults

 #ef create_diagram(
 #elf,
 #utput_html: Union[TextIO, Path, str],
 #ertical: int = 3,
 #how_results_names: bool = False,
 #how_groups: bool = False,
 #mbed: bool = False,
 #*kwargs,
 # -> None:
 #""
 #reate a railroad diagram for the parser.

 #arameters:

 # ``output_html`` (str or file-like object) - output target for generated
 #iagram HTML
 # ``vertical`` (int) - threshold for formatting multiple alternatives vertically
 #nstead of horizontally (default=3)
 # ``show_results_names`` - bool flag whether diagram should show annotations for
 #efined results names
 # ``show_groups`` - bool flag whether groups should be highlighted with an unlabeled surrounding box
 # ``embed`` - bool flag whether generated HTML should omit <HEAD>, <BODY>, and <DOCTYPE> tags to embed
 #he resulting HTML in an enclosing HTML source
 # ``head`` - str containing additional HTML to insert into the <HEAD> section of the generated code;
 #an be used to insert custom CSS styling
 # ``body`` - str containing additional HTML to insert at the beginning of the <BODY> section of the
 #enerated code

 #dditional diagram-formatting keyword arguments can also be included;
 #ee railroad.Diagram class.
 #""

 #ry:
 #rom .diagram import to_railroad, railroad_to_html
 #xcept ImportError as ie:
 #aise Exception(
 #must ``pip install pyparsing[diagrams]`` to generate parser railroad diagrams"
 # from ie

 #elf.streamline()

 #ailroad = to_railroad(
 #elf,
 #ertical=vertical,
 #how_results_names=show_results_names,
 #how_groups=show_groups,
 #iagram_kwargs=kwargs,
 #
 #f isinstance(output_html, (str, Path)):
 #ith open(output_html, "w", encoding="utf-8") as diag_file:
 #iag_file.write(railroad_to_html(railroad, embed=embed, **kwargs))
 #lse:
            # we were passed a file-like object, just write to it
 #utput_html.write(railroad_to_html(railroad, embed=embed, **kwargs))

    # Compatibility synonyms
    # fmt: off
 #staticmethod
 #replaced_by_pep8(inline_literals_using)
 #ef inlineLiteralsUsing(): ...

 #staticmethod
 #replaced_by_pep8(set_default_whitespace_chars)
 #ef setDefaultWhitespaceChars(): ...

 #replaced_by_pep8(set_results_name)
 #ef setResultsName(self): ...

 #replaced_by_pep8(set_break)
 #ef setBreak(self): ...

 #replaced_by_pep8(set_parse_action)
 #ef setParseAction(self): ...

 #replaced_by_pep8(add_parse_action)
 #ef addParseAction(self): ...

 #replaced_by_pep8(add_condition)
 #ef addCondition(self): ...

 #replaced_by_pep8(set_fail_action)
 #ef setFailAction(self): ...

 #replaced_by_pep8(try_parse)
 #ef tryParse(self): ...

 #staticmethod
 #replaced_by_pep8(enable_left_recursion)
 #ef enableLeftRecursion(): ...

 #staticmethod
 #replaced_by_pep8(enable_packrat)
 #ef enablePackrat(): ...

 #replaced_by_pep8(parse_string)
 #ef parseString(self): ...

 #replaced_by_pep8(scan_string)
 #ef scanString(self): ...

 #replaced_by_pep8(transform_string)
 #ef transformString(self): ...

 #replaced_by_pep8(search_string)
 #ef searchString(self): ...

 #replaced_by_pep8(ignore_whitespace)
 #ef ignoreWhitespace(self): ...

 #replaced_by_pep8(leave_whitespace)
 #ef leaveWhitespace(self): ...

 #replaced_by_pep8(set_whitespace_chars)
 #ef setWhitespaceChars(self): ...

 #replaced_by_pep8(parse_with_tabs)
 #ef parseWithTabs(self): ...

 #replaced_by_pep8(set_debug_actions)
 #ef setDebugActions(self): ...

 #replaced_by_pep8(set_debug)
 #ef setDebug(self): ...

 #replaced_by_pep8(set_name)
 #ef setName(self): ...

 #replaced_by_pep8(parse_file)
 #ef parseFile(self): ...

 #replaced_by_pep8(run_tests)
 #ef runTests(self): ...

 #anParseNext = can_parse_next
 #esetCache = reset_cache
 #efaultName = default_name
    # fmt: on


class _PendingSkip(ParserElement):
    # internal placeholder class to hold a place were '...' is added to a parser element,
    # once another ParserElement is added, this placeholder will be replaced with a SkipTo
 #ef __init__(self, expr: ParserElement, must_skip: bool = False):
 #uper().__init__()
 #elf.anchor = expr
 #elf.must_skip = must_skip

 #ef _generateDefaultName(self) -> str:
 #eturn str(self.anchor + Empty()).replace("Empty", "...")

 #ef __add__(self, other) -> "ParserElement":
 #kipper = SkipTo(other).set_name("...")("_skipped*")
 #f self.must_skip:

 #ef must_skip(t):
 #f not t._skipped or t._skipped.as_list() == [""]:
 #el t[0]
 #.pop("_skipped", None)

 #ef show_skip(t):
 #f t._skipped.as_list()[-1:] == [""]:
 #.pop("_skipped")
 #["_skipped"] = "missing <" + repr(self.anchor) + ">"

 #eturn (
 #elf.anchor + skipper().add_parse_action(must_skip)
 # skipper().add_parse_action(show_skip)
 # + other

 #eturn self.anchor + skipper + other

 #ef __repr__(self):
 #eturn self.defaultName

 #ef parseImpl(self, *args):
 #aise Exception(
 #use of `...` expression without following SkipTo target expression"
 #


class Token(ParserElement):
 #""Abstract :class:`ParserElement` subclass, for defining atomic
 #atching patterns.
 #""

 #ef __init__(self):
 #uper().__init__(savelist=False)

 #ef _generateDefaultName(self) -> str:
 #eturn type(self).__name__


class NoMatch(Token):
 #""
 # token that will never match.
 #""

 #ef __init__(self):
 #uper().__init__()
 #elf.mayReturnEmpty = True
 #elf.mayIndexError = False
 #elf.errmsg = "Unmatchable token"

 #ef parseImpl(self, instring, loc, doActions=True):
 #aise ParseException(instring, loc, self.errmsg, self)


class Literal(Token):
 #""
 #oken to exactly match a specified string.

 #xample::

 #iteral('blah').parse_string('blah')  # -> ['blah']
 #iteral('blah').parse_string('blahfooblah')  # -> ['blah']
 #iteral('blah').parse_string('bla')  # -> Exception: Expected "blah"

 #or case-insensitive matching, use :class:`CaselessLiteral`.

 #or keyword matching (force word break before and after the matched string),
 #se :class:`Keyword` or :class:`CaselessKeyword`.
 #""

 #ef __new__(cls, match_string: str = "", *, matchString: str = ""):
        # Performance tuning: select a subclass with optimized parseImpl
 #f cls is Literal:
 #atch_string = matchString or match_string
 #f not match_string:
 #eturn super().__new__(Empty)
 #f len(match_string) == 1:
 #eturn super().__new__(_SingleCharLiteral)

        # Default behavior
 #eturn super().__new__(cls)

    # Needed to make copy.copy() work correctly if we customize __new__
 #ef __getnewargs__(self):
 #eturn (self.match,)

 #ef __init__(self, match_string: str = "", *, matchString: str = ""):
 #uper().__init__()
 #atch_string = matchString or match_string
 #elf.match = match_string
 #elf.matchLen = len(match_string)
 #elf.firstMatchChar = match_string[:1]
 #elf.errmsg = "Expected " + self.name
 #elf.mayReturnEmpty = False
 #elf.mayIndexError = False

 #ef _generateDefaultName(self) -> str:
 #eturn repr(self.match)

 #ef parseImpl(self, instring, loc, doActions=True):
 #f instring[loc] == self.firstMatchChar and instring.startswith(
 #elf.match, loc
 #:
 #eturn loc + self.matchLen, self.match
 #aise ParseException(instring, loc, self.errmsg, self)


class Empty(Literal):
 #""
 #n empty token, will always match.
 #""

 #ef __init__(self, match_string="", *, matchString=""):
 #uper().__init__("")
 #elf.mayReturnEmpty = True
 #elf.mayIndexError = False

 #ef _generateDefaultName(self) -> str:
 #eturn "Empty"

 #ef parseImpl(self, instring, loc, doActions=True):
 #eturn loc, []


class _SingleCharLiteral(Literal):
 #ef parseImpl(self, instring, loc, doActions=True):
 #f instring[loc] == self.firstMatchChar:
 #eturn loc + 1, self.match
 #aise ParseException(instring, loc, self.errmsg, self)


ParserElement._literalStringClass = Literal


class Keyword(Token):
 #""
 #oken to exactly match a specified string as a keyword, that is,
 #t must be immediately preceded and followed by whitespace or
 #on-keyword characters. Compare with :class:`Literal`:

 # ``Literal("if")`` will match the leading ``'if'`` in
 #`'ifAndOnlyIf'``.
 # ``Keyword("if")`` will not; it will only match the leading
 #`'if'`` in ``'if x=1'``, or ``'if(y==2)'``

 #ccepts two optional constructor arguments in addition to the
 #eyword string:

 # ``ident_chars`` is a string of characters that would be valid
 #dentifier characters, defaulting to all alphanumerics + "_" and
 #$"
 # ``caseless`` allows case-insensitive matching, default is ``False``.

 #xample::

 #eyword("start").parse_string("start")  # -> ['start']
 #eyword("start").parse_string("starting")  # -> Exception

 #or case-insensitive matching, use :class:`CaselessKeyword`.
 #""

 #EFAULT_KEYWORD_CHARS = alphanums + "_$"

 #ef __init__(
 #elf,
 #atch_string: str = "",
 #dent_chars: typing.Optional[str] = None,
 #aseless: bool = False,
 #,
 #atchString: str = "",
 #dentChars: typing.Optional[str] = None,
 #:
 #uper().__init__()
 #dentChars = identChars or ident_chars
 #f identChars is None:
 #dentChars = Keyword.DEFAULT_KEYWORD_CHARS
 #atch_string = matchString or match_string
 #elf.match = match_string
 #elf.matchLen = len(match_string)
 #ry:
 #elf.firstMatchChar = match_string[0]
 #xcept IndexError:
 #aise ValueError("null string passed to Keyword; use Empty() instead")
 #elf.errmsg = f"Expected {type(self).__name__} {self.name}"
 #elf.mayReturnEmpty = False
 #elf.mayIndexError = False
 #elf.caseless = caseless
 #f caseless:
 #elf.caselessmatch = match_string.upper()
 #dentChars = identChars.upper()
 #elf.identChars = set(identChars)

 #ef _generateDefaultName(self) -> str:
 #eturn repr(self.match)

 #ef parseImpl(self, instring, loc, doActions=True):
 #rrmsg = self.errmsg
 #rrloc = loc
 #f self.caseless:
 #f instring[loc : loc + self.matchLen].upper() == self.caselessmatch:
 #f loc == 0 or instring[loc - 1].upper() not in self.identChars:
 #f (
 #oc >= len(instring) - self.matchLen
 #r instring[loc + self.matchLen].upper() not in self.identChars
 #:
 #eturn loc + self.matchLen, self.match
 #lse:
                        # followed by keyword char
 #rrmsg += ", was immediately followed by keyword character"
 #rrloc = loc + self.matchLen
 #lse:
                    # preceded by keyword char
 #rrmsg += ", keyword was immediately preceded by keyword character"
 #rrloc = loc - 1
            # else no match just raise plain exception

 #lse:
 #f (
 #nstring[loc] == self.firstMatchChar
 #nd self.matchLen == 1
 #r instring.startswith(self.match, loc)
 #:
 #f loc == 0 or instring[loc - 1] not in self.identChars:
 #f (
 #oc >= len(instring) - self.matchLen
 #r instring[loc + self.matchLen] not in self.identChars
 #:
 #eturn loc + self.matchLen, self.match
 #lse:
                        # followed by keyword char
 #rrmsg += (
 #, keyword was immediately followed by keyword character"
 #
 #rrloc = loc + self.matchLen
 #lse:
                    # preceded by keyword char
 #rrmsg += ", keyword was immediately preceded by keyword character"
 #rrloc = loc - 1
            # else no match just raise plain exception

 #aise ParseException(instring, errloc, errmsg, self)

 #staticmethod
 #ef set_default_keyword_chars(chars) -> None:
 #""
 #verrides the default characters used by :class:`Keyword` expressions.
 #""
 #eyword.DEFAULT_KEYWORD_CHARS = chars

 #etDefaultKeywordChars = set_default_keyword_chars


class CaselessLiteral(Literal):
 #""
 #oken to match a specified string, ignoring case of letters.
 #ote: the matched results will always be in the case of the given
 #atch string, NOT the case of the input text.

 #xample::

 #aselessLiteral("CMD")[1, ...].parse_string("cmd CMD Cmd10")
        # -> ['CMD', 'CMD', 'CMD']

 #Contrast with example for :class:`CaselessKeyword`.)
 #""

 #ef __init__(self, match_string: str = "", *, matchString: str = ""):
 #atch_string = matchString or match_string
 #uper().__init__(match_string.upper())
        # Preserve the defining literal.
 #elf.returnString = match_string
 #elf.errmsg = "Expected " + self.name

 #ef parseImpl(self, instring, loc, doActions=True):
 #f instring[loc : loc + self.matchLen].upper() == self.match:
 #eturn loc + self.matchLen, self.returnString
 #aise ParseException(instring, loc, self.errmsg, self)


class CaselessKeyword(Keyword):
 #""
 #aseless version of :class:`Keyword`.

 #xample::

 #aselessKeyword("CMD")[1, ...].parse_string("cmd CMD Cmd10")
        # -> ['CMD', 'CMD']

 #Contrast with example for :class:`CaselessLiteral`.)
 #""

 #ef __init__(
 #elf,
 #atch_string: str = "",
 #dent_chars: typing.Optional[str] = None,
 #,
 #atchString: str = "",
 #dentChars: typing.Optional[str] = None,
 #:
 #dentChars = identChars or ident_chars
 #atch_string = matchString or match_string
 #uper().__init__(match_string, identChars, caseless=True)


class CloseMatch(Token):
 #""A variation on :class:`Literal` which matches "close" matches,
 #hat is, strings with at most 'n' mismatching characters.
 #class:`CloseMatch` takes parameters:

 # ``match_string`` - string to be matched
 # ``caseless`` - a boolean indicating whether to ignore casing when comparing characters
 # ``max_mismatches`` - (``default=1``) maximum number of
 #ismatches allowed to count as a match

 #he results from a successful parse will contain the matched text
 #rom the input string and the following named results:

 # ``mismatches`` - a list of the positions within the
 #atch_string where mismatches were found
 # ``original`` - the original match_string used to compare
 #gainst the input string

 #f ``mismatches`` is an empty list, then the match was an exact
 #atch.

 #xample::

 #att = CloseMatch("ATCATCGAATGGA")
 #att.parse_string("ATCATCGAAXGGA") # -> (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']})
 #att.parse_string("ATCAXCGAAXGGA") # -> Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1)

        # exact match
 #att.parse_string("ATCATCGAATGGA") # -> (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']})

        # close match allowing up to 2 mismatches
 #att = CloseMatch("ATCATCGAATGGA", max_mismatches=2)
 #att.parse_string("ATCAXCGAAXGGA") # -> (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']})
 #""

 #ef __init__(
 #elf,
 #atch_string: str,
 #ax_mismatches: typing.Optional[int] = None,
 #,
 #axMismatches: int = 1,
 #aseless=False,
 #:
 #axMismatches = max_mismatches if max_mismatches is not None else maxMismatches
 #uper().__init__()
 #elf.match_string = match_string
 #elf.maxMismatches = maxMismatches
 #elf.errmsg = f"Expected {self.match_string!r} (with up to {self.maxMismatches} mismatches)"
 #elf.caseless = caseless
 #elf.mayIndexError = False
 #elf.mayReturnEmpty = False

 #ef _generateDefaultName(self) -> str:
 #eturn f"{type(self).__name__}:{self.match_string!r}"

 #ef parseImpl(self, instring, loc, doActions=True):
 #tart = loc
 #nstrlen = len(instring)
 #axloc = start + len(self.match_string)

 #f maxloc <= instrlen:
 #atch_string = self.match_string
 #atch_stringloc = 0
 #ismatches = []
 #axMismatches = self.maxMismatches

 #or match_stringloc, s_m in enumerate(
 #ip(instring[loc:maxloc], match_string)
 #:
 #rc, mat = s_m
 #f self.caseless:
 #rc, mat = src.lower(), mat.lower()

 #f src != mat:
 #ismatches.append(match_stringloc)
 #f len(mismatches) > maxMismatches:
 #reak
 #lse:
 #oc = start + match_stringloc + 1
 #esults = ParseResults([instring[start:loc]])
 #esults["original"] = match_string
 #esults["mismatches"] = mismatches
 #eturn loc, results

 #aise ParseException(instring, loc, self.errmsg, self)


class Word(Token):
 #""Token for matching words composed of allowed character sets.

 #arameters:

 # ``init_chars`` - string of all characters that should be used to
 #atch as a word; "ABC" will match "AAA", "ABAB", "CBAC", etc.;
 #f ``body_chars`` is also specified, then this is the string of
 #nitial characters
 # ``body_chars`` - string of characters that
 #an be used for matching after a matched initial character as
 #iven in ``init_chars``; if omitted, same as the initial characters
 #default=``None``)
 # ``min`` - minimum number of characters to match (default=1)
 # ``max`` - maximum number of characters to match (default=0)
 # ``exact`` - exact number of characters to match (default=0)
 # ``as_keyword`` - match as a keyword (default=``False``)
 # ``exclude_chars`` - characters that might be
 #ound in the input ``body_chars`` string but which should not be
 #ccepted for matching ;useful to define a word of all
 #rintables except for one or two characters, for instance
 #default=``None``)

 #class:`srange` is useful for defining custom character set strings
 #or defining :class:`Word` expressions, using range notation from
 #egular expression character sets.

 # common mistake is to use :class:`Word` to match a specific literal
 #tring, as in ``Word("Address")``. Remember that :class:`Word`
 #ses the string argument to define *sets* of matchable characters.
 #his expression would match "Add", "AAA", "dAred", or any other word
 #ade up of the characters 'A', 'd', 'r', 'e', and 's'. To match an
 #xact literal string, use :class:`Literal` or :class:`Keyword`.

 #yparsing includes helper strings for building Words:

 # :class:`alphas`
 # :class:`nums`
 # :class:`alphanums`
 # :class:`hexnums`
 # :class:`alphas8bit` (alphabetic characters in ASCII range 128-255
 # accented, tilded, umlauted, etc.)
 # :class:`punc8bit` (non-alphabetic characters in ASCII range
 #28-255 - currency, symbols, superscripts, diacriticals, etc.)
 # :class:`printables` (any non-whitespace character)

 #`alphas``, ``nums``, and ``printables`` are also defined in several
 #nicode sets - see :class:`pyparsing_unicode``.

 #xample::

        # a word composed of digits
 #nteger = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))

        # a word with a leading capital, and zero or more lowercase
 #apital_word = Word(alphas.upper(), alphas.lower())

        # hostnames are alphanumeric, with leading alpha, and '-'
 #ostname = Word(alphas, alphanums + '-')

        # roman numeral (not a strict parser, accepts invalid mix of characters)
 #oman = Word("IVXLCDM")

        # any string of non-whitespace characters, except for ','
 #sv_value = Word(printables, exclude_chars=",")
 #""

 #ef __init__(
 #elf,
 #nit_chars: str = "",
 #ody_chars: typing.Optional[str] = None,
 #in: int = 1,
 #ax: int = 0,
 #xact: int = 0,
 #s_keyword: bool = False,
 #xclude_chars: typing.Optional[str] = None,
 #,
 #nitChars: typing.Optional[str] = None,
 #odyChars: typing.Optional[str] = None,
 #sKeyword: bool = False,
 #xcludeChars: typing.Optional[str] = None,
 #:
 #nitChars = initChars or init_chars
 #odyChars = bodyChars or body_chars
 #sKeyword = asKeyword or as_keyword
 #xcludeChars = excludeChars or exclude_chars
 #uper().__init__()
 #f not initChars:
 #aise ValueError(
 #"invalid {type(self).__name__}, initChars cannot be empty string"
 #

 #nitChars_set = set(initChars)
 #f excludeChars:
 #xcludeChars_set = set(excludeChars)
 #nitChars_set -= excludeChars_set
 #f bodyChars:
 #odyChars = "".join(set(bodyChars) - excludeChars_set)
 #elf.initChars = initChars_set
 #elf.initCharsOrig = "".join(sorted(initChars_set))

 #f bodyChars:
 #elf.bodyChars = set(bodyChars)
 #elf.bodyCharsOrig = "".join(sorted(bodyChars))
 #lse:
 #elf.bodyChars = initChars_set
 #elf.bodyCharsOrig = self.initCharsOrig

 #elf.maxSpecified = max > 0

 #f min < 1:
 #aise ValueError(
 #cannot specify a minimum length < 1; use Opt(Word()) if zero-length word is permitted"
 #

 #f self.maxSpecified and min > max:
 #aise ValueError(
 #"invalid args, if min and max both specified min must be <= max (min={min}, max={max})"
 #

 #elf.minLen = min

 #f max > 0:
 #elf.maxLen = max
 #lse:
 #elf.maxLen = _MAX_INT

 #f exact > 0:
 #in = max = exact
 #elf.maxLen = exact
 #elf.minLen = exact

 #elf.errmsg = "Expected " + self.name
 #elf.mayIndexError = False
 #elf.asKeyword = asKeyword
 #f self.asKeyword:
 #elf.errmsg += " as a keyword"

        # see if we can make a regex for this Word
 #f " " not in (self.initChars | self.bodyChars):
 #f len(self.initChars) == 1:
 #e_leading_fragment = re.escape(self.initCharsOrig)
 #lse:
 #e_leading_fragment = f"[{_collapse_string_to_ranges(self.initChars)}]"

 #f self.bodyChars == self.initChars:
 #f max == 0:
 #epeat = "+"
 #lif max == 1:
 #epeat = ""
 #lse:
 #f self.minLen != self.maxLen:
 #epeat = f"{{{self.minLen},{'' if self.maxLen == _MAX_INT else self.maxLen}}}"
 #lse:
 #epeat = f"{{{self.minLen}}}"
 #elf.reString = f"{re_leading_fragment}{repeat}"
 #lse:
 #f max == 1:
 #e_body_fragment = ""
 #epeat = ""
 #lse:
 #e_body_fragment = f"[{_collapse_string_to_ranges(self.bodyChars)}]"
 #f max == 0:
 #epeat = "*"
 #lif max == 2:
 #epeat = "?" if min <= 1 else ""
 #lse:
 #f min != max:
 #epeat = f"{{{min - 1 if min > 0 else 0},{max - 1}}}"
 #lse:
 #epeat = f"{{{min - 1 if min > 0 else 0}}}"

 #elf.reString = (
 #"{re_leading_fragment}" f"{re_body_fragment}" f"{repeat}"
 #

 #f self.asKeyword:
 #elf.reString = rf"\b{self.reString}\b"

 #ry:
 #elf.re = re.compile(self.reString)
 #xcept re.error:
 #elf.re = None  # type: ignore[assignment]
 #lse:
 #elf.re_match = self.re.match
 #elf.parseImpl = self.parseImpl_regex  # type: ignore[assignment]

 #ef _generateDefaultName(self) -> str:
 #ef charsAsStr(s):
 #ax_repr_len = 16
 # = _collapse_string_to_ranges(s, re_escape=False)
 #f len(s) > max_repr_len:
 #eturn s[: max_repr_len - 3] + "..."
 #lse:
 #eturn s

 #f self.initChars != self.bodyChars:
 #ase = f"W:({charsAsStr(self.initChars)}, {charsAsStr(self.bodyChars)})"
 #lse:
 #ase = f"W:({charsAsStr(self.initChars)})"

        # add length specification
 #f self.minLen > 1 or self.maxLen != _MAX_INT:
 #f self.minLen == self.maxLen:
 #f self.minLen == 1:
 #eturn base[2:]
 #lse:
 #eturn base + f"{{{self.minLen}}}"
 #lif self.maxLen == _MAX_INT:
 #eturn base + f"{{{self.minLen},...}}"
 #lse:
 #eturn base + f"{{{self.minLen},{self.maxLen}}}"
 #eturn base

 #ef parseImpl(self, instring, loc, doActions=True):
 #f instring[loc] not in self.initChars:
 #aise ParseException(instring, loc, self.errmsg, self)

 #tart = loc
 #oc += 1
 #nstrlen = len(instring)
 #odychars = self.bodyChars
 #axloc = start + self.maxLen
 #axloc = min(maxloc, instrlen)
 #hile loc < maxloc and instring[loc] in bodychars:
 #oc += 1

 #hrowException = False
 #f loc - start < self.minLen:
 #hrowException = True
 #lif self.maxSpecified and loc < instrlen and instring[loc] in bodychars:
 #hrowException = True
 #lif self.asKeyword:
 #f (
 #tart > 0
 #nd instring[start - 1] in bodychars
 #r loc < instrlen
 #nd instring[loc] in bodychars
 #:
 #hrowException = True

 #f throwException:
 #aise ParseException(instring, loc, self.errmsg, self)

 #eturn loc, instring[start:loc]

 #ef parseImpl_regex(self, instring, loc, doActions=True):
 #esult = self.re_match(instring, loc)
 #f not result:
 #aise ParseException(instring, loc, self.errmsg, self)

 #oc = result.end()
 #eturn loc, result.group()


class Char(Word):
 #""A short-cut class for defining :class:`Word` ``(characters, exact=1)``,
 #hen defining a match of any single character in a string of
 #haracters.
 #""

 #ef __init__(
 #elf,
 #harset: str,
 #s_keyword: bool = False,
 #xclude_chars: typing.Optional[str] = None,
 #,
 #sKeyword: bool = False,
 #xcludeChars: typing.Optional[str] = None,
 #:
 #sKeyword = asKeyword or as_keyword
 #xcludeChars = excludeChars or exclude_chars
 #uper().__init__(
 #harset, exact=1, as_keyword=asKeyword, exclude_chars=excludeChars
 #


class Regex(Token):
 #"""Token for matching strings that match a given regular
 #xpression. Defined with string specifying the regular expression in
 # form recognized by the stdlib Python  `re module <https://docs.python.org/3/library/re.html>`_.
 #f the given regex contains named groups (defined using ``(?P<name>...)``),
 #hese will be preserved as named :class:`ParseResults`.

 #f instead of the Python stdlib ``re`` module you wish to use a different RE module
 #such as the ``regex`` module), you can do so by building your ``Regex`` object with
 # compiled RE that was compiled using ``regex``.

 #xample::

 #ealnum = Regex(r"[+-]?\d+\.\d*")
        # ref: https://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
 #oman = Regex(r"M{0,4}(CM|CD|D?{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")

        # named fields in a regex will be returned as named results
 #ate = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')

        # the Regex class will accept re's compiled using the regex module
 #mport regex
 #arser = pp.Regex(regex.compile(r'[0-9]'))
 #""

 #ef __init__(
 #elf,
 #attern: Any,
 #lags: Union[re.RegexFlag, int] = 0,
 #s_group_list: bool = False,
 #s_match: bool = False,
 #,
 #sGroupList: bool = False,
 #sMatch: bool = False,
 #:
 #""The parameters ``pattern`` and ``flags`` are passed
 #o the ``re.compile()`` function as-is. See the Python
 #re module <https://docs.python.org/3/library/re.html>`_ module for an
 #xplanation of the acceptable patterns and flags.
 #""
 #uper().__init__()
 #sGroupList = asGroupList or as_group_list
 #sMatch = asMatch or as_match

 #f isinstance(pattern, str_type):
 #f not pattern:
 #aise ValueError("null string passed to Regex; use Empty() instead")

 #elf._re = None
 #elf.reString = self.pattern = pattern
 #elf.flags = flags

 #lif hasattr(pattern, "pattern") and hasattr(pattern, "match"):
 #elf._re = pattern
 #elf.pattern = self.reString = pattern.pattern
 #elf.flags = flags

 #lse:
 #aise TypeError(
 #Regex may only be constructed with a string or a compiled RE object"
 #

 #elf.errmsg = "Expected " + self.name
 #elf.mayIndexError = False
 #elf.asGroupList = asGroupList
 #elf.asMatch = asMatch
 #f self.asGroupList:
 #elf.parseImpl = self.parseImplAsGroupList  # type: ignore [assignment]
 #f self.asMatch:
 #elf.parseImpl = self.parseImplAsMatch  # type: ignore [assignment]

 #cached_property
 #ef re(self):
 #f self._re:
 #eturn self._re
 #lse:
 #ry:
 #eturn re.compile(self.pattern, self.flags)
 #xcept re.error:
 #aise ValueError(f"invalid pattern ({self.pattern!r}) passed to Regex")

 #cached_property
 #ef re_match(self):
 #eturn self.re.match

 #cached_property
 #ef mayReturnEmpty(self):
 #eturn self.re_match("") is not None

 #ef _generateDefaultName(self) -> str:
 #eturn "Re:({})".format(repr(self.pattern).replace("\\\\", "\\"))

 #ef parseImpl(self, instring, loc, doActions=True):
 #esult = self.re_match(instring, loc)
 #f not result:
 #aise ParseException(instring, loc, self.errmsg, self)

 #oc = result.end()
 #et = ParseResults(result.group())
 # = result.groupdict()
 #f d:
 #or k, v in d.items():
 #et[k] = v
 #eturn loc, ret

 #ef parseImplAsGroupList(self, instring, loc, doActions=True):
 #esult = self.re_match(instring, loc)
 #f not result:
 #aise ParseException(instring, loc, self.errmsg, self)

 #oc = result.end()
 #et = result.groups()
 #eturn loc, ret

 #ef parseImplAsMatch(self, instring, loc, doActions=True):
 #esult = self.re_match(instring, loc)
 #f not result:
 #aise ParseException(instring, loc, self.errmsg, self)

 #oc = result.end()
 #et = result
 #eturn loc, ret

 #ef sub(self, repl: str) -> ParserElement:
 #"""
 #eturn :class:`Regex` with an attached parse action to transform the parsed
 #esult as if called using `re.sub(expr, repl, string) <https://docs.python.org/3/library/re.html#re.sub>`_.

 #xample::

 #ake_html = Regex(r"(\w+):(.*?):").sub(r"<\1>\2</\1>")
 #rint(make_html.transform_string("h1:main title:"))
            # prints "<h1>main title</h1>"
 #""
 #f self.asGroupList:
 #aise TypeError("cannot use sub() with Regex(as_group_list=True)")

 #f self.asMatch and callable(repl):
 #aise TypeError(
 #cannot use sub() with a callable with Regex(as_match=True)"
 #

 #f self.asMatch:

 #ef pa(tokens):
 #eturn tokens[0].expand(repl)

 #lse:

 #ef pa(tokens):
 #eturn self.re.sub(repl, tokens[0])

 #eturn self.add_parse_action(pa)


class QuotedString(Token):
 #"""
 #oken for matching strings that are delimited by quoting characters.

 #efined with the following parameters:

 # ``quote_char`` - string of one or more characters defining the
 #uote delimiting string
 # ``esc_char`` - character to re_escape quotes, typically backslash
 #default= ``None``)
 # ``esc_quote`` - special quote sequence to re_escape an embedded quote
 #tring (such as SQL's ``""`` to re_escape an embedded ``"``)
 #default= ``None``)
 # ``multiline`` - boolean indicating whether quotes can span
 #ultiple lines (default= ``False``)
 # ``unquote_results`` - boolean indicating whether the matched text
 #hould be unquoted (default= ``True``)
 # ``end_quote_char`` - string of one or more characters defining the
 #nd of the quote delimited string (default= ``None``  => same as
 #uote_char)
 # ``convert_whitespace_escapes`` - convert escaped whitespace
 #``'\t'``, ``'\n'``, etc.) to actual whitespace
 #default= ``True``)

 #xample::

 #s = QuotedString('"')
 #rint(qs.search_string('lsjdf "This is the quote" sldjf'))
 #omplex_qs = QuotedString('{{', end_quote_char='}}')
 #rint(complex_qs.search_string('lsjdf {{This is the "quote"}} sldjf'))
 #ql_qs = QuotedString('"', esc_quote='""')
 #rint(sql_qs.search_string('lsjdf "This is the quote with ""embedded"" quotes" sldjf'))

 #rints::

 #['This is the quote']]
 #['This is the "quote"']]
 #['This is the quote with "embedded" quotes']]
 #""
 #s_map = dict(((r"\t", "\t"), (r"\n", "\n"), (r"\f", "\f"), (r"\r", "\r")))

 #ef __init__(
 #elf,
 #uote_char: str = "",
 #sc_char: typing.Optional[str] = None,
 #sc_quote: typing.Optional[str] = None,
 #ultiline: bool = False,
 #nquote_results: bool = True,
 #nd_quote_char: typing.Optional[str] = None,
 #onvert_whitespace_escapes: bool = True,
 #,
 #uoteChar: str = "",
 #scChar: typing.Optional[str] = None,
 #scQuote: typing.Optional[str] = None,
 #nquoteResults: bool = True,
 #ndQuoteChar: typing.Optional[str] = None,
 #onvertWhitespaceEscapes: bool = True,
 #:
 #uper().__init__()
 #scChar = escChar or esc_char
 #scQuote = escQuote or esc_quote
 #nquoteResults = unquoteResults and unquote_results
 #ndQuoteChar = endQuoteChar or end_quote_char
 #onvertWhitespaceEscapes = (
 #onvertWhitespaceEscapes and convert_whitespace_escapes
 #
 #uote_char = quoteChar or quote_char

        # remove white space from quote chars - wont work anyway
 #uote_char = quote_char.strip()
 #f not quote_char:
 #aise ValueError("quote_char cannot be the empty string")

 #f endQuoteChar is None:
 #ndQuoteChar = quote_char
 #lse:
 #ndQuoteChar = endQuoteChar.strip()
 #f not endQuoteChar:
 #aise ValueError("end_quote_char cannot be the empty string")

 #elf.quoteChar: str = quote_char
 #elf.quoteCharLen: int = len(quote_char)
 #elf.firstQuoteChar: str = quote_char[0]
 #elf.endQuoteChar: str = endQuoteChar
 #elf.endQuoteCharLen: int = len(endQuoteChar)
 #elf.escChar: str = escChar or ""
 #elf.escQuote: str = escQuote or ""
 #elf.unquoteResults: bool = unquoteResults
 #elf.convertWhitespaceEscapes: bool = convertWhitespaceEscapes
 #elf.multiline = multiline

 #ep = ""
 #nner_pattern = ""

 #f escQuote:
 #nner_pattern += rf"{sep}(?:{re.escape(escQuote)})"
 #ep = "|"

 #f escChar:
 #nner_pattern += rf"{sep}(?:{re.escape(escChar)}.)"
 #ep = "|"
 #elf.escCharReplacePattern = re.escape(escChar) + "(.)"

 #f len(self.endQuoteChar) > 1:
 #nner_pattern += (
 #"{sep}(?:"
 # "|".join(
 #"(?:{re.escape(self.endQuoteChar[:i])}(?!{re.escape(self.endQuoteChar[i:])}))"
 #or i in range(len(self.endQuoteChar) - 1, 0, -1)
 #
 # ")"
 #
 #ep = "|"

 #elf.flags = re.RegexFlag(0)

 #f multiline:
 #elf.flags = re.MULTILINE | re.DOTALL
 #nner_pattern += (
 #f"{sep}(?:[^{_escape_regex_range_chars(self.endQuoteChar[0])}"
 #f"{(_escape_regex_range_chars(escChar) if escChar is not None else '')}])"
 #
 #lse:
 #nner_pattern += (
 #f"{sep}(?:[^{_escape_regex_range_chars(self.endQuoteChar[0])}\n\r"
 #f"{(_escape_regex_range_chars(escChar) if escChar is not None else '')}])"
 #

 #elf.pattern = "".join(
 #
 #e.escape(self.quoteChar),
 #(?:",
 #nner_pattern,
 #)*",
 #e.escape(self.endQuoteChar),
 #
 #

 #f self.unquoteResults:
 #f self.convertWhitespaceEscapes:
 #elf.unquote_scan_re = re.compile(
 #f"({'|'.join(re.escape(k) for k in self.ws_map)})|({re.escape(self.escChar)}.)|(\n|.)",
 #lags=self.flags,
 #
 #lse:
 #elf.unquote_scan_re = re.compile(
 #f"({re.escape(self.escChar)}.)|(\n|.)", flags=self.flags
 #

 #ry:
 #elf.re = re.compile(self.pattern, self.flags)
 #elf.reString = self.pattern
 #elf.re_match = self.re.match
 #xcept re.error:
 #aise ValueError(f"invalid pattern {self.pattern!r} passed to Regex")

 #elf.errmsg = "Expected " + self.name
 #elf.mayIndexError = False
 #elf.mayReturnEmpty = True

 #ef _generateDefaultName(self) -> str:
 #f self.quoteChar == self.endQuoteChar and isinstance(self.quoteChar, str_type):
 #eturn f"string enclosed in {self.quoteChar!r}"

 #eturn f"quoted string, starting with {self.quoteChar} ending with {self.endQuoteChar}"

 #ef parseImpl(self, instring, loc, doActions=True):
 #esult = (
 #nstring[loc] == self.firstQuoteChar
 #nd self.re_match(instring, loc)
 #r None
 #
 #f not result:
 #aise ParseException(instring, loc, self.errmsg, self)

 #oc = result.end()
 #et = result.group()

 #f self.unquoteResults:
            # strip off quotes
 #et = ret[self.quoteCharLen : -self.endQuoteCharLen]

 #f isinstance(ret, str_type):
 #f self.convertWhitespaceEscapes:
 #et = "".join(
 #elf.ws_map[match.group(1)]
 #f match.group(1)
 #lse match.group(2)[-1]
 #f match.group(2)
 #lse match.group(3)
 #or match in self.unquote_scan_re.finditer(ret)
 #
 #lse:
 #et = "".join(
 #atch.group(1)[-1] if match.group(1) else match.group(2)
 #or match in self.unquote_scan_re.finditer(ret)
 #

                # replace escaped quotes
 #f self.escQuote:
 #et = ret.replace(self.escQuote, self.endQuoteChar)

 #eturn loc, ret


class CharsNotIn(Token):
 #""Token for matching words composed of characters *not* in a given
 #et (will include whitespace in matched characters if not listed in
 #he provided exclusion set - see example). Defined with string
 #ontaining all disallowed characters, and an optional minimum,
 #aximum, and/or exact length.  The default value for ``min`` is
 # (a minimum value < 1 is not valid); the default values for
 #`max`` and ``exact`` are 0, meaning no maximum or exact
 #ength restriction.

 #xample::

        # define a comma-separated-value as anything that is not a ','
 #sv_value = CharsNotIn(',')
 #rint(DelimitedList(csv_value).parse_string("dkls,lsdkjf,s12 34,@!#,213"))

 #rints::

 #'dkls', 'lsdkjf', 's12 34', '@!#', '213']
 #""

 #ef __init__(
 #elf,
 #ot_chars: str = "",
 #in: int = 1,
 #ax: int = 0,
 #xact: int = 0,
 #,
 #otChars: str = "",
 #:
 #uper().__init__()
 #elf.skipWhitespace = False
 #elf.notChars = not_chars or notChars
 #elf.notCharsSet = set(self.notChars)

 #f min < 1:
 #aise ValueError(
 #cannot specify a minimum length < 1; use "
 #Opt(CharsNotIn()) if zero-length char group is permitted"
 #

 #elf.minLen = min

 #f max > 0:
 #elf.maxLen = max
 #lse:
 #elf.maxLen = _MAX_INT

 #f exact > 0:
 #elf.maxLen = exact
 #elf.minLen = exact

 #elf.errmsg = "Expected " + self.name
 #elf.mayReturnEmpty = self.minLen == 0
 #elf.mayIndexError = False

 #ef _generateDefaultName(self) -> str:
 #ot_chars_str = _collapse_string_to_ranges(self.notChars)
 #f len(not_chars_str) > 16:
 #eturn f"!W:({self.notChars[: 16 - 3]}...)"
 #lse:
 #eturn f"!W:({self.notChars})"

 #ef parseImpl(self, instring, loc, doActions=True):
 #otchars = self.notCharsSet
 #f instring[loc] in notchars:
 #aise ParseException(instring, loc, self.errmsg, self)

 #tart = loc
 #oc += 1
 #axlen = min(start + self.maxLen, len(instring))
 #hile loc < maxlen and instring[loc] not in notchars:
 #oc += 1

 #f loc - start < self.minLen:
 #aise ParseException(instring, loc, self.errmsg, self)

 #eturn loc, instring[start:loc]


class White(Token):
 #""Special matching class for matching whitespace.  Normally,
 #hitespace is ignored by pyparsing grammars.  This class is included
 #hen some whitespace structures are significant.  Define with
 # string containing the whitespace characters to be matched; default
 #s ``" \\t\\r\\n"``.  Also takes optional ``min``,
 #`max``, and ``exact`` arguments, as defined for the
 #class:`Word` class.
 #""

 #hiteStrs = {
 # ": "<SP>",
 #\t": "<TAB>",
 #\n": "<LF>",
 #\r": "<CR>",
 #\f": "<FF>",
 #\u00A0": "<NBSP>",
 #\u1680": "<OGHAM_SPACE_MARK>",
 #\u180E": "<MONGOLIAN_VOWEL_SEPARATOR>",
 #\u2000": "<EN_QUAD>",
 #\u2001": "<EM_QUAD>",
 #\u2002": "<EN_SPACE>",
 #\u2003": "<EM_SPACE>",
 #\u2004": "<THREE-PER-EM_SPACE>",
 #\u2005": "<FOUR-PER-EM_SPACE>",
 #\u2006": "<SIX-PER-EM_SPACE>",
 #\u2007": "<FIGURE_SPACE>",
 #\u2008": "<PUNCTUATION_SPACE>",
 #\u2009": "<THIN_SPACE>",
 #\u200A": "<HAIR_SPACE>",
 #\u200B": "<ZERO_WIDTH_SPACE>",
 #\u202F": "<NNBSP>",
 #\u205F": "<MMSP>",
 #\u3000": "<IDEOGRAPHIC_SPACE>",
 #

 #ef __init__(self, ws: str = " \t\r\n", min: int = 1, max: int = 0, exact: int = 0):
 #uper().__init__()
 #elf.matchWhite = ws
 #elf.set_whitespace_chars(
 #".join(c for c in self.whiteStrs if c not in self.matchWhite),
 #opy_defaults=True,
 #
        # self.leave_whitespace()
 #elf.mayReturnEmpty = True
 #elf.errmsg = "Expected " + self.name

 #elf.minLen = min

 #f max > 0:
 #elf.maxLen = max
 #lse:
 #elf.maxLen = _MAX_INT

 #f exact > 0:
 #elf.maxLen = exact
 #elf.minLen = exact

 #ef _generateDefaultName(self) -> str:
 #eturn "".join(White.whiteStrs[c] for c in self.matchWhite)

 #ef parseImpl(self, instring, loc, doActions=True):
 #f instring[loc] not in self.matchWhite:
 #aise ParseException(instring, loc, self.errmsg, self)
 #tart = loc
 #oc += 1
 #axloc = start + self.maxLen
 #axloc = min(maxloc, len(instring))
 #hile loc < maxloc and instring[loc] in self.matchWhite:
 #oc += 1

 #f loc - start < self.minLen:
 #aise ParseException(instring, loc, self.errmsg, self)

 #eturn loc, instring[start:loc]


class PositionToken(Token):
 #ef __init__(self):
 #uper().__init__()
 #elf.mayReturnEmpty = True
 #elf.mayIndexError = False


class GoToColumn(PositionToken):
 #""Token to advance to a specific column of input text; useful for
 #abular report scraping.
 #""

 #ef __init__(self, colno: int):
 #uper().__init__()
 #elf.col = colno

 #ef preParse(self, instring: str, loc: int) -> int:
 #f col(loc, instring) != self.col:
 #nstrlen = len(instring)
 #f self.ignoreExprs:
 #oc = self._skipIgnorables(instring, loc)
 #hile (
 #oc < instrlen
 #nd instring[loc].isspace()
 #nd col(loc, instring) != self.col
 #:
 #oc += 1
 #eturn loc

 #ef parseImpl(self, instring, loc, doActions=True):
 #hiscol = col(loc, instring)
 #f thiscol > self.col:
 #aise ParseException(instring, loc, "Text not in expected column", self)
 #ewloc = loc + self.col - thiscol
 #et = instring[loc:newloc]
 #eturn newloc, ret


class LineStart(PositionToken):
 #"""Matches if current position is at the beginning of a line within
 #he parse string

 #xample::

 #est = '''\
 #AA this line
 #AA and this line
 #AA but not this one
 # AAA and definitely not this one
 #''

 #or t in (LineStart() + 'AAA' + rest_of_line).search_string(test):
 #rint(t)

 #rints::

 #'AAA', ' this line']
 #'AAA', ' and this line']

 #""

 #ef __init__(self):
 #uper().__init__()
 #elf.leave_whitespace()
 #elf.orig_whiteChars = set() | self.whiteChars
 #elf.whiteChars.discard("\n")
 #elf.skipper = Empty().set_whitespace_chars(self.whiteChars)
 #elf.errmsg = "Expected start of line"

 #ef preParse(self, instring: str, loc: int) -> int:
 #f loc == 0:
 #eturn loc
 #lse:
 #et = self.skipper.preParse(instring, loc)
 #f "\n" in self.orig_whiteChars:
 #hile instring[ret : ret + 1] == "\n":
 #et = self.skipper.preParse(instring, ret + 1)
 #eturn ret

 #ef parseImpl(self, instring, loc, doActions=True):
 #f col(loc, instring) == 1:
 #eturn loc, []
 #aise ParseException(instring, loc, self.errmsg, self)


class LineEnd(PositionToken):
 #""Matches if current position is at the end of a line within the
 #arse string
 #""

 #ef __init__(self):
 #uper().__init__()
 #elf.whiteChars.discard("\n")
 #elf.set_whitespace_chars(self.whiteChars, copy_defaults=False)
 #elf.errmsg = "Expected end of line"

 #ef parseImpl(self, instring, loc, doActions=True):
 #f loc < len(instring):
 #f instring[loc] == "\n":
 #eturn loc + 1, "\n"
 #lse:
 #aise ParseException(instring, loc, self.errmsg, self)
 #lif loc == len(instring):
 #eturn loc + 1, []
 #lse:
 #aise ParseException(instring, loc, self.errmsg, self)


class StringStart(PositionToken):
 #""Matches if current position is at the beginning of the parse
 #tring
 #""

 #ef __init__(self):
 #uper().__init__()
 #elf.errmsg = "Expected start of text"

 #ef parseImpl(self, instring, loc, doActions=True):
 #f loc != 0:
            # see if entire string up to here is just whitespace and ignoreables
 #f loc != self.preParse(instring, 0):
 #aise ParseException(instring, loc, self.errmsg, self)
 #eturn loc, []


class StringEnd(PositionToken):
 #""
 #atches if current position is at the end of the parse string
 #""

 #ef __init__(self):
 #uper().__init__()
 #elf.errmsg = "Expected end of text"

 #ef parseImpl(self, instring, loc, doActions=True):
 #f loc < len(instring):
 #aise ParseException(instring, loc, self.errmsg, self)
 #lif loc == len(instring):
 #eturn loc + 1, []
 #lif loc > len(instring):
 #eturn loc, []
 #lse:
 #aise ParseException(instring, loc, self.errmsg, self)


class WordStart(PositionToken):
 #""Matches if the current position is at the beginning of a
 #class:`Word`, and is not preceded by any character in a given
 #et of ``word_chars`` (default= ``printables``). To emulate the
 #`\b`` behavior of regular expressions, use
 #`WordStart(alphanums)``. ``WordStart`` will also match at
 #he beginning of the string being parsed, or at the beginning of
 # line.
 #""

 #ef __init__(self, word_chars: str = printables, *, wordChars: str = printables):
 #ordChars = word_chars if wordChars == printables else wordChars
 #uper().__init__()
 #elf.wordChars = set(wordChars)
 #elf.errmsg = "Not at the start of a word"

 #ef parseImpl(self, instring, loc, doActions=True):
 #f loc != 0:
 #f (
 #nstring[loc - 1] in self.wordChars
 #r instring[loc] not in self.wordChars
 #:
 #aise ParseException(instring, loc, self.errmsg, self)
 #eturn loc, []


class WordEnd(PositionToken):
 #""Matches if the current position is at the end of a :class:`Word`,
 #nd is not followed by any character in a given set of ``word_chars``
 #default= ``printables``). To emulate the ``\b`` behavior of
 #egular expressions, use ``WordEnd(alphanums)``. ``WordEnd``
 #ill also match at the end of the string being parsed, or at the end
 #f a line.
 #""

 #ef __init__(self, word_chars: str = printables, *, wordChars: str = printables):
 #ordChars = word_chars if wordChars == printables else wordChars
 #uper().__init__()
 #elf.wordChars = set(wordChars)
 #elf.skipWhitespace = False
 #elf.errmsg = "Not at the end of a word"

 #ef parseImpl(self, instring, loc, doActions=True):
 #nstrlen = len(instring)
 #f instrlen > 0 and loc < instrlen:
 #f (
 #nstring[loc] in self.wordChars
 #r instring[loc - 1] not in self.wordChars
 #:
 #aise ParseException(instring, loc, self.errmsg, self)
 #eturn loc, []


class ParseExpression(ParserElement):
 #""Abstract subclass of ParserElement, for combining and
 #ost-processing parsed tokens.
 #""

 #ef __init__(self, exprs: typing.Iterable[ParserElement], savelist: bool = False):
 #uper().__init__(savelist)
 #elf.exprs: List[ParserElement]
 #f isinstance(exprs, _generatorType):
 #xprs = list(exprs)

 #f isinstance(exprs, str_type):
 #elf.exprs = [self._literalStringClass(exprs)]
 #lif isinstance(exprs, ParserElement):
 #elf.exprs = [exprs]
 #lif isinstance(exprs, Iterable):
 #xprs = list(exprs)
            # if sequence of strings provided, wrap with Literal
 #f any(isinstance(expr, str_type) for expr in exprs):
 #xprs = (
 #elf._literalStringClass(e) if isinstance(e, str_type) else e
 #or e in exprs
 #
 #elf.exprs = list(exprs)
 #lse:
 #ry:
 #elf.exprs = list(exprs)
 #xcept TypeError:
 #elf.exprs = [exprs]
 #elf.callPreparse = False

 #ef recurse(self) -> List[ParserElement]:
 #eturn self.exprs[:]

 #ef append(self, other) -> ParserElement:
 #elf.exprs.append(other)
 #elf._defaultName = None
 #eturn self

 #ef leave_whitespace(self, recursive: bool = True) -> ParserElement:
 #""
 #xtends ``leave_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on
 #ll contained expressions.
 #""
 #uper().leave_whitespace(recursive)

 #f recursive:
 #elf.exprs = [e.copy() for e in self.exprs]
 #or e in self.exprs:
 #.leave_whitespace(recursive)
 #eturn self

 #ef ignore_whitespace(self, recursive: bool = True) -> ParserElement:
 #""
 #xtends ``ignore_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on
 #ll contained expressions.
 #""
 #uper().ignore_whitespace(recursive)
 #f recursive:
 #elf.exprs = [e.copy() for e in self.exprs]
 #or e in self.exprs:
 #.ignore_whitespace(recursive)
 #eturn self

 #ef ignore(self, other) -> ParserElement:
 #f isinstance(other, Suppress):
 #f other not in self.ignoreExprs:
 #uper().ignore(other)
 #or e in self.exprs:
 #.ignore(self.ignoreExprs[-1])
 #lse:
 #uper().ignore(other)
 #or e in self.exprs:
 #.ignore(self.ignoreExprs[-1])
 #eturn self

 #ef _generateDefaultName(self) -> str:
 #eturn f"{self.__class__.__name__}:({str(self.exprs)})"

 #ef streamline(self) -> ParserElement:
 #f self.streamlined:
 #eturn self

 #uper().streamline()

 #or e in self.exprs:
 #.streamline()

        # collapse nested :class:`And`'s of the form ``And(And(And(a, b), c), d)`` to ``And(a, b, c, d)``
        # but only if there are no parse actions or resultsNames on the nested And's
        # (likewise for :class:`Or`'s and :class:`MatchFirst`'s)
 #f len(self.exprs) == 2:
 #ther = self.exprs[0]
 #f (
 #sinstance(other, self.__class__)
 #nd not other.parseAction
 #nd other.resultsName is None
 #nd not other.debug
 #:
 #elf.exprs = other.exprs[:] + [self.exprs[1]]
 #elf._defaultName = None
 #elf.mayReturnEmpty |= other.mayReturnEmpty
 #elf.mayIndexError |= other.mayIndexError

 #ther = self.exprs[-1]
 #f (
 #sinstance(other, self.__class__)
 #nd not other.parseAction
 #nd other.resultsName is None
 #nd not other.debug
 #:
 #elf.exprs = self.exprs[:-1] + other.exprs[:]
 #elf._defaultName = None
 #elf.mayReturnEmpty |= other.mayReturnEmpty
 #elf.mayIndexError |= other.mayIndexError

 #elf.errmsg = "Expected " + str(self)

 #eturn self

 #ef validate(self, validateTrace=None) -> None:
 #arnings.warn(
 #ParserElement.validate() is deprecated, and should not be used to check for left recursion",
 #eprecationWarning,
 #tacklevel=2,
 #
 #mp = (validateTrace if validateTrace is not None else [])[:] + [self]
 #or e in self.exprs:
 #.validate(tmp)
 #elf._checkRecursion([])

 #ef copy(self) -> ParserElement:
 #et = super().copy()
 #et = typing.cast(ParseExpression, ret)
 #et.exprs = [e.copy() for e in self.exprs]
 #eturn ret

 #ef _setResultsName(self, name, listAllMatches=False):
 #f (
 #_diag__.warn_ungrouped_named_tokens_in_collection
 #nd Diagnostics.warn_ungrouped_named_tokens_in_collection
 #ot in self.suppress_warnings_
 #:
 #or e in self.exprs:
 #f (
 #sinstance(e, ParserElement)
 #nd e.resultsName
 #nd Diagnostics.warn_ungrouped_named_tokens_in_collection
 #ot in e.suppress_warnings_
 #:
 #arnings.warn(
 #{}: setting results name {!r} on {} expression "
 #collides with {!r} on contained expression".format(
 #warn_ungrouped_named_tokens_in_collection",
 #ame,
 #ype(self).__name__,
 #.resultsName,
 #,
 #tacklevel=3,
 #

 #eturn super()._setResultsName(name, listAllMatches)

    # Compatibility synonyms
    # fmt: off
 #replaced_by_pep8(leave_whitespace)
 #ef leaveWhitespace(self): ...

 #replaced_by_pep8(ignore_whitespace)
 #ef ignoreWhitespace(self): ...
    # fmt: on


class And(ParseExpression):
 #""
 #equires all given :class:`ParseExpression` s to be found in the given order.
 #xpressions may be separated by whitespace.
 #ay be constructed using the ``'+'`` operator.
 #ay also be constructed using the ``'-'`` operator, which will
 #uppress backtracking.

 #xample::

 #nteger = Word(nums)
 #ame_expr = Word(alphas)[1, ...]

 #xpr = And([integer("id"), name_expr("name"), integer("age")])
        # more easily written as:
 #xpr = integer("id") + name_expr("name") + integer("age")
 #""

 #lass _ErrorStop(Empty):
 #ef __init__(self, *args, **kwargs):
 #uper().__init__(*args, **kwargs)
 #elf.leave_whitespace()

 #ef _generateDefaultName(self) -> str:
 #eturn "-"

 #ef __init__(
 #elf, exprs_arg: typing.Iterable[ParserElement], savelist: bool = True
 #:
 #xprs: List[ParserElement] = list(exprs_arg)
 #f exprs and Ellipsis in exprs:
 #mp = []
 #or i, expr in enumerate(exprs):
 #f expr is Ellipsis:
 #f i < len(exprs) - 1:
 #kipto_arg: ParserElement = typing.cast(
 #arseExpression, (Empty() + exprs[i + 1])
 #.exprs[-1]
 #mp.append(SkipTo(skipto_arg)("_skipped*"))
 #lse:
 #aise Exception(
 #cannot construct And with sequence ending in ..."
 #
 #lse:
 #mp.append(expr)
 #xprs[:] = tmp
 #uper().__init__(exprs, savelist)
 #f self.exprs:
 #elf.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
 #f not isinstance(self.exprs[0], White):
 #elf.set_whitespace_chars(
 #elf.exprs[0].whiteChars,
 #opy_defaults=self.exprs[0].copyDefaultWhiteChars,
 #
 #elf.skipWhitespace = self.exprs[0].skipWhitespace
 #lse:
 #elf.skipWhitespace = False
 #lse:
 #elf.mayReturnEmpty = True
 #elf.callPreparse = True

 #ef streamline(self) -> ParserElement:
        # collapse any _PendingSkip's
 #f self.exprs:
 #f any(
 #sinstance(e, ParseExpression)
 #nd e.exprs
 #nd isinstance(e.exprs[-1], _PendingSkip)
 #or e in self.exprs[:-1]
 #:
 #eleted_expr_marker = NoMatch()
 #or i, e in enumerate(self.exprs[:-1]):
 #f e is deleted_expr_marker:
 #ontinue
 #f (
 #sinstance(e, ParseExpression)
 #nd e.exprs
 #nd isinstance(e.exprs[-1], _PendingSkip)
 #:
 #.exprs[-1] = e.exprs[-1] + self.exprs[i + 1]
 #elf.exprs[i + 1] = deleted_expr_marker
 #elf.exprs = [e for e in self.exprs if e is not deleted_expr_marker]

 #uper().streamline()

        # link any IndentedBlocks to the prior expression
 #rev: ParserElement
 #ur: ParserElement
 #or prev, cur in zip(self.exprs, self.exprs[1:]):
            # traverse cur or any first embedded expr of cur looking for an IndentedBlock
            # (but watch out for recursive grammar)
 #een = set()
 #hile True:
 #f id(cur) in seen:
 #reak
 #een.add(id(cur))
 #f isinstance(cur, IndentedBlock):
 #rev.add_parse_action(
 #ambda s, l, t, cur_=cur: setattr(
 #ur_, "parent_anchor", col(l, s)
 #
 #
 #reak
 #ubs = cur.recurse()
 #ext_first = next(iter(subs), None)
 #f next_first is None:
 #reak
 #ur = typing.cast(ParserElement, next_first)

 #elf.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
 #eturn self

 #ef parseImpl(self, instring, loc, doActions=True):
        # pass False as callPreParse arg to _parse for first element, since we already
        # pre-parsed the string as part of our And pre-parsing
 #oc, resultlist = self.exprs[0]._parse(
 #nstring, loc, doActions, callPreParse=False
 #
 #rrorStop = False
 #or e in self.exprs[1:]:
            # if isinstance(e, And._ErrorStop):
 #f type(e) is And._ErrorStop:
 #rrorStop = True
 #ontinue
 #f errorStop:
 #ry:
 #oc, exprtokens = e._parse(instring, loc, doActions)
 #xcept ParseSyntaxException:
 #aise
 #xcept ParseBaseException as pe:
 #e.__traceback__ = None
 #aise ParseSyntaxException._from_exception(pe)
 #xcept IndexError:
 #aise ParseSyntaxException(
 #nstring, len(instring), self.errmsg, self
 #
 #lse:
 #oc, exprtokens = e._parse(instring, loc, doActions)
 #esultlist += exprtokens
 #eturn loc, resultlist

 #ef __iadd__(self, other):
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn self.append(other)  # And([self, other])

 #ef _checkRecursion(self, parseElementList):
 #ubRecCheckList = parseElementList[:] + [self]
 #or e in self.exprs:
 #._checkRecursion(subRecCheckList)
 #f not e.mayReturnEmpty:
 #reak

 #ef _generateDefaultName(self) -> str:
 #nner = " ".join(str(e) for e in self.exprs)
        # strip off redundant inner {}'s
 #hile len(inner) > 1 and inner[0 :: len(inner) - 1] == "{}":
 #nner = inner[1:-1]
 #eturn "{" + inner + "}"


class Or(ParseExpression):
 #""Requires that at least one :class:`ParseExpression` is found. If
 #wo expressions match, the expression that matches the longest
 #tring will be used. May be constructed using the ``'^'``
 #perator.

 #xample::

        # construct Or using '^' operator

 #umber = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums))
 #rint(number.search_string("123 3.1416 789"))

 #rints::

 #['123'], ['3.1416'], ['789']]
 #""

 #ef __init__(self, exprs: typing.Iterable[ParserElement], savelist: bool = False):
 #uper().__init__(exprs, savelist)
 #f self.exprs:
 #elf.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)
 #elf.skipWhitespace = all(e.skipWhitespace for e in self.exprs)
 #lse:
 #elf.mayReturnEmpty = True

 #ef streamline(self) -> ParserElement:
 #uper().streamline()
 #f self.exprs:
 #elf.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)
 #elf.saveAsList = any(e.saveAsList for e in self.exprs)
 #elf.skipWhitespace = all(
 #.skipWhitespace and not isinstance(e, White) for e in self.exprs
 #
 #lse:
 #elf.saveAsList = False
 #eturn self

 #ef parseImpl(self, instring, loc, doActions=True):
 #axExcLoc = -1
 #axException = None
 #atches = []
 #atals = []
 #f all(e.callPreparse for e in self.exprs):
 #oc = self.preParse(instring, loc)
 #or e in self.exprs:
 #ry:
 #oc2 = e.try_parse(instring, loc, raise_fatal=True)
 #xcept ParseFatalException as pfe:
 #fe.__traceback__ = None
 #fe.parser_element = e
 #atals.append(pfe)
 #axException = None
 #axExcLoc = -1
 #xcept ParseException as err:
 #f not fatals:
 #rr.__traceback__ = None
 #f err.loc > maxExcLoc:
 #axException = err
 #axExcLoc = err.loc
 #xcept IndexError:
 #f len(instring) > maxExcLoc:
 #axException = ParseException(
 #nstring, len(instring), e.errmsg, self
 #
 #axExcLoc = len(instring)
 #lse:
                # save match among all matches, to retry longest to shortest
 #atches.append((loc2, e))

 #f matches:
            # re-evaluate all matches in descending order of length of match, in case attached actions
            # might change whether or how much they match of the input.
 #atches.sort(key=itemgetter(0), reverse=True)

 #f not doActions:
                # no further conditions or parse actions to change the selection of
                # alternative, so the first match will be the best match
 #est_expr = matches[0][1]
 #eturn best_expr._parse(instring, loc, doActions)

 #ongest = -1, None
 #or loc1, expr1 in matches:
 #f loc1 <= longest[0]:
                    # already have a longer match than this one will deliver, we are done
 #eturn longest

 #ry:
 #oc2, toks = expr1._parse(instring, loc, doActions)
 #xcept ParseException as err:
 #rr.__traceback__ = None
 #f err.loc > maxExcLoc:
 #axException = err
 #axExcLoc = err.loc
 #lse:
 #f loc2 >= loc1:
 #eturn loc2, toks
                    # didn't match as much as before
 #lif loc2 > longest[0]:
 #ongest = loc2, toks

 #f longest != (-1, None):
 #eturn longest

 #f fatals:
 #f len(fatals) > 1:
 #atals.sort(key=lambda e: -e.loc)
 #f fatals[0].loc == fatals[1].loc:
 #atals.sort(key=lambda e: (-e.loc, -len(str(e.parser_element))))
 #ax_fatal = fatals[0]
 #aise max_fatal

 #f maxException is not None:
            # infer from this check that all alternatives failed at the current position
            # so emit this collective error message instead of any single error message
 #f maxExcLoc == loc:
 #axException.msg = self.errmsg
 #aise maxException
 #lse:
 #aise ParseException(
 #nstring, loc, "no defined alternatives to match", self
 #

 #ef __ixor__(self, other):
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn self.append(other)  # Or([self, other])

 #ef _generateDefaultName(self) -> str:
 #eturn "{" + " ^ ".join(str(e) for e in self.exprs) + "}"

 #ef _setResultsName(self, name, listAllMatches=False):
 #f (
 #_diag__.warn_multiple_tokens_in_named_alternation
 #nd Diagnostics.warn_multiple_tokens_in_named_alternation
 #ot in self.suppress_warnings_
 #:
 #f any(
 #sinstance(e, And)
 #nd Diagnostics.warn_multiple_tokens_in_named_alternation
 #ot in e.suppress_warnings_
 #or e in self.exprs
 #:
 #arnings.warn(
 #{}: setting results name {!r} on {} expression "
 #will return a list of all parsed tokens in an And alternative, "
 #in prior versions only the first token was returned; enclose "
 #contained argument in Group".format(
 #warn_multiple_tokens_in_named_alternation",
 #ame,
 #ype(self).__name__,
 #,
 #tacklevel=3,
 #

 #eturn super()._setResultsName(name, listAllMatches)


class MatchFirst(ParseExpression):
 #""Requires that at least one :class:`ParseExpression` is found. If
 #ore than one expression matches, the first one listed is the one that will
 #atch. May be constructed using the ``'|'`` operator.

 #xample::

        # construct MatchFirst using '|' operator

        # watch the order of expressions to match
 #umber = Word(nums) | Combine(Word(nums) + '.' + Word(nums))
 #rint(number.search_string("123 3.1416 789")) #  Fail! -> [['123'], ['3'], ['1416'], ['789']]

        # put more selective expression first
 #umber = Combine(Word(nums) + '.' + Word(nums)) | Word(nums)
 #rint(number.search_string("123 3.1416 789")) #  Better -> [['123'], ['3.1416'], ['789']]
 #""

 #ef __init__(self, exprs: typing.Iterable[ParserElement], savelist: bool = False):
 #uper().__init__(exprs, savelist)
 #f self.exprs:
 #elf.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)
 #elf.skipWhitespace = all(e.skipWhitespace for e in self.exprs)
 #lse:
 #elf.mayReturnEmpty = True

 #ef streamline(self) -> ParserElement:
 #f self.streamlined:
 #eturn self

 #uper().streamline()
 #f self.exprs:
 #elf.saveAsList = any(e.saveAsList for e in self.exprs)
 #elf.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)
 #elf.skipWhitespace = all(
 #.skipWhitespace and not isinstance(e, White) for e in self.exprs
 #
 #lse:
 #elf.saveAsList = False
 #elf.mayReturnEmpty = True
 #eturn self

 #ef parseImpl(self, instring, loc, doActions=True):
 #axExcLoc = -1
 #axException = None

 #or e in self.exprs:
 #ry:
 #eturn e._parse(
 #nstring,
 #oc,
 #oActions,
 #
 #xcept ParseFatalException as pfe:
 #fe.__traceback__ = None
 #fe.parser_element = e
 #aise
 #xcept ParseException as err:
 #f err.loc > maxExcLoc:
 #axException = err
 #axExcLoc = err.loc
 #xcept IndexError:
 #f len(instring) > maxExcLoc:
 #axException = ParseException(
 #nstring, len(instring), e.errmsg, self
 #
 #axExcLoc = len(instring)

 #f maxException is not None:
            # infer from this check that all alternatives failed at the current position
            # so emit this collective error message instead of any individual error message
 #f maxExcLoc == loc:
 #axException.msg = self.errmsg
 #aise maxException
 #lse:
 #aise ParseException(
 #nstring, loc, "no defined alternatives to match", self
 #

 #ef __ior__(self, other):
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn self.append(other)  # MatchFirst([self, other])

 #ef _generateDefaultName(self) -> str:
 #eturn "{" + " | ".join(str(e) for e in self.exprs) + "}"

 #ef _setResultsName(self, name, listAllMatches=False):
 #f (
 #_diag__.warn_multiple_tokens_in_named_alternation
 #nd Diagnostics.warn_multiple_tokens_in_named_alternation
 #ot in self.suppress_warnings_
 #:
 #f any(
 #sinstance(e, And)
 #nd Diagnostics.warn_multiple_tokens_in_named_alternation
 #ot in e.suppress_warnings_
 #or e in self.exprs
 #:
 #arnings.warn(
 #{}: setting results name {!r} on {} expression "
 #will return a list of all parsed tokens in an And alternative, "
 #in prior versions only the first token was returned; enclose "
 #contained argument in Group".format(
 #warn_multiple_tokens_in_named_alternation",
 #ame,
 #ype(self).__name__,
 #,
 #tacklevel=3,
 #

 #eturn super()._setResultsName(name, listAllMatches)


class Each(ParseExpression):
 #""Requires all given :class:`ParseExpression` s to be found, but in
 #ny order. Expressions may be separated by whitespace.

 #ay be constructed using the ``'&'`` operator.

 #xample::

 #olor = one_of("RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN")
 #hape_type = one_of("SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON")
 #nteger = Word(nums)
 #hape_attr = "shape:" + shape_type("shape")
 #osn_attr = "posn:" + Group(integer("x") + ',' + integer("y"))("posn")
 #olor_attr = "color:" + color("color")
 #ize_attr = "size:" + integer("size")

        # use Each (using operator '&') to accept attributes in any order
        # (shape and posn are required, color and size are optional)
 #hape_spec = shape_attr & posn_attr & Opt(color_attr) & Opt(size_attr)

 #hape_spec.run_tests('''
 #hape: SQUARE color: BLACK posn: 100, 120
 #hape: CIRCLE size: 50 color: BLUE posn: 50,80
 #olor:GREEN size:20 shape:TRIANGLE posn:20,40
 #''
 #

 #rints::

 #hape: SQUARE color: BLACK posn: 100, 120
 #'shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']]
 # color: BLACK
 # posn: ['100', ',', '120']
 # x: 100
 # y: 120
 # shape: SQUARE


 #hape: CIRCLE size: 50 color: BLUE posn: 50,80
 #'shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']]
 # color: BLUE
 # posn: ['50', ',', '80']
 # x: 50
 # y: 80
 # shape: CIRCLE
 # size: 50


 #olor: GREEN size: 20 shape: TRIANGLE posn: 20,40
 #'color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']]
 # color: GREEN
 # posn: ['20', ',', '40']
 # x: 20
 # y: 40
 # shape: TRIANGLE
 # size: 20
 #""

 #ef __init__(self, exprs: typing.Iterable[ParserElement], savelist: bool = True):
 #uper().__init__(exprs, savelist)
 #f self.exprs:
 #elf.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
 #lse:
 #elf.mayReturnEmpty = True
 #elf.skipWhitespace = True
 #elf.initExprGroups = True
 #elf.saveAsList = True

 #ef __iand__(self, other):
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented
 #eturn self.append(other)  # Each([self, other])

 #ef streamline(self) -> ParserElement:
 #uper().streamline()
 #f self.exprs:
 #elf.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)
 #lse:
 #elf.mayReturnEmpty = True
 #eturn self

 #ef parseImpl(self, instring, loc, doActions=True):
 #f self.initExprGroups:
 #elf.opt1map = dict(
 #id(e.expr), e) for e in self.exprs if isinstance(e, Opt)
 #
 #pt1 = [e.expr for e in self.exprs if isinstance(e, Opt)]
 #pt2 = [
 #
 #or e in self.exprs
 #f e.mayReturnEmpty and not isinstance(e, (Opt, Regex, ZeroOrMore))
 #
 #elf.optionals = opt1 + opt2
 #elf.multioptionals = [
 #.expr.set_results_name(e.resultsName, list_all_matches=True)
 #or e in self.exprs
 #f isinstance(e, _MultipleMatch)
 #
 #elf.multirequired = [
 #.expr.set_results_name(e.resultsName, list_all_matches=True)
 #or e in self.exprs
 #f isinstance(e, OneOrMore)
 #
 #elf.required = [
 # for e in self.exprs if not isinstance(e, (Opt, ZeroOrMore, OneOrMore))
 #
 #elf.required += self.multirequired
 #elf.initExprGroups = False

 #mpLoc = loc
 #mpReqd = self.required[:]
 #mpOpt = self.optionals[:]
 #ultis = self.multioptionals[:]
 #atchOrder = []

 #eepMatching = True
 #ailed = []
 #atals = []
 #hile keepMatching:
 #mpExprs = tmpReqd + tmpOpt + multis
 #ailed.clear()
 #atals.clear()
 #or e in tmpExprs:
 #ry:
 #mpLoc = e.try_parse(instring, tmpLoc, raise_fatal=True)
 #xcept ParseFatalException as pfe:
 #fe.__traceback__ = None
 #fe.parser_element = e
 #atals.append(pfe)
 #ailed.append(e)
 #xcept ParseException:
 #ailed.append(e)
 #lse:
 #atchOrder.append(self.opt1map.get(id(e), e))
 #f e in tmpReqd:
 #mpReqd.remove(e)
 #lif e in tmpOpt:
 #mpOpt.remove(e)
 #f len(failed) == len(tmpExprs):
 #eepMatching = False

        # look for any ParseFatalExceptions
 #f fatals:
 #f len(fatals) > 1:
 #atals.sort(key=lambda e: -e.loc)
 #f fatals[0].loc == fatals[1].loc:
 #atals.sort(key=lambda e: (-e.loc, -len(str(e.parser_element))))
 #ax_fatal = fatals[0]
 #aise max_fatal

 #f tmpReqd:
 #issing = ", ".join([str(e) for e in tmpReqd])
 #aise ParseException(
 #nstring,
 #oc,
 #"Missing one or more required elements ({missing})",
 #

        # add any unmatched Opts, in case they have default values defined
 #atchOrder += [e for e in self.exprs if isinstance(e, Opt) and e.expr in tmpOpt]

 #otal_results = ParseResults([])
 #or e in matchOrder:
 #oc, results = e._parse(instring, loc, doActions)
 #otal_results += results

 #eturn loc, total_results

 #ef _generateDefaultName(self) -> str:
 #eturn "{" + " & ".join(str(e) for e in self.exprs) + "}"


class ParseElementEnhance(ParserElement):
 #""Abstract subclass of :class:`ParserElement`, for combining and
 #ost-processing parsed tokens.
 #""

 #ef __init__(self, expr: Union[ParserElement, str], savelist: bool = False):
 #uper().__init__(savelist)
 #f isinstance(expr, str_type):
 #xpr_str = typing.cast(str, expr)
 #f issubclass(self._literalStringClass, Token):
 #xpr = self._literalStringClass(expr_str)  # type: ignore[call-arg]
 #lif issubclass(type(self), self._literalStringClass):
 #xpr = Literal(expr_str)
 #lse:
 #xpr = self._literalStringClass(Literal(expr_str))  # type: ignore[assignment, call-arg]
 #xpr = typing.cast(ParserElement, expr)
 #elf.expr = expr
 #f expr is not None:
 #elf.mayIndexError = expr.mayIndexError
 #elf.mayReturnEmpty = expr.mayReturnEmpty
 #elf.set_whitespace_chars(
 #xpr.whiteChars, copy_defaults=expr.copyDefaultWhiteChars
 #
 #elf.skipWhitespace = expr.skipWhitespace
 #elf.saveAsList = expr.saveAsList
 #elf.callPreparse = expr.callPreparse
 #elf.ignoreExprs.extend(expr.ignoreExprs)

 #ef recurse(self) -> List[ParserElement]:
 #eturn [self.expr] if self.expr is not None else []

 #ef parseImpl(self, instring, loc, doActions=True):
 #f self.expr is not None:
 #ry:
 #eturn self.expr._parse(instring, loc, doActions, callPreParse=False)
 #xcept ParseBaseException as pbe:
 #be.msg = self.errmsg
 #aise
 #lse:
 #aise ParseException(instring, loc, "No expression defined", self)

 #ef leave_whitespace(self, recursive: bool = True) -> ParserElement:
 #uper().leave_whitespace(recursive)

 #f recursive:
 #f self.expr is not None:
 #elf.expr = self.expr.copy()
 #elf.expr.leave_whitespace(recursive)
 #eturn self

 #ef ignore_whitespace(self, recursive: bool = True) -> ParserElement:
 #uper().ignore_whitespace(recursive)

 #f recursive:
 #f self.expr is not None:
 #elf.expr = self.expr.copy()
 #elf.expr.ignore_whitespace(recursive)
 #eturn self

 #ef ignore(self, other) -> ParserElement:
 #f isinstance(other, Suppress):
 #f other not in self.ignoreExprs:
 #uper().ignore(other)
 #f self.expr is not None:
 #elf.expr.ignore(self.ignoreExprs[-1])
 #lse:
 #uper().ignore(other)
 #f self.expr is not None:
 #elf.expr.ignore(self.ignoreExprs[-1])
 #eturn self

 #ef streamline(self) -> ParserElement:
 #uper().streamline()
 #f self.expr is not None:
 #elf.expr.streamline()
 #eturn self

 #ef _checkRecursion(self, parseElementList):
 #f self in parseElementList:
 #aise RecursiveGrammarException(parseElementList + [self])
 #ubRecCheckList = parseElementList[:] + [self]
 #f self.expr is not None:
 #elf.expr._checkRecursion(subRecCheckList)

 #ef validate(self, validateTrace=None) -> None:
 #arnings.warn(
 #ParserElement.validate() is deprecated, and should not be used to check for left recursion",
 #eprecationWarning,
 #tacklevel=2,
 #
 #f validateTrace is None:
 #alidateTrace = []
 #mp = validateTrace[:] + [self]
 #f self.expr is not None:
 #elf.expr.validate(tmp)
 #elf._checkRecursion([])

 #ef _generateDefaultName(self) -> str:
 #eturn f"{self.__class__.__name__}:({str(self.expr)})"

    # Compatibility synonyms
    # fmt: off
 #replaced_by_pep8(leave_whitespace)
 #ef leaveWhitespace(self): ...

 #replaced_by_pep8(ignore_whitespace)
 #ef ignoreWhitespace(self): ...
    # fmt: on


class IndentedBlock(ParseElementEnhance):
 #""
 #xpression to match one or more expressions at a given indentation level.
 #seful for parsing text where structure is implied by indentation (like Python source code).
 #""

 #lass _Indent(Empty):
 #ef __init__(self, ref_col: int):
 #uper().__init__()
 #elf.errmsg = f"expected indent at column {ref_col}"
 #elf.add_condition(lambda s, l, t: col(l, s) == ref_col)

 #lass _IndentGreater(Empty):
 #ef __init__(self, ref_col: int):
 #uper().__init__()
 #elf.errmsg = f"expected indent at column greater than {ref_col}"
 #elf.add_condition(lambda s, l, t: col(l, s) > ref_col)

 #ef __init__(
 #elf, expr: ParserElement, *, recursive: bool = False, grouped: bool = True
 #:
 #uper().__init__(expr, savelist=True)
        # if recursive:
        #     raise NotImplementedError("IndentedBlock with recursive is not implemented")
 #elf._recursive = recursive
 #elf._grouped = grouped
 #elf.parent_anchor = 1

 #ef parseImpl(self, instring, loc, doActions=True):
        # advance parse position to non-whitespace by using an Empty()
        # this should be the column to be used for all subsequent indented lines
 #nchor_loc = Empty().preParse(instring, loc)

        # see if self.expr matches at the current location - if not it will raise an exception
        # and no further work is necessary
 #elf.expr.try_parse(instring, anchor_loc, do_actions=doActions)

 #ndent_col = col(anchor_loc, instring)
 #eer_detect_expr = self._Indent(indent_col)

 #nner_expr = Empty() + peer_detect_expr + self.expr
 #f self._recursive:
 #ub_indent = self._IndentGreater(indent_col)
 #ested_block = IndentedBlock(
 #elf.expr, recursive=self._recursive, grouped=self._grouped
 #
 #ested_block.set_debug(self.debug)
 #ested_block.parent_anchor = indent_col
 #nner_expr += Opt(sub_indent + nested_block)

 #nner_expr.set_name(f"inner {hex(id(inner_expr))[-4:].upper()}@{indent_col}")
 #lock = OneOrMore(inner_expr)

 #railing_undent = self._Indent(self.parent_anchor) | StringEnd()

 #f self._grouped:
 #rapper = Group
 #lse:
 #rapper = lambda expr: expr
 #eturn (wrapper(block) + Optional(trailing_undent)).parseImpl(
 #nstring, anchor_loc, doActions
 #


class AtStringStart(ParseElementEnhance):
 #""Matches if expression matches at the beginning of the parse
 #tring::

 #tStringStart(Word(nums)).parse_string("123")
        # prints ["123"]

 #tStringStart(Word(nums)).parse_string("    123")
        # raises ParseException
 #""

 #ef __init__(self, expr: Union[ParserElement, str]):
 #uper().__init__(expr)
 #elf.callPreparse = False

 #ef parseImpl(self, instring, loc, doActions=True):
 #f loc != 0:
 #aise ParseException(instring, loc, "not found at string start")
 #eturn super().parseImpl(instring, loc, doActions)


class AtLineStart(ParseElementEnhance):
 #"""Matches if an expression matches at the beginning of a line within
 #he parse string

 #xample::

 #est = '''\
 #AA this line
 #AA and this line
 #AA but not this one
 # AAA and definitely not this one
 #''

 #or t in (AtLineStart('AAA') + rest_of_line).search_string(test):
 #rint(t)

 #rints::

 #'AAA', ' this line']
 #'AAA', ' and this line']

 #""

 #ef __init__(self, expr: Union[ParserElement, str]):
 #uper().__init__(expr)
 #elf.callPreparse = False

 #ef parseImpl(self, instring, loc, doActions=True):
 #f col(loc, instring) != 1:
 #aise ParseException(instring, loc, "not found at line start")
 #eturn super().parseImpl(instring, loc, doActions)


class FollowedBy(ParseElementEnhance):
 #""Lookahead matching of the given parse expression.
 #`FollowedBy`` does *not* advance the parsing position within
 #he input string, it only verifies that the specified parse
 #xpression matches at the current position.  ``FollowedBy``
 #lways returns a null token list. If any results names are defined
 #n the lookahead expression, those *will* be returned for access by
 #ame.

 #xample::

        # use FollowedBy to match a label only if it is followed by a ':'
 #ata_word = Word(alphas)
 #abel = data_word + FollowedBy(':')
 #ttr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))

 #ttr_expr[1, ...].parse_string("shape: SQUARE color: BLACK posn: upper left").pprint()

 #rints::

 #['shape', 'SQUARE'], ['color', 'BLACK'], ['posn', 'upper left']]
 #""

 #ef __init__(self, expr: Union[ParserElement, str]):
 #uper().__init__(expr)
 #elf.mayReturnEmpty = True

 #ef parseImpl(self, instring, loc, doActions=True):
        # by using self._expr.parse and deleting the contents of the returned ParseResults list
        # we keep any named results that were defined in the FollowedBy expression
 #, ret = self.expr._parse(instring, loc, doActions=doActions)
 #el ret[:]

 #eturn loc, ret


class PrecededBy(ParseElementEnhance):
 #""Lookbehind matching of the given parse expression.
 #`PrecededBy`` does not advance the parsing position within the
 #nput string, it only verifies that the specified parse expression
 #atches prior to the current position.  ``PrecededBy`` always
 #eturns a null token list, but if a results name is defined on the
 #iven expression, it is returned.

 #arameters:

 # ``expr`` - expression that must match prior to the current parse
 #ocation
 # ``retreat`` - (default= ``None``) - (int) maximum number of characters
 #o lookbehind prior to the current parse location

 #f the lookbehind expression is a string, :class:`Literal`,
 #class:`Keyword`, or a :class:`Word` or :class:`CharsNotIn`
 #ith a specified exact or maximum length, then the retreat
 #arameter is not required. Otherwise, retreat must be specified to
 #ive a maximum number of characters to look back from
 #he current parse position for a lookbehind match.

 #xample::

        # VB-style variable names with type prefixes
 #nt_var = PrecededBy("#") + pyparsing_common.identifier
 #tr_var = PrecededBy("$") + pyparsing_common.identifier

 #""

 #ef __init__(
 #elf, expr: Union[ParserElement, str], retreat: typing.Optional[int] = None
 #:
 #uper().__init__(expr)
 #elf.expr = self.expr().leave_whitespace()
 #elf.mayReturnEmpty = True
 #elf.mayIndexError = False
 #elf.exact = False
 #f isinstance(expr, str_type):
 #xpr = typing.cast(str, expr)
 #etreat = len(expr)
 #elf.exact = True
 #lif isinstance(expr, (Literal, Keyword)):
 #etreat = expr.matchLen
 #elf.exact = True
 #lif isinstance(expr, (Word, CharsNotIn)) and expr.maxLen != _MAX_INT:
 #etreat = expr.maxLen
 #elf.exact = True
 #lif isinstance(expr, PositionToken):
 #etreat = 0
 #elf.exact = True
 #elf.retreat = retreat
 #elf.errmsg = "not preceded by " + str(expr)
 #elf.skipWhitespace = False
 #elf.parseAction.append(lambda s, l, t: t.__delitem__(slice(None, None)))

 #ef parseImpl(self, instring, loc=0, doActions=True):
 #f self.exact:
 #f loc < self.retreat:
 #aise ParseException(instring, loc, self.errmsg)
 #tart = loc - self.retreat
 #, ret = self.expr._parse(instring, start)
 #lse:
            # retreat specified a maximum lookbehind window, iterate
 #est_expr = self.expr + StringEnd()
 #nstring_slice = instring[max(0, loc - self.retreat) : loc]
 #ast_expr = ParseException(instring, loc, self.errmsg)
 #or offset in range(1, min(loc, self.retreat + 1) + 1):
 #ry:
                    # print('trying', offset, instring_slice, repr(instring_slice[loc - offset:]))
 #, ret = test_expr._parse(
 #nstring_slice, len(instring_slice) - offset
 #
 #xcept ParseBaseException as pbe:
 #ast_expr = pbe
 #lse:
 #reak
 #lse:
 #aise last_expr
 #eturn loc, ret


class Located(ParseElementEnhance):
 #""
 #ecorates a returned token with its starting and ending
 #ocations in the input string.

 #his helper adds the following results names:

 # ``locn_start`` - location where matched expression begins
 # ``locn_end`` - location where matched expression ends
 # ``value`` - the actual parsed results

 #e careful if the input text contains ``<TAB>`` characters, you
 #ay want to call :class:`ParserElement.parse_with_tabs`

 #xample::

 #d = Word(alphas)
 #or match in Located(wd).search_string("ljsdf123lksdjjf123lkkjj1222"):
 #rint(match)

 #rints::

 #0, ['ljsdf'], 5]
 #8, ['lksdjjf'], 15]
 #18, ['lkkjj'], 23]

 #""

 #ef parseImpl(self, instring, loc, doActions=True):
 #tart = loc
 #oc, tokens = self.expr._parse(instring, start, doActions, callPreParse=False)
 #et_tokens = ParseResults([start, tokens, loc])
 #et_tokens["locn_start"] = start
 #et_tokens["value"] = tokens
 #et_tokens["locn_end"] = loc
 #f self.resultsName:
            # must return as a list, so that the name will be attached to the complete group
 #eturn loc, [ret_tokens]
 #lse:
 #eturn loc, ret_tokens


class NotAny(ParseElementEnhance):
 #""
 #ookahead to disallow matching with the given parse expression.
 #`NotAny`` does *not* advance the parsing position within the
 #nput string, it only verifies that the specified parse expression
 #oes *not* match at the current position.  Also, ``NotAny`` does
 #not* skip over leading whitespace. ``NotAny`` always returns
 # null token list.  May be constructed using the ``'~'`` operator.

 #xample::

 #ND, OR, NOT = map(CaselessKeyword, "AND OR NOT".split())

        # take care not to mistake keywords for identifiers
 #dent = ~(AND | OR | NOT) + Word(alphas)
 #oolean_term = Opt(NOT) + ident

        # very crude boolean expression - to support parenthesis groups and
        # operation hierarchy, use infix_notation
 #oolean_expr = boolean_term + ((AND | OR) + boolean_term)[...]

        # integers that are followed by "." are actually floats
 #nteger = Word(nums) + ~Char(".")
 #""

 #ef __init__(self, expr: Union[ParserElement, str]):
 #uper().__init__(expr)
        # do NOT use self.leave_whitespace(), don't want to propagate to exprs
        # self.leave_whitespace()
 #elf.skipWhitespace = False

 #elf.mayReturnEmpty = True
 #elf.errmsg = "Found unwanted token, " + str(self.expr)

 #ef parseImpl(self, instring, loc, doActions=True):
 #f self.expr.can_parse_next(instring, loc, do_actions=doActions):
 #aise ParseException(instring, loc, self.errmsg, self)
 #eturn loc, []

 #ef _generateDefaultName(self) -> str:
 #eturn "~{" + str(self.expr) + "}"


class _MultipleMatch(ParseElementEnhance):
 #ef __init__(
 #elf,
 #xpr: Union[str, ParserElement],
 #top_on: typing.Optional[Union[ParserElement, str]] = None,
 #,
 #topOn: typing.Optional[Union[ParserElement, str]] = None,
 #:
 #uper().__init__(expr)
 #topOn = stopOn or stop_on
 #elf.saveAsList = True
 #nder = stopOn
 #f isinstance(ender, str_type):
 #nder = self._literalStringClass(ender)
 #elf.stopOn(ender)

 #ef stopOn(self, ender) -> ParserElement:
 #f isinstance(ender, str_type):
 #nder = self._literalStringClass(ender)
 #elf.not_ender = ~ender if ender is not None else None
 #eturn self

 #ef parseImpl(self, instring, loc, doActions=True):
 #elf_expr_parse = self.expr._parse
 #elf_skip_ignorables = self._skipIgnorables
 #heck_ender = self.not_ender is not None
 #f check_ender:
 #ry_not_ender = self.not_ender.try_parse

        # must be at least one (but first see if we are the stopOn sentinel;
        # if so, fail)
 #f check_ender:
 #ry_not_ender(instring, loc)
 #oc, tokens = self_expr_parse(instring, loc, doActions)
 #ry:
 #asIgnoreExprs = not not self.ignoreExprs
 #hile 1:
 #f check_ender:
 #ry_not_ender(instring, loc)
 #f hasIgnoreExprs:
 #reloc = self_skip_ignorables(instring, loc)
 #lse:
 #reloc = loc
 #oc, tmptokens = self_expr_parse(instring, preloc, doActions)
 #okens += tmptokens
 #xcept (ParseException, IndexError):
 #ass

 #eturn loc, tokens

 #ef _setResultsName(self, name, listAllMatches=False):
 #f (
 #_diag__.warn_ungrouped_named_tokens_in_collection
 #nd Diagnostics.warn_ungrouped_named_tokens_in_collection
 #ot in self.suppress_warnings_
 #:
 #or e in [self.expr] + self.expr.recurse():
 #f (
 #sinstance(e, ParserElement)
 #nd e.resultsName
 #nd Diagnostics.warn_ungrouped_named_tokens_in_collection
 #ot in e.suppress_warnings_
 #:
 #arnings.warn(
 #{}: setting results name {!r} on {} expression "
 #collides with {!r} on contained expression".format(
 #warn_ungrouped_named_tokens_in_collection",
 #ame,
 #ype(self).__name__,
 #.resultsName,
 #,
 #tacklevel=3,
 #

 #eturn super()._setResultsName(name, listAllMatches)


class OneOrMore(_MultipleMatch):
 #""
 #epetition of one or more of the given expression.

 #arameters:

 # ``expr`` - expression that must match one or more times
 # ``stop_on`` - (default= ``None``) - expression for a terminating sentinel
 #only required if the sentinel would ordinarily match the repetition
 #xpression)

 #xample::

 #ata_word = Word(alphas)
 #abel = data_word + FollowedBy(':')
 #ttr_expr = Group(label + Suppress(':') + OneOrMore(data_word).set_parse_action(' '.join))

 #ext = "shape: SQUARE posn: upper left color: BLACK"
 #ttr_expr[1, ...].parse_string(text).pprint()  # Fail! read 'color' as data instead of next label -> [['shape', 'SQUARE color']]

        # use stop_on attribute for OneOrMore to avoid reading label string as part of the data
 #ttr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))
 #neOrMore(attr_expr).parse_string(text).pprint() # Better -> [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'BLACK']]

        # could also be written as
 #attr_expr * (1,)).parse_string(text).pprint()
 #""

 #ef _generateDefaultName(self) -> str:
 #eturn "{" + str(self.expr) + "}..."


class ZeroOrMore(_MultipleMatch):
 #""
 #ptional repetition of zero or more of the given expression.

 #arameters:

 # ``expr`` - expression that must match zero or more times
 # ``stop_on`` - expression for a terminating sentinel
 #only required if the sentinel would ordinarily match the repetition
 #xpression) - (default= ``None``)

 #xample: similar to :class:`OneOrMore`
 #""

 #ef __init__(
 #elf,
 #xpr: Union[str, ParserElement],
 #top_on: typing.Optional[Union[ParserElement, str]] = None,
 #,
 #topOn: typing.Optional[Union[ParserElement, str]] = None,
 #:
 #uper().__init__(expr, stopOn=stopOn or stop_on)
 #elf.mayReturnEmpty = True

 #ef parseImpl(self, instring, loc, doActions=True):
 #ry:
 #eturn super().parseImpl(instring, loc, doActions)
 #xcept (ParseException, IndexError):
 #eturn loc, ParseResults([], name=self.resultsName)

 #ef _generateDefaultName(self) -> str:
 #eturn "[" + str(self.expr) + "]..."


class DelimitedList(ParseElementEnhance):
 #ef __init__(
 #elf,
 #xpr: Union[str, ParserElement],
 #elim: Union[str, ParserElement] = ",",
 #ombine: bool = False,
 #in: typing.Optional[int] = None,
 #ax: typing.Optional[int] = None,
 #,
 #llow_trailing_delim: bool = False,
 #:
 #""Helper to define a delimited list of expressions - the delimiter
 #efaults to ','. By default, the list elements and delimiters can
 #ave intervening whitespace, and comments, but this can be
 #verridden by passing ``combine=True`` in the constructor. If
 #`combine`` is set to ``True``, the matching tokens are
 #eturned as a single token string, with the delimiters included;
 #therwise, the matching tokens are returned as a list of tokens,
 #ith the delimiters suppressed.

 #f ``allow_trailing_delim`` is set to True, then the list may end with
 # delimiter.

 #xample::

 #elimitedList(Word(alphas)).parse_string("aa,bb,cc") # -> ['aa', 'bb', 'cc']
 #elimitedList(Word(hexnums), delim=':', combine=True).parse_string("AA:BB:CC:DD:EE") # -> ['AA:BB:CC:DD:EE']
 #""
 #f isinstance(expr, str_type):
 #xpr = ParserElement._literalStringClass(expr)
 #xpr = typing.cast(ParserElement, expr)

 #f min is not None:
 #f min < 1:
 #aise ValueError("min must be greater than 0")
 #f max is not None:
 #f min is not None and max < min:
 #aise ValueError("max must be greater than, or equal to min")

 #elf.content = expr
 #elf.raw_delim = str(delim)
 #elf.delim = delim
 #elf.combine = combine
 #f not combine:
 #elf.delim = Suppress(delim)
 #elf.min = min or 1
 #elf.max = max
 #elf.allow_trailing_delim = allow_trailing_delim

 #elim_list_expr = self.content + (self.delim + self.content) * (
 #elf.min - 1,
 #one if self.max is None else self.max - 1,
 #
 #f self.allow_trailing_delim:
 #elim_list_expr += Opt(self.delim)

 #f self.combine:
 #elim_list_expr = Combine(delim_list_expr)

 #uper().__init__(delim_list_expr, savelist=True)

 #ef _generateDefaultName(self) -> str:
 #eturn "{0} [{1} {0}]...".format(self.content.streamline(), self.raw_delim)


class _NullToken:
 #ef __bool__(self):
 #eturn False

 #ef __str__(self):
 #eturn ""


class Opt(ParseElementEnhance):
 #""
 #ptional matching of the given expression.

 #arameters:

 # ``expr`` - expression that must match zero or more times
 # ``default`` (optional) - value to be returned if the optional expression is not found.

 #xample::

        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier
 #ip = Combine(Word(nums, exact=5) + Opt('-' + Word(nums, exact=4)))
 #ip.run_tests('''
            # traditional ZIP code
 #2345

            # ZIP+4 form
 #2101-0001

            # invalid ZIP
 #8765-
 #'')

 #rints::

        # traditional ZIP code
 #2345
 #'12345']

        # ZIP+4 form
 #2101-0001
 #'12101-0001']

        # invalid ZIP
 #8765-
 #
 #AIL: Expected end of text (at char 5), (line:1, col:6)
 #""

 #_optionalNotMatched = _NullToken()

 #ef __init__(
 #elf, expr: Union[ParserElement, str], default: Any = __optionalNotMatched
 #:
 #uper().__init__(expr, savelist=False)
 #elf.saveAsList = self.expr.saveAsList
 #elf.defaultValue = default
 #elf.mayReturnEmpty = True

 #ef parseImpl(self, instring, loc, doActions=True):
 #elf_expr = self.expr
 #ry:
 #oc, tokens = self_expr._parse(instring, loc, doActions, callPreParse=False)
 #xcept (ParseException, IndexError):
 #efault_value = self.defaultValue
 #f default_value is not self.__optionalNotMatched:
 #f self_expr.resultsName:
 #okens = ParseResults([default_value])
 #okens[self_expr.resultsName] = default_value
 #lse:
 #okens = [default_value]
 #lse:
 #okens = []
 #eturn loc, tokens

 #ef _generateDefaultName(self) -> str:
 #nner = str(self.expr)
        # strip off redundant inner {}'s
 #hile len(inner) > 1 and inner[0 :: len(inner) - 1] == "{}":
 #nner = inner[1:-1]
 #eturn "[" + inner + "]"


Optional = Opt


class SkipTo(ParseElementEnhance):
 #""
 #oken for skipping over all undefined text until the matched
 #xpression is found.

 #arameters:

 # ``expr`` - target expression marking the end of the data to be skipped
 # ``include`` - if ``True``, the target expression is also parsed
 #the skipped text and target expression are returned as a 2-element
 #ist) (default= ``False``).
 # ``ignore`` - (default= ``None``) used to define grammars (typically quoted strings and
 #omments) that might contain false matches to the target expression
 # ``fail_on`` - (default= ``None``) define expressions that are not allowed to be
 #ncluded in the skipped test; if found before the target expression is found,
 #he :class:`SkipTo` is not a match

 #xample::

 #eport = '''
 #utstanding Issues Report - 1 Jan 2000

               # | Severity | Description                               |  Days Open
 #----+----------+-------------------------------------------+-----------
 #01 | Critical | Intermittent system crash                 |          6
 #4 | Cosmetic | Spelling error on Login ('log|n')         |         14
 #9 | Minor    | System slow when running too many reports |         47
 #''
 #nteger = Word(nums)
 #EP = Suppress('|')
        # use SkipTo to simply match everything up until the next SEP
        # - ignore quoted strings, so that a '|' character inside a quoted string does not match
        # - parse action will call token.strip() for each matched token, i.e., the description body
 #tring_data = SkipTo(SEP, ignore=quoted_string)
 #tring_data.set_parse_action(token_map(str.strip))
 #icket_expr = (integer("issue_num") + SEP
 # string_data("sev") + SEP
 # string_data("desc") + SEP
 # integer("days_open"))

 #or tkt in ticket_expr.search_string(report):
 #rint tkt.dump()

 #rints::

 #'101', 'Critical', 'Intermittent system crash', '6']
 # days_open: '6'
 # desc: 'Intermittent system crash'
 # issue_num: '101'
 # sev: 'Critical'
 #'94', 'Cosmetic', "Spelling error on Login ('log|n')", '14']
 # days_open: '14'
 # desc: "Spelling error on Login ('log|n')"
 # issue_num: '94'
 # sev: 'Cosmetic'
 #'79', 'Minor', 'System slow when running too many reports', '47']
 # days_open: '47'
 # desc: 'System slow when running too many reports'
 # issue_num: '79'
 # sev: 'Minor'
 #""

 #ef __init__(
 #elf,
 #ther: Union[ParserElement, str],
 #nclude: bool = False,
 #gnore: typing.Optional[Union[ParserElement, str]] = None,
 #ail_on: typing.Optional[Union[ParserElement, str]] = None,
 #,
 #ailOn: typing.Optional[Union[ParserElement, str]] = None,
 #:
 #uper().__init__(other)
 #ailOn = failOn or fail_on
 #f ignore is not None:
 #elf.ignore(ignore)
 #elf.mayReturnEmpty = True
 #elf.mayIndexError = False
 #elf.includeMatch = include
 #elf.saveAsList = False
 #f isinstance(failOn, str_type):
 #elf.failOn = self._literalStringClass(failOn)
 #lse:
 #elf.failOn = failOn
 #elf.errmsg = "No match found for " + str(self.expr)

 #ef parseImpl(self, instring, loc, doActions=True):
 #tartloc = loc
 #nstrlen = len(instring)
 #elf_expr_parse = self.expr._parse
 #elf_failOn_canParseNext = (
 #elf.failOn.canParseNext if self.failOn is not None else None
 #
 #elf_preParse = self.preParse if self.callPreparse else None

 #mploc = loc
 #hile tmploc <= instrlen:
 #f self_failOn_canParseNext is not None:
                # break if failOn expression matches
 #f self_failOn_canParseNext(instring, tmploc):
 #reak

 #f self_preParse is not None:
                # skip grammar-ignored expressions
 #mploc = self_preParse(instring, tmploc)

 #ry:
 #elf_expr_parse(instring, tmploc, doActions=False, callPreParse=False)
 #xcept (ParseException, IndexError):
                # no match, advance loc in string
 #mploc += 1
 #lse:
                # matched skipto expr, done
 #reak

 #lse:
            # ran off the end of the input string without matching skipto expr, fail
 #aise ParseException(instring, loc, self.errmsg, self)

        # build up return values
 #oc = tmploc
 #kiptext = instring[startloc:loc]
 #kipresult = ParseResults(skiptext)

 #f self.includeMatch:
 #oc, mat = self_expr_parse(instring, loc, doActions, callPreParse=False)
 #kipresult += mat

 #eturn loc, skipresult


class Forward(ParseElementEnhance):
 #""
 #orward declaration of an expression to be defined later -
 #sed for recursive grammars, such as algebraic infix notation.
 #hen the expression is known, it is assigned to the ``Forward``
 #ariable using the ``'<<'`` operator.

 #ote: take care when assigning to ``Forward`` not to overlook
 #recedence of operators.

 #pecifically, ``'|'`` has a lower precedence than ``'<<'``, so that::

 #wd_expr << a | b | c

 #ill actually be evaluated as::

 #fwd_expr << a) | b | c

 #hereby leaving b and c out as parseable alternatives.  It is recommended that you
 #xplicitly group the values inserted into the ``Forward``::

 #wd_expr << (a | b | c)

 #onverting to use the ``'<<='`` operator instead will avoid this problem.

 #ee :class:`ParseResults.pprint` for an example of a recursive
 #arser created using ``Forward``.
 #""

 #ef __init__(self, other: typing.Optional[Union[ParserElement, str]] = None):
 #elf.caller_frame = traceback.extract_stack(limit=2)[0]
 #uper().__init__(other, savelist=False)  # type: ignore[arg-type]
 #elf.lshift_line = None

 #ef __lshift__(self, other) -> "Forward":
 #f hasattr(self, "caller_frame"):
 #el self.caller_frame
 #f isinstance(other, str_type):
 #ther = self._literalStringClass(other)

 #f not isinstance(other, ParserElement):
 #eturn NotImplemented

 #elf.expr = other
 #elf.streamlined = other.streamlined
 #elf.mayIndexError = self.expr.mayIndexError
 #elf.mayReturnEmpty = self.expr.mayReturnEmpty
 #elf.set_whitespace_chars(
 #elf.expr.whiteChars, copy_defaults=self.expr.copyDefaultWhiteChars
 #
 #elf.skipWhitespace = self.expr.skipWhitespace
 #elf.saveAsList = self.expr.saveAsList
 #elf.ignoreExprs.extend(self.expr.ignoreExprs)
 #elf.lshift_line = traceback.extract_stack(limit=2)[-2]  # type: ignore[assignment]
 #eturn self

 #ef __ilshift__(self, other) -> "Forward":
 #f not isinstance(other, ParserElement):
 #eturn NotImplemented

 #eturn self << other

 #ef __or__(self, other) -> "ParserElement":
 #aller_line = traceback.extract_stack(limit=2)[-2]
 #f (
 #_diag__.warn_on_match_first_with_lshift_operator
 #nd caller_line == self.lshift_line
 #nd Diagnostics.warn_on_match_first_with_lshift_operator
 #ot in self.suppress_warnings_
 #:
 #arnings.warn(
 #using '<<' operator with '|' is probably an error, use '<<='",
 #tacklevel=2,
 #
 #et = super().__or__(other)
 #eturn ret

 #ef __del__(self):
        # see if we are getting dropped because of '=' reassignment of var instead of '<<=' or '<<'
 #f (
 #elf.expr is None
 #nd __diag__.warn_on_assignment_to_Forward
 #nd Diagnostics.warn_on_assignment_to_Forward not in self.suppress_warnings_
 #:
 #arnings.warn_explicit(
 #Forward defined here but no expression attached later using '<<=' or '<<'",
 #serWarning,
 #ilename=self.caller_frame.filename,
 #ineno=self.caller_frame.lineno,
 #

 #ef parseImpl(self, instring, loc, doActions=True):
 #f (
 #elf.expr is None
 #nd __diag__.warn_on_parse_using_empty_Forward
 #nd Diagnostics.warn_on_parse_using_empty_Forward
 #ot in self.suppress_warnings_
 #:
            # walk stack until parse_string, scan_string, search_string, or transform_string is found
 #arse_fns = (
 #parse_string",
 #scan_string",
 #search_string",
 #transform_string",
 #
 #b = traceback.extract_stack(limit=200)
 #or i, frm in enumerate(reversed(tb), start=1):
 #f frm.name in parse_fns:
 #tacklevel = i + 1
 #reak
 #lse:
 #tacklevel = 2
 #arnings.warn(
 #Forward expression was never assigned a value, will not parse any input",
 #tacklevel=stacklevel,
 #
 #f not ParserElement._left_recursion_enabled:
 #eturn super().parseImpl(instring, loc, doActions)
        # ## Bounded Recursion algorithm ##
        # Recursion only needs to be processed at ``Forward`` elements, since they are
        # the only ones that can actually refer to themselves. The general idea is
        # to handle recursion stepwise: We start at no recursion, then recurse once,
        # recurse twice, ..., until more recursion offers no benefit (we hit the bound).
        #
        # The "trick" here is that each ``Forward`` gets evaluated in two contexts
        # - to *match* a specific recursion level, and
        # - to *search* the bounded recursion level
        # and the two run concurrently. The *search* must *match* each recursion level
        # to find the best possible match. This is handled by a memo table, which
        # provides the previous match to the next level match attempt.
        #
        # See also "Left Recursion in Parsing Expression Grammars", Medeiros et al.
        #
        # There is a complication since we not only *parse* but also *transform* via
        # actions: We do not want to run the actions too often while expanding. Thus,
        # we expand using `doActions=False` and only run `doActions=True` if the next
        # recursion level is acceptable.
 #ith ParserElement.recursion_lock:
 #emo = ParserElement.recursion_memos
 #ry:
                # we are parsing at a specific recursion expansion - use it as-is
 #rev_loc, prev_result = memo[loc, self, doActions]
 #f isinstance(prev_result, Exception):
 #aise prev_result
 #eturn prev_loc, prev_result.copy()
 #xcept KeyError:
 #ct_key = (loc, self, True)
 #eek_key = (loc, self, False)
                # we are searching for the best recursion expansion - keep on improving
                # both `doActions` cases must be tracked separately here!
 #rev_loc, prev_peek = memo[peek_key] = (
 #oc - 1,
 #arseException(
 #nstring, loc, "Forward recursion without base case", self
 #,
 #
 #f doActions:
 #emo[act_key] = memo[peek_key]
 #hile True:
 #ry:
 #ew_loc, new_peek = super().parseImpl(instring, loc, False)
 #xcept ParseException:
                        # we failed before getting any match  do not hide the error
 #f isinstance(prev_peek, Exception):
 #aise
 #ew_loc, new_peek = prev_loc, prev_peek
                    # the match did not get better: we are done
 #f new_loc <= prev_loc:
 #f doActions:
                            # replace the match for doActions=False as well,
                            # in case the action did backtrack
 #rev_loc, prev_result = memo[peek_key] = memo[act_key]
 #el memo[peek_key], memo[act_key]
 #eturn prev_loc, prev_result.copy()
 #el memo[peek_key]
 #eturn prev_loc, prev_peek.copy()
                    # the match did get better: see if we can improve further
 #lse:
 #f doActions:
 #ry:
 #emo[act_key] = super().parseImpl(instring, loc, True)
 #xcept ParseException as e:
 #emo[peek_key] = memo[act_key] = (new_loc, e)
 #aise
 #rev_loc, prev_peek = memo[peek_key] = new_loc, new_peek

 #ef leave_whitespace(self, recursive: bool = True) -> ParserElement:
 #elf.skipWhitespace = False
 #eturn self

 #ef ignore_whitespace(self, recursive: bool = True) -> ParserElement:
 #elf.skipWhitespace = True
 #eturn self

 #ef streamline(self) -> ParserElement:
 #f not self.streamlined:
 #elf.streamlined = True
 #f self.expr is not None:
 #elf.expr.streamline()
 #eturn self

 #ef validate(self, validateTrace=None) -> None:
 #arnings.warn(
 #ParserElement.validate() is deprecated, and should not be used to check for left recursion",
 #eprecationWarning,
 #tacklevel=2,
 #
 #f validateTrace is None:
 #alidateTrace = []

 #f self not in validateTrace:
 #mp = validateTrace[:] + [self]
 #f self.expr is not None:
 #elf.expr.validate(tmp)
 #elf._checkRecursion([])

 #ef _generateDefaultName(self) -> str:
        # Avoid infinite recursion by setting a temporary _defaultName
 #elf._defaultName = ": ..."

        # Use the string representation of main expression.
 #etString = "..."
 #ry:
 #f self.expr is not None:
 #etString = str(self.expr)[:1000]
 #lse:
 #etString = "None"
 #inally:
 #eturn self.__class__.__name__ + ": " + retString

 #ef copy(self) -> ParserElement:
 #f self.expr is not None:
 #eturn super().copy()
 #lse:
 #et = Forward()
 #et <<= self
 #eturn ret

 #ef _setResultsName(self, name, list_all_matches=False):
 #f (
 #_diag__.warn_name_set_on_empty_Forward
 #nd Diagnostics.warn_name_set_on_empty_Forward
 #ot in self.suppress_warnings_
 #:
 #f self.expr is None:
 #arnings.warn(
 #{}: setting results name {!r} on {} expression "
 #that has no contained expression".format(
 #warn_name_set_on_empty_Forward", name, type(self).__name__
 #,
 #tacklevel=3,
 #

 #eturn super()._setResultsName(name, list_all_matches)

    # Compatibility synonyms
    # fmt: off
 #replaced_by_pep8(leave_whitespace)
 #ef leaveWhitespace(self): ...

 #replaced_by_pep8(ignore_whitespace)
 #ef ignoreWhitespace(self): ...
    # fmt: on


class TokenConverter(ParseElementEnhance):
 #""
 #bstract subclass of :class:`ParseExpression`, for converting parsed results.
 #""

 #ef __init__(self, expr: Union[ParserElement, str], savelist=False):
 #uper().__init__(expr)  # , savelist)
 #elf.saveAsList = False


class Combine(TokenConverter):
 #""Converter to concatenate all matching tokens to a single string.
 #y default, the matching patterns must also be contiguous in the
 #nput string; this can be disabled by specifying
 #`'adjacent=False'`` in the constructor.

 #xample::

 #eal = Word(nums) + '.' + Word(nums)
 #rint(real.parse_string('3.1416')) # -> ['3', '.', '1416']
        # will also erroneously match the following
 #rint(real.parse_string('3. 1416')) # -> ['3', '.', '1416']

 #eal = Combine(Word(nums) + '.' + Word(nums))
 #rint(real.parse_string('3.1416')) # -> ['3.1416']
        # no match when there are internal spaces
 #rint(real.parse_string('3. 1416')) # -> Exception: Expected W:(0123...)
 #""

 #ef __init__(
 #elf,
 #xpr: ParserElement,
 #oin_string: str = "",
 #djacent: bool = True,
 #,
 #oinString: typing.Optional[str] = None,
 #:
 #uper().__init__(expr)
 #oinString = joinString if joinString is not None else join_string
        # suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself
 #f adjacent:
 #elf.leave_whitespace()
 #elf.adjacent = adjacent
 #elf.skipWhitespace = True
 #elf.joinString = joinString
 #elf.callPreparse = True

 #ef ignore(self, other) -> ParserElement:
 #f self.adjacent:
 #arserElement.ignore(self, other)
 #lse:
 #uper().ignore(other)
 #eturn self

 #ef postParse(self, instring, loc, tokenlist):
 #etToks = tokenlist.copy()
 #el retToks[:]
 #etToks += ParseResults(
 #"".join(tokenlist._asStringList(self.joinString))], modal=self.modalResults
 #

 #f self.resultsName and retToks.haskeys():
 #eturn [retToks]
 #lse:
 #eturn retToks


class Group(TokenConverter):
 #""Converter to return the matched tokens as a list - useful for
 #eturning tokens of :class:`ZeroOrMore` and :class:`OneOrMore` expressions.

 #he optional ``aslist`` argument when set to True will return the
 #arsed tokens as a Python list instead of a pyparsing ParseResults.

 #xample::

 #dent = Word(alphas)
 #um = Word(nums)
 #erm = ident | num
 #unc = ident + Opt(DelimitedList(term))
 #rint(func.parse_string("fn a, b, 100"))
        # -> ['fn', 'a', 'b', '100']

 #unc = ident + Group(Opt(DelimitedList(term)))
 #rint(func.parse_string("fn a, b, 100"))
        # -> ['fn', ['a', 'b', '100']]
 #""

 #ef __init__(self, expr: ParserElement, aslist: bool = False):
 #uper().__init__(expr)
 #elf.saveAsList = True
 #elf._asPythonList = aslist

 #ef postParse(self, instring, loc, tokenlist):
 #f self._asPythonList:
 #eturn ParseResults.List(
 #okenlist.asList()
 #f isinstance(tokenlist, ParseResults)
 #lse list(tokenlist)
 #
 #lse:
 #eturn [tokenlist]


class Dict(TokenConverter):
 #""Converter to return a repetitive expression as a list, but also
 #s a dictionary. Each element can also be referenced using the first
 #oken in the expression as its key. Useful for tabular report
 #craping when the first column can be used as a item key.

 #he optional ``asdict`` argument when set to True will return the
 #arsed tokens as a Python dict instead of a pyparsing ParseResults.

 #xample::

 #ata_word = Word(alphas)
 #abel = data_word + FollowedBy(':')

 #ext = "shape: SQUARE posn: upper left color: light blue texture: burlap"
 #ttr_expr = (label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))

        # print attributes as plain groups
 #rint(attr_expr[1, ...].parse_string(text).dump())

        # instead of OneOrMore(expr), parse using Dict(Group(expr)[1, ...]) - Dict will auto-assign names
 #esult = Dict(Group(attr_expr)[1, ...]).parse_string(text)
 #rint(result.dump())

        # access named fields as dict entries, or output as dict
 #rint(result['shape'])
 #rint(result.as_dict())

 #rints::

 #'shape', 'SQUARE', 'posn', 'upper left', 'color', 'light blue', 'texture', 'burlap']
 #['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
 # color: 'light blue'
 # posn: 'upper left'
 # shape: 'SQUARE'
 # texture: 'burlap'
 #QUARE
 #'color': 'light blue', 'posn': 'upper left', 'texture': 'burlap', 'shape': 'SQUARE'}

 #ee more examples at :class:`ParseResults` of accessing fields by results name.
 #""

 #ef __init__(self, expr: ParserElement, asdict: bool = False):
 #uper().__init__(expr)
 #elf.saveAsList = True
 #elf._asPythonDict = asdict

 #ef postParse(self, instring, loc, tokenlist):
 #or i, tok in enumerate(tokenlist):
 #f len(tok) == 0:
 #ontinue

 #key = tok[0]
 #f isinstance(ikey, int):
 #key = str(ikey).strip()

 #f len(tok) == 1:
 #okenlist[ikey] = _ParseResultsWithOffset("", i)

 #lif len(tok) == 2 and not isinstance(tok[1], ParseResults):
 #okenlist[ikey] = _ParseResultsWithOffset(tok[1], i)

 #lse:
 #ry:
 #ictvalue = tok.copy()  # ParseResults(i)
 #xcept Exception:
 #xc = TypeError(
 #could not extract dict values from parsed results"
 # - Dict expression must contain Grouped expressions"
 #
 #aise exc from None

 #el dictvalue[0]

 #f len(dictvalue) != 1 or (
 #sinstance(dictvalue, ParseResults) and dictvalue.haskeys()
 #:
 #okenlist[ikey] = _ParseResultsWithOffset(dictvalue, i)
 #lse:
 #okenlist[ikey] = _ParseResultsWithOffset(dictvalue[0], i)

 #f self._asPythonDict:
 #eturn [tokenlist.as_dict()] if self.resultsName else tokenlist.as_dict()
 #lse:
 #eturn [tokenlist] if self.resultsName else tokenlist


class Suppress(TokenConverter):
 #""Converter for ignoring the results of a parsed expression.

 #xample::

 #ource = "a, b, c,d"
 #d = Word(alphas)
 #d_list1 = wd + (',' + wd)[...]
 #rint(wd_list1.parse_string(source))

        # often, delimiters that are useful during parsing are just in the
        # way afterward - use Suppress to keep them out of the parsed output
 #d_list2 = wd + (Suppress(',') + wd)[...]
 #rint(wd_list2.parse_string(source))

        # Skipped text (using '...') can be suppressed as well
 #ource = "lead in START relevant text END trailing text"
 #tart_marker = Keyword("START")
 #nd_marker = Keyword("END")
 #ind_body = Suppress(...) + start_marker + ... + end_marker
 #rint(find_body.parse_string(source)

 #rints::

 #'a', ',', 'b', ',', 'c', ',', 'd']
 #'a', 'b', 'c', 'd']
 #'START', 'relevant text ', 'END']

 #See also :class:`DelimitedList`.)
 #""

 #ef __init__(self, expr: Union[ParserElement, str], savelist: bool = False):
 #f expr is ...:
 #xpr = _PendingSkip(NoMatch())
 #uper().__init__(expr)

 #ef __add__(self, other) -> "ParserElement":
 #f isinstance(self.expr, _PendingSkip):
 #eturn Suppress(SkipTo(other)) + other
 #lse:
 #eturn super().__add__(other)

 #ef __sub__(self, other) -> "ParserElement":
 #f isinstance(self.expr, _PendingSkip):
 #eturn Suppress(SkipTo(other)) - other
 #lse:
 #eturn super().__sub__(other)

 #ef postParse(self, instring, loc, tokenlist):
 #eturn []

 #ef suppress(self) -> ParserElement:
 #eturn self


def trace_parse_action(f: ParseAction) -> ParseAction:
 #""Decorator for debugging parse actions.

 #hen the parse action is called, this decorator will print
 #`">> entering method-name(line:<current_source_line>, <parse_location>, <matched_tokens>)"``.
 #hen the parse action completes, the decorator will print
 #`"<<"`` followed by the returned value, or any exception that the parse action raised.

 #xample::

 #d = Word(alphas)

 #trace_parse_action
 #ef remove_duplicate_chars(tokens):
 #eturn ''.join(sorted(set(''.join(tokens))))

 #ds = wd[1, ...].set_parse_action(remove_duplicate_chars)
 #rint(wds.parse_string("slkdjs sld sldd sdlf sdljf"))

 #rints::

 #>entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {}))
 #<leaving remove_duplicate_chars (ret: 'dfjkls')
 #'dfjkls']
 #""
 # = _trim_arity(f)

 #ef z(*paArgs):
 #hisFunc = f.__name__
 #, l, t = paArgs[-3:]
 #f len(paArgs) > 3:
 #hisFunc = paArgs[0].__class__.__name__ + "." + thisFunc
 #ys.stderr.write(f">>entering {thisFunc}(line: {line(l, s)!r}, {l}, {t!r})\n")
 #ry:
 #et = f(*paArgs)
 #xcept Exception as exc:
 #ys.stderr.write(f"<<leaving {thisFunc} (exception: {exc})\n")
 #aise
 #ys.stderr.write(f"<<leaving {thisFunc} (ret: {ret!r})\n")
 #eturn ret

 #.__name__ = f.__name__
 #eturn z


# convenience constants for positional expressions
empty = Empty().set_name("empty")
line_start = LineStart().set_name("line_start")
line_end = LineEnd().set_name("line_end")
string_start = StringStart().set_name("string_start")
string_end = StringEnd().set_name("string_end")

_escapedPunc = Regex(r"\\[\\[\]\/\-\*\.\$\+\^\?()~ ]").set_parse_action(
 #ambda s, l, t: t[0][1]
)
_escapedHexChar = Regex(r"\\0?[xX][0-9a-fA-F]+").set_parse_action(
 #ambda s, l, t: chr(int(t[0].lstrip(r"\0x"), 16))
)
_escapedOctChar = Regex(r"\\0[0-7]+").set_parse_action(
 #ambda s, l, t: chr(int(t[0][1:], 8))
)
_singleChar = (
 #escapedPunc | _escapedHexChar | _escapedOctChar | CharsNotIn(r"\]", exact=1)
)
_charRange = Group(_singleChar + Suppress("-") + _singleChar)
_reBracketExpr = (
 #iteral("[")
 # Opt("^").set_results_name("negate")
 # Group(OneOrMore(_charRange | _singleChar)).set_results_name("body")
 # Literal("]")
)


def srange(s: str) -> str:
 #"""Helper to easily define string ranges for use in :class:`Word`
 #onstruction. Borrows syntax from regexp ``'[]'`` string range
 #efinitions::

 #range("[0-9]")   -> "0123456789"
 #range("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz"
 #range("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_"

 #he input string must be enclosed in []'s, and the returned string
 #s the expanded character set joined into a single string. The
 #alues enclosed in the []'s may be:

 # a single character
 # an escaped character with a leading backslash (such as ``\-``
 #r ``\]``)
 # an escaped hex character with a leading ``'\x'``
 #``\x21``, which is a ``'!'`` character) (``\0x##``
 #s also supported for backwards compatibility)
 # an escaped octal character with a leading ``'\0'``
 #``\041``, which is a ``'!'`` character)
 # a range of any of the above, separated by a dash (``'a-z'``,
 #tc.)
 # any combination of the above (``'aeiouy'``,
 #`'a-zA-Z0-9_$'``, etc.)
 #""
 #expanded = (
 #ambda p: p
 #f not isinstance(p, ParseResults)
 #lse "".join(chr(c) for c in range(ord(p[0]), ord(p[1]) + 1))
 #
 #ry:
 #eturn "".join(_expanded(part) for part in _reBracketExpr.parse_string(s).body)
 #xcept Exception as e:
 #eturn ""


def token_map(func, *args) -> ParseAction:
 #""Helper to define a parse action by mapping a function to all
 #lements of a :class:`ParseResults` list. If any additional args are passed,
 #hey are forwarded to the given function as additional arguments
 #fter the token, as in
 #`hex_integer = Word(hexnums).set_parse_action(token_map(int, 16))``,
 #hich will convert the parsed data to an integer using base 16.

 #xample (compare the last to example in :class:`ParserElement.transform_string`::

 #ex_ints = Word(hexnums)[1, ...].set_parse_action(token_map(int, 16))
 #ex_ints.run_tests('''
 #0 11 22 aa FF 0a 0d 1a
 #'')

 #pperword = Word(alphas).set_parse_action(token_map(str.upper))
 #pperword[1, ...].run_tests('''
 #y kingdom for a horse
 #'')

 #d = Word(alphas).set_parse_action(token_map(str.title))
 #d[1, ...].set_parse_action(' '.join).run_tests('''
 #ow is the winter of our discontent made glorious summer by this sun of york
 #'')

 #rints::

 #0 11 22 aa FF 0a 0d 1a
 #0, 17, 34, 170, 255, 10, 13, 26]

 #y kingdom for a horse
 #'MY', 'KINGDOM', 'FOR', 'A', 'HORSE']

 #ow is the winter of our discontent made glorious summer by this sun of york
 #'Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York']
 #""

 #ef pa(s, l, t):
 #eturn [func(tokn, *args) for tokn in t]

 #unc_name = getattr(func, "__name__", getattr(func, "__class__").__name__)
 #a.__name__ = func_name

 #eturn pa


def autoname_elements() -> None:
 #""
 #tility to simplify mass-naming of parser elements, for
 #enerating railroad diagram with named subdiagrams.
 #""
 #alling_frame = sys._getframe().f_back
 #f calling_frame is None:
 #eturn
 #alling_frame = typing.cast(types.FrameType, calling_frame)
 #or name, var in calling_frame.f_locals.items():
 #f isinstance(var, ParserElement) and not var.customName:
 #ar.set_name(name)


dbl_quoted_string = Combine(
 #egex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*') + '"'
).set_name("string enclosed in double quotes")

sgl_quoted_string = Combine(
 #egex(r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*") + "'"
).set_name("string enclosed in single quotes")

quoted_string = Combine(
 #Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*') + '"').set_name(
 #double quoted string"
 #
 # (Regex(r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*") + "'").set_name(
 #single quoted string"
 #
).set_name("quoted string using single or double quotes")

python_quoted_string = Combine(
 #Regex(r'"""(?:[^"\\]|""(?!")|"(?!"")|\\.)*', flags=re.MULTILINE) + '"""').set_name(
 #multiline double quoted string"
 #
 # (
 #egex(r"'''(?:[^'\\]|''(?!')|'(?!'')|\\.)*", flags=re.MULTILINE) + "'''"
 #.set_name("multiline single quoted string")
 # (Regex(r'"(?:[^"\n\r\\]|(?:\\")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*') + '"').set_name(
 #double quoted string"
 #
 # (Regex(r"'(?:[^'\n\r\\]|(?:\\')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*") + "'").set_name(
 #single quoted string"
 #
).set_name("Python quoted string")

unicode_string = Combine("u" + quoted_string.copy()).set_name("unicode string literal")


alphas8bit = srange(r"[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]")
punc8bit = srange(r"[\0xa1-\0xbf\0xd7\0xf7]")

# build list of built-in expressions, for future reference if a global default value
# gets updated
_builtin_exprs: List[ParserElement] = [
 # for v in vars().values() if isinstance(v, ParserElement)
]

# backward compatibility names
# fmt: off
sglQuotedString = sgl_quoted_string
dblQuotedString = dbl_quoted_string
quotedString = quoted_string
unicodeString = unicode_string
lineStart = line_start
lineEnd = line_end
stringStart = string_start
stringEnd = string_end

@replaced_by_pep8(null_debug_action)
def nullDebugAction(): ...

@replaced_by_pep8(trace_parse_action)
def traceParseAction(): ...

@replaced_by_pep8(condition_as_parse_action)
def conditionAsParseAction(): ...

@replaced_by_pep8(token_map)
def tokenMap(): ...
# fmt: on
