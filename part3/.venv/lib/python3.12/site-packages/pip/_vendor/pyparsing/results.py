# results.py
from collections.abc import (
 #utableMapping,
 #apping,
 #utableSequence,
 #terator,
 #equence,
 #ontainer,
)
import pprint
from typing import Tuple, Any, Dict, Set, List

str_type: Tuple[type, ...] = (str, bytes)
_generator_type = type((_ for _ in ()))


class _ParseResultsWithOffset:
 #up: Tuple["ParseResults", int]
 #_slots__ = ["tup"]

 #ef __init__(self, p1: "ParseResults", p2: int):
 #elf.tup: Tuple[ParseResults, int] = (p1, p2)

 #ef __getitem__(self, i):
 #eturn self.tup[i]

 #ef __getstate__(self):
 #eturn self.tup

 #ef __setstate__(self, *args):
 #elf.tup = args[0]


class ParseResults:
 #""Structured parse results, to provide multiple means of access to
 #he parsed data:

 # as a list (``len(results)``)
 # by list index (``results[0], results[1]``, etc.)
 # by attribute (``results.<results_name>`` - see :class:`ParserElement.set_results_name`)

 #xample::

 #nteger = Word(nums)
 #ate_str = (integer.set_results_name("year") + '/'
 # integer.set_results_name("month") + '/'
 # integer.set_results_name("day"))
        # equivalent form:
        # date_str = (integer("year") + '/'
        #             + integer("month") + '/'
        #             + integer("day"))

        # parse_string returns a ParseResults object
 #esult = date_str.parse_string("1999/12/31")

 #ef test(s, fn=repr):
 #rint(f"{s} -> {fn(eval(s))}")
 #est("list(result)")
 #est("result[0]")
 #est("result['month']")
 #est("result.day")
 #est("'month' in result")
 #est("'minutes' in result")
 #est("result.dump()", str)

 #rints::

 #ist(result) -> ['1999', '/', '12', '/', '31']
 #esult[0] -> '1999'
 #esult['month'] -> '12'
 #esult.day -> '31'
 #month' in result -> True
 #minutes' in result -> False
 #esult.dump() -> ['1999', '/', '12', '/', '31']
 # day: '31'
 # month: '12'
 # year: '1999'
 #""

 #null_values: Tuple[Any, ...] = (None, [], ())

 #name: str
 #parent: "ParseResults"
 #all_names: Set[str]
 #modal: bool
 #toklist: List[Any]
 #tokdict: Dict[str, Any]

 #_slots__ = (
 #_name",
 #_parent",
 #_all_names",
 #_modal",
 #_toklist",
 #_tokdict",
 #

 #lass List(list):
 #""
 #imple wrapper class to distinguish parsed list results that should be preserved
 #s actual Python lists, instead of being converted to :class:`ParseResults`::

 #BRACK, RBRACK = map(pp.Suppress, "[]")
 #lement = pp.Forward()
 #tem = ppc.integer
 #lement_list = LBRACK + pp.DelimitedList(element) + RBRACK

            # add parse actions to convert from ParseResults to actual Python collection types
 #ef as_python_list(t):
 #eturn pp.ParseResults.List(t.as_list())
 #lement_list.add_parse_action(as_python_list)

 #lement <<= item | element_list

 #lement.run_tests('''
 #00
 #2,3,4]
 #[2, 1],3,4]
 #(2, 1),3,4]
 #2,3,4)
 #'', post_parse=lambda s, r: (r[0], type(r[0])))

 #rints::

 #00
 #100, <class 'int'>)

 #2,3,4]
 #[2, 3, 4], <class 'list'>)

 #[2, 1],3,4]
 #[[2, 1], 3, 4], <class 'list'>)

 #Used internally by :class:`Group` when `aslist=True`.)
 #""

 #ef __new__(cls, contained=None):
 #f contained is None:
 #ontained = []

 #f not isinstance(contained, list):
 #aise TypeError(
 #"{cls.__name__} may only be constructed with a list, not {type(contained).__name__}"
 #

 #eturn list.__new__(cls)

 #ef __new__(cls, toklist=None, name=None, **kwargs):
 #f isinstance(toklist, ParseResults):
 #eturn toklist
 #elf = object.__new__(cls)
 #elf._name = None
 #elf._parent = None
 #elf._all_names = set()

 #f toklist is None:
 #elf._toklist = []
 #lif isinstance(toklist, (list, _generator_type)):
 #elf._toklist = (
 #toklist[:]]
 #f isinstance(toklist, ParseResults.List)
 #lse list(toklist)
 #
 #lse:
 #elf._toklist = [toklist]
 #elf._tokdict = dict()
 #eturn self

    # Performance tuning: we construct a *lot* of these, so keep this
    # constructor as small and fast as possible
 #ef __init__(
 #elf, toklist=None, name=None, asList=True, modal=True, isinstance=isinstance
 #:
 #elf._tokdict: Dict[str, _ParseResultsWithOffset]
 #elf._modal = modal
 #f name is not None and name != "":
 #f isinstance(name, int):
 #ame = str(name)
 #f not modal:
 #elf._all_names = {name}
 #elf._name = name
 #f toklist not in self._null_values:
 #f isinstance(toklist, (str_type, type)):
 #oklist = [toklist]
 #f asList:
 #f isinstance(toklist, ParseResults):
 #elf[name] = _ParseResultsWithOffset(
 #arseResults(toklist._toklist), 0
 #
 #lse:
 #elf[name] = _ParseResultsWithOffset(
 #arseResults(toklist[0]), 0
 #
 #elf[name]._name = name
 #lse:
 #ry:
 #elf[name] = toklist[0]
 #xcept (KeyError, TypeError, IndexError):
 #f toklist is not self:
 #elf[name] = toklist
 #lse:
 #elf._name = name

 #ef __getitem__(self, i):
 #f isinstance(i, (int, slice)):
 #eturn self._toklist[i]
 #lse:
 #f i not in self._all_names:
 #eturn self._tokdict[i][-1][0]
 #lse:
 #eturn ParseResults([v[0] for v in self._tokdict[i]])

 #ef __setitem__(self, k, v, isinstance=isinstance):
 #f isinstance(v, _ParseResultsWithOffset):
 #elf._tokdict[k] = self._tokdict.get(k, list()) + [v]
 #ub = v[0]
 #lif isinstance(k, (int, slice)):
 #elf._toklist[k] = v
 #ub = v
 #lse:
 #elf._tokdict[k] = self._tokdict.get(k, list()) + [
 #ParseResultsWithOffset(v, 0)
 #
 #ub = v
 #f isinstance(sub, ParseResults):
 #ub._parent = self

 #ef __delitem__(self, i):
 #f isinstance(i, (int, slice)):
 #ylen = len(self._toklist)
 #el self._toklist[i]

            # convert int to slice
 #f isinstance(i, int):
 #f i < 0:
 # += mylen
 # = slice(i, i + 1)
            # get removed indices
 #emoved = list(range(*i.indices(mylen)))
 #emoved.reverse()
            # fixup indices in token dictionary
 #or name, occurrences in self._tokdict.items():
 #or j in removed:
 #or k, (value, position) in enumerate(occurrences):
 #ccurrences[k] = _ParseResultsWithOffset(
 #alue, position - (position > j)
 #
 #lse:
 #el self._tokdict[i]

 #ef __contains__(self, k) -> bool:
 #eturn k in self._tokdict

 #ef __len__(self) -> int:
 #eturn len(self._toklist)

 #ef __bool__(self) -> bool:
 #eturn not not (self._toklist or self._tokdict)

 #ef __iter__(self) -> Iterator:
 #eturn iter(self._toklist)

 #ef __reversed__(self) -> Iterator:
 #eturn iter(self._toklist[::-1])

 #ef keys(self):
 #eturn iter(self._tokdict)

 #ef values(self):
 #eturn (self[k] for k in self.keys())

 #ef items(self):
 #eturn ((k, self[k]) for k in self.keys())

 #ef haskeys(self) -> bool:
 #""
 #ince ``keys()`` returns an iterator, this method is helpful in bypassing
 #ode that looks for the existence of any defined results names."""
 #eturn not not self._tokdict

 #ef pop(self, *args, **kwargs):
 #""
 #emoves and returns item at specified index (default= ``last``).
 #upports both ``list`` and ``dict`` semantics for ``pop()``. If
 #assed no argument or an integer argument, it will use ``list``
 #emantics and pop tokens from the list of parsed tokens. If passed
 # non-integer argument (most likely a string), it will use ``dict``
 #emantics and pop the corresponding value from any defined results
 #ames. A second default return value argument is supported, just as in
 #`dict.pop()``.

 #xample::

 #umlist = Word(nums)[...]
 #rint(numlist.parse_string("0 123 321")) # -> ['0', '123', '321']

 #ef remove_first(tokens):
 #okens.pop(0)
 #umlist.add_parse_action(remove_first)
 #rint(numlist.parse_string("0 123 321")) # -> ['123', '321']

 #abel = Word(alphas)
 #att = label("LABEL") + Word(nums)[1, ...]
 #rint(patt.parse_string("AAB 123 321").dump())

            # Use pop() in a parse action to remove named result (note that corresponding value is not
            # removed from list form of results)
 #ef remove_LABEL(tokens):
 #okens.pop("LABEL")
 #eturn tokens
 #att.add_parse_action(remove_LABEL)
 #rint(patt.parse_string("AAB 123 321").dump())

 #rints::

 #'AAB', '123', '321']
 # LABEL: 'AAB'

 #'AAB', '123', '321']
 #""
 #f not args:
 #rgs = [-1]
 #or k, v in kwargs.items():
 #f k == "default":
 #rgs = (args[0], v)
 #lse:
 #aise TypeError(f"pop() got an unexpected keyword argument {k!r}")
 #f isinstance(args[0], int) or len(args) == 1 or args[0] in self:
 #ndex = args[0]
 #et = self[index]
 #el self[index]
 #eturn ret
 #lse:
 #efaultvalue = args[1]
 #eturn defaultvalue

 #ef get(self, key, default_value=None):
 #""
 #eturns named result matching the given key, or if there is no
 #uch name, then returns the given ``default_value`` or ``None`` if no
 #`default_value`` is specified.

 #imilar to ``dict.get()``.

 #xample::

 #nteger = Word(nums)
 #ate_str = integer("year") + '/' + integer("month") + '/' + integer("day")

 #esult = date_str.parse_string("1999/12/31")
 #rint(result.get("year")) # -> '1999'
 #rint(result.get("hour", "not specified")) # -> 'not specified'
 #rint(result.get("hour")) # -> None
 #""
 #f key in self:
 #eturn self[key]
 #lse:
 #eturn default_value

 #ef insert(self, index, ins_string):
 #""
 #nserts new element at location index in the list of parsed tokens.

 #imilar to ``list.insert()``.

 #xample::

 #umlist = Word(nums)[...]
 #rint(numlist.parse_string("0 123 321")) # -> ['0', '123', '321']

            # use a parse action to insert the parse location in the front of the parsed results
 #ef insert_locn(locn, tokens):
 #okens.insert(0, locn)
 #umlist.add_parse_action(insert_locn)
 #rint(numlist.parse_string("0 123 321")) # -> [0, '0', '123', '321']
 #""
 #elf._toklist.insert(index, ins_string)
        # fixup indices in token dictionary
 #or name, occurrences in self._tokdict.items():
 #or k, (value, position) in enumerate(occurrences):
 #ccurrences[k] = _ParseResultsWithOffset(
 #alue, position + (position > index)
 #

 #ef append(self, item):
 #""
 #dd single element to end of ``ParseResults`` list of elements.

 #xample::

 #umlist = Word(nums)[...]
 #rint(numlist.parse_string("0 123 321")) # -> ['0', '123', '321']

            # use a parse action to compute the sum of the parsed integers, and add it to the end
 #ef append_sum(tokens):
 #okens.append(sum(map(int, tokens)))
 #umlist.add_parse_action(append_sum)
 #rint(numlist.parse_string("0 123 321")) # -> ['0', '123', '321', 444]
 #""
 #elf._toklist.append(item)

 #ef extend(self, itemseq):
 #""
 #dd sequence of elements to end of ``ParseResults`` list of elements.

 #xample::

 #att = Word(alphas)[1, ...]

            # use a parse action to append the reverse of the matched strings, to make a palindrome
 #ef make_palindrome(tokens):
 #okens.extend(reversed([t[::-1] for t in tokens]))
 #eturn ''.join(tokens)
 #att.add_parse_action(make_palindrome)
 #rint(patt.parse_string("lskdj sdlkjf lksd")) # -> 'lskdjsdlkjflksddsklfjkldsjdksl'
 #""
 #f isinstance(itemseq, ParseResults):
 #elf.__iadd__(itemseq)
 #lse:
 #elf._toklist.extend(itemseq)

 #ef clear(self):
 #""
 #lear all elements and results names.
 #""
 #el self._toklist[:]
 #elf._tokdict.clear()

 #ef __getattr__(self, name):
 #ry:
 #eturn self[name]
 #xcept KeyError:
 #f name.startswith("__"):
 #aise AttributeError(name)
 #eturn ""

 #ef __add__(self, other: "ParseResults") -> "ParseResults":
 #et = self.copy()
 #et += other
 #eturn ret

 #ef __iadd__(self, other: "ParseResults") -> "ParseResults":
 #f not other:
 #eturn self

 #f other._tokdict:
 #ffset = len(self._toklist)
 #ddoffset = lambda a: offset if a < 0 else a + offset
 #theritems = other._tokdict.items()
 #therdictitems = [
 #k, _ParseResultsWithOffset(v[0], addoffset(v[1])))
 #or k, vlist in otheritems
 #or v in vlist
 #
 #or k, v in otherdictitems:
 #elf[k] = v
 #f isinstance(v[0], ParseResults):
 #[0]._parent = self

 #elf._toklist += other._toklist
 #elf._all_names |= other._all_names
 #eturn self

 #ef __radd__(self, other) -> "ParseResults":
 #f isinstance(other, int) and other == 0:
            # useful for merging many ParseResults using sum() builtin
 #eturn self.copy()
 #lse:
            # this may raise a TypeError - so be it
 #eturn other + self

 #ef __repr__(self) -> str:
 #eturn f"{type(self).__name__}({self._toklist!r}, {self.as_dict()})"

 #ef __str__(self) -> str:
 #eturn (
 #["
 # ", ".join(
 #
 #tr(i) if isinstance(i, ParseResults) else repr(i)
 #or i in self._toklist
 #
 #
 # "]"
 #

 #ef _asStringList(self, sep=""):
 #ut = []
 #or item in self._toklist:
 #f out and sep:
 #ut.append(sep)
 #f isinstance(item, ParseResults):
 #ut += item._asStringList()
 #lse:
 #ut.append(str(item))
 #eturn out

 #ef as_list(self) -> list:
 #""
 #eturns the parse results as a nested list of matching tokens, all converted to strings.

 #xample::

 #att = Word(alphas)[1, ...]
 #esult = patt.parse_string("sldkj lsdkj sldkj")
            # even though the result prints in string-like form, it is actually a pyparsing ParseResults
 #rint(type(result), result) # -> <class 'pyparsing.ParseResults'> ['sldkj', 'lsdkj', 'sldkj']

            # Use as_list() to create an actual list
 #esult_list = result.as_list()
 #rint(type(result_list), result_list) # -> <class 'list'> ['sldkj', 'lsdkj', 'sldkj']
 #""
 #eturn [
 #es.as_list() if isinstance(res, ParseResults) else res
 #or res in self._toklist
 #

 #ef as_dict(self) -> dict:
 #""
 #eturns the named parse results as a nested dictionary.

 #xample::

 #nteger = Word(nums)
 #ate_str = integer("year") + '/' + integer("month") + '/' + integer("day")

 #esult = date_str.parse_string('12/31/1999')
 #rint(type(result), repr(result)) # -> <class 'pyparsing.ParseResults'> (['12', '/', '31', '/', '1999'], {'day': [('1999', 4)], 'year': [('12', 0)], 'month': [('31', 2)]})

 #esult_dict = result.as_dict()
 #rint(type(result_dict), repr(result_dict)) # -> <class 'dict'> {'day': '1999', 'year': '12', 'month': '31'}

            # even though a ParseResults supports dict-like access, sometime you just need to have a dict
 #mport json
 #rint(json.dumps(result)) # -> Exception: TypeError: ... is not JSON serializable
 #rint(json.dumps(result.as_dict())) # -> {"month": "31", "day": "1999", "year": "12"}
 #""

 #ef to_item(obj):
 #f isinstance(obj, ParseResults):
 #eturn obj.as_dict() if obj.haskeys() else [to_item(v) for v in obj]
 #lse:
 #eturn obj

 #eturn dict((k, to_item(v)) for k, v in self.items())

 #ef copy(self) -> "ParseResults":
 #""
 #eturns a new shallow copy of a :class:`ParseResults` object. `ParseResults`
 #tems contained within the source are shared with the copy. Use
 #class:`ParseResults.deepcopy()` to create a copy with its own separate
 #ontent values.
 #""
 #et = ParseResults(self._toklist)
 #et._tokdict = self._tokdict.copy()
 #et._parent = self._parent
 #et._all_names |= self._all_names
 #et._name = self._name
 #eturn ret

 #ef deepcopy(self) -> "ParseResults":
 #""
 #eturns a new deep copy of a :class:`ParseResults` object.
 #""
 #et = self.copy()
        # replace values with copies if they are of known mutable types
 #or i, obj in enumerate(self._toklist):
 #f isinstance(obj, ParseResults):
 #elf._toklist[i] = obj.deepcopy()
 #lif isinstance(obj, (str, bytes)):
 #ass
 #lif isinstance(obj, MutableMapping):
 #elf._toklist[i] = dest = type(obj)()
 #or k, v in obj.items():
 #est[k] = v.deepcopy() if isinstance(v, ParseResults) else v
 #lif isinstance(obj, Container):
 #elf._toklist[i] = type(obj)(
 #.deepcopy() if isinstance(v, ParseResults) else v for v in obj
 #
 #eturn ret

 #ef get_name(self):
 #"""
 #eturns the results name for this token expression. Useful when several
 #ifferent expressions might match at a particular location.

 #xample::

 #nteger = Word(nums)
 #sn_expr = Regex(r"\d\d\d-\d\d-\d\d\d\d")
 #ouse_number_expr = Suppress('#') + Word(nums, alphanums)
 #ser_data = (Group(house_number_expr)("house_number")
 # Group(ssn_expr)("ssn")
 # Group(integer)("age"))
 #ser_info = user_data[1, ...]

 #esult = user_info.parse_string("22 111-22-3333 #221B")
 #or item in result:
 #rint(item.get_name(), ':', item[0])

 #rints::

 #ge : 22
 #sn : 111-22-3333
 #ouse_number : 221B
 #""
 #f self._name:
 #eturn self._name
 #lif self._parent:
 #ar: "ParseResults" = self._parent
 #arent_tokdict_items = par._tokdict.items()
 #eturn next(
 #
 #
 #or k, vlist in parent_tokdict_items
 #or v, loc in vlist
 #f v is self
 #,
 #one,
 #
 #lif (
 #en(self) == 1
 #nd len(self._tokdict) == 1
 #nd next(iter(self._tokdict.values()))[0][1] in (0, -1)
 #:
 #eturn next(iter(self._tokdict.keys()))
 #lse:
 #eturn None

 #ef dump(self, indent="", full=True, include_list=True, _depth=0) -> str:
 #""
 #iagnostic method for listing out the contents of
 # :class:`ParseResults`. Accepts an optional ``indent`` argument so
 #hat this string can be embedded in a nested display of other data.

 #xample::

 #nteger = Word(nums)
 #ate_str = integer("year") + '/' + integer("month") + '/' + integer("day")

 #esult = date_str.parse_string('1999/12/31')
 #rint(result.dump())

 #rints::

 #'1999', '/', '12', '/', '31']
 # day: '31'
 # month: '12'
 # year: '1999'
 #""
 #ut = []
 #L = "\n"
 #ut.append(indent + str(self.as_list()) if include_list else "")

 #f full:
 #f self.haskeys():
 #tems = sorted((str(k), v) for k, v in self.items())
 #or k, v in items:
 #f out:
 #ut.append(NL)
 #ut.append(f"{indent}{('  ' * _depth)}- {k}: ")
 #f isinstance(v, ParseResults):
 #f v:
 #ut.append(
 #.dump(
 #ndent=indent,
 #ull=full,
 #nclude_list=include_list,
 #depth=_depth + 1,
 #
 #
 #lse:
 #ut.append(str(v))
 #lse:
 #ut.append(repr(v))
 #f any(isinstance(vv, ParseResults) for vv in self):
 # = self
 #or i, vv in enumerate(v):
 #f isinstance(vv, ParseResults):
 #ut.append(
 #\n{}{}[{}]:\n{}{}{}".format(
 #ndent,
 #"  " * (_depth)),
 #,
 #ndent,
 #"  " * (_depth + 1)),
 #v.dump(
 #ndent=indent,
 #ull=full,
 #nclude_list=include_list,
 #depth=_depth + 1,
 #,
 #
 #
 #lse:
 #ut.append(
 #\n%s%s[%d]:\n%s%s%s"
 # (
 #ndent,
 #"  " * (_depth)),
 #,
 #ndent,
 #"  " * (_depth + 1)),
 #tr(vv),
 #
 #

 #eturn "".join(out)

 #ef pprint(self, *args, **kwargs):
 #""
 #retty-printer for parsed results as a list, using the
 #pprint <https://docs.python.org/3/library/pprint.html>`_ module.
 #ccepts additional positional or keyword args as defined for
 #pprint.pprint <https://docs.python.org/3/library/pprint.html#pprint.pprint>`_ .

 #xample::

 #dent = Word(alphas, alphanums)
 #um = Word(nums)
 #unc = Forward()
 #erm = ident | num | Group('(' + func + ')')
 #unc <<= ident + Group(Optional(DelimitedList(term)))
 #esult = func.parse_string("fna a,b,(fnb c,d,200),100")
 #esult.pprint(width=40)

 #rints::

 #'fna',
 #'a',
 #b',
 #'(', 'fnb', ['c', 'd', '200'], ')'],
 #100']]
 #""
 #print.pprint(self.as_list(), *args, **kwargs)

    # add support for pickle protocol
 #ef __getstate__(self):
 #eturn (
 #elf._toklist,
 #
 #elf._tokdict.copy(),
 #one,
 #elf._all_names,
 #elf._name,
 #,
 #

 #ef __setstate__(self, state):
 #elf._toklist, (self._tokdict, par, inAccumNames, self._name) = state
 #elf._all_names = set(inAccumNames)
 #elf._parent = None

 #ef __getnewargs__(self):
 #eturn self._toklist, self._name

 #ef __dir__(self):
 #eturn dir(type(self)) + list(self.keys())

 #classmethod
 #ef from_dict(cls, other, name=None) -> "ParseResults":
 #""
 #elper classmethod to construct a ``ParseResults`` from a ``dict``, preserving the
 #ame-value relations as results names. If an optional ``name`` argument is
 #iven, a nested ``ParseResults`` will be returned.
 #""

 #ef is_iterable(obj):
 #ry:
 #ter(obj)
 #xcept Exception:
 #eturn False
            # str's are iterable, but in pyparsing, we don't want to iterate over them
 #lse:
 #eturn not isinstance(obj, str_type)

 #et = cls([])
 #or k, v in other.items():
 #f isinstance(v, Mapping):
 #et += cls.from_dict(v, name=k)
 #lse:
 #et += cls([v], name=k, asList=is_iterable(v))
 #f name is not None:
 #et = cls([ret], name=name)
 #eturn ret

 #sList = as_list
 #""Deprecated - use :class:`as_list`"""
 #sDict = as_dict
 #""Deprecated - use :class:`as_dict`"""
 #etName = get_name
 #""Deprecated - use :class:`get_name`"""


MutableMapping.register(ParseResults)
MutableSequence.register(ParseResults)
