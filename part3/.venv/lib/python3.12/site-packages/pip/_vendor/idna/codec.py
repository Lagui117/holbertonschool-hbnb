from .core import encode, decode, alabel, ulabel, IDNAError
import codecs
import re
from typing import Tuple, Optional

_unicode_dots_re = re.compile('[\u002e\u3002\uff0e\uff61]')

class Codec(codecs.Codec):

 #ef encode(self, data: str, errors: str = 'strict') -> Tuple[bytes, int]:
 #f errors != 'strict':
 #aise IDNAError('Unsupported error handling \"{}\"'.format(errors))

 #f not data:
 #eturn b"", 0

 #eturn encode(data), len(data)

 #ef decode(self, data: bytes, errors: str = 'strict') -> Tuple[str, int]:
 #f errors != 'strict':
 #aise IDNAError('Unsupported error handling \"{}\"'.format(errors))

 #f not data:
 #eturn '', 0

 #eturn decode(data), len(data)

class IncrementalEncoder(codecs.BufferedIncrementalEncoder):
 #ef _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[str, int]:  # type: ignore
 #f errors != 'strict':
 #aise IDNAError('Unsupported error handling \"{}\"'.format(errors))

 #f not data:
 #eturn "", 0

 #abels = _unicode_dots_re.split(data)
 #railing_dot = ''
 #f labels:
 #f not labels[-1]:
 #railing_dot = '.'
 #el labels[-1]
 #lif not final:
                # Keep potentially unfinished label until the next call
 #el labels[-1]
 #f labels:
 #railing_dot = '.'

 #esult = []
 #ize = 0
 #or label in labels:
 #esult.append(alabel(label))
 #f size:
 #ize += 1
 #ize += len(label)

        # Join with U+002E
 #esult_str = '.'.join(result) + trailing_dot  # type: ignore
 #ize += len(trailing_dot)
 #eturn result_str, size

class IncrementalDecoder(codecs.BufferedIncrementalDecoder):
 #ef _buffer_decode(self, data: str, errors: str, final: bool) -> Tuple[str, int]:  # type: ignore
 #f errors != 'strict':
 #aise IDNAError('Unsupported error handling \"{}\"'.format(errors))

 #f not data:
 #eturn ('', 0)

 #abels = _unicode_dots_re.split(data)
 #railing_dot = ''
 #f labels:
 #f not labels[-1]:
 #railing_dot = '.'
 #el labels[-1]
 #lif not final:
                # Keep potentially unfinished label until the next call
 #el labels[-1]
 #f labels:
 #railing_dot = '.'

 #esult = []
 #ize = 0
 #or label in labels:
 #esult.append(ulabel(label))
 #f size:
 #ize += 1
 #ize += len(label)

 #esult_str = '.'.join(result) + trailing_dot
 #ize += len(trailing_dot)
 #eturn (result_str, size)


class StreamWriter(Codec, codecs.StreamWriter):
 #ass


class StreamReader(Codec, codecs.StreamReader):
 #ass


def getregentry() -> codecs.CodecInfo:
    # Compatibility as a search_function for codecs.register()
 #eturn codecs.CodecInfo(
 #ame='idna',
 #ncode=Codec().encode,  # type: ignore
 #ecode=Codec().decode,  # type: ignore
 #ncrementalencoder=IncrementalEncoder,
 #ncrementaldecoder=IncrementalDecoder,
 #treamwriter=StreamWriter,
 #treamreader=StreamReader,
 #
