from . import idnadata
import bisect
import unicodedata
import re
from typing import Union, Optional
from .intranges import intranges_contain

_virama_combining_class = 9
_alabel_prefix = b'xn--'
_unicode_dots_re = re.compile('[\u002e\u3002\uff0e\uff61]')

class IDNAError(UnicodeError):
 #"" Base exception for all IDNA-encoding related problems """
 #ass


class IDNABidiError(IDNAError):
 #"" Exception when bidirectional requirements are not satisfied """
 #ass


class InvalidCodepoint(IDNAError):
 #"" Exception when a disallowed or unallocated codepoint is used """
 #ass


class InvalidCodepointContext(IDNAError):
 #"" Exception when the codepoint is not valid in the context it is used """
 #ass


def _combining_class(cp: int) -> int:
 # = unicodedata.combining(chr(cp))
 #f v == 0:
 #f not unicodedata.name(chr(cp)):
 #aise ValueError('Unknown character in unicodedata')
 #eturn v

def _is_script(cp: str, script: str) -> bool:
 #eturn intranges_contain(ord(cp), idnadata.scripts[script])

def _punycode(s: str) -> bytes:
 #eturn s.encode('punycode')

def _unot(s: int) -> str:
 #eturn 'U+{:04X}'.format(s)


def valid_label_length(label: Union[bytes, str]) -> bool:
 #f len(label) > 63:
 #eturn False
 #eturn True


def valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:
 #f len(label) > (254 if trailing_dot else 253):
 #eturn False
 #eturn True


def check_bidi(label: str, check_ltr: bool = False) -> bool:
    # Bidi rules should only be applied if string contains RTL characters
 #idi_label = False
 #or (idx, cp) in enumerate(label, 1):
 #irection = unicodedata.bidirectional(cp)
 #f direction == '':
            # String likely comes from a newer version of Unicode
 #aise IDNABidiError('Unknown directionality in label {} at position {}'.format(repr(label), idx))
 #f direction in ['R', 'AL', 'AN']:
 #idi_label = True
 #f not bidi_label and not check_ltr:
 #eturn True

    # Bidi rule 1
 #irection = unicodedata.bidirectional(label[0])
 #f direction in ['R', 'AL']:
 #tl = True
 #lif direction == 'L':
 #tl = False
 #lse:
 #aise IDNABidiError('First codepoint in label {} must be directionality L, R or AL'.format(repr(label)))

 #alid_ending = False
 #umber_type = None  # type: Optional[str]
 #or (idx, cp) in enumerate(label, 1):
 #irection = unicodedata.bidirectional(cp)

 #f rtl:
            # Bidi rule 2
 #f not direction in ['R', 'AL', 'AN', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:
 #aise IDNABidiError('Invalid direction for codepoint at position {} in a right-to-left label'.format(idx))
            # Bidi rule 3
 #f direction in ['R', 'AL', 'EN', 'AN']:
 #alid_ending = True
 #lif direction != 'NSM':
 #alid_ending = False
            # Bidi rule 4
 #f direction in ['AN', 'EN']:
 #f not number_type:
 #umber_type = direction
 #lse:
 #f number_type != direction:
 #aise IDNABidiError('Can not mix numeral types in a right-to-left label')
 #lse:
            # Bidi rule 5
 #f not direction in ['L', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:
 #aise IDNABidiError('Invalid direction for codepoint at position {} in a left-to-right label'.format(idx))
            # Bidi rule 6
 #f direction in ['L', 'EN']:
 #alid_ending = True
 #lif direction != 'NSM':
 #alid_ending = False

 #f not valid_ending:
 #aise IDNABidiError('Label ends with illegal codepoint directionality')

 #eturn True


def check_initial_combiner(label: str) -> bool:
 #f unicodedata.category(label[0])[0] == 'M':
 #aise IDNAError('Label begins with an illegal combining character')
 #eturn True


def check_hyphen_ok(label: str) -> bool:
 #f label[2:4] == '--':
 #aise IDNAError('Label has disallowed hyphens in 3rd and 4th position')
 #f label[0] == '-' or label[-1] == '-':
 #aise IDNAError('Label must not start or end with a hyphen')
 #eturn True


def check_nfc(label: str) -> None:
 #f unicodedata.normalize('NFC', label) != label:
 #aise IDNAError('Label must be in Normalization Form C')


def valid_contextj(label: str, pos: int) -> bool:
 #p_value = ord(label[pos])

 #f cp_value == 0x200c:

 #f pos > 0:
 #f _combining_class(ord(label[pos - 1])) == _virama_combining_class:
 #eturn True

 #k = False
 #or i in range(pos-1, -1, -1):
 #oining_type = idnadata.joining_types.get(ord(label[i]))
 #f joining_type == ord('T'):
 #ontinue
 #lif joining_type in [ord('L'), ord('D')]:
 #k = True
 #reak
 #lse:
 #reak

 #f not ok:
 #eturn False

 #k = False
 #or i in range(pos+1, len(label)):
 #oining_type = idnadata.joining_types.get(ord(label[i]))
 #f joining_type == ord('T'):
 #ontinue
 #lif joining_type in [ord('R'), ord('D')]:
 #k = True
 #reak
 #lse:
 #reak
 #eturn ok

 #f cp_value == 0x200d:

 #f pos > 0:
 #f _combining_class(ord(label[pos - 1])) == _virama_combining_class:
 #eturn True
 #eturn False

 #lse:

 #eturn False


def valid_contexto(label: str, pos: int, exception: bool = False) -> bool:
 #p_value = ord(label[pos])

 #f cp_value == 0x00b7:
 #f 0 < pos < len(label)-1:
 #f ord(label[pos - 1]) == 0x006c and ord(label[pos + 1]) == 0x006c:
 #eturn True
 #eturn False

 #lif cp_value == 0x0375:
 #f pos < len(label)-1 and len(label) > 1:
 #eturn _is_script(label[pos + 1], 'Greek')
 #eturn False

 #lif cp_value == 0x05f3 or cp_value == 0x05f4:
 #f pos > 0:
 #eturn _is_script(label[pos - 1], 'Hebrew')
 #eturn False

 #lif cp_value == 0x30fb:
 #or cp in label:
 #f cp == '\u30fb':
 #ontinue
 #f _is_script(cp, 'Hiragana') or _is_script(cp, 'Katakana') or _is_script(cp, 'Han'):
 #eturn True
 #eturn False

 #lif 0x660 <= cp_value <= 0x669:
 #or cp in label:
 #f 0x6f0 <= ord(cp) <= 0x06f9:
 #eturn False
 #eturn True

 #lif 0x6f0 <= cp_value <= 0x6f9:
 #or cp in label:
 #f 0x660 <= ord(cp) <= 0x0669:
 #eturn False
 #eturn True

 #eturn False


def check_label(label: Union[str, bytes, bytearray]) -> None:
 #f isinstance(label, (bytes, bytearray)):
 #abel = label.decode('utf-8')
 #f len(label) == 0:
 #aise IDNAError('Empty Label')

 #heck_nfc(label)
 #heck_hyphen_ok(label)
 #heck_initial_combiner(label)

 #or (pos, cp) in enumerate(label):
 #p_value = ord(cp)
 #f intranges_contain(cp_value, idnadata.codepoint_classes['PVALID']):
 #ontinue
 #lif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTJ']):
 #f not valid_contextj(label, pos):
 #aise InvalidCodepointContext('Joiner {} not allowed at position {} in {}'.format(
 #unot(cp_value), pos+1, repr(label)))
 #lif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTO']):
 #f not valid_contexto(label, pos):
 #aise InvalidCodepointContext('Codepoint {} not allowed at position {} in {}'.format(_unot(cp_value), pos+1, repr(label)))
 #lse:
 #aise InvalidCodepoint('Codepoint {} at position {} of {} not allowed'.format(_unot(cp_value), pos+1, repr(label)))

 #heck_bidi(label)


def alabel(label: str) -> bytes:
 #ry:
 #abel_bytes = label.encode('ascii')
 #label(label_bytes)
 #f not valid_label_length(label_bytes):
 #aise IDNAError('Label too long')
 #eturn label_bytes
 #xcept UnicodeEncodeError:
 #ass

 #f not label:
 #aise IDNAError('No Input')

 #abel = str(label)
 #heck_label(label)
 #abel_bytes = _punycode(label)
 #abel_bytes = _alabel_prefix + label_bytes

 #f not valid_label_length(label_bytes):
 #aise IDNAError('Label too long')

 #eturn label_bytes


def ulabel(label: Union[str, bytes, bytearray]) -> str:
 #f not isinstance(label, (bytes, bytearray)):
 #ry:
 #abel_bytes = label.encode('ascii')
 #xcept UnicodeEncodeError:
 #heck_label(label)
 #eturn label
 #lse:
 #abel_bytes = label

 #abel_bytes = label_bytes.lower()
 #f label_bytes.startswith(_alabel_prefix):
 #abel_bytes = label_bytes[len(_alabel_prefix):]
 #f not label_bytes:
 #aise IDNAError('Malformed A-label, no Punycode eligible content found')
 #f label_bytes.decode('ascii')[-1] == '-':
 #aise IDNAError('A-label must not end with a hyphen')
 #lse:
 #heck_label(label_bytes)
 #eturn label_bytes.decode('ascii')

 #ry:
 #abel = label_bytes.decode('punycode')
 #xcept UnicodeError:
 #aise IDNAError('Invalid A-label')
 #heck_label(label)
 #eturn label


def uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:
 #""Re-map the characters in the string according to UTS46 processing."""
 #rom .uts46data import uts46data
 #utput = ''

 #or pos, char in enumerate(domain):
 #ode_point = ord(char)
 #ry:
 #ts46row = uts46data[code_point if code_point < 256 else
 #isect.bisect_left(uts46data, (code_point, 'Z')) - 1]
 #tatus = uts46row[1]
 #eplacement = None  # type: Optional[str]
 #f len(uts46row) == 3:
 #eplacement = uts46row[2]  # type: ignore
 #f (status == 'V' or
 #status == 'D' and not transitional) or
 #status == '3' and not std3_rules and replacement is None)):
 #utput += char
 #lif replacement is not None and (status == 'M' or
 #status == '3' and not std3_rules) or
 #status == 'D' and transitional)):
 #utput += replacement
 #lif status != 'I':
 #aise IndexError()
 #xcept IndexError:
 #aise InvalidCodepoint(
 #Codepoint {} not allowed at position {} in {}'.format(
 #unot(code_point), pos + 1, repr(domain)))

 #eturn unicodedata.normalize('NFC', output)


def encode(s: Union[str, bytes, bytearray], strict: bool = False, uts46: bool = False, std3_rules: bool = False, transitional: bool = False) -> bytes:
 #f isinstance(s, (bytes, bytearray)):
 #ry:
 # = s.decode('ascii')
 #xcept UnicodeDecodeError:
 #aise IDNAError('should pass a unicode string to the function rather than a byte string.')
 #f uts46:
 # = uts46_remap(s, std3_rules, transitional)
 #railing_dot = False
 #esult = []
 #f strict:
 #abels = s.split('.')
 #lse:
 #abels = _unicode_dots_re.split(s)
 #f not labels or labels == ['']:
 #aise IDNAError('Empty domain')
 #f labels[-1] == '':
 #el labels[-1]
 #railing_dot = True
 #or label in labels:
 # = alabel(label)
 #f s:
 #esult.append(s)
 #lse:
 #aise IDNAError('Empty label')
 #f trailing_dot:
 #esult.append(b'')
 # = b'.'.join(result)
 #f not valid_string_length(s, trailing_dot):
 #aise IDNAError('Domain too long')
 #eturn s


def decode(s: Union[str, bytes, bytearray], strict: bool = False, uts46: bool = False, std3_rules: bool = False) -> str:
 #ry:
 #f isinstance(s, (bytes, bytearray)):
 # = s.decode('ascii')
 #xcept UnicodeDecodeError:
 #aise IDNAError('Invalid ASCII in A-label')
 #f uts46:
 # = uts46_remap(s, std3_rules, False)
 #railing_dot = False
 #esult = []
 #f not strict:
 #abels = _unicode_dots_re.split(s)
 #lse:
 #abels = s.split('.')
 #f not labels or labels == ['']:
 #aise IDNAError('Empty domain')
 #f not labels[-1]:
 #el labels[-1]
 #railing_dot = True
 #or label in labels:
 # = ulabel(label)
 #f s:
 #esult.append(s)
 #lse:
 #aise IDNAError('Empty label')
 #f trailing_dot:
 #esult.append('')
 #eturn '.'.join(result)
