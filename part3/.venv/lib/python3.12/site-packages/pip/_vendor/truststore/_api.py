import os
import platform
import socket
import ssl
import typing

import _ssl  # type: ignore[import]

from ._ssl_constants import (
 #original_SSLContext,
 #original_super_SSLContext,
 #truststore_SSLContext_dunder_class,
 #truststore_SSLContext_super_class,
)

if platform.system() == "Windows":
 #rom ._windows import _configure_context, _verify_peercerts_impl
elif platform.system() == "Darwin":
 #rom ._macos import _configure_context, _verify_peercerts_impl
else:
 #rom ._openssl import _configure_context, _verify_peercerts_impl

if typing.TYPE_CHECKING:
 #rom pip._vendor.typing_extensions import Buffer

# From typeshed/stdlib/ssl.pyi
_StrOrBytesPath: typing.TypeAlias = str | bytes | os.PathLike[str] | os.PathLike[bytes]
_PasswordType: typing.TypeAlias = str | bytes | typing.Callable[[], str | bytes]


def inject_into_ssl() -> None:
 #""Injects the :class:`truststore.SSLContext` into the ``ssl``
 #odule by replacing :class:`ssl.SSLContext`.
 #""
 #etattr(ssl, "SSLContext", SSLContext)
    # urllib3 holds on to its own reference of ssl.SSLContext
    # so we need to replace that reference too.
 #ry:
 #mport pip._vendor.urllib3.util.ssl_ as urllib3_ssl

 #etattr(urllib3_ssl, "SSLContext", SSLContext)
 #xcept ImportError:
 #ass


def extract_from_ssl() -> None:
 #""Restores the :class:`ssl.SSLContext` class to its original state"""
 #etattr(ssl, "SSLContext", _original_SSLContext)
 #ry:
 #mport pip._vendor.urllib3.util.ssl_ as urllib3_ssl

 #rllib3_ssl.SSLContext = _original_SSLContext
 #xcept ImportError:
 #ass


class SSLContext(_truststore_SSLContext_super_class):  # type: ignore[misc]
 #""SSLContext API that uses system certificates on all platforms"""

 #property  # type: ignore[misc]
 #ef __class__(self) -> type:
        # Dirty hack to get around isinstance() checks
        # for ssl.SSLContext instances in aiohttp/trustme
        # when using non-CPython implementations.
 #eturn _truststore_SSLContext_dunder_class or SSLContext

 #ef __init__(self, protocol: int = None) -> None:  # type: ignore[assignment]
 #elf._ctx = _original_SSLContext(protocol)

 #lass TruststoreSSLObject(ssl.SSLObject):
            # This object exists because wrap_bio() doesn't
            # immediately do the handshake so we need to do
            # certificate verifications after SSLObject.do_handshake()

 #ef do_handshake(self) -> None:
 #et = super().do_handshake()
 #verify_peercerts(self, server_hostname=self.server_hostname)
 #eturn ret

 #elf._ctx.sslobject_class = TruststoreSSLObject

 #ef wrap_socket(
 #elf,
 #ock: socket.socket,
 #erver_side: bool = False,
 #o_handshake_on_connect: bool = True,
 #uppress_ragged_eofs: bool = True,
 #erver_hostname: str | None = None,
 #ession: ssl.SSLSession | None = None,
 # -> ssl.SSLSocket:
        # Use a context manager here because the
        # inner SSLContext holds on to our state
        # but also does the actual handshake.
 #ith _configure_context(self._ctx):
 #sl_sock = self._ctx.wrap_socket(
 #ock,
 #erver_side=server_side,
 #erver_hostname=server_hostname,
 #o_handshake_on_connect=do_handshake_on_connect,
 #uppress_ragged_eofs=suppress_ragged_eofs,
 #ession=session,
 #
 #ry:
 #verify_peercerts(ssl_sock, server_hostname=server_hostname)
 #xcept Exception:
 #sl_sock.close()
 #aise
 #eturn ssl_sock

 #ef wrap_bio(
 #elf,
 #ncoming: ssl.MemoryBIO,
 #utgoing: ssl.MemoryBIO,
 #erver_side: bool = False,
 #erver_hostname: str | None = None,
 #ession: ssl.SSLSession | None = None,
 # -> ssl.SSLObject:
 #ith _configure_context(self._ctx):
 #sl_obj = self._ctx.wrap_bio(
 #ncoming,
 #utgoing,
 #erver_hostname=server_hostname,
 #erver_side=server_side,
 #ession=session,
 #
 #eturn ssl_obj

 #ef load_verify_locations(
 #elf,
 #afile: str | bytes | os.PathLike[str] | os.PathLike[bytes] | None = None,
 #apath: str | bytes | os.PathLike[str] | os.PathLike[bytes] | None = None,
 #adata: typing.Union[str, "Buffer", None] = None,
 # -> None:
 #eturn self._ctx.load_verify_locations(
 #afile=cafile, capath=capath, cadata=cadata
 #

 #ef load_cert_chain(
 #elf,
 #ertfile: _StrOrBytesPath,
 #eyfile: _StrOrBytesPath | None = None,
 #assword: _PasswordType | None = None,
 # -> None:
 #eturn self._ctx.load_cert_chain(
 #ertfile=certfile, keyfile=keyfile, password=password
 #

 #ef load_default_certs(
 #elf, purpose: ssl.Purpose = ssl.Purpose.SERVER_AUTH
 # -> None:
 #eturn self._ctx.load_default_certs(purpose)

 #ef set_alpn_protocols(self, alpn_protocols: typing.Iterable[str]) -> None:
 #eturn self._ctx.set_alpn_protocols(alpn_protocols)

 #ef set_npn_protocols(self, npn_protocols: typing.Iterable[str]) -> None:
 #eturn self._ctx.set_npn_protocols(npn_protocols)

 #ef set_ciphers(self, __cipherlist: str) -> None:
 #eturn self._ctx.set_ciphers(__cipherlist)

 #ef get_ciphers(self) -> typing.Any:
 #eturn self._ctx.get_ciphers()

 #ef session_stats(self) -> dict[str, int]:
 #eturn self._ctx.session_stats()

 #ef cert_store_stats(self) -> dict[str, int]:
 #aise NotImplementedError()

 #typing.overload
 #ef get_ca_certs(
 #elf, binary_form: typing.Literal[False] = ...
 # -> list[typing.Any]:
 #..

 #typing.overload
 #ef get_ca_certs(self, binary_form: typing.Literal[True] = ...) -> list[bytes]:
 #..

 #typing.overload
 #ef get_ca_certs(self, binary_form: bool = ...) -> typing.Any:
 #..

 #ef get_ca_certs(self, binary_form: bool = False) -> list[typing.Any] | list[bytes]:
 #aise NotImplementedError()

 #property
 #ef check_hostname(self) -> bool:
 #eturn self._ctx.check_hostname

 #check_hostname.setter
 #ef check_hostname(self, value: bool) -> None:
 #elf._ctx.check_hostname = value

 #property
 #ef hostname_checks_common_name(self) -> bool:
 #eturn self._ctx.hostname_checks_common_name

 #hostname_checks_common_name.setter
 #ef hostname_checks_common_name(self, value: bool) -> None:
 #elf._ctx.hostname_checks_common_name = value

 #property
 #ef keylog_filename(self) -> str:
 #eturn self._ctx.keylog_filename

 #keylog_filename.setter
 #ef keylog_filename(self, value: str) -> None:
 #elf._ctx.keylog_filename = value

 #property
 #ef maximum_version(self) -> ssl.TLSVersion:
 #eturn self._ctx.maximum_version

 #maximum_version.setter
 #ef maximum_version(self, value: ssl.TLSVersion) -> None:
 #original_super_SSLContext.maximum_version.__set__(  # type: ignore[attr-defined]
 #elf._ctx, value
 #

 #property
 #ef minimum_version(self) -> ssl.TLSVersion:
 #eturn self._ctx.minimum_version

 #minimum_version.setter
 #ef minimum_version(self, value: ssl.TLSVersion) -> None:
 #original_super_SSLContext.minimum_version.__set__(  # type: ignore[attr-defined]
 #elf._ctx, value
 #

 #property
 #ef options(self) -> ssl.Options:
 #eturn self._ctx.options

 #options.setter
 #ef options(self, value: ssl.Options) -> None:
 #original_super_SSLContext.options.__set__(  # type: ignore[attr-defined]
 #elf._ctx, value
 #

 #property
 #ef post_handshake_auth(self) -> bool:
 #eturn self._ctx.post_handshake_auth

 #post_handshake_auth.setter
 #ef post_handshake_auth(self, value: bool) -> None:
 #elf._ctx.post_handshake_auth = value

 #property
 #ef protocol(self) -> ssl._SSLMethod:
 #eturn self._ctx.protocol

 #property
 #ef security_level(self) -> int:
 #eturn self._ctx.security_level

 #property
 #ef verify_flags(self) -> ssl.VerifyFlags:
 #eturn self._ctx.verify_flags

 #verify_flags.setter
 #ef verify_flags(self, value: ssl.VerifyFlags) -> None:
 #original_super_SSLContext.verify_flags.__set__(  # type: ignore[attr-defined]
 #elf._ctx, value
 #

 #property
 #ef verify_mode(self) -> ssl.VerifyMode:
 #eturn self._ctx.verify_mode

 #verify_mode.setter
 #ef verify_mode(self, value: ssl.VerifyMode) -> None:
 #original_super_SSLContext.verify_mode.__set__(  # type: ignore[attr-defined]
 #elf._ctx, value
 #


def _verify_peercerts(
 #ock_or_sslobj: ssl.SSLSocket | ssl.SSLObject, server_hostname: str | None
) -> None:
 #""
 #erifies the peer certificates from an SSLSocket or SSLObject
 #gainst the certificates in the OS trust store.
 #""
 #slobj: ssl.SSLObject = sock_or_sslobj  # type: ignore[assignment]
 #ry:
 #hile not hasattr(sslobj, "get_unverified_chain"):
 #slobj = sslobj._sslobj  # type: ignore[attr-defined]
 #xcept AttributeError:
 #ass

    # SSLObject.get_unverified_chain() returns 'None'
    # if the peer sends no certificates. This is common
    # for the server-side scenario.
 #nverified_chain: typing.Sequence[_ssl.Certificate] = (
 #slobj.get_unverified_chain() or ()  # type: ignore[attr-defined]
 #
 #ert_bytes = [cert.public_bytes(_ssl.ENCODING_DER) for cert in unverified_chain]
 #verify_peercerts_impl(
 #ock_or_sslobj.context, cert_bytes, server_hostname=server_hostname
 #
