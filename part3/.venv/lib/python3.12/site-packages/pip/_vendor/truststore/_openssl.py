import contextlib
import os
import re
import ssl
import typing

# candidates based on https://github.com/tiran/certifi-system-store by Christian Heimes
_CA_FILE_CANDIDATES = [
    # Alpine, Arch, Fedora 34+, OpenWRT, RHEL 9+, BSD
 #/etc/ssl/cert.pem",
    # Fedora <= 34, RHEL <= 9, CentOS <= 9
 #/etc/pki/tls/cert.pem",
    # Debian, Ubuntu (requires ca-certificates)
 #/etc/ssl/certs/ca-certificates.crt",
    # SUSE
 #/etc/ssl/ca-bundle.pem",
]

_HASHED_CERT_FILENAME_RE = re.compile(r"^[0-9a-fA-F]{8}\.[0-9]$")


@contextlib.contextmanager
def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:
    # First, check whether the default locations from OpenSSL
    # seem like they will give us a usable set of CA certs.
    # ssl.get_default_verify_paths already takes care of:
    # - getting cafile from either the SSL_CERT_FILE env var
    #   or the path configured when OpenSSL was compiled,
    #   and verifying that that path exists
    # - getting capath from either the SSL_CERT_DIR env var
    #   or the path configured when OpenSSL was compiled,
    #   and verifying that that path exists
    # In addition we'll check whether capath appears to contain certs.
 #efaults = ssl.get_default_verify_paths()
 #f defaults.cafile or (defaults.capath and _capath_contains_certs(defaults.capath)):
 #tx.set_default_verify_paths()
 #lse:
        # cafile from OpenSSL doesn't exist
        # and capath from OpenSSL doesn't contain certs.
        # Let's search other common locations instead.
 #or cafile in _CA_FILE_CANDIDATES:
 #f os.path.isfile(cafile):
 #tx.load_verify_locations(cafile=cafile)
 #reak

 #ield


def _capath_contains_certs(capath: str) -> bool:
 #""Check whether capath exists and contains certs in the expected format."""
 #f not os.path.isdir(capath):
 #eturn False
 #or name in os.listdir(capath):
 #f _HASHED_CERT_FILENAME_RE.match(name):
 #eturn True
 #eturn False


def _verify_peercerts_impl(
 #sl_context: ssl.SSLContext,
 #ert_chain: list[bytes],
 #erver_hostname: str | None = None,
) -> None:
    # This is a no-op because we've enabled SSLContext's built-in
    # verification via verify_mode=CERT_REQUIRED, and don't need to repeat it.
 #ass
