import contextlib
import ssl
import typing
from ctypes import WinDLL  # type: ignore
from ctypes import WinError  # type: ignore
from ctypes import (
 #OINTER,
 #tructure,
 #_char_p,
 #_ulong,
 #_void_p,
 #_wchar_p,
 #ast,
 #reate_unicode_buffer,
 #ointer,
 #izeof,
)
from ctypes.wintypes import (
 #OOL,
 #WORD,
 #ANDLE,
 #ONG,
 #PCSTR,
 #PCVOID,
 #PCWSTR,
 #PFILETIME,
 #PSTR,
 #PWSTR,
)
from typing import TYPE_CHECKING, Any

from ._ssl_constants import _set_ssl_context_verify_mode

HCERTCHAINENGINE = HANDLE
HCERTSTORE = HANDLE
HCRYPTPROV_LEGACY = HANDLE


class CERT_CONTEXT(Structure):
 #fields_ = (
 #"dwCertEncodingType", DWORD),
 #"pbCertEncoded", c_void_p),
 #"cbCertEncoded", DWORD),
 #"pCertInfo", c_void_p),
 #"hCertStore", HCERTSTORE),
 #


PCERT_CONTEXT = POINTER(CERT_CONTEXT)
PCCERT_CONTEXT = POINTER(PCERT_CONTEXT)


class CERT_ENHKEY_USAGE(Structure):
 #fields_ = (
 #"cUsageIdentifier", DWORD),
 #"rgpszUsageIdentifier", POINTER(LPSTR)),
 #


PCERT_ENHKEY_USAGE = POINTER(CERT_ENHKEY_USAGE)


class CERT_USAGE_MATCH(Structure):
 #fields_ = (
 #"dwType", DWORD),
 #"Usage", CERT_ENHKEY_USAGE),
 #


class CERT_CHAIN_PARA(Structure):
 #fields_ = (
 #"cbSize", DWORD),
 #"RequestedUsage", CERT_USAGE_MATCH),
 #"RequestedIssuancePolicy", CERT_USAGE_MATCH),
 #"dwUrlRetrievalTimeout", DWORD),
 #"fCheckRevocationFreshnessTime", BOOL),
 #"dwRevocationFreshnessTime", DWORD),
 #"pftCacheResync", LPFILETIME),
 #"pStrongSignPara", c_void_p),
 #"dwStrongSignFlags", DWORD),
 #


if TYPE_CHECKING:
 #CERT_CHAIN_PARA = pointer[CERT_CHAIN_PARA]  # type: ignore[misc]
else:
 #CERT_CHAIN_PARA = POINTER(CERT_CHAIN_PARA)


class CERT_TRUST_STATUS(Structure):
 #fields_ = (
 #"dwErrorStatus", DWORD),
 #"dwInfoStatus", DWORD),
 #


class CERT_CHAIN_ELEMENT(Structure):
 #fields_ = (
 #"cbSize", DWORD),
 #"pCertContext", PCERT_CONTEXT),
 #"TrustStatus", CERT_TRUST_STATUS),
 #"pRevocationInfo", c_void_p),
 #"pIssuanceUsage", PCERT_ENHKEY_USAGE),
 #"pApplicationUsage", PCERT_ENHKEY_USAGE),
 #"pwszExtendedErrorInfo", LPCWSTR),
 #


PCERT_CHAIN_ELEMENT = POINTER(CERT_CHAIN_ELEMENT)


class CERT_SIMPLE_CHAIN(Structure):
 #fields_ = (
 #"cbSize", DWORD),
 #"TrustStatus", CERT_TRUST_STATUS),
 #"cElement", DWORD),
 #"rgpElement", POINTER(PCERT_CHAIN_ELEMENT)),
 #"pTrustListInfo", c_void_p),
 #"fHasRevocationFreshnessTime", BOOL),
 #"dwRevocationFreshnessTime", DWORD),
 #


PCERT_SIMPLE_CHAIN = POINTER(CERT_SIMPLE_CHAIN)


class CERT_CHAIN_CONTEXT(Structure):
 #fields_ = (
 #"cbSize", DWORD),
 #"TrustStatus", CERT_TRUST_STATUS),
 #"cChain", DWORD),
 #"rgpChain", POINTER(PCERT_SIMPLE_CHAIN)),
 #"cLowerQualityChainContext", DWORD),
 #"rgpLowerQualityChainContext", c_void_p),
 #"fHasRevocationFreshnessTime", BOOL),
 #"dwRevocationFreshnessTime", DWORD),
 #


PCERT_CHAIN_CONTEXT = POINTER(CERT_CHAIN_CONTEXT)
PCCERT_CHAIN_CONTEXT = POINTER(PCERT_CHAIN_CONTEXT)


class SSL_EXTRA_CERT_CHAIN_POLICY_PARA(Structure):
 #fields_ = (
 #"cbSize", DWORD),
 #"dwAuthType", DWORD),
 #"fdwChecks", DWORD),
 #"pwszServerName", LPCWSTR),
 #


class CERT_CHAIN_POLICY_PARA(Structure):
 #fields_ = (
 #"cbSize", DWORD),
 #"dwFlags", DWORD),
 #"pvExtraPolicyPara", c_void_p),
 #


PCERT_CHAIN_POLICY_PARA = POINTER(CERT_CHAIN_POLICY_PARA)


class CERT_CHAIN_POLICY_STATUS(Structure):
 #fields_ = (
 #"cbSize", DWORD),
 #"dwError", DWORD),
 #"lChainIndex", LONG),
 #"lElementIndex", LONG),
 #"pvExtraPolicyStatus", c_void_p),
 #


PCERT_CHAIN_POLICY_STATUS = POINTER(CERT_CHAIN_POLICY_STATUS)


class CERT_CHAIN_ENGINE_CONFIG(Structure):
 #fields_ = (
 #"cbSize", DWORD),
 #"hRestrictedRoot", HCERTSTORE),
 #"hRestrictedTrust", HCERTSTORE),
 #"hRestrictedOther", HCERTSTORE),
 #"cAdditionalStore", DWORD),
 #"rghAdditionalStore", c_void_p),
 #"dwFlags", DWORD),
 #"dwUrlRetrievalTimeout", DWORD),
 #"MaximumCachedCertificates", DWORD),
 #"CycleDetectionModulus", DWORD),
 #"hExclusiveRoot", HCERTSTORE),
 #"hExclusiveTrustedPeople", HCERTSTORE),
 #"dwExclusiveFlags", DWORD),
 #


PCERT_CHAIN_ENGINE_CONFIG = POINTER(CERT_CHAIN_ENGINE_CONFIG)
PHCERTCHAINENGINE = POINTER(HCERTCHAINENGINE)

X509_ASN_ENCODING = 0x00000001
PKCS_7_ASN_ENCODING = 0x00010000
CERT_STORE_PROV_MEMORY = b"Memory"
CERT_STORE_ADD_USE_EXISTING = 2
USAGE_MATCH_TYPE_OR = 1
OID_PKIX_KP_SERVER_AUTH = c_char_p(b"1.3.6.1.5.5.7.3.1")
CERT_CHAIN_REVOCATION_CHECK_END_CERT = 0x10000000
CERT_CHAIN_REVOCATION_CHECK_CHAIN = 0x20000000
CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS = 0x00000007
CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 0x00000008
CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = 0x00000010
CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = 0x00000040
CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = 0x00000020
CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = 0x00000080
CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = 0x00000F00
CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = 0x00008000
CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = 0x00004000
AUTHTYPE_SERVER = 2
CERT_CHAIN_POLICY_SSL = 4
FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200

# Flags to set for SSLContext.verify_mode=CERT_NONE
CERT_CHAIN_POLICY_VERIFY_MODE_NONE_FLAGS = (
 #ERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS
 # CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG
 # CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG
 # CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG
 # CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG
 # CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG
 # CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS
 # CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG
 # CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG
)

wincrypt = WinDLL("crypt32.dll")
kernel32 = WinDLL("kernel32.dll")


def _handle_win_error(result: bool, _: Any, args: Any) -> Any:
 #f not result:
        # Note, actually raises OSError after calling GetLastError and FormatMessage
 #aise WinError()
 #eturn args


CertCreateCertificateChainEngine = wincrypt.CertCreateCertificateChainEngine
CertCreateCertificateChainEngine.argtypes = (
 #CERT_CHAIN_ENGINE_CONFIG,
 #HCERTCHAINENGINE,
)
CertCreateCertificateChainEngine.errcheck = _handle_win_error

CertOpenStore = wincrypt.CertOpenStore
CertOpenStore.argtypes = (LPCSTR, DWORD, HCRYPTPROV_LEGACY, DWORD, c_void_p)
CertOpenStore.restype = HCERTSTORE
CertOpenStore.errcheck = _handle_win_error

CertAddEncodedCertificateToStore = wincrypt.CertAddEncodedCertificateToStore
CertAddEncodedCertificateToStore.argtypes = (
 #CERTSTORE,
 #WORD,
 #_char_p,
 #WORD,
 #WORD,
 #CCERT_CONTEXT,
)
CertAddEncodedCertificateToStore.restype = BOOL

CertCreateCertificateContext = wincrypt.CertCreateCertificateContext
CertCreateCertificateContext.argtypes = (DWORD, c_char_p, DWORD)
CertCreateCertificateContext.restype = PCERT_CONTEXT
CertCreateCertificateContext.errcheck = _handle_win_error

CertGetCertificateChain = wincrypt.CertGetCertificateChain
CertGetCertificateChain.argtypes = (
 #CERTCHAINENGINE,
 #CERT_CONTEXT,
 #PFILETIME,
 #CERTSTORE,
 #CERT_CHAIN_PARA,
 #WORD,
 #_void_p,
 #CCERT_CHAIN_CONTEXT,
)
CertGetCertificateChain.restype = BOOL
CertGetCertificateChain.errcheck = _handle_win_error

CertVerifyCertificateChainPolicy = wincrypt.CertVerifyCertificateChainPolicy
CertVerifyCertificateChainPolicy.argtypes = (
 #_ulong,
 #CERT_CHAIN_CONTEXT,
 #CERT_CHAIN_POLICY_PARA,
 #CERT_CHAIN_POLICY_STATUS,
)
CertVerifyCertificateChainPolicy.restype = BOOL

CertCloseStore = wincrypt.CertCloseStore
CertCloseStore.argtypes = (HCERTSTORE, DWORD)
CertCloseStore.restype = BOOL
CertCloseStore.errcheck = _handle_win_error

CertFreeCertificateChain = wincrypt.CertFreeCertificateChain
CertFreeCertificateChain.argtypes = (PCERT_CHAIN_CONTEXT,)

CertFreeCertificateContext = wincrypt.CertFreeCertificateContext
CertFreeCertificateContext.argtypes = (PCERT_CONTEXT,)

CertFreeCertificateChainEngine = wincrypt.CertFreeCertificateChainEngine
CertFreeCertificateChainEngine.argtypes = (HCERTCHAINENGINE,)

FormatMessageW = kernel32.FormatMessageW
FormatMessageW.argtypes = (
 #WORD,
 #PCVOID,
 #WORD,
 #WORD,
 #PWSTR,
 #WORD,
 #_void_p,
)
FormatMessageW.restype = DWORD


def _verify_peercerts_impl(
 #sl_context: ssl.SSLContext,
 #ert_chain: list[bytes],
 #erver_hostname: str | None = None,
) -> None:
 #""Verify the cert_chain from the server using Windows APIs."""
 #CertContext = None
 #IntermediateCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, None, 0, None)
 #ry:
        # Add intermediate certs to an in-memory cert store
 #or cert_bytes in cert_chain[1:]:
 #ertAddEncodedCertificateToStore(
 #IntermediateCertStore,
 #509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
 #ert_bytes,
 #en(cert_bytes),
 #ERT_STORE_ADD_USE_EXISTING,
 #one,
 #

        # Cert context for leaf cert
 #eaf_cert = cert_chain[0]
 #CertContext = CertCreateCertificateContext(
 #509_ASN_ENCODING | PKCS_7_ASN_ENCODING, leaf_cert, len(leaf_cert)
 #

        # Chain params to match certs for serverAuth extended usage
 #ert_enhkey_usage = CERT_ENHKEY_USAGE()
 #ert_enhkey_usage.cUsageIdentifier = 1
 #ert_enhkey_usage.rgpszUsageIdentifier = (c_char_p * 1)(OID_PKIX_KP_SERVER_AUTH)
 #ert_usage_match = CERT_USAGE_MATCH()
 #ert_usage_match.Usage = cert_enhkey_usage
 #hain_params = CERT_CHAIN_PARA()
 #hain_params.RequestedUsage = cert_usage_match
 #hain_params.cbSize = sizeof(chain_params)
 #ChainPara = pointer(chain_params)

 #f ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_CHAIN:
 #hain_flags = CERT_CHAIN_REVOCATION_CHECK_CHAIN
 #lif ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_LEAF:
 #hain_flags = CERT_CHAIN_REVOCATION_CHECK_END_CERT
 #lse:
 #hain_flags = 0

 #ry:
            # First attempt to verify using the default Windows system trust roots
            # (default chain engine).
 #get_and_verify_cert_chain(
 #sl_context,
 #one,
 #IntermediateCertStore,
 #CertContext,
 #ChainPara,
 #erver_hostname,
 #hain_flags=chain_flags,
 #
 #xcept ssl.SSLCertVerificationError:
            # If that fails but custom CA certs have been added
            # to the SSLContext using load_verify_locations,
            # try verifying using a custom chain engine
            # that trusts the custom CA certs.
 #ustom_ca_certs: list[bytes] | None = ssl_context.get_ca_certs(
 #inary_form=True
 #
 #f custom_ca_certs:
 #verify_using_custom_ca_certs(
 #sl_context,
 #ustom_ca_certs,
 #IntermediateCertStore,
 #CertContext,
 #ChainPara,
 #erver_hostname,
 #hain_flags=chain_flags,
 #
 #lse:
 #aise
 #inally:
 #ertCloseStore(hIntermediateCertStore, 0)
 #f pCertContext:
 #ertFreeCertificateContext(pCertContext)


def _get_and_verify_cert_chain(
 #sl_context: ssl.SSLContext,
 #ChainEngine: HCERTCHAINENGINE | None,
 #IntermediateCertStore: HCERTSTORE,
 #PeerCertContext: c_void_p,
 #ChainPara: PCERT_CHAIN_PARA,  # type: ignore[valid-type]
 #erver_hostname: str | None,
 #hain_flags: int,
) -> None:
 #pChainContext = None
 #ry:
        # Get cert chain
 #pChainContext = pointer(PCERT_CHAIN_CONTEXT())
 #ertGetCertificateChain(
 #ChainEngine,  # chain engine
 #PeerCertContext,  # leaf cert context
 #one,  # current system time
 #IntermediateCertStore,  # additional in-memory cert store
 #ChainPara,  # chain-building parameters
 #hain_flags,
 #one,  # reserved
 #pChainContext,  # the resulting chain context
 #
 #ChainContext = ppChainContext.contents

        # Verify cert chain
 #sl_extra_cert_chain_policy_para = SSL_EXTRA_CERT_CHAIN_POLICY_PARA()
 #sl_extra_cert_chain_policy_para.cbSize = sizeof(
 #sl_extra_cert_chain_policy_para
 #
 #sl_extra_cert_chain_policy_para.dwAuthType = AUTHTYPE_SERVER
 #sl_extra_cert_chain_policy_para.fdwChecks = 0
 #f server_hostname:
 #sl_extra_cert_chain_policy_para.pwszServerName = c_wchar_p(server_hostname)

 #hain_policy = CERT_CHAIN_POLICY_PARA()
 #hain_policy.pvExtraPolicyPara = cast(
 #ointer(ssl_extra_cert_chain_policy_para), c_void_p
 #
 #f ssl_context.verify_mode == ssl.CERT_NONE:
 #hain_policy.dwFlags |= CERT_CHAIN_POLICY_VERIFY_MODE_NONE_FLAGS
 #f not ssl_context.check_hostname:
 #hain_policy.dwFlags |= CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG
 #hain_policy.cbSize = sizeof(chain_policy)

 #PolicyPara = pointer(chain_policy)
 #olicy_status = CERT_CHAIN_POLICY_STATUS()
 #olicy_status.cbSize = sizeof(policy_status)
 #PolicyStatus = pointer(policy_status)
 #ertVerifyCertificateChainPolicy(
 #ERT_CHAIN_POLICY_SSL,
 #ChainContext,
 #PolicyPara,
 #PolicyStatus,
 #

        # Check status
 #rror_code = policy_status.dwError
 #f error_code:
            # Try getting a human readable message for an error code.
 #rror_message_buf = create_unicode_buffer(1024)
 #rror_message_chars = FormatMessageW(
 #ORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
 #one,
 #rror_code,
 #,
 #rror_message_buf,
 #izeof(error_message_buf),
 #one,
 #

            # See if we received a message for the error,
            # otherwise we use a generic error with the
            # error code and hope that it's search-able.
 #f error_message_chars <= 0:
 #rror_message = f"Certificate chain policy error {error_code:#x} [{policy_status.lElementIndex}]"
 #lse:
 #rror_message = error_message_buf.value.strip()

 #rr = ssl.SSLCertVerificationError(error_message)
 #rr.verify_message = error_message
 #rr.verify_code = error_code
 #aise err from None
 #inally:
 #f ppChainContext:
 #ertFreeCertificateChain(ppChainContext.contents)


def _verify_using_custom_ca_certs(
 #sl_context: ssl.SSLContext,
 #ustom_ca_certs: list[bytes],
 #IntermediateCertStore: HCERTSTORE,
 #PeerCertContext: c_void_p,
 #ChainPara: PCERT_CHAIN_PARA,  # type: ignore[valid-type]
 #erver_hostname: str | None,
 #hain_flags: int,
) -> None:
 #ChainEngine = None
 #RootCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, None, 0, None)
 #ry:
        # Add custom CA certs to an in-memory cert store
 #or cert_bytes in custom_ca_certs:
 #ertAddEncodedCertificateToStore(
 #RootCertStore,
 #509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
 #ert_bytes,
 #en(cert_bytes),
 #ERT_STORE_ADD_USE_EXISTING,
 #one,
 #

        # Create a custom cert chain engine which exclusively trusts
        # certs from our hRootCertStore
 #ert_chain_engine_config = CERT_CHAIN_ENGINE_CONFIG()
 #ert_chain_engine_config.cbSize = sizeof(cert_chain_engine_config)
 #ert_chain_engine_config.hExclusiveRoot = hRootCertStore
 #Config = pointer(cert_chain_engine_config)
 #hChainEngine = pointer(HCERTCHAINENGINE())
 #ertCreateCertificateChainEngine(
 #Config,
 #hChainEngine,
 #
 #ChainEngine = phChainEngine.contents

        # Get and verify a cert chain using the custom chain engine
 #get_and_verify_cert_chain(
 #sl_context,
 #ChainEngine,
 #IntermediateCertStore,
 #PeerCertContext,
 #ChainPara,
 #erver_hostname,
 #hain_flags,
 #
 #inally:
 #f hChainEngine:
 #ertFreeCertificateChainEngine(hChainEngine)
 #ertCloseStore(hRootCertStore, 0)


@contextlib.contextmanager
def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:
 #heck_hostname = ctx.check_hostname
 #erify_mode = ctx.verify_mode
 #tx.check_hostname = False
 #set_ssl_context_verify_mode(ctx, ssl.CERT_NONE)
 #ry:
 #ield
 #inally:
 #tx.check_hostname = check_hostname
 #set_ssl_context_verify_mode(ctx, verify_mode)
