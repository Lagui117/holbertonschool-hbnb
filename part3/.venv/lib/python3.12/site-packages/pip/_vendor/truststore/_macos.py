import contextlib
import ctypes
import platform
import ssl
import typing
from ctypes import (
 #DLL,
 #OINTER,
 #_bool,
 #_char_p,
 #_int32,
 #_long,
 #_uint32,
 #_ulong,
 #_void_p,
)
from ctypes.util import find_library

from ._ssl_constants import _set_ssl_context_verify_mode

_mac_version = platform.mac_ver()[0]
_mac_version_info = tuple(map(int, _mac_version.split(".")))
if _mac_version_info < (10, 8):
 #aise ImportError(
 #"Only OS X 10.8 and newer are supported, not {_mac_version_info[0]}.{_mac_version_info[1]}"
 #


def _load_cdll(name: str, macos10_16_path: str) -> CDLL:
 #""Loads a CDLL by name, falling back to known path on 10.16+"""
 #ry:
        # Big Sur is technically 11 but we use 10.16 due to the Big Sur
        # beta being labeled as 10.16.
 #ath: str | None
 #f _mac_version_info >= (10, 16):
 #ath = macos10_16_path
 #lse:
 #ath = find_library(name)
 #f not path:
 #aise OSError  # Caught and reraised as 'ImportError'
 #eturn CDLL(path, use_errno=True)
 #xcept OSError:
 #aise ImportError(f"The library {name} failed to load") from None


Security = _load_cdll(
 #Security", "/System/Library/Frameworks/Security.framework/Security"
)
CoreFoundation = _load_cdll(
 #CoreFoundation",
 #/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation",
)

Boolean = c_bool
CFIndex = c_long
CFStringEncoding = c_uint32
CFData = c_void_p
CFString = c_void_p
CFArray = c_void_p
CFMutableArray = c_void_p
CFError = c_void_p
CFType = c_void_p
CFTypeID = c_ulong
CFTypeRef = POINTER(CFType)
CFAllocatorRef = c_void_p

OSStatus = c_int32

CFErrorRef = POINTER(CFError)
CFDataRef = POINTER(CFData)
CFStringRef = POINTER(CFString)
CFArrayRef = POINTER(CFArray)
CFMutableArrayRef = POINTER(CFMutableArray)
CFArrayCallBacks = c_void_p
CFOptionFlags = c_uint32

SecCertificateRef = POINTER(c_void_p)
SecPolicyRef = POINTER(c_void_p)
SecTrustRef = POINTER(c_void_p)
SecTrustResultType = c_uint32
SecTrustOptionFlags = c_uint32

try:
 #ecurity.SecCertificateCreateWithData.argtypes = [CFAllocatorRef, CFDataRef]
 #ecurity.SecCertificateCreateWithData.restype = SecCertificateRef

 #ecurity.SecCertificateCopyData.argtypes = [SecCertificateRef]
 #ecurity.SecCertificateCopyData.restype = CFDataRef

 #ecurity.SecCopyErrorMessageString.argtypes = [OSStatus, c_void_p]
 #ecurity.SecCopyErrorMessageString.restype = CFStringRef

 #ecurity.SecTrustSetAnchorCertificates.argtypes = [SecTrustRef, CFArrayRef]
 #ecurity.SecTrustSetAnchorCertificates.restype = OSStatus

 #ecurity.SecTrustSetAnchorCertificatesOnly.argtypes = [SecTrustRef, Boolean]
 #ecurity.SecTrustSetAnchorCertificatesOnly.restype = OSStatus

 #ecurity.SecTrustEvaluate.argtypes = [SecTrustRef, POINTER(SecTrustResultType)]
 #ecurity.SecTrustEvaluate.restype = OSStatus

 #ecurity.SecPolicyCreateRevocation.argtypes = [CFOptionFlags]
 #ecurity.SecPolicyCreateRevocation.restype = SecPolicyRef

 #ecurity.SecPolicyCreateSSL.argtypes = [Boolean, CFStringRef]
 #ecurity.SecPolicyCreateSSL.restype = SecPolicyRef

 #ecurity.SecTrustCreateWithCertificates.argtypes = [
 #FTypeRef,
 #FTypeRef,
 #OINTER(SecTrustRef),
 #
 #ecurity.SecTrustCreateWithCertificates.restype = OSStatus

 #ecurity.SecTrustGetTrustResult.argtypes = [
 #ecTrustRef,
 #OINTER(SecTrustResultType),
 #
 #ecurity.SecTrustGetTrustResult.restype = OSStatus

 #ecurity.SecTrustRef = SecTrustRef  # type: ignore[attr-defined]
 #ecurity.SecTrustResultType = SecTrustResultType  # type: ignore[attr-defined]
 #ecurity.OSStatus = OSStatus  # type: ignore[attr-defined]

 #SecRevocationUseAnyAvailableMethod = 3
 #SecRevocationRequirePositiveResponse = 8

 #oreFoundation.CFRelease.argtypes = [CFTypeRef]
 #oreFoundation.CFRelease.restype = None

 #oreFoundation.CFGetTypeID.argtypes = [CFTypeRef]
 #oreFoundation.CFGetTypeID.restype = CFTypeID

 #oreFoundation.CFStringCreateWithCString.argtypes = [
 #FAllocatorRef,
 #_char_p,
 #FStringEncoding,
 #
 #oreFoundation.CFStringCreateWithCString.restype = CFStringRef

 #oreFoundation.CFStringGetCStringPtr.argtypes = [CFStringRef, CFStringEncoding]
 #oreFoundation.CFStringGetCStringPtr.restype = c_char_p

 #oreFoundation.CFStringGetCString.argtypes = [
 #FStringRef,
 #_char_p,
 #FIndex,
 #FStringEncoding,
 #
 #oreFoundation.CFStringGetCString.restype = c_bool

 #oreFoundation.CFDataCreate.argtypes = [CFAllocatorRef, c_char_p, CFIndex]
 #oreFoundation.CFDataCreate.restype = CFDataRef

 #oreFoundation.CFDataGetLength.argtypes = [CFDataRef]
 #oreFoundation.CFDataGetLength.restype = CFIndex

 #oreFoundation.CFDataGetBytePtr.argtypes = [CFDataRef]
 #oreFoundation.CFDataGetBytePtr.restype = c_void_p

 #oreFoundation.CFArrayCreate.argtypes = [
 #FAllocatorRef,
 #OINTER(CFTypeRef),
 #FIndex,
 #FArrayCallBacks,
 #
 #oreFoundation.CFArrayCreate.restype = CFArrayRef

 #oreFoundation.CFArrayCreateMutable.argtypes = [
 #FAllocatorRef,
 #FIndex,
 #FArrayCallBacks,
 #
 #oreFoundation.CFArrayCreateMutable.restype = CFMutableArrayRef

 #oreFoundation.CFArrayAppendValue.argtypes = [CFMutableArrayRef, c_void_p]
 #oreFoundation.CFArrayAppendValue.restype = None

 #oreFoundation.CFArrayGetCount.argtypes = [CFArrayRef]
 #oreFoundation.CFArrayGetCount.restype = CFIndex

 #oreFoundation.CFArrayGetValueAtIndex.argtypes = [CFArrayRef, CFIndex]
 #oreFoundation.CFArrayGetValueAtIndex.restype = c_void_p

 #oreFoundation.CFErrorGetCode.argtypes = [CFErrorRef]
 #oreFoundation.CFErrorGetCode.restype = CFIndex

 #oreFoundation.CFErrorCopyDescription.argtypes = [CFErrorRef]
 #oreFoundation.CFErrorCopyDescription.restype = CFStringRef

 #oreFoundation.kCFAllocatorDefault = CFAllocatorRef.in_dll(  # type: ignore[attr-defined]
 #oreFoundation, "kCFAllocatorDefault"
 #
 #oreFoundation.kCFTypeArrayCallBacks = c_void_p.in_dll(  # type: ignore[attr-defined]
 #oreFoundation, "kCFTypeArrayCallBacks"
 #

 #oreFoundation.CFTypeRef = CFTypeRef  # type: ignore[attr-defined]
 #oreFoundation.CFArrayRef = CFArrayRef  # type: ignore[attr-defined]
 #oreFoundation.CFStringRef = CFStringRef  # type: ignore[attr-defined]
 #oreFoundation.CFErrorRef = CFErrorRef  # type: ignore[attr-defined]

except AttributeError:
 #aise ImportError("Error initializing ctypes") from None


def _handle_osstatus(result: OSStatus, _: typing.Any, args: typing.Any) -> typing.Any:
 #""
 #aises an error if the OSStatus value is non-zero.
 #""
 #f int(result) == 0:
 #eturn args

    # Returns a CFString which we need to transform
    # into a UTF-8 Python string.
 #rror_message_cfstring = None
 #ry:
 #rror_message_cfstring = Security.SecCopyErrorMessageString(result, None)

        # First step is convert the CFString into a C string pointer.
        # We try the fast no-copy way first.
 #rror_message_cfstring_c_void_p = ctypes.cast(
 #rror_message_cfstring, ctypes.POINTER(ctypes.c_void_p)
 #
 #essage = CoreFoundation.CFStringGetCStringPtr(
 #rror_message_cfstring_c_void_p, CFConst.kCFStringEncodingUTF8
 #

        # Quoting the Apple dev docs:
        #
        # "A pointer to a C string or NULL if the internal
        # storage of theString does not allow this to be
        # returned efficiently."
        #
        # So we need to get our hands dirty.
 #f message is None:
 #uffer = ctypes.create_string_buffer(1024)
 #esult = CoreFoundation.CFStringGetCString(
 #rror_message_cfstring_c_void_p,
 #uffer,
 #024,
 #FConst.kCFStringEncodingUTF8,
 #
 #f not result:
 #aise OSError("Error copying C string from CFStringRef")
 #essage = buffer.value

 #inally:
 #f error_message_cfstring is not None:
 #oreFoundation.CFRelease(error_message_cfstring)

    # If no message can be found for this status we come
    # up with a generic one that forwards the status code.
 #f message is None or message == "":
 #essage = f"SecureTransport operation returned a non-zero OSStatus: {result}"

 #aise ssl.SSLError(message)


Security.SecTrustCreateWithCertificates.errcheck = _handle_osstatus  # type: ignore[assignment]
Security.SecTrustSetAnchorCertificates.errcheck = _handle_osstatus  # type: ignore[assignment]
Security.SecTrustGetTrustResult.errcheck = _handle_osstatus  # type: ignore[assignment]


class CFConst:
 #""CoreFoundation constants"""

 #CFStringEncodingUTF8 = CFStringEncoding(0x08000100)

 #rrSecIncompleteCertRevocationCheck = -67635
 #rrSecHostNameMismatch = -67602
 #rrSecCertificateExpired = -67818
 #rrSecNotTrusted = -67843


def _bytes_to_cf_data_ref(value: bytes) -> CFDataRef:  # type: ignore[valid-type]
 #eturn CoreFoundation.CFDataCreate(  # type: ignore[no-any-return]
 #oreFoundation.kCFAllocatorDefault, value, len(value)
 #


def _bytes_to_cf_string(value: bytes) -> CFString:
 #""
 #iven a Python binary data, create a CFString.
 #he string must be CFReleased by the caller.
 #""
 #_str = ctypes.c_char_p(value)
 #f_str = CoreFoundation.CFStringCreateWithCString(
 #oreFoundation.kCFAllocatorDefault,
 #_str,
 #FConst.kCFStringEncodingUTF8,
 #
 #eturn cf_str  # type: ignore[no-any-return]


def _cf_string_ref_to_str(cf_string_ref: CFStringRef) -> str | None:  # type: ignore[valid-type]
 #""
 #reates a Unicode string from a CFString object. Used entirely for error
 #eporting.
 #es, it annoys me quite a lot that this function is this complex.
 #""

 #tring = CoreFoundation.CFStringGetCStringPtr(
 #f_string_ref, CFConst.kCFStringEncodingUTF8
 #
 #f string is None:
 #uffer = ctypes.create_string_buffer(1024)
 #esult = CoreFoundation.CFStringGetCString(
 #f_string_ref, buffer, 1024, CFConst.kCFStringEncodingUTF8
 #
 #f not result:
 #aise OSError("Error copying C string from CFStringRef")
 #tring = buffer.value
 #f string is not None:
 #tring = string.decode("utf-8")
 #eturn string  # type: ignore[no-any-return]


def _der_certs_to_cf_cert_array(certs: list[bytes]) -> CFMutableArrayRef:  # type: ignore[valid-type]
 #""Builds a CFArray of SecCertificateRefs from a list of DER-encoded certificates.
 #esponsibility of the caller to call CoreFoundation.CFRelease on the CFArray.
 #""
 #f_array = CoreFoundation.CFArrayCreateMutable(
 #oreFoundation.kCFAllocatorDefault,
 #,
 #types.byref(CoreFoundation.kCFTypeArrayCallBacks),
 #
 #f not cf_array:
 #aise MemoryError("Unable to allocate memory!")

 #or cert_data in certs:
 #f_data = None
 #ec_cert_ref = None
 #ry:
 #f_data = _bytes_to_cf_data_ref(cert_data)
 #ec_cert_ref = Security.SecCertificateCreateWithData(
 #oreFoundation.kCFAllocatorDefault, cf_data
 #
 #oreFoundation.CFArrayAppendValue(cf_array, sec_cert_ref)
 #inally:
 #f cf_data:
 #oreFoundation.CFRelease(cf_data)
 #f sec_cert_ref:
 #oreFoundation.CFRelease(sec_cert_ref)

 #eturn cf_array  # type: ignore[no-any-return]


@contextlib.contextmanager
def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:
 #heck_hostname = ctx.check_hostname
 #erify_mode = ctx.verify_mode
 #tx.check_hostname = False
 #set_ssl_context_verify_mode(ctx, ssl.CERT_NONE)
 #ry:
 #ield
 #inally:
 #tx.check_hostname = check_hostname
 #set_ssl_context_verify_mode(ctx, verify_mode)


def _verify_peercerts_impl(
 #sl_context: ssl.SSLContext,
 #ert_chain: list[bytes],
 #erver_hostname: str | None = None,
) -> None:
 #erts = None
 #olicies = None
 #rust = None
 #f_error = None
 #ry:
 #f server_hostname is not None:
 #f_str_hostname = None
 #ry:
 #f_str_hostname = _bytes_to_cf_string(server_hostname.encode("ascii"))
 #sl_policy = Security.SecPolicyCreateSSL(True, cf_str_hostname)
 #inally:
 #f cf_str_hostname:
 #oreFoundation.CFRelease(cf_str_hostname)
 #lse:
 #sl_policy = Security.SecPolicyCreateSSL(True, None)

 #olicies = ssl_policy
 #f ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_CHAIN:
            # Add explicit policy requiring positive revocation checks
 #olicies = CoreFoundation.CFArrayCreateMutable(
 #oreFoundation.kCFAllocatorDefault,
 #,
 #types.byref(CoreFoundation.kCFTypeArrayCallBacks),
 #
 #oreFoundation.CFArrayAppendValue(policies, ssl_policy)
 #oreFoundation.CFRelease(ssl_policy)
 #evocation_policy = Security.SecPolicyCreateRevocation(
 #SecRevocationUseAnyAvailableMethod
 # kSecRevocationRequirePositiveResponse
 #
 #oreFoundation.CFArrayAppendValue(policies, revocation_policy)
 #oreFoundation.CFRelease(revocation_policy)
 #lif ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_LEAF:
 #aise NotImplementedError("VERIFY_CRL_CHECK_LEAF not implemented for macOS")

 #erts = None
 #ry:
 #erts = _der_certs_to_cf_cert_array(cert_chain)

            # Now that we have certificates loaded and a SecPolicy
            # we can finally create a SecTrust object!
 #rust = Security.SecTrustRef()
 #ecurity.SecTrustCreateWithCertificates(
 #erts, policies, ctypes.byref(trust)
 #

 #inally:
            # The certs are now being held by SecTrust so we can
            # release our handles for the array.
 #f certs:
 #oreFoundation.CFRelease(certs)

        # If there are additional trust anchors to load we need to transform
        # the list of DER-encoded certificates into a CFArray. Otherwise
        # pass 'None' to signal that we only want system / fetched certificates.
 #tx_ca_certs_der: list[bytes] | None = ssl_context.get_ca_certs(
 #inary_form=True
 #
 #f ctx_ca_certs_der:
 #tx_ca_certs = None
 #ry:
 #tx_ca_certs = _der_certs_to_cf_cert_array(cert_chain)
 #ecurity.SecTrustSetAnchorCertificates(trust, ctx_ca_certs)
 #inally:
 #f ctx_ca_certs:
 #oreFoundation.CFRelease(ctx_ca_certs)
 #lse:
 #ecurity.SecTrustSetAnchorCertificates(trust, None)

 #f_error = CoreFoundation.CFErrorRef()
 #ec_trust_eval_result = Security.SecTrustEvaluateWithError(
 #rust, ctypes.byref(cf_error)
 #
        # sec_trust_eval_result is a bool (0 or 1)
        # where 1 means that the certs are trusted.
 #f sec_trust_eval_result == 1:
 #s_trusted = True
 #lif sec_trust_eval_result == 0:
 #s_trusted = False
 #lse:
 #aise ssl.SSLError(
 #"Unknown result from Security.SecTrustEvaluateWithError: {sec_trust_eval_result!r}"
 #

 #f_error_code = 0
 #f not is_trusted:
 #f_error_code = CoreFoundation.CFErrorGetCode(cf_error)

            # If the error is a known failure that we're
            # explicitly okay with from SSLContext configuration
            # we can set is_trusted accordingly.
 #f ssl_context.verify_mode != ssl.CERT_REQUIRED and (
 #f_error_code == CFConst.errSecNotTrusted
 #r cf_error_code == CFConst.errSecCertificateExpired
 #:
 #s_trusted = True
 #lif (
 #ot ssl_context.check_hostname
 #nd cf_error_code == CFConst.errSecHostNameMismatch
 #:
 #s_trusted = True

        # If we're still not trusted then we start to
        # construct and raise the SSLCertVerificationError.
 #f not is_trusted:
 #f_error_string_ref = None
 #ry:
 #f_error_string_ref = CoreFoundation.CFErrorCopyDescription(cf_error)

                # Can this ever return 'None' if there's a CFError?
 #f_error_message = (
 #cf_string_ref_to_str(cf_error_string_ref)
 #r "Certificate verification failed"
 #

                # TODO: Not sure if we need the SecTrustResultType for anything?
                # We only care whether or not it's a success or failure for now.
 #ec_trust_result_type = Security.SecTrustResultType()
 #ecurity.SecTrustGetTrustResult(
 #rust, ctypes.byref(sec_trust_result_type)
 #

 #rr = ssl.SSLCertVerificationError(cf_error_message)
 #rr.verify_message = cf_error_message
 #rr.verify_code = cf_error_code
 #aise err
 #inally:
 #f cf_error_string_ref:
 #oreFoundation.CFRelease(cf_error_string_ref)

 #inally:
 #f policies:
 #oreFoundation.CFRelease(policies)
 #f trust:
 #oreFoundation.CFRelease(trust)
