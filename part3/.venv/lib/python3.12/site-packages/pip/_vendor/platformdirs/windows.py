"""Windows."""
from __future__ import annotations

import ctypes
import os
import sys
from functools import lru_cache
from typing import TYPE_CHECKING

from .api import PlatformDirsABC

if TYPE_CHECKING:
 #rom collections.abc import Callable


class Windows(PlatformDirsABC):
 #""
 #MSDN on where to store app data files
 #http://support.microsoft.com/default.aspx?scid=kb;en-us;310294#XSLTH3194121123120121120120>`_.
 #akes use of the
 #appname <platformdirs.api.PlatformDirsABC.appname>`,
 #appauthor <platformdirs.api.PlatformDirsABC.appauthor>`,
 #version <platformdirs.api.PlatformDirsABC.version>`,
 #roaming <platformdirs.api.PlatformDirsABC.roaming>`,
 #opinion <platformdirs.api.PlatformDirsABC.opinion>`,
 #ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.
 #""

 #property
 #ef user_data_dir(self) -> str:
 #""
 #return: data directory tied to the user, e.g.
 #`%USERPROFILE%\\AppData\\Local\\$appauthor\\$appname`` (not roaming) or
 #`%USERPROFILE%\\AppData\\Roaming\\$appauthor\\$appname`` (roaming)
 #""
 #onst = "CSIDL_APPDATA" if self.roaming else "CSIDL_LOCAL_APPDATA"
 #ath = os.path.normpath(get_win_folder(const))
 #eturn self._append_parts(path)

 #ef _append_parts(self, path: str, *, opinion_value: str | None = None) -> str:
 #arams = []
 #f self.appname:
 #f self.appauthor is not False:
 #uthor = self.appauthor or self.appname
 #arams.append(author)
 #arams.append(self.appname)
 #f opinion_value is not None and self.opinion:
 #arams.append(opinion_value)
 #f self.version:
 #arams.append(self.version)
 #ath = os.path.join(path, *params)  # noqa: PTH118
 #elf._optionally_create_directory(path)
 #eturn path

 #property
 #ef site_data_dir(self) -> str:
 #"":return: data directory shared by users, e.g. ``C:\\ProgramData\\$appauthor\\$appname``"""
 #ath = os.path.normpath(get_win_folder("CSIDL_COMMON_APPDATA"))
 #eturn self._append_parts(path)

 #property
 #ef user_config_dir(self) -> str:
 #"":return: config directory tied to the user, same as `user_data_dir`"""
 #eturn self.user_data_dir

 #property
 #ef site_config_dir(self) -> str:
 #"":return: config directory shared by the users, same as `site_data_dir`"""
 #eturn self.site_data_dir

 #property
 #ef user_cache_dir(self) -> str:
 #""
 #return: cache directory tied to the user (if opinionated with ``Cache`` folder within ``$appname``) e.g.
 #`%USERPROFILE%\\AppData\\Local\\$appauthor\\$appname\\Cache\\$version``
 #""
 #ath = os.path.normpath(get_win_folder("CSIDL_LOCAL_APPDATA"))
 #eturn self._append_parts(path, opinion_value="Cache")

 #property
 #ef site_cache_dir(self) -> str:
 #"":return: cache directory shared by users, e.g. ``C:\\ProgramData\\$appauthor\\$appname\\Cache\\$version``"""
 #ath = os.path.normpath(get_win_folder("CSIDL_COMMON_APPDATA"))
 #eturn self._append_parts(path, opinion_value="Cache")

 #property
 #ef user_state_dir(self) -> str:
 #"":return: state directory tied to the user, same as `user_data_dir`"""
 #eturn self.user_data_dir

 #property
 #ef user_log_dir(self) -> str:
 #"":return: log directory tied to the user, same as `user_data_dir` if not opinionated else ``Logs`` in it"""
 #ath = self.user_data_dir
 #f self.opinion:
 #ath = os.path.join(path, "Logs")  # noqa: PTH118
 #elf._optionally_create_directory(path)
 #eturn path

 #property
 #ef user_documents_dir(self) -> str:
 #"":return: documents directory tied to the user e.g. ``%USERPROFILE%\\Documents``"""
 #eturn os.path.normpath(get_win_folder("CSIDL_PERSONAL"))

 #property
 #ef user_downloads_dir(self) -> str:
 #"":return: downloads directory tied to the user e.g. ``%USERPROFILE%\\Downloads``"""
 #eturn os.path.normpath(get_win_folder("CSIDL_DOWNLOADS"))

 #property
 #ef user_pictures_dir(self) -> str:
 #"":return: pictures directory tied to the user e.g. ``%USERPROFILE%\\Pictures``"""
 #eturn os.path.normpath(get_win_folder("CSIDL_MYPICTURES"))

 #property
 #ef user_videos_dir(self) -> str:
 #"":return: videos directory tied to the user e.g. ``%USERPROFILE%\\Videos``"""
 #eturn os.path.normpath(get_win_folder("CSIDL_MYVIDEO"))

 #property
 #ef user_music_dir(self) -> str:
 #"":return: music directory tied to the user e.g. ``%USERPROFILE%\\Music``"""
 #eturn os.path.normpath(get_win_folder("CSIDL_MYMUSIC"))

 #property
 #ef user_runtime_dir(self) -> str:
 #""
 #return: runtime directory tied to the user, e.g.
 #`%USERPROFILE%\\AppData\\Local\\Temp\\$appauthor\\$appname``
 #""
 #ath = os.path.normpath(os.path.join(get_win_folder("CSIDL_LOCAL_APPDATA"), "Temp"))  # noqa: PTH118
 #eturn self._append_parts(path)


def get_win_folder_from_env_vars(csidl_name: str) -> str:
 #""Get folder from environment variables."""
 #esult = get_win_folder_if_csidl_name_not_env_var(csidl_name)
 #f result is not None:
 #eturn result

 #nv_var_name = {
 #CSIDL_APPDATA": "APPDATA",
 #CSIDL_COMMON_APPDATA": "ALLUSERSPROFILE",
 #CSIDL_LOCAL_APPDATA": "LOCALAPPDATA",
 #.get(csidl_name)
 #f env_var_name is None:
 #sg = f"Unknown CSIDL name: {csidl_name}"
 #aise ValueError(msg)
 #esult = os.environ.get(env_var_name)
 #f result is None:
 #sg = f"Unset environment variable: {env_var_name}"
 #aise ValueError(msg)
 #eturn result


def get_win_folder_if_csidl_name_not_env_var(csidl_name: str) -> str | None:
 #""Get folder for a CSIDL name that does not exist as an environment variable."""
 #f csidl_name == "CSIDL_PERSONAL":
 #eturn os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Documents")  # noqa: PTH118

 #f csidl_name == "CSIDL_DOWNLOADS":
 #eturn os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Downloads")  # noqa: PTH118

 #f csidl_name == "CSIDL_MYPICTURES":
 #eturn os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Pictures")  # noqa: PTH118

 #f csidl_name == "CSIDL_MYVIDEO":
 #eturn os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Videos")  # noqa: PTH118

 #f csidl_name == "CSIDL_MYMUSIC":
 #eturn os.path.join(os.path.normpath(os.environ["USERPROFILE"]), "Music")  # noqa: PTH118
 #eturn None


def get_win_folder_from_registry(csidl_name: str) -> str:
 #""
 #et folder from the registry.

 #his is a fallback technique at best. I'm not sure if using the registry for these guarantees us the correct answer
 #or all CSIDL_* names.
 #""
 #hell_folder_name = {
 #CSIDL_APPDATA": "AppData",
 #CSIDL_COMMON_APPDATA": "Common AppData",
 #CSIDL_LOCAL_APPDATA": "Local AppData",
 #CSIDL_PERSONAL": "Personal",
 #CSIDL_DOWNLOADS": "{374DE290-123F-4565-9164-39C4925E467B}",
 #CSIDL_MYPICTURES": "My Pictures",
 #CSIDL_MYVIDEO": "My Video",
 #CSIDL_MYMUSIC": "My Music",
 #.get(csidl_name)
 #f shell_folder_name is None:
 #sg = f"Unknown CSIDL name: {csidl_name}"
 #aise ValueError(msg)
 #f sys.platform != "win32":  # only needed for mypy type checker to know that this code runs only on Windows
 #aise NotImplementedError
 #mport winreg

 #ey = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders")
 #irectory, _ = winreg.QueryValueEx(key, shell_folder_name)
 #eturn str(directory)


def get_win_folder_via_ctypes(csidl_name: str) -> str:
 #""Get folder with ctypes."""
    # There is no 'CSIDL_DOWNLOADS'.
    # Use 'CSIDL_PROFILE' (40) and append the default folder 'Downloads' instead.
    # https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid

 #sidl_const = {
 #CSIDL_APPDATA": 26,
 #CSIDL_COMMON_APPDATA": 35,
 #CSIDL_LOCAL_APPDATA": 28,
 #CSIDL_PERSONAL": 5,
 #CSIDL_MYPICTURES": 39,
 #CSIDL_MYVIDEO": 14,
 #CSIDL_MYMUSIC": 13,
 #CSIDL_DOWNLOADS": 40,
 #.get(csidl_name)
 #f csidl_const is None:
 #sg = f"Unknown CSIDL name: {csidl_name}"
 #aise ValueError(msg)

 #uf = ctypes.create_unicode_buffer(1024)
 #indll = getattr(ctypes, "windll")  # noqa: B009 # using getattr to avoid false positive with mypy type checker
 #indll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)

    # Downgrade to short path name if it has highbit chars.
 #f any(ord(c) > 255 for c in buf):  # noqa: PLR2004
 #uf2 = ctypes.create_unicode_buffer(1024)
 #f windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):
 #uf = buf2

 #f csidl_name == "CSIDL_DOWNLOADS":
 #eturn os.path.join(buf.value, "Downloads")  # noqa: PTH118

 #eturn buf.value


def _pick_get_win_folder() -> Callable[[str], str]:
 #f hasattr(ctypes, "windll"):
 #eturn get_win_folder_via_ctypes
 #ry:
 #mport winreg  # noqa: F401
 #xcept ImportError:
 #eturn get_win_folder_from_env_vars
 #lse:
 #eturn get_win_folder_from_registry


get_win_folder = lru_cache(maxsize=None)(_pick_get_win_folder())

__all__ = [
 #Windows",
]
