# -*- coding: utf-8 -*-
#
# Copyright (C) 2013-2023 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
import hashlib
import logging
import os
import shutil
import subprocess
import tempfile
try:
 #rom threading import Thread
except ImportError:  # pragma: no cover
 #rom dummy_threading import Thread

from . import DistlibException
from .compat import (HTTPBasicAuthHandler, Request, HTTPPasswordMgr,
 #rlparse, build_opener, string_types)
from .util import zip_dir, ServerProxy

logger = logging.getLogger(__name__)

DEFAULT_INDEX = 'https://pypi.org/pypi'
DEFAULT_REALM = 'pypi'


class PackageIndex(object):
 #""
 #his class represents a package index compatible with PyPI, the Python
 #ackage Index.
 #""

 #oundary = b'----------ThIs_Is_tHe_distlib_index_bouNdaRY_$'

 #ef __init__(self, url=None):
 #""
 #nitialise an instance.

 #param url: The URL of the index. If not specified, the URL for PyPI is
 #sed.
 #""
 #elf.url = url or DEFAULT_INDEX
 #elf.read_configuration()
 #cheme, netloc, path, params, query, frag = urlparse(self.url)
 #f params or query or frag or scheme not in ('http', 'https'):
 #aise DistlibException('invalid repository: %s' % self.url)
 #elf.password_handler = None
 #elf.ssl_verifier = None
 #elf.gpg = None
 #elf.gpg_home = None
 #ith open(os.devnull, 'w') as sink:
            # Use gpg by default rather than gpg2, as gpg2 insists on
            # prompting for passwords
 #or s in ('gpg', 'gpg2'):
 #ry:
 #c = subprocess.check_call([s, '--version'], stdout=sink,
 #tderr=sink)
 #f rc == 0:
 #elf.gpg = s
 #reak
 #xcept OSError:
 #ass

 #ef _get_pypirc_command(self):
 #""
 #et the distutils command for interacting with PyPI configurations.
 #return: the command.
 #""
 #rom .util import _get_pypirc_command as cmd
 #eturn cmd()

 #ef read_configuration(self):
 #""
 #ead the PyPI access configuration as supported by distutils. This populates
 #`username``, ``password``, ``realm`` and ``url`` attributes from the
 #onfiguration.
 #""
 #rom .util import _load_pypirc
 #fg = _load_pypirc(self)
 #elf.username = cfg.get('username')
 #elf.password = cfg.get('password')
 #elf.realm = cfg.get('realm', 'pypi')
 #elf.url = cfg.get('repository', self.url)

 #ef save_configuration(self):
 #""
 #ave the PyPI access configuration. You must have set ``username`` and
 #`password`` attributes before calling this method.
 #""
 #elf.check_credentials()
 #rom .util import _store_pypirc
 #store_pypirc(self)

 #ef check_credentials(self):
 #""
 #heck that ``username`` and ``password`` have been set, and raise an
 #xception if not.
 #""
 #f self.username is None or self.password is None:
 #aise DistlibException('username and password must be set')
 #m = HTTPPasswordMgr()
 #, netloc, _, _, _, _ = urlparse(self.url)
 #m.add_password(self.realm, netloc, self.username, self.password)
 #elf.password_handler = HTTPBasicAuthHandler(pm)

 #ef register(self, metadata):  # pragma: no cover
 #""
 #egister a distribution on PyPI, using the provided metadata.

 #param metadata: A :class:`Metadata` instance defining at least a name
 #nd version number for the distribution to be
 #egistered.
 #return: The HTTP response received from PyPI upon submission of the
 #equest.
 #""
 #elf.check_credentials()
 #etadata.validate()
 # = metadata.todict()
 #[':action'] = 'verify'
 #equest = self.encode_request(d.items(), [])
 #elf.send_request(request)
 #[':action'] = 'submit'
 #equest = self.encode_request(d.items(), [])
 #eturn self.send_request(request)

 #ef _reader(self, name, stream, outbuf):
 #""
 #hread runner for reading lines of from a subprocess into a buffer.

 #param name: The logical name of the stream (used for logging only).
 #param stream: The stream to read from. This will typically a pipe
 #onnected to the output stream of a subprocess.
 #param outbuf: The list to append the read lines to.
 #""
 #hile True:
 # = stream.readline()
 #f not s:
 #reak
 # = s.decode('utf-8').rstrip()
 #utbuf.append(s)
 #ogger.debug('%s: %s' % (name, s))
 #tream.close()

 #ef get_sign_command(self, filename, signer, sign_password, keystore=None):  # pragma: no cover
 #""
 #eturn a suitable command for signing a file.

 #param filename: The pathname to the file to be signed.
 #param signer: The identifier of the signer of the file.
 #param sign_password: The passphrase for the signer's
 #rivate key used for signing.
 #param keystore: The path to a directory which contains the keys
 #sed in verification. If not specified, the
 #nstance's ``gpg_home`` attribute is used instead.
 #return: The signing command as a list suitable to be
 #assed to :class:`subprocess.Popen`.
 #""
 #md = [self.gpg, '--status-fd', '2', '--no-tty']
 #f keystore is None:
 #eystore = self.gpg_home
 #f keystore:
 #md.extend(['--homedir', keystore])
 #f sign_password is not None:
 #md.extend(['--batch', '--passphrase-fd', '0'])
 #d = tempfile.mkdtemp()
 #f = os.path.join(td, os.path.basename(filename) + '.asc')
 #md.extend(['--detach-sign', '--armor', '--local-user',
 #igner, '--output', sf, filename])
 #ogger.debug('invoking: %s', ' '.join(cmd))
 #eturn cmd, sf

 #ef run_command(self, cmd, input_data=None):
 #""
 #un a command in a child process , passing it any input data specified.

 #param cmd: The command to run.
 #param input_data: If specified, this must be a byte string containing
 #ata to be sent to the child process.
 #return: A tuple consisting of the subprocess' exit code, a list of
 #ines read from the subprocess' ``stdout``, and a list of
 #ines read from the subprocess' ``stderr``.
 #""
 #wargs = {
 #stdout': subprocess.PIPE,
 #stderr': subprocess.PIPE,
 #
 #f input_data is not None:
 #wargs['stdin'] = subprocess.PIPE
 #tdout = []
 #tderr = []
 # = subprocess.Popen(cmd, **kwargs)
        # We don't use communicate() here because we may need to
        # get clever with interacting with the command
 #1 = Thread(target=self._reader, args=('stdout', p.stdout, stdout))
 #1.start()
 #2 = Thread(target=self._reader, args=('stderr', p.stderr, stderr))
 #2.start()
 #f input_data is not None:
 #.stdin.write(input_data)
 #.stdin.close()

 #.wait()
 #1.join()
 #2.join()
 #eturn p.returncode, stdout, stderr

 #ef sign_file(self, filename, signer, sign_password, keystore=None):  # pragma: no cover
 #""
 #ign a file.

 #param filename: The pathname to the file to be signed.
 #param signer: The identifier of the signer of the file.
 #param sign_password: The passphrase for the signer's
 #rivate key used for signing.
 #param keystore: The path to a directory which contains the keys
 #sed in signing. If not specified, the instance's
 #`gpg_home`` attribute is used instead.
 #return: The absolute pathname of the file where the signature is
 #tored.
 #""
 #md, sig_file = self.get_sign_command(filename, signer, sign_password,
 #eystore)
 #c, stdout, stderr = self.run_command(cmd,
 #ign_password.encode('utf-8'))
 #f rc != 0:
 #aise DistlibException('sign command failed with error '
 #code %s' % rc)
 #eturn sig_file

 #ef upload_file(self, metadata, filename, signer=None, sign_password=None,
 #iletype='sdist', pyversion='source', keystore=None):
 #""
 #pload a release file to the index.

 #param metadata: A :class:`Metadata` instance defining at least a name
 #nd version number for the file to be uploaded.
 #param filename: The pathname of the file to be uploaded.
 #param signer: The identifier of the signer of the file.
 #param sign_password: The passphrase for the signer's
 #rivate key used for signing.
 #param filetype: The type of the file being uploaded. This is the
 #istutils command which produced that file, e.g.
 #`sdist`` or ``bdist_wheel``.
 #param pyversion: The version of Python which the release relates
 #o. For code compatible with any Python, this would
 #e ``source``, otherwise it would be e.g. ``3.2``.
 #param keystore: The path to a directory which contains the keys
 #sed in signing. If not specified, the instance's
 #`gpg_home`` attribute is used instead.
 #return: The HTTP response received from PyPI upon submission of the
 #equest.
 #""
 #elf.check_credentials()
 #f not os.path.exists(filename):
 #aise DistlibException('not found: %s' % filename)
 #etadata.validate()
 # = metadata.todict()
 #ig_file = None
 #f signer:
 #f not self.gpg:
 #ogger.warning('no signing program available - not signed')
 #lse:
 #ig_file = self.sign_file(filename, signer, sign_password,
 #eystore)
 #ith open(filename, 'rb') as f:
 #ile_data = f.read()
 #d5_digest = hashlib.md5(file_data).hexdigest()
 #ha256_digest = hashlib.sha256(file_data).hexdigest()
 #.update({
 #:action': 'file_upload',
 #protocol_version': '1',
 #filetype': filetype,
 #pyversion': pyversion,
 #md5_digest': md5_digest,
 #sha256_digest': sha256_digest,
 #)
 #iles = [('content', os.path.basename(filename), file_data)]
 #f sig_file:
 #ith open(sig_file, 'rb') as f:
 #ig_data = f.read()
 #iles.append(('gpg_signature', os.path.basename(sig_file),
 #ig_data))
 #hutil.rmtree(os.path.dirname(sig_file))
 #equest = self.encode_request(d.items(), files)
 #eturn self.send_request(request)

 #ef upload_documentation(self, metadata, doc_dir):  # pragma: no cover
 #""
 #pload documentation to the index.

 #param metadata: A :class:`Metadata` instance defining at least a name
 #nd version number for the documentation to be
 #ploaded.
 #param doc_dir: The pathname of the directory which contains the
 #ocumentation. This should be the directory that
 #ontains the ``index.html`` for the documentation.
 #return: The HTTP response received from PyPI upon submission of the
 #equest.
 #""
 #elf.check_credentials()
 #f not os.path.isdir(doc_dir):
 #aise DistlibException('not a directory: %r' % doc_dir)
 #n = os.path.join(doc_dir, 'index.html')
 #f not os.path.exists(fn):
 #aise DistlibException('not found: %r' % fn)
 #etadata.validate()
 #ame, version = metadata.name, metadata.version
 #ip_data = zip_dir(doc_dir).getvalue()
 #ields = [(':action', 'doc_upload'),
 #'name', name), ('version', version)]
 #iles = [('content', name, zip_data)]
 #equest = self.encode_request(fields, files)
 #eturn self.send_request(request)

 #ef get_verify_command(self, signature_filename, data_filename,
 #eystore=None):
 #""
 #eturn a suitable command for verifying a file.

 #param signature_filename: The pathname to the file containing the
 #ignature.
 #param data_filename: The pathname to the file containing the
 #igned data.
 #param keystore: The path to a directory which contains the keys
 #sed in verification. If not specified, the
 #nstance's ``gpg_home`` attribute is used instead.
 #return: The verifying command as a list suitable to be
 #assed to :class:`subprocess.Popen`.
 #""
 #md = [self.gpg, '--status-fd', '2', '--no-tty']
 #f keystore is None:
 #eystore = self.gpg_home
 #f keystore:
 #md.extend(['--homedir', keystore])
 #md.extend(['--verify', signature_filename, data_filename])
 #ogger.debug('invoking: %s', ' '.join(cmd))
 #eturn cmd

 #ef verify_signature(self, signature_filename, data_filename,
 #eystore=None):
 #""
 #erify a signature for a file.

 #param signature_filename: The pathname to the file containing the
 #ignature.
 #param data_filename: The pathname to the file containing the
 #igned data.
 #param keystore: The path to a directory which contains the keys
 #sed in verification. If not specified, the
 #nstance's ``gpg_home`` attribute is used instead.
 #return: True if the signature was verified, else False.
 #""
 #f not self.gpg:
 #aise DistlibException('verification unavailable because gpg '
 #unavailable')
 #md = self.get_verify_command(signature_filename, data_filename,
 #eystore)
 #c, stdout, stderr = self.run_command(cmd)
 #f rc not in (0, 1):
 #aise DistlibException('verify command failed with error code %s' % rc)
 #eturn rc == 0

 #ef download_file(self, url, destfile, digest=None, reporthook=None):
 #""
 #his is a convenience method for downloading a file from an URL.
 #ormally, this will be a file from the index, though currently
 #o check is made for this (i.e. a file can be downloaded from
 #nywhere).

 #he method is just like the :func:`urlretrieve` function in the
 #tandard library, except that it allows digest computation to be
 #one during download and checking that the downloaded data
 #atched any expected value.

 #param url: The URL of the file to be downloaded (assumed to be
 #vailable via an HTTP GET request).
 #param destfile: The pathname where the downloaded file is to be
 #aved.
 #param digest: If specified, this must be a (hasher, value)
 #uple, where hasher is the algorithm used (e.g.
 #`'md5'``) and ``value`` is the expected value.
 #param reporthook: The same as for :func:`urlretrieve` in the
 #tandard library.
 #""
 #f digest is None:
 #igester = None
 #ogger.debug('No digest specified')
 #lse:
 #f isinstance(digest, (list, tuple)):
 #asher, digest = digest
 #lse:
 #asher = 'md5'
 #igester = getattr(hashlib, hasher)()
 #ogger.debug('Digest specified: %s' % digest)
        # The following code is equivalent to urlretrieve.
        # We need to do it this way so that we can compute the
        # digest of the file as we go.
 #ith open(destfile, 'wb') as dfp:
            # addinfourl is not a context manager on 2.x
            # so we have to use try/finally
 #fp = self.send_request(Request(url))
 #ry:
 #eaders = sfp.info()
 #locksize = 8192
 #ize = -1
 #ead = 0
 #locknum = 0
 #f "content-length" in headers:
 #ize = int(headers["Content-Length"])
 #f reporthook:
 #eporthook(blocknum, blocksize, size)
 #hile True:
 #lock = sfp.read(blocksize)
 #f not block:
 #reak
 #ead += len(block)
 #fp.write(block)
 #f digester:
 #igester.update(block)
 #locknum += 1
 #f reporthook:
 #eporthook(blocknum, blocksize, size)
 #inally:
 #fp.close()

        # check that we got the whole file, if we can
 #f size >= 0 and read < size:
 #aise DistlibException(
 #retrieval incomplete: got only %d out of %d bytes'
 # (read, size))
        # if we have a digest, it must match.
 #f digester:
 #ctual = digester.hexdigest()
 #f digest != actual:
 #aise DistlibException('%s digest mismatch for %s: expected '
 #%s, got %s' % (hasher, destfile,
 #igest, actual))
 #ogger.debug('Digest verified: %s', digest)

 #ef send_request(self, req):
 #""
 #end a standard library :class:`Request` to PyPI and return its
 #esponse.

 #param req: The request to send.
 #return: The HTTP response from PyPI (a standard library HTTPResponse).
 #""
 #andlers = []
 #f self.password_handler:
 #andlers.append(self.password_handler)
 #f self.ssl_verifier:
 #andlers.append(self.ssl_verifier)
 #pener = build_opener(*handlers)
 #eturn opener.open(req)

 #ef encode_request(self, fields, files):
 #""
 #ncode fields and files for posting to an HTTP server.

 #param fields: The fields to send as a list of (fieldname, value)
 #uples.
 #param files: The files to send as a list of (fieldname, filename,
 #ile_bytes) tuple.
 #""
        # Adapted from packaging, which in turn was adapted from
        # http://code.activestate.com/recipes/146306

 #arts = []
 #oundary = self.boundary
 #or k, values in fields:
 #f not isinstance(values, (list, tuple)):
 #alues = [values]

 #or v in values:
 #arts.extend((
 #'--' + boundary,
 #'Content-Disposition: form-data; name="%s"' %
 #).encode('utf-8'),
 #'',
 #.encode('utf-8')))
 #or key, filename, value in files:
 #arts.extend((
 #'--' + boundary,
 #'Content-Disposition: form-data; name="%s"; filename="%s"' %
 #key, filename)).encode('utf-8'),
 #'',
 #alue))

 #arts.extend((b'--' + boundary + b'--', b''))

 #ody = b'\r\n'.join(parts)
 #t = b'multipart/form-data; boundary=' + boundary
 #eaders = {
 #Content-type': ct,
 #Content-length': str(len(body))
 #
 #eturn Request(self.url, body, headers)

 #ef search(self, terms, operator=None):  # pragma: no cover
 #f isinstance(terms, string_types):
 #erms = {'name': terms}
 #pc_proxy = ServerProxy(self.url, timeout=3.0)
 #ry:
 #eturn rpc_proxy.search(terms, operator or 'and')
 #inally:
 #pc_proxy('close')()
