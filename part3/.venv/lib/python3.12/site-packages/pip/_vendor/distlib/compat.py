# -*- coding: utf-8 -*-
#
# Copyright (C) 2013-2017 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from __future__ import absolute_import

import os
import re
import shutil
import sys

try:
 #mport ssl
except ImportError:  # pragma: no cover
 #sl = None

if sys.version_info[0] < 3:  # pragma: no cover
 #rom StringIO import StringIO
 #tring_types = basestring,
 #ext_type = unicode
 #rom types import FileType as file_type
 #mport __builtin__ as builtins
 #mport ConfigParser as configparser
 #rom urlparse import urlparse, urlunparse, urljoin, urlsplit, urlunsplit
 #rom urllib import (urlretrieve, quote as _quote, unquote, url2pathname,
 #athname2url, ContentTooShortError, splittype)

 #ef quote(s):
 #f isinstance(s, unicode):
 # = s.encode('utf-8')
 #eturn _quote(s)

 #mport urllib2
 #rom urllib2 import (Request, urlopen, URLError, HTTPError,
 #TTPBasicAuthHandler, HTTPPasswordMgr, HTTPHandler,
 #TTPRedirectHandler, build_opener)
 #f ssl:
 #rom urllib2 import HTTPSHandler
 #mport httplib
 #mport xmlrpclib
 #mport Queue as queue
 #rom HTMLParser import HTMLParser
 #mport htmlentitydefs
 #aw_input = raw_input
 #rom itertools import ifilter as filter
 #rom itertools import ifilterfalse as filterfalse

    # Leaving this around for now, in case it needs resurrecting in some way
    # _userprog = None
    # def splituser(host):
    # """splituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'."""
    # global _userprog
    # if _userprog is None:
    # import re
    # _userprog = re.compile('^(.*)@(.*)$')

    # match = _userprog.match(host)
    # if match: return match.group(1, 2)
    # return None, host

else:  # pragma: no cover
 #rom io import StringIO
 #tring_types = str,
 #ext_type = str
 #rom io import TextIOWrapper as file_type
 #mport builtins
 #mport configparser
 #rom urllib.parse import (urlparse, urlunparse, urljoin, quote, unquote,
 #rlsplit, urlunsplit, splittype)
 #rom urllib.request import (urlopen, urlretrieve, Request, url2pathname,
 #athname2url, HTTPBasicAuthHandler,
 #TTPPasswordMgr, HTTPHandler,
 #TTPRedirectHandler, build_opener)
 #f ssl:
 #rom urllib.request import HTTPSHandler
 #rom urllib.error import HTTPError, URLError, ContentTooShortError
 #mport http.client as httplib
 #mport urllib.request as urllib2
 #mport xmlrpc.client as xmlrpclib
 #mport queue
 #rom html.parser import HTMLParser
 #mport html.entities as htmlentitydefs
 #aw_input = input
 #rom itertools import filterfalse
 #ilter = filter

try:
 #rom ssl import match_hostname, CertificateError
except ImportError:  # pragma: no cover

 #lass CertificateError(ValueError):
 #ass

 #ef _dnsname_match(dn, hostname, max_wildcards=1):
 #""Matching according to RFC 6125, section 6.4.3

 #ttp://tools.ietf.org/html/rfc6125#section-6.4.3
 #""
 #ats = []
 #f not dn:
 #eturn False

 #arts = dn.split('.')
 #eftmost, remainder = parts[0], parts[1:]

 #ildcards = leftmost.count('*')
 #f wildcards > max_wildcards:
            # Issue #17980: avoid denials of service by refusing more
            # than one wildcard per fragment.  A survey of established
            # policy among SSL implementations showed it to be a
            # reasonable choice.
 #aise CertificateError(
 #too many wildcards in certificate DNS name: " + repr(dn))

        # speed up common case w/o wildcards
 #f not wildcards:
 #eturn dn.lower() == hostname.lower()

        # RFC 6125, section 6.4.3, subitem 1.
        # The client SHOULD NOT attempt to match a presented identifier in which
        # the wildcard character comprises a label other than the left-most label.
 #f leftmost == '*':
            # When '*' is a fragment by itself, it matches a non-empty dotless
            # fragment.
 #ats.append('[^.]+')
 #lif leftmost.startswith('xn--') or hostname.startswith('xn--'):
            # RFC 6125, section 6.4.3, subitem 3.
            # The client SHOULD NOT attempt to match a presented identifier
            # where the wildcard character is embedded within an A-label or
            # U-label of an internationalized domain name.
 #ats.append(re.escape(leftmost))
 #lse:
            # Otherwise, '*' matches any dotless string, e.g. www*
 #ats.append(re.escape(leftmost).replace(r'\*', '[^.]*'))

        # add the remaining fragments, ignore any wildcards
 #or frag in remainder:
 #ats.append(re.escape(frag))

 #at = re.compile(r'\A' + r'\.'.join(pats) + r'\Z', re.IGNORECASE)
 #eturn pat.match(hostname)

 #ef match_hostname(cert, hostname):
 #""Verify that *cert* (in decoded format as returned by
 #SLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125
 #ules are followed, but IP addresses are not accepted for *hostname*.

 #ertificateError is raised on failure. On success, the function
 #eturns nothing.
 #""
 #f not cert:
 #aise ValueError("empty or no certificate, match_hostname needs a "
 #SSL socket or SSL context with either "
 #CERT_OPTIONAL or CERT_REQUIRED")
 #nsnames = []
 #an = cert.get('subjectAltName', ())
 #or key, value in san:
 #f key == 'DNS':
 #f _dnsname_match(value, hostname):
 #eturn
 #nsnames.append(value)
 #f not dnsnames:
            # The subject is only checked when there is no dNSName entry
            # in subjectAltName
 #or sub in cert.get('subject', ()):
 #or key, value in sub:
                    # XXX according to RFC 2818, the most specific Common Name
                    # must be used.
 #f key == 'commonName':
 #f _dnsname_match(value, hostname):
 #eturn
 #nsnames.append(value)
 #f len(dnsnames) > 1:
 #aise CertificateError("hostname %r "
 #doesn't match either of %s" %
 #hostname, ', '.join(map(repr, dnsnames))))
 #lif len(dnsnames) == 1:
 #aise CertificateError("hostname %r "
 #doesn't match %r" %
 #hostname, dnsnames[0]))
 #lse:
 #aise CertificateError("no appropriate commonName or "
 #subjectAltName fields were found")


try:
 #rom types import SimpleNamespace as Container
except ImportError:  # pragma: no cover

 #lass Container(object):
 #""
 # generic container for when multiple values need to be returned
 #""

 #ef __init__(self, **kwargs):
 #elf.__dict__.update(kwargs)


try:
 #rom shutil import which
except ImportError:  # pragma: no cover
    # Implementation from Python 3.3
 #ef which(cmd, mode=os.F_OK | os.X_OK, path=None):
 #""Given a command, mode, and a PATH string, return the path which
 #onforms to the given mode on the PATH, or None if there is no such
 #ile.

 #mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
 #f os.environ.get("PATH"), or can be overridden with a custom search
 #ath.

 #""

        # Check that a given file can be accessed with the correct mode.
        # Additionally check that `file` is not a directory, as on Windows
        # directories pass the os.access check.
 #ef _access_check(fn, mode):
 #eturn (os.path.exists(fn) and os.access(fn, mode)
 #nd not os.path.isdir(fn))

        # If we're given a path with a directory part, look it up directly rather
        # than referring to PATH directories. This includes checking relative to the
        # current directory, e.g. ./script
 #f os.path.dirname(cmd):
 #f _access_check(cmd, mode):
 #eturn cmd
 #eturn None

 #f path is None:
 #ath = os.environ.get("PATH", os.defpath)
 #f not path:
 #eturn None
 #ath = path.split(os.pathsep)

 #f sys.platform == "win32":
            # The current directory takes precedence on Windows.
 #f os.curdir not in path:
 #ath.insert(0, os.curdir)

            # PATHEXT is necessary to check on Windows.
 #athext = os.environ.get("PATHEXT", "").split(os.pathsep)
            # See if the given file matches any of the expected path extensions.
            # This will allow us to short circuit when given "python.exe".
            # If it does match, only test that one, otherwise we have to try
            # others.
 #f any(cmd.lower().endswith(ext.lower()) for ext in pathext):
 #iles = [cmd]
 #lse:
 #iles = [cmd + ext for ext in pathext]
 #lse:
            # On other platforms you don't have things like PATHEXT to tell you
            # what file suffixes are executable, so just pass on cmd as-is.
 #iles = [cmd]

 #een = set()
 #or dir in path:
 #ormdir = os.path.normcase(dir)
 #f normdir not in seen:
 #een.add(normdir)
 #or thefile in files:
 #ame = os.path.join(dir, thefile)
 #f _access_check(name, mode):
 #eturn name
 #eturn None


# ZipFile is a context manager in 2.7, but not in 2.6

from zipfile import ZipFile as BaseZipFile

if hasattr(BaseZipFile, '__enter__'):  # pragma: no cover
 #ipFile = BaseZipFile
else:  # pragma: no cover
 #rom zipfile import ZipExtFile as BaseZipExtFile

 #lass ZipExtFile(BaseZipExtFile):

 #ef __init__(self, base):
 #elf.__dict__.update(base.__dict__)

 #ef __enter__(self):
 #eturn self

 #ef __exit__(self, *exc_info):
 #elf.close()
            # return None, so if an exception occurred, it will propagate

 #lass ZipFile(BaseZipFile):

 #ef __enter__(self):
 #eturn self

 #ef __exit__(self, *exc_info):
 #elf.close()
            # return None, so if an exception occurred, it will propagate

 #ef open(self, *args, **kwargs):
 #ase = BaseZipFile.open(self, *args, **kwargs)
 #eturn ZipExtFile(base)


try:
 #rom platform import python_implementation
except ImportError:  # pragma: no cover

 #ef python_implementation():
 #""Return a string identifying the Python implementation."""
 #f 'PyPy' in sys.version:
 #eturn 'PyPy'
 #f os.name == 'java':
 #eturn 'Jython'
 #f sys.version.startswith('IronPython'):
 #eturn 'IronPython'
 #eturn 'CPython'


import sysconfig

try:
 #allable = callable
except NameError:  # pragma: no cover
 #rom collections.abc import Callable

 #ef callable(obj):
 #eturn isinstance(obj, Callable)


try:
 #sencode = os.fsencode
 #sdecode = os.fsdecode
except AttributeError:  # pragma: no cover
    # Issue #99: on some systems (e.g. containerised),
    # sys.getfilesystemencoding() returns None, and we need a real value,
    # so fall back to utf-8. From the CPython 2.7 docs relating to Unix and
    # sys.getfilesystemencoding(): the return value is "the userâ€™s preference
    # according to the result of nl_langinfo(CODESET), or None if the
    # nl_langinfo(CODESET) failed."
 #fsencoding = sys.getfilesystemencoding() or 'utf-8'
 #f _fsencoding == 'mbcs':
 #fserrors = 'strict'
 #lse:
 #fserrors = 'surrogateescape'

 #ef fsencode(filename):
 #f isinstance(filename, bytes):
 #eturn filename
 #lif isinstance(filename, text_type):
 #eturn filename.encode(_fsencoding, _fserrors)
 #lse:
 #aise TypeError("expect bytes or str, not %s" %
 #ype(filename).__name__)

 #ef fsdecode(filename):
 #f isinstance(filename, text_type):
 #eturn filename
 #lif isinstance(filename, bytes):
 #eturn filename.decode(_fsencoding, _fserrors)
 #lse:
 #aise TypeError("expect bytes or str, not %s" %
 #ype(filename).__name__)


try:
 #rom tokenize import detect_encoding
except ImportError:  # pragma: no cover
 #rom codecs import BOM_UTF8, lookup

 #ookie_re = re.compile(r"coding[:=]\s*([-\w.]+)")

 #ef _get_normal_name(orig_enc):
 #""Imitates get_normal_name in tokenizer.c."""
        # Only care about the first 12 characters.
 #nc = orig_enc[:12].lower().replace("_", "-")
 #f enc == "utf-8" or enc.startswith("utf-8-"):
 #eturn "utf-8"
 #f enc in ("latin-1", "iso-8859-1", "iso-latin-1") or \
 #nc.startswith(("latin-1-", "iso-8859-1-", "iso-latin-1-")):
 #eturn "iso-8859-1"
 #eturn orig_enc

 #ef detect_encoding(readline):
 #""
 #he detect_encoding() function is used to detect the encoding that should
 #e used to decode a Python source file.  It requires one argument, readline,
 #n the same way as the tokenize() generator.

 #t will call readline a maximum of twice, and return the encoding used
 #as a string) and a list of any lines (left as bytes) it has read in.

 #t detects the encoding from the presence of a utf-8 bom or an encoding
 #ookie as specified in pep-0263.  If both a bom and a cookie are present,
 #ut disagree, a SyntaxError will be raised.  If the encoding cookie is an
 #nvalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
 #utf-8-sig' is returned.

 #f no encoding is specified, then the default of 'utf-8' will be returned.
 #""
 #ry:
 #ilename = readline.__self__.name
 #xcept AttributeError:
 #ilename = None
 #om_found = False
 #ncoding = None
 #efault = 'utf-8'

 #ef read_or_stop():
 #ry:
 #eturn readline()
 #xcept StopIteration:
 #eturn b''

 #ef find_cookie(line):
 #ry:
                # Decode as UTF-8. Either the line is an encoding declaration,
                # in which case it should be pure ASCII, or it must be UTF-8
                # per default encoding.
 #ine_string = line.decode('utf-8')
 #xcept UnicodeDecodeError:
 #sg = "invalid or missing encoding declaration"
 #f filename is not None:
 #sg = '{} for {!r}'.format(msg, filename)
 #aise SyntaxError(msg)

 #atches = cookie_re.findall(line_string)
 #f not matches:
 #eturn None
 #ncoding = _get_normal_name(matches[0])
 #ry:
 #odec = lookup(encoding)
 #xcept LookupError:
                # This behaviour mimics the Python interpreter
 #f filename is None:
 #sg = "unknown encoding: " + encoding
 #lse:
 #sg = "unknown encoding for {!r}: {}".format(
 #ilename, encoding)
 #aise SyntaxError(msg)

 #f bom_found:
 #f codec.name != 'utf-8':
                    # This behaviour mimics the Python interpreter
 #f filename is None:
 #sg = 'encoding problem: utf-8'
 #lse:
 #sg = 'encoding problem for {!r}: utf-8'.format(
 #ilename)
 #aise SyntaxError(msg)
 #ncoding += '-sig'
 #eturn encoding

 #irst = read_or_stop()
 #f first.startswith(BOM_UTF8):
 #om_found = True
 #irst = first[3:]
 #efault = 'utf-8-sig'
 #f not first:
 #eturn default, []

 #ncoding = find_cookie(first)
 #f encoding:
 #eturn encoding, [first]

 #econd = read_or_stop()
 #f not second:
 #eturn default, [first]

 #ncoding = find_cookie(second)
 #f encoding:
 #eturn encoding, [first, second]

 #eturn default, [first, second]


# For converting & <-> &amp; etc.
try:
 #rom html import escape
except ImportError:
 #rom cgi import escape
if sys.version_info[:2] < (3, 4):
 #nescape = HTMLParser().unescape
else:
 #rom html import unescape

try:
 #rom collections import ChainMap
except ImportError:  # pragma: no cover
 #rom collections import MutableMapping

 #ry:
 #rom reprlib import recursive_repr as _recursive_repr
 #xcept ImportError:

 #ef _recursive_repr(fillvalue='...'):
 #''
 #ecorator to make a repr function return fillvalue for a recursive
 #all
 #''

 #ef decorating_function(user_function):
 #epr_running = set()

 #ef wrapper(self):
 #ey = id(self), get_ident()
 #f key in repr_running:
 #eturn fillvalue
 #epr_running.add(key)
 #ry:
 #esult = user_function(self)
 #inally:
 #epr_running.discard(key)
 #eturn result

                # Can't use functools.wraps() here because of bootstrap issues
 #rapper.__module__ = getattr(user_function, '__module__')
 #rapper.__doc__ = getattr(user_function, '__doc__')
 #rapper.__name__ = getattr(user_function, '__name__')
 #rapper.__annotations__ = getattr(user_function,
 #__annotations__', {})
 #eturn wrapper

 #eturn decorating_function

 #lass ChainMap(MutableMapping):
 #''
 # ChainMap groups multiple dicts (or other mappings) together
 #o create a single, updateable view.

 #he underlying mappings are stored in a list.  That list is public and can
 #ccessed or updated using the *maps* attribute.  There is no other state.

 #ookups search the underlying mappings successively until a key is found.
 #n contrast, writes, updates, and deletions only operate on the first
 #apping.
 #''

 #ef __init__(self, *maps):
 #''Initialize a ChainMap by setting *maps* to the given mappings.
 #f no mappings are provided, a single empty dictionary is used.

 #''
 #elf.maps = list(maps) or [{}]  # always at least one map

 #ef __missing__(self, key):
 #aise KeyError(key)

 #ef __getitem__(self, key):
 #or mapping in self.maps:
 #ry:
 #eturn mapping[
 #ey]  # can't use 'key in mapping' with defaultdict
 #xcept KeyError:
 #ass
 #eturn self.__missing__(
 #ey)  # support subclasses that define __missing__

 #ef get(self, key, default=None):
 #eturn self[key] if key in self else default

 #ef __len__(self):
 #eturn len(set().union(
 #self.maps))  # reuses stored hash values if possible

 #ef __iter__(self):
 #eturn iter(set().union(*self.maps))

 #ef __contains__(self, key):
 #eturn any(key in m for m in self.maps)

 #ef __bool__(self):
 #eturn any(self.maps)

 #_recursive_repr()
 #ef __repr__(self):
 #eturn '{0.__class__.__name__}({1})'.format(
 #elf, ', '.join(map(repr, self.maps)))

 #classmethod
 #ef fromkeys(cls, iterable, *args):
 #Create a ChainMap with a single dict created from the iterable.'
 #eturn cls(dict.fromkeys(iterable, *args))

 #ef copy(self):
 #New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]'
 #eturn self.__class__(self.maps[0].copy(), *self.maps[1:])

 #_copy__ = copy

 #ef new_child(self):  # like Django's Context.push()
 #New ChainMap with a new dict followed by all previous maps.'
 #eturn self.__class__({}, *self.maps)

 #property
 #ef parents(self):  # like Django's Context.pop()
 #New ChainMap from maps[1:].'
 #eturn self.__class__(*self.maps[1:])

 #ef __setitem__(self, key, value):
 #elf.maps[0][key] = value

 #ef __delitem__(self, key):
 #ry:
 #el self.maps[0][key]
 #xcept KeyError:
 #aise KeyError(
 #Key not found in the first mapping: {!r}'.format(key))

 #ef popitem(self):
 #Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.'
 #ry:
 #eturn self.maps[0].popitem()
 #xcept KeyError:
 #aise KeyError('No keys found in the first mapping.')

 #ef pop(self, key, *args):
 #Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].'
 #ry:
 #eturn self.maps[0].pop(key, *args)
 #xcept KeyError:
 #aise KeyError(
 #Key not found in the first mapping: {!r}'.format(key))

 #ef clear(self):
 #Clear maps[0], leaving maps[1:] intact.'
 #elf.maps[0].clear()


try:
 #rom importlib.util import cache_from_source  # Python >= 3.4
except ImportError:  # pragma: no cover

 #ef cache_from_source(path, debug_override=None):
 #ssert path.endswith('.py')
 #f debug_override is None:
 #ebug_override = __debug__
 #f debug_override:
 #uffix = 'c'
 #lse:
 #uffix = 'o'
 #eturn path + suffix


try:
 #rom collections import OrderedDict
except ImportError:  # pragma: no cover
    # {{{ http://code.activestate.com/recipes/576693/ (r9)
    # Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
    # Passes Python2.7's test suite and incorporates all the latest updates.
 #ry:
 #rom thread import get_ident as _get_ident
 #xcept ImportError:
 #rom dummy_thread import get_ident as _get_ident

 #ry:
 #rom _abcoll import KeysView, ValuesView, ItemsView
 #xcept ImportError:
 #ass

 #lass OrderedDict(dict):
 #Dictionary that remembers insertion order'

        # An inherited dict maps keys to values.
        # The inherited dict provides __getitem__, __len__, __contains__, and get.
        # The remaining methods are order-aware.
        # Big-O running times for all methods are the same as for regular dictionaries.

        # The internal self.__map dictionary maps keys to links in a doubly linked list.
        # The circular doubly linked list starts and ends with a sentinel element.
        # The sentinel element never gets deleted (this simplifies the algorithm).
        # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

 #ef __init__(self, *args, **kwds):
 #''Initialize an ordered dictionary.  Signature is the same as for
 #egular dictionaries, but keyword arguments are not recommended
 #ecause their insertion order is arbitrary.

 #''
 #f len(args) > 1:
 #aise TypeError('expected at most 1 arguments, got %d' %
 #en(args))
 #ry:
 #elf.__root
 #xcept AttributeError:
 #elf.__root = root = []  # sentinel node
 #oot[:] = [root, root, None]
 #elf.__map = {}
 #elf.__update(*args, **kwds)

 #ef __setitem__(self, key, value, dict_setitem=dict.__setitem__):
 #od.__setitem__(i, y) <==> od[i]=y'
            # Setting a new item creates a new link which goes at the end of the linked
            # list, and the inherited dictionary is updated with the new key/value pair.
 #f key not in self:
 #oot = self.__root
 #ast = root[0]
 #ast[1] = root[0] = self.__map[key] = [last, root, key]
 #ict_setitem(self, key, value)

 #ef __delitem__(self, key, dict_delitem=dict.__delitem__):
 #od.__delitem__(y) <==> del od[y]'
            # Deleting an existing item uses self.__map to find the link which is
            # then removed by updating the links in the predecessor and successor nodes.
 #ict_delitem(self, key)
 #ink_prev, link_next, key = self.__map.pop(key)
 #ink_prev[1] = link_next
 #ink_next[0] = link_prev

 #ef __iter__(self):
 #od.__iter__() <==> iter(od)'
 #oot = self.__root
 #urr = root[1]
 #hile curr is not root:
 #ield curr[2]
 #urr = curr[1]

 #ef __reversed__(self):
 #od.__reversed__() <==> reversed(od)'
 #oot = self.__root
 #urr = root[0]
 #hile curr is not root:
 #ield curr[2]
 #urr = curr[0]

 #ef clear(self):
 #od.clear() -> None.  Remove all items from od.'
 #ry:
 #or node in self.__map.itervalues():
 #el node[:]
 #oot = self.__root
 #oot[:] = [root, root, None]
 #elf.__map.clear()
 #xcept AttributeError:
 #ass
 #ict.clear(self)

 #ef popitem(self, last=True):
 #''od.popitem() -> (k, v), return and remove a (key, value) pair.
 #airs are returned in LIFO order if last is true or FIFO order if false.

 #''
 #f not self:
 #aise KeyError('dictionary is empty')
 #oot = self.__root
 #f last:
 #ink = root[0]
 #ink_prev = link[0]
 #ink_prev[1] = root
 #oot[0] = link_prev
 #lse:
 #ink = root[1]
 #ink_next = link[1]
 #oot[1] = link_next
 #ink_next[0] = root
 #ey = link[2]
 #el self.__map[key]
 #alue = dict.pop(self, key)
 #eturn key, value

        # -- the following methods do not depend on the internal structure --

 #ef keys(self):
 #od.keys() -> list of keys in od'
 #eturn list(self)

 #ef values(self):
 #od.values() -> list of values in od'
 #eturn [self[key] for key in self]

 #ef items(self):
 #od.items() -> list of (key, value) pairs in od'
 #eturn [(key, self[key]) for key in self]

 #ef iterkeys(self):
 #od.iterkeys() -> an iterator over the keys in od'
 #eturn iter(self)

 #ef itervalues(self):
 #od.itervalues -> an iterator over the values in od'
 #or k in self:
 #ield self[k]

 #ef iteritems(self):
 #od.iteritems -> an iterator over the (key, value) items in od'
 #or k in self:
 #ield (k, self[k])

 #ef update(*args, **kwds):
 #''od.update(E, **F) -> None.  Update od from dict/iterable E and F.

 #f E is a dict instance, does:           for k in E: od[k] = E[k]
 #f E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
 #r if E is an iterable of items, does:   for k, v in E: od[k] = v
 #n either case, this is followed by:     for k, v in F.items(): od[k] = v

 #''
 #f len(args) > 2:
 #aise TypeError('update() takes at most 2 positional '
 #arguments (%d given)' % (len(args), ))
 #lif not args:
 #aise TypeError('update() takes at least 1 argument (0 given)')
 #elf = args[0]
            # Make progressively weaker assumptions about "other"
 #ther = ()
 #f len(args) == 2:
 #ther = args[1]
 #f isinstance(other, dict):
 #or key in other:
 #elf[key] = other[key]
 #lif hasattr(other, 'keys'):
 #or key in other.keys():
 #elf[key] = other[key]
 #lse:
 #or key, value in other:
 #elf[key] = value
 #or key, value in kwds.items():
 #elf[key] = value

 #_update = update  # let subclasses override update without breaking __init__

 #_marker = object()

 #ef pop(self, key, default=__marker):
 #''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
 #f key is not found, d is returned if given, otherwise KeyError is raised.

 #''
 #f key in self:
 #esult = self[key]
 #el self[key]
 #eturn result
 #f default is self.__marker:
 #aise KeyError(key)
 #eturn default

 #ef setdefault(self, key, default=None):
 #od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
 #f key in self:
 #eturn self[key]
 #elf[key] = default
 #eturn default

 #ef __repr__(self, _repr_running=None):
 #od.__repr__() <==> repr(od)'
 #f not _repr_running:
 #repr_running = {}
 #all_key = id(self), _get_ident()
 #f call_key in _repr_running:
 #eturn '...'
 #repr_running[call_key] = 1
 #ry:
 #f not self:
 #eturn '%s()' % (self.__class__.__name__, )
 #eturn '%s(%r)' % (self.__class__.__name__, self.items())
 #inally:
 #el _repr_running[call_key]

 #ef __reduce__(self):
 #Return state information for pickling'
 #tems = [[k, self[k]] for k in self]
 #nst_dict = vars(self).copy()
 #or k in vars(OrderedDict()):
 #nst_dict.pop(k, None)
 #f inst_dict:
 #eturn (self.__class__, (items, ), inst_dict)
 #eturn self.__class__, (items, )

 #ef copy(self):
 #od.copy() -> a shallow copy of od'
 #eturn self.__class__(self)

 #classmethod
 #ef fromkeys(cls, iterable, value=None):
 #''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
 #nd values equal to v (which defaults to None).

 #''
 # = cls()
 #or key in iterable:
 #[key] = value
 #eturn d

 #ef __eq__(self, other):
 #''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
 #hile comparison to a regular mapping is order-insensitive.

 #''
 #f isinstance(other, OrderedDict):
 #eturn len(self) == len(
 #ther) and self.items() == other.items()
 #eturn dict.__eq__(self, other)

 #ef __ne__(self, other):
 #eturn not self == other

        # -- the following methods are only used in Python 2.7 --

 #ef viewkeys(self):
 #od.viewkeys() -> a set-like object providing a view on od's keys"
 #eturn KeysView(self)

 #ef viewvalues(self):
 #od.viewvalues() -> an object providing a view on od's values"
 #eturn ValuesView(self)

 #ef viewitems(self):
 #od.viewitems() -> a set-like object providing a view on od's items"
 #eturn ItemsView(self)


try:
 #rom logging.config import BaseConfigurator, valid_ident
except ImportError:  # pragma: no cover
 #DENTIFIER = re.compile('^[a-z_][a-z0-9_]*$', re.I)

 #ef valid_ident(s):
 # = IDENTIFIER.match(s)
 #f not m:
 #aise ValueError('Not a valid Python identifier: %r' % s)
 #eturn True

    # The ConvertingXXX classes are wrappers around standard Python containers,
    # and they serve to convert any suitable values in the container. The
    # conversion converts base dicts, lists and tuples to their wrapped
    # equivalents, whereas strings which match a conversion format are converted
    # appropriately.
    #
    # Each wrapper should have a configurator attribute holding the actual
    # configurator to use for conversion.

 #lass ConvertingDict(dict):
 #""A converting dictionary wrapper."""

 #ef __getitem__(self, key):
 #alue = dict.__getitem__(self, key)
 #esult = self.configurator.convert(value)
            # If the converted value is different, save for next time
 #f value is not result:
 #elf[key] = result
 #f type(result) in (ConvertingDict, ConvertingList,
 #onvertingTuple):
 #esult.parent = self
 #esult.key = key
 #eturn result

 #ef get(self, key, default=None):
 #alue = dict.get(self, key, default)
 #esult = self.configurator.convert(value)
            # If the converted value is different, save for next time
 #f value is not result:
 #elf[key] = result
 #f type(result) in (ConvertingDict, ConvertingList,
 #onvertingTuple):
 #esult.parent = self
 #esult.key = key
 #eturn result

 #ef pop(self, key, default=None):
 #alue = dict.pop(self, key, default)
 #esult = self.configurator.convert(value)
 #f value is not result:
 #f type(result) in (ConvertingDict, ConvertingList,
 #onvertingTuple):
 #esult.parent = self
 #esult.key = key
 #eturn result

 #lass ConvertingList(list):
 #""A converting list wrapper."""

 #ef __getitem__(self, key):
 #alue = list.__getitem__(self, key)
 #esult = self.configurator.convert(value)
            # If the converted value is different, save for next time
 #f value is not result:
 #elf[key] = result
 #f type(result) in (ConvertingDict, ConvertingList,
 #onvertingTuple):
 #esult.parent = self
 #esult.key = key
 #eturn result

 #ef pop(self, idx=-1):
 #alue = list.pop(self, idx)
 #esult = self.configurator.convert(value)
 #f value is not result:
 #f type(result) in (ConvertingDict, ConvertingList,
 #onvertingTuple):
 #esult.parent = self
 #eturn result

 #lass ConvertingTuple(tuple):
 #""A converting tuple wrapper."""

 #ef __getitem__(self, key):
 #alue = tuple.__getitem__(self, key)
 #esult = self.configurator.convert(value)
 #f value is not result:
 #f type(result) in (ConvertingDict, ConvertingList,
 #onvertingTuple):
 #esult.parent = self
 #esult.key = key
 #eturn result

 #lass BaseConfigurator(object):
 #""
 #he configurator base class which defines some useful defaults.
 #""

 #ONVERT_PATTERN = re.compile(r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$')

 #ORD_PATTERN = re.compile(r'^\s*(\w+)\s*')
 #OT_PATTERN = re.compile(r'^\.\s*(\w+)\s*')
 #NDEX_PATTERN = re.compile(r'^\[\s*(\w+)\s*\]\s*')
 #IGIT_PATTERN = re.compile(r'^\d+$')

 #alue_converters = {
 #ext': 'ext_convert',
 #cfg': 'cfg_convert',
 #

        # We might want to use a different one, e.g. importlib
 #mporter = staticmethod(__import__)

 #ef __init__(self, config):
 #elf.config = ConvertingDict(config)
 #elf.config.configurator = self

 #ef resolve(self, s):
 #""
 #esolve strings to objects using standard import and attribute
 #yntax.
 #""
 #ame = s.split('.')
 #sed = name.pop(0)
 #ry:
 #ound = self.importer(used)
 #or frag in name:
 #sed += '.' + frag
 #ry:
 #ound = getattr(found, frag)
 #xcept AttributeError:
 #elf.importer(used)
 #ound = getattr(found, frag)
 #eturn found
 #xcept ImportError:
 #, tb = sys.exc_info()[1:]
 # = ValueError('Cannot resolve %r: %s' % (s, e))
 #.__cause__, v.__traceback__ = e, tb
 #aise v

 #ef ext_convert(self, value):
 #""Default converter for the ext:// protocol."""
 #eturn self.resolve(value)

 #ef cfg_convert(self, value):
 #""Default converter for the cfg:// protocol."""
 #est = value
 # = self.WORD_PATTERN.match(rest)
 #f m is None:
 #aise ValueError("Unable to convert %r" % value)
 #lse:
 #est = rest[m.end():]
 # = self.config[m.groups()[0]]
 #hile rest:
 # = self.DOT_PATTERN.match(rest)
 #f m:
 # = d[m.groups()[0]]
 #lse:
 # = self.INDEX_PATTERN.match(rest)
 #f m:
 #dx = m.groups()[0]
 #f not self.DIGIT_PATTERN.match(idx):
 # = d[idx]
 #lse:
 #ry:
 # = int(
 #dx
 #  # try as number first (most likely)
 # = d[n]
 #xcept TypeError:
 # = d[idx]
 #f m:
 #est = rest[m.end():]
 #lse:
 #aise ValueError('Unable to convert '
 #%r at %r' % (value, rest))
            # rest should be empty
 #eturn d

 #ef convert(self, value):
 #""
 #onvert values to an appropriate type. dicts, lists and tuples are
 #eplaced by their converting alternatives. Strings are checked to
 #ee if they have a conversion format and are converted if they do.
 #""
 #f not isinstance(value, ConvertingDict) and isinstance(
 #alue, dict):
 #alue = ConvertingDict(value)
 #alue.configurator = self
 #lif not isinstance(value, ConvertingList) and isinstance(
 #alue, list):
 #alue = ConvertingList(value)
 #alue.configurator = self
 #lif not isinstance(value, ConvertingTuple) and isinstance(value, tuple):
 #alue = ConvertingTuple(value)
 #alue.configurator = self
 #lif isinstance(value, string_types):
 # = self.CONVERT_PATTERN.match(value)
 #f m:
 # = m.groupdict()
 #refix = d['prefix']
 #onverter = self.value_converters.get(prefix, None)
 #f converter:
 #uffix = d['suffix']
 #onverter = getattr(self, converter)
 #alue = converter(suffix)
 #eturn value

 #ef configure_custom(self, config):
 #""Configure an object with a user-supplied factory."""
 # = config.pop('()')
 #f not callable(c):
 # = self.resolve(c)
 #rops = config.pop('.', None)
            # Check for valid identifiers
 #wargs = dict([(k, config[k]) for k in config if valid_ident(k)])
 #esult = c(**kwargs)
 #f props:
 #or name, value in props.items():
 #etattr(result, name, value)
 #eturn result

 #ef as_tuple(self, value):
 #""Utility function which converts lists to tuples."""
 #f isinstance(value, list):
 #alue = tuple(value)
 #eturn value
