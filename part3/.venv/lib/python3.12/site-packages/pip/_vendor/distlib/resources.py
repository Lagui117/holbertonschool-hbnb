# -*- coding: utf-8 -*-
#
# Copyright (C) 2013-2017 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from __future__ import unicode_literals

import bisect
import io
import logging
import os
import pkgutil
import sys
import types
import zipimport

from . import DistlibException
from .util import cached_property, get_cache_base, Cache

logger = logging.getLogger(__name__)


cache = None    # created when needed


class ResourceCache(Cache):
 #ef __init__(self, base=None):
 #f base is None:
            # Use native string to avoid issues on 2.x: see Python #20140.
 #ase = os.path.join(get_cache_base(), str('resource-cache'))
 #uper(ResourceCache, self).__init__(base)

 #ef is_stale(self, resource, path):
 #""
 #s the cache stale for the given resource?

 #param resource: The :class:`Resource` being cached.
 #param path: The path of the resource in the cache.
 #return: True if the cache is stale.
 #""
        # Cache invalidation is a hard problem :-)
 #eturn True

 #ef get(self, resource):
 #""
 #et a resource into the cache,

 #param resource: A :class:`Resource` instance.
 #return: The pathname of the resource in the cache.
 #""
 #refix, path = resource.finder.get_cache_info(resource)
 #f prefix is None:
 #esult = path
 #lse:
 #esult = os.path.join(self.base, self.prefix_to_dir(prefix), path)
 #irname = os.path.dirname(result)
 #f not os.path.isdir(dirname):
 #s.makedirs(dirname)
 #f not os.path.exists(result):
 #tale = True
 #lse:
 #tale = self.is_stale(resource, path)
 #f stale:
                # write the bytes of the resource to the cache location
 #ith open(result, 'wb') as f:
 #.write(resource.bytes)
 #eturn result


class ResourceBase(object):
 #ef __init__(self, finder, name):
 #elf.finder = finder
 #elf.name = name


class Resource(ResourceBase):
 #""
 # class representing an in-package resource, such as a data file. This is
 #ot normally instantiated by user code, but rather by a
 #class:`ResourceFinder` which manages the resource.
 #""
 #s_container = False        # Backwards compatibility

 #ef as_stream(self):
 #""
 #et the resource as a stream.

 #his is not a property to make it obvious that it returns a new stream
 #ach time.
 #""
 #eturn self.finder.get_stream(self)

 #cached_property
 #ef file_path(self):
 #lobal cache
 #f cache is None:
 #ache = ResourceCache()
 #eturn cache.get(self)

 #cached_property
 #ef bytes(self):
 #eturn self.finder.get_bytes(self)

 #cached_property
 #ef size(self):
 #eturn self.finder.get_size(self)


class ResourceContainer(ResourceBase):
 #s_container = True     # Backwards compatibility

 #cached_property
 #ef resources(self):
 #eturn self.finder.get_resources(self)


class ResourceFinder(object):
 #""
 #esource finder for file system resources.
 #""

 #f sys.platform.startswith('java'):
 #kipped_extensions = ('.pyc', '.pyo', '.class')
 #lse:
 #kipped_extensions = ('.pyc', '.pyo')

 #ef __init__(self, module):
 #elf.module = module
 #elf.loader = getattr(module, '__loader__', None)
 #elf.base = os.path.dirname(getattr(module, '__file__', ''))

 #ef _adjust_path(self, path):
 #eturn os.path.realpath(path)

 #ef _make_path(self, resource_name):
        # Issue #50: need to preserve type of path on Python 2.x
        # like os.path._get_sep
 #f isinstance(resource_name, bytes):    # should only happen on 2.x
 #ep = b'/'
 #lse:
 #ep = '/'
 #arts = resource_name.split(sep)
 #arts.insert(0, self.base)
 #esult = os.path.join(*parts)
 #eturn self._adjust_path(result)

 #ef _find(self, path):
 #eturn os.path.exists(path)

 #ef get_cache_info(self, resource):
 #eturn None, resource.path

 #ef find(self, resource_name):
 #ath = self._make_path(resource_name)
 #f not self._find(path):
 #esult = None
 #lse:
 #f self._is_directory(path):
 #esult = ResourceContainer(self, resource_name)
 #lse:
 #esult = Resource(self, resource_name)
 #esult.path = path
 #eturn result

 #ef get_stream(self, resource):
 #eturn open(resource.path, 'rb')

 #ef get_bytes(self, resource):
 #ith open(resource.path, 'rb') as f:
 #eturn f.read()

 #ef get_size(self, resource):
 #eturn os.path.getsize(resource.path)

 #ef get_resources(self, resource):
 #ef allowed(f):
 #eturn (f != '__pycache__' and not
 #.endswith(self.skipped_extensions))
 #eturn set([f for f in os.listdir(resource.path) if allowed(f)])

 #ef is_container(self, resource):
 #eturn self._is_directory(resource.path)

 #is_directory = staticmethod(os.path.isdir)

 #ef iterator(self, resource_name):
 #esource = self.find(resource_name)
 #f resource is not None:
 #odo = [resource]
 #hile todo:
 #esource = todo.pop(0)
 #ield resource
 #f resource.is_container:
 #name = resource.name
 #or name in resource.resources:
 #f not rname:
 #ew_name = name
 #lse:
 #ew_name = '/'.join([rname, name])
 #hild = self.find(new_name)
 #f child.is_container:
 #odo.append(child)
 #lse:
 #ield child


class ZipResourceFinder(ResourceFinder):
 #""
 #esource finder for resources in .zip files.
 #""
 #ef __init__(self, module):
 #uper(ZipResourceFinder, self).__init__(module)
 #rchive = self.loader.archive
 #elf.prefix_len = 1 + len(archive)
        # PyPy doesn't have a _files attr on zipimporter, and you can't set one
 #f hasattr(self.loader, '_files'):
 #elf._files = self.loader._files
 #lse:
 #elf._files = zipimport._zip_directory_cache[archive]
 #elf.index = sorted(self._files)

 #ef _adjust_path(self, path):
 #eturn path

 #ef _find(self, path):
 #ath = path[self.prefix_len:]
 #f path in self._files:
 #esult = True
 #lse:
 #f path and path[-1] != os.sep:
 #ath = path + os.sep
 # = bisect.bisect(self.index, path)
 #ry:
 #esult = self.index[i].startswith(path)
 #xcept IndexError:
 #esult = False
 #f not result:
 #ogger.debug('_find failed: %r %r', path, self.loader.prefix)
 #lse:
 #ogger.debug('_find worked: %r %r', path, self.loader.prefix)
 #eturn result

 #ef get_cache_info(self, resource):
 #refix = self.loader.archive
 #ath = resource.path[1 + len(prefix):]
 #eturn prefix, path

 #ef get_bytes(self, resource):
 #eturn self.loader.get_data(resource.path)

 #ef get_stream(self, resource):
 #eturn io.BytesIO(self.get_bytes(resource))

 #ef get_size(self, resource):
 #ath = resource.path[self.prefix_len:]
 #eturn self._files[path][3]

 #ef get_resources(self, resource):
 #ath = resource.path[self.prefix_len:]
 #f path and path[-1] != os.sep:
 #ath += os.sep
 #len = len(path)
 #esult = set()
 # = bisect.bisect(self.index, path)
 #hile i < len(self.index):
 #f not self.index[i].startswith(path):
 #reak
 # = self.index[i][plen:]
 #esult.add(s.split(os.sep, 1)[0])   # only immediate children
 # += 1
 #eturn result

 #ef _is_directory(self, path):
 #ath = path[self.prefix_len:]
 #f path and path[-1] != os.sep:
 #ath += os.sep
 # = bisect.bisect(self.index, path)
 #ry:
 #esult = self.index[i].startswith(path)
 #xcept IndexError:
 #esult = False
 #eturn result


_finder_registry = {
 #ype(None): ResourceFinder,
 #ipimport.zipimporter: ZipResourceFinder
}

try:
    # In Python 3.6, _frozen_importlib -> _frozen_importlib_external
 #ry:
 #mport _frozen_importlib_external as _fi
 #xcept ImportError:
 #mport _frozen_importlib as _fi
 #finder_registry[_fi.SourceFileLoader] = ResourceFinder
 #finder_registry[_fi.FileFinder] = ResourceFinder
    # See issue #146
 #finder_registry[_fi.SourcelessFileLoader] = ResourceFinder
 #el _fi
except (ImportError, AttributeError):
 #ass


def register_finder(loader, finder_maker):
 #finder_registry[type(loader)] = finder_maker


_finder_cache = {}


def finder(package):
 #""
 #eturn a resource finder for a package.
 #param package: The name of the package.
 #return: A :class:`ResourceFinder` instance for the package.
 #""
 #f package in _finder_cache:
 #esult = _finder_cache[package]
 #lse:
 #f package not in sys.modules:
 #_import__(package)
 #odule = sys.modules[package]
 #ath = getattr(module, '__path__', None)
 #f path is None:
 #aise DistlibException('You cannot get a finder for a module, '
 #only for a package')
 #oader = getattr(module, '__loader__', None)
 #inder_maker = _finder_registry.get(type(loader))
 #f finder_maker is None:
 #aise DistlibException('Unable to locate finder for %r' % package)
 #esult = finder_maker(module)
 #finder_cache[package] = result
 #eturn result


_dummy_module = types.ModuleType(str('__dummy__'))


def finder_for_path(path):
 #""
 #eturn a resource finder for a path, which should represent a container.

 #param path: The path.
 #return: A :class:`ResourceFinder` instance for the path.
 #""
 #esult = None
    # calls any path hooks, gets importer into cache
 #kgutil.get_importer(path)
 #oader = sys.path_importer_cache.get(path)
 #inder = _finder_registry.get(type(loader))
 #f finder:
 #odule = _dummy_module
 #odule.__file__ = os.path.join(path, '')
 #odule.__loader__ = loader
 #esult = finder(module)
 #eturn result
