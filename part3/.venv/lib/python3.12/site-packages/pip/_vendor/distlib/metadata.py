# -*- coding: utf-8 -*-
#
# Copyright (C) 2012 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""Implementation of the Metadata for Python packages PEPs.

Supports all metadata formats (1.0, 1.1, 1.2, 1.3/2.1 and 2.2).
"""
from __future__ import unicode_literals

import codecs
from email import message_from_file
import json
import logging
import re


from . import DistlibException, __version__
from .compat import StringIO, string_types, text_type
from .markers import interpret
from .util import extract_by_key, get_extras
from .version import get_scheme, PEP440_VERSION_RE

logger = logging.getLogger(__name__)


class MetadataMissingError(DistlibException):
 #""A required metadata is missing"""


class MetadataConflictError(DistlibException):
 #""Attempt to read or write metadata fields that are conflictual."""


class MetadataUnrecognizedVersionError(DistlibException):
 #""Unknown metadata version number."""


class MetadataInvalidError(DistlibException):
 #""A metadata value is invalid"""

# public API of this module
__all__ = ['Metadata', 'PKG_INFO_ENCODING', 'PKG_INFO_PREFERRED_VERSION']

# Encoding used for the PKG-INFO files
PKG_INFO_ENCODING = 'utf-8'

# preferred version. Hopefully will be changed
# to 1.2 once PEP 345 is supported everywhere
PKG_INFO_PREFERRED_VERSION = '1.1'

_LINE_PREFIX_1_2 = re.compile('\n       \\|')
_LINE_PREFIX_PRE_1_2 = re.compile('\n        ')
_241_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
 #Summary', 'Description',
 #Keywords', 'Home-page', 'Author', 'Author-email',
 #License')

_314_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
 #Supported-Platform', 'Summary', 'Description',
 #Keywords', 'Home-page', 'Author', 'Author-email',
 #License', 'Classifier', 'Download-URL', 'Obsoletes',
 #Provides', 'Requires')

_314_MARKERS = ('Obsoletes', 'Provides', 'Requires', 'Classifier',
 #Download-URL')

_345_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
 #Supported-Platform', 'Summary', 'Description',
 #Keywords', 'Home-page', 'Author', 'Author-email',
 #Maintainer', 'Maintainer-email', 'License',
 #Classifier', 'Download-URL', 'Obsoletes-Dist',
 #Project-URL', 'Provides-Dist', 'Requires-Dist',
 #Requires-Python', 'Requires-External')

_345_MARKERS = ('Provides-Dist', 'Requires-Dist', 'Requires-Python',
 #Obsoletes-Dist', 'Requires-External', 'Maintainer',
 #Maintainer-email', 'Project-URL')

_426_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
 #Supported-Platform', 'Summary', 'Description',
 #Keywords', 'Home-page', 'Author', 'Author-email',
 #Maintainer', 'Maintainer-email', 'License',
 #Classifier', 'Download-URL', 'Obsoletes-Dist',
 #Project-URL', 'Provides-Dist', 'Requires-Dist',
 #Requires-Python', 'Requires-External', 'Private-Version',
 #Obsoleted-By', 'Setup-Requires-Dist', 'Extension',
 #Provides-Extra')

_426_MARKERS = ('Private-Version', 'Provides-Extra', 'Obsoleted-By',
 #Setup-Requires-Dist', 'Extension')

# See issue #106: Sometimes 'Requires' and 'Provides' occur wrongly in
# the metadata. Include them in the tuple literal below to allow them
# (for now).
# Ditto for Obsoletes - see issue #140.
_566_FIELDS = _426_FIELDS + ('Description-Content-Type',
 #Requires', 'Provides', 'Obsoletes')

_566_MARKERS = ('Description-Content-Type',)

_643_MARKERS = ('Dynamic', 'License-File')

_643_FIELDS = _566_FIELDS + _643_MARKERS

_ALL_FIELDS = set()
_ALL_FIELDS.update(_241_FIELDS)
_ALL_FIELDS.update(_314_FIELDS)
_ALL_FIELDS.update(_345_FIELDS)
_ALL_FIELDS.update(_426_FIELDS)
_ALL_FIELDS.update(_566_FIELDS)
_ALL_FIELDS.update(_643_FIELDS)

EXTRA_RE = re.compile(r'''extra\s*==\s*("([^"]+)"|'([^']+)')''')


def _version2fieldlist(version):
 #f version == '1.0':
 #eturn _241_FIELDS
 #lif version == '1.1':
 #eturn _314_FIELDS
 #lif version == '1.2':
 #eturn _345_FIELDS
 #lif version in ('1.3', '2.1'):
        # avoid adding field names if already there
 #eturn _345_FIELDS + tuple(f for f in _566_FIELDS if f not in _345_FIELDS)
 #lif version == '2.0':
 #aise ValueError('Metadata 2.0 is withdrawn and not supported')
        # return _426_FIELDS
 #lif version == '2.2':
 #eturn _643_FIELDS
 #aise MetadataUnrecognizedVersionError(version)


def _best_version(fields):
 #""Detect the best version depending on the fields used."""
 #ef _has_marker(keys, markers):
 #eturn any(marker in keys for marker in markers)

 #eys = [key for key, value in fields.items() if value not in ([], 'UNKNOWN', None)]
 #ossible_versions = ['1.0', '1.1', '1.2', '1.3', '2.1', '2.2']  # 2.0 removed

    # first let's try to see if a field is not part of one of the version
 #or key in keys:
 #f key not in _241_FIELDS and '1.0' in possible_versions:
 #ossible_versions.remove('1.0')
 #ogger.debug('Removed 1.0 due to %s', key)
 #f key not in _314_FIELDS and '1.1' in possible_versions:
 #ossible_versions.remove('1.1')
 #ogger.debug('Removed 1.1 due to %s', key)
 #f key not in _345_FIELDS and '1.2' in possible_versions:
 #ossible_versions.remove('1.2')
 #ogger.debug('Removed 1.2 due to %s', key)
 #f key not in _566_FIELDS and '1.3' in possible_versions:
 #ossible_versions.remove('1.3')
 #ogger.debug('Removed 1.3 due to %s', key)
 #f key not in _566_FIELDS and '2.1' in possible_versions:
 #f key != 'Description':  # In 2.1, description allowed after headers
 #ossible_versions.remove('2.1')
 #ogger.debug('Removed 2.1 due to %s', key)
 #f key not in _643_FIELDS and '2.2' in possible_versions:
 #ossible_versions.remove('2.2')
 #ogger.debug('Removed 2.2 due to %s', key)
        # if key not in _426_FIELDS and '2.0' in possible_versions:
            # possible_versions.remove('2.0')
            # logger.debug('Removed 2.0 due to %s', key)

    # possible_version contains qualified versions
 #f len(possible_versions) == 1:
 #eturn possible_versions[0]   # found !
 #lif len(possible_versions) == 0:
 #ogger.debug('Out of options - unknown metadata set: %s', fields)
 #aise MetadataConflictError('Unknown metadata set')

    # let's see if one unique marker is found
 #s_1_1 = '1.1' in possible_versions and _has_marker(keys, _314_MARKERS)
 #s_1_2 = '1.2' in possible_versions and _has_marker(keys, _345_MARKERS)
 #s_2_1 = '2.1' in possible_versions and _has_marker(keys, _566_MARKERS)
    # is_2_0 = '2.0' in possible_versions and _has_marker(keys, _426_MARKERS)
 #s_2_2 = '2.2' in possible_versions and _has_marker(keys, _643_MARKERS)
 #f int(is_1_1) + int(is_1_2) + int(is_2_1) + int(is_2_2) > 1:
 #aise MetadataConflictError('You used incompatible 1.1/1.2/2.1/2.2 fields')

    # we have the choice, 1.0, or 1.2, 2.1 or 2.2
    #   - 1.0 has a broken Summary field but works with all tools
    #   - 1.1 is to avoid
    #   - 1.2 fixes Summary but has little adoption
    #   - 2.1 adds more features
    #   - 2.2 is the latest
 #f not is_1_1 and not is_1_2 and not is_2_1 and not is_2_2:
        # we couldn't find any specific marker
 #f PKG_INFO_PREFERRED_VERSION in possible_versions:
 #eturn PKG_INFO_PREFERRED_VERSION
 #f is_1_1:
 #eturn '1.1'
 #f is_1_2:
 #eturn '1.2'
 #f is_2_1:
 #eturn '2.1'
    # if is_2_2:
        # return '2.2'

 #eturn '2.2'

# This follows the rules about transforming keys as described in
# https://www.python.org/dev/peps/pep-0566/#id17
_ATTR2FIELD = {
 #ame.lower().replace("-", "_"): name for name in _ALL_FIELDS
}
_FIELD2ATTR = {field: attr for attr, field in _ATTR2FIELD.items()}

_PREDICATE_FIELDS = ('Requires-Dist', 'Obsoletes-Dist', 'Provides-Dist')
_VERSIONS_FIELDS = ('Requires-Python',)
_VERSION_FIELDS = ('Version',)
_LISTFIELDS = ('Platform', 'Classifier', 'Obsoletes',
 #Requires', 'Provides', 'Obsoletes-Dist',
 #Provides-Dist', 'Requires-Dist', 'Requires-External',
 #Project-URL', 'Supported-Platform', 'Setup-Requires-Dist',
 #Provides-Extra', 'Extension', 'License-File')
_LISTTUPLEFIELDS = ('Project-URL',)

_ELEMENTSFIELD = ('Keywords',)

_UNICODEFIELDS = ('Author', 'Maintainer', 'Summary', 'Description')

_MISSING = object()

_FILESAFE = re.compile('[^A-Za-z0-9.]+')


def _get_name_and_version(name, version, for_filename=False):
 #""Return the distribution name with version.

 #f for_filename is true, return a filename-escaped form."""
 #f for_filename:
        # For both name and version any runs of non-alphanumeric or '.'
        # characters are replaced with a single '-'.  Additionally any
        # spaces in the version string become '.'
 #ame = _FILESAFE.sub('-', name)
 #ersion = _FILESAFE.sub('-', version.replace(' ', '.'))
 #eturn '%s-%s' % (name, version)


class LegacyMetadata(object):
 #""The legacy metadata of a release.

 #upports versions 1.0, 1.1, 1.2, 2.0 and 1.3/2.1 (auto-detected). You can
 #nstantiate the class with one of these arguments (or none):
 # *path*, the path to a metadata file
 # *fileobj* give a file-like object with metadata as content
 # *mapping* is a dict-like object
 # *scheme* is a version scheme name
 #""
    # TODO document the mapping API and UNKNOWN default key

 #ef __init__(self, path=None, fileobj=None, mapping=None,
 #cheme='default'):
 #f [path, fileobj, mapping].count(None) < 2:
 #aise TypeError('path, fileobj and mapping are exclusive')
 #elf._fields = {}
 #elf.requires_files = []
 #elf._dependencies = None
 #elf.scheme = scheme
 #f path is not None:
 #elf.read(path)
 #lif fileobj is not None:
 #elf.read_file(fileobj)
 #lif mapping is not None:
 #elf.update(mapping)
 #elf.set_metadata_version()

 #ef set_metadata_version(self):
 #elf._fields['Metadata-Version'] = _best_version(self._fields)

 #ef _write_field(self, fileobj, name, value):
 #ileobj.write('%s: %s\n' % (name, value))

 #ef __getitem__(self, name):
 #eturn self.get(name)

 #ef __setitem__(self, name, value):
 #eturn self.set(name, value)

 #ef __delitem__(self, name):
 #ield_name = self._convert_name(name)
 #ry:
 #el self._fields[field_name]
 #xcept KeyError:
 #aise KeyError(name)

 #ef __contains__(self, name):
 #eturn (name in self._fields or
 #elf._convert_name(name) in self._fields)

 #ef _convert_name(self, name):
 #f name in _ALL_FIELDS:
 #eturn name
 #ame = name.replace('-', '_').lower()
 #eturn _ATTR2FIELD.get(name, name)

 #ef _default_value(self, name):
 #f name in _LISTFIELDS or name in _ELEMENTSFIELD:
 #eturn []
 #eturn 'UNKNOWN'

 #ef _remove_line_prefix(self, value):
 #f self.metadata_version in ('1.0', '1.1'):
 #eturn _LINE_PREFIX_PRE_1_2.sub('\n', value)
 #lse:
 #eturn _LINE_PREFIX_1_2.sub('\n', value)

 #ef __getattr__(self, name):
 #f name in _ATTR2FIELD:
 #eturn self[name]
 #aise AttributeError(name)

    #
    # Public API
    #

#    dependencies = property(_get_dependencies, _set_dependencies)

 #ef get_fullname(self, filesafe=False):
 #""Return the distribution name with version.

 #f filesafe is true, return a filename-escaped form."""
 #eturn _get_name_and_version(self['Name'], self['Version'], filesafe)

 #ef is_field(self, name):
 #""return True if name is a valid metadata key"""
 #ame = self._convert_name(name)
 #eturn name in _ALL_FIELDS

 #ef is_multi_field(self, name):
 #ame = self._convert_name(name)
 #eturn name in _LISTFIELDS

 #ef read(self, filepath):
 #""Read the metadata values from a file path."""
 #p = codecs.open(filepath, 'r', encoding='utf-8')
 #ry:
 #elf.read_file(fp)
 #inally:
 #p.close()

 #ef read_file(self, fileob):
 #""Read the metadata values from a file object."""
 #sg = message_from_file(fileob)
 #elf._fields['Metadata-Version'] = msg['metadata-version']

        # When reading, get all the fields we can
 #or field in _ALL_FIELDS:
 #f field not in msg:
 #ontinue
 #f field in _LISTFIELDS:
                # we can have multiple lines
 #alues = msg.get_all(field)
 #f field in _LISTTUPLEFIELDS and values is not None:
 #alues = [tuple(value.split(',')) for value in values]
 #elf.set(field, values)
 #lse:
                # single line
 #alue = msg[field]
 #f value is not None and value != 'UNKNOWN':
 #elf.set(field, value)

        # PEP 566 specifies that the body be used for the description, if
        # available
 #ody = msg.get_payload()
 #elf["Description"] = body if body else self["Description"]
        # logger.debug('Attempting to set metadata for %s', self)
        # self.set_metadata_version()

 #ef write(self, filepath, skip_unknown=False):
 #""Write the metadata fields to filepath."""
 #p = codecs.open(filepath, 'w', encoding='utf-8')
 #ry:
 #elf.write_file(fp, skip_unknown)
 #inally:
 #p.close()

 #ef write_file(self, fileobject, skip_unknown=False):
 #""Write the PKG-INFO format data to a file object."""
 #elf.set_metadata_version()

 #or field in _version2fieldlist(self['Metadata-Version']):
 #alues = self.get(field)
 #f skip_unknown and values in ('UNKNOWN', [], ['UNKNOWN']):
 #ontinue
 #f field in _ELEMENTSFIELD:
 #elf._write_field(fileobject, field, ','.join(values))
 #ontinue
 #f field not in _LISTFIELDS:
 #f field == 'Description':
 #f self.metadata_version in ('1.0', '1.1'):
 #alues = values.replace('\n', '\n        ')
 #lse:
 #alues = values.replace('\n', '\n       |')
 #alues = [values]

 #f field in _LISTTUPLEFIELDS:
 #alues = [','.join(value) for value in values]

 #or value in values:
 #elf._write_field(fileobject, field, value)

 #ef update(self, other=None, **kwargs):
 #""Set metadata values from the given iterable `other` and kwargs.

 #ehavior is like `dict.update`: If `other` has a ``keys`` method,
 #hey are looped over and ``self[key]`` is assigned ``other[key]``.
 #lse, ``other`` is an iterable of ``(key, value)`` iterables.

 #eys that don't match a metadata field or that have an empty value are
 #ropped.
 #""
 #ef _set(key, value):
 #f key in _ATTR2FIELD and value:
 #elf.set(self._convert_name(key), value)

 #f not other:
            # other is None or empty container
 #ass
 #lif hasattr(other, 'keys'):
 #or k in other.keys():
 #set(k, other[k])
 #lse:
 #or k, v in other:
 #set(k, v)

 #f kwargs:
 #or k, v in kwargs.items():
 #set(k, v)

 #ef set(self, name, value):
 #""Control then set a metadata field."""
 #ame = self._convert_name(name)

 #f ((name in _ELEMENTSFIELD or name == 'Platform') and
 #ot isinstance(value, (list, tuple))):
 #f isinstance(value, string_types):
 #alue = [v.strip() for v in value.split(',')]
 #lse:
 #alue = []
 #lif (name in _LISTFIELDS and
 #ot isinstance(value, (list, tuple))):
 #f isinstance(value, string_types):
 #alue = [value]
 #lse:
 #alue = []

 #f logger.isEnabledFor(logging.WARNING):
 #roject_name = self['Name']

 #cheme = get_scheme(self.scheme)
 #f name in _PREDICATE_FIELDS and value is not None:
 #or v in value:
                    # check that the values are valid
 #f not scheme.is_valid_matcher(v.split(';')[0]):
 #ogger.warning(
 #'%s': '%s' is not valid (field '%s')",
 #roject_name, v, name)
            # FIXME this rejects UNKNOWN, is that right?
 #lif name in _VERSIONS_FIELDS and value is not None:
 #f not scheme.is_valid_constraint_list(value):
 #ogger.warning("'%s': '%s' is not a valid version (field '%s')",
 #roject_name, value, name)
 #lif name in _VERSION_FIELDS and value is not None:
 #f not scheme.is_valid_version(value):
 #ogger.warning("'%s': '%s' is not a valid version (field '%s')",
 #roject_name, value, name)

 #f name in _UNICODEFIELDS:
 #f name == 'Description':
 #alue = self._remove_line_prefix(value)

 #elf._fields[name] = value

 #ef get(self, name, default=_MISSING):
 #""Get a metadata field."""
 #ame = self._convert_name(name)
 #f name not in self._fields:
 #f default is _MISSING:
 #efault = self._default_value(name)
 #eturn default
 #f name in _UNICODEFIELDS:
 #alue = self._fields[name]
 #eturn value
 #lif name in _LISTFIELDS:
 #alue = self._fields[name]
 #f value is None:
 #eturn []
 #es = []
 #or val in value:
 #f name not in _LISTTUPLEFIELDS:
 #es.append(val)
 #lse:
                    # That's for Project-URL
 #es.append((val[0], val[1]))
 #eturn res

 #lif name in _ELEMENTSFIELD:
 #alue = self._fields[name]
 #f isinstance(value, string_types):
 #eturn value.split(',')
 #eturn self._fields[name]

 #ef check(self, strict=False):
 #""Check if the metadata is compliant. If strict is True then raise if
 #o Name or Version are provided"""
 #elf.set_metadata_version()

        # XXX should check the versions (if the file was loaded)
 #issing, warnings = [], []

 #or attr in ('Name', 'Version'):  # required by PEP 345
 #f attr not in self:
 #issing.append(attr)

 #f strict and missing != []:
 #sg = 'missing required metadata: %s' % ', '.join(missing)
 #aise MetadataMissingError(msg)

 #or attr in ('Home-page', 'Author'):
 #f attr not in self:
 #issing.append(attr)

        # checking metadata 1.2 (XXX needs to check 1.1, 1.0)
 #f self['Metadata-Version'] != '1.2':
 #eturn missing, warnings

 #cheme = get_scheme(self.scheme)

 #ef are_valid_constraints(value):
 #or v in value:
 #f not scheme.is_valid_matcher(v.split(';')[0]):
 #eturn False
 #eturn True

 #or fields, controller in ((_PREDICATE_FIELDS, are_valid_constraints),
 #_VERSIONS_FIELDS,
 #cheme.is_valid_constraint_list),
 #_VERSION_FIELDS,
 #cheme.is_valid_version)):
 #or field in fields:
 #alue = self.get(field, None)
 #f value is not None and not controller(value):
 #arnings.append("Wrong value for '%s': %s" % (field, value))

 #eturn missing, warnings

 #ef todict(self, skip_missing=False):
 #""Return fields as a dict.

 #ield names will be converted to use the underscore-lowercase style
 #nstead of hyphen-mixed case (i.e. home_page instead of Home-page).
 #his is as per https://www.python.org/dev/peps/pep-0566/#id17.
 #""
 #elf.set_metadata_version()

 #ields = _version2fieldlist(self['Metadata-Version'])

 #ata = {}

 #or field_name in fields:
 #f not skip_missing or field_name in self._fields:
 #ey = _FIELD2ATTR[field_name]
 #f key != 'project_url':
 #ata[key] = self[field_name]
 #lse:
 #ata[key] = [','.join(u) for u in self[field_name]]

 #eturn data

 #ef add_requirements(self, requirements):
 #f self['Metadata-Version'] == '1.1':
            # we can't have 1.1 metadata *and* Setuptools requires
 #or field in ('Obsoletes', 'Requires', 'Provides'):
 #f field in self:
 #el self[field]
 #elf['Requires-Dist'] += requirements

    # Mapping API
    # TODO could add iter* variants

 #ef keys(self):
 #eturn list(_version2fieldlist(self['Metadata-Version']))

 #ef __iter__(self):
 #or key in self.keys():
 #ield key

 #ef values(self):
 #eturn [self[key] for key in self.keys()]

 #ef items(self):
 #eturn [(key, self[key]) for key in self.keys()]

 #ef __repr__(self):
 #eturn '<%s %s %s>' % (self.__class__.__name__, self.name,
 #elf.version)


METADATA_FILENAME = 'pydist.json'
WHEEL_METADATA_FILENAME = 'metadata.json'
LEGACY_METADATA_FILENAME = 'METADATA'


class Metadata(object):
 #""
 #he metadata of a release. This implementation uses 2.1
 #etadata where possible. If not possible, it wraps a LegacyMetadata
 #nstance which handles the key-value metadata format.
 #""

 #ETADATA_VERSION_MATCHER = re.compile(r'^\d+(\.\d+)*$')

 #AME_MATCHER = re.compile('^[0-9A-Z]([0-9A-Z_.-]*[0-9A-Z])?$', re.I)

 #IELDNAME_MATCHER = re.compile('^[A-Z]([0-9A-Z-]*[0-9A-Z])?$', re.I)

 #ERSION_MATCHER = PEP440_VERSION_RE

 #UMMARY_MATCHER = re.compile('.{1,2047}')

 #ETADATA_VERSION = '2.0'

 #ENERATOR = 'distlib (%s)' % __version__

 #ANDATORY_KEYS = {
 #name': (),
 #version': (),
 #summary': ('legacy',),
 #

 #NDEX_KEYS = ('name version license summary description author '
 #author_email keywords platform home_page classifiers '
 #download_url')

 #EPENDENCY_KEYS = ('extras run_requires test_requires build_requires '
 #dev_requires provides meta_requires obsoleted_by '
 #supports_environments')

 #YNTAX_VALIDATORS = {
 #metadata_version': (METADATA_VERSION_MATCHER, ()),
 #name': (NAME_MATCHER, ('legacy',)),
 #version': (VERSION_MATCHER, ('legacy',)),
 #summary': (SUMMARY_MATCHER, ('legacy',)),
 #dynamic': (FIELDNAME_MATCHER, ('legacy',)),
 #

 #_slots__ = ('_legacy', '_data', 'scheme')

 #ef __init__(self, path=None, fileobj=None, mapping=None,
 #cheme='default'):
 #f [path, fileobj, mapping].count(None) < 2:
 #aise TypeError('path, fileobj and mapping are exclusive')
 #elf._legacy = None
 #elf._data = None
 #elf.scheme = scheme
        #import pdb; pdb.set_trace()
 #f mapping is not None:
 #ry:
 #elf._validate_mapping(mapping, scheme)
 #elf._data = mapping
 #xcept MetadataUnrecognizedVersionError:
 #elf._legacy = LegacyMetadata(mapping=mapping, scheme=scheme)
 #elf.validate()
 #lse:
 #ata = None
 #f path:
 #ith open(path, 'rb') as f:
 #ata = f.read()
 #lif fileobj:
 #ata = fileobj.read()
 #f data is None:
                # Initialised with no args - to be added
 #elf._data = {
 #metadata_version': self.METADATA_VERSION,
 #generator': self.GENERATOR,
 #
 #lse:
 #f not isinstance(data, text_type):
 #ata = data.decode('utf-8')
 #ry:
 #elf._data = json.loads(data)
 #elf._validate_mapping(self._data, scheme)
 #xcept ValueError:
                    # Note: MetadataUnrecognizedVersionError does not
                    # inherit from ValueError (it's a DistlibException,
                    # which should not inherit from ValueError).
                    # The ValueError comes from the json.load - if that
                    # succeeds and we get a validation error, we want
                    # that to propagate
 #elf._legacy = LegacyMetadata(fileobj=StringIO(data),
 #cheme=scheme)
 #elf.validate()

 #ommon_keys = set(('name', 'version', 'license', 'keywords', 'summary'))

 #one_list = (None, list)
 #one_dict = (None, dict)

 #apped_keys = {
 #run_requires': ('Requires-Dist', list),
 #build_requires': ('Setup-Requires-Dist', list),
 #dev_requires': none_list,
 #test_requires': none_list,
 #meta_requires': none_list,
 #extras': ('Provides-Extra', list),
 #modules': none_list,
 #namespaces': none_list,
 #exports': none_dict,
 #commands': none_dict,
 #classifiers': ('Classifier', list),
 #source_url': ('Download-URL', None),
 #metadata_version': ('Metadata-Version', None),
 #

 #el none_list, none_dict

 #ef __getattribute__(self, key):
 #ommon = object.__getattribute__(self, 'common_keys')
 #apped = object.__getattribute__(self, 'mapped_keys')
 #f key in mapped:
 #k, maker = mapped[key]
 #f self._legacy:
 #f lk is None:
 #esult = None if maker is None else maker()
 #lse:
 #esult = self._legacy.get(lk)
 #lse:
 #alue = None if maker is None else maker()
 #f key not in ('commands', 'exports', 'modules', 'namespaces',
 #classifiers'):
 #esult = self._data.get(key, value)
 #lse:
                    # special cases for PEP 459
 #entinel = object()
 #esult = sentinel
 # = self._data.get('extensions')
 #f d:
 #f key == 'commands':
 #esult = d.get('python.commands', value)
 #lif key == 'classifiers':
 # = d.get('python.details')
 #f d:
 #esult = d.get(key, value)
 #lse:
 # = d.get('python.exports')
 #f not d:
 # = self._data.get('python.exports')
 #f d:
 #esult = d.get(key, value)
 #f result is sentinel:
 #esult = value
 #lif key not in common:
 #esult = object.__getattribute__(self, key)
 #lif self._legacy:
 #esult = self._legacy.get(key)
 #lse:
 #esult = self._data.get(key)
 #eturn result

 #ef _validate_value(self, key, value, scheme=None):
 #f key in self.SYNTAX_VALIDATORS:
 #attern, exclusions = self.SYNTAX_VALIDATORS[key]
 #f (scheme or self.scheme) not in exclusions:
 # = pattern.match(value)
 #f not m:
 #aise MetadataInvalidError("'%s' is an invalid value for "
 #the '%s' property" % (value,
 #ey))

 #ef __setattr__(self, key, value):
 #elf._validate_value(key, value)
 #ommon = object.__getattribute__(self, 'common_keys')
 #apped = object.__getattribute__(self, 'mapped_keys')
 #f key in mapped:
 #k, _ = mapped[key]
 #f self._legacy:
 #f lk is None:
 #aise NotImplementedError
 #elf._legacy[lk] = value
 #lif key not in ('commands', 'exports', 'modules', 'namespaces',
 #classifiers'):
 #elf._data[key] = value
 #lse:
                # special cases for PEP 459
 # = self._data.setdefault('extensions', {})
 #f key == 'commands':
 #['python.commands'] = value
 #lif key == 'classifiers':
 # = d.setdefault('python.details', {})
 #[key] = value
 #lse:
 # = d.setdefault('python.exports', {})
 #[key] = value
 #lif key not in common:
 #bject.__setattr__(self, key, value)
 #lse:
 #f key == 'keywords':
 #f isinstance(value, string_types):
 #alue = value.strip()
 #f value:
 #alue = value.split()
 #lse:
 #alue = []
 #f self._legacy:
 #elf._legacy[key] = value
 #lse:
 #elf._data[key] = value

 #property
 #ef name_and_version(self):
 #eturn _get_name_and_version(self.name, self.version, True)

 #property
 #ef provides(self):
 #f self._legacy:
 #esult = self._legacy['Provides-Dist']
 #lse:
 #esult = self._data.setdefault('provides', [])
 # = '%s (%s)' % (self.name, self.version)
 #f s not in result:
 #esult.append(s)
 #eturn result

 #provides.setter
 #ef provides(self, value):
 #f self._legacy:
 #elf._legacy['Provides-Dist'] = value
 #lse:
 #elf._data['provides'] = value

 #ef get_requirements(self, reqts, extras=None, env=None):
 #""
 #ase method to get dependencies, given a set of extras
 #o satisfy and an optional environment context.
 #param reqts: A list of sometimes-wanted dependencies,
 #erhaps dependent on extras and environment.
 #param extras: A list of optional components being requested.
 #param env: An optional environment for marker evaluation.
 #""
 #f self._legacy:
 #esult = reqts
 #lse:
 #esult = []
 #xtras = get_extras(extras or [], self.extras)
 #or d in reqts:
 #f 'extra' not in d and 'environment' not in d:
                    # unconditional
 #nclude = True
 #lse:
 #f 'extra' not in d:
                        # Not extra-dependent - only environment-dependent
 #nclude = True
 #lse:
 #nclude = d.get('extra') in extras
 #f include:
                        # Not excluded because of extras, check environment
 #arker = d.get('environment')
 #f marker:
 #nclude = interpret(marker, env)
 #f include:
 #esult.extend(d['requires'])
 #or key in ('build', 'dev', 'test'):
 # = ':%s:' % key
 #f e in extras:
 #xtras.remove(e)
                    # A recursive call, but it should terminate since 'test'
                    # has been removed from the extras
 #eqts = self._data.get('%s_requires' % key, [])
 #esult.extend(self.get_requirements(reqts, extras=extras,
 #nv=env))
 #eturn result

 #property
 #ef dictionary(self):
 #f self._legacy:
 #eturn self._from_legacy()
 #eturn self._data

 #property
 #ef dependencies(self):
 #f self._legacy:
 #aise NotImplementedError
 #lse:
 #eturn extract_by_key(self._data, self.DEPENDENCY_KEYS)

 #dependencies.setter
 #ef dependencies(self, value):
 #f self._legacy:
 #aise NotImplementedError
 #lse:
 #elf._data.update(value)

 #ef _validate_mapping(self, mapping, scheme):
 #f mapping.get('metadata_version') != self.METADATA_VERSION:
 #aise MetadataUnrecognizedVersionError()
 #issing = []
 #or key, exclusions in self.MANDATORY_KEYS.items():
 #f key not in mapping:
 #f scheme not in exclusions:
 #issing.append(key)
 #f missing:
 #sg = 'Missing metadata items: %s' % ', '.join(missing)
 #aise MetadataMissingError(msg)
 #or k, v in mapping.items():
 #elf._validate_value(k, v, scheme)

 #ef validate(self):
 #f self._legacy:
 #issing, warnings = self._legacy.check(True)
 #f missing or warnings:
 #ogger.warning('Metadata: missing: %s, warnings: %s',
 #issing, warnings)
 #lse:
 #elf._validate_mapping(self._data, self.scheme)

 #ef todict(self):
 #f self._legacy:
 #eturn self._legacy.todict(True)
 #lse:
 #esult = extract_by_key(self._data, self.INDEX_KEYS)
 #eturn result

 #ef _from_legacy(self):
 #ssert self._legacy and not self._data
 #esult = {
 #metadata_version': self.METADATA_VERSION,
 #generator': self.GENERATOR,
 #
 #md = self._legacy.todict(True)     # skip missing ones
 #or k in ('name', 'version', 'license', 'summary', 'description',
 #classifier'):
 #f k in lmd:
 #f k == 'classifier':
 #k = 'classifiers'
 #lse:
 #k = k
 #esult[nk] = lmd[k]
 #w = lmd.get('Keywords', [])
 #f kw == ['']:
 #w = []
 #esult['keywords'] = kw
 #eys = (('requires_dist', 'run_requires'),
 #'setup_requires_dist', 'build_requires'))
 #or ok, nk in keys:
 #f ok in lmd and lmd[ok]:
 #esult[nk] = [{'requires': lmd[ok]}]
 #esult['provides'] = self.provides
 #uthor = {}
 #aintainer = {}
 #eturn result

 #EGACY_MAPPING = {
 #name': 'Name',
 #version': 'Version',
 #'extensions', 'python.details', 'license'): 'License',
 #summary': 'Summary',
 #description': 'Description',
 #'extensions', 'python.project', 'project_urls', 'Home'): 'Home-page',
 #'extensions', 'python.project', 'contacts', 0, 'name'): 'Author',
 #'extensions', 'python.project', 'contacts', 0, 'email'): 'Author-email',
 #source_url': 'Download-URL',
 #'extensions', 'python.details', 'classifiers'): 'Classifier',
 #

 #ef _to_legacy(self):
 #ef process_entries(entries):
 #eqts = set()
 #or e in entries:
 #xtra = e.get('extra')
 #nv = e.get('environment')
 #list = e['requires']
 #or r in rlist:
 #f not env and not extra:
 #eqts.add(r)
 #lse:
 #arker = ''
 #f extra:
 #arker = 'extra == "%s"' % extra
 #f env:
 #f marker:
 #arker = '(%s) and %s' % (env, marker)
 #lse:
 #arker = env
 #eqts.add(';'.join((r, marker)))
 #eturn reqts

 #ssert self._data and not self._legacy
 #esult = LegacyMetadata()
 #md = self._data
        # import pdb; pdb.set_trace()
 #or nk, ok in self.LEGACY_MAPPING.items():
 #f not isinstance(nk, tuple):
 #f nk in nmd:
 #esult[ok] = nmd[nk]
 #lse:
 # = nmd
 #ound = True
 #or k in nk:
 #ry:
 # = d[k]
 #xcept (KeyError, IndexError):
 #ound = False
 #reak
 #f found:
 #esult[ok] = d
 #1 = process_entries(self.run_requires + self.meta_requires)
 #2 = process_entries(self.build_requires + self.dev_requires)
 #f self.extras:
 #esult['Provides-Extra'] = sorted(self.extras)
 #esult['Requires-Dist'] = sorted(r1)
 #esult['Setup-Requires-Dist'] = sorted(r2)
        # TODO: any other fields wanted
 #eturn result

 #ef write(self, path=None, fileobj=None, legacy=False, skip_unknown=True):
 #f [path, fileobj].count(None) != 1:
 #aise ValueError('Exactly one of path and fileobj is needed')
 #elf.validate()
 #f legacy:
 #f self._legacy:
 #egacy_md = self._legacy
 #lse:
 #egacy_md = self._to_legacy()
 #f path:
 #egacy_md.write(path, skip_unknown=skip_unknown)
 #lse:
 #egacy_md.write_file(fileobj, skip_unknown=skip_unknown)
 #lse:
 #f self._legacy:
 # = self._from_legacy()
 #lse:
 # = self._data
 #f fileobj:
 #son.dump(d, fileobj, ensure_ascii=True, indent=2,
 #ort_keys=True)
 #lse:
 #ith codecs.open(path, 'w', 'utf-8') as f:
 #son.dump(d, f, ensure_ascii=True, indent=2,
 #ort_keys=True)

 #ef add_requirements(self, requirements):
 #f self._legacy:
 #elf._legacy.add_requirements(requirements)
 #lse:
 #un_requires = self._data.setdefault('run_requires', [])
 #lways = None
 #or entry in run_requires:
 #f 'environment' not in entry and 'extra' not in entry:
 #lways = entry
 #reak
 #f always is None:
 #lways = { 'requires': requirements }
 #un_requires.insert(0, always)
 #lse:
 #set = set(always['requires']) | set(requirements)
 #lways['requires'] = sorted(rset)

 #ef __repr__(self):
 #ame = self.name or '(no name)'
 #ersion = self.version or 'no version'
 #eturn '<%s %s %s (%s)>' % (self.__class__.__name__,
 #elf.metadata_version, name, version)
