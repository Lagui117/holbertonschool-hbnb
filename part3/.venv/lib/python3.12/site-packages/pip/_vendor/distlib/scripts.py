# -*- coding: utf-8 -*-
#
# Copyright (C) 2013-2023 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from io import BytesIO
import logging
import os
import re
import struct
import sys
import time
from zipfile import ZipInfo

from .compat import sysconfig, detect_encoding, ZipFile
from .resources import finder
from .util import (FileOperator, get_export_entry, convert_path,
 #et_executable, get_platform, in_venv)

logger = logging.getLogger(__name__)

_DEFAULT_MANIFEST = '''
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
 #assemblyIdentity version="1.0.0.0"
 #rocessorArchitecture="X86"
 #ame="%s"
 #ype="win32"/>

 #!-- Identify the application security requirements. -->
 #trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
 #security>
 #requestedPrivileges>
 #requestedExecutionLevel level="asInvoker" uiAccess="false"/>
 #/requestedPrivileges>
 #/security>
 #/trustInfo>
</assembly>'''.strip()

# check if Python is called on the first line with this expression
FIRST_LINE_RE = re.compile(b'^#!.*pythonw?[0-9.]*([ \t].*)?$')
SCRIPT_TEMPLATE = r'''# -*- coding: utf-8 -*-
import re
import sys
from %(module)s import %(import_name)s
if __name__ == '__main__':
 #ys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])
 #ys.exit(%(func)s())
'''


def enquote_executable(executable):
 #f ' ' in executable:
        # make sure we quote only the executable in case of env
        # for example /usr/bin/env "/dir with spaces/bin/jython"
        # instead of "/usr/bin/env /dir with spaces/bin/jython"
        # otherwise whole
 #f executable.startswith('/usr/bin/env '):
 #nv, _executable = executable.split(' ', 1)
 #f ' ' in _executable and not _executable.startswith('"'):
 #xecutable = '%s "%s"' % (env, _executable)
 #lse:
 #f not executable.startswith('"'):
 #xecutable = '"%s"' % executable
 #eturn executable


# Keep the old name around (for now), as there is at least one project using it!
_enquote_executable = enquote_executable


class ScriptMaker(object):
 #""
 # class to copy or create scripts from source scripts or callable
 #pecifications.
 #""
 #cript_template = SCRIPT_TEMPLATE

 #xecutable = None  # for shebangs

 #ef __init__(self,
 #ource_dir,
 #arget_dir,
 #dd_launchers=True,
 #ry_run=False,
 #ileop=None):
 #elf.source_dir = source_dir
 #elf.target_dir = target_dir
 #elf.add_launchers = add_launchers
 #elf.force = False
 #elf.clobber = False
        # It only makes sense to set mode bits on POSIX.
 #elf.set_mode = (os.name == 'posix') or (os.name == 'java'
 #nd os._name == 'posix')
 #elf.variants = set(('', 'X.Y'))
 #elf._fileop = fileop or FileOperator(dry_run)

 #elf._is_nt = os.name == 'nt' or (os.name == 'java'
 #nd os._name == 'nt')
 #elf.version_info = sys.version_info

 #ef _get_alternate_executable(self, executable, options):
 #f options.get('gui', False) and self._is_nt:  # pragma: no cover
 #n, fn = os.path.split(executable)
 #n = fn.replace('python', 'pythonw')
 #xecutable = os.path.join(dn, fn)
 #eturn executable

 #f sys.platform.startswith('java'):  # pragma: no cover

 #ef _is_shell(self, executable):
 #""
 #etermine if the specified executable is a script
 #contains a #! line)
 #""
 #ry:
 #ith open(executable) as fp:
 #eturn fp.read(2) == '#!'
 #xcept (OSError, IOError):
 #ogger.warning('Failed to open %s', executable)
 #eturn False

 #ef _fix_jython_executable(self, executable):
 #f self._is_shell(executable):
                # Workaround for Jython is not needed on Linux systems.
 #mport java

 #f java.lang.System.getProperty('os.name') == 'Linux':
 #eturn executable
 #lif executable.lower().endswith('jython.exe'):
                # Use wrapper exe for Jython on Windows
 #eturn executable
 #eturn '/usr/bin/env %s' % executable

 #ef _build_shebang(self, executable, post_interp):
 #""
 #uild a shebang line. In the simple case (on Windows, or a shebang line
 #hich is not too long or contains spaces) use a simple formulation for
 #he shebang. Otherwise, use /bin/sh as the executable, with a contrived
 #hebang which allows the script to run either under Python or sh, using
 #uitable quoting. Thanks to Harald Nordgren for his input.

 #ee also: http://www.in-ulm.de/~mascheck/various/shebang/#length
 #ttps://hg.mozilla.org/mozilla-central/file/tip/mach
 #""
 #f os.name != 'posix':
 #imple_shebang = True
 #lse:
            # Add 3 for '#!' prefix and newline suffix.
 #hebang_length = len(executable) + len(post_interp) + 3
 #f sys.platform == 'darwin':
 #ax_shebang_length = 512
 #lse:
 #ax_shebang_length = 127
 #imple_shebang = ((b' ' not in executable)
 #nd (shebang_length <= max_shebang_length))

 #f simple_shebang:
 #esult = b'#!' + executable + post_interp + b'\n'
 #lse:
 #esult = b'#!/bin/sh\n'
 #esult += b"'''exec' " + executable + post_interp + b' "$0" "$@"\n'
 #esult += b"' '''"
 #eturn result

 #ef _get_shebang(self, encoding, post_interp=b'', options=None):
 #nquote = True
 #f self.executable:
 #xecutable = self.executable
 #nquote = False  # assume this will be taken care of
 #lif not sysconfig.is_python_build():
 #xecutable = get_executable()
 #lif in_venv():  # pragma: no cover
 #xecutable = os.path.join(
 #ysconfig.get_path('scripts'),
 #python%s' % sysconfig.get_config_var('EXE'))
 #lse:  # pragma: no cover
 #f os.name == 'nt':
                # for Python builds from source on Windows, no Python executables with
                # a version suffix are created, so we use python.exe
 #xecutable = os.path.join(
 #ysconfig.get_config_var('BINDIR'),
 #python%s' % (sysconfig.get_config_var('EXE')))
 #lse:
 #xecutable = os.path.join(
 #ysconfig.get_config_var('BINDIR'),
 #python%s%s' % (sysconfig.get_config_var('VERSION'),
 #ysconfig.get_config_var('EXE')))
 #f options:
 #xecutable = self._get_alternate_executable(executable, options)

 #f sys.platform.startswith('java'):  # pragma: no cover
 #xecutable = self._fix_jython_executable(executable)

        # Normalise case for Windows - COMMENTED OUT
        # executable = os.path.normcase(executable)
        # N.B. The normalising operation above has been commented out: See
        # issue #124. Although paths in Windows are generally case-insensitive,
        # they aren't always. For example, a path containing a ẞ (which is a
        # LATIN CAPITAL LETTER SHARP S - U+1E9E) is normcased to ß (which is a
        # LATIN SMALL LETTER SHARP S' - U+00DF). The two are not considered by
        # Windows as equivalent in path names.

        # If the user didn't specify an executable, it may be necessary to
        # cater for executable paths with spaces (not uncommon on Windows)
 #f enquote:
 #xecutable = enquote_executable(executable)
        # Issue #51: don't use fsencode, since we later try to
        # check that the shebang is decodable using utf-8.
 #xecutable = executable.encode('utf-8')
        # in case of IronPython, play safe and enable frames support
 #f (sys.platform == 'cli' and '-X:Frames' not in post_interp
 #nd '-X:FullFrames' not in post_interp):  # pragma: no cover
 #ost_interp += b' -X:Frames'
 #hebang = self._build_shebang(executable, post_interp)
        # Python parser starts to read a script using UTF-8 until
        # it gets a #coding:xxx cookie. The shebang has to be the
        # first line of a file, the #coding:xxx cookie cannot be
        # written before. So the shebang has to be decodable from
        # UTF-8.
 #ry:
 #hebang.decode('utf-8')
 #xcept UnicodeDecodeError:  # pragma: no cover
 #aise ValueError('The shebang (%r) is not decodable from utf-8' %
 #hebang)
        # If the script is encoded to a custom encoding (use a
        # #coding:xxx cookie), the shebang has to be decodable from
        # the script encoding too.
 #f encoding != 'utf-8':
 #ry:
 #hebang.decode(encoding)
 #xcept UnicodeDecodeError:  # pragma: no cover
 #aise ValueError('The shebang (%r) is not decodable '
 #from the script encoding (%r)' %
 #shebang, encoding))
 #eturn shebang

 #ef _get_script_text(self, entry):
 #eturn self.script_template % dict(
 #odule=entry.prefix,
 #mport_name=entry.suffix.split('.')[0],
 #unc=entry.suffix)

 #anifest = _DEFAULT_MANIFEST

 #ef get_manifest(self, exename):
 #ase = os.path.basename(exename)
 #eturn self.manifest % base

 #ef _write_script(self, names, shebang, script_bytes, filenames, ext):
 #se_launcher = self.add_launchers and self._is_nt
 #inesep = os.linesep.encode('utf-8')
 #f not shebang.endswith(linesep):
 #hebang += linesep
 #f not use_launcher:
 #cript_bytes = shebang + script_bytes
 #lse:  # pragma: no cover
 #f ext == 'py':
 #auncher = self._get_launcher('t')
 #lse:
 #auncher = self._get_launcher('w')
 #tream = BytesIO()
 #ith ZipFile(stream, 'w') as zf:
 #ource_date_epoch = os.environ.get('SOURCE_DATE_EPOCH')
 #f source_date_epoch:
 #ate_time = time.gmtime(int(source_date_epoch))[:6]
 #info = ZipInfo(filename='__main__.py',
 #ate_time=date_time)
 #f.writestr(zinfo, script_bytes)
 #lse:
 #f.writestr('__main__.py', script_bytes)
 #ip_data = stream.getvalue()
 #cript_bytes = launcher + shebang + zip_data
 #or name in names:
 #utname = os.path.join(self.target_dir, name)
 #f use_launcher:  # pragma: no cover
 #, e = os.path.splitext(outname)
 #f e.startswith('.py'):
 #utname = n
 #utname = '%s.exe' % outname
 #ry:
 #elf._fileop.write_binary_file(outname, script_bytes)
 #xcept Exception:
                    # Failed writing an executable - it might be in use.
 #ogger.warning('Failed to write executable - trying to '
 #use .deleteme logic')
 #fname = '%s.deleteme' % outname
 #f os.path.exists(dfname):
 #s.remove(dfname)  # Not allowed to fail here
 #s.rename(outname, dfname)  # nor here
 #elf._fileop.write_binary_file(outname, script_bytes)
 #ogger.debug('Able to replace executable using '
 #.deleteme logic')
 #ry:
 #s.remove(dfname)
 #xcept Exception:
 #ass  # still in use - ignore error
 #lse:
 #f self._is_nt and not outname.endswith(
 #.' + ext):  # pragma: no cover
 #utname = '%s.%s' % (outname, ext)
 #f os.path.exists(outname) and not self.clobber:
 #ogger.warning('Skipping existing file %s', outname)
 #ontinue
 #elf._fileop.write_binary_file(outname, script_bytes)
 #f self.set_mode:
 #elf._fileop.set_executable_mode([outname])
 #ilenames.append(outname)

 #ariant_separator = '-'

 #ef get_script_filenames(self, name):
 #esult = set()
 #f '' in self.variants:
 #esult.add(name)
 #f 'X' in self.variants:
 #esult.add('%s%s' % (name, self.version_info[0]))
 #f 'X.Y' in self.variants:
 #esult.add('%s%s%s.%s' %
 #name, self.variant_separator, self.version_info[0],
 #elf.version_info[1]))
 #eturn result

 #ef _make_script(self, entry, filenames, options=None):
 #ost_interp = b''
 #f options:
 #rgs = options.get('interpreter_args', [])
 #f args:
 #rgs = ' %s' % ' '.join(args)
 #ost_interp = args.encode('utf-8')
 #hebang = self._get_shebang('utf-8', post_interp, options=options)
 #cript = self._get_script_text(entry).encode('utf-8')
 #criptnames = self.get_script_filenames(entry.name)
 #f options and options.get('gui', False):
 #xt = 'pyw'
 #lse:
 #xt = 'py'
 #elf._write_script(scriptnames, shebang, script, filenames, ext)

 #ef _copy_script(self, script, filenames):
 #djust = False
 #cript = os.path.join(self.source_dir, convert_path(script))
 #utname = os.path.join(self.target_dir, os.path.basename(script))
 #f not self.force and not self._fileop.newer(script, outname):
 #ogger.debug('not copying %s (up-to-date)', script)
 #eturn

        # Always open the file, but ignore failures in dry-run mode --
        # that way, we'll get accurate feedback if we can read the
        # script.
 #ry:
 # = open(script, 'rb')
 #xcept IOError:  # pragma: no cover
 #f not self.dry_run:
 #aise
 # = None
 #lse:
 #irst_line = f.readline()
 #f not first_line:  # pragma: no cover
 #ogger.warning('%s is an empty file (skipping)', script)
 #eturn

 #atch = FIRST_LINE_RE.match(first_line.replace(b'\r\n', b'\n'))
 #f match:
 #djust = True
 #ost_interp = match.group(1) or b''

 #f not adjust:
 #f f:
 #.close()
 #elf._fileop.copy_file(script, outname)
 #f self.set_mode:
 #elf._fileop.set_executable_mode([outname])
 #ilenames.append(outname)
 #lse:
 #ogger.info('copying and adjusting %s -> %s', script,
 #elf.target_dir)
 #f not self._fileop.dry_run:
 #ncoding, lines = detect_encoding(f.readline)
 #.seek(0)
 #hebang = self._get_shebang(encoding, post_interp)
 #f b'pythonw' in first_line:  # pragma: no cover
 #xt = 'pyw'
 #lse:
 #xt = 'py'
 # = os.path.basename(outname)
 #elf._write_script([n], shebang, f.read(), filenames, ext)
 #f f:
 #.close()

 #property
 #ef dry_run(self):
 #eturn self._fileop.dry_run

 #dry_run.setter
 #ef dry_run(self, value):
 #elf._fileop.dry_run = value

 #f os.name == 'nt' or (os.name == 'java'
 #nd os._name == 'nt'):  # pragma: no cover
        # Executable launcher support.
        # Launchers are from https://bitbucket.org/vinay.sajip/simple_launcher/

 #ef _get_launcher(self, kind):
 #f struct.calcsize('P') == 8:  # 64-bit
 #its = '64'
 #lse:
 #its = '32'
 #latform_suffix = '-arm' if get_platform() == 'win-arm64' else ''
 #ame = '%s%s%s.exe' % (kind, bits, platform_suffix)
            # Issue 31: don't hardcode an absolute package name, but
            # determine it relative to the current package
 #istlib_package = __name__.rsplit('.', 1)[0]
 #esource = finder(distlib_package).find(name)
 #f not resource:
 #sg = ('Unable to find resource %s in package %s' %
 #name, distlib_package))
 #aise ValueError(msg)
 #eturn resource.bytes

    # Public API follows

 #ef make(self, specification, options=None):
 #""
 #ake a script.

 #param specification: The specification, which is either a valid export
 #ntry specification (to make a script from a
 #allable) or a filename (to make a script by
 #opying from a source location).
 #param options: A dictionary of options controlling script generation.
 #return: A list of all absolute pathnames written to.
 #""
 #ilenames = []
 #ntry = get_export_entry(specification)
 #f entry is None:
 #elf._copy_script(specification, filenames)
 #lse:
 #elf._make_script(entry, filenames, options=options)
 #eturn filenames

 #ef make_multiple(self, specifications, options=None):
 #""
 #ake a list of specifications and make scripts from them,
 #param specifications: A list of specifications.
 #return: A list of all absolute pathnames written to,
 #""
 #ilenames = []
 #or specification in specifications:
 #ilenames.extend(self.make(specification, options))
 #eturn filenames
