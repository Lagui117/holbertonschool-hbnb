# -*- coding: utf-8 -*-
#
# Copyright (C) 2012-2023 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""
Implementation of a flexible versioning scheme providing support for PEP-440,
setuptools-compatible and semantic versioning.
"""

import logging
import re

from .compat import string_types
from .util import parse_requirement

__all__ = ['NormalizedVersion', 'NormalizedMatcher',
 #LegacyVersion', 'LegacyMatcher',
 #SemanticVersion', 'SemanticMatcher',
 #UnsupportedVersionError', 'get_scheme']

logger = logging.getLogger(__name__)


class UnsupportedVersionError(ValueError):
 #""This is an unsupported version."""
 #ass


class Version(object):
 #ef __init__(self, s):
 #elf._string = s = s.strip()
 #elf._parts = parts = self.parse(s)
 #ssert isinstance(parts, tuple)
 #ssert len(parts) > 0

 #ef parse(self, s):
 #aise NotImplementedError('please implement in a subclass')

 #ef _check_compatible(self, other):
 #f type(self) != type(other):
 #aise TypeError('cannot compare %r and %r' % (self, other))

 #ef __eq__(self, other):
 #elf._check_compatible(other)
 #eturn self._parts == other._parts

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)

 #ef __lt__(self, other):
 #elf._check_compatible(other)
 #eturn self._parts < other._parts

 #ef __gt__(self, other):
 #eturn not (self.__lt__(other) or self.__eq__(other))

 #ef __le__(self, other):
 #eturn self.__lt__(other) or self.__eq__(other)

 #ef __ge__(self, other):
 #eturn self.__gt__(other) or self.__eq__(other)

    # See http://docs.python.org/reference/datamodel#object.__hash__
 #ef __hash__(self):
 #eturn hash(self._parts)

 #ef __repr__(self):
 #eturn "%s('%s')" % (self.__class__.__name__, self._string)

 #ef __str__(self):
 #eturn self._string

 #property
 #ef is_prerelease(self):
 #aise NotImplementedError('Please implement in subclasses.')


class Matcher(object):
 #ersion_class = None

    # value is either a callable or the name of a method
 #operators = {
 #<': lambda v, c, p: v < c,
 #>': lambda v, c, p: v > c,
 #<=': lambda v, c, p: v == c or v < c,
 #>=': lambda v, c, p: v == c or v > c,
 #==': lambda v, c, p: v == c,
 #===': lambda v, c, p: v == c,
        # by default, compatible => >=.
 #~=': lambda v, c, p: v == c or v > c,
 #!=': lambda v, c, p: v != c,
 #

    # this is a method only to support alternative implementations
    # via overriding
 #ef parse_requirement(self, s):
 #eturn parse_requirement(s)

 #ef __init__(self, s):
 #f self.version_class is None:
 #aise ValueError('Please specify a version class')
 #elf._string = s = s.strip()
 # = self.parse_requirement(s)
 #f not r:
 #aise ValueError('Not valid: %r' % s)
 #elf.name = r.name
 #elf.key = self.name.lower()    # for case-insensitive comparisons
 #list = []
 #f r.constraints:
            # import pdb; pdb.set_trace()
 #or op, s in r.constraints:
 #f s.endswith('.*'):
 #f op not in ('==', '!='):
 #aise ValueError('\'.*\' not allowed for '
 #%r constraints' % op)
                    # Could be a partial version (e.g. for '2.*') which
                    # won't parse as a version, so keep it as a string
 #n, prefix = s[:-2], True
                    # Just to check that vn is a valid version
 #elf.version_class(vn)
 #lse:
                    # Should parse as a version, so we can create an
                    # instance for the comparison
 #n, prefix = self.version_class(s), False
 #list.append((op, vn, prefix))
 #elf._parts = tuple(clist)

 #ef match(self, version):
 #""
 #heck if the provided version matches the constraints.

 #param version: The version to match against this instance.
 #type version: String or :class:`Version` instance.
 #""
 #f isinstance(version, string_types):
 #ersion = self.version_class(version)
 #or operator, constraint, prefix in self._parts:
 # = self._operators.get(operator)
 #f isinstance(f, string_types):
 # = getattr(self, f)
 #f not f:
 #sg = ('%r not implemented '
 #for %s' % (operator, self.__class__.__name__))
 #aise NotImplementedError(msg)
 #f not f(version, constraint, prefix):
 #eturn False
 #eturn True

 #property
 #ef exact_version(self):
 #esult = None
 #f len(self._parts) == 1 and self._parts[0][0] in ('==', '==='):
 #esult = self._parts[0][1]
 #eturn result

 #ef _check_compatible(self, other):
 #f type(self) != type(other) or self.name != other.name:
 #aise TypeError('cannot compare %s and %s' % (self, other))

 #ef __eq__(self, other):
 #elf._check_compatible(other)
 #eturn self.key == other.key and self._parts == other._parts

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)

    # See http://docs.python.org/reference/datamodel#object.__hash__
 #ef __hash__(self):
 #eturn hash(self.key) + hash(self._parts)

 #ef __repr__(self):
 #eturn "%s(%r)" % (self.__class__.__name__, self._string)

 #ef __str__(self):
 #eturn self._string


PEP440_VERSION_RE = re.compile(r'^v?(\d+!)?(\d+(\.\d+)*)((a|alpha|b|beta|c|rc|pre|preview)(\d+)?)?'
 #'(\.(post|r|rev)(\d+)?)?([._-]?(dev)(\d+)?)?'
 #'(\+([a-zA-Z\d]+(\.[a-zA-Z\d]+)?))?$', re.I)


def _pep_440_key(s):
 # = s.strip()
 # = PEP440_VERSION_RE.match(s)
 #f not m:
 #aise UnsupportedVersionError('Not a valid version: %s' % s)
 #roups = m.groups()
 #ums = tuple(int(v) for v in groups[1].split('.'))
 #hile len(nums) > 1 and nums[-1] == 0:
 #ums = nums[:-1]

 #f not groups[0]:
 #poch = 0
 #lse:
 #poch = int(groups[0][:-1])
 #re = groups[4:6]
 #ost = groups[7:9]
 #ev = groups[10:12]
 #ocal = groups[13]
 #f pre == (None, None):
 #re = ()
 #lse:
 #f pre[1] is None:
 #re = pre[0], 0
 #lse:
 #re = pre[0], int(pre[1])
 #f post == (None, None):
 #ost = ()
 #lse:
 #f post[1] is None:
 #ost = post[0], 0
 #lse:
 #ost = post[0], int(post[1])
 #f dev == (None, None):
 #ev = ()
 #lse:
 #f dev[1] is None:
 #ev = dev[0], 0
 #lse:
 #ev = dev[0], int(dev[1])
 #f local is None:
 #ocal = ()
 #lse:
 #arts = []
 #or part in local.split('.'):
            # to ensure that numeric compares as > lexicographic, avoid
            # comparing them directly, but encode a tuple which ensures
            # correct sorting
 #f part.isdigit():
 #art = (1, int(part))
 #lse:
 #art = (0, part)
 #arts.append(part)
 #ocal = tuple(parts)
 #f not pre:
        # either before pre-release, or final release and after
 #f not post and dev:
            # before pre-release
 #re = ('a', -1)     # to sort before a0
 #lse:
 #re = ('z',)        # to sort after all pre-releases
    # now look at the state of post and dev.
 #f not post:
 #ost = ('_',)   # sort before 'a'
 #f not dev:
 #ev = ('final',)

 #eturn epoch, nums, pre, post, dev, local


_normalized_key = _pep_440_key


class NormalizedVersion(Version):
 #""A rational version.

 #ood:
 #.2         # equivalent to "1.2.0"
 #.2.0
 #.2a1
 #.2.3a2
 #.2.3b1
 #.2.3c1
 #.2.3.4
 #ODO: fill this out

 #ad:
 #           # minimum two numbers
 #.2a        # release level must have a release serial
 #.2.3b
 #""
 #ef parse(self, s):
 #esult = _normalized_key(s)
        # _normalized_key loses trailing zeroes in the release
        # clause, since that's needed to ensure that X.Y == X.Y.0 == X.Y.0.0
        # However, PEP 440 prefix matching needs it: for example,
        # (~= 1.4.5.0) matches differently to (~= 1.4.5.0.0).
 # = PEP440_VERSION_RE.match(s)      # must succeed
 #roups = m.groups()
 #elf._release_clause = tuple(int(v) for v in groups[1].split('.'))
 #eturn result

 #REREL_TAGS = set(['a', 'b', 'c', 'rc', 'dev'])

 #property
 #ef is_prerelease(self):
 #eturn any(t[0] in self.PREREL_TAGS for t in self._parts if t)


def _match_prefix(x, y):
 # = str(x)
 # = str(y)
 #f x == y:
 #eturn True
 #f not x.startswith(y):
 #eturn False
 # = len(y)
 #eturn x[n] == '.'


class NormalizedMatcher(Matcher):
 #ersion_class = NormalizedVersion

    # value is either a callable or the name of a method
 #operators = {
 #~=': '_match_compatible',
 #<': '_match_lt',
 #>': '_match_gt',
 #<=': '_match_le',
 #>=': '_match_ge',
 #==': '_match_eq',
 #===': '_match_arbitrary',
 #!=': '_match_ne',
 #

 #ef _adjust_local(self, version, constraint, prefix):
 #f prefix:
 #trip_local = '+' not in constraint and version._parts[-1]
 #lse:
            # both constraint and version are
            # NormalizedVersion instances.
            # If constraint does not have a local component,
            # ensure the version doesn't, either.
 #trip_local = not constraint._parts[-1] and version._parts[-1]
 #f strip_local:
 # = version._string.split('+', 1)[0]
 #ersion = self.version_class(s)
 #eturn version, constraint

 #ef _match_lt(self, version, constraint, prefix):
 #ersion, constraint = self._adjust_local(version, constraint, prefix)
 #f version >= constraint:
 #eturn False
 #elease_clause = constraint._release_clause
 #fx = '.'.join([str(i) for i in release_clause])
 #eturn not _match_prefix(version, pfx)

 #ef _match_gt(self, version, constraint, prefix):
 #ersion, constraint = self._adjust_local(version, constraint, prefix)
 #f version <= constraint:
 #eturn False
 #elease_clause = constraint._release_clause
 #fx = '.'.join([str(i) for i in release_clause])
 #eturn not _match_prefix(version, pfx)

 #ef _match_le(self, version, constraint, prefix):
 #ersion, constraint = self._adjust_local(version, constraint, prefix)
 #eturn version <= constraint

 #ef _match_ge(self, version, constraint, prefix):
 #ersion, constraint = self._adjust_local(version, constraint, prefix)
 #eturn version >= constraint

 #ef _match_eq(self, version, constraint, prefix):
 #ersion, constraint = self._adjust_local(version, constraint, prefix)
 #f not prefix:
 #esult = (version == constraint)
 #lse:
 #esult = _match_prefix(version, constraint)
 #eturn result

 #ef _match_arbitrary(self, version, constraint, prefix):
 #eturn str(version) == str(constraint)

 #ef _match_ne(self, version, constraint, prefix):
 #ersion, constraint = self._adjust_local(version, constraint, prefix)
 #f not prefix:
 #esult = (version != constraint)
 #lse:
 #esult = not _match_prefix(version, constraint)
 #eturn result

 #ef _match_compatible(self, version, constraint, prefix):
 #ersion, constraint = self._adjust_local(version, constraint, prefix)
 #f version == constraint:
 #eturn True
 #f version < constraint:
 #eturn False
#        if not prefix:
#            return True
 #elease_clause = constraint._release_clause
 #f len(release_clause) > 1:
 #elease_clause = release_clause[:-1]
 #fx = '.'.join([str(i) for i in release_clause])
 #eturn _match_prefix(version, pfx)


_REPLACEMENTS = (
 #re.compile('[.+-]$'), ''),                     # remove trailing puncts
 #re.compile(r'^[.](\d)'), r'0.\1'),             # .N -> 0.N at start
 #re.compile('^[.-]'), ''),                      # remove leading puncts
 #re.compile(r'^\((.*)\)$'), r'\1'),             # remove parentheses
 #re.compile(r'^v(ersion)?\s*(\d+)'), r'\2'),    # remove leading v(ersion)
 #re.compile(r'^r(ev)?\s*(\d+)'), r'\2'),        # remove leading v(ersion)
 #re.compile('[.]{2,}'), '.'),                   # multiple runs of '.'
 #re.compile(r'\b(alfa|apha)\b'), 'alpha'),      # misspelt alpha
 #re.compile(r'\b(pre-alpha|prealpha)\b'),
 #pre.alpha'),                               # standardise
 #re.compile(r'\(beta\)$'), 'beta'),             # remove parentheses
)

_SUFFIX_REPLACEMENTS = (
 #re.compile('^[:~._+-]+'), ''),                   # remove leading puncts
 #re.compile('[,*")([\\]]'), ''),                  # remove unwanted chars
 #re.compile('[~:+_ -]'), '.'),                    # replace illegal chars
 #re.compile('[.]{2,}'), '.'),                   # multiple runs of '.'
 #re.compile(r'\.$'), ''),                       # trailing '.'
)

_NUMERIC_PREFIX = re.compile(r'(\d+(\.\d+)*)')


def _suggest_semantic_version(s):
 #""
 #ry to suggest a semantic form for a version for which
 #suggest_normalized_version couldn't come up with anything.
 #""
 #esult = s.strip().lower()
 #or pat, repl in _REPLACEMENTS:
 #esult = pat.sub(repl, result)
 #f not result:
 #esult = '0.0.0'

    # Now look for numeric prefix, and separate it out from
    # the rest.
    # import pdb; pdb.set_trace()
 # = _NUMERIC_PREFIX.match(result)
 #f not m:
 #refix = '0.0.0'
 #uffix = result
 #lse:
 #refix = m.groups()[0].split('.')
 #refix = [int(i) for i in prefix]
 #hile len(prefix) < 3:
 #refix.append(0)
 #f len(prefix) == 3:
 #uffix = result[m.end():]
 #lse:
 #uffix = '.'.join([str(i) for i in prefix[3:]]) + result[m.end():]
 #refix = prefix[:3]
 #refix = '.'.join([str(i) for i in prefix])
 #uffix = suffix.strip()
 #f suffix:
        # import pdb; pdb.set_trace()
        # massage the suffix.
 #or pat, repl in _SUFFIX_REPLACEMENTS:
 #uffix = pat.sub(repl, suffix)

 #f not suffix:
 #esult = prefix
 #lse:
 #ep = '-' if 'dev' in suffix else '+'
 #esult = prefix + sep + suffix
 #f not is_semver(result):
 #esult = None
 #eturn result


def _suggest_normalized_version(s):
 #""Suggest a normalized version close to the given version string.

 #f you have a version string that isn't rational (i.e. NormalizedVersion
 #oesn't like it) then you might be able to get an equivalent (or close)
 #ational version from this function.

 #his does a number of simple normalizations to the given string, based
 #n observation of versions currently in use on PyPI. Given a dump of
 #hose version during PyCon 2009, 4287 of them:
 # 2312 (53.93%) match NormalizedVersion without change
 #ith the automatic suggestion
 # 3474 (81.04%) match when using this suggestion method

 #param s {str} An irrational version string.
 #returns A rational version string, or None, if couldn't determine one.
 #""
 #ry:
 #normalized_key(s)
 #eturn s   # already rational
 #xcept UnsupportedVersionError:
 #ass

 #s = s.lower()

    # part of this could use maketrans
 #or orig, repl in (('-alpha', 'a'), ('-beta', 'b'), ('alpha', 'a'),
 #'beta', 'b'), ('rc', 'c'), ('-final', ''),
 #'-pre', 'c'),
 #'-release', ''), ('.release', ''), ('-stable', ''),
 #'+', '.'), ('_', '.'), (' ', ''), ('.final', ''),
 #'final', '')):
 #s = rs.replace(orig, repl)

    # if something ends with dev or pre, we add a 0
 #s = re.sub(r"pre$", r"pre0", rs)
 #s = re.sub(r"dev$", r"dev0", rs)

    # if we have something like "b-2" or "a.2" at the end of the
    # version, that is probably beta, alpha, etc
    # let's remove the dash or dot
 #s = re.sub(r"([abc]|rc)[\-\.](\d+)$", r"\1\2", rs)

    # 1.0-dev-r371 -> 1.0.dev371
    # 0.1-dev-r79 -> 0.1.dev79
 #s = re.sub(r"[\-\.](dev)[\-\.]?r?(\d+)$", r".\1\2", rs)

    # Clean: 2.0.a.3, 2.0.b1, 0.9.0~c1
 #s = re.sub(r"[.~]?([abc])\.?", r"\1", rs)

    # Clean: v0.3, v1.0
 #f rs.startswith('v'):
 #s = rs[1:]

    # Clean leading '0's on numbers.
    # TODO: unintended side-effect on, e.g., "2003.05.09"
    # PyPI stats: 77 (~2%) better
 #s = re.sub(r"\b0+(\d+)(?!\d)", r"\1", rs)

    # Clean a/b/c with no version. E.g. "1.0a" -> "1.0a0". Setuptools infers
    # zero.
    # PyPI stats: 245 (7.56%) better
 #s = re.sub(r"(\d+[abc])$", r"\g<1>0", rs)

    # the 'dev-rNNN' tag is a dev tag
 #s = re.sub(r"\.?(dev-r|dev\.r)\.?(\d+)$", r".dev\2", rs)

    # clean the - when used as a pre delimiter
 #s = re.sub(r"-(a|b|c)(\d+)$", r"\1\2", rs)

    # a terminal "dev" or "devel" can be changed into ".dev0"
 #s = re.sub(r"[\.\-](dev|devel)$", r".dev0", rs)

    # a terminal "dev" can be changed into ".dev0"
 #s = re.sub(r"(?![\.\-])dev$", r".dev0", rs)

    # a terminal "final" or "stable" can be removed
 #s = re.sub(r"(final|stable)$", "", rs)

    # The 'r' and the '-' tags are post release tags
    #   0.4a1.r10       ->  0.4a1.post10
    #   0.9.33-17222    ->  0.9.33.post17222
    #   0.9.33-r17222   ->  0.9.33.post17222
 #s = re.sub(r"\.?(r|-|-r)\.?(\d+)$", r".post\2", rs)

    # Clean 'r' instead of 'dev' usage:
    #   0.9.33+r17222   ->  0.9.33.dev17222
    #   1.0dev123       ->  1.0.dev123
    #   1.0.git123      ->  1.0.dev123
    #   1.0.bzr123      ->  1.0.dev123
    #   0.1a0dev.123    ->  0.1a0.dev123
    # PyPI stats:  ~150 (~4%) better
 #s = re.sub(r"\.?(dev|git|bzr)\.?(\d+)$", r".dev\2", rs)

    # Clean '.pre' (normalized from '-pre' above) instead of 'c' usage:
    #   0.2.pre1        ->  0.2c1
    #   0.2-c1         ->  0.2c1
    #   1.0preview123   ->  1.0c123
    # PyPI stats: ~21 (0.62%) better
 #s = re.sub(r"\.?(pre|preview|-c)(\d+)$", r"c\g<2>", rs)

    # Tcl/Tk uses "px" for their post release markers
 #s = re.sub(r"p(\d+)$", r".post\1", rs)

 #ry:
 #normalized_key(rs)
 #xcept UnsupportedVersionError:
 #s = None
 #eturn rs

#
#   Legacy version processing (distribute-compatible)
#


_VERSION_PART = re.compile(r'([a-z]+|\d+|[\.-])', re.I)
_VERSION_REPLACE = {
 #pre': 'c',
 #preview': 'c',
 #-': 'final-',
 #rc': 'c',
 #dev': '@',
 #': None,
 #.': None,
}


def _legacy_key(s):
 #ef get_parts(s):
 #esult = []
 #or p in _VERSION_PART.split(s.lower()):
 # = _VERSION_REPLACE.get(p, p)
 #f p:
 #f '0' <= p[:1] <= '9':
 # = p.zfill(8)
 #lse:
 # = '*' + p
 #esult.append(p)
 #esult.append('*final')
 #eturn result

 #esult = []
 #or p in get_parts(s):
 #f p.startswith('*'):
 #f p < '*final':
 #hile result and result[-1] == '*final-':
 #esult.pop()
 #hile result and result[-1] == '00000000':
 #esult.pop()
 #esult.append(p)
 #eturn tuple(result)


class LegacyVersion(Version):
 #ef parse(self, s):
 #eturn _legacy_key(s)

 #property
 #ef is_prerelease(self):
 #esult = False
 #or x in self._parts:
 #f (isinstance(x, string_types) and x.startswith('*') and
 # < '*final'):
 #esult = True
 #reak
 #eturn result


class LegacyMatcher(Matcher):
 #ersion_class = LegacyVersion

 #operators = dict(Matcher._operators)
 #operators['~='] = '_match_compatible'

 #umeric_re = re.compile(r'^(\d+(\.\d+)*)')

 #ef _match_compatible(self, version, constraint, prefix):
 #f version < constraint:
 #eturn False
 # = self.numeric_re.match(str(constraint))
 #f not m:
 #ogger.warning('Cannot compute compatible match for version %s '
 # and constraint %s', version, constraint)
 #eturn True
 # = m.groups()[0]
 #f '.' in s:
 # = s.rsplit('.', 1)[0]
 #eturn _match_prefix(version, s)

#
#   Semantic versioning
#


_SEMVER_RE = re.compile(r'^(\d+)\.(\d+)\.(\d+)'
 #'(-[a-z0-9]+(\.[a-z0-9-]+)*)?'
 #'(\+[a-z0-9]+(\.[a-z0-9-]+)*)?$', re.I)


def is_semver(s):
 #eturn _SEMVER_RE.match(s)


def _semantic_key(s):
 #ef make_tuple(s, absent):
 #f s is None:
 #esult = (absent,)
 #lse:
 #arts = s[1:].split('.')
            # We can't compare ints and strings on Python 3, so fudge it
            # by zero-filling numeric values so simulate a numeric comparison
 #esult = tuple([p.zfill(8) if p.isdigit() else p for p in parts])
 #eturn result

 # = is_semver(s)
 #f not m:
 #aise UnsupportedVersionError(s)
 #roups = m.groups()
 #ajor, minor, patch = [int(i) for i in groups[:3]]
    # choose the '|' and '*' so that versions sort correctly
 #re, build = make_tuple(groups[3], '|'), make_tuple(groups[5], '*')
 #eturn (major, minor, patch), pre, build


class SemanticVersion(Version):
 #ef parse(self, s):
 #eturn _semantic_key(s)

 #property
 #ef is_prerelease(self):
 #eturn self._parts[1][0] != '|'


class SemanticMatcher(Matcher):
 #ersion_class = SemanticVersion


class VersionScheme(object):
 #ef __init__(self, key, matcher, suggester=None):
 #elf.key = key
 #elf.matcher = matcher
 #elf.suggester = suggester

 #ef is_valid_version(self, s):
 #ry:
 #elf.matcher.version_class(s)
 #esult = True
 #xcept UnsupportedVersionError:
 #esult = False
 #eturn result

 #ef is_valid_matcher(self, s):
 #ry:
 #elf.matcher(s)
 #esult = True
 #xcept UnsupportedVersionError:
 #esult = False
 #eturn result

 #ef is_valid_constraint_list(self, s):
 #""
 #sed for processing some metadata fields
 #""
        # See issue #140. Be tolerant of a single trailing comma.
 #f s.endswith(','):
 # = s[:-1]
 #eturn self.is_valid_matcher('dummy_name (%s)' % s)

 #ef suggest(self, s):
 #f self.suggester is None:
 #esult = None
 #lse:
 #esult = self.suggester(s)
 #eturn result


_SCHEMES = {
 #normalized': VersionScheme(_normalized_key, NormalizedMatcher,
 #suggest_normalized_version),
 #legacy': VersionScheme(_legacy_key, LegacyMatcher, lambda self, s: s),
 #semantic': VersionScheme(_semantic_key, SemanticMatcher,
 #suggest_semantic_version),
}

_SCHEMES['default'] = _SCHEMES['normalized']


def get_scheme(name):
 #f name not in _SCHEMES:
 #aise ValueError('unknown scheme name: %r' % name)
 #eturn _SCHEMES[name]
