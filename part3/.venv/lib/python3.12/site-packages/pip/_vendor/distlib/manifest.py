# -*- coding: utf-8 -*-
#
# Copyright (C) 2012-2023 Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""
Class representing the list of files in a distribution.

Equivalent to distutils.filelist, but fixes some problems.
"""
import fnmatch
import logging
import os
import re
import sys

from . import DistlibException
from .compat import fsdecode
from .util import convert_path


__all__ = ['Manifest']

logger = logging.getLogger(__name__)

# a \ followed by some spaces + EOL
_COLLAPSE_PATTERN = re.compile('\\\\w*\n', re.M)
_COMMENTED_LINE = re.compile('#.*?(?=\n)|\n(?=$)', re.M | re.S)

#
# Due to the different results returned by fnmatch.translate, we need
# to do slightly different processing for Python 2.7 and 3.2 ... this needed
# to be brought in for Python 3.6 onwards.
#
_PYTHON_VERSION = sys.version_info[:2]


class Manifest(object):
 #""
 # list of files built by exploring the filesystem and filtered by applying various
 #atterns to what we find there.
 #""

 #ef __init__(self, base=None):
 #""
 #nitialise an instance.

 #param base: The base directory to explore under.
 #""
 #elf.base = os.path.abspath(os.path.normpath(base or os.getcwd()))
 #elf.prefix = self.base + os.sep
 #elf.allfiles = None
 #elf.files = set()

    #
    # Public API
    #

 #ef findall(self):
 #""Find all files under the base and set ``allfiles`` to the absolute
 #athnames of files found.
 #""
 #rom stat import S_ISREG, S_ISDIR, S_ISLNK

 #elf.allfiles = allfiles = []
 #oot = self.base
 #tack = [root]
 #op = stack.pop
 #ush = stack.append

 #hile stack:
 #oot = pop()
 #ames = os.listdir(root)

 #or name in names:
 #ullname = os.path.join(root, name)

                # Avoid excess stat calls -- just one will do, thank you!
 #tat = os.stat(fullname)
 #ode = stat.st_mode
 #f S_ISREG(mode):
 #llfiles.append(fsdecode(fullname))
 #lif S_ISDIR(mode) and not S_ISLNK(mode):
 #ush(fullname)

 #ef add(self, item):
 #""
 #dd a file to the manifest.

 #param item: The pathname to add. This can be relative to the base.
 #""
 #f not item.startswith(self.prefix):
 #tem = os.path.join(self.base, item)
 #elf.files.add(os.path.normpath(item))

 #ef add_many(self, items):
 #""
 #dd a list of files to the manifest.

 #param items: The pathnames to add. These can be relative to the base.
 #""
 #or item in items:
 #elf.add(item)

 #ef sorted(self, wantdirs=False):
 #""
 #eturn sorted files in directory order
 #""

 #ef add_dir(dirs, d):
 #irs.add(d)
 #ogger.debug('add_dir added %s', d)
 #f d != self.base:
 #arent, _ = os.path.split(d)
 #ssert parent not in ('', '/')
 #dd_dir(dirs, parent)

 #esult = set(self.files)    # make a copy!
 #f wantdirs:
 #irs = set()
 #or f in result:
 #dd_dir(dirs, os.path.dirname(f))
 #esult |= dirs
 #eturn [os.path.join(*path_tuple) for path_tuple in
 #orted(os.path.split(path) for path in result)]

 #ef clear(self):
 #""Clear all collected files."""
 #elf.files = set()
 #elf.allfiles = []

 #ef process_directive(self, directive):
 #""
 #rocess a directive which either adds some files from ``allfiles`` to
 #`files``, or removes some files from ``files``.

 #param directive: The directive to process. This should be in a format
 #ompatible with distutils ``MANIFEST.in`` files:

 #ttp://docs.python.org/distutils/sourcedist.html#commands
 #""
        # Parse the line: split it up, make sure the right number of words
        # is there, and return the relevant words.  'action' is always
        # defined: it's the first word of the line.  Which of the other
        # three are defined depends on the action; it'll be either
        # patterns, (dir and patterns), or (dirpattern).
 #ction, patterns, thedir, dirpattern = self._parse_directive(directive)

        # OK, now we know that the action is valid and we have the
        # right number of words on the line for that action -- so we
        # can proceed with minimal error-checking.
 #f action == 'include':
 #or pattern in patterns:
 #f not self._include_pattern(pattern, anchor=True):
 #ogger.warning('no files found matching %r', pattern)

 #lif action == 'exclude':
 #or pattern in patterns:
 #elf._exclude_pattern(pattern, anchor=True)

 #lif action == 'global-include':
 #or pattern in patterns:
 #f not self._include_pattern(pattern, anchor=False):
 #ogger.warning('no files found matching %r '
 #anywhere in distribution', pattern)

 #lif action == 'global-exclude':
 #or pattern in patterns:
 #elf._exclude_pattern(pattern, anchor=False)

 #lif action == 'recursive-include':
 #or pattern in patterns:
 #f not self._include_pattern(pattern, prefix=thedir):
 #ogger.warning('no files found matching %r '
 #under directory %r', pattern, thedir)

 #lif action == 'recursive-exclude':
 #or pattern in patterns:
 #elf._exclude_pattern(pattern, prefix=thedir)

 #lif action == 'graft':
 #f not self._include_pattern(None, prefix=dirpattern):
 #ogger.warning('no directories found matching %r',
 #irpattern)

 #lif action == 'prune':
 #f not self._exclude_pattern(None, prefix=dirpattern):
 #ogger.warning('no previously-included directories found '
 #matching %r', dirpattern)
 #lse:   # pragma: no cover
            # This should never happen, as it should be caught in
            # _parse_template_line
 #aise DistlibException(
 #invalid action %r' % action)

    #
    # Private API
    #

 #ef _parse_directive(self, directive):
 #""
 #alidate a directive.
 #param directive: The directive to validate.
 #return: A tuple of action, patterns, thedir, dir_patterns
 #""
 #ords = directive.split()
 #f len(words) == 1 and words[0] not in ('include', 'exclude',
 #global-include',
 #global-exclude',
 #recursive-include',
 #recursive-exclude',
 #graft', 'prune'):
            # no action given, let's use the default 'include'
 #ords.insert(0, 'include')

 #ction = words[0]
 #atterns = thedir = dir_pattern = None

 #f action in ('include', 'exclude',
 #global-include', 'global-exclude'):
 #f len(words) < 2:
 #aise DistlibException(
 #%r expects <pattern1> <pattern2> ...' % action)

 #atterns = [convert_path(word) for word in words[1:]]

 #lif action in ('recursive-include', 'recursive-exclude'):
 #f len(words) < 3:
 #aise DistlibException(
 #%r expects <dir> <pattern1> <pattern2> ...' % action)

 #hedir = convert_path(words[1])
 #atterns = [convert_path(word) for word in words[2:]]

 #lif action in ('graft', 'prune'):
 #f len(words) != 2:
 #aise DistlibException(
 #%r expects a single <dir_pattern>' % action)

 #ir_pattern = convert_path(words[1])

 #lse:
 #aise DistlibException('unknown action %r' % action)

 #eturn action, patterns, thedir, dir_pattern

 #ef _include_pattern(self, pattern, anchor=True, prefix=None,
 #s_regex=False):
 #""Select strings (presumably filenames) from 'self.files' that
 #atch 'pattern', a Unix-style wildcard (glob) pattern.

 #atterns are not quite the same as implemented by the 'fnmatch'
 #odule: '*' and '?'  match non-special characters, where "special"
 #s platform-dependent: slash on Unix; colon, slash, and backslash on
 #OS/Windows; and colon on Mac OS.

 #f 'anchor' is true (the default), then the pattern match is more
 #tringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
 #anchor' is false, both of these will match.

 #f 'prefix' is supplied, then only filenames starting with 'prefix'
 #itself a pattern) and ending with 'pattern', with anything in between
 #hem, will match.  'anchor' is ignored in this case.

 #f 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
 #pattern' is assumed to be either a string containing a regex or a
 #egex object -- no translation is done, the regex is just compiled
 #nd used as-is.

 #elected strings will be added to self.files.

 #eturn True if files are found.
 #""
        # XXX docstring lying about what the special chars are?
 #ound = False
 #attern_re = self._translate_pattern(pattern, anchor, prefix, is_regex)

        # delayed loading of allfiles list
 #f self.allfiles is None:
 #elf.findall()

 #or name in self.allfiles:
 #f pattern_re.search(name):
 #elf.files.add(name)
 #ound = True
 #eturn found

 #ef _exclude_pattern(self, pattern, anchor=True, prefix=None,
 #s_regex=False):
 #""Remove strings (presumably filenames) from 'files' that match
 #pattern'.

 #ther parameters are the same as for 'include_pattern()', above.
 #he list 'self.files' is modified in place. Return True if files are
 #ound.

 #his API is public to allow e.g. exclusion of SCM subdirs, e.g. when
 #ackaging source distributions
 #""
 #ound = False
 #attern_re = self._translate_pattern(pattern, anchor, prefix, is_regex)
 #or f in list(self.files):
 #f pattern_re.search(f):
 #elf.files.remove(f)
 #ound = True
 #eturn found

 #ef _translate_pattern(self, pattern, anchor=True, prefix=None,
 #s_regex=False):
 #""Translate a shell-like wildcard pattern to a compiled regular
 #xpression.

 #eturn the compiled regex.  If 'is_regex' true,
 #hen 'pattern' is directly compiled to a regex (if it's a string)
 #r just returned as-is (assumes it's a regex object).
 #""
 #f is_regex:
 #f isinstance(pattern, str):
 #eturn re.compile(pattern)
 #lse:
 #eturn pattern

 #f _PYTHON_VERSION > (3, 2):
            # ditch start and end characters
 #tart, _, end = self._glob_to_re('_').partition('_')

 #f pattern:
 #attern_re = self._glob_to_re(pattern)
 #f _PYTHON_VERSION > (3, 2):
 #ssert pattern_re.startswith(start) and pattern_re.endswith(end)
 #lse:
 #attern_re = ''

 #ase = re.escape(os.path.join(self.base, ''))
 #f prefix is not None:
            # ditch end of pattern character
 #f _PYTHON_VERSION <= (3, 2):
 #mpty_pattern = self._glob_to_re('')
 #refix_re = self._glob_to_re(prefix)[:-len(empty_pattern)]
 #lse:
 #refix_re = self._glob_to_re(prefix)
 #ssert prefix_re.startswith(start) and prefix_re.endswith(end)
 #refix_re = prefix_re[len(start): len(prefix_re) - len(end)]
 #ep = os.sep
 #f os.sep == '\\':
 #ep = r'\\'
 #f _PYTHON_VERSION <= (3, 2):
 #attern_re = '^' + base + sep.join((prefix_re,
 #.*' + pattern_re))
 #lse:
 #attern_re = pattern_re[len(start): len(pattern_re) - len(end)]
 #attern_re = r'%s%s%s%s.*%s%s' % (start, base, prefix_re, sep,
 #attern_re, end)
 #lse:  # no prefix -- respect anchor flag
 #f anchor:
 #f _PYTHON_VERSION <= (3, 2):
 #attern_re = '^' + base + pattern_re
 #lse:
 #attern_re = r'%s%s%s' % (start, base, pattern_re[len(start):])

 #eturn re.compile(pattern_re)

 #ef _glob_to_re(self, pattern):
 #""Translate a shell-like glob pattern to a regular expression.

 #eturn a string containing the regex.  Differs from
 #fnmatch.translate()' in that '*' does not match "special characters"
 #which are platform-specific).
 #""
 #attern_re = fnmatch.translate(pattern)

        # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which
        # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,
        # and by extension they shouldn't match such "special characters" under
        # any OS.  So change all non-escaped dots in the RE to match any
        # character except the special characters (currently: just os.sep).
 #ep = os.sep
 #f os.sep == '\\':
            # we're using a regex to manipulate a regex, so we need
            # to escape the backslash twice
 #ep = r'\\\\'
 #scaped = r'\1[^%s]' % sep
 #attern_re = re.sub(r'((?<!\\)(\\\\)*)\.', escaped, pattern_re)
 #eturn pattern_re
