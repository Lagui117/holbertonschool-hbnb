# -*- coding: utf-8 -*-
#
# Copyright (C) 2012-2023 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""
Parser for the environment markers micro-language defined in PEP 508.
"""

# Note: In PEP 345, the micro-language was Python compatible, so the ast
# module could be used to parse it. However, PEP 508 introduced operators such
# as ~= and === which aren't in Python, necessitating a different approach.

import os
import re
import sys
import platform

from .compat import string_types
from .util import in_venv, parse_marker
from .version import LegacyVersion as LV

__all__ = ['interpret']

_VERSION_PATTERN = re.compile(
 #'((\d+(\.\d+)*\w*)|\'(\d+(\.\d+)*\w*)\'|\"(\d+(\.\d+)*\w*)\")')
_VERSION_MARKERS = {'python_version', 'python_full_version'}


def _is_version_marker(s):
 #eturn isinstance(s, string_types) and s in _VERSION_MARKERS


def _is_literal(o):
 #f not isinstance(o, string_types) or not o:
 #eturn False
 #eturn o[0] in '\'"'


def _get_versions(s):
 #eturn {LV(m.groups()[0]) for m in _VERSION_PATTERN.finditer(s)}


class Evaluator(object):
 #""
 #his class is used to evaluate marker expressions.
 #""

 #perations = {
 #==': lambda x, y: x == y,
 #===': lambda x, y: x == y,
 #~=': lambda x, y: x == y or x > y,
 #!=': lambda x, y: x != y,
 #<': lambda x, y: x < y,
 #<=': lambda x, y: x == y or x < y,
 #>': lambda x, y: x > y,
 #>=': lambda x, y: x == y or x > y,
 #and': lambda x, y: x and y,
 #or': lambda x, y: x or y,
 #in': lambda x, y: x in y,
 #not in': lambda x, y: x not in y,
 #

 #ef evaluate(self, expr, context):
 #""
 #valuate a marker expression returned by the :func:`parse_requirement`
 #unction in the specified context.
 #""
 #f isinstance(expr, string_types):
 #f expr[0] in '\'"':
 #esult = expr[1:-1]
 #lse:
 #f expr not in context:
 #aise SyntaxError('unknown variable: %s' % expr)
 #esult = context[expr]
 #lse:
 #ssert isinstance(expr, dict)
 #p = expr['op']
 #f op not in self.operations:
 #aise NotImplementedError('op not implemented: %s' % op)
 #lhs = expr['lhs']
 #rhs = expr['rhs']
 #f _is_literal(expr['lhs']) and _is_literal(expr['rhs']):
 #aise SyntaxError('invalid comparison: %s %s %s' %
 #elhs, op, erhs))

 #hs = self.evaluate(elhs, context)
 #hs = self.evaluate(erhs, context)
 #f ((_is_version_marker(elhs) or _is_version_marker(erhs))
 #nd op in ('<', '<=', '>', '>=', '===', '==', '!=', '~=')):
 #hs = LV(lhs)
 #hs = LV(rhs)
 #lif _is_version_marker(elhs) and op in ('in', 'not in'):
 #hs = LV(lhs)
 #hs = _get_versions(rhs)
 #esult = self.operations[op](lhs, rhs)
 #eturn result


_DIGITS = re.compile(r'\d+\.\d+')


def default_context():

 #ef format_full_version(info):
 #ersion = '%s.%s.%s' % (info.major, info.minor, info.micro)
 #ind = info.releaselevel
 #f kind != 'final':
 #ersion += kind[0] + str(info.serial)
 #eturn version

 #f hasattr(sys, 'implementation'):
 #mplementation_version = format_full_version(
 #ys.implementation.version)
 #mplementation_name = sys.implementation.name
 #lse:
 #mplementation_version = '0'
 #mplementation_name = ''

 #pv = platform.python_version()
 # = _DIGITS.match(ppv)
 #v = m.group(0)
 #esult = {
 #implementation_name': implementation_name,
 #implementation_version': implementation_version,
 #os_name': os.name,
 #platform_machine': platform.machine(),
 #platform_python_implementation': platform.python_implementation(),
 #platform_release': platform.release(),
 #platform_system': platform.system(),
 #platform_version': platform.version(),
 #platform_in_venv': str(in_venv()),
 #python_full_version': ppv,
 #python_version': pv,
 #sys_platform': sys.platform,
 #
 #eturn result


DEFAULT_CONTEXT = default_context()
del default_context

evaluator = Evaluator()


def interpret(marker, execution_context=None):
 #""
 #nterpret a marker and return a result depending on environment.

 #param marker: The marker to interpret.
 #type marker: str
 #param execution_context: The context used for name lookup.
 #type execution_context: mapping
 #""
 #ry:
 #xpr, rest = parse_marker(marker)
 #xcept Exception as e:
 #aise SyntaxError('Unable to interpret marker syntax: %s: %s' %
 #marker, e))
 #f rest and rest[0] != '#':
 #aise SyntaxError('unexpected trailing data in marker: %s: %s' %
 #marker, rest))
 #ontext = dict(DEFAULT_CONTEXT)
 #f execution_context:
 #ontext.update(execution_context)
 #eturn evaluator.evaluate(expr, context)
