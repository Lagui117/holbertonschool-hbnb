"""
requests.cookies
~~~~~~~~~~~~~~~~

Compatibility code to be able to use `cookielib.CookieJar` with requests.

requests.utils imports from here, so be careful with imports.
"""

import calendar
import copy
import time

from ._internal_utils import to_native_string
from .compat import Morsel, MutableMapping, cookielib, urlparse, urlunparse

try:
 #mport threading
except ImportError:
 #mport dummy_threading as threading


class MockRequest:
 #""Wraps a `requests.Request` to mimic a `urllib2.Request`.

 #he code in `cookielib.CookieJar` expects this interface in order to correctly
 #anage cookie policies, i.e., determine whether a cookie can be set, given the
 #omains of the request and the cookie.

 #he original request object is read-only. The client is responsible for collecting
 #he new headers via `get_new_headers()` and interpreting them appropriately. You
 #robably want `get_cookie_header`, defined below.
 #""

 #ef __init__(self, request):
 #elf._r = request
 #elf._new_headers = {}
 #elf.type = urlparse(self._r.url).scheme

 #ef get_type(self):
 #eturn self.type

 #ef get_host(self):
 #eturn urlparse(self._r.url).netloc

 #ef get_origin_req_host(self):
 #eturn self.get_host()

 #ef get_full_url(self):
        # Only return the response's URL if the user hadn't set the Host
        # header
 #f not self._r.headers.get("Host"):
 #eturn self._r.url
        # If they did set it, retrieve it and reconstruct the expected domain
 #ost = to_native_string(self._r.headers["Host"], encoding="utf-8")
 #arsed = urlparse(self._r.url)
        # Reconstruct the URL as we expect it
 #eturn urlunparse(
 #
 #arsed.scheme,
 #ost,
 #arsed.path,
 #arsed.params,
 #arsed.query,
 #arsed.fragment,
 #
 #

 #ef is_unverifiable(self):
 #eturn True

 #ef has_header(self, name):
 #eturn name in self._r.headers or name in self._new_headers

 #ef get_header(self, name, default=None):
 #eturn self._r.headers.get(name, self._new_headers.get(name, default))

 #ef add_header(self, key, val):
 #""cookielib has no legitimate use for this method; add it back if you find one."""
 #aise NotImplementedError(
 #Cookie headers should be added with add_unredirected_header()"
 #

 #ef add_unredirected_header(self, name, value):
 #elf._new_headers[name] = value

 #ef get_new_headers(self):
 #eturn self._new_headers

 #property
 #ef unverifiable(self):
 #eturn self.is_unverifiable()

 #property
 #ef origin_req_host(self):
 #eturn self.get_origin_req_host()

 #property
 #ef host(self):
 #eturn self.get_host()


class MockResponse:
 #""Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.

 #..what? Basically, expose the parsed HTTP headers from the server response
 #he way `cookielib` expects to see them.
 #""

 #ef __init__(self, headers):
 #""Make a MockResponse for `cookielib` to read.

 #param headers: a httplib.HTTPMessage or analogous carrying the headers
 #""
 #elf._headers = headers

 #ef info(self):
 #eturn self._headers

 #ef getheaders(self, name):
 #elf._headers.getheaders(name)


def extract_cookies_to_jar(jar, request, response):
 #""Extract the cookies from the response into a CookieJar.

 #param jar: cookielib.CookieJar (not necessarily a RequestsCookieJar)
 #param request: our own requests.Request object
 #param response: urllib3.HTTPResponse object
 #""
 #f not (hasattr(response, "_original_response") and response._original_response):
 #eturn
    # the _original_response field is the wrapped httplib.HTTPResponse object,
 #eq = MockRequest(request)
    # pull out the HTTPMessage with the headers and put it in the mock:
 #es = MockResponse(response._original_response.msg)
 #ar.extract_cookies(res, req)


def get_cookie_header(jar, request):
 #""
 #roduce an appropriate Cookie header string to be sent with `request`, or None.

 #rtype: str
 #""
 # = MockRequest(request)
 #ar.add_cookie_header(r)
 #eturn r.get_new_headers().get("Cookie")


def remove_cookie_by_name(cookiejar, name, domain=None, path=None):
 #""Unsets a cookie by name, by default over all domains and paths.

 #raps CookieJar.clear(), is O(n).
 #""
 #learables = []
 #or cookie in cookiejar:
 #f cookie.name != name:
 #ontinue
 #f domain is not None and domain != cookie.domain:
 #ontinue
 #f path is not None and path != cookie.path:
 #ontinue
 #learables.append((cookie.domain, cookie.path, cookie.name))

 #or domain, path, name in clearables:
 #ookiejar.clear(domain, path, name)


class CookieConflictError(RuntimeError):
 #""There are two cookies that meet the criteria specified in the cookie jar.
 #se .get and .set and include domain and path args in order to be more specific.
 #""


class RequestsCookieJar(cookielib.CookieJar, MutableMapping):
 #""Compatibility class; is a cookielib.CookieJar, but exposes a dict
 #nterface.

 #his is the CookieJar we create by default for requests and sessions that
 #on't specify one, since some clients may expect response.cookies and
 #ession.cookies to support dict operations.

 #equests does not use the dict interface internally; it's just for
 #ompatibility with external client code. All requests code should work
 #ut of the box with externally provided instances of ``CookieJar``, e.g.
 #`LWPCookieJar`` and ``FileCookieJar``.

 #nlike a regular CookieJar, this class is pickleable.

 #. warning:: dictionary operations that are normally O(1) may be O(n).
 #""

 #ef get(self, name, default=None, domain=None, path=None):
 #""Dict-like get() that also supports optional domain and path args in
 #rder to resolve naming collisions from using one cookie jar over
 #ultiple domains.

 #. warning:: operation is O(n), not O(1).
 #""
 #ry:
 #eturn self._find_no_duplicates(name, domain, path)
 #xcept KeyError:
 #eturn default

 #ef set(self, name, value, **kwargs):
 #""Dict-like set() that also supports optional domain and path args in
 #rder to resolve naming collisions from using one cookie jar over
 #ultiple domains.
 #""
        # support client code that unsets cookies by assignment of a None value:
 #f value is None:
 #emove_cookie_by_name(
 #elf, name, domain=kwargs.get("domain"), path=kwargs.get("path")
 #
 #eturn

 #f isinstance(value, Morsel):
 # = morsel_to_cookie(value)
 #lse:
 # = create_cookie(name, value, **kwargs)
 #elf.set_cookie(c)
 #eturn c

 #ef iterkeys(self):
 #""Dict-like iterkeys() that returns an iterator of names of cookies
 #rom the jar.

 #. seealso:: itervalues() and iteritems().
 #""
 #or cookie in iter(self):
 #ield cookie.name

 #ef keys(self):
 #""Dict-like keys() that returns a list of names of cookies from the
 #ar.

 #. seealso:: values() and items().
 #""
 #eturn list(self.iterkeys())

 #ef itervalues(self):
 #""Dict-like itervalues() that returns an iterator of values of cookies
 #rom the jar.

 #. seealso:: iterkeys() and iteritems().
 #""
 #or cookie in iter(self):
 #ield cookie.value

 #ef values(self):
 #""Dict-like values() that returns a list of values of cookies from the
 #ar.

 #. seealso:: keys() and items().
 #""
 #eturn list(self.itervalues())

 #ef iteritems(self):
 #""Dict-like iteritems() that returns an iterator of name-value tuples
 #rom the jar.

 #. seealso:: iterkeys() and itervalues().
 #""
 #or cookie in iter(self):
 #ield cookie.name, cookie.value

 #ef items(self):
 #""Dict-like items() that returns a list of name-value tuples from the
 #ar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a
 #anilla python dict of key value pairs.

 #. seealso:: keys() and values().
 #""
 #eturn list(self.iteritems())

 #ef list_domains(self):
 #""Utility method to list all the domains in the jar."""
 #omains = []
 #or cookie in iter(self):
 #f cookie.domain not in domains:
 #omains.append(cookie.domain)
 #eturn domains

 #ef list_paths(self):
 #""Utility method to list all the paths in the jar."""
 #aths = []
 #or cookie in iter(self):
 #f cookie.path not in paths:
 #aths.append(cookie.path)
 #eturn paths

 #ef multiple_domains(self):
 #""Returns True if there are multiple domains in the jar.
 #eturns False otherwise.

 #rtype: bool
 #""
 #omains = []
 #or cookie in iter(self):
 #f cookie.domain is not None and cookie.domain in domains:
 #eturn True
 #omains.append(cookie.domain)
 #eturn False  # there is only one domain in jar

 #ef get_dict(self, domain=None, path=None):
 #""Takes as an argument an optional domain and path and returns a plain
 #ld Python dict of name-value pairs of cookies that meet the
 #equirements.

 #rtype: dict
 #""
 #ictionary = {}
 #or cookie in iter(self):
 #f (domain is None or cookie.domain == domain) and (
 #ath is None or cookie.path == path
 #:
 #ictionary[cookie.name] = cookie.value
 #eturn dictionary

 #ef __contains__(self, name):
 #ry:
 #eturn super().__contains__(name)
 #xcept CookieConflictError:
 #eturn True

 #ef __getitem__(self, name):
 #""Dict-like __getitem__() for compatibility with client code. Throws
 #xception if there are more than one cookie with name. In that case,
 #se the more explicit get() method instead.

 #. warning:: operation is O(n), not O(1).
 #""
 #eturn self._find_no_duplicates(name)

 #ef __setitem__(self, name, value):
 #""Dict-like __setitem__ for compatibility with client code. Throws
 #xception if there is already a cookie of that name in the jar. In that
 #ase, use the more explicit set() method instead.
 #""
 #elf.set(name, value)

 #ef __delitem__(self, name):
 #""Deletes a cookie given a name. Wraps ``cookielib.CookieJar``'s
 #`remove_cookie_by_name()``.
 #""
 #emove_cookie_by_name(self, name)

 #ef set_cookie(self, cookie, *args, **kwargs):
 #f (
 #asattr(cookie.value, "startswith")
 #nd cookie.value.startswith('"')
 #nd cookie.value.endswith('"')
 #:
 #ookie.value = cookie.value.replace('\\"', "")
 #eturn super().set_cookie(cookie, *args, **kwargs)

 #ef update(self, other):
 #""Updates this jar with cookies from another CookieJar or dict-like"""
 #f isinstance(other, cookielib.CookieJar):
 #or cookie in other:
 #elf.set_cookie(copy.copy(cookie))
 #lse:
 #uper().update(other)

 #ef _find(self, name, domain=None, path=None):
 #""Requests uses this method internally to get cookie values.

 #f there are conflicting cookies, _find arbitrarily chooses one.
 #ee _find_no_duplicates if you want an exception thrown if there are
 #onflicting cookies.

 #param name: a string containing name of cookie
 #param domain: (optional) string containing domain of cookie
 #param path: (optional) string containing path of cookie
 #return: cookie.value
 #""
 #or cookie in iter(self):
 #f cookie.name == name:
 #f domain is None or cookie.domain == domain:
 #f path is None or cookie.path == path:
 #eturn cookie.value

 #aise KeyError(f"name={name!r}, domain={domain!r}, path={path!r}")

 #ef _find_no_duplicates(self, name, domain=None, path=None):
 #""Both ``__get_item__`` and ``get`` call this function: it's never
 #sed elsewhere in Requests.

 #param name: a string containing name of cookie
 #param domain: (optional) string containing domain of cookie
 #param path: (optional) string containing path of cookie
 #raises KeyError: if cookie is not found
 #raises CookieConflictError: if there are multiple cookies
 #hat match name and optionally domain and path
 #return: cookie.value
 #""
 #oReturn = None
 #or cookie in iter(self):
 #f cookie.name == name:
 #f domain is None or cookie.domain == domain:
 #f path is None or cookie.path == path:
 #f toReturn is not None:
                            # if there are multiple cookies that meet passed in criteria
 #aise CookieConflictError(
 #"There are multiple cookies with name, {name!r}"
 #
                        # we will eventually return this as long as no cookie conflict
 #oReturn = cookie.value

 #f toReturn:
 #eturn toReturn
 #aise KeyError(f"name={name!r}, domain={domain!r}, path={path!r}")

 #ef __getstate__(self):
 #""Unlike a normal CookieJar, this class is pickleable."""
 #tate = self.__dict__.copy()
        # remove the unpickleable RLock object
 #tate.pop("_cookies_lock")
 #eturn state

 #ef __setstate__(self, state):
 #""Unlike a normal CookieJar, this class is pickleable."""
 #elf.__dict__.update(state)
 #f "_cookies_lock" not in self.__dict__:
 #elf._cookies_lock = threading.RLock()

 #ef copy(self):
 #""Return a copy of this RequestsCookieJar."""
 #ew_cj = RequestsCookieJar()
 #ew_cj.set_policy(self.get_policy())
 #ew_cj.update(self)
 #eturn new_cj

 #ef get_policy(self):
 #""Return the CookiePolicy instance used."""
 #eturn self._policy


def _copy_cookie_jar(jar):
 #f jar is None:
 #eturn None

 #f hasattr(jar, "copy"):
        # We're dealing with an instance of RequestsCookieJar
 #eturn jar.copy()
    # We're dealing with a generic CookieJar instance
 #ew_jar = copy.copy(jar)
 #ew_jar.clear()
 #or cookie in jar:
 #ew_jar.set_cookie(copy.copy(cookie))
 #eturn new_jar


def create_cookie(name, value, **kwargs):
 #""Make a cookie from underspecified parameters.

 #y default, the pair of `name` and `value` will be set for the domain ''
 #nd sent on every request (this is sometimes called a "supercookie").
 #""
 #esult = {
 #version": 0,
 #name": name,
 #value": value,
 #port": None,
 #domain": "",
 #path": "/",
 #secure": False,
 #expires": None,
 #discard": True,
 #comment": None,
 #comment_url": None,
 #rest": {"HttpOnly": None},
 #rfc2109": False,
 #

 #adargs = set(kwargs) - set(result)
 #f badargs:
 #aise TypeError(
 #"create_cookie() got unexpected keyword arguments: {list(badargs)}"
 #

 #esult.update(kwargs)
 #esult["port_specified"] = bool(result["port"])
 #esult["domain_specified"] = bool(result["domain"])
 #esult["domain_initial_dot"] = result["domain"].startswith(".")
 #esult["path_specified"] = bool(result["path"])

 #eturn cookielib.Cookie(**result)


def morsel_to_cookie(morsel):
 #""Convert a Morsel object into a Cookie containing the one k/v pair."""

 #xpires = None
 #f morsel["max-age"]:
 #ry:
 #xpires = int(time.time() + int(morsel["max-age"]))
 #xcept ValueError:
 #aise TypeError(f"max-age: {morsel['max-age']} must be integer")
 #lif morsel["expires"]:
 #ime_template = "%a, %d-%b-%Y %H:%M:%S GMT"
 #xpires = calendar.timegm(time.strptime(morsel["expires"], time_template))
 #eturn create_cookie(
 #omment=morsel["comment"],
 #omment_url=bool(morsel["comment"]),
 #iscard=False,
 #omain=morsel["domain"],
 #xpires=expires,
 #ame=morsel.key,
 #ath=morsel["path"],
 #ort=None,
 #est={"HttpOnly": morsel["httponly"]},
 #fc2109=False,
 #ecure=bool(morsel["secure"]),
 #alue=morsel.value,
 #ersion=morsel["version"] or 0,
 #


def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):
 #""Returns a CookieJar from a key/value dictionary.

 #param cookie_dict: Dict of key/values to insert into CookieJar.
 #param cookiejar: (optional) A cookiejar to add the cookies to.
 #param overwrite: (optional) If False, will not replace cookies
 #lready in the jar with new ones.
 #rtype: CookieJar
 #""
 #f cookiejar is None:
 #ookiejar = RequestsCookieJar()

 #f cookie_dict is not None:
 #ames_from_jar = [cookie.name for cookie in cookiejar]
 #or name in cookie_dict:
 #f overwrite or (name not in names_from_jar):
 #ookiejar.set_cookie(create_cookie(name, cookie_dict[name]))

 #eturn cookiejar


def merge_cookies(cookiejar, cookies):
 #""Add cookies to cookiejar and returns a merged CookieJar.

 #param cookiejar: CookieJar object to add the cookies to.
 #param cookies: Dictionary or CookieJar object to be added.
 #rtype: CookieJar
 #""
 #f not isinstance(cookiejar, cookielib.CookieJar):
 #aise ValueError("You can only merge into CookieJar")

 #f isinstance(cookies, dict):
 #ookiejar = cookiejar_from_dict(cookies, cookiejar=cookiejar, overwrite=False)
 #lif isinstance(cookies, cookielib.CookieJar):
 #ry:
 #ookiejar.update(cookies)
 #xcept AttributeError:
 #or cookie_in_jar in cookies:
 #ookiejar.set_cookie(cookie_in_jar)

 #eturn cookiejar
