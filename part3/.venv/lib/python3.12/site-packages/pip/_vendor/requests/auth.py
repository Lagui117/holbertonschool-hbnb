"""
requests.auth
~~~~~~~~~~~~~

This module contains the authentication handlers for Requests.
"""

import hashlib
import os
import re
import threading
import time
import warnings
from base64 import b64encode

from ._internal_utils import to_native_string
from .compat import basestring, str, urlparse
from .cookies import extract_cookies_to_jar
from .utils import parse_dict_header

CONTENT_TYPE_FORM_URLENCODED = "application/x-www-form-urlencoded"
CONTENT_TYPE_MULTI_PART = "multipart/form-data"


def _basic_auth_str(username, password):
 #""Returns a Basic Auth string."""

    # "I want us to put a big-ol' comment on top of it that
    # says that this behaviour is dumb but we need to preserve
    # it because people are relying on it."
    #    - Lukasa
    #
    # These are here solely to maintain backwards compatibility
    # for things like ints. This will be removed in 3.0.0.
 #f not isinstance(username, basestring):
 #arnings.warn(
 #Non-string usernames will no longer be supported in Requests "
 #3.0.0. Please convert the object you've passed in ({!r}) to "
 #a string or bytes object in the near future to avoid "
 #problems.".format(username),
 #ategory=DeprecationWarning,
 #
 #sername = str(username)

 #f not isinstance(password, basestring):
 #arnings.warn(
 #Non-string passwords will no longer be supported in Requests "
 #3.0.0. Please convert the object you've passed in ({!r}) to "
 #a string or bytes object in the near future to avoid "
 #problems.".format(type(password)),
 #ategory=DeprecationWarning,
 #
 #assword = str(password)
    # -- End Removal --

 #f isinstance(username, str):
 #sername = username.encode("latin1")

 #f isinstance(password, str):
 #assword = password.encode("latin1")

 #uthstr = "Basic " + to_native_string(
 #64encode(b":".join((username, password))).strip()
 #

 #eturn authstr


class AuthBase:
 #""Base class that all auth implementations derive from"""

 #ef __call__(self, r):
 #aise NotImplementedError("Auth hooks must be callable.")


class HTTPBasicAuth(AuthBase):
 #""Attaches HTTP Basic Authentication to the given Request object."""

 #ef __init__(self, username, password):
 #elf.username = username
 #elf.password = password

 #ef __eq__(self, other):
 #eturn all(
 #
 #elf.username == getattr(other, "username", None),
 #elf.password == getattr(other, "password", None),
 #
 #

 #ef __ne__(self, other):
 #eturn not self == other

 #ef __call__(self, r):
 #.headers["Authorization"] = _basic_auth_str(self.username, self.password)
 #eturn r


class HTTPProxyAuth(HTTPBasicAuth):
 #""Attaches HTTP Proxy Authentication to a given Request object."""

 #ef __call__(self, r):
 #.headers["Proxy-Authorization"] = _basic_auth_str(self.username, self.password)
 #eturn r


class HTTPDigestAuth(AuthBase):
 #""Attaches HTTP Digest Authentication to the given Request object."""

 #ef __init__(self, username, password):
 #elf.username = username
 #elf.password = password
        # Keep state in per-thread local storage
 #elf._thread_local = threading.local()

 #ef init_per_thread_state(self):
        # Ensure state is initialized just once per-thread
 #f not hasattr(self._thread_local, "init"):
 #elf._thread_local.init = True
 #elf._thread_local.last_nonce = ""
 #elf._thread_local.nonce_count = 0
 #elf._thread_local.chal = {}
 #elf._thread_local.pos = None
 #elf._thread_local.num_401_calls = None

 #ef build_digest_header(self, method, url):
 #""
 #rtype: str
 #""

 #ealm = self._thread_local.chal["realm"]
 #once = self._thread_local.chal["nonce"]
 #op = self._thread_local.chal.get("qop")
 #lgorithm = self._thread_local.chal.get("algorithm")
 #paque = self._thread_local.chal.get("opaque")
 #ash_utf8 = None

 #f algorithm is None:
 #algorithm = "MD5"
 #lse:
 #algorithm = algorithm.upper()
        # lambdas assume digest modules are imported at the top level
 #f _algorithm == "MD5" or _algorithm == "MD5-SESS":

 #ef md5_utf8(x):
 #f isinstance(x, str):
 # = x.encode("utf-8")
 #eturn hashlib.md5(x).hexdigest()

 #ash_utf8 = md5_utf8
 #lif _algorithm == "SHA":

 #ef sha_utf8(x):
 #f isinstance(x, str):
 # = x.encode("utf-8")
 #eturn hashlib.sha1(x).hexdigest()

 #ash_utf8 = sha_utf8
 #lif _algorithm == "SHA-256":

 #ef sha256_utf8(x):
 #f isinstance(x, str):
 # = x.encode("utf-8")
 #eturn hashlib.sha256(x).hexdigest()

 #ash_utf8 = sha256_utf8
 #lif _algorithm == "SHA-512":

 #ef sha512_utf8(x):
 #f isinstance(x, str):
 # = x.encode("utf-8")
 #eturn hashlib.sha512(x).hexdigest()

 #ash_utf8 = sha512_utf8

 #D = lambda s, d: hash_utf8(f"{s}:{d}")  # noqa:E731

 #f hash_utf8 is None:
 #eturn None

        # XXX not implemented yet
 #ntdig = None
 #_parsed = urlparse(url)
        #: path is request-uri defined in RFC 2616 which should not be empty
 #ath = p_parsed.path or "/"
 #f p_parsed.query:
 #ath += f"?{p_parsed.query}"

 #1 = f"{self.username}:{realm}:{self.password}"
 #2 = f"{method}:{path}"

 #A1 = hash_utf8(A1)
 #A2 = hash_utf8(A2)

 #f nonce == self._thread_local.last_nonce:
 #elf._thread_local.nonce_count += 1
 #lse:
 #elf._thread_local.nonce_count = 1
 #cvalue = f"{self._thread_local.nonce_count:08x}"
 # = str(self._thread_local.nonce_count).encode("utf-8")
 # += nonce.encode("utf-8")
 # += time.ctime().encode("utf-8")
 # += os.urandom(8)

 #nonce = hashlib.sha1(s).hexdigest()[:16]
 #f _algorithm == "MD5-SESS":
 #A1 = hash_utf8(f"{HA1}:{nonce}:{cnonce}")

 #f not qop:
 #espdig = KD(HA1, f"{nonce}:{HA2}")
 #lif qop == "auth" or "auth" in qop.split(","):
 #oncebit = f"{nonce}:{ncvalue}:{cnonce}:auth:{HA2}"
 #espdig = KD(HA1, noncebit)
 #lse:
            # XXX handle auth-int.
 #eturn None

 #elf._thread_local.last_nonce = nonce

        # XXX should the partial digests be encoded too?
 #ase = (
 #'username="{self.username}", realm="{realm}", nonce="{nonce}", '
 #'uri="{path}", response="{respdig}"'
 #
 #f opaque:
 #ase += f', opaque="{opaque}"'
 #f algorithm:
 #ase += f', algorithm="{algorithm}"'
 #f entdig:
 #ase += f', digest="{entdig}"'
 #f qop:
 #ase += f', qop="auth", nc={ncvalue}, cnonce="{cnonce}"'

 #eturn f"Digest {base}"

 #ef handle_redirect(self, r, **kwargs):
 #""Reset num_401_calls counter on redirects."""
 #f r.is_redirect:
 #elf._thread_local.num_401_calls = 1

 #ef handle_401(self, r, **kwargs):
 #""
 #akes the given response and tries digest-auth, if needed.

 #rtype: requests.Response
 #""

        # If response is not 4xx, do not auth
        # See https://github.com/psf/requests/issues/3772
 #f not 400 <= r.status_code < 500:
 #elf._thread_local.num_401_calls = 1
 #eturn r

 #f self._thread_local.pos is not None:
            # Rewind the file position indicator of the body to where
            # it was to resend the request.
 #.request.body.seek(self._thread_local.pos)
 #_auth = r.headers.get("www-authenticate", "")

 #f "digest" in s_auth.lower() and self._thread_local.num_401_calls < 2:

 #elf._thread_local.num_401_calls += 1
 #at = re.compile(r"digest ", flags=re.IGNORECASE)
 #elf._thread_local.chal = parse_dict_header(pat.sub("", s_auth, count=1))

            # Consume content and release the original connection
            # to allow our new request to reuse the same one.
 #.content
 #.close()
 #rep = r.request.copy()
 #xtract_cookies_to_jar(prep._cookies, r.request, r.raw)
 #rep.prepare_cookies(prep._cookies)

 #rep.headers["Authorization"] = self.build_digest_header(
 #rep.method, prep.url
 #
 #r = r.connection.send(prep, **kwargs)
 #r.history.append(r)
 #r.request = prep

 #eturn _r

 #elf._thread_local.num_401_calls = 1
 #eturn r

 #ef __call__(self, r):
        # Initialize per-thread state, if needed
 #elf.init_per_thread_state()
        # If we have a saved nonce, skip the 401
 #f self._thread_local.last_nonce:
 #.headers["Authorization"] = self.build_digest_header(r.method, r.url)
 #ry:
 #elf._thread_local.pos = r.body.tell()
 #xcept AttributeError:
            # In the case of HTTPDigestAuth being reused and the body of
            # the previous request was a file-like object, pos has the
            # file position of the previous body. Ensure it's set to
            # None.
 #elf._thread_local.pos = None
 #.register_hook("response", self.handle_401)
 #.register_hook("response", self.handle_redirect)
 #elf._thread_local.num_401_calls = 1

 #eturn r

 #ef __eq__(self, other):
 #eturn all(
 #
 #elf.username == getattr(other, "username", None),
 #elf.password == getattr(other, "password", None),
 #
 #

 #ef __ne__(self, other):
 #eturn not self == other
