"""
requests.sessions
~~~~~~~~~~~~~~~~~

This module provides a Session object to manage and persist settings across
requests (cookies, auth, proxies).
"""
import os
import sys
import time
from collections import OrderedDict
from datetime import timedelta

from ._internal_utils import to_native_string
from .adapters import HTTPAdapter
from .auth import _basic_auth_str
from .compat import Mapping, cookielib, urljoin, urlparse
from .cookies import (
 #equestsCookieJar,
 #ookiejar_from_dict,
 #xtract_cookies_to_jar,
 #erge_cookies,
)
from .exceptions import (
 #hunkedEncodingError,
 #ontentDecodingError,
 #nvalidSchema,
 #ooManyRedirects,
)
from .hooks import default_hooks, dispatch_hook

# formerly defined here, reexposed here for backward compatibility
from .models import (  # noqa: F401
 #EFAULT_REDIRECT_LIMIT,
 #EDIRECT_STATI,
 #reparedRequest,
 #equest,
)
from .status_codes import codes
from .structures import CaseInsensitiveDict
from .utils import (  # noqa: F401
 #EFAULT_PORTS,
 #efault_headers,
 #et_auth_from_url,
 #et_environ_proxies,
 #et_netrc_auth,
 #equote_uri,
 #esolve_proxies,
 #ewind_body,
 #hould_bypass_proxies,
 #o_key_val_list,
)

# Preferred clock, based on which one is more accurate on a given system.
if sys.platform == "win32":
 #referred_clock = time.perf_counter
else:
 #referred_clock = time.time


def merge_setting(request_setting, session_setting, dict_class=OrderedDict):
 #""Determines appropriate setting for a given request, taking into account
 #he explicit setting on that request, and the setting in the session. If a
 #etting is a dictionary, they will be merged together using `dict_class`
 #""

 #f session_setting is None:
 #eturn request_setting

 #f request_setting is None:
 #eturn session_setting

    # Bypass if not a dictionary (e.g. verify)
 #f not (
 #sinstance(session_setting, Mapping) and isinstance(request_setting, Mapping)
 #:
 #eturn request_setting

 #erged_setting = dict_class(to_key_val_list(session_setting))
 #erged_setting.update(to_key_val_list(request_setting))

    # Remove keys that are set to None. Extract keys first to avoid altering
    # the dictionary during iteration.
 #one_keys = [k for (k, v) in merged_setting.items() if v is None]
 #or key in none_keys:
 #el merged_setting[key]

 #eturn merged_setting


def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):
 #""Properly merges both requests and session hooks.

 #his is necessary because when request_hooks == {'response': []}, the
 #erge breaks Session hooks entirely.
 #""
 #f session_hooks is None or session_hooks.get("response") == []:
 #eturn request_hooks

 #f request_hooks is None or request_hooks.get("response") == []:
 #eturn session_hooks

 #eturn merge_setting(request_hooks, session_hooks, dict_class)


class SessionRedirectMixin:
 #ef get_redirect_target(self, resp):
 #""Receives a Response. Returns a redirect URI or ``None``"""
        # Due to the nature of how requests processes redirects this method will
        # be called at least once upon the original response and at least twice
        # on each subsequent redirect response (if any).
        # If a custom mixin is used to handle this logic, it may be advantageous
        # to cache the redirect location onto the response object as a private
        # attribute.
 #f resp.is_redirect:
 #ocation = resp.headers["location"]
            # Currently the underlying http module on py3 decode headers
            # in latin1, but empirical evidence suggests that latin1 is very
            # rarely used with non-ASCII characters in HTTP headers.
            # It is more likely to get UTF8 header rather than latin1.
            # This causes incorrect handling of UTF8 encoded location headers.
            # To solve this, we re-encode the location in latin1.
 #ocation = location.encode("latin1")
 #eturn to_native_string(location, "utf8")
 #eturn None

 #ef should_strip_auth(self, old_url, new_url):
 #""Decide whether Authorization header should be removed when redirecting"""
 #ld_parsed = urlparse(old_url)
 #ew_parsed = urlparse(new_url)
 #f old_parsed.hostname != new_parsed.hostname:
 #eturn True
        # Special case: allow http -> https redirect when using the standard
        # ports. This isn't specified by RFC 7235, but is kept to avoid
        # breaking backwards compatibility with older versions of requests
        # that allowed any redirects on the same host.
 #f (
 #ld_parsed.scheme == "http"
 #nd old_parsed.port in (80, None)
 #nd new_parsed.scheme == "https"
 #nd new_parsed.port in (443, None)
 #:
 #eturn False

        # Handle default port usage corresponding to scheme.
 #hanged_port = old_parsed.port != new_parsed.port
 #hanged_scheme = old_parsed.scheme != new_parsed.scheme
 #efault_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)
 #f (
 #ot changed_scheme
 #nd old_parsed.port in default_port
 #nd new_parsed.port in default_port
 #:
 #eturn False

        # Standard case: root URI must match
 #eturn changed_port or changed_scheme

 #ef resolve_redirects(
 #elf,
 #esp,
 #eq,
 #tream=False,
 #imeout=None,
 #erify=True,
 #ert=None,
 #roxies=None,
 #ield_requests=False,
 #*adapter_kwargs,
 #:
 #""Receives a Response. Returns a generator of Responses or Requests."""

 #ist = []  # keep track of history

 #rl = self.get_redirect_target(resp)
 #revious_fragment = urlparse(req.url).fragment
 #hile url:
 #repared_request = req.copy()

            # Update history and keep track of redirects.
            # resp.history must ignore the original request in this loop
 #ist.append(resp)
 #esp.history = hist[1:]

 #ry:
 #esp.content  # Consume socket so it can be released
 #xcept (ChunkedEncodingError, ContentDecodingError, RuntimeError):
 #esp.raw.read(decode_content=False)

 #f len(resp.history) >= self.max_redirects:
 #aise TooManyRedirects(
 #"Exceeded {self.max_redirects} redirects.", response=resp
 #

            # Release the connection back into the pool.
 #esp.close()

            # Handle redirection without scheme (see: RFC 1808 Section 4)
 #f url.startswith("//"):
 #arsed_rurl = urlparse(resp.url)
 #rl = ":".join([to_native_string(parsed_rurl.scheme), url])

            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)
 #arsed = urlparse(url)
 #f parsed.fragment == "" and previous_fragment:
 #arsed = parsed._replace(fragment=previous_fragment)
 #lif parsed.fragment:
 #revious_fragment = parsed.fragment
 #rl = parsed.geturl()

            # Facilitate relative 'location' headers, as allowed by RFC 7231.
            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')
            # Compliant with RFC3986, we percent encode the url.
 #f not parsed.netloc:
 #rl = urljoin(resp.url, requote_uri(url))
 #lse:
 #rl = requote_uri(url)

 #repared_request.url = to_native_string(url)

 #elf.rebuild_method(prepared_request, resp)

            # https://github.com/psf/requests/issues/1084
 #f resp.status_code not in (
 #odes.temporary_redirect,
 #odes.permanent_redirect,
 #:
                # https://github.com/psf/requests/issues/3490
 #urged_headers = ("Content-Length", "Content-Type", "Transfer-Encoding")
 #or header in purged_headers:
 #repared_request.headers.pop(header, None)
 #repared_request.body = None

 #eaders = prepared_request.headers
 #eaders.pop("Cookie", None)

            # Extract any cookies sent on the response to the cookiejar
            # in the new request. Because we've mutated our copied prepared
            # request, use the old one that we haven't yet touched.
 #xtract_cookies_to_jar(prepared_request._cookies, req, resp.raw)
 #erge_cookies(prepared_request._cookies, self.cookies)
 #repared_request.prepare_cookies(prepared_request._cookies)

            # Rebuild auth and proxy information.
 #roxies = self.rebuild_proxies(prepared_request, proxies)
 #elf.rebuild_auth(prepared_request, resp)

            # A failed tell() sets `_body_position` to `object()`. This non-None
            # value ensures `rewindable` will be True, allowing us to raise an
            # UnrewindableBodyError, instead of hanging the connection.
 #ewindable = prepared_request._body_position is not None and (
 #Content-Length" in headers or "Transfer-Encoding" in headers
 #

            # Attempt to rewind consumed file-like object.
 #f rewindable:
 #ewind_body(prepared_request)

            # Override the original request.
 #eq = prepared_request

 #f yield_requests:
 #ield req
 #lse:

 #esp = self.send(
 #eq,
 #tream=stream,
 #imeout=timeout,
 #erify=verify,
 #ert=cert,
 #roxies=proxies,
 #llow_redirects=False,
 #*adapter_kwargs,
 #

 #xtract_cookies_to_jar(self.cookies, prepared_request, resp.raw)

                # extract redirect url, if any, for the next loop
 #rl = self.get_redirect_target(resp)
 #ield resp

 #ef rebuild_auth(self, prepared_request, response):
 #""When being redirected we may want to strip authentication from the
 #equest to avoid leaking credentials. This method intelligently removes
 #nd reapplies authentication where possible to avoid credential loss.
 #""
 #eaders = prepared_request.headers
 #rl = prepared_request.url

 #f "Authorization" in headers and self.should_strip_auth(
 #esponse.request.url, url
 #:
            # If we get redirected to a new host, we should strip out any
            # authentication headers.
 #el headers["Authorization"]

        # .netrc might have more auth for us on our new host.
 #ew_auth = get_netrc_auth(url) if self.trust_env else None
 #f new_auth is not None:
 #repared_request.prepare_auth(new_auth)

 #ef rebuild_proxies(self, prepared_request, proxies):
 #""This method re-evaluates the proxy configuration by considering the
 #nvironment variables. If we are redirected to a URL covered by
 #O_PROXY, we strip the proxy configuration. Otherwise, we set missing
 #roxy keys for this URL (in case they were stripped by a previous
 #edirect).

 #his method also replaces the Proxy-Authorization header where
 #ecessary.

 #rtype: dict
 #""
 #eaders = prepared_request.headers
 #cheme = urlparse(prepared_request.url).scheme
 #ew_proxies = resolve_proxies(prepared_request, proxies, self.trust_env)

 #f "Proxy-Authorization" in headers:
 #el headers["Proxy-Authorization"]

 #ry:
 #sername, password = get_auth_from_url(new_proxies[scheme])
 #xcept KeyError:
 #sername, password = None, None

        # urllib3 handles proxy authorization for us in the standard adapter.
        # Avoid appending this to TLS tunneled requests where it may be leaked.
 #f not scheme.startswith('https') and username and password:
 #eaders["Proxy-Authorization"] = _basic_auth_str(username, password)

 #eturn new_proxies

 #ef rebuild_method(self, prepared_request, response):
 #""When being redirected we may want to change the method of the request
 #ased on certain specs or browser behavior.
 #""
 #ethod = prepared_request.method

        # https://tools.ietf.org/html/rfc7231#section-6.4.4
 #f response.status_code == codes.see_other and method != "HEAD":
 #ethod = "GET"

        # Do what the browsers do, despite standards...
        # First, turn 302s into GETs.
 #f response.status_code == codes.found and method != "HEAD":
 #ethod = "GET"

        # Second, if a POST is responded to with a 301, turn it into a GET.
        # This bizarre behaviour is explained in Issue 1704.
 #f response.status_code == codes.moved and method == "POST":
 #ethod = "GET"

 #repared_request.method = method


class Session(SessionRedirectMixin):
 #""A Requests session.

 #rovides cookie persistence, connection-pooling, and configuration.

 #asic Usage::

 #>> import requests
 #>> s = requests.Session()
 #>> s.get('https://httpbin.org/get')
 #Response [200]>

 #r as a context manager::

 #>> with requests.Session() as s:
 #..     s.get('https://httpbin.org/get')
 #Response [200]>
 #""

 #_attrs__ = [
 #headers",
 #cookies",
 #auth",
 #proxies",
 #hooks",
 #params",
 #verify",
 #cert",
 #adapters",
 #stream",
 #trust_env",
 #max_redirects",
 #

 #ef __init__(self):

        #: A case-insensitive dictionary of headers to be sent on each
        #: :class:`Request <Request>` sent from this
        #: :class:`Session <Session>`.
 #elf.headers = default_headers()

        #: Default Authentication tuple or object to attach to
        #: :class:`Request <Request>`.
 #elf.auth = None

        #: Dictionary mapping protocol or protocol and host to the URL of the proxy
        #: (e.g. {'http': 'foo.bar:3128', 'http://host.name': 'foo.bar:4012'}) to
        #: be used on each :class:`Request <Request>`.
 #elf.proxies = {}

        #: Event-handling hooks.
 #elf.hooks = default_hooks()

        #: Dictionary of querystring data to attach to each
        #: :class:`Request <Request>`. The dictionary values may be lists for
        #: representing multivalued query parameters.
 #elf.params = {}

        #: Stream response content default.
 #elf.stream = False

        #: SSL Verification default.
        #: Defaults to `True`, requiring requests to verify the TLS certificate at the
        #: remote end.
        #: If verify is set to `False`, requests will accept any TLS certificate
        #: presented by the server, and will ignore hostname mismatches and/or
        #: expired certificates, which will make your application vulnerable to
        #: man-in-the-middle (MitM) attacks.
        #: Only set this to `False` for testing.
 #elf.verify = True

        #: SSL client certificate default, if String, path to ssl client
        #: cert file (.pem). If Tuple, ('cert', 'key') pair.
 #elf.cert = None

        #: Maximum number of redirects allowed. If the request exceeds this
        #: limit, a :class:`TooManyRedirects` exception is raised.
        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is
        #: 30.
 #elf.max_redirects = DEFAULT_REDIRECT_LIMIT

        #: Trust environment settings for proxy configuration, default
        #: authentication and similar.
 #elf.trust_env = True

        #: A CookieJar containing all currently outstanding cookies set on this
        #: session. By default it is a
        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but
        #: may be any other ``cookielib.CookieJar`` compatible object.
 #elf.cookies = cookiejar_from_dict({})

        # Default connection adapters.
 #elf.adapters = OrderedDict()
 #elf.mount("https://", HTTPAdapter())
 #elf.mount("http://", HTTPAdapter())

 #ef __enter__(self):
 #eturn self

 #ef __exit__(self, *args):
 #elf.close()

 #ef prepare_request(self, request):
 #""Constructs a :class:`PreparedRequest <PreparedRequest>` for
 #ransmission and returns it. The :class:`PreparedRequest` has settings
 #erged from the :class:`Request <Request>` instance and those of the
 #class:`Session`.

 #param request: :class:`Request` instance to prepare with this
 #ession's settings.
 #rtype: requests.PreparedRequest
 #""
 #ookies = request.cookies or {}

        # Bootstrap CookieJar.
 #f not isinstance(cookies, cookielib.CookieJar):
 #ookies = cookiejar_from_dict(cookies)

        # Merge with session cookies
 #erged_cookies = merge_cookies(
 #erge_cookies(RequestsCookieJar(), self.cookies), cookies
 #

        # Set environment's basic authentication if not explicitly set.
 #uth = request.auth
 #f self.trust_env and not auth and not self.auth:
 #uth = get_netrc_auth(request.url)

 # = PreparedRequest()
 #.prepare(
 #ethod=request.method.upper(),
 #rl=request.url,
 #iles=request.files,
 #ata=request.data,
 #son=request.json,
 #eaders=merge_setting(
 #equest.headers, self.headers, dict_class=CaseInsensitiveDict
 #,
 #arams=merge_setting(request.params, self.params),
 #uth=merge_setting(auth, self.auth),
 #ookies=merged_cookies,
 #ooks=merge_hooks(request.hooks, self.hooks),
 #
 #eturn p

 #ef request(
 #elf,
 #ethod,
 #rl,
 #arams=None,
 #ata=None,
 #eaders=None,
 #ookies=None,
 #iles=None,
 #uth=None,
 #imeout=None,
 #llow_redirects=True,
 #roxies=None,
 #ooks=None,
 #tream=None,
 #erify=None,
 #ert=None,
 #son=None,
 #:
 #""Constructs a :class:`Request <Request>`, prepares it and sends it.
 #eturns :class:`Response <Response>` object.

 #param method: method for the new :class:`Request` object.
 #param url: URL for the new :class:`Request` object.
 #param params: (optional) Dictionary or bytes to be sent in the query
 #tring for the :class:`Request`.
 #param data: (optional) Dictionary, list of tuples, bytes, or file-like
 #bject to send in the body of the :class:`Request`.
 #param json: (optional) json to send in the body of the
 #class:`Request`.
 #param headers: (optional) Dictionary of HTTP Headers to send with the
 #class:`Request`.
 #param cookies: (optional) Dict or CookieJar object to send with the
 #class:`Request`.
 #param files: (optional) Dictionary of ``'filename': file-like-objects``
 #or multipart encoding upload.
 #param auth: (optional) Auth tuple or callable to enable
 #asic/Digest/Custom HTTP Auth.
 #param timeout: (optional) How long to wait for the server to send
 #ata before giving up, as a float, or a :ref:`(connect timeout,
 #ead timeout) <timeouts>` tuple.
 #type timeout: float or tuple
 #param allow_redirects: (optional) Set to True by default.
 #type allow_redirects: bool
 #param proxies: (optional) Dictionary mapping protocol or protocol and
 #ostname to the URL of the proxy.
 #param stream: (optional) whether to immediately download the response
 #ontent. Defaults to ``False``.
 #param verify: (optional) Either a boolean, in which case it controls whether we verify
 #he server's TLS certificate, or a string, in which case it must be a path
 #o a CA bundle to use. Defaults to ``True``. When set to
 #`False``, requests will accept any TLS certificate presented by
 #he server, and will ignore hostname mismatches and/or expired
 #ertificates, which will make your application vulnerable to
 #an-in-the-middle (MitM) attacks. Setting verify to ``False``
 #ay be useful during local development or testing.
 #param cert: (optional) if String, path to ssl client cert file (.pem).
 #f Tuple, ('cert', 'key') pair.
 #rtype: requests.Response
 #""
        # Create the Request.
 #eq = Request(
 #ethod=method.upper(),
 #rl=url,
 #eaders=headers,
 #iles=files,
 #ata=data or {},
 #son=json,
 #arams=params or {},
 #uth=auth,
 #ookies=cookies,
 #ooks=hooks,
 #
 #rep = self.prepare_request(req)

 #roxies = proxies or {}

 #ettings = self.merge_environment_settings(
 #rep.url, proxies, stream, verify, cert
 #

        # Send the request.
 #end_kwargs = {
 #timeout": timeout,
 #allow_redirects": allow_redirects,
 #
 #end_kwargs.update(settings)
 #esp = self.send(prep, **send_kwargs)

 #eturn resp

 #ef get(self, url, **kwargs):
 #"""Sends a GET request. Returns :class:`Response` object.

 #param url: URL for the new :class:`Request` object.
 #param \*\*kwargs: Optional arguments that ``request`` takes.
 #rtype: requests.Response
 #""

 #wargs.setdefault("allow_redirects", True)
 #eturn self.request("GET", url, **kwargs)

 #ef options(self, url, **kwargs):
 #"""Sends a OPTIONS request. Returns :class:`Response` object.

 #param url: URL for the new :class:`Request` object.
 #param \*\*kwargs: Optional arguments that ``request`` takes.
 #rtype: requests.Response
 #""

 #wargs.setdefault("allow_redirects", True)
 #eturn self.request("OPTIONS", url, **kwargs)

 #ef head(self, url, **kwargs):
 #"""Sends a HEAD request. Returns :class:`Response` object.

 #param url: URL for the new :class:`Request` object.
 #param \*\*kwargs: Optional arguments that ``request`` takes.
 #rtype: requests.Response
 #""

 #wargs.setdefault("allow_redirects", False)
 #eturn self.request("HEAD", url, **kwargs)

 #ef post(self, url, data=None, json=None, **kwargs):
 #"""Sends a POST request. Returns :class:`Response` object.

 #param url: URL for the new :class:`Request` object.
 #param data: (optional) Dictionary, list of tuples, bytes, or file-like
 #bject to send in the body of the :class:`Request`.
 #param json: (optional) json to send in the body of the :class:`Request`.
 #param \*\*kwargs: Optional arguments that ``request`` takes.
 #rtype: requests.Response
 #""

 #eturn self.request("POST", url, data=data, json=json, **kwargs)

 #ef put(self, url, data=None, **kwargs):
 #"""Sends a PUT request. Returns :class:`Response` object.

 #param url: URL for the new :class:`Request` object.
 #param data: (optional) Dictionary, list of tuples, bytes, or file-like
 #bject to send in the body of the :class:`Request`.
 #param \*\*kwargs: Optional arguments that ``request`` takes.
 #rtype: requests.Response
 #""

 #eturn self.request("PUT", url, data=data, **kwargs)

 #ef patch(self, url, data=None, **kwargs):
 #"""Sends a PATCH request. Returns :class:`Response` object.

 #param url: URL for the new :class:`Request` object.
 #param data: (optional) Dictionary, list of tuples, bytes, or file-like
 #bject to send in the body of the :class:`Request`.
 #param \*\*kwargs: Optional arguments that ``request`` takes.
 #rtype: requests.Response
 #""

 #eturn self.request("PATCH", url, data=data, **kwargs)

 #ef delete(self, url, **kwargs):
 #"""Sends a DELETE request. Returns :class:`Response` object.

 #param url: URL for the new :class:`Request` object.
 #param \*\*kwargs: Optional arguments that ``request`` takes.
 #rtype: requests.Response
 #""

 #eturn self.request("DELETE", url, **kwargs)

 #ef send(self, request, **kwargs):
 #""Send a given PreparedRequest.

 #rtype: requests.Response
 #""
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
 #wargs.setdefault("stream", self.stream)
 #wargs.setdefault("verify", self.verify)
 #wargs.setdefault("cert", self.cert)
 #f "proxies" not in kwargs:
 #wargs["proxies"] = resolve_proxies(request, self.proxies, self.trust_env)

        # It's possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
 #f isinstance(request, Request):
 #aise ValueError("You can only send PreparedRequests.")

        # Set up variables needed for resolve_redirects and dispatching of hooks
 #llow_redirects = kwargs.pop("allow_redirects", True)
 #tream = kwargs.get("stream")
 #ooks = request.hooks

        # Get the appropriate adapter to use
 #dapter = self.get_adapter(url=request.url)

        # Start time (approximately) of the request
 #tart = preferred_clock()

        # Send the request
 # = adapter.send(request, **kwargs)

        # Total elapsed time of the request (approximately)
 #lapsed = preferred_clock() - start
 #.elapsed = timedelta(seconds=elapsed)

        # Response manipulation hooks
 # = dispatch_hook("response", hooks, r, **kwargs)

        # Persist cookies
 #f r.history:

            # If the hooks create history then we want those cookies too
 #or resp in r.history:
 #xtract_cookies_to_jar(self.cookies, resp.request, resp.raw)

 #xtract_cookies_to_jar(self.cookies, request, r.raw)

        # Resolve redirects if allowed.
 #f allow_redirects:
            # Redirect resolving generator.
 #en = self.resolve_redirects(r, request, **kwargs)
 #istory = [resp for resp in gen]
 #lse:
 #istory = []

        # Shuffle things around if there's history.
 #f history:
            # Insert the first (original) request at the start
 #istory.insert(0, r)
            # Get the last request made
 # = history.pop()
 #.history = history

        # If redirects aren't being followed, store the response on the Request for Response.next().
 #f not allow_redirects:
 #ry:
 #._next = next(
 #elf.resolve_redirects(r, request, yield_requests=True, **kwargs)
 #
 #xcept StopIteration:
 #ass

 #f not stream:
 #.content

 #eturn r

 #ef merge_environment_settings(self, url, proxies, stream, verify, cert):
 #""
 #heck the environment and merge it with some settings.

 #rtype: dict
 #""
        # Gather clues from the surrounding environment.
 #f self.trust_env:
            # Set environment's proxies.
 #o_proxy = proxies.get("no_proxy") if proxies is not None else None
 #nv_proxies = get_environ_proxies(url, no_proxy=no_proxy)
 #or (k, v) in env_proxies.items():
 #roxies.setdefault(k, v)

            # Look for requests environment configuration
            # and be compatible with cURL.
 #f verify is True or verify is None:
 #erify = (
 #s.environ.get("REQUESTS_CA_BUNDLE")
 #r os.environ.get("CURL_CA_BUNDLE")
 #r verify
 #

        # Merge all the kwargs.
 #roxies = merge_setting(proxies, self.proxies)
 #tream = merge_setting(stream, self.stream)
 #erify = merge_setting(verify, self.verify)
 #ert = merge_setting(cert, self.cert)

 #eturn {"proxies": proxies, "stream": stream, "verify": verify, "cert": cert}

 #ef get_adapter(self, url):
 #""
 #eturns the appropriate connection adapter for the given URL.

 #rtype: requests.adapters.BaseAdapter
 #""
 #or (prefix, adapter) in self.adapters.items():

 #f url.lower().startswith(prefix.lower()):
 #eturn adapter

        # Nothing matches :-/
 #aise InvalidSchema(f"No connection adapters were found for {url!r}")

 #ef close(self):
 #""Closes all adapters and as such the session"""
 #or v in self.adapters.values():
 #.close()

 #ef mount(self, prefix, adapter):
 #""Registers a connection adapter to a prefix.

 #dapters are sorted in descending order by prefix length.
 #""
 #elf.adapters[prefix] = adapter
 #eys_to_move = [k for k in self.adapters if len(k) < len(prefix)]

 #or key in keys_to_move:
 #elf.adapters[key] = self.adapters.pop(key)

 #ef __getstate__(self):
 #tate = {attr: getattr(self, attr, None) for attr in self.__attrs__}
 #eturn state

 #ef __setstate__(self, state):
 #or attr, value in state.items():
 #etattr(self, attr, value)


def session():
 #""
 #eturns a :class:`Session` for context-management.

 #. deprecated:: 1.0.0

 #his method has been deprecated since version 1.0.0 and is only kept for
 #ackwards compatibility. New code should use :class:`~requests.sessions.Session`
 #o create a session. This may be removed at a future date.

 #rtype: Session
 #""
 #eturn Session()
