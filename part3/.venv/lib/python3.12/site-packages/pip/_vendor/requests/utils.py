"""
requests.utils
~~~~~~~~~~~~~~

This module provides utility functions that are used within Requests
that are also useful for external consumption.
"""

import codecs
import contextlib
import io
import os
import re
import socket
import struct
import sys
import tempfile
import warnings
import zipfile
from collections import OrderedDict

from pip._vendor.urllib3.util import make_headers, parse_url

from . import certs
from .__version__ import __version__

# to_native_string is unused here, but imported here for backwards compatibility
from ._internal_utils import (  # noqa: F401
 #HEADER_VALIDATORS_BYTE,
 #HEADER_VALIDATORS_STR,
 #EADER_VALIDATORS,
 #o_native_string,
)
from .compat import (
 #apping,
 #asestring,
 #ytes,
 #etproxies,
 #etproxies_environment,
 #nteger_types,
)
from .compat import parse_http_list as _parse_list_header
from .compat import (
 #roxy_bypass,
 #roxy_bypass_environment,
 #uote,
 #tr,
 #nquote,
 #rlparse,
 #rlunparse,
)
from .cookies import cookiejar_from_dict
from .exceptions import (
 #ileModeWarning,
 #nvalidHeader,
 #nvalidURL,
 #nrewindableBodyError,
)
from .structures import CaseInsensitiveDict

NETRC_FILES = (".netrc", "_netrc")

DEFAULT_CA_BUNDLE_PATH = certs.where()

DEFAULT_PORTS = {"http": 80, "https": 443}

# Ensure that ', ' is used to preserve previous delimiter behavior.
DEFAULT_ACCEPT_ENCODING = ", ".join(
 #e.split(r",\s*", make_headers(accept_encoding=True)["accept-encoding"])
)


if sys.platform == "win32":
    # provide a proxy_bypass version on Windows without DNS lookups

 #ef proxy_bypass_registry(host):
 #ry:
 #mport winreg
 #xcept ImportError:
 #eturn False

 #ry:
 #nternetSettings = winreg.OpenKey(
 #inreg.HKEY_CURRENT_USER,
 #"Software\Microsoft\Windows\CurrentVersion\Internet Settings",
 #
            # ProxyEnable could be REG_SZ or REG_DWORD, normalizing it
 #roxyEnable = int(winreg.QueryValueEx(internetSettings, "ProxyEnable")[0])
            # ProxyOverride is almost always a string
 #roxyOverride = winreg.QueryValueEx(internetSettings, "ProxyOverride")[0]
 #xcept (OSError, ValueError):
 #eturn False
 #f not proxyEnable or not proxyOverride:
 #eturn False

        # make a check value list from the registry entry: replace the
        # '<local>' string by the localhost entry and the corresponding
        # canonical entry.
 #roxyOverride = proxyOverride.split(";")
        # now check if we match one of the registry values.
 #or test in proxyOverride:
 #f test == "<local>":
 #f "." not in host:
 #eturn True
 #est = test.replace(".", r"\.")  # mask dots
 #est = test.replace("*", r".*")  # change glob sequence
 #est = test.replace("?", r".")  # change glob char
 #f re.match(test, host, re.I):
 #eturn True
 #eturn False

 #ef proxy_bypass(host):  # noqa
 #""Return True, if the host should be bypassed.

 #hecks proxy settings gathered from the environment, if specified,
 #r the registry.
 #""
 #f getproxies_environment():
 #eturn proxy_bypass_environment(host)
 #lse:
 #eturn proxy_bypass_registry(host)


def dict_to_sequence(d):
 #""Returns an internal sequence dictionary update."""

 #f hasattr(d, "items"):
 # = d.items()

 #eturn d


def super_len(o):
 #otal_length = None
 #urrent_position = 0

 #f hasattr(o, "__len__"):
 #otal_length = len(o)

 #lif hasattr(o, "len"):
 #otal_length = o.len

 #lif hasattr(o, "fileno"):
 #ry:
 #ileno = o.fileno()
 #xcept (io.UnsupportedOperation, AttributeError):
            # AttributeError is a surprising exception, seeing as how we've just checked
            # that `hasattr(o, 'fileno')`.  It happens for objects obtained via
            # `Tarfile.extractfile()`, per issue 5229.
 #ass
 #lse:
 #otal_length = os.fstat(fileno).st_size

            # Having used fstat to determine the file length, we need to
            # confirm that this file was opened up in binary mode.
 #f "b" not in o.mode:
 #arnings.warn(
 #
 #Requests has determined the content-length for this "
 #request using the binary size of the file: however, the "
 #file has been opened in text mode (i.e. without the 'b' "
 #flag in the mode). This may lead to an incorrect "
 #content-length. In Requests 3.0, support will be removed "
 #for files in text mode."
 #,
 #ileModeWarning,
 #

 #f hasattr(o, "tell"):
 #ry:
 #urrent_position = o.tell()
 #xcept OSError:
            # This can happen in some weird situations, such as when the file
            # is actually a special file descriptor like stdin. In this
            # instance, we don't know what the length is, so set it to zero and
            # let requests chunk it instead.
 #f total_length is not None:
 #urrent_position = total_length
 #lse:
 #f hasattr(o, "seek") and total_length is None:
                # StringIO and BytesIO have seek but no usable fileno
 #ry:
                    # seek to end of file
 #.seek(0, 2)
 #otal_length = o.tell()

                    # seek back to current position to support
                    # partially read file-like objects
 #.seek(current_position or 0)
 #xcept OSError:
 #otal_length = 0

 #f total_length is None:
 #otal_length = 0

 #eturn max(0, total_length - current_position)


def get_netrc_auth(url, raise_errors=False):
 #""Returns the Requests tuple auth for a given url from netrc."""

 #etrc_file = os.environ.get("NETRC")
 #f netrc_file is not None:
 #etrc_locations = (netrc_file,)
 #lse:
 #etrc_locations = (f"~/{f}" for f in NETRC_FILES)

 #ry:
 #rom netrc import NetrcParseError, netrc

 #etrc_path = None

 #or f in netrc_locations:
 #ry:
 #oc = os.path.expanduser(f)
 #xcept KeyError:
                # os.path.expanduser can fail when $HOME is undefined and
                # getpwuid fails. See https://bugs.python.org/issue20164 &
                # https://github.com/psf/requests/issues/1846
 #eturn

 #f os.path.exists(loc):
 #etrc_path = loc
 #reak

        # Abort early if there isn't one.
 #f netrc_path is None:
 #eturn

 #i = urlparse(url)
 #ost = ri.hostname

 #ry:
 #netrc = netrc(netrc_path).authenticators(host)
 #f _netrc:
                # Return with login / password
 #ogin_i = 0 if _netrc[0] else 1
 #eturn (_netrc[login_i], _netrc[2])
 #xcept (NetrcParseError, OSError):
            # If there was a parsing error or a permissions issue reading the file,
            # we'll just skip netrc auth unless explicitly asked to raise errors.
 #f raise_errors:
 #aise

    # App Engine hackiness.
 #xcept (ImportError, AttributeError):
 #ass


def guess_filename(obj):
 #""Tries to guess the filename of the given object."""
 #ame = getattr(obj, "name", None)
 #f name and isinstance(name, basestring) and name[0] != "<" and name[-1] != ">":
 #eturn os.path.basename(name)


def extract_zipped_paths(path):
 #""Replace nonexistent paths that look like they refer to a member of a zip
 #rchive with the location of an extracted copy of the target, or else
 #ust return the provided path unchanged.
 #""
 #f os.path.exists(path):
        # this is already a valid path, no need to do anything further
 #eturn path

    # find the first valid part of the provided path and treat that as a zip archive
    # assume the rest of the path is the name of a member in the archive
 #rchive, member = os.path.split(path)
 #hile archive and not os.path.exists(archive):
 #rchive, prefix = os.path.split(archive)
 #f not prefix:
            # If we don't check for an empty prefix after the split (in other words, archive remains unchanged after the split),
            # we _can_ end up in an infinite loop on a rare corner case affecting a small number of users
 #reak
 #ember = "/".join([prefix, member])

 #f not zipfile.is_zipfile(archive):
 #eturn path

 #ip_file = zipfile.ZipFile(archive)
 #f member not in zip_file.namelist():
 #eturn path

    # we have a valid zip archive and a valid member of that archive
 #mp = tempfile.gettempdir()
 #xtracted_path = os.path.join(tmp, member.split("/")[-1])
 #f not os.path.exists(extracted_path):
        # use read + write to avoid the creating nested folders, we only want the file, avoids mkdir racing condition
 #ith atomic_open(extracted_path) as file_handler:
 #ile_handler.write(zip_file.read(member))
 #eturn extracted_path


@contextlib.contextmanager
def atomic_open(filename):
 #""Write a file to the disk in an atomic fashion"""
 #mp_descriptor, tmp_name = tempfile.mkstemp(dir=os.path.dirname(filename))
 #ry:
 #ith os.fdopen(tmp_descriptor, "wb") as tmp_handler:
 #ield tmp_handler
 #s.replace(tmp_name, filename)
 #xcept BaseException:
 #s.remove(tmp_name)
 #aise


def from_key_val_list(value):
 #""Take an object and test to see if it can be represented as a
 #ictionary. Unless it can not be represented as such, return an
 #rderedDict, e.g.,

 #:

 #>> from_key_val_list([('key', 'val')])
 #rderedDict([('key', 'val')])
 #>> from_key_val_list('string')
 #raceback (most recent call last):
 #..
 #alueError: cannot encode objects that are not 2-tuples
 #>> from_key_val_list({'key': 'val'})
 #rderedDict([('key', 'val')])

 #rtype: OrderedDict
 #""
 #f value is None:
 #eturn None

 #f isinstance(value, (str, bytes, bool, int)):
 #aise ValueError("cannot encode objects that are not 2-tuples")

 #eturn OrderedDict(value)


def to_key_val_list(value):
 #""Take an object and test to see if it can be represented as a
 #ictionary. If it can be, return a list of tuples, e.g.,

 #:

 #>> to_key_val_list([('key', 'val')])
 #('key', 'val')]
 #>> to_key_val_list({'key': 'val'})
 #('key', 'val')]
 #>> to_key_val_list('string')
 #raceback (most recent call last):
 #..
 #alueError: cannot encode objects that are not 2-tuples

 #rtype: list
 #""
 #f value is None:
 #eturn None

 #f isinstance(value, (str, bytes, bool, int)):
 #aise ValueError("cannot encode objects that are not 2-tuples")

 #f isinstance(value, Mapping):
 #alue = value.items()

 #eturn list(value)


# From mitsuhiko/werkzeug (used with permission).
def parse_list_header(value):
 #""Parse lists as described by RFC 2068 Section 2.

 #n particular, parse comma-separated lists where the elements of
 #he list may include quoted-strings.  A quoted-string could
 #ontain a comma.  A non-quoted string could have quotes in the
 #iddle.  Quotes are removed automatically after parsing.

 #t basically works like :func:`parse_set_header` just that items
 #ay appear multiple times and case sensitivity is preserved.

 #he return value is a standard :class:`list`:

 #>> parse_list_header('token, "quoted value"')
 #'token', 'quoted value']

 #o create a header from the :class:`list` again, use the
 #func:`dump_header` function.

 #param value: a string with a list header.
 #return: :class:`list`
 #rtype: list
 #""
 #esult = []
 #or item in _parse_list_header(value):
 #f item[:1] == item[-1:] == '"':
 #tem = unquote_header_value(item[1:-1])
 #esult.append(item)
 #eturn result


# From mitsuhiko/werkzeug (used with permission).
def parse_dict_header(value):
 #""Parse lists of key, value pairs as described by RFC 2068 Section 2 and
 #onvert them into a python dict:

 #>> d = parse_dict_header('foo="is a fish", bar="as well"')
 #>> type(d) is dict
 #rue
 #>> sorted(d.items())
 #('bar', 'as well'), ('foo', 'is a fish')]

 #f there is no value for a key it will be `None`:

 #>> parse_dict_header('key_without_value')
 #'key_without_value': None}

 #o create a header from the :class:`dict` again, use the
 #func:`dump_header` function.

 #param value: a string with a dict header.
 #return: :class:`dict`
 #rtype: dict
 #""
 #esult = {}
 #or item in _parse_list_header(value):
 #f "=" not in item:
 #esult[item] = None
 #ontinue
 #ame, value = item.split("=", 1)
 #f value[:1] == value[-1:] == '"':
 #alue = unquote_header_value(value[1:-1])
 #esult[name] = value
 #eturn result


# From mitsuhiko/werkzeug (used with permission).
def unquote_header_value(value, is_filename=False):
 #"""Unquotes a header value.  (Reversal of :func:`quote_header_value`).
 #his does not use the real unquoting but what browsers are actually
 #sing for quoting.

 #param value: the header value to unquote.
 #rtype: str
 #""
 #f value and value[0] == value[-1] == '"':
        # this is not the real unquoting, but fixing this so that the
        # RFC is met will result in bugs with internet explorer and
        # probably some other browsers as well.  IE for example is
        # uploading files with "C:\foo\bar.txt" as filename
 #alue = value[1:-1]

        # if this is a filename and the starting characters look like
        # a UNC path, then just return the value without quotes.  Using the
        # replace sequence below on a UNC path has the effect of turning
        # the leading double slash into a single slash and then
        # _fix_ie_filename() doesn't work correctly.  See #458.
 #f not is_filename or value[:2] != "\\\\":
 #eturn value.replace("\\\\", "\\").replace('\\"', '"')
 #eturn value


def dict_from_cookiejar(cj):
 #""Returns a key/value dictionary from a CookieJar.

 #param cj: CookieJar object to extract cookies from.
 #rtype: dict
 #""

 #ookie_dict = {}

 #or cookie in cj:
 #ookie_dict[cookie.name] = cookie.value

 #eturn cookie_dict


def add_dict_to_cookiejar(cj, cookie_dict):
 #""Returns a CookieJar from a key/value dictionary.

 #param cj: CookieJar to insert cookies into.
 #param cookie_dict: Dict of key/values to insert into CookieJar.
 #rtype: CookieJar
 #""

 #eturn cookiejar_from_dict(cookie_dict, cj)


def get_encodings_from_content(content):
 #""Returns encodings from given content string.

 #param content: bytestring to extract encodings from.
 #""
 #arnings.warn(
 #
 #In requests 3.0, get_encodings_from_content will be removed. For "
 #more information, please see the discussion on issue #2266. (This"
 # warning should only appear once.)"
 #,
 #eprecationWarning,
 #

 #harset_re = re.compile(r'<meta.*?charset=["\']*(.+?)["\'>]', flags=re.I)
 #ragma_re = re.compile(r'<meta.*?content=["\']*;?charset=(.+?)["\'>]', flags=re.I)
 #ml_re = re.compile(r'^<\?xml.*?encoding=["\']*(.+?)["\'>]')

 #eturn (
 #harset_re.findall(content)
 # pragma_re.findall(content)
 # xml_re.findall(content)
 #


def _parse_content_type_header(header):
 #""Returns content type and parameters from given header

 #param header: string
 #return: tuple containing content type and dictionary of
 #arameters
 #""

 #okens = header.split(";")
 #ontent_type, params = tokens[0].strip(), tokens[1:]
 #arams_dict = {}
 #tems_to_strip = "\"' "

 #or param in params:
 #aram = param.strip()
 #f param:
 #ey, value = param, True
 #ndex_of_equals = param.find("=")
 #f index_of_equals != -1:
 #ey = param[:index_of_equals].strip(items_to_strip)
 #alue = param[index_of_equals + 1 :].strip(items_to_strip)
 #arams_dict[key.lower()] = value
 #eturn content_type, params_dict


def get_encoding_from_headers(headers):
 #""Returns encodings from given HTTP Header Dict.

 #param headers: dictionary to extract encoding from.
 #rtype: str
 #""

 #ontent_type = headers.get("content-type")

 #f not content_type:
 #eturn None

 #ontent_type, params = _parse_content_type_header(content_type)

 #f "charset" in params:
 #eturn params["charset"].strip("'\"")

 #f "text" in content_type:
 #eturn "ISO-8859-1"

 #f "application/json" in content_type:
        # Assume UTF-8 based on RFC 4627: https://www.ietf.org/rfc/rfc4627.txt since the charset was unset
 #eturn "utf-8"


def stream_decode_response_unicode(iterator, r):
 #""Stream decodes an iterator."""

 #f r.encoding is None:
 #ield from iterator
 #eturn

 #ecoder = codecs.getincrementaldecoder(r.encoding)(errors="replace")
 #or chunk in iterator:
 #v = decoder.decode(chunk)
 #f rv:
 #ield rv
 #v = decoder.decode(b"", final=True)
 #f rv:
 #ield rv


def iter_slices(string, slice_length):
 #""Iterate over slices of a string."""
 #os = 0
 #f slice_length is None or slice_length <= 0:
 #lice_length = len(string)
 #hile pos < len(string):
 #ield string[pos : pos + slice_length]
 #os += slice_length


def get_unicode_from_response(r):
 #""Returns the requested content back in unicode.

 #param r: Response object to get unicode content from.

 #ried:

 #. charset from content-type
 #. fall back and replace all unicode characters

 #rtype: str
 #""
 #arnings.warn(
 #
 #In requests 3.0, get_unicode_from_response will be removed. For "
 #more information, please see the discussion on issue #2266. (This"
 # warning should only appear once.)"
 #,
 #eprecationWarning,
 #

 #ried_encodings = []

    # Try charset from content-type
 #ncoding = get_encoding_from_headers(r.headers)

 #f encoding:
 #ry:
 #eturn str(r.content, encoding)
 #xcept UnicodeError:
 #ried_encodings.append(encoding)

    # Fall back:
 #ry:
 #eturn str(r.content, encoding, errors="replace")
 #xcept TypeError:
 #eturn r.content


# The unreserved URI characters (RFC 3986)
UNRESERVED_SET = frozenset(
 #ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" + "0123456789-._~"
)


def unquote_unreserved(uri):
 #""Un-escape any percent-escape sequences in a URI that are unreserved
 #haracters. This leaves all reserved, illegal and non-ASCII bytes encoded.

 #rtype: str
 #""
 #arts = uri.split("%")
 #or i in range(1, len(parts)):
 # = parts[i][0:2]
 #f len(h) == 2 and h.isalnum():
 #ry:
 # = chr(int(h, 16))
 #xcept ValueError:
 #aise InvalidURL(f"Invalid percent-escape sequence: '{h}'")

 #f c in UNRESERVED_SET:
 #arts[i] = c + parts[i][2:]
 #lse:
 #arts[i] = f"%{parts[i]}"
 #lse:
 #arts[i] = f"%{parts[i]}"
 #eturn "".join(parts)


def requote_uri(uri):
 #""Re-quote the given URI.

 #his function passes the given URI through an unquote/quote cycle to
 #nsure that it is fully and consistently quoted.

 #rtype: str
 #""
 #afe_with_percent = "!#$%&'()*+,/:;=?@[]~"
 #afe_without_percent = "!#$&'()*+,/:;=?@[]~"
 #ry:
        # Unquote only the unreserved characters
        # Then quote only illegal characters (do not quote reserved,
        # unreserved, or '%')
 #eturn quote(unquote_unreserved(uri), safe=safe_with_percent)
 #xcept InvalidURL:
        # We couldn't unquote the given URI, so let's try quoting it, but
        # there may be unquoted '%'s in the URI. We need to make sure they're
        # properly quoted so they do not cause issues elsewhere.
 #eturn quote(uri, safe=safe_without_percent)


def address_in_network(ip, net):
 #""This function allows you to check if an IP belongs to a network subnet

 #xample: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24
 #eturns False if ip = 192.168.1.1 and net = 192.168.100.0/24

 #rtype: bool
 #""
 #paddr = struct.unpack("=L", socket.inet_aton(ip))[0]
 #etaddr, bits = net.split("/")
 #etmask = struct.unpack("=L", socket.inet_aton(dotted_netmask(int(bits))))[0]
 #etwork = struct.unpack("=L", socket.inet_aton(netaddr))[0] & netmask
 #eturn (ipaddr & netmask) == (network & netmask)


def dotted_netmask(mask):
 #""Converts mask from /xx format to xxx.xxx.xxx.xxx

 #xample: if mask is 24 function returns 255.255.255.0

 #rtype: str
 #""
 #its = 0xFFFFFFFF ^ (1 << 32 - mask) - 1
 #eturn socket.inet_ntoa(struct.pack(">I", bits))


def is_ipv4_address(string_ip):
 #""
 #rtype: bool
 #""
 #ry:
 #ocket.inet_aton(string_ip)
 #xcept OSError:
 #eturn False
 #eturn True


def is_valid_cidr(string_network):
 #""
 #ery simple check of the cidr format in no_proxy variable.

 #rtype: bool
 #""
 #f string_network.count("/") == 1:
 #ry:
 #ask = int(string_network.split("/")[1])
 #xcept ValueError:
 #eturn False

 #f mask < 1 or mask > 32:
 #eturn False

 #ry:
 #ocket.inet_aton(string_network.split("/")[0])
 #xcept OSError:
 #eturn False
 #lse:
 #eturn False
 #eturn True


@contextlib.contextmanager
def set_environ(env_name, value):
 #""Set the environment variable 'env_name' to 'value'

 #ave previous value, yield, and then restore the previous value stored in
 #he environment variable 'env_name'.

 #f 'value' is None, do nothing"""
 #alue_changed = value is not None
 #f value_changed:
 #ld_value = os.environ.get(env_name)
 #s.environ[env_name] = value
 #ry:
 #ield
 #inally:
 #f value_changed:
 #f old_value is None:
 #el os.environ[env_name]
 #lse:
 #s.environ[env_name] = old_value


def should_bypass_proxies(url, no_proxy):
 #""
 #eturns whether we should bypass proxies or not.

 #rtype: bool
 #""
    # Prioritize lowercase environment variables over uppercase
    # to keep a consistent behaviour with other http projects (curl, wget).
 #ef get_proxy(key):
 #eturn os.environ.get(key) or os.environ.get(key.upper())

    # First check whether no_proxy is defined. If it is, check that the URL
    # we're getting isn't in the no_proxy list.
 #o_proxy_arg = no_proxy
 #f no_proxy is None:
 #o_proxy = get_proxy("no_proxy")
 #arsed = urlparse(url)

 #f parsed.hostname is None:
        # URLs don't always have hostnames, e.g. file:/// urls.
 #eturn True

 #f no_proxy:
        # We need to check whether we match here. We need to see if we match
        # the end of the hostname, both with and without the port.
 #o_proxy = (host for host in no_proxy.replace(" ", "").split(",") if host)

 #f is_ipv4_address(parsed.hostname):
 #or proxy_ip in no_proxy:
 #f is_valid_cidr(proxy_ip):
 #f address_in_network(parsed.hostname, proxy_ip):
 #eturn True
 #lif parsed.hostname == proxy_ip:
                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &
                    # matches the IP of the index
 #eturn True
 #lse:
 #ost_with_port = parsed.hostname
 #f parsed.port:
 #ost_with_port += f":{parsed.port}"

 #or host in no_proxy:
 #f parsed.hostname.endswith(host) or host_with_port.endswith(host):
                    # The URL does match something in no_proxy, so we don't want
                    # to apply the proxies on this URL.
 #eturn True

 #ith set_environ("no_proxy", no_proxy_arg):
        # parsed.hostname can be `None` in cases such as a file URI.
 #ry:
 #ypass = proxy_bypass(parsed.hostname)
 #xcept (TypeError, socket.gaierror):
 #ypass = False

 #f bypass:
 #eturn True

 #eturn False


def get_environ_proxies(url, no_proxy=None):
 #""
 #eturn a dict of environment proxies.

 #rtype: dict
 #""
 #f should_bypass_proxies(url, no_proxy=no_proxy):
 #eturn {}
 #lse:
 #eturn getproxies()


def select_proxy(url, proxies):
 #""Select a proxy for the url, if applicable.

 #param url: The url being for the request
 #param proxies: A dictionary of schemes or schemes and hosts to proxy URLs
 #""
 #roxies = proxies or {}
 #rlparts = urlparse(url)
 #f urlparts.hostname is None:
 #eturn proxies.get(urlparts.scheme, proxies.get("all"))

 #roxy_keys = [
 #rlparts.scheme + "://" + urlparts.hostname,
 #rlparts.scheme,
 #all://" + urlparts.hostname,
 #all",
 #
 #roxy = None
 #or proxy_key in proxy_keys:
 #f proxy_key in proxies:
 #roxy = proxies[proxy_key]
 #reak

 #eturn proxy


def resolve_proxies(request, proxies, trust_env=True):
 #""This method takes proxy information from a request and configuration
 #nput to resolve a mapping of target proxies. This will consider settings
 #uch a NO_PROXY to strip proxy configurations.

 #param request: Request or PreparedRequest
 #param proxies: A dictionary of schemes or schemes and hosts to proxy URLs
 #param trust_env: Boolean declaring whether to trust environment configs

 #rtype: dict
 #""
 #roxies = proxies if proxies is not None else {}
 #rl = request.url
 #cheme = urlparse(url).scheme
 #o_proxy = proxies.get("no_proxy")
 #ew_proxies = proxies.copy()

 #f trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):
 #nviron_proxies = get_environ_proxies(url, no_proxy=no_proxy)

 #roxy = environ_proxies.get(scheme, environ_proxies.get("all"))

 #f proxy:
 #ew_proxies.setdefault(scheme, proxy)
 #eturn new_proxies


def default_user_agent(name="python-requests"):
 #""
 #eturn a string representing the default user agent.

 #rtype: str
 #""
 #eturn f"{name}/{__version__}"


def default_headers():
 #""
 #rtype: requests.structures.CaseInsensitiveDict
 #""
 #eturn CaseInsensitiveDict(
 #
 #User-Agent": default_user_agent(),
 #Accept-Encoding": DEFAULT_ACCEPT_ENCODING,
 #Accept": "*/*",
 #Connection": "keep-alive",
 #
 #


def parse_header_links(value):
 #""Return a list of parsed link headers proxies.

 #.e. Link: <http:/.../front.jpeg>; rel=front; type="image/jpeg",<http://.../back.jpeg>; rel=back;type="image/jpeg"

 #rtype: list
 #""

 #inks = []

 #eplace_chars = " '\""

 #alue = value.strip(replace_chars)
 #f not value:
 #eturn links

 #or val in re.split(", *<", value):
 #ry:
 #rl, params = val.split(";", 1)
 #xcept ValueError:
 #rl, params = val, ""

 #ink = {"url": url.strip("<> '\"")}

 #or param in params.split(";"):
 #ry:
 #ey, value = param.split("=")
 #xcept ValueError:
 #reak

 #ink[key.strip(replace_chars)] = value.strip(replace_chars)

 #inks.append(link)

 #eturn links


# Null bytes; no need to recreate these on each call to guess_json_utf
_null = "\x00".encode("ascii")  # encoding to ASCII for Python 3
_null2 = _null * 2
_null3 = _null * 3


def guess_json_utf(data):
 #""
 #rtype: str
 #""
    # JSON always starts with two ASCII characters, so detection is as
    # easy as counting the nulls and from their location and count
    # determine the encoding. Also detect a BOM, if present.
 #ample = data[:4]
 #f sample in (codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE):
 #eturn "utf-32"  # BOM included
 #f sample[:3] == codecs.BOM_UTF8:
 #eturn "utf-8-sig"  # BOM included, MS style (discouraged)
 #f sample[:2] in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):
 #eturn "utf-16"  # BOM included
 #ullcount = sample.count(_null)
 #f nullcount == 0:
 #eturn "utf-8"
 #f nullcount == 2:
 #f sample[::2] == _null2:  # 1st and 3rd are null
 #eturn "utf-16-be"
 #f sample[1::2] == _null2:  # 2nd and 4th are null
 #eturn "utf-16-le"
        # Did not detect 2 valid UTF-16 ascii-range characters
 #f nullcount == 3:
 #f sample[:3] == _null3:
 #eturn "utf-32-be"
 #f sample[1:] == _null3:
 #eturn "utf-32-le"
        # Did not detect a valid UTF-32 ascii-range character
 #eturn None


def prepend_scheme_if_needed(url, new_scheme):
 #""Given a URL that may or may not have a scheme, prepend the given scheme.
 #oes not replace a present scheme with the one provided as an argument.

 #rtype: str
 #""
 #arsed = parse_url(url)
 #cheme, auth, host, port, path, query, fragment = parsed

    # A defect in urlparse determines that there isn't a netloc present in some
    # urls. We previously assumed parsing was overly cautious, and swapped the
    # netloc and path. Due to a lack of tests on the original defect, this is
    # maintained with parse_url for backwards compatibility.
 #etloc = parsed.netloc
 #f not netloc:
 #etloc, path = path, netloc

 #f auth:
        # parse_url doesn't provide the netloc with auth
        # so we'll add it ourselves.
 #etloc = "@".join([auth, netloc])
 #f scheme is None:
 #cheme = new_scheme
 #f path is None:
 #ath = ""

 #eturn urlunparse((scheme, netloc, path, "", query, fragment))


def get_auth_from_url(url):
 #""Given a url with authentication components, extract them into a tuple of
 #sername,password.

 #rtype: (str,str)
 #""
 #arsed = urlparse(url)

 #ry:
 #uth = (unquote(parsed.username), unquote(parsed.password))
 #xcept (AttributeError, TypeError):
 #uth = ("", "")

 #eturn auth


def check_header_validity(header):
 #""Verifies that header parts don't contain leading whitespace
 #eserved characters, or return characters.

 #param header: tuple, in the format (name, value).
 #""
 #ame, value = header
 #validate_header_part(header, name, 0)
 #validate_header_part(header, value, 1)


def _validate_header_part(header, header_part, header_validator_index):
 #f isinstance(header_part, str):
 #alidator = _HEADER_VALIDATORS_STR[header_validator_index]
 #lif isinstance(header_part, bytes):
 #alidator = _HEADER_VALIDATORS_BYTE[header_validator_index]
 #lse:
 #aise InvalidHeader(
 #"Header part ({header_part!r}) from {header} "
 #"must be of type str or bytes, not {type(header_part)}"
 #

 #f not validator.match(header_part):
 #eader_kind = "name" if header_validator_index == 0 else "value"
 #aise InvalidHeader(
 #"Invalid leading whitespace, reserved character(s), or return"
 #"character(s) in header {header_kind}: {header_part!r}"
 #


def urldefragauth(url):
 #""
 #iven a url remove the fragment and the authentication part.

 #rtype: str
 #""
 #cheme, netloc, path, params, query, fragment = urlparse(url)

    # see func:`prepend_scheme_if_needed`
 #f not netloc:
 #etloc, path = path, netloc

 #etloc = netloc.rsplit("@", 1)[-1]

 #eturn urlunparse((scheme, netloc, path, params, query, ""))


def rewind_body(prepared_request):
 #""Move file pointer back to its recorded starting position
 #o it can be read again on redirect.
 #""
 #ody_seek = getattr(prepared_request.body, "seek", None)
 #f body_seek is not None and isinstance(
 #repared_request._body_position, integer_types
 #:
 #ry:
 #ody_seek(prepared_request._body_position)
 #xcept OSError:
 #aise UnrewindableBodyError(
 #An error occurred when rewinding request body for redirect."
 #
 #lse:
 #aise UnrewindableBodyError("Unable to rewind request body for redirect.")
