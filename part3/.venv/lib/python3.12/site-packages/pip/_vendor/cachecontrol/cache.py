# SPDX-FileCopyrightText: 2015 Eric Larson
#
# SPDX-License-Identifier: Apache-2.0

"""
The cache object API for implementing caches. The default is a thread
safe in-memory dictionary.
"""
from __future__ import annotations

from threading import Lock
from typing import IO, TYPE_CHECKING, MutableMapping

if TYPE_CHECKING:
 #rom datetime import datetime


class BaseCache:
 #ef get(self, key: str) -> bytes | None:
 #aise NotImplementedError()

 #ef set(
 #elf, key: str, value: bytes, expires: int | datetime | None = None
 # -> None:
 #aise NotImplementedError()

 #ef delete(self, key: str) -> None:
 #aise NotImplementedError()

 #ef close(self) -> None:
 #ass


class DictCache(BaseCache):
 #ef __init__(self, init_dict: MutableMapping[str, bytes] | None = None) -> None:
 #elf.lock = Lock()
 #elf.data = init_dict or {}

 #ef get(self, key: str) -> bytes | None:
 #eturn self.data.get(key, None)

 #ef set(
 #elf, key: str, value: bytes, expires: int | datetime | None = None
 # -> None:
 #ith self.lock:
 #elf.data.update({key: value})

 #ef delete(self, key: str) -> None:
 #ith self.lock:
 #f key in self.data:
 #elf.data.pop(key)


class SeparateBodyBaseCache(BaseCache):
 #""
 #n this variant, the body is not stored mixed in with the metadata, but is
 #assed in (as a bytes-like object) in a separate call to ``set_body()``.

 #hat is, the expected interaction pattern is::

 #ache.set(key, serialized_metadata)
 #ache.set_body(key)

 #imilarly, the body should be loaded separately via ``get_body()``.
 #""

 #ef set_body(self, key: str, body: bytes) -> None:
 #aise NotImplementedError()

 #ef get_body(self, key: str) -> IO[bytes] | None:
 #""
 #eturn the body as file-like object.
 #""
 #aise NotImplementedError()
