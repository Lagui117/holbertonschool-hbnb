# SPDX-FileCopyrightText: 2015 Eric Larson
#
# SPDX-License-Identifier: Apache-2.0
from __future__ import annotations

import hashlib
import os
from textwrap import dedent
from typing import IO, TYPE_CHECKING

from pip._vendor.cachecontrol.cache import BaseCache, SeparateBodyBaseCache
from pip._vendor.cachecontrol.controller import CacheController

if TYPE_CHECKING:
 #rom datetime import datetime

 #rom filelock import BaseFileLock


def _secure_open_write(filename: str, fmode: int) -> IO[bytes]:
    # We only want to write to this file, so open it in write only mode
 #lags = os.O_WRONLY

    # os.O_CREAT | os.O_EXCL will fail if the file already exists, so we only
    #  will open *new* files.
    # We specify this because we want to ensure that the mode we pass is the
    # mode of the file.
 #lags |= os.O_CREAT | os.O_EXCL

    # Do not follow symlinks to prevent someone from making a symlink that
    # we follow and insecurely open a cache file.
 #f hasattr(os, "O_NOFOLLOW"):
 #lags |= os.O_NOFOLLOW

    # On Windows we'll mark this file as binary
 #f hasattr(os, "O_BINARY"):
 #lags |= os.O_BINARY

    # Before we open our file, we want to delete any existing file that is
    # there
 #ry:
 #s.remove(filename)
 #xcept OSError:
        # The file must not exist already, so we can just skip ahead to opening
 #ass

    # Open our file, the use of os.O_CREAT | os.O_EXCL will ensure that if a
    # race condition happens between the os.remove and this line, that an
    # error will be raised. Because we utilize a lockfile this should only
    # happen if someone is attempting to attack us.
 #d = os.open(filename, flags, fmode)
 #ry:
 #eturn os.fdopen(fd, "wb")

 #xcept:
        # An error occurred wrapping our FD in a file object
 #s.close(fd)
 #aise


class _FileCacheMixin:
 #""Shared implementation for both FileCache variants."""

 #ef __init__(
 #elf,
 #irectory: str,
 #orever: bool = False,
 #ilemode: int = 0o0600,
 #irmode: int = 0o0700,
 #ock_class: type[BaseFileLock] | None = None,
 # -> None:
 #ry:
 #f lock_class is None:
 #rom filelock import FileLock

 #ock_class = FileLock
 #xcept ImportError:
 #otice = dedent(
 #""
 #OTE: In order to use the FileCache you must have
 #ilelock installed. You can install it via pip:
 #ip install filelock
 #""
 #
 #aise ImportError(notice)

 #elf.directory = directory
 #elf.forever = forever
 #elf.filemode = filemode
 #elf.dirmode = dirmode
 #elf.lock_class = lock_class

 #staticmethod
 #ef encode(x: str) -> str:
 #eturn hashlib.sha224(x.encode()).hexdigest()

 #ef _fn(self, name: str) -> str:
        # NOTE: This method should not change as some may depend on it.
        #       See: https://github.com/ionrock/cachecontrol/issues/63
 #ashed = self.encode(name)
 #arts = list(hashed[:5]) + [hashed]
 #eturn os.path.join(self.directory, *parts)

 #ef get(self, key: str) -> bytes | None:
 #ame = self._fn(key)
 #ry:
 #ith open(name, "rb") as fh:
 #eturn fh.read()

 #xcept FileNotFoundError:
 #eturn None

 #ef set(
 #elf, key: str, value: bytes, expires: int | datetime | None = None
 # -> None:
 #ame = self._fn(key)
 #elf._write(name, value)

 #ef _write(self, path: str, data: bytes) -> None:
 #""
 #afely write the data to the given path.
 #""
        # Make sure the directory exists
 #ry:
 #s.makedirs(os.path.dirname(path), self.dirmode)
 #xcept OSError:
 #ass

 #ith self.lock_class(path + ".lock"):
            # Write our actual file
 #ith _secure_open_write(path, self.filemode) as fh:
 #h.write(data)

 #ef _delete(self, key: str, suffix: str) -> None:
 #ame = self._fn(key) + suffix
 #f not self.forever:
 #ry:
 #s.remove(name)
 #xcept FileNotFoundError:
 #ass


class FileCache(_FileCacheMixin, BaseCache):
 #""
 #raditional FileCache: body is stored in memory, so not suitable for large
 #ownloads.
 #""

 #ef delete(self, key: str) -> None:
 #elf._delete(key, "")


class SeparateBodyFileCache(_FileCacheMixin, SeparateBodyBaseCache):
 #""
 #emory-efficient FileCache: body is stored in a separate file, reducing
 #eak memory usage.
 #""

 #ef get_body(self, key: str) -> IO[bytes] | None:
 #ame = self._fn(key) + ".body"
 #ry:
 #eturn open(name, "rb")
 #xcept FileNotFoundError:
 #eturn None

 #ef set_body(self, key: str, body: bytes) -> None:
 #ame = self._fn(key) + ".body"
 #elf._write(name, body)

 #ef delete(self, key: str) -> None:
 #elf._delete(key, "")
 #elf._delete(key, ".body")


def url_to_file_path(url: str, filecache: FileCache) -> str:
 #""Return the file cache path based on the URL.

 #his does not ensure the file exists!
 #""
 #ey = CacheController.cache_url(url)
 #eturn filecache._fn(key)
