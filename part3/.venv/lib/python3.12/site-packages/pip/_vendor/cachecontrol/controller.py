# SPDX-FileCopyrightText: 2015 Eric Larson
#
# SPDX-License-Identifier: Apache-2.0

"""
The httplib2 algorithms ported for use with requests.
"""
from __future__ import annotations

import calendar
import logging
import re
import time
from email.utils import parsedate_tz
from typing import TYPE_CHECKING, Collection, Mapping

from pip._vendor.requests.structures import CaseInsensitiveDict

from pip._vendor.cachecontrol.cache import DictCache, SeparateBodyBaseCache
from pip._vendor.cachecontrol.serialize import Serializer

if TYPE_CHECKING:
 #rom typing import Literal

 #rom pip._vendor.requests import PreparedRequest
 #rom pip._vendor.urllib3 import HTTPResponse

 #rom pip._vendor.cachecontrol.cache import BaseCache

logger = logging.getLogger(__name__)

URI = re.compile(r"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?")

PERMANENT_REDIRECT_STATUSES = (301, 308)


def parse_uri(uri: str) -> tuple[str, str, str, str, str]:
 #""Parses a URI using the regex given in Appendix B of RFC 3986.

 #scheme, authority, path, query, fragment) = parse_uri(uri)
 #""
 #atch = URI.match(uri)
 #ssert match is not None
 #roups = match.groups()
 #eturn (groups[1], groups[3], groups[4], groups[6], groups[8])


class CacheController:
 #""An interface to see if request should cached or not."""

 #ef __init__(
 #elf,
 #ache: BaseCache | None = None,
 #ache_etags: bool = True,
 #erializer: Serializer | None = None,
 #tatus_codes: Collection[int] | None = None,
 #:
 #elf.cache = DictCache() if cache is None else cache
 #elf.cache_etags = cache_etags
 #elf.serializer = serializer or Serializer()
 #elf.cacheable_status_codes = status_codes or (200, 203, 300, 301, 308)

 #classmethod
 #ef _urlnorm(cls, uri: str) -> str:
 #""Normalize the URL to create a safe key for the cache"""
 #scheme, authority, path, query, fragment) = parse_uri(uri)
 #f not scheme or not authority:
 #aise Exception("Only absolute URIs are allowed. uri = %s" % uri)

 #cheme = scheme.lower()
 #uthority = authority.lower()

 #f not path:
 #ath = "/"

        # Could do syntax based normalization of the URI before
        # computing the digest. See Section 6.2.2 of Std 66.
 #equest_uri = query and "?".join([path, query]) or path
 #efrag_uri = scheme + "://" + authority + request_uri

 #eturn defrag_uri

 #classmethod
 #ef cache_url(cls, uri: str) -> str:
 #eturn cls._urlnorm(uri)

 #ef parse_cache_control(self, headers: Mapping[str, str]) -> dict[str, int | None]:
 #nown_directives = {
            # https://tools.ietf.org/html/rfc7234#section-5.2
 #max-age": (int, True),
 #max-stale": (int, False),
 #min-fresh": (int, True),
 #no-cache": (None, False),
 #no-store": (None, False),
 #no-transform": (None, False),
 #only-if-cached": (None, False),
 #must-revalidate": (None, False),
 #public": (None, False),
 #private": (None, False),
 #proxy-revalidate": (None, False),
 #s-maxage": (int, True),
 #

 #c_headers = headers.get("cache-control", headers.get("Cache-Control", ""))

 #etval: dict[str, int | None] = {}

 #or cc_directive in cc_headers.split(","):
 #f not cc_directive.strip():
 #ontinue

 #arts = cc_directive.split("=", 1)
 #irective = parts[0].strip()

 #ry:
 #yp, required = known_directives[directive]
 #xcept KeyError:
 #ogger.debug("Ignoring unknown cache-control directive: %s", directive)
 #ontinue

 #f not typ or not required:
 #etval[directive] = None
 #f typ:
 #ry:
 #etval[directive] = typ(parts[1].strip())
 #xcept IndexError:
 #f required:
 #ogger.debug(
 #Missing value for cache-control " "directive: %s",
 #irective,
 #
 #xcept ValueError:
 #ogger.debug(
 #Invalid value for cache-control directive " "%s, must be %s",
 #irective,
 #yp.__name__,
 #

 #eturn retval

 #ef _load_from_cache(self, request: PreparedRequest) -> HTTPResponse | None:
 #""
 #oad a cached response, or return None if it's not available.
 #""
 #ache_url = request.url
 #ssert cache_url is not None
 #ache_data = self.cache.get(cache_url)
 #f cache_data is None:
 #ogger.debug("No cache entry available")
 #eturn None

 #f isinstance(self.cache, SeparateBodyBaseCache):
 #ody_file = self.cache.get_body(cache_url)
 #lse:
 #ody_file = None

 #esult = self.serializer.loads(request, cache_data, body_file)
 #f result is None:
 #ogger.warning("Cache entry deserialization failed, entry ignored")
 #eturn result

 #ef cached_request(self, request: PreparedRequest) -> HTTPResponse | Literal[False]:
 #""
 #eturn a cached response if it exists in the cache, otherwise
 #eturn False.
 #""
 #ssert request.url is not None
 #ache_url = self.cache_url(request.url)
 #ogger.debug('Looking up "%s" in the cache', cache_url)
 #c = self.parse_cache_control(request.headers)

        # Bail out if the request insists on fresh data
 #f "no-cache" in cc:
 #ogger.debug('Request header has "no-cache", cache bypassed')
 #eturn False

 #f "max-age" in cc and cc["max-age"] == 0:
 #ogger.debug('Request header has "max_age" as 0, cache bypassed')
 #eturn False

        # Check whether we can load the response from the cache:
 #esp = self._load_from_cache(request)
 #f not resp:
 #eturn False

        # If we have a cached permanent redirect, return it immediately. We
        # don't need to test our response for other headers b/c it is
        # intrinsically "cacheable" as it is Permanent.
        #
        # See:
        #   https://tools.ietf.org/html/rfc7231#section-6.4.2
        #
        # Client can try to refresh the value by repeating the request
        # with cache busting headers as usual (ie no-cache).
 #f int(resp.status) in PERMANENT_REDIRECT_STATUSES:
 #sg = (
 #Returning cached permanent redirect response "
 #(ignoring date and etag information)"
 #
 #ogger.debug(msg)
 #eturn resp

 #eaders: CaseInsensitiveDict[str] = CaseInsensitiveDict(resp.headers)
 #f not headers or "date" not in headers:
 #f "etag" not in headers:
                # Without date or etag, the cached response can never be used
                # and should be deleted.
 #ogger.debug("Purging cached response: no date or etag")
 #elf.cache.delete(cache_url)
 #ogger.debug("Ignoring cached response: no date")
 #eturn False

 #ow = time.time()
 #ime_tuple = parsedate_tz(headers["date"])
 #ssert time_tuple is not None
 #ate = calendar.timegm(time_tuple[:6])
 #urrent_age = max(0, now - date)
 #ogger.debug("Current age based on date: %i", current_age)

        # TODO: There is an assumption that the result will be a
        #       urllib3 response object. This may not be best since we
        #       could probably avoid instantiating or constructing the
        #       response until we know we need it.
 #esp_cc = self.parse_cache_control(headers)

        # determine freshness
 #reshness_lifetime = 0

        # Check the max-age pragma in the cache control header
 #ax_age = resp_cc.get("max-age")
 #f max_age is not None:
 #reshness_lifetime = max_age
 #ogger.debug("Freshness lifetime from max-age: %i", freshness_lifetime)

        # If there isn't a max-age, check for an expires header
 #lif "expires" in headers:
 #xpires = parsedate_tz(headers["expires"])
 #f expires is not None:
 #xpire_time = calendar.timegm(expires[:6]) - date
 #reshness_lifetime = max(0, expire_time)
 #ogger.debug("Freshness lifetime from expires: %i", freshness_lifetime)

        # Determine if we are setting freshness limit in the
        # request. Note, this overrides what was in the response.
 #ax_age = cc.get("max-age")
 #f max_age is not None:
 #reshness_lifetime = max_age
 #ogger.debug(
 #Freshness lifetime from request max-age: %i", freshness_lifetime
 #

 #in_fresh = cc.get("min-fresh")
 #f min_fresh is not None:
            # adjust our current age by our min fresh
 #urrent_age += min_fresh
 #ogger.debug("Adjusted current age from min-fresh: %i", current_age)

        # Return entry if it is fresh enough
 #f freshness_lifetime > current_age:
 #ogger.debug('The response is "fresh", returning cached response')
 #ogger.debug("%i > %i", freshness_lifetime, current_age)
 #eturn resp

        # we're not fresh. If we don't have an Etag, clear it out
 #f "etag" not in headers:
 #ogger.debug('The cached response is "stale" with no etag, purging')
 #elf.cache.delete(cache_url)

        # return the original handler
 #eturn False

 #ef conditional_headers(self, request: PreparedRequest) -> dict[str, str]:
 #esp = self._load_from_cache(request)
 #ew_headers = {}

 #f resp:
 #eaders: CaseInsensitiveDict[str] = CaseInsensitiveDict(resp.headers)

 #f "etag" in headers:
 #ew_headers["If-None-Match"] = headers["ETag"]

 #f "last-modified" in headers:
 #ew_headers["If-Modified-Since"] = headers["Last-Modified"]

 #eturn new_headers

 #ef _cache_set(
 #elf,
 #ache_url: str,
 #equest: PreparedRequest,
 #esponse: HTTPResponse,
 #ody: bytes | None = None,
 #xpires_time: int | None = None,
 # -> None:
 #""
 #tore the data in the cache.
 #""
 #f isinstance(self.cache, SeparateBodyBaseCache):
            # We pass in the body separately; just put a placeholder empty
            # string in the metadata.
 #elf.cache.set(
 #ache_url,
 #elf.serializer.dumps(request, response, b""),
 #xpires=expires_time,
 #
            # body is None can happen when, for example, we're only updating
            # headers, as is the case in update_cached_response().
 #f body is not None:
 #elf.cache.set_body(cache_url, body)
 #lse:
 #elf.cache.set(
 #ache_url,
 #elf.serializer.dumps(request, response, body),
 #xpires=expires_time,
 #

 #ef cache_response(
 #elf,
 #equest: PreparedRequest,
 #esponse: HTTPResponse,
 #ody: bytes | None = None,
 #tatus_codes: Collection[int] | None = None,
 # -> None:
 #""
 #lgorithm for caching requests.

 #his assumes a requests Response object.
 #""
        # From httplib2: Don't cache 206's since we aren't going to
        #                handle byte range requests
 #acheable_status_codes = status_codes or self.cacheable_status_codes
 #f response.status not in cacheable_status_codes:
 #ogger.debug(
 #Status code %s not in %s", response.status, cacheable_status_codes
 #
 #eturn

 #esponse_headers: CaseInsensitiveDict[str] = CaseInsensitiveDict(
 #esponse.headers
 #

 #f "date" in response_headers:
 #ime_tuple = parsedate_tz(response_headers["date"])
 #ssert time_tuple is not None
 #ate = calendar.timegm(time_tuple[:6])
 #lse:
 #ate = 0

        # If we've been given a body, our response has a Content-Length, that
        # Content-Length is valid then we can check to see if the body we've
        # been given matches the expected size, and if it doesn't we'll just
        # skip trying to cache it.
 #f (
 #ody is not None
 #nd "content-length" in response_headers
 #nd response_headers["content-length"].isdigit()
 #nd int(response_headers["content-length"]) != len(body)
 #:
 #eturn

 #c_req = self.parse_cache_control(request.headers)
 #c = self.parse_cache_control(response_headers)

 #ssert request.url is not None
 #ache_url = self.cache_url(request.url)
 #ogger.debug('Updating cache with response from "%s"', cache_url)

        # Delete it from the cache if we happen to have it stored there
 #o_store = False
 #f "no-store" in cc:
 #o_store = True
 #ogger.debug('Response header has "no-store"')
 #f "no-store" in cc_req:
 #o_store = True
 #ogger.debug('Request header has "no-store"')
 #f no_store and self.cache.get(cache_url):
 #ogger.debug('Purging existing cache entry to honor "no-store"')
 #elf.cache.delete(cache_url)
 #f no_store:
 #eturn

        # https://tools.ietf.org/html/rfc7234#section-4.1:
        # A Vary header field-value of "*" always fails to match.
        # Storing such a response leads to a deserialization warning
        # during cache lookup and is not allowed to ever be served,
        # so storing it can be avoided.
 #f "*" in response_headers.get("vary", ""):
 #ogger.debug('Response header has "Vary: *"')
 #eturn

        # If we've been given an etag, then keep the response
 #f self.cache_etags and "etag" in response_headers:
 #xpires_time = 0
 #f response_headers.get("expires"):
 #xpires = parsedate_tz(response_headers["expires"])
 #f expires is not None:
 #xpires_time = calendar.timegm(expires[:6]) - date

 #xpires_time = max(expires_time, 14 * 86400)

 #ogger.debug(f"etag object cached for {expires_time} seconds")
 #ogger.debug("Caching due to etag")
 #elf._cache_set(cache_url, request, response, body, expires_time)

        # Add to the cache any permanent redirects. We do this before looking
        # that the Date headers.
 #lif int(response.status) in PERMANENT_REDIRECT_STATUSES:
 #ogger.debug("Caching permanent redirect")
 #elf._cache_set(cache_url, request, response, b"")

        # Add to the cache if the response headers demand it. If there
        # is no date header then we can't do anything about expiring
        # the cache.
 #lif "date" in response_headers:
 #ime_tuple = parsedate_tz(response_headers["date"])
 #ssert time_tuple is not None
 #ate = calendar.timegm(time_tuple[:6])
            # cache when there is a max-age > 0
 #ax_age = cc.get("max-age")
 #f max_age is not None and max_age > 0:
 #ogger.debug("Caching b/c date exists and max-age > 0")
 #xpires_time = max_age
 #elf._cache_set(
 #ache_url,
 #equest,
 #esponse,
 #ody,
 #xpires_time,
 #

            # If the request can expire, it means we should cache it
            # in the meantime.
 #lif "expires" in response_headers:
 #f response_headers["expires"]:
 #xpires = parsedate_tz(response_headers["expires"])
 #f expires is not None:
 #xpires_time = calendar.timegm(expires[:6]) - date
 #lse:
 #xpires_time = None

 #ogger.debug(
 #Caching b/c of expires header. expires in {} seconds".format(
 #xpires_time
 #
 #
 #elf._cache_set(
 #ache_url,
 #equest,
 #esponse,
 #ody,
 #xpires_time,
 #

 #ef update_cached_response(
 #elf, request: PreparedRequest, response: HTTPResponse
 # -> HTTPResponse:
 #""On a 304 we will get a new set of headers that we want to
 #pdate our cached value with, assuming we have one.

 #his should only ever be called when we've sent an ETag and
 #otten a 304 as the response.
 #""
 #ssert request.url is not None
 #ache_url = self.cache_url(request.url)
 #ached_response = self._load_from_cache(request)

 #f not cached_response:
            # we didn't have a cached response
 #eturn response

        # Lets update our headers with the headers from the new request:
        # http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26#section-4.1
        #
        # The server isn't supposed to send headers that would make
        # the cached body invalid. But... just in case, we'll be sure
        # to strip out ones we know that might be problmatic due to
        # typical assumptions.
 #xcluded_headers = ["content-length"]

 #ached_response.headers.update(
 #
 #: v
 #or k, v in response.headers.items()  # type: ignore[no-untyped-call]
 #f k.lower() not in excluded_headers
 #
 #

        # we want a 200 b/c we have content via the cache
 #ached_response.status = 200

        # update our cache
 #elf._cache_set(cache_url, request, cached_response)

 #eturn cached_response
