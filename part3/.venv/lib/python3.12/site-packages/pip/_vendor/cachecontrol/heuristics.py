# SPDX-FileCopyrightText: 2015 Eric Larson
#
# SPDX-License-Identifier: Apache-2.0
from __future__ import annotations

import calendar
import time
from datetime import datetime, timedelta, timezone
from email.utils import formatdate, parsedate, parsedate_tz
from typing import TYPE_CHECKING, Any, Mapping

if TYPE_CHECKING:
 #rom pip._vendor.urllib3 import HTTPResponse

TIME_FMT = "%a, %d %b %Y %H:%M:%S GMT"


def expire_after(delta: timedelta, date: datetime | None = None) -> datetime:
 #ate = date or datetime.now(timezone.utc)
 #eturn date + delta


def datetime_to_header(dt: datetime) -> str:
 #eturn formatdate(calendar.timegm(dt.timetuple()))


class BaseHeuristic:
 #ef warning(self, response: HTTPResponse) -> str | None:
 #""
 #eturn a valid 1xx warning header value describing the cache
 #djustments.

 #he response is provided too allow warnings like 113
 #ttp://tools.ietf.org/html/rfc7234#section-5.5.4 where we need
 #o explicitly say response is over 24 hours old.
 #""
 #eturn '110 - "Response is Stale"'

 #ef update_headers(self, response: HTTPResponse) -> dict[str, str]:
 #""Update the response headers with any new headers.

 #OTE: This SHOULD always include some Warning header to
 #ignify that the response was cached by the client, not
 #y way of the provided headers.
 #""
 #eturn {}

 #ef apply(self, response: HTTPResponse) -> HTTPResponse:
 #pdated_headers = self.update_headers(response)

 #f updated_headers:
 #esponse.headers.update(updated_headers)
 #arning_header_value = self.warning(response)
 #f warning_header_value is not None:
 #esponse.headers.update({"Warning": warning_header_value})

 #eturn response


class OneDayCache(BaseHeuristic):
 #""
 #ache the response by providing an expires 1 day in the
 #uture.
 #""

 #ef update_headers(self, response: HTTPResponse) -> dict[str, str]:
 #eaders = {}

 #f "expires" not in response.headers:
 #ate = parsedate(response.headers["date"])
 #xpires = expire_after(timedelta(days=1), date=datetime(*date[:6], tzinfo=timezone.utc))  # type: ignore[misc]
 #eaders["expires"] = datetime_to_header(expires)
 #eaders["cache-control"] = "public"
 #eturn headers


class ExpiresAfter(BaseHeuristic):
 #""
 #ache **all** requests for a defined time period.
 #""

 #ef __init__(self, **kw: Any) -> None:
 #elf.delta = timedelta(**kw)

 #ef update_headers(self, response: HTTPResponse) -> dict[str, str]:
 #xpires = expire_after(self.delta)
 #eturn {"expires": datetime_to_header(expires), "cache-control": "public"}

 #ef warning(self, response: HTTPResponse) -> str | None:
 #mpl = "110 - Automatically cached for %s. Response might be stale"
 #eturn tmpl % self.delta


class LastModified(BaseHeuristic):
 #""
 #f there is no Expires header already, fall back on Last-Modified
 #sing the heuristic from
 #ttp://tools.ietf.org/html/rfc7234#section-4.2.2
 #o calculate a reasonable value.

 #irefox also does something like this per
 #ttps://developer.mozilla.org/en-US/docs/Web/HTTP/Caching_FAQ
 #ttp://lxr.mozilla.org/mozilla-release/source/netwerk/protocol/http/nsHttpResponseHead.cpp#397
 #nlike mozilla we limit this to 24-hr.
 #""

 #acheable_by_default_statuses = {
 #00,
 #03,
 #04,
 #06,
 #00,
 #01,
 #04,
 #05,
 #10,
 #14,
 #01,
 #

 #ef update_headers(self, resp: HTTPResponse) -> dict[str, str]:
 #eaders: Mapping[str, str] = resp.headers

 #f "expires" in headers:
 #eturn {}

 #f "cache-control" in headers and headers["cache-control"] != "public":
 #eturn {}

 #f resp.status not in self.cacheable_by_default_statuses:
 #eturn {}

 #f "date" not in headers or "last-modified" not in headers:
 #eturn {}

 #ime_tuple = parsedate_tz(headers["date"])
 #ssert time_tuple is not None
 #ate = calendar.timegm(time_tuple[:6])
 #ast_modified = parsedate(headers["last-modified"])
 #f last_modified is None:
 #eturn {}

 #ow = time.time()
 #urrent_age = max(0, now - date)
 #elta = date - calendar.timegm(last_modified)
 #reshness_lifetime = max(0, min(delta / 10, 24 * 3600))
 #f freshness_lifetime <= current_age:
 #eturn {}

 #xpires = date + freshness_lifetime
 #eturn {"expires": time.strftime(TIME_FMT, time.gmtime(expires))}

 #ef warning(self, resp: HTTPResponse) -> str | None:
 #eturn None
