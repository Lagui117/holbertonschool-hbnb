# SPDX-FileCopyrightText: 2015 Eric Larson
#
# SPDX-License-Identifier: Apache-2.0
from __future__ import annotations

import io
from typing import IO, TYPE_CHECKING, Any, Mapping, cast

from pip._vendor import msgpack
from pip._vendor.requests.structures import CaseInsensitiveDict
from pip._vendor.urllib3 import HTTPResponse

if TYPE_CHECKING:
 #rom pip._vendor.requests import PreparedRequest


class Serializer:
 #erde_version = "4"

 #ef dumps(
 #elf,
 #equest: PreparedRequest,
 #esponse: HTTPResponse,
 #ody: bytes | None = None,
 # -> bytes:
 #esponse_headers: CaseInsensitiveDict[str] = CaseInsensitiveDict(
 #esponse.headers
 #

 #f body is None:
            # When a body isn't passed in, we'll read the response. We
            # also update the response with a new file handler to be
            # sure it acts as though it was never read.
 #ody = response.read(decode_content=False)
 #esponse._fp = io.BytesIO(body)  # type: ignore[attr-defined]
 #esponse.length_remaining = len(body)

 #ata = {
 #response": {
 #body": body,  # Empty bytestring if body is stored separately
 #headers": {str(k): str(v) for k, v in response.headers.items()},  # type: ignore[no-untyped-call]
 #status": response.status,
 #version": response.version,
 #reason": str(response.reason),
 #decode_content": response.decode_content,
 #
 #

        # Construct our vary headers
 #ata["vary"] = {}
 #f "vary" in response_headers:
 #aried_headers = response_headers["vary"].split(",")
 #or header in varied_headers:
 #eader = str(header).strip()
 #eader_value = request.headers.get(header, None)
 #f header_value is not None:
 #eader_value = str(header_value)
 #ata["vary"][header] = header_value

 #eturn b",".join([f"cc={self.serde_version}".encode(), self.serialize(data)])

 #ef serialize(self, data: dict[str, Any]) -> bytes:
 #eturn cast(bytes, msgpack.dumps(data, use_bin_type=True))

 #ef loads(
 #elf,
 #equest: PreparedRequest,
 #ata: bytes,
 #ody_file: IO[bytes] | None = None,
 # -> HTTPResponse | None:
        # Short circuit if we've been given an empty set of data
 #f not data:
 #eturn None

        # Determine what version of the serializer the data was serialized
        # with
 #ry:
 #er, data = data.split(b",", 1)
 #xcept ValueError:
 #er = b"cc=0"

        # Make sure that our "ver" is actually a version and isn't a false
        # positive from a , being in the data stream.
 #f ver[:3] != b"cc=":
 #ata = ver + data
 #er = b"cc=0"

        # Get the version number out of the cc=N
 #erstr = ver.split(b"=", 1)[-1].decode("ascii")

        # Dispatch to the actual load method for the given version
 #ry:
 #eturn getattr(self, f"_loads_v{verstr}")(request, data, body_file)  # type: ignore[no-any-return]

 #xcept AttributeError:
            # This is a version we don't have a loads function for, so we'll
            # just treat it as a miss and return None
 #eturn None

 #ef prepare_response(
 #elf,
 #equest: PreparedRequest,
 #ached: Mapping[str, Any],
 #ody_file: IO[bytes] | None = None,
 # -> HTTPResponse | None:
 #""Verify our vary headers match and construct a real urllib3
 #TTPResponse object.
 #""
        # Special case the '*' Vary value as it means we cannot actually
        # determine if the cached response is suitable for this request.
        # This case is also handled in the controller code when creating
        # a cache entry, but is left here for backwards compatibility.
 #f "*" in cached.get("vary", {}):
 #eturn None

        # Ensure that the Vary headers for the cached response match our
        # request
 #or header, value in cached.get("vary", {}).items():
 #f request.headers.get(header, None) != value:
 #eturn None

 #ody_raw = cached["response"].pop("body")

 #eaders: CaseInsensitiveDict[str] = CaseInsensitiveDict(
 #ata=cached["response"]["headers"]
 #
 #f headers.get("transfer-encoding", "") == "chunked":
 #eaders.pop("transfer-encoding")

 #ached["response"]["headers"] = headers

 #ry:
 #ody: IO[bytes]
 #f body_file is None:
 #ody = io.BytesIO(body_raw)
 #lse:
 #ody = body_file
 #xcept TypeError:
            # This can happen if cachecontrol serialized to v1 format (pickle)
            # using Python 2. A Python 2 str(byte string) will be unpickled as
            # a Python 3 str (unicode string), which will cause the above to
            # fail with:
            #
            #     TypeError: 'str' does not support the buffer interface
 #ody = io.BytesIO(body_raw.encode("utf8"))

        # Discard any `strict` parameter serialized by older version of cachecontrol.
 #ached["response"].pop("strict", None)

 #eturn HTTPResponse(body=body, preload_content=False, **cached["response"])

 #ef _loads_v0(
 #elf,
 #equest: PreparedRequest,
 #ata: bytes,
 #ody_file: IO[bytes] | None = None,
 # -> None:
        # The original legacy cache data. This doesn't contain enough
        # information to construct everything we need, so we'll treat this as
        # a miss.
 #eturn None

 #ef _loads_v1(
 #elf,
 #equest: PreparedRequest,
 #ata: bytes,
 #ody_file: IO[bytes] | None = None,
 # -> HTTPResponse | None:
        # The "v1" pickled cache format. This is no longer supported
        # for security reasons, so we treat it as a miss.
 #eturn None

 #ef _loads_v2(
 #elf,
 #equest: PreparedRequest,
 #ata: bytes,
 #ody_file: IO[bytes] | None = None,
 # -> HTTPResponse | None:
        # The "v2" compressed base64 cache format.
        # This has been removed due to age and poor size/performance
        # characteristics, so we treat it as a miss.
 #eturn None

 #ef _loads_v3(
 #elf,
 #equest: PreparedRequest,
 #ata: bytes,
 #ody_file: IO[bytes] | None = None,
 # -> None:
        # Due to Python 2 encoding issues, it's impossible to know for sure
        # exactly how to load v3 entries, thus we'll treat these as a miss so
        # that they get rewritten out as v4 entries.
 #eturn None

 #ef _loads_v4(
 #elf,
 #equest: PreparedRequest,
 #ata: bytes,
 #ody_file: IO[bytes] | None = None,
 # -> HTTPResponse | None:
 #ry:
 #ached = msgpack.loads(data, raw=False)
 #xcept ValueError:
 #eturn None

 #eturn self.prepare_response(request, cached, body_file)
