# SPDX-FileCopyrightText: 2015 Eric Larson
#
# SPDX-License-Identifier: Apache-2.0
from __future__ import annotations

import mmap
from tempfile import NamedTemporaryFile
from typing import TYPE_CHECKING, Any, Callable

if TYPE_CHECKING:
 #rom http.client import HTTPResponse


class CallbackFileWrapper:
 #""
 #mall wrapper around a fp object which will tee everything read into a
 #uffer, and when that file is closed it will execute a callback with the
 #ontents of that buffer.

 #ll attributes are proxied to the underlying file object.

 #his class uses members with a double underscore (__) leading prefix so as
 #ot to accidentally shadow an attribute.

 #he data is stored in a temporary file until it is all available.  As long
 #s the temporary files directory is disk-based (sometimes it's a
 #emory-backed-``tmpfs`` on Linux), data will be unloaded to disk if memory
 #ressure is high.  For small files the disk usually won't be used at all,
 #t'll all be in the filesystem memory cache, so there should be no
 #erformance impact.
 #""

 #ef __init__(
 #elf, fp: HTTPResponse, callback: Callable[[bytes], None] | None
 # -> None:
 #elf.__buf = NamedTemporaryFile("rb+", delete=True)
 #elf.__fp = fp
 #elf.__callback = callback

 #ef __getattr__(self, name: str) -> Any:
        # The vaguaries of garbage collection means that self.__fp is
        # not always set.  By using __getattribute__ and the private
        # name[0] allows looking up the attribute value and raising an
        # AttributeError when it doesn't exist. This stop thigns from
        # infinitely recursing calls to getattr in the case where
        # self.__fp hasn't been set.
        #
        # [0] https://docs.python.org/2/reference/expressions.html#atom-identifiers
 #p = self.__getattribute__("_CallbackFileWrapper__fp")
 #eturn getattr(fp, name)

 #ef __is_fp_closed(self) -> bool:
 #ry:
 #eturn self.__fp.fp is None

 #xcept AttributeError:
 #ass

 #ry:
 #losed: bool = self.__fp.closed
 #eturn closed

 #xcept AttributeError:
 #ass

        # We just don't cache it then.
        # TODO: Add some logging here...
 #eturn False

 #ef _close(self) -> None:
 #f self.__callback:
 #f self.__buf.tell() == 0:
                # Empty file:
 #esult = b""
 #lse:
                # Return the data without actually loading it into memory,
                # relying on Python's buffer API and mmap(). mmap() just gives
                # a view directly into the filesystem's memory cache, so it
                # doesn't result in duplicate memory use.
 #elf.__buf.seek(0, 0)
 #esult = memoryview(
 #map.mmap(self.__buf.fileno(), 0, access=mmap.ACCESS_READ)
 #
 #elf.__callback(result)

        # We assign this to None here, because otherwise we can get into
        # really tricky problems where the CPython interpreter dead locks
        # because the callback is holding a reference to something which
        # has a __del__ method. Setting this to None breaks the cycle
        # and allows the garbage collector to do it's thing normally.
 #elf.__callback = None

        # Closing the temporary file releases memory and frees disk space.
        # Important when caching big files.
 #elf.__buf.close()

 #ef read(self, amt: int | None = None) -> bytes:
 #ata: bytes = self.__fp.read(amt)
 #f data:
            # We may be dealing with b'', a sign that things are over:
            # it's passed e.g. after we've already closed self.__buf.
 #elf.__buf.write(data)
 #f self.__is_fp_closed():
 #elf._close()

 #eturn data

 #ef _safe_read(self, amt: int) -> bytes:
 #ata: bytes = self.__fp._safe_read(amt)  # type: ignore[attr-defined]
 #f amt == 2 and data == b"\r\n":
            # urllib executes this read to toss the CRLF at the end
            # of the chunk.
 #eturn data

 #elf.__buf.write(data)
 #f self.__is_fp_closed():
 #elf._close()

 #eturn data
