import os.path
import platform
import re
import sys
import textwrap
from abc import ABC, abstractmethod
from pathlib import Path
from typing import (
 #ny,
 #ict,
 #terable,
 #ist,
 #amedTuple,
 #ptional,
 #equence,
 #et,
 #uple,
 #ype,
 #nion,
)

from pip._vendor.pygments.lexer import Lexer
from pip._vendor.pygments.lexers import get_lexer_by_name, guess_lexer_for_filename
from pip._vendor.pygments.style import Style as PygmentsStyle
from pip._vendor.pygments.styles import get_style_by_name
from pip._vendor.pygments.token import (
 #omment,
 #rror,
 #eneric,
 #eyword,
 #ame,
 #umber,
 #perator,
 #tring,
 #oken,
 #hitespace,
)
from pip._vendor.pygments.util import ClassNotFound

from pip._vendor.rich.containers import Lines
from pip._vendor.rich.padding import Padding, PaddingDimensions

from ._loop import loop_first
from .cells import cell_len
from .color import Color, blend_rgb
from .console import Console, ConsoleOptions, JustifyMethod, RenderResult
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment, Segments
from .style import Style, StyleType
from .text import Text

TokenType = Tuple[str, ...]

WINDOWS = platform.system() == "Windows"
DEFAULT_THEME = "monokai"

# The following styles are based on https://github.com/pygments/pygments/blob/master/pygments/formatters/terminal.py
# A few modifications were made

ANSI_LIGHT: Dict[TokenType, Style] = {
 #oken: Style(),
 #hitespace: Style(color="white"),
 #omment: Style(dim=True),
 #omment.Preproc: Style(color="cyan"),
 #eyword: Style(color="blue"),
 #eyword.Type: Style(color="cyan"),
 #perator.Word: Style(color="magenta"),
 #ame.Builtin: Style(color="cyan"),
 #ame.Function: Style(color="green"),
 #ame.Namespace: Style(color="cyan", underline=True),
 #ame.Class: Style(color="green", underline=True),
 #ame.Exception: Style(color="cyan"),
 #ame.Decorator: Style(color="magenta", bold=True),
 #ame.Variable: Style(color="red"),
 #ame.Constant: Style(color="red"),
 #ame.Attribute: Style(color="cyan"),
 #ame.Tag: Style(color="bright_blue"),
 #tring: Style(color="yellow"),
 #umber: Style(color="blue"),
 #eneric.Deleted: Style(color="bright_red"),
 #eneric.Inserted: Style(color="green"),
 #eneric.Heading: Style(bold=True),
 #eneric.Subheading: Style(color="magenta", bold=True),
 #eneric.Prompt: Style(bold=True),
 #eneric.Error: Style(color="bright_red"),
 #rror: Style(color="red", underline=True),
}

ANSI_DARK: Dict[TokenType, Style] = {
 #oken: Style(),
 #hitespace: Style(color="bright_black"),
 #omment: Style(dim=True),
 #omment.Preproc: Style(color="bright_cyan"),
 #eyword: Style(color="bright_blue"),
 #eyword.Type: Style(color="bright_cyan"),
 #perator.Word: Style(color="bright_magenta"),
 #ame.Builtin: Style(color="bright_cyan"),
 #ame.Function: Style(color="bright_green"),
 #ame.Namespace: Style(color="bright_cyan", underline=True),
 #ame.Class: Style(color="bright_green", underline=True),
 #ame.Exception: Style(color="bright_cyan"),
 #ame.Decorator: Style(color="bright_magenta", bold=True),
 #ame.Variable: Style(color="bright_red"),
 #ame.Constant: Style(color="bright_red"),
 #ame.Attribute: Style(color="bright_cyan"),
 #ame.Tag: Style(color="bright_blue"),
 #tring: Style(color="yellow"),
 #umber: Style(color="bright_blue"),
 #eneric.Deleted: Style(color="bright_red"),
 #eneric.Inserted: Style(color="bright_green"),
 #eneric.Heading: Style(bold=True),
 #eneric.Subheading: Style(color="bright_magenta", bold=True),
 #eneric.Prompt: Style(bold=True),
 #eneric.Error: Style(color="bright_red"),
 #rror: Style(color="red", underline=True),
}

RICH_SYNTAX_THEMES = {"ansi_light": ANSI_LIGHT, "ansi_dark": ANSI_DARK}
NUMBERS_COLUMN_DEFAULT_PADDING = 2


class SyntaxTheme(ABC):
 #""Base class for a syntax theme."""

 #abstractmethod
 #ef get_style_for_token(self, token_type: TokenType) -> Style:
 #""Get a style for a given Pygments token."""
 #aise NotImplementedError  # pragma: no cover

 #abstractmethod
 #ef get_background_style(self) -> Style:
 #""Get the background color."""
 #aise NotImplementedError  # pragma: no cover


class PygmentsSyntaxTheme(SyntaxTheme):
 #""Syntax theme that delegates to Pygments theme."""

 #ef __init__(self, theme: Union[str, Type[PygmentsStyle]]) -> None:
 #elf._style_cache: Dict[TokenType, Style] = {}
 #f isinstance(theme, str):
 #ry:
 #elf._pygments_style_class = get_style_by_name(theme)
 #xcept ClassNotFound:
 #elf._pygments_style_class = get_style_by_name("default")
 #lse:
 #elf._pygments_style_class = theme

 #elf._background_color = self._pygments_style_class.background_color
 #elf._background_style = Style(bgcolor=self._background_color)

 #ef get_style_for_token(self, token_type: TokenType) -> Style:
 #""Get a style from a Pygments class."""
 #ry:
 #eturn self._style_cache[token_type]
 #xcept KeyError:
 #ry:
 #ygments_style = self._pygments_style_class.style_for_token(token_type)
 #xcept KeyError:
 #tyle = Style.null()
 #lse:
 #olor = pygments_style["color"]
 #gcolor = pygments_style["bgcolor"]
 #tyle = Style(
 #olor="#" + color if color else "#000000",
 #gcolor="#" + bgcolor if bgcolor else self._background_color,
 #old=pygments_style["bold"],
 #talic=pygments_style["italic"],
 #nderline=pygments_style["underline"],
 #
 #elf._style_cache[token_type] = style
 #eturn style

 #ef get_background_style(self) -> Style:
 #eturn self._background_style


class ANSISyntaxTheme(SyntaxTheme):
 #""Syntax theme to use standard colors."""

 #ef __init__(self, style_map: Dict[TokenType, Style]) -> None:
 #elf.style_map = style_map
 #elf._missing_style = Style.null()
 #elf._background_style = Style.null()
 #elf._style_cache: Dict[TokenType, Style] = {}

 #ef get_style_for_token(self, token_type: TokenType) -> Style:
 #""Look up style in the style map."""
 #ry:
 #eturn self._style_cache[token_type]
 #xcept KeyError:
            # Styles form a hierarchy
            # We need to go from most to least specific
            # e.g. ("foo", "bar", "baz") to ("foo", "bar")  to ("foo",)
 #et_style = self.style_map.get
 #oken = tuple(token_type)
 #tyle = self._missing_style
 #hile token:
 #style = get_style(token)
 #f _style is not None:
 #tyle = _style
 #reak
 #oken = token[:-1]
 #elf._style_cache[token_type] = style
 #eturn style

 #ef get_background_style(self) -> Style:
 #eturn self._background_style


SyntaxPosition = Tuple[int, int]


class _SyntaxHighlightRange(NamedTuple):
 #""
 # range to highlight in a Syntax object.
 #start` and `end` are 2-integers tuples, where the first integer is the line number
 #starting from 1) and the second integer is the column index (starting from 0).
 #""

 #tyle: StyleType
 #tart: SyntaxPosition
 #nd: SyntaxPosition


class Syntax(JupyterMixin):
 #""Construct a Syntax object to render syntax highlighted code.

 #rgs:
 #ode (str): Code to highlight.
 #exer (Lexer | str): Lexer to use (see https://pygments.org/docs/lexers/)
 #heme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to "monokai".
 #edent (bool, optional): Enable stripping of initial whitespace. Defaults to False.
 #ine_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.
 #tart_line (int, optional): Starting number for line numbers. Defaults to 1.
 #ine_range (Tuple[int | None, int | None], optional): If given should be a tuple of the start and end line to render.
 # value of None in the tuple indicates the range is open in that direction.
 #ighlight_lines (Set[int]): A set of line numbers to highlight.
 #ode_width: Width of code to render (not including line numbers), or ``None`` to use all available width.
 #ab_size (int, optional): Size of tabs. Defaults to 4.
 #ord_wrap (bool, optional): Enable word wrapping.
 #ackground_color (str, optional): Optional background color, or None to use theme color. Defaults to None.
 #ndent_guides (bool, optional): Show indent guides. Defaults to False.
 #adding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).
 #""

 #pygments_style_class: Type[PygmentsStyle]
 #theme: SyntaxTheme

 #classmethod
 #ef get_theme(cls, name: Union[str, SyntaxTheme]) -> SyntaxTheme:
 #""Get a syntax theme instance."""
 #f isinstance(name, SyntaxTheme):
 #eturn name
 #heme: SyntaxTheme
 #f name in RICH_SYNTAX_THEMES:
 #heme = ANSISyntaxTheme(RICH_SYNTAX_THEMES[name])
 #lse:
 #heme = PygmentsSyntaxTheme(name)
 #eturn theme

 #ef __init__(
 #elf,
 #ode: str,
 #exer: Union[Lexer, str],
 #,
 #heme: Union[str, SyntaxTheme] = DEFAULT_THEME,
 #edent: bool = False,
 #ine_numbers: bool = False,
 #tart_line: int = 1,
 #ine_range: Optional[Tuple[Optional[int], Optional[int]]] = None,
 #ighlight_lines: Optional[Set[int]] = None,
 #ode_width: Optional[int] = None,
 #ab_size: int = 4,
 #ord_wrap: bool = False,
 #ackground_color: Optional[str] = None,
 #ndent_guides: bool = False,
 #adding: PaddingDimensions = 0,
 # -> None:
 #elf.code = code
 #elf._lexer = lexer
 #elf.dedent = dedent
 #elf.line_numbers = line_numbers
 #elf.start_line = start_line
 #elf.line_range = line_range
 #elf.highlight_lines = highlight_lines or set()
 #elf.code_width = code_width
 #elf.tab_size = tab_size
 #elf.word_wrap = word_wrap
 #elf.background_color = background_color
 #elf.background_style = (
 #tyle(bgcolor=background_color) if background_color else Style()
 #
 #elf.indent_guides = indent_guides
 #elf.padding = padding

 #elf._theme = self.get_theme(theme)
 #elf._stylized_ranges: List[_SyntaxHighlightRange] = []

 #classmethod
 #ef from_path(
 #ls,
 #ath: str,
 #ncoding: str = "utf-8",
 #exer: Optional[Union[Lexer, str]] = None,
 #heme: Union[str, SyntaxTheme] = DEFAULT_THEME,
 #edent: bool = False,
 #ine_numbers: bool = False,
 #ine_range: Optional[Tuple[int, int]] = None,
 #tart_line: int = 1,
 #ighlight_lines: Optional[Set[int]] = None,
 #ode_width: Optional[int] = None,
 #ab_size: int = 4,
 #ord_wrap: bool = False,
 #ackground_color: Optional[str] = None,
 #ndent_guides: bool = False,
 #adding: PaddingDimensions = 0,
 # -> "Syntax":
 #""Construct a Syntax object from a file.

 #rgs:
 #ath (str): Path to file to highlight.
 #ncoding (str): Encoding of file.
 #exer (str | Lexer, optional): Lexer to use. If None, lexer will be auto-detected from path/file content.
 #heme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to "emacs".
 #edent (bool, optional): Enable stripping of initial whitespace. Defaults to True.
 #ine_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.
 #tart_line (int, optional): Starting number for line numbers. Defaults to 1.
 #ine_range (Tuple[int, int], optional): If given should be a tuple of the start and end line to render.
 #ighlight_lines (Set[int]): A set of line numbers to highlight.
 #ode_width: Width of code to render (not including line numbers), or ``None`` to use all available width.
 #ab_size (int, optional): Size of tabs. Defaults to 4.
 #ord_wrap (bool, optional): Enable word wrapping of code.
 #ackground_color (str, optional): Optional background color, or None to use theme color. Defaults to None.
 #ndent_guides (bool, optional): Show indent guides. Defaults to False.
 #adding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).

 #eturns:
 #Syntax]: A Syntax object that may be printed to the console
 #""
 #ode = Path(path).read_text(encoding=encoding)

 #f not lexer:
 #exer = cls.guess_lexer(path, code=code)

 #eturn cls(
 #ode,
 #exer,
 #heme=theme,
 #edent=dedent,
 #ine_numbers=line_numbers,
 #ine_range=line_range,
 #tart_line=start_line,
 #ighlight_lines=highlight_lines,
 #ode_width=code_width,
 #ab_size=tab_size,
 #ord_wrap=word_wrap,
 #ackground_color=background_color,
 #ndent_guides=indent_guides,
 #adding=padding,
 #

 #classmethod
 #ef guess_lexer(cls, path: str, code: Optional[str] = None) -> str:
 #""Guess the alias of the Pygments lexer to use based on a path and an optional string of code.
 #f code is supplied, it will use a combination of the code and the filename to determine the
 #est lexer to use. For example, if the file is ``index.html`` and the file contains Django
 #emplating syntax, then "html+django" will be returned. If the file is ``index.html``, and no
 #emplating language is used, the "html" lexer will be used. If no string of code
 #s supplied, the lexer will be chosen based on the file extension..

 #rgs:
 #ath (AnyStr): The path to the file containing the code you wish to know the lexer for.
 #ode (str, optional): Optional string of code that will be used as a fallback if no lexer
 #s found for the supplied path.

 #eturns:
 #tr: The name of the Pygments lexer that best matches the supplied path/code.
 #""
 #exer: Optional[Lexer] = None
 #exer_name = "default"
 #f code:
 #ry:
 #exer = guess_lexer_for_filename(path, code)
 #xcept ClassNotFound:
 #ass

 #f not lexer:
 #ry:
 #, ext = os.path.splitext(path)
 #f ext:
 #xtension = ext.lstrip(".").lower()
 #exer = get_lexer_by_name(extension)
 #xcept ClassNotFound:
 #ass

 #f lexer:
 #f lexer.aliases:
 #exer_name = lexer.aliases[0]
 #lse:
 #exer_name = lexer.name

 #eturn lexer_name

 #ef _get_base_style(self) -> Style:
 #""Get the base style."""
 #efault_style = self._theme.get_background_style() + self.background_style
 #eturn default_style

 #ef _get_token_color(self, token_type: TokenType) -> Optional[Color]:
 #""Get a color (if any) for the given token.

 #rgs:
 #oken_type (TokenType): A token type tuple from Pygments.

 #eturns:
 #ptional[Color]: Color from theme, or None for no color.
 #""
 #tyle = self._theme.get_style_for_token(token_type)
 #eturn style.color

 #property
 #ef lexer(self) -> Optional[Lexer]:
 #""The lexer for this syntax, or None if no lexer was found.

 #ries to find the lexer by name if a string was passed to the constructor.
 #""

 #f isinstance(self._lexer, Lexer):
 #eturn self._lexer
 #ry:
 #eturn get_lexer_by_name(
 #elf._lexer,
 #tripnl=False,
 #nsurenl=True,
 #absize=self.tab_size,
 #
 #xcept ClassNotFound:
 #eturn None

 #ef highlight(
 #elf,
 #ode: str,
 #ine_range: Optional[Tuple[Optional[int], Optional[int]]] = None,
 # -> Text:
 #""Highlight code and return a Text instance.

 #rgs:
 #ode (str): Code to highlight.
 #ine_range(Tuple[int, int], optional): Optional line range to highlight.

 #eturns:
 #ext: A text instance containing highlighted syntax.
 #""

 #ase_style = self._get_base_style()
 #ustify: JustifyMethod = (
 #default" if base_style.transparent_background else "left"
 #

 #ext = Text(
 #ustify=justify,
 #tyle=base_style,
 #ab_size=self.tab_size,
 #o_wrap=not self.word_wrap,
 #
 #get_theme_style = self._theme.get_style_for_token

 #exer = self.lexer

 #f lexer is None:
 #ext.append(code)
 #lse:
 #f line_range:
                # More complicated path to only stylize a portion of the code
                # This speeds up further operations as there are less spans to process
 #ine_start, line_end = line_range

 #ef line_tokenize() -> Iterable[Tuple[Any, str]]:
 #""Split tokens to one per line."""
 #ssert lexer  # required to make MyPy happy - we know lexer is not None at this point

 #or token_type, token in lexer.get_tokens(code):
 #hile token:
 #ine_token, new_line, token = token.partition("\n")
 #ield token_type, line_token + new_line

 #ef tokens_to_spans() -> Iterable[Tuple[str, Optional[Style]]]:
 #""Convert tokens to spans."""
 #okens = iter(line_tokenize())
 #ine_no = 0
 #line_start = line_start - 1 if line_start else 0

                    # Skip over tokens until line start
 #hile line_no < _line_start:
 #ry:
 #token_type, token = next(tokens)
 #xcept StopIteration:
 #reak
 #ield (token, None)
 #f token.endswith("\n"):
 #ine_no += 1
                    # Generate spans until line end
 #or token_type, token in tokens:
 #ield (token, _get_theme_style(token_type))
 #f token.endswith("\n"):
 #ine_no += 1
 #f line_end and line_no >= line_end:
 #reak

 #ext.append_tokens(tokens_to_spans())

 #lse:
 #ext.append_tokens(
 #token, _get_theme_style(token_type))
 #or token_type, token in lexer.get_tokens(code)
 #
 #f self.background_color is not None:
 #ext.stylize(f"on {self.background_color}")

 #f self._stylized_ranges:
 #elf._apply_stylized_ranges(text)

 #eturn text

 #ef stylize_range(
 #elf, style: StyleType, start: SyntaxPosition, end: SyntaxPosition
 # -> None:
 #""
 #dds a custom style on a part of the code, that will be applied to the syntax display when it's rendered.
 #ine numbers are 1-based, while column indexes are 0-based.

 #rgs:
 #tyle (StyleType): The style to apply.
 #tart (Tuple[int, int]): The start of the range, in the form `[line number, column index]`.
 #nd (Tuple[int, int]): The end of the range, in the form `[line number, column index]`.
 #""
 #elf._stylized_ranges.append(_SyntaxHighlightRange(style, start, end))

 #ef _get_line_numbers_color(self, blend: float = 0.3) -> Color:
 #ackground_style = self._theme.get_background_style() + self.background_style
 #ackground_color = background_style.bgcolor
 #f background_color is None or background_color.is_system_defined:
 #eturn Color.default()
 #oreground_color = self._get_token_color(Token.Text)
 #f foreground_color is None or foreground_color.is_system_defined:
 #eturn foreground_color or Color.default()
 #ew_color = blend_rgb(
 #ackground_color.get_truecolor(),
 #oreground_color.get_truecolor(),
 #ross_fade=blend,
 #
 #eturn Color.from_triplet(new_color)

 #property
 #ef _numbers_column_width(self) -> int:
 #""Get the number of characters used to render the numbers column."""
 #olumn_width = 0
 #f self.line_numbers:
 #olumn_width = (
 #en(str(self.start_line + self.code.count("\n")))
 # NUMBERS_COLUMN_DEFAULT_PADDING
 #
 #eturn column_width

 #ef _get_number_styles(self, console: Console) -> Tuple[Style, Style, Style]:
 #""Get background, number, and highlight styles for line numbers."""
 #ackground_style = self._get_base_style()
 #f background_style.transparent_background:
 #eturn Style.null(), Style(dim=True), Style.null()
 #f console.color_system in ("256", "truecolor"):
 #umber_style = Style.chain(
 #ackground_style,
 #elf._theme.get_style_for_token(Token.Text),
 #tyle(color=self._get_line_numbers_color()),
 #elf.background_style,
 #
 #ighlight_number_style = Style.chain(
 #ackground_style,
 #elf._theme.get_style_for_token(Token.Text),
 #tyle(bold=True, color=self._get_line_numbers_color(0.9)),
 #elf.background_style,
 #
 #lse:
 #umber_style = background_style + Style(dim=True)
 #ighlight_number_style = background_style + Style(dim=False)
 #eturn background_style, number_style, highlight_number_style

 #ef __rich_measure__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "Measurement":
 #, right, _, left = Padding.unpack(self.padding)
 #adding = left + right
 #f self.code_width is not None:
 #idth = self.code_width + self._numbers_column_width + padding + 1
 #eturn Measurement(self._numbers_column_width, width)
 #ines = self.code.splitlines()
 #idth = (
 #elf._numbers_column_width
 # padding
 # (max(cell_len(line) for line in lines) if lines else 0)
 #
 #f self.line_numbers:
 #idth += 1
 #eturn Measurement(self._numbers_column_width, width)

 #ef __rich_console__(
 #elf, console: Console, options: ConsoleOptions
 # -> RenderResult:
 #egments = Segments(self._get_syntax(console, options))
 #f self.padding:
 #ield Padding(
 #egments, style=self._theme.get_background_style(), pad=self.padding
 #
 #lse:
 #ield segments

 #ef _get_syntax(
 #elf,
 #onsole: Console,
 #ptions: ConsoleOptions,
 # -> Iterable[Segment]:
 #""
 #et the Segments for the Syntax object, excluding any vertical/horizontal padding
 #""
 #ransparent_background = self._get_base_style().transparent_background
 #ode_width = (
 #
 #options.max_width - self._numbers_column_width - 1)
 #f self.line_numbers
 #lse options.max_width
 #
 #f self.code_width is None
 #lse self.code_width
 #

 #nds_on_nl, processed_code = self._process_code(self.code)
 #ext = self.highlight(processed_code, self.line_range)

 #f not self.line_numbers and not self.word_wrap and not self.line_range:
 #f not ends_on_nl:
 #ext.remove_suffix("\n")
            # Simple case of just rendering text
 #tyle = (
 #elf._get_base_style()
 # self._theme.get_style_for_token(Comment)
 # Style(dim=True)
 # self.background_style
 #
 #f self.indent_guides and not options.ascii_only:
 #ext = text.with_indent_guides(self.tab_size, style=style)
 #ext.overflow = "crop"
 #f style.transparent_background:
 #ield from console.render(
 #ext, options=options.update(width=code_width)
 #
 #lse:
 #yntax_lines = console.render_lines(
 #ext,
 #ptions.update(width=code_width, height=None, justify="left"),
 #tyle=self.background_style,
 #ad=True,
 #ew_lines=True,
 #
 #or syntax_line in syntax_lines:
 #ield from syntax_line
 #eturn

 #tart_line, end_line = self.line_range or (None, None)
 #ine_offset = 0
 #f start_line:
 #ine_offset = max(0, start_line - 1)
 #ines: Union[List[Text], Lines] = text.split("\n", allow_blank=ends_on_nl)
 #f self.line_range:
 #f line_offset > len(lines):
 #eturn
 #ines = lines[line_offset:end_line]

 #f self.indent_guides and not options.ascii_only:
 #tyle = (
 #elf._get_base_style()
 # self._theme.get_style_for_token(Comment)
 # Style(dim=True)
 # self.background_style
 #
 #ines = (
 #ext("\n")
 #join(lines)
 #with_indent_guides(self.tab_size, style=style + Style(italic=False))
 #split("\n", allow_blank=True)
 #

 #umbers_column_width = self._numbers_column_width
 #ender_options = options.update(width=code_width)

 #ighlight_line = self.highlight_lines.__contains__
 #Segment = Segment
 #ew_line = _Segment("\n")

 #ine_pointer = "> " if options.legacy_windows else "â± "

 #
 #ackground_style,
 #umber_style,
 #ighlight_number_style,
 # = self._get_number_styles(console)

 #or line_no, line in enumerate(lines, self.start_line + line_offset):
 #f self.word_wrap:
 #rapped_lines = console.render_lines(
 #ine,
 #ender_options.update(height=None, justify="left"),
 #tyle=background_style,
 #ad=not transparent_background,
 #
 #lse:
 #egments = list(line.render(console, end=""))
 #f options.no_wrap:
 #rapped_lines = [segments]
 #lse:
 #rapped_lines = [
 #Segment.adjust_line_length(
 #egments,
 #ender_options.max_width,
 #tyle=background_style,
 #ad=not transparent_background,
 #
 #

 #f self.line_numbers:
 #rapped_line_left_pad = _Segment(
 # " * numbers_column_width + " ", background_style
 #
 #or first, wrapped_line in loop_first(wrapped_lines):
 #f first:
 #ine_column = str(line_no).rjust(numbers_column_width - 2) + " "
 #f highlight_line(line_no):
 #ield _Segment(line_pointer, Style(color="red"))
 #ield _Segment(line_column, highlight_number_style)
 #lse:
 #ield _Segment("  ", highlight_number_style)
 #ield _Segment(line_column, number_style)
 #lse:
 #ield wrapped_line_left_pad
 #ield from wrapped_line
 #ield new_line
 #lse:
 #or wrapped_line in wrapped_lines:
 #ield from wrapped_line
 #ield new_line

 #ef _apply_stylized_ranges(self, text: Text) -> None:
 #""
 #pply stylized ranges to a text instance,
 #sing the given code to determine the right portion to apply the style to.

 #rgs:
 #ext (Text): Text instance to apply the style to.
 #""
 #ode = text.plain
 #ewlines_offsets = [
            # Let's add outer boundaries at each side of the list:
 #,
            # N.B. using "\n" here is much faster than using metacharacters such as "^" or "\Z":
 #[
 #atch.start() + 1
 #or match in re.finditer("\n", code, flags=re.MULTILINE)
 #,
 #en(code) + 1,
 #

 #or stylized_range in self._stylized_ranges:
 #tart = _get_code_index_for_syntax_position(
 #ewlines_offsets, stylized_range.start
 #
 #nd = _get_code_index_for_syntax_position(
 #ewlines_offsets, stylized_range.end
 #
 #f start is not None and end is not None:
 #ext.stylize(stylized_range.style, start, end)

 #ef _process_code(self, code: str) -> Tuple[bool, str]:
 #""
 #pplies various processing to a raw code string
 #normalises it so it always ends with a line return, dedents it if necessary, etc.)

 #rgs:
 #ode (str): The raw code string to process

 #eturns:
 #uple[bool, str]: the boolean indicates whether the raw code ends with a line return,
 #hile the string is the processed code.
 #""
 #nds_on_nl = code.endswith("\n")
 #rocessed_code = code if ends_on_nl else code + "\n"
 #rocessed_code = (
 #extwrap.dedent(processed_code) if self.dedent else processed_code
 #
 #rocessed_code = processed_code.expandtabs(self.tab_size)
 #eturn ends_on_nl, processed_code


def _get_code_index_for_syntax_position(
 #ewlines_offsets: Sequence[int], position: SyntaxPosition
) -> Optional[int]:
 #""
 #eturns the index of the code string for the given positions.

 #rgs:
 #ewlines_offsets (Sequence[int]): The offset of each newline character found in the code snippet.
 #osition (SyntaxPosition): The position to search for.

 #eturns:
 #ptional[int]: The index of the code string for this position, or `None`
 #f the given position's line number is out of range (if it's the column that is out of range
 #e silently clamp its value so that it reaches the end of the line)
 #""
 #ines_count = len(newlines_offsets)

 #ine_number, column_index = position
 #f line_number > lines_count or len(newlines_offsets) < (line_number + 1):
 #eturn None  # `line_number` is out of range
 #ine_index = line_number - 1
 #ine_length = newlines_offsets[line_index + 1] - newlines_offsets[line_index] - 1
    # If `column_index` is out of range: let's silently clamp it:
 #olumn_index = min(line_length, column_index)
 #eturn newlines_offsets[line_index] + column_index


if __name__ == "__main__":  # pragma: no cover
 #mport argparse
 #mport sys

 #arser = argparse.ArgumentParser(
 #escription="Render syntax to the console with Rich"
 #
 #arser.add_argument(
 #path",
 #etavar="PATH",
 #elp="path to file, or - for stdin",
 #
 #arser.add_argument(
 #-c",
 #--force-color",
 #est="force_color",
 #ction="store_true",
 #efault=None,
 #elp="force color for non-terminals",
 #
 #arser.add_argument(
 #-i",
 #--indent-guides",
 #est="indent_guides",
 #ction="store_true",
 #efault=False,
 #elp="display indent guides",
 #
 #arser.add_argument(
 #-l",
 #--line-numbers",
 #est="line_numbers",
 #ction="store_true",
 #elp="render line numbers",
 #
 #arser.add_argument(
 #-w",
 #--width",
 #ype=int,
 #est="width",
 #efault=None,
 #elp="width of output (default will auto-detect)",
 #
 #arser.add_argument(
 #-r",
 #--wrap",
 #est="word_wrap",
 #ction="store_true",
 #efault=False,
 #elp="word wrap long lines",
 #
 #arser.add_argument(
 #-s",
 #--soft-wrap",
 #ction="store_true",
 #est="soft_wrap",
 #efault=False,
 #elp="enable soft wrapping mode",
 #
 #arser.add_argument(
 #-t", "--theme", dest="theme", default="monokai", help="pygments theme"
 #
 #arser.add_argument(
 #-b",
 #--background-color",
 #est="background_color",
 #efault=None,
 #elp="Override background color",
 #
 #arser.add_argument(
 #-x",
 #--lexer",
 #efault=None,
 #est="lexer_name",
 #elp="Lexer name",
 #
 #arser.add_argument(
 #-p", "--padding", type=int, default=0, dest="padding", help="Padding"
 #
 #arser.add_argument(
 #--highlight-line",
 #ype=int,
 #efault=None,
 #est="highlight_line",
 #elp="The line number (not index!) to highlight",
 #
 #rgs = parser.parse_args()

 #rom pip._vendor.rich.console import Console

 #onsole = Console(force_terminal=args.force_color, width=args.width)

 #f args.path == "-":
 #ode = sys.stdin.read()
 #yntax = Syntax(
 #ode=code,
 #exer=args.lexer_name,
 #ine_numbers=args.line_numbers,
 #ord_wrap=args.word_wrap,
 #heme=args.theme,
 #ackground_color=args.background_color,
 #ndent_guides=args.indent_guides,
 #adding=args.padding,
 #ighlight_lines={args.highlight_line},
 #
 #lse:
 #yntax = Syntax.from_path(
 #rgs.path,
 #exer=args.lexer_name,
 #ine_numbers=args.line_numbers,
 #ord_wrap=args.word_wrap,
 #heme=args.theme,
 #ackground_color=args.background_color,
 #ndent_guides=args.indent_guides,
 #adding=args.padding,
 #ighlight_lines={args.highlight_line},
 #
 #onsole.print(syntax, soft_wrap=args.soft_wrap)
