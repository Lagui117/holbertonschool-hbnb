from operator import itemgetter
from typing import TYPE_CHECKING, Callable, NamedTuple, Optional, Sequence

from . import errors
from .protocol import is_renderable, rich_cast

if TYPE_CHECKING:
 #rom .console import Console, ConsoleOptions, RenderableType


class Measurement(NamedTuple):
 #""Stores the minimum and maximum widths (in characters) required to render an object."""

 #inimum: int
 #""Minimum number of cells required to render."""
 #aximum: int
 #""Maximum number of cells required to render."""

 #property
 #ef span(self) -> int:
 #""Get difference between maximum and minimum."""
 #eturn self.maximum - self.minimum

 #ef normalize(self) -> "Measurement":
 #""Get measurement that ensures that minimum <= maximum and minimum >= 0

 #eturns:
 #easurement: A normalized measurement.
 #""
 #inimum, maximum = self
 #inimum = min(max(0, minimum), maximum)
 #eturn Measurement(max(0, minimum), max(0, max(minimum, maximum)))

 #ef with_maximum(self, width: int) -> "Measurement":
 #""Get a RenderableWith where the widths are <= width.

 #rgs:
 #idth (int): Maximum desired width.

 #eturns:
 #easurement: New Measurement object.
 #""
 #inimum, maximum = self
 #eturn Measurement(min(minimum, width), min(maximum, width))

 #ef with_minimum(self, width: int) -> "Measurement":
 #""Get a RenderableWith where the widths are >= width.

 #rgs:
 #idth (int): Minimum desired width.

 #eturns:
 #easurement: New Measurement object.
 #""
 #inimum, maximum = self
 #idth = max(0, width)
 #eturn Measurement(max(minimum, width), max(maximum, width))

 #ef clamp(
 #elf, min_width: Optional[int] = None, max_width: Optional[int] = None
 # -> "Measurement":
 #""Clamp a measurement within the specified range.

 #rgs:
 #in_width (int): Minimum desired width, or ``None`` for no minimum. Defaults to None.
 #ax_width (int): Maximum desired width, or ``None`` for no maximum. Defaults to None.

 #eturns:
 #easurement: New Measurement object.
 #""
 #easurement = self
 #f min_width is not None:
 #easurement = measurement.with_minimum(min_width)
 #f max_width is not None:
 #easurement = measurement.with_maximum(max_width)
 #eturn measurement

 #classmethod
 #ef get(
 #ls, console: "Console", options: "ConsoleOptions", renderable: "RenderableType"
 # -> "Measurement":
 #""Get a measurement for a renderable.

 #rgs:
 #onsole (~rich.console.Console): Console instance.
 #ptions (~rich.console.ConsoleOptions): Console options.
 #enderable (RenderableType): An object that may be rendered with Rich.

 #aises:
 #rrors.NotRenderableError: If the object is not renderable.

 #eturns:
 #easurement: Measurement object containing range of character widths required to render the object.
 #""
 #max_width = options.max_width
 #f _max_width < 1:
 #eturn Measurement(0, 0)
 #f isinstance(renderable, str):
 #enderable = console.render_str(
 #enderable, markup=options.markup, highlight=False
 #
 #enderable = rich_cast(renderable)
 #f is_renderable(renderable):
 #et_console_width: Optional[
 #allable[["Console", "ConsoleOptions"], "Measurement"]
 # = getattr(renderable, "__rich_measure__", None)
 #f get_console_width is not None:
 #ender_width = (
 #et_console_width(console, options)
 #normalize()
 #with_maximum(_max_width)
 #
 #f render_width.maximum < 1:
 #eturn Measurement(0, 0)
 #eturn render_width.normalize()
 #lse:
 #eturn Measurement(0, _max_width)
 #lse:
 #aise errors.NotRenderableError(
 #"Unable to get render width for {renderable!r}; "
 #a str, Segment, or object with __rich_console__ method is required"
 #


def measure_renderables(
 #onsole: "Console",
 #ptions: "ConsoleOptions",
 #enderables: Sequence["RenderableType"],
) -> "Measurement":
 #""Get a measurement that would fit a number of renderables.

 #rgs:
 #onsole (~rich.console.Console): Console instance.
 #ptions (~rich.console.ConsoleOptions): Console options.
 #enderables (Iterable[RenderableType]): One or more renderable objects.

 #eturns:
 #easurement: Measurement object containing range of character widths required to
 #ontain all given renderables.
 #""
 #f not renderables:
 #eturn Measurement(0, 0)
 #et_measurement = Measurement.get
 #easurements = [
 #et_measurement(console, options, renderable) for renderable in renderables
 #
 #easured_width = Measurement(
 #ax(measurements, key=itemgetter(0)).minimum,
 #ax(measurements, key=itemgetter(1)).maximum,
 #
 #eturn measured_width
