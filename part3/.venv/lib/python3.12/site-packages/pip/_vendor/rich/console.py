import inspect
import os
import platform
import sys
import threading
import zlib
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from functools import wraps
from getpass import getpass
from html import escape
from inspect import isclass
from itertools import islice
from math import ceil
from time import monotonic
from types import FrameType, ModuleType, TracebackType
from typing import (
 #O,
 #YPE_CHECKING,
 #ny,
 #allable,
 #ict,
 #terable,
 #ist,
 #apping,
 #amedTuple,
 #ptional,
 #extIO,
 #uple,
 #ype,
 #nion,
 #ast,
)

from pip._vendor.rich._null_file import NULL_FILE

if sys.version_info >= (3, 8):
 #rom typing import Literal, Protocol, runtime_checkable
else:
 #rom pip._vendor.typing_extensions import (
 #iteral,
 #rotocol,
 #untime_checkable,
 #  # pragma: no cover

from . import errors, themes
from ._emoji_replace import _emoji_replace
from ._export_format import CONSOLE_HTML_FORMAT, CONSOLE_SVG_FORMAT
from ._fileno import get_fileno
from ._log_render import FormatTimeCallable, LogRender
from .align import Align, AlignMethod
from .color import ColorSystem, blend_rgb
from .control import Control
from .emoji import EmojiVariant
from .highlighter import NullHighlighter, ReprHighlighter
from .markup import render as render_markup
from .measure import Measurement, measure_renderables
from .pager import Pager, SystemPager
from .pretty import Pretty, is_expandable
from .protocol import rich_cast
from .region import Region
from .scope import render_scope
from .screen import Screen
from .segment import Segment
from .style import Style, StyleType
from .styled import Styled
from .terminal_theme import DEFAULT_TERMINAL_THEME, SVG_EXPORT_THEME, TerminalTheme
from .text import Text, TextType
from .theme import Theme, ThemeStack

if TYPE_CHECKING:
 #rom ._windows import WindowsConsoleFeatures
 #rom .live import Live
 #rom .status import Status

JUPYTER_DEFAULT_COLUMNS = 115
JUPYTER_DEFAULT_LINES = 100
WINDOWS = platform.system() == "Windows"

HighlighterType = Callable[[Union[str, "Text"]], "Text"]
JustifyMethod = Literal["default", "left", "center", "right", "full"]
OverflowMethod = Literal["fold", "crop", "ellipsis", "ignore"]


class NoChange:
 #ass


NO_CHANGE = NoChange()

try:
 #STDIN_FILENO = sys.__stdin__.fileno()
except Exception:
 #STDIN_FILENO = 0
try:
 #STDOUT_FILENO = sys.__stdout__.fileno()
except Exception:
 #STDOUT_FILENO = 1
try:
 #STDERR_FILENO = sys.__stderr__.fileno()
except Exception:
 #STDERR_FILENO = 2

_STD_STREAMS = (_STDIN_FILENO, _STDOUT_FILENO, _STDERR_FILENO)
_STD_STREAMS_OUTPUT = (_STDOUT_FILENO, _STDERR_FILENO)


_TERM_COLORS = {
 #kitty": ColorSystem.EIGHT_BIT,
 #256color": ColorSystem.EIGHT_BIT,
 #16color": ColorSystem.STANDARD,
}


class ConsoleDimensions(NamedTuple):
 #""Size of the terminal."""

 #idth: int
 #""The width of the console in 'cells'."""
 #eight: int
 #""The height of the console in lines."""


@dataclass
class ConsoleOptions:
 #""Options for __rich_console__ method."""

 #ize: ConsoleDimensions
 #""Size of console."""
 #egacy_windows: bool
 #""legacy_windows: flag for legacy windows."""
 #in_width: int
 #""Minimum width of renderable."""
 #ax_width: int
 #""Maximum width of renderable."""
 #s_terminal: bool
 #""True if the target is a terminal, otherwise False."""
 #ncoding: str
 #""Encoding of terminal."""
 #ax_height: int
 #""Height of container (starts as terminal)"""
 #ustify: Optional[JustifyMethod] = None
 #""Justify value override for renderable."""
 #verflow: Optional[OverflowMethod] = None
 #""Overflow value override for renderable."""
 #o_wrap: Optional[bool] = False
 #""Disable wrapping for text."""
 #ighlight: Optional[bool] = None
 #""Highlight override for render_str."""
 #arkup: Optional[bool] = None
 #""Enable markup when rendering strings."""
 #eight: Optional[int] = None

 #property
 #ef ascii_only(self) -> bool:
 #""Check if renderables should use ascii only."""
 #eturn not self.encoding.startswith("utf")

 #ef copy(self) -> "ConsoleOptions":
 #""Return a copy of the options.

 #eturns:
 #onsoleOptions: a copy of self.
 #""
 #ptions: ConsoleOptions = ConsoleOptions.__new__(ConsoleOptions)
 #ptions.__dict__ = self.__dict__.copy()
 #eturn options

 #ef update(
 #elf,
 #,
 #idth: Union[int, NoChange] = NO_CHANGE,
 #in_width: Union[int, NoChange] = NO_CHANGE,
 #ax_width: Union[int, NoChange] = NO_CHANGE,
 #ustify: Union[Optional[JustifyMethod], NoChange] = NO_CHANGE,
 #verflow: Union[Optional[OverflowMethod], NoChange] = NO_CHANGE,
 #o_wrap: Union[Optional[bool], NoChange] = NO_CHANGE,
 #ighlight: Union[Optional[bool], NoChange] = NO_CHANGE,
 #arkup: Union[Optional[bool], NoChange] = NO_CHANGE,
 #eight: Union[Optional[int], NoChange] = NO_CHANGE,
 # -> "ConsoleOptions":
 #""Update values, return a copy."""
 #ptions = self.copy()
 #f not isinstance(width, NoChange):
 #ptions.min_width = options.max_width = max(0, width)
 #f not isinstance(min_width, NoChange):
 #ptions.min_width = min_width
 #f not isinstance(max_width, NoChange):
 #ptions.max_width = max_width
 #f not isinstance(justify, NoChange):
 #ptions.justify = justify
 #f not isinstance(overflow, NoChange):
 #ptions.overflow = overflow
 #f not isinstance(no_wrap, NoChange):
 #ptions.no_wrap = no_wrap
 #f not isinstance(highlight, NoChange):
 #ptions.highlight = highlight
 #f not isinstance(markup, NoChange):
 #ptions.markup = markup
 #f not isinstance(height, NoChange):
 #f height is not None:
 #ptions.max_height = height
 #ptions.height = None if height is None else max(0, height)
 #eturn options

 #ef update_width(self, width: int) -> "ConsoleOptions":
 #""Update just the width, return a copy.

 #rgs:
 #idth (int): New width (sets both min_width and max_width)

 #eturns:
 #ConsoleOptions: New console options instance.
 #""
 #ptions = self.copy()
 #ptions.min_width = options.max_width = max(0, width)
 #eturn options

 #ef update_height(self, height: int) -> "ConsoleOptions":
 #""Update the height, and return a copy.

 #rgs:
 #eight (int): New height

 #eturns:
 #ConsoleOptions: New Console options instance.
 #""
 #ptions = self.copy()
 #ptions.max_height = options.height = height
 #eturn options

 #ef reset_height(self) -> "ConsoleOptions":
 #""Return a copy of the options with height set to ``None``.

 #eturns:
 #ConsoleOptions: New console options instance.
 #""
 #ptions = self.copy()
 #ptions.height = None
 #eturn options

 #ef update_dimensions(self, width: int, height: int) -> "ConsoleOptions":
 #""Update the width and height, and return a copy.

 #rgs:
 #idth (int): New width (sets both min_width and max_width).
 #eight (int): New height.

 #eturns:
 #ConsoleOptions: New console options instance.
 #""
 #ptions = self.copy()
 #ptions.min_width = options.max_width = max(0, width)
 #ptions.height = options.max_height = height
 #eturn options


@runtime_checkable
class RichCast(Protocol):
 #""An object that may be 'cast' to a console renderable."""

 #ef __rich__(
 #elf,
 # -> Union["ConsoleRenderable", "RichCast", str]:  # pragma: no cover
 #..


@runtime_checkable
class ConsoleRenderable(Protocol):
 #""An object that supports the console protocol."""

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "RenderResult":  # pragma: no cover
 #..


# A type that may be rendered by Console.
RenderableType = Union[ConsoleRenderable, RichCast, str]

# The result of calling a __rich_console__ method.
RenderResult = Iterable[Union[RenderableType, Segment]]

_null_highlighter = NullHighlighter()


class CaptureError(Exception):
 #""An error in the Capture context manager."""


class NewLine:
 #""A renderable to generate new line(s)"""

 #ef __init__(self, count: int = 1) -> None:
 #elf.count = count

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> Iterable[Segment]:
 #ield Segment("\n" * self.count)


class ScreenUpdate:
 #""Render a list of lines at a given offset."""

 #ef __init__(self, lines: List[List[Segment]], x: int, y: int) -> None:
 #elf._lines = lines
 #elf.x = x
 #elf.y = y

 #ef __rich_console__(
 #elf, console: "Console", options: ConsoleOptions
 # -> RenderResult:
 # = self.x
 #ove_to = Control.move_to
 #or offset, line in enumerate(self._lines, self.y):
 #ield move_to(x, offset)
 #ield from line


class Capture:
 #""Context manager to capture the result of printing to the console.
 #ee :meth:`~rich.console.Console.capture` for how to use.

 #rgs:
 #onsole (Console): A console instance to capture output.
 #""

 #ef __init__(self, console: "Console") -> None:
 #elf._console = console
 #elf._result: Optional[str] = None

 #ef __enter__(self) -> "Capture":
 #elf._console.begin_capture()
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> None:
 #elf._result = self._console.end_capture()

 #ef get(self) -> str:
 #""Get the result of the capture."""
 #f self._result is None:
 #aise CaptureError(
 #Capture result is not available until context manager exits."
 #
 #eturn self._result


class ThemeContext:
 #""A context manager to use a temporary theme. See :meth:`~rich.console.Console.use_theme` for usage."""

 #ef __init__(self, console: "Console", theme: Theme, inherit: bool = True) -> None:
 #elf.console = console
 #elf.theme = theme
 #elf.inherit = inherit

 #ef __enter__(self) -> "ThemeContext":
 #elf.console.push_theme(self.theme)
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> None:
 #elf.console.pop_theme()


class PagerContext:
 #""A context manager that 'pages' content. See :meth:`~rich.console.Console.pager` for usage."""

 #ef __init__(
 #elf,
 #onsole: "Console",
 #ager: Optional[Pager] = None,
 #tyles: bool = False,
 #inks: bool = False,
 # -> None:
 #elf._console = console
 #elf.pager = SystemPager() if pager is None else pager
 #elf.styles = styles
 #elf.links = links

 #ef __enter__(self) -> "PagerContext":
 #elf._console._enter_buffer()
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> None:
 #f exc_type is None:
 #ith self._console._lock:
 #uffer: List[Segment] = self._console._buffer[:]
 #el self._console._buffer[:]
 #egments: Iterable[Segment] = buffer
 #f not self.styles:
 #egments = Segment.strip_styles(segments)
 #lif not self.links:
 #egments = Segment.strip_links(segments)
 #ontent = self._console._render_buffer(segments)
 #elf.pager.show(content)
 #elf._console._exit_buffer()


class ScreenContext:
 #""A context manager that enables an alternative screen. See :meth:`~rich.console.Console.screen` for usage."""

 #ef __init__(
 #elf, console: "Console", hide_cursor: bool, style: StyleType = ""
 # -> None:
 #elf.console = console
 #elf.hide_cursor = hide_cursor
 #elf.screen = Screen(style=style)
 #elf._changed = False

 #ef update(
 #elf, *renderables: RenderableType, style: Optional[StyleType] = None
 # -> None:
 #""Update the screen.

 #rgs:
 #enderable (RenderableType, optional): Optional renderable to replace current renderable,
 #r None for no change. Defaults to None.
 #tyle: (Style, optional): Replacement style, or None for no change. Defaults to None.
 #""
 #f renderables:
 #elf.screen.renderable = (
 #roup(*renderables) if len(renderables) > 1 else renderables[0]
 #
 #f style is not None:
 #elf.screen.style = style
 #elf.console.print(self.screen, end="")

 #ef __enter__(self) -> "ScreenContext":
 #elf._changed = self.console.set_alt_screen(True)
 #f self._changed and self.hide_cursor:
 #elf.console.show_cursor(False)
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> None:
 #f self._changed:
 #elf.console.set_alt_screen(False)
 #f self.hide_cursor:
 #elf.console.show_cursor(True)


class Group:
 #""Takes a group of renderables and returns a renderable object that renders the group.

 #rgs:
 #enderables (Iterable[RenderableType]): An iterable of renderable objects.
 #it (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True.
 #""

 #ef __init__(self, *renderables: "RenderableType", fit: bool = True) -> None:
 #elf._renderables = renderables
 #elf.fit = fit
 #elf._render: Optional[List[RenderableType]] = None

 #property
 #ef renderables(self) -> List["RenderableType"]:
 #f self._render is None:
 #elf._render = list(self._renderables)
 #eturn self._render

 #ef __rich_measure__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "Measurement":
 #f self.fit:
 #eturn measure_renderables(console, options, self.renderables)
 #lse:
 #eturn Measurement(options.max_width, options.max_width)

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> RenderResult:
 #ield from self.renderables


def group(fit: bool = True) -> Callable[..., Callable[..., Group]]:
 #""A decorator that turns an iterable of renderables in to a group.

 #rgs:
 #it (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True.
 #""

 #ef decorator(
 #ethod: Callable[..., Iterable[RenderableType]]
 # -> Callable[..., Group]:
 #""Convert a method that returns an iterable of renderables in to a Group."""

 #wraps(method)
 #ef _replace(*args: Any, **kwargs: Any) -> Group:
 #enderables = method(*args, **kwargs)
 #eturn Group(*renderables, fit=fit)

 #eturn _replace

 #eturn decorator


def _is_jupyter() -> bool:  # pragma: no cover
 #""Check if we're running in a Jupyter notebook."""
 #ry:
 #et_ipython  # type: ignore[name-defined]
 #xcept NameError:
 #eturn False
 #python = get_ipython()  # type: ignore[name-defined]
 #hell = ipython.__class__.__name__
 #f (
 #google.colab" in str(ipython.__class__)
 #r os.getenv("DATABRICKS_RUNTIME_VERSION")
 #r shell == "ZMQInteractiveShell"
 #:
 #eturn True  # Jupyter notebook or qtconsole
 #lif shell == "TerminalInteractiveShell":
 #eturn False  # Terminal running IPython
 #lse:
 #eturn False  # Other type (?)


COLOR_SYSTEMS = {
 #standard": ColorSystem.STANDARD,
 #256": ColorSystem.EIGHT_BIT,
 #truecolor": ColorSystem.TRUECOLOR,
 #windows": ColorSystem.WINDOWS,
}

_COLOR_SYSTEMS_NAMES = {system: name for name, system in COLOR_SYSTEMS.items()}


@dataclass
class ConsoleThreadLocals(threading.local):
 #""Thread local values for Console context."""

 #heme_stack: ThemeStack
 #uffer: List[Segment] = field(default_factory=list)
 #uffer_index: int = 0


class RenderHook(ABC):
 #""Provides hooks in to the render process."""

 #abstractmethod
 #ef process_renderables(
 #elf, renderables: List[ConsoleRenderable]
 # -> List[ConsoleRenderable]:
 #""Called with a list of objects to render.

 #his method can return a new list of renderables, or modify and return the same list.

 #rgs:
 #enderables (List[ConsoleRenderable]): A number of renderable objects.

 #eturns:
 #ist[ConsoleRenderable]: A replacement list of renderables.
 #""


_windows_console_features: Optional["WindowsConsoleFeatures"] = None


def get_windows_console_features() -> "WindowsConsoleFeatures":  # pragma: no cover
 #lobal _windows_console_features
 #f _windows_console_features is not None:
 #eturn _windows_console_features
 #rom ._windows import get_windows_console_features

 #windows_console_features = get_windows_console_features()
 #eturn _windows_console_features


def detect_legacy_windows() -> bool:
 #""Detect legacy Windows."""
 #eturn WINDOWS and not get_windows_console_features().vt


class Console:
 #""A high level console interface.

 #rgs:
 #olor_system (str, optional): The color system supported by your terminal,
 #ither ``"standard"``, ``"256"`` or ``"truecolor"``. Leave as ``"auto"`` to autodetect.
 #orce_terminal (Optional[bool], optional): Enable/disable terminal control codes, or None to auto-detect terminal. Defaults to None.
 #orce_jupyter (Optional[bool], optional): Enable/disable Jupyter rendering, or None to auto-detect Jupyter. Defaults to None.
 #orce_interactive (Optional[bool], optional): Enable/disable interactive mode, or None to auto detect. Defaults to None.
 #oft_wrap (Optional[bool], optional): Set soft wrap default on print method. Defaults to False.
 #heme (Theme, optional): An optional style theme object, or ``None`` for default theme.
 #tderr (bool, optional): Use stderr rather than stdout if ``file`` is not specified. Defaults to False.
 #ile (IO, optional): A file object where the console should write to. Defaults to stdout.
 #uiet (bool, Optional): Boolean to suppress all output. Defaults to False.
 #idth (int, optional): The width of the terminal. Leave as default to auto-detect width.
 #eight (int, optional): The height of the terminal. Leave as default to auto-detect height.
 #tyle (StyleType, optional): Style to apply to all output, or None for no style. Defaults to None.
 #o_color (Optional[bool], optional): Enabled no color mode, or None to auto detect. Defaults to None.
 #ab_size (int, optional): Number of spaces used to replace a tab character. Defaults to 8.
 #ecord (bool, optional): Boolean to enable recording of terminal output,
 #equired to call :meth:`export_html`, :meth:`export_svg`, and :meth:`export_text`. Defaults to False.
 #arkup (bool, optional): Boolean to enable :ref:`console_markup`. Defaults to True.
 #moji (bool, optional): Enable emoji code. Defaults to True.
 #moji_variant (str, optional): Optional emoji variant, either "text" or "emoji". Defaults to None.
 #ighlight (bool, optional): Enable automatic highlighting. Defaults to True.
 #og_time (bool, optional): Boolean to enable logging of time by :meth:`log` methods. Defaults to True.
 #og_path (bool, optional): Boolean to enable the logging of the caller by :meth:`log`. Defaults to True.
 #og_time_format (Union[str, TimeFormatterCallable], optional): If ``log_time`` is enabled, either string for strftime or callable that formats the time. Defaults to "[%X] ".
 #ighlighter (HighlighterType, optional): Default highlighter.
 #egacy_windows (bool, optional): Enable legacy Windows mode, or ``None`` to auto detect. Defaults to ``None``.
 #afe_box (bool, optional): Restrict box options that don't render on legacy Windows.
 #et_datetime (Callable[[], datetime], optional): Callable that gets the current time as a datetime.datetime object (used by Console.log),
 #r None for datetime.now.
 #et_time (Callable[[], time], optional): Callable that gets the current time in seconds, default uses time.monotonic.
 #""

 #environ: Mapping[str, str] = os.environ

 #ef __init__(
 #elf,
 #,
 #olor_system: Optional[
 #iteral["auto", "standard", "256", "truecolor", "windows"]
 # = "auto",
 #orce_terminal: Optional[bool] = None,
 #orce_jupyter: Optional[bool] = None,
 #orce_interactive: Optional[bool] = None,
 #oft_wrap: bool = False,
 #heme: Optional[Theme] = None,
 #tderr: bool = False,
 #ile: Optional[IO[str]] = None,
 #uiet: bool = False,
 #idth: Optional[int] = None,
 #eight: Optional[int] = None,
 #tyle: Optional[StyleType] = None,
 #o_color: Optional[bool] = None,
 #ab_size: int = 8,
 #ecord: bool = False,
 #arkup: bool = True,
 #moji: bool = True,
 #moji_variant: Optional[EmojiVariant] = None,
 #ighlight: bool = True,
 #og_time: bool = True,
 #og_path: bool = True,
 #og_time_format: Union[str, FormatTimeCallable] = "[%X]",
 #ighlighter: Optional["HighlighterType"] = ReprHighlighter(),
 #egacy_windows: Optional[bool] = None,
 #afe_box: bool = True,
 #et_datetime: Optional[Callable[[], datetime]] = None,
 #et_time: Optional[Callable[[], float]] = None,
 #environ: Optional[Mapping[str, str]] = None,
 #:
        # Copy of os.environ allows us to replace it for testing
 #f _environ is not None:
 #elf._environ = _environ

 #elf.is_jupyter = _is_jupyter() if force_jupyter is None else force_jupyter
 #f self.is_jupyter:
 #f width is None:
 #upyter_columns = self._environ.get("JUPYTER_COLUMNS")
 #f jupyter_columns is not None and jupyter_columns.isdigit():
 #idth = int(jupyter_columns)
 #lse:
 #idth = JUPYTER_DEFAULT_COLUMNS
 #f height is None:
 #upyter_lines = self._environ.get("JUPYTER_LINES")
 #f jupyter_lines is not None and jupyter_lines.isdigit():
 #eight = int(jupyter_lines)
 #lse:
 #eight = JUPYTER_DEFAULT_LINES

 #elf.tab_size = tab_size
 #elf.record = record
 #elf._markup = markup
 #elf._emoji = emoji
 #elf._emoji_variant: Optional[EmojiVariant] = emoji_variant
 #elf._highlight = highlight
 #elf.legacy_windows: bool = (
 #detect_legacy_windows() and not self.is_jupyter)
 #f legacy_windows is None
 #lse legacy_windows
 #

 #f width is None:
 #olumns = self._environ.get("COLUMNS")
 #f columns is not None and columns.isdigit():
 #idth = int(columns) - self.legacy_windows
 #f height is None:
 #ines = self._environ.get("LINES")
 #f lines is not None and lines.isdigit():
 #eight = int(lines)

 #elf.soft_wrap = soft_wrap
 #elf._width = width
 #elf._height = height

 #elf._color_system: Optional[ColorSystem]

 #elf._force_terminal = None
 #f force_terminal is not None:
 #elf._force_terminal = force_terminal

 #elf._file = file
 #elf.quiet = quiet
 #elf.stderr = stderr

 #f color_system is None:
 #elf._color_system = None
 #lif color_system == "auto":
 #elf._color_system = self._detect_color_system()
 #lse:
 #elf._color_system = COLOR_SYSTEMS[color_system]

 #elf._lock = threading.RLock()
 #elf._log_render = LogRender(
 #how_time=log_time,
 #how_path=log_path,
 #ime_format=log_time_format,
 #
 #elf.highlighter: HighlighterType = highlighter or _null_highlighter
 #elf.safe_box = safe_box
 #elf.get_datetime = get_datetime or datetime.now
 #elf.get_time = get_time or monotonic
 #elf.style = style
 #elf.no_color = (
 #o_color if no_color is not None else "NO_COLOR" in self._environ
 #
 #elf.is_interactive = (
 #self.is_terminal and not self.is_dumb_terminal)
 #f force_interactive is None
 #lse force_interactive
 #

 #elf._record_buffer_lock = threading.RLock()
 #elf._thread_locals = ConsoleThreadLocals(
 #heme_stack=ThemeStack(themes.DEFAULT if theme is None else theme)
 #
 #elf._record_buffer: List[Segment] = []
 #elf._render_hooks: List[RenderHook] = []
 #elf._live: Optional["Live"] = None
 #elf._is_alt_screen = False

 #ef __repr__(self) -> str:
 #eturn f"<console width={self.width} {self._color_system!s}>"

 #property
 #ef file(self) -> IO[str]:
 #""Get the file object to write to."""
 #ile = self._file or (sys.stderr if self.stderr else sys.stdout)
 #ile = getattr(file, "rich_proxied_file", file)
 #f file is None:
 #ile = NULL_FILE
 #eturn file

 #file.setter
 #ef file(self, new_file: IO[str]) -> None:
 #""Set a new file object."""
 #elf._file = new_file

 #property
 #ef _buffer(self) -> List[Segment]:
 #""Get a thread local buffer."""
 #eturn self._thread_locals.buffer

 #property
 #ef _buffer_index(self) -> int:
 #""Get a thread local buffer."""
 #eturn self._thread_locals.buffer_index

 #_buffer_index.setter
 #ef _buffer_index(self, value: int) -> None:
 #elf._thread_locals.buffer_index = value

 #property
 #ef _theme_stack(self) -> ThemeStack:
 #""Get the thread local theme stack."""
 #eturn self._thread_locals.theme_stack

 #ef _detect_color_system(self) -> Optional[ColorSystem]:
 #""Detect color system from env vars."""
 #f self.is_jupyter:
 #eturn ColorSystem.TRUECOLOR
 #f not self.is_terminal or self.is_dumb_terminal:
 #eturn None
 #f WINDOWS:  # pragma: no cover
 #f self.legacy_windows:  # pragma: no cover
 #eturn ColorSystem.WINDOWS
 #indows_console_features = get_windows_console_features()
 #eturn (
 #olorSystem.TRUECOLOR
 #f windows_console_features.truecolor
 #lse ColorSystem.EIGHT_BIT
 #
 #lse:
 #olor_term = self._environ.get("COLORTERM", "").strip().lower()
 #f color_term in ("truecolor", "24bit"):
 #eturn ColorSystem.TRUECOLOR
 #erm = self._environ.get("TERM", "").strip().lower()
 #term_name, _hyphen, colors = term.rpartition("-")
 #olor_system = _TERM_COLORS.get(colors, ColorSystem.STANDARD)
 #eturn color_system

 #ef _enter_buffer(self) -> None:
 #""Enter in to a buffer context, and buffer all output."""
 #elf._buffer_index += 1

 #ef _exit_buffer(self) -> None:
 #""Leave buffer context, and render content if required."""
 #elf._buffer_index -= 1
 #elf._check_buffer()

 #ef set_live(self, live: "Live") -> None:
 #""Set Live instance. Used by Live context manager.

 #rgs:
 #ive (Live): Live instance using this Console.

 #aises:
 #rrors.LiveError: If this Console has a Live context currently active.
 #""
 #ith self._lock:
 #f self._live is not None:
 #aise errors.LiveError("Only one live display may be active at once")
 #elf._live = live

 #ef clear_live(self) -> None:
 #""Clear the Live instance."""
 #ith self._lock:
 #elf._live = None

 #ef push_render_hook(self, hook: RenderHook) -> None:
 #""Add a new render hook to the stack.

 #rgs:
 #ook (RenderHook): Render hook instance.
 #""
 #ith self._lock:
 #elf._render_hooks.append(hook)

 #ef pop_render_hook(self) -> None:
 #""Pop the last renderhook from the stack."""
 #ith self._lock:
 #elf._render_hooks.pop()

 #ef __enter__(self) -> "Console":
 #""Own context manager to enter buffer context."""
 #elf._enter_buffer()
 #eturn self

 #ef __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:
 #""Exit buffer context."""
 #elf._exit_buffer()

 #ef begin_capture(self) -> None:
 #""Begin capturing console output. Call :meth:`end_capture` to exit capture mode and return output."""
 #elf._enter_buffer()

 #ef end_capture(self) -> str:
 #""End capture mode and return captured string.

 #eturns:
 #tr: Console output.
 #""
 #ender_result = self._render_buffer(self._buffer)
 #el self._buffer[:]
 #elf._exit_buffer()
 #eturn render_result

 #ef push_theme(self, theme: Theme, *, inherit: bool = True) -> None:
 #""Push a new theme on to the top of the stack, replacing the styles from the previous theme.
 #enerally speaking, you should call :meth:`~rich.console.Console.use_theme` to get a context manager, rather
 #han calling this method directly.

 #rgs:
 #heme (Theme): A theme instance.
 #nherit (bool, optional): Inherit existing styles. Defaults to True.
 #""
 #elf._theme_stack.push_theme(theme, inherit=inherit)

 #ef pop_theme(self) -> None:
 #""Remove theme from top of stack, restoring previous theme."""
 #elf._theme_stack.pop_theme()

 #ef use_theme(self, theme: Theme, *, inherit: bool = True) -> ThemeContext:
 #""Use a different theme for the duration of the context manager.

 #rgs:
 #heme (Theme): Theme instance to user.
 #nherit (bool, optional): Inherit existing console styles. Defaults to True.

 #eturns:
 #hemeContext: [description]
 #""
 #eturn ThemeContext(self, theme, inherit)

 #property
 #ef color_system(self) -> Optional[str]:
 #""Get color system string.

 #eturns:
 #ptional[str]: "standard", "256" or "truecolor".
 #""

 #f self._color_system is not None:
 #eturn _COLOR_SYSTEMS_NAMES[self._color_system]
 #lse:
 #eturn None

 #property
 #ef encoding(self) -> str:
 #""Get the encoding of the console file, e.g. ``"utf-8"``.

 #eturns:
 #tr: A standard encoding string.
 #""
 #eturn (getattr(self.file, "encoding", "utf-8") or "utf-8").lower()

 #property
 #ef is_terminal(self) -> bool:
 #""Check if the console is writing to a terminal.

 #eturns:
 #ool: True if the console writing to a device capable of
 #nderstanding terminal codes, otherwise False.
 #""
 #f self._force_terminal is not None:
 #eturn self._force_terminal

 #f hasattr(sys.stdin, "__module__") and sys.stdin.__module__.startswith(
 #idlelib"
 #:
            # Return False for Idle which claims to be a tty but can't handle ansi codes
 #eturn False

 #f self.is_jupyter:
            # return False for Jupyter, which may have FORCE_COLOR set
 #eturn False

        # If FORCE_COLOR env var has any value at all, we assume a terminal.
 #orce_color = self._environ.get("FORCE_COLOR")
 #f force_color is not None:
 #elf._force_terminal = True
 #eturn True

 #satty: Optional[Callable[[], bool]] = getattr(self.file, "isatty", None)
 #ry:
 #eturn False if isatty is None else isatty()
 #xcept ValueError:
            # in some situation (at the end of a pytest run for example) isatty() can raise
            # ValueError: I/O operation on closed file
            # return False because we aren't in a terminal anymore
 #eturn False

 #property
 #ef is_dumb_terminal(self) -> bool:
 #""Detect dumb terminal.

 #eturns:
 #ool: True if writing to a dumb terminal, otherwise False.

 #""
 #term = self._environ.get("TERM", "")
 #s_dumb = _term.lower() in ("dumb", "unknown")
 #eturn self.is_terminal and is_dumb

 #property
 #ef options(self) -> ConsoleOptions:
 #""Get default console options."""
 #eturn ConsoleOptions(
 #ax_height=self.size.height,
 #ize=self.size,
 #egacy_windows=self.legacy_windows,
 #in_width=1,
 #ax_width=self.width,
 #ncoding=self.encoding,
 #s_terminal=self.is_terminal,
 #

 #property
 #ef size(self) -> ConsoleDimensions:
 #""Get the size of the console.

 #eturns:
 #onsoleDimensions: A named tuple containing the dimensions.
 #""

 #f self._width is not None and self._height is not None:
 #eturn ConsoleDimensions(self._width - self.legacy_windows, self._height)

 #f self.is_dumb_terminal:
 #eturn ConsoleDimensions(80, 25)

 #idth: Optional[int] = None
 #eight: Optional[int] = None

 #f WINDOWS:  # pragma: no cover
 #ry:
 #idth, height = os.get_terminal_size()
 #xcept (AttributeError, ValueError, OSError):  # Probably not a terminal
 #ass
 #lse:
 #or file_descriptor in _STD_STREAMS:
 #ry:
 #idth, height = os.get_terminal_size(file_descriptor)
 #xcept (AttributeError, ValueError, OSError):
 #ass
 #lse:
 #reak

 #olumns = self._environ.get("COLUMNS")
 #f columns is not None and columns.isdigit():
 #idth = int(columns)
 #ines = self._environ.get("LINES")
 #f lines is not None and lines.isdigit():
 #eight = int(lines)

        # get_terminal_size can report 0, 0 if run from pseudo-terminal
 #idth = width or 80
 #eight = height or 25
 #eturn ConsoleDimensions(
 #idth - self.legacy_windows if self._width is None else self._width,
 #eight if self._height is None else self._height,
 #

 #size.setter
 #ef size(self, new_size: Tuple[int, int]) -> None:
 #""Set a new size for the terminal.

 #rgs:
 #ew_size (Tuple[int, int]): New width and height.
 #""
 #idth, height = new_size
 #elf._width = width
 #elf._height = height

 #property
 #ef width(self) -> int:
 #""Get the width of the console.

 #eturns:
 #nt: The width (in characters) of the console.
 #""
 #eturn self.size.width

 #width.setter
 #ef width(self, width: int) -> None:
 #""Set width.

 #rgs:
 #idth (int): New width.
 #""
 #elf._width = width

 #property
 #ef height(self) -> int:
 #""Get the height of the console.

 #eturns:
 #nt: The height (in lines) of the console.
 #""
 #eturn self.size.height

 #height.setter
 #ef height(self, height: int) -> None:
 #""Set height.

 #rgs:
 #eight (int): new height.
 #""
 #elf._height = height

 #ef bell(self) -> None:
 #""Play a 'bell' sound (if supported by the terminal)."""
 #elf.control(Control.bell())

 #ef capture(self) -> Capture:
 #""A context manager to *capture* the result of print() or log() in a string,
 #ather than writing it to the console.

 #xample:
 #>> from rich.console import Console
 #>> console = Console()
 #>> with console.capture() as capture:
 #..     console.print("[bold magenta]Hello World[/]")
 #>> print(capture.get())

 #eturns:
 #apture: Context manager with disables writing to the terminal.
 #""
 #apture = Capture(self)
 #eturn capture

 #ef pager(
 #elf, pager: Optional[Pager] = None, styles: bool = False, links: bool = False
 # -> PagerContext:
 #""A context manager to display anything printed within a "pager". The pager application
 #s defined by the system and will typically support at least pressing a key to scroll.

 #rgs:
 #ager (Pager, optional): A pager object, or None to use :class:`~rich.pager.SystemPager`. Defaults to None.
 #tyles (bool, optional): Show styles in pager. Defaults to False.
 #inks (bool, optional): Show links in pager. Defaults to False.

 #xample:
 #>> from rich.console import Console
 #>> from rich.__main__ import make_test_card
 #>> console = Console()
 #>> with console.pager():
 #onsole.print(make_test_card())

 #eturns:
 #agerContext: A context manager.
 #""
 #eturn PagerContext(self, pager=pager, styles=styles, links=links)

 #ef line(self, count: int = 1) -> None:
 #""Write new line(s).

 #rgs:
 #ount (int, optional): Number of new lines. Defaults to 1.
 #""

 #ssert count >= 0, "count must be >= 0"
 #elf.print(NewLine(count))

 #ef clear(self, home: bool = True) -> None:
 #""Clear the screen.

 #rgs:
 #ome (bool, optional): Also move the cursor to 'home' position. Defaults to True.
 #""
 #f home:
 #elf.control(Control.clear(), Control.home())
 #lse:
 #elf.control(Control.clear())

 #ef status(
 #elf,
 #tatus: RenderableType,
 #,
 #pinner: str = "dots",
 #pinner_style: StyleType = "status.spinner",
 #peed: float = 1.0,
 #efresh_per_second: float = 12.5,
 # -> "Status":
 #""Display a status and spinner.

 #rgs:
 #tatus (RenderableType): A status renderable (str or Text typically).
 #pinner (str, optional): Name of spinner animation (see python -m rich.spinner). Defaults to "dots".
 #pinner_style (StyleType, optional): Style of spinner. Defaults to "status.spinner".
 #peed (float, optional): Speed factor for spinner animation. Defaults to 1.0.
 #efresh_per_second (float, optional): Number of refreshes per second. Defaults to 12.5.

 #eturns:
 #tatus: A Status object that may be used as a context manager.
 #""
 #rom .status import Status

 #tatus_renderable = Status(
 #tatus,
 #onsole=self,
 #pinner=spinner,
 #pinner_style=spinner_style,
 #peed=speed,
 #efresh_per_second=refresh_per_second,
 #
 #eturn status_renderable

 #ef show_cursor(self, show: bool = True) -> bool:
 #""Show or hide the cursor.

 #rgs:
 #how (bool, optional): Set visibility of the cursor.
 #""
 #f self.is_terminal:
 #elf.control(Control.show_cursor(show))
 #eturn True
 #eturn False

 #ef set_alt_screen(self, enable: bool = True) -> bool:
 #""Enables alternative screen mode.

 #ote, if you enable this mode, you should ensure that is disabled before
 #he application exits. See :meth:`~rich.Console.screen` for a context manager
 #hat handles this for you.

 #rgs:
 #nable (bool, optional): Enable (True) or disable (False) alternate screen. Defaults to True.

 #eturns:
 #ool: True if the control codes were written.

 #""
 #hanged = False
 #f self.is_terminal and not self.legacy_windows:
 #elf.control(Control.alt_screen(enable))
 #hanged = True
 #elf._is_alt_screen = enable
 #eturn changed

 #property
 #ef is_alt_screen(self) -> bool:
 #""Check if the alt screen was enabled.

 #eturns:
 #ool: True if the alt screen was enabled, otherwise False.
 #""
 #eturn self._is_alt_screen

 #ef set_window_title(self, title: str) -> bool:
 #""Set the title of the console terminal window.

 #arning: There is no means within Rich of "resetting" the window title to its
 #revious value, meaning the title you set will persist even after your application
 #xits.

 #`fish`` shell resets the window title before and after each command by default,
 #egating this issue. Windows Terminal and command prompt will also reset the title for you.
 #ost other shells and terminals, however, do not do this.

 #ome terminals may require configuration changes before you can set the title.
 #ome terminals may not support setting the title at all.

 #ther software (including the terminal itself, the shell, custom prompts, plugins, etc.)
 #ay also set the terminal window title. This could result in whatever value you write
 #sing this method being overwritten.

 #rgs:
 #itle (str): The new title of the terminal window.

 #eturns:
 #ool: True if the control code to change the terminal title was
 #ritten, otherwise False. Note that a return value of True
 #oes not guarantee that the window title has actually changed,
 #ince the feature may be unsupported/disabled in some terminals.
 #""
 #f self.is_terminal:
 #elf.control(Control.title(title))
 #eturn True
 #eturn False

 #ef screen(
 #elf, hide_cursor: bool = True, style: Optional[StyleType] = None
 # -> "ScreenContext":
 #""Context manager to enable and disable 'alternative screen' mode.

 #rgs:
 #ide_cursor (bool, optional): Also hide the cursor. Defaults to False.
 #tyle (Style, optional): Optional style for screen. Defaults to None.

 #eturns:
 #ScreenContext: Context which enables alternate screen on enter, and disables it on exit.
 #""
 #eturn ScreenContext(self, hide_cursor=hide_cursor, style=style or "")

 #ef measure(
 #elf, renderable: RenderableType, *, options: Optional[ConsoleOptions] = None
 # -> Measurement:
 #""Measure a renderable. Returns a :class:`~rich.measure.Measurement` object which contains
 #nformation regarding the number of characters required to print the renderable.

 #rgs:
 #enderable (RenderableType): Any renderable or string.
 #ptions (Optional[ConsoleOptions], optional): Options to use when measuring, or None
 #o use default options. Defaults to None.

 #eturns:
 #easurement: A measurement of the renderable.
 #""
 #easurement = Measurement.get(self, options or self.options, renderable)
 #eturn measurement

 #ef render(
 #elf, renderable: RenderableType, options: Optional[ConsoleOptions] = None
 # -> Iterable[Segment]:
 #""Render an object in to an iterable of `Segment` instances.

 #his method contains the logic for rendering objects with the console protocol.
 #ou are unlikely to need to use it directly, unless you are extending the library.

 #rgs:
 #enderable (RenderableType): An object supporting the console protocol, or
 #n object that may be converted to a string.
 #ptions (ConsoleOptions, optional): An options object, or None to use self.options. Defaults to None.

 #eturns:
 #terable[Segment]: An iterable of segments that may be rendered.
 #""

 #options = options or self.options
 #f _options.max_width < 1:
            # No space to render anything. This prevents potential recursion errors.
 #eturn
 #ender_iterable: RenderResult

 #enderable = rich_cast(renderable)
 #f hasattr(renderable, "__rich_console__") and not isclass(renderable):
 #ender_iterable = renderable.__rich_console__(self, _options)  # type: ignore[union-attr]
 #lif isinstance(renderable, str):
 #ext_renderable = self.render_str(
 #enderable, highlight=_options.highlight, markup=_options.markup
 #
 #ender_iterable = text_renderable.__rich_console__(self, _options)
 #lse:
 #aise errors.NotRenderableError(
 #"Unable to render {renderable!r}; "
 #A str, Segment or object with __rich_console__ method is required"
 #

 #ry:
 #ter_render = iter(render_iterable)
 #xcept TypeError:
 #aise errors.NotRenderableError(
 #"object {render_iterable!r} is not renderable"
 #
 #Segment = Segment
 #options = _options.reset_height()
 #or render_output in iter_render:
 #f isinstance(render_output, _Segment):
 #ield render_output
 #lse:
 #ield from self.render(render_output, _options)

 #ef render_lines(
 #elf,
 #enderable: RenderableType,
 #ptions: Optional[ConsoleOptions] = None,
 #,
 #tyle: Optional[Style] = None,
 #ad: bool = True,
 #ew_lines: bool = False,
 # -> List[List[Segment]]:
 #""Render objects in to a list of lines.

 #he output of render_lines is useful when further formatting of rendered console text
 #s required, such as the Panel class which draws a border around any renderable object.

 #rgs:
 #enderable (RenderableType): Any object renderable in the console.
 #ptions (Optional[ConsoleOptions], optional): Console options, or None to use self.options. Default to ``None``.
 #tyle (Style, optional): Optional style to apply to renderables. Defaults to ``None``.
 #ad (bool, optional): Pad lines shorter than render width. Defaults to ``True``.
 #ew_lines (bool, optional): Include "\n" characters at end of lines.

 #eturns:
 #ist[List[Segment]]: A list of lines, where a line is a list of Segment objects.
 #""
 #ith self._lock:
 #ender_options = options or self.options
 #rendered = self.render(renderable, render_options)
 #f style:
 #rendered = Segment.apply_style(_rendered, style)

 #ender_height = render_options.height
 #f render_height is not None:
 #ender_height = max(0, render_height)

 #ines = list(
 #slice(
 #egment.split_and_crop_lines(
 #rendered,
 #ender_options.max_width,
 #nclude_new_lines=new_lines,
 #ad=pad,
 #tyle=style,
 #,
 #one,
 #ender_height,
 #
 #
 #f render_options.height is not None:
 #xtra_lines = render_options.height - len(lines)
 #f extra_lines > 0:
 #ad_line = [
 #Segment(" " * render_options.max_width, style), Segment("\n")]
 #f new_lines
 #lse [Segment(" " * render_options.max_width, style)]
 #
 #ines.extend(pad_line * extra_lines)

 #eturn lines

 #ef render_str(
 #elf,
 #ext: str,
 #,
 #tyle: Union[str, Style] = "",
 #ustify: Optional[JustifyMethod] = None,
 #verflow: Optional[OverflowMethod] = None,
 #moji: Optional[bool] = None,
 #arkup: Optional[bool] = None,
 #ighlight: Optional[bool] = None,
 #ighlighter: Optional[HighlighterType] = None,
 # -> "Text":
 #""Convert a string to a Text instance. This is called automatically if
 #ou print or log a string.

 #rgs:
 #ext (str): Text to render.
 #tyle (Union[str, Style], optional): Style to apply to rendered text.
 #ustify (str, optional): Justify method: "default", "left", "center", "full", or "right". Defaults to ``None``.
 #verflow (str, optional): Overflow method: "crop", "fold", or "ellipsis". Defaults to ``None``.
 #moji (Optional[bool], optional): Enable emoji, or ``None`` to use Console default.
 #arkup (Optional[bool], optional): Enable markup, or ``None`` to use Console default.
 #ighlight (Optional[bool], optional): Enable highlighting, or ``None`` to use Console default.
 #ighlighter (HighlighterType, optional): Optional highlighter to apply.
 #eturns:
 #onsoleRenderable: Renderable object.

 #""
 #moji_enabled = emoji or (emoji is None and self._emoji)
 #arkup_enabled = markup or (markup is None and self._markup)
 #ighlight_enabled = highlight or (highlight is None and self._highlight)

 #f markup_enabled:
 #ich_text = render_markup(
 #ext,
 #tyle=style,
 #moji=emoji_enabled,
 #moji_variant=self._emoji_variant,
 #
 #ich_text.justify = justify
 #ich_text.overflow = overflow
 #lse:
 #ich_text = Text(
 #emoji_replace(text, default_variant=self._emoji_variant)
 #f emoji_enabled
 #lse text,
 #ustify=justify,
 #verflow=overflow,
 #tyle=style,
 #

 #highlighter = (highlighter or self.highlighter) if highlight_enabled else None
 #f _highlighter is not None:
 #ighlight_text = _highlighter(str(rich_text))
 #ighlight_text.copy_styles(rich_text)
 #eturn highlight_text

 #eturn rich_text

 #ef get_style(
 #elf, name: Union[str, Style], *, default: Optional[Union[Style, str]] = None
 # -> Style:
 #""Get a Style instance by its theme name or parse a definition.

 #rgs:
 #ame (str): The name of a style or a style definition.

 #eturns:
 #tyle: A Style object.

 #aises:
 #issingStyle: If no style could be parsed from name.

 #""
 #f isinstance(name, Style):
 #eturn name

 #ry:
 #tyle = self._theme_stack.get(name)
 #f style is None:
 #tyle = Style.parse(name)
 #eturn style.copy() if style.link else style
 #xcept errors.StyleSyntaxError as error:
 #f default is not None:
 #eturn self.get_style(default)
 #aise errors.MissingStyle(
 #"Failed to get style {name!r}; {error}"
 # from None

 #ef _collect_renderables(
 #elf,
 #bjects: Iterable[Any],
 #ep: str,
 #nd: str,
 #,
 #ustify: Optional[JustifyMethod] = None,
 #moji: Optional[bool] = None,
 #arkup: Optional[bool] = None,
 #ighlight: Optional[bool] = None,
 # -> List[ConsoleRenderable]:
 #""Combine a number of renderables and text into one renderable.

 #rgs:
 #bjects (Iterable[Any]): Anything that Rich can render.
 #ep (str): String to write between print data.
 #nd (str): String to write at end of print data.
 #ustify (str, optional): One of "left", "right", "center", or "full". Defaults to ``None``.
 #moji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default.
 #arkup (Optional[bool], optional): Enable markup, or ``None`` to use console default.
 #ighlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default.

 #eturns:
 #ist[ConsoleRenderable]: A list of things to render.
 #""
 #enderables: List[ConsoleRenderable] = []
 #append = renderables.append
 #ext: List[Text] = []
 #ppend_text = text.append

 #ppend = _append
 #f justify in ("left", "center", "right"):

 #ef align_append(renderable: RenderableType) -> None:
 #append(Align(renderable, cast(AlignMethod, justify)))

 #ppend = align_append

 #highlighter: HighlighterType = _null_highlighter
 #f highlight or (highlight is None and self._highlight):
 #highlighter = self.highlighter

 #ef check_text() -> None:
 #f text:
 #ep_text = Text(sep, justify=justify, end=end)
 #ppend(sep_text.join(text))
 #ext.clear()

 #or renderable in objects:
 #enderable = rich_cast(renderable)
 #f isinstance(renderable, str):
 #ppend_text(
 #elf.render_str(
 #enderable, emoji=emoji, markup=markup, highlighter=_highlighter
 #
 #
 #lif isinstance(renderable, Text):
 #ppend_text(renderable)
 #lif isinstance(renderable, ConsoleRenderable):
 #heck_text()
 #ppend(renderable)
 #lif is_expandable(renderable):
 #heck_text()
 #ppend(Pretty(renderable, highlighter=_highlighter))
 #lse:
 #ppend_text(_highlighter(str(renderable)))

 #heck_text()

 #f self.style is not None:
 #tyle = self.get_style(self.style)
 #enderables = [Styled(renderable, style) for renderable in renderables]

 #eturn renderables

 #ef rule(
 #elf,
 #itle: TextType = "",
 #,
 #haracters: str = "─",
 #tyle: Union[str, Style] = "rule.line",
 #lign: AlignMethod = "center",
 # -> None:
 #""Draw a line with optional centered title.

 #rgs:
 #itle (str, optional): Text to render over the rule. Defaults to "".
 #haracters (str, optional): Character(s) to form the line. Defaults to "─".
 #tyle (str, optional): Style of line. Defaults to "rule.line".
 #lign (str, optional): How to align the title, one of "left", "center", or "right". Defaults to "center".
 #""
 #rom .rule import Rule

 #ule = Rule(title=title, characters=characters, style=style, align=align)
 #elf.print(rule)

 #ef control(self, *control: Control) -> None:
 #""Insert non-printing control codes.

 #rgs:
 #ontrol_codes (str): Control codes, such as those that may move the cursor.
 #""
 #f not self.is_dumb_terminal:
 #ith self:
 #elf._buffer.extend(_control.segment for _control in control)

 #ef out(
 #elf,
 #objects: Any,
 #ep: str = " ",
 #nd: str = "\n",
 #tyle: Optional[Union[str, Style]] = None,
 #ighlight: Optional[bool] = None,
 # -> None:
 #""Output to the terminal. This is a low-level way of writing to the terminal which unlike
 #meth:`~rich.console.Console.print` won't pretty print, wrap text, or apply markup, but will
 #ptionally apply highlighting and a basic style.

 #rgs:
 #ep (str, optional): String to write between print data. Defaults to " ".
 #nd (str, optional): String to write at end of print data. Defaults to "\\\\n".
 #tyle (Union[str, Style], optional): A style to apply to output. Defaults to None.
 #ighlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use
 #onsole default. Defaults to ``None``.
 #""
 #aw_output: str = sep.join(str(_object) for _object in objects)
 #elf.print(
 #aw_output,
 #tyle=style,
 #ighlight=highlight,
 #moji=False,
 #arkup=False,
 #o_wrap=True,
 #verflow="ignore",
 #rop=False,
 #nd=end,
 #

 #ef print(
 #elf,
 #objects: Any,
 #ep: str = " ",
 #nd: str = "\n",
 #tyle: Optional[Union[str, Style]] = None,
 #ustify: Optional[JustifyMethod] = None,
 #verflow: Optional[OverflowMethod] = None,
 #o_wrap: Optional[bool] = None,
 #moji: Optional[bool] = None,
 #arkup: Optional[bool] = None,
 #ighlight: Optional[bool] = None,
 #idth: Optional[int] = None,
 #eight: Optional[int] = None,
 #rop: bool = True,
 #oft_wrap: Optional[bool] = None,
 #ew_line_start: bool = False,
 # -> None:
 #""Print to the console.

 #rgs:
 #bjects (positional args): Objects to log to the terminal.
 #ep (str, optional): String to write between print data. Defaults to " ".
 #nd (str, optional): String to write at end of print data. Defaults to "\\\\n".
 #tyle (Union[str, Style], optional): A style to apply to output. Defaults to None.
 #ustify (str, optional): Justify method: "default", "left", "right", "center", or "full". Defaults to ``None``.
 #verflow (str, optional): Overflow method: "ignore", "crop", "fold", or "ellipsis". Defaults to None.
 #o_wrap (Optional[bool], optional): Disable word wrapping. Defaults to None.
 #moji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to ``None``.
 #arkup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to ``None``.
 #ighlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to ``None``.
 #idth (Optional[int], optional): Width of output, or ``None`` to auto-detect. Defaults to ``None``.
 #rop (Optional[bool], optional): Crop output to width of terminal. Defaults to True.
 #oft_wrap (bool, optional): Enable soft wrap mode which disables word wrapping and cropping of text or ``None`` for
 #onsole default. Defaults to ``None``.
 #ew_line_start (bool, False): Insert a new line at the start if the output contains more than one line. Defaults to ``False``.
 #""
 #f not objects:
 #bjects = (NewLine(),)

 #f soft_wrap is None:
 #oft_wrap = self.soft_wrap
 #f soft_wrap:
 #f no_wrap is None:
 #o_wrap = True
 #f overflow is None:
 #verflow = "ignore"
 #rop = False
 #ender_hooks = self._render_hooks[:]
 #ith self:
 #enderables = self._collect_renderables(
 #bjects,
 #ep,
 #nd,
 #ustify=justify,
 #moji=emoji,
 #arkup=markup,
 #ighlight=highlight,
 #
 #or hook in render_hooks:
 #enderables = hook.process_renderables(renderables)
 #ender_options = self.options.update(
 #ustify=justify,
 #verflow=overflow,
 #idth=min(width, self.width) if width is not None else NO_CHANGE,
 #eight=height,
 #o_wrap=no_wrap,
 #arkup=markup,
 #ighlight=highlight,
 #

 #ew_segments: List[Segment] = []
 #xtend = new_segments.extend
 #ender = self.render
 #f style is None:
 #or renderable in renderables:
 #xtend(render(renderable, render_options))
 #lse:
 #or renderable in renderables:
 #xtend(
 #egment.apply_style(
 #ender(renderable, render_options), self.get_style(style)
 #
 #
 #f new_line_start:
 #f (
 #en("".join(segment.text for segment in new_segments).splitlines())
 # 1
 #:
 #ew_segments.insert(0, Segment.line())
 #f crop:
 #uffer_extend = self._buffer.extend
 #or line in Segment.split_and_crop_lines(
 #ew_segments, self.width, pad=False
 #:
 #uffer_extend(line)
 #lse:
 #elf._buffer.extend(new_segments)

 #ef print_json(
 #elf,
 #son: Optional[str] = None,
 #,
 #ata: Any = None,
 #ndent: Union[None, int, str] = 2,
 #ighlight: bool = True,
 #kip_keys: bool = False,
 #nsure_ascii: bool = False,
 #heck_circular: bool = True,
 #llow_nan: bool = True,
 #efault: Optional[Callable[[Any], Any]] = None,
 #ort_keys: bool = False,
 # -> None:
 #""Pretty prints JSON. Output will be valid JSON.

 #rgs:
 #son (Optional[str]): A string containing JSON.
 #ata (Any): If json is not supplied, then encode this data.
 #ndent (Union[None, int, str], optional): Number of spaces to indent. Defaults to 2.
 #ighlight (bool, optional): Enable highlighting of output: Defaults to True.
 #kip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.
 #nsure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.
 #heck_circular (bool, optional): Check for circular references. Defaults to True.
 #llow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.
 #efault (Callable, optional): A callable that converts values that can not be encoded
 #n to something that can be JSON encoded. Defaults to None.
 #ort_keys (bool, optional): Sort dictionary keys. Defaults to False.
 #""
 #rom pip._vendor.rich.json import JSON

 #f json is None:
 #son_renderable = JSON.from_data(
 #ata,
 #ndent=indent,
 #ighlight=highlight,
 #kip_keys=skip_keys,
 #nsure_ascii=ensure_ascii,
 #heck_circular=check_circular,
 #llow_nan=allow_nan,
 #efault=default,
 #ort_keys=sort_keys,
 #
 #lse:
 #f not isinstance(json, str):
 #aise TypeError(
 #"json must be str. Did you mean print_json(data={json!r}) ?"
 #
 #son_renderable = JSON(
 #son,
 #ndent=indent,
 #ighlight=highlight,
 #kip_keys=skip_keys,
 #nsure_ascii=ensure_ascii,
 #heck_circular=check_circular,
 #llow_nan=allow_nan,
 #efault=default,
 #ort_keys=sort_keys,
 #
 #elf.print(json_renderable, soft_wrap=True)

 #ef update_screen(
 #elf,
 #enderable: RenderableType,
 #,
 #egion: Optional[Region] = None,
 #ptions: Optional[ConsoleOptions] = None,
 # -> None:
 #""Update the screen at a given offset.

 #rgs:
 #enderable (RenderableType): A Rich renderable.
 #egion (Region, optional): Region of screen to update, or None for entire screen. Defaults to None.
 # (int, optional): x offset. Defaults to 0.
 # (int, optional): y offset. Defaults to 0.

 #aises:
 #rrors.NoAltScreen: If the Console isn't in alt screen mode.

 #""
 #f not self.is_alt_screen:
 #aise errors.NoAltScreen("Alt screen must be enabled to call update_screen")
 #ender_options = options or self.options
 #f region is None:
 # = y = 0
 #ender_options = render_options.update_dimensions(
 #ender_options.max_width, render_options.height or self.height
 #
 #lse:
 #, y, width, height = region
 #ender_options = render_options.update_dimensions(width, height)

 #ines = self.render_lines(renderable, options=render_options)
 #elf.update_screen_lines(lines, x, y)

 #ef update_screen_lines(
 #elf, lines: List[List[Segment]], x: int = 0, y: int = 0
 # -> None:
 #""Update lines of the screen at a given offset.

 #rgs:
 #ines (List[List[Segment]]): Rendered lines (as produced by :meth:`~rich.Console.render_lines`).
 # (int, optional): x offset (column no). Defaults to 0.
 # (int, optional): y offset (column no). Defaults to 0.

 #aises:
 #rrors.NoAltScreen: If the Console isn't in alt screen mode.
 #""
 #f not self.is_alt_screen:
 #aise errors.NoAltScreen("Alt screen must be enabled to call update_screen")
 #creen_update = ScreenUpdate(lines, x, y)
 #egments = self.render(screen_update)
 #elf._buffer.extend(segments)
 #elf._check_buffer()

 #ef print_exception(
 #elf,
 #,
 #idth: Optional[int] = 100,
 #xtra_lines: int = 3,
 #heme: Optional[str] = None,
 #ord_wrap: bool = False,
 #how_locals: bool = False,
 #uppress: Iterable[Union[str, ModuleType]] = (),
 #ax_frames: int = 100,
 # -> None:
 #""Prints a rich render of the last exception and traceback.

 #rgs:
 #idth (Optional[int], optional): Number of characters used to render code. Defaults to 100.
 #xtra_lines (int, optional): Additional lines of code to render. Defaults to 3.
 #heme (str, optional): Override pygments theme used in traceback
 #ord_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.
 #how_locals (bool, optional): Enable display of local variables. Defaults to False.
 #uppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.
 #ax_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.
 #""
 #rom .traceback import Traceback

 #raceback = Traceback(
 #idth=width,
 #xtra_lines=extra_lines,
 #heme=theme,
 #ord_wrap=word_wrap,
 #how_locals=show_locals,
 #uppress=suppress,
 #ax_frames=max_frames,
 #
 #elf.print(traceback)

 #staticmethod
 #ef _caller_frame_info(
 #ffset: int,
 #urrentframe: Callable[[], Optional[FrameType]] = inspect.currentframe,
 # -> Tuple[str, int, Dict[str, Any]]:
 #""Get caller frame information.

 #rgs:
 #ffset (int): the caller offset within the current frame stack.
 #urrentframe (Callable[[], Optional[FrameType]], optional): the callable to use to
 #etrieve the current frame. Defaults to ``inspect.currentframe``.

 #eturns:
 #uple[str, int, Dict[str, Any]]: A tuple containing the filename, the line number and
 #he dictionary of local variables associated with the caller frame.

 #aises:
 #untimeError: If the stack offset is invalid.
 #""
        # Ignore the frame of this local helper
 #ffset += 1

 #rame = currentframe()
 #f frame is not None:
            # Use the faster currentframe where implemented
 #hile offset and frame is not None:
 #rame = frame.f_back
 #ffset -= 1
 #ssert frame is not None
 #eturn frame.f_code.co_filename, frame.f_lineno, frame.f_locals
 #lse:
            # Fallback to the slower stack
 #rame_info = inspect.stack()[offset]
 #eturn frame_info.filename, frame_info.lineno, frame_info.frame.f_locals

 #ef log(
 #elf,
 #objects: Any,
 #ep: str = " ",
 #nd: str = "\n",
 #tyle: Optional[Union[str, Style]] = None,
 #ustify: Optional[JustifyMethod] = None,
 #moji: Optional[bool] = None,
 #arkup: Optional[bool] = None,
 #ighlight: Optional[bool] = None,
 #og_locals: bool = False,
 #stack_offset: int = 1,
 # -> None:
 #""Log rich content to the terminal.

 #rgs:
 #bjects (positional args): Objects to log to the terminal.
 #ep (str, optional): String to write between print data. Defaults to " ".
 #nd (str, optional): String to write at end of print data. Defaults to "\\\\n".
 #tyle (Union[str, Style], optional): A style to apply to output. Defaults to None.
 #ustify (str, optional): One of "left", "right", "center", or "full". Defaults to ``None``.
 #verflow (str, optional): Overflow method: "crop", "fold", or "ellipsis". Defaults to None.
 #moji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to None.
 #arkup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to None.
 #ighlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to None.
 #og_locals (bool, optional): Boolean to enable logging of locals where ``log()``
 #as called. Defaults to False.
 #stack_offset (int, optional): Offset of caller from end of call stack. Defaults to 1.
 #""
 #f not objects:
 #bjects = (NewLine(),)

 #ender_hooks = self._render_hooks[:]

 #ith self:
 #enderables = self._collect_renderables(
 #bjects,
 #ep,
 #nd,
 #ustify=justify,
 #moji=emoji,
 #arkup=markup,
 #ighlight=highlight,
 #
 #f style is not None:
 #enderables = [Styled(renderable, style) for renderable in renderables]

 #ilename, line_no, locals = self._caller_frame_info(_stack_offset)
 #ink_path = None if filename.startswith("<") else os.path.abspath(filename)
 #ath = filename.rpartition(os.sep)[-1]
 #f log_locals:
 #ocals_map = {
 #ey: value
 #or key, value in locals.items()
 #f not key.startswith("__")
 #
 #enderables.append(render_scope(locals_map, title="[i]locals"))

 #enderables = [
 #elf._log_render(
 #elf,
 #enderables,
 #og_time=self.get_datetime(),
 #ath=path,
 #ine_no=line_no,
 #ink_path=link_path,
 #
 #
 #or hook in render_hooks:
 #enderables = hook.process_renderables(renderables)
 #ew_segments: List[Segment] = []
 #xtend = new_segments.extend
 #ender = self.render
 #ender_options = self.options
 #or renderable in renderables:
 #xtend(render(renderable, render_options))
 #uffer_extend = self._buffer.extend
 #or line in Segment.split_and_crop_lines(
 #ew_segments, self.width, pad=False
 #:
 #uffer_extend(line)

 #ef _check_buffer(self) -> None:
 #""Check if the buffer may be rendered. Render it if it can (e.g. Console.quiet is False)
 #endering is supported on Windows, Unix and Jupyter environments. For
 #egacy Windows consoles, the win32 API is called directly.
 #his method will also record what it renders if recording is enabled via Console.record.
 #""
 #f self.quiet:
 #el self._buffer[:]
 #eturn
 #ith self._lock:
 #f self.record:
 #ith self._record_buffer_lock:
 #elf._record_buffer.extend(self._buffer[:])

 #f self._buffer_index == 0:
 #f self.is_jupyter:  # pragma: no cover
 #rom .jupyter import display

 #isplay(self._buffer, self._render_buffer(self._buffer[:]))
 #el self._buffer[:]
 #lse:
 #f WINDOWS:
 #se_legacy_windows_render = False
 #f self.legacy_windows:
 #ileno = get_fileno(self.file)
 #f fileno is not None:
 #se_legacy_windows_render = (
 #ileno in _STD_STREAMS_OUTPUT
 #

 #f use_legacy_windows_render:
 #rom pip._vendor.rich._win32_console import LegacyWindowsTerm
 #rom pip._vendor.rich._windows_renderer import legacy_windows_render

 #uffer = self._buffer[:]
 #f self.no_color and self._color_system:
 #uffer = list(Segment.remove_color(buffer))

 #egacy_windows_render(buffer, LegacyWindowsTerm(self.file))
 #lse:
                            # Either a non-std stream on legacy Windows, or modern Windows.
 #ext = self._render_buffer(self._buffer[:])
                            # https://bugs.python.org/issue37871
                            # https://github.com/python/cpython/issues/82052
                            # We need to avoid writing more than 32Kb in a single write, due to the above bug
 #rite = self.file.write
                            # Worse case scenario, every character is 4 bytes of utf-8
 #AX_WRITE = 32 * 1024 // 4
 #ry:
 #f len(text) <= MAX_WRITE:
 #rite(text)
 #lse:
 #atch: List[str] = []
 #atch_append = batch.append
 #ize = 0
 #or line in text.splitlines(True):
 #f size + len(line) > MAX_WRITE and batch:
 #rite("".join(batch))
 #atch.clear()
 #ize = 0
 #atch_append(line)
 #ize += len(line)
 #f batch:
 #rite("".join(batch))
 #atch.clear()
 #xcept UnicodeEncodeError as error:
 #rror.reason = f"{error.reason}\n*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***"
 #aise
 #lse:
 #ext = self._render_buffer(self._buffer[:])
 #ry:
 #elf.file.write(text)
 #xcept UnicodeEncodeError as error:
 #rror.reason = f"{error.reason}\n*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***"
 #aise

 #elf.file.flush()
 #el self._buffer[:]

 #ef _render_buffer(self, buffer: Iterable[Segment]) -> str:
 #""Render buffered output, and clear buffer."""
 #utput: List[str] = []
 #ppend = output.append
 #olor_system = self._color_system
 #egacy_windows = self.legacy_windows
 #ot_terminal = not self.is_terminal
 #f self.no_color and color_system:
 #uffer = Segment.remove_color(buffer)
 #or text, style, control in buffer:
 #f style:
 #ppend(
 #tyle.render(
 #ext,
 #olor_system=color_system,
 #egacy_windows=legacy_windows,
 #
 #
 #lif not (not_terminal and control):
 #ppend(text)

 #endered = "".join(output)
 #eturn rendered

 #ef input(
 #elf,
 #rompt: TextType = "",
 #,
 #arkup: bool = True,
 #moji: bool = True,
 #assword: bool = False,
 #tream: Optional[TextIO] = None,
 # -> str:
 #""Displays a prompt and waits for input from the user. The prompt may contain color / style.

 #t works in the same way as Python's builtin :func:`input` function and provides elaborate line editing and history features if Python's builtin :mod:`readline` module is previously loaded.

 #rgs:
 #rompt (Union[str, Text]): Text to render in the prompt.
 #arkup (bool, optional): Enable console markup (requires a str prompt). Defaults to True.
 #moji (bool, optional): Enable emoji (requires a str prompt). Defaults to True.
 #assword: (bool, optional): Hide typed text. Defaults to False.
 #tream: (TextIO, optional): Optional file to read input from (rather than stdin). Defaults to None.

 #eturns:
 #tr: Text read from stdin.
 #""
 #f prompt:
 #elf.print(prompt, markup=markup, emoji=emoji, end="")
 #f password:
 #esult = getpass("", stream=stream)
 #lse:
 #f stream:
 #esult = stream.readline()
 #lse:
 #esult = input()
 #eturn result

 #ef export_text(self, *, clear: bool = True, styles: bool = False) -> str:
 #""Generate text from console contents (requires record=True argument in constructor).

 #rgs:
 #lear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.
 #tyles (bool, optional): If ``True``, ansi escape codes will be included. ``False`` for plain text.
 #efaults to ``False``.

 #eturns:
 #tr: String containing console contents.

 #""
 #ssert (
 #elf.record
 #, "To export console contents set record=True in the constructor or instance"

 #ith self._record_buffer_lock:
 #f styles:
 #ext = "".join(
 #style.render(text) if style else text)
 #or text, style, _ in self._record_buffer
 #
 #lse:
 #ext = "".join(
 #egment.text
 #or segment in self._record_buffer
 #f not segment.control
 #
 #f clear:
 #el self._record_buffer[:]
 #eturn text

 #ef save_text(self, path: str, *, clear: bool = True, styles: bool = False) -> None:
 #""Generate text from console and save to a given location (requires record=True argument in constructor).

 #rgs:
 #ath (str): Path to write text files.
 #lear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.
 #tyles (bool, optional): If ``True``, ansi style codes will be included. ``False`` for plain text.
 #efaults to ``False``.

 #""
 #ext = self.export_text(clear=clear, styles=styles)
 #ith open(path, "wt", encoding="utf-8") as write_file:
 #rite_file.write(text)

 #ef export_html(
 #elf,
 #,
 #heme: Optional[TerminalTheme] = None,
 #lear: bool = True,
 #ode_format: Optional[str] = None,
 #nline_styles: bool = False,
 # -> str:
 #""Generate HTML from console contents (requires record=True argument in constructor).

 #rgs:
 #heme (TerminalTheme, optional): TerminalTheme object containing console colors.
 #lear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.
 #ode_format (str, optional): Format string to render HTML. In addition to '{foreground}',
 #{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.
 #nline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files
 #arger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.
 #efaults to False.

 #eturns:
 #tr: String containing console contents as HTML.
 #""
 #ssert (
 #elf.record
 #, "To export console contents set record=True in the constructor or instance"
 #ragments: List[str] = []
 #ppend = fragments.append
 #theme = theme or DEFAULT_TERMINAL_THEME
 #tylesheet = ""

 #ender_code_format = CONSOLE_HTML_FORMAT if code_format is None else code_format

 #ith self._record_buffer_lock:
 #f inline_styles:
 #or text, style, _ in Segment.filter_control(
 #egment.simplify(self._record_buffer)
 #:
 #ext = escape(text)
 #f style:
 #ule = style.get_html_style(_theme)
 #f style.link:
 #ext = f'<a href="{style.link}">{text}</a>'
 #ext = f'<span style="{rule}">{text}</span>' if rule else text
 #ppend(text)
 #lse:
 #tyles: Dict[str, int] = {}
 #or text, style, _ in Segment.filter_control(
 #egment.simplify(self._record_buffer)
 #:
 #ext = escape(text)
 #f style:
 #ule = style.get_html_style(_theme)
 #tyle_number = styles.setdefault(rule, len(styles) + 1)
 #f style.link:
 #ext = f'<a class="r{style_number}" href="{style.link}">{text}</a>'
 #lse:
 #ext = f'<span class="r{style_number}">{text}</span>'
 #ppend(text)
 #tylesheet_rules: List[str] = []
 #tylesheet_append = stylesheet_rules.append
 #or style_rule, style_number in styles.items():
 #f style_rule:
 #tylesheet_append(f".r{style_number} {{{style_rule}}}")
 #tylesheet = "\n".join(stylesheet_rules)

 #endered_code = render_code_format.format(
 #ode="".join(fragments),
 #tylesheet=stylesheet,
 #oreground=_theme.foreground_color.hex,
 #ackground=_theme.background_color.hex,
 #
 #f clear:
 #el self._record_buffer[:]
 #eturn rendered_code

 #ef save_html(
 #elf,
 #ath: str,
 #,
 #heme: Optional[TerminalTheme] = None,
 #lear: bool = True,
 #ode_format: str = CONSOLE_HTML_FORMAT,
 #nline_styles: bool = False,
 # -> None:
 #""Generate HTML from console contents and write to a file (requires record=True argument in constructor).

 #rgs:
 #ath (str): Path to write html file.
 #heme (TerminalTheme, optional): TerminalTheme object containing console colors.
 #lear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.
 #ode_format (str, optional): Format string to render HTML. In addition to '{foreground}',
 #{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.
 #nline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files
 #arger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.
 #efaults to False.

 #""
 #tml = self.export_html(
 #heme=theme,
 #lear=clear,
 #ode_format=code_format,
 #nline_styles=inline_styles,
 #
 #ith open(path, "wt", encoding="utf-8") as write_file:
 #rite_file.write(html)

 #ef export_svg(
 #elf,
 #,
 #itle: str = "Rich",
 #heme: Optional[TerminalTheme] = None,
 #lear: bool = True,
 #ode_format: str = CONSOLE_SVG_FORMAT,
 #ont_aspect_ratio: float = 0.61,
 #nique_id: Optional[str] = None,
 # -> str:
 #""
 #enerate an SVG from the console contents (requires record=True in Console constructor).

 #rgs:
 #itle (str, optional): The title of the tab in the output image
 #heme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal
 #lear (bool, optional): Clear record buffer after exporting. Defaults to ``True``
 #ode_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables
 #nto the string in order to form the final SVG output. The default template used and the variables
 #njected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.
 #ont_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``
 #tring. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).
 #f you aren't specifying a different font inside ``code_format``, you probably don't need this.
 #nique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node
 #ds). If not set, this defaults to a computed value based on the recorded content.
 #""

 #rom pip._vendor.rich.cells import cell_len

 #tyle_cache: Dict[Style, str] = {}

 #ef get_svg_style(style: Style) -> str:
 #""Convert a Style to CSS rules for SVG."""
 #f style in style_cache:
 #eturn style_cache[style]
 #ss_rules = []
 #olor = (
 #theme.foreground_color
 #f (style.color is None or style.color.is_default)
 #lse style.color.get_truecolor(_theme)
 #
 #gcolor = (
 #theme.background_color
 #f (style.bgcolor is None or style.bgcolor.is_default)
 #lse style.bgcolor.get_truecolor(_theme)
 #
 #f style.reverse:
 #olor, bgcolor = bgcolor, color
 #f style.dim:
 #olor = blend_rgb(color, bgcolor, 0.4)
 #ss_rules.append(f"fill: {color.hex}")
 #f style.bold:
 #ss_rules.append("font-weight: bold")
 #f style.italic:
 #ss_rules.append("font-style: italic;")
 #f style.underline:
 #ss_rules.append("text-decoration: underline;")
 #f style.strike:
 #ss_rules.append("text-decoration: line-through;")

 #ss = ";".join(css_rules)
 #tyle_cache[style] = css
 #eturn css

 #theme = theme or SVG_EXPORT_THEME

 #idth = self.width
 #har_height = 20
 #har_width = char_height * font_aspect_ratio
 #ine_height = char_height * 1.22

 #argin_top = 1
 #argin_right = 1
 #argin_bottom = 1
 #argin_left = 1

 #adding_top = 40
 #adding_right = 8
 #adding_bottom = 8
 #adding_left = 8

 #adding_width = padding_left + padding_right
 #adding_height = padding_top + padding_bottom
 #argin_width = margin_left + margin_right
 #argin_height = margin_top + margin_bottom

 #ext_backgrounds: List[str] = []
 #ext_group: List[str] = []
 #lasses: Dict[str, int] = {}
 #tyle_no = 1

 #ef escape_text(text: str) -> str:
 #""HTML escape text and replace spaces with nbsp."""
 #eturn escape(text).replace(" ", "&#160;")

 #ef make_tag(
 #ame: str, content: Optional[str] = None, **attribs: object
 # -> str:
 #""Make a tag from name, content, and attributes."""

 #ef stringify(value: object) -> str:
 #f isinstance(value, (float)):
 #eturn format(value, "g")
 #eturn str(value)

 #ag_attribs = " ".join(
 #'{k.lstrip("_").replace("_", "-")}="{stringify(v)}"'
 #or k, v in attribs.items()
 #
 #eturn (
 #"<{name} {tag_attribs}>{content}</{name}>"
 #f content
 #lse f"<{name} {tag_attribs}/>"
 #

 #ith self._record_buffer_lock:
 #egments = list(Segment.filter_control(self._record_buffer))
 #f clear:
 #elf._record_buffer.clear()

 #f unique_id is None:
 #nique_id = "terminal-" + str(
 #lib.adler32(
 #"".join(repr(segment) for segment in segments)).encode(
 #utf-8",
 #ignore",
 #
 # title.encode("utf-8", "ignore")
 #
 #
 # = 0
 #or y, line in enumerate(Segment.split_and_crop_lines(segments, length=width)):
 # = 0
 #or text, style, _control in line:
 #tyle = style or Style()
 #ules = get_svg_style(style)
 #f rules not in classes:
 #lasses[rules] = style_no
 #tyle_no += 1
 #lass_name = f"r{classes[rules]}"

 #f style.reverse:
 #as_background = True
 #ackground = (
 #theme.foreground_color.hex
 #f style.color is None
 #lse style.color.get_truecolor(_theme).hex
 #
 #lse:
 #gcolor = style.bgcolor
 #as_background = bgcolor is not None and not bgcolor.is_default
 #ackground = (
 #theme.background_color.hex
 #f style.bgcolor is None
 #lse style.bgcolor.get_truecolor(_theme).hex
 #

 #ext_length = cell_len(text)
 #f has_background:
 #ext_backgrounds.append(
 #ake_tag(
 #rect",
 #ill=background,
 #=x * char_width,
 #=y * line_height + 1.5,
 #idth=char_width * text_length,
 #eight=line_height + 0.25,
 #hape_rendering="crispEdges",
 #
 #

 #f text != " " * len(text):
 #ext_group.append(
 #ake_tag(
 #text",
 #scape_text(text),
 #class=f"{unique_id}-{class_name}",
 #=x * char_width,
 #=y * line_height + char_height,
 #extLength=char_width * len(text),
 #lip_path=f"url(#{unique_id}-line-{y})",
 #
 #
 # += cell_len(text)

 #ine_offsets = [line_no * line_height + 1.5 for line_no in range(y)]
 #ines = "\n".join(
 #"""<clipPath id="{unique_id}-line-{line_no}">
 #make_tag("rect", x=0, y=offset, width=char_width * width, height=line_height + 0.25)}
 #/clipPath>"""
 #or line_no, offset in enumerate(line_offsets)
 #

 #tyles = "\n".join(
 #".{unique_id}-r{rule_no} {{ {css} }}" for css, rule_no in classes.items()
 #
 #ackgrounds = "".join(text_backgrounds)
 #atrix = "".join(text_group)

 #erminal_width = ceil(width * char_width + padding_width)
 #erminal_height = (y + 1) * line_height + padding_height
 #hrome = make_tag(
 #rect",
 #ill=_theme.background_color.hex,
 #troke="rgba(255,255,255,0.35)",
 #troke_width="1",
 #=margin_left,
 #=margin_top,
 #idth=terminal_width,
 #eight=terminal_height,
 #x=8,
 #

 #itle_color = _theme.foreground_color.hex
 #f title:
 #hrome += make_tag(
 #text",
 #scape_text(title),
 #class=f"{unique_id}-title",
 #ill=title_color,
 #ext_anchor="middle",
 #=terminal_width // 2,
 #=margin_top + char_height + 6,
 #
 #hrome += f"""
 #g transform="translate(26,22)">
 #circle cx="0" cy="0" r="7" fill="#ff5f57"/>
 #circle cx="22" cy="0" r="7" fill="#febc2e"/>
 #circle cx="44" cy="0" r="7" fill="#28c840"/>
 #/g>
 #""

 #vg = code_format.format(
 #nique_id=unique_id,
 #har_width=char_width,
 #har_height=char_height,
 #ine_height=line_height,
 #erminal_width=char_width * width - 1,
 #erminal_height=(y + 1) * line_height - 1,
 #idth=terminal_width + margin_width,
 #eight=terminal_height + margin_height,
 #erminal_x=margin_left + padding_left,
 #erminal_y=margin_top + padding_top,
 #tyles=styles,
 #hrome=chrome,
 #ackgrounds=backgrounds,
 #atrix=matrix,
 #ines=lines,
 #
 #eturn svg

 #ef save_svg(
 #elf,
 #ath: str,
 #,
 #itle: str = "Rich",
 #heme: Optional[TerminalTheme] = None,
 #lear: bool = True,
 #ode_format: str = CONSOLE_SVG_FORMAT,
 #ont_aspect_ratio: float = 0.61,
 #nique_id: Optional[str] = None,
 # -> None:
 #""Generate an SVG file from the console contents (requires record=True in Console constructor).

 #rgs:
 #ath (str): The path to write the SVG to.
 #itle (str, optional): The title of the tab in the output image
 #heme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal
 #lear (bool, optional): Clear record buffer after exporting. Defaults to ``True``
 #ode_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables
 #nto the string in order to form the final SVG output. The default template used and the variables
 #njected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.
 #ont_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``
 #tring. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).
 #f you aren't specifying a different font inside ``code_format``, you probably don't need this.
 #nique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node
 #ds). If not set, this defaults to a computed value based on the recorded content.
 #""
 #vg = self.export_svg(
 #itle=title,
 #heme=theme,
 #lear=clear,
 #ode_format=code_format,
 #ont_aspect_ratio=font_aspect_ratio,
 #nique_id=unique_id,
 #
 #ith open(path, "wt", encoding="utf-8") as write_file:
 #rite_file.write(svg)


def _svg_hash(svg_main_code: str) -> str:
 #""Returns a unique hash for the given SVG main code.

 #rgs:
 #vg_main_code (str): The content we're going to inject in the SVG envelope.

 #eturns:
 #tr: a hash of the given content
 #""
 #eturn str(zlib.adler32(svg_main_code.encode()))


if __name__ == "__main__":  # pragma: no cover
 #onsole = Console(record=True)

 #onsole.log(
 #JSONRPC [i]request[/i]",
 #,
 #.3,
 #rue,
 #alse,
 #one,
 #
 #jsonrpc": "2.0",
 #method": "subtract",
 #params": {"minuend": 42, "subtrahend": 23},
 #id": 3,
 #,
 #

 #onsole.log("Hello, World!", "{'a': 1}", repr(console))

 #onsole.print(
 #
 #name": None,
 #empty": [],
 #quiz": {
 #sport": {
 #answered": True,
 #q1": {
 #question": "Which one is correct team name in NBA?",
 #options": [
 #New York Bulls",
 #Los Angeles Kings",
 #Golden State Warriors",
 #Huston Rocket",
 #,
 #answer": "Huston Rocket",
 #,
 #,
 #maths": {
 #answered": False,
 #q1": {
 #question": "5 + 7 = ?",
 #options": [10, 11, 12, 13],
 #answer": 12,
 #,
 #q2": {
 #question": "12 - 8 = ?",
 #options": [1, 2, 3, 4],
 #answer": 4,
 #,
 #,
 #,
 #
 #
