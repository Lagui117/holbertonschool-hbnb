from typing import Optional, Union

from .color import Color
from .console import Console, ConsoleOptions, RenderResult
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment
from .style import Style

# There are left-aligned characters for 1/8 to 7/8, but
# the right-aligned characters exist only for 1/8 and 4/8.
BEGIN_BLOCK_ELEMENTS = ["█", "█", "█", "▐", "▐", "▐", "▕", "▕"]
END_BLOCK_ELEMENTS = [" ", "▏", "▎", "▍", "▌", "▋", "▊", "▉"]
FULL_BLOCK = "█"


class Bar(JupyterMixin):
 #""Renders a solid block bar.

 #rgs:
 #ize (float): Value for the end of the bar.
 #egin (float): Begin point (between 0 and size, inclusive).
 #nd (float): End point (between 0 and size, inclusive).
 #idth (int, optional): Width of the bar, or ``None`` for maximum width. Defaults to None.
 #olor (Union[Color, str], optional): Color of the bar. Defaults to "default".
 #gcolor (Union[Color, str], optional): Color of bar background. Defaults to "default".
 #""

 #ef __init__(
 #elf,
 #ize: float,
 #egin: float,
 #nd: float,
 #,
 #idth: Optional[int] = None,
 #olor: Union[Color, str] = "default",
 #gcolor: Union[Color, str] = "default",
 #:
 #elf.size = size
 #elf.begin = max(begin, 0)
 #elf.end = min(end, size)
 #elf.width = width
 #elf.style = Style(color=color, bgcolor=bgcolor)

 #ef __repr__(self) -> str:
 #eturn f"Bar({self.size}, {self.begin}, {self.end})"

 #ef __rich_console__(
 #elf, console: Console, options: ConsoleOptions
 # -> RenderResult:

 #idth = min(
 #elf.width if self.width is not None else options.max_width,
 #ptions.max_width,
 #

 #f self.begin >= self.end:
 #ield Segment(" " * width, self.style)
 #ield Segment.line()
 #eturn

 #refix_complete_eights = int(width * 8 * self.begin / self.size)
 #refix_bar_count = prefix_complete_eights // 8
 #refix_eights_count = prefix_complete_eights % 8

 #ody_complete_eights = int(width * 8 * self.end / self.size)
 #ody_bar_count = body_complete_eights // 8
 #ody_eights_count = body_complete_eights % 8

        # When start and end fall into the same cell, we ideally should render
        # a symbol that's "center-aligned", but there is no good symbol in Unicode.
        # In this case, we fall back to right-aligned block symbol for simplicity.

 #refix = " " * prefix_bar_count
 #f prefix_eights_count:
 #refix += BEGIN_BLOCK_ELEMENTS[prefix_eights_count]

 #ody = FULL_BLOCK * body_bar_count
 #f body_eights_count:
 #ody += END_BLOCK_ELEMENTS[body_eights_count]

 #uffix = " " * (width - len(body))

 #ield Segment(prefix + body[len(prefix) :] + suffix, self.style)
 #ield Segment.line()

 #ef __rich_measure__(
 #elf, console: Console, options: ConsoleOptions
 # -> Measurement:
 #eturn (
 #easurement(self.width, self.width)
 #f self.width is not None
 #lse Measurement(4, options.max_width)
 #
