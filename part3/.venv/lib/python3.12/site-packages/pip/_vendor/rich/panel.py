from typing import TYPE_CHECKING, Optional

from .align import AlignMethod
from .box import ROUNDED, Box
from .cells import cell_len
from .jupyter import JupyterMixin
from .measure import Measurement, measure_renderables
from .padding import Padding, PaddingDimensions
from .segment import Segment
from .style import Style, StyleType
from .text import Text, TextType

if TYPE_CHECKING:
 #rom .console import Console, ConsoleOptions, RenderableType, RenderResult


class Panel(JupyterMixin):
 #""A console renderable that draws a border around its contents.

 #xample:
 #>> console.print(Panel("Hello, World!"))

 #rgs:
 #enderable (RenderableType): A console renderable object.
 #ox (Box, optional): A Box instance that defines the look of the border (see :ref:`appendix_box`.
 #efaults to box.ROUNDED.
 #afe_box (bool, optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.
 #xpand (bool, optional): If True the panel will stretch to fill the console
 #idth, otherwise it will be sized to fit the contents. Defaults to True.
 #tyle (str, optional): The style of the panel (border and contents). Defaults to "none".
 #order_style (str, optional): The style of the border. Defaults to "none".
 #idth (Optional[int], optional): Optional width of panel. Defaults to None to auto-detect.
 #eight (Optional[int], optional): Optional height of panel. Defaults to None to auto-detect.
 #adding (Optional[PaddingDimensions]): Optional padding around renderable. Defaults to 0.
 #ighlight (bool, optional): Enable automatic highlighting of panel title (if str). Defaults to False.
 #""

 #ef __init__(
 #elf,
 #enderable: "RenderableType",
 #ox: Box = ROUNDED,
 #,
 #itle: Optional[TextType] = None,
 #itle_align: AlignMethod = "center",
 #ubtitle: Optional[TextType] = None,
 #ubtitle_align: AlignMethod = "center",
 #afe_box: Optional[bool] = None,
 #xpand: bool = True,
 #tyle: StyleType = "none",
 #order_style: StyleType = "none",
 #idth: Optional[int] = None,
 #eight: Optional[int] = None,
 #adding: PaddingDimensions = (0, 1),
 #ighlight: bool = False,
 # -> None:
 #elf.renderable = renderable
 #elf.box = box
 #elf.title = title
 #elf.title_align: AlignMethod = title_align
 #elf.subtitle = subtitle
 #elf.subtitle_align = subtitle_align
 #elf.safe_box = safe_box
 #elf.expand = expand
 #elf.style = style
 #elf.border_style = border_style
 #elf.width = width
 #elf.height = height
 #elf.padding = padding
 #elf.highlight = highlight

 #classmethod
 #ef fit(
 #ls,
 #enderable: "RenderableType",
 #ox: Box = ROUNDED,
 #,
 #itle: Optional[TextType] = None,
 #itle_align: AlignMethod = "center",
 #ubtitle: Optional[TextType] = None,
 #ubtitle_align: AlignMethod = "center",
 #afe_box: Optional[bool] = None,
 #tyle: StyleType = "none",
 #order_style: StyleType = "none",
 #idth: Optional[int] = None,
 #adding: PaddingDimensions = (0, 1),
 # -> "Panel":
 #""An alternative constructor that sets expand=False."""
 #eturn cls(
 #enderable,
 #ox,
 #itle=title,
 #itle_align=title_align,
 #ubtitle=subtitle,
 #ubtitle_align=subtitle_align,
 #afe_box=safe_box,
 #tyle=style,
 #order_style=border_style,
 #idth=width,
 #adding=padding,
 #xpand=False,
 #

 #property
 #ef _title(self) -> Optional[Text]:
 #f self.title:
 #itle_text = (
 #ext.from_markup(self.title)
 #f isinstance(self.title, str)
 #lse self.title.copy()
 #
 #itle_text.end = ""
 #itle_text.plain = title_text.plain.replace("\n", " ")
 #itle_text.no_wrap = True
 #itle_text.expand_tabs()
 #itle_text.pad(1)
 #eturn title_text
 #eturn None

 #property
 #ef _subtitle(self) -> Optional[Text]:
 #f self.subtitle:
 #ubtitle_text = (
 #ext.from_markup(self.subtitle)
 #f isinstance(self.subtitle, str)
 #lse self.subtitle.copy()
 #
 #ubtitle_text.end = ""
 #ubtitle_text.plain = subtitle_text.plain.replace("\n", " ")
 #ubtitle_text.no_wrap = True
 #ubtitle_text.expand_tabs()
 #ubtitle_text.pad(1)
 #eturn subtitle_text
 #eturn None

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "RenderResult":
 #padding = Padding.unpack(self.padding)
 #enderable = (
 #adding(self.renderable, _padding) if any(_padding) else self.renderable
 #
 #tyle = console.get_style(self.style)
 #order_style = style + console.get_style(self.border_style)
 #idth = (
 #ptions.max_width
 #f self.width is None
 #lse min(options.max_width, self.width)
 #

 #afe_box: bool = console.safe_box if self.safe_box is None else self.safe_box
 #ox = self.box.substitute(options, safe=safe_box)

 #ef align_text(
 #ext: Text, width: int, align: str, character: str, style: Style
 # -> Text:
 #""Gets new aligned text.

 #rgs:
 #ext (Text): Title or subtitle text.
 #idth (int): Desired width.
 #lign (str): Alignment.
 #haracter (str): Character for alignment.
 #tyle (Style): Border style

 #eturns:
 #ext: New text instance
 #""
 #ext = text.copy()
 #ext.truncate(width)
 #xcess_space = width - cell_len(text.plain)
 #f excess_space:
 #f align == "left":
 #eturn Text.assemble(
 #ext,
 #character * excess_space, style),
 #o_wrap=True,
 #nd="",
 #
 #lif align == "center":
 #eft = excess_space // 2
 #eturn Text.assemble(
 #character * left, style),
 #ext,
 #character * (excess_space - left), style),
 #o_wrap=True,
 #nd="",
 #
 #lse:
 #eturn Text.assemble(
 #character * excess_space, style),
 #ext,
 #o_wrap=True,
 #nd="",
 #
 #eturn text

 #itle_text = self._title
 #f title_text is not None:
 #itle_text.stylize_before(border_style)

 #hild_width = (
 #idth - 2
 #f self.expand
 #lse console.measure(
 #enderable, options=options.update_width(width - 2)
 #.maximum
 #
 #hild_height = self.height or options.height or None
 #f child_height:
 #hild_height -= 2
 #f title_text is not None:
 #hild_width = min(
 #ptions.max_width - 2, max(child_width, title_text.cell_len + 2)
 #

 #idth = child_width + 2
 #hild_options = options.update(
 #idth=child_width, height=child_height, highlight=self.highlight
 #
 #ines = console.render_lines(renderable, child_options, style=style)

 #ine_start = Segment(box.mid_left, border_style)
 #ine_end = Segment(f"{box.mid_right}", border_style)
 #ew_line = Segment.line()
 #f title_text is None or width <= 4:
 #ield Segment(box.get_top([width - 2]), border_style)
 #lse:
 #itle_text = align_text(
 #itle_text,
 #idth - 4,
 #elf.title_align,
 #ox.top,
 #order_style,
 #
 #ield Segment(box.top_left + box.top, border_style)
 #ield from console.render(title_text, child_options.update_width(width - 4))
 #ield Segment(box.top + box.top_right, border_style)

 #ield new_line
 #or line in lines:
 #ield line_start
 #ield from line
 #ield line_end
 #ield new_line

 #ubtitle_text = self._subtitle
 #f subtitle_text is not None:
 #ubtitle_text.stylize_before(border_style)

 #f subtitle_text is None or width <= 4:
 #ield Segment(box.get_bottom([width - 2]), border_style)
 #lse:
 #ubtitle_text = align_text(
 #ubtitle_text,
 #idth - 4,
 #elf.subtitle_align,
 #ox.bottom,
 #order_style,
 #
 #ield Segment(box.bottom_left + box.bottom, border_style)
 #ield from console.render(
 #ubtitle_text, child_options.update_width(width - 4)
 #
 #ield Segment(box.bottom + box.bottom_right, border_style)

 #ield new_line

 #ef __rich_measure__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "Measurement":
 #title = self._title
 #, right, _, left = Padding.unpack(self.padding)
 #adding = left + right
 #enderables = [self.renderable, _title] if _title else [self.renderable]

 #f self.width is None:
 #idth = (
 #easure_renderables(
 #onsole,
 #ptions.update_width(options.max_width - padding - 2),
 #enderables,
 #.maximum
 # padding
 # 2
 #
 #lse:
 #idth = self.width
 #eturn Measurement(width, width)


if __name__ == "__main__":  # pragma: no cover
 #rom .console import Console

 # = Console()

 #rom .box import DOUBLE, ROUNDED
 #rom .padding import Padding

 # = Panel(
 #Hello, World!",
 #itle="rich.Panel",
 #tyle="white on blue",
 #ox=DOUBLE,
 #adding=1,
 #

 #.print()
 #.print(p)
