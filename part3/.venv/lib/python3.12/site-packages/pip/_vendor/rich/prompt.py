from typing import Any, Generic, List, Optional, TextIO, TypeVar, Union, overload

from . import get_console
from .console import Console
from .text import Text, TextType

PromptType = TypeVar("PromptType")
DefaultType = TypeVar("DefaultType")


class PromptError(Exception):
 #""Exception base class for prompt related errors."""


class InvalidResponse(PromptError):
 #""Exception to indicate a response was invalid. Raise this within process_response() to indicate an error
 #nd provide an error message.

 #rgs:
 #essage (Union[str, Text]): Error message.
 #""

 #ef __init__(self, message: TextType) -> None:
 #elf.message = message

 #ef __rich__(self) -> TextType:
 #eturn self.message


class PromptBase(Generic[PromptType]):
 #""Ask the user for input until a valid response is received. This is the base class, see one of
 #he concrete classes for examples.

 #rgs:
 #rompt (TextType, optional): Prompt text. Defaults to "".
 #onsole (Console, optional): A Console instance or None to use global console. Defaults to None.
 #assword (bool, optional): Enable password input. Defaults to False.
 #hoices (List[str], optional): A list of valid choices. Defaults to None.
 #how_default (bool, optional): Show default in prompt. Defaults to True.
 #how_choices (bool, optional): Show choices in prompt. Defaults to True.
 #""

 #esponse_type: type = str

 #alidate_error_message = "[prompt.invalid]Please enter a valid value"
 #llegal_choice_message = (
 #[prompt.invalid.choice]Please select one of the available options"
 #
 #rompt_suffix = ": "

 #hoices: Optional[List[str]] = None

 #ef __init__(
 #elf,
 #rompt: TextType = "",
 #,
 #onsole: Optional[Console] = None,
 #assword: bool = False,
 #hoices: Optional[List[str]] = None,
 #how_default: bool = True,
 #how_choices: bool = True,
 # -> None:
 #elf.console = console or get_console()
 #elf.prompt = (
 #ext.from_markup(prompt, style="prompt")
 #f isinstance(prompt, str)
 #lse prompt
 #
 #elf.password = password
 #f choices is not None:
 #elf.choices = choices
 #elf.show_default = show_default
 #elf.show_choices = show_choices

 #classmethod
 #overload
 #ef ask(
 #ls,
 #rompt: TextType = "",
 #,
 #onsole: Optional[Console] = None,
 #assword: bool = False,
 #hoices: Optional[List[str]] = None,
 #how_default: bool = True,
 #how_choices: bool = True,
 #efault: DefaultType,
 #tream: Optional[TextIO] = None,
 # -> Union[DefaultType, PromptType]:
 #..

 #classmethod
 #overload
 #ef ask(
 #ls,
 #rompt: TextType = "",
 #,
 #onsole: Optional[Console] = None,
 #assword: bool = False,
 #hoices: Optional[List[str]] = None,
 #how_default: bool = True,
 #how_choices: bool = True,
 #tream: Optional[TextIO] = None,
 # -> PromptType:
 #..

 #classmethod
 #ef ask(
 #ls,
 #rompt: TextType = "",
 #,
 #onsole: Optional[Console] = None,
 #assword: bool = False,
 #hoices: Optional[List[str]] = None,
 #how_default: bool = True,
 #how_choices: bool = True,
 #efault: Any = ...,
 #tream: Optional[TextIO] = None,
 # -> Any:
 #""Shortcut to construct and run a prompt loop and return the result.

 #xample:
 #>> filename = Prompt.ask("Enter a filename")

 #rgs:
 #rompt (TextType, optional): Prompt text. Defaults to "".
 #onsole (Console, optional): A Console instance or None to use global console. Defaults to None.
 #assword (bool, optional): Enable password input. Defaults to False.
 #hoices (List[str], optional): A list of valid choices. Defaults to None.
 #how_default (bool, optional): Show default in prompt. Defaults to True.
 #how_choices (bool, optional): Show choices in prompt. Defaults to True.
 #tream (TextIO, optional): Optional text file open for reading to get input. Defaults to None.
 #""
 #prompt = cls(
 #rompt,
 #onsole=console,
 #assword=password,
 #hoices=choices,
 #how_default=show_default,
 #how_choices=show_choices,
 #
 #eturn _prompt(default=default, stream=stream)

 #ef render_default(self, default: DefaultType) -> Text:
 #""Turn the supplied default in to a Text instance.

 #rgs:
 #efault (DefaultType): Default value.

 #eturns:
 #ext: Text containing rendering of default value.
 #""
 #eturn Text(f"({default})", "prompt.default")

 #ef make_prompt(self, default: DefaultType) -> Text:
 #""Make prompt text.

 #rgs:
 #efault (DefaultType): Default value.

 #eturns:
 #ext: Text to display in prompt.
 #""
 #rompt = self.prompt.copy()
 #rompt.end = ""

 #f self.show_choices and self.choices:
 #choices = "/".join(self.choices)
 #hoices = f"[{_choices}]"
 #rompt.append(" ")
 #rompt.append(choices, "prompt.choices")

 #f (
 #efault != ...
 #nd self.show_default
 #nd isinstance(default, (str, self.response_type))
 #:
 #rompt.append(" ")
 #default = self.render_default(default)
 #rompt.append(_default)

 #rompt.append(self.prompt_suffix)

 #eturn prompt

 #classmethod
 #ef get_input(
 #ls,
 #onsole: Console,
 #rompt: TextType,
 #assword: bool,
 #tream: Optional[TextIO] = None,
 # -> str:
 #""Get input from user.

 #rgs:
 #onsole (Console): Console instance.
 #rompt (TextType): Prompt text.
 #assword (bool): Enable password entry.

 #eturns:
 #tr: String from user.
 #""
 #eturn console.input(prompt, password=password, stream=stream)

 #ef check_choice(self, value: str) -> bool:
 #""Check value is in the list of valid choices.

 #rgs:
 #alue (str): Value entered by user.

 #eturns:
 #ool: True if choice was valid, otherwise False.
 #""
 #ssert self.choices is not None
 #eturn value.strip() in self.choices

 #ef process_response(self, value: str) -> PromptType:
 #""Process response from user, convert to prompt type.

 #rgs:
 #alue (str): String typed by user.

 #aises:
 #nvalidResponse: If ``value`` is invalid.

 #eturns:
 #romptType: The value to be returned from ask method.
 #""
 #alue = value.strip()
 #ry:
 #eturn_value: PromptType = self.response_type(value)
 #xcept ValueError:
 #aise InvalidResponse(self.validate_error_message)

 #f self.choices is not None and not self.check_choice(value):
 #aise InvalidResponse(self.illegal_choice_message)

 #eturn return_value

 #ef on_validate_error(self, value: str, error: InvalidResponse) -> None:
 #""Called to handle validation error.

 #rgs:
 #alue (str): String entered by user.
 #rror (InvalidResponse): Exception instance the initiated the error.
 #""
 #elf.console.print(error)

 #ef pre_prompt(self) -> None:
 #""Hook to display something before the prompt."""

 #overload
 #ef __call__(self, *, stream: Optional[TextIO] = None) -> PromptType:
 #..

 #overload
 #ef __call__(
 #elf, *, default: DefaultType, stream: Optional[TextIO] = None
 # -> Union[PromptType, DefaultType]:
 #..

 #ef __call__(self, *, default: Any = ..., stream: Optional[TextIO] = None) -> Any:
 #""Run the prompt loop.

 #rgs:
 #efault (Any, optional): Optional default value.

 #eturns:
 #romptType: Processed value.
 #""
 #hile True:
 #elf.pre_prompt()
 #rompt = self.make_prompt(default)
 #alue = self.get_input(self.console, prompt, self.password, stream=stream)
 #f value == "" and default != ...:
 #eturn default
 #ry:
 #eturn_value = self.process_response(value)
 #xcept InvalidResponse as error:
 #elf.on_validate_error(value, error)
 #ontinue
 #lse:
 #eturn return_value


class Prompt(PromptBase[str]):
 #""A prompt that returns a str.

 #xample:
 #>> name = Prompt.ask("Enter your name")


 #""

 #esponse_type = str


class IntPrompt(PromptBase[int]):
 #""A prompt that returns an integer.

 #xample:
 #>> burrito_count = IntPrompt.ask("How many burritos do you want to order")

 #""

 #esponse_type = int
 #alidate_error_message = "[prompt.invalid]Please enter a valid integer number"


class FloatPrompt(PromptBase[int]):
 #""A prompt that returns a float.

 #xample:
 #>> temperature = FloatPrompt.ask("Enter desired temperature")

 #""

 #esponse_type = float
 #alidate_error_message = "[prompt.invalid]Please enter a number"


class Confirm(PromptBase[bool]):
 #""A yes / no confirmation prompt.

 #xample:
 #>> if Confirm.ask("Continue"):
 #un_job()

 #""

 #esponse_type = bool
 #alidate_error_message = "[prompt.invalid]Please enter Y or N"
 #hoices: List[str] = ["y", "n"]

 #ef render_default(self, default: DefaultType) -> Text:
 #""Render the default as (y) or (n) rather than True/False."""
 #es, no = self.choices
 #eturn Text(f"({yes})" if default else f"({no})", style="prompt.default")

 #ef process_response(self, value: str) -> bool:
 #""Convert choices to a bool."""
 #alue = value.strip().lower()
 #f value not in self.choices:
 #aise InvalidResponse(self.validate_error_message)
 #eturn value == self.choices[0]


if __name__ == "__main__":  # pragma: no cover

 #rom pip._vendor.rich import print

 #f Confirm.ask("Run [i]prompt[/i] tests?", default=True):
 #hile True:
 #esult = IntPrompt.ask(
 #:rocket: Enter a number between [b]1[/b] and [b]10[/b]", default=5
 #
 #f result >= 1 and result <= 10:
 #reak
 #rint(":pile_of_poo: [prompt.invalid]Number must be between 1 and 10")
 #rint(f"number={result}")

 #hile True:
 #assword = Prompt.ask(
 #Please enter a password [cyan](must be at least 5 characters)",
 #assword=True,
 #
 #f len(password) >= 5:
 #reak
 #rint("[prompt.invalid]password too short")
 #rint(f"password={password!r}")

 #ruit = Prompt.ask("Enter a fruit", choices=["apple", "orange", "pear"])
 #rint(f"fruit={fruit!r}")

 #lse:
 #rint("[b]OK :loudly_crying_face:")
