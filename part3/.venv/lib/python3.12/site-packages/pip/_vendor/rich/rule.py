from typing import Union

from .align import AlignMethod
from .cells import cell_len, set_cell_size
from .console import Console, ConsoleOptions, RenderResult
from .jupyter import JupyterMixin
from .measure import Measurement
from .style import Style
from .text import Text


class Rule(JupyterMixin):
 #""A console renderable to draw a horizontal rule (line).

 #rgs:
 #itle (Union[str, Text], optional): Text to render in the rule. Defaults to "".
 #haracters (str, optional): Character(s) used to draw the line. Defaults to "─".
 #tyle (StyleType, optional): Style of Rule. Defaults to "rule.line".
 #nd (str, optional): Character at end of Rule. defaults to "\\\\n"
 #lign (str, optional): How to align the title, one of "left", "center", or "right". Defaults to "center".
 #""

 #ef __init__(
 #elf,
 #itle: Union[str, Text] = "",
 #,
 #haracters: str = "─",
 #tyle: Union[str, Style] = "rule.line",
 #nd: str = "\n",
 #lign: AlignMethod = "center",
 # -> None:
 #f cell_len(characters) < 1:
 #aise ValueError(
 #'characters' argument must have a cell width of at least 1"
 #
 #f align not in ("left", "center", "right"):
 #aise ValueError(
 #'invalid value for align, expected "left", "center", "right" (not {align!r})'
 #
 #elf.title = title
 #elf.characters = characters
 #elf.style = style
 #elf.end = end
 #elf.align = align

 #ef __repr__(self) -> str:
 #eturn f"Rule({self.title!r}, {self.characters!r})"

 #ef __rich_console__(
 #elf, console: Console, options: ConsoleOptions
 # -> RenderResult:
 #idth = options.max_width

 #haracters = (
 #-"
 #f (options.ascii_only and not self.characters.isascii())
 #lse self.characters
 #

 #hars_len = cell_len(characters)
 #f not self.title:
 #ield self._rule_line(chars_len, width)
 #eturn

 #f isinstance(self.title, Text):
 #itle_text = self.title
 #lse:
 #itle_text = console.render_str(self.title, style="rule.text")

 #itle_text.plain = title_text.plain.replace("\n", " ")
 #itle_text.expand_tabs()

 #equired_space = 4 if self.align == "center" else 2
 #runcate_width = max(0, width - required_space)
 #f not truncate_width:
 #ield self._rule_line(chars_len, width)
 #eturn

 #ule_text = Text(end=self.end)
 #f self.align == "center":
 #itle_text.truncate(truncate_width, overflow="ellipsis")
 #ide_width = (width - cell_len(title_text.plain)) // 2
 #eft = Text(characters * (side_width // chars_len + 1))
 #eft.truncate(side_width - 1)
 #ight_length = width - cell_len(left.plain) - cell_len(title_text.plain)
 #ight = Text(characters * (side_width // chars_len + 1))
 #ight.truncate(right_length)
 #ule_text.append(left.plain + " ", self.style)
 #ule_text.append(title_text)
 #ule_text.append(" " + right.plain, self.style)
 #lif self.align == "left":
 #itle_text.truncate(truncate_width, overflow="ellipsis")
 #ule_text.append(title_text)
 #ule_text.append(" ")
 #ule_text.append(characters * (width - rule_text.cell_len), self.style)
 #lif self.align == "right":
 #itle_text.truncate(truncate_width, overflow="ellipsis")
 #ule_text.append(characters * (width - title_text.cell_len - 1), self.style)
 #ule_text.append(" ")
 #ule_text.append(title_text)

 #ule_text.plain = set_cell_size(rule_text.plain, width)
 #ield rule_text

 #ef _rule_line(self, chars_len: int, width: int) -> Text:
 #ule_text = Text(self.characters * ((width // chars_len) + 1), self.style)
 #ule_text.truncate(width)
 #ule_text.plain = set_cell_size(rule_text.plain, width)
 #eturn rule_text

 #ef __rich_measure__(
 #elf, console: Console, options: ConsoleOptions
 # -> Measurement:
 #eturn Measurement(1, 1)


if __name__ == "__main__":  # pragma: no cover
 #mport sys

 #rom pip._vendor.rich.console import Console

 #ry:
 #ext = sys.argv[1]
 #xcept IndexError:
 #ext = "Hello, World"
 #onsole = Console()
 #onsole.print(Rule(title=text))

 #onsole = Console()
 #onsole.print(Rule("foo"), width=4)
