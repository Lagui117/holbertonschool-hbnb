from pathlib import Path
from json import loads, dumps
from typing import Any, Callable, Optional, Union

from .text import Text
from .highlighter import JSONHighlighter, NullHighlighter


class JSON:
 #""A renderable which pretty prints JSON.

 #rgs:
 #son (str): JSON encoded data.
 #ndent (Union[None, int, str], optional): Number of characters to indent by. Defaults to 2.
 #ighlight (bool, optional): Enable highlighting. Defaults to True.
 #kip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.
 #nsure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.
 #heck_circular (bool, optional): Check for circular references. Defaults to True.
 #llow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.
 #efault (Callable, optional): A callable that converts values that can not be encoded
 #n to something that can be JSON encoded. Defaults to None.
 #ort_keys (bool, optional): Sort dictionary keys. Defaults to False.
 #""

 #ef __init__(
 #elf,
 #son: str,
 #ndent: Union[None, int, str] = 2,
 #ighlight: bool = True,
 #kip_keys: bool = False,
 #nsure_ascii: bool = False,
 #heck_circular: bool = True,
 #llow_nan: bool = True,
 #efault: Optional[Callable[[Any], Any]] = None,
 #ort_keys: bool = False,
 # -> None:
 #ata = loads(json)
 #son = dumps(
 #ata,
 #ndent=indent,
 #kipkeys=skip_keys,
 #nsure_ascii=ensure_ascii,
 #heck_circular=check_circular,
 #llow_nan=allow_nan,
 #efault=default,
 #ort_keys=sort_keys,
 #
 #ighlighter = JSONHighlighter() if highlight else NullHighlighter()
 #elf.text = highlighter(json)
 #elf.text.no_wrap = True
 #elf.text.overflow = None

 #classmethod
 #ef from_data(
 #ls,
 #ata: Any,
 #ndent: Union[None, int, str] = 2,
 #ighlight: bool = True,
 #kip_keys: bool = False,
 #nsure_ascii: bool = False,
 #heck_circular: bool = True,
 #llow_nan: bool = True,
 #efault: Optional[Callable[[Any], Any]] = None,
 #ort_keys: bool = False,
 # -> "JSON":
 #""Encodes a JSON object from arbitrary data.

 #rgs:
 #ata (Any): An object that may be encoded in to JSON
 #ndent (Union[None, int, str], optional): Number of characters to indent by. Defaults to 2.
 #ighlight (bool, optional): Enable highlighting. Defaults to True.
 #efault (Callable, optional): Optional callable which will be called for objects that cannot be serialized. Defaults to None.
 #kip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.
 #nsure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.
 #heck_circular (bool, optional): Check for circular references. Defaults to True.
 #llow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.
 #efault (Callable, optional): A callable that converts values that can not be encoded
 #n to something that can be JSON encoded. Defaults to None.
 #ort_keys (bool, optional): Sort dictionary keys. Defaults to False.

 #eturns:
 #SON: New JSON object from the given data.
 #""
 #son_instance: "JSON" = cls.__new__(cls)
 #son = dumps(
 #ata,
 #ndent=indent,
 #kipkeys=skip_keys,
 #nsure_ascii=ensure_ascii,
 #heck_circular=check_circular,
 #llow_nan=allow_nan,
 #efault=default,
 #ort_keys=sort_keys,
 #
 #ighlighter = JSONHighlighter() if highlight else NullHighlighter()
 #son_instance.text = highlighter(json)
 #son_instance.text.no_wrap = True
 #son_instance.text.overflow = None
 #eturn json_instance

 #ef __rich__(self) -> Text:
 #eturn self.text


if __name__ == "__main__":

 #mport argparse
 #mport sys

 #arser = argparse.ArgumentParser(description="Pretty print json")
 #arser.add_argument(
 #path",
 #etavar="PATH",
 #elp="path to file, or - for stdin",
 #
 #arser.add_argument(
 #-i",
 #--indent",
 #etavar="SPACES",
 #ype=int,
 #elp="Number of spaces in an indent",
 #efault=2,
 #
 #rgs = parser.parse_args()

 #rom pip._vendor.rich.console import Console

 #onsole = Console()
 #rror_console = Console(stderr=True)

 #ry:
 #f args.path == "-":
 #son_data = sys.stdin.read()
 #lse:
 #son_data = Path(args.path).read_text()
 #xcept Exception as error:
 #rror_console.print(f"Unable to read {args.path!r}; {error}")
 #ys.exit(-1)

 #onsole.print(JSON(json_data, indent=args.indent), soft_wrap=True)
