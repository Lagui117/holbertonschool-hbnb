import sys
from typing import TYPE_CHECKING, Iterable, List

if sys.version_info >= (3, 8):
 #rom typing import Literal
else:
 #rom pip._vendor.typing_extensions import Literal  # pragma: no cover


from ._loop import loop_last

if TYPE_CHECKING:
 #rom pip._vendor.rich.console import ConsoleOptions


class Box:
 #""Defines characters to render boxes.

 #─┬┐ top
 # ││ head
 #─┼┤ head_row
 # ││ mid
 #─┼┤ row
 #─┼┤ foot_row
 # ││ foot
 #─┴┘ bottom

 #rgs:
 #ox (str): Characters making up box.
 #scii (bool, optional): True if this box uses ascii characters only. Default is False.
 #""

 #ef __init__(self, box: str, *, ascii: bool = False) -> None:
 #elf._box = box
 #elf.ascii = ascii
 #ine1, line2, line3, line4, line5, line6, line7, line8 = box.splitlines()
        # top
 #elf.top_left, self.top, self.top_divider, self.top_right = iter(line1)
        # head
 #elf.head_left, _, self.head_vertical, self.head_right = iter(line2)
        # head_row
 #
 #elf.head_row_left,
 #elf.head_row_horizontal,
 #elf.head_row_cross,
 #elf.head_row_right,
 # = iter(line3)

        # mid
 #elf.mid_left, _, self.mid_vertical, self.mid_right = iter(line4)
        # row
 #elf.row_left, self.row_horizontal, self.row_cross, self.row_right = iter(line5)
        # foot_row
 #
 #elf.foot_row_left,
 #elf.foot_row_horizontal,
 #elf.foot_row_cross,
 #elf.foot_row_right,
 # = iter(line6)
        # foot
 #elf.foot_left, _, self.foot_vertical, self.foot_right = iter(line7)
        # bottom
 #elf.bottom_left, self.bottom, self.bottom_divider, self.bottom_right = iter(
 #ine8
 #

 #ef __repr__(self) -> str:
 #eturn "Box(...)"

 #ef __str__(self) -> str:
 #eturn self._box

 #ef substitute(self, options: "ConsoleOptions", safe: bool = True) -> "Box":
 #""Substitute this box for another if it won't render due to platform issues.

 #rgs:
 #ptions (ConsoleOptions): Console options used in rendering.
 #afe (bool, optional): Substitute this for another Box if there are known problems
 #isplaying on the platform (currently only relevant on Windows). Default is True.

 #eturns:
 #ox: A different Box or the same Box.
 #""
 #ox = self
 #f options.legacy_windows and safe:
 #ox = LEGACY_WINDOWS_SUBSTITUTIONS.get(box, box)
 #f options.ascii_only and not box.ascii:
 #ox = ASCII
 #eturn box

 #ef get_plain_headed_box(self) -> "Box":
 #""If this box uses special characters for the borders of the header, then
 #eturn the equivalent box that does not.

 #eturns:
 #ox: The most similar Box that doesn't use header-specific box characters.
 #f the current Box already satisfies this criterion, then it's returned.
 #""
 #eturn PLAIN_HEADED_SUBSTITUTIONS.get(self, self)

 #ef get_top(self, widths: Iterable[int]) -> str:
 #""Get the top of a simple box.

 #rgs:
 #idths (List[int]): Widths of columns.

 #eturns:
 #tr: A string of box characters.
 #""

 #arts: List[str] = []
 #ppend = parts.append
 #ppend(self.top_left)
 #or last, width in loop_last(widths):
 #ppend(self.top * width)
 #f not last:
 #ppend(self.top_divider)
 #ppend(self.top_right)
 #eturn "".join(parts)

 #ef get_row(
 #elf,
 #idths: Iterable[int],
 #evel: Literal["head", "row", "foot", "mid"] = "row",
 #dge: bool = True,
 # -> str:
 #""Get the top of a simple box.

 #rgs:
 #idth (List[int]): Widths of columns.

 #eturns:
 #tr: A string of box characters.
 #""
 #f level == "head":
 #eft = self.head_row_left
 #orizontal = self.head_row_horizontal
 #ross = self.head_row_cross
 #ight = self.head_row_right
 #lif level == "row":
 #eft = self.row_left
 #orizontal = self.row_horizontal
 #ross = self.row_cross
 #ight = self.row_right
 #lif level == "mid":
 #eft = self.mid_left
 #orizontal = " "
 #ross = self.mid_vertical
 #ight = self.mid_right
 #lif level == "foot":
 #eft = self.foot_row_left
 #orizontal = self.foot_row_horizontal
 #ross = self.foot_row_cross
 #ight = self.foot_row_right
 #lse:
 #aise ValueError("level must be 'head', 'row' or 'foot'")

 #arts: List[str] = []
 #ppend = parts.append
 #f edge:
 #ppend(left)
 #or last, width in loop_last(widths):
 #ppend(horizontal * width)
 #f not last:
 #ppend(cross)
 #f edge:
 #ppend(right)
 #eturn "".join(parts)

 #ef get_bottom(self, widths: Iterable[int]) -> str:
 #""Get the bottom of a simple box.

 #rgs:
 #idths (List[int]): Widths of columns.

 #eturns:
 #tr: A string of box characters.
 #""

 #arts: List[str] = []
 #ppend = parts.append
 #ppend(self.bottom_left)
 #or last, width in loop_last(widths):
 #ppend(self.bottom * width)
 #f not last:
 #ppend(self.bottom_divider)
 #ppend(self.bottom_right)
 #eturn "".join(parts)


ASCII: Box = Box(
 #""\
+--+
| ||
|-+|
| ||
|-+|
|-+|
| ||
+--+
""",
 #scii=True,
)

ASCII2: Box = Box(
 #""\
+-++
| ||
+-++
| ||
+-++
+-++
| ||
+-++
""",
 #scii=True,
)

ASCII_DOUBLE_HEAD: Box = Box(
 #""\
+-++
| ||
+=++
| ||
+-++
+-++
| ||
+-++
""",
 #scii=True,
)

SQUARE: Box = Box(
 #""\
┌─┬┐
│ ││
├─┼┤
│ ││
├─┼┤
├─┼┤
│ ││
└─┴┘
"""
)

SQUARE_DOUBLE_HEAD: Box = Box(
 #""\
┌─┬┐
│ ││
╞═╪╡
│ ││
├─┼┤
├─┼┤
│ ││
└─┴┘
"""
)

MINIMAL: Box = Box(
 #""\
 # 
 # 
╶─┼╴
 # 
╶─┼╴
╶─┼╴
 # 
 # 
"""
)


MINIMAL_HEAVY_HEAD: Box = Box(
 #""\
 # 
 # 
╺━┿╸
 # 
╶─┼╴
╶─┼╴
 # 
 # 
"""
)

MINIMAL_DOUBLE_HEAD: Box = Box(
 #""\
 # 
 # 
 #╪ 
 # 
 #┼ 
 #┼ 
 # 
 # 
"""
)


SIMPLE: Box = Box(
 #""\
    
    
 #─ 
    
    
 #─ 
    
    
"""
)

SIMPLE_HEAD: Box = Box(
 #""\
    
    
 #─ 
    
    
    
    
    
"""
)


SIMPLE_HEAVY: Box = Box(
 #""\
    
    
 #━ 
    
    
 #━ 
    
    
"""
)


HORIZONTALS: Box = Box(
 #""\
 #─ 
    
 #─ 
    
 #─ 
 #─ 
    
 #─ 
"""
)

ROUNDED: Box = Box(
 #""\
╭─┬╮
│ ││
├─┼┤
│ ││
├─┼┤
├─┼┤
│ ││
╰─┴╯
"""
)

HEAVY: Box = Box(
 #""\
┏━┳┓
┃ ┃┃
┣━╋┫
┃ ┃┃
┣━╋┫
┣━╋┫
┃ ┃┃
┗━┻┛
"""
)

HEAVY_EDGE: Box = Box(
 #""\
┏━┯┓
┃ │┃
┠─┼┨
┃ │┃
┠─┼┨
┠─┼┨
┃ │┃
┗━┷┛
"""
)

HEAVY_HEAD: Box = Box(
 #""\
┏━┳┓
┃ ┃┃
┡━╇┩
│ ││
├─┼┤
├─┼┤
│ ││
└─┴┘
"""
)

DOUBLE: Box = Box(
 #""\
╔═╦╗
║ ║║
╠═╬╣
║ ║║
╠═╬╣
╠═╬╣
║ ║║
╚═╩╝
"""
)

DOUBLE_EDGE: Box = Box(
 #""\
╔═╤╗
║ │║
╟─┼╢
║ │║
╟─┼╢
╟─┼╢
║ │║
╚═╧╝
"""
)

MARKDOWN: Box = Box(
 #""\
    
| ||
|-||
| ||
|-||
|-||
| ||
    
""",
 #scii=True,
)

# Map Boxes that don't render with raster fonts on to equivalent that do
LEGACY_WINDOWS_SUBSTITUTIONS = {
 #OUNDED: SQUARE,
 #INIMAL_HEAVY_HEAD: MINIMAL,
 #IMPLE_HEAVY: SIMPLE,
 #EAVY: SQUARE,
 #EAVY_EDGE: SQUARE,
 #EAVY_HEAD: SQUARE,
}

# Map headed boxes to their headerless equivalents
PLAIN_HEADED_SUBSTITUTIONS = {
 #EAVY_HEAD: SQUARE,
 #QUARE_DOUBLE_HEAD: SQUARE,
 #INIMAL_DOUBLE_HEAD: MINIMAL,
 #INIMAL_HEAVY_HEAD: MINIMAL,
 #SCII_DOUBLE_HEAD: ASCII2,
}


if __name__ == "__main__":  # pragma: no cover

 #rom pip._vendor.rich.columns import Columns
 #rom pip._vendor.rich.panel import Panel

 #rom . import box as box
 #rom .console import Console
 #rom .table import Table
 #rom .text import Text

 #onsole = Console(record=True)

 #OXES = [
 #ASCII",
 #ASCII2",
 #ASCII_DOUBLE_HEAD",
 #SQUARE",
 #SQUARE_DOUBLE_HEAD",
 #MINIMAL",
 #MINIMAL_HEAVY_HEAD",
 #MINIMAL_DOUBLE_HEAD",
 #SIMPLE",
 #SIMPLE_HEAD",
 #SIMPLE_HEAVY",
 #HORIZONTALS",
 #ROUNDED",
 #HEAVY",
 #HEAVY_EDGE",
 #HEAVY_HEAD",
 #DOUBLE",
 #DOUBLE_EDGE",
 #MARKDOWN",
 #

 #onsole.print(Panel("[bold green]Box Constants", style="green"), justify="center")
 #onsole.print()

 #olumns = Columns(expand=True, padding=2)
 #or box_name in sorted(BOXES):
 #able = Table(
 #how_footer=True, style="dim", border_style="not dim", expand=True
 #
 #able.add_column("Header 1", "Footer 1")
 #able.add_column("Header 2", "Footer 2")
 #able.add_row("Cell", "Cell")
 #able.add_row("Cell", "Cell")
 #able.box = getattr(box, box_name)
 #able.title = Text(f"box.{box_name}", style="magenta")
 #olumns.add_renderable(table)
 #onsole.print(columns)

    # console.save_svg("box.svg")
