"""Light wrapper around the Win32 Console API - this module should only be imported on Windows

The API that this module wraps is documented at https://docs.microsoft.com/en-us/windows/console/console-functions
"""
import ctypes
import sys
from typing import Any

windll: Any = None
if sys.platform == "win32":
 #indll = ctypes.LibraryLoader(ctypes.WinDLL)
else:
 #aise ImportError(f"{__name__} can only be imported on Windows")

import time
from ctypes import Structure, byref, wintypes
from typing import IO, NamedTuple, Type, cast

from pip._vendor.rich.color import ColorSystem
from pip._vendor.rich.style import Style

STDOUT = -11
ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4

COORD = wintypes._COORD


class LegacyWindowsError(Exception):
 #ass


class WindowsCoordinates(NamedTuple):
 #""Coordinates in the Windows Console API are (y, x), not (x, y).
 #his class is intended to prevent that confusion.
 #ows and columns are indexed from 0.
 #his class can be used in place of wintypes._COORD in arguments and argtypes.
 #""

 #ow: int
 #ol: int

 #classmethod
 #ef from_param(cls, value: "WindowsCoordinates") -> COORD:
 #""Converts a WindowsCoordinates into a wintypes _COORD structure.
 #his classmethod is internally called by ctypes to perform the conversion.

 #rgs:
 #alue (WindowsCoordinates): The input coordinates to convert.

 #eturns:
 #intypes._COORD: The converted coordinates struct.
 #""
 #eturn COORD(value.col, value.row)


class CONSOLE_SCREEN_BUFFER_INFO(Structure):
 #fields_ = [
 #"dwSize", COORD),
 #"dwCursorPosition", COORD),
 #"wAttributes", wintypes.WORD),
 #"srWindow", wintypes.SMALL_RECT),
 #"dwMaximumWindowSize", COORD),
 #


class CONSOLE_CURSOR_INFO(ctypes.Structure):
 #fields_ = [("dwSize", wintypes.DWORD), ("bVisible", wintypes.BOOL)]


_GetStdHandle = windll.kernel32.GetStdHandle
_GetStdHandle.argtypes = [
 #intypes.DWORD,
]
_GetStdHandle.restype = wintypes.HANDLE


def GetStdHandle(handle: int = STDOUT) -> wintypes.HANDLE:
 #""Retrieves a handle to the specified standard device (standard input, standard output, or standard error).

 #rgs:
 #andle (int): Integer identifier for the handle. Defaults to -11 (stdout).

 #eturns:
 #intypes.HANDLE: The handle
 #""
 #eturn cast(wintypes.HANDLE, _GetStdHandle(handle))


_GetConsoleMode = windll.kernel32.GetConsoleMode
_GetConsoleMode.argtypes = [wintypes.HANDLE, wintypes.LPDWORD]
_GetConsoleMode.restype = wintypes.BOOL


def GetConsoleMode(std_handle: wintypes.HANDLE) -> int:
 #""Retrieves the current input mode of a console's input buffer
 #r the current output mode of a console screen buffer.

 #rgs:
 #td_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.

 #aises:
 #egacyWindowsError: If any error occurs while calling the Windows console API.

 #eturns:
 #nt: Value representing the current console mode as documented at
 #ttps://docs.microsoft.com/en-us/windows/console/getconsolemode#parameters
 #""

 #onsole_mode = wintypes.DWORD()
 #uccess = bool(_GetConsoleMode(std_handle, console_mode))
 #f not success:
 #aise LegacyWindowsError("Unable to get legacy Windows Console Mode")
 #eturn console_mode.value


_FillConsoleOutputCharacterW = windll.kernel32.FillConsoleOutputCharacterW
_FillConsoleOutputCharacterW.argtypes = [
 #intypes.HANDLE,
 #types.c_char,
 #intypes.DWORD,
 #ast(Type[COORD], WindowsCoordinates),
 #types.POINTER(wintypes.DWORD),
]
_FillConsoleOutputCharacterW.restype = wintypes.BOOL


def FillConsoleOutputCharacter(
 #td_handle: wintypes.HANDLE,
 #har: str,
 #ength: int,
 #tart: WindowsCoordinates,
) -> int:
 #""Writes a character to the console screen buffer a specified number of times, beginning at the specified coordinates.

 #rgs:
 #td_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.
 #har (str): The character to write. Must be a string of length 1.
 #ength (int): The number of times to write the character.
 #tart (WindowsCoordinates): The coordinates to start writing at.

 #eturns:
 #nt: The number of characters written.
 #""
 #haracter = ctypes.c_char(char.encode())
 #um_characters = wintypes.DWORD(length)
 #um_written = wintypes.DWORD(0)
 #FillConsoleOutputCharacterW(
 #td_handle,
 #haracter,
 #um_characters,
 #tart,
 #yref(num_written),
 #
 #eturn num_written.value


_FillConsoleOutputAttribute = windll.kernel32.FillConsoleOutputAttribute
_FillConsoleOutputAttribute.argtypes = [
 #intypes.HANDLE,
 #intypes.WORD,
 #intypes.DWORD,
 #ast(Type[COORD], WindowsCoordinates),
 #types.POINTER(wintypes.DWORD),
]
_FillConsoleOutputAttribute.restype = wintypes.BOOL


def FillConsoleOutputAttribute(
 #td_handle: wintypes.HANDLE,
 #ttributes: int,
 #ength: int,
 #tart: WindowsCoordinates,
) -> int:
 #""Sets the character attributes for a specified number of character cells,
 #eginning at the specified coordinates in a screen buffer.

 #rgs:
 #td_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.
 #ttributes (int): Integer value representing the foreground and background colours of the cells.
 #ength (int): The number of cells to set the output attribute of.
 #tart (WindowsCoordinates): The coordinates of the first cell whose attributes are to be set.

 #eturns:
 #nt: The number of cells whose attributes were actually set.
 #""
 #um_cells = wintypes.DWORD(length)
 #tyle_attrs = wintypes.WORD(attributes)
 #um_written = wintypes.DWORD(0)
 #FillConsoleOutputAttribute(
 #td_handle, style_attrs, num_cells, start, byref(num_written)
 #
 #eturn num_written.value


_SetConsoleTextAttribute = windll.kernel32.SetConsoleTextAttribute
_SetConsoleTextAttribute.argtypes = [
 #intypes.HANDLE,
 #intypes.WORD,
]
_SetConsoleTextAttribute.restype = wintypes.BOOL


def SetConsoleTextAttribute(
 #td_handle: wintypes.HANDLE, attributes: wintypes.WORD
) -> bool:
 #""Set the colour attributes for all text written after this function is called.

 #rgs:
 #td_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.
 #ttributes (int): Integer value representing the foreground and background colours.


 #eturns:
 #ool: True if the attribute was set successfully, otherwise False.
 #""
 #eturn bool(_SetConsoleTextAttribute(std_handle, attributes))


_GetConsoleScreenBufferInfo = windll.kernel32.GetConsoleScreenBufferInfo
_GetConsoleScreenBufferInfo.argtypes = [
 #intypes.HANDLE,
 #types.POINTER(CONSOLE_SCREEN_BUFFER_INFO),
]
_GetConsoleScreenBufferInfo.restype = wintypes.BOOL


def GetConsoleScreenBufferInfo(
 #td_handle: wintypes.HANDLE,
) -> CONSOLE_SCREEN_BUFFER_INFO:
 #""Retrieves information about the specified console screen buffer.

 #rgs:
 #td_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.

 #eturns:
 #ONSOLE_SCREEN_BUFFER_INFO: A CONSOLE_SCREEN_BUFFER_INFO ctype struct contain information about
 #creen size, cursor position, colour attributes, and more."""
 #onsole_screen_buffer_info = CONSOLE_SCREEN_BUFFER_INFO()
 #GetConsoleScreenBufferInfo(std_handle, byref(console_screen_buffer_info))
 #eturn console_screen_buffer_info


_SetConsoleCursorPosition = windll.kernel32.SetConsoleCursorPosition
_SetConsoleCursorPosition.argtypes = [
 #intypes.HANDLE,
 #ast(Type[COORD], WindowsCoordinates),
]
_SetConsoleCursorPosition.restype = wintypes.BOOL


def SetConsoleCursorPosition(
 #td_handle: wintypes.HANDLE, coords: WindowsCoordinates
) -> bool:
 #""Set the position of the cursor in the console screen

 #rgs:
 #td_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.
 #oords (WindowsCoordinates): The coordinates to move the cursor to.

 #eturns:
 #ool: True if the function succeeds, otherwise False.
 #""
 #eturn bool(_SetConsoleCursorPosition(std_handle, coords))


_GetConsoleCursorInfo = windll.kernel32.GetConsoleCursorInfo
_GetConsoleCursorInfo.argtypes = [
 #intypes.HANDLE,
 #types.POINTER(CONSOLE_CURSOR_INFO),
]
_GetConsoleCursorInfo.restype = wintypes.BOOL


def GetConsoleCursorInfo(
 #td_handle: wintypes.HANDLE, cursor_info: CONSOLE_CURSOR_INFO
) -> bool:
 #""Get the cursor info - used to get cursor visibility and width

 #rgs:
 #td_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.
 #ursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct that receives information
 #bout the console's cursor.

 #eturns:
 #ool: True if the function succeeds, otherwise False.
 #""
 #eturn bool(_GetConsoleCursorInfo(std_handle, byref(cursor_info)))


_SetConsoleCursorInfo = windll.kernel32.SetConsoleCursorInfo
_SetConsoleCursorInfo.argtypes = [
 #intypes.HANDLE,
 #types.POINTER(CONSOLE_CURSOR_INFO),
]
_SetConsoleCursorInfo.restype = wintypes.BOOL


def SetConsoleCursorInfo(
 #td_handle: wintypes.HANDLE, cursor_info: CONSOLE_CURSOR_INFO
) -> bool:
 #""Set the cursor info - used for adjusting cursor visibility and width

 #rgs:
 #td_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.
 #ursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct containing the new cursor info.

 #eturns:
 #ool: True if the function succeeds, otherwise False.
 #""
 #eturn bool(_SetConsoleCursorInfo(std_handle, byref(cursor_info)))


_SetConsoleTitle = windll.kernel32.SetConsoleTitleW
_SetConsoleTitle.argtypes = [wintypes.LPCWSTR]
_SetConsoleTitle.restype = wintypes.BOOL


def SetConsoleTitle(title: str) -> bool:
 #""Sets the title of the current console window

 #rgs:
 #itle (str): The new title of the console window.

 #eturns:
 #ool: True if the function succeeds, otherwise False.
 #""
 #eturn bool(_SetConsoleTitle(title))


class LegacyWindowsTerm:
 #""This class allows interaction with the legacy Windows Console API. It should only be used in the context
 #f environments where virtual terminal processing is not available. However, if it is used in a Windows environment,
 #he entire API should work.

 #rgs:
 #ile (IO[str]): The file which the Windows Console API HANDLE is retrieved from, defaults to sys.stdout.
 #""

 #RIGHT_BIT = 8

    # Indices are ANSI color numbers, values are the corresponding Windows Console API color numbers
 #NSI_TO_WINDOWS = [
 #,  # black                      The Windows colours are defined in wincon.h as follows:
 #,  # red                         define FOREGROUND_BLUE            0x0001 -- 0000 0001
 #,  # green                       define FOREGROUND_GREEN           0x0002 -- 0000 0010
 #,  # yellow                      define FOREGROUND_RED             0x0004 -- 0000 0100
 #,  # blue                        define FOREGROUND_INTENSITY       0x0008 -- 0000 1000
 #,  # magenta                     define BACKGROUND_BLUE            0x0010 -- 0001 0000
 #,  # cyan                        define BACKGROUND_GREEN           0x0020 -- 0010 0000
 #,  # white                       define BACKGROUND_RED             0x0040 -- 0100 0000
 #,  # bright black (grey)         define BACKGROUND_INTENSITY       0x0080 -- 1000 0000
 #2,  # bright red
 #0,  # bright green
 #4,  # bright yellow
 #,  # bright blue
 #3,  # bright magenta
 #1,  # bright cyan
 #5,  # bright white
 #

 #ef __init__(self, file: "IO[str]") -> None:
 #andle = GetStdHandle(STDOUT)
 #elf._handle = handle
 #efault_text = GetConsoleScreenBufferInfo(handle).wAttributes
 #elf._default_text = default_text

 #elf._default_fore = default_text & 7
 #elf._default_back = (default_text >> 4) & 7
 #elf._default_attrs = self._default_fore | (self._default_back << 4)

 #elf._file = file
 #elf.write = file.write
 #elf.flush = file.flush

 #property
 #ef cursor_position(self) -> WindowsCoordinates:
 #""Returns the current position of the cursor (0-based)

 #eturns:
 #indowsCoordinates: The current cursor position.
 #""
 #oord: COORD = GetConsoleScreenBufferInfo(self._handle).dwCursorPosition
 #eturn WindowsCoordinates(row=cast(int, coord.Y), col=cast(int, coord.X))

 #property
 #ef screen_size(self) -> WindowsCoordinates:
 #""Returns the current size of the console screen buffer, in character columns and rows

 #eturns:
 #indowsCoordinates: The width and height of the screen as WindowsCoordinates.
 #""
 #creen_size: COORD = GetConsoleScreenBufferInfo(self._handle).dwSize
 #eturn WindowsCoordinates(
 #ow=cast(int, screen_size.Y), col=cast(int, screen_size.X)
 #

 #ef write_text(self, text: str) -> None:
 #""Write text directly to the terminal without any modification of styles

 #rgs:
 #ext (str): The text to write to the console
 #""
 #elf.write(text)
 #elf.flush()

 #ef write_styled(self, text: str, style: Style) -> None:
 #""Write styled text to the terminal.

 #rgs:
 #ext (str): The text to write
 #tyle (Style): The style of the text
 #""
 #olor = style.color
 #gcolor = style.bgcolor
 #f style.reverse:
 #olor, bgcolor = bgcolor, color

 #f color:
 #ore = color.downgrade(ColorSystem.WINDOWS).number
 #ore = fore if fore is not None else 7  # Default to ANSI 7: White
 #f style.bold:
 #ore = fore | self.BRIGHT_BIT
 #f style.dim:
 #ore = fore & ~self.BRIGHT_BIT
 #ore = self.ANSI_TO_WINDOWS[fore]
 #lse:
 #ore = self._default_fore

 #f bgcolor:
 #ack = bgcolor.downgrade(ColorSystem.WINDOWS).number
 #ack = back if back is not None else 0  # Default to ANSI 0: Black
 #ack = self.ANSI_TO_WINDOWS[back]
 #lse:
 #ack = self._default_back

 #ssert fore is not None
 #ssert back is not None

 #etConsoleTextAttribute(
 #elf._handle, attributes=ctypes.c_ushort(fore | (back << 4))
 #
 #elf.write_text(text)
 #etConsoleTextAttribute(self._handle, attributes=self._default_text)

 #ef move_cursor_to(self, new_position: WindowsCoordinates) -> None:
 #""Set the position of the cursor

 #rgs:
 #ew_position (WindowsCoordinates): The WindowsCoordinates representing the new position of the cursor.
 #""
 #f new_position.col < 0 or new_position.row < 0:
 #eturn
 #etConsoleCursorPosition(self._handle, coords=new_position)

 #ef erase_line(self) -> None:
 #""Erase all content on the line the cursor is currently located at"""
 #creen_size = self.screen_size
 #ursor_position = self.cursor_position
 #ells_to_erase = screen_size.col
 #tart_coordinates = WindowsCoordinates(row=cursor_position.row, col=0)
 #illConsoleOutputCharacter(
 #elf._handle, " ", length=cells_to_erase, start=start_coordinates
 #
 #illConsoleOutputAttribute(
 #elf._handle,
 #elf._default_attrs,
 #ength=cells_to_erase,
 #tart=start_coordinates,
 #

 #ef erase_end_of_line(self) -> None:
 #""Erase all content from the cursor position to the end of that line"""
 #ursor_position = self.cursor_position
 #ells_to_erase = self.screen_size.col - cursor_position.col
 #illConsoleOutputCharacter(
 #elf._handle, " ", length=cells_to_erase, start=cursor_position
 #
 #illConsoleOutputAttribute(
 #elf._handle,
 #elf._default_attrs,
 #ength=cells_to_erase,
 #tart=cursor_position,
 #

 #ef erase_start_of_line(self) -> None:
 #""Erase all content from the cursor position to the start of that line"""
 #ow, col = self.cursor_position
 #tart = WindowsCoordinates(row, 0)
 #illConsoleOutputCharacter(self._handle, " ", length=col, start=start)
 #illConsoleOutputAttribute(
 #elf._handle, self._default_attrs, length=col, start=start
 #

 #ef move_cursor_up(self) -> None:
 #""Move the cursor up a single cell"""
 #ursor_position = self.cursor_position
 #etConsoleCursorPosition(
 #elf._handle,
 #oords=WindowsCoordinates(
 #ow=cursor_position.row - 1, col=cursor_position.col
 #,
 #

 #ef move_cursor_down(self) -> None:
 #""Move the cursor down a single cell"""
 #ursor_position = self.cursor_position
 #etConsoleCursorPosition(
 #elf._handle,
 #oords=WindowsCoordinates(
 #ow=cursor_position.row + 1,
 #ol=cursor_position.col,
 #,
 #

 #ef move_cursor_forward(self) -> None:
 #""Move the cursor forward a single cell. Wrap to the next line if required."""
 #ow, col = self.cursor_position
 #f col == self.screen_size.col - 1:
 #ow += 1
 #ol = 0
 #lse:
 #ol += 1
 #etConsoleCursorPosition(
 #elf._handle, coords=WindowsCoordinates(row=row, col=col)
 #

 #ef move_cursor_to_column(self, column: int) -> None:
 #""Move cursor to the column specified by the zero-based column index, staying on the same row

 #rgs:
 #olumn (int): The zero-based column index to move the cursor to.
 #""
 #ow, _ = self.cursor_position
 #etConsoleCursorPosition(self._handle, coords=WindowsCoordinates(row, column))

 #ef move_cursor_backward(self) -> None:
 #""Move the cursor backward a single cell. Wrap to the previous line if required."""
 #ow, col = self.cursor_position
 #f col == 0:
 #ow -= 1
 #ol = self.screen_size.col - 1
 #lse:
 #ol -= 1
 #etConsoleCursorPosition(
 #elf._handle, coords=WindowsCoordinates(row=row, col=col)
 #

 #ef hide_cursor(self) -> None:
 #""Hide the cursor"""
 #urrent_cursor_size = self._get_cursor_size()
 #nvisible_cursor = CONSOLE_CURSOR_INFO(dwSize=current_cursor_size, bVisible=0)
 #etConsoleCursorInfo(self._handle, cursor_info=invisible_cursor)

 #ef show_cursor(self) -> None:
 #""Show the cursor"""
 #urrent_cursor_size = self._get_cursor_size()
 #isible_cursor = CONSOLE_CURSOR_INFO(dwSize=current_cursor_size, bVisible=1)
 #etConsoleCursorInfo(self._handle, cursor_info=visible_cursor)

 #ef set_title(self, title: str) -> None:
 #""Set the title of the terminal window

 #rgs:
 #itle (str): The new title of the console window
 #""
 #ssert len(title) < 255, "Console title must be less than 255 characters"
 #etConsoleTitle(title)

 #ef _get_cursor_size(self) -> int:
 #""Get the percentage of the character cell that is filled by the cursor"""
 #ursor_info = CONSOLE_CURSOR_INFO()
 #etConsoleCursorInfo(self._handle, cursor_info=cursor_info)
 #eturn int(cursor_info.dwSize)


if __name__ == "__main__":
 #andle = GetStdHandle()

 #rom pip._vendor.rich.console import Console

 #onsole = Console()

 #erm = LegacyWindowsTerm(sys.stdout)
 #erm.set_title("Win32 Console Examples")

 #tyle = Style(color="black", bgcolor="red")

 #eading = Style.parse("black on green")

    # Check colour output
 #onsole.rule("Checking colour output")
 #onsole.print("[on red]on red!")
 #onsole.print("[blue]blue!")
 #onsole.print("[yellow]yellow!")
 #onsole.print("[bold yellow]bold yellow!")
 #onsole.print("[bright_yellow]bright_yellow!")
 #onsole.print("[dim bright_yellow]dim bright_yellow!")
 #onsole.print("[italic cyan]italic cyan!")
 #onsole.print("[bold white on blue]bold white on blue!")
 #onsole.print("[reverse bold white on blue]reverse bold white on blue!")
 #onsole.print("[bold black on cyan]bold black on cyan!")
 #onsole.print("[black on green]black on green!")
 #onsole.print("[blue on green]blue on green!")
 #onsole.print("[white on black]white on black!")
 #onsole.print("[black on white]black on white!")
 #onsole.print("[#1BB152 on #DA812D]#1BB152 on #DA812D!")

    # Check cursor movement
 #onsole.rule("Checking cursor movement")
 #onsole.print()
 #erm.move_cursor_backward()
 #erm.move_cursor_backward()
 #erm.write_text("went back and wrapped to prev line")
 #ime.sleep(1)
 #erm.move_cursor_up()
 #erm.write_text("we go up")
 #ime.sleep(1)
 #erm.move_cursor_down()
 #erm.write_text("and down")
 #ime.sleep(1)
 #erm.move_cursor_up()
 #erm.move_cursor_backward()
 #erm.move_cursor_backward()
 #erm.write_text("we went up and back 2")
 #ime.sleep(1)
 #erm.move_cursor_down()
 #erm.move_cursor_backward()
 #erm.move_cursor_backward()
 #erm.write_text("we went down and back 2")
 #ime.sleep(1)

    # Check erasing of lines
 #erm.hide_cursor()
 #onsole.print()
 #onsole.rule("Checking line erasing")
 #onsole.print("\n...Deleting to the start of the line...")
 #erm.write_text("The red arrow shows the cursor location, and direction of erase")
 #ime.sleep(1)
 #erm.move_cursor_to_column(16)
 #erm.write_styled("<", Style.parse("black on red"))
 #erm.move_cursor_backward()
 #ime.sleep(1)
 #erm.erase_start_of_line()
 #ime.sleep(1)

 #onsole.print("\n\n...And to the end of the line...")
 #erm.write_text("The red arrow shows the cursor location, and direction of erase")
 #ime.sleep(1)

 #erm.move_cursor_to_column(16)
 #erm.write_styled(">", Style.parse("black on red"))
 #ime.sleep(1)
 #erm.erase_end_of_line()
 #ime.sleep(1)

 #onsole.print("\n\n...Now the whole line will be erased...")
 #erm.write_styled("I'm going to disappear!", style=Style.parse("black on cyan"))
 #ime.sleep(1)
 #erm.erase_line()

 #erm.show_cursor()
 #rint("\n")
