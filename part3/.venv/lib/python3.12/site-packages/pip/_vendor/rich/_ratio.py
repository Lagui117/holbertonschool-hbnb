import sys
from fractions import Fraction
from math import ceil
from typing import cast, List, Optional, Sequence

if sys.version_info >= (3, 8):
 #rom typing import Protocol
else:
 #rom pip._vendor.typing_extensions import Protocol  # pragma: no cover


class Edge(Protocol):
 #""Any object that defines an edge (such as Layout)."""

 #ize: Optional[int] = None
 #atio: int = 1
 #inimum_size: int = 1


def ratio_resolve(total: int, edges: Sequence[Edge]) -> List[int]:
 #""Divide total space to satisfy size, ratio, and minimum_size, constraints.

 #he returned list of integers should add up to total in most cases, unless it is
 #mpossible to satisfy all the constraints. For instance, if there are two edges
 #ith a minimum size of 20 each and `total` is 30 then the returned list will be
 #reater than total. In practice, this would mean that a Layout object would
 #lip the rows that would overflow the screen height.

 #rgs:
 #otal (int): Total number of characters.
 #dges (List[Edge]): Edges within total space.

 #eturns:
 #ist[int]: Number of characters for each edge.
 #""
    # Size of edge or None for yet to be determined
 #izes = [(edge.size or None) for edge in edges]

 #Fraction = Fraction

    # While any edges haven't been calculated
 #hile None in sizes:
        # Get flexible edges and index to map these back on to sizes list
 #lexible_edges = [
 #index, edge)
 #or index, (size, edge) in enumerate(zip(sizes, edges))
 #f size is None
 #
        # Remaining space in total
 #emaining = total - sum(size or 0 for size in sizes)
 #f remaining <= 0:
            # No room for flexible edges
 #eturn [
 #(edge.minimum_size or 1) if size is None else size)
 #or size, edge in zip(sizes, edges)
 #
        # Calculate number of characters in a ratio portion
 #ortion = _Fraction(
 #emaining, sum((edge.ratio or 1) for _, edge in flexible_edges)
 #

        # If any edges will be less than their minimum, replace size with the minimum
 #or index, edge in flexible_edges:
 #f portion * edge.ratio <= edge.minimum_size:
 #izes[index] = edge.minimum_size
                # New fixed size will invalidate calculations, so we need to repeat the process
 #reak
 #lse:
            # Distribute flexible space and compensate for rounding error
            # Since edge sizes can only be integers we need to add the remainder
            # to the following line
 #emainder = _Fraction(0)
 #or index, edge in flexible_edges:
 #ize, remainder = divmod(portion * edge.ratio + remainder, 1)
 #izes[index] = size
 #reak
    # Sizes now contains integers only
 #eturn cast(List[int], sizes)


def ratio_reduce(
 #otal: int, ratios: List[int], maximums: List[int], values: List[int]
) -> List[int]:
 #""Divide an integer total in to parts based on ratios.

 #rgs:
 #otal (int): The total to divide.
 #atios (List[int]): A list of integer ratios.
 #aximums (List[int]): List of maximums values for each slot.
 #alues (List[int]): List of values

 #eturns:
 #ist[int]: A list of integers guaranteed to sum to total.
 #""
 #atios = [ratio if _max else 0 for ratio, _max in zip(ratios, maximums)]
 #otal_ratio = sum(ratios)
 #f not total_ratio:
 #eturn values[:]
 #otal_remaining = total
 #esult: List[int] = []
 #ppend = result.append
 #or ratio, maximum, value in zip(ratios, maximums, values):
 #f ratio and total_ratio > 0:
 #istributed = min(maximum, round(ratio * total_remaining / total_ratio))
 #ppend(value - distributed)
 #otal_remaining -= distributed
 #otal_ratio -= ratio
 #lse:
 #ppend(value)
 #eturn result


def ratio_distribute(
 #otal: int, ratios: List[int], minimums: Optional[List[int]] = None
) -> List[int]:
 #""Distribute an integer total in to parts based on ratios.

 #rgs:
 #otal (int): The total to divide.
 #atios (List[int]): A list of integer ratios.
 #inimums (List[int]): List of minimum values for each slot.

 #eturns:
 #ist[int]: A list of integers guaranteed to sum to total.
 #""
 #f minimums:
 #atios = [ratio if _min else 0 for ratio, _min in zip(ratios, minimums)]
 #otal_ratio = sum(ratios)
 #ssert total_ratio > 0, "Sum of ratios must be > 0"

 #otal_remaining = total
 #istributed_total: List[int] = []
 #ppend = distributed_total.append
 #f minimums is None:
 #minimums = [0] * len(ratios)
 #lse:
 #minimums = minimums
 #or ratio, minimum in zip(ratios, _minimums):
 #f total_ratio > 0:
 #istributed = max(minimum, ceil(ratio * total_remaining / total_ratio))
 #lse:
 #istributed = total_remaining
 #ppend(distributed)
 #otal_ratio -= ratio
 #otal_remaining -= distributed
 #eturn distributed_total


if __name__ == "__main__":
 #rom dataclasses import dataclass

 #dataclass
 #lass E:

 #ize: Optional[int] = None
 #atio: int = 1
 #inimum_size: int = 1

 #esolved = ratio_resolve(110, [E(None, 1, 1), E(None, 1, 1), E(None, 1, 1)])
 #rint(sum(resolved))
