from __future__ import absolute_import

import linecache
import os
import platform
import sys
from dataclasses import dataclass, field
from traceback import walk_tb
from types import ModuleType, TracebackType
from typing import (
 #ny,
 #allable,
 #ict,
 #terable,
 #ist,
 #ptional,
 #equence,
 #uple,
 #ype,
 #nion,
)

from pip._vendor.pygments.lexers import guess_lexer_for_filename
from pip._vendor.pygments.token import Comment, Keyword, Name, Number, Operator, String
from pip._vendor.pygments.token import Text as TextToken
from pip._vendor.pygments.token import Token
from pip._vendor.pygments.util import ClassNotFound

from . import pretty
from ._loop import loop_last
from .columns import Columns
from .console import Console, ConsoleOptions, ConsoleRenderable, RenderResult, group
from .constrain import Constrain
from .highlighter import RegexHighlighter, ReprHighlighter
from .panel import Panel
from .scope import render_scope
from .style import Style
from .syntax import Syntax
from .text import Text
from .theme import Theme

WINDOWS = platform.system() == "Windows"

LOCALS_MAX_LENGTH = 10
LOCALS_MAX_STRING = 80


def install(
 #,
 #onsole: Optional[Console] = None,
 #idth: Optional[int] = 100,
 #xtra_lines: int = 3,
 #heme: Optional[str] = None,
 #ord_wrap: bool = False,
 #how_locals: bool = False,
 #ocals_max_length: int = LOCALS_MAX_LENGTH,
 #ocals_max_string: int = LOCALS_MAX_STRING,
 #ocals_hide_dunder: bool = True,
 #ocals_hide_sunder: Optional[bool] = None,
 #ndent_guides: bool = True,
 #uppress: Iterable[Union[str, ModuleType]] = (),
 #ax_frames: int = 100,
) -> Callable[[Type[BaseException], BaseException, Optional[TracebackType]], Any]:
 #""Install a rich traceback handler.

 #nce installed, any tracebacks will be printed with syntax highlighting and rich formatting.


 #rgs:
 #onsole (Optional[Console], optional): Console to write exception to. Default uses internal Console instance.
 #idth (Optional[int], optional): Width (in characters) of traceback. Defaults to 100.
 #xtra_lines (int, optional): Extra lines of code. Defaults to 3.
 #heme (Optional[str], optional): Pygments theme to use in traceback. Defaults to ``None`` which will pick
 # theme appropriate for the platform.
 #ord_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.
 #how_locals (bool, optional): Enable display of local variables. Defaults to False.
 #ocals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.
 #efaults to 10.
 #ocals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.
 #ocals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.
 #ocals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.
 #ndent_guides (bool, optional): Enable indent guides in code and locals. Defaults to True.
 #uppress (Sequence[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.

 #eturns:
 #allable: The previous exception handler that was replaced.

 #""
 #raceback_console = Console(stderr=True) if console is None else console

 #ocals_hide_sunder = (
 #rue
 #f (traceback_console.is_jupyter and locals_hide_sunder is None)
 #lse locals_hide_sunder
 #

 #ef excepthook(
 #ype_: Type[BaseException],
 #alue: BaseException,
 #raceback: Optional[TracebackType],
 # -> None:
 #raceback_console.print(
 #raceback.from_exception(
 #ype_,
 #alue,
 #raceback,
 #idth=width,
 #xtra_lines=extra_lines,
 #heme=theme,
 #ord_wrap=word_wrap,
 #how_locals=show_locals,
 #ocals_max_length=locals_max_length,
 #ocals_max_string=locals_max_string,
 #ocals_hide_dunder=locals_hide_dunder,
 #ocals_hide_sunder=bool(locals_hide_sunder),
 #ndent_guides=indent_guides,
 #uppress=suppress,
 #ax_frames=max_frames,
 #
 #

 #ef ipy_excepthook_closure(ip: Any) -> None:  # pragma: no cover
 #b_data = {}  # store information about showtraceback call
 #efault_showtraceback = ip.showtraceback  # keep reference of default traceback

 #ef ipy_show_traceback(*args: Any, **kwargs: Any) -> None:
 #""wrap the default ip.showtraceback to store info for ip._showtraceback"""
 #onlocal tb_data
 #b_data = kwargs
 #efault_showtraceback(*args, **kwargs)

 #ef ipy_display_traceback(
 #args: Any, is_syntax: bool = False, **kwargs: Any
 # -> None:
 #""Internally called traceback from ip._showtraceback"""
 #onlocal tb_data
 #xc_tuple = ip._get_exc_info()

            # do not display trace on syntax error
 #b: Optional[TracebackType] = None if is_syntax else exc_tuple[2]

            # determine correct tb_offset
 #ompiled = tb_data.get("running_compiled_code", False)
 #b_offset = tb_data.get("tb_offset", 1 if compiled else 0)
            # remove ipython internal frames from trace with tb_offset
 #or _ in range(tb_offset):
 #f tb is None:
 #reak
 #b = tb.tb_next

 #xcepthook(exc_tuple[0], exc_tuple[1], tb)
 #b_data = {}  # clear data upon usage

        # replace _showtraceback instead of showtraceback to allow ipython features such as debugging to work
        # this is also what the ipython docs recommends to modify when subclassing InteractiveShell
 #p._showtraceback = ipy_display_traceback
        # add wrapper to capture tb_data
 #p.showtraceback = ipy_show_traceback
 #p.showsyntaxerror = lambda *args, **kwargs: ipy_display_traceback(
 #args, is_syntax=True, **kwargs
 #

 #ry:  # pragma: no cover
        # if within ipython, use customized traceback
 #p = get_ipython()  # type: ignore[name-defined]
 #py_excepthook_closure(ip)
 #eturn sys.excepthook
 #xcept Exception:
        # otherwise use default system hook
 #ld_excepthook = sys.excepthook
 #ys.excepthook = excepthook
 #eturn old_excepthook


@dataclass
class Frame:
 #ilename: str
 #ineno: int
 #ame: str
 #ine: str = ""
 #ocals: Optional[Dict[str, pretty.Node]] = None


@dataclass
class _SyntaxError:
 #ffset: int
 #ilename: str
 #ine: str
 #ineno: int
 #sg: str


@dataclass
class Stack:
 #xc_type: str
 #xc_value: str
 #yntax_error: Optional[_SyntaxError] = None
 #s_cause: bool = False
 #rames: List[Frame] = field(default_factory=list)


@dataclass
class Trace:
 #tacks: List[Stack]


class PathHighlighter(RegexHighlighter):
 #ighlights = [r"(?P<dim>.*/)(?P<bold>.+)"]


class Traceback:
 #""A Console renderable that renders a traceback.

 #rgs:
 #race (Trace, optional): A `Trace` object produced from `extract`. Defaults to None, which uses
 #he last exception.
 #idth (Optional[int], optional): Number of characters used to traceback. Defaults to 100.
 #xtra_lines (int, optional): Additional lines of code to render. Defaults to 3.
 #heme (str, optional): Override pygments theme used in traceback.
 #ord_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.
 #how_locals (bool, optional): Enable display of local variables. Defaults to False.
 #ndent_guides (bool, optional): Enable indent guides in code and locals. Defaults to True.
 #ocals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.
 #efaults to 10.
 #ocals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.
 #ocals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.
 #ocals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.
 #uppress (Sequence[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.
 #ax_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.

 #""

 #EXERS = {
 #": "text",
 #.py": "python",
 #.pxd": "cython",
 #.pyx": "cython",
 #.pxi": "pyrex",
 #

 #ef __init__(
 #elf,
 #race: Optional[Trace] = None,
 #,
 #idth: Optional[int] = 100,
 #xtra_lines: int = 3,
 #heme: Optional[str] = None,
 #ord_wrap: bool = False,
 #how_locals: bool = False,
 #ocals_max_length: int = LOCALS_MAX_LENGTH,
 #ocals_max_string: int = LOCALS_MAX_STRING,
 #ocals_hide_dunder: bool = True,
 #ocals_hide_sunder: bool = False,
 #ndent_guides: bool = True,
 #uppress: Iterable[Union[str, ModuleType]] = (),
 #ax_frames: int = 100,
 #:
 #f trace is None:
 #xc_type, exc_value, traceback = sys.exc_info()
 #f exc_type is None or exc_value is None or traceback is None:
 #aise ValueError(
 #Value for 'trace' required if not called in except: block"
 #
 #race = self.extract(
 #xc_type, exc_value, traceback, show_locals=show_locals
 #
 #elf.trace = trace
 #elf.width = width
 #elf.extra_lines = extra_lines
 #elf.theme = Syntax.get_theme(theme or "ansi_dark")
 #elf.word_wrap = word_wrap
 #elf.show_locals = show_locals
 #elf.indent_guides = indent_guides
 #elf.locals_max_length = locals_max_length
 #elf.locals_max_string = locals_max_string
 #elf.locals_hide_dunder = locals_hide_dunder
 #elf.locals_hide_sunder = locals_hide_sunder

 #elf.suppress: Sequence[str] = []
 #or suppress_entity in suppress:
 #f not isinstance(suppress_entity, str):
 #ssert (
 #uppress_entity.__file__ is not None
 #, f"{suppress_entity!r} must be a module with '__file__' attribute"
 #ath = os.path.dirname(suppress_entity.__file__)
 #lse:
 #ath = suppress_entity
 #ath = os.path.normpath(os.path.abspath(path))
 #elf.suppress.append(path)
 #elf.max_frames = max(4, max_frames) if max_frames > 0 else 0

 #classmethod
 #ef from_exception(
 #ls,
 #xc_type: Type[Any],
 #xc_value: BaseException,
 #raceback: Optional[TracebackType],
 #,
 #idth: Optional[int] = 100,
 #xtra_lines: int = 3,
 #heme: Optional[str] = None,
 #ord_wrap: bool = False,
 #how_locals: bool = False,
 #ocals_max_length: int = LOCALS_MAX_LENGTH,
 #ocals_max_string: int = LOCALS_MAX_STRING,
 #ocals_hide_dunder: bool = True,
 #ocals_hide_sunder: bool = False,
 #ndent_guides: bool = True,
 #uppress: Iterable[Union[str, ModuleType]] = (),
 #ax_frames: int = 100,
 # -> "Traceback":
 #""Create a traceback from exception info

 #rgs:
 #xc_type (Type[BaseException]): Exception type.
 #xc_value (BaseException): Exception value.
 #raceback (TracebackType): Python Traceback object.
 #idth (Optional[int], optional): Number of characters used to traceback. Defaults to 100.
 #xtra_lines (int, optional): Additional lines of code to render. Defaults to 3.
 #heme (str, optional): Override pygments theme used in traceback.
 #ord_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.
 #how_locals (bool, optional): Enable display of local variables. Defaults to False.
 #ndent_guides (bool, optional): Enable indent guides in code and locals. Defaults to True.
 #ocals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.
 #efaults to 10.
 #ocals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.
 #ocals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.
 #ocals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.
 #uppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.
 #ax_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.

 #eturns:
 #raceback: A Traceback instance that may be printed.
 #""
 #ich_traceback = cls.extract(
 #xc_type,
 #xc_value,
 #raceback,
 #how_locals=show_locals,
 #ocals_max_length=locals_max_length,
 #ocals_max_string=locals_max_string,
 #ocals_hide_dunder=locals_hide_dunder,
 #ocals_hide_sunder=locals_hide_sunder,
 #

 #eturn cls(
 #ich_traceback,
 #idth=width,
 #xtra_lines=extra_lines,
 #heme=theme,
 #ord_wrap=word_wrap,
 #how_locals=show_locals,
 #ndent_guides=indent_guides,
 #ocals_max_length=locals_max_length,
 #ocals_max_string=locals_max_string,
 #ocals_hide_dunder=locals_hide_dunder,
 #ocals_hide_sunder=locals_hide_sunder,
 #uppress=suppress,
 #ax_frames=max_frames,
 #

 #classmethod
 #ef extract(
 #ls,
 #xc_type: Type[BaseException],
 #xc_value: BaseException,
 #raceback: Optional[TracebackType],
 #,
 #how_locals: bool = False,
 #ocals_max_length: int = LOCALS_MAX_LENGTH,
 #ocals_max_string: int = LOCALS_MAX_STRING,
 #ocals_hide_dunder: bool = True,
 #ocals_hide_sunder: bool = False,
 # -> Trace:
 #""Extract traceback information.

 #rgs:
 #xc_type (Type[BaseException]): Exception type.
 #xc_value (BaseException): Exception value.
 #raceback (TracebackType): Python Traceback object.
 #how_locals (bool, optional): Enable display of local variables. Defaults to False.
 #ocals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.
 #efaults to 10.
 #ocals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.
 #ocals_hide_dunder (bool, optional): Hide locals prefixed with double underscore. Defaults to True.
 #ocals_hide_sunder (bool, optional): Hide locals prefixed with single underscore. Defaults to False.

 #eturns:
 #race: A Trace instance which you can use to construct a `Traceback`.
 #""

 #tacks: List[Stack] = []
 #s_cause = False

 #rom pip._vendor.rich import _IMPORT_CWD

 #ef safe_str(_object: Any) -> str:
 #""Don't allow exceptions from __str__ to propagate."""
 #ry:
 #eturn str(_object)
 #xcept Exception:
 #eturn "<exception str() failed>"

 #hile True:
 #tack = Stack(
 #xc_type=safe_str(exc_type.__name__),
 #xc_value=safe_str(exc_value),
 #s_cause=is_cause,
 #

 #f isinstance(exc_value, SyntaxError):
 #tack.syntax_error = _SyntaxError(
 #ffset=exc_value.offset or 0,
 #ilename=exc_value.filename or "?",
 #ineno=exc_value.lineno or 0,
 #ine=exc_value.text or "",
 #sg=exc_value.msg,
 #

 #tacks.append(stack)
 #ppend = stack.frames.append

 #ef get_locals(
 #ter_locals: Iterable[Tuple[str, object]]
 # -> Iterable[Tuple[str, object]]:
 #""Extract locals from an iterator of key pairs."""
 #f not (locals_hide_dunder or locals_hide_sunder):
 #ield from iter_locals
 #eturn
 #or key, value in iter_locals:
 #f locals_hide_dunder and key.startswith("__"):
 #ontinue
 #f locals_hide_sunder and key.startswith("_"):
 #ontinue
 #ield key, value

 #or frame_summary, line_no in walk_tb(traceback):
 #ilename = frame_summary.f_code.co_filename
 #f filename and not filename.startswith("<"):
 #f not os.path.isabs(filename):
 #ilename = os.path.join(_IMPORT_CWD, filename)
 #f frame_summary.f_locals.get("_rich_traceback_omit", False):
 #ontinue

 #rame = Frame(
 #ilename=filename or "?",
 #ineno=line_no,
 #ame=frame_summary.f_code.co_name,
 #ocals={
 #ey: pretty.traverse(
 #alue,
 #ax_length=locals_max_length,
 #ax_string=locals_max_string,
 #
 #or key, value in get_locals(frame_summary.f_locals.items())
 #
 #f show_locals
 #lse None,
 #
 #ppend(frame)
 #f frame_summary.f_locals.get("_rich_traceback_guard", False):
 #el stack.frames[:]

 #ause = getattr(exc_value, "__cause__", None)
 #f cause:
 #xc_type = cause.__class__
 #xc_value = cause
                # __traceback__ can be None, e.g. for exceptions raised by the
                # 'multiprocessing' module
 #raceback = cause.__traceback__
 #s_cause = True
 #ontinue

 #ause = exc_value.__context__
 #f cause and not getattr(exc_value, "__suppress_context__", False):
 #xc_type = cause.__class__
 #xc_value = cause
 #raceback = cause.__traceback__
 #s_cause = False
 #ontinue
            # No cover, code is reached but coverage doesn't recognize it.
 #reak  # pragma: no cover

 #race = Trace(stacks=stacks)
 #eturn trace

 #ef __rich_console__(
 #elf, console: Console, options: ConsoleOptions
 # -> RenderResult:
 #heme = self.theme
 #ackground_style = theme.get_background_style()
 #oken_style = theme.get_style_for_token

 #raceback_theme = Theme(
 #
 #pretty": token_style(TextToken),
 #pygments.text": token_style(Token),
 #pygments.string": token_style(String),
 #pygments.function": token_style(Name.Function),
 #pygments.number": token_style(Number),
 #repr.indent": token_style(Comment) + Style(dim=True),
 #repr.str": token_style(String),
 #repr.brace": token_style(TextToken) + Style(bold=True),
 #repr.number": token_style(Number),
 #repr.bool_true": token_style(Keyword.Constant),
 #repr.bool_false": token_style(Keyword.Constant),
 #repr.none": token_style(Keyword.Constant),
 #scope.border": token_style(String.Delimiter),
 #scope.equals": token_style(Operator),
 #scope.key": token_style(Name),
 #scope.key.special": token_style(Name.Constant) + Style(dim=True),
 #,
 #nherit=False,
 #

 #ighlighter = ReprHighlighter()
 #or last, stack in loop_last(reversed(self.trace.stacks)):
 #f stack.frames:
 #tack_renderable: ConsoleRenderable = Panel(
 #elf._render_stack(stack),
 #itle="[traceback.title]Traceback [dim](most recent call last)",
 #tyle=background_style,
 #order_style="traceback.border",
 #xpand=True,
 #adding=(0, 1),
 #
 #tack_renderable = Constrain(stack_renderable, self.width)
 #ith console.use_theme(traceback_theme):
 #ield stack_renderable
 #f stack.syntax_error is not None:
 #ith console.use_theme(traceback_theme):
 #ield Constrain(
 #anel(
 #elf._render_syntax_error(stack.syntax_error),
 #tyle=background_style,
 #order_style="traceback.border.syntax_error",
 #xpand=True,
 #adding=(0, 1),
 #idth=self.width,
 #,
 #elf.width,
 #
 #ield Text.assemble(
 #f"{stack.exc_type}: ", "traceback.exc_type"),
 #ighlighter(stack.syntax_error.msg),
 #
 #lif stack.exc_value:
 #ield Text.assemble(
 #f"{stack.exc_type}: ", "traceback.exc_type"),
 #ighlighter(stack.exc_value),
 #
 #lse:
 #ield Text.assemble((f"{stack.exc_type}", "traceback.exc_type"))

 #f not last:
 #f stack.is_cause:
 #ield Text.from_markup(
 #\n[i]The above exception was the direct cause of the following exception:\n",
 #
 #lse:
 #ield Text.from_markup(
 #\n[i]During handling of the above exception, another exception occurred:\n",
 #

 #group()
 #ef _render_syntax_error(self, syntax_error: _SyntaxError) -> RenderResult:
 #ighlighter = ReprHighlighter()
 #ath_highlighter = PathHighlighter()
 #f syntax_error.filename != "<stdin>":
 #f os.path.exists(syntax_error.filename):
 #ext = Text.assemble(
 #f" {syntax_error.filename}", "pygments.string"),
 #":", "pygments.text"),
 #str(syntax_error.lineno), "pygments.number"),
 #tyle="pygments.text",
 #
 #ield path_highlighter(text)
 #yntax_error_text = highlighter(syntax_error.line.rstrip())
 #yntax_error_text.no_wrap = True
 #ffset = min(syntax_error.offset - 1, len(syntax_error_text))
 #yntax_error_text.stylize("bold underline", offset, offset)
 #yntax_error_text += Text.from_markup(
 #\n" + " " * offset + "[traceback.offset]▲[/]",
 #tyle="pygments.text",
 #
 #ield syntax_error_text

 #classmethod
 #ef _guess_lexer(cls, filename: str, code: str) -> str:
 #xt = os.path.splitext(filename)[-1]
 #f not ext:
            # No extension, look at first line to see if it is a hashbang
            # Note, this is an educated guess and not a guarantee
            # If it fails, the only downside is that the code is highlighted strangely
 #ew_line_index = code.index("\n")
 #irst_line = code[:new_line_index] if new_line_index != -1 else code
 #f first_line.startswith("#!") and "python" in first_line.lower():
 #eturn "python"
 #ry:
 #eturn cls.LEXERS.get(ext) or guess_lexer_for_filename(filename, code).name
 #xcept ClassNotFound:
 #eturn "text"

 #group()
 #ef _render_stack(self, stack: Stack) -> RenderResult:
 #ath_highlighter = PathHighlighter()
 #heme = self.theme

 #ef read_code(filename: str) -> str:
 #""Read files, and cache results on filename.

 #rgs:
 #ilename (str): Filename to read

 #eturns:
 #tr: Contents of file
 #""
 #eturn "".join(linecache.getlines(filename))

 #ef render_locals(frame: Frame) -> Iterable[ConsoleRenderable]:
 #f frame.locals:
 #ield render_scope(
 #rame.locals,
 #itle="locals",
 #ndent_guides=self.indent_guides,
 #ax_length=self.locals_max_length,
 #ax_string=self.locals_max_string,
 #

 #xclude_frames: Optional[range] = None
 #f self.max_frames != 0:
 #xclude_frames = range(
 #elf.max_frames // 2,
 #en(stack.frames) - self.max_frames // 2,
 #

 #xcluded = False
 #or frame_index, frame in enumerate(stack.frames):

 #f exclude_frames and frame_index in exclude_frames:
 #xcluded = True
 #ontinue

 #f excluded:
 #ssert exclude_frames is not None
 #ield Text(
 #"\n... {len(exclude_frames)} frames hidden ...",
 #ustify="center",
 #tyle="traceback.error",
 #
 #xcluded = False

 #irst = frame_index == 0
 #rame_filename = frame.filename
 #uppressed = any(frame_filename.startswith(path) for path in self.suppress)

 #f os.path.exists(frame.filename):
 #ext = Text.assemble(
 #ath_highlighter(Text(frame.filename, style="pygments.string")),
 #":", "pygments.text"),
 #str(frame.lineno), "pygments.number"),
 # in ",
 #frame.name, "pygments.function"),
 #tyle="pygments.text",
 #
 #lse:
 #ext = Text.assemble(
 #in ",
 #frame.name, "pygments.function"),
 #":", "pygments.text"),
 #str(frame.lineno), "pygments.number"),
 #tyle="pygments.text",
 #
 #f not frame.filename.startswith("<") and not first:
 #ield ""
 #ield text
 #f frame.filename.startswith("<"):
 #ield from render_locals(frame)
 #ontinue
 #f not suppressed:
 #ry:
 #ode = read_code(frame.filename)
 #f not code:
                        # code may be an empty string if the file doesn't exist, OR
                        # if the traceback filename is generated dynamically
 #ontinue
 #exer_name = self._guess_lexer(frame.filename, code)
 #yntax = Syntax(
 #ode,
 #exer_name,
 #heme=theme,
 #ine_numbers=True,
 #ine_range=(
 #rame.lineno - self.extra_lines,
 #rame.lineno + self.extra_lines,
 #,
 #ighlight_lines={frame.lineno},
 #ord_wrap=self.word_wrap,
 #ode_width=88,
 #ndent_guides=self.indent_guides,
 #edent=False,
 #
 #ield ""
 #xcept Exception as error:
 #ield Text.assemble(
 #f"\n{error}", "traceback.error"),
 #
 #lse:
 #ield (
 #olumns(
 #
 #yntax,
 #render_locals(frame),
 #,
 #adding=1,
 #
 #f frame.locals
 #lse syntax
 #


if __name__ == "__main__":  # pragma: no cover

 #rom .console import Console

 #onsole = Console()
 #mport sys

 #ef bar(a: Any) -> None:  # 这是对亚洲语言支持的测试。面对模棱两可的想法，拒绝猜测的诱惑
 #ne = 1
 #rint(one / a)

 #ef foo(a: Any) -> None:
 #rich_traceback_guard = True
 #ed = {
 #characters": {
 #Paul Atreides",
 #Vladimir Harkonnen",
 #Thufir Hawat",
 #Duncan Idaho",
 #,
 #atomic_types": (None, False, True),
 #
 #ar(a)

 #ef error() -> None:

 #ry:
 #ry:
 #oo(0)
 #xcept:
 #lfkjsldkfj  # type: ignore[name-defined]
 #xcept:
 #onsole.print_exception(show_locals=True)

 #rror()
