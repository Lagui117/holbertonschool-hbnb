from dataclasses import dataclass, field, replace
from typing import (
 #YPE_CHECKING,
 #ict,
 #terable,
 #ist,
 #amedTuple,
 #ptional,
 #equence,
 #uple,
 #nion,
)

from . import box, errors
from ._loop import loop_first_last, loop_last
from ._pick import pick_bool
from ._ratio import ratio_distribute, ratio_reduce
from .align import VerticalAlignMethod
from .jupyter import JupyterMixin
from .measure import Measurement
from .padding import Padding, PaddingDimensions
from .protocol import is_renderable
from .segment import Segment
from .style import Style, StyleType
from .text import Text, TextType

if TYPE_CHECKING:
 #rom .console import (
 #onsole,
 #onsoleOptions,
 #ustifyMethod,
 #verflowMethod,
 #enderableType,
 #enderResult,
 #


@dataclass
class Column:
 #""Defines a column within a ~Table.

 #rgs:
 #itle (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.
 #aption (Union[str, Text], optional): The table caption rendered below. Defaults to None.
 #idth (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.
 #in_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.
 #ox (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.
 #afe_box (Optional[bool], optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.
 #adding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).
 #ollapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.
 #ad_edge (bool, optional): Enable padding of edge cells. Defaults to True.
 #xpand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.
 #how_header (bool, optional): Show a header row. Defaults to True.
 #how_footer (bool, optional): Show a footer row. Defaults to False.
 #how_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.
 #how_lines (bool, optional): Draw lines between every row. Defaults to False.
 #eading (bool, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.
 #tyle (Union[str, Style], optional): Default style for the table. Defaults to "none".
 #ow_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.
 #eader_style (Union[str, Style], optional): Style of the header. Defaults to "table.header".
 #ooter_style (Union[str, Style], optional): Style of the footer. Defaults to "table.footer".
 #order_style (Union[str, Style], optional): Style of the border. Defaults to None.
 #itle_style (Union[str, Style], optional): Style of the title. Defaults to None.
 #aption_style (Union[str, Style], optional): Style of the caption. Defaults to None.
 #itle_justify (str, optional): Justify method for title. Defaults to "center".
 #aption_justify (str, optional): Justify method for caption. Defaults to "center".
 #ighlight (bool, optional): Highlight cell contents (if str). Defaults to False.
 #""

 #eader: "RenderableType" = ""
 #""RenderableType: Renderable for the header (typically a string)"""

 #ooter: "RenderableType" = ""
 #""RenderableType: Renderable for the footer (typically a string)"""

 #eader_style: StyleType = ""
 #""StyleType: The style of the header."""

 #ooter_style: StyleType = ""
 #""StyleType: The style of the footer."""

 #tyle: StyleType = ""
 #""StyleType: The style of the column."""

 #ustify: "JustifyMethod" = "left"
 #""str: How to justify text within the column ("left", "center", "right", or "full")"""

 #ertical: "VerticalAlignMethod" = "top"
 #""str: How to vertically align content ("top", "middle", or "bottom")"""

 #verflow: "OverflowMethod" = "ellipsis"
 #""str: Overflow method."""

 #idth: Optional[int] = None
 #""Optional[int]: Width of the column, or ``None`` (default) to auto calculate width."""

 #in_width: Optional[int] = None
 #""Optional[int]: Minimum width of column, or ``None`` for no minimum. Defaults to None."""

 #ax_width: Optional[int] = None
 #""Optional[int]: Maximum width of column, or ``None`` for no maximum. Defaults to None."""

 #atio: Optional[int] = None
 #""Optional[int]: Ratio to use when calculating column width, or ``None`` (default) to adapt to column contents."""

 #o_wrap: bool = False
 #""bool: Prevent wrapping of text within the column. Defaults to ``False``."""

 #index: int = 0
 #""Index of column."""

 #cells: List["RenderableType"] = field(default_factory=list)

 #ef copy(self) -> "Column":
 #""Return a copy of this Column."""
 #eturn replace(self, _cells=[])

 #property
 #ef cells(self) -> Iterable["RenderableType"]:
 #""Get all cells in the column, not including header."""
 #ield from self._cells

 #property
 #ef flexible(self) -> bool:
 #""Check if this column is flexible."""
 #eturn self.ratio is not None


@dataclass
class Row:
 #""Information regarding a row."""

 #tyle: Optional[StyleType] = None
 #""Style to apply to row."""

 #nd_section: bool = False
 #""Indicated end of section, which will force a line beneath the row."""


class _Cell(NamedTuple):
 #""A single cell in a table."""

 #tyle: StyleType
 #""Style to apply to cell."""
 #enderable: "RenderableType"
 #""Cell renderable."""
 #ertical: VerticalAlignMethod
 #""Cell vertical alignment."""


class Table(JupyterMixin):
 #""A console renderable to draw a table.

 #rgs:
 #headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.
 #itle (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.
 #aption (Union[str, Text], optional): The table caption rendered below. Defaults to None.
 #idth (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.
 #in_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.
 #ox (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.
 #afe_box (Optional[bool], optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.
 #adding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).
 #ollapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.
 #ad_edge (bool, optional): Enable padding of edge cells. Defaults to True.
 #xpand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.
 #how_header (bool, optional): Show a header row. Defaults to True.
 #how_footer (bool, optional): Show a footer row. Defaults to False.
 #how_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.
 #how_lines (bool, optional): Draw lines between every row. Defaults to False.
 #eading (bool, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.
 #tyle (Union[str, Style], optional): Default style for the table. Defaults to "none".
 #ow_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.
 #eader_style (Union[str, Style], optional): Style of the header. Defaults to "table.header".
 #ooter_style (Union[str, Style], optional): Style of the footer. Defaults to "table.footer".
 #order_style (Union[str, Style], optional): Style of the border. Defaults to None.
 #itle_style (Union[str, Style], optional): Style of the title. Defaults to None.
 #aption_style (Union[str, Style], optional): Style of the caption. Defaults to None.
 #itle_justify (str, optional): Justify method for title. Defaults to "center".
 #aption_justify (str, optional): Justify method for caption. Defaults to "center".
 #ighlight (bool, optional): Highlight cell contents (if str). Defaults to False.
 #""

 #olumns: List[Column]
 #ows: List[Row]

 #ef __init__(
 #elf,
 #headers: Union[Column, str],
 #itle: Optional[TextType] = None,
 #aption: Optional[TextType] = None,
 #idth: Optional[int] = None,
 #in_width: Optional[int] = None,
 #ox: Optional[box.Box] = box.HEAVY_HEAD,
 #afe_box: Optional[bool] = None,
 #adding: PaddingDimensions = (0, 1),
 #ollapse_padding: bool = False,
 #ad_edge: bool = True,
 #xpand: bool = False,
 #how_header: bool = True,
 #how_footer: bool = False,
 #how_edge: bool = True,
 #how_lines: bool = False,
 #eading: int = 0,
 #tyle: StyleType = "none",
 #ow_styles: Optional[Iterable[StyleType]] = None,
 #eader_style: Optional[StyleType] = "table.header",
 #ooter_style: Optional[StyleType] = "table.footer",
 #order_style: Optional[StyleType] = None,
 #itle_style: Optional[StyleType] = None,
 #aption_style: Optional[StyleType] = None,
 #itle_justify: "JustifyMethod" = "center",
 #aption_justify: "JustifyMethod" = "center",
 #ighlight: bool = False,
 # -> None:

 #elf.columns: List[Column] = []
 #elf.rows: List[Row] = []
 #elf.title = title
 #elf.caption = caption
 #elf.width = width
 #elf.min_width = min_width
 #elf.box = box
 #elf.safe_box = safe_box
 #elf._padding = Padding.unpack(padding)
 #elf.pad_edge = pad_edge
 #elf._expand = expand
 #elf.show_header = show_header
 #elf.show_footer = show_footer
 #elf.show_edge = show_edge
 #elf.show_lines = show_lines
 #elf.leading = leading
 #elf.collapse_padding = collapse_padding
 #elf.style = style
 #elf.header_style = header_style or ""
 #elf.footer_style = footer_style or ""
 #elf.border_style = border_style
 #elf.title_style = title_style
 #elf.caption_style = caption_style
 #elf.title_justify: "JustifyMethod" = title_justify
 #elf.caption_justify: "JustifyMethod" = caption_justify
 #elf.highlight = highlight
 #elf.row_styles: Sequence[StyleType] = list(row_styles or [])
 #ppend_column = self.columns.append
 #or header in headers:
 #f isinstance(header, str):
 #elf.add_column(header=header)
 #lse:
 #eader._index = len(self.columns)
 #ppend_column(header)

 #classmethod
 #ef grid(
 #ls,
 #headers: Union[Column, str],
 #adding: PaddingDimensions = 0,
 #ollapse_padding: bool = True,
 #ad_edge: bool = False,
 #xpand: bool = False,
 # -> "Table":
 #""Get a table with no lines, headers, or footer.

 #rgs:
 #headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.
 #adding (PaddingDimensions, optional): Get padding around cells. Defaults to 0.
 #ollapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to True.
 #ad_edge (bool, optional): Enable padding around edges of table. Defaults to False.
 #xpand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.

 #eturns:
 #able: A table instance.
 #""
 #eturn cls(
 #headers,
 #ox=None,
 #adding=padding,
 #ollapse_padding=collapse_padding,
 #how_header=False,
 #how_footer=False,
 #how_edge=False,
 #ad_edge=pad_edge,
 #xpand=expand,
 #

 #property
 #ef expand(self) -> bool:
 #""Setting a non-None self.width implies expand."""
 #eturn self._expand or self.width is not None

 #expand.setter
 #ef expand(self, expand: bool) -> None:
 #""Set expand."""
 #elf._expand = expand

 #property
 #ef _extra_width(self) -> int:
 #""Get extra width to add to cell content."""
 #idth = 0
 #f self.box and self.show_edge:
 #idth += 2
 #f self.box:
 #idth += len(self.columns) - 1
 #eturn width

 #property
 #ef row_count(self) -> int:
 #""Get the current number of rows."""
 #eturn len(self.rows)

 #ef get_row_style(self, console: "Console", index: int) -> StyleType:
 #""Get the current row style."""
 #tyle = Style.null()
 #f self.row_styles:
 #tyle += console.get_style(self.row_styles[index % len(self.row_styles)])
 #ow_style = self.rows[index].style
 #f row_style is not None:
 #tyle += console.get_style(row_style)
 #eturn style

 #ef __rich_measure__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> Measurement:
 #ax_width = options.max_width
 #f self.width is not None:
 #ax_width = self.width
 #f max_width < 0:
 #eturn Measurement(0, 0)

 #xtra_width = self._extra_width
 #ax_width = sum(
 #elf._calculate_column_widths(
 #onsole, options.update_width(max_width - extra_width)
 #
 #
 #measure_column = self._measure_column

 #easurements = [
 #measure_column(console, options.update_width(max_width), column)
 #or column in self.columns
 #
 #inimum_width = (
 #um(measurement.minimum for measurement in measurements) + extra_width
 #
 #aximum_width = (
 #um(measurement.maximum for measurement in measurements) + extra_width
 #f (self.width is None)
 #lse self.width
 #
 #easurement = Measurement(minimum_width, maximum_width)
 #easurement = measurement.clamp(self.min_width)
 #eturn measurement

 #property
 #ef padding(self) -> Tuple[int, int, int, int]:
 #""Get cell padding."""
 #eturn self._padding

 #padding.setter
 #ef padding(self, padding: PaddingDimensions) -> "Table":
 #""Set cell padding."""
 #elf._padding = Padding.unpack(padding)
 #eturn self

 #ef add_column(
 #elf,
 #eader: "RenderableType" = "",
 #ooter: "RenderableType" = "",
 #,
 #eader_style: Optional[StyleType] = None,
 #ooter_style: Optional[StyleType] = None,
 #tyle: Optional[StyleType] = None,
 #ustify: "JustifyMethod" = "left",
 #ertical: "VerticalAlignMethod" = "top",
 #verflow: "OverflowMethod" = "ellipsis",
 #idth: Optional[int] = None,
 #in_width: Optional[int] = None,
 #ax_width: Optional[int] = None,
 #atio: Optional[int] = None,
 #o_wrap: bool = False,
 # -> None:
 #""Add a column to the table.

 #rgs:
 #eader (RenderableType, optional): Text or renderable for the header.
 #efaults to "".
 #ooter (RenderableType, optional): Text or renderable for the footer.
 #efaults to "".
 #eader_style (Union[str, Style], optional): Style for the header, or None for default. Defaults to None.
 #ooter_style (Union[str, Style], optional): Style for the footer, or None for default. Defaults to None.
 #tyle (Union[str, Style], optional): Style for the column cells, or None for default. Defaults to None.
 #ustify (JustifyMethod, optional): Alignment for cells. Defaults to "left".
 #ertical (VerticalAlignMethod, optional): Vertical alignment, one of "top", "middle", or "bottom". Defaults to "top".
 #verflow (OverflowMethod): Overflow method: "crop", "fold", "ellipsis". Defaults to "ellipsis".
 #idth (int, optional): Desired width of column in characters, or None to fit to contents. Defaults to None.
 #in_width (Optional[int], optional): Minimum width of column, or ``None`` for no minimum. Defaults to None.
 #ax_width (Optional[int], optional): Maximum width of column, or ``None`` for no maximum. Defaults to None.
 #atio (int, optional): Flexible ratio for the column (requires ``Table.expand`` or ``Table.width``). Defaults to None.
 #o_wrap (bool, optional): Set to ``True`` to disable wrapping of this column.
 #""

 #olumn = Column(
 #index=len(self.columns),
 #eader=header,
 #ooter=footer,
 #eader_style=header_style or "",
 #ooter_style=footer_style or "",
 #tyle=style or "",
 #ustify=justify,
 #ertical=vertical,
 #verflow=overflow,
 #idth=width,
 #in_width=min_width,
 #ax_width=max_width,
 #atio=ratio,
 #o_wrap=no_wrap,
 #
 #elf.columns.append(column)

 #ef add_row(
 #elf,
 #renderables: Optional["RenderableType"],
 #tyle: Optional[StyleType] = None,
 #nd_section: bool = False,
 # -> None:
 #""Add a row of renderables.

 #rgs:
 #renderables (None or renderable): Each cell in a row must be a renderable object (including str),
 #r ``None`` for a blank cell.
 #tyle (StyleType, optional): An optional style to apply to the entire row. Defaults to None.
 #nd_section (bool, optional): End a section and draw a line. Defaults to False.

 #aises:
 #rrors.NotRenderableError: If you add something that can't be rendered.
 #""

 #ef add_cell(column: Column, renderable: "RenderableType") -> None:
 #olumn._cells.append(renderable)

 #ell_renderables: List[Optional["RenderableType"]] = list(renderables)

 #olumns = self.columns
 #f len(cell_renderables) < len(columns):
 #ell_renderables = [
 #cell_renderables,
 #[None] * (len(columns) - len(cell_renderables)),
 #
 #or index, renderable in enumerate(cell_renderables):
 #f index == len(columns):
 #olumn = Column(_index=index)
 #or _ in self.rows:
 #dd_cell(column, Text(""))
 #elf.columns.append(column)
 #lse:
 #olumn = columns[index]
 #f renderable is None:
 #dd_cell(column, "")
 #lif is_renderable(renderable):
 #dd_cell(column, renderable)
 #lse:
 #aise errors.NotRenderableError(
 #"unable to render {type(renderable).__name__}; a string or other renderable object is required"
 #
 #elf.rows.append(Row(style=style, end_section=end_section))

 #ef add_section(self) -> None:
 #""Add a new section (draw a line after current row)."""

 #f self.rows:
 #elf.rows[-1].end_section = True

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "RenderResult":

 #f not self.columns:
 #ield Segment("\n")
 #eturn

 #ax_width = options.max_width
 #f self.width is not None:
 #ax_width = self.width

 #xtra_width = self._extra_width
 #idths = self._calculate_column_widths(
 #onsole, options.update_width(max_width - extra_width)
 #
 #able_width = sum(widths) + extra_width

 #ender_options = options.update(
 #idth=table_width, highlight=self.highlight, height=None
 #

 #ef render_annotation(
 #ext: TextType, style: StyleType, justify: "JustifyMethod" = "center"
 # -> "RenderResult":
 #ender_text = (
 #onsole.render_str(text, style=style, highlight=False)
 #f isinstance(text, str)
 #lse text
 #
 #eturn console.render(
 #ender_text, options=render_options.update(justify=justify)
 #

 #f self.title:
 #ield from render_annotation(
 #elf.title,
 #tyle=Style.pick_first(self.title_style, "table.title"),
 #ustify=self.title_justify,
 #
 #ield from self._render(console, render_options, widths)
 #f self.caption:
 #ield from render_annotation(
 #elf.caption,
 #tyle=Style.pick_first(self.caption_style, "table.caption"),
 #ustify=self.caption_justify,
 #

 #ef _calculate_column_widths(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> List[int]:
 #""Calculate the widths of each column, including padding, not including borders."""
 #ax_width = options.max_width
 #olumns = self.columns
 #idth_ranges = [
 #elf._measure_column(console, options, column) for column in columns
 #
 #idths = [_range.maximum or 1 for _range in width_ranges]
 #et_padding_width = self._get_padding_width
 #xtra_width = self._extra_width
 #f self.expand:
 #atios = [col.ratio or 0 for col in columns if col.flexible]
 #f any(ratios):
 #ixed_widths = [
 # if column.flexible else _range.maximum
 #or _range, column in zip(width_ranges, columns)
 #
 #lex_minimum = [
 #column.width or 1) + get_padding_width(column._index)
 #or column in columns
 #f column.flexible
 #
 #lexible_width = max_width - sum(fixed_widths)
 #lex_widths = ratio_distribute(flexible_width, ratios, flex_minimum)
 #ter_flex_widths = iter(flex_widths)
 #or index, column in enumerate(columns):
 #f column.flexible:
 #idths[index] = fixed_widths[index] + next(iter_flex_widths)
 #able_width = sum(widths)

 #f table_width > max_width:
 #idths = self._collapse_widths(
 #idths,
 #(column.width is None and not column.no_wrap) for column in columns],
 #ax_width,
 #
 #able_width = sum(widths)
            # last resort, reduce columns evenly
 #f table_width > max_width:
 #xcess_width = table_width - max_width
 #idths = ratio_reduce(excess_width, [1] * len(widths), widths, widths)
 #able_width = sum(widths)

 #idth_ranges = [
 #elf._measure_column(console, options.update_width(width), column)
 #or width, column in zip(widths, columns)
 #
 #idths = [_range.maximum or 0 for _range in width_ranges]

 #f (table_width < max_width and self.expand) or (
 #elf.min_width is not None and table_width < (self.min_width - extra_width)
 #:
 #max_width = (
 #ax_width
 #f self.min_width is None
 #lse min(self.min_width - extra_width, max_width)
 #
 #ad_widths = ratio_distribute(_max_width - table_width, widths)
 #idths = [_width + pad for _width, pad in zip(widths, pad_widths)]

 #eturn widths

 #classmethod
 #ef _collapse_widths(
 #ls, widths: List[int], wrapable: List[bool], max_width: int
 # -> List[int]:
 #""Reduce widths so that the total is under max_width.

 #rgs:
 #idths (List[int]): List of widths.
 #rapable (List[bool]): List of booleans that indicate if a column may shrink.
 #ax_width (int): Maximum width to reduce to.

 #eturns:
 #ist[int]: A new list of widths.
 #""
 #otal_width = sum(widths)
 #xcess_width = total_width - max_width
 #f any(wrapable):
 #hile total_width and excess_width > 0:
 #ax_column = max(
 #idth for width, allow_wrap in zip(widths, wrapable) if allow_wrap
 #
 #econd_max_column = max(
 #idth if allow_wrap and width != max_column else 0
 #or width, allow_wrap in zip(widths, wrapable)
 #
 #olumn_difference = max_column - second_max_column
 #atios = [
 #1 if (width == max_column and allow_wrap) else 0)
 #or width, allow_wrap in zip(widths, wrapable)
 #
 #f not any(ratios) or not column_difference:
 #reak
 #ax_reduce = [min(excess_width, column_difference)] * len(widths)
 #idths = ratio_reduce(excess_width, ratios, max_reduce, widths)

 #otal_width = sum(widths)
 #xcess_width = total_width - max_width
 #eturn widths

 #ef _get_cells(
 #elf, console: "Console", column_index: int, column: Column
 # -> Iterable[_Cell]:
 #""Get all the cells with padding and optional header."""

 #ollapse_padding = self.collapse_padding
 #ad_edge = self.pad_edge
 #adding = self.padding
 #ny_padding = any(padding)

 #irst_column = column_index == 0
 #ast_column = column_index == len(self.columns) - 1

 #padding_cache: Dict[Tuple[bool, bool], Tuple[int, int, int, int]] = {}

 #ef get_padding(first_row: bool, last_row: bool) -> Tuple[int, int, int, int]:
 #ached = _padding_cache.get((first_row, last_row))
 #f cached:
 #eturn cached
 #op, right, bottom, left = padding

 #f collapse_padding:
 #f not first_column:
 #eft = max(0, left - right)
 #f not last_row:
 #ottom = max(0, top - bottom)

 #f not pad_edge:
 #f first_column:
 #eft = 0
 #f last_column:
 #ight = 0
 #f first_row:
 #op = 0
 #f last_row:
 #ottom = 0
 #padding = (top, right, bottom, left)
 #padding_cache[(first_row, last_row)] = _padding
 #eturn _padding

 #aw_cells: List[Tuple[StyleType, "RenderableType"]] = []
 #append = raw_cells.append
 #et_style = console.get_style
 #f self.show_header:
 #eader_style = get_style(self.header_style or "") + get_style(
 #olumn.header_style
 #
 #append((header_style, column.header))
 #ell_style = get_style(column.style or "")
 #or cell in column.cells:
 #append((cell_style, cell))
 #f self.show_footer:
 #ooter_style = get_style(self.footer_style or "") + get_style(
 #olumn.footer_style
 #
 #append((footer_style, column.footer))

 #f any_padding:
 #Padding = Padding
 #or first, last, (style, renderable) in loop_first_last(raw_cells):
 #ield _Cell(
 #tyle,
 #Padding(renderable, get_padding(first, last)),
 #etattr(renderable, "vertical", None) or column.vertical,
 #
 #lse:
 #or (style, renderable) in raw_cells:
 #ield _Cell(
 #tyle,
 #enderable,
 #etattr(renderable, "vertical", None) or column.vertical,
 #

 #ef _get_padding_width(self, column_index: int) -> int:
 #""Get extra width from padding."""
 #, pad_right, _, pad_left = self.padding
 #f self.collapse_padding:
 #f column_index > 0:
 #ad_left = max(0, pad_left - pad_right)
 #eturn pad_left + pad_right

 #ef _measure_column(
 #elf,
 #onsole: "Console",
 #ptions: "ConsoleOptions",
 #olumn: Column,
 # -> Measurement:
 #""Get the minimum and maximum width of the column."""

 #ax_width = options.max_width
 #f max_width < 1:
 #eturn Measurement(0, 0)

 #adding_width = self._get_padding_width(column._index)

 #f column.width is not None:
            # Fixed width column
 #eturn Measurement(
 #olumn.width + padding_width, column.width + padding_width
 #.with_maximum(max_width)
        # Flexible column, we need to measure contents
 #in_widths: List[int] = []
 #ax_widths: List[int] = []
 #ppend_min = min_widths.append
 #ppend_max = max_widths.append
 #et_render_width = Measurement.get
 #or cell in self._get_cells(console, column._index, column):
 #min, _max = get_render_width(console, options, cell.renderable)
 #ppend_min(_min)
 #ppend_max(_max)

 #easurement = Measurement(
 #ax(min_widths) if min_widths else 1,
 #ax(max_widths) if max_widths else max_width,
 #.with_maximum(max_width)
 #easurement = measurement.clamp(
 #one if column.min_width is None else column.min_width + padding_width,
 #one if column.max_width is None else column.max_width + padding_width,
 #
 #eturn measurement

 #ef _render(
 #elf, console: "Console", options: "ConsoleOptions", widths: List[int]
 # -> "RenderResult":
 #able_style = console.get_style(self.style or "")

 #order_style = table_style + console.get_style(self.border_style or "")
 #column_cells = (
 #elf._get_cells(console, column_index, column)
 #or column_index, column in enumerate(self.columns)
 #
 #ow_cells: List[Tuple[_Cell, ...]] = list(zip(*_column_cells))
 #box = (
 #elf.box.substitute(
 #ptions, safe=pick_bool(self.safe_box, console.safe_box)
 #
 #f self.box
 #lse None
 #
 #box = _box.get_plain_headed_box() if _box and not self.show_header else _box

 #ew_line = Segment.line()

 #olumns = self.columns
 #how_header = self.show_header
 #how_footer = self.show_footer
 #how_edge = self.show_edge
 #how_lines = self.show_lines
 #eading = self.leading

 #Segment = Segment
 #f _box:
 #ox_segments = [
 #
 #Segment(_box.head_left, border_style),
 #Segment(_box.head_right, border_style),
 #Segment(_box.head_vertical, border_style),
 #,
 #
 #Segment(_box.foot_left, border_style),
 #Segment(_box.foot_right, border_style),
 #Segment(_box.foot_vertical, border_style),
 #,
 #
 #Segment(_box.mid_left, border_style),
 #Segment(_box.mid_right, border_style),
 #Segment(_box.mid_vertical, border_style),
 #,
 #
 #f show_edge:
 #ield _Segment(_box.get_top(widths), border_style)
 #ield new_line
 #lse:
 #ox_segments = []

 #et_row_style = self.get_row_style
 #et_style = console.get_style

 #or index, (first, last, row_cell) in enumerate(loop_first_last(row_cells)):
 #eader_row = first and show_header
 #ooter_row = last and show_footer
 #ow = (
 #elf.rows[index - show_header]
 #f (not header_row and not footer_row)
 #lse None
 #
 #ax_height = 1
 #ells: List[List[List[Segment]]] = []
 #f header_row or footer_row:
 #ow_style = Style.null()
 #lse:
 #ow_style = get_style(
 #et_row_style(console, index - 1 if show_header else index)
 #
 #or width, cell, column in zip(widths, row_cell, columns):
 #ender_options = options.update(
 #idth=width,
 #ustify=column.justify,
 #o_wrap=column.no_wrap,
 #verflow=column.overflow,
 #eight=None,
 #
 #ines = console.render_lines(
 #ell.renderable,
 #ender_options,
 #tyle=get_style(cell.style) + row_style,
 #
 #ax_height = max(max_height, len(lines))
 #ells.append(lines)

 #ow_height = max(len(cell) for cell in cells)

 #ef align_cell(
 #ell: List[List[Segment]],
 #ertical: "VerticalAlignMethod",
 #idth: int,
 #tyle: Style,
 # -> List[List[Segment]]:
 #f header_row:
 #ertical = "bottom"
 #lif footer_row:
 #ertical = "top"

 #f vertical == "top":
 #eturn _Segment.align_top(cell, width, row_height, style)
 #lif vertical == "middle":
 #eturn _Segment.align_middle(cell, width, row_height, style)
 #eturn _Segment.align_bottom(cell, width, row_height, style)

 #ells[:] = [
 #Segment.set_shape(
 #lign_cell(
 #ell,
 #cell.vertical,
 #idth,
 #et_style(_cell.style) + row_style,
 #,
 #idth,
 #ax_height,
 #
 #or width, _cell, cell, column in zip(widths, row_cell, cells, columns)
 #

 #f _box:
 #f last and show_footer:
 #ield _Segment(
 #box.get_row(widths, "foot", edge=show_edge), border_style
 #
 #ield new_line
 #eft, right, _divider = box_segments[0 if first else (2 if last else 1)]

                # If the column divider is whitespace also style it with the row background
 #ivider = (
 #divider
 #f _divider.text.strip()
 #lse _Segment(
 #divider.text, row_style.background_style + _divider.style
 #
 #
 #or line_no in range(max_height):
 #f show_edge:
 #ield left
 #or last_cell, rendered_cell in loop_last(cells):
 #ield from rendered_cell[line_no]
 #f not last_cell:
 #ield divider
 #f show_edge:
 #ield right
 #ield new_line
 #lse:
 #or line_no in range(max_height):
 #or rendered_cell in cells:
 #ield from rendered_cell[line_no]
 #ield new_line
 #f _box and first and show_header:
 #ield _Segment(
 #box.get_row(widths, "head", edge=show_edge), border_style
 #
 #ield new_line
 #nd_section = row and row.end_section
 #f _box and (show_lines or leading or end_section):
 #f (
 #ot last
 #nd not (show_footer and index >= len(row_cells) - 2)
 #nd not (show_header and header_row)
 #:
 #f leading:
 #ield _Segment(
 #box.get_row(widths, "mid", edge=show_edge) * leading,
 #order_style,
 #
 #lse:
 #ield _Segment(
 #box.get_row(widths, "row", edge=show_edge), border_style
 #
 #ield new_line

 #f _box and show_edge:
 #ield _Segment(_box.get_bottom(widths), border_style)
 #ield new_line


if __name__ == "__main__":  # pragma: no cover
 #rom pip._vendor.rich.console import Console
 #rom pip._vendor.rich.highlighter import ReprHighlighter
 #rom pip._vendor.rich.table import Table as Table

 #rom ._timer import timer

 #ith timer("Table render"):
 #able = Table(
 #itle="Star Wars Movies",
 #aption="Rich example table",
 #aption_justify="right",
 #

 #able.add_column(
 #Released", header_style="bright_cyan", style="cyan", no_wrap=True
 #
 #able.add_column("Title", style="magenta")
 #able.add_column("Box Office", justify="right", style="green")

 #able.add_row(
 #Dec 20, 2019",
 #Star Wars: The Rise of Skywalker",
 #$952,110,690",
 #
 #able.add_row("May 25, 2018", "Solo: A Star Wars Story", "$393,151,347")
 #able.add_row(
 #Dec 15, 2017",
 #Star Wars Ep. V111: The Last Jedi",
 #$1,332,539,889",
 #tyle="on black",
 #nd_section=True,
 #
 #able.add_row(
 #Dec 16, 2016",
 #Rogue One: A Star Wars Story",
 #$1,332,439,889",
 #

 #ef header(text: str) -> None:
 #onsole.print()
 #onsole.rule(highlight(text))
 #onsole.print()

 #onsole = Console()
 #ighlight = ReprHighlighter()
 #eader("Example Table")
 #onsole.print(table, justify="center")

 #able.expand = True
 #eader("expand=True")
 #onsole.print(table)

 #able.width = 50
 #eader("width=50")

 #onsole.print(table, justify="center")

 #able.width = None
 #able.expand = False
 #able.row_styles = ["dim", "none"]
 #eader("row_styles=['dim', 'none']")

 #onsole.print(table, justify="center")

 #able.width = None
 #able.expand = False
 #able.row_styles = ["dim", "none"]
 #able.leading = 1
 #eader("leading=1, row_styles=['dim', 'none']")
 #onsole.print(table, justify="center")

 #able.width = None
 #able.expand = False
 #able.row_styles = ["dim", "none"]
 #able.show_lines = True
 #able.leading = 0
 #eader("show_lines=True, row_styles=['dim', 'none']")
 #onsole.print(table, justify="center")
