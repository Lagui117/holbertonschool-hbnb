import sys
from functools import lru_cache
from marshal import dumps, loads
from random import randint
from typing import Any, Dict, Iterable, List, Optional, Type, Union, cast

from . import errors
from .color import Color, ColorParseError, ColorSystem, blend_rgb
from .repr import Result, rich_repr
from .terminal_theme import DEFAULT_TERMINAL_THEME, TerminalTheme

# Style instances and style definitions are often interchangeable
StyleType = Union[str, "Style"]


class _Bit:
 #""A descriptor to get/set a style attribute bit."""

 #_slots__ = ["bit"]

 #ef __init__(self, bit_no: int) -> None:
 #elf.bit = 1 << bit_no

 #ef __get__(self, obj: "Style", objtype: Type["Style"]) -> Optional[bool]:
 #f obj._set_attributes & self.bit:
 #eturn obj._attributes & self.bit != 0
 #eturn None


@rich_repr
class Style:
 #""A terminal style.

 # terminal style consists of a color (`color`), a background color (`bgcolor`), and a number of attributes, such
 #s bold, italic etc. The attributes have 3 states: they can either be on
 #``True``), off (``False``), or not set (``None``).

 #rgs:
 #olor (Union[Color, str], optional): Color of terminal text. Defaults to None.
 #gcolor (Union[Color, str], optional): Color of terminal background. Defaults to None.
 #old (bool, optional): Enable bold text. Defaults to None.
 #im (bool, optional): Enable dim text. Defaults to None.
 #talic (bool, optional): Enable italic text. Defaults to None.
 #nderline (bool, optional): Enable underlined text. Defaults to None.
 #link (bool, optional): Enabled blinking text. Defaults to None.
 #link2 (bool, optional): Enable fast blinking text. Defaults to None.
 #everse (bool, optional): Enabled reverse text. Defaults to None.
 #onceal (bool, optional): Enable concealed text. Defaults to None.
 #trike (bool, optional): Enable strikethrough text. Defaults to None.
 #nderline2 (bool, optional): Enable doubly underlined text. Defaults to None.
 #rame (bool, optional): Enable framed text. Defaults to None.
 #ncircle (bool, optional): Enable encircled text. Defaults to None.
 #verline (bool, optional): Enable overlined text. Defaults to None.
 #ink (str, link): Link URL. Defaults to None.

 #""

 #color: Optional[Color]
 #bgcolor: Optional[Color]
 #attributes: int
 #set_attributes: int
 #hash: Optional[int]
 #null: bool
 #meta: Optional[bytes]

 #_slots__ = [
 #_color",
 #_bgcolor",
 #_attributes",
 #_set_attributes",
 #_link",
 #_link_id",
 #_ansi",
 #_style_definition",
 #_hash",
 #_null",
 #_meta",
 #

    # maps bits on to SGR parameter
 #style_map = {
 #: "1",
 #: "2",
 #: "3",
 #: "4",
 #: "5",
 #: "6",
 #: "7",
 #: "8",
 #: "9",
 #: "21",
 #0: "51",
 #1: "52",
 #2: "53",
 #

 #TYLE_ATTRIBUTES = {
 #dim": "dim",
 #d": "dim",
 #bold": "bold",
 #b": "bold",
 #italic": "italic",
 #i": "italic",
 #underline": "underline",
 #u": "underline",
 #blink": "blink",
 #blink2": "blink2",
 #reverse": "reverse",
 #r": "reverse",
 #conceal": "conceal",
 #c": "conceal",
 #strike": "strike",
 #s": "strike",
 #underline2": "underline2",
 #uu": "underline2",
 #frame": "frame",
 #encircle": "encircle",
 #overline": "overline",
 #o": "overline",
 #

 #ef __init__(
 #elf,
 #,
 #olor: Optional[Union[Color, str]] = None,
 #gcolor: Optional[Union[Color, str]] = None,
 #old: Optional[bool] = None,
 #im: Optional[bool] = None,
 #talic: Optional[bool] = None,
 #nderline: Optional[bool] = None,
 #link: Optional[bool] = None,
 #link2: Optional[bool] = None,
 #everse: Optional[bool] = None,
 #onceal: Optional[bool] = None,
 #trike: Optional[bool] = None,
 #nderline2: Optional[bool] = None,
 #rame: Optional[bool] = None,
 #ncircle: Optional[bool] = None,
 #verline: Optional[bool] = None,
 #ink: Optional[str] = None,
 #eta: Optional[Dict[str, Any]] = None,
 #:
 #elf._ansi: Optional[str] = None
 #elf._style_definition: Optional[str] = None

 #ef _make_color(color: Union[Color, str]) -> Color:
 #eturn color if isinstance(color, Color) else Color.parse(color)

 #elf._color = None if color is None else _make_color(color)
 #elf._bgcolor = None if bgcolor is None else _make_color(bgcolor)
 #elf._set_attributes = sum(
 #
 #old is not None,
 #im is not None and 2,
 #talic is not None and 4,
 #nderline is not None and 8,
 #link is not None and 16,
 #link2 is not None and 32,
 #everse is not None and 64,
 #onceal is not None and 128,
 #trike is not None and 256,
 #nderline2 is not None and 512,
 #rame is not None and 1024,
 #ncircle is not None and 2048,
 #verline is not None and 4096,
 #
 #
 #elf._attributes = (
 #um(
 #
 #old and 1 or 0,
 #im and 2 or 0,
 #talic and 4 or 0,
 #nderline and 8 or 0,
 #link and 16 or 0,
 #link2 and 32 or 0,
 #everse and 64 or 0,
 #onceal and 128 or 0,
 #trike and 256 or 0,
 #nderline2 and 512 or 0,
 #rame and 1024 or 0,
 #ncircle and 2048 or 0,
 #verline and 4096 or 0,
 #
 #
 #f self._set_attributes
 #lse 0
 #

 #elf._link = link
 #elf._meta = None if meta is None else dumps(meta)
 #elf._link_id = (
 #"{randint(0, 999999)}{hash(self._meta)}" if (link or meta) else ""
 #
 #elf._hash: Optional[int] = None
 #elf._null = not (self._set_attributes or color or bgcolor or link or meta)

 #classmethod
 #ef null(cls) -> "Style":
 #""Create an 'null' style, equivalent to Style(), but more performant."""
 #eturn NULL_STYLE

 #classmethod
 #ef from_color(
 #ls, color: Optional[Color] = None, bgcolor: Optional[Color] = None
 # -> "Style":
 #""Create a new style with colors and no attributes.

 #eturns:
 #olor (Optional[Color]): A (foreground) color, or None for no color. Defaults to None.
 #gcolor (Optional[Color]): A (background) color, or None for no color. Defaults to None.
 #""
 #tyle: Style = cls.__new__(Style)
 #tyle._ansi = None
 #tyle._style_definition = None
 #tyle._color = color
 #tyle._bgcolor = bgcolor
 #tyle._set_attributes = 0
 #tyle._attributes = 0
 #tyle._link = None
 #tyle._link_id = ""
 #tyle._meta = None
 #tyle._null = not (color or bgcolor)
 #tyle._hash = None
 #eturn style

 #classmethod
 #ef from_meta(cls, meta: Optional[Dict[str, Any]]) -> "Style":
 #""Create a new style with meta data.

 #eturns:
 #eta (Optional[Dict[str, Any]]): A dictionary of meta data. Defaults to None.
 #""
 #tyle: Style = cls.__new__(Style)
 #tyle._ansi = None
 #tyle._style_definition = None
 #tyle._color = None
 #tyle._bgcolor = None
 #tyle._set_attributes = 0
 #tyle._attributes = 0
 #tyle._link = None
 #tyle._meta = dumps(meta)
 #tyle._link_id = f"{randint(0, 999999)}{hash(style._meta)}"
 #tyle._hash = None
 #tyle._null = not (meta)
 #eturn style

 #classmethod
 #ef on(cls, meta: Optional[Dict[str, Any]] = None, **handlers: Any) -> "Style":
 #""Create a blank style with meta information.

 #xample:
 #tyle = Style.on(click=self.on_click)

 #rgs:
 #eta (Optional[Dict[str, Any]], optional): An optional dict of meta information.
 #*handlers (Any): Keyword arguments are translated in to handlers.

 #eturns:
 #tyle: A Style with meta information attached.
 #""
 #eta = {} if meta is None else meta
 #eta.update({f"@{key}": value for key, value in handlers.items()})
 #eturn cls.from_meta(meta)

 #old = _Bit(0)
 #im = _Bit(1)
 #talic = _Bit(2)
 #nderline = _Bit(3)
 #link = _Bit(4)
 #link2 = _Bit(5)
 #everse = _Bit(6)
 #onceal = _Bit(7)
 #trike = _Bit(8)
 #nderline2 = _Bit(9)
 #rame = _Bit(10)
 #ncircle = _Bit(11)
 #verline = _Bit(12)

 #property
 #ef link_id(self) -> str:
 #""Get a link id, used in ansi code for links."""
 #eturn self._link_id

 #ef __str__(self) -> str:
 #""Re-generate style definition from attributes."""
 #f self._style_definition is None:
 #ttributes: List[str] = []
 #ppend = attributes.append
 #its = self._set_attributes
 #f bits & 0b0000000001111:
 #f bits & 1:
 #ppend("bold" if self.bold else "not bold")
 #f bits & (1 << 1):
 #ppend("dim" if self.dim else "not dim")
 #f bits & (1 << 2):
 #ppend("italic" if self.italic else "not italic")
 #f bits & (1 << 3):
 #ppend("underline" if self.underline else "not underline")
 #f bits & 0b0000111110000:
 #f bits & (1 << 4):
 #ppend("blink" if self.blink else "not blink")
 #f bits & (1 << 5):
 #ppend("blink2" if self.blink2 else "not blink2")
 #f bits & (1 << 6):
 #ppend("reverse" if self.reverse else "not reverse")
 #f bits & (1 << 7):
 #ppend("conceal" if self.conceal else "not conceal")
 #f bits & (1 << 8):
 #ppend("strike" if self.strike else "not strike")
 #f bits & 0b1111000000000:
 #f bits & (1 << 9):
 #ppend("underline2" if self.underline2 else "not underline2")
 #f bits & (1 << 10):
 #ppend("frame" if self.frame else "not frame")
 #f bits & (1 << 11):
 #ppend("encircle" if self.encircle else "not encircle")
 #f bits & (1 << 12):
 #ppend("overline" if self.overline else "not overline")
 #f self._color is not None:
 #ppend(self._color.name)
 #f self._bgcolor is not None:
 #ppend("on")
 #ppend(self._bgcolor.name)
 #f self._link:
 #ppend("link")
 #ppend(self._link)
 #elf._style_definition = " ".join(attributes) or "none"
 #eturn self._style_definition

 #ef __bool__(self) -> bool:
 #""A Style is false if it has no attributes, colors, or links."""
 #eturn not self._null

 #ef _make_ansi_codes(self, color_system: ColorSystem) -> str:
 #""Generate ANSI codes for this style.

 #rgs:
 #olor_system (ColorSystem): Color system.

 #eturns:
 #tr: String containing codes.
 #""

 #f self._ansi is None:
 #gr: List[str] = []
 #ppend = sgr.append
 #style_map = self._style_map
 #ttributes = self._attributes & self._set_attributes
 #f attributes:
 #f attributes & 1:
 #ppend(_style_map[0])
 #f attributes & 2:
 #ppend(_style_map[1])
 #f attributes & 4:
 #ppend(_style_map[2])
 #f attributes & 8:
 #ppend(_style_map[3])
 #f attributes & 0b0000111110000:
 #or bit in range(4, 9):
 #f attributes & (1 << bit):
 #ppend(_style_map[bit])
 #f attributes & 0b1111000000000:
 #or bit in range(9, 13):
 #f attributes & (1 << bit):
 #ppend(_style_map[bit])
 #f self._color is not None:
 #gr.extend(self._color.downgrade(color_system).get_ansi_codes())
 #f self._bgcolor is not None:
 #gr.extend(
 #elf._bgcolor.downgrade(color_system).get_ansi_codes(
 #oreground=False
 #
 #
 #elf._ansi = ";".join(sgr)
 #eturn self._ansi

 #classmethod
 #lru_cache(maxsize=1024)
 #ef normalize(cls, style: str) -> str:
 #""Normalize a style definition so that styles with the same effect have the same string
 #epresentation.

 #rgs:
 #tyle (str): A style definition.

 #eturns:
 #tr: Normal form of style definition.
 #""
 #ry:
 #eturn str(cls.parse(style))
 #xcept errors.StyleSyntaxError:
 #eturn style.strip().lower()

 #classmethod
 #ef pick_first(cls, *values: Optional[StyleType]) -> StyleType:
 #""Pick first non-None style."""
 #or value in values:
 #f value is not None:
 #eturn value
 #aise ValueError("expected at least one non-None style")

 #ef __rich_repr__(self) -> Result:
 #ield "color", self.color, None
 #ield "bgcolor", self.bgcolor, None
 #ield "bold", self.bold, None,
 #ield "dim", self.dim, None,
 #ield "italic", self.italic, None
 #ield "underline", self.underline, None,
 #ield "blink", self.blink, None
 #ield "blink2", self.blink2, None
 #ield "reverse", self.reverse, None
 #ield "conceal", self.conceal, None
 #ield "strike", self.strike, None
 #ield "underline2", self.underline2, None
 #ield "frame", self.frame, None
 #ield "encircle", self.encircle, None
 #ield "link", self.link, None
 #f self._meta:
 #ield "meta", self.meta

 #ef __eq__(self, other: Any) -> bool:
 #f not isinstance(other, Style):
 #eturn NotImplemented
 #eturn self.__hash__() == other.__hash__()

 #ef __ne__(self, other: Any) -> bool:
 #f not isinstance(other, Style):
 #eturn NotImplemented
 #eturn self.__hash__() != other.__hash__()

 #ef __hash__(self) -> int:
 #f self._hash is not None:
 #eturn self._hash
 #elf._hash = hash(
 #
 #elf._color,
 #elf._bgcolor,
 #elf._attributes,
 #elf._set_attributes,
 #elf._link,
 #elf._meta,
 #
 #
 #eturn self._hash

 #property
 #ef color(self) -> Optional[Color]:
 #""The foreground color or None if it is not set."""
 #eturn self._color

 #property
 #ef bgcolor(self) -> Optional[Color]:
 #""The background color or None if it is not set."""
 #eturn self._bgcolor

 #property
 #ef link(self) -> Optional[str]:
 #""Link text, if set."""
 #eturn self._link

 #property
 #ef transparent_background(self) -> bool:
 #""Check if the style specified a transparent background."""
 #eturn self.bgcolor is None or self.bgcolor.is_default

 #property
 #ef background_style(self) -> "Style":
 #""A Style with background only."""
 #eturn Style(bgcolor=self.bgcolor)

 #property
 #ef meta(self) -> Dict[str, Any]:
 #""Get meta information (can not be changed after construction)."""
 #eturn {} if self._meta is None else cast(Dict[str, Any], loads(self._meta))

 #property
 #ef without_color(self) -> "Style":
 #""Get a copy of the style with color removed."""
 #f self._null:
 #eturn NULL_STYLE
 #tyle: Style = self.__new__(Style)
 #tyle._ansi = None
 #tyle._style_definition = None
 #tyle._color = None
 #tyle._bgcolor = None
 #tyle._attributes = self._attributes
 #tyle._set_attributes = self._set_attributes
 #tyle._link = self._link
 #tyle._link_id = f"{randint(0, 999999)}" if self._link else ""
 #tyle._null = False
 #tyle._meta = None
 #tyle._hash = None
 #eturn style

 #classmethod
 #lru_cache(maxsize=4096)
 #ef parse(cls, style_definition: str) -> "Style":
 #""Parse a style definition.

 #rgs:
 #tyle_definition (str): A string containing a style.

 #aises:
 #rrors.StyleSyntaxError: If the style definition syntax is invalid.

 #eturns:
 #Style`: A Style instance.
 #""
 #f style_definition.strip() == "none" or not style_definition:
 #eturn cls.null()

 #TYLE_ATTRIBUTES = cls.STYLE_ATTRIBUTES
 #olor: Optional[str] = None
 #gcolor: Optional[str] = None
 #ttributes: Dict[str, Optional[Any]] = {}
 #ink: Optional[str] = None

 #ords = iter(style_definition.split())
 #or original_word in words:
 #ord = original_word.lower()
 #f word == "on":
 #ord = next(words, "")
 #f not word:
 #aise errors.StyleSyntaxError("color expected after 'on'")
 #ry:
 #olor.parse(word) is None
 #xcept ColorParseError as error:
 #aise errors.StyleSyntaxError(
 #"unable to parse {word!r} as background color; {error}"
 # from None
 #gcolor = word

 #lif word == "not":
 #ord = next(words, "")
 #ttribute = STYLE_ATTRIBUTES.get(word)
 #f attribute is None:
 #aise errors.StyleSyntaxError(
 #"expected style attribute after 'not', found {word!r}"
 #
 #ttributes[attribute] = False

 #lif word == "link":
 #ord = next(words, "")
 #f not word:
 #aise errors.StyleSyntaxError("URL expected after 'link'")
 #ink = word

 #lif word in STYLE_ATTRIBUTES:
 #ttributes[STYLE_ATTRIBUTES[word]] = True

 #lse:
 #ry:
 #olor.parse(word)
 #xcept ColorParseError as error:
 #aise errors.StyleSyntaxError(
 #"unable to parse {word!r} as color; {error}"
 # from None
 #olor = word
 #tyle = Style(color=color, bgcolor=bgcolor, link=link, **attributes)
 #eturn style

 #lru_cache(maxsize=1024)
 #ef get_html_style(self, theme: Optional[TerminalTheme] = None) -> str:
 #""Get a CSS style rule."""
 #heme = theme or DEFAULT_TERMINAL_THEME
 #ss: List[str] = []
 #ppend = css.append

 #olor = self.color
 #gcolor = self.bgcolor
 #f self.reverse:
 #olor, bgcolor = bgcolor, color
 #f self.dim:
 #oreground_color = (
 #heme.foreground_color if color is None else color.get_truecolor(theme)
 #
 #olor = Color.from_triplet(
 #lend_rgb(foreground_color, theme.background_color, 0.5)
 #
 #f color is not None:
 #heme_color = color.get_truecolor(theme)
 #ppend(f"color: {theme_color.hex}")
 #ppend(f"text-decoration-color: {theme_color.hex}")
 #f bgcolor is not None:
 #heme_color = bgcolor.get_truecolor(theme, foreground=False)
 #ppend(f"background-color: {theme_color.hex}")
 #f self.bold:
 #ppend("font-weight: bold")
 #f self.italic:
 #ppend("font-style: italic")
 #f self.underline:
 #ppend("text-decoration: underline")
 #f self.strike:
 #ppend("text-decoration: line-through")
 #f self.overline:
 #ppend("text-decoration: overline")
 #eturn "; ".join(css)

 #classmethod
 #ef combine(cls, styles: Iterable["Style"]) -> "Style":
 #""Combine styles and get result.

 #rgs:
 #tyles (Iterable[Style]): Styles to combine.

 #eturns:
 #tyle: A new style instance.
 #""
 #ter_styles = iter(styles)
 #eturn sum(iter_styles, next(iter_styles))

 #classmethod
 #ef chain(cls, *styles: "Style") -> "Style":
 #""Combine styles from positional argument in to a single style.

 #rgs:
 #styles (Iterable[Style]): Styles to combine.

 #eturns:
 #tyle: A new style instance.
 #""
 #ter_styles = iter(styles)
 #eturn sum(iter_styles, next(iter_styles))

 #ef copy(self) -> "Style":
 #""Get a copy of this style.

 #eturns:
 #tyle: A new Style instance with identical attributes.
 #""
 #f self._null:
 #eturn NULL_STYLE
 #tyle: Style = self.__new__(Style)
 #tyle._ansi = self._ansi
 #tyle._style_definition = self._style_definition
 #tyle._color = self._color
 #tyle._bgcolor = self._bgcolor
 #tyle._attributes = self._attributes
 #tyle._set_attributes = self._set_attributes
 #tyle._link = self._link
 #tyle._link_id = f"{randint(0, 999999)}" if self._link else ""
 #tyle._hash = self._hash
 #tyle._null = False
 #tyle._meta = self._meta
 #eturn style

 #lru_cache(maxsize=128)
 #ef clear_meta_and_links(self) -> "Style":
 #""Get a copy of this style with link and meta information removed.

 #eturns:
 #tyle: New style object.
 #""
 #f self._null:
 #eturn NULL_STYLE
 #tyle: Style = self.__new__(Style)
 #tyle._ansi = self._ansi
 #tyle._style_definition = self._style_definition
 #tyle._color = self._color
 #tyle._bgcolor = self._bgcolor
 #tyle._attributes = self._attributes
 #tyle._set_attributes = self._set_attributes
 #tyle._link = None
 #tyle._link_id = ""
 #tyle._hash = self._hash
 #tyle._null = False
 #tyle._meta = None
 #eturn style

 #ef update_link(self, link: Optional[str] = None) -> "Style":
 #""Get a copy with a different value for link.

 #rgs:
 #ink (str, optional): New value for link. Defaults to None.

 #eturns:
 #tyle: A new Style instance.
 #""
 #tyle: Style = self.__new__(Style)
 #tyle._ansi = self._ansi
 #tyle._style_definition = self._style_definition
 #tyle._color = self._color
 #tyle._bgcolor = self._bgcolor
 #tyle._attributes = self._attributes
 #tyle._set_attributes = self._set_attributes
 #tyle._link = link
 #tyle._link_id = f"{randint(0, 999999)}" if link else ""
 #tyle._hash = None
 #tyle._null = False
 #tyle._meta = self._meta
 #eturn style

 #ef render(
 #elf,
 #ext: str = "",
 #,
 #olor_system: Optional[ColorSystem] = ColorSystem.TRUECOLOR,
 #egacy_windows: bool = False,
 # -> str:
 #""Render the ANSI codes for the style.

 #rgs:
 #ext (str, optional): A string to style. Defaults to "".
 #olor_system (Optional[ColorSystem], optional): Color system to render to. Defaults to ColorSystem.TRUECOLOR.

 #eturns:
 #tr: A string containing ANSI style codes.
 #""
 #f not text or color_system is None:
 #eturn text
 #ttrs = self._ansi or self._make_ansi_codes(color_system)
 #endered = f"\x1b[{attrs}m{text}\x1b[0m" if attrs else text
 #f self._link and not legacy_windows:
 #endered = (
 #"\x1b]8;id={self._link_id};{self._link}\x1b\\{rendered}\x1b]8;;\x1b\\"
 #
 #eturn rendered

 #ef test(self, text: Optional[str] = None) -> None:
 #""Write text with style directly to terminal.

 #his method is for testing purposes only.

 #rgs:
 #ext (Optional[str], optional): Text to style or None for style name.

 #""
 #ext = text or str(self)
 #ys.stdout.write(f"{self.render(text)}\n")

 #lru_cache(maxsize=1024)
 #ef _add(self, style: Optional["Style"]) -> "Style":
 #f style is None or style._null:
 #eturn self
 #f self._null:
 #eturn style
 #ew_style: Style = self.__new__(Style)
 #ew_style._ansi = None
 #ew_style._style_definition = None
 #ew_style._color = style._color or self._color
 #ew_style._bgcolor = style._bgcolor or self._bgcolor
 #ew_style._attributes = (self._attributes & ~style._set_attributes) | (
 #tyle._attributes & style._set_attributes
 #
 #ew_style._set_attributes = self._set_attributes | style._set_attributes
 #ew_style._link = style._link or self._link
 #ew_style._link_id = style._link_id or self._link_id
 #ew_style._null = style._null
 #f self._meta and style._meta:
 #ew_style._meta = dumps({**self.meta, **style.meta})
 #lse:
 #ew_style._meta = self._meta or style._meta
 #ew_style._hash = None
 #eturn new_style

 #ef __add__(self, style: Optional["Style"]) -> "Style":
 #ombined_style = self._add(style)
 #eturn combined_style.copy() if combined_style.link else combined_style


NULL_STYLE = Style()


class StyleStack:
 #""A stack of styles."""

 #_slots__ = ["_stack"]

 #ef __init__(self, default_style: "Style") -> None:
 #elf._stack: List[Style] = [default_style]

 #ef __repr__(self) -> str:
 #eturn f"<stylestack {self._stack!r}>"

 #property
 #ef current(self) -> Style:
 #""Get the Style at the top of the stack."""
 #eturn self._stack[-1]

 #ef push(self, style: Style) -> None:
 #""Push a new style on to the stack.

 #rgs:
 #tyle (Style): New style to combine with current style.
 #""
 #elf._stack.append(self._stack[-1] + style)

 #ef pop(self) -> Style:
 #""Pop last style and discard.

 #eturns:
 #tyle: New current style (also available as stack.current)
 #""
 #elf._stack.pop()
 #eturn self._stack[-1]
