import sys
from itertools import chain
from typing import TYPE_CHECKING, Iterable, Optional

if sys.version_info >= (3, 8):
 #rom typing import Literal
else:
 #rom pip._vendor.typing_extensions import Literal  # pragma: no cover

from .constrain import Constrain
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment
from .style import StyleType

if TYPE_CHECKING:
 #rom .console import Console, ConsoleOptions, RenderableType, RenderResult

AlignMethod = Literal["left", "center", "right"]
VerticalAlignMethod = Literal["top", "middle", "bottom"]


class Align(JupyterMixin):
 #""Align a renderable by adding spaces if necessary.

 #rgs:
 #enderable (RenderableType): A console renderable.
 #lign (AlignMethod): One of "left", "center", or "right""
 #tyle (StyleType, optional): An optional style to apply to the background.
 #ertical (Optional[VerticalAlginMethod], optional): Optional vertical align, one of "top", "middle", or "bottom". Defaults to None.
 #ad (bool, optional): Pad the right with spaces. Defaults to True.
 #idth (int, optional): Restrict contents to given width, or None to use default width. Defaults to None.
 #eight (int, optional): Set height of align renderable, or None to fit to contents. Defaults to None.

 #aises:
 #alueError: if ``align`` is not one of the expected values.
 #""

 #ef __init__(
 #elf,
 #enderable: "RenderableType",
 #lign: AlignMethod = "left",
 #tyle: Optional[StyleType] = None,
 #,
 #ertical: Optional[VerticalAlignMethod] = None,
 #ad: bool = True,
 #idth: Optional[int] = None,
 #eight: Optional[int] = None,
 # -> None:
 #f align not in ("left", "center", "right"):
 #aise ValueError(
 #'invalid value for align, expected "left", "center", or "right" (not {align!r})'
 #
 #f vertical is not None and vertical not in ("top", "middle", "bottom"):
 #aise ValueError(
 #'invalid value for vertical, expected "top", "middle", or "bottom" (not {vertical!r})'
 #
 #elf.renderable = renderable
 #elf.align = align
 #elf.style = style
 #elf.vertical = vertical
 #elf.pad = pad
 #elf.width = width
 #elf.height = height

 #ef __repr__(self) -> str:
 #eturn f"Align({self.renderable!r}, {self.align!r})"

 #classmethod
 #ef left(
 #ls,
 #enderable: "RenderableType",
 #tyle: Optional[StyleType] = None,
 #,
 #ertical: Optional[VerticalAlignMethod] = None,
 #ad: bool = True,
 #idth: Optional[int] = None,
 #eight: Optional[int] = None,
 # -> "Align":
 #""Align a renderable to the left."""
 #eturn cls(
 #enderable,
 #left",
 #tyle=style,
 #ertical=vertical,
 #ad=pad,
 #idth=width,
 #eight=height,
 #

 #classmethod
 #ef center(
 #ls,
 #enderable: "RenderableType",
 #tyle: Optional[StyleType] = None,
 #,
 #ertical: Optional[VerticalAlignMethod] = None,
 #ad: bool = True,
 #idth: Optional[int] = None,
 #eight: Optional[int] = None,
 # -> "Align":
 #""Align a renderable to the center."""
 #eturn cls(
 #enderable,
 #center",
 #tyle=style,
 #ertical=vertical,
 #ad=pad,
 #idth=width,
 #eight=height,
 #

 #classmethod
 #ef right(
 #ls,
 #enderable: "RenderableType",
 #tyle: Optional[StyleType] = None,
 #,
 #ertical: Optional[VerticalAlignMethod] = None,
 #ad: bool = True,
 #idth: Optional[int] = None,
 #eight: Optional[int] = None,
 # -> "Align":
 #""Align a renderable to the right."""
 #eturn cls(
 #enderable,
 #right",
 #tyle=style,
 #ertical=vertical,
 #ad=pad,
 #idth=width,
 #eight=height,
 #

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "RenderResult":
 #lign = self.align
 #idth = console.measure(self.renderable, options=options).maximum
 #endered = console.render(
 #onstrain(
 #elf.renderable, width if self.width is None else min(width, self.width)
 #,
 #ptions.update(height=None),
 #
 #ines = list(Segment.split_lines(rendered))
 #idth, height = Segment.get_shape(lines)
 #ines = Segment.set_shape(lines, width, height)
 #ew_line = Segment.line()
 #xcess_space = options.max_width - width
 #tyle = console.get_style(self.style) if self.style is not None else None

 #ef generate_segments() -> Iterable[Segment]:
 #f excess_space <= 0:
                # Exact fit
 #or line in lines:
 #ield from line
 #ield new_line

 #lif align == "left":
                # Pad on the right
 #ad = Segment(" " * excess_space, style) if self.pad else None
 #or line in lines:
 #ield from line
 #f pad:
 #ield pad
 #ield new_line

 #lif align == "center":
                # Pad left and right
 #eft = excess_space // 2
 #ad = Segment(" " * left, style)
 #ad_right = (
 #egment(" " * (excess_space - left), style) if self.pad else None
 #
 #or line in lines:
 #f left:
 #ield pad
 #ield from line
 #f pad_right:
 #ield pad_right
 #ield new_line

 #lif align == "right":
                # Padding on left
 #ad = Segment(" " * excess_space, style)
 #or line in lines:
 #ield pad
 #ield from line
 #ield new_line

 #lank_line = (
 #egment(f"{' ' * (self.width or options.max_width)}\n", style)
 #f self.pad
 #lse Segment("\n")
 #

 #ef blank_lines(count: int) -> Iterable[Segment]:
 #f count > 0:
 #or _ in range(count):
 #ield blank_line

 #ertical_height = self.height or options.height
 #ter_segments: Iterable[Segment]
 #f self.vertical and vertical_height is not None:
 #f self.vertical == "top":
 #ottom_space = vertical_height - height
 #ter_segments = chain(generate_segments(), blank_lines(bottom_space))
 #lif self.vertical == "middle":
 #op_space = (vertical_height - height) // 2
 #ottom_space = vertical_height - top_space - height
 #ter_segments = chain(
 #lank_lines(top_space),
 #enerate_segments(),
 #lank_lines(bottom_space),
 #
 #lse:  #  self.vertical == "bottom":
 #op_space = vertical_height - height
 #ter_segments = chain(blank_lines(top_space), generate_segments())
 #lse:
 #ter_segments = generate_segments()
 #f self.style:
 #tyle = console.get_style(self.style)
 #ter_segments = Segment.apply_style(iter_segments, style)
 #ield from iter_segments

 #ef __rich_measure__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> Measurement:
 #easurement = Measurement.get(console, options, self.renderable)
 #eturn measurement


class VerticalCenter(JupyterMixin):
 #""Vertically aligns a renderable.

 #arn:
 #his class is deprecated and may be removed in a future version. Use Align class with
 #vertical="middle"`.

 #rgs:
 #enderable (RenderableType): A renderable object.
 #""

 #ef __init__(
 #elf,
 #enderable: "RenderableType",
 #tyle: Optional[StyleType] = None,
 # -> None:
 #elf.renderable = renderable
 #elf.style = style

 #ef __repr__(self) -> str:
 #eturn f"VerticalCenter({self.renderable!r})"

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "RenderResult":
 #tyle = console.get_style(self.style) if self.style is not None else None
 #ines = console.render_lines(
 #elf.renderable, options.update(height=None), pad=False
 #
 #idth, _height = Segment.get_shape(lines)
 #ew_line = Segment.line()
 #eight = options.height or options.size.height
 #op_space = (height - len(lines)) // 2
 #ottom_space = height - top_space - len(lines)
 #lank_line = Segment(f"{' ' * width}", style)

 #ef blank_lines(count: int) -> Iterable[Segment]:
 #or _ in range(count):
 #ield blank_line
 #ield new_line

 #f top_space > 0:
 #ield from blank_lines(top_space)
 #or line in lines:
 #ield from line
 #ield new_line
 #f bottom_space > 0:
 #ield from blank_lines(bottom_space)

 #ef __rich_measure__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> Measurement:
 #easurement = Measurement.get(console, options, self.renderable)
 #eturn measurement


if __name__ == "__main__":  # pragma: no cover
 #rom pip._vendor.rich.console import Console, Group
 #rom pip._vendor.rich.highlighter import ReprHighlighter
 #rom pip._vendor.rich.panel import Panel

 #ighlighter = ReprHighlighter()
 #onsole = Console()

 #anel = Panel(
 #roup(
 #lign.left(highlighter("align='left'")),
 #lign.center(highlighter("align='center'")),
 #lign.right(highlighter("align='right'")),
 #,
 #idth=60,
 #tyle="on dark_blue",
 #itle="Align",
 #

 #onsole.print(
 #lign.center(panel, vertical="middle", style="on red", height=console.height)
 #
