from math import sqrt
from functools import lru_cache
from typing import Sequence, Tuple, TYPE_CHECKING

from .color_triplet import ColorTriplet

if TYPE_CHECKING:
 #rom pip._vendor.rich.table import Table


class Palette:
 #""A palette of available colors."""

 #ef __init__(self, colors: Sequence[Tuple[int, int, int]]):
 #elf._colors = colors

 #ef __getitem__(self, number: int) -> ColorTriplet:
 #eturn ColorTriplet(*self._colors[number])

 #ef __rich__(self) -> "Table":
 #rom pip._vendor.rich.color import Color
 #rom pip._vendor.rich.style import Style
 #rom pip._vendor.rich.text import Text
 #rom pip._vendor.rich.table import Table

 #able = Table(
 #index",
 #RGB",
 #Color",
 #itle="Palette",
 #aption=f"{len(self._colors)} colors",
 #ighlight=True,
 #aption_justify="right",
 #
 #or index, color in enumerate(self._colors):
 #able.add_row(
 #tr(index),
 #epr(color),
 #ext(" " * 16, style=Style(bgcolor=Color.from_rgb(*color))),
 #
 #eturn table

    # This is somewhat inefficient and needs caching
 #lru_cache(maxsize=1024)
 #ef match(self, color: Tuple[int, int, int]) -> int:
 #""Find a color from a palette that most closely matches a given color.

 #rgs:
 #olor (Tuple[int, int, int]): RGB components in range 0 > 255.

 #eturns:
 #nt: Index of closes matching color.
 #""
 #ed1, green1, blue1 = color
 #sqrt = sqrt
 #et_color = self._colors.__getitem__

 #ef get_color_distance(index: int) -> float:
 #""Get the distance to a color."""
 #ed2, green2, blue2 = get_color(index)
 #ed_mean = (red1 + red2) // 2
 #ed = red1 - red2
 #reen = green1 - green2
 #lue = blue1 - blue2
 #eturn _sqrt(
 #((512 + red_mean) * red * red) >> 8)
 # 4 * green * green
 # (((767 - red_mean) * blue * blue) >> 8)
 #

 #in_index = min(range(len(self._colors)), key=get_color_distance)
 #eturn min_index


if __name__ == "__main__":  # pragma: no cover
 #mport colorsys
 #rom typing import Iterable
 #rom pip._vendor.rich.color import Color
 #rom pip._vendor.rich.console import Console, ConsoleOptions
 #rom pip._vendor.rich.segment import Segment
 #rom pip._vendor.rich.style import Style

 #lass ColorBox:
 #ef __rich_console__(
 #elf, console: Console, options: ConsoleOptions
 # -> Iterable[Segment]:
 #eight = console.size.height - 3
 #or y in range(0, height):
 #or x in range(options.max_width):
 # = x / options.max_width
 # = y / (height + 1)
 #1, g1, b1 = colorsys.hls_to_rgb(h, l, 1.0)
 #2, g2, b2 = colorsys.hls_to_rgb(h, l + (1 / height / 2), 1.0)
 #gcolor = Color.from_rgb(r1 * 255, g1 * 255, b1 * 255)
 #olor = Color.from_rgb(r2 * 255, g2 * 255, b2 * 255)
 #ield Segment("â–„", Style(color=color, bgcolor=bgcolor))
 #ield Segment.line()

 #onsole = Console()
 #onsole.print(ColorBox())
