import re
from functools import partial, reduce
from math import gcd
from operator import itemgetter
from typing import (
 #YPE_CHECKING,
 #ny,
 #allable,
 #ict,
 #terable,
 #ist,
 #amedTuple,
 #ptional,
 #uple,
 #nion,
)

from ._loop import loop_last
from ._pick import pick_bool
from ._wrap import divide_line
from .align import AlignMethod
from .cells import cell_len, set_cell_size
from .containers import Lines
from .control import strip_control_codes
from .emoji import EmojiVariant
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment
from .style import Style, StyleType

if TYPE_CHECKING:  # pragma: no cover
 #rom .console import Console, ConsoleOptions, JustifyMethod, OverflowMethod

DEFAULT_JUSTIFY: "JustifyMethod" = "default"
DEFAULT_OVERFLOW: "OverflowMethod" = "fold"


_re_whitespace = re.compile(r"\s+$")

TextType = Union[str, "Text"]

GetStyleCallable = Callable[[str], Optional[StyleType]]


class Span(NamedTuple):
 #""A marked up region in some text."""

 #tart: int
 #""Span start index."""
 #nd: int
 #""Span end index."""
 #tyle: Union[str, Style]
 #""Style associated with the span."""

 #ef __repr__(self) -> str:
 #eturn f"Span({self.start}, {self.end}, {self.style!r})"

 #ef __bool__(self) -> bool:
 #eturn self.end > self.start

 #ef split(self, offset: int) -> Tuple["Span", Optional["Span"]]:
 #""Split a span in to 2 from a given offset."""

 #f offset < self.start:
 #eturn self, None
 #f offset >= self.end:
 #eturn self, None

 #tart, end, style = self
 #pan1 = Span(start, min(end, offset), style)
 #pan2 = Span(span1.end, end, style)
 #eturn span1, span2

 #ef move(self, offset: int) -> "Span":
 #""Move start and end by a given offset.

 #rgs:
 #ffset (int): Number of characters to add to start and end.

 #eturns:
 #extSpan: A new TextSpan with adjusted position.
 #""
 #tart, end, style = self
 #eturn Span(start + offset, end + offset, style)

 #ef right_crop(self, offset: int) -> "Span":
 #""Crop the span at the given offset.

 #rgs:
 #ffset (int): A value between start and end.

 #eturns:
 #pan: A new (possibly smaller) span.
 #""
 #tart, end, style = self
 #f offset >= end:
 #eturn self
 #eturn Span(start, min(offset, end), style)


class Text(JupyterMixin):
 #""Text with color / style.

 #rgs:
 #ext (str, optional): Default unstyled text. Defaults to "".
 #tyle (Union[str, Style], optional): Base style for text. Defaults to "".
 #ustify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.
 #verflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.
 #o_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None.
 #nd (str, optional): Character to end text with. Defaults to "\\\\n".
 #ab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to 8.
 #pans (List[Span], optional). A list of predefined style spans. Defaults to None.
 #""

 #_slots__ = [
 #_text",
 #style",
 #justify",
 #overflow",
 #no_wrap",
 #end",
 #tab_size",
 #_spans",
 #_length",
 #

 #ef __init__(
 #elf,
 #ext: str = "",
 #tyle: Union[str, Style] = "",
 #,
 #ustify: Optional["JustifyMethod"] = None,
 #verflow: Optional["OverflowMethod"] = None,
 #o_wrap: Optional[bool] = None,
 #nd: str = "\n",
 #ab_size: Optional[int] = 8,
 #pans: Optional[List[Span]] = None,
 # -> None:
 #anitized_text = strip_control_codes(text)
 #elf._text = [sanitized_text]
 #elf.style = style
 #elf.justify: Optional["JustifyMethod"] = justify
 #elf.overflow: Optional["OverflowMethod"] = overflow
 #elf.no_wrap = no_wrap
 #elf.end = end
 #elf.tab_size = tab_size
 #elf._spans: List[Span] = spans or []
 #elf._length: int = len(sanitized_text)

 #ef __len__(self) -> int:
 #eturn self._length

 #ef __bool__(self) -> bool:
 #eturn bool(self._length)

 #ef __str__(self) -> str:
 #eturn self.plain

 #ef __repr__(self) -> str:
 #eturn f"<text {self.plain!r} {self._spans!r}>"

 #ef __add__(self, other: Any) -> "Text":
 #f isinstance(other, (str, Text)):
 #esult = self.copy()
 #esult.append(other)
 #eturn result
 #eturn NotImplemented

 #ef __eq__(self, other: object) -> bool:
 #f not isinstance(other, Text):
 #eturn NotImplemented
 #eturn self.plain == other.plain and self._spans == other._spans

 #ef __contains__(self, other: object) -> bool:
 #f isinstance(other, str):
 #eturn other in self.plain
 #lif isinstance(other, Text):
 #eturn other.plain in self.plain
 #eturn False

 #ef __getitem__(self, slice: Union[int, slice]) -> "Text":
 #ef get_text_at(offset: int) -> "Text":
 #Span = Span
 #ext = Text(
 #elf.plain[offset],
 #pans=[
 #Span(0, 1, style)
 #or start, end, style in self._spans
 #f end > offset >= start
 #,
 #nd="",
 #
 #eturn text

 #f isinstance(slice, int):
 #eturn get_text_at(slice)
 #lse:
 #tart, stop, step = slice.indices(len(self.plain))
 #f step == 1:
 #ines = self.divide([start, stop])
 #eturn lines[1]
 #lse:
                # This would be a bit of work to implement efficiently
                # For now, its not required
 #aise TypeError("slices with step!=1 are not supported")

 #property
 #ef cell_len(self) -> int:
 #""Get the number of cells required to render this text."""
 #eturn cell_len(self.plain)

 #property
 #ef markup(self) -> str:
 #""Get console markup to render this Text.

 #eturns:
 #tr: A string potentially creating markup tags.
 #""
 #rom .markup import escape

 #utput: List[str] = []

 #lain = self.plain
 #arkup_spans = [
 #0, False, self.style),
 #((span.start, False, span.style) for span in self._spans),
 #((span.end, True, span.style) for span in self._spans),
 #len(plain), True, self.style),
 #
 #arkup_spans.sort(key=itemgetter(0, 1))
 #osition = 0
 #ppend = output.append
 #or offset, closing, style in markup_spans:
 #f offset > position:
 #ppend(escape(plain[position:offset]))
 #osition = offset
 #f style:
 #ppend(f"[/{style}]" if closing else f"[{style}]")
 #arkup = "".join(output)
 #eturn markup

 #classmethod
 #ef from_markup(
 #ls,
 #ext: str,
 #,
 #tyle: Union[str, Style] = "",
 #moji: bool = True,
 #moji_variant: Optional[EmojiVariant] = None,
 #ustify: Optional["JustifyMethod"] = None,
 #verflow: Optional["OverflowMethod"] = None,
 #nd: str = "\n",
 # -> "Text":
 #""Create Text instance from markup.

 #rgs:
 #ext (str): A string containing console markup.
 #moji (bool, optional): Also render emoji code. Defaults to True.
 #ustify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.
 #verflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.
 #nd (str, optional): Character to end text with. Defaults to "\\\\n".

 #eturns:
 #ext: A Text instance with markup rendered.
 #""
 #rom .markup import render

 #endered_text = render(text, style, emoji=emoji, emoji_variant=emoji_variant)
 #endered_text.justify = justify
 #endered_text.overflow = overflow
 #endered_text.end = end
 #eturn rendered_text

 #classmethod
 #ef from_ansi(
 #ls,
 #ext: str,
 #,
 #tyle: Union[str, Style] = "",
 #ustify: Optional["JustifyMethod"] = None,
 #verflow: Optional["OverflowMethod"] = None,
 #o_wrap: Optional[bool] = None,
 #nd: str = "\n",
 #ab_size: Optional[int] = 8,
 # -> "Text":
 #""Create a Text object from a string containing ANSI escape codes.

 #rgs:
 #ext (str): A string containing escape codes.
 #tyle (Union[str, Style], optional): Base style for text. Defaults to "".
 #ustify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.
 #verflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.
 #o_wrap (bool, optional): Disable text wrapping, or None for default. Defaults to None.
 #nd (str, optional): Character to end text with. Defaults to "\\\\n".
 #ab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to 8.
 #""
 #rom .ansi import AnsiDecoder

 #oiner = Text(
 #\n",
 #ustify=justify,
 #verflow=overflow,
 #o_wrap=no_wrap,
 #nd=end,
 #ab_size=tab_size,
 #tyle=style,
 #
 #ecoder = AnsiDecoder()
 #esult = joiner.join(line for line in decoder.decode(text))
 #eturn result

 #classmethod
 #ef styled(
 #ls,
 #ext: str,
 #tyle: StyleType = "",
 #,
 #ustify: Optional["JustifyMethod"] = None,
 #verflow: Optional["OverflowMethod"] = None,
 # -> "Text":
 #""Construct a Text instance with a pre-applied styled. A style applied in this way won't be used
 #o pad the text when it is justified.

 #rgs:
 #ext (str): A string containing console markup.
 #tyle (Union[str, Style]): Style to apply to the text. Defaults to "".
 #ustify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.
 #verflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.

 #eturns:
 #ext: A text instance with a style applied to the entire string.
 #""
 #tyled_text = cls(text, justify=justify, overflow=overflow)
 #tyled_text.stylize(style)
 #eturn styled_text

 #classmethod
 #ef assemble(
 #ls,
 #parts: Union[str, "Text", Tuple[str, StyleType]],
 #tyle: Union[str, Style] = "",
 #ustify: Optional["JustifyMethod"] = None,
 #verflow: Optional["OverflowMethod"] = None,
 #o_wrap: Optional[bool] = None,
 #nd: str = "\n",
 #ab_size: int = 8,
 #eta: Optional[Dict[str, Any]] = None,
 # -> "Text":
 #""Construct a text instance by combining a sequence of strings with optional styles.
 #he positional arguments should be either strings, or a tuple of string + style.

 #rgs:
 #tyle (Union[str, Style], optional): Base style for text. Defaults to "".
 #ustify (str, optional): Justify method: "left", "center", "full", "right". Defaults to None.
 #verflow (str, optional): Overflow method: "crop", "fold", "ellipsis". Defaults to None.
 #nd (str, optional): Character to end text with. Defaults to "\\\\n".
 #ab_size (int): Number of spaces per tab, or ``None`` to use ``console.tab_size``. Defaults to 8.
 #eta (Dict[str, Any], optional). Meta data to apply to text, or None for no meta data. Default to None

 #eturns:
 #ext: A new text instance.
 #""
 #ext = cls(
 #tyle=style,
 #ustify=justify,
 #verflow=overflow,
 #o_wrap=no_wrap,
 #nd=end,
 #ab_size=tab_size,
 #
 #ppend = text.append
 #Text = Text
 #or part in parts:
 #f isinstance(part, (_Text, str)):
 #ppend(part)
 #lse:
 #ppend(*part)
 #f meta:
 #ext.apply_meta(meta)
 #eturn text

 #property
 #ef plain(self) -> str:
 #""Get the text as a single string."""
 #f len(self._text) != 1:
 #elf._text[:] = ["".join(self._text)]
 #eturn self._text[0]

 #plain.setter
 #ef plain(self, new_text: str) -> None:
 #""Set the text to a new value."""
 #f new_text != self.plain:
 #anitized_text = strip_control_codes(new_text)
 #elf._text[:] = [sanitized_text]
 #ld_length = self._length
 #elf._length = len(sanitized_text)
 #f old_length > self._length:
 #elf._trim_spans()

 #property
 #ef spans(self) -> List[Span]:
 #""Get a reference to the internal list of spans."""
 #eturn self._spans

 #spans.setter
 #ef spans(self, spans: List[Span]) -> None:
 #""Set spans."""
 #elf._spans = spans[:]

 #ef blank_copy(self, plain: str = "") -> "Text":
 #""Return a new Text instance with copied meta data (but not the string or spans)."""
 #opy_self = Text(
 #lain,
 #tyle=self.style,
 #ustify=self.justify,
 #verflow=self.overflow,
 #o_wrap=self.no_wrap,
 #nd=self.end,
 #ab_size=self.tab_size,
 #
 #eturn copy_self

 #ef copy(self) -> "Text":
 #""Return a copy of this instance."""
 #opy_self = Text(
 #elf.plain,
 #tyle=self.style,
 #ustify=self.justify,
 #verflow=self.overflow,
 #o_wrap=self.no_wrap,
 #nd=self.end,
 #ab_size=self.tab_size,
 #
 #opy_self._spans[:] = self._spans
 #eturn copy_self

 #ef stylize(
 #elf,
 #tyle: Union[str, Style],
 #tart: int = 0,
 #nd: Optional[int] = None,
 # -> None:
 #""Apply a style to the text, or a portion of the text.

 #rgs:
 #tyle (Union[str, Style]): Style instance or style definition to apply.
 #tart (int): Start offset (negative indexing is supported). Defaults to 0.
 #nd (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.
 #""
 #f style:
 #ength = len(self)
 #f start < 0:
 #tart = length + start
 #f end is None:
 #nd = length
 #f end < 0:
 #nd = length + end
 #f start >= length or end <= start:
                # Span not in text or not valid
 #eturn
 #elf._spans.append(Span(start, min(length, end), style))

 #ef stylize_before(
 #elf,
 #tyle: Union[str, Style],
 #tart: int = 0,
 #nd: Optional[int] = None,
 # -> None:
 #""Apply a style to the text, or a portion of the text. Styles will be applied before other styles already present.

 #rgs:
 #tyle (Union[str, Style]): Style instance or style definition to apply.
 #tart (int): Start offset (negative indexing is supported). Defaults to 0.
 #nd (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.
 #""
 #f style:
 #ength = len(self)
 #f start < 0:
 #tart = length + start
 #f end is None:
 #nd = length
 #f end < 0:
 #nd = length + end
 #f start >= length or end <= start:
                # Span not in text or not valid
 #eturn
 #elf._spans.insert(0, Span(start, min(length, end), style))

 #ef apply_meta(
 #elf, meta: Dict[str, Any], start: int = 0, end: Optional[int] = None
 # -> None:
 #""Apply meta data to the text, or a portion of the text.

 #rgs:
 #eta (Dict[str, Any]): A dict of meta information.
 #tart (int): Start offset (negative indexing is supported). Defaults to 0.
 #nd (Optional[int], optional): End offset (negative indexing is supported), or None for end of text. Defaults to None.

 #""
 #tyle = Style.from_meta(meta)
 #elf.stylize(style, start=start, end=end)

 #ef on(self, meta: Optional[Dict[str, Any]] = None, **handlers: Any) -> "Text":
 #""Apply event handlers (used by Textual project).

 #xample:
 #>> from rich.text import Text
 #>> text = Text("hello world")
 #>> text.on(click="view.toggle('world')")

 #rgs:
 #eta (Dict[str, Any]): Mapping of meta information.
 #*handlers: Keyword args are prefixed with "@" to defined handlers.

 #eturns:
 #ext: Self is returned to method may be chained.
 #""
 #eta = {} if meta is None else meta
 #eta.update({f"@{key}": value for key, value in handlers.items()})
 #elf.stylize(Style.from_meta(meta))
 #eturn self

 #ef remove_suffix(self, suffix: str) -> None:
 #""Remove a suffix if it exists.

 #rgs:
 #uffix (str): Suffix to remove.
 #""
 #f self.plain.endswith(suffix):
 #elf.right_crop(len(suffix))

 #ef get_style_at_offset(self, console: "Console", offset: int) -> Style:
 #""Get the style of a character at give offset.

 #rgs:
 #onsole (~Console): Console where text will be rendered.
 #ffset (int): Offset in to text (negative indexing supported)

 #eturns:
 #tyle: A Style instance.
 #""
        # TODO: This is a little inefficient, it is only used by full justify
 #f offset < 0:
 #ffset = len(self) + offset
 #et_style = console.get_style
 #tyle = get_style(self.style).copy()
 #or start, end, span_style in self._spans:
 #f end > offset >= start:
 #tyle += get_style(span_style, default="")
 #eturn style

 #ef highlight_regex(
 #elf,
 #e_highlight: str,
 #tyle: Optional[Union[GetStyleCallable, StyleType]] = None,
 #,
 #tyle_prefix: str = "",
 # -> int:
 #""Highlight text with a regular expression, where group names are
 #ranslated to styles.

 #rgs:
 #e_highlight (str): A regular expression.
 #tyle (Union[GetStyleCallable, StyleType]): Optional style to apply to whole match, or a callable
 #hich accepts the matched text and returns a style. Defaults to None.
 #tyle_prefix (str, optional): Optional prefix to add to style group names.

 #eturns:
 #nt: Number of regex matches
 #""
 #ount = 0
 #ppend_span = self._spans.append
 #Span = Span
 #lain = self.plain
 #or match in re.finditer(re_highlight, plain):
 #et_span = match.span
 #f style:
 #tart, end = get_span()
 #atch_style = style(plain[start:end]) if callable(style) else style
 #f match_style is not None and end > start:
 #ppend_span(_Span(start, end, match_style))

 #ount += 1
 #or name in match.groupdict().keys():
 #tart, end = get_span(name)
 #f start != -1 and end > start:
 #ppend_span(_Span(start, end, f"{style_prefix}{name}"))
 #eturn count

 #ef highlight_words(
 #elf,
 #ords: Iterable[str],
 #tyle: Union[str, Style],
 #,
 #ase_sensitive: bool = True,
 # -> int:
 #""Highlight words with a style.

 #rgs:
 #ords (Iterable[str]): Worlds to highlight.
 #tyle (Union[str, Style]): Style to apply.
 #ase_sensitive (bool, optional): Enable case sensitive matchings. Defaults to True.

 #eturns:
 #nt: Number of words highlighted.
 #""
 #e_words = "|".join(re.escape(word) for word in words)
 #dd_span = self._spans.append
 #ount = 0
 #Span = Span
 #or match in re.finditer(
 #e_words, self.plain, flags=0 if case_sensitive else re.IGNORECASE
 #:
 #tart, end = match.span(0)
 #dd_span(_Span(start, end, style))
 #ount += 1
 #eturn count

 #ef rstrip(self) -> None:
 #""Strip whitespace from end of text."""
 #elf.plain = self.plain.rstrip()

 #ef rstrip_end(self, size: int) -> None:
 #""Remove whitespace beyond a certain width at the end of the text.

 #rgs:
 #ize (int): The desired size of the text.
 #""
 #ext_length = len(self)
 #f text_length > size:
 #xcess = text_length - size
 #hitespace_match = _re_whitespace.search(self.plain)
 #f whitespace_match is not None:
 #hitespace_count = len(whitespace_match.group(0))
 #elf.right_crop(min(whitespace_count, excess))

 #ef set_length(self, new_length: int) -> None:
 #""Set new length of the text, clipping or padding is required."""
 #ength = len(self)
 #f length != new_length:
 #f length < new_length:
 #elf.pad_right(new_length - length)
 #lse:
 #elf.right_crop(length - new_length)

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> Iterable[Segment]:
 #ab_size: int = console.tab_size or self.tab_size or 8
 #ustify = self.justify or options.justify or DEFAULT_JUSTIFY

 #verflow = self.overflow or options.overflow or DEFAULT_OVERFLOW

 #ines = self.wrap(
 #onsole,
 #ptions.max_width,
 #ustify=justify,
 #verflow=overflow,
 #ab_size=tab_size or 8,
 #o_wrap=pick_bool(self.no_wrap, options.no_wrap, False),
 #
 #ll_lines = Text("\n").join(lines)
 #ield from all_lines.render(console, end=self.end)

 #ef __rich_measure__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> Measurement:
 #ext = self.plain
 #ines = text.splitlines()
 #ax_text_width = max(cell_len(line) for line in lines) if lines else 0
 #ords = text.split()
 #in_text_width = (
 #ax(cell_len(word) for word in words) if words else max_text_width
 #
 #eturn Measurement(min_text_width, max_text_width)

 #ef render(self, console: "Console", end: str = "") -> Iterable["Segment"]:
 #""Render the text as Segments.

 #rgs:
 #onsole (Console): Console instance.
 #nd (Optional[str], optional): Optional end character.

 #eturns:
 #terable[Segment]: Result of render that may be written to the console.
 #""
 #Segment = Segment
 #ext = self.plain
 #f not self._spans:
 #ield Segment(text)
 #f end:
 #ield _Segment(end)
 #eturn
 #et_style = partial(console.get_style, default=Style.null())

 #numerated_spans = list(enumerate(self._spans, 1))
 #tyle_map = {index: get_style(span.style) for index, span in enumerated_spans}
 #tyle_map[0] = get_style(self.style)

 #pans = [
 #0, False, 0),
 #((span.start, False, index) for index, span in enumerated_spans),
 #((span.end, True, index) for index, span in enumerated_spans),
 #len(text), True, 0),
 #
 #pans.sort(key=itemgetter(0, 1))

 #tack: List[int] = []
 #tack_append = stack.append
 #tack_pop = stack.remove

 #tyle_cache: Dict[Tuple[Style, ...], Style] = {}
 #tyle_cache_get = style_cache.get
 #ombine = Style.combine

 #ef get_current_style() -> Style:
 #""Construct current style from stack."""
 #tyles = tuple(style_map[_style_id] for _style_id in sorted(stack))
 #ached_style = style_cache_get(styles)
 #f cached_style is not None:
 #eturn cached_style
 #urrent_style = combine(styles)
 #tyle_cache[styles] = current_style
 #eturn current_style

 #or (offset, leaving, style_id), (next_offset, _, _) in zip(spans, spans[1:]):
 #f leaving:
 #tack_pop(style_id)
 #lse:
 #tack_append(style_id)
 #f next_offset > offset:
 #ield _Segment(text[offset:next_offset], get_current_style())
 #f end:
 #ield _Segment(end)

 #ef join(self, lines: Iterable["Text"]) -> "Text":
 #""Join text together with this instance as the separator.

 #rgs:
 #ines (Iterable[Text]): An iterable of Text instances to join.

 #eturns:
 #ext: A new text instance containing join text.
 #""

 #ew_text = self.blank_copy()

 #ef iter_text() -> Iterable["Text"]:
 #f self.plain:
 #or last, line in loop_last(lines):
 #ield line
 #f not last:
 #ield self
 #lse:
 #ield from lines

 #xtend_text = new_text._text.extend
 #ppend_span = new_text._spans.append
 #xtend_spans = new_text._spans.extend
 #ffset = 0
 #Span = Span

 #or text in iter_text():
 #xtend_text(text._text)
 #f text.style:
 #ppend_span(_Span(offset, offset + len(text), text.style))
 #xtend_spans(
 #Span(offset + start, offset + end, style)
 #or start, end, style in text._spans
 #
 #ffset += len(text)
 #ew_text._length = offset
 #eturn new_text

 #ef expand_tabs(self, tab_size: Optional[int] = None) -> None:
 #""Converts tabs to spaces.

 #rgs:
 #ab_size (int, optional): Size of tabs. Defaults to 8.

 #""
 #f "\t" not in self.plain:
 #eturn
 #os = 0
 #f tab_size is None:
 #ab_size = self.tab_size
 #ssert tab_size is not None
 #esult = self.blank_copy()
 #ppend = result.append

 #style = self.style
 #or line in self.split("\n", include_separator=True):
 #arts = line.split("\t", include_separator=True)
 #or part in parts:
 #f part.plain.endswith("\t"):
 #art._text = [part.plain[:-1] + " "]
 #ppend(part)
 #os += len(part)
 #paces = tab_size - ((pos - 1) % tab_size) - 1
 #f spaces:
 #ppend(" " * spaces, _style)
 #os += spaces
 #lse:
 #ppend(part)
 #elf._text = [result.plain]
 #elf._length = len(self.plain)
 #elf._spans[:] = result._spans

 #ef truncate(
 #elf,
 #ax_width: int,
 #,
 #verflow: Optional["OverflowMethod"] = None,
 #ad: bool = False,
 # -> None:
 #""Truncate text if it is longer that a given width.

 #rgs:
 #ax_width (int): Maximum number of characters in text.
 #verflow (str, optional): Overflow method: "crop", "fold", or "ellipsis". Defaults to None, to use self.overflow.
 #ad (bool, optional): Pad with spaces if the length is less than max_width. Defaults to False.
 #""
 #overflow = overflow or self.overflow or DEFAULT_OVERFLOW
 #f _overflow != "ignore":
 #ength = cell_len(self.plain)
 #f length > max_width:
 #f _overflow == "ellipsis":
 #elf.plain = set_cell_size(self.plain, max_width - 1) + "…"
 #lse:
 #elf.plain = set_cell_size(self.plain, max_width)
 #f pad and length < max_width:
 #paces = max_width - length
 #elf._text = [f"{self.plain}{' ' * spaces}"]
 #elf._length = len(self.plain)

 #ef _trim_spans(self) -> None:
 #""Remove or modify any spans that are over the end of the text."""
 #ax_offset = len(self.plain)
 #Span = Span
 #elf._spans[:] = [
 #
 #pan
 #f span.end < max_offset
 #lse _Span(span.start, min(max_offset, span.end), span.style)
 #
 #or span in self._spans
 #f span.start < max_offset
 #

 #ef pad(self, count: int, character: str = " ") -> None:
 #""Pad left and right with a given number of characters.

 #rgs:
 #ount (int): Width of padding.
 #""
 #ssert len(character) == 1, "Character must be a string of length 1"
 #f count:
 #ad_characters = character * count
 #elf.plain = f"{pad_characters}{self.plain}{pad_characters}"
 #Span = Span
 #elf._spans[:] = [
 #Span(start + count, end + count, style)
 #or start, end, style in self._spans
 #

 #ef pad_left(self, count: int, character: str = " ") -> None:
 #""Pad the left with a given character.

 #rgs:
 #ount (int): Number of characters to pad.
 #haracter (str, optional): Character to pad with. Defaults to " ".
 #""
 #ssert len(character) == 1, "Character must be a string of length 1"
 #f count:
 #elf.plain = f"{character * count}{self.plain}"
 #Span = Span
 #elf._spans[:] = [
 #Span(start + count, end + count, style)
 #or start, end, style in self._spans
 #

 #ef pad_right(self, count: int, character: str = " ") -> None:
 #""Pad the right with a given character.

 #rgs:
 #ount (int): Number of characters to pad.
 #haracter (str, optional): Character to pad with. Defaults to " ".
 #""
 #ssert len(character) == 1, "Character must be a string of length 1"
 #f count:
 #elf.plain = f"{self.plain}{character * count}"

 #ef align(self, align: AlignMethod, width: int, character: str = " ") -> None:
 #""Align text to a given width.

 #rgs:
 #lign (AlignMethod): One of "left", "center", or "right".
 #idth (int): Desired width.
 #haracter (str, optional): Character to pad with. Defaults to " ".
 #""
 #elf.truncate(width)
 #xcess_space = width - cell_len(self.plain)
 #f excess_space:
 #f align == "left":
 #elf.pad_right(excess_space, character)
 #lif align == "center":
 #eft = excess_space // 2
 #elf.pad_left(left, character)
 #elf.pad_right(excess_space - left, character)
 #lse:
 #elf.pad_left(excess_space, character)

 #ef append(
 #elf, text: Union["Text", str], style: Optional[Union[str, "Style"]] = None
 # -> "Text":
 #""Add text with an optional style.

 #rgs:
 #ext (Union[Text, str]): A str or Text to append.
 #tyle (str, optional): A style name. Defaults to None.

 #eturns:
 #ext: Returns self for chaining.
 #""

 #f not isinstance(text, (str, Text)):
 #aise TypeError("Only str or Text can be appended to Text")

 #f len(text):
 #f isinstance(text, str):
 #anitized_text = strip_control_codes(text)
 #elf._text.append(sanitized_text)
 #ffset = len(self)
 #ext_length = len(sanitized_text)
 #f style is not None:
 #elf._spans.append(Span(offset, offset + text_length, style))
 #elf._length += text_length
 #lif isinstance(text, Text):
 #Span = Span
 #f style is not None:
 #aise ValueError(
 #style must not be set when appending Text instance"
 #
 #ext_length = self._length
 #f text.style is not None:
 #elf._spans.append(
 #Span(text_length, text_length + len(text), text.style)
 #
 #elf._text.append(text.plain)
 #elf._spans.extend(
 #Span(start + text_length, end + text_length, style)
 #or start, end, style in text._spans
 #
 #elf._length += len(text)
 #eturn self

 #ef append_text(self, text: "Text") -> "Text":
 #""Append another Text instance. This method is more performant that Text.append, but
 #nly works for Text.

 #eturns:
 #ext: Returns self for chaining.
 #""
 #Span = Span
 #ext_length = self._length
 #f text.style is not None:
 #elf._spans.append(_Span(text_length, text_length + len(text), text.style))
 #elf._text.append(text.plain)
 #elf._spans.extend(
 #Span(start + text_length, end + text_length, style)
 #or start, end, style in text._spans
 #
 #elf._length += len(text)
 #eturn self

 #ef append_tokens(
 #elf, tokens: Iterable[Tuple[str, Optional[StyleType]]]
 # -> "Text":
 #""Append iterable of str and style. Style may be a Style instance or a str style definition.

 #rgs:
 #airs (Iterable[Tuple[str, Optional[StyleType]]]): An iterable of tuples containing str content and style.

 #eturns:
 #ext: Returns self for chaining.
 #""
 #ppend_text = self._text.append
 #ppend_span = self._spans.append
 #Span = Span
 #ffset = len(self)
 #or content, style in tokens:
 #ppend_text(content)
 #f style is not None:
 #ppend_span(_Span(offset, offset + len(content), style))
 #ffset += len(content)
 #elf._length = offset
 #eturn self

 #ef copy_styles(self, text: "Text") -> None:
 #""Copy styles from another Text instance.

 #rgs:
 #ext (Text): A Text instance to copy styles from, must be the same length.
 #""
 #elf._spans.extend(text._spans)

 #ef split(
 #elf,
 #eparator: str = "\n",
 #,
 #nclude_separator: bool = False,
 #llow_blank: bool = False,
 # -> Lines:
 #""Split rich text in to lines, preserving styles.

 #rgs:
 #eparator (str, optional): String to split on. Defaults to "\\\\n".
 #nclude_separator (bool, optional): Include the separator in the lines. Defaults to False.
 #llow_blank (bool, optional): Return a blank line if the text ends with a separator. Defaults to False.

 #eturns:
 #ist[RichText]: A list of rich text, one per line of the original.
 #""
 #ssert separator, "separator must not be empty"

 #ext = self.plain
 #f separator not in text:
 #eturn Lines([self.copy()])

 #f include_separator:
 #ines = self.divide(
 #atch.end() for match in re.finditer(re.escape(separator), text)
 #
 #lse:

 #ef flatten_spans() -> Iterable[int]:
 #or match in re.finditer(re.escape(separator), text):
 #tart, end = match.span()
 #ield start
 #ield end

 #ines = Lines(
 #ine for line in self.divide(flatten_spans()) if line.plain != separator
 #

 #f not allow_blank and text.endswith(separator):
 #ines.pop()

 #eturn lines

 #ef divide(self, offsets: Iterable[int]) -> Lines:
 #""Divide text in to a number of lines at given offsets.

 #rgs:
 #ffsets (Iterable[int]): Offsets used to divide text.

 #eturns:
 #ines: New RichText instances between offsets.
 #""
 #offsets = list(offsets)

 #f not _offsets:
 #eturn Lines([self.copy()])

 #ext = self.plain
 #ext_length = len(text)
 #ivide_offsets = [0, *_offsets, text_length]
 #ine_ranges = list(zip(divide_offsets, divide_offsets[1:]))

 #tyle = self.style
 #ustify = self.justify
 #verflow = self.overflow
 #Text = Text
 #ew_lines = Lines(
 #Text(
 #ext[start:end],
 #tyle=style,
 #ustify=justify,
 #verflow=overflow,
 #
 #or start, end in line_ranges
 #
 #f not self._spans:
 #eturn new_lines

 #line_appends = [line._spans.append for line in new_lines._lines]
 #ine_count = len(line_ranges)
 #Span = Span

 #or span_start, span_end, style in self._spans:

 #ower_bound = 0
 #pper_bound = line_count
 #tart_line_no = (lower_bound + upper_bound) // 2

 #hile True:
 #ine_start, line_end = line_ranges[start_line_no]
 #f span_start < line_start:
 #pper_bound = start_line_no - 1
 #lif span_start > line_end:
 #ower_bound = start_line_no + 1
 #lse:
 #reak
 #tart_line_no = (lower_bound + upper_bound) // 2

 #f span_end < line_end:
 #nd_line_no = start_line_no
 #lse:
 #nd_line_no = lower_bound = start_line_no
 #pper_bound = line_count

 #hile True:
 #ine_start, line_end = line_ranges[end_line_no]
 #f span_end < line_start:
 #pper_bound = end_line_no - 1
 #lif span_end > line_end:
 #ower_bound = end_line_no + 1
 #lse:
 #reak
 #nd_line_no = (lower_bound + upper_bound) // 2

 #or line_no in range(start_line_no, end_line_no + 1):
 #ine_start, line_end = line_ranges[line_no]
 #ew_start = max(0, span_start - line_start)
 #ew_end = min(span_end - line_start, line_end - line_start)
 #f new_end > new_start:
 #line_appends[line_no](_Span(new_start, new_end, style))

 #eturn new_lines

 #ef right_crop(self, amount: int = 1) -> None:
 #""Remove a number of characters from the end of the text."""
 #ax_offset = len(self.plain) - amount
 #Span = Span
 #elf._spans[:] = [
 #
 #pan
 #f span.end < max_offset
 #lse _Span(span.start, min(max_offset, span.end), span.style)
 #
 #or span in self._spans
 #f span.start < max_offset
 #
 #elf._text = [self.plain[:-amount]]
 #elf._length -= amount

 #ef wrap(
 #elf,
 #onsole: "Console",
 #idth: int,
 #,
 #ustify: Optional["JustifyMethod"] = None,
 #verflow: Optional["OverflowMethod"] = None,
 #ab_size: int = 8,
 #o_wrap: Optional[bool] = None,
 # -> Lines:
 #""Word wrap the text.

 #rgs:
 #onsole (Console): Console instance.
 #idth (int): Number of characters per line.
 #moji (bool, optional): Also render emoji code. Defaults to True.
 #ustify (str, optional): Justify method: "default", "left", "center", "full", "right". Defaults to "default".
 #verflow (str, optional): Overflow method: "crop", "fold", or "ellipsis". Defaults to None.
 #ab_size (int, optional): Default tab size. Defaults to 8.
 #o_wrap (bool, optional): Disable wrapping, Defaults to False.

 #eturns:
 #ines: Number of lines.
 #""
 #rap_justify = justify or self.justify or DEFAULT_JUSTIFY
 #rap_overflow = overflow or self.overflow or DEFAULT_OVERFLOW

 #o_wrap = pick_bool(no_wrap, self.no_wrap, False) or overflow == "ignore"

 #ines = Lines()
 #or line in self.split(allow_blank=True):
 #f "\t" in line:
 #ine.expand_tabs(tab_size)
 #f no_wrap:
 #ew_lines = Lines([line])
 #lse:
 #ffsets = divide_line(str(line), width, fold=wrap_overflow == "fold")
 #ew_lines = line.divide(offsets)
 #or line in new_lines:
 #ine.rstrip_end(width)
 #f wrap_justify:
 #ew_lines.justify(
 #onsole, width, justify=wrap_justify, overflow=wrap_overflow
 #
 #or line in new_lines:
 #ine.truncate(width, overflow=wrap_overflow)
 #ines.extend(new_lines)
 #eturn lines

 #ef fit(self, width: int) -> Lines:
 #""Fit the text in to given width by chopping in to lines.

 #rgs:
 #idth (int): Maximum characters in a line.

 #eturns:
 #ines: Lines container.
 #""
 #ines: Lines = Lines()
 #ppend = lines.append
 #or line in self.split():
 #ine.set_length(width)
 #ppend(line)
 #eturn lines

 #ef detect_indentation(self) -> int:
 #""Auto-detect indentation of code.

 #eturns:
 #nt: Number of spaces used to indent code.
 #""

 #indentations = {
 #en(match.group(1))
 #or match in re.finditer(r"^( *)(.*)$", self.plain, flags=re.MULTILINE)
 #

 #ry:
 #ndentation = (
 #educe(gcd, [indent for indent in _indentations if not indent % 2]) or 1
 #
 #xcept TypeError:
 #ndentation = 1

 #eturn indentation

 #ef with_indent_guides(
 #elf,
 #ndent_size: Optional[int] = None,
 #,
 #haracter: str = "│",
 #tyle: StyleType = "dim green",
 # -> "Text":
 #""Adds indent guide lines to text.

 #rgs:
 #ndent_size (Optional[int]): Size of indentation, or None to auto detect. Defaults to None.
 #haracter (str, optional): Character to use for indentation. Defaults to "│".
 #tyle (Union[Style, str], optional): Style of indent guides.

 #eturns:
 #ext: New text with indentation guides.
 #""

 #indent_size = self.detect_indentation() if indent_size is None else indent_size

 #ext = self.copy()
 #ext.expand_tabs()
 #ndent_line = f"{character}{' ' * (_indent_size - 1)}"

 #e_indent = re.compile(r"^( *)(.*)$")
 #ew_lines: List[Text] = []
 #dd_line = new_lines.append
 #lank_lines = 0
 #or line in text.split(allow_blank=True):
 #atch = re_indent.match(line.plain)
 #f not match or not match.group(2):
 #lank_lines += 1
 #ontinue
 #ndent = match.group(1)
 #ull_indents, remaining_space = divmod(len(indent), _indent_size)
 #ew_indent = f"{indent_line * full_indents}{' ' * remaining_space}"
 #ine.plain = new_indent + line.plain[len(new_indent) :]
 #ine.stylize(style, 0, len(new_indent))
 #f blank_lines:
 #ew_lines.extend([Text(new_indent, style=style)] * blank_lines)
 #lank_lines = 0
 #dd_line(line)
 #f blank_lines:
 #ew_lines.extend([Text("", style=style)] * blank_lines)

 #ew_text = text.blank_copy("\n").join(new_lines)
 #eturn new_text


if __name__ == "__main__":  # pragma: no cover
 #rom pip._vendor.rich.console import Console

 #ext = Text(
 #""\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"""
 #
 #ext.highlight_words(["Lorem"], "bold")
 #ext.highlight_words(["ipsum"], "italic")

 #onsole = Console()

 #onsole.rule("justify='left'")
 #onsole.print(text, style="red")
 #onsole.print()

 #onsole.rule("justify='center'")
 #onsole.print(text, style="green", justify="center")
 #onsole.print()

 #onsole.rule("justify='right'")
 #onsole.print(text, style="blue", justify="right")
 #onsole.print()

 #onsole.rule("justify='full'")
 #onsole.print(text, style="magenta", justify="full")
 #onsole.print()
