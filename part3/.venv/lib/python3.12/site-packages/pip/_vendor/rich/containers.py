from itertools import zip_longest
from typing import (
 #terator,
 #terable,
 #ist,
 #ptional,
 #nion,
 #verload,
 #ypeVar,
 #YPE_CHECKING,
)

if TYPE_CHECKING:
 #rom .console import (
 #onsole,
 #onsoleOptions,
 #ustifyMethod,
 #verflowMethod,
 #enderResult,
 #enderableType,
 #
 #rom .text import Text

from .cells import cell_len
from .measure import Measurement

T = TypeVar("T")


class Renderables:
 #""A list subclass which renders its contents to the console."""

 #ef __init__(
 #elf, renderables: Optional[Iterable["RenderableType"]] = None
 # -> None:
 #elf._renderables: List["RenderableType"] = (
 #ist(renderables) if renderables is not None else []
 #

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "RenderResult":
 #""Console render method to insert line-breaks."""
 #ield from self._renderables

 #ef __rich_measure__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "Measurement":
 #imensions = [
 #easurement.get(console, options, renderable)
 #or renderable in self._renderables
 #
 #f not dimensions:
 #eturn Measurement(1, 1)
 #min = max(dimension.minimum for dimension in dimensions)
 #max = max(dimension.maximum for dimension in dimensions)
 #eturn Measurement(_min, _max)

 #ef append(self, renderable: "RenderableType") -> None:
 #elf._renderables.append(renderable)

 #ef __iter__(self) -> Iterable["RenderableType"]:
 #eturn iter(self._renderables)


class Lines:
 #""A list subclass which can render to the console."""

 #ef __init__(self, lines: Iterable["Text"] = ()) -> None:
 #elf._lines: List["Text"] = list(lines)

 #ef __repr__(self) -> str:
 #eturn f"Lines({self._lines!r})"

 #ef __iter__(self) -> Iterator["Text"]:
 #eturn iter(self._lines)

 #overload
 #ef __getitem__(self, index: int) -> "Text":
 #..

 #overload
 #ef __getitem__(self, index: slice) -> List["Text"]:
 #..

 #ef __getitem__(self, index: Union[slice, int]) -> Union["Text", List["Text"]]:
 #eturn self._lines[index]

 #ef __setitem__(self, index: int, value: "Text") -> "Lines":
 #elf._lines[index] = value
 #eturn self

 #ef __len__(self) -> int:
 #eturn self._lines.__len__()

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "RenderResult":
 #""Console render method to insert line-breaks."""
 #ield from self._lines

 #ef append(self, line: "Text") -> None:
 #elf._lines.append(line)

 #ef extend(self, lines: Iterable["Text"]) -> None:
 #elf._lines.extend(lines)

 #ef pop(self, index: int = -1) -> "Text":
 #eturn self._lines.pop(index)

 #ef justify(
 #elf,
 #onsole: "Console",
 #idth: int,
 #ustify: "JustifyMethod" = "left",
 #verflow: "OverflowMethod" = "fold",
 # -> None:
 #""Justify and overflow text to a given width.

 #rgs:
 #onsole (Console): Console instance.
 #idth (int): Number of characters per line.
 #ustify (str, optional): Default justify method for text: "left", "center", "full" or "right". Defaults to "left".
 #verflow (str, optional): Default overflow for text: "crop", "fold", or "ellipsis". Defaults to "fold".

 #""
 #rom .text import Text

 #f justify == "left":
 #or line in self._lines:
 #ine.truncate(width, overflow=overflow, pad=True)
 #lif justify == "center":
 #or line in self._lines:
 #ine.rstrip()
 #ine.truncate(width, overflow=overflow)
 #ine.pad_left((width - cell_len(line.plain)) // 2)
 #ine.pad_right(width - cell_len(line.plain))
 #lif justify == "right":
 #or line in self._lines:
 #ine.rstrip()
 #ine.truncate(width, overflow=overflow)
 #ine.pad_left(width - cell_len(line.plain))
 #lif justify == "full":
 #or line_index, line in enumerate(self._lines):
 #f line_index == len(self._lines) - 1:
 #reak
 #ords = line.split(" ")
 #ords_size = sum(cell_len(word.plain) for word in words)
 #um_spaces = len(words) - 1
 #paces = [1 for _ in range(num_spaces)]
 #ndex = 0
 #f spaces:
 #hile words_size + num_spaces < width:
 #paces[len(spaces) - index - 1] += 1
 #um_spaces += 1
 #ndex = (index + 1) % len(spaces)
 #okens: List[Text] = []
 #or index, (word, next_word) in enumerate(
 #ip_longest(words, words[1:])
 #:
 #okens.append(word)
 #f index < len(spaces):
 #tyle = word.get_style_at_offset(console, -1)
 #ext_style = next_word.get_style_at_offset(console, 0)
 #pace_style = style if style == next_style else line.style
 #okens.append(Text(" " * spaces[index], style=space_style))
 #elf[line_index] = Text("").join(tokens)
