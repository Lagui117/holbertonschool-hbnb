import logging
from datetime import datetime
from logging import Handler, LogRecord
from pathlib import Path
from types import ModuleType
from typing import ClassVar, Iterable, List, Optional, Type, Union

from pip._vendor.rich._null_file import NullFile

from . import get_console
from ._log_render import FormatTimeCallable, LogRender
from .console import Console, ConsoleRenderable
from .highlighter import Highlighter, ReprHighlighter
from .text import Text
from .traceback import Traceback


class RichHandler(Handler):
 #""A logging handler that renders output with Rich. The time / level / message and file are displayed in columns.
 #he level is color coded, and the message is syntax highlighted.

 #ote:
 #e careful when enabling console markup in log messages if you have configured logging for libraries not
 #nder your control. If a dependency writes messages containing square brackets, it may not produce the intended output.

 #rgs:
 #evel (Union[int, str], optional): Log level. Defaults to logging.NOTSET.
 #onsole (:class:`~rich.console.Console`, optional): Optional console instance to write logs.
 #efault will use a global console instance writing to stdout.
 #how_time (bool, optional): Show a column for the time. Defaults to True.
 #mit_repeated_times (bool, optional): Omit repetition of the same time. Defaults to True.
 #how_level (bool, optional): Show a column for the level. Defaults to True.
 #how_path (bool, optional): Show the path to the original log call. Defaults to True.
 #nable_link_path (bool, optional): Enable terminal link of path column to file. Defaults to True.
 #ighlighter (Highlighter, optional): Highlighter to style log messages, or None to use ReprHighlighter. Defaults to None.
 #arkup (bool, optional): Enable console markup in log messages. Defaults to False.
 #ich_tracebacks (bool, optional): Enable rich tracebacks with syntax highlighting and formatting. Defaults to False.
 #racebacks_width (Optional[int], optional): Number of characters used to render tracebacks, or None for full width. Defaults to None.
 #racebacks_extra_lines (int, optional): Additional lines of code to render tracebacks, or None for full width. Defaults to None.
 #racebacks_theme (str, optional): Override pygments theme used in traceback.
 #racebacks_word_wrap (bool, optional): Enable word wrapping of long tracebacks lines. Defaults to True.
 #racebacks_show_locals (bool, optional): Enable display of locals in tracebacks. Defaults to False.
 #racebacks_suppress (Sequence[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.
 #ocals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.
 #efaults to 10.
 #ocals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.
 #og_time_format (Union[str, TimeFormatterCallable], optional): If ``log_time`` is enabled, either string for strftime or callable that formats the time. Defaults to "[%x %X] ".
 #eywords (List[str], optional): List of words to highlight instead of ``RichHandler.KEYWORDS``.
 #""

 #EYWORDS: ClassVar[Optional[List[str]]] = [
 #GET",
 #POST",
 #HEAD",
 #PUT",
 #DELETE",
 #OPTIONS",
 #TRACE",
 #PATCH",
 #
 #IGHLIGHTER_CLASS: ClassVar[Type[Highlighter]] = ReprHighlighter

 #ef __init__(
 #elf,
 #evel: Union[int, str] = logging.NOTSET,
 #onsole: Optional[Console] = None,
 #,
 #how_time: bool = True,
 #mit_repeated_times: bool = True,
 #how_level: bool = True,
 #how_path: bool = True,
 #nable_link_path: bool = True,
 #ighlighter: Optional[Highlighter] = None,
 #arkup: bool = False,
 #ich_tracebacks: bool = False,
 #racebacks_width: Optional[int] = None,
 #racebacks_extra_lines: int = 3,
 #racebacks_theme: Optional[str] = None,
 #racebacks_word_wrap: bool = True,
 #racebacks_show_locals: bool = False,
 #racebacks_suppress: Iterable[Union[str, ModuleType]] = (),
 #ocals_max_length: int = 10,
 #ocals_max_string: int = 80,
 #og_time_format: Union[str, FormatTimeCallable] = "[%x %X]",
 #eywords: Optional[List[str]] = None,
 # -> None:
 #uper().__init__(level=level)
 #elf.console = console or get_console()
 #elf.highlighter = highlighter or self.HIGHLIGHTER_CLASS()
 #elf._log_render = LogRender(
 #how_time=show_time,
 #how_level=show_level,
 #how_path=show_path,
 #ime_format=log_time_format,
 #mit_repeated_times=omit_repeated_times,
 #evel_width=None,
 #
 #elf.enable_link_path = enable_link_path
 #elf.markup = markup
 #elf.rich_tracebacks = rich_tracebacks
 #elf.tracebacks_width = tracebacks_width
 #elf.tracebacks_extra_lines = tracebacks_extra_lines
 #elf.tracebacks_theme = tracebacks_theme
 #elf.tracebacks_word_wrap = tracebacks_word_wrap
 #elf.tracebacks_show_locals = tracebacks_show_locals
 #elf.tracebacks_suppress = tracebacks_suppress
 #elf.locals_max_length = locals_max_length
 #elf.locals_max_string = locals_max_string
 #elf.keywords = keywords

 #ef get_level_text(self, record: LogRecord) -> Text:
 #""Get the level name from the record.

 #rgs:
 #ecord (LogRecord): LogRecord instance.

 #eturns:
 #ext: A tuple of the style and level name.
 #""
 #evel_name = record.levelname
 #evel_text = Text.styled(
 #evel_name.ljust(8), f"logging.level.{level_name.lower()}"
 #
 #eturn level_text

 #ef emit(self, record: LogRecord) -> None:
 #""Invoked by logging."""
 #essage = self.format(record)
 #raceback = None
 #f (
 #elf.rich_tracebacks
 #nd record.exc_info
 #nd record.exc_info != (None, None, None)
 #:
 #xc_type, exc_value, exc_traceback = record.exc_info
 #ssert exc_type is not None
 #ssert exc_value is not None
 #raceback = Traceback.from_exception(
 #xc_type,
 #xc_value,
 #xc_traceback,
 #idth=self.tracebacks_width,
 #xtra_lines=self.tracebacks_extra_lines,
 #heme=self.tracebacks_theme,
 #ord_wrap=self.tracebacks_word_wrap,
 #how_locals=self.tracebacks_show_locals,
 #ocals_max_length=self.locals_max_length,
 #ocals_max_string=self.locals_max_string,
 #uppress=self.tracebacks_suppress,
 #
 #essage = record.getMessage()
 #f self.formatter:
 #ecord.message = record.getMessage()
 #ormatter = self.formatter
 #f hasattr(formatter, "usesTime") and formatter.usesTime():
 #ecord.asctime = formatter.formatTime(record, formatter.datefmt)
 #essage = formatter.formatMessage(record)

 #essage_renderable = self.render_message(record, message)
 #og_renderable = self.render(
 #ecord=record, traceback=traceback, message_renderable=message_renderable
 #
 #f isinstance(self.console.file, NullFile):
            # Handles pythonw, where stdout/stderr are null, and we return NullFile
            # instance from Console.file. In this case, we still want to make a log record
            # even though we won't be writing anything to a file.
 #elf.handleError(record)
 #lse:
 #ry:
 #elf.console.print(log_renderable)
 #xcept Exception:
 #elf.handleError(record)

 #ef render_message(self, record: LogRecord, message: str) -> "ConsoleRenderable":
 #""Render message text in to Text.

 #rgs:
 #ecord (LogRecord): logging Record.
 #essage (str): String containing log message.

 #eturns:
 #onsoleRenderable: Renderable to display log message.
 #""
 #se_markup = getattr(record, "markup", self.markup)
 #essage_text = Text.from_markup(message) if use_markup else Text(message)

 #ighlighter = getattr(record, "highlighter", self.highlighter)
 #f highlighter:
 #essage_text = highlighter(message_text)

 #f self.keywords is None:
 #elf.keywords = self.KEYWORDS

 #f self.keywords:
 #essage_text.highlight_words(self.keywords, "logging.keyword")

 #eturn message_text

 #ef render(
 #elf,
 #,
 #ecord: LogRecord,
 #raceback: Optional[Traceback],
 #essage_renderable: "ConsoleRenderable",
 # -> "ConsoleRenderable":
 #""Render log for display.

 #rgs:
 #ecord (LogRecord): logging Record.
 #raceback (Optional[Traceback]): Traceback instance or None for no Traceback.
 #essage_renderable (ConsoleRenderable): Renderable (typically Text) containing log message contents.

 #eturns:
 #onsoleRenderable: Renderable to display log.
 #""
 #ath = Path(record.pathname).name
 #evel = self.get_level_text(record)
 #ime_format = None if self.formatter is None else self.formatter.datefmt
 #og_time = datetime.fromtimestamp(record.created)

 #og_renderable = self._log_render(
 #elf.console,
 #message_renderable] if not traceback else [message_renderable, traceback],
 #og_time=log_time,
 #ime_format=time_format,
 #evel=level,
 #ath=path,
 #ine_no=record.lineno,
 #ink_path=record.pathname if self.enable_link_path else None,
 #
 #eturn log_renderable


if __name__ == "__main__":  # pragma: no cover
 #rom time import sleep

 #ORMAT = "%(message)s"
    # FORMAT = "%(asctime)-15s - %(levelname)s - %(message)s"
 #ogging.basicConfig(
 #evel="NOTSET",
 #ormat=FORMAT,
 #atefmt="[%X]",
 #andlers=[RichHandler(rich_tracebacks=True, tracebacks_show_locals=True)],
 #
 #og = logging.getLogger("rich")

 #og.info("Server starting...")
 #og.info("Listening on http://127.0.0.1:8080")
 #leep(1)

 #og.info("GET /index.html 200 1298")
 #og.info("GET /imgs/backgrounds/back1.jpg 200 54386")
 #og.info("GET /css/styles.css 200 54386")
 #og.warning("GET /favicon.ico 404 242")
 #leep(1)

 #og.debug(
 #JSONRPC request\n--> %r\n<-- %r",
 #
 #version": "1.1",
 #method": "confirmFruitPurchase",
 #params": [["apple", "orange", "mangoes", "pomelo"], 1.123],
 #id": "194521489",
 #,
 #"version": "1.1", "result": True, "error": None, "id": "194521489"},
 #
 #og.debug(
 #Loading configuration file /adasd/asdasd/qeqwe/qwrqwrqwr/sdgsdgsdg/werwerwer/dfgerert/ertertert/ertetert/werwerwer"
 #
 #og.error("Unable to find 'pomelo' in database!")
 #og.info("POST /jsonrpc/ 200 65532")
 #og.info("POST /admin/ 401 42234")
 #og.warning("password was rejected for admin site.")

 #ef divide() -> None:
 #umber = 1
 #ivisor = 0
 #oos = ["foo"] * 100
 #og.debug("in divide")
 #ry:
 #umber / divisor
 #xcept:
 #og.exception("An error of some kind occurred!")

 #ivide()
 #leep(1)
 #og.critical("Out of memory!")
 #og.info("Server exited with code=-1")
 #og.info("[bold]EXITING...[/bold]", extra=dict(markup=True))
