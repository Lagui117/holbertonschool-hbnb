import io
from typing import IO, TYPE_CHECKING, Any, List

from .ansi import AnsiDecoder
from .text import Text

if TYPE_CHECKING:
 #rom .console import Console


class FileProxy(io.TextIOBase):
 #""Wraps a file (e.g. sys.stdout) and redirects writes to a console."""

 #ef __init__(self, console: "Console", file: IO[str]) -> None:
 #elf.__console = console
 #elf.__file = file
 #elf.__buffer: List[str] = []
 #elf.__ansi_decoder = AnsiDecoder()

 #property
 #ef rich_proxied_file(self) -> IO[str]:
 #""Get proxied file."""
 #eturn self.__file

 #ef __getattr__(self, name: str) -> Any:
 #eturn getattr(self.__file, name)

 #ef write(self, text: str) -> int:
 #f not isinstance(text, str):
 #aise TypeError(f"write() argument must be str, not {type(text).__name__}")
 #uffer = self.__buffer
 #ines: List[str] = []
 #hile text:
 #ine, new_line, text = text.partition("\n")
 #f new_line:
 #ines.append("".join(buffer) + line)
 #uffer.clear()
 #lse:
 #uffer.append(line)
 #reak
 #f lines:
 #onsole = self.__console
 #ith console:
 #utput = Text("\n").join(
 #elf.__ansi_decoder.decode_line(line) for line in lines
 #
 #onsole.print(output)
 #eturn len(text)

 #ef flush(self) -> None:
 #utput = "".join(self.__buffer)
 #f output:
 #elf.__console.print(output)
 #el self.__buffer[:]

 #ef fileno(self) -> int:
 #eturn self.__file.fileno()
