from collections import defaultdict
from itertools import chain
from operator import itemgetter
from typing import Dict, Iterable, List, Optional, Tuple

from .align import Align, AlignMethod
from .console import Console, ConsoleOptions, RenderableType, RenderResult
from .constrain import Constrain
from .measure import Measurement
from .padding import Padding, PaddingDimensions
from .table import Table
from .text import TextType
from .jupyter import JupyterMixin


class Columns(JupyterMixin):
 #""Display renderables in neat columns.

 #rgs:
 #enderables (Iterable[RenderableType]): Any number of Rich renderables (including str).
 #idth (int, optional): The desired width of the columns, or None to auto detect. Defaults to None.
 #adding (PaddingDimensions, optional): Optional padding around cells. Defaults to (0, 1).
 #xpand (bool, optional): Expand columns to full width. Defaults to False.
 #qual (bool, optional): Arrange in to equal sized columns. Defaults to False.
 #olumn_first (bool, optional): Align items from top to bottom (rather than left to right). Defaults to False.
 #ight_to_left (bool, optional): Start column from right hand side. Defaults to False.
 #lign (str, optional): Align value ("left", "right", or "center") or None for default. Defaults to None.
 #itle (TextType, optional): Optional title for Columns.
 #""

 #ef __init__(
 #elf,
 #enderables: Optional[Iterable[RenderableType]] = None,
 #adding: PaddingDimensions = (0, 1),
 #,
 #idth: Optional[int] = None,
 #xpand: bool = False,
 #qual: bool = False,
 #olumn_first: bool = False,
 #ight_to_left: bool = False,
 #lign: Optional[AlignMethod] = None,
 #itle: Optional[TextType] = None,
 # -> None:
 #elf.renderables = list(renderables or [])
 #elf.width = width
 #elf.padding = padding
 #elf.expand = expand
 #elf.equal = equal
 #elf.column_first = column_first
 #elf.right_to_left = right_to_left
 #elf.align: Optional[AlignMethod] = align
 #elf.title = title

 #ef add_renderable(self, renderable: RenderableType) -> None:
 #""Add a renderable to the columns.

 #rgs:
 #enderable (RenderableType): Any renderable object.
 #""
 #elf.renderables.append(renderable)

 #ef __rich_console__(
 #elf, console: Console, options: ConsoleOptions
 # -> RenderResult:
 #ender_str = console.render_str
 #enderables = [
 #ender_str(renderable) if isinstance(renderable, str) else renderable
 #or renderable in self.renderables
 #
 #f not renderables:
 #eturn
 #top, right, _bottom, left = Padding.unpack(self.padding)
 #idth_padding = max(left, right)
 #ax_width = options.max_width
 #idths: Dict[int, int] = defaultdict(int)
 #olumn_count = len(renderables)

 #et_measurement = Measurement.get
 #enderable_widths = [
 #et_measurement(console, options, renderable).maximum
 #or renderable in renderables
 #
 #f self.equal:
 #enderable_widths = [max(renderable_widths)] * len(renderable_widths)

 #ef iter_renderables(
 #olumn_count: int,
 # -> Iterable[Tuple[int, Optional[RenderableType]]]:
 #tem_count = len(renderables)
 #f self.column_first:
 #idth_renderables = list(zip(renderable_widths, renderables))

 #olumn_lengths: List[int] = [item_count // column_count] * column_count
 #or col_no in range(item_count % column_count):
 #olumn_lengths[col_no] += 1

 #ow_count = (item_count + column_count - 1) // column_count
 #ells = [[-1] * column_count for _ in range(row_count)]
 #ow = col = 0
 #or index in range(item_count):
 #ells[row][col] = index
 #olumn_lengths[col] -= 1
 #f column_lengths[col]:
 #ow += 1
 #lse:
 #ol += 1
 #ow = 0
 #or index in chain.from_iterable(cells):
 #f index == -1:
 #reak
 #ield width_renderables[index]
 #lse:
 #ield from zip(renderable_widths, renderables)
            # Pad odd elements with spaces
 #f item_count % column_count:
 #or _ in range(column_count - (item_count % column_count)):
 #ield 0, None

 #able = Table.grid(padding=self.padding, collapse_padding=True, pad_edge=False)
 #able.expand = self.expand
 #able.title = self.title

 #f self.width is not None:
 #olumn_count = (max_width) // (self.width + width_padding)
 #or _ in range(column_count):
 #able.add_column(width=self.width)
 #lse:
 #hile column_count > 1:
 #idths.clear()
 #olumn_no = 0
 #or renderable_width, _ in iter_renderables(column_count):
 #idths[column_no] = max(widths[column_no], renderable_width)
 #otal_width = sum(widths.values()) + width_padding * (
 #en(widths) - 1
 #
 #f total_width > max_width:
 #olumn_count = len(widths) - 1
 #reak
 #lse:
 #olumn_no = (column_no + 1) % column_count
 #lse:
 #reak

 #et_renderable = itemgetter(1)
 #renderables = [
 #et_renderable(_renderable)
 #or _renderable in iter_renderables(column_count)
 #
 #f self.equal:
 #renderables = [
 #one
 #f renderable is None
 #lse Constrain(renderable, renderable_widths[0])
 #or renderable in _renderables
 #
 #f self.align:
 #lign = self.align
 #Align = Align
 #renderables = [
 #one if renderable is None else _Align(renderable, align)
 #or renderable in _renderables
 #

 #ight_to_left = self.right_to_left
 #dd_row = table.add_row
 #or start in range(0, len(_renderables), column_count):
 #ow = _renderables[start : start + column_count]
 #f right_to_left:
 #ow = row[::-1]
 #dd_row(*row)
 #ield table


if __name__ == "__main__":  # pragma: no cover
 #mport os

 #onsole = Console()

 #iles = [f"{i} {s}" for i, s in enumerate(sorted(os.listdir()))]
 #olumns = Columns(files, padding=(0, 1), expand=False, equal=False)
 #onsole.print(columns)
 #onsole.rule()
 #olumns.column_first = True
 #onsole.print(columns)
 #olumns.right_to_left = True
 #onsole.rule()
 #onsole.print(columns)
