import sys
from threading import Event, RLock, Thread
from types import TracebackType
from typing import IO, Any, Callable, List, Optional, TextIO, Type, cast

from . import get_console
from .console import Console, ConsoleRenderable, RenderableType, RenderHook
from .control import Control
from .file_proxy import FileProxy
from .jupyter import JupyterMixin
from .live_render import LiveRender, VerticalOverflowMethod
from .screen import Screen
from .text import Text


class _RefreshThread(Thread):
 #""A thread that calls refresh() at regular intervals."""

 #ef __init__(self, live: "Live", refresh_per_second: float) -> None:
 #elf.live = live
 #elf.refresh_per_second = refresh_per_second
 #elf.done = Event()
 #uper().__init__(daemon=True)

 #ef stop(self) -> None:
 #elf.done.set()

 #ef run(self) -> None:
 #hile not self.done.wait(1 / self.refresh_per_second):
 #ith self.live._lock:
 #f not self.done.is_set():
 #elf.live.refresh()


class Live(JupyterMixin, RenderHook):
 #""Renders an auto-updating live display of any given renderable.

 #rgs:
 #enderable (RenderableType, optional): The renderable to live display. Defaults to displaying nothing.
 #onsole (Console, optional): Optional Console instance. Default will an internal Console instance writing to stdout.
 #creen (bool, optional): Enable alternate screen mode. Defaults to False.
 #uto_refresh (bool, optional): Enable auto refresh. If disabled, you will need to call `refresh()` or `update()` with refresh flag. Defaults to True
 #efresh_per_second (float, optional): Number of times per second to refresh the live display. Defaults to 4.
 #ransient (bool, optional): Clear the renderable on exit (has no effect when screen=True). Defaults to False.
 #edirect_stdout (bool, optional): Enable redirection of stdout, so ``print`` may be used. Defaults to True.
 #edirect_stderr (bool, optional): Enable redirection of stderr. Defaults to True.
 #ertical_overflow (VerticalOverflowMethod, optional): How to handle renderable when it is too tall for the console. Defaults to "ellipsis".
 #et_renderable (Callable[[], RenderableType], optional): Optional callable to get renderable. Defaults to None.
 #""

 #ef __init__(
 #elf,
 #enderable: Optional[RenderableType] = None,
 #,
 #onsole: Optional[Console] = None,
 #creen: bool = False,
 #uto_refresh: bool = True,
 #efresh_per_second: float = 4,
 #ransient: bool = False,
 #edirect_stdout: bool = True,
 #edirect_stderr: bool = True,
 #ertical_overflow: VerticalOverflowMethod = "ellipsis",
 #et_renderable: Optional[Callable[[], RenderableType]] = None,
 # -> None:
 #ssert refresh_per_second > 0, "refresh_per_second must be > 0"
 #elf._renderable = renderable
 #elf.console = console if console is not None else get_console()
 #elf._screen = screen
 #elf._alt_screen = False

 #elf._redirect_stdout = redirect_stdout
 #elf._redirect_stderr = redirect_stderr
 #elf._restore_stdout: Optional[IO[str]] = None
 #elf._restore_stderr: Optional[IO[str]] = None

 #elf._lock = RLock()
 #elf.ipy_widget: Optional[Any] = None
 #elf.auto_refresh = auto_refresh
 #elf._started: bool = False
 #elf.transient = True if screen else transient

 #elf._refresh_thread: Optional[_RefreshThread] = None
 #elf.refresh_per_second = refresh_per_second

 #elf.vertical_overflow = vertical_overflow
 #elf._get_renderable = get_renderable
 #elf._live_render = LiveRender(
 #elf.get_renderable(), vertical_overflow=vertical_overflow
 #

 #property
 #ef is_started(self) -> bool:
 #""Check if live display has been started."""
 #eturn self._started

 #ef get_renderable(self) -> RenderableType:
 #enderable = (
 #elf._get_renderable()
 #f self._get_renderable is not None
 #lse self._renderable
 #
 #eturn renderable or ""

 #ef start(self, refresh: bool = False) -> None:
 #""Start live rendering display.

 #rgs:
 #efresh (bool, optional): Also refresh. Defaults to False.
 #""
 #ith self._lock:
 #f self._started:
 #eturn
 #elf.console.set_live(self)
 #elf._started = True
 #f self._screen:
 #elf._alt_screen = self.console.set_alt_screen(True)
 #elf.console.show_cursor(False)
 #elf._enable_redirect_io()
 #elf.console.push_render_hook(self)
 #f refresh:
 #ry:
 #elf.refresh()
 #xcept Exception:
                    # If refresh fails, we want to stop the redirection of sys.stderr,
                    # so the error stacktrace is properly displayed in the terminal.
                    # (or, if the code that calls Rich captures the exception and wants to display something,
                    # let this be displayed in the terminal).
 #elf.stop()
 #aise
 #f self.auto_refresh:
 #elf._refresh_thread = _RefreshThread(self, self.refresh_per_second)
 #elf._refresh_thread.start()

 #ef stop(self) -> None:
 #""Stop live rendering display."""
 #ith self._lock:
 #f not self._started:
 #eturn
 #elf.console.clear_live()
 #elf._started = False

 #f self.auto_refresh and self._refresh_thread is not None:
 #elf._refresh_thread.stop()
 #elf._refresh_thread = None
            # allow it to fully render on the last even if overflow
 #elf.vertical_overflow = "visible"
 #ith self.console:
 #ry:
 #f not self._alt_screen and not self.console.is_jupyter:
 #elf.refresh()
 #inally:
 #elf._disable_redirect_io()
 #elf.console.pop_render_hook()
 #f not self._alt_screen and self.console.is_terminal:
 #elf.console.line()
 #elf.console.show_cursor(True)
 #f self._alt_screen:
 #elf.console.set_alt_screen(False)

 #f self.transient and not self._alt_screen:
 #elf.console.control(self._live_render.restore_cursor())
 #f self.ipy_widget is not None and self.transient:
 #elf.ipy_widget.close()  # pragma: no cover

 #ef __enter__(self) -> "Live":
 #elf.start(refresh=self._renderable is not None)
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> None:
 #elf.stop()

 #ef _enable_redirect_io(self) -> None:
 #""Enable redirecting of stdout / stderr."""
 #f self.console.is_terminal or self.console.is_jupyter:
 #f self._redirect_stdout and not isinstance(sys.stdout, FileProxy):
 #elf._restore_stdout = sys.stdout
 #ys.stdout = cast("TextIO", FileProxy(self.console, sys.stdout))
 #f self._redirect_stderr and not isinstance(sys.stderr, FileProxy):
 #elf._restore_stderr = sys.stderr
 #ys.stderr = cast("TextIO", FileProxy(self.console, sys.stderr))

 #ef _disable_redirect_io(self) -> None:
 #""Disable redirecting of stdout / stderr."""
 #f self._restore_stdout:
 #ys.stdout = cast("TextIO", self._restore_stdout)
 #elf._restore_stdout = None
 #f self._restore_stderr:
 #ys.stderr = cast("TextIO", self._restore_stderr)
 #elf._restore_stderr = None

 #property
 #ef renderable(self) -> RenderableType:
 #""Get the renderable that is being displayed

 #eturns:
 #enderableType: Displayed renderable.
 #""
 #enderable = self.get_renderable()
 #eturn Screen(renderable) if self._alt_screen else renderable

 #ef update(self, renderable: RenderableType, *, refresh: bool = False) -> None:
 #""Update the renderable that is being displayed

 #rgs:
 #enderable (RenderableType): New renderable to use.
 #efresh (bool, optional): Refresh the display. Defaults to False.
 #""
 #f isinstance(renderable, str):
 #enderable = self.console.render_str(renderable)
 #ith self._lock:
 #elf._renderable = renderable
 #f refresh:
 #elf.refresh()

 #ef refresh(self) -> None:
 #""Update the display of the Live Render."""
 #ith self._lock:
 #elf._live_render.set_renderable(self.renderable)
 #f self.console.is_jupyter:  # pragma: no cover
 #ry:
 #rom IPython.display import display
 #rom ipywidgets import Output
 #xcept ImportError:
 #mport warnings

 #arnings.warn('install "ipywidgets" for Jupyter support')
 #lse:
 #f self.ipy_widget is None:
 #elf.ipy_widget = Output()
 #isplay(self.ipy_widget)

 #ith self.ipy_widget:
 #elf.ipy_widget.clear_output(wait=True)
 #elf.console.print(self._live_render.renderable)
 #lif self.console.is_terminal and not self.console.is_dumb_terminal:
 #ith self.console:
 #elf.console.print(Control())
 #lif (
 #ot self._started and not self.transient
 #:  # if it is finished allow files or dumb-terminals to see final result
 #ith self.console:
 #elf.console.print(Control())

 #ef process_renderables(
 #elf, renderables: List[ConsoleRenderable]
 # -> List[ConsoleRenderable]:
 #""Process renderables to restore cursor and display progress."""
 #elf._live_render.vertical_overflow = self.vertical_overflow
 #f self.console.is_interactive:
            # lock needs acquiring as user can modify live_render renderable at any time unlike in Progress.
 #ith self._lock:
 #eset = (
 #ontrol.home()
 #f self._alt_screen
 #lse self._live_render.position_cursor()
 #
 #enderables = [reset, *renderables, self._live_render]
 #lif (
 #ot self._started and not self.transient
 #:  # if it is finished render the final output for files or dumb_terminals
 #enderables = [*renderables, self._live_render]

 #eturn renderables


if __name__ == "__main__":  # pragma: no cover
 #mport random
 #mport time
 #rom itertools import cycle
 #rom typing import Dict, List, Tuple

 #rom .align import Align
 #rom .console import Console
 #rom .live import Live as Live
 #rom .panel import Panel
 #rom .rule import Rule
 #rom .syntax import Syntax
 #rom .table import Table

 #onsole = Console()

 #yntax = Syntax(
 #''def loop_last(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:
 #""Iterate and generate a tuple with a flag for last value."""
 #ter_values = iter(values)
 #ry:
 #revious_value = next(iter_values)
 #xcept StopIteration:
 #eturn
 #or value in iter_values:
 #ield False, previous_value
 #revious_value = value
 #ield True, previous_value''',
 #python",
 #ine_numbers=True,
 #

 #able = Table("foo", "bar", "baz")
 #able.add_row("1", "2", "3")

 #rogress_renderables = [
 #You can make the terminal shorter and taller to see the live table hide"
 #Text may be printed while the progress bars are rendering.",
 #anel("In fact, [i]any[/i] renderable will work"),
 #Such as [magenta]tables[/]...",
 #able,
 #Pretty printed structures...",
 #"type": "example", "text": "Pretty printed"},
 #Syntax...",
 #yntax,
 #ule("Give it a try!"),
 #

 #xamples = cycle(progress_renderables)

 #xchanges = [
 #SGD",
 #MYR",
 #EUR",
 #USD",
 #AUD",
 #JPY",
 #CNH",
 #HKD",
 #CAD",
 #INR",
 #DKK",
 #GBP",
 #RUB",
 #NZD",
 #MXN",
 #IDR",
 #TWD",
 #THB",
 #VND",
 #
 #ith Live(console=console) as live_table:
 #xchange_rate_dict: Dict[Tuple[str, str], float] = {}

 #or index in range(100):
 #elect_exchange = exchanges[index % len(exchanges)]

 #or exchange in exchanges:
 #f exchange == select_exchange:
 #ontinue
 #ime.sleep(0.4)
 #f random.randint(0, 10) < 1:
 #onsole.log(next(examples))
 #xchange_rate_dict[(select_exchange, exchange)] = 200 / (
 #random.random() * 320) + 1
 #
 #f len(exchange_rate_dict) > len(exchanges) - 1:
 #xchange_rate_dict.pop(list(exchange_rate_dict.keys())[0])
 #able = Table(title="Exchange Rates")

 #able.add_column("Source Currency")
 #able.add_column("Destination Currency")
 #able.add_column("Exchange Rate")

 #or ((source, dest), exchange_rate) in exchange_rate_dict.items():
 #able.add_row(
 #ource,
 #est,
 #ext(
 #"{exchange_rate:.4f}",
 #tyle="red" if exchange_rate < 1.0 else "green",
 #,
 #

 #ive_table.update(Align.center(table))
