import re
from functools import lru_cache
from typing import Callable, List

from ._cell_widths import CELL_WIDTHS

# Regex to match sequence of the most common character ranges
_is_single_cell_widths = re.compile("^[\u0020-\u006f\u00a0\u02ff\u0370-\u0482]*$").match


@lru_cache(4096)
def cached_cell_len(text: str) -> int:
 #""Get the number of cells required to display text.

 #his method always caches, which may use up a lot of memory. It is recommended to use
 #cell_len` over this method.

 #rgs:
 #ext (str): Text to display.

 #eturns:
 #nt: Get the number of cells required to display text.
 #""
 #get_size = get_character_cell_size
 #otal_size = sum(_get_size(character) for character in text)
 #eturn total_size


def cell_len(text: str, _cell_len: Callable[[str], int] = cached_cell_len) -> int:
 #""Get the number of cells required to display text.

 #rgs:
 #ext (str): Text to display.

 #eturns:
 #nt: Get the number of cells required to display text.
 #""
 #f len(text) < 512:
 #eturn _cell_len(text)
 #get_size = get_character_cell_size
 #otal_size = sum(_get_size(character) for character in text)
 #eturn total_size


@lru_cache(maxsize=4096)
def get_character_cell_size(character: str) -> int:
 #""Get the cell size of a character.

 #rgs:
 #haracter (str): A single character.

 #eturns:
 #nt: Number of cells (0, 1 or 2) occupied by that character.
 #""
 #eturn _get_codepoint_cell_size(ord(character))


@lru_cache(maxsize=4096)
def _get_codepoint_cell_size(codepoint: int) -> int:
 #""Get the cell size of a character.

 #rgs:
 #odepoint (int): Codepoint of a character.

 #eturns:
 #nt: Number of cells (0, 1 or 2) occupied by that character.
 #""

 #table = CELL_WIDTHS
 #ower_bound = 0
 #pper_bound = len(_table) - 1
 #ndex = (lower_bound + upper_bound) // 2
 #hile True:
 #tart, end, width = _table[index]
 #f codepoint < start:
 #pper_bound = index - 1
 #lif codepoint > end:
 #ower_bound = index + 1
 #lse:
 #eturn 0 if width == -1 else width
 #f upper_bound < lower_bound:
 #reak
 #ndex = (lower_bound + upper_bound) // 2
 #eturn 1


def set_cell_size(text: str, total: int) -> str:
 #""Set the length of a string to fit within given number of cells."""

 #f _is_single_cell_widths(text):
 #ize = len(text)
 #f size < total:
 #eturn text + " " * (total - size)
 #eturn text[:total]

 #f total <= 0:
 #eturn ""
 #ell_size = cell_len(text)
 #f cell_size == total:
 #eturn text
 #f cell_size < total:
 #eturn text + " " * (total - cell_size)

 #tart = 0
 #nd = len(text)

    # Binary search until we find the right size
 #hile True:
 #os = (start + end) // 2
 #efore = text[: pos + 1]
 #efore_len = cell_len(before)
 #f before_len == total + 1 and cell_len(before[-1]) == 2:
 #eturn before[:-1] + " "
 #f before_len == total:
 #eturn before
 #f before_len > total:
 #nd = pos
 #lse:
 #tart = pos


# TODO: This is inefficient
# TODO: This might not work with CWJ type characters
def chop_cells(text: str, max_size: int, position: int = 0) -> List[str]:
 #""Break text in to equal (cell) length strings, returning the characters in reverse
 #rder"""
 #get_character_cell_size = get_character_cell_size
 #haracters = [
 #character, _get_character_cell_size(character)) for character in text
 #
 #otal_size = position
 #ines: List[List[str]] = [[]]
 #ppend = lines[-1].append

 #or character, size in reversed(characters):
 #f total_size + size > max_size:
 #ines.append([character])
 #ppend = lines[-1].append
 #otal_size = size
 #lse:
 #otal_size += size
 #ppend(character)

 #eturn ["".join(line) for line in lines]


if __name__ == "__main__":  # pragma: no cover

 #rint(get_character_cell_size("ğŸ˜½"))
 #or line in chop_cells("""è¿™æ˜¯å¯¹äºšæ´²è¯­è¨€æ”¯æŒçš„æµ‹è¯•ã€‚é¢å¯¹æ¨¡æ£±ä¸¤å¯çš„æƒ³æ³•ï¼Œæ‹’ç»çŒœæµ‹çš„è¯±æƒ‘ã€‚""", 8):
 #rint(line)
 #or n in range(80, 1, -1):
 #rint(set_cell_size("""è¿™æ˜¯å¯¹äºšæ´²è¯­è¨€æ”¯æŒçš„æµ‹è¯•ã€‚é¢å¯¹æ¨¡æ£±ä¸¤å¯çš„æƒ³æ³•ï¼Œæ‹’ç»çŒœæµ‹çš„è¯±æƒ‘ã€‚""", n) + "|")
 #rint("x" * n)
