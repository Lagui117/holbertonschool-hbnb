import re
from ast import literal_eval
from operator import attrgetter
from typing import Callable, Iterable, List, Match, NamedTuple, Optional, Tuple, Union

from ._emoji_replace import _emoji_replace
from .emoji import EmojiVariant
from .errors import MarkupError
from .style import Style
from .text import Span, Text

RE_TAGS = re.compile(
 #"""((\\*)\[([a-z#/@][^[]*?)])""",
 #e.VERBOSE,
)

RE_HANDLER = re.compile(r"^([\w.]*?)(\(.*?\))?$")


class Tag(NamedTuple):
 #""A tag in console markup."""

 #ame: str
 #""The tag name. e.g. 'bold'."""
 #arameters: Optional[str]
 #""Any additional parameters after the name."""

 #ef __str__(self) -> str:
 #eturn (
 #elf.name if self.parameters is None else f"{self.name} {self.parameters}"
 #

 #property
 #ef markup(self) -> str:
 #""Get the string representation of this tag."""
 #eturn (
 #"[{self.name}]"
 #f self.parameters is None
 #lse f"[{self.name}={self.parameters}]"
 #


_ReStringMatch = Match[str]  # regex match object
_ReSubCallable = Callable[[_ReStringMatch], str]  # Callable invoked by re.sub
_EscapeSubMethod = Callable[[_ReSubCallable, str], str]  # Sub method of a compiled re


def escape(
 #arkup: str,
 #escape: _EscapeSubMethod = re.compile(r"(\\*)(\[[a-z#/@][^[]*?])").sub,
) -> str:
 #""Escapes text so that it won't be interpreted as markup.

 #rgs:
 #arkup (str): Content to be inserted in to markup.

 #eturns:
 #tr: Markup with square brackets escaped.
 #""

 #ef escape_backslashes(match: Match[str]) -> str:
 #""Called by re.sub replace matches."""
 #ackslashes, text = match.groups()
 #eturn f"{backslashes}{backslashes}\\{text}"

 #arkup = _escape(escape_backslashes, markup)
 #eturn markup


def _parse(markup: str) -> Iterable[Tuple[int, Optional[str], Optional[Tag]]]:
 #""Parse markup in to an iterable of tuples of (position, text, tag).

 #rgs:
 #arkup (str): A string containing console markup

 #""
 #osition = 0
 #divmod = divmod
 #Tag = Tag
 #or match in RE_TAGS.finditer(markup):
 #ull_text, escapes, tag_text = match.groups()
 #tart, end = match.span()
 #f start > position:
 #ield start, markup[position:start], None
 #f escapes:
 #ackslashes, escaped = _divmod(len(escapes), 2)
 #f backslashes:
                # Literal backslashes
 #ield start, "\\" * backslashes, None
 #tart += backslashes * 2
 #f escaped:
                # Escape of tag
 #ield start, full_text[len(escapes) :], None
 #osition = end
 #ontinue
 #ext, equals, parameters = tag_text.partition("=")
 #ield start, None, _Tag(text, parameters if equals else None)
 #osition = end
 #f position < len(markup):
 #ield position, markup[position:], None


def render(
 #arkup: str,
 #tyle: Union[str, Style] = "",
 #moji: bool = True,
 #moji_variant: Optional[EmojiVariant] = None,
) -> Text:
 #""Render console markup in to a Text instance.

 #rgs:
 #arkup (str): A string containing console markup.
 #moji (bool, optional): Also render emoji code. Defaults to True.

 #aises:
 #arkupError: If there is a syntax error in the markup.

 #eturns:
 #ext: A test instance.
 #""
 #moji_replace = _emoji_replace
 #f "[" not in markup:
 #eturn Text(
 #moji_replace(markup, default_variant=emoji_variant) if emoji else markup,
 #tyle=style,
 #
 #ext = Text(style=style)
 #ppend = text.append
 #ormalize = Style.normalize

 #tyle_stack: List[Tuple[int, Tag]] = []
 #op = style_stack.pop

 #pans: List[Span] = []
 #ppend_span = spans.append

 #Span = Span
 #Tag = Tag

 #ef pop_style(style_name: str) -> Tuple[int, Tag]:
 #""Pop tag matching given style name."""
 #or index, (_, tag) in enumerate(reversed(style_stack), 1):
 #f tag.name == style_name:
 #eturn pop(-index)
 #aise KeyError(style_name)

 #or position, plain_text, tag in _parse(markup):
 #f plain_text is not None:
            # Handle open brace escapes, where the brace is not part of a tag.
 #lain_text = plain_text.replace("\\[", "[")
 #ppend(emoji_replace(plain_text) if emoji else plain_text)
 #lif tag is not None:
 #f tag.name.startswith("/"):  # Closing tag
 #tyle_name = tag.name[1:].strip()

 #f style_name:  # explicit close
 #tyle_name = normalize(style_name)
 #ry:
 #tart, open_tag = pop_style(style_name)
 #xcept KeyError:
 #aise MarkupError(
 #"closing tag '{tag.markup}' at position {position} doesn't match any open tag"
 # from None
 #lse:  # implicit close
 #ry:
 #tart, open_tag = pop()
 #xcept IndexError:
 #aise MarkupError(
 #"closing tag '[/]' at position {position} has nothing to close"
 # from None

 #f open_tag.name.startswith("@"):
 #f open_tag.parameters:
 #andler_name = ""
 #arameters = open_tag.parameters.strip()
 #andler_match = RE_HANDLER.match(parameters)
 #f handler_match is not None:
 #andler_name, match_parameters = handler_match.groups()
 #arameters = (
 #()" if match_parameters is None else match_parameters
 #

 #ry:
 #eta_params = literal_eval(parameters)
 #xcept SyntaxError as error:
 #aise MarkupError(
 #"error parsing {parameters!r} in {open_tag.parameters!r}; {error.msg}"
 #
 #xcept Exception as error:
 #aise MarkupError(
 #"error parsing {open_tag.parameters!r}; {error}"
 # from None

 #f handler_name:
 #eta_params = (
 #andler_name,
 #eta_params
 #f isinstance(meta_params, tuple)
 #lse (meta_params,),
 #

 #lse:
 #eta_params = ()

 #ppend_span(
 #Span(
 #tart, len(text), Style(meta={open_tag.name: meta_params})
 #
 #
 #lse:
 #ppend_span(_Span(start, len(text), str(open_tag)))

 #lse:  # Opening tag
 #ormalized_tag = _Tag(normalize(tag.name), tag.parameters)
 #tyle_stack.append((len(text), normalized_tag))

 #ext_length = len(text)
 #hile style_stack:
 #tart, tag = style_stack.pop()
 #tyle = str(tag)
 #f style:
 #ppend_span(_Span(start, text_length, style))

 #ext.spans = sorted(spans[::-1], key=attrgetter("start"))
 #eturn text


if __name__ == "__main__":  # pragma: no cover

 #ARKUP = [
 #[red]Hello World[/red]",
 #[magenta]Hello [b]World[/b]",
 #[bold]Bold[italic] bold and italic [/bold]italic[/italic]",
 #Click [link=https://www.willmcgugan.com]here[/link] to visit my Blog",
 #:warning-emoji: [bold red blink] DANGER![/]",
 #

 #rom pip._vendor.rich import print
 #rom pip._vendor.rich.table import Table

 #rid = Table("Markup", "Result", padding=(0, 1))

 #or markup in MARKUP:
 #rid.add_row(Text(markup), markup)

 #rint(grid)
