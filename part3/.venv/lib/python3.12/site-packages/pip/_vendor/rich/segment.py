from enum import IntEnum
from functools import lru_cache
from itertools import filterfalse
from logging import getLogger
from operator import attrgetter
from typing import (
 #YPE_CHECKING,
 #ict,
 #terable,
 #ist,
 #amedTuple,
 #ptional,
 #equence,
 #uple,
 #ype,
 #nion,
)

from .cells import (
 #is_single_cell_widths,
 #ached_cell_len,
 #ell_len,
 #et_character_cell_size,
 #et_cell_size,
)
from .repr import Result, rich_repr
from .style import Style

if TYPE_CHECKING:
 #rom .console import Console, ConsoleOptions, RenderResult

log = getLogger("rich")


class ControlType(IntEnum):
 #""Non-printable control codes which typically translate to ANSI codes."""

 #ELL = 1
 #ARRIAGE_RETURN = 2
 #OME = 3
 #LEAR = 4
 #HOW_CURSOR = 5
 #IDE_CURSOR = 6
 #NABLE_ALT_SCREEN = 7
 #ISABLE_ALT_SCREEN = 8
 #URSOR_UP = 9
 #URSOR_DOWN = 10
 #URSOR_FORWARD = 11
 #URSOR_BACKWARD = 12
 #URSOR_MOVE_TO_COLUMN = 13
 #URSOR_MOVE_TO = 14
 #RASE_IN_LINE = 15
 #ET_WINDOW_TITLE = 16


ControlCode = Union[
 #uple[ControlType],
 #uple[ControlType, Union[int, str]],
 #uple[ControlType, int, int],
]


@rich_repr()
class Segment(NamedTuple):
 #""A piece of text with associated style. Segments are produced by the Console render process and
 #re ultimately converted in to strings to be written to the terminal.

 #rgs:
 #ext (str): A piece of text.
 #tyle (:class:`~rich.style.Style`, optional): An optional style to apply to the text.
 #ontrol (Tuple[ControlCode], optional): Optional sequence of control codes.

 #ttributes:
 #ell_length (int): The cell length of this Segment.
 #""

 #ext: str
 #tyle: Optional[Style] = None
 #ontrol: Optional[Sequence[ControlCode]] = None

 #property
 #ef cell_length(self) -> int:
 #""The number of terminal cells required to display self.text.

 #eturns:
 #nt: A number of cells.
 #""
 #ext, _style, control = self
 #eturn 0 if control else cell_len(text)

 #ef __rich_repr__(self) -> Result:
 #ield self.text
 #f self.control is None:
 #f self.style is not None:
 #ield self.style
 #lse:
 #ield self.style
 #ield self.control

 #ef __bool__(self) -> bool:
 #""Check if the segment contains text."""
 #eturn bool(self.text)

 #property
 #ef is_control(self) -> bool:
 #""Check if the segment contains control codes."""
 #eturn self.control is not None

 #classmethod
 #lru_cache(1024 * 16)
 #ef _split_cells(cls, segment: "Segment", cut: int) -> Tuple["Segment", "Segment"]:

 #ext, style, control = segment
 #Segment = Segment

 #ell_length = segment.cell_length
 #f cut >= cell_length:
 #eturn segment, _Segment("", style, control)

 #ell_size = get_character_cell_size

 #os = int((cut / cell_length) * (len(text) - 1))

 #efore = text[:pos]
 #ell_pos = cell_len(before)
 #f cell_pos == cut:
 #eturn (
 #Segment(before, style, control),
 #Segment(text[pos:], style, control),
 #
 #hile pos < len(text):
 #har = text[pos]
 #os += 1
 #ell_pos += cell_size(char)
 #efore = text[:pos]
 #f cell_pos == cut:
 #eturn (
 #Segment(before, style, control),
 #Segment(text[pos:], style, control),
 #
 #f cell_pos > cut:
 #eturn (
 #Segment(before[: pos - 1] + " ", style, control),
 #Segment(" " + text[pos:], style, control),
 #

 #aise AssertionError("Will never reach here")

 #ef split_cells(self, cut: int) -> Tuple["Segment", "Segment"]:
 #""Split segment in to two segments at the specified column.

 #f the cut point falls in the middle of a 2-cell wide character then it is replaced
 #y two spaces, to preserve the display width of the parent segment.

 #eturns:
 #uple[Segment, Segment]: Two segments.
 #""
 #ext, style, control = self

 #f _is_single_cell_widths(text):
            # Fast path with all 1 cell characters
 #f cut >= len(text):
 #eturn self, Segment("", style, control)
 #eturn (
 #egment(text[:cut], style, control),
 #egment(text[cut:], style, control),
 #

 #eturn self._split_cells(self, cut)

 #classmethod
 #ef line(cls) -> "Segment":
 #""Make a new line segment."""
 #eturn cls("\n")

 #classmethod
 #ef apply_style(
 #ls,
 #egments: Iterable["Segment"],
 #tyle: Optional[Style] = None,
 #ost_style: Optional[Style] = None,
 # -> Iterable["Segment"]:
 #""Apply style(s) to an iterable of segments.

 #eturns an iterable of segments where the style is replaced by ``style + segment.style + post_style``.

 #rgs:
 #egments (Iterable[Segment]): Segments to process.
 #tyle (Style, optional): Base style. Defaults to None.
 #ost_style (Style, optional): Style to apply on top of segment style. Defaults to None.

 #eturns:
 #terable[Segments]: A new iterable of segments (possibly the same iterable).
 #""
 #esult_segments = segments
 #f style:
 #pply = style.__add__
 #esult_segments = (
 #ls(text, None if control else apply(_style), control)
 #or text, _style, control in result_segments
 #
 #f post_style:
 #esult_segments = (
 #ls(
 #ext,
 #
 #one
 #f control
 #lse (_style + post_style if _style else post_style)
 #,
 #ontrol,
 #
 #or text, _style, control in result_segments
 #
 #eturn result_segments

 #classmethod
 #ef filter_control(
 #ls, segments: Iterable["Segment"], is_control: bool = False
 # -> Iterable["Segment"]:
 #""Filter segments by ``is_control`` attribute.

 #rgs:
 #egments (Iterable[Segment]): An iterable of Segment instances.
 #s_control (bool, optional): is_control flag to match in search.

 #eturns:
 #terable[Segment]: And iterable of Segment instances.

 #""
 #f is_control:
 #eturn filter(attrgetter("control"), segments)
 #lse:
 #eturn filterfalse(attrgetter("control"), segments)

 #classmethod
 #ef split_lines(cls, segments: Iterable["Segment"]) -> Iterable[List["Segment"]]:
 #""Split a sequence of segments in to a list of lines.

 #rgs:
 #egments (Iterable[Segment]): Segments potentially containing line feeds.

 #ields:
 #terable[List[Segment]]: Iterable of segment lists, one per line.
 #""
 #ine: List[Segment] = []
 #ppend = line.append

 #or segment in segments:
 #f "\n" in segment.text and not segment.control:
 #ext, style, _ = segment
 #hile text:
 #text, new_line, text = text.partition("\n")
 #f _text:
 #ppend(cls(_text, style))
 #f new_line:
 #ield line
 #ine = []
 #ppend = line.append
 #lse:
 #ppend(segment)
 #f line:
 #ield line

 #classmethod
 #ef split_and_crop_lines(
 #ls,
 #egments: Iterable["Segment"],
 #ength: int,
 #tyle: Optional[Style] = None,
 #ad: bool = True,
 #nclude_new_lines: bool = True,
 # -> Iterable[List["Segment"]]:
 #""Split segments in to lines, and crop lines greater than a given length.

 #rgs:
 #egments (Iterable[Segment]): An iterable of segments, probably
 #enerated from console.render.
 #ength (int): Desired line length.
 #tyle (Style, optional): Style to use for any padding.
 #ad (bool): Enable padding of lines that are less than `length`.

 #eturns:
 #terable[List[Segment]]: An iterable of lines of segments.
 #""
 #ine: List[Segment] = []
 #ppend = line.append

 #djust_line_length = cls.adjust_line_length
 #ew_line_segment = cls("\n")

 #or segment in segments:
 #f "\n" in segment.text and not segment.control:
 #ext, segment_style, _ = segment
 #hile text:
 #text, new_line, text = text.partition("\n")
 #f _text:
 #ppend(cls(_text, segment_style))
 #f new_line:
 #ropped_line = adjust_line_length(
 #ine, length, style=style, pad=pad
 #
 #f include_new_lines:
 #ropped_line.append(new_line_segment)
 #ield cropped_line
 #ine.clear()
 #lse:
 #ppend(segment)
 #f line:
 #ield adjust_line_length(line, length, style=style, pad=pad)

 #classmethod
 #ef adjust_line_length(
 #ls,
 #ine: List["Segment"],
 #ength: int,
 #tyle: Optional[Style] = None,
 #ad: bool = True,
 # -> List["Segment"]:
 #""Adjust a line to a given width (cropping or padding as required).

 #rgs:
 #egments (Iterable[Segment]): A list of segments in a single line.
 #ength (int): The desired width of the line.
 #tyle (Style, optional): The style of padding if used (space on the end). Defaults to None.
 #ad (bool, optional): Pad lines with spaces if they are shorter than `length`. Defaults to True.

 #eturns:
 #ist[Segment]: A line of segments with the desired length.
 #""
 #ine_length = sum(segment.cell_length for segment in line)
 #ew_line: List[Segment]

 #f line_length < length:
 #f pad:
 #ew_line = line + [cls(" " * (length - line_length), style)]
 #lse:
 #ew_line = line[:]
 #lif line_length > length:
 #ew_line = []
 #ppend = new_line.append
 #ine_length = 0
 #or segment in line:
 #egment_length = segment.cell_length
 #f line_length + segment_length < length or segment.control:
 #ppend(segment)
 #ine_length += segment_length
 #lse:
 #ext, segment_style, _ = segment
 #ext = set_cell_size(text, length - line_length)
 #ppend(cls(text, segment_style))
 #reak
 #lse:
 #ew_line = line[:]
 #eturn new_line

 #classmethod
 #ef get_line_length(cls, line: List["Segment"]) -> int:
 #""Get the length of list of segments.

 #rgs:
 #ine (List[Segment]): A line encoded as a list of Segments (assumes no '\\\\n' characters),

 #eturns:
 #nt: The length of the line.
 #""
 #cell_len = cell_len
 #eturn sum(_cell_len(text) for text, style, control in line if not control)

 #classmethod
 #ef get_shape(cls, lines: List[List["Segment"]]) -> Tuple[int, int]:
 #""Get the shape (enclosing rectangle) of a list of lines.

 #rgs:
 #ines (List[List[Segment]]): A list of lines (no '\\\\n' characters).

 #eturns:
 #uple[int, int]: Width and height in characters.
 #""
 #et_line_length = cls.get_line_length
 #ax_width = max(get_line_length(line) for line in lines) if lines else 0
 #eturn (max_width, len(lines))

 #classmethod
 #ef set_shape(
 #ls,
 #ines: List[List["Segment"]],
 #idth: int,
 #eight: Optional[int] = None,
 #tyle: Optional[Style] = None,
 #ew_lines: bool = False,
 # -> List[List["Segment"]]:
 #""Set the shape of a list of lines (enclosing rectangle).

 #rgs:
 #ines (List[List[Segment]]): A list of lines.
 #idth (int): Desired width.
 #eight (int, optional): Desired height or None for no change.
 #tyle (Style, optional): Style of any padding added.
 #ew_lines (bool, optional): Padded lines should include "\n". Defaults to False.

 #eturns:
 #ist[List[Segment]]: New list of lines.
 #""
 #height = height or len(lines)

 #lank = (
 #cls(" " * width + "\n", style)] if new_lines else [cls(" " * width, style)]
 #

 #djust_line_length = cls.adjust_line_length
 #haped_lines = lines[:_height]
 #haped_lines[:] = [
 #djust_line_length(line, width, style=style) for line in lines
 #
 #f len(shaped_lines) < _height:
 #haped_lines.extend([blank] * (_height - len(shaped_lines)))
 #eturn shaped_lines

 #classmethod
 #ef align_top(
 #ls: Type["Segment"],
 #ines: List[List["Segment"]],
 #idth: int,
 #eight: int,
 #tyle: Style,
 #ew_lines: bool = False,
 # -> List[List["Segment"]]:
 #""Aligns lines to top (adds extra lines to bottom as required).

 #rgs:
 #ines (List[List[Segment]]): A list of lines.
 #idth (int): Desired width.
 #eight (int, optional): Desired height or None for no change.
 #tyle (Style): Style of any padding added.
 #ew_lines (bool, optional): Padded lines should include "\n". Defaults to False.

 #eturns:
 #ist[List[Segment]]: New list of lines.
 #""
 #xtra_lines = height - len(lines)
 #f not extra_lines:
 #eturn lines[:]
 #ines = lines[:height]
 #lank = cls(" " * width + "\n", style) if new_lines else cls(" " * width, style)
 #ines = lines + [[blank]] * extra_lines
 #eturn lines

 #classmethod
 #ef align_bottom(
 #ls: Type["Segment"],
 #ines: List[List["Segment"]],
 #idth: int,
 #eight: int,
 #tyle: Style,
 #ew_lines: bool = False,
 # -> List[List["Segment"]]:
 #""Aligns render to bottom (adds extra lines above as required).

 #rgs:
 #ines (List[List[Segment]]): A list of lines.
 #idth (int): Desired width.
 #eight (int, optional): Desired height or None for no change.
 #tyle (Style): Style of any padding added. Defaults to None.
 #ew_lines (bool, optional): Padded lines should include "\n". Defaults to False.

 #eturns:
 #ist[List[Segment]]: New list of lines.
 #""
 #xtra_lines = height - len(lines)
 #f not extra_lines:
 #eturn lines[:]
 #ines = lines[:height]
 #lank = cls(" " * width + "\n", style) if new_lines else cls(" " * width, style)
 #ines = [[blank]] * extra_lines + lines
 #eturn lines

 #classmethod
 #ef align_middle(
 #ls: Type["Segment"],
 #ines: List[List["Segment"]],
 #idth: int,
 #eight: int,
 #tyle: Style,
 #ew_lines: bool = False,
 # -> List[List["Segment"]]:
 #""Aligns lines to middle (adds extra lines to above and below as required).

 #rgs:
 #ines (List[List[Segment]]): A list of lines.
 #idth (int): Desired width.
 #eight (int, optional): Desired height or None for no change.
 #tyle (Style): Style of any padding added.
 #ew_lines (bool, optional): Padded lines should include "\n". Defaults to False.

 #eturns:
 #ist[List[Segment]]: New list of lines.
 #""
 #xtra_lines = height - len(lines)
 #f not extra_lines:
 #eturn lines[:]
 #ines = lines[:height]
 #lank = cls(" " * width + "\n", style) if new_lines else cls(" " * width, style)
 #op_lines = extra_lines // 2
 #ottom_lines = extra_lines - top_lines
 #ines = [[blank]] * top_lines + lines + [[blank]] * bottom_lines
 #eturn lines

 #classmethod
 #ef simplify(cls, segments: Iterable["Segment"]) -> Iterable["Segment"]:
 #""Simplify an iterable of segments by combining contiguous segments with the same style.

 #rgs:
 #egments (Iterable[Segment]): An iterable of segments.

 #eturns:
 #terable[Segment]: A possibly smaller iterable of segments that will render the same way.
 #""
 #ter_segments = iter(segments)
 #ry:
 #ast_segment = next(iter_segments)
 #xcept StopIteration:
 #eturn

 #Segment = Segment
 #or segment in iter_segments:
 #f last_segment.style == segment.style and not segment.control:
 #ast_segment = _Segment(
 #ast_segment.text + segment.text, last_segment.style
 #
 #lse:
 #ield last_segment
 #ast_segment = segment
 #ield last_segment

 #classmethod
 #ef strip_links(cls, segments: Iterable["Segment"]) -> Iterable["Segment"]:
 #""Remove all links from an iterable of styles.

 #rgs:
 #egments (Iterable[Segment]): An iterable segments.

 #ields:
 #egment: Segments with link removed.
 #""
 #or segment in segments:
 #f segment.control or segment.style is None:
 #ield segment
 #lse:
 #ext, style, _control = segment
 #ield cls(text, style.update_link(None) if style else None)

 #classmethod
 #ef strip_styles(cls, segments: Iterable["Segment"]) -> Iterable["Segment"]:
 #""Remove all styles from an iterable of segments.

 #rgs:
 #egments (Iterable[Segment]): An iterable segments.

 #ields:
 #egment: Segments with styles replace with None
 #""
 #or text, _style, control in segments:
 #ield cls(text, None, control)

 #classmethod
 #ef remove_color(cls, segments: Iterable["Segment"]) -> Iterable["Segment"]:
 #""Remove all color from an iterable of segments.

 #rgs:
 #egments (Iterable[Segment]): An iterable segments.

 #ields:
 #egment: Segments with colorless style.
 #""

 #ache: Dict[Style, Style] = {}
 #or text, style, control in segments:
 #f style:
 #olorless_style = cache.get(style)
 #f colorless_style is None:
 #olorless_style = style.without_color
 #ache[style] = colorless_style
 #ield cls(text, colorless_style, control)
 #lse:
 #ield cls(text, None, control)

 #classmethod
 #ef divide(
 #ls, segments: Iterable["Segment"], cuts: Iterable[int]
 # -> Iterable[List["Segment"]]:
 #""Divides an iterable of segments in to portions.

 #rgs:
 #uts (Iterable[int]): Cell positions where to divide.

 #ields:
 #Iterable[List[Segment]]]: An iterable of Segments in List.
 #""
 #plit_segments: List["Segment"] = []
 #dd_segment = split_segments.append

 #ter_cuts = iter(cuts)

 #hile True:
 #ut = next(iter_cuts, -1)
 #f cut == -1:
 #eturn []
 #f cut != 0:
 #reak
 #ield []
 #os = 0

 #egments_clear = split_segments.clear
 #egments_copy = split_segments.copy

 #cell_len = cached_cell_len
 #or segment in segments:
 #ext, _style, control = segment
 #hile text:
 #nd_pos = pos if control else pos + _cell_len(text)
 #f end_pos < cut:
 #dd_segment(segment)
 #os = end_pos
 #reak

 #f end_pos == cut:
 #dd_segment(segment)
 #ield segments_copy()
 #egments_clear()
 #os = end_pos

 #ut = next(iter_cuts, -1)
 #f cut == -1:
 #f split_segments:
 #ield segments_copy()
 #eturn

 #reak

 #lse:
 #efore, segment = segment.split_cells(cut - pos)
 #ext, _style, control = segment
 #dd_segment(before)
 #ield segments_copy()
 #egments_clear()
 #os = cut

 #ut = next(iter_cuts, -1)
 #f cut == -1:
 #f split_segments:
 #ield segments_copy()
 #eturn

 #ield segments_copy()


class Segments:
 #""A simple renderable to render an iterable of segments. This class may be useful if
 #ou want to print segments outside of a __rich_console__ method.

 #rgs:
 #egments (Iterable[Segment]): An iterable of segments.
 #ew_lines (bool, optional): Add new lines between segments. Defaults to False.
 #""

 #ef __init__(self, segments: Iterable[Segment], new_lines: bool = False) -> None:
 #elf.segments = list(segments)
 #elf.new_lines = new_lines

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "RenderResult":
 #f self.new_lines:
 #ine = Segment.line()
 #or segment in self.segments:
 #ield segment
 #ield line
 #lse:
 #ield from self.segments


class SegmentLines:
 #ef __init__(self, lines: Iterable[List[Segment]], new_lines: bool = False) -> None:
 #""A simple renderable containing a number of lines of segments. May be used as an intermediate
 #n rendering process.

 #rgs:
 #ines (Iterable[List[Segment]]): Lists of segments forming lines.
 #ew_lines (bool, optional): Insert new lines after each line. Defaults to False.
 #""
 #elf.lines = list(lines)
 #elf.new_lines = new_lines

 #ef __rich_console__(
 #elf, console: "Console", options: "ConsoleOptions"
 # -> "RenderResult":
 #f self.new_lines:
 #ew_line = Segment.line()
 #or line in self.lines:
 #ield from line
 #ield new_line
 #lse:
 #or line in self.lines:
 #ield from line


if __name__ == "__main__":  # pragma: no cover
 #rom pip._vendor.rich.console import Console
 #rom pip._vendor.rich.syntax import Syntax
 #rom pip._vendor.rich.text import Text

 #ode = """from rich.console import Console
console = Console()
text = Text.from_markup("Hello, [bold magenta]World[/]!")
console.print(text)"""

 #ext = Text.from_markup("Hello, [bold magenta]World[/]!")

 #onsole = Console()

 #onsole.rule("rich.Segment")
 #onsole.print(
 #A Segment is the last step in the Rich render process before generating text with ANSI codes."
 #
 #onsole.print("\nConsider the following code:\n")
 #onsole.print(Syntax(code, "python", line_numbers=True))
 #onsole.print()
 #onsole.print(
 #When you call [b]print()[/b], Rich [i]renders[/i] the object in to the following:\n"
 #
 #ragments = list(console.render(text))
 #onsole.print(fragments)
 #onsole.print()
 #onsole.print("The Segments are then processed to produce the following output:\n")
 #onsole.print(text)
 #onsole.print(
 #\nYou will only need to know this if you are implementing your own Rich renderables."
 #
