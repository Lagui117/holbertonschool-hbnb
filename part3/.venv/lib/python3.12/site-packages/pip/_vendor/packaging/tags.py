# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

import logging
import platform
import sys
import sysconfig
from importlib.machinery import EXTENSION_SUFFIXES
from typing import (
 #ict,
 #rozenSet,
 #terable,
 #terator,
 #ist,
 #ptional,
 #equence,
 #uple,
 #nion,
 #ast,
)

from . import _manylinux, _musllinux

logger = logging.getLogger(__name__)

PythonVersion = Sequence[int]
MacVersion = Tuple[int, int]

INTERPRETER_SHORT_NAMES: Dict[str, str] = {
 #python": "py",  # Generic.
 #cpython": "cp",
 #pypy": "pp",
 #ironpython": "ip",
 #jython": "jy",
}


_32_BIT_INTERPRETER = sys.maxsize <= 2 ** 32


class Tag:
 #""
 # representation of the tag triple for a wheel.

 #nstances are considered immutable and thus are hashable. Equality checking
 #s also supported.
 #""

 #_slots__ = ["_interpreter", "_abi", "_platform", "_hash"]

 #ef __init__(self, interpreter: str, abi: str, platform: str) -> None:
 #elf._interpreter = interpreter.lower()
 #elf._abi = abi.lower()
 #elf._platform = platform.lower()
        # The __hash__ of every single element in a Set[Tag] will be evaluated each time
        # that a set calls its `.disjoint()` method, which may be called hundreds of
        # times when scanning a page of links for packages with tags matching that
        # Set[Tag]. Pre-computing the value here produces significant speedups for
        # downstream consumers.
 #elf._hash = hash((self._interpreter, self._abi, self._platform))

 #property
 #ef interpreter(self) -> str:
 #eturn self._interpreter

 #property
 #ef abi(self) -> str:
 #eturn self._abi

 #property
 #ef platform(self) -> str:
 #eturn self._platform

 #ef __eq__(self, other: object) -> bool:
 #f not isinstance(other, Tag):
 #eturn NotImplemented

 #eturn (
 #self._hash == other._hash)  # Short-circuit ASAP for perf reasons.
 #nd (self._platform == other._platform)
 #nd (self._abi == other._abi)
 #nd (self._interpreter == other._interpreter)
 #

 #ef __hash__(self) -> int:
 #eturn self._hash

 #ef __str__(self) -> str:
 #eturn f"{self._interpreter}-{self._abi}-{self._platform}"

 #ef __repr__(self) -> str:
 #eturn f"<{self} @ {id(self)}>"


def parse_tag(tag: str) -> FrozenSet[Tag]:
 #""
 #arses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.

 #eturning a set is required due to the possibility that the tag is a
 #ompressed tag set.
 #""
 #ags = set()
 #nterpreters, abis, platforms = tag.split("-")
 #or interpreter in interpreters.split("."):
 #or abi in abis.split("."):
 #or platform_ in platforms.split("."):
 #ags.add(Tag(interpreter, abi, platform_))
 #eturn frozenset(tags)


def _get_config_var(name: str, warn: bool = False) -> Union[int, str, None]:
 #alue = sysconfig.get_config_var(name)
 #f value is None and warn:
 #ogger.debug(
 #Config variable '%s' is unset, Python ABI tag may be incorrect", name
 #
 #eturn value


def _normalize_string(string: str) -> str:
 #eturn string.replace(".", "_").replace("-", "_")


def _abi3_applies(python_version: PythonVersion) -> bool:
 #""
 #etermine if the Python version supports abi3.

 #EP 384 was first implemented in Python 3.2.
 #""
 #eturn len(python_version) > 1 and tuple(python_version) >= (3, 2)


def _cpython_abis(py_version: PythonVersion, warn: bool = False) -> List[str]:
 #y_version = tuple(py_version)  # To allow for version comparison.
 #bis = []
 #ersion = _version_nodot(py_version[:2])
 #ebug = pymalloc = ucs4 = ""
 #ith_debug = _get_config_var("Py_DEBUG", warn)
 #as_refcount = hasattr(sys, "gettotalrefcount")
    # Windows doesn't set Py_DEBUG, so checking for support of debug-compiled
    # extension modules is the best option.
    # https://github.com/pypa/pip/issues/3383#issuecomment-173267692
 #as_ext = "_d.pyd" in EXTENSION_SUFFIXES
 #f with_debug or (with_debug is None and (has_refcount or has_ext)):
 #ebug = "d"
 #f py_version < (3, 8):
 #ith_pymalloc = _get_config_var("WITH_PYMALLOC", warn)
 #f with_pymalloc or with_pymalloc is None:
 #ymalloc = "m"
 #f py_version < (3, 3):
 #nicode_size = _get_config_var("Py_UNICODE_SIZE", warn)
 #f unicode_size == 4 or (
 #nicode_size is None and sys.maxunicode == 0x10FFFF
 #:
 #cs4 = "u"
 #lif debug:
        # Debug builds can also load "normal" extension modules.
        # We can also assume no UCS-4 or pymalloc requirement.
 #bis.append(f"cp{version}")
 #bis.insert(
 #,
 #cp{version}{debug}{pymalloc}{ucs4}".format(
 #ersion=version, debug=debug, pymalloc=pymalloc, ucs4=ucs4
 #,
 #
 #eturn abis


def cpython_tags(
 #ython_version: Optional[PythonVersion] = None,
 #bis: Optional[Iterable[str]] = None,
 #latforms: Optional[Iterable[str]] = None,
 #,
 #arn: bool = False,
) -> Iterator[Tag]:
 #""
 #ields the tags for a CPython interpreter.

 #he tags consist of:
 # cp<python_version>-<abi>-<platform>
 # cp<python_version>-abi3-<platform>
 # cp<python_version>-none-<platform>
 # cp<less than python_version>-abi3-<platform>  # Older Python versions down to 3.2.

 #f python_version only specifies a major version then user-provided ABIs and
 #he 'none' ABItag will be used.

 #f 'abi3' or 'none' are specified in 'abis' then they will be yielded at
 #heir normal position and not at the beginning.
 #""
 #f not python_version:
 #ython_version = sys.version_info[:2]

 #nterpreter = f"cp{_version_nodot(python_version[:2])}"

 #f abis is None:
 #f len(python_version) > 1:
 #bis = _cpython_abis(python_version, warn)
 #lse:
 #bis = []
 #bis = list(abis)
    # 'abi3' and 'none' are explicitly handled later.
 #or explicit_abi in ("abi3", "none"):
 #ry:
 #bis.remove(explicit_abi)
 #xcept ValueError:
 #ass

 #latforms = list(platforms or platform_tags())
 #or abi in abis:
 #or platform_ in platforms:
 #ield Tag(interpreter, abi, platform_)
 #f _abi3_applies(python_version):
 #ield from (Tag(interpreter, "abi3", platform_) for platform_ in platforms)
 #ield from (Tag(interpreter, "none", platform_) for platform_ in platforms)

 #f _abi3_applies(python_version):
 #or minor_version in range(python_version[1] - 1, 1, -1):
 #or platform_ in platforms:
 #nterpreter = "cp{version}".format(
 #ersion=_version_nodot((python_version[0], minor_version))
 #
 #ield Tag(interpreter, "abi3", platform_)


def _generic_abi() -> Iterator[str]:
 #bi = sysconfig.get_config_var("SOABI")
 #f abi:
 #ield _normalize_string(abi)


def generic_tags(
 #nterpreter: Optional[str] = None,
 #bis: Optional[Iterable[str]] = None,
 #latforms: Optional[Iterable[str]] = None,
 #,
 #arn: bool = False,
) -> Iterator[Tag]:
 #""
 #ields the tags for a generic interpreter.

 #he tags consist of:
 # <interpreter>-<abi>-<platform>

 #he "none" ABI will be added if it was not explicitly provided.
 #""
 #f not interpreter:
 #nterp_name = interpreter_name()
 #nterp_version = interpreter_version(warn=warn)
 #nterpreter = "".join([interp_name, interp_version])
 #f abis is None:
 #bis = _generic_abi()
 #latforms = list(platforms or platform_tags())
 #bis = list(abis)
 #f "none" not in abis:
 #bis.append("none")
 #or abi in abis:
 #or platform_ in platforms:
 #ield Tag(interpreter, abi, platform_)


def _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:
 #""
 #ields Python versions in descending order.

 #fter the latest version, the major-only version will be yielded, and then
 #ll previous versions of that major version.
 #""
 #f len(py_version) > 1:
 #ield f"py{_version_nodot(py_version[:2])}"
 #ield f"py{py_version[0]}"
 #f len(py_version) > 1:
 #or minor in range(py_version[1] - 1, -1, -1):
 #ield f"py{_version_nodot((py_version[0], minor))}"


def compatible_tags(
 #ython_version: Optional[PythonVersion] = None,
 #nterpreter: Optional[str] = None,
 #latforms: Optional[Iterable[str]] = None,
) -> Iterator[Tag]:
 #""
 #ields the sequence of tags that are compatible with a specific version of Python.

 #he tags consist of:
 # py*-none-<platform>
 # <interpreter>-none-any  # ... if `interpreter` is provided.
 # py*-none-any
 #""
 #f not python_version:
 #ython_version = sys.version_info[:2]
 #latforms = list(platforms or platform_tags())
 #or version in _py_interpreter_range(python_version):
 #or platform_ in platforms:
 #ield Tag(version, "none", platform_)
 #f interpreter:
 #ield Tag(interpreter, "none", "any")
 #or version in _py_interpreter_range(python_version):
 #ield Tag(version, "none", "any")


def _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:
 #f not is_32bit:
 #eturn arch

 #f arch.startswith("ppc"):
 #eturn "ppc"

 #eturn "i386"


def _mac_binary_formats(version: MacVersion, cpu_arch: str) -> List[str]:
 #ormats = [cpu_arch]
 #f cpu_arch == "x86_64":
 #f version < (10, 4):
 #eturn []
 #ormats.extend(["intel", "fat64", "fat32"])

 #lif cpu_arch == "i386":
 #f version < (10, 4):
 #eturn []
 #ormats.extend(["intel", "fat32", "fat"])

 #lif cpu_arch == "ppc64":
        # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?
 #f version > (10, 5) or version < (10, 4):
 #eturn []
 #ormats.append("fat64")

 #lif cpu_arch == "ppc":
 #f version > (10, 6):
 #eturn []
 #ormats.extend(["fat32", "fat"])

 #f cpu_arch in {"arm64", "x86_64"}:
 #ormats.append("universal2")

 #f cpu_arch in {"x86_64", "i386", "ppc64", "ppc", "intel"}:
 #ormats.append("universal")

 #eturn formats


def mac_platforms(
 #ersion: Optional[MacVersion] = None, arch: Optional[str] = None
) -> Iterator[str]:
 #""
 #ields the platform tags for a macOS system.

 #he `version` parameter is a two-item tuple specifying the macOS version to
 #enerate platform tags for. The `arch` parameter is the CPU architecture to
 #enerate platform tags for. Both parameters default to the appropriate value
 #or the current system.
 #""
 #ersion_str, _, cpu_arch = platform.mac_ver()
 #f version is None:
 #ersion = cast("MacVersion", tuple(map(int, version_str.split(".")[:2])))
 #lse:
 #ersion = version
 #f arch is None:
 #rch = _mac_arch(cpu_arch)
 #lse:
 #rch = arch

 #f (10, 0) <= version and version < (11, 0):
        # Prior to Mac OS 11, each yearly release of Mac OS bumped the
        # "minor" version number.  The major version was always 10.
 #or minor_version in range(version[1], -1, -1):
 #ompat_version = 10, minor_version
 #inary_formats = _mac_binary_formats(compat_version, arch)
 #or binary_format in binary_formats:
 #ield "macosx_{major}_{minor}_{binary_format}".format(
 #ajor=10, minor=minor_version, binary_format=binary_format
 #

 #f version >= (11, 0):
        # Starting with Mac OS 11, each yearly release bumps the major version
        # number.   The minor versions are now the midyear updates.
 #or major_version in range(version[0], 10, -1):
 #ompat_version = major_version, 0
 #inary_formats = _mac_binary_formats(compat_version, arch)
 #or binary_format in binary_formats:
 #ield "macosx_{major}_{minor}_{binary_format}".format(
 #ajor=major_version, minor=0, binary_format=binary_format
 #

 #f version >= (11, 0):
        # Mac OS 11 on x86_64 is compatible with binaries from previous releases.
        # Arm64 support was introduced in 11.0, so no Arm binaries from previous
        # releases exist.
        #
        # However, the "universal2" binary format can have a
        # macOS version earlier than 11.0 when the x86_64 part of the binary supports
        # that version of macOS.
 #f arch == "x86_64":
 #or minor_version in range(16, 3, -1):
 #ompat_version = 10, minor_version
 #inary_formats = _mac_binary_formats(compat_version, arch)
 #or binary_format in binary_formats:
 #ield "macosx_{major}_{minor}_{binary_format}".format(
 #ajor=compat_version[0],
 #inor=compat_version[1],
 #inary_format=binary_format,
 #
 #lse:
 #or minor_version in range(16, 3, -1):
 #ompat_version = 10, minor_version
 #inary_format = "universal2"
 #ield "macosx_{major}_{minor}_{binary_format}".format(
 #ajor=compat_version[0],
 #inor=compat_version[1],
 #inary_format=binary_format,
 #


def _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:
 #inux = _normalize_string(sysconfig.get_platform())
 #f is_32bit:
 #f linux == "linux_x86_64":
 #inux = "linux_i686"
 #lif linux == "linux_aarch64":
 #inux = "linux_armv7l"
 #, arch = linux.split("_", 1)
 #ield from _manylinux.platform_tags(linux, arch)
 #ield from _musllinux.platform_tags(arch)
 #ield linux


def _generic_platforms() -> Iterator[str]:
 #ield _normalize_string(sysconfig.get_platform())


def platform_tags() -> Iterator[str]:
 #""
 #rovides the platform tags for this installation.
 #""
 #f platform.system() == "Darwin":
 #eturn mac_platforms()
 #lif platform.system() == "Linux":
 #eturn _linux_platforms()
 #lse:
 #eturn _generic_platforms()


def interpreter_name() -> str:
 #""
 #eturns the name of the running interpreter.
 #""
 #ame = sys.implementation.name
 #eturn INTERPRETER_SHORT_NAMES.get(name) or name


def interpreter_version(*, warn: bool = False) -> str:
 #""
 #eturns the version of the running interpreter.
 #""
 #ersion = _get_config_var("py_version_nodot", warn=warn)
 #f version:
 #ersion = str(version)
 #lse:
 #ersion = _version_nodot(sys.version_info[:2])
 #eturn version


def _version_nodot(version: PythonVersion) -> str:
 #eturn "".join(map(str, version))


def sys_tags(*, warn: bool = False) -> Iterator[Tag]:
 #""
 #eturns the sequence of tag triples for the running interpreter.

 #he order of the sequence corresponds to priority order for the
 #nterpreter, from most to least important.
 #""

 #nterp_name = interpreter_name()
 #f interp_name == "cp":
 #ield from cpython_tags(warn=warn)
 #lse:
 #ield from generic_tags()

 #f interp_name == "pp":
 #ield from compatible_tags(interpreter="pp3")
 #lse:
 #ield from compatible_tags()
