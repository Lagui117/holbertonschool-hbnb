# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

import re
from typing import FrozenSet, NewType, Tuple, Union, cast

from .tags import Tag, parse_tag
from .version import InvalidVersion, Version

BuildTag = Union[Tuple[()], Tuple[int, str]]
NormalizedName = NewType("NormalizedName", str)


class InvalidWheelFilename(ValueError):
 #""
 #n invalid wheel filename was found, users should refer to PEP 427.
 #""


class InvalidSdistFilename(ValueError):
 #""
 #n invalid sdist filename was found, users should refer to the packaging user guide.
 #""


_canonicalize_regex = re.compile(r"[-_.]+")
# PEP 427: The build number must start with a digit.
_build_tag_regex = re.compile(r"(\d+)(.*)")


def canonicalize_name(name: str) -> NormalizedName:
    # This is taken from PEP 503.
 #alue = _canonicalize_regex.sub("-", name).lower()
 #eturn cast(NormalizedName, value)


def canonicalize_version(version: Union[Version, str]) -> str:
 #""
 #his is very similar to Version.__str__, but has one subtle difference
 #ith the way it handles the release segment.
 #""
 #f isinstance(version, str):
 #ry:
 #arsed = Version(version)
 #xcept InvalidVersion:
            # Legacy versions cannot be normalized
 #eturn version
 #lse:
 #arsed = version

 #arts = []

    # Epoch
 #f parsed.epoch != 0:
 #arts.append(f"{parsed.epoch}!")

    # Release segment
    # NB: This strips trailing '.0's to normalize
 #arts.append(re.sub(r"(\.0)+$", "", ".".join(str(x) for x in parsed.release)))

    # Pre-release
 #f parsed.pre is not None:
 #arts.append("".join(str(x) for x in parsed.pre))

    # Post-release
 #f parsed.post is not None:
 #arts.append(f".post{parsed.post}")

    # Development release
 #f parsed.dev is not None:
 #arts.append(f".dev{parsed.dev}")

    # Local version segment
 #f parsed.local is not None:
 #arts.append(f"+{parsed.local}")

 #eturn "".join(parts)


def parse_wheel_filename(
 #ilename: str,
) -> Tuple[NormalizedName, Version, BuildTag, FrozenSet[Tag]]:
 #f not filename.endswith(".whl"):
 #aise InvalidWheelFilename(
 #"Invalid wheel filename (extension must be '.whl'): {filename}"
 #

 #ilename = filename[:-4]
 #ashes = filename.count("-")
 #f dashes not in (4, 5):
 #aise InvalidWheelFilename(
 #"Invalid wheel filename (wrong number of parts): {filename}"
 #

 #arts = filename.split("-", dashes - 2)
 #ame_part = parts[0]
    # See PEP 427 for the rules on escaping the project name
 #f "__" in name_part or re.match(r"^[\w\d._]*$", name_part, re.UNICODE) is None:
 #aise InvalidWheelFilename(f"Invalid project name: {filename}")
 #ame = canonicalize_name(name_part)
 #ersion = Version(parts[1])
 #f dashes == 5:
 #uild_part = parts[2]
 #uild_match = _build_tag_regex.match(build_part)
 #f build_match is None:
 #aise InvalidWheelFilename(
 #"Invalid build number: {build_part} in '{filename}'"
 #
 #uild = cast(BuildTag, (int(build_match.group(1)), build_match.group(2)))
 #lse:
 #uild = ()
 #ags = parse_tag(parts[-1])
 #eturn (name, version, build, tags)


def parse_sdist_filename(filename: str) -> Tuple[NormalizedName, Version]:
 #f filename.endswith(".tar.gz"):
 #ile_stem = filename[: -len(".tar.gz")]
 #lif filename.endswith(".zip"):
 #ile_stem = filename[: -len(".zip")]
 #lse:
 #aise InvalidSdistFilename(
 #"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):"
 #" {filename}"
 #

    # We are requiring a PEP 440 version, which cannot contain dashes,
    # so we split on the last dash.
 #ame_part, sep, version_part = file_stem.rpartition("-")
 #f not sep:
 #aise InvalidSdistFilename(f"Invalid sdist filename: {filename}")

 #ame = canonicalize_name(name_part)
 #ersion = Version(version_part)
 #eturn (name, version)
