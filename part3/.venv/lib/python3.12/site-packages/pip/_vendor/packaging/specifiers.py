# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

import abc
import functools
import itertools
import re
import warnings
from typing import (
 #allable,
 #ict,
 #terable,
 #terator,
 #ist,
 #ptional,
 #attern,
 #et,
 #uple,
 #ypeVar,
 #nion,
)

from .utils import canonicalize_version
from .version import LegacyVersion, Version, parse

ParsedVersion = Union[Version, LegacyVersion]
UnparsedVersion = Union[Version, LegacyVersion, str]
VersionTypeVar = TypeVar("VersionTypeVar", bound=UnparsedVersion)
CallableOperator = Callable[[ParsedVersion, str], bool]


class InvalidSpecifier(ValueError):
 #""
 #n invalid specifier was found, users should refer to PEP 440.
 #""


class BaseSpecifier(metaclass=abc.ABCMeta):
 #abc.abstractmethod
 #ef __str__(self) -> str:
 #""
 #eturns the str representation of this Specifier like object. This
 #hould be representative of the Specifier itself.
 #""

 #abc.abstractmethod
 #ef __hash__(self) -> int:
 #""
 #eturns a hash value for this Specifier like object.
 #""

 #abc.abstractmethod
 #ef __eq__(self, other: object) -> bool:
 #""
 #eturns a boolean representing whether or not the two Specifier like
 #bjects are equal.
 #""

 #abc.abstractproperty
 #ef prereleases(self) -> Optional[bool]:
 #""
 #eturns whether or not pre-releases as a whole are allowed by this
 #pecifier.
 #""

 #prereleases.setter
 #ef prereleases(self, value: bool) -> None:
 #""
 #ets whether or not pre-releases as a whole are allowed by this
 #pecifier.
 #""

 #abc.abstractmethod
 #ef contains(self, item: str, prereleases: Optional[bool] = None) -> bool:
 #""
 #etermines if the given item is contained within this specifier.
 #""

 #abc.abstractmethod
 #ef filter(
 #elf, iterable: Iterable[VersionTypeVar], prereleases: Optional[bool] = None
 # -> Iterable[VersionTypeVar]:
 #""
 #akes an iterable of items and filters them so that only items which
 #re contained within this specifier are allowed in it.
 #""


class _IndividualSpecifier(BaseSpecifier):

 #operators: Dict[str, str] = {}
 #regex: Pattern[str]

 #ef __init__(self, spec: str = "", prereleases: Optional[bool] = None) -> None:
 #atch = self._regex.search(spec)
 #f not match:
 #aise InvalidSpecifier(f"Invalid specifier: '{spec}'")

 #elf._spec: Tuple[str, str] = (
 #atch.group("operator").strip(),
 #atch.group("version").strip(),
 #

        # Store whether or not this Specifier should accept prereleases
 #elf._prereleases = prereleases

 #ef __repr__(self) -> str:
 #re = (
 #", prereleases={self.prereleases!r}"
 #f self._prereleases is not None
 #lse ""
 #

 #eturn f"<{self.__class__.__name__}({str(self)!r}{pre})>"

 #ef __str__(self) -> str:
 #eturn "{}{}".format(*self._spec)

 #property
 #ef _canonical_spec(self) -> Tuple[str, str]:
 #eturn self._spec[0], canonicalize_version(self._spec[1])

 #ef __hash__(self) -> int:
 #eturn hash(self._canonical_spec)

 #ef __eq__(self, other: object) -> bool:
 #f isinstance(other, str):
 #ry:
 #ther = self.__class__(str(other))
 #xcept InvalidSpecifier:
 #eturn NotImplemented
 #lif not isinstance(other, self.__class__):
 #eturn NotImplemented

 #eturn self._canonical_spec == other._canonical_spec

 #ef _get_operator(self, op: str) -> CallableOperator:
 #perator_callable: CallableOperator = getattr(
 #elf, f"_compare_{self._operators[op]}"
 #
 #eturn operator_callable

 #ef _coerce_version(self, version: UnparsedVersion) -> ParsedVersion:
 #f not isinstance(version, (LegacyVersion, Version)):
 #ersion = parse(version)
 #eturn version

 #property
 #ef operator(self) -> str:
 #eturn self._spec[0]

 #property
 #ef version(self) -> str:
 #eturn self._spec[1]

 #property
 #ef prereleases(self) -> Optional[bool]:
 #eturn self._prereleases

 #prereleases.setter
 #ef prereleases(self, value: bool) -> None:
 #elf._prereleases = value

 #ef __contains__(self, item: str) -> bool:
 #eturn self.contains(item)

 #ef contains(
 #elf, item: UnparsedVersion, prereleases: Optional[bool] = None
 # -> bool:

        # Determine if prereleases are to be allowed or not.
 #f prereleases is None:
 #rereleases = self.prereleases

        # Normalize item to a Version or LegacyVersion, this allows us to have
        # a shortcut for ``"2.0" in Specifier(">=2")
 #ormalized_item = self._coerce_version(item)

        # Determine if we should be supporting prereleases in this specifier
        # or not, if we do not support prereleases than we can short circuit
        # logic if this version is a prereleases.
 #f normalized_item.is_prerelease and not prereleases:
 #eturn False

        # Actually do the comparison to determine if this item is contained
        # within this Specifier or not.
 #perator_callable: CallableOperator = self._get_operator(self.operator)
 #eturn operator_callable(normalized_item, self.version)

 #ef filter(
 #elf, iterable: Iterable[VersionTypeVar], prereleases: Optional[bool] = None
 # -> Iterable[VersionTypeVar]:

 #ielded = False
 #ound_prereleases = []

 #w = {"prereleases": prereleases if prereleases is not None else True}

        # Attempt to iterate over all the values in the iterable and if any of
        # them match, yield them.
 #or version in iterable:
 #arsed_version = self._coerce_version(version)

 #f self.contains(parsed_version, **kw):
                # If our version is a prerelease, and we were not set to allow
                # prereleases, then we'll store it for later in case nothing
                # else matches this specifier.
 #f parsed_version.is_prerelease and not (
 #rereleases or self.prereleases
 #:
 #ound_prereleases.append(version)
                # Either this is not a prerelease, or we should have been
                # accepting prereleases from the beginning.
 #lse:
 #ielded = True
 #ield version

        # Now that we've iterated over everything, determine if we've yielded
        # any values, and if we have not and we have any prereleases stored up
        # then we will go ahead and yield the prereleases.
 #f not yielded and found_prereleases:
 #or version in found_prereleases:
 #ield version


class LegacySpecifier(_IndividualSpecifier):

 #regex_str = r"""
 #?P<operator>(==|!=|<=|>=|<|>))
 #s*
 #?P<version>
 #^,;\s)]* # Since this is a "legacy" specifier, and the version
                      # string can be just about anything, we match everything
                      # except for whitespace, a semi-colon for marker support,
                      # a closing paren since versions can be enclosed in
                      # them, and a comma since it's a version separator.
 #
 #""

 #regex = re.compile(r"^\s*" + _regex_str + r"\s*$", re.VERBOSE | re.IGNORECASE)

 #operators = {
 #==": "equal",
 #!=": "not_equal",
 #<=": "less_than_equal",
 #>=": "greater_than_equal",
 #<": "less_than",
 #>": "greater_than",
 #

 #ef __init__(self, spec: str = "", prereleases: Optional[bool] = None) -> None:
 #uper().__init__(spec, prereleases)

 #arnings.warn(
 #Creating a LegacyVersion has been deprecated and will be "
 #removed in the next major release",
 #eprecationWarning,
 #

 #ef _coerce_version(self, version: UnparsedVersion) -> LegacyVersion:
 #f not isinstance(version, LegacyVersion):
 #ersion = LegacyVersion(str(version))
 #eturn version

 #ef _compare_equal(self, prospective: LegacyVersion, spec: str) -> bool:
 #eturn prospective == self._coerce_version(spec)

 #ef _compare_not_equal(self, prospective: LegacyVersion, spec: str) -> bool:
 #eturn prospective != self._coerce_version(spec)

 #ef _compare_less_than_equal(self, prospective: LegacyVersion, spec: str) -> bool:
 #eturn prospective <= self._coerce_version(spec)

 #ef _compare_greater_than_equal(
 #elf, prospective: LegacyVersion, spec: str
 # -> bool:
 #eturn prospective >= self._coerce_version(spec)

 #ef _compare_less_than(self, prospective: LegacyVersion, spec: str) -> bool:
 #eturn prospective < self._coerce_version(spec)

 #ef _compare_greater_than(self, prospective: LegacyVersion, spec: str) -> bool:
 #eturn prospective > self._coerce_version(spec)


def _require_version_compare(
 #n: Callable[["Specifier", ParsedVersion, str], bool]
) -> Callable[["Specifier", ParsedVersion, str], bool]:
 #functools.wraps(fn)
 #ef wrapped(self: "Specifier", prospective: ParsedVersion, spec: str) -> bool:
 #f not isinstance(prospective, Version):
 #eturn False
 #eturn fn(self, prospective, spec)

 #eturn wrapped


class Specifier(_IndividualSpecifier):

 #regex_str = r"""
 #?P<operator>(~=|==|!=|<=|>=|<|>|===))
 #?P<version>
 #?:
                # The identity operators allow for an escape hatch that will
                # do an exact string match of the version you wish to install.
                # This will not be parsed by PEP 440 and we cannot determine
                # any semantic meaning from it. This operator is discouraged
                # but included entirely as an escape hatch.
 #?<====)  # Only match for the identity operator
 #s*
 #^\s]*    # We just match everything, except for whitespace
                          # since we are only testing for strict identity.
 #
 #
 #?:
                # The (non)equality operators allow for wild card and local
                # versions to be specified so we have to define these two
                # operators separately to enable that.
 #?<===|!=)            # Only match for equals and not equals

 #s*
 #?
 #?:[0-9]+!)?          # epoch
 #0-9]+(?:\.[0-9]+)*   # release
 #?:                   # pre release
 #-_\.]?
 #a|b|c|rc|alpha|beta|pre|preview)
 #-_\.]?
 #0-9]*
 #?
 #?:                   # post release
 #?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
 #?

                # You cannot use a wild card and a dev or local version
                # together so group them with a | and make them optional.
 #?:
 #?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release
 #?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local
 #
 #.\*  # Wild card syntax of .*
 #?
 #
 #
 #?:
                # The compatible operator requires at least two digits in the
                # release segment.
 #?<=~=)               # Only match for the compatible operator

 #s*
 #?
 #?:[0-9]+!)?          # epoch
 #0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *)
 #?:                   # pre release
 #-_\.]?
 #a|b|c|rc|alpha|beta|pre|preview)
 #-_\.]?
 #0-9]*
 #?
 #?:                                   # post release
 #?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
 #?
 #?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
 #
 #
 #?:
                # All other operators only allow a sub set of what the
                # (non)equality operators do. Specifically they do not allow
                # local versions to be specified nor do they allow the prefix
                # matching wild cards.
 #?<!==|!=|~=)         # We have special cases for these
                                      # operators so we want to make sure they
                                      # don't match here.

 #s*
 #?
 #?:[0-9]+!)?          # epoch
 #0-9]+(?:\.[0-9]+)*   # release
 #?:                   # pre release
 #-_\.]?
 #a|b|c|rc|alpha|beta|pre|preview)
 #-_\.]?
 #0-9]*
 #?
 #?:                                   # post release
 #?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
 #?
 #?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
 #
 #
 #""

 #regex = re.compile(r"^\s*" + _regex_str + r"\s*$", re.VERBOSE | re.IGNORECASE)

 #operators = {
 #~=": "compatible",
 #==": "equal",
 #!=": "not_equal",
 #<=": "less_than_equal",
 #>=": "greater_than_equal",
 #<": "less_than",
 #>": "greater_than",
 #===": "arbitrary",
 #

 #_require_version_compare
 #ef _compare_compatible(self, prospective: ParsedVersion, spec: str) -> bool:

        # Compatible releases have an equivalent combination of >= and ==. That
        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to
        # implement this in terms of the other specifiers instead of
        # implementing it ourselves. The only thing we need to do is construct
        # the other specifiers.

        # We want everything but the last item in the version, but we want to
        # ignore suffix segments.
 #refix = ".".join(
 #ist(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]
 #

        # Add the prefix notation to the end of our string
 #refix += ".*"

 #eturn self._get_operator(">=")(prospective, spec) and self._get_operator("==")(
 #rospective, prefix
 #

 #_require_version_compare
 #ef _compare_equal(self, prospective: ParsedVersion, spec: str) -> bool:

        # We need special logic to handle prefix matching
 #f spec.endswith(".*"):
            # In the case of prefix matching we want to ignore local segment.
 #rospective = Version(prospective.public)
            # Split the spec out by dots, and pretend that there is an implicit
            # dot in between a release segment and a pre-release segment.
 #plit_spec = _version_split(spec[:-2])  # Remove the trailing .*

            # Split the prospective version out by dots, and pretend that there
            # is an implicit dot in between a release segment and a pre-release
            # segment.
 #plit_prospective = _version_split(str(prospective))

            # Shorten the prospective version to be the same length as the spec
            # so that we can determine if the specifier is a prefix of the
            # prospective version or not.
 #hortened_prospective = split_prospective[: len(split_spec)]

            # Pad out our two sides with zeros so that they both equal the same
            # length.
 #added_spec, padded_prospective = _pad_version(
 #plit_spec, shortened_prospective
 #

 #eturn padded_prospective == padded_spec
 #lse:
            # Convert our spec string into a Version
 #pec_version = Version(spec)

            # If the specifier does not have a local segment, then we want to
            # act as if the prospective version also does not have a local
            # segment.
 #f not spec_version.local:
 #rospective = Version(prospective.public)

 #eturn prospective == spec_version

 #_require_version_compare
 #ef _compare_not_equal(self, prospective: ParsedVersion, spec: str) -> bool:
 #eturn not self._compare_equal(prospective, spec)

 #_require_version_compare
 #ef _compare_less_than_equal(self, prospective: ParsedVersion, spec: str) -> bool:

        # NB: Local version identifiers are NOT permitted in the version
        # specifier, so local version labels can be universally removed from
        # the prospective version.
 #eturn Version(prospective.public) <= Version(spec)

 #_require_version_compare
 #ef _compare_greater_than_equal(
 #elf, prospective: ParsedVersion, spec: str
 # -> bool:

        # NB: Local version identifiers are NOT permitted in the version
        # specifier, so local version labels can be universally removed from
        # the prospective version.
 #eturn Version(prospective.public) >= Version(spec)

 #_require_version_compare
 #ef _compare_less_than(self, prospective: ParsedVersion, spec_str: str) -> bool:

        # Convert our spec to a Version instance, since we'll want to work with
        # it as a version.
 #pec = Version(spec_str)

        # Check to see if the prospective version is less than the spec
        # version. If it's not we can short circuit and just return False now
        # instead of doing extra unneeded work.
 #f not prospective < spec:
 #eturn False

        # This special case is here so that, unless the specifier itself
        # includes is a pre-release version, that we do not accept pre-release
        # versions for the version mentioned in the specifier (e.g. <3.1 should
        # not match 3.1.dev0, but should match 3.0.dev0).
 #f not spec.is_prerelease and prospective.is_prerelease:
 #f Version(prospective.base_version) == Version(spec.base_version):
 #eturn False

        # If we've gotten to here, it means that prospective version is both
        # less than the spec version *and* it's not a pre-release of the same
        # version in the spec.
 #eturn True

 #_require_version_compare
 #ef _compare_greater_than(self, prospective: ParsedVersion, spec_str: str) -> bool:

        # Convert our spec to a Version instance, since we'll want to work with
        # it as a version.
 #pec = Version(spec_str)

        # Check to see if the prospective version is greater than the spec
        # version. If it's not we can short circuit and just return False now
        # instead of doing extra unneeded work.
 #f not prospective > spec:
 #eturn False

        # This special case is here so that, unless the specifier itself
        # includes is a post-release version, that we do not accept
        # post-release versions for the version mentioned in the specifier
        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).
 #f not spec.is_postrelease and prospective.is_postrelease:
 #f Version(prospective.base_version) == Version(spec.base_version):
 #eturn False

        # Ensure that we do not allow a local version of the version mentioned
        # in the specifier, which is technically greater than, to match.
 #f prospective.local is not None:
 #f Version(prospective.base_version) == Version(spec.base_version):
 #eturn False

        # If we've gotten to here, it means that prospective version is both
        # greater than the spec version *and* it's not a pre-release of the
        # same version in the spec.
 #eturn True

 #ef _compare_arbitrary(self, prospective: Version, spec: str) -> bool:
 #eturn str(prospective).lower() == str(spec).lower()

 #property
 #ef prereleases(self) -> bool:

        # If there is an explicit prereleases set for this, then we'll just
        # blindly use that.
 #f self._prereleases is not None:
 #eturn self._prereleases

        # Look at all of our specifiers and determine if they are inclusive
        # operators, and if they are if they are including an explicit
        # prerelease.
 #perator, version = self._spec
 #f operator in ["==", ">=", "<=", "~=", "==="]:
            # The == specifier can include a trailing .*, if it does we
            # want to remove before parsing.
 #f operator == "==" and version.endswith(".*"):
 #ersion = version[:-2]

            # Parse the version, and if it is a pre-release than this
            # specifier allows pre-releases.
 #f parse(version).is_prerelease:
 #eturn True

 #eturn False

 #prereleases.setter
 #ef prereleases(self, value: bool) -> None:
 #elf._prereleases = value


_prefix_regex = re.compile(r"^([0-9]+)((?:a|b|c|rc)[0-9]+)$")


def _version_split(version: str) -> List[str]:
 #esult: List[str] = []
 #or item in version.split("."):
 #atch = _prefix_regex.search(item)
 #f match:
 #esult.extend(match.groups())
 #lse:
 #esult.append(item)
 #eturn result


def _is_not_suffix(segment: str) -> bool:
 #eturn not any(
 #egment.startswith(prefix) for prefix in ("dev", "a", "b", "rc", "post")
 #


def _pad_version(left: List[str], right: List[str]) -> Tuple[List[str], List[str]]:
 #eft_split, right_split = [], []

    # Get the release segment of our versions
 #eft_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))
 #ight_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))

    # Get the rest of our versions
 #eft_split.append(left[len(left_split[0]) :])
 #ight_split.append(right[len(right_split[0]) :])

    # Insert our padding
 #eft_split.insert(1, ["0"] * max(0, len(right_split[0]) - len(left_split[0])))
 #ight_split.insert(1, ["0"] * max(0, len(left_split[0]) - len(right_split[0])))

 #eturn (list(itertools.chain(*left_split)), list(itertools.chain(*right_split)))


class SpecifierSet(BaseSpecifier):
 #ef __init__(
 #elf, specifiers: str = "", prereleases: Optional[bool] = None
 # -> None:

        # Split on , to break each individual specifier into it's own item, and
        # strip each item to remove leading/trailing whitespace.
 #plit_specifiers = [s.strip() for s in specifiers.split(",") if s.strip()]

        # Parsed each individual specifier, attempting first to make it a
        # Specifier and falling back to a LegacySpecifier.
 #arsed: Set[_IndividualSpecifier] = set()
 #or specifier in split_specifiers:
 #ry:
 #arsed.add(Specifier(specifier))
 #xcept InvalidSpecifier:
 #arsed.add(LegacySpecifier(specifier))

        # Turn our parsed specifiers into a frozen set and save them for later.
 #elf._specs = frozenset(parsed)

        # Store our prereleases value so we can use it later to determine if
        # we accept prereleases or not.
 #elf._prereleases = prereleases

 #ef __repr__(self) -> str:
 #re = (
 #", prereleases={self.prereleases!r}"
 #f self._prereleases is not None
 #lse ""
 #

 #eturn f"<SpecifierSet({str(self)!r}{pre})>"

 #ef __str__(self) -> str:
 #eturn ",".join(sorted(str(s) for s in self._specs))

 #ef __hash__(self) -> int:
 #eturn hash(self._specs)

 #ef __and__(self, other: Union["SpecifierSet", str]) -> "SpecifierSet":
 #f isinstance(other, str):
 #ther = SpecifierSet(other)
 #lif not isinstance(other, SpecifierSet):
 #eturn NotImplemented

 #pecifier = SpecifierSet()
 #pecifier._specs = frozenset(self._specs | other._specs)

 #f self._prereleases is None and other._prereleases is not None:
 #pecifier._prereleases = other._prereleases
 #lif self._prereleases is not None and other._prereleases is None:
 #pecifier._prereleases = self._prereleases
 #lif self._prereleases == other._prereleases:
 #pecifier._prereleases = self._prereleases
 #lse:
 #aise ValueError(
 #Cannot combine SpecifierSets with True and False prerelease "
 #overrides."
 #

 #eturn specifier

 #ef __eq__(self, other: object) -> bool:
 #f isinstance(other, (str, _IndividualSpecifier)):
 #ther = SpecifierSet(str(other))
 #lif not isinstance(other, SpecifierSet):
 #eturn NotImplemented

 #eturn self._specs == other._specs

 #ef __len__(self) -> int:
 #eturn len(self._specs)

 #ef __iter__(self) -> Iterator[_IndividualSpecifier]:
 #eturn iter(self._specs)

 #property
 #ef prereleases(self) -> Optional[bool]:

        # If we have been given an explicit prerelease modifier, then we'll
        # pass that through here.
 #f self._prereleases is not None:
 #eturn self._prereleases

        # If we don't have any specifiers, and we don't have a forced value,
        # then we'll just return None since we don't know if this should have
        # pre-releases or not.
 #f not self._specs:
 #eturn None

        # Otherwise we'll see if any of the given specifiers accept
        # prereleases, if any of them do we'll return True, otherwise False.
 #eturn any(s.prereleases for s in self._specs)

 #prereleases.setter
 #ef prereleases(self, value: bool) -> None:
 #elf._prereleases = value

 #ef __contains__(self, item: UnparsedVersion) -> bool:
 #eturn self.contains(item)

 #ef contains(
 #elf, item: UnparsedVersion, prereleases: Optional[bool] = None
 # -> bool:

        # Ensure that our item is a Version or LegacyVersion instance.
 #f not isinstance(item, (LegacyVersion, Version)):
 #tem = parse(item)

        # Determine if we're forcing a prerelease or not, if we're not forcing
        # one for this particular filter call, then we'll use whatever the
        # SpecifierSet thinks for whether or not we should support prereleases.
 #f prereleases is None:
 #rereleases = self.prereleases

        # We can determine if we're going to allow pre-releases by looking to
        # see if any of the underlying items supports them. If none of them do
        # and this item is a pre-release then we do not allow it and we can
        # short circuit that here.
        # Note: This means that 1.0.dev1 would not be contained in something
        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0
 #f not prereleases and item.is_prerelease:
 #eturn False

        # We simply dispatch to the underlying specs here to make sure that the
        # given version is contained within all of them.
        # Note: This use of all() here means that an empty set of specifiers
        #       will always return True, this is an explicit design decision.
 #eturn all(s.contains(item, prereleases=prereleases) for s in self._specs)

 #ef filter(
 #elf, iterable: Iterable[VersionTypeVar], prereleases: Optional[bool] = None
 # -> Iterable[VersionTypeVar]:

        # Determine if we're forcing a prerelease or not, if we're not forcing
        # one for this particular filter call, then we'll use whatever the
        # SpecifierSet thinks for whether or not we should support prereleases.
 #f prereleases is None:
 #rereleases = self.prereleases

        # If we have any specifiers, then we want to wrap our iterable in the
        # filter method for each one, this will act as a logical AND amongst
        # each specifier.
 #f self._specs:
 #or spec in self._specs:
 #terable = spec.filter(iterable, prereleases=bool(prereleases))
 #eturn iterable
        # If we do not have any specifiers, then we need to have a rough filter
        # which will filter out any pre-releases, unless there are no final
        # releases, and which will filter out LegacyVersion in general.
 #lse:
 #iltered: List[VersionTypeVar] = []
 #ound_prereleases: List[VersionTypeVar] = []

 #tem: UnparsedVersion
 #arsed_version: Union[Version, LegacyVersion]

 #or item in iterable:
                # Ensure that we some kind of Version class for this item.
 #f not isinstance(item, (LegacyVersion, Version)):
 #arsed_version = parse(item)
 #lse:
 #arsed_version = item

                # Filter out any item which is parsed as a LegacyVersion
 #f isinstance(parsed_version, LegacyVersion):
 #ontinue

                # Store any item which is a pre-release for later unless we've
                # already found a final version or we are accepting prereleases
 #f parsed_version.is_prerelease and not prereleases:
 #f not filtered:
 #ound_prereleases.append(item)
 #lse:
 #iltered.append(item)

            # If we've found no items except for pre-releases, then we'll go
            # ahead and use the pre-releases
 #f not filtered and found_prereleases and prereleases is None:
 #eturn found_prereleases

 #eturn filtered
