import collections
import functools
import os
import re
import struct
import sys
import warnings
from typing import IO, Dict, Iterator, NamedTuple, Optional, Tuple


# Python does not provide platform information at sufficient granularity to
# identify the architecture of the running executable in some cases, so we
# determine it dynamically by reading the information from the running
# process. This only applies on Linux, which uses the ELF format.
class _ELFFileHeader:
    # https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_header
 #lass _InvalidELFFileHeader(ValueError):
 #""
 #n invalid ELF file header was found.
 #""

 #LF_MAGIC_NUMBER = 0x7F454C46
 #LFCLASS32 = 1
 #LFCLASS64 = 2
 #LFDATA2LSB = 1
 #LFDATA2MSB = 2
 #M_386 = 3
 #M_S390 = 22
 #M_ARM = 40
 #M_X86_64 = 62
 #F_ARM_ABIMASK = 0xFF000000
 #F_ARM_ABI_VER5 = 0x05000000
 #F_ARM_ABI_FLOAT_HARD = 0x00000400

 #ef __init__(self, file: IO[bytes]) -> None:
 #ef unpack(fmt: str) -> int:
 #ry:
 #ata = file.read(struct.calcsize(fmt))
 #esult: Tuple[int, ...] = struct.unpack(fmt, data)
 #xcept struct.error:
 #aise _ELFFileHeader._InvalidELFFileHeader()
 #eturn result[0]

 #elf.e_ident_magic = unpack(">I")
 #f self.e_ident_magic != self.ELF_MAGIC_NUMBER:
 #aise _ELFFileHeader._InvalidELFFileHeader()
 #elf.e_ident_class = unpack("B")
 #f self.e_ident_class not in {self.ELFCLASS32, self.ELFCLASS64}:
 #aise _ELFFileHeader._InvalidELFFileHeader()
 #elf.e_ident_data = unpack("B")
 #f self.e_ident_data not in {self.ELFDATA2LSB, self.ELFDATA2MSB}:
 #aise _ELFFileHeader._InvalidELFFileHeader()
 #elf.e_ident_version = unpack("B")
 #elf.e_ident_osabi = unpack("B")
 #elf.e_ident_abiversion = unpack("B")
 #elf.e_ident_pad = file.read(7)
 #ormat_h = "<H" if self.e_ident_data == self.ELFDATA2LSB else ">H"
 #ormat_i = "<I" if self.e_ident_data == self.ELFDATA2LSB else ">I"
 #ormat_q = "<Q" if self.e_ident_data == self.ELFDATA2LSB else ">Q"
 #ormat_p = format_i if self.e_ident_class == self.ELFCLASS32 else format_q
 #elf.e_type = unpack(format_h)
 #elf.e_machine = unpack(format_h)
 #elf.e_version = unpack(format_i)
 #elf.e_entry = unpack(format_p)
 #elf.e_phoff = unpack(format_p)
 #elf.e_shoff = unpack(format_p)
 #elf.e_flags = unpack(format_i)
 #elf.e_ehsize = unpack(format_h)
 #elf.e_phentsize = unpack(format_h)
 #elf.e_phnum = unpack(format_h)
 #elf.e_shentsize = unpack(format_h)
 #elf.e_shnum = unpack(format_h)
 #elf.e_shstrndx = unpack(format_h)


def _get_elf_header() -> Optional[_ELFFileHeader]:
 #ry:
 #ith open(sys.executable, "rb") as f:
 #lf_header = _ELFFileHeader(f)
 #xcept (OSError, TypeError, _ELFFileHeader._InvalidELFFileHeader):
 #eturn None
 #eturn elf_header


def _is_linux_armhf() -> bool:
    # hard-float ABI can be detected from the ELF header of the running
    # process
    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf
 #lf_header = _get_elf_header()
 #f elf_header is None:
 #eturn False
 #esult = elf_header.e_ident_class == elf_header.ELFCLASS32
 #esult &= elf_header.e_ident_data == elf_header.ELFDATA2LSB
 #esult &= elf_header.e_machine == elf_header.EM_ARM
 #esult &= (
 #lf_header.e_flags & elf_header.EF_ARM_ABIMASK
 # == elf_header.EF_ARM_ABI_VER5
 #esult &= (
 #lf_header.e_flags & elf_header.EF_ARM_ABI_FLOAT_HARD
 # == elf_header.EF_ARM_ABI_FLOAT_HARD
 #eturn result


def _is_linux_i686() -> bool:
 #lf_header = _get_elf_header()
 #f elf_header is None:
 #eturn False
 #esult = elf_header.e_ident_class == elf_header.ELFCLASS32
 #esult &= elf_header.e_ident_data == elf_header.ELFDATA2LSB
 #esult &= elf_header.e_machine == elf_header.EM_386
 #eturn result


def _have_compatible_abi(arch: str) -> bool:
 #f arch == "armv7l":
 #eturn _is_linux_armhf()
 #f arch == "i686":
 #eturn _is_linux_i686()
 #eturn arch in {"x86_64", "aarch64", "ppc64", "ppc64le", "s390x"}


# If glibc ever changes its major version, we need to know what the last
# minor version was, so we can build the complete list of all versions.
# For now, guess what the highest minor version might be, assume it will
# be 50 for testing. Once this actually happens, update the dictionary
# with the actual value.
_LAST_GLIBC_MINOR: Dict[int, int] = collections.defaultdict(lambda: 50)


class _GLibCVersion(NamedTuple):
 #ajor: int
 #inor: int


def _glibc_version_string_confstr() -> Optional[str]:
 #""
 #rimary implementation of glibc_version_string using os.confstr.
 #""
    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely
    # to be broken or missing. This strategy is used in the standard library
    # platform module.
    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183
 #ry:
        # os.confstr("CS_GNU_LIBC_VERSION") returns a string like "glibc 2.17".
 #ersion_string = os.confstr("CS_GNU_LIBC_VERSION")
 #ssert version_string is not None
 #, version = version_string.split()
 #xcept (AssertionError, AttributeError, OSError, ValueError):
        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...
 #eturn None
 #eturn version


def _glibc_version_string_ctypes() -> Optional[str]:
 #""
 #allback implementation of glibc_version_string using ctypes.
 #""
 #ry:
 #mport ctypes
 #xcept ImportError:
 #eturn None

    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen
    # manpage says, "If filename is NULL, then the returned handle is for the
    # main program". This way we can let the linker do the work to figure out
    # which libc our process is actually using.
    #
    # We must also handle the special case where the executable is not a
    # dynamically linked executable. This can occur when using musl libc,
    # for example. In this situation, dlopen() will error, leading to an
    # OSError. Interestingly, at least in the case of musl, there is no
    # errno set on the OSError. The single string argument used to construct
    # OSError comes from libc itself and is therefore not portable to
    # hard code here. In any case, failure to call dlopen() means we
    # can proceed, so we bail on our attempt.
 #ry:
 #rocess_namespace = ctypes.CDLL(None)
 #xcept OSError:
 #eturn None

 #ry:
 #nu_get_libc_version = process_namespace.gnu_get_libc_version
 #xcept AttributeError:
        # Symbol doesn't exist -> therefore, we are not linked to
        # glibc.
 #eturn None

    # Call gnu_get_libc_version, which returns a string like "2.5"
 #nu_get_libc_version.restype = ctypes.c_char_p
 #ersion_str: str = gnu_get_libc_version()
    # py2 / py3 compatibility:
 #f not isinstance(version_str, str):
 #ersion_str = version_str.decode("ascii")

 #eturn version_str


def _glibc_version_string() -> Optional[str]:
 #""Returns glibc version string, or None if not using glibc."""
 #eturn _glibc_version_string_confstr() or _glibc_version_string_ctypes()


def _parse_glibc_version(version_str: str) -> Tuple[int, int]:
 #""Parse glibc version.

 #e use a regexp instead of str.split because we want to discard any
 #andom junk that might come after the minor version -- this might happen
 #n patched/forked versions of glibc (e.g. Linaro's version of glibc
 #ses version strings like "2.20-2014.11"). See gh-3588.
 #""
 # = re.match(r"(?P<major>[0-9]+)\.(?P<minor>[0-9]+)", version_str)
 #f not m:
 #arnings.warn(
 #Expected glibc version with 2 components major.minor,"
 # got: %s" % version_str,
 #untimeWarning,
 #
 #eturn -1, -1
 #eturn int(m.group("major")), int(m.group("minor"))


@functools.lru_cache()
def _get_glibc_version() -> Tuple[int, int]:
 #ersion_str = _glibc_version_string()
 #f version_str is None:
 #eturn (-1, -1)
 #eturn _parse_glibc_version(version_str)


# From PEP 513, PEP 600
def _is_compatible(name: str, arch: str, version: _GLibCVersion) -> bool:
 #ys_glibc = _get_glibc_version()
 #f sys_glibc < version:
 #eturn False
    # Check for presence of _manylinux module.
 #ry:
 #mport _manylinux  # noqa
 #xcept ImportError:
 #eturn True
 #f hasattr(_manylinux, "manylinux_compatible"):
 #esult = _manylinux.manylinux_compatible(version[0], version[1], arch)
 #f result is not None:
 #eturn bool(result)
 #eturn True
 #f version == _GLibCVersion(2, 5):
 #f hasattr(_manylinux, "manylinux1_compatible"):
 #eturn bool(_manylinux.manylinux1_compatible)
 #f version == _GLibCVersion(2, 12):
 #f hasattr(_manylinux, "manylinux2010_compatible"):
 #eturn bool(_manylinux.manylinux2010_compatible)
 #f version == _GLibCVersion(2, 17):
 #f hasattr(_manylinux, "manylinux2014_compatible"):
 #eturn bool(_manylinux.manylinux2014_compatible)
 #eturn True


_LEGACY_MANYLINUX_MAP = {
    # CentOS 7 w/ glibc 2.17 (PEP 599)
 #2, 17): "manylinux2014",
    # CentOS 6 w/ glibc 2.12 (PEP 571)
 #2, 12): "manylinux2010",
    # CentOS 5 w/ glibc 2.5 (PEP 513)
 #2, 5): "manylinux1",
}


def platform_tags(linux: str, arch: str) -> Iterator[str]:
 #f not _have_compatible_abi(arch):
 #eturn
    # Oldest glibc to be supported regardless of architecture is (2, 17).
 #oo_old_glibc2 = _GLibCVersion(2, 16)
 #f arch in {"x86_64", "i686"}:
        # On x86/i686 also oldest glibc to be supported is (2, 5).
 #oo_old_glibc2 = _GLibCVersion(2, 4)
 #urrent_glibc = _GLibCVersion(*_get_glibc_version())
 #libc_max_list = [current_glibc]
    # We can assume compatibility across glibc major versions.
    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636
    #
    # Build a list of maximum glibc versions so that we can
    # output the canonical list of all glibc from current_glibc
    # down to too_old_glibc2, including all intermediary versions.
 #or glibc_major in range(current_glibc.major - 1, 1, -1):
 #libc_minor = _LAST_GLIBC_MINOR[glibc_major]
 #libc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))
 #or glibc_max in glibc_max_list:
 #f glibc_max.major == too_old_glibc2.major:
 #in_minor = too_old_glibc2.minor
 #lse:
            # For other glibc major versions oldest supported is (x, 0).
 #in_minor = -1
 #or glibc_minor in range(glibc_max.minor, min_minor, -1):
 #libc_version = _GLibCVersion(glibc_max.major, glibc_minor)
 #ag = "manylinux_{}_{}".format(*glibc_version)
 #f _is_compatible(tag, arch, glibc_version):
 #ield linux.replace("linux", tag)
            # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.
 #f glibc_version in _LEGACY_MANYLINUX_MAP:
 #egacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]
 #f _is_compatible(legacy_tag, arch, glibc_version):
 #ield linux.replace("linux", legacy_tag)
