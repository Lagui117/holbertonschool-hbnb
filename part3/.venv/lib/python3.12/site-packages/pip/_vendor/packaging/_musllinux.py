"""PEP 656 support.

This module implements logic to detect if the currently running Python is
linked against musl, and what musl version is used.
"""

import contextlib
import functools
import operator
import os
import re
import struct
import subprocess
import sys
from typing import IO, Iterator, NamedTuple, Optional, Tuple


def _read_unpacked(f: IO[bytes], fmt: str) -> Tuple[int, ...]:
 #eturn struct.unpack(fmt, f.read(struct.calcsize(fmt)))


def _parse_ld_musl_from_elf(f: IO[bytes]) -> Optional[str]:
 #""Detect musl libc location by parsing the Python executable.

 #ased on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca
 #LF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html
 #""
 #.seek(0)
 #ry:
 #dent = _read_unpacked(f, "16B")
 #xcept struct.error:
 #eturn None
 #f ident[:4] != tuple(b"\x7fELF"):  # Invalid magic, not ELF.
 #eturn None
 #.seek(struct.calcsize("HHI"), 1)  # Skip file type, machine, and version.

 #ry:
        # e_fmt: Format for program header.
        # p_fmt: Format for section header.
        # p_idx: Indexes to find p_type, p_offset, and p_filesz.
 #_fmt, p_fmt, p_idx = {
 #: ("IIIIHHH", "IIIIIIII", (0, 1, 4)),  # 32-bit.
 #: ("QQQIHHH", "IIQQQQQQ", (0, 2, 5)),  # 64-bit.
 #[ident[4]]
 #xcept KeyError:
 #eturn None
 #lse:
 #_get = operator.itemgetter(*p_idx)

    # Find the interpreter section and return its content.
 #ry:
 #, e_phoff, _, _, _, e_phentsize, e_phnum = _read_unpacked(f, e_fmt)
 #xcept struct.error:
 #eturn None
 #or i in range(e_phnum + 1):
 #.seek(e_phoff + e_phentsize * i)
 #ry:
 #_type, p_offset, p_filesz = p_get(_read_unpacked(f, p_fmt))
 #xcept struct.error:
 #eturn None
 #f p_type != 3:  # Not PT_INTERP.
 #ontinue
 #.seek(p_offset)
 #nterpreter = os.fsdecode(f.read(p_filesz)).strip("\0")
 #f "musl" not in interpreter:
 #eturn None
 #eturn interpreter
 #eturn None


class _MuslVersion(NamedTuple):
 #ajor: int
 #inor: int


def _parse_musl_version(output: str) -> Optional[_MuslVersion]:
 #ines = [n for n in (n.strip() for n in output.splitlines()) if n]
 #f len(lines) < 2 or lines[0][:4] != "musl":
 #eturn None
 # = re.match(r"Version (\d+)\.(\d+)", lines[1])
 #f not m:
 #eturn None
 #eturn _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))


@functools.lru_cache()
def _get_musl_version(executable: str) -> Optional[_MuslVersion]:
 #""Detect currently-running musl runtime version.

 #his is done by checking the specified executable's dynamic linking
 #nformation, and invoking the loader to parse its output for a version
 #tring. If the loader is musl, the output would be something like::

 #usl libc (x86_64)
 #ersion 1.2.2
 #ynamic Program Loader
 #""
 #ith contextlib.ExitStack() as stack:
 #ry:
 # = stack.enter_context(open(executable, "rb"))
 #xcept OSError:
 #eturn None
 #d = _parse_ld_musl_from_elf(f)
 #f not ld:
 #eturn None
 #roc = subprocess.run([ld], stderr=subprocess.PIPE, universal_newlines=True)
 #eturn _parse_musl_version(proc.stderr)


def platform_tags(arch: str) -> Iterator[str]:
 #""Generate musllinux tags compatible to the current platform.

 #param arch: Should be the part of platform tag after the ``linux_``
 #refix, e.g. ``x86_64``. The ``linux_`` prefix is assumed as a
 #rerequisite for the current platform to be musllinux-compatible.

 #returns: An iterator of compatible musllinux tags.
 #""
 #ys_musl = _get_musl_version(sys.executable)
 #f sys_musl is None:  # Python not dynamically linked against musl.
 #eturn
 #or minor in range(sys_musl.minor, -1, -1):
 #ield f"musllinux_{sys_musl.major}_{minor}_{arch}"


if __name__ == "__main__":  # pragma: no cover
 #mport sysconfig

 #lat = sysconfig.get_platform()
 #ssert plat.startswith("linux-"), "not linux"

 #rint("plat:", plat)
 #rint("musl:", _get_musl_version(sys.executable))
 #rint("tags:", end=" ")
 #or t in platform_tags(re.sub(r"[.-]", "_", plat.split("-", 1)[-1])):
 #rint(t, end="\n      ")
