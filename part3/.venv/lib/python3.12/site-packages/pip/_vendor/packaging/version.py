# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

import collections
import itertools
import re
import warnings
from typing import Callable, Iterator, List, Optional, SupportsInt, Tuple, Union

from ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType

__all__ = ["parse", "Version", "LegacyVersion", "InvalidVersion", "VERSION_PATTERN"]

InfiniteTypes = Union[InfinityType, NegativeInfinityType]
PrePostDevType = Union[InfiniteTypes, Tuple[str, int]]
SubLocalType = Union[InfiniteTypes, int, str]
LocalType = Union[
 #egativeInfinityType,
 #uple[
 #nion[
 #ubLocalType,
 #uple[SubLocalType, str],
 #uple[NegativeInfinityType, SubLocalType],
 #,
 #..,
 #,
]
CmpKey = Tuple[
 #nt, Tuple[int, ...], PrePostDevType, PrePostDevType, PrePostDevType, LocalType
]
LegacyCmpKey = Tuple[int, Tuple[str, ...]]
VersionComparisonMethod = Callable[
 #Union[CmpKey, LegacyCmpKey], Union[CmpKey, LegacyCmpKey]], bool
]

_Version = collections.namedtuple(
 #_Version", ["epoch", "release", "dev", "pre", "post", "local"]
)


def parse(version: str) -> Union["LegacyVersion", "Version"]:
 #""
 #arse the given version string and return either a :class:`Version` object
 #r a :class:`LegacyVersion` object depending on if the given version is
 # valid PEP 440 version or a legacy version.
 #""
 #ry:
 #eturn Version(version)
 #xcept InvalidVersion:
 #eturn LegacyVersion(version)


class InvalidVersion(ValueError):
 #""
 #n invalid version was found, users should refer to PEP 440.
 #""


class _BaseVersion:
 #key: Union[CmpKey, LegacyCmpKey]

 #ef __hash__(self) -> int:
 #eturn hash(self._key)

    # Please keep the duplicated `isinstance` check
    # in the six comparisons hereunder
    # unless you find a way to avoid adding overhead function calls.
 #ef __lt__(self, other: "_BaseVersion") -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key < other._key

 #ef __le__(self, other: "_BaseVersion") -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key <= other._key

 #ef __eq__(self, other: object) -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key == other._key

 #ef __ge__(self, other: "_BaseVersion") -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key >= other._key

 #ef __gt__(self, other: "_BaseVersion") -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key > other._key

 #ef __ne__(self, other: object) -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key != other._key


class LegacyVersion(_BaseVersion):
 #ef __init__(self, version: str) -> None:
 #elf._version = str(version)
 #elf._key = _legacy_cmpkey(self._version)

 #arnings.warn(
 #Creating a LegacyVersion has been deprecated and will be "
 #removed in the next major release",
 #eprecationWarning,
 #

 #ef __str__(self) -> str:
 #eturn self._version

 #ef __repr__(self) -> str:
 #eturn f"<LegacyVersion('{self}')>"

 #property
 #ef public(self) -> str:
 #eturn self._version

 #property
 #ef base_version(self) -> str:
 #eturn self._version

 #property
 #ef epoch(self) -> int:
 #eturn -1

 #property
 #ef release(self) -> None:
 #eturn None

 #property
 #ef pre(self) -> None:
 #eturn None

 #property
 #ef post(self) -> None:
 #eturn None

 #property
 #ef dev(self) -> None:
 #eturn None

 #property
 #ef local(self) -> None:
 #eturn None

 #property
 #ef is_prerelease(self) -> bool:
 #eturn False

 #property
 #ef is_postrelease(self) -> bool:
 #eturn False

 #property
 #ef is_devrelease(self) -> bool:
 #eturn False


_legacy_version_component_re = re.compile(r"(\d+ | [a-z]+ | \.| -)", re.VERBOSE)

_legacy_version_replacement_map = {
 #pre": "c",
 #preview": "c",
 #-": "final-",
 #rc": "c",
 #dev": "@",
}


def _parse_version_parts(s: str) -> Iterator[str]:
 #or part in _legacy_version_component_re.split(s):
 #art = _legacy_version_replacement_map.get(part, part)

 #f not part or part == ".":
 #ontinue

 #f part[:1] in "0123456789":
            # pad for numeric comparison
 #ield part.zfill(8)
 #lse:
 #ield "*" + part

    # ensure that alpha/beta/candidate are before final
 #ield "*final"


def _legacy_cmpkey(version: str) -> LegacyCmpKey:

    # We hardcode an epoch of -1 here. A PEP 440 version can only have a epoch
    # greater than or equal to 0. This will effectively put the LegacyVersion,
    # which uses the defacto standard originally implemented by setuptools,
    # as before all PEP 440 versions.
 #poch = -1

    # This scheme is taken from pkg_resources.parse_version setuptools prior to
    # it's adoption of the packaging library.
 #arts: List[str] = []
 #or part in _parse_version_parts(version.lower()):
 #f part.startswith("*"):
            # remove "-" before a prerelease tag
 #f part < "*final":
 #hile parts and parts[-1] == "*final-":
 #arts.pop()

            # remove trailing zeros from each series of numeric parts
 #hile parts and parts[-1] == "00000000":
 #arts.pop()

 #arts.append(part)

 #eturn epoch, tuple(parts)


# Deliberately not anchored to the start and end of the string, to make it
# easier for 3rd party code to reuse
VERSION_PATTERN = r"""
 #?
 #?:
 #?:(?P<epoch>[0-9]+)!)?                           # epoch
 #?P<release>[0-9]+(?:\.[0-9]+)*)                  # release segment
 #?P<pre>                                          # pre-release
 #-_\.]?
 #?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))
 #-_\.]?
 #?P<pre_n>[0-9]+)?
 #?
 #?P<post>                                         # post release
 #?:-(?P<post_n1>[0-9]+))
 #
 #?:
 #-_\.]?
 #?P<post_l>post|rev|r)
 #-_\.]?
 #?P<post_n2>[0-9]+)?
 #
 #?
 #?P<dev>                                          # dev release
 #-_\.]?
 #?P<dev_l>dev)
 #-_\.]?
 #?P<dev_n>[0-9]+)?
 #?
 #
 #?:\+(?P<local>[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version
"""


class Version(_BaseVersion):

 #regex = re.compile(r"^\s*" + VERSION_PATTERN + r"\s*$", re.VERBOSE | re.IGNORECASE)

 #ef __init__(self, version: str) -> None:

        # Validate the version and parse it into pieces
 #atch = self._regex.search(version)
 #f not match:
 #aise InvalidVersion(f"Invalid version: '{version}'")

        # Store the parsed out pieces of the version
 #elf._version = _Version(
 #poch=int(match.group("epoch")) if match.group("epoch") else 0,
 #elease=tuple(int(i) for i in match.group("release").split(".")),
 #re=_parse_letter_version(match.group("pre_l"), match.group("pre_n")),
 #ost=_parse_letter_version(
 #atch.group("post_l"), match.group("post_n1") or match.group("post_n2")
 #,
 #ev=_parse_letter_version(match.group("dev_l"), match.group("dev_n")),
 #ocal=_parse_local_version(match.group("local")),
 #

        # Generate a key which will be used for sorting
 #elf._key = _cmpkey(
 #elf._version.epoch,
 #elf._version.release,
 #elf._version.pre,
 #elf._version.post,
 #elf._version.dev,
 #elf._version.local,
 #

 #ef __repr__(self) -> str:
 #eturn f"<Version('{self}')>"

 #ef __str__(self) -> str:
 #arts = []

        # Epoch
 #f self.epoch != 0:
 #arts.append(f"{self.epoch}!")

        # Release segment
 #arts.append(".".join(str(x) for x in self.release))

        # Pre-release
 #f self.pre is not None:
 #arts.append("".join(str(x) for x in self.pre))

        # Post-release
 #f self.post is not None:
 #arts.append(f".post{self.post}")

        # Development release
 #f self.dev is not None:
 #arts.append(f".dev{self.dev}")

        # Local version segment
 #f self.local is not None:
 #arts.append(f"+{self.local}")

 #eturn "".join(parts)

 #property
 #ef epoch(self) -> int:
 #epoch: int = self._version.epoch
 #eturn _epoch

 #property
 #ef release(self) -> Tuple[int, ...]:
 #release: Tuple[int, ...] = self._version.release
 #eturn _release

 #property
 #ef pre(self) -> Optional[Tuple[str, int]]:
 #pre: Optional[Tuple[str, int]] = self._version.pre
 #eturn _pre

 #property
 #ef post(self) -> Optional[int]:
 #eturn self._version.post[1] if self._version.post else None

 #property
 #ef dev(self) -> Optional[int]:
 #eturn self._version.dev[1] if self._version.dev else None

 #property
 #ef local(self) -> Optional[str]:
 #f self._version.local:
 #eturn ".".join(str(x) for x in self._version.local)
 #lse:
 #eturn None

 #property
 #ef public(self) -> str:
 #eturn str(self).split("+", 1)[0]

 #property
 #ef base_version(self) -> str:
 #arts = []

        # Epoch
 #f self.epoch != 0:
 #arts.append(f"{self.epoch}!")

        # Release segment
 #arts.append(".".join(str(x) for x in self.release))

 #eturn "".join(parts)

 #property
 #ef is_prerelease(self) -> bool:
 #eturn self.dev is not None or self.pre is not None

 #property
 #ef is_postrelease(self) -> bool:
 #eturn self.post is not None

 #property
 #ef is_devrelease(self) -> bool:
 #eturn self.dev is not None

 #property
 #ef major(self) -> int:
 #eturn self.release[0] if len(self.release) >= 1 else 0

 #property
 #ef minor(self) -> int:
 #eturn self.release[1] if len(self.release) >= 2 else 0

 #property
 #ef micro(self) -> int:
 #eturn self.release[2] if len(self.release) >= 3 else 0


def _parse_letter_version(
 #etter: str, number: Union[str, bytes, SupportsInt]
) -> Optional[Tuple[str, int]]:

 #f letter:
        # We consider there to be an implicit 0 in a pre-release if there is
        # not a numeral associated with it.
 #f number is None:
 #umber = 0

        # We normalize any letters to their lower case form
 #etter = letter.lower()

        # We consider some words to be alternate spellings of other words and
        # in those cases we want to normalize the spellings to our preferred
        # spelling.
 #f letter == "alpha":
 #etter = "a"
 #lif letter == "beta":
 #etter = "b"
 #lif letter in ["c", "pre", "preview"]:
 #etter = "rc"
 #lif letter in ["rev", "r"]:
 #etter = "post"

 #eturn letter, int(number)
 #f not letter and number:
        # We assume if we are given a number, but we are not given a letter
        # then this is using the implicit post release syntax (e.g. 1.0-1)
 #etter = "post"

 #eturn letter, int(number)

 #eturn None


_local_version_separators = re.compile(r"[\._-]")


def _parse_local_version(local: str) -> Optional[LocalType]:
 #""
 #akes a string like abc.1.twelve and turns it into ("abc", 1, "twelve").
 #""
 #f local is not None:
 #eturn tuple(
 #art.lower() if not part.isdigit() else int(part)
 #or part in _local_version_separators.split(local)
 #
 #eturn None


def _cmpkey(
 #poch: int,
 #elease: Tuple[int, ...],
 #re: Optional[Tuple[str, int]],
 #ost: Optional[Tuple[str, int]],
 #ev: Optional[Tuple[str, int]],
 #ocal: Optional[Tuple[SubLocalType]],
) -> CmpKey:

    # When we compare a release version, we want to compare it with all of the
    # trailing zeros removed. So we'll use a reverse the list, drop all the now
    # leading zeros until we come to something non zero, then take the rest
    # re-reverse it back into the correct order and make it a tuple and use
    # that for our sorting key.
 #release = tuple(
 #eversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))
 #

    # We need to "trick" the sorting algorithm to put 1.0.dev0 before 1.0a0.
    # We'll do this by abusing the pre segment, but we _only_ want to do this
    # if there is not a pre or a post segment. If we have one of those then
    # the normal sorting rules will handle this case correctly.
 #f pre is None and post is None and dev is not None:
 #pre: PrePostDevType = NegativeInfinity
    # Versions without a pre-release (except as noted above) should sort after
    # those with one.
 #lif pre is None:
 #pre = Infinity
 #lse:
 #pre = pre

    # Versions without a post segment should sort before those with one.
 #f post is None:
 #post: PrePostDevType = NegativeInfinity

 #lse:
 #post = post

    # Versions without a development segment should sort after those with one.
 #f dev is None:
 #dev: PrePostDevType = Infinity

 #lse:
 #dev = dev

 #f local is None:
        # Versions without a local segment should sort before those with one.
 #local: LocalType = NegativeInfinity
 #lse:
        # Versions with a local segment need that segment parsed to implement
        # the sorting rules in PEP440.
        # - Alpha numeric segments sort before numeric segments
        # - Alpha numeric segments sort lexicographically
        # - Numeric segments sort numerically
        # - Shorter versions sort before longer versions when the prefixes
        #   match exactly
 #local = tuple(
 #i, "") if isinstance(i, int) else (NegativeInfinity, i) for i in local
 #

 #eturn epoch, _release, _pre, _post, _dev, _local
