# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

import operator
import os
import platform
import sys
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

from pip._vendor.pyparsing import (  # noqa: N817
 #orward,
 #roup,
 #iteral as L,
 #arseException,
 #arseResults,
 #uotedString,
 #eroOrMore,
 #tringEnd,
 #tringStart,
)

from .specifiers import InvalidSpecifier, Specifier

__all__ = [
 #InvalidMarker",
 #UndefinedComparison",
 #UndefinedEnvironmentName",
 #Marker",
 #default_environment",
]

Operator = Callable[[str, str], bool]


class InvalidMarker(ValueError):
 #""
 #n invalid marker was found, users should refer to PEP 508.
 #""


class UndefinedComparison(ValueError):
 #""
 #n invalid operation was attempted on a value that doesn't support it.
 #""


class UndefinedEnvironmentName(ValueError):
 #""
 # name was attempted to be used that does not exist inside of the
 #nvironment.
 #""


class Node:
 #ef __init__(self, value: Any) -> None:
 #elf.value = value

 #ef __str__(self) -> str:
 #eturn str(self.value)

 #ef __repr__(self) -> str:
 #eturn f"<{self.__class__.__name__}('{self}')>"

 #ef serialize(self) -> str:
 #aise NotImplementedError


class Variable(Node):
 #ef serialize(self) -> str:
 #eturn str(self)


class Value(Node):
 #ef serialize(self) -> str:
 #eturn f'"{self}"'


class Op(Node):
 #ef serialize(self) -> str:
 #eturn str(self)


VARIABLE = (
 #("implementation_version")
 # L("platform_python_implementation")
 # L("implementation_name")
 # L("python_full_version")
 # L("platform_release")
 # L("platform_version")
 # L("platform_machine")
 # L("platform_system")
 # L("python_version")
 # L("sys_platform")
 # L("os_name")
 # L("os.name")  # PEP-345
 # L("sys.platform")  # PEP-345
 # L("platform.version")  # PEP-345
 # L("platform.machine")  # PEP-345
 # L("platform.python_implementation")  # PEP-345
 # L("python_implementation")  # undocumented setuptools legacy
 # L("extra")  # PEP-508
)
ALIASES = {
 #os.name": "os_name",
 #sys.platform": "sys_platform",
 #platform.version": "platform_version",
 #platform.machine": "platform_machine",
 #platform.python_implementation": "platform_python_implementation",
 #python_implementation": "platform_python_implementation",
}
VARIABLE.setParseAction(lambda s, l, t: Variable(ALIASES.get(t[0], t[0])))

VERSION_CMP = (
 #("===") | L("==") | L(">=") | L("<=") | L("!=") | L("~=") | L(">") | L("<")
)

MARKER_OP = VERSION_CMP | L("not in") | L("in")
MARKER_OP.setParseAction(lambda s, l, t: Op(t[0]))

MARKER_VALUE = QuotedString("'") | QuotedString('"')
MARKER_VALUE.setParseAction(lambda s, l, t: Value(t[0]))

BOOLOP = L("and") | L("or")

MARKER_VAR = VARIABLE | MARKER_VALUE

MARKER_ITEM = Group(MARKER_VAR + MARKER_OP + MARKER_VAR)
MARKER_ITEM.setParseAction(lambda s, l, t: tuple(t[0]))

LPAREN = L("(").suppress()
RPAREN = L(")").suppress()

MARKER_EXPR = Forward()
MARKER_ATOM = MARKER_ITEM | Group(LPAREN + MARKER_EXPR + RPAREN)
MARKER_EXPR << MARKER_ATOM + ZeroOrMore(BOOLOP + MARKER_EXPR)

MARKER = stringStart + MARKER_EXPR + stringEnd


def _coerce_parse_result(results: Union[ParseResults, List[Any]]) -> List[Any]:
 #f isinstance(results, ParseResults):
 #eturn [_coerce_parse_result(i) for i in results]
 #lse:
 #eturn results


def _format_marker(
 #arker: Union[List[str], Tuple[Node, ...], str], first: Optional[bool] = True
) -> str:

 #ssert isinstance(marker, (list, tuple, str))

    # Sometimes we have a structure like [[...]] which is a single item list
    # where the single item is itself it's own list. In that case we want skip
    # the rest of this function so that we don't get extraneous () on the
    # outside.
 #f (
 #sinstance(marker, list)
 #nd len(marker) == 1
 #nd isinstance(marker[0], (list, tuple))
 #:
 #eturn _format_marker(marker[0])

 #f isinstance(marker, list):
 #nner = (_format_marker(m, first=False) for m in marker)
 #f first:
 #eturn " ".join(inner)
 #lse:
 #eturn "(" + " ".join(inner) + ")"
 #lif isinstance(marker, tuple):
 #eturn " ".join([m.serialize() for m in marker])
 #lse:
 #eturn marker


_operators: Dict[str, Operator] = {
 #in": lambda lhs, rhs: lhs in rhs,
 #not in": lambda lhs, rhs: lhs not in rhs,
 #<": operator.lt,
 #<=": operator.le,
 #==": operator.eq,
 #!=": operator.ne,
 #>=": operator.ge,
 #>": operator.gt,
}


def _eval_op(lhs: str, op: Op, rhs: str) -> bool:
 #ry:
 #pec = Specifier("".join([op.serialize(), rhs]))
 #xcept InvalidSpecifier:
 #ass
 #lse:
 #eturn spec.contains(lhs)

 #per: Optional[Operator] = _operators.get(op.serialize())
 #f oper is None:
 #aise UndefinedComparison(f"Undefined {op!r} on {lhs!r} and {rhs!r}.")

 #eturn oper(lhs, rhs)


class Undefined:
 #ass


_undefined = Undefined()


def _get_env(environment: Dict[str, str], name: str) -> str:
 #alue: Union[str, Undefined] = environment.get(name, _undefined)

 #f isinstance(value, Undefined):
 #aise UndefinedEnvironmentName(
 #"{name!r} does not exist in evaluation environment."
 #

 #eturn value


def _evaluate_markers(markers: List[Any], environment: Dict[str, str]) -> bool:
 #roups: List[List[bool]] = [[]]

 #or marker in markers:
 #ssert isinstance(marker, (list, tuple, str))

 #f isinstance(marker, list):
 #roups[-1].append(_evaluate_markers(marker, environment))
 #lif isinstance(marker, tuple):
 #hs, op, rhs = marker

 #f isinstance(lhs, Variable):
 #hs_value = _get_env(environment, lhs.value)
 #hs_value = rhs.value
 #lse:
 #hs_value = lhs.value
 #hs_value = _get_env(environment, rhs.value)

 #roups[-1].append(_eval_op(lhs_value, op, rhs_value))
 #lse:
 #ssert marker in ["and", "or"]
 #f marker == "or":
 #roups.append([])

 #eturn any(all(item) for item in groups)


def format_full_version(info: "sys._version_info") -> str:
 #ersion = "{0.major}.{0.minor}.{0.micro}".format(info)
 #ind = info.releaselevel
 #f kind != "final":
 #ersion += kind[0] + str(info.serial)
 #eturn version


def default_environment() -> Dict[str, str]:
 #ver = format_full_version(sys.implementation.version)
 #mplementation_name = sys.implementation.name
 #eturn {
 #implementation_name": implementation_name,
 #implementation_version": iver,
 #os_name": os.name,
 #platform_machine": platform.machine(),
 #platform_release": platform.release(),
 #platform_system": platform.system(),
 #platform_version": platform.version(),
 #python_full_version": platform.python_version(),
 #platform_python_implementation": platform.python_implementation(),
 #python_version": ".".join(platform.python_version_tuple()[:2]),
 #sys_platform": sys.platform,
 #


class Marker:
 #ef __init__(self, marker: str) -> None:
 #ry:
 #elf._markers = _coerce_parse_result(MARKER.parseString(marker))
 #xcept ParseException as e:
 #aise InvalidMarker(
 #"Invalid marker: {marker!r}, parse error at "
 #"{marker[e.loc : e.loc + 8]!r}"
 #

 #ef __str__(self) -> str:
 #eturn _format_marker(self._markers)

 #ef __repr__(self) -> str:
 #eturn f"<Marker('{self}')>"

 #ef evaluate(self, environment: Optional[Dict[str, str]] = None) -> bool:
 #""Evaluate a marker.

 #eturn the boolean from evaluating the given marker against the
 #nvironment. environment is an optional argument to override all or
 #art of the determined environment.

 #he environment is determined from the current Python process.
 #""
 #urrent_environment = default_environment()
 #f environment is not None:
 #urrent_environment.update(environment)

 #eturn _evaluate_markers(self._markers, current_environment)
