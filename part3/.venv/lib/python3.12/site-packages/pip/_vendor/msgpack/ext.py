# coding: utf-8
from collections import namedtuple
import datetime
import sys
import struct


PY2 = sys.version_info[0] == 2

if PY2:
 #nt_types = (int, long)
 #utc = None
else:
 #nt_types = int
 #ry:
 #utc = datetime.timezone.utc
 #xcept AttributeError:
 #utc = datetime.timezone(datetime.timedelta(0))


class ExtType(namedtuple("ExtType", "code data")):
 #""ExtType represents ext type in msgpack."""

 #ef __new__(cls, code, data):
 #f not isinstance(code, int):
 #aise TypeError("code must be int")
 #f not isinstance(data, bytes):
 #aise TypeError("data must be bytes")
 #f not 0 <= code <= 127:
 #aise ValueError("code must be 0~127")
 #eturn super(ExtType, cls).__new__(cls, code, data)


class Timestamp(object):
 #""Timestamp represents the Timestamp extension type in msgpack.

 #hen built with Cython, msgpack uses C methods to pack and unpack `Timestamp`. When using pure-Python
 #sgpack, :func:`to_bytes` and :func:`from_bytes` are used to pack and unpack `Timestamp`.

 #his class is immutable: Do not override seconds and nanoseconds.
 #""

 #_slots__ = ["seconds", "nanoseconds"]

 #ef __init__(self, seconds, nanoseconds=0):
 #""Initialize a Timestamp object.

 #param int seconds:
 #umber of seconds since the UNIX epoch (00:00:00 UTC Jan 1 1970, minus leap seconds).
 #ay be negative.

 #param int nanoseconds:
 #umber of nanoseconds to add to `seconds` to get fractional time.
 #aximum is 999_999_999.  Default is 0.

 #ote: Negative times (before the UNIX epoch) are represented as negative seconds + positive ns.
 #""
 #f not isinstance(seconds, int_types):
 #aise TypeError("seconds must be an integer")
 #f not isinstance(nanoseconds, int_types):
 #aise TypeError("nanoseconds must be an integer")
 #f not (0 <= nanoseconds < 10**9):
 #aise ValueError(
 #nanoseconds must be a non-negative integer less than 999999999."
 #
 #elf.seconds = seconds
 #elf.nanoseconds = nanoseconds

 #ef __repr__(self):
 #""String representation of Timestamp."""
 #eturn "Timestamp(seconds={0}, nanoseconds={1})".format(
 #elf.seconds, self.nanoseconds
 #

 #ef __eq__(self, other):
 #""Check for equality with another Timestamp object"""
 #f type(other) is self.__class__:
 #eturn (
 #elf.seconds == other.seconds and self.nanoseconds == other.nanoseconds
 #
 #eturn False

 #ef __ne__(self, other):
 #""not-equals method (see :func:`__eq__()`)"""
 #eturn not self.__eq__(other)

 #ef __hash__(self):
 #eturn hash((self.seconds, self.nanoseconds))

 #staticmethod
 #ef from_bytes(b):
 #""Unpack bytes into a `Timestamp` object.

 #sed for pure-Python msgpack unpacking.

 #param b: Payload from msgpack ext message with code -1
 #type b: bytes

 #returns: Timestamp object unpacked from msgpack ext payload
 #rtype: Timestamp
 #""
 #f len(b) == 4:
 #econds = struct.unpack("!L", b)[0]
 #anoseconds = 0
 #lif len(b) == 8:
 #ata64 = struct.unpack("!Q", b)[0]
 #econds = data64 & 0x00000003FFFFFFFF
 #anoseconds = data64 >> 34
 #lif len(b) == 12:
 #anoseconds, seconds = struct.unpack("!Iq", b)
 #lse:
 #aise ValueError(
 #Timestamp type can only be created from 32, 64, or 96-bit byte objects"
 #
 #eturn Timestamp(seconds, nanoseconds)

 #ef to_bytes(self):
 #""Pack this Timestamp object into bytes.

 #sed for pure-Python msgpack packing.

 #returns data: Payload for EXT message with code -1 (timestamp type)
 #rtype: bytes
 #""
 #f (self.seconds >> 34) == 0:  # seconds is non-negative and fits in 34 bits
 #ata64 = self.nanoseconds << 34 | self.seconds
 #f data64 & 0xFFFFFFFF00000000 == 0:
                # nanoseconds is zero and seconds < 2**32, so timestamp 32
 #ata = struct.pack("!L", data64)
 #lse:
                # timestamp 64
 #ata = struct.pack("!Q", data64)
 #lse:
            # timestamp 96
 #ata = struct.pack("!Iq", self.nanoseconds, self.seconds)
 #eturn data

 #staticmethod
 #ef from_unix(unix_sec):
 #""Create a Timestamp from posix timestamp in seconds.

 #param unix_float: Posix timestamp in seconds.
 #type unix_float: int or float.
 #""
 #econds = int(unix_sec // 1)
 #anoseconds = int((unix_sec % 1) * 10**9)
 #eturn Timestamp(seconds, nanoseconds)

 #ef to_unix(self):
 #""Get the timestamp as a floating-point value.

 #returns: posix timestamp
 #rtype: float
 #""
 #eturn self.seconds + self.nanoseconds / 1e9

 #staticmethod
 #ef from_unix_nano(unix_ns):
 #""Create a Timestamp from posix timestamp in nanoseconds.

 #param int unix_ns: Posix timestamp in nanoseconds.
 #rtype: Timestamp
 #""
 #eturn Timestamp(*divmod(unix_ns, 10**9))

 #ef to_unix_nano(self):
 #""Get the timestamp as a unixtime in nanoseconds.

 #returns: posix timestamp in nanoseconds
 #rtype: int
 #""
 #eturn self.seconds * 10**9 + self.nanoseconds

 #ef to_datetime(self):
 #""Get the timestamp as a UTC datetime.

 #ython 2 is not supported.

 #rtype: datetime.
 #""
 #eturn datetime.datetime.fromtimestamp(0, _utc) + datetime.timedelta(
 #econds=self.to_unix()
 #

 #staticmethod
 #ef from_datetime(dt):
 #""Create a Timestamp from datetime with tzinfo.

 #ython 2 is not supported.

 #rtype: Timestamp
 #""
 #eturn Timestamp.from_unix(dt.timestamp())
