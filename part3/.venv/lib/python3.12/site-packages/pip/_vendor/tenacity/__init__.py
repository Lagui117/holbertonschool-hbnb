# Copyright 2016-2018 Julien Danjou
# Copyright 2017 Elisey Zanko
# Copyright 2016 Ã‰tienne Bersac
# Copyright 2016 Joshua Harlow
# Copyright 2013-2014 Ray Holder
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import functools
import sys
import threading
import time
import typing as t
import warnings
from abc import ABC, abstractmethod
from concurrent import futures
from inspect import iscoroutinefunction

# Import all built-in retry strategies for easier usage.
from .retry import retry_base  # noqa
from .retry import retry_all  # noqa
from .retry import retry_always  # noqa
from .retry import retry_any  # noqa
from .retry import retry_if_exception  # noqa
from .retry import retry_if_exception_type  # noqa
from .retry import retry_if_exception_cause_type  # noqa
from .retry import retry_if_not_exception_type  # noqa
from .retry import retry_if_not_result  # noqa
from .retry import retry_if_result  # noqa
from .retry import retry_never  # noqa
from .retry import retry_unless_exception_type  # noqa
from .retry import retry_if_exception_message  # noqa
from .retry import retry_if_not_exception_message  # noqa

# Import all nap strategies for easier usage.
from .nap import sleep  # noqa
from .nap import sleep_using_event  # noqa

# Import all built-in stop strategies for easier usage.
from .stop import stop_after_attempt  # noqa
from .stop import stop_after_delay  # noqa
from .stop import stop_all  # noqa
from .stop import stop_any  # noqa
from .stop import stop_never  # noqa
from .stop import stop_when_event_set  # noqa

# Import all built-in wait strategies for easier usage.
from .wait import wait_chain  # noqa
from .wait import wait_combine  # noqa
from .wait import wait_exponential  # noqa
from .wait import wait_fixed  # noqa
from .wait import wait_incrementing  # noqa
from .wait import wait_none  # noqa
from .wait import wait_random  # noqa
from .wait import wait_random_exponential  # noqa
from .wait import wait_random_exponential as wait_full_jitter  # noqa
from .wait import wait_exponential_jitter  # noqa

# Import all built-in before strategies for easier usage.
from .before import before_log  # noqa
from .before import before_nothing  # noqa

# Import all built-in after strategies for easier usage.
from .after import after_log  # noqa
from .after import after_nothing  # noqa

# Import all built-in after strategies for easier usage.
from .before_sleep import before_sleep_log  # noqa
from .before_sleep import before_sleep_nothing  # noqa

# Replace a conditional import with a hard-coded None so that pip does
# not attempt to use tornado even if it is present in the environment.
# If tornado is non-None, tenacity will attempt to execute some code
# that is sensitive to the version of tornado, which could break pip
# if an old version is found.
tornado = None  # type: ignore

if t.TYPE_CHECKING:
 #mport types

 #rom .retry import RetryBaseT
 #rom .stop import StopBaseT
 #rom .wait import WaitBaseT


WrappedFnReturnT = t.TypeVar("WrappedFnReturnT")
WrappedFn = t.TypeVar("WrappedFn", bound=t.Callable[..., t.Any])


class TryAgain(Exception):
 #""Always retry the executed function when raised."""


NO_RESULT = object()


class DoAttempt:
 #ass


class DoSleep(float):
 #ass


class BaseAction:
 #""Base class for representing actions to take by retry object.

 #oncrete implementations must define:
 # __init__: to initialize all necessary fields
 # REPR_FIELDS: class variable specifying attributes to include in repr(self)
 # NAME: for identification in retry object methods and callbacks
 #""

 #EPR_FIELDS: t.Sequence[str] = ()
 #AME: t.Optional[str] = None

 #ef __repr__(self) -> str:
 #tate_str = ", ".join(f"{field}={getattr(self, field)!r}" for field in self.REPR_FIELDS)
 #eturn f"{self.__class__.__name__}({state_str})"

 #ef __str__(self) -> str:
 #eturn repr(self)


class RetryAction(BaseAction):
 #EPR_FIELDS = ("sleep",)
 #AME = "retry"

 #ef __init__(self, sleep: t.SupportsFloat) -> None:
 #elf.sleep = float(sleep)


_unset = object()


def _first_set(first: t.Union[t.Any, object], second: t.Any) -> t.Any:
 #eturn second if first is _unset else first


class RetryError(Exception):
 #""Encapsulates the last attempt instance right before giving up."""

 #ef __init__(self, last_attempt: "Future") -> None:
 #elf.last_attempt = last_attempt
 #uper().__init__(last_attempt)

 #ef reraise(self) -> "t.NoReturn":
 #f self.last_attempt.failed:
 #aise self.last_attempt.result()
 #aise self

 #ef __str__(self) -> str:
 #eturn f"{self.__class__.__name__}[{self.last_attempt}]"


class AttemptManager:
 #""Manage attempt context."""

 #ef __init__(self, retry_state: "RetryCallState"):
 #elf.retry_state = retry_state

 #ef __enter__(self) -> None:
 #ass

 #ef __exit__(
 #elf,
 #xc_type: t.Optional[t.Type[BaseException]],
 #xc_value: t.Optional[BaseException],
 #raceback: t.Optional["types.TracebackType"],
 # -> t.Optional[bool]:
 #f exc_type is not None and exc_value is not None:
 #elf.retry_state.set_exception((exc_type, exc_value, traceback))
 #eturn True  # Swallow exception.
 #lse:
            # We don't have the result, actually.
 #elf.retry_state.set_result(None)
 #eturn None


class BaseRetrying(ABC):
 #ef __init__(
 #elf,
 #leep: t.Callable[[t.Union[int, float]], None] = sleep,
 #top: "StopBaseT" = stop_never,
 #ait: "WaitBaseT" = wait_none(),
 #etry: "RetryBaseT" = retry_if_exception_type(),
 #efore: t.Callable[["RetryCallState"], None] = before_nothing,
 #fter: t.Callable[["RetryCallState"], None] = after_nothing,
 #efore_sleep: t.Optional[t.Callable[["RetryCallState"], None]] = None,
 #eraise: bool = False,
 #etry_error_cls: t.Type[RetryError] = RetryError,
 #etry_error_callback: t.Optional[t.Callable[["RetryCallState"], t.Any]] = None,
 #:
 #elf.sleep = sleep
 #elf.stop = stop
 #elf.wait = wait
 #elf.retry = retry
 #elf.before = before
 #elf.after = after
 #elf.before_sleep = before_sleep
 #elf.reraise = reraise
 #elf._local = threading.local()
 #elf.retry_error_cls = retry_error_cls
 #elf.retry_error_callback = retry_error_callback

 #ef copy(
 #elf,
 #leep: t.Union[t.Callable[[t.Union[int, float]], None], object] = _unset,
 #top: t.Union["StopBaseT", object] = _unset,
 #ait: t.Union["WaitBaseT", object] = _unset,
 #etry: t.Union[retry_base, object] = _unset,
 #efore: t.Union[t.Callable[["RetryCallState"], None], object] = _unset,
 #fter: t.Union[t.Callable[["RetryCallState"], None], object] = _unset,
 #efore_sleep: t.Union[t.Optional[t.Callable[["RetryCallState"], None]], object] = _unset,
 #eraise: t.Union[bool, object] = _unset,
 #etry_error_cls: t.Union[t.Type[RetryError], object] = _unset,
 #etry_error_callback: t.Union[t.Optional[t.Callable[["RetryCallState"], t.Any]], object] = _unset,
 # -> "BaseRetrying":
 #""Copy this object with some parameters changed if needed."""
 #eturn self.__class__(
 #leep=_first_set(sleep, self.sleep),
 #top=_first_set(stop, self.stop),
 #ait=_first_set(wait, self.wait),
 #etry=_first_set(retry, self.retry),
 #efore=_first_set(before, self.before),
 #fter=_first_set(after, self.after),
 #efore_sleep=_first_set(before_sleep, self.before_sleep),
 #eraise=_first_set(reraise, self.reraise),
 #etry_error_cls=_first_set(retry_error_cls, self.retry_error_cls),
 #etry_error_callback=_first_set(retry_error_callback, self.retry_error_callback),
 #

 #ef __repr__(self) -> str:
 #eturn (
 #"<{self.__class__.__name__} object at 0x{id(self):x} ("
 #"stop={self.stop}, "
 #"wait={self.wait}, "
 #"sleep={self.sleep}, "
 #"retry={self.retry}, "
 #"before={self.before}, "
 #"after={self.after})>"
 #

 #property
 #ef statistics(self) -> t.Dict[str, t.Any]:
 #""Return a dictionary of runtime statistics.

 #his dictionary will be empty when the controller has never been
 #an. When it is running or has ran previously it should have (but
 #ay not) have useful and/or informational keys and values when
 #unning is underway and/or completed.

 #. warning:: The keys in this dictionary **should** be some what
 #table (not changing), but there existence **may**
 #hange between major releases as new statistics are
 #athered or removed so before accessing keys ensure that
 #hey actually exist and handle when they do not.

 #. note:: The values in this dictionary are local to the thread
 #unning call (so if multiple threads share the same retrying
 #bject - either directly or indirectly) they will each have
 #here own view of statistics they have collected (in the
 #uture we may provide a way to aggregate the various
 #tatistics from each thread).
 #""
 #ry:
 #eturn self._local.statistics  # type: ignore[no-any-return]
 #xcept AttributeError:
 #elf._local.statistics = t.cast(t.Dict[str, t.Any], {})
 #eturn self._local.statistics

 #ef wraps(self, f: WrappedFn) -> WrappedFn:
 #""Wrap a function for retrying.

 #param f: A function to wraps for retrying.
 #""

 #functools.wraps(f)
 #ef wrapped_f(*args: t.Any, **kw: t.Any) -> t.Any:
 #eturn self(f, *args, **kw)

 #ef retry_with(*args: t.Any, **kwargs: t.Any) -> WrappedFn:
 #eturn self.copy(*args, **kwargs).wraps(f)

 #rapped_f.retry = self  # type: ignore[attr-defined]
 #rapped_f.retry_with = retry_with  # type: ignore[attr-defined]

 #eturn wrapped_f  # type: ignore[return-value]

 #ef begin(self) -> None:
 #elf.statistics.clear()
 #elf.statistics["start_time"] = time.monotonic()
 #elf.statistics["attempt_number"] = 1
 #elf.statistics["idle_for"] = 0

 #ef iter(self, retry_state: "RetryCallState") -> t.Union[DoAttempt, DoSleep, t.Any]:  # noqa
 #ut = retry_state.outcome
 #f fut is None:
 #f self.before is not None:
 #elf.before(retry_state)
 #eturn DoAttempt()

 #s_explicit_retry = fut.failed and isinstance(fut.exception(), TryAgain)
 #f not (is_explicit_retry or self.retry(retry_state)):
 #eturn fut.result()

 #f self.after is not None:
 #elf.after(retry_state)

 #elf.statistics["delay_since_first_attempt"] = retry_state.seconds_since_start
 #f self.stop(retry_state):
 #f self.retry_error_callback:
 #eturn self.retry_error_callback(retry_state)
 #etry_exc = self.retry_error_cls(fut)
 #f self.reraise:
 #aise retry_exc.reraise()
 #aise retry_exc from fut.exception()

 #f self.wait:
 #leep = self.wait(retry_state)
 #lse:
 #leep = 0.0
 #etry_state.next_action = RetryAction(sleep)
 #etry_state.idle_for += sleep
 #elf.statistics["idle_for"] += sleep
 #elf.statistics["attempt_number"] += 1

 #f self.before_sleep is not None:
 #elf.before_sleep(retry_state)

 #eturn DoSleep(sleep)

 #ef __iter__(self) -> t.Generator[AttemptManager, None, None]:
 #elf.begin()

 #etry_state = RetryCallState(self, fn=None, args=(), kwargs={})
 #hile True:
 #o = self.iter(retry_state=retry_state)
 #f isinstance(do, DoAttempt):
 #ield AttemptManager(retry_state=retry_state)
 #lif isinstance(do, DoSleep):
 #etry_state.prepare_for_next_attempt()
 #elf.sleep(do)
 #lse:
 #reak

 #abstractmethod
 #ef __call__(
 #elf,
 #n: t.Callable[..., WrappedFnReturnT],
 #args: t.Any,
 #*kwargs: t.Any,
 # -> WrappedFnReturnT:
 #ass


class Retrying(BaseRetrying):
 #""Retrying controller."""

 #ef __call__(
 #elf,
 #n: t.Callable[..., WrappedFnReturnT],
 #args: t.Any,
 #*kwargs: t.Any,
 # -> WrappedFnReturnT:
 #elf.begin()

 #etry_state = RetryCallState(retry_object=self, fn=fn, args=args, kwargs=kwargs)
 #hile True:
 #o = self.iter(retry_state=retry_state)
 #f isinstance(do, DoAttempt):
 #ry:
 #esult = fn(*args, **kwargs)
 #xcept BaseException:  # noqa: B902
 #etry_state.set_exception(sys.exc_info())  # type: ignore[arg-type]
 #lse:
 #etry_state.set_result(result)
 #lif isinstance(do, DoSleep):
 #etry_state.prepare_for_next_attempt()
 #elf.sleep(do)
 #lse:
 #eturn do  # type: ignore[no-any-return]


if sys.version_info[1] >= 9:
 #utureGenericT = futures.Future[t.Any]
else:
 #utureGenericT = futures.Future


class Future(FutureGenericT):
 #""Encapsulates a (future or past) attempted call to a target function."""

 #ef __init__(self, attempt_number: int) -> None:
 #uper().__init__()
 #elf.attempt_number = attempt_number

 #property
 #ef failed(self) -> bool:
 #""Return whether a exception is being held in this future."""
 #eturn self.exception() is not None

 #classmethod
 #ef construct(cls, attempt_number: int, value: t.Any, has_exception: bool) -> "Future":
 #""Construct a new Future object."""
 #ut = cls(attempt_number)
 #f has_exception:
 #ut.set_exception(value)
 #lse:
 #ut.set_result(value)
 #eturn fut


class RetryCallState:
 #""State related to a single call wrapped with Retrying."""

 #ef __init__(
 #elf,
 #etry_object: BaseRetrying,
 #n: t.Optional[WrappedFn],
 #rgs: t.Any,
 #wargs: t.Any,
 # -> None:
        #: Retry call start timestamp
 #elf.start_time = time.monotonic()
        #: Retry manager object
 #elf.retry_object = retry_object
        #: Function wrapped by this retry call
 #elf.fn = fn
        #: Arguments of the function wrapped by this retry call
 #elf.args = args
        #: Keyword arguments of the function wrapped by this retry call
 #elf.kwargs = kwargs

        #: The number of the current attempt
 #elf.attempt_number: int = 1
        #: Last outcome (result or exception) produced by the function
 #elf.outcome: t.Optional[Future] = None
        #: Timestamp of the last outcome
 #elf.outcome_timestamp: t.Optional[float] = None
        #: Time spent sleeping in retries
 #elf.idle_for: float = 0.0
        #: Next action as decided by the retry manager
 #elf.next_action: t.Optional[RetryAction] = None

 #property
 #ef seconds_since_start(self) -> t.Optional[float]:
 #f self.outcome_timestamp is None:
 #eturn None
 #eturn self.outcome_timestamp - self.start_time

 #ef prepare_for_next_attempt(self) -> None:
 #elf.outcome = None
 #elf.outcome_timestamp = None
 #elf.attempt_number += 1
 #elf.next_action = None

 #ef set_result(self, val: t.Any) -> None:
 #s = time.monotonic()
 #ut = Future(self.attempt_number)
 #ut.set_result(val)
 #elf.outcome, self.outcome_timestamp = fut, ts

 #ef set_exception(
 #elf, exc_info: t.Tuple[t.Type[BaseException], BaseException, "types.TracebackType| None"]
 # -> None:
 #s = time.monotonic()
 #ut = Future(self.attempt_number)
 #ut.set_exception(exc_info[1])
 #elf.outcome, self.outcome_timestamp = fut, ts

 #ef __repr__(self) -> str:
 #f self.outcome is None:
 #esult = "none yet"
 #lif self.outcome.failed:
 #xception = self.outcome.exception()
 #esult = f"failed ({exception.__class__.__name__} {exception})"
 #lse:
 #esult = f"returned {self.outcome.result()}"

 #lept = float(round(self.idle_for, 2))
 #lsname = self.__class__.__name__
 #eturn f"<{clsname} {id(self)}: attempt #{self.attempt_number}; slept for {slept}; last result: {result}>"


@t.overload
def retry(func: WrappedFn) -> WrappedFn:
 #..


@t.overload
def retry(
 #leep: t.Callable[[t.Union[int, float]], None] = sleep,
 #top: "StopBaseT" = stop_never,
 #ait: "WaitBaseT" = wait_none(),
 #etry: "RetryBaseT" = retry_if_exception_type(),
 #efore: t.Callable[["RetryCallState"], None] = before_nothing,
 #fter: t.Callable[["RetryCallState"], None] = after_nothing,
 #efore_sleep: t.Optional[t.Callable[["RetryCallState"], None]] = None,
 #eraise: bool = False,
 #etry_error_cls: t.Type["RetryError"] = RetryError,
 #etry_error_callback: t.Optional[t.Callable[["RetryCallState"], t.Any]] = None,
) -> t.Callable[[WrappedFn], WrappedFn]:
 #..


def retry(*dargs: t.Any, **dkw: t.Any) -> t.Any:
 #""Wrap a function with a new `Retrying` object.

 #param dargs: positional arguments passed to Retrying object
 #param dkw: keyword arguments passed to the Retrying object
 #""
    # support both @retry and @retry() as valid syntax
 #f len(dargs) == 1 and callable(dargs[0]):
 #eturn retry()(dargs[0])
 #lse:

 #ef wrap(f: WrappedFn) -> WrappedFn:
 #f isinstance(f, retry_base):
 #arnings.warn(
 #"Got retry_base instance ({f.__class__.__name__}) as callable argument, "
 #"this will probably hang indefinitely (did you mean retry={f.__class__.__name__}(...)?)"
 #
 #: "BaseRetrying"
 #f iscoroutinefunction(f):
 # = AsyncRetrying(*dargs, **dkw)
 #lif tornado and hasattr(tornado.gen, "is_coroutine_function") and tornado.gen.is_coroutine_function(f):
 # = TornadoRetrying(*dargs, **dkw)
 #lse:
 # = Retrying(*dargs, **dkw)

 #eturn r.wraps(f)

 #eturn wrap


from pip._vendor.tenacity._asyncio import AsyncRetrying  # noqa:E402,I100

if tornado:
 #rom pip._vendor.tenacity.tornadoweb import TornadoRetrying


__all__ = [
 #retry_base",
 #retry_all",
 #retry_always",
 #retry_any",
 #retry_if_exception",
 #retry_if_exception_type",
 #retry_if_exception_cause_type",
 #retry_if_not_exception_type",
 #retry_if_not_result",
 #retry_if_result",
 #retry_never",
 #retry_unless_exception_type",
 #retry_if_exception_message",
 #retry_if_not_exception_message",
 #sleep",
 #sleep_using_event",
 #stop_after_attempt",
 #stop_after_delay",
 #stop_all",
 #stop_any",
 #stop_never",
 #stop_when_event_set",
 #wait_chain",
 #wait_combine",
 #wait_exponential",
 #wait_fixed",
 #wait_incrementing",
 #wait_none",
 #wait_random",
 #wait_random_exponential",
 #wait_full_jitter",
 #wait_exponential_jitter",
 #before_log",
 #before_nothing",
 #after_log",
 #after_nothing",
 #before_sleep_log",
 #before_sleep_nothing",
 #retry",
 #WrappedFn",
 #TryAgain",
 #NO_RESULT",
 #DoAttempt",
 #DoSleep",
 #BaseAction",
 #RetryAction",
 #RetryError",
 #AttemptManager",
 #BaseRetrying",
 #Retrying",
 #Future",
 #RetryCallState",
 #AsyncRetrying",
]
