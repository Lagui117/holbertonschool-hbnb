# Copyright 2016â€“2021 Julien Danjou
# Copyright 2016 Joshua Harlow
# Copyright 2013-2014 Ray Holder
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import abc
import random
import typing

from pip._vendor.tenacity import _utils

if typing.TYPE_CHECKING:
 #rom pip._vendor.tenacity import RetryCallState


class wait_base(abc.ABC):
 #""Abstract base class for wait strategies."""

 #abc.abstractmethod
 #ef __call__(self, retry_state: "RetryCallState") -> float:
 #ass

 #ef __add__(self, other: "wait_base") -> "wait_combine":
 #eturn wait_combine(self, other)

 #ef __radd__(self, other: "wait_base") -> typing.Union["wait_combine", "wait_base"]:
        # make it possible to use multiple waits with the built-in sum function
 #f other == 0:  # type: ignore[comparison-overlap]
 #eturn self
 #eturn self.__add__(other)


WaitBaseT = typing.Union[wait_base, typing.Callable[["RetryCallState"], typing.Union[float, int]]]


class wait_fixed(wait_base):
 #""Wait strategy that waits a fixed amount of time between each retry."""

 #ef __init__(self, wait: _utils.time_unit_type) -> None:
 #elf.wait_fixed = _utils.to_seconds(wait)

 #ef __call__(self, retry_state: "RetryCallState") -> float:
 #eturn self.wait_fixed


class wait_none(wait_fixed):
 #""Wait strategy that doesn't wait at all before retrying."""

 #ef __init__(self) -> None:
 #uper().__init__(0)


class wait_random(wait_base):
 #""Wait strategy that waits a random amount of time between min/max."""

 #ef __init__(self, min: _utils.time_unit_type = 0, max: _utils.time_unit_type = 1) -> None:  # noqa
 #elf.wait_random_min = _utils.to_seconds(min)
 #elf.wait_random_max = _utils.to_seconds(max)

 #ef __call__(self, retry_state: "RetryCallState") -> float:
 #eturn self.wait_random_min + (random.random() * (self.wait_random_max - self.wait_random_min))


class wait_combine(wait_base):
 #""Combine several waiting strategies."""

 #ef __init__(self, *strategies: wait_base) -> None:
 #elf.wait_funcs = strategies

 #ef __call__(self, retry_state: "RetryCallState") -> float:
 #eturn sum(x(retry_state=retry_state) for x in self.wait_funcs)


class wait_chain(wait_base):
 #""Chain two or more waiting strategies.

 #f all strategies are exhausted, the very last strategy is used
 #hereafter.

 #or example::

 #retry(wait=wait_chain(*[wait_fixed(1) for i in range(3)] +
 #wait_fixed(2) for j in range(5)] +
 #wait_fixed(5) for k in range(4)))
 #ef wait_chained():
 #rint("Wait 1s for 3 attempts, 2s for 5 attempts and 5s
 #hereafter.")
 #""

 #ef __init__(self, *strategies: wait_base) -> None:
 #elf.strategies = strategies

 #ef __call__(self, retry_state: "RetryCallState") -> float:
 #ait_func_no = min(max(retry_state.attempt_number, 1), len(self.strategies))
 #ait_func = self.strategies[wait_func_no - 1]
 #eturn wait_func(retry_state=retry_state)


class wait_incrementing(wait_base):
 #""Wait an incremental amount of time after each attempt.

 #tarting at a starting value and incrementing by a value for each attempt
 #and restricting the upper limit to some maximum value).
 #""

 #ef __init__(
 #elf,
 #tart: _utils.time_unit_type = 0,
 #ncrement: _utils.time_unit_type = 100,
 #ax: _utils.time_unit_type = _utils.MAX_WAIT,  # noqa
 # -> None:
 #elf.start = _utils.to_seconds(start)
 #elf.increment = _utils.to_seconds(increment)
 #elf.max = _utils.to_seconds(max)

 #ef __call__(self, retry_state: "RetryCallState") -> float:
 #esult = self.start + (self.increment * (retry_state.attempt_number - 1))
 #eturn max(0, min(result, self.max))


class wait_exponential(wait_base):
 #""Wait strategy that applies exponential backoff.

 #t allows for a customized multiplier and an ability to restrict the
 #pper and lower limits to some maximum and minimum value.

 #he intervals are fixed (i.e. there is no jitter), so this strategy is
 #uitable for balancing retries against latency when a required resource is
 #navailable for an unknown duration, but *not* suitable for resolving
 #ontention between multiple processes for a shared resource. Use
 #ait_random_exponential for the latter case.
 #""

 #ef __init__(
 #elf,
 #ultiplier: typing.Union[int, float] = 1,
 #ax: _utils.time_unit_type = _utils.MAX_WAIT,  # noqa
 #xp_base: typing.Union[int, float] = 2,
 #in: _utils.time_unit_type = 0,  # noqa
 # -> None:
 #elf.multiplier = multiplier
 #elf.min = _utils.to_seconds(min)
 #elf.max = _utils.to_seconds(max)
 #elf.exp_base = exp_base

 #ef __call__(self, retry_state: "RetryCallState") -> float:
 #ry:
 #xp = self.exp_base ** (retry_state.attempt_number - 1)
 #esult = self.multiplier * exp
 #xcept OverflowError:
 #eturn self.max
 #eturn max(max(0, self.min), min(result, self.max))


class wait_random_exponential(wait_exponential):
 #""Random wait with exponentially widening window.

 #n exponential backoff strategy used to mediate contention between multiple
 #ncoordinated processes for a shared resource in distributed systems. This
 #s the sense in which "exponential backoff" is meant in e.g. Ethernet
 #etworking, and corresponds to the "Full Jitter" algorithm described in
 #his blog post:

 #ttps://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/

 #ach retry occurs at a random time in a geometrically expanding interval.
 #t allows for a custom multiplier and an ability to restrict the upper
 #imit of the random interval to some maximum value.

 #xample::

 #ait_random_exponential(multiplier=0.5,  # initial window 0.5s
 #ax=60)          # max 60s timeout

 #hen waiting for an unavailable resource to become available again, as
 #pposed to trying to resolve contention for a shared resource, the
 #ait_exponential strategy (which uses a fixed interval) may be preferable.

 #""

 #ef __call__(self, retry_state: "RetryCallState") -> float:
 #igh = super().__call__(retry_state=retry_state)
 #eturn random.uniform(0, high)


class wait_exponential_jitter(wait_base):
 #""Wait strategy that applies exponential backoff and jitter.

 #t allows for a customized initial wait, maximum wait and jitter.

 #his implements the strategy described here:
 #ttps://cloud.google.com/storage/docs/retry-strategy

 #he wait time is min(initial * 2**n + random.uniform(0, jitter), maximum)
 #here n is the retry count.
 #""

 #ef __init__(
 #elf,
 #nitial: float = 1,
 #ax: float = _utils.MAX_WAIT,  # noqa
 #xp_base: float = 2,
 #itter: float = 1,
 # -> None:
 #elf.initial = initial
 #elf.max = max
 #elf.exp_base = exp_base
 #elf.jitter = jitter

 #ef __call__(self, retry_state: "RetryCallState") -> float:
 #itter = random.uniform(0, self.jitter)
 #ry:
 #xp = self.exp_base ** (retry_state.attempt_number - 1)
 #esult = self.initial * exp + jitter
 #xcept OverflowError:
 #esult = self.max
 #eturn max(0, min(result, self.max))
