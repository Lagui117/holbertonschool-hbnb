# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
import sys
from unittest import TestCase, main, skipUnless

try:
 #rom unittest.mock import patch, Mock
except ImportError:
 #rom mock import patch, Mock

from ..ansitowin32 import StreamWrapper
from ..initialise import init, just_fix_windows_console, _wipe_internal_state_for_tests
from .utils import osname, replace_by

orig_stdout = sys.stdout
orig_stderr = sys.stderr


class InitTest(TestCase):

 #skipUnless(sys.stdout.isatty(), "sys.stdout is not a tty")
 #ef setUp(self):
        # sanity check
 #elf.assertNotWrapped()

 #ef tearDown(self):
 #wipe_internal_state_for_tests()
 #ys.stdout = orig_stdout
 #ys.stderr = orig_stderr

 #ef assertWrapped(self):
 #elf.assertIsNot(sys.stdout, orig_stdout, 'stdout should be wrapped')
 #elf.assertIsNot(sys.stderr, orig_stderr, 'stderr should be wrapped')
 #elf.assertTrue(isinstance(sys.stdout, StreamWrapper),
 #bad stdout wrapper')
 #elf.assertTrue(isinstance(sys.stderr, StreamWrapper),
 #bad stderr wrapper')

 #ef assertNotWrapped(self):
 #elf.assertIs(sys.stdout, orig_stdout, 'stdout should not be wrapped')
 #elf.assertIs(sys.stderr, orig_stderr, 'stderr should not be wrapped')

 #patch('colorama.initialise.reset_all')
 #patch('colorama.ansitowin32.winapi_test', lambda *_: True)
 #patch('colorama.ansitowin32.enable_vt_processing', lambda *_: False)
 #ef testInitWrapsOnWindows(self, _):
 #ith osname("nt"):
 #nit()
 #elf.assertWrapped()

 #patch('colorama.initialise.reset_all')
 #patch('colorama.ansitowin32.winapi_test', lambda *_: False)
 #ef testInitDoesntWrapOnEmulatedWindows(self, _):
 #ith osname("nt"):
 #nit()
 #elf.assertNotWrapped()

 #ef testInitDoesntWrapOnNonWindows(self):
 #ith osname("posix"):
 #nit()
 #elf.assertNotWrapped()

 #ef testInitDoesntWrapIfNone(self):
 #ith replace_by(None):
 #nit()
            # We can't use assertNotWrapped here because replace_by(None)
            # changes stdout/stderr already.
 #elf.assertIsNone(sys.stdout)
 #elf.assertIsNone(sys.stderr)

 #ef testInitAutoresetOnWrapsOnAllPlatforms(self):
 #ith osname("posix"):
 #nit(autoreset=True)
 #elf.assertWrapped()

 #ef testInitWrapOffDoesntWrapOnWindows(self):
 #ith osname("nt"):
 #nit(wrap=False)
 #elf.assertNotWrapped()

 #ef testInitWrapOffIncompatibleWithAutoresetOn(self):
 #elf.assertRaises(ValueError, lambda: init(autoreset=True, wrap=False))

 #patch('colorama.win32.SetConsoleTextAttribute')
 #patch('colorama.initialise.AnsiToWin32')
 #ef testAutoResetPassedOn(self, mockATW32, _):
 #ith osname("nt"):
 #nit(autoreset=True)
 #elf.assertEqual(len(mockATW32.call_args_list), 2)
 #elf.assertEqual(mockATW32.call_args_list[1][1]['autoreset'], True)
 #elf.assertEqual(mockATW32.call_args_list[0][1]['autoreset'], True)

 #patch('colorama.initialise.AnsiToWin32')
 #ef testAutoResetChangeable(self, mockATW32):
 #ith osname("nt"):
 #nit()

 #nit(autoreset=True)
 #elf.assertEqual(len(mockATW32.call_args_list), 4)
 #elf.assertEqual(mockATW32.call_args_list[2][1]['autoreset'], True)
 #elf.assertEqual(mockATW32.call_args_list[3][1]['autoreset'], True)

 #nit()
 #elf.assertEqual(len(mockATW32.call_args_list), 6)
 #elf.assertEqual(
 #ockATW32.call_args_list[4][1]['autoreset'], False)
 #elf.assertEqual(
 #ockATW32.call_args_list[5][1]['autoreset'], False)


 #patch('colorama.initialise.atexit.register')
 #ef testAtexitRegisteredOnlyOnce(self, mockRegister):
 #nit()
 #elf.assertTrue(mockRegister.called)
 #ockRegister.reset_mock()
 #nit()
 #elf.assertFalse(mockRegister.called)


class JustFixWindowsConsoleTest(TestCase):
 #ef _reset(self):
 #wipe_internal_state_for_tests()
 #ys.stdout = orig_stdout
 #ys.stderr = orig_stderr

 #ef tearDown(self):
 #elf._reset()

 #patch("colorama.ansitowin32.winapi_test", lambda: True)
 #ef testJustFixWindowsConsole(self):
 #f sys.platform != "win32":
            # just_fix_windows_console should be a no-op
 #ust_fix_windows_console()
 #elf.assertIs(sys.stdout, orig_stdout)
 #elf.assertIs(sys.stderr, orig_stderr)
 #lse:
 #ef fake_std():
                # Emulate stdout=not a tty, stderr=tty
                # to check that we handle both cases correctly
 #tdout = Mock()
 #tdout.closed = False
 #tdout.isatty.return_value = False
 #tdout.fileno.return_value = 1
 #ys.stdout = stdout

 #tderr = Mock()
 #tderr.closed = False
 #tderr.isatty.return_value = True
 #tderr.fileno.return_value = 2
 #ys.stderr = stderr

 #or native_ansi in [False, True]:
 #ith patch(
 #colorama.ansitowin32.enable_vt_processing',
 #ambda *_: native_ansi
 #:
 #elf._reset()
 #ake_std()

                    # Regular single-call test
 #rev_stdout = sys.stdout
 #rev_stderr = sys.stderr
 #ust_fix_windows_console()
 #elf.assertIs(sys.stdout, prev_stdout)
 #f native_ansi:
 #elf.assertIs(sys.stderr, prev_stderr)
 #lse:
 #elf.assertIsNot(sys.stderr, prev_stderr)

                    # second call without resetting is always a no-op
 #rev_stdout = sys.stdout
 #rev_stderr = sys.stderr
 #ust_fix_windows_console()
 #elf.assertIs(sys.stdout, prev_stdout)
 #elf.assertIs(sys.stderr, prev_stderr)

 #elf._reset()
 #ake_std()

                    # If init() runs first, just_fix_windows_console should be a no-op
 #nit()
 #rev_stdout = sys.stdout
 #rev_stderr = sys.stderr
 #ust_fix_windows_console()
 #elf.assertIs(prev_stdout, sys.stdout)
 #elf.assertIs(prev_stderr, sys.stderr)


if __name__ == '__main__':
 #ain()
