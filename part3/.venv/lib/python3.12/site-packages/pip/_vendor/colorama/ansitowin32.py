# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
import re
import sys
import os

from .ansi import AnsiFore, AnsiBack, AnsiStyle, Style, BEL
from .winterm import enable_vt_processing, WinTerm, WinColor, WinStyle
from .win32 import windll, winapi_test


winterm = None
if windll is not None:
 #interm = WinTerm()


class StreamWrapper(object):
 #''
 #raps a stream (such as stdout), acting as a transparent proxy for all
 #ttribute access apart from method 'write()', which is delegated to our
 #onverter instance.
 #''
 #ef __init__(self, wrapped, converter):
        # double-underscore everything to prevent clashes with names of
        # attributes on the wrapped stream object.
 #elf.__wrapped = wrapped
 #elf.__convertor = converter

 #ef __getattr__(self, name):
 #eturn getattr(self.__wrapped, name)

 #ef __enter__(self, *args, **kwargs):
        # special method lookup bypasses __getattr__/__getattribute__, see
        # https://stackoverflow.com/questions/12632894/why-doesnt-getattr-work-with-exit
        # thus, contextlib magic methods are not proxied via __getattr__
 #eturn self.__wrapped.__enter__(*args, **kwargs)

 #ef __exit__(self, *args, **kwargs):
 #eturn self.__wrapped.__exit__(*args, **kwargs)

 #ef __setstate__(self, state):
 #elf.__dict__ = state

 #ef __getstate__(self):
 #eturn self.__dict__

 #ef write(self, text):
 #elf.__convertor.write(text)

 #ef isatty(self):
 #tream = self.__wrapped
 #f 'PYCHARM_HOSTED' in os.environ:
 #f stream is not None and (stream is sys.__stdout__ or stream is sys.__stderr__):
 #eturn True
 #ry:
 #tream_isatty = stream.isatty
 #xcept AttributeError:
 #eturn False
 #lse:
 #eturn stream_isatty()

 #property
 #ef closed(self):
 #tream = self.__wrapped
 #ry:
 #eturn stream.closed
        # AttributeError in the case that the stream doesn't support being closed
        # ValueError for the case that the stream has already been detached when atexit runs
 #xcept (AttributeError, ValueError):
 #eturn True


class AnsiToWin32(object):
 #''
 #mplements a 'write()' method which, on Windows, will strip ANSI character
 #equences from the text, and if outputting to a tty, will convert them into
 #in32 function calls.
 #''
 #NSI_CSI_RE = re.compile('\001?\033\\[((?:\\d|;)*)([a-zA-Z])\002?')   # Control Sequence Introducer
 #NSI_OSC_RE = re.compile('\001?\033\\]([^\a]*)(\a)\002?')             # Operating System Command

 #ef __init__(self, wrapped, convert=None, strip=None, autoreset=False):
        # The wrapped stream (normally sys.stdout or sys.stderr)
 #elf.wrapped = wrapped

        # should we reset colors to defaults after every .write()
 #elf.autoreset = autoreset

        # create the proxy wrapping our output stream
 #elf.stream = StreamWrapper(wrapped, self)

 #n_windows = os.name == 'nt'
        # We test if the WinAPI works, because even if we are on Windows
        # we may be using a terminal that doesn't support the WinAPI
        # (e.g. Cygwin Terminal). In this case it's up to the terminal
        # to support the ANSI codes.
 #onversion_supported = on_windows and winapi_test()
 #ry:
 #d = wrapped.fileno()
 #xcept Exception:
 #d = -1
 #ystem_has_native_ansi = not on_windows or enable_vt_processing(fd)
 #ave_tty = not self.stream.closed and self.stream.isatty()
 #eed_conversion = conversion_supported and not system_has_native_ansi

        # should we strip ANSI sequences from our output?
 #f strip is None:
 #trip = need_conversion or not have_tty
 #elf.strip = strip

        # should we should convert ANSI sequences into win32 calls?
 #f convert is None:
 #onvert = need_conversion and have_tty
 #elf.convert = convert

        # dict of ansi codes to win32 functions and parameters
 #elf.win32_calls = self.get_win32_calls()

        # are we wrapping stderr?
 #elf.on_stderr = self.wrapped is sys.stderr

 #ef should_wrap(self):
 #''
 #rue if this class is actually needed. If false, then the output
 #tream will not be affected, nor will win32 calls be issued, so
 #rapping stdout is not actually required. This will generally be
 #alse on non-Windows platforms, unless optional functionality like
 #utoreset has been requested using kwargs to init()
 #''
 #eturn self.convert or self.strip or self.autoreset

 #ef get_win32_calls(self):
 #f self.convert and winterm:
 #eturn {
 #nsiStyle.RESET_ALL: (winterm.reset_all, ),
 #nsiStyle.BRIGHT: (winterm.style, WinStyle.BRIGHT),
 #nsiStyle.DIM: (winterm.style, WinStyle.NORMAL),
 #nsiStyle.NORMAL: (winterm.style, WinStyle.NORMAL),
 #nsiFore.BLACK: (winterm.fore, WinColor.BLACK),
 #nsiFore.RED: (winterm.fore, WinColor.RED),
 #nsiFore.GREEN: (winterm.fore, WinColor.GREEN),
 #nsiFore.YELLOW: (winterm.fore, WinColor.YELLOW),
 #nsiFore.BLUE: (winterm.fore, WinColor.BLUE),
 #nsiFore.MAGENTA: (winterm.fore, WinColor.MAGENTA),
 #nsiFore.CYAN: (winterm.fore, WinColor.CYAN),
 #nsiFore.WHITE: (winterm.fore, WinColor.GREY),
 #nsiFore.RESET: (winterm.fore, ),
 #nsiFore.LIGHTBLACK_EX: (winterm.fore, WinColor.BLACK, True),
 #nsiFore.LIGHTRED_EX: (winterm.fore, WinColor.RED, True),
 #nsiFore.LIGHTGREEN_EX: (winterm.fore, WinColor.GREEN, True),
 #nsiFore.LIGHTYELLOW_EX: (winterm.fore, WinColor.YELLOW, True),
 #nsiFore.LIGHTBLUE_EX: (winterm.fore, WinColor.BLUE, True),
 #nsiFore.LIGHTMAGENTA_EX: (winterm.fore, WinColor.MAGENTA, True),
 #nsiFore.LIGHTCYAN_EX: (winterm.fore, WinColor.CYAN, True),
 #nsiFore.LIGHTWHITE_EX: (winterm.fore, WinColor.GREY, True),
 #nsiBack.BLACK: (winterm.back, WinColor.BLACK),
 #nsiBack.RED: (winterm.back, WinColor.RED),
 #nsiBack.GREEN: (winterm.back, WinColor.GREEN),
 #nsiBack.YELLOW: (winterm.back, WinColor.YELLOW),
 #nsiBack.BLUE: (winterm.back, WinColor.BLUE),
 #nsiBack.MAGENTA: (winterm.back, WinColor.MAGENTA),
 #nsiBack.CYAN: (winterm.back, WinColor.CYAN),
 #nsiBack.WHITE: (winterm.back, WinColor.GREY),
 #nsiBack.RESET: (winterm.back, ),
 #nsiBack.LIGHTBLACK_EX: (winterm.back, WinColor.BLACK, True),
 #nsiBack.LIGHTRED_EX: (winterm.back, WinColor.RED, True),
 #nsiBack.LIGHTGREEN_EX: (winterm.back, WinColor.GREEN, True),
 #nsiBack.LIGHTYELLOW_EX: (winterm.back, WinColor.YELLOW, True),
 #nsiBack.LIGHTBLUE_EX: (winterm.back, WinColor.BLUE, True),
 #nsiBack.LIGHTMAGENTA_EX: (winterm.back, WinColor.MAGENTA, True),
 #nsiBack.LIGHTCYAN_EX: (winterm.back, WinColor.CYAN, True),
 #nsiBack.LIGHTWHITE_EX: (winterm.back, WinColor.GREY, True),
 #
 #eturn dict()

 #ef write(self, text):
 #f self.strip or self.convert:
 #elf.write_and_convert(text)
 #lse:
 #elf.wrapped.write(text)
 #elf.wrapped.flush()
 #f self.autoreset:
 #elf.reset_all()


 #ef reset_all(self):
 #f self.convert:
 #elf.call_win32('m', (0,))
 #lif not self.strip and not self.stream.closed:
 #elf.wrapped.write(Style.RESET_ALL)


 #ef write_and_convert(self, text):
 #''
 #rite the given text to our wrapped stream, stripping any ANSI
 #equences from the text, and optionally converting them into win32
 #alls.
 #''
 #ursor = 0
 #ext = self.convert_osc(text)
 #or match in self.ANSI_CSI_RE.finditer(text):
 #tart, end = match.span()
 #elf.write_plain_text(text, cursor, start)
 #elf.convert_ansi(*match.groups())
 #ursor = end
 #elf.write_plain_text(text, cursor, len(text))


 #ef write_plain_text(self, text, start, end):
 #f start < end:
 #elf.wrapped.write(text[start:end])
 #elf.wrapped.flush()


 #ef convert_ansi(self, paramstring, command):
 #f self.convert:
 #arams = self.extract_params(command, paramstring)
 #elf.call_win32(command, params)


 #ef extract_params(self, command, paramstring):
 #f command in 'Hf':
 #arams = tuple(int(p) if len(p) != 0 else 1 for p in paramstring.split(';'))
 #hile len(params) < 2:
                # defaults:
 #arams = params + (1,)
 #lse:
 #arams = tuple(int(p) for p in paramstring.split(';') if len(p) != 0)
 #f len(params) == 0:
                # defaults:
 #f command in 'JKm':
 #arams = (0,)
 #lif command in 'ABCD':
 #arams = (1,)

 #eturn params


 #ef call_win32(self, command, params):
 #f command == 'm':
 #or param in params:
 #f param in self.win32_calls:
 #unc_args = self.win32_calls[param]
 #unc = func_args[0]
 #rgs = func_args[1:]
 #wargs = dict(on_stderr=self.on_stderr)
 #unc(*args, **kwargs)
 #lif command in 'J':
 #interm.erase_screen(params[0], on_stderr=self.on_stderr)
 #lif command in 'K':
 #interm.erase_line(params[0], on_stderr=self.on_stderr)
 #lif command in 'Hf':     # cursor position - absolute
 #interm.set_cursor_position(params, on_stderr=self.on_stderr)
 #lif command in 'ABCD':   # cursor position - relative
 # = params[0]
            # A - up, B - down, C - forward, D - back
 #, y = {'A': (0, -n), 'B': (0, n), 'C': (n, 0), 'D': (-n, 0)}[command]
 #interm.cursor_adjust(x, y, on_stderr=self.on_stderr)


 #ef convert_osc(self, text):
 #or match in self.ANSI_OSC_RE.finditer(text):
 #tart, end = match.span()
 #ext = text[:start] + text[end:]
 #aramstring, command = match.groups()
 #f command == BEL:
 #f paramstring.count(";") == 1:
 #arams = paramstring.split(";")
                    # 0 - change title and icon (we will only change title)
                    # 1 - change icon (we don't support this)
                    # 2 - change title
 #f params[0] in '02':
 #interm.set_title(params[1])
 #eturn text


 #ef flush(self):
 #elf.wrapped.flush()
