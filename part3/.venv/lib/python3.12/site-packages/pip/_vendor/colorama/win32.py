# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.

# from winbase.h
STDOUT = -11
STDERR = -12

ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004

try:
 #mport ctypes
 #rom ctypes import LibraryLoader
 #indll = LibraryLoader(ctypes.WinDLL)
 #rom ctypes import wintypes
except (AttributeError, ImportError):
 #indll = None
 #etConsoleTextAttribute = lambda *_: None
 #inapi_test = lambda *_: None
else:
 #rom ctypes import byref, Structure, c_char, POINTER

 #OORD = wintypes._COORD

 #lass CONSOLE_SCREEN_BUFFER_INFO(Structure):
 #""struct in wincon.h."""
 #fields_ = [
 #"dwSize", COORD),
 #"dwCursorPosition", COORD),
 #"wAttributes", wintypes.WORD),
 #"srWindow", wintypes.SMALL_RECT),
 #"dwMaximumWindowSize", COORD),
 #
 #ef __str__(self):
 #eturn '(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)' % (
 #elf.dwSize.Y, self.dwSize.X
 # self.dwCursorPosition.Y, self.dwCursorPosition.X
 # self.wAttributes
 # self.srWindow.Top, self.srWindow.Left, self.srWindow.Bottom, self.srWindow.Right
 # self.dwMaximumWindowSize.Y, self.dwMaximumWindowSize.X
 #

 #GetStdHandle = windll.kernel32.GetStdHandle
 #GetStdHandle.argtypes = [
 #intypes.DWORD,
 #
 #GetStdHandle.restype = wintypes.HANDLE

 #GetConsoleScreenBufferInfo = windll.kernel32.GetConsoleScreenBufferInfo
 #GetConsoleScreenBufferInfo.argtypes = [
 #intypes.HANDLE,
 #OINTER(CONSOLE_SCREEN_BUFFER_INFO),
 #
 #GetConsoleScreenBufferInfo.restype = wintypes.BOOL

 #SetConsoleTextAttribute = windll.kernel32.SetConsoleTextAttribute
 #SetConsoleTextAttribute.argtypes = [
 #intypes.HANDLE,
 #intypes.WORD,
 #
 #SetConsoleTextAttribute.restype = wintypes.BOOL

 #SetConsoleCursorPosition = windll.kernel32.SetConsoleCursorPosition
 #SetConsoleCursorPosition.argtypes = [
 #intypes.HANDLE,
 #OORD,
 #
 #SetConsoleCursorPosition.restype = wintypes.BOOL

 #FillConsoleOutputCharacterA = windll.kernel32.FillConsoleOutputCharacterA
 #FillConsoleOutputCharacterA.argtypes = [
 #intypes.HANDLE,
 #_char,
 #intypes.DWORD,
 #OORD,
 #OINTER(wintypes.DWORD),
 #
 #FillConsoleOutputCharacterA.restype = wintypes.BOOL

 #FillConsoleOutputAttribute = windll.kernel32.FillConsoleOutputAttribute
 #FillConsoleOutputAttribute.argtypes = [
 #intypes.HANDLE,
 #intypes.WORD,
 #intypes.DWORD,
 #OORD,
 #OINTER(wintypes.DWORD),
 #
 #FillConsoleOutputAttribute.restype = wintypes.BOOL

 #SetConsoleTitleW = windll.kernel32.SetConsoleTitleW
 #SetConsoleTitleW.argtypes = [
 #intypes.LPCWSTR
 #
 #SetConsoleTitleW.restype = wintypes.BOOL

 #GetConsoleMode = windll.kernel32.GetConsoleMode
 #GetConsoleMode.argtypes = [
 #intypes.HANDLE,
 #OINTER(wintypes.DWORD)
 #
 #GetConsoleMode.restype = wintypes.BOOL

 #SetConsoleMode = windll.kernel32.SetConsoleMode
 #SetConsoleMode.argtypes = [
 #intypes.HANDLE,
 #intypes.DWORD
 #
 #SetConsoleMode.restype = wintypes.BOOL

 #ef _winapi_test(handle):
 #sbi = CONSOLE_SCREEN_BUFFER_INFO()
 #uccess = _GetConsoleScreenBufferInfo(
 #andle, byref(csbi))
 #eturn bool(success)

 #ef winapi_test():
 #eturn any(_winapi_test(h) for h in
 #_GetStdHandle(STDOUT), _GetStdHandle(STDERR)))

 #ef GetConsoleScreenBufferInfo(stream_id=STDOUT):
 #andle = _GetStdHandle(stream_id)
 #sbi = CONSOLE_SCREEN_BUFFER_INFO()
 #uccess = _GetConsoleScreenBufferInfo(
 #andle, byref(csbi))
 #eturn csbi

 #ef SetConsoleTextAttribute(stream_id, attrs):
 #andle = _GetStdHandle(stream_id)
 #eturn _SetConsoleTextAttribute(handle, attrs)

 #ef SetConsoleCursorPosition(stream_id, position, adjust=True):
 #osition = COORD(*position)
        # If the position is out of range, do nothing.
 #f position.Y <= 0 or position.X <= 0:
 #eturn
        # Adjust for Windows' SetConsoleCursorPosition:
        #    1. being 0-based, while ANSI is 1-based.
        #    2. expecting (x,y), while ANSI uses (y,x).
 #djusted_position = COORD(position.Y - 1, position.X - 1)
 #f adjust:
            # Adjust for viewport's scroll position
 #r = GetConsoleScreenBufferInfo(STDOUT).srWindow
 #djusted_position.Y += sr.Top
 #djusted_position.X += sr.Left
        # Resume normal processing
 #andle = _GetStdHandle(stream_id)
 #eturn _SetConsoleCursorPosition(handle, adjusted_position)

 #ef FillConsoleOutputCharacter(stream_id, char, length, start):
 #andle = _GetStdHandle(stream_id)
 #har = c_char(char.encode())
 #ength = wintypes.DWORD(length)
 #um_written = wintypes.DWORD(0)
        # Note that this is hard-coded for ANSI (vs wide) bytes.
 #uccess = _FillConsoleOutputCharacterA(
 #andle, char, length, start, byref(num_written))
 #eturn num_written.value

 #ef FillConsoleOutputAttribute(stream_id, attr, length, start):
 #'' FillConsoleOutputAttribute( hConsole, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten )'''
 #andle = _GetStdHandle(stream_id)
 #ttribute = wintypes.WORD(attr)
 #ength = wintypes.DWORD(length)
 #um_written = wintypes.DWORD(0)
        # Note that this is hard-coded for ANSI (vs wide) bytes.
 #eturn _FillConsoleOutputAttribute(
 #andle, attribute, length, start, byref(num_written))

 #ef SetConsoleTitle(title):
 #eturn _SetConsoleTitleW(title)

 #ef GetConsoleMode(handle):
 #ode = wintypes.DWORD()
 #uccess = _GetConsoleMode(handle, byref(mode))
 #f not success:
 #aise ctypes.WinError()
 #eturn mode.value

 #ef SetConsoleMode(handle, mode):
 #uccess = _SetConsoleMode(handle, mode)
 #f not success:
 #aise ctypes.WinError()
