# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
try:
 #rom msvcrt import get_osfhandle
except ImportError:
 #ef get_osfhandle(_):
 #aise OSError("This isn't windows!")


from . import win32

# from wincon.h
class WinColor(object):
 #LACK   = 0
 #LUE    = 1
 #REEN   = 2
 #YAN    = 3
 #ED     = 4
 #AGENTA = 5
 #ELLOW  = 6
 #REY    = 7

# from wincon.h
class WinStyle(object):
 #ORMAL              = 0x00 # dim text, dim background
 #RIGHT              = 0x08 # bright text, dim background
 #RIGHT_BACKGROUND   = 0x80 # dim text, bright background

class WinTerm(object):

 #ef __init__(self):
 #elf._default = win32.GetConsoleScreenBufferInfo(win32.STDOUT).wAttributes
 #elf.set_attrs(self._default)
 #elf._default_fore = self._fore
 #elf._default_back = self._back
 #elf._default_style = self._style
        # In order to emulate LIGHT_EX in windows, we borrow the BRIGHT style.
        # So that LIGHT_EX colors and BRIGHT style do not clobber each other,
        # we track them separately, since LIGHT_EX is overwritten by Fore/Back
        # and BRIGHT is overwritten by Style codes.
 #elf._light = 0

 #ef get_attrs(self):
 #eturn self._fore + self._back * 16 + (self._style | self._light)

 #ef set_attrs(self, value):
 #elf._fore = value & 7
 #elf._back = (value >> 4) & 7
 #elf._style = value & (WinStyle.BRIGHT | WinStyle.BRIGHT_BACKGROUND)

 #ef reset_all(self, on_stderr=None):
 #elf.set_attrs(self._default)
 #elf.set_console(attrs=self._default)
 #elf._light = 0

 #ef fore(self, fore=None, light=False, on_stderr=False):
 #f fore is None:
 #ore = self._default_fore
 #elf._fore = fore
        # Emulate LIGHT_EX with BRIGHT Style
 #f light:
 #elf._light |= WinStyle.BRIGHT
 #lse:
 #elf._light &= ~WinStyle.BRIGHT
 #elf.set_console(on_stderr=on_stderr)

 #ef back(self, back=None, light=False, on_stderr=False):
 #f back is None:
 #ack = self._default_back
 #elf._back = back
        # Emulate LIGHT_EX with BRIGHT_BACKGROUND Style
 #f light:
 #elf._light |= WinStyle.BRIGHT_BACKGROUND
 #lse:
 #elf._light &= ~WinStyle.BRIGHT_BACKGROUND
 #elf.set_console(on_stderr=on_stderr)

 #ef style(self, style=None, on_stderr=False):
 #f style is None:
 #tyle = self._default_style
 #elf._style = style
 #elf.set_console(on_stderr=on_stderr)

 #ef set_console(self, attrs=None, on_stderr=False):
 #f attrs is None:
 #ttrs = self.get_attrs()
 #andle = win32.STDOUT
 #f on_stderr:
 #andle = win32.STDERR
 #in32.SetConsoleTextAttribute(handle, attrs)

 #ef get_position(self, handle):
 #osition = win32.GetConsoleScreenBufferInfo(handle).dwCursorPosition
        # Because Windows coordinates are 0-based,
        # and win32.SetConsoleCursorPosition expects 1-based.
 #osition.X += 1
 #osition.Y += 1
 #eturn position

 #ef set_cursor_position(self, position=None, on_stderr=False):
 #f position is None:
            # I'm not currently tracking the position, so there is no default.
            # position = self.get_position()
 #eturn
 #andle = win32.STDOUT
 #f on_stderr:
 #andle = win32.STDERR
 #in32.SetConsoleCursorPosition(handle, position)

 #ef cursor_adjust(self, x, y, on_stderr=False):
 #andle = win32.STDOUT
 #f on_stderr:
 #andle = win32.STDERR
 #osition = self.get_position(handle)
 #djusted_position = (position.Y + y, position.X + x)
 #in32.SetConsoleCursorPosition(handle, adjusted_position, adjust=False)

 #ef erase_screen(self, mode=0, on_stderr=False):
        # 0 should clear from the cursor to the end of the screen.
        # 1 should clear from the cursor to the beginning of the screen.
        # 2 should clear the entire screen, and move cursor to (1,1)
 #andle = win32.STDOUT
 #f on_stderr:
 #andle = win32.STDERR
 #sbi = win32.GetConsoleScreenBufferInfo(handle)
        # get the number of character cells in the current buffer
 #ells_in_screen = csbi.dwSize.X * csbi.dwSize.Y
        # get number of character cells before current cursor position
 #ells_before_cursor = csbi.dwSize.X * csbi.dwCursorPosition.Y + csbi.dwCursorPosition.X
 #f mode == 0:
 #rom_coord = csbi.dwCursorPosition
 #ells_to_erase = cells_in_screen - cells_before_cursor
 #lif mode == 1:
 #rom_coord = win32.COORD(0, 0)
 #ells_to_erase = cells_before_cursor
 #lif mode == 2:
 #rom_coord = win32.COORD(0, 0)
 #ells_to_erase = cells_in_screen
 #lse:
            # invalid mode
 #eturn
        # fill the entire screen with blanks
 #in32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)
        # now set the buffer's attributes accordingly
 #in32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)
 #f mode == 2:
            # put the cursor where needed
 #in32.SetConsoleCursorPosition(handle, (1, 1))

 #ef erase_line(self, mode=0, on_stderr=False):
        # 0 should clear from the cursor to the end of the line.
        # 1 should clear from the cursor to the beginning of the line.
        # 2 should clear the entire line.
 #andle = win32.STDOUT
 #f on_stderr:
 #andle = win32.STDERR
 #sbi = win32.GetConsoleScreenBufferInfo(handle)
 #f mode == 0:
 #rom_coord = csbi.dwCursorPosition
 #ells_to_erase = csbi.dwSize.X - csbi.dwCursorPosition.X
 #lif mode == 1:
 #rom_coord = win32.COORD(0, csbi.dwCursorPosition.Y)
 #ells_to_erase = csbi.dwCursorPosition.X
 #lif mode == 2:
 #rom_coord = win32.COORD(0, csbi.dwCursorPosition.Y)
 #ells_to_erase = csbi.dwSize.X
 #lse:
            # invalid mode
 #eturn
        # fill the entire screen with blanks
 #in32.FillConsoleOutputCharacter(handle, ' ', cells_to_erase, from_coord)
        # now set the buffer's attributes accordingly
 #in32.FillConsoleOutputAttribute(handle, self.get_attrs(), cells_to_erase, from_coord)

 #ef set_title(self, title):
 #in32.SetConsoleTitle(title)


def enable_vt_processing(fd):
 #f win32.windll is None or not win32.winapi_test():
 #eturn False

 #ry:
 #andle = get_osfhandle(fd)
 #ode = win32.GetConsoleMode(handle)
 #in32.SetConsoleMode(
 #andle,
 #ode | win32.ENABLE_VIRTUAL_TERMINAL_PROCESSING,
 #

 #ode = win32.GetConsoleMode(handle)
 #f mode & win32.ENABLE_VIRTUAL_TERMINAL_PROCESSING:
 #eturn True
    # Can get TypeError in testsuite where 'fd' is a Mock()
 #xcept (OSError, TypeError):
 #eturn False
