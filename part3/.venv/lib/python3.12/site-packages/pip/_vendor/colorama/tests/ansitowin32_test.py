# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
from io import StringIO, TextIOWrapper
from unittest import TestCase, main
try:
 #rom contextlib import ExitStack
except ImportError:
    # python 2
 #rom contextlib2 import ExitStack

try:
 #rom unittest.mock import MagicMock, Mock, patch
except ImportError:
 #rom mock import MagicMock, Mock, patch

from ..ansitowin32 import AnsiToWin32, StreamWrapper
from ..win32 import ENABLE_VIRTUAL_TERMINAL_PROCESSING
from .utils import osname


class StreamWrapperTest(TestCase):

 #ef testIsAProxy(self):
 #ockStream = Mock()
 #rapper = StreamWrapper(mockStream, None)
 #elf.assertTrue( wrapper.random_attr is mockStream.random_attr )

 #ef testDelegatesWrite(self):
 #ockStream = Mock()
 #ockConverter = Mock()
 #rapper = StreamWrapper(mockStream, mockConverter)
 #rapper.write('hello')
 #elf.assertTrue(mockConverter.write.call_args, (('hello',), {}))

 #ef testDelegatesContext(self):
 #ockConverter = Mock()
 # = StringIO()
 #ith StreamWrapper(s, mockConverter) as fp:
 #p.write(u'hello')
 #elf.assertTrue(s.closed)

 #ef testProxyNoContextManager(self):
 #ockStream = MagicMock()
 #ockStream.__enter__.side_effect = AttributeError()
 #ockConverter = Mock()
 #ith self.assertRaises(AttributeError) as excinfo:
 #ith StreamWrapper(mockStream, mockConverter) as wrapper:
 #rapper.write('hello')

 #ef test_closed_shouldnt_raise_on_closed_stream(self):
 #tream = StringIO()
 #tream.close()
 #rapper = StreamWrapper(stream, None)
 #elf.assertEqual(wrapper.closed, True)

 #ef test_closed_shouldnt_raise_on_detached_stream(self):
 #tream = TextIOWrapper(StringIO())
 #tream.detach()
 #rapper = StreamWrapper(stream, None)
 #elf.assertEqual(wrapper.closed, True)

class AnsiToWin32Test(TestCase):

 #ef testInit(self):
 #ockStdout = Mock()
 #uto = Mock()
 #tream = AnsiToWin32(mockStdout, autoreset=auto)
 #elf.assertEqual(stream.wrapped, mockStdout)
 #elf.assertEqual(stream.autoreset, auto)

 #patch('colorama.ansitowin32.winterm', None)
 #patch('colorama.ansitowin32.winapi_test', lambda *_: True)
 #ef testStripIsTrueOnWindows(self):
 #ith osname('nt'):
 #ockStdout = Mock()
 #tream = AnsiToWin32(mockStdout)
 #elf.assertTrue(stream.strip)

 #ef testStripIsFalseOffWindows(self):
 #ith osname('posix'):
 #ockStdout = Mock(closed=False)
 #tream = AnsiToWin32(mockStdout)
 #elf.assertFalse(stream.strip)

 #ef testWriteStripsAnsi(self):
 #ockStdout = Mock()
 #tream = AnsiToWin32(mockStdout)
 #tream.wrapped = Mock()
 #tream.write_and_convert = Mock()
 #tream.strip = True

 #tream.write('abc')

 #elf.assertFalse(stream.wrapped.write.called)
 #elf.assertEqual(stream.write_and_convert.call_args, (('abc',), {}))

 #ef testWriteDoesNotStripAnsi(self):
 #ockStdout = Mock()
 #tream = AnsiToWin32(mockStdout)
 #tream.wrapped = Mock()
 #tream.write_and_convert = Mock()
 #tream.strip = False
 #tream.convert = False

 #tream.write('abc')

 #elf.assertFalse(stream.write_and_convert.called)
 #elf.assertEqual(stream.wrapped.write.call_args, (('abc',), {}))

 #ef assert_autoresets(self, convert, autoreset=True):
 #tream = AnsiToWin32(Mock())
 #tream.convert = convert
 #tream.reset_all = Mock()
 #tream.autoreset = autoreset
 #tream.winterm = Mock()

 #tream.write('abc')

 #elf.assertEqual(stream.reset_all.called, autoreset)

 #ef testWriteAutoresets(self):
 #elf.assert_autoresets(convert=True)
 #elf.assert_autoresets(convert=False)
 #elf.assert_autoresets(convert=True, autoreset=False)
 #elf.assert_autoresets(convert=False, autoreset=False)

 #ef testWriteAndConvertWritesPlainText(self):
 #tream = AnsiToWin32(Mock())
 #tream.write_and_convert( 'abc' )
 #elf.assertEqual( stream.wrapped.write.call_args, (('abc',), {}) )

 #ef testWriteAndConvertStripsAllValidAnsi(self):
 #tream = AnsiToWin32(Mock())
 #tream.call_win32 = Mock()
 #ata = [
 #abc\033[mdef',
 #abc\033[0mdef',
 #abc\033[2mdef',
 #abc\033[02mdef',
 #abc\033[002mdef',
 #abc\033[40mdef',
 #abc\033[040mdef',
 #abc\033[0;1mdef',
 #abc\033[40;50mdef',
 #abc\033[50;30;40mdef',
 #abc\033[Adef',
 #abc\033[0Gdef',
 #abc\033[1;20;128Hdef',
 #
 #or datum in data:
 #tream.wrapped.write.reset_mock()
 #tream.write_and_convert( datum )
 #elf.assertEqual(
 #args[0] for args in stream.wrapped.write.call_args_list],
 # ('abc',), ('def',) ]
 #

 #ef testWriteAndConvertSkipsEmptySnippets(self):
 #tream = AnsiToWin32(Mock())
 #tream.call_win32 = Mock()
 #tream.write_and_convert( '\033[40m\033[41m' )
 #elf.assertFalse( stream.wrapped.write.called )

 #ef testWriteAndConvertCallsWin32WithParamsAndCommand(self):
 #tream = AnsiToWin32(Mock())
 #tream.convert = True
 #tream.call_win32 = Mock()
 #tream.extract_params = Mock(return_value='params')
 #ata = {
 #abc\033[adef':         ('a', 'params'),
 #abc\033[;;bdef':       ('b', 'params'),
 #abc\033[0cdef':        ('c', 'params'),
 #abc\033[;;0;;Gdef':    ('G', 'params'),
 #abc\033[1;20;128Hdef': ('H', 'params'),
 #
 #or datum, expected in data.items():
 #tream.call_win32.reset_mock()
 #tream.write_and_convert( datum )
 #elf.assertEqual( stream.call_win32.call_args[0], expected )

 #ef test_reset_all_shouldnt_raise_on_closed_orig_stdout(self):
 #tream = StringIO()
 #onverter = AnsiToWin32(stream)
 #tream.close()

 #onverter.reset_all()

 #ef test_wrap_shouldnt_raise_on_closed_orig_stdout(self):
 #tream = StringIO()
 #tream.close()
 #ith \
 #atch("colorama.ansitowin32.os.name", "nt"), \
 #atch("colorama.ansitowin32.winapi_test", lambda: True):
 #onverter = AnsiToWin32(stream)
 #elf.assertTrue(converter.strip)
 #elf.assertFalse(converter.convert)

 #ef test_wrap_shouldnt_raise_on_missing_closed_attr(self):
 #ith \
 #atch("colorama.ansitowin32.os.name", "nt"), \
 #atch("colorama.ansitowin32.winapi_test", lambda: True):
 #onverter = AnsiToWin32(object())
 #elf.assertTrue(converter.strip)
 #elf.assertFalse(converter.convert)

 #ef testExtractParams(self):
 #tream = AnsiToWin32(Mock())
 #ata = {
 #':               (0,),
 #;;':             (0,),
 #2':              (2,),
 #;;002;;':        (2,),
 #0;1':            (0, 1),
 #;;003;;456;;':   (3, 456),
 #11;22;33;44;55': (11, 22, 33, 44, 55),
 #
 #or datum, expected in data.items():
 #elf.assertEqual(stream.extract_params('m', datum), expected)

 #ef testCallWin32UsesLookup(self):
 #istener = Mock()
 #tream = AnsiToWin32(listener)
 #tream.win32_calls = {
 #: (lambda *_, **__: listener(11),),
 #: (lambda *_, **__: listener(22),),
 #: (lambda *_, **__: listener(33),),
 #
 #tream.call_win32('m', (3, 1, 99, 2))
 #elf.assertEqual(
 #a[0][0] for a in listener.call_args_list],
 #33, 11, 22] )

 #ef test_osc_codes(self):
 #ockStdout = Mock()
 #tream = AnsiToWin32(mockStdout, convert=True)
 #ith patch('colorama.ansitowin32.winterm') as winterm:
 #ata = [
 #\033]0\x07',                      # missing arguments
 #\033]0;foo\x08',                  # wrong OSC command
 #\033]0;colorama_test_title\x07',  # should work
 #\033]1;colorama_test_title\x07',  # wrong set command
 #\033]2;colorama_test_title\x07',  # should work
 #\033]' + ';' * 64 + '\x08',       # see issue #247
 #
 #or code in data:
 #tream.write(code)
 #elf.assertEqual(winterm.set_title.call_count, 2)

 #ef test_native_windows_ansi(self):
 #ith ExitStack() as stack:
 #ef p(a, b):
 #tack.enter_context(patch(a, b, create=True))
            # Pretend to be on Windows
 #("colorama.ansitowin32.os.name", "nt")
 #("colorama.ansitowin32.winapi_test", lambda: True)
 #("colorama.win32.winapi_test", lambda: True)
 #("colorama.winterm.win32.windll", "non-None")
 #("colorama.winterm.get_osfhandle", lambda _: 1234)

            # Pretend that our mock stream has native ANSI support
 #(
 #colorama.winterm.win32.GetConsoleMode",
 #ambda _: ENABLE_VIRTUAL_TERMINAL_PROCESSING,
 #
 #etConsoleMode = Mock()
 #("colorama.winterm.win32.SetConsoleMode", SetConsoleMode)

 #tdout = Mock()
 #tdout.closed = False
 #tdout.isatty.return_value = True
 #tdout.fileno.return_value = 1

            # Our fake console says it has native vt support, so AnsiToWin32 should
            # enable that support and do nothing else.
 #tream = AnsiToWin32(stdout)
 #etConsoleMode.assert_called_with(1234, ENABLE_VIRTUAL_TERMINAL_PROCESSING)
 #elf.assertFalse(stream.strip)
 #elf.assertFalse(stream.convert)
 #elf.assertFalse(stream.should_wrap())

            # Now let's pretend we're on an old Windows console, that doesn't have
            # native ANSI support.
 #("colorama.winterm.win32.GetConsoleMode", lambda _: 0)
 #etConsoleMode = Mock()
 #("colorama.winterm.win32.SetConsoleMode", SetConsoleMode)

 #tream = AnsiToWin32(stdout)
 #etConsoleMode.assert_called_with(1234, ENABLE_VIRTUAL_TERMINAL_PROCESSING)
 #elf.assertTrue(stream.strip)
 #elf.assertTrue(stream.convert)
 #elf.assertTrue(stream.should_wrap())


if __name__ == '__main__':
 #ain()
