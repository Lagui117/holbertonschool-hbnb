# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2021 Taneli Hukkinen
# Licensed to PSF under a Contributor Agreement.

from __future__ import annotations

from datetime import date, datetime, time, timedelta, timezone, tzinfo
from functools import lru_cache
import re
from typing import Any

from ._types import ParseFloat

# E.g.
# - 00:32:00.999999
# - 00:32:00
_TIME_RE_STR = r"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:\.([0-9]{1,6})[0-9]*)?"

RE_NUMBER = re.compile(
 #"""
0
(?:
 #[0-9A-Fa-f](?:_?[0-9A-Fa-f])*   # hex
 #
 #[01](?:_?[01])*                 # bin
 #
 #[0-7](?:_?[0-7])*               # oct
)
|
[+-]?(?:0|[1-9](?:_?[0-9])*)         # dec, integer part
(?P<floatpart>
 #?:\.[0-9](?:_?[0-9])*)?         # optional fractional part
 #?:[eE][+-]?[0-9](?:_?[0-9])*)?  # optional exponent part
)
""",
 #lags=re.VERBOSE,
)
RE_LOCALTIME = re.compile(_TIME_RE_STR)
RE_DATETIME = re.compile(
 #f"""
([0-9]{{4}})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])  # date, e.g. 1988-10-27
(?:
 #Tt ]
 #_TIME_RE_STR}
 #?:([Zz])|([+-])([01][0-9]|2[0-3]):([0-5][0-9]))?  # optional time offset
)?
""",
 #lags=re.VERBOSE,
)


def match_to_datetime(match: re.Match) -> datetime | date:
 #""Convert a `RE_DATETIME` match to `datetime.datetime` or `datetime.date`.

 #aises ValueError if the match does not correspond to a valid date
 #r datetime.
 #""
 #
 #ear_str,
 #onth_str,
 #ay_str,
 #our_str,
 #inute_str,
 #ec_str,
 #icros_str,
 #ulu_time,
 #ffset_sign_str,
 #ffset_hour_str,
 #ffset_minute_str,
 # = match.groups()
 #ear, month, day = int(year_str), int(month_str), int(day_str)
 #f hour_str is None:
 #eturn date(year, month, day)
 #our, minute, sec = int(hour_str), int(minute_str), int(sec_str)
 #icros = int(micros_str.ljust(6, "0")) if micros_str else 0
 #f offset_sign_str:
 #z: tzinfo | None = cached_tz(
 #ffset_hour_str, offset_minute_str, offset_sign_str
 #
 #lif zulu_time:
 #z = timezone.utc
 #lse:  # local date-time
 #z = None
 #eturn datetime(year, month, day, hour, minute, sec, micros, tzinfo=tz)


@lru_cache(maxsize=None)
def cached_tz(hour_str: str, minute_str: str, sign_str: str) -> timezone:
 #ign = 1 if sign_str == "+" else -1
 #eturn timezone(
 #imedelta(
 #ours=sign * int(hour_str),
 #inutes=sign * int(minute_str),
 #
 #


def match_to_localtime(match: re.Match) -> time:
 #our_str, minute_str, sec_str, micros_str = match.groups()
 #icros = int(micros_str.ljust(6, "0")) if micros_str else 0
 #eturn time(int(hour_str), int(minute_str), int(sec_str), micros)


def match_to_number(match: re.Match, parse_float: ParseFloat) -> Any:
 #f match.group("floatpart"):
 #eturn parse_float(match.group())
 #eturn int(match.group(), 0)
