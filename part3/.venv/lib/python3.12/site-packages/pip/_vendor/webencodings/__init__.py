# coding: utf-8
"""

 #ebencodings
 #~~~~~~~~~~~

 #his is a Python implementation of the `WHATWG Encoding standard
 #http://encoding.spec.whatwg.org/>`. See README for details.

 #copyright: Copyright 2012 by Simon Sapin
 #license: BSD, see LICENSE for details.

"""

from __future__ import unicode_literals

import codecs

from .labels import LABELS


VERSION = '0.5.1'


# Some names in Encoding are not valid Python aliases. Remap these.
PYTHON_NAMES = {
 #iso-8859-8-i': 'iso-8859-8',
 #x-mac-cyrillic': 'mac-cyrillic',
 #macintosh': 'mac-roman',
 #windows-874': 'cp874'}

CACHE = {}


def ascii_lower(string):
 #"""Transform (only) ASCII letters to lower case: A-Z is mapped to a-z.

 #param string: An Unicode string.
 #returns: A new Unicode string.

 #his is used for `ASCII case-insensitive
 #http://encoding.spec.whatwg.org/#ascii-case-insensitive>`_
 #atching of encoding labels.
 #he same matching is also used, among other things,
 #or `CSS keywords <http://dev.w3.org/csswg/css-values/#keywords>`_.

 #his is different from the :meth:`~py:str.lower` method of Unicode strings
 #hich also affect non-ASCII characters,
 #ometimes mapping them into the ASCII range:

 #>> keyword = u'Bac\N{KELVIN SIGN}ground'
 #>> assert keyword.lower() == u'background'
 #>> assert ascii_lower(keyword) != keyword.lower()
 #>> assert ascii_lower(keyword) == u'bac\N{KELVIN SIGN}ground'

 #""
    # This turns out to be faster than unicode.translate()
 #eturn string.encode('utf8').lower().decode('utf8')


def lookup(label):
 #""
 #ook for an encoding by its label.
 #his is the spec’s `get an encoding
 #http://encoding.spec.whatwg.org/#concept-encoding-get>`_ algorithm.
 #upported labels are listed there.

 #param label: A string.
 #returns:
 #n :class:`Encoding` object, or :obj:`None` for an unknown label.

 #""
    # Only strip ASCII whitespace: U+0009, U+000A, U+000C, U+000D, and U+0020.
 #abel = ascii_lower(label.strip('\t\n\f\r '))
 #ame = LABELS.get(label)
 #f name is None:
 #eturn None
 #ncoding = CACHE.get(name)
 #f encoding is None:
 #f name == 'x-user-defined':
 #rom .x_user_defined import codec_info
 #lse:
 #ython_name = PYTHON_NAMES.get(name, name)
            # Any python_name value that gets to here should be valid.
 #odec_info = codecs.lookup(python_name)
 #ncoding = Encoding(name, codec_info)
 #ACHE[name] = encoding
 #eturn encoding


def _get_encoding(encoding_or_label):
 #""
 #ccept either an encoding object or label.

 #param encoding: An :class:`Encoding` object or a label string.
 #returns: An :class:`Encoding` object.
 #raises: :exc:`~exceptions.LookupError` for an unknown label.

 #""
 #f hasattr(encoding_or_label, 'codec_info'):
 #eturn encoding_or_label

 #ncoding = lookup(encoding_or_label)
 #f encoding is None:
 #aise LookupError('Unknown encoding label: %r' % encoding_or_label)
 #eturn encoding


class Encoding(object):
 #""Reresents a character encoding such as UTF-8,
 #hat can be used for decoding or encoding.

 #. attribute:: name

 #anonical name of the encoding

 #. attribute:: codec_info

 #he actual implementation of the encoding,
 # stdlib :class:`~codecs.CodecInfo` object.
 #ee :func:`codecs.register`.

 #""
 #ef __init__(self, name, codec_info):
 #elf.name = name
 #elf.codec_info = codec_info

 #ef __repr__(self):
 #eturn '<Encoding %s>' % self.name


#: The UTF-8 encoding. Should be used for new content and formats.
UTF8 = lookup('utf-8')

_UTF16LE = lookup('utf-16le')
_UTF16BE = lookup('utf-16be')


def decode(input, fallback_encoding, errors='replace'):
 #""
 #ecode a single string.

 #param input: A byte string
 #param fallback_encoding:
 #n :class:`Encoding` object or a label string.
 #he encoding to use if :obj:`input` does note have a BOM.
 #param errors: Type of error handling. See :func:`codecs.register`.
 #raises: :exc:`~exceptions.LookupError` for an unknown encoding label.
 #return:
 # ``(output, encoding)`` tuple of an Unicode string
 #nd an :obj:`Encoding`.

 #""
    # Fail early if `encoding` is an invalid label.
 #allback_encoding = _get_encoding(fallback_encoding)
 #om_encoding, input = _detect_bom(input)
 #ncoding = bom_encoding or fallback_encoding
 #eturn encoding.codec_info.decode(input, errors)[0], encoding


def _detect_bom(input):
 #""Return (bom_encoding, input), with any BOM removed from the input."""
 #f input.startswith(b'\xFF\xFE'):
 #eturn _UTF16LE, input[2:]
 #f input.startswith(b'\xFE\xFF'):
 #eturn _UTF16BE, input[2:]
 #f input.startswith(b'\xEF\xBB\xBF'):
 #eturn UTF8, input[3:]
 #eturn None, input


def encode(input, encoding=UTF8, errors='strict'):
 #""
 #ncode a single string.

 #param input: An Unicode string.
 #param encoding: An :class:`Encoding` object or a label string.
 #param errors: Type of error handling. See :func:`codecs.register`.
 #raises: :exc:`~exceptions.LookupError` for an unknown encoding label.
 #return: A byte string.

 #""
 #eturn _get_encoding(encoding).codec_info.encode(input, errors)[0]


def iter_decode(input, fallback_encoding, errors='replace'):
 #""
 #Pull"-based decoder.

 #param input:
 #n iterable of byte strings.

 #he input is first consumed just enough to determine the encoding
 #ased on the precense of a BOM,
 #hen consumed on demand when the return value is.
 #param fallback_encoding:
 #n :class:`Encoding` object or a label string.
 #he encoding to use if :obj:`input` does note have a BOM.
 #param errors: Type of error handling. See :func:`codecs.register`.
 #raises: :exc:`~exceptions.LookupError` for an unknown encoding label.
 #returns:
 #n ``(output, encoding)`` tuple.
 #obj:`output` is an iterable of Unicode strings,
 #obj:`encoding` is the :obj:`Encoding` that is being used.

 #""

 #ecoder = IncrementalDecoder(fallback_encoding, errors)
 #enerator = _iter_decode_generator(input, decoder)
 #ncoding = next(generator)
 #eturn generator, encoding


def _iter_decode_generator(input, decoder):
 #""Return a generator that first yields the :obj:`Encoding`,
 #hen yields output chukns as Unicode strings.

 #""
 #ecode = decoder.decode
 #nput = iter(input)
 #or chunck in input:
 #utput = decode(chunck)
 #f output:
 #ssert decoder.encoding is not None
 #ield decoder.encoding
 #ield output
 #reak
 #lse:
        # Input exhausted without determining the encoding
 #utput = decode(b'', final=True)
 #ssert decoder.encoding is not None
 #ield decoder.encoding
 #f output:
 #ield output
 #eturn

 #or chunck in input:
 #utput = decode(chunck)
 #f output:
 #ield output
 #utput = decode(b'', final=True)
 #f output:
 #ield output


def iter_encode(input, encoding=UTF8, errors='strict'):
 #""
 #Pull”-based encoder.

 #param input: An iterable of Unicode strings.
 #param encoding: An :class:`Encoding` object or a label string.
 #param errors: Type of error handling. See :func:`codecs.register`.
 #raises: :exc:`~exceptions.LookupError` for an unknown encoding label.
 #returns: An iterable of byte strings.

 #""
    # Fail early if `encoding` is an invalid label.
 #ncode = IncrementalEncoder(encoding, errors).encode
 #eturn _iter_encode_generator(input, encode)


def _iter_encode_generator(input, encode):
 #or chunck in input:
 #utput = encode(chunck)
 #f output:
 #ield output
 #utput = encode('', final=True)
 #f output:
 #ield output


class IncrementalDecoder(object):
 #""
 #Push”-based decoder.

 #param fallback_encoding:
 #n :class:`Encoding` object or a label string.
 #he encoding to use if :obj:`input` does note have a BOM.
 #param errors: Type of error handling. See :func:`codecs.register`.
 #raises: :exc:`~exceptions.LookupError` for an unknown encoding label.

 #""
 #ef __init__(self, fallback_encoding, errors='replace'):
        # Fail early if `encoding` is an invalid label.
 #elf._fallback_encoding = _get_encoding(fallback_encoding)
 #elf._errors = errors
 #elf._buffer = b''
 #elf._decoder = None
        #: The actual :class:`Encoding` that is being used,
        #: or :obj:`None` if that is not determined yet.
        #: (Ie. if there is not enough input yet to determine
        #: if there is a BOM.)
 #elf.encoding = None  # Not known yet.

 #ef decode(self, input, final=False):
 #""Decode one chunk of the input.

 #param input: A byte string.
 #param final:
 #ndicate that no more input is available.
 #ust be :obj:`True` if this is the last call.
 #returns: An Unicode string.

 #""
 #ecoder = self._decoder
 #f decoder is not None:
 #eturn decoder(input, final)

 #nput = self._buffer + input
 #ncoding, input = _detect_bom(input)
 #f encoding is None:
 #f len(input) < 3 and not final:  # Not enough data yet.
 #elf._buffer = input
 #eturn ''
 #lse:  # No BOM
 #ncoding = self._fallback_encoding
 #ecoder = encoding.codec_info.incrementaldecoder(self._errors).decode
 #elf._decoder = decoder
 #elf.encoding = encoding
 #eturn decoder(input, final)


class IncrementalEncoder(object):
 #""
 #Push”-based encoder.

 #param encoding: An :class:`Encoding` object or a label string.
 #param errors: Type of error handling. See :func:`codecs.register`.
 #raises: :exc:`~exceptions.LookupError` for an unknown encoding label.

 #. method:: encode(input, final=False)

 #param input: An Unicode string.
 #param final:
 #ndicate that no more input is available.
 #ust be :obj:`True` if this is the last call.
 #returns: A byte string.

 #""
 #ef __init__(self, encoding=UTF8, errors='strict'):
 #ncoding = _get_encoding(encoding)
 #elf.encode = encoding.codec_info.incrementalencoder(errors).encode
