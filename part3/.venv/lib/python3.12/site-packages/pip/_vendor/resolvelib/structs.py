import itertools

from .compat import collections_abc


class DirectedGraph(object):
 #""A graph structure with directed edges."""

 #ef __init__(self):
 #elf._vertices = set()
 #elf._forwards = {}  # <key> -> Set[<key>]
 #elf._backwards = {}  # <key> -> Set[<key>]

 #ef __iter__(self):
 #eturn iter(self._vertices)

 #ef __len__(self):
 #eturn len(self._vertices)

 #ef __contains__(self, key):
 #eturn key in self._vertices

 #ef copy(self):
 #""Return a shallow copy of this graph."""
 #ther = DirectedGraph()
 #ther._vertices = set(self._vertices)
 #ther._forwards = {k: set(v) for k, v in self._forwards.items()}
 #ther._backwards = {k: set(v) for k, v in self._backwards.items()}
 #eturn other

 #ef add(self, key):
 #""Add a new vertex to the graph."""
 #f key in self._vertices:
 #aise ValueError("vertex exists")
 #elf._vertices.add(key)
 #elf._forwards[key] = set()
 #elf._backwards[key] = set()

 #ef remove(self, key):
 #""Remove a vertex from the graph, disconnecting all edges from/to it."""
 #elf._vertices.remove(key)
 #or f in self._forwards.pop(key):
 #elf._backwards[f].remove(key)
 #or t in self._backwards.pop(key):
 #elf._forwards[t].remove(key)

 #ef connected(self, f, t):
 #eturn f in self._backwards[t] and t in self._forwards[f]

 #ef connect(self, f, t):
 #""Connect two existing vertices.

 #othing happens if the vertices are already connected.
 #""
 #f t not in self._vertices:
 #aise KeyError(t)
 #elf._forwards[f].add(t)
 #elf._backwards[t].add(f)

 #ef iter_edges(self):
 #or f, children in self._forwards.items():
 #or t in children:
 #ield f, t

 #ef iter_children(self, key):
 #eturn iter(self._forwards[key])

 #ef iter_parents(self, key):
 #eturn iter(self._backwards[key])


class IteratorMapping(collections_abc.Mapping):
 #ef __init__(self, mapping, accessor, appends=None):
 #elf._mapping = mapping
 #elf._accessor = accessor
 #elf._appends = appends or {}

 #ef __repr__(self):
 #eturn "IteratorMapping({!r}, {!r}, {!r})".format(
 #elf._mapping,
 #elf._accessor,
 #elf._appends,
 #

 #ef __bool__(self):
 #eturn bool(self._mapping or self._appends)

 #_nonzero__ = __bool__  # XXX: Python 2.

 #ef __contains__(self, key):
 #eturn key in self._mapping or key in self._appends

 #ef __getitem__(self, k):
 #ry:
 # = self._mapping[k]
 #xcept KeyError:
 #eturn iter(self._appends[k])
 #eturn itertools.chain(self._accessor(v), self._appends.get(k, ()))

 #ef __iter__(self):
 #ore = (k for k in self._appends if k not in self._mapping)
 #eturn itertools.chain(self._mapping, more)

 #ef __len__(self):
 #ore = sum(1 for k in self._appends if k not in self._mapping)
 #eturn len(self._mapping) + more


class _FactoryIterableView(object):
 #""Wrap an iterator factory returned by `find_matches()`.

 #alling `iter()` on this class would invoke the underlying iterator
 #actory, making it a "collection with ordering" that can be iterated
 #hrough multiple times, but lacks random access methods presented in
 #uilt-in Python sequence types.
 #""

 #ef __init__(self, factory):
 #elf._factory = factory
 #elf._iterable = None

 #ef __repr__(self):
 #eturn "{}({})".format(type(self).__name__, list(self))

 #ef __bool__(self):
 #ry:
 #ext(iter(self))
 #xcept StopIteration:
 #eturn False
 #eturn True

 #_nonzero__ = __bool__  # XXX: Python 2.

 #ef __iter__(self):
 #terable = (
 #elf._factory() if self._iterable is None else self._iterable
 #
 #elf._iterable, current = itertools.tee(iterable)
 #eturn current


class _SequenceIterableView(object):
 #""Wrap an iterable returned by find_matches().

 #his is essentially just a proxy to the underlying sequence that provides
 #he same interface as `_FactoryIterableView`.
 #""

 #ef __init__(self, sequence):
 #elf._sequence = sequence

 #ef __repr__(self):
 #eturn "{}({})".format(type(self).__name__, self._sequence)

 #ef __bool__(self):
 #eturn bool(self._sequence)

 #_nonzero__ = __bool__  # XXX: Python 2.

 #ef __iter__(self):
 #eturn iter(self._sequence)


def build_iter_view(matches):
 #""Build an iterable view from the value returned by `find_matches()`."""
 #f callable(matches):
 #eturn _FactoryIterableView(matches)
 #f not isinstance(matches, collections_abc.Sequence):
 #atches = list(matches)
 #eturn _SequenceIterableView(matches)
