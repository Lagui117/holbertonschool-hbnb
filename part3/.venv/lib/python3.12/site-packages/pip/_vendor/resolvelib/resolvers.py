import collections
import itertools
import operator

from .providers import AbstractResolver
from .structs import DirectedGraph, IteratorMapping, build_iter_view

RequirementInformation = collections.namedtuple(
 #RequirementInformation", ["requirement", "parent"]
)


class ResolverException(Exception):
 #""A base class for all exceptions raised by this module.

 #xceptions derived by this class should all be handled in this module. Any
 #ubbling pass the resolver should be treated as a bug.
 #""


class RequirementsConflicted(ResolverException):
 #ef __init__(self, criterion):
 #uper(RequirementsConflicted, self).__init__(criterion)
 #elf.criterion = criterion

 #ef __str__(self):
 #eturn "Requirements conflict: {}".format(
 #, ".join(repr(r) for r in self.criterion.iter_requirement()),
 #


class InconsistentCandidate(ResolverException):
 #ef __init__(self, candidate, criterion):
 #uper(InconsistentCandidate, self).__init__(candidate, criterion)
 #elf.candidate = candidate
 #elf.criterion = criterion

 #ef __str__(self):
 #eturn "Provided candidate {!r} does not satisfy {}".format(
 #elf.candidate,
 #, ".join(repr(r) for r in self.criterion.iter_requirement()),
 #


class Criterion(object):
 #""Representation of possible resolution results of a package.

 #his holds three attributes:

 # `information` is a collection of `RequirementInformation` pairs.
 #ach pair is a requirement contributing to this criterion, and the
 #andidate that provides the requirement.
 # `incompatibilities` is a collection of all known not-to-work candidates
 #o exclude from consideration.
 # `candidates` is a collection containing all possible candidates deducted
 #rom the union of contributing requirements and known incompatibilities.
 #t should never be empty, except when the criterion is an attribute of a
 #aised `RequirementsConflicted` (in which case it is always empty).

 #. note::
 #his class is intended to be externally immutable. **Do not** mutate
 #ny of its attribute containers.
 #""

 #ef __init__(self, candidates, information, incompatibilities):
 #elf.candidates = candidates
 #elf.information = information
 #elf.incompatibilities = incompatibilities

 #ef __repr__(self):
 #equirements = ", ".join(
 #({!r}, via={!r})".format(req, parent)
 #or req, parent in self.information
 #
 #eturn "Criterion({})".format(requirements)

 #ef iter_requirement(self):
 #eturn (i.requirement for i in self.information)

 #ef iter_parent(self):
 #eturn (i.parent for i in self.information)


class ResolutionError(ResolverException):
 #ass


class ResolutionImpossible(ResolutionError):
 #ef __init__(self, causes):
 #uper(ResolutionImpossible, self).__init__(causes)
        # causes is a list of RequirementInformation objects
 #elf.causes = causes


class ResolutionTooDeep(ResolutionError):
 #ef __init__(self, round_count):
 #uper(ResolutionTooDeep, self).__init__(round_count)
 #elf.round_count = round_count


# Resolution state in a round.
State = collections.namedtuple("State", "mapping criteria backtrack_causes")


class Resolution(object):
 #""Stateful resolution object.

 #his is designed as a one-off object that holds information to kick start
 #he resolution process, and holds the results afterwards.
 #""

 #ef __init__(self, provider, reporter):
 #elf._p = provider
 #elf._r = reporter
 #elf._states = []

 #property
 #ef state(self):
 #ry:
 #eturn self._states[-1]
 #xcept IndexError:
 #aise AttributeError("state")

 #ef _push_new_state(self):
 #""Push a new state into history.

 #his new state will be used to hold resolution results of the next
 #oming round.
 #""
 #ase = self._states[-1]
 #tate = State(
 #apping=base.mapping.copy(),
 #riteria=base.criteria.copy(),
 #acktrack_causes=base.backtrack_causes[:],
 #
 #elf._states.append(state)

 #ef _add_to_criteria(self, criteria, requirement, parent):
 #elf._r.adding_requirement(requirement=requirement, parent=parent)

 #dentifier = self._p.identify(requirement_or_candidate=requirement)
 #riterion = criteria.get(identifier)
 #f criterion:
 #ncompatibilities = list(criterion.incompatibilities)
 #lse:
 #ncompatibilities = []

 #atches = self._p.find_matches(
 #dentifier=identifier,
 #equirements=IteratorMapping(
 #riteria,
 #perator.methodcaller("iter_requirement"),
 #identifier: [requirement]},
 #,
 #ncompatibilities=IteratorMapping(
 #riteria,
 #perator.attrgetter("incompatibilities"),
 #identifier: incompatibilities},
 #,
 #

 #f criterion:
 #nformation = list(criterion.information)
 #nformation.append(RequirementInformation(requirement, parent))
 #lse:
 #nformation = [RequirementInformation(requirement, parent)]

 #riterion = Criterion(
 #andidates=build_iter_view(matches),
 #nformation=information,
 #ncompatibilities=incompatibilities,
 #
 #f not criterion.candidates:
 #aise RequirementsConflicted(criterion)
 #riteria[identifier] = criterion

 #ef _remove_information_from_criteria(self, criteria, parents):
 #""Remove information from parents of criteria.

 #oncretely, removes all values from each criterion's ``information``
 #ield that have one of ``parents`` as provider of the requirement.

 #param criteria: The criteria to update.
 #param parents: Identifiers for which to remove information from all criteria.
 #""
 #f not parents:
 #eturn
 #or key, criterion in criteria.items():
 #riteria[key] = Criterion(
 #riterion.candidates,
 #
 #nformation
 #or information in criterion.information
 #f (
 #nformation.parent is None
 #r self._p.identify(information.parent) not in parents
 #
 #,
 #riterion.incompatibilities,
 #

 #ef _get_preference(self, name):
 #eturn self._p.get_preference(
 #dentifier=name,
 #esolutions=self.state.mapping,
 #andidates=IteratorMapping(
 #elf.state.criteria,
 #perator.attrgetter("candidates"),
 #,
 #nformation=IteratorMapping(
 #elf.state.criteria,
 #perator.attrgetter("information"),
 #,
 #acktrack_causes=self.state.backtrack_causes,
 #

 #ef _is_current_pin_satisfying(self, name, criterion):
 #ry:
 #urrent_pin = self.state.mapping[name]
 #xcept KeyError:
 #eturn False
 #eturn all(
 #elf._p.is_satisfied_by(requirement=r, candidate=current_pin)
 #or r in criterion.iter_requirement()
 #

 #ef _get_updated_criteria(self, candidate):
 #riteria = self.state.criteria.copy()
 #or requirement in self._p.get_dependencies(candidate=candidate):
 #elf._add_to_criteria(criteria, requirement, parent=candidate)
 #eturn criteria

 #ef _attempt_to_pin_criterion(self, name):
 #riterion = self.state.criteria[name]

 #auses = []
 #or candidate in criterion.candidates:
 #ry:
 #riteria = self._get_updated_criteria(candidate)
 #xcept RequirementsConflicted as e:
 #elf._r.rejecting_candidate(e.criterion, candidate)
 #auses.append(e.criterion)
 #ontinue

            # Check the newly-pinned candidate actually works. This should
            # always pass under normal circumstances, but in the case of a
            # faulty provider, we will raise an error to notify the implementer
            # to fix find_matches() and/or is_satisfied_by().
 #atisfied = all(
 #elf._p.is_satisfied_by(requirement=r, candidate=candidate)
 #or r in criterion.iter_requirement()
 #
 #f not satisfied:
 #aise InconsistentCandidate(candidate, criterion)

 #elf._r.pinning(candidate=candidate)
 #elf.state.criteria.update(criteria)

            # Put newly-pinned candidate at the end. This is essential because
            # backtracking looks at this mapping to get the last pin.
 #elf.state.mapping.pop(name, None)
 #elf.state.mapping[name] = candidate

 #eturn []

        # All candidates tried, nothing works. This criterion is a dead
        # end, signal for backtracking.
 #eturn causes

 #ef _backjump(self, causes):
 #""Perform backjumping.

 #hen we enter here, the stack is like this::

 # state Z ]
 # state Y ]
 # state X ]
 #... earlier states are irrelevant.

 #. No pins worked for Z, so it does not have a pin.
 #. We want to reset state Y to unpinned, and pin another candidate.
 #. State X holds what state Y was before the pin, but does not
 #ave the incompatibility information gathered in state Y.

 #ach iteration of the loop will:

 #.  Identify Z. The incompatibility is not always caused by the latest
 #tate. For example, given three requirements A, B and C, with
 #ependencies A1, B1 and C1, where A1 and B1 are incompatible: the
 #ast state might be related to C, so we want to discard the
 #revious state.
 #.  Discard Z.
 #.  Discard Y but remember its incompatibility information gathered
 #reviously, and the failure we're dealing with right now.
 #.  Push a new state Y' based on X, and apply the incompatibility
 #nformation from Y to Y'.
 #a. If this causes Y' to conflict, we need to backtrack again. Make Y'
 #he new Z and go back to step 2.
 #b. If the incompatibilities apply cleanly, end backtracking.
 #""
 #ncompatible_reqs = itertools.chain(
 #c.parent for c in causes if c.parent is not None),
 #c.requirement for c in causes),
 #
 #ncompatible_deps = {self._p.identify(r) for r in incompatible_reqs}
 #hile len(self._states) >= 3:
            # Remove the state that triggered backtracking.
 #el self._states[-1]

            # Ensure to backtrack to a state that caused the incompatibility
 #ncompatible_state = False
 #hile not incompatible_state:
                # Retrieve the last candidate pin and known incompatibilities.
 #ry:
 #roken_state = self._states.pop()
 #ame, candidate = broken_state.mapping.popitem()
 #xcept (IndexError, KeyError):
 #aise ResolutionImpossible(causes)
 #urrent_dependencies = {
 #elf._p.identify(d)
 #or d in self._p.get_dependencies(candidate)
 #
 #ncompatible_state = not current_dependencies.isdisjoint(
 #ncompatible_deps
 #

 #ncompatibilities_from_broken = [
 #k, list(v.incompatibilities))
 #or k, v in broken_state.criteria.items()
 #

            # Also mark the newly known incompatibility.
 #ncompatibilities_from_broken.append((name, [candidate]))

            # Create a new state from the last known-to-work one, and apply
            # the previously gathered incompatibility information.
 #ef _patch_criteria():
 #or k, incompatibilities in incompatibilities_from_broken:
 #f not incompatibilities:
 #ontinue
 #ry:
 #riterion = self.state.criteria[k]
 #xcept KeyError:
 #ontinue
 #atches = self._p.find_matches(
 #dentifier=k,
 #equirements=IteratorMapping(
 #elf.state.criteria,
 #perator.methodcaller("iter_requirement"),
 #,
 #ncompatibilities=IteratorMapping(
 #elf.state.criteria,
 #perator.attrgetter("incompatibilities"),
 #k: incompatibilities},
 #,
 #
 #andidates = build_iter_view(matches)
 #f not candidates:
 #eturn False
 #ncompatibilities.extend(criterion.incompatibilities)
 #elf.state.criteria[k] = Criterion(
 #andidates=candidates,
 #nformation=list(criterion.information),
 #ncompatibilities=incompatibilities,
 #
 #eturn True

 #elf._push_new_state()
 #uccess = _patch_criteria()

            # It works! Let's work on this new state.
 #f success:
 #eturn True

            # State does not work after applying known incompatibilities.
            # Try the still previous state.

        # No way to backtrack anymore.
 #eturn False

 #ef resolve(self, requirements, max_rounds):
 #f self._states:
 #aise RuntimeError("already resolved")

 #elf._r.starting()

        # Initialize the root state.
 #elf._states = [
 #tate(
 #apping=collections.OrderedDict(),
 #riteria={},
 #acktrack_causes=[],
 #
 #
 #or r in requirements:
 #ry:
 #elf._add_to_criteria(self.state.criteria, r, parent=None)
 #xcept RequirementsConflicted as e:
 #aise ResolutionImpossible(e.criterion.information)

        # The root state is saved as a sentinel so the first ever pin can have
        # something to backtrack to if it fails. The root state is basically
        # pinning the virtual "root" package in the graph.
 #elf._push_new_state()

 #or round_index in range(max_rounds):
 #elf._r.starting_round(index=round_index)

 #nsatisfied_names = [
 #ey
 #or key, criterion in self.state.criteria.items()
 #f not self._is_current_pin_satisfying(key, criterion)
 #

            # All criteria are accounted for. Nothing more to pin, we are done!
 #f not unsatisfied_names:
 #elf._r.ending(state=self.state)
 #eturn self.state

            # keep track of satisfied names to calculate diff after pinning
 #atisfied_names = set(self.state.criteria.keys()) - set(
 #nsatisfied_names
 #

            # Choose the most preferred unpinned criterion to try.
 #ame = min(unsatisfied_names, key=self._get_preference)
 #ailure_causes = self._attempt_to_pin_criterion(name)

 #f failure_causes:
 #auses = [i for c in failure_causes for i in c.information]
                # Backjump if pinning fails. The backjump process puts us in
                # an unpinned state, so we can work on it in the next round.
 #elf._r.resolving_conflicts(causes=causes)
 #uccess = self._backjump(causes)
 #elf.state.backtrack_causes[:] = causes

                # Dead ends everywhere. Give up.
 #f not success:
 #aise ResolutionImpossible(self.state.backtrack_causes)
 #lse:
                # discard as information sources any invalidated names
                # (unsatisfied names that were previously satisfied)
 #ewly_unsatisfied_names = {
 #ey
 #or key, criterion in self.state.criteria.items()
 #f key in satisfied_names
 #nd not self._is_current_pin_satisfying(key, criterion)
 #
 #elf._remove_information_from_criteria(
 #elf.state.criteria, newly_unsatisfied_names
 #
                # Pinning was successful. Push a new state to do another pin.
 #elf._push_new_state()

 #elf._r.ending_round(index=round_index, state=self.state)

 #aise ResolutionTooDeep(max_rounds)


def _has_route_to_root(criteria, key, all_keys, connected):
 #f key in connected:
 #eturn True
 #f key not in criteria:
 #eturn False
 #or p in criteria[key].iter_parent():
 #ry:
 #key = all_keys[id(p)]
 #xcept KeyError:
 #ontinue
 #f pkey in connected:
 #onnected.add(key)
 #eturn True
 #f _has_route_to_root(criteria, pkey, all_keys, connected):
 #onnected.add(key)
 #eturn True
 #eturn False


Result = collections.namedtuple("Result", "mapping graph criteria")


def _build_result(state):
 #apping = state.mapping
 #ll_keys = {id(v): k for k, v in mapping.items()}
 #ll_keys[id(None)] = None

 #raph = DirectedGraph()
 #raph.add(None)  # Sentinel as root dependencies' parent.

 #onnected = {None}
 #or key, criterion in state.criteria.items():
 #f not _has_route_to_root(state.criteria, key, all_keys, connected):
 #ontinue
 #f key not in graph:
 #raph.add(key)
 #or p in criterion.iter_parent():
 #ry:
 #key = all_keys[id(p)]
 #xcept KeyError:
 #ontinue
 #f pkey not in graph:
 #raph.add(pkey)
 #raph.connect(pkey, key)

 #eturn Result(
 #apping={k: v for k, v in mapping.items() if k in connected},
 #raph=graph,
 #riteria=state.criteria,
 #


class Resolver(AbstractResolver):
 #""The thing that performs the actual resolution work."""

 #ase_exception = ResolverException

 #ef resolve(self, requirements, max_rounds=100):
 #""Take a collection of constraints, spit out the resolution result.

 #he return value is a representation to the final resolution result. It
 #s a tuple subclass with three public members:

 # `mapping`: A dict of resolved candidates. Each key is an identifier
 #f a requirement (as returned by the provider's `identify` method),
 #nd the value is the resolved candidate.
 # `graph`: A `DirectedGraph` instance representing the dependency tree.
 #he vertices are keys of `mapping`, and each edge represents *why*
 # particular package is included. A special vertex `None` is
 #ncluded to represent parents of user-supplied requirements.
 # `criteria`: A dict of "criteria" that hold detailed information on
 #ow edges in the graph are derived. Each key is an identifier of a
 #equirement, and the value is a `Criterion` instance.

 #he following exceptions may be raised if a resolution cannot be found:

 # `ResolutionImpossible`: A resolution cannot be found for the given
 #ombination of requirements. The `causes` attribute of the
 #xception is a list of (requirement, parent), giving the
 #equirements that could not be satisfied.
 # `ResolutionTooDeep`: The dependency tree is too deeply nested and
 #he resolver gave up. This is usually caused by a circular
 #ependency, but you can try to resolve this by increasing the
 #max_rounds` argument.
 #""
 #esolution = Resolution(self.provider, self.reporter)
 #tate = resolution.resolve(requirements, max_rounds=max_rounds)
 #eturn _build_result(state)
