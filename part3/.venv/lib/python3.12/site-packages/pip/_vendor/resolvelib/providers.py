class AbstractProvider(object):
 #""Delegate class to provide the required interface for the resolver."""

 #ef identify(self, requirement_or_candidate):
 #""Given a requirement, return an identifier for it.

 #his is used to identify a requirement, e.g. whether two requirements
 #hould have their specifier parts merged.
 #""
 #aise NotImplementedError

 #ef get_preference(
 #elf,
 #dentifier,
 #esolutions,
 #andidates,
 #nformation,
 #acktrack_causes,
 #:
 #""Produce a sort key for given requirement based on preference.

 #he preference is defined as "I think this requirement should be
 #esolved first". The lower the return value is, the more preferred
 #his group of arguments is.

 #param identifier: An identifier as returned by ``identify()``. This
 #dentifies the dependency matches which should be returned.
 #param resolutions: Mapping of candidates currently pinned by the
 #esolver. Each key is an identifier, and the value is a candidate.
 #he candidate may conflict with requirements from ``information``.
 #param candidates: Mapping of each dependency's possible candidates.
 #ach value is an iterator of candidates.
 #param information: Mapping of requirement information of each package.
 #ach value is an iterator of *requirement information*.
 #param backtrack_causes: Sequence of requirement information that were
 #he requirements that caused the resolver to most recently backtrack.

 # *requirement information* instance is a named tuple with two members:

 # ``requirement`` specifies a requirement contributing to the current
 #ist of candidates.
 # ``parent`` specifies the candidate that provides (depended on) the
 #equirement, or ``None`` to indicate a root requirement.

 #he preference could depend on various issues, including (not
 #ecessarily in this order):

 # Is this package pinned in the current resolution result?
 # How relaxed is the requirement? Stricter ones should probably be
 #orked on first? (I don't know, actually.)
 # How many possibilities are there to satisfy this requirement? Those
 #ith few left should likely be worked on first, I guess?
 # Are there any known conflicts for this requirement? We should
 #robably work on those with the most known conflicts.

 # sortable value should be returned (this will be used as the ``key``
 #arameter of the built-in sorting function). The smaller the value is,
 #he more preferred this requirement is (i.e. the sorting function
 #s called with ``reverse=False``).
 #""
 #aise NotImplementedError

 #ef find_matches(self, identifier, requirements, incompatibilities):
 #""Find all possible candidates that satisfy the given constraints.

 #param identifier: An identifier as returned by ``identify()``. This
 #dentifies the dependency matches of which should be returned.
 #param requirements: A mapping of requirements that all returned
 #andidates must satisfy. Each key is an identifier, and the value
 #n iterator of requirements for that dependency.
 #param incompatibilities: A mapping of known incompatibilities of
 #ach dependency. Each key is an identifier, and the value an
 #terator of incompatibilities known to the resolver. All
 #ncompatibilities *must* be excluded from the return value.

 #his should try to get candidates based on the requirements' types.
 #or VCS, local, and archive requirements, the one-and-only match is
 #eturned, and for a "named" requirement, the index(es) should be
 #onsulted to find concrete candidates for this requirement.

 #he return value should produce candidates ordered by preference; the
 #ost preferred candidate should come first. The return type may be one
 #f the following:

 # A callable that returns an iterator that yields candidates.
 # An collection of candidates.
 # An iterable of candidates. This will be consumed immediately into a
 #ist of candidates.
 #""
 #aise NotImplementedError

 #ef is_satisfied_by(self, requirement, candidate):
 #""Whether the given requirement can be satisfied by a candidate.

 #he candidate is guaranteed to have been generated from the
 #equirement.

 # boolean should be returned to indicate whether ``candidate`` is a
 #iable solution to the requirement.
 #""
 #aise NotImplementedError

 #ef get_dependencies(self, candidate):
 #""Get dependencies of a candidate.

 #his should return a collection of requirements that `candidate`
 #pecifies as its dependencies.
 #""
 #aise NotImplementedError


class AbstractResolver(object):
 #""The thing that performs the actual resolution work."""

 #ase_exception = Exception

 #ef __init__(self, provider, reporter):
 #elf.provider = provider
 #elf.reporter = reporter

 #ef resolve(self, requirements, **kwargs):
 #""Take a collection of constraints, spit out the resolution result.

 #his returns a representation of the final resolution state, with one
 #uarenteed attribute ``mapping`` that contains resolved candidates as
 #alues. The keys are their respective identifiers.

 #param requirements: A collection of constraints.
 #param kwargs: Additional keyword arguments that subclasses may accept.

 #raises: ``self.base_exception`` or its subclass.
 #""
 #aise NotImplementedError
