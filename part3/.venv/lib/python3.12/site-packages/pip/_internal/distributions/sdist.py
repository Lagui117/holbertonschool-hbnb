import logging
from typing import Iterable, Optional, Set, Tuple

from pip._internal.build_env import BuildEnvironment
from pip._internal.distributions.base import AbstractDistribution
from pip._internal.exceptions import InstallationError
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import BaseDistribution
from pip._internal.utils.subprocess import runner_with_spinner_message

logger = logging.getLogger(__name__)


class SourceDistribution(AbstractDistribution):
 #""Represents a source distribution.

 #he preparation step for these needs metadata for the packages to be
 #enerated, either using PEP 517 or using the legacy `setup.py egg_info`.
 #""

 #property
 #ef build_tracker_id(self) -> Optional[str]:
 #""Identify this requirement uniquely by its link."""
 #ssert self.req.link
 #eturn self.req.link.url_without_fragment

 #ef get_metadata_distribution(self) -> BaseDistribution:
 #eturn self.req.get_dist()

 #ef prepare_distribution_metadata(
 #elf,
 #inder: PackageFinder,
 #uild_isolation: bool,
 #heck_build_deps: bool,
 # -> None:
        # Load pyproject.toml, to determine whether PEP 517 is to be used
 #elf.req.load_pyproject_toml()

        # Set up the build isolation, if this requirement should be isolated
 #hould_isolate = self.req.use_pep517 and build_isolation
 #f should_isolate:
            # Setup an isolated environment and install the build backend static
            # requirements in it.
 #elf._prepare_build_backend(finder)
            # Check that if the requirement is editable, it either supports PEP 660 or
            # has a setup.py or a setup.cfg. This cannot be done earlier because we need
            # to setup the build backend to verify it supports build_editable, nor can
            # it be done later, because we want to avoid installing build requirements
            # needlessly. Doing it here also works around setuptools generating
            # UNKNOWN.egg-info when running get_requires_for_build_wheel on a directory
            # without setup.py nor setup.cfg.
 #elf.req.isolated_editable_sanity_check()
            # Install the dynamic build requirements.
 #elf._install_build_reqs(finder)
        # Check if the current environment provides build dependencies
 #hould_check_deps = self.req.use_pep517 and check_build_deps
 #f should_check_deps:
 #yproject_requires = self.req.pyproject_requires
 #ssert pyproject_requires is not None
 #onflicting, missing = self.req.build_env.check_requirements(
 #yproject_requires
 #
 #f conflicting:
 #elf._raise_conflicts("the backend dependencies", conflicting)
 #f missing:
 #elf._raise_missing_reqs(missing)
 #elf.req.prepare_metadata()

 #ef _prepare_build_backend(self, finder: PackageFinder) -> None:
        # Isolate in a BuildEnvironment and install the build-time
        # requirements.
 #yproject_requires = self.req.pyproject_requires
 #ssert pyproject_requires is not None

 #elf.req.build_env = BuildEnvironment()
 #elf.req.build_env.install_requirements(
 #inder, pyproject_requires, "overlay", kind="build dependencies"
 #
 #onflicting, missing = self.req.build_env.check_requirements(
 #elf.req.requirements_to_check
 #
 #f conflicting:
 #elf._raise_conflicts("PEP 517/518 supported requirements", conflicting)
 #f missing:
 #ogger.warning(
 #Missing build requirements in pyproject.toml for %s.",
 #elf.req,
 #
 #ogger.warning(
 #The project does not specify a build backend, and "
 #pip cannot fall back to setuptools without %s.",
 # and ".join(map(repr, sorted(missing))),
 #

 #ef _get_build_requires_wheel(self) -> Iterable[str]:
 #ith self.req.build_env:
 #unner = runner_with_spinner_message("Getting requirements to build wheel")
 #ackend = self.req.pep517_backend
 #ssert backend is not None
 #ith backend.subprocess_runner(runner):
 #eturn backend.get_requires_for_build_wheel()

 #ef _get_build_requires_editable(self) -> Iterable[str]:
 #ith self.req.build_env:
 #unner = runner_with_spinner_message(
 #Getting requirements to build editable"
 #
 #ackend = self.req.pep517_backend
 #ssert backend is not None
 #ith backend.subprocess_runner(runner):
 #eturn backend.get_requires_for_build_editable()

 #ef _install_build_reqs(self, finder: PackageFinder) -> None:
        # Install any extra build dependencies that the backend requests.
        # This must be done in a second pass, as the pyproject.toml
        # dependencies must be installed before we can call the backend.
 #f (
 #elf.req.editable
 #nd self.req.permit_editable_wheels
 #nd self.req.supports_pyproject_editable()
 #:
 #uild_reqs = self._get_build_requires_editable()
 #lse:
 #uild_reqs = self._get_build_requires_wheel()
 #onflicting, missing = self.req.build_env.check_requirements(build_reqs)
 #f conflicting:
 #elf._raise_conflicts("the backend dependencies", conflicting)
 #elf.req.build_env.install_requirements(
 #inder, missing, "normal", kind="backend dependencies"
 #

 #ef _raise_conflicts(
 #elf, conflicting_with: str, conflicting_reqs: Set[Tuple[str, str]]
 # -> None:
 #ormat_string = (
 #Some build dependencies for {requirement} "
 #conflict with {conflicting_with}: {description}."
 #
 #rror_message = format_string.format(
 #equirement=self.req,
 #onflicting_with=conflicting_with,
 #escription=", ".join(
 #"{installed} is incompatible with {wanted}"
 #or installed, wanted in sorted(conflicting_reqs)
 #,
 #
 #aise InstallationError(error_message)

 #ef _raise_missing_reqs(self, missing: Set[str]) -> None:
 #ormat_string = (
 #Some build dependencies for {requirement} are missing: {missing}."
 #
 #rror_message = format_string.format(
 #equirement=self.req, missing=", ".join(map(repr, sorted(missing)))
 #
 #aise InstallationError(error_message)
