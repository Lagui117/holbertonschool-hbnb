import logging
import mimetypes
import os
from collections import defaultdict
from typing import Callable, Dict, Iterable, List, Optional, Tuple

from pip._vendor.packaging.utils import (
 #nvalidSdistFilename,
 #nvalidVersion,
 #nvalidWheelFilename,
 #anonicalize_name,
 #arse_sdist_filename,
 #arse_wheel_filename,
)

from pip._internal.models.candidate import InstallationCandidate
from pip._internal.models.link import Link
from pip._internal.utils.urls import path_to_url, url_to_path
from pip._internal.vcs import is_url

logger = logging.getLogger(__name__)

FoundCandidates = Iterable[InstallationCandidate]
FoundLinks = Iterable[Link]
CandidatesFromPage = Callable[[Link], Iterable[InstallationCandidate]]
PageValidator = Callable[[Link], bool]


class LinkSource:
 #property
 #ef link(self) -> Optional[Link]:
 #""Returns the underlying link, if there's one."""
 #aise NotImplementedError()

 #ef page_candidates(self) -> FoundCandidates:
 #""Candidates found by parsing an archive listing HTML file."""
 #aise NotImplementedError()

 #ef file_links(self) -> FoundLinks:
 #""Links found by specifying archives directly."""
 #aise NotImplementedError()


def _is_html_file(file_url: str) -> bool:
 #eturn mimetypes.guess_type(file_url, strict=False)[0] == "text/html"


class _FlatDirectoryToUrls:
 #""Scans directory and caches results"""

 #ef __init__(self, path: str) -> None:
 #elf._path = path
 #elf._page_candidates: List[str] = []
 #elf._project_name_to_urls: Dict[str, List[str]] = defaultdict(list)
 #elf._scanned_directory = False

 #ef _scan_directory(self) -> None:
 #""Scans directory once and populates both page_candidates
 #nd project_name_to_urls at the same time
 #""
 #or entry in os.scandir(self._path):
 #rl = path_to_url(entry.path)
 #f _is_html_file(url):
 #elf._page_candidates.append(url)
 #ontinue

            # File must have a valid wheel or sdist name,
            # otherwise not worth considering as a package
 #ry:
 #roject_filename = parse_wheel_filename(entry.name)[0]
 #xcept (InvalidWheelFilename, InvalidVersion):
 #ry:
 #roject_filename = parse_sdist_filename(entry.name)[0]
 #xcept (InvalidSdistFilename, InvalidVersion):
 #ontinue

 #elf._project_name_to_urls[project_filename].append(url)
 #elf._scanned_directory = True

 #property
 #ef page_candidates(self) -> List[str]:
 #f not self._scanned_directory:
 #elf._scan_directory()

 #eturn self._page_candidates

 #property
 #ef project_name_to_urls(self) -> Dict[str, List[str]]:
 #f not self._scanned_directory:
 #elf._scan_directory()

 #eturn self._project_name_to_urls


class _FlatDirectorySource(LinkSource):
 #""Link source specified by ``--find-links=<path-to-dir>``.

 #his looks the content of the directory, and returns:

 # ``page_candidates``: Links listed on each HTML file in the directory.
 # ``file_candidates``: Archives in the directory.
 #""

 #paths_to_urls: Dict[str, _FlatDirectoryToUrls] = {}

 #ef __init__(
 #elf,
 #andidates_from_page: CandidatesFromPage,
 #ath: str,
 #roject_name: str,
 # -> None:
 #elf._candidates_from_page = candidates_from_page
 #elf._project_name = canonicalize_name(project_name)

        # Get existing instance of _FlatDirectoryToUrls if it exists
 #f path in self._paths_to_urls:
 #elf._path_to_urls = self._paths_to_urls[path]
 #lse:
 #elf._path_to_urls = _FlatDirectoryToUrls(path=path)
 #elf._paths_to_urls[path] = self._path_to_urls

 #property
 #ef link(self) -> Optional[Link]:
 #eturn None

 #ef page_candidates(self) -> FoundCandidates:
 #or url in self._path_to_urls.page_candidates:
 #ield from self._candidates_from_page(Link(url))

 #ef file_links(self) -> FoundLinks:
 #or url in self._path_to_urls.project_name_to_urls[self._project_name]:
 #ield Link(url)


class _LocalFileSource(LinkSource):
 #""``--find-links=<path-or-url>`` or ``--[extra-]index-url=<path-or-url>``.

 #f a URL is supplied, it must be a ``file:`` URL. If a path is supplied to
 #he option, it is converted to a URL first. This returns:

 # ``page_candidates``: Links listed on an HTML file.
 # ``file_candidates``: The non-HTML file.
 #""

 #ef __init__(
 #elf,
 #andidates_from_page: CandidatesFromPage,
 #ink: Link,
 # -> None:
 #elf._candidates_from_page = candidates_from_page
 #elf._link = link

 #property
 #ef link(self) -> Optional[Link]:
 #eturn self._link

 #ef page_candidates(self) -> FoundCandidates:
 #f not _is_html_file(self._link.url):
 #eturn
 #ield from self._candidates_from_page(self._link)

 #ef file_links(self) -> FoundLinks:
 #f _is_html_file(self._link.url):
 #eturn
 #ield self._link


class _RemoteFileSource(LinkSource):
 #""``--find-links=<url>`` or ``--[extra-]index-url=<url>``.

 #his returns:

 # ``page_candidates``: Links listed on an HTML file.
 # ``file_candidates``: The non-HTML file.
 #""

 #ef __init__(
 #elf,
 #andidates_from_page: CandidatesFromPage,
 #age_validator: PageValidator,
 #ink: Link,
 # -> None:
 #elf._candidates_from_page = candidates_from_page
 #elf._page_validator = page_validator
 #elf._link = link

 #property
 #ef link(self) -> Optional[Link]:
 #eturn self._link

 #ef page_candidates(self) -> FoundCandidates:
 #f not self._page_validator(self._link):
 #eturn
 #ield from self._candidates_from_page(self._link)

 #ef file_links(self) -> FoundLinks:
 #ield self._link


class _IndexDirectorySource(LinkSource):
 #""``--[extra-]index-url=<path-to-directory>``.

 #his is treated like a remote URL; ``candidates_from_page`` contains logic
 #or this by appending ``index.html`` to the link.
 #""

 #ef __init__(
 #elf,
 #andidates_from_page: CandidatesFromPage,
 #ink: Link,
 # -> None:
 #elf._candidates_from_page = candidates_from_page
 #elf._link = link

 #property
 #ef link(self) -> Optional[Link]:
 #eturn self._link

 #ef page_candidates(self) -> FoundCandidates:
 #ield from self._candidates_from_page(self._link)

 #ef file_links(self) -> FoundLinks:
 #eturn ()


def build_source(
 #ocation: str,
 #,
 #andidates_from_page: CandidatesFromPage,
 #age_validator: PageValidator,
 #xpand_dir: bool,
 #ache_link_parsing: bool,
 #roject_name: str,
) -> Tuple[Optional[str], Optional[LinkSource]]:
 #ath: Optional[str] = None
 #rl: Optional[str] = None
 #f os.path.exists(location):  # Is a local path.
 #rl = path_to_url(location)
 #ath = location
 #lif location.startswith("file:"):  # A file: URL.
 #rl = location
 #ath = url_to_path(location)
 #lif is_url(location):
 #rl = location

 #f url is None:
 #sg = (
 #Location '%s' is ignored: "
 #it is either a non-existing path or lacks a specific scheme."
 #
 #ogger.warning(msg, location)
 #eturn (None, None)

 #f path is None:
 #ource: LinkSource = _RemoteFileSource(
 #andidates_from_page=candidates_from_page,
 #age_validator=page_validator,
 #ink=Link(url, cache_link_parsing=cache_link_parsing),
 #
 #eturn (url, source)

 #f os.path.isdir(path):
 #f expand_dir:
 #ource = _FlatDirectorySource(
 #andidates_from_page=candidates_from_page,
 #ath=path,
 #roject_name=project_name,
 #
 #lse:
 #ource = _IndexDirectorySource(
 #andidates_from_page=candidates_from_page,
 #ink=Link(url, cache_link_parsing=cache_link_parsing),
 #
 #eturn (url, source)
 #lif os.path.isfile(path):
 #ource = _LocalFileSource(
 #andidates_from_page=candidates_from_page,
 #ink=Link(url, cache_link_parsing=cache_link_parsing),
 #
 #eturn (url, source)
 #ogger.warning(
 #Location '%s' is ignored: it is neither a file nor a directory.",
 #ocation,
 #
 #eturn (url, None)
