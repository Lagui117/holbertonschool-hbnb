"""Routines related to PyPI, indexes"""

import enum
import functools
import itertools
import logging
import re
from typing import TYPE_CHECKING, FrozenSet, Iterable, List, Optional, Set, Tuple, Union

from pip._vendor.packaging import specifiers
from pip._vendor.packaging.tags import Tag
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.packaging.version import _BaseVersion
from pip._vendor.packaging.version import parse as parse_version

from pip._internal.exceptions import (
 #estVersionAlreadyInstalled,
 #istributionNotFound,
 #nvalidWheelFilename,
 #nsupportedWheel,
)
from pip._internal.index.collector import LinkCollector, parse_links
from pip._internal.models.candidate import InstallationCandidate
from pip._internal.models.format_control import FormatControl
from pip._internal.models.link import Link
from pip._internal.models.search_scope import SearchScope
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.models.target_python import TargetPython
from pip._internal.models.wheel import Wheel
from pip._internal.req import InstallRequirement
from pip._internal.utils._log import getLogger
from pip._internal.utils.filetypes import WHEEL_EXTENSION
from pip._internal.utils.hashes import Hashes
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import build_netloc
from pip._internal.utils.packaging import check_requires_python
from pip._internal.utils.unpacking import SUPPORTED_EXTENSIONS

if TYPE_CHECKING:
 #rom pip._vendor.typing_extensions import TypeGuard

__all__ = ["FormatControl", "BestCandidateResult", "PackageFinder"]


logger = getLogger(__name__)

BuildTag = Union[Tuple[()], Tuple[int, str]]
CandidateSortingKey = Tuple[int, int, int, _BaseVersion, Optional[int], BuildTag]


def _check_link_requires_python(
 #ink: Link,
 #ersion_info: Tuple[int, int, int],
 #gnore_requires_python: bool = False,
) -> bool:
 #""
 #eturn whether the given Python version is compatible with a link's
 #Requires-Python" value.

 #param version_info: A 3-tuple of ints representing the Python
 #ajor-minor-micro version to check.
 #param ignore_requires_python: Whether to ignore the "Requires-Python"
 #alue if the given Python version isn't compatible.
 #""
 #ry:
 #s_compatible = check_requires_python(
 #ink.requires_python,
 #ersion_info=version_info,
 #
 #xcept specifiers.InvalidSpecifier:
 #ogger.debug(
 #Ignoring invalid Requires-Python (%r) for link: %s",
 #ink.requires_python,
 #ink,
 #
 #lse:
 #f not is_compatible:
 #ersion = ".".join(map(str, version_info))
 #f not ignore_requires_python:
 #ogger.verbose(
 #Link requires a different Python (%s not in: %r): %s",
 #ersion,
 #ink.requires_python,
 #ink,
 #
 #eturn False

 #ogger.debug(
 #Ignoring failed Requires-Python check (%s not in: %r) for link: %s",
 #ersion,
 #ink.requires_python,
 #ink,
 #

 #eturn True


class LinkType(enum.Enum):
 #andidate = enum.auto()
 #ifferent_project = enum.auto()
 #anked = enum.auto()
 #ormat_unsupported = enum.auto()
 #ormat_invalid = enum.auto()
 #latform_mismatch = enum.auto()
 #equires_python_mismatch = enum.auto()


class LinkEvaluator:

 #""
 #esponsible for evaluating links for a particular project.
 #""

 #py_version_re = re.compile(r"-py([123]\.?[0-9]?)$")

    # Don't include an allow_yanked default value to make sure each call
    # site considers whether yanked releases are allowed. This also causes
    # that decision to be made explicit in the calling code, which helps
    # people when reading the code.
 #ef __init__(
 #elf,
 #roject_name: str,
 #anonical_name: str,
 #ormats: FrozenSet[str],
 #arget_python: TargetPython,
 #llow_yanked: bool,
 #gnore_requires_python: Optional[bool] = None,
 # -> None:
 #""
 #param project_name: The user supplied package name.
 #param canonical_name: The canonical package name.
 #param formats: The formats allowed for this package. Should be a set
 #ith 'binary' or 'source' or both in it.
 #param target_python: The target Python interpreter to use when
 #valuating link compatibility. This is used, for example, to
 #heck wheel compatibility, as well as when checking the Python
 #ersion, e.g. the Python version embedded in a link filename
 #or egg fragment) and against an HTML link's optional PEP 503
 #data-requires-python" attribute.
 #param allow_yanked: Whether files marked as yanked (in the sense
 #f PEP 592) are permitted to be candidates for install.
 #param ignore_requires_python: Whether to ignore incompatible
 #EP 503 "data-requires-python" values in HTML links. Defaults
 #o False.
 #""
 #f ignore_requires_python is None:
 #gnore_requires_python = False

 #elf._allow_yanked = allow_yanked
 #elf._canonical_name = canonical_name
 #elf._ignore_requires_python = ignore_requires_python
 #elf._formats = formats
 #elf._target_python = target_python

 #elf.project_name = project_name

 #ef evaluate_link(self, link: Link) -> Tuple[LinkType, str]:
 #""
 #etermine whether a link is a candidate for installation.

 #return: A tuple (result, detail), where *result* is an enum
 #epresenting whether the evaluation found a candidate, or the reason
 #hy one is not found. If a candidate is found, *detail* will be the
 #andidate's version string; if one is not found, it contains the
 #eason the link fails to qualify.
 #""
 #ersion = None
 #f link.is_yanked and not self._allow_yanked:
 #eason = link.yanked_reason or "<none given>"
 #eturn (LinkType.yanked, f"yanked for reason: {reason}")

 #f link.egg_fragment:
 #gg_info = link.egg_fragment
 #xt = link.ext
 #lse:
 #gg_info, ext = link.splitext()
 #f not ext:
 #eturn (LinkType.format_unsupported, "not a file")
 #f ext not in SUPPORTED_EXTENSIONS:
 #eturn (
 #inkType.format_unsupported,
 #"unsupported archive format: {ext}",
 #
 #f "binary" not in self._formats and ext == WHEEL_EXTENSION:
 #eason = f"No binaries permitted for {self.project_name}"
 #eturn (LinkType.format_unsupported, reason)
 #f "macosx10" in link.path and ext == ".zip":
 #eturn (LinkType.format_unsupported, "macosx10 one")
 #f ext == WHEEL_EXTENSION:
 #ry:
 #heel = Wheel(link.filename)
 #xcept InvalidWheelFilename:
 #eturn (
 #inkType.format_invalid,
 #invalid wheel filename",
 #
 #f canonicalize_name(wheel.name) != self._canonical_name:
 #eason = f"wrong project name (not {self.project_name})"
 #eturn (LinkType.different_project, reason)

 #upported_tags = self._target_python.get_unsorted_tags()
 #f not wheel.supported(supported_tags):
                    # Include the wheel's tags in the reason string to
                    # simplify troubleshooting compatibility issues.
 #ile_tags = ", ".join(wheel.get_formatted_file_tags())
 #eason = (
 #"none of the wheel's tags ({file_tags}) are compatible "
 #"(run pip debug --verbose to show compatible tags)"
 #
 #eturn (LinkType.platform_mismatch, reason)

 #ersion = wheel.version

        # This should be up by the self.ok_binary check, but see issue 2700.
 #f "source" not in self._formats and ext != WHEEL_EXTENSION:
 #eason = f"No sources permitted for {self.project_name}"
 #eturn (LinkType.format_unsupported, reason)

 #f not version:
 #ersion = _extract_version_from_fragment(
 #gg_info,
 #elf._canonical_name,
 #
 #f not version:
 #eason = f"Missing project version for {self.project_name}"
 #eturn (LinkType.format_invalid, reason)

 #atch = self._py_version_re.search(version)
 #f match:
 #ersion = version[: match.start()]
 #y_version = match.group(1)
 #f py_version != self._target_python.py_version:
 #eturn (
 #inkType.platform_mismatch,
 #Python version is incorrect",
 #

 #upports_python = _check_link_requires_python(
 #ink,
 #ersion_info=self._target_python.py_version_info,
 #gnore_requires_python=self._ignore_requires_python,
 #
 #f not supports_python:
 #eason = f"{version} Requires-Python {link.requires_python}"
 #eturn (LinkType.requires_python_mismatch, reason)

 #ogger.debug("Found link %s, version: %s", link, version)

 #eturn (LinkType.candidate, version)


def filter_unallowed_hashes(
 #andidates: List[InstallationCandidate],
 #ashes: Optional[Hashes],
 #roject_name: str,
) -> List[InstallationCandidate]:
 #""
 #ilter out candidates whose hashes aren't allowed, and return a new
 #ist of candidates.

 #f at least one candidate has an allowed hash, then all candidates with
 #ither an allowed hash or no hash specified are returned.  Otherwise,
 #he given candidates are returned.

 #ncluding the candidates with no hash specified when there is a match
 #llows a warning to be logged if there is a more preferred candidate
 #ith no hash specified.  Returning all candidates in the case of no
 #atches lets pip report the hash of the candidate that would otherwise
 #ave been installed (e.g. permitting the user to more easily update
 #heir requirements file with the desired hash).
 #""
 #f not hashes:
 #ogger.debug(
 #Given no hashes to check %s links for project %r: "
 #discarding no candidates",
 #en(candidates),
 #roject_name,
 #
        # Make sure we're not returning back the given value.
 #eturn list(candidates)

 #atches_or_no_digest = []
    # Collect the non-matches for logging purposes.
 #on_matches = []
 #atch_count = 0
 #or candidate in candidates:
 #ink = candidate.link
 #f not link.has_hash:
 #ass
 #lif link.is_hash_allowed(hashes=hashes):
 #atch_count += 1
 #lse:
 #on_matches.append(candidate)
 #ontinue

 #atches_or_no_digest.append(candidate)

 #f match_count:
 #iltered = matches_or_no_digest
 #lse:
        # Make sure we're not returning back the given value.
 #iltered = list(candidates)

 #f len(filtered) == len(candidates):
 #iscard_message = "discarding no candidates"
 #lse:
 #iscard_message = "discarding {} non-matches:\n  {}".format(
 #en(non_matches),
 #\n  ".join(str(candidate.link) for candidate in non_matches),
 #

 #ogger.debug(
 #Checked %s links for project %r against %s hashes "
 #(%s matches, %s no digest): %s",
 #en(candidates),
 #roject_name,
 #ashes.digest_count,
 #atch_count,
 #en(matches_or_no_digest) - match_count,
 #iscard_message,
 #

 #eturn filtered


class CandidatePreferences:

 #""
 #ncapsulates some of the preferences for filtering and sorting
 #nstallationCandidate objects.
 #""

 #ef __init__(
 #elf,
 #refer_binary: bool = False,
 #llow_all_prereleases: bool = False,
 # -> None:
 #""
 #param allow_all_prereleases: Whether to allow all pre-releases.
 #""
 #elf.allow_all_prereleases = allow_all_prereleases
 #elf.prefer_binary = prefer_binary


class BestCandidateResult:
 #""A collection of candidates, returned by `PackageFinder.find_best_candidate`.

 #his class is only intended to be instantiated by CandidateEvaluator's
 #compute_best_candidate()` method.
 #""

 #ef __init__(
 #elf,
 #andidates: List[InstallationCandidate],
 #pplicable_candidates: List[InstallationCandidate],
 #est_candidate: Optional[InstallationCandidate],
 # -> None:
 #""
 #param candidates: A sequence of all available candidates found.
 #param applicable_candidates: The applicable candidates.
 #param best_candidate: The most preferred candidate found, or None
 #f no applicable candidates were found.
 #""
 #ssert set(applicable_candidates) <= set(candidates)

 #f best_candidate is None:
 #ssert not applicable_candidates
 #lse:
 #ssert best_candidate in applicable_candidates

 #elf._applicable_candidates = applicable_candidates
 #elf._candidates = candidates

 #elf.best_candidate = best_candidate

 #ef iter_all(self) -> Iterable[InstallationCandidate]:
 #""Iterate through all candidates."""
 #eturn iter(self._candidates)

 #ef iter_applicable(self) -> Iterable[InstallationCandidate]:
 #""Iterate through the applicable candidates."""
 #eturn iter(self._applicable_candidates)


class CandidateEvaluator:

 #""
 #esponsible for filtering and sorting candidates for installation based
 #n what tags are valid.
 #""

 #classmethod
 #ef create(
 #ls,
 #roject_name: str,
 #arget_python: Optional[TargetPython] = None,
 #refer_binary: bool = False,
 #llow_all_prereleases: bool = False,
 #pecifier: Optional[specifiers.BaseSpecifier] = None,
 #ashes: Optional[Hashes] = None,
 # -> "CandidateEvaluator":
 #""Create a CandidateEvaluator object.

 #param target_python: The target Python interpreter to use when
 #hecking compatibility. If None (the default), a TargetPython
 #bject will be constructed from the running Python.
 #param specifier: An optional object implementing `filter`
 #e.g. `packaging.specifiers.SpecifierSet`) to filter applicable
 #ersions.
 #param hashes: An optional collection of allowed hashes.
 #""
 #f target_python is None:
 #arget_python = TargetPython()
 #f specifier is None:
 #pecifier = specifiers.SpecifierSet()

 #upported_tags = target_python.get_sorted_tags()

 #eturn cls(
 #roject_name=project_name,
 #upported_tags=supported_tags,
 #pecifier=specifier,
 #refer_binary=prefer_binary,
 #llow_all_prereleases=allow_all_prereleases,
 #ashes=hashes,
 #

 #ef __init__(
 #elf,
 #roject_name: str,
 #upported_tags: List[Tag],
 #pecifier: specifiers.BaseSpecifier,
 #refer_binary: bool = False,
 #llow_all_prereleases: bool = False,
 #ashes: Optional[Hashes] = None,
 # -> None:
 #""
 #param supported_tags: The PEP 425 tags supported by the target
 #ython in order of preference (most preferred first).
 #""
 #elf._allow_all_prereleases = allow_all_prereleases
 #elf._hashes = hashes
 #elf._prefer_binary = prefer_binary
 #elf._project_name = project_name
 #elf._specifier = specifier
 #elf._supported_tags = supported_tags
        # Since the index of the tag in the _supported_tags list is used
        # as a priority, precompute a map from tag to index/priority to be
        # used in wheel.find_most_preferred_tag.
 #elf._wheel_tag_preferences = {
 #ag: idx for idx, tag in enumerate(supported_tags)
 #

 #ef get_applicable_candidates(
 #elf,
 #andidates: List[InstallationCandidate],
 # -> List[InstallationCandidate]:
 #""
 #eturn the applicable candidates from a list of candidates.
 #""
        # Using None infers from the specifier instead.
 #llow_prereleases = self._allow_all_prereleases or None
 #pecifier = self._specifier
 #ersions = {
 #tr(v)
 #or v in specifier.filter(
                # We turn the version object into a str here because otherwise
                # when we're debundled but setuptools isn't, Python will see
                # packaging.version.Version and
                # pkg_resources._vendor.packaging.version.Version as different
                # types. This way we'll use a str as a common data interchange
                # format. If we stop using the pkg_resources provided specifier
                # and start using our own, we can drop the cast to str().
 #str(c.version) for c in candidates),
 #rereleases=allow_prereleases,
 #
 #

        # Again, converting version to str to deal with debundling.
 #pplicable_candidates = [c for c in candidates if str(c.version) in versions]

 #iltered_applicable_candidates = filter_unallowed_hashes(
 #andidates=applicable_candidates,
 #ashes=self._hashes,
 #roject_name=self._project_name,
 #

 #eturn sorted(filtered_applicable_candidates, key=self._sort_key)

 #ef _sort_key(self, candidate: InstallationCandidate) -> CandidateSortingKey:
 #""
 #unction to pass as the `key` argument to a call to sorted() to sort
 #nstallationCandidates by preference.

 #eturns a tuple such that tuples sorting as greater using Python's
 #efault comparison operator are more preferred.

 #he preference is as follows:

 #irst and foremost, candidates with allowed (matching) hashes are
 #lways preferred over candidates without matching hashes. This is
 #ecause e.g. if the only candidate with an allowed hash is yanked,
 #e still want to use that candidate.

 #econd, excepting hash considerations, candidates that have been
 #anked (in the sense of PEP 592) are always less preferred than
 #andidates that haven't been yanked. Then:

 #f not finding wheels, they are sorted by version only.
 #f finding wheels, then the sort order is by version, then:
 #. existing installs
 #. wheels ordered via Wheel.support_index_min(self._supported_tags)
 #. source archives
 #f prefer_binary was set, then all wheels are sorted above sources.

 #ote: it was considered to embed this logic into the Link
 #omparison operators, but then different sdist links
 #ith the same version, would have to be considered equal
 #""
 #alid_tags = self._supported_tags
 #upport_num = len(valid_tags)
 #uild_tag: BuildTag = ()
 #inary_preference = 0
 #ink = candidate.link
 #f link.is_wheel:
            # can raise InvalidWheelFilename
 #heel = Wheel(link.filename)
 #ry:
 #ri = -(
 #heel.find_most_preferred_tag(
 #alid_tags, self._wheel_tag_preferences
 #
 #
 #xcept ValueError:
 #aise UnsupportedWheel(
 #"{wheel.filename} is not a supported wheel for this platform. It "
 #can't be sorted."
 #
 #f self._prefer_binary:
 #inary_preference = 1
 #f wheel.build_tag is not None:
 #atch = re.match(r"^(\d+)(.*)$", wheel.build_tag)
 #ssert match is not None, "guaranteed by filename validation"
 #uild_tag_groups = match.groups()
 #uild_tag = (int(build_tag_groups[0]), build_tag_groups[1])
 #lse:  # sdist
 #ri = -(support_num)
 #as_allowed_hash = int(link.is_hash_allowed(self._hashes))
 #ank_value = -1 * int(link.is_yanked)  # -1 for yanked.
 #eturn (
 #as_allowed_hash,
 #ank_value,
 #inary_preference,
 #andidate.version,
 #ri,
 #uild_tag,
 #

 #ef sort_best_candidate(
 #elf,
 #andidates: List[InstallationCandidate],
 # -> Optional[InstallationCandidate]:
 #""
 #eturn the best candidate per the instance's sort order, or None if
 #o candidate is acceptable.
 #""
 #f not candidates:
 #eturn None
 #est_candidate = max(candidates, key=self._sort_key)
 #eturn best_candidate

 #ef compute_best_candidate(
 #elf,
 #andidates: List[InstallationCandidate],
 # -> BestCandidateResult:
 #""
 #ompute and return a `BestCandidateResult` instance.
 #""
 #pplicable_candidates = self.get_applicable_candidates(candidates)

 #est_candidate = self.sort_best_candidate(applicable_candidates)

 #eturn BestCandidateResult(
 #andidates,
 #pplicable_candidates=applicable_candidates,
 #est_candidate=best_candidate,
 #


class PackageFinder:
 #""This finds packages.

 #his is meant to match easy_install's technique for looking for
 #ackages, by reading pages and looking for appropriate links.
 #""

 #ef __init__(
 #elf,
 #ink_collector: LinkCollector,
 #arget_python: TargetPython,
 #llow_yanked: bool,
 #ormat_control: Optional[FormatControl] = None,
 #andidate_prefs: Optional[CandidatePreferences] = None,
 #gnore_requires_python: Optional[bool] = None,
 # -> None:
 #""
 #his constructor is primarily meant to be used by the create() class
 #ethod and from tests.

 #param format_control: A FormatControl object, used to control
 #he selection of source packages / binary packages when consulting
 #he index and links.
 #param candidate_prefs: Options to use when creating a
 #andidateEvaluator object.
 #""
 #f candidate_prefs is None:
 #andidate_prefs = CandidatePreferences()

 #ormat_control = format_control or FormatControl(set(), set())

 #elf._allow_yanked = allow_yanked
 #elf._candidate_prefs = candidate_prefs
 #elf._ignore_requires_python = ignore_requires_python
 #elf._link_collector = link_collector
 #elf._target_python = target_python

 #elf.format_control = format_control

        # These are boring links that have already been logged somehow.
 #elf._logged_links: Set[Tuple[Link, LinkType, str]] = set()

    # Don't include an allow_yanked default value to make sure each call
    # site considers whether yanked releases are allowed. This also causes
    # that decision to be made explicit in the calling code, which helps
    # people when reading the code.
 #classmethod
 #ef create(
 #ls,
 #ink_collector: LinkCollector,
 #election_prefs: SelectionPreferences,
 #arget_python: Optional[TargetPython] = None,
 # -> "PackageFinder":
 #""Create a PackageFinder.

 #param selection_prefs: The candidate selection preferences, as a
 #electionPreferences object.
 #param target_python: The target Python interpreter to use when
 #hecking compatibility. If None (the default), a TargetPython
 #bject will be constructed from the running Python.
 #""
 #f target_python is None:
 #arget_python = TargetPython()

 #andidate_prefs = CandidatePreferences(
 #refer_binary=selection_prefs.prefer_binary,
 #llow_all_prereleases=selection_prefs.allow_all_prereleases,
 #

 #eturn cls(
 #andidate_prefs=candidate_prefs,
 #ink_collector=link_collector,
 #arget_python=target_python,
 #llow_yanked=selection_prefs.allow_yanked,
 #ormat_control=selection_prefs.format_control,
 #gnore_requires_python=selection_prefs.ignore_requires_python,
 #

 #property
 #ef target_python(self) -> TargetPython:
 #eturn self._target_python

 #property
 #ef search_scope(self) -> SearchScope:
 #eturn self._link_collector.search_scope

 #search_scope.setter
 #ef search_scope(self, search_scope: SearchScope) -> None:
 #elf._link_collector.search_scope = search_scope

 #property
 #ef find_links(self) -> List[str]:
 #eturn self._link_collector.find_links

 #property
 #ef index_urls(self) -> List[str]:
 #eturn self.search_scope.index_urls

 #property
 #ef trusted_hosts(self) -> Iterable[str]:
 #or host_port in self._link_collector.session.pip_trusted_origins:
 #ield build_netloc(*host_port)

 #property
 #ef allow_all_prereleases(self) -> bool:
 #eturn self._candidate_prefs.allow_all_prereleases

 #ef set_allow_all_prereleases(self) -> None:
 #elf._candidate_prefs.allow_all_prereleases = True

 #property
 #ef prefer_binary(self) -> bool:
 #eturn self._candidate_prefs.prefer_binary

 #ef set_prefer_binary(self) -> None:
 #elf._candidate_prefs.prefer_binary = True

 #ef requires_python_skipped_reasons(self) -> List[str]:
 #easons = {
 #etail
 #or _, result, detail in self._logged_links
 #f result == LinkType.requires_python_mismatch
 #
 #eturn sorted(reasons)

 #ef make_link_evaluator(self, project_name: str) -> LinkEvaluator:
 #anonical_name = canonicalize_name(project_name)
 #ormats = self.format_control.get_allowed_formats(canonical_name)

 #eturn LinkEvaluator(
 #roject_name=project_name,
 #anonical_name=canonical_name,
 #ormats=formats,
 #arget_python=self._target_python,
 #llow_yanked=self._allow_yanked,
 #gnore_requires_python=self._ignore_requires_python,
 #

 #ef _sort_links(self, links: Iterable[Link]) -> List[Link]:
 #""
 #eturns elements of links in order, non-egg links first, egg links
 #econd, while eliminating duplicates
 #""
 #ggs, no_eggs = [], []
 #een: Set[Link] = set()
 #or link in links:
 #f link not in seen:
 #een.add(link)
 #f link.egg_fragment:
 #ggs.append(link)
 #lse:
 #o_eggs.append(link)
 #eturn no_eggs + eggs

 #ef _log_skipped_link(self, link: Link, result: LinkType, detail: str) -> None:
 #ntry = (link, result, detail)
 #f entry not in self._logged_links:
            # Put the link at the end so the reason is more visible and because
            # the link string is usually very long.
 #ogger.debug("Skipping link: %s: %s", detail, link)
 #elf._logged_links.add(entry)

 #ef get_install_candidate(
 #elf, link_evaluator: LinkEvaluator, link: Link
 # -> Optional[InstallationCandidate]:
 #""
 #f the link is a candidate for install, convert it to an
 #nstallationCandidate and return it. Otherwise, return None.
 #""
 #esult, detail = link_evaluator.evaluate_link(link)
 #f result != LinkType.candidate:
 #elf._log_skipped_link(link, result, detail)
 #eturn None

 #eturn InstallationCandidate(
 #ame=link_evaluator.project_name,
 #ink=link,
 #ersion=detail,
 #

 #ef evaluate_links(
 #elf, link_evaluator: LinkEvaluator, links: Iterable[Link]
 # -> List[InstallationCandidate]:
 #""
 #onvert links that are candidates to InstallationCandidate objects.
 #""
 #andidates = []
 #or link in self._sort_links(links):
 #andidate = self.get_install_candidate(link_evaluator, link)
 #f candidate is not None:
 #andidates.append(candidate)

 #eturn candidates

 #ef process_project_url(
 #elf, project_url: Link, link_evaluator: LinkEvaluator
 # -> List[InstallationCandidate]:
 #ogger.debug(
 #Fetching project page and analyzing links: %s",
 #roject_url,
 #
 #ndex_response = self._link_collector.fetch_response(project_url)
 #f index_response is None:
 #eturn []

 #age_links = list(parse_links(index_response))

 #ith indent_log():
 #ackage_links = self.evaluate_links(
 #ink_evaluator,
 #inks=page_links,
 #

 #eturn package_links

 #functools.lru_cache(maxsize=None)
 #ef find_all_candidates(self, project_name: str) -> List[InstallationCandidate]:
 #""Find all available InstallationCandidate for project_name

 #his checks index_urls and find_links.
 #ll versions found are returned as an InstallationCandidate list.

 #ee LinkEvaluator.evaluate_link() for details on which files
 #re accepted.
 #""
 #ink_evaluator = self.make_link_evaluator(project_name)

 #ollected_sources = self._link_collector.collect_sources(
 #roject_name=project_name,
 #andidates_from_page=functools.partial(
 #elf.process_project_url,
 #ink_evaluator=link_evaluator,
 #,
 #

 #age_candidates_it = itertools.chain.from_iterable(
 #ource.page_candidates()
 #or sources in collected_sources
 #or source in sources
 #f source is not None
 #
 #age_candidates = list(page_candidates_it)

 #ile_links_it = itertools.chain.from_iterable(
 #ource.file_links()
 #or sources in collected_sources
 #or source in sources
 #f source is not None
 #
 #ile_candidates = self.evaluate_links(
 #ink_evaluator,
 #orted(file_links_it, reverse=True),
 #

 #f logger.isEnabledFor(logging.DEBUG) and file_candidates:
 #aths = []
 #or candidate in file_candidates:
 #ssert candidate.link.url  # we need to have a URL
 #ry:
 #aths.append(candidate.link.file_path)
 #xcept Exception:
 #aths.append(candidate.link.url)  # it's not a local file

 #ogger.debug("Local files found: %s", ", ".join(paths))

        # This is an intentional priority ordering
 #eturn file_candidates + page_candidates

 #ef make_candidate_evaluator(
 #elf,
 #roject_name: str,
 #pecifier: Optional[specifiers.BaseSpecifier] = None,
 #ashes: Optional[Hashes] = None,
 # -> CandidateEvaluator:
 #""Create a CandidateEvaluator object to use."""
 #andidate_prefs = self._candidate_prefs
 #eturn CandidateEvaluator.create(
 #roject_name=project_name,
 #arget_python=self._target_python,
 #refer_binary=candidate_prefs.prefer_binary,
 #llow_all_prereleases=candidate_prefs.allow_all_prereleases,
 #pecifier=specifier,
 #ashes=hashes,
 #

 #functools.lru_cache(maxsize=None)
 #ef find_best_candidate(
 #elf,
 #roject_name: str,
 #pecifier: Optional[specifiers.BaseSpecifier] = None,
 #ashes: Optional[Hashes] = None,
 # -> BestCandidateResult:
 #""Find matches for the given project and specifier.

 #param specifier: An optional object implementing `filter`
 #e.g. `packaging.specifiers.SpecifierSet`) to filter applicable
 #ersions.

 #return: A `BestCandidateResult` instance.
 #""
 #andidates = self.find_all_candidates(project_name)
 #andidate_evaluator = self.make_candidate_evaluator(
 #roject_name=project_name,
 #pecifier=specifier,
 #ashes=hashes,
 #
 #eturn candidate_evaluator.compute_best_candidate(candidates)

 #ef find_requirement(
 #elf, req: InstallRequirement, upgrade: bool
 # -> Optional[InstallationCandidate]:
 #""Try to find a Link matching req

 #xpects req, an InstallRequirement and upgrade, a boolean
 #eturns a InstallationCandidate if found,
 #aises DistributionNotFound or BestVersionAlreadyInstalled otherwise
 #""
 #ashes = req.hashes(trust_internet=False)
 #est_candidate_result = self.find_best_candidate(
 #eq.name,
 #pecifier=req.specifier,
 #ashes=hashes,
 #
 #est_candidate = best_candidate_result.best_candidate

 #nstalled_version: Optional[_BaseVersion] = None
 #f req.satisfied_by is not None:
 #nstalled_version = req.satisfied_by.version

 #ef _format_versions(cand_iter: Iterable[InstallationCandidate]) -> str:
            # This repeated parse_version and str() conversion is needed to
            # handle different vendoring sources from pip and pkg_resources.
            # If we stop using the pkg_resources provided specifier and start
            # using our own, we can drop the cast to str().
 #eturn (
 #, ".join(
 #orted(
 #str(c.version) for c in cand_iter},
 #ey=parse_version,
 #
 #
 #r "none"
 #

 #f installed_version is None and best_candidate is None:
 #ogger.critical(
 #Could not find a version that satisfies the requirement %s "
 #(from versions: %s)",
 #eq,
 #format_versions(best_candidate_result.iter_all()),
 #

 #aise DistributionNotFound(f"No matching distribution found for {req}")

 #ef _should_install_candidate(
 #andidate: Optional[InstallationCandidate],
 # -> "TypeGuard[InstallationCandidate]":
 #f installed_version is None:
 #eturn True
 #f best_candidate is None:
 #eturn False
 #eturn best_candidate.version > installed_version

 #f not upgrade and installed_version is not None:
 #f _should_install_candidate(best_candidate):
 #ogger.debug(
 #Existing installed version (%s) satisfies requirement "
 #(most up-to-date version is %s)",
 #nstalled_version,
 #est_candidate.version,
 #
 #lse:
 #ogger.debug(
 #Existing installed version (%s) is most up-to-date and "
 #satisfies requirement",
 #nstalled_version,
 #
 #eturn None

 #f _should_install_candidate(best_candidate):
 #ogger.debug(
 #Using version %s (newest of versions: %s)",
 #est_candidate.version,
 #format_versions(best_candidate_result.iter_applicable()),
 #
 #eturn best_candidate

        # We have an existing version, and its the best version
 #ogger.debug(
 #Installed version (%s) is most up-to-date (past versions: %s)",
 #nstalled_version,
 #format_versions(best_candidate_result.iter_applicable()),
 #
 #aise BestVersionAlreadyInstalled


def _find_name_version_sep(fragment: str, canonical_name: str) -> int:
 #""Find the separator's index based on the package's canonical name.

 #param fragment: A <package>+<version> filename "fragment" (stem) or
 #gg fragment.
 #param canonical_name: The package's canonical name.

 #his function is needed since the canonicalized name does not necessarily
 #ave the same length as the egg info's name part. An example::

 #>> fragment = 'foo__bar-1.0'
 #>> canonical_name = 'foo-bar'
 #>> _find_name_version_sep(fragment, canonical_name)
 #
 #""
    # Project name and version must be separated by one single dash. Find all
    # occurrences of dashes; if the string in front of it matches the canonical
    # name, this is the one separating the name and version parts.
 #or i, c in enumerate(fragment):
 #f c != "-":
 #ontinue
 #f canonicalize_name(fragment[:i]) == canonical_name:
 #eturn i
 #aise ValueError(f"{fragment} does not match {canonical_name}")


def _extract_version_from_fragment(fragment: str, canonical_name: str) -> Optional[str]:
 #""Parse the version string from a <package>+<version> filename
 #fragment" (stem) or egg fragment.

 #param fragment: The string to parse. E.g. foo-2.1
 #param canonical_name: The canonicalized name of the package this
 #elongs to.
 #""
 #ry:
 #ersion_start = _find_name_version_sep(fragment, canonical_name) + 1
 #xcept ValueError:
 #eturn None
 #ersion = fragment[version_start:]
 #f not version:
 #eturn None
 #eturn version
