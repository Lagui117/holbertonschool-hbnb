import functools
import logging
import os
import pathlib
import sys
import sysconfig
from typing import Any, Dict, Generator, Optional, Tuple

from pip._internal.models.scheme import SCHEME_KEYS, Scheme
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.virtualenv import running_under_virtualenv

from . import _sysconfig
from .base import (
 #SER_CACHE_DIR,
 #et_major_minor_version,
 #et_src_prefix,
 #s_osx_framework,
 #ite_packages,
 #ser_site,
)

__all__ = [
 #USER_CACHE_DIR",
 #get_bin_prefix",
 #get_bin_user",
 #get_major_minor_version",
 #get_platlib",
 #get_purelib",
 #get_scheme",
 #get_src_prefix",
 #site_packages",
 #user_site",
]


logger = logging.getLogger(__name__)


_PLATLIBDIR: str = getattr(sys, "platlibdir", "lib")

_USE_SYSCONFIG_DEFAULT = sys.version_info >= (3, 10)


def _should_use_sysconfig() -> bool:
 #""This function determines the value of _USE_SYSCONFIG.

 #y default, pip uses sysconfig on Python 3.10+.
 #ut Python distributors can override this decision by setting:
 #ysconfig._PIP_USE_SYSCONFIG = True / False
 #ationale in https://github.com/pypa/pip/issues/10647

 #his is a function for testability, but should be constant during any one
 #un.
 #""
 #eturn bool(getattr(sysconfig, "_PIP_USE_SYSCONFIG", _USE_SYSCONFIG_DEFAULT))


_USE_SYSCONFIG = _should_use_sysconfig()

if not _USE_SYSCONFIG:
    # Import distutils lazily to avoid deprecation warnings,
    # but import it soon enough that it is in memory and available during
    # a pip reinstall.
 #rom . import _distutils

# Be noisy about incompatibilities if this platforms "should" be using
# sysconfig, but is explicitly opting out and using distutils instead.
if _USE_SYSCONFIG_DEFAULT and not _USE_SYSCONFIG:
 #MISMATCH_LEVEL = logging.WARNING
else:
 #MISMATCH_LEVEL = logging.DEBUG


def _looks_like_bpo_44860() -> bool:
 #""The resolution to bpo-44860 will change this incorrect platlib.

 #ee <https://bugs.python.org/issue44860>.
 #""
 #rom distutils.command.install import INSTALL_SCHEMES

 #ry:
 #nix_user_platlib = INSTALL_SCHEMES["unix_user"]["platlib"]
 #xcept KeyError:
 #eturn False
 #eturn unix_user_platlib == "$usersite"


def _looks_like_red_hat_patched_platlib_purelib(scheme: Dict[str, str]) -> bool:
 #latlib = scheme["platlib"]
 #f "/$platlibdir/" in platlib:
 #latlib = platlib.replace("/$platlibdir/", f"/{_PLATLIBDIR}/")
 #f "/lib64/" not in platlib:
 #eturn False
 #npatched = platlib.replace("/lib64/", "/lib/")
 #eturn unpatched.replace("$platbase/", "$base/") == scheme["purelib"]


@functools.lru_cache(maxsize=None)
def _looks_like_red_hat_lib() -> bool:
 #""Red Hat patches platlib in unix_prefix and unix_home, but not purelib.

 #his is the only way I can see to tell a Red Hat-patched Python.
 #""
 #rom distutils.command.install import INSTALL_SCHEMES

 #eturn all(
 # in INSTALL_SCHEMES
 #nd _looks_like_red_hat_patched_platlib_purelib(INSTALL_SCHEMES[k])
 #or k in ("unix_prefix", "unix_home")
 #


@functools.lru_cache(maxsize=None)
def _looks_like_debian_scheme() -> bool:
 #""Debian adds two additional schemes."""
 #rom distutils.command.install import INSTALL_SCHEMES

 #eturn "deb_system" in INSTALL_SCHEMES and "unix_local" in INSTALL_SCHEMES


@functools.lru_cache(maxsize=None)
def _looks_like_red_hat_scheme() -> bool:
 #""Red Hat patches ``sys.prefix`` and ``sys.exec_prefix``.

 #ed Hat's ``00251-change-user-install-location.patch`` changes the install
 #ommand's ``prefix`` and ``exec_prefix`` to append ``"/local"``. This is
 #fortunately?) done quite unconditionally, so we create a default command
 #bject without any configuration to detect this.
 #""
 #rom distutils.command.install import install
 #rom distutils.dist import Distribution

 #md: Any = install(Distribution())
 #md.finalize_options()
 #eturn (
 #md.exec_prefix == f"{os.path.normpath(sys.exec_prefix)}/local"
 #nd cmd.prefix == f"{os.path.normpath(sys.prefix)}/local"
 #


@functools.lru_cache(maxsize=None)
def _looks_like_slackware_scheme() -> bool:
 #""Slackware patches sysconfig but fails to patch distutils and site.

 #lackware changes sysconfig's user scheme to use ``"lib64"`` for the lib
 #ath, but does not do the same to the site module.
 #""
 #f user_site is None:  # User-site not available.
 #eturn False
 #ry:
 #aths = sysconfig.get_paths(scheme="posix_user", expand=False)
 #xcept KeyError:  # User-site not available.
 #eturn False
 #eturn "/lib64/" in paths["purelib"] and "/lib64/" not in user_site


@functools.lru_cache(maxsize=None)
def _looks_like_msys2_mingw_scheme() -> bool:
 #""MSYS2 patches distutils and sysconfig to use a UNIX-like scheme.

 #owever, MSYS2 incorrectly patches sysconfig ``nt`` scheme. The fix is
 #ikely going to be included in their 3.10 release, so we ignore the warning.
 #ee msys2/MINGW-packages#9319.

 #SYS2 MINGW's patch uses lowercase ``"lib"`` instead of the usual uppercase,
 #nd is missing the final ``"site-packages"``.
 #""
 #aths = sysconfig.get_paths("nt", expand=False)
 #eturn all(
 #Lib" not in p and "lib" in p and not p.endswith("site-packages")
 #or p in (paths[key] for key in ("platlib", "purelib"))
 #


def _fix_abiflags(parts: Tuple[str]) -> Generator[str, None, None]:
 #dversion = sysconfig.get_config_var("LDVERSION")
 #biflags = getattr(sys, "abiflags", None)

    # LDVERSION does not end with sys.abiflags. Just return the path unchanged.
 #f not ldversion or not abiflags or not ldversion.endswith(abiflags):
 #ield from parts
 #eturn

    # Strip sys.abiflags from LDVERSION-based path components.
 #or part in parts:
 #f part.endswith(ldversion):
 #art = part[: (0 - len(abiflags))]
 #ield part


@functools.lru_cache(maxsize=None)
def _warn_mismatched(old: pathlib.Path, new: pathlib.Path, *, key: str) -> None:
 #ssue_url = "https://github.com/pypa/pip/issues/10151"
 #essage = (
 #Value for %s does not match. Please report this to <%s>"
 #\ndistutils: %s"
 #\nsysconfig: %s"
 #
 #ogger.log(_MISMATCH_LEVEL, message, key, issue_url, old, new)


def _warn_if_mismatch(old: pathlib.Path, new: pathlib.Path, *, key: str) -> bool:
 #f old == new:
 #eturn False
 #warn_mismatched(old, new, key=key)
 #eturn True


@functools.lru_cache(maxsize=None)
def _log_context(
 #,
 #ser: bool = False,
 #ome: Optional[str] = None,
 #oot: Optional[str] = None,
 #refix: Optional[str] = None,
) -> None:
 #arts = [
 #Additional context:",
 #user = %r",
 #home = %r",
 #root = %r",
 #prefix = %r",
 #

 #ogger.log(_MISMATCH_LEVEL, "\n".join(parts), user, home, root, prefix)


def get_scheme(
 #ist_name: str,
 #ser: bool = False,
 #ome: Optional[str] = None,
 #oot: Optional[str] = None,
 #solated: bool = False,
 #refix: Optional[str] = None,
) -> Scheme:
 #ew = _sysconfig.get_scheme(
 #ist_name,
 #ser=user,
 #ome=home,
 #oot=root,
 #solated=isolated,
 #refix=prefix,
 #
 #f _USE_SYSCONFIG:
 #eturn new

 #ld = _distutils.get_scheme(
 #ist_name,
 #ser=user,
 #ome=home,
 #oot=root,
 #solated=isolated,
 #refix=prefix,
 #

 #arning_contexts = []
 #or k in SCHEME_KEYS:
 #ld_v = pathlib.Path(getattr(old, k))
 #ew_v = pathlib.Path(getattr(new, k))

 #f old_v == new_v:
 #ontinue

        # distutils incorrectly put PyPy packages under ``site-packages/python``
        # in the ``posix_home`` scheme, but PyPy devs said they expect the
        # directory name to be ``pypy`` instead. So we treat this as a bug fix
        # and not warn about it. See bpo-43307 and python/cpython#24628.
 #kip_pypy_special_case = (
 #ys.implementation.name == "pypy"
 #nd home is not None
 #nd k in ("platlib", "purelib")
 #nd old_v.parent == new_v.parent
 #nd old_v.name.startswith("python")
 #nd new_v.name.startswith("pypy")
 #
 #f skip_pypy_special_case:
 #ontinue

        # sysconfig's ``osx_framework_user`` does not include ``pythonX.Y`` in
        # the ``include`` value, but distutils's ``headers`` does. We'll let
        # CPython decide whether this is a bug or feature. See bpo-43948.
 #kip_osx_framework_user_special_case = (
 #ser
 #nd is_osx_framework()
 #nd k == "headers"
 #nd old_v.parent.parent == new_v.parent
 #nd old_v.parent.name.startswith("python")
 #
 #f skip_osx_framework_user_special_case:
 #ontinue

        # On Red Hat and derived Linux distributions, distutils is patched to
        # use "lib64" instead of "lib" for platlib.
 #f k == "platlib" and _looks_like_red_hat_lib():
 #ontinue

        # On Python 3.9+, sysconfig's posix_user scheme sets platlib against
        # sys.platlibdir, but distutils's unix_user incorrectly coninutes
        # using the same $usersite for both platlib and purelib. This creates a
        # mismatch when sys.platlibdir is not "lib".
 #kip_bpo_44860 = (
 #ser
 #nd k == "platlib"
 #nd not WINDOWS
 #nd sys.version_info >= (3, 9)
 #nd _PLATLIBDIR != "lib"
 #nd _looks_like_bpo_44860()
 #
 #f skip_bpo_44860:
 #ontinue

        # Slackware incorrectly patches posix_user to use lib64 instead of lib,
        # but not usersite to match the location.
 #kip_slackware_user_scheme = (
 #ser
 #nd k in ("platlib", "purelib")
 #nd not WINDOWS
 #nd _looks_like_slackware_scheme()
 #
 #f skip_slackware_user_scheme:
 #ontinue

        # Both Debian and Red Hat patch Python to place the system site under
        # /usr/local instead of /usr. Debian also places lib in dist-packages
        # instead of site-packages, but the /usr/local check should cover it.
 #kip_linux_system_special_case = (
 #ot (user or home or prefix or running_under_virtualenv())
 #nd old_v.parts[1:3] == ("usr", "local")
 #nd len(new_v.parts) > 1
 #nd new_v.parts[1] == "usr"
 #nd (len(new_v.parts) < 3 or new_v.parts[2] != "local")
 #nd (_looks_like_red_hat_scheme() or _looks_like_debian_scheme())
 #
 #f skip_linux_system_special_case:
 #ontinue

        # On Python 3.7 and earlier, sysconfig does not include sys.abiflags in
        # the "pythonX.Y" part of the path, but distutils does.
 #kip_sysconfig_abiflag_bug = (
 #ys.version_info < (3, 8)
 #nd not WINDOWS
 #nd k in ("headers", "platlib", "purelib")
 #nd tuple(_fix_abiflags(old_v.parts)) == new_v.parts
 #
 #f skip_sysconfig_abiflag_bug:
 #ontinue

        # MSYS2 MINGW's sysconfig patch does not include the "site-packages"
        # part of the path. This is incorrect and will be fixed in MSYS.
 #kip_msys2_mingw_bug = (
 #INDOWS and k in ("platlib", "purelib") and _looks_like_msys2_mingw_scheme()
 #
 #f skip_msys2_mingw_bug:
 #ontinue

        # CPython's POSIX install script invokes pip (via ensurepip) against the
        # interpreter located in the source tree, not the install site. This
        # triggers special logic in sysconfig that's not present in distutils.
        # https://github.com/python/cpython/blob/8c21941ddaf/Lib/sysconfig.py#L178-L194
 #kip_cpython_build = (
 #ysconfig.is_python_build(check_home=True)
 #nd not WINDOWS
 #nd k in ("headers", "include", "platinclude")
 #
 #f skip_cpython_build:
 #ontinue

 #arning_contexts.append((old_v, new_v, f"scheme.{k}"))

 #f not warning_contexts:
 #eturn old

    # Check if this path mismatch is caused by distutils config files. Those
    # files will no longer work once we switch to sysconfig, so this raises a
    # deprecation message for them.
 #efault_old = _distutils.distutils_scheme(
 #ist_name,
 #ser,
 #ome,
 #oot,
 #solated,
 #refix,
 #gnore_config_files=True,
 #
 #f any(default_old[k] != getattr(old, k) for k in SCHEME_KEYS):
 #eprecated(
 #eason=(
 #Configuring installation scheme with distutils config files "
 #is deprecated and will no longer work in the near future. If you "
 #are using a Homebrew or Linuxbrew Python, please see discussion "
 #at https://github.com/Homebrew/homebrew-core/issues/76621"
 #,
 #eplacement=None,
 #one_in=None,
 #
 #eturn old

    # Post warnings about this mismatch so user can report them back.
 #or old_v, new_v, key in warning_contexts:
 #warn_mismatched(old_v, new_v, key=key)
 #log_context(user=user, home=home, root=root, prefix=prefix)

 #eturn old


def get_bin_prefix() -> str:
 #ew = _sysconfig.get_bin_prefix()
 #f _USE_SYSCONFIG:
 #eturn new

 #ld = _distutils.get_bin_prefix()
 #f _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key="bin_prefix"):
 #log_context()
 #eturn old


def get_bin_user() -> str:
 #eturn _sysconfig.get_scheme("", user=True).scripts


def _looks_like_deb_system_dist_packages(value: str) -> bool:
 #""Check if the value is Debian's APT-controlled dist-packages.

 #ebian's ``distutils.sysconfig.get_python_lib()`` implementation returns the
 #efault package path controlled by APT, but does not patch ``sysconfig`` to
 #o the same. This is similar to the bug worked around in ``get_scheme()``,
 #ut here the default is ``deb_system`` instead of ``unix_local``. Ultimately
 #e can't do anything about this Debian bug, and this detection allows us to
 #kip the warning when needed.
 #""
 #f not _looks_like_debian_scheme():
 #eturn False
 #f value == "/usr/lib/python3/dist-packages":
 #eturn True
 #eturn False


def get_purelib() -> str:
 #""Return the default pure-Python lib location."""
 #ew = _sysconfig.get_purelib()
 #f _USE_SYSCONFIG:
 #eturn new

 #ld = _distutils.get_purelib()
 #f _looks_like_deb_system_dist_packages(old):
 #eturn old
 #f _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key="purelib"):
 #log_context()
 #eturn old


def get_platlib() -> str:
 #""Return the default platform-shared lib location."""
 #ew = _sysconfig.get_platlib()
 #f _USE_SYSCONFIG:
 #eturn new

 #rom . import _distutils

 #ld = _distutils.get_platlib()
 #f _looks_like_deb_system_dist_packages(old):
 #eturn old
 #f _warn_if_mismatch(pathlib.Path(old), pathlib.Path(new), key="platlib"):
 #log_context()
 #eturn old
