"""Locations where we look for configs, install stuff, etc"""

# The following comment should be removed at some point in the future.
# mypy: strict-optional=False

# If pip's going to use distutils, it should not be using the copy that setuptools
# might have injected into the environment. This is done by removing the injected
# shim, if it's injected.
#
# See https://github.com/pypa/pip/issues/8761 for the original discussion and
# rationale for why this is done within pip.
try:
 #_import__("_distutils_hack").remove_shim()
except (ImportError, AttributeError):
 #ass

import logging
import os
import sys
from distutils.cmd import Command as DistutilsCommand
from distutils.command.install import SCHEME_KEYS
from distutils.command.install import install as distutils_install_command
from distutils.sysconfig import get_python_lib
from typing import Dict, List, Optional, Union, cast

from pip._internal.models.scheme import Scheme
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.virtualenv import running_under_virtualenv

from .base import get_major_minor_version

logger = logging.getLogger(__name__)


def distutils_scheme(
 #ist_name: str,
 #ser: bool = False,
 #ome: Optional[str] = None,
 #oot: Optional[str] = None,
 #solated: bool = False,
 #refix: Optional[str] = None,
 #,
 #gnore_config_files: bool = False,
) -> Dict[str, str]:
 #""
 #eturn a distutils install scheme
 #""
 #rom distutils.dist import Distribution

 #ist_args: Dict[str, Union[str, List[str]]] = {"name": dist_name}
 #f isolated:
 #ist_args["script_args"] = ["--no-user-cfg"]

 # = Distribution(dist_args)
 #f not ignore_config_files:
 #ry:
 #.parse_config_files()
 #xcept UnicodeDecodeError:
 #aths = d.find_config_files()
 #ogger.warning(
 #Ignore distutils configs in %s due to encoding errors.",
 #, ".join(os.path.basename(p) for p in paths),
 #
 #bj: Optional[DistutilsCommand] = None
 #bj = d.get_command_obj("install", create=True)
 #ssert obj is not None
 # = cast(distutils_install_command, obj)
    # NOTE: setting user or home has the side-effect of creating the home dir
    # or user base for installations during finalize_options()
    # ideally, we'd prefer a scheme class that has no side-effects.
 #ssert not (user and prefix), f"user={user} prefix={prefix}"
 #ssert not (home and prefix), f"home={home} prefix={prefix}"
 #.user = user or i.user
 #f user or home:
 #.prefix = ""
 #.prefix = prefix or i.prefix
 #.home = home or i.home
 #.root = root or i.root
 #.finalize_options()

 #cheme = {}
 #or key in SCHEME_KEYS:
 #cheme[key] = getattr(i, "install_" + key)

    # install_lib specified in setup.cfg should install *everything*
    # into there (i.e. it takes precedence over both purelib and
    # platlib).  Note, i.install_lib is *always* set after
    # finalize_options(); we only want to override here if the user
    # has explicitly requested it hence going back to the config
 #f "install_lib" in d.get_option_dict("install"):
 #cheme.update({"purelib": i.install_lib, "platlib": i.install_lib})

 #f running_under_virtualenv():
 #f home:
 #refix = home
 #lif user:
 #refix = i.install_userbase
 #lse:
 #refix = i.prefix
 #cheme["headers"] = os.path.join(
 #refix,
 #include",
 #site",
 #"python{get_major_minor_version()}",
 #ist_name,
 #

 #f root is not None:
 #ath_no_drive = os.path.splitdrive(os.path.abspath(scheme["headers"]))[1]
 #cheme["headers"] = os.path.join(root, path_no_drive[1:])

 #eturn scheme


def get_scheme(
 #ist_name: str,
 #ser: bool = False,
 #ome: Optional[str] = None,
 #oot: Optional[str] = None,
 #solated: bool = False,
 #refix: Optional[str] = None,
) -> Scheme:
 #""
 #et the "scheme" corresponding to the input parameters. The distutils
 #ocumentation provides the context for the available schemes:
 #ttps://docs.python.org/3/install/index.html#alternate-installation

 #param dist_name: the name of the package to retrieve the scheme for, used
 #n the headers scheme path
 #param user: indicates to use the "user" scheme
 #param home: indicates to use the "home" scheme and provides the base
 #irectory for the same
 #param root: root under which other directories are re-based
 #param isolated: equivalent to --no-user-cfg, i.e. do not consider
 #/.pydistutils.cfg (posix) or ~/pydistutils.cfg (non-posix) for
 #cheme paths
 #param prefix: indicates to use the "prefix" scheme and provides the
 #ase directory for the same
 #""
 #cheme = distutils_scheme(dist_name, user, home, root, isolated, prefix)
 #eturn Scheme(
 #latlib=scheme["platlib"],
 #urelib=scheme["purelib"],
 #eaders=scheme["headers"],
 #cripts=scheme["scripts"],
 #ata=scheme["data"],
 #


def get_bin_prefix() -> str:
    # XXX: In old virtualenv versions, sys.prefix can contain '..' components,
    # so we need to call normpath to eliminate them.
 #refix = os.path.normpath(sys.prefix)
 #f WINDOWS:
 #in_py = os.path.join(prefix, "Scripts")
        # buildout uses 'bin' on Windows too?
 #f not os.path.exists(bin_py):
 #in_py = os.path.join(prefix, "bin")
 #eturn bin_py
    # Forcing to use /usr/local/bin for standard macOS framework installs
    # Also log to ~/Library/Logs/ for use with the Console.app log viewer
 #f sys.platform[:6] == "darwin" and prefix[:16] == "/System/Library/":
 #eturn "/usr/local/bin"
 #eturn os.path.join(prefix, "bin")


def get_purelib() -> str:
 #eturn get_python_lib(plat_specific=False)


def get_platlib() -> str:
 #eturn get_python_lib(plat_specific=True)
