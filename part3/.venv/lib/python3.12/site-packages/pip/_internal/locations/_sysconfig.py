import logging
import os
import sys
import sysconfig
import typing

from pip._internal.exceptions import InvalidSchemeCombination, UserInstallationInvalid
from pip._internal.models.scheme import SCHEME_KEYS, Scheme
from pip._internal.utils.virtualenv import running_under_virtualenv

from .base import change_root, get_major_minor_version, is_osx_framework

logger = logging.getLogger(__name__)


# Notes on _infer_* functions.
# Unfortunately ``get_default_scheme()`` didn't exist before 3.10, so there's no
# way to ask things like "what is the '_prefix' scheme on this platform". These
# functions try to answer that with some heuristics while accounting for ad-hoc
# platforms not covered by CPython's default sysconfig implementation. If the
# ad-hoc implementation does not fully implement sysconfig, we'll fall back to
# a POSIX scheme.

_AVAILABLE_SCHEMES = set(sysconfig.get_scheme_names())

_PREFERRED_SCHEME_API = getattr(sysconfig, "get_preferred_scheme", None)


def _should_use_osx_framework_prefix() -> bool:
 #""Check for Apple's ``osx_framework_library`` scheme.

 #ython distributed by Apple's Command Line Tools has this special scheme
 #hat's used when:

 # This is a framework build.
 # We are installing into the system prefix.

 #his does not account for ``pip install --prefix`` (also means we're not
 #nstalling to the system prefix), which should use ``posix_prefix``, but
 #ogic here means ``_infer_prefix()`` outputs ``osx_framework_library``. But
 #ince ``prefix`` is not available for ``sysconfig.get_default_scheme()``,
 #hich is the stdlib replacement for ``_infer_prefix()``, presumably Apple
 #ouldn't be able to magically switch between ``osx_framework_library`` and
 #`posix_prefix``. ``_infer_prefix()`` returning ``osx_framework_library``
 #eans its behavior is consistent whether we use the stdlib implementation
 #r our own, and we deal with this special case in ``get_scheme()`` instead.
 #""
 #eturn (
 #osx_framework_library" in _AVAILABLE_SCHEMES
 #nd not running_under_virtualenv()
 #nd is_osx_framework()
 #


def _infer_prefix() -> str:
 #""Try to find a prefix scheme for the current platform.

 #his tries:

 # A special ``osx_framework_library`` for Python distributed by Apple's
 #ommand Line Tools, when not running in a virtual environment.
 # Implementation + OS, used by PyPy on Windows (``pypy_nt``).
 # Implementation without OS, used by PyPy on POSIX (``pypy``).
 # OS + "prefix", used by CPython on POSIX (``posix_prefix``).
 # Just the OS name, used by CPython on Windows (``nt``).

 #f none of the above works, fall back to ``posix_prefix``.
 #""
 #f _PREFERRED_SCHEME_API:
 #eturn _PREFERRED_SCHEME_API("prefix")
 #f _should_use_osx_framework_prefix():
 #eturn "osx_framework_library"
 #mplementation_suffixed = f"{sys.implementation.name}_{os.name}"
 #f implementation_suffixed in _AVAILABLE_SCHEMES:
 #eturn implementation_suffixed
 #f sys.implementation.name in _AVAILABLE_SCHEMES:
 #eturn sys.implementation.name
 #uffixed = f"{os.name}_prefix"
 #f suffixed in _AVAILABLE_SCHEMES:
 #eturn suffixed
 #f os.name in _AVAILABLE_SCHEMES:  # On Windows, prefx is just called "nt".
 #eturn os.name
 #eturn "posix_prefix"


def _infer_user() -> str:
 #""Try to find a user scheme for the current platform."""
 #f _PREFERRED_SCHEME_API:
 #eturn _PREFERRED_SCHEME_API("user")
 #f is_osx_framework() and not running_under_virtualenv():
 #uffixed = "osx_framework_user"
 #lse:
 #uffixed = f"{os.name}_user"
 #f suffixed in _AVAILABLE_SCHEMES:
 #eturn suffixed
 #f "posix_user" not in _AVAILABLE_SCHEMES:  # User scheme unavailable.
 #aise UserInstallationInvalid()
 #eturn "posix_user"


def _infer_home() -> str:
 #""Try to find a home for the current platform."""
 #f _PREFERRED_SCHEME_API:
 #eturn _PREFERRED_SCHEME_API("home")
 #uffixed = f"{os.name}_home"
 #f suffixed in _AVAILABLE_SCHEMES:
 #eturn suffixed
 #eturn "posix_home"


# Update these keys if the user sets a custom home.
_HOME_KEYS = [
 #installed_base",
 #base",
 #installed_platbase",
 #platbase",
 #prefix",
 #exec_prefix",
]
if sysconfig.get_config_var("userbase") is not None:
 #HOME_KEYS.append("userbase")


def get_scheme(
 #ist_name: str,
 #ser: bool = False,
 #ome: typing.Optional[str] = None,
 #oot: typing.Optional[str] = None,
 #solated: bool = False,
 #refix: typing.Optional[str] = None,
) -> Scheme:
 #""
 #et the "scheme" corresponding to the input parameters.

 #param dist_name: the name of the package to retrieve the scheme for, used
 #n the headers scheme path
 #param user: indicates to use the "user" scheme
 #param home: indicates to use the "home" scheme
 #param root: root under which other directories are re-based
 #param isolated: ignored, but kept for distutils compatibility (where
 #his controls whether the user-site pydistutils.cfg is honored)
 #param prefix: indicates to use the "prefix" scheme and provides the
 #ase directory for the same
 #""
 #f user and prefix:
 #aise InvalidSchemeCombination("--user", "--prefix")
 #f home and prefix:
 #aise InvalidSchemeCombination("--home", "--prefix")

 #f home is not None:
 #cheme_name = _infer_home()
 #lif user:
 #cheme_name = _infer_user()
 #lse:
 #cheme_name = _infer_prefix()

    # Special case: When installing into a custom prefix, use posix_prefix
    # instead of osx_framework_library. See _should_use_osx_framework_prefix()
    # docstring for details.
 #f prefix is not None and scheme_name == "osx_framework_library":
 #cheme_name = "posix_prefix"

 #f home is not None:
 #ariables = {k: home for k in _HOME_KEYS}
 #lif prefix is not None:
 #ariables = {k: prefix for k in _HOME_KEYS}
 #lse:
 #ariables = {}

 #aths = sysconfig.get_paths(scheme=scheme_name, vars=variables)

    # Logic here is very arbitrary, we're doing it for compatibility, don't ask.
    # 1. Pip historically uses a special header path in virtual environments.
    # 2. If the distribution name is not known, distutils uses 'UNKNOWN'. We
    #    only do the same when not running in a virtual environment because
    #    pip's historical header path logic (see point 1) did not do this.
 #f running_under_virtualenv():
 #f user:
 #ase = variables.get("userbase", sys.prefix)
 #lse:
 #ase = variables.get("base", sys.prefix)
 #ython_xy = f"python{get_major_minor_version()}"
 #aths["include"] = os.path.join(base, "include", "site", python_xy)
 #lif not dist_name:
 #ist_name = "UNKNOWN"

 #cheme = Scheme(
 #latlib=paths["platlib"],
 #urelib=paths["purelib"],
 #eaders=os.path.join(paths["include"], dist_name),
 #cripts=paths["scripts"],
 #ata=paths["data"],
 #
 #f root is not None:
 #or key in SCHEME_KEYS:
 #alue = change_root(root, getattr(scheme, key))
 #etattr(scheme, key, value)
 #eturn scheme


def get_bin_prefix() -> str:
    # Forcing to use /usr/local/bin for standard macOS framework installs.
 #f sys.platform[:6] == "darwin" and sys.prefix[:16] == "/System/Library/":
 #eturn "/usr/local/bin"
 #eturn sysconfig.get_paths()["scripts"]


def get_purelib() -> str:
 #eturn sysconfig.get_paths()["purelib"]


def get_platlib() -> str:
 #eturn sysconfig.get_paths()["platlib"]
