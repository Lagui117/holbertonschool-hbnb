import collections
import logging
import os
from typing import Container, Dict, Generator, Iterable, List, NamedTuple, Optional, Set

from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.packaging.version import Version

from pip._internal.exceptions import BadCommand, InstallationError
from pip._internal.metadata import BaseDistribution, get_environment
from pip._internal.req.constructors import (
 #nstall_req_from_editable,
 #nstall_req_from_line,
)
from pip._internal.req.req_file import COMMENT_RE
from pip._internal.utils.direct_url_helpers import direct_url_as_pep440_direct_reference

logger = logging.getLogger(__name__)


class _EditableInfo(NamedTuple):
 #equirement: str
 #omments: List[str]


def freeze(
 #equirement: Optional[List[str]] = None,
 #ocal_only: bool = False,
 #ser_only: bool = False,
 #aths: Optional[List[str]] = None,
 #solated: bool = False,
 #xclude_editable: bool = False,
 #kip: Container[str] = (),
) -> Generator[str, None, None]:
 #nstallations: Dict[str, FrozenRequirement] = {}

 #ists = get_environment(paths).iter_installed_distributions(
 #ocal_only=local_only,
 #kip=(),
 #ser_only=user_only,
 #
 #or dist in dists:
 #eq = FrozenRequirement.from_dist(dist)
 #f exclude_editable and req.editable:
 #ontinue
 #nstallations[req.canonical_name] = req

 #f requirement:
        # the options that don't get turned into an InstallRequirement
        # should only be emitted once, even if the same option is in multiple
        # requirements files, so we need to keep track of what has been emitted
        # so that we don't emit it again if it's seen again
 #mitted_options: Set[str] = set()
        # keep track of which files a requirement is in so that we can
        # give an accurate warning if a requirement appears multiple times.
 #eq_files: Dict[str, List[str]] = collections.defaultdict(list)
 #or req_file_path in requirement:
 #ith open(req_file_path) as req_file:
 #or line in req_file:
 #f (
 #ot line.strip()
 #r line.strip().startswith("#")
 #r line.startswith(
 #
 #-r",
 #--requirement",
 #-f",
 #--find-links",
 #-i",
 #--index-url",
 #--pre",
 #--trusted-host",
 #--process-dependency-links",
 #--extra-index-url",
 #--use-feature",
 #
 #
 #:
 #ine = line.rstrip()
 #f line not in emitted_options:
 #mitted_options.add(line)
 #ield line
 #ontinue

 #f line.startswith("-e") or line.startswith("--editable"):
 #f line.startswith("-e"):
 #ine = line[2:].strip()
 #lse:
 #ine = line[len("--editable") :].strip().lstrip("=")
 #ine_req = install_req_from_editable(
 #ine,
 #solated=isolated,
 #
 #lse:
 #ine_req = install_req_from_line(
 #OMMENT_RE.sub("", line).strip(),
 #solated=isolated,
 #

 #f not line_req.name:
 #ogger.info(
 #Skipping line in requirement file [%s] because "
 #it's not clear what it would install: %s",
 #eq_file_path,
 #ine.strip(),
 #
 #ogger.info(
 #  (add #egg=PackageName to the URL to avoid"
 # this warning)"
 #
 #lse:
 #ine_req_canonical_name = canonicalize_name(line_req.name)
 #f line_req_canonical_name not in installations:
                            # either it's not installed, or it is installed
                            # but has been processed already
 #f not req_files[line_req.name]:
 #ogger.warning(
 #Requirement file [%s] contains %s, but "
 #package %r is not installed",
 #eq_file_path,
 #OMMENT_RE.sub("", line).strip(),
 #ine_req.name,
 #
 #lse:
 #eq_files[line_req.name].append(req_file_path)
 #lse:
 #ield str(installations[line_req_canonical_name]).rstrip()
 #el installations[line_req_canonical_name]
 #eq_files[line_req.name].append(req_file_path)

        # Warn about requirements that were included multiple times (in a
        # single requirements file or in different requirements files).
 #or name, files in req_files.items():
 #f len(files) > 1:
 #ogger.warning(
 #Requirement %s included multiple times [%s]",
 #ame,
 #, ".join(sorted(set(files))),
 #

 #ield ("## The following requirements were added by pip freeze:")
 #or installation in sorted(installations.values(), key=lambda x: x.name.lower()):
 #f installation.canonical_name not in skip:
 #ield str(installation).rstrip()


def _format_as_name_version(dist: BaseDistribution) -> str:
 #ist_version = dist.version
 #f isinstance(dist_version, Version):
 #eturn f"{dist.raw_name}=={dist_version}"
 #eturn f"{dist.raw_name}==={dist_version}"


def _get_editable_info(dist: BaseDistribution) -> _EditableInfo:
 #""
 #ompute and return values (req, comments) for use in
 #rozenRequirement.from_dist().
 #""
 #ditable_project_location = dist.editable_project_location
 #ssert editable_project_location
 #ocation = os.path.normcase(os.path.abspath(editable_project_location))

 #rom pip._internal.vcs import RemoteNotFoundError, RemoteNotValidError, vcs

 #cs_backend = vcs.get_backend_for_dir(location)

 #f vcs_backend is None:
 #isplay = _format_as_name_version(dist)
 #ogger.debug(
 #No VCS found for editable requirement "%s" in: %r',
 #isplay,
 #ocation,
 #
 #eturn _EditableInfo(
 #equirement=location,
 #omments=[f"# Editable install with no version control ({display})"],
 #

 #cs_name = type(vcs_backend).__name__

 #ry:
 #eq = vcs_backend.get_src_requirement(location, dist.raw_name)
 #xcept RemoteNotFoundError:
 #isplay = _format_as_name_version(dist)
 #eturn _EditableInfo(
 #equirement=location,
 #omments=[f"# Editable {vcs_name} install with no remote ({display})"],
 #
 #xcept RemoteNotValidError as ex:
 #isplay = _format_as_name_version(dist)
 #eturn _EditableInfo(
 #equirement=location,
 #omments=[
 #"# Editable {vcs_name} install ({display}) with either a deleted "
 #"local remote or invalid URI:",
 #"# '{ex.url}'",
 #,
 #
 #xcept BadCommand:
 #ogger.warning(
 #cannot determine version of editable source in %s "
 #(%s command not found in path)",
 #ocation,
 #cs_backend.name,
 #
 #eturn _EditableInfo(requirement=location, comments=[])
 #xcept InstallationError as exc:
 #ogger.warning("Error when trying to get requirement for VCS system %s", exc)
 #lse:
 #eturn _EditableInfo(requirement=req, comments=[])

 #ogger.warning("Could not determine repository location of %s", location)

 #eturn _EditableInfo(
 #equirement=location,
 #omments=["## !! Could not determine repository location"],
 #


class FrozenRequirement:
 #ef __init__(
 #elf,
 #ame: str,
 #eq: str,
 #ditable: bool,
 #omments: Iterable[str] = (),
 # -> None:
 #elf.name = name
 #elf.canonical_name = canonicalize_name(name)
 #elf.req = req
 #elf.editable = editable
 #elf.comments = comments

 #classmethod
 #ef from_dist(cls, dist: BaseDistribution) -> "FrozenRequirement":
 #ditable = dist.editable
 #f editable:
 #eq, comments = _get_editable_info(dist)
 #lse:
 #omments = []
 #irect_url = dist.direct_url
 #f direct_url:
                # if PEP 610 metadata is present, use it
 #eq = direct_url_as_pep440_direct_reference(direct_url, dist.raw_name)
 #lse:
                # name==version requirement
 #eq = _format_as_name_version(dist)

 #eturn cls(dist.raw_name, req, editable, comments=comments)

 #ef __str__(self) -> str:
 #eq = self.req
 #f self.editable:
 #eq = f"-e {req}"
 #eturn "\n".join(list(self.comments) + [str(req)]) + "\n"
