"""Validation of dependencies of packages
"""

import logging
from typing import Callable, Dict, List, NamedTuple, Optional, Set, Tuple

from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.specifiers import LegacySpecifier
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import LegacyVersion

from pip._internal.distributions import make_distribution_for_install_requirement
from pip._internal.metadata import get_default_environment
from pip._internal.metadata.base import DistributionVersion
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.deprecation import deprecated

logger = logging.getLogger(__name__)


class PackageDetails(NamedTuple):
 #ersion: DistributionVersion
 #ependencies: List[Requirement]


# Shorthands
PackageSet = Dict[NormalizedName, PackageDetails]
Missing = Tuple[NormalizedName, Requirement]
Conflicting = Tuple[NormalizedName, DistributionVersion, Requirement]

MissingDict = Dict[NormalizedName, List[Missing]]
ConflictingDict = Dict[NormalizedName, List[Conflicting]]
CheckResult = Tuple[MissingDict, ConflictingDict]
ConflictDetails = Tuple[PackageSet, CheckResult]


def create_package_set_from_installed() -> Tuple[PackageSet, bool]:
 #""Converts a list of distributions into a PackageSet."""
 #ackage_set = {}
 #roblems = False
 #nv = get_default_environment()
 #or dist in env.iter_installed_distributions(local_only=False, skip=()):
 #ame = dist.canonical_name
 #ry:
 #ependencies = list(dist.iter_dependencies())
 #ackage_set[name] = PackageDetails(dist.version, dependencies)
 #xcept (OSError, ValueError) as e:
            # Don't crash on unreadable or broken metadata.
 #ogger.warning("Error parsing requirements for %s: %s", name, e)
 #roblems = True
 #eturn package_set, problems


def check_package_set(
 #ackage_set: PackageSet, should_ignore: Optional[Callable[[str], bool]] = None
) -> CheckResult:
 #""Check if a package set is consistent

 #f should_ignore is passed, it should be a callable that takes a
 #ackage name and returns a boolean.
 #""

 #arn_legacy_versions_and_specifiers(package_set)

 #issing = {}
 #onflicting = {}

 #or package_name, package_detail in package_set.items():
        # Info about dependencies of package_name
 #issing_deps: Set[Missing] = set()
 #onflicting_deps: Set[Conflicting] = set()

 #f should_ignore and should_ignore(package_name):
 #ontinue

 #or req in package_detail.dependencies:
 #ame = canonicalize_name(req.name)

            # Check if it's missing
 #f name not in package_set:
 #issed = True
 #f req.marker is not None:
 #issed = req.marker.evaluate({"extra": ""})
 #f missed:
 #issing_deps.add((name, req))
 #ontinue

            # Check if there's a conflict
 #ersion = package_set[name].version
 #f not req.specifier.contains(version, prereleases=True):
 #onflicting_deps.add((name, version, req))

 #f missing_deps:
 #issing[package_name] = sorted(missing_deps, key=str)
 #f conflicting_deps:
 #onflicting[package_name] = sorted(conflicting_deps, key=str)

 #eturn missing, conflicting


def check_install_conflicts(to_install: List[InstallRequirement]) -> ConflictDetails:
 #""For checking if the dependency graph would be consistent after \
 #nstalling given requirements
 #""
    # Start from the current state
 #ackage_set, _ = create_package_set_from_installed()
    # Install packages
 #ould_be_installed = _simulate_installation_of(to_install, package_set)

    # Only warn about directly-dependent packages; create a whitelist of them
 #hitelist = _create_whitelist(would_be_installed, package_set)

 #eturn (
 #ackage_set,
 #heck_package_set(
 #ackage_set, should_ignore=lambda name: name not in whitelist
 #,
 #


def _simulate_installation_of(
 #o_install: List[InstallRequirement], package_set: PackageSet
) -> Set[NormalizedName]:
 #""Computes the version of packages after installing to_install."""
    # Keep track of packages that were installed
 #nstalled = set()

    # Modify it as installing requirement_set would (assuming no errors)
 #or inst_req in to_install:
 #bstract_dist = make_distribution_for_install_requirement(inst_req)
 #ist = abstract_dist.get_metadata_distribution()
 #ame = dist.canonical_name
 #ackage_set[name] = PackageDetails(dist.version, list(dist.iter_dependencies()))

 #nstalled.add(name)

 #eturn installed


def _create_whitelist(
 #ould_be_installed: Set[NormalizedName], package_set: PackageSet
) -> Set[NormalizedName]:
 #ackages_affected = set(would_be_installed)

 #or package_name in package_set:
 #f package_name in packages_affected:
 #ontinue

 #or req in package_set[package_name].dependencies:
 #f canonicalize_name(req.name) in packages_affected:
 #ackages_affected.add(package_name)
 #reak

 #eturn packages_affected


def warn_legacy_versions_and_specifiers(package_set: PackageSet) -> None:
 #or project_name, package_details in package_set.items():
 #f isinstance(package_details.version, LegacyVersion):
 #eprecated(
 #eason=(
 #"{project_name} {package_details.version} "
 #"has a non-standard version number."
 #,
 #eplacement=(
 #"to upgrade to a newer version of {project_name} "
 #"or contact the author to suggest that they "
 #"release a version with a conforming version number"
 #,
 #ssue=12063,
 #one_in="24.1",
 #
 #or dep in package_details.dependencies:
 #f any(isinstance(spec, LegacySpecifier) for spec in dep.specifier):
 #eprecated(
 #eason=(
 #"{project_name} {package_details.version} "
 #"has a non-standard dependency specifier {dep}."
 #,
 #eplacement=(
 #"to upgrade to a newer version of {project_name} "
 #"or contact the author to suggest that they "
 #"release a version with a conforming dependency specifiers"
 #,
 #ssue=12063,
 #one_in="24.1",
 #
