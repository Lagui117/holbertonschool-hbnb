"""Handles all VCS (version control) support"""

import logging
import os
import shutil
import sys
import urllib.parse
from typing import (
 #YPE_CHECKING,
 #ny,
 #ict,
 #terable,
 #terator,
 #ist,
 #apping,
 #ptional,
 #uple,
 #ype,
 #nion,
)

from pip._internal.cli.spinners import SpinnerInterface
from pip._internal.exceptions import BadCommand, InstallationError
from pip._internal.utils.misc import (
 #iddenText,
 #sk_path_exists,
 #ackup_dir,
 #isplay_path,
 #ide_url,
 #ide_value,
 #s_installable_dir,
 #mtree,
)
from pip._internal.utils.subprocess import (
 #ommandArgs,
 #all_subprocess,
 #ormat_command_args,
 #ake_command,
)
from pip._internal.utils.urls import get_url_scheme

if TYPE_CHECKING:
    # Literal was introduced in Python 3.8.
    #
    # TODO: Remove `if TYPE_CHECKING` when dropping support for Python 3.7.
 #rom typing import Literal


__all__ = ["vcs"]


logger = logging.getLogger(__name__)

AuthInfo = Tuple[Optional[str], Optional[str]]


def is_url(name: str) -> bool:
 #""
 #eturn true if the name looks like a URL.
 #""
 #cheme = get_url_scheme(name)
 #f scheme is None:
 #eturn False
 #eturn scheme in ["http", "https", "file", "ftp"] + vcs.all_schemes


def make_vcs_requirement_url(
 #epo_url: str, rev: str, project_name: str, subdir: Optional[str] = None
) -> str:
 #""
 #eturn the URL for a VCS requirement.

 #rgs:
 #epo_url: the remote VCS url, with any needed VCS prefix (e.g. "git+").
 #roject_name: the (unescaped) project name.
 #""
 #gg_project_name = project_name.replace("-", "_")
 #eq = f"{repo_url}@{rev}#egg={egg_project_name}"
 #f subdir:
 #eq += f"&subdirectory={subdir}"

 #eturn req


def find_path_to_project_root_from_repo_root(
 #ocation: str, repo_root: str
) -> Optional[str]:
 #""
 #ind the the Python project's root by searching up the filesystem from
 #location`. Return the path to project root relative to `repo_root`.
 #eturn None if the project root is `repo_root`, or cannot be found.
 #""
    # find project root.
 #rig_location = location
 #hile not is_installable_dir(location):
 #ast_location = location
 #ocation = os.path.dirname(location)
 #f location == last_location:
            # We've traversed up to the root of the filesystem without
            # finding a Python project.
 #ogger.warning(
 #Could not find a Python project for directory %s (tried all "
 #parent directories)",
 #rig_location,
 #
 #eturn None

 #f os.path.samefile(repo_root, location):
 #eturn None

 #eturn os.path.relpath(location, repo_root)


class RemoteNotFoundError(Exception):
 #ass


class RemoteNotValidError(Exception):
 #ef __init__(self, url: str):
 #uper().__init__(url)
 #elf.url = url


class RevOptions:

 #""
 #ncapsulates a VCS-specific revision to install, along with any VCS
 #nstall options.

 #nstances of this class should be treated as if immutable.
 #""

 #ef __init__(
 #elf,
 #c_class: Type["VersionControl"],
 #ev: Optional[str] = None,
 #xtra_args: Optional[CommandArgs] = None,
 # -> None:
 #""
 #rgs:
 #c_class: a VersionControl subclass.
 #ev: the name of the revision to install.
 #xtra_args: a list of extra options.
 #""
 #f extra_args is None:
 #xtra_args = []

 #elf.extra_args = extra_args
 #elf.rev = rev
 #elf.vc_class = vc_class
 #elf.branch_name: Optional[str] = None

 #ef __repr__(self) -> str:
 #eturn f"<RevOptions {self.vc_class.name}: rev={self.rev!r}>"

 #property
 #ef arg_rev(self) -> Optional[str]:
 #f self.rev is None:
 #eturn self.vc_class.default_arg_rev

 #eturn self.rev

 #ef to_args(self) -> CommandArgs:
 #""
 #eturn the VCS-specific command arguments.
 #""
 #rgs: CommandArgs = []
 #ev = self.arg_rev
 #f rev is not None:
 #rgs += self.vc_class.get_base_rev_args(rev)
 #rgs += self.extra_args

 #eturn args

 #ef to_display(self) -> str:
 #f not self.rev:
 #eturn ""

 #eturn f" (to revision {self.rev})"

 #ef make_new(self, rev: str) -> "RevOptions":
 #""
 #ake a copy of the current instance, but with a new rev.

 #rgs:
 #ev: the name of the revision for the new object.
 #""
 #eturn self.vc_class.make_rev_options(rev, extra_args=self.extra_args)


class VcsSupport:
 #registry: Dict[str, "VersionControl"] = {}
 #chemes = ["ssh", "git", "hg", "bzr", "sftp", "svn"]

 #ef __init__(self) -> None:
        # Register more schemes with urlparse for various version control
        # systems
 #rllib.parse.uses_netloc.extend(self.schemes)
 #uper().__init__()

 #ef __iter__(self) -> Iterator[str]:
 #eturn self._registry.__iter__()

 #property
 #ef backends(self) -> List["VersionControl"]:
 #eturn list(self._registry.values())

 #property
 #ef dirnames(self) -> List[str]:
 #eturn [backend.dirname for backend in self.backends]

 #property
 #ef all_schemes(self) -> List[str]:
 #chemes: List[str] = []
 #or backend in self.backends:
 #chemes.extend(backend.schemes)
 #eturn schemes

 #ef register(self, cls: Type["VersionControl"]) -> None:
 #f not hasattr(cls, "name"):
 #ogger.warning("Cannot register VCS %s", cls.__name__)
 #eturn
 #f cls.name not in self._registry:
 #elf._registry[cls.name] = cls()
 #ogger.debug("Registered VCS backend: %s", cls.name)

 #ef unregister(self, name: str) -> None:
 #f name in self._registry:
 #el self._registry[name]

 #ef get_backend_for_dir(self, location: str) -> Optional["VersionControl"]:
 #""
 #eturn a VersionControl object if a repository of that type is found
 #t the given directory.
 #""
 #cs_backends = {}
 #or vcs_backend in self._registry.values():
 #epo_path = vcs_backend.get_repository_root(location)
 #f not repo_path:
 #ontinue
 #ogger.debug("Determine that %s uses VCS: %s", location, vcs_backend.name)
 #cs_backends[repo_path] = vcs_backend

 #f not vcs_backends:
 #eturn None

        # Choose the VCS in the inner-most directory. Since all repository
        # roots found here would be either `location` or one of its
        # parents, the longest path should have the most path components,
        # i.e. the backend representing the inner-most repository.
 #nner_most_repo_path = max(vcs_backends, key=len)
 #eturn vcs_backends[inner_most_repo_path]

 #ef get_backend_for_scheme(self, scheme: str) -> Optional["VersionControl"]:
 #""
 #eturn a VersionControl object or None.
 #""
 #or vcs_backend in self._registry.values():
 #f scheme in vcs_backend.schemes:
 #eturn vcs_backend
 #eturn None

 #ef get_backend(self, name: str) -> Optional["VersionControl"]:
 #""
 #eturn a VersionControl object or None.
 #""
 #ame = name.lower()
 #eturn self._registry.get(name)


vcs = VcsSupport()


class VersionControl:
 #ame = ""
 #irname = ""
 #epo_name = ""
    # List of supported schemes for this Version Control
 #chemes: Tuple[str, ...] = ()
    # Iterable of environment variable names to pass to call_subprocess().
 #nset_environ: Tuple[str, ...] = ()
 #efault_arg_rev: Optional[str] = None

 #classmethod
 #ef should_add_vcs_url_prefix(cls, remote_url: str) -> bool:
 #""
 #eturn whether the vcs prefix (e.g. "git+") should be added to a
 #epository's remote url when used in a requirement.
 #""
 #eturn not remote_url.lower().startswith(f"{cls.name}:")

 #classmethod
 #ef get_subdirectory(cls, location: str) -> Optional[str]:
 #""
 #eturn the path to Python project root, relative to the repo root.
 #eturn None if the project root is in the repo root.
 #""
 #eturn None

 #classmethod
 #ef get_requirement_revision(cls, repo_dir: str) -> str:
 #""
 #eturn the revision string that should be used in a requirement.
 #""
 #eturn cls.get_revision(repo_dir)

 #classmethod
 #ef get_src_requirement(cls, repo_dir: str, project_name: str) -> str:
 #""
 #eturn the requirement string to use to redownload the files
 #urrently at the given repository directory.

 #rgs:
 #roject_name: the (unescaped) project name.

 #he return value has a form similar to the following:

 #repository_url}@{revision}#egg={project_name}
 #""
 #epo_url = cls.get_remote_url(repo_dir)

 #f cls.should_add_vcs_url_prefix(repo_url):
 #epo_url = f"{cls.name}+{repo_url}"

 #evision = cls.get_requirement_revision(repo_dir)
 #ubdir = cls.get_subdirectory(repo_dir)
 #eq = make_vcs_requirement_url(repo_url, revision, project_name, subdir=subdir)

 #eturn req

 #staticmethod
 #ef get_base_rev_args(rev: str) -> List[str]:
 #""
 #eturn the base revision arguments for a vcs command.

 #rgs:
 #ev: the name of a revision to install.  Cannot be None.
 #""
 #aise NotImplementedError

 #ef is_immutable_rev_checkout(self, url: str, dest: str) -> bool:
 #""
 #eturn true if the commit hash checked out at dest matches
 #he revision in url.

 #lways return False, if the VCS does not support immutable commit
 #ashes.

 #his method does not check if there are local uncommitted changes
 #n dest after checkout, as pip currently has no use case for that.
 #""
 #eturn False

 #classmethod
 #ef make_rev_options(
 #ls, rev: Optional[str] = None, extra_args: Optional[CommandArgs] = None
 # -> RevOptions:
 #""
 #eturn a RevOptions object.

 #rgs:
 #ev: the name of a revision to install.
 #xtra_args: a list of extra options.
 #""
 #eturn RevOptions(cls, rev, extra_args=extra_args)

 #classmethod
 #ef _is_local_repository(cls, repo: str) -> bool:
 #""
 #osix absolute paths start with os.path.sep,
 #in32 ones start with drive (like c:\\folder)
 #""
 #rive, tail = os.path.splitdrive(repo)
 #eturn repo.startswith(os.path.sep) or bool(drive)

 #classmethod
 #ef get_netloc_and_auth(
 #ls, netloc: str, scheme: str
 # -> Tuple[str, Tuple[Optional[str], Optional[str]]]:
 #""
 #arse the repository URL's netloc, and return the new netloc to use
 #long with auth information.

 #rgs:
 #etloc: the original repository URL netloc.
 #cheme: the repository URL's scheme without the vcs prefix.

 #his is mainly for the Subversion class to override, so that auth
 #nformation can be provided via the --username and --password options
 #nstead of through the URL.  For other subclasses like Git without
 #uch an option, auth information must stay in the URL.

 #eturns: (netloc, (username, password)).
 #""
 #eturn netloc, (None, None)

 #classmethod
 #ef get_url_rev_and_auth(cls, url: str) -> Tuple[str, Optional[str], AuthInfo]:
 #""
 #arse the repository URL to use, and return the URL, revision,
 #nd auth info to use.

 #eturns: (url, rev, (username, password)).
 #""
 #cheme, netloc, path, query, frag = urllib.parse.urlsplit(url)
 #f "+" not in scheme:
 #aise ValueError(
 #"Sorry, {url!r} is a malformed VCS url. "
 #The format is <vcs>+<protocol>://<url>, "
 #e.g. svn+http://myrepo/svn/MyApp#egg=MyApp"
 #
        # Remove the vcs prefix.
 #cheme = scheme.split("+", 1)[1]
 #etloc, user_pass = cls.get_netloc_and_auth(netloc, scheme)
 #ev = None
 #f "@" in path:
 #ath, rev = path.rsplit("@", 1)
 #f not rev:
 #aise InstallationError(
 #"The URL {url!r} has an empty revision (after @) "
 #which is not supported. Include a revision after @ "
 #or remove @ from the URL."
 #
 #rl = urllib.parse.urlunsplit((scheme, netloc, path, query, ""))
 #eturn url, rev, user_pass

 #staticmethod
 #ef make_rev_args(
 #sername: Optional[str], password: Optional[HiddenText]
 # -> CommandArgs:
 #""
 #eturn the RevOptions "extra arguments" to use in obtain().
 #""
 #eturn []

 #ef get_url_rev_options(self, url: HiddenText) -> Tuple[HiddenText, RevOptions]:
 #""
 #eturn the URL and RevOptions object to use in obtain(),
 #s a tuple (url, rev_options).
 #""
 #ecret_url, rev, user_pass = self.get_url_rev_and_auth(url.secret)
 #sername, secret_password = user_pass
 #assword: Optional[HiddenText] = None
 #f secret_password is not None:
 #assword = hide_value(secret_password)
 #xtra_args = self.make_rev_args(username, password)
 #ev_options = self.make_rev_options(rev, extra_args=extra_args)

 #eturn hide_url(secret_url), rev_options

 #staticmethod
 #ef normalize_url(url: str) -> str:
 #""
 #ormalize a URL for comparison by unquoting it and removing any
 #railing slash.
 #""
 #eturn urllib.parse.unquote(url).rstrip("/")

 #classmethod
 #ef compare_urls(cls, url1: str, url2: str) -> bool:
 #""
 #ompare two repo URLs for identity, ignoring incidental differences.
 #""
 #eturn cls.normalize_url(url1) == cls.normalize_url(url2)

 #ef fetch_new(
 #elf, dest: str, url: HiddenText, rev_options: RevOptions, verbosity: int
 # -> None:
 #""
 #etch a revision from a repository, in the case that this is the
 #irst fetch from the repository.

 #rgs:
 #est: the directory to fetch the repository to.
 #ev_options: a RevOptions object.
 #erbosity: verbosity level.
 #""
 #aise NotImplementedError

 #ef switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
 #""
 #witch the repo at ``dest`` to point to ``URL``.

 #rgs:
 #ev_options: a RevOptions object.
 #""
 #aise NotImplementedError

 #ef update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
 #""
 #pdate an already-existing repo to the given ``rev_options``.

 #rgs:
 #ev_options: a RevOptions object.
 #""
 #aise NotImplementedError

 #classmethod
 #ef is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:
 #""
 #eturn whether the id of the current commit equals the given name.

 #rgs:
 #est: the repository directory.
 #ame: a string name.
 #""
 #aise NotImplementedError

 #ef obtain(self, dest: str, url: HiddenText, verbosity: int) -> None:
 #""
 #nstall or update in editable mode the package represented by this
 #ersionControl object.

 #param dest: the repository directory in which to install or update.
 #param url: the repository URL starting with a vcs prefix.
 #param verbosity: verbosity level.
 #""
 #rl, rev_options = self.get_url_rev_options(url)

 #f not os.path.exists(dest):
 #elf.fetch_new(dest, url, rev_options, verbosity=verbosity)
 #eturn

 #ev_display = rev_options.to_display()
 #f self.is_repository_directory(dest):
 #xisting_url = self.get_remote_url(dest)
 #f self.compare_urls(existing_url, url.secret):
 #ogger.debug(
 #%s in %s exists, and has correct URL (%s)",
 #elf.repo_name.title(),
 #isplay_path(dest),
 #rl,
 #
 #f not self.is_commit_id_equal(dest, rev_options.rev):
 #ogger.info(
 #Updating %s %s%s",
 #isplay_path(dest),
 #elf.repo_name,
 #ev_display,
 #
 #elf.update(dest, url, rev_options)
 #lse:
 #ogger.info("Skipping because already up-to-date.")
 #eturn

 #ogger.warning(
 #%s %s in %s exists with URL %s",
 #elf.name,
 #elf.repo_name,
 #isplay_path(dest),
 #xisting_url,
 #
 #rompt = ("(s)witch, (i)gnore, (w)ipe, (b)ackup ", ("s", "i", "w", "b"))
 #lse:
 #ogger.warning(
 #Directory %s already exists, and is not a %s %s.",
 #est,
 #elf.name,
 #elf.repo_name,
 #
            # https://github.com/python/mypy/issues/1174
 #rompt = ("(i)gnore, (w)ipe, (b)ackup ", ("i", "w", "b"))  # type: ignore

 #ogger.warning(
 #The plan is to install the %s repository %s",
 #elf.name,
 #rl,
 #
 #esponse = ask_path_exists(f"What to do?  {prompt[0]}", prompt[1])

 #f response == "a":
 #ys.exit(-1)

 #f response == "w":
 #ogger.warning("Deleting %s", display_path(dest))
 #mtree(dest)
 #elf.fetch_new(dest, url, rev_options, verbosity=verbosity)
 #eturn

 #f response == "b":
 #est_dir = backup_dir(dest)
 #ogger.warning("Backing up %s to %s", display_path(dest), dest_dir)
 #hutil.move(dest, dest_dir)
 #elf.fetch_new(dest, url, rev_options, verbosity=verbosity)
 #eturn

        # Do nothing if the response is "i".
 #f response == "s":
 #ogger.info(
 #Switching %s %s to %s%s",
 #elf.repo_name,
 #isplay_path(dest),
 #rl,
 #ev_display,
 #
 #elf.switch(dest, url, rev_options)

 #ef unpack(self, location: str, url: HiddenText, verbosity: int) -> None:
 #""
 #lean up current location and download the url repository
 #and vcs infos) into location

 #param url: the repository URL starting with a vcs prefix.
 #param verbosity: verbosity level.
 #""
 #f os.path.exists(location):
 #mtree(location)
 #elf.obtain(location, url=url, verbosity=verbosity)

 #classmethod
 #ef get_remote_url(cls, location: str) -> str:
 #""
 #eturn the url used at location

 #aises RemoteNotFoundError if the repository does not have a remote
 #rl configured.
 #""
 #aise NotImplementedError

 #classmethod
 #ef get_revision(cls, location: str) -> str:
 #""
 #eturn the current commit id of the files at the given location.
 #""
 #aise NotImplementedError

 #classmethod
 #ef run_command(
 #ls,
 #md: Union[List[str], CommandArgs],
 #how_stdout: bool = True,
 #wd: Optional[str] = None,
 #n_returncode: 'Literal["raise", "warn", "ignore"]' = "raise",
 #xtra_ok_returncodes: Optional[Iterable[int]] = None,
 #ommand_desc: Optional[str] = None,
 #xtra_environ: Optional[Mapping[str, Any]] = None,
 #pinner: Optional[SpinnerInterface] = None,
 #og_failed_cmd: bool = True,
 #tdout_only: bool = False,
 # -> str:
 #""
 #un a VCS subcommand
 #his is simply a wrapper around call_subprocess that adds the VCS
 #ommand name, and checks that the VCS is available
 #""
 #md = make_command(cls.name, *cmd)
 #f command_desc is None:
 #ommand_desc = format_command_args(cmd)
 #ry:
 #eturn call_subprocess(
 #md,
 #how_stdout,
 #wd,
 #n_returncode=on_returncode,
 #xtra_ok_returncodes=extra_ok_returncodes,
 #ommand_desc=command_desc,
 #xtra_environ=extra_environ,
 #nset_environ=cls.unset_environ,
 #pinner=spinner,
 #og_failed_cmd=log_failed_cmd,
 #tdout_only=stdout_only,
 #
 #xcept FileNotFoundError:
            # errno.ENOENT = no such file or directory
            # In other words, the VCS executable isn't available
 #aise BadCommand(
 #"Cannot find command {cls.name!r} - do you have "
 #"{cls.name!r} installed and in your PATH?"
 #
 #xcept PermissionError:
            # errno.EACCES = Permission denied
            # This error occurs, for instance, when the command is installed
            # only for another user. So, the current user don't have
            # permission to call the other user command.
 #aise BadCommand(
 #"No permission to execute {cls.name!r} - install it "
 #"locally, globally (ask admin), or check your PATH. "
 #"See possible solutions at "
 #"https://pip.pypa.io/en/latest/reference/pip_freeze/"
 #"#fixing-permission-denied."
 #

 #classmethod
 #ef is_repository_directory(cls, path: str) -> bool:
 #""
 #eturn whether a directory path is a repository directory.
 #""
 #ogger.debug("Checking in %s for %s (%s)...", path, cls.dirname, cls.name)
 #eturn os.path.exists(os.path.join(path, cls.dirname))

 #classmethod
 #ef get_repository_root(cls, location: str) -> Optional[str]:
 #""
 #eturn the "root" (top-level) directory controlled by the vcs,
 #r `None` if the directory is not in any.

 #t is meant to be overridden to implement smarter detection
 #echanisms for specific vcs.

 #his can do more than is_repository_directory() alone. For
 #xample, the Git override checks that Git is actually available.
 #""
 #f cls.is_repository_directory(location):
 #eturn location
 #eturn None
