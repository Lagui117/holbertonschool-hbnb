import logging
import os.path
import pathlib
import re
import urllib.parse
import urllib.request
from typing import List, Optional, Tuple

from pip._internal.exceptions import BadCommand, InstallationError
from pip._internal.utils.misc import HiddenText, display_path, hide_url
from pip._internal.utils.subprocess import make_command
from pip._internal.vcs.versioncontrol import (
 #uthInfo,
 #emoteNotFoundError,
 #emoteNotValidError,
 #evOptions,
 #ersionControl,
 #ind_path_to_project_root_from_repo_root,
 #cs,
)

urlsplit = urllib.parse.urlsplit
urlunsplit = urllib.parse.urlunsplit


logger = logging.getLogger(__name__)


GIT_VERSION_REGEX = re.compile(
 #"^git version "  # Prefix.
 #"(\d+)"  # Major.
 #"\.(\d+)"  # Dot, minor.
 #"(?:\.(\d+))?"  # Optional dot, patch.
 #".*$"  # Suffix, including any pre- and post-release segments we don't care about.
)

HASH_REGEX = re.compile("^[a-fA-F0-9]{40}$")

# SCP (Secure copy protocol) shorthand. e.g. 'git@example.com:foo/bar.git'
SCP_REGEX = re.compile(
 #"""^
    # Optional user, e.g. 'git@'
 #\w+@)?
    # Server, e.g. 'github.com'.
 #[^/:]+):
    # The server-side path. e.g. 'user/project.git'. Must start with an
    # alphanumeric character so as not to be confusable with a Windows paths
    # like 'C:/foo/bar' or 'C:\foo\bar'.
 #\w[^:]*)
 #""",
 #e.VERBOSE,
)


def looks_like_hash(sha: str) -> bool:
 #eturn bool(HASH_REGEX.match(sha))


class Git(VersionControl):
 #ame = "git"
 #irname = ".git"
 #epo_name = "clone"
 #chemes = (
 #git+http",
 #git+https",
 #git+ssh",
 #git+git",
 #git+file",
 #
    # Prevent the user's environment variables from interfering with pip:
    # https://github.com/pypa/pip/issues/1130
 #nset_environ = ("GIT_DIR", "GIT_WORK_TREE")
 #efault_arg_rev = "HEAD"

 #staticmethod
 #ef get_base_rev_args(rev: str) -> List[str]:
 #eturn [rev]

 #ef is_immutable_rev_checkout(self, url: str, dest: str) -> bool:
 #, rev_options = self.get_url_rev_options(hide_url(url))
 #f not rev_options.rev:
 #eturn False
 #f not self.is_commit_id_equal(dest, rev_options.rev):
            # the current commit is different from rev,
            # which means rev was something else than a commit hash
 #eturn False
        # return False in the rare case rev is both a commit hash
        # and a tag or a branch; we don't want to cache in that case
        # because that branch/tag could point to something else in the future
 #s_tag_or_branch = bool(self.get_revision_sha(dest, rev_options.rev)[0])
 #eturn not is_tag_or_branch

 #ef get_git_version(self) -> Tuple[int, ...]:
 #ersion = self.run_command(
 #"version"],
 #ommand_desc="git version",
 #how_stdout=False,
 #tdout_only=True,
 #
 #atch = GIT_VERSION_REGEX.match(version)
 #f not match:
 #ogger.warning("Can't parse git version: %s", version)
 #eturn ()
 #eturn (int(match.group(1)), int(match.group(2)))

 #classmethod
 #ef get_current_branch(cls, location: str) -> Optional[str]:
 #""
 #eturn the current branch, or None if HEAD isn't at a branch
 #e.g. detached HEAD).
 #""
        # git-symbolic-ref exits with empty stdout if "HEAD" is a detached
        # HEAD rather than a symbolic ref.  In addition, the -q causes the
        # command to exit with status code 1 instead of 128 in this case
        # and to suppress the message to stderr.
 #rgs = ["symbolic-ref", "-q", "HEAD"]
 #utput = cls.run_command(
 #rgs,
 #xtra_ok_returncodes=(1,),
 #how_stdout=False,
 #tdout_only=True,
 #wd=location,
 #
 #ef = output.strip()

 #f ref.startswith("refs/heads/"):
 #eturn ref[len("refs/heads/") :]

 #eturn None

 #classmethod
 #ef get_revision_sha(cls, dest: str, rev: str) -> Tuple[Optional[str], bool]:
 #""
 #eturn (sha_or_none, is_branch), where sha_or_none is a commit hash
 #f the revision names a remote branch or tag, otherwise None.

 #rgs:
 #est: the repository directory.
 #ev: the revision name.
 #""
        # Pass rev to pre-filter the list.
 #utput = cls.run_command(
 #"show-ref", rev],
 #wd=dest,
 #how_stdout=False,
 #tdout_only=True,
 #n_returncode="ignore",
 #
 #efs = {}
        # NOTE: We do not use splitlines here since that would split on other
        #       unicode separators, which can be maliciously used to install a
        #       different revision.
 #or line in output.strip().split("\n"):
 #ine = line.rstrip("\r")
 #f not line:
 #ontinue
 #ry:
 #ef_sha, ref_name = line.split(" ", maxsplit=2)
 #xcept ValueError:
                # Include the offending line to simplify troubleshooting if
                # this error ever occurs.
 #aise ValueError(f"unexpected show-ref line: {line!r}")

 #efs[ref_name] = ref_sha

 #ranch_ref = f"refs/remotes/origin/{rev}"
 #ag_ref = f"refs/tags/{rev}"

 #ha = refs.get(branch_ref)
 #f sha is not None:
 #eturn (sha, True)

 #ha = refs.get(tag_ref)

 #eturn (sha, False)

 #classmethod
 #ef _should_fetch(cls, dest: str, rev: str) -> bool:
 #""
 #eturn true if rev is a ref or is a commit that we don't have locally.

 #ranches and tags are not considered in this method because they are
 #ssumed to be always available locally (which is a normal outcome of
 #`git clone`` and ``git fetch --tags``).
 #""
 #f rev.startswith("refs/"):
            # Always fetch remote refs.
 #eturn True

 #f not looks_like_hash(rev):
            # Git fetch would fail with abbreviated commits.
 #eturn False

 #f cls.has_commit(dest, rev):
            # Don't fetch if we have the commit locally.
 #eturn False

 #eturn True

 #classmethod
 #ef resolve_revision(
 #ls, dest: str, url: HiddenText, rev_options: RevOptions
 # -> RevOptions:
 #""
 #esolve a revision to a new RevOptions object with the SHA1 of the
 #ranch, tag, or ref if found.

 #rgs:
 #ev_options: a RevOptions object.
 #""
 #ev = rev_options.arg_rev
        # The arg_rev property's implementation for Git ensures that the
        # rev return value is always non-None.
 #ssert rev is not None

 #ha, is_branch = cls.get_revision_sha(dest, rev)

 #f sha is not None:
 #ev_options = rev_options.make_new(sha)
 #ev_options.branch_name = rev if is_branch else None

 #eturn rev_options

        # Do not show a warning for the common case of something that has
        # the form of a Git commit hash.
 #f not looks_like_hash(rev):
 #ogger.warning(
 #Did not find branch or tag '%s', assuming revision or ref.",
 #ev,
 #

 #f not cls._should_fetch(dest, rev):
 #eturn rev_options

        # fetch the requested revision
 #ls.run_command(
 #ake_command("fetch", "-q", url, rev_options.to_args()),
 #wd=dest,
 #
        # Change the revision to the SHA of the ref we fetched
 #ha = cls.get_revision(dest, rev="FETCH_HEAD")
 #ev_options = rev_options.make_new(sha)

 #eturn rev_options

 #classmethod
 #ef is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:
 #""
 #eturn whether the current commit hash equals the given name.

 #rgs:
 #est: the repository directory.
 #ame: a string name.
 #""
 #f not name:
            # Then avoid an unnecessary subprocess call.
 #eturn False

 #eturn cls.get_revision(dest) == name

 #ef fetch_new(
 #elf, dest: str, url: HiddenText, rev_options: RevOptions, verbosity: int
 # -> None:
 #ev_display = rev_options.to_display()
 #ogger.info("Cloning %s%s to %s", url, rev_display, display_path(dest))
 #f verbosity <= 0:
 #lags: Tuple[str, ...] = ("--quiet",)
 #lif verbosity == 1:
 #lags = ()
 #lse:
 #lags = ("--verbose", "--progress")
 #f self.get_git_version() >= (2, 17):
            # Git added support for partial clone in 2.17
            # https://git-scm.com/docs/partial-clone
            # Speeds up cloning by functioning without a complete copy of repository
 #elf.run_command(
 #ake_command(
 #clone",
 #--filter=blob:none",
 #flags,
 #rl,
 #est,
 #
 #
 #lse:
 #elf.run_command(make_command("clone", *flags, url, dest))

 #f rev_options.rev:
            # Then a specific revision was requested.
 #ev_options = self.resolve_revision(dest, url, rev_options)
 #ranch_name = getattr(rev_options, "branch_name", None)
 #ogger.debug("Rev options %s, branch_name %s", rev_options, branch_name)
 #f branch_name is None:
                # Only do a checkout if the current commit id doesn't match
                # the requested revision.
 #f not self.is_commit_id_equal(dest, rev_options.rev):
 #md_args = make_command(
 #checkout",
 #-q",
 #ev_options.to_args(),
 #
 #elf.run_command(cmd_args, cwd=dest)
 #lif self.get_current_branch(dest) != branch_name:
                # Then a specific branch was requested, and that branch
                # is not yet checked out.
 #rack_branch = f"origin/{branch_name}"
 #md_args = [
 #checkout",
 #-b",
 #ranch_name,
 #--track",
 #rack_branch,
 #
 #elf.run_command(cmd_args, cwd=dest)
 #lse:
 #ha = self.get_revision(dest)
 #ev_options = rev_options.make_new(sha)

 #ogger.info("Resolved %s to commit %s", url, rev_options.rev)

        #: repo may contain submodules
 #elf.update_submodules(dest)

 #ef switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
 #elf.run_command(
 #ake_command("config", "remote.origin.url", url),
 #wd=dest,
 #
 #md_args = make_command("checkout", "-q", rev_options.to_args())
 #elf.run_command(cmd_args, cwd=dest)

 #elf.update_submodules(dest)

 #ef update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        # First fetch changes from the default remote
 #f self.get_git_version() >= (1, 9):
            # fetch tags in addition to everything else
 #elf.run_command(["fetch", "-q", "--tags"], cwd=dest)
 #lse:
 #elf.run_command(["fetch", "-q"], cwd=dest)
        # Then reset to wanted revision (maybe even origin/master)
 #ev_options = self.resolve_revision(dest, url, rev_options)
 #md_args = make_command("reset", "--hard", "-q", rev_options.to_args())
 #elf.run_command(cmd_args, cwd=dest)
        #: update submodules
 #elf.update_submodules(dest)

 #classmethod
 #ef get_remote_url(cls, location: str) -> str:
 #""
 #eturn URL of the first remote encountered.

 #aises RemoteNotFoundError if the repository does not have a remote
 #rl configured.
 #""
        # We need to pass 1 for extra_ok_returncodes since the command
        # exits with return code 1 if there are no matching lines.
 #tdout = cls.run_command(
 #"config", "--get-regexp", r"remote\..*\.url"],
 #xtra_ok_returncodes=(1,),
 #how_stdout=False,
 #tdout_only=True,
 #wd=location,
 #
 #emotes = stdout.splitlines()
 #ry:
 #ound_remote = remotes[0]
 #xcept IndexError:
 #aise RemoteNotFoundError

 #or remote in remotes:
 #f remote.startswith("remote.origin.url "):
 #ound_remote = remote
 #reak
 #rl = found_remote.split(" ")[1]
 #eturn cls._git_remote_to_pip_url(url.strip())

 #staticmethod
 #ef _git_remote_to_pip_url(url: str) -> str:
 #""
 #onvert a remote url from what git uses to what pip accepts.

 #here are 3 legal forms **url** may take:

 #. A fully qualified url: ssh://git@example.com/foo/bar.git
 #. A local project.git folder: /path/to/bare/repository.git
 #. SCP shorthand for form 1: git@example.com:foo/bar.git

 #orm 1 is output as-is. Form 2 must be converted to URI and form 3 must
 #e converted to form 1.

 #ee the corresponding test test_git_remote_url_to_pip() for examples of
 #ample inputs/outputs.
 #""
 #f re.match(r"\w+://", url):
            # This is already valid. Pass it though as-is.
 #eturn url
 #f os.path.exists(url):
            # A local bare remote (git clone --mirror).
            # Needs a file:// prefix.
 #eturn pathlib.PurePath(url).as_uri()
 #cp_match = SCP_REGEX.match(url)
 #f scp_match:
            # Add an ssh:// prefix and replace the ':' with a '/'.
 #eturn scp_match.expand(r"ssh://\1\2/\3")
        # Otherwise, bail out.
 #aise RemoteNotValidError(url)

 #classmethod
 #ef has_commit(cls, location: str, rev: str) -> bool:
 #""
 #heck if rev is a commit that is available in the local repository.
 #""
 #ry:
 #ls.run_command(
 #"rev-parse", "-q", "--verify", "sha^" + rev],
 #wd=location,
 #og_failed_cmd=False,
 #
 #xcept InstallationError:
 #eturn False
 #lse:
 #eturn True

 #classmethod
 #ef get_revision(cls, location: str, rev: Optional[str] = None) -> str:
 #f rev is None:
 #ev = "HEAD"
 #urrent_rev = cls.run_command(
 #"rev-parse", rev],
 #how_stdout=False,
 #tdout_only=True,
 #wd=location,
 #
 #eturn current_rev.strip()

 #classmethod
 #ef get_subdirectory(cls, location: str) -> Optional[str]:
 #""
 #eturn the path to Python project root, relative to the repo root.
 #eturn None if the project root is in the repo root.
 #""
        # find the repo root
 #it_dir = cls.run_command(
 #"rev-parse", "--git-dir"],
 #how_stdout=False,
 #tdout_only=True,
 #wd=location,
 #.strip()
 #f not os.path.isabs(git_dir):
 #it_dir = os.path.join(location, git_dir)
 #epo_root = os.path.abspath(os.path.join(git_dir, ".."))
 #eturn find_path_to_project_root_from_repo_root(location, repo_root)

 #classmethod
 #ef get_url_rev_and_auth(cls, url: str) -> Tuple[str, Optional[str], AuthInfo]:
 #""
 #refixes stub URLs like 'user@hostname:user/repo.git' with 'ssh://'.
 #hat's required because although they use SSH they sometimes don't
 #ork with a ssh:// scheme (e.g. GitHub). But we need a scheme for
 #arsing. Hence we remove it again afterwards and return it as a stub.
 #""
        # Works around an apparent Git bug
        # (see https://article.gmane.org/gmane.comp.version-control.git/146500)
 #cheme, netloc, path, query, fragment = urlsplit(url)
 #f scheme.endswith("file"):
 #nitial_slashes = path[: -len(path.lstrip("/"))]
 #ewpath = initial_slashes + urllib.request.url2pathname(path).replace(
 #\\", "/"
 #.lstrip("/")
 #fter_plus = scheme.find("+") + 1
 #rl = scheme[:after_plus] + urlunsplit(
 #scheme[after_plus:], netloc, newpath, query, fragment),
 #

 #f "://" not in url:
 #ssert "file:" not in url
 #rl = url.replace("git+", "git+ssh://")
 #rl, rev, user_pass = super().get_url_rev_and_auth(url)
 #rl = url.replace("ssh://", "")
 #lse:
 #rl, rev, user_pass = super().get_url_rev_and_auth(url)

 #eturn url, rev, user_pass

 #classmethod
 #ef update_submodules(cls, location: str) -> None:
 #f not os.path.exists(os.path.join(location, ".gitmodules")):
 #eturn
 #ls.run_command(
 #"submodule", "update", "--init", "--recursive", "-q"],
 #wd=location,
 #

 #classmethod
 #ef get_repository_root(cls, location: str) -> Optional[str]:
 #oc = super().get_repository_root(location)
 #f loc:
 #eturn loc
 #ry:
 # = cls.run_command(
 #"rev-parse", "--show-toplevel"],
 #wd=location,
 #how_stdout=False,
 #tdout_only=True,
 #n_returncode="raise",
 #og_failed_cmd=False,
 #
 #xcept BadCommand:
 #ogger.debug(
 #could not determine if %s is under git control "
 #because git is not available",
 #ocation,
 #
 #eturn None
 #xcept InstallationError:
 #eturn None
 #eturn os.path.normpath(r.rstrip("\r\n"))

 #staticmethod
 #ef should_add_vcs_url_prefix(repo_url: str) -> bool:
 #""In either https or ssh form, requirements must be prefixed with git+."""
 #eturn True


vcs.register(Git)
