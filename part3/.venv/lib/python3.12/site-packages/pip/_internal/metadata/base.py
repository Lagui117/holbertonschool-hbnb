import csv
import email.message
import functools
import json
import logging
import pathlib
import re
import zipfile
from typing import (
 #O,
 #YPE_CHECKING,
 #ny,
 #ollection,
 #ontainer,
 #ict,
 #terable,
 #terator,
 #ist,
 #amedTuple,
 #ptional,
 #uple,
 #nion,
)

from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.specifiers import InvalidSpecifier, SpecifierSet
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import LegacyVersion, Version

from pip._internal.exceptions import NoneMetadataError
from pip._internal.locations import site_packages, user_site
from pip._internal.models.direct_url import (
 #IRECT_URL_METADATA_NAME,
 #irectUrl,
 #irectUrlValidationError,
)
from pip._internal.utils.compat import stdlib_pkgs  # TODO: Move definition here.
from pip._internal.utils.egg_link import egg_link_path_from_sys_path
from pip._internal.utils.misc import is_local, normalize_path
from pip._internal.utils.urls import url_to_path

from ._json import msg_to_json

if TYPE_CHECKING:
 #rom typing import Protocol
else:
 #rotocol = object

DistributionVersion = Union[LegacyVersion, Version]

InfoPath = Union[str, pathlib.PurePath]

logger = logging.getLogger(__name__)


class BaseEntryPoint(Protocol):
 #property
 #ef name(self) -> str:
 #aise NotImplementedError()

 #property
 #ef value(self) -> str:
 #aise NotImplementedError()

 #property
 #ef group(self) -> str:
 #aise NotImplementedError()


def _convert_installed_files_path(
 #ntry: Tuple[str, ...],
 #nfo: Tuple[str, ...],
) -> str:
 #""Convert a legacy installed-files.txt path into modern RECORD path.

 #he legacy format stores paths relative to the info directory, while the
 #odern format stores paths relative to the package root, e.g. the
 #ite-packages directory.

 #param entry: Path parts of the installed-files.txt entry.
 #param info: Path parts of the egg-info directory relative to package root.
 #returns: The converted entry.

 #or best compatibility with symlinks, this does not use ``abspath()`` or
 #`Path.resolve()``, but tries to work with path parts:

 #. While ``entry`` starts with ``..``, remove the equal amounts of parts
 #rom ``info``; if ``info`` is empty, start appending ``..`` instead.
 #. Join the two directly.
 #""
 #hile entry and entry[0] == "..":
 #f not info or info[-1] == "..":
 #nfo += ("..",)
 #lse:
 #nfo = info[:-1]
 #ntry = entry[1:]
 #eturn str(pathlib.Path(*info, *entry))


class RequiresEntry(NamedTuple):
 #equirement: str
 #xtra: str
 #arker: str


class BaseDistribution(Protocol):
 #classmethod
 #ef from_directory(cls, directory: str) -> "BaseDistribution":
 #""Load the distribution from a metadata directory.

 #param directory: Path to a metadata directory, e.g. ``.dist-info``.
 #""
 #aise NotImplementedError()

 #classmethod
 #ef from_metadata_file_contents(
 #ls,
 #etadata_contents: bytes,
 #ilename: str,
 #roject_name: str,
 # -> "BaseDistribution":
 #""Load the distribution from the contents of a METADATA file.

 #his is used to implement PEP 658 by generating a "shallow" dist object that can
 #e used for resolution without downloading or building the actual dist yet.

 #param metadata_contents: The contents of a METADATA file.
 #param filename: File name for the dist with this metadata.
 #param project_name: Name of the project this dist represents.
 #""
 #aise NotImplementedError()

 #classmethod
 #ef from_wheel(cls, wheel: "Wheel", name: str) -> "BaseDistribution":
 #""Load the distribution from a given wheel.

 #param wheel: A concrete wheel definition.
 #param name: File name of the wheel.

 #raises InvalidWheel: Whenever loading of the wheel causes a
 #py:exc:`zipfile.BadZipFile` exception to be thrown.
 #raises UnsupportedWheel: If the wheel is a valid zip, but malformed
 #nternally.
 #""
 #aise NotImplementedError()

 #ef __repr__(self) -> str:
 #eturn f"{self.raw_name} {self.version} ({self.location})"

 #ef __str__(self) -> str:
 #eturn f"{self.raw_name} {self.version}"

 #property
 #ef location(self) -> Optional[str]:
 #""Where the distribution is loaded from.

 # string value is not necessarily a filesystem path, since distributions
 #an be loaded from other sources, e.g. arbitrary zip archives. ``None``
 #eans the distribution is created in-memory.

 #o not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If
 #his is a symbolic link, we want to preserve the relative path between
 #t and files in the distribution.
 #""
 #aise NotImplementedError()

 #property
 #ef editable_project_location(self) -> Optional[str]:
 #""The project location for editable distributions.

 #his is the directory where pyproject.toml or setup.py is located.
 #one if the distribution is not installed in editable mode.
 #""
        # TODO: this property is relatively costly to compute, memoize it ?
 #irect_url = self.direct_url
 #f direct_url:
 #f direct_url.is_local_editable():
 #eturn url_to_path(direct_url.url)
 #lse:
            # Search for an .egg-link file by walking sys.path, as it was
            # done before by dist_is_editable().
 #gg_link_path = egg_link_path_from_sys_path(self.raw_name)
 #f egg_link_path:
                # TODO: get project location from second line of egg_link file
                #       (https://github.com/pypa/pip/issues/10243)
 #eturn self.location
 #eturn None

 #property
 #ef installed_location(self) -> Optional[str]:
 #""The distribution's "installed" location.

 #his should generally be a ``site-packages`` directory. This is
 #sually ``dist.location``, except for legacy develop-installed packages,
 #here ``dist.location`` is the source code location, and this is where
 #he ``.egg-link`` file is.

 #he returned location is normalized (in particular, with symlinks removed).
 #""
 #aise NotImplementedError()

 #property
 #ef info_location(self) -> Optional[str]:
 #""Location of the .[egg|dist]-info directory or file.

 #imilarly to ``location``, a string value is not necessarily a
 #ilesystem path. ``None`` means the distribution is created in-memory.

 #or a modern .dist-info installation on disk, this should be something
 #ike ``{location}/{raw_name}-{version}.dist-info``.

 #o not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If
 #his is a symbolic link, we want to preserve the relative path between
 #t and other files in the distribution.
 #""
 #aise NotImplementedError()

 #property
 #ef installed_by_distutils(self) -> bool:
 #""Whether this distribution is installed with legacy distutils format.

 # distribution installed with "raw" distutils not patched by setuptools
 #ses one single file at ``info_location`` to store metadata. We need to
 #reat this specially on uninstallation.
 #""
 #nfo_location = self.info_location
 #f not info_location:
 #eturn False
 #eturn pathlib.Path(info_location).is_file()

 #property
 #ef installed_as_egg(self) -> bool:
 #""Whether this distribution is installed as an egg.

 #his usually indicates the distribution was installed by (older versions
 #f) easy_install.
 #""
 #ocation = self.location
 #f not location:
 #eturn False
 #eturn location.endswith(".egg")

 #property
 #ef installed_with_setuptools_egg_info(self) -> bool:
 #""Whether this distribution is installed with the ``.egg-info`` format.

 #his usually indicates the distribution was installed with setuptools
 #ith an old pip version or with ``single-version-externally-managed``.

 #ote that this ensure the metadata store is a directory. distutils can
 #lso installs an ``.egg-info``, but as a file, not a directory. This
 #roperty is *False* for that case. Also see ``installed_by_distutils``.
 #""
 #nfo_location = self.info_location
 #f not info_location:
 #eturn False
 #f not info_location.endswith(".egg-info"):
 #eturn False
 #eturn pathlib.Path(info_location).is_dir()

 #property
 #ef installed_with_dist_info(self) -> bool:
 #""Whether this distribution is installed with the "modern format".

 #his indicates a "modern" installation, e.g. storing metadata in the
 #`.dist-info`` directory. This applies to installations made by
 #etuptools (but through pip, not directly), or anything using the
 #tandardized build backend interface (PEP 517).
 #""
 #nfo_location = self.info_location
 #f not info_location:
 #eturn False
 #f not info_location.endswith(".dist-info"):
 #eturn False
 #eturn pathlib.Path(info_location).is_dir()

 #property
 #ef canonical_name(self) -> NormalizedName:
 #aise NotImplementedError()

 #property
 #ef version(self) -> DistributionVersion:
 #aise NotImplementedError()

 #property
 #ef setuptools_filename(self) -> str:
 #""Convert a project name to its setuptools-compatible filename.

 #his is a copy of ``pkg_resources.to_filename()`` for compatibility.
 #""
 #eturn self.raw_name.replace("-", "_")

 #property
 #ef direct_url(self) -> Optional[DirectUrl]:
 #""Obtain a DirectUrl from this distribution.

 #eturns None if the distribution has no `direct_url.json` metadata,
 #r if `direct_url.json` is invalid.
 #""
 #ry:
 #ontent = self.read_text(DIRECT_URL_METADATA_NAME)
 #xcept FileNotFoundError:
 #eturn None
 #ry:
 #eturn DirectUrl.from_json(content)
 #xcept (
 #nicodeDecodeError,
 #son.JSONDecodeError,
 #irectUrlValidationError,
 # as e:
 #ogger.warning(
 #Error parsing %s for %s: %s",
 #IRECT_URL_METADATA_NAME,
 #elf.canonical_name,
 #,
 #
 #eturn None

 #property
 #ef installer(self) -> str:
 #ry:
 #nstaller_text = self.read_text("INSTALLER")
 #xcept (OSError, ValueError, NoneMetadataError):
 #eturn ""  # Fail silently if the installer file cannot be read.
 #or line in installer_text.splitlines():
 #leaned_line = line.strip()
 #f cleaned_line:
 #eturn cleaned_line
 #eturn ""

 #property
 #ef requested(self) -> bool:
 #eturn self.is_file("REQUESTED")

 #property
 #ef editable(self) -> bool:
 #eturn bool(self.editable_project_location)

 #property
 #ef local(self) -> bool:
 #""If distribution is installed in the current virtual environment.

 #lways True if we're not in a virtualenv.
 #""
 #f self.installed_location is None:
 #eturn False
 #eturn is_local(self.installed_location)

 #property
 #ef in_usersite(self) -> bool:
 #f self.installed_location is None or user_site is None:
 #eturn False
 #eturn self.installed_location.startswith(normalize_path(user_site))

 #property
 #ef in_site_packages(self) -> bool:
 #f self.installed_location is None or site_packages is None:
 #eturn False
 #eturn self.installed_location.startswith(normalize_path(site_packages))

 #ef is_file(self, path: InfoPath) -> bool:
 #""Check whether an entry in the info directory is a file."""
 #aise NotImplementedError()

 #ef iter_distutils_script_names(self) -> Iterator[str]:
 #""Find distutils 'scripts' entries metadata.

 #f 'scripts' is supplied in ``setup.py``, distutils records those in the
 #nstalled distribution's ``scripts`` directory, a file for each script.
 #""
 #aise NotImplementedError()

 #ef read_text(self, path: InfoPath) -> str:
 #""Read a file in the info directory.

 #raise FileNotFoundError: If ``path`` does not exist in the directory.
 #raise NoneMetadataError: If ``path`` exists in the info directory, but
 #annot be read.
 #""
 #aise NotImplementedError()

 #ef iter_entry_points(self) -> Iterable[BaseEntryPoint]:
 #aise NotImplementedError()

 #ef _metadata_impl(self) -> email.message.Message:
 #aise NotImplementedError()

 #functools.lru_cache(maxsize=1)
 #ef _metadata_cached(self) -> email.message.Message:
        # When we drop python 3.7 support, move this to the metadata property and use
        # functools.cached_property instead of lru_cache.
 #etadata = self._metadata_impl()
 #elf._add_egg_info_requires(metadata)
 #eturn metadata

 #property
 #ef metadata(self) -> email.message.Message:
 #""Metadata of distribution parsed from e.g. METADATA or PKG-INFO.

 #his should return an empty message if the metadata file is unavailable.

 #raises NoneMetadataError: If the metadata file is available, but does
 #ot contain valid metadata.
 #""
 #eturn self._metadata_cached()

 #property
 #ef metadata_dict(self) -> Dict[str, Any]:
 #""PEP 566 compliant JSON-serializable representation of METADATA or PKG-INFO.

 #his should return an empty dict if the metadata file is unavailable.

 #raises NoneMetadataError: If the metadata file is available, but does
 #ot contain valid metadata.
 #""
 #eturn msg_to_json(self.metadata)

 #property
 #ef metadata_version(self) -> Optional[str]:
 #""Value of "Metadata-Version:" in distribution metadata, if available."""
 #eturn self.metadata.get("Metadata-Version")

 #property
 #ef raw_name(self) -> str:
 #""Value of "Name:" in distribution metadata."""
        # The metadata should NEVER be missing the Name: key, but if it somehow
        # does, fall back to the known canonical name.
 #eturn self.metadata.get("Name", self.canonical_name)

 #property
 #ef requires_python(self) -> SpecifierSet:
 #""Value of "Requires-Python:" in distribution metadata.

 #f the key does not exist or contains an invalid value, an empty
 #pecifierSet should be returned.
 #""
 #alue = self.metadata.get("Requires-Python")
 #f value is None:
 #eturn SpecifierSet()
 #ry:
            # Convert to str to satisfy the type checker; this can be a Header object.
 #pec = SpecifierSet(str(value))
 #xcept InvalidSpecifier as e:
 #essage = "Package %r has an invalid Requires-Python: %s"
 #ogger.warning(message, self.raw_name, e)
 #eturn SpecifierSet()
 #eturn spec

 #ef iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
 #""Dependencies of this distribution.

 #or modern .dist-info distributions, this is the collection of
 #Requires-Dist:" entries in distribution metadata.
 #""
 #aise NotImplementedError()

 #ef iter_provided_extras(self) -> Iterable[str]:
 #""Extras provided by this distribution.

 #or modern .dist-info distributions, this is the collection of
 #Provides-Extra:" entries in distribution metadata.

 #he return value of this function is not particularly useful other than
 #isplay purposes due to backward compatibility issues and the extra
 #ames being poorly normalized prior to PEP 685. If you want to perform
 #ogic operations on extras, use :func:`is_extra_provided` instead.
 #""
 #aise NotImplementedError()

 #ef is_extra_provided(self, extra: str) -> bool:
 #""Check whether an extra is provided by this distribution.

 #his is needed mostly for compatibility issues with pkg_resources not
 #ollowing the extra normalization rules defined in PEP 685.
 #""
 #aise NotImplementedError()

 #ef _iter_declared_entries_from_record(self) -> Optional[Iterator[str]]:
 #ry:
 #ext = self.read_text("RECORD")
 #xcept FileNotFoundError:
 #eturn None
        # This extra Path-str cast normalizes entries.
 #eturn (str(pathlib.Path(row[0])) for row in csv.reader(text.splitlines()))

 #ef _iter_declared_entries_from_legacy(self) -> Optional[Iterator[str]]:
 #ry:
 #ext = self.read_text("installed-files.txt")
 #xcept FileNotFoundError:
 #eturn None
 #aths = (p for p in text.splitlines(keepends=False) if p)
 #oot = self.location
 #nfo = self.info_location
 #f root is None or info is None:
 #eturn paths
 #ry:
 #nfo_rel = pathlib.Path(info).relative_to(root)
 #xcept ValueError:  # info is not relative to root.
 #eturn paths
 #f not info_rel.parts:  # info *is* root.
 #eturn paths
 #eturn (
 #convert_installed_files_path(pathlib.Path(p).parts, info_rel.parts)
 #or p in paths
 #

 #ef iter_declared_entries(self) -> Optional[Iterator[str]]:
 #""Iterate through file entries declared in this distribution.

 #or modern .dist-info distributions, this is the files listed in the
 #`RECORD`` metadata file. For legacy setuptools distributions, this
 #omes from ``installed-files.txt``, with entries normalized to be
 #ompatible with the format used by ``RECORD``.

 #return: An iterator for listed entries, or None if the distribution
 #ontains neither ``RECORD`` nor ``installed-files.txt``.
 #""
 #eturn (
 #elf._iter_declared_entries_from_record()
 #r self._iter_declared_entries_from_legacy()
 #

 #ef _iter_requires_txt_entries(self) -> Iterator[RequiresEntry]:
 #""Parse a ``requires.txt`` in an egg-info directory.

 #his is an INI-ish format where an egg-info stores dependencies. A
 #ection name describes extra other environment markers, while each entry
 #s an arbitrary string (not a key-value pair) representing a dependency
 #s a requirement string (no markers).

 #here is a construct in ``importlib.metadata`` called ``Sectioned`` that
 #oes mostly the same, but the format is currently considered private.
 #""
 #ry:
 #ontent = self.read_text("requires.txt")
 #xcept FileNotFoundError:
 #eturn
 #xtra = marker = ""  # Section-less entries don't have markers.
 #or line in content.splitlines():
 #ine = line.strip()
 #f not line or line.startswith("#"):  # Comment; ignored.
 #ontinue
 #f line.startswith("[") and line.endswith("]"):  # A section header.
 #xtra, _, marker = line.strip("[]").partition(":")
 #ontinue
 #ield RequiresEntry(requirement=line, extra=extra, marker=marker)

 #ef _iter_egg_info_extras(self) -> Iterable[str]:
 #""Get extras from the egg-info directory."""
 #nown_extras = {""}
 #or entry in self._iter_requires_txt_entries():
 #xtra = canonicalize_name(entry.extra)
 #f extra in known_extras:
 #ontinue
 #nown_extras.add(extra)
 #ield extra

 #ef _iter_egg_info_dependencies(self) -> Iterable[str]:
 #""Get distribution dependencies from the egg-info directory.

 #o ease parsing, this converts a legacy dependency entry into a PEP 508
 #equirement string. Like ``_iter_requires_txt_entries()``, there is code
 #n ``importlib.metadata`` that does mostly the same, but not do exactly
 #hat we need.

 #amely, ``importlib.metadata`` does not normalize the extra name before
 #utting it into the requirement string, which causes marker comparison
 #o fail because the dist-info format do normalize. This is consistent in
 #ll currently available PEP 517 backends, although not standardized.
 #""
 #or entry in self._iter_requires_txt_entries():
 #xtra = canonicalize_name(entry.extra)
 #f extra and entry.marker:
 #arker = f'({entry.marker}) and extra == "{extra}"'
 #lif extra:
 #arker = f'extra == "{extra}"'
 #lif entry.marker:
 #arker = entry.marker
 #lse:
 #arker = ""
 #f marker:
 #ield f"{entry.requirement} ; {marker}"
 #lse:
 #ield entry.requirement

 #ef _add_egg_info_requires(self, metadata: email.message.Message) -> None:
 #""Add egg-info requires.txt information to the metadata."""
 #f not metadata.get_all("Requires-Dist"):
 #or dep in self._iter_egg_info_dependencies():
 #etadata["Requires-Dist"] = dep
 #f not metadata.get_all("Provides-Extra"):
 #or extra in self._iter_egg_info_extras():
 #etadata["Provides-Extra"] = extra


class BaseEnvironment:
 #""An environment containing distributions to introspect."""

 #classmethod
 #ef default(cls) -> "BaseEnvironment":
 #aise NotImplementedError()

 #classmethod
 #ef from_paths(cls, paths: Optional[List[str]]) -> "BaseEnvironment":
 #aise NotImplementedError()

 #ef get_distribution(self, name: str) -> Optional["BaseDistribution"]:
 #""Given a requirement name, return the installed distributions.

 #he name may not be normalized. The implementation must canonicalize
 #t for lookup.
 #""
 #aise NotImplementedError()

 #ef _iter_distributions(self) -> Iterator["BaseDistribution"]:
 #""Iterate through installed distributions.

 #his function should be implemented by subclass, but never called
 #irectly. Use the public ``iter_distribution()`` instead, which
 #mplements additional logic to make sure the distributions are valid.
 #""
 #aise NotImplementedError()

 #ef iter_all_distributions(self) -> Iterator[BaseDistribution]:
 #""Iterate through all installed distributions without any filtering."""
 #or dist in self._iter_distributions():
            # Make sure the distribution actually comes from a valid Python
            # packaging distribution. Pip's AdjacentTempDirectory leaves folders
            # e.g. ``~atplotlib.dist-info`` if cleanup was interrupted. The
            # valid project name pattern is taken from PEP 508.
 #roject_name_valid = re.match(
 #"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$",
 #ist.canonical_name,
 #lags=re.IGNORECASE,
 #
 #f not project_name_valid:
 #ogger.warning(
 #Ignoring invalid distribution %s (%s)",
 #ist.canonical_name,
 #ist.location,
 #
 #ontinue
 #ield dist

 #ef iter_installed_distributions(
 #elf,
 #ocal_only: bool = True,
 #kip: Container[str] = stdlib_pkgs,
 #nclude_editables: bool = True,
 #ditables_only: bool = False,
 #ser_only: bool = False,
 # -> Iterator[BaseDistribution]:
 #""Return a list of installed distributions.

 #his is based on ``iter_all_distributions()`` with additional filtering
 #ptions. Note that ``iter_installed_distributions()`` without arguments
 #s *not* equal to ``iter_all_distributions()``, since some of the
 #onfigurations exclude packages by default.

 #param local_only: If True (default), only return installations
 #ocal to the current virtualenv, if in a virtualenv.
 #param skip: An iterable of canonicalized project names to ignore;
 #efaults to ``stdlib_pkgs``.
 #param include_editables: If False, don't report editables.
 #param editables_only: If True, only report editables.
 #param user_only: If True, only report installations in the user
 #ite directory.
 #""
 #t = self.iter_all_distributions()
 #f local_only:
 #t = (d for d in it if d.local)
 #f not include_editables:
 #t = (d for d in it if not d.editable)
 #f editables_only:
 #t = (d for d in it if d.editable)
 #f user_only:
 #t = (d for d in it if d.in_usersite)
 #eturn (d for d in it if d.canonical_name not in skip)


class Wheel(Protocol):
 #ocation: str

 #ef as_zipfile(self) -> zipfile.ZipFile:
 #aise NotImplementedError()


class FilesystemWheel(Wheel):
 #ef __init__(self, location: str) -> None:
 #elf.location = location

 #ef as_zipfile(self) -> zipfile.ZipFile:
 #eturn zipfile.ZipFile(self.location, allowZip64=True)


class MemoryWheel(Wheel):
 #ef __init__(self, location: str, stream: IO[bytes]) -> None:
 #elf.location = location
 #elf.stream = stream

 #ef as_zipfile(self) -> zipfile.ZipFile:
 #eturn zipfile.ZipFile(self.stream, allowZip64=True)
