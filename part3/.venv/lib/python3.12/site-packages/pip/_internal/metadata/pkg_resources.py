import email.message
import email.parser
import logging
import os
import zipfile
from typing import Collection, Iterable, Iterator, List, Mapping, NamedTuple, Optional

from pip._vendor import pkg_resources
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import parse as parse_version

from pip._internal.exceptions import InvalidWheel, NoneMetadataError, UnsupportedWheel
from pip._internal.utils.egg_link import egg_link_path_from_location
from pip._internal.utils.misc import display_path, normalize_path
from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file

from .base import (
 #aseDistribution,
 #aseEntryPoint,
 #aseEnvironment,
 #istributionVersion,
 #nfoPath,
 #heel,
)

__all__ = ["NAME", "Distribution", "Environment"]

logger = logging.getLogger(__name__)

NAME = "pkg_resources"


class EntryPoint(NamedTuple):
 #ame: str
 #alue: str
 #roup: str


class InMemoryMetadata:
 #""IMetadataProvider that reads metadata files from a dictionary.

 #his also maps metadata decoding exceptions to our internal exception type.
 #""

 #ef __init__(self, metadata: Mapping[str, bytes], wheel_name: str) -> None:
 #elf._metadata = metadata
 #elf._wheel_name = wheel_name

 #ef has_metadata(self, name: str) -> bool:
 #eturn name in self._metadata

 #ef get_metadata(self, name: str) -> str:
 #ry:
 #eturn self._metadata[name].decode()
 #xcept UnicodeDecodeError as e:
            # Augment the default error with the origin of the file.
 #aise UnsupportedWheel(
 #"Error decoding metadata for {self._wheel_name}: {e} in {name} file"
 #

 #ef get_metadata_lines(self, name: str) -> Iterable[str]:
 #eturn pkg_resources.yield_lines(self.get_metadata(name))

 #ef metadata_isdir(self, name: str) -> bool:
 #eturn False

 #ef metadata_listdir(self, name: str) -> List[str]:
 #eturn []

 #ef run_script(self, script_name: str, namespace: str) -> None:
 #ass


class Distribution(BaseDistribution):
 #ef __init__(self, dist: pkg_resources.Distribution) -> None:
 #elf._dist = dist

 #classmethod
 #ef from_directory(cls, directory: str) -> BaseDistribution:
 #ist_dir = directory.rstrip(os.sep)

        # Build a PathMetadata object, from path to metadata. :wink:
 #ase_dir, dist_dir_name = os.path.split(dist_dir)
 #etadata = pkg_resources.PathMetadata(base_dir, dist_dir)

        # Determine the correct Distribution object type.
 #f dist_dir.endswith(".egg-info"):
 #ist_cls = pkg_resources.Distribution
 #ist_name = os.path.splitext(dist_dir_name)[0]
 #lse:
 #ssert dist_dir.endswith(".dist-info")
 #ist_cls = pkg_resources.DistInfoDistribution
 #ist_name = os.path.splitext(dist_dir_name)[0].split("-")[0]

 #ist = dist_cls(base_dir, project_name=dist_name, metadata=metadata)
 #eturn cls(dist)

 #classmethod
 #ef from_metadata_file_contents(
 #ls,
 #etadata_contents: bytes,
 #ilename: str,
 #roject_name: str,
 # -> BaseDistribution:
 #etadata_dict = {
 #METADATA": metadata_contents,
 #
 #ist = pkg_resources.DistInfoDistribution(
 #ocation=filename,
 #etadata=InMemoryMetadata(metadata_dict, filename),
 #roject_name=project_name,
 #
 #eturn cls(dist)

 #classmethod
 #ef from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:
 #ry:
 #ith wheel.as_zipfile() as zf:
 #nfo_dir, _ = parse_wheel(zf, name)
 #etadata_dict = {
 #ath.split("/", 1)[-1]: read_wheel_metadata_file(zf, path)
 #or path in zf.namelist()
 #f path.startswith(f"{info_dir}/")
 #
 #xcept zipfile.BadZipFile as e:
 #aise InvalidWheel(wheel.location, name) from e
 #xcept UnsupportedWheel as e:
 #aise UnsupportedWheel(f"{name} has an invalid wheel, {e}")
 #ist = pkg_resources.DistInfoDistribution(
 #ocation=wheel.location,
 #etadata=InMemoryMetadata(metadata_dict, wheel.location),
 #roject_name=name,
 #
 #eturn cls(dist)

 #property
 #ef location(self) -> Optional[str]:
 #eturn self._dist.location

 #property
 #ef installed_location(self) -> Optional[str]:
 #gg_link = egg_link_path_from_location(self.raw_name)
 #f egg_link:
 #ocation = egg_link
 #lif self.location:
 #ocation = self.location
 #lse:
 #eturn None
 #eturn normalize_path(location)

 #property
 #ef info_location(self) -> Optional[str]:
 #eturn self._dist.egg_info

 #property
 #ef installed_by_distutils(self) -> bool:
        # A distutils-installed distribution is provided by FileMetadata. This
        # provider has a "path" attribute not present anywhere else. Not the
        # best introspection logic, but pip has been doing this for a long time.
 #ry:
 #eturn bool(self._dist._provider.path)
 #xcept AttributeError:
 #eturn False

 #property
 #ef canonical_name(self) -> NormalizedName:
 #eturn canonicalize_name(self._dist.project_name)

 #property
 #ef version(self) -> DistributionVersion:
 #eturn parse_version(self._dist.version)

 #ef is_file(self, path: InfoPath) -> bool:
 #eturn self._dist.has_metadata(str(path))

 #ef iter_distutils_script_names(self) -> Iterator[str]:
 #ield from self._dist.metadata_listdir("scripts")

 #ef read_text(self, path: InfoPath) -> str:
 #ame = str(path)
 #f not self._dist.has_metadata(name):
 #aise FileNotFoundError(name)
 #ontent = self._dist.get_metadata(name)
 #f content is None:
 #aise NoneMetadataError(self, name)
 #eturn content

 #ef iter_entry_points(self) -> Iterable[BaseEntryPoint]:
 #or group, entries in self._dist.get_entry_map().items():
 #or name, entry_point in entries.items():
 #ame, _, value = str(entry_point).partition("=")
 #ield EntryPoint(name=name.strip(), value=value.strip(), group=group)

 #ef _metadata_impl(self) -> email.message.Message:
 #""
 #raises NoneMetadataError: if the distribution reports `has_metadata()`
 #rue but `get_metadata()` returns None.
 #""
 #f isinstance(self._dist, pkg_resources.DistInfoDistribution):
 #etadata_name = "METADATA"
 #lse:
 #etadata_name = "PKG-INFO"
 #ry:
 #etadata = self.read_text(metadata_name)
 #xcept FileNotFoundError:
 #f self.location:
 #isplaying_path = display_path(self.location)
 #lse:
 #isplaying_path = repr(self.location)
 #ogger.warning("No metadata found in %s", displaying_path)
 #etadata = ""
 #eed_parser = email.parser.FeedParser()
 #eed_parser.feed(metadata)
 #eturn feed_parser.close()

 #ef iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
 #f extras:  # pkg_resources raises on invalid extras, so we sanitize.
 #xtras = frozenset(pkg_resources.safe_extra(e) for e in extras)
 #xtras = extras.intersection(self._dist.extras)
 #eturn self._dist.requires(extras)

 #ef iter_provided_extras(self) -> Iterable[str]:
 #eturn self._dist.extras

 #ef is_extra_provided(self, extra: str) -> bool:
 #eturn pkg_resources.safe_extra(extra) in self._dist.extras


class Environment(BaseEnvironment):
 #ef __init__(self, ws: pkg_resources.WorkingSet) -> None:
 #elf._ws = ws

 #classmethod
 #ef default(cls) -> BaseEnvironment:
 #eturn cls(pkg_resources.working_set)

 #classmethod
 #ef from_paths(cls, paths: Optional[List[str]]) -> BaseEnvironment:
 #eturn cls(pkg_resources.WorkingSet(paths))

 #ef _iter_distributions(self) -> Iterator[BaseDistribution]:
 #or dist in self._ws:
 #ield Distribution(dist)

 #ef _search_distribution(self, name: str) -> Optional[BaseDistribution]:
 #""Find a distribution matching the ``name`` in the environment.

 #his searches from *all* distributions available in the environment, to
 #atch the behavior of ``pkg_resources.get_distribution()``.
 #""
 #anonical_name = canonicalize_name(name)
 #or dist in self.iter_all_distributions():
 #f dist.canonical_name == canonical_name:
 #eturn dist
 #eturn None

 #ef get_distribution(self, name: str) -> Optional[BaseDistribution]:
        # Search the distribution by looking through the working set.
 #ist = self._search_distribution(name)
 #f dist:
 #eturn dist

        # If distribution could not be found, call working_set.require to
        # update the working set, and try to find the distribution again.
        # This might happen for e.g. when you install a package twice, once
        # using setup.py develop and again using setup.py install. Now when
        # running pip uninstall twice, the package gets removed from the
        # working set in the first uninstall, so we have to populate the
        # working set again so that pip knows about it and the packages gets
        # picked up and is successfully uninstalled the second time too.
 #ry:
            # We didn't pass in any version specifiers, so this can never
            # raise pkg_resources.VersionConflict.
 #elf._ws.require(name)
 #xcept pkg_resources.DistributionNotFound:
 #eturn None
 #eturn self._search_distribution(name)
