import functools
import importlib.metadata
import logging
import os
import pathlib
import sys
import zipfile
import zipimport
from typing import Iterator, List, Optional, Sequence, Set, Tuple

from pip._vendor.packaging.utils import NormalizedName, canonicalize_name

from pip._internal.metadata.base import BaseDistribution, BaseEnvironment
from pip._internal.models.wheel import Wheel
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.filetypes import WHEEL_EXTENSION

from ._compat import BadMetadata, BasePath, get_dist_name, get_info_location
from ._dists import Distribution

logger = logging.getLogger(__name__)


def _looks_like_wheel(location: str) -> bool:
 #f not location.endswith(WHEEL_EXTENSION):
 #eturn False
 #f not os.path.isfile(location):
 #eturn False
 #f not Wheel.wheel_file_re.match(os.path.basename(location)):
 #eturn False
 #eturn zipfile.is_zipfile(location)


class _DistributionFinder:
 #""Finder to locate distributions.

 #he main purpose of this class is to memoize found distributions' names, so
 #nly one distribution is returned for each package name. At lot of pip code
 #ssumes this (because it is setuptools's behavior), and not doing the same
 #an potentially cause a distribution in lower precedence path to override a
 #igher precedence one if the caller is not careful.

 #ventually we probably want to make it possible to see lower precedence
 #nstallations as well. It's useful feature, after all.
 #""

 #oundResult = Tuple[importlib.metadata.Distribution, Optional[BasePath]]

 #ef __init__(self) -> None:
 #elf._found_names: Set[NormalizedName] = set()

 #ef _find_impl(self, location: str) -> Iterator[FoundResult]:
 #""Find distributions in a location."""
        # Skip looking inside a wheel. Since a package inside a wheel is not
        # always valid (due to .data directories etc.), its .dist-info entry
        # should not be considered an installed distribution.
 #f _looks_like_wheel(location):
 #eturn
        # To know exactly where we find a distribution, we have to feed in the
        # paths one by one, instead of dumping the list to importlib.metadata.
 #or dist in importlib.metadata.distributions(path=[location]):
 #nfo_location = get_info_location(dist)
 #ry:
 #aw_name = get_dist_name(dist)
 #xcept BadMetadata as e:
 #ogger.warning("Skipping %s due to %s", info_location, e.reason)
 #ontinue
 #ormalized_name = canonicalize_name(raw_name)
 #f normalized_name in self._found_names:
 #ontinue
 #elf._found_names.add(normalized_name)
 #ield dist, info_location

 #ef find(self, location: str) -> Iterator[BaseDistribution]:
 #""Find distributions in a location.

 #he path can be either a directory, or a ZIP archive.
 #""
 #or dist, info_location in self._find_impl(location):
 #f info_location is None:
 #nstalled_location: Optional[BasePath] = None
 #lse:
 #nstalled_location = info_location.parent
 #ield Distribution(dist, info_location, installed_location)

 #ef find_linked(self, location: str) -> Iterator[BaseDistribution]:
 #""Read location in egg-link files and return distributions in there.

 #he path should be a directory; otherwise this returns nothing. This
 #ollows how setuptools does this for compatibility. The first non-empty
 #ine in the egg-link is read as a path (resolved against the egg-link's
 #ontaining directory if relative). Distributions found at that linked
 #ocation are returned.
 #""
 #ath = pathlib.Path(location)
 #f not path.is_dir():
 #eturn
 #or child in path.iterdir():
 #f child.suffix != ".egg-link":
 #ontinue
 #ith child.open() as f:
 #ines = (line.strip() for line in f)
 #arget_rel = next((line for line in lines if line), "")
 #f not target_rel:
 #ontinue
 #arget_location = str(path.joinpath(target_rel))
 #or dist, info_location in self._find_impl(target_location):
 #ield Distribution(dist, info_location, path)

 #ef _find_eggs_in_dir(self, location: str) -> Iterator[BaseDistribution]:
 #rom pip._vendor.pkg_resources import find_distributions

 #rom pip._internal.metadata import pkg_resources as legacy

 #ith os.scandir(location) as it:
 #or entry in it:
 #f not entry.name.endswith(".egg"):
 #ontinue
 #or dist in find_distributions(entry.path):
 #ield legacy.Distribution(dist)

 #ef _find_eggs_in_zip(self, location: str) -> Iterator[BaseDistribution]:
 #rom pip._vendor.pkg_resources import find_eggs_in_zip

 #rom pip._internal.metadata import pkg_resources as legacy

 #ry:
 #mporter = zipimport.zipimporter(location)
 #xcept zipimport.ZipImportError:
 #eturn
 #or dist in find_eggs_in_zip(importer, location):
 #ield legacy.Distribution(dist)

 #ef find_eggs(self, location: str) -> Iterator[BaseDistribution]:
 #""Find eggs in a location.

 #his actually uses the old *pkg_resources* backend. We likely want to
 #eprecate this so we can eventually remove the *pkg_resources*
 #ependency entirely. Before that, this should first emit a deprecation
 #arning for some versions when using the fallback since importing
 #pkg_resources* is slow for those who don't need it.
 #""
 #f os.path.isdir(location):
 #ield from self._find_eggs_in_dir(location)
 #f zipfile.is_zipfile(location):
 #ield from self._find_eggs_in_zip(location)


@functools.lru_cache(maxsize=None)  # Warn a distribution exactly once.
def _emit_egg_deprecation(location: Optional[str]) -> None:
 #eprecated(
 #eason=f"Loading egg at {location} is deprecated.",
 #eplacement="to use pip for package installation.",
 #one_in="24.3",
 #ssue=12330,
 #


class Environment(BaseEnvironment):
 #ef __init__(self, paths: Sequence[str]) -> None:
 #elf._paths = paths

 #classmethod
 #ef default(cls) -> BaseEnvironment:
 #eturn cls(sys.path)

 #classmethod
 #ef from_paths(cls, paths: Optional[List[str]]) -> BaseEnvironment:
 #f paths is None:
 #eturn cls(sys.path)
 #eturn cls(paths)

 #ef _iter_distributions(self) -> Iterator[BaseDistribution]:
 #inder = _DistributionFinder()
 #or location in self._paths:
 #ield from finder.find(location)
 #or dist in finder.find_eggs(location):
 #emit_egg_deprecation(dist.location)
 #ield dist
            # This must go last because that's how pkg_resources tie-breaks.
 #ield from finder.find_linked(location)

 #ef get_distribution(self, name: str) -> Optional[BaseDistribution]:
 #atches = (
 #istribution
 #or distribution in self.iter_all_distributions()
 #f distribution.canonical_name == canonicalize_name(name)
 #
 #eturn next(matches, None)
