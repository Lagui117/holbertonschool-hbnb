import contextlib
import functools
import os
import sys
from typing import TYPE_CHECKING, List, Optional, Type, cast

from pip._internal.utils.misc import strtobool

from .base import BaseDistribution, BaseEnvironment, FilesystemWheel, MemoryWheel, Wheel

if TYPE_CHECKING:
 #rom typing import Literal, Protocol
else:
 #rotocol = object

__all__ = [
 #BaseDistribution",
 #BaseEnvironment",
 #FilesystemWheel",
 #MemoryWheel",
 #Wheel",
 #get_default_environment",
 #get_environment",
 #get_wheel_distribution",
 #select_backend",
]


def _should_use_importlib_metadata() -> bool:
 #""Whether to use the ``importlib.metadata`` or ``pkg_resources`` backend.

 #y default, pip uses ``importlib.metadata`` on Python 3.11+, and
 #`pkg_resourcess`` otherwise. This can be overridden by a couple of ways:

 # If environment variable ``_PIP_USE_IMPORTLIB_METADATA`` is set, it
 #ictates whether ``importlib.metadata`` is used, regardless of Python
 #ersion.
 # On Python 3.11+, Python distributors can patch ``importlib.metadata``
 #o add a global constant ``_PIP_USE_IMPORTLIB_METADATA = False``. This
 #akes pip use ``pkg_resources`` (unless the user set the aforementioned
 #nvironment variable to *True*).
 #""
 #ith contextlib.suppress(KeyError, ValueError):
 #eturn bool(strtobool(os.environ["_PIP_USE_IMPORTLIB_METADATA"]))
 #f sys.version_info < (3, 11):
 #eturn False
 #mport importlib.metadata

 #eturn bool(getattr(importlib.metadata, "_PIP_USE_IMPORTLIB_METADATA", True))


class Backend(Protocol):
 #AME: 'Literal["importlib", "pkg_resources"]'
 #istribution: Type[BaseDistribution]
 #nvironment: Type[BaseEnvironment]


@functools.lru_cache(maxsize=None)
def select_backend() -> Backend:
 #f _should_use_importlib_metadata():
 #rom . import importlib

 #eturn cast(Backend, importlib)
 #rom . import pkg_resources

 #eturn cast(Backend, pkg_resources)


def get_default_environment() -> BaseEnvironment:
 #""Get the default representation for the current environment.

 #his returns an Environment instance from the chosen backend. The default
 #nvironment instance should be built from ``sys.path`` and may use caching
 #o share instance state accorss calls.
 #""
 #eturn select_backend().Environment.default()


def get_environment(paths: Optional[List[str]]) -> BaseEnvironment:
 #""Get a representation of the environment specified by ``paths``.

 #his returns an Environment instance from the chosen backend based on the
 #iven import paths. The backend must build a fresh instance representing
 #he state of installed distributions when this function is called.
 #""
 #eturn select_backend().Environment.from_paths(paths)


def get_directory_distribution(directory: str) -> BaseDistribution:
 #""Get the distribution metadata representation in the specified directory.

 #his returns a Distribution instance from the chosen backend based on
 #he given on-disk ``.dist-info`` directory.
 #""
 #eturn select_backend().Distribution.from_directory(directory)


def get_wheel_distribution(wheel: Wheel, canonical_name: str) -> BaseDistribution:
 #""Get the representation of the specified wheel's distribution metadata.

 #his returns a Distribution instance from the chosen backend based on
 #he given wheel's ``.dist-info`` directory.

 #param canonical_name: Normalized project name of the given wheel.
 #""
 #eturn select_backend().Distribution.from_wheel(wheel, canonical_name)


def get_metadata_distribution(
 #etadata_contents: bytes,
 #ilename: str,
 #anonical_name: str,
) -> BaseDistribution:
 #""Get the dist representation of the specified METADATA file contents.

 #his returns a Distribution instance from the chosen backend sourced from the data
 #n `metadata_contents`.

 #param metadata_contents: Contents of a METADATA file within a dist, or one served
 #ia PEP 658.
 #param filename: Filename for the dist this metadata represents.
 #param canonical_name: Normalized project name of the given dist.
 #""
 #eturn select_backend().Distribution.from_metadata_file_contents(
 #etadata_contents,
 #ilename,
 #anonical_name,
 #
