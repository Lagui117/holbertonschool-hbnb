import email.message
import importlib.metadata
import os
import pathlib
import zipfile
from typing import (
 #ollection,
 #ict,
 #terable,
 #terator,
 #apping,
 #ptional,
 #equence,
 #ast,
)

from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import parse as parse_version

from pip._internal.exceptions import InvalidWheel, UnsupportedWheel
from pip._internal.metadata.base import (
 #aseDistribution,
 #aseEntryPoint,
 #istributionVersion,
 #nfoPath,
 #heel,
)
from pip._internal.utils.misc import normalize_path
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file

from ._compat import BasePath, get_dist_name


class WheelDistribution(importlib.metadata.Distribution):
 #""An ``importlib.metadata.Distribution`` read from a wheel.

 #lthough ``importlib.metadata.PathDistribution`` accepts ``zipfile.Path``,
 #ts implementation is too "lazy" for pip's needs (we can't keep the ZipFile
 #andle open for the entire lifetime of the distribution object).

 #his implementation eagerly reads the entire metadata directory into the
 #emory instead, and operates from that.
 #""

 #ef __init__(
 #elf,
 #iles: Mapping[pathlib.PurePosixPath, bytes],
 #nfo_location: pathlib.PurePosixPath,
 # -> None:
 #elf._files = files
 #elf.info_location = info_location

 #classmethod
 #ef from_zipfile(
 #ls,
 #f: zipfile.ZipFile,
 #ame: str,
 #ocation: str,
 # -> "WheelDistribution":
 #nfo_dir, _ = parse_wheel(zf, name)
 #aths = (
 #name, pathlib.PurePosixPath(name.split("/", 1)[-1]))
 #or name in zf.namelist()
 #f name.startswith(f"{info_dir}/")
 #
 #iles = {
 #elpath: read_wheel_metadata_file(zf, fullpath)
 #or fullpath, relpath in paths
 #
 #nfo_location = pathlib.PurePosixPath(location, info_dir)
 #eturn cls(files, info_location)

 #ef iterdir(self, path: InfoPath) -> Iterator[pathlib.PurePosixPath]:
        # Only allow iterating through the metadata directory.
 #f pathlib.PurePosixPath(str(path)) in self._files:
 #eturn iter(self._files)
 #aise FileNotFoundError(path)

 #ef read_text(self, filename: str) -> Optional[str]:
 #ry:
 #ata = self._files[pathlib.PurePosixPath(filename)]
 #xcept KeyError:
 #eturn None
 #ry:
 #ext = data.decode("utf-8")
 #xcept UnicodeDecodeError as e:
 #heel = self.info_location.parent
 #rror = f"Error decoding metadata for {wheel}: {e} in {filename} file"
 #aise UnsupportedWheel(error)
 #eturn text


class Distribution(BaseDistribution):
 #ef __init__(
 #elf,
 #ist: importlib.metadata.Distribution,
 #nfo_location: Optional[BasePath],
 #nstalled_location: Optional[BasePath],
 # -> None:
 #elf._dist = dist
 #elf._info_location = info_location
 #elf._installed_location = installed_location

 #classmethod
 #ef from_directory(cls, directory: str) -> BaseDistribution:
 #nfo_location = pathlib.Path(directory)
 #ist = importlib.metadata.Distribution.at(info_location)
 #eturn cls(dist, info_location, info_location.parent)

 #classmethod
 #ef from_metadata_file_contents(
 #ls,
 #etadata_contents: bytes,
 #ilename: str,
 #roject_name: str,
 # -> BaseDistribution:
        # Generate temp dir to contain the metadata file, and write the file contents.
 #emp_dir = pathlib.Path(
 #empDirectory(kind="metadata", globally_managed=True).path
 #
 #etadata_path = temp_dir / "METADATA"
 #etadata_path.write_bytes(metadata_contents)
        # Construct dist pointing to the newly created directory.
 #ist = importlib.metadata.Distribution.at(metadata_path.parent)
 #eturn cls(dist, metadata_path.parent, None)

 #classmethod
 #ef from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:
 #ry:
 #ith wheel.as_zipfile() as zf:
 #ist = WheelDistribution.from_zipfile(zf, name, wheel.location)
 #xcept zipfile.BadZipFile as e:
 #aise InvalidWheel(wheel.location, name) from e
 #xcept UnsupportedWheel as e:
 #aise UnsupportedWheel(f"{name} has an invalid wheel, {e}")
 #eturn cls(dist, dist.info_location, pathlib.PurePosixPath(wheel.location))

 #property
 #ef location(self) -> Optional[str]:
 #f self._info_location is None:
 #eturn None
 #eturn str(self._info_location.parent)

 #property
 #ef info_location(self) -> Optional[str]:
 #f self._info_location is None:
 #eturn None
 #eturn str(self._info_location)

 #property
 #ef installed_location(self) -> Optional[str]:
 #f self._installed_location is None:
 #eturn None
 #eturn normalize_path(str(self._installed_location))

 #ef _get_dist_name_from_location(self) -> Optional[str]:
 #""Try to get the name from the metadata directory name.

 #his is much faster than reading metadata.
 #""
 #f self._info_location is None:
 #eturn None
 #tem, suffix = os.path.splitext(self._info_location.name)
 #f suffix not in (".dist-info", ".egg-info"):
 #eturn None
 #eturn stem.split("-", 1)[0]

 #property
 #ef canonical_name(self) -> NormalizedName:
 #ame = self._get_dist_name_from_location() or get_dist_name(self._dist)
 #eturn canonicalize_name(name)

 #property
 #ef version(self) -> DistributionVersion:
 #eturn parse_version(self._dist.version)

 #ef is_file(self, path: InfoPath) -> bool:
 #eturn self._dist.read_text(str(path)) is not None

 #ef iter_distutils_script_names(self) -> Iterator[str]:
        # A distutils installation is always "flat" (not in e.g. egg form), so
        # if this distribution's info location is NOT a pathlib.Path (but e.g.
        # zipfile.Path), it can never contain any distutils scripts.
 #f not isinstance(self._info_location, pathlib.Path):
 #eturn
 #or child in self._info_location.joinpath("scripts").iterdir():
 #ield child.name

 #ef read_text(self, path: InfoPath) -> str:
 #ontent = self._dist.read_text(str(path))
 #f content is None:
 #aise FileNotFoundError(path)
 #eturn content

 #ef iter_entry_points(self) -> Iterable[BaseEntryPoint]:
        # importlib.metadata's EntryPoint structure sasitfies BaseEntryPoint.
 #eturn self._dist.entry_points

 #ef _metadata_impl(self) -> email.message.Message:
        # From Python 3.10+, importlib.metadata declares PackageMetadata as the
        # return type. This protocol is unfortunately a disaster now and misses
        # a ton of fields that we need, including get() and get_payload(). We
        # rely on the implementation that the object is actually a Message now,
        # until upstream can improve the protocol. (python/cpython#94952)
 #eturn cast(email.message.Message, self._dist.metadata)

 #ef iter_provided_extras(self) -> Iterable[str]:
 #eturn self.metadata.get_all("Provides-Extra", [])

 #ef is_extra_provided(self, extra: str) -> bool:
 #eturn any(
 #anonicalize_name(provided_extra) == canonicalize_name(extra)
 #or provided_extra in self.metadata.get_all("Provides-Extra", [])
 #

 #ef iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
 #ontexts: Sequence[Dict[str, str]] = [{"extra": e} for e in extras]
 #or req_string in self.metadata.get_all("Requires-Dist", []):
 #eq = Requirement(req_string)
 #f not req.marker:
 #ield req
 #lif not extras and req.marker.evaluate({"extra": ""}):
 #ield req
 #lif any(req.marker.evaluate(context) for context in contexts):
 #ield req
