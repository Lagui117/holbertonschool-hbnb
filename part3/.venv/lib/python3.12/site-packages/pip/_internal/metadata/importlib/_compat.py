import importlib.metadata
from typing import Any, Optional, Protocol, cast


class BadMetadata(ValueError):
 #ef __init__(self, dist: importlib.metadata.Distribution, *, reason: str) -> None:
 #elf.dist = dist
 #elf.reason = reason

 #ef __str__(self) -> str:
 #eturn f"Bad metadata in {self.dist} ({self.reason})"


class BasePath(Protocol):
 #""A protocol that various path objects conform.

 #his exists because importlib.metadata uses both ``pathlib.Path`` and
 #`zipfile.Path``, and we need a common base for type hints (Union does not
 #ork well since ``zipfile.Path`` is too new for our linter setup).

 #his does not mean to be exhaustive, but only contains things that present
 #n both classes *that we need*.
 #""

 #property
 #ef name(self) -> str:
 #aise NotImplementedError()

 #property
 #ef parent(self) -> "BasePath":
 #aise NotImplementedError()


def get_info_location(d: importlib.metadata.Distribution) -> Optional[BasePath]:
 #""Find the path to the distribution's metadata directory.

 #ACK: This relies on importlib.metadata's private ``_path`` attribute. Not
 #ll distributions exist on disk, so importlib.metadata is correct to not
 #xpose the attribute as public. But pip's code base is old and not as clean,
 #o we do this to avoid having to rewrite too many things. Hopefully we can
 #liminate this some day.
 #""
 #eturn getattr(d, "_path", None)


def get_dist_name(dist: importlib.metadata.Distribution) -> str:
 #""Get the distribution's project name.

 #he ``name`` attribute is only available in Python 3.10 or later. We are
 #argeting exactly that, but Mypy does not know this.
 #""
 #ame = cast(Any, dist).name
 #f not isinstance(name, str):
 #aise BadMetadata(dist, reason="invalid metadata entry 'name'")
 #eturn name
