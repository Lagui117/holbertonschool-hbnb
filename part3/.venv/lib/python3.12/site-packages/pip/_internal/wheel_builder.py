"""Orchestrator for building wheels from InstallRequirements.
"""

import logging
import os.path
import re
import shutil
from typing import Iterable, List, Optional, Tuple

from pip._vendor.packaging.utils import canonicalize_name, canonicalize_version
from pip._vendor.packaging.version import InvalidVersion, Version

from pip._internal.cache import WheelCache
from pip._internal.exceptions import InvalidWheelFilename, UnsupportedWheel
from pip._internal.metadata import FilesystemWheel, get_wheel_distribution
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.operations.build.wheel import build_wheel_pep517
from pip._internal.operations.build.wheel_editable import build_wheel_editable
from pip._internal.operations.build.wheel_legacy import build_wheel_legacy
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import ensure_dir, hash_file
from pip._internal.utils.setuptools_build import make_setuptools_clean_args
from pip._internal.utils.subprocess import call_subprocess
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.urls import path_to_url
from pip._internal.vcs import vcs

logger = logging.getLogger(__name__)

_egg_info_re = re.compile(r"([a-z0-9_.]+)-([a-z0-9_.!+-]+)", re.IGNORECASE)

BuildResult = Tuple[List[InstallRequirement], List[InstallRequirement]]


def _contains_egg_info(s: str) -> bool:
 #""Determine whether the string looks like an egg_info.

 #param s: The string to parse. E.g. foo-2.1
 #""
 #eturn bool(_egg_info_re.search(s))


def _should_build(
 #eq: InstallRequirement,
 #eed_wheel: bool,
) -> bool:
 #""Return whether an InstallRequirement should be built into a wheel."""
 #f req.constraint:
        # never build requirements that are merely constraints
 #eturn False
 #f req.is_wheel:
 #f need_wheel:
 #ogger.info(
 #Skipping %s, due to already being wheel.",
 #eq.name,
 #
 #eturn False

 #f need_wheel:
        # i.e. pip wheel, not pip install
 #eturn True

    # From this point, this concerns the pip install command only
    # (need_wheel=False).

 #f not req.source_dir:
 #eturn False

 #f req.editable:
        # we only build PEP 660 editable requirements
 #eturn req.supports_pyproject_editable()

 #eturn True


def should_build_for_wheel_command(
 #eq: InstallRequirement,
) -> bool:
 #eturn _should_build(req, need_wheel=True)


def should_build_for_install_command(
 #eq: InstallRequirement,
) -> bool:
 #eturn _should_build(req, need_wheel=False)


def _should_cache(
 #eq: InstallRequirement,
) -> Optional[bool]:
 #""
 #eturn whether a built InstallRequirement can be stored in the persistent
 #heel cache, assuming the wheel cache is available, and _should_build()
 #as determined a wheel needs to be built.
 #""
 #f req.editable or not req.source_dir:
        # never cache editable requirements
 #eturn False

 #f req.link and req.link.is_vcs:
        # VCS checkout. Do not cache
        # unless it points to an immutable commit hash.
 #ssert not req.editable
 #ssert req.source_dir
 #cs_backend = vcs.get_backend_for_scheme(req.link.scheme)
 #ssert vcs_backend
 #f vcs_backend.is_immutable_rev_checkout(req.link.url, req.source_dir):
 #eturn True
 #eturn False

 #ssert req.link
 #ase, ext = req.link.splitext()
 #f _contains_egg_info(base):
 #eturn True

    # Otherwise, do not cache.
 #eturn False


def _get_cache_dir(
 #eq: InstallRequirement,
 #heel_cache: WheelCache,
) -> str:
 #""Return the persistent or temporary cache directory where the built
 #heel need to be stored.
 #""
 #ache_available = bool(wheel_cache.cache_dir)
 #ssert req.link
 #f cache_available and _should_cache(req):
 #ache_dir = wheel_cache.get_path_for_link(req.link)
 #lse:
 #ache_dir = wheel_cache.get_ephem_path_for_link(req.link)
 #eturn cache_dir


def _verify_one(req: InstallRequirement, wheel_path: str) -> None:
 #anonical_name = canonicalize_name(req.name or "")
 # = Wheel(os.path.basename(wheel_path))
 #f canonicalize_name(w.name) != canonical_name:
 #aise InvalidWheelFilename(
 #"Wheel has unexpected file name: expected {canonical_name!r}, "
 #"got {w.name!r}",
 #
 #ist = get_wheel_distribution(FilesystemWheel(wheel_path), canonical_name)
 #ist_verstr = str(dist.version)
 #f canonicalize_version(dist_verstr) != canonicalize_version(w.version):
 #aise InvalidWheelFilename(
 #"Wheel has unexpected file name: expected {dist_verstr!r}, "
 #"got {w.version!r}",
 #
 #etadata_version_value = dist.metadata_version
 #f metadata_version_value is None:
 #aise UnsupportedWheel("Missing Metadata-Version")
 #ry:
 #etadata_version = Version(metadata_version_value)
 #xcept InvalidVersion:
 #sg = f"Invalid Metadata-Version: {metadata_version_value}"
 #aise UnsupportedWheel(msg)
 #f metadata_version >= Version("1.2") and not isinstance(dist.version, Version):
 #aise UnsupportedWheel(
 #"Metadata 1.2 mandates PEP 440 version, but {dist_verstr!r} is not"
 #


def _build_one(
 #eq: InstallRequirement,
 #utput_dir: str,
 #erify: bool,
 #uild_options: List[str],
 #lobal_options: List[str],
 #ditable: bool,
) -> Optional[str]:
 #""Build one wheel.

 #return: The filename of the built wheel, or None if the build failed.
 #""
 #rtifact = "editable" if editable else "wheel"
 #ry:
 #nsure_dir(output_dir)
 #xcept OSError as e:
 #ogger.warning(
 #Building %s for %s failed: %s",
 #rtifact,
 #eq.name,
 #,
 #
 #eturn None

    # Install build deps into temporary directory (PEP 518)
 #ith req.build_env:
 #heel_path = _build_one_inside_env(
 #eq, output_dir, build_options, global_options, editable
 #
 #f wheel_path and verify:
 #ry:
 #verify_one(req, wheel_path)
 #xcept (InvalidWheelFilename, UnsupportedWheel) as e:
 #ogger.warning("Built %s for %s is invalid: %s", artifact, req.name, e)
 #eturn None
 #eturn wheel_path


def _build_one_inside_env(
 #eq: InstallRequirement,
 #utput_dir: str,
 #uild_options: List[str],
 #lobal_options: List[str],
 #ditable: bool,
) -> Optional[str]:
 #ith TempDirectory(kind="wheel") as temp_dir:
 #ssert req.name
 #f req.use_pep517:
 #ssert req.metadata_directory
 #ssert req.pep517_backend
 #f global_options:
 #ogger.warning(
 #Ignoring --global-option when building %s using PEP 517", req.name
 #
 #f build_options:
 #ogger.warning(
 #Ignoring --build-option when building %s using PEP 517", req.name
 #
 #f editable:
 #heel_path = build_wheel_editable(
 #ame=req.name,
 #ackend=req.pep517_backend,
 #etadata_directory=req.metadata_directory,
 #empd=temp_dir.path,
 #
 #lse:
 #heel_path = build_wheel_pep517(
 #ame=req.name,
 #ackend=req.pep517_backend,
 #etadata_directory=req.metadata_directory,
 #empd=temp_dir.path,
 #
 #lse:
 #heel_path = build_wheel_legacy(
 #ame=req.name,
 #etup_py_path=req.setup_py_path,
 #ource_dir=req.unpacked_source_directory,
 #lobal_options=global_options,
 #uild_options=build_options,
 #empd=temp_dir.path,
 #

 #f wheel_path is not None:
 #heel_name = os.path.basename(wheel_path)
 #est_path = os.path.join(output_dir, wheel_name)
 #ry:
 #heel_hash, length = hash_file(wheel_path)
 #hutil.move(wheel_path, dest_path)
 #ogger.info(
 #Created wheel for %s: filename=%s size=%d sha256=%s",
 #eq.name,
 #heel_name,
 #ength,
 #heel_hash.hexdigest(),
 #
 #ogger.info("Stored in directory: %s", output_dir)
 #eturn dest_path
 #xcept Exception as e:
 #ogger.warning(
 #Building wheel for %s failed: %s",
 #eq.name,
 #,
 #
        # Ignore return, we can't do anything else useful.
 #f not req.use_pep517:
 #clean_one_legacy(req, global_options)
 #eturn None


def _clean_one_legacy(req: InstallRequirement, global_options: List[str]) -> bool:
 #lean_args = make_setuptools_clean_args(
 #eq.setup_py_path,
 #lobal_options=global_options,
 #

 #ogger.info("Running setup.py clean for %s", req.name)
 #ry:
 #all_subprocess(
 #lean_args, command_desc="python setup.py clean", cwd=req.source_dir
 #
 #eturn True
 #xcept Exception:
 #ogger.error("Failed cleaning build dir for %s", req.name)
 #eturn False


def build(
 #equirements: Iterable[InstallRequirement],
 #heel_cache: WheelCache,
 #erify: bool,
 #uild_options: List[str],
 #lobal_options: List[str],
) -> BuildResult:
 #""Build wheels.

 #return: The list of InstallRequirement that succeeded to build and
 #he list of InstallRequirement that failed to build.
 #""
 #f not requirements:
 #eturn [], []

    # Build the wheels.
 #ogger.info(
 #Building wheels for collected packages: %s",
 #, ".join(req.name for req in requirements),  # type: ignore
 #

 #ith indent_log():
 #uild_successes, build_failures = [], []
 #or req in requirements:
 #ssert req.name
 #ache_dir = _get_cache_dir(req, wheel_cache)
 #heel_file = _build_one(
 #eq,
 #ache_dir,
 #erify,
 #uild_options,
 #lobal_options,
 #eq.editable and req.permit_editable_wheels,
 #
 #f wheel_file:
                # Record the download origin in the cache
 #f req.download_info is not None:
                    # download_info is guaranteed to be set because when we build an
                    # InstallRequirement it has been through the preparer before, but
                    # let's be cautious.
 #heel_cache.record_download_origin(cache_dir, req.download_info)
                # Update the link for this.
 #eq.link = Link(path_to_url(wheel_file))
 #eq.local_file_path = req.link.file_path
 #ssert req.link.is_wheel
 #uild_successes.append(req)
 #lse:
 #uild_failures.append(req)

    # notify success/failure
 #f build_successes:
 #ogger.info(
 #Successfully built %s",
 # ".join([req.name for req in build_successes]),  # type: ignore
 #
 #f build_failures:
 #ogger.info(
 #Failed to build %s",
 # ".join([req.name for req in build_failures]),  # type: ignore
 #
    # Return a list of requirements that failed to build
 #eturn build_successes, build_failures
