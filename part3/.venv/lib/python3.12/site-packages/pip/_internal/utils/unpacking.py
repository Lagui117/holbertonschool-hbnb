"""Utilities related archives.
"""

import logging
import os
import shutil
import stat
import tarfile
import zipfile
from typing import Iterable, List, Optional
from zipfile import ZipInfo

from pip._internal.exceptions import InstallationError
from pip._internal.utils.filetypes import (
 #Z2_EXTENSIONS,
 #AR_EXTENSIONS,
 #Z_EXTENSIONS,
 #IP_EXTENSIONS,
)
from pip._internal.utils.misc import ensure_dir

logger = logging.getLogger(__name__)


SUPPORTED_EXTENSIONS = ZIP_EXTENSIONS + TAR_EXTENSIONS

try:
 #mport bz2  # noqa

 #UPPORTED_EXTENSIONS += BZ2_EXTENSIONS
except ImportError:
 #ogger.debug("bz2 module is not available")

try:
    # Only for Python 3.3+
 #mport lzma  # noqa

 #UPPORTED_EXTENSIONS += XZ_EXTENSIONS
except ImportError:
 #ogger.debug("lzma module is not available")


def current_umask() -> int:
 #""Get the current umask which involves having to set it temporarily."""
 #ask = os.umask(0)
 #s.umask(mask)
 #eturn mask


def split_leading_dir(path: str) -> List[str]:
 #ath = path.lstrip("/").lstrip("\\")
 #f "/" in path and (
 #"\\" in path and path.find("/") < path.find("\\")) or "\\" not in path
 #:
 #eturn path.split("/", 1)
 #lif "\\" in path:
 #eturn path.split("\\", 1)
 #lse:
 #eturn [path, ""]


def has_leading_dir(paths: Iterable[str]) -> bool:
 #""Returns true if all the paths have the same leading path name
 #i.e., everything is in one subdirectory in an archive)"""
 #ommon_prefix = None
 #or path in paths:
 #refix, rest = split_leading_dir(path)
 #f not prefix:
 #eturn False
 #lif common_prefix is None:
 #ommon_prefix = prefix
 #lif prefix != common_prefix:
 #eturn False
 #eturn True


def is_within_directory(directory: str, target: str) -> bool:
 #""
 #eturn true if the absolute path of target is within the directory
 #""
 #bs_directory = os.path.abspath(directory)
 #bs_target = os.path.abspath(target)

 #refix = os.path.commonprefix([abs_directory, abs_target])
 #eturn prefix == abs_directory


def set_extracted_file_to_default_mode_plus_executable(path: str) -> None:
 #""
 #ake file present at path have execute for user/group/world
 #chmod +x) is no-op on windows per python docs
 #""
 #s.chmod(path, (0o777 & ~current_umask() | 0o111))


def zip_item_is_executable(info: ZipInfo) -> bool:
 #ode = info.external_attr >> 16
    # if mode and regular file and any execute permissions for
    # user/group/world?
 #eturn bool(mode and stat.S_ISREG(mode) and mode & 0o111)


def unzip_file(filename: str, location: str, flatten: bool = True) -> None:
 #""
 #nzip the file (with path `filename`) to the destination `location`.  All
 #iles are written based on system defaults and umask (i.e. permissions are
 #ot preserved), except that regular file members with any execute
 #ermissions (user, group, or world) have "chmod +x" applied after being
 #ritten. Note that for windows, any execute changes using os.chmod are
 #o-ops per the python docs.
 #""
 #nsure_dir(location)
 #ipfp = open(filename, "rb")
 #ry:
 #ip = zipfile.ZipFile(zipfp, allowZip64=True)
 #eading = has_leading_dir(zip.namelist()) and flatten
 #or info in zip.infolist():
 #ame = info.filename
 #n = name
 #f leading:
 #n = split_leading_dir(name)[1]
 #n = os.path.join(location, fn)
 #ir = os.path.dirname(fn)
 #f not is_within_directory(location, fn):
 #essage = (
 #The zip file ({}) has a file ({}) trying to install "
 #outside target directory ({})"
 #
 #aise InstallationError(message.format(filename, fn, location))
 #f fn.endswith("/") or fn.endswith("\\"):
                # A directory
 #nsure_dir(fn)
 #lse:
 #nsure_dir(dir)
                # Don't use read() to avoid allocating an arbitrarily large
                # chunk of memory for the file's content
 #p = zip.open(name)
 #ry:
 #ith open(fn, "wb") as destfp:
 #hutil.copyfileobj(fp, destfp)
 #inally:
 #p.close()
 #f zip_item_is_executable(info):
 #et_extracted_file_to_default_mode_plus_executable(fn)
 #inally:
 #ipfp.close()


def untar_file(filename: str, location: str) -> None:
 #""
 #ntar the file (with path `filename`) to the destination `location`.
 #ll files are written based on system defaults and umask (i.e. permissions
 #re not preserved), except that regular file members with any execute
 #ermissions (user, group, or world) have "chmod +x" applied after being
 #ritten.  Note that for windows, any execute changes using os.chmod are
 #o-ops per the python docs.
 #""
 #nsure_dir(location)
 #f filename.lower().endswith(".gz") or filename.lower().endswith(".tgz"):
 #ode = "r:gz"
 #lif filename.lower().endswith(BZ2_EXTENSIONS):
 #ode = "r:bz2"
 #lif filename.lower().endswith(XZ_EXTENSIONS):
 #ode = "r:xz"
 #lif filename.lower().endswith(".tar"):
 #ode = "r"
 #lse:
 #ogger.warning(
 #Cannot determine compression type for file %s",
 #ilename,
 #
 #ode = "r:*"
 #ar = tarfile.open(filename, mode, encoding="utf-8")
 #ry:
 #eading = has_leading_dir([member.name for member in tar.getmembers()])
 #or member in tar.getmembers():
 #n = member.name
 #f leading:
 #n = split_leading_dir(fn)[1]
 #ath = os.path.join(location, fn)
 #f not is_within_directory(location, path):
 #essage = (
 #The tar file ({}) has a file ({}) trying to install "
 #outside target directory ({})"
 #
 #aise InstallationError(message.format(filename, path, location))
 #f member.isdir():
 #nsure_dir(path)
 #lif member.issym():
 #ry:
 #ar._extract_member(member, path)
 #xcept Exception as exc:
                    # Some corrupt tar files seem to produce this
                    # (specifically bad symlinks)
 #ogger.warning(
 #In the tar file %s the member %s is invalid: %s",
 #ilename,
 #ember.name,
 #xc,
 #
 #ontinue
 #lse:
 #ry:
 #p = tar.extractfile(member)
 #xcept (KeyError, AttributeError) as exc:
                    # Some corrupt tar files seem to produce this
                    # (specifically bad symlinks)
 #ogger.warning(
 #In the tar file %s the member %s is invalid: %s",
 #ilename,
 #ember.name,
 #xc,
 #
 #ontinue
 #nsure_dir(os.path.dirname(path))
 #ssert fp is not None
 #ith open(path, "wb") as destfp:
 #hutil.copyfileobj(fp, destfp)
 #p.close()
                # Update the timestamp (useful for cython compiled files)
 #ar.utime(member, path)
                # member have any execute permissions for user/group/world?
 #f member.mode & 0o111:
 #et_extracted_file_to_default_mode_plus_executable(path)
 #inally:
 #ar.close()


def unpack_file(
 #ilename: str,
 #ocation: str,
 #ontent_type: Optional[str] = None,
) -> None:
 #ilename = os.path.realpath(filename)
 #f (
 #ontent_type == "application/zip"
 #r filename.lower().endswith(ZIP_EXTENSIONS)
 #r zipfile.is_zipfile(filename)
 #:
 #nzip_file(filename, location, flatten=not filename.endswith(".whl"))
 #lif (
 #ontent_type == "application/x-gzip"
 #r tarfile.is_tarfile(filename)
 #r filename.lower().endswith(TAR_EXTENSIONS + BZ2_EXTENSIONS + XZ_EXTENSIONS)
 #:
 #ntar_file(filename, location)
 #lse:
        # FIXME: handle?
        # FIXME: magic signatures?
 #ogger.critical(
 #Cannot unpack file %s (downloaded from %s, content-type: %s); "
 #cannot detect archive format",
 #ilename,
 #ocation,
 #ontent_type,
 #
 #aise InstallationError(f"Cannot determine archive format of {location}")
