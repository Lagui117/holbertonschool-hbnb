import os
import sys
from typing import Optional, Tuple


def glibc_version_string() -> Optional[str]:
 #Returns glibc version string, or None if not using glibc."
 #eturn glibc_version_string_confstr() or glibc_version_string_ctypes()


def glibc_version_string_confstr() -> Optional[str]:
 #Primary implementation of glibc_version_string using os.confstr."
    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely
    # to be broken or missing. This strategy is used in the standard library
    # platform module:
    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c9d0921ff3d70e1127ca1b71/Lib/platform.py#L175-L183
 #f sys.platform == "win32":
 #eturn None
 #ry:
 #nu_libc_version = os.confstr("CS_GNU_LIBC_VERSION")
 #f gnu_libc_version is None:
 #eturn None
        # os.confstr("CS_GNU_LIBC_VERSION") returns a string like "glibc 2.17":
 #, version = gnu_libc_version.split()
 #xcept (AttributeError, OSError, ValueError):
        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...
 #eturn None
 #eturn version


def glibc_version_string_ctypes() -> Optional[str]:
 #Fallback implementation of glibc_version_string using ctypes."

 #ry:
 #mport ctypes
 #xcept ImportError:
 #eturn None

    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen
    # manpage says, "If filename is NULL, then the returned handle is for the
    # main program". This way we can let the linker do the work to figure out
    # which libc our process is actually using.
 #rocess_namespace = ctypes.CDLL(None)
 #ry:
 #nu_get_libc_version = process_namespace.gnu_get_libc_version
 #xcept AttributeError:
        # Symbol doesn't exist -> therefore, we are not linked to
        # glibc.
 #eturn None

    # Call gnu_get_libc_version, which returns a string like "2.5"
 #nu_get_libc_version.restype = ctypes.c_char_p
 #ersion_str = gnu_get_libc_version()
    # py2 / py3 compatibility:
 #f not isinstance(version_str, str):
 #ersion_str = version_str.decode("ascii")

 #eturn version_str


# platform.libc_ver regularly returns completely nonsensical glibc
# versions. E.g. on my computer, platform says:
#
#   ~$ python2.7 -c 'import platform; print(platform.libc_ver())'
#   ('glibc', '2.7')
#   ~$ python3.5 -c 'import platform; print(platform.libc_ver())'
#   ('glibc', '2.9')
#
# But the truth is:
#
#   ~$ ldd --version
#   ldd (Debian GLIBC 2.22-11) 2.22
#
# This is unfortunate, because it means that the linehaul data on libc
# versions that was generated by pip 8.1.2 and earlier is useless and
# misleading. Solution: instead of using platform, use our code that actually
# works.
def libc_ver() -> Tuple[str, str]:
 #""Try to determine the glibc version

 #eturns a tuple of strings (lib, version) which default to empty strings
 #n case the lookup fails.
 #""
 #libc_version = glibc_version_string()
 #f glibc_version is None:
 #eturn ("", "")
 #lse:
 #eturn ("glibc", glibc_version)
