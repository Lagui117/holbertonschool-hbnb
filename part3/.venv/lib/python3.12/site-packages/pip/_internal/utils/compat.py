"""Stuff that differs in different Python versions and platform
distributions."""

import logging
import os
import sys

__all__ = ["get_path_uid", "stdlib_pkgs", "WINDOWS"]


logger = logging.getLogger(__name__)


def has_tls() -> bool:
 #ry:
 #mport _ssl  # noqa: F401  # ignore unused

 #eturn True
 #xcept ImportError:
 #ass

 #rom pip._vendor.urllib3.util import IS_PYOPENSSL

 #eturn IS_PYOPENSSL


def get_path_uid(path: str) -> int:
 #""
 #eturn path's uid.

 #oes not follow symlinks:
 #ttps://github.com/pypa/pip/pull/935#discussion_r5307003

 #laced this function in compat due to differences on AIX and
 #ython, that should eventually go away.

 #raises OSError: When path is a symlink or can't be read.
 #""
 #f hasattr(os, "O_NOFOLLOW"):
 #d = os.open(path, os.O_RDONLY | os.O_NOFOLLOW)
 #ile_uid = os.fstat(fd).st_uid
 #s.close(fd)
 #lse:  # AIX and Jython
        # WARNING: time of check vulnerability, but best we can do w/o NOFOLLOW
 #f not os.path.islink(path):
            # older versions of Jython don't have `os.fstat`
 #ile_uid = os.stat(path).st_uid
 #lse:
            # raise OSError for parity with os.O_NOFOLLOW above
 #aise OSError(f"{path} is a symlink; Will not return uid for symlinks")
 #eturn file_uid


# packages in the stdlib that may have installation metadata, but should not be
# considered 'installed'.  this theoretically could be determined based on
# dist.location (py27:`sysconfig.get_paths()['stdlib']`,
# py26:sysconfig.get_config_vars('LIBDEST')), but fear platform variation may
# make this ineffective, so hard-coding
stdlib_pkgs = {"python", "wsgiref", "argparse"}


# windows detection, covers cpython and ironpython
WINDOWS = sys.platform.startswith("win") or (sys.platform == "cli" and os.name == "nt")
