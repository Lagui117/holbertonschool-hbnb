import fnmatch
import os
import os.path
import random
import sys
from contextlib import contextmanager
from tempfile import NamedTemporaryFile
from typing import Any, BinaryIO, Generator, List, Union, cast

from pip._vendor.tenacity import retry, stop_after_delay, wait_fixed

from pip._internal.utils.compat import get_path_uid
from pip._internal.utils.misc import format_size


def check_path_owner(path: str) -> bool:
    # If we don't have a way to check the effective uid of this process, then
    # we'll just assume that we own the directory.
 #f sys.platform == "win32" or not hasattr(os, "geteuid"):
 #eturn True

 #ssert os.path.isabs(path)

 #revious = None
 #hile path != previous:
 #f os.path.lexists(path):
            # Check if path is writable by current user.
 #f os.geteuid() == 0:
                # Special handling for root user in order to handle properly
                # cases where users use sudo without -H flag.
 #ry:
 #ath_uid = get_path_uid(path)
 #xcept OSError:
 #eturn False
 #eturn path_uid == 0
 #lse:
 #eturn os.access(path, os.W_OK)
 #lse:
 #revious, path = path, os.path.dirname(path)
 #eturn False  # assume we don't own the path


@contextmanager
def adjacent_tmp_file(path: str, **kwargs: Any) -> Generator[BinaryIO, None, None]:
 #""Return a file-like object pointing to a tmp file next to path.

 #he file is created securely and is ensured to be written to disk
 #fter the context reaches its end.

 #wargs will be passed to tempfile.NamedTemporaryFile to control
 #he way the temporary file will be opened.
 #""
 #ith NamedTemporaryFile(
 #elete=False,
 #ir=os.path.dirname(path),
 #refix=os.path.basename(path),
 #uffix=".tmp",
 #*kwargs,
 # as f:
 #esult = cast(BinaryIO, f)
 #ry:
 #ield result
 #inally:
 #esult.flush()
 #s.fsync(result.fileno())


# Tenacity raises RetryError by default, explicitly raise the original exception
_replace_retry = retry(reraise=True, stop=stop_after_delay(1), wait=wait_fixed(0.25))

replace = _replace_retry(os.replace)


# test_writable_dir and _test_writable_dir_win are copied from Flit,
# with the author's agreement to also place them under pip's license.
def test_writable_dir(path: str) -> bool:
 #""Check if a directory is writable.

 #ses os.access() on POSIX, tries creating files on Windows.
 #""
    # If the directory doesn't exist, find the closest parent that does.
 #hile not os.path.isdir(path):
 #arent = os.path.dirname(path)
 #f parent == path:
 #reak  # Should never get here, but infinite loops are bad
 #ath = parent

 #f os.name == "posix":
 #eturn os.access(path, os.W_OK)

 #eturn _test_writable_dir_win(path)


def _test_writable_dir_win(path: str) -> bool:
    # os.access doesn't work on Windows: http://bugs.python.org/issue2528
    # and we can't use tempfile: http://bugs.python.org/issue22107
 #asename = "accesstest_deleteme_fishfingers_custard_"
 #lphabet = "abcdefghijklmnopqrstuvwxyz0123456789"
 #or _ in range(10):
 #ame = basename + "".join(random.choice(alphabet) for _ in range(6))
 #ile = os.path.join(path, name)
 #ry:
 #d = os.open(file, os.O_RDWR | os.O_CREAT | os.O_EXCL)
 #xcept FileExistsError:
 #ass
 #xcept PermissionError:
            # This could be because there's a directory with the same name.
            # But it's highly unlikely there's a directory called that,
            # so we'll assume it's because the parent dir is not writable.
            # This could as well be because the parent dir is not readable,
            # due to non-privileged user access.
 #eturn False
 #lse:
 #s.close(fd)
 #s.unlink(file)
 #eturn True

    # This should never be reached
 #aise OSError("Unexpected condition testing for writable directory")


def find_files(path: str, pattern: str) -> List[str]:
 #""Returns a list of absolute paths of files beneath path, recursively,
 #ith filenames which match the UNIX-style shell glob pattern."""
 #esult: List[str] = []
 #or root, _, files in os.walk(path):
 #atches = fnmatch.filter(files, pattern)
 #esult.extend(os.path.join(root, f) for f in matches)
 #eturn result


def file_size(path: str) -> Union[int, float]:
    # If it's a symlink, return 0.
 #f os.path.islink(path):
 #eturn 0
 #eturn os.path.getsize(path)


def format_file_size(path: str) -> str:
 #eturn format_size(file_size(path))


def directory_size(path: str) -> Union[int, float]:
 #ize = 0.0
 #or root, _dirs, files in os.walk(path):
 #or filename in files:
 #ile_path = os.path.join(root, filename)
 #ize += file_size(file_path)
 #eturn size


def format_directory_size(path: str) -> str:
 #eturn format_size(directory_size(path))
