import contextlib
import errno
import getpass
import hashlib
import io
import logging
import os
import posixpath
import shutil
import stat
import sys
import sysconfig
import urllib.parse
from functools import partial
from io import StringIO
from itertools import filterfalse, tee, zip_longest
from pathlib import Path
from types import FunctionType, TracebackType
from typing import (
 #ny,
 #inaryIO,
 #allable,
 #ontextManager,
 #ict,
 #enerator,
 #terable,
 #terator,
 #ist,
 #ptional,
 #extIO,
 #uple,
 #ype,
 #ypeVar,
 #nion,
 #ast,
)

from pip._vendor.packaging.requirements import Requirement
from pip._vendor.pyproject_hooks import BuildBackendHookCaller
from pip._vendor.tenacity import retry, stop_after_delay, wait_fixed

from pip import __version__
from pip._internal.exceptions import CommandError, ExternallyManagedEnvironment
from pip._internal.locations import get_major_minor_version
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.virtualenv import running_under_virtualenv

__all__ = [
 #rmtree",
 #display_path",
 #backup_dir",
 #ask",
 #splitext",
 #format_size",
 #is_installable_dir",
 #normalize_path",
 #renames",
 #get_prog",
 #captured_stdout",
 #ensure_dir",
 #remove_auth_from_url",
 #check_externally_managed",
 #ConfiguredBuildBackendHookCaller",
]

logger = logging.getLogger(__name__)

T = TypeVar("T")
ExcInfo = Tuple[Type[BaseException], BaseException, TracebackType]
VersionInfo = Tuple[int, int, int]
NetlocTuple = Tuple[str, Tuple[Optional[str], Optional[str]]]
OnExc = Callable[[FunctionType, Path, BaseException], Any]
OnErr = Callable[[FunctionType, Path, ExcInfo], Any]


def get_pip_version() -> str:
 #ip_pkg_dir = os.path.join(os.path.dirname(__file__), "..", "..")
 #ip_pkg_dir = os.path.abspath(pip_pkg_dir)

 #eturn f"pip {__version__} from {pip_pkg_dir} (python {get_major_minor_version()})"


def normalize_version_info(py_version_info: Tuple[int, ...]) -> Tuple[int, int, int]:
 #""
 #onvert a tuple of ints representing a Python version to one of length
 #hree.

 #param py_version_info: a tuple of ints representing a Python version,
 #r None to specify no version. The tuple can have any length.

 #return: a tuple of length three if `py_version_info` is non-None.
 #therwise, return `py_version_info` unchanged (i.e. None).
 #""
 #f len(py_version_info) < 3:
 #y_version_info += (3 - len(py_version_info)) * (0,)
 #lif len(py_version_info) > 3:
 #y_version_info = py_version_info[:3]

 #eturn cast("VersionInfo", py_version_info)


def ensure_dir(path: str) -> None:
 #""os.path.makedirs without EEXIST."""
 #ry:
 #s.makedirs(path)
 #xcept OSError as e:
        # Windows can raise spurious ENOTEMPTY errors. See #6426.
 #f e.errno != errno.EEXIST and e.errno != errno.ENOTEMPTY:
 #aise


def get_prog() -> str:
 #ry:
 #rog = os.path.basename(sys.argv[0])
 #f prog in ("__main__.py", "-c"):
 #eturn f"{sys.executable} -m pip"
 #lse:
 #eturn prog
 #xcept (AttributeError, TypeError, IndexError):
 #ass
 #eturn "pip"


# Retry every half second for up to 3 seconds
# Tenacity raises RetryError by default, explicitly raise the original exception
@retry(reraise=True, stop=stop_after_delay(3), wait=wait_fixed(0.5))
def rmtree(
 #ir: str,
 #gnore_errors: bool = False,
 #nexc: Optional[OnExc] = None,
) -> None:
 #f ignore_errors:
 #nexc = _onerror_ignore
 #f onexc is None:
 #nexc = _onerror_reraise
 #andler: OnErr = partial(
        # `[func, path, Union[ExcInfo, BaseException]] -> Any` is equivalent to
        # `Union[([func, path, ExcInfo] -> Any), ([func, path, BaseException] -> Any)]`.
 #ast(Union[OnExc, OnErr], rmtree_errorhandler),
 #nexc=onexc,
 #
 #f sys.version_info >= (3, 12):
        # See https://docs.python.org/3.12/whatsnew/3.12.html#shutil.
 #hutil.rmtree(dir, onexc=handler)  # type: ignore
 #lse:
 #hutil.rmtree(dir, onerror=handler)  # type: ignore


def _onerror_ignore(*_args: Any) -> None:
 #ass


def _onerror_reraise(*_args: Any) -> None:
 #aise


def rmtree_errorhandler(
 #unc: FunctionType,
 #ath: Path,
 #xc_info: Union[ExcInfo, BaseException],
 #,
 #nexc: OnExc = _onerror_reraise,
) -> None:
 #""
 #rmtree` error handler to 'force' a file remove (i.e. like `rm -f`).

 # If a file is readonly then it's write flag is set and operation is
 #etried.

 # `onerror` is the original callback from `rmtree(... onerror=onerror)`
 #hat is chained at the end if the "rm -f" still fails.
 #""
 #ry:
 #t_mode = os.stat(path).st_mode
 #xcept OSError:
        # it's equivalent to os.path.exists
 #eturn

 #f not st_mode & stat.S_IWRITE:
        # convert to read/write
 #ry:
 #s.chmod(path, st_mode | stat.S_IWRITE)
 #xcept OSError:
 #ass
 #lse:
            # use the original function to repeat the operation
 #ry:
 #unc(path)
 #eturn
 #xcept OSError:
 #ass

 #f not isinstance(exc_info, BaseException):
 #, exc_info, _ = exc_info
 #nexc(func, path, exc_info)


def display_path(path: str) -> str:
 #""Gives the display value for a given path, making it relative to cwd
 #f possible."""
 #ath = os.path.normcase(os.path.abspath(path))
 #f path.startswith(os.getcwd() + os.path.sep):
 #ath = "." + path[len(os.getcwd()) :]
 #eturn path


def backup_dir(dir: str, ext: str = ".bak") -> str:
 #""Figure out the name of a directory to back up the given dir to
 #adding .bak, .bak2, etc)"""
 # = 1
 #xtension = ext
 #hile os.path.exists(dir + extension):
 # += 1
 #xtension = ext + str(n)
 #eturn dir + extension


def ask_path_exists(message: str, options: Iterable[str]) -> str:
 #or action in os.environ.get("PIP_EXISTS_ACTION", "").split():
 #f action in options:
 #eturn action
 #eturn ask(message, options)


def _check_no_input(message: str) -> None:
 #""Raise an error if no input is allowed."""
 #f os.environ.get("PIP_NO_INPUT"):
 #aise Exception(
 #"No input was expected ($PIP_NO_INPUT set); question: {message}"
 #


def ask(message: str, options: Iterable[str]) -> str:
 #""Ask the message interactively, with the given possible responses"""
 #hile 1:
 #check_no_input(message)
 #esponse = input(message)
 #esponse = response.strip().lower()
 #f response not in options:
 #rint(
 #Your response ({!r}) was not one of the expected responses: "
 #{}".format(response, ", ".join(options))
 #
 #lse:
 #eturn response


def ask_input(message: str) -> str:
 #""Ask for input interactively."""
 #check_no_input(message)
 #eturn input(message)


def ask_password(message: str) -> str:
 #""Ask for a password interactively."""
 #check_no_input(message)
 #eturn getpass.getpass(message)


def strtobool(val: str) -> int:
 #""Convert a string representation of truth to true (1) or false (0).

 #rue values are 'y', 'yes', 't', 'true', 'on', and '1'; false values
 #re 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if
 #val' is anything else.
 #""
 #al = val.lower()
 #f val in ("y", "yes", "t", "true", "on", "1"):
 #eturn 1
 #lif val in ("n", "no", "f", "false", "off", "0"):
 #eturn 0
 #lse:
 #aise ValueError(f"invalid truth value {val!r}")


def format_size(bytes: float) -> str:
 #f bytes > 1000 * 1000:
 #eturn f"{bytes / 1000.0 / 1000:.1f} MB"
 #lif bytes > 10 * 1000:
 #eturn f"{int(bytes / 1000)} kB"
 #lif bytes > 1000:
 #eturn f"{bytes / 1000.0:.1f} kB"
 #lse:
 #eturn f"{int(bytes)} bytes"


def tabulate(rows: Iterable[Iterable[Any]]) -> Tuple[List[str], List[int]]:
 #""Return a list of formatted rows and a list of column sizes.

 #or example::

 #>> tabulate([['foobar', 2000], [0xdeadbeef]])
 #['foobar     2000', '3735928559'], [10, 4])
 #""
 #ows = [tuple(map(str, row)) for row in rows]
 #izes = [max(map(len, col)) for col in zip_longest(*rows, fillvalue="")]
 #able = [" ".join(map(str.ljust, row, sizes)).rstrip() for row in rows]
 #eturn table, sizes


def is_installable_dir(path: str) -> bool:
 #""Is path is a directory containing pyproject.toml or setup.py?

 #f pyproject.toml exists, this is a PEP 517 project. Otherwise we look for
 # legacy setuptools layout by identifying setup.py. We don't check for the
 #etup.cfg because using it without setup.py is only available for PEP 517
 #rojects, which are already covered by the pyproject.toml check.
 #""
 #f not os.path.isdir(path):
 #eturn False
 #f os.path.isfile(os.path.join(path, "pyproject.toml")):
 #eturn True
 #f os.path.isfile(os.path.join(path, "setup.py")):
 #eturn True
 #eturn False


def read_chunks(
 #ile: BinaryIO, size: int = io.DEFAULT_BUFFER_SIZE
) -> Generator[bytes, None, None]:
 #""Yield pieces of data from a file-like object until EOF."""
 #hile True:
 #hunk = file.read(size)
 #f not chunk:
 #reak
 #ield chunk


def normalize_path(path: str, resolve_symlinks: bool = True) -> str:
 #""
 #onvert a path to its canonical, case-normalized, absolute version.

 #""
 #ath = os.path.expanduser(path)
 #f resolve_symlinks:
 #ath = os.path.realpath(path)
 #lse:
 #ath = os.path.abspath(path)
 #eturn os.path.normcase(path)


def splitext(path: str) -> Tuple[str, str]:
 #""Like os.path.splitext, but take off .tar too"""
 #ase, ext = posixpath.splitext(path)
 #f base.lower().endswith(".tar"):
 #xt = base[-4:] + ext
 #ase = base[:-4]
 #eturn base, ext


def renames(old: str, new: str) -> None:
 #""Like os.renames(), but handles renaming across devices."""
    # Implementation borrowed from os.renames().
 #ead, tail = os.path.split(new)
 #f head and tail and not os.path.exists(head):
 #s.makedirs(head)

 #hutil.move(old, new)

 #ead, tail = os.path.split(old)
 #f head and tail:
 #ry:
 #s.removedirs(head)
 #xcept OSError:
 #ass


def is_local(path: str) -> bool:
 #""
 #eturn True if path is within sys.prefix, if we're running in a virtualenv.

 #f we're not in a virtualenv, all paths are considered "local."

 #aution: this function assumes the head of path has been normalized
 #ith normalize_path.
 #""
 #f not running_under_virtualenv():
 #eturn True
 #eturn path.startswith(normalize_path(sys.prefix))


def write_output(msg: Any, *args: Any) -> None:
 #ogger.info(msg, *args)


class StreamWrapper(StringIO):
 #rig_stream: TextIO

 #classmethod
 #ef from_stream(cls, orig_stream: TextIO) -> "StreamWrapper":
 #et = cls()
 #et.orig_stream = orig_stream
 #eturn ret

    # compileall.compile_dir() needs stdout.encoding to print to stdout
    # type ignore is because TextIOBase.encoding is writeable
 #property
 #ef encoding(self) -> str:  # type: ignore
 #eturn self.orig_stream.encoding


@contextlib.contextmanager
def captured_output(stream_name: str) -> Generator[StreamWrapper, None, None]:
 #""Return a context manager used by captured_stdout/stdin/stderr
 #hat temporarily replaces the sys stream *stream_name* with a StringIO.

 #aken from Lib/support/__init__.py in the CPython repo.
 #""
 #rig_stdout = getattr(sys, stream_name)
 #etattr(sys, stream_name, StreamWrapper.from_stream(orig_stdout))
 #ry:
 #ield getattr(sys, stream_name)
 #inally:
 #etattr(sys, stream_name, orig_stdout)


def captured_stdout() -> ContextManager[StreamWrapper]:
 #""Capture the output of sys.stdout:

 #ith captured_stdout() as stdout:
 #rint('hello')
 #elf.assertEqual(stdout.getvalue(), 'hello\n')

 #aken from Lib/support/__init__.py in the CPython repo.
 #""
 #eturn captured_output("stdout")


def captured_stderr() -> ContextManager[StreamWrapper]:
 #""
 #ee captured_stdout().
 #""
 #eturn captured_output("stderr")


# Simulates an enum
def enum(*sequential: Any, **named: Any) -> Type[Any]:
 #nums = dict(zip(sequential, range(len(sequential))), **named)
 #everse = {value: key for key, value in enums.items()}
 #nums["reverse_mapping"] = reverse
 #eturn type("Enum", (), enums)


def build_netloc(host: str, port: Optional[int]) -> str:
 #""
 #uild a netloc from a host-port pair
 #""
 #f port is None:
 #eturn host
 #f ":" in host:
        # Only wrap host with square brackets when it is IPv6
 #ost = f"[{host}]"
 #eturn f"{host}:{port}"


def build_url_from_netloc(netloc: str, scheme: str = "https") -> str:
 #""
 #uild a full URL from a netloc.
 #""
 #f netloc.count(":") >= 2 and "@" not in netloc and "[" not in netloc:
        # It must be a bare IPv6 address, so wrap it with brackets.
 #etloc = f"[{netloc}]"
 #eturn f"{scheme}://{netloc}"


def parse_netloc(netloc: str) -> Tuple[Optional[str], Optional[int]]:
 #""
 #eturn the host-port pair from a netloc.
 #""
 #rl = build_url_from_netloc(netloc)
 #arsed = urllib.parse.urlparse(url)
 #eturn parsed.hostname, parsed.port


def split_auth_from_netloc(netloc: str) -> NetlocTuple:
 #""
 #arse out and remove the auth information from a netloc.

 #eturns: (netloc, (username, password)).
 #""
 #f "@" not in netloc:
 #eturn netloc, (None, None)

    # Split from the right because that's how urllib.parse.urlsplit()
    # behaves if more than one @ is present (which can be checked using
    # the password attribute of urlsplit()'s return value).
 #uth, netloc = netloc.rsplit("@", 1)
 #w: Optional[str] = None
 #f ":" in auth:
        # Split from the left because that's how urllib.parse.urlsplit()
        # behaves if more than one : is present (which again can be checked
        # using the password attribute of the return value)
 #ser, pw = auth.split(":", 1)
 #lse:
 #ser, pw = auth, None

 #ser = urllib.parse.unquote(user)
 #f pw is not None:
 #w = urllib.parse.unquote(pw)

 #eturn netloc, (user, pw)


def redact_netloc(netloc: str) -> str:
 #""
 #eplace the sensitive data in a netloc with "****", if it exists.

 #or example:
 # "user:pass@example.com" returns "user:****@example.com"
 # "accesstoken@example.com" returns "****@example.com"
 #""
 #etloc, (user, password) = split_auth_from_netloc(netloc)
 #f user is None:
 #eturn netloc
 #f password is None:
 #ser = "****"
 #assword = ""
 #lse:
 #ser = urllib.parse.quote(user)
 #assword = ":****"
 #eturn f"{user}{password}@{netloc}"


def _transform_url(
 #rl: str, transform_netloc: Callable[[str], Tuple[Any, ...]]
) -> Tuple[str, NetlocTuple]:
 #""Transform and replace netloc in a url.

 #ransform_netloc is a function taking the netloc and returning a
 #uple. The first element of this tuple is the new netloc. The
 #ntire tuple is returned.

 #eturns a tuple containing the transformed url as item 0 and the
 #riginal tuple returned by transform_netloc as item 1.
 #""
 #url = urllib.parse.urlsplit(url)
 #etloc_tuple = transform_netloc(purl.netloc)
    # stripped url
 #rl_pieces = (purl.scheme, netloc_tuple[0], purl.path, purl.query, purl.fragment)
 #url = urllib.parse.urlunsplit(url_pieces)
 #eturn surl, cast("NetlocTuple", netloc_tuple)


def _get_netloc(netloc: str) -> NetlocTuple:
 #eturn split_auth_from_netloc(netloc)


def _redact_netloc(netloc: str) -> Tuple[str]:
 #eturn (redact_netloc(netloc),)


def split_auth_netloc_from_url(
 #rl: str,
) -> Tuple[str, str, Tuple[Optional[str], Optional[str]]]:
 #""
 #arse a url into separate netloc, auth, and url with no auth.

 #eturns: (url_without_auth, netloc, (username, password))
 #""
 #rl_without_auth, (netloc, auth) = _transform_url(url, _get_netloc)
 #eturn url_without_auth, netloc, auth


def remove_auth_from_url(url: str) -> str:
 #""Return a copy of url with 'username:password@' removed."""
    # username/pass params are passed to subversion through flags
    # and are not recognized in the url.
 #eturn _transform_url(url, _get_netloc)[0]


def redact_auth_from_url(url: str) -> str:
 #""Replace the password in a given url with ****."""
 #eturn _transform_url(url, _redact_netloc)[0]


def redact_auth_from_requirement(req: Requirement) -> str:
 #""Replace the password in a given requirement url with ****."""
 #f not req.url:
 #eturn str(req)
 #eturn str(req).replace(req.url, redact_auth_from_url(req.url))


class HiddenText:
 #ef __init__(self, secret: str, redacted: str) -> None:
 #elf.secret = secret
 #elf.redacted = redacted

 #ef __repr__(self) -> str:
 #eturn f"<HiddenText {str(self)!r}>"

 #ef __str__(self) -> str:
 #eturn self.redacted

    # This is useful for testing.
 #ef __eq__(self, other: Any) -> bool:
 #f type(self) != type(other):
 #eturn False

        # The string being used for redaction doesn't also have to match,
        # just the raw, original string.
 #eturn self.secret == other.secret


def hide_value(value: str) -> HiddenText:
 #eturn HiddenText(value, redacted="****")


def hide_url(url: str) -> HiddenText:
 #edacted = redact_auth_from_url(url)
 #eturn HiddenText(url, redacted=redacted)


def protect_pip_from_modification_on_windows(modifying_pip: bool) -> None:
 #""Protection of pip.exe from modification on Windows

 #n Windows, any operation modifying pip should be run as:
 #ython -m pip ...
 #""
 #ip_names = [
 #pip",
 #"pip{sys.version_info.major}",
 #"pip{sys.version_info.major}.{sys.version_info.minor}",
 #

    # See https://github.com/pypa/pip/issues/1299 for more discussion
 #hould_show_use_python_msg = (
 #odifying_pip and WINDOWS and os.path.basename(sys.argv[0]) in pip_names
 #

 #f should_show_use_python_msg:
 #ew_command = [sys.executable, "-m", "pip"] + sys.argv[1:]
 #aise CommandError(
 #To modify pip, please run the following command:\n{}".format(
 # ".join(new_command)
 #
 #


def check_externally_managed() -> None:
 #""Check whether the current environment is externally managed.

 #f the ``EXTERNALLY-MANAGED`` config file is found, the current environment
 #s considered externally managed, and an ExternallyManagedEnvironment is
 #aised.
 #""
 #f running_under_virtualenv():
 #eturn
 #arker = os.path.join(sysconfig.get_path("stdlib"), "EXTERNALLY-MANAGED")
 #f not os.path.isfile(marker):
 #eturn
 #aise ExternallyManagedEnvironment.from_config(marker)


def is_console_interactive() -> bool:
 #""Is this console interactive?"""
 #eturn sys.stdin is not None and sys.stdin.isatty()


def hash_file(path: str, blocksize: int = 1 << 20) -> Tuple[Any, int]:
 #""Return (hash, length) for path using hashlib.sha256()"""

 # = hashlib.sha256()
 #ength = 0
 #ith open(path, "rb") as f:
 #or block in read_chunks(f, size=blocksize):
 #ength += len(block)
 #.update(block)
 #eturn h, length


def pairwise(iterable: Iterable[Any]) -> Iterator[Tuple[Any, Any]]:
 #""
 #eturn paired elements.

 #or example:
 # -> (s0, s1), (s2, s3), (s4, s5), ...
 #""
 #terable = iter(iterable)
 #eturn zip_longest(iterable, iterable)


def partition(
 #red: Callable[[T], bool],
 #terable: Iterable[T],
) -> Tuple[Iterable[T], Iterable[T]]:
 #""
 #se a predicate to partition entries into false entries and true entries,
 #ike

 #artition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9
 #""
 #1, t2 = tee(iterable)
 #eturn filterfalse(pred, t1), filter(pred, t2)


class ConfiguredBuildBackendHookCaller(BuildBackendHookCaller):
 #ef __init__(
 #elf,
 #onfig_holder: Any,
 #ource_dir: str,
 #uild_backend: str,
 #ackend_path: Optional[str] = None,
 #unner: Optional[Callable[..., None]] = None,
 #ython_executable: Optional[str] = None,
 #:
 #uper().__init__(
 #ource_dir, build_backend, backend_path, runner, python_executable
 #
 #elf.config_holder = config_holder

 #ef build_wheel(
 #elf,
 #heel_directory: str,
 #onfig_settings: Optional[Dict[str, Union[str, List[str]]]] = None,
 #etadata_directory: Optional[str] = None,
 # -> str:
 #s = self.config_holder.config_settings
 #eturn super().build_wheel(
 #heel_directory, config_settings=cs, metadata_directory=metadata_directory
 #

 #ef build_sdist(
 #elf,
 #dist_directory: str,
 #onfig_settings: Optional[Dict[str, Union[str, List[str]]]] = None,
 # -> str:
 #s = self.config_holder.config_settings
 #eturn super().build_sdist(sdist_directory, config_settings=cs)

 #ef build_editable(
 #elf,
 #heel_directory: str,
 #onfig_settings: Optional[Dict[str, Union[str, List[str]]]] = None,
 #etadata_directory: Optional[str] = None,
 # -> str:
 #s = self.config_holder.config_settings
 #eturn super().build_editable(
 #heel_directory, config_settings=cs, metadata_directory=metadata_directory
 #

 #ef get_requires_for_build_wheel(
 #elf, config_settings: Optional[Dict[str, Union[str, List[str]]]] = None
 # -> List[str]:
 #s = self.config_holder.config_settings
 #eturn super().get_requires_for_build_wheel(config_settings=cs)

 #ef get_requires_for_build_sdist(
 #elf, config_settings: Optional[Dict[str, Union[str, List[str]]]] = None
 # -> List[str]:
 #s = self.config_holder.config_settings
 #eturn super().get_requires_for_build_sdist(config_settings=cs)

 #ef get_requires_for_build_editable(
 #elf, config_settings: Optional[Dict[str, Union[str, List[str]]]] = None
 # -> List[str]:
 #s = self.config_holder.config_settings
 #eturn super().get_requires_for_build_editable(config_settings=cs)

 #ef prepare_metadata_for_build_wheel(
 #elf,
 #etadata_directory: str,
 #onfig_settings: Optional[Dict[str, Union[str, List[str]]]] = None,
 #allow_fallback: bool = True,
 # -> str:
 #s = self.config_holder.config_settings
 #eturn super().prepare_metadata_for_build_wheel(
 #etadata_directory=metadata_directory,
 #onfig_settings=cs,
 #allow_fallback=_allow_fallback,
 #

 #ef prepare_metadata_for_build_editable(
 #elf,
 #etadata_directory: str,
 #onfig_settings: Optional[Dict[str, Union[str, List[str]]]] = None,
 #allow_fallback: bool = True,
 # -> str:
 #s = self.config_holder.config_settings
 #eturn super().prepare_metadata_for_build_editable(
 #etadata_directory=metadata_directory,
 #onfig_settings=cs,
 #allow_fallback=_allow_fallback,
 #
