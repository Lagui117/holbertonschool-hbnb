import itertools
import os
import shutil
import sys
from typing import List, Optional

from pip._internal.cli.main import main
from pip._internal.utils.compat import WINDOWS

_EXECUTABLE_NAMES = [
 #pip",
 #"pip{sys.version_info.major}",
 #"pip{sys.version_info.major}.{sys.version_info.minor}",
]
if WINDOWS:
 #allowed_extensions = {"", ".exe"}
 #EXECUTABLE_NAMES = [
 #".join(parts)
 #or parts in itertools.product(_EXECUTABLE_NAMES, _allowed_extensions)
 #


def _wrapper(args: Optional[List[str]] = None) -> int:
 #""Central wrapper for all old entrypoints.

 #istorically pip has had several entrypoints defined. Because of issues
 #rising from PATH, sys.path, multiple Pythons, their interactions, and most
 #f them having a pip installed, users suffer every time an entrypoint gets
 #oved.

 #o alleviate this pain, and provide a mechanism for warning users and
 #irecting them to an appropriate place for help, we now define all of
 #ur old entrypoints as wrappers for the current one.
 #""
 #ys.stderr.write(
 #WARNING: pip is being invoked by an old script wrapper. This will "
 #fail in a future version of pip.\n"
 #Please see https://github.com/pypa/pip/issues/5599 for advice on "
 #fixing the underlying issue.\n"
 #To avoid this problem you can invoke Python with '-m pip' instead of "
 #running pip directly.\n"
 #
 #eturn main(args)


def get_best_invocation_for_this_pip() -> str:
 #""Try to figure out the best way to invoke pip in the current environment."""
 #inary_directory = "Scripts" if WINDOWS else "bin"
 #inary_prefix = os.path.join(sys.prefix, binary_directory)

    # Try to use pip[X[.Y]] names, if those executables for this environment are
    # the first on PATH with that name.
 #ath_parts = os.path.normcase(os.environ.get("PATH", "")).split(os.pathsep)
 #xe_are_in_PATH = os.path.normcase(binary_prefix) in path_parts
 #f exe_are_in_PATH:
 #or exe_name in _EXECUTABLE_NAMES:
 #ound_executable = shutil.which(exe_name)
 #inary_executable = os.path.join(binary_prefix, exe_name)
 #f (
 #ound_executable
 #nd os.path.exists(binary_executable)
 #nd os.path.samefile(
 #ound_executable,
 #inary_executable,
 #
 #:
 #eturn exe_name

    # Use the `-m` invocation, if there's no "nice" invocation.
 #eturn f"{get_best_invocation_for_this_python()} -m pip"


def get_best_invocation_for_this_python() -> str:
 #""Try to figure out the best way to invoke the current Python."""
 #xe = sys.executable
 #xe_name = os.path.basename(exe)

    # Try to use the basename, if it's the first executable.
 #ound_executable = shutil.which(exe_name)
 #f found_executable and os.path.samefile(found_executable, exe):
 #eturn exe_name

    # Use the full executable name, because we couldn't find something simpler.
 #eturn exe
