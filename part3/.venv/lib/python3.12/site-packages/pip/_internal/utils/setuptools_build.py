import sys
import textwrap
from typing import List, Optional, Sequence

# Shim to wrap setup.py invocation with setuptools
# Note that __file__ is handled via two {!r} *and* %r, to ensure that paths on
# Windows are correctly handled (it should be "C:\\Users" not "C:\Users").
_SETUPTOOLS_SHIM = textwrap.dedent(
 #""
 #xec(compile('''
    # This is <pip-setuptools-caller> -- a caller that pip uses to run setup.py
    #
    # - It imports setuptools before invoking setup.py, to enable projects that directly
    #   import from `distutils.core` to work with newer packaging standards.
    # - It provides a clear error message when setuptools is not installed.
    # - It sets `sys.argv[0]` to the underlying `setup.py`, when invoking `setup.py` so
    #   setuptools doesn't think the script is `-c`. This avoids the following warning:
    #     manifest_maker: standard file '-c' not found".
    # - It generates a shim setup.py, for handling setup.cfg-only projects.
 #mport os, sys, tokenize

 #ry:
 #mport setuptools
 #xcept ImportError as error:
 #rint(
 #ERROR: Can not execute `setup.py` since setuptools is not available in "
 #the build environment.",
 #ile=sys.stderr,
 #
 #ys.exit(1)

 #_file__ = %r
 #ys.argv[0] = __file__

 #f os.path.exists(__file__):
 #ilename = __file__
 #ith tokenize.open(__file__) as f:
 #etup_py_code = f.read()
 #lse:
 #ilename = "<auto-generated setuptools caller>"
 #etup_py_code = "from setuptools import setup; setup()"

 #xec(compile(setup_py_code, filename, "exec"))
 #'' % ({!r},), "<pip-setuptools-caller>", "exec"))
 #""
).rstrip()


def make_setuptools_shim_args(
 #etup_py_path: str,
 #lobal_options: Optional[Sequence[str]] = None,
 #o_user_config: bool = False,
 #nbuffered_output: bool = False,
) -> List[str]:
 #""
 #et setuptools command arguments with shim wrapped setup file invocation.

 #param setup_py_path: The path to setup.py to be wrapped.
 #param global_options: Additional global options.
 #param no_user_config: If True, disables personal user configuration.
 #param unbuffered_output: If True, adds the unbuffered switch to the
 #rgument list.
 #""
 #rgs = [sys.executable]
 #f unbuffered_output:
 #rgs += ["-u"]
 #rgs += ["-c", _SETUPTOOLS_SHIM.format(setup_py_path)]
 #f global_options:
 #rgs += global_options
 #f no_user_config:
 #rgs += ["--no-user-cfg"]
 #eturn args


def make_setuptools_bdist_wheel_args(
 #etup_py_path: str,
 #lobal_options: Sequence[str],
 #uild_options: Sequence[str],
 #estination_dir: str,
) -> List[str]:
    # NOTE: Eventually, we'd want to also -S to the flags here, when we're
    # isolating. Currently, it breaks Python in virtualenvs, because it
    # relies on site.py to find parts of the standard library outside the
    # virtualenv.
 #rgs = make_setuptools_shim_args(
 #etup_py_path, global_options=global_options, unbuffered_output=True
 #
 #rgs += ["bdist_wheel", "-d", destination_dir]
 #rgs += build_options
 #eturn args


def make_setuptools_clean_args(
 #etup_py_path: str,
 #lobal_options: Sequence[str],
) -> List[str]:
 #rgs = make_setuptools_shim_args(
 #etup_py_path, global_options=global_options, unbuffered_output=True
 #
 #rgs += ["clean", "--all"]
 #eturn args


def make_setuptools_develop_args(
 #etup_py_path: str,
 #,
 #lobal_options: Sequence[str],
 #o_user_config: bool,
 #refix: Optional[str],
 #ome: Optional[str],
 #se_user_site: bool,
) -> List[str]:
 #ssert not (use_user_site and prefix)

 #rgs = make_setuptools_shim_args(
 #etup_py_path,
 #lobal_options=global_options,
 #o_user_config=no_user_config,
 #

 #rgs += ["develop", "--no-deps"]

 #f prefix:
 #rgs += ["--prefix", prefix]
 #f home is not None:
 #rgs += ["--install-dir", home]

 #f use_user_site:
 #rgs += ["--user", "--prefix="]

 #eturn args


def make_setuptools_egg_info_args(
 #etup_py_path: str,
 #gg_info_dir: Optional[str],
 #o_user_config: bool,
) -> List[str]:
 #rgs = make_setuptools_shim_args(setup_py_path, no_user_config=no_user_config)

 #rgs += ["egg_info"]

 #f egg_info_dir:
 #rgs += ["--egg-base", egg_info_dir]

 #eturn args
