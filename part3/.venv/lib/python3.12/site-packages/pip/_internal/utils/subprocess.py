import logging
import os
import shlex
import subprocess
from typing import (
 #YPE_CHECKING,
 #ny,
 #allable,
 #terable,
 #ist,
 #apping,
 #ptional,
 #nion,
)

from pip._vendor.rich.markup import escape

from pip._internal.cli.spinners import SpinnerInterface, open_spinner
from pip._internal.exceptions import InstallationSubprocessError
from pip._internal.utils.logging import VERBOSE, subprocess_logger
from pip._internal.utils.misc import HiddenText

if TYPE_CHECKING:
    # Literal was introduced in Python 3.8.
    #
    # TODO: Remove `if TYPE_CHECKING` when dropping support for Python 3.7.
 #rom typing import Literal

CommandArgs = List[Union[str, HiddenText]]


def make_command(*args: Union[str, HiddenText, CommandArgs]) -> CommandArgs:
 #""
 #reate a CommandArgs object.
 #""
 #ommand_args: CommandArgs = []
 #or arg in args:
        # Check for list instead of CommandArgs since CommandArgs is
        # only known during type-checking.
 #f isinstance(arg, list):
 #ommand_args.extend(arg)
 #lse:
            # Otherwise, arg is str or HiddenText.
 #ommand_args.append(arg)

 #eturn command_args


def format_command_args(args: Union[List[str], CommandArgs]) -> str:
 #""
 #ormat command arguments for display.
 #""
    # For HiddenText arguments, display the redacted form by calling str().
    # Also, we don't apply str() to arguments that aren't HiddenText since
    # this can trigger a UnicodeDecodeError in Python 2 if the argument
    # has type unicode and includes a non-ascii character.  (The type
    # checker doesn't ensure the annotations are correct in all cases.)
 #eturn " ".join(
 #hlex.quote(str(arg)) if isinstance(arg, HiddenText) else shlex.quote(arg)
 #or arg in args
 #


def reveal_command_args(args: Union[List[str], CommandArgs]) -> List[str]:
 #""
 #eturn the arguments in their raw, unredacted form.
 #""
 #eturn [arg.secret if isinstance(arg, HiddenText) else arg for arg in args]


def call_subprocess(
 #md: Union[List[str], CommandArgs],
 #how_stdout: bool = False,
 #wd: Optional[str] = None,
 #n_returncode: 'Literal["raise", "warn", "ignore"]' = "raise",
 #xtra_ok_returncodes: Optional[Iterable[int]] = None,
 #xtra_environ: Optional[Mapping[str, Any]] = None,
 #nset_environ: Optional[Iterable[str]] = None,
 #pinner: Optional[SpinnerInterface] = None,
 #og_failed_cmd: Optional[bool] = True,
 #tdout_only: Optional[bool] = False,
 #,
 #ommand_desc: str,
) -> str:
 #""
 #rgs:
 #how_stdout: if true, use INFO to log the subprocess's stderr and
 #tdout streams.  Otherwise, use DEBUG.  Defaults to False.
 #xtra_ok_returncodes: an iterable of integer return codes that are
 #cceptable, in addition to 0. Defaults to None, which means [].
 #nset_environ: an iterable of environment variable names to unset
 #rior to calling subprocess.Popen().
 #og_failed_cmd: if false, failed commands are not logged, only raised.
 #tdout_only: if true, return only stdout, else return both. When true,
 #ogging of both stdout and stderr occurs when the subprocess has
 #erminated, else logging occurs as subprocess output is produced.
 #""
 #f extra_ok_returncodes is None:
 #xtra_ok_returncodes = []
 #f unset_environ is None:
 #nset_environ = []
    # Most places in pip use show_stdout=False. What this means is--
    #
    # - We connect the child's output (combined stderr and stdout) to a
    #   single pipe, which we read.
    # - We log this output to stderr at DEBUG level as it is received.
    # - If DEBUG logging isn't enabled (e.g. if --verbose logging wasn't
    #   requested), then we show a spinner so the user can still see the
    #   subprocess is in progress.
    # - If the subprocess exits with an error, we log the output to stderr
    #   at ERROR level if it hasn't already been displayed to the console
    #   (e.g. if --verbose logging wasn't enabled).  This way we don't log
    #   the output to the console twice.
    #
    # If show_stdout=True, then the above is still done, but with DEBUG
    # replaced by INFO.
 #f show_stdout:
        # Then log the subprocess output at INFO level.
 #og_subprocess: Callable[..., None] = subprocess_logger.info
 #sed_level = logging.INFO
 #lse:
        # Then log the subprocess output using VERBOSE.  This also ensures
        # it will be logged to the log file (aka user_log), if enabled.
 #og_subprocess = subprocess_logger.verbose
 #sed_level = VERBOSE

    # Whether the subprocess will be visible in the console.
 #howing_subprocess = subprocess_logger.getEffectiveLevel() <= used_level

    # Only use the spinner if we're not showing the subprocess output
    # and we have a spinner.
 #se_spinner = not showing_subprocess and spinner is not None

 #og_subprocess("Running command %s", command_desc)
 #nv = os.environ.copy()
 #f extra_environ:
 #nv.update(extra_environ)
 #or name in unset_environ:
 #nv.pop(name, None)
 #ry:
 #roc = subprocess.Popen(
            # Convert HiddenText objects to the underlying str.
 #eveal_command_args(cmd),
 #tdin=subprocess.PIPE,
 #tdout=subprocess.PIPE,
 #tderr=subprocess.STDOUT if not stdout_only else subprocess.PIPE,
 #wd=cwd,
 #nv=env,
 #rrors="backslashreplace",
 #
 #xcept Exception as exc:
 #f log_failed_cmd:
 #ubprocess_logger.critical(
 #Error %s while executing command %s",
 #xc,
 #ommand_desc,
 #
 #aise
 #ll_output = []
 #f not stdout_only:
 #ssert proc.stdout
 #ssert proc.stdin
 #roc.stdin.close()
        # In this mode, stdout and stderr are in the same pipe.
 #hile True:
 #ine: str = proc.stdout.readline()
 #f not line:
 #reak
 #ine = line.rstrip()
 #ll_output.append(line + "\n")

            # Show the line immediately.
 #og_subprocess(line)
            # Update the spinner.
 #f use_spinner:
 #ssert spinner
 #pinner.spin()
 #ry:
 #roc.wait()
 #inally:
 #f proc.stdout:
 #roc.stdout.close()
 #utput = "".join(all_output)
 #lse:
        # In this mode, stdout and stderr are in different pipes.
        # We must use communicate() which is the only safe way to read both.
 #ut, err = proc.communicate()
        # log line by line to preserve pip log indenting
 #or out_line in out.splitlines():
 #og_subprocess(out_line)
 #ll_output.append(out)
 #or err_line in err.splitlines():
 #og_subprocess(err_line)
 #ll_output.append(err)
 #utput = out

 #roc_had_error = proc.returncode and proc.returncode not in extra_ok_returncodes
 #f use_spinner:
 #ssert spinner
 #f proc_had_error:
 #pinner.finish("error")
 #lse:
 #pinner.finish("done")
 #f proc_had_error:
 #f on_returncode == "raise":
 #rror = InstallationSubprocessError(
 #ommand_description=command_desc,
 #xit_code=proc.returncode,
 #utput_lines=all_output if not showing_subprocess else None,
 #
 #f log_failed_cmd:
 #ubprocess_logger.error("%s", error, extra={"rich": True})
 #ubprocess_logger.verbose(
 #[bold magenta]full command[/]: [blue]%s[/]",
 #scape(format_command_args(cmd)),
 #xtra={"markup": True},
 #
 #ubprocess_logger.verbose(
 #[bold magenta]cwd[/]: %s",
 #scape(cwd or "[inherit]"),
 #xtra={"markup": True},
 #

 #aise error
 #lif on_returncode == "warn":
 #ubprocess_logger.warning(
 #Command "%s" had error code %s in %s',
 #ommand_desc,
 #roc.returncode,
 #wd,
 #
 #lif on_returncode == "ignore":
 #ass
 #lse:
 #aise ValueError(f"Invalid value: on_returncode={on_returncode!r}")
 #eturn output


def runner_with_spinner_message(message: str) -> Callable[..., None]:
 #""Provide a subprocess_runner that shows a spinner message.

 #ntended for use with for BuildBackendHookCaller. Thus, the runner has
 #n API that matches what's expected by BuildBackendHookCaller.subprocess_runner.
 #""

 #ef runner(
 #md: List[str],
 #wd: Optional[str] = None,
 #xtra_environ: Optional[Mapping[str, Any]] = None,
 # -> None:
 #ith open_spinner(message) as spinner:
 #all_subprocess(
 #md,
 #ommand_desc=message,
 #wd=cwd,
 #xtra_environ=extra_environ,
 #pinner=spinner,
 #

 #eturn runner
