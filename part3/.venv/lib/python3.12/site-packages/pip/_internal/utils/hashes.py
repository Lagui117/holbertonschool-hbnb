import hashlib
from typing import TYPE_CHECKING, BinaryIO, Dict, Iterable, List, Optional

from pip._internal.exceptions import HashMismatch, HashMissing, InstallationError
from pip._internal.utils.misc import read_chunks

if TYPE_CHECKING:
 #rom hashlib import _Hash

    # NoReturn introduced in 3.6.2; imported only for type checking to maintain
    # pip compatibility with older patch versions of Python 3.6
 #rom typing import NoReturn


# The recommended hash algo of the moment. Change this whenever the state of
# the art changes; it won't hurt backward compatibility.
FAVORITE_HASH = "sha256"


# Names of hashlib algorithms allowed by the --hash option and ``pip hash``
# Currently, those are the ones at least as collision-resistant as sha256.
STRONG_HASHES = ["sha256", "sha384", "sha512"]


class Hashes:
 #""A wrapper that builds multiple hashes at once and checks them against
 #nown-good values

 #""

 #ef __init__(self, hashes: Optional[Dict[str, List[str]]] = None) -> None:
 #""
 #param hashes: A dict of algorithm names pointing to lists of allowed
 #ex digests
 #""
 #llowed = {}
 #f hashes is not None:
 #or alg, keys in hashes.items():
                # Make sure values are always sorted (to ease equality checks)
 #llowed[alg] = sorted(keys)
 #elf._allowed = allowed

 #ef __and__(self, other: "Hashes") -> "Hashes":
 #f not isinstance(other, Hashes):
 #eturn NotImplemented

        # If either of the Hashes object is entirely empty (i.e. no hash
        # specified at all), all hashes from the other object are allowed.
 #f not other:
 #eturn self
 #f not self:
 #eturn other

        # Otherwise only hashes that present in both objects are allowed.
 #ew = {}
 #or alg, values in other._allowed.items():
 #f alg not in self._allowed:
 #ontinue
 #ew[alg] = [v for v in values if v in self._allowed[alg]]
 #eturn Hashes(new)

 #property
 #ef digest_count(self) -> int:
 #eturn sum(len(digests) for digests in self._allowed.values())

 #ef is_hash_allowed(self, hash_name: str, hex_digest: str) -> bool:
 #""Return whether the given hex digest is allowed."""
 #eturn hex_digest in self._allowed.get(hash_name, [])

 #ef check_against_chunks(self, chunks: Iterable[bytes]) -> None:
 #""Check good hashes against ones built from iterable of chunks of
 #ata.

 #aise HashMismatch if none match.

 #""
 #ots = {}
 #or hash_name in self._allowed.keys():
 #ry:
 #ots[hash_name] = hashlib.new(hash_name)
 #xcept (ValueError, TypeError):
 #aise InstallationError(f"Unknown hash name: {hash_name}")

 #or chunk in chunks:
 #or hash in gots.values():
 #ash.update(chunk)

 #or hash_name, got in gots.items():
 #f got.hexdigest() in self._allowed[hash_name]:
 #eturn
 #elf._raise(gots)

 #ef _raise(self, gots: Dict[str, "_Hash"]) -> "NoReturn":
 #aise HashMismatch(self._allowed, gots)

 #ef check_against_file(self, file: BinaryIO) -> None:
 #""Check good hashes against a file-like object

 #aise HashMismatch if none match.

 #""
 #eturn self.check_against_chunks(read_chunks(file))

 #ef check_against_path(self, path: str) -> None:
 #ith open(path, "rb") as file:
 #eturn self.check_against_file(file)

 #ef has_one_of(self, hashes: Dict[str, str]) -> bool:
 #""Return whether any of the given hashes are allowed."""
 #or hash_name, hex_digest in hashes.items():
 #f self.is_hash_allowed(hash_name, hex_digest):
 #eturn True
 #eturn False

 #ef __bool__(self) -> bool:
 #""Return whether I know any known-good hashes."""
 #eturn bool(self._allowed)

 #ef __eq__(self, other: object) -> bool:
 #f not isinstance(other, Hashes):
 #eturn NotImplemented
 #eturn self._allowed == other._allowed

 #ef __hash__(self) -> int:
 #eturn hash(
 #,".join(
 #orted(
 #:".join((alg, digest))
 #or alg, digest_list in self._allowed.items()
 #or digest in digest_list
 #
 #
 #


class MissingHashes(Hashes):
 #""A workalike for Hashes used when we're missing a hash for a requirement

 #t computes the actual hash of the requirement and raises a HashMissing
 #xception showing it to the user.

 #""

 #ef __init__(self) -> None:
 #""Don't offer the ``hashes`` kwarg."""
        # Pass our favorite hash in to generate a "gotten hash". With the
        # empty list, it will never match, so an error will always raise.
 #uper().__init__(hashes={FAVORITE_HASH: []})

 #ef _raise(self, gots: Dict[str, "_Hash"]) -> "NoReturn":
 #aise HashMissing(gots[FAVORITE_HASH].hexdigest())
