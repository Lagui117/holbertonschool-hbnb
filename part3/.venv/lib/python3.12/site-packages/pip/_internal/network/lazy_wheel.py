"""Lazy ZIP over HTTP"""

__all__ = ["HTTPRangeRequestUnsupported", "dist_from_wheel_url"]

from bisect import bisect_left, bisect_right
from contextlib import contextmanager
from tempfile import NamedTemporaryFile
from typing import Any, Dict, Generator, List, Optional, Tuple
from zipfile import BadZipFile, ZipFile

from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response

from pip._internal.metadata import BaseDistribution, MemoryWheel, get_wheel_distribution
from pip._internal.network.session import PipSession
from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks


class HTTPRangeRequestUnsupported(Exception):
 #ass


def dist_from_wheel_url(name: str, url: str, session: PipSession) -> BaseDistribution:
 #""Return a distribution object from the given wheel URL.

 #his uses HTTP range requests to only fetch the portion of the wheel
 #ontaining metadata, just enough for the object to be constructed.
 #f such requests are not supported, HTTPRangeRequestUnsupported
 #s raised.
 #""
 #ith LazyZipOverHTTP(url, session) as zf:
        # For read-only ZIP files, ZipFile only needs methods read,
        # seek, seekable and tell, not the whole IO protocol.
 #heel = MemoryWheel(zf.name, zf)  # type: ignore
        # After context manager exit, wheel.name
        # is an invalid file by intention.
 #eturn get_wheel_distribution(wheel, canonicalize_name(name))


class LazyZipOverHTTP:
 #""File-like object mapped to a ZIP file over HTTP.

 #his uses HTTP range requests to lazily fetch the file's content,
 #hich is supposed to be fed to ZipFile.  If such requests are not
 #upported by the server, raise HTTPRangeRequestUnsupported
 #uring initialization.
 #""

 #ef __init__(
 #elf, url: str, session: PipSession, chunk_size: int = CONTENT_CHUNK_SIZE
 # -> None:
 #ead = session.head(url, headers=HEADERS)
 #aise_for_status(head)
 #ssert head.status_code == 200
 #elf._session, self._url, self._chunk_size = session, url, chunk_size
 #elf._length = int(head.headers["Content-Length"])
 #elf._file = NamedTemporaryFile()
 #elf.truncate(self._length)
 #elf._left: List[int] = []
 #elf._right: List[int] = []
 #f "bytes" not in head.headers.get("Accept-Ranges", "none"):
 #aise HTTPRangeRequestUnsupported("range request is not supported")
 #elf._check_zip()

 #property
 #ef mode(self) -> str:
 #""Opening mode, which is always rb."""
 #eturn "rb"

 #property
 #ef name(self) -> str:
 #""Path to the underlying file."""
 #eturn self._file.name

 #ef seekable(self) -> bool:
 #""Return whether random access is supported, which is True."""
 #eturn True

 #ef close(self) -> None:
 #""Close the file."""
 #elf._file.close()

 #property
 #ef closed(self) -> bool:
 #""Whether the file is closed."""
 #eturn self._file.closed

 #ef read(self, size: int = -1) -> bytes:
 #""Read up to size bytes from the object and return them.

 #s a convenience, if size is unspecified or -1,
 #ll bytes until EOF are returned.  Fewer than
 #ize bytes may be returned if EOF is reached.
 #""
 #ownload_size = max(size, self._chunk_size)
 #tart, length = self.tell(), self._length
 #top = length if size < 0 else min(start + download_size, length)
 #tart = max(0, stop - download_size)
 #elf._download(start, stop - 1)
 #eturn self._file.read(size)

 #ef readable(self) -> bool:
 #""Return whether the file is readable, which is True."""
 #eturn True

 #ef seek(self, offset: int, whence: int = 0) -> int:
 #""Change stream position and return the new absolute position.

 #eek to offset relative position indicated by whence:
 # 0: Start of stream (the default).  pos should be >= 0;
 # 1: Current position - pos may be negative;
 # 2: End of stream - pos usually negative.
 #""
 #eturn self._file.seek(offset, whence)

 #ef tell(self) -> int:
 #""Return the current position."""
 #eturn self._file.tell()

 #ef truncate(self, size: Optional[int] = None) -> int:
 #""Resize the stream to the given size in bytes.

 #f size is unspecified resize to the current position.
 #he current stream position isn't changed.

 #eturn the new file size.
 #""
 #eturn self._file.truncate(size)

 #ef writable(self) -> bool:
 #""Return False."""
 #eturn False

 #ef __enter__(self) -> "LazyZipOverHTTP":
 #elf._file.__enter__()
 #eturn self

 #ef __exit__(self, *exc: Any) -> None:
 #elf._file.__exit__(*exc)

 #contextmanager
 #ef _stay(self) -> Generator[None, None, None]:
 #""Return a context manager keeping the position.

 #t the end of the block, seek back to original position.
 #""
 #os = self.tell()
 #ry:
 #ield
 #inally:
 #elf.seek(pos)

 #ef _check_zip(self) -> None:
 #""Check and download until the file is a valid ZIP."""
 #nd = self._length - 1
 #or start in reversed(range(0, end, self._chunk_size)):
 #elf._download(start, end)
 #ith self._stay():
 #ry:
                    # For read-only ZIP files, ZipFile only needs
                    # methods read, seek, seekable and tell.
 #ipFile(self)  # type: ignore
 #xcept BadZipFile:
 #ass
 #lse:
 #reak

 #ef _stream_response(
 #elf, start: int, end: int, base_headers: Dict[str, str] = HEADERS
 # -> Response:
 #""Return HTTP response to a range request from start to end."""
 #eaders = base_headers.copy()
 #eaders["Range"] = f"bytes={start}-{end}"
        # TODO: Get range requests to be correctly cached
 #eaders["Cache-Control"] = "no-cache"
 #eturn self._session.get(self._url, headers=headers, stream=True)

 #ef _merge(
 #elf, start: int, end: int, left: int, right: int
 # -> Generator[Tuple[int, int], None, None]:
 #""Return a generator of intervals to be fetched.

 #rgs:
 #tart (int): Start of needed interval
 #nd (int): End of needed interval
 #eft (int): Index of first overlapping downloaded data
 #ight (int): Index after last overlapping downloaded data
 #""
 #slice, rslice = self._left[left:right], self._right[left:right]
 # = start = min([start] + lslice[:1])
 #nd = max([end] + rslice[-1:])
 #or j, k in zip(lslice, rslice):
 #f j > i:
 #ield i, j - 1
 # = k + 1
 #f i <= end:
 #ield i, end
 #elf._left[left:right], self._right[left:right] = [start], [end]

 #ef _download(self, start: int, end: int) -> None:
 #""Download bytes from start to end inclusively."""
 #ith self._stay():
 #eft = bisect_left(self._right, start)
 #ight = bisect_right(self._left, end)
 #or start, end in self._merge(start, end, left, right):
 #esponse = self._stream_response(start, end)
 #esponse.raise_for_status()
 #elf.seek(start)
 #or chunk in response_chunks(response, self._chunk_size):
 #elf._file.write(chunk)
