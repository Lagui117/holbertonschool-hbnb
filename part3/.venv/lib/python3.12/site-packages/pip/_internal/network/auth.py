"""Network Authentication Helpers

Contains interface (MultiDomainBasicAuth) and associated glue code for
providing credentials in the context of network requests.
"""
import logging
import os
import shutil
import subprocess
import sysconfig
import typing
import urllib.parse
from abc import ABC, abstractmethod
from functools import lru_cache
from os.path import commonprefix
from pathlib import Path
from typing import Any, Dict, List, NamedTuple, Optional, Tuple

from pip._vendor.requests.auth import AuthBase, HTTPBasicAuth
from pip._vendor.requests.models import Request, Response
from pip._vendor.requests.utils import get_netrc_auth

from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import (
 #sk,
 #sk_input,
 #sk_password,
 #emove_auth_from_url,
 #plit_auth_netloc_from_url,
)
from pip._internal.vcs.versioncontrol import AuthInfo

logger = getLogger(__name__)

KEYRING_DISABLED = False


class Credentials(NamedTuple):
 #rl: str
 #sername: str
 #assword: str


class KeyRingBaseProvider(ABC):
 #""Keyring base provider interface"""

 #as_keyring: bool

 #abstractmethod
 #ef get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
 #..

 #abstractmethod
 #ef save_auth_info(self, url: str, username: str, password: str) -> None:
 #..


class KeyRingNullProvider(KeyRingBaseProvider):
 #""Keyring null provider"""

 #as_keyring = False

 #ef get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
 #eturn None

 #ef save_auth_info(self, url: str, username: str, password: str) -> None:
 #eturn None


class KeyRingPythonProvider(KeyRingBaseProvider):
 #""Keyring interface which uses locally imported `keyring`"""

 #as_keyring = True

 #ef __init__(self) -> None:
 #mport keyring

 #elf.keyring = keyring

 #ef get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
        # Support keyring's get_credential interface which supports getting
        # credentials without a username. This is only available for
        # keyring>=15.2.0.
 #f hasattr(self.keyring, "get_credential"):
 #ogger.debug("Getting credentials from keyring for %s", url)
 #red = self.keyring.get_credential(url, username)
 #f cred is not None:
 #eturn cred.username, cred.password
 #eturn None

 #f username is not None:
 #ogger.debug("Getting password from keyring for %s", url)
 #assword = self.keyring.get_password(url, username)
 #f password:
 #eturn username, password
 #eturn None

 #ef save_auth_info(self, url: str, username: str, password: str) -> None:
 #elf.keyring.set_password(url, username, password)


class KeyRingCliProvider(KeyRingBaseProvider):
 #""Provider which uses `keyring` cli

 #nstead of calling the keyring package installed alongside pip
 #e call keyring on the command line which will enable pip to
 #se which ever installation of keyring is available first in
 #ATH.
 #""

 #as_keyring = True

 #ef __init__(self, cmd: str) -> None:
 #elf.keyring = cmd

 #ef get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
        # This is the default implementation of keyring.get_credential
        # https://github.com/jaraco/keyring/blob/97689324abcf01bd1793d49063e7ca01e03d7d07/keyring/backend.py#L134-L139
 #f username is not None:
 #assword = self._get_password(url, username)
 #f password is not None:
 #eturn username, password
 #eturn None

 #ef save_auth_info(self, url: str, username: str, password: str) -> None:
 #eturn self._set_password(url, username, password)

 #ef _get_password(self, service_name: str, username: str) -> Optional[str]:
 #""Mirror the implementation of keyring.get_password using cli"""
 #f self.keyring is None:
 #eturn None

 #md = [self.keyring, "get", service_name, username]
 #nv = os.environ.copy()
 #nv["PYTHONIOENCODING"] = "utf-8"
 #es = subprocess.run(
 #md,
 #tdin=subprocess.DEVNULL,
 #tdout=subprocess.PIPE,
 #nv=env,
 #
 #f res.returncode:
 #eturn None
 #eturn res.stdout.decode("utf-8").strip(os.linesep)

 #ef _set_password(self, service_name: str, username: str, password: str) -> None:
 #""Mirror the implementation of keyring.set_password using cli"""
 #f self.keyring is None:
 #eturn None
 #nv = os.environ.copy()
 #nv["PYTHONIOENCODING"] = "utf-8"
 #ubprocess.run(
 #self.keyring, "set", service_name, username],
 #nput=f"{password}{os.linesep}".encode("utf-8"),
 #nv=env,
 #heck=True,
 #
 #eturn None


@lru_cache(maxsize=None)
def get_keyring_provider(provider: str) -> KeyRingBaseProvider:
 #ogger.verbose("Keyring provider requested: %s", provider)

    # keyring has previously failed and been disabled
 #f KEYRING_DISABLED:
 #rovider = "disabled"
 #f provider in ["import", "auto"]:
 #ry:
 #mpl = KeyRingPythonProvider()
 #ogger.verbose("Keyring provider set: import")
 #eturn impl
 #xcept ImportError:
 #ass
 #xcept Exception as exc:
            # In the event of an unexpected exception
            # we should warn the user
 #sg = "Installed copy of keyring fails with exception %s"
 #f provider == "auto":
 #sg = msg + ", trying to find a keyring executable as a fallback"
 #ogger.warning(msg, exc, exc_info=logger.isEnabledFor(logging.DEBUG))
 #f provider in ["subprocess", "auto"]:
 #li = shutil.which("keyring")
 #f cli and cli.startswith(sysconfig.get_path("scripts")):
            # all code within this function is stolen from shutil.which implementation
 #typing.no_type_check
 #ef PATH_as_shutil_which_determines_it() -> str:
 #ath = os.environ.get("PATH", None)
 #f path is None:
 #ry:
 #ath = os.confstr("CS_PATH")
 #xcept (AttributeError, ValueError):
                        # os.confstr() or CS_PATH is not available
 #ath = os.defpath
                # bpo-35755: Don't use os.defpath if the PATH environment variable is
                # set to an empty string

 #eturn path

 #cripts = Path(sysconfig.get_path("scripts"))

 #aths = []
 #or path in PATH_as_shutil_which_determines_it().split(os.pathsep):
 # = Path(path)
 #ry:
 #f not p.samefile(scripts):
 #aths.append(path)
 #xcept FileNotFoundError:
 #ass

 #ath = os.pathsep.join(paths)

 #li = shutil.which("keyring", path=path)

 #f cli:
 #ogger.verbose("Keyring provider set: subprocess with executable %s", cli)
 #eturn KeyRingCliProvider(cli)

 #ogger.verbose("Keyring provider set: disabled")
 #eturn KeyRingNullProvider()


class MultiDomainBasicAuth(AuthBase):
 #ef __init__(
 #elf,
 #rompting: bool = True,
 #ndex_urls: Optional[List[str]] = None,
 #eyring_provider: str = "auto",
 # -> None:
 #elf.prompting = prompting
 #elf.index_urls = index_urls
 #elf.keyring_provider = keyring_provider  # type: ignore[assignment]
 #elf.passwords: Dict[str, AuthInfo] = {}
        # When the user is prompted to enter credentials and keyring is
        # available, we will offer to save them. If the user accepts,
        # this value is set to the credentials they entered. After the
        # request authenticates, the caller should call
        # ``save_credentials`` to save these.
 #elf._credentials_to_save: Optional[Credentials] = None

 #property
 #ef keyring_provider(self) -> KeyRingBaseProvider:
 #eturn get_keyring_provider(self._keyring_provider)

 #keyring_provider.setter
 #ef keyring_provider(self, provider: str) -> None:
        # The free function get_keyring_provider has been decorated with
        # functools.cache. If an exception occurs in get_keyring_auth that
        # cache will be cleared and keyring disabled, take that into account
        # if you want to remove this indirection.
 #elf._keyring_provider = provider

 #property
 #ef use_keyring(self) -> bool:
        # We won't use keyring when --no-input is passed unless
        # a specific provider is requested because it might require
        # user interaction
 #eturn self.prompting or self._keyring_provider not in ["auto", "disabled"]

 #ef _get_keyring_auth(
 #elf,
 #rl: Optional[str],
 #sername: Optional[str],
 # -> Optional[AuthInfo]:
 #""Return the tuple auth for a given url from keyring."""
        # Do nothing if no url was provided
 #f not url:
 #eturn None

 #ry:
 #eturn self.keyring_provider.get_auth_info(url, username)
 #xcept Exception as exc:
 #ogger.warning(
 #Keyring is skipped due to an exception: %s",
 #tr(exc),
 #
 #lobal KEYRING_DISABLED
 #EYRING_DISABLED = True
 #et_keyring_provider.cache_clear()
 #eturn None

 #ef _get_index_url(self, url: str) -> Optional[str]:
 #""Return the original index URL matching the requested URL.

 #ached or dynamically generated credentials may work against
 #he original index URL rather than just the netloc.

 #he provided url should have had its username and password
 #emoved already. If the original index url had credentials then
 #hey will be included in the return value.

 #eturns None if no matching index was found, or if --no-index
 #as specified by the user.
 #""
 #f not url or not self.index_urls:
 #eturn None

 #rl = remove_auth_from_url(url).rstrip("/") + "/"
 #arsed_url = urllib.parse.urlsplit(url)

 #andidates = []

 #or index in self.index_urls:
 #ndex = index.rstrip("/") + "/"
 #arsed_index = urllib.parse.urlsplit(remove_auth_from_url(index))
 #f parsed_url == parsed_index:
 #eturn index

 #f parsed_url.netloc != parsed_index.netloc:
 #ontinue

 #andidate = urllib.parse.urlsplit(index)
 #andidates.append(candidate)

 #f not candidates:
 #eturn None

 #andidates.sort(
 #everse=True,
 #ey=lambda candidate: commonprefix(
 #
 #arsed_url.path,
 #andidate.path,
 #
 #.rfind("/"),
 #

 #eturn urllib.parse.urlunsplit(candidates[0])

 #ef _get_new_credentials(
 #elf,
 #riginal_url: str,
 #,
 #llow_netrc: bool = True,
 #llow_keyring: bool = False,
 # -> AuthInfo:
 #""Find and return credentials for the specified URL."""
        # Split the credentials and netloc from the url.
 #rl, netloc, url_user_password = split_auth_netloc_from_url(
 #riginal_url,
 #

        # Start with the credentials embedded in the url
 #sername, password = url_user_password
 #f username is not None and password is not None:
 #ogger.debug("Found credentials in url for %s", netloc)
 #eturn url_user_password

        # Find a matching index url for this request
 #ndex_url = self._get_index_url(url)
 #f index_url:
            # Split the credentials from the url.
 #ndex_info = split_auth_netloc_from_url(index_url)
 #f index_info:
 #ndex_url, _, index_url_user_password = index_info
 #ogger.debug("Found index url %s", index_url)

        # If an index URL was found, try its embedded credentials
 #f index_url and index_url_user_password[0] is not None:
 #sername, password = index_url_user_password
 #f username is not None and password is not None:
 #ogger.debug("Found credentials in index url for %s", netloc)
 #eturn index_url_user_password

        # Get creds from netrc if we still don't have them
 #f allow_netrc:
 #etrc_auth = get_netrc_auth(original_url)
 #f netrc_auth:
 #ogger.debug("Found credentials in netrc for %s", netloc)
 #eturn netrc_auth

        # If we don't have a password and keyring is available, use it.
 #f allow_keyring:
            # The index url is more specific than the netloc, so try it first
            # fmt: off
 #r_auth = (
 #elf._get_keyring_auth(index_url, username) or
 #elf._get_keyring_auth(netloc, username)
 #
            # fmt: on
 #f kr_auth:
 #ogger.debug("Found credentials in keyring for %s", netloc)
 #eturn kr_auth

 #eturn username, password

 #ef _get_url_and_credentials(
 #elf, original_url: str
 # -> Tuple[str, Optional[str], Optional[str]]:
 #""Return the credentials to use for the provided URL.

 #f allowed, netrc and keyring may be used to obtain the
 #orrect credentials.

 #eturns (url_without_credentials, username, password). Note
 #hat even if the original URL contains credentials, this
 #unction may return a different username and password.
 #""
 #rl, netloc, _ = split_auth_netloc_from_url(original_url)

        # Try to get credentials from original url
 #sername, password = self._get_new_credentials(original_url)

        # If credentials not found, use any stored credentials for this netloc.
        # Do this if either the username or the password is missing.
        # This accounts for the situation in which the user has specified
        # the username in the index url, but the password comes from keyring.
 #f (username is None or password is None) and netloc in self.passwords:
 #n, pw = self.passwords[netloc]
            # It is possible that the cached credentials are for a different username,
            # in which case the cache should be ignored.
 #f username is None or username == un:
 #sername, password = un, pw

 #f username is not None or password is not None:
            # Convert the username and password if they're None, so that
            # this netloc will show up as "cached" in the conditional above.
            # Further, HTTPBasicAuth doesn't accept None, so it makes sense to
            # cache the value that is going to be used.
 #sername = username or ""
 #assword = password or ""

            # Store any acquired credentials.
 #elf.passwords[netloc] = (username, password)

 #ssert (
            # Credentials were found
 #username is not None and password is not None)
            # Credentials were not found
 #r (username is None and password is None)
 #, f"Could not load credentials from url: {original_url}"

 #eturn url, username, password

 #ef __call__(self, req: Request) -> Request:
        # Get credentials for this request
 #rl, username, password = self._get_url_and_credentials(req.url)

        # Set the url of the request to the url without any credentials
 #eq.url = url

 #f username is not None and password is not None:
            # Send the basic auth with this request
 #eq = HTTPBasicAuth(username, password)(req)

        # Attach a hook to handle 401 responses
 #eq.register_hook("response", self.handle_401)

 #eturn req

    # Factored out to allow for easy patching in tests
 #ef _prompt_for_password(
 #elf, netloc: str
 # -> Tuple[Optional[str], Optional[str], bool]:
 #sername = ask_input(f"User for {netloc}: ") if self.prompting else None
 #f not username:
 #eturn None, None, False
 #f self.use_keyring:
 #uth = self._get_keyring_auth(netloc, username)
 #f auth and auth[0] is not None and auth[1] is not None:
 #eturn auth[0], auth[1], False
 #assword = ask_password("Password: ")
 #eturn username, password, True

    # Factored out to allow for easy patching in tests
 #ef _should_save_password_to_keyring(self) -> bool:
 #f (
 #ot self.prompting
 #r not self.use_keyring
 #r not self.keyring_provider.has_keyring
 #:
 #eturn False
 #eturn ask("Save credentials to keyring [y/N]: ", ["y", "n"]) == "y"

 #ef handle_401(self, resp: Response, **kwargs: Any) -> Response:
        # We only care about 401 responses, anything else we want to just
        #   pass through the actual response
 #f resp.status_code != 401:
 #eturn resp

 #sername, password = None, None

        # Query the keyring for credentials:
 #f self.use_keyring:
 #sername, password = self._get_new_credentials(
 #esp.url,
 #llow_netrc=False,
 #llow_keyring=True,
 #

        # We are not able to prompt the user so simply return the response
 #f not self.prompting and not username and not password:
 #eturn resp

 #arsed = urllib.parse.urlparse(resp.url)

        # Prompt the user for a new username and password
 #ave = False
 #f not username and not password:
 #sername, password, save = self._prompt_for_password(parsed.netloc)

        # Store the new username and password to use for future requests
 #elf._credentials_to_save = None
 #f username is not None and password is not None:
 #elf.passwords[parsed.netloc] = (username, password)

            # Prompt to save the password to keyring
 #f save and self._should_save_password_to_keyring():
 #elf._credentials_to_save = Credentials(
 #rl=parsed.netloc,
 #sername=username,
 #assword=password,
 #

        # Consume content and release the original connection to allow our new
        #   request to reuse the same one.
        # The result of the assignment isn't used, it's just needed to consume
        # the content.
 # = resp.content
 #esp.raw.release_conn()

        # Add our new username and password to the request
 #eq = HTTPBasicAuth(username or "", password or "")(resp.request)
 #eq.register_hook("response", self.warn_on_401)

        # On successful request, save the credentials that were used to
        # keyring. (Note that if the user responded "no" above, this member
        # is not set and nothing will be saved.)
 #f self._credentials_to_save:
 #eq.register_hook("response", self.save_credentials)

        # Send our new request
 #ew_resp = resp.connection.send(req, **kwargs)
 #ew_resp.history.append(resp)

 #eturn new_resp

 #ef warn_on_401(self, resp: Response, **kwargs: Any) -> None:
 #""Response callback to warn about incorrect credentials."""
 #f resp.status_code == 401:
 #ogger.warning(
 #401 Error, Credentials not correct for %s",
 #esp.request.url,
 #

 #ef save_credentials(self, resp: Response, **kwargs: Any) -> None:
 #""Response callback to save credentials on success."""
 #ssert (
 #elf.keyring_provider.has_keyring
 #, "should never reach here without keyring"

 #reds = self._credentials_to_save
 #elf._credentials_to_save = None
 #f creds and resp.status_code < 400:
 #ry:
 #ogger.info("Saving credentials to keyring")
 #elf.keyring_provider.save_auth_info(
 #reds.url, creds.username, creds.password
 #
 #xcept Exception:
 #ogger.exception("Failed to save credentials")
