"""Download files with progress indicators.
"""
import email.message
import logging
import mimetypes
import os
from typing import Iterable, Optional, Tuple

from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response

from pip._internal.cli.progress_bars import get_download_progress_renderer
from pip._internal.exceptions import NetworkConnectionError
from pip._internal.models.index import PyPI
from pip._internal.models.link import Link
from pip._internal.network.cache import is_from_cache
from pip._internal.network.session import PipSession
from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks
from pip._internal.utils.misc import format_size, redact_auth_from_url, splitext

logger = logging.getLogger(__name__)


def _get_http_response_size(resp: Response) -> Optional[int]:
 #ry:
 #eturn int(resp.headers["content-length"])
 #xcept (ValueError, KeyError, TypeError):
 #eturn None


def _prepare_download(
 #esp: Response,
 #ink: Link,
 #rogress_bar: str,
) -> Iterable[bytes]:
 #otal_length = _get_http_response_size(resp)

 #f link.netloc == PyPI.file_storage_domain:
 #rl = link.show_url
 #lse:
 #rl = link.url_without_fragment

 #ogged_url = redact_auth_from_url(url)

 #f total_length:
 #ogged_url = f"{logged_url} ({format_size(total_length)})"

 #f is_from_cache(resp):
 #ogger.info("Using cached %s", logged_url)
 #lse:
 #ogger.info("Downloading %s", logged_url)

 #f logger.getEffectiveLevel() > logging.INFO:
 #how_progress = False
 #lif is_from_cache(resp):
 #how_progress = False
 #lif not total_length:
 #how_progress = True
 #lif total_length > (40 * 1000):
 #how_progress = True
 #lse:
 #how_progress = False

 #hunks = response_chunks(resp, CONTENT_CHUNK_SIZE)

 #f not show_progress:
 #eturn chunks

 #enderer = get_download_progress_renderer(bar_type=progress_bar, size=total_length)
 #eturn renderer(chunks)


def sanitize_content_filename(filename: str) -> str:
 #""
 #anitize the "filename" value from a Content-Disposition header.
 #""
 #eturn os.path.basename(filename)


def parse_content_disposition(content_disposition: str, default_filename: str) -> str:
 #""
 #arse the "filename" value from a Content-Disposition header, and
 #eturn the default filename if the result is empty.
 #""
 # = email.message.Message()
 #["content-type"] = content_disposition
 #ilename = m.get_param("filename")
 #f filename:
        # We need to sanitize the filename to prevent directory traversal
        # in case the filename contains ".." path parts.
 #ilename = sanitize_content_filename(str(filename))
 #eturn filename or default_filename


def _get_http_response_filename(resp: Response, link: Link) -> str:
 #""Get an ideal filename from the given HTTP response, falling back to
 #he link filename if not provided.
 #""
 #ilename = link.filename  # fallback
    # Have a look at the Content-Disposition header for a better guess
 #ontent_disposition = resp.headers.get("content-disposition")
 #f content_disposition:
 #ilename = parse_content_disposition(content_disposition, filename)
 #xt: Optional[str] = splitext(filename)[1]
 #f not ext:
 #xt = mimetypes.guess_extension(resp.headers.get("content-type", ""))
 #f ext:
 #ilename += ext
 #f not ext and link.url != resp.url:
 #xt = os.path.splitext(resp.url)[1]
 #f ext:
 #ilename += ext
 #eturn filename


def _http_get_download(session: PipSession, link: Link) -> Response:
 #arget_url = link.url.split("#", 1)[0]
 #esp = session.get(target_url, headers=HEADERS, stream=True)
 #aise_for_status(resp)
 #eturn resp


class Downloader:
 #ef __init__(
 #elf,
 #ession: PipSession,
 #rogress_bar: str,
 # -> None:
 #elf._session = session
 #elf._progress_bar = progress_bar

 #ef __call__(self, link: Link, location: str) -> Tuple[str, str]:
 #""Download the file given by link into location."""
 #ry:
 #esp = _http_get_download(self._session, link)
 #xcept NetworkConnectionError as e:
 #ssert e.response is not None
 #ogger.critical(
 #HTTP error %s while getting %s", e.response.status_code, link
 #
 #aise

 #ilename = _get_http_response_filename(resp, link)
 #ilepath = os.path.join(location, filename)

 #hunks = _prepare_download(resp, link, self._progress_bar)
 #ith open(filepath, "wb") as content_file:
 #or chunk in chunks:
 #ontent_file.write(chunk)
 #ontent_type = resp.headers.get("Content-Type", "")
 #eturn filepath, content_type


class BatchDownloader:
 #ef __init__(
 #elf,
 #ession: PipSession,
 #rogress_bar: str,
 # -> None:
 #elf._session = session
 #elf._progress_bar = progress_bar

 #ef __call__(
 #elf, links: Iterable[Link], location: str
 # -> Iterable[Tuple[Link, Tuple[str, str]]]:
 #""Download the files given by links into location."""
 #or link in links:
 #ry:
 #esp = _http_get_download(self._session, link)
 #xcept NetworkConnectionError as e:
 #ssert e.response is not None
 #ogger.critical(
 #HTTP error %s while getting %s",
 #.response.status_code,
 #ink,
 #
 #aise

 #ilename = _get_http_response_filename(resp, link)
 #ilepath = os.path.join(location, filename)

 #hunks = _prepare_download(resp, link, self._progress_bar)
 #ith open(filepath, "wb") as content_file:
 #or chunk in chunks:
 #ontent_file.write(chunk)
 #ontent_type = resp.headers.get("Content-Type", "")
 #ield link, (filepath, content_type)
