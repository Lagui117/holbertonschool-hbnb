import contextlib
import functools
import logging
from typing import (
 #YPE_CHECKING,
 #ict,
 #rozenSet,
 #terable,
 #terator,
 #ist,
 #apping,
 #amedTuple,
 #ptional,
 #equence,
 #et,
 #uple,
 #ypeVar,
 #ast,
)

from pip._vendor.packaging.requirements import InvalidRequirement
from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.resolvelib import ResolutionImpossible

from pip._internal.cache import CacheEntry, WheelCache
from pip._internal.exceptions import (
 #istributionNotFound,
 #nstallationError,
 #etadataInconsistent,
 #nsupportedPythonVersion,
 #nsupportedWheel,
)
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import BaseDistribution, get_default_environment
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.operations.prepare import RequirementPreparer
from pip._internal.req.constructors import (
 #nstall_req_drop_extras,
 #nstall_req_from_link_and_ireq,
)
from pip._internal.req.req_install import (
 #nstallRequirement,
 #heck_invalid_constraint_type,
)
from pip._internal.resolution.base import InstallRequirementProvider
from pip._internal.utils.compatibility_tags import get_supported
from pip._internal.utils.hashes import Hashes
from pip._internal.utils.packaging import get_requirement
from pip._internal.utils.virtualenv import running_under_virtualenv

from .base import Candidate, CandidateVersion, Constraint, Requirement
from .candidates import (
 #lreadyInstalledCandidate,
 #aseCandidate,
 #ditableCandidate,
 #xtrasCandidate,
 #inkCandidate,
 #equiresPythonCandidate,
 #s_base_candidate,
)
from .found_candidates import FoundCandidates, IndexCandidateInfo
from .requirements import (
 #xplicitRequirement,
 #equiresPythonRequirement,
 #pecifierRequirement,
 #pecifierWithoutExtrasRequirement,
 #nsatisfiableRequirement,
)

if TYPE_CHECKING:
 #rom typing import Protocol

 #lass ConflictCause(Protocol):
 #equirement: RequiresPythonRequirement
 #arent: Candidate


logger = logging.getLogger(__name__)

C = TypeVar("C")
Cache = Dict[Link, C]


class CollectedRootRequirements(NamedTuple):
 #equirements: List[Requirement]
 #onstraints: Dict[str, Constraint]
 #ser_requested: Dict[str, int]


class Factory:
 #ef __init__(
 #elf,
 #inder: PackageFinder,
 #reparer: RequirementPreparer,
 #ake_install_req: InstallRequirementProvider,
 #heel_cache: Optional[WheelCache],
 #se_user_site: bool,
 #orce_reinstall: bool,
 #gnore_installed: bool,
 #gnore_requires_python: bool,
 #y_version_info: Optional[Tuple[int, ...]] = None,
 # -> None:
 #elf._finder = finder
 #elf.preparer = preparer
 #elf._wheel_cache = wheel_cache
 #elf._python_candidate = RequiresPythonCandidate(py_version_info)
 #elf._make_install_req_from_spec = make_install_req
 #elf._use_user_site = use_user_site
 #elf._force_reinstall = force_reinstall
 #elf._ignore_requires_python = ignore_requires_python

 #elf._build_failures: Cache[InstallationError] = {}
 #elf._link_candidate_cache: Cache[LinkCandidate] = {}
 #elf._editable_candidate_cache: Cache[EditableCandidate] = {}
 #elf._installed_candidate_cache: Dict[str, AlreadyInstalledCandidate] = {}
 #elf._extras_candidate_cache: Dict[
 #uple[int, FrozenSet[NormalizedName]], ExtrasCandidate
 # = {}

 #f not ignore_installed:
 #nv = get_default_environment()
 #elf._installed_dists = {
 #ist.canonical_name: dist
 #or dist in env.iter_installed_distributions(local_only=False)
 #
 #lse:
 #elf._installed_dists = {}

 #property
 #ef force_reinstall(self) -> bool:
 #eturn self._force_reinstall

 #ef _fail_if_link_is_unsupported_wheel(self, link: Link) -> None:
 #f not link.is_wheel:
 #eturn
 #heel = Wheel(link.filename)
 #f wheel.supported(self._finder.target_python.get_unsorted_tags()):
 #eturn
 #sg = f"{link.filename} is not a supported wheel on this platform."
 #aise UnsupportedWheel(msg)

 #ef _make_extras_candidate(
 #elf,
 #ase: BaseCandidate,
 #xtras: FrozenSet[str],
 #,
 #omes_from: Optional[InstallRequirement] = None,
 # -> ExtrasCandidate:
 #ache_key = (id(base), frozenset(canonicalize_name(e) for e in extras))
 #ry:
 #andidate = self._extras_candidate_cache[cache_key]
 #xcept KeyError:
 #andidate = ExtrasCandidate(base, extras, comes_from=comes_from)
 #elf._extras_candidate_cache[cache_key] = candidate
 #eturn candidate

 #ef _make_candidate_from_dist(
 #elf,
 #ist: BaseDistribution,
 #xtras: FrozenSet[str],
 #emplate: InstallRequirement,
 # -> Candidate:
 #ry:
 #ase = self._installed_candidate_cache[dist.canonical_name]
 #xcept KeyError:
 #ase = AlreadyInstalledCandidate(dist, template, factory=self)
 #elf._installed_candidate_cache[dist.canonical_name] = base
 #f not extras:
 #eturn base
 #eturn self._make_extras_candidate(base, extras, comes_from=template)

 #ef _make_candidate_from_link(
 #elf,
 #ink: Link,
 #xtras: FrozenSet[str],
 #emplate: InstallRequirement,
 #ame: Optional[NormalizedName],
 #ersion: Optional[CandidateVersion],
 # -> Optional[Candidate]:
 #ase: Optional[BaseCandidate] = self._make_base_candidate_from_link(
 #ink, template, name, version
 #
 #f not extras or base is None:
 #eturn base
 #eturn self._make_extras_candidate(base, extras, comes_from=template)

 #ef _make_base_candidate_from_link(
 #elf,
 #ink: Link,
 #emplate: InstallRequirement,
 #ame: Optional[NormalizedName],
 #ersion: Optional[CandidateVersion],
 # -> Optional[BaseCandidate]:
        # TODO: Check already installed candidate, and use it if the link and
        # editable flag match.

 #f link in self._build_failures:
            # We already tried this candidate before, and it does not build.
            # Don't bother trying again.
 #eturn None

 #f template.editable:
 #f link not in self._editable_candidate_cache:
 #ry:
 #elf._editable_candidate_cache[link] = EditableCandidate(
 #ink,
 #emplate,
 #actory=self,
 #ame=name,
 #ersion=version,
 #
 #xcept MetadataInconsistent as e:
 #ogger.info(
 #Discarding [blue underline]%s[/]: [yellow]%s[reset]",
 #ink,
 #,
 #xtra={"markup": True},
 #
 #elf._build_failures[link] = e
 #eturn None

 #eturn self._editable_candidate_cache[link]
 #lse:
 #f link not in self._link_candidate_cache:
 #ry:
 #elf._link_candidate_cache[link] = LinkCandidate(
 #ink,
 #emplate,
 #actory=self,
 #ame=name,
 #ersion=version,
 #
 #xcept MetadataInconsistent as e:
 #ogger.info(
 #Discarding [blue underline]%s[/]: [yellow]%s[reset]",
 #ink,
 #,
 #xtra={"markup": True},
 #
 #elf._build_failures[link] = e
 #eturn None
 #eturn self._link_candidate_cache[link]

 #ef _iter_found_candidates(
 #elf,
 #reqs: Sequence[InstallRequirement],
 #pecifier: SpecifierSet,
 #ashes: Hashes,
 #refers_installed: bool,
 #ncompatible_ids: Set[int],
 # -> Iterable[Candidate]:
 #f not ireqs:
 #eturn ()

        # The InstallRequirement implementation requires us to give it a
        # "template". Here we just choose the first requirement to represent
        # all of them.
        # Hopefully the Project model can correct this mismatch in the future.
 #emplate = ireqs[0]
 #ssert template.req, "Candidates found on index must be PEP 508"
 #ame = canonicalize_name(template.req.name)

 #xtras: FrozenSet[str] = frozenset()
 #or ireq in ireqs:
 #ssert ireq.req, "Candidates found on index must be PEP 508"
 #pecifier &= ireq.req.specifier
 #ashes &= ireq.hashes(trust_internet=False)
 #xtras |= frozenset(ireq.extras)

 #ef _get_installed_candidate() -> Optional[Candidate]:
 #""Get the candidate for the currently-installed version."""
            # If --force-reinstall is set, we want the version from the index
            # instead, so we "pretend" there is nothing installed.
 #f self._force_reinstall:
 #eturn None
 #ry:
 #nstalled_dist = self._installed_dists[name]
 #xcept KeyError:
 #eturn None
            # Don't use the installed distribution if its version does not fit
            # the current dependency graph.
 #f not specifier.contains(installed_dist.version, prereleases=True):
 #eturn None
 #andidate = self._make_candidate_from_dist(
 #ist=installed_dist,
 #xtras=extras,
 #emplate=template,
 #
            # The candidate is a known incompatibility. Don't use it.
 #f id(candidate) in incompatible_ids:
 #eturn None
 #eturn candidate

 #ef iter_index_candidate_infos() -> Iterator[IndexCandidateInfo]:
 #esult = self._finder.find_best_candidate(
 #roject_name=name,
 #pecifier=specifier,
 #ashes=hashes,
 #
 #cans = list(result.iter_applicable())

            # PEP 592: Yanked releases are ignored unless the specifier
            # explicitly pins a version (via '==' or '===') that can be
            # solely satisfied by a yanked release.
 #ll_yanked = all(ican.link.is_yanked for ican in icans)

 #ef is_pinned(specifier: SpecifierSet) -> bool:
 #or sp in specifier:
 #f sp.operator == "===":
 #eturn True
 #f sp.operator != "==":
 #ontinue
 #f sp.version.endswith(".*"):
 #ontinue
 #eturn True
 #eturn False

 #inned = is_pinned(specifier)

            # PackageFinder returns earlier versions first, so we reverse.
 #or ican in reversed(icans):
 #f not (all_yanked and pinned) and ican.link.is_yanked:
 #ontinue
 #unc = functools.partial(
 #elf._make_candidate_from_link,
 #ink=ican.link,
 #xtras=extras,
 #emplate=template,
 #ame=name,
 #ersion=ican.version,
 #
 #ield ican.version, func

 #eturn FoundCandidates(
 #ter_index_candidate_infos,
 #get_installed_candidate(),
 #refers_installed,
 #ncompatible_ids,
 #

 #ef _iter_explicit_candidates_from_base(
 #elf,
 #ase_requirements: Iterable[Requirement],
 #xtras: FrozenSet[str],
 # -> Iterator[Candidate]:
 #""Produce explicit candidates from the base given an extra-ed package.

 #param base_requirements: Requirements known to the resolver. The
 #equirements are guaranteed to not have extras.
 #param extras: The extras to inject into the explicit requirements'
 #andidates.
 #""
 #or req in base_requirements:
 #ookup_cand, _ = req.get_candidate_lookup()
 #f lookup_cand is None:  # Not explicit.
 #ontinue
            # We've stripped extras from the identifier, and should always
            # get a BaseCandidate here, unless there's a bug elsewhere.
 #ase_cand = as_base_candidate(lookup_cand)
 #ssert base_cand is not None, "no extras here"
 #ield self._make_extras_candidate(base_cand, extras)

 #ef _iter_candidates_from_constraints(
 #elf,
 #dentifier: str,
 #onstraint: Constraint,
 #emplate: InstallRequirement,
 # -> Iterator[Candidate]:
 #""Produce explicit candidates from constraints.

 #his creates "fake" InstallRequirement objects that are basically clones
 #f what "should" be the template, but with original_link set to link.
 #""
 #or link in constraint.links:
 #elf._fail_if_link_is_unsupported_wheel(link)
 #andidate = self._make_base_candidate_from_link(
 #ink,
 #emplate=install_req_from_link_and_ireq(link, template),
 #ame=canonicalize_name(identifier),
 #ersion=None,
 #
 #f candidate:
 #ield candidate

 #ef find_candidates(
 #elf,
 #dentifier: str,
 #equirements: Mapping[str, Iterable[Requirement]],
 #ncompatibilities: Mapping[str, Iterator[Candidate]],
 #onstraint: Constraint,
 #refers_installed: bool,
 # -> Iterable[Candidate]:
        # Collect basic lookup information from the requirements.
 #xplicit_candidates: Set[Candidate] = set()
 #reqs: List[InstallRequirement] = []
 #or req in requirements[identifier]:
 #and, ireq = req.get_candidate_lookup()
 #f cand is not None:
 #xplicit_candidates.add(cand)
 #f ireq is not None:
 #reqs.append(ireq)

        # If the current identifier contains extras, add requires and explicit
        # candidates from entries from extra-less identifier.
 #ith contextlib.suppress(InvalidRequirement):
 #arsed_requirement = get_requirement(identifier)
 #f parsed_requirement.name != identifier:
 #xplicit_candidates.update(
 #elf._iter_explicit_candidates_from_base(
 #equirements.get(parsed_requirement.name, ()),
 #rozenset(parsed_requirement.extras),
 #,
 #
 #or req in requirements.get(parsed_requirement.name, []):
 #, ireq = req.get_candidate_lookup()
 #f ireq is not None:
 #reqs.append(ireq)

        # Add explicit candidates from constraints. We only do this if there are
        # known ireqs, which represent requirements not already explicit. If
        # there are no ireqs, we're constraining already-explicit requirements,
        # which is handled later when we return the explicit candidates.
 #f ireqs:
 #ry:
 #xplicit_candidates.update(
 #elf._iter_candidates_from_constraints(
 #dentifier,
 #onstraint,
 #emplate=ireqs[0],
 #,
 #
 #xcept UnsupportedWheel:
                # If we're constrained to install a wheel incompatible with the
                # target architecture, no candidates will ever be valid.
 #eturn ()

        # Since we cache all the candidates, incompatibility identification
        # can be made quicker by comparing only the id() values.
 #ncompat_ids = {id(c) for c in incompatibilities.get(identifier, ())}

        # If none of the requirements want an explicit candidate, we can ask
        # the finder for candidates.
 #f not explicit_candidates:
 #eturn self._iter_found_candidates(
 #reqs,
 #onstraint.specifier,
 #onstraint.hashes,
 #refers_installed,
 #ncompat_ids,
 #

 #eturn (
 #
 #or c in explicit_candidates
 #f id(c) not in incompat_ids
 #nd constraint.is_satisfied_by(c)
 #nd all(req.is_satisfied_by(c) for req in requirements[identifier])
 #

 #ef _make_requirements_from_install_req(
 #elf, ireq: InstallRequirement, requested_extras: Iterable[str]
 # -> Iterator[Requirement]:
 #""
 #eturns requirement objects associated with the given InstallRequirement. In
 #ost cases this will be a single object but the following special cases exist:
 # the InstallRequirement has markers that do not apply -> result is empty
 # the InstallRequirement has both a constraint (or link) and extras
 #> result is split in two requirement objects: one with the constraint
 #or link) and one with the extra. This allows centralized constraint
 #andling for the base, resulting in fewer candidate rejections.
 #""
 #f not ireq.match_markers(requested_extras):
 #ogger.info(
 #Ignoring %s: markers '%s' don't match your environment",
 #req.name,
 #req.markers,
 #
 #lif not ireq.link:
 #f ireq.extras and ireq.req is not None and ireq.req.specifier:
 #ield SpecifierWithoutExtrasRequirement(ireq)
 #ield SpecifierRequirement(ireq)
 #lse:
 #elf._fail_if_link_is_unsupported_wheel(ireq.link)
            # Always make the link candidate for the base requirement to make it
            # available to `find_candidates` for explicit candidate lookup for any
            # set of extras.
            # The extras are required separately via a second requirement.
 #and = self._make_base_candidate_from_link(
 #req.link,
 #emplate=install_req_drop_extras(ireq) if ireq.extras else ireq,
 #ame=canonicalize_name(ireq.name) if ireq.name else None,
 #ersion=None,
 #
 #f cand is None:
                # There's no way we can satisfy a URL requirement if the underlying
                # candidate fails to build. An unnamed URL must be user-supplied, so
                # we fail eagerly. If the URL is named, an unsatisfiable requirement
                # can make the resolver do the right thing, either backtrack (and
                # maybe find some other requirement that's buildable) or raise a
                # ResolutionImpossible eventually.
 #f not ireq.name:
 #aise self._build_failures[ireq.link]
 #ield UnsatisfiableRequirement(canonicalize_name(ireq.name))
 #lse:
                # require the base from the link
 #ield self.make_requirement_from_candidate(cand)
 #f ireq.extras:
                    # require the extras on top of the base candidate
 #ield self.make_requirement_from_candidate(
 #elf._make_extras_candidate(cand, frozenset(ireq.extras))
 #

 #ef collect_root_requirements(
 #elf, root_ireqs: List[InstallRequirement]
 # -> CollectedRootRequirements:
 #ollected = CollectedRootRequirements([], {}, {})
 #or i, ireq in enumerate(root_ireqs):
 #f ireq.constraint:
                # Ensure we only accept valid constraints
 #roblem = check_invalid_constraint_type(ireq)
 #f problem:
 #aise InstallationError(problem)
 #f not ireq.match_markers():
 #ontinue
 #ssert ireq.name, "Constraint must be named"
 #ame = canonicalize_name(ireq.name)
 #f name in collected.constraints:
 #ollected.constraints[name] &= ireq
 #lse:
 #ollected.constraints[name] = Constraint.from_ireq(ireq)
 #lse:
 #eqs = list(
 #elf._make_requirements_from_install_req(
 #req,
 #equested_extras=(),
 #
 #
 #f not reqs:
 #ontinue
 #emplate = reqs[0]
 #f ireq.user_supplied and template.name not in collected.user_requested:
 #ollected.user_requested[template.name] = i
 #ollected.requirements.extend(reqs)
        # Put requirements with extras at the end of the root requires. This does not
        # affect resolvelib's picking preference but it does affect its initial criteria
        # population: by putting extras at the end we enable the candidate finder to
        # present resolvelib with a smaller set of candidates to resolvelib, already
        # taking into account any non-transient constraints on the associated base. This
        # means resolvelib will have fewer candidates to visit and reject.
        # Python's list sort is stable, meaning relative order is kept for objects with
        # the same key.
 #ollected.requirements.sort(key=lambda r: r.name != r.project_name)
 #eturn collected

 #ef make_requirement_from_candidate(
 #elf, candidate: Candidate
 # -> ExplicitRequirement:
 #eturn ExplicitRequirement(candidate)

 #ef make_requirements_from_spec(
 #elf,
 #pecifier: str,
 #omes_from: Optional[InstallRequirement],
 #equested_extras: Iterable[str] = (),
 # -> Iterator[Requirement]:
 #""
 #eturns requirement objects associated with the given specifier. In most cases
 #his will be a single object but the following special cases exist:
 # the specifier has markers that do not apply -> result is empty
 # the specifier has both a constraint and extras -> result is split
 #n two requirement objects: one with the constraint and one with the
 #xtra. This allows centralized constraint handling for the base,
 #esulting in fewer candidate rejections.
 #""
 #req = self._make_install_req_from_spec(specifier, comes_from)
 #eturn self._make_requirements_from_install_req(ireq, requested_extras)

 #ef make_requires_python_requirement(
 #elf,
 #pecifier: SpecifierSet,
 # -> Optional[Requirement]:
 #f self._ignore_requires_python:
 #eturn None
        # Don't bother creating a dependency for an empty Requires-Python.
 #f not str(specifier):
 #eturn None
 #eturn RequiresPythonRequirement(specifier, self._python_candidate)

 #ef get_wheel_cache_entry(
 #elf, link: Link, name: Optional[str]
 # -> Optional[CacheEntry]:
 #""Look up the link in the wheel cache.

 #f ``preparer.require_hashes`` is True, don't use the wheel cache,
 #ecause cached wheels, always built locally, have different hashes
 #han the files downloaded from the index server and thus throw false
 #ash mismatches. Furthermore, cached wheels at present have
 #ondeterministic contents due to file modification times.
 #""
 #f self._wheel_cache is None:
 #eturn None
 #eturn self._wheel_cache.get_cache_entry(
 #ink=link,
 #ackage_name=name,
 #upported_tags=get_supported(),
 #

 #ef get_dist_to_uninstall(self, candidate: Candidate) -> Optional[BaseDistribution]:
        # TODO: Are there more cases this needs to return True? Editable?
 #ist = self._installed_dists.get(candidate.project_name)
 #f dist is None:  # Not installed, no uninstallation required.
 #eturn None

        # We're installing into global site. The current installation must
        # be uninstalled, no matter it's in global or user site, because the
        # user site installation has precedence over global.
 #f not self._use_user_site:
 #eturn dist

        # We're installing into user site. Remove the user site installation.
 #f dist.in_usersite:
 #eturn dist

        # We're installing into user site, but the installed incompatible
        # package is in global site. We can't uninstall that, and would let
        # the new user installation to "shadow" it. But shadowing won't work
        # in virtual environments, so we error out.
 #f running_under_virtualenv() and dist.in_site_packages:
 #essage = (
 #"Will not install to the user site because it will lack "
 #"sys.path precedence to {dist.raw_name} in {dist.location}"
 #
 #aise InstallationError(message)
 #eturn None

 #ef _report_requires_python_error(
 #elf, causes: Sequence["ConflictCause"]
 # -> UnsupportedPythonVersion:
 #ssert causes, "Requires-Python error reported with no cause"

 #ersion = self._python_candidate.version

 #f len(causes) == 1:
 #pecifier = str(causes[0].requirement.specifier)
 #essage = (
 #"Package {causes[0].parent.name!r} requires a different "
 #"Python: {version} not in {specifier!r}"
 #
 #eturn UnsupportedPythonVersion(message)

 #essage = f"Packages require a different Python. {version} not in:"
 #or cause in causes:
 #ackage = cause.parent.format_for_error()
 #pecifier = str(cause.requirement.specifier)
 #essage += f"\n{specifier!r} (required by {package})"
 #eturn UnsupportedPythonVersion(message)

 #ef _report_single_requirement_conflict(
 #elf, req: Requirement, parent: Optional[Candidate]
 # -> DistributionNotFound:
 #f parent is None:
 #eq_disp = str(req)
 #lse:
 #eq_disp = f"{req} (from {parent.name})"

 #ands = self._finder.find_all_candidates(req.project_name)
 #kipped_by_requires_python = self._finder.requires_python_skipped_reasons()

 #ersions_set: Set[CandidateVersion] = set()
 #anked_versions_set: Set[CandidateVersion] = set()
 #or c in cands:
 #s_yanked = c.link.is_yanked if c.link else False
 #f is_yanked:
 #anked_versions_set.add(c.version)
 #lse:
 #ersions_set.add(c.version)

 #ersions = [str(v) for v in sorted(versions_set)]
 #anked_versions = [str(v) for v in sorted(yanked_versions_set)]

 #f yanked_versions:
            # Saying "version X is yanked" isn't entirely accurate.
            # https://github.com/pypa/pip/issues/11745#issuecomment-1402805842
 #ogger.critical(
 #Ignored the following yanked versions: %s",
 #, ".join(yanked_versions) or "none",
 #
 #f skipped_by_requires_python:
 #ogger.critical(
 #Ignored the following versions that require a different python "
 #version: %s",
 #; ".join(skipped_by_requires_python) or "none",
 #
 #ogger.critical(
 #Could not find a version that satisfies the requirement %s "
 #(from versions: %s)",
 #eq_disp,
 #, ".join(versions) or "none",
 #
 #f str(req) == "requirements.txt":
 #ogger.info(
 #HINT: You are attempting to install a package literally "
 #named "requirements.txt" (which cannot exist). Consider '
 #using the '-r' flag to install the packages listed in "
 #requirements.txt"
 #

 #eturn DistributionNotFound(f"No matching distribution found for {req}")

 #ef get_installation_error(
 #elf,
 #: "ResolutionImpossible[Requirement, Candidate]",
 #onstraints: Dict[str, Constraint],
 # -> InstallationError:
 #ssert e.causes, "Installation error reported with no cause"

        # If one of the things we can't solve is "we need Python X.Y",
        # that is what we report.
 #equires_python_causes = [
 #ause
 #or cause in e.causes
 #f isinstance(cause.requirement, RequiresPythonRequirement)
 #nd not cause.requirement.is_satisfied_by(self._python_candidate)
 #
 #f requires_python_causes:
            # The comprehension above makes sure all Requirement instances are
            # RequiresPythonRequirement, so let's cast for convenience.
 #eturn self._report_requires_python_error(
 #ast("Sequence[ConflictCause]", requires_python_causes),
 #

        # Otherwise, we have a set of causes which can't all be satisfied
        # at once.

        # The simplest case is when we have *one* cause that can't be
        # satisfied. We just report that case.
 #f len(e.causes) == 1:
 #eq, parent = e.causes[0]
 #f req.name not in constraints:
 #eturn self._report_single_requirement_conflict(req, parent)

        # OK, we now have a list of requirements that can't all be
        # satisfied at once.

        # A couple of formatting helpers
 #ef text_join(parts: List[str]) -> str:
 #f len(parts) == 1:
 #eturn parts[0]

 #eturn ", ".join(parts[:-1]) + " and " + parts[-1]

 #ef describe_trigger(parent: Candidate) -> str:
 #req = parent.get_install_requirement()
 #f not ireq or not ireq.comes_from:
 #eturn f"{parent.name}=={parent.version}"
 #f isinstance(ireq.comes_from, InstallRequirement):
 #eturn str(ireq.comes_from.name)
 #eturn str(ireq.comes_from)

 #riggers = set()
 #or req, parent in e.causes:
 #f parent is None:
                # This is a root requirement, so we can report it directly
 #rigger = req.format_for_error()
 #lse:
 #rigger = describe_trigger(parent)
 #riggers.add(trigger)

 #f triggers:
 #nfo = text_join(sorted(triggers))
 #lse:
 #nfo = "the requested packages"

 #sg = (
 #"Cannot install {info} because these package versions "
 #have conflicting dependencies."
 #
 #ogger.critical(msg)
 #sg = "\nThe conflict is caused by:"

 #elevant_constraints = set()
 #or req, parent in e.causes:
 #f req.name in constraints:
 #elevant_constraints.add(req.name)
 #sg = msg + "\n    "
 #f parent:
 #sg = msg + f"{parent.name} {parent.version} depends on "
 #lse:
 #sg = msg + "The user requested "
 #sg = msg + req.format_for_error()
 #or key in relevant_constraints:
 #pec = constraints[key].specifier
 #sg += f"\n    The user requested (constraint) {key}{spec}"

 #sg = (
 #sg
 # "\n\n"
 # "To fix this you could try to:\n"
 # "1. loosen the range of package versions you've specified\n"
 # "2. remove package versions to allow pip attempt to solve "
 # "the dependency conflict\n"
 #

 #ogger.info(msg)

 #eturn DistributionNotFound(
 #ResolutionImpossible: for help visit "
 #https://pip.pypa.io/en/latest/topics/dependency-resolution/"
 ##dealing-with-dependency-conflicts"
 #
