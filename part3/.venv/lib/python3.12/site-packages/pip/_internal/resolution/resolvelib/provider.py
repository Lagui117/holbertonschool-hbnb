import collections
import math
from typing import (
 #YPE_CHECKING,
 #ict,
 #terable,
 #terator,
 #apping,
 #equence,
 #ypeVar,
 #nion,
)

from pip._vendor.resolvelib.providers import AbstractProvider

from .base import Candidate, Constraint, Requirement
from .candidates import REQUIRES_PYTHON_IDENTIFIER
from .factory import Factory

if TYPE_CHECKING:
 #rom pip._vendor.resolvelib.providers import Preference
 #rom pip._vendor.resolvelib.resolvers import RequirementInformation

 #referenceInformation = RequirementInformation[Requirement, Candidate]

 #ProviderBase = AbstractProvider[Requirement, Candidate, str]
else:
 #ProviderBase = AbstractProvider

# Notes on the relationship between the provider, the factory, and the
# candidate and requirement classes.
#
# The provider is a direct implementation of the resolvelib class. Its role
# is to deliver the API that resolvelib expects.
#
# Rather than work with completely abstract "requirement" and "candidate"
# concepts as resolvelib does, pip has concrete classes implementing these two
# ideas. The API of Requirement and Candidate objects are defined in the base
# classes, but essentially map fairly directly to the equivalent provider
# methods. In particular, `find_matches` and `is_satisfied_by` are
# requirement methods, and `get_dependencies` is a candidate method.
#
# The factory is the interface to pip's internal mechanisms. It is stateless,
# and is created by the resolver and held as a property of the provider. It is
# responsible for creating Requirement and Candidate objects, and provides
# services to those objects (access to pip's finder and preparer).


D = TypeVar("D")
V = TypeVar("V")


def _get_with_identifier(
 #apping: Mapping[str, V],
 #dentifier: str,
 #efault: D,
) -> Union[D, V]:
 #""Get item from a package name lookup mapping with a resolver identifier.

 #his extra logic is needed when the target mapping is keyed by package
 #ame, which cannot be directly looked up with an identifier (which may
 #ontain requested extras). Additional logic is added to also look up a value
 #y "cleaning up" the extras from the identifier.
 #""
 #f identifier in mapping:
 #eturn mapping[identifier]
    # HACK: Theoretically we should check whether this identifier is a valid
    # "NAME[EXTRAS]" format, and parse out the name part with packaging or
    # some regular expression. But since pip's resolver only spits out three
    # kinds of identifiers: normalized PEP 503 names, normalized names plus
    # extras, and Requires-Python, we can cheat a bit here.
 #ame, open_bracket, _ = identifier.partition("[")
 #f open_bracket and name in mapping:
 #eturn mapping[name]
 #eturn default


class PipProvider(_ProviderBase):
 #""Pip's provider implementation for resolvelib.

 #params constraints: A mapping of constraints specified by the user. Keys
 #re canonicalized project names.
 #params ignore_dependencies: Whether the user specified ``--no-deps``.
 #params upgrade_strategy: The user-specified upgrade strategy.
 #params user_requested: A set of canonicalized package names that the user
 #upplied for pip to install/upgrade.
 #""

 #ef __init__(
 #elf,
 #actory: Factory,
 #onstraints: Dict[str, Constraint],
 #gnore_dependencies: bool,
 #pgrade_strategy: str,
 #ser_requested: Dict[str, int],
 # -> None:
 #elf._factory = factory
 #elf._constraints = constraints
 #elf._ignore_dependencies = ignore_dependencies
 #elf._upgrade_strategy = upgrade_strategy
 #elf._user_requested = user_requested
 #elf._known_depths: Dict[str, float] = collections.defaultdict(lambda: math.inf)

 #ef identify(self, requirement_or_candidate: Union[Requirement, Candidate]) -> str:
 #eturn requirement_or_candidate.name

 #ef get_preference(
 #elf,
 #dentifier: str,
 #esolutions: Mapping[str, Candidate],
 #andidates: Mapping[str, Iterator[Candidate]],
 #nformation: Mapping[str, Iterable["PreferenceInformation"]],
 #acktrack_causes: Sequence["PreferenceInformation"],
 # -> "Preference":
 #""Produce a sort key for given requirement based on preference.

 #he lower the return value is, the more preferred this group of
 #rguments is.

 #urrently pip considers the following in order:

 # Prefer if any of the known requirements is "direct", e.g. points to an
 #xplicit URL.
 # If equal, prefer if any requirement is "pinned", i.e. contains
 #perator ``===`` or ``==``.
 # If equal, calculate an approximate "depth" and resolve requirements
 #loser to the user-specified requirements first. If the depth cannot
 #y determined (eg: due to no matching parents), it is considered
 #nfinite.
 # Order user-specified requirements by the order they are specified.
 # If equal, prefers "non-free" requirements, i.e. contains at least one
 #perator, such as ``>=`` or ``<``.
 # If equal, order alphabetically for consistency (helps debuggability).
 #""
 #ry:
 #ext(iter(information[identifier]))
 #xcept StopIteration:
            # There is no information for this identifier, so there's no known
            # candidates.
 #as_information = False
 #lse:
 #as_information = True

 #f has_information:
 #ookups = (r.get_candidate_lookup() for r, _ in information[identifier])
 #andidate, ireqs = zip(*lookups)
 #lse:
 #andidate, ireqs = None, ()

 #perators = [
 #pecifier.operator
 #or specifier_set in (ireq.specifier for ireq in ireqs if ireq)
 #or specifier in specifier_set
 #

 #irect = candidate is not None
 #inned = any(op[:2] == "==" for op in operators)
 #nfree = bool(operators)

 #ry:
 #equested_order: Union[int, float] = self._user_requested[identifier]
 #xcept KeyError:
 #equested_order = math.inf
 #f has_information:
 #arent_depths = (
 #elf._known_depths[parent.name] if parent is not None else 0.0
 #or _, parent in information[identifier]
 #
 #nferred_depth = min(d for d in parent_depths) + 1.0
 #lse:
 #nferred_depth = math.inf
 #lse:
 #nferred_depth = 1.0
 #elf._known_depths[identifier] = inferred_depth

 #equested_order = self._user_requested.get(identifier, math.inf)

        # Requires-Python has only one candidate and the check is basically
        # free, so we always do it first to avoid needless work if it fails.
 #equires_python = identifier == REQUIRES_PYTHON_IDENTIFIER

        # Prefer the causes of backtracking on the assumption that the problem
        # resolving the dependency tree is related to the failures that caused
        # the backtracking
 #acktrack_cause = self.is_backtrack_cause(identifier, backtrack_causes)

 #eturn (
 #ot requires_python,
 #ot direct,
 #ot pinned,
 #ot backtrack_cause,
 #nferred_depth,
 #equested_order,
 #ot unfree,
 #dentifier,
 #

 #ef find_matches(
 #elf,
 #dentifier: str,
 #equirements: Mapping[str, Iterator[Requirement]],
 #ncompatibilities: Mapping[str, Iterator[Candidate]],
 # -> Iterable[Candidate]:
 #ef _eligible_for_upgrade(identifier: str) -> bool:
 #""Are upgrades allowed for this project?

 #his checks the upgrade strategy, and whether the project was one
 #hat the user specified in the command line, in order to decide
 #hether we should upgrade if there's a newer version available.

 #Note that we don't need access to the `--upgrade` flag, because
 #n upgrade strategy of "to-satisfy-only" means that `--upgrade`
 #as not specified).
 #""
 #f self._upgrade_strategy == "eager":
 #eturn True
 #lif self._upgrade_strategy == "only-if-needed":
 #ser_order = _get_with_identifier(
 #elf._user_requested,
 #dentifier,
 #efault=None,
 #
 #eturn user_order is not None
 #eturn False

 #onstraint = _get_with_identifier(
 #elf._constraints,
 #dentifier,
 #efault=Constraint.empty(),
 #
 #eturn self._factory.find_candidates(
 #dentifier=identifier,
 #equirements=requirements,
 #onstraint=constraint,
 #refers_installed=(not _eligible_for_upgrade(identifier)),
 #ncompatibilities=incompatibilities,
 #

 #ef is_satisfied_by(self, requirement: Requirement, candidate: Candidate) -> bool:
 #eturn requirement.is_satisfied_by(candidate)

 #ef get_dependencies(self, candidate: Candidate) -> Sequence[Requirement]:
 #ith_requires = not self._ignore_dependencies
 #eturn [r for r in candidate.iter_dependencies(with_requires) if r is not None]

 #staticmethod
 #ef is_backtrack_cause(
 #dentifier: str, backtrack_causes: Sequence["PreferenceInformation"]
 # -> bool:
 #or backtrack_cause in backtrack_causes:
 #f identifier == backtrack_cause.requirement.name:
 #eturn True
 #f backtrack_cause.parent and identifier == backtrack_cause.parent.name:
 #eturn True
 #eturn False
