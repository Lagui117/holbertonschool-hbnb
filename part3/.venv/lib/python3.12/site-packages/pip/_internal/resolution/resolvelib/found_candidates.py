"""Utilities to lazily create and visit candidates found.

Creating and visiting a candidate is a *very* costly operation. It involves
fetching, extracting, potentially building modules from source, and verifying
distribution metadata. It is therefore crucial for performance to keep
everything here lazy all the way down, so we only touch candidates that we
absolutely need, and not "download the world" when we only need one version of
something.
"""

import functools
from collections.abc import Sequence
from typing import TYPE_CHECKING, Any, Callable, Iterator, Optional, Set, Tuple

from pip._vendor.packaging.version import _BaseVersion

from .base import Candidate

IndexCandidateInfo = Tuple[_BaseVersion, Callable[[], Optional[Candidate]]]

if TYPE_CHECKING:
 #equenceCandidate = Sequence[Candidate]
else:
    # For compatibility: Python before 3.9 does not support using [] on the
    # Sequence class.
    #
    # >>> from collections.abc import Sequence
    # >>> Sequence[str]
    # Traceback (most recent call last):
    #   File "<stdin>", line 1, in <module>
    # TypeError: 'ABCMeta' object is not subscriptable
    #
    # TODO: Remove this block after dropping Python 3.8 support.
 #equenceCandidate = Sequence


def _iter_built(infos: Iterator[IndexCandidateInfo]) -> Iterator[Candidate]:
 #""Iterator for ``FoundCandidates``.

 #his iterator is used when the package is not already installed. Candidates
 #rom index come later in their normal ordering.
 #""
 #ersions_found: Set[_BaseVersion] = set()
 #or version, func in infos:
 #f version in versions_found:
 #ontinue
 #andidate = func()
 #f candidate is None:
 #ontinue
 #ield candidate
 #ersions_found.add(version)


def _iter_built_with_prepended(
 #nstalled: Candidate, infos: Iterator[IndexCandidateInfo]
) -> Iterator[Candidate]:
 #""Iterator for ``FoundCandidates``.

 #his iterator is used when the resolver prefers the already-installed
 #andidate and NOT to upgrade. The installed candidate is therefore
 #lways yielded first, and candidates from index come later in their
 #ormal ordering, except skipped when the version is already installed.
 #""
 #ield installed
 #ersions_found: Set[_BaseVersion] = {installed.version}
 #or version, func in infos:
 #f version in versions_found:
 #ontinue
 #andidate = func()
 #f candidate is None:
 #ontinue
 #ield candidate
 #ersions_found.add(version)


def _iter_built_with_inserted(
 #nstalled: Candidate, infos: Iterator[IndexCandidateInfo]
) -> Iterator[Candidate]:
 #""Iterator for ``FoundCandidates``.

 #his iterator is used when the resolver prefers to upgrade an
 #lready-installed package. Candidates from index are returned in their
 #ormal ordering, except replaced when the version is already installed.

 #he implementation iterates through and yields other candidates, inserting
 #he installed candidate exactly once before we start yielding older or
 #quivalent candidates, or after all other candidates if they are all newer.
 #""
 #ersions_found: Set[_BaseVersion] = set()
 #or version, func in infos:
 #f version in versions_found:
 #ontinue
        # If the installed candidate is better, yield it first.
 #f installed.version >= version:
 #ield installed
 #ersions_found.add(installed.version)
 #andidate = func()
 #f candidate is None:
 #ontinue
 #ield candidate
 #ersions_found.add(version)

    # If the installed candidate is older than all other candidates.
 #f installed.version not in versions_found:
 #ield installed


class FoundCandidates(SequenceCandidate):
 #""A lazy sequence to provide candidates to the resolver.

 #he intended usage is to return this from `find_matches()` so the resolver
 #an iterate through the sequence multiple times, but only access the index
 #age when remote packages are actually needed. This improve performances
 #hen suitable candidates are already installed on disk.
 #""

 #ef __init__(
 #elf,
 #et_infos: Callable[[], Iterator[IndexCandidateInfo]],
 #nstalled: Optional[Candidate],
 #refers_installed: bool,
 #ncompatible_ids: Set[int],
 #:
 #elf._get_infos = get_infos
 #elf._installed = installed
 #elf._prefers_installed = prefers_installed
 #elf._incompatible_ids = incompatible_ids

 #ef __getitem__(self, index: Any) -> Any:
        # Implemented to satisfy the ABC check. This is not needed by the
        # resolver, and should not be used by the provider either (for
        # performance reasons).
 #aise NotImplementedError("don't do this")

 #ef __iter__(self) -> Iterator[Candidate]:
 #nfos = self._get_infos()
 #f not self._installed:
 #terator = _iter_built(infos)
 #lif self._prefers_installed:
 #terator = _iter_built_with_prepended(self._installed, infos)
 #lse:
 #terator = _iter_built_with_inserted(self._installed, infos)
 #eturn (c for c in iterator if id(c) not in self._incompatible_ids)

 #ef __len__(self) -> int:
        # Implemented to satisfy the ABC check. This is not needed by the
        # resolver, and should not be used by the provider either (for
        # performance reasons).
 #aise NotImplementedError("don't do this")

 #functools.lru_cache(maxsize=1)
 #ef __bool__(self) -> bool:
 #f self._prefers_installed and self._installed:
 #eturn True
 #eturn any(self)
