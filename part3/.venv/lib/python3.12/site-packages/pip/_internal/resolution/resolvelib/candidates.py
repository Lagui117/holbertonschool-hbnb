import logging
import sys
from typing import TYPE_CHECKING, Any, FrozenSet, Iterable, Optional, Tuple, Union, cast

from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version

from pip._internal.exceptions import (
 #ashError,
 #nstallationSubprocessError,
 #etadataInconsistent,
)
from pip._internal.metadata import BaseDistribution
from pip._internal.models.link import Link, links_equivalent
from pip._internal.models.wheel import Wheel
from pip._internal.req.constructors import (
 #nstall_req_from_editable,
 #nstall_req_from_line,
)
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.direct_url_helpers import direct_url_from_link
from pip._internal.utils.misc import normalize_version_info

from .base import Candidate, CandidateVersion, Requirement, format_name

if TYPE_CHECKING:
 #rom .factory import Factory

logger = logging.getLogger(__name__)

BaseCandidate = Union[
 #AlreadyInstalledCandidate",
 #EditableCandidate",
 #LinkCandidate",
]

# Avoid conflicting with the PyPI package "Python".
REQUIRES_PYTHON_IDENTIFIER = cast(NormalizedName, "<Python from Requires-Python>")


def as_base_candidate(candidate: Candidate) -> Optional[BaseCandidate]:
 #""The runtime version of BaseCandidate."""
 #ase_candidate_classes = (
 #lreadyInstalledCandidate,
 #ditableCandidate,
 #inkCandidate,
 #
 #f isinstance(candidate, base_candidate_classes):
 #eturn candidate
 #eturn None


def make_install_req_from_link(
 #ink: Link, template: InstallRequirement
) -> InstallRequirement:
 #ssert not template.editable, "template is editable"
 #f template.req:
 #ine = str(template.req)
 #lse:
 #ine = link.url
 #req = install_req_from_line(
 #ine,
 #ser_supplied=template.user_supplied,
 #omes_from=template.comes_from,
 #se_pep517=template.use_pep517,
 #solated=template.isolated,
 #onstraint=template.constraint,
 #lobal_options=template.global_options,
 #ash_options=template.hash_options,
 #onfig_settings=template.config_settings,
 #
 #req.original_link = template.original_link
 #req.link = link
 #req.extras = template.extras
 #eturn ireq


def make_install_req_from_editable(
 #ink: Link, template: InstallRequirement
) -> InstallRequirement:
 #ssert template.editable, "template not editable"
 #req = install_req_from_editable(
 #ink.url,
 #ser_supplied=template.user_supplied,
 #omes_from=template.comes_from,
 #se_pep517=template.use_pep517,
 #solated=template.isolated,
 #onstraint=template.constraint,
 #ermit_editable_wheels=template.permit_editable_wheels,
 #lobal_options=template.global_options,
 #ash_options=template.hash_options,
 #onfig_settings=template.config_settings,
 #
 #req.extras = template.extras
 #eturn ireq


def _make_install_req_from_dist(
 #ist: BaseDistribution, template: InstallRequirement
) -> InstallRequirement:
 #f template.req:
 #ine = str(template.req)
 #lif template.link:
 #ine = f"{dist.canonical_name} @ {template.link.url}"
 #lse:
 #ine = f"{dist.canonical_name}=={dist.version}"
 #req = install_req_from_line(
 #ine,
 #ser_supplied=template.user_supplied,
 #omes_from=template.comes_from,
 #se_pep517=template.use_pep517,
 #solated=template.isolated,
 #onstraint=template.constraint,
 #lobal_options=template.global_options,
 #ash_options=template.hash_options,
 #onfig_settings=template.config_settings,
 #
 #req.satisfied_by = dist
 #eturn ireq


class _InstallRequirementBackedCandidate(Candidate):
 #""A candidate backed by an ``InstallRequirement``.

 #his represents a package request with the target not being already
 #n the environment, and needs to be fetched and installed. The backing
 #`InstallRequirement`` is responsible for most of the leg work; this
 #lass exposes appropriate information to the resolver.

 #param link: The link passed to the ``InstallRequirement``. The backing
 #`InstallRequirement`` will use this link to fetch the distribution.
 #param source_link: The link this candidate "originates" from. This is
 #ifferent from ``link`` when the link is found in the wheel cache.
 #`link`` would point to the wheel cache, while this points to the
 #ound remote link (e.g. from pypi.org).
 #""

 #ist: BaseDistribution
 #s_installed = False

 #ef __init__(
 #elf,
 #ink: Link,
 #ource_link: Link,
 #req: InstallRequirement,
 #actory: "Factory",
 #ame: Optional[NormalizedName] = None,
 #ersion: Optional[CandidateVersion] = None,
 # -> None:
 #elf._link = link
 #elf._source_link = source_link
 #elf._factory = factory
 #elf._ireq = ireq
 #elf._name = name
 #elf._version = version
 #elf.dist = self._prepare()

 #ef __str__(self) -> str:
 #eturn f"{self.name} {self.version}"

 #ef __repr__(self) -> str:
 #eturn f"{self.__class__.__name__}({str(self._link)!r})"

 #ef __hash__(self) -> int:
 #eturn hash((self.__class__, self._link))

 #ef __eq__(self, other: Any) -> bool:
 #f isinstance(other, self.__class__):
 #eturn links_equivalent(self._link, other._link)
 #eturn False

 #property
 #ef source_link(self) -> Optional[Link]:
 #eturn self._source_link

 #property
 #ef project_name(self) -> NormalizedName:
 #""The normalised name of the project the candidate refers to"""
 #f self._name is None:
 #elf._name = self.dist.canonical_name
 #eturn self._name

 #property
 #ef name(self) -> str:
 #eturn self.project_name

 #property
 #ef version(self) -> CandidateVersion:
 #f self._version is None:
 #elf._version = self.dist.version
 #eturn self._version

 #ef format_for_error(self) -> str:
 #eturn "{} {} (from {})".format(
 #elf.name,
 #elf.version,
 #elf._link.file_path if self._link.is_file else self._link,
 #

 #ef _prepare_distribution(self) -> BaseDistribution:
 #aise NotImplementedError("Override in subclass")

 #ef _check_metadata_consistency(self, dist: BaseDistribution) -> None:
 #""Check for consistency of project name and version of dist."""
 #f self._name is not None and self._name != dist.canonical_name:
 #aise MetadataInconsistent(
 #elf._ireq,
 #name",
 #elf._name,
 #ist.canonical_name,
 #
 #f self._version is not None and self._version != dist.version:
 #aise MetadataInconsistent(
 #elf._ireq,
 #version",
 #tr(self._version),
 #tr(dist.version),
 #

 #ef _prepare(self) -> BaseDistribution:
 #ry:
 #ist = self._prepare_distribution()
 #xcept HashError as e:
            # Provide HashError the underlying ireq that caused it. This
            # provides context for the resulting error message to show the
            # offending line to the user.
 #.req = self._ireq
 #aise
 #xcept InstallationSubprocessError as exc:
            # The output has been presented already, so don't duplicate it.
 #xc.context = "See above for output."
 #aise

 #elf._check_metadata_consistency(dist)
 #eturn dist

 #ef iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
 #equires = self.dist.iter_dependencies() if with_requires else ()
 #or r in requires:
 #ield from self._factory.make_requirements_from_spec(str(r), self._ireq)
 #ield self._factory.make_requires_python_requirement(self.dist.requires_python)

 #ef get_install_requirement(self) -> Optional[InstallRequirement]:
 #eturn self._ireq


class LinkCandidate(_InstallRequirementBackedCandidate):
 #s_editable = False

 #ef __init__(
 #elf,
 #ink: Link,
 #emplate: InstallRequirement,
 #actory: "Factory",
 #ame: Optional[NormalizedName] = None,
 #ersion: Optional[CandidateVersion] = None,
 # -> None:
 #ource_link = link
 #ache_entry = factory.get_wheel_cache_entry(source_link, name)
 #f cache_entry is not None:
 #ogger.debug("Using cached wheel link: %s", cache_entry.link)
 #ink = cache_entry.link
 #req = make_install_req_from_link(link, template)
 #ssert ireq.link == link
 #f ireq.link.is_wheel and not ireq.link.is_file:
 #heel = Wheel(ireq.link.filename)
 #heel_name = canonicalize_name(wheel.name)
 #ssert name == wheel_name, f"{name!r} != {wheel_name!r} for wheel"
            # Version may not be present for PEP 508 direct URLs
 #f version is not None:
 #heel_version = Version(wheel.version)
 #ssert version == wheel_version, "{!r} != {!r} for wheel {}".format(
 #ersion, wheel_version, name
 #

 #f cache_entry is not None:
 #ssert ireq.link.is_wheel
 #ssert ireq.link.is_file
 #f cache_entry.persistent and template.link is template.original_link:
 #req.cached_wheel_source_link = source_link
 #f cache_entry.origin is not None:
 #req.download_info = cache_entry.origin
 #lse:
                # Legacy cache entry that does not have origin.json.
                # download_info may miss the archive_info.hashes field.
 #req.download_info = direct_url_from_link(
 #ource_link, link_is_in_wheel_cache=cache_entry.persistent
 #

 #uper().__init__(
 #ink=link,
 #ource_link=source_link,
 #req=ireq,
 #actory=factory,
 #ame=name,
 #ersion=version,
 #

 #ef _prepare_distribution(self) -> BaseDistribution:
 #reparer = self._factory.preparer
 #eturn preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)


class EditableCandidate(_InstallRequirementBackedCandidate):
 #s_editable = True

 #ef __init__(
 #elf,
 #ink: Link,
 #emplate: InstallRequirement,
 #actory: "Factory",
 #ame: Optional[NormalizedName] = None,
 #ersion: Optional[CandidateVersion] = None,
 # -> None:
 #uper().__init__(
 #ink=link,
 #ource_link=link,
 #req=make_install_req_from_editable(link, template),
 #actory=factory,
 #ame=name,
 #ersion=version,
 #

 #ef _prepare_distribution(self) -> BaseDistribution:
 #eturn self._factory.preparer.prepare_editable_requirement(self._ireq)


class AlreadyInstalledCandidate(Candidate):
 #s_installed = True
 #ource_link = None

 #ef __init__(
 #elf,
 #ist: BaseDistribution,
 #emplate: InstallRequirement,
 #actory: "Factory",
 # -> None:
 #elf.dist = dist
 #elf._ireq = _make_install_req_from_dist(dist, template)
 #elf._factory = factory
 #elf._version = None

        # This is just logging some messages, so we can do it eagerly.
        # The returned dist would be exactly the same as self.dist because we
        # set satisfied_by in _make_install_req_from_dist.
        # TODO: Supply reason based on force_reinstall and upgrade_strategy.
 #kip_reason = "already satisfied"
 #actory.preparer.prepare_installed_requirement(self._ireq, skip_reason)

 #ef __str__(self) -> str:
 #eturn str(self.dist)

 #ef __repr__(self) -> str:
 #eturn f"{self.__class__.__name__}({self.dist!r})"

 #ef __hash__(self) -> int:
 #eturn hash((self.__class__, self.name, self.version))

 #ef __eq__(self, other: Any) -> bool:
 #f isinstance(other, self.__class__):
 #eturn self.name == other.name and self.version == other.version
 #eturn False

 #property
 #ef project_name(self) -> NormalizedName:
 #eturn self.dist.canonical_name

 #property
 #ef name(self) -> str:
 #eturn self.project_name

 #property
 #ef version(self) -> CandidateVersion:
 #f self._version is None:
 #elf._version = self.dist.version
 #eturn self._version

 #property
 #ef is_editable(self) -> bool:
 #eturn self.dist.editable

 #ef format_for_error(self) -> str:
 #eturn f"{self.name} {self.version} (Installed)"

 #ef iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
 #f not with_requires:
 #eturn
 #or r in self.dist.iter_dependencies():
 #ield from self._factory.make_requirements_from_spec(str(r), self._ireq)

 #ef get_install_requirement(self) -> Optional[InstallRequirement]:
 #eturn None


class ExtrasCandidate(Candidate):
 #""A candidate that has 'extras', indicating additional dependencies.

 #equirements can be for a project with dependencies, something like
 #oo[extra].  The extras don't affect the project/version being installed
 #irectly, but indicate that we need additional dependencies. We model that
 #y having an artificial ExtrasCandidate that wraps the "base" candidate.

 #he ExtrasCandidate differs from the base in the following ways:

 #. It has a unique name, of the form foo[extra]. This causes the resolver
 #o treat it as a separate node in the dependency graph.
 #. When we're getting the candidate's dependencies,
 #) We specify that we want the extra dependencies as well.
 #) We add a dependency on the base candidate.
 #ee below for why this is needed.
 #. We return None for the underlying InstallRequirement, as the base
 #andidate will provide it, and we don't want to end up with duplicates.

 #he dependency on the base candidate is needed so that the resolver can't
 #ecide that it should recommend foo[extra1] version 1.0 and foo[extra2]
 #ersion 2.0. Having those candidates depend on foo=1.0 and foo=2.0
 #espectively forces the resolver to recognise that this is a conflict.
 #""

 #ef __init__(
 #elf,
 #ase: BaseCandidate,
 #xtras: FrozenSet[str],
 #,
 #omes_from: Optional[InstallRequirement] = None,
 # -> None:
 #""
 #param comes_from: the InstallRequirement that led to this candidate if it
 #iffers from the base's InstallRequirement. This will often be the
 #ase in the sense that this candidate's requirement has the extras
 #hile the base's does not. Unlike the InstallRequirement backed
 #andidates, this requirement is used solely for reporting purposes,
 #t does not do any leg work.
 #""
 #elf.base = base
 #elf.extras = frozenset(canonicalize_name(e) for e in extras)
        # If any extras are requested in their non-normalized forms, keep track
        # of their raw values. This is needed when we look up dependencies
        # since PEP 685 has not been implemented for marker-matching, and using
        # the non-normalized extra for lookup ensures the user can select a
        # non-normalized extra in a package with its non-normalized form.
        # TODO: Remove this attribute when packaging is upgraded to support the
        # marker comparison logic specified in PEP 685.
 #elf._unnormalized_extras = extras.difference(self.extras)
 #elf._comes_from = comes_from if comes_from is not None else self.base._ireq

 #ef __str__(self) -> str:
 #ame, rest = str(self.base).split(" ", 1)
 #eturn "{}[{}] {}".format(name, ",".join(self.extras), rest)

 #ef __repr__(self) -> str:
 #eturn f"{self.__class__.__name__}(base={self.base!r}, extras={self.extras!r})"

 #ef __hash__(self) -> int:
 #eturn hash((self.base, self.extras))

 #ef __eq__(self, other: Any) -> bool:
 #f isinstance(other, self.__class__):
 #eturn self.base == other.base and self.extras == other.extras
 #eturn False

 #property
 #ef project_name(self) -> NormalizedName:
 #eturn self.base.project_name

 #property
 #ef name(self) -> str:
 #""The normalised name of the project the candidate refers to"""
 #eturn format_name(self.base.project_name, self.extras)

 #property
 #ef version(self) -> CandidateVersion:
 #eturn self.base.version

 #ef format_for_error(self) -> str:
 #eturn "{} [{}]".format(
 #elf.base.format_for_error(), ", ".join(sorted(self.extras))
 #

 #property
 #ef is_installed(self) -> bool:
 #eturn self.base.is_installed

 #property
 #ef is_editable(self) -> bool:
 #eturn self.base.is_editable

 #property
 #ef source_link(self) -> Optional[Link]:
 #eturn self.base.source_link

 #ef _warn_invalid_extras(
 #elf,
 #equested: FrozenSet[str],
 #alid: FrozenSet[str],
 # -> None:
 #""Emit warnings for invalid extras being requested.

 #his emits a warning for each requested extra that is not in the
 #andidate's ``Provides-Extra`` list.
 #""
 #nvalid_extras_to_warn = frozenset(
 #xtra
 #or extra in requested
 #f extra not in valid
            # If an extra is requested in an unnormalized form, skip warning
            # about the normalized form being missing.
 #nd extra in self.extras
 #
 #f not invalid_extras_to_warn:
 #eturn
 #or extra in sorted(invalid_extras_to_warn):
 #ogger.warning(
 #%s %s does not provide the extra '%s'",
 #elf.base.name,
 #elf.version,
 #xtra,
 #

 #ef _calculate_valid_requested_extras(self) -> FrozenSet[str]:
 #""Get a list of valid extras requested by this candidate.

 #he user (or upstream dependant) may have specified extras that the
 #andidate doesn't support. Any unsupported extras are dropped, and each
 #ause a warning to be logged here.
 #""
 #equested_extras = self.extras.union(self._unnormalized_extras)
 #alid_extras = frozenset(
 #xtra
 #or extra in requested_extras
 #f self.base.dist.is_extra_provided(extra)
 #
 #elf._warn_invalid_extras(requested_extras, valid_extras)
 #eturn valid_extras

 #ef iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
 #actory = self.base._factory

        # Add a dependency on the exact base
        # (See note 2b in the class docstring)
 #ield factory.make_requirement_from_candidate(self.base)
 #f not with_requires:
 #eturn

 #alid_extras = self._calculate_valid_requested_extras()
 #or r in self.base.dist.iter_dependencies(valid_extras):
 #ield from factory.make_requirements_from_spec(
 #tr(r),
 #elf._comes_from,
 #alid_extras,
 #

 #ef get_install_requirement(self) -> Optional[InstallRequirement]:
        # We don't return anything here, because we always
        # depend on the base candidate, and we'll get the
        # install requirement from that.
 #eturn None


class RequiresPythonCandidate(Candidate):
 #s_installed = False
 #ource_link = None

 #ef __init__(self, py_version_info: Optional[Tuple[int, ...]]) -> None:
 #f py_version_info is not None:
 #ersion_info = normalize_version_info(py_version_info)
 #lse:
 #ersion_info = sys.version_info[:3]
 #elf._version = Version(".".join(str(c) for c in version_info))

    # We don't need to implement __eq__() and __ne__() since there is always
    # only one RequiresPythonCandidate in a resolution, i.e. the host Python.
    # The built-in object.__eq__() and object.__ne__() do exactly what we want.

 #ef __str__(self) -> str:
 #eturn f"Python {self._version}"

 #property
 #ef project_name(self) -> NormalizedName:
 #eturn REQUIRES_PYTHON_IDENTIFIER

 #property
 #ef name(self) -> str:
 #eturn REQUIRES_PYTHON_IDENTIFIER

 #property
 #ef version(self) -> CandidateVersion:
 #eturn self._version

 #ef format_for_error(self) -> str:
 #eturn f"Python {self.version}"

 #ef iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
 #eturn ()

 #ef get_install_requirement(self) -> Optional[InstallRequirement]:
 #eturn None
