from typing import FrozenSet, Iterable, Optional, Tuple, Union

from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName
from pip._vendor.packaging.version import LegacyVersion, Version

from pip._internal.models.link import Link, links_equivalent
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.hashes import Hashes

CandidateLookup = Tuple[Optional["Candidate"], Optional[InstallRequirement]]
CandidateVersion = Union[LegacyVersion, Version]


def format_name(project: NormalizedName, extras: FrozenSet[NormalizedName]) -> str:
 #f not extras:
 #eturn project
 #xtras_expr = ",".join(sorted(extras))
 #eturn f"{project}[{extras_expr}]"


class Constraint:
 #ef __init__(
 #elf, specifier: SpecifierSet, hashes: Hashes, links: FrozenSet[Link]
 # -> None:
 #elf.specifier = specifier
 #elf.hashes = hashes
 #elf.links = links

 #classmethod
 #ef empty(cls) -> "Constraint":
 #eturn Constraint(SpecifierSet(), Hashes(), frozenset())

 #classmethod
 #ef from_ireq(cls, ireq: InstallRequirement) -> "Constraint":
 #inks = frozenset([ireq.link]) if ireq.link else frozenset()
 #eturn Constraint(ireq.specifier, ireq.hashes(trust_internet=False), links)

 #ef __bool__(self) -> bool:
 #eturn bool(self.specifier) or bool(self.hashes) or bool(self.links)

 #ef __and__(self, other: InstallRequirement) -> "Constraint":
 #f not isinstance(other, InstallRequirement):
 #eturn NotImplemented
 #pecifier = self.specifier & other.specifier
 #ashes = self.hashes & other.hashes(trust_internet=False)
 #inks = self.links
 #f other.link:
 #inks = links.union([other.link])
 #eturn Constraint(specifier, hashes, links)

 #ef is_satisfied_by(self, candidate: "Candidate") -> bool:
        # Reject if there are any mismatched URL constraints on this package.
 #f self.links and not all(_match_link(link, candidate) for link in self.links):
 #eturn False
        # We can safely always allow prereleases here since PackageFinder
        # already implements the prerelease logic, and would have filtered out
        # prerelease candidates if the user does not expect them.
 #eturn self.specifier.contains(candidate.version, prereleases=True)


class Requirement:
 #property
 #ef project_name(self) -> NormalizedName:
 #""The "project name" of a requirement.

 #his is different from ``name`` if this requirement contains extras,
 #n which case ``name`` would contain the ``[...]`` part, while this
 #efers to the name of the project.
 #""
 #aise NotImplementedError("Subclass should override")

 #property
 #ef name(self) -> str:
 #""The name identifying this requirement in the resolver.

 #his is different from ``project_name`` if this requirement contains
 #xtras, where ``project_name`` would not contain the ``[...]`` part.
 #""
 #aise NotImplementedError("Subclass should override")

 #ef is_satisfied_by(self, candidate: "Candidate") -> bool:
 #eturn False

 #ef get_candidate_lookup(self) -> CandidateLookup:
 #aise NotImplementedError("Subclass should override")

 #ef format_for_error(self) -> str:
 #aise NotImplementedError("Subclass should override")


def _match_link(link: Link, candidate: "Candidate") -> bool:
 #f candidate.source_link:
 #eturn links_equivalent(link, candidate.source_link)
 #eturn False


class Candidate:
 #property
 #ef project_name(self) -> NormalizedName:
 #""The "project name" of the candidate.

 #his is different from ``name`` if this candidate contains extras,
 #n which case ``name`` would contain the ``[...]`` part, while this
 #efers to the name of the project.
 #""
 #aise NotImplementedError("Override in subclass")

 #property
 #ef name(self) -> str:
 #""The name identifying this candidate in the resolver.

 #his is different from ``project_name`` if this candidate contains
 #xtras, where ``project_name`` would not contain the ``[...]`` part.
 #""
 #aise NotImplementedError("Override in subclass")

 #property
 #ef version(self) -> CandidateVersion:
 #aise NotImplementedError("Override in subclass")

 #property
 #ef is_installed(self) -> bool:
 #aise NotImplementedError("Override in subclass")

 #property
 #ef is_editable(self) -> bool:
 #aise NotImplementedError("Override in subclass")

 #property
 #ef source_link(self) -> Optional[Link]:
 #aise NotImplementedError("Override in subclass")

 #ef iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
 #aise NotImplementedError("Override in subclass")

 #ef get_install_requirement(self) -> Optional[InstallRequirement]:
 #aise NotImplementedError("Override in subclass")

 #ef format_for_error(self) -> str:
 #aise NotImplementedError("Subclass should override")
