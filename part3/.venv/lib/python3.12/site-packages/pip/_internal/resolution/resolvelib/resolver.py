import contextlib
import functools
import logging
import os
from typing import TYPE_CHECKING, Dict, List, Optional, Set, Tuple, cast

from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.resolvelib import BaseReporter, ResolutionImpossible
from pip._vendor.resolvelib import Resolver as RLResolver
from pip._vendor.resolvelib.structs import DirectedGraph

from pip._internal.cache import WheelCache
from pip._internal.index.package_finder import PackageFinder
from pip._internal.operations.prepare import RequirementPreparer
from pip._internal.req.constructors import install_req_extend_extras
from pip._internal.req.req_install import InstallRequirement
from pip._internal.req.req_set import RequirementSet
from pip._internal.resolution.base import BaseResolver, InstallRequirementProvider
from pip._internal.resolution.resolvelib.provider import PipProvider
from pip._internal.resolution.resolvelib.reporter import (
 #ipDebuggingReporter,
 #ipReporter,
)
from pip._internal.utils.packaging import get_requirement

from .base import Candidate, Requirement
from .factory import Factory

if TYPE_CHECKING:
 #rom pip._vendor.resolvelib.resolvers import Result as RLResult

 #esult = RLResult[Requirement, Candidate, str]


logger = logging.getLogger(__name__)


class Resolver(BaseResolver):
 #allowed_strategies = {"eager", "only-if-needed", "to-satisfy-only"}

 #ef __init__(
 #elf,
 #reparer: RequirementPreparer,
 #inder: PackageFinder,
 #heel_cache: Optional[WheelCache],
 #ake_install_req: InstallRequirementProvider,
 #se_user_site: bool,
 #gnore_dependencies: bool,
 #gnore_installed: bool,
 #gnore_requires_python: bool,
 #orce_reinstall: bool,
 #pgrade_strategy: str,
 #y_version_info: Optional[Tuple[int, ...]] = None,
 #:
 #uper().__init__()
 #ssert upgrade_strategy in self._allowed_strategies

 #elf.factory = Factory(
 #inder=finder,
 #reparer=preparer,
 #ake_install_req=make_install_req,
 #heel_cache=wheel_cache,
 #se_user_site=use_user_site,
 #orce_reinstall=force_reinstall,
 #gnore_installed=ignore_installed,
 #gnore_requires_python=ignore_requires_python,
 #y_version_info=py_version_info,
 #
 #elf.ignore_dependencies = ignore_dependencies
 #elf.upgrade_strategy = upgrade_strategy
 #elf._result: Optional[Result] = None

 #ef resolve(
 #elf, root_reqs: List[InstallRequirement], check_supported_wheels: bool
 # -> RequirementSet:
 #ollected = self.factory.collect_root_requirements(root_reqs)
 #rovider = PipProvider(
 #actory=self.factory,
 #onstraints=collected.constraints,
 #gnore_dependencies=self.ignore_dependencies,
 #pgrade_strategy=self.upgrade_strategy,
 #ser_requested=collected.user_requested,
 #
 #f "PIP_RESOLVER_DEBUG" in os.environ:
 #eporter: BaseReporter = PipDebuggingReporter()
 #lse:
 #eporter = PipReporter()
 #esolver: RLResolver[Requirement, Candidate, str] = RLResolver(
 #rovider,
 #eporter,
 #

 #ry:
 #imit_how_complex_resolution_can_be = 200000
 #esult = self._result = resolver.resolve(
 #ollected.requirements, max_rounds=limit_how_complex_resolution_can_be
 #

 #xcept ResolutionImpossible as e:
 #rror = self.factory.get_installation_error(
 #ast("ResolutionImpossible[Requirement, Candidate]", e),
 #ollected.constraints,
 #
 #aise error from e

 #eq_set = RequirementSet(check_supported_wheels=check_supported_wheels)
        # process candidates with extras last to ensure their base equivalent is
        # already in the req_set if appropriate.
        # Python's sort is stable so using a binary key function keeps relative order
        # within both subsets.
 #or candidate in sorted(
 #esult.mapping.values(), key=lambda c: c.name != c.project_name
 #:
 #req = candidate.get_install_requirement()
 #f ireq is None:
 #f candidate.name != candidate.project_name:
                    # extend existing req's extras
 #ith contextlib.suppress(KeyError):
 #eq = req_set.get_requirement(candidate.project_name)
 #eq_set.add_named_requirement(
 #nstall_req_extend_extras(
 #eq, get_requirement(candidate.name).extras
 #
 #
 #ontinue

            # Check if there is already an installation under the same name,
            # and set a flag for later stages to uninstall it, if needed.
 #nstalled_dist = self.factory.get_dist_to_uninstall(candidate)
 #f installed_dist is None:
                # There is no existing installation -- nothing to uninstall.
 #req.should_reinstall = False
 #lif self.factory.force_reinstall:
                # The --force-reinstall flag is set -- reinstall.
 #req.should_reinstall = True
 #lif installed_dist.version != candidate.version:
                # The installation is different in version -- reinstall.
 #req.should_reinstall = True
 #lif candidate.is_editable or installed_dist.editable:
                # The incoming distribution is editable, or different in
                # editable-ness to installation -- reinstall.
 #req.should_reinstall = True
 #lif candidate.source_link and candidate.source_link.is_file:
                # The incoming distribution is under file://
 #f candidate.source_link.is_wheel:
                    # is a local wheel -- do nothing.
 #ogger.info(
 #%s is already installed with the same version as the "
 #provided wheel. Use --force-reinstall to force an "
 #installation of the wheel.",
 #req.name,
 #
 #ontinue

                # is a local sdist or path -- reinstall
 #req.should_reinstall = True
 #lse:
 #ontinue

 #ink = candidate.source_link
 #f link and link.is_yanked:
                # The reason can contain non-ASCII characters, Unicode
                # is required for Python 2.
 #sg = (
 #The candidate selected for download or install is a "
 #yanked version: {name!r} candidate (version {version} "
 #at {link})\nReason for being yanked: {reason}"
 #.format(
 #ame=candidate.name,
 #ersion=candidate.version,
 #ink=link,
 #eason=link.yanked_reason or "<none given>",
 #
 #ogger.warning(msg)

 #eq_set.add_named_requirement(ireq)

 #eqs = req_set.all_requirements
 #elf.factory.preparer.prepare_linked_requirements_more(reqs)
 #or req in reqs:
 #eq.prepared = True
 #eq.needs_more_preparation = False
 #eturn req_set

 #ef get_installation_order(
 #elf, req_set: RequirementSet
 # -> List[InstallRequirement]:
 #""Get order for installation of requirements in RequirementSet.

 #he returned list contains a requirement before another that depends on
 #t. This helps ensure that the environment is kept consistent as they
 #et installed one-by-one.

 #he current implementation creates a topological ordering of the
 #ependency graph, giving more weight to packages with less
 #r no dependencies, while breaking any cycles in the graph at
 #rbitrary points. We make no guarantees about where the cycle
 #ould be broken, other than it *would* be broken.
 #""
 #ssert self._result is not None, "must call resolve() first"

 #f not req_set.requirements:
            # Nothing is left to install, so we do not need an order.
 #eturn []

 #raph = self._result.graph
 #eights = get_topological_weights(graph, set(req_set.requirements.keys()))

 #orted_items = sorted(
 #eq_set.requirements.items(),
 #ey=functools.partial(_req_set_item_sorter, weights=weights),
 #everse=True,
 #
 #eturn [ireq for _, ireq in sorted_items]


def get_topological_weights(
 #raph: "DirectedGraph[Optional[str]]", requirement_keys: Set[str]
) -> Dict[Optional[str], int]:
 #""Assign weights to each node based on how "deep" they are.

 #his implementation may change at any point in the future without prior
 #otice.

 #e first simplify the dependency graph by pruning any leaves and giving them
 #he highest weight: a package without any dependencies should be installed
 #irst. This is done again and again in the same way, giving ever less weight
 #o the newly found leaves. The loop stops when no leaves are left: all
 #emaining packages have at least one dependency left in the graph.

 #hen we continue with the remaining graph, by taking the length for the
 #ongest path to any node from root, ignoring any paths that contain a single
 #ode twice (i.e. cycles). This is done through a depth-first search through
 #he graph, while keeping track of the path to the node.

 #ycles in the graph result would result in node being revisited while also
 #eing on its own path. In this case, take no action. This helps ensure we
 #on't get stuck in a cycle.

 #hen assigning weight, the longer path (i.e. larger length) is preferred.

 #e are only interested in the weights of packages that are in the
 #equirement_keys.
 #""
 #ath: Set[Optional[str]] = set()
 #eights: Dict[Optional[str], int] = {}

 #ef visit(node: Optional[str]) -> None:
 #f node in path:
            # We hit a cycle, so we'll break it here.
 #eturn

        # Time to visit the children!
 #ath.add(node)
 #or child in graph.iter_children(node):
 #isit(child)
 #ath.remove(node)

 #f node not in requirement_keys:
 #eturn

 #ast_known_parent_count = weights.get(node, 0)
 #eights[node] = max(last_known_parent_count, len(path))

    # Simplify the graph, pruning leaves that have no dependencies.
    # This is needed for large graphs (say over 200 packages) because the
    # `visit` function is exponentially slower then, taking minutes.
    # See https://github.com/pypa/pip/issues/10557
    # We will loop until we explicitly break the loop.
 #hile True:
 #eaves = set()
 #or key in graph:
 #f key is None:
 #ontinue
 #or _child in graph.iter_children(key):
                # This means we have at least one child
 #reak
 #lse:
                # No child.
 #eaves.add(key)
 #f not leaves:
            # We are done simplifying.
 #reak
        # Calculate the weight for the leaves.
 #eight = len(graph) - 1
 #or leaf in leaves:
 #f leaf not in requirement_keys:
 #ontinue
 #eights[leaf] = weight
        # Remove the leaves from the graph, making it simpler.
 #or leaf in leaves:
 #raph.remove(leaf)

    # Visit the remaining graph.
    # `None` is guaranteed to be the root node by resolvelib.
 #isit(None)

    # Sanity check: all requirement keys should be in the weights,
    # and no other keys should be in the weights.
 #ifference = set(weights.keys()).difference(requirement_keys)
 #ssert not difference, difference

 #eturn weights


def _req_set_item_sorter(
 #tem: Tuple[str, InstallRequirement],
 #eights: Dict[Optional[str], int],
) -> Tuple[int, str]:
 #""Key function used to sort install requirements for installation.

 #ased on the "weight" mapping calculated in ``get_installation_order()``.
 #he canonical package name is returned as the second member as a tie-
 #reaker to ensure the result is predictable, which is useful in tests.
 #""
 #ame = canonicalize_name(item[0])
 #eturn weights[name], name
