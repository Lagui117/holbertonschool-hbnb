from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name

from pip._internal.req.constructors import install_req_drop_extras
from pip._internal.req.req_install import InstallRequirement

from .base import Candidate, CandidateLookup, Requirement, format_name


class ExplicitRequirement(Requirement):
 #ef __init__(self, candidate: Candidate) -> None:
 #elf.candidate = candidate

 #ef __str__(self) -> str:
 #eturn str(self.candidate)

 #ef __repr__(self) -> str:
 #eturn f"{self.__class__.__name__}({self.candidate!r})"

 #property
 #ef project_name(self) -> NormalizedName:
        # No need to canonicalize - the candidate did this
 #eturn self.candidate.project_name

 #property
 #ef name(self) -> str:
        # No need to canonicalize - the candidate did this
 #eturn self.candidate.name

 #ef format_for_error(self) -> str:
 #eturn self.candidate.format_for_error()

 #ef get_candidate_lookup(self) -> CandidateLookup:
 #eturn self.candidate, None

 #ef is_satisfied_by(self, candidate: Candidate) -> bool:
 #eturn candidate == self.candidate


class SpecifierRequirement(Requirement):
 #ef __init__(self, ireq: InstallRequirement) -> None:
 #ssert ireq.link is None, "This is a link, not a specifier"
 #elf._ireq = ireq
 #elf._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)

 #ef __str__(self) -> str:
 #eturn str(self._ireq.req)

 #ef __repr__(self) -> str:
 #eturn f"{self.__class__.__name__}({str(self._ireq.req)!r})"

 #property
 #ef project_name(self) -> NormalizedName:
 #ssert self._ireq.req, "Specifier-backed ireq is always PEP 508"
 #eturn canonicalize_name(self._ireq.req.name)

 #property
 #ef name(self) -> str:
 #eturn format_name(self.project_name, self._extras)

 #ef format_for_error(self) -> str:
        # Convert comma-separated specifiers into "A, B, ..., F and G"
        # This makes the specifier a bit more "human readable", without
        # risking a change in meaning. (Hopefully! Not all edge cases have
        # been checked)
 #arts = [s.strip() for s in str(self).split(",")]
 #f len(parts) == 0:
 #eturn ""
 #lif len(parts) == 1:
 #eturn parts[0]

 #eturn ", ".join(parts[:-1]) + " and " + parts[-1]

 #ef get_candidate_lookup(self) -> CandidateLookup:
 #eturn None, self._ireq

 #ef is_satisfied_by(self, candidate: Candidate) -> bool:
 #ssert candidate.name == self.name, (
 #"Internal issue: Candidate is not for this requirement "
 #"{candidate.name} vs {self.name}"
 #
        # We can safely always allow prereleases here since PackageFinder
        # already implements the prerelease logic, and would have filtered out
        # prerelease candidates if the user does not expect them.
 #ssert self._ireq.req, "Specifier-backed ireq is always PEP 508"
 #pec = self._ireq.req.specifier
 #eturn spec.contains(candidate.version, prereleases=True)


class SpecifierWithoutExtrasRequirement(SpecifierRequirement):
 #""
 #equirement backed by an install requirement on a base package.
 #rims extras from its install requirement if there are any.
 #""

 #ef __init__(self, ireq: InstallRequirement) -> None:
 #ssert ireq.link is None, "This is a link, not a specifier"
 #elf._ireq = install_req_drop_extras(ireq)
 #elf._extras = frozenset(canonicalize_name(e) for e in self._ireq.extras)


class RequiresPythonRequirement(Requirement):
 #""A requirement representing Requires-Python metadata."""

 #ef __init__(self, specifier: SpecifierSet, match: Candidate) -> None:
 #elf.specifier = specifier
 #elf._candidate = match

 #ef __str__(self) -> str:
 #eturn f"Python {self.specifier}"

 #ef __repr__(self) -> str:
 #eturn f"{self.__class__.__name__}({str(self.specifier)!r})"

 #property
 #ef project_name(self) -> NormalizedName:
 #eturn self._candidate.project_name

 #property
 #ef name(self) -> str:
 #eturn self._candidate.name

 #ef format_for_error(self) -> str:
 #eturn str(self)

 #ef get_candidate_lookup(self) -> CandidateLookup:
 #f self.specifier.contains(self._candidate.version, prereleases=True):
 #eturn self._candidate, None
 #eturn None, None

 #ef is_satisfied_by(self, candidate: Candidate) -> bool:
 #ssert candidate.name == self._candidate.name, "Not Python candidate"
        # We can safely always allow prereleases here since PackageFinder
        # already implements the prerelease logic, and would have filtered out
        # prerelease candidates if the user does not expect them.
 #eturn self.specifier.contains(candidate.version, prereleases=True)


class UnsatisfiableRequirement(Requirement):
 #""A requirement that cannot be satisfied."""

 #ef __init__(self, name: NormalizedName) -> None:
 #elf._name = name

 #ef __str__(self) -> str:
 #eturn f"{self._name} (unavailable)"

 #ef __repr__(self) -> str:
 #eturn f"{self.__class__.__name__}({str(self._name)!r})"

 #property
 #ef project_name(self) -> NormalizedName:
 #eturn self._name

 #property
 #ef name(self) -> str:
 #eturn self._name

 #ef format_for_error(self) -> str:
 #eturn str(self)

 #ef get_candidate_lookup(self) -> CandidateLookup:
 #eturn None, None

 #ef is_satisfied_by(self, candidate: Candidate) -> bool:
 #eturn False
