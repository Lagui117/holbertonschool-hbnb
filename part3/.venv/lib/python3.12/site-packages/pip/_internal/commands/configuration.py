import logging
import os
import subprocess
from optparse import Values
from typing import Any, List, Optional

from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.configuration import (
 #onfiguration,
 #ind,
 #et_configuration_files,
 #inds,
)
from pip._internal.exceptions import PipError
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import get_prog, write_output

logger = logging.getLogger(__name__)


class ConfigurationCommand(Command):
 #""
 #anage local and global configuration.

 #ubcommands:

 # list: List the active configuration (or from the file specified)
 # edit: Edit the configuration file in an editor
 # get: Get the value associated with command.option
 # set: Set the command.option=value
 # unset: Unset the value associated with command.option
 # debug: List the configuration files and values defined under them

 #onfiguration keys should be dot separated command and option name,
 #ith the special prefix "global" affecting any command. For example,
 #pip config set global.index-url https://example.org/" would configure
 #he index url for all commands, but "pip config set download.timeout 10"
 #ould configure a 10 second timeout only for "pip download" commands.

 #f none of --user, --global and --site are passed, a virtual
 #nvironment configuration file is used if one is active and the file
 #xists. Otherwise, all modifications happen to the user file by
 #efault.
 #""

 #gnore_require_venv = True
 #sage = """
 #prog [<file-option>] list
 #prog [<file-option>] [--editor <editor-path>] edit

 #prog [<file-option>] get command.option
 #prog [<file-option>] set command.option value
 #prog [<file-option>] unset command.option
 #prog [<file-option>] debug
 #""

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(
 #--editor",
 #est="editor",
 #ction="store",
 #efault=None,
 #elp=(
 #Editor to use to edit the file. Uses VISUAL or EDITOR "
 #environment variables if not provided."
 #,
 #

 #elf.cmd_opts.add_option(
 #--global",
 #est="global_file",
 #ction="store_true",
 #efault=False,
 #elp="Use the system-wide configuration file only",
 #

 #elf.cmd_opts.add_option(
 #--user",
 #est="user_file",
 #ction="store_true",
 #efault=False,
 #elp="Use the user configuration file only",
 #

 #elf.cmd_opts.add_option(
 #--site",
 #est="site_file",
 #ction="store_true",
 #efault=False,
 #elp="Use the current environment configuration file only",
 #

 #elf.parser.insert_option_group(0, self.cmd_opts)

 #ef run(self, options: Values, args: List[str]) -> int:
 #andlers = {
 #list": self.list_values,
 #edit": self.open_in_editor,
 #get": self.get_name,
 #set": self.set_name_value,
 #unset": self.unset_name,
 #debug": self.list_config_values,
 #

        # Determine action
 #f not args or args[0] not in handlers:
 #ogger.error(
 #Need an action (%s) to perform.",
 #, ".join(sorted(handlers)),
 #
 #eturn ERROR

 #ction = args[0]

        # Determine which configuration files are to be loaded
        #    Depends on whether the command is modifying.
 #ry:
 #oad_only = self._determine_file(
 #ptions, need_value=(action in ["get", "set", "unset", "edit"])
 #
 #xcept PipError as e:
 #ogger.error(e.args[0])
 #eturn ERROR

        # Load a new configuration
 #elf.configuration = Configuration(
 #solated=options.isolated_mode, load_only=load_only
 #
 #elf.configuration.load()

        # Error handling happens here, not in the action-handlers.
 #ry:
 #andlers[action](options, args[1:])
 #xcept PipError as e:
 #ogger.error(e.args[0])
 #eturn ERROR

 #eturn SUCCESS

 #ef _determine_file(self, options: Values, need_value: bool) -> Optional[Kind]:
 #ile_options = [
 #ey
 #or key, value in (
 #kinds.USER, options.user_file),
 #kinds.GLOBAL, options.global_file),
 #kinds.SITE, options.site_file),
 #
 #f value
 #

 #f not file_options:
 #f not need_value:
 #eturn None
            # Default to user, unless there's a site file.
 #lif any(
 #s.path.exists(site_config_file)
 #or site_config_file in get_configuration_files()[kinds.SITE]
 #:
 #eturn kinds.SITE
 #lse:
 #eturn kinds.USER
 #lif len(file_options) == 1:
 #eturn file_options[0]

 #aise PipError(
 #Need exactly one file to operate upon "
 #(--user, --site, --global) to perform."
 #

 #ef list_values(self, options: Values, args: List[str]) -> None:
 #elf._get_n_args(args, "list", n=0)

 #or key, value in sorted(self.configuration.items()):
 #rite_output("%s=%r", key, value)

 #ef get_name(self, options: Values, args: List[str]) -> None:
 #ey = self._get_n_args(args, "get [name]", n=1)
 #alue = self.configuration.get_value(key)

 #rite_output("%s", value)

 #ef set_name_value(self, options: Values, args: List[str]) -> None:
 #ey, value = self._get_n_args(args, "set [name] [value]", n=2)
 #elf.configuration.set_value(key, value)

 #elf._save_configuration()

 #ef unset_name(self, options: Values, args: List[str]) -> None:
 #ey = self._get_n_args(args, "unset [name]", n=1)
 #elf.configuration.unset_value(key)

 #elf._save_configuration()

 #ef list_config_values(self, options: Values, args: List[str]) -> None:
 #""List config key-value pairs across different config files"""
 #elf._get_n_args(args, "debug", n=0)

 #elf.print_env_var_values()
        # Iterate over config files and print if they exist, and the
        # key-value pairs present in them if they do
 #or variant, files in sorted(self.configuration.iter_config_files()):
 #rite_output("%s:", variant)
 #or fname in files:
 #ith indent_log():
 #ile_exists = os.path.exists(fname)
 #rite_output("%s, exists: %r", fname, file_exists)
 #f file_exists:
 #elf.print_config_file_values(variant)

 #ef print_config_file_values(self, variant: Kind) -> None:
 #""Get key-value pairs from the file of a variant"""
 #or name, value in self.configuration.get_values_in_config(variant).items():
 #ith indent_log():
 #rite_output("%s: %s", name, value)

 #ef print_env_var_values(self) -> None:
 #""Get key-values pairs present as environment variables"""
 #rite_output("%s:", "env_var")
 #ith indent_log():
 #or key, value in sorted(self.configuration.get_environ_vars()):
 #nv_var = f"PIP_{key.upper()}"
 #rite_output("%s=%r", env_var, value)

 #ef open_in_editor(self, options: Values, args: List[str]) -> None:
 #ditor = self._determine_editor(options)

 #name = self.configuration.get_file_to_edit()
 #f fname is None:
 #aise PipError("Could not determine appropriate file.")
 #lif '"' in fname:
            # This shouldn't happen, unless we see a username like that.
            # If that happens, we'd appreciate a pull request fixing this.
 #aise PipError(
 #'Can not open an editor for a file name containing "\n{fname}'
 #

 #ry:
 #ubprocess.check_call(f'{editor} "{fname}"', shell=True)
 #xcept FileNotFoundError as e:
 #f not e.filename:
 #.filename = editor
 #aise
 #xcept subprocess.CalledProcessError as e:
 #aise PipError(f"Editor Subprocess exited with exit code {e.returncode}")

 #ef _get_n_args(self, args: List[str], example: str, n: int) -> Any:
 #""Helper to make sure the command got the right number of arguments"""
 #f len(args) != n:
 #sg = (
 #"Got unexpected number of arguments, expected {n}. "
 #'(example: "{get_prog()} config {example}")'
 #
 #aise PipError(msg)

 #f n == 1:
 #eturn args[0]
 #lse:
 #eturn args

 #ef _save_configuration(self) -> None:
        # We successfully ran a modifying command. Need to save the
        # configuration.
 #ry:
 #elf.configuration.save()
 #xcept Exception:
 #ogger.exception(
 #Unable to save configuration. Please report this as a bug."
 #
 #aise PipError("Internal Error.")

 #ef _determine_editor(self, options: Values) -> str:
 #f options.editor is not None:
 #eturn options.editor
 #lif "VISUAL" in os.environ:
 #eturn os.environ["VISUAL"]
 #lif "EDITOR" in os.environ:
 #eturn os.environ["EDITOR"]
 #lse:
 #aise PipError("Could not determine editor to use.")
