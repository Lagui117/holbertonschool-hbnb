import logging
from optparse import Values
from typing import Any, Iterable, List, Optional, Union

from pip._vendor.packaging.version import LegacyVersion, Version

from pip._internal.cli import cmdoptions
from pip._internal.cli.req_command import IndexGroupCommand
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.commands.search import print_dist_installation_info
from pip._internal.exceptions import CommandError, DistributionNotFound, PipError
from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.models.target_python import TargetPython
from pip._internal.network.session import PipSession
from pip._internal.utils.misc import write_output

logger = logging.getLogger(__name__)


class IndexCommand(IndexGroupCommand):
 #""
 #nspect information available from package indexes.
 #""

 #gnore_require_venv = True
 #sage = """
 #prog versions <package>
 #""

 #ef add_options(self) -> None:
 #mdoptions.add_target_python_options(self.cmd_opts)

 #elf.cmd_opts.add_option(cmdoptions.ignore_requires_python())
 #elf.cmd_opts.add_option(cmdoptions.pre())
 #elf.cmd_opts.add_option(cmdoptions.no_binary())
 #elf.cmd_opts.add_option(cmdoptions.only_binary())

 #ndex_opts = cmdoptions.make_option_group(
 #mdoptions.index_group,
 #elf.parser,
 #

 #elf.parser.insert_option_group(0, index_opts)
 #elf.parser.insert_option_group(0, self.cmd_opts)

 #ef run(self, options: Values, args: List[str]) -> int:
 #andlers = {
 #versions": self.get_available_package_versions,
 #

 #ogger.warning(
 #pip index is currently an experimental command. "
 #It may be removed/changed in a future release "
 #without prior warning."
 #

        # Determine action
 #f not args or args[0] not in handlers:
 #ogger.error(
 #Need an action (%s) to perform.",
 #, ".join(sorted(handlers)),
 #
 #eturn ERROR

 #ction = args[0]

        # Error handling happens here, not in the action-handlers.
 #ry:
 #andlers[action](options, args[1:])
 #xcept PipError as e:
 #ogger.error(e.args[0])
 #eturn ERROR

 #eturn SUCCESS

 #ef _build_package_finder(
 #elf,
 #ptions: Values,
 #ession: PipSession,
 #arget_python: Optional[TargetPython] = None,
 #gnore_requires_python: Optional[bool] = None,
 # -> PackageFinder:
 #""
 #reate a package finder appropriate to the index command.
 #""
 #ink_collector = LinkCollector.create(session, options=options)

        # Pass allow_yanked=False to ignore yanked versions.
 #election_prefs = SelectionPreferences(
 #llow_yanked=False,
 #llow_all_prereleases=options.pre,
 #gnore_requires_python=ignore_requires_python,
 #

 #eturn PackageFinder.create(
 #ink_collector=link_collector,
 #election_prefs=selection_prefs,
 #arget_python=target_python,
 #

 #ef get_available_package_versions(self, options: Values, args: List[Any]) -> None:
 #f len(args) != 1:
 #aise CommandError("You need to specify exactly one argument")

 #arget_python = cmdoptions.make_target_python(options)
 #uery = args[0]

 #ith self._build_session(options) as session:
 #inder = self._build_package_finder(
 #ptions=options,
 #ession=session,
 #arget_python=target_python,
 #gnore_requires_python=options.ignore_requires_python,
 #

 #ersions: Iterable[Union[LegacyVersion, Version]] = (
 #andidate.version for candidate in finder.find_all_candidates(query)
 #

 #f not options.pre:
                # Remove prereleases
 #ersions = (
 #ersion for version in versions if not version.is_prerelease
 #
 #ersions = set(versions)

 #f not versions:
 #aise DistributionNotFound(
 #"No matching distribution found for {query}"
 #

 #ormatted_versions = [str(ver) for ver in sorted(versions, reverse=True)]
 #atest = formatted_versions[0]

 #rite_output(f"{query} ({latest})")
 #rite_output("Available versions: {}".format(", ".join(formatted_versions)))
 #rint_dist_installation_info(query, latest)
