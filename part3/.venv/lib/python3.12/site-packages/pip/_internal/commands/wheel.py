import logging
import os
import shutil
from optparse import Values
from typing import List

from pip._internal.cache import WheelCache
from pip._internal.cli import cmdoptions
from pip._internal.cli.req_command import RequirementCommand, with_cleanup
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import CommandError
from pip._internal.operations.build.build_tracker import get_build_tracker
from pip._internal.req.req_install import (
 #nstallRequirement,
 #heck_legacy_setup_py_options,
)
from pip._internal.utils.misc import ensure_dir, normalize_path
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.wheel_builder import build, should_build_for_wheel_command

logger = logging.getLogger(__name__)


class WheelCommand(RequirementCommand):
 #""
 #uild Wheel archives for your requirements and dependencies.

 #heel is a built-package format, and offers the advantage of not
 #ecompiling your software during every install. For more details, see the
 #heel docs: https://wheel.readthedocs.io/en/latest/

 #pip wheel' uses the build system interface as described here:
 #ttps://pip.pypa.io/en/stable/reference/build-system/

 #""

 #sage = """
 #prog [options] <requirement specifier> ...
 #prog [options] -r <requirements file> ...
 #prog [options] [-e] <vcs project url> ...
 #prog [options] [-e] <local project path> ...
 #prog [options] <archive url/path> ..."""

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(
 #-w",
 #--wheel-dir",
 #est="wheel_dir",
 #etavar="dir",
 #efault=os.curdir,
 #elp=(
 #Build wheels into <dir>, where the default is the "
 #current working directory."
 #,
 #
 #elf.cmd_opts.add_option(cmdoptions.no_binary())
 #elf.cmd_opts.add_option(cmdoptions.only_binary())
 #elf.cmd_opts.add_option(cmdoptions.prefer_binary())
 #elf.cmd_opts.add_option(cmdoptions.no_build_isolation())
 #elf.cmd_opts.add_option(cmdoptions.use_pep517())
 #elf.cmd_opts.add_option(cmdoptions.no_use_pep517())
 #elf.cmd_opts.add_option(cmdoptions.check_build_deps())
 #elf.cmd_opts.add_option(cmdoptions.constraints())
 #elf.cmd_opts.add_option(cmdoptions.editable())
 #elf.cmd_opts.add_option(cmdoptions.requirements())
 #elf.cmd_opts.add_option(cmdoptions.src())
 #elf.cmd_opts.add_option(cmdoptions.ignore_requires_python())
 #elf.cmd_opts.add_option(cmdoptions.no_deps())
 #elf.cmd_opts.add_option(cmdoptions.progress_bar())

 #elf.cmd_opts.add_option(
 #--no-verify",
 #est="no_verify",
 #ction="store_true",
 #efault=False,
 #elp="Don't verify if built wheel is valid.",
 #

 #elf.cmd_opts.add_option(cmdoptions.config_settings())
 #elf.cmd_opts.add_option(cmdoptions.build_options())
 #elf.cmd_opts.add_option(cmdoptions.global_options())

 #elf.cmd_opts.add_option(
 #--pre",
 #ction="store_true",
 #efault=False,
 #elp=(
 #Include pre-release and development versions. By default, "
 #pip only finds stable versions."
 #,
 #

 #elf.cmd_opts.add_option(cmdoptions.require_hashes())

 #ndex_opts = cmdoptions.make_option_group(
 #mdoptions.index_group,
 #elf.parser,
 #

 #elf.parser.insert_option_group(0, index_opts)
 #elf.parser.insert_option_group(0, self.cmd_opts)

 #with_cleanup
 #ef run(self, options: Values, args: List[str]) -> int:
 #ession = self.get_default_session(options)

 #inder = self._build_package_finder(options, session)

 #ptions.wheel_dir = normalize_path(options.wheel_dir)
 #nsure_dir(options.wheel_dir)

 #uild_tracker = self.enter_context(get_build_tracker())

 #irectory = TempDirectory(
 #elete=not options.no_clean,
 #ind="wheel",
 #lobally_managed=True,
 #

 #eqs = self.get_requirements(args, options, finder, session)
 #heck_legacy_setup_py_options(options, reqs)

 #heel_cache = WheelCache(options.cache_dir)

 #reparer = self.make_requirement_preparer(
 #emp_build_dir=directory,
 #ptions=options,
 #uild_tracker=build_tracker,
 #ession=session,
 #inder=finder,
 #ownload_dir=options.wheel_dir,
 #se_user_site=False,
 #erbosity=self.verbosity,
 #

 #esolver = self.make_resolver(
 #reparer=preparer,
 #inder=finder,
 #ptions=options,
 #heel_cache=wheel_cache,
 #gnore_requires_python=options.ignore_requires_python,
 #se_pep517=options.use_pep517,
 #

 #elf.trace_basic_info(finder)

 #equirement_set = resolver.resolve(reqs, check_supported_wheels=True)

 #eqs_to_build: List[InstallRequirement] = []
 #or req in requirement_set.requirements.values():
 #f req.is_wheel:
 #reparer.save_linked_requirement(req)
 #lif should_build_for_wheel_command(req):
 #eqs_to_build.append(req)

 #reparer.prepare_linked_requirements_more(requirement_set.requirements.values())
 #equirement_set.warn_legacy_versions_and_specifiers()

        # build wheels
 #uild_successes, build_failures = build(
 #eqs_to_build,
 #heel_cache=wheel_cache,
 #erify=(not options.no_verify),
 #uild_options=options.build_options or [],
 #lobal_options=options.global_options or [],
 #
 #or req in build_successes:
 #ssert req.link and req.link.is_wheel
 #ssert req.local_file_path
            # copy from cache to target directory
 #ry:
 #hutil.copy(req.local_file_path, options.wheel_dir)
 #xcept OSError as e:
 #ogger.warning(
 #Building wheel for %s failed: %s",
 #eq.name,
 #,
 #
 #uild_failures.append(req)
 #f len(build_failures) != 0:
 #aise CommandError("Failed to build one or more wheels")

 #eturn SUCCESS
