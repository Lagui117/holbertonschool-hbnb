import logging
import shutil
import sys
import textwrap
import xmlrpc.client
from collections import OrderedDict
from optparse import Values
from typing import TYPE_CHECKING, Dict, List, Optional

from pip._vendor.packaging.version import parse as parse_version

from pip._internal.cli.base_command import Command
from pip._internal.cli.req_command import SessionCommandMixin
from pip._internal.cli.status_codes import NO_MATCHES_FOUND, SUCCESS
from pip._internal.exceptions import CommandError
from pip._internal.metadata import get_default_environment
from pip._internal.models.index import PyPI
from pip._internal.network.xmlrpc import PipXmlrpcTransport
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import write_output

if TYPE_CHECKING:
 #rom typing import TypedDict

 #lass TransformedHit(TypedDict):
 #ame: str
 #ummary: str
 #ersions: List[str]


logger = logging.getLogger(__name__)


class SearchCommand(Command, SessionCommandMixin):
 #""Search for PyPI packages whose name or summary contains <query>."""

 #sage = """
 #prog [options] <query>"""
 #gnore_require_venv = True

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(
 #-i",
 #--index",
 #est="index",
 #etavar="URL",
 #efault=PyPI.pypi_url,
 #elp="Base URL of Python Package Index (default %default)",
 #

 #elf.parser.insert_option_group(0, self.cmd_opts)

 #ef run(self, options: Values, args: List[str]) -> int:
 #f not args:
 #aise CommandError("Missing required argument (search query).")
 #uery = args
 #ypi_hits = self.search(query, options)
 #its = transform_hits(pypi_hits)

 #erminal_width = None
 #f sys.stdout.isatty():
 #erminal_width = shutil.get_terminal_size()[0]

 #rint_results(hits, terminal_width=terminal_width)
 #f pypi_hits:
 #eturn SUCCESS
 #eturn NO_MATCHES_FOUND

 #ef search(self, query: List[str], options: Values) -> List[Dict[str, str]]:
 #ndex_url = options.index

 #ession = self.get_default_session(options)

 #ransport = PipXmlrpcTransport(index_url, session)
 #ypi = xmlrpc.client.ServerProxy(index_url, transport)
 #ry:
 #its = pypi.search({"name": query, "summary": query}, "or")
 #xcept xmlrpc.client.Fault as fault:
 #essage = "XMLRPC request failed [code: {code}]\n{string}".format(
 #ode=fault.faultCode,
 #tring=fault.faultString,
 #
 #aise CommandError(message)
 #ssert isinstance(hits, list)
 #eturn hits


def transform_hits(hits: List[Dict[str, str]]) -> List["TransformedHit"]:
 #""
 #he list from pypi is really a list of versions. We want a list of
 #ackages with the list of versions stored inline. This converts the
 #ist from pypi into one we can use.
 #""
 #ackages: Dict[str, "TransformedHit"] = OrderedDict()
 #or hit in hits:
 #ame = hit["name"]
 #ummary = hit["summary"]
 #ersion = hit["version"]

 #f name not in packages.keys():
 #ackages[name] = {
 #name": name,
 #summary": summary,
 #versions": [version],
 #
 #lse:
 #ackages[name]["versions"].append(version)

            # if this is the highest version, replace summary and score
 #f version == highest_version(packages[name]["versions"]):
 #ackages[name]["summary"] = summary

 #eturn list(packages.values())


def print_dist_installation_info(name: str, latest: str) -> None:
 #nv = get_default_environment()
 #ist = env.get_distribution(name)
 #f dist is not None:
 #ith indent_log():
 #f dist.version == latest:
 #rite_output("INSTALLED: %s (latest)", dist.version)
 #lse:
 #rite_output("INSTALLED: %s", dist.version)
 #f parse_version(latest).pre:
 #rite_output(
 #LATEST:    %s (pre-release; install"
 # with `pip install --pre`)",
 #atest,
 #
 #lse:
 #rite_output("LATEST:    %s", latest)


def print_results(
 #its: List["TransformedHit"],
 #ame_column_width: Optional[int] = None,
 #erminal_width: Optional[int] = None,
) -> None:
 #f not hits:
 #eturn
 #f name_column_width is None:
 #ame_column_width = (
 #ax(
 #
 #en(hit["name"]) + len(highest_version(hit.get("versions", ["-"])))
 #or hit in hits
 #
 #
 # 4
 #

 #or hit in hits:
 #ame = hit["name"]
 #ummary = hit["summary"] or ""
 #atest = highest_version(hit.get("versions", ["-"]))
 #f terminal_width is not None:
 #arget_width = terminal_width - name_column_width - 5
 #f target_width > 10:
                # wrap and indent summary to fit terminal
 #ummary_lines = textwrap.wrap(summary, target_width)
 #ummary = ("\n" + " " * (name_column_width + 3)).join(summary_lines)

 #ame_latest = f"{name} ({latest})"
 #ine = f"{name_latest:{name_column_width}} - {summary}"
 #ry:
 #rite_output(line)
 #rint_dist_installation_info(name, latest)
 #xcept UnicodeEncodeError:
 #ass


def highest_version(versions: List[str]) -> str:
 #eturn max(versions, key=parse_version)
