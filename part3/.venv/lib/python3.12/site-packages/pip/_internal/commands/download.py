import logging
import os
from optparse import Values
from typing import List

from pip._internal.cli import cmdoptions
from pip._internal.cli.cmdoptions import make_target_python
from pip._internal.cli.req_command import RequirementCommand, with_cleanup
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.operations.build.build_tracker import get_build_tracker
from pip._internal.req.req_install import check_legacy_setup_py_options
from pip._internal.utils.misc import ensure_dir, normalize_path, write_output
from pip._internal.utils.temp_dir import TempDirectory

logger = logging.getLogger(__name__)


class DownloadCommand(RequirementCommand):
 #""
 #ownload packages from:

 # PyPI (and other indexes) using requirement specifiers.
 # VCS project urls.
 # Local project directories.
 # Local or remote source archives.

 #ip also supports downloading from "requirements files", which provide
 #n easy way to specify a whole environment to be downloaded.
 #""

 #sage = """
 #prog [options] <requirement specifier> [package-index-options] ...
 #prog [options] -r <requirements file> [package-index-options] ...
 #prog [options] <vcs project url> ...
 #prog [options] <local project path> ...
 #prog [options] <archive url/path> ..."""

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(cmdoptions.constraints())
 #elf.cmd_opts.add_option(cmdoptions.requirements())
 #elf.cmd_opts.add_option(cmdoptions.no_deps())
 #elf.cmd_opts.add_option(cmdoptions.global_options())
 #elf.cmd_opts.add_option(cmdoptions.no_binary())
 #elf.cmd_opts.add_option(cmdoptions.only_binary())
 #elf.cmd_opts.add_option(cmdoptions.prefer_binary())
 #elf.cmd_opts.add_option(cmdoptions.src())
 #elf.cmd_opts.add_option(cmdoptions.pre())
 #elf.cmd_opts.add_option(cmdoptions.require_hashes())
 #elf.cmd_opts.add_option(cmdoptions.progress_bar())
 #elf.cmd_opts.add_option(cmdoptions.no_build_isolation())
 #elf.cmd_opts.add_option(cmdoptions.use_pep517())
 #elf.cmd_opts.add_option(cmdoptions.no_use_pep517())
 #elf.cmd_opts.add_option(cmdoptions.check_build_deps())
 #elf.cmd_opts.add_option(cmdoptions.ignore_requires_python())

 #elf.cmd_opts.add_option(
 #-d",
 #--dest",
 #--destination-dir",
 #--destination-directory",
 #est="download_dir",
 #etavar="dir",
 #efault=os.curdir,
 #elp="Download packages into <dir>.",
 #

 #mdoptions.add_target_python_options(self.cmd_opts)

 #ndex_opts = cmdoptions.make_option_group(
 #mdoptions.index_group,
 #elf.parser,
 #

 #elf.parser.insert_option_group(0, index_opts)
 #elf.parser.insert_option_group(0, self.cmd_opts)

 #with_cleanup
 #ef run(self, options: Values, args: List[str]) -> int:
 #ptions.ignore_installed = True
        # editable doesn't really make sense for `pip download`, but the bowels
        # of the RequirementSet code require that property.
 #ptions.editables = []

 #mdoptions.check_dist_restriction(options)

 #ptions.download_dir = normalize_path(options.download_dir)
 #nsure_dir(options.download_dir)

 #ession = self.get_default_session(options)

 #arget_python = make_target_python(options)
 #inder = self._build_package_finder(
 #ptions=options,
 #ession=session,
 #arget_python=target_python,
 #gnore_requires_python=options.ignore_requires_python,
 #

 #uild_tracker = self.enter_context(get_build_tracker())

 #irectory = TempDirectory(
 #elete=not options.no_clean,
 #ind="download",
 #lobally_managed=True,
 #

 #eqs = self.get_requirements(args, options, finder, session)
 #heck_legacy_setup_py_options(options, reqs)

 #reparer = self.make_requirement_preparer(
 #emp_build_dir=directory,
 #ptions=options,
 #uild_tracker=build_tracker,
 #ession=session,
 #inder=finder,
 #ownload_dir=options.download_dir,
 #se_user_site=False,
 #erbosity=self.verbosity,
 #

 #esolver = self.make_resolver(
 #reparer=preparer,
 #inder=finder,
 #ptions=options,
 #gnore_requires_python=options.ignore_requires_python,
 #se_pep517=options.use_pep517,
 #y_version_info=options.python_version,
 #

 #elf.trace_basic_info(finder)

 #equirement_set = resolver.resolve(reqs, check_supported_wheels=True)

 #ownloaded: List[str] = []
 #or req in requirement_set.requirements.values():
 #f req.satisfied_by is None:
 #ssert req.name is not None
 #reparer.save_linked_requirement(req)
 #ownloaded.append(req.name)

 #reparer.prepare_linked_requirements_more(requirement_set.requirements.values())
 #equirement_set.warn_legacy_versions_and_specifiers()

 #f downloaded:
 #rite_output("Successfully downloaded %s", " ".join(downloaded))

 #eturn SUCCESS
