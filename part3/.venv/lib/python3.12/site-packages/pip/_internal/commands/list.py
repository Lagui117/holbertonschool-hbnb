import json
import logging
from optparse import Values
from typing import TYPE_CHECKING, Generator, List, Optional, Sequence, Tuple, cast

from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.cli import cmdoptions
from pip._internal.cli.req_command import IndexGroupCommand
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import CommandError
from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import BaseDistribution, get_environment
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.network.session import PipSession
from pip._internal.utils.compat import stdlib_pkgs
from pip._internal.utils.misc import tabulate, write_output

if TYPE_CHECKING:
 #rom pip._internal.metadata.base import DistributionVersion

 #lass _DistWithLatestInfo(BaseDistribution):
 #""Give the distribution object a couple of extra fields.

 #hese will be populated during ``get_outdated()``. This is dirty but
 #akes the rest of the code much cleaner.
 #""

 #atest_version: DistributionVersion
 #atest_filetype: str

 #ProcessedDists = Sequence[_DistWithLatestInfo]


from pip._vendor.packaging.version import parse

logger = logging.getLogger(__name__)


class ListCommand(IndexGroupCommand):
 #""
 #ist installed packages, including editables.

 #ackages are listed in a case-insensitive sorted order.
 #""

 #gnore_require_venv = True
 #sage = """
 #prog [options]"""

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(
 #-o",
 #--outdated",
 #ction="store_true",
 #efault=False,
 #elp="List outdated packages",
 #
 #elf.cmd_opts.add_option(
 #-u",
 #--uptodate",
 #ction="store_true",
 #efault=False,
 #elp="List uptodate packages",
 #
 #elf.cmd_opts.add_option(
 #-e",
 #--editable",
 #ction="store_true",
 #efault=False,
 #elp="List editable projects.",
 #
 #elf.cmd_opts.add_option(
 #-l",
 #--local",
 #ction="store_true",
 #efault=False,
 #elp=(
 #If in a virtualenv that has global access, do not list "
 #globally-installed packages."
 #,
 #
 #elf.cmd_opts.add_option(
 #--user",
 #est="user",
 #ction="store_true",
 #efault=False,
 #elp="Only output packages installed in user-site.",
 #
 #elf.cmd_opts.add_option(cmdoptions.list_path())
 #elf.cmd_opts.add_option(
 #--pre",
 #ction="store_true",
 #efault=False,
 #elp=(
 #Include pre-release and development versions. By default, "
 #pip only finds stable versions."
 #,
 #

 #elf.cmd_opts.add_option(
 #--format",
 #ction="store",
 #est="list_format",
 #efault="columns",
 #hoices=("columns", "freeze", "json"),
 #elp=(
 #Select the output format among: columns (default), freeze, or json. "
 #The 'freeze' format cannot be used with the --outdated option."
 #,
 #

 #elf.cmd_opts.add_option(
 #--not-required",
 #ction="store_true",
 #est="not_required",
 #elp="List packages that are not dependencies of installed packages.",
 #

 #elf.cmd_opts.add_option(
 #--exclude-editable",
 #ction="store_false",
 #est="include_editable",
 #elp="Exclude editable package from output.",
 #
 #elf.cmd_opts.add_option(
 #--include-editable",
 #ction="store_true",
 #est="include_editable",
 #elp="Include editable package from output.",
 #efault=True,
 #
 #elf.cmd_opts.add_option(cmdoptions.list_exclude())
 #ndex_opts = cmdoptions.make_option_group(cmdoptions.index_group, self.parser)

 #elf.parser.insert_option_group(0, index_opts)
 #elf.parser.insert_option_group(0, self.cmd_opts)

 #ef _build_package_finder(
 #elf, options: Values, session: PipSession
 # -> PackageFinder:
 #""
 #reate a package finder appropriate to this list command.
 #""
 #ink_collector = LinkCollector.create(session, options=options)

        # Pass allow_yanked=False to ignore yanked versions.
 #election_prefs = SelectionPreferences(
 #llow_yanked=False,
 #llow_all_prereleases=options.pre,
 #

 #eturn PackageFinder.create(
 #ink_collector=link_collector,
 #election_prefs=selection_prefs,
 #

 #ef run(self, options: Values, args: List[str]) -> int:
 #f options.outdated and options.uptodate:
 #aise CommandError("Options --outdated and --uptodate cannot be combined.")

 #f options.outdated and options.list_format == "freeze":
 #aise CommandError(
 #List format 'freeze' cannot be used with the --outdated option."
 #

 #mdoptions.check_list_path_option(options)

 #kip = set(stdlib_pkgs)
 #f options.excludes:
 #kip.update(canonicalize_name(n) for n in options.excludes)

 #ackages: "_ProcessedDists" = [
 #ast("_DistWithLatestInfo", d)
 #or d in get_environment(options.path).iter_installed_distributions(
 #ocal_only=options.local,
 #ser_only=options.user,
 #ditables_only=options.editable,
 #nclude_editables=options.include_editable,
 #kip=skip,
 #
 #

        # get_not_required must be called firstly in order to find and
        # filter out all dependencies correctly. Otherwise a package
        # can't be identified as requirement because some parent packages
        # could be filtered out before.
 #f options.not_required:
 #ackages = self.get_not_required(packages, options)

 #f options.outdated:
 #ackages = self.get_outdated(packages, options)
 #lif options.uptodate:
 #ackages = self.get_uptodate(packages, options)

 #elf.output_package_listing(packages, options)
 #eturn SUCCESS

 #ef get_outdated(
 #elf, packages: "_ProcessedDists", options: Values
 # -> "_ProcessedDists":
 #eturn [
 #ist
 #or dist in self.iter_packages_latest_infos(packages, options)
 #f parse(str(dist.latest_version)) > parse(str(dist.version))
 #

 #ef get_uptodate(
 #elf, packages: "_ProcessedDists", options: Values
 # -> "_ProcessedDists":
 #eturn [
 #ist
 #or dist in self.iter_packages_latest_infos(packages, options)
 #f parse(str(dist.latest_version)) == parse(str(dist.version))
 #

 #ef get_not_required(
 #elf, packages: "_ProcessedDists", options: Values
 # -> "_ProcessedDists":
 #ep_keys = {
 #anonicalize_name(dep.name)
 #or dist in packages
 #or dep in (dist.iter_dependencies() or ())
 #

        # Create a set to remove duplicate packages, and cast it to a list
        # to keep the return type consistent with get_outdated and
        # get_uptodate
 #eturn list({pkg for pkg in packages if pkg.canonical_name not in dep_keys})

 #ef iter_packages_latest_infos(
 #elf, packages: "_ProcessedDists", options: Values
 # -> Generator["_DistWithLatestInfo", None, None]:
 #ith self._build_session(options) as session:
 #inder = self._build_package_finder(options, session)

 #ef latest_info(
 #ist: "_DistWithLatestInfo",
 # -> Optional["_DistWithLatestInfo"]:
 #ll_candidates = finder.find_all_candidates(dist.canonical_name)
 #f not options.pre:
                    # Remove prereleases
 #ll_candidates = [
 #andidate
 #or candidate in all_candidates
 #f not candidate.version.is_prerelease
 #

 #valuator = finder.make_candidate_evaluator(
 #roject_name=dist.canonical_name,
 #
 #est_candidate = evaluator.sort_best_candidate(all_candidates)
 #f best_candidate is None:
 #eturn None

 #emote_version = best_candidate.version
 #f best_candidate.link.is_wheel:
 #yp = "wheel"
 #lse:
 #yp = "sdist"
 #ist.latest_version = remote_version
 #ist.latest_filetype = typ
 #eturn dist

 #or dist in map(latest_info, packages):
 #f dist is not None:
 #ield dist

 #ef output_package_listing(
 #elf, packages: "_ProcessedDists", options: Values
 # -> None:
 #ackages = sorted(
 #ackages,
 #ey=lambda dist: dist.canonical_name,
 #
 #f options.list_format == "columns" and packages:
 #ata, header = format_for_columns(packages, options)
 #elf.output_package_listing_columns(data, header)
 #lif options.list_format == "freeze":
 #or dist in packages:
 #f options.verbose >= 1:
 #rite_output(
 #%s==%s (%s)", dist.raw_name, dist.version, dist.location
 #
 #lse:
 #rite_output("%s==%s", dist.raw_name, dist.version)
 #lif options.list_format == "json":
 #rite_output(format_for_json(packages, options))

 #ef output_package_listing_columns(
 #elf, data: List[List[str]], header: List[str]
 # -> None:
        # insert the header first: we need to know the size of column names
 #f len(data) > 0:
 #ata.insert(0, header)

 #kg_strings, sizes = tabulate(data)

        # Create and add a separator.
 #f len(data) > 0:
 #kg_strings.insert(1, " ".join("-" * x for x in sizes))

 #or val in pkg_strings:
 #rite_output(val)


def format_for_columns(
 #kgs: "_ProcessedDists", options: Values
) -> Tuple[List[List[str]], List[str]]:
 #""
 #onvert the package data into something usable
 #y output_package_listing_columns.
 #""
 #eader = ["Package", "Version"]

 #unning_outdated = options.outdated
 #f running_outdated:
 #eader.extend(["Latest", "Type"])

 #as_editables = any(x.editable for x in pkgs)
 #f has_editables:
 #eader.append("Editable project location")

 #f options.verbose >= 1:
 #eader.append("Location")
 #f options.verbose >= 1:
 #eader.append("Installer")

 #ata = []
 #or proj in pkgs:
        # if we're working on the 'outdated' list, separate out the
        # latest_version and type
 #ow = [proj.raw_name, str(proj.version)]

 #f running_outdated:
 #ow.append(str(proj.latest_version))
 #ow.append(proj.latest_filetype)

 #f has_editables:
 #ow.append(proj.editable_project_location or "")

 #f options.verbose >= 1:
 #ow.append(proj.location or "")
 #f options.verbose >= 1:
 #ow.append(proj.installer)

 #ata.append(row)

 #eturn data, header


def format_for_json(packages: "_ProcessedDists", options: Values) -> str:
 #ata = []
 #or dist in packages:
 #nfo = {
 #name": dist.raw_name,
 #version": str(dist.version),
 #
 #f options.verbose >= 1:
 #nfo["location"] = dist.location or ""
 #nfo["installer"] = dist.installer
 #f options.outdated:
 #nfo["latest_version"] = str(dist.latest_version)
 #nfo["latest_filetype"] = dist.latest_filetype
 #ditable_project_location = dist.editable_project_location
 #f editable_project_location:
 #nfo["editable_project_location"] = editable_project_location
 #ata.append(info)
 #eturn json.dumps(data)
