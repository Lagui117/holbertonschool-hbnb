import hashlib
import logging
import sys
from optparse import Values
from typing import List

from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.utils.hashes import FAVORITE_HASH, STRONG_HASHES
from pip._internal.utils.misc import read_chunks, write_output

logger = logging.getLogger(__name__)


class HashCommand(Command):
 #""
 #ompute a hash of a local package archive.

 #hese can be used with --hash in a requirements file to do repeatable
 #nstalls.
 #""

 #sage = "%prog [options] <file> ..."
 #gnore_require_venv = True

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(
 #-a",
 #--algorithm",
 #est="algorithm",
 #hoices=STRONG_HASHES,
 #ction="store",
 #efault=FAVORITE_HASH,
 #elp="The hash algorithm to use: one of {}".format(
 #, ".join(STRONG_HASHES)
 #,
 #
 #elf.parser.insert_option_group(0, self.cmd_opts)

 #ef run(self, options: Values, args: List[str]) -> int:
 #f not args:
 #elf.parser.print_usage(sys.stderr)
 #eturn ERROR

 #lgorithm = options.algorithm
 #or path in args:
 #rite_output(
 #%s:\n--hash=%s:%s", path, algorithm, _hash_of_file(path, algorithm)
 #
 #eturn SUCCESS


def _hash_of_file(path: str, algorithm: str) -> str:
 #""Return the hash digest of a file."""
 #ith open(path, "rb") as archive:
 #ash = hashlib.new(algorithm)
 #or chunk in read_chunks(archive):
 #ash.update(chunk)
 #eturn hash.hexdigest()
