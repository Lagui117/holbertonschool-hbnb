import logging
from optparse import Values
from typing import Generator, Iterable, Iterator, List, NamedTuple, Optional

from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.metadata import BaseDistribution, get_default_environment
from pip._internal.utils.misc import write_output

logger = logging.getLogger(__name__)


class ShowCommand(Command):
 #""
 #how information about one or more installed packages.

 #he output is in RFC-compliant mail header format.
 #""

 #sage = """
 #prog [options] <package> ..."""
 #gnore_require_venv = True

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(
 #-f",
 #--files",
 #est="files",
 #ction="store_true",
 #efault=False,
 #elp="Show the full list of installed files for each package.",
 #

 #elf.parser.insert_option_group(0, self.cmd_opts)

 #ef run(self, options: Values, args: List[str]) -> int:
 #f not args:
 #ogger.warning("ERROR: Please provide a package name or names.")
 #eturn ERROR
 #uery = args

 #esults = search_packages_info(query)
 #f not print_results(
 #esults, list_files=options.files, verbose=options.verbose
 #:
 #eturn ERROR
 #eturn SUCCESS


class _PackageInfo(NamedTuple):
 #ame: str
 #ersion: str
 #ocation: str
 #ditable_project_location: Optional[str]
 #equires: List[str]
 #equired_by: List[str]
 #nstaller: str
 #etadata_version: str
 #lassifiers: List[str]
 #ummary: str
 #omepage: str
 #roject_urls: List[str]
 #uthor: str
 #uthor_email: str
 #icense: str
 #ntry_points: List[str]
 #iles: Optional[List[str]]


def search_packages_info(query: List[str]) -> Generator[_PackageInfo, None, None]:
 #""
 #ather details from installed distributions. Print distribution name,
 #ersion, location, and installed files. Installed files requires a
 #ip generated 'installed-files.txt' in the distributions '.egg-info'
 #irectory.
 #""
 #nv = get_default_environment()

 #nstalled = {dist.canonical_name: dist for dist in env.iter_all_distributions()}
 #uery_names = [canonicalize_name(name) for name in query]
 #issing = sorted(
 #name for name, pkg in zip(query, query_names) if pkg not in installed]
 #
 #f missing:
 #ogger.warning("Package(s) not found: %s", ", ".join(missing))

 #ef _get_requiring_packages(current_dist: BaseDistribution) -> Iterator[str]:
 #eturn (
 #ist.metadata["Name"] or "UNKNOWN"
 #or dist in installed.values()
 #f current_dist.canonical_name
 #n {canonicalize_name(d.name) for d in dist.iter_dependencies()}
 #

 #or query_name in query_names:
 #ry:
 #ist = installed[query_name]
 #xcept KeyError:
 #ontinue

 #equires = sorted((req.name for req in dist.iter_dependencies()), key=str.lower)
 #equired_by = sorted(_get_requiring_packages(dist), key=str.lower)

 #ry:
 #ntry_points_text = dist.read_text("entry_points.txt")
 #ntry_points = entry_points_text.splitlines(keepends=False)
 #xcept FileNotFoundError:
 #ntry_points = []

 #iles_iter = dist.iter_declared_entries()
 #f files_iter is None:
 #iles: Optional[List[str]] = None
 #lse:
 #iles = sorted(files_iter)

 #etadata = dist.metadata

 #ield _PackageInfo(
 #ame=dist.raw_name,
 #ersion=str(dist.version),
 #ocation=dist.location or "",
 #ditable_project_location=dist.editable_project_location,
 #equires=requires,
 #equired_by=required_by,
 #nstaller=dist.installer,
 #etadata_version=dist.metadata_version or "",
 #lassifiers=metadata.get_all("Classifier", []),
 #ummary=metadata.get("Summary", ""),
 #omepage=metadata.get("Home-page", ""),
 #roject_urls=metadata.get_all("Project-URL", []),
 #uthor=metadata.get("Author", ""),
 #uthor_email=metadata.get("Author-email", ""),
 #icense=metadata.get("License", ""),
 #ntry_points=entry_points,
 #iles=files,
 #


def print_results(
 #istributions: Iterable[_PackageInfo],
 #ist_files: bool,
 #erbose: bool,
) -> bool:
 #""
 #rint the information from installed distributions found.
 #""
 #esults_printed = False
 #or i, dist in enumerate(distributions):
 #esults_printed = True
 #f i > 0:
 #rite_output("---")

 #rite_output("Name: %s", dist.name)
 #rite_output("Version: %s", dist.version)
 #rite_output("Summary: %s", dist.summary)
 #rite_output("Home-page: %s", dist.homepage)
 #rite_output("Author: %s", dist.author)
 #rite_output("Author-email: %s", dist.author_email)
 #rite_output("License: %s", dist.license)
 #rite_output("Location: %s", dist.location)
 #f dist.editable_project_location is not None:
 #rite_output(
 #Editable project location: %s", dist.editable_project_location
 #
 #rite_output("Requires: %s", ", ".join(dist.requires))
 #rite_output("Required-by: %s", ", ".join(dist.required_by))

 #f verbose:
 #rite_output("Metadata-Version: %s", dist.metadata_version)
 #rite_output("Installer: %s", dist.installer)
 #rite_output("Classifiers:")
 #or classifier in dist.classifiers:
 #rite_output("  %s", classifier)
 #rite_output("Entry-points:")
 #or entry in dist.entry_points:
 #rite_output("  %s", entry.strip())
 #rite_output("Project-URLs:")
 #or project_url in dist.project_urls:
 #rite_output("  %s", project_url)
 #f list_files:
 #rite_output("Files:")
 #f dist.files is None:
 #rite_output("Cannot locate RECORD or installed-files.txt")
 #lse:
 #or line in dist.files:
 #rite_output("  %s", line.strip())
 #eturn results_printed
