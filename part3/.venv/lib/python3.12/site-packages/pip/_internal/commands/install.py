import errno
import json
import operator
import os
import shutil
import site
from optparse import SUPPRESS_HELP, Values
from typing import List, Optional

from pip._vendor.rich import print_json

from pip._internal.cache import WheelCache
from pip._internal.cli import cmdoptions
from pip._internal.cli.cmdoptions import make_target_python
from pip._internal.cli.req_command import (
 #equirementCommand,
 #arn_if_run_as_root,
 #ith_cleanup,
)
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.exceptions import CommandError, InstallationError
from pip._internal.locations import get_scheme
from pip._internal.metadata import get_environment
from pip._internal.models.installation_report import InstallationReport
from pip._internal.operations.build.build_tracker import get_build_tracker
from pip._internal.operations.check import ConflictDetails, check_install_conflicts
from pip._internal.req import install_given_reqs
from pip._internal.req.req_install import (
 #nstallRequirement,
 #heck_legacy_setup_py_options,
)
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.filesystem import test_writable_dir
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import (
 #heck_externally_managed,
 #nsure_dir,
 #et_pip_version,
 #rotect_pip_from_modification_on_windows,
 #rite_output,
)
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.virtualenv import (
 #unning_under_virtualenv,
 #irtualenv_no_global,
)
from pip._internal.wheel_builder import build, should_build_for_install_command

logger = getLogger(__name__)


class InstallCommand(RequirementCommand):
 #""
 #nstall packages from:

 # PyPI (and other indexes) using requirement specifiers.
 # VCS project urls.
 # Local project directories.
 # Local or remote source archives.

 #ip also supports installing from "requirements files", which provide
 #n easy way to specify a whole environment to be installed.
 #""

 #sage = """
 #prog [options] <requirement specifier> [package-index-options] ...
 #prog [options] -r <requirements file> [package-index-options] ...
 #prog [options] [-e] <vcs project url> ...
 #prog [options] [-e] <local project path> ...
 #prog [options] <archive url/path> ..."""

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(cmdoptions.requirements())
 #elf.cmd_opts.add_option(cmdoptions.constraints())
 #elf.cmd_opts.add_option(cmdoptions.no_deps())
 #elf.cmd_opts.add_option(cmdoptions.pre())

 #elf.cmd_opts.add_option(cmdoptions.editable())
 #elf.cmd_opts.add_option(
 #--dry-run",
 #ction="store_true",
 #est="dry_run",
 #efault=False,
 #elp=(
 #Don't actually install anything, just print what would be. "
 #Can be used in combination with --ignore-installed "
 #to 'resolve' the requirements."
 #,
 #
 #elf.cmd_opts.add_option(
 #-t",
 #--target",
 #est="target_dir",
 #etavar="dir",
 #efault=None,
 #elp=(
 #Install packages into <dir>. "
 #By default this will not replace existing files/folders in "
 #<dir>. Use --upgrade to replace existing packages in <dir> "
 #with new versions."
 #,
 #
 #mdoptions.add_target_python_options(self.cmd_opts)

 #elf.cmd_opts.add_option(
 #--user",
 #est="use_user_site",
 #ction="store_true",
 #elp=(
 #Install to the Python user install directory for your "
 #platform. Typically ~/.local/, or %APPDATA%\\Python on "
 #Windows. (See the Python documentation for site.USER_BASE "
 #for full details.)"
 #,
 #
 #elf.cmd_opts.add_option(
 #--no-user",
 #est="use_user_site",
 #ction="store_false",
 #elp=SUPPRESS_HELP,
 #
 #elf.cmd_opts.add_option(
 #--root",
 #est="root_path",
 #etavar="dir",
 #efault=None,
 #elp="Install everything relative to this alternate root directory.",
 #
 #elf.cmd_opts.add_option(
 #--prefix",
 #est="prefix_path",
 #etavar="dir",
 #efault=None,
 #elp=(
 #Installation prefix where lib, bin and other top-level "
 #folders are placed. Note that the resulting installation may "
 #contain scripts and other resources which reference the "
 #Python interpreter of pip, and not that of ``--prefix``. "
 #See also the ``--python`` option if the intention is to "
 #install packages into another (possibly pip-free) "
 #environment."
 #,
 #

 #elf.cmd_opts.add_option(cmdoptions.src())

 #elf.cmd_opts.add_option(
 #-U",
 #--upgrade",
 #est="upgrade",
 #ction="store_true",
 #elp=(
 #Upgrade all specified packages to the newest available "
 #version. The handling of dependencies depends on the "
 #upgrade-strategy used."
 #,
 #

 #elf.cmd_opts.add_option(
 #--upgrade-strategy",
 #est="upgrade_strategy",
 #efault="only-if-needed",
 #hoices=["only-if-needed", "eager"],
 #elp=(
 #Determines how dependency upgrading should be handled "
 #[default: %default]. "
 #"eager" - dependencies are upgraded regardless of '
 #whether the currently installed version satisfies the "
 #requirements of the upgraded package(s). "
 #"only-if-needed" -  are upgraded only when they do not '
 #satisfy the requirements of the upgraded package(s)."
 #,
 #

 #elf.cmd_opts.add_option(
 #--force-reinstall",
 #est="force_reinstall",
 #ction="store_true",
 #elp="Reinstall all packages even if they are already up-to-date.",
 #

 #elf.cmd_opts.add_option(
 #-I",
 #--ignore-installed",
 #est="ignore_installed",
 #ction="store_true",
 #elp=(
 #Ignore the installed packages, overwriting them. "
 #This can break your system if the existing package "
 #is of a different version or was installed "
 #with a different package manager!"
 #,
 #

 #elf.cmd_opts.add_option(cmdoptions.ignore_requires_python())
 #elf.cmd_opts.add_option(cmdoptions.no_build_isolation())
 #elf.cmd_opts.add_option(cmdoptions.use_pep517())
 #elf.cmd_opts.add_option(cmdoptions.no_use_pep517())
 #elf.cmd_opts.add_option(cmdoptions.check_build_deps())
 #elf.cmd_opts.add_option(cmdoptions.override_externally_managed())

 #elf.cmd_opts.add_option(cmdoptions.config_settings())
 #elf.cmd_opts.add_option(cmdoptions.global_options())

 #elf.cmd_opts.add_option(
 #--compile",
 #ction="store_true",
 #est="compile",
 #efault=True,
 #elp="Compile Python source files to bytecode",
 #

 #elf.cmd_opts.add_option(
 #--no-compile",
 #ction="store_false",
 #est="compile",
 #elp="Do not compile Python source files to bytecode",
 #

 #elf.cmd_opts.add_option(
 #--no-warn-script-location",
 #ction="store_false",
 #est="warn_script_location",
 #efault=True,
 #elp="Do not warn when installing scripts outside PATH",
 #
 #elf.cmd_opts.add_option(
 #--no-warn-conflicts",
 #ction="store_false",
 #est="warn_about_conflicts",
 #efault=True,
 #elp="Do not warn about broken dependencies",
 #
 #elf.cmd_opts.add_option(cmdoptions.no_binary())
 #elf.cmd_opts.add_option(cmdoptions.only_binary())
 #elf.cmd_opts.add_option(cmdoptions.prefer_binary())
 #elf.cmd_opts.add_option(cmdoptions.require_hashes())
 #elf.cmd_opts.add_option(cmdoptions.progress_bar())
 #elf.cmd_opts.add_option(cmdoptions.root_user_action())

 #ndex_opts = cmdoptions.make_option_group(
 #mdoptions.index_group,
 #elf.parser,
 #

 #elf.parser.insert_option_group(0, index_opts)
 #elf.parser.insert_option_group(0, self.cmd_opts)

 #elf.cmd_opts.add_option(
 #--report",
 #est="json_report_file",
 #etavar="file",
 #efault=None,
 #elp=(
 #Generate a JSON file describing what pip did to install "
 #the provided requirements. "
 #Can be used in combination with --dry-run and --ignore-installed "
 #to 'resolve' the requirements. "
 #When - is used as file name it writes to stdout. "
 #When writing to stdout, please combine with the --quiet option "
 #to avoid mixing pip logging output with JSON output."
 #,
 #

 #with_cleanup
 #ef run(self, options: Values, args: List[str]) -> int:
 #f options.use_user_site and options.target_dir is not None:
 #aise CommandError("Can not combine '--user' and '--target'")

        # Check whether the environment we're installing into is externally
        # managed, as specified in PEP 668. Specifying --root, --target, or
        # --prefix disables the check, since there's no reliable way to locate
        # the EXTERNALLY-MANAGED file for those cases. An exception is also
        # made specifically for "--dry-run --report" for convenience.
 #nstalling_into_current_environment = (
 #ot (options.dry_run and options.json_report_file)
 #nd options.root_path is None
 #nd options.target_dir is None
 #nd options.prefix_path is None
 #
 #f (
 #nstalling_into_current_environment
 #nd not options.override_externally_managed
 #:
 #heck_externally_managed()

 #pgrade_strategy = "to-satisfy-only"
 #f options.upgrade:
 #pgrade_strategy = options.upgrade_strategy

 #mdoptions.check_dist_restriction(options, check_target=True)

 #ogger.verbose("Using %s", get_pip_version())
 #ptions.use_user_site = decide_user_install(
 #ptions.use_user_site,
 #refix_path=options.prefix_path,
 #arget_dir=options.target_dir,
 #oot_path=options.root_path,
 #solated_mode=options.isolated_mode,
 #

 #arget_temp_dir: Optional[TempDirectory] = None
 #arget_temp_dir_path: Optional[str] = None
 #f options.target_dir:
 #ptions.ignore_installed = True
 #ptions.target_dir = os.path.abspath(options.target_dir)
 #f (
                # fmt: off
 #s.path.exists(options.target_dir) and
 #ot os.path.isdir(options.target_dir)
                # fmt: on
 #:
 #aise CommandError(
 #Target path exists but is not a directory, will not continue."
 #

            # Create a target directory for using with the target option
 #arget_temp_dir = TempDirectory(kind="target")
 #arget_temp_dir_path = target_temp_dir.path
 #elf.enter_context(target_temp_dir)

 #lobal_options = options.global_options or []

 #ession = self.get_default_session(options)

 #arget_python = make_target_python(options)
 #inder = self._build_package_finder(
 #ptions=options,
 #ession=session,
 #arget_python=target_python,
 #gnore_requires_python=options.ignore_requires_python,
 #
 #uild_tracker = self.enter_context(get_build_tracker())

 #irectory = TempDirectory(
 #elete=not options.no_clean,
 #ind="install",
 #lobally_managed=True,
 #

 #ry:
 #eqs = self.get_requirements(args, options, finder, session)
 #heck_legacy_setup_py_options(options, reqs)

 #heel_cache = WheelCache(options.cache_dir)

            # Only when installing is it permitted to use PEP 660.
            # In other circumstances (pip wheel, pip download) we generate
            # regular (i.e. non editable) metadata and wheels.
 #or req in reqs:
 #eq.permit_editable_wheels = True

 #reparer = self.make_requirement_preparer(
 #emp_build_dir=directory,
 #ptions=options,
 #uild_tracker=build_tracker,
 #ession=session,
 #inder=finder,
 #se_user_site=options.use_user_site,
 #erbosity=self.verbosity,
 #
 #esolver = self.make_resolver(
 #reparer=preparer,
 #inder=finder,
 #ptions=options,
 #heel_cache=wheel_cache,
 #se_user_site=options.use_user_site,
 #gnore_installed=options.ignore_installed,
 #gnore_requires_python=options.ignore_requires_python,
 #orce_reinstall=options.force_reinstall,
 #pgrade_strategy=upgrade_strategy,
 #se_pep517=options.use_pep517,
 #

 #elf.trace_basic_info(finder)

 #equirement_set = resolver.resolve(
 #eqs, check_supported_wheels=not options.target_dir
 #

 #f options.json_report_file:
 #eport = InstallationReport(requirement_set.requirements_to_install)
 #f options.json_report_file == "-":
 #rint_json(data=report.to_dict())
 #lse:
 #ith open(options.json_report_file, "w", encoding="utf-8") as f:
 #son.dump(report.to_dict(), f, indent=2, ensure_ascii=False)

 #f options.dry_run:
                # In non dry-run mode, the legacy versions and specifiers check
                # will be done as part of conflict detection.
 #equirement_set.warn_legacy_versions_and_specifiers()
 #ould_install_items = sorted(
 #r.metadata["name"], r.metadata["version"])
 #or r in requirement_set.requirements_to_install
 #
 #f would_install_items:
 #rite_output(
 #Would install %s",
 # ".join("-".join(item) for item in would_install_items),
 #
 #eturn SUCCESS

 #ry:
 #ip_req = requirement_set.get_requirement("pip")
 #xcept KeyError:
 #odifying_pip = False
 #lse:
                # If we're not replacing an already installed pip,
                # we're not modifying it.
 #odifying_pip = pip_req.satisfied_by is None
 #rotect_pip_from_modification_on_windows(modifying_pip=modifying_pip)

 #eqs_to_build = [
 #
 #or r in requirement_set.requirements.values()
 #f should_build_for_install_command(r)
 #

 #, build_failures = build(
 #eqs_to_build,
 #heel_cache=wheel_cache,
 #erify=True,
 #uild_options=[],
 #lobal_options=global_options,
 #

 #f build_failures:
 #aise InstallationError(
 #Could not build wheels for {}, which is required to "
 #install pyproject.toml-based projects".format(
 #, ".join(r.name for r in build_failures)  # type: ignore
 #
 #

 #o_install = resolver.get_installation_order(requirement_set)

            # Check for conflicts in the package set we're installing.
 #onflicts: Optional[ConflictDetails] = None
 #hould_warn_about_conflicts = (
 #ot options.ignore_dependencies and options.warn_about_conflicts
 #
 #f should_warn_about_conflicts:
 #onflicts = self._determine_conflicts(to_install)

            # Don't warn about script install locations if
            # --target or --prefix has been specified
 #arn_script_location = options.warn_script_location
 #f options.target_dir or options.prefix_path:
 #arn_script_location = False

 #nstalled = install_given_reqs(
 #o_install,
 #lobal_options,
 #oot=options.root_path,
 #ome=target_temp_dir_path,
 #refix=options.prefix_path,
 #arn_script_location=warn_script_location,
 #se_user_site=options.use_user_site,
 #ycompile=options.compile,
 #

 #ib_locations = get_lib_location_guesses(
 #ser=options.use_user_site,
 #ome=target_temp_dir_path,
 #oot=options.root_path,
 #refix=options.prefix_path,
 #solated=options.isolated_mode,
 #
 #nv = get_environment(lib_locations)

 #nstalled.sort(key=operator.attrgetter("name"))
 #tems = []
 #or result in installed:
 #tem = result.name
 #ry:
 #nstalled_dist = env.get_distribution(item)
 #f installed_dist is not None:
 #tem = f"{item}-{installed_dist.version}"
 #xcept Exception:
 #ass
 #tems.append(item)

 #f conflicts is not None:
 #elf._warn_about_conflicts(
 #onflicts,
 #esolver_variant=self.determine_resolver_variant(options),
 #

 #nstalled_desc = " ".join(items)
 #f installed_desc:
 #rite_output(
 #Successfully installed %s",
 #nstalled_desc,
 #
 #xcept OSError as error:
 #how_traceback = self.verbosity >= 1

 #essage = create_os_error_message(
 #rror,
 #how_traceback,
 #ptions.use_user_site,
 #
 #ogger.error(message, exc_info=show_traceback)

 #eturn ERROR

 #f options.target_dir:
 #ssert target_temp_dir
 #elf._handle_target_dir(
 #ptions.target_dir, target_temp_dir, options.upgrade
 #
 #f options.root_user_action == "warn":
 #arn_if_run_as_root()
 #eturn SUCCESS

 #ef _handle_target_dir(
 #elf, target_dir: str, target_temp_dir: TempDirectory, upgrade: bool
 # -> None:
 #nsure_dir(target_dir)

        # Checking both purelib and platlib directories for installed
        # packages to be moved to target directory
 #ib_dir_list = []

        # Checking both purelib and platlib directories for installed
        # packages to be moved to target directory
 #cheme = get_scheme("", home=target_temp_dir.path)
 #urelib_dir = scheme.purelib
 #latlib_dir = scheme.platlib
 #ata_dir = scheme.data

 #f os.path.exists(purelib_dir):
 #ib_dir_list.append(purelib_dir)
 #f os.path.exists(platlib_dir) and platlib_dir != purelib_dir:
 #ib_dir_list.append(platlib_dir)
 #f os.path.exists(data_dir):
 #ib_dir_list.append(data_dir)

 #or lib_dir in lib_dir_list:
 #or item in os.listdir(lib_dir):
 #f lib_dir == data_dir:
 #dir = os.path.join(data_dir, item)
 #f any(s.startswith(ddir) for s in lib_dir_list[:-1]):
 #ontinue
 #arget_item_dir = os.path.join(target_dir, item)
 #f os.path.exists(target_item_dir):
 #f not upgrade:
 #ogger.warning(
 #Target directory %s already exists. Specify "
 #--upgrade to force replacement.",
 #arget_item_dir,
 #
 #ontinue
 #f os.path.islink(target_item_dir):
 #ogger.warning(
 #Target directory %s already exists and is "
 #a link. pip will not automatically replace "
 #links, please remove if replacement is "
 #desired.",
 #arget_item_dir,
 #
 #ontinue
 #f os.path.isdir(target_item_dir):
 #hutil.rmtree(target_item_dir)
 #lse:
 #s.remove(target_item_dir)

 #hutil.move(os.path.join(lib_dir, item), target_item_dir)

 #ef _determine_conflicts(
 #elf, to_install: List[InstallRequirement]
 # -> Optional[ConflictDetails]:
 #ry:
 #eturn check_install_conflicts(to_install)
 #xcept Exception:
 #ogger.exception(
 #Error while checking for conflicts. Please file an issue on "
 #pip's issue tracker: https://github.com/pypa/pip/issues/new"
 #
 #eturn None

 #ef _warn_about_conflicts(
 #elf, conflict_details: ConflictDetails, resolver_variant: str
 # -> None:
 #ackage_set, (missing, conflicting) = conflict_details
 #f not missing and not conflicting:
 #eturn

 #arts: List[str] = []
 #f resolver_variant == "legacy":
 #arts.append(
 #pip's legacy dependency resolver does not consider dependency "
 #conflicts when selecting packages. This behaviour is the "
 #source of the following dependency conflicts."
 #
 #lse:
 #ssert resolver_variant == "resolvelib"
 #arts.append(
 #pip's dependency resolver does not currently take into account "
 #all the packages that are installed. This behaviour is the "
 #source of the following dependency conflicts."
 #

        # NOTE: There is some duplication here, with commands/check.py
 #or project_name in missing:
 #ersion = package_set[project_name][0]
 #or dependency in missing[project_name]:
 #essage = (
 #"{project_name} {version} requires {dependency[1]}, "
 #which is not installed."
 #
 #arts.append(message)

 #or project_name in conflicting:
 #ersion = package_set[project_name][0]
 #or dep_name, dep_version, req in conflicting[project_name]:
 #essage = (
 #{name} {version} requires {requirement}, but {you} have "
 #{dep_name} {dep_version} which is incompatible."
 #.format(
 #ame=project_name,
 #ersion=version,
 #equirement=req,
 #ep_name=dep_name,
 #ep_version=dep_version,
 #ou=("you" if resolver_variant == "resolvelib" else "you'll"),
 #
 #arts.append(message)

 #ogger.critical("\n".join(parts))


def get_lib_location_guesses(
 #ser: bool = False,
 #ome: Optional[str] = None,
 #oot: Optional[str] = None,
 #solated: bool = False,
 #refix: Optional[str] = None,
) -> List[str]:
 #cheme = get_scheme(
 #",
 #ser=user,
 #ome=home,
 #oot=root,
 #solated=isolated,
 #refix=prefix,
 #
 #eturn [scheme.purelib, scheme.platlib]


def site_packages_writable(root: Optional[str], isolated: bool) -> bool:
 #eturn all(
 #est_writable_dir(d)
 #or d in set(get_lib_location_guesses(root=root, isolated=isolated))
 #


def decide_user_install(
 #se_user_site: Optional[bool],
 #refix_path: Optional[str] = None,
 #arget_dir: Optional[str] = None,
 #oot_path: Optional[str] = None,
 #solated_mode: bool = False,
) -> bool:
 #""Determine whether to do a user install based on the input options.

 #f use_user_site is False, no additional checks are done.
 #f use_user_site is True, it is checked for compatibility with other
 #ptions.
 #f use_user_site is None, the default behaviour depends on the environment,
 #hich is provided by the other arguments.
 #""
    # In some cases (config from tox), use_user_site can be set to an integer
    # rather than a bool, which 'use_user_site is False' wouldn't catch.
 #f (use_user_site is not None) and (not use_user_site):
 #ogger.debug("Non-user install by explicit request")
 #eturn False

 #f use_user_site:
 #f prefix_path:
 #aise CommandError(
 #Can not combine '--user' and '--prefix' as they imply "
 #different installation locations"
 #
 #f virtualenv_no_global():
 #aise InstallationError(
 #Can not perform a '--user' install. User site-packages "
 #are not visible in this virtualenv."
 #
 #ogger.debug("User install by explicit request")
 #eturn True

    # If we are here, user installs have not been explicitly requested/avoided
 #ssert use_user_site is None

    # user install incompatible with --prefix/--target
 #f prefix_path or target_dir:
 #ogger.debug("Non-user install due to --prefix or --target option")
 #eturn False

    # If user installs are not enabled, choose a non-user install
 #f not site.ENABLE_USER_SITE:
 #ogger.debug("Non-user install because user site-packages disabled")
 #eturn False

    # If we have permission for a non-user install, do that,
    # otherwise do a user install.
 #f site_packages_writable(root=root_path, isolated=isolated_mode):
 #ogger.debug("Non-user install because site-packages writeable")
 #eturn False

 #ogger.info(
 #Defaulting to user installation because normal site-packages "
 #is not writeable"
 #
 #eturn True


def create_os_error_message(
 #rror: OSError, show_traceback: bool, using_user_site: bool
) -> str:
 #""Format an error message for an OSError

 #t may occur anytime during the execution of the install command.
 #""
 #arts = []

    # Mention the error if we are not going to show a traceback
 #arts.append("Could not install packages due to an OSError")
 #f not show_traceback:
 #arts.append(": ")
 #arts.append(str(error))
 #lse:
 #arts.append(".")

    # Spilt the error indication from a helper message (if any)
 #arts[-1] += "\n"

    # Suggest useful actions to the user:
    #  (1) using user site-packages or (2) verifying the permissions
 #f error.errno == errno.EACCES:
 #ser_option_part = "Consider using the `--user` option"
 #ermissions_part = "Check the permissions"

 #f not running_under_virtualenv() and not using_user_site:
 #arts.extend(
 #
 #ser_option_part,
 # or ",
 #ermissions_part.lower(),
 #
 #
 #lse:
 #arts.append(permissions_part)
 #arts.append(".\n")

    # Suggest the user to enable Long Paths if path length is
    # more than 260
 #f (
 #INDOWS
 #nd error.errno == errno.ENOENT
 #nd error.filename
 #nd len(error.filename) > 260
 #:
 #arts.append(
 #HINT: This error might have occurred since "
 #this system does not have Windows Long Path "
 #support enabled. You can find information on "
 #how to enable this at "
 #https://pip.pypa.io/warnings/enable-long-paths\n"
 #

 #eturn "".join(parts).strip() + "\n"
