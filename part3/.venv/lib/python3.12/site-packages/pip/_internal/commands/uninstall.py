import logging
from optparse import Values
from typing import List

from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.cli import cmdoptions
from pip._internal.cli.base_command import Command
from pip._internal.cli.req_command import SessionCommandMixin, warn_if_run_as_root
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import InstallationError
from pip._internal.req import parse_requirements
from pip._internal.req.constructors import (
 #nstall_req_from_line,
 #nstall_req_from_parsed_requirement,
)
from pip._internal.utils.misc import (
 #heck_externally_managed,
 #rotect_pip_from_modification_on_windows,
)

logger = logging.getLogger(__name__)


class UninstallCommand(Command, SessionCommandMixin):
 #""
 #ninstall packages.

 #ip is able to uninstall most installed packages. Known exceptions are:

 # Pure distutils packages installed with ``python setup.py install``, which
 #eave behind no metadata to determine what files were installed.
 # Script wrappers installed by ``python setup.py develop``.
 #""

 #sage = """
 #prog [options] <package> ...
 #prog [options] -r <requirements file> ..."""

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(
 #-r",
 #--requirement",
 #est="requirements",
 #ction="append",
 #efault=[],
 #etavar="file",
 #elp=(
 #Uninstall all the packages listed in the given requirements "
 #file.  This option can be used multiple times."
 #,
 #
 #elf.cmd_opts.add_option(
 #-y",
 #--yes",
 #est="yes",
 #ction="store_true",
 #elp="Don't ask for confirmation of uninstall deletions.",
 #
 #elf.cmd_opts.add_option(cmdoptions.root_user_action())
 #elf.cmd_opts.add_option(cmdoptions.override_externally_managed())
 #elf.parser.insert_option_group(0, self.cmd_opts)

 #ef run(self, options: Values, args: List[str]) -> int:
 #ession = self.get_default_session(options)

 #eqs_to_uninstall = {}
 #or name in args:
 #eq = install_req_from_line(
 #ame,
 #solated=options.isolated_mode,
 #
 #f req.name:
 #eqs_to_uninstall[canonicalize_name(req.name)] = req
 #lse:
 #ogger.warning(
 #Invalid requirement: %r ignored -"
 # the uninstall command expects named"
 # requirements.",
 #ame,
 #
 #or filename in options.requirements:
 #or parsed_req in parse_requirements(
 #ilename, options=options, session=session
 #:
 #eq = install_req_from_parsed_requirement(
 #arsed_req, isolated=options.isolated_mode
 #
 #f req.name:
 #eqs_to_uninstall[canonicalize_name(req.name)] = req
 #f not reqs_to_uninstall:
 #aise InstallationError(
 #"You must give at least one requirement to {self.name} (see "
 #'"pip help {self.name}")'
 #

 #f not options.override_externally_managed:
 #heck_externally_managed()

 #rotect_pip_from_modification_on_windows(
 #odifying_pip="pip" in reqs_to_uninstall
 #

 #or req in reqs_to_uninstall.values():
 #ninstall_pathset = req.uninstall(
 #uto_confirm=options.yes,
 #erbose=self.verbosity > 0,
 #
 #f uninstall_pathset:
 #ninstall_pathset.commit()
 #f options.root_user_action == "warn":
 #arn_if_run_as_root()
 #eturn SUCCESS
