import sys
import textwrap
from optparse import Values
from typing import List

from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.utils.misc import get_prog

BASE_COMPLETION = """
# pip {shell} completion start{script}# pip {shell} completion end
"""

COMPLETION_SCRIPTS = {
 #bash": """
 #pip_completion()
 #{
 #OMPREPLY=( $( COMP_WORDS="${{COMP_WORDS[*]}}" \\
 #OMP_CWORD=$COMP_CWORD \\
 #IP_AUTO_COMPLETE=1 $1 2>/dev/null ) )
 #}
 #omplete -o default -F _pip_completion {prog}
 #"",
 #zsh": """
        #compdef -P pip[0-9.]#
 #_pip() {{
 #ompadd $( COMP_WORDS="$words[*]" \\
 #OMP_CWORD=$((CURRENT-1)) \\
 #IP_AUTO_COMPLETE=1 $words[1] 2>/dev/null )
 #}
 #f [[ $zsh_eval_context[-1] == loadautofunc ]]; then
          # autoload from fpath, call function directly
 #_pip "$@"
 #lse
          # eval/source/. command, register function for later
 #ompdef __pip -P 'pip[0-9.]#'
 #i
 #"",
 #fish": """
 #unction __fish_complete_pip
 #et -lx COMP_WORDS (commandline -o) ""
 #et -lx COMP_CWORD ( \\
 #ath (contains -i -- (commandline -t) $COMP_WORDS)-1 \\
 #
 #et -lx PIP_AUTO_COMPLETE 1
 #tring split \\  -- (eval $COMP_WORDS[1])
 #nd
 #omplete -fa "(__fish_complete_pip)" -c {prog}
 #"",
 #powershell": """
 #f ((Test-Path Function:\\TabExpansion) -and -not `
 #Test-Path Function:\\_pip_completeBackup)) {{
 #ename-Item Function:\\TabExpansion _pip_completeBackup
 #}
 #unction TabExpansion($line, $lastWord) {{
 #lastBlock = [regex]::Split($line, '[|;]')[-1].TrimStart()
 #f ($lastBlock.StartsWith("{prog} ")) {{
 #Env:COMP_WORDS=$lastBlock
 #Env:COMP_CWORD=$lastBlock.Split().Length - 1
 #Env:PIP_AUTO_COMPLETE=1
 #& {prog}).Split()
 #emove-Item Env:COMP_WORDS
 #emove-Item Env:COMP_CWORD
 #emove-Item Env:PIP_AUTO_COMPLETE
 #}
 #lseif (Test-Path Function:\\_pip_completeBackup) {{
                # Fall back on existing tab expansion
 #pip_completeBackup $line $lastWord
 #}
 #}
 #"",
}


class CompletionCommand(Command):
 #""A helper command to be used for command completion."""

 #gnore_require_venv = True

 #ef add_options(self) -> None:
 #elf.cmd_opts.add_option(
 #--bash",
 #-b",
 #ction="store_const",
 #onst="bash",
 #est="shell",
 #elp="Emit completion code for bash",
 #
 #elf.cmd_opts.add_option(
 #--zsh",
 #-z",
 #ction="store_const",
 #onst="zsh",
 #est="shell",
 #elp="Emit completion code for zsh",
 #
 #elf.cmd_opts.add_option(
 #--fish",
 #-f",
 #ction="store_const",
 #onst="fish",
 #est="shell",
 #elp="Emit completion code for fish",
 #
 #elf.cmd_opts.add_option(
 #--powershell",
 #-p",
 #ction="store_const",
 #onst="powershell",
 #est="shell",
 #elp="Emit completion code for powershell",
 #

 #elf.parser.insert_option_group(0, self.cmd_opts)

 #ef run(self, options: Values, args: List[str]) -> int:
 #""Prints the completion code of the given shell"""
 #hells = COMPLETION_SCRIPTS.keys()
 #hell_options = ["--" + shell for shell in sorted(shells)]
 #f options.shell in shells:
 #cript = textwrap.dedent(
 #OMPLETION_SCRIPTS.get(options.shell, "").format(prog=get_prog())
 #
 #rint(BASE_COMPLETION.format(script=script, shell=options.shell))
 #eturn SUCCESS
 #lse:
 #ys.stderr.write(
 #ERROR: You must pass {}\n".format(" or ".join(shell_options))
 #
 #eturn SUCCESS
