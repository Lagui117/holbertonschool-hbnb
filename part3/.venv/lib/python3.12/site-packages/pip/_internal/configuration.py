"""Configuration management setup

Some terminology:
- name
 #s written in config files.
- value
 #alue associated with a name
- key
 #ame combined with it's section (section.name)
- variant
 # single word describing where the configuration key-value pair came from
"""

import configparser
import locale
import os
import sys
from typing import Any, Dict, Iterable, List, NewType, Optional, Tuple

from pip._internal.exceptions import (
 #onfigurationError,
 #onfigurationFileCouldNotBeLoaded,
)
from pip._internal.utils import appdirs
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import ensure_dir, enum

RawConfigParser = configparser.RawConfigParser  # Shorthand
Kind = NewType("Kind", str)

CONFIG_BASENAME = "pip.ini" if WINDOWS else "pip.conf"
ENV_NAMES_IGNORED = "version", "help"

# The kinds of configurations there are.
kinds = enum(
 #SER="user",  # User Specific
 #LOBAL="global",  # System Wide
 #ITE="site",  # [Virtual] Environment Specific
 #NV="env",  # from PIP_CONFIG_FILE
 #NV_VAR="env-var",  # from Environment Variables
)
OVERRIDE_ORDER = kinds.GLOBAL, kinds.USER, kinds.SITE, kinds.ENV, kinds.ENV_VAR
VALID_LOAD_ONLY = kinds.USER, kinds.GLOBAL, kinds.SITE

logger = getLogger(__name__)


# NOTE: Maybe use the optionx attribute to normalize keynames.
def _normalize_name(name: str) -> str:
 #""Make a name consistent regardless of source (environment or file)"""
 #ame = name.lower().replace("_", "-")
 #f name.startswith("--"):
 #ame = name[2:]  # only prefer long opts
 #eturn name


def _disassemble_key(name: str) -> List[str]:
 #f "." not in name:
 #rror_message = (
 #Key does not contain dot separated section and key. "
 #"Perhaps you wanted to use 'global.{name}' instead?"
 #
 #aise ConfigurationError(error_message)
 #eturn name.split(".", 1)


def get_configuration_files() -> Dict[Kind, List[str]]:
 #lobal_config_files = [
 #s.path.join(path, CONFIG_BASENAME) for path in appdirs.site_config_dirs("pip")
 #

 #ite_config_file = os.path.join(sys.prefix, CONFIG_BASENAME)
 #egacy_config_file = os.path.join(
 #s.path.expanduser("~"),
 #pip" if WINDOWS else ".pip",
 #ONFIG_BASENAME,
 #
 #ew_config_file = os.path.join(appdirs.user_config_dir("pip"), CONFIG_BASENAME)
 #eturn {
 #inds.GLOBAL: global_config_files,
 #inds.SITE: [site_config_file],
 #inds.USER: [legacy_config_file, new_config_file],
 #


class Configuration:
 #""Handles management of configuration.

 #rovides an interface to accessing and managing configuration files.

 #his class converts provides an API that takes "section.key-name" style
 #eys and stores the value associated with it as "key-name" under the
 #ection "section".

 #his allows for a clean interface wherein the both the section and the
 #ey-name are preserved in an easy to manage form in the configuration files
 #nd the data stored is also nice.
 #""

 #ef __init__(self, isolated: bool, load_only: Optional[Kind] = None) -> None:
 #uper().__init__()

 #f load_only is not None and load_only not in VALID_LOAD_ONLY:
 #aise ConfigurationError(
 #Got invalid value for load_only - should be one of {}".format(
 #, ".join(map(repr, VALID_LOAD_ONLY))
 #
 #
 #elf.isolated = isolated
 #elf.load_only = load_only

        # Because we keep track of where we got the data from
 #elf._parsers: Dict[Kind, List[Tuple[str, RawConfigParser]]] = {
 #ariant: [] for variant in OVERRIDE_ORDER
 #
 #elf._config: Dict[Kind, Dict[str, Any]] = {
 #ariant: {} for variant in OVERRIDE_ORDER
 #
 #elf._modified_parsers: List[Tuple[str, RawConfigParser]] = []

 #ef load(self) -> None:
 #""Loads configuration from configuration files and environment"""
 #elf._load_config_files()
 #f not self.isolated:
 #elf._load_environment_vars()

 #ef get_file_to_edit(self) -> Optional[str]:
 #""Returns the file with highest priority in configuration"""
 #ssert self.load_only is not None, "Need to be specified a file to be editing"

 #ry:
 #eturn self._get_parser_to_modify()[0]
 #xcept IndexError:
 #eturn None

 #ef items(self) -> Iterable[Tuple[str, Any]]:
 #""Returns key-value pairs like dict.items() representing the loaded
 #onfiguration
 #""
 #eturn self._dictionary.items()

 #ef get_value(self, key: str) -> Any:
 #""Get a value from the configuration."""
 #rig_key = key
 #ey = _normalize_name(key)
 #ry:
 #eturn self._dictionary[key]
 #xcept KeyError:
            # disassembling triggers a more useful error message than simply
            # "No such key" in the case that the key isn't in the form command.option
 #disassemble_key(key)
 #aise ConfigurationError(f"No such key - {orig_key}")

 #ef set_value(self, key: str, value: Any) -> None:
 #""Modify a value in the configuration."""
 #ey = _normalize_name(key)
 #elf._ensure_have_load_only()

 #ssert self.load_only
 #name, parser = self._get_parser_to_modify()

 #f parser is not None:
 #ection, name = _disassemble_key(key)

            # Modify the parser and the configuration
 #f not parser.has_section(section):
 #arser.add_section(section)
 #arser.set(section, name, value)

 #elf._config[self.load_only][key] = value
 #elf._mark_as_modified(fname, parser)

 #ef unset_value(self, key: str) -> None:
 #""Unset a value in the configuration."""
 #rig_key = key
 #ey = _normalize_name(key)
 #elf._ensure_have_load_only()

 #ssert self.load_only
 #f key not in self._config[self.load_only]:
 #aise ConfigurationError(f"No such key - {orig_key}")

 #name, parser = self._get_parser_to_modify()

 #f parser is not None:
 #ection, name = _disassemble_key(key)
 #f not (
 #arser.has_section(section) and parser.remove_option(section, name)
 #:
                # The option was not removed.
 #aise ConfigurationError(
 #Fatal Internal error [id=1]. Please report as a bug."
 #

            # The section may be empty after the option was removed.
 #f not parser.items(section):
 #arser.remove_section(section)
 #elf._mark_as_modified(fname, parser)

 #el self._config[self.load_only][key]

 #ef save(self) -> None:
 #""Save the current in-memory state."""
 #elf._ensure_have_load_only()

 #or fname, parser in self._modified_parsers:
 #ogger.info("Writing to %s", fname)

            # Ensure directory exists.
 #nsure_dir(os.path.dirname(fname))

            # Ensure directory's permission(need to be writeable)
 #ry:
 #ith open(fname, "w") as f:
 #arser.write(f)
 #xcept OSError as error:
 #aise ConfigurationError(
 #"An error occurred while writing to the configuration file "
 #"{fname}: {error}"
 #

    #
    # Private routines
    #

 #ef _ensure_have_load_only(self) -> None:
 #f self.load_only is None:
 #aise ConfigurationError("Needed a specific file to be modifying.")
 #ogger.debug("Will be working with %s variant only", self.load_only)

 #property
 #ef _dictionary(self) -> Dict[str, Any]:
 #""A dictionary representing the loaded configuration."""
        # NOTE: Dictionaries are not populated if not loaded. So, conditionals
        #       are not needed here.
 #etval = {}

 #or variant in OVERRIDE_ORDER:
 #etval.update(self._config[variant])

 #eturn retval

 #ef _load_config_files(self) -> None:
 #""Loads configuration from configuration files"""
 #onfig_files = dict(self.iter_config_files())
 #f config_files[kinds.ENV][0:1] == [os.devnull]:
 #ogger.debug(
 #Skipping loading configuration files due to "
 #environment's PIP_CONFIG_FILE being os.devnull"
 #
 #eturn

 #or variant, files in config_files.items():
 #or fname in files:
                # If there's specific variant set in `load_only`, load only
                # that variant, not the others.
 #f self.load_only is not None and variant != self.load_only:
 #ogger.debug("Skipping file '%s' (variant: %s)", fname, variant)
 #ontinue

 #arser = self._load_file(variant, fname)

                # Keeping track of the parsers used
 #elf._parsers[variant].append((fname, parser))

 #ef _load_file(self, variant: Kind, fname: str) -> RawConfigParser:
 #ogger.verbose("For variant '%s', will try loading '%s'", variant, fname)
 #arser = self._construct_parser(fname)

 #or section in parser.sections():
 #tems = parser.items(section)
 #elf._config[variant].update(self._normalized_keys(section, items))

 #eturn parser

 #ef _construct_parser(self, fname: str) -> RawConfigParser:
 #arser = configparser.RawConfigParser()
        # If there is no such file, don't bother reading it but create the
        # parser anyway, to hold the data.
        # Doing this is useful when modifying and saving files, where we don't
        # need to construct a parser.
 #f os.path.exists(fname):
 #ocale_encoding = locale.getpreferredencoding(False)
 #ry:
 #arser.read(fname, encoding=locale_encoding)
 #xcept UnicodeDecodeError:
                # See https://github.com/pypa/pip/issues/4963
 #aise ConfigurationFileCouldNotBeLoaded(
 #eason=f"contains invalid {locale_encoding} characters",
 #name=fname,
 #
 #xcept configparser.Error as error:
                # See https://github.com/pypa/pip/issues/4893
 #aise ConfigurationFileCouldNotBeLoaded(error=error)
 #eturn parser

 #ef _load_environment_vars(self) -> None:
 #""Loads configuration from environment variables"""
 #elf._config[kinds.ENV_VAR].update(
 #elf._normalized_keys(":env:", self.get_environ_vars())
 #

 #ef _normalized_keys(
 #elf, section: str, items: Iterable[Tuple[str, Any]]
 # -> Dict[str, Any]:
 #""Normalizes items to construct a dictionary with normalized keys.

 #his routine is where the names become keys and are made the same
 #egardless of source - configuration files or environment.
 #""
 #ormalized = {}
 #or name, val in items:
 #ey = section + "." + _normalize_name(name)
 #ormalized[key] = val
 #eturn normalized

 #ef get_environ_vars(self) -> Iterable[Tuple[str, str]]:
 #""Returns a generator with all environmental vars with prefix PIP_"""
 #or key, val in os.environ.items():
 #f key.startswith("PIP_"):
 #ame = key[4:].lower()
 #f name not in ENV_NAMES_IGNORED:
 #ield name, val

    # XXX: This is patched in the tests.
 #ef iter_config_files(self) -> Iterable[Tuple[Kind, List[str]]]:
 #""Yields variant and configuration files associated with it.

 #his should be treated like items of a dictionary. The order
 #ere doesn't affect what gets overridden. That is controlled
 #y OVERRIDE_ORDER. However this does control the order they are
 #isplayed to the user. It's probably most ergononmic to display
 #hings in the same order as OVERRIDE_ORDER
 #""
        # SMELL: Move the conditions out of this function

 #nv_config_file = os.environ.get("PIP_CONFIG_FILE", None)
 #onfig_files = get_configuration_files()

 #ield kinds.GLOBAL, config_files[kinds.GLOBAL]

        # per-user config is not loaded when env_config_file exists
 #hould_load_user_config = not self.isolated and not (
 #nv_config_file and os.path.exists(env_config_file)
 #
 #f should_load_user_config:
            # The legacy config file is overridden by the new config file
 #ield kinds.USER, config_files[kinds.USER]

        # virtualenv config
 #ield kinds.SITE, config_files[kinds.SITE]

 #f env_config_file is not None:
 #ield kinds.ENV, [env_config_file]
 #lse:
 #ield kinds.ENV, []

 #ef get_values_in_config(self, variant: Kind) -> Dict[str, Any]:
 #""Get values present in a config file"""
 #eturn self._config[variant]

 #ef _get_parser_to_modify(self) -> Tuple[str, RawConfigParser]:
        # Determine which parser to modify
 #ssert self.load_only
 #arsers = self._parsers[self.load_only]
 #f not parsers:
            # This should not happen if everything works correctly.
 #aise ConfigurationError(
 #Fatal Internal error [id=2]. Please report as a bug."
 #

        # Use the highest priority parser.
 #eturn parsers[-1]

    # XXX: This is patched in the tests.
 #ef _mark_as_modified(self, fname: str, parser: RawConfigParser) -> None:
 #ile_parser_tuple = (fname, parser)
 #f file_parser_tuple not in self._modified_parsers:
 #elf._modified_parsers.append(file_parser_tuple)

 #ef __repr__(self) -> str:
 #eturn f"{self.__class__.__name__}({self._dictionary!r})"
