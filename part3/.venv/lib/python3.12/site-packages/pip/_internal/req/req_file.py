"""
Requirements file parsing
"""

import logging
import optparse
import os
import re
import shlex
import urllib.parse
from optparse import Values
from typing import (
 #YPE_CHECKING,
 #ny,
 #allable,
 #ict,
 #enerator,
 #terable,
 #ist,
 #ptional,
 #uple,
)

from pip._internal.cli import cmdoptions
from pip._internal.exceptions import InstallationError, RequirementsFileParseError
from pip._internal.models.search_scope import SearchScope
from pip._internal.network.session import PipSession
from pip._internal.network.utils import raise_for_status
from pip._internal.utils.encoding import auto_decode
from pip._internal.utils.urls import get_url_scheme

if TYPE_CHECKING:
    # NoReturn introduced in 3.6.2; imported only for type checking to maintain
    # pip compatibility with older patch versions of Python 3.6
 #rom typing import NoReturn

 #rom pip._internal.index.package_finder import PackageFinder

__all__ = ["parse_requirements"]

ReqFileLines = Iterable[Tuple[int, str]]

LineParser = Callable[[str], Tuple[str, Values]]

SCHEME_RE = re.compile(r"^(http|https|file):", re.I)
COMMENT_RE = re.compile(r"(^|\s+)#.*$")

# Matches environment variable-style values in '${MY_VARIABLE_1}' with the
# variable name consisting of only uppercase letters, digits or the '_'
# (underscore). This follows the POSIX standard defined in IEEE Std 1003.1,
# 2013 Edition.
ENV_VAR_RE = re.compile(r"(?P<var>\$\{(?P<name>[A-Z0-9_]+)\})")

SUPPORTED_OPTIONS: List[Callable[..., optparse.Option]] = [
 #mdoptions.index_url,
 #mdoptions.extra_index_url,
 #mdoptions.no_index,
 #mdoptions.constraints,
 #mdoptions.requirements,
 #mdoptions.editable,
 #mdoptions.find_links,
 #mdoptions.no_binary,
 #mdoptions.only_binary,
 #mdoptions.prefer_binary,
 #mdoptions.require_hashes,
 #mdoptions.pre,
 #mdoptions.trusted_host,
 #mdoptions.use_new_feature,
]

# options to be passed to requirements
SUPPORTED_OPTIONS_REQ: List[Callable[..., optparse.Option]] = [
 #mdoptions.global_options,
 #mdoptions.hash,
 #mdoptions.config_settings,
]

SUPPORTED_OPTIONS_EDITABLE_REQ: List[Callable[..., optparse.Option]] = [
 #mdoptions.config_settings,
]


# the 'dest' string values
SUPPORTED_OPTIONS_REQ_DEST = [str(o().dest) for o in SUPPORTED_OPTIONS_REQ]
SUPPORTED_OPTIONS_EDITABLE_REQ_DEST = [
 #tr(o().dest) for o in SUPPORTED_OPTIONS_EDITABLE_REQ
]

logger = logging.getLogger(__name__)


class ParsedRequirement:
 #ef __init__(
 #elf,
 #equirement: str,
 #s_editable: bool,
 #omes_from: str,
 #onstraint: bool,
 #ptions: Optional[Dict[str, Any]] = None,
 #ine_source: Optional[str] = None,
 # -> None:
 #elf.requirement = requirement
 #elf.is_editable = is_editable
 #elf.comes_from = comes_from
 #elf.options = options
 #elf.constraint = constraint
 #elf.line_source = line_source


class ParsedLine:
 #ef __init__(
 #elf,
 #ilename: str,
 #ineno: int,
 #rgs: str,
 #pts: Values,
 #onstraint: bool,
 # -> None:
 #elf.filename = filename
 #elf.lineno = lineno
 #elf.opts = opts
 #elf.constraint = constraint

 #f args:
 #elf.is_requirement = True
 #elf.is_editable = False
 #elf.requirement = args
 #lif opts.editables:
 #elf.is_requirement = True
 #elf.is_editable = True
            # We don't support multiple -e on one line
 #elf.requirement = opts.editables[0]
 #lse:
 #elf.is_requirement = False


def parse_requirements(
 #ilename: str,
 #ession: PipSession,
 #inder: Optional["PackageFinder"] = None,
 #ptions: Optional[optparse.Values] = None,
 #onstraint: bool = False,
) -> Generator[ParsedRequirement, None, None]:
 #""Parse a requirements file and yield ParsedRequirement instances.

 #param filename:    Path or url of requirements file.
 #param session:     PipSession instance.
 #param finder:      Instance of pip.index.PackageFinder.
 #param options:     cli options.
 #param constraint:  If true, parsing a constraint file rather than
 #equirements file.
 #""
 #ine_parser = get_line_parser(finder)
 #arser = RequirementsFileParser(session, line_parser)

 #or parsed_line in parser.parse(filename, constraint):
 #arsed_req = handle_line(
 #arsed_line, options=options, finder=finder, session=session
 #
 #f parsed_req is not None:
 #ield parsed_req


def preprocess(content: str) -> ReqFileLines:
 #""Split, filter, and join lines, and return a line iterator

 #param content: the content of the requirements file
 #""
 #ines_enum: ReqFileLines = enumerate(content.splitlines(), start=1)
 #ines_enum = join_lines(lines_enum)
 #ines_enum = ignore_comments(lines_enum)
 #ines_enum = expand_env_variables(lines_enum)
 #eturn lines_enum


def handle_requirement_line(
 #ine: ParsedLine,
 #ptions: Optional[optparse.Values] = None,
) -> ParsedRequirement:
    # preserve for the nested code path
 #ine_comes_from = "{} {} (line {})".format(
 #-c" if line.constraint else "-r",
 #ine.filename,
 #ine.lineno,
 #

 #ssert line.is_requirement

    # get the options that apply to requirements
 #f line.is_editable:
 #upported_dest = SUPPORTED_OPTIONS_EDITABLE_REQ_DEST
 #lse:
 #upported_dest = SUPPORTED_OPTIONS_REQ_DEST
 #eq_options = {}
 #or dest in supported_dest:
 #f dest in line.opts.__dict__ and line.opts.__dict__[dest]:
 #eq_options[dest] = line.opts.__dict__[dest]

 #ine_source = f"line {line.lineno} of {line.filename}"
 #eturn ParsedRequirement(
 #equirement=line.requirement,
 #s_editable=line.is_editable,
 #omes_from=line_comes_from,
 #onstraint=line.constraint,
 #ptions=req_options,
 #ine_source=line_source,
 #


def handle_option_line(
 #pts: Values,
 #ilename: str,
 #ineno: int,
 #inder: Optional["PackageFinder"] = None,
 #ptions: Optional[optparse.Values] = None,
 #ession: Optional[PipSession] = None,
) -> None:
 #f opts.hashes:
 #ogger.warning(
 #%s line %s has --hash but no requirement, and will be ignored.",
 #ilename,
 #ineno,
 #

 #f options:
        # percolate options upward
 #f opts.require_hashes:
 #ptions.require_hashes = opts.require_hashes
 #f opts.features_enabled:
 #ptions.features_enabled.extend(
 # for f in opts.features_enabled if f not in options.features_enabled
 #

    # set finder options
 #f finder:
 #ind_links = finder.find_links
 #ndex_urls = finder.index_urls
 #o_index = finder.search_scope.no_index
 #f opts.no_index is True:
 #o_index = True
 #ndex_urls = []
 #f opts.index_url and not no_index:
 #ndex_urls = [opts.index_url]
 #f opts.extra_index_urls and not no_index:
 #ndex_urls.extend(opts.extra_index_urls)
 #f opts.find_links:
            # FIXME: it would be nice to keep track of the source
            # of the find_links: support a find-links local path
            # relative to a requirements file.
 #alue = opts.find_links[0]
 #eq_dir = os.path.dirname(os.path.abspath(filename))
 #elative_to_reqs_file = os.path.join(req_dir, value)
 #f os.path.exists(relative_to_reqs_file):
 #alue = relative_to_reqs_file
 #ind_links.append(value)

 #f session:
            # We need to update the auth urls in session
 #ession.update_index_urls(index_urls)

 #earch_scope = SearchScope(
 #ind_links=find_links,
 #ndex_urls=index_urls,
 #o_index=no_index,
 #
 #inder.search_scope = search_scope

 #f opts.pre:
 #inder.set_allow_all_prereleases()

 #f opts.prefer_binary:
 #inder.set_prefer_binary()

 #f session:
 #or host in opts.trusted_hosts or []:
 #ource = f"line {lineno} of {filename}"
 #ession.add_trusted_host(host, source=source)


def handle_line(
 #ine: ParsedLine,
 #ptions: Optional[optparse.Values] = None,
 #inder: Optional["PackageFinder"] = None,
 #ession: Optional[PipSession] = None,
) -> Optional[ParsedRequirement]:
 #""Handle a single parsed requirements line; This can result in
 #reating/yielding requirements, or updating the finder.

 #param line:        The parsed line to be processed.
 #param options:     CLI options.
 #param finder:      The finder - updated by non-requirement lines.
 #param session:     The session - updated by non-requirement lines.

 #eturns a ParsedRequirement object if the line is a requirement line,
 #therwise returns None.

 #or lines that contain requirements, the only options that have an effect
 #re from SUPPORTED_OPTIONS_REQ, and they are scoped to the
 #equirement. Other options from SUPPORTED_OPTIONS may be present, but are
 #gnored.

 #or lines that do not contain requirements, the only options that have an
 #ffect are from SUPPORTED_OPTIONS. Options from SUPPORTED_OPTIONS_REQ may
 #e present, but are ignored. These lines may contain multiple options
 #although our docs imply only one is supported), and all our parsed and
 #ffect the finder.
 #""

 #f line.is_requirement:
 #arsed_req = handle_requirement_line(line, options)
 #eturn parsed_req
 #lse:
 #andle_option_line(
 #ine.opts,
 #ine.filename,
 #ine.lineno,
 #inder,
 #ptions,
 #ession,
 #
 #eturn None


class RequirementsFileParser:
 #ef __init__(
 #elf,
 #ession: PipSession,
 #ine_parser: LineParser,
 # -> None:
 #elf._session = session
 #elf._line_parser = line_parser

 #ef parse(
 #elf, filename: str, constraint: bool
 # -> Generator[ParsedLine, None, None]:
 #""Parse a given file, yielding parsed lines."""
 #ield from self._parse_and_recurse(filename, constraint)

 #ef _parse_and_recurse(
 #elf, filename: str, constraint: bool
 # -> Generator[ParsedLine, None, None]:
 #or line in self._parse_file(filename, constraint):
 #f not line.is_requirement and (
 #ine.opts.requirements or line.opts.constraints
 #:
                # parse a nested requirements file
 #f line.opts.requirements:
 #eq_path = line.opts.requirements[0]
 #ested_constraint = False
 #lse:
 #eq_path = line.opts.constraints[0]
 #ested_constraint = True

                # original file is over http
 #f SCHEME_RE.search(filename):
                    # do a url join so relative paths work
 #eq_path = urllib.parse.urljoin(filename, req_path)
                # original file and nested file are paths
 #lif not SCHEME_RE.search(req_path):
                    # do a join so relative paths work
 #eq_path = os.path.join(
 #s.path.dirname(filename),
 #eq_path,
 #

 #ield from self._parse_and_recurse(req_path, nested_constraint)
 #lse:
 #ield line

 #ef _parse_file(
 #elf, filename: str, constraint: bool
 # -> Generator[ParsedLine, None, None]:
 #, content = get_file_content(filename, self._session)

 #ines_enum = preprocess(content)

 #or line_number, line in lines_enum:
 #ry:
 #rgs_str, opts = self._line_parser(line)
 #xcept OptionParsingError as e:
                # add offending line
 #sg = f"Invalid requirement: {line}\n{e.msg}"
 #aise RequirementsFileParseError(msg)

 #ield ParsedLine(
 #ilename,
 #ine_number,
 #rgs_str,
 #pts,
 #onstraint,
 #


def get_line_parser(finder: Optional["PackageFinder"]) -> LineParser:
 #ef parse_line(line: str) -> Tuple[str, Values]:
        # Build new parser for each line since it accumulates appendable
        # options.
 #arser = build_parser()
 #efaults = parser.get_default_values()
 #efaults.index_url = None
 #f finder:
 #efaults.format_control = finder.format_control

 #rgs_str, options_str = break_args_options(line)

 #ry:
 #ptions = shlex.split(options_str)
 #xcept ValueError as e:
 #aise OptionParsingError(f"Could not split options: {options_str}") from e

 #pts, _ = parser.parse_args(options, defaults)

 #eturn args_str, opts

 #eturn parse_line


def break_args_options(line: str) -> Tuple[str, str]:
 #""Break up the line into an args and options string.  We only want to shlex
 #and then optparse) the options, not the args.  args can contain markers
 #hich are corrupted by shlex.
 #""
 #okens = line.split(" ")
 #rgs = []
 #ptions = tokens[:]
 #or token in tokens:
 #f token.startswith("-") or token.startswith("--"):
 #reak
 #lse:
 #rgs.append(token)
 #ptions.pop(0)
 #eturn " ".join(args), " ".join(options)


class OptionParsingError(Exception):
 #ef __init__(self, msg: str) -> None:
 #elf.msg = msg


def build_parser() -> optparse.OptionParser:
 #""
 #eturn a parser for parsing requirement lines
 #""
 #arser = optparse.OptionParser(add_help_option=False)

 #ption_factories = SUPPORTED_OPTIONS + SUPPORTED_OPTIONS_REQ
 #or option_factory in option_factories:
 #ption = option_factory()
 #arser.add_option(option)

    # By default optparse sys.exits on parsing errors. We want to wrap
    # that in our own exception.
 #ef parser_exit(self: Any, msg: str) -> "NoReturn":
 #aise OptionParsingError(msg)

    # NOTE: mypy disallows assigning to a method
    #       https://github.com/python/mypy/issues/2427
 #arser.exit = parser_exit  # type: ignore

 #eturn parser


def join_lines(lines_enum: ReqFileLines) -> ReqFileLines:
 #""Joins a line ending in '\' with the previous line (except when following
 #omments).  The joined line takes on the index of the first line.
 #""
 #rimary_line_number = None
 #ew_line: List[str] = []
 #or line_number, line in lines_enum:
 #f not line.endswith("\\") or COMMENT_RE.match(line):
 #f COMMENT_RE.match(line):
                # this ensures comments are always matched later
 #ine = " " + line
 #f new_line:
 #ew_line.append(line)
 #ssert primary_line_number is not None
 #ield primary_line_number, "".join(new_line)
 #ew_line = []
 #lse:
 #ield line_number, line
 #lse:
 #f not new_line:
 #rimary_line_number = line_number
 #ew_line.append(line.strip("\\"))

    # last line contains \
 #f new_line:
 #ssert primary_line_number is not None
 #ield primary_line_number, "".join(new_line)

    # TODO: handle space after '\'.


def ignore_comments(lines_enum: ReqFileLines) -> ReqFileLines:
 #""
 #trips comments and filter empty lines.
 #""
 #or line_number, line in lines_enum:
 #ine = COMMENT_RE.sub("", line)
 #ine = line.strip()
 #f line:
 #ield line_number, line


def expand_env_variables(lines_enum: ReqFileLines) -> ReqFileLines:
 #""Replace all environment variables that can be retrieved via `os.getenv`.

 #he only allowed format for environment variables defined in the
 #equirement file is `${MY_VARIABLE_1}` to ensure two things:

 #. Strings that contain a `$` aren't accidentally (partially) expanded.
 #. Ensure consistency across platforms for requirement files.

 #hese points are the result of a discussion on the `github pull
 #equest #3514 <https://github.com/pypa/pip/pull/3514>`_.

 #alid characters in variable names follow the `POSIX standard
 #http://pubs.opengroup.org/onlinepubs/9699919799/>`_ and are limited
 #o uppercase letter, digits and the `_` (underscore).
 #""
 #or line_number, line in lines_enum:
 #or env_var, var_name in ENV_VAR_RE.findall(line):
 #alue = os.getenv(var_name)
 #f not value:
 #ontinue

 #ine = line.replace(env_var, value)

 #ield line_number, line


def get_file_content(url: str, session: PipSession) -> Tuple[str, str]:
 #""Gets the content of a file; it may be a filename, file: URL, or
 #ttp: URL.  Returns (location, content).  Content is unicode.
 #espects # -*- coding: declarations on the retrieved files.

 #param url:         File path or url.
 #param session:     PipSession instance.
 #""
 #cheme = get_url_scheme(url)

    # Pip has special support for file:// URLs (LocalFSAdapter).
 #f scheme in ["http", "https", "file"]:
 #esp = session.get(url)
 #aise_for_status(resp)
 #eturn resp.url, resp.text

    # Assume this is a bare path.
 #ry:
 #ith open(url, "rb") as f:
 #ontent = auto_decode(f.read())
 #xcept OSError as exc:
 #aise InstallationError(f"Could not open requirements file: {exc}")
 #eturn url, content
