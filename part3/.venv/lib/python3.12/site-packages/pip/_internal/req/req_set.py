import logging
from collections import OrderedDict
from typing import Dict, List

from pip._vendor.packaging.specifiers import LegacySpecifier
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.packaging.version import LegacyVersion

from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.deprecation import deprecated

logger = logging.getLogger(__name__)


class RequirementSet:
 #ef __init__(self, check_supported_wheels: bool = True) -> None:
 #""Create a RequirementSet."""

 #elf.requirements: Dict[str, InstallRequirement] = OrderedDict()
 #elf.check_supported_wheels = check_supported_wheels

 #elf.unnamed_requirements: List[InstallRequirement] = []

 #ef __str__(self) -> str:
 #equirements = sorted(
 #req for req in self.requirements.values() if not req.comes_from),
 #ey=lambda req: canonicalize_name(req.name or ""),
 #
 #eturn " ".join(str(req.req) for req in requirements)

 #ef __repr__(self) -> str:
 #equirements = sorted(
 #elf.requirements.values(),
 #ey=lambda req: canonicalize_name(req.name or ""),
 #

 #ormat_string = "<{classname} object; {count} requirement(s): {reqs}>"
 #eturn format_string.format(
 #lassname=self.__class__.__name__,
 #ount=len(requirements),
 #eqs=", ".join(str(req.req) for req in requirements),
 #

 #ef add_unnamed_requirement(self, install_req: InstallRequirement) -> None:
 #ssert not install_req.name
 #elf.unnamed_requirements.append(install_req)

 #ef add_named_requirement(self, install_req: InstallRequirement) -> None:
 #ssert install_req.name

 #roject_name = canonicalize_name(install_req.name)
 #elf.requirements[project_name] = install_req

 #ef has_requirement(self, name: str) -> bool:
 #roject_name = canonicalize_name(name)

 #eturn (
 #roject_name in self.requirements
 #nd not self.requirements[project_name].constraint
 #

 #ef get_requirement(self, name: str) -> InstallRequirement:
 #roject_name = canonicalize_name(name)

 #f project_name in self.requirements:
 #eturn self.requirements[project_name]

 #aise KeyError(f"No project with the name {name!r}")

 #property
 #ef all_requirements(self) -> List[InstallRequirement]:
 #eturn self.unnamed_requirements + list(self.requirements.values())

 #property
 #ef requirements_to_install(self) -> List[InstallRequirement]:
 #""Return the list of requirements that need to be installed.

 #ODO remove this property together with the legacy resolver, since the new
 #esolver only returns requirements that need to be installed.
 #""
 #eturn [
 #nstall_req
 #or install_req in self.all_requirements
 #f not install_req.constraint and not install_req.satisfied_by
 #

 #ef warn_legacy_versions_and_specifiers(self) -> None:
 #or req in self.requirements_to_install:
 #ersion = req.get_dist().version
 #f isinstance(version, LegacyVersion):
 #eprecated(
 #eason=(
 #"pip has selected the non standard version {version} "
 #"of {req}. In the future this version will be "
 #"ignored as it isn't standard compliant."
 #,
 #eplacement=(
 #set or update constraints to select another version "
 #or contact the package author to fix the version number"
 #,
 #ssue=12063,
 #one_in="24.1",
 #
 #or dep in req.get_dist().iter_dependencies():
 #f any(isinstance(spec, LegacySpecifier) for spec in dep.specifier):
 #eprecated(
 #eason=(
 #"pip has selected {req} {version} which has non "
 #"standard dependency specifier {dep}. "
 #"In the future this version of {req} will be "
 #"ignored as it isn't standard compliant."
 #,
 #eplacement=(
 #set or update constraints to select another version "
 #or contact the package author to fix the version number"
 #,
 #ssue=12063,
 #one_in="24.1",
 #
