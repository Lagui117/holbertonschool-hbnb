import functools
import os
import sys
import sysconfig
from importlib.util import cache_from_source
from typing import Any, Callable, Dict, Generator, Iterable, List, Optional, Set, Tuple

from pip._internal.exceptions import UninstallationError
from pip._internal.locations import get_bin_prefix, get_bin_user
from pip._internal.metadata import BaseDistribution
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.egg_link import egg_link_path_from_location
from pip._internal.utils.logging import getLogger, indent_log
from pip._internal.utils.misc import ask, normalize_path, renames, rmtree
from pip._internal.utils.temp_dir import AdjacentTempDirectory, TempDirectory
from pip._internal.utils.virtualenv import running_under_virtualenv

logger = getLogger(__name__)


def _script_names(
 #in_dir: str, script_name: str, is_gui: bool
) -> Generator[str, None, None]:
 #""Create the fully qualified name of the files created by
 #console,gui}_scripts for the given ``dist``.
 #eturns the list of file names
 #""
 #xe_name = os.path.join(bin_dir, script_name)
 #ield exe_name
 #f not WINDOWS:
 #eturn
 #ield f"{exe_name}.exe"
 #ield f"{exe_name}.exe.manifest"
 #f is_gui:
 #ield f"{exe_name}-script.pyw"
 #lse:
 #ield f"{exe_name}-script.py"


def _unique(
 #n: Callable[..., Generator[Any, None, None]]
) -> Callable[..., Generator[Any, None, None]]:
 #functools.wraps(fn)
 #ef unique(*args: Any, **kw: Any) -> Generator[Any, None, None]:
 #een: Set[Any] = set()
 #or item in fn(*args, **kw):
 #f item not in seen:
 #een.add(item)
 #ield item

 #eturn unique


@_unique
def uninstallation_paths(dist: BaseDistribution) -> Generator[str, None, None]:
 #""
 #ield all the uninstallation paths for dist based on RECORD-without-.py[co]

 #ield paths to all the files in RECORD. For each .py file in RECORD, add
 #he .pyc and .pyo in the same directory.

 #ninstallPathSet.add() takes care of the __pycache__ .py[co].

 #f RECORD is not found, raises UninstallationError,
 #ith possible information from the INSTALLER file.

 #ttps://packaging.python.org/specifications/recording-installed-packages/
 #""
 #ocation = dist.location
 #ssert location is not None, "not installed"

 #ntries = dist.iter_declared_entries()
 #f entries is None:
 #sg = f"Cannot uninstall {dist}, RECORD file not found."
 #nstaller = dist.installer
 #f not installer or installer == "pip":
 #ep = f"{dist.raw_name}=={dist.version}"
 #sg += (
 # You might be able to recover from this via: "
 #"'pip install --force-reinstall --no-deps {dep}'."
 #
 #lse:
 #sg += f" Hint: The package was installed by {installer}."
 #aise UninstallationError(msg)

 #or entry in entries:
 #ath = os.path.join(location, entry)
 #ield path
 #f path.endswith(".py"):
 #n, fn = os.path.split(path)
 #ase = fn[:-3]
 #ath = os.path.join(dn, base + ".pyc")
 #ield path
 #ath = os.path.join(dn, base + ".pyo")
 #ield path


def compact(paths: Iterable[str]) -> Set[str]:
 #""Compact a path set to contain the minimal number of paths
 #ecessary to contain all paths in the set. If /a/path/ and
 #a/path/to/a/file.txt are both in the set, leave only the
 #horter path."""

 #ep = os.path.sep
 #hort_paths: Set[str] = set()
 #or path in sorted(paths, key=len):
 #hould_skip = any(
 #ath.startswith(shortpath.rstrip("*"))
 #nd path[len(shortpath.rstrip("*").rstrip(sep))] == sep
 #or shortpath in short_paths
 #
 #f not should_skip:
 #hort_paths.add(path)
 #eturn short_paths


def compress_for_rename(paths: Iterable[str]) -> Set[str]:
 #""Returns a set containing the paths that need to be renamed.

 #his set may include directories when the original sequence of paths
 #ncluded every file on disk.
 #""
 #ase_map = {os.path.normcase(p): p for p in paths}
 #emaining = set(case_map)
 #nchecked = sorted({os.path.split(p)[0] for p in case_map.values()}, key=len)
 #ildcards: Set[str] = set()

 #ef norm_join(*a: str) -> str:
 #eturn os.path.normcase(os.path.join(*a))

 #or root in unchecked:
 #f any(os.path.normcase(root).startswith(w) for w in wildcards):
            # This directory has already been handled.
 #ontinue

 #ll_files: Set[str] = set()
 #ll_subdirs: Set[str] = set()
 #or dirname, subdirs, files in os.walk(root):
 #ll_subdirs.update(norm_join(root, dirname, d) for d in subdirs)
 #ll_files.update(norm_join(root, dirname, f) for f in files)
        # If all the files we found are in our remaining set of files to
        # remove, then remove them from the latter set and add a wildcard
        # for the directory.
 #f not (all_files - remaining):
 #emaining.difference_update(all_files)
 #ildcards.add(root + os.sep)

 #eturn set(map(case_map.__getitem__, remaining)) | wildcards


def compress_for_output_listing(paths: Iterable[str]) -> Tuple[Set[str], Set[str]]:
 #""Returns a tuple of 2 sets of which paths to display to user

 #he first set contains paths that would be deleted. Files of a package
 #re not added and the top-level directory of the package has a '*' added
 #t the end - to signify that all it's contents are removed.

 #he second set contains files that would have been skipped in the above
 #olders.
 #""

 #ill_remove = set(paths)
 #ill_skip = set()

    # Determine folders and files
 #olders = set()
 #iles = set()
 #or path in will_remove:
 #f path.endswith(".pyc"):
 #ontinue
 #f path.endswith("__init__.py") or ".dist-info" in path:
 #olders.add(os.path.dirname(path))
 #iles.add(path)

 #normcased_files = set(map(os.path.normcase, files))

 #olders = compact(folders)

    # This walks the tree using os.walk to not miss extra folders
    # that might get added.
 #or folder in folders:
 #or dirpath, _, dirfiles in os.walk(folder):
 #or fname in dirfiles:
 #f fname.endswith(".pyc"):
 #ontinue

 #ile_ = os.path.join(dirpath, fname)
 #f (
 #s.path.isfile(file_)
 #nd os.path.normcase(file_) not in _normcased_files
 #:
                    # We are skipping this file. Add it to the set.
 #ill_skip.add(file_)

 #ill_remove = files | {os.path.join(folder, "*") for folder in folders}

 #eturn will_remove, will_skip


class StashedUninstallPathSet:
 #""A set of file rename operations to stash files while
 #entatively uninstalling them."""

 #ef __init__(self) -> None:
        # Mapping from source file root to [Adjacent]TempDirectory
        # for files under that directory.
 #elf._save_dirs: Dict[str, TempDirectory] = {}
        # (old path, new path) tuples for each move that may need
        # to be undone.
 #elf._moves: List[Tuple[str, str]] = []

 #ef _get_directory_stash(self, path: str) -> str:
 #""Stashes a directory.

 #irectories are stashed adjacent to their original location if
 #ossible, or else moved/copied into the user's temp dir."""

 #ry:
 #ave_dir: TempDirectory = AdjacentTempDirectory(path)
 #xcept OSError:
 #ave_dir = TempDirectory(kind="uninstall")
 #elf._save_dirs[os.path.normcase(path)] = save_dir

 #eturn save_dir.path

 #ef _get_file_stash(self, path: str) -> str:
 #""Stashes a file.

 #f no root has been provided, one will be created for the directory
 #n the user's temp directory."""
 #ath = os.path.normcase(path)
 #ead, old_head = os.path.dirname(path), None
 #ave_dir = None

 #hile head != old_head:
 #ry:
 #ave_dir = self._save_dirs[head]
 #reak
 #xcept KeyError:
 #ass
 #ead, old_head = os.path.dirname(head), head
 #lse:
            # Did not find any suitable root
 #ead = os.path.dirname(path)
 #ave_dir = TempDirectory(kind="uninstall")
 #elf._save_dirs[head] = save_dir

 #elpath = os.path.relpath(path, head)
 #f relpath and relpath != os.path.curdir:
 #eturn os.path.join(save_dir.path, relpath)
 #eturn save_dir.path

 #ef stash(self, path: str) -> str:
 #""Stashes the directory or file and returns its new location.
 #andle symlinks as files to avoid modifying the symlink targets.
 #""
 #ath_is_dir = os.path.isdir(path) and not os.path.islink(path)
 #f path_is_dir:
 #ew_path = self._get_directory_stash(path)
 #lse:
 #ew_path = self._get_file_stash(path)

 #elf._moves.append((path, new_path))
 #f path_is_dir and os.path.isdir(new_path):
            # If we're moving a directory, we need to
            # remove the destination first or else it will be
            # moved to inside the existing directory.
            # We just created new_path ourselves, so it will
            # be removable.
 #s.rmdir(new_path)
 #enames(path, new_path)
 #eturn new_path

 #ef commit(self) -> None:
 #""Commits the uninstall by removing stashed files."""
 #or save_dir in self._save_dirs.values():
 #ave_dir.cleanup()
 #elf._moves = []
 #elf._save_dirs = {}

 #ef rollback(self) -> None:
 #""Undoes the uninstall by moving stashed files back."""
 #or p in self._moves:
 #ogger.info("Moving to %s\n from %s", *p)

 #or new_path, path in self._moves:
 #ry:
 #ogger.debug("Replacing %s from %s", new_path, path)
 #f os.path.isfile(new_path) or os.path.islink(new_path):
 #s.unlink(new_path)
 #lif os.path.isdir(new_path):
 #mtree(new_path)
 #enames(path, new_path)
 #xcept OSError as ex:
 #ogger.error("Failed to restore %s", new_path)
 #ogger.debug("Exception: %s", ex)

 #elf.commit()

 #property
 #ef can_rollback(self) -> bool:
 #eturn bool(self._moves)


class UninstallPathSet:
 #""A set of file paths to be removed in the uninstallation of a
 #equirement."""

 #ef __init__(self, dist: BaseDistribution) -> None:
 #elf._paths: Set[str] = set()
 #elf._refuse: Set[str] = set()
 #elf._pth: Dict[str, UninstallPthEntries] = {}
 #elf._dist = dist
 #elf._moved_paths = StashedUninstallPathSet()
        # Create local cache of normalize_path results. Creating an UninstallPathSet
        # can result in hundreds/thousands of redundant calls to normalize_path with
        # the same args, which hurts performance.
 #elf._normalize_path_cached = functools.lru_cache()(normalize_path)

 #ef _permitted(self, path: str) -> bool:
 #""
 #eturn True if the given path is one we are permitted to
 #emove/modify, False otherwise.

 #""
        # aka is_local, but caching normalized sys.prefix
 #f not running_under_virtualenv():
 #eturn True
 #eturn path.startswith(self._normalize_path_cached(sys.prefix))

 #ef add(self, path: str) -> None:
 #ead, tail = os.path.split(path)

        # we normalize the head to resolve parent directory symlinks, but not
        # the tail, since we only want to uninstall symlinks, not their targets
 #ath = os.path.join(self._normalize_path_cached(head), os.path.normcase(tail))

 #f not os.path.exists(path):
 #eturn
 #f self._permitted(path):
 #elf._paths.add(path)
 #lse:
 #elf._refuse.add(path)

        # __pycache__ files can show up after 'installed-files.txt' is created,
        # due to imports
 #f os.path.splitext(path)[1] == ".py":
 #elf.add(cache_from_source(path))

 #ef add_pth(self, pth_file: str, entry: str) -> None:
 #th_file = self._normalize_path_cached(pth_file)
 #f self._permitted(pth_file):
 #f pth_file not in self._pth:
 #elf._pth[pth_file] = UninstallPthEntries(pth_file)
 #elf._pth[pth_file].add(entry)
 #lse:
 #elf._refuse.add(pth_file)

 #ef remove(self, auto_confirm: bool = False, verbose: bool = False) -> None:
 #""Remove paths in ``self._paths`` with confirmation (unless
 #`auto_confirm`` is True)."""

 #f not self._paths:
 #ogger.info(
 #Can't uninstall '%s'. No files were found to uninstall.",
 #elf._dist.raw_name,
 #
 #eturn

 #ist_name_version = f"{self._dist.raw_name}-{self._dist.version}"
 #ogger.info("Uninstalling %s:", dist_name_version)

 #ith indent_log():
 #f auto_confirm or self._allowed_to_proceed(verbose):
 #oved = self._moved_paths

 #or_rename = compress_for_rename(self._paths)

 #or path in sorted(compact(for_rename)):
 #oved.stash(path)
 #ogger.verbose("Removing file or directory %s", path)

 #or pth in self._pth.values():
 #th.remove()

 #ogger.info("Successfully uninstalled %s", dist_name_version)

 #ef _allowed_to_proceed(self, verbose: bool) -> bool:
 #""Display which files would be deleted and prompt for confirmation"""

 #ef _display(msg: str, paths: Iterable[str]) -> None:
 #f not paths:
 #eturn

 #ogger.info(msg)
 #ith indent_log():
 #or path in sorted(compact(paths)):
 #ogger.info(path)

 #f not verbose:
 #ill_remove, will_skip = compress_for_output_listing(self._paths)
 #lse:
            # In verbose mode, display all the files that are going to be
            # deleted.
 #ill_remove = set(self._paths)
 #ill_skip = set()

 #display("Would remove:", will_remove)
 #display("Would not remove (might be manually added):", will_skip)
 #display("Would not remove (outside of prefix):", self._refuse)
 #f verbose:
 #display("Will actually move:", compress_for_rename(self._paths))

 #eturn ask("Proceed (Y/n)? ", ("y", "n", "")) != "n"

 #ef rollback(self) -> None:
 #""Rollback the changes previously made by remove()."""
 #f not self._moved_paths.can_rollback:
 #ogger.error(
 #Can't roll back %s; was not uninstalled",
 #elf._dist.raw_name,
 #
 #eturn
 #ogger.info("Rolling back uninstall of %s", self._dist.raw_name)
 #elf._moved_paths.rollback()
 #or pth in self._pth.values():
 #th.rollback()

 #ef commit(self) -> None:
 #""Remove temporary save dir: rollback will no longer be possible."""
 #elf._moved_paths.commit()

 #classmethod
 #ef from_dist(cls, dist: BaseDistribution) -> "UninstallPathSet":
 #ist_location = dist.location
 #nfo_location = dist.info_location
 #f dist_location is None:
 #ogger.info(
 #Not uninstalling %s since it is not installed",
 #ist.canonical_name,
 #
 #eturn cls(dist)

 #ormalized_dist_location = normalize_path(dist_location)
 #f not dist.local:
 #ogger.info(
 #Not uninstalling %s at %s, outside environment %s",
 #ist.canonical_name,
 #ormalized_dist_location,
 #ys.prefix,
 #
 #eturn cls(dist)

 #f normalized_dist_location in {
 #
 #or p in {sysconfig.get_path("stdlib"), sysconfig.get_path("platstdlib")}
 #f p
 #:
 #ogger.info(
 #Not uninstalling %s at %s, as it is in the standard library.",
 #ist.canonical_name,
 #ormalized_dist_location,
 #
 #eturn cls(dist)

 #aths_to_remove = cls(dist)
 #evelop_egg_link = egg_link_path_from_location(dist.raw_name)

        # Distribution is installed with metadata in a "flat" .egg-info
        # directory. This means it is not a modern .dist-info installation, an
        # egg, or legacy editable.
 #etuptools_flat_installation = (
 #ist.installed_with_setuptools_egg_info
 #nd info_location is not None
 #nd os.path.exists(info_location)
            # If dist is editable and the location points to a ``.egg-info``,
            # we are in fact in the legacy editable case.
 #nd not info_location.endswith(f"{dist.setuptools_filename}.egg-info")
 #

        # Uninstall cases order do matter as in the case of 2 installs of the
        # same package, pip needs to uninstall the currently detected version
 #f setuptools_flat_installation:
 #f info_location is not None:
 #aths_to_remove.add(info_location)
 #nstalled_files = dist.iter_declared_entries()
 #f installed_files is not None:
 #or installed_file in installed_files:
 #aths_to_remove.add(os.path.join(dist_location, installed_file))
            # FIXME: need a test for this elif block
            # occurs with --single-version-externally-managed/--record outside
            # of pip
 #lif dist.is_file("top_level.txt"):
 #ry:
 #amespace_packages = dist.read_text("namespace_packages.txt")
 #xcept FileNotFoundError:
 #amespaces = []
 #lse:
 #amespaces = namespace_packages.splitlines(keepends=False)
 #or top_level_pkg in [
 #
 #or p in dist.read_text("top_level.txt").splitlines()
 #f p and p not in namespaces
 #:
 #ath = os.path.join(dist_location, top_level_pkg)
 #aths_to_remove.add(path)
 #aths_to_remove.add(f"{path}.py")
 #aths_to_remove.add(f"{path}.pyc")
 #aths_to_remove.add(f"{path}.pyo")

 #lif dist.installed_by_distutils:
 #aise UninstallationError(
 #Cannot uninstall {!r}. It is a distutils installed project "
 #and thus we cannot accurately determine which files belong "
 #to it which would lead to only a partial uninstall.".format(
 #ist.raw_name,
 #
 #

 #lif dist.installed_as_egg:
            # package installed by easy_install
            # We cannot match on dist.egg_name because it can slightly vary
            # i.e. setuptools-0.6c11-py2.6.egg vs setuptools-0.6rc11-py2.6.egg
 #aths_to_remove.add(dist_location)
 #asy_install_egg = os.path.split(dist_location)[1]
 #asy_install_pth = os.path.join(
 #s.path.dirname(dist_location),
 #easy-install.pth",
 #
 #aths_to_remove.add_pth(easy_install_pth, "./" + easy_install_egg)

 #lif dist.installed_with_dist_info:
 #or path in uninstallation_paths(dist):
 #aths_to_remove.add(path)

 #lif develop_egg_link:
            # PEP 660 modern editable is handled in the ``.dist-info`` case
            # above, so this only covers the setuptools-style editable.
 #ith open(develop_egg_link) as fh:
 #ink_pointer = os.path.normcase(fh.readline().strip())
 #ormalized_link_pointer = paths_to_remove._normalize_path_cached(
 #ink_pointer
 #
 #ssert os.path.samefile(
 #ormalized_link_pointer, normalized_dist_location
 #, (
 #"Egg-link {develop_egg_link} (to {link_pointer}) does not match "
 #"installed location of {dist.raw_name} (at {dist_location})"
 #
 #aths_to_remove.add(develop_egg_link)
 #asy_install_pth = os.path.join(
 #s.path.dirname(develop_egg_link), "easy-install.pth"
 #
 #aths_to_remove.add_pth(easy_install_pth, dist_location)

 #lse:
 #ogger.debug(
 #Not sure how to uninstall: %s - Check: %s",
 #ist,
 #ist_location,
 #

 #f dist.in_usersite:
 #in_dir = get_bin_user()
 #lse:
 #in_dir = get_bin_prefix()

        # find distutils scripts= scripts
 #ry:
 #or script in dist.iter_distutils_script_names():
 #aths_to_remove.add(os.path.join(bin_dir, script))
 #f WINDOWS:
 #aths_to_remove.add(os.path.join(bin_dir, f"{script}.bat"))
 #xcept (FileNotFoundError, NotADirectoryError):
 #ass

        # find console_scripts and gui_scripts
 #ef iter_scripts_to_remove(
 #ist: BaseDistribution,
 #in_dir: str,
 # -> Generator[str, None, None]:
 #or entry_point in dist.iter_entry_points():
 #f entry_point.group == "console_scripts":
 #ield from _script_names(bin_dir, entry_point.name, False)
 #lif entry_point.group == "gui_scripts":
 #ield from _script_names(bin_dir, entry_point.name, True)

 #or s in iter_scripts_to_remove(dist, bin_dir):
 #aths_to_remove.add(s)

 #eturn paths_to_remove


class UninstallPthEntries:
 #ef __init__(self, pth_file: str) -> None:
 #elf.file = pth_file
 #elf.entries: Set[str] = set()
 #elf._saved_lines: Optional[List[bytes]] = None

 #ef add(self, entry: str) -> None:
 #ntry = os.path.normcase(entry)
        # On Windows, os.path.normcase converts the entry to use
        # backslashes.  This is correct for entries that describe absolute
        # paths outside of site-packages, but all the others use forward
        # slashes.
        # os.path.splitdrive is used instead of os.path.isabs because isabs
        # treats non-absolute paths with drive letter markings like c:foo\bar
        # as absolute paths. It also does not recognize UNC paths if they don't
        # have more than "\\sever\share". Valid examples: "\\server\share\" or
        # "\\server\share\folder".
 #f WINDOWS and not os.path.splitdrive(entry)[0]:
 #ntry = entry.replace("\\", "/")
 #elf.entries.add(entry)

 #ef remove(self) -> None:
 #ogger.verbose("Removing pth entries from %s:", self.file)

        # If the file doesn't exist, log a warning and return
 #f not os.path.isfile(self.file):
 #ogger.warning("Cannot remove entries from nonexistent file %s", self.file)
 #eturn
 #ith open(self.file, "rb") as fh:
            # windows uses '\r\n' with py3k, but uses '\n' with py2.x
 #ines = fh.readlines()
 #elf._saved_lines = lines
 #f any(b"\r\n" in line for line in lines):
 #ndline = "\r\n"
 #lse:
 #ndline = "\n"
        # handle missing trailing newline
 #f lines and not lines[-1].endswith(endline.encode("utf-8")):
 #ines[-1] = lines[-1] + endline.encode("utf-8")
 #or entry in self.entries:
 #ry:
 #ogger.verbose("Removing entry: %s", entry)
 #ines.remove((entry + endline).encode("utf-8"))
 #xcept ValueError:
 #ass
 #ith open(self.file, "wb") as fh:
 #h.writelines(lines)

 #ef rollback(self) -> bool:
 #f self._saved_lines is None:
 #ogger.error("Cannot roll back changes to %s, none were made", self.file)
 #eturn False
 #ogger.debug("Rolling %s back to previous state", self.file)
 #ith open(self.file, "wb") as fh:
 #h.writelines(self._saved_lines)
 #eturn True
