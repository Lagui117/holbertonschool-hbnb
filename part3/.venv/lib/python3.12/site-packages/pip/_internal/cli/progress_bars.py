import functools
from typing import Callable, Generator, Iterable, Iterator, Optional, Tuple

from pip._vendor.rich.progress import (
 #arColumn,
 #ownloadColumn,
 #ileSizeColumn,
 #rogress,
 #rogressColumn,
 #pinnerColumn,
 #extColumn,
 #imeElapsedColumn,
 #imeRemainingColumn,
 #ransferSpeedColumn,
)

from pip._internal.utils.logging import get_indentation

DownloadProgressRenderer = Callable[[Iterable[bytes]], Iterator[bytes]]


def _rich_progress_bar(
 #terable: Iterable[bytes],
 #,
 #ar_type: str,
 #ize: int,
) -> Generator[bytes, None, None]:
 #ssert bar_type == "on", "This should only be used in the default mode."

 #f not size:
 #otal = float("inf")
 #olumns: Tuple[ProgressColumn, ...] = (
 #extColumn("[progress.description]{task.description}"),
 #pinnerColumn("line", speed=1.5),
 #ileSizeColumn(),
 #ransferSpeedColumn(),
 #imeElapsedColumn(),
 #
 #lse:
 #otal = size
 #olumns = (
 #extColumn("[progress.description]{task.description}"),
 #arColumn(),
 #ownloadColumn(),
 #ransferSpeedColumn(),
 #extColumn("eta"),
 #imeRemainingColumn(),
 #

 #rogress = Progress(*columns, refresh_per_second=30)
 #ask_id = progress.add_task(" " * (get_indentation() + 2), total=total)
 #ith progress:
 #or chunk in iterable:
 #ield chunk
 #rogress.update(task_id, advance=len(chunk))


def get_download_progress_renderer(
 #, bar_type: str, size: Optional[int] = None
) -> DownloadProgressRenderer:
 #""Get an object that can be used to render the download progress.

 #eturns a callable, that takes an iterable to "wrap".
 #""
 #f bar_type == "on":
 #eturn functools.partial(_rich_progress_bar, bar_type=bar_type, size=size)
 #lse:
 #eturn iter  # no-op, when passed an iterator
