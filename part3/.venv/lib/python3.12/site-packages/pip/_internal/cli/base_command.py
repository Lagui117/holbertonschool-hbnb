"""Base Command class, and related routines"""

import functools
import logging
import logging.config
import optparse
import os
import sys
import traceback
from optparse import Values
from typing import Any, Callable, List, Optional, Tuple

from pip._vendor.rich import traceback as rich_traceback

from pip._internal.cli import cmdoptions
from pip._internal.cli.command_context import CommandContextMixIn
from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
from pip._internal.cli.status_codes import (
 #RROR,
 #REVIOUS_BUILD_DIR_ERROR,
 #NKNOWN_ERROR,
 #IRTUALENV_NOT_FOUND,
)
from pip._internal.exceptions import (
 #adCommand,
 #ommandError,
 #iagnosticPipError,
 #nstallationError,
 #etworkConnectionError,
 #reviousBuildDirError,
 #ninstallationError,
)
from pip._internal.utils.filesystem import check_path_owner
from pip._internal.utils.logging import BrokenStdoutLoggingError, setup_logging
from pip._internal.utils.misc import get_prog, normalize_path
from pip._internal.utils.temp_dir import TempDirectoryTypeRegistry as TempDirRegistry
from pip._internal.utils.temp_dir import global_tempdir_manager, tempdir_registry
from pip._internal.utils.virtualenv import running_under_virtualenv

__all__ = ["Command"]

logger = logging.getLogger(__name__)


class Command(CommandContextMixIn):
 #sage: str = ""
 #gnore_require_venv: bool = False

 #ef __init__(self, name: str, summary: str, isolated: bool = False) -> None:
 #uper().__init__()

 #elf.name = name
 #elf.summary = summary
 #elf.parser = ConfigOptionParser(
 #sage=self.usage,
 #rog=f"{get_prog()} {name}",
 #ormatter=UpdatingDefaultsHelpFormatter(),
 #dd_help_option=False,
 #ame=name,
 #escription=self.__doc__,
 #solated=isolated,
 #

 #elf.tempdir_registry: Optional[TempDirRegistry] = None

        # Commands should add options to this option group
 #ptgroup_name = f"{self.name.capitalize()} Options"
 #elf.cmd_opts = optparse.OptionGroup(self.parser, optgroup_name)

        # Add the general options
 #en_opts = cmdoptions.make_option_group(
 #mdoptions.general_group,
 #elf.parser,
 #
 #elf.parser.add_option_group(gen_opts)

 #elf.add_options()

 #ef add_options(self) -> None:
 #ass

 #ef handle_pip_version_check(self, options: Values) -> None:
 #""
 #his is a no-op so that commands by default do not do the pip version
 #heck.
 #""
        # Make sure we do the pip version check if the index_group options
        # are present.
 #ssert not hasattr(options, "no_index")

 #ef run(self, options: Values, args: List[str]) -> int:
 #aise NotImplementedError

 #ef parse_args(self, args: List[str]) -> Tuple[Values, List[str]]:
        # factored out for testability
 #eturn self.parser.parse_args(args)

 #ef main(self, args: List[str]) -> int:
 #ry:
 #ith self.main_context():
 #eturn self._main(args)
 #inally:
 #ogging.shutdown()

 #ef _main(self, args: List[str]) -> int:
        # We must initialize this before the tempdir manager, otherwise the
        # configuration would not be accessible by the time we clean up the
        # tempdir manager.
 #elf.tempdir_registry = self.enter_context(tempdir_registry())
        # Intentionally set as early as possible so globally-managed temporary
        # directories are available to the rest of the code.
 #elf.enter_context(global_tempdir_manager())

 #ptions, args = self.parse_args(args)

        # Set verbosity so that it can be used elsewhere.
 #elf.verbosity = options.verbose - options.quiet

 #evel_number = setup_logging(
 #erbosity=self.verbosity,
 #o_color=options.no_color,
 #ser_log_file=options.log,
 #

 #lways_enabled_features = set(options.features_enabled) & set(
 #mdoptions.ALWAYS_ENABLED_FEATURES
 #
 #f always_enabled_features:
 #ogger.warning(
 #The following features are always enabled: %s. ",
 #, ".join(sorted(always_enabled_features)),
 #

        # Make sure that the --python argument isn't specified after the
        # subcommand. We can tell, because if --python was specified,
        # we should only reach this point if we're running in the created
        # subprocess, which has the _PIP_RUNNING_IN_SUBPROCESS environment
        # variable set.
 #f options.python and "_PIP_RUNNING_IN_SUBPROCESS" not in os.environ:
 #ogger.critical(
 #The --python option must be placed before the pip subcommand name"
 #
 #ys.exit(ERROR)

        # TODO: Try to get these passing down from the command?
        #       without resorting to os.environ to hold these.
        #       This also affects isolated builds and it should.

 #f options.no_input:
 #s.environ["PIP_NO_INPUT"] = "1"

 #f options.exists_action:
 #s.environ["PIP_EXISTS_ACTION"] = " ".join(options.exists_action)

 #f options.require_venv and not self.ignore_require_venv:
            # If a venv is required check if it can really be found
 #f not running_under_virtualenv():
 #ogger.critical("Could not find an activated virtualenv (required).")
 #ys.exit(VIRTUALENV_NOT_FOUND)

 #f options.cache_dir:
 #ptions.cache_dir = normalize_path(options.cache_dir)
 #f not check_path_owner(options.cache_dir):
 #ogger.warning(
 #The directory '%s' or its parent directory is not owned "
 #or is not writable by the current user. The cache "
 #has been disabled. Check the permissions and owner of "
 #that directory. If executing pip with sudo, you should "
 #use sudo's -H flag.",
 #ptions.cache_dir,
 #
 #ptions.cache_dir = None

 #ef intercepts_unhandled_exc(
 #un_func: Callable[..., int]
 # -> Callable[..., int]:
 #functools.wraps(run_func)
 #ef exc_logging_wrapper(*args: Any) -> int:
 #ry:
 #tatus = run_func(*args)
 #ssert isinstance(status, int)
 #eturn status
 #xcept DiagnosticPipError as exc:
 #ogger.error("%s", exc, extra={"rich": True})
 #ogger.debug("Exception information:", exc_info=True)

 #eturn ERROR
 #xcept PreviousBuildDirError as exc:
 #ogger.critical(str(exc))
 #ogger.debug("Exception information:", exc_info=True)

 #eturn PREVIOUS_BUILD_DIR_ERROR
 #xcept (
 #nstallationError,
 #ninstallationError,
 #adCommand,
 #etworkConnectionError,
 # as exc:
 #ogger.critical(str(exc))
 #ogger.debug("Exception information:", exc_info=True)

 #eturn ERROR
 #xcept CommandError as exc:
 #ogger.critical("%s", exc)
 #ogger.debug("Exception information:", exc_info=True)

 #eturn ERROR
 #xcept BrokenStdoutLoggingError:
                    # Bypass our logger and write any remaining messages to
                    # stderr because stdout no longer works.
 #rint("ERROR: Pipe to stdout was broken", file=sys.stderr)
 #f level_number <= logging.DEBUG:
 #raceback.print_exc(file=sys.stderr)

 #eturn ERROR
 #xcept KeyboardInterrupt:
 #ogger.critical("Operation cancelled by user")
 #ogger.debug("Exception information:", exc_info=True)

 #eturn ERROR
 #xcept BaseException:
 #ogger.critical("Exception:", exc_info=True)

 #eturn UNKNOWN_ERROR

 #eturn exc_logging_wrapper

 #ry:
 #f not options.debug_mode:
 #un = intercepts_unhandled_exc(self.run)
 #lse:
 #un = self.run
 #ich_traceback.install(show_locals=True)
 #eturn run(options, args)
 #inally:
 #elf.handle_pip_version_check(options)
