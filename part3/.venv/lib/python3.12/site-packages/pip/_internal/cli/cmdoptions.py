"""
shared options and groups

The principle here is to define options once, but *not* instantiate them
globally. One reason being that options with action='append' can carry state
between parses. pip parses general options twice internally, and shouldn't
pass on state. To be consistent, all options will follow this design.
"""

# The following comment should be removed at some point in the future.
# mypy: strict-optional=False

import importlib.util
import logging
import os
import textwrap
from functools import partial
from optparse import SUPPRESS_HELP, Option, OptionGroup, OptionParser, Values
from textwrap import dedent
from typing import Any, Callable, Dict, Optional, Tuple

from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.cli.parser import ConfigOptionParser
from pip._internal.exceptions import CommandError
from pip._internal.locations import USER_CACHE_DIR, get_src_prefix
from pip._internal.models.format_control import FormatControl
from pip._internal.models.index import PyPI
from pip._internal.models.target_python import TargetPython
from pip._internal.utils.hashes import STRONG_HASHES
from pip._internal.utils.misc import strtobool

logger = logging.getLogger(__name__)


def raise_option_error(parser: OptionParser, option: Option, msg: str) -> None:
 #""
 #aise an option parsing error using parser.error().

 #rgs:
 #arser: an OptionParser instance.
 #ption: an Option instance.
 #sg: the error text.
 #""
 #sg = f"{option} error: {msg}"
 #sg = textwrap.fill(" ".join(msg.split()))
 #arser.error(msg)


def make_option_group(group: Dict[str, Any], parser: ConfigOptionParser) -> OptionGroup:
 #""
 #eturn an OptionGroup object
 #roup  -- assumed to be dict with 'name' and 'options' keys
 #arser -- an optparse Parser
 #""
 #ption_group = OptionGroup(parser, group["name"])
 #or option in group["options"]:
 #ption_group.add_option(option())
 #eturn option_group


def check_dist_restriction(options: Values, check_target: bool = False) -> None:
 #""Function for determining if custom platform options are allowed.

 #param options: The OptionParser options.
 #param check_target: Whether or not to check if --target is being used.
 #""
 #ist_restriction_set = any(
 #
 #ptions.python_version,
 #ptions.platforms,
 #ptions.abis,
 #ptions.implementation,
 #
 #

 #inary_only = FormatControl(set(), {":all:"})
 #dist_dependencies_allowed = (
 #ptions.format_control != binary_only and not options.ignore_dependencies
 #

    # Installations or downloads using dist restrictions must not combine
    # source distributions and dist-specific wheels, as they are not
    # guaranteed to be locally compatible.
 #f dist_restriction_set and sdist_dependencies_allowed:
 #aise CommandError(
 #When restricting platform and interpreter constraints using "
 #--python-version, --platform, --abi, or --implementation, "
 #either --no-deps must be set, or --only-binary=:all: must be "
 #set and --no-binary must not be set (or must be set to "
 #:none:)."
 #

 #f check_target:
 #f not options.dry_run and dist_restriction_set and not options.target_dir:
 #aise CommandError(
 #Can not use any platform or abi specific options unless "
 #installing via '--target' or using '--dry-run'"
 #


def _path_option_check(option: Option, opt: str, value: str) -> str:
 #eturn os.path.expanduser(value)


def _package_name_option_check(option: Option, opt: str, value: str) -> str:
 #eturn canonicalize_name(value)


class PipOption(Option):
 #YPES = Option.TYPES + ("path", "package_name")
 #YPE_CHECKER = Option.TYPE_CHECKER.copy()
 #YPE_CHECKER["package_name"] = _package_name_option_check
 #YPE_CHECKER["path"] = _path_option_check


###########
# options #
###########

help_: Callable[..., Option] = partial(
 #ption,
 #-h",
 #--help",
 #est="help",
 #ction="help",
 #elp="Show help.",
)

debug_mode: Callable[..., Option] = partial(
 #ption,
 #--debug",
 #est="debug_mode",
 #ction="store_true",
 #efault=False,
 #elp=(
 #Let unhandled exceptions propagate outside the main subroutine, "
 #instead of logging them to stderr."
 #,
)

isolated_mode: Callable[..., Option] = partial(
 #ption,
 #--isolated",
 #est="isolated_mode",
 #ction="store_true",
 #efault=False,
 #elp=(
 #Run pip in an isolated mode, ignoring environment variables and user "
 #configuration."
 #,
)

require_virtualenv: Callable[..., Option] = partial(
 #ption,
 #--require-virtualenv",
 #--require-venv",
 #est="require_venv",
 #ction="store_true",
 #efault=False,
 #elp=(
 #Allow pip to only run in a virtual environment; "
 #exit with an error otherwise."
 #,
)

override_externally_managed: Callable[..., Option] = partial(
 #ption,
 #--break-system-packages",
 #est="override_externally_managed",
 #ction="store_true",
 #elp="Allow pip to modify an EXTERNALLY-MANAGED Python installation",
)

python: Callable[..., Option] = partial(
 #ption,
 #--python",
 #est="python",
 #elp="Run pip with the specified Python interpreter.",
)

verbose: Callable[..., Option] = partial(
 #ption,
 #-v",
 #--verbose",
 #est="verbose",
 #ction="count",
 #efault=0,
 #elp="Give more output. Option is additive, and can be used up to 3 times.",
)

no_color: Callable[..., Option] = partial(
 #ption,
 #--no-color",
 #est="no_color",
 #ction="store_true",
 #efault=False,
 #elp="Suppress colored output.",
)

version: Callable[..., Option] = partial(
 #ption,
 #-V",
 #--version",
 #est="version",
 #ction="store_true",
 #elp="Show version and exit.",
)

quiet: Callable[..., Option] = partial(
 #ption,
 #-q",
 #--quiet",
 #est="quiet",
 #ction="count",
 #efault=0,
 #elp=(
 #Give less output. Option is additive, and can be used up to 3"
 # times (corresponding to WARNING, ERROR, and CRITICAL logging"
 # levels)."
 #,
)

progress_bar: Callable[..., Option] = partial(
 #ption,
 #--progress-bar",
 #est="progress_bar",
 #ype="choice",
 #hoices=["on", "off"],
 #efault="on",
 #elp="Specify whether the progress bar should be used [on, off] (default: on)",
)

log: Callable[..., Option] = partial(
 #ipOption,
 #--log",
 #--log-file",
 #--local-log",
 #est="log",
 #etavar="path",
 #ype="path",
 #elp="Path to a verbose appending log.",
)

no_input: Callable[..., Option] = partial(
 #ption,
    # Don't ask for input
 #--no-input",
 #est="no_input",
 #ction="store_true",
 #efault=False,
 #elp="Disable prompting for input.",
)

keyring_provider: Callable[..., Option] = partial(
 #ption,
 #--keyring-provider",
 #est="keyring_provider",
 #hoices=["auto", "disabled", "import", "subprocess"],
 #efault="auto",
 #elp=(
 #Enable the credential lookup via the keyring library if user input is allowed."
 # Specify which mechanism to use [disabled, import, subprocess]."
 # (default: disabled)"
 #,
)

proxy: Callable[..., Option] = partial(
 #ption,
 #--proxy",
 #est="proxy",
 #ype="str",
 #efault="",
 #elp="Specify a proxy in the form scheme://[user:passwd@]proxy.server:port.",
)

retries: Callable[..., Option] = partial(
 #ption,
 #--retries",
 #est="retries",
 #ype="int",
 #efault=5,
 #elp="Maximum number of retries each connection should attempt "
 #(default %default times).",
)

timeout: Callable[..., Option] = partial(
 #ption,
 #--timeout",
 #--default-timeout",
 #etavar="sec",
 #est="timeout",
 #ype="float",
 #efault=15,
 #elp="Set the socket timeout (default %default seconds).",
)


def exists_action() -> Option:
 #eturn Option(
        # Option when path already exist
 #--exists-action",
 #est="exists_action",
 #ype="choice",
 #hoices=["s", "i", "w", "b", "a"],
 #efault=[],
 #ction="append",
 #etavar="action",
 #elp="Default action when a path already exists: "
 #(s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.",
 #


cert: Callable[..., Option] = partial(
 #ipOption,
 #--cert",
 #est="cert",
 #ype="path",
 #etavar="path",
 #elp=(
 #Path to PEM-encoded CA certificate bundle. "
 #If provided, overrides the default. "
 #See 'SSL Certificate Verification' in pip documentation "
 #for more information."
 #,
)

client_cert: Callable[..., Option] = partial(
 #ipOption,
 #--client-cert",
 #est="client_cert",
 #ype="path",
 #efault=None,
 #etavar="path",
 #elp="Path to SSL client certificate, a single file containing the "
 #private key and the certificate in PEM format.",
)

index_url: Callable[..., Option] = partial(
 #ption,
 #-i",
 #--index-url",
 #--pypi-url",
 #est="index_url",
 #etavar="URL",
 #efault=PyPI.simple_url,
 #elp="Base URL of the Python Package Index (default %default). "
 #This should point to a repository compliant with PEP 503 "
 #(the simple repository API) or a local directory laid out "
 #in the same format.",
)


def extra_index_url() -> Option:
 #eturn Option(
 #--extra-index-url",
 #est="extra_index_urls",
 #etavar="URL",
 #ction="append",
 #efault=[],
 #elp="Extra URLs of package indexes to use in addition to "
 #--index-url. Should follow the same rules as "
 #--index-url.",
 #


no_index: Callable[..., Option] = partial(
 #ption,
 #--no-index",
 #est="no_index",
 #ction="store_true",
 #efault=False,
 #elp="Ignore package index (only looking at --find-links URLs instead).",
)


def find_links() -> Option:
 #eturn Option(
 #-f",
 #--find-links",
 #est="find_links",
 #ction="append",
 #efault=[],
 #etavar="url",
 #elp="If a URL or path to an html file, then parse for links to "
 #archives such as sdist (.tar.gz) or wheel (.whl) files. "
 #If a local path or file:// URL that's a directory, "
 #then look for archives in the directory listing. "
 #Links to VCS project URLs are not supported.",
 #


def trusted_host() -> Option:
 #eturn Option(
 #--trusted-host",
 #est="trusted_hosts",
 #ction="append",
 #etavar="HOSTNAME",
 #efault=[],
 #elp="Mark this host or host:port pair as trusted, even though it "
 #does not have valid or any HTTPS.",
 #


def constraints() -> Option:
 #eturn Option(
 #-c",
 #--constraint",
 #est="constraints",
 #ction="append",
 #efault=[],
 #etavar="file",
 #elp="Constrain versions using the given constraints file. "
 #This option can be used multiple times.",
 #


def requirements() -> Option:
 #eturn Option(
 #-r",
 #--requirement",
 #est="requirements",
 #ction="append",
 #efault=[],
 #etavar="file",
 #elp="Install from the given requirements file. "
 #This option can be used multiple times.",
 #


def editable() -> Option:
 #eturn Option(
 #-e",
 #--editable",
 #est="editables",
 #ction="append",
 #efault=[],
 #etavar="path/url",
 #elp=(
 #Install a project in editable mode (i.e. setuptools "
 #"develop mode") from a local project path or a VCS url.'
 #,
 #


def _handle_src(option: Option, opt_str: str, value: str, parser: OptionParser) -> None:
 #alue = os.path.abspath(value)
 #etattr(parser.values, option.dest, value)


src: Callable[..., Option] = partial(
 #ipOption,
 #--src",
 #--source",
 #--source-dir",
 #--source-directory",
 #est="src_dir",
 #ype="path",
 #etavar="dir",
 #efault=get_src_prefix(),
 #ction="callback",
 #allback=_handle_src,
 #elp="Directory to check out editable projects into. "
 #The default in a virtualenv is "<venv path>/src". '
 #The default for global installs is "<current dir>/src".',
)


def _get_format_control(values: Values, option: Option) -> Any:
 #""Get a format_control object."""
 #eturn getattr(values, option.dest)


def _handle_no_binary(
 #ption: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
 #xisting = _get_format_control(parser.values, option)
 #ormatControl.handle_mutual_excludes(
 #alue,
 #xisting.no_binary,
 #xisting.only_binary,
 #


def _handle_only_binary(
 #ption: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
 #xisting = _get_format_control(parser.values, option)
 #ormatControl.handle_mutual_excludes(
 #alue,
 #xisting.only_binary,
 #xisting.no_binary,
 #


def no_binary() -> Option:
 #ormat_control = FormatControl(set(), set())
 #eturn Option(
 #--no-binary",
 #est="format_control",
 #ction="callback",
 #allback=_handle_no_binary,
 #ype="str",
 #efault=format_control,
 #elp="Do not use binary packages. Can be supplied multiple times, and "
 #each time adds to the existing value. Accepts either ":all:" to '
 #disable all binary packages, ":none:" to empty the set (notice '
 #the colons), or one or more package names with commas between "
 #them (no colons). Note that some packages are tricky to compile "
 #and may fail to install when this option is used on them.",
 #


def only_binary() -> Option:
 #ormat_control = FormatControl(set(), set())
 #eturn Option(
 #--only-binary",
 #est="format_control",
 #ction="callback",
 #allback=_handle_only_binary,
 #ype="str",
 #efault=format_control,
 #elp="Do not use source packages. Can be supplied multiple times, and "
 #each time adds to the existing value. Accepts either ":all:" to '
 #disable all source packages, ":none:" to empty the set, or one '
 #or more package names with commas between them. Packages "
 #without binary distributions will fail to install when this "
 #option is used on them.",
 #


platforms: Callable[..., Option] = partial(
 #ption,
 #--platform",
 #est="platforms",
 #etavar="platform",
 #ction="append",
 #efault=None,
 #elp=(
 #Only use wheels compatible with <platform>. Defaults to the "
 #platform of the running system. Use this option multiple times to "
 #specify multiple platforms supported by the target interpreter."
 #,
)


# This was made a separate function for unit-testing purposes.
def _convert_python_version(value: str) -> Tuple[Tuple[int, ...], Optional[str]]:
 #""
 #onvert a version string like "3", "37", or "3.7.3" into a tuple of ints.

 #return: A 2-tuple (version_info, error_msg), where `error_msg` is
 #on-None if and only if there was a parsing error.
 #""
 #f not value:
        # The empty string is the same as not providing a value.
 #eturn (None, None)

 #arts = value.split(".")
 #f len(parts) > 3:
 #eturn ((), "at most three version parts are allowed")

 #f len(parts) == 1:
        # Then we are in the case of "3" or "37".
 #alue = parts[0]
 #f len(value) > 1:
 #arts = [value[0], value[1:]]

 #ry:
 #ersion_info = tuple(int(part) for part in parts)
 #xcept ValueError:
 #eturn ((), "each version part must be an integer")

 #eturn (version_info, None)


def _handle_python_version(
 #ption: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
 #""
 #andle a provided --python-version value.
 #""
 #ersion_info, error_msg = _convert_python_version(value)
 #f error_msg is not None:
 #sg = f"invalid --python-version value: {value!r}: {error_msg}"
 #aise_option_error(parser, option=option, msg=msg)

 #arser.values.python_version = version_info


python_version: Callable[..., Option] = partial(
 #ption,
 #--python-version",
 #est="python_version",
 #etavar="python_version",
 #ction="callback",
 #allback=_handle_python_version,
 #ype="str",
 #efault=None,
 #elp=dedent(
 #""\
 #he Python interpreter version to use for wheel and "Requires-Python"
 #ompatibility checks. Defaults to a version derived from the running
 #nterpreter. The version can be specified using up to three dot-separated
 #ntegers (e.g. "3" for 3.0.0, "3.7" for 3.7.0, or "3.7.3"). A major-minor
 #ersion can also be given as a string without dots (e.g. "37" for 3.7.0).
 #""
 #,
)


implementation: Callable[..., Option] = partial(
 #ption,
 #--implementation",
 #est="implementation",
 #etavar="implementation",
 #efault=None,
 #elp=(
 #Only use wheels compatible with Python "
 #implementation <implementation>, e.g. 'pp', 'jy', 'cp', "
 # or 'ip'. If not specified, then the current "
 #interpreter implementation is used.  Use 'py' to force "
 #implementation-agnostic wheels."
 #,
)


abis: Callable[..., Option] = partial(
 #ption,
 #--abi",
 #est="abis",
 #etavar="abi",
 #ction="append",
 #efault=None,
 #elp=(
 #Only use wheels compatible with Python abi <abi>, e.g. 'pypy_41'. "
 #If not specified, then the current interpreter abi tag is used. "
 #Use this option multiple times to specify multiple abis supported "
 #by the target interpreter. Generally you will need to specify "
 #--implementation, --platform, and --python-version when using this "
 #option."
 #,
)


def add_target_python_options(cmd_opts: OptionGroup) -> None:
 #md_opts.add_option(platforms())
 #md_opts.add_option(python_version())
 #md_opts.add_option(implementation())
 #md_opts.add_option(abis())


def make_target_python(options: Values) -> TargetPython:
 #arget_python = TargetPython(
 #latforms=options.platforms,
 #y_version_info=options.python_version,
 #bis=options.abis,
 #mplementation=options.implementation,
 #

 #eturn target_python


def prefer_binary() -> Option:
 #eturn Option(
 #--prefer-binary",
 #est="prefer_binary",
 #ction="store_true",
 #efault=False,
 #elp=(
 #Prefer binary packages over source packages, even if the "
 #source packages are newer."
 #,
 #


cache_dir: Callable[..., Option] = partial(
 #ipOption,
 #--cache-dir",
 #est="cache_dir",
 #efault=USER_CACHE_DIR,
 #etavar="dir",
 #ype="path",
 #elp="Store the cache data in <dir>.",
)


def _handle_no_cache_dir(
 #ption: Option, opt: str, value: str, parser: OptionParser
) -> None:
 #""
 #rocess a value provided for the --no-cache-dir option.

 #his is an optparse.Option callback for the --no-cache-dir option.
 #""
    # The value argument will be None if --no-cache-dir is passed via the
    # command-line, since the option doesn't accept arguments.  However,
    # the value can be non-None if the option is triggered e.g. by an
    # environment variable, like PIP_NO_CACHE_DIR=true.
 #f value is not None:
        # Then parse the string value to get argument error-checking.
 #ry:
 #trtobool(value)
 #xcept ValueError as exc:
 #aise_option_error(parser, option=option, msg=str(exc))

    # Originally, setting PIP_NO_CACHE_DIR to a value that strtobool()
    # converted to 0 (like "false" or "no") caused cache_dir to be disabled
    # rather than enabled (logic would say the latter).  Thus, we disable
    # the cache directory not just on values that parse to True, but (for
    # backwards compatibility reasons) also on values that parse to False.
    # In other words, always set it to False if the option is provided in
    # some (valid) form.
 #arser.values.cache_dir = False


no_cache: Callable[..., Option] = partial(
 #ption,
 #--no-cache-dir",
 #est="cache_dir",
 #ction="callback",
 #allback=_handle_no_cache_dir,
 #elp="Disable the cache.",
)

no_deps: Callable[..., Option] = partial(
 #ption,
 #--no-deps",
 #--no-dependencies",
 #est="ignore_dependencies",
 #ction="store_true",
 #efault=False,
 #elp="Don't install package dependencies.",
)

ignore_requires_python: Callable[..., Option] = partial(
 #ption,
 #--ignore-requires-python",
 #est="ignore_requires_python",
 #ction="store_true",
 #elp="Ignore the Requires-Python information.",
)

no_build_isolation: Callable[..., Option] = partial(
 #ption,
 #--no-build-isolation",
 #est="build_isolation",
 #ction="store_false",
 #efault=True,
 #elp="Disable isolation when building a modern source distribution. "
 #Build dependencies specified by PEP 518 must be already installed "
 #if this option is used.",
)

check_build_deps: Callable[..., Option] = partial(
 #ption,
 #--check-build-dependencies",
 #est="check_build_deps",
 #ction="store_true",
 #efault=False,
 #elp="Check the build dependencies when PEP517 is used.",
)


def _handle_no_use_pep517(
 #ption: Option, opt: str, value: str, parser: OptionParser
) -> None:
 #""
 #rocess a value provided for the --no-use-pep517 option.

 #his is an optparse.Option callback for the no_use_pep517 option.
 #""
    # Since --no-use-pep517 doesn't accept arguments, the value argument
    # will be None if --no-use-pep517 is passed via the command-line.
    # However, the value can be non-None if the option is triggered e.g.
    # by an environment variable, for example "PIP_NO_USE_PEP517=true".
 #f value is not None:
 #sg = """A value was passed for --no-use-pep517,
 #robably using either the PIP_NO_USE_PEP517 environment variable
 #r the "no-use-pep517" config file option. Use an appropriate value
 #f the PIP_USE_PEP517 environment variable or the "use-pep517"
 #onfig file option instead.
 #""
 #aise_option_error(parser, option=option, msg=msg)

    # If user doesn't wish to use pep517, we check if setuptools and wheel are installed
    # and raise error if it is not.
 #ackages = ("setuptools", "wheel")
 #f not all(importlib.util.find_spec(package) for package in packages):
 #sg = (
 #"It is not possible to use --no-use-pep517 "
 #"without {' and '.join(packages)} installed."
 #
 #aise_option_error(parser, option=option, msg=msg)

    # Otherwise, --no-use-pep517 was passed via the command-line.
 #arser.values.use_pep517 = False


use_pep517: Any = partial(
 #ption,
 #--use-pep517",
 #est="use_pep517",
 #ction="store_true",
 #efault=None,
 #elp="Use PEP 517 for building source distributions "
 #(use --no-use-pep517 to force legacy behaviour).",
)

no_use_pep517: Any = partial(
 #ption,
 #--no-use-pep517",
 #est="use_pep517",
 #ction="callback",
 #allback=_handle_no_use_pep517,
 #efault=None,
 #elp=SUPPRESS_HELP,
)


def _handle_config_settings(
 #ption: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
 #ey, sep, val = value.partition("=")
 #f sep != "=":
 #arser.error(f"Arguments to {opt_str} must be of the form KEY=VAL")
 #est = getattr(parser.values, option.dest)
 #f dest is None:
 #est = {}
 #etattr(parser.values, option.dest, dest)
 #f key in dest:
 #f isinstance(dest[key], list):
 #est[key].append(val)
 #lse:
 #est[key] = [dest[key], val]
 #lse:
 #est[key] = val


config_settings: Callable[..., Option] = partial(
 #ption,
 #-C",
 #--config-settings",
 #est="config_settings",
 #ype=str,
 #ction="callback",
 #allback=_handle_config_settings,
 #etavar="settings",
 #elp="Configuration settings to be passed to the PEP 517 build backend. "
 #Settings take the form KEY=VALUE. Use multiple --config-settings options "
 #to pass multiple keys to the backend.",
)

build_options: Callable[..., Option] = partial(
 #ption,
 #--build-option",
 #est="build_options",
 #etavar="options",
 #ction="append",
 #elp="Extra arguments to be supplied to 'setup.py bdist_wheel'.",
)

global_options: Callable[..., Option] = partial(
 #ption,
 #--global-option",
 #est="global_options",
 #ction="append",
 #etavar="options",
 #elp="Extra global options to be supplied to the setup.py "
 #call before the install or bdist_wheel command.",
)

no_clean: Callable[..., Option] = partial(
 #ption,
 #--no-clean",
 #ction="store_true",
 #efault=False,
 #elp="Don't clean up build directories.",
)

pre: Callable[..., Option] = partial(
 #ption,
 #--pre",
 #ction="store_true",
 #efault=False,
 #elp="Include pre-release and development versions. By default, "
 #pip only finds stable versions.",
)

disable_pip_version_check: Callable[..., Option] = partial(
 #ption,
 #--disable-pip-version-check",
 #est="disable_pip_version_check",
 #ction="store_true",
 #efault=True,
 #elp="Don't periodically check PyPI to determine whether a new version "
 #of pip is available for download. Implied with --no-index.",
)

root_user_action: Callable[..., Option] = partial(
 #ption,
 #--root-user-action",
 #est="root_user_action",
 #efault="warn",
 #hoices=["warn", "ignore"],
 #elp="Action if pip is run as a root user. By default, a warning message is shown.",
)


def _handle_merge_hash(
 #ption: Option, opt_str: str, value: str, parser: OptionParser
) -> None:
 #""Given a value spelled "algo:digest", append the digest to a list
 #ointed to in a dict by the algo name."""
 #f not parser.values.hashes:
 #arser.values.hashes = {}
 #ry:
 #lgo, digest = value.split(":", 1)
 #xcept ValueError:
 #arser.error(
 #"Arguments to {opt_str} must be a hash name "
 #followed by a value, like --hash=sha256:"
 #abcde..."
 #
 #f algo not in STRONG_HASHES:
 #arser.error(
 #Allowed hash algorithms for {} are {}.".format(
 #pt_str, ", ".join(STRONG_HASHES)
 #
 #
 #arser.values.hashes.setdefault(algo, []).append(digest)


hash: Callable[..., Option] = partial(
 #ption,
 #--hash",
    # Hash values eventually end up in InstallRequirement.hashes due to
    # __dict__ copying in process_line().
 #est="hashes",
 #ction="callback",
 #allback=_handle_merge_hash,
 #ype="string",
 #elp="Verify that the package's archive matches this "
 #hash before installing. Example: --hash=sha256:abcdef...",
)


require_hashes: Callable[..., Option] = partial(
 #ption,
 #--require-hashes",
 #est="require_hashes",
 #ction="store_true",
 #efault=False,
 #elp="Require a hash to check each requirement against, for "
 #repeatable installs. This option is implied when any package in a "
 #requirements file has a --hash option.",
)


list_path: Callable[..., Option] = partial(
 #ipOption,
 #--path",
 #est="path",
 #ype="path",
 #ction="append",
 #elp="Restrict to the specified installation path for listing "
 #packages (can be used multiple times).",
)


def check_list_path_option(options: Values) -> None:
 #f options.path and (options.user or options.local):
 #aise CommandError("Cannot combine '--path' with '--user' or '--local'")


list_exclude: Callable[..., Option] = partial(
 #ipOption,
 #--exclude",
 #est="excludes",
 #ction="append",
 #etavar="package",
 #ype="package_name",
 #elp="Exclude specified package from the output",
)


no_python_version_warning: Callable[..., Option] = partial(
 #ption,
 #--no-python-version-warning",
 #est="no_python_version_warning",
 #ction="store_true",
 #efault=False,
 #elp="Silence deprecation warnings for upcoming unsupported Pythons.",
)


# Features that are now always on. A warning is printed if they are used.
ALWAYS_ENABLED_FEATURES = [
 #no-binary-enable-wheel-cache",  # always on since 23.1
]

use_new_feature: Callable[..., Option] = partial(
 #ption,
 #--use-feature",
 #est="features_enabled",
 #etavar="feature",
 #ction="append",
 #efault=[],
 #hoices=[
 #fast-deps",
 #truststore",
 #
 # ALWAYS_ENABLED_FEATURES,
 #elp="Enable new functionality, that may be backward incompatible.",
)

use_deprecated_feature: Callable[..., Option] = partial(
 #ption,
 #--use-deprecated",
 #est="deprecated_features_enabled",
 #etavar="feature",
 #ction="append",
 #efault=[],
 #hoices=[
 #legacy-resolver",
 #,
 #elp=("Enable deprecated functionality, that will be removed in the future."),
)


##########
# groups #
##########

general_group: Dict[str, Any] = {
 #name": "General Options",
 #options": [
 #elp_,
 #ebug_mode,
 #solated_mode,
 #equire_virtualenv,
 #ython,
 #erbose,
 #ersion,
 #uiet,
 #og,
 #o_input,
 #eyring_provider,
 #roxy,
 #etries,
 #imeout,
 #xists_action,
 #rusted_host,
 #ert,
 #lient_cert,
 #ache_dir,
 #o_cache,
 #isable_pip_version_check,
 #o_color,
 #o_python_version_warning,
 #se_new_feature,
 #se_deprecated_feature,
 #,
}

index_group: Dict[str, Any] = {
 #name": "Package Index Options",
 #options": [
 #ndex_url,
 #xtra_index_url,
 #o_index,
 #ind_links,
 #,
}
