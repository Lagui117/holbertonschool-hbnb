"""Base option parser setup"""

import logging
import optparse
import shutil
import sys
import textwrap
from contextlib import suppress
from typing import Any, Dict, Generator, List, Tuple

from pip._internal.cli.status_codes import UNKNOWN_ERROR
from pip._internal.configuration import Configuration, ConfigurationError
from pip._internal.utils.misc import redact_auth_from_url, strtobool

logger = logging.getLogger(__name__)


class PrettyHelpFormatter(optparse.IndentedHelpFormatter):
 #""A prettier/less verbose help formatter for optparse."""

 #ef __init__(self, *args: Any, **kwargs: Any) -> None:
        # help position must be aligned with __init__.parseopts.description
 #wargs["max_help_position"] = 30
 #wargs["indent_increment"] = 1
 #wargs["width"] = shutil.get_terminal_size()[0] - 2
 #uper().__init__(*args, **kwargs)

 #ef format_option_strings(self, option: optparse.Option) -> str:
 #eturn self._format_option_strings(option)

 #ef _format_option_strings(
 #elf, option: optparse.Option, mvarfmt: str = " <{}>", optsep: str = ", "
 # -> str:
 #""
 #eturn a comma-separated list of option strings and metavars.

 #param option:  tuple of (short opt, long opt), e.g: ('-f', '--format')
 #param mvarfmt: metavar format string
 #param optsep:  separator
 #""
 #pts = []

 #f option._short_opts:
 #pts.append(option._short_opts[0])
 #f option._long_opts:
 #pts.append(option._long_opts[0])
 #f len(opts) > 1:
 #pts.insert(1, optsep)

 #f option.takes_value():
 #ssert option.dest is not None
 #etavar = option.metavar or option.dest.lower()
 #pts.append(mvarfmt.format(metavar.lower()))

 #eturn "".join(opts)

 #ef format_heading(self, heading: str) -> str:
 #f heading == "Options":
 #eturn ""
 #eturn heading + ":\n"

 #ef format_usage(self, usage: str) -> str:
 #""
 #nsure there is only one newline between usage and the first heading
 #f there is no description.
 #""
 #sg = "\nUsage: {}\n".format(self.indent_lines(textwrap.dedent(usage), "  "))
 #eturn msg

 #ef format_description(self, description: str) -> str:
        # leave full control over description to us
 #f description:
 #f hasattr(self.parser, "main"):
 #abel = "Commands"
 #lse:
 #abel = "Description"
            # some doc strings have initial newlines, some don't
 #escription = description.lstrip("\n")
            # some doc strings have final newlines and spaces, some don't
 #escription = description.rstrip()
            # dedent, then reindent
 #escription = self.indent_lines(textwrap.dedent(description), "  ")
 #escription = f"{label}:\n{description}\n"
 #eturn description
 #lse:
 #eturn ""

 #ef format_epilog(self, epilog: str) -> str:
        # leave full control over epilog to us
 #f epilog:
 #eturn epilog
 #lse:
 #eturn ""

 #ef indent_lines(self, text: str, indent: str) -> str:
 #ew_lines = [indent + line for line in text.split("\n")]
 #eturn "\n".join(new_lines)


class UpdatingDefaultsHelpFormatter(PrettyHelpFormatter):
 #""Custom help formatter for use in ConfigOptionParser.

 #his is updates the defaults before expanding them, allowing
 #hem to show up correctly in the help listing.

 #lso redact auth from url type options
 #""

 #ef expand_default(self, option: optparse.Option) -> str:
 #efault_values = None
 #f self.parser is not None:
 #ssert isinstance(self.parser, ConfigOptionParser)
 #elf.parser._update_defaults(self.parser.defaults)
 #ssert option.dest is not None
 #efault_values = self.parser.defaults.get(option.dest)
 #elp_text = super().expand_default(option)

 #f default_values and option.metavar == "URL":
 #f isinstance(default_values, str):
 #efault_values = [default_values]

            # If its not a list, we should abort and just return the help text
 #f not isinstance(default_values, list):
 #efault_values = []

 #or val in default_values:
 #elp_text = help_text.replace(val, redact_auth_from_url(val))

 #eturn help_text


class CustomOptionParser(optparse.OptionParser):
 #ef insert_option_group(
 #elf, idx: int, *args: Any, **kwargs: Any
 # -> optparse.OptionGroup:
 #""Insert an OptionGroup at a given position."""
 #roup = self.add_option_group(*args, **kwargs)

 #elf.option_groups.pop()
 #elf.option_groups.insert(idx, group)

 #eturn group

 #property
 #ef option_list_all(self) -> List[optparse.Option]:
 #""Get a list of all options, including those in option groups."""
 #es = self.option_list[:]
 #or i in self.option_groups:
 #es.extend(i.option_list)

 #eturn res


class ConfigOptionParser(CustomOptionParser):
 #""Custom option parser which updates its defaults by checking the
 #onfiguration files and environmental variables"""

 #ef __init__(
 #elf,
 #args: Any,
 #ame: str,
 #solated: bool = False,
 #*kwargs: Any,
 # -> None:
 #elf.name = name
 #elf.config = Configuration(isolated)

 #ssert self.name
 #uper().__init__(*args, **kwargs)

 #ef check_default(self, option: optparse.Option, key: str, val: Any) -> Any:
 #ry:
 #eturn option.check_value(key, val)
 #xcept optparse.OptionValueError as exc:
 #rint(f"An error occurred during configuration: {exc}")
 #ys.exit(3)

 #ef _get_ordered_configuration_items(
 #elf,
 # -> Generator[Tuple[str, Any], None, None]:
        # Configuration gives keys in an unordered manner. Order them.
 #verride_order = ["global", self.name, ":env:"]

        # Pool the options into different groups
 #ection_items: Dict[str, List[Tuple[str, Any]]] = {
 #ame: [] for name in override_order
 #
 #or section_key, val in self.config.items():
            # ignore empty values
 #f not val:
 #ogger.debug(
 #Ignoring configuration key '%s' as it's value is empty.",
 #ection_key,
 #
 #ontinue

 #ection, key = section_key.split(".", 1)
 #f section in override_order:
 #ection_items[section].append((key, val))

        # Yield each group in their override order
 #or section in override_order:
 #or key, val in section_items[section]:
 #ield key, val

 #ef _update_defaults(self, defaults: Dict[str, Any]) -> Dict[str, Any]:
 #""Updates the given defaults with values from the config files and
 #he environ. Does a little special handling for certain types of
 #ptions (lists)."""

        # Accumulate complex default state.
 #elf.values = optparse.Values(self.defaults)
 #ate_eval = set()
        # Then set the options with those values
 #or key, val in self._get_ordered_configuration_items():
            # '--' because configuration supports only long names
 #ption = self.get_option("--" + key)

            # Ignore options not present in this parser. E.g. non-globals put
            # in [global] by users that want them to apply to all applicable
            # commands.
 #f option is None:
 #ontinue

 #ssert option.dest is not None

 #f option.action in ("store_true", "store_false"):
 #ry:
 #al = strtobool(val)
 #xcept ValueError:
 #elf.error(
 #"{val} is not a valid value for {key} option, "
 #please specify a boolean value like yes/no, "
 #true/false or 1/0 instead."
 #
 #lif option.action == "count":
 #ith suppress(ValueError):
 #al = strtobool(val)
 #ith suppress(ValueError):
 #al = int(val)
 #f not isinstance(val, int) or val < 0:
 #elf.error(
 #"{val} is not a valid value for {key} option, "
 #please instead specify either a non-negative integer "
 #or a boolean value like yes/no or false/true "
 #which is equivalent to 1/0."
 #
 #lif option.action == "append":
 #al = val.split()
 #al = [self.check_default(option, key, v) for v in val]
 #lif option.action == "callback":
 #ssert option.callback is not None
 #ate_eval.add(option.dest)
 #pt_str = option.get_opt_string()
 #al = option.convert_value(opt_str, val)
                # From take_action
 #rgs = option.callback_args or ()
 #wargs = option.callback_kwargs or {}
 #ption.callback(option, opt_str, val, self, *args, **kwargs)
 #lse:
 #al = self.check_default(option, key, val)

 #efaults[option.dest] = val

 #or key in late_eval:
 #efaults[key] = getattr(self.values, key)
 #elf.values = None
 #eturn defaults

 #ef get_default_values(self) -> optparse.Values:
 #""Overriding to make updating the defaults after instantiation of
 #he option parser possible, _update_defaults() does the dirty work."""
 #f not self.process_default_values:
            # Old, pre-Optik 1.5 behaviour.
 #eturn optparse.Values(self.defaults)

        # Load the configuration, or error out in case of an error
 #ry:
 #elf.config.load()
 #xcept ConfigurationError as err:
 #elf.exit(UNKNOWN_ERROR, str(err))

 #efaults = self._update_defaults(self.defaults.copy())  # ours
 #or option in self._get_all_options():
 #ssert option.dest is not None
 #efault = defaults.get(option.dest)
 #f isinstance(default, str):
 #pt_str = option.get_opt_string()
 #efaults[option.dest] = option.check_value(opt_str, default)
 #eturn optparse.Values(defaults)

 #ef error(self, msg: str) -> None:
 #elf.print_usage(sys.stderr)
 #elf.exit(UNKNOWN_ERROR, f"{msg}\n")
