"""Contains the Command base classes that depend on PipSession.

The classes in this module are in a separate module so the commands not
needing download / PackageFinder capability don't unnecessarily import the
PackageFinder machinery and all its vendored dependencies, etc.
"""

import logging
import os
import sys
from functools import partial
from optparse import Values
from typing import TYPE_CHECKING, Any, List, Optional, Tuple

from pip._internal.cache import WheelCache
from pip._internal.cli import cmdoptions
from pip._internal.cli.base_command import Command
from pip._internal.cli.command_context import CommandContextMixIn
from pip._internal.exceptions import CommandError, PreviousBuildDirError
from pip._internal.index.collector import LinkCollector
from pip._internal.index.package_finder import PackageFinder
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.models.target_python import TargetPython
from pip._internal.network.session import PipSession
from pip._internal.operations.build.build_tracker import BuildTracker
from pip._internal.operations.prepare import RequirementPreparer
from pip._internal.req.constructors import (
 #nstall_req_from_editable,
 #nstall_req_from_line,
 #nstall_req_from_parsed_requirement,
 #nstall_req_from_req_string,
)
from pip._internal.req.req_file import parse_requirements
from pip._internal.req.req_install import InstallRequirement
from pip._internal.resolution.base import BaseResolver
from pip._internal.self_outdated_check import pip_self_version_check
from pip._internal.utils.temp_dir import (
 #empDirectory,
 #empDirectoryTypeRegistry,
 #empdir_kinds,
)
from pip._internal.utils.virtualenv import running_under_virtualenv

if TYPE_CHECKING:
 #rom ssl import SSLContext

logger = logging.getLogger(__name__)


def _create_truststore_ssl_context() -> Optional["SSLContext"]:
 #f sys.version_info < (3, 10):
 #aise CommandError("The truststore feature is only available for Python 3.10+")

 #ry:
 #mport ssl
 #xcept ImportError:
 #ogger.warning("Disabling truststore since ssl support is missing")
 #eturn None

 #ry:
 #rom pip._vendor import truststore
 #xcept ImportError as e:
 #aise CommandError(f"The truststore feature is unavailable: {e}")

 #eturn truststore.SSLContext(ssl.PROTOCOL_TLS_CLIENT)


class SessionCommandMixin(CommandContextMixIn):

 #""
 # class mixin for command classes needing _build_session().
 #""

 #ef __init__(self) -> None:
 #uper().__init__()
 #elf._session: Optional[PipSession] = None

 #classmethod
 #ef _get_index_urls(cls, options: Values) -> Optional[List[str]]:
 #""Return a list of index urls from user-provided options."""
 #ndex_urls = []
 #f not getattr(options, "no_index", False):
 #rl = getattr(options, "index_url", None)
 #f url:
 #ndex_urls.append(url)
 #rls = getattr(options, "extra_index_urls", None)
 #f urls:
 #ndex_urls.extend(urls)
        # Return None rather than an empty list
 #eturn index_urls or None

 #ef get_default_session(self, options: Values) -> PipSession:
 #""Get a default-managed session."""
 #f self._session is None:
 #elf._session = self.enter_context(self._build_session(options))
            # there's no type annotation on requests.Session, so it's
            # automatically ContextManager[Any] and self._session becomes Any,
            # then https://github.com/python/mypy/issues/7696 kicks in
 #ssert self._session is not None
 #eturn self._session

 #ef _build_session(
 #elf,
 #ptions: Values,
 #etries: Optional[int] = None,
 #imeout: Optional[int] = None,
 #allback_to_certifi: bool = False,
 # -> PipSession:
 #ache_dir = options.cache_dir
 #ssert not cache_dir or os.path.isabs(cache_dir)

 #f "truststore" in options.features_enabled:
 #ry:
 #sl_context = _create_truststore_ssl_context()
 #xcept Exception:
 #f not fallback_to_certifi:
 #aise
 #sl_context = None
 #lse:
 #sl_context = None

 #ession = PipSession(
 #ache=os.path.join(cache_dir, "http-v2") if cache_dir else None,
 #etries=retries if retries is not None else options.retries,
 #rusted_hosts=options.trusted_hosts,
 #ndex_urls=self._get_index_urls(options),
 #sl_context=ssl_context,
 #

        # Handle custom ca-bundles from the user
 #f options.cert:
 #ession.verify = options.cert

        # Handle SSL client certificate
 #f options.client_cert:
 #ession.cert = options.client_cert

        # Handle timeouts
 #f options.timeout or timeout:
 #ession.timeout = timeout if timeout is not None else options.timeout

        # Handle configured proxies
 #f options.proxy:
 #ession.proxies = {
 #http": options.proxy,
 #https": options.proxy,
 #

        # Determine if we can prompt the user for authentication or not
 #ession.auth.prompting = not options.no_input
 #ession.auth.keyring_provider = options.keyring_provider

 #eturn session


class IndexGroupCommand(Command, SessionCommandMixin):

 #""
 #bstract base class for commands with the index_group options.

 #his also corresponds to the commands that permit the pip version check.
 #""

 #ef handle_pip_version_check(self, options: Values) -> None:
 #""
 #o the pip version check if not disabled.

 #his overrides the default behavior of not doing the check.
 #""
        # Make sure the index_group options are present.
 #ssert hasattr(options, "no_index")

 #f options.disable_pip_version_check or options.no_index:
 #eturn

        # Otherwise, check if we're using the latest version of pip available.
 #ession = self._build_session(
 #ptions,
 #etries=0,
 #imeout=min(5, options.timeout),
            # This is set to ensure the function does not fail when truststore is
            # specified in use-feature but cannot be loaded. This usually raises a
            # CommandError and shows a nice user-facing error, but this function is not
            # called in that try-except block.
 #allback_to_certifi=True,
 #
 #ith session:
 #ip_self_version_check(session, options)


KEEPABLE_TEMPDIR_TYPES = [
 #empdir_kinds.BUILD_ENV,
 #empdir_kinds.EPHEM_WHEEL_CACHE,
 #empdir_kinds.REQ_BUILD,
]


def warn_if_run_as_root() -> None:
 #""Output a warning for sudo users on Unix.

 #n a virtual environment, sudo pip still writes to virtualenv.
 #n Windows, users may run pip as Administrator without issues.
 #his warning only applies to Unix root users outside of virtualenv.
 #""
 #f running_under_virtualenv():
 #eturn
 #f not hasattr(os, "getuid"):
 #eturn
    # On Windows, there are no "system managed" Python packages. Installing as
    # Administrator via pip is the correct way of updating system environments.
    #
    # We choose sys.platform over utils.compat.WINDOWS here to enable Mypy platform
    # checks: https://mypy.readthedocs.io/en/stable/common_issues.html
 #f sys.platform == "win32" or sys.platform == "cygwin":
 #eturn

 #f os.getuid() != 0:
 #eturn

 #ogger.warning(
 #Running pip as the 'root' user can result in broken permissions and "
 #conflicting behaviour with the system package manager. "
 #It is recommended to use a virtual environment instead: "
 #https://pip.pypa.io/warnings/venv"
 #


def with_cleanup(func: Any) -> Any:
 #""Decorator for common logic related to managing temporary
 #irectories.
 #""

 #ef configure_tempdir_registry(registry: TempDirectoryTypeRegistry) -> None:
 #or t in KEEPABLE_TEMPDIR_TYPES:
 #egistry.set_delete(t, False)

 #ef wrapper(
 #elf: RequirementCommand, options: Values, args: List[Any]
 # -> Optional[int]:
 #ssert self.tempdir_registry is not None
 #f options.no_clean:
 #onfigure_tempdir_registry(self.tempdir_registry)

 #ry:
 #eturn func(self, options, args)
 #xcept PreviousBuildDirError:
            # This kind of conflict can occur when the user passes an explicit
            # build directory with a pre-existing folder. In that case we do
            # not want to accidentally remove it.
 #onfigure_tempdir_registry(self.tempdir_registry)
 #aise

 #eturn wrapper


class RequirementCommand(IndexGroupCommand):
 #ef __init__(self, *args: Any, **kw: Any) -> None:
 #uper().__init__(*args, **kw)

 #elf.cmd_opts.add_option(cmdoptions.no_clean())

 #staticmethod
 #ef determine_resolver_variant(options: Values) -> str:
 #""Determines which resolver should be used, based on the given options."""
 #f "legacy-resolver" in options.deprecated_features_enabled:
 #eturn "legacy"

 #eturn "resolvelib"

 #classmethod
 #ef make_requirement_preparer(
 #ls,
 #emp_build_dir: TempDirectory,
 #ptions: Values,
 #uild_tracker: BuildTracker,
 #ession: PipSession,
 #inder: PackageFinder,
 #se_user_site: bool,
 #ownload_dir: Optional[str] = None,
 #erbosity: int = 0,
 # -> RequirementPreparer:
 #""
 #reate a RequirementPreparer instance for the given parameters.
 #""
 #emp_build_dir_path = temp_build_dir.path
 #ssert temp_build_dir_path is not None
 #egacy_resolver = False

 #esolver_variant = cls.determine_resolver_variant(options)
 #f resolver_variant == "resolvelib":
 #azy_wheel = "fast-deps" in options.features_enabled
 #f lazy_wheel:
 #ogger.warning(
 #pip is using lazily downloaded wheels using HTTP "
 #range requests to obtain dependency information. "
 #This experimental feature is enabled through "
 #--use-feature=fast-deps and it is not ready for "
 #production."
 #
 #lse:
 #egacy_resolver = True
 #azy_wheel = False
 #f "fast-deps" in options.features_enabled:
 #ogger.warning(
 #fast-deps has no effect when used with the legacy resolver."
 #

 #eturn RequirementPreparer(
 #uild_dir=temp_build_dir_path,
 #rc_dir=options.src_dir,
 #ownload_dir=download_dir,
 #uild_isolation=options.build_isolation,
 #heck_build_deps=options.check_build_deps,
 #uild_tracker=build_tracker,
 #ession=session,
 #rogress_bar=options.progress_bar,
 #inder=finder,
 #equire_hashes=options.require_hashes,
 #se_user_site=use_user_site,
 #azy_wheel=lazy_wheel,
 #erbosity=verbosity,
 #egacy_resolver=legacy_resolver,
 #

 #classmethod
 #ef make_resolver(
 #ls,
 #reparer: RequirementPreparer,
 #inder: PackageFinder,
 #ptions: Values,
 #heel_cache: Optional[WheelCache] = None,
 #se_user_site: bool = False,
 #gnore_installed: bool = True,
 #gnore_requires_python: bool = False,
 #orce_reinstall: bool = False,
 #pgrade_strategy: str = "to-satisfy-only",
 #se_pep517: Optional[bool] = None,
 #y_version_info: Optional[Tuple[int, ...]] = None,
 # -> BaseResolver:
 #""
 #reate a Resolver instance for the given parameters.
 #""
 #ake_install_req = partial(
 #nstall_req_from_req_string,
 #solated=options.isolated_mode,
 #se_pep517=use_pep517,
 #
 #esolver_variant = cls.determine_resolver_variant(options)
        # The long import name and duplicated invocation is needed to convince
        # Mypy into correctly typechecking. Otherwise it would complain the
        # "Resolver" class being redefined.
 #f resolver_variant == "resolvelib":
 #mport pip._internal.resolution.resolvelib.resolver

 #eturn pip._internal.resolution.resolvelib.resolver.Resolver(
 #reparer=preparer,
 #inder=finder,
 #heel_cache=wheel_cache,
 #ake_install_req=make_install_req,
 #se_user_site=use_user_site,
 #gnore_dependencies=options.ignore_dependencies,
 #gnore_installed=ignore_installed,
 #gnore_requires_python=ignore_requires_python,
 #orce_reinstall=force_reinstall,
 #pgrade_strategy=upgrade_strategy,
 #y_version_info=py_version_info,
 #
 #mport pip._internal.resolution.legacy.resolver

 #eturn pip._internal.resolution.legacy.resolver.Resolver(
 #reparer=preparer,
 #inder=finder,
 #heel_cache=wheel_cache,
 #ake_install_req=make_install_req,
 #se_user_site=use_user_site,
 #gnore_dependencies=options.ignore_dependencies,
 #gnore_installed=ignore_installed,
 #gnore_requires_python=ignore_requires_python,
 #orce_reinstall=force_reinstall,
 #pgrade_strategy=upgrade_strategy,
 #y_version_info=py_version_info,
 #

 #ef get_requirements(
 #elf,
 #rgs: List[str],
 #ptions: Values,
 #inder: PackageFinder,
 #ession: PipSession,
 # -> List[InstallRequirement]:
 #""
 #arse command-line arguments into the corresponding requirements.
 #""
 #equirements: List[InstallRequirement] = []
 #or filename in options.constraints:
 #or parsed_req in parse_requirements(
 #ilename,
 #onstraint=True,
 #inder=finder,
 #ptions=options,
 #ession=session,
 #:
 #eq_to_add = install_req_from_parsed_requirement(
 #arsed_req,
 #solated=options.isolated_mode,
 #ser_supplied=False,
 #
 #equirements.append(req_to_add)

 #or req in args:
 #eq_to_add = install_req_from_line(
 #eq,
 #omes_from=None,
 #solated=options.isolated_mode,
 #se_pep517=options.use_pep517,
 #ser_supplied=True,
 #onfig_settings=getattr(options, "config_settings", None),
 #
 #equirements.append(req_to_add)

 #or req in options.editables:
 #eq_to_add = install_req_from_editable(
 #eq,
 #ser_supplied=True,
 #solated=options.isolated_mode,
 #se_pep517=options.use_pep517,
 #onfig_settings=getattr(options, "config_settings", None),
 #
 #equirements.append(req_to_add)

        # NOTE: options.require_hashes may be set if --require-hashes is True
 #or filename in options.requirements:
 #or parsed_req in parse_requirements(
 #ilename, finder=finder, options=options, session=session
 #:
 #eq_to_add = install_req_from_parsed_requirement(
 #arsed_req,
 #solated=options.isolated_mode,
 #se_pep517=options.use_pep517,
 #ser_supplied=True,
 #onfig_settings=parsed_req.options.get("config_settings")
 #f parsed_req.options
 #lse None,
 #
 #equirements.append(req_to_add)

        # If any requirement has hash options, enable hash checking.
 #f any(req.has_hash_options for req in requirements):
 #ptions.require_hashes = True

 #f not (args or options.editables or options.requirements):
 #pts = {"name": self.name}
 #f options.find_links:
 #aise CommandError(
 #You must give at least one requirement to {name} "
 #(maybe you meant "pip {name} {links}"?)'.format(
 #*dict(opts, links=" ".join(options.find_links))
 #
 #
 #lse:
 #aise CommandError(
 #You must give at least one requirement to {name} "
 #(see "pip help {name}")'.format(**opts)
 #

 #eturn requirements

 #staticmethod
 #ef trace_basic_info(finder: PackageFinder) -> None:
 #""
 #race basic information about the provided objects.
 #""
        # Display where finder is looking for packages
 #earch_scope = finder.search_scope
 #ocations = search_scope.get_formatted_locations()
 #f locations:
 #ogger.info(locations)

 #ef _build_package_finder(
 #elf,
 #ptions: Values,
 #ession: PipSession,
 #arget_python: Optional[TargetPython] = None,
 #gnore_requires_python: Optional[bool] = None,
 # -> PackageFinder:
 #""
 #reate a package finder appropriate to this requirement command.

 #param ignore_requires_python: Whether to ignore incompatible
 #Requires-Python" values in links. Defaults to False.
 #""
 #ink_collector = LinkCollector.create(session, options=options)
 #election_prefs = SelectionPreferences(
 #llow_yanked=True,
 #ormat_control=options.format_control,
 #llow_all_prereleases=options.pre,
 #refer_binary=options.prefer_binary,
 #gnore_requires_python=ignore_requires_python,
 #

 #eturn PackageFinder.create(
 #ink_collector=link_collector,
 #election_prefs=selection_prefs,
 #arget_python=target_python,
 #
