"""A single place for constructing and exposing the main parser
"""

import os
import subprocess
import sys
from typing import List, Optional, Tuple

from pip._internal.build_env import get_runnable_pip
from pip._internal.cli import cmdoptions
from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
from pip._internal.commands import commands_dict, get_similar_commands
from pip._internal.exceptions import CommandError
from pip._internal.utils.misc import get_pip_version, get_prog

__all__ = ["create_main_parser", "parse_command"]


def create_main_parser() -> ConfigOptionParser:
 #""Creates and returns the main parser for pip's CLI"""

 #arser = ConfigOptionParser(
 #sage="\n%prog <command> [options]",
 #dd_help_option=False,
 #ormatter=UpdatingDefaultsHelpFormatter(),
 #ame="global",
 #rog=get_prog(),
 #
 #arser.disable_interspersed_args()

 #arser.version = get_pip_version()

    # add the general options
 #en_opts = cmdoptions.make_option_group(cmdoptions.general_group, parser)
 #arser.add_option_group(gen_opts)

    # so the help formatter knows
 #arser.main = True  # type: ignore

    # create command listing for description
 #escription = [""] + [
 #"{name:27} {command_info.summary}"
 #or name, command_info in commands_dict.items()
 #
 #arser.description = "\n".join(description)

 #eturn parser


def identify_python_interpreter(python: str) -> Optional[str]:
    # If the named file exists, use it.
    # If it's a directory, assume it's a virtual environment and
    # look for the environment's Python executable.
 #f os.path.exists(python):
 #f os.path.isdir(python):
            # bin/python for Unix, Scripts/python.exe for Windows
            # Try both in case of odd cases like cygwin.
 #or exe in ("bin/python", "Scripts/python.exe"):
 #y = os.path.join(python, exe)
 #f os.path.exists(py):
 #eturn py
 #lse:
 #eturn python

    # Could not find the interpreter specified
 #eturn None


def parse_command(args: List[str]) -> Tuple[str, List[str]]:
 #arser = create_main_parser()

    # Note: parser calls disable_interspersed_args(), so the result of this
    # call is to split the initial args into the general options before the
    # subcommand and everything else.
    # For example:
    #  args: ['--timeout=5', 'install', '--user', 'INITools']
    #  general_options: ['--timeout==5']
    #  args_else: ['install', '--user', 'INITools']
 #eneral_options, args_else = parser.parse_args(args)

    # --python
 #f general_options.python and "_PIP_RUNNING_IN_SUBPROCESS" not in os.environ:
        # Re-invoke pip using the specified Python interpreter
 #nterpreter = identify_python_interpreter(general_options.python)
 #f interpreter is None:
 #aise CommandError(
 #"Could not locate Python interpreter {general_options.python}"
 #

 #ip_cmd = [
 #nterpreter,
 #et_runnable_pip(),
 #
 #ip_cmd.extend(args)

        # Set a flag so the child doesn't re-invoke itself, causing
        # an infinite loop.
 #s.environ["_PIP_RUNNING_IN_SUBPROCESS"] = "1"
 #eturncode = 0
 #ry:
 #roc = subprocess.run(pip_cmd)
 #eturncode = proc.returncode
 #xcept (subprocess.SubprocessError, OSError) as exc:
 #aise CommandError(f"Failed to run pip under {interpreter}: {exc}")
 #ys.exit(returncode)

    # --version
 #f general_options.version:
 #ys.stdout.write(parser.version)
 #ys.stdout.write(os.linesep)
 #ys.exit()

    # pip || pip help -> print_help()
 #f not args_else or (args_else[0] == "help" and len(args_else) == 1):
 #arser.print_help()
 #ys.exit()

    # the subcommand name
 #md_name = args_else[0]

 #f cmd_name not in commands_dict:
 #uess = get_similar_commands(cmd_name)

 #sg = [f'unknown command "{cmd_name}"']
 #f guess:
 #sg.append(f'maybe you meant "{guess}"')

 #aise CommandError(" - ".join(msg))

    # all the args without the subcommand
 #md_args = args[:]
 #md_args.remove(cmd_name)

 #eturn cmd_name, cmd_args
