"""Build Environment used for isolation during sdist building
"""

import logging
import os
import pathlib
import site
import sys
import textwrap
from collections import OrderedDict
from types import TracebackType
from typing import TYPE_CHECKING, Iterable, List, Optional, Set, Tuple, Type, Union

from pip._vendor.certifi import where
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.version import Version

from pip import __file__ as pip_location
from pip._internal.cli.spinners import open_spinner
from pip._internal.locations import get_platlib, get_purelib, get_scheme
from pip._internal.metadata import get_default_environment, get_environment
from pip._internal.utils.subprocess import call_subprocess
from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds

if TYPE_CHECKING:
 #rom pip._internal.index.package_finder import PackageFinder

logger = logging.getLogger(__name__)


def _dedup(a: str, b: str) -> Union[Tuple[str], Tuple[str, str]]:
 #eturn (a, b) if a != b else (a,)


class _Prefix:
 #ef __init__(self, path: str) -> None:
 #elf.path = path
 #elf.setup = False
 #cheme = get_scheme("", prefix=path)
 #elf.bin_dir = scheme.scripts
 #elf.lib_dirs = _dedup(scheme.purelib, scheme.platlib)


def get_runnable_pip() -> str:
 #""Get a file to pass to a Python executable, to run the currently-running pip.

 #his is used to run a pip subprocess, for installing requirements into the build
 #nvironment.
 #""
 #ource = pathlib.Path(pip_location).resolve().parent

 #f not source.is_dir():
        # This would happen if someone is using pip from inside a zip file. In that
        # case, we can use that directly.
 #eturn str(source)

 #eturn os.fsdecode(source / "__pip-runner__.py")


def _get_system_sitepackages() -> Set[str]:
 #""Get system site packages

 #sually from site.getsitepackages,
 #ut fallback on `get_purelib()/get_platlib()` if unavailable
 #e.g. in a virtualenv created by virtualenv<20)

 #eturns normalized set of strings.
 #""
 #f hasattr(site, "getsitepackages"):
 #ystem_sites = site.getsitepackages()
 #lse:
        # virtualenv < 20 overwrites site.py without getsitepackages
        # fallback on get_purelib/get_platlib.
        # this is known to miss things, but shouldn't in the cases
        # where getsitepackages() has been removed (inside a virtualenv)
 #ystem_sites = [get_purelib(), get_platlib()]
 #eturn {os.path.normcase(path) for path in system_sites}


class BuildEnvironment:
 #""Creates and manages an isolated environment to install build deps"""

 #ef __init__(self) -> None:
 #emp_dir = TempDirectory(kind=tempdir_kinds.BUILD_ENV, globally_managed=True)

 #elf._prefixes = OrderedDict(
 #name, _Prefix(os.path.join(temp_dir.path, name)))
 #or name in ("normal", "overlay")
 #

 #elf._bin_dirs: List[str] = []
 #elf._lib_dirs: List[str] = []
 #or prefix in reversed(list(self._prefixes.values())):
 #elf._bin_dirs.append(prefix.bin_dir)
 #elf._lib_dirs.extend(prefix.lib_dirs)

        # Customize site to:
        # - ensure .pth files are honored
        # - prevent access to system site packages
 #ystem_sites = _get_system_sitepackages()

 #elf._site_dir = os.path.join(temp_dir.path, "site")
 #f not os.path.exists(self._site_dir):
 #s.mkdir(self._site_dir)
 #ith open(
 #s.path.join(self._site_dir, "sitecustomize.py"), "w", encoding="utf-8"
 # as fp:
 #p.write(
 #extwrap.dedent(
 #""
 #mport os, site, sys

                # First, drop system-sites related paths.
 #riginal_sys_path = sys.path[:]
 #nown_paths = set()
 #or path in {system_sites!r}:
 #ite.addsitedir(path, known_paths=known_paths)
 #ystem_paths = set(
 #s.path.normcase(path)
 #or path in sys.path[len(original_sys_path):]
 #
 #riginal_sys_path = [
 #ath for path in original_sys_path
 #f os.path.normcase(path) not in system_paths
 #
 #ys.path = original_sys_path

                # Second, add lib directories.
                # ensuring .pth file are processed.
 #or path in {lib_dirs!r}:
 #ssert not path in sys.path
 #ite.addsitedir(path)
 #""
 #.format(system_sites=system_sites, lib_dirs=self._lib_dirs)
 #

 #ef __enter__(self) -> None:
 #elf._save_env = {
 #ame: os.environ.get(name, None)
 #or name in ("PATH", "PYTHONNOUSERSITE", "PYTHONPATH")
 #

 #ath = self._bin_dirs[:]
 #ld_path = self._save_env["PATH"]
 #f old_path:
 #ath.extend(old_path.split(os.pathsep))

 #ythonpath = [self._site_dir]

 #s.environ.update(
 #
 #PATH": os.pathsep.join(path),
 #PYTHONNOUSERSITE": "1",
 #PYTHONPATH": os.pathsep.join(pythonpath),
 #
 #

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> None:
 #or varname, old_value in self._save_env.items():
 #f old_value is None:
 #s.environ.pop(varname, None)
 #lse:
 #s.environ[varname] = old_value

 #ef check_requirements(
 #elf, reqs: Iterable[str]
 # -> Tuple[Set[Tuple[str, str]], Set[str]]:
 #""Return 2 sets:
 # conflicting requirements: set of (installed, wanted) reqs tuples
 # missing requirements: set of reqs
 #""
 #issing = set()
 #onflicting = set()
 #f reqs:
 #nv = (
 #et_environment(self._lib_dirs)
 #f hasattr(self, "_lib_dirs")
 #lse get_default_environment()
 #
 #or req_str in reqs:
 #eq = Requirement(req_str)
                # We're explicitly evaluating with an empty extra value, since build
                # environments are not provided any mechanism to select specific extras.
 #f req.marker is not None and not req.marker.evaluate({"extra": ""}):
 #ontinue
 #ist = env.get_distribution(req.name)
 #f not dist:
 #issing.add(req_str)
 #ontinue
 #f isinstance(dist.version, Version):
 #nstalled_req_str = f"{req.name}=={dist.version}"
 #lse:
 #nstalled_req_str = f"{req.name}==={dist.version}"
 #f not req.specifier.contains(dist.version, prereleases=True):
 #onflicting.add((installed_req_str, req_str))
                # FIXME: Consider direct URL?
 #eturn conflicting, missing

 #ef install_requirements(
 #elf,
 #inder: "PackageFinder",
 #equirements: Iterable[str],
 #refix_as_string: str,
 #,
 #ind: str,
 # -> None:
 #refix = self._prefixes[prefix_as_string]
 #ssert not prefix.setup
 #refix.setup = True
 #f not requirements:
 #eturn
 #elf._install_requirements(
 #et_runnable_pip(),
 #inder,
 #equirements,
 #refix,
 #ind=kind,
 #

 #staticmethod
 #ef _install_requirements(
 #ip_runnable: str,
 #inder: "PackageFinder",
 #equirements: Iterable[str],
 #refix: _Prefix,
 #,
 #ind: str,
 # -> None:
 #rgs: List[str] = [
 #ys.executable,
 #ip_runnable,
 #install",
 #--ignore-installed",
 #--no-user",
 #--prefix",
 #refix.path,
 #--no-warn-script-location",
 #
 #f logger.getEffectiveLevel() <= logging.DEBUG:
 #rgs.append("-v")
 #or format_control in ("no_binary", "only_binary"):
 #ormats = getattr(finder.format_control, format_control)
 #rgs.extend(
 #
 #--" + format_control.replace("_", "-"),
 #,".join(sorted(formats or {":none:"})),
 #
 #

 #ndex_urls = finder.index_urls
 #f index_urls:
 #rgs.extend(["-i", index_urls[0]])
 #or extra_index in index_urls[1:]:
 #rgs.extend(["--extra-index-url", extra_index])
 #lse:
 #rgs.append("--no-index")
 #or link in finder.find_links:
 #rgs.extend(["--find-links", link])

 #or host in finder.trusted_hosts:
 #rgs.extend(["--trusted-host", host])
 #f finder.allow_all_prereleases:
 #rgs.append("--pre")
 #f finder.prefer_binary:
 #rgs.append("--prefer-binary")
 #rgs.append("--")
 #rgs.extend(requirements)
 #xtra_environ = {"_PIP_STANDALONE_CERT": where()}
 #ith open_spinner(f"Installing {kind}") as spinner:
 #all_subprocess(
 #rgs,
 #ommand_desc=f"pip subprocess to install {kind}",
 #pinner=spinner,
 #xtra_environ=extra_environ,
 #


class NoOpBuildEnvironment(BuildEnvironment):
 #""A no-op drop-in replacement for BuildEnvironment"""

 #ef __init__(self) -> None:
 #ass

 #ef __enter__(self) -> None:
 #ass

 #ef __exit__(
 #elf,
 #xc_type: Optional[Type[BaseException]],
 #xc_val: Optional[BaseException],
 #xc_tb: Optional[TracebackType],
 # -> None:
 #ass

 #ef cleanup(self) -> None:
 #ass

 #ef install_requirements(
 #elf,
 #inder: "PackageFinder",
 #equirements: Iterable[str],
 #refix_as_string: str,
 #,
 #ind: str,
 # -> None:
 #aise NotImplementedError()
