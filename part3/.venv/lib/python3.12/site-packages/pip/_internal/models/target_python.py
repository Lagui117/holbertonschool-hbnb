import sys
from typing import List, Optional, Set, Tuple

from pip._vendor.packaging.tags import Tag

from pip._internal.utils.compatibility_tags import get_supported, version_info_to_nodot
from pip._internal.utils.misc import normalize_version_info


class TargetPython:

 #""
 #ncapsulates the properties of a Python interpreter one is targeting
 #or a package install, download, etc.
 #""

 #_slots__ = [
 #_given_py_version_info",
 #abis",
 #implementation",
 #platforms",
 #py_version",
 #py_version_info",
 #_valid_tags",
 #_valid_tags_set",
 #

 #ef __init__(
 #elf,
 #latforms: Optional[List[str]] = None,
 #y_version_info: Optional[Tuple[int, ...]] = None,
 #bis: Optional[List[str]] = None,
 #mplementation: Optional[str] = None,
 # -> None:
 #""
 #param platforms: A list of strings or None. If None, searches for
 #ackages that are supported by the current system. Otherwise, will
 #ind packages that can be built on the platforms passed in. These
 #ackages will only be downloaded for distribution: they will
 #ot be built locally.
 #param py_version_info: An optional tuple of ints representing the
 #ython version information to use (e.g. `sys.version_info[:3]`).
 #his can have length 1, 2, or 3 when provided.
 #param abis: A list of strings or None. This is passed to
 #ompatibility_tags.py's get_supported() function as is.
 #param implementation: A string or None. This is passed to
 #ompatibility_tags.py's get_supported() function as is.
 #""
        # Store the given py_version_info for when we call get_supported().
 #elf._given_py_version_info = py_version_info

 #f py_version_info is None:
 #y_version_info = sys.version_info[:3]
 #lse:
 #y_version_info = normalize_version_info(py_version_info)

 #y_version = ".".join(map(str, py_version_info[:2]))

 #elf.abis = abis
 #elf.implementation = implementation
 #elf.platforms = platforms
 #elf.py_version = py_version
 #elf.py_version_info = py_version_info

        # This is used to cache the return value of get_(un)sorted_tags.
 #elf._valid_tags: Optional[List[Tag]] = None
 #elf._valid_tags_set: Optional[Set[Tag]] = None

 #ef format_given(self) -> str:
 #""
 #ormat the given, non-None attributes for display.
 #""
 #isplay_version = None
 #f self._given_py_version_info is not None:
 #isplay_version = ".".join(
 #tr(part) for part in self._given_py_version_info
 #

 #ey_values = [
 #"platforms", self.platforms),
 #"version_info", display_version),
 #"abis", self.abis),
 #"implementation", self.implementation),
 #
 #eturn " ".join(
 #"{key}={value!r}" for key, value in key_values if value is not None
 #

 #ef get_sorted_tags(self) -> List[Tag]:
 #""
 #eturn the supported PEP 425 tags to check wheel candidates against.

 #he tags are returned in order of preference (most preferred first).
 #""
 #f self._valid_tags is None:
            # Pass versions=None if no py_version_info was given since
            # versions=None uses special default logic.
 #y_version_info = self._given_py_version_info
 #f py_version_info is None:
 #ersion = None
 #lse:
 #ersion = version_info_to_nodot(py_version_info)

 #ags = get_supported(
 #ersion=version,
 #latforms=self.platforms,
 #bis=self.abis,
 #mpl=self.implementation,
 #
 #elf._valid_tags = tags

 #eturn self._valid_tags

 #ef get_unsorted_tags(self) -> Set[Tag]:
 #""Exactly the same as get_sorted_tags, but returns a set.

 #his is important for performance.
 #""
 #f self._valid_tags_set is None:
 #elf._valid_tags_set = set(self.get_sorted_tags())

 #eturn self._valid_tags_set
