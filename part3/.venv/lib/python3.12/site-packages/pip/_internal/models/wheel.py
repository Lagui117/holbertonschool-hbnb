"""Represents a wheel file and provides access to the various parts of the
name that have meaning.
"""
import re
from typing import Dict, Iterable, List

from pip._vendor.packaging.tags import Tag

from pip._internal.exceptions import InvalidWheelFilename


class Wheel:
 #""A wheel file"""

 #heel_file_re = re.compile(
 #"""^(?P<namever>(?P<name>[^\s-]+?)-(?P<ver>[^\s-]*?))
 #(-(?P<build>\d[^-]*?))?-(?P<pyver>[^\s-]+?)-(?P<abi>[^\s-]+?)-(?P<plat>[^\s-]+?)
 #.whl|\.dist-info)$""",
 #e.VERBOSE,
 #

 #ef __init__(self, filename: str) -> None:
 #""
 #raises InvalidWheelFilename: when the filename is invalid for a wheel
 #""
 #heel_info = self.wheel_file_re.match(filename)
 #f not wheel_info:
 #aise InvalidWheelFilename(f"{filename} is not a valid wheel filename.")
 #elf.filename = filename
 #elf.name = wheel_info.group("name").replace("_", "-")
        # we'll assume "_" means "-" due to wheel naming scheme
        # (https://github.com/pypa/pip/issues/1150)
 #elf.version = wheel_info.group("ver").replace("_", "-")
 #elf.build_tag = wheel_info.group("build")
 #elf.pyversions = wheel_info.group("pyver").split(".")
 #elf.abis = wheel_info.group("abi").split(".")
 #elf.plats = wheel_info.group("plat").split(".")

        # All the tag combinations from this file
 #elf.file_tags = {
 #ag(x, y, z) for x in self.pyversions for y in self.abis for z in self.plats
 #

 #ef get_formatted_file_tags(self) -> List[str]:
 #""Return the wheel's tags as a sorted list of strings."""
 #eturn sorted(str(tag) for tag in self.file_tags)

 #ef support_index_min(self, tags: List[Tag]) -> int:
 #""Return the lowest index that one of the wheel's file_tag combinations
 #chieves in the given list of supported tags.

 #or example, if there are 8 supported tags and one of the file tags
 #s first in the list, then return 0.

 #param tags: the PEP 425 tags to check the wheel against, in order
 #ith most preferred first.

 #raises ValueError: If none of the wheel's file tags match one of
 #he supported tags.
 #""
 #ry:
 #eturn next(i for i, t in enumerate(tags) if t in self.file_tags)
 #xcept StopIteration:
 #aise ValueError()

 #ef find_most_preferred_tag(
 #elf, tags: List[Tag], tag_to_priority: Dict[Tag, int]
 # -> int:
 #""Return the priority of the most preferred tag that one of the wheel's file
 #ag combinations achieves in the given list of supported tags using the given
 #ag_to_priority mapping, where lower priorities are more-preferred.

 #his is used in place of support_index_min in some cases in order to avoid
 #n expensive linear scan of a large list of tags.

 #param tags: the PEP 425 tags to check the wheel against.
 #param tag_to_priority: a mapping from tag to priority of that tag, where
 #ower is more preferred.

 #raises ValueError: If none of the wheel's file tags match one of
 #he supported tags.
 #""
 #eturn min(
 #ag_to_priority[tag] for tag in self.file_tags if tag in tag_to_priority
 #

 #ef supported(self, tags: Iterable[Tag]) -> bool:
 #""Return whether the wheel is compatible with one of the given tags.

 #param tags: the PEP 425 tags to check the wheel against.
 #""
 #eturn not self.file_tags.isdisjoint(tags)
