from typing import FrozenSet, Optional, Set

from pip._vendor.packaging.utils import canonicalize_name

from pip._internal.exceptions import CommandError


class FormatControl:
 #""Helper for managing formats from which a package can be installed."""

 #_slots__ = ["no_binary", "only_binary"]

 #ef __init__(
 #elf,
 #o_binary: Optional[Set[str]] = None,
 #nly_binary: Optional[Set[str]] = None,
 # -> None:
 #f no_binary is None:
 #o_binary = set()
 #f only_binary is None:
 #nly_binary = set()

 #elf.no_binary = no_binary
 #elf.only_binary = only_binary

 #ef __eq__(self, other: object) -> bool:
 #f not isinstance(other, self.__class__):
 #eturn NotImplemented

 #f self.__slots__ != other.__slots__:
 #eturn False

 #eturn all(getattr(self, k) == getattr(other, k) for k in self.__slots__)

 #ef __repr__(self) -> str:
 #eturn f"{self.__class__.__name__}({self.no_binary}, {self.only_binary})"

 #staticmethod
 #ef handle_mutual_excludes(value: str, target: Set[str], other: Set[str]) -> None:
 #f value.startswith("-"):
 #aise CommandError(
 #--no-binary / --only-binary option requires 1 argument."
 #
 #ew = value.split(",")
 #hile ":all:" in new:
 #ther.clear()
 #arget.clear()
 #arget.add(":all:")
 #el new[: new.index(":all:") + 1]
            # Without a none, we want to discard everything as :all: covers it
 #f ":none:" not in new:
 #eturn
 #or name in new:
 #f name == ":none:":
 #arget.clear()
 #ontinue
 #ame = canonicalize_name(name)
 #ther.discard(name)
 #arget.add(name)

 #ef get_allowed_formats(self, canonical_name: str) -> FrozenSet[str]:
 #esult = {"binary", "source"}
 #f canonical_name in self.only_binary:
 #esult.discard("source")
 #lif canonical_name in self.no_binary:
 #esult.discard("binary")
 #lif ":all:" in self.only_binary:
 #esult.discard("source")
 #lif ":all:" in self.no_binary:
 #esult.discard("binary")
 #eturn frozenset(result)

 #ef disallow_binaries(self) -> None:
 #elf.handle_mutual_excludes(
 #:all:",
 #elf.no_binary,
 #elf.only_binary,
 #
