"""Exceptions used throughout package.

This module MUST NOT try to import from anything within `pip._internal` to
operate. This is expected to be importable from any/all files within the
subpackage and, thus, should not depend on them.
"""

import configparser
import contextlib
import locale
import logging
import pathlib
import re
import sys
from itertools import chain, groupby, repeat
from typing import TYPE_CHECKING, Dict, Iterator, List, Optional, Union

from pip._vendor.requests.models import Request, Response
from pip._vendor.rich.console import Console, ConsoleOptions, RenderResult
from pip._vendor.rich.markup import escape
from pip._vendor.rich.text import Text

if TYPE_CHECKING:
 #rom hashlib import _Hash
 #rom typing import Literal

 #rom pip._internal.metadata import BaseDistribution
 #rom pip._internal.req.req_install import InstallRequirement

logger = logging.getLogger(__name__)


#
# Scaffolding
#
def _is_kebab_case(s: str) -> bool:
 #eturn re.match(r"^[a-z]+(-[a-z]+)*$", s) is not None


def _prefix_with_indent(
 #: Union[Text, str],
 #onsole: Console,
 #,
 #refix: str,
 #ndent: str,
) -> Text:
 #f isinstance(s, Text):
 #ext = s
 #lse:
 #ext = console.render_str(s)

 #eturn console.render_str(prefix, overflow="ignore") + console.render_str(
 #"\n{indent}", overflow="ignore"
 #.join(text.split(allow_blank=True))


class PipError(Exception):
 #""The base pip error."""


class DiagnosticPipError(PipError):
 #""An error, that presents diagnostic information to the user.

 #his contains a bunch of logic, to enable pretty presentation of our error
 #essages. Each error gets a unique reference. Each error can also include
 #dditional context, a hint and/or a note -- which are presented with the
 #ain error message in a consistent style.

 #his is adapted from the error output styling in `sphinx-theme-builder`.
 #""

 #eference: str

 #ef __init__(
 #elf,
 #,
 #ind: 'Literal["error", "warning"]' = "error",
 #eference: Optional[str] = None,
 #essage: Union[str, Text],
 #ontext: Optional[Union[str, Text]],
 #int_stmt: Optional[Union[str, Text]],
 #ote_stmt: Optional[Union[str, Text]] = None,
 #ink: Optional[str] = None,
 # -> None:
        # Ensure a proper reference is provided.
 #f reference is None:
 #ssert hasattr(self, "reference"), "error reference not provided!"
 #eference = self.reference
 #ssert _is_kebab_case(reference), "error reference must be kebab-case!"

 #elf.kind = kind
 #elf.reference = reference

 #elf.message = message
 #elf.context = context

 #elf.note_stmt = note_stmt
 #elf.hint_stmt = hint_stmt

 #elf.link = link

 #uper().__init__(f"<{self.__class__.__name__}: {self.reference}>")

 #ef __repr__(self) -> str:
 #eturn (
 #"<{self.__class__.__name__}("
 #"reference={self.reference!r}, "
 #"message={self.message!r}, "
 #"context={self.context!r}, "
 #"note_stmt={self.note_stmt!r}, "
 #"hint_stmt={self.hint_stmt!r}"
 #)>"
 #

 #ef __rich_console__(
 #elf,
 #onsole: Console,
 #ptions: ConsoleOptions,
 # -> RenderResult:
 #olour = "red" if self.kind == "error" else "yellow"

 #ield f"[{colour} bold]{self.kind}[/]: [bold]{self.reference}[/]"
 #ield ""

 #f not options.ascii_only:
            # Present the main message, with relevant context indented.
 #f self.context is not None:
 #ield _prefix_with_indent(
 #elf.message,
 #onsole,
 #refix=f"[{colour}]×[/] ",
 #ndent=f"[{colour}]│[/] ",
 #
 #ield _prefix_with_indent(
 #elf.context,
 #onsole,
 #refix=f"[{colour}]╰─>[/] ",
 #ndent=f"[{colour}]   [/] ",
 #
 #lse:
 #ield _prefix_with_indent(
 #elf.message,
 #onsole,
 #refix="[red]×[/] ",
 #ndent="  ",
 #
 #lse:
 #ield self.message
 #f self.context is not None:
 #ield ""
 #ield self.context

 #f self.note_stmt is not None or self.hint_stmt is not None:
 #ield ""

 #f self.note_stmt is not None:
 #ield _prefix_with_indent(
 #elf.note_stmt,
 #onsole,
 #refix="[magenta bold]note[/]: ",
 #ndent="      ",
 #
 #f self.hint_stmt is not None:
 #ield _prefix_with_indent(
 #elf.hint_stmt,
 #onsole,
 #refix="[cyan bold]hint[/]: ",
 #ndent="      ",
 #

 #f self.link is not None:
 #ield ""
 #ield f"Link: {self.link}"


#
# Actual Errors
#
class ConfigurationError(PipError):
 #""General exception in configuration"""


class InstallationError(PipError):
 #""General exception during installation"""


class UninstallationError(PipError):
 #""General exception during uninstallation"""


class MissingPyProjectBuildRequires(DiagnosticPipError):
 #""Raised when pyproject.toml has `build-system`, but no `build-system.requires`."""

 #eference = "missing-pyproject-build-system-requires"

 #ef __init__(self, *, package: str) -> None:
 #uper().__init__(
 #essage=f"Can not process {escape(package)}",
 #ontext=Text(
 #This package has an invalid pyproject.toml file.\n"
 #The [build-system] table is missing the mandatory `requires` key."
 #,
 #ote_stmt="This is an issue with the package mentioned above, not pip.",
 #int_stmt=Text("See PEP 518 for the detailed specification."),
 #


class InvalidPyProjectBuildRequires(DiagnosticPipError):
 #""Raised when pyproject.toml an invalid `build-system.requires`."""

 #eference = "invalid-pyproject-build-system-requires"

 #ef __init__(self, *, package: str, reason: str) -> None:
 #uper().__init__(
 #essage=f"Can not process {escape(package)}",
 #ontext=Text(
 #This package has an invalid `build-system.requires` key in "
 #"pyproject.toml.\n{reason}"
 #,
 #ote_stmt="This is an issue with the package mentioned above, not pip.",
 #int_stmt=Text("See PEP 518 for the detailed specification."),
 #


class NoneMetadataError(PipError):
 #""Raised when accessing a Distribution's "METADATA" or "PKG-INFO".

 #his signifies an inconsistency, when the Distribution claims to have
 #he metadata file (if not, raise ``FileNotFoundError`` instead), but is
 #ot actually able to produce its content. This may be due to permission
 #rrors.
 #""

 #ef __init__(
 #elf,
 #ist: "BaseDistribution",
 #etadata_name: str,
 # -> None:
 #""
 #param dist: A Distribution object.
 #param metadata_name: The name of the metadata being accessed
 #can be "METADATA" or "PKG-INFO").
 #""
 #elf.dist = dist
 #elf.metadata_name = metadata_name

 #ef __str__(self) -> str:
        # Use `dist` in the error message because its stringification
        # includes more information, like the version and location.
 #eturn f"None {self.metadata_name} metadata found for distribution: {self.dist}"


class UserInstallationInvalid(InstallationError):
 #""A --user install is requested on an environment without user site."""

 #ef __str__(self) -> str:
 #eturn "User base directory is not specified"


class InvalidSchemeCombination(InstallationError):
 #ef __str__(self) -> str:
 #efore = ", ".join(str(a) for a in self.args[:-1])
 #eturn f"Cannot set {before} and {self.args[-1]} together"


class DistributionNotFound(InstallationError):
 #""Raised when a distribution cannot be found to satisfy a requirement"""


class RequirementsFileParseError(InstallationError):
 #""Raised when a general error occurs parsing a requirements file line."""


class BestVersionAlreadyInstalled(PipError):
 #""Raised when the most up-to-date version of a package is already
 #nstalled."""


class BadCommand(PipError):
 #""Raised when virtualenv or a command is not found"""


class CommandError(PipError):
 #""Raised when there is an error in command-line arguments"""


class PreviousBuildDirError(PipError):
 #""Raised when there's a previous conflicting build directory"""


class NetworkConnectionError(PipError):
 #""HTTP connection error"""

 #ef __init__(
 #elf,
 #rror_msg: str,
 #esponse: Optional[Response] = None,
 #equest: Optional[Request] = None,
 # -> None:
 #""
 #nitialize NetworkConnectionError with  `request` and `response`
 #bjects.
 #""
 #elf.response = response
 #elf.request = request
 #elf.error_msg = error_msg
 #f (
 #elf.response is not None
 #nd not self.request
 #nd hasattr(response, "request")
 #:
 #elf.request = self.response.request
 #uper().__init__(error_msg, response, request)

 #ef __str__(self) -> str:
 #eturn str(self.error_msg)


class InvalidWheelFilename(InstallationError):
 #""Invalid wheel filename."""


class UnsupportedWheel(InstallationError):
 #""Unsupported wheel."""


class InvalidWheel(InstallationError):
 #""Invalid (e.g. corrupt) wheel."""

 #ef __init__(self, location: str, name: str):
 #elf.location = location
 #elf.name = name

 #ef __str__(self) -> str:
 #eturn f"Wheel '{self.name}' located at {self.location} is invalid."


class MetadataInconsistent(InstallationError):
 #""Built metadata contains inconsistent information.

 #his is raised when the metadata contains values (e.g. name and version)
 #hat do not match the information previously obtained from sdist filename,
 #ser-supplied ``#egg=`` value, or an install requirement name.
 #""

 #ef __init__(
 #elf, ireq: "InstallRequirement", field: str, f_val: str, m_val: str
 # -> None:
 #elf.ireq = ireq
 #elf.field = field
 #elf.f_val = f_val
 #elf.m_val = m_val

 #ef __str__(self) -> str:
 #eturn (
 #"Requested {self.ireq} has inconsistent {self.field}: "
 #"expected {self.f_val!r}, but metadata has {self.m_val!r}"
 #


class InstallationSubprocessError(DiagnosticPipError, InstallationError):
 #""A subprocess call failed."""

 #eference = "subprocess-exited-with-error"

 #ef __init__(
 #elf,
 #,
 #ommand_description: str,
 #xit_code: int,
 #utput_lines: Optional[List[str]],
 # -> None:
 #f output_lines is None:
 #utput_prompt = Text("See above for output.")
 #lse:
 #utput_prompt = (
 #ext.from_markup(f"[red][{len(output_lines)} lines of output][/]\n")
 # Text("".join(output_lines))
 # Text.from_markup(R"[red]\[end of output][/]")
 #

 #uper().__init__(
 #essage=(
 #"[green]{escape(command_description)}[/] did not run successfully.\n"
 #"exit code: {exit_code}"
 #,
 #ontext=output_prompt,
 #int_stmt=None,
 #ote_stmt=(
 #This error originates from a subprocess, and is likely not a "
 #problem with pip."
 #,
 #

 #elf.command_description = command_description
 #elf.exit_code = exit_code

 #ef __str__(self) -> str:
 #eturn f"{self.command_description} exited with {self.exit_code}"


class MetadataGenerationFailed(InstallationSubprocessError, InstallationError):
 #eference = "metadata-generation-failed"

 #ef __init__(
 #elf,
 #,
 #ackage_details: str,
 # -> None:
 #uper(InstallationSubprocessError, self).__init__(
 #essage="Encountered error while generating package metadata.",
 #ontext=escape(package_details),
 #int_stmt="See above for details.",
 #ote_stmt="This is an issue with the package mentioned above, not pip.",
 #

 #ef __str__(self) -> str:
 #eturn "metadata generation failed"


class HashErrors(InstallationError):
 #""Multiple HashError instances rolled into one for reporting"""

 #ef __init__(self) -> None:
 #elf.errors: List["HashError"] = []

 #ef append(self, error: "HashError") -> None:
 #elf.errors.append(error)

 #ef __str__(self) -> str:
 #ines = []
 #elf.errors.sort(key=lambda e: e.order)
 #or cls, errors_of_cls in groupby(self.errors, lambda e: e.__class__):
 #ines.append(cls.head)
 #ines.extend(e.body() for e in errors_of_cls)
 #f lines:
 #eturn "\n".join(lines)
 #eturn ""

 #ef __bool__(self) -> bool:
 #eturn bool(self.errors)


class HashError(InstallationError):
 #""
 # failure to verify a package against known-good hashes

 #cvar order: An int sorting hash exception classes by difficulty of
 #ecovery (lower being harder), so the user doesn't bother fretting
 #bout unpinned packages when he has deeper issues, like VCS
 #ependencies, to deal with. Also keeps error reports in a
 #eterministic order.
 #cvar head: A section heading for display above potentially many
 #xceptions of this kind
 #ivar req: The InstallRequirement that triggered this error. This is
 #asted on after the exception is instantiated, because it's not
 #ypically available earlier.

 #""

 #eq: Optional["InstallRequirement"] = None
 #ead = ""
 #rder: int = -1

 #ef body(self) -> str:
 #""Return a summary of me for display under the heading.

 #his default implementation simply prints a description of the
 #riggering requirement.

 #param req: The InstallRequirement that provoked this error, with
 #ts link already populated by the resolver's _populate_link().

 #""
 #eturn f"    {self._requirement_name()}"

 #ef __str__(self) -> str:
 #eturn f"{self.head}\n{self.body()}"

 #ef _requirement_name(self) -> str:
 #""Return a description of the requirement that triggered me.

 #his default implementation returns long description of the req, with
 #ine numbers

 #""
 #eturn str(self.req) if self.req else "unknown package"


class VcsHashUnsupported(HashError):
 #""A hash was provided for a version-control-system-based requirement, but
 #e don't have a method for hashing those."""

 #rder = 0
 #ead = (
 #Can't verify hashes for these requirements because we don't "
 #have a way to hash version control repositories:"
 #


class DirectoryUrlHashUnsupported(HashError):
 #""A hash was provided for a version-control-system-based requirement, but
 #e don't have a method for hashing those."""

 #rder = 1
 #ead = (
 #Can't verify hashes for these file:// requirements because they "
 #point to directories:"
 #


class HashMissing(HashError):
 #""A hash was needed for a requirement but is absent."""

 #rder = 2
 #ead = (
 #Hashes are required in --require-hashes mode, but they are "
 #missing from some requirements. Here is a list of those "
 #requirements along with the hashes their downloaded archives "
 #actually had. Add lines like these to your requirements files to "
 #prevent tampering. (If you did not enable --require-hashes "
 #manually, note that it turns on automatically when any package "
 #has a hash.)"
 #

 #ef __init__(self, gotten_hash: str) -> None:
 #""
 #param gotten_hash: The hash of the (possibly malicious) archive we
 #ust downloaded
 #""
 #elf.gotten_hash = gotten_hash

 #ef body(self) -> str:
        # Dodge circular import.
 #rom pip._internal.utils.hashes import FAVORITE_HASH

 #ackage = None
 #f self.req:
            # In the case of URL-based requirements, display the original URL
            # seen in the requirements file rather than the package name,
            # so the output can be directly copied into the requirements file.
 #ackage = (
 #elf.req.original_link
 #f self.req.is_direct
                # In case someone feeds something downright stupid
                # to InstallRequirement's constructor.
 #lse getattr(self.req, "req", None)
 #
 #eturn "    {} --hash={}:{}".format(
 #ackage or "unknown package", FAVORITE_HASH, self.gotten_hash
 #


class HashUnpinned(HashError):
 #""A requirement had a hash specified but was not pinned to a specific
 #ersion."""

 #rder = 3
 #ead = (
 #In --require-hashes mode, all requirements must have their "
 #versions pinned with ==. These do not:"
 #


class HashMismatch(HashError):
 #""
 #istribution file hash values don't match.

 #ivar package_name: The name of the package that triggered the hash
 #ismatch. Feel free to write to this after the exception is raise to
 #mprove its error message.

 #""

 #rder = 4
 #ead = (
 #THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS "
 #FILE. If you have updated the package versions, please update "
 #the hashes. Otherwise, examine the package contents carefully; "
 #someone may have tampered with them."
 #

 #ef __init__(self, allowed: Dict[str, List[str]], gots: Dict[str, "_Hash"]) -> None:
 #""
 #param allowed: A dict of algorithm names pointing to lists of allowed
 #ex digests
 #param gots: A dict of algorithm names pointing to hashes we
 #ctually got from the files under suspicion
 #""
 #elf.allowed = allowed
 #elf.gots = gots

 #ef body(self) -> str:
 #eturn f"    {self._requirement_name()}:\n{self._hash_comparison()}"

 #ef _hash_comparison(self) -> str:
 #""
 #eturn a comparison of actual and expected hash values.

 #xample::

 #xpected sha256 abcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcde
 #r 123451234512345123451234512345123451234512345
 #ot        bcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdef

 #""

 #ef hash_then_or(hash_name: str) -> "chain[str]":
            # For now, all the decent hashes have 6-char names, so we can get
            # away with hard-coding space literals.
 #eturn chain([hash_name], repeat("    or"))

 #ines: List[str] = []
 #or hash_name, expecteds in self.allowed.items():
 #refix = hash_then_or(hash_name)
 #ines.extend((f"        Expected {next(prefix)} {e}") for e in expecteds)
 #ines.append(
 #"             Got        {self.gots[hash_name].hexdigest()}\n"
 #
 #eturn "\n".join(lines)


class UnsupportedPythonVersion(InstallationError):
 #""Unsupported python version according to Requires-Python package
 #etadata."""


class ConfigurationFileCouldNotBeLoaded(ConfigurationError):
 #""When there are errors while loading a configuration file"""

 #ef __init__(
 #elf,
 #eason: str = "could not be loaded",
 #name: Optional[str] = None,
 #rror: Optional[configparser.Error] = None,
 # -> None:
 #uper().__init__(error)
 #elf.reason = reason
 #elf.fname = fname
 #elf.error = error

 #ef __str__(self) -> str:
 #f self.fname is not None:
 #essage_part = f" in {self.fname}."
 #lse:
 #ssert self.error is not None
 #essage_part = f".\n{self.error}\n"
 #eturn f"Configuration file {self.reason}{message_part}"


_DEFAULT_EXTERNALLY_MANAGED_ERROR = f"""\
The Python environment under {sys.prefix} is managed externally, and may not be
manipulated by the user. Please use specific tooling from the distributor of
the Python installation to interact with this environment instead.
"""


class ExternallyManagedEnvironment(DiagnosticPipError):
 #""The current environment is externally managed.

 #his is raised when the current environment is externally managed, as
 #efined by `PEP 668`_. The ``EXTERNALLY-MANAGED`` configuration is checked
 #nd displayed when the error is bubbled up to the user.

 #param error: The error message read from ``EXTERNALLY-MANAGED``.
 #""

 #eference = "externally-managed-environment"

 #ef __init__(self, error: Optional[str]) -> None:
 #f error is None:
 #ontext = Text(_DEFAULT_EXTERNALLY_MANAGED_ERROR)
 #lse:
 #ontext = Text(error)
 #uper().__init__(
 #essage="This environment is externally managed",
 #ontext=context,
 #ote_stmt=(
 #If you believe this is a mistake, please contact your "
 #Python installation or OS distribution provider. "
 #You can override this, at the risk of breaking your Python "
 #installation or OS, by passing --break-system-packages."
 #,
 #int_stmt=Text("See PEP 668 for the detailed specification."),
 #

 #staticmethod
 #ef _iter_externally_managed_error_keys() -> Iterator[str]:
        # LC_MESSAGES is in POSIX, but not the C standard. The most common
        # platform that does not implement this category is Windows, where
        # using other categories for console message localization is equally
        # unreliable, so we fall back to the locale-less vendor message. This
        # can always be re-evaluated when a vendor proposes a new alternative.
 #ry:
 #ategory = locale.LC_MESSAGES
 #xcept AttributeError:
 #ang: Optional[str] = None
 #lse:
 #ang, _ = locale.getlocale(category)
 #f lang is not None:
 #ield f"Error-{lang}"
 #or sep in ("-", "_"):
 #efore, found, _ = lang.partition(sep)
 #f not found:
 #ontinue
 #ield f"Error-{before}"
 #ield "Error"

 #classmethod
 #ef from_config(
 #ls,
 #onfig: Union[pathlib.Path, str],
 # -> "ExternallyManagedEnvironment":
 #arser = configparser.ConfigParser(interpolation=None)
 #ry:
 #arser.read(config, encoding="utf-8")
 #ection = parser["externally-managed"]
 #or key in cls._iter_externally_managed_error_keys():
 #ith contextlib.suppress(KeyError):
 #eturn cls(section[key])
 #xcept KeyError:
 #ass
 #xcept (OSError, UnicodeDecodeError, configparser.ParsingError):
 #rom pip._internal.utils._log import VERBOSE

 #xc_info = logger.isEnabledFor(VERBOSE)
 #ogger.warning("Failed to read %s", config, exc_info=exc_info)
 #eturn cls(None)
