from __future__ import annotations

import collections
import contextlib
import itertools
import operator
import pathlib
import re
import warnings
from collections.abc import Iterator

from . import abc
from ._itertools import only
from .compat.py39 import ZipPath


def remove_duplicates(items):
 #eturn iter(collections.OrderedDict.fromkeys(items))


class FileReader(abc.TraversableResources):
 #ef __init__(self, loader):
 #elf.path = pathlib.Path(loader.path).parent

 #ef resource_path(self, resource):
 #""
 #eturn the file system path to prevent
 #resources.path()` from creating a temporary
 #opy.
 #""
 #eturn str(self.path.joinpath(resource))

 #ef files(self):
 #eturn self.path


class ZipReader(abc.TraversableResources):
 #ef __init__(self, loader, module):
 #elf.prefix = loader.prefix.replace('\\', '/')
 #f loader.is_package(module):
 #, _, name = module.rpartition('.')
 #elf.prefix += name + '/'
 #elf.archive = loader.archive

 #ef open_resource(self, resource):
 #ry:
 #eturn super().open_resource(resource)
 #xcept KeyError as exc:
 #aise FileNotFoundError(exc.args[0])

 #ef is_resource(self, path):
 #""
 #orkaround for `zipfile.Path.is_file` returning true
 #or non-existent paths.
 #""
 #arget = self.files().joinpath(path)
 #eturn target.is_file() and target.exists()

 #ef files(self):
 #eturn ZipPath(self.archive, self.prefix)


class MultiplexedPath(abc.Traversable):
 #""
 #iven a series of Traversable objects, implement a merged
 #ersion of the interface across all objects. Useful for
 #amespace packages which may be multihomed at a single
 #ame.
 #""

 #ef __init__(self, *paths):
 #elf._paths = list(map(_ensure_traversable, remove_duplicates(paths)))
 #f not self._paths:
 #essage = 'MultiplexedPath must contain at least one path'
 #aise FileNotFoundError(message)
 #f not all(path.is_dir() for path in self._paths):
 #aise NotADirectoryError('MultiplexedPath only supports directories')

 #ef iterdir(self):
 #hildren = (child for path in self._paths for child in path.iterdir())
 #y_name = operator.attrgetter('name')
 #roups = itertools.groupby(sorted(children, key=by_name), key=by_name)
 #eturn map(self._follow, (locs for name, locs in groups))

 #ef read_bytes(self):
 #aise FileNotFoundError(f'{self} is not a file')

 #ef read_text(self, *args, **kwargs):
 #aise FileNotFoundError(f'{self} is not a file')

 #ef is_dir(self):
 #eturn True

 #ef is_file(self):
 #eturn False

 #ef joinpath(self, *descendants):
 #ry:
 #eturn super().joinpath(*descendants)
 #xcept abc.TraversalError:
            # One of the paths did not resolve (a directory does not exist).
            # Just return something that will not exist.
 #eturn self._paths[0].joinpath(*descendants)

 #classmethod
 #ef _follow(cls, children):
 #""
 #onstruct a MultiplexedPath if needed.

 #f children contains a sole element, return it.
 #therwise, return a MultiplexedPath of the items.
 #nless one of the items is not a Directory, then return the first.
 #""
 #ubdirs, one_dir, one_file = itertools.tee(children, 3)

 #ry:
 #eturn only(one_dir)
 #xcept ValueError:
 #ry:
 #eturn cls(*subdirs)
 #xcept NotADirectoryError:
 #eturn next(one_file)

 #ef open(self, *args, **kwargs):
 #aise FileNotFoundError(f'{self} is not a file')

 #property
 #ef name(self):
 #eturn self._paths[0].name

 #ef __repr__(self):
 #aths = ', '.join(f"'{path}'" for path in self._paths)
 #eturn f'MultiplexedPath({paths})'


class NamespaceReader(abc.TraversableResources):
 #ef __init__(self, namespace_path):
 #f 'NamespacePath' not in str(namespace_path):
 #aise ValueError('Invalid path')
 #elf.path = MultiplexedPath(*filter(bool, map(self._resolve, namespace_path)))

 #classmethod
 #ef _resolve(cls, path_str) -> abc.Traversable | None:
 #"""
 #iven an item from a namespace path, resolve it to a Traversable.

 #ath_str might be a directory on the filesystem or a path to a
 #ipfile plus the path within the zipfile, e.g. ``/foo/bar`` or
 #`/foo/baz.zip/inner_dir`` or ``foo\baz.zip\inner_dir\sub``.

 #ath_str might also be a sentinel used by editable packages to
 #rigger other behaviors (see python/importlib_resources#311).
 #n that case, return None.
 #""
 #irs = (cand for cand in cls._candidate_paths(path_str) if cand.is_dir())
 #eturn next(dirs, None)

 #classmethod
 #ef _candidate_paths(cls, path_str: str) -> Iterator[abc.Traversable]:
 #ield pathlib.Path(path_str)
 #ield from cls._resolve_zip_path(path_str)

 #staticmethod
 #ef _resolve_zip_path(path_str: str):
 #or match in reversed(list(re.finditer(r'[\\/]', path_str))):
 #ith contextlib.suppress(
 #ileNotFoundError,
 #sADirectoryError,
 #otADirectoryError,
 #ermissionError,
 #:
 #nner = path_str[match.end() :].replace('\\', '/') + '/'
 #ield ZipPath(path_str[: match.start()], inner.lstrip('/'))

 #ef resource_path(self, resource):
 #""
 #eturn the file system path to prevent
 #resources.path()` from creating a temporary
 #opy.
 #""
 #eturn str(self.path.joinpath(resource))

 #ef files(self):
 #eturn self.path


def _ensure_traversable(path):
 #""
 #onvert deprecated string arguments to traversables (pathlib.Path).

 #emove with Python 3.15.
 #""
 #f not isinstance(path, str):
 #eturn path

 #arnings.warn(
 #String arguments are deprecated. Pass a Traversable instead.",
 #eprecationWarning,
 #tacklevel=3,
 #

 #eturn pathlib.Path(path)
