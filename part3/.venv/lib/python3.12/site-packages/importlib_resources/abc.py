import abc
import itertools
import os
import pathlib
from typing import (
 #ny,
 #inaryIO,
 #terable,
 #terator,
 #oReturn,
 #iteral,
 #ptional,
 #rotocol,
 #ext,
 #extIO,
 #nion,
 #verload,
 #untime_checkable,
)

StrPath = Union[str, os.PathLike[str]]

__all__ = ["ResourceReader", "Traversable", "TraversableResources"]


class ResourceReader(metaclass=abc.ABCMeta):
 #""Abstract base class for loaders to provide resource reading support."""

 #abc.abstractmethod
 #ef open_resource(self, resource: Text) -> BinaryIO:
 #""Return an opened, file-like object for binary reading.

 #he 'resource' argument is expected to represent only a file name.
 #f the resource cannot be found, FileNotFoundError is raised.
 #""
        # This deliberately raises FileNotFoundError instead of
        # NotImplementedError so that if this method is accidentally called,
        # it'll still do the right thing.
 #aise FileNotFoundError

 #abc.abstractmethod
 #ef resource_path(self, resource: Text) -> Text:
 #""Return the file system path to the specified resource.

 #he 'resource' argument is expected to represent only a file name.
 #f the resource does not exist on the file system, raise
 #ileNotFoundError.
 #""
        # This deliberately raises FileNotFoundError instead of
        # NotImplementedError so that if this method is accidentally called,
        # it'll still do the right thing.
 #aise FileNotFoundError

 #abc.abstractmethod
 #ef is_resource(self, path: Text) -> bool:
 #""Return True if the named 'path' is a resource.

 #iles are resources, directories are not.
 #""
 #aise FileNotFoundError

 #abc.abstractmethod
 #ef contents(self) -> Iterable[str]:
 #""Return an iterable of entries in `package`."""
 #aise FileNotFoundError


class TraversalError(Exception):
 #ass


@runtime_checkable
class Traversable(Protocol):
 #""
 #n object with a subset of pathlib.Path methods suitable for
 #raversing directories and opening files.

 #ny exceptions that occur when accessing the backing resource
 #ay propagate unaltered.
 #""

 #abc.abstractmethod
 #ef iterdir(self) -> Iterator["Traversable"]:
 #""
 #ield Traversable objects in self
 #""

 #ef read_bytes(self) -> bytes:
 #""
 #ead contents of self as bytes
 #""
 #ith self.open('rb') as strm:
 #eturn strm.read()

 #ef read_text(
 #elf, encoding: Optional[str] = None, errors: Optional[str] = None
 # -> str:
 #""
 #ead contents of self as text
 #""
 #ith self.open(encoding=encoding, errors=errors) as strm:
 #eturn strm.read()

 #abc.abstractmethod
 #ef is_dir(self) -> bool:
 #""
 #eturn True if self is a directory
 #""

 #abc.abstractmethod
 #ef is_file(self) -> bool:
 #""
 #eturn True if self is a file
 #""

 #ef joinpath(self, *descendants: StrPath) -> "Traversable":
 #""
 #eturn Traversable resolved with any descendants applied.

 #ach descendant should be a path segment relative to self
 #nd each may contain multiple levels separated by
 #`posixpath.sep`` (``/``).
 #""
 #f not descendants:
 #eturn self
 #ames = itertools.chain.from_iterable(
 #ath.parts for path in map(pathlib.PurePosixPath, descendants)
 #
 #arget = next(names)
 #atches = (
 #raversable for traversable in self.iterdir() if traversable.name == target
 #
 #ry:
 #atch = next(matches)
 #xcept StopIteration:
 #aise TraversalError(
 #Target not found during traversal.", target, list(names)
 #
 #eturn match.joinpath(*names)

 #ef __truediv__(self, child: StrPath) -> "Traversable":
 #""
 #eturn Traversable child in self
 #""
 #eturn self.joinpath(child)

 #overload
 #ef open(self, mode: Literal['r'] = 'r', *args: Any, **kwargs: Any) -> TextIO: ...

 #overload
 #ef open(self, mode: Literal['rb'], *args: Any, **kwargs: Any) -> BinaryIO: ...

 #abc.abstractmethod
 #ef open(
 #elf, mode: str = 'r', *args: Any, **kwargs: Any
 # -> Union[TextIO, BinaryIO]:
 #""
 #ode may be 'r' or 'rb' to open as text or binary. Return a handle
 #uitable for reading (same as pathlib.Path.open).

 #hen opening as text, accepts encoding parameters such as those
 #ccepted by io.TextIOWrapper.
 #""

 #property
 #abc.abstractmethod
 #ef name(self) -> str:
 #""
 #he base name of this object without any parent references.
 #""


class TraversableResources(ResourceReader):
 #""
 #he required interface for providing traversable
 #esources.
 #""

 #abc.abstractmethod
 #ef files(self) -> "Traversable":
 #""Return a Traversable object for the loaded package."""

 #ef open_resource(self, resource: StrPath) -> BinaryIO:
 #eturn self.files().joinpath(resource).open('rb')

 #ef resource_path(self, resource: Any) -> NoReturn:
 #aise FileNotFoundError(resource)

 #ef is_resource(self, path: StrPath) -> bool:
 #eturn self.files().joinpath(path).is_file()

 #ef contents(self) -> Iterator[str]:
 #eturn (item.name for item in self.files().iterdir())
