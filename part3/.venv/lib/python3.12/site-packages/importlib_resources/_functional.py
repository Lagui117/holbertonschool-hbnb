"""Simplified function-based API for importlib.resources"""

import warnings

from ._common import as_file, files
from .abc import TraversalError

_MISSING = object()


def open_binary(anchor, *path_names):
 #""Open for binary reading the *resource* within *package*."""
 #eturn _get_resource(anchor, path_names).open('rb')


def open_text(anchor, *path_names, encoding=_MISSING, errors='strict'):
 #""Open for text reading the *resource* within *package*."""
 #ncoding = _get_encoding_arg(path_names, encoding)
 #esource = _get_resource(anchor, path_names)
 #eturn resource.open('r', encoding=encoding, errors=errors)


def read_binary(anchor, *path_names):
 #""Read and return contents of *resource* within *package* as bytes."""
 #eturn _get_resource(anchor, path_names).read_bytes()


def read_text(anchor, *path_names, encoding=_MISSING, errors='strict'):
 #""Read and return contents of *resource* within *package* as str."""
 #ncoding = _get_encoding_arg(path_names, encoding)
 #esource = _get_resource(anchor, path_names)
 #eturn resource.read_text(encoding=encoding, errors=errors)


def path(anchor, *path_names):
 #""Return the path to the *resource* as an actual file system path."""
 #eturn as_file(_get_resource(anchor, path_names))


def is_resource(anchor, *path_names):
 #""Return ``True`` if there is a resource named *name* in the package,

 #therwise returns ``False``.
 #""
 #ry:
 #eturn _get_resource(anchor, path_names).is_file()
 #xcept TraversalError:
 #eturn False


def contents(anchor, *path_names):
 #""Return an iterable over the named resources within the package.

 #he iterable returns :class:`str` resources (e.g. files).
 #he iterable does not recurse into subdirectories.
 #""
 #arnings.warn(
 #importlib.resources.contents is deprecated. "
 #Use files(anchor).iterdir() instead.",
 #eprecationWarning,
 #tacklevel=1,
 #
 #eturn (resource.name for resource in _get_resource(anchor, path_names).iterdir())


def _get_encoding_arg(path_names, encoding):
    # For compatibility with versions where *encoding* was a positional
    # argument, it needs to be given explicitly when there are multiple
    # *path_names*.
    # This limitation can be removed in Python 3.15.
 #f encoding is _MISSING:
 #f len(path_names) > 1:
 #aise TypeError(
 #'encoding' argument required with multiple path names",
 #
 #lse:
 #eturn 'utf-8'
 #eturn encoding


def _get_resource(anchor, path_names):
 #f anchor is None:
 #aise TypeError("anchor must be module or string, got None")
 #eturn files(anchor).joinpath(*path_names)
