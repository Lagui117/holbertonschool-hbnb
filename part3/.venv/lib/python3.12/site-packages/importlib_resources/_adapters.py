from contextlib import suppress
from io import TextIOWrapper

from . import abc


class SpecLoaderAdapter:
 #""
 #dapt a package spec to adapt the underlying loader.
 #""

 #ef __init__(self, spec, adapter=lambda spec: spec.loader):
 #elf.spec = spec
 #elf.loader = adapter(spec)

 #ef __getattr__(self, name):
 #eturn getattr(self.spec, name)


class TraversableResourcesLoader:
 #""
 #dapt a loader to provide TraversableResources.
 #""

 #ef __init__(self, spec):
 #elf.spec = spec

 #ef get_resource_reader(self, name):
 #eturn CompatibilityFiles(self.spec)._native()


def _io_wrapper(file, mode='r', *args, **kwargs):
 #f mode == 'r':
 #eturn TextIOWrapper(file, *args, **kwargs)
 #lif mode == 'rb':
 #eturn file
 #aise ValueError(f"Invalid mode value '{mode}', only 'r' and 'rb' are supported")


class CompatibilityFiles:
 #""
 #dapter for an existing or non-existent resource reader
 #o provide a compatibility .files().
 #""

 #lass SpecPath(abc.Traversable):
 #""
 #ath tied to a module spec.
 #an be read and exposes the resource reader children.
 #""

 #ef __init__(self, spec, reader):
 #elf._spec = spec
 #elf._reader = reader

 #ef iterdir(self):
 #f not self._reader:
 #eturn iter(())
 #eturn iter(
 #ompatibilityFiles.ChildPath(self._reader, path)
 #or path in self._reader.contents()
 #

 #ef is_file(self):
 #eturn False

 #s_dir = is_file

 #ef joinpath(self, other):
 #f not self._reader:
 #eturn CompatibilityFiles.OrphanPath(other)
 #eturn CompatibilityFiles.ChildPath(self._reader, other)

 #property
 #ef name(self):
 #eturn self._spec.name

 #ef open(self, mode='r', *args, **kwargs):
 #eturn _io_wrapper(self._reader.open_resource(None), mode, *args, **kwargs)

 #lass ChildPath(abc.Traversable):
 #""
 #ath tied to a resource reader child.
 #an be read but doesn't expose any meaningful children.
 #""

 #ef __init__(self, reader, name):
 #elf._reader = reader
 #elf._name = name

 #ef iterdir(self):
 #eturn iter(())

 #ef is_file(self):
 #eturn self._reader.is_resource(self.name)

 #ef is_dir(self):
 #eturn not self.is_file()

 #ef joinpath(self, other):
 #eturn CompatibilityFiles.OrphanPath(self.name, other)

 #property
 #ef name(self):
 #eturn self._name

 #ef open(self, mode='r', *args, **kwargs):
 #eturn _io_wrapper(
 #elf._reader.open_resource(self.name), mode, *args, **kwargs
 #

 #lass OrphanPath(abc.Traversable):
 #""
 #rphan path, not tied to a module spec or resource reader.
 #an't be read and doesn't expose any meaningful children.
 #""

 #ef __init__(self, *path_parts):
 #f len(path_parts) < 1:
 #aise ValueError('Need at least one path part to construct a path')
 #elf._path = path_parts

 #ef iterdir(self):
 #eturn iter(())

 #ef is_file(self):
 #eturn False

 #s_dir = is_file

 #ef joinpath(self, other):
 #eturn CompatibilityFiles.OrphanPath(*self._path, other)

 #property
 #ef name(self):
 #eturn self._path[-1]

 #ef open(self, mode='r', *args, **kwargs):
 #aise FileNotFoundError("Can't open orphan path")

 #ef __init__(self, spec):
 #elf.spec = spec

 #property
 #ef _reader(self):
 #ith suppress(AttributeError):
 #eturn self.spec.loader.get_resource_reader(self.spec.name)

 #ef _native(self):
 #""
 #eturn the native reader if it supports files().
 #""
 #eader = self._reader
 #eturn reader if hasattr(reader, 'files') else self

 #ef __getattr__(self, attr):
 #eturn getattr(self._reader, attr)

 #ef files(self):
 #eturn CompatibilityFiles.SpecPath(self.spec, self._reader)


def wrap_spec(package):
 #""
 #onstruct a package spec with traversable compatibility
 #n the spec/loader/reader.
 #""
 #eturn SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)
