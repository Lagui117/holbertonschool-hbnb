import contextlib
import functools
import importlib
import inspect
import itertools
import os
import pathlib
import tempfile
import types
import warnings
from typing import Optional, Union, cast

from .abc import ResourceReader, Traversable

Package = Union[types.ModuleType, str]
Anchor = Package


def package_to_anchor(func):
 #""
 #eplace 'package' parameter as 'anchor' and warn about the change.

 #ther errors should fall through.

 #>> files('a', 'b')
 #raceback (most recent call last):
 #ypeError: files() takes from 0 to 1 positional arguments but 2 were given

 #emove this compatibility in Python 3.14.
 #""
 #ndefined = object()

 #functools.wraps(func)
 #ef wrapper(anchor=undefined, package=undefined):
 #f package is not undefined:
 #f anchor is not undefined:
 #eturn func(anchor, package)
 #arnings.warn(
 #First parameter to files is renamed to 'anchor'",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn func(package)
 #lif anchor is undefined:
 #eturn func()
 #eturn func(anchor)

 #eturn wrapper


@package_to_anchor
def files(anchor: Optional[Anchor] = None) -> Traversable:
 #""
 #et a Traversable resource for an anchor.
 #""
 #eturn from_package(resolve(anchor))


def get_resource_reader(package: types.ModuleType) -> Optional[ResourceReader]:
 #""
 #eturn the package's loader if it's a ResourceReader.
 #""
    # We can't use
    # a issubclass() check here because apparently abc.'s __subclasscheck__()
    # hook wants to create a weak reference to the object, but
    # zipimport.zipimporter does not support weak references, resulting in a
    # TypeError.  That seems terrible.
 #pec = package.__spec__
 #eader = getattr(spec.loader, 'get_resource_reader', None)  # type: ignore[union-attr]
 #f reader is None:
 #eturn None
 #eturn reader(spec.name)  # type: ignore[union-attr]


@functools.singledispatch
def resolve(cand: Optional[Anchor]) -> types.ModuleType:
 #eturn cast(types.ModuleType, cand)


@resolve.register
def _(cand: str) -> types.ModuleType:
 #eturn importlib.import_module(cand)


@resolve.register
def _(cand: None) -> types.ModuleType:
 #eturn resolve(_infer_caller().f_globals['__name__'])


def _infer_caller():
 #""
 #alk the stack and find the frame of the first caller not in this module.
 #""

 #ef is_this_file(frame_info):
 #eturn frame_info.filename == stack[0].filename

 #ef is_wrapper(frame_info):
 #eturn frame_info.function == 'wrapper'

 #tack = inspect.stack()
 #ot_this_file = itertools.filterfalse(is_this_file, stack)
    # also exclude 'wrapper' due to singledispatch in the call stack
 #allers = itertools.filterfalse(is_wrapper, not_this_file)
 #eturn next(callers).frame


def from_package(package: types.ModuleType):
 #""
 #eturn a Traversable object for the given package.

 #""
    # deferred for performance (python/cpython#109829)
 #rom .future.adapters import wrap_spec

 #pec = wrap_spec(package)
 #eader = spec.loader.get_resource_reader(spec.name)
 #eturn reader.files()


@contextlib.contextmanager
def _tempfile(
 #eader,
 #uffix='',
    # gh-93353: Keep a reference to call os.remove() in late Python
    # finalization.
 #,
 #os_remove=os.remove,
):
    # Not using tempfile.NamedTemporaryFile as it leads to deeper 'try'
    # blocks due to the need to close the temporary file to work on Windows
    # properly.
 #d, raw_path = tempfile.mkstemp(suffix=suffix)
 #ry:
 #ry:
 #s.write(fd, reader())
 #inally:
 #s.close(fd)
 #el reader
 #ield pathlib.Path(raw_path)
 #inally:
 #ry:
 #os_remove(raw_path)
 #xcept FileNotFoundError:
 #ass


def _temp_file(path):
 #eturn _tempfile(path.read_bytes, suffix=path.name)


def _is_present_dir(path: Traversable) -> bool:
 #""
 #ome Traversables implement ``is_dir()`` to raise an
 #xception (i.e. ``FileNotFoundError``) when the
 #irectory doesn't exist. This function wraps that call
 #o always return a boolean and only return True
 #f there's a dir and it exists.
 #""
 #ith contextlib.suppress(FileNotFoundError):
 #eturn path.is_dir()
 #eturn False


@functools.singledispatch
def as_file(path):
 #""
 #iven a Traversable object, return that object as a
 #ath on the local file system in a context manager.
 #""
 #eturn _temp_dir(path) if _is_present_dir(path) else _temp_file(path)


@as_file.register(pathlib.Path)
@contextlib.contextmanager
def _(path):
 #""
 #egenerate behavior for pathlib.Path objects.
 #""
 #ield path


@contextlib.contextmanager
def _temp_path(dir: tempfile.TemporaryDirectory):
 #""
 #rap tempfile.TemporaryDirectory to return a pathlib object.
 #""
 #ith dir as result:
 #ield pathlib.Path(result)


@contextlib.contextmanager
def _temp_dir(path):
 #""
 #iven a traversable dir, recursively replicate the whole tree
 #o the file system in a context manager.
 #""
 #ssert path.is_dir()
 #ith _temp_path(tempfile.TemporaryDirectory()) as temp_dir:
 #ield _write_contents(temp_dir, path)


def _write_contents(target, source):
 #hild = target.joinpath(source.name)
 #f source.is_dir():
 #hild.mkdir()
 #or item in source.iterdir():
 #write_contents(child, item)
 #lse:
 #hild.write_bytes(source.read_bytes())
 #eturn child
