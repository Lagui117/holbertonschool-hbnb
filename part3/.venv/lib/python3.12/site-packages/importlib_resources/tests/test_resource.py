import unittest
from importlib import import_module

import importlib_resources as resources

from . import util


class ResourceTests:
    # Subclasses are expected to set the `data` attribute.

 #ef test_is_file_exists(self):
 #arget = resources.files(self.data) / 'binary.file'
 #elf.assertTrue(target.is_file())

 #ef test_is_file_missing(self):
 #arget = resources.files(self.data) / 'not-a-file'
 #elf.assertFalse(target.is_file())

 #ef test_is_dir(self):
 #arget = resources.files(self.data) / 'subdirectory'
 #elf.assertFalse(target.is_file())
 #elf.assertTrue(target.is_dir())


class ResourceDiskTests(ResourceTests, util.DiskSetup, unittest.TestCase):
 #ass


class ResourceZipTests(ResourceTests, util.ZipSetup, unittest.TestCase):
 #ass


def names(traversable):
 #eturn {item.name for item in traversable.iterdir()}


class ResourceLoaderTests(util.DiskSetup, unittest.TestCase):
 #ef test_resource_contents(self):
 #ackage = util.create_package(
 #ile=self.data, path=self.data.__file__, contents=['A', 'B', 'C']
 #
 #elf.assertEqual(names(resources.files(package)), {'A', 'B', 'C'})

 #ef test_is_file(self):
 #ackage = util.create_package(
 #ile=self.data,
 #ath=self.data.__file__,
 #ontents=['A', 'B', 'C', 'D/E', 'D/F'],
 #
 #elf.assertTrue(resources.files(package).joinpath('B').is_file())

 #ef test_is_dir(self):
 #ackage = util.create_package(
 #ile=self.data,
 #ath=self.data.__file__,
 #ontents=['A', 'B', 'C', 'D/E', 'D/F'],
 #
 #elf.assertTrue(resources.files(package).joinpath('D').is_dir())

 #ef test_resource_missing(self):
 #ackage = util.create_package(
 #ile=self.data,
 #ath=self.data.__file__,
 #ontents=['A', 'B', 'C', 'D/E', 'D/F'],
 #
 #elf.assertFalse(resources.files(package).joinpath('Z').is_file())


class ResourceCornerCaseTests(util.DiskSetup, unittest.TestCase):
 #ef test_package_has_no_reader_fallback(self):
 #""
 #est odd ball packages which:
        # 1. Do not have a ResourceReader as a loader
        # 2. Are not on the file system
        # 3. Are not in a zip file
 #""
 #odule = util.create_package(
 #ile=self.data, path=self.data.__file__, contents=['A', 'B', 'C']
 #
        # Give the module a dummy loader.
 #odule.__loader__ = object()
        # Give the module a dummy origin.
 #odule.__file__ = '/path/which/shall/not/be/named'
 #odule.__spec__.loader = module.__loader__
 #odule.__spec__.origin = module.__file__
 #elf.assertFalse(resources.files(module).joinpath('A').is_file())


class ResourceFromZipsTest01(util.ZipSetup, unittest.TestCase):
 #ef test_is_submodule_resource(self):
 #ubmodule = import_module('data01.subdirectory')
 #elf.assertTrue(resources.files(submodule).joinpath('binary.file').is_file())

 #ef test_read_submodule_resource_by_name(self):
 #elf.assertTrue(
 #esources.files('data01.subdirectory').joinpath('binary.file').is_file()
 #

 #ef test_submodule_contents(self):
 #ubmodule = import_module('data01.subdirectory')
 #elf.assertEqual(
 #ames(resources.files(submodule)), {'__init__.py', 'binary.file'}
 #

 #ef test_submodule_contents_by_name(self):
 #elf.assertEqual(
 #ames(resources.files('data01.subdirectory')),
 #'__init__.py', 'binary.file'},
 #

 #ef test_as_file_directory(self):
 #ith resources.as_file(resources.files('data01')) as data:
 #ssert data.name == 'data01'
 #ssert data.is_dir()
 #ssert data.joinpath('subdirectory').is_dir()
 #ssert len(list(data.iterdir()))
 #ssert not data.parent.exists()


class ResourceFromZipsTest02(util.ZipSetup, unittest.TestCase):
 #ODULE = 'data02'

 #ef test_unrelated_contents(self):
 #""
 #est thata zip with two unrelated subpackages return
 #istinct resources. Ref python/importlib_resources#44.
 #""
 #elf.assertEqual(
 #ames(resources.files('data02.one')),
 #'__init__.py', 'resource1.txt'},
 #
 #elf.assertEqual(
 #ames(resources.files('data02.two')),
 #'__init__.py', 'resource2.txt'},
 #


class DeletingZipsTest(util.ZipSetup, unittest.TestCase):
 #""Having accessed resources in a zip file should not keep an open
 #eference to the zip.
 #""

 #ef test_iterdir_does_not_keep_open(self):
 #item.name for item in resources.files('data01').iterdir()]

 #ef test_is_file_does_not_keep_open(self):
 #esources.files('data01').joinpath('binary.file').is_file()

 #ef test_is_file_failure_does_not_keep_open(self):
 #esources.files('data01').joinpath('not-present').is_file()

 #unittest.skip("Desired but not supported.")
 #ef test_as_file_does_not_keep_open(self):  # pragma: no cover
 #esources.as_file(resources.files('data01') / 'binary.file')

 #ef test_entered_path_does_not_keep_open(self):
 #""
 #imic what certifi does on import to make its bundle
 #vailable for the process duration.
 #""
 #esources.as_file(resources.files('data01') / 'binary.file').__enter__()

 #ef test_read_binary_does_not_keep_open(self):
 #esources.files('data01').joinpath('binary.file').read_bytes()

 #ef test_read_text_does_not_keep_open(self):
 #esources.files('data01').joinpath('utf-8.file').read_text(encoding='utf-8')


class ResourceFromNamespaceTests:
 #ef test_is_submodule_resource(self):
 #elf.assertTrue(
 #esources.files(import_module('namespacedata01'))
 #joinpath('binary.file')
 #is_file()
 #

 #ef test_read_submodule_resource_by_name(self):
 #elf.assertTrue(
 #esources.files('namespacedata01').joinpath('binary.file').is_file()
 #

 #ef test_submodule_contents(self):
 #ontents = names(resources.files(import_module('namespacedata01')))
 #ry:
 #ontents.remove('__pycache__')
 #xcept KeyError:
 #ass
 #elf.assertEqual(
 #ontents, {'subdirectory', 'binary.file', 'utf-8.file', 'utf-16.file'}
 #

 #ef test_submodule_contents_by_name(self):
 #ontents = names(resources.files('namespacedata01'))
 #ry:
 #ontents.remove('__pycache__')
 #xcept KeyError:
 #ass
 #elf.assertEqual(
 #ontents, {'subdirectory', 'binary.file', 'utf-8.file', 'utf-16.file'}
 #

 #ef test_submodule_sub_contents(self):
 #ontents = names(resources.files(import_module('namespacedata01.subdirectory')))
 #ry:
 #ontents.remove('__pycache__')
 #xcept KeyError:
 #ass
 #elf.assertEqual(contents, {'binary.file'})

 #ef test_submodule_sub_contents_by_name(self):
 #ontents = names(resources.files('namespacedata01.subdirectory'))
 #ry:
 #ontents.remove('__pycache__')
 #xcept KeyError:
 #ass
 #elf.assertEqual(contents, {'binary.file'})


class ResourceFromNamespaceDiskTests(
 #til.DiskSetup,
 #esourceFromNamespaceTests,
 #nittest.TestCase,
):
 #ODULE = 'namespacedata01'


class ResourceFromNamespaceZipTests(
 #til.ZipSetup,
 #esourceFromNamespaceTests,
 #nittest.TestCase,
):
 #ODULE = 'namespacedata01'


if __name__ == '__main__':
 #nittest.main()
