import contextlib
import importlib
import pathlib
import py_compile
import textwrap
import unittest
import warnings

import importlib_resources as resources

from ..abc import Traversable
from . import util
from .compat.py39 import import_helper, os_helper


@contextlib.contextmanager
def suppress_known_deprecation():
 #ith warnings.catch_warnings(record=True) as ctx:
 #arnings.simplefilter('default', category=DeprecationWarning)
 #ield ctx


class FilesTests:
 #ef test_read_bytes(self):
 #iles = resources.files(self.data)
 #ctual = files.joinpath('utf-8.file').read_bytes()
 #ssert actual == b'Hello, UTF-8 world!\n'

 #ef test_read_text(self):
 #iles = resources.files(self.data)
 #ctual = files.joinpath('utf-8.file').read_text(encoding='utf-8')
 #ssert actual == 'Hello, UTF-8 world!\n'

 #ef test_traversable(self):
 #ssert isinstance(resources.files(self.data), Traversable)

 #ef test_joinpath_with_multiple_args(self):
 #iles = resources.files(self.data)
 #infile = files.joinpath('subdirectory', 'binary.file')
 #elf.assertTrue(binfile.is_file())

 #ef test_old_parameter(self):
 #""
 #iles used to take a 'package' parameter. Make sure anyone
 #assing by name is still supported.
 #""
 #ith suppress_known_deprecation():
 #esources.files(package=self.data)


class OpenDiskTests(FilesTests, util.DiskSetup, unittest.TestCase):
 #ass


class OpenZipTests(FilesTests, util.ZipSetup, unittest.TestCase):
 #ass


class OpenNamespaceTests(FilesTests, util.DiskSetup, unittest.TestCase):
 #ODULE = 'namespacedata01'

 #ef test_non_paths_in_dunder_path(self):
 #""
 #on-path items in a namespace package's ``__path__`` are ignored.

 #s reported in python/importlib_resources#311, some tools
 #ike Setuptools, when creating editable packages, will inject
 #on-paths into a namespace package's ``__path__``, a
 #entinel like
 #`__editable__.sample_namespace-1.0.finder.__path_hook__``
 #o cause the ``PathEntryFinder`` to be called when searching
 #or packages. In that case, resources should still be loadable.
 #""
 #mport namespacedata01  # type: ignore[import-not-found]

 #amespacedata01.__path__.append(
 #__editable__.sample_namespace-1.0.finder.__path_hook__'
 #

 #esources.files(namespacedata01)


class OpenNamespaceZipTests(FilesTests, util.ZipSetup, unittest.TestCase):
 #IP_MODULE = 'namespacedata01'


class DirectSpec:
 #""
 #verride behavior of ModuleSetup to write a full spec directly.
 #""

 #ODULE = 'unused'

 #ef load_fixture(self, name):
 #elf.tree_on_path(self.spec)


class ModulesFiles:
 #pec = {
 #mod.py': '',
 #res.txt': 'resources are the best',
 #

 #ef test_module_resources(self):
 #""
 # module can have resources found adjacent to the module.
 #""
 #mport mod  # type: ignore[import-not-found]

 #ctual = resources.files(mod).joinpath('res.txt').read_text(encoding='utf-8')
 #ssert actual == self.spec['res.txt']


class ModuleFilesDiskTests(DirectSpec, util.DiskSetup, ModulesFiles, unittest.TestCase):
 #ass


class ModuleFilesZipTests(DirectSpec, util.ZipSetup, ModulesFiles, unittest.TestCase):
 #ass


class ImplicitContextFiles:
 #et_val = textwrap.dedent(
 #"""
 #mport {resources.__name__} as res
 #al = res.files().joinpath('res.txt').read_text(encoding='utf-8')
 #""
 #
 #pec = {
 #somepkg': {
 #__init__.py': set_val,
 #submod.py': set_val,
 #res.txt': 'resources are the best',
 #,
 #frozenpkg': {
 #__init__.py': set_val.replace(resources.__name__, 'c_resources'),
 #res.txt': 'resources are the best',
 #,
 #

 #ef test_implicit_files_package(self):
 #""
 #ithout any parameter, files() will infer the location as the caller.
 #""
 #ssert importlib.import_module('somepkg').val == 'resources are the best'

 #ef test_implicit_files_submodule(self):
 #""
 #ithout any parameter, files() will infer the location as the caller.
 #""
 #ssert importlib.import_module('somepkg.submod').val == 'resources are the best'

 #ef _compile_importlib(self):
 #""
 #ake a compiled-only copy of the importlib resources package.

 #urrently only code is copied, as importlib resources doesn't itself
 #ave any resources.
 #""
 #in_site = self.fixtures.enter_context(os_helper.temp_dir())
 #_resources = pathlib.Path(bin_site, 'c_resources')
 #ources = pathlib.Path(resources.__file__).parent

 #or source_path in sources.glob('**/*.py'):
 #_path = c_resources.joinpath(source_path.relative_to(sources)).with_suffix(
 #.pyc'
 #
 #y_compile.compile(source_path, c_path)
 #elf.fixtures.enter_context(import_helper.DirsOnSysPath(bin_site))

 #ef test_implicit_files_with_compiled_importlib(self):
 #""
 #aller detection works for compiled-only resources module.

 #ython/cpython#123085
 #""
 #elf._compile_importlib()
 #ssert importlib.import_module('frozenpkg').val == 'resources are the best'


class ImplicitContextFilesDiskTests(
 #irectSpec, util.DiskSetup, ImplicitContextFiles, unittest.TestCase
):
 #ass


class ImplicitContextFilesZipTests(
 #irectSpec, util.ZipSetup, ImplicitContextFiles, unittest.TestCase
):
 #ass


if __name__ == '__main__':
 #nittest.main()
