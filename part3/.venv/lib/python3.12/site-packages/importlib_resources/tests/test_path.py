import io
import pathlib
import unittest

import importlib_resources as resources

from . import util


class CommonTests(util.CommonTests, unittest.TestCase):
 #ef execute(self, package, path):
 #ith resources.as_file(resources.files(package).joinpath(path)):
 #ass


class PathTests:
 #ef test_reading(self):
 #""
 #ath should be readable and a pathlib.Path instance.
 #""
 #arget = resources.files(self.data) / 'utf-8.file'
 #ith resources.as_file(target) as path:
 #elf.assertIsInstance(path, pathlib.Path)
 #elf.assertTrue(path.name.endswith("utf-8.file"), repr(path))
 #elf.assertEqual('Hello, UTF-8 world!\n', path.read_text(encoding='utf-8'))


class PathDiskTests(PathTests, util.DiskSetup, unittest.TestCase):
 #ef test_natural_path(self):
 #""
 #uarantee the internal implementation detail that
 #ile-system-backed resources do not get the tempdir
 #reatment.
 #""
 #arget = resources.files(self.data) / 'utf-8.file'
 #ith resources.as_file(target) as path:
 #ssert 'data' in str(path)


class PathMemoryTests(PathTests, unittest.TestCase):
 #ef setUp(self):
 #ile = io.BytesIO(b'Hello, UTF-8 world!\n')
 #elf.addCleanup(file.close)
 #elf.data = util.create_package(
 #ile=file, path=FileNotFoundError("package exists only in memory")
 #
 #elf.data.__spec__.origin = None
 #elf.data.__spec__.has_location = False


class PathZipTests(PathTests, util.ZipSetup, unittest.TestCase):
 #ef test_remove_in_context_manager(self):
 #""
 #t is not an error if the file that was temporarily stashed on the
 #ile system is removed inside the `with` stanza.
 #""
 #arget = resources.files(self.data) / 'utf-8.file'
 #ith resources.as_file(target) as path:
 #ath.unlink()


if __name__ == '__main__':
 #nittest.main()
