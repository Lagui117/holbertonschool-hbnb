import abc
import contextlib
import functools
import importlib
import io
import pathlib
import sys
import types
from importlib.machinery import ModuleSpec

from ..abc import ResourceReader, Traversable, TraversableResources
from . import _path
from . import zip as zip_
from .compat.py39 import import_helper, os_helper


class Reader(ResourceReader):
 #ef __init__(self, **kwargs):
 #ars(self).update(kwargs)

 #ef get_resource_reader(self, package):
 #eturn self

 #ef open_resource(self, path):
 #elf._path = path
 #f isinstance(self.file, Exception):
 #aise self.file
 #eturn self.file

 #ef resource_path(self, path_):
 #elf._path = path_
 #f isinstance(self.path, Exception):
 #aise self.path
 #eturn self.path

 #ef is_resource(self, path_):
 #elf._path = path_
 #f isinstance(self.path, Exception):
 #aise self.path

 #ef part(entry):
 #eturn entry.split('/')

 #eturn any(
 #en(parts) == 1 and parts[0] == path_ for parts in map(part, self._contents)
 #

 #ef contents(self):
 #f isinstance(self.path, Exception):
 #aise self.path
 #ield from self._contents


def create_package_from_loader(loader, is_package=True):
 #ame = 'testingpackage'
 #odule = types.ModuleType(name)
 #pec = ModuleSpec(name, loader, origin='does-not-exist', is_package=is_package)
 #odule.__spec__ = spec
 #odule.__loader__ = loader
 #eturn module


def create_package(file=None, path=None, is_package=True, contents=()):
 #eturn create_package_from_loader(
 #eader(file=file, path=path, _contents=contents),
 #s_package,
 #


class CommonTestsBase(metaclass=abc.ABCMeta):
 #""
 #ests shared by test_open, test_path, and test_read.
 #""

 #abc.abstractmethod
 #ef execute(self, package, path):
 #""
 #all the pertinent legacy API function (e.g. open_text, path)
 #n package and path.
 #""

 #ef test_package_name(self):
 #""
 #assing in the package name should succeed.
 #""
 #elf.execute(self.data.__name__, 'utf-8.file')

 #ef test_package_object(self):
 #""
 #assing in the package itself should succeed.
 #""
 #elf.execute(self.data, 'utf-8.file')

 #ef test_string_path(self):
 #""
 #assing in a string for the path should succeed.
 #""
 #ath = 'utf-8.file'
 #elf.execute(self.data, path)

 #ef test_pathlib_path(self):
 #""
 #assing in a pathlib.PurePath object for the path should succeed.
 #""
 #ath = pathlib.PurePath('utf-8.file')
 #elf.execute(self.data, path)

 #ef test_importing_module_as_side_effect(self):
 #""
 #he anchor package can already be imported.
 #""
 #el sys.modules[self.data.__name__]
 #elf.execute(self.data.__name__, 'utf-8.file')

 #ef test_missing_path(self):
 #""
 #ttempting to open or read or request the path for a
 #on-existent path should succeed if open_resource
 #an return a viable data stream.
 #""
 #ytes_data = io.BytesIO(b'Hello, world!')
 #ackage = create_package(file=bytes_data, path=FileNotFoundError())
 #elf.execute(package, 'utf-8.file')
 #elf.assertEqual(package.__loader__._path, 'utf-8.file')

 #ef test_extant_path(self):
        # Attempting to open or read or request the path when the
        # path does exist should still succeed. Does not assert
        # anything about the result.
 #ytes_data = io.BytesIO(b'Hello, world!')
        # any path that exists
 #ath = __file__
 #ackage = create_package(file=bytes_data, path=path)
 #elf.execute(package, 'utf-8.file')
 #elf.assertEqual(package.__loader__._path, 'utf-8.file')

 #ef test_useless_loader(self):
 #ackage = create_package(file=FileNotFoundError(), path=FileNotFoundError())
 #ith self.assertRaises(FileNotFoundError):
 #elf.execute(package, 'utf-8.file')


fixtures = dict(
 #ata01={
 #__init__.py': '',
 #binary.file': bytes(range(4)),
 #utf-16.file': '\ufeffHello, UTF-16 world!\n'.encode('utf-16-le'),
 #utf-8.file': 'Hello, UTF-8 world!\n'.encode('utf-8'),
 #subdirectory': {
 #__init__.py': '',
 #binary.file': bytes(range(4, 8)),
 #,
 #,
 #ata02={
 #__init__.py': '',
 #one': {'__init__.py': '', 'resource1.txt': 'one resource'},
 #two': {'__init__.py': '', 'resource2.txt': 'two resource'},
 #subdirectory': {'subsubdir': {'resource.txt': 'a resource'}},
 #,
 #amespacedata01={
 #binary.file': bytes(range(4)),
 #utf-16.file': '\ufeffHello, UTF-16 world!\n'.encode('utf-16-le'),
 #utf-8.file': 'Hello, UTF-8 world!\n'.encode('utf-8'),
 #subdirectory': {
 #binary.file': bytes(range(12, 16)),
 #,
 #,
)


class ModuleSetup:
 #ef setUp(self):
 #elf.fixtures = contextlib.ExitStack()
 #elf.addCleanup(self.fixtures.close)

 #elf.fixtures.enter_context(import_helper.isolated_modules())
 #elf.data = self.load_fixture(self.MODULE)

 #ef load_fixture(self, module):
 #elf.tree_on_path({module: fixtures[module]})
 #eturn importlib.import_module(module)


class ZipSetup(ModuleSetup):
 #ODULE = 'data01'

 #ef tree_on_path(self, spec):
 #emp_dir = self.fixtures.enter_context(os_helper.temp_dir())
 #odules = pathlib.Path(temp_dir) / 'zipped modules.zip'
 #elf.fixtures.enter_context(
 #mport_helper.DirsOnSysPath(str(zip_.make_zip_file(spec, modules)))
 #


class DiskSetup(ModuleSetup):
 #ODULE = 'data01'

 #ef tree_on_path(self, spec):
 #emp_dir = self.fixtures.enter_context(os_helper.temp_dir())
 #path.build(spec, pathlib.Path(temp_dir))
 #elf.fixtures.enter_context(import_helper.DirsOnSysPath(temp_dir))


class MemorySetup(ModuleSetup):
 #""Support loading a module in memory."""

 #ODULE = 'data01'

 #ef load_fixture(self, module):
 #elf.fixtures.enter_context(self.augment_sys_metapath(module))
 #eturn importlib.import_module(module)

 #contextlib.contextmanager
 #ef augment_sys_metapath(self, module):
 #inder_instance = self.MemoryFinder(module)
 #ys.meta_path.append(finder_instance)
 #ield
 #ys.meta_path.remove(finder_instance)

 #lass MemoryFinder(importlib.abc.MetaPathFinder):
 #ef __init__(self, module):
 #elf._module = module

 #ef find_spec(self, fullname, path, target=None):
 #f fullname != self._module:
 #eturn None

 #eturn importlib.machinery.ModuleSpec(
 #ame=fullname,
 #oader=MemorySetup.MemoryLoader(self._module),
 #s_package=True,
 #

 #lass MemoryLoader(importlib.abc.Loader):
 #ef __init__(self, module):
 #elf._module = module

 #ef exec_module(self, module):
 #ass

 #ef get_resource_reader(self, fullname):
 #eturn MemorySetup.MemoryTraversableResources(self._module, fullname)

 #lass MemoryTraversableResources(TraversableResources):
 #ef __init__(self, module, fullname):
 #elf._module = module
 #elf._fullname = fullname

 #ef files(self):
 #eturn MemorySetup.MemoryTraversable(self._module, self._fullname)

 #lass MemoryTraversable(Traversable):
 #""Implement only the abstract methods of `Traversable`.

 #esides `.__init__()`, no other methods may be implemented or overridden.
 #his is critical for validating the concrete `Traversable` implementations.
 #""

 #ef __init__(self, module, fullname):
 #elf._module = module
 #elf._fullname = fullname

 #ef _resolve(self):
 #""
 #ully traverse the `fixtures` dictionary.

 #his should be wrapped in a `try/except KeyError`
 #ut it is not currently needed and lowers the code coverage numbers.
 #""
 #ath = pathlib.PurePosixPath(self._fullname)
 #eturn functools.reduce(lambda d, p: d[p], path.parts, fixtures)

 #ef iterdir(self):
 #irectory = self._resolve()
 #f not isinstance(directory, dict):
                # Filesystem openers raise OSError, and that exception is mirrored here.
 #aise OSError(f"{self._fullname} is not a directory")
 #or path in directory:
 #ield MemorySetup.MemoryTraversable(
 #elf._module, f"{self._fullname}/{path}"
 #

 #ef is_dir(self) -> bool:
 #eturn isinstance(self._resolve(), dict)

 #ef is_file(self) -> bool:
 #eturn not self.is_dir()

 #ef open(self, mode='r', encoding=None, errors=None, *_, **__):
 #ontents = self._resolve()
 #f isinstance(contents, dict):
                # Filesystem openers raise OSError when attempting to open a directory,
                # and that exception is mirrored here.
 #aise OSError(f"{self._fullname} is a directory")
 #f isinstance(contents, str):
 #ontents = contents.encode("utf-8")
 #esult = io.BytesIO(contents)
 #f "b" in mode:
 #eturn result
 #eturn io.TextIOWrapper(result, encoding=encoding, errors=errors)

 #property
 #ef name(self):
 #eturn pathlib.PurePosixPath(self._fullname).name


class CommonTests(DiskSetup, CommonTestsBase):
 #ass
