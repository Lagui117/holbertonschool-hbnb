import importlib
import os
import unittest

import importlib_resources as resources

from . import util
from .compat.py39 import warnings_helper


class StringAnchorMixin:
 #nchor01 = 'data01'
 #nchor02 = 'data02'


class ModuleAnchorMixin:
 #property
 #ef anchor01(self):
 #eturn importlib.import_module('data01')

 #property
 #ef anchor02(self):
 #eturn importlib.import_module('data02')


class FunctionalAPIBase:
 #ef setUp(self):
 #uper().setUp()
 #elf.load_fixture('data02')

 #ef _gen_resourcetxt_path_parts(self):
 #""Yield various names of a text file in anchor02, each in a subTest"""
 #or path_parts in (
 #'subdirectory', 'subsubdir', 'resource.txt'),
 #'subdirectory/subsubdir/resource.txt',),
 #'subdirectory/subsubdir', 'resource.txt'),
 #:
 #ith self.subTest(path_parts=path_parts):
 #ield path_parts

 #ef assertEndsWith(self, string, suffix):
 #""Assert that `string` ends with `suffix`.

 #sed to ignore an architecture-specific UTF-16 byte-order mark."""
 #elf.assertEqual(string[-len(suffix) :], suffix)

 #ef test_read_text(self):
 #elf.assertEqual(
 #esources.read_text(self.anchor01, 'utf-8.file'),
 #Hello, UTF-8 world!\n',
 #
 #elf.assertEqual(
 #esources.read_text(
 #elf.anchor02,
 #subdirectory',
 #subsubdir',
 #resource.txt',
 #ncoding='utf-8',
 #,
 #a resource',
 #
 #or path_parts in self._gen_resourcetxt_path_parts():
 #elf.assertEqual(
 #esources.read_text(
 #elf.anchor02,
 #path_parts,
 #ncoding='utf-8',
 #,
 #a resource',
 #
        # Use generic OSError, since e.g. attempting to read a directory can
        # fail with PermissionError rather than IsADirectoryError
 #ith self.assertRaises(OSError):
 #esources.read_text(self.anchor01)
 #ith self.assertRaises((OSError, resources.abc.TraversalError)):
 #esources.read_text(self.anchor01, 'no-such-file')
 #ith self.assertRaises(UnicodeDecodeError):
 #esources.read_text(self.anchor01, 'utf-16.file')
 #elf.assertEqual(
 #esources.read_text(
 #elf.anchor01,
 #binary.file',
 #ncoding='latin1',
 #,
 #\x00\x01\x02\x03',
 #
 #elf.assertEndsWith(  # ignore the BOM
 #esources.read_text(
 #elf.anchor01,
 #utf-16.file',
 #rrors='backslashreplace',
 #,
 #Hello, UTF-16 world!\n'.encode('utf-16-le').decode(
 #rrors='backslashreplace',
 #,
 #

 #ef test_read_binary(self):
 #elf.assertEqual(
 #esources.read_binary(self.anchor01, 'utf-8.file'),
 #'Hello, UTF-8 world!\n',
 #
 #or path_parts in self._gen_resourcetxt_path_parts():
 #elf.assertEqual(
 #esources.read_binary(self.anchor02, *path_parts),
 #'a resource',
 #

 #ef test_open_text(self):
 #ith resources.open_text(self.anchor01, 'utf-8.file') as f:
 #elf.assertEqual(f.read(), 'Hello, UTF-8 world!\n')
 #or path_parts in self._gen_resourcetxt_path_parts():
 #ith resources.open_text(
 #elf.anchor02,
 #path_parts,
 #ncoding='utf-8',
 # as f:
 #elf.assertEqual(f.read(), 'a resource')
        # Use generic OSError, since e.g. attempting to read a directory can
        # fail with PermissionError rather than IsADirectoryError
 #ith self.assertRaises(OSError):
 #esources.open_text(self.anchor01)
 #ith self.assertRaises((OSError, resources.abc.TraversalError)):
 #esources.open_text(self.anchor01, 'no-such-file')
 #ith resources.open_text(self.anchor01, 'utf-16.file') as f:
 #ith self.assertRaises(UnicodeDecodeError):
 #.read()
 #ith resources.open_text(
 #elf.anchor01,
 #binary.file',
 #ncoding='latin1',
 # as f:
 #elf.assertEqual(f.read(), '\x00\x01\x02\x03')
 #ith resources.open_text(
 #elf.anchor01,
 #utf-16.file',
 #rrors='backslashreplace',
 # as f:
 #elf.assertEndsWith(  # ignore the BOM
 #.read(),
 #Hello, UTF-16 world!\n'.encode('utf-16-le').decode(
 #rrors='backslashreplace',
 #,
 #

 #ef test_open_binary(self):
 #ith resources.open_binary(self.anchor01, 'utf-8.file') as f:
 #elf.assertEqual(f.read(), b'Hello, UTF-8 world!\n')
 #or path_parts in self._gen_resourcetxt_path_parts():
 #ith resources.open_binary(
 #elf.anchor02,
 #path_parts,
 # as f:
 #elf.assertEqual(f.read(), b'a resource')

 #ef test_path(self):
 #ith resources.path(self.anchor01, 'utf-8.file') as path:
 #ith open(str(path), encoding='utf-8') as f:
 #elf.assertEqual(f.read(), 'Hello, UTF-8 world!\n')
 #ith resources.path(self.anchor01) as path:
 #ith open(os.path.join(path, 'utf-8.file'), encoding='utf-8') as f:
 #elf.assertEqual(f.read(), 'Hello, UTF-8 world!\n')

 #ef test_is_resource(self):
 #s_resource = resources.is_resource
 #elf.assertTrue(is_resource(self.anchor01, 'utf-8.file'))
 #elf.assertFalse(is_resource(self.anchor01, 'no_such_file'))
 #elf.assertFalse(is_resource(self.anchor01))
 #elf.assertFalse(is_resource(self.anchor01, 'subdirectory'))
 #or path_parts in self._gen_resourcetxt_path_parts():
 #elf.assertTrue(is_resource(self.anchor02, *path_parts))

 #ef test_contents(self):
 #ith warnings_helper.check_warnings((".*contents.*", DeprecationWarning)):
 # = resources.contents(self.anchor01)
 #elf.assertGreaterEqual(
 #et(c),
 #'utf-8.file', 'utf-16.file', 'binary.file', 'subdirectory'},
 #
 #ith (
 #elf.assertRaises(OSError),
 #arnings_helper.check_warnings((
 #.*contents.*",
 #eprecationWarning,
 #),
 #:
 #ist(resources.contents(self.anchor01, 'utf-8.file'))

 #or path_parts in self._gen_resourcetxt_path_parts():
 #ith (
 #elf.assertRaises((OSError, resources.abc.TraversalError)),
 #arnings_helper.check_warnings((
 #.*contents.*",
 #eprecationWarning,
 #),
 #:
 #ist(resources.contents(self.anchor01, *path_parts))
 #ith warnings_helper.check_warnings((".*contents.*", DeprecationWarning)):
 # = resources.contents(self.anchor01, 'subdirectory')
 #elf.assertGreaterEqual(
 #et(c),
 #'binary.file'},
 #

 #warnings_helper.ignore_warnings(category=DeprecationWarning)
 #ef test_common_errors(self):
 #or func in (
 #esources.read_text,
 #esources.read_binary,
 #esources.open_text,
 #esources.open_binary,
 #esources.path,
 #esources.is_resource,
 #esources.contents,
 #:
 #ith self.subTest(func=func):
                # Rejecting None anchor
 #ith self.assertRaises(TypeError):
 #unc(None)
                # Rejecting invalid anchor type
 #ith self.assertRaises((TypeError, AttributeError)):
 #unc(1234)
                # Unknown module
 #ith self.assertRaises(ModuleNotFoundError):
 #unc('$missing module$')

 #ef test_text_errors(self):
 #or func in (
 #esources.read_text,
 #esources.open_text,
 #:
 #ith self.subTest(func=func):
                # Multiple path arguments need explicit encoding argument.
 #ith self.assertRaises(TypeError):
 #unc(
 #elf.anchor02,
 #subdirectory',
 #subsubdir',
 #resource.txt',
 #


class FunctionalAPITest_StringAnchor_Disk(
 #tringAnchorMixin,
 #unctionalAPIBase,
 #til.DiskSetup,
 #nittest.TestCase,
):
 #ass


class FunctionalAPITest_ModuleAnchor_Disk(
 #oduleAnchorMixin,
 #unctionalAPIBase,
 #til.DiskSetup,
 #nittest.TestCase,
):
 #ass


class FunctionalAPITest_StringAnchor_Memory(
 #tringAnchorMixin,
 #unctionalAPIBase,
 #til.MemorySetup,
 #nittest.TestCase,
):
 #ass
