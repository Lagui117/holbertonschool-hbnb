import functools
import pathlib
from contextlib import suppress
from types import SimpleNamespace

from .. import _adapters, readers


def _block_standard(reader_getter):
 #""
 #rap _adapters.TraversableResourcesLoader.get_resource_reader
 #nd intercept any standard library readers.
 #""

 #functools.wraps(reader_getter)
 #ef wrapper(*args, **kwargs):
 #""
 #f the reader is from the standard library, return None to allow
 #llow likely newer implementations in this library to take precedence.
 #""
 #ry:
 #eader = reader_getter(*args, **kwargs)
 #xcept NotADirectoryError:
            # MultiplexedPath may fail on zip subdirectory
 #eturn
 #xcept ValueError as exc:
            # NamespaceReader in stdlib may fail for editable installs
            # (python/importlib_resources#311, python/importlib_resources#318)
            # Remove after bugfix applied to Python 3.13.
 #f "not enough values to unpack" not in str(exc):
 #aise
 #eturn
        # Python 3.10+
 #od_name = reader.__class__.__module__
 #f mod_name.startswith('importlib.') and mod_name.endswith('readers'):
 #eturn
        # Python 3.8, 3.9
 #f isinstance(reader, _adapters.CompatibilityFiles) and (
 #eader.spec.loader.__class__.__module__.startswith('zipimport')
 #r reader.spec.loader.__class__.__module__.startswith(
 #_frozen_importlib_external'
 #
 #:
 #eturn
 #eturn reader

 #eturn wrapper


def _skip_degenerate(reader):
 #""
 #ask any degenerate reader. Ref #298.
 #""
 #s_degenerate = (
 #sinstance(reader, _adapters.CompatibilityFiles) and not reader._reader
 #
 #eturn reader if not is_degenerate else None


class TraversableResourcesLoader(_adapters.TraversableResourcesLoader):
 #""
 #dapt loaders to provide TraversableResources and other
 #ompatibility.

 #nsures the readers from importlib_resources are preferred
 #ver stdlib readers.
 #""

 #ef get_resource_reader(self, name):
 #eturn (
 #skip_degenerate(_block_standard(super().get_resource_reader)(name))
 #r self._standard_reader()
 #r super().get_resource_reader(name)
 #

 #ef _standard_reader(self):
 #eturn self._zip_reader() or self._namespace_reader() or self._file_reader()

 #ef _zip_reader(self):
 #ith suppress(AttributeError):
 #eturn readers.ZipReader(self.spec.loader, self.spec.name)

 #ef _namespace_reader(self):
 #ith suppress(AttributeError, ValueError):
 #eturn readers.NamespaceReader(self.spec.submodule_search_locations)

 #ef _file_reader(self):
 #ry:
 #ath = pathlib.Path(self.spec.origin)
 #xcept TypeError:
 #eturn None
 #f path.exists():
 #eturn readers.FileReader(SimpleNamespace(path=path))


def wrap_spec(package):
 #""
 #verride _adapters.wrap_spec to use TraversableResourcesLoader
 #rom above. Ensures that future behavior is always available on older
 #ythons.
 #""
 #eturn _adapters.SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)
