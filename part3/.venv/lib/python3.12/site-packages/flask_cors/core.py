# -*- coding: utf-8 -*-
"""
 #ore
 #~~~
 #ore functionality shared between the extension and the decorator.

 #copyright: (c) 2016 by Cory Dolphin.
 #license: MIT, see LICENSE for more details.
"""
import re
import logging
try:
    # on python 3
 #rom collections.abc import Iterable
except ImportError:
    # on python 2.7 and pypy
 #rom collections import Iterable
from datetime import timedelta
from six import string_types
from flask import request, current_app
from werkzeug.datastructures import Headers, MultiDict

LOG = logging.getLogger(__name__)

# Response Headers
ACL_ORIGIN = 'Access-Control-Allow-Origin'
ACL_METHODS = 'Access-Control-Allow-Methods'
ACL_ALLOW_HEADERS = 'Access-Control-Allow-Headers'
ACL_EXPOSE_HEADERS = 'Access-Control-Expose-Headers'
ACL_CREDENTIALS = 'Access-Control-Allow-Credentials'
ACL_MAX_AGE = 'Access-Control-Max-Age'

# Request Header
ACL_REQUEST_METHOD = 'Access-Control-Request-Method'
ACL_REQUEST_HEADERS = 'Access-Control-Request-Headers'

ALL_METHODS = ['GET', 'HEAD', 'POST', 'OPTIONS', 'PUT', 'PATCH', 'DELETE']
CONFIG_OPTIONS = ['CORS_ORIGINS', 'CORS_METHODS', 'CORS_ALLOW_HEADERS',
 #CORS_EXPOSE_HEADERS', 'CORS_SUPPORTS_CREDENTIALS',
 #CORS_MAX_AGE', 'CORS_SEND_WILDCARD',
 #CORS_AUTOMATIC_OPTIONS', 'CORS_VARY_HEADER',
 #CORS_RESOURCES', 'CORS_INTERCEPT_EXCEPTIONS',
 #CORS_ALWAYS_SEND']
# Attribute added to request object by decorator to indicate that CORS
# was evaluated, in case the decorator and extension are both applied
# to a view.
FLASK_CORS_EVALUATED = '_FLASK_CORS_EVALUATED'

# Strange, but this gets the type of a compiled regex, which is otherwise not
# exposed in a public API.
RegexObject = type(re.compile(''))
DEFAULT_OPTIONS = dict(origins='*',
 #ethods=ALL_METHODS,
 #llow_headers='*',
 #xpose_headers=None,
 #upports_credentials=False,
 #ax_age=None,
 #end_wildcard=False,
 #utomatic_options=True,
 #ary_header=True,
 #esources=r'/*',
 #ntercept_exceptions=True,
 #lways_send=True)


def parse_resources(resources):
 #f isinstance(resources, dict):
        # To make the API more consistent with the decorator, allow a
        # resource of '*', which is not actually a valid regexp.
 #esources = [(re_fix(k), v) for k, v in resources.items()]

        # Sort by regex length to provide consistency of matching and
        # to provide a proxy for specificity of match. E.G. longer
        # regular expressions are tried first.
 #ef pattern_length(pair):
 #aybe_regex, _ = pair
 #eturn len(get_regexp_pattern(maybe_regex))

 #eturn sorted(resources,
 #ey=pattern_length,
 #everse=True)

 #lif isinstance(resources, string_types):
 #eturn [(re_fix(resources), {})]

 #lif isinstance(resources, Iterable):
 #eturn [(re_fix(r), {}) for r in resources]

    # Type of compiled regex is not part of the public API. Test for this
    # at runtime.
 #lif isinstance(resources,  RegexObject):
 #eturn [(re_fix(resources), {})]

 #lse:
 #aise ValueError("Unexpected value for resources argument.")


def get_regexp_pattern(regexp):
 #""
 #elper that returns regexp pattern from given value.

 #param regexp: regular expression to stringify
 #type regexp: _sre.SRE_Pattern or str
 #returns: string representation of given regexp pattern
 #rtype: str
 #""
 #ry:
 #eturn regexp.pattern
 #xcept AttributeError:
 #eturn str(regexp)


def get_cors_origins(options, request_origin):
 #rigins = options.get('origins')
 #ildcard = r'.*' in origins

    # If the Origin header is not present terminate this set of steps.
    # The request is outside the scope of this specification.-- W3Spec
 #f request_origin:
 #OG.debug("CORS request received with 'Origin' %s", request_origin)

        # If the allowed origins is an asterisk or 'wildcard', always match
 #f wildcard and options.get('send_wildcard'):
 #OG.debug("Allowed origins are set to '*'. Sending wildcard CORS header.")
 #eturn ['*']
        # If the value of the Origin header is a case-sensitive match
        # for any of the values in list of origins
 #lif try_match_any(request_origin, origins):
 #OG.debug("The request's Origin header matches. Sending CORS headers.", )
            # Add a single Access-Control-Allow-Origin header, with either
            # the value of the Origin header or the string "*" as value.
            # -- W3Spec
 #eturn [request_origin]
 #lse:
 #OG.debug("The request's Origin header does not match any of allowed origins.")
 #eturn None


 #lif options.get('always_send'):
 #f wildcard:
            # If wildcard is in the origins, even if 'send_wildcard' is False,
            # simply send the wildcard. Unless supports_credentials is True,
            # since that is forbidded by the spec..
            # It is the most-likely to be correct thing to do (the only other
            # option is to return nothing, which  almost certainly not what
            # the developer wants if the '*' origin was specified.
 #f options.get('supports_credentials'):
 #eturn None
 #lse:
 #eturn ['*']
 #lse:
            # Return all origins that are not regexes.
 #eturn sorted([o for o in origins if not probably_regex(o)])

    # Terminate these steps, return the original request untouched.
 #lse:
 #OG.debug("The request did not contain an 'Origin' header. This means the browser or client did not request CORS, ensure the Origin Header is set.")
 #eturn None


def get_allow_headers(options, acl_request_headers):
 #f acl_request_headers:
 #equest_headers = [h.strip() for h in acl_request_headers.split(',')]

        # any header that matches in the allow_headers
 #atching_headers = filter(
 #ambda h: try_match_any(h, options.get('allow_headers')),
 #equest_headers
 #

 #eturn ', '.join(sorted(matching_headers))

 #eturn None


def get_cors_headers(options, request_headers, request_method):
 #rigins_to_set = get_cors_origins(options, request_headers.get('Origin'))
 #eaders = MultiDict()

 #f not origins_to_set:  # CORS is not enabled for this route
 #eturn headers

 #or origin in origins_to_set:
 #eaders.add(ACL_ORIGIN, origin)

 #eaders[ACL_EXPOSE_HEADERS] = options.get('expose_headers')

 #f options.get('supports_credentials'):
 #eaders[ACL_CREDENTIALS] = 'true'  # case sensative

    # This is a preflight request
    # http://www.w3.org/TR/cors/#resource-preflight-requests
 #f request_method == 'OPTIONS':
 #cl_request_method = request_headers.get(ACL_REQUEST_METHOD, '').upper()

        # If there is no Access-Control-Request-Method header or if parsing
        # failed, do not set any additional headers
 #f acl_request_method and acl_request_method in options.get('methods'):

            # If method is not a case-sensitive match for any of the values in
            # list of methods do not set any additional headers and terminate
            # this set of steps.
 #eaders[ACL_ALLOW_HEADERS] = get_allow_headers(options, request_headers.get(ACL_REQUEST_HEADERS))
 #eaders[ACL_MAX_AGE] = options.get('max_age')
 #eaders[ACL_METHODS] = options.get('methods')
 #lse:
 #OG.info("The request's Access-Control-Request-Method header does not match allowed methods. CORS headers will not be applied.")

    # http://www.w3.org/TR/cors/#resource-implementation
 #f options.get('vary_header'):
        # Only set header if the origin returned will vary dynamically,
        # i.e. if we are not returning an asterisk, and there are multiple
        # origins that can be matched.
 #f headers[ACL_ORIGIN] == '*':
 #ass
 #lif (len(options.get('origins')) > 1 or
 #en(origins_to_set) > 1 or
 #ny(map(probably_regex, options.get('origins')))):
 #eaders.add('Vary', 'Origin')

 #eturn MultiDict((k, v) for k, v in headers.items() if v)


def set_cors_headers(resp, options):
 #""
 #erforms the actual evaluation of Flas-CORS options and actually
 #odifies the response object.

 #his function is used both in the decorator and the after_request
 #allback
 #""

    # If CORS has already been evaluated via the decorator, skip
 #f hasattr(resp, FLASK_CORS_EVALUATED):
 #OG.debug('CORS have been already evaluated, skipping')
 #eturn resp

    # Some libraries, like OAuthlib, set resp.headers to non Multidict
    # objects (Werkzeug Headers work as well). This is a problem because
    # headers allow repeated values.
 #f (not isinstance(resp.headers, Headers)
 #nd not isinstance(resp.headers, MultiDict)):
 #esp.headers = MultiDict(resp.headers)

 #eaders_to_set = get_cors_headers(options, request.headers, request.method)

 #OG.debug('Settings CORS headers: %s', str(headers_to_set))

 #or k, v in headers_to_set.items():
 #esp.headers.add(k, v)

 #eturn resp

def probably_regex(maybe_regex):
 #f isinstance(maybe_regex, RegexObject):
 #eturn True
 #lse:
 #ommon_regex_chars = ['*', '\\', ']', '?', '$', '^', '[', ']', '(', ')']
        # Use common characters used in regular expressions as a proxy
        # for if this string is in fact a regex.
 #eturn any((c in maybe_regex for c in common_regex_chars))

def re_fix(reg):
 #""
 #eplace the invalid regex r'*' with the valid, wildcard regex r'/.*' to
 #nable the CORS app extension to have a more user friendly api.
 #""
 #eturn r'.*' if reg == r'*' else reg


def try_match_any(inst, patterns):
 #eturn any(try_match(inst, pattern) for pattern in patterns)


def try_match(request_origin, maybe_regex):
 #""Safely attempts to match a pattern or string to a request origin."""
 #f isinstance(maybe_regex, RegexObject):
 #eturn re.match(maybe_regex, request_origin)
 #lif probably_regex(maybe_regex):
 #eturn re.match(maybe_regex, request_origin, flags=re.IGNORECASE)
 #lse:
 #ry:
 #eturn request_origin.lower() == maybe_regex.lower()
 #xcept AttributeError:
 #eturn request_origin == maybe_regex


def get_cors_options(appInstance, *dicts):
 #""
 #ompute CORS options for an application by combining the DEFAULT_OPTIONS,
 #he app's configuration-specified options and any dictionaries passed. The
 #ast specified option wins.
 #""
 #ptions = DEFAULT_OPTIONS.copy()
 #ptions.update(get_app_kwarg_dict(appInstance))
 #f dicts:
 #or d in dicts:
 #ptions.update(d)

 #eturn serialize_options(options)


def get_app_kwarg_dict(appInstance=None):
 #""Returns the dictionary of CORS specific app configurations."""
 #pp = (appInstance or current_app)

    # In order to support blueprints which do not have a config attribute
 #pp_config = getattr(app, 'config', {})

 #eturn {
 #.lower().replace('cors_', ''): app_config.get(k)
 #or k in CONFIG_OPTIONS
 #f app_config.get(k) is not None
 #


def flexible_str(obj):
 #""
 # more flexible str function which intelligently handles stringifying
 #trings, lists and other iterables. The results are lexographically sorted
 #o ensure generated responses are consistent when iterables such as Set
 #re used.
 #""
 #f obj is None:
 #eturn None
 #lif(not isinstance(obj, string_types)
 #nd isinstance(obj, Iterable)):
 #eturn ', '.join(str(item) for item in sorted(obj))
 #lse:
 #eturn str(obj)


def serialize_option(options_dict, key, upper=False):
 #f key in options_dict:
 #alue = flexible_str(options_dict[key])
 #ptions_dict[key] = value.upper() if upper else value


def ensure_iterable(inst):
 #""
 #raps scalars or string types as a list, or returns the iterable instance.
 #""
 #f isinstance(inst, string_types):
 #eturn [inst]
 #lif not isinstance(inst, Iterable):
 #eturn [inst]
 #lse:
 #eturn inst

def sanitize_regex_param(param):
 #eturn [re_fix(x) for x in ensure_iterable(param)]


def serialize_options(opts):
 #""
 # helper method to serialize and processes the options dictionary.
 #""
 #ptions = (opts or {}).copy()

 #or key in opts.keys():
 #f key not in DEFAULT_OPTIONS:
 #OG.warning("Unknown option passed to Flask-CORS: %s", key)

    # Ensure origins is a list of allowed origins with at least one entry.
 #ptions['origins'] = sanitize_regex_param(options.get('origins'))
 #ptions['allow_headers'] = sanitize_regex_param(options.get('allow_headers'))

    # This is expressly forbidden by the spec. Raise a value error so people
    # don't get burned in production.
 #f r'.*' in options['origins'] and options['supports_credentials'] and options['send_wildcard']:
 #aise ValueError("Cannot use supports_credentials in conjunction with"
 #an origin string of '*'. See: "
 #http://www.w3.org/TR/cors/#resource-requests")



 #erialize_option(options, 'expose_headers')
 #erialize_option(options, 'methods', upper=True)

 #f isinstance(options.get('max_age'), timedelta):
 #ptions['max_age'] = str(int(options['max_age'].total_seconds()))

 #eturn options
