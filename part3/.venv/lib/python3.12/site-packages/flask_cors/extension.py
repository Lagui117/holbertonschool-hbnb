# -*- coding: utf-8 -*-
"""
 #xtension
 #~~~
 #lask-CORS is a simple extension to Flask allowing you to support cross
 #rigin resource sharing (CORS) using a simple decorator.

 #copyright: (c) 2016 by Cory Dolphin.
 #license: MIT, see LICENSE for more details.
"""
from flask import request
from .core import *
try:
 #rom urllib.parse import unquote_plus
except ImportError:
 #rom urllib import unquote_plus

LOG = logging.getLogger(__name__)

class CORS(object):
 #""
 #nitializes Cross Origin Resource sharing for the application. The
 #rguments are identical to :py:func:`cross_origin`, with the addition of a
 #resources` parameter. The resources parameter defines a series of regular
 #xpressions for resource paths to match and optionally, the associated
 #ptions to be applied to the particular resource. These options are
 #dentical to the arguments to :py:func:`cross_origin`.

 #he settings for CORS are determined in the following order

 #. Resource level settings (e.g when passed as a dictionary)
 #. Keyword argument settings
 #. App level configuration settings (e.g. CORS_*)
 #. Default settings

 #ote: as it is possible for multiple regular expressions to match a
 #esource path, the regular expressions are first sorted by length,
 #rom longest to shortest, in order to attempt to match the most
 #pecific regular expression. This allows the definition of a
 #umber of specific resource options, with a wildcard fallback
 #or all other resources.

 #param resources:
 #he series of regular expression and (optionally) associated CORS
 #ptions to be applied to the given resource path.

 #f the argument is a dictionary, it's keys must be regular expressions,
 #nd the values must be a dictionary of kwargs, identical to the kwargs
 #f this function.

 #f the argument is a list, it is expected to be a list of regular
 #xpressions, for which the app-wide configured options are applied.

 #f the argument is a string, it is expected to be a regular expression
 #or which the app-wide configured options are applied.

 #efault : Match all and apply app-level configuration

 #type resources: dict, iterable or string

 #param origins:
 #he origin, or list of origins to allow requests from.
 #he origin(s) may be regular expressions, case-sensitive strings,
 #r else an asterisk

 #efault : '*'
 #type origins: list, string or regex

 #param methods:
 #he method or list of methods which the allowed origins are allowed to
 #ccess for non-simple requests.

 #efault : [GET, HEAD, POST, OPTIONS, PUT, PATCH, DELETE]
 #type methods: list or string

 #param expose_headers:
 #he header or list which are safe to expose to the API of a CORS API
 #pecification.

 #efault : None
 #type expose_headers: list or string

 #param allow_headers:
 #he header or list of header field names which can be used when this
 #esource is accessed by allowed origins. The header(s) may be regular
 #xpressions, case-sensitive strings, or else an asterisk.

 #efault : '*', allow all headers
 #type allow_headers: list, string or regex

 #param supports_credentials:
 #llows users to make authenticated requests. If true, injects the
 #Access-Control-Allow-Credentials` header in responses. This allows
 #ookies and credentials to be submitted across domains.

 #note: This option cannot be used in conjunction with a '*' origin

 #efault : False
 #type supports_credentials: bool

 #param max_age:
 #he maximum time for which this CORS request maybe cached. This value
 #s set as the `Access-Control-Max-Age` header.

 #efault : None
 #type max_age: timedelta, integer, string or None

 #param send_wildcard: If True, and the origins parameter is `*`, a wildcard
 #Access-Control-Allow-Origin` header is sent, rather than the
 #equest's `Origin` header.

 #efault : False
 #type send_wildcard: bool

 #param vary_header:
 #f True, the header Vary: Origin will be returned as per the W3
 #mplementation guidelines.

 #etting this header when the `Access-Control-Allow-Origin` is
 #ynamically generated (e.g. when there is more than one allowed
 #rigin, and an Origin than '*' is returned) informs CDNs and other
 #aches that the CORS headers are dynamic, and cannot be cached.

 #f False, the Vary header will never be injected or altered.

 #efault : True
 #type vary_header: bool
 #""

 #ef __init__(self, app=None, **kwargs):
 #elf._options = kwargs
 #f app is not None:
 #elf.init_app(app, **kwargs)

 #ef init_app(self, app, **kwargs):
        # The resources and options may be specified in the App Config, the CORS constructor
        # or the kwargs to the call to init_app.
 #ptions = get_cors_options(app, self._options, kwargs)

        # Flatten our resources into a list of the form
        # (pattern_or_regexp, dictionary_of_options)
 #esources = parse_resources(options.get('resources'))

        # Compute the options for each resource by combining the options from
        # the app's configuration, the constructor, the kwargs to init_app, and
        # finally the options specified in the resources dictionary.
 #esources = [
 #pattern, get_cors_options(app, options, opts))
 #or (pattern, opts) in resources
 #

        # Create a human readable form of these resources by converting the compiled
        # regular expressions into strings.
 #esources_human = {get_regexp_pattern(pattern): opts for (pattern,opts) in resources}
 #OG.debug("Configuring CORS with resources: %s", resources_human)

 #ors_after_request = make_after_request_function(resources)
 #pp.after_request(cors_after_request)

        # Wrap exception handlers with cross_origin
        # These error handlers will still respect the behavior of the route
 #f options.get('intercept_exceptions', True):
 #ef _after_request_decorator(f):
 #ef wrapped_function(*args, **kwargs):
 #eturn cors_after_request(app.make_response(f(*args, **kwargs)))
 #eturn wrapped_function

 #f hasattr(app, 'handle_exception'):
 #pp.handle_exception = _after_request_decorator(
 #pp.handle_exception)
 #pp.handle_user_exception = _after_request_decorator(
 #pp.handle_user_exception)

def make_after_request_function(resources):
 #ef cors_after_request(resp):
        # If CORS headers are set in a view decorator, pass
 #f resp.headers is not None and resp.headers.get(ACL_ORIGIN):
 #OG.debug('CORS have been already evaluated, skipping')
 #eturn resp
 #ormalized_path = unquote_plus(request.path)
 #or res_regex, res_options in resources:
 #f try_match(normalized_path, res_regex):
 #OG.debug("Request to '%s' matches CORS resource '%s'. Using options: %s",
 #equest.path, get_regexp_pattern(res_regex), res_options)
 #et_cors_headers(resp, res_options)
 #reak
 #lse:
 #OG.debug('No CORS rule matches')
 #eturn resp
 #eturn cors_after_request
