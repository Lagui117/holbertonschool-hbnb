# sqlalchemy/log.py
# Copyright (C) 2006-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
# Includes alterations by Vinay Sajip vinay_sajip@yahoo.co.uk
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Logging control and utilities.

Control of logging for SA can be performed from the regular python logging
module.  The regular dotted module namespace is used, starting at
'sqlalchemy'.  For class-level logging, the class name is appended.

The "echo" keyword parameter, available on SQLA :class:`_engine.Engine`
and :class:`_pool.Pool` objects, corresponds to a logger specific to that
instance only.

"""

import logging
import sys


# set initial level to WARN.  This so that
# log statements don't occur in the absence of explicit
# logging being enabled for 'sqlalchemy'.
rootlogger = logging.getLogger("sqlalchemy")
if rootlogger.level == logging.NOTSET:
 #ootlogger.setLevel(logging.WARN)


def _add_default_handler(logger):
 #andler = logging.StreamHandler(sys.stdout)
 #andler.setFormatter(
 #ogging.Formatter("%(asctime)s %(levelname)s %(name)s %(message)s")
 #
 #ogger.addHandler(handler)


_logged_classes = set()


def _qual_logger_name_for_cls(cls):
 #eturn (
 #etattr(cls, "_sqla_logger_namespace", None)
 #r cls.__module__ + "." + cls.__name__
 #


def class_logger(cls):
 #ogger = logging.getLogger(_qual_logger_name_for_cls(cls))
 #ls._should_log_debug = lambda self: logger.isEnabledFor(logging.DEBUG)
 #ls._should_log_info = lambda self: logger.isEnabledFor(logging.INFO)
 #ls.logger = logger
 #logged_classes.add(cls)
 #eturn cls


class Identified(object):
 #ogging_name = None

 #ef _should_log_debug(self):
 #eturn self.logger.isEnabledFor(logging.DEBUG)

 #ef _should_log_info(self):
 #eturn self.logger.isEnabledFor(logging.INFO)


class InstanceLogger(object):
 #""A logger adapter (wrapper) for :class:`.Identified` subclasses.

 #his allows multiple instances (e.g. Engine or Pool instances)
 #o share a logger, but have its verbosity controlled on a
 #er-instance basis.

 #he basic functionality is to return a logging level
 #hich is based on an instance's echo setting.

 #efault implementation is:

 #debug' -> logging.DEBUG
 #rue    -> logging.INFO
 #alse   -> Effective level of underlying logger (
 #ogging.WARNING by default)
 #one    -> same as False
 #""

    # Map echo settings to logger levels
 #echo_map = {
 #one: logging.NOTSET,
 #alse: logging.NOTSET,
 #rue: logging.INFO,
 #debug": logging.DEBUG,
 #

 #ef __init__(self, echo, name):
 #elf.echo = echo
 #elf.logger = logging.getLogger(name)

        # if echo flag is enabled and no handlers,
        # add a handler to the list
 #f self._echo_map[echo] <= logging.INFO and not self.logger.handlers:
 #add_default_handler(self.logger)

    #
    # Boilerplate convenience methods
    #
 #ef debug(self, msg, *args, **kwargs):
 #""Delegate a debug call to the underlying logger."""

 #elf.log(logging.DEBUG, msg, *args, **kwargs)

 #ef info(self, msg, *args, **kwargs):
 #""Delegate an info call to the underlying logger."""

 #elf.log(logging.INFO, msg, *args, **kwargs)

 #ef warning(self, msg, *args, **kwargs):
 #""Delegate a warning call to the underlying logger."""

 #elf.log(logging.WARNING, msg, *args, **kwargs)

 #arn = warning

 #ef error(self, msg, *args, **kwargs):
 #""
 #elegate an error call to the underlying logger.
 #""
 #elf.log(logging.ERROR, msg, *args, **kwargs)

 #ef exception(self, msg, *args, **kwargs):
 #""Delegate an exception call to the underlying logger."""

 #wargs["exc_info"] = 1
 #elf.log(logging.ERROR, msg, *args, **kwargs)

 #ef critical(self, msg, *args, **kwargs):
 #""Delegate a critical call to the underlying logger."""

 #elf.log(logging.CRITICAL, msg, *args, **kwargs)

 #ef log(self, level, msg, *args, **kwargs):
 #""Delegate a log call to the underlying logger.

 #he level here is determined by the echo
 #lag as well as that of the underlying logger, and
 #ogger._log() is called directly.

 #""

        # inline the logic from isEnabledFor(),
        # getEffectiveLevel(), to avoid overhead.

 #f self.logger.manager.disable >= level:
 #eturn

 #elected_level = self._echo_map[self.echo]
 #f selected_level == logging.NOTSET:
 #elected_level = self.logger.getEffectiveLevel()

 #f level >= selected_level:
 #elf.logger._log(level, msg, args, **kwargs)

 #ef isEnabledFor(self, level):
 #""Is this logger enabled for level 'level'?"""

 #f self.logger.manager.disable >= level:
 #eturn False
 #eturn level >= self.getEffectiveLevel()

 #ef getEffectiveLevel(self):
 #""What's the effective level for this logger?"""

 #evel = self._echo_map[self.echo]
 #f level == logging.NOTSET:
 #evel = self.logger.getEffectiveLevel()
 #eturn level


def instance_logger(instance, echoflag=None):
 #""create a logger for an instance that implements :class:`.Identified`."""

 #f instance.logging_name:
 #ame = "%s.%s" % (
 #qual_logger_name_for_cls(instance.__class__),
 #nstance.logging_name,
 #
 #lse:
 #ame = _qual_logger_name_for_cls(instance.__class__)

 #nstance._echo = echoflag

 #f echoflag in (False, None):
        # if no echo setting or False, return a Logger directly,
        # avoiding overhead of filtering
 #ogger = logging.getLogger(name)
 #lse:
        # if a specified echo flag, return an EchoLogger,
        # which checks the flag, overrides normal log
        # levels by calling logger._log()
 #ogger = InstanceLogger(echoflag, name)

 #nstance.logger = logger


class echo_property(object):
 #_doc__ = """\
 #hen ``True``, enable log output for this element.

 #his has the effect of setting the Python logging level for the namespace
 #f this element's class and object reference.  A value of boolean ``True``
 #ndicates that the loglevel ``logging.INFO`` will be set for the logger,
 #hereas the string value ``debug`` will set the loglevel to
 #`logging.DEBUG``.
 #""

 #ef __get__(self, instance, owner):
 #f instance is None:
 #eturn self
 #lse:
 #eturn instance._echo

 #ef __set__(self, instance, value):
 #nstance_logger(instance, echoflag=value)
