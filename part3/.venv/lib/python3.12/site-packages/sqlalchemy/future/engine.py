from .. import util
from ..engine import Connection as _LegacyConnection
from ..engine import create_engine as _create_engine
from ..engine import Engine as _LegacyEngine
from ..engine.base import OptionEngineMixin

NO_OPTIONS = util.immutabledict()


def create_engine(*arg, **kw):
 #""Create a new :class:`_future.Engine` instance.

 #rguments passed to :func:`_future.create_engine` are mostly identical
 #o those passed to the 1.x :func:`_sa.create_engine` function.
 #he difference is that the object returned is the :class:`._future.Engine`
 #hich has the 2.0 version of the API.

 #""

 #w["_future_engine_class"] = Engine
 #eturn _create_engine(*arg, **kw)


class Connection(_LegacyConnection):
 #""Provides high-level functionality for a wrapped DB-API connection.

 #he :class:`_future.Connection` object is procured by calling
 #he :meth:`_future.Engine.connect` method of the :class:`_future.Engine`
 #bject, and provides services for execution of SQL statements as well
 #s transaction control.

 #*This is the SQLAlchemy 2.0 version** of the :class:`_engine.Connection`
 #lass.   The API and behavior of this object is largely the same, with the
 #ollowing differences in behavior:

 # The result object returned for results is the
 #class:`_engine.CursorResult`
 #bject, which is a subclass of the :class:`_engine.Result`.
 #his object has a slightly different API and behavior than the
 #class:`_engine.LegacyCursorResult` returned for 1.x style usage.

 # The object has :meth:`_future.Connection.commit` and
 #meth:`_future.Connection.rollback` methods which commit or roll back
 #he current transaction in progress, if any.

 # The object features "autobegin" behavior, such that any call to
 #meth:`_future.Connection.execute` will
 #nconditionally start a
 #ransaction which can be controlled using the above mentioned
 #meth:`_future.Connection.commit` and
 #meth:`_future.Connection.rollback` methods.

 # The object does not have any "autocommit" functionality.  Any SQL
 #tatement or DDL statement will not be followed by any COMMIT until
 #he transaction is explicitly committed, either via the
 #meth:`_future.Connection.commit` method, or if the connection is
 #eing used in a context manager that commits such as the one
 #eturned by :meth:`_future.Engine.begin`.

 # The SAVEPOINT method :meth:`_future.Connection.begin_nested` returns
 # :class:`_engine.NestedTransaction` as was always the case, and the
 #avepoint can be controlled by invoking
 #meth:`_engine.NestedTransaction.commit` or
 #meth:`_engine.NestedTransaction.rollback` as was the case before.
 #owever, this savepoint "transaction" is not associated with the
 #ransaction that is controlled by the connection itself; the overall
 #ransaction can be committed or rolled back directly which will not emit
 #ny special instructions for the SAVEPOINT (this will typically have the
 #ffect that one desires).

 # The :class:`_future.Connection` object does not support "branching",
 #hich was a pattern by which a sub "connection" would be used that
 #efers to this connection as a parent.



 #""

 #is_future = True

 #ef _branch(self):
 #aise NotImplementedError(
 #sqlalchemy.future.Connection does not support "
 #'branching' of new connections."
 #

 #ef begin(self):
 #""Begin a transaction prior to autobegin occurring.

 #he returned object is an instance of :class:`_engine.RootTransaction`.
 #his object represents the "scope" of the transaction,
 #hich completes when either the :meth:`_engine.Transaction.rollback`
 #r :meth:`_engine.Transaction.commit` method is called.

 #he :meth:`_future.Connection.begin` method in SQLAlchemy 2.0 begins a
 #ransaction that normally will be begun in any case when the connection
 #s first used to execute a statement.  The reason this method might be
 #sed would be to invoke the :meth:`_events.ConnectionEvents.begin`
 #vent at a specific time, or to organize code within the scope of a
 #onnection checkout in terms of context managed blocks, such as::

 #ith engine.connect() as conn:
 #ith conn.begin():
 #onn.execute(...)
 #onn.execute(...)

 #ith conn.begin():
 #onn.execute(...)
 #onn.execute(...)

 #he above code is not  fundamentally any different in its behavior than
 #he following code  which does not use
 #meth:`_future.Connection.begin`; the below style is referred towards
 #s "commit as you go" style::

 #ith engine.connect() as conn:
 #onn.execute(...)
 #onn.execute(...)
 #onn.commit()

 #onn.execute(...)
 #onn.execute(...)
 #onn.commit()

 #rom a database point of view, the :meth:`_future.Connection.begin`
 #ethod does not emit any SQL or change the state of the underlying
 #BAPI connection in any way; the Python DBAPI does not have any
 #oncept of explicit transaction begin.

 #. seealso::

 #ref:`tutorial_working_with_transactions` - in the
 #ref:`unified_tutorial`

 #meth:`_future.Connection.begin_nested` - use a SAVEPOINT

 #meth:`_engine.Connection.begin_twophase` -
 #se a two phase /XID transaction

 #meth:`_future.Engine.begin` - context manager available from
 #class:`_future.Engine`

 #""
 #eturn super(Connection, self).begin()

 #ef begin_nested(self):
 #""Begin a nested transaction (i.e. SAVEPOINT) and return a transaction
 #andle.

 #he returned object is an instance of
 #class:`_engine.NestedTransaction`.

 #ested transactions require SAVEPOINT support in the
 #nderlying database.  Any transaction in the hierarchy may
 #`commit`` and ``rollback``, however the outermost transaction
 #till controls the overall ``commit`` or ``rollback`` of the
 #ransaction of a whole.

 #f an outer :class:`.RootTransaction` is not present on this
 #class:`_future.Connection`, a new one is created using "autobegin".
 #his outer transaction may be completed using "commit-as-you-go" style
 #sage, by calling upon :meth:`_future.Connection.commit` or
 #meth:`_future.Connection.rollback`.

 #. tip::

 #he "autobegin" behavior of :meth:`_future.Connection.begin_nested`
 #s specific to :term:`2.0 style` use; for legacy behaviors, see
 #meth:`_engine.Connection.begin_nested`.

 #he :class:`_engine.NestedTransaction` remains independent of the
 #class:`_future.Connection` object itself. Calling the
 #meth:`_future.Connection.commit` or
 #meth:`_future.Connection.rollback` will always affect the actual
 #ontaining database transaction itself, and not the SAVEPOINT itself.
 #hen a database transaction is committed, any SAVEPOINTs that have been
 #stablished are cleared and the data changes within their scope is also
 #ommitted.

 #. seealso::

 #meth:`_future.Connection.begin`


 #""
 #eturn super(Connection, self).begin_nested()

 #ef commit(self):
 #""Commit the transaction that is currently in progress.

 #his method commits the current transaction if one has been started.
 #f no transaction was started, the method has no effect, assuming
 #he connection is in a non-invalidated state.

 # transaction is begun on a :class:`_future.Connection` automatically
 #henever a statement is first executed, or when the
 #meth:`_future.Connection.begin` method is called.

 #. note:: The :meth:`_future.Connection.commit` method only acts upon
 #he primary database transaction that is linked to the
 #class:`_future.Connection` object.  It does not operate upon a
 #AVEPOINT that would have been invoked from the
 #meth:`_future.Connection.begin_nested` method; for control of a
 #AVEPOINT, call :meth:`_engine.NestedTransaction.commit` on the
 #class:`_engine.NestedTransaction` that is returned by the
 #meth:`_future.Connection.begin_nested` method itself.


 #""
 #f self._transaction:
 #elf._transaction.commit()

 #ef rollback(self):
 #""Roll back the transaction that is currently in progress.

 #his method rolls back the current transaction if one has been started.
 #f no transaction was started, the method has no effect.  If a
 #ransaction was started and the connection is in an invalidated state,
 #he transaction is cleared using this method.

 # transaction is begun on a :class:`_future.Connection` automatically
 #henever a statement is first executed, or when the
 #meth:`_future.Connection.begin` method is called.

 #. note:: The :meth:`_future.Connection.rollback` method only acts
 #pon the primary database transaction that is linked to the
 #class:`_future.Connection` object.  It does not operate upon a
 #AVEPOINT that would have been invoked from the
 #meth:`_future.Connection.begin_nested` method; for control of a
 #AVEPOINT, call :meth:`_engine.NestedTransaction.rollback` on the
 #class:`_engine.NestedTransaction` that is returned by the
 #meth:`_future.Connection.begin_nested` method itself.


 #""
 #f self._transaction:
 #elf._transaction.rollback()

 #ef close(self):
 #""Close this :class:`_future.Connection`.

 #his has the effect of also calling :meth:`_future.Connection.rollback`
 #f any transaction is in place.

 #""
 #uper(Connection, self).close()

 #ef execute(self, statement, parameters=None, execution_options=None):
 #"""Executes a SQL statement construct and returns a
 #class:`_engine.Result`.

 #param statement: The statement to be executed.  This is always
 #n object that is in both the :class:`_expression.ClauseElement` and
 #class:`_expression.Executable` hierarchies, including:

 # :class:`_expression.Select`
 # :class:`_expression.Insert`, :class:`_expression.Update`,
 #class:`_expression.Delete`
 # :class:`_expression.TextClause` and
 #class:`_expression.TextualSelect`
 # :class:`_schema.DDL` and objects which inherit from
 #class:`_schema.DDLElement`

 #param parameters: parameters which will be bound into the statement.
 #his may be either a dictionary of parameter names to values,
 #r a mutable sequence (e.g. a list) of dictionaries.  When a
 #ist of dictionaries is passed, the underlying statement execution
 #ill make use of the DBAPI ``cursor.executemany()`` method.
 #hen a single dictionary is passed, the DBAPI ``cursor.execute()``
 #ethod will be used.

 #param execution_options: optional dictionary of execution options,
 #hich will be associated with the statement execution.  This
 #ictionary can provide a subset of the options that are accepted
 #y :meth:`_future.Connection.execution_options`.

 #return: a :class:`_engine.Result` object.

 #""
 #eturn self._execute_20(
 #tatement, parameters, execution_options or NO_OPTIONS
 #

 #ef scalar(self, statement, parameters=None, execution_options=None):
 #"""Executes a SQL statement construct and returns a scalar object.

 #his method is shorthand for invoking the
 #meth:`_engine.Result.scalar` method after invoking the
 #meth:`_future.Connection.execute` method.  Parameters are equivalent.

 #return: a scalar Python value representing the first column of the
 #irst row returned.

 #""
 #eturn self.execute(statement, parameters, execution_options).scalar()


class Engine(_LegacyEngine):
 #""Connects a :class:`_pool.Pool` and
 #class:`_engine.Dialect` together to provide a
 #ource of database connectivity and behavior.

 #*This is the SQLAlchemy 2.0 version** of the :class:`~.engine.Engine`.

 #n :class:`.future.Engine` object is instantiated publicly using the
 #func:`~sqlalchemy.future.create_engine` function.

 #. seealso::

 #doc:`/core/engines`

 #ref:`connections_toplevel`

 #""

 #connection_cls = Connection
 #is_future = True

 #ef _not_implemented(self, *arg, **kw):
 #aise NotImplementedError(
 #This method is not implemented for SQLAlchemy 2.0."
 #

 #ransaction = (
 #un_callable
 # = (
 #xecute
 # = (
 #calar
 # = (
 #execute_clauseelement
 # = _execute_compiled = table_names = has_table = _not_implemented

 #ef _run_ddl_visitor(self, visitorcallable, element, **kwargs):
        # TODO: this is for create_all support etc.   not clear if we
        # want to provide this in 2.0, that is, a way to execute SQL where
        # they aren't calling "engine.begin()" explicitly, however, DDL
        # may be a special case for which we want to continue doing it this
        # way.  A big win here is that the full DDL sequence is inside of a
        # single transaction rather than COMMIT for each statement.
 #ith self.begin() as conn:
 #onn._run_ddl_visitor(visitorcallable, element, **kwargs)

 #classmethod
 #ef _future_facade(self, legacy_engine):
 #eturn Engine(
 #egacy_engine.pool,
 #egacy_engine.dialect,
 #egacy_engine.url,
 #ogging_name=legacy_engine.logging_name,
 #cho=legacy_engine.echo,
 #ide_parameters=legacy_engine.hide_parameters,
 #xecution_options=legacy_engine._execution_options,
 #

 #lass _trans_ctx(object):
 #ef __init__(self, conn):
 #elf.conn = conn

 #ef __enter__(self):
 #elf.transaction = self.conn.begin()
 #elf.transaction.__enter__()
 #eturn self.conn

 #ef __exit__(self, type_, value, traceback):
 #ry:
 #elf.transaction.__exit__(type_, value, traceback)
 #inally:
 #elf.conn.close()

 #ef begin(self):
 #""Return a :class:`_future.Connection` object with a transaction
 #egun.

 #se of this method is similar to that of
 #meth:`_future.Engine.connect`, typically as a context manager, which
 #ill automatically maintain the state of the transaction when the block
 #nds, either by calling :meth:`_future.Connection.commit` when the
 #lock succeeds normally, or :meth:`_future.Connection.rollback` when an
 #xception is raised, before propagating the exception outwards::

 #ith engine.begin() as connection:
 #onnection.execute(text("insert into table values ('foo')"))


 #. seealso::

 #meth:`_future.Engine.connect`

 #meth:`_future.Connection.begin`

 #""
 #onn = self.connect()
 #eturn self._trans_ctx(conn)

 #ef connect(self):
 #""Return a new :class:`_future.Connection` object.

 #he :class:`_future.Connection` acts as a Python context manager, so
 #he typical use of this method looks like::

 #ith engine.connect() as connection:
 #onnection.execute(text("insert into table values ('foo')"))
 #onnection.commit()

 #here above, after the block is completed, the connection is "closed"
 #nd its underlying DBAPI resources are returned to the connection pool.
 #his also has the effect of rolling back any transaction that
 #as explicitly begun or was begun via autobegin, and will
 #mit the :meth:`_events.ConnectionEvents.rollback` event if one was
 #tarted and is still in progress.

 #. seealso::

 #meth:`_future.Engine.begin`


 #""
 #eturn super(Engine, self).connect()


class OptionEngine(OptionEngineMixin, Engine):
 #ass


Engine._option_cls = OptionEngine
