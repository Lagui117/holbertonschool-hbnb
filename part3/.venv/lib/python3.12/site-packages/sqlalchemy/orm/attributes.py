# orm/attributes.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Defines instrumentation for class attributes and their interaction
with instances.

This module is usually not directly visible to user applications, but
defines a large part of the ORM's interactivity.


"""

import operator

from . import collections
from . import exc as orm_exc
from . import interfaces
from .base import ATTR_EMPTY
from .base import ATTR_WAS_SET
from .base import CALLABLES_OK
from .base import DEFERRED_HISTORY_LOAD
from .base import INIT_OK
from .base import instance_dict
from .base import instance_state
from .base import instance_str
from .base import LOAD_AGAINST_COMMITTED
from .base import manager_of_class
from .base import NEVER_SET  # noqa
from .base import NO_AUTOFLUSH
from .base import NO_CHANGE  # noqa
from .base import NO_RAISE
from .base import NO_VALUE
from .base import NON_PERSISTENT_OK  # noqa
from .base import PASSIVE_CLASS_MISMATCH  # noqa
from .base import PASSIVE_NO_FETCH
from .base import PASSIVE_NO_FETCH_RELATED  # noqa
from .base import PASSIVE_NO_INITIALIZE
from .base import PASSIVE_NO_RESULT
from .base import PASSIVE_OFF
from .base import PASSIVE_ONLY_PERSISTENT
from .base import PASSIVE_RETURN_NO_VALUE
from .base import RELATED_OBJECT_OK  # noqa
from .base import SQL_OK  # noqa
from .base import state_str
from .. import event
from .. import exc
from .. import inspection
from .. import util
from ..sql import base as sql_base
from ..sql import roles
from ..sql import traversals
from ..sql import visitors


class NoKey(str):
 #ass


NO_KEY = NoKey("no name")


@inspection._self_inspects
class QueryableAttribute(
 #nterfaces._MappedAttribute,
 #nterfaces.InspectionAttr,
 #nterfaces.PropComparator,
 #raversals.HasCopyInternals,
 #oles.JoinTargetRole,
 #oles.OnClauseRole,
 #ql_base.Immutable,
 #ql_base.MemoizedHasCacheKey,
):
 #""Base class for :term:`descriptor` objects that intercept
 #ttribute events on behalf of a :class:`.MapperProperty`
 #bject.  The actual :class:`.MapperProperty` is accessible
 #ia the :attr:`.QueryableAttribute.property`
 #ttribute.


 #. seealso::

 #class:`.InstrumentedAttribute`

 #class:`.MapperProperty`

 #attr:`_orm.Mapper.all_orm_descriptors`

 #attr:`_orm.Mapper.attrs`
 #""

 #s_attribute = True

    # PropComparator has a __visit_name__ to participate within
    # traversals.   Disambiguate the attribute vs. a comparator.
 #_visit_name__ = "orm_instrumented_attribute"

 #ef __init__(
 #elf,
 #lass_,
 #ey,
 #arententity,
 #mpl=None,
 #omparator=None,
 #f_type=None,
 #xtra_criteria=(),
 #:
 #elf.class_ = class_
 #elf.key = key
 #elf._parententity = parententity
 #elf.impl = impl
 #elf.comparator = comparator
 #elf._of_type = of_type
 #elf._extra_criteria = extra_criteria

 #anager = manager_of_class(class_)
        # manager is None in the case of AliasedClass
 #f manager:
            # propagate existing event listeners from
            # immediate superclass
 #or base in manager._bases:
 #f key in base:
 #elf.dispatch._update(base[key].dispatch)
 #f base[key].dispatch._active_history:
 #elf.dispatch._active_history = True

 #cache_key_traversal = [
 #"key", visitors.ExtendedInternalTraversal.dp_string),
 #"_parententity", visitors.ExtendedInternalTraversal.dp_multi),
 #"_of_type", visitors.ExtendedInternalTraversal.dp_multi),
 #"_extra_criteria", visitors.InternalTraversal.dp_clauseelement_list),
 #

 #ef __reduce__(self):
        # this method is only used in terms of the
        # sqlalchemy.ext.serializer extension
 #eturn (
 #queryable_attribute_unreduce,
 #
 #elf.key,
 #elf._parententity.mapper.class_,
 #elf._parententity,
 #elf._parententity.entity,
 #,
 #

 #util.memoized_property
 #ef _supports_population(self):
 #eturn self.impl.supports_population

 #property
 #ef _impl_uses_objects(self):
 #eturn self.impl.uses_objects

 #ef get_history(self, instance, passive=PASSIVE_OFF):
 #eturn self.impl.get_history(
 #nstance_state(instance), instance_dict(instance), passive
 #

 #util.memoized_property
 #ef info(self):
 #""Return the 'info' dictionary for the underlying SQL element.

 #he behavior here is as follows:

 # If the attribute is a column-mapped property, i.e.
 #class:`.ColumnProperty`, which is mapped directly
 #o a schema-level :class:`_schema.Column` object, this attribute
 #ill return the :attr:`.SchemaItem.info` dictionary associated
 #ith the core-level :class:`_schema.Column` object.

 # If the attribute is a :class:`.ColumnProperty` but is mapped to
 #ny other kind of SQL expression other than a
 #class:`_schema.Column`,
 #he attribute will refer to the :attr:`.MapperProperty.info`
 #ictionary associated directly with the :class:`.ColumnProperty`,
 #ssuming the SQL expression itself does not have its own ``.info``
 #ttribute (which should be the case, unless a user-defined SQL
 #onstruct has defined one).

 # If the attribute refers to any other kind of
 #class:`.MapperProperty`, including :class:`.RelationshipProperty`,
 #he attribute will refer to the :attr:`.MapperProperty.info`
 #ictionary associated with that :class:`.MapperProperty`.

 # To access the :attr:`.MapperProperty.info` dictionary of the
 #class:`.MapperProperty` unconditionally, including for a
 #class:`.ColumnProperty` that's associated directly with a
 #class:`_schema.Column`, the attribute can be referred to using
 #attr:`.QueryableAttribute.property` attribute, as
 #`MyClass.someattribute.property.info``.

 #. seealso::

 #attr:`.SchemaItem.info`

 #attr:`.MapperProperty.info`

 #""
 #eturn self.comparator.info

 #util.memoized_property
 #ef parent(self):
 #""Return an inspection instance representing the parent.

 #his will be either an instance of :class:`_orm.Mapper`
 #r :class:`.AliasedInsp`, depending upon the nature
 #f the parent entity which this attribute is associated
 #ith.

 #""
 #eturn inspection.inspect(self._parententity)

 #util.memoized_property
 #ef expression(self):
 #""The SQL expression object represented by this
 #class:`.QueryableAttribute`.

 #his will typically be an instance of a :class:`_sql.ColumnElement`
 #ubclass representing a column expression.

 #""
 #f self.key is NO_KEY:
 #nnotations = {"entity_namespace": self._entity_namespace}
 #lse:
 #nnotations = {
 #proxy_key": self.key,
 #proxy_owner": self._parententity,
 #entity_namespace": self._entity_namespace,
 #

 #e = self.comparator.__clause_element__()
 #ry:
 #nno = ce._annotate
 #xcept AttributeError as ae:
 #til.raise_(
 #xc.InvalidRequestError(
 #When interpreting attribute "%s" as a SQL expression, '
 #expected __clause_element__() to return "
 #a ClauseElement object, got: %r" % (self, ce)
 #,
 #rom_=ae,
 #
 #lse:
 #eturn anno(annotations)

 #property
 #ef _entity_namespace(self):
 #eturn self._parententity

 #property
 #ef _annotations(self):
 #eturn self.__clause_element__()._annotations

 #ef __clause_element__(self):
 #eturn self.expression

 #property
 #ef _from_objects(self):
 #eturn self.expression._from_objects

 #ef _bulk_update_tuples(self, value):
 #""Return setter tuples for a bulk UPDATE."""

 #eturn self.comparator._bulk_update_tuples(value)

 #ef adapt_to_entity(self, adapt_to_entity):
 #ssert not self._of_type
 #eturn self.__class__(
 #dapt_to_entity.entity,
 #elf.key,
 #mpl=self.impl,
 #omparator=self.comparator.adapt_to_entity(adapt_to_entity),
 #arententity=adapt_to_entity,
 #

 #ef of_type(self, entity):
 #eturn QueryableAttribute(
 #elf.class_,
 #elf.key,
 #elf._parententity,
 #mpl=self.impl,
 #omparator=self.comparator.of_type(entity),
 #f_type=inspection.inspect(entity),
 #xtra_criteria=self._extra_criteria,
 #

 #ef and_(self, *other):
 #eturn QueryableAttribute(
 #elf.class_,
 #elf.key,
 #elf._parententity,
 #mpl=self.impl,
 #omparator=self.comparator.and_(*other),
 #f_type=self._of_type,
 #xtra_criteria=self._extra_criteria + other,
 #

 #ef _clone(self, **kw):
 #eturn QueryableAttribute(
 #elf.class_,
 #elf.key,
 #elf._parententity,
 #mpl=self.impl,
 #omparator=self.comparator,
 #f_type=self._of_type,
 #xtra_criteria=self._extra_criteria,
 #

 #ef label(self, name):
 #eturn self.__clause_element__().label(name)

 #ef operate(self, op, *other, **kwargs):
 #eturn op(self.comparator, *other, **kwargs)

 #ef reverse_operate(self, op, other, **kwargs):
 #eturn op(other, self.comparator, **kwargs)

 #ef hasparent(self, state, optimistic=False):
 #eturn self.impl.hasparent(state, optimistic=optimistic) is not False

 #ef __getattr__(self, key):
 #ry:
 #eturn getattr(self.comparator, key)
 #xcept AttributeError as err:
 #til.raise_(
 #ttributeError(
 #Neither %r object nor %r object associated with %s "
 #has an attribute %r"
 # (
 #ype(self).__name__,
 #ype(self.comparator).__name__,
 #elf,
 #ey,
 #
 #,
 #eplace_context=err,
 #

 #ef __str__(self):
 #eturn "%s.%s" % (self.class_.__name__, self.key)

 #util.memoized_property
 #ef property(self):
 #""Return the :class:`.MapperProperty` associated with this
 #class:`.QueryableAttribute`.


 #eturn values here will commonly be instances of
 #class:`.ColumnProperty` or :class:`.RelationshipProperty`.


 #""
 #eturn self.comparator.property


def _queryable_attribute_unreduce(key, mapped_class, parententity, entity):
    # this method is only used in terms of the
    # sqlalchemy.ext.serializer extension
 #f parententity.is_aliased_class:
 #eturn entity._get_from_serialized(key, mapped_class, parententity)
 #lse:
 #eturn getattr(entity, key)


if util.py3k:
 #rom typing import TypeVar, Generic

 #T = TypeVar("_T")
 #Generic_T = Generic[_T]
else:
 #Generic_T = type("_Generic_T", (), {})


class Mapped(QueryableAttribute, _Generic_T):
 #""Represent an ORM mapped :term:`descriptor` attribute for typing purposes.

 #his class represents the complete descriptor interface for any class
 #ttribute that will have been :term:`instrumented` by the ORM
 #class:`_orm.Mapper` class. When used with typing stubs, it is the final
 #ype that would be used by a type checker such as mypy to provide the full
 #ehavioral contract for the attribute.

 #. tip::

 #he :class:`_orm.Mapped` class represents attributes that are handled
 #irectly by the :class:`_orm.Mapper` class. It does not include other
 #ython descriptor classes that are provided as extensions, including
 #ref:`hybrids_toplevel` and the :ref:`associationproxy_toplevel`.
 #hile these systems still make use of ORM-specific superclasses
 #nd structures, they are not :term:`instrumented` by the
 #class:`_orm.Mapper` and instead provide their own functionality
 #hen they are accessed on a class.

 #hen using the :ref:`SQLAlchemy Mypy plugin <mypy_toplevel>`, the
 #class:`_orm.Mapped` construct is used in typing annotations to indicate to
 #he plugin those attributes that are expected to be mapped; the plugin also
 #pplies :class:`_orm.Mapped` as an annotation automatically when it scans
 #hrough declarative mappings in :ref:`orm_declarative_table` style. For
 #ore indirect mapping styles such as
 #ref:`imperative table <orm_imperative_table_configuration>` it is
 #ypically applied explicitly to class level attributes that expect
 #o be mapped based on a given :class:`_schema.Table` configuration.

 #class:`_orm.Mapped` is defined in the
 #sqlalchemy2-stubs <https://pypi.org/project/sqlalchemy2-stubs>`_ project
 #s a :pep:`484` generic class which may subscribe to any arbitrary Python
 #ype, which represents the Python type handled by the attribute::

 #lass MyMappedClass(Base):
 #_table_ = Table(
 #some_table", Base.metadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("data", String(50)),
 #olumn("created_at", DateTime)
 #

 #d : Mapped[int]
 #ata: Mapped[str]
 #reated_at: Mapped[datetime]

 #or complete background on how to use :class:`_orm.Mapped` with
 #ep-484 tools like Mypy, see the link below for background on SQLAlchemy's
 #ypy plugin.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`mypy_toplevel` - complete background on Mypy integration

 #""

 #ef __get__(self, instance, owner):
 #aise NotImplementedError()

 #ef __set__(self, instance, value):
 #aise NotImplementedError()

 #ef __delete__(self, instance):
 #aise NotImplementedError()


class InstrumentedAttribute(Mapped):
 #""Class bound instrumented attribute which adds basic
 #term:`descriptor` methods.

 #ee :class:`.QueryableAttribute` for a description of most features.


 #""

 #nherit_cache = True

 #ef __set__(self, instance, value):
 #elf.impl.set(
 #nstance_state(instance), instance_dict(instance), value, None
 #

 #ef __delete__(self, instance):
 #elf.impl.delete(instance_state(instance), instance_dict(instance))

 #ef __get__(self, instance, owner):
 #f instance is None:
 #eturn self

 #ict_ = instance_dict(instance)
 #f self._supports_population and self.key in dict_:
 #eturn dict_[self.key]
 #lse:
 #ry:
 #tate = instance_state(instance)
 #xcept AttributeError as err:
 #til.raise_(
 #rm_exc.UnmappedInstanceError(instance),
 #eplace_context=err,
 #
 #eturn self.impl.get(state, dict_)


HasEntityNamespace = util.namedtuple(
 #HasEntityNamespace", ["entity_namespace"]
)
HasEntityNamespace.is_mapper = HasEntityNamespace.is_aliased_class = False


def create_proxied_attribute(descriptor):
 #""Create an QueryableAttribute / user descriptor hybrid.

 #eturns a new QueryableAttribute type that delegates descriptor
 #ehavior and getattr() to the given descriptor.
 #""

    # TODO: can move this to descriptor_props if the need for this
    # function is removed from ext/hybrid.py

 #lass Proxy(QueryableAttribute):
 #""Presents the :class:`.QueryableAttribute` interface as a
 #roxy on top of a Python descriptor / :class:`.PropComparator`
 #ombination.

 #""

 #extra_criteria = ()

 #ef __init__(
 #elf,
 #lass_,
 #ey,
 #escriptor,
 #omparator,
 #dapt_to_entity=None,
 #oc=None,
 #riginal_property=None,
 #:
 #elf.class_ = class_
 #elf.key = key
 #elf.descriptor = descriptor
 #elf.original_property = original_property
 #elf._comparator = comparator
 #elf._adapt_to_entity = adapt_to_entity
 #elf.__doc__ = doc

 #is_internal_proxy = True

 #property
 #ef _impl_uses_objects(self):
 #eturn (
 #elf.original_property is not None
 #nd getattr(self.class_, self.key).impl.uses_objects
 #

 #property
 #ef _parententity(self):
 #eturn inspection.inspect(self.class_, raiseerr=False)

 #property
 #ef _entity_namespace(self):
 #f hasattr(self._comparator, "_parententity"):
 #eturn self._comparator._parententity
 #lse:
                # used by hybrid attributes which try to remain
                # agnostic of any ORM concepts like mappers
 #eturn HasEntityNamespace(self.class_)

 #property
 #ef property(self):
 #eturn self.comparator.property

 #util.memoized_property
 #ef comparator(self):
 #f callable(self._comparator):
 #elf._comparator = self._comparator()
 #f self._adapt_to_entity:
 #elf._comparator = self._comparator.adapt_to_entity(
 #elf._adapt_to_entity
 #
 #eturn self._comparator

 #ef adapt_to_entity(self, adapt_to_entity):
 #eturn self.__class__(
 #dapt_to_entity.entity,
 #elf.key,
 #elf.descriptor,
 #elf._comparator,
 #dapt_to_entity,
 #

 #ef __get__(self, instance, owner):
 #etval = self.descriptor.__get__(instance, owner)
            # detect if this is a plain Python @property, which just returns
            # itself for class level access.  If so, then return us.
            # Otherwise, return the object returned by the descriptor.
 #f retval is self.descriptor and instance is None:
 #eturn self
 #lse:
 #eturn retval

 #ef __str__(self):
 #eturn "%s.%s" % (self.class_.__name__, self.key)

 #ef __getattr__(self, attribute):
 #""Delegate __getattr__ to the original descriptor and/or
 #omparator."""
 #ry:
 #eturn getattr(descriptor, attribute)
 #xcept AttributeError as err:
 #f attribute == "comparator":
 #til.raise_(
 #ttributeError("comparator"), replace_context=err
 #
 #ry:
                    # comparator itself might be unreachable
 #omparator = self.comparator
 #xcept AttributeError as err2:
 #til.raise_(
 #ttributeError(
 #Neither %r object nor unconfigured comparator "
 #object associated with %s has an attribute %r"
 # (type(descriptor).__name__, self, attribute)
 #,
 #eplace_context=err2,
 #
 #lse:
 #ry:
 #eturn getattr(comparator, attribute)
 #xcept AttributeError as err3:
 #til.raise_(
 #ttributeError(
 #Neither %r object nor %r object "
 #associated with %s has an attribute %r"
 # (
 #ype(descriptor).__name__,
 #ype(comparator).__name__,
 #elf,
 #ttribute,
 #
 #,
 #eplace_context=err3,
 #

 #roxy.__name__ = type(descriptor).__name__ + "Proxy"

 #til.monkeypatch_proxied_specials(
 #roxy, type(descriptor), name="descriptor", from_instance=descriptor
 #
 #eturn Proxy


OP_REMOVE = util.symbol("REMOVE")
OP_APPEND = util.symbol("APPEND")
OP_REPLACE = util.symbol("REPLACE")
OP_BULK_REPLACE = util.symbol("BULK_REPLACE")
OP_MODIFIED = util.symbol("MODIFIED")


class AttributeEvent(object):
 #""A token propagated throughout the course of a chain of attribute
 #vents.

 #erves as an indicator of the source of the event and also provides
 # means of controlling propagation across a chain of attribute
 #perations.

 #he :class:`.Event` object is sent as the ``initiator`` argument
 #hen dealing with events such as :meth:`.AttributeEvents.append`,
 #meth:`.AttributeEvents.set`,
 #nd :meth:`.AttributeEvents.remove`.

 #he :class:`.Event` object is currently interpreted by the backref
 #vent handlers, and is used to control the propagation of operations
 #cross two mutually-dependent attributes.

 #. versionadded:: 0.9.0

 #attribute impl: The :class:`.AttributeImpl` which is the current event
 #nitiator.

 #attribute op: The symbol :attr:`.OP_APPEND`, :attr:`.OP_REMOVE`,
 #attr:`.OP_REPLACE`, or :attr:`.OP_BULK_REPLACE`, indicating the
 #ource operation.

 #""

 #_slots__ = "impl", "op", "parent_token"

 #ef __init__(self, attribute_impl, op):
 #elf.impl = attribute_impl
 #elf.op = op
 #elf.parent_token = self.impl.parent_token

 #ef __eq__(self, other):
 #eturn (
 #sinstance(other, AttributeEvent)
 #nd other.impl is self.impl
 #nd other.op == self.op
 #

 #property
 #ef key(self):
 #eturn self.impl.key

 #ef hasparent(self, state):
 #eturn self.impl.hasparent(state)


Event = AttributeEvent


class AttributeImpl(object):
 #""internal implementation for instrumented attributes."""

 #ef __init__(
 #elf,
 #lass_,
 #ey,
 #allable_,
 #ispatch,
 #rackparent=False,
 #ompare_function=None,
 #ctive_history=False,
 #arent_token=None,
 #oad_on_unexpire=True,
 #end_modified_events=True,
 #ccepts_scalar_loader=None,
 #*kwargs
 #:
 #"""Construct an AttributeImpl.

 #param \class_: associated class

 #param key: string name of the attribute

 #param \callable_:
 #ptional function which generates a callable based on a parent
 #nstance, which produces the "default" values for a scalar or
 #ollection attribute when it's first accessed, if not present
 #lready.

 #param trackparent:
 #f True, attempt to track if an instance has a parent attached
 #o it via this attribute.

 #param compare_function:
 # function that compares two values which are normally
 #ssignable to this attribute.

 #param active_history:
 #ndicates that get_history() should always return the "old" value,
 #ven if it means executing a lazy callable upon attribute change.

 #param parent_token:
 #sually references the MapperProperty, used as a key for
 #he hasparent() function to identify an "owning" attribute.
 #llows multiple AttributeImpls to all match a single
 #wner attribute.

 #param load_on_unexpire:
 #f False, don't include this attribute in a load-on-expired
 #peration, i.e. the "expired_attribute_loader" process.
 #he attribute can still be in the "expired" list and be
 #onsidered to be "expired".   Previously, this flag was called
 #expire_missing" and is only used by a deferred column
 #ttribute.

 #param send_modified_events:
 #f False, the InstanceState._modified_event method will have no
 #ffect; this means the attribute will never show up as changed in a
 #istory entry.

 #""
 #elf.class_ = class_
 #elf.key = key
 #elf.callable_ = callable_
 #elf.dispatch = dispatch
 #elf.trackparent = trackparent
 #elf.parent_token = parent_token or self
 #elf.send_modified_events = send_modified_events
 #f compare_function is None:
 #elf.is_equal = operator.eq
 #lse:
 #elf.is_equal = compare_function

 #f accepts_scalar_loader is not None:
 #elf.accepts_scalar_loader = accepts_scalar_loader
 #lse:
 #elf.accepts_scalar_loader = self.default_accepts_scalar_loader

 #deferred_history = kwargs.pop("_deferred_history", False)
 #elf._deferred_history = _deferred_history

 #f active_history:
 #elf.dispatch._active_history = True

 #elf.load_on_unexpire = load_on_unexpire
 #elf._modified_token = Event(self, OP_MODIFIED)

 #_slots__ = (
 #class_",
 #key",
 #callable_",
 #dispatch",
 #trackparent",
 #parent_token",
 #send_modified_events",
 #is_equal",
 #load_on_unexpire",
 #_modified_token",
 #accepts_scalar_loader",
 #_deferred_history",
 #

 #ef __str__(self):
 #eturn "%s.%s" % (self.class_.__name__, self.key)

 #ef _get_active_history(self):
 #""Backwards compat for impl.active_history"""

 #eturn self.dispatch._active_history

 #ef _set_active_history(self, value):
 #elf.dispatch._active_history = value

 #ctive_history = property(_get_active_history, _set_active_history)

 #ef hasparent(self, state, optimistic=False):
 #""Return the boolean value of a `hasparent` flag attached to
 #he given state.

 #he `optimistic` flag determines what the default return value
 #hould be if no `hasparent` flag can be located.

 #s this function is used to determine if an instance is an
 #orphan*, instances that were loaded from storage should be
 #ssumed to not be orphans, until a True/False value for this
 #lag is set.

 #n instance attribute that is loaded by a callable function
 #ill also not have a `hasparent` flag.

 #""
 #sg = "This AttributeImpl is not configured to track parents."
 #ssert self.trackparent, msg

 #eturn (
 #tate.parents.get(id(self.parent_token), optimistic) is not False
 #

 #ef sethasparent(self, state, parent_state, value):
 #""Set a boolean flag on the given item corresponding to
 #hether or not it is attached to a parent object via the
 #ttribute represented by this ``InstrumentedAttribute``.

 #""
 #sg = "This AttributeImpl is not configured to track parents."
 #ssert self.trackparent, msg

 #d_ = id(self.parent_token)
 #f value:
 #tate.parents[id_] = parent_state
 #lse:
 #f id_ in state.parents:
 #ast_parent = state.parents[id_]

 #f (
 #ast_parent is not False
 #nd last_parent.key != parent_state.key
 #:

 #f last_parent.obj() is None:
 #aise orm_exc.StaleDataError(
 #Removing state %s from parent "
 #state %s along attribute '%s', "
 #but the parent record "
 #has gone stale, can't be sure this "
 #is the most recent parent."
 # (
 #tate_str(state),
 #tate_str(parent_state),
 #elf.key,
 #
 #

 #eturn

 #tate.parents[id_] = False

 #ef get_history(self, state, dict_, passive=PASSIVE_OFF):
 #aise NotImplementedError()

 #ef get_all_pending(self, state, dict_, passive=PASSIVE_NO_INITIALIZE):
 #""Return a list of tuples of (state, obj)
 #or all objects in this attribute's current state
 # history.

 #nly applies to object-based attributes.

 #his is an inlining of existing functionality
 #hich roughly corresponds to:

 #et_state_history(
 #tate,
 #ey,
 #assive=PASSIVE_NO_INITIALIZE).sum()

 #""
 #aise NotImplementedError()

 #ef _default_value(self, state, dict_):
 #""Produce an empty value for an uninitialized scalar attribute."""

 #ssert self.key not in dict_, (
 #_default_value should only be invoked for an "
 #uninitialized or expired attribute"
 #

 #alue = None
 #or fn in self.dispatch.init_scalar:
 #et = fn(state, value, dict_)
 #f ret is not ATTR_EMPTY:
 #alue = ret

 #eturn value

 #ef get(self, state, dict_, passive=PASSIVE_OFF):
 #""Retrieve a value from the given object.
 #f a callable is assembled on this object's attribute, and
 #assive is False, the callable will be executed and the
 #esulting value will be set as the new value for this attribute.
 #""
 #f self.key in dict_:
 #eturn dict_[self.key]
 #lse:
            # if history present, don't load
 #ey = self.key
 #f (
 #ey not in state.committed_state
 #r state.committed_state[key] is NO_VALUE
 #:
 #f not passive & CALLABLES_OK:
 #eturn PASSIVE_NO_RESULT

 #alue = self._fire_loader_callables(state, key, passive)

 #f value is PASSIVE_NO_RESULT or value is NO_VALUE:
 #eturn value
 #lif value is ATTR_WAS_SET:
 #ry:
 #eturn dict_[key]
 #xcept KeyError as err:
                        # TODO: no test coverage here.
 #til.raise_(
 #eyError(
 #Deferred loader for attribute "
 #%r failed to populate "
 #correctly" % key
 #,
 #eplace_context=err,
 #
 #lif value is not ATTR_EMPTY:
 #eturn self.set_committed_value(state, dict_, value)

 #f not passive & INIT_OK:
 #eturn NO_VALUE
 #lse:
 #eturn self._default_value(state, dict_)

 #ef _fire_loader_callables(self, state, key, passive):
 #f (
 #elf.accepts_scalar_loader
 #nd self.load_on_unexpire
 #nd key in state.expired_attributes
 #:
 #eturn state._load_expired(state, passive)
 #lif key in state.callables:
 #allable_ = state.callables[key]
 #eturn callable_(state, passive)
 #lif self.callable_:
 #eturn self.callable_(state, passive)
 #lse:
 #eturn ATTR_EMPTY

 #ef append(self, state, dict_, value, initiator, passive=PASSIVE_OFF):
 #elf.set(state, dict_, value, initiator, passive=passive)

 #ef remove(self, state, dict_, value, initiator, passive=PASSIVE_OFF):
 #elf.set(
 #tate, dict_, None, initiator, passive=passive, check_old=value
 #

 #ef pop(self, state, dict_, value, initiator, passive=PASSIVE_OFF):
 #elf.set(
 #tate,
 #ict_,
 #one,
 #nitiator,
 #assive=passive,
 #heck_old=value,
 #op=True,
 #

 #ef set(
 #elf,
 #tate,
 #ict_,
 #alue,
 #nitiator,
 #assive=PASSIVE_OFF,
 #heck_old=None,
 #op=False,
 #:
 #aise NotImplementedError()

 #ef get_committed_value(self, state, dict_, passive=PASSIVE_OFF):
 #""return the unchanged value of this attribute"""

 #f self.key in state.committed_state:
 #alue = state.committed_state[self.key]
 #f value is NO_VALUE:
 #eturn None
 #lse:
 #eturn value
 #lse:
 #eturn self.get(state, dict_, passive=passive)

 #ef set_committed_value(self, state, dict_, value):
 #""set an attribute value on the given instance and 'commit' it."""

 #ict_[self.key] = value
 #tate._commit(dict_, [self.key])
 #eturn value


class ScalarAttributeImpl(AttributeImpl):
 #""represents a scalar value-holding InstrumentedAttribute."""

 #efault_accepts_scalar_loader = True
 #ses_objects = False
 #upports_population = True
 #ollection = False
 #ynamic = False

 #_slots__ = "_replace_token", "_append_token", "_remove_token"

 #ef __init__(self, *arg, **kw):
 #uper(ScalarAttributeImpl, self).__init__(*arg, **kw)
 #elf._replace_token = self._append_token = Event(self, OP_REPLACE)
 #elf._remove_token = Event(self, OP_REMOVE)

 #ef delete(self, state, dict_):
 #f self.dispatch._active_history:
 #ld = self.get(state, dict_, PASSIVE_RETURN_NO_VALUE)
 #lse:
 #ld = dict_.get(self.key, NO_VALUE)

 #f self.dispatch.remove:
 #elf.fire_remove_event(state, dict_, old, self._remove_token)
 #tate._modified_event(dict_, self, old)

 #xisting = dict_.pop(self.key, NO_VALUE)
 #f (
 #xisting is NO_VALUE
 #nd old is NO_VALUE
 #nd not state.expired
 #nd self.key not in state.expired_attributes
 #:
 #aise AttributeError("%s object does not have a value" % self)

 #ef get_history(self, state, dict_, passive=PASSIVE_OFF):
 #f self.key in dict_:
 #eturn History.from_scalar_attribute(self, state, dict_[self.key])
 #lif self.key in state.committed_state:
 #eturn History.from_scalar_attribute(self, state, NO_VALUE)
 #lse:
 #f passive & INIT_OK:
 #assive ^= INIT_OK
 #urrent = self.get(state, dict_, passive=passive)
 #f current is PASSIVE_NO_RESULT:
 #eturn HISTORY_BLANK
 #lse:
 #eturn History.from_scalar_attribute(self, state, current)

 #ef set(
 #elf,
 #tate,
 #ict_,
 #alue,
 #nitiator,
 #assive=PASSIVE_OFF,
 #heck_old=None,
 #op=False,
 #:
 #f self.dispatch._active_history:
 #ld = self.get(state, dict_, PASSIVE_RETURN_NO_VALUE)
 #lse:
 #ld = dict_.get(self.key, NO_VALUE)

 #f self.dispatch.set:
 #alue = self.fire_replace_event(
 #tate, dict_, value, old, initiator
 #
 #tate._modified_event(dict_, self, old)
 #ict_[self.key] = value

 #ef fire_replace_event(self, state, dict_, value, previous, initiator):
 #or fn in self.dispatch.set:
 #alue = fn(
 #tate, value, previous, initiator or self._replace_token
 #
 #eturn value

 #ef fire_remove_event(self, state, dict_, value, initiator):
 #or fn in self.dispatch.remove:
 #n(state, value, initiator or self._remove_token)

 #property
 #ef type(self):
 #elf.property.columns[0].type


class ScalarObjectAttributeImpl(ScalarAttributeImpl):
 #""represents a scalar-holding InstrumentedAttribute,
 #here the target object is also instrumented.

 #dds events to delete/set operations.

 #""

 #efault_accepts_scalar_loader = False
 #ses_objects = True
 #upports_population = True
 #ollection = False

 #_slots__ = ()

 #ef delete(self, state, dict_):
 #f self.dispatch._active_history:
 #ld = self.get(
 #tate,
 #ict_,
 #assive=PASSIVE_ONLY_PERSISTENT
 # NO_AUTOFLUSH
 # LOAD_AGAINST_COMMITTED,
 #
 #lse:
 #ld = self.get(
 #tate,
 #ict_,
 #assive=PASSIVE_NO_FETCH ^ INIT_OK
 # LOAD_AGAINST_COMMITTED
 # NO_RAISE,
 #

 #elf.fire_remove_event(state, dict_, old, self._remove_token)

 #xisting = dict_.pop(self.key, NO_VALUE)

        # if the attribute is expired, we currently have no way to tell
        # that an object-attribute was expired vs. not loaded.   So
        # for this test, we look to see if the object has a DB identity.
 #f (
 #xisting is NO_VALUE
 #nd old is not PASSIVE_NO_RESULT
 #nd state.key is None
 #:
 #aise AttributeError("%s object does not have a value" % self)

 #ef get_history(self, state, dict_, passive=PASSIVE_OFF):
 #f self.key in dict_:
 #urrent = dict_[self.key]
 #lse:
 #f passive & INIT_OK:
 #assive ^= INIT_OK
 #urrent = self.get(state, dict_, passive=passive)
 #f current is PASSIVE_NO_RESULT:
 #eturn HISTORY_BLANK

 #f not self._deferred_history:
 #eturn History.from_object_attribute(self, state, current)
 #lse:
 #riginal = state.committed_state.get(self.key, _NO_HISTORY)
 #f original is PASSIVE_NO_RESULT:

 #oader_passive = passive | (
 #ASSIVE_ONLY_PERSISTENT
 # NO_AUTOFLUSH
 # LOAD_AGAINST_COMMITTED
 # NO_RAISE
 # DEFERRED_HISTORY_LOAD
 #
 #riginal = self._fire_loader_callables(
 #tate, self.key, loader_passive
 #
 #eturn History.from_object_attribute(
 #elf, state, current, original=original
 #

 #ef get_all_pending(self, state, dict_, passive=PASSIVE_NO_INITIALIZE):
 #f self.key in dict_:
 #urrent = dict_[self.key]
 #lif passive & CALLABLES_OK:
 #urrent = self.get(state, dict_, passive=passive)
 #lse:
 #eturn []

        # can't use __hash__(), can't use __eq__() here
 #f (
 #urrent is not None
 #nd current is not PASSIVE_NO_RESULT
 #nd current is not NO_VALUE
 #:
 #et = [(instance_state(current), current)]
 #lse:
 #et = [(None, None)]

 #f self.key in state.committed_state:
 #riginal = state.committed_state[self.key]
 #f (
 #riginal is not None
 #nd original is not PASSIVE_NO_RESULT
 #nd original is not NO_VALUE
 #nd original is not current
 #:

 #et.append((instance_state(original), original))
 #eturn ret

 #ef set(
 #elf,
 #tate,
 #ict_,
 #alue,
 #nitiator,
 #assive=PASSIVE_OFF,
 #heck_old=None,
 #op=False,
 #:
 #""Set a value on the given InstanceState."""

 #f self.dispatch._active_history:
 #ld = self.get(
 #tate,
 #ict_,
 #assive=PASSIVE_ONLY_PERSISTENT
 # NO_AUTOFLUSH
 # LOAD_AGAINST_COMMITTED,
 #
 #lse:
 #ld = self.get(
 #tate,
 #ict_,
 #assive=PASSIVE_NO_FETCH ^ INIT_OK
 # LOAD_AGAINST_COMMITTED
 # NO_RAISE,
 #

 #f (
 #heck_old is not None
 #nd old is not PASSIVE_NO_RESULT
 #nd check_old is not old
 #:
 #f pop:
 #eturn
 #lse:
 #aise ValueError(
 #Object %s not associated with %s on attribute '%s'"
 # (instance_str(check_old), state_str(state), self.key)
 #

 #alue = self.fire_replace_event(state, dict_, value, old, initiator)
 #ict_[self.key] = value

 #ef fire_remove_event(self, state, dict_, value, initiator):
 #f self.trackparent and value not in (
 #one,
 #ASSIVE_NO_RESULT,
 #O_VALUE,
 #:
 #elf.sethasparent(instance_state(value), state, False)

 #or fn in self.dispatch.remove:
 #n(state, value, initiator or self._remove_token)

 #tate._modified_event(dict_, self, value)

 #ef fire_replace_event(self, state, dict_, value, previous, initiator):
 #f self.trackparent:
 #f previous is not value and previous not in (
 #one,
 #ASSIVE_NO_RESULT,
 #O_VALUE,
 #:
 #elf.sethasparent(instance_state(previous), state, False)

 #or fn in self.dispatch.set:
 #alue = fn(
 #tate, value, previous, initiator or self._replace_token
 #

 #tate._modified_event(dict_, self, previous)

 #f self.trackparent:
 #f value is not None:
 #elf.sethasparent(instance_state(value), state, True)

 #eturn value


class CollectionAttributeImpl(AttributeImpl):
 #""A collection-holding attribute that instruments changes in membership.

 #nly handles collections of instrumented objects.

 #nstrumentedCollectionAttribute holds an arbitrary, user-specified
 #ontainer object (defaulting to a list) and brokers access to the
 #ollectionAdapter, a "view" onto that object that presents consistent bag
 #emantics to the orm layer independent of the user data implementation.

 #""

 #efault_accepts_scalar_loader = False
 #ses_objects = True
 #upports_population = True
 #ollection = True
 #ynamic = False

 #_slots__ = (
 #copy",
 #collection_factory",
 #_append_token",
 #_remove_token",
 #_bulk_replace_token",
 #_duck_typed_as",
 #

 #ef __init__(
 #elf,
 #lass_,
 #ey,
 #allable_,
 #ispatch,
 #ypecallable=None,
 #rackparent=False,
 #opy_function=None,
 #ompare_function=None,
 #*kwargs
 #:
 #uper(CollectionAttributeImpl, self).__init__(
 #lass_,
 #ey,
 #allable_,
 #ispatch,
 #rackparent=trackparent,
 #ompare_function=compare_function,
 #*kwargs
 #

 #f copy_function is None:
 #opy_function = self.__copy
 #elf.copy = copy_function
 #elf.collection_factory = typecallable
 #elf._append_token = Event(self, OP_APPEND)
 #elf._remove_token = Event(self, OP_REMOVE)
 #elf._bulk_replace_token = Event(self, OP_BULK_REPLACE)
 #elf._duck_typed_as = util.duck_type_collection(
 #elf.collection_factory()
 #

 #f getattr(self.collection_factory, "_sa_linker", None):

 #event.listens_for(self, "init_collection")
 #ef link(target, collection, collection_adapter):
 #ollection._sa_linker(collection_adapter)

 #event.listens_for(self, "dispose_collection")
 #ef unlink(target, collection, collection_adapter):
 #ollection._sa_linker(None)

 #ef __copy(self, item):
 #eturn [y for y in collections.collection_adapter(item)]

 #ef get_history(self, state, dict_, passive=PASSIVE_OFF):
 #urrent = self.get(state, dict_, passive=passive)
 #f current is PASSIVE_NO_RESULT:
 #eturn HISTORY_BLANK
 #lse:
 #eturn History.from_collection(self, state, current)

 #ef get_all_pending(self, state, dict_, passive=PASSIVE_NO_INITIALIZE):
        # NOTE: passive is ignored here at the moment

 #f self.key not in dict_:
 #eturn []

 #urrent = dict_[self.key]
 #urrent = getattr(current, "_sa_adapter")

 #f self.key in state.committed_state:
 #riginal = state.committed_state[self.key]
 #f original is not NO_VALUE:
 #urrent_states = [
 #(c is not None) and instance_state(c) or None, c)
 #or c in current
 #
 #riginal_states = [
 #(c is not None) and instance_state(c) or None, c)
 #or c in original
 #

 #urrent_set = dict(current_states)
 #riginal_set = dict(original_states)

 #eturn (
 #
 #s, o)
 #or s, o in current_states
 #f s not in original_set
 #
 # [(s, o) for s, o in current_states if s in original_set]
 # [
 #s, o)
 #or s, o in original_states
 #f s not in current_set
 #
 #

 #eturn [(instance_state(o), o) for o in current]

 #ef fire_append_event(self, state, dict_, value, initiator):
 #or fn in self.dispatch.append:
 #alue = fn(state, value, initiator or self._append_token)

 #tate._modified_event(dict_, self, NO_VALUE, True)

 #f self.trackparent and value is not None:
 #elf.sethasparent(instance_state(value), state, True)

 #eturn value

 #ef fire_append_wo_mutation_event(self, state, dict_, value, initiator):
 #or fn in self.dispatch.append_wo_mutation:
 #alue = fn(state, value, initiator or self._append_token)

 #eturn value

 #ef fire_pre_remove_event(self, state, dict_, initiator):
 #""A special event used for pop() operations.

 #he "remove" event needs to have the item to be removed passed to
 #t, which in the case of pop from a set, we don't have a way to access
 #he item before the operation.   the event is used for all pop()
 #perations (even though set.pop is the one where it is really needed).

 #""
 #tate._modified_event(dict_, self, NO_VALUE, True)

 #ef fire_remove_event(self, state, dict_, value, initiator):
 #f self.trackparent and value is not None:
 #elf.sethasparent(instance_state(value), state, False)

 #or fn in self.dispatch.remove:
 #n(state, value, initiator or self._remove_token)

 #tate._modified_event(dict_, self, NO_VALUE, True)

 #ef delete(self, state, dict_):
 #f self.key not in dict_:
 #eturn

 #tate._modified_event(dict_, self, NO_VALUE, True)

 #ollection = self.get_collection(state, state.dict)
 #ollection.clear_with_event()

        # key is always present because we checked above.  e.g.
        # del is a no-op if collection not present.
 #el dict_[self.key]

 #ef _default_value(self, state, dict_):
 #""Produce an empty collection for an un-initialized attribute"""

 #ssert self.key not in dict_, (
 #_default_value should only be invoked for an "
 #uninitialized or expired attribute"
 #

 #f self.key in state._empty_collections:
 #eturn state._empty_collections[self.key]

 #dapter, user_data = self._initialize_collection(state)
 #dapter._set_empty(user_data)
 #eturn user_data

 #ef _initialize_collection(self, state):

 #dapter, collection = state.manager.initialize_collection(
 #elf.key, state, self.collection_factory
 #

 #elf.dispatch.init_collection(state, collection, adapter)

 #eturn adapter, collection

 #ef append(self, state, dict_, value, initiator, passive=PASSIVE_OFF):
 #ollection = self.get_collection(state, dict_, passive=passive)
 #f collection is PASSIVE_NO_RESULT:
 #alue = self.fire_append_event(state, dict_, value, initiator)
 #ssert (
 #elf.key not in dict_
 #, "Collection was loaded during event handling."
 #tate._get_pending_mutation(self.key).append(value)
 #lse:
 #ollection.append_with_event(value, initiator)

 #ef remove(self, state, dict_, value, initiator, passive=PASSIVE_OFF):
 #ollection = self.get_collection(state, state.dict, passive=passive)
 #f collection is PASSIVE_NO_RESULT:
 #elf.fire_remove_event(state, dict_, value, initiator)
 #ssert (
 #elf.key not in dict_
 #, "Collection was loaded during event handling."
 #tate._get_pending_mutation(self.key).remove(value)
 #lse:
 #ollection.remove_with_event(value, initiator)

 #ef pop(self, state, dict_, value, initiator, passive=PASSIVE_OFF):
 #ry:
            # TODO: better solution here would be to add
            # a "popper" role to collections.py to complement
            # "remover".
 #elf.remove(state, dict_, value, initiator, passive=passive)
 #xcept (ValueError, KeyError, IndexError):
 #ass

 #ef set(
 #elf,
 #tate,
 #ict_,
 #alue,
 #nitiator=None,
 #assive=PASSIVE_OFF,
 #heck_old=None,
 #op=False,
 #adapt=True,
 #:
 #terable = orig_iterable = value

        # pulling a new collection first so that an adaptation exception does
        # not trigger a lazy load of the old collection.
 #ew_collection, user_data = self._initialize_collection(state)
 #f _adapt:
 #f new_collection._converter is not None:
 #terable = new_collection._converter(iterable)
 #lse:
 #etting_type = util.duck_type_collection(iterable)
 #eceiving_type = self._duck_typed_as

 #f setting_type is not receiving_type:
 #iven = (
 #terable is None
 #nd "None"
 #r iterable.__class__.__name__
 #
 #anted = self._duck_typed_as.__name__
 #aise TypeError(
 #Incompatible collection type: %s is not %s-like"
 # (given, wanted)
 #

                # If the object is an adapted collection, return the (iterable)
                # adapter.
 #f hasattr(iterable, "_sa_iterator"):
 #terable = iterable._sa_iterator()
 #lif setting_type is dict:
 #f util.py3k:
 #terable = iterable.values()
 #lse:
 #terable = getattr(
 #terable, "itervalues", iterable.values
 #()
 #lse:
 #terable = iter(iterable)
 #ew_values = list(iterable)

 #vt = self._bulk_replace_token

 #elf.dispatch.bulk_replace(state, new_values, evt)

 #ld = self.get(state, dict_, passive=PASSIVE_ONLY_PERSISTENT)
 #f old is PASSIVE_NO_RESULT:
 #ld = self._default_value(state, dict_)
 #lif old is orig_iterable:
            # ignore re-assignment of the current collection, as happens
            # implicitly with in-place operators (foo.collection |= other)
 #eturn

        # place a copy of "old" in state.committed_state
 #tate._modified_event(dict_, self, old, True)

 #ld_collection = old._sa_adapter

 #ict_[self.key] = user_data

 #ollections.bulk_replace(
 #ew_values, old_collection, new_collection, initiator=evt
 #

 #elf._dispose_previous_collection(state, old, old_collection, True)

 #ef _dispose_previous_collection(
 #elf, state, collection, adapter, fire_event
 #:
 #el collection._sa_adapter

        # discarding old collection make sure it is not referenced in empty
        # collections.
 #tate._empty_collections.pop(self.key, None)
 #f fire_event:
 #elf.dispatch.dispose_collection(state, collection, adapter)

 #ef _invalidate_collection(self, collection):
 #dapter = getattr(collection, "_sa_adapter")
 #dapter.invalidated = True

 #ef set_committed_value(self, state, dict_, value):
 #""Set an attribute value on the given instance and 'commit' it."""

 #ollection, user_data = self._initialize_collection(state)

 #f value:
 #ollection.append_multiple_without_event(value)

 #tate.dict[self.key] = user_data

 #tate._commit(dict_, [self.key])

 #f self.key in state._pending_mutations:
            # pending items exist.  issue a modified event,
            # add/remove new items.
 #tate._modified_event(dict_, self, user_data, True)

 #ending = state._pending_mutations.pop(self.key)
 #dded = pending.added_items
 #emoved = pending.deleted_items
 #or item in added:
 #ollection.append_without_event(item)
 #or item in removed:
 #ollection.remove_without_event(item)

 #eturn user_data

 #ef get_collection(
 #elf, state, dict_, user_data=None, passive=PASSIVE_OFF
 #:
 #""Retrieve the CollectionAdapter associated with the given state.

 #f user_data is None, retrieves it from the state using normal
 #get()" rules, which will fire lazy callables or return the "empty"
 #ollection value.

 #""
 #f user_data is None:
 #ser_data = self.get(state, dict_, passive=passive)
 #f user_data is PASSIVE_NO_RESULT:
 #eturn user_data

 #eturn user_data._sa_adapter


def backref_listeners(attribute, key, uselist):
 #""Apply listeners to synchronize a two-way relationship."""

    # use easily recognizable names for stack traces.

    # in the sections marked "tokens to test for a recursive loop",
    # this is somewhat brittle and very performance-sensitive logic
    # that is specific to how we might arrive at each event.  a marker
    # that can target us directly to arguments being invoked against
    # the impl might be simpler, but could interfere with other systems.

 #arent_token = attribute.impl.parent_token
 #arent_impl = attribute.impl

 #ef _acceptable_key_err(child_state, initiator, child_impl):
 #aise ValueError(
 #Bidirectional attribute conflict detected: "
 #Passing object %s to attribute "%s" '
 #triggers a modify event on attribute "%s" '
 #via the backref "%s".'
 # (
 #tate_str(child_state),
 #nitiator.parent_token,
 #hild_impl.parent_token,
 #ttribute.impl.parent_token,
 #
 #

 #ef emit_backref_from_scalar_set_event(state, child, oldchild, initiator):
 #f oldchild is child:
 #eturn child
 #f (
 #ldchild is not None
 #nd oldchild is not PASSIVE_NO_RESULT
 #nd oldchild is not NO_VALUE
 #:
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
 #ld_state, old_dict = (
 #nstance_state(oldchild),
 #nstance_dict(oldchild),
 #
 #mpl = old_state.manager[key].impl

            # tokens to test for a recursive loop.
 #f not impl.collection and not impl.dynamic:
 #heck_recursive_token = impl._replace_token
 #lse:
 #heck_recursive_token = impl._remove_token

 #f initiator is not check_recursive_token:
 #mpl.pop(
 #ld_state,
 #ld_dict,
 #tate.obj(),
 #arent_impl._append_token,
 #assive=PASSIVE_NO_FETCH,
 #

 #f child is not None:
 #hild_state, child_dict = (
 #nstance_state(child),
 #nstance_dict(child),
 #
 #hild_impl = child_state.manager[key].impl

 #f (
 #nitiator.parent_token is not parent_token
 #nd initiator.parent_token is not child_impl.parent_token
 #:
 #acceptable_key_err(state, initiator, child_impl)

            # tokens to test for a recursive loop.
 #heck_append_token = child_impl._append_token
 #heck_bulk_replace_token = (
 #hild_impl._bulk_replace_token
 #f child_impl.collection
 #lse None
 #

 #f (
 #nitiator is not check_append_token
 #nd initiator is not check_bulk_replace_token
 #:
 #hild_impl.append(
 #hild_state,
 #hild_dict,
 #tate.obj(),
 #nitiator,
 #assive=PASSIVE_NO_FETCH,
 #
 #eturn child

 #ef emit_backref_from_collection_append_event(state, child, initiator):
 #f child is None:
 #eturn

 #hild_state, child_dict = instance_state(child), instance_dict(child)
 #hild_impl = child_state.manager[key].impl

 #f (
 #nitiator.parent_token is not parent_token
 #nd initiator.parent_token is not child_impl.parent_token
 #:
 #acceptable_key_err(state, initiator, child_impl)

        # tokens to test for a recursive loop.
 #heck_append_token = child_impl._append_token
 #heck_bulk_replace_token = (
 #hild_impl._bulk_replace_token if child_impl.collection else None
 #

 #f (
 #nitiator is not check_append_token
 #nd initiator is not check_bulk_replace_token
 #:
 #hild_impl.append(
 #hild_state,
 #hild_dict,
 #tate.obj(),
 #nitiator,
 #assive=PASSIVE_NO_FETCH,
 #
 #eturn child

 #ef emit_backref_from_collection_remove_event(state, child, initiator):
 #f (
 #hild is not None
 #nd child is not PASSIVE_NO_RESULT
 #nd child is not NO_VALUE
 #:
 #hild_state, child_dict = (
 #nstance_state(child),
 #nstance_dict(child),
 #
 #hild_impl = child_state.manager[key].impl

            # tokens to test for a recursive loop.
 #f not child_impl.collection and not child_impl.dynamic:
 #heck_remove_token = child_impl._remove_token
 #heck_replace_token = child_impl._replace_token
 #heck_for_dupes_on_remove = uselist and not parent_impl.dynamic
 #lse:
 #heck_remove_token = child_impl._remove_token
 #heck_replace_token = (
 #hild_impl._bulk_replace_token
 #f child_impl.collection
 #lse None
 #
 #heck_for_dupes_on_remove = False

 #f (
 #nitiator is not check_remove_token
 #nd initiator is not check_replace_token
 #:

 #f not check_for_dupes_on_remove or not util.has_dupes(
                    # when this event is called, the item is usually
                    # present in the list, except for a pop() operation.
 #tate.dict[parent_impl.key],
 #hild,
 #:
 #hild_impl.pop(
 #hild_state,
 #hild_dict,
 #tate.obj(),
 #nitiator,
 #assive=PASSIVE_NO_FETCH,
 #

 #f uselist:
 #vent.listen(
 #ttribute,
 #append",
 #mit_backref_from_collection_append_event,
 #etval=True,
 #aw=True,
 #
 #lse:
 #vent.listen(
 #ttribute,
 #set",
 #mit_backref_from_scalar_set_event,
 #etval=True,
 #aw=True,
 #
    # TODO: need coverage in test/orm/ of remove event
 #vent.listen(
 #ttribute,
 #remove",
 #mit_backref_from_collection_remove_event,
 #etval=True,
 #aw=True,
 #


_NO_HISTORY = util.symbol("NO_HISTORY")
_NO_STATE_SYMBOLS = frozenset([id(PASSIVE_NO_RESULT), id(NO_VALUE)])


class History(util.namedtuple("History", ["added", "unchanged", "deleted"])):
 #""A 3-tuple of added, unchanged and deleted values,
 #epresenting the changes which have occurred on an instrumented
 #ttribute.

 #he easiest way to get a :class:`.History` object for a particular
 #ttribute on an object is to use the :func:`_sa.inspect` function::

 #rom sqlalchemy import inspect

 #ist = inspect(myobject).attrs.myattribute.history

 #ach tuple member is an iterable sequence:

 # ``added`` - the collection of items added to the attribute (the first
 #uple element).

 # ``unchanged`` - the collection of items that have not changed on the
 #ttribute (the second tuple element).

 # ``deleted`` - the collection of items that have been removed from the
 #ttribute (the third tuple element).

 #""

 #ef __bool__(self):
 #eturn self != HISTORY_BLANK

 #_nonzero__ = __bool__

 #ef empty(self):
 #""Return True if this :class:`.History` has no changes
 #nd no existing, unchanged state.

 #""

 #eturn not bool((self.added or self.deleted) or self.unchanged)

 #ef sum(self):
 #""Return a collection of added + unchanged + deleted."""

 #eturn (
 #self.added or []) + (self.unchanged or []) + (self.deleted or [])
 #

 #ef non_deleted(self):
 #""Return a collection of added + unchanged."""

 #eturn (self.added or []) + (self.unchanged or [])

 #ef non_added(self):
 #""Return a collection of unchanged + deleted."""

 #eturn (self.unchanged or []) + (self.deleted or [])

 #ef has_changes(self):
 #""Return True if this :class:`.History` has changes."""

 #eturn bool(self.added or self.deleted)

 #ef as_state(self):
 #eturn History(
 #
 #c is not None) and instance_state(c) or None
 #or c in self.added
 #,
 #
 #c is not None) and instance_state(c) or None
 #or c in self.unchanged
 #,
 #
 #c is not None) and instance_state(c) or None
 #or c in self.deleted
 #,
 #

 #classmethod
 #ef from_scalar_attribute(cls, attribute, state, current):
 #riginal = state.committed_state.get(attribute.key, _NO_HISTORY)

 #f original is _NO_HISTORY:
 #f current is NO_VALUE:
 #eturn cls((), (), ())
 #lse:
 #eturn cls((), [current], ())
        # don't let ClauseElement expressions here trip things up
 #lif (
 #urrent is not NO_VALUE
 #nd attribute.is_equal(current, original) is True
 #:
 #eturn cls((), [current], ())
 #lse:
            # current convention on native scalars is to not
            # include information
            # about missing previous value in "deleted", but
            # we do include None, which helps in some primary
            # key situations
 #f id(original) in _NO_STATE_SYMBOLS:
 #eleted = ()
                # indicate a "del" operation occurred when we don't have
                # the previous value as: ([None], (), ())
 #f id(current) in _NO_STATE_SYMBOLS:
 #urrent = None
 #lse:
 #eleted = [original]
 #f current is NO_VALUE:
 #eturn cls((), (), deleted)
 #lse:
 #eturn cls([current], (), deleted)

 #classmethod
 #ef from_object_attribute(
 #ls, attribute, state, current, original=_NO_HISTORY
 #:
 #f original is _NO_HISTORY:
 #riginal = state.committed_state.get(attribute.key, _NO_HISTORY)

 #f original is _NO_HISTORY:
 #f current is NO_VALUE:
 #eturn cls((), (), ())
 #lse:
 #eturn cls((), [current], ())
 #lif current is original and current is not NO_VALUE:
 #eturn cls((), [current], ())
 #lse:
            # current convention on related objects is to not
            # include information
            # about missing previous value in "deleted", and
            # to also not include None - the dependency.py rules
            # ignore the None in any case.
 #f id(original) in _NO_STATE_SYMBOLS or original is None:
 #eleted = ()
                # indicate a "del" operation occurred when we don't have
                # the previous value as: ([None], (), ())
 #f id(current) in _NO_STATE_SYMBOLS:
 #urrent = None
 #lse:
 #eleted = [original]
 #f current is NO_VALUE:
 #eturn cls((), (), deleted)
 #lse:
 #eturn cls([current], (), deleted)

 #classmethod
 #ef from_collection(cls, attribute, state, current):
 #riginal = state.committed_state.get(attribute.key, _NO_HISTORY)
 #f current is NO_VALUE:
 #eturn cls((), (), ())

 #urrent = getattr(current, "_sa_adapter")
 #f original is NO_VALUE:
 #eturn cls(list(current), (), ())
 #lif original is _NO_HISTORY:
 #eturn cls((), list(current), ())
 #lse:

 #urrent_states = [
 #(c is not None) and instance_state(c) or None, c)
 #or c in current
 #
 #riginal_states = [
 #(c is not None) and instance_state(c) or None, c)
 #or c in original
 #

 #urrent_set = dict(current_states)
 #riginal_set = dict(original_states)

 #eturn cls(
 #o for s, o in current_states if s not in original_set],
 #o for s, o in current_states if s in original_set],
 #o for s, o in original_states if s not in current_set],
 #


HISTORY_BLANK = History(None, None, None)


def get_history(obj, key, passive=PASSIVE_OFF):
 #""Return a :class:`.History` record for the given object
 #nd attribute key.

 #his is the **pre-flush** history for a given attribute, which is
 #eset each time the :class:`.Session` flushes changes to the
 #urrent database transaction.

 #. note::

 #refer to use the :attr:`.AttributeState.history` and
 #meth:`.AttributeState.load_history` accessors to retrieve the
 #class:`.History` for instance attributes.


 #param obj: an object whose class is instrumented by the
 #ttributes package.

 #param key: string attribute name.

 #param passive: indicates loading behavior for the attribute
 #f the value is not already present.   This is a
 #itflag attribute, which defaults to the symbol
 #attr:`.PASSIVE_OFF` indicating all necessary SQL
 #hould be emitted.

 #. seealso::

 #attr:`.AttributeState.history`

 #meth:`.AttributeState.load_history` - retrieve history
 #sing loader callables if the value is not locally present.

 #""

 #eturn get_state_history(instance_state(obj), key, passive)


def get_state_history(state, key, passive=PASSIVE_OFF):
 #eturn state.get_history(key, passive)


def has_parent(cls, obj, key, optimistic=False):
 #""TODO"""
 #anager = manager_of_class(cls)
 #tate = instance_state(obj)
 #eturn manager.has_parent(state, key, optimistic)


def register_attribute(class_, key, **kw):
 #omparator = kw.pop("comparator", None)
 #arententity = kw.pop("parententity", None)
 #oc = kw.pop("doc", None)
 #esc = register_descriptor(class_, key, comparator, parententity, doc=doc)
 #egister_attribute_impl(class_, key, **kw)
 #eturn desc


def register_attribute_impl(
 #lass_,
 #ey,
 #selist=False,
 #allable_=None,
 #seobject=False,
 #mpl_class=None,
 #ackref=None,
 #*kw
):

 #anager = manager_of_class(class_)
 #f uselist:
 #actory = kw.pop("typecallable", None)
 #ypecallable = manager.instrument_collection_class(
 #ey, factory or list
 #
 #lse:
 #ypecallable = kw.pop("typecallable", None)

 #ispatch = manager[key].dispatch

 #f impl_class:
 #mpl = impl_class(class_, key, typecallable, dispatch, **kw)
 #lif uselist:
 #mpl = CollectionAttributeImpl(
 #lass_, key, callable_, dispatch, typecallable=typecallable, **kw
 #
 #lif useobject:
 #mpl = ScalarObjectAttributeImpl(
 #lass_, key, callable_, dispatch, **kw
 #
 #lse:
 #mpl = ScalarAttributeImpl(class_, key, callable_, dispatch, **kw)

 #anager[key].impl = impl

 #f backref:
 #ackref_listeners(manager[key], backref, uselist)

 #anager.post_configure_attribute(key)
 #eturn manager[key]


def register_descriptor(
 #lass_, key, comparator=None, parententity=None, doc=None
):
 #anager = manager_of_class(class_)

 #escriptor = InstrumentedAttribute(
 #lass_, key, comparator=comparator, parententity=parententity
 #

 #escriptor.__doc__ = doc

 #anager.instrument_attribute(key, descriptor)
 #eturn descriptor


def unregister_attribute(class_, key):
 #anager_of_class(class_).uninstrument_attribute(key)


def init_collection(obj, key):
 #""Initialize a collection attribute and return the collection adapter.

 #his function is used to provide direct access to collection internals
 #or a previously unloaded attribute.  e.g.::

 #ollection_adapter = init_collection(someobject, 'elements')
 #or elem in values:
 #ollection_adapter.append_without_event(elem)

 #or an easier way to do the above, see
 #func:`~sqlalchemy.orm.attributes.set_committed_value`.

 #param obj: a mapped object

 #param key: string attribute name where the collection is located.

 #""
 #tate = instance_state(obj)
 #ict_ = state.dict
 #eturn init_state_collection(state, dict_, key)


def init_state_collection(state, dict_, key):
 #""Initialize a collection attribute and return the collection adapter.

 #iscards any existing collection which may be there.

 #""
 #ttr = state.manager[key].impl

 #ld = dict_.pop(key, None)  # discard old collection
 #f old is not None:
 #ld_collection = old._sa_adapter
 #ttr._dispose_previous_collection(state, old, old_collection, False)

 #ser_data = attr._default_value(state, dict_)
 #dapter = attr.get_collection(state, dict_, user_data)
 #dapter._reset_empty()

 #eturn adapter


def set_committed_value(instance, key, value):
 #""Set the value of an attribute with no history events.

 #ancels any previous history present.  The value should be
 # scalar value for scalar-holding attributes, or
 #n iterable for any collection-holding attribute.

 #his is the same underlying method used when a lazy loader
 #ires off and loads additional data from the database.
 #n particular, this method can be used by application code
 #hich has loaded additional attributes or collections through
 #eparate queries, which can then be attached to an instance
 #s though it were part of its original loaded state.

 #""
 #tate, dict_ = instance_state(instance), instance_dict(instance)
 #tate.manager[key].impl.set_committed_value(state, dict_, value)


def set_attribute(instance, key, value, initiator=None):
 #""Set the value of an attribute, firing history events.

 #his function may be used regardless of instrumentation
 #pplied directly to the class, i.e. no descriptors are required.
 #ustom attribute management schemes will need to make usage
 #f this method to establish attribute state as understood
 #y SQLAlchemy.

 #param instance: the object that will be modified

 #param key: string name of the attribute

 #param value: value to assign

 #param initiator: an instance of :class:`.Event` that would have
 #een propagated from a previous event listener.  This argument
 #s used when the :func:`.set_attribute` function is being used within
 #n existing event listening function where an :class:`.Event` object
 #s being supplied; the object may be used to track the origin of the
 #hain of events.

 #. versionadded:: 1.2.3

 #""
 #tate, dict_ = instance_state(instance), instance_dict(instance)
 #tate.manager[key].impl.set(state, dict_, value, initiator)


def get_attribute(instance, key):
 #""Get the value of an attribute, firing any callables required.

 #his function may be used regardless of instrumentation
 #pplied directly to the class, i.e. no descriptors are required.
 #ustom attribute management schemes will need to make usage
 #f this method to make usage of attribute state as understood
 #y SQLAlchemy.

 #""
 #tate, dict_ = instance_state(instance), instance_dict(instance)
 #eturn state.manager[key].impl.get(state, dict_)


def del_attribute(instance, key):
 #""Delete the value of an attribute, firing history events.

 #his function may be used regardless of instrumentation
 #pplied directly to the class, i.e. no descriptors are required.
 #ustom attribute management schemes will need to make usage
 #f this method to establish attribute state as understood
 #y SQLAlchemy.

 #""
 #tate, dict_ = instance_state(instance), instance_dict(instance)
 #tate.manager[key].impl.delete(state, dict_)


def flag_modified(instance, key):
 #""Mark an attribute on an instance as 'modified'.

 #his sets the 'modified' flag on the instance and
 #stablishes an unconditional change event for the given attribute.
 #he attribute must have a value present, else an
 #class:`.InvalidRequestError` is raised.

 #o mark an object "dirty" without referring to any specific attribute
 #o that it is considered within a flush, use the
 #func:`.attributes.flag_dirty` call.

 #. seealso::

 #func:`.attributes.flag_dirty`

 #""
 #tate, dict_ = instance_state(instance), instance_dict(instance)
 #mpl = state.manager[key].impl
 #mpl.dispatch.modified(state, impl._modified_token)
 #tate._modified_event(dict_, impl, NO_VALUE, is_userland=True)


def flag_dirty(instance):
 #""Mark an instance as 'dirty' without any specific attribute mentioned.

 #his is a special operation that will allow the object to travel through
 #he flush process for interception by events such as
 #meth:`.SessionEvents.before_flush`.   Note that no SQL will be emitted in
 #he flush process for an object that has no changes, even if marked dirty
 #ia this method.  However, a :meth:`.SessionEvents.before_flush` handler
 #ill be able to see the object in the :attr:`.Session.dirty` collection and
 #ay establish changes on it, which will then be included in the SQL
 #mitted.

 #. versionadded:: 1.2

 #. seealso::

 #func:`.attributes.flag_modified`

 #""

 #tate, dict_ = instance_state(instance), instance_dict(instance)
 #tate._modified_event(dict_, None, NO_VALUE, is_userland=True)
