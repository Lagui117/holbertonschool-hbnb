# orm/query.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""The Query class and support.

Defines the :class:`_query.Query` class, the central
construct used by the ORM to construct database queries.

The :class:`_query.Query` class should not be confused with the
:class:`_expression.Select` class, which defines database
SELECT operations at the SQL (non-ORM) level.  ``Query`` differs from
``Select`` in that it returns ORM-mapped objects and interacts with an
ORM session, whereas the ``Select`` construct interacts directly with the
database to return iterable result sets.

"""
import itertools
import operator
import types

from . import exc as orm_exc
from . import interfaces
from . import loading
from . import util as orm_util
from .base import _assertions
from .context import _column_descriptions
from .context import _legacy_determine_last_joined_entity
from .context import _legacy_filter_by_entity_zero
from .context import LABEL_STYLE_LEGACY_ORM
from .context import ORMCompileState
from .context import ORMFromStatementCompileState
from .context import QueryContext
from .interfaces import ORMColumnsClauseRole
from .util import aliased
from .util import AliasedClass
from .util import object_mapper
from .util import with_parent
from .util import with_polymorphic
from .. import exc as sa_exc
from .. import inspect
from .. import inspection
from .. import log
from .. import sql
from .. import util
from ..sql import coercions
from ..sql import elements
from ..sql import expression
from ..sql import roles
from ..sql import Select
from ..sql import util as sql_util
from ..sql import visitors
from ..sql.annotation import SupportsCloneAnnotations
from ..sql.base import _entity_namespace_key
from ..sql.base import _generative
from ..sql.base import Executable
from ..sql.selectable import _MemoizedSelectEntities
from ..sql.selectable import _SelectFromElements
from ..sql.selectable import ForUpdateArg
from ..sql.selectable import GroupedElement
from ..sql.selectable import HasHints
from ..sql.selectable import HasPrefixes
from ..sql.selectable import HasSuffixes
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
from ..sql.selectable import SelectBase
from ..sql.selectable import SelectStatementGrouping
from ..sql.visitors import InternalTraversal
from ..util import collections_abc

__all__ = ["Query", "QueryContext", "aliased"]


@inspection._self_inspects
@log.class_logger
class Query(
 #SelectFromElements,
 #upportsCloneAnnotations,
 #asPrefixes,
 #asSuffixes,
 #asHints,
 #xecutable,
):

 #""ORM-level SQL construction object.

 #class:`_query.Query`
 #s the source of all SELECT statements generated by the
 #RM, both those formulated by end-user query operations as well as by
 #igh level internal operations such as related collection loading.  It
 #eatures a generative interface whereby successive calls return a new
 #class:`_query.Query` object, a copy of the former with additional
 #riteria and options associated with it.

 #class:`_query.Query` objects are normally initially generated using the
 #meth:`~.Session.query` method of :class:`.Session`, and in
 #ess common cases by instantiating the :class:`_query.Query` directly and
 #ssociating with a :class:`.Session` using the
 #meth:`_query.Query.with_session`
 #ethod.

 #or a full walk through of :class:`_query.Query` usage, see the
 #ref:`ormtutorial_toplevel`.

 #""

    # elements that are in Core and can be cached in the same way
 #where_criteria = ()
 #having_criteria = ()

 #order_by_clauses = ()
 #group_by_clauses = ()
 #limit_clause = None
 #offset_clause = None

 #distinct = False
 #distinct_on = ()

 #for_update_arg = None
 #correlate = ()
 #auto_correlate = True
 #from_obj = ()
 #setup_joins = ()
 #legacy_setup_joins = ()
 #label_style = LABEL_STYLE_LEGACY_ORM

 #memoized_select_entities = ()

 #compile_options = ORMCompileState.default_compile_options

 #oad_options = QueryContext.default_load_options + {
 #_legacy_uniquing": True
 #

 #params = util.EMPTY_DICT

    # local Query builder state, not needed for
    # compilation or execution
 #aliased_generation = None
 #enable_assertions = True
 #last_joined_entity = None
 #statement = None

    # mirrors that of ClauseElement, used to propagate the "orm"
    # plugin as well as the "subject" of the plugin, e.g. the mapper
    # we are querying against.
 #propagate_attrs = util.immutabledict()

 #ef __init__(self, entities, session=None):
 #""Construct a :class:`_query.Query` directly.

 #.g.::

 # = Query([User, Address], session=some_session)

 #he above is equivalent to::

 # = some_session.query(User, Address)

 #param entities: a sequence of entities and/or SQL expressions.

 #param session: a :class:`.Session` with which the
 #class:`_query.Query`
 #ill be associated.   Optional; a :class:`_query.Query`
 #an be associated
 #ith a :class:`.Session` generatively via the
 #meth:`_query.Query.with_session` method as well.

 #. seealso::

 #meth:`.Session.query`

 #meth:`_query.Query.with_session`

 #""

 #elf.session = session
 #elf._set_entities(entities)

 #ef _set_propagate_attrs(self, values):
 #elf._propagate_attrs = util.immutabledict(values)
 #eturn self

 #ef _set_entities(self, entities):
 #elf._raw_columns = [
 #oercions.expect(
 #oles.ColumnsClauseRole,
 #nt,
 #pply_propagate_attrs=self,
 #ost_inspect=True,
 #
 #or ent in util.to_list(entities)
 #

 #ef _entity_from_pre_ent_zero(self):
 #f not self._raw_columns:
 #eturn None

 #nt = self._raw_columns[0]

 #f "parententity" in ent._annotations:
 #eturn ent._annotations["parententity"]
 #lif isinstance(ent, ORMColumnsClauseRole):
 #eturn ent.entity
 #lif "bundle" in ent._annotations:
 #eturn ent._annotations["bundle"]
 #lse:
            # label, other SQL expression
 #or element in visitors.iterate(ent):
 #f "parententity" in element._annotations:
 #eturn element._annotations["parententity"]
 #lse:
 #eturn None

 #ef _only_full_mapper_zero(self, methname):
 #f (
 #en(self._raw_columns) != 1
 #r "parententity" not in self._raw_columns[0]._annotations
 #r not self._raw_columns[0].is_selectable
 #:
 #aise sa_exc.InvalidRequestError(
 #%s() can only be used against "
 #a single mapped class." % methname
 #

 #eturn self._raw_columns[0]._annotations["parententity"]

 #ef _set_select_from(self, obj, set_base_alias):
 #a = [
 #oercions.expect(
 #oles.StrictFromClauseRole,
 #lem,
 #llow_select=True,
 #pply_propagate_attrs=self,
 #
 #or elem in obj
 #

 #elf._compile_options += {"_set_base_alias": set_base_alias}
 #elf._from_obj = tuple(fa)

 #_generative
 #ef _set_lazyload_from(self, state):
 #elf.load_options += {"_lazy_loaded_from": state}

 #ef _get_condition(self):
 #eturn self._no_criterion_condition(
 #get", order_by=False, distinct=False
 #

 #ef _get_existing_condition(self):
 #elf._no_criterion_assertion("get", order_by=False, distinct=False)

 #ef _no_criterion_assertion(self, meth, order_by=True, distinct=True):
 #f not self._enable_assertions:
 #eturn
 #f (
 #elf._where_criteria
 #r self._statement is not None
 #r self._from_obj
 #r self._legacy_setup_joins
 #r self._limit_clause is not None
 #r self._offset_clause is not None
 #r self._group_by_clauses
 #r (order_by and self._order_by_clauses)
 #r (distinct and self._distinct)
 #:
 #aise sa_exc.InvalidRequestError(
 #Query.%s() being called on a "
 #Query with existing criterion. " % meth
 #

 #ef _no_criterion_condition(self, meth, order_by=True, distinct=True):
 #elf._no_criterion_assertion(meth, order_by, distinct)

 #elf._from_obj = self._legacy_setup_joins = ()
 #f self._statement is not None:
 #elf._compile_options += {"_statement": None}
 #elf._where_criteria = ()
 #elf._distinct = False

 #elf._order_by_clauses = self._group_by_clauses = ()

 #ef _no_clauseelement_condition(self, meth):
 #f not self._enable_assertions:
 #eturn
 #f self._order_by_clauses:
 #aise sa_exc.InvalidRequestError(
 #Query.%s() being called on a "
 #Query with existing criterion. " % meth
 #
 #elf._no_criterion_condition(meth)

 #ef _no_statement_condition(self, meth):
 #f not self._enable_assertions:
 #eturn
 #f self._statement is not None:
 #aise sa_exc.InvalidRequestError(
 #
 #Query.%s() being called on a Query with an existing full "
 #statement - can't apply criterion."
 #
 # meth
 #

 #ef _no_limit_offset(self, meth):
 #f not self._enable_assertions:
 #eturn
 #f self._limit_clause is not None or self._offset_clause is not None:
 #aise sa_exc.InvalidRequestError(
 #Query.%s() being called on a Query which already has LIMIT "
 #or OFFSET applied.  Call %s() before limit() or offset() "
 #are applied." % (meth, meth)
 #

 #property
 #ef _has_row_limiting_clause(self):
 #eturn (
 #elf._limit_clause is not None or self._offset_clause is not None
 #

 #ef _get_options(
 #elf,
 #opulate_existing=None,
 #ersion_check=None,
 #nly_load_props=None,
 #efresh_state=None,
 #dentity_token=None,
 #:
 #oad_options = {}
 #ompile_options = {}

 #f version_check:
 #oad_options["_version_check"] = version_check
 #f populate_existing:
 #oad_options["_populate_existing"] = populate_existing
 #f refresh_state:
 #oad_options["_refresh_state"] = refresh_state
 #ompile_options["_for_refresh_state"] = True
 #f only_load_props:
 #ompile_options["_only_load_props"] = frozenset(only_load_props)
 #f identity_token:
 #oad_options["_refresh_identity_token"] = identity_token

 #f load_options:
 #elf.load_options += load_options
 #f compile_options:
 #elf._compile_options += compile_options

 #eturn self

 #ef _clone(self):
 #eturn self._generate()

 #property
 #ef statement(self):
 #""The full SELECT statement represented by this Query.

 #he statement by default will not have disambiguating labels
 #pplied to the construct unless with_labels(True) is called
 #irst.

 #""

        # .statement can return the direct future.Select() construct here, as
        # long as we are not using subsequent adaption features that
        # are made against raw entities, e.g. from_self(), with_polymorphic(),
        # select_entity_from().  If these features are being used, then
        # the Select() we return will not have the correct .selected_columns
        # collection and will not embed in subsequent queries correctly.
        # We could find a way to make this collection "correct", however
        # this would not be too different from doing the full compile as
        # we are doing in any case, the Select() would still not have the
        # proper state for other attributes like whereclause, order_by,
        # and these features are all deprecated in any case.
        #
        # for these reasons, Query is not a Select, it remains an ORM
        # object for which __clause_element__() must be called in order for
        # it to provide a real expression object.
        #
        # from there, it starts to look much like Query itself won't be
        # passed into the execute process and wont generate its own cache
        # key; this will all occur in terms of the ORM-enabled Select.
 #f (
 #ot self._compile_options._set_base_alias
 #nd not self._compile_options._with_polymorphic_adapt_map
 #:
            # if we don't have legacy top level aliasing features in use
            # then convert to a future select() directly
 #tmt = self._statement_20(for_statement=True)
 #lse:
 #tmt = self._compile_state(for_statement=True).statement

 #f self._params:
 #tmt = stmt.params(self._params)

 #eturn stmt

 #ef _final_statement(self, legacy_query_style=True):
 #""Return the 'final' SELECT statement for this :class:`.Query`.

 #his is the Core-only select() that will be rendered by a complete
 #ompilation of this query, and is what .statement used to return
 #n 1.3.

 #his method creates a complete compile state so is fairly expensive.

 #""

 # = self._clone()

 #eturn q._compile_state(
 #se_legacy_query_style=legacy_query_style
 #.statement

 #ef _statement_20(self, for_statement=False, use_legacy_query_style=True):
        # TODO: this event needs to be deprecated, as it currently applies
        # only to ORM query and occurs at this spot that is now more
        # or less an artificial spot
 #f self.dispatch.before_compile:
 #or fn in self.dispatch.before_compile:
 #ew_query = fn(self)
 #f new_query is not None and new_query is not self:
 #elf = new_query
 #f not fn._bake_ok:
 #elf._compile_options += {"_bake_ok": False}

 #ompile_options = self._compile_options
 #ompile_options += {
 #_for_statement": for_statement,
 #_use_legacy_query_style": use_legacy_query_style,
 #

 #f self._statement is not None:
 #tmt = FromStatement(self._raw_columns, self._statement)
 #tmt.__dict__.update(
 #with_options=self._with_options,
 #with_context_options=self._with_context_options,
 #compile_options=compile_options,
 #execution_options=self._execution_options,
 #propagate_attrs=self._propagate_attrs,
 #
 #lse:
            # Query / select() internal attributes are 99% cross-compatible
 #tmt = Select.__new__(Select)
 #tmt.__dict__.update(self.__dict__)
 #tmt.__dict__.update(
 #label_style=self._label_style,
 #compile_options=compile_options,
 #propagate_attrs=self._propagate_attrs,
 #
 #tmt.__dict__.pop("session", None)

        # ensure the ORM context is used to compile the statement, even
        # if it has no ORM entities.  This is so ORM-only things like
        # _legacy_joins are picked up that wouldn't be picked up by the
        # Core statement context
 #f "compile_state_plugin" not in stmt._propagate_attrs:
 #tmt._propagate_attrs = stmt._propagate_attrs.union(
 #"compile_state_plugin": "orm", "plugin_subject": None}
 #

 #eturn stmt

 #ef subquery(
 #elf,
 #ame=None,
 #ith_labels=False,
 #educe_columns=False,
 #:
 #""Return the full SELECT statement represented by
 #his :class:`_query.Query`, embedded within an
 #class:`_expression.Alias`.

 #ager JOIN generation within the query is disabled.

 #param name: string name to be assigned as the alias;
 #his is passed through to :meth:`_expression.FromClause.alias`.
 #f ``None``, a name will be deterministically generated
 #t compile time.

 #param with_labels: if True, :meth:`.with_labels` will be called
 #n the :class:`_query.Query` first to apply table-qualified labels
 #o all columns.

 #param reduce_columns: if True,
 #meth:`_expression.Select.reduce_columns` will
 #e called on the resulting :func:`_expression.select` construct,
 #o remove same-named columns where one also refers to the other
 #ia foreign key or WHERE clause equivalence.

 #""
 # = self.enable_eagerloads(False)
 #f with_labels:
 # = q.set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)

 # = q.statement

 #f reduce_columns:
 # = q.reduce_columns()
 #eturn q.alias(name=name)

 #ef cte(self, name=None, recursive=False):
 #"""Return the full SELECT statement represented by this
 #class:`_query.Query` represented as a common table expression (CTE).

 #arameters and usage are the same as those of the
 #meth:`_expression.SelectBase.cte` method; see that method for
 #urther details.

 #ere is the `PostgreSQL WITH
 #ECURSIVE example
 #https://www.postgresql.org/docs/8.4/static/queries-with.html>`_.
 #ote that, in this example, the ``included_parts`` cte and the
 #`incl_alias`` alias of it are Core selectables, which
 #eans the columns are accessed via the ``.c.`` attribute.  The
 #`parts_alias`` object is an :func:`_orm.aliased` instance of the
 #`Part`` entity, so column-mapped attributes are available
 #irectly::

 #rom sqlalchemy.orm import aliased

 #lass Part(Base):
 #_tablename__ = 'part'
 #art = Column(String, primary_key=True)
 #ub_part = Column(String, primary_key=True)
 #uantity = Column(Integer)

 #ncluded_parts = session.query(
 #art.sub_part,
 #art.part,
 #art.quantity).\
 #ilter(Part.part=="our part").\
 #te(name="included_parts", recursive=True)

 #ncl_alias = aliased(included_parts, name="pr")
 #arts_alias = aliased(Part, name="p")
 #ncluded_parts = included_parts.union_all(
 #ession.query(
 #arts_alias.sub_part,
 #arts_alias.part,
 #arts_alias.quantity).\
 #ilter(parts_alias.part==incl_alias.c.sub_part)
 #

 # = session.query(
 #ncluded_parts.c.sub_part,
 #unc.sum(included_parts.c.quantity).
 #abel('total_quantity')
 #.\
 #roup_by(included_parts.c.sub_part)

 #. seealso::

 #meth:`_expression.HasCTE.cte`

 #""
 #eturn self.enable_eagerloads(False).statement.cte(
 #ame=name, recursive=recursive
 #

 #ef label(self, name):
 #""Return the full SELECT statement represented by this
 #class:`_query.Query`, converted
 #o a scalar subquery with a label of the given name.

 #nalogous to :meth:`sqlalchemy.sql.expression.SelectBase.label`.

 #""

 #eturn self.enable_eagerloads(False).statement.label(name)

 #util.deprecated(
 #1.4",
 #The :meth:`_query.Query.as_scalar` method is deprecated and will be "
 #removed in a future release.  Please refer to "
 #:meth:`_query.Query.scalar_subquery`.",
 #
 #ef as_scalar(self):
 #""Return the full SELECT statement represented by this
 #class:`_query.Query`, converted to a scalar subquery.

 #""
 #eturn self.scalar_subquery()

 #ef scalar_subquery(self):
 #""Return the full SELECT statement represented by this
 #class:`_query.Query`, converted to a scalar subquery.

 #nalogous to
 #meth:`sqlalchemy.sql.expression.SelectBase.scalar_subquery`.

 #. versionchanged:: 1.4 The :meth:`_query.Query.scalar_subquery`
 #ethod replaces the :meth:`_query.Query.as_scalar` method.

 #""

 #eturn self.enable_eagerloads(False).statement.scalar_subquery()

 #property
 #ef selectable(self):
 #""Return the :class:`_expression.Select` object emitted by this
 #class:`_query.Query`.

 #sed for :func:`_sa.inspect` compatibility, this is equivalent to::

 #uery.enable_eagerloads(False).with_labels().statement

 #""
 #eturn self.__clause_element__()

 #ef __clause_element__(self):
 #eturn (
 #elf._with_compile_options(
 #enable_eagerloads=False, _render_for_subquery=True
 #
 #set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
 #statement
 #

 #_generative
 #ef only_return_tuples(self, value):
 #""When set to True, the query results will always be a tuple.

 #his is specifically for single element queries. The default is False.

 #. versionadded:: 1.2.5

 #. seealso::

 #meth:`_query.Query.is_single_entity`

 #""
 #elf.load_options += dict(_only_return_tuples=value)

 #property
 #ef is_single_entity(self):
 #""Indicates if this :class:`_query.Query`
 #eturns tuples or single entities.

 #eturns True if this query returns a single entity for each instance
 #n its result list, and False if this query returns a tuple of entities
 #or each result.

 #. versionadded:: 1.3.11

 #. seealso::

 #meth:`_query.Query.only_return_tuples`

 #""
 #eturn (
 #ot self.load_options._only_return_tuples
 #nd len(self._raw_columns) == 1
 #nd "parententity" in self._raw_columns[0]._annotations
 #nd isinstance(
 #elf._raw_columns[0]._annotations["parententity"],
 #RMColumnsClauseRole,
 #
 #

 #_generative
 #ef enable_eagerloads(self, value):
 #""Control whether or not eager joins and subqueries are
 #endered.

 #hen set to False, the returned Query will not render
 #ager joins regardless of :func:`~sqlalchemy.orm.joinedload`,
 #func:`~sqlalchemy.orm.subqueryload` options
 #r mapper-level ``lazy='joined'``/``lazy='subquery'``
 #onfigurations.

 #his is used primarily when nesting the Query's
 #tatement into a subquery or other
 #electable, or when using :meth:`_query.Query.yield_per`.

 #""
 #elf._compile_options += {"_enable_eagerloads": value}

 #_generative
 #ef _with_compile_options(self, **opt):
 #elf._compile_options += opt

 #util.deprecated_20(
 #:meth:`_orm.Query.with_labels` and :meth:`_orm.Query.apply_labels`",
 #lternative="Use set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL) "
 #instead.",
 #
 #ef with_labels(self):
 #eturn self.set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)

 #pply_labels = with_labels

 #property
 #ef get_label_style(self):
 #""
 #etrieve the current label style.

 #. versionadded:: 1.4

 #""
 #eturn self._label_style

 #ef set_label_style(self, style):
 #""Apply column labels to the return value of Query.statement.

 #ndicates that this Query's `statement` accessor should return
 # SELECT statement that applies labels to all columns in the
 #orm <tablename>_<columnname>; this is commonly used to
 #isambiguate columns from multiple tables which have the same
 #ame.

 #hen the `Query` actually issues SQL to load rows, it always
 #ses column labeling.

 #. note:: The :meth:`_query.Query.set_label_style` method *only* applies
 #he output of :attr:`_query.Query.statement`, and *not* to any of
 #he result-row invoking systems of :class:`_query.Query` itself,
 #.g.
 #meth:`_query.Query.first`, :meth:`_query.Query.all`, etc.
 #o execute
 # query using :meth:`_query.Query.set_label_style`, invoke the
 #attr:`_query.Query.statement` using :meth:`.Session.execute`::

 #esult = session.execute(
 #uery
 #set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
 #statement
 #

 #. versionadded:: 1.4

 #""  # noqa
 #f self._label_style is not style:
 #elf = self._generate()
 #elf._label_style = style
 #eturn self

 #_generative
 #ef enable_assertions(self, value):
 #""Control whether assertions are generated.

 #hen set to False, the returned Query will
 #ot assert its state before certain operations,
 #ncluding that LIMIT/OFFSET has not been applied
 #hen filter() is called, no criterion exists
 #hen get() is called, and no "from_statement()"
 #xists when filter()/order_by()/group_by() etc.
 #s called.  This more permissive mode is used by
 #ustom Query subclasses to specify criterion or
 #ther modifiers outside of the usual usage patterns.

 #are should be taken to ensure that the usage
 #attern is even possible.  A statement applied
 #y from_statement() will override any criterion
 #et by filter() or order_by(), for example.

 #""
 #elf._enable_assertions = value

 #property
 #ef whereclause(self):
 #""A readonly attribute which returns the current WHERE criterion for
 #his Query.

 #his returned value is a SQL expression construct, or ``None`` if no
 #riterion has been established.

 #""
 #eturn sql.elements.BooleanClauseList._construct_for_whereclause(
 #elf._where_criteria
 #

 #_generative
 #ef _with_current_path(self, path):
 #""indicate that this query applies to objects loaded
 #ithin a certain path.

 #sed by deferred loaders (see strategies.py) which transfer
 #uery options from an originating query to a newly generated
 #uery intended for the deferred load.

 #""
 #elf._compile_options += {"_current_path": path}

 #_generative
 #_assertions(_no_clauseelement_condition)
 #util.deprecated_20(
 #:meth:`_orm.Query.with_polymorphic`",
 #lternative="Use the orm.with_polymorphic() standalone function",
 #
 #ef with_polymorphic(
 #elf, cls_or_mappers, selectable=None, polymorphic_on=None
 #:
 #""Load columns for inheriting classes.

 #his is a legacy method which is replaced by the
 #func:`_orm.with_polymorphic` function.

 #. warning:: The :meth:`_orm.Query.with_polymorphic` method does
 #*not** support 1.4/2.0 style features including
 #func:`_orm.with_loader_criteria`.  Please migrate code
 #o use :func:`_orm.with_polymorphic`.

 #meth:`_query.Query.with_polymorphic` applies transformations
 #o the "main" mapped class represented by this :class:`_query.Query`.
 #he "main" mapped class here means the :class:`_query.Query`
 #bject's first argument is a full class, i.e.
 #`session.query(SomeClass)``. These transformations allow additional
 #ables to be present in the FROM clause so that columns for a
 #oined-inheritance subclass are available in the query, both for the
 #urposes of load-time efficiency as well as the ability to use
 #hese columns at query time.

 #. seealso::

 #ref:`with_polymorphic` - illustrates current patterns

 #""

 #ntity = _legacy_filter_by_entity_zero(self)

 #p = with_polymorphic(
 #ntity,
 #ls_or_mappers,
 #electable=selectable,
 #olymorphic_on=polymorphic_on,
 #

 #elf._compile_options = self._compile_options.add_to_element(
 #_with_polymorphic_adapt_map", ((entity, inspect(wp)),)
 #

 #_generative
 #ef yield_per(self, count):
 #"""Yield only ``count`` rows at a time.

 #he purpose of this method is when fetching very large result sets
 #> 10K rows), to batch results in sub-collections and yield them
 #ut partially, so that the Python interpreter doesn't need to declare
 #ery large areas of memory which is both time consuming and leads
 #o excessive memory use.   The performance from fetching hundreds of
 #housands of rows can often double when a suitable yield-per setting
 #e.g. approximately 1000) is used, even with DBAPIs that buffer
 #ows (which are most).

 #s of SQLAlchemy 1.4, the :meth:`_orm.Query.yield_per` method is
 #quivalent to using the ``yield_per`` execution option at the ORM
 #evel. See the section :ref:`orm_queryguide_yield_per` for further
 #ackground on this option.

 #""
 #elf.load_options += {"_yield_per": count}

 #util.deprecated_20(
 #:meth:`_orm.Query.get`",
 #lternative="The method is now available as :meth:`_orm.Session.get`",
 #ecomes_legacy=True,
 #
 #ef get(self, ident):
 #""Return an instance based on the given primary key identifier,
 #r ``None`` if not found.

 #.g.::

 #y_user = session.query(User).get(5)

 #ome_object = session.query(VersionedFoo).get((5, 10))

 #ome_object = session.query(VersionedFoo).get(
 #"id": 5, "version_id": 10})

 #meth:`_query.Query.get` is special in that it provides direct
 #ccess to the identity map of the owning :class:`.Session`.
 #f the given primary key identifier is present
 #n the local identity map, the object is returned
 #irectly from this collection and no SQL is emitted,
 #nless the object has been marked fully expired.
 #f not present,
 # SELECT is performed in order to locate the object.

 #meth:`_query.Query.get` also will perform a check if
 #he object is present in the identity map and
 #arked as expired - a SELECT
 #s emitted to refresh the object as well as to
 #nsure that the row is still present.
 #f not, :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised.

 #meth:`_query.Query.get` is only used to return a single
 #apped instance, not multiple instances or
 #ndividual column constructs, and strictly
 #n a single primary key value.  The originating
 #class:`_query.Query` must be constructed in this way,
 #.e. against a single mapped entity,
 #ith no additional filtering criterion.  Loading
 #ptions via :meth:`_query.Query.options` may be applied
 #owever, and will be used if the object is not
 #et locally present.

 #param ident: A scalar, tuple, or dictionary representing the
 #rimary key.  For a composite (e.g. multiple column) primary key,
 # tuple or dictionary should be passed.

 #or a single-column primary key, the scalar calling form is typically
 #he most expedient.  If the primary key of a row is the value "5",
 #he call looks like::

 #y_object = query.get(5)

 #he tuple form contains primary key values typically in
 #he order in which they correspond to the mapped
 #class:`_schema.Table`
 #bject's primary key columns, or if the
 #paramref:`_orm.Mapper.primary_key` configuration parameter were
 #sed, in
 #he order used for that parameter. For example, if the primary key
 #f a row is represented by the integer
 #igits "5, 10" the call would look like::

 #y_object = query.get((5, 10))

 #he dictionary form should include as keys the mapped attribute names
 #orresponding to each element of the primary key.  If the mapped class
 #as the attributes ``id``, ``version_id`` as the attributes which
 #tore the object's primary key value, the call would look like::

 #y_object = query.get({"id": 5, "version_id": 10})

 #. versionadded:: 1.3 the :meth:`_query.Query.get`
 #ethod now optionally
 #ccepts a dictionary of attribute names to values in order to
 #ndicate a primary key identifier.


 #return: The object instance, or ``None``.

 #""
 #elf._no_criterion_assertion("get", order_by=False, distinct=False)

        # we still implement _get_impl() so that baked query can override
        # it
 #eturn self._get_impl(ident, loading.load_on_pk_identity)

 #ef _get_impl(self, primary_key_identity, db_load_fn, identity_token=None):
 #apper = self._only_full_mapper_zero("get")
 #eturn self.session._get_impl(
 #apper,
 #rimary_key_identity,
 #b_load_fn,
 #opulate_existing=self.load_options._populate_existing,
 #ith_for_update=self._for_update_arg,
 #ptions=self._with_options,
 #dentity_token=identity_token,
 #xecution_options=self._execution_options,
 #

 #property
 #ef lazy_loaded_from(self):
 #""An :class:`.InstanceState` that is using this :class:`_query.Query`
 #or a lazy load operation.

 #. deprecated:: 1.4  This attribute should be viewed via the
 #attr:`.ORMExecuteState.lazy_loaded_from` attribute, within
 #he context of the :meth:`.SessionEvents.do_orm_execute`
 #vent.

 #. seealso::

 #attr:`.ORMExecuteState.lazy_loaded_from`

 #""
 #eturn self.load_options._lazy_loaded_from

 #property
 #ef _current_path(self):
 #eturn self._compile_options._current_path

 #_generative
 #ef correlate(self, *fromclauses):
 #""Return a :class:`.Query` construct which will correlate the given
 #ROM clauses to that of an enclosing :class:`.Query` or
 #func:`~.expression.select`.

 #he method here accepts mapped classes, :func:`.aliased` constructs,
 #nd :func:`.mapper` constructs as arguments, which are resolved into
 #xpression constructs, in addition to appropriate expression
 #onstructs.

 #he correlation arguments are ultimately passed to
 #meth:`_expression.Select.correlate`
 #fter coercion to expression constructs.

 #he correlation arguments take effect in such cases
 #s when :meth:`_query.Query.from_self` is used, or when
 # subquery as returned by :meth:`_query.Query.subquery` is
 #mbedded in another :func:`_expression.select` construct.

 #""

 #elf._auto_correlate = False
 #f fromclauses and fromclauses[0] in {None, False}:
 #elf._correlate = ()
 #lse:
 #elf._correlate = set(self._correlate).union(
 #oercions.expect(roles.FromClauseRole, f) for f in fromclauses
 #

 #_generative
 #ef autoflush(self, setting):
 #""Return a Query with a specific 'autoflush' setting.

 #s of SQLAlchemy 1.4, the :meth:`_orm.Query.autoflush` method
 #s equivalent to using the ``autoflush`` execution option at the
 #RM level. See the section :ref:`orm_queryguide_autoflush` for
 #urther background on this option.

 #""
 #elf.load_options += {"_autoflush": setting}

 #_generative
 #ef populate_existing(self):
 #""Return a :class:`_query.Query`
 #hat will expire and refresh all instances
 #s they are loaded, or reused from the current :class:`.Session`.

 #s of SQLAlchemy 1.4, the :meth:`_orm.Query.populate_existing` method
 #s equivalent to using the ``populate_existing`` execution option at
 #he ORM level. See the section :ref:`orm_queryguide_populate_existing`
 #or further background on this option.

 #""
 #elf.load_options += {"_populate_existing": True}

 #_generative
 #ef _with_invoke_all_eagers(self, value):
 #""Set the 'invoke all eagers' flag which causes joined- and
 #ubquery loaders to traverse into already-loaded related objects
 #nd collections.

 #efault is that of :attr:`_query.Query._invoke_all_eagers`.

 #""
 #elf.load_options += {"_invoke_all_eagers": value}

 #util.deprecated_20(
 #:meth:`_orm.Query.with_parent`",
 #lternative="Use the :func:`_orm.with_parent` standalone construct.",
 #ecomes_legacy=True,
 #
 #util.preload_module("sqlalchemy.orm.relationships")
 #ef with_parent(self, instance, property=None, from_entity=None):  # noqa
 #""Add filtering criterion that relates the given instance
 #o a child object or collection, using its attribute state
 #s well as an established :func:`_orm.relationship()`
 #onfiguration.

 #he method uses the :func:`.with_parent` function to generate
 #he clause, the result of which is passed to
 #meth:`_query.Query.filter`.

 #arameters are the same as :func:`.with_parent`, with the exception
 #hat the given property can be None, in which case a search is
 #erformed against this :class:`_query.Query` object's target mapper.

 #param instance:
 #n instance which has some :func:`_orm.relationship`.

 #param property:
 #tring property name, or class-bound attribute, which indicates
 #hat relationship from the instance should be used to reconcile the
 #arent/child relationship.

 #param from_entity:
 #ntity in which to consider as the left side.  This defaults to the
 #zero" entity of the :class:`_query.Query` itself.

 #""
 #elationships = util.preloaded.orm_relationships

 #f from_entity:
 #ntity_zero = inspect(from_entity)
 #lse:
 #ntity_zero = _legacy_filter_by_entity_zero(self)
 #f property is None:
            # TODO: deprecate, property has to be supplied
 #apper = object_mapper(instance)

 #or prop in mapper.iterate_properties:
 #f (
 #sinstance(prop, relationships.RelationshipProperty)
 #nd prop.mapper is entity_zero.mapper
 #:
 #roperty = prop  # noqa
 #reak
 #lse:
 #aise sa_exc.InvalidRequestError(
 #Could not locate a property which relates instances "
 #of class '%s' to instances of class '%s'"
 # (
 #ntity_zero.mapper.class_.__name__,
 #nstance.__class__.__name__,
 #
 #

 #eturn self.filter(with_parent(instance, property, entity_zero.entity))

 #_generative
 #ef add_entity(self, entity, alias=None):
 #""add a mapped entity to the list of result columns
 #o be returned."""

 #f alias is not None:
            # TODO: deprecate
 #ntity = aliased(entity, alias)

 #elf._raw_columns = list(self._raw_columns)

 #elf._raw_columns.append(
 #oercions.expect(
 #oles.ColumnsClauseRole, entity, apply_propagate_attrs=self
 #
 #

 #_generative
 #ef with_session(self, session):
 #""Return a :class:`_query.Query` that will use the given
 #class:`.Session`.

 #hile the :class:`_query.Query`
 #bject is normally instantiated using the
 #meth:`.Session.query` method, it is legal to build the
 #class:`_query.Query`
 #irectly without necessarily using a :class:`.Session`.  Such a
 #class:`_query.Query` object, or any :class:`_query.Query`
 #lready associated
 #ith a different :class:`.Session`, can produce a new
 #class:`_query.Query`
 #bject associated with a target session using this method::

 #rom sqlalchemy.orm import Query

 #uery = Query([MyClass]).filter(MyClass.id == 5)

 #esult = query.with_session(my_session).one()

 #""

 #elf.session = session

 #util.deprecated_20(
 #:meth:`_query.Query.from_self`",
 #lternative="The new approach is to use the :func:`.orm.aliased` "
 #construct in conjunction with a subquery.  See the section "
 #:ref:`Selecting from the query itself as a subquery "
 #<migration_20_query_from_self>` in the 2.0 migration notes for an "
 #example.",
 #
 #ef from_self(self, *entities):
 #"""return a Query that selects from this Query's
 #ELECT statement.

 #meth:`_query.Query.from_self` essentially turns the SELECT statement
 #nto a SELECT of itself.  Given a query such as::

 # = session.query(User).filter(User.name.like('e%'))

 #iven the :meth:`_query.Query.from_self` version::

 # = session.query(User).filter(User.name.like('e%')).from_self()

 #his query renders as:

 #. sourcecode:: sql

 #ELECT anon_1.user_id AS anon_1_user_id,
 #non_1.user_name AS anon_1_user_name
 #ROM (SELECT "user".id AS user_id, "user".name AS user_name
 #ROM "user"
 #HERE "user".name LIKE :name_1) AS anon_1

 #here are lots of cases where :meth:`_query.Query.from_self`
 #ay be useful.
 # simple one is where above, we may want to apply a row LIMIT to
 #he set of user objects we query against, and then apply additional
 #oins against that row-limited set::

 # = session.query(User).filter(User.name.like('e%')).\
 #imit(5).from_self().\
 #oin(User.addresses).filter(Address.email.like('q%'))

 #he above query joins to the ``Address`` entity but only against the
 #irst five results of the ``User`` query:

 #. sourcecode:: sql

 #ELECT anon_1.user_id AS anon_1_user_id,
 #non_1.user_name AS anon_1_user_name
 #ROM (SELECT "user".id AS user_id, "user".name AS user_name
 #ROM "user"
 #HERE "user".name LIKE :name_1
 #IMIT :param_1) AS anon_1
 #OIN address ON anon_1.user_id = address.user_id
 #HERE address.email LIKE :email_1

 #*Automatic Aliasing**

 #nother key behavior of :meth:`_query.Query.from_self`
 #s that it applies
 #*automatic aliasing** to the entities inside the subquery, when
 #hey are referenced on the outside.  Above, if we continue to
 #efer to the ``User`` entity without any additional aliasing applied
 #o it, those references will be in terms of the subquery::

 # = session.query(User).filter(User.name.like('e%')).\
 #imit(5).from_self().\
 #oin(User.addresses).filter(Address.email.like('q%')).\
 #rder_by(User.name)

 #he ORDER BY against ``User.name`` is aliased to be in terms of the
 #nner subquery:

 #. sourcecode:: sql

 #ELECT anon_1.user_id AS anon_1_user_id,
 #non_1.user_name AS anon_1_user_name
 #ROM (SELECT "user".id AS user_id, "user".name AS user_name
 #ROM "user"
 #HERE "user".name LIKE :name_1
 #IMIT :param_1) AS anon_1
 #OIN address ON anon_1.user_id = address.user_id
 #HERE address.email LIKE :email_1 ORDER BY anon_1.user_name

 #he automatic aliasing feature only works in a **limited** way,
 #or simple filters and orderings.   More ambitious constructions
 #uch as referring to the entity in joins should prefer to use
 #xplicit subquery objects, typically making use of the
 #meth:`_query.Query.subquery`
 #ethod to produce an explicit subquery object.
 #lways test the structure of queries by viewing the SQL to ensure
 # particular structure does what's expected!

 #*Changing the Entities**

 #meth:`_query.Query.from_self`
 #lso includes the ability to modify what
 #olumns are being queried.   In our example, we want ``User.id``
 #o be queried by the inner query, so that we can join to the
 #`Address`` entity on the outside, but we only wanted the outer
 #uery to return the ``Address.email`` column::

 # = session.query(User).filter(User.name.like('e%')).\
 #imit(5).from_self(Address.email).\
 #oin(User.addresses).filter(Address.email.like('q%'))

 #ielding:

 #. sourcecode:: sql

 #ELECT address.email AS address_email
 #ROM (SELECT "user".id AS user_id, "user".name AS user_name
 #ROM "user"
 #HERE "user".name LIKE :name_1
 #IMIT :param_1) AS anon_1
 #OIN address ON anon_1.user_id = address.user_id
 #HERE address.email LIKE :email_1

 #*Looking out for Inner / Outer Columns**

 #eep in mind that when referring to columns that originate from
 #nside the subquery, we need to ensure they are present in the
 #olumns clause of the subquery itself; this is an ordinary aspect of
 #QL.  For example, if we wanted to load from a joined entity inside
 #he subquery using :func:`.contains_eager`, we need to add those
 #olumns.   Below illustrates a join of ``Address`` to ``User``,
 #hen a subquery, and then we'd like :func:`.contains_eager` to access
 #he ``User`` columns::

 # = session.query(Address).join(Address.user).\
 #ilter(User.name.like('e%'))

 # = q.add_entity(User).from_self().\
 #ptions(contains_eager(Address.user))

 #e use :meth:`_query.Query.add_entity` above **before** we call
 #meth:`_query.Query.from_self`
 #o that the ``User`` columns are present
 #n the inner subquery, so that they are available to the
 #func:`.contains_eager` modifier we are using on the outside,
 #roducing:

 #. sourcecode:: sql

 #ELECT anon_1.address_id AS anon_1_address_id,
 #non_1.address_email AS anon_1_address_email,
 #non_1.address_user_id AS anon_1_address_user_id,
 #non_1.user_id AS anon_1_user_id,
 #non_1.user_name AS anon_1_user_name
 #ROM (
 #ELECT address.id AS address_id,
 #ddress.email AS address_email,
 #ddress.user_id AS address_user_id,
 #user".id AS user_id,
 #user".name AS user_name
 #ROM address JOIN "user" ON "user".id = address.user_id
 #HERE "user".name LIKE :name_1) AS anon_1

 #f we didn't call ``add_entity(User)``, but still asked
 #func:`.contains_eager` to load the ``User`` entity, it would be
 #orced to add the table on the outside without the correct
 #oin criteria - note the ``anon1, "user"`` phrase at
 #he end:

 #. sourcecode:: sql

 #- incorrect query
 #ELECT anon_1.address_id AS anon_1_address_id,
 #non_1.address_email AS anon_1_address_email,
 #non_1.address_user_id AS anon_1_address_user_id,
 #user".id AS user_id,
 #user".name AS user_name
 #ROM (
 #ELECT address.id AS address_id,
 #ddress.email AS address_email,
 #ddress.user_id AS address_user_id
 #ROM address JOIN "user" ON "user".id = address.user_id
 #HERE "user".name LIKE :name_1) AS anon_1, "user"

 #param \*entities: optional list of entities which will replace
 #hose being selected.

 #""
 #eturn self._from_self(*entities)

 #ef _from_self(self, *entities):
 #romclause = (
 #elf.set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
 #correlate(None)
 #subquery()
 #_anonymous_fromclause()
 #

 # = self._from_selectable(fromclause)

 #f entities:
 #._set_entities(entities)
 #eturn q

 #_generative
 #ef _set_enable_single_crit(self, val):
 #elf._compile_options += {"_enable_single_crit": val}

 #_generative
 #ef _from_selectable(self, fromclause, set_entity_from=True):
 #or attr in (
 #_where_criteria",
 #_order_by_clauses",
 #_group_by_clauses",
 #_limit_clause",
 #_offset_clause",
 #_last_joined_entity",
 #_legacy_setup_joins",
 #_memoized_select_entities",
 #_distinct",
 #_distinct_on",
 #_having_criteria",
 #_prefixes",
 #_suffixes",
 #:
 #elf.__dict__.pop(attr, None)
 #elf._set_select_from([fromclause], set_entity_from)
 #elf._compile_options += {
 #_enable_single_crit": False,
 #

        # this enables clause adaptation for non-ORM
        # expressions.
        # legacy.  see test/orm/test_froms.py for various
        # "oldstyle" tests that rely on this and the corresponding
        # "newtyle" that do not.
 #elf._compile_options += {"_orm_only_from_obj_alias": False}

 #util.deprecated(
 #1.4",
 #:meth:`_query.Query.values` "
 #is deprecated and will be removed in a "
 #future release.  Please use :meth:`_query.Query.with_entities`",
 #
 #ef values(self, *columns):
 #""Return an iterator yielding result tuples corresponding
 #o the given list of columns

 #""

 #f not columns:
 #eturn iter(())
 # = self._clone().enable_eagerloads(False)
 #._set_entities(columns)
 #f not q.load_options._yield_per:
 #.load_options += {"_yield_per": 10}
 #eturn iter(q)

 #values = values

 #util.deprecated(
 #1.4",
 #:meth:`_query.Query.value` "
 #is deprecated and will be removed in a "
 #future release.  Please use :meth:`_query.Query.with_entities` "
 #in combination with :meth:`_query.Query.scalar`",
 #
 #ef value(self, column):
 #""Return a scalar result corresponding to the given
 #olumn expression.

 #""
 #ry:
 #eturn next(self.values(column))[0]
 #xcept StopIteration:
 #eturn None

 #_generative
 #ef with_entities(self, *entities):
 #"""Return a new :class:`_query.Query`
 #eplacing the SELECT list with the
 #iven entities.

 #.g.::

            # Users, filtered on some arbitrary criterion
            # and then ordered by related email address
 # = session.query(User).\
 #oin(User.address).\
 #ilter(User.name.like('%ed%')).\
 #rder_by(Address.email)

            # given *only* User.id==5, Address.email, and 'q', what
            # would the *next* User in the result be ?
 #ubq = q.with_entities(Address.email).\
 #rder_by(None).\
 #ilter(User.id==5).\
 #ubquery()
 # = q.join((subq, subq.c.email < Address.email)).\
 #imit(1)

 #""
 #MemoizedSelectEntities._generate_for_statement(self)
 #elf._set_entities(entities)

 #_generative
 #ef add_columns(self, *column):
 #""Add one or more column expressions to the list
 #f result columns to be returned."""

 #elf._raw_columns = list(self._raw_columns)

 #elf._raw_columns.extend(
 #oercions.expect(
 #oles.ColumnsClauseRole,
 #,
 #pply_propagate_attrs=self,
 #ost_inspect=True,
 #
 #or c in column
 #

 #util.deprecated(
 #1.4",
 #:meth:`_query.Query.add_column` "
 #is deprecated and will be removed in a "
 #future release.  Please use :meth:`_query.Query.add_columns`",
 #
 #ef add_column(self, column):
 #""Add a column expression to the list of result columns to be
 #eturned.

 #""
 #eturn self.add_columns(column)

 #_generative
 #ef options(self, *args):
 #""Return a new :class:`_query.Query` object,
 #pplying the given list of
 #apper options.

 #ost supplied options regard changing how column- and
 #elationship-mapped attributes are loaded.

 #. seealso::

 #ref:`deferred_options`

 #ref:`relationship_loader_options`

 #""

 #pts = tuple(util.flatten_iterator(args))
 #f self._compile_options._current_path:
 #or opt in opts:
 #f opt._is_legacy_option:
 #pt.process_query_conditionally(self)
 #lse:
 #or opt in opts:
 #f opt._is_legacy_option:
 #pt.process_query(self)

 #elf._with_options += opts

 #ef with_transformation(self, fn):
 #""Return a new :class:`_query.Query` object transformed by
 #he given function.

 #.g.::

 #ef filter_something(criterion):
 #ef transform(q):
 #eturn q.filter(criterion)
 #eturn transform

 # = q.with_transformation(filter_something(x==5))

 #his allows ad-hoc recipes to be created for :class:`_query.Query`
 #bjects.  See the example at :ref:`hybrid_transformers`.

 #""
 #eturn fn(self)

 #ef get_execution_options(self):
 #""Get the non-SQL options which will take effect during execution.

 #. versionadded:: 1.3

 #. seealso::

 #meth:`_query.Query.execution_options`
 #""
 #eturn self._execution_options

 #_generative
 #ef execution_options(self, **kwargs):
 #""Set non-SQL options which take effect during execution.

 #ptions allowed here include all of those accepted by
 #meth:`_engine.Connection.execution_options`, as well as a series
 #f ORM specific options:

 #`populate_existing=True`` - equivalent to using
 #meth:`_orm.Query.populate_existing`

 #`autoflush=True|False`` - equivalent to using
 #meth:`_orm.Query.autoflush`

 #`yield_per=<value>`` - equivalent to using
 #meth:`_orm.Query.yield_per`

 #ote that the ``stream_results`` execution option is enabled
 #utomatically if the :meth:`~sqlalchemy.orm.query.Query.yield_per()`
 #ethod or execution option is used.

 #he execution options may also be specified on a per execution basis
 #hen using :term:`2.0 style` queries via the
 #paramref:`_orm.Session.execution_options` parameter.

 #. versionadded:: 1.4 - added ORM options to
 #meth:`_orm.Query.execution_options`

 #. seealso::

 #ref:`engine_stream_results`

 #meth:`_query.Query.get_execution_options`

 #""
 #elf._execution_options = self._execution_options.union(kwargs)

 #_generative
 #ef with_for_update(
 #elf,
 #ead=False,
 #owait=False,
 #f=None,
 #kip_locked=False,
 #ey_share=False,
 #:
 #""return a new :class:`_query.Query`
 #ith the specified options for the
 #`FOR UPDATE`` clause.

 #he behavior of this method is identical to that of
 #meth:`_expression.GenerativeSelect.with_for_update`.
 #hen called with no arguments,
 #he resulting ``SELECT`` statement will have a ``FOR UPDATE`` clause
 #ppended.  When additional arguments are specified, backend-specific
 #ptions such as ``FOR UPDATE NOWAIT`` or ``LOCK IN SHARE MODE``
 #an take effect.

 #.g.::

 # = sess.query(User).populate_existing().with_for_update(nowait=True, of=User)

 #he above query on a PostgreSQL backend will render like::

 #ELECT users.id AS users_id FROM users FOR UPDATE OF users NOWAIT

 #. note::  It is generally a good idea to combine the use of the
 #meth:`_orm.Query.populate_existing` method when using the
 #meth:`_orm.Query.with_for_update` method.   The purpose of
 #meth:`_orm.Query.populate_existing` is to force all the data read
 #rom the SELECT to be populated into the ORM objects returned,
 #ven if these objects are already in the :term:`identity map`.

 #. seealso::

 #meth:`_expression.GenerativeSelect.with_for_update`
 # Core level method with
 #ull argument and behavioral description.

 #meth:`_orm.Query.populate_existing` - overwrites attributes of
 #bjects already loaded in the identity map.

 #""  # noqa: E501

 #elf._for_update_arg = ForUpdateArg(
 #ead=read,
 #owait=nowait,
 #f=of,
 #kip_locked=skip_locked,
 #ey_share=key_share,
 #

 #_generative
 #ef params(self, *args, **kwargs):
 #"""Add values for bind parameters which may have been
 #pecified in filter().

 #arameters may be specified using \**kwargs, or optionally a single
 #ictionary as the first positional argument. The reason for both is
 #hat \**kwargs is convenient, however some parameter dictionaries
 #ontain unicode keys in which case \**kwargs cannot be used.

 #""
 #f len(args) == 1:
 #wargs.update(args[0])
 #lif len(args) > 0:
 #aise sa_exc.ArgumentError(
 #params() takes zero or one positional argument, "
 #which is a dictionary."
 #
 #elf._params = self._params.union(kwargs)

 #ef where(self, *criterion):
 #""A synonym for :meth:`.Query.filter`.

 #. versionadded:: 1.4

 #""
 #eturn self.filter(*criterion)

 #_generative
 #_assertions(_no_statement_condition, _no_limit_offset)
 #ef filter(self, *criterion):
 #"""Apply the given filtering criterion to a copy
 #f this :class:`_query.Query`, using SQL expressions.

 #.g.::

 #ession.query(MyClass).filter(MyClass.name == 'some name')

 #ultiple criteria may be specified as comma separated; the effect
 #s that they will be joined together using the :func:`.and_`
 #unction::

 #ession.query(MyClass).\
 #ilter(MyClass.name == 'some name', MyClass.id > 5)

 #he criterion is any SQL expression object applicable to the
 #HERE clause of a select.   String expressions are coerced
 #nto SQL expression constructs via the :func:`_expression.text`
 #onstruct.

 #. seealso::

 #meth:`_query.Query.filter_by` - filter on keyword expressions.

 #""
 #or criterion in list(criterion):
 #riterion = coercions.expect(
 #oles.WhereHavingRole, criterion, apply_propagate_attrs=self
 #

            # legacy vvvvvvvvvvvvvvvvvvvvvvvvvvv
 #f self._aliased_generation:
 #riterion = sql_util._deep_annotate(
 #riterion, {"aliased_generation": self._aliased_generation}
 #
            # legacy ^^^^^^^^^^^^^^^^^^^^^^^^^^^

 #elf._where_criteria += (criterion,)

 #util.memoized_property
 #ef _last_joined_entity(self):
 #f self._legacy_setup_joins:
 #eturn _legacy_determine_last_joined_entity(
 #elf._legacy_setup_joins, self._entity_from_pre_ent_zero()
 #
 #lse:
 #eturn None

 #ef _filter_by_zero(self):
 #f self._legacy_setup_joins:
 #last_joined_entity = self._last_joined_entity
 #f _last_joined_entity is not None:
 #eturn _last_joined_entity

 #f self._from_obj:
 #eturn self._from_obj[0]

 #eturn self._raw_columns[0]

 #ef filter_by(self, **kwargs):
 #"""Apply the given filtering criterion to a copy
 #f this :class:`_query.Query`, using keyword expressions.

 #.g.::

 #ession.query(MyClass).filter_by(name = 'some name')

 #ultiple criteria may be specified as comma separated; the effect
 #s that they will be joined together using the :func:`.and_`
 #unction::

 #ession.query(MyClass).\
 #ilter_by(name = 'some name', id = 5)

 #he keyword expressions are extracted from the primary
 #ntity of the query, or the last entity that was the
 #arget of a call to :meth:`_query.Query.join`.

 #. seealso::

 #meth:`_query.Query.filter` - filter on SQL expressions.

 #""
 #rom_entity = self._filter_by_zero()
 #f from_entity is None:
 #aise sa_exc.InvalidRequestError(
 #Can't use filter_by when the first entity '%s' of a query "
 #is not a mapped class. Please use the filter method instead, "
 #or change the order of the entities in the query"
 # self._query_entity_zero()
 #

 #lauses = [
 #entity_namespace_key(from_entity, key) == value
 #or key, value in kwargs.items()
 #
 #eturn self.filter(*clauses)

 #_generative
 #_assertions(_no_statement_condition, _no_limit_offset)
 #ef order_by(self, *clauses):
 #""Apply one or more ORDER BY criterion to the query and return
 #he newly resulting :class:`_query.Query`.

 #ll existing ORDER BY settings can be suppressed by  passing
 #`None``.

 #. seealso::

 #hese sections describe ORDER BY in terms of :term:`2.0 style`
 #nvocation but apply to :class:`_orm.Query` as well:

 #ref:`tutorial_order_by` - in the :ref:`unified_tutorial`

 #ref:`tutorial_order_by_label` - in the :ref:`unified_tutorial`

 #""

 #f len(clauses) == 1 and (clauses[0] is None or clauses[0] is False):
 #elf._order_by_clauses = ()
 #lse:
 #riterion = tuple(
 #oercions.expect(roles.OrderByRole, clause)
 #or clause in clauses
 #
            # legacy vvvvvvvvvvvvvvvvvvvvvvvvvvv
 #f self._aliased_generation:
 #riterion = tuple(
 #
 #ql_util._deep_annotate(
 #, {"aliased_generation": self._aliased_generation}
 #
 #or o in criterion
 #
 #
            # legacy ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

 #elf._order_by_clauses += criterion

 #_generative
 #_assertions(_no_statement_condition, _no_limit_offset)
 #ef group_by(self, *clauses):
 #""Apply one or more GROUP BY criterion to the query and return
 #he newly resulting :class:`_query.Query`.

 #ll existing GROUP BY settings can be suppressed by
 #assing ``None`` - this will suppress any GROUP BY configured
 #n mappers as well.

 #. seealso::

 #hese sections describe GROUP BY in terms of :term:`2.0 style`
 #nvocation but apply to :class:`_orm.Query` as well:

 #ref:`tutorial_group_by_w_aggregates` - in the
 #ref:`unified_tutorial`

 #ref:`tutorial_order_by_label` - in the :ref:`unified_tutorial`

 #""

 #f len(clauses) == 1 and (clauses[0] is None or clauses[0] is False):
 #elf._group_by_clauses = ()
 #lse:
 #riterion = tuple(
 #oercions.expect(roles.GroupByRole, clause)
 #or clause in clauses
 #
            # legacy vvvvvvvvvvvvvvvvvvvvvvvvvvv
 #f self._aliased_generation:
 #riterion = tuple(
 #
 #ql_util._deep_annotate(
 #, {"aliased_generation": self._aliased_generation}
 #
 #or o in criterion
 #
 #
            # legacy ^^^^^^^^^^^^^^^^^^^^^^^^^^

 #elf._group_by_clauses += criterion

 #_generative
 #_assertions(_no_statement_condition, _no_limit_offset)
 #ef having(self, criterion):
 #"""Apply a HAVING criterion to the query and return the
 #ewly resulting :class:`_query.Query`.

 #meth:`_query.Query.having` is used in conjunction with
 #meth:`_query.Query.group_by`.

 #AVING criterion makes it possible to use filters on aggregate
 #unctions like COUNT, SUM, AVG, MAX, and MIN, eg.::

 # = session.query(User.id).\
 #oin(User.addresses).\
 #roup_by(User.id).\
 #aving(func.count(Address.id) > 2)

 #""

 #elf._having_criteria += (
 #oercions.expect(
 #oles.WhereHavingRole, criterion, apply_propagate_attrs=self
 #,
 #

 #ef _set_op(self, expr_fn, *q):
 #eturn self._from_selectable(expr_fn(*([self] + list(q))).subquery())

 #ef union(self, *q):
 #""Produce a UNION of this Query against one or more queries.

 #.g.::

 #1 = sess.query(SomeClass).filter(SomeClass.foo=='bar')
 #2 = sess.query(SomeClass).filter(SomeClass.bar=='foo')

 #3 = q1.union(q2)

 #he method accepts multiple Query objects so as to control
 #he level of nesting.  A series of ``union()`` calls such as::

 #.union(y).union(z).all()

 #ill nest on each ``union()``, and produces::

 #ELECT * FROM (SELECT * FROM (SELECT * FROM X UNION
 #ELECT * FROM y) UNION SELECT * FROM Z)

 #hereas::

 #.union(y, z).all()

 #roduces::

 #ELECT * FROM (SELECT * FROM X UNION SELECT * FROM y UNION
 #ELECT * FROM Z)

 #ote that many database backends do not allow ORDER BY to
 #e rendered on a query called within UNION, EXCEPT, etc.
 #o disable all ORDER BY clauses including those configured
 #n mappers, issue ``query.order_by(None)`` - the resulting
 #class:`_query.Query` object will not render ORDER BY within
 #ts SELECT statement.

 #""
 #eturn self._set_op(expression.union, *q)

 #ef union_all(self, *q):
 #""Produce a UNION ALL of this Query against one or more queries.

 #orks the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See
 #hat method for usage examples.

 #""
 #eturn self._set_op(expression.union_all, *q)

 #ef intersect(self, *q):
 #""Produce an INTERSECT of this Query against one or more queries.

 #orks the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See
 #hat method for usage examples.

 #""
 #eturn self._set_op(expression.intersect, *q)

 #ef intersect_all(self, *q):
 #""Produce an INTERSECT ALL of this Query against one or more queries.

 #orks the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See
 #hat method for usage examples.

 #""
 #eturn self._set_op(expression.intersect_all, *q)

 #ef except_(self, *q):
 #""Produce an EXCEPT of this Query against one or more queries.

 #orks the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See
 #hat method for usage examples.

 #""
 #eturn self._set_op(expression.except_, *q)

 #ef except_all(self, *q):
 #""Produce an EXCEPT ALL of this Query against one or more queries.

 #orks the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See
 #hat method for usage examples.

 #""
 #eturn self._set_op(expression.except_all, *q)

 #ef _next_aliased_generation(self):
 #f "_aliased_generation_counter" not in self.__dict__:
 #elf._aliased_generation_counter = 0
 #elf._aliased_generation_counter += 1
 #eturn self._aliased_generation_counter

 #_generative
 #_assertions(_no_statement_condition, _no_limit_offset)
 #ef join(self, target, *props, **kwargs):
 #"""Create a SQL JOIN against this :class:`_query.Query`
 #bject's criterion
 #nd apply generatively, returning the newly resulting
 #class:`_query.Query`.

 #*Simple Relationship Joins**

 #onsider a mapping between two classes ``User`` and ``Address``,
 #ith a relationship ``User.addresses`` representing a collection
 #f ``Address`` objects associated with each ``User``.   The most
 #ommon usage of :meth:`_query.Query.join`
 #s to create a JOIN along this
 #elationship, using the ``User.addresses`` attribute as an indicator
 #or how this should occur::

 # = session.query(User).join(User.addresses)

 #here above, the call to :meth:`_query.Query.join` along
 #`User.addresses`` will result in SQL approximately equivalent to::

 #ELECT user.id, user.name
 #ROM user JOIN address ON user.id = address.user_id

 #n the above example we refer to ``User.addresses`` as passed to
 #meth:`_query.Query.join` as the "on clause", that is, it indicates
 #ow the "ON" portion of the JOIN should be constructed.

 #o construct a chain of joins, multiple :meth:`_query.Query.join`
 #alls may be used.  The relationship-bound attribute implies both
 #he left and right side of the join at once::

 # = session.query(User).\
 #oin(User.orders).\
 #oin(Order.items).\
 #oin(Item.keywords)

 #. note:: as seen in the above example, **the order in which each
 #all to the join() method occurs is important**.    Query would not,
 #or example, know how to join correctly if we were to specify
 #`User``, then ``Item``, then ``Order``, in our chain of joins; in
 #uch a case, depending on the arguments passed, it may raise an
 #rror that it doesn't know how to join, or it may produce invalid
 #QL in which case the database will raise an error. In correct
 #ractice, the
 #meth:`_query.Query.join` method is invoked in such a way that lines
 #p with how we would want the JOIN clauses in SQL to be
 #endered, and each call should represent a clear link from what
 #recedes it.

 #*Joins to a Target Entity or Selectable**

 # second form of :meth:`_query.Query.join` allows any mapped entity or
 #ore selectable construct as a target.   In this usage,
 #meth:`_query.Query.join` will attempt to create a JOIN along the
 #atural foreign key relationship between two entities::

 # = session.query(User).join(Address)

 #n the above calling form, :meth:`_query.Query.join` is called upon to
 #reate the "on clause" automatically for us.  This calling form will
 #ltimately raise an error if either there are no foreign keys between
 #he two entities, or if there are multiple foreign key linkages between
 #he target entity and the entity or entities already present on the
 #eft side such that creating a join requires more information.  Note
 #hat when indicating a join to a target without any ON clause, ORM
 #onfigured relationships are not taken into account.

 #*Joins to a Target with an ON Clause**

 #he third calling form allows both the target entity as well
 #s the ON clause to be passed explicitly.    A example that includes
 # SQL expression as the ON clause is as follows::

 # = session.query(User).join(Address, User.id==Address.user_id)

 #he above form may also use a relationship-bound attribute as the
 #N clause as well::

 # = session.query(User).join(Address, User.addresses)

 #he above syntax can be useful for the case where we wish
 #o join to an alias of a particular target entity.  If we wanted
 #o join to ``Address`` twice, it could be achieved using two
 #liases set up using the :func:`~sqlalchemy.orm.aliased` function::

 #1 = aliased(Address)
 #2 = aliased(Address)

 # = session.query(User).\
 #oin(a1, User.addresses).\
 #oin(a2, User.addresses).\
 #ilter(a1.email_address=='ed@foo.com').\
 #ilter(a2.email_address=='ed@bar.com')

 #he relationship-bound calling form can also specify a target entity
 #sing the :meth:`_orm.PropComparator.of_type` method; a query
 #quivalent to the one above would be::

 #1 = aliased(Address)
 #2 = aliased(Address)

 # = session.query(User).\
 #oin(User.addresses.of_type(a1)).\
 #oin(User.addresses.of_type(a2)).\
 #ilter(a1.email_address == 'ed@foo.com').\
 #ilter(a2.email_address == 'ed@bar.com')

 #*Augmenting Built-in ON Clauses**

 #s a substitute for providing a full custom ON condition for an
 #xisting relationship, the :meth:`_orm.PropComparator.and_` function
 #ay be applied to a relationship attribute to augment additional
 #riteria into the ON clause; the additional criteria will be combined
 #ith the default criteria using AND::

 # = session.query(User).join(
 #ser.addresses.and_(Address.email_address != 'foo@bar.com')
 #

 #. versionadded:: 1.4

 #*Joining to Tables and Subqueries**


 #he target of a join may also be any table or SELECT statement,
 #hich may be related to a target entity or not.   Use the
 #ppropriate ``.subquery()`` method in order to make a subquery
 #ut of a query::

 #ubq = session.query(Address).\
 #ilter(Address.email_address == 'ed@foo.com').\
 #ubquery()


 # = session.query(User).join(
 #ubq, User.id == subq.c.user_id
 #

 #oining to a subquery in terms of a specific relationship and/or
 #arget entity may be achieved by linking the subquery to the
 #ntity using :func:`_orm.aliased`::

 #ubq = session.query(Address).\
 #ilter(Address.email_address == 'ed@foo.com').\
 #ubquery()

 #ddress_subq = aliased(Address, subq)

 # = session.query(User).join(
 #ser.addresses.of_type(address_subq)
 #


 #*Controlling what to Join From**

 #n cases where the left side of the current state of
 #class:`_query.Query` is not in line with what we want to join from,
 #he :meth:`_query.Query.select_from` method may be used::

 # = session.query(Address).select_from(User).\
 #oin(User.addresses).\
 #ilter(User.name == 'ed')

 #hich will produce SQL similar to::

 #ELECT address.* FROM user
 #OIN address ON user.id=address.user_id
 #HERE user.name = :name_1

 #*Legacy Features of Query.join()**

 #. deprecated:: 1.4 The following features are deprecated and will
 #e removed in SQLAlchemy 2.0.

 #he :meth:`_query.Query.join` method currently supports several
 #sage patterns and arguments that are considered to be legacy
 #s of SQLAlchemy 1.3.   A deprecation path will follow
 #n the 1.4 series for the following features:


 # Joining on relationship names rather than attributes::

 #ession.query(User).join("addresses")

 #*Why it's legacy**: the string name does not provide enough context
 #or :meth:`_query.Query.join` to always know what is desired,
 #otably in that there is no indication of what the left side
 #f the join should be.  This gives rise to flags like
 #`from_joinpoint`` as well as the ability to place several
 #oin clauses in a single :meth:`_query.Query.join` call
 #hich don't solve the problem fully while also
 #dding new calling styles that are unnecessary and expensive to
 #ccommodate internally.

 #*Modern calling pattern**:  Use the actual relationship,
 #.g. ``User.addresses`` in the above case::

 #ession.query(User).join(User.addresses)

 # Automatic aliasing with the ``aliased=True`` flag::

 #ession.query(Node).join(Node.children, aliased=True).\
 #ilter(Node.name == 'some name')

 #*Why it's legacy**:  the automatic aliasing feature of
 #class:`_query.Query` is intensely complicated, both in its internal
 #mplementation as well as in its observed behavior, and is almost
 #ever used.  It is difficult to know upon inspection where and when
 #ts aliasing of a target entity, ``Node`` in the above case, will be
 #pplied and when it won't, and additionally the feature has to use
 #ery elaborate heuristics to achieve this implicit behavior.

 #*Modern calling pattern**: Use the :func:`_orm.aliased` construct
 #xplicitly::

 #rom sqlalchemy.orm import aliased

 #1 = aliased(Node)

 #ession.query(Node).join(Node.children.of_type(n1)).\
 #ilter(n1.name == 'some name')

 # Multiple joins in one call::

 #ession.query(User).join("orders", "items")

 #ession.query(User).join(User.orders, Order.items)

 #ession.query(User).join(
 #Order, User.orders),
 #Item, Item.order_id == Order.id)
 #

 #ession.query(User).join(Order, Item)

            # ... and several more forms actually

 #*Why it's legacy**: being able to chain multiple ON clauses in one
 #all to :meth:`_query.Query.join` is yet another attempt to solve
 #he problem of being able to specify what entity to join from,
 #nd is the source of a large variety of potential calling patterns
 #hat are internally expensive and complicated to parse and
 #ccommodate.

 #*Modern calling pattern**:  Use relationship-bound attributes
 #r SQL-oriented ON clauses within separate calls, so that
 #ach call to :meth:`_query.Query.join` knows what the left
 #ide should be::

 #ession.query(User).join(User.orders).join(
 #tem, Item.order_id == Order.id)


 #param \*props: Incoming arguments for :meth:`_query.Query.join`,
 #he props collection in modern use should be considered to be a  one
 #r two argument form, either as a single "target" entity or ORM
 #ttribute-bound relationship, or as a target entity plus an "on
 #lause" which  may be a SQL expression or ORM attribute-bound
 #elationship.

 #param isouter=False: If True, the join used will be a left outer join,
 #ust as if the :meth:`_query.Query.outerjoin` method were called.

 #param full=False: render FULL OUTER JOIN; implies ``isouter``.

 #. versionadded:: 1.1

 #param from_joinpoint=False: When using ``aliased=True``, a setting
 #f True here will cause the join to be from the most recent
 #oined target, rather than starting back from the original
 #ROM clauses of the query.

 #. note:: This flag is considered legacy.

 #param aliased=False: If True, indicate that the JOIN target should be
 #nonymously aliased.  Subsequent calls to :meth:`_query.Query.filter`
 #nd similar will adapt the incoming criterion to the target
 #lias, until :meth:`_query.Query.reset_joinpoint` is called.

 #. note:: This flag is considered legacy.

 #. seealso::

 #ref:`ormtutorial_joins` in the ORM tutorial.

 #ref:`inheritance_toplevel` for details on how
 #meth:`_query.Query.join` is used for inheritance relationships.

 #func:`_orm.join` - a standalone ORM-level join function,
 #sed internally by :meth:`_query.Query.join`, which in previous
 #QLAlchemy versions was the primary ORM-level joining interface.

 #""

 #liased, from_joinpoint, isouter, full = (
 #wargs.pop("aliased", False),
 #wargs.pop("from_joinpoint", False),
 #wargs.pop("isouter", False),
 #wargs.pop("full", False),
 #

 #f aliased or from_joinpoint:
 #til.warn_deprecated_20(
 #The ``aliased`` and ``from_joinpoint`` keyword arguments "
 #to Query.join() are deprecated and will be removed "
 #in SQLAlchemy 2.0."
 #

 #f kwargs:
 #aise TypeError(
 #unknown arguments: %s" % ", ".join(sorted(kwargs))
 #

        # legacy vvvvvvvvvvvvvvvvvvvvvvvvvvv
 #f not from_joinpoint:
 #elf._last_joined_entity = None
 #elf._aliased_generation = None
        # legacy ^^^^^^^^^^^^^^^^^^^^^^^^^^^

 #f props:
 #nclause, legacy = props[0], props[1:]
 #lse:
 #nclause = legacy = None

 #f not legacy and onclause is None and not isinstance(target, tuple):
            # non legacy argument form
 #props = [(target,)]
 #lif (
 #ot legacy
 #nd isinstance(
 #arget,
 #
 #xpression.Selectable,
 #ype,
 #liasedClass,
 #ypes.FunctionType,
 #,
 #
 #nd isinstance(
 #nclause,
 #
 #lements.ColumnElement,
 #tr,
 #nterfaces.PropComparator,
 #ypes.FunctionType,
 #,
 #
 #:
            # non legacy argument form
 #props = [(target, onclause)]
 #lse:
            # legacy forms.   more time consuming :)
 #props = []
 #single = []
 #or prop in (target,) + props:
 #f isinstance(prop, tuple):
 #til.warn_deprecated_20(
 #Query.join() will no longer accept tuples as "
 #arguments in SQLAlchemy 2.0."
 #
 #f _single:
 #props.extend((_s,) for _s in _single)
 #single = []

                    # this checks for an extremely ancient calling form of
                    # reversed tuples.
 #f isinstance(prop[0], (str, interfaces.PropComparator)):
 #rop = (prop[1], prop[0])

 #props.append(prop)
 #lse:
 #single.append(prop)
 #f _single:
 #props.extend((_s,) for _s in _single)

        # legacy vvvvvvvvvvvvvvvvvvvvvvvvvvv
 #f aliased:
 #elf._aliased_generation = self._next_aliased_generation()

 #f self._aliased_generation:
 #props = [
 #
 #rop[0],
 #ql_util._deep_annotate(
 #rop[1],
 #"aliased_generation": self._aliased_generation},
 #
 #f isinstance(prop[1], expression.ClauseElement)
 #lse prop[1],
 #
 #f len(prop) == 2
 #lse prop
 #or prop in _props
 #

        # legacy ^^^^^^^^^^^^^^^^^^^^^^^^^^^

 #oins_to_add = tuple(
 #
 #oercions.expect(
 #oles.JoinTargetRole,
 #rop[0],
 #egacy=True,
 #pply_propagate_attrs=self,
 #,
 #
 #oercions.expect(roles.OnClauseRole, prop[1], legacy=True)
                    #                    if not isinstance(prop[1], str)
                    #                    else prop[1]
 #
 #f len(prop) == 2
 #lse None,
 #one,
 #
 #isouter": isouter,
 #aliased": aliased,
 #from_joinpoint": True if i > 0 else from_joinpoint,
 #full": full,
 #aliased_generation": self._aliased_generation,
 #,
 #
 #or i, prop in enumerate(_props)
 #

 #f len(joins_to_add) > 1:
 #til.warn_deprecated_20(
 #Passing a chain of multiple join conditions to Query.join() "
 #is deprecated and will be removed in SQLAlchemy 2.0. "
 #Please use individual join() calls per relationship."
 #

 #elf._legacy_setup_joins += joins_to_add

 #elf.__dict__.pop("_last_joined_entity", None)

 #ef outerjoin(self, target, *props, **kwargs):
 #""Create a left outer join against this ``Query`` object's criterion
 #nd apply generatively, returning the newly resulting ``Query``.

 #sage is the same as the ``join()`` method.

 #""
 #wargs["isouter"] = True
 #eturn self.join(target, *props, **kwargs)

 #_generative
 #_assertions(_no_statement_condition)
 #ef reset_joinpoint(self):
 #""Return a new :class:`.Query`, where the "join point" has
 #een reset back to the base FROM entities of the query.

 #his method is usually used in conjunction with the
 #`aliased=True`` feature of the :meth:`~.Query.join`
 #ethod.  See the example in :meth:`~.Query.join` for how
 #his is used.

 #""
 #elf._last_joined_entity = None
 #elf._aliased_generation = None

 #_generative
 #_assertions(_no_clauseelement_condition)
 #ef select_from(self, *from_obj):
 #"""Set the FROM clause of this :class:`.Query` explicitly.

 #meth:`.Query.select_from` is often used in conjunction with
 #meth:`.Query.join` in order to control which entity is selected
 #rom on the "left" side of the join.

 #he entity or selectable object here effectively replaces the
 #left edge" of any calls to :meth:`~.Query.join`, when no
 #oinpoint is otherwise established - usually, the default "join
 #oint" is the leftmost entity in the :class:`~.Query` object's
 #ist of entities to be selected.

 # typical example::

 # = session.query(Address).select_from(User).\
 #oin(User.addresses).\
 #ilter(User.name == 'ed')

 #hich produces SQL equivalent to::

 #ELECT address.* FROM user
 #OIN address ON user.id=address.user_id
 #HERE user.name = :name_1

 #param \*from_obj: collection of one or more entities to apply
 #o the FROM clause.  Entities can be mapped classes,
 #class:`.AliasedClass` objects, :class:`.Mapper` objects
 #s well as core :class:`.FromClause` elements like subqueries.

 #. versionchanged:: 0.9
 #his method no longer applies the given FROM object
 #o be the selectable from which matching entities
 #elect from; the :meth:`.select_entity_from` method
 #ow accomplishes this.  See that method for a description
 #f this behavior.

 #. seealso::

 #meth:`~.Query.join`

 #meth:`.Query.select_entity_from`

 #""

 #elf._set_select_from(from_obj, False)

 #util.deprecated_20(
 #:meth:`_orm.Query.select_entity_from`",
 #lternative="Use the :func:`_orm.aliased` construct instead",
 #
 #_generative
 #_assertions(_no_clauseelement_condition)
 #ef select_entity_from(self, from_obj):
 #"""Set the FROM clause of this :class:`_query.Query` to a
 #ore selectable, applying it as a replacement FROM clause
 #or corresponding mapped entities.

 #he :meth:`_query.Query.select_entity_from`
 #ethod supplies an alternative
 #pproach to the use case of applying an :func:`.aliased` construct
 #xplicitly throughout a query.  Instead of referring to the
 #func:`.aliased` construct explicitly,
 #meth:`_query.Query.select_entity_from` automatically *adapts* all
 #ccurrences of the entity to the target selectable.

 #iven a case for :func:`.aliased` such as selecting ``User``
 #bjects from a SELECT statement::

 #elect_stmt = select(User).where(User.id == 7)
 #ser_alias = aliased(User, select_stmt)

 # = session.query(user_alias).\
 #ilter(user_alias.name == 'ed')

 #bove, we apply the ``user_alias`` object explicitly throughout the
 #uery.  When it's not feasible for ``user_alias`` to be referenced
 #xplicitly in many places, :meth:`_query.Query.select_entity_from`
 #ay be
 #sed at the start of the query to adapt the existing ``User`` entity::

 # = session.query(User).\
 #elect_entity_from(select_stmt.subquery()).\
 #ilter(User.name == 'ed')

 #bove, the generated SQL will show that the ``User`` entity is
 #dapted to our statement, even in the case of the WHERE clause:

 #. sourcecode:: sql

 #ELECT anon_1.id AS anon_1_id, anon_1.name AS anon_1_name
 #ROM (SELECT "user".id AS id, "user".name AS name
 #ROM "user"
 #HERE "user".id = :id_1) AS anon_1
 #HERE anon_1.name = :name_1

 #he :meth:`_query.Query.select_entity_from` method is similar to the
 #meth:`_query.Query.select_from` method,
 #n that it sets the FROM clause
 #f the query.  The difference is that it additionally applies
 #daptation to the other parts of the query that refer to the
 #rimary entity.  If above we had used :meth:`_query.Query.select_from`
 #nstead, the SQL generated would have been:

 #. sourcecode:: sql

 #- uses plain select_from(), not select_entity_from()
 #ELECT "user".id AS user_id, "user".name AS user_name
 #ROM "user", (SELECT "user".id AS id, "user".name AS name
 #ROM "user"
 #HERE "user".id = :id_1) AS anon_1
 #HERE "user".name = :name_1

 #o supply textual SQL to the :meth:`_query.Query.select_entity_from`
 #ethod,
 #e can make use of the :func:`_expression.text` construct.  However,
 #he
 #func:`_expression.text`
 #onstruct needs to be aligned with the columns of our
 #ntity, which is achieved by making use of the
 #meth:`_expression.TextClause.columns` method::

 #ext_stmt = text("select id, name from user").columns(
 #ser.id, User.name).subquery()
 # = session.query(User).select_entity_from(text_stmt)

 #meth:`_query.Query.select_entity_from` itself accepts an
 #func:`.aliased`
 #bject, so that the special options of :func:`.aliased` such as
 #paramref:`.aliased.adapt_on_names` may be used within the
 #cope of the :meth:`_query.Query.select_entity_from`
 #ethod's adaptation
 #ervices.  Suppose
 # view ``user_view`` also returns rows from ``user``.    If
 #e reflect this view into a :class:`_schema.Table`, this view has no
 #elationship to the :class:`_schema.Table` to which we are mapped,
 #owever
 #e can use name matching to select from it::

 #ser_view = Table('user_view', metadata,
 #utoload_with=engine)
 #ser_view_alias = aliased(
 #ser, user_view, adapt_on_names=True)
 # = session.query(User).\
 #elect_entity_from(user_view_alias).\
 #rder_by(User.name)

 #. versionchanged:: 1.1.7 The :meth:`_query.Query.select_entity_from`
 #ethod now accepts an :func:`.aliased` object as an alternative
 #o a :class:`_expression.FromClause` object.

 #param from_obj: a :class:`_expression.FromClause`
 #bject that will replace
 #he FROM clause of this :class:`_query.Query`.
 #t also may be an instance
 #f :func:`.aliased`.



 #. seealso::

 #meth:`_query.Query.select_from`

 #""

 #elf._set_select_from([from_obj], True)
 #elf._compile_options += {"_enable_single_crit": False}

 #ef __getitem__(self, item):
 #eturn orm_util._getitem(
 #elf,
 #tem,
 #llow_negative=not self.session or not self.session.future,
 #

 #_generative
 #_assertions(_no_statement_condition)
 #ef slice(self, start, stop):
 #""Computes the "slice" of the :class:`_query.Query` represented by
 #he given indices and returns the resulting :class:`_query.Query`.

 #he start and stop indices behave like the argument to Python's
 #uilt-in :func:`range` function. This method provides an
 #lternative to using ``LIMIT``/``OFFSET`` to get a slice of the
 #uery.

 #or example, ::

 #ession.query(User).order_by(User.id).slice(1, 3)

 #enders as

 #. sourcecode:: sql

 #ELECT users.id AS users_id,
 #sers.name AS users_name
 #ROM users ORDER BY users.id
 #IMIT ? OFFSET ?
 #2, 1)

 #. seealso::

 #meth:`_query.Query.limit`

 #meth:`_query.Query.offset`

 #""

 #elf._limit_clause, self._offset_clause = sql_util._make_slice(
 #elf._limit_clause, self._offset_clause, start, stop
 #

 #_generative
 #_assertions(_no_statement_condition)
 #ef limit(self, limit):
 #""Apply a ``LIMIT`` to the query and return the newly resulting
 #`Query``.

 #""
 #elf._limit_clause = sql_util._offset_or_limit_clause(limit)

 #_generative
 #_assertions(_no_statement_condition)
 #ef offset(self, offset):
 #""Apply an ``OFFSET`` to the query and return the newly resulting
 #`Query``.

 #""
 #elf._offset_clause = sql_util._offset_or_limit_clause(offset)

 #_generative
 #_assertions(_no_statement_condition)
 #ef distinct(self, *expr):
 #"""Apply a ``DISTINCT`` to the query and return the newly resulting
 #`Query``.


 #. note::

 #he ORM-level :meth:`.distinct` call includes logic that will
 #utomatically add columns from the ORDER BY of the query to the
 #olumns clause of the SELECT statement, to satisfy the common need
 #f the database backend that ORDER BY columns be part of the SELECT
 #ist when DISTINCT is used.   These columns *are not* added to the
 #ist of columns actually fetched by the :class:`_query.Query`,
 #owever,
 #o would not affect results. The columns are passed through when
 #sing the :attr:`_query.Query.statement` accessor, however.

 #. deprecated:: 2.0  This logic is deprecated and will be removed
 #n SQLAlchemy 2.0.     See :ref:`migration_20_query_distinct`
 #or a description of this use case in 2.0.

 #param \*expr: optional column expressions.  When present,
 #he PostgreSQL dialect will render a ``DISTINCT ON (<expressions>)``
 #onstruct.

 #. deprecated:: 1.4 Using \*expr in other dialects is deprecated
 #nd will raise :class:`_exc.CompileError` in a future version.

 #""
 #f expr:
 #elf._distinct = True
 #elf._distinct_on = self._distinct_on + tuple(
 #oercions.expect(roles.ByOfRole, e) for e in expr
 #
 #lse:
 #elf._distinct = True

 #ef all(self):
 #""Return the results represented by this :class:`_query.Query`
 #s a list.

 #his results in an execution of the underlying SQL statement.

 #. warning::  The :class:`_query.Query` object,
 #hen asked to return either
 # sequence or iterator that consists of full ORM-mapped entities,
 #ill **deduplicate entries based on primary key**.  See the FAQ for
 #ore details.

 #. seealso::

 #ref:`faq_query_deduplicating`
 #""
 #eturn self._iter().all()

 #_generative
 #_assertions(_no_clauseelement_condition)
 #ef from_statement(self, statement):
 #""Execute the given SELECT statement and return results.

 #his method bypasses all internal statement compilation, and the
 #tatement is executed without modification.

 #he statement is typically either a :func:`_expression.text`
 #r :func:`_expression.select` construct, and should return the set
 #f columns
 #ppropriate to the entity class represented by this
 #class:`_query.Query`.

 #. seealso::

 #ref:`orm_tutorial_literal_sql` - usage examples in the
 #RM tutorial

 #""
 #tatement = coercions.expect(
 #oles.SelectStatementRole, statement, apply_propagate_attrs=self
 #
 #elf._statement = statement

 #ef first(self):
 #""Return the first result of this ``Query`` or
 #one if the result doesn't contain any row.

 #irst() applies a limit of one within the generated SQL, so that
 #nly one primary entity row is generated on the server side
 #note this may consist of multiple result rows if join-loaded
 #ollections are present).

 #alling :meth:`_query.Query.first`
 #esults in an execution of the underlying
 #uery.

 #. seealso::

 #meth:`_query.Query.one`

 #meth:`_query.Query.one_or_none`

 #""
        # replicates limit(1) behavior
 #f self._statement is not None:
 #eturn self._iter().first()
 #lse:
 #eturn self.limit(1)._iter().first()

 #ef one_or_none(self):
 #""Return at most one result or raise an exception.

 #eturns ``None`` if the query selects
 #o rows.  Raises ``sqlalchemy.orm.exc.MultipleResultsFound``
 #f multiple object identities are returned, or if multiple
 #ows are returned for a query that returns only scalar values
 #s opposed to full identity-mapped entities.

 #alling :meth:`_query.Query.one_or_none`
 #esults in an execution of the
 #nderlying query.

 #. versionadded:: 1.0.9

 #dded :meth:`_query.Query.one_or_none`

 #. seealso::

 #meth:`_query.Query.first`

 #meth:`_query.Query.one`

 #""
 #eturn self._iter().one_or_none()

 #ef one(self):
 #""Return exactly one result or raise an exception.

 #aises ``sqlalchemy.orm.exc.NoResultFound`` if the query selects
 #o rows.  Raises ``sqlalchemy.orm.exc.MultipleResultsFound``
 #f multiple object identities are returned, or if multiple
 #ows are returned for a query that returns only scalar values
 #s opposed to full identity-mapped entities.

 #alling :meth:`.one` results in an execution of the underlying query.

 #. seealso::

 #meth:`_query.Query.first`

 #meth:`_query.Query.one_or_none`

 #""
 #eturn self._iter().one()

 #ef scalar(self):
 #""Return the first element of the first result or None
 #f no rows present.  If multiple rows are returned,
 #aises MultipleResultsFound.

 #>> session.query(Item).scalar()
 #Item>
 #>> session.query(Item.id).scalar()
 #
 #>> session.query(Item.id).filter(Item.id < 0).scalar()
 #one
 #>> session.query(Item.id, Item.name).scalar()
 #
 #>> session.query(func.count(Parent.id)).scalar()
 #0

 #his results in an execution of the underlying query.

 #""
        # TODO: not sure why we can't use result.scalar() here
 #ry:
 #et = self.one()
 #f not isinstance(ret, collections_abc.Sequence):
 #eturn ret
 #eturn ret[0]
 #xcept orm_exc.NoResultFound:
 #eturn None

 #ef __iter__(self):
 #eturn self._iter().__iter__()

 #ef _iter(self):
        # new style execution.
 #arams = self._params

 #tatement = self._statement_20()
 #esult = self.session.execute(
 #tatement,
 #arams,
 #xecution_options={"_sa_orm_load_options": self.load_options},
 #

        # legacy: automatically set scalars, unique
 #f result._attributes.get("is_single_entity", False):
 #esult = result.scalars()

 #f (
 #esult._attributes.get("filtered", False)
 #nd not self.load_options._yield_per
 #:
 #esult = result.unique()

 #eturn result

 #ef __str__(self):
 #tatement = self._statement_20()

 #ry:
 #ind = (
 #elf._get_bind_args(statement, self.session.get_bind)
 #f self.session
 #lse None
 #
 #xcept sa_exc.UnboundExecutionError:
 #ind = None

 #eturn str(statement.compile(bind))

 #ef _get_bind_args(self, statement, fn, **kw):
 #eturn fn(clause=statement, **kw)

 #property
 #ef column_descriptions(self):
 #""Return metadata about the columns which would be
 #eturned by this :class:`_query.Query`.

 #ormat is a list of dictionaries::

 #ser_alias = aliased(User, name='user2')
 # = sess.query(User, User.id, user_alias)

            # this expression:
 #.column_descriptions

            # would return:
 #
 #
 #name':'User',
 #type':User,
 #aliased':False,
 #expr':User,
 #entity': User
 #,
 #
 #name':'id',
 #type':Integer(),
 #aliased':False,
 #expr':User.id,
 #entity': User
 #,
 #
 #name':'user2',
 #type':User,
 #aliased':True,
 #expr':user_alias,
 #entity': user_alias
 #
 #

 #""

 #eturn _column_descriptions(self, legacy=True)

 #ef instances(self, result_proxy, context=None):
 #""Return an ORM result given a :class:`_engine.CursorResult` and
 #class:`.QueryContext`.

 #""
 #f context is None:
 #til.warn_deprecated(
 #Using the Query.instances() method without a context "
 #is deprecated and will be disallowed in a future release.  "
 #Please make use of :meth:`_query.Query.from_statement` "
 #for linking ORM results to arbitrary select constructs.",
 #ersion="1.4",
 #
 #ompile_state = self._compile_state(for_statement=False)

 #ontext = QueryContext(
 #ompile_state,
 #ompile_state.statement,
 #elf._params,
 #elf.session,
 #elf.load_options,
 #

 #esult = loading.instances(result_proxy, context)

        # legacy: automatically set scalars, unique
 #f result._attributes.get("is_single_entity", False):
 #esult = result.scalars()

 #f result._attributes.get("filtered", False):
 #esult = result.unique()

 #eturn result

 #ef merge_result(self, iterator, load=True):
 #""Merge a result into this :class:`_query.Query` object's Session.

 #iven an iterator returned by a :class:`_query.Query`
 #f the same structure
 #s this one, return an identical iterator of results, with all mapped
 #nstances merged into the session using :meth:`.Session.merge`. This
 #s an optimized method which will merge all mapped instances,
 #reserving the structure of the result rows and unmapped columns with
 #ess method overhead than that of calling :meth:`.Session.merge`
 #xplicitly for each value.

 #he structure of the results is determined based on the column list of
 #his :class:`_query.Query` - if these do not correspond,
 #nchecked errors
 #ill occur.

 #he 'load' argument is the same as that of :meth:`.Session.merge`.

 #or an example of how :meth:`_query.Query.merge_result` is used, see
 #he source code for the example :ref:`examples_caching`, where
 #meth:`_query.Query.merge_result` is used to efficiently restore state
 #rom a cache back into a target :class:`.Session`.

 #""

 #eturn loading.merge_result(self, iterator, load)

 #ef exists(self):
 #""A convenience method that turns a query into an EXISTS subquery
 #f the form EXISTS (SELECT 1 FROM ... WHERE ...).

 #.g.::

 # = session.query(User).filter(User.name == 'fred')
 #ession.query(q.exists())

 #roducing SQL similar to::

 #ELECT EXISTS (
 #ELECT 1 FROM users WHERE users.name = :name_1
 # AS anon_1

 #he EXISTS construct is usually used in the WHERE clause::

 #ession.query(User.id).filter(q.exists()).scalar()

 #ote that some databases such as SQL Server don't allow an
 #XISTS expression to be present in the columns clause of a
 #ELECT.    To select a simple boolean value based on the exists
 #s a WHERE, use :func:`.literal`::

 #rom sqlalchemy import literal

 #ession.query(literal(True)).filter(q.exists()).scalar()

 #""

        # .add_columns() for the case that we are a query().select_from(X),
        # so that ".statement" can be produced (#2995) but also without
        # omitting the FROM clause from a query(X) (#2818);
        # .with_only_columns() after we have a core select() so that
        # we get just "SELECT 1" without any entities.

 #nner = (
 #elf.enable_eagerloads(False)
 #add_columns(sql.literal_column("1"))
 #set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
 #statement.with_only_columns(1)
 #

 #zero = self._entity_from_pre_ent_zero()
 #f ezero is not None:
 #nner = inner.select_from(ezero)

 #eturn sql.exists(inner)

 #ef count(self):
 #"""Return a count of rows this the SQL formed by this :class:`Query`
 #ould return.

 #his generates the SQL for this Query as follows::

 #ELECT count(1) AS count_1 FROM (
 #ELECT <rest of query follows...>
 # AS anon_1

 #he above SQL returns a single row, which is the aggregate value
 #f the count function; the :meth:`_query.Query.count`
 #ethod then returns
 #hat single integer value.

 #. warning::

 #t is important to note that the value returned by
 #ount() is **not the same as the number of ORM objects that this
 #uery would return from a method such as the .all() method**.
 #he :class:`_query.Query` object,
 #hen asked to return full entities,
 #ill **deduplicate entries based on primary key**, meaning if the
 #ame primary key value would appear in the results more than once,
 #nly one object of that primary key would be present.  This does
 #ot apply to a query that is against individual columns.

 #. seealso::

 #ref:`faq_query_deduplicating`

 #ref:`orm_tutorial_query_returning`

 #or fine grained control over specific columns to count, to skip the
 #sage of a subquery or otherwise control of the FROM clause, or to use
 #ther aggregate functions, use :attr:`~sqlalchemy.sql.expression.func`
 #xpressions in conjunction with :meth:`~.Session.query`, i.e.::

 #rom sqlalchemy import func

            # count User records, without
            # using a subquery.
 #ession.query(func.count(User.id))

            # return count of user "id" grouped
            # by "name"
 #ession.query(func.count(User.id)).\
 #roup_by(User.name)

 #rom sqlalchemy import distinct

            # count distinct "name" values
 #ession.query(func.count(distinct(User.name)))

 #""
 #ol = sql.func.count(sql.literal_column("*"))
 #eturn self._from_self(col).enable_eagerloads(False).scalar()

 #ef delete(self, synchronize_session="evaluate"):
 #"""Perform a DELETE with an arbitrary WHERE clause.

 #eletes rows matched by this query from the database.

 #.g.::

 #ess.query(User).filter(User.age == 25).\
 #elete(synchronize_session=False)

 #ess.query(User).filter(User.age == 25).\
 #elete(synchronize_session='evaluate')

 #. warning::

 #ee the section :ref:`orm_expression_update_delete` for important
 #aveats and warnings, including limitations when using bulk UPDATE
 #nd DELETE with mapper inheritance configurations.

 #param synchronize_session: chooses the strategy to update the
 #ttributes on objects in the session.   See the section
 #ref:`orm_expression_update_delete` for a discussion of these
 #trategies.

 #return: the count of rows matched as returned by the database's
 #row count" feature.

 #. seealso::

 #ref:`orm_expression_update_delete`

 #""

 #ulk_del = BulkDelete(self)
 #f self.dispatch.before_compile_delete:
 #or fn in self.dispatch.before_compile_delete:
 #ew_query = fn(bulk_del.query, bulk_del)
 #f new_query is not None:
 #ulk_del.query = new_query

 #elf = bulk_del.query

 #elete_ = sql.delete(*self._raw_columns)
 #elete_._where_criteria = self._where_criteria
 #esult = self.session.execute(
 #elete_,
 #elf._params,
 #xecution_options={"synchronize_session": synchronize_session},
 #
 #ulk_del.result = result
 #elf.session.dispatch.after_bulk_delete(bulk_del)
 #esult.close()

 #eturn result.rowcount

 #ef update(self, values, synchronize_session="evaluate", update_args=None):
 #"""Perform an UPDATE with an arbitrary WHERE clause.

 #pdates rows matched by this query in the database.

 #.g.::

 #ess.query(User).filter(User.age == 25).\
 #pdate({User.age: User.age - 10}, synchronize_session=False)

 #ess.query(User).filter(User.age == 25).\
 #pdate({"age": User.age - 10}, synchronize_session='evaluate')

 #. warning::

 #ee the section :ref:`orm_expression_update_delete` for important
 #aveats and warnings, including limitations when using arbitrary
 #PDATE and DELETE with mapper inheritance configurations.

 #param values: a dictionary with attributes names, or alternatively
 #apped attributes or SQL expressions, as keys, and literal
 #alues or sql expressions as values.   If :ref:`parameter-ordered
 #ode <updates_order_parameters>` is desired, the values can be
 #assed as a list of 2-tuples;
 #his requires that the
 #paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order`
 #lag is passed to the :paramref:`.Query.update.update_args` dictionary
 #s well.

 #param synchronize_session: chooses the strategy to update the
 #ttributes on objects in the session.   See the section
 #ref:`orm_expression_update_delete` for a discussion of these
 #trategies.

 #param update_args: Optional dictionary, if present will be passed
 #o the underlying :func:`_expression.update`
 #onstruct as the ``**kw`` for
 #he object.  May be used to pass dialect-specific arguments such
 #s ``mysql_limit``, as well as other special arguments such as
 #paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order`.

 #return: the count of rows matched as returned by the database's
 #row count" feature.


 #. seealso::

 #ref:`orm_expression_update_delete`


 #""

 #pdate_args = update_args or {}

 #ulk_ud = BulkUpdate(self, values, update_args)

 #f self.dispatch.before_compile_update:
 #or fn in self.dispatch.before_compile_update:
 #ew_query = fn(bulk_ud.query, bulk_ud)
 #f new_query is not None:
 #ulk_ud.query = new_query
 #elf = bulk_ud.query

 #pd = sql.update(*self._raw_columns)

 #po = update_args.pop("preserve_parameter_order", False)
 #f ppo:
 #pd = upd.ordered_values(*values)
 #lse:
 #pd = upd.values(values)
 #f update_args:
 #pd = upd.with_dialect_options(**update_args)

 #pd._where_criteria = self._where_criteria
 #esult = self.session.execute(
 #pd,
 #elf._params,
 #xecution_options={"synchronize_session": synchronize_session},
 #
 #ulk_ud.result = result
 #elf.session.dispatch.after_bulk_update(bulk_ud)
 #esult.close()
 #eturn result.rowcount

 #ef _compile_state(self, for_statement=False, **kw):
 #""Create an out-of-compiler ORMCompileState object.

 #he ORMCompileState object is normally created directly as a result
 #f the SQLCompiler.process() method being handed a Select()
 #r FromStatement() object that uses the "orm" plugin.   This method
 #rovides a means of creating this ORMCompileState object directly
 #ithout using the compiler.

 #his method is used only for deprecated cases, which include
 #he .from_self() method for a Query that has multiple levels
 #f .from_self() in use, as well as the instances() method.  It is
 #lso used within the test suite to generate ORMCompileState objects
 #or test purposes.

 #""

 #tmt = self._statement_20(for_statement=for_statement, **kw)
 #ssert for_statement == stmt._compile_options._for_statement

        # this chooses between ORMFromStatementCompileState and
        # ORMSelectCompileState.  We could also base this on
        # query._statement is not None as we have the ORM Query here
        # however this is the more general path.
 #ompile_state_cls = ORMCompileState._get_plugin_class_for_plugin(
 #tmt, "orm"
 #

 #eturn compile_state_cls.create_for_statement(stmt, None)

 #ef _compile_context(self, for_statement=False):
 #ompile_state = self._compile_state(for_statement=for_statement)
 #ontext = QueryContext(
 #ompile_state,
 #ompile_state.statement,
 #elf._params,
 #elf.session,
 #elf.load_options,
 #

 #eturn context


class FromStatement(GroupedElement, SelectBase, Executable):
 #""Core construct that represents a load of ORM objects from a finished
 #elect or text construct.

 #""

 #_visit_name__ = "orm_from_statement"

 #compile_options = ORMFromStatementCompileState.default_compile_options

 #compile_state_factory = ORMFromStatementCompileState.create_for_statement

 #for_update_arg = None

 #traverse_internals = [
 #"_raw_columns", InternalTraversal.dp_clauseelement_list),
 #"element", InternalTraversal.dp_clauseelement),
 # + Executable._executable_traverse_internals

 #cache_key_traversal = _traverse_internals + [
 #"_compile_options", InternalTraversal.dp_has_cache_key)
 #

 #ef __init__(self, entities, element):
 #elf._raw_columns = [
 #oercions.expect(
 #oles.ColumnsClauseRole,
 #nt,
 #pply_propagate_attrs=self,
 #ost_inspect=True,
 #
 #or ent in util.to_list(entities)
 #
 #elf.element = element

 #ef get_label_style(self):
 #eturn self._label_style

 #ef set_label_style(self, label_style):
 #eturn SelectStatementGrouping(
 #elf.element.set_label_style(label_style)
 #

 #property
 #ef _label_style(self):
 #eturn self.element._label_style

 #ef _compiler_dispatch(self, compiler, **kw):

 #""provide a fixed _compiler_dispatch method.

 #his is roughly similar to using the sqlalchemy.ext.compiler
 #`@compiles`` extension.

 #""

 #ompile_state = self._compile_state_factory(self, compiler, **kw)

 #oplevel = not compiler.stack

 #f toplevel:
 #ompiler.compile_state = compile_state

 #eturn compiler.process(compile_state.statement, **kw)

 #ef _ensure_disambiguated_names(self):
 #eturn self

 #ef get_children(self, **kw):
 #or elem in itertools.chain.from_iterable(
 #lement._from_objects for element in self._raw_columns
 #:
 #ield elem
 #or elem in super(FromStatement, self).get_children(**kw):
 #ield elem

 #property
 #ef _returning(self):
 #eturn self.element._returning if self.element.is_dml else None

 #property
 #ef _inline(self):
 #eturn self.element._inline if self.element.is_dml else None


class AliasOption(interfaces.LoaderOption):
 #util.deprecated(
 #1.4",
 #The :class:`.AliasOption` is not necessary "
 #for entities to be matched up to a query that is established "
 #via :meth:`.Query.from_statement` and now does nothing.",
 #
 #ef __init__(self, alias):
 #"""Return a :class:`.MapperOption` that will indicate to the
 #class:`_query.Query`
 #hat the main table has been aliased.

 #""

 #ef process_compile_state(self, compile_state):
 #ass


class BulkUD(object):
 #""State used for the orm.Query version of update() / delete().

 #his object is now specific to Query only.

 #""

 #ef __init__(self, query):
 #elf.query = query.enable_eagerloads(False)
 #elf._validate_query_state()
 #elf.mapper = self.query._entity_from_pre_ent_zero()

 #ef _validate_query_state(self):
 #or attr, methname, notset, op in (
 #"_limit_clause", "limit()", None, operator.is_),
 #"_offset_clause", "offset()", None, operator.is_),
 #"_order_by_clauses", "order_by()", (), operator.eq),
 #"_group_by_clauses", "group_by()", (), operator.eq),
 #"_distinct", "distinct()", False, operator.is_),
 #
 #_from_obj",
 #join(), outerjoin(), select_from(), or from_self()",
 #),
 #perator.eq,
 #,
 #
 #_legacy_setup_joins",
 #join(), outerjoin(), select_from(), or from_self()",
 #),
 #perator.eq,
 #,
 #:
 #f not op(getattr(self.query, attr), notset):
 #aise sa_exc.InvalidRequestError(
 #Can't call Query.update() or Query.delete() "
 #when %s has been called" % (methname,)
 #

 #property
 #ef session(self):
 #eturn self.query.session


class BulkUpdate(BulkUD):
 #""BulkUD which handles UPDATEs."""

 #ef __init__(self, query, values, update_kwargs):
 #uper(BulkUpdate, self).__init__(query)
 #elf.values = values
 #elf.update_kwargs = update_kwargs


class BulkDelete(BulkUD):
 #""BulkUD which handles DELETEs."""
