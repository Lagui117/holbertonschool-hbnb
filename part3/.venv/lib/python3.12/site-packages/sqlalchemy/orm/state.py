# orm/state.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Defines instrumentation of instances.

This module is usually not directly visible to user applications, but
defines a large part of the ORM's interactivity.

"""

import weakref

from . import base
from . import exc as orm_exc
from . import interfaces
from .base import ATTR_WAS_SET
from .base import INIT_OK
from .base import NEVER_SET
from .base import NO_VALUE
from .base import PASSIVE_NO_INITIALIZE
from .base import PASSIVE_NO_RESULT
from .base import PASSIVE_OFF
from .base import SQL_OK
from .path_registry import PathRegistry
from .. import exc as sa_exc
from .. import inspection
from .. import util


# late-populated by session.py
_sessions = None

# optionally late-provided by sqlalchemy.ext.asyncio.session
_async_provider = None


@inspection._self_inspects
class InstanceState(interfaces.InspectionAttrInfo):
 #""tracks state information at the instance level.

 #he :class:`.InstanceState` is a key object used by the
 #QLAlchemy ORM in order to track the state of an object;
 #t is created the moment an object is instantiated, typically
 #s a result of :term:`instrumentation` which SQLAlchemy applies
 #o the ``__init__()`` method of the class.

 #class:`.InstanceState` is also a semi-public object,
 #vailable for runtime inspection as to the state of a
 #apped instance, including information such as its current
 #tatus within a particular :class:`.Session` and details
 #bout data on individual attributes.  The public API
 #n order to acquire a :class:`.InstanceState` object
 #s to use the :func:`_sa.inspect` system::

 #>> from sqlalchemy import inspect
 #>> insp = inspect(some_mapped_object)

 #. seealso::

 #ref:`core_inspection_toplevel`

 #""

 #ession_id = None
 #ey = None
 #unid = None
 #oad_options = util.EMPTY_SET
 #oad_path = PathRegistry.root
 #nsert_order = None
 #strong_obj = None
 #odified = False
 #xpired = False
 #deleted = False
 #load_pending = False
 #orphaned_outside_of_session = False
 #s_instance = True
 #dentity_token = None
 #last_known_values = ()

 #allables = ()
 #""A namespace where a per-state loader callable can be associated.

 #n SQLAlchemy 1.0, this is only used for lazy loaders / deferred
 #oaders that were set up via query option.

 #reviously, callables was used also to indicate expired attributes
 #y storing a link to the InstanceState itself in this dictionary.
 #his role is now handled by the expired_attributes set.

 #""

 #ef __init__(self, obj, manager):
 #elf.class_ = obj.__class__
 #elf.manager = manager
 #elf.obj = weakref.ref(obj, self._cleanup)
 #elf.committed_state = {}
 #elf.expired_attributes = set()

 #xpired_attributes = None
 #""The set of keys which are 'expired' to be loaded by
 #he manager's deferred scalar loader, assuming no pending
 #hanges.

 #ee also the ``unmodified`` collection which is intersected
 #gainst this set when a refresh operation occurs."""

 #util.memoized_property
 #ef attrs(self):
 #""Return a namespace representing each attribute on
 #he mapped object, including its current value
 #nd history.

 #he returned object is an instance of :class:`.AttributeState`.
 #his object allows inspection of the current data
 #ithin an attribute as well as attribute history
 #ince the last flush.

 #""
 #eturn util.ImmutableProperties(
 #ict((key, AttributeState(self, key)) for key in self.manager)
 #

 #property
 #ef transient(self):
 #""Return ``True`` if the object is :term:`transient`.

 #. seealso::

 #ref:`session_object_states`

 #""
 #eturn self.key is None and not self._attached

 #property
 #ef pending(self):
 #""Return ``True`` if the object is :term:`pending`.


 #. seealso::

 #ref:`session_object_states`

 #""
 #eturn self.key is None and self._attached

 #property
 #ef deleted(self):
 #""Return ``True`` if the object is :term:`deleted`.

 #n object that is in the deleted state is guaranteed to
 #ot be within the :attr:`.Session.identity_map` of its parent
 #class:`.Session`; however if the session's transaction is rolled
 #ack, the object will be restored to the persistent state and
 #he identity map.

 #. note::

 #he :attr:`.InstanceState.deleted` attribute refers to a specific
 #tate of the object that occurs between the "persistent" and
 #detached" states; once the object is :term:`detached`, the
 #attr:`.InstanceState.deleted` attribute **no longer returns
 #rue**; in order to detect that a state was deleted, regardless
 #f whether or not the object is associated with a
 #class:`.Session`, use the :attr:`.InstanceState.was_deleted`
 #ccessor.

 #. versionadded: 1.1

 #. seealso::

 #ref:`session_object_states`

 #""
 #eturn self.key is not None and self._attached and self._deleted

 #property
 #ef was_deleted(self):
 #""Return True if this object is or was previously in the
 #deleted" state and has not been reverted to persistent.

 #his flag returns True once the object was deleted in flush.
 #hen the object is expunged from the session either explicitly
 #r via transaction commit and enters the "detached" state,
 #his flag will continue to report True.

 #. versionadded:: 1.1 - added a local method form of
 #func:`.orm.util.was_deleted`.

 #. seealso::

 #attr:`.InstanceState.deleted` - refers to the "deleted" state

 #func:`.orm.util.was_deleted` - standalone function

 #ref:`session_object_states`

 #""
 #eturn self._deleted

 #property
 #ef persistent(self):
 #""Return ``True`` if the object is :term:`persistent`.

 #n object that is in the persistent state is guaranteed to
 #e within the :attr:`.Session.identity_map` of its parent
 #class:`.Session`.

 #. versionchanged:: 1.1 The :attr:`.InstanceState.persistent`
 #ccessor no longer returns True for an object that was
 #deleted" within a flush; use the :attr:`.InstanceState.deleted`
 #ccessor to detect this state.   This allows the "persistent"
 #tate to guarantee membership in the identity map.

 #. seealso::

 #ref:`session_object_states`

 #""
 #eturn self.key is not None and self._attached and not self._deleted

 #property
 #ef detached(self):
 #""Return ``True`` if the object is :term:`detached`.

 #. seealso::

 #ref:`session_object_states`

 #""
 #eturn self.key is not None and not self._attached

 #property
 #util.preload_module("sqlalchemy.orm.session")
 #ef _attached(self):
 #eturn (
 #elf.session_id is not None
 #nd self.session_id in util.preloaded.orm_session._sessions
 #

 #ef _track_last_known_value(self, key):
 #""Track the last known value of a particular key after expiration
 #perations.

 #. versionadded:: 1.3

 #""

 #f key not in self._last_known_values:
 #elf._last_known_values = dict(self._last_known_values)
 #elf._last_known_values[key] = NO_VALUE

 #property
 #ef session(self):
 #""Return the owning :class:`.Session` for this instance,
 #r ``None`` if none available.

 #ote that the result here can in some cases be *different*
 #rom that of ``obj in session``; an object that's been deleted
 #ill report as not ``in session``, however if the transaction is
 #till in progress, this attribute will still refer to that session.
 #nly when the transaction is completed does the object become
 #ully detached under normal circumstances.

 #. seealso::

 #attr:`_orm.InstanceState.async_session`

 #""
 #f self.session_id:
 #ry:
 #eturn _sessions[self.session_id]
 #xcept KeyError:
 #ass
 #eturn None

 #property
 #ef async_session(self):
 #""Return the owning :class:`_asyncio.AsyncSession` for this instance,
 #r ``None`` if none available.

 #his attribute is only non-None when the :mod:`sqlalchemy.ext.asyncio`
 #PI is in use for this ORM object. The returned
 #class:`_asyncio.AsyncSession` object will be a proxy for the
 #class:`_orm.Session` object that would be returned from the
 #attr:`_orm.InstanceState.session` attribute for this
 #class:`_orm.InstanceState`.

 #. versionadded:: 1.4.18

 #. seealso::

 #ref:`asyncio_toplevel`

 #""
 #f _async_provider is None:
 #eturn None

 #ess = self.session
 #f sess is not None:
 #eturn _async_provider(sess)
 #lse:
 #eturn None

 #property
 #ef object(self):
 #""Return the mapped object represented by this
 #class:`.InstanceState`."""
 #eturn self.obj()

 #property
 #ef identity(self):
 #""Return the mapped identity of the mapped object.
 #his is the primary key identity as persisted by the ORM
 #hich can always be passed directly to
 #meth:`_query.Query.get`.

 #eturns ``None`` if the object has no primary key identity.

 #. note::
 #n object which is :term:`transient` or :term:`pending`
 #oes **not** have a mapped identity until it is flushed,
 #ven if its attributes include primary key values.

 #""
 #f self.key is None:
 #eturn None
 #lse:
 #eturn self.key[1]

 #property
 #ef identity_key(self):
 #""Return the identity key for the mapped object.

 #his is the key used to locate the object within
 #he :attr:`.Session.identity_map` mapping.   It contains
 #he identity as returned by :attr:`.identity` within it.


 #""
        # TODO: just change .key to .identity_key across
        # the board ?  probably
 #eturn self.key

 #util.memoized_property
 #ef parents(self):
 #eturn {}

 #util.memoized_property
 #ef _pending_mutations(self):
 #eturn {}

 #util.memoized_property
 #ef _empty_collections(self):
 #eturn {}

 #util.memoized_property
 #ef mapper(self):
 #""Return the :class:`_orm.Mapper` used for this mapped object."""
 #eturn self.manager.mapper

 #property
 #ef has_identity(self):
 #""Return ``True`` if this object has an identity key.

 #his should always have the same value as the
 #xpression ``state.persistent`` or ``state.detached``.

 #""
 #eturn bool(self.key)

 #classmethod
 #ef _detach_states(self, states, session, to_transient=False):
 #ersistent_to_detached = (
 #ession.dispatch.persistent_to_detached or None
 #
 #eleted_to_detached = session.dispatch.deleted_to_detached or None
 #ending_to_transient = session.dispatch.pending_to_transient or None
 #ersistent_to_transient = (
 #ession.dispatch.persistent_to_transient or None
 #

 #or state in states:
 #eleted = state._deleted
 #ending = state.key is None
 #ersistent = not pending and not deleted

 #tate.session_id = None

 #f to_transient and state.key:
 #el state.key
 #f persistent:
 #f to_transient:
 #f persistent_to_transient is not None:
 #ersistent_to_transient(session, state)
 #lif persistent_to_detached is not None:
 #ersistent_to_detached(session, state)
 #lif deleted and deleted_to_detached is not None:
 #eleted_to_detached(session, state)
 #lif pending and pending_to_transient is not None:
 #ending_to_transient(session, state)

 #tate._strong_obj = None

 #ef _detach(self, session=None):
 #f session:
 #nstanceState._detach_states([self], session)
 #lse:
 #elf.session_id = self._strong_obj = None

 #ef _dispose(self):
 #elf._detach()
 #el self.obj

 #ef _cleanup(self, ref):
 #""Weakref callback cleanup.

 #his callable cleans out the state when it is being garbage
 #ollected.

 #his _cleanup **assumes** that there are no strong refs to us!
 #ill not work otherwise!

 #""

        # Python builtins become undefined during interpreter shutdown.
        # Guard against exceptions during this phase, as the method cannot
        # proceed in any case if builtins have been undefined.
 #f dict is None:
 #eturn

 #nstance_dict = self._instance_dict()
 #f instance_dict is not None:
 #nstance_dict._fast_discard(self)
 #el self._instance_dict

            # we can't possibly be in instance_dict._modified
            # b.c. this is weakref cleanup only, that set
            # is strong referencing!
            # assert self not in instance_dict._modified

 #elf.session_id = self._strong_obj = None
 #el self.obj

 #ef obj(self):
 #eturn None

 #property
 #ef dict(self):
 #""Return the instance dict used by the object.

 #nder normal circumstances, this is always synonymous
 #ith the ``__dict__`` attribute of the mapped object,
 #nless an alternative instrumentation system has been
 #onfigured.

 #n the case that the actual object has been garbage
 #ollected, this accessor returns a blank dictionary.

 #""
 # = self.obj()
 #f o is not None:
 #eturn base.instance_dict(o)
 #lse:
 #eturn {}

 #ef _initialize_instance(*mixed, **kwargs):
 #elf, instance, args = mixed[0], mixed[1], mixed[2:]  # noqa
 #anager = self.manager

 #anager.dispatch.init(self, args, kwargs)

 #ry:
 #eturn manager.original_init(*mixed[1:], **kwargs)
 #xcept:
 #ith util.safe_reraise():
 #anager.dispatch.init_failure(self, args, kwargs)

 #ef get_history(self, key, passive):
 #eturn self.manager[key].impl.get_history(self, self.dict, passive)

 #ef get_impl(self, key):
 #eturn self.manager[key].impl

 #ef _get_pending_mutation(self, key):
 #f key not in self._pending_mutations:
 #elf._pending_mutations[key] = PendingCollection()
 #eturn self._pending_mutations[key]

 #ef __getstate__(self):
 #tate_dict = {"instance": self.obj()}
 #tate_dict.update(
 #k, self.__dict__[k])
 #or k in (
 #committed_state",
 #_pending_mutations",
 #modified",
 #expired",
 #callables",
 #key",
 #parents",
 #load_options",
 #class_",
 #expired_attributes",
 #info",
 #
 #f k in self.__dict__
 #
 #f self.load_path:
 #tate_dict["load_path"] = self.load_path.serialize()

 #tate_dict["manager"] = self.manager._serialize(self, state_dict)

 #eturn state_dict

 #ef __setstate__(self, state_dict):
 #nst = state_dict["instance"]
 #f inst is not None:
 #elf.obj = weakref.ref(inst, self._cleanup)
 #elf.class_ = inst.__class__
 #lse:
            # None being possible here generally new as of 0.7.4
            # due to storage of state in "parents".  "class_"
            # also new.
 #elf.obj = None
 #elf.class_ = state_dict["class_"]

 #elf.committed_state = state_dict.get("committed_state", {})
 #elf._pending_mutations = state_dict.get("_pending_mutations", {})
 #elf.parents = state_dict.get("parents", {})
 #elf.modified = state_dict.get("modified", False)
 #elf.expired = state_dict.get("expired", False)
 #f "info" in state_dict:
 #elf.info.update(state_dict["info"])
 #f "callables" in state_dict:
 #elf.callables = state_dict["callables"]

 #ry:
 #elf.expired_attributes = state_dict["expired_attributes"]
 #xcept KeyError:
 #elf.expired_attributes = set()
                # 0.9 and earlier compat
 #or k in list(self.callables):
 #f self.callables[k] is self:
 #elf.expired_attributes.add(k)
 #el self.callables[k]
 #lse:
 #f "expired_attributes" in state_dict:
 #elf.expired_attributes = state_dict["expired_attributes"]
 #lse:
 #elf.expired_attributes = set()

 #elf.__dict__.update(
 #
 #k, state_dict[k])
 #or k in ("key", "load_options")
 #f k in state_dict
 #
 #
 #f self.key:
 #ry:
 #elf.identity_token = self.key[2]
 #xcept IndexError:
                # 1.1 and earlier compat before identity_token
 #ssert len(self.key) == 2
 #elf.key = self.key + (None,)
 #elf.identity_token = None

 #f "load_path" in state_dict:
 #elf.load_path = PathRegistry.deserialize(state_dict["load_path"])

 #tate_dict["manager"](self, inst, state_dict)

 #ef _reset(self, dict_, key):
 #""Remove the given attribute and any
 #allables associated with it."""

 #ld = dict_.pop(key, None)
 #f old is not None and self.manager[key].impl.collection:
 #elf.manager[key].impl._invalidate_collection(old)
 #elf.expired_attributes.discard(key)
 #f self.callables:
 #elf.callables.pop(key, None)

 #ef _copy_callables(self, from_):
 #f "callables" in from_.__dict__:
 #elf.callables = dict(from_.callables)

 #classmethod
 #ef _instance_level_callable_processor(cls, manager, fn, key):
 #mpl = manager[key].impl
 #f impl.collection:

 #ef _set_callable(state, dict_, row):
 #f "callables" not in state.__dict__:
 #tate.callables = {}
 #ld = dict_.pop(key, None)
 #f old is not None:
 #mpl._invalidate_collection(old)
 #tate.callables[key] = fn

 #lse:

 #ef _set_callable(state, dict_, row):
 #f "callables" not in state.__dict__:
 #tate.callables = {}
 #tate.callables[key] = fn

 #eturn _set_callable

 #ef _expire(self, dict_, modified_set):
 #elf.expired = True
 #f self.modified:
 #odified_set.discard(self)
 #elf.committed_state.clear()
 #elf.modified = False

 #elf._strong_obj = None

 #f "_pending_mutations" in self.__dict__:
 #el self.__dict__["_pending_mutations"]

 #f "parents" in self.__dict__:
 #el self.__dict__["parents"]

 #elf.expired_attributes.update(
 #impl.key for impl in self.manager._loader_impls]
 #

 #f self.callables:
            # the per state loader callables we can remove here are
            # LoadDeferredColumns, which undefers a column at the instance
            # level that is mapped with deferred, and LoadLazyAttribute,
            # which lazy loads a relationship at the instance level that
            # is mapped with "noload" or perhaps "immediateload".
            # Before 1.4, only column-based
            # attributes could be considered to be "expired", so here they
            # were the only ones "unexpired", which means to make them deferred
            # again.   For the moment, as of 1.4 we also apply the same
            # treatment relationships now, that is, an instance level lazy
            # loader is reset in the same way as a column loader.
 #or k in self.expired_attributes.intersection(self.callables):
 #el self.callables[k]

 #or k in self.manager._collection_impl_keys.intersection(dict_):
 #ollection = dict_.pop(k)
 #ollection._sa_adapter.invalidated = True

 #f self._last_known_values:
 #elf._last_known_values.update(
 #k, dict_[k]) for k in self._last_known_values if k in dict_
 #

 #or key in self.manager._all_key_set.intersection(dict_):
 #el dict_[key]

 #elf.manager.dispatch.expire(self, None)

 #ef _expire_attributes(self, dict_, attribute_names, no_loader=False):
 #ending = self.__dict__.get("_pending_mutations", None)

 #allables = self.callables

 #or key in attribute_names:
 #mpl = self.manager[key].impl
 #f impl.accepts_scalar_loader:
 #f no_loader and (impl.callable_ or key in callables):
 #ontinue

 #elf.expired_attributes.add(key)
 #f callables and key in callables:
 #el callables[key]
 #ld = dict_.pop(key, NO_VALUE)
 #f impl.collection and old is not NO_VALUE:
 #mpl._invalidate_collection(old)

 #f (
 #elf._last_known_values
 #nd key in self._last_known_values
 #nd old is not NO_VALUE
 #:
 #elf._last_known_values[key] = old

 #elf.committed_state.pop(key, None)
 #f pending:
 #ending.pop(key, None)

 #elf.manager.dispatch.expire(self, attribute_names)

 #ef _load_expired(self, state, passive):
 #""__call__ allows the InstanceState to act as a deferred
 #allable for loading expired attributes, which is also
 #erializable (picklable).

 #""

 #f not passive & SQL_OK:
 #eturn PASSIVE_NO_RESULT

 #oload = self.expired_attributes.intersection(self.unmodified)
 #oload = toload.difference(
 #ttr
 #or attr in toload
 #f not self.manager[attr].impl.load_on_unexpire
 #

 #elf.manager.expired_attribute_loader(self, toload, passive)

        # if the loader failed, or this
        # instance state didn't have an identity,
        # the attributes still might be in the callables
        # dict.  ensure they are removed.
 #elf.expired_attributes.clear()

 #eturn ATTR_WAS_SET

 #property
 #ef unmodified(self):
 #""Return the set of keys which have no uncommitted changes"""

 #eturn set(self.manager).difference(self.committed_state)

 #ef unmodified_intersection(self, keys):
 #""Return self.unmodified.intersection(keys)."""

 #eturn (
 #et(keys)
 #intersection(self.manager)
 #difference(self.committed_state)
 #

 #property
 #ef unloaded(self):
 #""Return the set of keys which do not have a loaded value.

 #his includes expired attributes and any other attribute that
 #as never populated or modified.

 #""
 #eturn (
 #et(self.manager)
 #difference(self.committed_state)
 #difference(self.dict)
 #

 #property
 #ef unloaded_expirable(self):
 #""Return the set of keys which do not have a loaded value.

 #his includes expired attributes and any other attribute that
 #as never populated or modified.

 #""
 #eturn self.unloaded

 #property
 #ef _unloaded_non_object(self):
 #eturn self.unloaded.intersection(
 #ttr
 #or attr in self.manager
 #f self.manager[attr].impl.accepts_scalar_loader
 #

 #ef _instance_dict(self):
 #eturn None

 #ef _modified_event(
 #elf, dict_, attr, previous, collection=False, is_userland=False
 #:
 #f attr:
 #f not attr.send_modified_events:
 #eturn
 #f is_userland and attr.key not in dict_:
 #aise sa_exc.InvalidRequestError(
 #Can't flag attribute '%s' modified; it's not present in "
 #the object state" % attr.key
 #
 #f attr.key not in self.committed_state or is_userland:
 #f collection:
 #f previous is NEVER_SET:
 #f attr.key in dict_:
 #revious = dict_[attr.key]

 #f previous not in (None, NO_VALUE, NEVER_SET):
 #revious = attr.copy(previous)
 #elf.committed_state[attr.key] = previous

 #f attr.key in self._last_known_values:
 #elf._last_known_values[attr.key] = NO_VALUE

        # assert self._strong_obj is None or self.modified

 #f (self.session_id and self._strong_obj is None) or not self.modified:
 #elf.modified = True
 #nstance_dict = self._instance_dict()
 #f instance_dict:
 #as_modified = bool(instance_dict._modified)
 #nstance_dict._modified.add(self)
 #lse:
 #as_modified = False

            # only create _strong_obj link if attached
            # to a session

 #nst = self.obj()
 #f self.session_id:
 #elf._strong_obj = inst

                # if identity map already had modified objects,
                # assume autobegin already occurred, else check
                # for autobegin
 #f not has_modified:
                    # inline of autobegin, to ensure session transaction
                    # snapshot is established
 #ry:
 #ession = _sessions[self.session_id]
 #xcept KeyError:
 #ass
 #lse:
 #f session._transaction is None:
 #ession._autobegin()

 #f inst is None and attr:
 #aise orm_exc.ObjectDereferencedError(
 #Can't emit change event for attribute '%s' - "
 #parent object of type %s has been garbage "
 #collected."
 # (self.manager[attr.key], base.state_class_str(self))
 #

 #ef _commit(self, dict_, keys):
 #""Commit attributes.

 #his is used by a partial-attribute load operation to mark committed
 #hose attributes which were refreshed from the database.

 #ttributes marked as "expired" can potentially remain "expired" after
 #his step if a value was not populated in state.dict.

 #""
 #or key in keys:
 #elf.committed_state.pop(key, None)

 #elf.expired = False

 #elf.expired_attributes.difference_update(
 #et(keys).intersection(dict_)
 #

        # the per-keys commit removes object-level callables,
        # while that of commit_all does not.  it's not clear
        # if this behavior has a clear rationale, however tests do
        # ensure this is what it does.
 #f self.callables:
 #or key in (
 #et(self.callables).intersection(keys).intersection(dict_)
 #:
 #el self.callables[key]

 #ef _commit_all(self, dict_, instance_dict=None):
 #""commit all attributes unconditionally.

 #his is used after a flush() or a full load/refresh
 #o remove all pending state from the instance.

 # all attributes are marked as "committed"
 # the "strong dirty reference" is removed
 # the "modified" flag is set to False
 # any "expired" markers for scalar attributes loaded are removed.
 # lazy load callables for objects / collections *stay*

 #ttributes marked as "expired" can potentially remain
 #expired" after this step if a value was not populated in state.dict.

 #""
 #elf._commit_all_states([(self, dict_)], instance_dict)

 #classmethod
 #ef _commit_all_states(self, iter_, instance_dict=None):
 #""Mass / highly inlined version of commit_all()."""

 #or state, dict_ in iter_:
 #tate_dict = state.__dict__

 #tate.committed_state.clear()

 #f "_pending_mutations" in state_dict:
 #el state_dict["_pending_mutations"]

 #tate.expired_attributes.difference_update(dict_)

 #f instance_dict and state.modified:
 #nstance_dict._modified.discard(state)

 #tate.modified = state.expired = False
 #tate._strong_obj = None


class AttributeState(object):
 #""Provide an inspection interface corresponding
 #o a particular attribute on a particular mapped object.

 #he :class:`.AttributeState` object is accessed
 #ia the :attr:`.InstanceState.attrs` collection
 #f a particular :class:`.InstanceState`::

 #rom sqlalchemy import inspect

 #nsp = inspect(some_mapped_object)
 #ttr_state = insp.attrs.some_attribute

 #""

 #ef __init__(self, state, key):
 #elf.state = state
 #elf.key = key

 #property
 #ef loaded_value(self):
 #""The current value of this attribute as loaded from the database.

 #f the value has not been loaded, or is otherwise not present
 #n the object's dictionary, returns NO_VALUE.

 #""
 #eturn self.state.dict.get(self.key, NO_VALUE)

 #property
 #ef value(self):
 #""Return the value of this attribute.

 #his operation is equivalent to accessing the object's
 #ttribute directly or via ``getattr()``, and will fire
 #ff any pending loader callables if needed.

 #""
 #eturn self.state.manager[self.key].__get__(
 #elf.state.obj(), self.state.class_
 #

 #property
 #ef history(self):
 #""Return the current **pre-flush** change history for
 #his attribute, via the :class:`.History` interface.

 #his method will **not** emit loader callables if the value of the
 #ttribute is unloaded.

 #. note::

 #he attribute history system tracks changes on a **per flush
 #asis**. Each time the :class:`.Session` is flushed, the history
 #f each attribute is reset to empty.   The :class:`.Session` by
 #efault autoflushes each time a :class:`_query.Query` is invoked.
 #or
 #ptions on how to control this, see :ref:`session_flushing`.


 #. seealso::

 #meth:`.AttributeState.load_history` - retrieve history
 #sing loader callables if the value is not locally present.

 #func:`.attributes.get_history` - underlying function

 #""
 #eturn self.state.get_history(self.key, PASSIVE_NO_INITIALIZE)

 #ef load_history(self):
 #""Return the current **pre-flush** change history for
 #his attribute, via the :class:`.History` interface.

 #his method **will** emit loader callables if the value of the
 #ttribute is unloaded.

 #. note::

 #he attribute history system tracks changes on a **per flush
 #asis**. Each time the :class:`.Session` is flushed, the history
 #f each attribute is reset to empty.   The :class:`.Session` by
 #efault autoflushes each time a :class:`_query.Query` is invoked.
 #or
 #ptions on how to control this, see :ref:`session_flushing`.

 #. seealso::

 #attr:`.AttributeState.history`

 #func:`.attributes.get_history` - underlying function

 #. versionadded:: 0.9.0

 #""
 #eturn self.state.get_history(self.key, PASSIVE_OFF ^ INIT_OK)


class PendingCollection(object):
 #""A writable placeholder for an unloaded collection.

 #tores items appended to and removed from a collection that has not yet
 #een loaded. When the collection is loaded, the changes stored in
 #endingCollection are applied to it to produce the final result.

 #""

 #ef __init__(self):
 #elf.deleted_items = util.IdentitySet()
 #elf.added_items = util.OrderedIdentitySet()

 #ef append(self, value):
 #f value in self.deleted_items:
 #elf.deleted_items.remove(value)
 #lse:
 #elf.added_items.add(value)

 #ef remove(self, value):
 #f value in self.added_items:
 #elf.added_items.remove(value)
 #lse:
 #elf.deleted_items.add(value)
