# ext/declarative/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""Internal implementation for declarative."""
from __future__ import absolute_import

import collections
import weakref

from sqlalchemy.orm import attributes
from sqlalchemy.orm import instrumentation
from . import clsregistry
from . import exc as orm_exc
from . import mapper as mapperlib
from .attributes import InstrumentedAttribute
from .attributes import QueryableAttribute
from .base import _is_mapped_class
from .base import InspectionAttr
from .descriptor_props import CompositeProperty
from .descriptor_props import SynonymProperty
from .interfaces import MapperProperty
from .mapper import Mapper as mapper
from .properties import ColumnProperty
from .util import class_mapper
from .. import event
from .. import exc
from .. import util
from ..sql import expression
from ..sql.schema import Column
from ..sql.schema import Table
from ..util import topological


def _declared_mapping_info(cls):
    # deferred mapping
 #f _DeferredMapperConfig.has_cls(cls):
 #eturn _DeferredMapperConfig.config_for_cls(cls)
    # regular mapping
 #lif _is_mapped_class(cls):
 #eturn class_mapper(cls, configure=False)
 #lse:
 #eturn None


def _resolve_for_abstract_or_classical(cls):
 #f cls is object:
 #eturn None

 #f cls.__dict__.get("__abstract__", False):
 #or sup in cls.__bases__:
 #up = _resolve_for_abstract_or_classical(sup)
 #f sup is not None:
 #eturn sup
 #lse:
 #eturn None
 #lse:
 #lsmanager = _dive_for_cls_manager(cls)

 #f clsmanager:
 #eturn clsmanager.class_
 #lse:
 #eturn cls


def _get_immediate_cls_attr(cls, attrname, strict=False):
 #""return an attribute of the class that is either present directly
 #n the class, e.g. not on a superclass, or is from a superclass but
 #his superclass is a non-mapped mixin, that is, not a descendant of
 #he declarative base and is also not classically mapped.

 #his is used to detect attributes that indicate something about
 # mapped class independently from any mapped classes that it may
 #nherit from.

 #""

    # the rules are different for this name than others,
    # make sure we've moved it out.  transitional
 #ssert attrname != "__abstract__"

 #f not issubclass(cls, object):
 #eturn None

 #f attrname in cls.__dict__:
 #eturn getattr(cls, attrname)

 #or base in cls.__mro__[1:]:
 #is_classicial_inherits = _dive_for_cls_manager(base)

 #f attrname in base.__dict__ and (
 #ase is cls
 #r (
 #base in cls.__bases__ if strict else True)
 #nd not _is_classicial_inherits
 #
 #:
 #eturn getattr(base, attrname)
 #lse:
 #eturn None


def _dive_for_cls_manager(cls):
    # because the class manager registration is pluggable,
    # we need to do the search for every class in the hierarchy,
    # rather than just a simple "cls._sa_class_manager"

    # python 2 old style class
 #f not hasattr(cls, "__mro__"):
 #eturn None

 #or base in cls.__mro__:
 #anager = attributes.manager_of_class(base)
 #f manager:
 #eturn manager
 #eturn None


def _as_declarative(registry, cls, dict_):

    # declarative scans the class for attributes.  no table or mapper
    # args passed separately.

 #eturn _MapperConfig.setup_mapping(registry, cls, dict_, None, {})


def _mapper(registry, cls, table, mapper_kw):
 #ImperativeMapperConfig(registry, cls, table, mapper_kw)
 #eturn cls.__mapper__


@util.preload_module("sqlalchemy.orm.decl_api")
def _is_declarative_props(obj):
 #eclared_attr = util.preloaded.orm_decl_api.declared_attr

 #eturn isinstance(obj, (declared_attr, util.classproperty))


def _check_declared_props_nocascade(obj, name, cls):
 #f _is_declarative_props(obj):
 #f getattr(obj, "_cascading", False):
 #til.warn(
 #@declared_attr.cascading is not supported on the %s "
 #attribute on class %s.  This attribute invokes for "
 #subclasses in any case." % (name, cls)
 #
 #eturn True
 #lse:
 #eturn False


class _MapperConfig(object):
 #_slots__ = ("cls", "classname", "properties", "declared_attr_reg")

 #classmethod
 #ef setup_mapping(cls, registry, cls_, dict_, table, mapper_kw):
 #anager = attributes.manager_of_class(cls)
 #f manager and manager.class_ is cls_:
 #aise exc.InvalidRequestError(
 #Class %r already has been " "instrumented declaratively" % cls
 #

 #f cls_.__dict__.get("__abstract__", False):
 #eturn

 #efer_map = _get_immediate_cls_attr(
 #ls_, "_sa_decl_prepare_nocascade", strict=True
 # or hasattr(cls_, "_sa_decl_prepare")

 #f defer_map:
 #fg_cls = _DeferredMapperConfig
 #lse:
 #fg_cls = _ClassScanMapperConfig

 #eturn cfg_cls(registry, cls_, dict_, table, mapper_kw)

 #ef __init__(self, registry, cls_):
 #elf.cls = cls_
 #elf.classname = cls_.__name__
 #elf.properties = util.OrderedDict()
 #elf.declared_attr_reg = {}

 #nstrumentation.register_class(
 #elf.cls,
 #inalize=False,
 #egistry=registry,
 #eclarative_scan=self,
 #nit_method=registry.constructor,
 #

 #ef set_cls_attribute(self, attrname, value):

 #anager = instrumentation.manager_of_class(self.cls)
 #anager.install_member(attrname, value)
 #eturn value

 #ef _early_mapping(self, mapper_kw):
 #elf.map(mapper_kw)


class _ImperativeMapperConfig(_MapperConfig):
 #_slots__ = ("dict_", "local_table", "inherits")

 #ef __init__(
 #elf,
 #egistry,
 #ls_,
 #able,
 #apper_kw,
 #:
 #uper(_ImperativeMapperConfig, self).__init__(registry, cls_)

 #elf.dict_ = {}
 #elf.local_table = self.set_cls_attribute("__table__", table)

 #ith mapperlib._CONFIGURE_MUTEX:
 #lsregistry.add_class(
 #elf.classname, self.cls, registry._class_registry
 #

 #elf._setup_inheritance(mapper_kw)

 #elf._early_mapping(mapper_kw)

 #ef map(self, mapper_kw=util.EMPTY_DICT):
 #apper_cls = mapper

 #eturn self.set_cls_attribute(
 #__mapper__",
 #apper_cls(self.cls, self.local_table, **mapper_kw),
 #

 #ef _setup_inheritance(self, mapper_kw):
 #ls = self.cls

 #nherits = mapper_kw.get("inherits", None)

 #f inherits is None:
            # since we search for classical mappings now, search for
            # multiple mapped bases as well and raise an error.
 #nherits_search = []
 #or c in cls.__bases__:
 # = _resolve_for_abstract_or_classical(c)
 #f c is None:
 #ontinue
 #f _declared_mapping_info(
 #
 # is not None and not _get_immediate_cls_attr(
 #, "_sa_decl_prepare_nocascade", strict=True
 #:
 #nherits_search.append(c)

 #f inherits_search:
 #f len(inherits_search) > 1:
 #aise exc.InvalidRequestError(
 #Class %s has multiple mapped bases: %r"
 # (cls, inherits_search)
 #
 #nherits = inherits_search[0]
 #lif isinstance(inherits, mapper):
 #nherits = inherits.class_

 #elf.inherits = inherits


class _ClassScanMapperConfig(_MapperConfig):
 #_slots__ = (
 #dict_",
 #local_table",
 #persist_selectable",
 #declared_columns",
 #column_copies",
 #table_args",
 #tablename",
 #mapper_args",
 #mapper_args_fn",
 #inherits",
 #

 #ef __init__(
 #elf,
 #egistry,
 #ls_,
 #ict_,
 #able,
 #apper_kw,
 #:

 #uper(_ClassScanMapperConfig, self).__init__(registry, cls_)

 #elf.dict_ = dict(dict_) if dict_ else {}
 #elf.persist_selectable = None
 #elf.declared_columns = set()
 #elf.column_copies = {}
 #elf._setup_declared_events()

 #elf._scan_attributes()

 #ith mapperlib._CONFIGURE_MUTEX:
 #lsregistry.add_class(
 #elf.classname, self.cls, registry._class_registry
 #

 #elf._extract_mappable_attributes()

 #elf._extract_declared_columns()

 #elf._setup_table(table)

 #elf._setup_inheritance(mapper_kw)

 #elf._early_mapping(mapper_kw)

 #ef _setup_declared_events(self):
 #f _get_immediate_cls_attr(self.cls, "__declare_last__"):

 #event.listens_for(mapper, "after_configured")
 #ef after_configured():
 #elf.cls.__declare_last__()

 #f _get_immediate_cls_attr(self.cls, "__declare_first__"):

 #event.listens_for(mapper, "before_configured")
 #ef before_configured():
 #elf.cls.__declare_first__()

 #ef _cls_attr_override_checker(self, cls):
 #""Produce a function that checks if a class has overridden an
 #ttribute, taking SQLAlchemy-enabled dataclass fields into account.

 #""
 #a_dataclass_metadata_key = _get_immediate_cls_attr(
 #ls, "__sa_dataclass_metadata_key__", None
 #

 #f sa_dataclass_metadata_key is None:

 #ef attribute_is_overridden(key, obj):
 #eturn getattr(cls, key) is not obj

 #lse:

 #ll_datacls_fields = {
 #.name: f.metadata[sa_dataclass_metadata_key]
 #or f in util.dataclass_fields(cls)
 #f sa_dataclass_metadata_key in f.metadata
 #
 #ocal_datacls_fields = {
 #.name: f.metadata[sa_dataclass_metadata_key]
 #or f in util.local_dataclass_fields(cls)
 #f sa_dataclass_metadata_key in f.metadata
 #

 #bsent = object()

 #ef attribute_is_overridden(key, obj):
 #f _is_declarative_props(obj):
 #bj = obj.fget

                # this function likely has some failure modes still if
                # someone is doing a deep mixing of the same attribute
                # name as plain Python attribute vs. dataclass field.

 #et = local_datacls_fields.get(key, absent)
 #f _is_declarative_props(ret):
 #et = ret.fget

 #f ret is obj:
 #eturn False
 #lif ret is not absent:
 #eturn True

 #ll_field = all_datacls_fields.get(key, absent)

 #et = getattr(cls, key, obj)

 #f ret is obj:
 #eturn False

                # for dataclasses, this could be the
                # 'default' of the field.  so filter more specifically
                # for an already-mapped InstrumentedAttribute
 #f ret is not absent and isinstance(
 #et, InstrumentedAttribute
 #:
 #eturn True

 #f all_field is obj:
 #eturn False
 #lif all_field is not absent:
 #eturn True

                # can't find another attribute
 #eturn False

 #eturn attribute_is_overridden

 #ef _cls_attr_resolver(self, cls):
 #""produce a function to iterate the "attributes" of a class,
 #djusting for SQLAlchemy fields embedded in dataclass fields.

 #""
 #a_dataclass_metadata_key = _get_immediate_cls_attr(
 #ls, "__sa_dataclass_metadata_key__", None
 #

 #f sa_dataclass_metadata_key is None:

 #ef local_attributes_for_class():
 #or name, obj in vars(cls).items():
 #ield name, obj, False

 #lse:
 #ield_names = set()

 #ef local_attributes_for_class():
 #or field in util.local_dataclass_fields(cls):
 #f sa_dataclass_metadata_key in field.metadata:
 #ield_names.add(field.name)
 #ield field.name, _as_dc_declaredattr(
 #ield.metadata, sa_dataclass_metadata_key
 #, True
 #or name, obj in vars(cls).items():
 #f name not in field_names:
 #ield name, obj, False

 #eturn local_attributes_for_class

 #ef _scan_attributes(self):
 #ls = self.cls
 #ict_ = self.dict_
 #olumn_copies = self.column_copies
 #apper_args_fn = None
 #able_args = inherited_table_args = None
 #ablename = None

 #ttribute_is_overridden = self._cls_attr_override_checker(self.cls)

 #or base in cls.__mro__:

 #lass_mapped = (
 #ase is not cls
 #nd _declared_mapping_info(base) is not None
 #nd not _get_immediate_cls_attr(
 #ase, "_sa_decl_prepare_nocascade", strict=True
 #
 #

 #ocal_attributes_for_class = self._cls_attr_resolver(base)

 #f not class_mapped and base is not cls:
 #elf._produce_column_copies(
 #ocal_attributes_for_class, attribute_is_overridden
 #

 #or name, obj, is_dataclass in local_attributes_for_class():
 #f name == "__mapper_args__":
 #heck_decl = _check_declared_props_nocascade(
 #bj, name, cls
 #
 #f not mapper_args_fn and (not class_mapped or check_decl):
                        # don't even invoke __mapper_args__ until
                        # after we've determined everything about the
                        # mapped table.
                        # make a copy of it so a class-level dictionary
                        # is not overwritten when we update column-based
                        # arguments.
 #ef mapper_args_fn():
 #eturn dict(cls.__mapper_args__)

 #lif name == "__tablename__":
 #heck_decl = _check_declared_props_nocascade(
 #bj, name, cls
 #
 #f not tablename and (not class_mapped or check_decl):
 #ablename = cls.__tablename__
 #lif name == "__table_args__":
 #heck_decl = _check_declared_props_nocascade(
 #bj, name, cls
 #
 #f not table_args and (not class_mapped or check_decl):
 #able_args = cls.__table_args__
 #f not isinstance(
 #able_args, (tuple, dict, type(None))
 #:
 #aise exc.ArgumentError(
 #__table_args__ value must be a tuple, "
 #dict, or None"
 #
 #f base is not cls:
 #nherited_table_args = True
 #lif class_mapped:
 #f _is_declarative_props(obj):
 #til.warn(
 #Regular (i.e. not __special__) "
 #attribute '%s.%s' uses @declared_attr, "
 #but owning class %s is mapped - "
 #not applying to subclass %s."
 # (base.__name__, name, base, cls)
 #
 #ontinue
 #lif base is not cls:
                    # we're a mixin, abstract base, or something that is
                    # acting like that for now.
 #f isinstance(obj, Column):
                        # already copied columns to the mapped class.
 #ontinue
 #lif isinstance(obj, MapperProperty):
 #aise exc.InvalidRequestError(
 #Mapper properties (i.e. deferred,"
 #column_property(), relationship(), etc.) must "
 #be declared as @declared_attr callables "
 #on declarative mixin classes.  For dataclass "
 #field() objects, use a lambda:"
 #
 #lif _is_declarative_props(obj):
 #f obj._cascading:
 #f name in dict_:
                                # unfortunately, while we can use the user-
                                # defined attribute here to allow a clean
                                # override, if there's another
                                # subclass below then it still tries to use
                                # this.  not sure if there is enough
                                # information here to add this as a feature
                                # later on.
 #til.warn(
 #Attribute '%s' on class %s cannot be "
 #processed due to "
 #@declared_attr.cascading; "
 #skipping" % (name, cls)
 #
 #ict_[name] = column_copies[
 #bj
 # = ret = obj.__get__(obj, cls)
 #etattr(cls, name, ret)
 #lse:
 #f is_dataclass:
                                # access attribute using normal class access
                                # first, to see if it's been mapped on a
                                # superclass.   note if the dataclasses.field()
                                # has "default", this value can be anything.
 #et = getattr(cls, name, None)

                                # so, if it's anything that's not ORM
                                # mapped, assume we should invoke the
                                # declared_attr
 #f not isinstance(ret, InspectionAttr):
 #et = obj.fget()
 #lse:
                                # access attribute using normal class access.
                                # if the declared attr already took place
                                # on a superclass that is mapped, then
                                # this is no longer a declared_attr, it will
                                # be the InstrumentedAttribute
 #et = getattr(cls, name)

                            # correct for proxies created from hybrid_property
                            # or similar.  note there is no known case that
                            # produces nested proxies, so we are only
                            # looking one level deep right now.
 #f (
 #sinstance(ret, InspectionAttr)
 #nd ret._is_internal_proxy
 #nd not isinstance(
 #et.original_property, MapperProperty
 #
 #:
 #et = ret.descriptor

 #ict_[name] = column_copies[obj] = ret
 #f (
 #sinstance(ret, (Column, MapperProperty))
 #nd ret.doc is None
 #:
 #et.doc = obj.__doc__
                    # here, the attribute is some other kind of property that
                    # we assume is not part of the declarative mapping.
                    # however, check for some more common mistakes
 #lse:
 #elf._warn_for_decl_attributes(base, name, obj)
 #lif is_dataclass and (
 #ame not in dict_ or dict_[name] is not obj
 #:
                    # here, we are definitely looking at the target class
                    # and not a superclass.   this is currently a
                    # dataclass-only path.  if the name is only
                    # a dataclass field and isn't in local cls.__dict__,
                    # put the object there.
                    # assert that the dataclass-enabled resolver agrees
                    # with what we are seeing

 #ssert not attribute_is_overridden(name, obj)

 #f _is_declarative_props(obj):
 #bj = obj.fget()

 #ict_[name] = obj

 #f inherited_table_args and not tablename:
 #able_args = None

 #elf.table_args = table_args
 #elf.tablename = tablename
 #elf.mapper_args_fn = mapper_args_fn

 #ef _warn_for_decl_attributes(self, cls, key, c):
 #f isinstance(c, expression.ColumnClause):
 #til.warn(
 #Attribute '%s' on class %s appears to be a non-schema "
 #'sqlalchemy.sql.column()' "
 #object; this won't be part of the declarative mapping"
 # (key, cls)
 #

 #ef _produce_column_copies(
 #elf, attributes_for_class, attribute_is_overridden
 #:
 #ls = self.cls
 #ict_ = self.dict_
 #olumn_copies = self.column_copies
        # copy mixin columns to the mapped class

 #or name, obj, is_dataclass in attributes_for_class():
 #f isinstance(obj, Column):
 #f attribute_is_overridden(name, obj):
                    # if column has been overridden
                    # (like by the InstrumentedAttribute of the
                    # superclass), skip
 #ontinue
 #lif obj.foreign_keys:
 #aise exc.InvalidRequestError(
 #Columns with foreign keys to other columns "
 #must be declared as @declared_attr callables "
 #on declarative mixin classes.  For dataclass "
 #field() objects, use a lambda:."
 #
 #lif name not in dict_ and not (
 #__table__" in dict_
 #nd (obj.name or name) in dict_["__table__"].c
 #:
 #olumn_copies[obj] = copy_ = obj._copy()
 #opy_._creation_order = obj._creation_order
 #etattr(cls, name, copy_)
 #ict_[name] = copy_

 #ef _extract_mappable_attributes(self):
 #ls = self.cls
 #ict_ = self.dict_

 #ur_stuff = self.properties

 #ate_mapped = _get_immediate_cls_attr(
 #ls, "_sa_decl_prepare_nocascade", strict=True
 #

 #or k in list(dict_):

 #f k in ("__table__", "__tablename__", "__mapper_args__"):
 #ontinue

 #alue = dict_[k]
 #f _is_declarative_props(value):
 #f value._cascading:
 #til.warn(
 #Use of @declared_attr.cascading only applies to "
 #Declarative 'mixin' and 'abstract' classes.  "
 #Currently, this flag is ignored on mapped class "
 #%s" % self.cls
 #

 #alue = getattr(cls, k)

 #lif (
 #sinstance(value, QueryableAttribute)
 #nd value.class_ is not cls
 #nd value.key != k
 #:
                # detect a QueryableAttribute that's already mapped being
                # assigned elsewhere in userland, turn into a synonym()
 #alue = SynonymProperty(value.key)
 #etattr(cls, k, value)

 #f (
 #sinstance(value, tuple)
 #nd len(value) == 1
 #nd isinstance(value[0], (Column, MapperProperty))
 #:
 #til.warn(
 #Ignoring declarative-like tuple value of attribute "
 #'%s': possibly a copy-and-paste error with a comma "
 #accidentally placed at the end of the line?" % k
 #
 #ontinue
 #lif not isinstance(value, (Column, MapperProperty)):
                # using @declared_attr for some object that
                # isn't Column/MapperProperty; remove from the dict_
                # and place the evaluated value onto the class.
 #f not k.startswith("__"):
 #ict_.pop(k)
 #elf._warn_for_decl_attributes(cls, k, value)
 #f not late_mapped:
 #etattr(cls, k, value)
 #ontinue
            # we expect to see the name 'metadata' in some valid cases;
            # however at this point we see it's assigned to something trying
            # to be mapped, so raise for that.
 #lif k == "metadata":
 #aise exc.InvalidRequestError(
 #Attribute name 'metadata' is reserved "
 #for the MetaData instance when using a "
 #declarative base class."
 #
 #ur_stuff[k] = value

 #ef _extract_declared_columns(self):
 #ur_stuff = self.properties

        # set up attributes in the order they were created
 #til.sort_dictionary(
 #ur_stuff, key=lambda key: our_stuff[key]._creation_order
 #

        # extract columns from the class dict
 #eclared_columns = self.declared_columns
 #ame_to_prop_key = collections.defaultdict(set)
 #or key, c in list(our_stuff.items()):
 #f isinstance(c, (ColumnProperty, CompositeProperty)):
 #or col in c.columns:
 #f isinstance(col, Column) and col.table is None:
 #undefer_column_name(key, col)
 #f not isinstance(c, CompositeProperty):
 #ame_to_prop_key[col.name].add(key)
 #eclared_columns.add(col)
 #lif isinstance(c, Column):
 #undefer_column_name(key, c)
 #ame_to_prop_key[c.name].add(key)
 #eclared_columns.add(c)
                # if the column is the same name as the key,
                # remove it from the explicit properties dict.
                # the normal rules for assigning column-based properties
                # will take over, including precedence of columns
                # in multi-column ColumnProperties.
 #f key == c.key:
 #el our_stuff[key]

 #or name, keys in name_to_prop_key.items():
 #f len(keys) > 1:
 #til.warn(
 #On class %r, Column object %r named "
 #directly multiple times, "
 #only one will be used: %s. "
 #Consider using orm.synonym instead"
 # (self.classname, name, (", ".join(sorted(keys))))
 #

 #ef _setup_table(self, table=None):
 #ls = self.cls
 #ablename = self.tablename
 #able_args = self.table_args
 #ict_ = self.dict_
 #eclared_columns = self.declared_columns

 #anager = attributes.manager_of_class(cls)

 #eclared_columns = self.declared_columns = sorted(
 #eclared_columns, key=lambda c: c._creation_order
 #

 #f "__table__" not in dict_ and table is None:
 #f hasattr(cls, "__table_cls__"):
 #able_cls = util.unbound_method_to_callable(cls.__table_cls__)
 #lse:
 #able_cls = Table

 #f tablename is not None:

 #rgs, table_kw = (), {}
 #f table_args:
 #f isinstance(table_args, dict):
 #able_kw = table_args
 #lif isinstance(table_args, tuple):
 #f isinstance(table_args[-1], dict):
 #rgs, table_kw = table_args[0:-1], table_args[-1]
 #lse:
 #rgs = table_args

 #utoload_with = dict_.get("__autoload_with__")
 #f autoload_with:
 #able_kw["autoload_with"] = autoload_with

 #utoload = dict_.get("__autoload__")
 #f autoload:
 #able_kw["autoload"] = True

 #able = self.set_cls_attribute(
 #__table__",
 #able_cls(
 #ablename,
 #elf._metadata_for_cls(manager),
 #(tuple(declared_columns) + tuple(args)),
 #*table_kw
 #,
 #
 #lse:
 #f table is None:
 #able = cls.__table__
 #f declared_columns:
 #or c in declared_columns:
 #f not table.c.contains_column(c):
 #aise exc.ArgumentError(
 #Can't add additional column %r when "
 #specifying __table__" % c.key
 #
 #elf.local_table = table

 #ef _metadata_for_cls(self, manager):
 #f hasattr(self.cls, "metadata"):
 #eturn self.cls.metadata
 #lse:
 #eturn manager.registry.metadata

 #ef _setup_inheritance(self, mapper_kw):
 #able = self.local_table
 #ls = self.cls
 #able_args = self.table_args
 #eclared_columns = self.declared_columns

 #nherits = mapper_kw.get("inherits", None)

 #f inherits is None:
            # since we search for classical mappings now, search for
            # multiple mapped bases as well and raise an error.
 #nherits_search = []
 #or c in cls.__bases__:
 # = _resolve_for_abstract_or_classical(c)
 #f c is None:
 #ontinue
 #f _declared_mapping_info(
 #
 # is not None and not _get_immediate_cls_attr(
 #, "_sa_decl_prepare_nocascade", strict=True
 #:
 #f c not in inherits_search:
 #nherits_search.append(c)

 #f inherits_search:
 #f len(inherits_search) > 1:
 #aise exc.InvalidRequestError(
 #Class %s has multiple mapped bases: %r"
 # (cls, inherits_search)
 #
 #nherits = inherits_search[0]
 #lif isinstance(inherits, mapper):
 #nherits = inherits.class_

 #elf.inherits = inherits

 #f (
 #able is None
 #nd self.inherits is None
 #nd not _get_immediate_cls_attr(cls, "__no_table__")
 #:

 #aise exc.InvalidRequestError(
 #Class %r does not have a __table__ or __tablename__ "
 #specified and does not inherit from an existing "
 #table-mapped class." % cls
 #
 #lif self.inherits:
 #nherited_mapper = _declared_mapping_info(self.inherits)
 #nherited_table = inherited_mapper.local_table
 #nherited_persist_selectable = inherited_mapper.persist_selectable

 #f table is None:
                # single table inheritance.
                # ensure no table args
 #f table_args:
 #aise exc.ArgumentError(
 #Can't place __table_args__ on an inherited class "
 #with no table."
 #
                # add any columns declared here to the inherited table.
 #or c in declared_columns:
 #f c.name in inherited_table.c:
 #f inherited_table.c[c.name] is c:
 #ontinue
 #aise exc.ArgumentError(
 #Column '%s' on class %s conflicts with "
 #existing column '%s'"
 # (c, cls, inherited_table.c[c.name])
 #
 #f c.primary_key:
 #aise exc.ArgumentError(
 #Can't place primary key columns on an inherited "
 #class with no table."
 #
 #nherited_table.append_column(c)
 #f (
 #nherited_persist_selectable is not None
 #nd inherited_persist_selectable is not inherited_table
 #:
 #nherited_persist_selectable._refresh_for_new_column(c)

 #ef _prepare_mapper_arguments(self, mapper_kw):
 #roperties = self.properties

 #f self.mapper_args_fn:
 #apper_args = self.mapper_args_fn()
 #lse:
 #apper_args = {}

 #f mapper_kw:
 #apper_args.update(mapper_kw)

 #f "properties" in mapper_args:
 #roperties = dict(properties)
 #roperties.update(mapper_args["properties"])

        # make sure that column copies are used rather
        # than the original columns from any mixins
 #or k in ("version_id_col", "polymorphic_on"):
 #f k in mapper_args:
 # = mapper_args[k]
 #apper_args[k] = self.column_copies.get(v, v)

 #f "inherits" in mapper_args:
 #nherits_arg = mapper_args["inherits"]
 #f isinstance(inherits_arg, mapper):
 #nherits_arg = inherits_arg.class_

 #f inherits_arg is not self.inherits:
 #aise exc.InvalidRequestError(
 #mapper inherits argument given for non-inheriting "
 #class %s" % (mapper_args["inherits"])
 #

 #f self.inherits:
 #apper_args["inherits"] = self.inherits

 #f self.inherits and not mapper_args.get("concrete", False):
            # single or joined inheritance
            # exclude any cols on the inherited table which are
            # not mapped on the parent class, to avoid
            # mapping columns specific to sibling/nephew classes
 #nherited_mapper = _declared_mapping_info(self.inherits)
 #nherited_table = inherited_mapper.local_table

 #f "exclude_properties" not in mapper_args:
 #apper_args["exclude_properties"] = exclude_properties = set(
 #
 #.key
 #or c in inherited_table.c
 #f c not in inherited_mapper._columntoproperty
 #
 #.union(inherited_mapper.exclude_properties or ())
 #xclude_properties.difference_update(
 #c.key for c in self.declared_columns]
 #

            # look through columns in the current mapper that
            # are keyed to a propname different than the colname
            # (if names were the same, we'd have popped it out above,
            # in which case the mapper makes this combination).
            # See if the superclass has a similar column property.
            # If so, join them together.
 #or k, col in list(properties.items()):
 #f not isinstance(col, expression.ColumnElement):
 #ontinue
 #f k in inherited_mapper._props:
 # = inherited_mapper._props[k]
 #f isinstance(p, ColumnProperty):
                        # note here we place the subclass column
                        # first.  See [ticket:1892] for background.
 #roperties[k] = [col] + p.columns
 #esult_mapper_args = mapper_args.copy()
 #esult_mapper_args["properties"] = properties
 #elf.mapper_args = result_mapper_args

 #ef map(self, mapper_kw=util.EMPTY_DICT):
 #elf._prepare_mapper_arguments(mapper_kw)
 #f hasattr(self.cls, "__mapper_cls__"):
 #apper_cls = util.unbound_method_to_callable(
 #elf.cls.__mapper_cls__
 #
 #lse:
 #apper_cls = mapper

 #eturn self.set_cls_attribute(
 #__mapper__",
 #apper_cls(self.cls, self.local_table, **self.mapper_args),
 #


@util.preload_module("sqlalchemy.orm.decl_api")
def _as_dc_declaredattr(field_metadata, sa_dataclass_metadata_key):
    # wrap lambdas inside dataclass fields inside an ad-hoc declared_attr.
    # we can't write it because field.metadata is immutable :( so we have
    # to go through extra trouble to compare these
 #ecl_api = util.preloaded.orm_decl_api
 #bj = field_metadata[sa_dataclass_metadata_key]
 #f callable(obj) and not isinstance(obj, decl_api.declared_attr):
 #eturn decl_api.declared_attr(obj)
 #lse:
 #eturn obj


class _DeferredMapperConfig(_ClassScanMapperConfig):
 #configs = util.OrderedDict()

 #ef _early_mapping(self, mapper_kw):
 #ass

 #property
 #ef cls(self):
 #eturn self._cls()

 #cls.setter
 #ef cls(self, class_):
 #elf._cls = weakref.ref(class_, self._remove_config_cls)
 #elf._configs[self._cls] = self

 #classmethod
 #ef _remove_config_cls(cls, ref):
 #ls._configs.pop(ref, None)

 #classmethod
 #ef has_cls(cls, class_):
        # 2.6 fails on weakref if class_ is an old style class
 #eturn isinstance(class_, type) and weakref.ref(class_) in cls._configs

 #classmethod
 #ef raise_unmapped_for_cls(cls, class_):
 #f hasattr(class_, "_sa_raise_deferred_config"):
 #lass_._sa_raise_deferred_config()

 #aise orm_exc.UnmappedClassError(
 #lass_,
 #sg="Class %s has a deferred mapping on it.  It is not yet "
 #usable as a mapped class." % orm_exc._safe_cls_name(class_),
 #

 #classmethod
 #ef config_for_cls(cls, class_):
 #eturn cls._configs[weakref.ref(class_)]

 #classmethod
 #ef classes_for_base(cls, base_cls, sort=True):
 #lasses_for_base = [
 #
 #or m, cls_ in [(m, m.cls) for m in cls._configs.values()]
 #f cls_ is not None and issubclass(cls_, base_cls)
 #

 #f not sort:
 #eturn classes_for_base

 #ll_m_by_cls = dict((m.cls, m) for m in classes_for_base)

 #uples = []
 #or m_cls in all_m_by_cls:
 #uples.extend(
 #all_m_by_cls[base_cls], all_m_by_cls[m_cls])
 #or base_cls in m_cls.__bases__
 #f base_cls in all_m_by_cls
 #
 #eturn list(topological.sort(tuples, classes_for_base))

 #ef map(self, mapper_kw=util.EMPTY_DICT):
 #elf._configs.pop(self._cls, None)
 #eturn super(_DeferredMapperConfig, self).map(mapper_kw)


def _add_attribute(cls, key, value):
 #""add an attribute to an existing declarative class.

 #his runs through the logic to determine MapperProperty,
 #dds it to the Mapper, adds a column to the mapped Table, etc.

 #""

 #f "__mapper__" in cls.__dict__:
 #f isinstance(value, Column):
 #undefer_column_name(key, value)
 #ls.__table__.append_column(value, replace_existing=True)
 #ls.__mapper__.add_property(key, value)
 #lif isinstance(value, ColumnProperty):
 #or col in value.columns:
 #f isinstance(col, Column) and col.table is None:
 #undefer_column_name(key, col)
 #ls.__table__.append_column(col, replace_existing=True)
 #ls.__mapper__.add_property(key, value)
 #lif isinstance(value, MapperProperty):
 #ls.__mapper__.add_property(key, value)
 #lif isinstance(value, QueryableAttribute) and value.key != key:
            # detect a QueryableAttribute that's already mapped being
            # assigned elsewhere in userland, turn into a synonym()
 #alue = SynonymProperty(value.key)
 #ls.__mapper__.add_property(key, value)
 #lse:
 #ype.__setattr__(cls, key, value)
 #ls.__mapper__._expire_memoizations()
 #lse:
 #ype.__setattr__(cls, key, value)


def _del_attribute(cls, key):

 #f (
 #__mapper__" in cls.__dict__
 #nd key in cls.__dict__
 #nd not cls.__mapper__._dispose_called
 #:
 #alue = cls.__dict__[key]
 #f isinstance(
 #alue, (Column, ColumnProperty, MapperProperty, QueryableAttribute)
 #:
 #aise NotImplementedError(
 #Can't un-map individual mapped attributes on a mapped class."
 #
 #lse:
 #ype.__delattr__(cls, key)
 #ls.__mapper__._expire_memoizations()
 #lse:
 #ype.__delattr__(cls, key)


def _declarative_constructor(self, **kwargs):
 #""A simple constructor that allows initialization from kwargs.

 #ets attributes on the constructed instance using the names and
 #alues in ``kwargs``.

 #nly keys that are present as
 #ttributes of the instance's class are allowed. These could be,
 #or example, any mapped columns or relationships.
 #""
 #ls_ = type(self)
 #or k in kwargs:
 #f not hasattr(cls_, k):
 #aise TypeError(
 #%r is an invalid keyword argument for %s" % (k, cls_.__name__)
 #
 #etattr(self, k, kwargs[k])


_declarative_constructor.__name__ = "__init__"


def _undefer_column_name(key, column):
 #f column.key is None:
 #olumn.key = key
 #f column.name is None:
 #olumn.name = key
