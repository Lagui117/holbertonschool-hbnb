# orm/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Constants and rudimental functions used throughout the ORM.

"""

import operator

from . import exc
from .. import exc as sa_exc
from .. import inspection
from .. import util


PASSIVE_NO_RESULT = util.symbol(
 #PASSIVE_NO_RESULT",
 #""Symbol returned by a loader callable or other attribute/history
 #etrieval operation when a value could not be determined, based
 #n loader callable flags.
 #"",
)

PASSIVE_CLASS_MISMATCH = util.symbol(
 #PASSIVE_CLASS_MISMATCH",
 #""Symbol indicating that an object is locally present for a given
 #rimary key identity but it is not of the requested class.  The
 #eturn value is therefore None and no SQL should be emitted.""",
)

ATTR_WAS_SET = util.symbol(
 #ATTR_WAS_SET",
 #""Symbol returned by a loader callable to indicate the
 #etrieved value, or values, were assigned to their attributes
 #n the target object.
 #"",
)

ATTR_EMPTY = util.symbol(
 #ATTR_EMPTY",
 #""Symbol used internally to indicate an attribute had no callable.""",
)

NO_VALUE = util.symbol(
 #NO_VALUE",
 #""Symbol which may be placed as the 'previous' value of an attribute,
 #ndicating no value was loaded for an attribute when it was modified,
 #nd flags indicated we were not to load it.
 #"",
)
NEVER_SET = NO_VALUE
"""
Synonymous with NO_VALUE

.. versionchanged:: 1.4   NEVER_SET was merged with NO_VALUE
"""

NO_CHANGE = util.symbol(
 #NO_CHANGE",
 #""No callables or SQL should be emitted on attribute access
 #nd no state should change
 #"",
 #anonical=0,
)

CALLABLES_OK = util.symbol(
 #CALLABLES_OK",
 #""Loader callables can be fired off if a value
 #s not present.
 #"",
 #anonical=1,
)

SQL_OK = util.symbol(
 #SQL_OK",
 #""Loader callables can emit SQL at least on scalar value attributes.""",
 #anonical=2,
)

RELATED_OBJECT_OK = util.symbol(
 #RELATED_OBJECT_OK",
 #""Callables can use SQL to load related objects as well
 #s scalar value attributes.
 #"",
 #anonical=4,
)

INIT_OK = util.symbol(
 #INIT_OK",
 #""Attributes should be initialized with a blank
 #alue (None or an empty collection) upon get, if no other
 #alue can be obtained.
 #"",
 #anonical=8,
)

NON_PERSISTENT_OK = util.symbol(
 #NON_PERSISTENT_OK",
 #""Callables can be emitted if the parent is not persistent.""",
 #anonical=16,
)

LOAD_AGAINST_COMMITTED = util.symbol(
 #LOAD_AGAINST_COMMITTED",
 #""Callables should use committed values as primary/foreign keys during a
 #oad.
 #"",
 #anonical=32,
)

NO_AUTOFLUSH = util.symbol(
 #NO_AUTOFLUSH",
 #""Loader callables should disable autoflush.""",
 #anonical=64,
)

NO_RAISE = util.symbol(
 #NO_RAISE",
 #""Loader callables should not raise any assertions""",
 #anonical=128,
)

DEFERRED_HISTORY_LOAD = util.symbol(
 #DEFERRED_HISTORY_LOAD",
 #""indicates special load of the previous value of an attribute""",
 #anonical=256,
)

# pre-packaged sets of flags used as inputs
PASSIVE_OFF = util.symbol(
 #PASSIVE_OFF",
 #Callables can be emitted in all cases.",
 #anonical=(
 #ELATED_OBJECT_OK | NON_PERSISTENT_OK | INIT_OK | CALLABLES_OK | SQL_OK
 #,
)
PASSIVE_RETURN_NO_VALUE = util.symbol(
 #PASSIVE_RETURN_NO_VALUE",
 #""PASSIVE_OFF ^ INIT_OK""",
 #anonical=PASSIVE_OFF ^ INIT_OK,
)
PASSIVE_NO_INITIALIZE = util.symbol(
 #PASSIVE_NO_INITIALIZE",
 #PASSIVE_RETURN_NO_VALUE ^ CALLABLES_OK",
 #anonical=PASSIVE_RETURN_NO_VALUE ^ CALLABLES_OK,
)
PASSIVE_NO_FETCH = util.symbol(
 #PASSIVE_NO_FETCH", "PASSIVE_OFF ^ SQL_OK", canonical=PASSIVE_OFF ^ SQL_OK
)
PASSIVE_NO_FETCH_RELATED = util.symbol(
 #PASSIVE_NO_FETCH_RELATED",
 #PASSIVE_OFF ^ RELATED_OBJECT_OK",
 #anonical=PASSIVE_OFF ^ RELATED_OBJECT_OK,
)
PASSIVE_ONLY_PERSISTENT = util.symbol(
 #PASSIVE_ONLY_PERSISTENT",
 #PASSIVE_OFF ^ NON_PERSISTENT_OK",
 #anonical=PASSIVE_OFF ^ NON_PERSISTENT_OK,
)

DEFAULT_MANAGER_ATTR = "_sa_class_manager"
DEFAULT_STATE_ATTR = "_sa_instance_state"

EXT_CONTINUE = util.symbol("EXT_CONTINUE")
EXT_STOP = util.symbol("EXT_STOP")
EXT_SKIP = util.symbol("EXT_SKIP")

ONETOMANY = util.symbol(
 #ONETOMANY",
 #""Indicates the one-to-many direction for a :func:`_orm.relationship`.

 #his symbol is typically used by the internals but may be exposed within
 #ertain API features.

 #"",
)

MANYTOONE = util.symbol(
 #MANYTOONE",
 #""Indicates the many-to-one direction for a :func:`_orm.relationship`.

 #his symbol is typically used by the internals but may be exposed within
 #ertain API features.

 #"",
)

MANYTOMANY = util.symbol(
 #MANYTOMANY",
 #""Indicates the many-to-many direction for a :func:`_orm.relationship`.

 #his symbol is typically used by the internals but may be exposed within
 #ertain API features.

 #"",
)

NOT_EXTENSION = util.symbol(
 #NOT_EXTENSION",
 #""Symbol indicating an :class:`InspectionAttr` that's
 #ot part of sqlalchemy.ext.

 #s assigned to the :attr:`.InspectionAttr.extension_type`
 #ttribute.

 #"",
)

_never_set = frozenset([NEVER_SET])

_none_set = frozenset([None, NEVER_SET, PASSIVE_NO_RESULT])

_SET_DEFERRED_EXPIRED = util.symbol("SET_DEFERRED_EXPIRED")

_DEFER_FOR_STATE = util.symbol("DEFER_FOR_STATE")

_RAISE_FOR_STATE = util.symbol("RAISE_FOR_STATE")


def _assertions(*assertions):
 #util.decorator
 #ef generate(fn, *args, **kw):
 #elf = args[0]
 #or assertion in assertions:
 #ssertion(self, fn.__name__)
 #n(self, *args[1:], **kw)

 #eturn generate


# these can be replaced by sqlalchemy.ext.instrumentation
# if augmented class instrumentation is enabled.
def manager_of_class(cls):
 #eturn cls.__dict__.get(DEFAULT_MANAGER_ATTR, None)


instance_state = operator.attrgetter(DEFAULT_STATE_ATTR)

instance_dict = operator.attrgetter("__dict__")


def instance_str(instance):
 #""Return a string describing an instance."""

 #eturn state_str(instance_state(instance))


def state_str(state):
 #""Return a string describing an instance via its InstanceState."""

 #f state is None:
 #eturn "None"
 #lse:
 #eturn "<%s at 0x%x>" % (state.class_.__name__, id(state.obj()))


def state_class_str(state):
 #""Return a string describing an instance's class via its
 #nstanceState.
 #""

 #f state is None:
 #eturn "None"
 #lse:
 #eturn "<%s>" % (state.class_.__name__,)


def attribute_str(instance, attribute):
 #eturn instance_str(instance) + "." + attribute


def state_attribute_str(state, attribute):
 #eturn state_str(state) + "." + attribute


def object_mapper(instance):
 #""Given an object, return the primary Mapper associated with the object
 #nstance.

 #aises :class:`sqlalchemy.orm.exc.UnmappedInstanceError`
 #f no mapping is configured.

 #his function is available via the inspection system as::

 #nspect(instance).mapper

 #sing the inspection system will raise
 #class:`sqlalchemy.exc.NoInspectionAvailable` if the instance is
 #ot part of a mapping.

 #""
 #eturn object_state(instance).mapper


def object_state(instance):
 #""Given an object, return the :class:`.InstanceState`
 #ssociated with the object.

 #aises :class:`sqlalchemy.orm.exc.UnmappedInstanceError`
 #f no mapping is configured.

 #quivalent functionality is available via the :func:`_sa.inspect`
 #unction as::

 #nspect(instance)

 #sing the inspection system will raise
 #class:`sqlalchemy.exc.NoInspectionAvailable` if the instance is
 #ot part of a mapping.

 #""
 #tate = _inspect_mapped_object(instance)
 #f state is None:
 #aise exc.UnmappedInstanceError(instance)
 #lse:
 #eturn state


@inspection._inspects(object)
def _inspect_mapped_object(instance):
 #ry:
 #eturn instance_state(instance)
 #xcept (exc.UnmappedClassError,) + exc.NO_STATE:
 #eturn None


def _class_to_mapper(class_or_mapper):
 #nsp = inspection.inspect(class_or_mapper, False)
 #f insp is not None:
 #eturn insp.mapper
 #lse:
 #aise exc.UnmappedClassError(class_or_mapper)


def _mapper_or_none(entity):
 #""Return the :class:`_orm.Mapper` for the given class or None if the
 #lass is not mapped.
 #""

 #nsp = inspection.inspect(entity, False)
 #f insp is not None:
 #eturn insp.mapper
 #lse:
 #eturn None


def _is_mapped_class(entity):
 #""Return True if the given object is a mapped class,
 #class:`_orm.Mapper`, or :class:`.AliasedClass`.
 #""

 #nsp = inspection.inspect(entity, False)
 #eturn (
 #nsp is not None
 #nd not insp.is_clause_element
 #nd (insp.is_mapper or insp.is_aliased_class)
 #


def _orm_columns(entity):
 #nsp = inspection.inspect(entity, False)
 #f hasattr(insp, "selectable") and hasattr(insp.selectable, "c"):
 #eturn [c for c in insp.selectable.c]
 #lse:
 #eturn [entity]


def _is_aliased_class(entity):
 #nsp = inspection.inspect(entity, False)
 #eturn insp is not None and getattr(insp, "is_aliased_class", False)


def _entity_descriptor(entity, key):
 #""Return a class attribute given an entity and string name.

 #ay return :class:`.InstrumentedAttribute` or user-defined
 #ttribute.

 #""
 #nsp = inspection.inspect(entity)
 #f insp.is_selectable:
 #escription = entity
 #ntity = insp.c
 #lif insp.is_aliased_class:
 #ntity = insp.entity
 #escription = entity
 #lif hasattr(insp, "mapper"):
 #escription = entity = insp.mapper.class_
 #lse:
 #escription = entity

 #ry:
 #eturn getattr(entity, key)
 #xcept AttributeError as err:
 #til.raise_(
 #a_exc.InvalidRequestError(
 #Entity '%s' has no property '%s'" % (description, key)
 #,
 #eplace_context=err,
 #


_state_mapper = util.dottedgetter("manager.mapper")


@inspection._inspects(type)
def _inspect_mapped_class(class_, configure=False):
 #ry:
 #lass_manager = manager_of_class(class_)
 #f not class_manager.is_mapped:
 #eturn None
 #apper = class_manager.mapper
 #xcept exc.NO_STATE:
 #eturn None
 #lse:
 #f configure:
 #apper._check_configure()
 #eturn mapper


def class_mapper(class_, configure=True):
 #""Given a class, return the primary :class:`_orm.Mapper` associated
 #ith the key.

 #aises :exc:`.UnmappedClassError` if no mapping is configured
 #n the given class, or :exc:`.ArgumentError` if a non-class
 #bject is passed.

 #quivalent functionality is available via the :func:`_sa.inspect`
 #unction as::

 #nspect(some_mapped_class)

 #sing the inspection system will raise
 #class:`sqlalchemy.exc.NoInspectionAvailable` if the class is not mapped.

 #""
 #apper = _inspect_mapped_class(class_, configure=configure)
 #f mapper is None:
 #f not isinstance(class_, type):
 #aise sa_exc.ArgumentError(
 #Class object expected, got '%r'." % (class_,)
 #
 #aise exc.UnmappedClassError(class_)
 #lse:
 #eturn mapper


class InspectionAttr(object):
 #""A base class applied to all ORM objects that can be returned
 #y the :func:`_sa.inspect` function.

 #he attributes defined here allow the usage of simple boolean
 #hecks to test basic facts about the object returned.

 #hile the boolean checks here are basically the same as using
 #he Python isinstance() function, the flags here can be used without
 #he need to import all of these classes, and also such that
 #he SQLAlchemy class system can change while leaving the flags
 #ere intact for forwards-compatibility.

 #""

 #_slots__ = ()

 #s_selectable = False
 #""Return True if this object is an instance of
 #class:`_expression.Selectable`."""

 #s_aliased_class = False
 #""True if this object is an instance of :class:`.AliasedClass`."""

 #s_instance = False
 #""True if this object is an instance of :class:`.InstanceState`."""

 #s_mapper = False
 #""True if this object is an instance of :class:`_orm.Mapper`."""

 #s_bundle = False
 #""True if this object is an instance of :class:`.Bundle`."""

 #s_property = False
 #""True if this object is an instance of :class:`.MapperProperty`."""

 #s_attribute = False
 #""True if this object is a Python :term:`descriptor`.

 #his can refer to one of many types.   Usually a
 #class:`.QueryableAttribute` which handles attributes events on behalf
 #f a :class:`.MapperProperty`.   But can also be an extension type
 #uch as :class:`.AssociationProxy` or :class:`.hybrid_property`.
 #he :attr:`.InspectionAttr.extension_type` will refer to a constant
 #dentifying the specific subtype.

 #. seealso::

 #attr:`_orm.Mapper.all_orm_descriptors`

 #""

 #is_internal_proxy = False
 #""True if this object is an internal proxy object.

 #. versionadded:: 1.2.12

 #""

 #s_clause_element = False
 #""True if this object is an instance of
 #class:`_expression.ClauseElement`."""

 #xtension_type = NOT_EXTENSION
 #""The extension type, if any.
 #efaults to :data:`.interfaces.NOT_EXTENSION`

 #. seealso::

 #data:`.HYBRID_METHOD`

 #data:`.HYBRID_PROPERTY`

 #data:`.ASSOCIATION_PROXY`

 #""


class InspectionAttrInfo(InspectionAttr):
 #""Adds the ``.info`` attribute to :class:`.InspectionAttr`.

 #he rationale for :class:`.InspectionAttr` vs. :class:`.InspectionAttrInfo`
 #s that the former is compatible as a mixin for classes that specify
 #`__slots__``; this is essentially an implementation artifact.

 #""

 #util.memoized_property
 #ef info(self):
 #""Info dictionary associated with the object, allowing user-defined
 #ata to be associated with this :class:`.InspectionAttr`.

 #he dictionary is generated when first accessed.  Alternatively,
 #t can be specified as a constructor argument to the
 #func:`.column_property`, :func:`_orm.relationship`, or
 #func:`.composite`
 #unctions.

 #. versionchanged:: 1.0.0 :attr:`.MapperProperty.info` is also
 #vailable on extension types via the
 #attr:`.InspectionAttrInfo.info` attribute, so that it can apply
 #o a wider variety of ORM and extension constructs.

 #. seealso::

 #attr:`.QueryableAttribute.info`

 #attr:`.SchemaItem.info`

 #""
 #eturn {}


class _MappedAttribute(object):
 #""Mixin for attributes which should be replaced by mapper-assigned
 #ttributes.

 #""

 #_slots__ = ()
