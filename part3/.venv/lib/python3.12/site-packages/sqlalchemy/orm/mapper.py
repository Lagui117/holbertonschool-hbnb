# orm/mapper.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Logic to map Python classes to and from selectables.

Defines the :class:`~sqlalchemy.orm.mapper.Mapper` class, the central
configurational unit which associates a class with a database table.

This is a semi-private module; the main configurational API of the ORM is
available in :class:`~sqlalchemy.orm.`.

"""
from __future__ import absolute_import

from collections import deque
from itertools import chain
import sys
import weakref

from . import attributes
from . import exc as orm_exc
from . import instrumentation
from . import loading
from . import properties
from . import util as orm_util
from .base import _class_to_mapper
from .base import _state_mapper
from .base import class_mapper
from .base import state_str
from .interfaces import _MappedAttribute
from .interfaces import EXT_SKIP
from .interfaces import InspectionAttr
from .interfaces import MapperProperty
from .interfaces import ORMEntityColumnsClauseRole
from .interfaces import ORMFromClauseRole
from .path_registry import PathRegistry
from .. import event
from .. import exc as sa_exc
from .. import inspection
from .. import log
from .. import schema
from .. import sql
from .. import util
from ..sql import base as sql_base
from ..sql import coercions
from ..sql import expression
from ..sql import operators
from ..sql import roles
from ..sql import util as sql_util
from ..sql import visitors
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
from ..util import HasMemoized

_mapper_registries = weakref.WeakKeyDictionary()

_legacy_registry = None


def _all_registries():
 #ith _CONFIGURE_MUTEX:
 #eturn set(_mapper_registries)


def _unconfigured_mappers():
 #or reg in _all_registries():
 #or mapper in reg._mappers_to_configure():
 #ield mapper


_already_compiling = False


# a constant returned by _get_attr_by_column to indicate
# this mapper is not handling an attribute for a particular
# column
NO_ATTRIBUTE = util.symbol("NO_ATTRIBUTE")

# lock used to synchronize the "mapper configure" step
_CONFIGURE_MUTEX = util.threading.RLock()


@inspection._self_inspects
@log.class_logger
class Mapper(
 #RMFromClauseRole,
 #RMEntityColumnsClauseRole,
 #ql_base.MemoizedHasCacheKey,
 #nspectionAttr,
):
 #""Define the correlation of class attributes to database table
 #olumns.

 #he :class:`_orm.Mapper` object is instantiated using the
 #func:`~sqlalchemy.orm.mapper` function.    For information
 #bout instantiating new :class:`_orm.Mapper` objects, see
 #hat function's documentation.


 #hen :func:`.mapper` is used
 #xplicitly to link a user defined class with table
 #etadata, this is referred to as *classical mapping*.
 #odern SQLAlchemy usage tends to favor the
 #mod:`sqlalchemy.ext.declarative` extension for class
 #onfiguration, which
 #akes usage of :func:`.mapper` behind the scenes.

 #iven a particular class known to be mapped by the ORM,
 #he :class:`_orm.Mapper` which maintains it can be acquired
 #sing the :func:`_sa.inspect` function::

 #rom sqlalchemy import inspect

 #apper = inspect(MyClass)

 # class which was mapped by the :mod:`sqlalchemy.ext.declarative`
 #xtension will also have its mapper available via the ``__mapper__``
 #ttribute.


 #""

 #dispose_called = False
 #ready_for_configure = False

 #util.deprecated_params(
 #on_primary=(
 #1.3",
 #The :paramref:`.mapper.non_primary` parameter is deprecated, "
 #and will be removed in a future release.  The functionality "
 #of non primary mappers is now better suited using the "
 #:class:`.AliasedClass` construct, which can also be used "
 #as the target of a :func:`_orm.relationship` in 1.3.",
 #,
 #
 #ef __init__(
 #elf,
 #lass_,
 #ocal_table=None,
 #roperties=None,
 #rimary_key=None,
 #on_primary=False,
 #nherits=None,
 #nherit_condition=None,
 #nherit_foreign_keys=None,
 #lways_refresh=False,
 #ersion_id_col=None,
 #ersion_id_generator=None,
 #olymorphic_on=None,
 #polymorphic_map=None,
 #olymorphic_identity=None,
 #oncrete=False,
 #ith_polymorphic=None,
 #olymorphic_load=None,
 #llow_partial_pks=True,
 #atch=True,
 #olumn_prefix=None,
 #nclude_properties=None,
 #xclude_properties=None,
 #assive_updates=True,
 #assive_deletes=False,
 #onfirm_deleted_rows=True,
 #ager_defaults=False,
 #egacy_is_orphan=False,
 #compiled_cache_size=100,
 #:
 #"""Direct constructor for a new :class:`_orm.Mapper` object.

 #he :func:`_orm.mapper` function is normally invoked through the
 #se of the :class:`_orm.registry` object through either the
 #ref:`Declarative <orm_declarative_mapping>` or
 #ref:`Imperative <orm_imperative_mapping>` mapping styles.

 #. versionchanged:: 1.4 The :func:`_orm.mapper` function should not
 #e called directly for classical mapping; for a classical mapping
 #onfiguration, use the :meth:`_orm.registry.map_imperatively`
 #ethod.   The :func:`_orm.mapper` function may become private in a
 #uture release.

 #arameters documented below may be passed to either the
 #meth:`_orm.registry.map_imperatively` method, or may be passed in the
 #`__mapper_args__`` declarative class attribute described at
 #ref:`orm_declarative_mapper_options`.

 #param class\_: The class to be mapped.  When using Declarative,
 #his argument is automatically passed as the declared class
 #tself.

 #param local_table: The :class:`_schema.Table` or other selectable
 #o which the class is mapped.  May be ``None`` if
 #his mapper inherits from another mapper using single-table
 #nheritance.   When using Declarative, this argument is
 #utomatically passed by the extension, based on what
 #s configured via the ``__table__`` argument or via the
 #class:`_schema.Table`
 #roduced as a result of the ``__tablename__``
 #nd :class:`_schema.Column` arguments present.

 #param always_refresh: If True, all query operations for this mapped
 #lass will overwrite all data within object instances that already
 #xist within the session, erasing any in-memory changes with
 #hatever information was loaded from the database. Usage of this
 #lag is highly discouraged; as an alternative, see the method
 #meth:`_query.Query.populate_existing`.

 #param allow_partial_pks: Defaults to True.  Indicates that a
 #omposite primary key with some NULL values should be considered as
 #ossibly existing within the database. This affects whether a
 #apper will assign an incoming row to an existing identity, as well
 #s if :meth:`.Session.merge` will check the database first for a
 #articular primary key value. A "partial primary key" can occur if
 #ne has mapped to an OUTER JOIN, for example.

 #param batch: Defaults to ``True``, indicating that save operations
 #f multiple entities can be batched together for efficiency.
 #etting to False indicates
 #hat an instance will be fully saved before saving the next
 #nstance.  This is used in the extremely rare case that a
 #class:`.MapperEvents` listener requires being called
 #n between individual row persistence operations.

 #param column_prefix: A string which will be prepended
 #o the mapped attribute name when :class:`_schema.Column`
 #bjects are automatically assigned as attributes to the
 #apped class.  Does not affect explicitly specified
 #olumn-based properties.

 #ee the section :ref:`column_prefix` for an example.

 #param concrete: If True, indicates this mapper should use concrete
 #able inheritance with its parent mapper.

 #ee the section :ref:`concrete_inheritance` for an example.

 #param confirm_deleted_rows: defaults to True; when a DELETE occurs
 #f one more rows based on specific primary keys, a warning is
 #mitted when the number of rows matched does not equal the number
 #f rows expected.  This parameter may be set to False to handle the
 #ase where database ON DELETE CASCADE rules may be deleting some of
 #hose rows automatically.  The warning may be changed to an
 #xception in a future release.

 #. versionadded:: 0.9.4 - added
 #paramref:`.mapper.confirm_deleted_rows` as well as conditional
 #atched row checking on delete.

 #param eager_defaults: if True, the ORM will immediately fetch the
 #alue of server-generated default values after an INSERT or UPDATE,
 #ather than leaving them as expired to be fetched on next access.
 #his can be used for event schemes where the server-generated values
 #re needed immediately before the flush completes.   By default,
 #his scheme will emit an individual ``SELECT`` statement per row
 #nserted or updated, which note can add significant performance
 #verhead.  However, if the
 #arget database supports :term:`RETURNING`, the default values will
 #e returned inline with the INSERT or UPDATE statement, which can
 #reatly enhance performance for an application that needs frequent
 #ccess to just-generated server defaults.

 #. seealso::

 #ref:`orm_server_defaults`

 #. versionchanged:: 0.9.0 The ``eager_defaults`` option can now
 #ake use of :term:`RETURNING` for backends which support it.

 #param exclude_properties: A list or set of string column names to
 #e excluded from mapping.

 #ee :ref:`include_exclude_cols` for an example.

 #param include_properties: An inclusive list or set of string column
 #ames to map.

 #ee :ref:`include_exclude_cols` for an example.

 #param inherits: A mapped class or the corresponding
 #class:`_orm.Mapper`
 #f one indicating a superclass to which this :class:`_orm.Mapper`
 #hould *inherit* from.   The mapped class here must be a subclass
 #f the other mapper's class.   When using Declarative, this argument
 #s passed automatically as a result of the natural class
 #ierarchy of the declared classes.

 #. seealso::

 #ref:`inheritance_toplevel`

 #param inherit_condition: For joined table inheritance, a SQL
 #xpression which will
 #efine how the two tables are joined; defaults to a natural join
 #etween the two tables.

 #param inherit_foreign_keys: When ``inherit_condition`` is used and
 #he columns present are missing a :class:`_schema.ForeignKey`
 #onfiguration, this parameter can be used to specify which columns
 #re "foreign".  In most cases can be left as ``None``.

 #param legacy_is_orphan: Boolean, defaults to ``False``.
 #hen ``True``, specifies that "legacy" orphan consideration
 #s to be applied to objects mapped by this mapper, which means
 #hat a pending (that is, not persistent) object is auto-expunged
 #rom an owning :class:`.Session` only when it is de-associated
 #rom *all* parents that specify a ``delete-orphan`` cascade towards
 #his mapper.  The new default behavior is that the object is
 #uto-expunged when it is de-associated with *any* of its parents
 #hat specify ``delete-orphan`` cascade.  This behavior is more
 #onsistent with that of a persistent object, and allows behavior to
 #e consistent in more scenarios independently of whether or not an
 #rphan object has been flushed yet or not.

 #ee the change note and example at :ref:`legacy_is_orphan_addition`
 #or more detail on this change.

 #param non_primary: Specify that this :class:`_orm.Mapper`
 #s in addition
 #o the "primary" mapper, that is, the one used for persistence.
 #he :class:`_orm.Mapper` created here may be used for ad-hoc
 #apping of the class to an alternate selectable, for loading
 #nly.

 #. seealso::

 #ref:`relationship_aliased_class` - the new pattern that removes
 #he need for the :paramref:`_orm.Mapper.non_primary` flag.

 #param passive_deletes: Indicates DELETE behavior of foreign key
 #olumns when a joined-table inheritance entity is being deleted.
 #efaults to ``False`` for a base mapper; for an inheriting mapper,
 #efaults to ``False`` unless the value is set to ``True``
 #n the superclass mapper.

 #hen ``True``, it is assumed that ON DELETE CASCADE is configured
 #n the foreign key relationships that link this mapper's table
 #o its superclass table, so that when the unit of work attempts
 #o delete the entity, it need only emit a DELETE statement for the
 #uperclass table, and not this table.

 #hen ``False``, a DELETE statement is emitted for this mapper's
 #able individually.  If the primary key attributes local to this
 #able are unloaded, then a SELECT must be emitted in order to
 #alidate these attributes; note that the primary key columns
 #f a joined-table subclass are not part of the "primary key" of
 #he object as a whole.

 #ote that a value of ``True`` is **always** forced onto the
 #ubclass mappers; that is, it's not possible for a superclass
 #o specify passive_deletes without this taking effect for
 #ll subclass mappers.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`passive_deletes` - description of similar feature as
 #sed with :func:`_orm.relationship`

 #paramref:`.mapper.passive_updates` - supporting ON UPDATE
 #ASCADE for joined-table inheritance mappers

 #param passive_updates: Indicates UPDATE behavior of foreign key
 #olumns when a primary key column changes on a joined-table
 #nheritance mapping.   Defaults to ``True``.

 #hen True, it is assumed that ON UPDATE CASCADE is configured on
 #he foreign key in the database, and that the database will handle
 #ropagation of an UPDATE from a source column to dependent columns
 #n joined-table rows.

 #hen False, it is assumed that the database does not enforce
 #eferential integrity and will not be issuing its own CASCADE
 #peration for an update.  The unit of work process will
 #mit an UPDATE statement for the dependent columns during a
 #rimary key change.

 #. seealso::

 #ref:`passive_updates` - description of a similar feature as
 #sed with :func:`_orm.relationship`

 #paramref:`.mapper.passive_deletes` - supporting ON DELETE
 #ASCADE for joined-table inheritance mappers

 #param polymorphic_load: Specifies "polymorphic loading" behavior
 #or a subclass in an inheritance hierarchy (joined and single
 #able inheritance only).   Valid values are:

 # "'inline'" - specifies this class should be part of the
 #with_polymorphic" mappers, e.g. its columns will be included
 #n a SELECT query against the base.

 # "'selectin'" - specifies that when instances of this class
 #re loaded, an additional SELECT will be emitted to retrieve
 #he columns specific to this subclass.  The SELECT uses
 #N to fetch multiple subclasses at once.

 #. versionadded:: 1.2

 #. seealso::

 #ref:`with_polymorphic_mapper_config`

 #ref:`polymorphic_selectin`

 #param polymorphic_on: Specifies the column, attribute, or
 #QL expression used to determine the target class for an
 #ncoming row, when inheriting classes are present.

 #his value is commonly a :class:`_schema.Column` object that's
 #resent in the mapped :class:`_schema.Table`::

 #lass Employee(Base):
 #_tablename__ = 'employee'

 #d = Column(Integer, primary_key=True)
 #iscriminator = Column(String(50))

 #_mapper_args__ = {
 #polymorphic_on":discriminator,
 #polymorphic_identity":"employee"
 #

 #t may also be specified
 #s a SQL expression, as in this example where we
 #se the :func:`.case` construct to provide a conditional
 #pproach::

 #lass Employee(Base):
 #_tablename__ = 'employee'

 #d = Column(Integer, primary_key=True)
 #iscriminator = Column(String(50))

 #_mapper_args__ = {
 #polymorphic_on":case([
 #discriminator == "EN", "engineer"),
 #discriminator == "MA", "manager"),
 #, else_="employee"),
 #polymorphic_identity":"employee"
 #

 #t may also refer to any attribute
 #onfigured with :func:`.column_property`, or to the
 #tring name of one::

 #lass Employee(Base):
 #_tablename__ = 'employee'

 #d = Column(Integer, primary_key=True)
 #iscriminator = Column(String(50))
 #mployee_type = column_property(
 #ase([
 #discriminator == "EN", "engineer"),
 #discriminator == "MA", "manager"),
 #, else_="employee")
 #

 #_mapper_args__ = {
 #polymorphic_on":employee_type,
 #polymorphic_identity":"employee"
 #

 #hen setting ``polymorphic_on`` to reference an
 #ttribute or expression that's not present in the
 #ocally mapped :class:`_schema.Table`, yet the value
 #f the discriminator should be persisted to the database,
 #he value of the
 #iscriminator is not automatically set on new
 #nstances; this must be handled by the user,
 #ither through manual means or via event listeners.
 # typical approach to establishing such a listener
 #ooks like::

 #rom sqlalchemy import event
 #rom sqlalchemy.orm import object_mapper

 #event.listens_for(Employee, "init", propagate=True)
 #ef set_identity(instance, *arg, **kw):
 #apper = object_mapper(instance)
 #nstance.discriminator = mapper.polymorphic_identity

 #here above, we assign the value of ``polymorphic_identity``
 #or the mapped class to the ``discriminator`` attribute,
 #hus persisting the value to the ``discriminator`` column
 #n the database.

 #. warning::

 #urrently, **only one discriminator column may be set**, typically
 #n the base-most class in the hierarchy. "Cascading" polymorphic
 #olumns are not yet supported.

 #. seealso::

 #ref:`inheritance_toplevel`

 #param polymorphic_identity: Specifies the value which
 #dentifies this particular class as returned by the
 #olumn expression referred to by the ``polymorphic_on``
 #etting.  As rows are received, the value corresponding
 #o the ``polymorphic_on`` column expression is compared
 #o this value, indicating which subclass should
 #e used for the newly reconstructed object.

 #param properties: A dictionary mapping the string names of object
 #ttributes to :class:`.MapperProperty` instances, which define the
 #ersistence behavior of that attribute.  Note that
 #class:`_schema.Column`
 #bjects present in
 #he mapped :class:`_schema.Table` are automatically placed into
 #`ColumnProperty`` instances upon mapping, unless overridden.
 #hen using Declarative, this argument is passed automatically,
 #ased on all those :class:`.MapperProperty` instances declared
 #n the declared class body.

 #param primary_key: A list of :class:`_schema.Column`
 #bjects which define
 #he primary key to be used against this mapper's selectable unit.
 #his is normally simply the primary key of the ``local_table``, but
 #an be overridden here.

 #param version_id_col: A :class:`_schema.Column`
 #hat will be used to keep a running version id of rows
 #n the table.  This is used to detect concurrent updates or
 #he presence of stale data in a flush.  The methodology is to
 #etect if an UPDATE statement does not match the last known
 #ersion id, a
 #class:`~sqlalchemy.orm.exc.StaleDataError` exception is
 #hrown.
 #y default, the column must be of :class:`.Integer` type,
 #nless ``version_id_generator`` specifies an alternative version
 #enerator.

 #. seealso::

 #ref:`mapper_version_counter` - discussion of version counting
 #nd rationale.

 #param version_id_generator: Define how new version ids should
 #e generated.  Defaults to ``None``, which indicates that
 # simple integer counting scheme be employed.  To provide a custom
 #ersioning scheme, provide a callable function of the form::

 #ef generate_version(version):
 #eturn next_version

 #lternatively, server-side versioning functions such as triggers,
 #r programmatic versioning schemes outside of the version id
 #enerator may be used, by specifying the value ``False``.
 #lease see :ref:`server_side_version_counter` for a discussion
 #f important points when using this option.

 #. versionadded:: 0.9.0 ``version_id_generator`` supports
 #erver-side version number generation.

 #. seealso::

 #ref:`custom_version_counter`

 #ref:`server_side_version_counter`


 #param with_polymorphic: A tuple in the form ``(<classes>,
 #selectable>)`` indicating the default style of "polymorphic"
 #oading, that is, which tables are queried at once. <classes> is
 #ny single or list of mappers and/or classes indicating the
 #nherited classes that should be loaded at once. The special value
 #`'*'`` may be used to indicate all descending classes should be
 #oaded immediately. The second tuple argument <selectable>
 #ndicates a selectable that will be used to query for multiple
 #lasses.

 #. seealso::

 #ref:`with_polymorphic` - discussion of polymorphic querying
 #echniques.

 #""
 #elf.class_ = util.assert_arg_type(class_, type, "class_")
 #elf._sort_key = "%s.%s" % (
 #elf.class_.__module__,
 #elf.class_.__name__,
 #

 #elf.class_manager = None

 #elf._primary_key_argument = util.to_list(primary_key)
 #elf.non_primary = non_primary

 #elf.always_refresh = always_refresh

 #f isinstance(version_id_col, MapperProperty):
 #elf.version_id_prop = version_id_col
 #elf.version_id_col = None
 #lse:
 #elf.version_id_col = version_id_col
 #f version_id_generator is False:
 #elf.version_id_generator = False
 #lif version_id_generator is None:
 #elf.version_id_generator = lambda x: (x or 0) + 1
 #lse:
 #elf.version_id_generator = version_id_generator

 #elf.concrete = concrete
 #elf.single = False
 #elf.inherits = inherits
 #f local_table is not None:
 #elf.local_table = coercions.expect(
 #oles.StrictFromClauseRole, local_table
 #
 #lse:
 #elf.local_table = None

 #elf.inherit_condition = inherit_condition
 #elf.inherit_foreign_keys = inherit_foreign_keys
 #elf._init_properties = properties or {}
 #elf._delete_orphans = []
 #elf.batch = batch
 #elf.eager_defaults = eager_defaults
 #elf.column_prefix = column_prefix
 #elf.polymorphic_on = (
 #oercions.expect(
 #oles.ColumnArgumentOrKeyRole,
 #olymorphic_on,
 #rgname="polymorphic_on",
 #
 #f polymorphic_on is not None
 #lse None
 #
 #elf._dependency_processors = []
 #elf.validators = util.EMPTY_DICT
 #elf.passive_updates = passive_updates
 #elf.passive_deletes = passive_deletes
 #elf.legacy_is_orphan = legacy_is_orphan
 #elf._clause_adapter = None
 #elf._requires_row_aliasing = False
 #elf._inherits_equated_pairs = None
 #elf._memoized_values = {}
 #elf._compiled_cache_size = _compiled_cache_size
 #elf._reconstructor = None
 #elf.allow_partial_pks = allow_partial_pks

 #f self.inherits and not self.concrete:
 #elf.confirm_deleted_rows = False
 #lse:
 #elf.confirm_deleted_rows = confirm_deleted_rows

 #elf._set_with_polymorphic(with_polymorphic)
 #elf.polymorphic_load = polymorphic_load

        # our 'polymorphic identity', a string name that when located in a
        #  result set row indicates this Mapper should be used to construct
        # the object instance for that row.
 #elf.polymorphic_identity = polymorphic_identity

        # a dictionary of 'polymorphic identity' names, associating those
        # names with Mappers that will be used to construct object instances
        # upon a select operation.
 #f _polymorphic_map is None:
 #elf.polymorphic_map = {}
 #lse:
 #elf.polymorphic_map = _polymorphic_map

 #f include_properties is not None:
 #elf.include_properties = util.to_set(include_properties)
 #lse:
 #elf.include_properties = None
 #f exclude_properties:
 #elf.exclude_properties = util.to_set(exclude_properties)
 #lse:
 #elf.exclude_properties = None

        # prevent this mapper from being constructed
        # while a configure_mappers() is occurring (and defer a
        # configure_mappers() until construction succeeds)
 #ith _CONFIGURE_MUTEX:
 #elf.dispatch._events._new_mapper_instance(class_, self)
 #elf._configure_inheritance()
 #elf._configure_class_instrumentation()
 #elf._configure_properties()
 #elf._configure_polymorphic_setter()
 #elf._configure_pks()
 #elf.registry._flag_new_mapper(self)
 #elf._log("constructed")
 #elf._expire_memoizations()

    # major attributes initialized at the classlevel so that
    # they can be Sphinx-documented.

 #s_mapper = True
 #""Part of the inspection API."""

 #epresents_outer_join = False

 #property
 #ef mapper(self):
 #""Part of the inspection API.

 #eturns self.

 #""
 #eturn self

 #ef _gen_cache_key(self, anon_map, bindparams):
 #eturn (self,)

 #property
 #ef entity(self):
 #"""Part of the inspection API.

 #eturns self.class\_.

 #""
 #eturn self.class_

 #ocal_table = None
 #""The :class:`_expression.Selectable` which this :class:`_orm.Mapper`
 #anages.

 #ypically is an instance of :class:`_schema.Table` or
 #class:`_expression.Alias`.
 #ay also be ``None``.

 #he "local" table is the
 #electable that the :class:`_orm.Mapper` is directly responsible for
 #anaging from an attribute access and flush perspective.   For
 #on-inheriting mappers, the local table is the same as the
 #mapped" table.   For joined-table inheritance mappers, local_table
 #ill be the particular sub-table of the overall "join" which
 #his :class:`_orm.Mapper` represents.  If this mapper is a
 #ingle-table inheriting mapper, local_table will be ``None``.

 #. seealso::

 #attr:`_orm.Mapper.persist_selectable`.

 #""

 #ersist_selectable = None
 #""The :class:`_expression.Selectable` to which this :class:`_orm.Mapper`
 #s mapped.

 #ypically an instance of :class:`_schema.Table`,
 #class:`_expression.Join`, or :class:`_expression.Alias`.

 #he :attr:`_orm.Mapper.persist_selectable` is separate from
 #attr:`_orm.Mapper.selectable` in that the former represents columns
 #hat are mapped on this class or its superclasses, whereas the
 #atter may be a "polymorphic" selectable that contains additional columns
 #hich are in fact mapped on subclasses only.

 #persist selectable" is the "thing the mapper writes to" and
 #selectable" is the "thing the mapper selects from".

 #attr:`_orm.Mapper.persist_selectable` is also separate from
 #attr:`_orm.Mapper.local_table`, which represents the set of columns that
 #re locally mapped on this class directly.


 #. seealso::

 #attr:`_orm.Mapper.selectable`.

 #attr:`_orm.Mapper.local_table`.

 #""

 #nherits = None
 #""References the :class:`_orm.Mapper` which this :class:`_orm.Mapper`
 #nherits from, if any.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #onfigured = False
 #""Represent ``True`` if this :class:`_orm.Mapper` has been configured.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #. seealso::

 #func:`.configure_mappers`.

 #""

 #oncrete = None
 #""Represent ``True`` if this :class:`_orm.Mapper` is a concrete
 #nheritance mapper.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #ables = None
 #""An iterable containing the collection of :class:`_schema.Table` objects
 #hich this :class:`_orm.Mapper` is aware of.

 #f the mapper is mapped to a :class:`_expression.Join`, or an
 #class:`_expression.Alias`
 #epresenting a :class:`_expression.Select`, the individual
 #class:`_schema.Table`
 #bjects that comprise the full construct will be represented here.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #rimary_key = None
 #""An iterable containing the collection of :class:`_schema.Column`
 #bjects
 #hich comprise the 'primary key' of the mapped table, from the
 #erspective of this :class:`_orm.Mapper`.

 #his list is against the selectable in
 #attr:`_orm.Mapper.persist_selectable`.
 #n the case of inheriting mappers, some columns may be managed by a
 #uperclass mapper.  For example, in the case of a
 #class:`_expression.Join`, the
 #rimary key is determined by all of the primary key columns across all
 #ables referenced by the :class:`_expression.Join`.

 #he list is also not necessarily the same as the primary key column
 #ollection associated with the underlying tables; the :class:`_orm.Mapper`
 #eatures a ``primary_key`` argument that can override what the
 #class:`_orm.Mapper` considers as primary key columns.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #lass_ = None
 #""The Python class which this :class:`_orm.Mapper` maps.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #lass_manager = None
 #""The :class:`.ClassManager` which maintains event listeners
 #nd class-bound descriptors for this :class:`_orm.Mapper`.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #ingle = None
 #""Represent ``True`` if this :class:`_orm.Mapper` is a single table
 #nheritance mapper.

 #attr:`_orm.Mapper.local_table` will be ``None`` if this flag is set.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #on_primary = None
 #""Represent ``True`` if this :class:`_orm.Mapper` is a "non-primary"
 #apper, e.g. a mapper that is used only to select rows but not for
 #ersistence management.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #olymorphic_on = None
 #""The :class:`_schema.Column` or SQL expression specified as the
 #`polymorphic_on`` argument
 #or this :class:`_orm.Mapper`, within an inheritance scenario.

 #his attribute is normally a :class:`_schema.Column` instance but
 #ay also be an expression, such as one derived from
 #func:`.cast`.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #olymorphic_map = None
 #""A mapping of "polymorphic identity" identifiers mapped to
 #class:`_orm.Mapper` instances, within an inheritance scenario.

 #he identifiers can be of any type which is comparable to the
 #ype of column represented by :attr:`_orm.Mapper.polymorphic_on`.

 #n inheritance chain of mappers will all reference the same
 #olymorphic map object.  The object is used to correlate incoming
 #esult rows to target mappers.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #olymorphic_identity = None
 #""Represent an identifier which is matched against the
 #attr:`_orm.Mapper.polymorphic_on` column during result row loading.

 #sed only with inheritance, this object can be of any type which is
 #omparable to the type of column represented by
 #attr:`_orm.Mapper.polymorphic_on`.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #ase_mapper = None
 #""The base-most :class:`_orm.Mapper` in an inheritance chain.

 #n a non-inheriting scenario, this attribute will always be this
 #class:`_orm.Mapper`.   In an inheritance scenario, it references
 #he :class:`_orm.Mapper` which is parent to all other :class:`_orm.Mapper`
 #bjects in the inheritance chain.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #olumns = None
 #""A collection of :class:`_schema.Column` or other scalar expression
 #bjects maintained by this :class:`_orm.Mapper`.

 #he collection behaves the same as that of the ``c`` attribute on
 #ny :class:`_schema.Table` object,
 #xcept that only those columns included in
 #his mapping are present, and are keyed based on the attribute name
 #efined in the mapping, not necessarily the ``key`` attribute of the
 #class:`_schema.Column` itself.   Additionally, scalar expressions mapped
 #y :func:`.column_property` are also present here.

 #his is a *read only* attribute determined during mapper construction.
 #ehavior is undefined if directly modified.

 #""

 #alidators = None
 #""An immutable dictionary of attributes which have been decorated
 #sing the :func:`_orm.validates` decorator.

 #he dictionary contains string attribute names as keys
 #apped to the actual validation method.

 #""

 # = None
 #""A synonym for :attr:`_orm.Mapper.columns`."""

 #property
 #util.deprecated("1.3", "Use .persist_selectable")
 #ef mapped_table(self):
 #eturn self.persist_selectable

 #util.memoized_property
 #ef _path_registry(self):
 #eturn PathRegistry.per_mapper(self)

 #ef _configure_inheritance(self):
 #""Configure settings related to inheriting and/or inherited mappers
 #eing present."""

        # a set of all mappers which inherit from this one.
 #elf._inheriting_mappers = util.WeakSequence()

 #f self.inherits:
 #f isinstance(self.inherits, type):
 #elf.inherits = class_mapper(self.inherits, configure=False)
 #f not issubclass(self.class_, self.inherits.class_):
 #aise sa_exc.ArgumentError(
 #Class '%s' does not inherit from '%s'"
 # (self.class_.__name__, self.inherits.class_.__name__)
 #

 #elf.dispatch._update(self.inherits.dispatch)

 #f self.non_primary != self.inherits.non_primary:
 #p = not self.non_primary and "primary" or "non-primary"
 #aise sa_exc.ArgumentError(
 #Inheritance of %s mapper for class '%s' is "
 #only allowed from a %s mapper"
 # (np, self.class_.__name__, np)
 #
            # inherit_condition is optional.
 #f self.local_table is None:
 #elf.local_table = self.inherits.local_table
 #elf.persist_selectable = self.inherits.persist_selectable
 #elf.single = True
 #lif self.local_table is not self.inherits.local_table:
 #f self.concrete:
 #elf.persist_selectable = self.local_table
 #or mapper in self.iterate_to_root():
 #f mapper.polymorphic_on is not None:
 #apper._requires_row_aliasing = True
 #lse:
 #f self.inherit_condition is None:
                        # figure out inherit condition from our table to the
                        # immediate table of the inherited mapper, not its
                        # full table which could pull in other stuff we don't
                        # want (allows test/inheritance.InheritTest4 to pass)
 #elf.inherit_condition = sql_util.join_condition(
 #elf.inherits.local_table, self.local_table
 #
 #elf.persist_selectable = sql.join(
 #elf.inherits.persist_selectable,
 #elf.local_table,
 #elf.inherit_condition,
 #

 #ks = util.to_set(self.inherit_foreign_keys)
 #elf._inherits_equated_pairs = sql_util.criterion_as_pairs(
 #elf.persist_selectable.onclause,
 #onsider_as_foreign_keys=fks,
 #
 #lse:
 #elf.persist_selectable = self.local_table

 #f self.polymorphic_identity is not None and not self.concrete:
 #elf._identity_class = self.inherits._identity_class
 #lse:
 #elf._identity_class = self.class_

 #f self.version_id_col is None:
 #elf.version_id_col = self.inherits.version_id_col
 #elf.version_id_generator = self.inherits.version_id_generator
 #lif (
 #elf.inherits.version_id_col is not None
 #nd self.version_id_col is not self.inherits.version_id_col
 #:
 #til.warn(
 #Inheriting version_id_col '%s' does not match inherited "
 #version_id_col '%s' and will not automatically populate "
 #the inherited versioning column. "
 #version_id_col should only be specified on "
 #the base-most mapper that includes versioning."
 # (
 #elf.version_id_col.description,
 #elf.inherits.version_id_col.description,
 #
 #

 #elf.polymorphic_map = self.inherits.polymorphic_map
 #elf.batch = self.inherits.batch
 #elf.inherits._inheriting_mappers.append(self)
 #elf.base_mapper = self.inherits.base_mapper
 #elf.passive_updates = self.inherits.passive_updates
 #elf.passive_deletes = (
 #elf.inherits.passive_deletes or self.passive_deletes
 #
 #elf._all_tables = self.inherits._all_tables

 #f self.polymorphic_identity is not None:
 #f self.polymorphic_identity in self.polymorphic_map:
 #til.warn(
 #Reassigning polymorphic association for identity %r "
 #from %r to %r: Check for duplicate use of %r as "
 #value for polymorphic_identity."
 # (
 #elf.polymorphic_identity,
 #elf.polymorphic_map[self.polymorphic_identity],
 #elf,
 #elf.polymorphic_identity,
 #
 #
 #elf.polymorphic_map[self.polymorphic_identity] = self

 #f self.polymorphic_load and self.concrete:
 #aise sa_exc.ArgumentError(
 #polymorphic_load is not currently supported "
 #with concrete table inheritance"
 #
 #f self.polymorphic_load == "inline":
 #elf.inherits._add_with_polymorphic_subclass(self)
 #lif self.polymorphic_load == "selectin":
 #ass
 #lif self.polymorphic_load is not None:
 #aise sa_exc.ArgumentError(
 #unknown argument for polymorphic_load: %r"
 # self.polymorphic_load
 #

 #lse:
 #elf._all_tables = set()
 #elf.base_mapper = self
 #elf.persist_selectable = self.local_table
 #f self.polymorphic_identity is not None:
 #elf.polymorphic_map[self.polymorphic_identity] = self
 #elf._identity_class = self.class_

 #f self.persist_selectable is None:
 #aise sa_exc.ArgumentError(
 #Mapper '%s' does not have a persist_selectable specified."
 # self
 #

 #ef _set_with_polymorphic(self, with_polymorphic):
 #f with_polymorphic == "*":
 #elf.with_polymorphic = ("*", None)
 #lif isinstance(with_polymorphic, (tuple, list)):
 #f isinstance(
 #ith_polymorphic[0], util.string_types + (tuple, list)
 #:
 #elf.with_polymorphic = with_polymorphic
 #lse:
 #elf.with_polymorphic = (with_polymorphic, None)
 #lif with_polymorphic is not None:
 #aise sa_exc.ArgumentError("Invalid setting for with_polymorphic")
 #lse:
 #elf.with_polymorphic = None

 #f self.with_polymorphic and self.with_polymorphic[1] is not None:
 #elf.with_polymorphic = (
 #elf.with_polymorphic[0],
 #oercions.expect(
 #oles.StrictFromClauseRole,
 #elf.with_polymorphic[1],
 #llow_select=True,
 #,
 #

 #f self.configured:
 #elf._expire_memoizations()

 #ef _add_with_polymorphic_subclass(self, mapper):
 #ubcl = mapper.class_
 #f self.with_polymorphic is None:
 #elf._set_with_polymorphic((subcl,))
 #lif self.with_polymorphic[0] != "*":
 #elf._set_with_polymorphic(
 #self.with_polymorphic[0] + (subcl,), self.with_polymorphic[1])
 #

 #ef _set_concrete_base(self, mapper):
 #""Set the given :class:`_orm.Mapper` as the 'inherits' for this
 #class:`_orm.Mapper`, assuming this :class:`_orm.Mapper` is concrete
 #nd does not already have an inherits."""

 #ssert self.concrete
 #ssert not self.inherits
 #ssert isinstance(mapper, Mapper)
 #elf.inherits = mapper
 #elf.inherits.polymorphic_map.update(self.polymorphic_map)
 #elf.polymorphic_map = self.inherits.polymorphic_map
 #or mapper in self.iterate_to_root():
 #f mapper.polymorphic_on is not None:
 #apper._requires_row_aliasing = True
 #elf.batch = self.inherits.batch
 #or mp in self.self_and_descendants:
 #p.base_mapper = self.inherits.base_mapper
 #elf.inherits._inheriting_mappers.append(self)
 #elf.passive_updates = self.inherits.passive_updates
 #elf._all_tables = self.inherits._all_tables

 #or key, prop in mapper._props.items():
 #f key not in self._props and not self._should_exclude(
 #ey, key, local=False, column=None
 #:
 #elf._adapt_inherited_property(key, prop, False)

 #ef _set_polymorphic_on(self, polymorphic_on):
 #elf.polymorphic_on = polymorphic_on
 #elf._configure_polymorphic_setter(True)

 #ef _configure_class_instrumentation(self):
 #""If this mapper is to be a primary mapper (i.e. the
 #on_primary flag is not set), associate this Mapper with the
 #iven class and entity name.

 #ubsequent calls to ``class_mapper()`` for the ``class_`` / ``entity``
 #ame combination will return this mapper.  Also decorate the
 #__init__` method on the mapped class to include optional
 #uto-session attachment logic.

 #""

        # we expect that declarative has applied the class manager
        # already and set up a registry.  if this is None,
        # we will emit a deprecation warning below when we also see that
        # it has no registry.
 #anager = attributes.manager_of_class(self.class_)

 #f self.non_primary:
 #f not manager or not manager.is_mapped:
 #aise sa_exc.InvalidRequestError(
 #Class %s has no primary mapper configured.  Configure "
 #a primary mapper first before setting up a non primary "
 #Mapper." % self.class_
 #
 #elf.class_manager = manager
 #elf.registry = manager.registry
 #elf._identity_class = manager.mapper._identity_class
 #anager.registry._add_non_primary_mapper(self)
 #eturn

 #f manager is not None:
 #ssert manager.class_ is self.class_
 #f manager.is_mapped:
 #aise sa_exc.ArgumentError(
 #Class '%s' already has a primary mapper defined. "
 # self.class_
 #
            # else:
            # a ClassManager may already exist as
            # ClassManager.instrument_attribute() creates
            # new managers for each subclass if they don't yet exist.

 #elf.dispatch.instrument_class(self, self.class_)

        # this invokes the class_instrument event and sets up
        # the __init__ method.  documented behavior is that this must
        # occur after the instrument_class event above.
        # yes two events with the same two words reversed and different APIs.
        # :(

 #anager = instrumentation.register_class(
 #elf.class_,
 #apper=self,
 #xpired_attribute_loader=util.partial(
 #oading.load_scalar_attributes, self
 #,
            # finalize flag means instrument the __init__ method
            # and call the class_instrument event
 #inalize=True,
 #

 #f not manager.registry:
 #til.warn_deprecated_20(
 #Calling the mapper() function directly outside of a "
 #declarative registry is deprecated."
 # Please use the sqlalchemy.orm.registry.map_imperatively() "
 #function for a classical mapping."
 #
 #ssert _legacy_registry is not None
 #legacy_registry._add_manager(manager)

 #elf.class_manager = manager
 #elf.registry = manager.registry

        # The remaining members can be added by any mapper,
        # e_name None or not.
 #f manager.mapper is None:
 #eturn

 #vent.listen(manager, "init", _event_on_init, raw=True)

 #or key, method in util.iterate_attributes(self.class_):
 #f key == "__init__" and hasattr(method, "_sa_original_init"):
 #ethod = method._sa_original_init
 #f hasattr(method, "__func__"):
 #ethod = method.__func__
 #f callable(method):
 #f hasattr(method, "__sa_reconstructor__"):
 #elf._reconstructor = method
 #vent.listen(manager, "load", _event_on_load, raw=True)
 #lif hasattr(method, "__sa_validators__"):
 #alidation_opts = method.__sa_validation_opts__
 #or name in method.__sa_validators__:
 #f name in self.validators:
 #aise sa_exc.InvalidRequestError(
 #A validation function for mapped "
 #attribute %r on mapper %s already exists."
 # (name, self)
 #
 #elf.validators = self.validators.union(
 #name: (method, validation_opts)}
 #

 #ef _set_dispose_flags(self):
 #elf.configured = True
 #elf._ready_for_configure = True
 #elf._dispose_called = True

 #elf.__dict__.pop("_configure_failed", None)

 #ef _configure_pks(self):
 #elf.tables = sql_util.find_tables(self.persist_selectable)

 #elf._pks_by_table = {}
 #elf._cols_by_table = {}

 #ll_cols = util.column_set(
 #hain(*[col.proxy_set for col in self._columntoproperty])
 #

 #k_cols = util.column_set(c for c in all_cols if c.primary_key)

        # identify primary key columns which are also mapped by this mapper.
 #ables = set(self.tables + [self.persist_selectable])
 #elf._all_tables.update(tables)
 #or t in tables:
 #f t.primary_key and pk_cols.issuperset(t.primary_key):
                # ordering is important since it determines the ordering of
                # mapper.primary_key (and therefore query.get())
 #elf._pks_by_table[t] = util.ordered_column_set(
 #.primary_key
 #.intersection(pk_cols)
 #elf._cols_by_table[t] = util.ordered_column_set(t.c).intersection(
 #ll_cols
 #

        # if explicit PK argument sent, add those columns to the
        # primary key mappings
 #f self._primary_key_argument:
 #or k in self._primary_key_argument:
 #f k.table not in self._pks_by_table:
 #elf._pks_by_table[k.table] = util.OrderedSet()
 #elf._pks_by_table[k.table].add(k)

        # otherwise, see that we got a full PK for the mapped table
 #lif (
 #elf.persist_selectable not in self._pks_by_table
 #r len(self._pks_by_table[self.persist_selectable]) == 0
 #:
 #aise sa_exc.ArgumentError(
 #Mapper %s could not assemble any primary "
 #key columns for mapped table '%s'"
 # (self, self.persist_selectable.description)
 #
 #lif self.local_table not in self._pks_by_table and isinstance(
 #elf.local_table, schema.Table
 #:
 #til.warn(
 #Could not assemble any primary "
 #keys for locally mapped table '%s' - "
 #no rows will be persisted in this Table."
 # self.local_table.description
 #

 #f (
 #elf.inherits
 #nd not self.concrete
 #nd not self._primary_key_argument
 #:
            # if inheriting, the "primary key" for this mapper is
            # that of the inheriting (unless concrete or explicit)
 #elf.primary_key = self.inherits.primary_key
 #lse:
            # determine primary key from argument or persist_selectable pks -
            # reduce to the minimal set of columns
 #f self._primary_key_argument:
 #rimary_key = sql_util.reduce_columns(
 #
 #elf.persist_selectable.corresponding_column(c)
 #or c in self._primary_key_argument
 #,
 #gnore_nonexistent_tables=True,
 #
 #lse:
 #rimary_key = sql_util.reduce_columns(
 #elf._pks_by_table[self.persist_selectable],
 #gnore_nonexistent_tables=True,
 #

 #f len(primary_key) == 0:
 #aise sa_exc.ArgumentError(
 #Mapper %s could not assemble any primary "
 #key columns for mapped table '%s'"
 # (self, self.persist_selectable.description)
 #

 #elf.primary_key = tuple(primary_key)
 #elf._log("Identified primary key columns: %s", primary_key)

        # determine cols that aren't expressed within our tables; mark these
        # as "read only" properties which are refreshed upon INSERT/UPDATE
 #elf._readonly_props = set(
 #elf._columntoproperty[col]
 #or col in self._columntoproperty
 #f self._columntoproperty[col] not in self._identity_key_props
 #nd (
 #ot hasattr(col, "table")
 #r col.table not in self._cols_by_table
 #
 #

 #ef _configure_properties(self):
        # Column and other ClauseElement objects which are mapped

        # TODO: technically this should be a DedupeColumnCollection
        # however DCC needs changes and more tests to fully cover
        # storing columns under a separate key name
 #elf.columns = self.c = sql_base.ColumnCollection()

        # object attribute names mapped to MapperProperty objects
 #elf._props = util.OrderedDict()

        # table columns mapped to lists of MapperProperty objects
        # using a list allows a single column to be defined as
        # populating multiple object attributes
 #elf._columntoproperty = _ColumnMapping(self)

        # load custom properties
 #f self._init_properties:
 #or key, prop in self._init_properties.items():
 #elf._configure_property(key, prop, False)

        # pull properties from the inherited mapper if any.
 #f self.inherits:
 #or key, prop in self.inherits._props.items():
 #f key not in self._props and not self._should_exclude(
 #ey, key, local=False, column=None
 #:
 #elf._adapt_inherited_property(key, prop, False)

        # create properties for each column in the mapped table,
        # for those columns which don't already map to a property
 #or column in self.persist_selectable.columns:
 #f column in self._columntoproperty:
 #ontinue

 #olumn_key = (self.column_prefix or "") + column.key

 #f self._should_exclude(
 #olumn.key,
 #olumn_key,
 #ocal=self.local_table.c.contains_column(column),
 #olumn=column,
 #:
 #ontinue

            # adjust the "key" used for this column to that
            # of the inheriting mapper
 #or mapper in self.iterate_to_root():
 #f column in mapper._columntoproperty:
 #olumn_key = mapper._columntoproperty[column].key

 #elf._configure_property(
 #olumn_key, column, init=False, setparent=True
 #

 #ef _configure_polymorphic_setter(self, init=False):
 #""Configure an attribute on the mapper representing the
 #polymorphic_on' column, if applicable, and not
 #lready generated by _configure_properties (which is typical).

 #lso create a setter function which will assign this
 #ttribute to the value of the 'polymorphic_identity'
 #pon instance construction, also if applicable.  This
 #outine will run when an instance is created.

 #""
 #etter = False

 #f self.polymorphic_on is not None:
 #etter = True

 #f isinstance(self.polymorphic_on, util.string_types):
                # polymorphic_on specified as a string - link
                # it to mapped ColumnProperty
 #ry:
 #elf.polymorphic_on = self._props[self.polymorphic_on]
 #xcept KeyError as err:
 #til.raise_(
 #a_exc.ArgumentError(
 #Can't determine polymorphic_on "
 #value '%s' - no attribute is "
 #mapped to this name." % self.polymorphic_on
 #,
 #eplace_context=err,
 #

 #f self.polymorphic_on in self._columntoproperty:
                # polymorphic_on is a column that is already mapped
                # to a ColumnProperty
 #rop = self._columntoproperty[self.polymorphic_on]
 #lif isinstance(self.polymorphic_on, MapperProperty):
                # polymorphic_on is directly a MapperProperty,
                # ensure it's a ColumnProperty
 #f not isinstance(
 #elf.polymorphic_on, properties.ColumnProperty
 #:
 #aise sa_exc.ArgumentError(
 #Only direct column-mapped "
 #property or SQL expression "
 #can be passed for polymorphic_on"
 #
 #rop = self.polymorphic_on
 #lse:
                # polymorphic_on is a Column or SQL expression and
                # doesn't appear to be mapped. this means it can be 1.
                # only present in the with_polymorphic selectable or
                # 2. a totally standalone SQL expression which we'd
                # hope is compatible with this mapper's persist_selectable
 #ol = self.persist_selectable.corresponding_column(
 #elf.polymorphic_on
 #
 #f col is None:
                    # polymorphic_on doesn't derive from any
                    # column/expression isn't present in the mapped
                    # table. we will make a "hidden" ColumnProperty
                    # for it. Just check that if it's directly a
                    # schema.Column and we have with_polymorphic, it's
                    # likely a user error if the schema.Column isn't
                    # represented somehow in either persist_selectable or
                    # with_polymorphic.   Otherwise as of 0.7.4 we
                    # just go with it and assume the user wants it
                    # that way (i.e. a CASE statement)
 #etter = False
 #nstrument = False
 #ol = self.polymorphic_on
 #f isinstance(col, schema.Column) and (
 #elf.with_polymorphic is None
 #r self.with_polymorphic[1].corresponding_column(col)
 #s None
 #:
 #aise sa_exc.InvalidRequestError(
 #Could not map polymorphic_on column "
 #'%s' to the mapped table - polymorphic "
 #loads will not function properly"
 # col.description
 #
 #lse:
                    # column/expression that polymorphic_on derives from
                    # is present in our mapped table
                    # and is probably mapped, but polymorphic_on itself
                    # is not.  This happens when
                    # the polymorphic_on is only directly present in the
                    # with_polymorphic selectable, as when use
                    # polymorphic_union.
                    # we'll make a separate ColumnProperty for it.
 #nstrument = True
 #ey = getattr(col, "key", None)
 #f key:
 #f self._should_exclude(col.key, col.key, False, col):
 #aise sa_exc.InvalidRequestError(
 #Cannot exclude or override the "
 #discriminator column %r" % col.key
 #
 #lse:
 #elf.polymorphic_on = col = col.label("_sa_polymorphic_on")
 #ey = col.key

 #rop = properties.ColumnProperty(col, _instrument=instrument)
 #elf._configure_property(key, prop, init=init, setparent=True)

            # the actual polymorphic_on should be the first public-facing
            # column in the property
 #elf.polymorphic_on = prop.columns[0]
 #olymorphic_key = prop.key

 #lse:
            # no polymorphic_on was set.
            # check inheriting mappers for one.
 #or mapper in self.iterate_to_root():
                # determine if polymorphic_on of the parent
                # should be propagated here.   If the col
                # is present in our mapped table, or if our mapped
                # table is the same as the parent (i.e. single table
                # inheritance), we can use it
 #f mapper.polymorphic_on is not None:
 #f self.persist_selectable is mapper.persist_selectable:
 #elf.polymorphic_on = mapper.polymorphic_on
 #lse:
 #elf.polymorphic_on = (
 #elf.persist_selectable
 #.corresponding_column(mapper.polymorphic_on)
                    # we can use the parent mapper's _set_polymorphic_identity
                    # directly; it ensures the polymorphic_identity of the
                    # instance's mapper is used so is portable to subclasses.
 #f self.polymorphic_on is not None:
 #elf._set_polymorphic_identity = (
 #apper._set_polymorphic_identity
 #
 #elf._validate_polymorphic_identity = (
 #apper._validate_polymorphic_identity
 #
 #lse:
 #elf._set_polymorphic_identity = None
 #eturn

 #f setter:

 #ef _set_polymorphic_identity(state):
 #ict_ = state.dict
 #tate.get_impl(polymorphic_key).set(
 #tate,
 #ict_,
 #tate.manager.mapper.polymorphic_identity,
 #one,
 #

 #ef _validate_polymorphic_identity(mapper, state, dict_):
 #f (
 #olymorphic_key in dict_
 #nd dict_[polymorphic_key]
 #ot in mapper._acceptable_polymorphic_identities
 #:
 #til.warn_limited(
 #Flushing object %s with "
 #incompatible polymorphic identity %r; the "
 #object may not refresh and/or load correctly",
 #state_str(state), dict_[polymorphic_key]),
 #

 #elf._set_polymorphic_identity = _set_polymorphic_identity
 #elf._validate_polymorphic_identity = (
 #validate_polymorphic_identity
 #
 #lse:
 #elf._set_polymorphic_identity = None

 #validate_polymorphic_identity = None

 #HasMemoized.memoized_attribute
 #ef _version_id_prop(self):
 #f self.version_id_col is not None:
 #eturn self._columntoproperty[self.version_id_col]
 #lse:
 #eturn None

 #HasMemoized.memoized_attribute
 #ef _acceptable_polymorphic_identities(self):
 #dentities = set()

 #tack = deque([self])
 #hile stack:
 #tem = stack.popleft()
 #f item.persist_selectable is self.persist_selectable:
 #dentities.add(item.polymorphic_identity)
 #tack.extend(item._inheriting_mappers)

 #eturn identities

 #HasMemoized.memoized_attribute
 #ef _prop_set(self):
 #eturn frozenset(self._props.values())

 #util.preload_module("sqlalchemy.orm.descriptor_props")
 #ef _adapt_inherited_property(self, key, prop, init):
 #escriptor_props = util.preloaded.orm_descriptor_props

 #f not self.concrete:
 #elf._configure_property(key, prop, init=False, setparent=False)
 #lif key not in self._props:
            # determine if the class implements this attribute; if not,
            # or if it is implemented by the attribute that is handling the
            # given superclass-mapped property, then we need to report that we
            # can't use this at the instance level since we are a concrete
            # mapper and we don't map this.  don't trip user-defined
            # descriptors that might have side effects when invoked.
 #mplementing_attribute = self.class_manager._get_class_attr_mro(
 #ey, prop
 #
 #f implementing_attribute is prop or (
 #sinstance(
 #mplementing_attribute, attributes.InstrumentedAttribute
 #
 #nd implementing_attribute._parententity is prop.parent
 #:
 #elf._configure_property(
 #ey,
 #escriptor_props.ConcreteInheritedProperty(),
 #nit=init,
 #etparent=True,
 #

 #util.preload_module("sqlalchemy.orm.descriptor_props")
 #ef _configure_property(self, key, prop, init=True, setparent=True):
 #escriptor_props = util.preloaded.orm_descriptor_props
 #elf._log("_configure_property(%s, %s)", key, prop.__class__.__name__)

 #f not isinstance(prop, MapperProperty):
 #rop = self._property_from_column(key, prop)

 #f isinstance(prop, properties.ColumnProperty):
 #ol = self.persist_selectable.corresponding_column(prop.columns[0])

            # if the column is not present in the mapped table,
            # test if a column has been added after the fact to the
            # parent table (or their parent, etc.) [ticket:1570]
 #f col is None and self.inherits:
 #ath = [self]
 #or m in self.inherits.iterate_to_root():
 #ol = m.local_table.corresponding_column(prop.columns[0])
 #f col is not None:
 #or m2 in path:
 #2.persist_selectable._refresh_for_new_column(col)
 #ol = self.persist_selectable.corresponding_column(
 #rop.columns[0]
 #
 #reak
 #ath.append(m)

            # subquery expression, column not present in the mapped
            # selectable.
 #f col is None:
 #ol = prop.columns[0]

                # column is coming in after _readonly_props was
                # initialized; check for 'readonly'
 #f hasattr(self, "_readonly_props") and (
 #ot hasattr(col, "table")
 #r col.table not in self._cols_by_table
 #:
 #elf._readonly_props.add(prop)

 #lse:
                # if column is coming in after _cols_by_table was
                # initialized, ensure the col is in the right set
 #f (
 #asattr(self, "_cols_by_table")
 #nd col.table in self._cols_by_table
 #nd col not in self._cols_by_table[col.table]
 #:
 #elf._cols_by_table[col.table].add(col)

            # if this properties.ColumnProperty represents the "polymorphic
            # discriminator" column, mark it.  We'll need this when rendering
            # columns in SELECT statements.
 #f not hasattr(prop, "_is_polymorphic_discriminator"):
 #rop._is_polymorphic_discriminator = (
 #ol is self.polymorphic_on
 #r prop.columns[0] is self.polymorphic_on
 #

 #f isinstance(col, expression.Label):
                # new in 1.4, get column property against expressions
                # to be addressable in subqueries
 #ol.key = col._tq_key_label = key

 #elf.columns.add(col, key)
 #or col in prop.columns + prop._orig_columns:
 #or col in col.proxy_set:
 #elf._columntoproperty[col] = prop

 #rop.key = key

 #f setparent:
 #rop.set_parent(self, init)

 #f key in self._props and getattr(
 #elf._props[key], "_mapped_by_synonym", False
 #:
 #yn = self._props[key]._mapped_by_synonym
 #aise sa_exc.ArgumentError(
 #Can't call map_column=True for synonym %r=%r, "
 #a ColumnProperty already exists keyed to the name "
 #%r for column %r" % (syn, key, key, syn)
 #

 #f (
 #ey in self._props
 #nd not isinstance(prop, properties.ColumnProperty)
 #nd not isinstance(
 #elf._props[key],
 #
 #roperties.ColumnProperty,
 #escriptor_props.ConcreteInheritedProperty,
 #,
 #
 #:
 #til.warn(
 #Property %s on %s being replaced with new "
 #property %s; the old property will be discarded"
 # (self._props[key], self, prop)
 #
 #ldprop = self._props[key]
 #elf._path_registry.pop(oldprop, None)

 #elf._props[key] = prop

 #f not self.non_primary:
 #rop.instrument_class(self)

 #or mapper in self._inheriting_mappers:
 #apper._adapt_inherited_property(key, prop, init)

 #f init:
 #rop.init()
 #rop.post_instrument_class(self)

 #f self.configured:
 #elf._expire_memoizations()

 #util.preload_module("sqlalchemy.orm.descriptor_props")
 #ef _property_from_column(self, key, prop):
 #""generate/update a :class:`.ColumnProperty` given a
 #class:`_schema.Column` object."""
 #escriptor_props = util.preloaded.orm_descriptor_props
        # we were passed a Column or a list of Columns;
        # generate a properties.ColumnProperty
 #olumns = util.to_list(prop)
 #olumn = columns[0]
 #ssert isinstance(column, expression.ColumnElement)

 #rop = self._props.get(key, None)

 #f isinstance(prop, properties.ColumnProperty):
 #f (
 #
 #ot self._inherits_equated_pairs
 #r (prop.columns[0], column)
 #ot in self._inherits_equated_pairs
 #
 #nd not prop.columns[0].shares_lineage(column)
 #nd prop.columns[0] is not self.version_id_col
 #nd column is not self.version_id_col
 #:
 #arn_only = prop.parent is not self
 #sg = (
 #Implicitly combining column %s with column "
 #%s under attribute '%s'.  Please configure one "
 #or more attributes for these same-named columns "
 #explicitly." % (prop.columns[-1], column, key)
 #
 #f warn_only:
 #til.warn(msg)
 #lse:
 #aise sa_exc.InvalidRequestError(msg)

            # existing properties.ColumnProperty from an inheriting
            # mapper. make a copy and append our column to it
 #rop = prop.copy()
 #rop.columns.insert(0, column)
 #elf._log(
 #inserting column to existing list "
 #in properties.ColumnProperty %s" % (key)
 #
 #eturn prop
 #lif prop is None or isinstance(
 #rop, descriptor_props.ConcreteInheritedProperty
 #:
 #apped_column = []
 #or c in columns:
 #c = self.persist_selectable.corresponding_column(c)
 #f mc is None:
 #c = self.local_table.corresponding_column(c)
 #f mc is not None:
                        # if the column is in the local table but not the
                        # mapped table, this corresponds to adding a
                        # column after the fact to the local table.
                        # [ticket:1523]
 #elf.persist_selectable._refresh_for_new_column(mc)
 #c = self.persist_selectable.corresponding_column(c)
 #f mc is None:
 #aise sa_exc.ArgumentError(
 #When configuring property '%s' on %s, "
 #column '%s' is not represented in the mapper's "
 #table. Use the `column_property()` function to "
 #force this column to be mapped as a read-only "
 #attribute." % (key, self, c)
 #
 #apped_column.append(mc)
 #eturn properties.ColumnProperty(*mapped_column)
 #lse:
 #aise sa_exc.ArgumentError(
 #WARNING: when configuring property '%s' on %s, "
 #column '%s' conflicts with property '%r'. "
 #To resolve this, map the column to the class under a "
 #different name in the 'properties' dictionary.  Or, "
 #to remove all awareness of the column entirely "
 #(including its availability as a foreign key), "
 #use the 'include_properties' or 'exclude_properties' "
 #mapper arguments to control specifically which table "
 #columns get mapped." % (key, self, column.key, prop)
 #

 #ef _check_configure(self):
 #f self.registry._new_mappers:
 #configure_registries({self.registry}, cascade=True)

 #ef _post_configure_properties(self):
 #""Call the ``init()`` method on all ``MapperProperties``
 #ttached to this mapper.

 #his is a deferred configuration step which is intended
 #o execute once all mappers have been constructed.

 #""

 #elf._log("_post_configure_properties() started")
 # = [(key, prop) for key, prop in self._props.items()]
 #or key, prop in l:
 #elf._log("initialize prop %s", key)

 #f prop.parent is self and not prop._configure_started:
 #rop.init()

 #f prop._configure_finished:
 #rop.post_instrument_class(self)

 #elf._log("_post_configure_properties() complete")
 #elf.configured = True

 #ef add_properties(self, dict_of_properties):
 #""Add the given dictionary of properties to this mapper,
 #sing `add_property`.

 #""
 #or key, value in dict_of_properties.items():
 #elf.add_property(key, value)

 #ef add_property(self, key, prop):
 #""Add an individual MapperProperty to this mapper.

 #f the mapper has not been configured yet, just adds the
 #roperty to the initial properties dictionary sent to the
 #onstructor.  If this Mapper has already been configured, then
 #he given MapperProperty is configured immediately.

 #""
 #elf._init_properties[key] = prop
 #elf._configure_property(key, prop, init=self.configured)

 #ef _expire_memoizations(self):
 #or mapper in self.iterate_to_root():
 #apper._reset_memoizations()

 #property
 #ef _log_desc(self):
 #eturn (
 #("
 # self.class_.__name__
 # "|"
 # (
 #elf.local_table is not None
 #nd self.local_table.description
 #r str(self.local_table)
 #
 # (self.non_primary and "|non-primary" or "")
 # ")"
 #

 #ef _log(self, msg, *args):
 #elf.logger.info("%s " + msg, *((self._log_desc,) + args))

 #ef _log_debug(self, msg, *args):
 #elf.logger.debug("%s " + msg, *((self._log_desc,) + args))

 #ef __repr__(self):
 #eturn "<Mapper at 0x%x; %s>" % (id(self), self.class_.__name__)

 #ef __str__(self):
 #eturn "mapped class %s%s->%s" % (
 #elf.class_.__name__,
 #elf.non_primary and " (non-primary)" or "",
 #elf.local_table.description
 #f self.local_table is not None
 #lse self.persist_selectable.description,
 #

 #ef _is_orphan(self, state):
 #rphan_possible = False
 #or mapper in self.iterate_to_root():
 #or (key, cls) in mapper._delete_orphans:
 #rphan_possible = True

 #as_parent = attributes.manager_of_class(cls).has_parent(
 #tate, key, optimistic=state.has_identity
 #

 #f self.legacy_is_orphan and has_parent:
 #eturn False
 #lif not self.legacy_is_orphan and not has_parent:
 #eturn True

 #f self.legacy_is_orphan:
 #eturn orphan_possible
 #lse:
 #eturn False

 #ef has_property(self, key):
 #eturn key in self._props

 #ef get_property(self, key, _configure_mappers=True):
 #""return a MapperProperty associated with the given key."""

 #f _configure_mappers:
 #elf._check_configure()

 #ry:
 #eturn self._props[key]
 #xcept KeyError as err:
 #til.raise_(
 #a_exc.InvalidRequestError(
 #Mapper '%s' has no property '%s'" % (self, key)
 #,
 #eplace_context=err,
 #

 #ef get_property_by_column(self, column):
 #""Given a :class:`_schema.Column` object, return the
 #class:`.MapperProperty` which maps this column."""

 #eturn self._columntoproperty[column]

 #property
 #ef iterate_properties(self):
 #""return an iterator of all MapperProperty objects."""

 #elf._check_configure()
 #eturn iter(self._props.values())

 #ef _mappers_from_spec(self, spec, selectable):
 #""given a with_polymorphic() argument, return the set of mappers it
 #epresents.

 #rims the list of mappers to just those represented within the given
 #electable, if present. This helps some more legacy-ish mappings.

 #""
 #f spec == "*":
 #appers = list(self.self_and_descendants)
 #lif spec:
 #appers = set()
 #or m in util.to_list(spec):
 # = _class_to_mapper(m)
 #f not m.isa(self):
 #aise sa_exc.InvalidRequestError(
 #%r does not inherit from %r" % (m, self)
 #

 #f selectable is None:
 #appers.update(m.iterate_to_root())
 #lse:
 #appers.add(m)
 #appers = [m for m in self.self_and_descendants if m in mappers]
 #lse:
 #appers = []

 #f selectable is not None:
 #ables = set(
 #ql_util.find_tables(selectable, include_aliases=True)
 #
 #appers = [m for m in mappers if m.local_table in tables]
 #eturn mappers

 #ef _selectable_from_mappers(self, mappers, innerjoin):
 #""given a list of mappers (assumed to be within this mapper's
 #nheritance hierarchy), construct an outerjoin amongst those mapper's
 #apped tables.

 #""
 #rom_obj = self.persist_selectable
 #or m in mappers:
 #f m is self:
 #ontinue
 #f m.concrete:
 #aise sa_exc.InvalidRequestError(
 #'with_polymorphic()' requires 'selectable' argument "
 #when concrete-inheriting mappers are used."
 #
 #lif not m.single:
 #f innerjoin:
 #rom_obj = from_obj.join(
 #.local_table, m.inherit_condition
 #
 #lse:
 #rom_obj = from_obj.outerjoin(
 #.local_table, m.inherit_condition
 #

 #eturn from_obj

 #HasMemoized.memoized_attribute
 #ef _single_table_criterion(self):
 #f self.single and self.inherits and self.polymorphic_on is not None:
 #eturn self.polymorphic_on._annotate({"parentmapper": self}).in_(
 #.polymorphic_identity for m in self.self_and_descendants
 #
 #lse:
 #eturn None

 #HasMemoized.memoized_attribute
 #ef _with_polymorphic_mappers(self):
 #elf._check_configure()

 #f not self.with_polymorphic:
 #eturn []
 #eturn self._mappers_from_spec(*self.with_polymorphic)

 #HasMemoized.memoized_attribute
 #ef _post_inspect(self):
 #""This hook is invoked by attribute inspection.

 #.g. when Query calls:

 #oercions.expect(roles.ColumnsClauseRole, ent, keep_inspect=True)

 #his allows the inspection process run a configure mappers hook.

 #""
 #elf._check_configure()

 #HasMemoized.memoized_attribute
 #ef _with_polymorphic_selectable(self):
 #f not self.with_polymorphic:
 #eturn self.persist_selectable

 #pec, selectable = self.with_polymorphic
 #f selectable is not None:
 #eturn selectable
 #lse:
 #eturn self._selectable_from_mappers(
 #elf._mappers_from_spec(spec, selectable), False
 #

 #ith_polymorphic_mappers = _with_polymorphic_mappers
 #""The list of :class:`_orm.Mapper` objects included in the
 #efault "polymorphic" query.

 #""

 #HasMemoized.memoized_attribute
 #ef _insert_cols_evaluating_none(self):
 #eturn dict(
 #
 #able,
 #rozenset(
 #ol for col in columns if col.type.should_evaluate_none
 #,
 #
 #or table, columns in self._cols_by_table.items()
 #

 #HasMemoized.memoized_attribute
 #ef _insert_cols_as_none(self):
 #eturn dict(
 #
 #able,
 #rozenset(
 #ol.key
 #or col in columns
 #f not col.primary_key
 #nd not col.server_default
 #nd not col.default
 #nd not col.type.should_evaluate_none
 #,
 #
 #or table, columns in self._cols_by_table.items()
 #

 #HasMemoized.memoized_attribute
 #ef _propkey_to_col(self):
 #eturn dict(
 #
 #able,
 #ict(
 #self._columntoproperty[col].key, col) for col in columns
 #,
 #
 #or table, columns in self._cols_by_table.items()
 #

 #HasMemoized.memoized_attribute
 #ef _pk_keys_by_table(self):
 #eturn dict(
 #table, frozenset([col.key for col in pks]))
 #or table, pks in self._pks_by_table.items()
 #

 #HasMemoized.memoized_attribute
 #ef _pk_attr_keys_by_table(self):
 #eturn dict(
 #
 #able,
 #rozenset([self._columntoproperty[col].key for col in pks]),
 #
 #or table, pks in self._pks_by_table.items()
 #

 #HasMemoized.memoized_attribute
 #ef _server_default_cols(self):
 #eturn dict(
 #
 #able,
 #rozenset(
 #
 #ol.key
 #or col in columns
 #f col.server_default is not None
 #
 #,
 #
 #or table, columns in self._cols_by_table.items()
 #

 #HasMemoized.memoized_attribute
 #ef _server_default_plus_onupdate_propkeys(self):
 #esult = set()

 #or table, columns in self._cols_by_table.items():
 #or col in columns:
 #f (
 #ol.server_default is not None
 #r col.server_onupdate is not None
 # and col in self._columntoproperty:
 #esult.add(self._columntoproperty[col].key)

 #eturn result

 #HasMemoized.memoized_attribute
 #ef _server_onupdate_default_cols(self):
 #eturn dict(
 #
 #able,
 #rozenset(
 #
 #ol.key
 #or col in columns
 #f col.server_onupdate is not None
 #
 #,
 #
 #or table, columns in self._cols_by_table.items()
 #

 #HasMemoized.memoized_instancemethod
 #ef __clause_element__(self):

 #nnotations = {
 #entity_namespace": self,
 #parententity": self,
 #parentmapper": self,
 #
 #f self.persist_selectable is not self.local_table:
            # joined table inheritance, with polymorphic selectable,
            # etc.
 #nnotations["dml_table"] = self.local_table._annotate(
 #
 #entity_namespace": self,
 #parententity": self,
 #parentmapper": self,
 #
 #._set_propagate_attrs(
 #"compile_state_plugin": "orm", "plugin_subject": self}
 #

 #eturn self.selectable._annotate(annotations)._set_propagate_attrs(
 #"compile_state_plugin": "orm", "plugin_subject": self}
 #

 #util.memoized_property
 #ef select_identity_token(self):
 #eturn (
 #xpression.null()
 #_annotate(
 #
 #entity_namespace": self,
 #parententity": self,
 #parentmapper": self,
 #identity_token": True,
 #
 #
 #_set_propagate_attrs(
 #"compile_state_plugin": "orm", "plugin_subject": self}
 #
 #

 #property
 #ef selectable(self):
 #""The :class:`_schema.FromClause` construct this
 #class:`_orm.Mapper` selects from by default.

 #ormally, this is equivalent to :attr:`.persist_selectable`, unless
 #he ``with_polymorphic`` feature is in use, in which case the
 #ull "polymorphic" selectable is returned.

 #""
 #eturn self._with_polymorphic_selectable

 #ef _with_polymorphic_args(
 #elf, spec=None, selectable=False, innerjoin=False
 #:
 #f selectable not in (None, False):
 #electable = coercions.expect(
 #oles.StrictFromClauseRole, selectable, allow_select=True
 #

 #f self.with_polymorphic:
 #f not spec:
 #pec = self.with_polymorphic[0]
 #f selectable is False:
 #electable = self.with_polymorphic[1]
 #lif selectable is False:
 #electable = None
 #appers = self._mappers_from_spec(spec, selectable)
 #f selectable is not None:
 #eturn mappers, selectable
 #lse:
 #eturn mappers, self._selectable_from_mappers(mappers, innerjoin)

 #HasMemoized.memoized_attribute
 #ef _polymorphic_properties(self):
 #eturn list(
 #elf._iterate_polymorphic_properties(
 #elf._with_polymorphic_mappers
 #
 #

 #property
 #ef _all_column_expressions(self):
 #oly_properties = self._polymorphic_properties
 #dapter = self._polymorphic_adapter

 #eturn [
 #dapter.columns[prop.columns[0]] if adapter else prop.columns[0]
 #or prop in poly_properties
 #f isinstance(prop, properties.ColumnProperty)
 #nd prop._renders_in_subqueries
 #

 #ef _columns_plus_keys(self, polymorphic_mappers=()):
 #f polymorphic_mappers:
 #oly_properties = self._iterate_polymorphic_properties(
 #olymorphic_mappers
 #
 #lse:
 #oly_properties = self._polymorphic_properties

 #eturn [
 #prop.key, prop.columns[0])
 #or prop in poly_properties
 #f isinstance(prop, properties.ColumnProperty)
 #

 #HasMemoized.memoized_attribute
 #ef _polymorphic_adapter(self):
 #f self.with_polymorphic:
 #eturn sql_util.ColumnAdapter(
 #elf.selectable, equivalents=self._equivalent_columns
 #
 #lse:
 #eturn None

 #ef _iterate_polymorphic_properties(self, mappers=None):
 #""Return an iterator of MapperProperty objects which will render into
 # SELECT."""
 #f mappers is None:
 #appers = self._with_polymorphic_mappers

 #f not mappers:
 #or c in self.iterate_properties:
 #ield c
 #lse:
            # in the polymorphic case, filter out discriminator columns
            # from other mappers, as these are sometimes dependent on that
            # mapper's polymorphic selectable (which we don't want rendered)
 #or c in util.unique_list(
 #hain(
 #[
 #ist(mapper.iterate_properties)
 #or mapper in [self] + mappers
 #
 #
 #:
 #f getattr(c, "_is_polymorphic_discriminator", False) and (
 #elf.polymorphic_on is None
 #r c.columns[0] is not self.polymorphic_on
 #:
 #ontinue
 #ield c

 #HasMemoized.memoized_attribute
 #ef attrs(self):
 #""A namespace of all :class:`.MapperProperty` objects
 #ssociated this mapper.

 #his is an object that provides each property based on
 #ts key name.  For instance, the mapper for a
 #`User`` class which has ``User.name`` attribute would
 #rovide ``mapper.attrs.name``, which would be the
 #class:`.ColumnProperty` representing the ``name``
 #olumn.   The namespace object can also be iterated,
 #hich would yield each :class:`.MapperProperty`.

 #class:`_orm.Mapper` has several pre-filtered views
 #f this attribute which limit the types of properties
 #eturned, including :attr:`.synonyms`, :attr:`.column_attrs`,
 #attr:`.relationships`, and :attr:`.composites`.

 #. warning::

 #he :attr:`_orm.Mapper.attrs` accessor namespace is an
 #nstance of :class:`.OrderedProperties`.  This is
 # dictionary-like object which includes a small number of
 #amed methods such as :meth:`.OrderedProperties.items`
 #nd :meth:`.OrderedProperties.values`.  When
 #ccessing attributes dynamically, favor using the dict-access
 #cheme, e.g. ``mapper.attrs[somename]`` over
 #`getattr(mapper.attrs, somename)`` to avoid name collisions.

 #. seealso::

 #attr:`_orm.Mapper.all_orm_descriptors`

 #""

 #elf._check_configure()
 #eturn util.ImmutableProperties(self._props)

 #HasMemoized.memoized_attribute
 #ef all_orm_descriptors(self):
 #""A namespace of all :class:`.InspectionAttr` attributes associated
 #ith the mapped class.

 #hese attributes are in all cases Python :term:`descriptors`
 #ssociated with the mapped class or its superclasses.

 #his namespace includes attributes that are mapped to the class
 #s well as attributes declared by extension modules.
 #t includes any Python descriptor type that inherits from
 #class:`.InspectionAttr`.  This includes
 #class:`.QueryableAttribute`, as well as extension types such as
 #class:`.hybrid_property`, :class:`.hybrid_method` and
 #class:`.AssociationProxy`.

 #o distinguish between mapped attributes and extension attributes,
 #he attribute :attr:`.InspectionAttr.extension_type` will refer
 #o a constant that distinguishes between different extension types.

 #he sorting of the attributes is based on the following rules:

 #. Iterate through the class and its superclasses in order from
 #ubclass to superclass (i.e. iterate through ``cls.__mro__``)

 #. For each class, yield the attributes in the order in which they
 #ppear in ``__dict__``, with the exception of those in step
 # below.  In Python 3.6 and above this ordering will be the
 #ame as that of the class' construction, with the exception
 #f attributes that were added after the fact by the application
 #r the mapper.

 #. If a certain attribute key is also in the superclass ``__dict__``,
 #hen it's included in the iteration for that class, and not the
 #lass in which it first appeared.

 #he above process produces an ordering that is deterministic in terms
 #f the order in which attributes were assigned to the class.

 #. versionchanged:: 1.3.19 ensured deterministic ordering for
 #meth:`_orm.Mapper.all_orm_descriptors`.

 #hen dealing with a :class:`.QueryableAttribute`, the
 #attr:`.QueryableAttribute.property` attribute refers to the
 #class:`.MapperProperty` property, which is what you get when
 #eferring to the collection of mapped properties via
 #attr:`_orm.Mapper.attrs`.

 #. warning::

 #he :attr:`_orm.Mapper.all_orm_descriptors`
 #ccessor namespace is an
 #nstance of :class:`.OrderedProperties`.  This is
 # dictionary-like object which includes a small number of
 #amed methods such as :meth:`.OrderedProperties.items`
 #nd :meth:`.OrderedProperties.values`.  When
 #ccessing attributes dynamically, favor using the dict-access
 #cheme, e.g. ``mapper.all_orm_descriptors[somename]`` over
 #`getattr(mapper.all_orm_descriptors, somename)`` to avoid name
 #ollisions.

 #. seealso::

 #attr:`_orm.Mapper.attrs`

 #""
 #eturn util.ImmutableProperties(
 #ict(self.class_manager._all_sqla_attributes())
 #

 #HasMemoized.memoized_attribute
 #util.preload_module("sqlalchemy.orm.descriptor_props")
 #ef synonyms(self):
 #""Return a namespace of all :class:`.SynonymProperty`
 #roperties maintained by this :class:`_orm.Mapper`.

 #. seealso::

 #attr:`_orm.Mapper.attrs` - namespace of all
 #class:`.MapperProperty`
 #bjects.

 #""
 #escriptor_props = util.preloaded.orm_descriptor_props

 #eturn self._filter_properties(descriptor_props.SynonymProperty)

 #property
 #ef entity_namespace(self):
 #eturn self.class_

 #HasMemoized.memoized_attribute
 #ef column_attrs(self):
 #""Return a namespace of all :class:`.ColumnProperty`
 #roperties maintained by this :class:`_orm.Mapper`.

 #. seealso::

 #attr:`_orm.Mapper.attrs` - namespace of all
 #class:`.MapperProperty`
 #bjects.

 #""
 #eturn self._filter_properties(properties.ColumnProperty)

 #util.preload_module("sqlalchemy.orm.relationships")
 #HasMemoized.memoized_attribute
 #ef relationships(self):
 #""A namespace of all :class:`.RelationshipProperty` properties
 #aintained by this :class:`_orm.Mapper`.

 #. warning::

 #he :attr:`_orm.Mapper.relationships` accessor namespace is an
 #nstance of :class:`.OrderedProperties`.  This is
 # dictionary-like object which includes a small number of
 #amed methods such as :meth:`.OrderedProperties.items`
 #nd :meth:`.OrderedProperties.values`.  When
 #ccessing attributes dynamically, favor using the dict-access
 #cheme, e.g. ``mapper.relationships[somename]`` over
 #`getattr(mapper.relationships, somename)`` to avoid name
 #ollisions.

 #. seealso::

 #attr:`_orm.Mapper.attrs` - namespace of all
 #class:`.MapperProperty`
 #bjects.

 #""
 #eturn self._filter_properties(
 #til.preloaded.orm_relationships.RelationshipProperty
 #

 #HasMemoized.memoized_attribute
 #util.preload_module("sqlalchemy.orm.descriptor_props")
 #ef composites(self):
 #""Return a namespace of all :class:`.CompositeProperty`
 #roperties maintained by this :class:`_orm.Mapper`.

 #. seealso::

 #attr:`_orm.Mapper.attrs` - namespace of all
 #class:`.MapperProperty`
 #bjects.

 #""
 #eturn self._filter_properties(
 #til.preloaded.orm_descriptor_props.CompositeProperty
 #

 #ef _filter_properties(self, type_):
 #elf._check_configure()
 #eturn util.ImmutableProperties(
 #til.OrderedDict(
 #k, v) for k, v in self._props.items() if isinstance(v, type_)
 #
 #

 #HasMemoized.memoized_attribute
 #ef _get_clause(self):
 #""create a "get clause" based on the primary key.  this is used
 #y query.get() and many-to-one lazyloads to load this item
 #y primary key.

 #""
 #arams = [
 #
 #rimary_key,
 #ql.bindparam("pk_%d" % idx, type_=primary_key.type),
 #
 #or idx, primary_key in enumerate(self.primary_key, 1)
 #
 #eturn (
 #ql.and_(*[k == v for (k, v) in params]),
 #til.column_dict(params),
 #

 #HasMemoized.memoized_attribute
 #ef _equivalent_columns(self):
 #""Create a map of all equivalent columns, based on
 #he determination of column pairs that are equated to
 #ne another based on inherit condition.  This is designed
 #o work with the queries that util.polymorphic_union
 #omes up with, which often don't include the columns from
 #he base table directly (including the subclass table columns
 #nly).

 #he resulting structure is a dictionary of columns mapped
 #o lists of equivalent columns, e.g.::

 #
 #ablea.col1:
 #tableb.col1, tablec.col1},
 #ablea.col2:
 #tabled.col2}
 #

 #""
 #esult = util.column_dict()

 #ef visit_binary(binary):
 #f binary.operator == operators.eq:
 #f binary.left in result:
 #esult[binary.left].add(binary.right)
 #lse:
 #esult[binary.left] = util.column_set((binary.right,))
 #f binary.right in result:
 #esult[binary.right].add(binary.left)
 #lse:
 #esult[binary.right] = util.column_set((binary.left,))

 #or mapper in self.base_mapper.self_and_descendants:
 #f mapper.inherit_condition is not None:
 #isitors.traverse(
 #apper.inherit_condition, {}, {"binary": visit_binary}
 #

 #eturn result

 #ef _is_userland_descriptor(self, assigned_name, obj):
 #f isinstance(
 #bj,
 #
 #MappedAttribute,
 #nstrumentation.ClassManager,
 #xpression.ColumnElement,
 #,
 #:
 #eturn False
 #lse:
 #eturn assigned_name not in self._dataclass_fields

 #HasMemoized.memoized_attribute
 #ef _dataclass_fields(self):
 #eturn [f.name for f in util.dataclass_fields(self.class_)]

 #ef _should_exclude(self, name, assigned_name, local, column):
 #""determine whether a particular property should be implicitly
 #resent on the class.

 #his occurs when properties are propagated from an inherited class, or
 #re applied from the columns present in the mapped table.

 #""

        # check for class-bound attributes and/or descriptors,
        # either local or from an inherited class
        # ignore dataclass field default values
 #f local:
 #f self.class_.__dict__.get(
 #ssigned_name, None
 # is not None and self._is_userland_descriptor(
 #ssigned_name, self.class_.__dict__[assigned_name]
 #:
 #eturn True
 #lse:
 #ttr = self.class_manager._get_class_attr_mro(assigned_name, None)
 #f attr is not None and self._is_userland_descriptor(
 #ssigned_name, attr
 #:
 #eturn True

 #f (
 #elf.include_properties is not None
 #nd name not in self.include_properties
 #nd (column is None or column not in self.include_properties)
 #:
 #elf._log("not including property %s" % (name))
 #eturn True

 #f self.exclude_properties is not None and (
 #ame in self.exclude_properties
 #r (column is not None and column in self.exclude_properties)
 #:
 #elf._log("excluding property %s" % (name))
 #eturn True

 #eturn False

 #ef common_parent(self, other):
 #""Return true if the given mapper shares a
 #ommon inherited parent as this mapper."""

 #eturn self.base_mapper is other.base_mapper

 #ef is_sibling(self, other):
 #""return true if the other mapper is an inheriting sibling to this
 #ne.  common parent but different branch

 #""
 #eturn (
 #elf.base_mapper is other.base_mapper
 #nd not self.isa(other)
 #nd not other.isa(self)
 #

 #ef _canload(self, state, allow_subtypes):
 # = self.primary_mapper()
 #f self.polymorphic_on is not None or allow_subtypes:
 #eturn _state_mapper(state).isa(s)
 #lse:
 #eturn _state_mapper(state) is s

 #ef isa(self, other):
 #""Return True if the this mapper inherits from the given mapper."""

 # = self
 #hile m and m is not other:
 # = m.inherits
 #eturn bool(m)

 #ef iterate_to_root(self):
 # = self
 #hile m:
 #ield m
 # = m.inherits

 #HasMemoized.memoized_attribute
 #ef self_and_descendants(self):
 #""The collection including this mapper and all descendant mappers.

 #his includes not just the immediately inheriting mappers but
 #ll their inheriting mappers as well.

 #""
 #escendants = []
 #tack = deque([self])
 #hile stack:
 #tem = stack.popleft()
 #escendants.append(item)
 #tack.extend(item._inheriting_mappers)
 #eturn util.WeakSequence(descendants)

 #ef polymorphic_iterator(self):
 #""Iterate through the collection including this mapper and
 #ll descendant mappers.

 #his includes not just the immediately inheriting mappers but
 #ll their inheriting mappers as well.

 #o iterate through an entire hierarchy, use
 #`mapper.base_mapper.polymorphic_iterator()``.

 #""
 #eturn iter(self.self_and_descendants)

 #ef primary_mapper(self):
 #""Return the primary mapper corresponding to this mapper's class key
 #class)."""

 #eturn self.class_manager.mapper

 #property
 #ef primary_base_mapper(self):
 #eturn self.class_manager.mapper.base_mapper

 #ef _result_has_identity_key(self, result, adapter=None):
 #k_cols = self.primary_key
 #f adapter:
 #k_cols = [adapter.columns[c] for c in pk_cols]
 #k = result.keys()
 #or col in pk_cols:
 #f col not in rk:
 #eturn False
 #lse:
 #eturn True

 #ef identity_key_from_row(self, row, identity_token=None, adapter=None):
 #""Return an identity-map key for use in storing/retrieving an
 #tem from the identity map.

 #param row: A :class:`.Row` instance.  The columns which are
 #apped by this :class:`_orm.Mapper` should be locatable in the row,
 #referably via the :class:`_schema.Column`
 #bject directly (as is the case
 #hen a :func:`_expression.select` construct is executed), or
 #ia string names of the form ``<tablename>_<colname>``.

 #""
 #k_cols = self.primary_key
 #f adapter:
 #k_cols = [adapter.columns[c] for c in pk_cols]

 #eturn (
 #elf._identity_class,
 #uple(row[column] for column in pk_cols),
 #dentity_token,
 #

 #ef identity_key_from_primary_key(self, primary_key, identity_token=None):
 #""Return an identity-map key for use in storing/retrieving an
 #tem from an identity map.

 #param primary_key: A list of values indicating the identifier.

 #""
 #eturn self._identity_class, tuple(primary_key), identity_token

 #ef identity_key_from_instance(self, instance):
 #""Return the identity key for the given instance, based on
 #ts primary key attributes.

 #f the instance's state is expired, calling this method
 #ill result in a database check to see if the object has been deleted.
 #f the row no longer exists,
 #class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised.

 #his value is typically also found on the instance state under the
 #ttribute name `key`.

 #""
 #tate = attributes.instance_state(instance)
 #eturn self._identity_key_from_state(state, attributes.PASSIVE_OFF)

 #ef _identity_key_from_state(
 #elf, state, passive=attributes.PASSIVE_RETURN_NO_VALUE
 #:
 #ict_ = state.dict
 #anager = state.manager
 #eturn (
 #elf._identity_class,
 #uple(
 #
 #anager[prop.key].impl.get(state, dict_, passive)
 #or prop in self._identity_key_props
 #
 #,
 #tate.identity_token,
 #

 #ef primary_key_from_instance(self, instance):
 #""Return the list of primary key values for the given
 #nstance.

 #f the instance's state is expired, calling this method
 #ill result in a database check to see if the object has been deleted.
 #f the row no longer exists,
 #class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised.

 #""
 #tate = attributes.instance_state(instance)
 #dentity_key = self._identity_key_from_state(
 #tate, attributes.PASSIVE_OFF
 #
 #eturn identity_key[1]

 #HasMemoized.memoized_attribute
 #ef _persistent_sortkey_fn(self):
 #ey_fns = [col.type.sort_key_function for col in self.primary_key]

 #f set(key_fns).difference([None]):

 #ef key(state):
 #eturn tuple(
 #ey_fn(val) if key_fn is not None else val
 #or key_fn, val in zip(key_fns, state.key[1])
 #

 #lse:

 #ef key(state):
 #eturn state.key[1]

 #eturn key

 #HasMemoized.memoized_attribute
 #ef _identity_key_props(self):
 #eturn [self._columntoproperty[col] for col in self.primary_key]

 #HasMemoized.memoized_attribute
 #ef _all_pk_cols(self):
 #ollection = set()
 #or table in self.tables:
 #ollection.update(self._pks_by_table[table])
 #eturn collection

 #HasMemoized.memoized_attribute
 #ef _should_undefer_in_wildcard(self):
 #ols = set(self.primary_key)
 #f self.polymorphic_on is not None:
 #ols.add(self.polymorphic_on)
 #eturn cols

 #HasMemoized.memoized_attribute
 #ef _primary_key_propkeys(self):
 #eturn {self._columntoproperty[col].key for col in self._all_pk_cols}

 #ef _get_state_attr_by_column(
 #elf, state, dict_, column, passive=attributes.PASSIVE_RETURN_NO_VALUE
 #:
 #rop = self._columntoproperty[column]
 #eturn state.manager[prop.key].impl.get(state, dict_, passive=passive)

 #ef _set_committed_state_attr_by_column(self, state, dict_, column, value):
 #rop = self._columntoproperty[column]
 #tate.manager[prop.key].impl.set_committed_value(state, dict_, value)

 #ef _set_state_attr_by_column(self, state, dict_, column, value):
 #rop = self._columntoproperty[column]
 #tate.manager[prop.key].impl.set(state, dict_, value, None)

 #ef _get_committed_attr_by_column(self, obj, column):
 #tate = attributes.instance_state(obj)
 #ict_ = attributes.instance_dict(obj)
 #eturn self._get_committed_state_attr_by_column(
 #tate, dict_, column, passive=attributes.PASSIVE_OFF
 #

 #ef _get_committed_state_attr_by_column(
 #elf, state, dict_, column, passive=attributes.PASSIVE_RETURN_NO_VALUE
 #:

 #rop = self._columntoproperty[column]
 #eturn state.manager[prop.key].impl.get_committed_value(
 #tate, dict_, passive=passive
 #

 #ef _optimized_get_statement(self, state, attribute_names):
 #""assemble a WHERE clause which retrieves a given state by primary
 #ey, using a minimized set of tables.

 #pplies to a joined-table inheritance mapper where the
 #equested attribute names are only present on joined tables,
 #ot the base table.  The WHERE clause attempts to include
 #nly those tables to minimize joins.

 #""
 #rops = self._props

 #ol_attribute_names = set(attribute_names).intersection(
 #tate.mapper.column_attrs.keys()
 #
 #ables = set(
 #hain(
 #[
 #ql_util.find_tables(c, check_columns=True)
 #or key in col_attribute_names
 #or c in props[key].columns
 #
 #
 #

 #f self.base_mapper.local_table in tables:
 #eturn None

 #ef visit_binary(binary):
 #eftcol = binary.left
 #ightcol = binary.right
 #f leftcol is None or rightcol is None:
 #eturn

 #f leftcol.table not in tables:
 #eftval = self._get_committed_state_attr_by_column(
 #tate,
 #tate.dict,
 #eftcol,
 #assive=attributes.PASSIVE_NO_INITIALIZE,
 #
 #f leftval in orm_util._none_set:
 #aise _OptGetColumnsNotAvailable()
 #inary.left = sql.bindparam(
 #one, leftval, type_=binary.right.type
 #
 #lif rightcol.table not in tables:
 #ightval = self._get_committed_state_attr_by_column(
 #tate,
 #tate.dict,
 #ightcol,
 #assive=attributes.PASSIVE_NO_INITIALIZE,
 #
 #f rightval in orm_util._none_set:
 #aise _OptGetColumnsNotAvailable()
 #inary.right = sql.bindparam(
 #one, rightval, type_=binary.right.type
 #

 #llconds = []

 #ry:
 #tart = False
 #or mapper in reversed(list(self.iterate_to_root())):
 #f mapper.local_table in tables:
 #tart = True
 #lif not isinstance(
 #apper.local_table, expression.TableClause
 #:
 #eturn None
 #f start and not mapper.single:
 #llconds.append(
 #isitors.cloned_traverse(
 #apper.inherit_condition,
 #},
 #"binary": visit_binary},
 #
 #
 #xcept _OptGetColumnsNotAvailable:
 #eturn None

 #ond = sql.and_(*allconds)

 #ols = []
 #or key in col_attribute_names:
 #ols.extend(props[key].columns)
 #eturn (
 #ql.select(*cols)
 #where(cond)
 #set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
 #

 #ef _iterate_to_target_viawpoly(self, mapper):
 #f self.isa(mapper):
 #rev = self
 #or m in self.iterate_to_root():
 #ield m

 #f m is not prev and prev not in m._with_polymorphic_mappers:
 #reak

 #rev = m
 #f m is mapper:
 #reak

 #ef _should_selectin_load(self, enabled_via_opt, polymorphic_from):
 #f not enabled_via_opt:
            # common case, takes place for all polymorphic loads
 #apper = polymorphic_from
 #or m in self._iterate_to_target_viawpoly(mapper):
 #f m.polymorphic_load == "selectin":
 #eturn m
 #lse:
            # uncommon case, selectin load options were used
 #nabled_via_opt = set(enabled_via_opt)
 #nabled_via_opt_mappers = {e.mapper: e for e in enabled_via_opt}
 #or entity in enabled_via_opt.union([polymorphic_from]):
 #apper = entity.mapper
 #or m in self._iterate_to_target_viawpoly(mapper):
 #f (
 #.polymorphic_load == "selectin"
 #r m in enabled_via_opt_mappers
 #:
 #eturn enabled_via_opt_mappers.get(m, m)

 #eturn None

 #util.preload_module(
 #sqlalchemy.ext.baked", "sqlalchemy.orm.strategy_options"
 #
 #ef _subclass_load_via_in(self, entity):
 #""Assemble a BakedQuery that can load the columns local to
 #his subclass as a SELECT with IN.

 #""
 #trategy_options = util.preloaded.orm_strategy_options
 #aked = util.preloaded.ext_baked

 #ssert self.inherits

 #olymorphic_prop = self._columntoproperty[self.polymorphic_on]
 #eep_props = set([polymorphic_prop] + self._identity_key_props)

 #isable_opt = strategy_options.Load(entity)
 #nable_opt = strategy_options.Load(entity)

 #or prop in self.attrs:
 #f prop.parent is self or prop in keep_props:
                # "enable" options, to turn on the properties that we want to
                # load by default (subject to options from the query)
 #nable_opt.set_generic_strategy(
 #prop.key,), dict(prop.strategy_key)
 #
 #lse:
                # "disable" options, to turn off the properties from the
                # superclass that we *don't* want to load, applied after
                # the options from the query to override them
 #isable_opt.set_generic_strategy(
 #prop.key,), {"do_nothing": True}
 #

 #rimary_key = [
 #ql_util._deep_annotate(pk, {"_orm_adapt": True})
 #or pk in self.primary_key
 #

 #f len(primary_key) > 1:
 #n_expr = sql.tuple_(*primary_key)
 #lse:
 #n_expr = primary_key[0]

 #f entity.is_aliased_class:
 #ssert entity.mapper is self

 # = baked.BakedQuery(
 #elf._compiled_cache,
 #ambda session: session.query(entity).select_entity_from(
 #ntity.selectable
 #,
 #self,),
 #
 #.spoil()
 #lse:
 # = baked.BakedQuery(
 #elf._compiled_cache,
 #ambda session: session.query(self),
 #self,),
 #

 # += lambda q: q.filter(
 #n_expr.in_(sql.bindparam("primary_keys", expanding=True))
 #.order_by(*primary_key)

 #eturn q, enable_opt, disable_opt

 #HasMemoized.memoized_attribute
 #ef _subclass_load_via_in_mapper(self):
 #eturn self._subclass_load_via_in(self)

 #ef cascade_iterator(self, type_, state, halt_on=None):
 #"""Iterate each element and its mapper in an object graph,
 #or all relationships that meet the given cascade rule.

 #param type\_:
 #he name of the cascade rule (i.e. ``"save-update"``, ``"delete"``,
 #tc.).

 #. note::  the ``"all"`` cascade is not accepted here.  For a generic
 #bject traversal function, see :ref:`faq_walk_objects`.

 #param state:
 #he lead InstanceState.  child items will be processed per
 #he relationships defined for this object's mapper.

 #return: the method yields individual object instances.

 #. seealso::

 #ref:`unitofwork_cascades`

 #ref:`faq_walk_objects` - illustrates a generic function to
 #raverse all objects without relying on cascades.

 #""
 #isited_states = set()
 #rp, mpp = object(), object()

 #ssert state.mapper.isa(self)

 #isitables = deque(
 #(deque(state.mapper._props.values()), prp, state, state.dict)]
 #

 #hile visitables:
 #terator, item_type, parent_state, parent_dict = visitables[-1]
 #f not iterator:
 #isitables.pop()
 #ontinue

 #f item_type is prp:
 #rop = iterator.popleft()
 #f type_ not in prop.cascade:
 #ontinue
 #ueue = deque(
 #rop.cascade_iterator(
 #ype_,
 #arent_state,
 #arent_dict,
 #isited_states,
 #alt_on,
 #
 #
 #f queue:
 #isitables.append((queue, mpp, None, None))
 #lif item_type is mpp:
 #
 #nstance,
 #nstance_mapper,
 #orresponding_state,
 #orresponding_dict,
 # = iterator.popleft()
 #ield (
 #nstance,
 #nstance_mapper,
 #orresponding_state,
 #orresponding_dict,
 #
 #isitables.append(
 #
 #eque(instance_mapper._props.values()),
 #rp,
 #orresponding_state,
 #orresponding_dict,
 #
 #

 #HasMemoized.memoized_attribute
 #ef _compiled_cache(self):
 #eturn util.LRUCache(self._compiled_cache_size)

 #HasMemoized.memoized_attribute
 #ef _sorted_tables(self):
 #able_to_mapper = {}

 #or mapper in self.base_mapper.self_and_descendants:
 #or t in mapper.tables:
 #able_to_mapper.setdefault(t, mapper)

 #xtra_dependencies = []
 #or table, mapper in table_to_mapper.items():
 #uper_ = mapper.inherits
 #f super_:
 #xtra_dependencies.extend(
 #(super_table, table) for super_table in super_.tables]
 #

 #ef skip(fk):
            # attempt to skip dependencies that are not
            # significant to the inheritance chain
            # for two tables that are related by inheritance.
            # while that dependency may be important, it's technically
            # not what we mean to sort on here.
 #arent = table_to_mapper.get(fk.parent.table)
 #ep = table_to_mapper.get(fk.column.table)
 #f (
 #arent is not None
 #nd dep is not None
 #nd dep is not parent
 #nd dep.inherit_condition is not None
 #:
 #ols = set(sql_util._find_columns(dep.inherit_condition))
 #f parent.inherit_condition is not None:
 #ols = cols.union(
 #ql_util._find_columns(parent.inherit_condition)
 #
 #eturn fk.parent not in cols and fk.column not in cols
 #lse:
 #eturn fk.parent not in cols
 #eturn False

 #orted_ = sql_util.sort_tables(
 #able_to_mapper,
 #kip_fn=skip,
 #xtra_dependencies=extra_dependencies,
 #

 #et = util.OrderedDict()
 #or t in sorted_:
 #et[t] = table_to_mapper[t]
 #eturn ret

 #ef _memo(self, key, callable_):
 #f key in self._memoized_values:
 #eturn self._memoized_values[key]
 #lse:
 #elf._memoized_values[key] = value = callable_()
 #eturn value

 #util.memoized_property
 #ef _table_to_equated(self):
 #""memoized map of tables to collections of columns to be
 #ynchronized upwards to the base mapper."""

 #esult = util.defaultdict(list)

 #or table in self._sorted_tables:
 #ols = set(table.c)
 #or m in self.iterate_to_root():
 #f m._inherits_equated_pairs and cols.intersection(
 #til.reduce(
 #et.union,
 #l.proxy_set for l, r in m._inherits_equated_pairs],
 #
 #:
 #esult[table].append((m, m._inherits_equated_pairs))

 #eturn result


class _OptGetColumnsNotAvailable(Exception):
 #ass


def configure_mappers():
 #""Initialize the inter-mapper relationships of all mappers that
 #ave been constructed thus far across all :class:`_orm.registry`
 #ollections.

 #he configure step is used to reconcile and initialize the
 #func:`_orm.relationship` linkages between mapped classes, as well as to
 #nvoke configuration events such as the
 #meth:`_orm.MapperEvents.before_configured` and
 #meth:`_orm.MapperEvents.after_configured`, which may be used by ORM
 #xtensions or user-defined extension hooks.

 #apper configuration is normally invoked automatically, the first time
 #appings from a particular :class:`_orm.registry` are used, as well as
 #henever mappings are used and additional not-yet-configured mappers have
 #een constructed. The automatic configuration process however is local only
 #o the :class:`_orm.registry` involving the target mapper and any related
 #class:`_orm.registry` objects which it may depend on; this is
 #quivalent to invoking the :meth:`_orm.registry.configure` method
 #n a particular :class:`_orm.registry`.

 #y contrast, the :func:`_orm.configure_mappers` function will invoke the
 #onfiguration process on all :class:`_orm.registry` objects that
 #xist in memory, and may be useful for scenarios where many individual
 #class:`_orm.registry` objects that are nonetheless interrelated are
 #n use.

 #. versionchanged:: 1.4

 #s of SQLAlchemy 1.4.0b2, this function works on a
 #er-:class:`_orm.registry` basis, locating all :class:`_orm.registry`
 #bjects present and invoking the :meth:`_orm.registry.configure` method
 #n each. The :meth:`_orm.registry.configure` method may be preferred to
 #imit the configuration of mappers to those local to a particular
 #class:`_orm.registry` and/or declarative base class.

 #oints at which automatic configuration is invoked include when a mapped
 #lass is instantiated into an instance, as well as when ORM queries
 #re emitted using :meth:`.Session.query` or :meth:`_orm.Session.execute`
 #ith an ORM-enabled statement.

 #he mapper configure process, whether invoked by
 #func:`_orm.configure_mappers` or from :meth:`_orm.registry.configure`,
 #rovides several event hooks that can be used to augment the mapper
 #onfiguration step. These hooks include:

 # :meth:`.MapperEvents.before_configured` - called once before
 #func:`.configure_mappers` or :meth:`_orm.registry.configure` does any
 #ork; this can be used to establish additional options, properties, or
 #elated mappings before the operation proceeds.

 # :meth:`.MapperEvents.mapper_configured` - called as each individual
 #class:`_orm.Mapper` is configured within the process; will include all
 #apper state except for backrefs set up by other mappers that are still
 #o be configured.

 # :meth:`.MapperEvents.after_configured` - called once after
 #func:`.configure_mappers` or :meth:`_orm.registry.configure` is
 #omplete; at this stage, all :class:`_orm.Mapper` objects that fall
 #ithin the scope of the configuration operation will be fully configured.
 #ote that the calling application may still have other mappings that
 #aven't been produced yet, such as if they are in modules as yet
 #nimported, and may also have mappings that are still to be configured,
 #f they are in other :class:`_orm.registry` collections not part of the
 #urrent scope of configuration.

 #""

 #configure_registries(_all_registries(), cascade=True)


def _configure_registries(registries, cascade):
 #or reg in registries:
 #f reg._new_mappers:
 #reak
 #lse:
 #eturn

 #ith _CONFIGURE_MUTEX:
 #lobal _already_compiling
 #f _already_compiling:
 #eturn
 #already_compiling = True
 #ry:

            # double-check inside mutex
 #or reg in registries:
 #f reg._new_mappers:
 #reak
 #lse:
 #eturn

 #apper.dispatch._for_class(Mapper).before_configured()
            # initialize properties on all mappers
            # note that _mapper_registry is unordered, which
            # may randomly conceal/reveal issues related to
            # the order of mapper compilation

 #do_configure_registries(registries, cascade)
 #inally:
 #already_compiling = False
 #apper.dispatch._for_class(Mapper).after_configured()


@util.preload_module("sqlalchemy.orm.decl_api")
def _do_configure_registries(registries, cascade):

 #egistry = util.preloaded.orm_decl_api.registry

 #rig = set(registries)

 #or reg in registry._recurse_with_dependencies(registries):
 #as_skip = False

 #or mapper in reg._mappers_to_configure():
 #un_configure = None
 #or fn in mapper.dispatch.before_mapper_configured:
 #un_configure = fn(mapper, mapper.class_)
 #f run_configure is EXT_SKIP:
 #as_skip = True
 #reak
 #f run_configure is EXT_SKIP:
 #ontinue

 #f getattr(mapper, "_configure_failed", False):
 # = sa_exc.InvalidRequestError(
 #One or more mappers failed to initialize - "
 #can't proceed with initialization of other "
 #mappers. Triggering mapper: '%s'. "
 #Original exception was: %s"
 # (mapper, mapper._configure_failed)
 #
 #._configure_failed = mapper._configure_failed
 #aise e

 #f not mapper.configured:
 #ry:
 #apper._post_configure_properties()
 #apper._expire_memoizations()
 #apper.dispatch.mapper_configured(mapper, mapper.class_)
 #xcept Exception:
 #xc = sys.exc_info()[1]
 #f not hasattr(exc, "_configure_failed"):
 #apper._configure_failed = exc
 #aise
 #f not has_skip:
 #eg._new_mappers = False

 #f not cascade and reg._dependencies.difference(orig):
 #aise sa_exc.InvalidRequestError(
 #configure was called with cascade=False but "
 #additional registries remain"
 #


@util.preload_module("sqlalchemy.orm.decl_api")
def _dispose_registries(registries, cascade):

 #egistry = util.preloaded.orm_decl_api.registry

 #rig = set(registries)

 #or reg in registry._recurse_with_dependents(registries):
 #f not cascade and reg._dependents.difference(orig):
 #aise sa_exc.InvalidRequestError(
 #Registry has dependent registries that are not disposed; "
 #pass cascade=True to clear these also"
 #

 #hile reg._managers:
 #ry:
 #anager, _ = reg._managers.popitem()
 #xcept KeyError:
                # guard against race between while and popitem
 #ass
 #lse:
 #eg._dispose_manager_and_mapper(manager)

 #eg._non_primary_mappers.clear()
 #eg._dependents.clear()
 #or dep in reg._dependencies:
 #ep._dependents.discard(reg)
 #eg._dependencies.clear()
        # this wasn't done in the 1.3 clear_mappers() and in fact it
        # was a bug, as it could cause configure_mappers() to invoke
        # the "before_configured" event even though mappers had all been
        # disposed.
 #eg._new_mappers = False


def reconstructor(fn):
 #""Decorate a method as the 'reconstructor' hook.

 #esignates a method as the "reconstructor", an ``__init__``-like
 #ethod that will be called by the ORM after the instance has been
 #oaded from the database or otherwise reconstituted.

 #he reconstructor will be invoked with no arguments.  Scalar
 #non-collection) database-mapped attributes of the instance will
 #e available for use within the function.  Eagerly-loaded
 #ollections are generally not yet available and will usually only
 #ontain the first element.  ORM state changes made to objects at
 #his stage will not be recorded for the next flush() operation, so
 #he activity within a reconstructor should be conservative.

 #. seealso::

 #ref:`mapping_constructors`

 #meth:`.InstanceEvents.load`

 #""
 #n.__sa_reconstructor__ = True
 #eturn fn


def validates(*names, **kw):
 #"""Decorate a method as a 'validator' for one or more named properties.

 #esignates a method as a validator, a method which receives the
 #ame of the attribute as well as a value to be assigned, or in the
 #ase of a collection, the value to be added to the collection.
 #he function can then raise validation exceptions to halt the
 #rocess from continuing (where Python's built-in ``ValueError``
 #nd ``AssertionError`` exceptions are reasonable choices), or can
 #odify or replace the value before proceeding. The function should
 #therwise return the given value.

 #ote that a validator for a collection **cannot** issue a load of that
 #ollection within the validation routine - this usage raises
 #n assertion to avoid recursion overflows.  This is a reentrant
 #ondition which is not supported.

 #param \*names: list of attribute names to be validated.
 #param include_removes: if True, "remove" events will be
 #ent as well - the validation function must accept an additional
 #rgument "is_remove" which will be a boolean.

 #param include_backrefs: defaults to ``True``; if ``False``, the
 #alidation function will not emit if the originator is an attribute
 #vent related via a backref.  This can be used for bi-directional
 #func:`.validates` usage where only one validator should emit per
 #ttribute operation.

 #. versionadded:: 0.9.0

 #. seealso::

 #ref:`simple_validators` - usage examples for :func:`.validates`

 #""
 #nclude_removes = kw.pop("include_removes", False)
 #nclude_backrefs = kw.pop("include_backrefs", True)

 #ef wrap(fn):
 #n.__sa_validators__ = names
 #n.__sa_validation_opts__ = {
 #include_removes": include_removes,
 #include_backrefs": include_backrefs,
 #
 #eturn fn

 #eturn wrap


def _event_on_load(state, ctx):
 #nstrumenting_mapper = state.manager.mapper

 #f instrumenting_mapper._reconstructor:
 #nstrumenting_mapper._reconstructor(state.obj())


def _event_on_init(state, args, kwargs):
 #""Run init_instance hooks.

 #his also includes mapper compilation, normally not needed
 #ere but helps with some piecemeal configuration
 #cenarios (such as in the ORM tutorial).

 #""

 #nstrumenting_mapper = state.manager.mapper
 #f instrumenting_mapper:
 #nstrumenting_mapper._check_configure()
 #f instrumenting_mapper._set_polymorphic_identity:
 #nstrumenting_mapper._set_polymorphic_identity(state)


class _ColumnMapping(dict):
 #""Error reporting helper for mapper._columntoproperty."""

 #_slots__ = ("mapper",)

 #ef __init__(self, mapper):
 #elf.mapper = mapper

 #ef __missing__(self, column):
 #rop = self.mapper._props.get(column)
 #f prop:
 #aise orm_exc.UnmappedColumnError(
 #Column '%s.%s' is not available, due to "
 #conflicting property '%s':%r"
 # (column.table.name, column.name, column.key, prop)
 #
 #aise orm_exc.UnmappedColumnError(
 #No column %s is configured on mapper %s..."
 # (column, self.mapper)
 #
