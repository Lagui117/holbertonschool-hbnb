# orm/descriptor_props.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Descriptor properties are more "auxiliary" properties
that exist as configurational elements, but don't participate
as actively in the load/persist ORM loop.

"""

from . import attributes
from . import util as orm_util
from .interfaces import MapperProperty
from .interfaces import PropComparator
from .util import _none_set
from .. import event
from .. import exc as sa_exc
from .. import schema
from .. import sql
from .. import util
from ..sql import expression
from ..sql import operators


class DescriptorProperty(MapperProperty):
 #"":class:`.MapperProperty` which proxies access to a
 #ser-defined descriptor."""

 #oc = None

 #ses_objects = False

 #ef instrument_class(self, mapper):
 #rop = self

 #lass _ProxyImpl(object):
 #ccepts_scalar_loader = False
 #oad_on_unexpire = True
 #ollection = False

 #property
 #ef uses_objects(self):
 #eturn prop.uses_objects

 #ef __init__(self, key):
 #elf.key = key

 #f hasattr(prop, "get_history"):

 #ef get_history(
 #elf, state, dict_, passive=attributes.PASSIVE_OFF
 #:
 #eturn prop.get_history(state, dict_, passive)

 #f self.descriptor is None:
 #esc = getattr(mapper.class_, self.key, None)
 #f mapper._is_userland_descriptor(self.key, desc):
 #elf.descriptor = desc

 #f self.descriptor is None:

 #ef fset(obj, value):
 #etattr(obj, self.name, value)

 #ef fdel(obj):
 #elattr(obj, self.name)

 #ef fget(obj):
 #eturn getattr(obj, self.name)

 #elf.descriptor = property(fget=fget, fset=fset, fdel=fdel)

 #roxy_attr = attributes.create_proxied_attribute(self.descriptor)(
 #elf.parent.class_,
 #elf.key,
 #elf.descriptor,
 #ambda: self._comparator_factory(mapper),
 #oc=self.doc,
 #riginal_property=self,
 #
 #roxy_attr.impl = _ProxyImpl(self.key)
 #apper.class_manager.instrument_attribute(self.key, proxy_attr)


class CompositeProperty(DescriptorProperty):
 #""Defines a "composite" mapped attribute, representing a collection
 #f columns as one attribute.

 #class:`.CompositeProperty` is constructed using the :func:`.composite`
 #unction.

 #. seealso::

 #ref:`mapper_composite`

 #""

 #ef __init__(self, class_, *attrs, **kwargs):
 #"""Return a composite column-based property for use with a Mapper.

 #ee the mapping documentation section :ref:`mapper_composite` for a
 #ull usage example.

 #he :class:`.MapperProperty` returned by :func:`.composite`
 #s the :class:`.CompositeProperty`.

 #param class\_:
 #he "composite type" class, or any classmethod or callable which
 #ill produce a new instance of the composite object given the
 #olumn values in order.

 #param \*cols:
 #ist of Column objects to be mapped.

 #param active_history=False:
 #hen ``True``, indicates that the "previous" value for a
 #calar attribute should be loaded when replaced, if not
 #lready loaded.  See the same flag on :func:`.column_property`.

 #param group:
 # group name for this property when marked as deferred.

 #param deferred:
 #hen True, the column property is "deferred", meaning that it does
 #ot load immediately, and is instead loaded when the attribute is
 #irst accessed on an instance.  See also
 #func:`~sqlalchemy.orm.deferred`.

 #param comparator_factory:  a class which extends
 #class:`.CompositeProperty.Comparator` which provides custom SQL
 #lause generation for comparison operations.

 #param doc:
 #ptional string that will be applied as the doc on the
 #lass-bound descriptor.

 #param info: Optional data dictionary which will be populated into the
 #attr:`.MapperProperty.info` attribute of this object.

 #""
 #uper(CompositeProperty, self).__init__()

 #elf.attrs = attrs
 #elf.composite_class = class_
 #elf.active_history = kwargs.get("active_history", False)
 #elf.deferred = kwargs.get("deferred", False)
 #elf.group = kwargs.get("group", None)
 #elf.comparator_factory = kwargs.pop(
 #comparator_factory", self.__class__.Comparator
 #
 #f "info" in kwargs:
 #elf.info = kwargs.pop("info")

 #til.set_creation_order(self)
 #elf._create_descriptor()

 #ef instrument_class(self, mapper):
 #uper(CompositeProperty, self).instrument_class(mapper)
 #elf._setup_event_handlers()

 #ef do_init(self):
 #""Initialization which occurs after the :class:`.CompositeProperty`
 #as been associated with its parent mapper.

 #""
 #elf._setup_arguments_on_columns()

 #COMPOSITE_FGET = object()

 #ef _create_descriptor(self):
 #""Create the Python descriptor that will serve as
 #he access point on instances of the mapped class.

 #""

 #ef fget(instance):
 #ict_ = attributes.instance_dict(instance)
 #tate = attributes.instance_state(instance)

 #f self.key not in dict_:
                # key not present.  Iterate through related
                # attributes, retrieve their values.  This
                # ensures they all load.
 #alues = [
 #etattr(instance, key) for key in self._attribute_keys
 #

                # current expected behavior here is that the composite is
                # created on access if the object is persistent or if
                # col attributes have non-None.  This would be better
                # if the composite were created unconditionally,
                # but that would be a behavioral change.
 #f self.key not in dict_ and (
 #tate.key is not None or not _none_set.issuperset(values)
 #:
 #ict_[self.key] = self.composite_class(*values)
 #tate.manager.dispatch.refresh(
 #tate, self._COMPOSITE_FGET, [self.key]
 #

 #eturn dict_.get(self.key, None)

 #ef fset(instance, value):
 #ict_ = attributes.instance_dict(instance)
 #tate = attributes.instance_state(instance)
 #ttr = state.manager[self.key]
 #revious = dict_.get(self.key, attributes.NO_VALUE)
 #or fn in attr.dispatch.set:
 #alue = fn(state, value, previous, attr.impl)
 #ict_[self.key] = value
 #f value is None:
 #or key in self._attribute_keys:
 #etattr(instance, key, None)
 #lse:
 #or key, value in zip(
 #elf._attribute_keys, value.__composite_values__()
 #:
 #etattr(instance, key, value)

 #ef fdel(instance):
 #tate = attributes.instance_state(instance)
 #ict_ = attributes.instance_dict(instance)
 #revious = dict_.pop(self.key, attributes.NO_VALUE)
 #ttr = state.manager[self.key]
 #ttr.dispatch.remove(state, previous, attr.impl)
 #or key in self._attribute_keys:
 #etattr(instance, key, None)

 #elf.descriptor = property(fget, fset, fdel)

 #util.memoized_property
 #ef _comparable_elements(self):
 #eturn [getattr(self.parent.class_, prop.key) for prop in self.props]

 #util.memoized_property
 #ef props(self):
 #rops = []
 #or attr in self.attrs:
 #f isinstance(attr, str):
 #rop = self.parent.get_property(attr, _configure_mappers=False)
 #lif isinstance(attr, schema.Column):
 #rop = self.parent._columntoproperty[attr]
 #lif isinstance(attr, attributes.InstrumentedAttribute):
 #rop = attr.property
 #lse:
 #aise sa_exc.ArgumentError(
 #Composite expects Column objects or mapped "
 #attributes/attribute names as arguments, got: %r"
 # (attr,)
 #
 #rops.append(prop)
 #eturn props

 #property
 #ef columns(self):
 #eturn [a for a in self.attrs if isinstance(a, schema.Column)]

 #ef _setup_arguments_on_columns(self):
 #""Propagate configuration arguments made on this composite
 #o the target columns, for those that apply.

 #""
 #or prop in self.props:
 #rop.active_history = self.active_history
 #f self.deferred:
 #rop.deferred = self.deferred
 #rop.strategy_key = (("deferred", True), ("instrument", True))
 #rop.group = self.group

 #ef _setup_event_handlers(self):
 #""Establish events that populate/expire the composite attribute."""

 #ef load_handler(state, context):
 #load_refresh_handler(state, context, None, is_refresh=False)

 #ef refresh_handler(state, context, to_load):
            # note this corresponds to sqlalchemy.ext.mutable load_attrs()

 #f not to_load or (
 #self.key}.union(self._attribute_keys)
 #.intersection(to_load):
 #load_refresh_handler(state, context, to_load, is_refresh=True)

 #ef _load_refresh_handler(state, context, to_load, is_refresh):
 #ict_ = state.dict

            # if context indicates we are coming from the
            # fget() handler, this already set the value; skip the
            # handler here. (other handlers like mutablecomposite will still
            # want to catch it)
            # there's an insufficiency here in that the fget() handler
            # really should not be using the refresh event and there should
            # be some other event that mutablecomposite can subscribe
            # towards for this.

 #f (
 #ot is_refresh or context is self._COMPOSITE_FGET
 # and self.key in dict_:
 #eturn

            # if column elements aren't loaded, skip.
            # __get__() will initiate a load for those
            # columns
 #or k in self._attribute_keys:
 #f k not in dict_:
 #eturn

 #ict_[self.key] = self.composite_class(
 #[state.dict[key] for key in self._attribute_keys]
 #

 #ef expire_handler(state, keys):
 #f keys is None or set(self._attribute_keys).intersection(keys):
 #tate.dict.pop(self.key, None)

 #ef insert_update_handler(mapper, connection, state):
 #""After an insert or update, some columns may be expired due
 #o server side defaults, or re-populated due to client side
 #efaults.  Pop out the composite value here so that it
 #ecreates.

 #""

 #tate.dict.pop(self.key, None)

 #vent.listen(
 #elf.parent, "after_insert", insert_update_handler, raw=True
 #
 #vent.listen(
 #elf.parent, "after_update", insert_update_handler, raw=True
 #
 #vent.listen(
 #elf.parent, "load", load_handler, raw=True, propagate=True
 #
 #vent.listen(
 #elf.parent, "refresh", refresh_handler, raw=True, propagate=True
 #
 #vent.listen(
 #elf.parent, "expire", expire_handler, raw=True, propagate=True
 #

        # TODO: need a deserialize hook here

 #util.memoized_property
 #ef _attribute_keys(self):
 #eturn [prop.key for prop in self.props]

 #ef get_history(self, state, dict_, passive=attributes.PASSIVE_OFF):
 #""Provided for userland code that uses attributes.get_history()."""

 #dded = []
 #eleted = []

 #as_history = False
 #or prop in self.props:
 #ey = prop.key
 #ist = state.manager[key].impl.get_history(state, dict_)
 #f hist.has_changes():
 #as_history = True

 #on_deleted = hist.non_deleted()
 #f non_deleted:
 #dded.extend(non_deleted)
 #lse:
 #dded.append(None)
 #f hist.deleted:
 #eleted.extend(hist.deleted)
 #lse:
 #eleted.append(None)

 #f has_history:
 #eturn attributes.History(
 #self.composite_class(*added)],
 #),
 #self.composite_class(*deleted)],
 #
 #lse:
 #eturn attributes.History((), [self.composite_class(*added)], ())

 #ef _comparator_factory(self, mapper):
 #eturn self.comparator_factory(self, mapper)

 #lass CompositeBundle(orm_util.Bundle):
 #ef __init__(self, property_, expr):
 #elf.property = property_
 #uper(CompositeProperty.CompositeBundle, self).__init__(
 #roperty_.key, *expr
 #

 #ef create_row_processor(self, query, procs, labels):
 #ef proc(row):
 #eturn self.property.composite_class(
 #[proc(row) for proc in procs]
 #

 #eturn proc

 #lass Comparator(PropComparator):
 #""Produce boolean, comparison, and other operators for
 #class:`.CompositeProperty` attributes.

 #ee the example in :ref:`composite_operations` for an overview
 #f usage , as well as the documentation for :class:`.PropComparator`.

 #. seealso::

 #class:`.PropComparator`

 #class:`.ColumnOperators`

 #ref:`types_operators`

 #attr:`.TypeEngine.comparator_factory`

 #""

 #_hash__ = None

 #util.memoized_property
 #ef clauses(self):
 #eturn expression.ClauseList(
 #roup=False, *self._comparable_elements
 #

 #ef __clause_element__(self):
 #eturn self.expression

 #util.memoized_property
 #ef expression(self):
 #lauses = self.clauses._annotate(
 #
 #parententity": self._parententity,
 #parentmapper": self._parententity,
 #proxy_key": self.prop.key,
 #
 #
 #eturn CompositeProperty.CompositeBundle(self.prop, clauses)

 #ef _bulk_update_tuples(self, value):
 #f isinstance(value, sql.elements.BindParameter):
 #alue = value.value

 #f value is None:
 #alues = [None for key in self.prop._attribute_keys]
 #lif isinstance(value, self.prop.composite_class):
 #alues = value.__composite_values__()
 #lse:
 #aise sa_exc.ArgumentError(
 #Can't UPDATE composite attribute %s to %r"
 # (self.prop, value)
 #

 #eturn zip(self._comparable_elements, values)

 #util.memoized_property
 #ef _comparable_elements(self):
 #f self._adapt_to_entity:
 #eturn [
 #etattr(self._adapt_to_entity.entity, prop.key)
 #or prop in self.prop._comparable_elements
 #
 #lse:
 #eturn self.prop._comparable_elements

 #ef __eq__(self, other):
 #f other is None:
 #alues = [None] * len(self.prop._comparable_elements)
 #lse:
 #alues = other.__composite_values__()
 #omparisons = [
 # == b for a, b in zip(self.prop._comparable_elements, values)
 #
 #f self._adapt_to_entity:
 #omparisons = [self.adapter(x) for x in comparisons]
 #eturn sql.and_(*comparisons)

 #ef __ne__(self, other):
 #eturn sql.not_(self.__eq__(other))

 #ef __str__(self):
 #eturn str(self.parent.class_.__name__) + "." + self.key


class ConcreteInheritedProperty(DescriptorProperty):
 #""A 'do nothing' :class:`.MapperProperty` that disables
 #n attribute on a concrete subclass that is only present
 #n the inherited mapper, not the concrete classes' mapper.

 #ases where this occurs include:

 # When the superclass mapper is mapped against a
 #polymorphic union", which includes all attributes from
 #ll subclasses.
 # When a relationship() is configured on an inherited mapper,
 #ut not on the subclass mapper.  Concrete mappers require
 #hat relationship() is configured explicitly on each
 #ubclass.

 #""

 #ef _comparator_factory(self, mapper):
 #omparator_callable = None

 #or m in self.parent.iterate_to_root():
 # = m._props[self.key]
 #f not isinstance(p, ConcreteInheritedProperty):
 #omparator_callable = p.comparator_factory
 #reak
 #eturn comparator_callable

 #ef __init__(self):
 #uper(ConcreteInheritedProperty, self).__init__()

 #ef warn():
 #aise AttributeError(
 #Concrete %s does not implement "
 #attribute %r at the instance level.  Add "
 #this property explicitly to %s."
 # (self.parent, self.key, self.parent)
 #

 #lass NoninheritedConcreteProp(object):
 #ef __set__(s, obj, value):
 #arn()

 #ef __delete__(s, obj):
 #arn()

 #ef __get__(s, obj, owner):
 #f obj is None:
 #eturn self.descriptor
 #arn()

 #elf.descriptor = NoninheritedConcreteProp()


class SynonymProperty(DescriptorProperty):
 #ef __init__(
 #elf,
 #ame,
 #ap_column=None,
 #escriptor=None,
 #omparator_factory=None,
 #oc=None,
 #nfo=None,
 #:
 #""Denote an attribute name as a synonym to a mapped property,
 #n that the attribute will mirror the value and expression behavior
 #f another attribute.

 #.g.::

 #lass MyClass(Base):
 #_tablename__ = 'my_table'

 #d = Column(Integer, primary_key=True)
 #ob_status = Column(String(50))

 #tatus = synonym("job_status")


 #param name: the name of the existing mapped property.  This
 #an refer to the string name ORM-mapped attribute
 #onfigured on the class, including column-bound attributes
 #nd relationships.

 #param descriptor: a Python :term:`descriptor` that will be used
 #s a getter (and potentially a setter) when this attribute is
 #ccessed at the instance level.

 #param map_column: **For classical mappings and mappings against
 #n existing Table object only**.  if ``True``, the :func:`.synonym`
 #onstruct will locate the :class:`_schema.Column`
 #bject upon the mapped
 #able that would normally be associated with the attribute name of
 #his synonym, and produce a new :class:`.ColumnProperty` that instead
 #aps this :class:`_schema.Column`
 #o the alternate name given as the "name"
 #rgument of the synonym; in this way, the usual step of redefining
 #he mapping of the :class:`_schema.Column`
 #o be under a different name is
 #nnecessary. This is usually intended to be used when a
 #class:`_schema.Column`
 #s to be replaced with an attribute that also uses a
 #escriptor, that is, in conjunction with the
 #paramref:`.synonym.descriptor` parameter::

 #y_table = Table(
 #my_table", metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('job_status', String(50))
 #

 #lass MyClass(object):
 #property
 #ef _job_status_descriptor(self):
 #eturn "Status: %s" % self._job_status


 #apper(
 #yClass, my_table, properties={
 #job_status": synonym(
 #_job_status", map_column=True,
 #escriptor=MyClass._job_status_descriptor)
 #
 #

 #bove, the attribute named ``_job_status`` is automatically
 #apped to the ``job_status`` column::

 #>> j1 = MyClass()
 #>> j1._job_status = "employed"
 #>> j1.job_status
 #tatus: employed

 #hen using Declarative, in order to provide a descriptor in
 #onjunction with a synonym, use the
 #func:`sqlalchemy.ext.declarative.synonym_for` helper.  However,
 #ote that the :ref:`hybrid properties <mapper_hybrids>` feature
 #hould usually be preferred, particularly when redefining attribute
 #ehavior.

 #param info: Optional data dictionary which will be populated into the
 #attr:`.InspectionAttr.info` attribute of this object.

 #. versionadded:: 1.0.0

 #param comparator_factory: A subclass of :class:`.PropComparator`
 #hat will provide custom comparison behavior at the SQL expression
 #evel.

 #. note::

 #or the use case of providing an attribute which redefines both
 #ython-level and SQL-expression level behavior of an attribute,
 #lease refer to the Hybrid attribute introduced at
 #ref:`mapper_hybrids` for a more effective technique.

 #. seealso::

 #ref:`synonyms` - Overview of synonyms

 #func:`.synonym_for` - a helper oriented towards Declarative

 #ref:`mapper_hybrids` - The Hybrid Attribute extension provides an
 #pdated approach to augmenting attribute behavior more flexibly
 #han can be achieved with synonyms.

 #""
 #uper(SynonymProperty, self).__init__()

 #elf.name = name
 #elf.map_column = map_column
 #elf.descriptor = descriptor
 #elf.comparator_factory = comparator_factory
 #elf.doc = doc or (descriptor and descriptor.__doc__) or None
 #f info:
 #elf.info = info

 #til.set_creation_order(self)

 #property
 #ef uses_objects(self):
 #eturn getattr(self.parent.class_, self.name).impl.uses_objects

    # TODO: when initialized, check _proxied_object,
    # emit a warning if its not a column-based property

 #util.memoized_property
 #ef _proxied_object(self):
 #ttr = getattr(self.parent.class_, self.name)
 #f not hasattr(attr, "property") or not isinstance(
 #ttr.property, MapperProperty
 #:
            # attribute is a non-MapperProprerty proxy such as
            # hybrid or association proxy
 #f isinstance(attr, attributes.QueryableAttribute):
 #eturn attr.comparator
 #lif isinstance(attr, operators.ColumnOperators):
 #eturn attr

 #aise sa_exc.InvalidRequestError(
 #""synonym() attribute "%s.%s" only supports """
 #""ORM mapped attributes, got %r"""
 # (self.parent.class_.__name__, self.name, attr)
 #
 #eturn attr.property

 #ef _comparator_factory(self, mapper):
 #rop = self._proxied_object

 #f isinstance(prop, MapperProperty):
 #f self.comparator_factory:
 #omp = self.comparator_factory(prop, mapper)
 #lse:
 #omp = prop.comparator_factory(prop, mapper)
 #eturn comp
 #lse:
 #eturn prop

 #ef get_history(self, *arg, **kw):
 #ttr = getattr(self.parent.class_, self.name)
 #eturn attr.impl.get_history(*arg, **kw)

 #util.preload_module("sqlalchemy.orm.properties")
 #ef set_parent(self, parent, init):
 #roperties = util.preloaded.orm_properties

 #f self.map_column:
            # implement the 'map_column' option.
 #f self.key not in parent.persist_selectable.c:
 #aise sa_exc.ArgumentError(
 #Can't compile synonym '%s': no column on table "
 #'%s' named '%s'"
 # (
 #elf.name,
 #arent.persist_selectable.description,
 #elf.key,
 #
 #
 #lif (
 #arent.persist_selectable.c[self.key]
 #n parent._columntoproperty
 #nd parent._columntoproperty[
 #arent.persist_selectable.c[self.key]
 #.key
 #= self.name
 #:
 #aise sa_exc.ArgumentError(
 #Can't call map_column=True for synonym %r=%r, "
 #a ColumnProperty already exists keyed to the name "
 #%r for column %r"
 # (self.key, self.name, self.name, self.key)
 #
 # = properties.ColumnProperty(
 #arent.persist_selectable.c[self.key]
 #
 #arent._configure_property(self.name, p, init=init, setparent=True)
 #._mapped_by_synonym = self.key

 #elf.parent = parent
