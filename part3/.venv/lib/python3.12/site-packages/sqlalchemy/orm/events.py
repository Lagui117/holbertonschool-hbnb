# orm/events.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""ORM event interfaces.

"""
import weakref

from . import instrumentation
from . import interfaces
from . import mapperlib
from .attributes import QueryableAttribute
from .base import _mapper_or_none
from .query import Query
from .scoping import scoped_session
from .session import Session
from .session import sessionmaker
from .. import event
from .. import exc
from .. import util
from ..util.compat import inspect_getfullargspec


class InstrumentationEvents(event.Events):
 #""Events related to class instrumentation events.

 #he listeners here support being established against
 #ny new style class, that is any object that is a subclass
 #f 'type'.  Events will then be fired off for events
 #gainst that class.  If the "propagate=True" flag is passed
 #o event.listen(), the event will fire off for subclasses
 #f that class as well.

 #he Python ``type`` builtin is also accepted as a target,
 #hich when used has the effect of events being emitted
 #or all classes.

 #ote the "propagate" flag here is defaulted to ``True``,
 #nlike the other class level events where it defaults
 #o ``False``.  This means that new subclasses will also
 #e the subject of these events, when a listener
 #s established on a superclass.

 #""

 #target_class_doc = "SomeBaseClass"
 #dispatch_target = instrumentation.InstrumentationFactory

 #classmethod
 #ef _accept_with(cls, target):
 #f isinstance(target, type):
 #eturn _InstrumentationEventsHold(target)
 #lse:
 #eturn None

 #classmethod
 #ef _listen(cls, event_key, propagate=True, **kw):
 #arget, identifier, fn = (
 #vent_key.dispatch_target,
 #vent_key.identifier,
 #vent_key._listen_fn,
 #

 #ef listen(target_cls, *arg):
 #isten_cls = target()

            # if weakref were collected, however this is not something
            # that normally happens.   it was occurring during test teardown
            # between mapper/registry/instrumentation_manager, however this
            # interaction was changed to not rely upon the event system.
 #f listen_cls is None:
 #eturn None

 #f propagate and issubclass(target_cls, listen_cls):
 #eturn fn(target_cls, *arg)
 #lif not propagate and target_cls is listen_cls:
 #eturn fn(target_cls, *arg)

 #ef remove(ref):
 #ey = event.registry._EventKey(
 #one,
 #dentifier,
 #isten,
 #nstrumentation._instrumentation_factory,
 #
 #etattr(
 #nstrumentation._instrumentation_factory.dispatch, identifier
 #.remove(key)

 #arget = weakref.ref(target.class_, remove)

 #vent_key.with_dispatch_target(
 #nstrumentation._instrumentation_factory
 #.with_wrapper(listen).base_listen(**kw)

 #classmethod
 #ef _clear(cls):
 #uper(InstrumentationEvents, cls)._clear()
 #nstrumentation._instrumentation_factory.dispatch._clear()

 #ef class_instrument(self, cls):
 #""Called after the given class is instrumented.

 #o get at the :class:`.ClassManager`, use
 #func:`.manager_of_class`.

 #""

 #ef class_uninstrument(self, cls):
 #""Called before the given class is uninstrumented.

 #o get at the :class:`.ClassManager`, use
 #func:`.manager_of_class`.

 #""

 #ef attribute_instrument(self, cls, key, inst):
 #""Called when an attribute is instrumented."""


class _InstrumentationEventsHold(object):
 #""temporary marker object used to transfer from _accept_with() to
 #listen() on the InstrumentationEvents class.

 #""

 #ef __init__(self, class_):
 #elf.class_ = class_

 #ispatch = event.dispatcher(InstrumentationEvents)


class InstanceEvents(event.Events):
 #""Define events specific to object lifecycle.

 #.g.::

 #rom sqlalchemy import event

 #ef my_load_listener(target, context):
 #rint("on load!")

 #vent.listen(SomeClass, 'load', my_load_listener)

 #vailable targets include:

 # mapped classes
 # unmapped superclasses of mapped or to-be-mapped classes
 #using the ``propagate=True`` flag)
 # :class:`_orm.Mapper` objects
 # the :class:`_orm.Mapper` class itself and the :func:`.mapper`
 #unction indicate listening for all mappers.

 #nstance events are closely related to mapper events, but
 #re more specific to the instance and its instrumentation,
 #ather than its system of persistence.

 #hen using :class:`.InstanceEvents`, several modifiers are
 #vailable to the :func:`.event.listen` function.

 #param propagate=False: When True, the event listener should
 #e applied to all inheriting classes as well as the
 #lass which is the target of this listener.
 #param raw=False: When True, the "target" argument passed
 #o applicable event listener functions will be the
 #nstance's :class:`.InstanceState` management
 #bject, rather than the mapped instance itself.
 #param restore_load_context=False: Applies to the
 #meth:`.InstanceEvents.load` and :meth:`.InstanceEvents.refresh`
 #vents.  Restores the loader context of the object when the event
 #ook is complete, so that ongoing eager load operations continue
 #o target the object appropriately.  A warning is emitted if the
 #bject is moved to a new loader context from within one of these
 #vents if this flag is not set.

 #. versionadded:: 1.3.14


 #""

 #target_class_doc = "SomeClass"

 #dispatch_target = instrumentation.ClassManager

 #classmethod
 #ef _new_classmanager_instance(cls, class_, classmanager):
 #InstanceEventsHold.populate(class_, classmanager)

 #classmethod
 #util.preload_module("sqlalchemy.orm")
 #ef _accept_with(cls, target):
 #rm = util.preloaded.orm

 #f isinstance(target, instrumentation.ClassManager):
 #eturn target
 #lif isinstance(target, mapperlib.Mapper):
 #eturn target.class_manager
 #lif target is orm.mapper:
 #eturn instrumentation.ClassManager
 #lif isinstance(target, type):
 #f issubclass(target, mapperlib.Mapper):
 #eturn instrumentation.ClassManager
 #lse:
 #anager = instrumentation.manager_of_class(target)
 #f manager:
 #eturn manager
 #lse:
 #eturn _InstanceEventsHold(target)
 #eturn None

 #classmethod
 #ef _listen(
 #ls,
 #vent_key,
 #aw=False,
 #ropagate=False,
 #estore_load_context=False,
 #*kw
 #:
 #arget, fn = (event_key.dispatch_target, event_key._listen_fn)

 #f not raw or restore_load_context:

 #ef wrap(state, *arg, **kw):
 #f not raw:
 #arget = state.obj()
 #lse:
 #arget = state
 #f restore_load_context:
 #unid = state.runid
 #ry:
 #eturn fn(target, *arg, **kw)
 #inally:
 #f restore_load_context:
 #tate.runid = runid

 #vent_key = event_key.with_wrapper(wrap)

 #vent_key.base_listen(propagate=propagate, **kw)

 #f propagate:
 #or mgr in target.subclass_managers(True):
 #vent_key.with_dispatch_target(mgr).base_listen(propagate=True)

 #classmethod
 #ef _clear(cls):
 #uper(InstanceEvents, cls)._clear()
 #InstanceEventsHold._clear()

 #ef first_init(self, manager, cls):
 #""Called when the first instance of a particular mapping is called.

 #his event is called when the ``__init__`` method of a class
 #s called the first time for that particular class.    The event
 #nvokes before ``__init__`` actually proceeds as well as before
 #he :meth:`.InstanceEvents.init` event is invoked.

 #""

 #ef init(self, target, args, kwargs):
 #""Receive an instance when its constructor is called.

 #his method is only called during a userland construction of
 #n object, in conjunction with the object's constructor, e.g.
 #ts ``__init__`` method.  It is not called when an object is
 #oaded from the database; see the :meth:`.InstanceEvents.load`
 #vent in order to intercept a database load.

 #he event is called before the actual ``__init__`` constructor
 #f the object is called.  The ``kwargs`` dictionary may be
 #odified in-place in order to affect what is passed to
 #`__init__``.

 #param target: the mapped instance.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #param args: positional arguments passed to the ``__init__`` method.
 #his is passed as a tuple and is currently immutable.
 #param kwargs: keyword arguments passed to the ``__init__`` method.
 #his structure *can* be altered in place.

 #. seealso::

 #meth:`.InstanceEvents.init_failure`

 #meth:`.InstanceEvents.load`

 #""

 #ef init_failure(self, target, args, kwargs):
 #""Receive an instance when its constructor has been called,
 #nd raised an exception.

 #his method is only called during a userland construction of
 #n object, in conjunction with the object's constructor, e.g.
 #ts ``__init__`` method. It is not called when an object is loaded
 #rom the database.

 #he event is invoked after an exception raised by the ``__init__``
 #ethod is caught.  After the event
 #s invoked, the original exception is re-raised outwards, so that
 #he construction of the object still raises an exception.   The
 #ctual exception and stack trace raised should be present in
 #`sys.exc_info()``.

 #param target: the mapped instance.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #param args: positional arguments that were passed to the ``__init__``
 #ethod.
 #param kwargs: keyword arguments that were passed to the ``__init__``
 #ethod.

 #. seealso::

 #meth:`.InstanceEvents.init`

 #meth:`.InstanceEvents.load`

 #""

 #ef load(self, target, context):
 #""Receive an object instance after it has been created via
 #`__new__``, and after initial attribute population has
 #ccurred.

 #his typically occurs when the instance is created based on
 #ncoming result rows, and is only called once for that
 #nstance's lifetime.

 #. warning::

 #uring a result-row load, this event is invoked when the
 #irst row received for this instance is processed.  When using
 #ager loading with collection-oriented attributes, the additional
 #ows that are to be loaded / processed in order to load subsequent
 #ollection items have not occurred yet.   This has the effect
 #oth that collections will not be fully loaded, as well as that
 #f an operation occurs within this event handler that emits
 #nother database load operation for the object, the "loading
 #ontext" for the object can change and interfere with the
 #xisting eager loaders still in progress.

 #xamples of what can cause the "loading context" to change within
 #he event handler include, but are not necessarily limited to:

 # accessing deferred attributes that weren't part of the row,
 #ill trigger an "undefer" operation and refresh the object

 # accessing attributes on a joined-inheritance subclass that
 #eren't part of the row, will trigger a refresh operation.

 #s of SQLAlchemy 1.3.14, a warning is emitted when this occurs. The
 #paramref:`.InstanceEvents.restore_load_context` option may  be
 #sed on the event to prevent this warning; this will ensure that
 #he existing loading context is maintained for the object after the
 #vent is called::

 #event.listens_for(
 #omeClass, "load", restore_load_context=True)
 #ef on_load(instance, context):
 #nstance.some_unloaded_attribute

 #. versionchanged:: 1.3.14 Added
 #paramref:`.InstanceEvents.restore_load_context`
 #nd :paramref:`.SessionEvents.restore_load_context` flags which
 #pply to "on load" events, which will ensure that the loading
 #ontext for an object is restored when the event hook is
 #omplete; a warning is emitted if the load context of the object
 #hanges without this flag being set.


 #he :meth:`.InstanceEvents.load` event is also available in a
 #lass-method decorator format called :func:`_orm.reconstructor`.

 #param target: the mapped instance.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #param context: the :class:`.QueryContext` corresponding to the
 #urrent :class:`_query.Query` in progress.  This argument may be
 #`None`` if the load does not correspond to a :class:`_query.Query`,
 #uch as during :meth:`.Session.merge`.

 #. seealso::

 #meth:`.InstanceEvents.init`

 #meth:`.InstanceEvents.refresh`

 #meth:`.SessionEvents.loaded_as_persistent`

 #ref:`mapping_constructors`

 #""

 #ef refresh(self, target, context, attrs):
 #""Receive an object instance after one or more attributes have
 #een refreshed from a query.

 #ontrast this to the :meth:`.InstanceEvents.load` method, which
 #s invoked when the object is first loaded from a query.

 #. note:: This event is invoked within the loader process before
 #ager loaders may have been completed, and the object's state may
 #ot be complete.  Additionally, invoking row-level refresh
 #perations on the object will place the object into a new loader
 #ontext, interfering with the existing load context.   See the note
 #n :meth:`.InstanceEvents.load` for background on making use of the
 #paramref:`.InstanceEvents.restore_load_context` parameter, in
 #rder to resolve this scenario.

 #param target: the mapped instance.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #param context: the :class:`.QueryContext` corresponding to the
 #urrent :class:`_query.Query` in progress.
 #param attrs: sequence of attribute names which
 #ere populated, or None if all column-mapped, non-deferred
 #ttributes were populated.

 #. seealso::

 #meth:`.InstanceEvents.load`

 #""

 #ef refresh_flush(self, target, flush_context, attrs):
 #""Receive an object instance after one or more attributes that
 #ontain a column-level default or onupdate handler have been refreshed
 #uring persistence of the object's state.

 #his event is the same as :meth:`.InstanceEvents.refresh` except
 #t is invoked within the unit of work flush process, and includes
 #nly non-primary-key columns that have column level default or
 #nupdate handlers, including Python callables as well as server side
 #efaults and triggers which may be fetched via the RETURNING clause.

 #. note::

 #hile the :meth:`.InstanceEvents.refresh_flush` event is triggered
 #or an object that was INSERTed as well as for an object that was
 #PDATEd, the event is geared primarily  towards the UPDATE process;
 #t is mostly an internal artifact that INSERT actions can also
 #rigger this event, and note that **primary key columns for an
 #NSERTed row are explicitly omitted** from this event.  In order to
 #ntercept the newly INSERTed state of an object, the
 #meth:`.SessionEvents.pending_to_persistent` and
 #meth:`.MapperEvents.after_insert` are better choices.

 #. versionadded:: 1.0.5

 #param target: the mapped instance.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #param flush_context: Internal :class:`.UOWTransaction` object
 #hich handles the details of the flush.
 #param attrs: sequence of attribute names which
 #ere populated.

 #. seealso::

 #ref:`orm_server_defaults`

 #ref:`metadata_defaults_toplevel`

 #""

 #ef expire(self, target, attrs):
 #""Receive an object instance after its attributes or some subset
 #ave been expired.

 #keys' is a list of attribute names.  If None, the entire
 #tate was expired.

 #param target: the mapped instance.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #param attrs: sequence of attribute
 #ames which were expired, or None if all attributes were
 #xpired.

 #""

 #ef pickle(self, target, state_dict):
 #""Receive an object instance when its associated state is
 #eing pickled.

 #param target: the mapped instance.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #param state_dict: the dictionary returned by
 #class:`.InstanceState.__getstate__`, containing the state
 #o be pickled.

 #""

 #ef unpickle(self, target, state_dict):
 #""Receive an object instance after its associated state has
 #een unpickled.

 #param target: the mapped instance.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #param state_dict: the dictionary sent to
 #class:`.InstanceState.__setstate__`, containing the state
 #ictionary which was pickled.

 #""


class _EventsHold(event.RefCollection):
 #""Hold onto listeners against unmapped, uninstrumented classes.

 #stablish _listen() for that class' mapper/instrumentation when
 #hose objects are created for that class.

 #""

 #ef __init__(self, class_):
 #elf.class_ = class_

 #classmethod
 #ef _clear(cls):
 #ls.all_holds.clear()

 #lass HoldEvents(object):
 #dispatch_target = None

 #classmethod
 #ef _listen(
 #ls, event_key, raw=False, propagate=False, retval=False, **kw
 #:
 #arget = event_key.dispatch_target

 #f target.class_ in target.all_holds:
 #ollection = target.all_holds[target.class_]
 #lse:
 #ollection = target.all_holds[target.class_] = {}

 #vent.registry._stored_in_collection(event_key, target)
 #ollection[event_key._key] = (
 #vent_key,
 #aw,
 #ropagate,
 #etval,
 #w,
 #

 #f propagate:
 #tack = list(target.class_.__subclasses__())
 #hile stack:
 #ubclass = stack.pop(0)
 #tack.extend(subclass.__subclasses__())
 #ubject = target.resolve(subclass)
 #f subject is not None:
                        # we are already going through __subclasses__()
                        # so leave generic propagate flag False
 #vent_key.with_dispatch_target(subject).listen(
 #aw=raw, propagate=False, retval=retval, **kw
 #

 #ef remove(self, event_key):
 #arget = event_key.dispatch_target

 #f isinstance(target, _EventsHold):
 #ollection = target.all_holds[target.class_]
 #el collection[event_key._key]

 #classmethod
 #ef populate(cls, class_, subject):
 #or subclass in class_.__mro__:
 #f subclass in cls.all_holds:
 #ollection = cls.all_holds[subclass]
 #or (
 #vent_key,
 #aw,
 #ropagate,
 #etval,
 #w,
 # in collection.values():
 #f propagate or subclass is class_:
                        # since we can't be sure in what order different
                        # classes in a hierarchy are triggered with
                        # populate(), we rely upon _EventsHold for all event
                        # assignment, instead of using the generic propagate
                        # flag.
 #vent_key.with_dispatch_target(subject).listen(
 #aw=raw, propagate=False, retval=retval, **kw
 #


class _InstanceEventsHold(_EventsHold):
 #ll_holds = weakref.WeakKeyDictionary()

 #ef resolve(self, class_):
 #eturn instrumentation.manager_of_class(class_)

 #lass HoldInstanceEvents(_EventsHold.HoldEvents, InstanceEvents):
 #ass

 #ispatch = event.dispatcher(HoldInstanceEvents)


class MapperEvents(event.Events):
 #""Define events specific to mappings.

 #.g.::

 #rom sqlalchemy import event

 #ef my_before_insert_listener(mapper, connection, target):
            # execute a stored procedure upon INSERT,
            # apply the value to the row to be inserted
 #arget.calculated_value = connection.execute(
 #ext("select my_special_function(%d)" % target.special_number)
 #.scalar()

        # associate the listener function with SomeClass,
        # to execute during the "before_insert" hook
 #vent.listen(
 #omeClass, 'before_insert', my_before_insert_listener)

 #vailable targets include:

 # mapped classes
 # unmapped superclasses of mapped or to-be-mapped classes
 #using the ``propagate=True`` flag)
 # :class:`_orm.Mapper` objects
 # the :class:`_orm.Mapper` class itself and the :func:`.mapper`
 #unction indicate listening for all mappers.

 #apper events provide hooks into critical sections of the
 #apper, including those related to object instrumentation,
 #bject loading, and object persistence. In particular, the
 #ersistence methods :meth:`~.MapperEvents.before_insert`,
 #nd :meth:`~.MapperEvents.before_update` are popular
 #laces to augment the state being persisted - however, these
 #ethods operate with several significant restrictions. The
 #ser is encouraged to evaluate the
 #meth:`.SessionEvents.before_flush` and
 #meth:`.SessionEvents.after_flush` methods as more
 #lexible and user-friendly hooks in which to apply
 #dditional database state during a flush.

 #hen using :class:`.MapperEvents`, several modifiers are
 #vailable to the :func:`.event.listen` function.

 #param propagate=False: When True, the event listener should
 #e applied to all inheriting mappers and/or the mappers of
 #nheriting classes, as well as any
 #apper which is the target of this listener.
 #param raw=False: When True, the "target" argument passed
 #o applicable event listener functions will be the
 #nstance's :class:`.InstanceState` management
 #bject, rather than the mapped instance itself.
 #param retval=False: when True, the user-defined event function
 #ust have a return value, the purpose of which is either to
 #ontrol subsequent event propagation, or to otherwise alter
 #he operation in progress by the mapper.   Possible return
 #alues are:

 # ``sqlalchemy.orm.interfaces.EXT_CONTINUE`` - continue event
 #rocessing normally.
 # ``sqlalchemy.orm.interfaces.EXT_STOP`` - cancel all subsequent
 #vent handlers in the chain.
 # other values - the return value specified by specific listeners.

 #""

 #target_class_doc = "SomeClass"
 #dispatch_target = mapperlib.Mapper

 #classmethod
 #ef _new_mapper_instance(cls, class_, mapper):
 #MapperEventsHold.populate(class_, mapper)

 #classmethod
 #util.preload_module("sqlalchemy.orm")
 #ef _accept_with(cls, target):
 #rm = util.preloaded.orm

 #f target is orm.mapper:
 #eturn mapperlib.Mapper
 #lif isinstance(target, type):
 #f issubclass(target, mapperlib.Mapper):
 #eturn target
 #lse:
 #apper = _mapper_or_none(target)
 #f mapper is not None:
 #eturn mapper
 #lse:
 #eturn _MapperEventsHold(target)
 #lse:
 #eturn target

 #classmethod
 #ef _listen(
 #ls, event_key, raw=False, retval=False, propagate=False, **kw
 #:
 #arget, identifier, fn = (
 #vent_key.dispatch_target,
 #vent_key.identifier,
 #vent_key._listen_fn,
 #

 #f (
 #dentifier in ("before_configured", "after_configured")
 #nd target is not mapperlib.Mapper
 #:
 #til.warn(
 #'before_configured' and 'after_configured' ORM events "
 #only invoke with the mapper() function or Mapper class "
 #as the target."
 #

 #f not raw or not retval:
 #f not raw:
 #eth = getattr(cls, identifier)
 #ry:
 #arget_index = (
 #nspect_getfullargspec(meth)[0].index("target") - 1
 #
 #xcept ValueError:
 #arget_index = None

 #ef wrap(*arg, **kw):
 #f not raw and target_index is not None:
 #rg = list(arg)
 #rg[target_index] = arg[target_index].obj()
 #f not retval:
 #n(*arg, **kw)
 #eturn interfaces.EXT_CONTINUE
 #lse:
 #eturn fn(*arg, **kw)

 #vent_key = event_key.with_wrapper(wrap)

 #f propagate:
 #or mapper in target.self_and_descendants:
 #vent_key.with_dispatch_target(mapper).base_listen(
 #ropagate=True, **kw
 #
 #lse:
 #vent_key.base_listen(**kw)

 #classmethod
 #ef _clear(cls):
 #uper(MapperEvents, cls)._clear()
 #MapperEventsHold._clear()

 #ef instrument_class(self, mapper, class_):
 #"""Receive a class when the mapper is first constructed,
 #efore instrumentation is applied to the mapped class.

 #his event is the earliest phase of mapper construction.
 #ost attributes of the mapper are not yet initialized.

 #his listener can either be applied to the :class:`_orm.Mapper`
 #lass overall, or to any un-mapped class which serves as a base
 #or classes that will be mapped (using the ``propagate=True`` flag)::

 #ase = declarative_base()

 #event.listens_for(Base, "instrument_class", propagate=True)
 #ef on_new_class(mapper, cls_):
 # ... "

 #param mapper: the :class:`_orm.Mapper` which is the target
 #f this event.
 #param class\_: the mapped class.

 #""

 #ef before_mapper_configured(self, mapper, class_):
 #""Called right before a specific mapper is to be configured.

 #his event is intended to allow a specific mapper to be skipped during
 #he configure step, by returning the :attr:`.orm.interfaces.EXT_SKIP`
 #ymbol which indicates to the :func:`.configure_mappers` call that this
 #articular mapper (or hierarchy of mappers, if ``propagate=True`` is
 #sed) should be skipped in the current configuration run.  When one or
 #ore mappers are skipped, the he "new mappers" flag will remain set,
 #eaning the :func:`.configure_mappers` function will continue to be
 #alled when mappers are used, to continue to try to configure all
 #vailable mappers.

 #n comparison to the other configure-level events,
 #meth:`.MapperEvents.before_configured`,
 #meth:`.MapperEvents.after_configured`, and
 #meth:`.MapperEvents.mapper_configured`, the
 #meth;`.MapperEvents.before_mapper_configured` event provides for a
 #eaningful return value when it is registered with the ``retval=True``
 #arameter.

 #. versionadded:: 1.3

 #.g.::

 #rom sqlalchemy.orm import EXT_SKIP

 #ase = declarative_base()

 #ontConfigureBase = declarative_base()

 #event.listens_for(
 #ontConfigureBase,
 #before_mapper_configured", retval=True, propagate=True)
 #ef dont_configure(mapper, cls):
 #eturn EXT_SKIP


 #. seealso::

 #meth:`.MapperEvents.before_configured`

 #meth:`.MapperEvents.after_configured`

 #meth:`.MapperEvents.mapper_configured`

 #""

 #ef mapper_configured(self, mapper, class_):
 #"""Called when a specific mapper has completed its own configuration
 #ithin the scope of the :func:`.configure_mappers` call.

 #he :meth:`.MapperEvents.mapper_configured` event is invoked
 #or each mapper that is encountered when the
 #func:`_orm.configure_mappers` function proceeds through the current
 #ist of not-yet-configured mappers.
 #func:`_orm.configure_mappers` is typically invoked
 #utomatically as mappings are first used, as well as each time
 #ew mappers have been made available and new mapper use is
 #etected.

 #hen the event is called, the mapper should be in its final
 #tate, but **not including backrefs** that may be invoked from
 #ther mappers; they might still be pending within the
 #onfiguration operation.    Bidirectional relationships that
 #re instead configured via the
 #paramref:`.orm.relationship.back_populates` argument
 #will* be fully available, since this style of relationship does not
 #ely upon other possibly-not-configured mappers to know that they
 #xist.

 #or an event that is guaranteed to have **all** mappers ready
 #o go including backrefs that are defined only on other
 #appings, use the :meth:`.MapperEvents.after_configured`
 #vent; this event invokes only after all known mappings have been
 #ully configured.

 #he :meth:`.MapperEvents.mapper_configured` event, unlike
 #meth:`.MapperEvents.before_configured` or
 #meth:`.MapperEvents.after_configured`,
 #s called for each mapper/class individually, and the mapper is
 #assed to the event itself.  It also is called exactly once for
 # particular mapper.  The event is therefore useful for
 #onfigurational steps that benefit from being invoked just once
 #n a specific mapper basis, which don't require that "backref"
 #onfigurations are necessarily ready yet.

 #param mapper: the :class:`_orm.Mapper` which is the target
 #f this event.
 #param class\_: the mapped class.

 #. seealso::

 #meth:`.MapperEvents.before_configured`

 #meth:`.MapperEvents.after_configured`

 #meth:`.MapperEvents.before_mapper_configured`

 #""
        # TODO: need coverage for this event

 #ef before_configured(self):
 #""Called before a series of mappers have been configured.

 #he :meth:`.MapperEvents.before_configured` event is invoked
 #ach time the :func:`_orm.configure_mappers` function is
 #nvoked, before the function has done any of its work.
 #func:`_orm.configure_mappers` is typically invoked
 #utomatically as mappings are first used, as well as each time
 #ew mappers have been made available and new mapper use is
 #etected.

 #his event can **only** be applied to the :class:`_orm.Mapper` class
 #r :func:`.mapper` function, and not to individual mappings or
 #apped classes.  It is only invoked for all mappings as a whole::

 #rom sqlalchemy.orm import mapper

 #event.listens_for(mapper, "before_configured")
 #ef go():
                # ...

 #ontrast this event to :meth:`.MapperEvents.after_configured`,
 #hich is invoked after the series of mappers has been configured,
 #s well as :meth:`.MapperEvents.before_mapper_configured`
 #nd :meth:`.MapperEvents.mapper_configured`, which are both invoked
 #n a per-mapper basis.

 #heoretically this event is called once per
 #pplication, but is actually called any time new mappers
 #re to be affected by a :func:`_orm.configure_mappers`
 #all.   If new mappings are constructed after existing ones have
 #lready been used, this event will likely be called again.  To ensure
 #hat a particular event is only called once and no further, the
 #`once=True`` argument (new in 0.9.4) can be applied::

 #rom sqlalchemy.orm import mapper

 #event.listens_for(mapper, "before_configured", once=True)
 #ef go():
                # ...


 #. versionadded:: 0.9.3


 #. seealso::

 #meth:`.MapperEvents.before_mapper_configured`

 #meth:`.MapperEvents.mapper_configured`

 #meth:`.MapperEvents.after_configured`

 #""

 #ef after_configured(self):
 #""Called after a series of mappers have been configured.

 #he :meth:`.MapperEvents.after_configured` event is invoked
 #ach time the :func:`_orm.configure_mappers` function is
 #nvoked, after the function has completed its work.
 #func:`_orm.configure_mappers` is typically invoked
 #utomatically as mappings are first used, as well as each time
 #ew mappers have been made available and new mapper use is
 #etected.

 #ontrast this event to the :meth:`.MapperEvents.mapper_configured`
 #vent, which is called on a per-mapper basis while the configuration
 #peration proceeds; unlike that event, when this event is invoked,
 #ll cross-configurations (e.g. backrefs) will also have been made
 #vailable for any mappers that were pending.
 #lso contrast to :meth:`.MapperEvents.before_configured`,
 #hich is invoked before the series of mappers has been configured.

 #his event can **only** be applied to the :class:`_orm.Mapper` class
 #r :func:`.mapper` function, and not to individual mappings or
 #apped classes.  It is only invoked for all mappings as a whole::

 #rom sqlalchemy.orm import mapper

 #event.listens_for(mapper, "after_configured")
 #ef go():
                # ...

 #heoretically this event is called once per
 #pplication, but is actually called any time new mappers
 #ave been affected by a :func:`_orm.configure_mappers`
 #all.   If new mappings are constructed after existing ones have
 #lready been used, this event will likely be called again.  To ensure
 #hat a particular event is only called once and no further, the
 #`once=True`` argument (new in 0.9.4) can be applied::

 #rom sqlalchemy.orm import mapper

 #event.listens_for(mapper, "after_configured", once=True)
 #ef go():
                # ...

 #. seealso::

 #meth:`.MapperEvents.before_mapper_configured`

 #meth:`.MapperEvents.mapper_configured`

 #meth:`.MapperEvents.before_configured`

 #""

 #ef before_insert(self, mapper, connection, target):
 #""Receive an object instance before an INSERT statement
 #s emitted corresponding to that instance.

 #his event is used to modify local, non-object related
 #ttributes on the instance before an INSERT occurs, as well
 #s to emit additional SQL statements on the given
 #onnection.

 #he event is often called for a batch of objects of the
 #ame class before their INSERT statements are emitted at
 #nce in a later step. In the extremely rare case that
 #his is not desirable, the :func:`.mapper` can be
 #onfigured with ``batch=False``, which will cause
 #atches of instances to be broken up into individual
 #and more poorly performing) event->persist->event
 #teps.

 #. warning::

 #apper-level flush events only allow **very limited operations**,
 #n attributes local to the row being operated upon only,
 #s well as allowing any SQL to be emitted on the given
 #class:`_engine.Connection`.  **Please read fully** the notes
 #t :ref:`session_persistence_mapper` for guidelines on using
 #hese methods; generally, the :meth:`.SessionEvents.before_flush`
 #ethod should be preferred for general on-flush changes.

 #param mapper: the :class:`_orm.Mapper` which is the target
 #f this event.
 #param connection: the :class:`_engine.Connection` being used to
 #mit INSERT statements for this instance.  This
 #rovides a handle into the current transaction on the
 #arget database specific to this instance.
 #param target: the mapped instance being persisted.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #return: No return value is supported by this event.

 #. seealso::

 #ref:`session_persistence_events`

 #""

 #ef after_insert(self, mapper, connection, target):
 #""Receive an object instance after an INSERT statement
 #s emitted corresponding to that instance.

 #his event is used to modify in-Python-only
 #tate on the instance after an INSERT occurs, as well
 #s to emit additional SQL statements on the given
 #onnection.

 #he event is often called for a batch of objects of the
 #ame class after their INSERT statements have been
 #mitted at once in a previous step. In the extremely
 #are case that this is not desirable, the
 #func:`.mapper` can be configured with ``batch=False``,
 #hich will cause batches of instances to be broken up
 #nto individual (and more poorly performing)
 #vent->persist->event steps.

 #. warning::

 #apper-level flush events only allow **very limited operations**,
 #n attributes local to the row being operated upon only,
 #s well as allowing any SQL to be emitted on the given
 #class:`_engine.Connection`.  **Please read fully** the notes
 #t :ref:`session_persistence_mapper` for guidelines on using
 #hese methods; generally, the :meth:`.SessionEvents.before_flush`
 #ethod should be preferred for general on-flush changes.

 #param mapper: the :class:`_orm.Mapper` which is the target
 #f this event.
 #param connection: the :class:`_engine.Connection` being used to
 #mit INSERT statements for this instance.  This
 #rovides a handle into the current transaction on the
 #arget database specific to this instance.
 #param target: the mapped instance being persisted.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #return: No return value is supported by this event.

 #. seealso::

 #ref:`session_persistence_events`

 #""

 #ef before_update(self, mapper, connection, target):
 #""Receive an object instance before an UPDATE statement
 #s emitted corresponding to that instance.

 #his event is used to modify local, non-object related
 #ttributes on the instance before an UPDATE occurs, as well
 #s to emit additional SQL statements on the given
 #onnection.

 #his method is called for all instances that are
 #arked as "dirty", *even those which have no net changes
 #o their column-based attributes*. An object is marked
 #s dirty when any of its column-based attributes have a
 #set attribute" operation called or when any of its
 #ollections are modified. If, at update time, no
 #olumn-based attributes have any net changes, no UPDATE
 #tatement will be issued. This means that an instance
 #eing sent to :meth:`~.MapperEvents.before_update` is
 #not* a guarantee that an UPDATE statement will be
 #ssued, although you can affect the outcome here by
 #odifying attributes so that a net change in value does
 #xist.

 #o detect if the column-based attributes on the object have net
 #hanges, and will therefore generate an UPDATE statement, use
 #`object_session(instance).is_modified(instance,
 #nclude_collections=False)``.

 #he event is often called for a batch of objects of the
 #ame class before their UPDATE statements are emitted at
 #nce in a later step. In the extremely rare case that
 #his is not desirable, the :func:`.mapper` can be
 #onfigured with ``batch=False``, which will cause
 #atches of instances to be broken up into individual
 #and more poorly performing) event->persist->event
 #teps.

 #. warning::

 #apper-level flush events only allow **very limited operations**,
 #n attributes local to the row being operated upon only,
 #s well as allowing any SQL to be emitted on the given
 #class:`_engine.Connection`.  **Please read fully** the notes
 #t :ref:`session_persistence_mapper` for guidelines on using
 #hese methods; generally, the :meth:`.SessionEvents.before_flush`
 #ethod should be preferred for general on-flush changes.

 #param mapper: the :class:`_orm.Mapper` which is the target
 #f this event.
 #param connection: the :class:`_engine.Connection` being used to
 #mit UPDATE statements for this instance.  This
 #rovides a handle into the current transaction on the
 #arget database specific to this instance.
 #param target: the mapped instance being persisted.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #return: No return value is supported by this event.

 #. seealso::

 #ref:`session_persistence_events`

 #""

 #ef after_update(self, mapper, connection, target):
 #""Receive an object instance after an UPDATE statement
 #s emitted corresponding to that instance.

 #his event is used to modify in-Python-only
 #tate on the instance after an UPDATE occurs, as well
 #s to emit additional SQL statements on the given
 #onnection.

 #his method is called for all instances that are
 #arked as "dirty", *even those which have no net changes
 #o their column-based attributes*, and for which
 #o UPDATE statement has proceeded. An object is marked
 #s dirty when any of its column-based attributes have a
 #set attribute" operation called or when any of its
 #ollections are modified. If, at update time, no
 #olumn-based attributes have any net changes, no UPDATE
 #tatement will be issued. This means that an instance
 #eing sent to :meth:`~.MapperEvents.after_update` is
 #not* a guarantee that an UPDATE statement has been
 #ssued.

 #o detect if the column-based attributes on the object have net
 #hanges, and therefore resulted in an UPDATE statement, use
 #`object_session(instance).is_modified(instance,
 #nclude_collections=False)``.

 #he event is often called for a batch of objects of the
 #ame class after their UPDATE statements have been emitted at
 #nce in a previous step. In the extremely rare case that
 #his is not desirable, the :func:`.mapper` can be
 #onfigured with ``batch=False``, which will cause
 #atches of instances to be broken up into individual
 #and more poorly performing) event->persist->event
 #teps.

 #. warning::

 #apper-level flush events only allow **very limited operations**,
 #n attributes local to the row being operated upon only,
 #s well as allowing any SQL to be emitted on the given
 #class:`_engine.Connection`.  **Please read fully** the notes
 #t :ref:`session_persistence_mapper` for guidelines on using
 #hese methods; generally, the :meth:`.SessionEvents.before_flush`
 #ethod should be preferred for general on-flush changes.

 #param mapper: the :class:`_orm.Mapper` which is the target
 #f this event.
 #param connection: the :class:`_engine.Connection` being used to
 #mit UPDATE statements for this instance.  This
 #rovides a handle into the current transaction on the
 #arget database specific to this instance.
 #param target: the mapped instance being persisted.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #return: No return value is supported by this event.

 #. seealso::

 #ref:`session_persistence_events`

 #""

 #ef before_delete(self, mapper, connection, target):
 #""Receive an object instance before a DELETE statement
 #s emitted corresponding to that instance.

 #his event is used to emit additional SQL statements on
 #he given connection as well as to perform application
 #pecific bookkeeping related to a deletion event.

 #he event is often called for a batch of objects of the
 #ame class before their DELETE statements are emitted at
 #nce in a later step.

 #. warning::

 #apper-level flush events only allow **very limited operations**,
 #n attributes local to the row being operated upon only,
 #s well as allowing any SQL to be emitted on the given
 #class:`_engine.Connection`.  **Please read fully** the notes
 #t :ref:`session_persistence_mapper` for guidelines on using
 #hese methods; generally, the :meth:`.SessionEvents.before_flush`
 #ethod should be preferred for general on-flush changes.

 #param mapper: the :class:`_orm.Mapper` which is the target
 #f this event.
 #param connection: the :class:`_engine.Connection` being used to
 #mit DELETE statements for this instance.  This
 #rovides a handle into the current transaction on the
 #arget database specific to this instance.
 #param target: the mapped instance being deleted.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #return: No return value is supported by this event.

 #. seealso::

 #ref:`session_persistence_events`

 #""

 #ef after_delete(self, mapper, connection, target):
 #""Receive an object instance after a DELETE statement
 #as been emitted corresponding to that instance.

 #his event is used to emit additional SQL statements on
 #he given connection as well as to perform application
 #pecific bookkeeping related to a deletion event.

 #he event is often called for a batch of objects of the
 #ame class after their DELETE statements have been emitted at
 #nce in a previous step.

 #. warning::

 #apper-level flush events only allow **very limited operations**,
 #n attributes local to the row being operated upon only,
 #s well as allowing any SQL to be emitted on the given
 #class:`_engine.Connection`.  **Please read fully** the notes
 #t :ref:`session_persistence_mapper` for guidelines on using
 #hese methods; generally, the :meth:`.SessionEvents.before_flush`
 #ethod should be preferred for general on-flush changes.

 #param mapper: the :class:`_orm.Mapper` which is the target
 #f this event.
 #param connection: the :class:`_engine.Connection` being used to
 #mit DELETE statements for this instance.  This
 #rovides a handle into the current transaction on the
 #arget database specific to this instance.
 #param target: the mapped instance being deleted.  If
 #he event is configured with ``raw=True``, this will
 #nstead be the :class:`.InstanceState` state-management
 #bject associated with the instance.
 #return: No return value is supported by this event.

 #. seealso::

 #ref:`session_persistence_events`

 #""


class _MapperEventsHold(_EventsHold):
 #ll_holds = weakref.WeakKeyDictionary()

 #ef resolve(self, class_):
 #eturn _mapper_or_none(class_)

 #lass HoldMapperEvents(_EventsHold.HoldEvents, MapperEvents):
 #ass

 #ispatch = event.dispatcher(HoldMapperEvents)


_sessionevents_lifecycle_event_names = set()


class SessionEvents(event.Events):
 #""Define events specific to :class:`.Session` lifecycle.

 #.g.::

 #rom sqlalchemy import event
 #rom sqlalchemy.orm import sessionmaker

 #ef my_before_commit(session):
 #rint("before commit!")

 #ession = sessionmaker()

 #vent.listen(Session, "before_commit", my_before_commit)

 #he :func:`~.event.listen` function will accept
 #class:`.Session` objects as well as the return result
 #f :class:`~.sessionmaker()` and :class:`~.scoped_session()`.

 #dditionally, it accepts the :class:`.Session` class which
 #ill apply listeners to all :class:`.Session` instances
 #lobally.

 #param raw=False: When True, the "target" argument passed
 #o applicable event listener functions that work on individual
 #bjects will be the instance's :class:`.InstanceState` management
 #bject, rather than the mapped instance itself.

 #. versionadded:: 1.3.14

 #param restore_load_context=False: Applies to the
 #meth:`.SessionEvents.loaded_as_persistent` event.  Restores the loader
 #ontext of the object when the event hook is complete, so that ongoing
 #ager load operations continue to target the object appropriately.  A
 #arning is emitted if the object is moved to a new loader context from
 #ithin this event if this flag is not set.

 #. versionadded:: 1.3.14

 #""

 #target_class_doc = "SomeSessionOrFactory"

 #dispatch_target = Session

 #ef _lifecycle_event(fn):
 #sessionevents_lifecycle_event_names.add(fn.__name__)
 #eturn fn

 #classmethod
 #ef _accept_with(cls, target):
 #f isinstance(target, scoped_session):

 #arget = target.session_factory
 #f not isinstance(target, sessionmaker) and (
 #ot isinstance(target, type) or not issubclass(target, Session)
 #:
 #aise exc.ArgumentError(
 #Session event listen on a scoped_session "
 #requires that its creation callable "
 #is associated with the Session class."
 #

 #f isinstance(target, sessionmaker):
 #eturn target.class_
 #lif isinstance(target, type):
 #f issubclass(target, scoped_session):
 #eturn Session
 #lif issubclass(target, Session):
 #eturn target
 #lif isinstance(target, Session):
 #eturn target
 #lse:
            # allows alternate SessionEvents-like-classes to be consulted
 #eturn event.Events._accept_with(target)

 #classmethod
 #ef _listen(cls, event_key, raw=False, restore_load_context=False, **kw):
 #s_instance_event = (
 #vent_key.identifier in _sessionevents_lifecycle_event_names
 #

 #f is_instance_event:
 #f not raw or restore_load_context:

 #n = event_key._listen_fn

 #ef wrap(session, state, *arg, **kw):
 #f not raw:
 #arget = state.obj()
 #f target is None:
                            # existing behavior is that if the object is
                            # garbage collected, no event is emitted
 #eturn
 #lse:
 #arget = state
 #f restore_load_context:
 #unid = state.runid
 #ry:
 #eturn fn(session, target, *arg, **kw)
 #inally:
 #f restore_load_context:
 #tate.runid = runid

 #vent_key = event_key.with_wrapper(wrap)

 #vent_key.base_listen(**kw)

 #ef do_orm_execute(self, orm_execute_state):
 #""Intercept statement executions that occur in terms of a :class:`.Session`.

 #his event is invoked for all top-level SQL statements invoked
 #rom the :meth:`_orm.Session.execute` method.   As of SQLAlchemy 1.4,
 #ll ORM queries emitted on behalf of a :class:`_orm.Session` will
 #low through this method, so this event hook provides the single
 #oint at which ORM queries of all types may be intercepted before
 #hey are invoked, and additionally to replace their execution with
 # different process.

 #his event is a ``do_`` event, meaning it has the capability to replace
 #he operation that the :meth:`_orm.Session.execute` method normally
 #erforms.  The intended use for this includes sharding and
 #esult-caching schemes which may seek to invoke the same statement
 #cross  multiple database connections, returning a result that is
 #erged from each of them, or which don't invoke the statement at all,
 #nstead returning data from a cache.

 #he hook intends to replace the use of the
 #`Query._execute_and_instances`` method that could be subclassed prior
 #o SQLAlchemy 1.4.

 #param orm_execute_state: an instance of :class:`.ORMExecuteState`
 #hich contains all information about the current execution, as well
 #s helper functions used to derive other commonly required
 #nformation.   See that object for details.

 #. seealso::

 #ref:`session_execute_events` - top level documentation on how
 #o use :meth:`_orm.SessionEvents.do_orm_execute`

 #class:`.ORMExecuteState` - the object passed to the
 #meth:`_orm.SessionEvents.do_orm_execute` event which contains
 #ll information about the statement to be invoked.  It also
 #rovides an interface to extend the current statement, options,
 #nd parameters as well as an option that allows programmatic
 #nvocation of the statement at any point.

 #ref:`examples_session_orm_events` - includes examples of using
 #meth:`_orm.SessionEvents.do_orm_execute`

 #ref:`examples_caching` - an example of how to integrate
 #ogpile caching with the ORM :class:`_orm.Session` making use
 #f the :meth:`_orm.SessionEvents.do_orm_execute` event hook.

 #ref:`examples_sharding` - the Horizontal Sharding example /
 #xtension relies upon the
 #meth:`_orm.SessionEvents.do_orm_execute` event hook to invoke a
 #QL statement on multiple backends and return a merged result.


 #. versionadded:: 1.4

 #""

 #ef after_transaction_create(self, session, transaction):
 #""Execute when a new :class:`.SessionTransaction` is created.

 #his event differs from :meth:`~.SessionEvents.after_begin`
 #n that it occurs for each :class:`.SessionTransaction`
 #verall, as opposed to when transactions are begun
 #n individual database connections.  It is also invoked
 #or nested transactions and subtransactions, and is always
 #atched by a corresponding
 #meth:`~.SessionEvents.after_transaction_end` event
 #assuming normal operation of the :class:`.Session`).

 #param session: the target :class:`.Session`.
 #param transaction: the target :class:`.SessionTransaction`.

 #o detect if this is the outermost
 #class:`.SessionTransaction`, as opposed to a "subtransaction" or a
 #AVEPOINT, test that the :attr:`.SessionTransaction.parent` attribute
 #s ``None``::

 #event.listens_for(session, "after_transaction_create")
 #ef after_transaction_create(session, transaction):
 #f transaction.parent is None:
                        # work with top-level transaction

 #o detect if the :class:`.SessionTransaction` is a SAVEPOINT, use the
 #attr:`.SessionTransaction.nested` attribute::

 #event.listens_for(session, "after_transaction_create")
 #ef after_transaction_create(session, transaction):
 #f transaction.nested:
                        # work with SAVEPOINT transaction


 #. seealso::

 #class:`.SessionTransaction`

 #meth:`~.SessionEvents.after_transaction_end`

 #""

 #ef after_transaction_end(self, session, transaction):
 #""Execute when the span of a :class:`.SessionTransaction` ends.

 #his event differs from :meth:`~.SessionEvents.after_commit`
 #n that it corresponds to all :class:`.SessionTransaction`
 #bjects in use, including those for nested transactions
 #nd subtransactions, and is always matched by a corresponding
 #meth:`~.SessionEvents.after_transaction_create` event.

 #param session: the target :class:`.Session`.
 #param transaction: the target :class:`.SessionTransaction`.

 #o detect if this is the outermost
 #class:`.SessionTransaction`, as opposed to a "subtransaction" or a
 #AVEPOINT, test that the :attr:`.SessionTransaction.parent` attribute
 #s ``None``::

 #event.listens_for(session, "after_transaction_create")
 #ef after_transaction_end(session, transaction):
 #f transaction.parent is None:
                        # work with top-level transaction

 #o detect if the :class:`.SessionTransaction` is a SAVEPOINT, use the
 #attr:`.SessionTransaction.nested` attribute::

 #event.listens_for(session, "after_transaction_create")
 #ef after_transaction_end(session, transaction):
 #f transaction.nested:
                        # work with SAVEPOINT transaction


 #. seealso::

 #class:`.SessionTransaction`

 #meth:`~.SessionEvents.after_transaction_create`

 #""

 #ef before_commit(self, session):
 #""Execute before commit is called.

 #. note::

 #he :meth:`~.SessionEvents.before_commit` hook is *not* per-flush,
 #hat is, the :class:`.Session` can emit SQL to the database
 #any times within the scope of a transaction.
 #or interception of these events, use the
 #meth:`~.SessionEvents.before_flush`,
 #meth:`~.SessionEvents.after_flush`, or
 #meth:`~.SessionEvents.after_flush_postexec`
 #vents.

 #param session: The target :class:`.Session`.

 #. seealso::

 #meth:`~.SessionEvents.after_commit`

 #meth:`~.SessionEvents.after_begin`

 #meth:`~.SessionEvents.after_transaction_create`

 #meth:`~.SessionEvents.after_transaction_end`

 #""

 #ef after_commit(self, session):
 #""Execute after a commit has occurred.

 #. note::

 #he :meth:`~.SessionEvents.after_commit` hook is *not* per-flush,
 #hat is, the :class:`.Session` can emit SQL to the database
 #any times within the scope of a transaction.
 #or interception of these events, use the
 #meth:`~.SessionEvents.before_flush`,
 #meth:`~.SessionEvents.after_flush`, or
 #meth:`~.SessionEvents.after_flush_postexec`
 #vents.

 #. note::

 #he :class:`.Session` is not in an active transaction
 #hen the :meth:`~.SessionEvents.after_commit` event is invoked,
 #nd therefore can not emit SQL.  To emit SQL corresponding to
 #very transaction, use the :meth:`~.SessionEvents.before_commit`
 #vent.

 #param session: The target :class:`.Session`.

 #. seealso::

 #meth:`~.SessionEvents.before_commit`

 #meth:`~.SessionEvents.after_begin`

 #meth:`~.SessionEvents.after_transaction_create`

 #meth:`~.SessionEvents.after_transaction_end`

 #""

 #ef after_rollback(self, session):
 #""Execute after a real DBAPI rollback has occurred.

 #ote that this event only fires when the *actual* rollback against
 #he database occurs - it does *not* fire each time the
 #meth:`.Session.rollback` method is called, if the underlying
 #BAPI transaction has already been rolled back.  In many
 #ases, the :class:`.Session` will not be in
 #n "active" state during this event, as the current
 #ransaction is not valid.   To acquire a :class:`.Session`
 #hich is active after the outermost rollback has proceeded,
 #se the :meth:`.SessionEvents.after_soft_rollback` event, checking the
 #attr:`.Session.is_active` flag.

 #param session: The target :class:`.Session`.

 #""

 #ef after_soft_rollback(self, session, previous_transaction):
 #""Execute after any rollback has occurred, including "soft"
 #ollbacks that don't actually emit at the DBAPI level.

 #his corresponds to both nested and outer rollbacks, i.e.
 #he innermost rollback that calls the DBAPI's
 #ollback() method, as well as the enclosing rollback
 #alls that only pop themselves from the transaction stack.

 #he given :class:`.Session` can be used to invoke SQL and
 #meth:`.Session.query` operations after an outermost rollback
 #y first checking the :attr:`.Session.is_active` flag::

 #event.listens_for(Session, "after_soft_rollback")
 #ef do_something(session, previous_transaction):
 #f session.is_active:
 #ession.execute("select * from some_table")

 #param session: The target :class:`.Session`.
 #param previous_transaction: The :class:`.SessionTransaction`
 #ransactional marker object which was just closed.   The current
 #class:`.SessionTransaction` for the given :class:`.Session` is
 #vailable via the :attr:`.Session.transaction` attribute.

 #""

 #ef before_flush(self, session, flush_context, instances):
 #""Execute before flush process has started.

 #param session: The target :class:`.Session`.
 #param flush_context: Internal :class:`.UOWTransaction` object
 #hich handles the details of the flush.
 #param instances: Usually ``None``, this is the collection of
 #bjects which can be passed to the :meth:`.Session.flush` method
 #note this usage is deprecated).

 #. seealso::

 #meth:`~.SessionEvents.after_flush`

 #meth:`~.SessionEvents.after_flush_postexec`

 #ref:`session_persistence_events`

 #""

 #ef after_flush(self, session, flush_context):
 #""Execute after flush has completed, but before commit has been
 #alled.

 #ote that the session's state is still in pre-flush, i.e. 'new',
 #dirty', and 'deleted' lists still show pre-flush state as well
 #s the history settings on instance attributes.

 #. warning:: This event runs after the :class:`.Session` has emitted
 #QL to modify the database, but **before** it has altered its
 #nternal state to reflect those changes, including that newly
 #nserted objects are placed into the identity map.  ORM operations
 #mitted within this event such as loads of related items
 #ay produce new identity map entries that will immediately
 #e replaced, sometimes causing confusing results.  SQLAlchemy will
 #mit a warning for this condition as of version 1.3.9.

 #param session: The target :class:`.Session`.
 #param flush_context: Internal :class:`.UOWTransaction` object
 #hich handles the details of the flush.

 #. seealso::

 #meth:`~.SessionEvents.before_flush`

 #meth:`~.SessionEvents.after_flush_postexec`

 #ref:`session_persistence_events`

 #""

 #ef after_flush_postexec(self, session, flush_context):
 #""Execute after flush has completed, and after the post-exec
 #tate occurs.

 #his will be when the 'new', 'dirty', and 'deleted' lists are in
 #heir final state.  An actual commit() may or may not have
 #ccurred, depending on whether or not the flush started its own
 #ransaction or participated in a larger transaction.

 #param session: The target :class:`.Session`.
 #param flush_context: Internal :class:`.UOWTransaction` object
 #hich handles the details of the flush.


 #. seealso::

 #meth:`~.SessionEvents.before_flush`

 #meth:`~.SessionEvents.after_flush`

 #ref:`session_persistence_events`

 #""

 #ef after_begin(self, session, transaction, connection):
 #""Execute after a transaction is begun on a connection

 #param session: The target :class:`.Session`.
 #param transaction: The :class:`.SessionTransaction`.
 #param connection: The :class:`_engine.Connection` object
 #hich will be used for SQL statements.

 #. seealso::

 #meth:`~.SessionEvents.before_commit`

 #meth:`~.SessionEvents.after_commit`

 #meth:`~.SessionEvents.after_transaction_create`

 #meth:`~.SessionEvents.after_transaction_end`

 #""

 #_lifecycle_event
 #ef before_attach(self, session, instance):
 #""Execute before an instance is attached to a session.

 #his is called before an add, delete or merge causes
 #he object to be part of the session.

 #. seealso::

 #meth:`~.SessionEvents.after_attach`

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef after_attach(self, session, instance):
 #""Execute after an instance is attached to a session.

 #his is called after an add, delete or merge.

 #. note::

 #s of 0.8, this event fires off *after* the item
 #as been fully associated with the session, which is
 #ifferent than previous releases.  For event
 #andlers that require the object not yet
 #e part of session state (such as handlers which
 #ay autoflush while the target object is not
 #et complete) consider the
 #ew :meth:`.before_attach` event.

 #. seealso::

 #meth:`~.SessionEvents.before_attach`

 #ref:`session_lifecycle_events`

 #""

 #event._legacy_signature(
 #0.9",
 #"session", "query", "query_context", "result"],
 #ambda update_context: (
 #pdate_context.session,
 #pdate_context.query,
 #one,
 #pdate_context.result,
 #,
 #
 #ef after_bulk_update(self, update_context):
 #""Execute after an ORM UPDATE against a WHERE expression has been
 #nvoked.

 #his is called as a result of the :meth:`_query.Query.update` method.

 #param update_context: an "update context" object which contains
 #etails about the update, including these attributes:

 # ``session`` - the :class:`.Session` involved
 # ``query`` -the :class:`_query.Query`
 #bject that this update operation
 #as called upon.
 # ``values`` The "values" dictionary that was passed to
 #meth:`_query.Query.update`.
 # ``result`` the :class:`_engine.CursorResult`
 #eturned as a result of the
 #ulk UPDATE operation.

 #. versionchanged:: 1.4 the update_context no longer has a
 #`QueryContext`` object associated with it.

 #. seealso::

 #meth:`.QueryEvents.before_compile_update`

 #meth:`.SessionEvents.after_bulk_delete`

 #""

 #event._legacy_signature(
 #0.9",
 #"session", "query", "query_context", "result"],
 #ambda delete_context: (
 #elete_context.session,
 #elete_context.query,
 #one,
 #elete_context.result,
 #,
 #
 #ef after_bulk_delete(self, delete_context):
 #""Execute after ORM DELETE against a WHERE expression has been
 #nvoked.

 #his is called as a result of the :meth:`_query.Query.delete` method.

 #param delete_context: a "delete context" object which contains
 #etails about the update, including these attributes:

 # ``session`` - the :class:`.Session` involved
 # ``query`` -the :class:`_query.Query`
 #bject that this update operation
 #as called upon.
 # ``result`` the :class:`_engine.CursorResult`
 #eturned as a result of the
 #ulk DELETE operation.

 #. versionchanged:: 1.4 the update_context no longer has a
 #`QueryContext`` object associated with it.

 #. seealso::

 #meth:`.QueryEvents.before_compile_delete`

 #meth:`.SessionEvents.after_bulk_update`

 #""

 #_lifecycle_event
 #ef transient_to_pending(self, session, instance):
 #""Intercept the "transient to pending" transition for a specific object.

 #his event is a specialization of the
 #meth:`.SessionEvents.after_attach` event which is only invoked
 #or this specific transition.  It is invoked typically during the
 #meth:`.Session.add` call.

 #param session: target :class:`.Session`

 #param instance: the ORM-mapped instance being operated upon.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef pending_to_transient(self, session, instance):
 #""Intercept the "pending to transient" transition for a specific object.

 #his less common transition occurs when an pending object that has
 #ot been flushed is evicted from the session; this can occur
 #hen the :meth:`.Session.rollback` method rolls back the transaction,
 #r when the :meth:`.Session.expunge` method is used.

 #param session: target :class:`.Session`

 #param instance: the ORM-mapped instance being operated upon.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef persistent_to_transient(self, session, instance):
 #""Intercept the "persistent to transient" transition for a specific object.

 #his less common transition occurs when an pending object that has
 #as been flushed is evicted from the session; this can occur
 #hen the :meth:`.Session.rollback` method rolls back the transaction.

 #param session: target :class:`.Session`

 #param instance: the ORM-mapped instance being operated upon.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef pending_to_persistent(self, session, instance):
 #""Intercept the "pending to persistent"" transition for a specific object.

 #his event is invoked within the flush process, and is
 #imilar to scanning the :attr:`.Session.new` collection within
 #he :meth:`.SessionEvents.after_flush` event.  However, in this
 #ase the object has already been moved to the persistent state
 #hen the event is called.

 #param session: target :class:`.Session`

 #param instance: the ORM-mapped instance being operated upon.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef detached_to_persistent(self, session, instance):
 #""Intercept the "detached to persistent" transition for a specific object.

 #his event is a specialization of the
 #meth:`.SessionEvents.after_attach` event which is only invoked
 #or this specific transition.  It is invoked typically during the
 #meth:`.Session.add` call, as well as during the
 #meth:`.Session.delete` call if the object was not previously
 #ssociated with the
 #class:`.Session` (note that an object marked as "deleted" remains
 #n the "persistent" state until the flush proceeds).

 #. note::

 #f the object becomes persistent as part of a call to
 #meth:`.Session.delete`, the object is **not** yet marked as
 #eleted when this event is called.  To detect deleted objects,
 #heck the ``deleted`` flag sent to the
 #meth:`.SessionEvents.persistent_to_detached` to event after the
 #lush proceeds, or check the :attr:`.Session.deleted` collection
 #ithin the :meth:`.SessionEvents.before_flush` event if deleted
 #bjects need to be intercepted before the flush.

 #param session: target :class:`.Session`

 #param instance: the ORM-mapped instance being operated upon.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef loaded_as_persistent(self, session, instance):
 #""Intercept the "loaded as persistent" transition for a specific object.

 #his event is invoked within the ORM loading process, and is invoked
 #ery similarly to the :meth:`.InstanceEvents.load` event.  However,
 #he event here is linkable to a :class:`.Session` class or instance,
 #ather than to a mapper or class hierarchy, and integrates
 #ith the other session lifecycle events smoothly.  The object
 #s guaranteed to be present in the session's identity map when
 #his event is called.

 #. note:: This event is invoked within the loader process before
 #ager loaders may have been completed, and the object's state may
 #ot be complete.  Additionally, invoking row-level refresh
 #perations on the object will place the object into a new loader
 #ontext, interfering with the existing load context.   See the note
 #n :meth:`.InstanceEvents.load` for background on making use of the
 #paramref:`.SessionEvents.restore_load_context` parameter, which
 #orks in the same manner as that of
 #paramref:`.InstanceEvents.restore_load_context`, in  order to
 #esolve this scenario.

 #param session: target :class:`.Session`

 #param instance: the ORM-mapped instance being operated upon.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef persistent_to_deleted(self, session, instance):
 #""Intercept the "persistent to deleted" transition for a specific object.

 #his event is invoked when a persistent object's identity
 #s deleted from the database within a flush, however the object
 #till remains associated with the :class:`.Session` until the
 #ransaction completes.

 #f the transaction is rolled back, the object moves again
 #o the persistent state, and the
 #meth:`.SessionEvents.deleted_to_persistent` event is called.
 #f the transaction is committed, the object becomes detached,
 #hich will emit the :meth:`.SessionEvents.deleted_to_detached`
 #vent.

 #ote that while the :meth:`.Session.delete` method is the primary
 #ublic interface to mark an object as deleted, many objects
 #et deleted due to cascade rules, which are not always determined
 #ntil flush time.  Therefore, there's no way to catch
 #very object that will be deleted until the flush has proceeded.
 #he :meth:`.SessionEvents.persistent_to_deleted` event is therefore
 #nvoked at the end of a flush.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef deleted_to_persistent(self, session, instance):
 #""Intercept the "deleted to persistent" transition for a specific object.

 #his transition occurs only when an object that's been deleted
 #uccessfully in a flush is restored due to a call to
 #meth:`.Session.rollback`.   The event is not called under
 #ny other circumstances.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef deleted_to_detached(self, session, instance):
 #""Intercept the "deleted to detached" transition for a specific object.

 #his event is invoked when a deleted object is evicted
 #rom the session.   The typical case when this occurs is when
 #he transaction for a :class:`.Session` in which the object
 #as deleted is committed; the object moves from the deleted
 #tate to the detached state.

 #t is also invoked for objects that were deleted in a flush
 #hen the :meth:`.Session.expunge_all` or :meth:`.Session.close`
 #vents are called, as well as if the object is individually
 #xpunged from its deleted state via :meth:`.Session.expunge`.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""

 #_lifecycle_event
 #ef persistent_to_detached(self, session, instance):
 #""Intercept the "persistent to detached" transition for a specific object.

 #his event is invoked when a persistent object is evicted
 #rom the session.  There are many conditions that cause this
 #o happen, including:

 # using a method such as :meth:`.Session.expunge`
 #r :meth:`.Session.close`

 # Calling the :meth:`.Session.rollback` method, when the object
 #as part of an INSERT statement for that session's transaction


 #param session: target :class:`.Session`

 #param instance: the ORM-mapped instance being operated upon.

 #param deleted: boolean.  If True, indicates this object moved
 #o the detached state because it was marked as deleted and flushed.


 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_lifecycle_events`

 #""


class AttributeEvents(event.Events):
 #"""Define events for object attributes.

 #hese are typically defined on the class-bound descriptor for the
 #arget class.

 #.g.::

 #rom sqlalchemy import event

 #event.listens_for(MyClass.collection, 'append', propagate=True)
 #ef my_append_listener(target, value, initiator):
 #rint("received append event for target: %s" % target)


 #isteners have the option to return a possibly modified version of the
 #alue, when the :paramref:`.AttributeEvents.retval` flag is passed to
 #func:`.event.listen` or :func:`.event.listens_for`::

 #ef validate_phone(target, value, oldvalue, initiator):
 #Strip non-numeric characters from a phone number"

 #eturn re.sub(r'\D', '', value)

        # setup listener on UserContact.phone attribute, instructing
        # it to use the return value
 #isten(UserContact.phone, 'set', validate_phone, retval=True)

 # validation function like the above can also raise an exception
 #uch as :exc:`ValueError` to halt the operation.

 #he :paramref:`.AttributeEvents.propagate` flag is also important when
 #pplying listeners to mapped classes that also have mapped subclasses,
 #s when using mapper inheritance patterns::


 #event.listens_for(MySuperClass.attr, 'set', propagate=True)
 #ef receive_set(target, value, initiator):
 #rint("value set: %s" % target)

 #he full list of modifiers available to the :func:`.event.listen`
 #nd :func:`.event.listens_for` functions are below.

 #param active_history=False: When True, indicates that the
 #set" event would like to receive the "old" value being
 #eplaced unconditionally, even if this requires firing off
 #atabase loads. Note that ``active_history`` can also be
 #et directly via :func:`.column_property` and
 #func:`_orm.relationship`.

 #param propagate=False: When True, the listener function will
 #e established not just for the class attribute given, but
 #or attributes of the same name on all current subclasses
 #f that class, as well as all future subclasses of that
 #lass, using an additional listener that listens for
 #nstrumentation events.
 #param raw=False: When True, the "target" argument to the
 #vent will be the :class:`.InstanceState` management
 #bject, rather than the mapped instance itself.
 #param retval=False: when True, the user-defined event
 #istening must return the "value" argument from the
 #unction.  This gives the listening function the opportunity
 #o change the value that is ultimately used for a "set"
 #r "append" event.

 #""

 #target_class_doc = "SomeClass.some_attribute"
 #dispatch_target = QueryableAttribute

 #staticmethod
 #ef _set_dispatch(cls, dispatch_cls):
 #ispatch = event.Events._set_dispatch(cls, dispatch_cls)
 #ispatch_cls._active_history = False
 #eturn dispatch

 #classmethod
 #ef _accept_with(cls, target):
        # TODO: coverage
 #f isinstance(target, interfaces.MapperProperty):
 #eturn getattr(target.parent.class_, target.key)
 #lse:
 #eturn target

 #classmethod
 #ef _listen(
 #ls,
 #vent_key,
 #ctive_history=False,
 #aw=False,
 #etval=False,
 #ropagate=False,
 #:

 #arget, fn = event_key.dispatch_target, event_key._listen_fn

 #f active_history:
 #arget.dispatch._active_history = True

 #f not raw or not retval:

 #ef wrap(target, *arg):
 #f not raw:
 #arget = target.obj()
 #f not retval:
 #f arg:
 #alue = arg[0]
 #lse:
 #alue = None
 #n(target, *arg)
 #eturn value
 #lse:
 #eturn fn(target, *arg)

 #vent_key = event_key.with_wrapper(wrap)

 #vent_key.base_listen(propagate=propagate)

 #f propagate:
 #anager = instrumentation.manager_of_class(target.class_)

 #or mgr in manager.subclass_managers(True):
 #vent_key.with_dispatch_target(mgr[target.key]).base_listen(
 #ropagate=True
 #
 #f active_history:
 #gr[target.key].dispatch._active_history = True

 #ef append(self, target, value, initiator):
 #""Receive a collection append event.

 #he append event is invoked for each element as it is appended
 #o the collection.  This occurs for single-item appends as well
 #s for a "bulk replace" operation.

 #param target: the object instance receiving the event.
 #f the listener is registered with ``raw=True``, this will
 #e the :class:`.InstanceState` object.
 #param value: the value being appended.  If this listener
 #s registered with ``retval=True``, the listener
 #unction must return this value, or a new value which
 #eplaces it.
 #param initiator: An instance of :class:`.attributes.Event`
 #epresenting the initiation of the event.  May be modified
 #rom its original value by backref handlers in order to control
 #hained event propagation, as well as be inspected for information
 #bout the source of the event.
 #return: if the event was registered with ``retval=True``,
 #he given value, or a new effective value, should be returned.

 #. seealso::

 #class:`.AttributeEvents` - background on listener options such
 #s propagation to subclasses.

 #meth:`.AttributeEvents.bulk_replace`

 #""

 #ef append_wo_mutation(self, target, value, initiator):
 #""Receive a collection append event where the collection was not
 #ctually mutated.

 #his event differs from :meth:`_orm.AttributeEvents.append` in that
 #t is fired off for de-duplicating collections such as sets and
 #ictionaries, when the object already exists in the target collection.
 #he event does not have a return value and the identity of the
 #iven object cannot be changed.

 #he event is used for cascading objects into a :class:`_orm.Session`
 #hen the collection has already been mutated via a backref event.

 #param target: the object instance receiving the event.
 #f the listener is registered with ``raw=True``, this will
 #e the :class:`.InstanceState` object.
 #param value: the value that would be appended if the object did not
 #lready exist in the collection.
 #param initiator: An instance of :class:`.attributes.Event`
 #epresenting the initiation of the event.  May be modified
 #rom its original value by backref handlers in order to control
 #hained event propagation, as well as be inspected for information
 #bout the source of the event.

 #return: No return value is defined for this event.

 #. versionadded:: 1.4.15

 #""

 #ef bulk_replace(self, target, values, initiator):
 #""Receive a collection 'bulk replace' event.

 #his event is invoked for a sequence of values as they are incoming
 #o a bulk collection set operation, which can be
 #odified in place before the values are treated as ORM objects.
 #his is an "early hook" that runs before the bulk replace routine
 #ttempts to reconcile which objects are already present in the
 #ollection and which are being removed by the net replace operation.

 #t is typical that this method be combined with use of the
 #meth:`.AttributeEvents.append` event.    When using both of these
 #vents, note that a bulk replace operation will invoke
 #he :meth:`.AttributeEvents.append` event for all new items,
 #ven after :meth:`.AttributeEvents.bulk_replace` has been invoked
 #or the collection as a whole.  In order to determine if an
 #meth:`.AttributeEvents.append` event is part of a bulk replace,
 #se the symbol :attr:`~.attributes.OP_BULK_REPLACE` to test the
 #ncoming initiator::

 #rom sqlalchemy.orm.attributes import OP_BULK_REPLACE

 #event.listens_for(SomeObject.collection, "bulk_replace")
 #ef process_collection(target, values, initiator):
 #alues[:] = [_make_value(value) for value in values]

 #event.listens_for(SomeObject.collection, "append", retval=True)
 #ef process_collection(target, value, initiator):
                # make sure bulk_replace didn't already do it
 #f initiator is None or initiator.op is not OP_BULK_REPLACE:
 #eturn _make_value(value)
 #lse:
 #eturn value

 #. versionadded:: 1.2

 #param target: the object instance receiving the event.
 #f the listener is registered with ``raw=True``, this will
 #e the :class:`.InstanceState` object.
 #param value: a sequence (e.g. a list) of the values being set.  The
 #andler can modify this list in place.
 #param initiator: An instance of :class:`.attributes.Event`
 #epresenting the initiation of the event.

 #. seealso::

 #class:`.AttributeEvents` - background on listener options such
 #s propagation to subclasses.


 #""

 #ef remove(self, target, value, initiator):
 #""Receive a collection remove event.

 #param target: the object instance receiving the event.
 #f the listener is registered with ``raw=True``, this will
 #e the :class:`.InstanceState` object.
 #param value: the value being removed.
 #param initiator: An instance of :class:`.attributes.Event`
 #epresenting the initiation of the event.  May be modified
 #rom its original value by backref handlers in order to control
 #hained event propagation.

 #. versionchanged:: 0.9.0 the ``initiator`` argument is now
 #assed as a :class:`.attributes.Event` object, and may be
 #odified by backref handlers within a chain of backref-linked
 #vents.

 #return: No return value is defined for this event.


 #. seealso::

 #class:`.AttributeEvents` - background on listener options such
 #s propagation to subclasses.

 #""

 #ef set(self, target, value, oldvalue, initiator):
 #""Receive a scalar set event.

 #param target: the object instance receiving the event.
 #f the listener is registered with ``raw=True``, this will
 #e the :class:`.InstanceState` object.
 #param value: the value being set.  If this listener
 #s registered with ``retval=True``, the listener
 #unction must return this value, or a new value which
 #eplaces it.
 #param oldvalue: the previous value being replaced.  This
 #ay also be the symbol ``NEVER_SET`` or ``NO_VALUE``.
 #f the listener is registered with ``active_history=True``,
 #he previous value of the attribute will be loaded from
 #he database if the existing value is currently unloaded
 #r expired.
 #param initiator: An instance of :class:`.attributes.Event`
 #epresenting the initiation of the event.  May be modified
 #rom its original value by backref handlers in order to control
 #hained event propagation.

 #. versionchanged:: 0.9.0 the ``initiator`` argument is now
 #assed as a :class:`.attributes.Event` object, and may be
 #odified by backref handlers within a chain of backref-linked
 #vents.

 #return: if the event was registered with ``retval=True``,
 #he given value, or a new effective value, should be returned.

 #. seealso::

 #class:`.AttributeEvents` - background on listener options such
 #s propagation to subclasses.

 #""

 #ef init_scalar(self, target, value, dict_):
 #"""Receive a scalar "init" event.

 #his event is invoked when an uninitialized, unpersisted scalar
 #ttribute is accessed, e.g. read::


 # = my_object.some_attribute

 #he ORM's default behavior when this occurs for an un-initialized
 #ttribute is to return the value ``None``; note this differs from
 #ython's usual behavior of raising ``AttributeError``.    The
 #vent here can be used to customize what value is actually returned,
 #ith the assumption that the event listener would be mirroring
 # default generator that is configured on the Core
 #class:`_schema.Column`
 #bject as well.

 #ince a default generator on a :class:`_schema.Column`
 #ight also produce
 # changing value such as a timestamp, the
 #meth:`.AttributeEvents.init_scalar`
 #vent handler can also be used to **set** the newly returned value, so
 #hat a Core-level default generation function effectively fires off
 #nly once, but at the moment the attribute is accessed on the
 #on-persisted object.   Normally, no change to the object's state
 #s made when an uninitialized attribute is accessed (much older
 #QLAlchemy versions did in fact change the object's state).

 #f a default generator on a column returned a particular constant,
 # handler might be used as follows::

 #OME_CONSTANT = 3.1415926

 #lass MyClass(Base):
                # ...

 #ome_attribute = Column(Numeric, default=SOME_CONSTANT)

 #event.listens_for(
 #yClass.some_attribute, "init_scalar",
 #etval=True, propagate=True)
 #ef _init_some_attribute(target, dict_, value):
 #ict_['some_attribute'] = SOME_CONSTANT
 #eturn SOME_CONSTANT

 #bove, we initialize the attribute ``MyClass.some_attribute`` to the
 #alue of ``SOME_CONSTANT``.   The above code includes the following
 #eatures:

 # By setting the value ``SOME_CONSTANT`` in the given ``dict_``,
 #e indicate that this value is to be persisted to the database.
 #his supersedes the use of ``SOME_CONSTANT`` in the default generator
 #or the :class:`_schema.Column`.  The ``active_column_defaults.py``
 #xample given at :ref:`examples_instrumentation` illustrates using
 #he same approach for a changing default, e.g. a timestamp
 #enerator.    In this particular example, it is not strictly
 #ecessary to do this since ``SOME_CONSTANT`` would be part of the
 #NSERT statement in either case.

 # By establishing the ``retval=True`` flag, the value we return
 #rom the function will be returned by the attribute getter.
 #ithout this flag, the event is assumed to be a passive observer
 #nd the return value of our function is ignored.

 # The ``propagate=True`` flag is significant if the mapped class
 #ncludes inheriting subclasses, which would also make use of this
 #vent listener.  Without this flag, an inheriting subclass will
 #ot use our event handler.

 #n the above example, the attribute set event
 #meth:`.AttributeEvents.set` as well as the related validation feature
 #rovided by :obj:`_orm.validates` is **not** invoked when we apply our
 #alue to the given ``dict_``.  To have these events to invoke in
 #esponse to our newly generated value, apply the value to the given
 #bject as a normal attribute set operation::

 #OME_CONSTANT = 3.1415926

 #event.listens_for(
 #yClass.some_attribute, "init_scalar",
 #etval=True, propagate=True)
 #ef _init_some_attribute(target, dict_, value):
                # will also fire off attribute set events
 #arget.some_attribute = SOME_CONSTANT
 #eturn SOME_CONSTANT

 #hen multiple listeners are set up, the generation of the value
 #s "chained" from one listener to the next by passing the value
 #eturned by the previous listener that specifies ``retval=True``
 #s the ``value`` argument of the next listener.

 #. versionadded:: 1.1

 #param target: the object instance receiving the event.
 #f the listener is registered with ``raw=True``, this will
 #e the :class:`.InstanceState` object.
 #param value: the value that is to be returned before this event
 #istener were invoked.  This value begins as the value ``None``,
 #owever will be the return value of the previous event handler
 #unction if multiple listeners are present.
 #param dict\_: the attribute dictionary of this mapped object.
 #his is normally the ``__dict__`` of the object, but in all cases
 #epresents the destination that the attribute system uses to get
 #t the actual value of this attribute.  Placing the value in this
 #ictionary has the effect that the value will be used in the
 #NSERT statement generated by the unit of work.


 #. seealso::

 #meth:`.AttributeEvents.init_collection` - collection version
 #f this event

 #class:`.AttributeEvents` - background on listener options such
 #s propagation to subclasses.

 #ref:`examples_instrumentation` - see the
 #`active_column_defaults.py`` example.

 #""

 #ef init_collection(self, target, collection, collection_adapter):
 #""Receive a 'collection init' event.

 #his event is triggered for a collection-based attribute, when
 #he initial "empty collection" is first generated for a blank
 #ttribute, as well as for when the collection is replaced with
 # new one, such as via a set event.

 #.g., given that ``User.addresses`` is a relationship-based
 #ollection, the event is triggered here::

 #1 = User()
 #1.addresses.append(a1)  #  <- new collection

 #nd also during replace operations::

 #1.addresses = [a2, a3]  #  <- new collection

 #param target: the object instance receiving the event.
 #f the listener is registered with ``raw=True``, this will
 #e the :class:`.InstanceState` object.
 #param collection: the new collection.  This will always be generated
 #rom what was specified as
 #paramref:`_orm.relationship.collection_class`, and will always
 #e empty.
 #param collection_adapter: the :class:`.CollectionAdapter` that will
 #ediate internal access to the collection.

 #. versionadded:: 1.0.0 :meth:`.AttributeEvents.init_collection`
 #nd :meth:`.AttributeEvents.dispose_collection` events.

 #. seealso::

 #class:`.AttributeEvents` - background on listener options such
 #s propagation to subclasses.

 #meth:`.AttributeEvents.init_scalar` - "scalar" version of this
 #vent.

 #""

 #ef dispose_collection(self, target, collection, collection_adapter):
 #""Receive a 'collection dispose' event.

 #his event is triggered for a collection-based attribute when
 # collection is replaced, that is::

 #1.addresses.append(a1)

 #1.addresses = [a2, a3]  # <- old collection is disposed

 #he old collection received will contain its previous contents.

 #. versionchanged:: 1.2 The collection passed to
 #meth:`.AttributeEvents.dispose_collection` will now have its
 #ontents before the dispose intact; previously, the collection
 #ould be empty.

 #. versionadded:: 1.0.0 the :meth:`.AttributeEvents.init_collection`
 #nd :meth:`.AttributeEvents.dispose_collection` events.

 #. seealso::

 #class:`.AttributeEvents` - background on listener options such
 #s propagation to subclasses.

 #""

 #ef modified(self, target, initiator):
 #""Receive a 'modified' event.

 #his event is triggered when the :func:`.attributes.flag_modified`
 #unction is used to trigger a modify event on an attribute without
 #ny specific value being set.

 #. versionadded:: 1.2

 #param target: the object instance receiving the event.
 #f the listener is registered with ``raw=True``, this will
 #e the :class:`.InstanceState` object.

 #param initiator: An instance of :class:`.attributes.Event`
 #epresenting the initiation of the event.

 #. seealso::

 #class:`.AttributeEvents` - background on listener options such
 #s propagation to subclasses.

 #""


class QueryEvents(event.Events):
 #""Represent events within the construction of a :class:`_query.Query`
 #bject.

 #he :class:`_orm.QueryEvents` hooks are now superseded by the
 #meth:`_orm.SessionEvents.do_orm_execute` event hook.

 #""

 #target_class_doc = "SomeQuery"
 #dispatch_target = Query

 #ef before_compile(self, query):
 #""Receive the :class:`_query.Query`
 #bject before it is composed into a
 #ore :class:`_expression.Select` object.

 #. deprecated:: 1.4  The :meth:`_orm.QueryEvents.before_compile` event
 #s superseded by the much more capable
 #meth:`_orm.SessionEvents.do_orm_execute` hook.   In version 1.4,
 #he :meth:`_orm.QueryEvents.before_compile` event is **no longer
 #sed** for ORM-level attribute loads, such as loads of deferred
 #r expired attributes as well as relationship loaders.   See the
 #ew examples in :ref:`examples_session_orm_events` which
 #llustrate new ways of intercepting and modifying ORM queries
 #or the most common purpose of adding arbitrary filter criteria.


 #his event is intended to allow changes to the query given::

 #event.listens_for(Query, "before_compile", retval=True)
 #ef no_deleted(query):
 #or desc in query.column_descriptions:
 #f desc['type'] is User:
 #ntity = desc['entity']
 #uery = query.filter(entity.deleted == False)
 #eturn query

 #he event should normally be listened with the ``retval=True``
 #arameter set, so that the modified query may be returned.

 #he :meth:`.QueryEvents.before_compile` event by default
 #ill disallow "baked" queries from caching a query, if the event
 #ook returns a new :class:`_query.Query` object.
 #his affects both direct
 #se of the baked query extension as well as its operation within
 #azy loaders and eager loaders for relationships.  In order to
 #e-establish the query being cached, apply the event adding the
 #`bake_ok`` flag::

 #event.listens_for(
 #uery, "before_compile", retval=True, bake_ok=True)
 #ef my_event(query):
 #or desc in query.column_descriptions:
 #f desc['type'] is User:
 #ntity = desc['entity']
 #uery = query.filter(entity.deleted == False)
 #eturn query

 #hen ``bake_ok`` is set to True, the event hook will only be invoked
 #nce, and not called for subsequent invocations of a particular query
 #hat is being cached.

 #. versionadded:: 1.3.11  - added the "bake_ok" flag to the
 #meth:`.QueryEvents.before_compile` event and disallowed caching via
 #he "baked" extension from occurring for event handlers that
 #eturn  a new :class:`_query.Query` object if this flag is not set.

 #. seealso::

 #meth:`.QueryEvents.before_compile_update`

 #meth:`.QueryEvents.before_compile_delete`

 #ref:`baked_with_before_compile`

 #""

 #ef before_compile_update(self, query, update_context):
 #""Allow modifications to the :class:`_query.Query` object within
 #meth:`_query.Query.update`.

 #. deprecated:: 1.4  The :meth:`_orm.QueryEvents.before_compile_update`
 #vent is superseded by the much more capable
 #meth:`_orm.SessionEvents.do_orm_execute` hook.

 #ike the :meth:`.QueryEvents.before_compile` event, if the event
 #s to be used to alter the :class:`_query.Query` object, it should
 #e configured with ``retval=True``, and the modified
 #class:`_query.Query` object returned, as in ::

 #event.listens_for(Query, "before_compile_update", retval=True)
 #ef no_deleted(query, update_context):
 #or desc in query.column_descriptions:
 #f desc['type'] is User:
 #ntity = desc['entity']
 #uery = query.filter(entity.deleted == False)

 #pdate_context.values['timestamp'] = datetime.utcnow()
 #eturn query

 #he ``.values`` dictionary of the "update context" object can also
 #e modified in place as illustrated above.

 #param query: a :class:`_query.Query` instance; this is also
 #he ``.query`` attribute of the given "update context"
 #bject.

 #param update_context: an "update context" object which is
 #he same kind of object as described in
 #paramref:`.QueryEvents.after_bulk_update.update_context`.
 #he object has a ``.values`` attribute in an UPDATE context which is
 #he dictionary of parameters passed to :meth:`_query.Query.update`.
 #his
 #ictionary can be modified to alter the VALUES clause of the
 #esulting UPDATE statement.

 #. versionadded:: 1.2.17

 #. seealso::

 #meth:`.QueryEvents.before_compile`

 #meth:`.QueryEvents.before_compile_delete`


 #""

 #ef before_compile_delete(self, query, delete_context):
 #""Allow modifications to the :class:`_query.Query` object within
 #meth:`_query.Query.delete`.

 #. deprecated:: 1.4  The :meth:`_orm.QueryEvents.before_compile_delete`
 #vent is superseded by the much more capable
 #meth:`_orm.SessionEvents.do_orm_execute` hook.

 #ike the :meth:`.QueryEvents.before_compile` event, this event
 #hould be configured with ``retval=True``, and the modified
 #class:`_query.Query` object returned, as in ::

 #event.listens_for(Query, "before_compile_delete", retval=True)
 #ef no_deleted(query, delete_context):
 #or desc in query.column_descriptions:
 #f desc['type'] is User:
 #ntity = desc['entity']
 #uery = query.filter(entity.deleted == False)
 #eturn query

 #param query: a :class:`_query.Query` instance; this is also
 #he ``.query`` attribute of the given "delete context"
 #bject.

 #param delete_context: a "delete context" object which is
 #he same kind of object as described in
 #paramref:`.QueryEvents.after_bulk_delete.delete_context`.

 #. versionadded:: 1.2.17

 #. seealso::

 #meth:`.QueryEvents.before_compile`

 #meth:`.QueryEvents.before_compile_update`


 #""

 #classmethod
 #ef _listen(cls, event_key, retval=False, bake_ok=False, **kw):
 #n = event_key._listen_fn

 #f not retval:

 #ef wrap(*arg, **kw):
 #f not retval:
 #uery = arg[0]
 #n(*arg, **kw)
 #eturn query
 #lse:
 #eturn fn(*arg, **kw)

 #vent_key = event_key.with_wrapper(wrap)
 #lse:
            # don't assume we can apply an attribute to the callable
 #ef wrap(*arg, **kw):
 #eturn fn(*arg, **kw)

 #vent_key = event_key.with_wrapper(wrap)

 #rap._bake_ok = bake_ok

 #vent_key.base_listen(**kw)
