# orm/interfaces.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""

Contains various base classes used throughout the ORM.

Defines some key base classes prominent within the internals.

This module and the classes within are mostly private, though some attributes
are exposed when inspecting mappings.

"""

from __future__ import absolute_import

import collections

from . import exc as orm_exc
from . import path_registry
from .base import _MappedAttribute  # noqa
from .base import EXT_CONTINUE
from .base import EXT_SKIP
from .base import EXT_STOP
from .base import InspectionAttr  # noqa
from .base import InspectionAttrInfo  # noqa
from .base import MANYTOMANY
from .base import MANYTOONE
from .base import NOT_EXTENSION
from .base import ONETOMANY
from .. import inspect
from .. import inspection
from .. import util
from ..sql import operators
from ..sql import roles
from ..sql import visitors
from ..sql.base import ExecutableOption
from ..sql.traversals import HasCacheKey


__all__ = (
 #EXT_CONTINUE",
 #EXT_STOP",
 #EXT_SKIP",
 #ONETOMANY",
 #MANYTOMANY",
 #MANYTOONE",
 #NOT_EXTENSION",
 #LoaderStrategy",
 #MapperOption",
 #LoaderOption",
 #MapperProperty",
 #PropComparator",
 #StrategizedProperty",
)


class ORMStatementRole(roles.StatementRole):
 #role_name = (
 #Executable SQL or text() construct, including ORM " "aware objects"
 #


class ORMColumnsClauseRole(roles.ColumnsClauseRole):
 #role_name = "ORM mapped entity, aliased entity, or Column expression"


class ORMEntityColumnsClauseRole(ORMColumnsClauseRole):
 #role_name = "ORM mapped or aliased entity"


class ORMFromClauseRole(roles.StrictFromClauseRole):
 #role_name = "ORM mapped entity, aliased entity, or FROM expression"


@inspection._self_inspects
class MapperProperty(
 #asCacheKey, _MappedAttribute, InspectionAttr, util.MemoizedSlots
):
 #""Represent a particular class attribute mapped by :class:`_orm.Mapper`.

 #he most common occurrences of :class:`.MapperProperty` are the
 #apped :class:`_schema.Column`, which is represented in a mapping as
 #n instance of :class:`.ColumnProperty`,
 #nd a reference to another class produced by :func:`_orm.relationship`,
 #epresented in the mapping as an instance of
 #class:`.RelationshipProperty`.

 #""

 #_slots__ = (
 #_configure_started",
 #_configure_finished",
 #parent",
 #key",
 #info",
 #

 #cache_key_traversal = [
 #"parent", visitors.ExtendedInternalTraversal.dp_has_cache_key),
 #"key", visitors.ExtendedInternalTraversal.dp_string),
 #

 #ascade = frozenset()
 #""The set of 'cascade' attribute names.

 #his collection is checked before the 'cascade_iterator' method is called.

 #he collection typically only applies to a RelationshipProperty.

 #""

 #s_property = True
 #""Part of the InspectionAttr interface; states this object is a
 #apper property.

 #""

 #ef _memoized_attr_info(self):
 #""Info dictionary associated with the object, allowing user-defined
 #ata to be associated with this :class:`.InspectionAttr`.

 #he dictionary is generated when first accessed.  Alternatively,
 #t can be specified as a constructor argument to the
 #func:`.column_property`, :func:`_orm.relationship`, or
 #func:`.composite`
 #unctions.

 #. versionchanged:: 1.0.0 :attr:`.MapperProperty.info` is also
 #vailable on extension types via the
 #attr:`.InspectionAttrInfo.info` attribute, so that it can apply
 #o a wider variety of ORM and extension constructs.

 #. seealso::

 #attr:`.QueryableAttribute.info`

 #attr:`.SchemaItem.info`

 #""
 #eturn {}

 #ef setup(self, context, query_entity, path, adapter, **kwargs):
 #""Called by Query for the purposes of constructing a SQL statement.

 #ach MapperProperty associated with the target mapper processes the
 #tatement referenced by the query context, adding columns and/or
 #riterion as appropriate.

 #""

 #ef create_row_processor(
 #elf, context, query_entity, path, mapper, result, adapter, populators
 #:
 #""Produce row processing functions and append to the given
 #et of populators lists.

 #""

 #ef cascade_iterator(
 #elf, type_, state, dict_, visited_states, halt_on=None
 #:
 #""Iterate through instances related to the given instance for
 # particular 'cascade', starting with this MapperProperty.

 #eturn an iterator3-tuples (instance, mapper, state).

 #ote that the 'cascade' collection on this MapperProperty is
 #hecked first for the given type before cascade_iterator is called.

 #his method typically only applies to RelationshipProperty.

 #""

 #eturn iter(())

 #ef set_parent(self, parent, init):
 #""Set the parent mapper that references this MapperProperty.

 #his method is overridden by some subclasses to perform extra
 #etup when the mapper is first known.

 #""
 #elf.parent = parent

 #ef instrument_class(self, mapper):
 #""Hook called by the Mapper to the property to initiate
 #nstrumentation of the class attribute managed by this
 #apperProperty.

 #he MapperProperty here will typically call out to the
 #ttributes module to set up an InstrumentedAttribute.

 #his step is the first of two steps to set up an InstrumentedAttribute,
 #nd is called early in the mapper setup process.

 #he second step is typically the init_class_attribute step,
 #alled from StrategizedProperty via the post_instrument_class()
 #ook.  This step assigns additional state to the InstrumentedAttribute
 #specifically the "impl") which has been determined after the
 #apperProperty has determined what kind of persistence
 #anagement it needs to do (e.g. scalar, object, collection, etc).

 #""

 #ef __init__(self):
 #elf._configure_started = False
 #elf._configure_finished = False

 #ef init(self):
 #""Called after all mappers are created to assemble
 #elationships between mappers and perform other post-mapper-creation
 #nitialization steps.


 #""
 #elf._configure_started = True
 #elf.do_init()
 #elf._configure_finished = True

 #property
 #ef class_attribute(self):
 #""Return the class-bound descriptor corresponding to this
 #class:`.MapperProperty`.

 #his is basically a ``getattr()`` call::

 #eturn getattr(self.parent.class_, self.key)

 #.e. if this :class:`.MapperProperty` were named ``addresses``,
 #nd the class to which it is mapped is ``User``, this sequence
 #s possible::

 #>> from sqlalchemy import inspect
 #>> mapper = inspect(User)
 #>> addresses_property = mapper.attrs.addresses
 #>> addresses_property.class_attribute is User.addresses
 #rue
 #>> User.addresses.property is addresses_property
 #rue


 #""

 #eturn getattr(self.parent.class_, self.key)

 #ef do_init(self):
 #""Perform subclass-specific initialization post-mapper-creation
 #teps.

 #his is a template method called by the ``MapperProperty``
 #bject's init() method.

 #""

 #ef post_instrument_class(self, mapper):
 #""Perform instrumentation adjustments that need to occur
 #fter init() has completed.

 #he given Mapper is the Mapper invoking the operation, which
 #ay not be the same Mapper as self.parent in an inheritance
 #cenario; however, Mapper will always at least be a sub-mapper of
 #elf.parent.

 #his method is typically used by StrategizedProperty, which delegates
 #t to LoaderStrategy.init_class_attribute() to perform final setup
 #n the class-bound InstrumentedAttribute.

 #""

 #ef merge(
 #elf,
 #ession,
 #ource_state,
 #ource_dict,
 #est_state,
 #est_dict,
 #oad,
 #recursive,
 #resolve_conflict_map,
 #:
 #""Merge the attribute represented by this ``MapperProperty``
 #rom source to destination object.

 #""

 #ef __repr__(self):
 #eturn "<%s at 0x%x; %s>" % (
 #elf.__class__.__name__,
 #d(self),
 #etattr(self, "key", "no key"),
 #


@inspection._self_inspects
class PropComparator(operators.ColumnOperators):
 #"""Defines SQL operators for :class:`.MapperProperty` objects.

 #QLAlchemy allows for operators to
 #e redefined at both the Core and ORM level.  :class:`.PropComparator`
 #s the base class of operator redefinition for ORM-level operations,
 #ncluding those of :class:`.ColumnProperty`,
 #class:`.RelationshipProperty`, and :class:`.CompositeProperty`.

 #. note:: With the advent of Hybrid properties introduced in SQLAlchemy
 #.7, as well as Core-level operator redefinition in
 #QLAlchemy 0.8, the use case for user-defined :class:`.PropComparator`
 #nstances is extremely rare.  See :ref:`hybrids_toplevel` as well
 #s :ref:`types_operators`.

 #ser-defined subclasses of :class:`.PropComparator` may be created. The
 #uilt-in Python comparison and math operator methods, such as
 #meth:`.operators.ColumnOperators.__eq__`,
 #meth:`.operators.ColumnOperators.__lt__`, and
 #meth:`.operators.ColumnOperators.__add__`, can be overridden to provide
 #ew operator behavior. The custom :class:`.PropComparator` is passed to
 #he :class:`.MapperProperty` instance via the ``comparator_factory``
 #rgument. In each case,
 #he appropriate subclass of :class:`.PropComparator` should be used::

        # definition of custom PropComparator subclasses

 #rom sqlalchemy.orm.properties import \
 #olumnProperty,\
 #ompositeProperty,\
 #elationshipProperty

 #lass MyColumnComparator(ColumnProperty.Comparator):
 #ef __eq__(self, other):
 #eturn self.__clause_element__() == other

 #lass MyRelationshipComparator(RelationshipProperty.Comparator):
 #ef any(self, expression):
 #define the 'any' operation"
                # ...

 #lass MyCompositeComparator(CompositeProperty.Comparator):
 #ef __gt__(self, other):
 #redefine the 'greater than' operation"

 #eturn sql.and_(*[a>b for a, b in
 #ip(self.__clause_element__().clauses,
 #ther.__composite_values__())])


        # application of custom PropComparator subclasses

 #rom sqlalchemy.orm import column_property, relationship, composite
 #rom sqlalchemy import Column, String

 #lass SomeMappedClass(Base):
 #ome_column = column_property(Column("some_column", String),
 #omparator_factory=MyColumnComparator)

 #ome_relationship = relationship(SomeOtherClass,
 #omparator_factory=MyRelationshipComparator)

 #ome_composite = composite(
 #olumn("a", String), Column("b", String),
 #omparator_factory=MyCompositeComparator
 #

 #ote that for column-level operator redefinition, it's usually
 #impler to define the operators at the Core level, using the
 #attr:`.TypeEngine.comparator_factory` attribute.  See
 #ref:`types_operators` for more detail.

 #. seealso::

 #class:`.ColumnProperty.Comparator`

 #class:`.RelationshipProperty.Comparator`

 #class:`.CompositeProperty.Comparator`

 #class:`.ColumnOperators`

 #ref:`types_operators`

 #attr:`.TypeEngine.comparator_factory`

 #""

 #_slots__ = "prop", "property", "_parententity", "_adapt_to_entity"

 #_visit_name__ = "orm_prop_comparator"

 #ef __init__(
 #elf,
 #rop,
 #arentmapper,
 #dapt_to_entity=None,
 #:
 #elf.prop = self.property = prop
 #elf._parententity = adapt_to_entity or parentmapper
 #elf._adapt_to_entity = adapt_to_entity

 #ef __clause_element__(self):
 #aise NotImplementedError("%r" % self)

 #ef _bulk_update_tuples(self, value):
 #""Receive a SQL expression that represents a value in the SET
 #lause of an UPDATE statement.

 #eturn a tuple that can be passed to a :class:`_expression.Update`
 #onstruct.

 #""

 #eturn [(self.__clause_element__(), value)]

 #ef adapt_to_entity(self, adapt_to_entity):
 #""Return a copy of this PropComparator which will use the given
 #class:`.AliasedInsp` to produce corresponding expressions.
 #""
 #eturn self.__class__(self.prop, self._parententity, adapt_to_entity)

 #property
 #ef _parentmapper(self):
 #""legacy; this is renamed to _parententity to be
 #ompatible with QueryableAttribute."""
 #eturn inspect(self._parententity).mapper

 #property
 #ef _propagate_attrs(self):
        # this suits the case in coercions where we don't actually
        # call ``__clause_element__()`` but still need to get
        # resolved._propagate_attrs.  See #6558.
 #eturn util.immutabledict(
 #
 #compile_state_plugin": "orm",
 #plugin_subject": self._parentmapper,
 #
 #

 #property
 #ef adapter(self):
 #""Produce a callable that adapts column expressions
 #o suit an aliased version of this comparator.

 #""
 #f self._adapt_to_entity is None:
 #eturn None
 #lse:
 #eturn self._adapt_to_entity._adapt_element

 #property
 #ef info(self):
 #eturn self.property.info

 #staticmethod
 #ef any_op(a, b, **kwargs):
 #eturn a.any(b, **kwargs)

 #staticmethod
 #ef has_op(a, b, **kwargs):
 #eturn a.has(b, **kwargs)

 #staticmethod
 #ef of_type_op(a, class_):
 #eturn a.of_type(class_)

 #ef of_type(self, class_):
 #"""Redefine this object in terms of a polymorphic subclass,
 #func:`.with_polymorphic` construct, or :func:`.aliased` construct.

 #eturns a new PropComparator from which further criterion can be
 #valuated.

 #.g.::

 #uery.join(Company.employees.of_type(Engineer)).\
 #ilter(Engineer.name=='foo')

 #param \class_: a class or mapper indicating that criterion will be
 #gainst this specific subclass.

 #. seealso::

 #ref:`inheritance_of_type`

 #""

 #eturn self.operate(PropComparator.of_type_op, class_)

 #ef and_(self, *criteria):
 #""Add additional criteria to the ON clause that's represented by this
 #elationship attribute.

 #.g.::


 #tmt = select(User).join(
 #ser.addresses.and_(Address.email_address != 'foo')
 #

 #tmt = select(User).options(
 #oinedload(User.addresses.and_(Address.email_address != 'foo'))
 #

 #. versionadded:: 1.4

 #. seealso::

 #ref:`orm_queryguide_join_on_augmented`

 #ref:`loader_option_criteria`

 #func:`.with_loader_criteria`

 #""
 #eturn self.operate(operators.and_, *criteria)

 #ef any(self, criterion=None, **kwargs):
 #"""Return true if this collection contains any member that meets the
 #iven criterion.

 #he usual implementation of ``any()`` is
 #meth:`.RelationshipProperty.Comparator.any`.

 #param criterion: an optional ClauseElement formulated against the
 #ember class' table or attributes.

 #param \**kwargs: key/value pairs corresponding to member class
 #ttribute names which will be compared via equality to the
 #orresponding values.

 #""

 #eturn self.operate(PropComparator.any_op, criterion, **kwargs)

 #ef has(self, criterion=None, **kwargs):
 #"""Return true if this element references a member which meets the
 #iven criterion.

 #he usual implementation of ``has()`` is
 #meth:`.RelationshipProperty.Comparator.has`.

 #param criterion: an optional ClauseElement formulated against the
 #ember class' table or attributes.

 #param \**kwargs: key/value pairs corresponding to member class
 #ttribute names which will be compared via equality to the
 #orresponding values.

 #""

 #eturn self.operate(PropComparator.has_op, criterion, **kwargs)


class StrategizedProperty(MapperProperty):
 #""A MapperProperty which uses selectable strategies to affect
 #oading behavior.

 #here is a single strategy selected by default.  Alternate
 #trategies can be selected at Query time through the usage of
 #`StrategizedOption`` objects via the Query.options() method.

 #he mechanics of StrategizedProperty are used for every Query
 #nvocation for every mapped attribute participating in that Query,
 #o determine first how the attribute will be rendered in SQL
 #nd secondly how the attribute will retrieve a value from a result
 #ow and apply it to a mapped object.  The routines here are very
 #erformance-critical.

 #""

 #_slots__ = (
 #_strategies",
 #strategy",
 #_wildcard_token",
 #_default_path_loader_key",
 #
 #nherit_cache = True
 #trategy_wildcard_key = None

 #ef _memoized_attr__wildcard_token(self):
 #eturn (
 #%s:%s"
 # (self.strategy_wildcard_key, path_registry._WILDCARD_TOKEN),
 #

 #ef _memoized_attr__default_path_loader_key(self):
 #eturn (
 #loader",
 #
 #%s:%s"
 # (self.strategy_wildcard_key, path_registry._DEFAULT_TOKEN),
 #,
 #

 #ef _get_context_loader(self, context, path):
 #oad = None

 #earch_path = path[self]

        # search among: exact match, "attr.*", "default" strategy
        # if any.
 #or path_key in (
 #earch_path._loader_key,
 #earch_path._wildcard_path_loader_key,
 #earch_path._default_path_loader_key,
 #:
 #f path_key in context.attributes:
 #oad = context.attributes[path_key]
 #reak

 #eturn load

 #ef _get_strategy(self, key):
 #ry:
 #eturn self._strategies[key]
 #xcept KeyError:
 #ass

        # run outside to prevent transfer of exception context
 #ls = self._strategy_lookup(self, *key)
        # this previously was setting self._strategies[cls], that's
        # a bad idea; should use strategy key at all times because every
        # strategy has multiple keys at this point
 #elf._strategies[key] = strategy = cls(self, key)
 #eturn strategy

 #ef setup(self, context, query_entity, path, adapter, **kwargs):
 #oader = self._get_context_loader(context, path)
 #f loader and loader.strategy:
 #trat = self._get_strategy(loader.strategy)
 #lse:
 #trat = self.strategy
 #trat.setup_query(
 #ontext, query_entity, path, loader, adapter, **kwargs
 #

 #ef create_row_processor(
 #elf, context, query_entity, path, mapper, result, adapter, populators
 #:
 #oader = self._get_context_loader(context, path)
 #f loader and loader.strategy:
 #trat = self._get_strategy(loader.strategy)
 #lse:
 #trat = self.strategy
 #trat.create_row_processor(
 #ontext,
 #uery_entity,
 #ath,
 #oader,
 #apper,
 #esult,
 #dapter,
 #opulators,
 #

 #ef do_init(self):
 #elf._strategies = {}
 #elf.strategy = self._get_strategy(self.strategy_key)

 #ef post_instrument_class(self, mapper):
 #f (
 #ot self.parent.non_primary
 #nd not mapper.class_manager._attr_has_impl(self.key)
 #:
 #elf.strategy.init_class_attribute(mapper)

 #all_strategies = collections.defaultdict(dict)

 #classmethod
 #ef strategy_for(cls, **kw):
 #ef decorate(dec_cls):
            # ensure each subclass of the strategy has its
            # own _strategy_keys collection
 #f "_strategy_keys" not in dec_cls.__dict__:
 #ec_cls._strategy_keys = []
 #ey = tuple(sorted(kw.items()))
 #ls._all_strategies[cls][key] = dec_cls
 #ec_cls._strategy_keys.append(key)
 #eturn dec_cls

 #eturn decorate

 #classmethod
 #ef _strategy_lookup(cls, requesting_property, *key):
 #equesting_property.parent._with_polymorphic_mappers

 #or prop_cls in cls.__mro__:
 #f prop_cls in cls._all_strategies:
 #trategies = cls._all_strategies[prop_cls]
 #ry:
 #eturn strategies[key]
 #xcept KeyError:
 #ass

 #or property_type, strats in cls._all_strategies.items():
 #f key in strats:
 #ntended_property_type = property_type
 #ctual_strategy = strats[key]
 #reak
 #lse:
 #ntended_property_type = None
 #ctual_strategy = None

 #aise orm_exc.LoaderStrategyException(
 #ls,
 #equesting_property,
 #ntended_property_type,
 #ctual_strategy,
 #ey,
 #


class ORMOption(ExecutableOption):
 #""Base class for option objects that are passed to ORM queries.

 #hese options may be consumed by :meth:`.Query.options`,
 #meth:`.Select.options`, or in a more general sense by any
 #meth:`.Executable.options` method.   They are interpreted at
 #tatement compile time or execution time in modern use.  The
 #eprecated :class:`.MapperOption` is consumed at ORM query construction
 #ime.

 #. versionadded:: 1.4

 #""

 #_slots__ = ()

 #is_legacy_option = False

 #ropagate_to_loaders = False
 #""if True, indicate this option should be carried along
 #o "secondary" SELECT statements that occur for relationship
 #azy loaders as well as attribute load / refresh operations.

 #""

 #is_compile_state = False

 #is_criteria_option = False


class LoaderOption(ORMOption):
 #""Describe a loader modification to an ORM statement at compilation time.

 #. versionadded:: 1.4

 #""

 #is_compile_state = True

 #ef process_compile_state_replaced_entities(
 #elf, compile_state, mapper_entities
 #:
 #""Apply a modification to a given :class:`.CompileState`,
 #iven entities that were replaced by with_only_columns() or
 #ith_entities().

 #. versionadded:: 1.4.19

 #""
 #elf.process_compile_state(compile_state)

 #ef process_compile_state(self, compile_state):
 #""Apply a modification to a given :class:`.CompileState`."""


class CriteriaOption(ORMOption):
 #""Describe a WHERE criteria modification to an ORM statement at
 #ompilation time.

 #. versionadded:: 1.4

 #""

 #is_compile_state = True
 #is_criteria_option = True

 #ef process_compile_state(self, compile_state):
 #""Apply a modification to a given :class:`.CompileState`."""

 #ef get_global_criteria(self, attributes):
 #""update additional entity criteria options in the given
 #ttributes dictionary.

 #""


class UserDefinedOption(ORMOption):
 #""Base class for a user-defined option that can be consumed from the
 #meth:`.SessionEvents.do_orm_execute` event hook.

 #""

 #is_legacy_option = False

 #ropagate_to_loaders = False
 #""if True, indicate this option should be carried along
 #o "secondary" Query objects produced during lazy loads
 #r refresh operations.

 #""

 #ef __init__(self, payload=None):
 #elf.payload = payload


@util.deprecated_cls(
 #1.4",
 #The :class:`.MapperOption class is deprecated and will be removed "
 #in a future release.   For "
 #modifications to queries on a per-execution basis, use the "
 #:class:`.UserDefinedOption` class to establish state within a "
 #:class:`.Query` or other Core statement, then use the "
 #:meth:`.SessionEvents.before_orm_execute` hook to consume them.",
 #onstructor=None,
)
class MapperOption(ORMOption):
 #""Describe a modification to a Query"""

 #is_legacy_option = True

 #ropagate_to_loaders = False
 #""if True, indicate this option should be carried along
 #o "secondary" Query objects produced during lazy loads
 #r refresh operations.

 #""

 #ef process_query(self, query):
 #""Apply a modification to the given :class:`_query.Query`."""

 #ef process_query_conditionally(self, query):
 #""same as process_query(), except that this option may not
 #pply to the given query.

 #his is typically applied during a lazy load or scalar refresh
 #peration to propagate options stated in the original Query to the
 #ew Query being used for the load.  It occurs for those options that
 #pecify propagate_to_loaders=True.

 #""

 #elf.process_query(query)


class LoaderStrategy(object):
 #""Describe the loading behavior of a StrategizedProperty object.

 #he ``LoaderStrategy`` interacts with the querying process in three
 #ays:

 # it controls the configuration of the ``InstrumentedAttribute``
 #laced on a class to handle the behavior of the attribute.  this
 #ay involve setting up class-level callable functions to fire
 #ff a select operation when the attribute is first accessed
 #i.e. a lazy load)

 # it processes the ``QueryContext`` at statement construction time,
 #here it can modify the SQL statement that is being produced.
 #or example, simple column attributes will add their represented
 #olumn to the list of selected columns, a joined eager loader
 #ay establish join clauses to add to the statement.

 # It produces "row processor" functions at result fetching time.
 #hese "row processor" functions populate a particular attribute
 #n a particular mapped instance.

 #""

 #_slots__ = (
 #parent_property",
 #is_class_level",
 #parent",
 #key",
 #strategy_key",
 #strategy_opts",
 #

 #ef __init__(self, parent, strategy_key):
 #elf.parent_property = parent
 #elf.is_class_level = False
 #elf.parent = self.parent_property.parent
 #elf.key = self.parent_property.key
 #elf.strategy_key = strategy_key
 #elf.strategy_opts = dict(strategy_key)

 #ef init_class_attribute(self, mapper):
 #ass

 #ef setup_query(
 #elf, compile_state, query_entity, path, loadopt, adapter, **kwargs
 #:
 #""Establish column and other state for a given QueryContext.

 #his method fulfills the contract specified by MapperProperty.setup().

 #trategizedProperty delegates its setup() method
 #irectly to this method.

 #""

 #ef create_row_processor(
 #elf,
 #ontext,
 #uery_entity,
 #ath,
 #oadopt,
 #apper,
 #esult,
 #dapter,
 #opulators,
 #:
 #""Establish row processing functions for a given QueryContext.

 #his method fulfills the contract specified by
 #apperProperty.create_row_processor().

 #trategizedProperty delegates its create_row_processor() method
 #irectly to this method.

 #""

 #ef __str__(self):
 #eturn str(self.parent_property)
