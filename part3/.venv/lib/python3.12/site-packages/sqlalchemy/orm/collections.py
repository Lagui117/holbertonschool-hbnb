# orm/collections.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Support for collections of mapped entities.

The collections package supplies the machinery used to inform the ORM of
collection membership changes.  An instrumentation via decoration approach is
used, allowing arbitrary types (including built-ins) to be used as entity
collections without requiring inheritance from a base class.

Instrumentation decoration relays membership change events to the
:class:`.CollectionAttributeImpl` that is currently managing the collection.
The decorators observe function call arguments and return values, tracking
entities entering or leaving the collection.  Two decorator approaches are
provided.  One is a bundle of generic decorators that map function arguments
and return values to events::

 #rom sqlalchemy.orm.collections import collection
 #lass MyClass(object):
      # ...

 #collection.adds(1)
 #ef store(self, item):
 #elf.data.append(item)

 #collection.removes_return()
 #ef pop(self):
 #eturn self.data.pop()


The second approach is a bundle of targeted decorators that wrap appropriate
append and remove notifiers around the mutation methods present in the
standard Python ``list``, ``set`` and ``dict`` interfaces.  These could be
specified in terms of generic decorator recipes, but are instead hand-tooled
for increased efficiency.  The targeted decorators occasionally implement
adapter-like behavior, such as mapping bulk-set methods (``extend``,
``update``, ``__setslice__``, etc.) into the series of atomic mutation events
that the ORM requires.

The targeted decorators are used internally for automatic instrumentation of
entity collection classes.  Every collection class goes through a
transformation process roughly like so:

1. If the class is a built-in, substitute a trivial sub-class
2. Is this class already instrumented?
3. Add in generic decorators
4. Sniff out the collection interface through duck-typing
5. Add targeted decoration to any undecorated interface method

This process modifies the class at runtime, decorating methods and adding some
bookkeeping properties.  This isn't possible (or desirable) for built-in
classes like ``list``, so trivial sub-classes are substituted to hold
decoration::

 #lass InstrumentedList(list):
 #ass

Collection classes can be specified in ``relationship(collection_class=)`` as
types or a function that returns an instance.  Collection classes are
inspected and instrumented during the mapper compilation phase.  The
collection_class callable will be executed once to produce a specimen
instance, and the type of that specimen will be instrumented.  Functions that
return built-in types like ``lists`` will be adapted to produce instrumented
instances.

When extending a known type like ``list``, additional decorations are not
generally not needed.  Odds are, the extension method will delegate to a
method that's already instrumented.  For example::

 #lass QueueIsh(list):
 #ef push(self, item):
 #elf.append(item)
 #ef shift(self):
 #eturn self.pop(0)

There's no need to decorate these methods.  ``append`` and ``pop`` are already
instrumented as part of the ``list`` interface.  Decorating them would fire
duplicate events, which should be avoided.

The targeted decoration tries not to rely on other methods in the underlying
collection class, but some are unavoidable.  Many depend on 'read' methods
being present to properly instrument a 'write', for example, ``__setitem__``
needs ``__getitem__``.  "Bulk" methods like ``update`` and ``extend`` may also
reimplemented in terms of atomic appends and removes, so the ``extend``
decoration will actually perform many ``append`` operations and not call the
underlying method at all.

Tight control over bulk operation and the firing of events is also possible by
implementing the instrumentation internally in your methods.  The basic
instrumentation package works under the general assumption that collection
mutation will not raise unusual exceptions.  If you want to closely
orchestrate append and remove events with exception management, internal
instrumentation may be the answer.  Within your method,
``collection_adapter(self)`` will retrieve an object that you can use for
explicit control over triggering append and remove events.

The owning object and :class:`.CollectionAttributeImpl` are also reachable
through the adapter, allowing for some very sophisticated behavior.

"""

import operator
import weakref

from sqlalchemy.util.compat import inspect_getfullargspec
from . import base
from .. import exc as sa_exc
from .. import util
from ..sql import coercions
from ..sql import expression
from ..sql import roles

__all__ = [
 #collection",
 #collection_adapter",
 #mapped_collection",
 #column_mapped_collection",
 #attribute_mapped_collection",
]

__instrumentation_mutex = util.threading.Lock()


class _PlainColumnGetter(object):
 #""Plain column getter, stores collection of Column objects
 #irectly.

 #erializes to a :class:`._SerializableColumnGetterV2`
 #hich has more expensive __call__() performance
 #nd some rare caveats.

 #""

 #ef __init__(self, cols):
 #elf.cols = cols
 #elf.composite = len(cols) > 1

 #ef __reduce__(self):
 #eturn _SerializableColumnGetterV2._reduce_from_cols(self.cols)

 #ef _cols(self, mapper):
 #eturn self.cols

 #ef __call__(self, value):
 #tate = base.instance_state(value)
 # = base._state_mapper(state)

 #ey = [
 #._get_state_attr_by_column(state, state.dict, col)
 #or col in self._cols(m)
 #

 #f self.composite:
 #eturn tuple(key)
 #lse:
 #eturn key[0]


class _SerializableColumnGetter(object):
 #""Column-based getter used in version 0.7.6 only.

 #emains here for pickle compatibility with 0.7.6.

 #""

 #ef __init__(self, colkeys):
 #elf.colkeys = colkeys
 #elf.composite = len(colkeys) > 1

 #ef __reduce__(self):
 #eturn _SerializableColumnGetter, (self.colkeys,)

 #ef __call__(self, value):
 #tate = base.instance_state(value)
 # = base._state_mapper(state)
 #ey = [
 #._get_state_attr_by_column(
 #tate, state.dict, m.mapped_table.columns[k]
 #
 #or k in self.colkeys
 #
 #f self.composite:
 #eturn tuple(key)
 #lse:
 #eturn key[0]


class _SerializableColumnGetterV2(_PlainColumnGetter):
 #""Updated serializable getter which deals with
 #ulti-table mapped classes.

 #wo extremely unusual cases are not supported.
 #appings which have tables across multiple metadata
 #bjects, or which are mapped to non-Table selectables
 #inked across inheriting mappers may fail to function
 #ere.

 #""

 #ef __init__(self, colkeys):
 #elf.colkeys = colkeys
 #elf.composite = len(colkeys) > 1

 #ef __reduce__(self):
 #eturn self.__class__, (self.colkeys,)

 #classmethod
 #ef _reduce_from_cols(cls, cols):
 #ef _table_key(c):
 #f not isinstance(c.table, expression.TableClause):
 #eturn None
 #lse:
 #eturn c.table.key

 #olkeys = [(c.key, _table_key(c)) for c in cols]
 #eturn _SerializableColumnGetterV2, (colkeys,)

 #ef _cols(self, mapper):
 #ols = []
 #etadata = getattr(mapper.local_table, "metadata", None)
 #or (ckey, tkey) in self.colkeys:
 #f tkey is None or metadata is None or tkey not in metadata:
 #ols.append(mapper.local_table.c[ckey])
 #lse:
 #ols.append(metadata.tables[tkey].c[ckey])
 #eturn cols


def column_mapped_collection(mapping_spec):
 #""A dictionary-based collection type with column-based keying.

 #eturns a :class:`.MappedCollection` factory with a keying function
 #enerated from mapping_spec, which may be a Column or a sequence
 #f Columns.

 #he key value must be immutable for the lifetime of the object.  You
 #an not, for example, map on foreign key values if those key values will
 #hange during the session, i.e. from None to a database-assigned integer
 #fter a session flush.

 #""
 #ols = [
 #oercions.expect(roles.ColumnArgumentRole, q, argname="mapping_spec")
 #or q in util.to_list(mapping_spec)
 #
 #eyfunc = _PlainColumnGetter(cols)
 #eturn lambda: MappedCollection(keyfunc)


class _SerializableAttrGetter(object):
 #ef __init__(self, name):
 #elf.name = name
 #elf.getter = operator.attrgetter(name)

 #ef __call__(self, target):
 #eturn self.getter(target)

 #ef __reduce__(self):
 #eturn _SerializableAttrGetter, (self.name,)


def attribute_mapped_collection(attr_name):
 #""A dictionary-based collection type with attribute-based keying.

 #eturns a :class:`.MappedCollection` factory with a keying based on the
 #attr_name' attribute of entities in the collection, where ``attr_name``
 #s the string name of the attribute.

 #. warning:: the key value must be assigned to its final value
 #*before** it is accessed by the attribute mapped collection.
 #dditionally, changes to the key attribute are **not tracked**
 #utomatically, which means the key in the dictionary is not
 #utomatically synchronized with the key value on the target object
 #tself.  See the section :ref:`key_collections_mutations`
 #or an example.

 #""
 #etter = _SerializableAttrGetter(attr_name)
 #eturn lambda: MappedCollection(getter)


def mapped_collection(keyfunc):
 #""A dictionary-based collection type with arbitrary keying.

 #eturns a :class:`.MappedCollection` factory with a keying function
 #enerated from keyfunc, a callable that takes an entity and returns a
 #ey value.

 #he key value must be immutable for the lifetime of the object.  You
 #an not, for example, map on foreign key values if those key values will
 #hange during the session, i.e. from None to a database-assigned integer
 #fter a session flush.

 #""
 #eturn lambda: MappedCollection(keyfunc)


class collection(object):
 #""Decorators for entity collection classes.

 #he decorators fall into two groups: annotations and interception recipes.

 #he annotating decorators (appender, remover, iterator, converter,
 #nternally_instrumented) indicate the method's purpose and take no
 #rguments.  They are not written with parens::

 #collection.appender
 #ef append(self, append): ...

 #he recipe decorators all require parens, even those that take no
 #rguments::

 #collection.adds('entity')
 #ef insert(self, position, entity): ...

 #collection.removes_return()
 #ef popitem(self): ...

 #""

    # Bundled as a class solely for ease of use: packaging, doc strings,
    # importability.

 #staticmethod
 #ef appender(fn):
 #""Tag the method as the collection appender.

 #he appender method is called with one positional argument: the value
 #o append. The method will be automatically decorated with 'adds(1)'
 #f not already decorated::

 #collection.appender
 #ef add(self, append): ...

            # or, equivalently
 #collection.appender
 #collection.adds(1)
 #ef add(self, append): ...

            # for mapping type, an 'append' may kick out a previous value
            # that occupies that slot.  consider d['a'] = 'foo'- any previous
            # value in d['a'] is discarded.
 #collection.appender
 #collection.replaces(1)
 #ef add(self, entity):
 #ey = some_key_func(entity)
 #revious = None
 #f key in self:
 #revious = self[key]
 #elf[key] = entity
 #eturn previous

 #f the value to append is not allowed in the collection, you may
 #aise an exception.  Something to remember is that the appender
 #ill be called for each object mapped by a database query.  If the
 #atabase contains rows that violate your collection semantics, you
 #ill need to get creative to fix the problem, as access via the
 #ollection will not work.

 #f the appender method is internally instrumented, you must also
 #eceive the keyword argument '_sa_initiator' and ensure its
 #romulgation to collection events.

 #""
 #n._sa_instrument_role = "appender"
 #eturn fn

 #staticmethod
 #ef remover(fn):
 #""Tag the method as the collection remover.

 #he remover method is called with one positional argument: the value
 #o remove. The method will be automatically decorated with
 #meth:`removes_return` if not already decorated::

 #collection.remover
 #ef zap(self, entity): ...

            # or, equivalently
 #collection.remover
 #collection.removes_return()
 #ef zap(self, ): ...

 #f the value to remove is not present in the collection, you may
 #aise an exception or return None to ignore the error.

 #f the remove method is internally instrumented, you must also
 #eceive the keyword argument '_sa_initiator' and ensure its
 #romulgation to collection events.

 #""
 #n._sa_instrument_role = "remover"
 #eturn fn

 #staticmethod
 #ef iterator(fn):
 #""Tag the method as the collection remover.

 #he iterator method is called with no arguments.  It is expected to
 #eturn an iterator over all collection members::

 #collection.iterator
 #ef __iter__(self): ...

 #""
 #n._sa_instrument_role = "iterator"
 #eturn fn

 #staticmethod
 #ef internally_instrumented(fn):
 #""Tag the method as instrumented.

 #his tag will prevent any decoration from being applied to the
 #ethod. Use this if you are orchestrating your own calls to
 #func:`.collection_adapter` in one of the basic SQLAlchemy
 #nterface methods, or to prevent an automatic ABC method
 #ecoration from wrapping your implementation::

            # normally an 'extend' method on a list-like class would be
            # automatically intercepted and re-implemented in terms of
            # SQLAlchemy events and append().  your implementation will
            # never be called, unless:
 #collection.internally_instrumented
 #ef extend(self, items): ...

 #""
 #n._sa_instrumented = True
 #eturn fn

 #staticmethod
 #util.deprecated(
 #1.3",
 #The :meth:`.collection.converter` handler is deprecated and will "
 #be removed in a future release.  Please refer to the "
 #:class:`.AttributeEvents.bulk_replace` listener interface in "
 #conjunction with the :func:`.event.listen` function.",
 #
 #ef converter(fn):
 #""Tag the method as the collection converter.

 #his optional method will be called when a collection is being
 #eplaced entirely, as in::

 #yobj.acollection = [newvalue1, newvalue2]

 #he converter method will receive the object being assigned and should
 #eturn an iterable of values suitable for use by the ``appender``
 #ethod.  A converter must not assign values or mutate the collection,
 #ts sole job is to adapt the value the user provides into an iterable
 #f values for the ORM's use.

 #he default converter implementation will use duck-typing to do the
 #onversion.  A dict-like collection will be convert into an iterable
 #f dictionary values, and other types will simply be iterated::

 #collection.converter
 #ef convert(self, other): ...

 #f the duck-typing of the object does not match the type of this
 #ollection, a TypeError is raised.

 #upply an implementation of this method if you want to expand the
 #ange of possible types that can be assigned in bulk or perform
 #alidation on the values about to be assigned.

 #""
 #n._sa_instrument_role = "converter"
 #eturn fn

 #staticmethod
 #ef adds(arg):
 #""Mark the method as adding an entity to the collection.

 #dds "add to collection" handling to the method.  The decorator
 #rgument indicates which method argument holds the SQLAlchemy-relevant
 #alue.  Arguments can be specified positionally (i.e. integer) or by
 #ame::

 #collection.adds(1)
 #ef push(self, item): ...

 #collection.adds('entity')
 #ef do_stuff(self, thing, entity=None): ...

 #""

 #ef decorator(fn):
 #n._sa_instrument_before = ("fire_append_event", arg)
 #eturn fn

 #eturn decorator

 #staticmethod
 #ef replaces(arg):
 #""Mark the method as replacing an entity in the collection.

 #dds "add to collection" and "remove from collection" handling to
 #he method.  The decorator argument indicates which method argument
 #olds the SQLAlchemy-relevant value to be added, and return value, if
 #ny will be considered the value to remove.

 #rguments can be specified positionally (i.e. integer) or by name::

 #collection.replaces(2)
 #ef __setitem__(self, index, item): ...

 #""

 #ef decorator(fn):
 #n._sa_instrument_before = ("fire_append_event", arg)
 #n._sa_instrument_after = "fire_remove_event"
 #eturn fn

 #eturn decorator

 #staticmethod
 #ef removes(arg):
 #""Mark the method as removing an entity in the collection.

 #dds "remove from collection" handling to the method.  The decorator
 #rgument indicates which method argument holds the SQLAlchemy-relevant
 #alue to be removed. Arguments can be specified positionally (i.e.
 #nteger) or by name::

 #collection.removes(1)
 #ef zap(self, item): ...

 #or methods where the value to remove is not known at call-time, use
 #ollection.removes_return.

 #""

 #ef decorator(fn):
 #n._sa_instrument_before = ("fire_remove_event", arg)
 #eturn fn

 #eturn decorator

 #staticmethod
 #ef removes_return():
 #""Mark the method as removing an entity in the collection.

 #dds "remove from collection" handling to the method.  The return
 #alue of the method, if any, is considered the value to remove.  The
 #ethod arguments are not inspected::

 #collection.removes_return()
 #ef pop(self): ...

 #or methods where the value to remove is known at call-time, use
 #ollection.remove.

 #""

 #ef decorator(fn):
 #n._sa_instrument_after = "fire_remove_event"
 #eturn fn

 #eturn decorator


collection_adapter = operator.attrgetter("_sa_adapter")
"""Fetch the :class:`.CollectionAdapter` for a collection."""


class CollectionAdapter(object):
 #""Bridges between the ORM and arbitrary Python collections.

 #roxies base-level collection operations (append, remove, iterate)
 #o the underlying Python collection, and emits add/remove events for
 #ntities entering or leaving the collection.

 #he ORM uses :class:`.CollectionAdapter` exclusively for interaction with
 #ntity collections.


 #""

 #_slots__ = (
 #attr",
 #_key",
 #_data",
 #owner_state",
 #_converter",
 #invalidated",
 #empty",
 #

 #ef __init__(self, attr, owner_state, data):
 #elf.attr = attr
 #elf._key = attr.key
 #elf._data = weakref.ref(data)
 #elf.owner_state = owner_state
 #ata._sa_adapter = self
 #elf._converter = data._sa_converter
 #elf.invalidated = False
 #elf.empty = False

 #ef _warn_invalidated(self):
 #til.warn("This collection has been invalidated.")

 #property
 #ef data(self):
 #The entity collection being adapted."
 #eturn self._data()

 #property
 #ef _referenced_by_owner(self):
 #""return True if the owner state still refers to this collection.

 #his will return False within a bulk replace operation,
 #here this collection is the one being replaced.

 #""
 #eturn self.owner_state.dict[self._key] is self._data()

 #ef bulk_appender(self):
 #eturn self._data()._sa_appender

 #ef append_with_event(self, item, initiator=None):
 #""Add an entity to the collection, firing mutation events."""

 #elf._data()._sa_appender(item, _sa_initiator=initiator)

 #ef _set_empty(self, user_data):
 #ssert (
 #ot self.empty
 #, "This collection adapter is already in the 'empty' state"
 #elf.empty = True
 #elf.owner_state._empty_collections[self._key] = user_data

 #ef _reset_empty(self):
 #ssert (
 #elf.empty
 #, "This collection adapter is not in the 'empty' state"
 #elf.empty = False
 #elf.owner_state.dict[
 #elf._key
 # = self.owner_state._empty_collections.pop(self._key)

 #ef _refuse_empty(self):
 #aise sa_exc.InvalidRequestError(
 #This is a special 'empty' collection which cannot accommodate "
 #internal mutation operations"
 #

 #ef append_without_event(self, item):
 #""Add or restore an entity to the collection, firing no events."""

 #f self.empty:
 #elf._refuse_empty()
 #elf._data()._sa_appender(item, _sa_initiator=False)

 #ef append_multiple_without_event(self, items):
 #""Add or restore an entity to the collection, firing no events."""
 #f self.empty:
 #elf._refuse_empty()
 #ppender = self._data()._sa_appender
 #or item in items:
 #ppender(item, _sa_initiator=False)

 #ef bulk_remover(self):
 #eturn self._data()._sa_remover

 #ef remove_with_event(self, item, initiator=None):
 #""Remove an entity from the collection, firing mutation events."""
 #elf._data()._sa_remover(item, _sa_initiator=initiator)

 #ef remove_without_event(self, item):
 #""Remove an entity from the collection, firing no events."""
 #f self.empty:
 #elf._refuse_empty()
 #elf._data()._sa_remover(item, _sa_initiator=False)

 #ef clear_with_event(self, initiator=None):
 #""Empty the collection, firing a mutation event for each entity."""

 #f self.empty:
 #elf._refuse_empty()
 #emover = self._data()._sa_remover
 #or item in list(self):
 #emover(item, _sa_initiator=initiator)

 #ef clear_without_event(self):
 #""Empty the collection, firing no events."""

 #f self.empty:
 #elf._refuse_empty()
 #emover = self._data()._sa_remover
 #or item in list(self):
 #emover(item, _sa_initiator=False)

 #ef __iter__(self):
 #""Iterate over entities in the collection."""

 #eturn iter(self._data()._sa_iterator())

 #ef __len__(self):
 #""Count entities in the collection."""
 #eturn len(list(self._data()._sa_iterator()))

 #ef __bool__(self):
 #eturn True

 #_nonzero__ = __bool__

 #ef fire_append_wo_mutation_event(self, item, initiator=None):
 #""Notify that a entity is entering the collection but is already
 #resent.


 #nitiator is a token owned by the InstrumentedAttribute that
 #nitiated the membership mutation, and should be left as None
 #nless you are passing along an initiator value from a chained
 #peration.

 #. versionadded:: 1.4.15

 #""
 #f initiator is not False:
 #f self.invalidated:
 #elf._warn_invalidated()

 #f self.empty:
 #elf._reset_empty()

 #eturn self.attr.fire_append_wo_mutation_event(
 #elf.owner_state, self.owner_state.dict, item, initiator
 #
 #lse:
 #eturn item

 #ef fire_append_event(self, item, initiator=None):
 #""Notify that a entity has entered the collection.

 #nitiator is a token owned by the InstrumentedAttribute that
 #nitiated the membership mutation, and should be left as None
 #nless you are passing along an initiator value from a chained
 #peration.

 #""
 #f initiator is not False:
 #f self.invalidated:
 #elf._warn_invalidated()

 #f self.empty:
 #elf._reset_empty()

 #eturn self.attr.fire_append_event(
 #elf.owner_state, self.owner_state.dict, item, initiator
 #
 #lse:
 #eturn item

 #ef fire_remove_event(self, item, initiator=None):
 #""Notify that a entity has been removed from the collection.

 #nitiator is the InstrumentedAttribute that initiated the membership
 #utation, and should be left as None unless you are passing along
 #n initiator value from a chained operation.

 #""
 #f initiator is not False:
 #f self.invalidated:
 #elf._warn_invalidated()

 #f self.empty:
 #elf._reset_empty()

 #elf.attr.fire_remove_event(
 #elf.owner_state, self.owner_state.dict, item, initiator
 #

 #ef fire_pre_remove_event(self, initiator=None):
 #""Notify that an entity is about to be removed from the collection.

 #nly called if the entity cannot be removed after calling
 #ire_remove_event().

 #""
 #f self.invalidated:
 #elf._warn_invalidated()
 #elf.attr.fire_pre_remove_event(
 #elf.owner_state, self.owner_state.dict, initiator=initiator
 #

 #ef __getstate__(self):
 #eturn {
 #key": self._key,
 #owner_state": self.owner_state,
 #owner_cls": self.owner_state.class_,
 #data": self.data,
 #invalidated": self.invalidated,
 #empty": self.empty,
 #

 #ef __setstate__(self, d):
 #elf._key = d["key"]
 #elf.owner_state = d["owner_state"]
 #elf._data = weakref.ref(d["data"])
 #elf._converter = d["data"]._sa_converter
 #["data"]._sa_adapter = self
 #elf.invalidated = d["invalidated"]
 #elf.attr = getattr(d["owner_cls"], self._key).impl
 #elf.empty = d.get("empty", False)


def bulk_replace(values, existing_adapter, new_adapter, initiator=None):
 #""Load a new collection, firing events based on prior like membership.

 #ppends instances in ``values`` onto the ``new_adapter``. Events will be
 #ired for any instance not present in the ``existing_adapter``.  Any
 #nstances in ``existing_adapter`` not present in ``values`` will have
 #emove events fired upon them.

 #param values: An iterable of collection member instances

 #param existing_adapter: A :class:`.CollectionAdapter` of
 #nstances to be replaced

 #param new_adapter: An empty :class:`.CollectionAdapter`
 #o load with ``values``


 #""

 #ssert isinstance(values, list)

 #dset = util.IdentitySet
 #xisting_idset = idset(existing_adapter or ())
 #onstants = existing_idset.intersection(values or ())
 #dditions = idset(values or ()).difference(constants)
 #emovals = existing_idset.difference(constants)

 #ppender = new_adapter.bulk_appender()

 #or member in values or ():
 #f member in additions:
 #ppender(member, _sa_initiator=initiator)
 #lif member in constants:
 #ppender(member, _sa_initiator=False)

 #f existing_adapter:
 #or member in removals:
 #xisting_adapter.fire_remove_event(member, initiator=initiator)


def prepare_instrumentation(factory):
 #""Prepare a callable for future use as a collection class factory.

 #iven a collection class factory (either a type or no-arg callable),
 #eturn another factory that will produce compatible instances when
 #alled.

 #his function is responsible for converting collection_class=list
 #nto the run-time behavior of collection_class=InstrumentedList.

 #""
    # Convert a builtin to 'Instrumented*'
 #f factory in __canned_instrumentation:
 #actory = __canned_instrumentation[factory]

    # Create a specimen
 #ls = type(factory())

    # Did factory callable return a builtin?
 #f cls in __canned_instrumentation:
        # Wrap it so that it returns our 'Instrumented*'
 #actory = __converting_factory(cls, factory)
 #ls = factory()

    # Instrument the class if needed.
 #f __instrumentation_mutex.acquire():
 #ry:
 #f getattr(cls, "_sa_instrumented", None) != id(cls):
 #instrument_class(cls)
 #inally:
 #_instrumentation_mutex.release()

 #eturn factory


def __converting_factory(specimen_cls, original_factory):
 #""Return a wrapper that converts a "canned" collection like
 #et, dict, list into the Instrumented* version.

 #""

 #nstrumented_cls = __canned_instrumentation[specimen_cls]

 #ef wrapper():
 #ollection = original_factory()
 #eturn instrumented_cls(collection)

    # often flawed but better than nothing
 #rapper.__name__ = "%sWrapper" % original_factory.__name__
 #rapper.__doc__ = original_factory.__doc__

 #eturn wrapper


def _instrument_class(cls):
 #""Modify methods in a class and install instrumentation."""

    # In the normal call flow, a request for any of the 3 basic collection
    # types is transformed into one of our trivial subclasses
    # (e.g. InstrumentedList).  Catch anything else that sneaks in here...
 #f cls.__module__ == "__builtin__":
 #aise sa_exc.ArgumentError(
 #Can not instrument a built-in type. Use a "
 #subclass, even a trivial one."
 #

 #oles, methods = _locate_roles_and_methods(cls)

 #setup_canned_roles(cls, roles, methods)

 #assert_required_roles(cls, roles, methods)

 #set_collection_attributes(cls, roles, methods)


def _locate_roles_and_methods(cls):
 #""search for _sa_instrument_role-decorated methods in
 #ethod resolution order, assign to roles.

 #""

 #oles = {}
 #ethods = {}

 #or supercls in cls.__mro__:
 #or name, method in vars(supercls).items():
 #f not callable(method):
 #ontinue

            # note role declarations
 #f hasattr(method, "_sa_instrument_role"):
 #ole = method._sa_instrument_role
 #ssert role in (
 #appender",
 #remover",
 #iterator",
 #converter",
 #
 #oles.setdefault(role, name)

            # transfer instrumentation requests from decorated function
            # to the combined queue
 #efore, after = None, None
 #f hasattr(method, "_sa_instrument_before"):
 #p, argument = method._sa_instrument_before
 #ssert op in ("fire_append_event", "fire_remove_event")
 #efore = op, argument
 #f hasattr(method, "_sa_instrument_after"):
 #p = method._sa_instrument_after
 #ssert op in ("fire_append_event", "fire_remove_event")
 #fter = op
 #f before:
 #ethods[name] = before + (after,)
 #lif after:
 #ethods[name] = None, None, after
 #eturn roles, methods


def _setup_canned_roles(cls, roles, methods):
 #""see if this class has "canned" roles based on a known
 #ollection type (dict, set, list).  Apply those roles
 #s needed to the "roles" dictionary, and also
 #repare "decorator" methods

 #""
 #ollection_type = util.duck_type_collection(cls)
 #f collection_type in __interfaces:
 #anned_roles, decorators = __interfaces[collection_type]
 #or role, name in canned_roles.items():
 #oles.setdefault(role, name)

        # apply ABC auto-decoration to methods that need it
 #or method, decorator in decorators.items():
 #n = getattr(cls, method, None)
 #f (
 #n
 #nd method not in methods
 #nd not hasattr(fn, "_sa_instrumented")
 #:
 #etattr(cls, method, decorator(fn))


def _assert_required_roles(cls, roles, methods):
 #""ensure all roles are present, and apply implicit instrumentation if
 #eeded

 #""
 #f "appender" not in roles or not hasattr(cls, roles["appender"]):
 #aise sa_exc.ArgumentError(
 #Type %s must elect an appender method to be "
 #a collection class" % cls.__name__
 #
 #lif roles["appender"] not in methods and not hasattr(
 #etattr(cls, roles["appender"]), "_sa_instrumented"
 #:
 #ethods[roles["appender"]] = ("fire_append_event", 1, None)

 #f "remover" not in roles or not hasattr(cls, roles["remover"]):
 #aise sa_exc.ArgumentError(
 #Type %s must elect a remover method to be "
 #a collection class" % cls.__name__
 #
 #lif roles["remover"] not in methods and not hasattr(
 #etattr(cls, roles["remover"]), "_sa_instrumented"
 #:
 #ethods[roles["remover"]] = ("fire_remove_event", 1, None)

 #f "iterator" not in roles or not hasattr(cls, roles["iterator"]):
 #aise sa_exc.ArgumentError(
 #Type %s must elect an iterator method to be "
 #a collection class" % cls.__name__
 #


def _set_collection_attributes(cls, roles, methods):
 #""apply ad-hoc instrumentation from decorators, class-level defaults
 #nd implicit role declarations

 #""
 #or method_name, (before, argument, after) in methods.items():
 #etattr(
 #ls,
 #ethod_name,
 #instrument_membership_mutator(
 #etattr(cls, method_name), before, argument, after
 #,
 #
    # intern the role map
 #or role, method_name in roles.items():
 #etattr(cls, "_sa_%s" % role, getattr(cls, method_name))

 #ls._sa_adapter = None

 #f not hasattr(cls, "_sa_converter"):
 #ls._sa_converter = None
 #ls._sa_instrumented = id(cls)


def _instrument_membership_mutator(method, before, argument, after):
 #""Route method args and/or return value through the collection
 #dapter."""
    # This isn't smart enough to handle @adds(1) for 'def fn(self, (a, b))'
 #f before:
 #n_args = list(
 #til.flatten_iterator(inspect_getfullargspec(method)[0])
 #
 #f isinstance(argument, int):
 #os_arg = argument
 #amed_arg = len(fn_args) > argument and fn_args[argument] or None
 #lse:
 #f argument in fn_args:
 #os_arg = fn_args.index(argument)
 #lse:
 #os_arg = None
 #amed_arg = argument
 #el fn_args

 #ef wrapper(*args, **kw):
 #f before:
 #f pos_arg is None:
 #f named_arg not in kw:
 #aise sa_exc.ArgumentError(
 #Missing argument %s" % argument
 #
 #alue = kw[named_arg]
 #lse:
 #f len(args) > pos_arg:
 #alue = args[pos_arg]
 #lif named_arg in kw:
 #alue = kw[named_arg]
 #lse:
 #aise sa_exc.ArgumentError(
 #Missing argument %s" % argument
 #

 #nitiator = kw.pop("_sa_initiator", None)
 #f initiator is False:
 #xecutor = None
 #lse:
 #xecutor = args[0]._sa_adapter

 #f before and executor:
 #etattr(executor, before)(value, initiator)

 #f not after or not executor:
 #eturn method(*args, **kw)
 #lse:
 #es = method(*args, **kw)
 #f res is not None:
 #etattr(executor, after)(res, initiator)
 #eturn res

 #rapper._sa_instrumented = True
 #f hasattr(method, "_sa_instrument_role"):
 #rapper._sa_instrument_role = method._sa_instrument_role
 #rapper.__name__ = method.__name__
 #rapper.__doc__ = method.__doc__
 #eturn wrapper


def __set_wo_mutation(collection, item, _sa_initiator=None):
 #""Run set wo mutation events.

 #he collection is not mutated.

 #""
 #f _sa_initiator is not False:
 #xecutor = collection._sa_adapter
 #f executor:
 #xecutor.fire_append_wo_mutation_event(item, _sa_initiator)


def __set(collection, item, _sa_initiator=None):
 #""Run set events.

 #his event always occurs before the collection is actually mutated.

 #""

 #f _sa_initiator is not False:
 #xecutor = collection._sa_adapter
 #f executor:
 #tem = executor.fire_append_event(item, _sa_initiator)
 #eturn item


def __del(collection, item, _sa_initiator=None):
 #""Run del events.

 #his event occurs before the collection is actually mutated, *except*
 #n the case of a pop operation, in which case it occurs afterwards.
 #or pop operations, the __before_pop hook is called before the
 #peration occurs.

 #""
 #f _sa_initiator is not False:
 #xecutor = collection._sa_adapter
 #f executor:
 #xecutor.fire_remove_event(item, _sa_initiator)


def __before_pop(collection, _sa_initiator=None):
 #""An event which occurs on a before a pop() operation occurs."""
 #xecutor = collection._sa_adapter
 #f executor:
 #xecutor.fire_pre_remove_event(_sa_initiator)


def _list_decorators():
 #""Tailored instrumentation wrappers for any list-like class."""

 #ef _tidy(fn):
 #n._sa_instrumented = True
 #n.__doc__ = getattr(list, fn.__name__).__doc__

 #ef append(fn):
 #ef append(self, item, _sa_initiator=None):
 #tem = __set(self, item, _sa_initiator)
 #n(self, item)

 #tidy(append)
 #eturn append

 #ef remove(fn):
 #ef remove(self, value, _sa_initiator=None):
 #_del(self, value, _sa_initiator)
            # testlib.pragma exempt:__eq__
 #n(self, value)

 #tidy(remove)
 #eturn remove

 #ef insert(fn):
 #ef insert(self, index, value):
 #alue = __set(self, value)
 #n(self, index, value)

 #tidy(insert)
 #eturn insert

 #ef __setitem__(fn):
 #ef __setitem__(self, index, value):
 #f not isinstance(index, slice):
 #xisting = self[index]
 #f existing is not None:
 #_del(self, existing)
 #alue = __set(self, value)
 #n(self, index, value)
 #lse:
                # slice assignment requires __delitem__, insert, __len__
 #tep = index.step or 1
 #tart = index.start or 0
 #f start < 0:
 #tart += len(self)
 #f index.stop is not None:
 #top = index.stop
 #lse:
 #top = len(self)
 #f stop < 0:
 #top += len(self)

 #f step == 1:
 #f value is self:
 #eturn
 #or i in range(start, stop, step):
 #f len(self) > start:
 #el self[start]

 #or i, item in enumerate(value):
 #elf.insert(i + start, item)
 #lse:
 #ng = list(range(start, stop, step))
 #f len(value) != len(rng):
 #aise ValueError(
 #attempt to assign sequence of size %s to "
 #extended slice of size %s"
 # (len(value), len(rng))
 #
 #or i, item in zip(rng, value):
 #elf.__setitem__(i, item)

 #tidy(__setitem__)
 #eturn __setitem__

 #ef __delitem__(fn):
 #ef __delitem__(self, index):
 #f not isinstance(index, slice):
 #tem = self[index]
 #_del(self, item)
 #n(self, index)
 #lse:
                # slice deletion requires __getslice__ and a slice-groking
                # __getitem__ for stepped deletion
                # note: not breaking this into atomic dels
 #or item in self[index]:
 #_del(self, item)
 #n(self, index)

 #tidy(__delitem__)
 #eturn __delitem__

 #f util.py2k:

 #ef __setslice__(fn):
 #ef __setslice__(self, start, end, values):
 #or value in self[start:end]:
 #_del(self, value)
 #alues = [__set(self, value) for value in values]
 #n(self, start, end, values)

 #tidy(__setslice__)
 #eturn __setslice__

 #ef __delslice__(fn):
 #ef __delslice__(self, start, end):
 #or value in self[start:end]:
 #_del(self, value)
 #n(self, start, end)

 #tidy(__delslice__)
 #eturn __delslice__

 #ef extend(fn):
 #ef extend(self, iterable):
 #or value in iterable:
 #elf.append(value)

 #tidy(extend)
 #eturn extend

 #ef __iadd__(fn):
 #ef __iadd__(self, iterable):
            # list.__iadd__ takes any iterable and seems to let TypeError
            # raise as-is instead of returning NotImplemented
 #or value in iterable:
 #elf.append(value)
 #eturn self

 #tidy(__iadd__)
 #eturn __iadd__

 #ef pop(fn):
 #ef pop(self, index=-1):
 #_before_pop(self)
 #tem = fn(self, index)
 #_del(self, item)
 #eturn item

 #tidy(pop)
 #eturn pop

 #f not util.py2k:

 #ef clear(fn):
 #ef clear(self, index=-1):
 #or item in self:
 #_del(self, item)
 #n(self)

 #tidy(clear)
 #eturn clear

    # __imul__ : not wrapping this.  all members of the collection are already
    # present, so no need to fire appends... wrapping it with an explicit
    # decorator is still possible, so events on *= can be had if they're
    # desired.  hard to imagine a use case for __imul__, though.

 # = locals().copy()
 #.pop("_tidy")
 #eturn l


def _dict_decorators():
 #""Tailored instrumentation wrappers for any dict-like mapping class."""

 #ef _tidy(fn):
 #n._sa_instrumented = True
 #n.__doc__ = getattr(dict, fn.__name__).__doc__

 #nspecified = util.symbol("Unspecified")

 #ef __setitem__(fn):
 #ef __setitem__(self, key, value, _sa_initiator=None):
 #f key in self:
 #_del(self, self[key], _sa_initiator)
 #alue = __set(self, value, _sa_initiator)
 #n(self, key, value)

 #tidy(__setitem__)
 #eturn __setitem__

 #ef __delitem__(fn):
 #ef __delitem__(self, key, _sa_initiator=None):
 #f key in self:
 #_del(self, self[key], _sa_initiator)
 #n(self, key)

 #tidy(__delitem__)
 #eturn __delitem__

 #ef clear(fn):
 #ef clear(self):
 #or key in self:
 #_del(self, self[key])
 #n(self)

 #tidy(clear)
 #eturn clear

 #ef pop(fn):
 #ef pop(self, key, default=Unspecified):
 #_before_pop(self)
 #to_del = key in self
 #f default is Unspecified:
 #tem = fn(self, key)
 #lse:
 #tem = fn(self, key, default)
 #f _to_del:
 #_del(self, item)
 #eturn item

 #tidy(pop)
 #eturn pop

 #ef popitem(fn):
 #ef popitem(self):
 #_before_pop(self)
 #tem = fn(self)
 #_del(self, item[1])
 #eturn item

 #tidy(popitem)
 #eturn popitem

 #ef setdefault(fn):
 #ef setdefault(self, key, default=None):
 #f key not in self:
 #elf.__setitem__(key, default)
 #eturn default
 #lse:
 #alue = self.__getitem__(key)
 #f value is default:
 #_set_wo_mutation(self, value, None)

 #eturn value

 #tidy(setdefault)
 #eturn setdefault

 #ef update(fn):
 #ef update(self, __other=Unspecified, **kw):
 #f __other is not Unspecified:
 #f hasattr(__other, "keys"):
 #or key in list(__other):
 #f key not in self or self[key] is not __other[key]:
 #elf[key] = __other[key]
 #lse:
 #_set_wo_mutation(self, __other[key], None)
 #lse:
 #or key, value in __other:
 #f key not in self or self[key] is not value:
 #elf[key] = value
 #lse:
 #_set_wo_mutation(self, value, None)
 #or key in kw:
 #f key not in self or self[key] is not kw[key]:
 #elf[key] = kw[key]
 #lse:
 #_set_wo_mutation(self, kw[key], None)

 #tidy(update)
 #eturn update

 # = locals().copy()
 #.pop("_tidy")
 #.pop("Unspecified")
 #eturn l


_set_binop_bases = (set, frozenset)


def _set_binops_check_strict(self, obj):
 #""Allow only set, frozenset and self.__class__-derived
 #bjects in binops."""
 #eturn isinstance(obj, _set_binop_bases + (self.__class__,))


def _set_binops_check_loose(self, obj):
 #""Allow anything set-like to participate in set binops."""
 #eturn (
 #sinstance(obj, _set_binop_bases + (self.__class__,))
 #r util.duck_type_collection(obj) == set
 #


def _set_decorators():
 #""Tailored instrumentation wrappers for any set-like class."""

 #ef _tidy(fn):
 #n._sa_instrumented = True
 #n.__doc__ = getattr(set, fn.__name__).__doc__

 #nspecified = util.symbol("Unspecified")

 #ef add(fn):
 #ef add(self, value, _sa_initiator=None):
 #f value not in self:
 #alue = __set(self, value, _sa_initiator)
 #lse:
 #_set_wo_mutation(self, value, _sa_initiator)
            # testlib.pragma exempt:__hash__
 #n(self, value)

 #tidy(add)
 #eturn add

 #ef discard(fn):
 #ef discard(self, value, _sa_initiator=None):
            # testlib.pragma exempt:__hash__
 #f value in self:
 #_del(self, value, _sa_initiator)
                # testlib.pragma exempt:__hash__
 #n(self, value)

 #tidy(discard)
 #eturn discard

 #ef remove(fn):
 #ef remove(self, value, _sa_initiator=None):
            # testlib.pragma exempt:__hash__
 #f value in self:
 #_del(self, value, _sa_initiator)
            # testlib.pragma exempt:__hash__
 #n(self, value)

 #tidy(remove)
 #eturn remove

 #ef pop(fn):
 #ef pop(self):
 #_before_pop(self)
 #tem = fn(self)
            # for set in particular, we have no way to access the item
            # that will be popped before pop is called.
 #_del(self, item)
 #eturn item

 #tidy(pop)
 #eturn pop

 #ef clear(fn):
 #ef clear(self):
 #or item in list(self):
 #elf.remove(item)

 #tidy(clear)
 #eturn clear

 #ef update(fn):
 #ef update(self, value):
 #or item in value:
 #elf.add(item)

 #tidy(update)
 #eturn update

 #ef __ior__(fn):
 #ef __ior__(self, value):
 #f not _set_binops_check_strict(self, value):
 #eturn NotImplemented
 #or item in value:
 #elf.add(item)
 #eturn self

 #tidy(__ior__)
 #eturn __ior__

 #ef difference_update(fn):
 #ef difference_update(self, value):
 #or item in value:
 #elf.discard(item)

 #tidy(difference_update)
 #eturn difference_update

 #ef __isub__(fn):
 #ef __isub__(self, value):
 #f not _set_binops_check_strict(self, value):
 #eturn NotImplemented
 #or item in value:
 #elf.discard(item)
 #eturn self

 #tidy(__isub__)
 #eturn __isub__

 #ef intersection_update(fn):
 #ef intersection_update(self, other):
 #ant, have = self.intersection(other), set(self)
 #emove, add = have - want, want - have

 #or item in remove:
 #elf.remove(item)
 #or item in add:
 #elf.add(item)

 #tidy(intersection_update)
 #eturn intersection_update

 #ef __iand__(fn):
 #ef __iand__(self, other):
 #f not _set_binops_check_strict(self, other):
 #eturn NotImplemented
 #ant, have = self.intersection(other), set(self)
 #emove, add = have - want, want - have

 #or item in remove:
 #elf.remove(item)
 #or item in add:
 #elf.add(item)
 #eturn self

 #tidy(__iand__)
 #eturn __iand__

 #ef symmetric_difference_update(fn):
 #ef symmetric_difference_update(self, other):
 #ant, have = self.symmetric_difference(other), set(self)
 #emove, add = have - want, want - have

 #or item in remove:
 #elf.remove(item)
 #or item in add:
 #elf.add(item)

 #tidy(symmetric_difference_update)
 #eturn symmetric_difference_update

 #ef __ixor__(fn):
 #ef __ixor__(self, other):
 #f not _set_binops_check_strict(self, other):
 #eturn NotImplemented
 #ant, have = self.symmetric_difference(other), set(self)
 #emove, add = have - want, want - have

 #or item in remove:
 #elf.remove(item)
 #or item in add:
 #elf.add(item)
 #eturn self

 #tidy(__ixor__)
 #eturn __ixor__

 # = locals().copy()
 #.pop("_tidy")
 #.pop("Unspecified")
 #eturn l


class InstrumentedList(list):
 #""An instrumented version of the built-in list."""


class InstrumentedSet(set):
 #""An instrumented version of the built-in set."""


class InstrumentedDict(dict):
 #""An instrumented version of the built-in dict."""


__canned_instrumentation = {
 #ist: InstrumentedList,
 #et: InstrumentedSet,
 #ict: InstrumentedDict,
}

__interfaces = {
 #ist: (
 #"appender": "append", "remover": "remove", "iterator": "__iter__"},
 #list_decorators(),
 #,
 #et: (
 #"appender": "add", "remover": "remove", "iterator": "__iter__"},
 #set_decorators(),
 #,
    # decorators are required for dicts and object collections.
 #ict: ({"iterator": "values"}, _dict_decorators())
 #f util.py3k
 #lse ({"iterator": "itervalues"}, _dict_decorators()),
}


class MappedCollection(dict):
 #""A basic dictionary-based collection class.

 #xtends dict with the minimal bag semantics that collection
 #lasses require. ``set`` and ``remove`` are implemented in terms
 #f a keying function: any callable that takes an object and
 #eturns an object for use as a dictionary key.

 #""

 #ef __init__(self, keyfunc):
 #""Create a new collection with keying provided by keyfunc.

 #eyfunc may be any callable that takes an object and returns an object
 #or use as a dictionary key.

 #he keyfunc will be called every time the ORM needs to add a member by
 #alue-only (such as when loading instances from the database) or
 #emove a member.  The usual cautions about dictionary keying apply-
 #`keyfunc(object)`` should return the same output for the life of the
 #ollection.  Keying based on mutable properties can result in
 #nreachable instances "lost" in the collection.

 #""
 #elf.keyfunc = keyfunc

 #collection.appender
 #collection.internally_instrumented
 #ef set(self, value, _sa_initiator=None):
 #""Add an item by value, consulting the keyfunc for the key."""

 #ey = self.keyfunc(value)
 #elf.__setitem__(key, value, _sa_initiator)

 #collection.remover
 #collection.internally_instrumented
 #ef remove(self, value, _sa_initiator=None):
 #""Remove an item by value, consulting the keyfunc for the key."""

 #ey = self.keyfunc(value)
        # Let self[key] raise if key is not in this collection
        # testlib.pragma exempt:__ne__
 #f self[key] != value:
 #aise sa_exc.InvalidRequestError(
 #Can not remove '%s': collection holds '%s' for key '%s'. "
 #Possible cause: is the MappedCollection key function "
 #based on mutable properties or properties that only obtain "
 #values after flush?" % (value, self[key], key)
 #
 #elf.__delitem__(key, _sa_initiator)


# ensure instrumentation is associated with
# these built-in classes; if a user-defined class
# subclasses these and uses @internally_instrumented,
# the superclass is otherwise not instrumented.
# see [ticket:2406].
_instrument_class(MappedCollection)
_instrument_class(InstrumentedList)
_instrument_class(InstrumentedSet)
