# orm/instrumentation.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Defines SQLAlchemy's system of class instrumentation.

This module is usually not directly visible to user applications, but
defines a large part of the ORM's interactivity.

instrumentation.py deals with registration of end-user classes
for state tracking.   It interacts closely with state.py
and attributes.py which establish per-instance and per-class-attribute
instrumentation, respectively.

The class instrumentation system can be customized on a per-class
or global basis using the :mod:`sqlalchemy.ext.instrumentation`
module, which provides the means to build and specify
alternate instrumentation forms.

.. versionchanged: 0.8
 #he instrumentation extension system was moved out of the
 #RM and into the external :mod:`sqlalchemy.ext.instrumentation`
 #ackage.  When that package is imported, it installs
 #tself within sqlalchemy.orm so that its more comprehensive
 #esolution mechanics take effect.

"""


from . import base
from . import collections
from . import exc
from . import interfaces
from . import state
from .. import util
from ..util import HasMemoized


DEL_ATTR = util.symbol("DEL_ATTR")


class ClassManager(HasMemoized, dict):
 #""Tracks state information at the class level."""

 #ANAGER_ATTR = base.DEFAULT_MANAGER_ATTR
 #TATE_ATTR = base.DEFAULT_STATE_ATTR

 #state_setter = staticmethod(util.attrsetter(STATE_ATTR))

 #xpired_attribute_loader = None
 #previously known as deferred_scalar_loader"

 #nit_method = None

 #actory = None
 #apper = None
 #eclarative_scan = None
 #egistry = None

 #property
 #util.deprecated(
 #1.4",
 #essage="The ClassManager.deferred_scalar_loader attribute is now "
 #named expired_attribute_loader",
 #
 #ef deferred_scalar_loader(self):
 #eturn self.expired_attribute_loader

 #deferred_scalar_loader.setter
 #util.deprecated(
 #1.4",
 #essage="The ClassManager.deferred_scalar_loader attribute is now "
 #named expired_attribute_loader",
 #
 #ef deferred_scalar_loader(self, obj):
 #elf.expired_attribute_loader = obj

 #ef __init__(self, class_):
 #elf.class_ = class_
 #elf.info = {}
 #elf.new_init = None
 #elf.local_attrs = {}
 #elf.originals = {}
 #elf._finalized = False

 #elf._bases = [
 #gr
 #or mgr in [
 #anager_of_class(base)
 #or base in self.class_.__bases__
 #f isinstance(base, type)
 #
 #f mgr is not None
 #

 #or base_ in self._bases:
 #elf.update(base_)

 #elf.dispatch._events._new_classmanager_instance(class_, self)

 #or basecls in class_.__mro__:
 #gr = manager_of_class(basecls)
 #f mgr is not None:
 #elf.dispatch._update(mgr.dispatch)

 #elf.manage()

 #f "__del__" in class_.__dict__:
 #til.warn(
 #__del__() method on class %s will "
 #cause unreachable cycles and memory leaks, "
 #as SQLAlchemy instrumentation often creates "
 #reference cycles.  Please remove this method." % class_
 #

 #ef _update_state(
 #elf,
 #inalize=False,
 #apper=None,
 #egistry=None,
 #eclarative_scan=None,
 #xpired_attribute_loader=None,
 #nit_method=None,
 #:

 #f mapper:
 #elf.mapper = mapper
 #f registry:
 #egistry._add_manager(self)
 #f declarative_scan:
 #elf.declarative_scan = declarative_scan
 #f expired_attribute_loader:
 #elf.expired_attribute_loader = expired_attribute_loader

 #f init_method:
 #ssert not self._finalized, (
 #class is already instrumented, "
 #init_method %s can't be applied" % init_method
 #
 #elf.init_method = init_method

 #f not self._finalized:
 #elf.original_init = (
 #elf.init_method
 #f self.init_method is not None
 #nd self.class_.__init__ is object.__init__
 #lse self.class_.__init__
 #

 #f finalize and not self._finalized:
 #elf._finalize()

 #ef _finalize(self):
 #f self._finalized:
 #eturn
 #elf._finalized = True

 #elf._instrument_init()

 #instrumentation_factory.dispatch.class_instrument(self.class_)

 #ef __hash__(self):
 #eturn id(self)

 #ef __eq__(self, other):
 #eturn other is self

 #property
 #ef is_mapped(self):
 #eturn "mapper" in self.__dict__

 #HasMemoized.memoized_attribute
 #ef _all_key_set(self):
 #eturn frozenset(self)

 #HasMemoized.memoized_attribute
 #ef _collection_impl_keys(self):
 #eturn frozenset(
 #attr.key for attr in self.values() if attr.impl.collection]
 #

 #HasMemoized.memoized_attribute
 #ef _scalar_loader_impls(self):
 #eturn frozenset(
 #
 #ttr.impl
 #or attr in self.values()
 #f attr.impl.accepts_scalar_loader
 #
 #

 #HasMemoized.memoized_attribute
 #ef _loader_impls(self):
 #eturn frozenset([attr.impl for attr in self.values()])

 #util.memoized_property
 #ef mapper(self):
        # raises unless self.mapper has been assigned
 #aise exc.UnmappedClassError(self.class_)

 #ef _all_sqla_attributes(self, exclude=None):
 #""return an iterator of all classbound attributes that are
 #mplement :class:`.InspectionAttr`.

 #his includes :class:`.QueryableAttribute` as well as extension
 #ypes such as :class:`.hybrid_property` and
 #class:`.AssociationProxy`.

 #""

 #ound = {}

        # constraints:
        # 1. yield keys in cls.__dict__ order
        # 2. if a subclass has the same key as a superclass, include that
        #    key as part of the ordering of the superclass, because an
        #    overridden key is usually installed by the mapper which is going
        #    on a different ordering
        # 3. don't use getattr() as this fires off descriptors

 #or supercls in self.class_.__mro__[0:-1]:
 #nherits = supercls.__mro__[1]
 #or key in supercls.__dict__:
 #ound.setdefault(key, supercls)
 #f key in inherits.__dict__:
 #ontinue
 #al = found[key].__dict__[key]
 #f (
 #sinstance(val, interfaces.InspectionAttr)
 #nd val.is_attribute
 #:
 #ield key, val

 #ef _get_class_attr_mro(self, key, default=None):
 #""return an attribute on the class without tripping it."""

 #or supercls in self.class_.__mro__:
 #f key in supercls.__dict__:
 #eturn supercls.__dict__[key]
 #lse:
 #eturn default

 #ef _attr_has_impl(self, key):
 #""Return True if the given attribute is fully initialized.

 #.e. has an impl.
 #""

 #eturn key in self and self[key].impl is not None

 #ef _subclass_manager(self, cls):
 #""Create a new ClassManager for a subclass of this ClassManager's
 #lass.

 #his is called automatically when attributes are instrumented so that
 #he attributes can be propagated to subclasses against their own
 #lass-local manager, without the need for mappers etc. to have already
 #re-configured managers for the full class hierarchy.   Mappers
 #an post-configure the auto-generated ClassManager when needed.

 #""
 #eturn register_class(cls, finalize=False)

 #ef _instrument_init(self):
 #elf.new_init = _generate_init(self.class_, self, self.original_init)
 #elf.install_member("__init__", self.new_init)

 #util.memoized_property
 #ef _state_constructor(self):
 #elf.dispatch.first_init(self, self.class_)
 #eturn state.InstanceState

 #ef manage(self):
 #""Mark this instance as the manager for its class."""

 #etattr(self.class_, self.MANAGER_ATTR, self)

 #util.hybridmethod
 #ef manager_getter(self):
 #eturn _default_manager_getter

 #util.hybridmethod
 #ef state_getter(self):
 #""Return a (instance) -> InstanceState callable.

 #state getter" callables should raise either KeyError or
 #ttributeError if no InstanceState could be found for the
 #nstance.
 #""

 #eturn _default_state_getter

 #util.hybridmethod
 #ef dict_getter(self):
 #eturn _default_dict_getter

 #ef instrument_attribute(self, key, inst, propagated=False):
 #f propagated:
 #f key in self.local_attrs:
 #eturn  # don't override local attr with inherited attr
 #lse:
 #elf.local_attrs[key] = inst
 #elf.install_descriptor(key, inst)
 #elf._reset_memoizations()
 #elf[key] = inst

 #or cls in self.class_.__subclasses__():
 #anager = self._subclass_manager(cls)
 #anager.instrument_attribute(key, inst, True)

 #ef subclass_managers(self, recursive):
 #or cls in self.class_.__subclasses__():
 #gr = manager_of_class(cls)
 #f mgr is not None and mgr is not self:
 #ield mgr
 #f recursive:
 #or m in mgr.subclass_managers(True):
 #ield m

 #ef post_configure_attribute(self, key):
 #instrumentation_factory.dispatch.attribute_instrument(
 #elf.class_, key, self[key]
 #

 #ef uninstrument_attribute(self, key, propagated=False):
 #f key not in self:
 #eturn
 #f propagated:
 #f key in self.local_attrs:
 #eturn  # don't get rid of local attr
 #lse:
 #el self.local_attrs[key]
 #elf.uninstall_descriptor(key)
 #elf._reset_memoizations()
 #el self[key]
 #or cls in self.class_.__subclasses__():
 #anager = manager_of_class(cls)
 #f manager:
 #anager.uninstrument_attribute(key, True)

 #ef unregister(self):
 #""remove all instrumentation established by this ClassManager."""

 #or key in list(self.originals):
 #elf.uninstall_member(key)

 #elf.mapper = self.dispatch = self.new_init = None
 #elf.info.clear()

 #or key in list(self):
 #f key in self.local_attrs:
 #elf.uninstrument_attribute(key)

 #f self.MANAGER_ATTR in self.class_.__dict__:
 #elattr(self.class_, self.MANAGER_ATTR)

 #ef install_descriptor(self, key, inst):
 #f key in (self.STATE_ATTR, self.MANAGER_ATTR):
 #aise KeyError(
 #%r: requested attribute name conflicts with "
 #instrumentation attribute of the same name." % key
 #
 #etattr(self.class_, key, inst)

 #ef uninstall_descriptor(self, key):
 #elattr(self.class_, key)

 #ef install_member(self, key, implementation):
 #f key in (self.STATE_ATTR, self.MANAGER_ATTR):
 #aise KeyError(
 #%r: requested attribute name conflicts with "
 #instrumentation attribute of the same name." % key
 #
 #elf.originals.setdefault(key, self.class_.__dict__.get(key, DEL_ATTR))
 #etattr(self.class_, key, implementation)

 #ef uninstall_member(self, key):
 #riginal = self.originals.pop(key, None)
 #f original is not DEL_ATTR:
 #etattr(self.class_, key, original)
 #lse:
 #elattr(self.class_, key)

 #ef instrument_collection_class(self, key, collection_class):
 #eturn collections.prepare_instrumentation(collection_class)

 #ef initialize_collection(self, key, state, factory):
 #ser_data = factory()
 #dapter = collections.CollectionAdapter(
 #elf.get_impl(key), state, user_data
 #
 #eturn adapter, user_data

 #ef is_instrumented(self, key, search=False):
 #f search:
 #eturn key in self
 #lse:
 #eturn key in self.local_attrs

 #ef get_impl(self, key):
 #eturn self[key].impl

 #property
 #ef attributes(self):
 #eturn iter(self.values())

    # InstanceState management

 #ef new_instance(self, state=None):
 #nstance = self.class_.__new__(self.class_)
 #f state is None:
 #tate = self._state_constructor(instance, self)
 #elf._state_setter(instance, state)
 #eturn instance

 #ef setup_instance(self, instance, state=None):
 #f state is None:
 #tate = self._state_constructor(instance, self)
 #elf._state_setter(instance, state)

 #ef teardown_instance(self, instance):
 #elattr(instance, self.STATE_ATTR)

 #ef _serialize(self, state, state_dict):
 #eturn _SerializeManager(state, state_dict)

 #ef _new_state_if_none(self, instance):
 #""Install a default InstanceState if none is present.

 # private convenience method used by the __init__ decorator.

 #""
 #f hasattr(instance, self.STATE_ATTR):
 #eturn False
 #lif self.class_ is not instance.__class__ and self.is_mapped:
            # this will create a new ClassManager for the
            # subclass, without a mapper.  This is likely a
            # user error situation but allow the object
            # to be constructed, so that it is usable
            # in a non-ORM context at least.
 #eturn self._subclass_manager(
 #nstance.__class__
 #._new_state_if_none(instance)
 #lse:
 #tate = self._state_constructor(instance, self)
 #elf._state_setter(instance, state)
 #eturn state

 #ef has_state(self, instance):
 #eturn hasattr(instance, self.STATE_ATTR)

 #ef has_parent(self, state, key, optimistic=False):
 #""TODO"""
 #eturn self.get_impl(key).hasparent(state, optimistic=optimistic)

 #ef __bool__(self):
 #""All ClassManagers are non-zero regardless of attribute state."""
 #eturn True

 #_nonzero__ = __bool__

 #ef __repr__(self):
 #eturn "<%s of %r at %x>" % (
 #elf.__class__.__name__,
 #elf.class_,
 #d(self),
 #


class _SerializeManager(object):
 #""Provide serialization of a :class:`.ClassManager`.

 #he :class:`.InstanceState` uses ``__init__()`` on serialize
 #nd ``__call__()`` on deserialize.

 #""

 #ef __init__(self, state, d):
 #elf.class_ = state.class_
 #anager = state.manager
 #anager.dispatch.pickle(state, d)

 #ef __call__(self, state, inst, state_dict):
 #tate.manager = manager = manager_of_class(self.class_)
 #f manager is None:
 #aise exc.UnmappedInstanceError(
 #nst,
 #Cannot deserialize object of type %r - "
 #no mapper() has "
 #been configured for this class within the current "
 #Python process!" % self.class_,
 #
 #lif manager.is_mapped and not manager.mapper.configured:
 #anager.mapper._check_configure()

        # setup _sa_instance_state ahead of time so that
        # unpickle events can access the object normally.
        # see [ticket:2362]
 #f inst is not None:
 #anager.setup_instance(inst, state)
 #anager.dispatch.unpickle(state, state_dict)


class InstrumentationFactory(object):
 #""Factory for new ClassManager instances."""

 #ef create_manager_for_cls(self, class_):
 #ssert class_ is not None
 #ssert manager_of_class(class_) is None

        # give a more complicated subclass
        # a chance to do what it wants here
 #anager, factory = self._locate_extended_factory(class_)

 #f factory is None:
 #actory = ClassManager
 #anager = factory(class_)

 #elf._check_conflicts(class_, factory)

 #anager.factory = factory

 #eturn manager

 #ef _locate_extended_factory(self, class_):
 #""Overridden by a subclass to do an extended lookup."""
 #eturn None, None

 #ef _check_conflicts(self, class_, factory):
 #""Overridden by a subclass to test for conflicting factories."""
 #eturn

 #ef unregister(self, class_):
 #anager = manager_of_class(class_)
 #anager.unregister()
 #elf.dispatch.class_uninstrument(class_)


# this attribute is replaced by sqlalchemy.ext.instrumentation
# when imported.
_instrumentation_factory = InstrumentationFactory()

# these attributes are replaced by sqlalchemy.ext.instrumentation
# when a non-standard InstrumentationManager class is first
# used to instrument a class.
instance_state = _default_state_getter = base.instance_state

instance_dict = _default_dict_getter = base.instance_dict

manager_of_class = _default_manager_getter = base.manager_of_class


def register_class(
 #lass_,
 #inalize=True,
 #apper=None,
 #egistry=None,
 #eclarative_scan=None,
 #xpired_attribute_loader=None,
 #nit_method=None,
):
 #""Register class instrumentation.

 #eturns the existing or newly created class manager.

 #""

 #anager = manager_of_class(class_)
 #f manager is None:
 #anager = _instrumentation_factory.create_manager_for_cls(class_)
 #anager._update_state(
 #apper=mapper,
 #egistry=registry,
 #eclarative_scan=declarative_scan,
 #xpired_attribute_loader=expired_attribute_loader,
 #nit_method=init_method,
 #inalize=finalize,
 #

 #eturn manager


def unregister_class(class_):
 #""Unregister class instrumentation."""

 #instrumentation_factory.unregister(class_)


def is_instrumented(instance, key):
 #""Return True if the given attribute on the given instance is
 #nstrumented by the attributes package.

 #his function may be used regardless of instrumentation
 #pplied directly to the class, i.e. no descriptors are required.

 #""
 #eturn manager_of_class(instance.__class__).is_instrumented(
 #ey, search=True
 #


def _generate_init(class_, class_manager, original_init):
 #""Build an __init__ decorator that triggers ClassManager events."""

    # TODO: we should use the ClassManager's notion of the
    # original '__init__' method, once ClassManager is fixed
    # to always reference that.

 #f original_init is None:
 #riginal_init = class_.__init__

    # Go through some effort here and don't change the user's __init__
    # calling signature, including the unlikely case that it has
    # a return value.
    # FIXME: need to juggle local names to avoid constructor argument
    # clashes.
 #unc_body = """\
def __init__(%(apply_pos)s):
 #ew_state = class_manager._new_state_if_none(%(self_arg)s)
 #f new_state:
 #eturn new_state._initialize_instance(%(apply_kw)s)
 #lse:
 #eturn original_init(%(apply_kw)s)
"""
 #unc_vars = util.format_argspec_init(original_init, grouped=False)
 #unc_text = func_body % func_vars

 #f util.py2k:
 #unc = getattr(original_init, "im_func", original_init)
 #unc_defaults = getattr(func, "func_defaults", None)
 #lse:
 #unc_defaults = getattr(original_init, "__defaults__", None)
 #unc_kw_defaults = getattr(original_init, "__kwdefaults__", None)

 #nv = locals().copy()
 #nv["__name__"] = __name__
 #xec(func_text, env)
 #_init__ = env["__init__"]
 #_init__.__doc__ = original_init.__doc__
 #_init__._sa_original_init = original_init

 #f func_defaults:
 #_init__.__defaults__ = func_defaults
 #f not util.py2k and func_kw_defaults:
 #_init__.__kwdefaults__ = func_kw_defaults

 #eturn __init__
