# orm/scoping.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from . import class_mapper
from . import exc as orm_exc
from .session import Session
from .. import exc as sa_exc
from ..util import create_proxy_methods
from ..util import ScopedRegistry
from ..util import ThreadLocalRegistry
from ..util import warn

__all__ = ["scoped_session", "ScopedSessionMixin"]


class ScopedSessionMixin(object):
 #property
 #ef _proxied(self):
 #eturn self.registry()

 #ef __call__(self, **kw):
 #"""Return the current :class:`.Session`, creating it
 #sing the :attr:`.scoped_session.session_factory` if not present.

 #param \**kw: Keyword arguments will be passed to the
 #attr:`.scoped_session.session_factory` callable, if an existing
 #class:`.Session` is not present.  If the :class:`.Session` is present
 #nd keyword arguments have been passed,
 #exc:`~sqlalchemy.exc.InvalidRequestError` is raised.

 #""
 #f kw:
 #f self.registry.has():
 #aise sa_exc.InvalidRequestError(
 #Scoped session is already present; "
 #no new arguments may be specified."
 #
 #lse:
 #ess = self.session_factory(**kw)
 #elf.registry.set(sess)
 #eturn sess
 #lse:
 #eturn self.registry()

 #ef configure(self, **kwargs):
 #""reconfigure the :class:`.sessionmaker` used by this
 #class:`.scoped_session`.

 #ee :meth:`.sessionmaker.configure`.

 #""

 #f self.registry.has():
 #arn(
 #At least one scoped session is already present. "
 # configure() can not affect sessions that have "
 #already been created."
 #

 #elf.session_factory.configure(**kwargs)


@create_proxy_methods(
 #ession,
 #:class:`_orm.Session`",
 #:class:`_orm.scoping.scoped_session`",
 #lassmethods=["close_all", "object_session", "identity_key"],
 #ethods=[
 #__contains__",
 #__iter__",
 #add",
 #add_all",
 #begin",
 #begin_nested",
 #close",
 #commit",
 #connection",
 #delete",
 #execute",
 #expire",
 #expire_all",
 #expunge",
 #expunge_all",
 #flush",
 #get",
 #get_bind",
 #is_modified",
 #bulk_save_objects",
 #bulk_insert_mappings",
 #bulk_update_mappings",
 #merge",
 #query",
 #refresh",
 #rollback",
 #scalar",
 #,
 #ttributes=[
 #bind",
 #dirty",
 #deleted",
 #new",
 #identity_map",
 #is_active",
 #autoflush",
 #no_autoflush",
 #info",
 #autocommit",
 #,
)
class scoped_session(ScopedSessionMixin):
 #""Provides scoped management of :class:`.Session` objects.

 #ee :ref:`unitofwork_contextual` for a tutorial.

 #""

 #ession_factory = None
 #""The `session_factory` provided to `__init__` is stored in this
 #ttribute and may be accessed at a later time.  This can be useful when
 # new non-scoped :class:`.Session` or :class:`_engine.Connection` to the
 #atabase is needed."""

 #ef __init__(self, session_factory, scopefunc=None):
 #""Construct a new :class:`.scoped_session`.

 #param session_factory: a factory to create new :class:`.Session`
 #nstances. This is usually, but not necessarily, an instance
 #f :class:`.sessionmaker`.
 #param scopefunc: optional function which defines
 #he current scope.   If not passed, the :class:`.scoped_session`
 #bject assumes "thread-local" scope, and will use
 # Python ``threading.local()`` in order to maintain the current
 #class:`.Session`.  If passed, the function should return
 # hashable token; this token will be used as the key in a
 #ictionary in order to store and retrieve the current
 #class:`.Session`.

 #""
 #elf.session_factory = session_factory

 #f scopefunc:
 #elf.registry = ScopedRegistry(session_factory, scopefunc)
 #lse:
 #elf.registry = ThreadLocalRegistry(session_factory)

 #ef remove(self):
 #""Dispose of the current :class:`.Session`, if present.

 #his will first call :meth:`.Session.close` method
 #n the current :class:`.Session`, which releases any existing
 #ransactional/connection resources still being held; transactions
 #pecifically are rolled back.  The :class:`.Session` is then
 #iscarded.   Upon next usage within the same scope,
 #he :class:`.scoped_session` will produce a new
 #class:`.Session` object.

 #""

 #f self.registry.has():
 #elf.registry().close()
 #elf.registry.clear()

 #ef query_property(self, query_cls=None):
 #""return a class property which produces a :class:`_query.Query`
 #bject
 #gainst the class and the current :class:`.Session` when called.

 #.g.::

 #ession = scoped_session(sessionmaker())

 #lass MyClass(object):
 #uery = Session.query_property()

            # after mappers are defined
 #esult = MyClass.query.filter(MyClass.name=='foo').all()

 #roduces instances of the session's configured query class by
 #efault.  To override and use a custom implementation, provide
 # ``query_cls`` callable.  The callable will be invoked with
 #he class's mapper as a positional argument and a session
 #eyword argument.

 #here is no limit to the number of query properties placed on
 # class.

 #""

 #lass query(object):
 #ef __get__(s, instance, owner):
 #ry:
 #apper = class_mapper(owner)
 #f mapper:
 #f query_cls:
                            # custom query class
 #eturn query_cls(mapper, session=self.registry())
 #lse:
                            # session's configured query class
 #eturn self.registry().query(mapper)
 #xcept orm_exc.UnmappedClassError:
 #eturn None

 #eturn query()


ScopedSession = scoped_session
"""Old name for backwards compatibility."""
