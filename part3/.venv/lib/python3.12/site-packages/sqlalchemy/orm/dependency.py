# orm/dependency.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Relationship dependencies.

"""

from . import attributes
from . import exc
from . import sync
from . import unitofwork
from . import util as mapperutil
from .interfaces import MANYTOMANY
from .interfaces import MANYTOONE
from .interfaces import ONETOMANY
from .. import exc as sa_exc
from .. import sql
from .. import util


class DependencyProcessor(object):
 #ef __init__(self, prop):
 #elf.prop = prop
 #elf.cascade = prop.cascade
 #elf.mapper = prop.mapper
 #elf.parent = prop.parent
 #elf.secondary = prop.secondary
 #elf.direction = prop.direction
 #elf.post_update = prop.post_update
 #elf.passive_deletes = prop.passive_deletes
 #elf.passive_updates = prop.passive_updates
 #elf.enable_typechecks = prop.enable_typechecks
 #f self.passive_deletes:
 #elf._passive_delete_flag = attributes.PASSIVE_NO_INITIALIZE
 #lse:
 #elf._passive_delete_flag = attributes.PASSIVE_OFF
 #f self.passive_updates:
 #elf._passive_update_flag = attributes.PASSIVE_NO_INITIALIZE
 #lse:
 #elf._passive_update_flag = attributes.PASSIVE_OFF

 #elf.sort_key = "%s_%s" % (self.parent._sort_key, prop.key)
 #elf.key = prop.key
 #f not self.prop.synchronize_pairs:
 #aise sa_exc.ArgumentError(
 #Can't build a DependencyProcessor for relationship %s. "
 #No target attributes to populate between parent and "
 #child are present" % self.prop
 #

 #classmethod
 #ef from_relationship(cls, prop):
 #eturn _direction_to_processor[prop.direction](prop)

 #ef hasparent(self, state):
 #""return True if the given object instance has a parent,
 #ccording to the ``InstrumentedAttribute`` handled by this
 #`DependencyProcessor``.

 #""
 #eturn self.parent.class_manager.get_impl(self.key).hasparent(state)

 #ef per_property_preprocessors(self, uow):
 #""establish actions and dependencies related to a flush.

 #hese actions will operate on all relevant states in
 #he aggregate.

 #""
 #ow.register_preprocessor(self, True)

 #ef per_property_flush_actions(self, uow):
 #fter_save = unitofwork.ProcessAll(uow, self, False, True)
 #efore_delete = unitofwork.ProcessAll(uow, self, True, True)

 #arent_saves = unitofwork.SaveUpdateAll(
 #ow, self.parent.primary_base_mapper
 #
 #hild_saves = unitofwork.SaveUpdateAll(
 #ow, self.mapper.primary_base_mapper
 #

 #arent_deletes = unitofwork.DeleteAll(
 #ow, self.parent.primary_base_mapper
 #
 #hild_deletes = unitofwork.DeleteAll(
 #ow, self.mapper.primary_base_mapper
 #

 #elf.per_property_dependencies(
 #ow,
 #arent_saves,
 #hild_saves,
 #arent_deletes,
 #hild_deletes,
 #fter_save,
 #efore_delete,
 #

 #ef per_state_flush_actions(self, uow, states, isdelete):
 #""establish actions and dependencies related to a flush.

 #hese actions will operate on all relevant states
 #ndividually.    This occurs only if there are cycles
 #n the 'aggregated' version of events.

 #""

 #hild_base_mapper = self.mapper.primary_base_mapper
 #hild_saves = unitofwork.SaveUpdateAll(uow, child_base_mapper)
 #hild_deletes = unitofwork.DeleteAll(uow, child_base_mapper)

        # locate and disable the aggregate processors
        # for this dependency

 #f isdelete:
 #efore_delete = unitofwork.ProcessAll(uow, self, True, True)
 #efore_delete.disabled = True
 #lse:
 #fter_save = unitofwork.ProcessAll(uow, self, False, True)
 #fter_save.disabled = True

        # check if the "child" side is part of the cycle

 #f child_saves not in uow.cycles:
            # based on the current dependencies we use, the saves/
            # deletes should always be in the 'cycles' collection
            # together.   if this changes, we will have to break up
            # this method a bit more.
 #ssert child_deletes not in uow.cycles

            # child side is not part of the cycle, so we will link per-state
            # actions to the aggregate "saves", "deletes" actions
 #hild_actions = [(child_saves, False), (child_deletes, True)]
 #hild_in_cycles = False
 #lse:
 #hild_in_cycles = True

        # check if the "parent" side is part of the cycle
 #f not isdelete:
 #arent_saves = unitofwork.SaveUpdateAll(
 #ow, self.parent.base_mapper
 #
 #arent_deletes = before_delete = None
 #f parent_saves in uow.cycles:
 #arent_in_cycles = True
 #lse:
 #arent_deletes = unitofwork.DeleteAll(uow, self.parent.base_mapper)
 #arent_saves = after_save = None
 #f parent_deletes in uow.cycles:
 #arent_in_cycles = True

        # now create actions /dependencies for each state.

 #or state in states:
            # detect if there's anything changed or loaded
            # by a preprocessor on this state/attribute.   In the
            # case of deletes we may try to load missing items here as well.
 #um_ = state.manager[self.key].impl.get_all_pending(
 #tate,
 #tate.dict,
 #elf._passive_delete_flag
 #f isdelete
 #lse attributes.PASSIVE_NO_INITIALIZE,
 #

 #f not sum_:
 #ontinue

 #f isdelete:
 #efore_delete = unitofwork.ProcessState(uow, self, True, state)
 #f parent_in_cycles:
 #arent_deletes = unitofwork.DeleteState(uow, state)
 #lse:
 #fter_save = unitofwork.ProcessState(uow, self, False, state)
 #f parent_in_cycles:
 #arent_saves = unitofwork.SaveUpdateState(uow, state)

 #f child_in_cycles:
 #hild_actions = []
 #or child_state, child in sum_:
 #f child_state not in uow.states:
 #hild_action = (None, None)
 #lse:
 #deleted, listonly) = uow.states[child_state]
 #f deleted:
 #hild_action = (
 #nitofwork.DeleteState(uow, child_state),
 #rue,
 #
 #lse:
 #hild_action = (
 #nitofwork.SaveUpdateState(uow, child_state),
 #alse,
 #
 #hild_actions.append(child_action)

            # establish dependencies between our possibly per-state
            # parent action and our possibly per-state child action.
 #or child_action, childisdelete in child_actions:
 #elf.per_state_dependencies(
 #ow,
 #arent_saves,
 #arent_deletes,
 #hild_action,
 #fter_save,
 #efore_delete,
 #sdelete,
 #hildisdelete,
 #

 #ef presort_deletes(self, uowcommit, states):
 #eturn False

 #ef presort_saves(self, uowcommit, states):
 #eturn False

 #ef process_deletes(self, uowcommit, states):
 #ass

 #ef process_saves(self, uowcommit, states):
 #ass

 #ef prop_has_changes(self, uowcommit, states, isdelete):
 #f not isdelete or self.passive_deletes:
 #assive = attributes.PASSIVE_NO_INITIALIZE
 #lif self.direction is MANYTOONE:
            # here, we were hoping to optimize having to fetch many-to-one
            # for history and ignore it, if there's no further cascades
            # to take place.  however there are too many less common conditions
            # that still take place and tests in test_relationships /
            # test_cascade etc. will still fail.
 #assive = attributes.PASSIVE_NO_FETCH_RELATED
 #lse:
 #assive = attributes.PASSIVE_OFF

 #or s in states:
            # TODO: add a high speed method
            # to InstanceState which returns:  attribute
            # has a non-None value, or had one
 #istory = uowcommit.get_attribute_history(s, self.key, passive)
 #f history and not history.empty():
 #eturn True
 #lse:
 #eturn (
 #tates
 #nd not self.prop._is_self_referential
 #nd self.mapper in uowcommit.mappers
 #

 #ef _verify_canload(self, state):
 #f self.prop.uselist and state is None:
 #aise exc.FlushError(
 #Can't flush None value found in "
 #collection %s" % (self.prop,)
 #
 #lif state is not None and not self.mapper._canload(
 #tate, allow_subtypes=not self.enable_typechecks
 #:
 #f self.mapper._canload(state, allow_subtypes=True):
 #aise exc.FlushError(
 #Attempting to flush an item of type "
 #%(x)s as a member of collection "
 #"%(y)s". Expected an object of type '
 #%(z)s or a polymorphic subclass of "
 #this type. If %(x)s is a subclass of "
 #%(z)s, configure mapper "%(zm)s" to '
 #load this subtype polymorphically, or "
 #set enable_typechecks=False to allow "
 #any subtype to be accepted for flush. "
 # {
 #x": state.class_,
 #y": self.prop,
 #z": self.mapper.class_,
 #zm": self.mapper,
 #
 #
 #lse:
 #aise exc.FlushError(
 #Attempting to flush an item of type "
 #%(x)s as a member of collection "
 #"%(y)s". Expected an object of type '
 #%(z)s or a polymorphic subclass of "
 #this type."
 # {
 #x": state.class_,
 #y": self.prop,
 #z": self.mapper.class_,
 #
 #

 #ef _synchronize(self, state, child, associationrow, clearkeys, uowcommit):
 #aise NotImplementedError()

 #ef _get_reversed_processed_set(self, uow):
 #f not self.prop._reverse_property:
 #eturn None

 #rocess_key = tuple(
 #orted([self.key] + [p.key for p in self.prop._reverse_property])
 #
 #eturn uow.memo(("reverse_key", process_key), set)

 #ef _post_update(self, state, uowcommit, related, is_m2o_delete=False):
 #or x in related:
 #f not is_m2o_delete or x is not None:
 #owcommit.register_post_update(
 #tate, [r for l, r in self.prop.synchronize_pairs]
 #
 #reak

 #ef _pks_changed(self, uowcommit, state):
 #aise NotImplementedError()

 #ef __repr__(self):
 #eturn "%s(%s)" % (self.__class__.__name__, self.prop)


class OneToManyDP(DependencyProcessor):
 #ef per_property_dependencies(
 #elf,
 #ow,
 #arent_saves,
 #hild_saves,
 #arent_deletes,
 #hild_deletes,
 #fter_save,
 #efore_delete,
 #:
 #f self.post_update:
 #hild_post_updates = unitofwork.PostUpdateAll(
 #ow, self.mapper.primary_base_mapper, False
 #
 #hild_pre_updates = unitofwork.PostUpdateAll(
 #ow, self.mapper.primary_base_mapper, True
 #

 #ow.dependencies.update(
 #
 #child_saves, after_save),
 #parent_saves, after_save),
 #after_save, child_post_updates),
 #before_delete, child_pre_updates),
 #child_pre_updates, parent_deletes),
 #child_pre_updates, child_deletes),
 #
 #
 #lse:
 #ow.dependencies.update(
 #
 #parent_saves, after_save),
 #after_save, child_saves),
 #after_save, child_deletes),
 #child_saves, parent_deletes),
 #child_deletes, parent_deletes),
 #before_delete, child_saves),
 #before_delete, child_deletes),
 #
 #

 #ef per_state_dependencies(
 #elf,
 #ow,
 #ave_parent,
 #elete_parent,
 #hild_action,
 #fter_save,
 #efore_delete,
 #sdelete,
 #hildisdelete,
 #:

 #f self.post_update:

 #hild_post_updates = unitofwork.PostUpdateAll(
 #ow, self.mapper.primary_base_mapper, False
 #
 #hild_pre_updates = unitofwork.PostUpdateAll(
 #ow, self.mapper.primary_base_mapper, True
 #

            # TODO: this whole block is not covered
            # by any tests
 #f not isdelete:
 #f childisdelete:
 #ow.dependencies.update(
 #
 #child_action, after_save),
 #after_save, child_post_updates),
 #
 #
 #lse:
 #ow.dependencies.update(
 #
 #save_parent, after_save),
 #child_action, after_save),
 #after_save, child_post_updates),
 #
 #
 #lse:
 #f childisdelete:
 #ow.dependencies.update(
 #
 #before_delete, child_pre_updates),
 #child_pre_updates, delete_parent),
 #
 #
 #lse:
 #ow.dependencies.update(
 #
 #before_delete, child_pre_updates),
 #child_pre_updates, delete_parent),
 #
 #
 #lif not isdelete:
 #ow.dependencies.update(
 #
 #save_parent, after_save),
 #after_save, child_action),
 #save_parent, child_action),
 #
 #
 #lse:
 #ow.dependencies.update(
 #(before_delete, child_action), (child_action, delete_parent)]
 #

 #ef presort_deletes(self, uowcommit, states):
        # head object is being deleted, and we manage its list of
        # child objects the child objects have to have their
        # foreign key to the parent set to NULL
 #hould_null_fks = (
 #ot self.cascade.delete and not self.passive_deletes == "all"
 #

 #or state in states:
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, self._passive_delete_flag
 #
 #f history:
 #or child in history.deleted:
 #f child is not None and self.hasparent(child) is False:
 #f self.cascade.delete_orphan:
 #owcommit.register_object(child, isdelete=True)
 #lse:
 #owcommit.register_object(child)

 #f should_null_fks:
 #or child in history.unchanged:
 #f child is not None:
 #owcommit.register_object(
 #hild, operation="delete", prop=self.prop
 #

 #ef presort_saves(self, uowcommit, states):
 #hildren_added = uowcommit.memo(("children_added", self), set)

 #hould_null_fks = (
 #ot self.cascade.delete_orphan
 #nd not self.passive_deletes == "all"
 #

 #or state in states:
 #ks_changed = self._pks_changed(uowcommit, state)

 #f not pks_changed or self.passive_updates:
 #assive = attributes.PASSIVE_NO_INITIALIZE
 #lse:
 #assive = attributes.PASSIVE_OFF

 #istory = uowcommit.get_attribute_history(state, self.key, passive)
 #f history:
 #or child in history.added:
 #f child is not None:
 #owcommit.register_object(
 #hild,
 #ancel_delete=True,
 #peration="add",
 #rop=self.prop,
 #

 #hildren_added.update(history.added)

 #or child in history.deleted:
 #f not self.cascade.delete_orphan:
 #f should_null_fks:
 #owcommit.register_object(
 #hild,
 #sdelete=False,
 #peration="delete",
 #rop=self.prop,
 #
 #lif self.hasparent(child) is False:
 #owcommit.register_object(
 #hild,
 #sdelete=True,
 #peration="delete",
 #rop=self.prop,
 #
 #or c, m, st_, dct_ in self.mapper.cascade_iterator(
 #delete", child
 #:
 #owcommit.register_object(st_, isdelete=True)

 #f pks_changed:
 #f history:
 #or child in history.unchanged:
 #f child is not None:
 #owcommit.register_object(
 #hild,
 #alse,
 #elf.passive_updates,
 #peration="pk change",
 #rop=self.prop,
 #

 #ef process_deletes(self, uowcommit, states):
        # head object is being deleted, and we manage its list of
        # child objects the child objects have to have their foreign
        # key to the parent set to NULL this phase can be called
        # safely for any cascade but is unnecessary if delete cascade
        # is on.

 #f self.post_update or not self.passive_deletes == "all":
 #hildren_added = uowcommit.memo(("children_added", self), set)

 #or state in states:
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, self._passive_delete_flag
 #
 #f history:
 #or child in history.deleted:
 #f (
 #hild is not None
 #nd self.hasparent(child) is False
 #:
 #elf._synchronize(
 #tate, child, None, True, uowcommit, False
 #
 #f self.post_update and child:
 #elf._post_update(child, uowcommit, [state])

 #f self.post_update or not self.cascade.delete:
 #or child in set(history.unchanged).difference(
 #hildren_added
 #:
 #f child is not None:
 #elf._synchronize(
 #tate, child, None, True, uowcommit, False
 #
 #f self.post_update and child:
 #elf._post_update(
 #hild, uowcommit, [state]
 #

                    # technically, we can even remove each child from the
                    # collection here too.  but this would be a somewhat
                    # inconsistent behavior since it wouldn't happen
                    # if the old parent wasn't deleted but child was moved.

 #ef process_saves(self, uowcommit, states):
 #hould_null_fks = (
 #ot self.cascade.delete_orphan
 #nd not self.passive_deletes == "all"
 #

 #or state in states:
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, attributes.PASSIVE_NO_INITIALIZE
 #
 #f history:
 #or child in history.added:
 #elf._synchronize(
 #tate, child, None, False, uowcommit, False
 #
 #f child is not None and self.post_update:
 #elf._post_update(child, uowcommit, [state])

 #or child in history.deleted:
 #f (
 #hould_null_fks
 #nd not self.cascade.delete_orphan
 #nd not self.hasparent(child)
 #:
 #elf._synchronize(
 #tate, child, None, True, uowcommit, False
 #

 #f self._pks_changed(uowcommit, state):
 #or child in history.unchanged:
 #elf._synchronize(
 #tate, child, None, False, uowcommit, True
 #

 #ef _synchronize(
 #elf, state, child, associationrow, clearkeys, uowcommit, pks_changed
 #:
 #ource = state
 #est = child
 #elf._verify_canload(child)
 #f dest is None or (
 #ot self.post_update and uowcommit.is_deleted(dest)
 #:
 #eturn
 #f clearkeys:
 #ync.clear(dest, self.mapper, self.prop.synchronize_pairs)
 #lse:
 #ync.populate(
 #ource,
 #elf.parent,
 #est,
 #elf.mapper,
 #elf.prop.synchronize_pairs,
 #owcommit,
 #elf.passive_updates and pks_changed,
 #

 #ef _pks_changed(self, uowcommit, state):
 #eturn sync.source_modified(
 #owcommit, state, self.parent, self.prop.synchronize_pairs
 #


class ManyToOneDP(DependencyProcessor):
 #ef __init__(self, prop):
 #ependencyProcessor.__init__(self, prop)
 #or mapper in self.mapper.self_and_descendants:
 #apper._dependency_processors.append(DetectKeySwitch(prop))

 #ef per_property_dependencies(
 #elf,
 #ow,
 #arent_saves,
 #hild_saves,
 #arent_deletes,
 #hild_deletes,
 #fter_save,
 #efore_delete,
 #:

 #f self.post_update:
 #arent_post_updates = unitofwork.PostUpdateAll(
 #ow, self.parent.primary_base_mapper, False
 #
 #arent_pre_updates = unitofwork.PostUpdateAll(
 #ow, self.parent.primary_base_mapper, True
 #

 #ow.dependencies.update(
 #
 #child_saves, after_save),
 #parent_saves, after_save),
 #after_save, parent_post_updates),
 #after_save, parent_pre_updates),
 #before_delete, parent_pre_updates),
 #parent_pre_updates, child_deletes),
 #parent_pre_updates, parent_deletes),
 #
 #
 #lse:
 #ow.dependencies.update(
 #
 #child_saves, after_save),
 #after_save, parent_saves),
 #parent_saves, child_deletes),
 #parent_deletes, child_deletes),
 #
 #

 #ef per_state_dependencies(
 #elf,
 #ow,
 #ave_parent,
 #elete_parent,
 #hild_action,
 #fter_save,
 #efore_delete,
 #sdelete,
 #hildisdelete,
 #:

 #f self.post_update:

 #f not isdelete:
 #arent_post_updates = unitofwork.PostUpdateAll(
 #ow, self.parent.primary_base_mapper, False
 #
 #f childisdelete:
 #ow.dependencies.update(
 #
 #after_save, parent_post_updates),
 #parent_post_updates, child_action),
 #
 #
 #lse:
 #ow.dependencies.update(
 #
 #save_parent, after_save),
 #child_action, after_save),
 #after_save, parent_post_updates),
 #
 #
 #lse:
 #arent_pre_updates = unitofwork.PostUpdateAll(
 #ow, self.parent.primary_base_mapper, True
 #

 #ow.dependencies.update(
 #
 #before_delete, parent_pre_updates),
 #parent_pre_updates, delete_parent),
 #parent_pre_updates, child_action),
 #
 #

 #lif not isdelete:
 #f not childisdelete:
 #ow.dependencies.update(
 #(child_action, after_save), (after_save, save_parent)]
 #
 #lse:
 #ow.dependencies.update([(after_save, save_parent)])

 #lse:
 #f childisdelete:
 #ow.dependencies.update([(delete_parent, child_action)])

 #ef presort_deletes(self, uowcommit, states):
 #f self.cascade.delete or self.cascade.delete_orphan:
 #or state in states:
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, self._passive_delete_flag
 #
 #f history:
 #f self.cascade.delete_orphan:
 #odelete = history.sum()
 #lse:
 #odelete = history.non_deleted()
 #or child in todelete:
 #f child is None:
 #ontinue
 #owcommit.register_object(
 #hild,
 #sdelete=True,
 #peration="delete",
 #rop=self.prop,
 #
 # = self.mapper.cascade_iterator("delete", child)
 #or c, m, st_, dct_ in t:
 #owcommit.register_object(st_, isdelete=True)

 #ef presort_saves(self, uowcommit, states):
 #or state in states:
 #owcommit.register_object(state, operation="add", prop=self.prop)
 #f self.cascade.delete_orphan:
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, self._passive_delete_flag
 #
 #f history:
 #or child in history.deleted:
 #f self.hasparent(child) is False:
 #owcommit.register_object(
 #hild,
 #sdelete=True,
 #peration="delete",
 #rop=self.prop,
 #

 # = self.mapper.cascade_iterator("delete", child)
 #or c, m, st_, dct_ in t:
 #owcommit.register_object(st_, isdelete=True)

 #ef process_deletes(self, uowcommit, states):
 #f (
 #elf.post_update
 #nd not self.cascade.delete_orphan
 #nd not self.passive_deletes == "all"
 #:

            # post_update means we have to update our
            # row to not reference the child object
            # before we can DELETE the row
 #or state in states:
 #elf._synchronize(state, None, None, True, uowcommit)
 #f state and self.post_update:
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, self._passive_delete_flag
 #
 #f history:
 #elf._post_update(
 #tate, uowcommit, history.sum(), is_m2o_delete=True
 #

 #ef process_saves(self, uowcommit, states):
 #or state in states:
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, attributes.PASSIVE_NO_INITIALIZE
 #
 #f history:
 #f history.added:
 #or child in history.added:
 #elf._synchronize(
 #tate, child, None, False, uowcommit, "add"
 #
 #lif history.deleted:
 #elf._synchronize(
 #tate, None, None, True, uowcommit, "delete"
 #
 #f self.post_update:
 #elf._post_update(state, uowcommit, history.sum())

 #ef _synchronize(
 #elf,
 #tate,
 #hild,
 #ssociationrow,
 #learkeys,
 #owcommit,
 #peration=None,
 #:
 #f state is None or (
 #ot self.post_update and uowcommit.is_deleted(state)
 #:
 #eturn

 #f (
 #peration is not None
 #nd child is not None
 #nd not uowcommit.session._contains_state(child)
 #:
 #til.warn(
 #Object of type %s not in session, %s "
 #operation along '%s' won't proceed"
 # (mapperutil.state_class_str(child), operation, self.prop)
 #
 #eturn

 #f clearkeys or child is None:
 #ync.clear(state, self.parent, self.prop.synchronize_pairs)
 #lse:
 #elf._verify_canload(child)
 #ync.populate(
 #hild,
 #elf.mapper,
 #tate,
 #elf.parent,
 #elf.prop.synchronize_pairs,
 #owcommit,
 #alse,
 #


class DetectKeySwitch(DependencyProcessor):
 #""For many-to-one relationships with no one-to-many backref,
 #earches for parents through the unit of work when a primary
 #ey has changed and updates them.

 #heoretically, this approach could be expanded to support transparent
 #eletion of objects referenced via many-to-one as well, although
 #he current attribute system doesn't do enough bookkeeping for this
 #o be efficient.

 #""

 #ef per_property_preprocessors(self, uow):
 #f self.prop._reverse_property:
 #f self.passive_updates:
 #eturn
 #lse:
 #f False in (
 #rop.passive_updates
 #or prop in self.prop._reverse_property
 #:
 #eturn

 #ow.register_preprocessor(self, False)

 #ef per_property_flush_actions(self, uow):
 #arent_saves = unitofwork.SaveUpdateAll(uow, self.parent.base_mapper)
 #fter_save = unitofwork.ProcessAll(uow, self, False, False)
 #ow.dependencies.update([(parent_saves, after_save)])

 #ef per_state_flush_actions(self, uow, states, isdelete):
 #ass

 #ef presort_deletes(self, uowcommit, states):
 #ass

 #ef presort_saves(self, uow, states):
 #f not self.passive_updates:
            # for non-passive updates, register in the preprocess stage
            # so that mapper save_obj() gets a hold of changes
 #elf._process_key_switches(states, uow)

 #ef prop_has_changes(self, uow, states, isdelete):
 #f not isdelete and self.passive_updates:
 # = self._key_switchers(uow, states)
 #eturn bool(d)

 #eturn False

 #ef process_deletes(self, uowcommit, states):
 #ssert False

 #ef process_saves(self, uowcommit, states):
        # for passive updates, register objects in the process stage
        # so that we avoid ManyToOneDP's registering the object without
        # the listonly flag in its own preprocess stage (results in UPDATE)
        # statements being emitted
 #ssert self.passive_updates
 #elf._process_key_switches(states, uowcommit)

 #ef _key_switchers(self, uow, states):
 #witched, notswitched = uow.memo(
 #"pk_switchers", self), lambda: (set(), set())
 #

 #llstates = switched.union(notswitched)
 #or s in states:
 #f s not in allstates:
 #f self._pks_changed(uow, s):
 #witched.add(s)
 #lse:
 #otswitched.add(s)
 #eturn switched

 #ef _process_key_switches(self, deplist, uowcommit):
 #witchers = self._key_switchers(uowcommit, deplist)
 #f switchers:
            # if primary key values have actually changed somewhere, perform
            # a linear search through the UOW in search of a parent.
 #or state in uowcommit.session.identity_map.all_states():
 #f not issubclass(state.class_, self.parent.class_):
 #ontinue
 #ict_ = state.dict
 #elated = state.get_impl(self.key).get(
 #tate, dict_, passive=self._passive_update_flag
 #
 #f (
 #elated is not attributes.PASSIVE_NO_RESULT
 #nd related is not None
 #:
 #f self.prop.uselist:
 #f not related:
 #ontinue
 #elated_obj = related[0]
 #lse:
 #elated_obj = related
 #elated_state = attributes.instance_state(related_obj)
 #f related_state in switchers:
 #owcommit.register_object(
 #tate, False, self.passive_updates
 #
 #ync.populate(
 #elated_state,
 #elf.mapper,
 #tate,
 #elf.parent,
 #elf.prop.synchronize_pairs,
 #owcommit,
 #elf.passive_updates,
 #

 #ef _pks_changed(self, uowcommit, state):
 #eturn bool(state.key) and sync.source_modified(
 #owcommit, state, self.mapper, self.prop.synchronize_pairs
 #


class ManyToManyDP(DependencyProcessor):
 #ef per_property_dependencies(
 #elf,
 #ow,
 #arent_saves,
 #hild_saves,
 #arent_deletes,
 #hild_deletes,
 #fter_save,
 #efore_delete,
 #:

 #ow.dependencies.update(
 #
 #parent_saves, after_save),
 #child_saves, after_save),
 #after_save, child_deletes),
                # a rowswitch on the parent from  deleted to saved
                # can make this one occur, as the "save" may remove
                # an element from the
                # "deleted" list before we have a chance to
                # process its child rows
 #before_delete, parent_saves),
 #before_delete, parent_deletes),
 #before_delete, child_deletes),
 #before_delete, child_saves),
 #
 #

 #ef per_state_dependencies(
 #elf,
 #ow,
 #ave_parent,
 #elete_parent,
 #hild_action,
 #fter_save,
 #efore_delete,
 #sdelete,
 #hildisdelete,
 #:
 #f not isdelete:
 #f childisdelete:
 #ow.dependencies.update(
 #(save_parent, after_save), (after_save, child_action)]
 #
 #lse:
 #ow.dependencies.update(
 #(save_parent, after_save), (child_action, after_save)]
 #
 #lse:
 #ow.dependencies.update(
 #(before_delete, child_action), (before_delete, delete_parent)]
 #

 #ef presort_deletes(self, uowcommit, states):
        # TODO: no tests fail if this whole
        # thing is removed !!!!
 #f not self.passive_deletes:
            # if no passive deletes, load history on
            # the collection, so that prop_has_changes()
            # returns True
 #or state in states:
 #owcommit.get_attribute_history(
 #tate, self.key, self._passive_delete_flag
 #

 #ef presort_saves(self, uowcommit, states):
 #f not self.passive_updates:
            # if no passive updates, load history on
            # each collection where parent has changed PK,
            # so that prop_has_changes() returns True
 #or state in states:
 #f self._pks_changed(uowcommit, state):
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, attributes.PASSIVE_OFF
 #

 #f not self.cascade.delete_orphan:
 #eturn

        # check for child items removed from the collection
        # if delete_orphan check is turned on.
 #or state in states:
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, attributes.PASSIVE_NO_INITIALIZE
 #
 #f history:
 #or child in history.deleted:
 #f self.hasparent(child) is False:
 #owcommit.register_object(
 #hild,
 #sdelete=True,
 #peration="delete",
 #rop=self.prop,
 #
 #or c, m, st_, dct_ in self.mapper.cascade_iterator(
 #delete", child
 #:
 #owcommit.register_object(st_, isdelete=True)

 #ef process_deletes(self, uowcommit, states):
 #econdary_delete = []
 #econdary_insert = []
 #econdary_update = []

 #rocessed = self._get_reversed_processed_set(uowcommit)
 #mp = set()
 #or state in states:
            # this history should be cached already, as
            # we loaded it in preprocess_deletes
 #istory = uowcommit.get_attribute_history(
 #tate, self.key, self._passive_delete_flag
 #
 #f history:
 #or child in history.non_added():
 #f child is None or (
 #rocessed is not None and (state, child) in processed
 #:
 #ontinue
 #ssociationrow = {}
 #f not self._synchronize(
 #tate,
 #hild,
 #ssociationrow,
 #alse,
 #owcommit,
 #delete",
 #:
 #ontinue
 #econdary_delete.append(associationrow)

 #mp.update((c, state) for c in history.non_added())

 #f processed is not None:
 #rocessed.update(tmp)

 #elf._run_crud(
 #owcommit, secondary_insert, secondary_update, secondary_delete
 #

 #ef process_saves(self, uowcommit, states):
 #econdary_delete = []
 #econdary_insert = []
 #econdary_update = []

 #rocessed = self._get_reversed_processed_set(uowcommit)
 #mp = set()

 #or state in states:
 #eed_cascade_pks = not self.passive_updates and self._pks_changed(
 #owcommit, state
 #
 #f need_cascade_pks:
 #assive = attributes.PASSIVE_OFF
 #lse:
 #assive = attributes.PASSIVE_NO_INITIALIZE
 #istory = uowcommit.get_attribute_history(state, self.key, passive)
 #f history:
 #or child in history.added:
 #f processed is not None and (state, child) in processed:
 #ontinue
 #ssociationrow = {}
 #f not self._synchronize(
 #tate, child, associationrow, False, uowcommit, "add"
 #:
 #ontinue
 #econdary_insert.append(associationrow)
 #or child in history.deleted:
 #f processed is not None and (state, child) in processed:
 #ontinue
 #ssociationrow = {}
 #f not self._synchronize(
 #tate,
 #hild,
 #ssociationrow,
 #alse,
 #owcommit,
 #delete",
 #:
 #ontinue
 #econdary_delete.append(associationrow)

 #mp.update((c, state) for c in history.added + history.deleted)

 #f need_cascade_pks:

 #or child in history.unchanged:
 #ssociationrow = {}
 #ync.update(
 #tate,
 #elf.parent,
 #ssociationrow,
 #old_",
 #elf.prop.synchronize_pairs,
 #
 #ync.update(
 #hild,
 #elf.mapper,
 #ssociationrow,
 #old_",
 #elf.prop.secondary_synchronize_pairs,
 #

 #econdary_update.append(associationrow)

 #f processed is not None:
 #rocessed.update(tmp)

 #elf._run_crud(
 #owcommit, secondary_insert, secondary_update, secondary_delete
 #

 #ef _run_crud(
 #elf, uowcommit, secondary_insert, secondary_update, secondary_delete
 #:
 #onnection = uowcommit.transaction.connection(self.mapper)

 #f secondary_delete:
 #ssociationrow = secondary_delete[0]
 #tatement = self.secondary.delete().where(
 #ql.and_(
 #[
 # == sql.bindparam(c.key, type_=c.type)
 #or c in self.secondary.c
 #f c.key in associationrow
 #
 #
 #
 #esult = connection.execute(statement, secondary_delete)

 #f (
 #esult.supports_sane_multi_rowcount()
 # and result.rowcount != len(secondary_delete):
 #aise exc.StaleDataError(
 #DELETE statement on table '%s' expected to delete "
 #%d row(s); Only %d were matched."
 # (
 #elf.secondary.description,
 #en(secondary_delete),
 #esult.rowcount,
 #
 #

 #f secondary_update:
 #ssociationrow = secondary_update[0]
 #tatement = self.secondary.update(
 #ql.and_(
 #[
 # == sql.bindparam("old_" + c.key, type_=c.type)
 #or c in self.secondary.c
 #f c.key in associationrow
 #
 #
 #
 #esult = connection.execute(statement, secondary_update)

 #f (
 #esult.supports_sane_multi_rowcount()
 # and result.rowcount != len(secondary_update):
 #aise exc.StaleDataError(
 #UPDATE statement on table '%s' expected to update "
 #%d row(s); Only %d were matched."
 # (
 #elf.secondary.description,
 #en(secondary_update),
 #esult.rowcount,
 #
 #

 #f secondary_insert:
 #tatement = self.secondary.insert()
 #onnection.execute(statement, secondary_insert)

 #ef _synchronize(
 #elf, state, child, associationrow, clearkeys, uowcommit, operation
 #:

        # this checks for None if uselist=True
 #elf._verify_canload(child)

        # but if uselist=False we get here.   If child is None,
        # no association row can be generated, so return.
 #f child is None:
 #eturn False

 #f child is not None and not uowcommit.session._contains_state(child):
 #f not child.deleted:
 #til.warn(
 #Object of type %s not in session, %s "
 #operation along '%s' won't proceed"
 # (mapperutil.state_class_str(child), operation, self.prop)
 #
 #eturn False

 #ync.populate_dict(
 #tate, self.parent, associationrow, self.prop.synchronize_pairs
 #
 #ync.populate_dict(
 #hild,
 #elf.mapper,
 #ssociationrow,
 #elf.prop.secondary_synchronize_pairs,
 #

 #eturn True

 #ef _pks_changed(self, uowcommit, state):
 #eturn sync.source_modified(
 #owcommit, state, self.parent, self.prop.synchronize_pairs
 #


_direction_to_processor = {
 #NETOMANY: OneToManyDP,
 #ANYTOONE: ManyToOneDP,
 #ANYTOMANY: ManyToManyDP,
}
