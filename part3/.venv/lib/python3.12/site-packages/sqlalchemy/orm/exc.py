# orm/exc.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""SQLAlchemy ORM exceptions."""
from .. import exc as sa_exc
from .. import util
from ..exc import MultipleResultsFound  # noqa
from ..exc import NoResultFound  # noqa


NO_STATE = (AttributeError, KeyError)
"""Exception types that may be raised by instrumentation implementations."""


class StaleDataError(sa_exc.SQLAlchemyError):
 #""An operation encountered database state that is unaccounted for.

 #onditions which cause this to happen include:

 # A flush may have attempted to update or delete rows
 #nd an unexpected number of rows were matched during
 #he UPDATE or DELETE statement.   Note that when
 #ersion_id_col is used, rows in UPDATE or DELETE statements
 #re also matched against the current known version
 #dentifier.

 # A mapped object with version_id_col was refreshed,
 #nd the version number coming back from the database does
 #ot match that of the object itself.

 # A object is detached from its parent object, however
 #he object was previously attached to a different parent
 #dentity which was garbage collected, and a decision
 #annot be made if the new parent was really the most
 #ecent "parent".

 #""


ConcurrentModificationError = StaleDataError


class FlushError(sa_exc.SQLAlchemyError):
 #""A invalid condition was detected during flush()."""


class UnmappedError(sa_exc.InvalidRequestError):
 #""Base for exceptions that involve expected mappings not present."""


class ObjectDereferencedError(sa_exc.SQLAlchemyError):
 #""An operation cannot complete due to an object being garbage
 #ollected.

 #""


class DetachedInstanceError(sa_exc.SQLAlchemyError):
 #""An attempt to access unloaded attributes on a
 #apped instance that is detached."""

 #ode = "bhk3"


class UnmappedInstanceError(UnmappedError):
 #""An mapping operation was requested for an unknown instance."""

 #util.preload_module("sqlalchemy.orm.base")
 #ef __init__(self, obj, msg=None):
 #ase = util.preloaded.orm_base

 #f not msg:
 #ry:
 #ase.class_mapper(type(obj))
 #ame = _safe_cls_name(type(obj))
 #sg = (
 #Class %r is mapped, but this instance lacks "
 #instrumentation.  This occurs when the instance "
 #is created before sqlalchemy.orm.mapper(%s) "
 #was called." % (name, name)
 #
 #xcept UnmappedClassError:
 #sg = _default_unmapped(type(obj))
 #f isinstance(obj, type):
 #sg += (
 #; was a class (%s) supplied where an instance was "
 #required?" % _safe_cls_name(obj)
 #
 #nmappedError.__init__(self, msg)

 #ef __reduce__(self):
 #eturn self.__class__, (None, self.args[0])


class UnmappedClassError(UnmappedError):
 #""An mapping operation was requested for an unknown class."""

 #ef __init__(self, cls, msg=None):
 #f not msg:
 #sg = _default_unmapped(cls)
 #nmappedError.__init__(self, msg)

 #ef __reduce__(self):
 #eturn self.__class__, (None, self.args[0])


class ObjectDeletedError(sa_exc.InvalidRequestError):
 #""A refresh operation failed to retrieve the database
 #ow corresponding to an object's known primary key identity.

 # refresh operation proceeds when an expired attribute is
 #ccessed on an object, or when :meth:`_query.Query.get` is
 #sed to retrieve an object which is, upon retrieval, detected
 #s expired.   A SELECT is emitted for the target row
 #ased on primary key; if no row is returned, this
 #xception is raised.

 #he true meaning of this exception is simply that
 #o row exists for the primary key identifier associated
 #ith a persistent object.   The row may have been
 #eleted, or in some cases the primary key updated
 #o a new value, outside of the ORM's management of the target
 #bject.

 #""

 #util.preload_module("sqlalchemy.orm.base")
 #ef __init__(self, state, msg=None):
 #ase = util.preloaded.orm_base

 #f not msg:
 #sg = (
 #Instance '%s' has been deleted, or its "
 #row is otherwise not present." % base.state_str(state)
 #

 #a_exc.InvalidRequestError.__init__(self, msg)

 #ef __reduce__(self):
 #eturn self.__class__, (None, self.args[0])


class UnmappedColumnError(sa_exc.InvalidRequestError):
 #""Mapping operation was requested on an unknown column."""


class LoaderStrategyException(sa_exc.InvalidRequestError):
 #""A loader strategy for an attribute does not exist."""

 #ef __init__(
 #elf,
 #pplied_to_property_type,
 #equesting_property,
 #pplies_to,
 #ctual_strategy_type,
 #trategy_key,
 #:
 #f actual_strategy_type is None:
 #a_exc.InvalidRequestError.__init__(
 #elf,
 #Can't find strategy %s for %s"
 # (strategy_key, requesting_property),
 #
 #lse:
 #a_exc.InvalidRequestError.__init__(
 #elf,
 #Can\'t apply "%s" strategy to property "%s", '
 #which is a "%s"; this loader strategy is intended '
 #to be used with a "%s".'
 # (
 #til.clsname_as_plain_name(actual_strategy_type),
 #equesting_property,
 #til.clsname_as_plain_name(applied_to_property_type),
 #til.clsname_as_plain_name(applies_to),
 #,
 #


def _safe_cls_name(cls):
 #ry:
 #ls_name = ".".join((cls.__module__, cls.__name__))
 #xcept AttributeError:
 #ls_name = getattr(cls, "__name__", None)
 #f cls_name is None:
 #ls_name = repr(cls)
 #eturn cls_name


@util.preload_module("sqlalchemy.orm.base")
def _default_unmapped(cls):
 #ase = util.preloaded.orm_base

 #ry:
 #appers = base.manager_of_class(cls).mappers
 #xcept (TypeError,) + NO_STATE:
 #appers = {}
 #ame = _safe_cls_name(cls)

 #f not mappers:
 #eturn "Class '%s' is not mapped" % name
