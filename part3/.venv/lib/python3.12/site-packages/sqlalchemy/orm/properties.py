# orm/properties.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""MapperProperty implementations.

This is a private module which defines the behavior of individual ORM-
mapped attributes.

"""
from __future__ import absolute_import

from . import attributes
from .descriptor_props import CompositeProperty
from .descriptor_props import ConcreteInheritedProperty
from .descriptor_props import SynonymProperty
from .interfaces import PropComparator
from .interfaces import StrategizedProperty
from .relationships import RelationshipProperty
from .util import _orm_full_deannotate
from .. import log
from .. import util
from ..sql import coercions
from ..sql import roles


__all__ = [
 #ColumnProperty",
 #CompositeProperty",
 #ConcreteInheritedProperty",
 #RelationshipProperty",
 #SynonymProperty",
]


@log.class_logger
class ColumnProperty(StrategizedProperty):
 #""Describes an object attribute that corresponds to a table column.

 #ublic constructor is the :func:`_orm.column_property` function.

 #""

 #trategy_wildcard_key = "column"
 #nherit_cache = True

 #_slots__ = (
 #_orig_columns",
 #columns",
 #group",
 #deferred",
 #instrument",
 #comparator_factory",
 #descriptor",
 #active_history",
 #expire_on_flush",
 #info",
 #doc",
 #strategy_key",
 #_creation_order",
 #_is_polymorphic_discriminator",
 #_mapped_by_synonym",
 #_deferred_column_loader",
 #_raise_column_loader",
 #_renders_in_subqueries",
 #raiseload",
 #

 #ef __init__(self, *columns, **kwargs):
 #"""Provide a column-level property for use with a mapping.

 #olumn-based properties can normally be applied to the mapper's
 #`properties`` dictionary using the :class:`_schema.Column`
 #lement directly.
 #se this function when the given column is not directly present within
 #he mapper's selectable; examples include SQL expressions, functions,
 #nd scalar SELECT queries.

 #he :func:`_orm.column_property` function returns an instance of
 #class:`.ColumnProperty`.

 #olumns that aren't present in the mapper's selectable won't be
 #ersisted by the mapper and are effectively "read-only" attributes.

 #param \*cols:
 #ist of Column objects to be mapped.

 #param active_history=False:
 #hen ``True``, indicates that the "previous" value for a
 #calar attribute should be loaded when replaced, if not
 #lready loaded. Normally, history tracking logic for
 #imple non-primary-key scalar values only needs to be
 #ware of the "new" value in order to perform a flush. This
 #lag is available for applications that make use of
 #func:`.attributes.get_history` or :meth:`.Session.is_modified`
 #hich also need to know
 #he "previous" value of the attribute.

 #param comparator_factory: a class which extends
 #class:`.ColumnProperty.Comparator` which provides custom SQL
 #lause generation for comparison operations.

 #param group:
 # group name for this property when marked as deferred.

 #param deferred:
 #hen True, the column property is "deferred", meaning that
 #t does not load immediately, and is instead loaded when the
 #ttribute is first accessed on an instance.  See also
 #func:`~sqlalchemy.orm.deferred`.

 #param doc:
 #ptional string that will be applied as the doc on the
 #lass-bound descriptor.

 #param expire_on_flush=True:
 #isable expiry on flush.   A column_property() which refers
 #o a SQL expression (and not a single table-bound column)
 #s considered to be a "read only" property; populating it
 #as no effect on the state of data, and it can only return
 #atabase state.   For this reason a column_property()'s value
 #s expired whenever the parent object is involved in a
 #lush, that is, has any kind of "dirty" state within a flush.
 #etting this parameter to ``False`` will have the effect of
 #eaving any existing value present after the flush proceeds.
 #ote however that the :class:`.Session` with default expiration
 #ettings still expires
 #ll attributes after a :meth:`.Session.commit` call, however.

 #param info: Optional data dictionary which will be populated into the
 #attr:`.MapperProperty.info` attribute of this object.

 #param raiseload: if True, indicates the column should raise an error
 #hen undeferred, rather than loading the value.  This can be
 #ltered at query time by using the :func:`.deferred` option with
 #aiseload=False.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`deferred_raiseload`

 #. seealso::

 #ref:`column_property_options` - to map columns while including
 #apping options

 #ref:`mapper_column_property_sql_expressions` - to map SQL
 #xpressions

 #""
 #uper(ColumnProperty, self).__init__()
 #elf._orig_columns = [
 #oercions.expect(roles.LabeledColumnExprRole, c) for c in columns
 #
 #elf.columns = [
 #oercions.expect(
 #oles.LabeledColumnExprRole, _orm_full_deannotate(c)
 #
 #or c in columns
 #
 #elf.group = kwargs.pop("group", None)
 #elf.deferred = kwargs.pop("deferred", False)
 #elf.raiseload = kwargs.pop("raiseload", False)
 #elf.instrument = kwargs.pop("_instrument", True)
 #elf.comparator_factory = kwargs.pop(
 #comparator_factory", self.__class__.Comparator
 #
 #elf.descriptor = kwargs.pop("descriptor", None)
 #elf.active_history = kwargs.pop("active_history", False)
 #elf.expire_on_flush = kwargs.pop("expire_on_flush", True)

 #f "info" in kwargs:
 #elf.info = kwargs.pop("info")

 #f "doc" in kwargs:
 #elf.doc = kwargs.pop("doc")
 #lse:
 #or col in reversed(self.columns):
 #oc = getattr(col, "doc", None)
 #f doc is not None:
 #elf.doc = doc
 #reak
 #lse:
 #elf.doc = None

 #f kwargs:
 #aise TypeError(
 #%s received unexpected keyword argument(s): %s"
 # (self.__class__.__name__, ", ".join(sorted(kwargs.keys())))
 #

 #til.set_creation_order(self)

 #elf.strategy_key = (
 #"deferred", self.deferred),
 #"instrument", self.instrument),
 #
 #f self.raiseload:
 #elf.strategy_key += (("raiseload", True),)

 #ef _memoized_attr__renders_in_subqueries(self):
 #eturn ("deferred", True) not in self.strategy_key or (
 #elf not in self.parent._readonly_props
 #

 #util.preload_module("sqlalchemy.orm.state", "sqlalchemy.orm.strategies")
 #ef _memoized_attr__deferred_column_loader(self):
 #tate = util.preloaded.orm_state
 #trategies = util.preloaded.orm_strategies
 #eturn state.InstanceState._instance_level_callable_processor(
 #elf.parent.class_manager,
 #trategies.LoadDeferredColumns(self.key),
 #elf.key,
 #

 #util.preload_module("sqlalchemy.orm.state", "sqlalchemy.orm.strategies")
 #ef _memoized_attr__raise_column_loader(self):
 #tate = util.preloaded.orm_state
 #trategies = util.preloaded.orm_strategies
 #eturn state.InstanceState._instance_level_callable_processor(
 #elf.parent.class_manager,
 #trategies.LoadDeferredColumns(self.key, True),
 #elf.key,
 #

 #ef __clause_element__(self):
 #""Allow the ColumnProperty to work in expression before it is turned
 #nto an instrumented attribute.
 #""

 #eturn self.expression

 #property
 #ef expression(self):
 #""Return the primary column or expression for this ColumnProperty.

 #.g.::


 #lass File(Base):
                # ...

 #ame = Column(String(64))
 #xtension = Column(String(8))
 #ilename = column_property(name + '.' + extension)
 #ath = column_property('C:/' + filename.expression)

 #. seealso::

 #ref:`mapper_column_property_sql_expressions_composed`

 #""
 #eturn self.columns[0]

 #ef instrument_class(self, mapper):
 #f not self.instrument:
 #eturn

 #ttributes.register_descriptor(
 #apper.class_,
 #elf.key,
 #omparator=self.comparator_factory(self, mapper),
 #arententity=mapper,
 #oc=self.doc,
 #

 #ef do_init(self):
 #uper(ColumnProperty, self).do_init()

 #f len(self.columns) > 1 and set(self.parent.primary_key).issuperset(
 #elf.columns
 #:
 #til.warn(
 #
 #On mapper %s, primary key column '%s' is being combined "
 #with distinct primary key column '%s' in attribute '%s'. "
 #Use explicit properties to give each column its own "
 #mapped attribute name."
 #
 # (self.parent, self.columns[1], self.columns[0], self.key)
 #

 #ef copy(self):
 #eturn ColumnProperty(
 #eferred=self.deferred,
 #roup=self.group,
 #ctive_history=self.active_history,
 #self.columns
 #

 #ef _getcommitted(
 #elf, state, dict_, column, passive=attributes.PASSIVE_OFF
 #:
 #eturn state.get_impl(self.key).get_committed_value(
 #tate, dict_, passive=passive
 #

 #ef merge(
 #elf,
 #ession,
 #ource_state,
 #ource_dict,
 #est_state,
 #est_dict,
 #oad,
 #recursive,
 #resolve_conflict_map,
 #:
 #f not self.instrument:
 #eturn
 #lif self.key in source_dict:
 #alue = source_dict[self.key]

 #f not load:
 #est_dict[self.key] = value
 #lse:
 #mpl = dest_state.get_impl(self.key)
 #mpl.set(dest_state, dest_dict, value, None)
 #lif dest_state.has_identity and self.key not in dest_dict:
 #est_state._expire_attributes(
 #est_dict, [self.key], no_loader=True
 #

 #lass Comparator(util.MemoizedSlots, PropComparator):
 #""Produce boolean, comparison, and other operators for
 #class:`.ColumnProperty` attributes.

 #ee the documentation for :class:`.PropComparator` for a brief
 #verview.

 #. seealso::

 #class:`.PropComparator`

 #class:`.ColumnOperators`

 #ref:`types_operators`

 #attr:`.TypeEngine.comparator_factory`

 #""

 #_slots__ = "__clause_element__", "info", "expressions"

 #ef _orm_annotate_column(self, column):
 #""annotate and possibly adapt a column to be returned
 #s the mapped-attribute exposed version of the column.

 #he column in this context needs to act as much like the
 #olumn in an ORM mapped context as possible, so includes
 #nnotations to give hints to various ORM functions as to
 #he source entity of this column.   It also adapts it
 #o the mapper's with_polymorphic selectable if one is
 #resent.

 #""

 #e = self._parententity
 #nnotations = {
 #entity_namespace": pe,
 #parententity": pe,
 #parentmapper": pe,
 #proxy_key": self.prop.key,
 #

 #ol = column

            # for a mapper with polymorphic_on and an adapter, return
            # the column against the polymorphic selectable.
            # see also orm.util._orm_downgrade_polymorphic_columns
            # for the reverse operation.
 #f self._parentmapper._polymorphic_adapter:
 #apper_local_col = col
 #ol = self._parentmapper._polymorphic_adapter.traverse(col)

                # this is a clue to the ORM Query etc. that this column
                # was adapted to the mapper's polymorphic_adapter.  the
                # ORM uses this hint to know which column its adapting.
 #nnotations["adapt_column"] = mapper_local_col

 #eturn col._annotate(annotations)._set_propagate_attrs(
 #"compile_state_plugin": "orm", "plugin_subject": pe}
 #

 #ef _memoized_method___clause_element__(self):
 #f self.adapter:
 #eturn self.adapter(self.prop.columns[0], self.prop.key)
 #lse:
 #eturn self._orm_annotate_column(self.prop.columns[0])

 #ef _memoized_attr_info(self):
 #""The .info dictionary for this attribute."""

 #e = self.__clause_element__()
 #ry:
 #eturn ce.info
 #xcept AttributeError:
 #eturn self.prop.info

 #ef _memoized_attr_expressions(self):
 #""The full sequence of columns referenced by this
 #ttribute, adjusted for any aliasing in progress.

 #. versionadded:: 1.3.17

 #""
 #f self.adapter:
 #eturn [
 #elf.adapter(col, self.prop.key)
 #or col in self.prop.columns
 #
 #lse:
 #eturn [
 #elf._orm_annotate_column(col) for col in self.prop.columns
 #

 #ef _fallback_getattr(self, key):
 #""proxy attribute access down to the mapped column.

 #his allows user-defined comparison methods to be accessed.
 #""
 #eturn getattr(self.__clause_element__(), key)

 #ef operate(self, op, *other, **kwargs):
 #eturn op(self.__clause_element__(), *other, **kwargs)

 #ef reverse_operate(self, op, other, **kwargs):
 #ol = self.__clause_element__()
 #eturn op(col._bind_param(op, other), col, **kwargs)

 #ef __str__(self):
 #eturn str(self.parent.class_.__name__) + "." + self.key
