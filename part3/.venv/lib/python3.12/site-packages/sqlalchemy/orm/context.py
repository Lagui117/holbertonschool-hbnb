# orm/context.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
from . import attributes
from . import interfaces
from . import loading
from .base import _is_aliased_class
from .interfaces import ORMColumnsClauseRole
from .path_registry import PathRegistry
from .util import _entity_corresponds_to
from .util import _ORMJoin
from .util import aliased
from .util import Bundle
from .util import ORMAdapter
from .. import exc as sa_exc
from .. import future
from .. import inspect
from .. import sql
from .. import util
from ..sql import coercions
from ..sql import expression
from ..sql import roles
from ..sql import util as sql_util
from ..sql import visitors
from ..sql.base import _entity_namespace_key
from ..sql.base import _select_iterables
from ..sql.base import CacheableOptions
from ..sql.base import CompileState
from ..sql.base import Options
from ..sql.selectable import LABEL_STYLE_DISAMBIGUATE_ONLY
from ..sql.selectable import LABEL_STYLE_NONE
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
from ..sql.selectable import SelectState
from ..sql.visitors import ExtendedInternalTraversal
from ..sql.visitors import InternalTraversal

_path_registry = PathRegistry.root

_EMPTY_DICT = util.immutabledict()


LABEL_STYLE_LEGACY_ORM = util.symbol("LABEL_STYLE_LEGACY_ORM")


class QueryContext(object):
 #_slots__ = (
 #compile_state",
 #query",
 #params",
 #load_options",
 #bind_arguments",
 #execution_options",
 #session",
 #autoflush",
 #populate_existing",
 #invoke_all_eagers",
 #version_check",
 #refresh_state",
 #create_eager_joins",
 #propagated_loader_options",
 #attributes",
 #runid",
 #partials",
 #post_load_paths",
 #identity_token",
 #yield_per",
 #loaders_require_buffering",
 #loaders_require_uniquing",
 #

 #lass default_load_options(Options):
 #only_return_tuples = False
 #populate_existing = False
 #version_check = False
 #invoke_all_eagers = True
 #autoflush = True
 #refresh_identity_token = None
 #yield_per = None
 #refresh_state = None
 #lazy_loaded_from = None
 #legacy_uniquing = False

 #ef __init__(
 #elf,
 #ompile_state,
 #tatement,
 #arams,
 #ession,
 #oad_options,
 #xecution_options=None,
 #ind_arguments=None,
 #:
 #elf.load_options = load_options
 #elf.execution_options = execution_options or _EMPTY_DICT
 #elf.bind_arguments = bind_arguments or _EMPTY_DICT
 #elf.compile_state = compile_state
 #elf.query = statement
 #elf.session = session
 #elf.loaders_require_buffering = False
 #elf.loaders_require_uniquing = False
 #elf.params = params

 #elf.propagated_loader_options = {
 # for o in statement._with_options if o.propagate_to_loaders
 #

 #elf.attributes = dict(compile_state.attributes)

 #elf.autoflush = load_options._autoflush
 #elf.populate_existing = load_options._populate_existing
 #elf.invoke_all_eagers = load_options._invoke_all_eagers
 #elf.version_check = load_options._version_check
 #elf.refresh_state = load_options._refresh_state
 #elf.yield_per = load_options._yield_per
 #elf.identity_token = load_options._refresh_identity_token

 #f self.yield_per and compile_state._no_yield_pers:
 #aise sa_exc.InvalidRequestError(
 #The yield_per Query option is currently not "
 #compatible with %s eager loading.  Please "
 #specify lazyload('*') or query.enable_eagerloads(False) in "
 #order to "
 #proceed with query.yield_per()."
 # ", ".join(compile_state._no_yield_pers)
 #


_orm_load_exec_options = util.immutabledict(
 #"_result_disable_adapt_to_context": True, "future_result": True}
)


class ORMCompileState(CompileState):
    # note this is a dictionary, but the
    # default_compile_options._with_polymorphic_adapt_map is a tuple
 #with_polymorphic_adapt_map = _EMPTY_DICT

 #lass default_compile_options(CacheableOptions):
 #cache_key_traversal = [
 #"_use_legacy_query_style", InternalTraversal.dp_boolean),
 #"_for_statement", InternalTraversal.dp_boolean),
 #"_bake_ok", InternalTraversal.dp_boolean),
 #
 #_with_polymorphic_adapt_map",
 #xtendedInternalTraversal.dp_has_cache_key_tuples,
 #,
 #"_current_path", InternalTraversal.dp_has_cache_key),
 #"_enable_single_crit", InternalTraversal.dp_boolean),
 #"_enable_eagerloads", InternalTraversal.dp_boolean),
 #"_orm_only_from_obj_alias", InternalTraversal.dp_boolean),
 #"_only_load_props", InternalTraversal.dp_plain_obj),
 #"_set_base_alias", InternalTraversal.dp_boolean),
 #"_for_refresh_state", InternalTraversal.dp_boolean),
 #"_render_for_subquery", InternalTraversal.dp_boolean),
 #

        # set to True by default from Query._statement_20(), to indicate
        # the rendered query should look like a legacy ORM query.  right
        # now this basically indicates we should use tablename_columnname
        # style labels.    Generally indicates the statement originated
        # from a Query object.
 #use_legacy_query_style = False

        # set *only* when we are coming from the Query.statement
        # accessor, or a Query-level equivalent such as
        # query.subquery().  this supersedes "toplevel".
 #for_statement = False

 #bake_ok = True
 #with_polymorphic_adapt_map = ()
 #current_path = _path_registry
 #enable_single_crit = True
 #enable_eagerloads = True
 #orm_only_from_obj_alias = True
 #only_load_props = None
 #set_base_alias = False
 #for_refresh_state = False
 #render_for_subquery = False

 #urrent_path = _path_registry

 #ef __init__(self, *arg, **kw):
 #aise NotImplementedError()

 #classmethod
 #ef _column_naming_convention(cls, label_style, legacy):

 #f legacy:

 #ef name(col, col_name=None):
 #f col_name:
 #eturn col_name
 #lse:
 #eturn getattr(col, "key")

 #eturn name
 #lse:
 #eturn SelectState._column_naming_convention(label_style)

 #classmethod
 #ef create_for_statement(cls, statement_container, compiler, **kw):
 #""Create a context for a statement given a :class:`.Compiler`.

 #his method is always invoked in the context of SQLCompiler.process().

 #or a Select object, this would be invoked from
 #QLCompiler.visit_select(). For the special FromStatement object used
 #y Query to indicate "Query.from_statement()", this is called by
 #romStatement._compiler_dispatch() that would be called by
 #QLCompiler.process().

 #""
 #aise NotImplementedError()

 #classmethod
 #ef get_column_descriptions(cls, statement):
 #eturn _column_descriptions(statement)

 #classmethod
 #ef orm_pre_session_exec(
 #ls,
 #ession,
 #tatement,
 #arams,
 #xecution_options,
 #ind_arguments,
 #s_reentrant_invoke,
 #:
 #f is_reentrant_invoke:
 #eturn statement, execution_options

 #
 #oad_options,
 #xecution_options,
 # = QueryContext.default_load_options.from_execution_options(
 #_sa_orm_load_options",
 #"populate_existing", "autoflush", "yield_per"},
 #xecution_options,
 #tatement._execution_options,
 #

        # default execution options for ORM results:
        # 1. _result_disable_adapt_to_context=True
        #    this will disable the ResultSetMetadata._adapt_to_context()
        #    step which we don't need, as we have result processors cached
        #    against the original SELECT statement before caching.
        # 2. future_result=True.  The ORM should **never** resolve columns
        #    in a result set based on names, only on Column objects that
        #    are correctly adapted to the context.   W the legacy result
        #    it will still attempt name-based resolution and also emit a
        #    warning.
 #f not execution_options:
 #xecution_options = _orm_load_exec_options
 #lse:
 #xecution_options = execution_options.union(_orm_load_exec_options)

 #f "yield_per" in execution_options or load_options._yield_per:
 #xecution_options = execution_options.union(
 #
 #stream_results": True,
 #max_row_buffer": execution_options.get(
 #yield_per", load_options._yield_per
 #,
 #
 #

 #ind_arguments["clause"] = statement

        # new in 1.4 - the coercions system is leveraged to allow the
        # "subject" mapper of a statement be propagated to the top
        # as the statement is built.   "subject" mapper is the generally
        # standard object used as an identifier for multi-database schemes.

        # we are here based on the fact that _propagate_attrs contains
        # "compile_state_plugin": "orm".   The "plugin_subject"
        # needs to be present as well.

 #ry:
 #lugin_subject = statement._propagate_attrs["plugin_subject"]
 #xcept KeyError:
 #ssert False, "statement had 'orm' plugin but no plugin_subject"
 #lse:
 #f plugin_subject:
 #ind_arguments["mapper"] = plugin_subject.mapper

 #f load_options._autoflush:
 #ession._autoflush()

 #eturn statement, execution_options

 #classmethod
 #ef orm_setup_cursor_result(
 #ls,
 #ession,
 #tatement,
 #arams,
 #xecution_options,
 #ind_arguments,
 #esult,
 #:
 #xecution_context = result.context
 #ompile_state = execution_context.compiled.compile_state

        # cover edge case where ORM entities used in legacy select
        # were passed to session.execute:
        # session.execute(legacy_select([User.id, User.name]))
        # see test_query->test_legacy_tuple_old_select

 #oad_options = execution_options.get(
 #_sa_orm_load_options", QueryContext.default_load_options
 #

 #uerycontext = QueryContext(
 #ompile_state,
 #tatement,
 #arams,
 #ession,
 #oad_options,
 #xecution_options,
 #ind_arguments,
 #
 #eturn loading.instances(result, querycontext)

 #property
 #ef _lead_mapper_entities(self):
 #""return all _MapperEntity objects in the lead entities collection.

 #oes **not** include entities that have been replaced by
 #ith_entities(), with_only_columns()

 #""
 #eturn [
 #nt for ent in self._entities if isinstance(ent, _MapperEntity)
 #

 #ef _create_with_polymorphic_adapter(self, ext_info, selectable):
 #f (
 #ot ext_info.is_aliased_class
 #nd ext_info.mapper.persist_selectable
 #ot in self._polymorphic_adapters
 #:
 #or mp in ext_info.mapper.iterate_to_root():
 #elf._mapper_loads_polymorphically_with(
 #p,
 #ql_util.ColumnAdapter(selectable, mp._equivalent_columns),
 #

 #ef _mapper_loads_polymorphically_with(self, mapper, adapter):
 #or m2 in mapper._with_polymorphic_mappers or [mapper]:
 #elf._polymorphic_adapters[m2] = adapter
 #or m in m2.iterate_to_root():  # TODO: redundant ?
 #elf._polymorphic_adapters[m.local_table] = adapter


@sql.base.CompileState.plugin_for("orm", "orm_from_statement")
class ORMFromStatementCompileState(ORMCompileState):
 #aliased_generations = util.immutabledict()
 #from_obj_alias = None
 #has_mapper_entities = False

 #has_orm_entities = False
 #ulti_row_eager_loaders = False
 #ompound_eager_adapter = None

 #xtra_criteria_entities = _EMPTY_DICT
 #ager_joins = _EMPTY_DICT

 #classmethod
 #ef create_for_statement(cls, statement_container, compiler, **kw):

 #f compiler is not None:
 #oplevel = not compiler.stack
 #lse:
 #oplevel = True

 #elf = cls.__new__(cls)
 #elf._primary_entity = None

 #elf.use_legacy_query_style = (
 #tatement_container._compile_options._use_legacy_query_style
 #
 #elf.statement_container = self.select_statement = statement_container
 #elf.requested_statement = statement = statement_container.element

 #f statement.is_dml:
 #elf.dml_table = statement.table

 #elf._entities = []
 #elf._polymorphic_adapters = {}
 #elf._no_yield_pers = set()

 #elf.compile_options = statement_container._compile_options

 #f (
 #elf.use_legacy_query_style
 #nd isinstance(statement, expression.SelectBase)
 #nd not statement._is_textual
 #nd not statement.is_dml
 #nd statement._label_style is LABEL_STYLE_NONE
 #:
 #elf.statement = statement.set_label_style(
 #ABEL_STYLE_TABLENAME_PLUS_COL
 #
 #lse:
 #elf.statement = statement

 #elf._label_convention = self._column_naming_convention(
 #tatement._label_style
 #f not statement._is_textual and not statement.is_dml
 #lse LABEL_STYLE_NONE,
 #elf.use_legacy_query_style,
 #

 #QueryEntity.to_compile_state(
 #elf, statement_container._raw_columns, self._entities
 #

 #elf.current_path = statement_container._compile_options._current_path

 #f toplevel and statement_container._with_options:
 #elf.attributes = {"_unbound_load_dedupes": set()}
 #elf.global_attributes = compiler._global_attributes

 #or opt in statement_container._with_options:
 #f opt._is_compile_state:
 #pt.process_compile_state(self)

 #lse:
 #elf.attributes = {}
 #elf.global_attributes = compiler._global_attributes

 #f statement_container._with_context_options:
 #or fn, key in statement_container._with_context_options:
 #n(self)

 #elf.primary_columns = []
 #elf.secondary_columns = []
 #elf.create_eager_joins = []
 #elf._fallback_from_clauses = []

 #elf.order_by = None

 #f isinstance(
 #elf.statement, (expression.TextClause, expression.UpdateBase)
 #:

 #elf.extra_criteria_entities = {}

            # setup for all entities. Currently, this is not useful
            # for eager loaders, as the eager loaders that work are able
            # to do their work entirely in row_processor.
 #or entity in self._entities:
 #ntity.setup_compile_state(self)

            # we did the setup just to get primary columns.
 #elf.statement = expression.TextualSelect(
 #elf.statement, self.primary_columns, positional=False
 #
 #lse:
            # allow TextualSelect with implicit columns as well
            # as select() with ad-hoc columns, see test_query::TextTest
 #elf._from_obj_alias = sql.util.ColumnAdapter(
 #elf.statement, adapt_on_names=True
 #
            # set up for eager loaders, however if we fix subqueryload
            # it should not need to do this here.  the model of eager loaders
            # that can work entirely in row_processor might be interesting
            # here though subqueryloader has a lot of upfront work to do
            # see test/orm/test_query.py -> test_related_eagerload_against_text
            # for where this part makes a difference.  would rather have
            # subqueryload figure out what it needs more intelligently.
            #            for entity in self._entities:
            #                entity.setup_compile_state(self)

 #eturn self

 #ef _adapt_col_list(self, cols, current_adapter):
 #eturn cols

 #ef _get_current_adapter(self):
 #eturn None


@sql.base.CompileState.plugin_for("orm", "select")
class ORMSelectCompileState(ORMCompileState, SelectState):
 #joinpath = _joinpoint = _EMPTY_DICT

 #memoized_entities = _EMPTY_DICT

 #from_obj_alias = None
 #has_mapper_entities = False

 #has_orm_entities = False
 #ulti_row_eager_loaders = False
 #ompound_eager_adapter = None

 #orrelate = None
 #orrelate_except = None
 #where_criteria = ()
 #having_criteria = ()

 #classmethod
 #ef create_for_statement(cls, statement, compiler, **kw):
 #""compiler hook, we arrive here from compiler.visit_select() only."""

 #elf = cls.__new__(cls)

 #f compiler is not None:
 #oplevel = not compiler.stack
 #elf.global_attributes = compiler._global_attributes
 #lse:
 #oplevel = True
 #elf.global_attributes = {}

 #elect_statement = statement

        # if we are a select() that was never a legacy Query, we won't
        # have ORM level compile options.
 #tatement._compile_options = cls.default_compile_options.safe_merge(
 #tatement._compile_options
 #

 #f select_statement._execution_options:
            # execution options should not impact the compilation of a
            # query, and at the moment subqueryloader is putting some things
            # in here that we explicitly don't want stuck in a cache.
 #elf.select_statement = select_statement._clone()
 #elf.select_statement._execution_options = util.immutabledict()
 #lse:
 #elf.select_statement = select_statement

        # indicates this select() came from Query.statement
 #elf.for_statement = select_statement._compile_options._for_statement

        # generally if we are from Query or directly from a select()
 #elf.use_legacy_query_style = (
 #elect_statement._compile_options._use_legacy_query_style
 #

 #elf._entities = []
 #elf._primary_entity = None
 #elf._aliased_generations = {}
 #elf._polymorphic_adapters = {}
 #elf._no_yield_pers = set()

        # legacy: only for query.with_polymorphic()
 #f select_statement._compile_options._with_polymorphic_adapt_map:
 #elf._with_polymorphic_adapt_map = dict(
 #elect_statement._compile_options._with_polymorphic_adapt_map
 #
 #elf._setup_with_polymorphics()

 #elf.compile_options = select_statement._compile_options

 #f not toplevel:
            # for subqueries, turn off eagerloads and set
            # "render_for_subquery".
 #elf.compile_options += {
 #_enable_eagerloads": False,
 #_render_for_subquery": True,
 #

        # determine label style.   we can make different decisions here.
        # at the moment, trying to see if we can always use DISAMBIGUATE_ONLY
        # rather than LABEL_STYLE_NONE, and if we can use disambiguate style
        # for new style ORM selects too.
 #f (
 #elf.use_legacy_query_style
 #nd self.select_statement._label_style is LABEL_STYLE_LEGACY_ORM
 #:
 #f not self.for_statement:
 #elf.label_style = LABEL_STYLE_TABLENAME_PLUS_COL
 #lse:
 #elf.label_style = LABEL_STYLE_DISAMBIGUATE_ONLY
 #lse:
 #elf.label_style = self.select_statement._label_style

 #elf._label_convention = self._column_naming_convention(
 #tatement._label_style, self.use_legacy_query_style
 #

 #f select_statement._memoized_select_entities:
 #elf._memoized_entities = {
 #emoized_entities: _QueryEntity.to_compile_state(
 #elf,
 #emoized_entities._raw_columns,
 #],
 #
 #or memoized_entities in (
 #elect_statement._memoized_select_entities
 #
 #

 #QueryEntity.to_compile_state(
 #elf, select_statement._raw_columns, self._entities
 #

 #elf.current_path = select_statement._compile_options._current_path

 #elf.eager_order_by = ()

 #f toplevel and (
 #elect_statement._with_options
 #r select_statement._memoized_select_entities
 #:
 #elf.attributes = {"_unbound_load_dedupes": set()}

 #or (
 #emoized_entities
 # in select_statement._memoized_select_entities:
 #or opt in memoized_entities._with_options:
 #f opt._is_compile_state:
 #pt.process_compile_state_replaced_entities(
 #elf,
 #
 #nt
 #or ent in self._memoized_entities[
 #emoized_entities
 #
 #f isinstance(ent, _MapperEntity)
 #,
 #

 #or opt in self.select_statement._with_options:
 #f opt._is_compile_state:
 #pt.process_compile_state(self)
 #lse:
 #elf.attributes = {}

 #f select_statement._with_context_options:
 #or fn, key in select_statement._with_context_options:
 #n(self)

 #elf.primary_columns = []
 #elf.secondary_columns = []
 #elf.eager_joins = {}
 #elf.extra_criteria_entities = {}
 #elf.create_eager_joins = []
 #elf._fallback_from_clauses = []

        # normalize the FROM clauses early by themselves, as this makes
        # it an easier job when we need to assemble a JOIN onto these,
        # for select.join() as well as joinedload().   As of 1.4 there are now
        # potentially more complex sets of FROM objects here as the use
        # of lambda statements for lazyload, load_on_pk etc. uses more
        # cloning of the select() construct.  See #6495
 #elf.from_clauses = self._normalize_froms(
 #nfo.selectable for info in select_statement._from_obj
 #

        # this is a fairly arbitrary break into a second method,
        # so it might be nicer to break up create_for_statement()
        # and _setup_for_generate into three or four logical sections
 #elf._setup_for_generate()

 #electState.__init__(self, self.statement, compiler, **kw)

 #eturn self

 #ef _setup_for_generate(self):
 #uery = self.select_statement

 #elf.statement = None
 #elf._join_entities = ()

 #f self.compile_options._set_base_alias:
 #elf._set_select_from_alias()

 #or memoized_entities in query._memoized_select_entities:
 #f memoized_entities._setup_joins:
 #elf._join(
 #emoized_entities._setup_joins,
 #elf._memoized_entities[memoized_entities],
 #
 #f memoized_entities._legacy_setup_joins:
 #elf._legacy_join(
 #emoized_entities._legacy_setup_joins,
 #elf._memoized_entities[memoized_entities],
 #

 #f query._setup_joins:
 #elf._join(query._setup_joins, self._entities)

 #f query._legacy_setup_joins:
 #elf._legacy_join(query._legacy_setup_joins, self._entities)

 #urrent_adapter = self._get_current_adapter()

 #f query._where_criteria:
 #elf._where_criteria = query._where_criteria

 #f current_adapter:
 #elf._where_criteria = tuple(
 #urrent_adapter(crit, True)
 #or crit in self._where_criteria
 #

        # TODO: some complexity with order_by here was due to mapper.order_by.
        # now that this is removed we can hopefully make order_by /
        # group_by act identically to how they are in Core select.
 #elf.order_by = (
 #elf._adapt_col_list(query._order_by_clauses, current_adapter)
 #f current_adapter and query._order_by_clauses not in (None, False)
 #lse query._order_by_clauses
 #

 #f query._having_criteria:
 #elf._having_criteria = tuple(
 #urrent_adapter(crit, True) if current_adapter else crit
 #or crit in query._having_criteria
 #

 #elf.group_by = (
 #elf._adapt_col_list(
 #til.flatten_iterator(query._group_by_clauses), current_adapter
 #
 #f current_adapter and query._group_by_clauses not in (None, False)
 #lse query._group_by_clauses or None
 #

 #f self.eager_order_by:
 #dapter = self.from_clauses[0]._target_adapter
 #elf.eager_order_by = adapter.copy_and_process(self.eager_order_by)

 #f query._distinct_on:
 #elf.distinct_on = self._adapt_col_list(
 #uery._distinct_on, current_adapter
 #
 #lse:
 #elf.distinct_on = ()

 #elf.distinct = query._distinct

 #f query._correlate:
            # ORM mapped entities that are mapped to joins can be passed
            # to .correlate, so here they are broken into their component
            # tables.
 #elf.correlate = tuple(
 #til.flatten_iterator(
 #ql_util.surface_selectables(s) if s is not None else None
 #or s in query._correlate
 #
 #
 #lif query._correlate_except:
 #elf.correlate_except = tuple(
 #til.flatten_iterator(
 #ql_util.surface_selectables(s) if s is not None else None
 #or s in query._correlate_except
 #
 #
 #lif not query._auto_correlate:
 #elf.correlate = (None,)

        # PART II

 #elf.dedupe_cols = True

 #elf._for_update_arg = query._for_update_arg

 #or entity in self._entities:
 #ntity.setup_compile_state(self)

 #or rec in self.create_eager_joins:
 #trategy = rec[0]
 #trategy(self, *rec[1:])

        # else "load from discrete FROMs" mode,
        # i.e. when each _MappedEntity has its own FROM

 #f self.compile_options._enable_single_crit:
 #elf._adjust_for_extra_criteria()

 #f not self.primary_columns:
 #f self.compile_options._only_load_props:
 #aise sa_exc.InvalidRequestError(
 #No column-based properties specified for "
 #refresh operation. Use session.expire() "
 #to reload collections and related items."
 #
 #lse:
 #aise sa_exc.InvalidRequestError(
 #Query contains no columns with which to SELECT from."
 #

 #f not self.from_clauses:
 #elf.from_clauses = list(self._fallback_from_clauses)

 #f self.order_by is False:
 #elf.order_by = None

 #f self.multi_row_eager_loaders and self._should_nest_selectable:
 #elf.statement = self._compound_eager_statement()
 #lse:
 #elf.statement = self._simple_statement()

 #f self.for_statement:
 #zero = self._mapper_zero()
 #f ezero is not None:
                # TODO: this goes away once we get rid of the deep entity
                # thing
 #elf.statement = self.statement._annotate(
 #"deepentity": ezero}
 #

 #classmethod
 #ef _create_entities_collection(cls, query, legacy):
 #""Creates a partial ORMSelectCompileState that includes
 #he full collection of _MapperEntity and other _QueryEntity objects.

 #upports a few remaining use cases that are pre-compilation
 #ut still need to gather some of the column  / adaption information.

 #""
 #elf = cls.__new__(cls)

 #elf._entities = []
 #elf._primary_entity = None
 #elf._aliased_generations = {}
 #elf._polymorphic_adapters = {}

 #ompile_options = cls.default_compile_options.safe_merge(
 #uery._compile_options
 #
        # legacy: only for query.with_polymorphic()
 #f compile_options._with_polymorphic_adapt_map:
 #elf._with_polymorphic_adapt_map = dict(
 #ompile_options._with_polymorphic_adapt_map
 #
 #elf._setup_with_polymorphics()

 #elf._label_convention = self._column_naming_convention(
 #uery._label_style, legacy
 #

        # entities will also set up polymorphic adapters for mappers
        # that have with_polymorphic configured
 #QueryEntity.to_compile_state(self, query._raw_columns, self._entities)
 #eturn self

 #classmethod
 #ef determine_last_joined_entity(cls, statement):
 #etup_joins = statement._setup_joins

 #f not setup_joins:
 #eturn None

 #target, onclause, from_, flags) = setup_joins[-1]

 #f isinstance(target, interfaces.PropComparator):
 #eturn target.entity
 #lse:
 #eturn target

 #classmethod
 #ef all_selected_columns(cls, statement):
 #or element in statement._raw_columns:
 #f (
 #lement.is_selectable
 #nd "entity_namespace" in element._annotations
 #:
 #ns = element._annotations["entity_namespace"]
 #f not ens.is_mapper and not ens.is_aliased_class:
 #or elem in _select_iterables([element]):
 #ield elem
 #lse:
 #or elem in _select_iterables(ens._all_column_expressions):
 #ield elem
 #lse:
 #or elem in _select_iterables([element]):
 #ield elem

 #classmethod
 #util.preload_module("sqlalchemy.orm.query")
 #ef from_statement(cls, statement, from_statement):
 #uery = util.preloaded.orm_query

 #rom_statement = coercions.expect(
 #oles.ReturnsRowsRole,
 #rom_statement,
 #pply_propagate_attrs=statement,
 #

 #tmt = query.FromStatement(statement._raw_columns, from_statement)

 #tmt.__dict__.update(
 #with_options=statement._with_options,
 #with_context_options=statement._with_context_options,
 #execution_options=statement._execution_options,
 #propagate_attrs=statement._propagate_attrs,
 #
 #eturn stmt

 #ef _setup_with_polymorphics(self):
        # legacy: only for query.with_polymorphic()
 #or ext_info, wp in self._with_polymorphic_adapt_map.items():
 #elf._mapper_loads_polymorphically_with(ext_info, wp._adapter)

 #ef _set_select_from_alias(self):

 #uery = self.select_statement  # query

 #ssert self.compile_options._set_base_alias
 #ssert len(query._from_obj) == 1

 #dapter = self._get_select_from_alias_from_obj(query._from_obj[0])
 #f adapter:
 #elf.compile_options += {"_enable_single_crit": False}
 #elf._from_obj_alias = adapter

 #ef _get_select_from_alias_from_obj(self, from_obj):
 #nfo = from_obj

 #f "parententity" in info._annotations:
 #nfo = info._annotations["parententity"]

 #f hasattr(info, "mapper"):
 #f not info.is_aliased_class:
 #aise sa_exc.ArgumentError(
 #A selectable (FromClause) instance is "
 #expected when the base alias is being set."
 #
 #lse:
 #eturn info._adapter

 #lif isinstance(info.selectable, sql.selectable.AliasedReturnsRows):
 #quivs = self._all_equivs()
 #eturn sql_util.ColumnAdapter(info, equivs)
 #lse:
 #eturn None

 #ef _mapper_zero(self):
 #""return the Mapper associated with the first QueryEntity."""
 #eturn self._entities[0].mapper

 #ef _entity_zero(self):
 #""Return the 'entity' (mapper or AliasedClass) associated
 #ith the first QueryEntity, or alternatively the 'select from'
 #ntity if specified."""

 #or ent in self.from_clauses:
 #f "parententity" in ent._annotations:
 #eturn ent._annotations["parententity"]
 #or qent in self._entities:
 #f qent.entity_zero:
 #eturn qent.entity_zero

 #eturn None

 #ef _only_full_mapper_zero(self, methname):
 #f self._entities != [self._primary_entity]:
 #aise sa_exc.InvalidRequestError(
 #%s() can only be used against "
 #a single mapped class." % methname
 #
 #eturn self._primary_entity.entity_zero

 #ef _only_entity_zero(self, rationale=None):
 #f len(self._entities) > 1:
 #aise sa_exc.InvalidRequestError(
 #ationale
 #r "This operation requires a Query "
 #against a single mapper."
 #
 #eturn self._entity_zero()

 #ef _all_equivs(self):
 #quivs = {}

 #or memoized_entities in self._memoized_entities.values():
 #or ent in [
 #nt
 #or ent in memoized_entities
 #f isinstance(ent, _MapperEntity)
 #:
 #quivs.update(ent.mapper._equivalent_columns)

 #or ent in [
 #nt for ent in self._entities if isinstance(ent, _MapperEntity)
 #:
 #quivs.update(ent.mapper._equivalent_columns)
 #eturn equivs

 #ef _compound_eager_statement(self):
        # for eager joins present and LIMIT/OFFSET/DISTINCT,
        # wrap the query inside a select,
        # then append eager joins onto that

 #f self.order_by:
            # the default coercion for ORDER BY is now the OrderByRole,
            # which adds an additional post coercion to ByOfRole in that
            # elements are converted into label references.  For the
            # eager load / subquery wrapping case, we need to un-coerce
            # the original expressions outside of the label references
            # in order to have them render.
 #nwrapped_order_by = [
 #lem.element
 #f isinstance(elem, sql.elements._label_reference)
 #lse elem
 #or elem in self.order_by
 #

 #rder_by_col_expr = sql_util.expand_column_list_from_order_by(
 #elf.primary_columns, unwrapped_order_by
 #
 #lse:
 #rder_by_col_expr = []
 #nwrapped_order_by = None

        # put FOR UPDATE on the inner query, where MySQL will honor it,
        # as well as if it has an OF so PostgreSQL can use it.
 #nner = self._select_statement(
 #til.unique_list(self.primary_columns + order_by_col_expr)
 #f self.dedupe_cols
 #lse (self.primary_columns + order_by_col_expr),
 #elf.from_clauses,
 #elf._where_criteria,
 #elf._having_criteria,
 #elf.label_style,
 #elf.order_by,
 #or_update=self._for_update_arg,
 #ints=self.select_statement._hints,
 #tatement_hints=self.select_statement._statement_hints,
 #orrelate=self.correlate,
 #orrelate_except=self.correlate_except,
 #*self._select_args
 #

 #nner = inner.alias()

 #quivs = self._all_equivs()

 #elf.compound_eager_adapter = sql_util.ColumnAdapter(inner, equivs)

 #tatement = future.select(
 #([inner] + self.secondary_columns)  # use_labels=self.labels
 #
 #tatement._label_style = self.label_style

        # Oracle however does not allow FOR UPDATE on the subquery,
        # and the Oracle dialect ignores it, plus for PostgreSQL, MySQL
        # we expect that all elements of the row are locked, so also put it
        # on the outside (except in the case of PG when OF is used)
 #f (
 #elf._for_update_arg is not None
 #nd self._for_update_arg.of is None
 #:
 #tatement._for_update_arg = self._for_update_arg

 #rom_clause = inner
 #or eager_join in self.eager_joins.values():
            # EagerLoader places a 'stop_on' attribute on the join,
            # giving us a marker as to where the "splice point" of
            # the join should be
 #rom_clause = sql_util.splice_joins(
 #rom_clause, eager_join, eager_join.stop_on
 #

 #tatement.select_from.non_generative(statement, from_clause)

 #f unwrapped_order_by:
 #tatement.order_by.non_generative(
 #tatement,
 #self.compound_eager_adapter.copy_and_process(
 #nwrapped_order_by
 #
 #

 #tatement.order_by.non_generative(statement, *self.eager_order_by)
 #eturn statement

 #ef _simple_statement(self):

 #f (
 #elf.compile_options._use_legacy_query_style
 #nd (self.distinct and not self.distinct_on)
 #nd self.order_by
 #:
 #o_add = sql_util.expand_column_list_from_order_by(
 #elf.primary_columns, self.order_by
 #
 #f to_add:
 #til.warn_deprecated_20(
 #ORDER BY columns added implicitly due to "
 #DISTINCT is deprecated and will be removed in "
 #SQLAlchemy 2.0.  SELECT statements with DISTINCT "
 #should be written to explicitly include the appropriate "
 #columns in the columns clause"
 #
 #elf.primary_columns += to_add

 #tatement = self._select_statement(
 #til.unique_list(self.primary_columns + self.secondary_columns)
 #f self.dedupe_cols
 #lse (self.primary_columns + self.secondary_columns),
 #uple(self.from_clauses) + tuple(self.eager_joins.values()),
 #elf._where_criteria,
 #elf._having_criteria,
 #elf.label_style,
 #elf.order_by,
 #or_update=self._for_update_arg,
 #ints=self.select_statement._hints,
 #tatement_hints=self.select_statement._statement_hints,
 #orrelate=self.correlate,
 #orrelate_except=self.correlate_except,
 #*self._select_args
 #

 #f self.eager_order_by:
 #tatement.order_by.non_generative(statement, *self.eager_order_by)
 #eturn statement

 #ef _select_statement(
 #elf,
 #aw_columns,
 #rom_obj,
 #here_criteria,
 #aving_criteria,
 #abel_style,
 #rder_by,
 #or_update,
 #ints,
 #tatement_hints,
 #orrelate,
 #orrelate_except,
 #imit_clause,
 #ffset_clause,
 #istinct,
 #istinct_on,
 #refixes,
 #uffixes,
 #roup_by,
 #:

 #elect = future.Select
 #tatement = Select.__new__(Select)
 #tatement._raw_columns = raw_columns
 #tatement._from_obj = from_obj

 #tatement._label_style = label_style

 #f where_criteria:
 #tatement._where_criteria = where_criteria
 #f having_criteria:
 #tatement._having_criteria = having_criteria

 #f order_by:
 #tatement._order_by_clauses += tuple(order_by)

 #f distinct_on:
 #tatement.distinct.non_generative(statement, *distinct_on)
 #lif distinct:
 #tatement.distinct.non_generative(statement)

 #f group_by:
 #tatement._group_by_clauses += tuple(group_by)

 #tatement._limit_clause = limit_clause
 #tatement._offset_clause = offset_clause

 #f prefixes:
 #tatement._prefixes = prefixes

 #f suffixes:
 #tatement._suffixes = suffixes

 #tatement._for_update_arg = for_update

 #f hints:
 #tatement._hints = hints
 #f statement_hints:
 #tatement._statement_hints = statement_hints

 #f correlate:
 #tatement.correlate.non_generative(statement, *correlate)

 #f correlate_except:
 #tatement.correlate_except.non_generative(
 #tatement, *correlate_except
 #

 #eturn statement

 #ef _adapt_polymorphic_element(self, element):
 #f "parententity" in element._annotations:
 #earch = element._annotations["parententity"]
 #lias = self._polymorphic_adapters.get(search, None)
 #f alias:
 #eturn alias.adapt_clause(element)

 #f isinstance(element, expression.FromClause):
 #earch = element
 #lif hasattr(element, "table"):
 #earch = element.table
 #lse:
 #eturn None

 #lias = self._polymorphic_adapters.get(search, None)
 #f alias:
 #eturn alias.adapt_clause(element)

 #ef _adapt_aliased_generation(self, element):
        # this is crazy logic that I look forward to blowing away
        # when aliased=True is gone :)
 #f "aliased_generation" in element._annotations:
 #or adapter in self._aliased_generations.get(
 #lement._annotations["aliased_generation"], ()
 #:
 #eplaced_elem = adapter.replace(element)
 #f replaced_elem is not None:
 #eturn replaced_elem

 #eturn None

 #ef _adapt_col_list(self, cols, current_adapter):
 #f current_adapter:
 #eturn [current_adapter(o, True) for o in cols]
 #lse:
 #eturn cols

 #ef _get_current_adapter(self):

 #dapters = []

        # vvvvvvvvvvvvvvv legacy vvvvvvvvvvvvvvvvvv
 #f self._from_obj_alias:
            # for the "from obj" alias, apply extra rule to the
            # 'ORM only' check, if this query were generated from a
            # subquery of itself, i.e. _from_selectable(), apply adaption
            # to all SQL constructs.
 #dapters.append(
 #
 #alse
 #f self.compile_options._orm_only_from_obj_alias
 #lse True,
 #elf._from_obj_alias.replace,
 #
 #

 #f self._aliased_generations:
 #dapters.append((False, self._adapt_aliased_generation))
        # ^^^^^^^^^^^^^ legacy ^^^^^^^^^^^^^^^^^^^^^

        # this is the only adapter we would need going forward...
 #f self._polymorphic_adapters:
 #dapters.append((False, self._adapt_polymorphic_element))

 #f not adapters:
 #eturn None

 #ef _adapt_clause(clause, as_filter):
            # do we adapt all expression elements or only those
            # tagged as 'ORM' constructs ?

 #ef replace(elem):
 #s_orm_adapt = (
 #_orm_adapt" in elem._annotations
 #r "parententity" in elem._annotations
 #
 #or always_adapt, adapter in adapters:
 #f is_orm_adapt or always_adapt:
 # = adapter(elem)
 #f e is not None:
 #eturn e

 #eturn visitors.replacement_traverse(clause, {}, replace)

 #eturn _adapt_clause

 #ef _join(self, args, entities_collection):
 #or (right, onclause, from_, flags) in args:
 #souter = flags["isouter"]
 #ull = flags["full"]
            # maybe?
 #elf._reset_joinpoint()

 #ight = inspect(right)
 #f onclause is not None:
 #nclause = inspect(onclause)

 #f onclause is None and isinstance(
 #ight, interfaces.PropComparator
 #:
                # determine onclause/right_entity.  still need to think
                # about how to best organize this since we are getting:
                #
                #
                # q.join(Entity, Parent.property)
                # q.join(Parent.property)
                # q.join(Parent.property.of_type(Entity))
                # q.join(some_table)
                # q.join(some_table, some_parent.c.id==some_table.c.parent_id)
                #
                # is this still too many choices?  how do we handle this
                # when sometimes "right" is implied and sometimes not?
                #
 #nclause = right
 #ight = None
 #lif "parententity" in right._annotations:
 #ight = right._annotations["parententity"]

 #f onclause is None:
 #f not right.is_selectable and not hasattr(right, "mapper"):
 #aise sa_exc.ArgumentError(
 #Expected mapped entity or "
 #selectable/table as join target"
 #

 #f_type = None

 #f isinstance(onclause, interfaces.PropComparator):
                # descriptor/property given (or determined); this tells us
                # explicitly what the expected "left" side of the join is.

 #f_type = getattr(onclause, "_of_type", None)

 #f right is None:
 #f of_type:
 #ight = of_type
 #lse:
 #ight = onclause.property

 #ry:
 #ight = right.entity
 #xcept AttributeError as err:
 #til.raise_(
 #a_exc.ArgumentError(
 #Join target %s does not refer to a "
 #mapped entity" % right
 #,
 #eplace_context=err,
 #

 #eft = onclause._parententity

 #lias = self._polymorphic_adapters.get(left, None)

                # could be None or could be ColumnAdapter also
 #f isinstance(alias, ORMAdapter) and alias.mapper.isa(left):
 #eft = alias.aliased_class
 #nclause = getattr(left, onclause.key)

 #rop = onclause.property
 #f not isinstance(onclause, attributes.QueryableAttribute):
 #nclause = prop

                # TODO: this is where "check for path already present"
                # would occur. see if this still applies?

 #f from_ is not None:
 #f (
 #rom_ is not left
 #nd from_._annotations.get("parententity", None)
 #s not left
 #:
 #aise sa_exc.InvalidRequestError(
 #explicit from clause %s does not match left side "
 #of relationship attribute %s"
 # (
 #rom_._annotations.get("parententity", from_),
 #nclause,
 #
 #
 #lif from_ is not None:
 #rop = None
 #eft = from_
 #lse:
                # no descriptor/property given; we will need to figure out
                # what the effective "left" side is
 #rop = left = None

            # figure out the final "left" and "right" sides and create an
            # ORMJoin to add to our _from_obj tuple
 #elf._join_left_to_right(
 #ntities_collection,
 #eft,
 #ight,
 #nclause,
 #rop,
 #alse,
 #alse,
 #souter,
 #ull,
 #

 #ef _legacy_join(self, args, entities_collection):
 #""consumes arguments from join() or outerjoin(), places them into a
 #onsistent format with which to form the actual JOIN constructs.

 #""
 #or (right, onclause, left, flags) in args:

 #uterjoin = flags["isouter"]
 #reate_aliases = flags["aliased"]
 #rom_joinpoint = flags["from_joinpoint"]
 #ull = flags["full"]
 #liased_generation = flags["aliased_generation"]

            # do a quick inspect to accommodate for a lambda
 #f right is not None and not isinstance(right, util.string_types):
 #ight = inspect(right)
 #f onclause is not None and not isinstance(
 #nclause, util.string_types
 #:
 #nclause = inspect(onclause)

            # legacy vvvvvvvvvvvvvvvvvvvvvvvvvv
 #f not from_joinpoint:
 #elf._reset_joinpoint()
 #lse:
 #rev_aliased_generation = self._joinpoint.get(
 #aliased_generation", None
 #
 #f not aliased_generation:
 #liased_generation = prev_aliased_generation
 #lif prev_aliased_generation:
 #elf._aliased_generations[
 #liased_generation
 # = self._aliased_generations.get(
 #rev_aliased_generation, ()
 #
            # legacy ^^^^^^^^^^^^^^^^^^^^^^^^^^^

 #f (
 #sinstance(
 #ight, (interfaces.PropComparator, util.string_types)
 #
 #nd onclause is None
 #:
 #nclause = right
 #ight = None
 #lif "parententity" in right._annotations:
 #ight = right._annotations["parententity"]

 #f onclause is None:
 #f not right.is_selectable and not hasattr(right, "mapper"):
 #aise sa_exc.ArgumentError(
 #Expected mapped entity or "
 #selectable/table as join target"
 #

 #f isinstance(onclause, interfaces.PropComparator):
 #f_type = getattr(onclause, "_of_type", None)
 #lse:
 #f_type = None

 #f isinstance(onclause, util.string_types):
                # string given, e.g. query(Foo).join("bar").
                # we look to the left entity or what we last joined
                # towards
 #nclause = _entity_namespace_key(
 #nspect(self._joinpoint_zero()), onclause
 #

            # legacy vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
            # check for q.join(Class.propname, from_joinpoint=True)
            # and Class corresponds at the mapper level to the current
            # joinpoint.  this match intentionally looks for a non-aliased
            # class-bound descriptor as the onclause and if it matches the
            # current joinpoint at the mapper level, it's used.  This
            # is a very old use case that is intended to make it easier
            # to work with the aliased=True flag, which is also something
            # that probably shouldn't exist on join() due to its high
            # complexity/usefulness ratio
 #lif from_joinpoint and isinstance(
 #nclause, interfaces.PropComparator
 #:
 #p0 = self._joinpoint_zero()
 #nfo = inspect(jp0)

 #f getattr(info, "mapper", None) is onclause._parententity:
 #nclause = _entity_namespace_key(info, onclause.key)
            # legacy ^^^^^^^^^^^^^^^^^^^^^^^^^^^

 #f isinstance(onclause, interfaces.PropComparator):
                # descriptor/property given (or determined); this tells us
                # explicitly what the expected "left" side of the join is.
 #f right is None:
 #f of_type:
 #ight = of_type
 #lse:
 #ight = onclause.property

 #ry:
 #ight = right.entity
 #xcept AttributeError as err:
 #til.raise_(
 #a_exc.ArgumentError(
 #Join target %s does not refer to a "
 #mapped entity" % right
 #,
 #eplace_context=err,
 #

 #eft = onclause._parententity

 #lias = self._polymorphic_adapters.get(left, None)

                # could be None or could be ColumnAdapter also
 #f isinstance(alias, ORMAdapter) and alias.mapper.isa(left):
 #eft = alias.aliased_class
 #nclause = getattr(left, onclause.key)

 #rop = onclause.property
 #f not isinstance(onclause, attributes.QueryableAttribute):
 #nclause = prop

 #f not create_aliases:
                    # check for this path already present.
                    # don't render in that case.
 #dge = (left, right, prop.key)
 #f edge in self._joinpoint:
                        # The child's prev reference might be stale --
                        # it could point to a parent older than the
                        # current joinpoint.  If this is the case,
                        # then we need to update it and then fix the
                        # tree's spine with _update_joinpoint.  Copy
                        # and then mutate the child, which might be
                        # shared by a different query object.
 #p = self._joinpoint[edge].copy()
 #p["prev"] = (edge, self._joinpoint)
 #elf._update_joinpoint(jp)

 #ontinue

 #lse:
                # no descriptor/property given; we will need to figure out
                # what the effective "left" side is
 #rop = left = None

            # figure out the final "left" and "right" sides and create an
            # ORMJoin to add to our _from_obj tuple
 #elf._join_left_to_right(
 #ntities_collection,
 #eft,
 #ight,
 #nclause,
 #rop,
 #reate_aliases,
 #liased_generation,
 #uterjoin,
 #ull,
 #

 #ef _joinpoint_zero(self):
 #eturn self._joinpoint.get("_joinpoint_entity", self._entity_zero())

 #ef _join_left_to_right(
 #elf,
 #ntities_collection,
 #eft,
 #ight,
 #nclause,
 #rop,
 #reate_aliases,
 #liased_generation,
 #uterjoin,
 #ull,
 #:
 #""given raw "left", "right", "onclause" parameters consumed from
 # particular key within _join(), add a real ORMJoin object to
 #ur _from_obj list (or augment an existing one)

 #""

 #f left is None:
            # left not given (e.g. no relationship object/name specified)
            # figure out the best "left" side based on our existing froms /
            # entities
 #ssert prop is None
 #
 #eft,
 #eplace_from_obj_index,
 #se_entity_index,
 # = self._join_determine_implicit_left_side(
 #ntities_collection, left, right, onclause
 #
 #lse:
            # left is given via a relationship/name, or as explicit left side.
            # Determine where in our
            # "froms" list it should be spliced/appended as well as what
            # existing entity it corresponds to.
 #
 #eplace_from_obj_index,
 #se_entity_index,
 # = self._join_place_explicit_left_side(entities_collection, left)

 #f left is right and not create_aliases:
 #aise sa_exc.InvalidRequestError(
 #Can't construct a join from %s to %s, they "
 #are the same entity" % (left, right)
 #

        # the right side as given often needs to be adapted.  additionally
        # a lot of things can be wrong with it.  handle all that and
        # get back the new effective "right" side
 #_info, right, onclause = self._join_check_and_adapt_right_side(
 #eft, right, onclause, prop, create_aliases, aliased_generation
 #

 #f not r_info.is_selectable:
 #xtra_criteria = self._get_extra_criteria(r_info)
 #lse:
 #xtra_criteria = ()

 #f replace_from_obj_index is not None:
            # splice into an existing element in the
            # self._from_obj list
 #eft_clause = self.from_clauses[replace_from_obj_index]

 #elf.from_clauses = (
 #elf.from_clauses[:replace_from_obj_index]
 # [
 #ORMJoin(
 #eft_clause,
 #ight,
 #nclause,
 #souter=outerjoin,
 #ull=full,
 #extra_criteria=extra_criteria,
 #
 #
 # self.from_clauses[replace_from_obj_index + 1 :]
 #
 #lse:
            # add a new element to the self._from_obj list
 #f use_entity_index is not None:
                # make use of _MapperEntity selectable, which is usually
                # entity_zero.selectable, but if with_polymorphic() were used
                # might be distinct
 #ssert isinstance(
 #ntities_collection[use_entity_index], _MapperEntity
 #
 #eft_clause = entities_collection[use_entity_index].selectable
 #lse:
 #eft_clause = left

 #elf.from_clauses = self.from_clauses + [
 #ORMJoin(
 #eft_clause,
 #_info,
 #nclause,
 #souter=outerjoin,
 #ull=full,
 #extra_criteria=extra_criteria,
 #
 #

 #ef _join_determine_implicit_left_side(
 #elf, entities_collection, left, right, onclause
 #:
 #""When join conditions don't express the left side explicitly,
 #etermine if an existing FROM or entity in this query
 #an serve as the left hand side.

 #""

        # when we are here, it means join() was called without an ORM-
        # specific way of telling us what the "left" side is, e.g.:
        #
        # join(RightEntity)
        #
        # or
        #
        # join(RightEntity, RightEntity.foo == LeftEntity.bar)
        #

 #_info = inspect(right)

 #eplace_from_obj_index = use_entity_index = None

 #f self.from_clauses:
            # we have a list of FROMs already.  So by definition this
            # join has to connect to one of those FROMs.

 #ndexes = sql_util.find_left_clause_to_join_from(
 #elf.from_clauses, r_info.selectable, onclause
 #

 #f len(indexes) == 1:
 #eplace_from_obj_index = indexes[0]
 #eft = self.from_clauses[replace_from_obj_index]
 #lif len(indexes) > 1:
 #aise sa_exc.InvalidRequestError(
 #Can't determine which FROM clause to join "
 #from, there are multiple FROMS which can "
 #join to this entity. Please use the .select_from() "
 #method to establish an explicit left side, as well as "
 #providing an explicit ON clause if not present already "
 #to help resolve the ambiguity."
 #
 #lse:
 #aise sa_exc.InvalidRequestError(
 #Don't know how to join to %r. "
 #Please use the .select_from() "
 #method to establish an explicit left side, as well as "
 #providing an explicit ON clause if not present already "
 #to help resolve the ambiguity." % (right,)
 #

 #lif entities_collection:
            # we have no explicit FROMs, so the implicit left has to
            # come from our list of entities.

 #otential = {}
 #or entity_index, ent in enumerate(entities_collection):
 #ntity = ent.entity_zero_or_selectable
 #f entity is None:
 #ontinue
 #nt_info = inspect(entity)
 #f ent_info is r_info:  # left and right are the same, skip
 #ontinue

                # by using a dictionary with the selectables as keys this
                # de-duplicates those selectables as occurs when the query is
                # against a series of columns from the same selectable
 #f isinstance(ent, _MapperEntity):
 #otential[ent.selectable] = (entity_index, entity)
 #lse:
 #otential[ent_info.selectable] = (None, entity)

 #ll_clauses = list(potential.keys())
 #ndexes = sql_util.find_left_clause_to_join_from(
 #ll_clauses, r_info.selectable, onclause
 #

 #f len(indexes) == 1:
 #se_entity_index, left = potential[all_clauses[indexes[0]]]
 #lif len(indexes) > 1:
 #aise sa_exc.InvalidRequestError(
 #Can't determine which FROM clause to join "
 #from, there are multiple FROMS which can "
 #join to this entity. Please use the .select_from() "
 #method to establish an explicit left side, as well as "
 #providing an explicit ON clause if not present already "
 #to help resolve the ambiguity."
 #
 #lse:
 #aise sa_exc.InvalidRequestError(
 #Don't know how to join to %r. "
 #Please use the .select_from() "
 #method to establish an explicit left side, as well as "
 #providing an explicit ON clause if not present already "
 #to help resolve the ambiguity." % (right,)
 #
 #lse:
 #aise sa_exc.InvalidRequestError(
 #No entities to join from; please use "
 #select_from() to establish the left "
 #entity/selectable of this join"
 #

 #eturn left, replace_from_obj_index, use_entity_index

 #ef _join_place_explicit_left_side(self, entities_collection, left):
 #""When join conditions express a left side explicitly, determine
 #here in our existing list of FROM clauses we should join towards,
 #r if we need to make a new join, and if so is it from one of our
 #xisting entities.

 #""

        # when we are here, it means join() was called with an indicator
        # as to an exact left side, which means a path to a
        # RelationshipProperty was given, e.g.:
        #
        # join(RightEntity, LeftEntity.right)
        #
        # or
        #
        # join(LeftEntity.right)
        #
        # as well as string forms:
        #
        # join(RightEntity, "right")
        #
        # etc.
        #

 #eplace_from_obj_index = use_entity_index = None

 #_info = inspect(left)
 #f self.from_clauses:
 #ndexes = sql_util.find_left_clause_that_matches_given(
 #elf.from_clauses, l_info.selectable
 #

 #f len(indexes) > 1:
 #aise sa_exc.InvalidRequestError(
 #Can't identify which entity in which to assign the "
 #left side of this join.   Please use a more specific "
 #ON clause."
 #

            # have an index, means the left side is already present in
            # an existing FROM in the self._from_obj tuple
 #f indexes:
 #eplace_from_obj_index = indexes[0]

            # no index, means we need to add a new element to the
            # self._from_obj tuple

        # no from element present, so we will have to add to the
        # self._from_obj tuple.  Determine if this left side matches up
        # with existing mapper entities, in which case we want to apply the
        # aliasing / adaptation rules present on that entity if any
 #f (
 #eplace_from_obj_index is None
 #nd entities_collection
 #nd hasattr(l_info, "mapper")
 #:
 #or idx, ent in enumerate(entities_collection):
                # TODO: should we be checking for multiple mapper entities
                # matching?
 #f isinstance(ent, _MapperEntity) and ent.corresponds_to(left):
 #se_entity_index = idx
 #reak

 #eturn replace_from_obj_index, use_entity_index

 #ef _join_check_and_adapt_right_side(
 #elf, left, right, onclause, prop, create_aliases, aliased_generation
 #:
 #""transform the "right" side of the join as well as the onclause
 #ccording to polymorphic mapping translations, aliasing on the query
 #r on the join, special cases where the right and left side have
 #verlapping tables.

 #""

 #_info = inspect(left)
 #_info = inspect(right)

 #verlap = False
 #f not create_aliases:
 #ight_mapper = getattr(r_info, "mapper", None)
            # if the target is a joined inheritance mapping,
            # be more liberal about auto-aliasing.
 #f right_mapper and (
 #ight_mapper.with_polymorphic
 #r isinstance(right_mapper.persist_selectable, expression.Join)
 #:
 #or from_obj in self.from_clauses or [l_info.selectable]:
 #f sql_util.selectables_overlap(
 #_info.selectable, from_obj
 # and sql_util.selectables_overlap(
 #rom_obj, r_info.selectable
 #:
 #verlap = True
 #reak

 #f (
 #verlap or not create_aliases
 # and l_info.selectable is r_info.selectable:
 #aise sa_exc.InvalidRequestError(
 #Can't join table/selectable '%s' to itself"
 # l_info.selectable
 #

 #ight_mapper, right_selectable, right_is_aliased = (
 #etattr(r_info, "mapper", None),
 #_info.selectable,
 #etattr(r_info, "is_aliased_class", False),
 #

 #f (
 #ight_mapper
 #nd prop
 #nd not right_mapper.common_parent(prop.mapper)
 #:
 #aise sa_exc.InvalidRequestError(
 #Join target %s does not correspond to "
 #the right side of join condition %s" % (right, onclause)
 #

        # _join_entities is used as a hint for single-table inheritance
        # purposes at the moment
 #f hasattr(r_info, "mapper"):
 #elf._join_entities += (r_info,)

 #eed_adapter = False

        # test for joining to an unmapped selectable as the target
 #f r_info.is_clause_element:

 #f prop:
 #ight_mapper = prop.mapper

 #f right_selectable._is_lateral:
                # orm_only is disabled to suit the case where we have to
                # adapt an explicit correlate(Entity) - the select() loses
                # the ORM-ness in this case right now, ideally it would not
 #urrent_adapter = self._get_current_adapter()
 #f current_adapter is not None:
                    # TODO: we had orm_only=False here before, removing
                    # it didn't break things.   if we identify the rationale,
                    # may need to apply "_orm_only" annotation here.
 #ight = current_adapter(right, True)

 #lif prop:
                # joining to selectable with a mapper property given
                # as the ON clause

 #f not right_selectable.is_derived_from(
 #ight_mapper.persist_selectable
 #:
 #aise sa_exc.InvalidRequestError(
 #Selectable '%s' is not derived from '%s'"
 # (
 #ight_selectable.description,
 #ight_mapper.persist_selectable.description,
 #
 #

                # if the destination selectable is a plain select(),
                # turn it into an alias().
 #f isinstance(right_selectable, expression.SelectBase):
 #ight_selectable = coercions.expect(
 #oles.FromClauseRole, right_selectable
 #
 #eed_adapter = True

                # make the right hand side target into an ORM entity
 #ight = aliased(right_mapper, right_selectable)
 #lif create_aliases:
                # it *could* work, but it doesn't right now and I'd rather
                # get rid of aliased=True completely
 #aise sa_exc.InvalidRequestError(
 #The aliased=True parameter on query.join() only works "
 #with an ORM entity, not a plain selectable, as the "
 #target."
 #

        # test for overlap:
        # orm/inheritance/relationships.py
        # SelfReferentialM2MTest
 #liased_entity = right_mapper and not right_is_aliased and overlap

 #f not need_adapter and (create_aliases or aliased_entity):
            # there are a few places in the ORM that automatic aliasing
            # is still desirable, and can't be automatic with a Core
            # only approach.  For illustrations of "overlaps" see
            # test/orm/inheritance/test_relationships.py.  There are also
            # general overlap cases with many-to-many tables where automatic
            # aliasing is desirable.
 #ight = aliased(right, flat=True)
 #eed_adapter = True

 #f need_adapter:
 #ssert right_mapper

 #dapter = ORMAdapter(
 #ight, equivalents=right_mapper._equivalent_columns
 #

            # if an alias() on the right side was generated,
            # which is intended to wrap a the right side in a subquery,
            # ensure that columns retrieved from this target in the result
            # set are also adapted.
 #f not create_aliases:
 #elf._mapper_loads_polymorphically_with(right_mapper, adapter)
 #lif aliased_generation:
 #dapter._debug = True
 #elf._aliased_generations[aliased_generation] = (
 #dapter,
 # + self._aliased_generations.get(aliased_generation, ())
 #lif (
 #ot r_info.is_clause_element
 #nd not right_is_aliased
 #nd right_mapper.with_polymorphic
 #nd isinstance(
 #ight_mapper._with_polymorphic_selectable,
 #xpression.AliasedReturnsRows,
 #
 #:
            # for the case where the target mapper has a with_polymorphic
            # set up, ensure an adapter is set up for criteria that works
            # against this mapper.  Previously, this logic used to
            # use the "create_aliases or aliased_entity" case to generate
            # an aliased() object, but this creates an alias that isn't
            # strictly necessary.
            # see test/orm/test_core_compilation.py
            # ::RelNaturalAliasedJoinsTest::test_straight
            # and similar
 #elf._mapper_loads_polymorphically_with(
 #ight_mapper,
 #ql_util.ColumnAdapter(
 #ight_mapper.selectable,
 #ight_mapper._equivalent_columns,
 #,
 #
        # if the onclause is a ClauseElement, adapt it with any
        # adapters that are in place right now
 #f isinstance(onclause, expression.ClauseElement):
 #urrent_adapter = self._get_current_adapter()
 #f current_adapter:
 #nclause = current_adapter(onclause, True)

        # if joining on a MapperProperty path,
        # track the path to prevent redundant joins
 #f not create_aliases and prop:
 #elf._update_joinpoint(
 #
 #_joinpoint_entity": right,
 #prev": ((left, right, prop.key), self._joinpoint),
 #aliased_generation": aliased_generation,
 #
 #
 #lse:
 #elf._joinpoint = {
 #_joinpoint_entity": right,
 #aliased_generation": aliased_generation,
 #

 #eturn inspect(right), right, onclause

 #ef _update_joinpoint(self, jp):
 #elf._joinpoint = jp
        # copy backwards to the root of the _joinpath
        # dict, so that no existing dict in the path is mutated
 #hile "prev" in jp:
 #, prev = jp["prev"]
 #rev = dict(prev)
 #rev[f] = jp.copy()
 #p["prev"] = (f, prev)
 #p = prev
 #elf._joinpath = jp

 #ef _reset_joinpoint(self):
 #elf._joinpoint = self._joinpath

 #property
 #ef _select_args(self):
 #eturn {
 #limit_clause": self.select_statement._limit_clause,
 #offset_clause": self.select_statement._offset_clause,
 #distinct": self.distinct,
 #distinct_on": self.distinct_on,
 #prefixes": self.select_statement._prefixes,
 #suffixes": self.select_statement._suffixes,
 #group_by": self.group_by or None,
 #

 #property
 #ef _should_nest_selectable(self):
 #wargs = self._select_args
 #eturn (
 #wargs.get("limit_clause") is not None
 #r kwargs.get("offset_clause") is not None
 #r kwargs.get("distinct", False)
 #r kwargs.get("distinct_on", ())
 #r kwargs.get("group_by", False)
 #

 #ef _get_extra_criteria(self, ext_info):
 #f (
 #additional_entity_criteria",
 #xt_info.mapper,
 # in self.global_attributes:
 #eturn tuple(
 #e._resolve_where_criteria(ext_info)
 #or ae in self.global_attributes[
 #"additional_entity_criteria", ext_info.mapper)
 #
 #f ae.include_aliases or ae.entity is ext_info
 #
 #lse:
 #eturn ()

 #ef _adjust_for_extra_criteria(self):
 #""Apply extra criteria filtering.

 #or all distinct single-table-inheritance mappers represented in
 #he columns clause of this query, as well as the "select from entity",
 #dd criterion to the WHERE
 #lause of the given QueryContext such that only the appropriate
 #ubtypes are selected from the total results.

 #dditionally, add WHERE criteria originating from LoaderCriteriaOptions
 #ssociated with the global context.

 #""

 #or fromclause in self.from_clauses:
 #xt_info = fromclause._annotations.get("parententity", None)
 #f (
 #xt_info
 #nd (
 #xt_info.mapper._single_table_criterion is not None
 #r ("additional_entity_criteria", ext_info.mapper)
 #n self.global_attributes
 #
 #nd ext_info not in self.extra_criteria_entities
 #:

 #elf.extra_criteria_entities[ext_info] = (
 #xt_info,
 #xt_info._adapter if ext_info.is_aliased_class else None,
 #

 #earch = set(self.extra_criteria_entities.values())

 #or (ext_info, adapter) in search:
 #f ext_info in self._join_entities:
 #ontinue

 #ingle_crit = ext_info.mapper._single_table_criterion

 #dditional_entity_criteria = self._get_extra_criteria(ext_info)

 #f single_crit is not None:
 #dditional_entity_criteria += (single_crit,)

 #urrent_adapter = self._get_current_adapter()
 #or crit in additional_entity_criteria:
 #f adapter:
 #rit = adapter.traverse(crit)

 #f current_adapter:
 #rit = sql_util._deep_annotate(crit, {"_orm_adapt": True})
 #rit = current_adapter(crit, False)
 #elf._where_criteria += (crit,)


def _column_descriptions(
 #uery_or_select_stmt, compile_state=None, legacy=False
):
 #f compile_state is None:
 #ompile_state = ORMSelectCompileState._create_entities_collection(
 #uery_or_select_stmt, legacy=legacy
 #
 #tx = compile_state
 #eturn [
 #
 #name": ent._label_name,
 #type": ent.type,
 #aliased": getattr(insp_ent, "is_aliased_class", False),
 #expr": ent.expr,
 #entity": getattr(insp_ent, "entity", None)
 #f ent.entity_zero is not None and not insp_ent.is_clause_element
 #lse None,
 #
 #or ent, insp_ent in [
 #
 #ent,
 #
 #nspect(_ent.entity_zero)
 #f _ent.entity_zero is not None
 #lse None
 #,
 #
 #or _ent in ctx._entities
 #
 #


def _legacy_filter_by_entity_zero(query_or_augmented_select):
 #elf = query_or_augmented_select
 #f self._legacy_setup_joins:
 #last_joined_entity = self._last_joined_entity
 #f _last_joined_entity is not None:
 #eturn _last_joined_entity

 #f self._from_obj and "parententity" in self._from_obj[0]._annotations:
 #eturn self._from_obj[0]._annotations["parententity"]

 #eturn _entity_from_pre_ent_zero(self)


def _entity_from_pre_ent_zero(query_or_augmented_select):
 #elf = query_or_augmented_select
 #f not self._raw_columns:
 #eturn None

 #nt = self._raw_columns[0]

 #f "parententity" in ent._annotations:
 #eturn ent._annotations["parententity"]
 #lif isinstance(ent, ORMColumnsClauseRole):
 #eturn ent.entity
 #lif "bundle" in ent._annotations:
 #eturn ent._annotations["bundle"]
 #lse:
 #eturn ent


def _legacy_determine_last_joined_entity(setup_joins, entity_zero):
 #""given the legacy_setup_joins collection at a point in time,
 #igure out what the "filter by entity" would be in terms
 #f those joins.

 #n 2.0 this logic should hopefully be much simpler as there will
 #e far fewer ways to specify joins with the ORM

 #""

 #f not setup_joins:
 #eturn entity_zero

    # CAN BE REMOVED IN 2.0:
    # 1. from_joinpoint
    # 2. aliased_generation
    # 3. aliased
    # 4. any treating of prop as str
    # 5. tuple madness
    # 6. won't need recursive call anymore without #4
    # 7. therefore can pass in just the last setup_joins record,
    #    don't need entity_zero

 #right, onclause, left_, flags) = setup_joins[-1]

 #rom_joinpoint = flags["from_joinpoint"]

 #f onclause is None and isinstance(
 #ight, (str, interfaces.PropComparator)
 #:
 #nclause = right
 #ight = None

 #f right is not None and "parententity" in right._annotations:
 #ight = right._annotations["parententity"].entity

 #f right is not None:
 #ast_entity = right
 #nsp = inspect(last_entity)
 #f insp.is_clause_element or insp.is_aliased_class or insp.is_mapper:
 #eturn insp

 #ast_entity = onclause
 #f isinstance(last_entity, interfaces.PropComparator):
 #eturn last_entity.entity

    # legacy vvvvvvvvvvvvvvvvvvvvvvvvvvv
 #f isinstance(onclause, str):
 #f from_joinpoint:
 #rev = _legacy_determine_last_joined_entity(
 #etup_joins[0:-1], entity_zero
 #
 #lse:
 #rev = entity_zero

 #f prev is None:
 #eturn None

 #rev = inspect(prev)
 #ttr = getattr(prev.entity, onclause, None)
 #f attr is not None:
 #eturn attr.property.entity
    # legacy ^^^^^^^^^^^^^^^^^^^^^^^^^^^

 #eturn None


class _QueryEntity(object):
 #""represent an entity column returned within a Query result."""

 #_slots__ = ()

 #non_hashable_value = False
 #null_column_type = False
 #se_id_for_hash = False

 #classmethod
 #ef to_compile_state(cls, compile_state, entities, entities_collection):

 #or idx, entity in enumerate(entities):
 #f entity._is_lambda_element:
 #f entity._is_sequence:
 #ls.to_compile_state(
 #ompile_state, entity._resolved, entities_collection
 #
 #ontinue
 #lse:
 #ntity = entity._resolved

 #f entity.is_clause_element:
 #f entity.is_selectable:
 #f "parententity" in entity._annotations:
 #MapperEntity(
 #ompile_state, entity, entities_collection
 #
 #lse:
 #ColumnEntity._for_columns(
 #ompile_state,
 #ntity._select_iterable,
 #ntities_collection,
 #dx,
 #
 #lse:
 #f entity._annotations.get("bundle", False):
 #BundleEntity(
 #ompile_state, entity, entities_collection
 #
 #lif entity._is_clause_list:
                        # this is legacy only - test_composites.py
                        # test_query_cols_legacy
 #ColumnEntity._for_columns(
 #ompile_state,
 #ntity._select_iterable,
 #ntities_collection,
 #dx,
 #
 #lse:
 #ColumnEntity._for_columns(
 #ompile_state, [entity], entities_collection, idx
 #
 #lif entity.is_bundle:
 #BundleEntity(compile_state, entity, entities_collection)

 #eturn entities_collection


class _MapperEntity(_QueryEntity):
 #""mapper/class/AliasedClass entity"""

 #_slots__ = (
 #expr",
 #mapper",
 #entity_zero",
 #is_aliased_class",
 #path",
 #_extra_entities",
 #_label_name",
 #_with_polymorphic_mappers",
 #selectable",
 #_polymorphic_discriminator",
 #

 #ef __init__(self, compile_state, entity, entities_collection):
 #ntities_collection.append(self)
 #f compile_state._primary_entity is None:
 #ompile_state._primary_entity = self
 #ompile_state._has_mapper_entities = True
 #ompile_state._has_orm_entities = True

 #ntity = entity._annotations["parententity"]
 #ntity._post_inspect
 #xt_info = self.entity_zero = entity
 #ntity = ext_info.entity

 #elf.expr = entity
 #elf.mapper = mapper = ext_info.mapper

 #elf._extra_entities = (self.expr,)

 #f ext_info.is_aliased_class:
 #elf._label_name = ext_info.name
 #lse:
 #elf._label_name = mapper.class_.__name__

 #elf.is_aliased_class = ext_info.is_aliased_class
 #elf.path = ext_info._path_registry

 #f ext_info in compile_state._with_polymorphic_adapt_map:
            # this codepath occurs only if query.with_polymorphic() were
            # used

 #p = inspect(compile_state._with_polymorphic_adapt_map[ext_info])

 #f self.is_aliased_class:
                # TODO: invalidrequest ?
 #aise NotImplementedError(
 #Can't use with_polymorphic() against an Aliased object"
 #

 #appers, from_obj = mapper._with_polymorphic_args(
 #p.with_polymorphic_mappers, wp.selectable
 #

 #elf._with_polymorphic_mappers = mappers
 #elf.selectable = from_obj
 #elf._polymorphic_discriminator = wp.polymorphic_on

 #lse:
 #elf.selectable = ext_info.selectable
 #elf._with_polymorphic_mappers = ext_info.with_polymorphic_mappers
 #elf._polymorphic_discriminator = ext_info.polymorphic_on

 #f (
 #apper.with_polymorphic
                # controversy - only if inheriting mapper is also
                # polymorphic?
                # or (mapper.inherits and mapper.inherits.with_polymorphic)
 #r mapper.inherits
 #r mapper._requires_row_aliasing
 #:
 #ompile_state._create_with_polymorphic_adapter(
 #xt_info, self.selectable
 #

 #upports_single_entity = True

 #non_hashable_value = True
 #se_id_for_hash = True

 #property
 #ef type(self):
 #eturn self.mapper.class_

 #property
 #ef entity_zero_or_selectable(self):
 #eturn self.entity_zero

 #ef corresponds_to(self, entity):
 #eturn _entity_corresponds_to(self.entity_zero, entity)

 #ef _get_entity_clauses(self, compile_state):

 #dapter = None

 #f not self.is_aliased_class:
 #f compile_state._polymorphic_adapters:
 #dapter = compile_state._polymorphic_adapters.get(
 #elf.mapper, None
 #
 #lse:
 #dapter = self.entity_zero._adapter

 #f adapter:
 #f compile_state._from_obj_alias:
 #et = adapter.wrap(compile_state._from_obj_alias)
 #lse:
 #et = adapter
 #lse:
 #et = compile_state._from_obj_alias

 #eturn ret

 #ef row_processor(self, context, result):
 #ompile_state = context.compile_state
 #dapter = self._get_entity_clauses(compile_state)

 #f compile_state.compound_eager_adapter and adapter:
 #dapter = adapter.wrap(compile_state.compound_eager_adapter)
 #lif not adapter:
 #dapter = compile_state.compound_eager_adapter

 #f compile_state._primary_entity is self:
 #nly_load_props = compile_state.compile_options._only_load_props
 #efresh_state = context.refresh_state
 #lse:
 #nly_load_props = refresh_state = None

 #instance = loading._instance_processor(
 #elf,
 #elf.mapper,
 #ontext,
 #esult,
 #elf.path,
 #dapter,
 #nly_load_props=only_load_props,
 #efresh_state=refresh_state,
 #olymorphic_discriminator=self._polymorphic_discriminator,
 #

 #eturn _instance, self._label_name, self._extra_entities

 #ef setup_compile_state(self, compile_state):

 #dapter = self._get_entity_clauses(compile_state)

 #ingle_table_crit = self.mapper._single_table_criterion
 #f (
 #ingle_table_crit is not None
 #r ("additional_entity_criteria", self.mapper)
 #n compile_state.global_attributes
 #:
 #xt_info = self.entity_zero
 #ompile_state.extra_criteria_entities[ext_info] = (
 #xt_info,
 #xt_info._adapter if ext_info.is_aliased_class else None,
 #

 #oading._setup_entity_query(
 #ompile_state,
 #elf.mapper,
 #elf,
 #elf.path,
 #dapter,
 #ompile_state.primary_columns,
 #ith_polymorphic=self._with_polymorphic_mappers,
 #nly_load_props=compile_state.compile_options._only_load_props,
 #olymorphic_discriminator=self._polymorphic_discriminator,
 #

 #ompile_state._fallback_from_clauses.append(self.selectable)


class _BundleEntity(_QueryEntity):

 #extra_entities = ()

 #_slots__ = (
 #bundle",
 #expr",
 #type",
 #_label_name",
 #_entities",
 #supports_single_entity",
 #

 #ef __init__(
 #elf,
 #ompile_state,
 #xpr,
 #ntities_collection,
 #etup_entities=True,
 #arent_bundle=None,
 #:
 #ompile_state._has_orm_entities = True

 #xpr = expr._annotations["bundle"]
 #f parent_bundle:
 #arent_bundle._entities.append(self)
 #lse:
 #ntities_collection.append(self)

 #f isinstance(
 #xpr, (attributes.QueryableAttribute, interfaces.PropComparator)
 #:
 #undle = expr.__clause_element__()
 #lse:
 #undle = expr

 #elf.bundle = self.expr = bundle
 #elf.type = type(bundle)
 #elf._label_name = bundle.name
 #elf._entities = []

 #f setup_entities:
 #or expr in bundle.exprs:
 #f "bundle" in expr._annotations:
 #BundleEntity(
 #ompile_state,
 #xpr,
 #ntities_collection,
 #arent_bundle=self,
 #
 #lif isinstance(expr, Bundle):
 #BundleEntity(
 #ompile_state,
 #xpr,
 #ntities_collection,
 #arent_bundle=self,
 #
 #lse:
 #ORMColumnEntity._for_columns(
 #ompile_state,
 #expr],
 #ntities_collection,
 #one,
 #arent_bundle=self,
 #

 #elf.supports_single_entity = self.bundle.single_entity
 #f (
 #elf.supports_single_entity
 #nd not compile_state.compile_options._use_legacy_query_style
 #:
 #til.warn_deprecated_20(
 #The Bundle.single_entity flag has no effect when "
 #using 2.0 style execution."
 #

 #property
 #ef mapper(self):
 #zero = self.entity_zero
 #f ezero is not None:
 #eturn ezero.mapper
 #lse:
 #eturn None

 #property
 #ef entity_zero(self):
 #or ent in self._entities:
 #zero = ent.entity_zero
 #f ezero is not None:
 #eturn ezero
 #lse:
 #eturn None

 #ef corresponds_to(self, entity):
        # TODO: we might be able to implement this but for now
        # we are working around it
 #eturn False

 #property
 #ef entity_zero_or_selectable(self):
 #or ent in self._entities:
 #zero = ent.entity_zero_or_selectable
 #f ezero is not None:
 #eturn ezero
 #lse:
 #eturn None

 #ef setup_compile_state(self, compile_state):
 #or ent in self._entities:
 #nt.setup_compile_state(compile_state)

 #ef row_processor(self, context, result):
 #rocs, labels, extra = zip(
 #[ent.row_processor(context, result) for ent in self._entities]
 #

 #roc = self.bundle.create_row_processor(context.query, procs, labels)

 #eturn proc, self._label_name, self._extra_entities


class _ColumnEntity(_QueryEntity):
 #_slots__ = (
 #_fetch_column",
 #_row_processor",
 #raw_column_index",
 #translate_raw_column",
 #

 #classmethod
 #ef _for_columns(
 #ls,
 #ompile_state,
 #olumns,
 #ntities_collection,
 #aw_column_index,
 #arent_bundle=None,
 #:
 #or column in columns:
 #nnotations = column._annotations
 #f "parententity" in annotations:
 #entity = annotations["parententity"]
 #lse:
 #entity = sql_util.extract_first_column_annotation(
 #olumn, "parententity"
 #

 #f _entity:
 #f "identity_token" in column._annotations:
 #IdentityTokenEntity(
 #ompile_state,
 #olumn,
 #ntities_collection,
 #entity,
 #aw_column_index,
 #arent_bundle=parent_bundle,
 #
 #lse:
 #ORMColumnEntity(
 #ompile_state,
 #olumn,
 #ntities_collection,
 #entity,
 #aw_column_index,
 #arent_bundle=parent_bundle,
 #
 #lse:
 #RawColumnEntity(
 #ompile_state,
 #olumn,
 #ntities_collection,
 #aw_column_index,
 #arent_bundle=parent_bundle,
 #

 #property
 #ef type(self):
 #eturn self.column.type

 #property
 #ef _non_hashable_value(self):
 #eturn not self.column.type.hashable

 #property
 #ef _null_column_type(self):
 #eturn self.column.type._isnull

 #ef row_processor(self, context, result):
 #ompile_state = context.compile_state

        # the resulting callable is entirely cacheable so just return
        # it if we already made one
 #f self._row_processor is not None:
 #etter, label_name, extra_entities = self._row_processor
 #f self.translate_raw_column:
 #xtra_entities += (
 #esult.context.invoked_statement._raw_columns[
 #elf.raw_column_index
 #,
 #

 #eturn getter, label_name, extra_entities

        # retrieve the column that would have been set up in
        # setup_compile_state, to avoid doing redundant work
 #f self._fetch_column is not None:
 #olumn = self._fetch_column
 #lse:
            # fetch_column will be None when we are doing a from_statement
            # and setup_compile_state may not have been called.
 #olumn = self.column

            # previously, the RawColumnEntity didn't look for from_obj_alias
            # however I can't think of a case where we would be here and
            # we'd want to ignore it if this is the from_statement use case.
            # it's not really a use case to have raw columns + from_statement
 #f compile_state._from_obj_alias:
 #olumn = compile_state._from_obj_alias.columns[column]

 #f column._annotations:
                # annotated columns perform more slowly in compiler and
                # result due to the __eq__() method, so use deannotated
 #olumn = column._deannotate()

 #f compile_state.compound_eager_adapter:
 #olumn = compile_state.compound_eager_adapter.columns[column]

 #etter = result._getter(column)

 #et = getter, self._label_name, self._extra_entities
 #elf._row_processor = ret

 #f self.translate_raw_column:
 #xtra_entities = self._extra_entities + (
 #esult.context.invoked_statement._raw_columns[
 #elf.raw_column_index
 #,
 #
 #eturn getter, self._label_name, extra_entities
 #lse:
 #eturn ret


class _RawColumnEntity(_ColumnEntity):
 #ntity_zero = None
 #apper = None
 #upports_single_entity = False

 #_slots__ = (
 #expr",
 #column",
 #_label_name",
 #entity_zero_or_selectable",
 #_extra_entities",
 #

 #ef __init__(
 #elf,
 #ompile_state,
 #olumn,
 #ntities_collection,
 #aw_column_index,
 #arent_bundle=None,
 #:
 #elf.expr = column
 #elf.raw_column_index = raw_column_index
 #elf.translate_raw_column = raw_column_index is not None
 #f column._is_text_clause:
 #elf._label_name = None
 #lse:
 #elf._label_name = compile_state._label_convention(column)

 #f parent_bundle:
 #arent_bundle._entities.append(self)
 #lse:
 #ntities_collection.append(self)

 #elf.column = column
 #elf.entity_zero_or_selectable = (
 #elf.column._from_objects[0] if self.column._from_objects else None
 #
 #elf._extra_entities = (self.expr, self.column)
 #elf._fetch_column = self._row_processor = None

 #ef corresponds_to(self, entity):
 #eturn False

 #ef setup_compile_state(self, compile_state):
 #urrent_adapter = compile_state._get_current_adapter()
 #f current_adapter:
 #olumn = current_adapter(self.column, False)
 #lse:
 #olumn = self.column

 #f column._annotations:
            # annotated columns perform more slowly in compiler and
            # result due to the __eq__() method, so use deannotated
 #olumn = column._deannotate()

 #ompile_state.primary_columns.append(column)
 #elf._fetch_column = column


class _ORMColumnEntity(_ColumnEntity):
 #""Column/expression based entity."""

 #upports_single_entity = False

 #_slots__ = (
 #expr",
 #mapper",
 #column",
 #_label_name",
 #entity_zero_or_selectable",
 #entity_zero",
 #_extra_entities",
 #

 #ef __init__(
 #elf,
 #ompile_state,
 #olumn,
 #ntities_collection,
 #arententity,
 #aw_column_index,
 #arent_bundle=None,
 #:
 #nnotations = column._annotations

 #entity = parententity

        # an AliasedClass won't have proxy_key in the annotations for
        # a column if it was acquired using the class' adapter directly,
        # such as using AliasedInsp._adapt_element().  this occurs
        # within internal loaders.

 #rm_key = annotations.get("proxy_key", None)
 #roxy_owner = annotations.get("proxy_owner", _entity)
 #f orm_key:
 #elf.expr = getattr(proxy_owner.entity, orm_key)
 #elf.translate_raw_column = False
 #lse:
            # if orm_key is not present, that means this is an ad-hoc
            # SQL ColumnElement, like a CASE() or other expression.
            # include this column position from the invoked statement
            # in the ORM-level ResultSetMetaData on each execute, so that
            # it can be targeted by identity after caching
 #elf.expr = column
 #elf.translate_raw_column = raw_column_index is not None

 #elf.raw_column_index = raw_column_index
 #elf._label_name = compile_state._label_convention(
 #olumn, col_name=orm_key
 #

 #entity._post_inspect
 #elf.entity_zero = self.entity_zero_or_selectable = ezero = _entity
 #elf.mapper = mapper = _entity.mapper

 #f parent_bundle:
 #arent_bundle._entities.append(self)
 #lse:
 #ntities_collection.append(self)

 #ompile_state._has_orm_entities = True

 #elf.column = column

 #elf._fetch_column = self._row_processor = None

 #elf._extra_entities = (self.expr, self.column)

 #f (
 #apper.with_polymorphic
 #r mapper.inherits
 #r mapper._requires_row_aliasing
 #:
 #ompile_state._create_with_polymorphic_adapter(
 #zero, ezero.selectable
 #

 #ef corresponds_to(self, entity):
 #f _is_aliased_class(entity):
            # TODO: polymorphic subclasses ?
 #eturn entity is self.entity_zero
 #lse:
 #eturn not _is_aliased_class(
 #elf.entity_zero
 # and entity.common_parent(self.entity_zero)

 #ef setup_compile_state(self, compile_state):
 #urrent_adapter = compile_state._get_current_adapter()
 #f current_adapter:
 #olumn = current_adapter(self.column, False)
 #lse:
 #olumn = self.column

 #zero = self.entity_zero

 #ingle_table_crit = self.mapper._single_table_criterion
 #f (
 #ingle_table_crit is not None
 #r ("additional_entity_criteria", self.mapper)
 #n compile_state.global_attributes
 #:

 #ompile_state.extra_criteria_entities[ezero] = (
 #zero,
 #zero._adapter if ezero.is_aliased_class else None,
 #

 #f column._annotations and not column._expression_label:
            # annotated columns perform more slowly in compiler and
            # result due to the __eq__() method, so use deannotated
 #olumn = column._deannotate()

        # use entity_zero as the from if we have it. this is necessary
        # for polymorphic scenarios where our FROM is based on ORM entity,
        # not the FROM of the column.  but also, don't use it if our column
        # doesn't actually have any FROMs that line up, such as when its
        # a scalar subquery.
 #f set(self.column._from_objects).intersection(
 #zero.selectable._from_objects
 #:
 #ompile_state._fallback_from_clauses.append(ezero.selectable)

 #ompile_state.primary_columns.append(column)
 #elf._fetch_column = column


class _IdentityTokenEntity(_ORMColumnEntity):
 #ranslate_raw_column = False

 #ef setup_compile_state(self, compile_state):
 #ass

 #ef row_processor(self, context, result):
 #ef getter(row):
 #eturn context.load_options._refresh_identity_token

 #eturn getter, self._label_name, self._extra_entities
