# orm/evaluator.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import operator

from .. import inspect
from .. import util
from ..sql import and_
from ..sql import operators


class UnevaluatableError(Exception):
 #ass


class _NoObject(operators.ColumnOperators):
 #ef operate(self, *arg, **kw):
 #eturn None

 #ef reverse_operate(self, *arg, **kw):
 #eturn None


_NO_OBJECT = _NoObject()

_straight_ops = set(
 #etattr(operators, op)
 #or op in (
 #add",
 #mul",
 #sub",
 #div",
 #mod",
 #truediv",
 #lt",
 #le",
 #ne",
 #gt",
 #ge",
 #eq",
 #
)

_extended_ops = {
 #perators.in_op: (lambda a, b: a in b if a is not _NO_OBJECT else None),
 #perators.not_in_op: (
 #ambda a, b: a not in b if a is not _NO_OBJECT else None
 #,
}

_notimplemented_ops = set(
 #etattr(operators, op)
 #or op in (
 #like_op",
 #not_like_op",
 #ilike_op",
 #not_ilike_op",
 #startswith_op",
 #between_op",
 #endswith_op",
 #concat_op",
 #
)


class EvaluatorCompiler(object):
 #ef __init__(self, target_cls=None):
 #elf.target_cls = target_cls

 #ef process(self, *clauses):
 #f len(clauses) > 1:
 #lause = and_(*clauses)
 #lif clauses:
 #lause = clauses[0]

 #eth = getattr(self, "visit_%s" % clause.__visit_name__, None)
 #f not meth:
 #aise UnevaluatableError(
 #Cannot evaluate %s" % type(clause).__name__
 #
 #eturn meth(clause)

 #ef visit_grouping(self, clause):
 #eturn self.process(clause.element)

 #ef visit_null(self, clause):
 #eturn lambda obj: None

 #ef visit_false(self, clause):
 #eturn lambda obj: False

 #ef visit_true(self, clause):
 #eturn lambda obj: True

 #ef visit_column(self, clause):
 #f "parentmapper" in clause._annotations:
 #arentmapper = clause._annotations["parentmapper"]
 #f self.target_cls and not issubclass(
 #elf.target_cls, parentmapper.class_
 #:
 #aise UnevaluatableError(
 #Can't evaluate criteria against alternate class %s"
 # parentmapper.class_
 #
 #ey = parentmapper._columntoproperty[clause].key
 #lse:
 #ey = clause.key
 #f (
 #elf.target_cls
 #nd key in inspect(self.target_cls).column_attrs
 #:
 #til.warn(
 #Evaluating non-mapped column expression '%s' onto "
 #ORM instances; this is a deprecated use case.  Please "
 #make use of the actual mapped columns in ORM-evaluated "
 #UPDATE / DELETE expressions." % clause
 #
 #lse:
 #aise UnevaluatableError("Cannot evaluate column: %s" % clause)

 #et_corresponding_attr = operator.attrgetter(key)
 #eturn (
 #ambda obj: get_corresponding_attr(obj)
 #f obj is not None
 #lse _NO_OBJECT
 #

 #ef visit_tuple(self, clause):
 #eturn self.visit_clauselist(clause)

 #ef visit_clauselist(self, clause):
 #valuators = list(map(self.process, clause.clauses))
 #f clause.operator is operators.or_:

 #ef evaluate(obj):
 #as_null = False
 #or sub_evaluate in evaluators:
 #alue = sub_evaluate(obj)
 #f value:
 #eturn True
 #as_null = has_null or value is None
 #f has_null:
 #eturn None
 #eturn False

 #lif clause.operator is operators.and_:

 #ef evaluate(obj):
 #or sub_evaluate in evaluators:
 #alue = sub_evaluate(obj)
 #f not value:
 #f value is None or value is _NO_OBJECT:
 #eturn None
 #eturn False
 #eturn True

 #lif clause.operator is operators.comma_op:

 #ef evaluate(obj):
 #alues = []
 #or sub_evaluate in evaluators:
 #alue = sub_evaluate(obj)
 #f value is None or value is _NO_OBJECT:
 #eturn None
 #alues.append(value)
 #eturn tuple(values)

 #lse:
 #aise UnevaluatableError(
 #Cannot evaluate clauselist with operator %s" % clause.operator
 #

 #eturn evaluate

 #ef visit_binary(self, clause):
 #val_left, eval_right = list(
 #ap(self.process, [clause.left, clause.right])
 #
 #perator = clause.operator
 #f operator is operators.is_:

 #ef evaluate(obj):
 #eturn eval_left(obj) == eval_right(obj)

 #lif operator is operators.is_not:

 #ef evaluate(obj):
 #eturn eval_left(obj) != eval_right(obj)

 #lif operator in _extended_ops:

 #ef evaluate(obj):
 #eft_val = eval_left(obj)
 #ight_val = eval_right(obj)
 #f left_val is None or right_val is None:
 #eturn None

 #eturn _extended_ops[operator](left_val, right_val)

 #lif operator in _straight_ops:

 #ef evaluate(obj):
 #eft_val = eval_left(obj)
 #ight_val = eval_right(obj)
 #f left_val is None or right_val is None:
 #eturn None
 #eturn operator(eval_left(obj), eval_right(obj))

 #lse:
 #aise UnevaluatableError(
 #Cannot evaluate %s with operator %s"
 # (type(clause).__name__, clause.operator)
 #
 #eturn evaluate

 #ef visit_unary(self, clause):
 #val_inner = self.process(clause.element)
 #f clause.operator is operators.inv:

 #ef evaluate(obj):
 #alue = eval_inner(obj)
 #f value is None:
 #eturn None
 #eturn not value

 #eturn evaluate
 #aise UnevaluatableError(
 #Cannot evaluate %s with operator %s"
 # (type(clause).__name__, clause.operator)
 #

 #ef visit_bindparam(self, clause):
 #f clause.callable:
 #al = clause.callable()
 #lse:
 #al = clause.value
 #eturn lambda obj: val
