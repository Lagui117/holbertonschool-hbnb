# ext/declarative/api.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""Public API functions and helpers for declarative."""
from __future__ import absolute_import

import itertools
import re
import weakref

from . import attributes
from . import clsregistry
from . import exc as orm_exc
from . import instrumentation
from . import interfaces
from . import mapper as mapperlib
from .base import _inspect_mapped_class
from .decl_base import _add_attribute
from .decl_base import _as_declarative
from .decl_base import _declarative_constructor
from .decl_base import _DeferredMapperConfig
from .decl_base import _del_attribute
from .decl_base import _mapper
from .descriptor_props import SynonymProperty as _orm_synonym
from .. import exc
from .. import inspection
from .. import util
from ..sql.schema import MetaData
from ..util import hybridmethod
from ..util import hybridproperty


def has_inherited_table(cls):
 #""Given a class, return True if any of the classes it inherits from has a
 #apped table, otherwise return False.

 #his is used in declarative mixins to build attributes that behave
 #ifferently for the base class vs. a subclass in an inheritance
 #ierarchy.

 #. seealso::

 #ref:`decl_mixin_inheritance`

 #""
 #or class_ in cls.__mro__[1:]:
 #f getattr(class_, "__table__", None) is not None:
 #eturn True
 #eturn False


class DeclarativeMeta(type):
 #ef __init__(cls, classname, bases, dict_, **kw):
        # early-consume registry from the initial declarative base,
        # assign privately to not conflict with subclass attributes named
        # "registry"
 #eg = getattr(cls, "_sa_registry", None)
 #f reg is None:
 #eg = dict_.get("registry", None)
 #f not isinstance(reg, registry):
 #aise exc.InvalidRequestError(
 #Declarative base class has no 'registry' attribute, "
 #or registry is not a sqlalchemy.orm.registry() object"
 #
 #lse:
 #ls._sa_registry = reg

 #f not cls.__dict__.get("__abstract__", False):
 #as_declarative(reg, cls, dict_)
 #ype.__init__(cls, classname, bases, dict_)

 #ef __setattr__(cls, key, value):
 #add_attribute(cls, key, value)

 #ef __delattr__(cls, key):
 #del_attribute(cls, key)


def synonym_for(name, map_column=False):
 #""Decorator that produces an :func:`_orm.synonym`
 #ttribute in conjunction with a Python descriptor.

 #he function being decorated is passed to :func:`_orm.synonym` as the
 #paramref:`.orm.synonym.descriptor` parameter::

 #lass MyClass(Base):
 #_tablename__ = 'my_table'

 #d = Column(Integer, primary_key=True)
 #job_status = Column("job_status", String(50))

 #synonym_for("job_status")
 #property
 #ef job_status(self):
 #eturn "Status: %s" % self._job_status

 #he :ref:`hybrid properties <mapper_hybrids>` feature of SQLAlchemy
 #s typically preferred instead of synonyms, which is a more legacy
 #eature.

 #. seealso::

 #ref:`synonyms` - Overview of synonyms

 #func:`_orm.synonym` - the mapper-level function

 #ref:`mapper_hybrids` - The Hybrid Attribute extension provides an
 #pdated approach to augmenting attribute behavior more flexibly than
 #an be achieved with synonyms.

 #""

 #ef decorate(fn):
 #eturn _orm_synonym(name, map_column=map_column, descriptor=fn)

 #eturn decorate


class declared_attr(interfaces._MappedAttribute, property):
 #""Mark a class-level method as representing the definition of
 # mapped property or special declarative member name.

 #class:`_orm.declared_attr` is typically applied as a decorator to a class
 #evel method, turning the attribute into a scalar-like property that can be
 #nvoked from the uninstantiated class. The Declarative mapping process
 #ooks for these :class:`_orm.declared_attr` callables as it scans classe,
 #nd assumes any attribute marked with :class:`_orm.declared_attr` will be a
 #allable that will produce an object specific to the Declarative mapping or
 #able configuration.

 #class:`_orm.declared_attr` is usually applicable to mixins, to define
 #elationships that are to be applied to different implementors of the
 #lass. It is also used to define :class:`_schema.Column` objects that
 #nclude the :class:`_schema.ForeignKey` construct, as these cannot be
 #asily reused across different mappings.  The example below illustrates
 #oth::

 #lass ProvidesUser(object):
 #A mixin that adds a 'user' relationship to classes."

 #declared_attr
 #ef user_id(self):
 #eturn Column(ForeignKey("user_account.id"))

 #declared_attr
 #ef user(self):
 #eturn relationship("User")

 #class:`_orm.declared_attr` can also be applied to mapped classes, such as
 #o provide a "polymorphic" scheme for inheritance::

 #lass Employee(Base):
 #d = Column(Integer, primary_key=True)
 #ype = Column(String(50), nullable=False)

 #declared_attr
 #ef __tablename__(cls):
 #eturn cls.__name__.lower()

 #declared_attr
 #ef __mapper_args__(cls):
 #f cls.__name__ == 'Employee':
 #eturn {
 #polymorphic_on":cls.type,
 #polymorphic_identity":"Employee"
 #
 #lse:
 #eturn {"polymorphic_identity":cls.__name__}

 #o use :class:`_orm.declared_attr` inside of a Python dataclass
 #s discussed at :ref:`orm_declarative_dataclasses_declarative_table`,
 #t may be placed directly inside the field metadata using a lambda::

 #dataclass
 #lass AddressMixin:
 #_sa_dataclass_metadata_key__ = "sa"

 #ser_id: int = field(
 #nit=False, metadata={"sa": declared_attr(lambda: Column(ForeignKey("user.id")))}
 #
 #ser: User = field(
 #nit=False, metadata={"sa": declared_attr(lambda: relationship(User))}
 #

 #class:`_orm.declared_attr` also may be omitted from this form using a
 #ambda directly, as in::

 #ser: User = field(
 #nit=False, metadata={"sa": lambda: relationship(User)}
 #

 #. seealso::

 #ref:`orm_mixins_toplevel` - illustrates how to use Declarative Mixins
 #hich is the primary use case for :class:`_orm.declared_attr`

 #ref:`orm_declarative_dataclasses_mixin` - illustrates special forms
 #or use with Python dataclasses

 #""  # noqa E501

 #ef __init__(self, fget, cascading=False):
 #uper(declared_attr, self).__init__(fget)
 #elf.__doc__ = fget.__doc__
 #elf._cascading = cascading

 #ef __get__(desc, self, cls):
        # the declared_attr needs to make use of a cache that exists
        # for the span of the declarative scan_attributes() phase.
        # to achieve this we look at the class manager that's configured.
 #anager = attributes.manager_of_class(cls)
 #f manager is None:
 #f not re.match(r"^__.+__$", desc.fget.__name__):
                # if there is no manager at all, then this class hasn't been
                # run through declarative or mapper() at all, emit a warning.
 #til.warn(
 #Unmanaged access of declarative attribute %s from "
 #non-mapped class %s" % (desc.fget.__name__, cls.__name__)
 #
 #eturn desc.fget(cls)
 #lif manager.is_mapped:
            # the class is mapped, which means we're outside of the declarative
            # scan setup, just run the function.
 #eturn desc.fget(cls)

        # here, we are inside of the declarative scan.  use the registry
        # that is tracking the values of these attributes.
 #eclarative_scan = manager.declarative_scan
 #eg = declarative_scan.declared_attr_reg

 #f desc in reg:
 #eturn reg[desc]
 #lse:
 #eg[desc] = obj = desc.fget(cls)
 #eturn obj

 #hybridmethod
 #ef _stateful(cls, **kw):
 #eturn _stateful_declared_attr(**kw)

 #hybridproperty
 #ef cascading(cls):
 #""Mark a :class:`.declared_attr` as cascading.

 #his is a special-use modifier which indicates that a column
 #r MapperProperty-based declared attribute should be configured
 #istinctly per mapped subclass, within a mapped-inheritance scenario.

 #. warning::

 #he :attr:`.declared_attr.cascading` modifier has several
 #imitations:

 # The flag **only** applies to the use of :class:`.declared_attr`
 #n declarative mixin classes and ``__abstract__`` classes; it
 #urrently has no effect when used on a mapped class directly.

 # The flag **only** applies to normally-named attributes, e.g.
 #ot any special underscore attributes such as ``__tablename__``.
 #n these attributes it has **no** effect.

 # The flag currently **does not allow further overrides** down
 #he class hierarchy; if a subclass tries to override the
 #ttribute, a warning is emitted and the overridden attribute
 #s skipped.  This is a limitation that it is hoped will be
 #esolved at some point.

 #elow, both MyClass as well as MySubClass will have a distinct
 #`id`` Column object established::

 #lass HasIdMixin(object):
 #declared_attr.cascading
 #ef id(cls):
 #f has_inherited_table(cls):
 #eturn Column(
 #oreignKey('myclass.id'), primary_key=True
 #
 #lse:
 #eturn Column(Integer, primary_key=True)

 #lass MyClass(HasIdMixin, Base):
 #_tablename__ = 'myclass'
                # ...

 #lass MySubClass(MyClass):
 #"
                # ...

 #he behavior of the above configuration is that ``MySubClass``
 #ill refer to both its own ``id`` column as well as that of
 #`MyClass`` underneath the attribute named ``some_id``.

 #. seealso::

 #ref:`declarative_inheritance`

 #ref:`mixin_inheritance_columns`


 #""
 #eturn cls._stateful(cascading=True)


class _stateful_declared_attr(declared_attr):
 #ef __init__(self, **kw):
 #elf.kw = kw

 #ef _stateful(self, **kw):
 #ew_kw = self.kw.copy()
 #ew_kw.update(kw)
 #eturn _stateful_declared_attr(**new_kw)

 #ef __call__(self, fn):
 #eturn declared_attr(fn, **self.kw)


def declarative_mixin(cls):
 #""Mark a class as providing the feature of "declarative mixin".

 #.g.::

 #rom sqlalchemy.orm import declared_attr
 #rom sqlalchemy.orm import declarative_mixin

 #declarative_mixin
 #lass MyMixin:

 #declared_attr
 #ef __tablename__(cls):
 #eturn cls.__name__.lower()

 #_table_args__ = {'mysql_engine': 'InnoDB'}
 #_mapper_args__= {'always_refresh': True}

 #d =  Column(Integer, primary_key=True)

 #lass MyModel(MyMixin, Base):
 #ame = Column(String(1000))

 #he :func:`_orm.declarative_mixin` decorator currently does not modify
 #he given class in any way; it's current purpose is strictly to assist
 #he :ref:`Mypy plugin <mypy_toplevel>` in being able to identify
 #QLAlchemy declarative mixin classes when no other context is present.

 #. versionadded:: 1.4.6

 #. seealso::

 #ref:`orm_mixins_toplevel`

 #ref:`mypy_declarative_mixins` - in the
 #ref:`Mypy plugin documentation <mypy_toplevel>`

 #""  # noqa: E501

 #eturn cls


def declarative_base(
 #ind=None,
 #etadata=None,
 #apper=None,
 #ls=object,
 #ame="Base",
 #onstructor=_declarative_constructor,
 #lass_registry=None,
 #etaclass=DeclarativeMeta,
):
 #"""Construct a base class for declarative class definitions.

 #he new base class will be given a metaclass that produces
 #ppropriate :class:`~sqlalchemy.schema.Table` objects and makes
 #he appropriate :func:`~sqlalchemy.orm.mapper` calls based on the
 #nformation provided declaratively in the class and any subclasses
 #f the class.

 #he :func:`_orm.declarative_base` function is a shorthand version
 #f using the :meth:`_orm.registry.generate_base`
 #ethod.  That is, the following::

 #rom sqlalchemy.orm import declarative_base

 #ase = declarative_base()

 #s equivalent to::

 #rom sqlalchemy.orm import registry

 #apper_registry = registry()
 #ase = mapper_registry.generate_base()

 #ee the docstring for :class:`_orm.registry`
 #nd :meth:`_orm.registry.generate_base`
 #or more details.

 #. versionchanged:: 1.4  The :func:`_orm.declarative_base`
 #unction is now a specialization of the more generic
 #class:`_orm.registry` class.  The function also moves to the
 #`sqlalchemy.orm`` package from the ``declarative.ext`` package.


 #param bind: An optional
 #class:`~sqlalchemy.engine.Connectable`, will be assigned
 #he ``bind`` attribute on the :class:`~sqlalchemy.schema.MetaData`
 #nstance.

 #. deprecated:: 1.4  The "bind" argument to declarative_base is
 #eprecated and will be removed in SQLAlchemy 2.0.

 #param metadata:
 #n optional :class:`~sqlalchemy.schema.MetaData` instance.  All
 #class:`~sqlalchemy.schema.Table` objects implicitly declared by
 #ubclasses of the base will share this MetaData.  A MetaData instance
 #ill be created if none is provided.  The
 #class:`~sqlalchemy.schema.MetaData` instance will be available via the
 #`metadata`` attribute of the generated declarative base class.

 #param mapper:
 #n optional callable, defaults to :func:`~sqlalchemy.orm.mapper`. Will
 #e used to map subclasses to their Tables.

 #param cls:
 #efaults to :class:`object`. A type to use as the base for the generated
 #eclarative base class. May be a class or tuple of classes.

 #param name:
 #efaults to ``Base``.  The display name for the generated
 #lass.  Customizing this is not required, but can improve clarity in
 #racebacks and debugging.

 #param constructor:
 #pecify the implementation for the ``__init__`` function on a mapped
 #lass that has no ``__init__`` of its own.  Defaults to an
 #mplementation that assigns \**kwargs for declared
 #ields and relationships to an instance.  If ``None`` is supplied,
 #o __init__ will be provided and construction will fall back to
 #ls.__init__ by way of the normal Python semantics.

 #param class_registry: optional dictionary that will serve as the
 #egistry of class names-> mapped classes when string names
 #re used to identify classes inside of :func:`_orm.relationship`
 #nd others.  Allows two or more declarative base classes
 #o share the same registry of class names for simplified
 #nter-base relationships.

 #param metaclass:
 #efaults to :class:`.DeclarativeMeta`.  A metaclass or __metaclass__
 #ompatible callable to use as the meta type of the generated
 #eclarative base class.

 #. seealso::

 #class:`_orm.registry`

 #""

 #f bind is not None:
        # util.deprecated_params does not work
 #til.warn_deprecated_20(
 #The ``bind`` argument to declarative_base is "
 #deprecated and will be removed in SQLAlchemy 2.0.",
 #

 #eturn registry(
 #bind=bind,
 #etadata=metadata,
 #lass_registry=class_registry,
 #onstructor=constructor,
 #.generate_base(
 #apper=mapper,
 #ls=cls,
 #ame=name,
 #etaclass=metaclass,
 #


class registry(object):
 #""Generalized registry for mapping classes.

 #he :class:`_orm.registry` serves as the basis for maintaining a collection
 #f mappings, and provides configurational hooks used to map classes.

 #he three general kinds of mappings supported are Declarative Base,
 #eclarative Decorator, and Imperative Mapping.   All of these mapping
 #tyles may be used interchangeably:

 # :meth:`_orm.registry.generate_base` returns a new declarative base
 #lass, and is the underlying implementation of the
 #func:`_orm.declarative_base` function.

 # :meth:`_orm.registry.mapped` provides a class decorator that will
 #pply declarative mapping to a class without the use of a declarative
 #ase class.

 # :meth:`_orm.registry.map_imperatively` will produce a
 #class:`_orm.Mapper` for a class without scanning the class for
 #eclarative class attributes. This method suits the use case historically
 #rovided by the
 #func:`_orm.mapper` classical mapping function.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`orm_mapping_classes_toplevel` - overview of class mapping
 #tyles.

 #""

 #ef __init__(
 #elf,
 #etadata=None,
 #lass_registry=None,
 #onstructor=_declarative_constructor,
 #bind=None,
 #:
 #"""Construct a new :class:`_orm.registry`

 #param metadata:
 #n optional :class:`_schema.MetaData` instance.  All
 #class:`_schema.Table` objects generated using declarative
 #able mapping will make use of this :class:`_schema.MetaData`
 #ollection.  If this argument is left at its default of ``None``,
 # blank :class:`_schema.MetaData` collection is created.

 #param constructor:
 #pecify the implementation for the ``__init__`` function on a mapped
 #lass that has no ``__init__`` of its own.  Defaults to an
 #mplementation that assigns \**kwargs for declared
 #ields and relationships to an instance.  If ``None`` is supplied,
 #o __init__ will be provided and construction will fall back to
 #ls.__init__ by way of the normal Python semantics.

 #param class_registry: optional dictionary that will serve as the
 #egistry of class names-> mapped classes when string names
 #re used to identify classes inside of :func:`_orm.relationship`
 #nd others.  Allows two or more declarative base classes
 #o share the same registry of class names for simplified
 #nter-base relationships.

 #""
 #cl_metadata = metadata or MetaData()
 #f _bind:
 #cl_metadata.bind = _bind

 #f class_registry is None:
 #lass_registry = weakref.WeakValueDictionary()

 #elf._class_registry = class_registry
 #elf._managers = weakref.WeakKeyDictionary()
 #elf._non_primary_mappers = weakref.WeakKeyDictionary()
 #elf.metadata = lcl_metadata
 #elf.constructor = constructor

 #elf._dependents = set()
 #elf._dependencies = set()

 #elf._new_mappers = False

 #ith mapperlib._CONFIGURE_MUTEX:
 #apperlib._mapper_registries[self] = True

 #property
 #ef mappers(self):
 #""read only collection of all :class:`_orm.Mapper` objects."""

 #eturn frozenset(manager.mapper for manager in self._managers).union(
 #elf._non_primary_mappers
 #

 #ef _set_depends_on(self, registry):
 #f registry is self:
 #eturn
 #egistry._dependents.add(self)
 #elf._dependencies.add(registry)

 #ef _flag_new_mapper(self, mapper):
 #apper._ready_for_configure = True
 #f self._new_mappers:
 #eturn

 #or reg in self._recurse_with_dependents({self}):
 #eg._new_mappers = True

 #classmethod
 #ef _recurse_with_dependents(cls, registries):
 #odo = registries
 #one = set()
 #hile todo:
 #eg = todo.pop()
 #one.add(reg)

            # if yielding would remove dependents, make sure we have
            # them before
 #odo.update(reg._dependents.difference(done))
 #ield reg

            # if yielding would add dependents, make sure we have them
            # after
 #odo.update(reg._dependents.difference(done))

 #classmethod
 #ef _recurse_with_dependencies(cls, registries):
 #odo = registries
 #one = set()
 #hile todo:
 #eg = todo.pop()
 #one.add(reg)

            # if yielding would remove dependencies, make sure we have
            # them before
 #odo.update(reg._dependencies.difference(done))

 #ield reg

            # if yielding would remove dependencies, make sure we have
            # them before
 #odo.update(reg._dependencies.difference(done))

 #ef _mappers_to_configure(self):
 #eturn itertools.chain(
 #
 #anager.mapper
 #or manager in list(self._managers)
 #f manager.is_mapped
 #nd not manager.mapper.configured
 #nd manager.mapper._ready_for_configure
 #,
 #
 #pm
 #or npm in list(self._non_primary_mappers)
 #f not npm.configured and npm._ready_for_configure
 #,
 #

 #ef _add_non_primary_mapper(self, np_mapper):
 #elf._non_primary_mappers[np_mapper] = True

 #ef _dispose_cls(self, cls):
 #lsregistry.remove_class(cls.__name__, cls, self._class_registry)

 #ef _add_manager(self, manager):
 #elf._managers[manager] = True
 #ssert manager.registry is None
 #anager.registry = self

 #ef configure(self, cascade=False):
 #""Configure all as-yet unconfigured mappers in this
 #class:`_orm.registry`.

 #he configure step is used to reconcile and initialize the
 #func:`_orm.relationship` linkages between mapped classes, as well as
 #o invoke configuration events such as the
 #meth:`_orm.MapperEvents.before_configured` and
 #meth:`_orm.MapperEvents.after_configured`, which may be used by ORM
 #xtensions or user-defined extension hooks.

 #f one or more mappers in this registry contain
 #func:`_orm.relationship` constructs that refer to mapped classes in
 #ther registries, this registry is said to be *dependent* on those
 #egistries. In order to configure those dependent registries
 #utomatically, the :paramref:`_orm.registry.configure.cascade` flag
 #hould be set to ``True``. Otherwise, if they are not configured, an
 #xception will be raised.  The rationale behind this behavior is to
 #llow an application to programmatically invoke configuration of
 #egistries while controlling whether or not the process implicitly
 #eaches other registries.

 #s an alternative to invoking :meth:`_orm.registry.configure`, the ORM
 #unction :func:`_orm.configure_mappers` function may be used to ensure
 #onfiguration is complete for all :class:`_orm.registry` objects in
 #emory. This is generally simpler to use and also predates the usage of
 #class:`_orm.registry` objects overall. However, this function will
 #mpact all mappings throughout the running Python process and may be
 #ore memory/time consuming for an application that has many registries
 #n use for different purposes that may not be needed immediately.

 #. seealso::

 #func:`_orm.configure_mappers`


 #. versionadded:: 1.4.0b2

 #""
 #apperlib._configure_registries({self}, cascade=cascade)

 #ef dispose(self, cascade=False):
 #""Dispose of all mappers in this :class:`_orm.registry`.

 #fter invocation, all the classes that were mapped within this registry
 #ill no longer have class instrumentation associated with them. This
 #ethod is the per-:class:`_orm.registry` analogue to the
 #pplication-wide :func:`_orm.clear_mappers` function.

 #f this registry contains mappers that are dependencies of other
 #egistries, typically via :func:`_orm.relationship` links, then those
 #egistries must be disposed as well. When such registries exist in
 #elation to this one, their :meth:`_orm.registry.dispose` method will
 #lso be called, if the :paramref:`_orm.registry.dispose.cascade` flag
 #s set to ``True``; otherwise, an error is raised if those registries
 #ere not already disposed.

 #. versionadded:: 1.4.0b2

 #. seealso::

 #func:`_orm.clear_mappers`

 #""

 #apperlib._dispose_registries({self}, cascade=cascade)

 #ef _dispose_manager_and_mapper(self, manager):
 #f "mapper" in manager.__dict__:
 #apper = manager.mapper

 #apper._set_dispose_flags()

 #lass_ = manager.class_
 #elf._dispose_cls(class_)
 #nstrumentation._instrumentation_factory.unregister(class_)

 #ef generate_base(
 #elf,
 #apper=None,
 #ls=object,
 #ame="Base",
 #etaclass=DeclarativeMeta,
 #:
 #""Generate a declarative base class.

 #lasses that inherit from the returned class object will be
 #utomatically mapped using declarative mapping.

 #.g.::

 #rom sqlalchemy.orm import registry

 #apper_registry = registry()

 #ase = mapper_registry.generate_base()

 #lass MyClass(Base):
 #_tablename__ = "my_table"
 #d = Column(Integer, primary_key=True)

 #he above dynamically generated class is equivalent to the
 #on-dynamic example below::

 #rom sqlalchemy.orm import registry
 #rom sqlalchemy.orm.decl_api import DeclarativeMeta

 #apper_registry = registry()

 #lass Base(metaclass=DeclarativeMeta):
 #_abstract__ = True
 #egistry = mapper_registry
 #etadata = mapper_registry.metadata

 #he :meth:`_orm.registry.generate_base` method provides the
 #mplementation for the :func:`_orm.declarative_base` function, which
 #reates the :class:`_orm.registry` and base class all at once.

 #ee the section :ref:`orm_declarative_mapping` for background and
 #xamples.

 #param mapper:
 #n optional callable, defaults to :func:`~sqlalchemy.orm.mapper`.
 #his function is used to generate new :class:`_orm.Mapper` objects.

 #param cls:
 #efaults to :class:`object`. A type to use as the base for the
 #enerated declarative base class. May be a class or tuple of classes.

 #param name:
 #efaults to ``Base``.  The display name for the generated
 #lass.  Customizing this is not required, but can improve clarity in
 #racebacks and debugging.

 #param metaclass:
 #efaults to :class:`.DeclarativeMeta`.  A metaclass or __metaclass__
 #ompatible callable to use as the meta type of the generated
 #eclarative base class.

 #. seealso::

 #ref:`orm_declarative_mapping`

 #func:`_orm.declarative_base`

 #""
 #etadata = self.metadata

 #ases = not isinstance(cls, tuple) and (cls,) or cls

 #lass_dict = dict(registry=self, metadata=metadata)
 #f isinstance(cls, type):
 #lass_dict["__doc__"] = cls.__doc__

 #f self.constructor:
 #lass_dict["__init__"] = self.constructor

 #lass_dict["__abstract__"] = True
 #f mapper:
 #lass_dict["__mapper_cls__"] = mapper

 #eturn metaclass(name, bases, class_dict)

 #ef mapped(self, cls):
 #""Class decorator that will apply the Declarative mapping process
 #o a given class.

 #.g.::

 #rom sqlalchemy.orm import registry

 #apper_registry = registry()

 #mapper_registry.mapped
 #lass Foo:
 #_tablename__ = 'some_table'

 #d = Column(Integer, primary_key=True)
 #ame = Column(String)

 #ee the section :ref:`orm_declarative_mapping` for complete
 #etails and examples.

 #param cls: class to be mapped.

 #return: the class that was passed.

 #. seealso::

 #ref:`orm_declarative_mapping`

 #meth:`_orm.registry.generate_base` - generates a base class
 #hat will apply Declarative mapping to subclasses automatically
 #sing a Python metaclass.

 #""
 #as_declarative(self, cls, cls.__dict__)
 #eturn cls

 #ef as_declarative_base(self, **kw):
 #""
 #lass decorator which will invoke
 #meth:`_orm.registry.generate_base`
 #or a given base class.

 #.g.::

 #rom sqlalchemy.orm import registry

 #apper_registry = registry()

 #mapper_registry.as_declarative_base()
 #lass Base(object):
 #declared_attr
 #ef __tablename__(cls):
 #eturn cls.__name__.lower()
 #d = Column(Integer, primary_key=True)

 #lass MyMappedClass(Base):
                # ...

 #ll keyword arguments passed to
 #meth:`_orm.registry.as_declarative_base` are passed
 #long to :meth:`_orm.registry.generate_base`.

 #""

 #ef decorate(cls):
 #w["cls"] = cls
 #w["name"] = cls.__name__
 #eturn self.generate_base(**kw)

 #eturn decorate

 #ef map_declaratively(self, cls):
 #""Map a class declaratively.

 #n this form of mapping, the class is scanned for mapping information,
 #ncluding for columns to be associated with a table, and/or an
 #ctual table object.

 #eturns the :class:`_orm.Mapper` object.

 #.g.::

 #rom sqlalchemy.orm import registry

 #apper_registry = registry()

 #lass Foo:
 #_tablename__ = 'some_table'

 #d = Column(Integer, primary_key=True)
 #ame = Column(String)

 #apper = mapper_registry.map_declaratively(Foo)

 #his function is more conveniently invoked indirectly via either the
 #meth:`_orm.registry.mapped` class decorator or by subclassing a
 #eclarative metaclass generated from
 #meth:`_orm.registry.generate_base`.

 #ee the section :ref:`orm_declarative_mapping` for complete
 #etails and examples.

 #param cls: class to be mapped.

 #return: a :class:`_orm.Mapper` object.

 #. seealso::

 #ref:`orm_declarative_mapping`

 #meth:`_orm.registry.mapped` - more common decorator interface
 #o this function.

 #meth:`_orm.registry.map_imperatively`

 #""
 #eturn _as_declarative(self, cls, cls.__dict__)

 #ef map_imperatively(self, class_, local_table=None, **kw):
 #"""Map a class imperatively.

 #n this form of mapping, the class is not scanned for any mapping
 #nformation.  Instead, all mapping constructs are passed as
 #rguments.

 #his method is intended to be fully equivalent to the classic
 #QLAlchemy :func:`_orm.mapper` function, except that it's in terms of
 # particular registry.

 #.g.::

 #rom sqlalchemy.orm import registry

 #apper_registry = registry()

 #y_table = Table(
 #my_table",
 #apper_registry.metadata,
 #olumn('id', Integer, primary_key=True)
 #

 #lass MyClass:
 #ass

 #apper_registry.map_imperatively(MyClass, my_table)

 #ee the section :ref:`orm_imperative_mapping` for complete background
 #nd usage examples.

 #param class\_: The class to be mapped.  Corresponds to the
 #paramref:`_orm.mapper.class_` parameter.

 #param local_table: the :class:`_schema.Table` or other
 #class:`_sql.FromClause` object that is the subject of the mapping.
 #orresponds to the
 #paramref:`_orm.mapper.local_table` parameter.

 #param \**kw: all other keyword arguments are passed to the
 #func:`_orm.mapper` function directly.

 #. seealso::

 #ref:`orm_imperative_mapping`

 #ref:`orm_declarative_mapping`

 #""
 #eturn _mapper(self, class_, local_table, kw)


mapperlib._legacy_registry = registry()


@util.deprecated_params(
 #ind=(
 #2.0",
 #The ``bind`` argument to as_declarative is "
 #deprecated and will be removed in SQLAlchemy 2.0.",
 #
)
def as_declarative(**kw):
 #""
 #lass decorator which will adapt a given class into a
 #func:`_orm.declarative_base`.

 #his function makes use of the :meth:`_orm.registry.as_declarative_base`
 #ethod, by first creating a :class:`_orm.registry` automatically
 #nd then invoking the decorator.

 #.g.::

 #rom sqlalchemy.orm import as_declarative

 #as_declarative()
 #lass Base(object):
 #declared_attr
 #ef __tablename__(cls):
 #eturn cls.__name__.lower()
 #d = Column(Integer, primary_key=True)

 #lass MyMappedClass(Base):
            # ...

 #. seealso::

 #meth:`_orm.registry.as_declarative_base`

 #""
 #ind, metadata, class_registry = (
 #w.pop("bind", None),
 #w.pop("metadata", None),
 #w.pop("class_registry", None),
 #

 #eturn registry(
 #bind=bind, metadata=metadata, class_registry=class_registry
 #.as_declarative_base(**kw)


@inspection._inspects(DeclarativeMeta)
def _inspect_decl_meta(cls):
 #p = _inspect_mapped_class(cls)
 #f mp is None:
 #f _DeferredMapperConfig.has_cls(cls):
 #DeferredMapperConfig.raise_unmapped_for_cls(cls)
 #aise orm_exc.UnmappedClassError(
 #ls,
 #sg="Class %s has a deferred mapping on it.  It is not yet "
 #usable as a mapped class." % orm_exc._safe_cls_name(cls),
 #
 #eturn mp
