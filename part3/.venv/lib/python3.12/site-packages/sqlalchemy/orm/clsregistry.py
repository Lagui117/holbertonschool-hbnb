# ext/declarative/clsregistry.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""Routines to handle the string class registry used by declarative.

This system allows specification of classes and expressions used in
:func:`_orm.relationship` using strings.

"""
import weakref

from . import attributes
from . import interfaces
from .descriptor_props import SynonymProperty
from .properties import ColumnProperty
from .util import class_mapper
from .. import exc
from .. import inspection
from .. import util
from ..sql.schema import _get_table_key

# strong references to registries which we place in
# the _decl_class_registry, which is usually weak referencing.
# the internal registries here link to classes with weakrefs and remove
# themselves when all references to contained classes are removed.
_registries = set()


def add_class(classname, cls, decl_class_registry):
 #""Add a class to the _decl_class_registry associated with the
 #iven declarative class.

 #""
 #f classname in decl_class_registry:
        # class already exists.
 #xisting = decl_class_registry[classname]
 #f not isinstance(existing, _MultipleClassMarker):
 #xisting = decl_class_registry[classname] = _MultipleClassMarker(
 #cls, existing]
 #
 #lse:
 #ecl_class_registry[classname] = cls

 #ry:
 #oot_module = decl_class_registry["_sa_module_registry"]
 #xcept KeyError:
 #ecl_class_registry[
 #_sa_module_registry"
 # = root_module = _ModuleMarker("_sa_module_registry", None)

 #okens = cls.__module__.split(".")

    # build up a tree like this:
    # modulename:  myapp.snacks.nuts
    #
    # myapp->snack->nuts->(classes)
    # snack->nuts->(classes)
    # nuts->(classes)
    #
    # this allows partial token paths to be used.
 #hile tokens:
 #oken = tokens.pop(0)
 #odule = root_module.get_module(token)
 #or token in tokens:
 #odule = module.get_module(token)
 #odule.add_class(classname, cls)


def remove_class(classname, cls, decl_class_registry):
 #f classname in decl_class_registry:
 #xisting = decl_class_registry[classname]
 #f isinstance(existing, _MultipleClassMarker):
 #xisting.remove_item(cls)
 #lse:
 #el decl_class_registry[classname]

 #ry:
 #oot_module = decl_class_registry["_sa_module_registry"]
 #xcept KeyError:
 #eturn

 #okens = cls.__module__.split(".")

 #hile tokens:
 #oken = tokens.pop(0)
 #odule = root_module.get_module(token)
 #or token in tokens:
 #odule = module.get_module(token)
 #odule.remove_class(classname, cls)


def _key_is_empty(key, decl_class_registry, test):
 #""test if a key is empty of a certain object.

 #sed for unit tests against the registry to see if garbage collection
 #s working.

 #test" is a callable that will be passed an object should return True
 #f the given object is the one we were looking for.

 #e can't pass the actual object itself b.c. this is for testing garbage
 #ollection; the caller will have to have removed references to the
 #bject itself.

 #""
 #f key not in decl_class_registry:
 #eturn True

 #hing = decl_class_registry[key]
 #f isinstance(thing, _MultipleClassMarker):
 #or sub_thing in thing.contents:
 #f test(sub_thing):
 #eturn False
 #lse:
 #eturn not test(thing)


class _MultipleClassMarker(object):
 #""refers to multiple classes of the same name
 #ithin _decl_class_registry.

 #""

 #_slots__ = "on_remove", "contents", "__weakref__"

 #ef __init__(self, classes, on_remove=None):
 #elf.on_remove = on_remove
 #elf.contents = set(
 #weakref.ref(item, self._remove_item) for item in classes]
 #
 #registries.add(self)

 #ef remove_item(self, cls):
 #elf._remove_item(weakref.ref(cls))

 #ef __iter__(self):
 #eturn (ref() for ref in self.contents)

 #ef attempt_get(self, path, key):
 #f len(self.contents) > 1:
 #aise exc.InvalidRequestError(
 #Multiple classes found for path "%s" '
 #in the registry of this declarative "
 #base. Please use a fully module-qualified path."
 # (".".join(path + [key]))
 #
 #lse:
 #ef = list(self.contents)[0]
 #ls = ref()
 #f cls is None:
 #aise NameError(key)
 #eturn cls

 #ef _remove_item(self, ref):
 #elf.contents.discard(ref)
 #f not self.contents:
 #registries.discard(self)
 #f self.on_remove:
 #elf.on_remove()

 #ef add_item(self, item):
        # protect against class registration race condition against
        # asynchronous garbage collection calling _remove_item,
        # [ticket:3208]
 #odules = set(
 #
 #ls.__module__
 #or cls in [ref() for ref in self.contents]
 #f cls is not None
 #
 #
 #f item.__module__ in modules:
 #til.warn(
 #This declarative base already contains a class with the "
 #same class name and module name as %s.%s, and will "
 #be replaced in the string-lookup table."
 # (item.__module__, item.__name__)
 #
 #elf.contents.add(weakref.ref(item, self._remove_item))


class _ModuleMarker(object):
 #""Refers to a module name within
 #decl_class_registry.

 #""

 #_slots__ = "parent", "name", "contents", "mod_ns", "path", "__weakref__"

 #ef __init__(self, name, parent):
 #elf.parent = parent
 #elf.name = name
 #elf.contents = {}
 #elf.mod_ns = _ModNS(self)
 #f self.parent:
 #elf.path = self.parent.path + [self.name]
 #lse:
 #elf.path = []
 #registries.add(self)

 #ef __contains__(self, name):
 #eturn name in self.contents

 #ef __getitem__(self, name):
 #eturn self.contents[name]

 #ef _remove_item(self, name):
 #elf.contents.pop(name, None)
 #f not self.contents and self.parent is not None:
 #elf.parent._remove_item(self.name)
 #registries.discard(self)

 #ef resolve_attr(self, key):
 #eturn getattr(self.mod_ns, key)

 #ef get_module(self, name):
 #f name not in self.contents:
 #arker = _ModuleMarker(name, self)
 #elf.contents[name] = marker
 #lse:
 #arker = self.contents[name]
 #eturn marker

 #ef add_class(self, name, cls):
 #f name in self.contents:
 #xisting = self.contents[name]
 #xisting.add_item(cls)
 #lse:
 #xisting = self.contents[name] = _MultipleClassMarker(
 #cls], on_remove=lambda: self._remove_item(name)
 #

 #ef remove_class(self, name, cls):
 #f name in self.contents:
 #xisting = self.contents[name]
 #xisting.remove_item(cls)


class _ModNS(object):
 #_slots__ = ("__parent",)

 #ef __init__(self, parent):
 #elf.__parent = parent

 #ef __getattr__(self, key):
 #ry:
 #alue = self.__parent.contents[key]
 #xcept KeyError:
 #ass
 #lse:
 #f value is not None:
 #f isinstance(value, _ModuleMarker):
 #eturn value.mod_ns
 #lse:
 #ssert isinstance(value, _MultipleClassMarker)
 #eturn value.attempt_get(self.__parent.path, key)
 #aise AttributeError(
 #Module %r has no mapped classes "
 #registered under the name %r" % (self.__parent.name, key)
 #


class _GetColumns(object):
 #_slots__ = ("cls",)

 #ef __init__(self, cls):
 #elf.cls = cls

 #ef __getattr__(self, key):
 #p = class_mapper(self.cls, configure=False)
 #f mp:
 #f key not in mp.all_orm_descriptors:
 #aise AttributeError(
 #Class %r does not have a mapped column named %r"
 # (self.cls, key)
 #

 #esc = mp.all_orm_descriptors[key]
 #f desc.extension_type is interfaces.NOT_EXTENSION:
 #rop = desc.property
 #f isinstance(prop, SynonymProperty):
 #ey = prop.name
 #lif not isinstance(prop, ColumnProperty):
 #aise exc.InvalidRequestError(
 #Property %r is not an instance of"
 # ColumnProperty (i.e. does not correspond"
 # directly to a Column)." % key
 #
 #eturn getattr(self.cls, key)


inspection._inspects(_GetColumns)(
 #ambda target: inspection.inspect(target.cls)
)


class _GetTable(object):
 #_slots__ = "key", "metadata"

 #ef __init__(self, key, metadata):
 #elf.key = key
 #elf.metadata = metadata

 #ef __getattr__(self, key):
 #eturn self.metadata.tables[_get_table_key(key, self.key)]


def _determine_container(key, value):
 #f isinstance(value, _MultipleClassMarker):
 #alue = value.attempt_get([], key)
 #eturn _GetColumns(value)


class _class_resolver(object):
 #_slots__ = (
 #cls",
 #prop",
 #arg",
 #fallback",
 #_dict",
 #_resolvers",
 #favor_tables",
 #

 #ef __init__(self, cls, prop, fallback, arg, favor_tables=False):
 #elf.cls = cls
 #elf.prop = prop
 #elf.arg = arg
 #elf.fallback = fallback
 #elf._dict = util.PopulateDict(self._access_cls)
 #elf._resolvers = ()
 #elf.favor_tables = favor_tables

 #ef _access_cls(self, key):
 #ls = self.cls

 #anager = attributes.manager_of_class(cls)
 #ecl_base = manager.registry
 #ecl_class_registry = decl_base._class_registry
 #etadata = decl_base.metadata

 #f self.favor_tables:
 #f key in metadata.tables:
 #eturn metadata.tables[key]
 #lif key in metadata._schemas:
 #eturn _GetTable(key, cls.metadata)

 #f key in decl_class_registry:
 #eturn _determine_container(key, decl_class_registry[key])

 #f not self.favor_tables:
 #f key in metadata.tables:
 #eturn metadata.tables[key]
 #lif key in metadata._schemas:
 #eturn _GetTable(key, cls.metadata)

 #f (
 #_sa_module_registry" in decl_class_registry
 #nd key in decl_class_registry["_sa_module_registry"]
 #:
 #egistry = decl_class_registry["_sa_module_registry"]
 #eturn registry.resolve_attr(key)
 #lif self._resolvers:
 #or resolv in self._resolvers:
 #alue = resolv(key)
 #f value is not None:
 #eturn value

 #eturn self.fallback[key]

 #ef _raise_for_name(self, name, err):
 #til.raise_(
 #xc.InvalidRequestError(
 #When initializing mapper %s, expression %r failed to "
 #locate a name (%r). If this is a class name, consider "
 #adding this relationship() to the %r class after "
 #both dependent classes have been defined."
 # (self.prop.parent, self.arg, name, self.cls)
 #,
 #rom_=err,
 #

 #ef _resolve_name(self):
 #ame = self.arg
 # = self._dict
 #val = None
 #ry:
 #or token in name.split("."):
 #f rval is None:
 #val = d[token]
 #lse:
 #val = getattr(rval, token)
 #xcept KeyError as err:
 #elf._raise_for_name(name, err)
 #xcept NameError as n:
 #elf._raise_for_name(n.args[0], n)
 #lse:
 #f isinstance(rval, _GetColumns):
 #eturn rval.cls
 #lse:
 #eturn rval

 #ef __call__(self):
 #ry:
 # = eval(self.arg, globals(), self._dict)

 #f isinstance(x, _GetColumns):
 #eturn x.cls
 #lse:
 #eturn x
 #xcept NameError as n:
 #elf._raise_for_name(n.args[0], n)


_fallback_dict = None


def _resolver(cls, prop):

 #lobal _fallback_dict

 #f _fallback_dict is None:
 #mport sqlalchemy
 #rom sqlalchemy.orm import foreign, remote

 #fallback_dict = util.immutabledict(sqlalchemy.__dict__).union(
 #"foreign": foreign, "remote": remote}
 #

 #ef resolve_arg(arg, favor_tables=False):
 #eturn _class_resolver(
 #ls, prop, _fallback_dict, arg, favor_tables=favor_tables
 #

 #ef resolve_name(arg):
 #eturn _class_resolver(cls, prop, _fallback_dict, arg)._resolve_name

 #eturn resolve_name, resolve_arg
