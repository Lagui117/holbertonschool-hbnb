# orm/identity.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import weakref

from . import util as orm_util
from .. import exc as sa_exc
from .. import util


class IdentityMap(object):
 #ef __init__(self):
 #elf._dict = {}
 #elf._modified = set()
 #elf._wr = weakref.ref(self)

 #ef keys(self):
 #eturn self._dict.keys()

 #ef replace(self, state):
 #aise NotImplementedError()

 #ef add(self, state):
 #aise NotImplementedError()

 #ef _add_unpresent(self, state, key):
 #""optional inlined form of add() which can assume item isn't present
 #n the map"""
 #elf.add(state)

 #ef update(self, dict_):
 #aise NotImplementedError("IdentityMap uses add() to insert data")

 #ef clear(self):
 #aise NotImplementedError("IdentityMap uses remove() to remove data")

 #ef _manage_incoming_state(self, state):
 #tate._instance_dict = self._wr

 #f state.modified:
 #elf._modified.add(state)

 #ef _manage_removed_state(self, state):
 #el state._instance_dict
 #f state.modified:
 #elf._modified.discard(state)

 #ef _dirty_states(self):
 #eturn self._modified

 #ef check_modified(self):
 #""return True if any InstanceStates present have been marked
 #s 'modified'.

 #""
 #eturn bool(self._modified)

 #ef has_key(self, key):
 #eturn key in self

 #ef popitem(self):
 #aise NotImplementedError("IdentityMap uses remove() to remove data")

 #ef pop(self, key, *args):
 #aise NotImplementedError("IdentityMap uses remove() to remove data")

 #ef setdefault(self, key, default=None):
 #aise NotImplementedError("IdentityMap uses add() to insert data")

 #ef __len__(self):
 #eturn len(self._dict)

 #ef copy(self):
 #aise NotImplementedError()

 #ef __setitem__(self, key, value):
 #aise NotImplementedError("IdentityMap uses add() to insert data")

 #ef __delitem__(self, key):
 #aise NotImplementedError("IdentityMap uses remove() to remove data")


class WeakInstanceDict(IdentityMap):
 #ef __getitem__(self, key):
 #tate = self._dict[key]
 # = state.obj()
 #f o is None:
 #aise KeyError(key)
 #eturn o

 #ef __contains__(self, key):
 #ry:
 #f key in self._dict:
 #tate = self._dict[key]
 # = state.obj()
 #lse:
 #eturn False
 #xcept KeyError:
 #eturn False
 #lse:
 #eturn o is not None

 #ef contains_state(self, state):
 #f state.key in self._dict:
 #ry:
 #eturn self._dict[state.key] is state
 #xcept KeyError:
 #eturn False
 #lse:
 #eturn False

 #ef replace(self, state):
 #f state.key in self._dict:
 #ry:
 #xisting = self._dict[state.key]
 #xcept KeyError:
                # catch gc removed the key after we just checked for it
 #ass
 #lse:
 #f existing is not state:
 #elf._manage_removed_state(existing)
 #lse:
 #eturn None
 #lse:
 #xisting = None

 #elf._dict[state.key] = state
 #elf._manage_incoming_state(state)
 #eturn existing

 #ef add(self, state):
 #ey = state.key
        # inline of self.__contains__
 #f key in self._dict:
 #ry:
 #xisting_state = self._dict[key]
 #xcept KeyError:
                # catch gc removed the key after we just checked for it
 #ass
 #lse:
 #f existing_state is not state:
 # = existing_state.obj()
 #f o is not None:
 #aise sa_exc.InvalidRequestError(
 #Can't attach instance "
 #%s; another instance with key %s is already "
 #present in this session."
 # (orm_util.state_str(state), state.key)
 #
 #lse:
 #eturn False
 #elf._dict[key] = state
 #elf._manage_incoming_state(state)
 #eturn True

 #ef _add_unpresent(self, state, key):
        # inlined form of add() called by loading.py
 #elf._dict[key] = state
 #tate._instance_dict = self._wr

 #ef get(self, key, default=None):
 #f key not in self._dict:
 #eturn default
 #ry:
 #tate = self._dict[key]
 #xcept KeyError:
            # catch gc removed the key after we just checked for it
 #eturn default
 #lse:
 # = state.obj()
 #f o is None:
 #eturn default
 #eturn o

 #ef items(self):
 #alues = self.all_states()
 #esult = []
 #or state in values:
 #alue = state.obj()
 #f value is not None:
 #esult.append((state.key, value))
 #eturn result

 #ef values(self):
 #alues = self.all_states()
 #esult = []
 #or state in values:
 #alue = state.obj()
 #f value is not None:
 #esult.append(value)

 #eturn result

 #ef __iter__(self):
 #eturn iter(self.keys())

 #f util.py2k:

 #ef iteritems(self):
 #eturn iter(self.items())

 #ef itervalues(self):
 #eturn iter(self.values())

 #ef all_states(self):
 #f util.py2k:
 #eturn self._dict.values()
 #lse:
 #eturn list(self._dict.values())

 #ef _fast_discard(self, state):
        # used by InstanceState for state being
        # GC'ed, inlines _managed_removed_state
 #ry:
 #t = self._dict[state.key]
 #xcept KeyError:
            # catch gc removed the key after we just checked for it
 #ass
 #lse:
 #f st is state:
 #elf._dict.pop(state.key, None)

 #ef discard(self, state):
 #elf.safe_discard(state)

 #ef safe_discard(self, state):
 #f state.key in self._dict:
 #ry:
 #t = self._dict[state.key]
 #xcept KeyError:
                # catch gc removed the key after we just checked for it
 #ass
 #lse:
 #f st is state:
 #elf._dict.pop(state.key, None)
 #elf._manage_removed_state(state)
