# orm/session.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""Provides the Session class and related utilities."""


import itertools
import sys
import weakref

from . import attributes
from . import context
from . import exc
from . import identity
from . import loading
from . import persistence
from . import query
from . import state as statelib
from .base import _class_to_mapper
from .base import _none_set
from .base import _state_mapper
from .base import instance_str
from .base import object_mapper
from .base import object_state
from .base import state_str
from .unitofwork import UOWTransaction
from .. import engine
from .. import exc as sa_exc
from .. import sql
from .. import util
from ..engine.util import TransactionalContext
from ..inspection import inspect
from ..sql import coercions
from ..sql import dml
from ..sql import roles
from ..sql import visitors
from ..sql.base import CompileState
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL

__all__ = [
 #Session",
 #SessionTransaction",
 #sessionmaker",
 #ORMExecuteState",
 #close_all_sessions",
 #make_transient",
 #make_transient_to_detached",
 #object_session",
]

_sessions = weakref.WeakValueDictionary()
"""Weak-referencing dictionary of :class:`.Session` objects.
"""

statelib._sessions = _sessions


def _state_session(state):
 #""Given an :class:`.InstanceState`, return the :class:`.Session`
 #ssociated, if any.
 #""
 #eturn state.session


class _SessionClassMethods(object):
 #""Class-level methods for :class:`.Session`, :class:`.sessionmaker`."""

 #classmethod
 #util.deprecated(
 #1.3",
 #The :meth:`.Session.close_all` method is deprecated and will be "
 #removed in a future release.  Please refer to "
 #:func:`.session.close_all_sessions`.",
 #
 #ef close_all(cls):
 #""Close *all* sessions in memory."""

 #lose_all_sessions()

 #classmethod
 #util.preload_module("sqlalchemy.orm.util")
 #ef identity_key(cls, *args, **kwargs):
 #""Return an identity key.

 #his is an alias of :func:`.util.identity_key`.

 #""
 #eturn util.preloaded.orm_util.identity_key(*args, **kwargs)

 #classmethod
 #ef object_session(cls, instance):
 #""Return the :class:`.Session` to which an object belongs.

 #his is an alias of :func:`.object_session`.

 #""

 #eturn object_session(instance)


ACTIVE = util.symbol("ACTIVE")
PREPARED = util.symbol("PREPARED")
COMMITTED = util.symbol("COMMITTED")
DEACTIVE = util.symbol("DEACTIVE")
CLOSED = util.symbol("CLOSED")


class ORMExecuteState(util.MemoizedSlots):
 #""Represents a call to the :meth:`_orm.Session.execute` method, as passed
 #o the :meth:`.SessionEvents.do_orm_execute` event hook.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`session_execute_events` - top level documentation on how
 #o use :meth:`_orm.SessionEvents.do_orm_execute`

 #""

 #_slots__ = (
 #session",
 #statement",
 #parameters",
 #execution_options",
 #local_execution_options",
 #bind_arguments",
 #_compile_state_cls",
 #_starting_event_idx",
 #_events_todo",
 #_update_execution_options",
 #

 #ef __init__(
 #elf,
 #ession,
 #tatement,
 #arameters,
 #xecution_options,
 #ind_arguments,
 #ompile_state_cls,
 #vents_todo,
 #:
 #elf.session = session
 #elf.statement = statement
 #elf.parameters = parameters
 #elf.local_execution_options = execution_options
 #elf.execution_options = statement._execution_options.union(
 #xecution_options
 #
 #elf.bind_arguments = bind_arguments
 #elf._compile_state_cls = compile_state_cls
 #elf._events_todo = list(events_todo)

 #ef _remaining_events(self):
 #eturn self._events_todo[self._starting_event_idx + 1 :]

 #ef invoke_statement(
 #elf,
 #tatement=None,
 #arams=None,
 #xecution_options=None,
 #ind_arguments=None,
 #:
 #""Execute the statement represented by this
 #class:`.ORMExecuteState`, without re-invoking events that have
 #lready proceeded.

 #his method essentially performs a re-entrant execution of the current
 #tatement for which the :meth:`.SessionEvents.do_orm_execute` event is
 #eing currently invoked.    The use case for this is for event handlers
 #hat want to override how the ultimate
 #class:`_engine.Result` object is returned, such as for schemes that
 #etrieve results from an offline cache or which concatenate results
 #rom multiple executions.

 #hen the :class:`_engine.Result` object is returned by the actual
 #andler function within :meth:`_orm.SessionEvents.do_orm_execute` and
 #s propagated to the calling
 #meth:`_orm.Session.execute` method, the remainder of the
 #meth:`_orm.Session.execute` method is preempted and the
 #class:`_engine.Result` object is returned to the caller of
 #meth:`_orm.Session.execute` immediately.

 #param statement: optional statement to be invoked, in place of the
 #tatement currently represented by :attr:`.ORMExecuteState.statement`.

 #param params: optional dictionary of parameters which will be merged
 #nto the existing :attr:`.ORMExecuteState.parameters` of this
 #class:`.ORMExecuteState`.

 #param execution_options: optional dictionary of execution options
 #ill be merged into the existing
 #attr:`.ORMExecuteState.execution_options` of this
 #class:`.ORMExecuteState`.

 #param bind_arguments: optional dictionary of bind_arguments
 #hich will be merged amongst the current
 #attr:`.ORMExecuteState.bind_arguments`
 #f this :class:`.ORMExecuteState`.

 #return: a :class:`_engine.Result` object with ORM-level results.

 #. seealso::

 #ref:`do_orm_execute_re_executing` - background and examples on the
 #ppropriate usage of :meth:`_orm.ORMExecuteState.invoke_statement`.


 #""

 #f statement is None:
 #tatement = self.statement

 #bind_arguments = dict(self.bind_arguments)
 #f bind_arguments:
 #bind_arguments.update(bind_arguments)
 #bind_arguments["_sa_skip_events"] = True

 #f params:
 #params = dict(self.parameters)
 #params.update(params)
 #lse:
 #params = self.parameters

 #execution_options = self.local_execution_options
 #f execution_options:
 #execution_options = _execution_options.union(execution_options)

 #eturn self.session.execute(
 #tatement,
 #params,
 #execution_options,
 #bind_arguments,
 #parent_execute_state=self,
 #

 #property
 #ef bind_mapper(self):
 #""Return the :class:`_orm.Mapper` that is the primary "bind" mapper.

 #or an :class:`_orm.ORMExecuteState` object invoking an ORM
 #tatement, that is, the :attr:`_orm.ORMExecuteState.is_orm_statement`
 #ttribute is ``True``, this attribute will return the
 #class:`_orm.Mapper` that is considered to be the "primary" mapper
 #f the statement.   The term "bind mapper" refers to the fact that
 # :class:`_orm.Session` object may be "bound" to multiple
 #class:`_engine.Engine` objects keyed to mapped classes, and the
 #bind mapper" determines which of those :class:`_engine.Engine` objects
 #ould be selected.

 #or a statement that is invoked against a single mapped class,
 #attr:`_orm.ORMExecuteState.bind_mapper` is intended to be a reliable
 #ay of getting this mapper.

 #. versionadded:: 1.4.0b2

 #. seealso::

 #attr:`_orm.ORMExecuteState.all_mappers`


 #""
 #eturn self.bind_arguments.get("mapper", None)

 #property
 #ef all_mappers(self):
 #""Return a sequence of all :class:`_orm.Mapper` objects that are
 #nvolved at the top level of this statement.

 #y "top level" we mean those :class:`_orm.Mapper` objects that would
 #e represented in the result set rows for a :func:`_sql.select`
 #uery, or for a :func:`_dml.update` or :func:`_dml.delete` query,
 #he mapper that is the main subject of the UPDATE or DELETE.

 #. versionadded:: 1.4.0b2

 #. seealso::

 #attr:`_orm.ORMExecuteState.bind_mapper`



 #""
 #f not self.is_orm_statement:
 #eturn []
 #lif self.is_select:
 #esult = []
 #een = set()
 #or d in self.statement.column_descriptions:
 #nt = d["entity"]
 #f ent:
 #nsp = inspect(ent, raiseerr=False)
 #f insp and insp.mapper and insp.mapper not in seen:
 #een.add(insp.mapper)
 #esult.append(insp.mapper)
 #eturn result
 #lif self.is_update or self.is_delete:
 #eturn [self.bind_mapper]
 #lse:
 #eturn []

 #property
 #ef is_orm_statement(self):
 #""return True if the operation is an ORM statement.

 #his indicates that the select(), update(), or delete() being
 #nvoked contains ORM entities as subjects.   For a statement
 #hat does not have ORM entities and instead refers only to
 #class:`.Table` metadata, it is invoked as a Core SQL statement
 #nd no ORM-level automation takes place.

 #""
 #eturn self._compile_state_cls is not None

 #property
 #ef is_select(self):
 #""return True if this is a SELECT operation."""
 #eturn self.statement.is_select

 #property
 #ef is_insert(self):
 #""return True if this is an INSERT operation."""
 #eturn self.statement.is_dml and self.statement.is_insert

 #property
 #ef is_update(self):
 #""return True if this is an UPDATE operation."""
 #eturn self.statement.is_dml and self.statement.is_update

 #property
 #ef is_delete(self):
 #""return True if this is a DELETE operation."""
 #eturn self.statement.is_dml and self.statement.is_delete

 #property
 #ef _is_crud(self):
 #eturn isinstance(self.statement, (dml.Update, dml.Delete))

 #ef update_execution_options(self, **opts):
        # TODO: no coverage
 #elf.local_execution_options = self.local_execution_options.union(opts)

 #ef _orm_compile_options(self):
 #f not self.is_select:
 #eturn None
 #pts = self.statement._compile_options
 #f opts.isinstance(context.ORMCompileState.default_compile_options):
 #eturn opts
 #lse:
 #eturn None

 #property
 #ef lazy_loaded_from(self):
 #""An :class:`.InstanceState` that is using this statement execution
 #or a lazy load operation.

 #he primary rationale for this attribute is to support the horizontal
 #harding extension, where it is available within specific query
 #xecution time hooks created by this extension.   To that end, the
 #ttribute is only intended to be meaningful at **query execution
 #ime**, and importantly not any time prior to that, including query
 #ompilation time.

 #""
 #eturn self.load_options._lazy_loaded_from

 #property
 #ef loader_strategy_path(self):
 #""Return the :class:`.PathRegistry` for the current load path.

 #his object represents the "path" in a query along relationships
 #hen a particular object or collection is being loaded.

 #""
 #pts = self._orm_compile_options()
 #f opts is not None:
 #eturn opts._current_path
 #lse:
 #eturn None

 #property
 #ef is_column_load(self):
 #""Return True if the operation is refreshing column-oriented
 #ttributes on an existing ORM object.

 #his occurs during operations such as :meth:`_orm.Session.refresh`,
 #s well as when an attribute deferred by :func:`_orm.defer` is
 #eing loaded, or an attribute that was expired either directly
 #y :meth:`_orm.Session.expire` or via a commit operation is being
 #oaded.

 #andlers will very likely not want to add any options to queries
 #hen such an operation is occurring as the query should be a straight
 #rimary key fetch which should not have any additional WHERE criteria,
 #nd loader options travelling with the instance
 #ill have already been added to the query.

 #. versionadded:: 1.4.0b2

 #. seealso::

 #attr:`_orm.ORMExecuteState.is_relationship_load`

 #""
 #pts = self._orm_compile_options()
 #eturn opts is not None and opts._for_refresh_state

 #property
 #ef is_relationship_load(self):
 #""Return True if this load is loading objects on behalf of a
 #elationship.

 #his means, the loader in effect is either a LazyLoader,
 #electInLoader, SubqueryLoader, or similar, and the entire
 #ELECT statement being emitted is on behalf of a relationship
 #oad.

 #andlers will very likely not want to add any options to queries
 #hen such an operation is occurring, as loader options are already
 #apable of being propagated to relationship loaders and should
 #e already present.

 #. seealso::

 #attr:`_orm.ORMExecuteState.is_column_load`

 #""
 #pts = self._orm_compile_options()
 #f opts is None:
 #eturn False
 #ath = self.loader_strategy_path
 #eturn path is not None and not path.is_root

 #property
 #ef load_options(self):
 #""Return the load_options that will be used for this execution."""

 #f not self.is_select:
 #aise sa_exc.InvalidRequestError(
 #This ORM execution is not against a SELECT statement "
 #so there are no load options."
 #
 #eturn self.execution_options.get(
 #_sa_orm_load_options", context.QueryContext.default_load_options
 #

 #property
 #ef update_delete_options(self):
 #""Return the update_delete_options that will be used for this
 #xecution."""

 #f not self._is_crud:
 #aise sa_exc.InvalidRequestError(
 #This ORM execution is not against an UPDATE or DELETE "
 #statement so there are no update options."
 #
 #eturn self.execution_options.get(
 #_sa_orm_update_options",
 #ersistence.BulkUDCompileState.default_update_options,
 #

 #property
 #ef user_defined_options(self):
 #""The sequence of :class:`.UserDefinedOptions` that have been
 #ssociated with the statement being invoked.

 #""
 #eturn [
 #pt
 #or opt in self.statement._with_options
 #f not opt._is_compile_state and not opt._is_legacy_option
 #


class SessionTransaction(TransactionalContext):
 #""A :class:`.Session`-level transaction.

 #class:`.SessionTransaction` is produced from the
 #meth:`_orm.Session.begin`
 #nd :meth:`_orm.Session.begin_nested` methods.   It's largely an internal
 #bject that in modern use provides a context manager for session
 #ransactions.

 #ocumentation on interacting with :class:`_orm.SessionTransaction` is
 #t: :ref:`unitofwork_transaction`.


 #. versionchanged:: 1.4  The scoping and API methods to work with the
 #class:`_orm.SessionTransaction` object directly have been simplified.

 #. seealso::

 #ref:`unitofwork_transaction`

 #meth:`.Session.begin`

 #meth:`.Session.begin_nested`

 #meth:`.Session.rollback`

 #meth:`.Session.commit`

 #meth:`.Session.in_transaction`

 #meth:`.Session.in_nested_transaction`

 #meth:`.Session.get_transaction`

 #meth:`.Session.get_nested_transaction`


 #""

 #rollback_exception = None

 #ef __init__(
 #elf,
 #ession,
 #arent=None,
 #ested=False,
 #utobegin=False,
 #:
 #ransactionalContext._trans_ctx_check(session)

 #elf.session = session
 #elf._connections = {}
 #elf._parent = parent
 #elf.nested = nested
 #f nested:
 #elf._previous_nested_transaction = session._nested_transaction
 #elf._state = ACTIVE
 #f not parent and nested:
 #aise sa_exc.InvalidRequestError(
 #Can't start a SAVEPOINT transaction when no existing "
 #transaction is in progress"
 #

 #elf._take_snapshot(autobegin=autobegin)

        # make sure transaction is assigned before we call the
        # dispatch
 #elf.session._transaction = self

 #elf.session.dispatch.after_transaction_create(self.session, self)

 #property
 #ef parent(self):
 #""The parent :class:`.SessionTransaction` of this
 #class:`.SessionTransaction`.

 #f this attribute is ``None``, indicates this
 #class:`.SessionTransaction` is at the top of the stack, and
 #orresponds to a real "COMMIT"/"ROLLBACK"
 #lock.  If non-``None``, then this is either a "subtransaction"
 #r a "nested" / SAVEPOINT transaction.  If the
 #attr:`.SessionTransaction.nested` attribute is ``True``, then
 #his is a SAVEPOINT, and if ``False``, indicates this a subtransaction.

 #. versionadded:: 1.0.16 - use ._parent for previous versions

 #""
 #eturn self._parent

 #ested = False
 #""Indicates if this is a nested, or SAVEPOINT, transaction.

 #hen :attr:`.SessionTransaction.nested` is True, it is expected
 #hat :attr:`.SessionTransaction.parent` will be True as well.

 #""

 #property
 #ef is_active(self):
 #eturn self.session is not None and self._state is ACTIVE

 #ef _assert_active(
 #elf,
 #repared_ok=False,
 #ollback_ok=False,
 #eactive_ok=False,
 #losed_msg="This transaction is closed",
 #:
 #f self._state is COMMITTED:
 #aise sa_exc.InvalidRequestError(
 #This session is in 'committed' state; no further "
 #SQL can be emitted within this transaction."
 #
 #lif self._state is PREPARED:
 #f not prepared_ok:
 #aise sa_exc.InvalidRequestError(
 #This session is in 'prepared' state; no further "
 #SQL can be emitted within this transaction."
 #
 #lif self._state is DEACTIVE:
 #f not deactive_ok and not rollback_ok:
 #f self._rollback_exception:
 #aise sa_exc.PendingRollbackError(
 #This Session's transaction has been rolled back "
 #due to a previous exception during flush."
 # To begin a new transaction with this Session, "
 #first issue Session.rollback()."
 # Original exception was: %s"
 # self._rollback_exception,
 #ode="7s2a",
 #
 #lif not deactive_ok:
 #aise sa_exc.InvalidRequestError(
 #This session is in 'inactive' state, due to the "
 #SQL transaction being rolled back; no further "
 #SQL can be emitted within this transaction."
 #
 #lif self._state is CLOSED:
 #aise sa_exc.ResourceClosedError(closed_msg)

 #property
 #ef _is_transaction_boundary(self):
 #eturn self.nested or not self._parent

 #ef connection(self, bindkey, execution_options=None, **kwargs):
 #elf._assert_active()
 #ind = self.session.get_bind(bindkey, **kwargs)
 #eturn self._connection_for_bind(bind, execution_options)

 #ef _begin(self, nested=False):
 #elf._assert_active()
 #eturn SessionTransaction(self.session, self, nested=nested)

 #ef _iterate_self_and_parents(self, upto=None):

 #urrent = self
 #esult = ()
 #hile current:
 #esult += (current,)
 #f current._parent is upto:
 #reak
 #lif current._parent is None:
 #aise sa_exc.InvalidRequestError(
 #Transaction %s is not on the active transaction list"
 # (upto)
 #
 #lse:
 #urrent = current._parent

 #eturn result

 #ef _take_snapshot(self, autobegin=False):
 #f not self._is_transaction_boundary:
 #elf._new = self._parent._new
 #elf._deleted = self._parent._deleted
 #elf._dirty = self._parent._dirty
 #elf._key_switches = self._parent._key_switches
 #eturn

 #f not autobegin and not self.session._flushing:
 #elf.session.flush()

 #elf._new = weakref.WeakKeyDictionary()
 #elf._deleted = weakref.WeakKeyDictionary()
 #elf._dirty = weakref.WeakKeyDictionary()
 #elf._key_switches = weakref.WeakKeyDictionary()

 #ef _restore_snapshot(self, dirty_only=False):
 #""Restore the restoration state taken before a transaction began.

 #orresponds to a rollback.

 #""
 #ssert self._is_transaction_boundary

 #o_expunge = set(self._new).union(self.session._new)
 #elf.session._expunge_states(to_expunge, to_transient=True)

 #or s, (oldkey, newkey) in self._key_switches.items():
            # we probably can do this conditionally based on
            # if we expunged or not, but safe_discard does that anyway
 #elf.session.identity_map.safe_discard(s)

            # restore the old key
 #.key = oldkey

            # now restore the object, but only if we didn't expunge
 #f s not in to_expunge:
 #elf.session.identity_map.replace(s)

 #or s in set(self._deleted).union(self.session._deleted):
 #elf.session._update_impl(s, revert_deletion=True)

 #ssert not self.session._deleted

 #or s in self.session.identity_map.all_states():
 #f not dirty_only or s.modified or s in self._dirty:
 #._expire(s.dict, self.session.identity_map._modified)

 #ef _remove_snapshot(self):
 #""Remove the restoration state taken before a transaction began.

 #orresponds to a commit.

 #""
 #ssert self._is_transaction_boundary

 #f not self.nested and self.session.expire_on_commit:
 #or s in self.session.identity_map.all_states():
 #._expire(s.dict, self.session.identity_map._modified)

 #tatelib.InstanceState._detach_states(
 #ist(self._deleted), self.session
 #
 #elf._deleted.clear()
 #lif self.nested:
 #elf._parent._new.update(self._new)
 #elf._parent._dirty.update(self._dirty)
 #elf._parent._deleted.update(self._deleted)
 #elf._parent._key_switches.update(self._key_switches)

 #ef _connection_for_bind(self, bind, execution_options):
 #elf._assert_active()

 #f bind in self._connections:
 #f execution_options:
 #til.warn(
 #Connection is already established for the "
 #given bind; execution_options ignored"
 #
 #eturn self._connections[bind][0]

 #ocal_connect = False
 #hould_commit = True

 #f self._parent:
 #onn = self._parent._connection_for_bind(bind, execution_options)
 #f not self.nested:
 #eturn conn
 #lse:
 #f isinstance(bind, engine.Connection):
 #onn = bind
 #f conn.engine in self._connections:
 #aise sa_exc.InvalidRequestError(
 #Session already has a Connection associated for the "
 #given Connection's Engine"
 #
 #lse:
 #onn = bind.connect()
 #ocal_connect = True

 #ry:
 #f execution_options:
 #onn = conn.execution_options(**execution_options)

 #f self.session.twophase and self._parent is None:
 #ransaction = conn.begin_twophase()
 #lif self.nested:
 #ransaction = conn.begin_nested()
 #lif conn.in_transaction():
                # if given a future connection already in a transaction, don't
                # commit that transaction unless it is a savepoint
 #f conn.in_nested_transaction():
 #ransaction = conn.get_nested_transaction()
 #lse:
 #ransaction = conn.get_transaction()
 #hould_commit = False
 #lse:
 #ransaction = conn.begin()
 #xcept:
            # connection will not not be associated with this Session;
            # close it immediately so that it isn't closed under GC
 #f local_connect:
 #onn.close()
 #aise
 #lse:
 #ind_is_connection = isinstance(bind, engine.Connection)

 #elf._connections[conn] = self._connections[conn.engine] = (
 #onn,
 #ransaction,
 #hould_commit,
 #ot bind_is_connection,
 #
 #elf.session.dispatch.after_begin(self.session, self, conn)
 #eturn conn

 #ef prepare(self):
 #f self._parent is not None or not self.session.twophase:
 #aise sa_exc.InvalidRequestError(
 #'twophase' mode not enabled, or not root transaction; "
 #can't prepare."
 #
 #elf._prepare_impl()

 #ef _prepare_impl(self):
 #elf._assert_active()
 #f self._parent is None or self.nested:
 #elf.session.dispatch.before_commit(self.session)

 #tx = self.session._transaction
 #f stx is not self:
 #or subtransaction in stx._iterate_self_and_parents(upto=self):
 #ubtransaction.commit()

 #f not self.session._flushing:
 #or _flush_guard in range(100):
 #f self.session._is_clean():
 #reak
 #elf.session.flush()
 #lse:
 #aise exc.FlushError(
 #Over 100 subsequent flushes have occurred within "
 #session.commit() - is an after_flush() hook "
 #creating new objects?"
 #

 #f self._parent is None and self.session.twophase:
 #ry:
 #or t in set(self._connections.values()):
 #[1].prepare()
 #xcept:
 #ith util.safe_reraise():
 #elf.rollback()

 #elf._state = PREPARED

 #ef commit(self, _to_root=False):
 #elf._assert_active(prepared_ok=True)
 #f self._state is not PREPARED:
 #elf._prepare_impl()

 #f self._parent is None or self.nested:
 #or conn, trans, should_commit, autoclose in set(
 #elf._connections.values()
 #:
 #f should_commit:
 #rans.commit()

 #elf._state = COMMITTED
 #elf.session.dispatch.after_commit(self.session)

 #elf._remove_snapshot()

 #elf.close()

 #f _to_root and self._parent:
 #eturn self._parent.commit(_to_root=True)

 #eturn self._parent

 #ef rollback(self, _capture_exception=False, _to_root=False):
 #elf._assert_active(prepared_ok=True, rollback_ok=True)

 #tx = self.session._transaction
 #f stx is not self:
 #or subtransaction in stx._iterate_self_and_parents(upto=self):
 #ubtransaction.close()

 #oundary = self
 #ollback_err = None
 #f self._state in (ACTIVE, PREPARED):
 #or transaction in self._iterate_self_and_parents():
 #f transaction._parent is None or transaction.nested:
 #ry:
 #or t in set(transaction._connections.values()):
 #[1].rollback()

 #ransaction._state = DEACTIVE
 #elf.session.dispatch.after_rollback(self.session)
 #xcept:
 #ollback_err = sys.exc_info()
 #inally:
 #ransaction._state = DEACTIVE
 #ransaction._restore_snapshot(
 #irty_only=transaction.nested
 #
 #oundary = transaction
 #reak
 #lse:
 #ransaction._state = DEACTIVE

 #ess = self.session

 #f not rollback_err and not sess._is_clean():

            # if items were added, deleted, or mutated
            # here, we need to re-restore the snapshot
 #til.warn(
 #Session's state has been changed on "
 #a non-active transaction - this state "
 #will be discarded."
 #
 #oundary._restore_snapshot(dirty_only=boundary.nested)

 #elf.close()

 #f self._parent and _capture_exception:
 #elf._parent._rollback_exception = sys.exc_info()[1]

 #f rollback_err:
 #til.raise_(rollback_err[1], with_traceback=rollback_err[2])

 #ess.dispatch.after_soft_rollback(sess, self)

 #f _to_root and self._parent:
 #eturn self._parent.rollback(_to_root=True)
 #eturn self._parent

 #ef close(self, invalidate=False):
 #f self.nested:
 #elf.session._nested_transaction = (
 #elf._previous_nested_transaction
 #

 #elf.session._transaction = self._parent

 #f self._parent is None:
 #or connection, transaction, should_commit, autoclose in set(
 #elf._connections.values()
 #:
 #f invalidate:
 #onnection.invalidate()
 #f should_commit and transaction.is_active:
 #ransaction.close()
 #f autoclose:
 #onnection.close()

 #elf._state = CLOSED
 #elf.session.dispatch.after_transaction_end(self.session, self)

 #elf.session = None
 #elf._connections = None

 #ef _get_subject(self):
 #eturn self.session

 #ef _transaction_is_active(self):
 #eturn self._state is ACTIVE

 #ef _transaction_is_closed(self):
 #eturn self._state is CLOSED


class Session(_SessionClassMethods):
 #""Manages persistence operations for ORM-mapped objects.

 #he Session's usage paradigm is described at :doc:`/orm/session`.


 #""

 #util.deprecated_params(
 #utocommit=(
 #2.0",
 #The :paramref:`.Session.autocommit` parameter is deprecated "
 #and will be removed in SQLAlchemy version 2.0.  The "
 #:class:`_orm.Session` now features "autobegin" behavior '
 #such that the :meth:`.Session.begin` method may be called "
 #if a transaction has not yet been started yet.  See the section "
 #:ref:`session_explicit_begin` for background.",
 #,
 #
 #ef __init__(
 #elf,
 #ind=None,
 #utoflush=True,
 #uture=False,
 #xpire_on_commit=True,
 #utocommit=False,
 #wophase=False,
 #inds=None,
 #nable_baked_queries=True,
 #nfo=None,
 #uery_cls=None,
 #:
 #"""Construct a new Session.

 #ee also the :class:`.sessionmaker` function which is used to
 #enerate a :class:`.Session`-producing callable with a given
 #et of arguments.

 #param autocommit:
 #efaults to ``False``. When ``True``, the
 #class:`.Session` does not automatically begin transactions for
 #ndividual statement executions, will acquire connections from the
 #ngine on an as-needed basis, releasing to the connection pool
 #fter each statement. Flushes will begin and commit (or possibly
 #ollback) their own transaction if no transaction is present.
 #hen using this mode, the
 #meth:`.Session.begin` method may be used to explicitly start
 #ransactions, but the usual "autobegin" behavior is not present.

 #param autoflush: When ``True``, all query operations will issue a
 #meth:`~.Session.flush` call to this ``Session`` before proceeding.
 #his is a convenience feature so that :meth:`~.Session.flush` need
 #ot be called repeatedly in order for database queries to retrieve
 #esults. It's typical that ``autoflush`` is used in conjunction
 #ith ``autocommit=False``. In this scenario, explicit calls to
 #meth:`~.Session.flush` are rarely needed; you usually only need to
 #all :meth:`~.Session.commit` (which flushes) to finalize changes.

 #param bind: An optional :class:`_engine.Engine` or
 #class:`_engine.Connection` to
 #hich this ``Session`` should be bound. When specified, all SQL
 #perations performed by this session will execute via this
 #onnectable.

 #param binds: A dictionary which may specify any number of
 #class:`_engine.Engine` or :class:`_engine.Connection`
 #bjects as the source of
 #onnectivity for SQL operations on a per-entity basis.   The keys
 #f the dictionary consist of any series of mapped classes,
 #rbitrary Python classes that are bases for mapped classes,
 #class:`_schema.Table` objects and :class:`_orm.Mapper` objects.
 #he
 #alues of the dictionary are then instances of
 #class:`_engine.Engine`
 #r less commonly :class:`_engine.Connection` objects.
 #perations which
 #roceed relative to a particular mapped class will consult this
 #ictionary for the closest matching entity in order to determine
 #hich :class:`_engine.Engine` should be used for a particular SQL
 #peration.    The complete heuristics for resolution are
 #escribed at :meth:`.Session.get_bind`.  Usage looks like::

 #ession = sessionmaker(binds={
 #omeMappedClass: create_engine('postgresql://engine1'),
 #omeDeclarativeBase: create_engine('postgresql://engine2'),
 #ome_mapper: create_engine('postgresql://engine3'),
 #ome_table: create_engine('postgresql://engine4'),
 #)

 #. seealso::

 #ref:`session_partitioning`

 #meth:`.Session.bind_mapper`

 #meth:`.Session.bind_table`

 #meth:`.Session.get_bind`


 #param \class_: Specify an alternate class other than
 #`sqlalchemy.orm.session.Session`` which should be used by the
 #eturned class. This is the only argument that is local to the
 #class:`.sessionmaker` function, and is not sent directly to the
 #onstructor for ``Session``.

 #param enable_baked_queries: defaults to ``True``.  A flag consumed
 #y the :mod:`sqlalchemy.ext.baked` extension to determine if
 #baked queries" should be cached, as is the normal operation
 #f this extension.  When set to ``False``, all caching is disabled,
 #ncluding baked queries defined by the calling application as
 #ell as those used internally.  Setting this flag to ``False``
 #an significantly reduce memory use, however will also degrade
 #erformance for those areas that make use of baked queries
 #such as relationship loaders).   Additionally, baked query
 #ogic in the calling application or potentially within the ORM
 #hat may be malfunctioning due to cache key collisions or similar
 #an be flagged by observing if this flag resolves the issue.

 #. versionadded:: 1.2

 #param expire_on_commit:  Defaults to ``True``. When ``True``, all
 #nstances will be fully expired after each :meth:`~.commit`,
 #o that all attribute/object access subsequent to a completed
 #ransaction will load from the most recent database state.

 #. seealso::

 #ref:`session_committing`

 #param future: if True, use 2.0 style transactional and engine
 #ehavior.  Future mode includes the following behaviors:

 # The :class:`_orm.Session` will not use "bound" metadata in order
 #o locate an :class:`_engine.Engine`; the engine or engines in use
 #ust be specified to the constructor of :class:`_orm.Session` or
 #therwise be configured against the :class:`_orm.sessionmaker`
 #n use

 # The "subtransactions" feature of :meth:`_orm.Session.begin` is
 #emoved in version 2.0 and is disabled when the future flag is
 #et.

 # The behavior of the :paramref:`_orm.relationship.cascade_backrefs`
 #lag on a :func:`_orm.relationship` will always assume
 #False" behavior.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`migration_20_toplevel`

 #param info: optional dictionary of arbitrary data to be associated
 #ith this :class:`.Session`.  Is available via the
 #attr:`.Session.info` attribute.  Note the dictionary is copied at
 #onstruction time so that modifications to the per-
 #class:`.Session` dictionary will be local to that
 #class:`.Session`.

 #param query_cls:  Class which should be used to create new Query
 #bjects, as returned by the :meth:`~.Session.query` method.
 #efaults to :class:`_query.Query`.

 #param twophase:  When ``True``, all transactions will be started as
 # "two phase" transaction, i.e. using the "two phase" semantics
 #f the database in use along with an XID.  During a
 #meth:`~.commit`, after :meth:`~.flush` has been issued for all
 #ttached databases, the :meth:`~.TwoPhaseTransaction.prepare`
 #ethod on each database's :class:`.TwoPhaseTransaction` will be
 #alled. This allows each database to roll back the entire
 #ransaction, before each transaction is committed.

 #""
 #elf.identity_map = identity.WeakInstanceDict()

 #elf._new = {}  # InstanceState->object, strong refs object
 #elf._deleted = {}  # same
 #elf.bind = bind
 #elf.__binds = {}
 #elf._flushing = False
 #elf._warn_on_events = False
 #elf._transaction = None
 #elf._nested_transaction = None
 #elf.future = future
 #elf.hash_key = _new_sessionid()
 #elf.autoflush = autoflush
 #elf.expire_on_commit = expire_on_commit
 #elf.enable_baked_queries = enable_baked_queries

 #f autocommit:
 #f future:
 #aise sa_exc.ArgumentError(
 #Cannot use autocommit mode with future=True."
 #
 #elf.autocommit = True
 #lse:
 #elf.autocommit = False

 #elf.twophase = twophase
 #elf._query_cls = query_cls if query_cls else query.Query
 #f info:
 #elf.info.update(info)

 #f binds is not None:
 #or key, bind in binds.items():
 #elf._add_bind(key, bind)

 #sessions[self.hash_key] = self

    # used by sqlalchemy.engine.util.TransactionalContext
 #trans_context_manager = None

 #onnection_callable = None

 #ef __enter__(self):
 #eturn self

 #ef __exit__(self, type_, value, traceback):
 #elf.close()

 #util.contextmanager
 #ef _maker_context_manager(self):
 #ith self:
 #ith self.begin():
 #ield self

 #property
 #util.deprecated_20(
 #:attr:`_orm.Session.transaction`",
 #lternative="For context manager use, use "
 #:meth:`_orm.Session.begin`.  To access "
 #the current root transaction, use "
 #:meth:`_orm.Session.get_transaction`.",
 #arn_on_attribute_access=True,
 #
 #ef transaction(self):
 #""The current active or inactive :class:`.SessionTransaction`.

 #ay be None if no transaction has begun yet.

 #. versionchanged:: 1.4  the :attr:`.Session.transaction` attribute
 #s now a read-only descriptor that also may return None if no
 #ransaction has begun yet.


 #""
 #eturn self._legacy_transaction()

 #ef _legacy_transaction(self):
 #f not self.future:
 #elf._autobegin()
 #eturn self._transaction

 #ef in_transaction(self):
 #""Return True if this :class:`_orm.Session` has begun a transaction.

 #. versionadded:: 1.4

 #. seealso::

 #attr:`_orm.Session.is_active`


 #""
 #eturn self._transaction is not None

 #ef in_nested_transaction(self):
 #""Return True if this :class:`_orm.Session` has begun a nested
 #ransaction, e.g. SAVEPOINT.

 #. versionadded:: 1.4

 #""
 #eturn self._nested_transaction is not None

 #ef get_transaction(self):
 #""Return the current root transaction in progress, if any.

 #. versionadded:: 1.4

 #""
 #rans = self._transaction
 #hile trans is not None and trans._parent is not None:
 #rans = trans._parent
 #eturn trans

 #ef get_nested_transaction(self):
 #""Return the current nested transaction in progress, if any.

 #. versionadded:: 1.4

 #""

 #eturn self._nested_transaction

 #util.memoized_property
 #ef info(self):
 #""A user-modifiable dictionary.

 #he initial value of this dictionary can be populated using the
 #`info`` argument to the :class:`.Session` constructor or
 #class:`.sessionmaker` constructor or factory methods.  The dictionary
 #ere is always local to this :class:`.Session` and can be modified
 #ndependently of all other :class:`.Session` objects.

 #""
 #eturn {}

 #ef _autobegin(self):
 #f not self.autocommit and self._transaction is None:

 #rans = SessionTransaction(self, autobegin=True)
 #ssert self._transaction is trans
 #eturn True

 #eturn False

 #util.deprecated_params(
 #ubtransactions=(
 #2.0",
 #The :paramref:`_orm.Session.begin.subtransactions` flag is "
 #deprecated and "
 #will be removed in SQLAlchemy version 2.0.  See "
 #the documentation at :ref:`session_subtransactions` for "
 #background on a compatible alternative pattern.",
 #
 #
 #ef begin(self, subtransactions=False, nested=False, _subtrans=False):
 #""Begin a transaction, or nested transaction,
 #n this :class:`.Session`, if one is not already begun.

 #he :class:`_orm.Session` object features **autobegin** behavior,
 #o that normally it is not necessary to call the
 #meth:`_orm.Session.begin`
 #ethod explicitly. However, it may be used in order to control
 #he scope of when the transactional state is begun.

 #hen used to begin the outermost transaction, an error is raised
 #f this :class:`.Session` is already inside of a transaction.

 #param nested: if True, begins a SAVEPOINT transaction and is
 #quivalent to calling :meth:`~.Session.begin_nested`. For
 #ocumentation on SAVEPOINT transactions, please see
 #ref:`session_begin_nested`.

 #param subtransactions: if True, indicates that this
 #meth:`~.Session.begin` can create a "subtransaction".

 #return: the :class:`.SessionTransaction` object.  Note that
 #class:`.SessionTransaction`
 #cts as a Python context manager, allowing :meth:`.Session.begin`
 #o be used in a "with" block.  See :ref:`session_autocommit` for
 #n example.

 #. seealso::

 #ref:`session_autobegin`

 #ref:`unitofwork_transaction`

 #meth:`.Session.begin_nested`


 #""

 #f subtransactions and self.future:
 #aise NotImplementedError(
 #subtransactions are not implemented in future "
 #Session objects."
 #
 #f self._autobegin():
 #f not subtransactions and not nested and not _subtrans:
 #eturn self._transaction

 #f self._transaction is not None:
 #f subtransactions or _subtrans or nested:
 #rans = self._transaction._begin(nested=nested)
 #ssert self._transaction is trans
 #f nested:
 #elf._nested_transaction = trans
 #lse:
 #aise sa_exc.InvalidRequestError(
 #A transaction is already begun on this Session."
 #
 #lif not self.autocommit:
            # outermost transaction.  must be a not nested and not
            # a subtransaction
 #ssert not nested and not _subtrans and not subtransactions
 #rans = SessionTransaction(self)
 #ssert self._transaction is trans
 #lse:
            # legacy autocommit mode
 #ssert not self.future
 #rans = SessionTransaction(self, nested=nested)
 #ssert self._transaction is trans

 #eturn self._transaction  # needed for __enter__/__exit__ hook

 #ef begin_nested(self):
 #""Begin a "nested" transaction on this Session, e.g. SAVEPOINT.

 #he target database(s) and associated drivers must support SQL
 #AVEPOINT for this method to function correctly.

 #or documentation on SAVEPOINT
 #ransactions, please see :ref:`session_begin_nested`.

 #return: the :class:`.SessionTransaction` object.  Note that
 #class:`.SessionTransaction` acts as a context manager, allowing
 #meth:`.Session.begin_nested` to be used in a "with" block.
 #ee :ref:`session_begin_nested` for a usage example.

 #. seealso::

 #ref:`session_begin_nested`

 #ref:`pysqlite_serializable` - special workarounds required
 #ith the SQLite driver in order for SAVEPOINT to work
 #orrectly.

 #""
 #eturn self.begin(nested=True)

 #ef rollback(self):
 #""Rollback the current transaction in progress.

 #f no transaction is in progress, this method is a pass-through.

 #n :term:`1.x-style` use, this method rolls back the topmost
 #atabase transaction if no nested transactions are in effect, or
 #o the current nested transaction if one is in effect.

 #hen
 #term:`2.0-style` use is in effect via the
 #paramref:`_orm.Session.future` flag, the method always rolls back
 #he topmost database transaction, discarding any nested
 #ransactions that may be in progress.

 #. seealso::

 #ref:`session_rollback`

 #ref:`unitofwork_transaction`

 #""
 #f self._transaction is None:
 #ass
 #lse:
 #elf._transaction.rollback(_to_root=self.future)

 #ef commit(self):
 #""Flush pending changes and commit the current transaction.

 #f no transaction is in progress, the method will first
 #autobegin" a new transaction and commit.

 #f :term:`1.x-style` use is in effect and there are currently
 #AVEPOINTs in progress via :meth:`_orm.Session.begin_nested`,
 #he operation will release the current SAVEPOINT but not commit
 #he outermost database transaction.

 #f :term:`2.0-style` use is in effect via the
 #paramref:`_orm.Session.future` flag, the outermost database
 #ransaction is committed unconditionally, automatically releasing any
 #AVEPOINTs in effect.

 #hen using legacy "autocommit" mode, this method is only
 #alid to call if a transaction is actually in progress, else
 #n error is raised.   Similarly, when using legacy "subtransactions",
 #he method will instead close out the current "subtransaction",
 #ather than the actual database transaction, if a transaction
 #s in progress.

 #. seealso::

 #ref:`session_committing`

 #ref:`unitofwork_transaction`

 #""
 #f self._transaction is None:
 #f not self._autobegin():
 #aise sa_exc.InvalidRequestError("No transaction is begun.")

 #elf._transaction.commit(_to_root=self.future)

 #ef prepare(self):
 #""Prepare the current transaction in progress for two phase commit.

 #f no transaction is in progress, this method raises an
 #exc:`~sqlalchemy.exc.InvalidRequestError`.

 #nly root transactions of two phase sessions can be prepared. If the
 #urrent transaction is not such, an
 #exc:`~sqlalchemy.exc.InvalidRequestError` is raised.

 #""
 #f self._transaction is None:
 #f not self._autobegin():
 #aise sa_exc.InvalidRequestError("No transaction is begun.")

 #elf._transaction.prepare()

 #ef connection(
 #elf,
 #ind_arguments=None,
 #lose_with_result=False,
 #xecution_options=None,
 #*kw
 #:
 #"""Return a :class:`_engine.Connection` object corresponding to this
 #class:`.Session` object's transactional state.

 #f this :class:`.Session` is configured with ``autocommit=False``,
 #ither the :class:`_engine.Connection` corresponding to the current
 #ransaction is returned, or if no transaction is in progress, a new
 #ne is begun and the :class:`_engine.Connection`
 #eturned (note that no
 #ransactional state is established with the DBAPI until the first
 #QL statement is emitted).

 #lternatively, if this :class:`.Session` is configured with
 #`autocommit=True``, an ad-hoc :class:`_engine.Connection` is returned
 #sing :meth:`_engine.Engine.connect` on the underlying
 #class:`_engine.Engine`.

 #mbiguity in multi-bind or unbound :class:`.Session` objects can be
 #esolved through any of the optional keyword arguments.   This
 #ltimately makes usage of the :meth:`.get_bind` method for resolution.

 #param bind_arguments: dictionary of bind arguments.  May include
 #mapper", "bind", "clause", other custom arguments that are passed
 #o :meth:`.Session.get_bind`.

 #param bind:
 #eprecated; use bind_arguments

 #param mapper:
 #eprecated; use bind_arguments

 #param clause:
 #eprecated; use bind_arguments

 #param close_with_result: Passed to :meth:`_engine.Engine.connect`,
 #ndicating the :class:`_engine.Connection` should be considered
 #single use", automatically closing when the first result set is
 #losed.  This flag only has an effect if this :class:`.Session` is
 #onfigured with ``autocommit=True`` and does not already have a
 #ransaction in progress.

 #. deprecated:: 1.4  this parameter is deprecated and will be removed
 #n SQLAlchemy 2.0

 #param execution_options: a dictionary of execution options that will
 #e passed to :meth:`_engine.Connection.execution_options`, **when the
 #onnection is first procured only**.   If the connection is already
 #resent within the :class:`.Session`, a warning is emitted and
 #he arguments are ignored.

 #. seealso::

 #ref:`session_transaction_isolation`

 #param \**kw:
 #eprecated; use bind_arguments

 #""

 #f not bind_arguments:
 #ind_arguments = kw

 #ind = bind_arguments.pop("bind", None)
 #f bind is None:
 #ind = self.get_bind(**bind_arguments)

 #eturn self._connection_for_bind(
 #ind,
 #lose_with_result=close_with_result,
 #xecution_options=execution_options,
 #

 #ef _connection_for_bind(self, engine, execution_options=None, **kw):
 #ransactionalContext._trans_ctx_check(self)

 #f self._transaction is not None or self._autobegin():
 #eturn self._transaction._connection_for_bind(
 #ngine, execution_options
 #

 #ssert self._transaction is None
 #ssert self.autocommit
 #onn = engine.connect(**kw)
 #f execution_options:
 #onn = conn.execution_options(**execution_options)
 #eturn conn

 #ef execute(
 #elf,
 #tatement,
 #arams=None,
 #xecution_options=util.EMPTY_DICT,
 #ind_arguments=None,
 #parent_execute_state=None,
 #add_event=None,
 #*kw
 #:
 #"""Execute a SQL expression construct.

 #eturns a :class:`_engine.Result` object representing
 #esults of the statement execution.

 #.g.::

 #rom sqlalchemy import select
 #esult = session.execute(
 #elect(User).where(User.id == 5)
 #

 #he API contract of :meth:`_orm.Session.execute` is similar to that
 #f :meth:`_future.Connection.execute`, the :term:`2.0 style` version
 #f :class:`_future.Connection`.

 #. versionchanged:: 1.4 the :meth:`_orm.Session.execute` method is
 #ow the primary point of ORM statement execution when using
 #term:`2.0 style` ORM usage.

 #param statement:
 #n executable statement (i.e. an :class:`.Executable` expression
 #uch as :func:`_expression.select`).

 #param params:
 #ptional dictionary, or list of dictionaries, containing
 #ound parameter values.   If a single dictionary, single-row
 #xecution occurs; if a list of dictionaries, an
 #executemany" will be invoked.  The keys in each dictionary
 #ust correspond to parameter names present in the statement.

 #param execution_options: optional dictionary of execution options,
 #hich will be associated with the statement execution.  This
 #ictionary can provide a subset of the options that are accepted
 #y :meth:`_future.Connection.execution_options`, and may also
 #rovide additional options understood only in an ORM context.

 #param bind_arguments: dictionary of additional arguments to determine
 #he bind.  May include "mapper", "bind", or other custom arguments.
 #ontents of this dictionary are passed to the
 #meth:`.Session.get_bind` method.

 #param mapper:
 #eprecated; use the bind_arguments dictionary

 #param bind:
 #eprecated; use the bind_arguments dictionary

 #param \**kw:
 #eprecated; use the bind_arguments dictionary

 #return: a :class:`_engine.Result` object.


 #""
 #tatement = coercions.expect(roles.StatementRole, statement)

 #f kw:
 #til.warn_deprecated_20(
 #Passing bind arguments to Session.execute() as keyword "
 #arguments is deprecated and will be removed SQLAlchemy 2.0. "
 #Please use the bind_arguments parameter."
 #
 #f not bind_arguments:
 #ind_arguments = kw
 #lse:
 #ind_arguments.update(kw)
 #lif not bind_arguments:
 #ind_arguments = {}

 #f (
 #tatement._propagate_attrs.get("compile_state_plugin", None)
 #= "orm"
 #:
            # note that even without "future" mode, we need
 #ompile_state_cls = CompileState._get_plugin_class_for_plugin(
 #tatement, "orm"
 #
 #lse:
 #ompile_state_cls = None

 #xecution_options = util.coerce_to_immutabledict(execution_options)

 #f compile_state_cls is not None:
 #
 #tatement,
 #xecution_options,
 # = compile_state_cls.orm_pre_session_exec(
 #elf,
 #tatement,
 #arams,
 #xecution_options,
 #ind_arguments,
 #parent_execute_state is not None,
 #
 #lse:
 #ind_arguments.setdefault("clause", statement)
 #xecution_options = execution_options.union(
 #"future_result": True}
 #

 #f _parent_execute_state:
 #vents_todo = _parent_execute_state._remaining_events()
 #lse:
 #vents_todo = self.dispatch.do_orm_execute
 #f _add_event:
 #vents_todo = list(events_todo) + [_add_event]

 #f events_todo:
 #rm_exec_state = ORMExecuteState(
 #elf,
 #tatement,
 #arams,
 #xecution_options,
 #ind_arguments,
 #ompile_state_cls,
 #vents_todo,
 #
 #or idx, fn in enumerate(events_todo):
 #rm_exec_state._starting_event_idx = idx
 #esult = fn(orm_exec_state)
 #f result:
 #eturn result

 #tatement = orm_exec_state.statement
 #xecution_options = orm_exec_state.local_execution_options

 #ind = self.get_bind(**bind_arguments)

 #f self.autocommit:
            # legacy stuff, we can't use future_result w/ autocommit because
            # we rely upon close_with_result, also legacy.  it's all
            # interrelated
 #onn = self._connection_for_bind(bind, close_with_result=True)
 #xecution_options = execution_options.union(
 #ict(future_result=False)
 #
 #lse:
 #onn = self._connection_for_bind(bind)
 #esult = conn._execute_20(statement, params or {}, execution_options)

 #f compile_state_cls:
 #esult = compile_state_cls.orm_setup_cursor_result(
 #elf,
 #tatement,
 #arams,
 #xecution_options,
 #ind_arguments,
 #esult,
 #

 #eturn result

 #ef scalar(
 #elf,
 #tatement,
 #arams=None,
 #xecution_options=util.EMPTY_DICT,
 #ind_arguments=None,
 #*kw
 #:
 #""Execute a statement and return a scalar result.

 #sage and parameters are the same as that of
 #meth:`_orm.Session.execute`; the return result is a scalar Python
 #alue.

 #""

 #eturn self.execute(
 #tatement,
 #arams=params,
 #xecution_options=execution_options,
 #ind_arguments=bind_arguments,
 #*kw
 #.scalar()

 #ef close(self):
 #""Close out the transactional resources and ORM objects used by this
 #class:`_orm.Session`.

 #his expunges all ORM objects associated with this
 #class:`_orm.Session`, ends any transaction in progress and
 #term:`releases` any :class:`_engine.Connection` objects which this
 #class:`_orm.Session` itself has checked out from associated
 #class:`_engine.Engine` objects. The operation then leaves the
 #class:`_orm.Session` in a state which it may be used again.

 #. tip::

 #he :meth:`_orm.Session.close` method **does not prevent the
 #ession from being used again**.   The :class:`_orm.Session` itself
 #oes not actually have a distinct "closed" state; it merely means
 #he :class:`_orm.Session` will release all database connections
 #nd ORM objects.

 #. versionchanged:: 1.4  The :meth:`.Session.close` method does not
 #mmediately create a new :class:`.SessionTransaction` object;
 #nstead, the new :class:`.SessionTransaction` is created only if
 #he :class:`.Session` is used again for a database operation.

 #. seealso::

 #ref:`session_closing` - detail on the semantics of
 #meth:`_orm.Session.close`

 #""
 #elf._close_impl(invalidate=False)

 #ef invalidate(self):
 #""Close this Session, using connection invalidation.

 #his is a variant of :meth:`.Session.close` that will additionally
 #nsure that the :meth:`_engine.Connection.invalidate`
 #ethod will be called on each :class:`_engine.Connection` object
 #hat is currently in use for a transaction (typically there is only
 #ne connection unless the :class:`_orm.Session` is used with
 #ultiple engines).

 #his can be called when the database is known to be in a state where
 #he connections are no longer safe to be used.

 #elow illustrates a scenario when using `gevent
 #https://www.gevent.org/>`_, which can produce ``Timeout`` exceptions
 #hat may mean the underlying connection should be discarded::

 #mport gevent

 #ry:
 #ess = Session()
 #ess.add(User())
 #ess.commit()
 #xcept gevent.Timeout:
 #ess.invalidate()
 #aise
 #xcept:
 #ess.rollback()
 #aise

 #he method additionally does everything that :meth:`_orm.Session.close`
 #oes, including that all ORM objects are expunged.

 #""
 #elf._close_impl(invalidate=True)

 #ef _close_impl(self, invalidate):
 #elf.expunge_all()
 #f self._transaction is not None:
 #or transaction in self._transaction._iterate_self_and_parents():
 #ransaction.close(invalidate)

 #ef expunge_all(self):
 #""Remove all object instances from this ``Session``.

 #his is equivalent to calling ``expunge(obj)`` on all objects in this
 #`Session``.

 #""

 #ll_states = self.identity_map.all_states() + list(self._new)
 #elf.identity_map = identity.WeakInstanceDict()
 #elf._new = {}
 #elf._deleted = {}

 #tatelib.InstanceState._detach_states(all_states, self)

 #ef _add_bind(self, key, bind):
 #ry:
 #nsp = inspect(key)
 #xcept sa_exc.NoInspectionAvailable as err:
 #f not isinstance(key, type):
 #til.raise_(
 #a_exc.ArgumentError(
 #Not an acceptable bind target: %s" % key
 #,
 #eplace_context=err,
 #
 #lse:
 #elf.__binds[key] = bind
 #lse:
 #f insp.is_selectable:
 #elf.__binds[insp] = bind
 #lif insp.is_mapper:
 #elf.__binds[insp.class_] = bind
 #or _selectable in insp._all_tables:
 #elf.__binds[_selectable] = bind
 #lse:
 #aise sa_exc.ArgumentError(
 #Not an acceptable bind target: %s" % key
 #

 #ef bind_mapper(self, mapper, bind):
 #""Associate a :class:`_orm.Mapper` or arbitrary Python class with a
 #bind", e.g. an :class:`_engine.Engine` or
 #class:`_engine.Connection`.

 #he given entity is added to a lookup used by the
 #meth:`.Session.get_bind` method.

 #param mapper: a :class:`_orm.Mapper` object,
 #r an instance of a mapped
 #lass, or any Python class that is the base of a set of mapped
 #lasses.

 #param bind: an :class:`_engine.Engine` or :class:`_engine.Connection`
 #bject.

 #. seealso::

 #ref:`session_partitioning`

 #paramref:`.Session.binds`

 #meth:`.Session.bind_table`


 #""
 #elf._add_bind(mapper, bind)

 #ef bind_table(self, table, bind):
 #""Associate a :class:`_schema.Table` with a "bind", e.g. an
 #class:`_engine.Engine`
 #r :class:`_engine.Connection`.

 #he given :class:`_schema.Table` is added to a lookup used by the
 #meth:`.Session.get_bind` method.

 #param table: a :class:`_schema.Table` object,
 #hich is typically the target
 #f an ORM mapping, or is present within a selectable that is
 #apped.

 #param bind: an :class:`_engine.Engine` or :class:`_engine.Connection`
 #bject.

 #. seealso::

 #ref:`session_partitioning`

 #paramref:`.Session.binds`

 #meth:`.Session.bind_mapper`


 #""
 #elf._add_bind(table, bind)

 #ef get_bind(
 #elf,
 #apper=None,
 #lause=None,
 #ind=None,
 #sa_skip_events=None,
 #sa_skip_for_implicit_returning=False,
 #:
 #""Return a "bind" to which this :class:`.Session` is bound.

 #he "bind" is usually an instance of :class:`_engine.Engine`,
 #xcept in the case where the :class:`.Session` has been
 #xplicitly bound directly to a :class:`_engine.Connection`.

 #or a multiply-bound or unbound :class:`.Session`, the
 #`mapper`` or ``clause`` arguments are used to determine the
 #ppropriate bind to return.

 #ote that the "mapper" argument is usually present
 #hen :meth:`.Session.get_bind` is called via an ORM
 #peration such as a :meth:`.Session.query`, each
 #ndividual INSERT/UPDATE/DELETE operation within a
 #meth:`.Session.flush`, call, etc.

 #he order of resolution is:

 #. if mapper given and :paramref:`.Session.binds` is present,
 #ocate a bind based first on the mapper in use, then
 #n the mapped class in use, then on any base classes that are
 #resent in the ``__mro__`` of the mapped class, from more specific
 #uperclasses to more general.
 #. if clause given and ``Session.binds`` is present,
 #ocate a bind based on :class:`_schema.Table` objects
 #ound in the given clause present in ``Session.binds``.
 #. if ``Session.binds`` is present, return that.
 #. if clause given, attempt to return a bind
 #inked to the :class:`_schema.MetaData` ultimately
 #ssociated with the clause.
 #. if mapper given, attempt to return a bind
 #inked to the :class:`_schema.MetaData` ultimately
 #ssociated with the :class:`_schema.Table` or other
 #electable to which the mapper is mapped.
 #. No bind can be found, :exc:`~sqlalchemy.exc.UnboundExecutionError`
 #s raised.

 #ote that the :meth:`.Session.get_bind` method can be overridden on
 # user-defined subclass of :class:`.Session` to provide any kind
 #f bind resolution scheme.  See the example at
 #ref:`session_custom_partitioning`.

 #param mapper:
 #ptional :func:`.mapper` mapped class or instance of
 #class:`_orm.Mapper`.   The bind can be derived from a
 #class:`_orm.Mapper`
 #irst by consulting the "binds" map associated with this
 #class:`.Session`, and secondly by consulting the
 #class:`_schema.MetaData`
 #ssociated with the :class:`_schema.Table` to which the
 #class:`_orm.Mapper`
 #s mapped for a bind.

 #param clause:
 # :class:`_expression.ClauseElement` (i.e.
 #func:`_expression.select`,
 #func:`_expression.text`,
 #tc.).  If the ``mapper`` argument is not present or could not
 #roduce a bind, the given expression construct will be searched
 #or a bound element, typically a :class:`_schema.Table`
 #ssociated with
 #ound :class:`_schema.MetaData`.

 #. seealso::

 #ref:`session_partitioning`

 #paramref:`.Session.binds`

 #meth:`.Session.bind_mapper`

 #meth:`.Session.bind_table`

 #""

        # this function is documented as a subclassing hook, so we have
        # to call this method even if the return is simple
 #f bind:
 #eturn bind
 #lif not self.__binds and self.bind:
            # simplest and most common case, we have a bind and no
            # per-mapper/table binds, we're done
 #eturn self.bind

        # we don't have self.bind and either have self.__binds
        # or we don't have self.__binds (which is legacy).  Look at the
        # mapper and the clause
 #f mapper is clause is None:
 #f self.bind:
 #eturn self.bind
 #lse:
 #aise sa_exc.UnboundExecutionError(
 #This session is not bound to a single Engine or "
 #Connection, and no context was provided to locate "
 #a binding."
 #

        # look more closely at the mapper.
 #f mapper is not None:
 #ry:
 #apper = inspect(mapper)
 #xcept sa_exc.NoInspectionAvailable as err:
 #f isinstance(mapper, type):
 #til.raise_(
 #xc.UnmappedClassError(mapper),
 #eplace_context=err,
 #
 #lse:
 #aise

        # match up the mapper or clause in the __binds
 #f self.__binds:
            # matching mappers and selectables to entries in the
            # binds dictionary; supported use case.
 #f mapper:
 #or cls in mapper.class_.__mro__:
 #f cls in self.__binds:
 #eturn self.__binds[cls]
 #f clause is None:
 #lause = mapper.persist_selectable

 #f clause is not None:
 #lugin_subject = clause._propagate_attrs.get(
 #plugin_subject", None
 #

 #f plugin_subject is not None:
 #or cls in plugin_subject.mapper.class_.__mro__:
 #f cls in self.__binds:
 #eturn self.__binds[cls]

 #or obj in visitors.iterate(clause):
 #f obj in self.__binds:
 #eturn self.__binds[obj]

        # none of the __binds matched, but we have a fallback bind.
        # return that
 #f self.bind:
 #eturn self.bind

        # now we are in legacy territory.  looking for "bind" on tables
        # that are via bound metadata.   this goes away in 2.0.

 #uture_msg = ""
 #uture_code = ""

 #f mapper and clause is None:
 #lause = mapper.persist_selectable

 #f clause is not None:
 #f clause.bind:
 #f self.future:
 #uture_msg = (
 # A bind was located via legacy bound metadata, but "
 #since future=True is set on this Session, this "
 #bind is ignored."
 #
 #lse:
 #til.warn_deprecated_20(
 #This Session located a target engine via bound "
 #metadata; as this functionality will be removed in "
 #SQLAlchemy 2.0, an Engine object should be passed "
 #to the Session() constructor directly."
 #
 #eturn clause.bind

 #f mapper:
 #f mapper.persist_selectable.bind:
 #f self.future:
 #uture_msg = (
 # A bind was located via legacy bound metadata, but "
 #since future=True is set on this Session, this "
 #bind is ignored."
 #
 #lse:
 #til.warn_deprecated_20(
 #This Session located a target engine via bound "
 #metadata; as this functionality will be removed in "
 #SQLAlchemy 2.0, an Engine object should be passed "
 #to the Session() constructor directly."
 #
 #eturn mapper.persist_selectable.bind

 #ontext = []
 #f mapper is not None:
 #ontext.append("mapper %s" % mapper)
 #f clause is not None:
 #ontext.append("SQL expression")

 #aise sa_exc.UnboundExecutionError(
 #Could not locate a bind configured on %s or this Session.%s"
 # (", ".join(context), future_msg),
 #ode=future_code,
 #

 #ef query(self, *entities, **kwargs):
 #""Return a new :class:`_query.Query` object corresponding to this
 #class:`_orm.Session`.

 #""

 #eturn self._query_cls(entities, self, **kwargs)

 #ef _identity_lookup(
 #elf,
 #apper,
 #rimary_key_identity,
 #dentity_token=None,
 #assive=attributes.PASSIVE_OFF,
 #azy_loaded_from=None,
 #:
 #""Locate an object in the identity map.

 #iven a primary key identity, constructs an identity key and then
 #ooks in the session's identity map.  If present, the object may
 #e run through unexpiration rules (e.g. load unloaded attributes,
 #heck if was deleted).

 #.g.::

 #bj = session._identity_lookup(inspect(SomeClass), (1, ))

 #param mapper: mapper in use
 #param primary_key_identity: the primary key we are searching for, as
 # tuple.
 #param identity_token: identity token that should be used to create
 #he identity key.  Used as is, however overriding subclasses can
 #epurpose this in order to interpret the value in a special way,
 #uch as if None then look among multiple target tokens.
 #param passive: passive load flag passed to
 #func:`.loading.get_from_identity`, which impacts the behavior if
 #he object is found; the object may be validated and/or unexpired
 #f the flag allows for SQL to be emitted.
 #param lazy_loaded_from: an :class:`.InstanceState` that is
 #pecifically asking for this identity as a related identity.  Used
 #or sharding schemes where there is a correspondence between an object
 #nd a related object being lazy-loaded (or otherwise
 #elationship-loaded).

 #return: None if the object is not found in the identity map, *or*
 #f the object was unexpired and found to have been deleted.
 #f passive flags disallow SQL and the object is expired, returns
 #ASSIVE_NO_RESULT.   In all other cases the instance is returned.

 #. versionchanged:: 1.4.0 - the :meth:`.Session._identity_lookup`
 #ethod was moved from :class:`_query.Query` to
 #class:`.Session`, to avoid having to instantiate the
 #class:`_query.Query` object.


 #""

 #ey = mapper.identity_key_from_primary_key(
 #rimary_key_identity, identity_token=identity_token
 #
 #eturn loading.get_from_identity(self, mapper, key, passive)

 #property
 #util.contextmanager
 #ef no_autoflush(self):
 #""Return a context manager that disables autoflush.

 #.g.::

 #ith session.no_autoflush:

 #ome_object = SomeClass()
 #ession.add(some_object)
                # won't autoflush
 #ome_object.related_thing = session.query(SomeRelated).first()

 #perations that proceed within the ``with:`` block
 #ill not be subject to flushes occurring upon query
 #ccess.  This is useful when initializing a series
 #f objects which involve existing database queries,
 #here the uncompleted object should not yet be flushed.

 #""
 #utoflush = self.autoflush
 #elf.autoflush = False
 #ry:
 #ield self
 #inally:
 #elf.autoflush = autoflush

 #ef _autoflush(self):
 #f self.autoflush and not self._flushing:
 #ry:
 #elf.flush()
 #xcept sa_exc.StatementError as e:
                # note we are reraising StatementError as opposed to
                # raising FlushError with "chaining" to remain compatible
                # with code that catches StatementError, IntegrityError,
                # etc.
 #.add_detail(
 #raised as a result of Query-invoked autoflush; "
 #consider using a session.no_autoflush block if this "
 #flush is occurring prematurely"
 #
 #til.raise_(e, with_traceback=sys.exc_info()[2])

 #ef refresh(self, instance, attribute_names=None, with_for_update=None):
 #""Expire and refresh attributes on the given instance.

 #he selected attributes will first be expired as they would when using
 #meth:`_orm.Session.expire`; then a SELECT statement will be issued to
 #he database to refresh column-oriented attributes with the current
 #alue available in the current transaction.

 #func:`_orm.relationship` oriented attributes will also be immediately
 #oaded if they were already eagerly loaded on the object, using the
 #ame eager loading strategy that they were loaded with originally.
 #nloaded relationship attributes will remain unloaded, as will
 #elationship attributes that were originally lazy loaded.

 #. versionadded:: 1.4 - the :meth:`_orm.Session.refresh` method
 #an also refresh eagerly loaded attributes.

 #. tip::

 #hile the :meth:`_orm.Session.refresh` method is capable of
 #efreshing both column and relationship oriented attributes, its
 #rimary focus is on refreshing of local column-oriented attributes
 #n a single instance. For more open ended "refresh" functionality,
 #ncluding the ability to refresh the attributes on many objects at
 #nce while having explicit control over relationship loader
 #trategies, use the
 #ref:`populate existing <orm_queryguide_populate_existing>` feature
 #nstead.

 #ote that a highly isolated transaction will return the same values as
 #ere previously read in that same transaction, regardless of changes
 #n database state outside of that transaction.   Refreshing
 #ttributes usually only makes sense at the start of a transaction
 #here database rows have not yet been accessed.

 #param attribute_names: optional.  An iterable collection of
 #tring attribute names indicating a subset of attributes to
 #e refreshed.

 #param with_for_update: optional boolean ``True`` indicating FOR UPDATE
 #hould be used, or may be a dictionary containing flags to
 #ndicate a more specific set of FOR UPDATE flags for the SELECT;
 #lags should match the parameters of
 #meth:`_query.Query.with_for_update`.
 #upersedes the :paramref:`.Session.refresh.lockmode` parameter.

 #. seealso::

 #ref:`session_expire` - introductory material

 #meth:`.Session.expire`

 #meth:`.Session.expire_all`

 #ref:`orm_queryguide_populate_existing` - allows any ORM query
 #o refresh objects as they would be loaded normally.

 #""
 #ry:
 #tate = attributes.instance_state(instance)
 #xcept exc.NO_STATE as err:
 #til.raise_(
 #xc.UnmappedInstanceError(instance),
 #eplace_context=err,
 #

 #elf._expire_state(state, attribute_names)

 #f with_for_update == {}:
 #aise sa_exc.ArgumentError(
 #with_for_update should be the boolean value "
 #True, or a dictionary with options.  "
 #A blank dictionary is ambiguous."
 #

 #ith_for_update = query.ForUpdateArg._from_argument(with_for_update)

 #tmt = sql.select(object_mapper(instance))
 #f (
 #oading.load_on_ident(
 #elf,
 #tmt,
 #tate.key,
 #efresh_state=state,
 #ith_for_update=with_for_update,
 #nly_load_props=attribute_names,
 #
 #s None
 #:
 #aise sa_exc.InvalidRequestError(
 #Could not refresh instance '%s'" % instance_str(instance)
 #

 #ef expire_all(self):
 #""Expires all persistent instances within this Session.

 #hen any attributes on a persistent instance is next accessed,
 # query will be issued using the
 #class:`.Session` object's current transactional context in order to
 #oad all expired attributes for the given instance.   Note that
 # highly isolated transaction will return the same values as were
 #reviously read in that same transaction, regardless of changes
 #n database state outside of that transaction.

 #o expire individual objects and individual attributes
 #n those objects, use :meth:`Session.expire`.

 #he :class:`.Session` object's default behavior is to
 #xpire all state whenever the :meth:`Session.rollback`
 #r :meth:`Session.commit` methods are called, so that new
 #tate can be loaded for the new transaction.   For this reason,
 #alling :meth:`Session.expire_all` should not be needed when
 #utocommit is ``False``, assuming the transaction is isolated.

 #. seealso::

 #ref:`session_expire` - introductory material

 #meth:`.Session.expire`

 #meth:`.Session.refresh`

 #meth:`_orm.Query.populate_existing`

 #""
 #or state in self.identity_map.all_states():
 #tate._expire(state.dict, self.identity_map._modified)

 #ef expire(self, instance, attribute_names=None):
 #""Expire the attributes on an instance.

 #arks the attributes of an instance as out of date. When an expired
 #ttribute is next accessed, a query will be issued to the
 #class:`.Session` object's current transactional context in order to
 #oad all expired attributes for the given instance.   Note that
 # highly isolated transaction will return the same values as were
 #reviously read in that same transaction, regardless of changes
 #n database state outside of that transaction.

 #o expire all objects in the :class:`.Session` simultaneously,
 #se :meth:`Session.expire_all`.

 #he :class:`.Session` object's default behavior is to
 #xpire all state whenever the :meth:`Session.rollback`
 #r :meth:`Session.commit` methods are called, so that new
 #tate can be loaded for the new transaction.   For this reason,
 #alling :meth:`Session.expire` only makes sense for the specific
 #ase that a non-ORM SQL statement was emitted in the current
 #ransaction.

 #param instance: The instance to be refreshed.
 #param attribute_names: optional list of string attribute names
 #ndicating a subset of attributes to be expired.

 #. seealso::

 #ref:`session_expire` - introductory material

 #meth:`.Session.expire`

 #meth:`.Session.refresh`

 #meth:`_orm.Query.populate_existing`

 #""
 #ry:
 #tate = attributes.instance_state(instance)
 #xcept exc.NO_STATE as err:
 #til.raise_(
 #xc.UnmappedInstanceError(instance),
 #eplace_context=err,
 #
 #elf._expire_state(state, attribute_names)

 #ef _expire_state(self, state, attribute_names):
 #elf._validate_persistent(state)
 #f attribute_names:
 #tate._expire_attributes(state.dict, attribute_names)
 #lse:
            # pre-fetch the full cascade since the expire is going to
            # remove associations
 #ascaded = list(
 #tate.manager.mapper.cascade_iterator("refresh-expire", state)
 #
 #elf._conditional_expire(state)
 #or o, m, st_, dct_ in cascaded:
 #elf._conditional_expire(st_)

 #ef _conditional_expire(self, state, autoflush=None):
 #""Expire a state if persistent, else expunge if pending"""

 #f state.key:
 #tate._expire(state.dict, self.identity_map._modified)
 #lif state in self._new:
 #elf._new.pop(state)
 #tate._detach(self)

 #ef expunge(self, instance):
 #""Remove the `instance` from this ``Session``.

 #his will free all internal references to the instance.  Cascading
 #ill be applied according to the *expunge* cascade rule.

 #""
 #ry:
 #tate = attributes.instance_state(instance)
 #xcept exc.NO_STATE as err:
 #til.raise_(
 #xc.UnmappedInstanceError(instance),
 #eplace_context=err,
 #
 #f state.session_id is not self.hash_key:
 #aise sa_exc.InvalidRequestError(
 #Instance %s is not present in this Session" % state_str(state)
 #

 #ascaded = list(
 #tate.manager.mapper.cascade_iterator("expunge", state)
 #
 #elf._expunge_states([state] + [st_ for o, m, st_, dct_ in cascaded])

 #ef _expunge_states(self, states, to_transient=False):
 #or state in states:
 #f state in self._new:
 #elf._new.pop(state)
 #lif self.identity_map.contains_state(state):
 #elf.identity_map.safe_discard(state)
 #elf._deleted.pop(state, None)
 #lif self._transaction:
                # state is "detached" from being deleted, but still present
                # in the transaction snapshot
 #elf._transaction._deleted.pop(state, None)
 #tatelib.InstanceState._detach_states(
 #tates, self, to_transient=to_transient
 #

 #ef _register_persistent(self, states):
 #""Register all persistent objects from a flush.

 #his is used both for pending objects moving to the persistent
 #tate as well as already persistent objects.

 #""

 #ending_to_persistent = self.dispatch.pending_to_persistent or None
 #or state in states:
 #apper = _state_mapper(state)

            # prevent against last minute dereferences of the object
 #bj = state.obj()
 #f obj is not None:

 #nstance_key = mapper._identity_key_from_state(state)

 #f (
 #none_set.intersection(instance_key[1])
 #nd not mapper.allow_partial_pks
 #r _none_set.issuperset(instance_key[1])
 #:
 #aise exc.FlushError(
 #Instance %s has a NULL identity key.  If this is an "
 #auto-generated value, check that the database table "
 #allows generation of new primary key values, and "
 #that the mapped Column object is configured to "
 #expect these generated values.  Ensure also that "
 #this flush() is not occurring at an inappropriate "
 #time, such as within a load() event."
 # state_str(state)
 #

 #f state.key is None:
 #tate.key = instance_key
 #lif state.key != instance_key:
                    # primary key switch. use safe_discard() in case another
                    # state has already replaced this one in the identity
                    # map (see test/orm/test_naturalpks.py ReversePKsTest)
 #elf.identity_map.safe_discard(state)
 #f state in self._transaction._key_switches:
 #rig_key = self._transaction._key_switches[state][0]
 #lse:
 #rig_key = state.key
 #elf._transaction._key_switches[state] = (
 #rig_key,
 #nstance_key,
 #
 #tate.key = instance_key

                # there can be an existing state in the identity map
                # that is replaced when the primary keys of two instances
                # are swapped; see test/orm/test_naturalpks.py -> test_reverse
 #ld = self.identity_map.replace(state)
 #f (
 #ld is not None
 #nd mapper._identity_key_from_state(old) == instance_key
 #nd old.obj() is not None
 #:
 #til.warn(
 #Identity map already had an identity for %s, "
 #replacing it with newly flushed object.   Are there "
 #load operations occurring inside of an event handler "
 #within the flush?" % (instance_key,)
 #
 #tate._orphaned_outside_of_session = False

 #tatelib.InstanceState._commit_all_states(
 #(state, state.dict) for state in states), self.identity_map
 #

 #elf._register_altered(states)

 #f pending_to_persistent is not None:
 #or state in states.intersection(self._new):
 #ending_to_persistent(self, state)

        # remove from new last, might be the last strong ref
 #or state in set(states).intersection(self._new):
 #elf._new.pop(state)

 #ef _register_altered(self, states):
 #f self._transaction:
 #or state in states:
 #f state in self._new:
 #elf._transaction._new[state] = True
 #lse:
 #elf._transaction._dirty[state] = True

 #ef _remove_newly_deleted(self, states):
 #ersistent_to_deleted = self.dispatch.persistent_to_deleted or None
 #or state in states:
 #f self._transaction:
 #elf._transaction._deleted[state] = True

 #f persistent_to_deleted is not None:
                # get a strong reference before we pop out of
                # self._deleted
 #bj = state.obj()  # noqa

 #elf.identity_map.safe_discard(state)
 #elf._deleted.pop(state, None)
 #tate._deleted = True
            # can't call state._detach() here, because this state
            # is still in the transaction snapshot and needs to be
            # tracked as part of that
 #f persistent_to_deleted is not None:
 #ersistent_to_deleted(self, state)

 #ef add(self, instance, _warn=True):
 #""Place an object in the ``Session``.

 #ts state will be persisted to the database on the next flush
 #peration.

 #epeated calls to ``add()`` will be ignored. The opposite of ``add()``
 #s ``expunge()``.

 #""
 #f _warn and self._warn_on_events:
 #elf._flush_warning("Session.add()")

 #ry:
 #tate = attributes.instance_state(instance)
 #xcept exc.NO_STATE as err:
 #til.raise_(
 #xc.UnmappedInstanceError(instance),
 #eplace_context=err,
 #

 #elf._save_or_update_state(state)

 #ef add_all(self, instances):
 #""Add the given collection of instances to this ``Session``."""

 #f self._warn_on_events:
 #elf._flush_warning("Session.add_all()")

 #or instance in instances:
 #elf.add(instance, _warn=False)

 #ef _save_or_update_state(self, state):
 #tate._orphaned_outside_of_session = False
 #elf._save_or_update_impl(state)

 #apper = _state_mapper(state)
 #or o, m, st_, dct_ in mapper.cascade_iterator(
 #save-update", state, halt_on=self._contains_state
 #:
 #elf._save_or_update_impl(st_)

 #ef delete(self, instance):
 #""Mark an instance as deleted.

 #he database delete operation occurs upon ``flush()``.

 #""
 #f self._warn_on_events:
 #elf._flush_warning("Session.delete()")

 #ry:
 #tate = attributes.instance_state(instance)
 #xcept exc.NO_STATE as err:
 #til.raise_(
 #xc.UnmappedInstanceError(instance),
 #eplace_context=err,
 #

 #elf._delete_impl(state, instance, head=True)

 #ef _delete_impl(self, state, obj, head):

 #f state.key is None:
 #f head:
 #aise sa_exc.InvalidRequestError(
 #Instance '%s' is not persisted" % state_str(state)
 #
 #lse:
 #eturn

 #o_attach = self._before_attach(state, obj)

 #f state in self._deleted:
 #eturn

 #elf.identity_map.add(state)

 #f to_attach:
 #elf._after_attach(state, obj)

 #f head:
            # grab the cascades before adding the item to the deleted list
            # so that autoflush does not delete the item
            # the strong reference to the instance itself is significant here
 #ascade_states = list(
 #tate.manager.mapper.cascade_iterator("delete", state)
 #

 #elf._deleted[state] = obj

 #f head:
 #or o, m, st_, dct_ in cascade_states:
 #elf._delete_impl(st_, o, False)

 #ef get(
 #elf,
 #ntity,
 #dent,
 #ptions=None,
 #opulate_existing=False,
 #ith_for_update=None,
 #dentity_token=None,
 #:
 #""Return an instance based on the given primary key identifier,
 #r ``None`` if not found.

 #.g.::

 #y_user = session.get(User, 5)

 #ome_object = session.get(VersionedFoo, (5, 10))

 #ome_object = session.get(
 #ersionedFoo,
 #"id": 5, "version_id": 10}
 #

 #. versionadded:: 1.4 Added :meth:`_orm.Session.get`, which is moved
 #rom the now deprecated :meth:`_orm.Query.get` method.

 #meth:`_orm.Session.get` is special in that it provides direct
 #ccess to the identity map of the :class:`.Session`.
 #f the given primary key identifier is present
 #n the local identity map, the object is returned
 #irectly from this collection and no SQL is emitted,
 #nless the object has been marked fully expired.
 #f not present,
 # SELECT is performed in order to locate the object.

 #meth:`_orm.Session.get` also will perform a check if
 #he object is present in the identity map and
 #arked as expired - a SELECT
 #s emitted to refresh the object as well as to
 #nsure that the row is still present.
 #f not, :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised.

 #param entity: a mapped class or :class:`.Mapper` indicating the
 #ype of entity to be loaded.

 #param ident: A scalar, tuple, or dictionary representing the
 #rimary key.  For a composite (e.g. multiple column) primary key,
 # tuple or dictionary should be passed.

 #or a single-column primary key, the scalar calling form is typically
 #he most expedient.  If the primary key of a row is the value "5",
 #he call looks like::

 #y_object = session.get(SomeClass, 5)

 #he tuple form contains primary key values typically in
 #he order in which they correspond to the mapped
 #class:`_schema.Table`
 #bject's primary key columns, or if the
 #paramref:`_orm.Mapper.primary_key` configuration parameter were
 #sed, in
 #he order used for that parameter. For example, if the primary key
 #f a row is represented by the integer
 #igits "5, 10" the call would look like::

 #y_object = session.get(SomeClass, (5, 10))

 #he dictionary form should include as keys the mapped attribute names
 #orresponding to each element of the primary key.  If the mapped class
 #as the attributes ``id``, ``version_id`` as the attributes which
 #tore the object's primary key value, the call would look like::

 #y_object = session.get(SomeClass, {"id": 5, "version_id": 10})

 #param options: optional sequence of loader options which will be
 #pplied to the query, if one is emitted.

 #param populate_existing: causes the method to unconditionally emit
 # SQL query and refresh the object with the newly loaded data,
 #egardless of whether or not the object is already present.

 #param with_for_update: optional boolean ``True`` indicating FOR UPDATE
 #hould be used, or may be a dictionary containing flags to
 #ndicate a more specific set of FOR UPDATE flags for the SELECT;
 #lags should match the parameters of
 #meth:`_query.Query.with_for_update`.
 #upersedes the :paramref:`.Session.refresh.lockmode` parameter.

 #return: The object instance, or ``None``.

 #""
 #eturn self._get_impl(
 #ntity,
 #dent,
 #oading.load_on_pk_identity,
 #ptions,
 #opulate_existing=populate_existing,
 #ith_for_update=with_for_update,
 #dentity_token=identity_token,
 #

 #ef _get_impl(
 #elf,
 #ntity,
 #rimary_key_identity,
 #b_load_fn,
 #ptions=None,
 #opulate_existing=False,
 #ith_for_update=None,
 #dentity_token=None,
 #xecution_options=None,
 #:

        # convert composite types to individual args
 #f hasattr(primary_key_identity, "__composite_values__"):
 #rimary_key_identity = primary_key_identity.__composite_values__()

 #apper = inspect(entity)

 #s_dict = isinstance(primary_key_identity, dict)
 #f not is_dict:
 #rimary_key_identity = util.to_list(
 #rimary_key_identity, default=(None,)
 #

 #f len(primary_key_identity) != len(mapper.primary_key):
 #aise sa_exc.InvalidRequestError(
 #Incorrect number of values in identifier to formulate "
 #primary key for query.get(); primary key columns are %s"
 # ",".join("'%s'" % c for c in mapper.primary_key)
 #

 #f is_dict:
 #ry:
 #rimary_key_identity = list(
 #rimary_key_identity[prop.key]
 #or prop in mapper._identity_key_props
 #

 #xcept KeyError as err:
 #til.raise_(
 #a_exc.InvalidRequestError(
 #Incorrect names of values in identifier to formulate "
 #primary key for query.get(); primary key attribute "
 #names are %s"
 # ",".join(
 #'%s'" % prop.key
 #or prop in mapper._identity_key_props
 #
 #,
 #eplace_context=err,
 #

 #f (
 #ot populate_existing
 #nd not mapper.always_refresh
 #nd with_for_update is None
 #:

 #nstance = self._identity_lookup(
 #apper, primary_key_identity, identity_token=identity_token
 #

 #f instance is not None:
                # reject calls for id in identity map but class
                # mismatch.
 #f not issubclass(instance.__class__, mapper.class_):
 #eturn None
 #eturn instance
 #lif instance is attributes.PASSIVE_CLASS_MISMATCH:
 #eturn None

        # set_label_style() not strictly necessary, however this will ensure
        # that tablename_colname style is used which at the moment is
        # asserted in a lot of unit tests :)

 #oad_options = context.QueryContext.default_load_options

 #f populate_existing:
 #oad_options += {"_populate_existing": populate_existing}
 #tatement = sql.select(mapper).set_label_style(
 #ABEL_STYLE_TABLENAME_PLUS_COL
 #
 #f with_for_update is not None:
 #tatement._for_update_arg = query.ForUpdateArg._from_argument(
 #ith_for_update
 #

 #f options:
 #tatement = statement.options(*options)
 #f execution_options:
 #tatement = statement.execution_options(**execution_options)
 #eturn db_load_fn(
 #elf,
 #tatement,
 #rimary_key_identity,
 #oad_options=load_options,
 #

 #ef merge(self, instance, load=True):
 #""Copy the state of a given instance into a corresponding instance
 #ithin this :class:`.Session`.

 #meth:`.Session.merge` examines the primary key attributes of the
 #ource instance, and attempts to reconcile it with an instance of the
 #ame primary key in the session.   If not found locally, it attempts
 #o load the object from the database based on primary key, and if
 #one can be located, creates a new instance.  The state of each
 #ttribute on the source instance is then copied to the target
 #nstance.  The resulting target instance is then returned by the
 #ethod; the original source instance is left unmodified, and
 #n-associated with the :class:`.Session` if not already.

 #his operation cascades to associated instances if the association is
 #apped with ``cascade="merge"``.

 #ee :ref:`unitofwork_merging` for a detailed discussion of merging.

 #. versionchanged:: 1.1 - :meth:`.Session.merge` will now reconcile
 #ending objects with overlapping primary keys in the same way
 #s persistent.  See :ref:`change_3601` for discussion.

 #param instance: Instance to be merged.
 #param load: Boolean, when False, :meth:`.merge` switches into
 # "high performance" mode which causes it to forego emitting history
 #vents as well as all database access.  This flag is used for
 #ases such as transferring graphs of objects into a :class:`.Session`
 #rom a second level cache, or to transfer just-loaded objects
 #nto the :class:`.Session` owned by a worker thread or process
 #ithout re-querying the database.

 #he ``load=False`` use case adds the caveat that the given
 #bject has to be in a "clean" state, that is, has no pending changes
 #o be flushed - even if the incoming object is detached from any
 #class:`.Session`.   This is so that when
 #he merge operation populates local attributes and
 #ascades to related objects and
 #ollections, the values can be "stamped" onto the
 #arget object as is, without generating any history or attribute
 #vents, and without the need to reconcile the incoming data with
 #ny existing related objects or collections that might not
 #e loaded.  The resulting objects from ``load=False`` are always
 #roduced as "clean", so it is only appropriate that the given objects
 #hould be "clean" as well, else this suggests a mis-use of the
 #ethod.


 #. seealso::

 #func:`.make_transient_to_detached` - provides for an alternative
 #eans of "merging" a single object into the :class:`.Session`

 #""

 #f self._warn_on_events:
 #elf._flush_warning("Session.merge()")

 #recursive = {}
 #resolve_conflict_map = {}

 #f load:
            # flush current contents if we expect to load data
 #elf._autoflush()

 #bject_mapper(instance)  # verify mapped
 #utoflush = self.autoflush
 #ry:
 #elf.autoflush = False
 #eturn self._merge(
 #ttributes.instance_state(instance),
 #ttributes.instance_dict(instance),
 #oad=load,
 #recursive=_recursive,
 #resolve_conflict_map=_resolve_conflict_map,
 #
 #inally:
 #elf.autoflush = autoflush

 #ef _merge(
 #elf,
 #tate,
 #tate_dict,
 #oad=True,
 #recursive=None,
 #resolve_conflict_map=None,
 #:
 #apper = _state_mapper(state)
 #f state in _recursive:
 #eturn _recursive[state]

 #ew_instance = False
 #ey = state.key

 #f key is None:
 #f state in self._new:
 #til.warn(
 #Instance %s is already pending in this Session yet is "
 #being merged again; this is probably not what you want "
 #to do" % state_str(state)
 #

 #f not load:
 #aise sa_exc.InvalidRequestError(
 #merge() with load=False option does not support "
 #objects transient (i.e. unpersisted) objects.  flush() "
 #all changes on mapped instances before merging with "
 #load=False."
 #
 #ey = mapper._identity_key_from_state(state)
 #ey_is_persistent = attributes.NEVER_SET not in key[1] and (
 #ot _none_set.intersection(key[1])
 #r (
 #apper.allow_partial_pks
 #nd not _none_set.issuperset(key[1])
 #
 #
 #lse:
 #ey_is_persistent = True

 #f key in self.identity_map:
 #ry:
 #erged = self.identity_map[key]
 #xcept KeyError:
                # object was GC'ed right as we checked for it
 #erged = None
 #lse:
 #erged = None

 #f merged is None:
 #f key_is_persistent and key in _resolve_conflict_map:
 #erged = _resolve_conflict_map[key]

 #lif not load:
 #f state.modified:
 #aise sa_exc.InvalidRequestError(
 #merge() with load=False option does not support "
 #objects marked as 'dirty'.  flush() all changes on "
 #mapped instances before merging with load=False."
 #
 #erged = mapper.class_manager.new_instance()
 #erged_state = attributes.instance_state(merged)
 #erged_state.key = key
 #elf._update_impl(merged_state)
 #ew_instance = True

 #lif key_is_persistent:
 #erged = self.get(mapper.class_, key[1], identity_token=key[2])

 #f merged is None:
 #erged = mapper.class_manager.new_instance()
 #erged_state = attributes.instance_state(merged)
 #erged_dict = attributes.instance_dict(merged)
 #ew_instance = True
 #elf._save_or_update_state(merged_state)
 #lse:
 #erged_state = attributes.instance_state(merged)
 #erged_dict = attributes.instance_dict(merged)

 #recursive[state] = merged
 #resolve_conflict_map[key] = merged

        # check that we didn't just pull the exact same
        # state out.
 #f state is not merged_state:
            # version check if applicable
 #f mapper.version_id_col is not None:
 #xisting_version = mapper._get_state_attr_by_column(
 #tate,
 #tate_dict,
 #apper.version_id_col,
 #assive=attributes.PASSIVE_NO_INITIALIZE,
 #

 #erged_version = mapper._get_state_attr_by_column(
 #erged_state,
 #erged_dict,
 #apper.version_id_col,
 #assive=attributes.PASSIVE_NO_INITIALIZE,
 #

 #f (
 #xisting_version is not attributes.PASSIVE_NO_RESULT
 #nd merged_version is not attributes.PASSIVE_NO_RESULT
 #nd existing_version != merged_version
 #:
 #aise exc.StaleDataError(
 #Version id '%s' on merged state %s "
 #does not match existing version '%s'. "
 #Leave the version attribute unset when "
 #merging to update the most recent version."
 # (
 #xisting_version,
 #tate_str(merged_state),
 #erged_version,
 #
 #

 #erged_state.load_path = state.load_path
 #erged_state.load_options = state.load_options

            # since we are copying load_options, we need to copy
            # the callables_ that would have been generated by those
            # load_options.
            # assumes that the callables we put in state.callables_
            # are not instance-specific (which they should not be)
 #erged_state._copy_callables(state)

 #or prop in mapper.iterate_properties:
 #rop.merge(
 #elf,
 #tate,
 #tate_dict,
 #erged_state,
 #erged_dict,
 #oad,
 #recursive,
 #resolve_conflict_map,
 #

 #f not load:
            # remove any history
 #erged_state._commit_all(merged_dict, self.identity_map)

 #f new_instance:
 #erged_state.manager.dispatch.load(merged_state, None)
 #eturn merged

 #ef _validate_persistent(self, state):
 #f not self.identity_map.contains_state(state):
 #aise sa_exc.InvalidRequestError(
 #Instance '%s' is not persistent within this Session"
 # state_str(state)
 #

 #ef _save_impl(self, state):
 #f state.key is not None:
 #aise sa_exc.InvalidRequestError(
 #Object '%s' already has an identity - "
 #it can't be registered as pending" % state_str(state)
 #

 #bj = state.obj()
 #o_attach = self._before_attach(state, obj)
 #f state not in self._new:
 #elf._new[state] = obj
 #tate.insert_order = len(self._new)
 #f to_attach:
 #elf._after_attach(state, obj)

 #ef _update_impl(self, state, revert_deletion=False):
 #f state.key is None:
 #aise sa_exc.InvalidRequestError(
 #Instance '%s' is not persisted" % state_str(state)
 #

 #f state._deleted:
 #f revert_deletion:
 #f not state._attached:
 #eturn
 #el state._deleted
 #lse:
 #aise sa_exc.InvalidRequestError(
 #Instance '%s' has been deleted.  "
 #Use the make_transient() "
 #function to send this object back "
 #to the transient state." % state_str(state)
 #

 #bj = state.obj()

        # check for late gc
 #f obj is None:
 #eturn

 #o_attach = self._before_attach(state, obj)

 #elf._deleted.pop(state, None)
 #f revert_deletion:
 #elf.identity_map.replace(state)
 #lse:
 #elf.identity_map.add(state)

 #f to_attach:
 #elf._after_attach(state, obj)
 #lif revert_deletion:
 #elf.dispatch.deleted_to_persistent(self, state)

 #ef _save_or_update_impl(self, state):
 #f state.key is None:
 #elf._save_impl(state)
 #lse:
 #elf._update_impl(state)

 #ef enable_relationship_loading(self, obj):
 #""Associate an object with this :class:`.Session` for related
 #bject loading.

 #. warning::

 #meth:`.enable_relationship_loading` exists to serve special
 #se cases and is not recommended for general use.

 #ccesses of attributes mapped with :func:`_orm.relationship`
 #ill attempt to load a value from the database using this
 #class:`.Session` as the source of connectivity.  The values
 #ill be loaded based on foreign key and primary key values
 #resent on this object - if not present, then those relationships
 #ill be unavailable.

 #he object will be attached to this session, but will
 #*not** participate in any persistence operations; its state
 #or almost all purposes will remain either "transient" or
 #detached", except for the case of relationship loading.

 #lso note that backrefs will often not work as expected.
 #ltering a relationship-bound attribute on the target object
 #ay not fire off a backref event, if the effective value
 #s what was already loaded from a foreign-key-holding value.

 #he :meth:`.Session.enable_relationship_loading` method is
 #imilar to the ``load_on_pending`` flag on :func:`_orm.relationship`.
 #nlike that flag, :meth:`.Session.enable_relationship_loading` allows
 #n object to remain transient while still being able to load
 #elated items.

 #o make a transient object associated with a :class:`.Session`
 #ia :meth:`.Session.enable_relationship_loading` pending, add
 #t to the :class:`.Session` using :meth:`.Session.add` normally.
 #f the object instead represents an existing identity in the database,
 #t should be merged using :meth:`.Session.merge`.

 #meth:`.Session.enable_relationship_loading` does not improve
 #ehavior when the ORM is used normally - object references should be
 #onstructed at the object level, not at the foreign key level, so
 #hat they are present in an ordinary way before flush()
 #roceeds.  This method is not intended for general use.

 #. seealso::

 #paramref:`_orm.relationship.load_on_pending` - this flag
 #llows per-relationship loading of many-to-ones on items that
 #re pending.

 #func:`.make_transient_to_detached` - allows for an object to
 #e added to a :class:`.Session` without SQL emitted, which then
 #ill unexpire attributes on access.

 #""
 #ry:
 #tate = attributes.instance_state(obj)
 #xcept exc.NO_STATE as err:
 #til.raise_(
 #xc.UnmappedInstanceError(obj),
 #eplace_context=err,
 #

 #o_attach = self._before_attach(state, obj)
 #tate._load_pending = True
 #f to_attach:
 #elf._after_attach(state, obj)

 #ef _before_attach(self, state, obj):
 #elf._autobegin()

 #f state.session_id == self.hash_key:
 #eturn False

 #f state.session_id and state.session_id in _sessions:
 #aise sa_exc.InvalidRequestError(
 #Object '%s' is already attached to session '%s' "
 #(this is '%s')"
 # (state_str(state), state.session_id, self.hash_key)
 #

 #elf.dispatch.before_attach(self, state)

 #eturn True

 #ef _after_attach(self, state, obj):
 #tate.session_id = self.hash_key
 #f state.modified and state._strong_obj is None:
 #tate._strong_obj = obj
 #elf.dispatch.after_attach(self, state)

 #f state.key:
 #elf.dispatch.detached_to_persistent(self, state)
 #lse:
 #elf.dispatch.transient_to_pending(self, state)

 #ef __contains__(self, instance):
 #""Return True if the instance is associated with this session.

 #he instance may be pending or persistent within the Session for a
 #esult of True.

 #""
 #ry:
 #tate = attributes.instance_state(instance)
 #xcept exc.NO_STATE as err:
 #til.raise_(
 #xc.UnmappedInstanceError(instance),
 #eplace_context=err,
 #
 #eturn self._contains_state(state)

 #ef __iter__(self):
 #""Iterate over all pending or persistent instances within this
 #ession.

 #""
 #eturn iter(
 #ist(self._new.values()) + list(self.identity_map.values())
 #

 #ef _contains_state(self, state):
 #eturn state in self._new or self.identity_map.contains_state(state)

 #ef flush(self, objects=None):
 #""Flush all the object changes to the database.

 #rites out all pending object creations, deletions and modifications
 #o the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
 #utomatically ordered by the Session's unit of work dependency
 #olver.

 #atabase operations will be issued in the current transactional
 #ontext and do not affect the state of the transaction, unless an
 #rror occurs, in which case the entire transaction is rolled back.
 #ou may flush() as often as you like within a transaction to move
 #hanges from Python to the database's transaction buffer.

 #or ``autocommit`` Sessions with no active manual transaction, flush()
 #ill create a transaction on the fly that surrounds the entire set of
 #perations into the flush.

 #param objects: Optional; restricts the flush operation to operate
 #nly on elements that are in the given collection.

 #his feature is for an extremely narrow set of use cases where
 #articular objects may need to be operated upon before the
 #ull flush() occurs.  It is not intended for general use.

 #""

 #f self._flushing:
 #aise sa_exc.InvalidRequestError("Session is already flushing")

 #f self._is_clean():
 #eturn
 #ry:
 #elf._flushing = True
 #elf._flush(objects)
 #inally:
 #elf._flushing = False

 #ef _flush_warning(self, method):
 #til.warn(
 #Usage of the '%s' operation is not currently supported "
 #within the execution stage of the flush process. "
 #Results may not be consistent.  Consider using alternative "
 #event listeners or connection-level operations instead." % method
 #

 #ef _is_clean(self):
 #eturn (
 #ot self.identity_map.check_modified()
 #nd not self._deleted
 #nd not self._new
 #

 #ef _flush(self, objects=None):

 #irty = self._dirty_states
 #f not dirty and not self._deleted and not self._new:
 #elf.identity_map._modified.clear()
 #eturn

 #lush_context = UOWTransaction(self)

 #f self.dispatch.before_flush:
 #elf.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
 #irty = self._dirty_states

 #eleted = set(self._deleted)
 #ew = set(self._new)

 #irty = set(dirty).difference(deleted)

        # create the set of all objects we want to operate upon
 #f objects:
            # specific list passed in
 #bjset = set()
 #or o in objects:
 #ry:
 #tate = attributes.instance_state(o)

 #xcept exc.NO_STATE as err:
 #til.raise_(
 #xc.UnmappedInstanceError(o),
 #eplace_context=err,
 #
 #bjset.add(state)
 #lse:
 #bjset = None

        # store objects whose fate has been decided
 #rocessed = set()

        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
 #f objset:
 #roc = new.union(dirty).intersection(objset).difference(deleted)
 #lse:
 #roc = new.union(dirty).difference(deleted)

 #or state in proc:
 #s_orphan = _state_mapper(state)._is_orphan(state)

 #s_persistent_orphan = is_orphan and state.has_identity

 #f (
 #s_orphan
 #nd not is_persistent_orphan
 #nd state._orphaned_outside_of_session
 #:
 #elf._expunge_states([state])
 #lse:
 #reg = flush_context.register_object(
 #tate, isdelete=is_persistent_orphan
 #
 #ssert _reg, "Failed to add object to the flush context!"
 #rocessed.add(state)

        # put all remaining deletes into the flush context.
 #f objset:
 #roc = deleted.intersection(objset).difference(processed)
 #lse:
 #roc = deleted.difference(processed)
 #or state in proc:
 #reg = flush_context.register_object(state, isdelete=True)
 #ssert _reg, "Failed to add object to the flush context!"

 #f not flush_context.has_work:
 #eturn

 #lush_context.transaction = transaction = self.begin(_subtrans=True)
 #ry:
 #elf._warn_on_events = True
 #ry:
 #lush_context.execute()
 #inally:
 #elf._warn_on_events = False

 #elf.dispatch.after_flush(self, flush_context)

 #lush_context.finalize_flush_changes()

 #f not objects and self.identity_map._modified:
 #en_ = len(self.identity_map._modified)

 #tatelib.InstanceState._commit_all_states(
 #
 #state, state.dict)
 #or state in self.identity_map._modified
 #,
 #nstance_dict=self.identity_map,
 #
 #til.warn(
 #Attribute history events accumulated on %d "
 #previously clean instances "
 #within inner-flush event handlers have been "
 #reset, and will not result in database updates. "
 #Consider using set_committed_value() within "
 #inner-flush event handlers to avoid this warning." % len_
 #

            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)

 #elf.dispatch.after_flush_postexec(self, flush_context)

 #ransaction.commit()

 #xcept:
 #ith util.safe_reraise():
 #ransaction.rollback(_capture_exception=True)

 #ef bulk_save_objects(
 #elf,
 #bjects,
 #eturn_defaults=False,
 #pdate_changed_only=True,
 #reserve_order=True,
 #:
 #""Perform a bulk save of the given list of objects.

 #he bulk save feature allows mapped objects to be used as the
 #ource of simple INSERT and UPDATE operations which can be more easily
 #rouped together into higher performing "executemany"
 #perations; the extraction of data from the objects is also performed
 #sing a lower-latency process that ignores whether or not attributes
 #ave actually been modified in the case of UPDATEs, and also ignores
 #QL expressions.

 #he objects as given are not added to the session and no additional
 #tate is established on them, unless the ``return_defaults`` flag
 #s also set, in which case primary key attributes and server-side
 #efault values will be populated.

 #. versionadded:: 1.0.0

 #. warning::

 #he bulk save feature allows for a lower-latency INSERT/UPDATE
 #f rows at the expense of most other unit-of-work features.
 #eatures such as object management, relationship handling,
 #nd SQL clause support are **silently omitted** in favor of raw
 #NSERT/UPDATES of records.

 #*Please read the list of caveats at**
 #ref:`bulk_operations_caveats` **before using this method, and
 #ully test and confirm the functionality of all code developed
 #sing these systems.**

 #param objects: a sequence of mapped object instances.  The mapped
 #bjects are persisted as is, and are **not** associated with the
 #class:`.Session` afterwards.

 #or each object, whether the object is sent as an INSERT or an
 #PDATE is dependent on the same rules used by the :class:`.Session`
 #n traditional operation; if the object has the
 #attr:`.InstanceState.key`
 #ttribute set, then the object is assumed to be "detached" and
 #ill result in an UPDATE.  Otherwise, an INSERT is used.

 #n the case of an UPDATE, statements are grouped based on which
 #ttributes have changed, and are thus to be the subject of each
 #ET clause.  If ``update_changed_only`` is False, then all
 #ttributes present within each object are applied to the UPDATE
 #tatement, which may help in allowing the statements to be grouped
 #ogether into a larger executemany(), and will also reduce the
 #verhead of checking history on attributes.

 #param return_defaults: when True, rows that are missing values which
 #enerate defaults, namely integer primary key defaults and sequences,
 #ill be inserted **one at a time**, so that the primary key value
 #s available.  In particular this will allow joined-inheritance
 #nd other multi-table mappings to insert correctly without the need
 #o provide primary key values ahead of time; however,
 #paramref:`.Session.bulk_save_objects.return_defaults` **greatly
 #educes the performance gains** of the method overall.

 #param update_changed_only: when True, UPDATE statements are rendered
 #ased on those attributes in each state that have logged changes.
 #hen False, all attributes present are rendered into the SET clause
 #ith the exception of primary key attributes.

 #param preserve_order: when True, the order of inserts and updates
 #atches exactly the order in which the objects are given.   When
 #alse, common types of objects are grouped into inserts
 #nd updates, to allow for more batching opportunities.

 #. versionadded:: 1.3

 #. seealso::

 #ref:`bulk_operations`

 #meth:`.Session.bulk_insert_mappings`

 #meth:`.Session.bulk_update_mappings`

 #""

 #ef key(state):
 #eturn (state.mapper, state.key is not None)

 #bj_states = (attributes.instance_state(obj) for obj in objects)
 #f not preserve_order:
 #bj_states = sorted(obj_states, key=key)

 #or (mapper, isupdate), states in itertools.groupby(obj_states, key):
 #elf._bulk_save_mappings(
 #apper,
 #tates,
 #supdate,
 #rue,
 #eturn_defaults,
 #pdate_changed_only,
 #alse,
 #

 #ef bulk_insert_mappings(
 #elf, mapper, mappings, return_defaults=False, render_nulls=False
 #:
 #""Perform a bulk insert of the given list of mapping dictionaries.

 #he bulk insert feature allows plain Python dictionaries to be used as
 #he source of simple INSERT operations which can be more easily
 #rouped together into higher performing "executemany"
 #perations.  Using dictionaries, there is no "history" or session
 #tate management features in use, reducing latency when inserting
 #arge numbers of simple rows.

 #he values within the dictionaries as given are typically passed
 #ithout modification into Core :meth:`_expression.Insert` constructs,
 #fter
 #rganizing the values within them across the tables to which
 #he given mapper is mapped.

 #. versionadded:: 1.0.0

 #. warning::

 #he bulk insert feature allows for a lower-latency INSERT
 #f rows at the expense of most other unit-of-work features.
 #eatures such as object management, relationship handling,
 #nd SQL clause support are **silently omitted** in favor of raw
 #NSERT of records.

 #*Please read the list of caveats at**
 #ref:`bulk_operations_caveats` **before using this method, and
 #ully test and confirm the functionality of all code developed
 #sing these systems.**

 #param mapper: a mapped class, or the actual :class:`_orm.Mapper`
 #bject,
 #epresenting the single kind of object represented within the mapping
 #ist.

 #param mappings: a sequence of dictionaries, each one containing the
 #tate of the mapped row to be inserted, in terms of the attribute
 #ames on the mapped class.   If the mapping refers to multiple tables,
 #uch as a joined-inheritance mapping, each dictionary must contain all
 #eys to be populated into all tables.

 #param return_defaults: when True, rows that are missing values which
 #enerate defaults, namely integer primary key defaults and sequences,
 #ill be inserted **one at a time**, so that the primary key value
 #s available.  In particular this will allow joined-inheritance
 #nd other multi-table mappings to insert correctly without the need
 #o provide primary
 #ey values ahead of time; however,
 #paramref:`.Session.bulk_insert_mappings.return_defaults`
 #*greatly reduces the performance gains** of the method overall.
 #f the rows
 #o be inserted only refer to a single table, then there is no
 #eason this flag should be set as the returned default information
 #s not used.

 #param render_nulls: When True, a value of ``None`` will result
 #n a NULL value being included in the INSERT statement, rather
 #han the column being omitted from the INSERT.   This allows all
 #he rows being INSERTed to have the identical set of columns which
 #llows the full set of rows to be batched to the DBAPI.  Normally,
 #ach column-set that contains a different combination of NULL values
 #han the previous row must omit a different series of columns from
 #he rendered INSERT statement, which means it must be emitted as a
 #eparate statement.   By passing this flag, the full set of rows
 #re guaranteed to be batchable into one batch; the cost however is
 #hat server-side defaults which are invoked by an omitted column will
 #e skipped, so care must be taken to ensure that these are not
 #ecessary.

 #. warning::

 #hen this flag is set, **server side default SQL values will
 #ot be invoked** for those columns that are inserted as NULL;
 #he NULL value will be sent explicitly.   Care must be taken
 #o ensure that no server-side default functions need to be
 #nvoked for the operation as a whole.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`bulk_operations`

 #meth:`.Session.bulk_save_objects`

 #meth:`.Session.bulk_update_mappings`

 #""
 #elf._bulk_save_mappings(
 #apper,
 #appings,
 #alse,
 #alse,
 #eturn_defaults,
 #alse,
 #ender_nulls,
 #

 #ef bulk_update_mappings(self, mapper, mappings):
 #""Perform a bulk update of the given list of mapping dictionaries.

 #he bulk update feature allows plain Python dictionaries to be used as
 #he source of simple UPDATE operations which can be more easily
 #rouped together into higher performing "executemany"
 #perations.  Using dictionaries, there is no "history" or session
 #tate management features in use, reducing latency when updating
 #arge numbers of simple rows.

 #. versionadded:: 1.0.0

 #. warning::

 #he bulk update feature allows for a lower-latency UPDATE
 #f rows at the expense of most other unit-of-work features.
 #eatures such as object management, relationship handling,
 #nd SQL clause support are **silently omitted** in favor of raw
 #PDATES of records.

 #*Please read the list of caveats at**
 #ref:`bulk_operations_caveats` **before using this method, and
 #ully test and confirm the functionality of all code developed
 #sing these systems.**

 #param mapper: a mapped class, or the actual :class:`_orm.Mapper`
 #bject,
 #epresenting the single kind of object represented within the mapping
 #ist.

 #param mappings: a sequence of dictionaries, each one containing the
 #tate of the mapped row to be updated, in terms of the attribute names
 #n the mapped class.   If the mapping refers to multiple tables, such
 #s a joined-inheritance mapping, each dictionary may contain keys
 #orresponding to all tables.   All those keys which are present and
 #re not part of the primary key are applied to the SET clause of the
 #PDATE statement; the primary key values, which are required, are
 #pplied to the WHERE clause.


 #. seealso::

 #ref:`bulk_operations`

 #meth:`.Session.bulk_insert_mappings`

 #meth:`.Session.bulk_save_objects`

 #""
 #elf._bulk_save_mappings(
 #apper, mappings, True, False, False, False, False
 #

 #ef _bulk_save_mappings(
 #elf,
 #apper,
 #appings,
 #supdate,
 #sstates,
 #eturn_defaults,
 #pdate_changed_only,
 #ender_nulls,
 #:
 #apper = _class_to_mapper(mapper)
 #elf._flushing = True

 #ransaction = self.begin(_subtrans=True)
 #ry:
 #f isupdate:
 #ersistence._bulk_update(
 #apper,
 #appings,
 #ransaction,
 #sstates,
 #pdate_changed_only,
 #
 #lse:
 #ersistence._bulk_insert(
 #apper,
 #appings,
 #ransaction,
 #sstates,
 #eturn_defaults,
 #ender_nulls,
 #
 #ransaction.commit()

 #xcept:
 #ith util.safe_reraise():
 #ransaction.rollback(_capture_exception=True)
 #inally:
 #elf._flushing = False

 #ef is_modified(self, instance, include_collections=True):
 #"""Return ``True`` if the given instance has locally
 #odified attributes.

 #his method retrieves the history for each instrumented
 #ttribute on the instance and performs a comparison of the current
 #alue to its previously committed value, if any.

 #t is in effect a more expensive and accurate
 #ersion of checking for the given instance in the
 #attr:`.Session.dirty` collection; a full test for
 #ach attribute's net "dirty" status is performed.

 #.g.::

 #eturn session.is_modified(someobject)

 # few caveats to this method apply:

 # Instances present in the :attr:`.Session.dirty` collection may
 #eport ``False`` when tested with this method.  This is because
 #he object may have received change events via attribute mutation,
 #hus placing it in :attr:`.Session.dirty`, but ultimately the state
 #s the same as that loaded from the database, resulting in no net
 #hange here.
 # Scalar attributes may not have recorded the previously set
 #alue when a new value was applied, if the attribute was not loaded,
 #r was expired, at the time the new value was received - in these
 #ases, the attribute is assumed to have a change, even if there is
 #ltimately no net change against its database value. SQLAlchemy in
 #ost cases does not need the "old" value when a set event occurs, so
 #t skips the expense of a SQL call if the old value isn't present,
 #ased on the assumption that an UPDATE of the scalar value is
 #sually needed, and in those few cases where it isn't, is less
 #xpensive on average than issuing a defensive SELECT.

 #he "old" value is fetched unconditionally upon set only if the
 #ttribute container has the ``active_history`` flag set to ``True``.
 #his flag is set typically for primary key attributes and scalar
 #bject references that are not a simple many-to-one.  To set this
 #lag for any arbitrary mapped column, use the ``active_history``
 #rgument with :func:`.column_property`.

 #param instance: mapped instance to be tested for pending changes.
 #param include_collections: Indicates if multivalued collections
 #hould be included in the operation.  Setting this to ``False`` is a
 #ay to detect only local-column based properties (i.e. scalar columns
 #r many-to-one foreign keys) that would result in an UPDATE for this
 #nstance upon flush.

 #""
 #tate = object_state(instance)

 #f not state.modified:
 #eturn False

 #ict_ = state.dict

 #or attr in state.manager.attributes:
 #f (
 #ot include_collections
 #nd hasattr(attr.impl, "get_collection")
 # or not hasattr(attr.impl, "get_history"):
 #ontinue

 #added, unchanged, deleted) = attr.impl.get_history(
 #tate, dict_, passive=attributes.NO_CHANGE
 #

 #f added or deleted:
 #eturn True
 #lse:
 #eturn False

 #property
 #ef is_active(self):
 #""True if this :class:`.Session` not in "partial rollback" state.

 #. versionchanged:: 1.4 The :class:`_orm.Session` no longer begins
 # new transaction immediately, so this attribute will be False
 #hen the :class:`_orm.Session` is first instantiated.

 #partial rollback" state typically indicates that the flush process
 #f the :class:`_orm.Session` has failed, and that the
 #meth:`_orm.Session.rollback` method must be emitted in order to
 #ully roll back the transaction.

 #f this :class:`_orm.Session` is not in a transaction at all, the
 #class:`_orm.Session` will autobegin when it is first used, so in this
 #ase :attr:`_orm.Session.is_active` will return True.

 #therwise, if this :class:`_orm.Session` is within a transaction,
 #nd that transaction has not been rolled back internally, the
 #attr:`_orm.Session.is_active` will also return True.

 #. seealso::

 #ref:`faq_session_rollback`

 #meth:`_orm.Session.in_transaction`

 #""
 #f self.autocommit:
 #eturn (
 #elf._transaction is not None and self._transaction.is_active
 #
 #lse:
 #eturn self._transaction is None or self._transaction.is_active

 #dentity_map = None
 #""A mapping of object identities to objects themselves.

 #terating through ``Session.identity_map.values()`` provides
 #ccess to the full set of persistent objects (i.e., those
 #hat have row identity) currently in the session.

 #. seealso::

 #func:`.identity_key` - helper function to produce the keys used
 #n this dictionary.

 #""

 #property
 #ef _dirty_states(self):
 #""The set of all persistent states considered dirty.

 #his method returns all states that were modified including
 #hose that were possibly deleted.

 #""
 #eturn self.identity_map._dirty_states()

 #property
 #ef dirty(self):
 #""The set of all persistent instances considered dirty.

 #.g.::

 #ome_mapped_object in session.dirty

 #nstances are considered dirty when they were modified but not
 #eleted.

 #ote that this 'dirty' calculation is 'optimistic'; most
 #ttribute-setting or collection modification operations will
 #ark an instance as 'dirty' and place it in this set, even if
 #here is no net change to the attribute's value.  At flush
 #ime, the value of each attribute is compared to its
 #reviously saved value, and if there's no net change, no SQL
 #peration will occur (this is a more expensive operation so
 #t's only done at flush time).

 #o check if an instance has actionable net changes to its
 #ttributes, use the :meth:`.Session.is_modified` method.

 #""
 #eturn util.IdentitySet(
 #
 #tate.obj()
 #or state in self._dirty_states
 #f state not in self._deleted
 #
 #

 #property
 #ef deleted(self):
 #The set of all instances marked as 'deleted' within this ``Session``"

 #eturn util.IdentitySet(list(self._deleted.values()))

 #property
 #ef new(self):
 #The set of all instances marked as 'new' within this ``Session``."

 #eturn util.IdentitySet(list(self._new.values()))


class sessionmaker(_SessionClassMethods):
 #""A configurable :class:`.Session` factory.

 #he :class:`.sessionmaker` factory generates new
 #class:`.Session` objects when called, creating them given
 #he configurational arguments established here.

 #.g.::

 #rom sqlalchemy import create_engine
 #rom sqlalchemy.orm import sessionmaker

        # an Engine, which the Session will use for connection
        # resources
 #ngine = create_engine('postgresql://scott:tiger@localhost/')

 #ession = sessionmaker(engine)

 #ith Session() as session:
 #ession.add(some_object)
 #ession.add(some_other_object)
 #ession.commit()

 #ontext manager use is optional; otherwise, the returned
 #class:`_orm.Session` object may be closed explicitly via the
 #meth:`_orm.Session.close` method.   Using a
 #`try:/finally:`` block is optional, however will ensure that the close
 #akes place even if there are database errors::

 #ession = Session()
 #ry:
 #ession.add(some_object)
 #ession.add(some_other_object)
 #ession.commit()
 #inally:
 #ession.close()

 #class:`.sessionmaker` acts as a factory for :class:`_orm.Session`
 #bjects in the same way as an :class:`_engine.Engine` acts as a factory
 #or :class:`_engine.Connection` objects.  In this way it also includes
 # :meth:`_orm.sessionmaker.begin` method, that provides a context
 #anager which both begins and commits a transaction, as well as closes
 #ut the :class:`_orm.Session` when complete, rolling back the transaction
 #f any errors occur::

 #ession = sessionmaker(engine)

 #ith Session.begin() as session:
 #ession.add(some_object)
 #ession.add(some_other_object)
        # commits transaction, closes session

 #. versionadded:: 1.4

 #hen calling upon :class:`_orm.sessionmaker` to construct a
 #class:`_orm.Session`, keyword arguments may also be passed to the
 #ethod; these arguments will override that of the globally configured
 #arameters.  Below we use a :class:`_orm.sessionmaker` bound to a certain
 #class:`_engine.Engine` to produce a :class:`_orm.Session` that is instead
 #ound to a specific :class:`_engine.Connection` procured from that engine::

 #ession = sessionmaker(engine)

        # bind an individual session to a connection

 #ith engine.connect() as connection:
 #ith Session(bind=connection) as session:
                # work with session

 #he class also includes a method :meth:`_orm.sessionmaker.configure`, which
 #an be used to specify additional keyword arguments to the factory, which
 #ill take effect for subsequent :class:`.Session` objects generated. This
 #s usually used to associate one or more :class:`_engine.Engine` objects
 #ith an existing
 #class:`.sessionmaker` factory before it is first used::

        # application starts, sessionmaker does not have
        # an engine bound yet
 #ession = sessionmaker()

        # ... later, when an engine URL is read from a configuration
        # file or other events allow the engine to be created
 #ngine = create_engine('sqlite:///foo.db')
 #ession.configure(bind=engine)

 #ess = Session()
        # work with session

 #. seealso::

 #ref:`session_getting` - introductory text on creating
 #essions using :class:`.sessionmaker`.

 #""

 #ef __init__(
 #elf,
 #ind=None,
 #lass_=Session,
 #utoflush=True,
 #utocommit=False,
 #xpire_on_commit=True,
 #nfo=None,
 #*kw
 #:
 #"""Construct a new :class:`.sessionmaker`.

 #ll arguments here except for ``class_`` correspond to arguments
 #ccepted by :class:`.Session` directly.  See the
 #meth:`.Session.__init__` docstring for more details on parameters.

 #param bind: a :class:`_engine.Engine` or other :class:`.Connectable`
 #ith
 #hich newly created :class:`.Session` objects will be associated.
 #param class\_: class to use in order to create new :class:`.Session`
 #bjects.  Defaults to :class:`.Session`.
 #param autoflush: The autoflush setting to use with newly created
 #class:`.Session` objects.
 #param autocommit: The autocommit setting to use with newly created
 #class:`.Session` objects.
 #param expire_on_commit=True: the
 #paramref:`_orm.Session.expire_on_commit` setting to use
 #ith newly created :class:`.Session` objects.

 #param info: optional dictionary of information that will be available
 #ia :attr:`.Session.info`.  Note this dictionary is *updated*, not
 #eplaced, when the ``info`` parameter is specified to the specific
 #class:`.Session` construction operation.

 #param \**kw: all other keyword arguments are passed to the
 #onstructor of newly created :class:`.Session` objects.

 #""
 #w["bind"] = bind
 #w["autoflush"] = autoflush
 #w["autocommit"] = autocommit
 #w["expire_on_commit"] = expire_on_commit
 #f info is not None:
 #w["info"] = info
 #elf.kw = kw
        # make our own subclass of the given class, so that
        # events can be associated with it specifically.
 #elf.class_ = type(class_.__name__, (class_,), {})

 #ef begin(self):
 #""Produce a context manager that both provides a new
 #class:`_orm.Session` as well as a transaction that commits.


 #.g.::

 #ession = sessionmaker(some_engine)

 #ith Session.begin() as session:
 #ession.add(some_object)

            # commits transaction, closes session

 #. versionadded:: 1.4


 #""

 #ession = self()
 #eturn session._maker_context_manager()

 #ef __call__(self, **local_kw):
 #""Produce a new :class:`.Session` object using the configuration
 #stablished in this :class:`.sessionmaker`.

 #n Python, the ``__call__`` method is invoked on an object when
 #t is "called" in the same way as a function::

 #ession = sessionmaker()
 #ession = Session()  # invokes sessionmaker.__call__()

 #""
 #or k, v in self.kw.items():
 #f k == "info" and "info" in local_kw:
 # = v.copy()
 #.update(local_kw["info"])
 #ocal_kw["info"] = d
 #lse:
 #ocal_kw.setdefault(k, v)
 #eturn self.class_(**local_kw)

 #ef configure(self, **new_kw):
 #""(Re)configure the arguments for this sessionmaker.

 #.g.::

 #ession = sessionmaker()

 #ession.configure(bind=create_engine('sqlite://'))
 #""
 #elf.kw.update(new_kw)

 #ef __repr__(self):
 #eturn "%s(class_=%r, %s)" % (
 #elf.__class__.__name__,
 #elf.class_.__name__,
 #, ".join("%s=%r" % (k, v) for k, v in self.kw.items()),
 #


def close_all_sessions():
 #""Close all sessions in memory.

 #his function consults a global registry of all :class:`.Session` objects
 #nd calls :meth:`.Session.close` on them, which resets them to a clean
 #tate.

 #his function is not for general use but may be useful for test suites
 #ithin the teardown scheme.

 #. versionadded:: 1.3

 #""

 #or sess in _sessions.values():
 #ess.close()


def make_transient(instance):
 #""Alter the state of the given instance so that it is :term:`transient`.

 #. note::

 #func:`.make_transient` is a special-case function for
 #dvanced use cases only.

 #he given mapped instance is assumed to be in the :term:`persistent` or
 #term:`detached` state.   The function will remove its association with any
 #class:`.Session` as well as its :attr:`.InstanceState.identity`. The
 #ffect is that the object will behave as though it were newly constructed,
 #xcept retaining any attribute / collection values that were loaded at the
 #ime of the call.   The :attr:`.InstanceState.deleted` flag is also reset
 #f this object had been deleted as a result of using
 #meth:`.Session.delete`.

 #. warning::

 #func:`.make_transient` does **not** "unexpire" or otherwise eagerly
 #oad ORM-mapped attributes that are not currently loaded at the time
 #he function is called.   This includes attributes which:

 # were expired via :meth:`.Session.expire`

 # were expired as the natural effect of committing a session
 #ransaction, e.g. :meth:`.Session.commit`

 # are normally :term:`lazy loaded` but are not currently loaded

 # are "deferred" via :ref:`deferred` and are not yet loaded

 # were not present in the query which loaded this object, such as that
 #hich is common in joined table inheritance and other scenarios.

 #fter :func:`.make_transient` is called, unloaded attributes such
 #s those above will normally resolve to the value ``None`` when
 #ccessed, or an empty collection for a collection-oriented attribute.
 #s the object is transient and un-associated with any database
 #dentity, it will no longer retrieve these values.

 #. seealso::

 #func:`.make_transient_to_detached`

 #""
 #tate = attributes.instance_state(instance)
 # = _state_session(state)
 #f s:
 #._expunge_states([state])

    # remove expired state
 #tate.expired_attributes.clear()

    # remove deferred callables
 #f state.callables:
 #el state.callables

 #f state.key:
 #el state.key
 #f state._deleted:
 #el state._deleted


def make_transient_to_detached(instance):
 #""Make the given transient instance :term:`detached`.

 #. note::

 #func:`.make_transient_to_detached` is a special-case function for
 #dvanced use cases only.

 #ll attribute history on the given instance
 #ill be reset as though the instance were freshly loaded
 #rom a query.  Missing attributes will be marked as expired.
 #he primary key attributes of the object, which are required, will be made
 #nto the "key" of the instance.

 #he object can then be added to a session, or merged
 #ossibly with the load=False flag, at which point it will look
 #s if it were loaded that way, without emitting SQL.

 #his is a special use case function that differs from a normal
 #all to :meth:`.Session.merge` in that a given persistent state
 #an be manufactured without any SQL calls.

 #. seealso::

 #func:`.make_transient`

 #meth:`.Session.enable_relationship_loading`

 #""
 #tate = attributes.instance_state(instance)
 #f state.session_id or state.key:
 #aise sa_exc.InvalidRequestError("Given object must be transient")
 #tate.key = state.mapper._identity_key_from_state(state)
 #f state._deleted:
 #el state._deleted
 #tate._commit_all(state.dict)
 #tate._expire_attributes(state.dict, state.unloaded_expirable)


def object_session(instance):
 #""Return the :class:`.Session` to which the given instance belongs.

 #his is essentially the same as the :attr:`.InstanceState.session`
 #ccessor.  See that attribute for details.

 #""

 #ry:
 #tate = attributes.instance_state(instance)
 #xcept exc.NO_STATE as err:
 #til.raise_(
 #xc.UnmappedInstanceError(instance),
 #eplace_context=err,
 #
 #lse:
 #eturn _state_session(state)


_new_sessionid = util.counter()
