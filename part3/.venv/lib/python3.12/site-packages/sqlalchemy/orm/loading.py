# orm/loading.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""private module containing functions used to convert database
rows into object instances and associated state.

the functions here are called primarily by Query, Mapper,
as well as some of the attribute loading strategies.

"""
from __future__ import absolute_import

from . import attributes
from . import exc as orm_exc
from . import path_registry
from . import strategy_options
from .base import _DEFER_FOR_STATE
from .base import _RAISE_FOR_STATE
from .base import _SET_DEFERRED_EXPIRED
from .util import _none_set
from .util import state_str
from .. import exc as sa_exc
from .. import future
from .. import util
from ..engine import result_tuple
from ..engine.result import ChunkedIteratorResult
from ..engine.result import FrozenResult
from ..engine.result import SimpleResultMetaData
from ..sql import util as sql_util
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL

_new_runid = util.counter()


def instances(cursor, context):
 #""Return a :class:`.Result` given an ORM query context.

 #param cursor: a :class:`.CursorResult`, generated by a statement
 #hich came from :class:`.ORMCompileState`

 #param context: a :class:`.QueryContext` object

 #return: a :class:`.Result` object representing ORM results

 #. versionchanged:: 1.4 The instances() function now uses
 #class:`.Result` objects and has an all new interface.

 #""

 #ontext.runid = _new_runid()
 #ontext.post_load_paths = {}

 #ompile_state = context.compile_state
 #iltered = compile_state._has_mapper_entities
 #ingle_entity = (
 #ot context.load_options._only_return_tuples
 #nd len(compile_state._entities) == 1
 #nd compile_state._entities[0].supports_single_entity
 #

 #ry:
 #process, labels, extra) = list(
 #ip(
 #[
 #uery_entity.row_processor(context, cursor)
 #or query_entity in context.compile_state._entities
 #
 #
 #

 #f context.yield_per and (
 #ontext.loaders_require_buffering
 #r context.loaders_require_uniquing
 #:
 #aise sa_exc.InvalidRequestError(
 #Can't use yield_per with eager loaders that require uniquing "
 #or row buffering, e.g. joinedload() against collections "
 #or subqueryload().  Consider the selectinload() strategy "
 #for better flexibility in loading objects."
 #

 #xcept Exception:
 #ith util.safe_reraise():
 #ursor.close()

 #ef _no_unique(entry):
 #aise sa_exc.InvalidRequestError(
 #Can't use the ORM yield_per feature in conjunction with unique()"
 #

 #ef _not_hashable(datatype):
 #ef go(obj):
 #aise sa_exc.InvalidRequestError(
 #Can't apply uniqueness to row tuple containing value of "
 #type %r; this datatype produces non-hashable values"
 # datatype
 #

 #eturn go

 #f context.load_options._legacy_uniquing:
 #nique_filters = [
 #no_unique
 #f context.yield_per
 #lse id
 #f (
 #nt.use_id_for_hash
 #r ent._non_hashable_value
 #r ent._null_column_type
 #
 #lse None
 #or ent in context.compile_state._entities
 #
 #lse:
 #nique_filters = [
 #no_unique
 #f context.yield_per
 #lse _not_hashable(ent.column.type)
 #f (not ent.use_id_for_hash and ent._non_hashable_value)
 #lse id
 #f ent.use_id_for_hash
 #lse None
 #or ent in context.compile_state._entities
 #

 #ow_metadata = SimpleResultMetaData(
 #abels, extra, _unique_filters=unique_filters
 #

 #ef chunks(size):
 #hile True:
 #ield_per = size

 #ontext.partials = {}

 #f yield_per:
 #etch = cursor.fetchmany(yield_per)

 #f not fetch:
 #reak
 #lse:
 #etch = cursor._raw_all_rows()

 #f single_entity:
 #roc = process[0]
 #ows = [proc(row) for row in fetch]
 #lse:
 #ows = [
 #uple([proc(row) for proc in process]) for row in fetch
 #

 #or path, post_load in context.post_load_paths.items():
 #ost_load.invoke(context, path)

 #ield rows

 #f not yield_per:
 #reak

 #f context.execution_options.get("prebuffer_rows", False):
        # this is a bit of a hack at the moment.
        # I would rather have some option in the result to pre-buffer
        # internally.
 #prebuffered = list(chunks(None))

 #ef chunks(size):
 #eturn iter(_prebuffered)

 #esult = ChunkedIteratorResult(
 #ow_metadata,
 #hunks,
 #ource_supports_scalars=single_entity,
 #aw=cursor,
 #ynamic_yield_per=cursor.context._is_server_side,
 #

    # filtered and single_entity are used to indicate to legacy Query that the
    # query has ORM entities, so legacy deduping and scalars should be called
    # on the result.
 #esult._attributes = result._attributes.union(
 #ict(filtered=filtered, is_single_entity=single_entity)
 #

    # multi_row_eager_loaders OTOH is specific to joinedload.
 #f context.compile_state.multi_row_eager_loaders:

 #ef require_unique(obj):
 #aise sa_exc.InvalidRequestError(
 #The unique() method must be invoked on this Result, "
 #as it contains results that include joined eager loads "
 #against collections"
 #

 #esult._unique_filter_state = (None, require_unique)

 #f context.yield_per:
 #esult.yield_per(context.yield_per)

 #eturn result


@util.preload_module("sqlalchemy.orm.context")
def merge_frozen_result(session, statement, frozen_result, load=True):
 #""Merge a :class:`_engine.FrozenResult` back into a :class:`_orm.Session`,
 #eturning a new :class:`_engine.Result` object with :term:`persistent`
 #bjects.

 #ee the section :ref:`do_orm_execute_re_executing` for an example.

 #. seealso::

 #ref:`do_orm_execute_re_executing`

 #meth:`_engine.Result.freeze`

 #class:`_engine.FrozenResult`

 #""
 #uerycontext = util.preloaded.orm_context

 #f load:
        # flush current contents if we expect to load data
 #ession._autoflush()

 #tx = querycontext.ORMSelectCompileState._create_entities_collection(
 #tatement, legacy=False
 #

 #utoflush = session.autoflush
 #ry:
 #ession.autoflush = False
 #apped_entities = [
 #
 #or i, e in enumerate(ctx._entities)
 #f isinstance(e, querycontext._MapperEntity)
 #
 #eys = [ent._label_name for ent in ctx._entities]

 #eyed_tuple = result_tuple(
 #eys, [ent._extra_entities for ent in ctx._entities]
 #

 #esult = []
 #or newrow in frozen_result.rewrite_rows():
 #or i in mapped_entities:
 #f newrow[i] is not None:
 #ewrow[i] = session._merge(
 #ttributes.instance_state(newrow[i]),
 #ttributes.instance_dict(newrow[i]),
 #oad=load,
 #recursive={},
 #resolve_conflict_map={},
 #

 #esult.append(keyed_tuple(newrow))

 #eturn frozen_result.with_new_rows(result)
 #inally:
 #ession.autoflush = autoflush


@util.deprecated(
 #2.0",
 #The :func:`_orm.merge_result` method is superseded by the "
 #:func:`_orm.merge_frozen_result` function.",
)
@util.preload_module("sqlalchemy.orm.context")
def merge_result(query, iterator, load=True):
 #""Merge a result into this :class:`.Query` object's Session."""

 #uerycontext = util.preloaded.orm_context

 #ession = query.session
 #f load:
        # flush current contents if we expect to load data
 #ession._autoflush()

    # TODO: need test coverage and documentation for the FrozenResult
    # use case.
 #f isinstance(iterator, FrozenResult):
 #rozen_result = iterator
 #terator = iter(frozen_result.data)
 #lse:
 #rozen_result = None

 #tx = querycontext.ORMSelectCompileState._create_entities_collection(
 #uery, legacy=True
 #

 #utoflush = session.autoflush
 #ry:
 #ession.autoflush = False
 #ingle_entity = not frozen_result and len(ctx._entities) == 1

 #f single_entity:
 #f isinstance(ctx._entities[0], querycontext._MapperEntity):
 #esult = [
 #ession._merge(
 #ttributes.instance_state(instance),
 #ttributes.instance_dict(instance),
 #oad=load,
 #recursive={},
 #resolve_conflict_map={},
 #
 #or instance in iterator
 #
 #lse:
 #esult = list(iterator)
 #lse:
 #apped_entities = [
 #
 #or i, e in enumerate(ctx._entities)
 #f isinstance(e, querycontext._MapperEntity)
 #
 #esult = []
 #eys = [ent._label_name for ent in ctx._entities]

 #eyed_tuple = result_tuple(
 #eys, [ent._extra_entities for ent in ctx._entities]
 #

 #or row in iterator:
 #ewrow = list(row)
 #or i in mapped_entities:
 #f newrow[i] is not None:
 #ewrow[i] = session._merge(
 #ttributes.instance_state(newrow[i]),
 #ttributes.instance_dict(newrow[i]),
 #oad=load,
 #recursive={},
 #resolve_conflict_map={},
 #
 #esult.append(keyed_tuple(newrow))

 #f frozen_result:
 #eturn frozen_result.with_data(result)
 #lse:
 #eturn iter(result)
 #inally:
 #ession.autoflush = autoflush


def get_from_identity(session, mapper, key, passive):
 #""Look up the given key in the given session's identity map,
 #heck the object for expired state if found.

 #""
 #nstance = session.identity_map.get(key)
 #f instance is not None:

 #tate = attributes.instance_state(instance)

 #f mapper.inherits and not state.mapper.isa(mapper):
 #eturn attributes.PASSIVE_CLASS_MISMATCH

        # expired - ensure it still exists
 #f state.expired:
 #f not passive & attributes.SQL_OK:
                # TODO: no coverage here
 #eturn attributes.PASSIVE_NO_RESULT
 #lif not passive & attributes.RELATED_OBJECT_OK:
                # this mode is used within a flush and the instance's
                # expired state will be checked soon enough, if necessary.
                # also used by immediateloader for a mutually-dependent
                # o2m->m2m load, :ticket:`6301`
 #eturn instance
 #ry:
 #tate._load_expired(state, passive)
 #xcept orm_exc.ObjectDeletedError:
 #ession._remove_newly_deleted([state])
 #eturn None
 #eturn instance
 #lse:
 #eturn None


def load_on_ident(
 #ession,
 #tatement,
 #ey,
 #oad_options=None,
 #efresh_state=None,
 #ith_for_update=None,
 #nly_load_props=None,
 #o_autoflush=False,
 #ind_arguments=util.EMPTY_DICT,
 #xecution_options=util.EMPTY_DICT,
):
 #""Load the given identity key from the database."""
 #f key is not None:
 #dent = key[1]
 #dentity_token = key[2]
 #lse:
 #dent = identity_token = None

 #eturn load_on_pk_identity(
 #ession,
 #tatement,
 #dent,
 #oad_options=load_options,
 #efresh_state=refresh_state,
 #ith_for_update=with_for_update,
 #nly_load_props=only_load_props,
 #dentity_token=identity_token,
 #o_autoflush=no_autoflush,
 #ind_arguments=bind_arguments,
 #xecution_options=execution_options,
 #


def load_on_pk_identity(
 #ession,
 #tatement,
 #rimary_key_identity,
 #oad_options=None,
 #efresh_state=None,
 #ith_for_update=None,
 #nly_load_props=None,
 #dentity_token=None,
 #o_autoflush=False,
 #ind_arguments=util.EMPTY_DICT,
 #xecution_options=util.EMPTY_DICT,
):

 #""Load the given primary key identity from the database."""

 #uery = statement
 # = query._clone()

 #s_lambda = q._is_lambda_element

    # TODO: fix these imports ....
 #rom .context import QueryContext, ORMCompileState

 #f load_options is None:
 #oad_options = QueryContext.default_load_options

 #ompile_options = ORMCompileState.default_compile_options

 #f primary_key_identity is not None:
 #apper = query._propagate_attrs["plugin_subject"]

 #_get_clause, _get_params) = mapper._get_clause

        # None present in ident - turn those comparisons
        # into "IS NULL"
 #f None in primary_key_identity:
 #ones = set(
 #
 #get_params[col].key
 #or col, value in zip(
 #apper.primary_key, primary_key_identity
 #
 #f value is None
 #
 #

 #get_clause = sql_util.adapt_criterion_to_null(_get_clause, nones)

 #f len(nones) == len(primary_key_identity):
 #til.warn(
 #fully NULL primary key identity cannot load any "
 #object.  This condition may raise an error in a future "
 #release."
 #

 #f is_lambda:
 # = q.add_criteria(
 #ambda q: q.where(
 #ql_util._deep_annotate(_get_clause, {"_orm_adapt": True})
 #,
                # this track_on will allow the lambda to refresh if
                # _get_clause goes stale due to reconfigured mapper.
                # however, it's not needed as the lambda otherwise tracks
                # on the SQL cache key of the expression.  the main thing
                # is that the bindparam.key stays the same if the cache key
                # stays the same, as we are referring to the .key explicitly
                # in the params.
                # track_on=[id(_get_clause)]
 #
 #lse:
 #._where_criteria = (
 #ql_util._deep_annotate(_get_clause, {"_orm_adapt": True}),
 #

 #arams = dict(
 #
 #_get_params[primary_key].key, id_val)
 #or id_val, primary_key in zip(
 #rimary_key_identity, mapper.primary_key
 #
 #
 #
 #lse:
 #arams = None

 #f is_lambda:
 #f with_for_update is not None or refresh_state or only_load_props:
 #aise NotImplementedError(
 #refresh operation not supported with lambda statement"
 #

 #ersion_check = False

 #, load_options = _set_get_options(
 #ompile_options,
 #oad_options,
 #ersion_check=version_check,
 #nly_load_props=only_load_props,
 #efresh_state=refresh_state,
 #dentity_token=identity_token,
 #

 #f no_autoflush:
 #oad_options += {"_autoflush": False}
 #lse:
 #f with_for_update is not None:
 #ersion_check = True
 #._for_update_arg = with_for_update
 #lif query._for_update_arg is not None:
 #ersion_check = True
 #._for_update_arg = query._for_update_arg
 #lse:
 #ersion_check = False

 #f refresh_state and refresh_state.load_options:
 #ompile_options += {
 #_current_path": refresh_state.load_path.parent
 #
 # = q.options(*refresh_state.load_options)

        # TODO: most of the compile_options that are not legacy only involve
        # this function, so try to see if handling of them can mostly be local
        # to here

 #._compile_options, load_options = _set_get_options(
 #ompile_options,
 #oad_options,
 #ersion_check=version_check,
 #nly_load_props=only_load_props,
 #efresh_state=refresh_state,
 #dentity_token=identity_token,
 #
 #._order_by = None

 #f no_autoflush:
 #oad_options += {"_autoflush": False}

 #xecution_options = util.EMPTY_DICT.merge_with(
 #xecution_options, {"_sa_orm_load_options": load_options}
 #
 #esult = (
 #ession.execute(
 #,
 #arams=params,
 #xecution_options=execution_options,
 #ind_arguments=bind_arguments,
 #
 #unique()
 #scalars()
 #

 #ry:
 #eturn result.one()
 #xcept orm_exc.NoResultFound:
 #eturn None


def _set_get_options(
 #ompile_opt,
 #oad_opt,
 #opulate_existing=None,
 #ersion_check=None,
 #nly_load_props=None,
 #efresh_state=None,
 #dentity_token=None,
):

 #ompile_options = {}
 #oad_options = {}
 #f version_check:
 #oad_options["_version_check"] = version_check
 #f populate_existing:
 #oad_options["_populate_existing"] = populate_existing
 #f refresh_state:
 #oad_options["_refresh_state"] = refresh_state
 #ompile_options["_for_refresh_state"] = True
 #f only_load_props:
 #ompile_options["_only_load_props"] = frozenset(only_load_props)
 #f identity_token:
 #oad_options["_refresh_identity_token"] = identity_token

 #f load_options:
 #oad_opt += load_options
 #f compile_options:
 #ompile_opt += compile_options

 #eturn compile_opt, load_opt


def _setup_entity_query(
 #ompile_state,
 #apper,
 #uery_entity,
 #ath,
 #dapter,
 #olumn_collection,
 #ith_polymorphic=None,
 #nly_load_props=None,
 #olymorphic_discriminator=None,
 #*kw
):

 #f with_polymorphic:
 #oly_properties = mapper._iterate_polymorphic_properties(
 #ith_polymorphic
 #
 #lse:
 #oly_properties = mapper._polymorphic_properties

 #uick_populators = {}

 #ath.set(compile_state.attributes, "memoized_setups", quick_populators)

    # for the lead entities in the path, e.g. not eager loads, and
    # assuming a user-passed aliased class, e.g. not a from_self() or any
    # implicit aliasing, don't add columns to the SELECT that aren't
    # in the thing that's aliased.
 #heck_for_adapt = adapter and len(path) == 1 and path[-1].is_aliased_class

 #or value in poly_properties:
 #f only_load_props and value.key not in only_load_props:
 #ontinue

 #alue.setup(
 #ompile_state,
 #uery_entity,
 #ath,
 #dapter,
 #nly_load_props=only_load_props,
 #olumn_collection=column_collection,
 #emoized_populators=quick_populators,
 #heck_for_adapt=check_for_adapt,
 #*kw
 #

 #f (
 #olymorphic_discriminator is not None
 #nd polymorphic_discriminator is not mapper.polymorphic_on
 #:

 #f adapter:
 #d = adapter.columns[polymorphic_discriminator]
 #lse:
 #d = polymorphic_discriminator
 #olumn_collection.append(pd)


def _warn_for_runid_changed(state):
 #til.warn(
 #Loading context for %s has changed within a load/refresh "
 #handler, suggesting a row refresh operation took place. If this "
 #event handler is expected to be "
 #emitting row refresh operations within an existing load or refresh "
 #operation, set restore_load_context=True when establishing the "
 #listener to ensure the context remains unchanged when the event "
 #handler completes." % (state_str(state),)
 #


def _instance_processor(
 #uery_entity,
 #apper,
 #ontext,
 #esult,
 #ath,
 #dapter,
 #nly_load_props=None,
 #efresh_state=None,
 #olymorphic_discriminator=None,
 #polymorphic_from=None,
):
 #""Produce a mapper level row processor callable
 #hich processes rows into mapped instances."""

    # note that this method, most of which exists in a closure
    # called _instance(), resists being broken out, as
    # attempts to do so tend to add significant function
    # call overhead.  _instance() is the most
    # performance-critical section in the whole ORM.

 #dentity_class = mapper._identity_class
 #ompile_state = context.compile_state

    # look for "row getter" functions that have been assigned along
    # with the compile state that were cached from a previous load.
    # these are operator.itemgetter() objects that each will extract a
    # particular column from each row.

 #etter_key = ("getters", mapper)
 #etters = path.get(compile_state.attributes, getter_key, None)

 #f getters is None:
        # no getters, so go through a list of attributes we are loading for,
        # and the ones that are column based will have already put information
        # for us in another collection "memoized_setups", which represents the
        # output of the LoaderStrategy.setup_query() method.  We can just as
        # easily call LoaderStrategy.create_row_processor for each, but by
        # getting it all at once from setup_query we save another method call
        # per attribute.
 #rops = mapper._prop_set
 #f only_load_props is not None:
 #rops = props.intersection(
 #apper._props[k] for k in only_load_props
 #

 #uick_populators = path.get(
 #ontext.attributes, "memoized_setups", _none_set
 #

 #odo = []
 #ached_populators = {
 #new": [],
 #quick": [],
 #deferred": [],
 #expire": [],
 #delayed": [],
 #existing": [],
 #eager": [],
 #

 #f refresh_state is None:
            # we can also get the "primary key" tuple getter function
 #k_cols = mapper.primary_key

 #f adapter:
 #k_cols = [adapter.columns[c] for c in pk_cols]
 #rimary_key_getter = result._tuple_getter(pk_cols)
 #lse:
 #rimary_key_getter = None

 #etters = {
 #cached_populators": cached_populators,
 #todo": todo,
 #primary_key_getter": primary_key_getter,
 #
 #or prop in props:
 #f prop in quick_populators:
                # this is an inlined path just for column-based attributes.
 #ol = quick_populators[prop]
 #f col is _DEFER_FOR_STATE:
 #ached_populators["new"].append(
 #prop.key, prop._deferred_column_loader)
 #
 #lif col is _SET_DEFERRED_EXPIRED:
                    # note that in this path, we are no longer
                    # searching in the result to see if the column might
                    # be present in some unexpected way.
 #ached_populators["expire"].append((prop.key, False))
 #lif col is _RAISE_FOR_STATE:
 #ached_populators["new"].append(
 #prop.key, prop._raise_column_loader)
 #
 #lse:
 #etter = None
 #f adapter:
                        # this logic had been removed for all 1.4 releases
                        # up until 1.4.18; the adapter here is particularly
                        # the compound eager adapter which isn't accommodated
                        # in the quick_populators right now.  The "fallback"
                        # logic below instead took over in many more cases
                        # until issue #6596 was identified.

                        # note there is still an issue where this codepath
                        # produces no "getter" for cases where a joined-inh
                        # mapping includes a labeled column property, meaning
                        # KeyError is caught internally and we fall back to
                        # _getter(col), which works anyway.   The adapter
                        # here for joined inh without any aliasing might not
                        # be useful.  Tests which see this include
                        # test.orm.inheritance.test_basic ->
                        # EagerTargetingTest.test_adapt_stringency
                        # OptimizedLoadTest.test_column_expression_joined
                        # PolymorphicOnNotLocalTest.test_polymorphic_on_column_prop  # noqa E501
                        #

 #dapted_col = adapter.columns[col]
 #f adapted_col is not None:
 #etter = result._getter(adapted_col, False)
 #f not getter:
 #etter = result._getter(col, False)
 #f getter:
 #ached_populators["quick"].append((prop.key, getter))
 #lse:
                        # fall back to the ColumnProperty itself, which
                        # will iterate through all of its columns
                        # to see if one fits
 #rop.create_row_processor(
 #ontext,
 #uery_entity,
 #ath,
 #apper,
 #esult,
 #dapter,
 #ached_populators,
 #
 #lse:
                # loader strategies like subqueryload, selectinload,
                # joinedload, basically relationships, these need to interact
                # with the context each time to work correctly.
 #odo.append(prop)

 #ath.set(compile_state.attributes, getter_key, getters)

 #ached_populators = getters["cached_populators"]

 #opulators = {key: list(value) for key, value in cached_populators.items()}
 #or prop in getters["todo"]:
 #rop.create_row_processor(
 #ontext, query_entity, path, mapper, result, adapter, populators
 #

 #ropagated_loader_options = context.propagated_loader_options
 #oad_path = (
 #ontext.compile_state.current_path + path
 #f context.compile_state.current_path.path
 #lse path
 #

 #ession_identity_map = context.session.identity_map

 #opulate_existing = context.populate_existing or mapper.always_refresh
 #oad_evt = bool(mapper.class_manager.dispatch.load)
 #efresh_evt = bool(mapper.class_manager.dispatch.refresh)
 #ersistent_evt = bool(context.session.dispatch.loaded_as_persistent)
 #f persistent_evt:
 #oaded_as_persistent = context.session.dispatch.loaded_as_persistent
 #nstance_state = attributes.instance_state
 #nstance_dict = attributes.instance_dict
 #ession_id = context.session.hash_key
 #unid = context.runid
 #dentity_token = context.identity_token

 #ersion_check = context.version_check
 #f version_check:
 #ersion_id_col = mapper.version_id_col
 #f version_id_col is not None:
 #f adapter:
 #ersion_id_col = adapter.columns[version_id_col]
 #ersion_id_getter = result._getter(version_id_col)
 #lse:
 #ersion_id_getter = None

 #f not refresh_state and _polymorphic_from is not None:
 #ey = ("loader", path.path)
 #f key in context.attributes and context.attributes[key].strategy == (
 #"selectinload_polymorphic", True),
 #:
 #electin_load_via = mapper._should_selectin_load(
 #ontext.attributes[key].local_opts["entities"],
 #polymorphic_from,
 #
 #lse:
 #electin_load_via = mapper._should_selectin_load(
 #one, _polymorphic_from
 #

 #f selectin_load_via and selectin_load_via is not _polymorphic_from:
            # only_load_props goes w/ refresh_state only, and in a refresh
            # we are a single row query for the exact entity; polymorphic
            # loading does not apply
 #ssert only_load_props is None

 #allable_ = _load_subclass_via_in(context, path, selectin_load_via)

 #ostLoad.callable_for_path(
 #ontext,
 #oad_path,
 #electin_load_via.mapper,
 #electin_load_via,
 #allable_,
 #electin_load_via,
 #

 #ost_load = PostLoad.for_context(context, load_path, only_load_props)

 #f refresh_state:
 #efresh_identity_key = refresh_state.key
 #f refresh_identity_key is None:
            # super-rare condition; a refresh is being called
            # on a non-instance-key instance; this is meant to only
            # occur within a flush()
 #efresh_identity_key = mapper._identity_key_from_state(
 #efresh_state
 #
 #lse:
 #efresh_identity_key = None

 #rimary_key_getter = getters["primary_key_getter"]

 #f mapper.allow_partial_pks:
 #s_not_primary_key = _none_set.issuperset
 #lse:
 #s_not_primary_key = _none_set.intersection

 #ef _instance(row):

        # determine the state that we'll be populating
 #f refresh_identity_key:
            # fixed state that we're refreshing
 #tate = refresh_state
 #nstance = state.obj()
 #ict_ = instance_dict(instance)
 #snew = state.runid != runid
 #urrentload = True
 #oaded_instance = False
 #lse:
            # look at the row, see if that identity is in the
            # session, or we have to create a new one
 #dentitykey = (
 #dentity_class,
 #rimary_key_getter(row),
 #dentity_token,
 #

 #nstance = session_identity_map.get(identitykey)

 #f instance is not None:
                # existing instance
 #tate = instance_state(instance)
 #ict_ = instance_dict(instance)

 #snew = state.runid != runid
 #urrentload = not isnew
 #oaded_instance = False

 #f version_check and version_id_getter and not currentload:
 #validate_version_id(
 #apper, state, dict_, row, version_id_getter
 #

 #lse:
                # create a new instance

                # check for non-NULL values in the primary key columns,
                # else no entity is returned for the row
 #f is_not_primary_key(identitykey[1]):
 #eturn None

 #snew = True
 #urrentload = True
 #oaded_instance = True

 #nstance = mapper.class_manager.new_instance()

 #ict_ = instance_dict(instance)
 #tate = instance_state(instance)
 #tate.key = identitykey
 #tate.identity_token = identity_token

                # attach instance to session.
 #tate.session_id = session_id
 #ession_identity_map._add_unpresent(state, identitykey)

 #ffective_populate_existing = populate_existing
 #f refresh_state is state:
 #ffective_populate_existing = True

        # populate.  this looks at whether this state is new
        # for this load or was existing, and whether or not this
        # row is the first row with this identity.
 #f currentload or effective_populate_existing:
            # full population routines.  Objects here are either
            # just created, or we are doing a populate_existing

            # be conservative about setting load_path when populate_existing
            # is in effect; want to maintain options from the original
            # load.  see test_expire->test_refresh_maintains_deferred_options
 #f isnew and (
 #ropagated_loader_options or not effective_populate_existing
 #:
 #tate.load_options = propagated_loader_options
 #tate.load_path = load_path

 #populate_full(
 #ontext,
 #ow,
 #tate,
 #ict_,
 #snew,
 #oad_path,
 #oaded_instance,
 #ffective_populate_existing,
 #opulators,
 #

 #f isnew:
                # state.runid should be equal to context.runid / runid
                # here, however for event checks we are being more conservative
                # and checking against existing run id
                # assert state.runid == runid

 #xisting_runid = state.runid

 #f loaded_instance:
 #f load_evt:
 #tate.manager.dispatch.load(state, context)
 #f state.runid != existing_runid:
 #warn_for_runid_changed(state)
 #f persistent_evt:
 #oaded_as_persistent(context.session, state)
 #f state.runid != existing_runid:
 #warn_for_runid_changed(state)
 #lif refresh_evt:
 #tate.manager.dispatch.refresh(
 #tate, context, only_load_props
 #
 #f state.runid != runid:
 #warn_for_runid_changed(state)

 #f effective_populate_existing or state.modified:
 #f refresh_state and only_load_props:
 #tate._commit(dict_, only_load_props)
 #lse:
 #tate._commit_all(dict_, session_identity_map)

 #f post_load:
 #ost_load.add_state(state, True)

 #lse:
            # partial population routines, for objects that were already
            # in the Session, but a row matches them; apply eager loaders
            # on existing objects, etc.
 #nloaded = state.unloaded
 #snew = state not in context.partials

 #f not isnew or unloaded or populators["eager"]:
                # state is having a partial set of its attributes
                # refreshed.  Populate those attributes,
                # and add to the "context.partials" collection.

 #o_load = _populate_partial(
 #ontext,
 #ow,
 #tate,
 #ict_,
 #snew,
 #oad_path,
 #nloaded,
 #opulators,
 #

 #f isnew:
 #f refresh_evt:
 #xisting_runid = state.runid
 #tate.manager.dispatch.refresh(state, context, to_load)
 #f state.runid != existing_runid:
 #warn_for_runid_changed(state)

 #tate._commit(dict_, to_load)

 #f post_load and context.invoke_all_eagers:
 #ost_load.add_state(state, False)

 #eturn instance

 #f mapper.polymorphic_map and not _polymorphic_from and not refresh_state:
        # if we are doing polymorphic, dispatch to a different _instance()
        # method specific to the subclass mapper
 #ef ensure_no_pk(row):
 #dentitykey = (
 #dentity_class,
 #rimary_key_getter(row),
 #dentity_token,
 #
 #f not is_not_primary_key(identitykey[1]):
 #eturn identitykey
 #lse:
 #eturn None

 #instance = _decorate_polymorphic_switch(
 #instance,
 #ontext,
 #uery_entity,
 #apper,
 #esult,
 #ath,
 #olymorphic_discriminator,
 #dapter,
 #nsure_no_pk,
 #

 #eturn _instance


def _load_subclass_via_in(context, path, entity):
 #apper = entity.mapper

 #ero_idx = len(mapper.base_mapper.primary_key) == 1

 #f entity.is_aliased_class:
 #, enable_opt, disable_opt = mapper._subclass_load_via_in(entity)
 #lse:
 #, enable_opt, disable_opt = mapper._subclass_load_via_in_mapper

 #ef do_load(context, path, states, load_only, effective_entity):
 #rig_query = context.query

 #2 = q._with_lazyload_options(
 #enable_opt,) + orig_query._with_options + (disable_opt,),
 #ath.parent,
 #ache_path=path,
 #

 #f context.populate_existing:
 #2.add_criteria(lambda q: q.populate_existing())

 #2(context.session).params(
 #rimary_keys=[
 #tate.key[1][0] if zero_idx else state.key[1]
 #or state, load_attrs in states
 #
 #.all()

 #eturn do_load


def _populate_full(
 #ontext,
 #ow,
 #tate,
 #ict_,
 #snew,
 #oad_path,
 #oaded_instance,
 #opulate_existing,
 #opulators,
):
 #f isnew:
        # first time we are seeing a row with this identity.
 #tate.runid = context.runid

 #or key, getter in populators["quick"]:
 #ict_[key] = getter(row)
 #f populate_existing:
 #or key, set_callable in populators["expire"]:
 #ict_.pop(key, None)
 #f set_callable:
 #tate.expired_attributes.add(key)
 #lse:
 #or key, set_callable in populators["expire"]:
 #f set_callable:
 #tate.expired_attributes.add(key)

 #or key, populator in populators["new"]:
 #opulator(state, dict_, row)
 #or key, populator in populators["delayed"]:
 #opulator(state, dict_, row)
 #lif load_path != state.load_path:
        # new load path, e.g. object is present in more than one
        # column position in a series of rows
 #tate.load_path = load_path

        # if we have data, and the data isn't in the dict, OK, let's put
        # it in.
 #or key, getter in populators["quick"]:
 #f key not in dict_:
 #ict_[key] = getter(row)

        # otherwise treat like an "already seen" row
 #or key, populator in populators["existing"]:
 #opulator(state, dict_, row)
            # TODO:  allow "existing" populator to know this is
            # a new path for the state:
            # populator(state, dict_, row, new_path=True)

 #lse:
        # have already seen rows with this identity in this same path.
 #or key, populator in populators["existing"]:
 #opulator(state, dict_, row)

            # TODO: same path
            # populator(state, dict_, row, new_path=False)


def _populate_partial(
 #ontext, row, state, dict_, isnew, load_path, unloaded, populators
):

 #f not isnew:
 #o_load = context.partials[state]
 #or key, populator in populators["existing"]:
 #f key in to_load:
 #opulator(state, dict_, row)
 #lse:
 #o_load = unloaded
 #ontext.partials[state] = to_load

 #or key, getter in populators["quick"]:
 #f key in to_load:
 #ict_[key] = getter(row)
 #or key, set_callable in populators["expire"]:
 #f key in to_load:
 #ict_.pop(key, None)
 #f set_callable:
 #tate.expired_attributes.add(key)
 #or key, populator in populators["new"]:
 #f key in to_load:
 #opulator(state, dict_, row)
 #or key, populator in populators["delayed"]:
 #f key in to_load:
 #opulator(state, dict_, row)
 #or key, populator in populators["eager"]:
 #f key not in unloaded:
 #opulator(state, dict_, row)

 #eturn to_load


def _validate_version_id(mapper, state, dict_, row, getter):

 #f mapper._get_state_attr_by_column(
 #tate, dict_, mapper.version_id_col
 # != getter(row):
 #aise orm_exc.StaleDataError(
 #Instance '%s' has version id '%s' which "
 #does not match database-loaded version id '%s'."
 # (
 #tate_str(state),
 #apper._get_state_attr_by_column(
 #tate, dict_, mapper.version_id_col
 #,
 #etter(row),
 #
 #


def _decorate_polymorphic_switch(
 #nstance_fn,
 #ontext,
 #uery_entity,
 #apper,
 #esult,
 #ath,
 #olymorphic_discriminator,
 #dapter,
 #nsure_no_pk,
):
 #f polymorphic_discriminator is not None:
 #olymorphic_on = polymorphic_discriminator
 #lse:
 #olymorphic_on = mapper.polymorphic_on
 #f polymorphic_on is None:
 #eturn instance_fn

 #f adapter:
 #olymorphic_on = adapter.columns[polymorphic_on]

 #ef configure_subclass_mapper(discriminator):
 #ry:
 #ub_mapper = mapper.polymorphic_map[discriminator]
 #xcept KeyError:
 #aise AssertionError(
 #No such polymorphic_identity %r is defined" % discriminator
 #
 #lse:
 #f sub_mapper is mapper:
 #eturn None
 #lif not sub_mapper.isa(mapper):
 #eturn False

 #eturn _instance_processor(
 #uery_entity,
 #ub_mapper,
 #ontext,
 #esult,
 #ath,
 #dapter,
 #polymorphic_from=mapper,
 #

 #olymorphic_instances = util.PopulateDict(configure_subclass_mapper)

 #etter = result._getter(polymorphic_on)

 #ef polymorphic_instance(row):
 #iscriminator = getter(row)
 #f discriminator is not None:
 #instance = polymorphic_instances[discriminator]
 #f _instance:
 #eturn _instance(row)
 #lif _instance is False:
 #dentitykey = ensure_no_pk(row)

 #f identitykey:
 #aise sa_exc.InvalidRequestError(
 #Row with identity key %s can't be loaded into an "
 #object; the polymorphic discriminator column '%s' "
 #refers to %s, which is not a sub-mapper of "
 #the requested %s"
 # (
 #dentitykey,
 #olymorphic_on,
 #apper.polymorphic_map[discriminator],
 #apper,
 #
 #
 #lse:
 #eturn None
 #lse:
 #eturn instance_fn(row)
 #lse:
 #dentitykey = ensure_no_pk(row)

 #f identitykey:
 #aise sa_exc.InvalidRequestError(
 #Row with identity key %s can't be loaded into an "
 #object; the polymorphic discriminator column '%s' is "
 #NULL" % (identitykey, polymorphic_on)
 #
 #lse:
 #eturn None

 #eturn polymorphic_instance


class PostLoad(object):
 #""Track loaders and states for "post load" operations."""

 #_slots__ = "loaders", "states", "load_keys"

 #ef __init__(self):
 #elf.loaders = {}
 #elf.states = util.OrderedDict()
 #elf.load_keys = None

 #ef add_state(self, state, overwrite):
        # the states for a polymorphic load here are all shared
        # within a single PostLoad object among multiple subtypes.
        # Filtering of callables on a per-subclass basis needs to be done at
        # the invocation level
 #elf.states[state] = overwrite

 #ef invoke(self, context, path):
 #f not self.states:
 #eturn
 #ath = path_registry.PathRegistry.coerce(path)
 #or token, limit_to_mapper, loader, arg, kw in self.loaders.values():
 #tates = [
 #state, overwrite)
 #or state, overwrite in self.states.items()
 #f state.manager.mapper.isa(limit_to_mapper)
 #
 #f states:
 #oader(context, path, states, self.load_keys, *arg, **kw)
 #elf.states.clear()

 #classmethod
 #ef for_context(cls, context, path, only_load_props):
 #l = context.post_load_paths.get(path.path)
 #f pl is not None and only_load_props:
 #l.load_keys = only_load_props
 #eturn pl

 #classmethod
 #ef path_exists(self, context, path, key):
 #eturn (
 #ath.path in context.post_load_paths
 #nd key in context.post_load_paths[path.path].loaders
 #

 #classmethod
 #ef callable_for_path(
 #ls, context, path, limit_to_mapper, token, loader_callable, *arg, **kw
 #:
 #f path.path in context.post_load_paths:
 #l = context.post_load_paths[path.path]
 #lse:
 #l = context.post_load_paths[path.path] = PostLoad()
 #l.loaders[token] = (token, limit_to_mapper, loader_callable, arg, kw)


def load_scalar_attributes(mapper, state, attribute_names, passive):
 #""initiate a column-based attribute refresh operation."""

    # assert mapper is _state_mapper(state)
 #ession = state.session
 #f not session:
 #aise orm_exc.DetachedInstanceError(
 #Instance %s is not bound to a Session; "
 #attribute refresh operation cannot proceed" % (state_str(state))
 #

 #as_key = bool(state.key)

 #esult = False

 #o_autoflush = (
 #ool(passive & attributes.NO_AUTOFLUSH) or state.session.autocommit
 #

    # in the case of inheritance, particularly concrete and abstract
    # concrete inheritance, the class manager might have some keys
    # of attributes on the superclass that we didn't actually map.
    # These could be mapped as "concrete, don't load" or could be completely
    # excluded from the mapping and we know nothing about them.  Filter them
    # here to prevent them from coming through.
 #f attribute_names:
 #ttribute_names = attribute_names.intersection(mapper.attrs.keys())

 #f mapper.inherits and not mapper.concrete:
        # because we are using Core to produce a select() that we
        # pass to the Query, we aren't calling setup() for mapped
        # attributes; in 1.0 this means deferred attrs won't get loaded
        # by default
 #tatement = mapper._optimized_get_statement(state, attribute_names)
 #f statement is not None:
            # this was previously aliased(mapper, statement), however,
            # statement is a select() and Query's coercion now raises for this
            # since you can't "select" from a "SELECT" statement.  only
            # from_statement() allows this.
            # note: using from_statement() here means there is an adaption
            # with adapt_on_names set up.  the other option is to make the
            # aliased() against a subquery which affects the SQL.

 #rom .query import FromStatement

 #tmt = FromStatement(mapper, statement).options(
 #trategy_options.Load(mapper).undefer("*")
 #

 #esult = load_on_ident(
 #ession,
 #tmt,
 #one,
 #nly_load_props=attribute_names,
 #efresh_state=state,
 #o_autoflush=no_autoflush,
 #

 #f result is False:
 #f has_key:
 #dentity_key = state.key
 #lse:
            # this codepath is rare - only valid when inside a flush, and the
            # object is becoming persistent but hasn't yet been assigned
            # an identity_key.
            # check here to ensure we have the attrs we need.
 #k_attrs = [
 #apper._columntoproperty[col].key for col in mapper.primary_key
 #
 #f state.expired_attributes.intersection(pk_attrs):
 #aise sa_exc.InvalidRequestError(
 #Instance %s cannot be refreshed - it's not "
 # persistent and does not "
 #contain a full primary key." % state_str(state)
 #
 #dentity_key = mapper._identity_key_from_state(state)

 #f (
 #none_set.issubset(identity_key) and not mapper.allow_partial_pks
 # or _none_set.issuperset(identity_key):
 #til.warn_limited(
 #Instance %s to be refreshed doesn't "
 #contain a full primary key - can't be refreshed "
 #(and shouldn't be expired, either).",
 #tate_str(state),
 #
 #eturn

 #esult = load_on_ident(
 #ession,
 #uture.select(mapper).set_label_style(
 #ABEL_STYLE_TABLENAME_PLUS_COL
 #,
 #dentity_key,
 #efresh_state=state,
 #nly_load_props=attribute_names,
 #o_autoflush=no_autoflush,
 #

    # if instance is pending, a refresh operation
    # may not complete (even if PK attributes are assigned)
 #f has_key and result is None:
 #aise orm_exc.ObjectDeletedError(state)
