# orm/relationships.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Heuristics related to join conditions as used in
:func:`_orm.relationship`.

Provides the :class:`.JoinCondition` object, which encapsulates
SQL annotation and aliasing behavior focused on the `primaryjoin`
and `secondaryjoin` aspects of :func:`_orm.relationship`.

"""
from __future__ import absolute_import

import collections
import re
import weakref

from . import attributes
from .base import _is_mapped_class
from .base import state_str
from .interfaces import MANYTOMANY
from .interfaces import MANYTOONE
from .interfaces import ONETOMANY
from .interfaces import PropComparator
from .interfaces import StrategizedProperty
from .util import _orm_annotate
from .util import _orm_deannotate
from .util import CascadeOptions
from .. import exc as sa_exc
from .. import log
from .. import schema
from .. import sql
from .. import util
from ..inspection import inspect
from ..sql import coercions
from ..sql import expression
from ..sql import operators
from ..sql import roles
from ..sql import visitors
from ..sql.util import _deep_deannotate
from ..sql.util import _shallow_annotate
from ..sql.util import adapt_criterion_to_null
from ..sql.util import ClauseAdapter
from ..sql.util import join_condition
from ..sql.util import selectables_overlap
from ..sql.util import visit_binary_product


def remote(expr):
 #""Annotate a portion of a primaryjoin expression
 #ith a 'remote' annotation.

 #ee the section :ref:`relationship_custom_foreign` for a
 #escription of use.

 #. seealso::

 #ref:`relationship_custom_foreign`

 #func:`.foreign`

 #""
 #eturn _annotate_columns(
 #oercions.expect(roles.ColumnArgumentRole, expr), {"remote": True}
 #


def foreign(expr):
 #""Annotate a portion of a primaryjoin expression
 #ith a 'foreign' annotation.

 #ee the section :ref:`relationship_custom_foreign` for a
 #escription of use.

 #. seealso::

 #ref:`relationship_custom_foreign`

 #func:`.remote`

 #""

 #eturn _annotate_columns(
 #oercions.expect(roles.ColumnArgumentRole, expr), {"foreign": True}
 #


@log.class_logger
class RelationshipProperty(StrategizedProperty):
 #""Describes an object property that holds a single item or list
 #f items that correspond to a related database table.

 #ublic constructor is the :func:`_orm.relationship` function.

 #. seealso::

 #ref:`relationship_config_toplevel`

 #""

 #trategy_wildcard_key = "relationship"
 #nherit_cache = True

 #persistence_only = dict(
 #assive_deletes=False,
 #assive_updates=True,
 #nable_typechecks=True,
 #ctive_history=False,
 #ascade_backrefs=True,
 #

 #dependency_processor = None

 #ef __init__(
 #elf,
 #rgument,
 #econdary=None,
 #rimaryjoin=None,
 #econdaryjoin=None,
 #oreign_keys=None,
 #selist=None,
 #rder_by=False,
 #ackref=None,
 #ack_populates=None,
 #verlaps=None,
 #ost_update=False,
 #ascade=False,
 #iewonly=False,
 #azy="select",
 #ollection_class=None,
 #assive_deletes=_persistence_only["passive_deletes"],
 #assive_updates=_persistence_only["passive_updates"],
 #emote_side=None,
 #nable_typechecks=_persistence_only["enable_typechecks"],
 #oin_depth=None,
 #omparator_factory=None,
 #ingle_parent=False,
 #nnerjoin=False,
 #istinct_target_key=None,
 #oc=None,
 #ctive_history=_persistence_only["active_history"],
 #ascade_backrefs=_persistence_only["cascade_backrefs"],
 #oad_on_pending=False,
 #ake_queries=True,
 #local_remote_pairs=None,
 #uery_class=None,
 #nfo=None,
 #mit_join=None,
 #ync_backref=None,
 #legacy_inactive_history_style=False,
 #:
 #""Provide a relationship between two mapped classes.

 #his corresponds to a parent-child or associative table relationship.
 #he constructed class is an instance of
 #class:`.RelationshipProperty`.

 # typical :func:`_orm.relationship`, used in a classical mapping::

 #apper(Parent, properties={
 #children': relationship(Child)
 #)

 #ome arguments accepted by :func:`_orm.relationship`
 #ptionally accept a
 #allable function, which when called produces the desired value.
 #he callable is invoked by the parent :class:`_orm.Mapper` at "mapper
 #nitialization" time, which happens only when mappers are first used,
 #nd is assumed to be after all mappings have been constructed.  This
 #an be used to resolve order-of-declaration and other dependency
 #ssues, such as if ``Child`` is declared below ``Parent`` in the same
 #ile::

 #apper(Parent, properties={
 #children":relationship(lambda: Child,
 #rder_by=lambda: Child.id)
 #)

 #hen using the :ref:`declarative_toplevel` extension, the Declarative
 #nitializer allows string arguments to be passed to
 #func:`_orm.relationship`.  These string arguments are converted into
 #allables that evaluate the string as Python code, using the
 #eclarative class-registry as a namespace.  This allows the lookup of
 #elated classes to be automatic via their string name, and removes the
 #eed for related classes to be imported into the local module space
 #efore the dependent classes have been declared.  It is still required
 #hat the modules in which these related classes appear are imported
 #nywhere in the application at some point before the related mappings
 #re actually used, else a lookup error will be raised when the
 #func:`_orm.relationship`
 #ttempts to resolve the string reference to the
 #elated class.    An example of a string- resolved class is as
 #ollows::

 #rom sqlalchemy.ext.declarative import declarative_base

 #ase = declarative_base()

 #lass Parent(Base):
 #_tablename__ = 'parent'
 #d = Column(Integer, primary_key=True)
 #hildren = relationship("Child", order_by="Child.id")

 #. seealso::

 #ref:`relationship_config_toplevel` - Full introductory and
 #eference documentation for :func:`_orm.relationship`.

 #ref:`orm_tutorial_relationship` - ORM tutorial introduction.

 #param argument:
 # mapped class, or actual :class:`_orm.Mapper` instance,
 #epresenting
 #he target of the relationship.

 #paramref:`_orm.relationship.argument`
 #ay also be passed as a callable
 #unction which is evaluated at mapper initialization time, and may
 #e passed as a string name when using Declarative.

 #. warning:: Prior to SQLAlchemy 1.3.16, this value is interpreted
 #sing Python's ``eval()`` function.
 #*DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
 #ee :ref:`declarative_relationship_eval` for details on
 #eclarative evaluation of :func:`_orm.relationship` arguments.

 #. versionchanged 1.3.16::

 #he string evaluation of the main "argument" no longer accepts an
 #pen ended Python expression, instead only accepting a string
 #lass name or dotted package-qualified name.

 #. seealso::

 #ref:`declarative_configuring_relationships` - further detail
 #n relationship configuration when using Declarative.

 #param secondary:
 #or a many-to-many relationship, specifies the intermediary
 #able, and is typically an instance of :class:`_schema.Table`.
 #n less common circumstances, the argument may also be specified
 #s an :class:`_expression.Alias` construct, or even a
 #class:`_expression.Join` construct.

 #paramref:`_orm.relationship.secondary` may
 #lso be passed as a callable function which is evaluated at
 #apper initialization time.  When using Declarative, it may also
 #e a string argument noting the name of a :class:`_schema.Table`
 #hat is
 #resent in the :class:`_schema.MetaData`
 #ollection associated with the
 #arent-mapped :class:`_schema.Table`.

 #. warning:: When passed as a Python-evaluable string, the
 #rgument is interpreted using Python's ``eval()`` function.
 #*DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
 #ee :ref:`declarative_relationship_eval` for details on
 #eclarative evaluation of :func:`_orm.relationship` arguments.

 #he :paramref:`_orm.relationship.secondary` keyword argument is
 #ypically applied in the case where the intermediary
 #class:`_schema.Table`
 #s not otherwise expressed in any direct class mapping. If the
 #secondary" table is also explicitly mapped elsewhere (e.g. as in
 #ref:`association_pattern`), one should consider applying the
 #paramref:`_orm.relationship.viewonly` flag so that this
 #func:`_orm.relationship`
 #s not used for persistence operations which
 #ay conflict with those of the association object pattern.

 #. seealso::

 #ref:`relationships_many_to_many` - Reference example of "many
 #o many".

 #ref:`orm_tutorial_many_to_many` - ORM tutorial introduction to
 #any-to-many relationships.

 #ref:`self_referential_many_to_many` - Specifics on using
 #any-to-many in a self-referential case.

 #ref:`declarative_many_to_many` - Additional options when using
 #eclarative.

 #ref:`association_pattern` - an alternative to
 #paramref:`_orm.relationship.secondary`
 #hen composing association
 #able relationships, allowing additional attributes to be
 #pecified on the association table.

 #ref:`composite_secondary_join` - a lesser-used pattern which
 #n some cases can enable complex :func:`_orm.relationship` SQL
 #onditions to be used.

 #. versionadded:: 0.9.2 :paramref:`_orm.relationship.secondary`
 #orks
 #ore effectively when referring to a :class:`_expression.Join`
 #nstance.

 #param active_history=False:
 #hen ``True``, indicates that the "previous" value for a
 #any-to-one reference should be loaded when replaced, if
 #ot already loaded. Normally, history tracking logic for
 #imple many-to-ones only needs to be aware of the "new"
 #alue in order to perform a flush. This flag is available
 #or applications that make use of
 #func:`.attributes.get_history` which also need to know
 #he "previous" value of the attribute.

 #param backref:
 #ndicates the string name of a property to be placed on the related
 #apper's class that will handle this relationship in the other
 #irection. The other property will be created automatically
 #hen the mappers are configured.  Can also be passed as a
 #func:`.backref` object to control the configuration of the
 #ew relationship.

 #. seealso::

 #ref:`relationships_backref` - Introductory documentation and
 #xamples.

 #paramref:`_orm.relationship.back_populates` - alternative form
 #f backref specification.

 #func:`.backref` - allows control over :func:`_orm.relationship`
 #onfiguration when using :paramref:`_orm.relationship.backref`.


 #param back_populates:
 #akes a string name and has the same meaning as
 #paramref:`_orm.relationship.backref`, except the complementing
 #roperty is **not** created automatically, and instead must be
 #onfigured explicitly on the other mapper.  The complementing
 #roperty should also indicate
 #paramref:`_orm.relationship.back_populates` to this relationship to
 #nsure proper functioning.

 #. seealso::

 #ref:`relationships_backref` - Introductory documentation and
 #xamples.

 #paramref:`_orm.relationship.backref` - alternative form
 #f backref specification.

 #param overlaps:
 # string name or comma-delimited set of names of other relationships
 #n either this mapper, a descendant mapper, or a target mapper with
 #hich this relationship may write to the same foreign keys upon
 #ersistence.   The only effect this has is to eliminate the
 #arning that this relationship will conflict with another upon
 #ersistence.   This is used for such relationships that are truly
 #apable of conflicting with each other on write, but the application
 #ill ensure that no such conflicts occur.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`error_qzyx` - usage example

 #param bake_queries=True:
 #nable :ref:`lambda caching <engine_lambda_caching>` for loader
 #trategies, if applicable, which adds a performance gain to the
 #onstruction of SQL constructs used by loader strategies, in addition
 #o the usual SQL statement caching used throughout SQLAlchemy. This
 #arameter currently applies only to the "lazy" and "selectin" loader
 #trategies. There is generally no reason to set this parameter to
 #alse.

 #. versionchanged:: 1.4  Relationship loaders no longer use the
 #revious "baked query" system of query caching.   The "lazy"
 #nd "selectin" loaders make use of the "lambda cache" system
 #or the construction of SQL constructs,
 #s well as the usual SQL caching system that is throughout
 #QLAlchemy as of the 1.4 series.

 #param cascade:
 # comma-separated list of cascade rules which determines how
 #ession operations should be "cascaded" from parent to child.
 #his defaults to ``False``, which means the default cascade
 #hould be used - this default cascade is ``"save-update, merge"``.

 #he available cascades are ``save-update``, ``merge``,
 #`expunge``, ``delete``, ``delete-orphan``, and ``refresh-expire``.
 #n additional option, ``all`` indicates shorthand for
 #`"save-update, merge, refresh-expire,
 #xpunge, delete"``, and is often used as in ``"all, delete-orphan"``
 #o indicate that related objects should follow along with the
 #arent object in all cases, and be deleted when de-associated.

 #. seealso::

 #ref:`unitofwork_cascades` - Full detail on each of the available
 #ascade options.

 #ref:`tutorial_delete_cascade` - Tutorial example describing
 # delete cascade.

 #param cascade_backrefs=True:
 # boolean value indicating if the ``save-update`` cascade should
 #perate along an assignment event intercepted by a backref.
 #hen set to ``False``, the attribute managed by this relationship
 #ill not cascade an incoming transient object into the session of a
 #ersistent parent, if the event is received via backref.

 #. deprecated:: 1.4 The
 #paramref:`_orm.relationship.cascade_backrefs`
 #lag will default to False in all cases in SQLAlchemy 2.0.

 #. seealso::

 #ref:`backref_cascade` - Full discussion and examples on how
 #he :paramref:`_orm.relationship.cascade_backrefs` option is used.

 #param collection_class:
 # class or callable that returns a new list-holding object. will
 #e used in place of a plain list for storing elements.

 #. seealso::

 #ref:`custom_collections` - Introductory documentation and
 #xamples.

 #param comparator_factory:
 # class which extends :class:`.RelationshipProperty.Comparator`
 #hich provides custom SQL clause generation for comparison
 #perations.

 #. seealso::

 #class:`.PropComparator` - some detail on redefining comparators
 #t this level.

 #ref:`custom_comparators` - Brief intro to this feature.


 #param distinct_target_key=None:
 #ndicate if a "subquery" eager load should apply the DISTINCT
 #eyword to the innermost SELECT statement.  When left as ``None``,
 #he DISTINCT keyword will be applied in those cases when the target
 #olumns do not comprise the full primary key of the target table.
 #hen set to ``True``, the DISTINCT keyword is applied to the
 #nnermost SELECT unconditionally.

 #t may be desirable to set this flag to False when the DISTINCT is
 #educing performance of the innermost subquery beyond that of what
 #uplicate innermost rows may be causing.

 #. versionchanged:: 0.9.0 -
 #paramref:`_orm.relationship.distinct_target_key` now defaults to
 #`None``, so that the feature enables itself automatically for
 #hose cases where the innermost query targets a non-unique
 #ey.

 #. seealso::

 #ref:`loading_toplevel` - includes an introduction to subquery
 #ager loading.

 #param doc:
 #ocstring which will be applied to the resulting descriptor.

 #param foreign_keys:

 # list of columns which are to be used as "foreign key"
 #olumns, or columns which refer to the value in a remote
 #olumn, within the context of this :func:`_orm.relationship`
 #bject's :paramref:`_orm.relationship.primaryjoin` condition.
 #hat is, if the :paramref:`_orm.relationship.primaryjoin`
 #ondition of this :func:`_orm.relationship` is ``a.id ==
 #.a_id``, and the values in ``b.a_id`` are required to be
 #resent in ``a.id``, then the "foreign key" column of this
 #func:`_orm.relationship` is ``b.a_id``.

 #n normal cases, the :paramref:`_orm.relationship.foreign_keys`
 #arameter is **not required.** :func:`_orm.relationship` will
 #utomatically determine which columns in the
 #paramref:`_orm.relationship.primaryjoin` condition are to be
 #onsidered "foreign key" columns based on those
 #class:`_schema.Column` objects that specify
 #class:`_schema.ForeignKey`,
 #r are otherwise listed as referencing columns in a
 #class:`_schema.ForeignKeyConstraint` construct.
 #paramref:`_orm.relationship.foreign_keys` is only needed when:

 #. There is more than one way to construct a join from the local
 #able to the remote table, as there are multiple foreign key
 #eferences present.  Setting ``foreign_keys`` will limit the
 #func:`_orm.relationship`
 #o consider just those columns specified
 #ere as "foreign".

 #. The :class:`_schema.Table` being mapped does not actually have
 #class:`_schema.ForeignKey` or
 #class:`_schema.ForeignKeyConstraint`
 #onstructs present, often because the table
 #as reflected from a database that does not support foreign key
 #eflection (MySQL MyISAM).

 #. The :paramref:`_orm.relationship.primaryjoin`
 #rgument is used to
 #onstruct a non-standard join condition, which makes use of
 #olumns or expressions that do not normally refer to their
 #parent" column, such as a join condition expressed by a
 #omplex comparison using a SQL function.

 #he :func:`_orm.relationship` construct will raise informative
 #rror messages that suggest the use of the
 #paramref:`_orm.relationship.foreign_keys` parameter when
 #resented with an ambiguous condition.   In typical cases,
 #f :func:`_orm.relationship` doesn't raise any exceptions, the
 #paramref:`_orm.relationship.foreign_keys` parameter is usually
 #ot needed.

 #paramref:`_orm.relationship.foreign_keys` may also be passed as a
 #allable function which is evaluated at mapper initialization time,
 #nd may be passed as a Python-evaluable string when using
 #eclarative.

 #. warning:: When passed as a Python-evaluable string, the
 #rgument is interpreted using Python's ``eval()`` function.
 #*DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
 #ee :ref:`declarative_relationship_eval` for details on
 #eclarative evaluation of :func:`_orm.relationship` arguments.

 #. seealso::

 #ref:`relationship_foreign_keys`

 #ref:`relationship_custom_foreign`

 #func:`.foreign` - allows direct annotation of the "foreign"
 #olumns within a :paramref:`_orm.relationship.primaryjoin`
 #ondition.

 #param info: Optional data dictionary which will be populated into the
 #attr:`.MapperProperty.info` attribute of this object.

 #param innerjoin=False:
 #hen ``True``, joined eager loads will use an inner join to join
 #gainst related tables instead of an outer join.  The purpose
 #f this option is generally one of performance, as inner joins
 #enerally perform better than outer joins.

 #his flag can be set to ``True`` when the relationship references an
 #bject via many-to-one using local foreign keys that are not
 #ullable, or when the reference is one-to-one or a collection that
 #s guaranteed to have one or at least one entry.

 #he option supports the same "nested" and "unnested" options as
 #hat of :paramref:`_orm.joinedload.innerjoin`.  See that flag
 #or details on nested / unnested behaviors.

 #. seealso::

 #paramref:`_orm.joinedload.innerjoin` - the option as specified by
 #oader option, including detail on nesting behavior.

 #ref:`what_kind_of_loading` - Discussion of some details of
 #arious loader options.


 #param join_depth:
 #hen non-``None``, an integer value indicating how many levels
 #eep "eager" loaders should join on a self-referring or cyclical
 #elationship.  The number counts how many times the same Mapper
 #hall be present in the loading condition along a particular join
 #ranch.  When left at its default of ``None``, eager loaders
 #ill stop chaining when they encounter a the same target mapper
 #hich is already higher up in the chain.  This option applies
 #oth to joined- and subquery- eager loaders.

 #. seealso::

 #ref:`self_referential_eager_loading` - Introductory documentation
 #nd examples.

 #param lazy='select': specifies
 #ow the related items should be loaded.  Default value is
 #`select``.  Values include:

 # ``select`` - items should be loaded lazily when the property is
 #irst accessed, using a separate SELECT statement, or identity map
 #etch for simple many-to-one references.

 # ``immediate`` - items should be loaded as the parents are loaded,
 #sing a separate SELECT statement, or identity map fetch for
 #imple many-to-one references.

 # ``joined`` - items should be loaded "eagerly" in the same query as
 #hat of the parent, using a JOIN or LEFT OUTER JOIN.  Whether
 #he join is "outer" or not is determined by the
 #paramref:`_orm.relationship.innerjoin` parameter.

 # ``subquery`` - items should be loaded "eagerly" as the parents are
 #oaded, using one additional SQL statement, which issues a JOIN to
 # subquery of the original statement, for each collection
 #equested.

 # ``selectin`` - items should be loaded "eagerly" as the parents
 #re loaded, using one or more additional SQL statements, which
 #ssues a JOIN to the immediate parent object, specifying primary
 #ey identifiers using an IN clause.

 #. versionadded:: 1.2

 # ``noload`` - no loading should occur at any time.  This is to
 #upport "write-only" attributes, or attributes which are
 #opulated in some manner specific to the application.

 # ``raise`` - lazy loading is disallowed; accessing
 #he attribute, if its value were not already loaded via eager
 #oading, will raise an :exc:`~sqlalchemy.exc.InvalidRequestError`.
 #his strategy can be used when objects are to be detached from
 #heir attached :class:`.Session` after they are loaded.

 #. versionadded:: 1.1

 # ``raise_on_sql`` - lazy loading that emits SQL is disallowed;
 #ccessing the attribute, if its value were not already loaded via
 #ager loading, will raise an
 #exc:`~sqlalchemy.exc.InvalidRequestError`, **if the lazy load
 #eeds to emit SQL**.  If the lazy load can pull the related value
 #rom the identity map or determine that it should be None, the
 #alue is loaded.  This strategy can be used when objects will
 #emain associated with the attached :class:`.Session`, however
 #dditional SELECT statements should be blocked.

 #. versionadded:: 1.1

 # ``dynamic`` - the attribute will return a pre-configured
 #class:`_query.Query` object for all read
 #perations, onto which further filtering operations can be
 #pplied before iterating the results.  See
 #he section :ref:`dynamic_relationship` for more details.

 # True - a synonym for 'select'

 # False - a synonym for 'joined'

 # None - a synonym for 'noload'

 #. seealso::

 #doc:`/orm/loading_relationships` - Full documentation on
 #elationship loader configuration.

 #ref:`dynamic_relationship` - detail on the ``dynamic`` option.

 #ref:`collections_noload_raiseload` - notes on "noload" and "raise"

 #param load_on_pending=False:
 #ndicates loading behavior for transient or pending parent objects.

 #hen set to ``True``, causes the lazy-loader to
 #ssue a query for a parent object that is not persistent, meaning it
 #as never been flushed.  This may take effect for a pending object
 #hen autoflush is disabled, or for a transient object that has been
 #attached" to a :class:`.Session` but is not part of its pending
 #ollection.

 #he :paramref:`_orm.relationship.load_on_pending`
 #lag does not improve
 #ehavior when the ORM is used normally - object references should be
 #onstructed at the object level, not at the foreign key level, so
 #hat they are present in an ordinary way before a flush proceeds.
 #his flag is not not intended for general use.

 #. seealso::

 #meth:`.Session.enable_relationship_loading` - this method
 #stablishes "load on pending" behavior for the whole object, and
 #lso allows loading on objects that remain transient or
 #etached.

 #param order_by:
 #ndicates the ordering that should be applied when loading these
 #tems.  :paramref:`_orm.relationship.order_by`
 #s expected to refer to
 #ne of the :class:`_schema.Column`
 #bjects to which the target class is
 #apped, or the attribute itself bound to the target class which
 #efers to the column.

 #paramref:`_orm.relationship.order_by`
 #ay also be passed as a callable
 #unction which is evaluated at mapper initialization time, and may
 #e passed as a Python-evaluable string when using Declarative.

 #. warning:: When passed as a Python-evaluable string, the
 #rgument is interpreted using Python's ``eval()`` function.
 #*DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
 #ee :ref:`declarative_relationship_eval` for details on
 #eclarative evaluation of :func:`_orm.relationship` arguments.

 #param passive_deletes=False:
 #ndicates loading behavior during delete operations.

 # value of True indicates that unloaded child items should not
 #e loaded during a delete operation on the parent.  Normally,
 #hen a parent item is deleted, all child items are loaded so
 #hat they can either be marked as deleted, or have their
 #oreign key to the parent set to NULL.  Marking this flag as
 #rue usually implies an ON DELETE <CASCADE|SET NULL> rule is in
 #lace which will handle updating/deleting child rows on the
 #atabase side.

 #dditionally, setting the flag to the string value 'all' will
 #isable the "nulling out" of the child foreign keys, when the parent
 #bject is deleted and there is no delete or delete-orphan cascade
 #nabled.  This is typically used when a triggering or error raise
 #cenario is in place on the database side.  Note that the foreign
 #ey attributes on in-session child objects will not be changed after
 # flush occurs so this is a very special use-case setting.
 #dditionally, the "nulling out" will still occur if the child
 #bject is de-associated with the parent.

 #. seealso::

 #ref:`passive_deletes` - Introductory documentation
 #nd examples.

 #param passive_updates=True:
 #ndicates the persistence behavior to take when a referenced
 #rimary key value changes in place, indicating that the referencing
 #oreign key columns will also need their value changed.

 #hen True, it is assumed that ``ON UPDATE CASCADE`` is configured on
 #he foreign key in the database, and that the database will
 #andle propagation of an UPDATE from a source column to
 #ependent rows.  When False, the SQLAlchemy
 #func:`_orm.relationship`
 #onstruct will attempt to emit its own UPDATE statements to
 #odify related targets.  However note that SQLAlchemy **cannot**
 #mit an UPDATE for more than one level of cascade.  Also,
 #etting this flag to False is not compatible in the case where
 #he database is in fact enforcing referential integrity, unless
 #hose constraints are explicitly "deferred", if the target backend
 #upports it.

 #t is highly advised that an application which is employing
 #utable primary keys keeps ``passive_updates`` set to True,
 #nd instead uses the referential integrity features of the database
 #tself in order to handle the change efficiently and fully.

 #. seealso::

 #ref:`passive_updates` - Introductory documentation and
 #xamples.

 #paramref:`.mapper.passive_updates` - a similar flag which
 #akes effect for joined-table inheritance mappings.

 #param post_update:
 #his indicates that the relationship should be handled by a
 #econd UPDATE statement after an INSERT or before a
 #ELETE. Currently, it also will issue an UPDATE after the
 #nstance was UPDATEd as well, although this technically should
 #e improved. This flag is used to handle saving bi-directional
 #ependencies between two individual rows (i.e. each row
 #eferences the other), where it would otherwise be impossible to
 #NSERT or DELETE both rows fully since one row exists before the
 #ther. Use this flag when a particular mapping arrangement will
 #ncur two rows that are dependent on each other, such as a table
 #hat has a one-to-many relationship to a set of child rows, and
 #lso has a column that references a single child row within that
 #ist (i.e. both tables contain a foreign key to each other). If
 # flush operation returns an error that a "cyclical
 #ependency" was detected, this is a cue that you might want to
 #se :paramref:`_orm.relationship.post_update` to "break" the cycle.

 #. seealso::

 #ref:`post_update` - Introductory documentation and examples.

 #param primaryjoin:
 # SQL expression that will be used as the primary
 #oin of the child object against the parent object, or in a
 #any-to-many relationship the join of the parent object to the
 #ssociation table. By default, this value is computed based on the
 #oreign key relationships of the parent and child tables (or
 #ssociation table).

 #paramref:`_orm.relationship.primaryjoin` may also be passed as a
 #allable function which is evaluated at mapper initialization time,
 #nd may be passed as a Python-evaluable string when using
 #eclarative.

 #. warning:: When passed as a Python-evaluable string, the
 #rgument is interpreted using Python's ``eval()`` function.
 #*DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
 #ee :ref:`declarative_relationship_eval` for details on
 #eclarative evaluation of :func:`_orm.relationship` arguments.

 #. seealso::

 #ref:`relationship_primaryjoin`

 #param remote_side:
 #sed for self-referential relationships, indicates the column or
 #ist of columns that form the "remote side" of the relationship.

 #paramref:`_orm.relationship.remote_side` may also be passed as a
 #allable function which is evaluated at mapper initialization time,
 #nd may be passed as a Python-evaluable string when using
 #eclarative.

 #. warning:: When passed as a Python-evaluable string, the
 #rgument is interpreted using Python's ``eval()`` function.
 #*DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
 #ee :ref:`declarative_relationship_eval` for details on
 #eclarative evaluation of :func:`_orm.relationship` arguments.

 #. seealso::

 #ref:`self_referential` - in-depth explanation of how
 #paramref:`_orm.relationship.remote_side`
 #s used to configure self-referential relationships.

 #func:`.remote` - an annotation function that accomplishes the
 #ame purpose as :paramref:`_orm.relationship.remote_side`,
 #ypically
 #hen a custom :paramref:`_orm.relationship.primaryjoin` condition
 #s used.

 #param query_class:
 # :class:`_query.Query`
 #ubclass that will be used internally by the
 #`AppenderQuery`` returned by a "dynamic" relationship, that
 #s, a relationship that specifies ``lazy="dynamic"`` or was
 #therwise constructed using the :func:`_orm.dynamic_loader`
 #unction.

 #. seealso::

 #ref:`dynamic_relationship` - Introduction to "dynamic"
 #elationship loaders.

 #param secondaryjoin:
 # SQL expression that will be used as the join of
 #n association table to the child object. By default, this value is
 #omputed based on the foreign key relationships of the association
 #nd child tables.

 #paramref:`_orm.relationship.secondaryjoin` may also be passed as a
 #allable function which is evaluated at mapper initialization time,
 #nd may be passed as a Python-evaluable string when using
 #eclarative.

 #. warning:: When passed as a Python-evaluable string, the
 #rgument is interpreted using Python's ``eval()`` function.
 #*DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
 #ee :ref:`declarative_relationship_eval` for details on
 #eclarative evaluation of :func:`_orm.relationship` arguments.

 #. seealso::

 #ref:`relationship_primaryjoin`

 #param single_parent:
 #hen True, installs a validator which will prevent objects
 #rom being associated with more than one parent at a time.
 #his is used for many-to-one or many-to-many relationships that
 #hould be treated either as one-to-one or one-to-many.  Its usage
 #s optional, except for :func:`_orm.relationship` constructs which
 #re many-to-one or many-to-many and also
 #pecify the ``delete-orphan`` cascade option.  The
 #func:`_orm.relationship` construct itself will raise an error
 #nstructing when this option is required.

 #. seealso::

 #ref:`unitofwork_cascades` - includes detail on when the
 #paramref:`_orm.relationship.single_parent`
 #lag may be appropriate.

 #param uselist:
 # boolean that indicates if this property should be loaded as a
 #ist or a scalar. In most cases, this value is determined
 #utomatically by :func:`_orm.relationship` at mapper configuration
 #ime, based on the type and direction
 #f the relationship - one to many forms a list, many to one
 #orms a scalar, many to many is a list. If a scalar is desired
 #here normally a list would be present, such as a bi-directional
 #ne-to-one relationship, set :paramref:`_orm.relationship.uselist`
 #o
 #alse.

 #he :paramref:`_orm.relationship.uselist`
 #lag is also available on an
 #xisting :func:`_orm.relationship`
 #onstruct as a read-only attribute,
 #hich can be used to determine if this :func:`_orm.relationship`
 #eals
 #ith collections or scalar attributes::

 #>> User.addresses.property.uselist
 #rue

 #. seealso::

 #ref:`relationships_one_to_one` - Introduction to the "one to
 #ne" relationship pattern, which is typically when the
 #paramref:`_orm.relationship.uselist` flag is needed.

 #param viewonly=False:
 #hen set to ``True``, the relationship is used only for loading
 #bjects, and not for any persistence operation.  A
 #func:`_orm.relationship` which specifies
 #paramref:`_orm.relationship.viewonly` can work
 #ith a wider range of SQL operations within the
 #paramref:`_orm.relationship.primaryjoin` condition, including
 #perations that feature the use of a variety of comparison operators
 #s well as SQL functions such as :func:`_expression.cast`.  The
 #paramref:`_orm.relationship.viewonly`
 #lag is also of general use when defining any kind of
 #func:`_orm.relationship` that doesn't represent
 #he full set of related objects, to prevent modifications of the
 #ollection from resulting in persistence operations.

 #hen using the :paramref:`_orm.relationship.viewonly` flag in
 #onjunction with backrefs, the originating relationship for a
 #articular state change will not produce state changes within the
 #iewonly relationship.   This is the behavior implied by
 #paramref:`_orm.relationship.sync_backref` being set to False.

 #. versionchanged:: 1.3.17 - the
 #paramref:`_orm.relationship.sync_backref` flag is set to False
 #hen using viewonly in conjunction with backrefs.

 #. seealso::

 #paramref:`_orm.relationship.sync_backref`

 #param sync_backref:
 # boolean that enables the events used to synchronize the in-Python
 #ttributes when this relationship is target of either
 #paramref:`_orm.relationship.backref` or
 #paramref:`_orm.relationship.back_populates`.

 #efaults to ``None``, which indicates that an automatic value should
 #e selected based on the value of the
 #paramref:`_orm.relationship.viewonly` flag.  When left at its
 #efault, changes in state will be back-populated only if neither
 #ides of a relationship is viewonly.

 #. versionadded:: 1.3.17

 #. versionchanged:: 1.4 - A relationship that specifies
 #paramref:`_orm.relationship.viewonly` automatically implies
 #hat :paramref:`_orm.relationship.sync_backref` is ``False``.

 #. seealso::

 #paramref:`_orm.relationship.viewonly`

 #param omit_join:
 #llows manual control over the "selectin" automatic join
 #ptimization.  Set to ``False`` to disable the "omit join" feature
 #dded in SQLAlchemy 1.3; or leave as ``None`` to leave automatic
 #ptimization in place.

 #. note:: This flag may only be set to ``False``.   It is not
 #ecessary to set it to ``True`` as the "omit_join" optimization is
 #utomatically detected; if it is not detected, then the
 #ptimization is not supported.

 #. versionchanged:: 1.3.11  setting ``omit_join`` to True will now
 #mit a warning as this was not the intended use of this flag.

 #. versionadded:: 1.3


 #""
 #uper(RelationshipProperty, self).__init__()

 #elf.uselist = uselist
 #elf.argument = argument
 #elf.secondary = secondary
 #elf.primaryjoin = primaryjoin
 #elf.secondaryjoin = secondaryjoin
 #elf.post_update = post_update
 #elf.direction = None
 #elf.viewonly = viewonly
 #f viewonly:
 #elf._warn_for_persistence_only_flags(
 #assive_deletes=passive_deletes,
 #assive_updates=passive_updates,
 #nable_typechecks=enable_typechecks,
 #ctive_history=active_history,
 #ascade_backrefs=cascade_backrefs,
 #
 #f viewonly and sync_backref:
 #aise sa_exc.ArgumentError(
 #sync_backref and viewonly cannot both be True"
 #
 #elf.sync_backref = sync_backref
 #elf.lazy = lazy
 #elf.single_parent = single_parent
 #elf._user_defined_foreign_keys = foreign_keys
 #elf.collection_class = collection_class
 #elf.passive_deletes = passive_deletes
 #elf.cascade_backrefs = cascade_backrefs
 #elf.passive_updates = passive_updates
 #elf.remote_side = remote_side
 #elf.enable_typechecks = enable_typechecks
 #elf.query_class = query_class
 #elf.innerjoin = innerjoin
 #elf.distinct_target_key = distinct_target_key
 #elf.doc = doc
 #elf.active_history = active_history
 #elf._legacy_inactive_history_style = _legacy_inactive_history_style

 #elf.join_depth = join_depth
 #f omit_join:
 #til.warn(
 #setting omit_join to True is not supported; selectin "
 #loading of this relationship may not work correctly if this "
 #flag is set explicitly.  omit_join optimization is "
 #automatically detected for conditions under which it is "
 #supported."
 #

 #elf.omit_join = omit_join
 #elf.local_remote_pairs = _local_remote_pairs
 #elf.bake_queries = bake_queries
 #elf.load_on_pending = load_on_pending
 #elf.comparator_factory = (
 #omparator_factory or RelationshipProperty.Comparator
 #
 #elf.comparator = self.comparator_factory(self, None)
 #til.set_creation_order(self)

 #f info is not None:
 #elf.info = info

 #elf.strategy_key = (("lazy", self.lazy),)

 #elf._reverse_property = set()
 #f overlaps:
 #elf._overlaps = set(re.split(r"\s*,\s*", overlaps))
 #lse:
 #elf._overlaps = ()

 #f cascade is not False:
 #elf.cascade = cascade
 #lif self.viewonly:
 #elf.cascade = "none"
 #lse:
 #elf.cascade = "save-update, merge"

 #elf.order_by = order_by

 #elf.back_populates = back_populates

 #f self.back_populates:
 #f backref:
 #aise sa_exc.ArgumentError(
 #backref and back_populates keyword arguments "
 #are mutually exclusive"
 #
 #elf.backref = None
 #lse:
 #elf.backref = backref

 #ef _warn_for_persistence_only_flags(self, **kw):
 #or k, v in kw.items():
 #f v != self._persistence_only[k]:
                # we are warning here rather than warn deprecated as this is a
                # configuration mistake, and Python shows regular warnings more
                # aggressively than deprecation warnings by default. Unlike the
                # case of setting viewonly with cascade, the settings being
                # warned about here are not actively doing the wrong thing
                # against viewonly=True, so it is not as urgent to have these
                # raise an error.
 #til.warn(
 #Setting %s on relationship() while also "
 #setting viewonly=True does not make sense, as a "
 #viewonly=True relationship does not perform persistence "
 #operations. This configuration may raise an error "
 #in a future release." % (k,)
 #

 #ef instrument_class(self, mapper):
 #ttributes.register_descriptor(
 #apper.class_,
 #elf.key,
 #omparator=self.comparator_factory(self, mapper),
 #arententity=mapper,
 #oc=self.doc,
 #

 #lass Comparator(PropComparator):
 #""Produce boolean, comparison, and other operators for
 #class:`.RelationshipProperty` attributes.

 #ee the documentation for :class:`.PropComparator` for a brief
 #verview of ORM level operator definition.

 #. seealso::

 #class:`.PropComparator`

 #class:`.ColumnProperty.Comparator`

 #class:`.ColumnOperators`

 #ref:`types_operators`

 #attr:`.TypeEngine.comparator_factory`

 #""

 #of_type = None
 #extra_criteria = ()

 #ef __init__(
 #elf,
 #rop,
 #arentmapper,
 #dapt_to_entity=None,
 #f_type=None,
 #xtra_criteria=(),
 #:
 #""Construction of :class:`.RelationshipProperty.Comparator`
 #s internal to the ORM's attribute mechanics.

 #""
 #elf.prop = prop
 #elf._parententity = parentmapper
 #elf._adapt_to_entity = adapt_to_entity
 #f of_type:
 #elf._of_type = of_type
 #elf._extra_criteria = extra_criteria

 #ef adapt_to_entity(self, adapt_to_entity):
 #eturn self.__class__(
 #elf.property,
 #elf._parententity,
 #dapt_to_entity=adapt_to_entity,
 #f_type=self._of_type,
 #

 #util.memoized_property
 #ef entity(self):
 #""The target entity referred to by this
 #class:`.RelationshipProperty.Comparator`.

 #his is either a :class:`_orm.Mapper` or :class:`.AliasedInsp`
 #bject.

 #his is the "target" or "remote" side of the
 #func:`_orm.relationship`.

 #""
 #eturn self.property.entity

 #util.memoized_property
 #ef mapper(self):
 #""The target :class:`_orm.Mapper` referred to by this
 #class:`.RelationshipProperty.Comparator`.

 #his is the "target" or "remote" side of the
 #func:`_orm.relationship`.

 #""
 #eturn self.property.mapper

 #util.memoized_property
 #ef _parententity(self):
 #eturn self.property.parent

 #ef _source_selectable(self):
 #f self._adapt_to_entity:
 #eturn self._adapt_to_entity.selectable
 #lse:
 #eturn self.property.parent._with_polymorphic_selectable

 #ef __clause_element__(self):
 #dapt_from = self._source_selectable()
 #f self._of_type:
 #f_type_entity = inspect(self._of_type)
 #lse:
 #f_type_entity = None

 #
 #j,
 #j,
 #ource,
 #est,
 #econdary,
 #arget_adapter,
 # = self.property._create_joins(
 #ource_selectable=adapt_from,
 #ource_polymorphic=True,
 #f_type_entity=of_type_entity,
 #lias_secondary=True,
 #xtra_criteria=self._extra_criteria,
 #
 #f sj is not None:
 #eturn pj & sj
 #lse:
 #eturn pj

 #ef of_type(self, cls):
 #"""Redefine this object in terms of a polymorphic subclass.

 #ee :meth:`.PropComparator.of_type` for an example.


 #""
 #eturn RelationshipProperty.Comparator(
 #elf.property,
 #elf._parententity,
 #dapt_to_entity=self._adapt_to_entity,
 #f_type=cls,
 #xtra_criteria=self._extra_criteria,
 #

 #ef and_(self, *other):
 #""Add AND criteria.

 #ee :meth:`.PropComparator.and_` for an example.

 #. versionadded:: 1.4

 #""
 #eturn RelationshipProperty.Comparator(
 #elf.property,
 #elf._parententity,
 #dapt_to_entity=self._adapt_to_entity,
 #f_type=self._of_type,
 #xtra_criteria=self._extra_criteria + other,
 #

 #ef in_(self, other):
 #""Produce an IN clause - this is not implemented
 #or :func:`_orm.relationship`-based attributes at this time.

 #""
 #aise NotImplementedError(
 #in_() not yet supported for "
 #relationships.  For a simple "
 #many-to-one, use in_() against "
 #the set of foreign key values."
 #

 #_hash__ = None

 #ef __eq__(self, other):
 #""Implement the ``==`` operator.

 #n a many-to-one context, such as::

 #yClass.some_prop == <some object>

 #his will typically produce a
 #lause such as::

 #ytable.related_id == <some id>

 #here ``<some id>`` is the primary key of the given
 #bject.

 #he ``==`` operator provides partial functionality for non-
 #any-to-one comparisons:

 # Comparisons against collections are not supported.
 #se :meth:`~.RelationshipProperty.Comparator.contains`.
 # Compared to a scalar one-to-many, will produce a
 #lause that compares the target columns in the parent to
 #he given target.
 # Compared to a scalar many-to-many, an alias
 #f the association table will be rendered as
 #ell, forming a natural join that is part of the
 #ain body of the query. This will not work for
 #ueries that go beyond simple AND conjunctions of
 #omparisons, such as those which use OR. Use
 #xplicit joins, outerjoins, or
 #meth:`~.RelationshipProperty.Comparator.has` for
 #ore comprehensive non-many-to-one scalar
 #embership tests.
 # Comparisons against ``None`` given in a one-to-many
 #r many-to-many context produce a NOT EXISTS clause.

 #""
 #f isinstance(other, (util.NoneType, expression.Null)):
 #f self.property.direction in [ONETOMANY, MANYTOMANY]:
 #eturn ~self._criterion_exists()
 #lse:
 #eturn _orm_annotate(
 #elf.property._optimized_compare(
 #one, adapt_source=self.adapter
 #
 #
 #lif self.property.uselist:
 #aise sa_exc.InvalidRequestError(
 #Can't compare a collection to an object or collection; "
 #use contains() to test for membership."
 #
 #lse:
 #eturn _orm_annotate(
 #elf.property._optimized_compare(
 #ther, adapt_source=self.adapter
 #
 #

 #ef _criterion_exists(self, criterion=None, **kwargs):
 #f getattr(self, "_of_type", None):
 #nfo = inspect(self._of_type)
 #arget_mapper, to_selectable, is_aliased_class = (
 #nfo.mapper,
 #nfo.selectable,
 #nfo.is_aliased_class,
 #
 #f self.property._is_self_referential and not is_aliased_class:
 #o_selectable = to_selectable._anonymous_fromclause()

 #ingle_crit = target_mapper._single_table_criterion
 #f single_crit is not None:
 #f criterion is not None:
 #riterion = single_crit & criterion
 #lse:
 #riterion = single_crit
 #lse:
 #s_aliased_class = False
 #o_selectable = None

 #f self.adapter:
 #ource_selectable = self._source_selectable()
 #lse:
 #ource_selectable = None

 #
 #j,
 #j,
 #ource,
 #est,
 #econdary,
 #arget_adapter,
 # = self.property._create_joins(
 #est_selectable=to_selectable,
 #ource_selectable=source_selectable,
 #

 #or k in kwargs:
 #rit = getattr(self.property.mapper.class_, k) == kwargs[k]
 #f criterion is None:
 #riterion = crit
 #lse:
 #riterion = criterion & crit

            # annotate the *local* side of the join condition, in the case
            # of pj + sj this is the full primaryjoin, in the case of just
            # pj its the local side of the primaryjoin.
 #f sj is not None:
 # = _orm_annotate(pj) & sj
 #lse:
 # = _orm_annotate(pj, exclude=self.property.remote_side)

 #f (
 #riterion is not None
 #nd target_adapter
 #nd not is_aliased_class
 #:
                # limit this adapter to annotated only?
 #riterion = target_adapter.traverse(criterion)

            # only have the "joined left side" of what we
            # return be subject to Query adaption.  The right
            # side of it is used for an exists() subquery and
            # should not correlate or otherwise reach out
            # to anything in the enclosing query.
 #f criterion is not None:
 #riterion = criterion._annotate(
 #"no_replacement_traverse": True}
 #

 #rit = j & sql.True_._ifnone(criterion)

 #f secondary is not None:
 #x = (
 #ql.exists(1)
 #where(crit)
 #select_from(dest, secondary)
 #correlate_except(dest, secondary)
 #
 #lse:
 #x = (
 #ql.exists(1)
 #where(crit)
 #select_from(dest)
 #correlate_except(dest)
 #
 #eturn ex

 #ef any(self, criterion=None, **kwargs):
 #""Produce an expression that tests a collection against
 #articular criterion, using EXISTS.

 #n expression like::

 #ession.query(MyClass).filter(
 #yClass.somereference.any(SomeRelated.x==2)
 #


 #ill produce a query like::

 #ELECT * FROM my_table WHERE
 #XISTS (SELECT 1 FROM related WHERE related.my_id=my_table.id
 #ND related.x=2)

 #ecause :meth:`~.RelationshipProperty.Comparator.any` uses
 # correlated subquery, its performance is not nearly as
 #ood when compared against large target tables as that of
 #sing a join.

 #meth:`~.RelationshipProperty.Comparator.any` is particularly
 #seful for testing for empty collections::

 #ession.query(MyClass).filter(
 #MyClass.somereference.any()
 #

 #ill produce::

 #ELECT * FROM my_table WHERE
 #OT (EXISTS (SELECT 1 FROM related WHERE
 #elated.my_id=my_table.id))

 #meth:`~.RelationshipProperty.Comparator.any` is only
 #alid for collections, i.e. a :func:`_orm.relationship`
 #hat has ``uselist=True``.  For scalar references,
 #se :meth:`~.RelationshipProperty.Comparator.has`.

 #""
 #f not self.property.uselist:
 #aise sa_exc.InvalidRequestError(
 #'any()' not implemented for scalar "
 #attributes. Use has()."
 #

 #eturn self._criterion_exists(criterion, **kwargs)

 #ef has(self, criterion=None, **kwargs):
 #""Produce an expression that tests a scalar reference against
 #articular criterion, using EXISTS.

 #n expression like::

 #ession.query(MyClass).filter(
 #yClass.somereference.has(SomeRelated.x==2)
 #


 #ill produce a query like::

 #ELECT * FROM my_table WHERE
 #XISTS (SELECT 1 FROM related WHERE
 #elated.id==my_table.related_id AND related.x=2)

 #ecause :meth:`~.RelationshipProperty.Comparator.has` uses
 # correlated subquery, its performance is not nearly as
 #ood when compared against large target tables as that of
 #sing a join.

 #meth:`~.RelationshipProperty.Comparator.has` is only
 #alid for scalar references, i.e. a :func:`_orm.relationship`
 #hat has ``uselist=False``.  For collection references,
 #se :meth:`~.RelationshipProperty.Comparator.any`.

 #""
 #f self.property.uselist:
 #aise sa_exc.InvalidRequestError(
 #'has()' not implemented for collections.  " "Use any()."
 #
 #eturn self._criterion_exists(criterion, **kwargs)

 #ef contains(self, other, **kwargs):
 #""Return a simple expression that tests a collection for
 #ontainment of a particular item.

 #meth:`~.RelationshipProperty.Comparator.contains` is
 #nly valid for a collection, i.e. a
 #func:`_orm.relationship` that implements
 #ne-to-many or many-to-many with ``uselist=True``.

 #hen used in a simple one-to-many context, an
 #xpression like::

 #yClass.contains(other)

 #roduces a clause like::

 #ytable.id == <some id>

 #here ``<some id>`` is the value of the foreign key
 #ttribute on ``other`` which refers to the primary
 #ey of its parent object. From this it follows that
 #meth:`~.RelationshipProperty.Comparator.contains` is
 #ery useful when used with simple one-to-many
 #perations.

 #or many-to-many operations, the behavior of
 #meth:`~.RelationshipProperty.Comparator.contains`
 #as more caveats. The association table will be
 #endered in the statement, producing an "implicit"
 #oin, that is, includes multiple tables in the FROM
 #lause which are equated in the WHERE clause::

 #uery(MyClass).filter(MyClass.contains(other))

 #roduces a query like::

 #ELECT * FROM my_table, my_association_table AS
 #y_association_table_1 WHERE
 #y_table.id = my_association_table_1.parent_id
 #ND my_association_table_1.child_id = <some id>

 #here ``<some id>`` would be the primary key of
 #`other``. From the above, it is clear that
 #meth:`~.RelationshipProperty.Comparator.contains`
 #ill **not** work with many-to-many collections when
 #sed in queries that move beyond simple AND
 #onjunctions, such as multiple
 #meth:`~.RelationshipProperty.Comparator.contains`
 #xpressions joined by OR. In such cases subqueries or
 #xplicit "outer joins" will need to be used instead.
 #ee :meth:`~.RelationshipProperty.Comparator.any` for
 # less-performant alternative using EXISTS, or refer
 #o :meth:`_query.Query.outerjoin`
 #s well as :ref:`ormtutorial_joins`
 #or more details on constructing outer joins.

 #""
 #f not self.property.uselist:
 #aise sa_exc.InvalidRequestError(
 #'contains' not implemented for scalar "
 #attributes.  Use =="
 #
 #lause = self.property._optimized_compare(
 #ther, adapt_source=self.adapter
 #

 #f self.property.secondaryjoin is not None:
 #lause.negation_clause = self.__negated_contains_or_equals(
 #ther
 #

 #eturn clause

 #ef __negated_contains_or_equals(self, other):
 #f self.property.direction == MANYTOONE:
 #tate = attributes.instance_state(other)

 #ef state_bindparam(local_col, state, remote_col):
 #ict_ = state.dict
 #eturn sql.bindparam(
 #ocal_col.key,
 #ype_=local_col.type,
 #nique=True,
 #allable_=self.property._get_attr_w_warn_on_none(
 #elf.property.mapper, state, dict_, remote_col
 #,
 #

 #ef adapt(col):
 #f self.adapter:
 #eturn self.adapter(col)
 #lse:
 #eturn col

 #f self.property._use_get:
 #eturn sql.and_(
 #[
 #ql.or_(
 #dapt(x)
 #= state_bindparam(adapt(x), state, y),
 #dapt(x) == None,
 #
 #or (x, y) in self.property.local_remote_pairs
 #
 #

 #riterion = sql.and_(
 #[
 # == y
 #or (x, y) in zip(
 #elf.property.mapper.primary_key,
 #elf.property.mapper.primary_key_from_instance(other),
 #
 #
 #

 #eturn ~self._criterion_exists(criterion)

 #ef __ne__(self, other):
 #""Implement the ``!=`` operator.

 #n a many-to-one context, such as::

 #yClass.some_prop != <some object>

 #his will typically produce a clause such as::

 #ytable.related_id != <some id>

 #here ``<some id>`` is the primary key of the
 #iven object.

 #he ``!=`` operator provides partial functionality for non-
 #any-to-one comparisons:

 # Comparisons against collections are not supported.
 #se
 #meth:`~.RelationshipProperty.Comparator.contains`
 #n conjunction with :func:`_expression.not_`.
 # Compared to a scalar one-to-many, will produce a
 #lause that compares the target columns in the parent to
 #he given target.
 # Compared to a scalar many-to-many, an alias
 #f the association table will be rendered as
 #ell, forming a natural join that is part of the
 #ain body of the query. This will not work for
 #ueries that go beyond simple AND conjunctions of
 #omparisons, such as those which use OR. Use
 #xplicit joins, outerjoins, or
 #meth:`~.RelationshipProperty.Comparator.has` in
 #onjunction with :func:`_expression.not_` for
 #ore comprehensive non-many-to-one scalar
 #embership tests.
 # Comparisons against ``None`` given in a one-to-many
 #r many-to-many context produce an EXISTS clause.

 #""
 #f isinstance(other, (util.NoneType, expression.Null)):
 #f self.property.direction == MANYTOONE:
 #eturn _orm_annotate(
 #self.property._optimized_compare(
 #one, adapt_source=self.adapter
 #
 #

 #lse:
 #eturn self._criterion_exists()
 #lif self.property.uselist:
 #aise sa_exc.InvalidRequestError(
 #Can't compare a collection"
 # to an object or collection; use "
 #contains() to test for membership."
 #
 #lse:
 #eturn _orm_annotate(self.__negated_contains_or_equals(other))

 #util.memoized_property
 #ef property(self):
 #elf.prop.parent._check_configure()
 #eturn self.prop

 #ef _with_parent(self, instance, alias_secondary=True, from_entity=None):
 #ssert instance is not None
 #dapt_source = None
 #f from_entity is not None:
 #nsp = inspect(from_entity)
 #f insp.is_aliased_class:
 #dapt_source = insp._adapter.adapt_clause
 #eturn self._optimized_compare(
 #nstance,
 #alue_is_parent=True,
 #dapt_source=adapt_source,
 #lias_secondary=alias_secondary,
 #

 #ef _optimized_compare(
 #elf,
 #tate,
 #alue_is_parent=False,
 #dapt_source=None,
 #lias_secondary=True,
 #:
 #f state is not None:
 #ry:
 #tate = inspect(state)
 #xcept sa_exc.NoInspectionAvailable:
 #tate = None

 #f state is None or not getattr(state, "is_instance", False):
 #aise sa_exc.ArgumentError(
 #Mapped instance expected for relationship "
 #comparison to object.   Classes, queries and other "
 #SQL elements are not accepted in this context; for "
 #comparison with a subquery, "
 #use %s.has(**criteria)." % self
 #
 #everse_direction = not value_is_parent

 #f state is None:
 #eturn self._lazy_none_clause(
 #everse_direction, adapt_source=adapt_source
 #

 #f not reverse_direction:
 #riterion, bind_to_col = (
 #elf._lazy_strategy._lazywhere,
 #elf._lazy_strategy._bind_to_col,
 #
 #lse:
 #riterion, bind_to_col = (
 #elf._lazy_strategy._rev_lazywhere,
 #elf._lazy_strategy._rev_bind_to_col,
 #

 #f reverse_direction:
 #apper = self.mapper
 #lse:
 #apper = self.parent

 #ict_ = attributes.instance_dict(state.obj())

 #ef visit_bindparam(bindparam):
 #f bindparam._identifying_key in bind_to_col:
 #indparam.callable = self._get_attr_w_warn_on_none(
 #apper,
 #tate,
 #ict_,
 #ind_to_col[bindparam._identifying_key],
 #

 #f self.secondary is not None and alias_secondary:
 #riterion = ClauseAdapter(
 #elf.secondary._anonymous_fromclause()
 #.traverse(criterion)

 #riterion = visitors.cloned_traverse(
 #riterion, {}, {"bindparam": visit_bindparam}
 #

 #f adapt_source:
 #riterion = adapt_source(criterion)
 #eturn criterion

 #ef _get_attr_w_warn_on_none(self, mapper, state, dict_, column):
 #""Create the callable that is used in a many-to-one expression.

 #.g.::

 #1 = s.query(User).get(5)

 #xpr = Address.user == u1

 #bove, the SQL should be "address.user_id = 5". The callable
 #eturned by this method produces the value "5" based on the identity
 #f ``u1``.

 #""

        # in this callable, we're trying to thread the needle through
        # a wide variety of scenarios, including:
        #
        # * the object hasn't been flushed yet and there's no value for
        #   the attribute as of yet
        #
        # * the object hasn't been flushed yet but it has a user-defined
        #   value
        #
        # * the object has a value but it's expired and not locally present
        #
        # * the object has a value but it's expired and not locally present,
        #   and the object is also detached
        #
        # * The object hadn't been flushed yet, there was no value, but
        #   later, the object has been expired and detached, and *now*
        #   they're trying to evaluate it
        #
        # * the object had a value, but it was changed to a new value, and
        #   then expired
        #
        # * the object had a value, but it was changed to a new value, and
        #   then expired, then the object was detached
        #
        # * the object has a user-set value, but it's None and we don't do
        #   the comparison correctly for that so warn
        #

 #rop = mapper.get_property_by_column(column)

        # by invoking this method, InstanceState will track the last known
        # value for this key each time the attribute is to be expired.
        # this feature was added explicitly for use in this method.
 #tate._track_last_known_value(prop.key)

 #ef _go():
 #ast_known = to_return = state._last_known_values[prop.key]
 #xisting_is_available = last_known is not attributes.NO_VALUE

            # we support that the value may have changed.  so here we
            # try to get the most recent value including re-fetching.
            # only if we can't get a value now due to detachment do we return
            # the last known value
 #urrent_value = mapper._get_state_attr_by_column(
 #tate,
 #ict_,
 #olumn,
 #assive=attributes.PASSIVE_OFF
 #f state.persistent
 #lse attributes.PASSIVE_NO_FETCH ^ attributes.INIT_OK,
 #

 #f current_value is attributes.NEVER_SET:
 #f not existing_is_available:
 #aise sa_exc.InvalidRequestError(
 #Can't resolve value for column %s on object "
 #%s; no value has been set for this column"
 # (column, state_str(state))
 #
 #lif current_value is attributes.PASSIVE_NO_RESULT:
 #f not existing_is_available:
 #aise sa_exc.InvalidRequestError(
 #Can't resolve value for column %s on object "
 #%s; the object is detached and the value was "
 #expired" % (column, state_str(state))
 #
 #lse:
 #o_return = current_value
 #f to_return is None:
 #til.warn(
 #Got None for value of column %s; this is unsupported "
 #for a relationship comparison and will not "
 #currently produce an IS comparison "
 #(but may in a future release)" % column
 #
 #eturn to_return

 #eturn _go

 #ef _lazy_none_clause(self, reverse_direction=False, adapt_source=None):
 #f not reverse_direction:
 #riterion, bind_to_col = (
 #elf._lazy_strategy._lazywhere,
 #elf._lazy_strategy._bind_to_col,
 #
 #lse:
 #riterion, bind_to_col = (
 #elf._lazy_strategy._rev_lazywhere,
 #elf._lazy_strategy._rev_bind_to_col,
 #

 #riterion = adapt_criterion_to_null(criterion, bind_to_col)

 #f adapt_source:
 #riterion = adapt_source(criterion)
 #eturn criterion

 #ef __str__(self):
 #eturn str(self.parent.class_.__name__) + "." + self.key

 #ef merge(
 #elf,
 #ession,
 #ource_state,
 #ource_dict,
 #est_state,
 #est_dict,
 #oad,
 #recursive,
 #resolve_conflict_map,
 #:

 #f load:
 #or r in self._reverse_property:
 #f (source_state, r) in _recursive:
 #eturn

 #f "merge" not in self._cascade:
 #eturn

 #f self.key not in source_dict:
 #eturn

 #f self.uselist:
 #mpl = source_state.get_impl(self.key)
 #nstances_iterable = impl.get_collection(source_state, source_dict)

            # if this is a CollectionAttributeImpl, then empty should
            # be False, otherwise "self.key in source_dict" should not be
            # True
 #ssert not instances_iterable.empty if impl.collection else True

 #f load:
                # for a full merge, pre-load the destination collection,
                # so that individual _merge of each item pulls from identity
                # map for those already present.
                # also assumes CollectionAttributeImpl behavior of loading
                # "old" list in any case
 #est_state.get_impl(self.key).get(dest_state, dest_dict)

 #est_list = []
 #or current in instances_iterable:
 #urrent_state = attributes.instance_state(current)
 #urrent_dict = attributes.instance_dict(current)
 #recursive[(current_state, self)] = True
 #bj = session._merge(
 #urrent_state,
 #urrent_dict,
 #oad=load,
 #recursive=_recursive,
 #resolve_conflict_map=_resolve_conflict_map,
 #
 #f obj is not None:
 #est_list.append(obj)

 #f not load:
 #oll = attributes.init_state_collection(
 #est_state, dest_dict, self.key
 #
 #or c in dest_list:
 #oll.append_without_event(c)
 #lse:
 #est_state.get_impl(self.key).set(
 #est_state, dest_dict, dest_list, _adapt=False
 #
 #lse:
 #urrent = source_dict[self.key]
 #f current is not None:
 #urrent_state = attributes.instance_state(current)
 #urrent_dict = attributes.instance_dict(current)
 #recursive[(current_state, self)] = True
 #bj = session._merge(
 #urrent_state,
 #urrent_dict,
 #oad=load,
 #recursive=_recursive,
 #resolve_conflict_map=_resolve_conflict_map,
 #
 #lse:
 #bj = None

 #f not load:
 #est_dict[self.key] = obj
 #lse:
 #est_state.get_impl(self.key).set(
 #est_state, dest_dict, obj, None
 #

 #ef _value_as_iterable(
 #elf, state, dict_, key, passive=attributes.PASSIVE_OFF
 #:
 #""Return a list of tuples (state, obj) for the given
 #ey.

 #eturns an empty list if the value is None/empty/PASSIVE_NO_RESULT
 #""

 #mpl = state.manager[key].impl
 # = impl.get(state, dict_, passive=passive)
 #f x is attributes.PASSIVE_NO_RESULT or x is None:
 #eturn []
 #lif hasattr(impl, "get_collection"):
 #eturn [
 #attributes.instance_state(o), o)
 #or o in impl.get_collection(state, dict_, x, passive=passive)
 #
 #lse:
 #eturn [(attributes.instance_state(x), x)]

 #ef cascade_iterator(
 #elf, type_, state, dict_, visited_states, halt_on=None
 #:
        # assert type_ in self._cascade

        # only actively lazy load on the 'delete' cascade
 #f type_ != "delete" or self.passive_deletes:
 #assive = attributes.PASSIVE_NO_INITIALIZE
 #lse:
 #assive = attributes.PASSIVE_OFF

 #f type_ == "save-update":
 #uples = state.manager[self.key].impl.get_all_pending(state, dict_)

 #lse:
 #uples = self._value_as_iterable(
 #tate, dict_, self.key, passive=passive
 #

 #kip_pending = (
 #ype_ == "refresh-expire" and "delete-orphan" not in self._cascade
 #

 #or instance_state, c in tuples:
 #f instance_state in visited_states:
 #ontinue

 #f c is None:
                # would like to emit a warning here, but
                # would not be consistent with collection.append(None)
                # current behavior of silently skipping.
                # see [ticket:2229]
 #ontinue

 #nstance_dict = attributes.instance_dict(c)

 #f halt_on and halt_on(instance_state):
 #ontinue

 #f skip_pending and not instance_state.key:
 #ontinue

 #nstance_mapper = instance_state.manager.mapper

 #f not instance_mapper.isa(self.mapper.class_manager.mapper):
 #aise AssertionError(
 #Attribute '%s' on class '%s' "
 #doesn't handle objects "
 #of type '%s'"
 # (self.key, self.parent.class_, c.__class__)
 #

 #isited_states.add(instance_state)

 #ield c, instance_mapper, instance_state, instance_dict

 #property
 #ef _effective_sync_backref(self):
 #f self.viewonly:
 #eturn False
 #lse:
 #eturn self.sync_backref is not False

 #staticmethod
 #ef _check_sync_backref(rel_a, rel_b):
 #f rel_a.viewonly and rel_b.sync_backref:
 #aise sa_exc.InvalidRequestError(
 #Relationship %s cannot specify sync_backref=True since %s "
 #includes viewonly=True." % (rel_b, rel_a)
 #
 #f (
 #el_a.viewonly
 #nd not rel_b.viewonly
 #nd rel_b.sync_backref is not False
 #:
 #el_b.sync_backref = False

 #ef _add_reverse_property(self, key):
 #ther = self.mapper.get_property(key, _configure_mappers=False)
 #f not isinstance(other, RelationshipProperty):
 #aise sa_exc.InvalidRequestError(
 #back_populates on relationship '%s' refers to attribute '%s' "
 #that is not a relationship.  The back_populates parameter "
 #should refer to the name of a relationship on the target "
 #class." % (self, other)
 #
        # viewonly and sync_backref cases
        # 1. self.viewonly==True and other.sync_backref==True -> error
        # 2. self.viewonly==True and other.viewonly==False and
        #    other.sync_backref==None -> warn sync_backref=False, set to False
 #elf._check_sync_backref(self, other)
        # 3. other.viewonly==True and self.sync_backref==True -> error
        # 4. other.viewonly==True and self.viewonly==False and
        #    self.sync_backref==None -> warn sync_backref=False, set to False
 #elf._check_sync_backref(other, self)

 #elf._reverse_property.add(other)
 #ther._reverse_property.add(self)

 #f not other.mapper.common_parent(self.parent):
 #aise sa_exc.ArgumentError(
 #reverse_property %r on "
 #relationship %s references relationship %s, which "
 #does not reference mapper %s"
 # (key, self, other, self.parent)
 #

 #f (
 #elf.direction in (ONETOMANY, MANYTOONE)
 #nd self.direction == other.direction
 #:
 #aise sa_exc.ArgumentError(
 #%s and back-reference %s are "
 #both of the same direction %r.  Did you mean to "
 #set remote_side on the many-to-one side ?"
 # (other, self, self.direction)
 #

 #util.memoized_property
 #util.preload_module("sqlalchemy.orm.mapper")
 #ef entity(self):
 #""Return the target mapped entity, which is an inspect() of the
 #lass or aliased class that is referred towards.

 #""

 #apperlib = util.preloaded.orm_mapper

 #f isinstance(self.argument, util.string_types):
 #rgument = self._clsregistry_resolve_name(self.argument)()

 #lif callable(self.argument) and not isinstance(
 #elf.argument, (type, mapperlib.Mapper)
 #:
 #rgument = self.argument()
 #lse:
 #rgument = self.argument

 #f isinstance(argument, type):
 #eturn mapperlib.class_mapper(argument, configure=False)

 #ry:
 #ntity = inspect(argument)
 #xcept sa_exc.NoInspectionAvailable:
 #ass
 #lse:
 #f hasattr(entity, "mapper"):
 #eturn entity

 #aise sa_exc.ArgumentError(
 #relationship '%s' expects "
 #a class or a mapper argument (received: %s)"
 # (self.key, type(argument))
 #

 #util.memoized_property
 #ef mapper(self):
 #""Return the targeted :class:`_orm.Mapper` for this
 #class:`.RelationshipProperty`.

 #his is a lazy-initializing static attribute.

 #""
 #eturn self.entity.mapper

 #ef do_init(self):
 #elf._check_conflicts()
 #elf._process_dependent_arguments()
 #elf._setup_registry_dependencies()
 #elf._setup_join_conditions()
 #elf._check_cascade_settings(self._cascade)
 #elf._post_init()
 #elf._generate_backref()
 #elf._join_condition._warn_for_conflicting_sync_targets()
 #uper(RelationshipProperty, self).do_init()
 #elf._lazy_strategy = self._get_strategy((("lazy", "select"),))

 #ef _setup_registry_dependencies(self):
 #elf.parent.mapper.registry._set_depends_on(
 #elf.entity.mapper.registry
 #

 #ef _process_dependent_arguments(self):
 #""Convert incoming configuration arguments to their
 #roper form.

 #allables are resolved, ORM annotations removed.

 #""

        # accept callables for other attributes which may require
        # deferred initialization.  This technique is used
        # by declarative "string configs" and some recipes.
 #or attr in (
 #order_by",
 #primaryjoin",
 #secondaryjoin",
 #secondary",
 #_user_defined_foreign_keys",
 #remote_side",
 #:
 #ttr_value = getattr(self, attr)

 #f isinstance(attr_value, util.string_types):
 #etattr(
 #elf,
 #ttr,
 #elf._clsregistry_resolve_arg(
 #ttr_value, favor_tables=attr == "secondary"
 #(),
 #
 #lif callable(attr_value) and not _is_mapped_class(attr_value):
 #etattr(self, attr, attr_value())

        # remove "annotations" which are present if mapped class
        # descriptors are used to create the join expression.
 #or attr in "primaryjoin", "secondaryjoin":
 #al = getattr(self, attr)
 #f val is not None:
 #etattr(
 #elf,
 #ttr,
 #orm_deannotate(
 #oercions.expect(
 #oles.ColumnArgumentRole, val, argname=attr
 #
 #,
 #

 #f self.secondary is not None and _is_mapped_class(self.secondary):
 #aise sa_exc.ArgumentError(
 #secondary argument %s passed to to relationship() %s must "
 #be a Table object or other FROM clause; can't send a mapped "
 #class directly as rows in 'secondary' are persisted "
 #independently of a class that is mapped "
 #to that same table." % (self.secondary, self)
 #

        # ensure expressions in self.order_by, foreign_keys,
        # remote_side are all columns, not strings.
 #f self.order_by is not False and self.order_by is not None:
 #elf.order_by = tuple(
 #oercions.expect(
 #oles.ColumnArgumentRole, x, argname="order_by"
 #
 #or x in util.to_list(self.order_by)
 #

 #elf._user_defined_foreign_keys = util.column_set(
 #oercions.expect(
 #oles.ColumnArgumentRole, x, argname="foreign_keys"
 #
 #or x in util.to_column_set(self._user_defined_foreign_keys)
 #

 #elf.remote_side = util.column_set(
 #oercions.expect(
 #oles.ColumnArgumentRole, x, argname="remote_side"
 #
 #or x in util.to_column_set(self.remote_side)
 #

 #elf.target = self.entity.persist_selectable

 #ef _setup_join_conditions(self):
 #elf._join_condition = jc = JoinCondition(
 #arent_persist_selectable=self.parent.persist_selectable,
 #hild_persist_selectable=self.entity.persist_selectable,
 #arent_local_selectable=self.parent.local_table,
 #hild_local_selectable=self.entity.local_table,
 #rimaryjoin=self.primaryjoin,
 #econdary=self.secondary,
 #econdaryjoin=self.secondaryjoin,
 #arent_equivalents=self.parent._equivalent_columns,
 #hild_equivalents=self.mapper._equivalent_columns,
 #onsider_as_foreign_keys=self._user_defined_foreign_keys,
 #ocal_remote_pairs=self.local_remote_pairs,
 #emote_side=self.remote_side,
 #elf_referential=self._is_self_referential,
 #rop=self,
 #upport_sync=not self.viewonly,
 #an_be_synced_fn=self._columns_are_mapped,
 #
 #elf.primaryjoin = jc.primaryjoin
 #elf.secondaryjoin = jc.secondaryjoin
 #elf.direction = jc.direction
 #elf.local_remote_pairs = jc.local_remote_pairs
 #elf.remote_side = jc.remote_columns
 #elf.local_columns = jc.local_columns
 #elf.synchronize_pairs = jc.synchronize_pairs
 #elf._calculated_foreign_keys = jc.foreign_key_columns
 #elf.secondary_synchronize_pairs = jc.secondary_synchronize_pairs

 #property
 #ef _clsregistry_resolve_arg(self):
 #eturn self._clsregistry_resolvers[1]

 #property
 #ef _clsregistry_resolve_name(self):
 #eturn self._clsregistry_resolvers[0]

 #util.memoized_property
 #util.preload_module("sqlalchemy.orm.clsregistry")
 #ef _clsregistry_resolvers(self):
 #resolver = util.preloaded.orm_clsregistry._resolver

 #eturn _resolver(self.parent.class_, self)

 #util.preload_module("sqlalchemy.orm.mapper")
 #ef _check_conflicts(self):
 #""Test that this relationship is legal, warn about
 #nheritance conflicts."""
 #apperlib = util.preloaded.orm_mapper
 #f self.parent.non_primary and not mapperlib.class_mapper(
 #elf.parent.class_, configure=False
 #.has_property(self.key):
 #aise sa_exc.ArgumentError(
 #Attempting to assign a new "
 #relationship '%s' to a non-primary mapper on "
 #class '%s'.  New relationships can only be added "
 #to the primary mapper, i.e. the very first mapper "
 #created for class '%s' "
 # (
 #elf.key,
 #elf.parent.class_.__name__,
 #elf.parent.class_.__name__,
 #
 #

 #property
 #ef cascade(self):
 #""Return the current cascade setting for this
 #class:`.RelationshipProperty`.
 #""
 #eturn self._cascade

 #cascade.setter
 #ef cascade(self, cascade):
 #elf._set_cascade(cascade)

 #ef _set_cascade(self, cascade):
 #ascade = CascadeOptions(cascade)

 #f self.viewonly:
 #on_viewonly = set(cascade).difference(
 #ascadeOptions._viewonly_cascades
 #
 #f non_viewonly:
 #aise sa_exc.ArgumentError(
 #Cascade settings "%s" apply to persistence operations '
 #and should not be combined with a viewonly=True "
 #relationship." % (", ".join(sorted(non_viewonly)))
 #

 #f "mapper" in self.__dict__:
 #elf._check_cascade_settings(cascade)
 #elf._cascade = cascade

 #f self._dependency_processor:
 #elf._dependency_processor.cascade = cascade

 #ef _check_cascade_settings(self, cascade):
 #f (
 #ascade.delete_orphan
 #nd not self.single_parent
 #nd (self.direction is MANYTOMANY or self.direction is MANYTOONE)
 #:
 #aise sa_exc.ArgumentError(
 #For %(direction)s relationship %(rel)s, delete-orphan "
 #cascade is normally "
 #configured only on the "one" side of a one-to-many '
 #relationship, "
 #and not on the "many" side of a many-to-one or many-to-many '
 #relationship.  "
 #To force this relationship to allow a particular "
 #"%(relatedcls)s" object to be referred towards by only '
 #a single "%(clsname)s" object at a time via the '
 #%(rel)s relationship, which "
 #would allow "
 #delete-orphan cascade to take place in this direction, set "
 #the single_parent=True flag."
 # {
 #rel": self,
 #direction": "many-to-one"
 #f self.direction is MANYTOONE
 #lse "many-to-many",
 #clsname": self.parent.class_.__name__,
 #relatedcls": self.mapper.class_.__name__,
 #,
 #ode="bbf0",
 #

 #f self.passive_deletes == "all" and (
 #delete" in cascade or "delete-orphan" in cascade
 #:
 #aise sa_exc.ArgumentError(
 #On %s, can't set passive_deletes='all' in conjunction "
 #with 'delete' or 'delete-orphan' cascade" % self
 #

 #f cascade.delete_orphan:
 #elf.mapper.primary_mapper()._delete_orphans.append(
 #self.key, self.parent.class_)
 #

 #ef _persists_for(self, mapper):
 #""Return True if this property will persist values on behalf
 #f the given mapper.

 #""

 #eturn (
 #elf.key in mapper.relationships
 #nd mapper.relationships[self.key] is self
 #

 #ef _columns_are_mapped(self, *cols):
 #""Return True if all columns in the given collection are
 #apped by the tables referenced by this :class:`.Relationship`.

 #""
 #or c in cols:
 #f (
 #elf.secondary is not None
 #nd self.secondary.c.contains_column(c)
 #:
 #ontinue
 #f not self.parent.persist_selectable.c.contains_column(
 #
 # and not self.target.c.contains_column(c):
 #eturn False
 #eturn True

 #ef _generate_backref(self):
 #""Interpret the 'backref' instruction to create a
 #func:`_orm.relationship` complementary to this one."""

 #f self.parent.non_primary:
 #eturn
 #f self.backref is not None and not self.back_populates:
 #f isinstance(self.backref, util.string_types):
 #ackref_key, kwargs = self.backref, {}
 #lse:
 #ackref_key, kwargs = self.backref
 #apper = self.mapper.primary_mapper()

 #f not mapper.concrete:
 #heck = set(mapper.iterate_to_root()).union(
 #apper.self_and_descendants
 #
 #or m in check:
 #f m.has_property(backref_key) and not m.concrete:
 #aise sa_exc.ArgumentError(
 #Error creating backref "
 #'%s' on relationship '%s': property of that "
 #name exists on mapper '%s'"
 # (backref_key, self, m)
 #

            # determine primaryjoin/secondaryjoin for the
            # backref.  Use the one we had, so that
            # a custom join doesn't have to be specified in
            # both directions.
 #f self.secondary is not None:
                # for many to many, just switch primaryjoin/
                # secondaryjoin.   use the annotated
                # pj/sj on the _join_condition.
 #j = kwargs.pop(
 #primaryjoin",
 #elf._join_condition.secondaryjoin_minus_local,
 #
 #j = kwargs.pop(
 #secondaryjoin",
 #elf._join_condition.primaryjoin_minus_local,
 #
 #lse:
 #j = kwargs.pop(
 #primaryjoin",
 #elf._join_condition.primaryjoin_reverse_remote,
 #
 #j = kwargs.pop("secondaryjoin", None)
 #f sj:
 #aise sa_exc.InvalidRequestError(
 #Can't assign 'secondaryjoin' on a backref "
 #against a non-secondary relationship."
 #

 #oreign_keys = kwargs.pop(
 #foreign_keys", self._user_defined_foreign_keys
 #
 #arent = self.parent.primary_mapper()
 #wargs.setdefault("viewonly", self.viewonly)
 #wargs.setdefault("post_update", self.post_update)
 #wargs.setdefault("passive_updates", self.passive_updates)
 #wargs.setdefault("sync_backref", self.sync_backref)
 #elf.back_populates = backref_key
 #elationship = RelationshipProperty(
 #arent,
 #elf.secondary,
 #j,
 #j,
 #oreign_keys=foreign_keys,
 #ack_populates=self.key,
 #*kwargs
 #
 #apper._configure_property(backref_key, relationship)

 #f self.back_populates:
 #elf._add_reverse_property(self.back_populates)

 #util.preload_module("sqlalchemy.orm.dependency")
 #ef _post_init(self):
 #ependency = util.preloaded.orm_dependency

 #f self.uselist is None:
 #elf.uselist = self.direction is not MANYTOONE
 #f not self.viewonly:
 #elf._dependency_processor = (
 #ependency.DependencyProcessor.from_relationship
 #(self)

 #util.memoized_property
 #ef _use_get(self):
 #""memoize the 'use_get' attribute of this RelationshipLoader's
 #azyloader."""

 #trategy = self._lazy_strategy
 #eturn strategy.use_get

 #util.memoized_property
 #ef _is_self_referential(self):
 #eturn self.mapper.common_parent(self.parent)

 #ef _create_joins(
 #elf,
 #ource_polymorphic=False,
 #ource_selectable=None,
 #est_selectable=None,
 #f_type_entity=None,
 #lias_secondary=False,
 #xtra_criteria=(),
 #:

 #liased = False

 #f alias_secondary and self.secondary is not None:
 #liased = True

 #f source_selectable is None:
 #f source_polymorphic and self.parent.with_polymorphic:
 #ource_selectable = self.parent._with_polymorphic_selectable

 #f of_type_entity:
 #est_mapper = of_type_entity.mapper
 #f dest_selectable is None:
 #est_selectable = of_type_entity.selectable
 #liased = True
 #lse:
 #est_mapper = self.mapper

 #f dest_selectable is None:
 #est_selectable = self.entity.selectable
 #f self.mapper.with_polymorphic:
 #liased = True

 #f self._is_self_referential and source_selectable is None:
 #est_selectable = dest_selectable._anonymous_fromclause()
 #liased = True
 #lif (
 #est_selectable is not self.mapper._with_polymorphic_selectable
 #r self.mapper.with_polymorphic
 #:
 #liased = True

 #ingle_crit = dest_mapper._single_table_criterion
 #liased = aliased or (
 #ource_selectable is not None
 #nd (
 #ource_selectable
 #s not self.parent._with_polymorphic_selectable
 #r source_selectable._is_subquery
 #
 #

 #
 #rimaryjoin,
 #econdaryjoin,
 #econdary,
 #arget_adapter,
 #est_selectable,
 # = self._join_condition.join_targets(
 #ource_selectable,
 #est_selectable,
 #liased,
 #ingle_crit,
 #xtra_criteria,
 #
 #f source_selectable is None:
 #ource_selectable = self.parent.local_table
 #f dest_selectable is None:
 #est_selectable = self.entity.local_table
 #eturn (
 #rimaryjoin,
 #econdaryjoin,
 #ource_selectable,
 #est_selectable,
 #econdary,
 #arget_adapter,
 #


def _annotate_columns(element, annotations):
 #ef clone(elem):
 #f isinstance(elem, expression.ColumnClause):
 #lem = elem._annotate(annotations.copy())
 #lem._copy_internals(clone=clone)
 #eturn elem

 #f element is not None:
 #lement = clone(element)
 #lone = None  # remove gc cycles
 #eturn element


class JoinCondition(object):
 #ef __init__(
 #elf,
 #arent_persist_selectable,
 #hild_persist_selectable,
 #arent_local_selectable,
 #hild_local_selectable,
 #rimaryjoin=None,
 #econdary=None,
 #econdaryjoin=None,
 #arent_equivalents=None,
 #hild_equivalents=None,
 #onsider_as_foreign_keys=None,
 #ocal_remote_pairs=None,
 #emote_side=None,
 #elf_referential=False,
 #rop=None,
 #upport_sync=True,
 #an_be_synced_fn=lambda *c: True,
 #:
 #elf.parent_persist_selectable = parent_persist_selectable
 #elf.parent_local_selectable = parent_local_selectable
 #elf.child_persist_selectable = child_persist_selectable
 #elf.child_local_selectable = child_local_selectable
 #elf.parent_equivalents = parent_equivalents
 #elf.child_equivalents = child_equivalents
 #elf.primaryjoin = primaryjoin
 #elf.secondaryjoin = secondaryjoin
 #elf.secondary = secondary
 #elf.consider_as_foreign_keys = consider_as_foreign_keys
 #elf._local_remote_pairs = local_remote_pairs
 #elf._remote_side = remote_side
 #elf.prop = prop
 #elf.self_referential = self_referential
 #elf.support_sync = support_sync
 #elf.can_be_synced_fn = can_be_synced_fn
 #elf._determine_joins()
 #elf._sanitize_joins()
 #elf._annotate_fks()
 #elf._annotate_remote()
 #elf._annotate_local()
 #elf._annotate_parentmapper()
 #elf._setup_pairs()
 #elf._check_foreign_cols(self.primaryjoin, True)
 #f self.secondaryjoin is not None:
 #elf._check_foreign_cols(self.secondaryjoin, False)
 #elf._determine_direction()
 #elf._check_remote_side()
 #elf._log_joins()

 #ef _log_joins(self):
 #f self.prop is None:
 #eturn
 #og = self.prop.logger
 #og.info("%s setup primary join %s", self.prop, self.primaryjoin)
 #og.info("%s setup secondary join %s", self.prop, self.secondaryjoin)
 #og.info(
 #%s synchronize pairs [%s]",
 #elf.prop,
 #,".join(
 #(%s => %s)" % (l, r) for (l, r) in self.synchronize_pairs
 #,
 #
 #og.info(
 #%s secondary synchronize pairs [%s]",
 #elf.prop,
 #,".join(
 #(%s => %s)" % (l, r)
 #or (l, r) in self.secondary_synchronize_pairs or []
 #,
 #
 #og.info(
 #%s local/remote pairs [%s]",
 #elf.prop,
 #,".join(
 #(%s / %s)" % (l, r) for (l, r) in self.local_remote_pairs
 #,
 #
 #og.info(
 #%s remote columns [%s]",
 #elf.prop,
 #,".join("%s" % col for col in self.remote_columns),
 #
 #og.info(
 #%s local columns [%s]",
 #elf.prop,
 #,".join("%s" % col for col in self.local_columns),
 #
 #og.info("%s relationship direction %s", self.prop, self.direction)

 #ef _sanitize_joins(self):
 #""remove the parententity annotation from our join conditions which
 #an leak in here based on some declarative patterns and maybe others.

 #e'd want to remove "parentmapper" also, but apparently there's
 #n exotic use case in _join_fixture_inh_selfref_w_entity
 #hat relies upon it being present, see :ticket:`3364`.

 #""

 #elf.primaryjoin = _deep_deannotate(
 #elf.primaryjoin, values=("parententity", "proxy_key")
 #
 #f self.secondaryjoin is not None:
 #elf.secondaryjoin = _deep_deannotate(
 #elf.secondaryjoin, values=("parententity", "proxy_key")
 #

 #ef _determine_joins(self):
 #""Determine the 'primaryjoin' and 'secondaryjoin' attributes,
 #f not passed to the constructor already.

 #his is based on analysis of the foreign key relationships
 #etween the parent and target mapped selectables.

 #""
 #f self.secondaryjoin is not None and self.secondary is None:
 #aise sa_exc.ArgumentError(
 #Property %s specified with secondary "
 #join condition but "
 #no secondary argument" % self.prop
 #

        # find a join between the given mapper's mapped table and
        # the given table. will try the mapper's local table first
        # for more specificity, then if not found will try the more
        # general mapped table, which in the case of inheritance is
        # a join.
 #ry:
 #onsider_as_foreign_keys = self.consider_as_foreign_keys or None
 #f self.secondary is not None:
 #f self.secondaryjoin is None:
 #elf.secondaryjoin = join_condition(
 #elf.child_persist_selectable,
 #elf.secondary,
 #_subset=self.child_local_selectable,
 #onsider_as_foreign_keys=consider_as_foreign_keys,
 #
 #f self.primaryjoin is None:
 #elf.primaryjoin = join_condition(
 #elf.parent_persist_selectable,
 #elf.secondary,
 #_subset=self.parent_local_selectable,
 #onsider_as_foreign_keys=consider_as_foreign_keys,
 #
 #lse:
 #f self.primaryjoin is None:
 #elf.primaryjoin = join_condition(
 #elf.parent_persist_selectable,
 #elf.child_persist_selectable,
 #_subset=self.parent_local_selectable,
 #onsider_as_foreign_keys=consider_as_foreign_keys,
 #
 #xcept sa_exc.NoForeignKeysError as nfe:
 #f self.secondary is not None:
 #til.raise_(
 #a_exc.NoForeignKeysError(
 #Could not determine join "
 #condition between parent/child tables on "
 #relationship %s - there are no foreign keys "
 #linking these tables via secondary table '%s'.  "
 #Ensure that referencing columns are associated "
 #with a ForeignKey or ForeignKeyConstraint, or "
 #specify 'primaryjoin' and 'secondaryjoin' "
 #expressions." % (self.prop, self.secondary)
 #,
 #rom_=nfe,
 #
 #lse:
 #til.raise_(
 #a_exc.NoForeignKeysError(
 #Could not determine join "
 #condition between parent/child tables on "
 #relationship %s - there are no foreign keys "
 #linking these tables.  "
 #Ensure that referencing columns are associated "
 #with a ForeignKey or ForeignKeyConstraint, or "
 #specify a 'primaryjoin' expression." % self.prop
 #,
 #rom_=nfe,
 #
 #xcept sa_exc.AmbiguousForeignKeysError as afe:
 #f self.secondary is not None:
 #til.raise_(
 #a_exc.AmbiguousForeignKeysError(
 #Could not determine join "
 #condition between parent/child tables on "
 #relationship %s - there are multiple foreign key "
 #paths linking the tables via secondary table '%s'.  "
 #Specify the 'foreign_keys' "
 #argument, providing a list of those columns which "
 #should be counted as containing a foreign key "
 #reference from the secondary table to each of the "
 #parent and child tables."
 # (self.prop, self.secondary)
 #,
 #rom_=afe,
 #
 #lse:
 #til.raise_(
 #a_exc.AmbiguousForeignKeysError(
 #Could not determine join "
 #condition between parent/child tables on "
 #relationship %s - there are multiple foreign key "
 #paths linking the tables.  Specify the "
 #'foreign_keys' argument, providing a list of those "
 #columns which should be counted as containing a "
 #foreign key reference to the parent table."
 # self.prop
 #,
 #rom_=afe,
 #

 #property
 #ef primaryjoin_minus_local(self):
 #eturn _deep_deannotate(self.primaryjoin, values=("local", "remote"))

 #property
 #ef secondaryjoin_minus_local(self):
 #eturn _deep_deannotate(self.secondaryjoin, values=("local", "remote"))

 #util.memoized_property
 #ef primaryjoin_reverse_remote(self):
 #""Return the primaryjoin condition suitable for the
 #reverse" direction.

 #f the primaryjoin was delivered here with pre-existing
 #remote" annotations, the local/remote annotations
 #re reversed.  Otherwise, the local/remote annotations
 #re removed.

 #""
 #f self._has_remote_annotations:

 #ef replace(element):
 #f "remote" in element._annotations:
 # = dict(element._annotations)
 #el v["remote"]
 #["local"] = True
 #eturn element._with_annotations(v)
 #lif "local" in element._annotations:
 # = dict(element._annotations)
 #el v["local"]
 #["remote"] = True
 #eturn element._with_annotations(v)

 #eturn visitors.replacement_traverse(self.primaryjoin, {}, replace)
 #lse:
 #f self._has_foreign_annotations:
                # TODO: coverage
 #eturn _deep_deannotate(
 #elf.primaryjoin, values=("local", "remote")
 #
 #lse:
 #eturn _deep_deannotate(self.primaryjoin)

 #ef _has_annotation(self, clause, annotation):
 #or col in visitors.iterate(clause, {}):
 #f annotation in col._annotations:
 #eturn True
 #lse:
 #eturn False

 #util.memoized_property
 #ef _has_foreign_annotations(self):
 #eturn self._has_annotation(self.primaryjoin, "foreign")

 #util.memoized_property
 #ef _has_remote_annotations(self):
 #eturn self._has_annotation(self.primaryjoin, "remote")

 #ef _annotate_fks(self):
 #""Annotate the primaryjoin and secondaryjoin
 #tructures with 'foreign' annotations marking columns
 #onsidered as foreign.

 #""
 #f self._has_foreign_annotations:
 #eturn

 #f self.consider_as_foreign_keys:
 #elf._annotate_from_fk_list()
 #lse:
 #elf._annotate_present_fks()

 #ef _annotate_from_fk_list(self):
 #ef check_fk(col):
 #f col in self.consider_as_foreign_keys:
 #eturn col._annotate({"foreign": True})

 #elf.primaryjoin = visitors.replacement_traverse(
 #elf.primaryjoin, {}, check_fk
 #
 #f self.secondaryjoin is not None:
 #elf.secondaryjoin = visitors.replacement_traverse(
 #elf.secondaryjoin, {}, check_fk
 #

 #ef _annotate_present_fks(self):
 #f self.secondary is not None:
 #econdarycols = util.column_set(self.secondary.c)
 #lse:
 #econdarycols = set()

 #ef is_foreign(a, b):
 #f isinstance(a, schema.Column) and isinstance(b, schema.Column):
 #f a.references(b):
 #eturn a
 #lif b.references(a):
 #eturn b

 #f secondarycols:
 #f a in secondarycols and b not in secondarycols:
 #eturn a
 #lif b in secondarycols and a not in secondarycols:
 #eturn b

 #ef visit_binary(binary):
 #f not isinstance(
 #inary.left, sql.ColumnElement
 # or not isinstance(binary.right, sql.ColumnElement):
 #eturn

 #f (
 #foreign" not in binary.left._annotations
 #nd "foreign" not in binary.right._annotations
 #:
 #ol = is_foreign(binary.left, binary.right)
 #f col is not None:
 #f col.compare(binary.left):
 #inary.left = binary.left._annotate({"foreign": True})
 #lif col.compare(binary.right):
 #inary.right = binary.right._annotate(
 #"foreign": True}
 #

 #elf.primaryjoin = visitors.cloned_traverse(
 #elf.primaryjoin, {}, {"binary": visit_binary}
 #
 #f self.secondaryjoin is not None:
 #elf.secondaryjoin = visitors.cloned_traverse(
 #elf.secondaryjoin, {}, {"binary": visit_binary}
 #

 #ef _refers_to_parent_table(self):
 #""Return True if the join condition contains column
 #omparisons where both columns are in both tables.

 #""
 #t = self.parent_persist_selectable
 #t = self.child_persist_selectable
 #esult = [False]

 #ef visit_binary(binary):
 #, f = binary.left, binary.right
 #f (
 #sinstance(c, expression.ColumnClause)
 #nd isinstance(f, expression.ColumnClause)
 #nd pt.is_derived_from(c.table)
 #nd pt.is_derived_from(f.table)
 #nd mt.is_derived_from(c.table)
 #nd mt.is_derived_from(f.table)
 #:
 #esult[0] = True

 #isitors.traverse(self.primaryjoin, {}, {"binary": visit_binary})
 #eturn result[0]

 #ef _tables_overlap(self):
 #""Return True if parent/child tables have some overlap."""

 #eturn selectables_overlap(
 #elf.parent_persist_selectable, self.child_persist_selectable
 #

 #ef _annotate_remote(self):
 #""Annotate the primaryjoin and secondaryjoin
 #tructures with 'remote' annotations marking columns
 #onsidered as part of the 'remote' side.

 #""
 #f self._has_remote_annotations:
 #eturn

 #f self.secondary is not None:
 #elf._annotate_remote_secondary()
 #lif self._local_remote_pairs or self._remote_side:
 #elf._annotate_remote_from_args()
 #lif self._refers_to_parent_table():
 #elf._annotate_selfref(
 #ambda col: "foreign" in col._annotations, False
 #
 #lif self._tables_overlap():
 #elf._annotate_remote_with_overlap()
 #lse:
 #elf._annotate_remote_distinct_selectables()

 #ef _annotate_remote_secondary(self):
 #""annotate 'remote' in primaryjoin, secondaryjoin
 #hen 'secondary' is present.

 #""

 #ef repl(element):
 #f self.secondary.c.contains_column(element):
 #eturn element._annotate({"remote": True})

 #elf.primaryjoin = visitors.replacement_traverse(
 #elf.primaryjoin, {}, repl
 #
 #elf.secondaryjoin = visitors.replacement_traverse(
 #elf.secondaryjoin, {}, repl
 #

 #ef _annotate_selfref(self, fn, remote_side_given):
 #""annotate 'remote' in primaryjoin, secondaryjoin
 #hen the relationship is detected as self-referential.

 #""

 #ef visit_binary(binary):
 #quated = binary.left.compare(binary.right)
 #f isinstance(binary.left, expression.ColumnClause) and isinstance(
 #inary.right, expression.ColumnClause
 #:
                # assume one to many - FKs are "remote"
 #f fn(binary.left):
 #inary.left = binary.left._annotate({"remote": True})
 #f fn(binary.right) and not equated:
 #inary.right = binary.right._annotate({"remote": True})
 #lif not remote_side_given:
 #elf._warn_non_column_elements()

 #elf.primaryjoin = visitors.cloned_traverse(
 #elf.primaryjoin, {}, {"binary": visit_binary}
 #

 #ef _annotate_remote_from_args(self):
 #""annotate 'remote' in primaryjoin, secondaryjoin
 #hen the 'remote_side' or '_local_remote_pairs'
 #rguments are used.

 #""
 #f self._local_remote_pairs:
 #f self._remote_side:
 #aise sa_exc.ArgumentError(
 #remote_side argument is redundant "
 #against more detailed _local_remote_side "
 #argument."
 #

 #emote_side = [r for (l, r) in self._local_remote_pairs]
 #lse:
 #emote_side = self._remote_side

 #f self._refers_to_parent_table():
 #elf._annotate_selfref(lambda col: col in remote_side, True)
 #lse:

 #ef repl(element):
                # use set() to avoid generating ``__eq__()`` expressions
                # against each element
 #f element in set(remote_side):
 #eturn element._annotate({"remote": True})

 #elf.primaryjoin = visitors.replacement_traverse(
 #elf.primaryjoin, {}, repl
 #

 #ef _annotate_remote_with_overlap(self):
 #""annotate 'remote' in primaryjoin, secondaryjoin
 #hen the parent/child tables have some set of
 #ables in common, though is not a fully self-referential
 #elationship.

 #""

 #ef visit_binary(binary):
 #inary.left, binary.right = proc_left_right(
 #inary.left, binary.right
 #
 #inary.right, binary.left = proc_left_right(
 #inary.right, binary.left
 #

 #heck_entities = (
 #elf.prop is not None and self.prop.mapper is not self.prop.parent
 #

 #ef proc_left_right(left, right):
 #f isinstance(left, expression.ColumnClause) and isinstance(
 #ight, expression.ColumnClause
 #:
 #f self.child_persist_selectable.c.contains_column(
 #ight
 # and self.parent_persist_selectable.c.contains_column(left):
 #ight = right._annotate({"remote": True})
 #lif (
 #heck_entities
 #nd right._annotations.get("parentmapper") is self.prop.mapper
 #:
 #ight = right._annotate({"remote": True})
 #lif (
 #heck_entities
 #nd left._annotations.get("parentmapper") is self.prop.mapper
 #:
 #eft = left._annotate({"remote": True})
 #lse:
 #elf._warn_non_column_elements()

 #eturn left, right

 #elf.primaryjoin = visitors.cloned_traverse(
 #elf.primaryjoin, {}, {"binary": visit_binary}
 #

 #ef _annotate_remote_distinct_selectables(self):
 #""annotate 'remote' in primaryjoin, secondaryjoin
 #hen the parent/child tables are entirely
 #eparate.

 #""

 #ef repl(element):
 #f self.child_persist_selectable.c.contains_column(element) and (
 #ot self.parent_local_selectable.c.contains_column(element)
 #r self.child_local_selectable.c.contains_column(element)
 #:
 #eturn element._annotate({"remote": True})

 #elf.primaryjoin = visitors.replacement_traverse(
 #elf.primaryjoin, {}, repl
 #

 #ef _warn_non_column_elements(self):
 #til.warn(
 #Non-simple column elements in primary "
 #join condition for property %s - consider using "
 #remote() annotations to mark the remote side." % self.prop
 #

 #ef _annotate_local(self):
 #""Annotate the primaryjoin and secondaryjoin
 #tructures with 'local' annotations.

 #his annotates all column elements found
 #imultaneously in the parent table
 #nd the join condition that don't have a
 #remote' annotation set up from
 #annotate_remote() or user-defined.

 #""
 #f self._has_annotation(self.primaryjoin, "local"):
 #eturn

 #f self._local_remote_pairs:
 #ocal_side = util.column_set(
 #l for (l, r) in self._local_remote_pairs]
 #
 #lse:
 #ocal_side = util.column_set(self.parent_persist_selectable.c)

 #ef locals_(elem):
 #f "remote" not in elem._annotations and elem in local_side:
 #eturn elem._annotate({"local": True})

 #elf.primaryjoin = visitors.replacement_traverse(
 #elf.primaryjoin, {}, locals_
 #

 #ef _annotate_parentmapper(self):
 #f self.prop is None:
 #eturn

 #ef parentmappers_(elem):
 #f "remote" in elem._annotations:
 #eturn elem._annotate({"parentmapper": self.prop.mapper})
 #lif "local" in elem._annotations:
 #eturn elem._annotate({"parentmapper": self.prop.parent})

 #elf.primaryjoin = visitors.replacement_traverse(
 #elf.primaryjoin, {}, parentmappers_
 #

 #ef _check_remote_side(self):
 #f not self.local_remote_pairs:
 #aise sa_exc.ArgumentError(
 #Relationship %s could "
 #not determine any unambiguous local/remote column "
 #pairs based on join condition and remote_side "
 #arguments.  "
 #Consider using the remote() annotation to "
 #accurately mark those elements of the join "
 #condition that are on the remote side of "
 #the relationship." % (self.prop,)
 #

 #ef _check_foreign_cols(self, join_condition, primary):
 #""Check the foreign key columns collected and emit error
 #essages."""

 #an_sync = False

 #oreign_cols = self._gather_columns_with_annotation(
 #oin_condition, "foreign"
 #

 #as_foreign = bool(foreign_cols)

 #f primary:
 #an_sync = bool(self.synchronize_pairs)
 #lse:
 #an_sync = bool(self.secondary_synchronize_pairs)

 #f (
 #elf.support_sync
 #nd can_sync
 #r (not self.support_sync and has_foreign)
 #:
 #eturn

        # from here below is just determining the best error message
        # to report.  Check for a join condition using any operator
        # (not just ==), perhaps they need to turn on "viewonly=True".
 #f self.support_sync and has_foreign and not can_sync:
 #rr = (
 #Could not locate any simple equality expressions "
 #involving locally mapped foreign key columns for "
 #%s join condition "
 #'%s' on relationship %s."
 # (
 #rimary and "primary" or "secondary",
 #oin_condition,
 #elf.prop,
 #
 #
 #rr += (
 #  Ensure that referencing columns are associated "
 #with a ForeignKey or ForeignKeyConstraint, or are "
 #annotated in the join condition with the foreign() "
 #annotation. To allow comparison operators other than "
 #'==', the relationship can be marked as viewonly=True."
 #

 #aise sa_exc.ArgumentError(err)
 #lse:
 #rr = (
 #Could not locate any relevant foreign key columns "
 #for %s join condition '%s' on relationship %s."
 # (
 #rimary and "primary" or "secondary",
 #oin_condition,
 #elf.prop,
 #
 #
 #rr += (
 #  Ensure that referencing columns are associated "
 #with a ForeignKey or ForeignKeyConstraint, or are "
 #annotated in the join condition with the foreign() "
 #annotation."
 #
 #aise sa_exc.ArgumentError(err)

 #ef _determine_direction(self):
 #""Determine if this relationship is one to many, many to one,
 #any to many.

 #""
 #f self.secondaryjoin is not None:
 #elf.direction = MANYTOMANY
 #lse:
 #arentcols = util.column_set(self.parent_persist_selectable.c)
 #argetcols = util.column_set(self.child_persist_selectable.c)

            # fk collection which suggests ONETOMANY.
 #netomany_fk = targetcols.intersection(self.foreign_key_columns)

            # fk collection which suggests MANYTOONE.

 #anytoone_fk = parentcols.intersection(self.foreign_key_columns)

 #f onetomany_fk and manytoone_fk:
                # fks on both sides.  test for overlap of local/remote
                # with foreign key.
                # we will gather columns directly from their annotations
                # without deannotating, so that we can distinguish on a column
                # that refers to itself.

                # 1. columns that are both remote and FK suggest
                # onetomany.
 #netomany_local = self._gather_columns_with_annotation(
 #elf.primaryjoin, "remote", "foreign"
 #

                # 2. columns that are FK but are not remote (e.g. local)
                # suggest manytoone.
 #anytoone_local = set(
 #
 #
 #or c in self._gather_columns_with_annotation(
 #elf.primaryjoin, "foreign"
 #
 #f "remote" not in c._annotations
 #
 #

                # 3. if both collections are present, remove columns that
                # refer to themselves.  This is for the case of
                # and_(Me.id == Me.remote_id, Me.version == Me.version)
 #f onetomany_local and manytoone_local:
 #elf_equated = self.remote_columns.intersection(
 #elf.local_columns
 #
 #netomany_local = onetomany_local.difference(self_equated)
 #anytoone_local = manytoone_local.difference(self_equated)

                # at this point, if only one or the other collection is
                # present, we know the direction, otherwise it's still
                # ambiguous.

 #f onetomany_local and not manytoone_local:
 #elf.direction = ONETOMANY
 #lif manytoone_local and not onetomany_local:
 #elf.direction = MANYTOONE
 #lse:
 #aise sa_exc.ArgumentError(
 #Can't determine relationship"
 # direction for relationship '%s' - foreign "
 #key columns within the join condition are present "
 #in both the parent and the child's mapped tables.  "
 #Ensure that only those columns referring "
 #to a parent column are marked as foreign, "
 #either via the foreign() annotation or "
 #via the foreign_keys argument." % self.prop
 #
 #lif onetomany_fk:
 #elf.direction = ONETOMANY
 #lif manytoone_fk:
 #elf.direction = MANYTOONE
 #lse:
 #aise sa_exc.ArgumentError(
 #Can't determine relationship "
 #direction for relationship '%s' - foreign "
 #key columns are present in neither the parent "
 #nor the child's mapped tables" % self.prop
 #

 #ef _deannotate_pairs(self, collection):
 #""provide deannotation for the various lists of
 #airs, so that using them in hashes doesn't incur
 #igh-overhead __eq__() comparisons against
 #riginal columns mapped.

 #""
 #eturn [(x._deannotate(), y._deannotate()) for x, y in collection]

 #ef _setup_pairs(self):
 #ync_pairs = []
 #rp = util.OrderedSet([])
 #econdary_sync_pairs = []

 #ef go(joincond, collection):
 #ef visit_binary(binary, left, right):
 #f (
 #remote" in right._annotations
 #nd "remote" not in left._annotations
 #nd self.can_be_synced_fn(left)
 #:
 #rp.add((left, right))
 #lif (
 #remote" in left._annotations
 #nd "remote" not in right._annotations
 #nd self.can_be_synced_fn(right)
 #:
 #rp.add((right, left))
 #f binary.operator is operators.eq and self.can_be_synced_fn(
 #eft, right
 #:
 #f "foreign" in right._annotations:
 #ollection.append((left, right))
 #lif "foreign" in left._annotations:
 #ollection.append((right, left))

 #isit_binary_product(visit_binary, joincond)

 #or joincond, collection in [
 #self.primaryjoin, sync_pairs),
 #self.secondaryjoin, secondary_sync_pairs),
 #:
 #f joincond is None:
 #ontinue
 #o(joincond, collection)

 #elf.local_remote_pairs = self._deannotate_pairs(lrp)
 #elf.synchronize_pairs = self._deannotate_pairs(sync_pairs)
 #elf.secondary_synchronize_pairs = self._deannotate_pairs(
 #econdary_sync_pairs
 #

 #track_overlapping_sync_targets = weakref.WeakKeyDictionary()

 #ef _warn_for_conflicting_sync_targets(self):
 #f not self.support_sync:
 #eturn

        # we would like to detect if we are synchronizing any column
        # pairs in conflict with another relationship that wishes to sync
        # an entirely different column to the same target.   This is a
        # very rare edge case so we will try to minimize the memory/overhead
        # impact of this check
 #or from_, to_ in [
 #from_, to_) for (from_, to_) in self.synchronize_pairs
 # + [
 #from_, to_) for (from_, to_) in self.secondary_synchronize_pairs
 #:
            # save ourselves a ton of memory and overhead by only
            # considering columns that are subject to a overlapping
            # FK constraints at the core level.   This condition can arise
            # if multiple relationships overlap foreign() directly, but
            # we're going to assume it's typically a ForeignKeyConstraint-
            # level configuration that benefits from this warning.

 #f to_ not in self._track_overlapping_sync_targets:
 #elf._track_overlapping_sync_targets[
 #o_
 # = weakref.WeakKeyDictionary({self.prop: from_})
 #lse:
 #ther_props = []
 #rop_to_from = self._track_overlapping_sync_targets[to_]

 #or pr, fr_ in prop_to_from.items():
 #f (
 #ot pr.mapper._dispose_called
 #nd pr not in self.prop._reverse_property
 #nd pr.key not in self.prop._overlaps
 #nd self.prop.key not in pr._overlaps
                        # note: the "__*" symbol is used internally by
                        # SQLAlchemy as a general means of supressing the
                        # overlaps warning for some extension cases, however
                        # this is not currently
                        # a publicly supported symbol and may change at
                        # any time.
 #nd "__*" not in self.prop._overlaps
 #nd "__*" not in pr._overlaps
 #nd not self.prop.parent.is_sibling(pr.parent)
 #nd not self.prop.mapper.is_sibling(pr.mapper)
 #nd not self.prop.parent.is_sibling(pr.mapper)
 #nd not self.prop.mapper.is_sibling(pr.parent)
 #nd (
 #elf.prop.key != pr.key
 #r not self.prop.parent.common_parent(pr.parent)
 #
 #:

 #ther_props.append((pr, fr_))

 #f other_props:
 #til.warn(
 #relationship '%s' will copy column %s to column %s, "
 #which conflicts with relationship(s): %s. "
 #If this is not the intention, consider if these "
 #relationships should be linked with "
 #back_populates, or if viewonly=True should be "
 #applied to one or more if they are read-only. "
 #For the less common case that foreign key "
 #constraints are partially overlapping, the "
 #orm.foreign() "
 #annotation can be used to isolate the columns that "
 #should be written towards.   To silence this "
 #warning, add the parameter 'overlaps=\"%s\"' to the "
 #'%s' relationship."
 # (
 #elf.prop,
 #rom_,
 #o_,
 #, ".join(
 #orted(
 #'%s' (copies %s to %s)" % (pr, fr_, to_)
 #or (pr, fr_) in other_props
 #
 #,
 #,".join(sorted(pr.key for pr, fr in other_props)),
 #elf.prop,
 #,
 #ode="qzyx",
 #
 #elf._track_overlapping_sync_targets[to_][self.prop] = from_

 #util.memoized_property
 #ef remote_columns(self):
 #eturn self._gather_join_annotations("remote")

 #util.memoized_property
 #ef local_columns(self):
 #eturn self._gather_join_annotations("local")

 #util.memoized_property
 #ef foreign_key_columns(self):
 #eturn self._gather_join_annotations("foreign")

 #ef _gather_join_annotations(self, annotation):
 # = set(
 #elf._gather_columns_with_annotation(self.primaryjoin, annotation)
 #
 #f self.secondaryjoin is not None:
 #.update(
 #elf._gather_columns_with_annotation(
 #elf.secondaryjoin, annotation
 #
 #
 #eturn {x._deannotate() for x in s}

 #ef _gather_columns_with_annotation(self, clause, *annotation):
 #nnotation = set(annotation)
 #eturn set(
 #
 #ol
 #or col in visitors.iterate(clause, {})
 #f annotation.issubset(col._annotations)
 #
 #

 #ef join_targets(
 #elf,
 #ource_selectable,
 #est_selectable,
 #liased,
 #ingle_crit=None,
 #xtra_criteria=(),
 #:
 #""Given a source and destination selectable, create a
 #oin between them.

 #his takes into account aliasing the join clause
 #o reference the appropriate corresponding columns
 #n the target objects, as well as the extra child
 #riterion, equivalent column sets, etc.

 #""
        # place a barrier on the destination such that
        # replacement traversals won't ever dig into it.
        # its internal structure remains fixed
        # regardless of context.
 #est_selectable = _shallow_annotate(
 #est_selectable, {"no_replacement_traverse": True}
 #

 #rimaryjoin, secondaryjoin, secondary = (
 #elf.primaryjoin,
 #elf.secondaryjoin,
 #elf.secondary,
 #

        # adjust the join condition for single table inheritance,
        # in the case that the join is to a subclass
        # this is analogous to the
        # "_adjust_for_single_table_inheritance()" method in Query.

 #f single_crit is not None:
 #f secondaryjoin is not None:
 #econdaryjoin = secondaryjoin & single_crit
 #lse:
 #rimaryjoin = primaryjoin & single_crit

 #f extra_criteria:
 #f secondaryjoin is not None:
 #econdaryjoin = secondaryjoin & sql.and_(*extra_criteria)
 #lse:
 #rimaryjoin = primaryjoin & sql.and_(*extra_criteria)

 #f aliased:
 #f secondary is not None:
 #econdary = secondary._anonymous_fromclause(flat=True)
 #rimary_aliasizer = ClauseAdapter(
 #econdary, exclude_fn=_ColInAnnotations("local")
 #
 #econdary_aliasizer = ClauseAdapter(
 #est_selectable, equivalents=self.child_equivalents
 #.chain(primary_aliasizer)
 #f source_selectable is not None:
 #rimary_aliasizer = ClauseAdapter(
 #econdary, exclude_fn=_ColInAnnotations("local")
 #.chain(
 #lauseAdapter(
 #ource_selectable,
 #quivalents=self.parent_equivalents,
 #
 #

 #econdaryjoin = secondary_aliasizer.traverse(secondaryjoin)
 #lse:
 #rimary_aliasizer = ClauseAdapter(
 #est_selectable,
 #xclude_fn=_ColInAnnotations("local"),
 #quivalents=self.child_equivalents,
 #
 #f source_selectable is not None:
 #rimary_aliasizer.chain(
 #lauseAdapter(
 #ource_selectable,
 #xclude_fn=_ColInAnnotations("remote"),
 #quivalents=self.parent_equivalents,
 #
 #
 #econdary_aliasizer = None

 #rimaryjoin = primary_aliasizer.traverse(primaryjoin)
 #arget_adapter = secondary_aliasizer or primary_aliasizer
 #arget_adapter.exclude_fn = None
 #lse:
 #arget_adapter = None
 #eturn (
 #rimaryjoin,
 #econdaryjoin,
 #econdary,
 #arget_adapter,
 #est_selectable,
 #

 #ef create_lazy_clause(self, reverse_direction=False):
 #inds = util.column_dict()
 #quated_columns = util.column_dict()

 #as_secondary = self.secondaryjoin is not None

 #f has_secondary:
 #ookup = collections.defaultdict(list)
 #or l, r in self.local_remote_pairs:
 #ookup[l].append((l, r))
 #quated_columns[r] = l
 #lif not reverse_direction:
 #or l, r in self.local_remote_pairs:
 #quated_columns[r] = l
 #lse:
 #or l, r in self.local_remote_pairs:
 #quated_columns[l] = r

 #ef col_to_bind(col):

 #f (
 #not reverse_direction and "local" in col._annotations)
 #r reverse_direction
 #nd (
 #has_secondary and col in lookup)
 #r (not has_secondary and "remote" in col._annotations)
 #
 #:
 #f col not in binds:
 #inds[col] = sql.bindparam(
 #one, None, type_=col.type, unique=True
 #
 #eturn binds[col]
 #eturn None

 #azywhere = self.primaryjoin
 #f self.secondaryjoin is None or not reverse_direction:
 #azywhere = visitors.replacement_traverse(
 #azywhere, {}, col_to_bind
 #

 #f self.secondaryjoin is not None:
 #econdaryjoin = self.secondaryjoin
 #f reverse_direction:
 #econdaryjoin = visitors.replacement_traverse(
 #econdaryjoin, {}, col_to_bind
 #
 #azywhere = sql.and_(lazywhere, secondaryjoin)

 #ind_to_col = {binds[col].key: col for col in binds}

 #eturn lazywhere, bind_to_col, equated_columns


class _ColInAnnotations(object):
 #""Serializable object that tests for a name in c._annotations."""

 #_slots__ = ("name",)

 #ef __init__(self, name):
 #elf.name = name

 #ef __call__(self, c):
 #eturn self.name in c._annotations
