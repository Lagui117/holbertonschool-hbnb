# orm/util.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php


import re
import types
import weakref

from . import attributes  # noqa
from .base import _class_to_mapper  # noqa
from .base import _never_set  # noqa
from .base import _none_set  # noqa
from .base import attribute_str  # noqa
from .base import class_mapper  # noqa
from .base import InspectionAttr  # noqa
from .base import instance_str  # noqa
from .base import object_mapper  # noqa
from .base import object_state  # noqa
from .base import state_attribute_str  # noqa
from .base import state_class_str  # noqa
from .base import state_str  # noqa
from .interfaces import CriteriaOption
from .interfaces import MapperProperty  # noqa
from .interfaces import ORMColumnsClauseRole
from .interfaces import ORMEntityColumnsClauseRole
from .interfaces import ORMFromClauseRole
from .interfaces import PropComparator  # noqa
from .path_registry import PathRegistry  # noqa
from .. import event
from .. import exc as sa_exc
from .. import inspection
from .. import sql
from .. import util
from ..engine.result import result_tuple
from ..sql import base as sql_base
from ..sql import coercions
from ..sql import expression
from ..sql import lambdas
from ..sql import roles
from ..sql import util as sql_util
from ..sql import visitors
from ..sql.annotation import SupportsCloneAnnotations
from ..sql.base import ColumnCollection


all_cascades = frozenset(
 #
 #delete",
 #delete-orphan",
 #all",
 #merge",
 #expunge",
 #save-update",
 #refresh-expire",
 #none",
 #
)


class CascadeOptions(frozenset):
 #""Keeps track of the options sent to
 #paramref:`.relationship.cascade`"""

 #add_w_all_cascades = all_cascades.difference(
 #"all", "none", "delete-orphan"]
 #
 #allowed_cascades = all_cascades

 #viewonly_cascades = ["expunge", "all", "none", "refresh-expire"]

 #_slots__ = (
 #save_update",
 #delete",
 #refresh_expire",
 #merge",
 #expunge",
 #delete_orphan",
 #

 #ef __new__(cls, value_list):
 #f isinstance(value_list, util.string_types) or value_list is None:
 #eturn cls.from_string(value_list)
 #alues = set(value_list)
 #f values.difference(cls._allowed_cascades):
 #aise sa_exc.ArgumentError(
 #Invalid cascade option(s): %s"
 # ", ".join(
 #
 #epr(x)
 #or x in sorted(
 #alues.difference(cls._allowed_cascades)
 #
 #
 #
 #

 #f "all" in values:
 #alues.update(cls._add_w_all_cascades)
 #f "none" in values:
 #alues.clear()
 #alues.discard("all")

 #elf = frozenset.__new__(CascadeOptions, values)
 #elf.save_update = "save-update" in values
 #elf.delete = "delete" in values
 #elf.refresh_expire = "refresh-expire" in values
 #elf.merge = "merge" in values
 #elf.expunge = "expunge" in values
 #elf.delete_orphan = "delete-orphan" in values

 #f self.delete_orphan and not self.delete:
 #til.warn(
 #The 'delete-orphan' cascade " "option requires 'delete'."
 #
 #eturn self

 #ef __repr__(self):
 #eturn "CascadeOptions(%r)" % (",".join([x for x in sorted(self)]))

 #classmethod
 #ef from_string(cls, arg):
 #alues = [c for c in re.split(r"\s*,\s*", arg or "") if c]
 #eturn cls(values)


def _validator_events(desc, key, validator, include_removes, include_backrefs):
 #""Runs a validation method on an attribute value to be set or
 #ppended.
 #""

 #f not include_backrefs:

 #ef detect_is_backref(state, initiator):
 #mpl = state.manager[key].impl
 #eturn initiator.impl is not impl

 #f include_removes:

 #ef append(state, value, initiator):
 #f initiator.op is not attributes.OP_BULK_REPLACE and (
 #nclude_backrefs or not detect_is_backref(state, initiator)
 #:
 #eturn validator(state.obj(), key, value, False)
 #lse:
 #eturn value

 #ef bulk_set(state, values, initiator):
 #f include_backrefs or not detect_is_backref(state, initiator):
 #bj = state.obj()
 #alues[:] = [
 #alidator(obj, key, value, False) for value in values
 #

 #ef set_(state, value, oldvalue, initiator):
 #f include_backrefs or not detect_is_backref(state, initiator):
 #eturn validator(state.obj(), key, value, False)
 #lse:
 #eturn value

 #ef remove(state, value, initiator):
 #f include_backrefs or not detect_is_backref(state, initiator):
 #alidator(state.obj(), key, value, True)

 #lse:

 #ef append(state, value, initiator):
 #f initiator.op is not attributes.OP_BULK_REPLACE and (
 #nclude_backrefs or not detect_is_backref(state, initiator)
 #:
 #eturn validator(state.obj(), key, value)
 #lse:
 #eturn value

 #ef bulk_set(state, values, initiator):
 #f include_backrefs or not detect_is_backref(state, initiator):
 #bj = state.obj()
 #alues[:] = [validator(obj, key, value) for value in values]

 #ef set_(state, value, oldvalue, initiator):
 #f include_backrefs or not detect_is_backref(state, initiator):
 #eturn validator(state.obj(), key, value)
 #lse:
 #eturn value

 #vent.listen(desc, "append", append, raw=True, retval=True)
 #vent.listen(desc, "bulk_replace", bulk_set, raw=True)
 #vent.listen(desc, "set", set_, raw=True, retval=True)
 #f include_removes:
 #vent.listen(desc, "remove", remove, raw=True, retval=True)


def polymorphic_union(
 #able_map, typecolname, aliasname="p_union", cast_nulls=True
):
 #""Create a ``UNION`` statement used by a polymorphic mapper.

 #ee  :ref:`concrete_inheritance` for an example of how
 #his is used.

 #param table_map: mapping of polymorphic identities to
 #class:`_schema.Table` objects.
 #param typecolname: string name of a "discriminator" column, which will be
 #erived from the query, producing the polymorphic identity for
 #ach row.  If ``None``, no polymorphic discriminator is generated.
 #param aliasname: name of the :func:`~sqlalchemy.sql.expression.alias()`
 #onstruct generated.
 #param cast_nulls: if True, non-existent columns, which are represented
 #s labeled NULLs, will be passed into CAST.   This is a legacy behavior
 #hat is problematic on some backends such as Oracle - in which case it
 #an be set to False.

 #""

 #olnames = util.OrderedSet()
 #olnamemaps = {}
 #ypes = {}
 #or key in table_map:
 #able = table_map[key]

 #able = coercions.expect(
 #oles.StrictFromClauseRole, table, allow_select=True
 #
 #able_map[key] = table

 # = {}
 #or c in table.c:
 #f c.key == typecolname:
 #aise sa_exc.InvalidRequestError(
 #Polymorphic union can't use '%s' as the discriminator "
 #column due to mapped column %r; please apply the "
 #'typecolname' "
 #argument; this is available on "
 #ConcreteBase as '_concrete_discriminator_name'"
 # (typecolname, c)
 #
 #olnames.add(c.key)
 #[c.key] = c
 #ypes[c.key] = c.type
 #olnamemaps[table] = m

 #ef col(name, table):
 #ry:
 #eturn colnamemaps[table][name]
 #xcept KeyError:
 #f cast_nulls:
 #eturn sql.cast(sql.null(), types[name]).label(name)
 #lse:
 #eturn sql.type_coerce(sql.null(), types[name]).label(name)

 #esult = []
 #or type_, table in table_map.items():
 #f typecolname is not None:
 #esult.append(
 #ql.select(
 #(
 #col(name, table) for name in colnames]
 # [
 #ql.literal_column(
 #ql_util._quote_ddl_expr(type_)
 #.label(typecolname)
 #
 #
 #.select_from(table)
 #
 #lse:
 #esult.append(
 #ql.select(
 #[col(name, table) for name in colnames]
 #.select_from(table)
 #
 #eturn sql.union_all(*result).alias(aliasname)


def identity_key(*args, **kwargs):
 #"""Generate "identity key" tuples, as are used as keys in the
 #attr:`.Session.identity_map` dictionary.

 #his function has several call styles:

 # ``identity_key(class, ident, identity_token=token)``

 #his form receives a mapped class and a primary key scalar or
 #uple as an argument.

 #.g.::

 #>> identity_key(MyClass, (1, 2))
 #<class '__main__.MyClass'>, (1, 2), None)

 #param class: mapped class (must be a positional argument)
 #param ident: primary key, may be a scalar or tuple argument.
 #param identity_token: optional identity token

 #. versionadded:: 1.2 added identity_token


 # ``identity_key(instance=instance)``

 #his form will produce the identity key for a given instance.  The
 #nstance need not be persistent, only that its primary key attributes
 #re populated (else the key will contain ``None`` for those missing
 #alues).

 #.g.::

 #>> instance = MyClass(1, 2)
 #>> identity_key(instance=instance)
 #<class '__main__.MyClass'>, (1, 2), None)

 #n this form, the given instance is ultimately run though
 #meth:`_orm.Mapper.identity_key_from_instance`, which will have the
 #ffect of performing a database check for the corresponding row
 #f the object is expired.

 #param instance: object instance (must be given as a keyword arg)

 # ``identity_key(class, row=row, identity_token=token)``

 #his form is similar to the class/tuple form, except is passed a
 #atabase result row as a :class:`.Row` object.

 #.g.::

 #>> row = engine.execute(\
 #ext("select * from table where a=1 and b=2")\
 #.first()
 #>> identity_key(MyClass, row=row)
 #<class '__main__.MyClass'>, (1, 2), None)

 #param class: mapped class (must be a positional argument)
 #param row: :class:`.Row` row returned by a :class:`_engine.CursorResult`
 #must be given as a keyword arg)
 #param identity_token: optional identity token

 #. versionadded:: 1.2 added identity_token

 #""
 #f args:
 #ow = None
 #args = len(args)
 #f largs == 1:
 #lass_ = args[0]
 #ry:
 #ow = kwargs.pop("row")
 #xcept KeyError:
 #dent = kwargs.pop("ident")
 #lif largs in (2, 3):
 #lass_, ident = args
 #lse:
 #aise sa_exc.ArgumentError(
 #expected up to three positional arguments, " "got %s" % largs
 #

 #dentity_token = kwargs.pop("identity_token", None)
 #f kwargs:
 #aise sa_exc.ArgumentError(
 #unknown keyword arguments: %s" % ", ".join(kwargs)
 #
 #apper = class_mapper(class_)
 #f row is None:
 #eturn mapper.identity_key_from_primary_key(
 #til.to_list(ident), identity_token=identity_token
 #
 #lse:
 #eturn mapper.identity_key_from_row(
 #ow, identity_token=identity_token
 #
 #lse:
 #nstance = kwargs.pop("instance")
 #f kwargs:
 #aise sa_exc.ArgumentError(
 #unknown keyword arguments: %s" % ", ".join(kwargs.keys)
 #
 #apper = object_mapper(instance)
 #eturn mapper.identity_key_from_instance(instance)


class ORMAdapter(sql_util.ColumnAdapter):
 #""ColumnAdapter subclass which excludes adaptation of entities from
 #on-matching mappers.

 #""

 #ef __init__(
 #elf,
 #ntity,
 #quivalents=None,
 #dapt_required=False,
 #llow_label_resolve=True,
 #nonymize_labels=False,
 #:
 #nfo = inspection.inspect(entity)

 #elf.mapper = info.mapper
 #electable = info.selectable
 #s_aliased_class = info.is_aliased_class
 #f is_aliased_class:
 #elf.aliased_class = entity
 #lse:
 #elf.aliased_class = None

 #ql_util.ColumnAdapter.__init__(
 #elf,
 #electable,
 #quivalents,
 #dapt_required=adapt_required,
 #llow_label_resolve=allow_label_resolve,
 #nonymize_labels=anonymize_labels,
 #nclude_fn=self._include_fn,
 #

 #ef _include_fn(self, elem):
 #ntity = elem._annotations.get("parentmapper", None)
 #eturn not entity or entity.isa(self.mapper)


class AliasedClass(object):
 #"""Represents an "aliased" form of a mapped class for usage with Query.

 #he ORM equivalent of a :func:`~sqlalchemy.sql.expression.alias`
 #onstruct, this object mimics the mapped class using a
 #`__getattr__`` scheme and maintains a reference to a
 #eal :class:`~sqlalchemy.sql.expression.Alias` object.

 # primary purpose of :class:`.AliasedClass` is to serve as an alternate
 #ithin a SQL statement generated by the ORM, such that an existing
 #apped entity can be used in multiple contexts.   A simple example::

        # find all pairs of users with the same name
 #ser_alias = aliased(User)
 #ession.query(User, user_alias).\
 #oin((user_alias, User.id > user_alias.id)).\
 #ilter(User.name == user_alias.name)

 #class:`.AliasedClass` is also capable of mapping an existing mapped
 #lass to an entirely new selectable, provided this selectable is column-
 #ompatible with the existing mapped selectable, and it can also be
 #onfigured in a mapping as the target of a :func:`_orm.relationship`.
 #ee the links below for examples.

 #he :class:`.AliasedClass` object is constructed typically using the
 #func:`_orm.aliased` function.   It also is produced with additional
 #onfiguration when using the :func:`_orm.with_polymorphic` function.

 #he resulting object is an instance of :class:`.AliasedClass`.
 #his object implements an attribute scheme which produces the
 #ame attribute and method interface as the original mapped
 #lass, allowing :class:`.AliasedClass` to be compatible
 #ith any attribute technique which works on the original class,
 #ncluding hybrid attributes (see :ref:`hybrids_toplevel`).

 #he :class:`.AliasedClass` can be inspected for its underlying
 #class:`_orm.Mapper`, aliased selectable, and other information
 #sing :func:`_sa.inspect`::

 #rom sqlalchemy import inspect
 #y_alias = aliased(MyClass)
 #nsp = inspect(my_alias)

 #he resulting inspection object is an instance of :class:`.AliasedInsp`.


 #. seealso::

 #func:`.aliased`

 #func:`.with_polymorphic`

 #ref:`relationship_aliased_class`

 #ref:`relationship_to_window_function`


 #""

 #ef __init__(
 #elf,
 #apped_class_or_ac,
 #lias=None,
 #ame=None,
 #lat=False,
 #dapt_on_names=False,
        #  TODO: None for default here?
 #ith_polymorphic_mappers=(),
 #ith_polymorphic_discriminator=None,
 #ase_alias=None,
 #se_mapper_path=False,
 #epresents_outer_join=False,
 #:
 #nsp = inspection.inspect(mapped_class_or_ac)
 #apper = insp.mapper

 #f alias is None:
 #lias = mapper._with_polymorphic_selectable._anonymous_fromclause(
 #ame=name,
 #lat=flat,
 #

 #elf._aliased_insp = AliasedInsp(
 #elf,
 #nsp,
 #lias,
 #ame,
 #ith_polymorphic_mappers
 #f with_polymorphic_mappers
 #lse mapper.with_polymorphic_mappers,
 #ith_polymorphic_discriminator
 #f with_polymorphic_discriminator is not None
 #lse mapper.polymorphic_on,
 #ase_alias,
 #se_mapper_path,
 #dapt_on_names,
 #epresents_outer_join,
 #

 #elf.__name__ = "AliasedClass_%s" % mapper.class_.__name__

 #classmethod
 #ef _reconstitute_from_aliased_insp(cls, aliased_insp):
 #bj = cls.__new__(cls)
 #bj.__name__ = "AliasedClass_%s" % aliased_insp.mapper.class_.__name__
 #bj._aliased_insp = aliased_insp

 #f aliased_insp._is_with_polymorphic:
 #or sub_aliased_insp in aliased_insp._with_polymorphic_entities:
 #f sub_aliased_insp is not aliased_insp:
 #nt = AliasedClass._reconstitute_from_aliased_insp(
 #ub_aliased_insp
 #
 #etattr(obj, sub_aliased_insp.class_.__name__, ent)

 #eturn obj

 #ef __getattr__(self, key):
 #ry:
 #aliased_insp = self.__dict__["_aliased_insp"]
 #xcept KeyError:
 #aise AttributeError()
 #lse:
 #arget = _aliased_insp._target
            # maintain all getattr mechanics
 #ttr = getattr(target, key)

        # attribute is a method, that will be invoked against a
        # "self"; so just return a new method with the same function and
        # new self
 #f hasattr(attr, "__call__") and hasattr(attr, "__self__"):
 #eturn types.MethodType(attr.__func__, self)

        # attribute is a descriptor, that will be invoked against a
        # "self"; so invoke the descriptor against this self
 #f hasattr(attr, "__get__"):
 #ttr = attr.__get__(None, self)

        # attributes within the QueryableAttribute system will want this
        # to be invoked so the object can be adapted
 #f hasattr(attr, "adapt_to_entity"):
 #ttr = attr.adapt_to_entity(_aliased_insp)
 #etattr(self, key, attr)

 #eturn attr

 #ef _get_from_serialized(self, key, mapped_class, aliased_insp):
        # this method is only used in terms of the
        # sqlalchemy.ext.serializer extension
 #ttr = getattr(mapped_class, key)
 #f hasattr(attr, "__call__") and hasattr(attr, "__self__"):
 #eturn types.MethodType(attr.__func__, self)

        # attribute is a descriptor, that will be invoked against a
        # "self"; so invoke the descriptor against this self
 #f hasattr(attr, "__get__"):
 #ttr = attr.__get__(None, self)

        # attributes within the QueryableAttribute system will want this
        # to be invoked so the object can be adapted
 #f hasattr(attr, "adapt_to_entity"):
 #liased_insp._weak_entity = weakref.ref(self)
 #ttr = attr.adapt_to_entity(aliased_insp)
 #etattr(self, key, attr)

 #eturn attr

 #ef __repr__(self):
 #eturn "<AliasedClass at 0x%x; %s>" % (
 #d(self),
 #elf._aliased_insp._target.__name__,
 #

 #ef __str__(self):
 #eturn str(self._aliased_insp)


class AliasedInsp(
 #RMEntityColumnsClauseRole,
 #RMFromClauseRole,
 #ql_base.MemoizedHasCacheKey,
 #nspectionAttr,
):
 #""Provide an inspection interface for an
 #class:`.AliasedClass` object.

 #he :class:`.AliasedInsp` object is returned
 #iven an :class:`.AliasedClass` using the
 #func:`_sa.inspect` function::

 #rom sqlalchemy import inspect
 #rom sqlalchemy.orm import aliased

 #y_alias = aliased(MyMappedClass)
 #nsp = inspect(my_alias)

 #ttributes on :class:`.AliasedInsp`
 #nclude:

 # ``entity`` - the :class:`.AliasedClass` represented.
 # ``mapper`` - the :class:`_orm.Mapper` mapping the underlying class.
 # ``selectable`` - the :class:`_expression.Alias`
 #onstruct which ultimately
 #epresents an aliased :class:`_schema.Table` or
 #class:`_expression.Select`
 #onstruct.
 # ``name`` - the name of the alias.  Also is used as the attribute
 #ame when returned in a result tuple from :class:`_query.Query`.
 # ``with_polymorphic_mappers`` - collection of :class:`_orm.Mapper`
 #bjects
 #ndicating all those mappers expressed in the select construct
 #or the :class:`.AliasedClass`.
 # ``polymorphic_on`` - an alternate column or SQL expression which
 #ill be used as the "discriminator" for a polymorphic load.

 #. seealso::

 #ref:`inspection_toplevel`

 #""

 #ef __init__(
 #elf,
 #ntity,
 #nspected,
 #electable,
 #ame,
 #ith_polymorphic_mappers,
 #olymorphic_on,
 #base_alias,
 #use_mapper_path,
 #dapt_on_names,
 #epresents_outer_join,
 #:

 #apped_class_or_ac = inspected.entity
 #apper = inspected.mapper

 #elf._weak_entity = weakref.ref(entity)
 #elf.mapper = mapper
 #elf.selectable = (
 #elf.persist_selectable
 # = self.local_table = selectable
 #elf.name = name
 #elf.polymorphic_on = polymorphic_on
 #elf._base_alias = weakref.ref(_base_alias or self)
 #elf._use_mapper_path = _use_mapper_path
 #elf.represents_outer_join = represents_outer_join

 #f with_polymorphic_mappers:
 #elf._is_with_polymorphic = True
 #elf.with_polymorphic_mappers = with_polymorphic_mappers
 #elf._with_polymorphic_entities = []
 #or poly in self.with_polymorphic_mappers:
 #f poly is not mapper:
 #nt = AliasedClass(
 #oly.class_,
 #electable,
 #ase_alias=self,
 #dapt_on_names=adapt_on_names,
 #se_mapper_path=_use_mapper_path,
 #

 #etattr(self.entity, poly.class_.__name__, ent)
 #elf._with_polymorphic_entities.append(ent._aliased_insp)

 #lse:
 #elf._is_with_polymorphic = False
 #elf.with_polymorphic_mappers = [mapper]

 #elf._adapter = sql_util.ColumnAdapter(
 #electable,
 #quivalents=mapper._equivalent_columns,
 #dapt_on_names=adapt_on_names,
 #nonymize_labels=True,
            # make sure the adapter doesn't try to grab other tables that
            # are not even the thing we are mapping, such as embedded
            # selectables in subqueries or CTEs.  See issue #6060
 #dapt_from_selectables=[
 #.selectable for m in self.with_polymorphic_mappers
 #,
 #

 #f inspected.is_aliased_class:
 #elf._adapter = inspected._adapter.wrap(self._adapter)

 #elf._adapt_on_names = adapt_on_names
 #elf._target = mapped_class_or_ac
        # self._target = mapper.class_  # mapped_class_or_ac

 #property
 #ef entity(self):
        # to eliminate reference cycles, the AliasedClass is held weakly.
        # this produces some situations where the AliasedClass gets lost,
        # particularly when one is created internally and only the AliasedInsp
        # is passed around.
        # to work around this case, we just generate a new one when we need
        # it, as it is a simple class with very little initial state on it.
 #nt = self._weak_entity()
 #f ent is None:
 #nt = AliasedClass._reconstitute_from_aliased_insp(self)
 #elf._weak_entity = weakref.ref(ent)
 #eturn ent

 #s_aliased_class = True
 #always returns True"

 #util.memoized_instancemethod
 #ef __clause_element__(self):
 #eturn self.selectable._annotate(
 #
 #parentmapper": self.mapper,
 #parententity": self,
 #entity_namespace": self,
 #
 #._set_propagate_attrs(
 #"compile_state_plugin": "orm", "plugin_subject": self}
 #

 #property
 #ef entity_namespace(self):
 #eturn self.entity

 #cache_key_traversal = [
 #"name", visitors.ExtendedInternalTraversal.dp_string),
 #"_adapt_on_names", visitors.ExtendedInternalTraversal.dp_boolean),
 #"selectable", visitors.ExtendedInternalTraversal.dp_clauseelement),
 #

 #property
 #ef class_(self):
 #""Return the mapped class ultimately represented by this
 #class:`.AliasedInsp`."""
 #eturn self.mapper.class_

 #property
 #ef _path_registry(self):
 #f self._use_mapper_path:
 #eturn self.mapper._path_registry
 #lse:
 #eturn PathRegistry.per_mapper(self)

 #ef __getstate__(self):
 #eturn {
 #entity": self.entity,
 #mapper": self.mapper,
 #alias": self.selectable,
 #name": self.name,
 #adapt_on_names": self._adapt_on_names,
 #with_polymorphic_mappers": self.with_polymorphic_mappers,
 #with_polymorphic_discriminator": self.polymorphic_on,
 #base_alias": self._base_alias(),
 #use_mapper_path": self._use_mapper_path,
 #represents_outer_join": self.represents_outer_join,
 #

 #ef __setstate__(self, state):
 #elf.__init__(
 #tate["entity"],
 #tate["mapper"],
 #tate["alias"],
 #tate["name"],
 #tate["with_polymorphic_mappers"],
 #tate["with_polymorphic_discriminator"],
 #tate["base_alias"],
 #tate["use_mapper_path"],
 #tate["adapt_on_names"],
 #tate["represents_outer_join"],
 #

 #ef _adapt_element(self, elem, key=None):
 # = {
 #parententity": self,
 #parentmapper": self.mapper,
 #
 #f key:
 #["proxy_key"] = key
 #eturn (
 #elf._adapter.traverse(elem)
 #_annotate(d)
 #_set_propagate_attrs(
 #"compile_state_plugin": "orm", "plugin_subject": self}
 #
 #

 #ef _entity_for_mapper(self, mapper):
 #elf_poly = self.with_polymorphic_mappers
 #f mapper in self_poly:
 #f mapper is self.mapper:
 #eturn self
 #lse:
 #eturn getattr(
 #elf.entity, mapper.class_.__name__
 #._aliased_insp
 #lif mapper.isa(self.mapper):
 #eturn self
 #lse:
 #ssert False, "mapper %s doesn't correspond to %s" % (mapper, self)

 #util.memoized_property
 #ef _get_clause(self):
 #nclause, replacemap = self.mapper._get_clause
 #eturn (
 #elf._adapter.traverse(onclause),
 #
 #elf._adapter.traverse(col): param
 #or col, param in replacemap.items()
 #,
 #

 #util.memoized_property
 #ef _memoized_values(self):
 #eturn {}

 #util.memoized_property
 #ef _all_column_expressions(self):
 #f self._is_with_polymorphic:
 #ols_plus_keys = self.mapper._columns_plus_keys(
 #ent.mapper for ent in self._with_polymorphic_entities]
 #
 #lse:
 #ols_plus_keys = self.mapper._columns_plus_keys()

 #ols_plus_keys = [
 #key, self._adapt_element(col)) for key, col in cols_plus_keys
 #

 #eturn ColumnCollection(cols_plus_keys)

 #ef _memo(self, key, callable_, *args, **kw):
 #f key in self._memoized_values:
 #eturn self._memoized_values[key]
 #lse:
 #elf._memoized_values[key] = value = callable_(*args, **kw)
 #eturn value

 #ef __repr__(self):
 #f self.with_polymorphic_mappers:
 #ith_poly = "(%s)" % ", ".join(
 #p.class_.__name__ for mp in self.with_polymorphic_mappers
 #
 #lse:
 #ith_poly = ""
 #eturn "<AliasedInsp at 0x%x; %s%s>" % (
 #d(self),
 #elf.class_.__name__,
 #ith_poly,
 #

 #ef __str__(self):
 #f self._is_with_polymorphic:
 #eturn "with_polymorphic(%s, [%s])" % (
 #elf._target.__name__,
 #, ".join(
 #p.class_.__name__
 #or mp in self.with_polymorphic_mappers
 #f mp is not self.mapper
 #,
 #
 #lse:
 #eturn "aliased(%s)" % (self._target.__name__,)


class _WrapUserEntity(object):
 #""A wrapper used within the loader_criteria lambda caller so that
 #e can bypass declared_attr descriptors on unmapped mixins, which
 #ormally emit a warning for such use.

 #ight also be useful for other per-lambda instrumentations should
 #he need arise.

 #""

 #ef __init__(self, subject):
 #elf.subject = subject

 #util.preload_module("sqlalchemy.orm.decl_api")
 #ef __getattribute__(self, name):
 #ecl_api = util.preloaded.orm.decl_api

 #ubject = object.__getattribute__(self, "subject")
 #f name in subject.__dict__ and isinstance(
 #ubject.__dict__[name], decl_api.declared_attr
 #:
 #eturn subject.__dict__[name].fget(subject)
 #lse:
 #eturn getattr(subject, name)


class LoaderCriteriaOption(CriteriaOption):
 #""Add additional WHERE criteria to the load for all occurrences of
 # particular entity.

 #class:`_orm.LoaderCriteriaOption` is invoked using the
 #func:`_orm.with_loader_criteria` function; see that function for
 #etails.

 #. versionadded:: 1.4

 #""

 #traverse_internals = [
 #"root_entity", visitors.ExtendedInternalTraversal.dp_plain_obj),
 #"entity", visitors.ExtendedInternalTraversal.dp_has_cache_key),
 #"where_criteria", visitors.InternalTraversal.dp_clauseelement),
 #"include_aliases", visitors.InternalTraversal.dp_boolean),
 #"propagate_to_loaders", visitors.InternalTraversal.dp_boolean),
 #

 #ef __init__(
 #elf,
 #ntity_or_base,
 #here_criteria,
 #oader_only=False,
 #nclude_aliases=False,
 #ropagate_to_loaders=True,
 #rack_closure_variables=True,
 #:
 #""Add additional WHERE criteria to the load for all occurrences of
 # particular entity.

 #. versionadded:: 1.4

 #he :func:`_orm.with_loader_criteria` option is intended to add
 #imiting criteria to a particular kind of entity in a query,
 #*globally**, meaning it will apply to the entity as it appears
 #n the SELECT query as well as within any subqueries, join
 #onditions, and relationship loads, including both eager and lazy
 #oaders, without the need for it to be specified in any particular
 #art of the query.    The rendering logic uses the same system used by
 #ingle table inheritance to ensure a certain discriminator is applied
 #o a table.

 #.g., using :term:`2.0-style` queries, we can limit the way the
 #`User.addresses`` collection is loaded, regardless of the kind
 #f loading used::

 #rom sqlalchemy.orm import with_loader_criteria

 #tmt = select(User).options(
 #electinload(User.addresses),
 #ith_loader_criteria(Address, Address.email_address != 'foo'))
 #

 #bove, the "selectinload" for ``User.addresses`` will apply the
 #iven filtering criteria to the WHERE clause.

 #nother example, where the filtering will be applied to the
 #N clause of the join, in this example using :term:`1.x style`
 #ueries::

 # = session.query(User).outerjoin(User.addresses).options(
 #ith_loader_criteria(Address, Address.email_address != 'foo'))
 #

 #he primary purpose of :func:`_orm.with_loader_criteria` is to use
 #t in the :meth:`_orm.SessionEvents.do_orm_execute` event handler
 #o ensure that all occurrences of a particular entity are filtered
 #n a certain way, such as filtering for access control roles.    It
 #lso can be used to apply criteria to relationship loads.  In the
 #xample below, we can apply a certain set of rules to all queries
 #mitted by a particular :class:`_orm.Session`::

 #ession = Session(bind=engine)

 #event.listens_for("do_orm_execute", session)
 #ef _add_filtering_criteria(execute_state):

 #f (
 #xecute_state.is_select
 #nd not execute_state.is_column_load
 #nd not execute_state.is_relationship_load
 #:
 #xecute_state.statement = execute_state.statement.options(
 #ith_loader_criteria(
 #ecurityRole,
 #ambda cls: cls.role.in_(['some_role']),
 #nclude_aliases=True
 #
 #

 #n the above example, the :meth:`_orm.SessionEvents.do_orm_execute`
 #vent will intercept all queries emitted using the
 #class:`_orm.Session`. For those queries which are SELECT statements
 #nd are not attribute or relationship loads a custom
 #func:`_orm.with_loader_criteria` option is added to the query.    The
 #func:`_orm.with_loader_criteria` option will be used in the given
 #tatement and will also be automatically propagated to all relationship
 #oads that descend from this query.

 #he criteria argument given is a ``lambda`` that accepts a ``cls``
 #rgument.  The given class will expand to include all mapped subclass
 #nd need not itself be a mapped class.

 #. warning:: The use of a lambda inside of the call to
 #func:`_orm.with_loader_criteria` is only invoked **once per unique
 #lass**. Custom functions should not be invoked within this lambda.
 #ee :ref:`engine_lambda_caching` for an overview of the "lambda SQL"
 #eature, which is for advanced use only.

 #param entity_or_base: a mapped class, or a class that is a super
 #lass of a particular set of mapped classes, to which the rule
 #ill apply.

 #param where_criteria: a Core SQL expression that applies limiting
 #riteria.   This may also be a "lambda:" or Python function that
 #ccepts a target class as an argument, when the given class is
 # base with many different mapped subclasses.

 #param include_aliases: if True, apply the rule to :func:`_orm.aliased`
 #onstructs as well.

 #param propagate_to_loaders: defaults to True, apply to relationship
 #oaders such as lazy loaders.


 #. seealso::

 #ref:`examples_session_orm_events` - includes examples of using
 #func:`_orm.with_loader_criteria`.

 #ref:`do_orm_execute_global_criteria` - basic example on how to
 #ombine :func:`_orm.with_loader_criteria` with the
 #meth:`_orm.SessionEvents.do_orm_execute` event.

 #param track_closure_variables: when False, closure variables inside
 #f a lambda expression will not be used as part of
 #ny cache key.    This allows more complex expressions to be used
 #nside of a lambda expression but requires that the lambda ensures
 #t returns the identical SQL every time given a particular class.

 #. versionadded:: 1.4.0b2

 #""
 #ntity = inspection.inspect(entity_or_base, False)
 #f entity is None:
 #elf.root_entity = entity_or_base
 #elf.entity = None
 #lse:
 #elf.root_entity = None
 #elf.entity = entity

 #f callable(where_criteria):
 #elf.deferred_where_criteria = True
 #elf.where_criteria = lambdas.DeferredLambdaElement(
 #here_criteria,
 #oles.WhereHavingRole,
 #ambda_args=(
 #WrapUserEntity(
 #elf.root_entity
 #f self.root_entity is not None
 #lse self.entity.entity,
 #,
 #,
 #pts=lambdas.LambdaOptions(
 #rack_closure_variables=track_closure_variables
 #,
 #
 #lse:
 #elf.deferred_where_criteria = False
 #elf.where_criteria = coercions.expect(
 #oles.WhereHavingRole, where_criteria
 #

 #elf.include_aliases = include_aliases
 #elf.propagate_to_loaders = propagate_to_loaders

 #ef _all_mappers(self):
 #f self.entity:
 #or ent in self.entity.mapper.self_and_descendants:
 #ield ent
 #lse:
 #tack = list(self.root_entity.__subclasses__())
 #hile stack:
 #ubclass = stack.pop(0)
 #nt = inspection.inspect(subclass, raiseerr=False)
 #f ent:
 #or mp in ent.mapper.self_and_descendants:
 #ield mp
 #lse:
 #tack.extend(subclass.__subclasses__())

 #ef _resolve_where_criteria(self, ext_info):
 #f self.deferred_where_criteria:
 #eturn self.where_criteria._resolve_with_args(ext_info.entity)
 #lse:
 #eturn self.where_criteria

 #ef process_compile_state(self, compile_state):
 #""Apply a modification to a given :class:`.CompileState`."""

        # if options to limit the criteria to immediate query only,
        # use compile_state.attributes instead

 #f compile_state.compile_options._with_polymorphic_adapt_map:
 #til.warn(
 #The with_loader_criteria() function may not work "
 #correctly with the legacy Query.with_polymorphic() feature.  "
 #Please migrate code to use the with_polymorphic() standalone "
 #function before using with_loader_criteria()."
 #
 #f not compile_state.compile_options._for_refresh_state:
 #elf.get_global_criteria(compile_state.global_attributes)

 #ef get_global_criteria(self, attributes):
 #or mp in self._all_mappers():
 #oad_criteria = attributes.setdefault(
 #"additional_entity_criteria", mp), []
 #

 #oad_criteria.append(self)


inspection._inspects(AliasedClass)(lambda target: target._aliased_insp)
inspection._inspects(AliasedInsp)(lambda target: target)


def aliased(element, alias=None, name=None, flat=False, adapt_on_names=False):
 #""Produce an alias of the given element, usually an :class:`.AliasedClass`
 #nstance.

 #.g.::

 #y_alias = aliased(MyClass)

 #ession.query(MyClass, my_alias).filter(MyClass.id > my_alias.id)

 #he :func:`.aliased` function is used to create an ad-hoc mapping of a
 #apped class to a new selectable.  By default, a selectable is generated
 #rom the normally mapped selectable (typically a :class:`_schema.Table`
 # using the
 #meth:`_expression.FromClause.alias` method. However, :func:`.aliased`
 #an also be
 #sed to link the class to a new :func:`_expression.select` statement.
 #lso, the :func:`.with_polymorphic` function is a variant of
 #func:`.aliased` that is intended to specify a so-called "polymorphic
 #electable", that corresponds to the union of several joined-inheritance
 #ubclasses at once.

 #or convenience, the :func:`.aliased` function also accepts plain
 #class:`_expression.FromClause` constructs, such as a
 #class:`_schema.Table` or
 #func:`_expression.select` construct.   In those cases, the
 #meth:`_expression.FromClause.alias`
 #ethod is called on the object and the new
 #class:`_expression.Alias` object returned.  The returned
 #class:`_expression.Alias` is not
 #RM-mapped in this case.

 #param element: element to be aliased.  Is normally a mapped class,
 #ut for convenience can also be a :class:`_expression.FromClause`
 #lement.

 #param alias: Optional selectable unit to map the element to.  This is
 #sually used to link the object to a subquery, and should be an aliased
 #elect construct as one would produce from the
 #meth:`_query.Query.subquery` method or
 #he :meth:`_expression.Select.subquery` or
 #meth:`_expression.Select.alias` methods of the :func:`_expression.select`
 #onstruct.

 #param name: optional string name to use for the alias, if not specified
 #y the ``alias`` parameter.  The name, among other things, forms the
 #ttribute name that will be accessible via tuples returned by a
 #class:`_query.Query` object.  Not supported when creating aliases
 #f :class:`_sql.Join` objects.

 #param flat: Boolean, will be passed through to the
 #meth:`_expression.FromClause.alias` call so that aliases of
 #class:`_expression.Join` objects will alias the individual tables
 #nside the join, rather than creating a subquery.  This is generally
 #upported by all modern databases with regards to right-nested joins
 #nd generally produces more efficient queries.

 #param adapt_on_names: if True, more liberal "matching" will be used when
 #apping the mapped columns of the ORM entity to those of the
 #iven selectable - a name-based match will be performed if the
 #iven selectable doesn't otherwise have a column that corresponds
 #o one on the entity.  The use case for this is when associating
 #n entity with some derived selectable such as one that uses
 #ggregate functions::

 #lass UnitPrice(Base):
 #_tablename__ = 'unit_price'
 #..
 #nit_id = Column(Integer)
 #rice = Column(Numeric)

 #ggregated_unit_price = Session.query(
 #unc.sum(UnitPrice.price).label('price')
 #.group_by(UnitPrice.unit_id).subquery()

 #ggregated_unit_price = aliased(UnitPrice,
 #lias=aggregated_unit_price, adapt_on_names=True)

 #bove, functions on ``aggregated_unit_price`` which refer to
 #`.price`` will return the
 #`func.sum(UnitPrice.price).label('price')`` column, as it is
 #atched on the name "price".  Ordinarily, the "price" function
 #ouldn't have any "column correspondence" to the actual
 #`UnitPrice.price`` column as it is not a proxy of the original.

 #""
 #f isinstance(element, expression.FromClause):
 #f adapt_on_names:
 #aise sa_exc.ArgumentError(
 #adapt_on_names only applies to ORM elements"
 #
 #f name:
 #eturn element.alias(name=name, flat=flat)
 #lse:
 #eturn coercions.expect(
 #oles.AnonymizedFromClauseRole, element, flat=flat
 #
 #lse:
 #eturn AliasedClass(
 #lement,
 #lias=alias,
 #lat=flat,
 #ame=name,
 #dapt_on_names=adapt_on_names,
 #


def with_polymorphic(
 #ase,
 #lasses,
 #electable=False,
 #lat=False,
 #olymorphic_on=None,
 #liased=False,
 #nnerjoin=False,
 #use_mapper_path=False,
 #existing_alias=None,
):
 #""Produce an :class:`.AliasedClass` construct which specifies
 #olumns for descendant mappers of the given base.

 #sing this method will ensure that each descendant mapper's
 #ables are included in the FROM clause, and will allow filter()
 #riterion to be used against those tables.  The resulting
 #nstances will also have those columns already loaded so that
 #o "post fetch" of those columns will be required.

 #. seealso::

 #ref:`with_polymorphic` - full discussion of
 #func:`_orm.with_polymorphic`.

 #param base: Base class to be aliased.

 #param classes: a single class or mapper, or list of
 #lass/mappers, which inherit from the base class.
 #lternatively, it may also be the string ``'*'``, in which case
 #ll descending mapped classes will be added to the FROM clause.

 #param aliased: when True, the selectable will be aliased.   For a
 #OIN, this means the JOIN will be SELECTed from inside of a subquery
 #nless the :paramref:`_orm.with_polymorphic.flat` flag is set to
 #rue, which is recommended for simpler use cases.

 #param flat: Boolean, will be passed through to the
 #meth:`_expression.FromClause.alias` call so that aliases of
 #class:`_expression.Join` objects will alias the individual tables
 #nside the join, rather than creating a subquery.  This is generally
 #upported by all modern databases with regards to right-nested joins
 #nd generally produces more efficient queries.  Setting this flag is
 #ecommended as long as the resulting SQL is functional.

 #param selectable: a table or subquery that will
 #e used in place of the generated FROM clause. This argument is
 #equired if any of the desired classes use concrete table
 #nheritance, since SQLAlchemy currently cannot generate UNIONs
 #mong tables automatically. If used, the ``selectable`` argument
 #ust represent the full set of tables and columns mapped by every
 #apped class. Otherwise, the unaccounted mapped columns will
 #esult in their table being appended directly to the FROM clause
 #hich will usually lead to incorrect results.

 #param polymorphic_on: a column to be used as the "discriminator"
 #olumn for the given selectable. If not given, the polymorphic_on
 #ttribute of the base classes' mapper will be used, if any. This
 #s useful for mappings that don't have polymorphic loading
 #ehavior by default.

 #param innerjoin: if True, an INNER JOIN will be used.  This should
 #nly be specified if querying for one specific subtype only
 #""
 #rimary_mapper = _class_to_mapper(base)

 #f selectable not in (None, False) and flat:
 #aise sa_exc.ArgumentError(
 #the 'flat' and 'selectable' arguments cannot be passed "
 #simultaneously to with_polymorphic()"
 #

 #f _existing_alias:
 #ssert _existing_alias.mapper is primary_mapper
 #lasses = util.to_set(classes)
 #ew_classes = set(
 #mp.class_ for mp in _existing_alias.with_polymorphic_mappers]
 #
 #f classes == new_classes:
 #eturn _existing_alias
 #lse:
 #lasses = classes.union(new_classes)
 #appers, selectable = primary_mapper._with_polymorphic_args(
 #lasses, selectable, innerjoin=innerjoin
 #
 #f aliased or flat:
 #electable = selectable._anonymous_fromclause(flat=flat)
 #eturn AliasedClass(
 #ase,
 #electable,
 #ith_polymorphic_mappers=mappers,
 #ith_polymorphic_discriminator=polymorphic_on,
 #se_mapper_path=_use_mapper_path,
 #epresents_outer_join=not innerjoin,
 #


@inspection._self_inspects
class Bundle(ORMColumnsClauseRole, SupportsCloneAnnotations, InspectionAttr):
 #""A grouping of SQL expressions that are returned by a :class:`.Query`
 #nder one namespace.

 #he :class:`.Bundle` essentially allows nesting of the tuple-based
 #esults returned by a column-oriented :class:`_query.Query` object.
 #t also
 #s extensible via simple subclassing, where the primary capability
 #o override is that of how the set of expressions should be returned,
 #llowing post-processing as well as custom return types, without
 #nvolving ORM identity-mapped classes.

 #. versionadded:: 0.9.0

 #. seealso::

 #ref:`bundles`


 #""

 #ingle_entity = False
 #""If True, queries for a single Bundle will be returned as a single
 #ntity, rather than an element within a keyed tuple."""

 #s_clause_element = False

 #s_mapper = False

 #s_aliased_class = False

 #s_bundle = True

 #propagate_attrs = util.immutabledict()

 #ef __init__(self, name, *exprs, **kw):
 #"""Construct a new :class:`.Bundle`.

 #.g.::

 #n = Bundle("mybundle", MyClass.x, MyClass.y)

 #or row in session.query(bn).filter(
 #n.c.x == 5).filter(bn.c.y == 4):
 #rint(row.mybundle.x, row.mybundle.y)

 #param name: name of the bundle.
 #param \*exprs: columns or SQL expressions comprising the bundle.
 #param single_entity=False: if True, rows for this :class:`.Bundle`
 #an be returned as a "single entity" outside of any enclosing tuple
 #n the same manner as a mapped entity.

 #""
 #elf.name = self._label = name
 #elf.exprs = exprs = [
 #oercions.expect(
 #oles.ColumnsClauseRole, expr, apply_propagate_attrs=self
 #
 #or expr in exprs
 #

 #elf.c = self.columns = ColumnCollection(
 #getattr(col, "key", col._label), col)
 #or col in [e._annotations.get("bundle", e) for e in exprs]
 #
 #elf.single_entity = kw.pop("single_entity", self.single_entity)

 #property
 #ef mapper(self):
 #eturn self.exprs[0]._annotations.get("parentmapper", None)

 #property
 #ef entity(self):
 #eturn self.exprs[0]._annotations.get("parententity", None)

 #property
 #ef entity_namespace(self):
 #eturn self.c

 #olumns = None
 #""A namespace of SQL expressions referred to by this :class:`.Bundle`.

 #.g.::

 #n = Bundle("mybundle", MyClass.x, MyClass.y)

 # = sess.query(bn).filter(bn.c.x == 5)

 #esting of bundles is also supported::

 #1 = Bundle("b1",
 #undle('b2', MyClass.a, MyClass.b),
 #undle('b3', MyClass.x, MyClass.y)
 #

 # = sess.query(b1).filter(
 #1.c.b2.c.a == 5).filter(b1.c.b3.c.y == 9)

 #. seealso::

 #attr:`.Bundle.c`

 #""

 # = None
 #""An alias for :attr:`.Bundle.columns`."""

 #ef _clone(self):
 #loned = self.__class__.__new__(self.__class__)
 #loned.__dict__.update(self.__dict__)
 #eturn cloned

 #ef __clause_element__(self):
        # ensure existing entity_namespace remains
 #nnotations = {"bundle": self, "entity_namespace": self}
 #nnotations.update(self._annotations)

 #lugin_subject = self.exprs[0]._propagate_attrs.get(
 #plugin_subject", self.entity
 #
 #eturn (
 #xpression.ClauseList(
 #literal_as_text_role=roles.ColumnsClauseRole,
 #roup=False,
 #[e._annotations.get("bundle", e) for e in self.exprs]
 #
 #_annotate(annotations)
 #_set_propagate_attrs(
                # the Bundle *must* use the orm plugin no matter what.  the
                # subject can be None but it's much better if it's not.
 #
 #compile_state_plugin": "orm",
 #plugin_subject": plugin_subject,
 #
 #
 #

 #property
 #ef clauses(self):
 #eturn self.__clause_element__().clauses

 #ef label(self, name):
 #""Provide a copy of this :class:`.Bundle` passing a new label."""

 #loned = self._clone()
 #loned.name = name
 #eturn cloned

 #ef create_row_processor(self, query, procs, labels):
 #""Produce the "row processing" function for this :class:`.Bundle`.

 #ay be overridden by subclasses.

 #. seealso::

 #ref:`bundles` - includes an example of subclassing.

 #""
 #eyed_tuple = result_tuple(labels, [() for l in labels])

 #ef proc(row):
 #eturn keyed_tuple([proc(row) for proc in procs])

 #eturn proc


def _orm_annotate(element, exclude=None):
 #""Deep copy the given ClauseElement, annotating each element with the
 #_orm_adapt" flag.

 #lements within the exclude collection will be cloned but not annotated.

 #""
 #eturn sql_util._deep_annotate(element, {"_orm_adapt": True}, exclude)


def _orm_deannotate(element):
 #""Remove annotations that link a column to a particular mapping.

 #ote this doesn't affect "remote" and "foreign" annotations
 #assed by the :func:`_orm.foreign` and :func:`_orm.remote`
 #nnotators.

 #""

 #eturn sql_util._deep_deannotate(
 #lement, values=("_orm_adapt", "parententity")
 #


def _orm_full_deannotate(element):
 #eturn sql_util._deep_deannotate(element)


class _ORMJoin(expression.Join):
 #""Extend Join to support ORM constructs as input."""

 #_visit_name__ = expression.Join.__visit_name__

 #nherit_cache = True

 #ef __init__(
 #elf,
 #eft,
 #ight,
 #nclause=None,
 #souter=False,
 #ull=False,
 #left_memo=None,
 #right_memo=None,
 #extra_criteria=(),
 #:
 #eft_info = inspection.inspect(left)

 #ight_info = inspection.inspect(right)
 #dapt_to = right_info.selectable

        # used by joined eager loader
 #elf._left_memo = _left_memo
 #elf._right_memo = _right_memo

        # legacy, for string attr name ON clause.  if that's removed
        # then the "_joined_from_info" concept can go
 #eft_orm_info = getattr(left, "_joined_from_info", left_info)
 #elf._joined_from_info = right_info
 #f isinstance(onclause, util.string_types):
 #nclause = getattr(left_orm_info.entity, onclause)
        # ####

 #f isinstance(onclause, attributes.QueryableAttribute):
 #n_selectable = onclause.comparator._source_selectable()
 #rop = onclause.property
 #extra_criteria += onclause._extra_criteria
 #lif isinstance(onclause, MapperProperty):
            # used internally by joined eager loader...possibly not ideal
 #rop = onclause
 #n_selectable = prop.parent.selectable
 #lse:
 #rop = None

 #f prop:
 #eft_selectable = left_info.selectable

 #f sql_util.clause_is_present(on_selectable, left_selectable):
 #dapt_from = on_selectable
 #lse:
 #dapt_from = left_selectable

 #
 #j,
 #j,
 #ource,
 #est,
 #econdary,
 #arget_adapter,
 # = prop._create_joins(
 #ource_selectable=adapt_from,
 #est_selectable=adapt_to,
 #ource_polymorphic=True,
 #f_type_entity=right_info,
 #lias_secondary=True,
 #xtra_criteria=_extra_criteria,
 #

 #f sj is not None:
 #f isouter:
                    # note this is an inner join from secondary->right
 #ight = sql.join(secondary, right, sj)
 #nclause = pj
 #lse:
 #eft = sql.join(left, secondary, pj, isouter)
 #nclause = sj
 #lse:
 #nclause = pj

 #elf._target_adapter = target_adapter

 #xpression.Join.__init__(self, left, right, onclause, isouter, full)

 #f (
 #ot prop
 #nd getattr(right_info, "mapper", None)
 #nd right_info.mapper.single
 #:
            # if single inheritance target and we are using a manual
            # or implicit ON clause, augment it the same way we'd augment the
            # WHERE.
 #ingle_crit = right_info.mapper._single_table_criterion
 #f single_crit is not None:
 #f right_info.is_aliased_class:
 #ingle_crit = right_info._adapter.traverse(single_crit)
 #elf.onclause = self.onclause & single_crit

 #ef _splice_into_center(self, other):
 #""Splice a join into the center.

 #iven join(a, b) and join(b, c), return join(a, b).join(c)

 #""
 #eftmost = other
 #hile isinstance(leftmost, sql.Join):
 #eftmost = leftmost.left

 #ssert self.right is leftmost

 #eft = _ORMJoin(
 #elf.left,
 #ther.left,
 #elf.onclause,
 #souter=self.isouter,
 #left_memo=self._left_memo,
 #right_memo=other._left_memo,
 #

 #eturn _ORMJoin(
 #eft,
 #ther.right,
 #ther.onclause,
 #souter=other.isouter,
 #right_memo=other._right_memo,
 #

 #ef join(
 #elf,
 #ight,
 #nclause=None,
 #souter=False,
 #ull=False,
 #oin_to_left=None,
 #:
 #eturn _ORMJoin(self, right, onclause, full=full, isouter=isouter)

 #ef outerjoin(self, right, onclause=None, full=False, join_to_left=None):
 #eturn _ORMJoin(self, right, onclause, isouter=True, full=full)


def join(
 #eft, right, onclause=None, isouter=False, full=False, join_to_left=None
):
 #"""Produce an inner join between left and right clauses.

 #func:`_orm.join` is an extension to the core join interface
 #rovided by :func:`_expression.join()`, where the
 #eft and right selectables may be not only core selectable
 #bjects such as :class:`_schema.Table`, but also mapped classes or
 #class:`.AliasedClass` instances.   The "on" clause can
 #e a SQL expression, or an attribute or string name
 #eferencing a configured :func:`_orm.relationship`.

 #func:`_orm.join` is not commonly needed in modern usage,
 #s its functionality is encapsulated within that of the
 #meth:`_query.Query.join` method, which features a
 #ignificant amount of automation beyond :func:`_orm.join`
 #y itself.  Explicit usage of :func:`_orm.join`
 #ith :class:`_query.Query` involves usage of the
 #meth:`_query.Query.select_from` method, as in::

 #rom sqlalchemy.orm import join
 #ession.query(User).\
 #elect_from(join(User, Address, User.addresses)).\
 #ilter(Address.email_address=='foo@bar.com')

 #n modern SQLAlchemy the above join can be written more
 #uccinctly as::

 #ession.query(User).\
 #oin(User.addresses).\
 #ilter(Address.email_address=='foo@bar.com')

 #ee :meth:`_query.Query.join` for information on modern usage
 #f ORM level joins.

 #. deprecated:: 0.8

 #he ``join_to_left`` parameter is deprecated, and will be removed
 #n a future release.  The parameter has no effect.

 #""
 #eturn _ORMJoin(left, right, onclause, isouter, full)


def outerjoin(left, right, onclause=None, full=False, join_to_left=None):
 #""Produce a left outer join between left and right clauses.

 #his is the "outer join" version of the :func:`_orm.join` function,
 #eaturing the same behavior except that an OUTER JOIN is generated.
 #ee that function's documentation for other usage details.

 #""
 #eturn _ORMJoin(left, right, onclause, True, full)


def with_parent(instance, prop, from_entity=None):
 #""Create filtering criterion that relates this query's primary entity
 #o the given related instance, using established
 #func:`_orm.relationship()`
 #onfiguration.

 #.g.::

 #tmt = select(Address).where(with_parent(some_user, Address.user))


 #he SQL rendered is the same as that rendered when a lazy loader
 #ould fire off from the given parent on that attribute, meaning
 #hat the appropriate state is taken from the parent object in
 #ython without the need to render joins to the parent table
 #n the rendered statement.

 #he given property may also make use of :meth:`_orm.PropComparator.of_type`
 #o indicate the left side of the criteria::


 #1 = aliased(Address)
 #2 = aliased(Address)
 #tmt = select(a1, a2).where(
 #ith_parent(u1, User.addresses.of_type(a2))
 #

 #he above use is equivalent to using the
 #func:`_orm.with_parent.from_entity` argument::

 #1 = aliased(Address)
 #2 = aliased(Address)
 #tmt = select(a1, a2).where(
 #ith_parent(u1, User.addresses, from_entity=a2)
 #

 #param instance:
 #n instance which has some :func:`_orm.relationship`.

 #param property:
 #tring property name, or class-bound attribute, which indicates
 #hat relationship from the instance should be used to reconcile the
 #arent/child relationship.

 #. deprecated:: 1.4 Using strings is deprecated and will be removed
 #n SQLAlchemy 2.0.  Please use the class-bound attribute directly.

 #param from_entity:
 #ntity in which to consider as the left side.  This defaults to the
 #zero" entity of the :class:`_query.Query` itself.

 #. versionadded:: 1.2

 #""
 #f isinstance(prop, util.string_types):
 #til.warn_deprecated_20(
 #Using strings to indicate relationship names in the ORM "
 #with_parent() function is deprecated and will be removed "
 #SQLAlchemy 2.0.  Please use the class-bound attribute directly."
 #
 #apper = object_mapper(instance)
 #rop = getattr(mapper.class_, prop).property
 #lif isinstance(prop, attributes.QueryableAttribute):
 #f prop._of_type:
 #rom_entity = prop._of_type
 #rop = prop.property

 #eturn prop._with_parent(instance, from_entity=from_entity)


def has_identity(object_):
 #""Return True if the given object has a database
 #dentity.

 #his typically corresponds to the object being
 #n either the persistent or detached state.

 #. seealso::

 #func:`.was_deleted`

 #""
 #tate = attributes.instance_state(object_)
 #eturn state.has_identity


def was_deleted(object_):
 #""Return True if the given object was deleted
 #ithin a session flush.

 #his is regardless of whether or not the object is
 #ersistent or detached.

 #. seealso::

 #attr:`.InstanceState.was_deleted`

 #""

 #tate = attributes.instance_state(object_)
 #eturn state.was_deleted


def _entity_corresponds_to(given, entity):
 #""determine if 'given' corresponds to 'entity', in terms
 #f an entity passed to Query that would match the same entity
 #eing referred to elsewhere in the query.

 #""
 #f entity.is_aliased_class:
 #f given.is_aliased_class:
 #f entity._base_alias() is given._base_alias():
 #eturn True
 #eturn False
 #lif given.is_aliased_class:
 #f given._use_mapper_path:
 #eturn entity in given.with_polymorphic_mappers
 #lse:
 #eturn entity is given

 #eturn entity.common_parent(given)


def _entity_corresponds_to_use_path_impl(given, entity):
 #""determine if 'given' corresponds to 'entity', in terms
 #f a path of loader options where a mapped attribute is taken to
 #e a member of a parent entity.

 #.g.::

 #omeoption(A).someoption(A.b)  # -> fn(A, A) -> True
 #omeoption(A).someoption(C.d)  # -> fn(A, C) -> False

 #1 = aliased(A)
 #omeoption(a1).someoption(A.b) # -> fn(a1, A) -> False
 #omeoption(a1).someoption(a1.b) # -> fn(a1, a1) -> True

 #p = with_polymorphic(A, [A1, A2])
 #omeoption(wp).someoption(A1.foo)  # -> fn(wp, A1) -> False
 #omeoption(wp).someoption(wp.A1.foo)  # -> fn(wp, wp.A1) -> True


 #""
 #f given.is_aliased_class:
 #eturn (
 #ntity.is_aliased_class
 #nd not entity._use_mapper_path
 #nd (given is entity or given in entity._with_polymorphic_entities)
 #
 #lif not entity.is_aliased_class:
 #eturn given.common_parent(entity.mapper)
 #lse:
 #eturn (
 #ntity._use_mapper_path
 #nd given in entity.with_polymorphic_mappers
 #


def _entity_isa(given, mapper):
 #""determine if 'given' "is a" mapper, in terms of the given
 #ould load rows of type 'mapper'.

 #""
 #f given.is_aliased_class:
 #eturn mapper in given.with_polymorphic_mappers or given.mapper.isa(
 #apper
 #
 #lif given.with_polymorphic_mappers:
 #eturn mapper in given.with_polymorphic_mappers
 #lse:
 #eturn given.isa(mapper)


def randomize_unitofwork():
 #""Use random-ordering sets within the unit of work in order
 #o detect unit of work sorting issues.

 #his is a utility function that can be used to help reproduce
 #nconsistent unit of work sorting issues.   For example,
 #f two kinds of objects A and B are being inserted, and
 # has a foreign key reference to A - the A must be inserted first.
 #owever, if there is no relationship between A and B, the unit of work
 #on't know to perform this sorting, and an operation may or may not
 #ail, depending on how the ordering works out.   Since Python sets
 #nd dictionaries have non-deterministic ordering, such an issue may
 #ccur on some runs and not on others, and in practice it tends to
 #ave a great dependence on the state of the interpreter.  This leads
 #o so-called "heisenbugs" where changing entirely irrelevant aspects
 #f the test program still cause the failure behavior to change.

 #y calling ``randomize_unitofwork()`` when a script first runs, the
 #rdering of a key series of sets within the unit of work implementation
 #re randomized, so that the script can be minimized down to the
 #undamental mapping and operation that's failing, while still reproducing
 #he issue on at least some runs.

 #his utility is also available when running the test suite via the
 #`--reversetop`` flag.

 #""
 #rom sqlalchemy.orm import unitofwork, session, mapper, dependency
 #rom sqlalchemy.util import topological
 #rom sqlalchemy.testing.util import RandomSet

 #opological.set = (
 #nitofwork.set
 # = session.set = mapper.set = dependency.set = RandomSet


def _getitem(iterable_query, item, allow_negative):
 #""calculate __getitem__ in terms of an iterable query object
 #hat also has a slice() method.

 #""

 #ef _no_negative_indexes():
 #f not allow_negative:
 #aise IndexError(
 #negative indexes are not accepted by SQL "
 #index / slice operators"
 #
 #lse:
 #til.warn_deprecated_20(
 #Support for negative indexes for SQL index / slice operators "
 #will be "
 #removed in 2.0; these operators fetch the complete result "
 #and do not work efficiently."
 #

 #f isinstance(item, slice):
 #tart, stop, step = util.decode_slice(item)

 #f (
 #sinstance(stop, int)
 #nd isinstance(start, int)
 #nd stop - start <= 0
 #:
 #eturn []

 #lif (isinstance(start, int) and start < 0) or (
 #sinstance(stop, int) and stop < 0
 #:
 #no_negative_indexes()
 #eturn list(iterable_query)[item]

 #es = iterable_query.slice(start, stop)
 #f step is not None:
 #eturn list(res)[None : None : item.step]
 #lse:
 #eturn list(res)
 #lse:
 #f item == -1:
 #no_negative_indexes()
 #eturn list(iterable_query)[-1]
 #lse:
 #eturn list(iterable_query[item : item + 1])[0]
