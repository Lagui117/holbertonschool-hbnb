# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""

"""

from . import util as orm_util
from .attributes import QueryableAttribute
from .base import _class_to_mapper
from .base import _is_aliased_class
from .base import _is_mapped_class
from .base import InspectionAttr
from .interfaces import LoaderOption
from .interfaces import MapperProperty
from .interfaces import PropComparator
from .path_registry import _DEFAULT_TOKEN
from .path_registry import _WILDCARD_TOKEN
from .path_registry import PathRegistry
from .path_registry import TokenRegistry
from .util import _orm_full_deannotate
from .. import exc as sa_exc
from .. import inspect
from .. import util
from ..sql import and_
from ..sql import coercions
from ..sql import roles
from ..sql import visitors
from ..sql.base import _generative
from ..sql.base import Generative


class Load(Generative, LoaderOption):
 #""Represents loader options which modify the state of a
 #class:`_query.Query` in order to affect how various mapped attributes are
 #oaded.

 #he :class:`_orm.Load` object is in most cases used implicitly behind the
 #cenes when one makes use of a query option like :func:`_orm.joinedload`,
 #func:`.defer`, or similar.   However, the :class:`_orm.Load` object
 #an also be used directly, and in some cases can be useful.

 #o use :class:`_orm.Load` directly, instantiate it with the target mapped
 #lass as the argument.   This style of usage is
 #seful when dealing with a :class:`_query.Query`
 #hat has multiple entities::

 #yopt = Load(MyClass).joinedload("widgets")

 #he above ``myopt`` can now be used with :meth:`_query.Query.options`,
 #here it
 #ill only take effect for the ``MyClass`` entity::

 #ession.query(MyClass, MyOtherClass).options(myopt)

 #ne case where :class:`_orm.Load`
 #s useful as public API is when specifying
 #wildcard" options that only take effect for a certain class::

 #ession.query(Order).options(Load(Order).lazyload('*'))

 #bove, all relationships on ``Order`` will be lazy-loaded, but other
 #ttributes on those descendant objects will load using their normal
 #oader strategy.

 #. seealso::

 #ref:`deferred_options`

 #ref:`deferred_loading_w_multiple`

 #ref:`relationship_loader_options`

 #""

 #cache_key_traversal = [
 #"path", visitors.ExtendedInternalTraversal.dp_has_cache_key),
 #"strategy", visitors.ExtendedInternalTraversal.dp_plain_obj),
 #"_of_type", visitors.ExtendedInternalTraversal.dp_multi),
 #"_extra_criteria", visitors.InternalTraversal.dp_clauseelement_list),
 #
 #_context_cache_key",
 #isitors.ExtendedInternalTraversal.dp_has_cache_key_tuples,
 #,
 #
 #local_opts",
 #isitors.ExtendedInternalTraversal.dp_string_multi_dict,
 #,
 #

 #ef __init__(self, entity):
 #nsp = inspect(entity)
 #nsp._post_inspect

 #elf.path = insp._path_registry
        # note that this .context is shared among all descendant
        # Load objects
 #elf.context = util.OrderedDict()
 #elf.local_opts = {}
 #elf.is_class_strategy = False

 #classmethod
 #ef for_existing_path(cls, path):
 #oad = cls.__new__(cls)
 #oad.path = path
 #oad.context = {}
 #oad.local_opts = {}
 #oad._of_type = None
 #oad._extra_criteria = ()
 #eturn load

 #ef _generate_extra_criteria(self, context):
 #""Apply the current bound parameters in a QueryContext to the
 #extra_criteria" stored with this Load object.

 #oad objects are typically pulled from the cached version of
 #he statement from a QueryContext.  The statement currently being
 #xecuted will have new values (and keys) for bound parameters in the
 #xtra criteria which need to be applied by loader strategies when
 #hey handle this criteria for a result set.

 #""

 #ssert (
 #elf._extra_criteria
 #, "this should only be called if _extra_criteria is present"

 #rig_query = context.compile_state.select_statement
 #urrent_query = context.query

        # NOTE: while it seems like we should not do the "apply" operation
        # here if orig_query is current_query, skipping it in the "optimized"
        # case causes the query to be different from a cache key perspective,
        # because we are creating a copy of the criteria which is no longer
        # the same identity of the _extra_criteria in the loader option
        # itself.  cache key logic produces a different key for
        # (A, copy_of_A) vs. (A, A), because in the latter case it shortens
        # the second part of the key to just indicate on identity.

        # if orig_query is current_query:
        # not cached yet.   just do the and_()
        #    return and_(*self._extra_criteria)

 #1 = orig_query._generate_cache_key()
 #2 = current_query._generate_cache_key()

 #eturn k2._apply_params_to_element(k1, and_(*self._extra_criteria))

 #property
 #ef _context_cache_key(self):
 #erialized = []
 #f self.context is None:
 #eturn []
 #or (key, loader_path), obj in self.context.items():
 #f key != "loader":
 #ontinue
 #erialized.append(loader_path + (obj,))
 #eturn serialized

 #ef _generate(self):
 #loned = super(Load, self)._generate()
 #loned.local_opts = {}
 #eturn cloned

 #s_opts_only = False
 #s_class_strategy = False
 #trategy = None
 #ropagate_to_loaders = False
 #of_type = None
 #extra_criteria = ()

 #ef process_compile_state_replaced_entities(
 #elf, compile_state, mapper_entities
 #:
 #f not compile_state.compile_options._enable_eagerloads:
 #eturn

        # process is being run here so that the options given are validated
        # against what the lead entities were, as well as to accommodate
        # for the entities having been replaced with equivalents
 #elf._process(
 #ompile_state,
 #apper_entities,
 #ot bool(compile_state.current_path),
 #

 #ef process_compile_state(self, compile_state):
 #f not compile_state.compile_options._enable_eagerloads:
 #eturn

 #elf._process(
 #ompile_state,
 #ompile_state._lead_mapper_entities,
 #ot bool(compile_state.current_path),
 #

 #ef _process(self, compile_state, mapper_entities, raiseerr):
 #s_refresh = compile_state.compile_options._for_refresh_state
 #urrent_path = compile_state.current_path
 #f current_path:
 #or (token, start_path), loader in self.context.items():
 #f is_refresh and not loader.propagate_to_loaders:
 #ontinue
 #hopped_start_path = self._chop_path(start_path, current_path)
 #f chopped_start_path is not None:
 #ompile_state.attributes[
 #token, chopped_start_path)
 # = loader
 #lse:
 #ompile_state.attributes.update(self.context)

 #ef _generate_path(
 #elf,
 #ath,
 #ttr,
 #or_strategy,
 #ildcard_key,
 #aiseerr=True,
 #olymorphic_entity_context=None,
 #:
 #xisting_of_type = self._of_type
 #elf._of_type = None
 #f raiseerr and not path.has_entity:
 #f isinstance(path, TokenRegistry):
 #aise sa_exc.ArgumentError(
 #Wildcard token cannot be followed by another entity"
 #
 #lse:
 #aise sa_exc.ArgumentError(
 #Mapped attribute '%s' does not "
 #refer to a mapped entity" % (path.prop,)
 #

 #f isinstance(attr, util.string_types):
 #efault_token = attr.endswith(_DEFAULT_TOKEN)
 #ttr_str_name = attr
 #f attr.endswith(_WILDCARD_TOKEN) or default_token:
 #f default_token:
 #elf.propagate_to_loaders = False
 #f wildcard_key:
 #ttr = "%s:%s" % (wildcard_key, attr)

                # TODO: AliasedInsp inside the path for of_type is not
                # working for a with_polymorphic entity because the
                # relationship loaders don't render the with_poly into the
                # path.  See #4469 which will try to improve this
 #f existing_of_type and not existing_of_type.is_aliased_class:
 #ath = path.parent[existing_of_type]
 #ath = path.token(attr)
 #elf.path = path
 #eturn path

 #f existing_of_type:
 #nt = inspect(existing_of_type)
 #lse:
 #nt = path.entity

 #til.warn_deprecated_20(
 #Using strings to indicate column or "
 #relationship paths in loader options is deprecated "
 #and will be removed in SQLAlchemy 2.0.  Please use "
 #the class-bound attribute directly."
 #
 #ry:
                # use getattr on the class to work around
                # synonyms, hybrids, etc.
 #ttr = getattr(ent.class_, attr)
 #xcept AttributeError as err:
 #f raiseerr:
 #til.raise_(
 #a_exc.ArgumentError(
 #Can\'t find property named "%s" on '
 #%s in this Query." % (attr, ent)
 #,
 #eplace_context=err,
 #
 #lse:
 #eturn None
 #lse:
 #ry:
 #ttr = found_property = attr.property
 #xcept AttributeError as ae:
 #f not isinstance(attr, MapperProperty):
 #til.raise_(
 #a_exc.ArgumentError(
 #Expected attribute "%s" on %s to be a '
 #mapped attribute; "
 #instead got %s object."
 # (attr_str_name, ent, type(attr))
 #,
 #eplace_context=ae,
 #
 #lse:
 #aise

 #ath = path[attr]
 #lse:
 #nsp = inspect(attr)

 #f insp.is_mapper or insp.is_aliased_class:
                # TODO: this does not appear to be a valid codepath.  "attr"
                # would never be a mapper.  This block is present in 1.2
                # as well however does not seem to be accessed in any tests.
 #f not orm_util._entity_corresponds_to_use_path_impl(
 #ttr.parent, path[-1]
 #:
 #f raiseerr:
 #aise sa_exc.ArgumentError(
 #Attribute '%s' does not "
 #link from element '%s'" % (attr, path.entity)
 #
 #lse:
 #eturn None
 #lif insp.is_property:
 #rop = found_property = attr
 #ath = path[prop]
 #lif insp.is_attribute:
 #rop = found_property = attr.property

 #f not orm_util._entity_corresponds_to_use_path_impl(
 #ttr.parent, path[-1]
 #:
 #f raiseerr:
 #aise sa_exc.ArgumentError(
 #Attribute "%s" does not '
 #link from element "%s".%s'
 # (
 #ttr,
 #ath.entity,
 #
 #  Did you mean to use "
 #%s.of_type(%s)?"
 # (path[-2], attr.class_.__name__)
 #f len(path) > 1
 #nd path.entity.is_mapper
 #nd attr.parent.is_aliased_class
 #lse ""
 #,
 #
 #
 #lse:
 #eturn None

 #f attr._extra_criteria:
 #elf._extra_criteria = attr._extra_criteria

 #f getattr(attr, "_of_type", None):
 #c = attr._of_type
 #xt_info = of_type_info = inspect(ac)

 #f polymorphic_entity_context is None:
 #olymorphic_entity_context = self.context

 #xisting = path.entity_path[prop].get(
 #olymorphic_entity_context, "path_with_polymorphic"
 #

 #f not ext_info.is_aliased_class:
 #c = orm_util.with_polymorphic(
 #xt_info.mapper.base_mapper,
 #xt_info.mapper,
 #liased=True,
 #use_mapper_path=True,
 #existing_alias=inspect(existing)
 #f existing is not None
 #lse None,
 #

 #xt_info = inspect(ac)

 #ath.entity_path[prop].set(
 #olymorphic_entity_context, "path_with_polymorphic", ac
 #

 #ath = path[prop][ext_info]

 #elf._of_type = of_type_info

 #lse:
 #ath = path[prop]

 #f for_strategy is not None:
 #ound_property._get_strategy(for_strategy)
 #f path.has_entity:
 #ath = path.entity_path
 #elf.path = path
 #eturn path

 #ef __str__(self):
 #eturn "Load(strategy=%r)" % (self.strategy,)

 #ef _coerce_strat(self, strategy):
 #f strategy is not None:
 #trategy = tuple(sorted(strategy.items()))
 #eturn strategy

 #ef _apply_to_parent(self, parent, applied, bound):
 #aise NotImplementedError(
 #Only 'unbound' loader options may be used with the "
 #Load.options() method"
 #

 #_generative
 #ef options(self, *opts):
 #"""Apply a series of options as sub-options to this
 #class:`_orm.Load`
 #bject.

 #.g.::

 #uery = session.query(Author)
 #uery = query.options(
 #oinedload(Author.book).options(
 #oad_only(Book.summary, Book.excerpt),
 #oinedload(Book.citations).options(
 #oinedload(Citation.author)
 #
 #
 #

 #param \*opts: A series of loader option objects (ultimately
 #class:`_orm.Load` objects) which should be applied to the path
 #pecified by this :class:`_orm.Load` object.

 #. versionadded:: 1.3.6

 #. seealso::

 #func:`.defaultload`

 #ref:`relationship_loader_options`

 #ref:`deferred_loading_w_multiple`

 #""
 #pply_cache = {}
 #ound = not isinstance(self, _UnboundLoad)
 #f bound:
 #aise NotImplementedError(
 #The options() method is currently only supported "
 #for 'unbound' loader options"
 #
 #or opt in opts:
 #pt._apply_to_parent(self, apply_cache, bound)

 #_generative
 #ef set_relationship_strategy(
 #elf, attr, strategy, propagate_to_loaders=True
 #:
 #trategy = self._coerce_strat(strategy)
 #elf.propagate_to_loaders = propagate_to_loaders
 #loned = self._clone_for_bind_strategy(attr, strategy, "relationship")
 #elf.path = cloned.path
 #elf._of_type = cloned._of_type
 #elf._extra_criteria = cloned._extra_criteria
 #loned.is_class_strategy = self.is_class_strategy = False
 #elf.propagate_to_loaders = cloned.propagate_to_loaders

 #_generative
 #ef set_column_strategy(self, attrs, strategy, opts=None, opts_only=False):
 #trategy = self._coerce_strat(strategy)
 #elf.is_class_strategy = False
 #or attr in attrs:
 #loned = self._clone_for_bind_strategy(
 #ttr, strategy, "column", opts_only=opts_only, opts=opts
 #
 #loned.propagate_to_loaders = True

 #_generative
 #ef set_generic_strategy(self, attrs, strategy):
 #trategy = self._coerce_strat(strategy)
 #or attr in attrs:
 #loned = self._clone_for_bind_strategy(attr, strategy, None)
 #loned.propagate_to_loaders = True

 #_generative
 #ef set_class_strategy(self, strategy, opts):
 #trategy = self._coerce_strat(strategy)
 #loned = self._clone_for_bind_strategy(None, strategy, None)
 #loned.is_class_strategy = True
 #loned.propagate_to_loaders = True
 #loned.local_opts.update(opts)

 #ef _clone_for_bind_strategy(
 #elf, attr, strategy, wildcard_key, opts_only=False, opts=None
 #:
 #""Create an anonymous clone of the Load/_UnboundLoad that is suitable
 #o be placed in the context / _to_bind collection of this Load
 #bject.   The clone will then lose references to context/_to_bind
 #n order to not create reference cycles.

 #""
 #loned = self._generate()
 #loned._generate_path(self.path, attr, strategy, wildcard_key)
 #loned.strategy = strategy

 #loned.local_opts = self.local_opts
 #f opts:
 #loned.local_opts.update(opts)
 #f opts_only:
 #loned.is_opts_only = True

 #f strategy or cloned.is_opts_only:
 #loned._set_path_strategy()
 #eturn cloned

 #ef _set_for_path(self, context, path, replace=True, merge_opts=False):
 #f merge_opts or not replace:
 #xisting = path.get(context, "loader")
 #f existing:
 #f merge_opts:
 #xisting.local_opts.update(self.local_opts)
 #xisting._extra_criteria += self._extra_criteria
 #lse:
 #ath.set(context, "loader", self)
 #lse:
 #xisting = path.get(context, "loader")
 #ath.set(context, "loader", self)
 #f existing and existing.is_opts_only:
 #elf.local_opts.update(existing.local_opts)
 #xisting._extra_criteria += self._extra_criteria

 #ef _set_path_strategy(self):
 #f not self.is_class_strategy and self.path.has_entity:
 #ffective_path = self.path.parent
 #lse:
 #ffective_path = self.path

 #f effective_path.is_token:
 #or path in effective_path.generate_for_superclasses():
 #elf._set_for_path(
 #elf.context,
 #ath,
 #eplace=True,
 #erge_opts=self.is_opts_only,
 #
 #lse:
 #elf._set_for_path(
 #elf.context,
 #ffective_path,
 #eplace=True,
 #erge_opts=self.is_opts_only,
 #

        # remove cycles; _set_path_strategy is always invoked on an
        # anonymous clone of the Load / UnboundLoad object since #5056
 #elf.context = None

 #ef __getstate__(self):
 # = self.__dict__.copy()

        # can't pickle this right now; warning is raised by strategies
 #["_extra_criteria"] = ()

 #f d["context"] is not None:
 #["context"] = PathRegistry.serialize_context_dict(
 #["context"], ("loader",)
 #
 #["path"] = self.path.serialize()
 #eturn d

 #ef __setstate__(self, state):
 #elf.__dict__.update(state)
 #elf.path = PathRegistry.deserialize(self.path)
 #f self.context is not None:
 #elf.context = PathRegistry.deserialize_context_dict(self.context)

 #ef _chop_path(self, to_chop, path):
 # = -1

 #or i, (c_token, p_token) in enumerate(zip(to_chop, path.path)):
 #f isinstance(c_token, util.string_types):
                # TODO: this is approximated from the _UnboundLoad
                # version and probably has issues, not fully covered.

 #f i == 0 and c_token.endswith(":" + _DEFAULT_TOKEN):
 #eturn to_chop
 #lif (
 #_token != "relationship:%s" % (_WILDCARD_TOKEN,)
 #nd c_token != p_token.key
 #:
 #eturn None

 #f c_token is p_token:
 #ontinue
 #lif (
 #sinstance(c_token, InspectionAttr)
 #nd c_token.is_mapper
 #nd p_token.is_mapper
 #nd c_token.isa(p_token)
 #:
 #ontinue
 #lse:
 #eturn None
 #eturn to_chop[i + 1 :]


class _UnboundLoad(Load):
 #""Represent a loader option that isn't tied to a root entity.

 #he loader option will produce an entity-linked :class:`_orm.Load`
 #bject when it is passed :meth:`_query.Query.options`.

 #his provides compatibility with the traditional system
 #f freestanding options, e.g. ``joinedload('x.y.z')``.

 #""

 #ef __init__(self):
 #elf.path = ()
 #elf._to_bind = []
 #elf.local_opts = {}
 #elf._extra_criteria = ()

 #cache_key_traversal = [
 #"path", visitors.ExtendedInternalTraversal.dp_multi_list),
 #"strategy", visitors.ExtendedInternalTraversal.dp_plain_obj),
 #"_to_bind", visitors.ExtendedInternalTraversal.dp_has_cache_key_list),
 #"_extra_criteria", visitors.InternalTraversal.dp_clauseelement_list),
 #
 #local_opts",
 #isitors.ExtendedInternalTraversal.dp_string_multi_dict,
 #,
 #

 #is_chain_link = False

 #ef _set_path_strategy(self):
 #elf._to_bind.append(self)

        # remove cycles; _set_path_strategy is always invoked on an
        # anonymous clone of the Load / UnboundLoad object since #5056
 #elf._to_bind = None

 #ef _apply_to_parent(self, parent, applied, bound, to_bind=None):
 #f self in applied:
 #eturn applied[self]

 #f to_bind is None:
 #o_bind = self._to_bind

 #loned = self._generate()

 #pplied[self] = cloned

 #loned.strategy = self.strategy
 #f self.path:
 #ttr = self.path[-1]
 #f isinstance(attr, util.string_types) and attr.endswith(
 #DEFAULT_TOKEN
 #:
 #ttr = attr.split(":")[0] + ":" + _WILDCARD_TOKEN
 #loned._generate_path(
 #arent.path + self.path[0:-1], attr, self.strategy, None
 #

        # these assertions can go away once the "sub options" API is
        # mature
 #ssert cloned.propagate_to_loaders == self.propagate_to_loaders
 #ssert cloned.is_class_strategy == self.is_class_strategy
 #ssert cloned.is_opts_only == self.is_opts_only

 #ew_to_bind = {
 #lem._apply_to_parent(parent, applied, bound, to_bind)
 #or elem in to_bind
 #
 #loned._to_bind = parent._to_bind
 #loned._to_bind.extend(new_to_bind)
 #loned.local_opts.update(self.local_opts)

 #eturn cloned

 #ef _generate_path(self, path, attr, for_strategy, wildcard_key):
 #f (
 #ildcard_key
 #nd isinstance(attr, util.string_types)
 #nd attr in (_WILDCARD_TOKEN, _DEFAULT_TOKEN)
 #:
 #f attr == _DEFAULT_TOKEN:
 #elf.propagate_to_loaders = False
 #ttr = "%s:%s" % (wildcard_key, attr)
 #f path and _is_mapped_class(path[-1]) and not self.is_class_strategy:
 #ath = path[0:-1]
 #f attr:
 #ath = path + (attr,)
 #elf.path = path
 #elf._extra_criteria = getattr(attr, "_extra_criteria", ())

 #eturn path

 #ef __getstate__(self):
 # = self.__dict__.copy()

        # can't pickle this right now; warning is raised by strategies
 #["_extra_criteria"] = ()

 #["path"] = self._serialize_path(self.path, filter_aliased_class=True)
 #eturn d

 #ef __setstate__(self, state):
 #et = []
 #or key in state["path"]:
 #f isinstance(key, tuple):
 #f len(key) == 2:
                    # support legacy
 #ls, propkey = key
 #f_type = None
 #lse:
 #ls, propkey, of_type = key
 #rop = getattr(cls, propkey)
 #f of_type:
 #rop = prop.of_type(of_type)
 #et.append(prop)
 #lse:
 #et.append(key)
 #tate["path"] = tuple(ret)
 #elf.__dict__ = state

 #ef _process(self, compile_state, mapper_entities, raiseerr):
 #edupes = compile_state.attributes["_unbound_load_dedupes"]
 #s_refresh = compile_state.compile_options._for_refresh_state
 #or val in self._to_bind:
 #f val not in dedupes:
 #edupes.add(val)
 #f is_refresh and not val.propagate_to_loaders:
 #ontinue
 #al._bind_loader(
 #ent.entity_zero for ent in mapper_entities],
 #ompile_state.current_path,
 #ompile_state.attributes,
 #aiseerr,
 #

 #classmethod
 #ef _from_keys(cls, meth, keys, chained, kw):
 #pt = _UnboundLoad()

 #ef _split_key(key):
 #f isinstance(key, util.string_types):
                # coerce fooload('*') into "default loader strategy"
 #f key == _WILDCARD_TOKEN:
 #eturn (_DEFAULT_TOKEN,)
                # coerce fooload(".*") into "wildcard on default entity"
 #lif key.startswith("." + _WILDCARD_TOKEN):
 #ey = key[1:]
 #eturn key.split(".")
 #lse:
 #eturn (key,)

 #ll_tokens = [token for key in keys for token in _split_key(key)]

 #or token in all_tokens[0:-1]:
            # set _is_chain_link first so that clones of the
            # object also inherit this flag
 #pt._is_chain_link = True
 #f chained:
 #pt = meth(opt, token, **kw)
 #lse:
 #pt = opt.defaultload(token)

 #pt = meth(opt, all_tokens[-1], **kw)
 #pt._is_chain_link = False
 #eturn opt

 #ef _chop_path(self, to_chop, path):
 # = -1
 #or i, (c_token, (p_entity, p_prop)) in enumerate(
 #ip(to_chop, path.pairs())
 #:
 #f isinstance(c_token, util.string_types):
 #f i == 0 and c_token.endswith(":" + _DEFAULT_TOKEN):
 #eturn to_chop
 #lif (
 #_token != "relationship:%s" % (_WILDCARD_TOKEN,)
 #nd c_token != p_prop.key
 #:
 #eturn None
 #lif isinstance(c_token, PropComparator):
 #f c_token.property is not p_prop or (
 #_token._parententity is not p_entity
 #nd (
 #ot c_token._parententity.is_mapper
 #r not c_token._parententity.isa(p_entity)
 #
 #:
 #eturn None
 #lse:
 # += 1

 #eturn to_chop[i:]

 #ef _serialize_path(self, path, filter_aliased_class=False):
 #et = []
 #or token in path:
 #f isinstance(token, QueryableAttribute):
 #f (
 #ilter_aliased_class
 #nd token._of_type
 #nd inspect(token._of_type).is_aliased_class
 #:
 #et.append((token._parentmapper.class_, token.key, None))
 #lse:
 #et.append(
 #
 #oken._parentmapper.class_,
 #oken.key,
 #oken._of_type.entity if token._of_type else None,
 #
 #
 #lif isinstance(token, PropComparator):
 #et.append((token._parentmapper.class_, token.key, None))
 #lse:
 #et.append(token)
 #eturn ret

 #ef _bind_loader(self, entities, current_path, context, raiseerr):
 #""Convert from an _UnboundLoad() object into a Load() object.

 #he _UnboundLoad() uses an informal "path" and does not necessarily
 #efer to a lead entity as it may use string tokens.   The Load()
 #TOH refers to a complete path.   This method reconciles from a
 #iven Query into a Load.

 #xample::


 #uery = session.query(User).options(
 #oinedload("orders").joinedload("items"))

 #he above options will be an _UnboundLoad object along the lines
 #f (note this is not the exact API of _UnboundLoad)::

 #UnboundLoad(
 #to_bind=[
 #UnboundLoad(["orders"], {"lazy": "joined"}),
 #UnboundLoad(["orders", "items"], {"lazy": "joined"}),
 #
 #

 #fter this method, we get something more like this (again this is
 #ot exact API)::

 #oad(
 #ser,
 #User, User.orders.property))
 #oad(
 #ser,
 #User, User.orders.property, Order, Order.items.property))

 #""

 #tart_path = self.path

 #f self.is_class_strategy and current_path:
 #tart_path += (entities[0],)

        # _current_path implies we're in a
        # secondary load with an existing path

 #f current_path:
 #tart_path = self._chop_path(start_path, current_path)

 #f not start_path:
 #eturn None

        # look at the first token and try to locate within the Query
        # what entity we are referring towards.
 #oken = start_path[0]

 #f isinstance(token, util.string_types):
 #ntity = self._find_entity_basestring(entities, token, raiseerr)
 #lif isinstance(token, PropComparator):
 #rop = token.property
 #ntity = self._find_entity_prop_comparator(
 #ntities, prop, token._parententity, raiseerr
 #
 #lif self.is_class_strategy and _is_mapped_class(token):
 #ntity = inspect(token)
 #f entity not in entities:
 #ntity = None
 #lse:
 #aise sa_exc.ArgumentError(
 #mapper option expects " "string key or list of attributes"
 #

 #f not entity:
 #eturn

 #ath_element = entity

        # transfer our entity-less state into a Load() object
        # with a real entity path.  Start with the lead entity
        # we just located, then go through the rest of our path
        # tokens and populate into the Load().
 #oader = Load(path_element)

 #f context is None:
 #ontext = loader.context

 #oader.strategy = self.strategy
 #oader.is_opts_only = self.is_opts_only
 #oader.is_class_strategy = self.is_class_strategy

 #ath = loader.path

 #f not loader.is_class_strategy:
 #or idx, token in enumerate(start_path):
 #f not loader._generate_path(
 #oader.path,
 #oken,
 #elf.strategy if idx == len(start_path) - 1 else None,
 #one,
 #aiseerr,
 #olymorphic_entity_context=context,
 #:
 #eturn

 #oader.local_opts.update(self.local_opts)

 #f not loader.is_class_strategy and loader.path.has_entity:
 #ffective_path = loader.path.parent
 #lse:
 #ffective_path = loader.path

        # prioritize "first class" options over those
        # that were "links in the chain", e.g. "x" and "y" in
        # someload("x.y.z") versus someload("x") / someload("x.y")

 #f effective_path.is_token:
 #or path in effective_path.generate_for_superclasses():
 #oader._set_for_path(
 #ontext,
 #ath,
 #eplace=not self._is_chain_link,
 #erge_opts=self.is_opts_only,
 #
 #lse:
 #oader._set_for_path(
 #ontext,
 #ffective_path,
 #eplace=not self._is_chain_link,
 #erge_opts=self.is_opts_only,
 #

 #eturn loader

 #ef _find_entity_prop_comparator(self, entities, prop, mapper, raiseerr):
 #f _is_aliased_class(mapper):
 #earchfor = mapper
 #lse:
 #earchfor = _class_to_mapper(mapper)
 #or ent in entities:
 #f orm_util._entity_corresponds_to(ent, searchfor):
 #eturn ent
 #lse:
 #f raiseerr:
 #f not list(entities):
 #aise sa_exc.ArgumentError(
 #Query has only expression-based entities, "
 #which do not apply to %s "%s"'
 # (util.clsname_as_plain_name(type(prop)), prop)
 #
 #lse:
 #aise sa_exc.ArgumentError(
 #Mapped attribute "%s" does not apply to any of the '
 #root entities in this query, e.g. %s. Please "
 #specify the full path "
 #from one of the root entities to the target "
 #attribute. "
 # (prop, ", ".join(str(x) for x in entities))
 #
 #lse:
 #eturn None

 #ef _find_entity_basestring(self, entities, token, raiseerr):
 #f token.endswith(":" + _WILDCARD_TOKEN):
 #f len(list(entities)) != 1:
 #f raiseerr:
 #aise sa_exc.ArgumentError(
 #Can't apply wildcard ('*') or load_only() "
 #loader option to multiple entities %s. Specify "
 #loader options for each entity individually, such "
 #as %s."
 # (
 #, ".join(str(ent) for ent in entities),
 #, ".join(
 #Load(%s).some_option('*')" % ent
 #or ent in entities
 #,
 #
 #
 #lif token.endswith(_DEFAULT_TOKEN):
 #aiseerr = False

 #or ent in entities:
            # return only the first _MapperEntity when searching
            # based on string prop name.   Ideally object
            # attributes are used to specify more exactly.
 #eturn ent
 #lse:
 #f raiseerr:
 #aise sa_exc.ArgumentError(
 #Query has only expression-based entities - "
 #can\'t find property named "%s".' % (token,)
 #
 #lse:
 #eturn None


class loader_option(object):
 #ef __init__(self):
 #ass

 #ef __call__(self, fn):
 #elf.name = name = fn.__name__
 #elf.fn = fn
 #f hasattr(Load, name):
 #aise TypeError("Load class already has a %s method." % (name))
 #etattr(Load, name, fn)

 #eturn self

 #ef _add_unbound_fn(self, fn):
 #elf._unbound_fn = fn
 #n_doc = self.fn.__doc__
 #elf.fn.__doc__ = """Produce a new :class:`_orm.Load` object with the
:func:`_orm.%(name)s` option applied.

See :func:`_orm.%(name)s` for usage examples.

""" % {
 #name": self.name
 #

 #n.__doc__ = fn_doc
 #eturn self

 #ef _add_unbound_all_fn(self, fn):
 #n.__doc__ = """Produce a standalone "all" option for
:func:`_orm.%(name)s`.

.. deprecated:: 0.9

 #he :func:`_orm.%(name)s_all` function is deprecated, and will be removed
 #n a future release.  Please use method chaining with
 #func:`_orm.%(name)s` instead, as in::

 #ession.query(MyClass).options(
 #(name)s("someattribute").%(name)s("anotherattribute")
 #

""" % {
 #name": self.name
 #
 #n = util.deprecated(
            # This is used by `baked_lazyload_all` was only deprecated in
            # version 1.2 so this must stick around until that is removed
 #0.9",
 #The :func:`.%(name)s_all` function is deprecated, and will be "
 #removed in a future release.  Please use method chaining with "
 #:func:`.%(name)s` instead" % {"name": self.name},
 #dd_deprecation_to_docstring=False,
 #(fn)

 #elf._unbound_all_fn = fn
 #eturn self


@loader_option()
def contains_eager(loadopt, attr, alias=None):
 #"""Indicate that the given attribute should be eagerly loaded from
 #olumns stated manually in the query.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #he option is used in conjunction with an explicit join that loads
 #he desired rows, i.e.::

 #ess.query(Order).\
 #oin(Order.user).\
 #ptions(contains_eager(Order.user))

 #he above query would join from the ``Order`` entity to its related
 #`User`` entity, and the returned ``Order`` objects would have the
 #`Order.user`` attribute pre-populated.

 #t may also be used for customizing the entries in an eagerly loaded
 #ollection; queries will normally want to use the
 #meth:`_query.Query.populate_existing` method assuming the primary
 #ollection of parent objects may already have been loaded::

 #ess.query(User).\
 #oin(User.addresses).\
 #ilter(Address.email_address.like('%@aol.com')).\
 #ptions(contains_eager(User.addresses)).\
 #opulate_existing()

 #ee the section :ref:`contains_eager` for complete usage details.

 #. seealso::

 #ref:`loading_toplevel`

 #ref:`contains_eager`

 #""
 #f alias is not None:
 #f not isinstance(alias, str):
 #nfo = inspect(alias)
 #lias = info.selectable

 #lse:
 #til.warn_deprecated(
 #Passing a string name for the 'alias' argument to "
 #'contains_eager()` is deprecated, and will not work in a "
 #future release.  Please use a sqlalchemy.alias() or "
 #sqlalchemy.orm.aliased() construct.",
 #ersion="1.4",
 #

 #lif getattr(attr, "_of_type", None):
 #t = inspect(attr._of_type)
 #lias = ot.selectable

 #loned = loadopt.set_relationship_strategy(
 #ttr, {"lazy": "joined"}, propagate_to_loaders=False
 #
 #loned.local_opts["eager_from_alias"] = alias
 #eturn cloned


@contains_eager._add_unbound_fn
def contains_eager(*keys, **kw):
 #eturn _UnboundLoad()._from_keys(
 #UnboundLoad.contains_eager, keys, True, kw
 #


@loader_option()
def load_only(loadopt, *attrs):
 #""Indicate that for a particular entity, only the given list
 #f column-based attribute names should be loaded; all others will be
 #eferred.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #xample - given a class ``User``, load only the ``name`` and ``fullname``
 #ttributes::

 #ession.query(User).options(load_only(User.name, User.fullname))

 #xample - given a relationship ``User.addresses -> Address``, specify
 #ubquery loading for the ``User.addresses`` collection, but on each
 #`Address`` object load only the ``email_address`` attribute::

 #ession.query(User).options(
 #ubqueryload(User.addresses).load_only(Address.email_address)
 #

 #or a :class:`_query.Query` that has multiple entities,
 #he lead entity can be
 #pecifically referred to using the :class:`_orm.Load` constructor::

 #ession.query(User, Address).join(User.addresses).options(
 #oad(User).load_only(User.name, User.fullname),
 #oad(Address).load_only(Address.email_address)
 #

 #. note:: This method will still load a :class:`_schema.Column` even
 #f the column property is defined with ``deferred=True``
 #or the :func:`.column_property` function.

 #. versionadded:: 0.9.0

 #""
 #loned = loadopt.set_column_strategy(
 #ttrs, {"deferred": False, "instrument": True}
 #
 #loned.set_column_strategy(
 #*", {"deferred": True, "instrument": True}, {"undefer_pks": True}
 #
 #eturn cloned


@load_only._add_unbound_fn
def load_only(*attrs):
 #eturn _UnboundLoad().load_only(*attrs)


@loader_option()
def joinedload(loadopt, attr, innerjoin=None):
 #""Indicate that the given attribute should be loaded using joined
 #ager loading.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #xamples::

        # joined-load the "orders" collection on "User"
 #uery(User).options(joinedload(User.orders))

        # joined-load Order.items and then Item.keywords
 #uery(Order).options(
 #oinedload(Order.items).joinedload(Item.keywords))

        # lazily load Order.items, but when Items are loaded,
        # joined-load the keywords collection
 #uery(Order).options(
 #azyload(Order.items).joinedload(Item.keywords))

 #param innerjoin: if ``True``, indicates that the joined eager load should
 #se an inner join instead of the default of left outer join::

 #uery(Order).options(joinedload(Order.user, innerjoin=True))

 #n order to chain multiple eager joins together where some may be
 #UTER and others INNER, right-nested joins are used to link them::

 #uery(A).options(
 #oinedload(A.bs, innerjoin=False).
 #oinedload(B.cs, innerjoin=True)
 #

 #he above query, linking A.bs via "outer" join and B.cs via "inner" join
 #ould render the joins as "a LEFT OUTER JOIN (b JOIN c)".   When using
 #lder versions of SQLite (< 3.7.16), this form of JOIN is translated to
 #se full subqueries as this syntax is otherwise not directly supported.

 #he ``innerjoin`` flag can also be stated with the term ``"unnested"``.
 #his indicates that an INNER JOIN should be used, *unless* the join
 #s linked to a LEFT OUTER JOIN to the left, in which case it
 #ill render as LEFT OUTER JOIN.  For example, supposing ``A.bs``
 #s an outerjoin::

 #uery(A).options(
 #oinedload(A.bs).
 #oinedload(B.cs, innerjoin="unnested")
 #

 #he above join will render as "a LEFT OUTER JOIN b LEFT OUTER JOIN c",
 #ather than as "a LEFT OUTER JOIN (b JOIN c)".

 #. note:: The "unnested" flag does **not** affect the JOIN rendered
 #rom a many-to-many association table, e.g. a table configured
 #s :paramref:`_orm.relationship.secondary`, to the target table; for
 #orrectness of results, these joins are always INNER and are
 #herefore right-nested if linked to an OUTER join.

 #. versionchanged:: 1.0.0 ``innerjoin=True`` now implies
 #`innerjoin="nested"``, whereas in 0.9 it implied
 #`innerjoin="unnested"``.  In order to achieve the pre-1.0 "unnested"
 #nner join behavior, use the value ``innerjoin="unnested"``.
 #ee :ref:`migration_3008`.

 #. note::

 #he joins produced by :func:`_orm.joinedload` are **anonymously
 #liased**.  The criteria by which the join proceeds cannot be
 #odified, nor can the :class:`_query.Query`
 #efer to these joins in any way,
 #ncluding ordering.  See :ref:`zen_of_eager_loading` for further
 #etail.

 #o produce a specific SQL JOIN which is explicitly available, use
 #meth:`_query.Query.join`.
 #o combine explicit JOINs with eager loading
 #f collections, use :func:`_orm.contains_eager`; see
 #ref:`contains_eager`.

 #. seealso::

 #ref:`loading_toplevel`

 #ref:`joined_eager_loading`

 #""
 #oader = loadopt.set_relationship_strategy(attr, {"lazy": "joined"})
 #f innerjoin is not None:
 #oader.local_opts["innerjoin"] = innerjoin
 #eturn loader


@joinedload._add_unbound_fn
def joinedload(*keys, **kw):
 #eturn _UnboundLoad._from_keys(_UnboundLoad.joinedload, keys, False, kw)


@loader_option()
def subqueryload(loadopt, attr):
 #""Indicate that the given attribute should be loaded using
 #ubquery eager loading.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #xamples::

        # subquery-load the "orders" collection on "User"
 #uery(User).options(subqueryload(User.orders))

        # subquery-load Order.items and then Item.keywords
 #uery(Order).options(
 #ubqueryload(Order.items).subqueryload(Item.keywords))

        # lazily load Order.items, but when Items are loaded,
        # subquery-load the keywords collection
 #uery(Order).options(
 #azyload(Order.items).subqueryload(Item.keywords))


 #. seealso::

 #ref:`loading_toplevel`

 #ref:`subquery_eager_loading`

 #""
 #eturn loadopt.set_relationship_strategy(attr, {"lazy": "subquery"})


@subqueryload._add_unbound_fn
def subqueryload(*keys):
 #eturn _UnboundLoad._from_keys(_UnboundLoad.subqueryload, keys, False, {})


@loader_option()
def selectinload(loadopt, attr):
 #""Indicate that the given attribute should be loaded using
 #ELECT IN eager loading.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #xamples::

        # selectin-load the "orders" collection on "User"
 #uery(User).options(selectinload(User.orders))

        # selectin-load Order.items and then Item.keywords
 #uery(Order).options(
 #electinload(Order.items).selectinload(Item.keywords))

        # lazily load Order.items, but when Items are loaded,
        # selectin-load the keywords collection
 #uery(Order).options(
 #azyload(Order.items).selectinload(Item.keywords))

 #. versionadded:: 1.2

 #. seealso::

 #ref:`loading_toplevel`

 #ref:`selectin_eager_loading`

 #""
 #eturn loadopt.set_relationship_strategy(attr, {"lazy": "selectin"})


@selectinload._add_unbound_fn
def selectinload(*keys):
 #eturn _UnboundLoad._from_keys(_UnboundLoad.selectinload, keys, False, {})


@loader_option()
def lazyload(loadopt, attr):
 #""Indicate that the given attribute should be loaded using "lazy"
 #oading.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #. seealso::

 #ref:`loading_toplevel`

 #ref:`lazy_loading`

 #""
 #eturn loadopt.set_relationship_strategy(attr, {"lazy": "select"})


@lazyload._add_unbound_fn
def lazyload(*keys):
 #eturn _UnboundLoad._from_keys(_UnboundLoad.lazyload, keys, False, {})


@loader_option()
def immediateload(loadopt, attr):
 #""Indicate that the given attribute should be loaded using
 #n immediate load with a per-attribute SELECT statement.

 #he load is achieved using the "lazyloader" strategy and does not
 #ire off any additional eager loaders.

 #he :func:`.immediateload` option is superseded in general
 #y the :func:`.selectinload` option, which performs the same task
 #ore efficiently by emitting a SELECT for all loaded objects.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #. seealso::

 #ref:`loading_toplevel`

 #ref:`selectin_eager_loading`

 #""
 #oader = loadopt.set_relationship_strategy(attr, {"lazy": "immediate"})
 #eturn loader


@immediateload._add_unbound_fn
def immediateload(*keys):
 #eturn _UnboundLoad._from_keys(_UnboundLoad.immediateload, keys, False, {})


@loader_option()
def noload(loadopt, attr):
 #""Indicate that the given relationship attribute should remain unloaded.

 #he relationship attribute will return ``None`` when accessed without
 #roducing any loading effect.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #func:`_orm.noload` applies to :func:`_orm.relationship` attributes; for
 #olumn-based attributes, see :func:`_orm.defer`.

 #. note:: Setting this loading strategy as the default strategy
 #or a relationship using the :paramref:`.orm.relationship.lazy`
 #arameter may cause issues with flushes, such if a delete operation
 #eeds to load related objects and instead ``None`` was returned.

 #. seealso::

 #ref:`loading_toplevel`

 #""

 #eturn loadopt.set_relationship_strategy(attr, {"lazy": "noload"})


@noload._add_unbound_fn
def noload(*keys):
 #eturn _UnboundLoad._from_keys(_UnboundLoad.noload, keys, False, {})


@loader_option()
def raiseload(loadopt, attr, sql_only=False):
 #""Indicate that the given attribute should raise an error if accessed.

 # relationship attribute configured with :func:`_orm.raiseload` will
 #aise an :exc:`~sqlalchemy.exc.InvalidRequestError` upon access.   The
 #ypical way this is useful is when an application is attempting to ensure
 #hat all relationship attributes that are accessed in a particular context
 #ould have been already loaded via eager loading.  Instead of having
 #o read through SQL logs to ensure lazy loads aren't occurring, this
 #trategy will cause them to raise immediately.

 #func:`_orm.raiseload` applies to :func:`_orm.relationship`
 #ttributes only.
 #n order to apply raise-on-SQL behavior to a column-based attribute,
 #se the :paramref:`.orm.defer.raiseload` parameter on the :func:`.defer`
 #oader option.

 #param sql_only: if True, raise only if the lazy load would emit SQL, but
 #ot if it is only checking the identity map, or determining that the
 #elated value should just be None due to missing keys.  When False, the
 #trategy will raise for all varieties of relationship loading.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.


 #. versionadded:: 1.1

 #. seealso::

 #ref:`loading_toplevel`

 #ref:`prevent_lazy_with_raiseload`

 #ref:`deferred_raiseload`

 #""

 #eturn loadopt.set_relationship_strategy(
 #ttr, {"lazy": "raise_on_sql" if sql_only else "raise"}
 #


@raiseload._add_unbound_fn
def raiseload(*keys, **kw):
 #eturn _UnboundLoad._from_keys(_UnboundLoad.raiseload, keys, False, kw)


@loader_option()
def defaultload(loadopt, attr):
 #""Indicate an attribute should load using its default loader style.

 #his method is used to link to other loader options further into
 # chain of attributes without altering the loader style of the links
 #long the chain.  For example, to set joined eager loading for an
 #lement of an element::

 #ession.query(MyClass).options(
 #efaultload(MyClass.someattribute).
 #oinedload(MyOtherClass.someotherattribute)
 #

 #func:`.defaultload` is also useful for setting column-level options
 #n a related class, namely that of :func:`.defer` and :func:`.undefer`::

 #ession.query(MyClass).options(
 #efaultload(MyClass.someattribute).
 #efer("some_column").
 #ndefer("some_other_column")
 #

 #. seealso::

 #meth:`_orm.Load.options` - allows for complex hierarchical
 #oader option structures with less verbosity than with individual
 #func:`.defaultload` directives.

 #ref:`relationship_loader_options`

 #ref:`deferred_loading_w_multiple`

 #""
 #eturn loadopt.set_relationship_strategy(attr, None)


@defaultload._add_unbound_fn
def defaultload(*keys):
 #eturn _UnboundLoad._from_keys(_UnboundLoad.defaultload, keys, False, {})


@loader_option()
def defer(loadopt, key, raiseload=False):
 #"""Indicate that the given column-oriented attribute should be deferred,
 #.g. not loaded until accessed.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #.g.::

 #rom sqlalchemy.orm import defer

 #ession.query(MyClass).options(
 #efer("attribute_one"),
 #efer("attribute_two"))

 #ession.query(MyClass).options(
 #efer(MyClass.attribute_one),
 #efer(MyClass.attribute_two))

 #o specify a deferred load of an attribute on a related class,
 #he path can be specified one token at a time, specifying the loading
 #tyle for each link along the chain.  To leave the loading style
 #or a link unchanged, use :func:`_orm.defaultload`::

 #ession.query(MyClass).options(defaultload("someattr").defer("some_column"))

 # :class:`_orm.Load` object that is present on a certain path can have
 #meth:`_orm.Load.defer` called multiple times,
 #ach will operate on the same
 #arent entity::


 #ession.query(MyClass).options(
 #efaultload("someattr").
 #efer("some_column").
 #efer("some_other_column").
 #efer("another_column")
 #

 #param key: Attribute to be deferred.

 #param raiseload: raise :class:`.InvalidRequestError` if the column
 #alue is to be loaded from emitting SQL.   Used to prevent unwanted
 #QL from being emitted.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`deferred_raiseload`

 #param \*addl_attrs: This option supports the old 0.8 style
 #f specifying a path as a series of attributes, which is now superseded
 #y the method-chained style.

 #. deprecated:: 0.9  The \*addl_attrs on :func:`_orm.defer` is
 #eprecated and will be removed in a future release.   Please
 #se method chaining in conjunction with defaultload() to
 #ndicate a path.


 #. seealso::

 #ref:`deferred`

 #func:`_orm.undefer`

 #""
 #trategy = {"deferred": True, "instrument": True}
 #f raiseload:
 #trategy["raiseload"] = True
 #eturn loadopt.set_column_strategy((key,), strategy)


@defer._add_unbound_fn
def defer(key, *addl_attrs, **kw):
 #f addl_attrs:
 #til.warn_deprecated(
 #The *addl_attrs on orm.defer is deprecated.  Please use "
 #method chaining in conjunction with defaultload() to "
 #indicate a path.",
 #ersion="1.3",
 #
 #eturn _UnboundLoad._from_keys(
 #UnboundLoad.defer, (key,) + addl_attrs, False, kw
 #


@loader_option()
def undefer(loadopt, key):
 #"""Indicate that the given column-oriented attribute should be undeferred,
 #.g. specified within the SELECT statement of the entity as a whole.

 #he column being undeferred is typically set up on the mapping as a
 #func:`.deferred` attribute.

 #his function is part of the :class:`_orm.Load` interface and supports
 #oth method-chained and standalone operation.

 #xamples::

        # undefer two columns
 #ession.query(MyClass).options(undefer("col1"), undefer("col2"))

        # undefer all columns specific to a single class using Load + *
 #ession.query(MyClass, MyOtherClass).options(
 #oad(MyClass).undefer("*"))

        # undefer a column on a related object
 #ession.query(MyClass).options(
 #efaultload(MyClass.items).undefer('text'))

 #param key: Attribute to be undeferred.

 #param \*addl_attrs: This option supports the old 0.8 style
 #f specifying a path as a series of attributes, which is now superseded
 #y the method-chained style.

 #. deprecated:: 0.9  The \*addl_attrs on :func:`_orm.undefer` is
 #eprecated and will be removed in a future release.   Please
 #se method chaining in conjunction with defaultload() to
 #ndicate a path.

 #. seealso::

 #ref:`deferred`

 #func:`_orm.defer`

 #func:`_orm.undefer_group`

 #""
 #eturn loadopt.set_column_strategy(
 #key,), {"deferred": False, "instrument": True}
 #


@undefer._add_unbound_fn
def undefer(key, *addl_attrs):
 #f addl_attrs:
 #til.warn_deprecated(
 #The *addl_attrs on orm.undefer is deprecated.  Please use "
 #method chaining in conjunction with defaultload() to "
 #indicate a path.",
 #ersion="1.3",
 #
 #eturn _UnboundLoad._from_keys(
 #UnboundLoad.undefer, (key,) + addl_attrs, False, {}
 #


@loader_option()
def undefer_group(loadopt, name):
 #""Indicate that columns within the given deferred group name should be
 #ndeferred.

 #he columns being undeferred are set up on the mapping as
 #func:`.deferred` attributes and include a "group" name.

 #.g::

 #ession.query(MyClass).options(undefer_group("large_attrs"))

 #o undefer a group of attributes on a related entity, the path can be
 #pelled out using relationship loader options, such as
 #func:`_orm.defaultload`::

 #ession.query(MyClass).options(
 #efaultload("someattr").undefer_group("large_attrs"))

 #. versionchanged:: 0.9.0 :func:`_orm.undefer_group` is now specific to a
 #articular entity load path.

 #. seealso::

 #ref:`deferred`

 #func:`_orm.defer`

 #func:`_orm.undefer`

 #""
 #eturn loadopt.set_column_strategy(
 #*", None, {"undefer_group_%s" % name: True}, opts_only=True
 #


@undefer_group._add_unbound_fn
def undefer_group(name):
 #eturn _UnboundLoad().undefer_group(name)


@loader_option()
def with_expression(loadopt, key, expression):
 #"""Apply an ad-hoc SQL expression to a "deferred expression" attribute.

 #his option is used in conjunction with the :func:`_orm.query_expression`
 #apper-level construct that indicates an attribute which should be the
 #arget of an ad-hoc SQL expression.

 #.g.::


 #ess.query(SomeClass).options(
 #ith_expression(SomeClass.x_y_expr, SomeClass.x + SomeClass.y)
 #

 #. versionadded:: 1.2

 #param key: Attribute to be undeferred.

 #param expr: SQL expression to be applied to the attribute.

 #. note:: the target attribute is populated only if the target object
 #s **not currently loaded** in the current :class:`_orm.Session`
 #nless the :meth:`_query.Query.populate_existing` method is used.
 #lease refer to :ref:`mapper_querytime_expression` for complete
 #sage details.

 #. seealso::

 #ref:`mapper_querytime_expression`

 #""

 #xpression = coercions.expect(
 #oles.LabeledColumnExprRole, _orm_full_deannotate(expression)
 #

 #eturn loadopt.set_column_strategy(
 #key,), {"query_expression": True}, opts={"expression": expression}
 #


@with_expression._add_unbound_fn
def with_expression(key, expression):
 #eturn _UnboundLoad._from_keys(
 #UnboundLoad.with_expression, (key,), False, {"expression": expression}
 #


@loader_option()
def selectin_polymorphic(loadopt, classes):
 #""Indicate an eager load should take place for all attributes
 #pecific to a subclass.

 #his uses an additional SELECT with IN against all matched primary
 #ey values, and is the per-query analogue to the ``"selectin"``
 #etting on the :paramref:`.mapper.polymorphic_load` parameter.

 #. versionadded:: 1.2

 #. seealso::

 #ref:`polymorphic_selectin`

 #""
 #oadopt.set_class_strategy(
 #"selectinload_polymorphic": True},
 #pts={
 #entities": tuple(
 #orted((inspect(cls) for cls in classes), key=id)
 #
 #,
 #
 #eturn loadopt


@selectin_polymorphic._add_unbound_fn
def selectin_polymorphic(base_cls, classes):
 #l = _UnboundLoad()
 #l.is_class_strategy = True
 #l.path = (inspect(base_cls),)
 #l.selectin_polymorphic(classes)
 #eturn ul
