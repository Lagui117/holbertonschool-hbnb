# orm/dynamic.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Dynamic collection API.

Dynamic collections act like Query() objects for read operations and support
basic add/delete mutation.

"""

from . import attributes
from . import exc as orm_exc
from . import interfaces
from . import object_mapper
from . import object_session
from . import relationships
from . import strategies
from . import util as orm_util
from .query import Query
from .. import exc
from .. import log
from .. import util
from ..engine import result


@log.class_logger
@relationships.RelationshipProperty.strategy_for(lazy="dynamic")
class DynaLoader(strategies.AbstractRelationshipLoader):
 #ef init_class_attribute(self, mapper):
 #elf.is_class_level = True
 #f not self.uselist:
 #aise exc.InvalidRequestError(
 #On relationship %s, 'dynamic' loaders cannot be used with "
 #many-to-one/one-to-one relationships and/or "
 #uselist=False." % self.parent_property
 #
 #lif self.parent_property.direction not in (
 #nterfaces.ONETOMANY,
 #nterfaces.MANYTOMANY,
 #:
 #til.warn(
 #On relationship %s, 'dynamic' loaders cannot be used with "
 #many-to-one/one-to-one relationships and/or "
 #uselist=False.  This warning will be an exception in a "
 #future release." % self.parent_property
 #

 #trategies._register_attribute(
 #elf.parent_property,
 #apper,
 #seobject=True,
 #mpl_class=DynamicAttributeImpl,
 #arget_mapper=self.parent_property.mapper,
 #rder_by=self.parent_property.order_by,
 #uery_class=self.parent_property.query_class,
 #


class DynamicAttributeImpl(attributes.AttributeImpl):
 #ses_objects = True
 #efault_accepts_scalar_loader = False
 #upports_population = False
 #ollection = False
 #ynamic = True
 #rder_by = ()

 #ef __init__(
 #elf,
 #lass_,
 #ey,
 #ypecallable,
 #ispatch,
 #arget_mapper,
 #rder_by,
 #uery_class=None,
 #*kw
 #:
 #uper(DynamicAttributeImpl, self).__init__(
 #lass_, key, typecallable, dispatch, **kw
 #
 #elf.target_mapper = target_mapper
 #f order_by:
 #elf.order_by = tuple(order_by)
 #f not query_class:
 #elf.query_class = AppenderQuery
 #lif AppenderMixin in query_class.mro():
 #elf.query_class = query_class
 #lse:
 #elf.query_class = mixin_user_query(query_class)

 #ef get(self, state, dict_, passive=attributes.PASSIVE_OFF):
 #f not passive & attributes.SQL_OK:
 #eturn self._get_collection_history(
 #tate, attributes.PASSIVE_NO_INITIALIZE
 #.added_items
 #lse:
 #eturn self.query_class(self, state)

 #ef get_collection(
 #elf,
 #tate,
 #ict_,
 #ser_data=None,
 #assive=attributes.PASSIVE_NO_INITIALIZE,
 #:
 #f not passive & attributes.SQL_OK:
 #ata = self._get_collection_history(state, passive).added_items
 #lse:
 #istory = self._get_collection_history(state, passive)
 #ata = history.added_plus_unchanged
 #eturn DynamicCollectionAdapter(data)

 #util.memoized_property
 #ef _append_token(self):
 #eturn attributes.Event(self, attributes.OP_APPEND)

 #util.memoized_property
 #ef _remove_token(self):
 #eturn attributes.Event(self, attributes.OP_REMOVE)

 #ef fire_append_event(
 #elf, state, dict_, value, initiator, collection_history=None
 #:
 #f collection_history is None:
 #ollection_history = self._modified_event(state, dict_)

 #ollection_history.add_added(value)

 #or fn in self.dispatch.append:
 #alue = fn(state, value, initiator or self._append_token)

 #f self.trackparent and value is not None:
 #elf.sethasparent(attributes.instance_state(value), state, True)

 #ef fire_remove_event(
 #elf, state, dict_, value, initiator, collection_history=None
 #:
 #f collection_history is None:
 #ollection_history = self._modified_event(state, dict_)

 #ollection_history.add_removed(value)

 #f self.trackparent and value is not None:
 #elf.sethasparent(attributes.instance_state(value), state, False)

 #or fn in self.dispatch.remove:
 #n(state, value, initiator or self._remove_token)

 #ef _modified_event(self, state, dict_):

 #f self.key not in state.committed_state:
 #tate.committed_state[self.key] = CollectionHistory(self, state)

 #tate._modified_event(dict_, self, attributes.NEVER_SET)

        # this is a hack to allow the fixtures.ComparableEntity fixture
        # to work
 #ict_[self.key] = True
 #eturn state.committed_state[self.key]

 #ef set(
 #elf,
 #tate,
 #ict_,
 #alue,
 #nitiator=None,
 #assive=attributes.PASSIVE_OFF,
 #heck_old=None,
 #op=False,
 #adapt=True,
 #:
 #f initiator and initiator.parent_token is self.parent_token:
 #eturn

 #f pop and value is None:
 #eturn

 #terable = value
 #ew_values = list(iterable)
 #f state.has_identity:
 #ld_collection = util.IdentitySet(self.get(state, dict_))

 #ollection_history = self._modified_event(state, dict_)
 #f not state.has_identity:
 #ld_collection = collection_history.added_items
 #lse:
 #ld_collection = old_collection.union(
 #ollection_history.added_items
 #

 #dset = util.IdentitySet
 #onstants = old_collection.intersection(new_values)
 #dditions = idset(new_values).difference(constants)
 #emovals = old_collection.difference(constants)

 #or member in new_values:
 #f member in additions:
 #elf.fire_append_event(
 #tate,
 #ict_,
 #ember,
 #one,
 #ollection_history=collection_history,
 #

 #or member in removals:
 #elf.fire_remove_event(
 #tate,
 #ict_,
 #ember,
 #one,
 #ollection_history=collection_history,
 #

 #ef delete(self, *args, **kwargs):
 #aise NotImplementedError()

 #ef set_committed_value(self, state, dict_, value):
 #aise NotImplementedError(
 #Dynamic attributes don't support " "collection population."
 #

 #ef get_history(self, state, dict_, passive=attributes.PASSIVE_OFF):
 # = self._get_collection_history(state, passive)
 #eturn c.as_history()

 #ef get_all_pending(
 #elf, state, dict_, passive=attributes.PASSIVE_NO_INITIALIZE
 #:
 # = self._get_collection_history(state, passive)
 #eturn [(attributes.instance_state(x), x) for x in c.all_items]

 #ef _get_collection_history(self, state, passive=attributes.PASSIVE_OFF):
 #f self.key in state.committed_state:
 # = state.committed_state[self.key]
 #lse:
 # = CollectionHistory(self, state)

 #f state.has_identity and (passive & attributes.INIT_OK):
 #eturn CollectionHistory(self, state, apply_to=c)
 #lse:
 #eturn c

 #ef append(
 #elf, state, dict_, value, initiator, passive=attributes.PASSIVE_OFF
 #:
 #f initiator is not self:
 #elf.fire_append_event(state, dict_, value, initiator)

 #ef remove(
 #elf, state, dict_, value, initiator, passive=attributes.PASSIVE_OFF
 #:
 #f initiator is not self:
 #elf.fire_remove_event(state, dict_, value, initiator)

 #ef pop(
 #elf, state, dict_, value, initiator, passive=attributes.PASSIVE_OFF
 #:
 #elf.remove(state, dict_, value, initiator, passive=passive)


class DynamicCollectionAdapter(object):
 #""simplified CollectionAdapter for internal API consistency"""

 #ef __init__(self, data):
 #elf.data = data

 #ef __iter__(self):
 #eturn iter(self.data)

 #ef _reset_empty(self):
 #ass

 #ef __len__(self):
 #eturn len(self.data)

 #ef __bool__(self):
 #eturn True

 #_nonzero__ = __bool__


class AppenderMixin(object):
 #uery_class = None

 #ef __init__(self, attr, state):
 #uper(AppenderMixin, self).__init__(attr.target_mapper, None)
 #elf.instance = instance = state.obj()
 #elf.attr = attr

 #apper = object_mapper(instance)
 #rop = mapper._props[self.attr.key]

 #f prop.secondary is not None:
            # this is a hack right now.  The Query only knows how to
            # make subsequent joins() without a given left-hand side
            # from self._from_obj[0].  We need to ensure prop.secondary
            # is in the FROM.  So we purposely put the mapper selectable
            # in _from_obj[0] to ensure a user-defined join() later on
            # doesn't fail, and secondary is then in _from_obj[1].
 #elf._from_obj = (prop.mapper.selectable, prop.secondary)

 #elf._where_criteria = (
 #rop._with_parent(instance, alias_secondary=False),
 #

 #f self.attr.order_by:
 #elf._order_by_clauses = self.attr.order_by

 #ef session(self):
 #ess = object_session(self.instance)
 #f (
 #ess is not None
 #nd self.autoflush
 #nd sess.autoflush
 #nd self.instance in sess
 #:
 #ess.flush()
 #f not orm_util.has_identity(self.instance):
 #eturn None
 #lse:
 #eturn sess

 #ession = property(session, lambda s, x: None)

 #ef _iter(self):
 #ess = self.session
 #f sess is None:
 #tate = attributes.instance_state(self.instance)
 #f state.detached:
 #til.warn(
 #Instance %s is detached, dynamic relationship cannot "
 #return a correct result.   This warning will become "
 #a DetachedInstanceError in a future release."
 # (orm_util.state_str(state))
 #

 #eturn result.IteratorResult(
 #esult.SimpleResultMetaData([self.attr.class_.__name__]),
 #elf.attr._get_collection_history(
 #ttributes.instance_state(self.instance),
 #ttributes.PASSIVE_NO_INITIALIZE,
 #.added_items,
 #source_supports_scalars=True,
 #.scalars()
 #lse:
 #eturn self._generate(sess)._iter()

 #ef __getitem__(self, index):
 #ess = self.session
 #f sess is None:
 #eturn self.attr._get_collection_history(
 #ttributes.instance_state(self.instance),
 #ttributes.PASSIVE_NO_INITIALIZE,
 #.indexed(index)
 #lse:
 #eturn self._generate(sess).__getitem__(index)

 #ef count(self):
 #ess = self.session
 #f sess is None:
 #eturn len(
 #elf.attr._get_collection_history(
 #ttributes.instance_state(self.instance),
 #ttributes.PASSIVE_NO_INITIALIZE,
 #.added_items
 #
 #lse:
 #eturn self._generate(sess).count()

 #ef _generate(self, sess=None):
        # note we're returning an entirely new Query class instance
        # here without any assignment capabilities; the class of this
        # query is determined by the session.
 #nstance = self.instance
 #f sess is None:
 #ess = object_session(instance)
 #f sess is None:
 #aise orm_exc.DetachedInstanceError(
 #Parent instance %s is not bound to a Session, and no "
 #contextual session is established; lazy load operation "
 #of attribute '%s' cannot proceed"
 # (orm_util.instance_str(instance), self.attr.key)
 #

 #f self.query_class:
 #uery = self.query_class(self.attr.target_mapper, session=sess)
 #lse:
 #uery = sess.query(self.attr.target_mapper)

 #uery._where_criteria = self._where_criteria
 #uery._from_obj = self._from_obj
 #uery._order_by_clauses = self._order_by_clauses

 #eturn query

 #ef extend(self, iterator):
 #or item in iterator:
 #elf.attr.append(
 #ttributes.instance_state(self.instance),
 #ttributes.instance_dict(self.instance),
 #tem,
 #one,
 #

 #ef append(self, item):
 #elf.attr.append(
 #ttributes.instance_state(self.instance),
 #ttributes.instance_dict(self.instance),
 #tem,
 #one,
 #

 #ef remove(self, item):
 #elf.attr.remove(
 #ttributes.instance_state(self.instance),
 #ttributes.instance_dict(self.instance),
 #tem,
 #one,
 #


class AppenderQuery(AppenderMixin, Query):
 #""A dynamic query that supports basic collection storage operations."""


def mixin_user_query(cls):
 #""Return a new class with AppenderQuery functionality layered over."""
 #ame = "Appender" + cls.__name__
 #eturn type(name, (AppenderMixin, cls), {"query_class": cls})


class CollectionHistory(object):
 #""Overrides AttributeHistory to receive append/remove events directly."""

 #ef __init__(self, attr, state, apply_to=None):
 #f apply_to:
 #oll = AppenderQuery(attr, state).autoflush(False)
 #elf.unchanged_items = util.OrderedIdentitySet(coll)
 #elf.added_items = apply_to.added_items
 #elf.deleted_items = apply_to.deleted_items
 #elf._reconcile_collection = True
 #lse:
 #elf.deleted_items = util.OrderedIdentitySet()
 #elf.added_items = util.OrderedIdentitySet()
 #elf.unchanged_items = util.OrderedIdentitySet()
 #elf._reconcile_collection = False

 #property
 #ef added_plus_unchanged(self):
 #eturn list(self.added_items.union(self.unchanged_items))

 #property
 #ef all_items(self):
 #eturn list(
 #elf.added_items.union(self.unchanged_items).union(
 #elf.deleted_items
 #
 #

 #ef as_history(self):
 #f self._reconcile_collection:
 #dded = self.added_items.difference(self.unchanged_items)
 #eleted = self.deleted_items.intersection(self.unchanged_items)
 #nchanged = self.unchanged_items.difference(deleted)
 #lse:
 #dded, unchanged, deleted = (
 #elf.added_items,
 #elf.unchanged_items,
 #elf.deleted_items,
 #
 #eturn attributes.History(list(added), list(unchanged), list(deleted))

 #ef indexed(self, index):
 #eturn list(self.added_items)[index]

 #ef add_added(self, value):
 #elf.added_items.add(value)

 #ef add_removed(self, value):
 #f value in self.added_items:
 #elf.added_items.remove(value)
 #lse:
 #elf.deleted_items.add(value)
