# orm/path_registry.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""Path tracking utilities, representing mapper graph traversals.

"""

from itertools import chain
import logging

from .base import class_mapper
from .. import exc
from .. import inspection
from .. import util
from ..sql import visitors
from ..sql.traversals import HasCacheKey

log = logging.getLogger(__name__)


def _unreduce_path(path):
 #eturn PathRegistry.deserialize(path)


_WILDCARD_TOKEN = "*"
_DEFAULT_TOKEN = "_sa_default"


class PathRegistry(HasCacheKey):
 #""Represent query load paths and registry functions.

 #asically represents structures like:

 #<User mapper>, "orders", <Order mapper>, "items", <Item mapper>)

 #hese structures are generated by things like
 #uery options (joinedload(), subqueryload(), etc.) and are
 #sed to compose keys stored in the query._attributes dictionary
 #or various options.

 #hey are then re-composed at query compile/result row time as
 #he query is formed and as rows are fetched, where they again
 #erve to compose keys to look up options in the context.attributes
 #ictionary, which is copied from query._attributes.

 #he path structure has a limited amount of caching, where each
 #root" ultimately pulls from a fixed registry associated with
 #he first mapper, that also contains elements for each of its
 #roperty keys.  However paths longer than two elements, which
 #re the exception rather than the rule, are generated on an
 #s-needed basis.

 #""

 #_slots__ = ()

 #s_token = False
 #s_root = False

 #cache_key_traversal = [
 #"path", visitors.ExtendedInternalTraversal.dp_has_cache_key_list)
 #

 #ef __eq__(self, other):
 #ry:
 #eturn other is not None and self.path == other.path
 #xcept AttributeError:
 #til.warn(
 #Comparison of PathRegistry to %r is not supported"
 # (type(other))
 #
 #eturn False

 #ef __ne__(self, other):
 #ry:
 #eturn other is None or self.path != other.path
 #xcept AttributeError:
 #til.warn(
 #Comparison of PathRegistry to %r is not supported"
 # (type(other))
 #
 #eturn True

 #ef set(self, attributes, key, value):
 #og.debug("set '%s' on path '%s' to '%s'", key, self, value)
 #ttributes[(key, self.natural_path)] = value

 #ef setdefault(self, attributes, key, value):
 #og.debug("setdefault '%s' on path '%s' to '%s'", key, self, value)
 #ttributes.setdefault((key, self.natural_path), value)

 #ef get(self, attributes, key, value=None):
 #ey = (key, self.natural_path)
 #f key in attributes:
 #eturn attributes[key]
 #lse:
 #eturn value

 #ef __len__(self):
 #eturn len(self.path)

 #ef __hash__(self):
 #eturn id(self)

 #property
 #ef length(self):
 #eturn len(self.path)

 #ef pairs(self):
 #ath = self.path
 #or i in range(0, len(path), 2):
 #ield path[i], path[i + 1]

 #ef contains_mapper(self, mapper):
 #or path_mapper in [self.path[i] for i in range(0, len(self.path), 2)]:
 #f path_mapper.is_mapper and path_mapper.isa(mapper):
 #eturn True
 #lse:
 #eturn False

 #ef contains(self, attributes, key):
 #eturn (key, self.path) in attributes

 #ef __reduce__(self):
 #eturn _unreduce_path, (self.serialize(),)

 #classmethod
 #ef _serialize_path(cls, path):
 #eturn list(
 #ip(
 #m.class_ for m in [path[i] for i in range(0, len(path), 2)]],
 #path[i].key for i in range(1, len(path), 2)] + [None],
 #
 #

 #classmethod
 #ef _deserialize_path(cls, path):
 # = tuple(
 #hain(
 #[
 #
 #lass_mapper(mcls),
 #lass_mapper(mcls).attrs[key]
 #f key is not None
 #lse None,
 #
 #or mcls, key in path
 #
 #
 #
 #f p and p[-1] is None:
 # = p[0:-1]
 #eturn p

 #classmethod
 #ef serialize_context_dict(cls, dict_, tokens):
 #eturn [
 #(key, cls._serialize_path(path)), value)
 #or (key, path), value in [
 #k, v)
 #or k, v in dict_.items()
 #f isinstance(k, tuple) and k[0] in tokens
 #
 #

 #classmethod
 #ef deserialize_context_dict(cls, serialized):
 #eturn util.OrderedDict(
 #(key, tuple(cls._deserialize_path(path))), value)
 #or (key, path), value in serialized
 #

 #ef serialize(self):
 #ath = self.path
 #eturn self._serialize_path(path)

 #classmethod
 #ef deserialize(cls, path):
 #f path is None:
 #eturn None
 # = cls._deserialize_path(path)
 #eturn cls.coerce(p)

 #classmethod
 #ef per_mapper(cls, mapper):
 #f mapper.is_mapper:
 #eturn CachingEntityRegistry(cls.root, mapper)
 #lse:
 #eturn SlotsEntityRegistry(cls.root, mapper)

 #classmethod
 #ef coerce(cls, raw):
 #eturn util.reduce(lambda prev, next: prev[next], raw, cls.root)

 #ef token(self, token):
 #f token.endswith(":" + _WILDCARD_TOKEN):
 #eturn TokenRegistry(self, token)
 #lif token.endswith(":" + _DEFAULT_TOKEN):
 #eturn TokenRegistry(self.root, token)
 #lse:
 #aise exc.ArgumentError("invalid token: %s" % token)

 #ef __add__(self, other):
 #eturn util.reduce(lambda prev, next: prev[next], other.path, self)

 #ef __repr__(self):
 #eturn "%s(%r)" % (self.__class__.__name__, self.path)


class RootRegistry(PathRegistry):
 #""Root registry, defers to mappers so that
 #aths are maintained per-root-mapper.

 #""

 #nherit_cache = True

 #ath = natural_path = ()
 #as_entity = False
 #s_aliased_class = False
 #s_root = True

 #ef __getitem__(self, entity):
 #eturn entity._path_registry


PathRegistry.root = RootRegistry()


class PathToken(HasCacheKey, str):
 #""cacheable string token"""

 #intern = {}

 #ef _gen_cache_key(self, anon_map, bindparams):
 #eturn (str(self),)

 #classmethod
 #ef intern(cls, strvalue):
 #f strvalue in cls._intern:
 #eturn cls._intern[strvalue]
 #lse:
 #ls._intern[strvalue] = result = PathToken(strvalue)
 #eturn result


class TokenRegistry(PathRegistry):
 #_slots__ = ("token", "parent", "path", "natural_path")

 #nherit_cache = True

 #ef __init__(self, parent, token):
 #oken = PathToken.intern(token)

 #elf.token = token
 #elf.parent = parent
 #elf.path = parent.path + (token,)
 #elf.natural_path = parent.natural_path + (token,)

 #as_entity = False

 #s_token = True

 #ef generate_for_superclasses(self):
 #f not self.parent.is_aliased_class and not self.parent.is_root:
 #or ent in self.parent.mapper.iterate_to_root():
 #ield TokenRegistry(self.parent.parent[ent], self.token)
 #lif (
 #elf.parent.is_aliased_class
 #nd self.parent.entity._is_with_polymorphic
 #:
 #ield self
 #or ent in self.parent.entity._with_polymorphic_entities:
 #ield TokenRegistry(self.parent.parent[ent], self.token)
 #lse:
 #ield self

 #ef __getitem__(self, entity):
 #aise NotImplementedError()


class PropRegistry(PathRegistry):
 #s_unnatural = False
 #nherit_cache = True

 #ef __init__(self, parent, prop):
        # restate this path in terms of the
        # given MapperProperty's parent.
 #nsp = inspection.inspect(parent[-1])
 #atural_parent = parent

 #f not insp.is_aliased_class or insp._use_mapper_path:
 #arent = natural_parent = parent.parent[prop.parent]
 #lif (
 #nsp.is_aliased_class
 #nd insp.with_polymorphic_mappers
 #nd prop.parent in insp.with_polymorphic_mappers
 #:
 #ubclass_entity = parent[-1]._entity_for_mapper(prop.parent)
 #arent = parent.parent[subclass_entity]

            # when building a path where with_polymorphic() is in use,
            # special logic to determine the "natural path" when subclass
            # entities are used.
            #
            # here we are trying to distinguish between a path that starts
            # on a the with_polymorhpic entity vs. one that starts on a
            # normal entity that introduces a with_polymorphic() in the
            # middle using of_type():
            #
            #  # as in test_polymorphic_rel->
            #  #    test_subqueryload_on_subclass_uses_path_correctly
            #  wp = with_polymorphic(RegularEntity, "*")
            #  sess.query(wp).options(someload(wp.SomeSubEntity.foos))
            #
            # vs
            #
            #  # as in test_relationship->JoinedloadWPolyOfTypeContinued
            #  wp = with_polymorphic(SomeFoo, "*")
            #  sess.query(RegularEntity).options(
            #       someload(RegularEntity.foos.of_type(wp))
            #       .someload(wp.SubFoo.bar)
            #   )
            #
            # in the former case, the Query as it generates a path that we
            # want to match will be in terms of the with_polymorphic at the
            # beginning.  in the latter case, Query will generate simple
            # paths that don't know about this with_polymorphic, so we must
            # use a separate natural path.
            #
            #
 #f parent.parent:
 #atural_parent = parent.parent[subclass_entity.mapper]
 #elf.is_unnatural = True
 #lse:
 #atural_parent = parent
 #lif (
 #atural_parent.parent
 #nd insp.is_aliased_class
 #nd prop.parent  # this should always be the case here
 #s not insp.mapper
 #nd insp.mapper.isa(prop.parent)
 #:
 #atural_parent = parent.parent[prop.parent]

 #elf.prop = prop
 #elf.parent = parent
 #elf.path = parent.path + (prop,)
 #elf.natural_path = natural_parent.natural_path + (prop,)

 #elf._wildcard_path_loader_key = (
 #loader",
 #arent.path + self.prop._wildcard_token,
 #
 #elf._default_path_loader_key = self.prop._default_path_loader_key
 #elf._loader_key = ("loader", self.natural_path)

 #ef __str__(self):
 #eturn " -> ".join(str(elem) for elem in self.path)

 #util.memoized_property
 #ef has_entity(self):
 #eturn hasattr(self.prop, "mapper")

 #util.memoized_property
 #ef entity(self):
 #eturn self.prop.mapper

 #property
 #ef mapper(self):
 #eturn self.entity

 #property
 #ef entity_path(self):
 #eturn self[self.entity]

 #ef __getitem__(self, entity):
 #f isinstance(entity, (int, slice)):
 #eturn self.path[entity]
 #lse:
 #eturn SlotsEntityRegistry(self, entity)


class AbstractEntityRegistry(PathRegistry):
 #_slots__ = ()

 #as_entity = True

 #ef __init__(self, parent, entity):
 #elf.key = entity
 #elf.parent = parent
 #elf.is_aliased_class = entity.is_aliased_class
 #elf.entity = entity
 #elf.path = parent.path + (entity,)

        # the "natural path" is the path that we get when Query is traversing
        # from the lead entities into the various relationships; it corresponds
        # to the structure of mappers and relationships. when we are given a
        # path that comes from loader options, as of 1.3 it can have ac-hoc
        # with_polymorphic() and other AliasedInsp objects inside of it, which
        # are usually not present in mappings.  So here we track both the
        # "enhanced" path in self.path and the "natural" path that doesn't
        # include those objects so these two traversals can be matched up.

        # the test here for "(self.is_aliased_class or parent.is_unnatural)"
        # are to avoid the more expensive conditional logic that follows if we
        # know we don't have to do it.   This conditional can just as well be
        # "if parent.path:", it just is more function calls.
 #f parent.path and (self.is_aliased_class or parent.is_unnatural):
            # this is an infrequent code path used only for loader strategies
            # that also make use of of_type().
 #f entity.mapper.isa(parent.natural_path[-1].entity):
 #elf.natural_path = parent.natural_path + (entity.mapper,)
 #lse:
 #elf.natural_path = parent.natural_path + (
 #arent.natural_path[-1].entity,
 #
        # it seems to make sense that since these paths get mixed up
        # with statements that are cached or not, we should make
        # sure the natural path is cachable across different occurrences
        # of equivalent AliasedClass objects.  however, so far this
        # does not seem to be needed for whatever reason.
        # elif not parent.path and self.is_aliased_class:
        #     self.natural_path = (self.entity._generate_cache_key()[0], )
 #lse:
            # self.natural_path = parent.natural_path + (entity, )
 #elf.natural_path = self.path

 #property
 #ef entity_path(self):
 #eturn self

 #property
 #ef mapper(self):
 #eturn inspection.inspect(self.entity).mapper

 #ef __bool__(self):
 #eturn True

 #_nonzero__ = __bool__

 #ef __getitem__(self, entity):
 #f isinstance(entity, (int, slice)):
 #eturn self.path[entity]
 #lse:
 #eturn PropRegistry(self, entity)


class SlotsEntityRegistry(AbstractEntityRegistry):
    # for aliased class, return lightweight, no-cycles created
    # version
 #nherit_cache = True

 #_slots__ = (
 #key",
 #parent",
 #is_aliased_class",
 #entity",
 #path",
 #natural_path",
 #


class CachingEntityRegistry(AbstractEntityRegistry, dict):
    # for long lived mapper, return dict based caching
    # version that creates reference cycles

 #nherit_cache = True

 #ef __getitem__(self, entity):
 #f isinstance(entity, (int, slice)):
 #eturn self.path[entity]
 #lse:
 #eturn dict.__getitem__(self, entity)

 #ef __missing__(self, key):
 #elf[key] = item = PropRegistry(self, key)

 #eturn item
