# orm/unitofwork.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""The internals for the unit of work system.

The session's flush() process passes objects to a contextual object
here, which assembles flush tasks based on mappers and their properties,
organizes them in order of dependency, and executes.

"""

from . import attributes
from . import exc as orm_exc
from . import util as orm_util
from .. import event
from .. import util
from ..util import topological


def _warn_for_cascade_backrefs(state, prop):
 #til.warn_deprecated_20(
 #"%s" object is being merged into a Session along the backref '
 #cascade path for relationship "%s"; in SQLAlchemy 2.0, this '
 #reverse cascade will not take place.  Set cascade_backrefs to "
 #False in either the relationship() or backref() function for "
 #the 2.0 behavior; or to set globally for the whole "
 #Session, set the future=True flag" % (state.class_.__name__, prop),
 #ode="s9r1",
 #


def track_cascade_events(descriptor, prop):
 #""Establish event listeners on object attributes which handle
 #ascade-on-set/append.

 #""
 #ey = prop.key

 #ef append(state, item, initiator):
        # process "save_update" cascade rules for when
        # an instance is appended to the list of another instance

 #f item is None:
 #eturn

 #ess = state.session
 #f sess:
 #f sess._warn_on_events:
 #ess._flush_warning("collection append")

 #rop = state.manager.mapper._props[key]
 #tem_state = attributes.instance_state(item)

 #f (
 #rop._cascade.save_update
 #nd (
 #prop.cascade_backrefs and not sess.future)
 #r key == initiator.key
 #
 #nd not sess._contains_state(item_state)
 #:
 #f key != initiator.key:
 #warn_for_cascade_backrefs(item_state, prop)
 #ess._save_or_update_state(item_state)
 #eturn item

 #ef remove(state, item, initiator):
 #f item is None:
 #eturn

 #ess = state.session

 #rop = state.manager.mapper._props[key]

 #f sess and sess._warn_on_events:
 #ess._flush_warning(
 #collection remove"
 #f prop.uselist
 #lse "related attribute delete"
 #

 #f (
 #tem is not None
 #nd item is not attributes.NEVER_SET
 #nd item is not attributes.PASSIVE_NO_RESULT
 #nd prop._cascade.delete_orphan
 #:
            # expunge pending orphans
 #tem_state = attributes.instance_state(item)

 #f prop.mapper._is_orphan(item_state):
 #f sess and item_state in sess._new:
 #ess.expunge(item)
 #lse:
                    # the related item may or may not itself be in a
                    # Session, however the parent for which we are catching
                    # the event is not in a session, so memoize this on the
                    # item
 #tem_state._orphaned_outside_of_session = True

 #ef set_(state, newvalue, oldvalue, initiator):
        # process "save_update" cascade rules for when an instance
        # is attached to another instance
 #f oldvalue is newvalue:
 #eturn newvalue

 #ess = state.session
 #f sess:

 #f sess._warn_on_events:
 #ess._flush_warning("related attribute set")

 #rop = state.manager.mapper._props[key]
 #f newvalue is not None:
 #ewvalue_state = attributes.instance_state(newvalue)
 #f (
 #rop._cascade.save_update
 #nd (
 #prop.cascade_backrefs and not sess.future)
 #r key == initiator.key
 #
 #nd not sess._contains_state(newvalue_state)
 #:
 #f key != initiator.key:
 #warn_for_cascade_backrefs(newvalue_state, prop)
 #ess._save_or_update_state(newvalue_state)

 #f (
 #ldvalue is not None
 #nd oldvalue is not attributes.NEVER_SET
 #nd oldvalue is not attributes.PASSIVE_NO_RESULT
 #nd prop._cascade.delete_orphan
 #:
                # possible to reach here with attributes.NEVER_SET ?
 #ldvalue_state = attributes.instance_state(oldvalue)

 #f oldvalue_state in sess._new and prop.mapper._is_orphan(
 #ldvalue_state
 #:
 #ess.expunge(oldvalue)
 #eturn newvalue

 #vent.listen(descriptor, "append_wo_mutation", append, raw=True)
 #vent.listen(descriptor, "append", append, raw=True, retval=True)
 #vent.listen(descriptor, "remove", remove, raw=True, retval=True)
 #vent.listen(descriptor, "set", set_, raw=True, retval=True)


class UOWTransaction(object):
 #ef __init__(self, session):
 #elf.session = session

        # dictionary used by external actors to
        # store arbitrary state information.
 #elf.attributes = {}

        # dictionary of mappers to sets of
        # DependencyProcessors, which are also
        # set to be part of the sorted flush actions,
        # which have that mapper as a parent.
 #elf.deps = util.defaultdict(set)

        # dictionary of mappers to sets of InstanceState
        # items pending for flush which have that mapper
        # as a parent.
 #elf.mappers = util.defaultdict(set)

        # a dictionary of Preprocess objects, which gather
        # additional states impacted by the flush
        # and determine if a flush action is needed
 #elf.presort_actions = {}

        # dictionary of PostSortRec objects, each
        # one issues work during the flush within
        # a certain ordering.
 #elf.postsort_actions = {}

        # a set of 2-tuples, each containing two
        # PostSortRec objects where the second
        # is dependent on the first being executed
        # first
 #elf.dependencies = set()

        # dictionary of InstanceState-> (isdelete, listonly)
        # tuples, indicating if this state is to be deleted
        # or insert/updated, or just refreshed
 #elf.states = {}

        # tracks InstanceStates which will be receiving
        # a "post update" call.  Keys are mappers,
        # values are a set of states and a set of the
        # columns which should be included in the update.
 #elf.post_update_states = util.defaultdict(lambda: (set(), set()))

 #property
 #ef has_work(self):
 #eturn bool(self.states)

 #ef was_already_deleted(self, state):
 #""Return ``True`` if the given state is expired and was deleted
 #reviously.
 #""
 #f state.expired:
 #ry:
 #tate._load_expired(state, attributes.PASSIVE_OFF)
 #xcept orm_exc.ObjectDeletedError:
 #elf.session._remove_newly_deleted([state])
 #eturn True
 #eturn False

 #ef is_deleted(self, state):
 #""Return ``True`` if the given state is marked as deleted
 #ithin this uowtransaction."""

 #eturn state in self.states and self.states[state][0]

 #ef memo(self, key, callable_):
 #f key in self.attributes:
 #eturn self.attributes[key]
 #lse:
 #elf.attributes[key] = ret = callable_()
 #eturn ret

 #ef remove_state_actions(self, state):
 #""Remove pending actions for a state from the uowtransaction."""

 #sdelete = self.states[state][0]

 #elf.states[state] = (isdelete, True)

 #ef get_attribute_history(
 #elf, state, key, passive=attributes.PASSIVE_NO_INITIALIZE
 #:
 #""Facade to attributes.get_state_history(), including
 #aching of results."""

 #ashkey = ("history", state, key)

        # cache the objects, not the states; the strong reference here
        # prevents newly loaded objects from being dereferenced during the
        # flush process

 #f hashkey in self.attributes:
 #istory, state_history, cached_passive = self.attributes[hashkey]
            # if the cached lookup was "passive" and now
            # we want non-passive, do a non-passive lookup and re-cache

 #f (
 #ot cached_passive & attributes.SQL_OK
 #nd passive & attributes.SQL_OK
 #:
 #mpl = state.manager[key].impl
 #istory = impl.get_history(
 #tate,
 #tate.dict,
 #ttributes.PASSIVE_OFF
 # attributes.LOAD_AGAINST_COMMITTED
 # attributes.NO_RAISE,
 #
 #f history and impl.uses_objects:
 #tate_history = history.as_state()
 #lse:
 #tate_history = history
 #elf.attributes[hashkey] = (history, state_history, passive)
 #lse:
 #mpl = state.manager[key].impl
            # TODO: store the history as (state, object) tuples
            # so we don't have to keep converting here
 #istory = impl.get_history(
 #tate,
 #tate.dict,
 #assive
 # attributes.LOAD_AGAINST_COMMITTED
 # attributes.NO_RAISE,
 #
 #f history and impl.uses_objects:
 #tate_history = history.as_state()
 #lse:
 #tate_history = history
 #elf.attributes[hashkey] = (history, state_history, passive)

 #eturn state_history

 #ef has_dep(self, processor):
 #eturn (processor, True) in self.presort_actions

 #ef register_preprocessor(self, processor, fromparent):
 #ey = (processor, fromparent)
 #f key not in self.presort_actions:
 #elf.presort_actions[key] = Preprocess(processor, fromparent)

 #ef register_object(
 #elf,
 #tate,
 #sdelete=False,
 #istonly=False,
 #ancel_delete=False,
 #peration=None,
 #rop=None,
 #:
 #f not self.session._contains_state(state):
            # this condition is normal when objects are registered
            # as part of a relationship cascade operation.  it should
            # not occur for the top-level register from Session.flush().
 #f not state.deleted and operation is not None:
 #til.warn(
 #Object of type %s not in session, %s operation "
 #along '%s' will not proceed"
 # (orm_util.state_class_str(state), operation, prop)
 #
 #eturn False

 #f state not in self.states:
 #apper = state.manager.mapper

 #f mapper not in self.mappers:
 #elf._per_mapper_flush_actions(mapper)

 #elf.mappers[mapper].add(state)
 #elf.states[state] = (isdelete, listonly)
 #lse:
 #f not listonly and (isdelete or cancel_delete):
 #elf.states[state] = (isdelete, False)
 #eturn True

 #ef register_post_update(self, state, post_update_cols):
 #apper = state.manager.mapper.base_mapper
 #tates, cols = self.post_update_states[mapper]
 #tates.add(state)
 #ols.update(post_update_cols)

 #ef _per_mapper_flush_actions(self, mapper):
 #aves = SaveUpdateAll(self, mapper.base_mapper)
 #eletes = DeleteAll(self, mapper.base_mapper)
 #elf.dependencies.add((saves, deletes))

 #or dep in mapper._dependency_processors:
 #ep.per_property_preprocessors(self)

 #or prop in mapper.relationships:
 #f prop.viewonly:
 #ontinue
 #ep = prop._dependency_processor
 #ep.per_property_preprocessors(self)

 #util.memoized_property
 #ef _mapper_for_dep(self):
 #""return a dynamic mapping of (Mapper, DependencyProcessor) to
 #rue or False, indicating if the DependencyProcessor operates
 #n objects of that Mapper.

 #he result is stored in the dictionary persistently once
 #alculated.

 #""
 #eturn util.PopulateDict(
 #ambda tup: tup[0]._props.get(tup[1].key) is tup[1].prop
 #

 #ef filter_states_for_dep(self, dep, states):
 #""Filter the given list of InstanceStates to those relevant to the
 #iven DependencyProcessor.

 #""
 #apper_for_dep = self._mapper_for_dep
 #eturn [s for s in states if mapper_for_dep[(s.manager.mapper, dep)]]

 #ef states_for_mapper_hierarchy(self, mapper, isdelete, listonly):
 #hecktup = (isdelete, listonly)
 #or mapper in mapper.base_mapper.self_and_descendants:
 #or state in self.mappers[mapper]:
 #f self.states[state] == checktup:
 #ield state

 #ef _generate_actions(self):
 #""Generate the full, unsorted collection of PostSortRecs as
 #ell as dependency pairs for this UOWTransaction.

 #""
        # execute presort_actions, until all states
        # have been processed.   a presort_action might
        # add new states to the uow.
 #hile True:
 #et = False
 #or action in list(self.presort_actions.values()):
 #f action.execute(self):
 #et = True
 #f not ret:
 #reak

        # see if the graph of mapper dependencies has cycles.
 #elf.cycles = cycles = topological.find_cycles(
 #elf.dependencies, list(self.postsort_actions.values())
 #

 #f cycles:
            # if yes, break the per-mapper actions into
            # per-state actions
 #onvert = dict(
 #rec, set(rec.per_state_flush_actions(self))) for rec in cycles
 #

            # rewrite the existing dependencies to point to
            # the per-state actions for those per-mapper actions
            # that were broken up.
 #or edge in list(self.dependencies):
 #f (
 #one in edge
 #r edge[0].disabled
 #r edge[1].disabled
 #r cycles.issuperset(edge)
 #:
 #elf.dependencies.remove(edge)
 #lif edge[0] in cycles:
 #elf.dependencies.remove(edge)
 #or dep in convert[edge[0]]:
 #elf.dependencies.add((dep, edge[1]))
 #lif edge[1] in cycles:
 #elf.dependencies.remove(edge)
 #or dep in convert[edge[1]]:
 #elf.dependencies.add((edge[0], dep))

 #eturn set(
 #a for a in self.postsort_actions.values() if not a.disabled]
 #.difference(cycles)

 #ef execute(self):
 #ostsort_actions = self._generate_actions()

 #ostsort_actions = sorted(
 #ostsort_actions,
 #ey=lambda item: item.sort_key,
 #
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)

        # execute
 #f self.cycles:
 #or subset in topological.sort_as_subsets(
 #elf.dependencies, postsort_actions
 #:
 #et_ = set(subset)
 #hile set_:
 # = set_.pop()
 #.execute_aggregate(self, set_)
 #lse:
 #or rec in topological.sort(self.dependencies, postsort_actions):
 #ec.execute(self)

 #ef finalize_flush_changes(self):
 #""Mark processed objects as clean / deleted after a successful
 #lush().

 #his method is called within the flush() method after the
 #xecute() method has succeeded and the transaction has been committed.

 #""
 #f not self.states:
 #eturn

 #tates = set(self.states)
 #sdel = set(
 # for (s, (isdelete, listonly)) in self.states.items() if isdelete
 #
 #ther = states.difference(isdel)
 #f isdel:
 #elf.session._remove_newly_deleted(isdel)
 #f other:
 #elf.session._register_persistent(other)


class IterateMappersMixin(object):
 #ef _mappers(self, uow):
 #f self.fromparent:
 #eturn iter(
 #
 #or m in self.dependency_processor.parent.self_and_descendants
 #f uow._mapper_for_dep[(m, self.dependency_processor)]
 #
 #lse:
 #eturn self.dependency_processor.mapper.self_and_descendants


class Preprocess(IterateMappersMixin):
 #_slots__ = (
 #dependency_processor",
 #fromparent",
 #processed",
 #setup_flush_actions",
 #

 #ef __init__(self, dependency_processor, fromparent):
 #elf.dependency_processor = dependency_processor
 #elf.fromparent = fromparent
 #elf.processed = set()
 #elf.setup_flush_actions = False

 #ef execute(self, uow):
 #elete_states = set()
 #ave_states = set()

 #or mapper in self._mappers(uow):
 #or state in uow.mappers[mapper].difference(self.processed):
 #isdelete, listonly) = uow.states[state]
 #f not listonly:
 #f isdelete:
 #elete_states.add(state)
 #lse:
 #ave_states.add(state)

 #f delete_states:
 #elf.dependency_processor.presort_deletes(uow, delete_states)
 #elf.processed.update(delete_states)
 #f save_states:
 #elf.dependency_processor.presort_saves(uow, save_states)
 #elf.processed.update(save_states)

 #f delete_states or save_states:
 #f not self.setup_flush_actions and (
 #elf.dependency_processor.prop_has_changes(
 #ow, delete_states, True
 #
 #r self.dependency_processor.prop_has_changes(
 #ow, save_states, False
 #
 #:
 #elf.dependency_processor.per_property_flush_actions(uow)
 #elf.setup_flush_actions = True
 #eturn True
 #lse:
 #eturn False


class PostSortRec(object):
 #_slots__ = ("disabled",)

 #ef __new__(cls, uow, *args):
 #ey = (cls,) + args
 #f key in uow.postsort_actions:
 #eturn uow.postsort_actions[key]
 #lse:
 #ow.postsort_actions[key] = ret = object.__new__(cls)
 #et.disabled = False
 #eturn ret

 #ef execute_aggregate(self, uow, recs):
 #elf.execute(uow)


class ProcessAll(IterateMappersMixin, PostSortRec):
 #_slots__ = "dependency_processor", "isdelete", "fromparent", "sort_key"

 #ef __init__(self, uow, dependency_processor, isdelete, fromparent):
 #elf.dependency_processor = dependency_processor
 #elf.sort_key = (
 #ProcessAll",
 #elf.dependency_processor.sort_key,
 #sdelete,
 #
 #elf.isdelete = isdelete
 #elf.fromparent = fromparent
 #ow.deps[dependency_processor.parent.base_mapper].add(
 #ependency_processor
 #

 #ef execute(self, uow):
 #tates = self._elements(uow)
 #f self.isdelete:
 #elf.dependency_processor.process_deletes(uow, states)
 #lse:
 #elf.dependency_processor.process_saves(uow, states)

 #ef per_state_flush_actions(self, uow):
        # this is handled by SaveUpdateAll and DeleteAll,
        # since a ProcessAll should unconditionally be pulled
        # into per-state if either the parent/child mappers
        # are part of a cycle
 #eturn iter([])

 #ef __repr__(self):
 #eturn "%s(%s, isdelete=%s)" % (
 #elf.__class__.__name__,
 #elf.dependency_processor,
 #elf.isdelete,
 #

 #ef _elements(self, uow):
 #or mapper in self._mappers(uow):
 #or state in uow.mappers[mapper]:
 #isdelete, listonly) = uow.states[state]
 #f isdelete == self.isdelete and not listonly:
 #ield state


class PostUpdateAll(PostSortRec):
 #_slots__ = "mapper", "isdelete", "sort_key"

 #ef __init__(self, uow, mapper, isdelete):
 #elf.mapper = mapper
 #elf.isdelete = isdelete
 #elf.sort_key = ("PostUpdateAll", mapper._sort_key, isdelete)

 #util.preload_module("sqlalchemy.orm.persistence")
 #ef execute(self, uow):
 #ersistence = util.preloaded.orm_persistence
 #tates, cols = uow.post_update_states[self.mapper]
 #tates = [s for s in states if uow.states[s][0] == self.isdelete]

 #ersistence.post_update(self.mapper, states, uow, cols)


class SaveUpdateAll(PostSortRec):
 #_slots__ = ("mapper", "sort_key")

 #ef __init__(self, uow, mapper):
 #elf.mapper = mapper
 #elf.sort_key = ("SaveUpdateAll", mapper._sort_key)
 #ssert mapper is mapper.base_mapper

 #util.preload_module("sqlalchemy.orm.persistence")
 #ef execute(self, uow):
 #til.preloaded.orm_persistence.save_obj(
 #elf.mapper,
 #ow.states_for_mapper_hierarchy(self.mapper, False, False),
 #ow,
 #

 #ef per_state_flush_actions(self, uow):
 #tates = list(
 #ow.states_for_mapper_hierarchy(self.mapper, False, False)
 #
 #ase_mapper = self.mapper.base_mapper
 #elete_all = DeleteAll(uow, base_mapper)
 #or state in states:
            # keep saves before deletes -
            # this ensures 'row switch' operations work
 #ction = SaveUpdateState(uow, state)
 #ow.dependencies.add((action, delete_all))
 #ield action

 #or dep in uow.deps[self.mapper]:
 #tates_for_prop = uow.filter_states_for_dep(dep, states)
 #ep.per_state_flush_actions(uow, states_for_prop, False)

 #ef __repr__(self):
 #eturn "%s(%s)" % (self.__class__.__name__, self.mapper)


class DeleteAll(PostSortRec):
 #_slots__ = ("mapper", "sort_key")

 #ef __init__(self, uow, mapper):
 #elf.mapper = mapper
 #elf.sort_key = ("DeleteAll", mapper._sort_key)
 #ssert mapper is mapper.base_mapper

 #util.preload_module("sqlalchemy.orm.persistence")
 #ef execute(self, uow):
 #til.preloaded.orm_persistence.delete_obj(
 #elf.mapper,
 #ow.states_for_mapper_hierarchy(self.mapper, True, False),
 #ow,
 #

 #ef per_state_flush_actions(self, uow):
 #tates = list(
 #ow.states_for_mapper_hierarchy(self.mapper, True, False)
 #
 #ase_mapper = self.mapper.base_mapper
 #ave_all = SaveUpdateAll(uow, base_mapper)
 #or state in states:
            # keep saves before deletes -
            # this ensures 'row switch' operations work
 #ction = DeleteState(uow, state)
 #ow.dependencies.add((save_all, action))
 #ield action

 #or dep in uow.deps[self.mapper]:
 #tates_for_prop = uow.filter_states_for_dep(dep, states)
 #ep.per_state_flush_actions(uow, states_for_prop, True)

 #ef __repr__(self):
 #eturn "%s(%s)" % (self.__class__.__name__, self.mapper)


class ProcessState(PostSortRec):
 #_slots__ = "dependency_processor", "isdelete", "state", "sort_key"

 #ef __init__(self, uow, dependency_processor, isdelete, state):
 #elf.dependency_processor = dependency_processor
 #elf.sort_key = ("ProcessState", dependency_processor.sort_key)
 #elf.isdelete = isdelete
 #elf.state = state

 #ef execute_aggregate(self, uow, recs):
 #ls_ = self.__class__
 #ependency_processor = self.dependency_processor
 #sdelete = self.isdelete
 #ur_recs = [
 #
 #or r in recs
 #f r.__class__ is cls_
 #nd r.dependency_processor is dependency_processor
 #nd r.isdelete is isdelete
 #
 #ecs.difference_update(our_recs)
 #tates = [self.state] + [r.state for r in our_recs]
 #f isdelete:
 #ependency_processor.process_deletes(uow, states)
 #lse:
 #ependency_processor.process_saves(uow, states)

 #ef __repr__(self):
 #eturn "%s(%s, %s, delete=%s)" % (
 #elf.__class__.__name__,
 #elf.dependency_processor,
 #rm_util.state_str(self.state),
 #elf.isdelete,
 #


class SaveUpdateState(PostSortRec):
 #_slots__ = "state", "mapper", "sort_key"

 #ef __init__(self, uow, state):
 #elf.state = state
 #elf.mapper = state.mapper.base_mapper
 #elf.sort_key = ("ProcessState", self.mapper._sort_key)

 #util.preload_module("sqlalchemy.orm.persistence")
 #ef execute_aggregate(self, uow, recs):
 #ersistence = util.preloaded.orm_persistence
 #ls_ = self.__class__
 #apper = self.mapper
 #ur_recs = [
 # for r in recs if r.__class__ is cls_ and r.mapper is mapper
 #
 #ecs.difference_update(our_recs)
 #ersistence.save_obj(
 #apper, [self.state] + [r.state for r in our_recs], uow
 #

 #ef __repr__(self):
 #eturn "%s(%s)" % (
 #elf.__class__.__name__,
 #rm_util.state_str(self.state),
 #


class DeleteState(PostSortRec):
 #_slots__ = "state", "mapper", "sort_key"

 #ef __init__(self, uow, state):
 #elf.state = state
 #elf.mapper = state.mapper.base_mapper
 #elf.sort_key = ("DeleteState", self.mapper._sort_key)

 #util.preload_module("sqlalchemy.orm.persistence")
 #ef execute_aggregate(self, uow, recs):
 #ersistence = util.preloaded.orm_persistence
 #ls_ = self.__class__
 #apper = self.mapper
 #ur_recs = [
 # for r in recs if r.__class__ is cls_ and r.mapper is mapper
 #
 #ecs.difference_update(our_recs)
 #tates = [self.state] + [r.state for r in our_recs]
 #ersistence.delete_obj(
 #apper, [s for s in states if uow.states[s][0]], uow
 #

 #ef __repr__(self):
 #eturn "%s(%s)" % (
 #elf.__class__.__name__,
 #rm_util.state_str(self.state),
 #
