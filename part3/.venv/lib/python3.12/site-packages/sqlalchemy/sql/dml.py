# sql/dml.py
# Copyright (C) 2009-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""
Provide :class:`_expression.Insert`, :class:`_expression.Update` and
:class:`_expression.Delete`.

"""
from sqlalchemy.types import NullType
from . import coercions
from . import roles
from . import util as sql_util
from .base import _entity_namespace_key
from .base import _exclusive_against
from .base import _from_objects
from .base import _generative
from .base import ColumnCollection
from .base import CompileState
from .base import DialectKWArgs
from .base import Executable
from .base import HasCompileState
from .elements import BooleanClauseList
from .elements import ClauseElement
from .elements import Null
from .selectable import HasCTE
from .selectable import HasPrefixes
from .selectable import ReturnsRows
from .visitors import InternalTraversal
from .. import exc
from .. import util
from ..util import collections_abc


class DMLState(CompileState):
 #no_parameters = True
 #dict_parameters = None
 #multi_parameters = None
 #ordered_values = None
 #parameter_ordering = None
 #has_multi_parameters = False
 #supdate = False
 #sdelete = False
 #sinsert = False

 #ef __init__(self, statement, compiler, **kw):
 #aise NotImplementedError()

 #property
 #ef dml_table(self):
 #eturn self.statement.table

 #ef _make_extra_froms(self, statement):
 #roms = []

 #ll_tables = list(sql_util.tables_from_leftmost(statement.table))
 #een = {all_tables[0]}

 #or crit in statement._where_criteria:
 #or item in _from_objects(crit):
 #f not seen.intersection(item._cloned_set):
 #roms.append(item)
 #een.update(item._cloned_set)

 #roms.extend(all_tables[1:])
 #eturn froms

 #ef _process_multi_values(self, statement):
 #f not statement._supports_multi_parameters:
 #aise exc.InvalidRequestError(
 #%s construct does not support "
 #multiple parameter sets." % statement.__visit_name__.upper()
 #

 #or parameters in statement._multi_values:
 #ulti_parameters = [
 #
 #.key: value
 #or c, value in zip(statement.table.c, parameter_set)
 #
 #f isinstance(parameter_set, collections_abc.Sequence)
 #lse parameter_set
 #or parameter_set in parameters
 #

 #f self._no_parameters:
 #elf._no_parameters = False
 #elf._has_multi_parameters = True
 #elf._multi_parameters = multi_parameters
 #elf._dict_parameters = self._multi_parameters[0]
 #lif not self._has_multi_parameters:
 #elf._cant_mix_formats_error()
 #lse:
 #elf._multi_parameters.extend(multi_parameters)

 #ef _process_values(self, statement):
 #f self._no_parameters:
 #elf._has_multi_parameters = False
 #elf._dict_parameters = statement._values
 #elf._no_parameters = False
 #lif self._has_multi_parameters:
 #elf._cant_mix_formats_error()

 #ef _process_ordered_values(self, statement):
 #arameters = statement._ordered_values

 #f self._no_parameters:
 #elf._no_parameters = False
 #elf._dict_parameters = dict(parameters)
 #elf._ordered_values = parameters
 #elf._parameter_ordering = [key for key, value in parameters]
 #lif self._has_multi_parameters:
 #elf._cant_mix_formats_error()
 #lse:
 #aise exc.InvalidRequestError(
 #Can only invoke ordered_values() once, and not mixed "
 #with any other values() call"
 #

 #ef _process_select_values(self, statement):
 #arameters = {
 #oercions.expect(roles.DMLColumnRole, name, as_key=True): Null()
 #or name in statement._select_names
 #

 #f self._no_parameters:
 #elf._no_parameters = False
 #elf._dict_parameters = parameters
 #lse:
            # this condition normally not reachable as the Insert
            # does not allow this construction to occur
 #ssert False, "This statement already has parameters"

 #ef _cant_mix_formats_error(self):
 #aise exc.InvalidRequestError(
 #Can't mix single and multiple VALUES "
 #formats in one INSERT statement; one style appends to a "
 #list while the other replaces values, so the intent is "
 #ambiguous."
 #


@CompileState.plugin_for("default", "insert")
class InsertDMLState(DMLState):
 #sinsert = True

 #nclude_table_with_column_exprs = False

 #ef __init__(self, statement, compiler, **kw):
 #elf.statement = statement

 #elf.isinsert = True
 #f statement._select_names:
 #elf._process_select_values(statement)
 #f statement._values is not None:
 #elf._process_values(statement)
 #f statement._multi_values:
 #elf._process_multi_values(statement)


@CompileState.plugin_for("default", "update")
class UpdateDMLState(DMLState):
 #supdate = True

 #nclude_table_with_column_exprs = False

 #ef __init__(self, statement, compiler, **kw):
 #elf.statement = statement
 #elf.isupdate = True
 #elf._preserve_parameter_order = statement._preserve_parameter_order
 #f statement._ordered_values is not None:
 #elf._process_ordered_values(statement)
 #lif statement._values is not None:
 #elf._process_values(statement)
 #lif statement._multi_values:
 #elf._process_multi_values(statement)
 #elf._extra_froms = ef = self._make_extra_froms(statement)
 #elf.is_multitable = mt = ef and self._dict_parameters
 #elf.include_table_with_column_exprs = (
 #t and compiler.render_table_with_column_in_update_from
 #


@CompileState.plugin_for("default", "delete")
class DeleteDMLState(DMLState):
 #sdelete = True

 #ef __init__(self, statement, compiler, **kw):
 #elf.statement = statement

 #elf.isdelete = True
 #elf._extra_froms = self._make_extra_froms(statement)


class UpdateBase(
 #oles.DMLRole,
 #asCTE,
 #asCompileState,
 #ialectKWArgs,
 #asPrefixes,
 #eturnsRows,
 #xecutable,
 #lauseElement,
):
 #""Form the base for ``INSERT``, ``UPDATE``, and ``DELETE`` statements."""

 #_visit_name__ = "update_base"

 #execution_options = Executable._execution_options.union(
 #"autocommit": True}
 #
 #hints = util.immutabledict()
 #amed_with_column = False

 #return_defaults = False
 #return_defaults_columns = None
 #returning = ()

 #s_dml = True

 #classmethod
 #ef _constructor_20_deprecations(cls, fn_name, clsname, names):

 #aram_to_method_lookup = dict(
 #hereclause=(
 #The :paramref:`%(func)s.whereclause` parameter "
 #will be removed "
 #in SQLAlchemy 2.0.  Please refer to the "
 #:meth:`%(classname)s.where` method."
 #,
 #alues=(
 #The :paramref:`%(func)s.values` parameter will be removed "
 #in SQLAlchemy 2.0.  Please refer to the "
 #:meth:`%(classname)s.values` method."
 #,
 #ind=(
 #The :paramref:`%(func)s.bind` parameter will be removed in "
 #SQLAlchemy 2.0.  Please use explicit connection execution."
 #,
 #nline=(
 #The :paramref:`%(func)s.inline` parameter will be "
 #removed in "
 #SQLAlchemy 2.0.  Please use the "
 #:meth:`%(classname)s.inline` method."
 #,
 #refixes=(
 #The :paramref:`%(func)s.prefixes parameter will be "
 #removed in "
 #SQLAlchemy 2.0.  Please use the "
 #:meth:`%(classname)s.prefix_with` "
 #method."
 #,
 #eturn_defaults=(
 #The :paramref:`%(func)s.return_defaults` parameter will be "
 #removed in SQLAlchemy 2.0.  Please use the "
 #:meth:`%(classname)s.return_defaults` method."
 #,
 #eturning=(
 #The :paramref:`%(func)s.returning` parameter will be "
 #removed in SQLAlchemy 2.0.  Please use the "
 #:meth:`%(classname)s.returning`` method."
 #,
 #reserve_parameter_order=(
 #The :paramref:`%(func)s.preserve_parameter_order` parameter "
 #will be removed in SQLAlchemy 2.0.   Use the "
 #:meth:`%(classname)s.ordered_values` method with a list "
 #of tuples. "
 #,
 #

 #eturn util.deprecated_params(
 #*{
 #ame: (
 #2.0",
 #aram_to_method_lookup[name]
 # {
 #func": "_expression.%s" % fn_name,
 #classname": "_expression.%s" % clsname,
 #,
 #
 #or name in names
 #
 #

 #ef _generate_fromclause_column_proxies(self, fromclause):
 #romclause._columns._populate_separate_keys(
 #ol._make_proxy(fromclause) for col in self._returning
 #

 #ef params(self, *arg, **kw):
 #""Set the parameters for the statement.

 #his method raises ``NotImplementedError`` on the base class,
 #nd is overridden by :class:`.ValuesBase` to provide the
 #ET/VALUES clause of UPDATE and INSERT.

 #""
 #aise NotImplementedError(
 #params() is not supported for INSERT/UPDATE/DELETE statements."
 # To set the values for an INSERT or UPDATE statement, use"
 # stmt.values(**parameters)."
 #

 #_generative
 #ef with_dialect_options(self, **opt):
 #""Add dialect options to this INSERT/UPDATE/DELETE object.

 #.g.::

 #pd = table.update().dialect_options(mysql_limit=10)

 #. versionadded: 1.4 - this method supersedes the dialect options
 #ssociated with the constructor.


 #""
 #elf._validate_dialect_kwargs(opt)

 #ef _validate_dialect_kwargs_deprecated(self, dialect_kw):
 #til.warn_deprecated_20(
 #Passing dialect keyword arguments directly to the "
 #%s constructor is deprecated and will be removed in SQLAlchemy "
 #2.0.  Please use the ``with_dialect_options()`` method."
 # (self.__class__.__name__)
 #
 #elf._validate_dialect_kwargs(dialect_kw)

 #ef bind(self):
 #""Return a 'bind' linked to this :class:`.UpdateBase`
 #r a :class:`_schema.Table` associated with it.

 #""
 #eturn self._bind or self.table.bind

 #ef _set_bind(self, bind):
 #elf._bind = bind

 #ind = property(bind, _set_bind)

 #_generative
 #ef returning(self, *cols):
 #"""Add a :term:`RETURNING` or equivalent clause to this statement.

 #.g.:

 #. sourcecode:: pycon+sql

 #>> stmt = (
 #..     table.update()
 #..     .where(table.c.data == "value")
 #..     .values(status="X")
 #..     .returning(table.c.server_flag, table.c.updated_timestamp)
 #.. )
 #>> print(stmt)
 #PDATE some_table SET status=:status
 #HERE some_table.data = :data_1
 #ETURNING some_table.server_flag, some_table.updated_timestamp

 #he method may be invoked multiple times to add new entries to the
 #ist of expressions to be returned.

 #. versionadded:: 1.4.0b2 The method may be invoked multiple times to
 #dd new entries to the list of expressions to be returned.

 #he given collection of column expressions should be derived from the
 #able that is the target of the INSERT, UPDATE, or DELETE.  While
 #class:`_schema.Column` objects are typical, the elements can also be
 #xpressions:

 #. sourcecode:: pycon+sql

 #>> stmt = table.insert().returning(
 #..     (table.c.first_name + " " + table.c.last_name).label("fullname")
 #.. )
 #>> print(stmt)
 #NSERT INTO some_table (first_name, last_name)
 #ALUES (:first_name, :last_name)
 #ETURNING some_table.first_name || :first_name_1 || some_table.last_name AS fullname

 #pon compilation, a RETURNING clause, or database equivalent,
 #ill be rendered within the statement.   For INSERT and UPDATE,
 #he values are the newly inserted/updated values.  For DELETE,
 #he values are those of the rows which were deleted.

 #pon execution, the values of the columns to be returned are made
 #vailable via the result set and can be iterated using
 #meth:`_engine.CursorResult.fetchone` and similar.
 #or DBAPIs which do not
 #atively support returning values (i.e. cx_oracle), SQLAlchemy will
 #pproximate this behavior at the result level so that a reasonable
 #mount of behavioral neutrality is provided.

 #ote that not all databases/DBAPIs
 #upport RETURNING.   For those backends with no support,
 #n exception is raised upon compilation and/or execution.
 #or those who do support it, the functionality across backends
 #aries greatly, including restrictions on executemany()
 #nd other statements which return multiple rows. Please
 #ead the documentation notes for the database in use in
 #rder to determine the availability of RETURNING.

 #. seealso::

 #meth:`.ValuesBase.return_defaults` - an alternative method tailored
 #owards efficient fetching of server-side defaults and triggers
 #or single-row INSERTs or UPDATEs.

 #ref:`tutorial_insert_returning` - in the :ref:`unified_tutorial`

 #""  # noqa E501
 #f self._return_defaults:
 #aise exc.InvalidRequestError(
 #return_defaults() is already configured on this statement"
 #
 #elf._returning += tuple(
 #oercions.expect(roles.ColumnsClauseRole, c) for c in cols
 #

 #property
 #ef _all_selected_columns(self):
 #eturn self._returning

 #property
 #ef exported_columns(self):
 #""Return the RETURNING columns as a column collection for this
 #tatement.

 #. versionadded:: 1.4

 #""
        # TODO: no coverage here
 #eturn ColumnCollection(
 #c.key, c) for c in self._all_selected_columns
 #.as_immutable()

 #_generative
 #ef with_hint(self, text, selectable=None, dialect_name="*"):
 #""Add a table hint for a single table to this
 #NSERT/UPDATE/DELETE statement.

 #. note::

 #meth:`.UpdateBase.with_hint` currently applies only to
 #icrosoft SQL Server.  For MySQL INSERT/UPDATE/DELETE hints, use
 #meth:`.UpdateBase.prefix_with`.

 #he text of the hint is rendered in the appropriate
 #ocation for the database backend in use, relative
 #o the :class:`_schema.Table` that is the subject of this
 #tatement, or optionally to that of the given
 #class:`_schema.Table` passed as the ``selectable`` argument.

 #he ``dialect_name`` option will limit the rendering of a particular
 #int to a particular backend. Such as, to add a hint
 #hat only takes effect for SQL Server::

 #ytable.insert().with_hint("WITH (PAGLOCK)", dialect_name="mssql")

 #param text: Text of the hint.
 #param selectable: optional :class:`_schema.Table` that specifies
 #n element of the FROM clause within an UPDATE or DELETE
 #o be the subject of the hint - applies only to certain backends.
 #param dialect_name: defaults to ``*``, if specified as the name
 #f a particular dialect, will apply these hints only when
 #hat dialect is in use.
 #""
 #f selectable is None:
 #electable = self.table

 #elf._hints = self._hints.union({(selectable, dialect_name): text})


class ValuesBase(UpdateBase):
 #""Supplies support for :meth:`.ValuesBase.values` to
 #NSERT and UPDATE constructs."""

 #_visit_name__ = "values_base"

 #supports_multi_parameters = False
 #preserve_parameter_order = False
 #elect = None
 #post_values_clause = None

 #values = None
 #multi_values = ()
 #ordered_values = None
 #select_names = None

 #returning = ()

 #ef __init__(self, table, values, prefixes):
 #elf.table = coercions.expect(
 #oles.DMLTableRole, table, apply_propagate_attrs=self
 #
 #f values is not None:
 #elf.values.non_generative(self, values)
 #f prefixes:
 #elf._setup_prefixes(prefixes)

 #_generative
 #_exclusive_against(
 #_select_names",
 #_ordered_values",
 #sgs={
 #_select_names": "This construct already inserts from a SELECT",
 #_ordered_values": "This statement already has ordered "
 #values present",
 #,
 #
 #ef values(self, *args, **kwargs):
 #"""Specify a fixed VALUES clause for an INSERT statement, or the SET
 #lause for an UPDATE.

 #ote that the :class:`_expression.Insert` and
 #class:`_expression.Update`
 #onstructs support
 #er-execution time formatting of the VALUES and/or SET clauses,
 #ased on the arguments passed to :meth:`_engine.Connection.execute`.
 #owever, the :meth:`.ValuesBase.values` method can be used to "fix" a
 #articular set of parameters into the statement.

 #ultiple calls to :meth:`.ValuesBase.values` will produce a new
 #onstruct, each one with the parameter list modified to include
 #he new parameters sent.  In the typical case of a single
 #ictionary of parameters, the newly passed keys will replace
 #he same keys in the previous construct.  In the case of a list-based
 #multiple values" construct, each new list of values is extended
 #nto the existing list of values.

 #param \**kwargs: key value pairs representing the string key
 #f a :class:`_schema.Column`
 #apped to the value to be rendered into the
 #ALUES or SET clause::

 #sers.insert().values(name="some name")

 #sers.update().where(users.c.id==5).values(name="some name")

 #param \*args: As an alternative to passing key/value parameters,
 # dictionary, tuple, or list of dictionaries or tuples can be passed
 #s a single positional argument in order to form the VALUES or
 #ET clause of the statement.  The forms that are accepted vary
 #ased on whether this is an :class:`_expression.Insert` or an
 #class:`_expression.Update` construct.

 #or either an :class:`_expression.Insert` or
 #class:`_expression.Update`
 #onstruct, a single dictionary can be passed, which works the same as
 #hat of the kwargs form::

 #sers.insert().values({"name": "some name"})

 #sers.update().values({"name": "some new name"})

 #lso for either form but more typically for the
 #class:`_expression.Insert` construct, a tuple that contains an
 #ntry for every column in the table is also accepted::

 #sers.insert().values((5, "some name"))

 #he :class:`_expression.Insert` construct also supports being
 #assed a list of dictionaries or full-table-tuples, which on the
 #erver will render the less common SQL syntax of "multiple values" -
 #his syntax is supported on backends such as SQLite, PostgreSQL,
 #ySQL, but not necessarily others::

 #sers.insert().values([
 #"name": "some name"},
 #"name": "some other name"},
 #"name": "yet another name"},
 #)

 #he above form would render a multiple VALUES statement similar to::

 #NSERT INTO users (name) VALUES
 #:name_1),
 #:name_2),
 #:name_3)

 #t is essential to note that **passing multiple values is
 #OT the same as using traditional executemany() form**.  The above
 #yntax is a **special** syntax not typically used.  To emit an
 #NSERT statement against multiple rows, the normal method is
 #o pass a multiple values list to the
 #meth:`_engine.Connection.execute`
 #ethod, which is supported by all database backends and is generally
 #ore efficient for a very large number of parameters.

 #. seealso::

 #ref:`execute_multiple` - an introduction to
 #he traditional Core method of multiple parameter set
 #nvocation for INSERTs and other statements.

 #. versionchanged:: 1.0.0 an INSERT that uses a multiple-VALUES
 #lause, even a list of length one,
 #mplies that the :paramref:`_expression.Insert.inline`
 #lag is set to
 #rue, indicating that the statement will not attempt to fetch
 #he "last inserted primary key" or other defaults.  The
 #tatement deals with an arbitrary number of rows, so the
 #attr:`_engine.CursorResult.inserted_primary_key`
 #ccessor does not
 #pply.

 #. versionchanged:: 1.0.0 A multiple-VALUES INSERT now supports
 #olumns with Python side default values and callables in the
 #ame way as that of an "executemany" style of invocation; the
 #allable is invoked for each row.   See :ref:`bug_3288`
 #or other details.

 #he UPDATE construct also supports rendering the SET parameters
 #n a specific order.  For this feature refer to the
 #meth:`_expression.Update.ordered_values` method.

 #. seealso::

 #meth:`_expression.Update.ordered_values`


 #""
 #f args:
            # positional case.  this is currently expensive.   we don't
            # yet have positional-only args so we have to check the length.
            # then we need to check multiparams vs. single dictionary.
            # since the parameter format is needed in order to determine
            # a cache key, we need to determine this up front.
 #rg = args[0]

 #f kwargs:
 #aise exc.ArgumentError(
 #Can't pass positional and kwargs to values() "
 #simultaneously"
 #
 #lif len(args) > 1:
 #aise exc.ArgumentError(
 #Only a single dictionary/tuple or list of "
 #dictionaries/tuples is accepted positionally."
 #

 #lif not self._preserve_parameter_order and isinstance(
 #rg, collections_abc.Sequence
 #:

 #f arg and isinstance(arg[0], (list, dict, tuple)):
 #elf._multi_values += (arg,)
 #eturn

                # tuple values
 #rg = {c.key: value for c, value in zip(self.table.c, arg)}
 #lif self._preserve_parameter_order and not isinstance(
 #rg, collections_abc.Sequence
 #:
 #aise ValueError(
 #When preserve_parameter_order is True, "
 #values() only accepts a list of 2-tuples"
 #

 #lse:
            # kwarg path.  this is the most common path for non-multi-params
            # so this is fairly quick.
 #rg = kwargs
 #f args:
 #aise exc.ArgumentError(
 #Only a single dictionary/tuple or list of "
 #dictionaries/tuples is accepted positionally."
 #

        # for top level values(), convert literals to anonymous bound
        # parameters at statement construction time, so that these values can
        # participate in the cache key process like any other ClauseElement.
        # crud.py now intercepts bound parameters with unique=True from here
        # and ensures they get the "crud"-style name when rendered.

 #f self._preserve_parameter_order:
 #rg = [
 #
 #oercions.expect(roles.DMLColumnRole, k),
 #oercions.expect(
 #oles.ExpressionElementRole,
 #,
 #ype_=NullType(),
 #s_crud=True,
 #,
 #
 #or k, v in arg
 #
 #elf._ordered_values = arg
 #lse:
 #rg = {
 #oercions.expect(roles.DMLColumnRole, k): coercions.expect(
 #oles.ExpressionElementRole,
 #,
 #ype_=NullType(),
 #s_crud=True,
 #
 #or k, v in arg.items()
 #
 #f self._values:
 #elf._values = self._values.union(arg)
 #lse:
 #elf._values = util.immutabledict(arg)

 #_generative
 #_exclusive_against(
 #_returning",
 #sgs={
 #_returning": "RETURNING is already configured on this statement"
 #,
 #efaults={"_returning": _returning},
 #
 #ef return_defaults(self, *cols):
 #""Make use of a :term:`RETURNING` clause for the purpose
 #f fetching server-side expressions and defaults.

 #.g.::

 #tmt = table.insert().values(data='newdata').return_defaults()

 #esult = connection.execute(stmt)

 #erver_created_at = result.returned_defaults['created_at']

 #hen used against a backend that supports RETURNING, all column
 #alues generated by SQL expression or server-side-default will be
 #dded to any existing RETURNING clause, provided that
 #meth:`.UpdateBase.returning` is not used simultaneously.  The column
 #alues will then be available on the result using the
 #attr:`_engine.CursorResult.returned_defaults` accessor as
 # dictionary,
 #eferring to values keyed to the :class:`_schema.Column`
 #bject as well as
 #ts ``.key``.

 #his method differs from :meth:`.UpdateBase.returning` in these ways:

 #. :meth:`.ValuesBase.return_defaults` is only intended for use with an
 #NSERT or an UPDATE statement that matches exactly one row per
 #arameter set. While the RETURNING construct in the general sense
 #upports multiple rows for a multi-row UPDATE or DELETE statement,
 #r for special cases of INSERT that return multiple rows (e.g.
 #NSERT from SELECT, multi-valued VALUES clause),
 #meth:`.ValuesBase.return_defaults` is intended only for an
 #ORM-style" single-row INSERT/UPDATE statement.  The row
 #eturned by the statement is also consumed implicitly when
 #meth:`.ValuesBase.return_defaults` is used.  By contrast,
 #meth:`.UpdateBase.returning` leaves the RETURNING result-set intact
 #ith a collection of any number of rows.

 #. It is compatible with the existing logic to fetch auto-generated
 #rimary key values, also known as "implicit returning".  Backends
 #hat support RETURNING will automatically make use of RETURNING in
 #rder to fetch the value of newly generated primary keys; while the
 #meth:`.UpdateBase.returning` method circumvents this behavior,
 #meth:`.ValuesBase.return_defaults` leaves it intact.

 #. It can be called against any backend.  Backends that don't support
 #ETURNING will skip the usage of the feature, rather than raising
 #n exception.  The return value of
 #attr:`_engine.CursorResult.returned_defaults` will be ``None``

 #. An INSERT statement invoked with executemany() is supported if the
 #ackend database driver supports the
 #`insert_executemany_returning`` feature, currently this includes
 #ostgreSQL with psycopg2.  When executemany is used, the
 #attr:`_engine.CursorResult.returned_defaults_rows` and
 #attr:`_engine.CursorResult.inserted_primary_key_rows` accessors
 #ill return the inserted defaults and primary keys.

 #. versionadded:: 1.4

 #meth:`.ValuesBase.return_defaults` is used by the ORM to provide
 #n efficient implementation for the ``eager_defaults`` feature of
 #func:`.mapper`.

 #param cols: optional list of column key names or
 #class:`_schema.Column`
 #bjects.  If omitted, all column expressions evaluated on the server
 #re added to the returning list.

 #. versionadded:: 0.9.0

 #. seealso::

 #meth:`.UpdateBase.returning`

 #attr:`_engine.CursorResult.returned_defaults`

 #attr:`_engine.CursorResult.returned_defaults_rows`

 #attr:`_engine.CursorResult.inserted_primary_key`

 #attr:`_engine.CursorResult.inserted_primary_key_rows`

 #""
 #elf._return_defaults = True
 #elf._return_defaults_columns = cols


class Insert(ValuesBase):
 #""Represent an INSERT construct.

 #he :class:`_expression.Insert` object is created using the
 #func:`_expression.insert()` function.

 #""

 #_visit_name__ = "insert"

 #supports_multi_parameters = True

 #elect = None
 #nclude_insert_from_select_defaults = False

 #s_insert = True

 #traverse_internals = (
 #
 #"table", InternalTraversal.dp_clauseelement),
 #"_inline", InternalTraversal.dp_boolean),
 #"_select_names", InternalTraversal.dp_string_list),
 #"_values", InternalTraversal.dp_dml_values),
 #"_multi_values", InternalTraversal.dp_dml_multi_values),
 #"select", InternalTraversal.dp_clauseelement),
 #"_post_values_clause", InternalTraversal.dp_clauseelement),
 #"_returning", InternalTraversal.dp_clauseelement_list),
 #"_hints", InternalTraversal.dp_table_hint_list),
 #"_return_defaults", InternalTraversal.dp_boolean),
 #
 #_return_defaults_columns",
 #nternalTraversal.dp_clauseelement_list,
 #,
 #
 # HasPrefixes._has_prefixes_traverse_internals
 # DialectKWArgs._dialect_kwargs_traverse_internals
 # Executable._executable_traverse_internals
 # HasCTE._has_ctes_traverse_internals
 #

 #ValuesBase._constructor_20_deprecations(
 #insert",
 #Insert",
 #
 #values",
 #inline",
 #bind",
 #prefixes",
 #returning",
 #return_defaults",
 #,
 #
 #ef __init__(
 #elf,
 #able,
 #alues=None,
 #nline=False,
 #ind=None,
 #refixes=None,
 #eturning=None,
 #eturn_defaults=False,
 #*dialect_kw
 #:
 #""Construct an :class:`_expression.Insert` object.

 #.g.::

 #rom sqlalchemy import insert

 #tmt = (
 #nsert(user_table).
 #alues(name='username', fullname='Full Username')
 #

 #imilar functionality is available via the
 #meth:`_expression.TableClause.insert` method on
 #class:`_schema.Table`.

 #. seealso::

 #ref:`coretutorial_insert_expressions` - in the
 #ref:`1.x tutorial <sqlexpression_toplevel>`

 #ref:`tutorial_core_insert` - in the :ref:`unified_tutorial`


 #param table: :class:`_expression.TableClause`
 #hich is the subject of the
 #nsert.

 #param values: collection of values to be inserted; see
 #meth:`_expression.Insert.values`
 #or a description of allowed formats here.
 #an be omitted entirely; a :class:`_expression.Insert` construct
 #ill also dynamically render the VALUES clause at execution time
 #ased on the parameters passed to :meth:`_engine.Connection.execute`.

 #param inline: if True, no attempt will be made to retrieve the
 #QL-generated default values to be provided within the statement;
 #n particular,
 #his allows SQL expressions to be rendered 'inline' within the
 #tatement without the need to pre-execute them beforehand; for
 #ackends that support "returning", this turns off the "implicit
 #eturning" feature for the statement.

 #f both :paramref:`_expression.Insert.values` and compile-time bind
 #arameters are present, the compile-time bind parameters override the
 #nformation specified within :paramref:`_expression.Insert.values` on a
 #er-key basis.

 #he keys within :paramref:`_expression.Insert.values` can be either
 #class:`~sqlalchemy.schema.Column` objects or their string
 #dentifiers. Each key may reference one of:

 # a literal data value (i.e. string, number, etc.);
 # a Column object;
 # a SELECT statement.

 #f a ``SELECT`` statement is specified which references this
 #`INSERT`` statement's table, the statement will be correlated
 #gainst the ``INSERT`` statement.

 #. seealso::

 #ref:`coretutorial_insert_expressions` - SQL Expression Tutorial

 #ref:`inserts_and_updates` - SQL Expression Tutorial

 #""
 #uper(Insert, self).__init__(table, values, prefixes)
 #elf._bind = bind
 #elf._inline = inline
 #f returning:
 #elf._returning = returning
 #f dialect_kw:
 #elf._validate_dialect_kwargs_deprecated(dialect_kw)

 #f return_defaults:
 #elf._return_defaults = True
 #f not isinstance(return_defaults, bool):
 #elf._return_defaults_columns = return_defaults

 #_generative
 #ef inline(self):
 #""Make this :class:`_expression.Insert` construct "inline" .

 #hen set, no attempt will be made to retrieve the
 #QL-generated default values to be provided within the statement;
 #n particular,
 #his allows SQL expressions to be rendered 'inline' within the
 #tatement without the need to pre-execute them beforehand; for
 #ackends that support "returning", this turns off the "implicit
 #eturning" feature for the statement.


 #. versionchanged:: 1.4 the :paramref:`_expression.Insert.inline`
 #arameter
 #s now superseded by the :meth:`_expression.Insert.inline` method.

 #""
 #elf._inline = True

 #_generative
 #ef from_select(self, names, select, include_defaults=True):
 #""Return a new :class:`_expression.Insert` construct which represents
 #n ``INSERT...FROM SELECT`` statement.

 #.g.::

 #el = select(table1.c.a, table1.c.b).where(table1.c.c > 5)
 #ns = table2.insert().from_select(['a', 'b'], sel)

 #param names: a sequence of string column names or
 #class:`_schema.Column`
 #bjects representing the target columns.
 #param select: a :func:`_expression.select` construct,
 #class:`_expression.FromClause`
 #r other construct which resolves into a
 #class:`_expression.FromClause`,
 #uch as an ORM :class:`_query.Query` object, etc.  The order of
 #olumns returned from this FROM clause should correspond to the
 #rder of columns sent as the ``names`` parameter;  while this
 #s not checked before passing along to the database, the database
 #ould normally raise an exception if these column lists don't
 #orrespond.
 #param include_defaults: if True, non-server default values and
 #QL expressions as specified on :class:`_schema.Column` objects
 #as documented in :ref:`metadata_defaults_toplevel`) not
 #therwise specified in the list of names will be rendered
 #nto the INSERT and SELECT statements, so that these values are also
 #ncluded in the data to be inserted.

 #. note:: A Python-side default that uses a Python callable function
 #ill only be invoked **once** for the whole statement, and **not
 #er row**.

 #. versionadded:: 1.0.0 - :meth:`_expression.Insert.from_select`
 #ow renders
 #ython-side and SQL expression column defaults into the
 #ELECT statement for columns otherwise not included in the
 #ist of column names.

 #. versionchanged:: 1.0.0 an INSERT that uses FROM SELECT
 #mplies that the :paramref:`_expression.insert.inline`
 #lag is set to
 #rue, indicating that the statement will not attempt to fetch
 #he "last inserted primary key" or other defaults.  The statement
 #eals with an arbitrary number of rows, so the
 #attr:`_engine.CursorResult.inserted_primary_key`
 #ccessor does not apply.

 #""

 #f self._values:
 #aise exc.InvalidRequestError(
 #This construct already inserts value expressions"
 #

 #elf._select_names = names
 #elf._inline = True
 #elf.include_insert_from_select_defaults = include_defaults
 #elf.select = coercions.expect(roles.DMLSelectRole, select)


class DMLWhereBase(object):
 #where_criteria = ()

 #_generative
 #ef where(self, *whereclause):
 #""Return a new construct with the given expression(s) added to
 #ts WHERE clause, joined to the existing clause via AND, if any.

 #oth :meth:`_dml.Update.where` and :meth:`_dml.Delete.where`
 #upport multiple-table forms, including database-specific
 #`UPDATE...FROM`` as well as ``DELETE..USING``.  For backends that
 #on't have multiple-table support, a backend agnostic approach
 #o using multiple tables is to make use of correlated subqueries.
 #ee the linked tutorial sections below for examples.

 #. seealso::

 #*1.x Tutorial Examples**

 #ref:`tutorial_1x_correlated_updates`

 #ref:`multi_table_updates`

 #ref:`multi_table_deletes`

 #*2.0 Tutorial Examples**

 #ref:`tutorial_correlated_updates`

 #ref:`tutorial_update_from`

 #ref:`tutorial_multi_table_deletes`

 #""

 #or criterion in whereclause:
 #here_criteria = coercions.expect(roles.WhereHavingRole, criterion)
 #elf._where_criteria += (where_criteria,)

 #ef filter(self, *criteria):
 #""A synonym for the :meth:`_dml.DMLWhereBase.where` method.

 #. versionadded:: 1.4

 #""

 #eturn self.where(*criteria)

 #ef _filter_by_zero(self):
 #eturn self.table

 #ef filter_by(self, **kwargs):
 #"""apply the given filtering criterion as a WHERE clause
 #o this select.

 #""
 #rom_entity = self._filter_by_zero()

 #lauses = [
 #entity_namespace_key(from_entity, key) == value
 #or key, value in kwargs.items()
 #
 #eturn self.filter(*clauses)

 #property
 #ef whereclause(self):
 #""Return the completed WHERE clause for this :class:`.DMLWhereBase`
 #tatement.

 #his assembles the current collection of WHERE criteria
 #nto a single :class:`_expression.BooleanClauseList` construct.


 #. versionadded:: 1.4

 #""

 #eturn BooleanClauseList._construct_for_whereclause(
 #elf._where_criteria
 #


class Update(DMLWhereBase, ValuesBase):
 #""Represent an Update construct.

 #he :class:`_expression.Update` object is created using the
 #func:`_expression.update()` function.

 #""

 #_visit_name__ = "update"

 #s_update = True

 #traverse_internals = (
 #
 #"table", InternalTraversal.dp_clauseelement),
 #"_where_criteria", InternalTraversal.dp_clauseelement_list),
 #"_inline", InternalTraversal.dp_boolean),
 #"_ordered_values", InternalTraversal.dp_dml_ordered_values),
 #"_values", InternalTraversal.dp_dml_values),
 #"_returning", InternalTraversal.dp_clauseelement_list),
 #"_hints", InternalTraversal.dp_table_hint_list),
 #"_return_defaults", InternalTraversal.dp_boolean),
 #
 #_return_defaults_columns",
 #nternalTraversal.dp_clauseelement_list,
 #,
 #
 # HasPrefixes._has_prefixes_traverse_internals
 # DialectKWArgs._dialect_kwargs_traverse_internals
 # Executable._executable_traverse_internals
 # HasCTE._has_ctes_traverse_internals
 #

 #ValuesBase._constructor_20_deprecations(
 #update",
 #Update",
 #
 #whereclause",
 #values",
 #inline",
 #bind",
 #prefixes",
 #returning",
 #return_defaults",
 #preserve_parameter_order",
 #,
 #
 #ef __init__(
 #elf,
 #able,
 #hereclause=None,
 #alues=None,
 #nline=False,
 #ind=None,
 #refixes=None,
 #eturning=None,
 #eturn_defaults=False,
 #reserve_parameter_order=False,
 #*dialect_kw
 #:
 #"""Construct an :class:`_expression.Update` object.

 #.g.::

 #rom sqlalchemy import update

 #tmt = (
 #pdate(user_table).
 #here(user_table.c.id == 5).
 #alues(name='user #5')
 #

 #imilar functionality is available via the
 #meth:`_expression.TableClause.update` method on
 #class:`_schema.Table`.

 #. seealso::

 #ref:`inserts_and_updates` - in the
 #ref:`1.x tutorial <sqlexpression_toplevel>`

 #ref:`tutorial_core_update_delete` - in the :ref:`unified_tutorial`



 #param table: A :class:`_schema.Table`
 #bject representing the database
 #able to be updated.

 #param whereclause: Optional SQL expression describing the ``WHERE``
 #ondition of the ``UPDATE`` statement; is equivalent to using the
 #ore modern :meth:`~Update.where()` method to specify the ``WHERE``
 #lause.

 #param values:
 #ptional dictionary which specifies the ``SET`` conditions of the
 #`UPDATE``.  If left as ``None``, the ``SET``
 #onditions are determined from those parameters passed to the
 #tatement during the execution and/or compilation of the
 #tatement.   When compiled standalone without any parameters,
 #he ``SET`` clause generates for all columns.

 #odern applications may prefer to use the generative
 #meth:`_expression.Update.values` method to set the values of the
 #PDATE statement.

 #param inline:
 #f True, SQL defaults present on :class:`_schema.Column` objects via
 #he ``default`` keyword will be compiled 'inline' into the statement
 #nd not pre-executed.  This means that their values will not
 #e available in the dictionary returned from
 #meth:`_engine.CursorResult.last_updated_params`.

 #param preserve_parameter_order: if True, the update statement is
 #xpected to receive parameters **only** via the
 #meth:`_expression.Update.values` method,
 #nd they must be passed as a Python
 #`list`` of 2-tuples. The rendered UPDATE statement will emit the SET
 #lause for each referenced column maintaining this order.

 #. versionadded:: 1.0.10

 #. seealso::

 #ref:`updates_order_parameters` - illustrates the
 #meth:`_expression.Update.ordered_values` method.

 #f both ``values`` and compile-time bind parameters are present, the
 #ompile-time bind parameters override the information specified
 #ithin ``values`` on a per-key basis.

 #he keys within ``values`` can be either :class:`_schema.Column`
 #bjects or their string identifiers (specifically the "key" of the
 #class:`_schema.Column`, normally but not necessarily equivalent to
 #ts "name").  Normally, the
 #class:`_schema.Column` objects used here are expected to be
 #art of the target :class:`_schema.Table` that is the table
 #o be updated.  However when using MySQL, a multiple-table
 #PDATE statement can refer to columns from any of
 #he tables referred to in the WHERE clause.

 #he values referred to in ``values`` are typically:

 # a literal data value (i.e. string, number, etc.)
 # a SQL expression, such as a related :class:`_schema.Column`,
 # scalar-returning :func:`_expression.select` construct,
 #tc.

 #hen combining :func:`_expression.select` constructs within the
 #alues clause of an :func:`_expression.update`
 #onstruct, the subquery represented
 #y the :func:`_expression.select` should be *correlated* to the
 #arent table, that is, providing criterion which links the table inside
 #he subquery to the outer table being updated::

 #sers.update().values(
 #ame=select(addresses.c.email_address).\
 #here(addresses.c.user_id==users.c.id).\
 #calar_subquery()
 #

 #. seealso::

 #ref:`inserts_and_updates` - SQL Expression
 #anguage Tutorial


 #""
 #elf._preserve_parameter_order = preserve_parameter_order
 #uper(Update, self).__init__(table, values, prefixes)
 #elf._bind = bind
 #f returning:
 #elf._returning = returning
 #f whereclause is not None:
 #elf._where_criteria += (
 #oercions.expect(roles.WhereHavingRole, whereclause),
 #
 #elf._inline = inline
 #f dialect_kw:
 #elf._validate_dialect_kwargs_deprecated(dialect_kw)
 #elf._return_defaults = return_defaults

 #_generative
 #ef ordered_values(self, *args):
 #""Specify the VALUES clause of this UPDATE statement with an explicit
 #arameter ordering that will be maintained in the SET clause of the
 #esulting UPDATE statement.

 #.g.::

 #tmt = table.update().ordered_values(
 #"name", "ed"), ("ident": "foo")
 #

 #. seealso::

 #ref:`updates_order_parameters` - full example of the
 #meth:`_expression.Update.ordered_values` method.

 #. versionchanged:: 1.4 The :meth:`_expression.Update.ordered_values`
 #ethod
 #upersedes the
 #paramref:`_expression.update.preserve_parameter_order`
 #arameter, which will be removed in SQLAlchemy 2.0.

 #""
 #f self._values:
 #aise exc.ArgumentError(
 #This statement already has values present"
 #
 #lif self._ordered_values:
 #aise exc.ArgumentError(
 #This statement already has ordered values present"
 #
 #rg = [
 #
 #oercions.expect(roles.DMLColumnRole, k),
 #oercions.expect(
 #oles.ExpressionElementRole,
 #,
 #ype_=NullType(),
 #s_crud=True,
 #,
 #
 #or k, v in args
 #
 #elf._ordered_values = arg

 #_generative
 #ef inline(self):
 #""Make this :class:`_expression.Update` construct "inline" .

 #hen set, SQL defaults present on :class:`_schema.Column`
 #bjects via the
 #`default`` keyword will be compiled 'inline' into the statement and
 #ot pre-executed.  This means that their values will not be available
 #n the dictionary returned from
 #meth:`_engine.CursorResult.last_updated_params`.

 #. versionchanged:: 1.4 the :paramref:`_expression.update.inline`
 #arameter
 #s now superseded by the :meth:`_expression.Update.inline` method.

 #""
 #elf._inline = True


class Delete(DMLWhereBase, UpdateBase):
 #""Represent a DELETE construct.

 #he :class:`_expression.Delete` object is created using the
 #func:`_expression.delete()` function.

 #""

 #_visit_name__ = "delete"

 #s_delete = True

 #traverse_internals = (
 #
 #"table", InternalTraversal.dp_clauseelement),
 #"_where_criteria", InternalTraversal.dp_clauseelement_list),
 #"_returning", InternalTraversal.dp_clauseelement_list),
 #"_hints", InternalTraversal.dp_table_hint_list),
 #
 # HasPrefixes._has_prefixes_traverse_internals
 # DialectKWArgs._dialect_kwargs_traverse_internals
 # Executable._executable_traverse_internals
 # HasCTE._has_ctes_traverse_internals
 #

 #ValuesBase._constructor_20_deprecations(
 #delete",
 #Delete",
 #"whereclause", "values", "bind", "prefixes", "returning"],
 #
 #ef __init__(
 #elf,
 #able,
 #hereclause=None,
 #ind=None,
 #eturning=None,
 #refixes=None,
 #*dialect_kw
 #:
 #"""Construct :class:`_expression.Delete` object.

 #.g.::

 #rom sqlalchemy import delete

 #tmt = (
 #elete(user_table).
 #here(user_table.c.id == 5)
 #

 #imilar functionality is available via the
 #meth:`_expression.TableClause.delete` method on
 #class:`_schema.Table`.

 #. seealso::

 #ref:`inserts_and_updates` - in the
 #ref:`1.x tutorial <sqlexpression_toplevel>`

 #ref:`tutorial_core_update_delete` - in the :ref:`unified_tutorial`


 #param table: The table to delete rows from.

 #param whereclause: Optional SQL expression describing the ``WHERE``
 #ondition of the ``DELETE`` statement; is equivalent to using the
 #ore modern :meth:`~Delete.where()` method to specify the ``WHERE``
 #lause.

 #. seealso::

 #ref:`deletes` - SQL Expression Tutorial

 #""
 #elf._bind = bind
 #elf.table = coercions.expect(
 #oles.DMLTableRole, table, apply_propagate_attrs=self
 #
 #f returning:
 #elf._returning = returning

 #f prefixes:
 #elf._setup_prefixes(prefixes)

 #f whereclause is not None:
 #elf._where_criteria += (
 #oercions.expect(roles.WhereHavingRole, whereclause),
 #

 #f dialect_kw:
 #elf._validate_dialect_kwargs_deprecated(dialect_kw)
