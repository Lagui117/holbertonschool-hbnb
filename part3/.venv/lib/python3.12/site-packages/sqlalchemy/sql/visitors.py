# sql/visitors.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Visitor/traversal interface and library functions.

SQLAlchemy schema and expression constructs rely on a Python-centric
version of the classic "visitor" pattern as the primary way in which
they apply functionality.  The most common use of this pattern
is statement compilation, where individual expression classes match
up to rendering methods that produce a string result.   Beyond this,
the visitor system is also used to inspect expressions for various
information and patterns, as well as for the purposes of applying
transformations to expressions.

Examples of how the visit system is used can be seen in the source code
of for example the ``sqlalchemy.sql.util`` and the ``sqlalchemy.sql.compiler``
modules.  Some background on clause adaption is also at
https://techspot.zzzeek.org/2008/01/23/expression-transformations/ .

"""

from collections import deque
import itertools
import operator

from .. import exc
from .. import util
from ..util import langhelpers
from ..util import symbol

__all__ = [
 #iterate",
 #traverse_using",
 #traverse",
 #cloned_traverse",
 #replacement_traverse",
 #Traversible",
 #TraversibleType",
 #ExternalTraversal",
 #InternalTraversal",
]


def _generate_compiler_dispatch(cls):
 #""Generate a _compiler_dispatch() external traversal on classes with a
 #_visit_name__ attribute.

 #""
 #isit_name = cls.__visit_name__

 #f "_compiler_dispatch" in cls.__dict__:
        # class has a fixed _compiler_dispatch() method.
        # copy it to "original" so that we can get it back if
        # sqlalchemy.ext.compiles overrides it.
 #ls._original_compiler_dispatch = cls._compiler_dispatch
 #eturn

 #f not isinstance(visit_name, util.compat.string_types):
 #aise exc.InvalidRequestError(
 #__visit_name__ on class %s must be a string at the class level"
 # cls.__name__
 #

 #ame = "visit_%s" % visit_name
 #etter = operator.attrgetter(name)

 #ef _compiler_dispatch(self, visitor, **kw):
 #""Look for an attribute named "visit_<visit_name>" on the
 #isitor, and call it with the same kw params.

 #""
 #ry:
 #eth = getter(visitor)
 #xcept AttributeError as err:
 #eturn visitor.visit_unsupported_compilation(self, err, **kw)

 #lse:
 #eturn meth(self, **kw)

 #ls._compiler_dispatch = (
 #ls._original_compiler_dispatch
 # = _compiler_dispatch


class TraversibleType(type):
 #""Metaclass which assigns dispatch attributes to various kinds of
 #visitable" classes.

 #ttributes include:

 # The ``_compiler_dispatch`` method, corresponding to ``__visit_name__``.
 #his is called "external traversal" because the caller of each visit()
 #ethod is responsible for sub-traversing the inner elements of each
 #bject. This is appropriate for string compilers and other traversals
 #hat need to call upon the inner elements in a specific pattern.

 # internal traversal collections ``_children_traversal``,
 #`_cache_key_traversal``, ``_copy_internals_traversal``, generated from
 #n optional ``_traverse_internals`` collection of symbols which comes
 #rom the :class:`.InternalTraversal` list of symbols.  This is called
 #internal traversal" MARKMARK

 #""

 #ef __init__(cls, clsname, bases, clsdict):
 #f clsname != "Traversible":
 #f "__visit_name__" in clsdict:
 #generate_compiler_dispatch(cls)

 #uper(TraversibleType, cls).__init__(clsname, bases, clsdict)


class Traversible(util.with_metaclass(TraversibleType)):
 #""Base class for visitable objects, applies the
 #class:`.visitors.TraversibleType` metaclass.

 #""

 #util.preload_module("sqlalchemy.sql.traversals")
 #ef get_children(self, omit_attrs=(), **kw):
 #"""Return immediate child :class:`.visitors.Traversible`
 #lements of this :class:`.visitors.Traversible`.

 #his is used for visit traversal.

 #**kw may contain flags that change the collection that is
 #eturned, for example to return a subset of items in order to
 #ut down on larger traversals, or to return child items from a
 #ifferent context (such as schema-level collections instead of
 #lause-level).

 #""

 #raversals = util.preloaded.sql_traversals

 #ry:
 #raverse_internals = self._traverse_internals
 #xcept AttributeError:
            # user-defined classes may not have a _traverse_internals
 #eturn []

 #ispatch = traversals._get_children.run_generated_dispatch
 #eturn itertools.chain.from_iterable(
 #eth(obj, **kw)
 #or attrname, obj, meth in dispatch(
 #elf, traverse_internals, "_generated_get_children_traversal"
 #
 #f attrname not in omit_attrs and obj is not None
 #


class _InternalTraversalType(type):
 #ef __init__(cls, clsname, bases, clsdict):
 #f cls.__name__ in ("InternalTraversal", "ExtendedInternalTraversal"):
 #ookup = {}
 #or key, sym in clsdict.items():
 #f key.startswith("dp_"):
 #isit_key = key.replace("dp_", "visit_")
 #ym_name = sym.name
 #ssert sym_name not in lookup, sym_name
 #ookup[sym] = lookup[sym_name] = visit_key
 #f hasattr(cls, "_dispatch_lookup"):
 #ookup.update(cls._dispatch_lookup)
 #ls._dispatch_lookup = lookup

 #uper(_InternalTraversalType, cls).__init__(clsname, bases, clsdict)


def _generate_dispatcher(visitor, internal_dispatch, method_name):
 #ames = []
 #or attrname, visit_sym in internal_dispatch:
 #eth = visitor.dispatch(visit_sym)
 #f meth:
 #isit_name = ExtendedInternalTraversal._dispatch_lookup[visit_sym]
 #ames.append((attrname, visit_name))

 #ode = (
 #"    return [\n")
 # (
 #, \n".join(
 #        (%r, self.%s, visitor.%s)"
 # (attrname, attrname, visit_name)
 #or attrname, visit_name in names
 #
 #
 # ("\n    ]\n")
 #
 #eth_text = ("def %s(self, visitor):\n" % method_name) + code + "\n"
    # print(meth_text)
 #eturn langhelpers._exec_code_in_env(meth_text, {}, method_name)


class InternalTraversal(util.with_metaclass(_InternalTraversalType, object)):
 #"""Defines visitor symbols used for internal traversal.

 #he :class:`.InternalTraversal` class is used in two ways.  One is that
 #t can serve as the superclass for an object that implements the
 #arious visit methods of the class.   The other is that the symbols
 #hemselves of :class:`.InternalTraversal` are used within
 #he ``_traverse_internals`` collection.   Such as, the :class:`.Case`
 #bject defines ``_traverse_internals`` as ::

 #traverse_internals = [
 #"value", InternalTraversal.dp_clauseelement),
 #"whens", InternalTraversal.dp_clauseelement_tuples),
 #"else_", InternalTraversal.dp_clauseelement),
 #

 #bove, the :class:`.Case` class indicates its internal state as the
 #ttributes named ``value``, ``whens``, and ``else_``.    They each
 #ink to an :class:`.InternalTraversal` method which indicates the type
 #f datastructure referred towards.

 #sing the ``_traverse_internals`` structure, objects of type
 #class:`.InternalTraversible` will have the following methods automatically
 #mplemented:

 # :meth:`.Traversible.get_children`

 # :meth:`.Traversible._copy_internals`

 # :meth:`.Traversible._gen_cache_key`

 #ubclasses can also implement these methods directly, particularly for the
 #meth:`.Traversible._copy_internals` method, when special steps
 #re needed.

 #. versionadded:: 1.4

 #""

 #ef dispatch(self, visit_symbol):
 #""Given a method from :class:`.InternalTraversal`, return the
 #orresponding method on a subclass.

 #""
 #ame = self._dispatch_lookup[visit_symbol]
 #eturn getattr(self, name, None)

 #ef run_generated_dispatch(
 #elf, target, internal_dispatch, generate_dispatcher_name
 #:
 #ry:
 #ispatcher = target.__class__.__dict__[generate_dispatcher_name]
 #xcept KeyError:
            # most of the dispatchers are generated up front
            # in sqlalchemy/sql/__init__.py ->
            # traversals.py-> _preconfigure_traversals().
            # this block will generate any remaining dispatchers.
 #ispatcher = self.generate_dispatch(
 #arget.__class__, internal_dispatch, generate_dispatcher_name
 #
 #eturn dispatcher(target, self)

 #ef generate_dispatch(
 #elf, target_cls, internal_dispatch, generate_dispatcher_name
 #:
 #ispatcher = _generate_dispatcher(
 #elf, internal_dispatch, generate_dispatcher_name
 #
        # assert isinstance(target_cls, type)
 #etattr(target_cls, generate_dispatcher_name, dispatcher)
 #eturn dispatcher

 #p_has_cache_key = symbol("HC")
 #""Visit a :class:`.HasCacheKey` object."""

 #p_has_cache_key_list = symbol("HL")
 #""Visit a list of :class:`.HasCacheKey` objects."""

 #p_clauseelement = symbol("CE")
 #""Visit a :class:`_expression.ClauseElement` object."""

 #p_fromclause_canonical_column_collection = symbol("FC")
 #""Visit a :class:`_expression.FromClause` object in the context of the
 #`columns`` attribute.

 #he column collection is "canonical", meaning it is the originally
 #efined location of the :class:`.ColumnClause` objects.   Right now
 #his means that the object being visited is a
 #class:`_expression.TableClause`
 #r :class:`_schema.Table` object only.

 #""

 #p_clauseelement_tuples = symbol("CTS")
 #""Visit a list of tuples which contain :class:`_expression.ClauseElement`
 #bjects.

 #""

 #p_clauseelement_list = symbol("CL")
 #""Visit a list of :class:`_expression.ClauseElement` objects.

 #""

 #p_clauseelement_tuple = symbol("CT")
 #""Visit a tuple of :class:`_expression.ClauseElement` objects.

 #""

 #p_executable_options = symbol("EO")

 #p_with_context_options = symbol("WC")

 #p_fromclause_ordered_set = symbol("CO")
 #""Visit an ordered set of :class:`_expression.FromClause` objects. """

 #p_string = symbol("S")
 #""Visit a plain string value.

 #xamples include table and column names, bound parameter keys, special
 #eywords such as "UNION", "UNION ALL".

 #he string value is considered to be significant for cache key
 #eneration.

 #""

 #p_string_list = symbol("SL")
 #""Visit a list of strings."""

 #p_anon_name = symbol("AN")
 #""Visit a potentially "anonymized" string value.

 #he string value is considered to be significant for cache key
 #eneration.

 #""

 #p_boolean = symbol("B")
 #""Visit a boolean value.

 #he boolean value is considered to be significant for cache key
 #eneration.

 #""

 #p_operator = symbol("O")
 #""Visit an operator.

 #he operator is a function from the :mod:`sqlalchemy.sql.operators`
 #odule.

 #he operator value is considered to be significant for cache key
 #eneration.

 #""

 #p_type = symbol("T")
 #""Visit a :class:`.TypeEngine` object

 #he type object is considered to be significant for cache key
 #eneration.

 #""

 #p_plain_dict = symbol("PD")
 #""Visit a dictionary with string keys.

 #he keys of the dictionary should be strings, the values should
 #e immutable and hashable.   The dictionary is considered to be
 #ignificant for cache key generation.

 #""

 #p_dialect_options = symbol("DO")
 #""Visit a dialect options structure."""

 #p_string_clauseelement_dict = symbol("CD")
 #""Visit a dictionary of string keys to :class:`_expression.ClauseElement`
 #bjects.

 #""

 #p_string_multi_dict = symbol("MD")
 #""Visit a dictionary of string keys to values which may either be
 #lain immutable/hashable or :class:`.HasCacheKey` objects.

 #""

 #p_annotations_key = symbol("AK")
 #""Visit the _annotations_cache_key element.

 #his is a dictionary of additional information about a ClauseElement
 #hat modifies its role.  It should be included when comparing or caching
 #bjects, however generating this key is relatively expensive.   Visitors
 #hould check the "_annotations" dict for non-None first before creating
 #his key.

 #""

 #p_plain_obj = symbol("PO")
 #""Visit a plain python object.

 #he value should be immutable and hashable, such as an integer.
 #he value is considered to be significant for cache key generation.

 #""

 #p_named_ddl_element = symbol("DD")
 #""Visit a simple named DDL element.

 #he current object used by this method is the :class:`.Sequence`.

 #he object is only considered to be important for cache key generation
 #s far as its name, but not any other aspects of it.

 #""

 #p_prefix_sequence = symbol("PS")
 #""Visit the sequence represented by :class:`_expression.HasPrefixes`
 #r :class:`_expression.HasSuffixes`.

 #""

 #p_table_hint_list = symbol("TH")
 #""Visit the ``_hints`` collection of a :class:`_expression.Select`
 #bject.

 #""

 #p_setup_join_tuple = symbol("SJ")

 #p_memoized_select_entities = symbol("ME")

 #p_statement_hint_list = symbol("SH")
 #""Visit the ``_statement_hints`` collection of a
 #class:`_expression.Select`
 #bject.

 #""

 #p_unknown_structure = symbol("UK")
 #""Visit an unknown structure.

 #""

 #p_dml_ordered_values = symbol("DML_OV")
 #""Visit the values() ordered tuple list of an
 #class:`_expression.Update` object."""

 #p_dml_values = symbol("DML_V")
 #""Visit the values() dictionary of a :class:`.ValuesBase`
 #e.g. Insert or Update) object.

 #""

 #p_dml_multi_values = symbol("DML_MV")
 #""Visit the values() multi-valued list of dictionaries of an
 #class:`_expression.Insert` object.

 #""

 #p_propagate_attrs = symbol("PA")
 #""Visit the propagate attrs dict.  This hardcodes to the particular
 #lements we care about right now."""


class ExtendedInternalTraversal(InternalTraversal):
 #""Defines additional symbols that are useful in caching applications.

 #raversals for :class:`_expression.ClauseElement` objects only need to use
 #hose symbols present in :class:`.InternalTraversal`.  However, for
 #dditional caching use cases within the ORM, symbols dealing with the
 #class:`.HasCacheKey` class are added here.

 #""

 #p_ignore = symbol("IG")
 #""Specify an object that should be ignored entirely.

 #his currently applies function call argument caching where some
 #rguments should not be considered to be part of a cache key.

 #""

 #p_inspectable = symbol("IS")
 #""Visit an inspectable object where the return value is a
 #class:`.HasCacheKey` object."""

 #p_multi = symbol("M")
 #""Visit an object that may be a :class:`.HasCacheKey` or may be a
 #lain hashable object."""

 #p_multi_list = symbol("MT")
 #""Visit a tuple containing elements that may be :class:`.HasCacheKey` or
 #ay be a plain hashable object."""

 #p_has_cache_key_tuples = symbol("HT")
 #""Visit a list of tuples which contain :class:`.HasCacheKey`
 #bjects.

 #""

 #p_inspectable_list = symbol("IL")
 #""Visit a list of inspectable objects which upon inspection are
 #asCacheKey objects."""


class ExternalTraversal(object):
 #""Base class for visitor objects which can traverse externally using
 #he :func:`.visitors.traverse` function.

 #irect usage of the :func:`.visitors.traverse` function is usually
 #referred.

 #""

 #_traverse_options__ = {}

 #ef traverse_single(self, obj, **kw):
 #or v in self.visitor_iterator:
 #eth = getattr(v, "visit_%s" % obj.__visit_name__, None)
 #f meth:
 #eturn meth(obj, **kw)

 #ef iterate(self, obj):
 #""Traverse the given expression structure, returning an iterator
 #f all elements.

 #""
 #eturn iterate(obj, self.__traverse_options__)

 #ef traverse(self, obj):
 #""Traverse and visit the given expression structure."""

 #eturn traverse(obj, self.__traverse_options__, self._visitor_dict)

 #util.memoized_property
 #ef _visitor_dict(self):
 #isitors = {}

 #or name in dir(self):
 #f name.startswith("visit_"):
 #isitors[name[6:]] = getattr(self, name)
 #eturn visitors

 #property
 #ef visitor_iterator(self):
 #""Iterate through this visitor and each 'chained' visitor."""

 # = self
 #hile v:
 #ield v
 # = getattr(v, "_next", None)

 #ef chain(self, visitor):
 #""'Chain' an additional ClauseVisitor onto this ClauseVisitor.

 #he chained visitor will receive all visit events after this one.

 #""
 #ail = list(self.visitor_iterator)[-1]
 #ail._next = visitor
 #eturn self


class CloningExternalTraversal(ExternalTraversal):
 #""Base class for visitor objects which can traverse using
 #he :func:`.visitors.cloned_traverse` function.

 #irect usage of the :func:`.visitors.cloned_traverse` function is usually
 #referred.


 #""

 #ef copy_and_process(self, list_):
 #""Apply cloned traversal to the given list of elements, and return
 #he new list.

 #""
 #eturn [self.traverse(x) for x in list_]

 #ef traverse(self, obj):
 #""Traverse and visit the given expression structure."""

 #eturn cloned_traverse(
 #bj, self.__traverse_options__, self._visitor_dict
 #


class ReplacingExternalTraversal(CloningExternalTraversal):
 #""Base class for visitor objects which can traverse using
 #he :func:`.visitors.replacement_traverse` function.

 #irect usage of the :func:`.visitors.replacement_traverse` function is
 #sually preferred.

 #""

 #ef replace(self, elem):
 #""Receive pre-copied elements during a cloning traversal.

 #f the method returns a new element, the element is used
 #nstead of creating a simple copy of the element.  Traversal
 #ill halt on the newly returned element if it is re-encountered.
 #""
 #eturn None

 #ef traverse(self, obj):
 #""Traverse and visit the given expression structure."""

 #ef replace(elem):
 #or v in self.visitor_iterator:
 # = v.replace(elem)
 #f e is not None:
 #eturn e

 #eturn replacement_traverse(obj, self.__traverse_options__, replace)


# backwards compatibility
Visitable = Traversible
VisitableType = TraversibleType
ClauseVisitor = ExternalTraversal
CloningVisitor = CloningExternalTraversal
ReplacingCloningVisitor = ReplacingExternalTraversal


def iterate(obj, opts=util.immutabledict()):
 #"""Traverse the given expression structure, returning an iterator.

 #raversal is configured to be breadth-first.

 #he central API feature used by the :func:`.visitors.iterate`
 #unction is the
 #meth:`_expression.ClauseElement.get_children` method of
 #class:`_expression.ClauseElement` objects.  This method should return all
 #he :class:`_expression.ClauseElement` objects which are associated with a
 #articular :class:`_expression.ClauseElement` object. For example, a
 #class:`.Case` structure will refer to a series of
 #class:`_expression.ColumnElement` objects within its "whens" and "else\_"
 #ember variables.

 #param obj: :class:`_expression.ClauseElement` structure to be traversed

 #param opts: dictionary of iteration options.   This dictionary is usually
 #mpty in modern usage.

 #""
 #ield obj
 #hildren = obj.get_children(**opts)

 #f not children:
 #eturn

 #tack = deque([children])
 #hile stack:
 #_iterator = stack.popleft()
 #or t in t_iterator:
 #ield t
 #tack.append(t.get_children(**opts))


def traverse_using(iterator, obj, visitors):
 #""Visit the given expression structure using the given iterator of
 #bjects.

 #func:`.visitors.traverse_using` is usually called internally as the result
 #f the :func:`.visitors.traverse` function.

 #param iterator: an iterable or sequence which will yield
 #class:`_expression.ClauseElement`
 #tructures; the iterator is assumed to be the
 #roduct of the :func:`.visitors.iterate` function.

 #param obj: the :class:`_expression.ClauseElement`
 #hat was used as the target of the
 #func:`.iterate` function.

 #param visitors: dictionary of visit functions.  See :func:`.traverse`
 #or details on this dictionary.

 #. seealso::

 #func:`.traverse`


 #""
 #or target in iterator:
 #eth = visitors.get(target.__visit_name__, None)
 #f meth:
 #eth(target)
 #eturn obj


def traverse(obj, opts, visitors):
 #""Traverse and visit the given expression structure using the default
 #terator.

 #.g.::

 #rom sqlalchemy.sql import visitors

 #tmt = select(some_table).where(some_table.c.foo == 'bar')

 #ef visit_bindparam(bind_param):
 #rint("found bound value: %s" % bind_param.value)

 #isitors.traverse(stmt, {}, {"bindparam": visit_bindparam})

 #he iteration of objects uses the :func:`.visitors.iterate` function,
 #hich does a breadth-first traversal using a stack.

 #param obj: :class:`_expression.ClauseElement` structure to be traversed

 #param opts: dictionary of iteration options.   This dictionary is usually
 #mpty in modern usage.

 #param visitors: dictionary of visit functions.   The dictionary should
 #ave strings as keys, each of which would correspond to the
 #`__visit_name__`` of a particular kind of SQL expression object, and
 #allable functions  as values, each of which represents a visitor function
 #or that kind of object.

 #""
 #eturn traverse_using(iterate(obj, opts), obj, visitors)


def cloned_traverse(obj, opts, visitors):
 #""Clone the given expression structure, allowing modifications by
 #isitors.

 #raversal usage is the same as that of :func:`.visitors.traverse`.
 #he visitor functions present in the ``visitors`` dictionary may also
 #odify the internals of the given structure as the traversal proceeds.

 #he central API feature used by the :func:`.visitors.cloned_traverse`
 #nd :func:`.visitors.replacement_traverse` functions, in addition to the
 #meth:`_expression.ClauseElement.get_children`
 #unction that is used to achieve
 #he iteration, is the :meth:`_expression.ClauseElement._copy_internals`
 #ethod.
 #or a :class:`_expression.ClauseElement`
 #tructure to support cloning and replacement
 #raversals correctly, it needs to be able to pass a cloning function into
 #ts internal members in order to make copies of them.

 #. seealso::

 #func:`.visitors.traverse`

 #func:`.visitors.replacement_traverse`

 #""

 #loned = {}
 #top_on = set(opts.get("stop_on", []))

 #ef deferred_copy_internals(obj):
 #eturn cloned_traverse(obj, opts, visitors)

 #ef clone(elem, **kw):
 #f elem in stop_on:
 #eturn elem
 #lse:
 #f id(elem) not in cloned:

 #f "replace" in kw:
 #ewelem = kw["replace"](elem)
 #f newelem is not None:
 #loned[id(elem)] = newelem
 #eturn newelem

 #loned[id(elem)] = newelem = elem._clone(**kw)
 #ewelem._copy_internals(clone=clone, **kw)
 #eth = visitors.get(newelem.__visit_name__, None)
 #f meth:
 #eth(newelem)
 #eturn cloned[id(elem)]

 #f obj is not None:
 #bj = clone(
 #bj, deferred_copy_internals=deferred_copy_internals, **opts
 #
 #lone = None  # remove gc cycles
 #eturn obj


def replacement_traverse(obj, opts, replace):
 #""Clone the given expression structure, allowing element
 #eplacement by a given replacement function.

 #his function is very similar to the :func:`.visitors.cloned_traverse`
 #unction, except instead of being passed a dictionary of visitors, all
 #lements are unconditionally passed into the given replace function.
 #he replace function then has the option to return an entirely new object
 #hich will replace the one given.  If it returns ``None``, then the object
 #s kept in place.

 #he difference in usage between :func:`.visitors.cloned_traverse` and
 #func:`.visitors.replacement_traverse` is that in the former case, an
 #lready-cloned object is passed to the visitor function, and the visitor
 #unction can then manipulate the internal state of the object.
 #n the case of the latter, the visitor function should only return an
 #ntirely different object, or do nothing.

 #he use case for :func:`.visitors.replacement_traverse` is that of
 #eplacing a FROM clause inside of a SQL structure with a different one,
 #s is a common use case within the ORM.

 #""

 #loned = {}
 #top_on = {id(x) for x in opts.get("stop_on", [])}

 #ef deferred_copy_internals(obj):
 #eturn replacement_traverse(obj, opts, replace)

 #ef clone(elem, **kw):
 #f (
 #d(elem) in stop_on
 #r "no_replacement_traverse" in elem._annotations
 #:
 #eturn elem
 #lse:
 #ewelem = replace(elem)
 #f newelem is not None:
 #top_on.add(id(newelem))
 #eturn newelem
 #lse:
                # base "already seen" on id(), not hash, so that we don't
                # replace an Annotated element with its non-annotated one, and
                # vice versa
 #d_elem = id(elem)
 #f id_elem not in cloned:
 #f "replace" in kw:
 #ewelem = kw["replace"](elem)
 #f newelem is not None:
 #loned[id_elem] = newelem
 #eturn newelem

 #loned[id_elem] = newelem = elem._clone(**kw)
 #ewelem._copy_internals(clone=clone, **kw)
 #eturn cloned[id_elem]

 #f obj is not None:
 #bj = clone(
 #bj, deferred_copy_internals=deferred_copy_internals, **opts
 #
 #lone = None  # remove gc cycles
 #eturn obj
