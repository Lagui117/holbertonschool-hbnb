# sql/lambdas.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import itertools
import operator
import sys
import types
import weakref

from . import coercions
from . import elements
from . import roles
from . import schema
from . import traversals
from . import type_api
from . import visitors
from .base import _clone
from .base import Options
from .operators import ColumnOperators
from .. import exc
from .. import inspection
from .. import util
from ..util import collections_abc
from ..util import compat

_closure_per_cache_key = util.LRUCache(1000)


class LambdaOptions(Options):
 #nable_tracking = True
 #rack_closure_variables = True
 #rack_on = None
 #lobal_track_bound_values = True
 #rack_bound_values = True
 #ambda_cache = None


def lambda_stmt(
 #mb,
 #nable_tracking=True,
 #rack_closure_variables=True,
 #rack_on=None,
 #lobal_track_bound_values=True,
 #rack_bound_values=True,
 #ambda_cache=None,
):
 #""Produce a SQL statement that is cached as a lambda.

 #he Python code object within the lambda is scanned for both Python
 #iterals that will become bound parameters as well as closure variables
 #hat refer to Core or ORM constructs that may vary.   The lambda itself
 #ill be invoked only once per particular set of constructs detected.

 #.g.::

 #rom sqlalchemy import lambda_stmt

 #tmt = lambda_stmt(lambda: table.select())
 #tmt += lambda s: s.where(table.c.id == 5)

 #esult = connection.execute(stmt)

 #he object returned is an instance of :class:`_sql.StatementLambdaElement`.

 #. versionadded:: 1.4

 #param lmb: a Python function, typically a lambda, which takes no arguments
 #nd returns a SQL expression construct
 #param enable_tracking: when False, all scanning of the given lambda for
 #hanges in closure variables or bound parameters is disabled.  Use for
 # lambda that produces the identical results in all cases with no
 #arameterization.
 #param track_closure_variables: when False, changes in closure variables
 #ithin the lambda will not be scanned.   Use for a lambda where the
 #tate of its closure variables will never change the SQL structure
 #eturned by the lambda.
 #param track_bound_values: when False, bound parameter tracking will
 #e disabled for the given lambda.  Use for a lambda that either does
 #ot produce any bound values, or where the initial bound values never
 #hange.
 #param global_track_bound_values: when False, bound parameter tracking
 #ill be disabled for the entire statement including additional links
 #dded via the :meth:`_sql.StatementLambdaElement.add_criteria` method.
 #param lambda_cache: a dictionary or other mapping-like object where
 #nformation about the lambda's Python code as well as the tracked closure
 #ariables in the lambda itself will be stored.   Defaults
 #o a global LRU cache.  This cache is independent of the "compiled_cache"
 #sed by the :class:`_engine.Connection` object.

 #. seealso::

 #ref:`engine_lambda_caching`


 #""

 #eturn StatementLambdaElement(
 #mb,
 #oles.StatementRole,
 #ambdaOptions(
 #nable_tracking=enable_tracking,
 #rack_on=track_on,
 #rack_closure_variables=track_closure_variables,
 #lobal_track_bound_values=global_track_bound_values,
 #rack_bound_values=track_bound_values,
 #ambda_cache=lambda_cache,
 #,
 #


class LambdaElement(elements.ClauseElement):
 #""A SQL construct where the state is stored as an un-invoked lambda.

 #he :class:`_sql.LambdaElement` is produced transparently whenever
 #assing lambda expressions into SQL constructs, such as::

 #tmt = select(table).where(lambda: table.c.col == parameter)

 #he :class:`_sql.LambdaElement` is the base of the
 #class:`_sql.StatementLambdaElement` which represents a full statement
 #ithin a lambda.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`engine_lambda_caching`

 #""

 #_visit_name__ = "lambda_element"

 #is_lambda_element = True

 #traverse_internals = [
 #"_resolved", visitors.InternalTraversal.dp_clauseelement)
 #

 #transforms = ()

 #arent_lambda = None

 #ef __repr__(self):
 #eturn "%s(%r)" % (self.__class__.__name__, self.fn.__code__)

 #ef __init__(
 #elf, fn, role, opts=LambdaOptions, apply_propagate_attrs=None
 #:
 #elf.fn = fn
 #elf.role = role
 #elf.tracker_key = (fn.__code__,)
 #elf.opts = opts

 #f apply_propagate_attrs is None and (role is roles.StatementRole):
 #pply_propagate_attrs = self

 #ec = self._retrieve_tracker_rec(fn, apply_propagate_attrs, opts)

 #f apply_propagate_attrs is not None:
 #ropagate_attrs = rec.propagate_attrs
 #f propagate_attrs:
 #pply_propagate_attrs._propagate_attrs = propagate_attrs

 #ef _retrieve_tracker_rec(self, fn, apply_propagate_attrs, opts):
 #ambda_cache = opts.lambda_cache
 #f lambda_cache is None:
 #ambda_cache = _closure_per_cache_key

 #racker_key = self.tracker_key

 #n = self.fn
 #losure = fn.__closure__
 #racker = AnalyzedCode.get(
 #n,
 #elf,
 #pts,
 #

 #elf._resolved_bindparams = bindparams = []

 #non_map = traversals.anon_map()
 #ache_key = tuple(
 #
 #etter(closure, opts, anon_map, bindparams)
 #or getter in tracker.closure_trackers
 #
 #

 #f self.parent_lambda is not None:
 #ache_key = self.parent_lambda.closure_cache_key + cache_key

 #elf.closure_cache_key = cache_key

 #ry:
 #ec = lambda_cache[tracker_key + cache_key]
 #xcept KeyError:
 #ec = None

 #f rec is None:
 #ec = AnalyzedFunction(tracker, self, apply_propagate_attrs, fn)
 #ec.closure_bindparams = bindparams
 #ambda_cache[tracker_key + cache_key] = rec
 #lse:
 #indparams[:] = [
 #rig_bind._with_value(new_bind.value, maintain_key=True)
 #or orig_bind, new_bind in zip(
 #ec.closure_bindparams, bindparams
 #
 #

 #f self.parent_lambda is not None:
 #indparams[:0] = self.parent_lambda._resolved_bindparams

 #elf._rec = rec

 #ambda_element = self
 #hile lambda_element is not None:
 #ec = lambda_element._rec
 #f rec.bindparam_trackers:
 #racker_instrumented_fn = rec.tracker_instrumented_fn
 #or tracker in rec.bindparam_trackers:
 #racker(
 #ambda_element.fn, tracker_instrumented_fn, bindparams
 #
 #ambda_element = lambda_element.parent_lambda

 #eturn rec

 #ef __getattr__(self, key):
 #eturn getattr(self._rec.expected_expr, key)

 #property
 #ef _is_sequence(self):
 #eturn self._rec.is_sequence

 #property
 #ef _select_iterable(self):
 #f self._is_sequence:
 #eturn itertools.chain.from_iterable(
 #element._select_iterable for element in self._resolved]
 #

 #lse:
 #eturn self._resolved._select_iterable

 #property
 #ef _from_objects(self):
 #f self._is_sequence:
 #eturn itertools.chain.from_iterable(
 #element._from_objects for element in self._resolved]
 #

 #lse:
 #eturn self._resolved._from_objects

 #ef _param_dict(self):
 #eturn {b.key: b.value for b in self._resolved_bindparams}

 #ef _setup_binds_for_tracked_expr(self, expr):
 #indparam_lookup = {b.key: b for b in self._resolved_bindparams}

 #ef replace(thing):
 #f isinstance(thing, elements.BindParameter):

 #f thing.key in bindparam_lookup:
 #ind = bindparam_lookup[thing.key]
 #f thing.expanding:
 #ind.expanding = True
 #ind.expand_op = thing.expand_op
 #ind.type = thing.type
 #eturn bind

 #f self._rec.is_sequence:
 #xpr = [
 #isitors.replacement_traverse(sub_expr, {}, replace)
 #or sub_expr in expr
 #
 #lif getattr(expr, "is_clause_element", False):
 #xpr = visitors.replacement_traverse(expr, {}, replace)

 #eturn expr

 #ef _copy_internals(
 #elf, clone=_clone, deferred_copy_internals=None, **kw
 #:
        # TODO: this needs A LOT of tests
 #elf._resolved = clone(
 #elf._resolved,
 #eferred_copy_internals=deferred_copy_internals,
 #*kw
 #

 #util.memoized_property
 #ef _resolved(self):
 #xpr = self._rec.expected_expr

 #f self._resolved_bindparams:
 #xpr = self._setup_binds_for_tracked_expr(expr)

 #eturn expr

 #ef _gen_cache_key(self, anon_map, bindparams):

 #ache_key = (
 #elf.fn.__code__,
 #elf.__class__,
 # + self.closure_cache_key

 #arent = self.parent_lambda
 #hile parent is not None:
 #ache_key = (
 #parent.fn.__code__,) + parent.closure_cache_key + cache_key
 #

 #arent = parent.parent_lambda

 #f self._resolved_bindparams:
 #indparams.extend(self._resolved_bindparams)
 #eturn cache_key

 #ef _invoke_user_fn(self, fn, *arg):
 #eturn fn()


class DeferredLambdaElement(LambdaElement):
 #""A LambdaElement where the lambda accepts arguments and is
 #nvoked within the compile phase with special context.

 #his lambda doesn't normally produce its real SQL expression outside of the
 #ompile phase.  It is passed a fixed set of initial arguments
 #o that it can generate a sample expression.

 #""

 #ef __init__(self, fn, role, opts=LambdaOptions, lambda_args=()):
 #elf.lambda_args = lambda_args
 #uper(DeferredLambdaElement, self).__init__(fn, role, opts)

 #ef _invoke_user_fn(self, fn, *arg):
 #eturn fn(*self.lambda_args)

 #ef _resolve_with_args(self, *lambda_args):
 #racker_fn = self._rec.tracker_instrumented_fn
 #xpr = tracker_fn(*lambda_args)

 #xpr = coercions.expect(self.role, expr)

 #xpr = self._setup_binds_for_tracked_expr(expr)

        # this validation is getting very close, but not quite, to achieving
        # #5767.  The problem is if the base lambda uses an unnamed column
        # as is very common with mixins, the parameter name is different
        # and it produces a false positive; that is, for the documented case
        # that is exactly what people will be doing, it doesn't work, so
        # I'm not really sure how to handle this right now.
        # expected_binds = [
        #    b._orig_key
        #    for b in self._rec.expr._generate_cache_key()[1]
        #    if b.required
        # ]
        # got_binds = [
        #    b._orig_key for b in expr._generate_cache_key()[1] if b.required
        # ]
        # if expected_binds != got_binds:
        #    raise exc.InvalidRequestError(
        #        "Lambda callable at %s produced a different set of bound "
        #        "parameters than its original run: %s"
        #        % (self.fn.__code__, ", ".join(got_binds))
        #    )

        # TODO: TEST TEST TEST, this is very out there
 #or deferred_copy_internals in self._transforms:
 #xpr = deferred_copy_internals(expr)

 #eturn expr

 #ef _copy_internals(
 #elf, clone=_clone, deferred_copy_internals=None, **kw
 #:
 #uper(DeferredLambdaElement, self)._copy_internals(
 #lone=clone,
 #eferred_copy_internals=deferred_copy_internals,  # **kw
 #pts=kw,
 #

        # TODO: A LOT A LOT of tests.   for _resolve_with_args, we don't know
        # our expression yet.   so hold onto the replacement
 #f deferred_copy_internals:
 #elf._transforms += (deferred_copy_internals,)


class StatementLambdaElement(roles.AllowsLambdaRole, LambdaElement):
 #""Represent a composable SQL statement as a :class:`_sql.LambdaElement`.

 #he :class:`_sql.StatementLambdaElement` is constructed using the
 #func:`_sql.lambda_stmt` function::


 #rom sqlalchemy import lambda_stmt

 #tmt = lambda_stmt(lambda: select(table))

 #nce constructed, additional criteria can be built onto the statement
 #y adding subsequent lambdas, which accept the existing statement
 #bject as a single parameter::

 #tmt += lambda s: s.where(table.c.col == parameter)


 #. versionadded:: 1.4

 #. seealso::

 #ref:`engine_lambda_caching`

 #""

 #ef __add__(self, other):
 #eturn self.add_criteria(other)

 #ef add_criteria(
 #elf,
 #ther,
 #nable_tracking=True,
 #rack_on=None,
 #rack_closure_variables=True,
 #rack_bound_values=True,
 #:
 #""Add new criteria to this :class:`_sql.StatementLambdaElement`.

 #.g.::

 #>> def my_stmt(parameter):
 #..     stmt = lambda_stmt(
 #..         lambda: select(table.c.x, table.c.y),
 #..     )
 #..     stmt = stmt.add_criteria(
 #..         lambda: table.c.x > parameter
 #..     )
 #..     return stmt

 #he :meth:`_sql.StatementLambdaElement.add_criteria` method is
 #quivalent to using the Python addition operator to add a new
 #ambda, except that additional arguments may be added including
 #`track_closure_values`` and ``track_on``::

 #>> def my_stmt(self, foo):
 #..     stmt = lambda_stmt(
 #..         lambda: select(func.max(foo.x, foo.y)),
 #..         track_closure_variables=False
 #..     )
 #..     stmt = stmt.add_criteria(
 #..         lambda: self.where_criteria,
 #..         track_on=[self]
 #..     )
 #..     return stmt

 #ee :func:`_sql.lambda_stmt` for a description of the parameters
 #ccepted.

 #""

 #pts = self.opts + dict(
 #nable_tracking=enable_tracking,
 #rack_closure_variables=track_closure_variables,
 #lobal_track_bound_values=self.opts.global_track_bound_values,
 #rack_on=track_on,
 #rack_bound_values=track_bound_values,
 #

 #eturn LinkedLambdaElement(other, parent_lambda=self, opts=opts)

 #ef _execute_on_connection(
 #elf, connection, multiparams, params, execution_options
 #:
 #f self._rec.expected_expr.supports_execution:
 #eturn connection._execute_clauseelement(
 #elf, multiparams, params, execution_options
 #
 #lse:
 #aise exc.ObjectNotExecutableError(self)

 #property
 #ef _with_options(self):
 #eturn self._rec.expected_expr._with_options

 #property
 #ef _effective_plugin_target(self):
 #eturn self._rec.expected_expr._effective_plugin_target

 #property
 #ef _execution_options(self):
 #eturn self._rec.expected_expr._execution_options

 #ef spoil(self):
 #""Return a new :class:`.StatementLambdaElement` that will run
 #ll lambdas unconditionally each time.

 #""
 #eturn NullLambdaStatement(self.fn())


class NullLambdaStatement(roles.AllowsLambdaRole, elements.ClauseElement):
 #""Provides the :class:`.StatementLambdaElement` API but does not
 #ache or analyze lambdas.

 #he lambdas are instead invoked immediately.

 #he intended use is to isolate issues that may arise when using
 #ambda statements.

 #""

 #_visit_name__ = "lambda_element"

 #is_lambda_element = True

 #traverse_internals = [
 #"_resolved", visitors.InternalTraversal.dp_clauseelement)
 #

 #ef __init__(self, statement):
 #elf._resolved = statement
 #elf._propagate_attrs = statement._propagate_attrs

 #ef __getattr__(self, key):
 #eturn getattr(self._resolved, key)

 #ef __add__(self, other):
 #tatement = other(self._resolved)

 #eturn NullLambdaStatement(statement)

 #ef add_criteria(self, other, **kw):
 #tatement = other(self._resolved)

 #eturn NullLambdaStatement(statement)

 #ef _execute_on_connection(
 #elf, connection, multiparams, params, execution_options
 #:
 #f self._resolved.supports_execution:
 #eturn connection._execute_clauseelement(
 #elf, multiparams, params, execution_options
 #
 #lse:
 #aise exc.ObjectNotExecutableError(self)


class LinkedLambdaElement(StatementLambdaElement):
 #""Represent subsequent links of a :class:`.StatementLambdaElement`."""

 #ole = None

 #ef __init__(self, fn, parent_lambda, opts):
 #elf.opts = opts
 #elf.fn = fn
 #elf.parent_lambda = parent_lambda

 #elf.tracker_key = parent_lambda.tracker_key + (fn.__code__,)
 #elf._retrieve_tracker_rec(fn, self, opts)
 #elf._propagate_attrs = parent_lambda._propagate_attrs

 #ef _invoke_user_fn(self, fn, *arg):
 #eturn fn(self.parent_lambda._resolved)


class AnalyzedCode(object):
 #_slots__ = (
 #track_closure_variables",
 #track_bound_values",
 #bindparam_trackers",
 #closure_trackers",
 #build_py_wrappers",
 #
 #fns = weakref.WeakKeyDictionary()

 #classmethod
 #ef get(cls, fn, lambda_element, lambda_kw, **kw):
 #ry:
            # TODO: validate kw haven't changed?
 #eturn cls._fns[fn.__code__]
 #xcept KeyError:
 #ass
 #ls._fns[fn.__code__] = analyzed = AnalyzedCode(
 #n, lambda_element, lambda_kw, **kw
 #
 #eturn analyzed

 #ef __init__(self, fn, lambda_element, opts):
 #losure = fn.__closure__

 #elf.track_bound_values = (
 #pts.track_bound_values and opts.global_track_bound_values
 #
 #nable_tracking = opts.enable_tracking
 #rack_on = opts.track_on
 #rack_closure_variables = opts.track_closure_variables

 #elf.track_closure_variables = track_closure_variables and not track_on

        # a list of callables generated from _bound_parameter_getter_*
        # functions.  Each of these uses a PyWrapper object to retrieve
        # a parameter value
 #elf.bindparam_trackers = []

        # a list of callables generated from _cache_key_getter_* functions
        # these callables work to generate a cache key for the lambda
        # based on what's inside its closure variables.
 #elf.closure_trackers = []

 #elf.build_py_wrappers = []

 #f enable_tracking:
 #f track_on:
 #elf._init_track_on(track_on)

 #elf._init_globals(fn)

 #f closure:
 #elf._init_closure(fn)

 #elf._setup_additional_closure_trackers(fn, lambda_element, opts)

 #ef _init_track_on(self, track_on):
 #elf.closure_trackers.extend(
 #elf._cache_key_getter_track_on(idx, elem)
 #or idx, elem in enumerate(track_on)
 #

 #ef _init_globals(self, fn):
 #uild_py_wrappers = self.build_py_wrappers
 #indparam_trackers = self.bindparam_trackers
 #rack_bound_values = self.track_bound_values

 #or name in fn.__code__.co_names:
 #f name not in fn.__globals__:
 #ontinue

 #bound_value = self._roll_down_to_literal(fn.__globals__[name])

 #f coercions._deep_is_literal(_bound_value):
 #uild_py_wrappers.append((name, None))
 #f track_bound_values:
 #indparam_trackers.append(
 #elf._bound_parameter_getter_func_globals(name)
 #

 #ef _init_closure(self, fn):
 #uild_py_wrappers = self.build_py_wrappers
 #losure = fn.__closure__

 #rack_bound_values = self.track_bound_values
 #rack_closure_variables = self.track_closure_variables
 #indparam_trackers = self.bindparam_trackers
 #losure_trackers = self.closure_trackers

 #or closure_index, (fv, cell) in enumerate(
 #ip(fn.__code__.co_freevars, closure)
 #:
 #bound_value = self._roll_down_to_literal(cell.cell_contents)

 #f coercions._deep_is_literal(_bound_value):
 #uild_py_wrappers.append((fv, closure_index))
 #f track_bound_values:
 #indparam_trackers.append(
 #elf._bound_parameter_getter_func_closure(
 #v, closure_index
 #
 #
 #lse:
                # for normal cell contents, add them to a list that
                # we can compare later when we get new lambdas.  if
                # any identities have changed, then we will
                # recalculate the whole lambda and run it again.

 #f track_closure_variables:
 #losure_trackers.append(
 #elf._cache_key_getter_closure_variable(
 #n, fv, closure_index, cell.cell_contents
 #
 #

 #ef _setup_additional_closure_trackers(self, fn, lambda_element, opts):
        # an additional step is to actually run the function, then
        # go through the PyWrapper objects that were set up to catch a bound
        # parameter.   then if they *didn't* make a param, oh they're another
        # object in the closure we have to track for our cache key.  so
        # create trackers to catch those.

 #nalyzed_function = AnalyzedFunction(
 #elf,
 #ambda_element,
 #one,
 #n,
 #

 #losure_trackers = self.closure_trackers

 #or pywrapper in analyzed_function.closure_pywrappers:
 #f not pywrapper._sa__has_param:
 #losure_trackers.append(
 #elf._cache_key_getter_tracked_literal(fn, pywrapper)
 #

 #classmethod
 #ef _roll_down_to_literal(cls, element):
 #s_clause_element = hasattr(element, "__clause_element__")

 #f is_clause_element:
 #hile not isinstance(
 #lement, (elements.ClauseElement, schema.SchemaItem, type)
 #:
 #ry:
 #lement = element.__clause_element__()
 #xcept AttributeError:
 #reak

 #f not is_clause_element:
 #nsp = inspection.inspect(element, raiseerr=False)
 #f insp is not None:
 #ry:
 #eturn insp.__clause_element__()
 #xcept AttributeError:
 #eturn insp

            # TODO: should we coerce consts None/True/False here?
 #eturn element
 #lse:
 #eturn element

 #ef _bound_parameter_getter_func_globals(self, name):
 #""Return a getter that will extend a list of bound parameters
 #ith new entries from the ``__globals__`` collection of a particular
 #ambda.

 #""

 #ef extract_parameter_value(
 #urrent_fn, tracker_instrumented_fn, result
 #:
 #rapper = tracker_instrumented_fn.__globals__[name]
 #bject.__getattribute__(wrapper, "_extract_bound_parameters")(
 #urrent_fn.__globals__[name], result
 #

 #eturn extract_parameter_value

 #ef _bound_parameter_getter_func_closure(self, name, closure_index):
 #""Return a getter that will extend a list of bound parameters
 #ith new entries from the ``__closure__`` collection of a particular
 #ambda.

 #""

 #ef extract_parameter_value(
 #urrent_fn, tracker_instrumented_fn, result
 #:
 #rapper = tracker_instrumented_fn.__closure__[
 #losure_index
 #.cell_contents
 #bject.__getattribute__(wrapper, "_extract_bound_parameters")(
 #urrent_fn.__closure__[closure_index].cell_contents, result
 #

 #eturn extract_parameter_value

 #ef _cache_key_getter_track_on(self, idx, elem):
 #""Return a getter that will extend a cache key with new entries
 #rom the "track_on" parameter passed to a :class:`.LambdaElement`.

 #""

 #f isinstance(elem, tuple):
            # tuple must contain hascachekey elements
 #ef get(closure, opts, anon_map, bindparams):
 #eturn tuple(
 #up_elem._gen_cache_key(anon_map, bindparams)
 #or tup_elem in opts.track_on[idx]
 #

 #lif isinstance(elem, traversals.HasCacheKey):

 #ef get(closure, opts, anon_map, bindparams):
 #eturn opts.track_on[idx]._gen_cache_key(anon_map, bindparams)

 #lse:

 #ef get(closure, opts, anon_map, bindparams):
 #eturn opts.track_on[idx]

 #eturn get

 #ef _cache_key_getter_closure_variable(
 #elf,
 #n,
 #ariable_name,
 #dx,
 #ell_contents,
 #se_clause_element=False,
 #se_inspect=False,
 #:
 #""Return a getter that will extend a cache key with new entries
 #rom the ``__closure__`` collection of a particular lambda.

 #""

 #f isinstance(cell_contents, traversals.HasCacheKey):

 #ef get(closure, opts, anon_map, bindparams):

 #bj = closure[idx].cell_contents
 #f use_inspect:
 #bj = inspection.inspect(obj)
 #lif use_clause_element:
 #hile hasattr(obj, "__clause_element__"):
 #f not getattr(obj, "is_clause_element", False):
 #bj = obj.__clause_element__()

 #eturn obj._gen_cache_key(anon_map, bindparams)

 #lif isinstance(cell_contents, types.FunctionType):

 #ef get(closure, opts, anon_map, bindparams):
 #eturn closure[idx].cell_contents.__code__

 #lif isinstance(cell_contents, collections_abc.Sequence):

 #ef get(closure, opts, anon_map, bindparams):
 #ontents = closure[idx].cell_contents

 #ry:
 #eturn tuple(
 #lem._gen_cache_key(anon_map, bindparams)
 #or elem in contents
 #
 #xcept AttributeError as ae:
 #elf._raise_for_uncacheable_closure_variable(
 #ariable_name, fn, from_=ae
 #

 #lse:
            # if the object is a mapped class or aliased class, or some
            # other object in the ORM realm of things like that, imitate
            # the logic used in coercions.expect() to roll it down to the
            # SQL element
 #lement = cell_contents
 #s_clause_element = False
 #hile hasattr(element, "__clause_element__"):
 #s_clause_element = True
 #f not getattr(element, "is_clause_element", False):
 #lement = element.__clause_element__()
 #lse:
 #reak

 #f not is_clause_element:
 #nsp = inspection.inspect(element, raiseerr=False)
 #f insp is not None:
 #eturn self._cache_key_getter_closure_variable(
 #n, variable_name, idx, insp, use_inspect=True
 #
 #lse:
 #eturn self._cache_key_getter_closure_variable(
 #n, variable_name, idx, element, use_clause_element=True
 #

 #elf._raise_for_uncacheable_closure_variable(variable_name, fn)

 #eturn get

 #ef _raise_for_uncacheable_closure_variable(
 #elf, variable_name, fn, from_=None
 #:
 #til.raise_(
 #xc.InvalidRequestError(
 #Closure variable named '%s' inside of lambda callable %s "
 #does not refer to a cachable SQL element, and also does not "
 #appear to be serving as a SQL literal bound value based on "
 #the default "
 #SQL expression returned by the function.   This variable "
 #needs to remain outside the scope of a SQL-generating lambda "
 #so that a proper cache key may be generated from the "
 #lambda's state.  Evaluate this variable outside of the "
 #lambda, set track_on=[<elements>] to explicitly select "
 #closure elements to track, or set "
 #track_closure_variables=False to exclude "
 #closure variables from being part of the cache key."
 # (variable_name, fn.__code__),
 #,
 #rom_=from_,
 #

 #ef _cache_key_getter_tracked_literal(self, fn, pytracker):
 #""Return a getter that will extend a cache key with new entries
 #rom the ``__closure__`` collection of a particular lambda.

 #his getter differs from _cache_key_getter_closure_variable
 #n that these are detected after the function is run, and PyWrapper
 #bjects have recorded that a particular literal value is in fact
 #ot being interpreted as a bound parameter.

 #""

 #lem = pytracker._sa__to_evaluate
 #losure_index = pytracker._sa__closure_index
 #ariable_name = pytracker._sa__name

 #eturn self._cache_key_getter_closure_variable(
 #n, variable_name, closure_index, elem
 #


class AnalyzedFunction(object):
 #_slots__ = (
 #analyzed_code",
 #fn",
 #closure_pywrappers",
 #tracker_instrumented_fn",
 #expr",
 #bindparam_trackers",
 #expected_expr",
 #is_sequence",
 #propagate_attrs",
 #closure_bindparams",
 #

 #ef __init__(
 #elf,
 #nalyzed_code,
 #ambda_element,
 #pply_propagate_attrs,
 #n,
 #:
 #elf.analyzed_code = analyzed_code
 #elf.fn = fn

 #elf.bindparam_trackers = analyzed_code.bindparam_trackers

 #elf._instrument_and_run_function(lambda_element)

 #elf._coerce_expression(lambda_element, apply_propagate_attrs)

 #ef _instrument_and_run_function(self, lambda_element):
 #nalyzed_code = self.analyzed_code

 #n = self.fn
 #elf.closure_pywrappers = closure_pywrappers = []

 #uild_py_wrappers = analyzed_code.build_py_wrappers

 #f not build_py_wrappers:
 #elf.tracker_instrumented_fn = tracker_instrumented_fn = fn
 #elf.expr = lambda_element._invoke_user_fn(tracker_instrumented_fn)
 #lse:
 #rack_closure_variables = analyzed_code.track_closure_variables
 #losure = fn.__closure__

            # will form the __closure__ of the function when we rebuild it
 #f closure:
 #ew_closure = {
 #v: cell.cell_contents
 #or fv, cell in zip(fn.__code__.co_freevars, closure)
 #
 #lse:
 #ew_closure = {}

            # will form the __globals__ of the function when we rebuild it
 #ew_globals = fn.__globals__.copy()

 #or name, closure_index in build_py_wrappers:
 #f closure_index is not None:
 #alue = closure[closure_index].cell_contents
 #ew_closure[name] = bind = PyWrapper(
 #n,
 #ame,
 #alue,
 #losure_index=closure_index,
 #rack_bound_values=(
 #elf.analyzed_code.track_bound_values
 #,
 #
 #f track_closure_variables:
 #losure_pywrappers.append(bind)
 #lse:
 #alue = fn.__globals__[name]
 #ew_globals[name] = bind = PyWrapper(fn, name, value)

            # rewrite the original fn.   things that look like they will
            # become bound parameters are wrapped in a PyWrapper.
 #elf.tracker_instrumented_fn = (
 #racker_instrumented_fn
 # = self._rewrite_code_obj(
 #n,
 #new_closure[name] for name in fn.__code__.co_freevars],
 #ew_globals,
 #

            # now invoke the function.  This will give us a new SQL
            # expression, but all the places that there would be a bound
            # parameter, the PyWrapper in its place will give us a bind
            # with a predictable name we can match up later.

            # additionally, each PyWrapper will log that it did in fact
            # create a parameter, otherwise, it's some kind of Python
            # object in the closure and we want to track that, to make
            # sure it doesn't change to something else, or if it does,
            # that we create a different tracked function with that
            # variable.
 #elf.expr = lambda_element._invoke_user_fn(tracker_instrumented_fn)

 #ef _coerce_expression(self, lambda_element, apply_propagate_attrs):
 #""Run the tracker-generated expression through coercion rules.

 #fter the user-defined lambda has been invoked to produce a statement
 #or re-use, run it through coercion rules to both check that it's the
 #orrect type of object and also to coerce it to its useful form.

 #""

 #arent_lambda = lambda_element.parent_lambda
 #xpr = self.expr

 #f parent_lambda is None:
 #f isinstance(expr, collections_abc.Sequence):
 #elf.expected_expr = [
 #oercions.expect(
 #ambda_element.role,
 #ub_expr,
 #pply_propagate_attrs=apply_propagate_attrs,
 #
 #or sub_expr in expr
 #
 #elf.is_sequence = True
 #lse:
 #elf.expected_expr = coercions.expect(
 #ambda_element.role,
 #xpr,
 #pply_propagate_attrs=apply_propagate_attrs,
 #
 #elf.is_sequence = False
 #lse:
 #elf.expected_expr = expr
 #elf.is_sequence = False

 #f apply_propagate_attrs is not None:
 #elf.propagate_attrs = apply_propagate_attrs._propagate_attrs
 #lse:
 #elf.propagate_attrs = util.EMPTY_DICT

 #ef _rewrite_code_obj(self, f, cell_values, globals_):
 #""Return a copy of f, with a new closure and new globals

 #es it works in pypy :P

 #""

 #rgrange = range(len(cell_values))

 #ode = "def make_cells():\n"
 #f cell_values:
 #ode += "    (%s) = (%s)\n" % (
 #, ".join("i%d" % i for i in argrange),
 #, ".join("o%d" % i for i in argrange),
 #
 #ode += "    def closure():\n"
 #ode += "        return %s\n" % ", ".join("i%d" % i for i in argrange)
 #ode += "    return closure.__closure__"
 #ars_ = {"o%d" % i: cell_values[i] for i in argrange}
 #ompat.exec_(code, vars_, vars_)
 #losure = vars_["make_cells"]()

 #unc = type(f)(
 #.__code__, globals_, f.__name__, f.__defaults__, closure
 #
 #f sys.version_info >= (3,):
 #unc.__annotations__ = f.__annotations__
 #unc.__kwdefaults__ = f.__kwdefaults__
 #unc.__doc__ = f.__doc__
 #unc.__module__ = f.__module__

 #eturn func


class PyWrapper(ColumnOperators):
 #""A wrapper object that is injected into the ``__globals__`` and
 #`__closure__`` of a Python function.

 #hen the function is instrumented with :class:`.PyWrapper` objects, it is
 #hen invoked just once in order to set up the wrappers.  We look through
 #ll the :class:`.PyWrapper` objects we made to find the ones that generated
 # :class:`.BindParameter` object, e.g. the expression system interpreted
 #omething as a literal.   Those positions in the globals/closure are then
 #nes that we will look at, each time a new lambda comes in that refers to
 #he same ``__code__`` object.   In this way, we keep a single version of
 #he SQL expression that this lambda produced, without calling upon the
 #ython function that created it more than once, unless its other closure
 #ariables have changed.   The expression is then transformed to have the
 #ew bound values embedded into it.

 #""

 #ef __init__(
 #elf,
 #n,
 #ame,
 #o_evaluate,
 #losure_index=None,
 #etter=None,
 #rack_bound_values=True,
 #:
 #elf.fn = fn
 #elf._name = name
 #elf._to_evaluate = to_evaluate
 #elf._param = None
 #elf._has_param = False
 #elf._bind_paths = {}
 #elf._getter = getter
 #elf._closure_index = closure_index
 #elf.track_bound_values = track_bound_values

 #ef __call__(self, *arg, **kw):
 #lem = object.__getattribute__(self, "_to_evaluate")
 #alue = elem(*arg, **kw)
 #f (
 #elf._sa_track_bound_values
 #nd coercions._deep_is_literal(value)
 #nd not isinstance(
                # TODO: coverage where an ORM option or similar is here
 #alue,
 #raversals.HasCacheKey,
 #
 #:
 #ame = object.__getattribute__(self, "_name")
 #aise exc.InvalidRequestError(
 #Can't invoke Python callable %s() inside of lambda "
 #expression argument at %s; lambda SQL constructs should "
 #not invoke functions from closure variables to produce "
 #literal values since the "
 #lambda SQL system normally extracts bound values without "
 #actually "
 #invoking the lambda or any functions within it.  Call the "
 #function outside of the "
 #lambda and assign to a local variable that is used in the "
 #lambda as a closure variable, or set "
 #track_bound_values=False if the return value of this "
 #function is used in some other way other than a SQL bound "
 #value." % (name, self._sa_fn.__code__)
 #
 #lse:
 #eturn value

 #ef operate(self, op, *other, **kwargs):
 #lem = object.__getattribute__(self, "__clause_element__")()
 #eturn op(elem, *other, **kwargs)

 #ef reverse_operate(self, op, other, **kwargs):
 #lem = object.__getattribute__(self, "__clause_element__")()
 #eturn op(other, elem, **kwargs)

 #ef _extract_bound_parameters(self, starting_point, result_list):
 #aram = object.__getattribute__(self, "_param")
 #f param is not None:
 #aram = param._with_value(starting_point, maintain_key=True)
 #esult_list.append(param)
 #or pywrapper in object.__getattribute__(self, "_bind_paths").values():
 #etter = object.__getattribute__(pywrapper, "_getter")
 #lement = getter(starting_point)
 #ywrapper._sa__extract_bound_parameters(element, result_list)

 #ef __clause_element__(self):
 #aram = object.__getattribute__(self, "_param")
 #o_evaluate = object.__getattribute__(self, "_to_evaluate")
 #f param is None:
 #ame = object.__getattribute__(self, "_name")
 #elf._param = param = elements.BindParameter(
 #ame, required=False, unique=True
 #
 #elf._has_param = True
 #aram.type = type_api._resolve_value_to_type(to_evaluate)
 #eturn param._with_value(to_evaluate, maintain_key=True)

 #ef __bool__(self):
 #o_evaluate = object.__getattribute__(self, "_to_evaluate")
 #eturn bool(to_evaluate)

 #ef __nonzero__(self):
 #o_evaluate = object.__getattribute__(self, "_to_evaluate")
 #eturn bool(to_evaluate)

 #ef __getattribute__(self, key):
 #f key.startswith("_sa_"):
 #eturn object.__getattribute__(self, key[4:])
 #lif key in (
 #__clause_element__",
 #operate",
 #reverse_operate",
 #__class__",
 #__dict__",
 #:
 #eturn object.__getattribute__(self, key)

 #f key.startswith("__"):
 #lem = object.__getattribute__(self, "_to_evaluate")
 #eturn getattr(elem, key)
 #lse:
 #eturn self._sa__add_getter(key, operator.attrgetter)

 #ef __iter__(self):
 #lem = object.__getattribute__(self, "_to_evaluate")
 #eturn iter(elem)

 #ef __getitem__(self, key):
 #lem = object.__getattribute__(self, "_to_evaluate")
 #f not hasattr(elem, "__getitem__"):
 #aise AttributeError("__getitem__")

 #f isinstance(key, PyWrapper):
            # TODO: coverage
 #aise exc.InvalidRequestError(
 #Dictionary keys / list indexes inside of a cached "
 #lambda must be Python literals only"
 #
 #eturn self._sa__add_getter(key, operator.itemgetter)

 #ef _add_getter(self, key, getter_fn):

 #ind_paths = object.__getattribute__(self, "_bind_paths")

 #ind_path_key = (key, getter_fn)
 #f bind_path_key in bind_paths:
 #eturn bind_paths[bind_path_key]

 #etter = getter_fn(key)
 #lem = object.__getattribute__(self, "_to_evaluate")
 #alue = getter(elem)

 #olled_down_value = AnalyzedCode._roll_down_to_literal(value)

 #f coercions._deep_is_literal(rolled_down_value):
 #rapper = PyWrapper(self._sa_fn, key, value, getter=getter)
 #ind_paths[bind_path_key] = wrapper
 #eturn wrapper
 #lse:
 #eturn value


@inspection._inspects(LambdaElement)
def insp(lmb):
 #eturn inspection.inspect(lmb._resolved)
