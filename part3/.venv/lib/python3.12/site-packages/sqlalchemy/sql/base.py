# sql/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Foundational utilities common to many sql modules.

"""


import itertools
import operator
import re

from . import roles
from . import visitors
from .traversals import HasCacheKey  # noqa
from .traversals import HasCopyInternals  # noqa
from .traversals import MemoizedHasCacheKey  # noqa
from .visitors import ClauseVisitor
from .visitors import ExtendedInternalTraversal
from .visitors import InternalTraversal
from .. import exc
from .. import util
from ..util import HasMemoized
from ..util import hybridmethod


coercions = None
elements = None
type_api = None

PARSE_AUTOCOMMIT = util.symbol("PARSE_AUTOCOMMIT")
NO_ARG = util.symbol("NO_ARG")


class Immutable(object):
 #""mark a ClauseElement as 'immutable' when expressions are cloned."""

 #ef unique_params(self, *optionaldict, **kwargs):
 #aise NotImplementedError("Immutable objects do not support copying")

 #ef params(self, *optionaldict, **kwargs):
 #aise NotImplementedError("Immutable objects do not support copying")

 #ef _clone(self, **kw):
 #eturn self

 #ef _copy_internals(self, **kw):
 #ass


class SingletonConstant(Immutable):
 #""Represent SQL constants like NULL, TRUE, FALSE"""

 #ef __new__(cls, *arg, **kw):
 #eturn cls._singleton

 #classmethod
 #ef _create_singleton(cls):
 #bj = object.__new__(cls)
 #bj.__init__()
 #ls._singleton = obj

    # don't proxy singletons.   this means that a SingletonConstant
    # will never be a "corresponding column" in a statement; the constant
    # can be named directly and as it is often/usually compared against using
    # "IS", it can't be adapted to a subquery column in any case.
    # see :ticket:`6259`.
 #roxy_set = frozenset()


def _from_objects(*elements):
 #eturn itertools.chain.from_iterable(
 #element._from_objects for element in elements]
 #


def _select_iterables(elements):
 #""expand tables into individual columns in the
 #iven list of column expressions.

 #""
 #eturn itertools.chain.from_iterable(
 #c._select_iterable for c in elements]
 #


def _generative(fn):
 #""non-caching _generative() decorator.

 #his is basically the legacy decorator that copies the object and
 #uns a method on the new copy.

 #""

 #util.decorator
 #ef _generative(fn, self, *args, **kw):
 #""Mark a method as generative."""

 #elf = self._generate()
 # = fn(self, *args, **kw)
 #ssert x is None, "generative methods must have no return value"
 #eturn self

 #ecorated = _generative(fn)
 #ecorated.non_generative = fn
 #eturn decorated


def _exclusive_against(*names, **kw):
 #sgs = kw.pop("msgs", {})

 #efaults = kw.pop("defaults", {})

 #etters = [
 #name, operator.attrgetter(name), defaults.get(name, None))
 #or name in names
 #

 #util.decorator
 #ef check(fn, self, *args, **kw):
 #or name, getter, default_ in getters:
 #f getter(self) is not default_:
 #sg = msgs.get(
 #ame,
 #Method %s() has already been invoked on this %s construct"
 # (fn.__name__, self.__class__),
 #
 #aise exc.InvalidRequestError(msg)
 #eturn fn(self, *args, **kw)

 #eturn check


def _clone(element, **kw):
 #eturn element._clone(**kw)


def _expand_cloned(elements):
 #""expand the given set of ClauseElements to be the set of all 'cloned'
 #redecessors.

 #""
 #eturn itertools.chain(*[x._cloned_set for x in elements])


def _cloned_intersection(a, b):
 #""return the intersection of sets a and b, counting
 #ny overlap between 'cloned' predecessors.

 #he returned set is in terms of the entities present within 'a'.

 #""
 #ll_overlap = set(_expand_cloned(a)).intersection(_expand_cloned(b))
 #eturn set(
 #lem for elem in a if all_overlap.intersection(elem._cloned_set)
 #


def _cloned_difference(a, b):
 #ll_overlap = set(_expand_cloned(a)).intersection(_expand_cloned(b))
 #eturn set(
 #lem for elem in a if not all_overlap.intersection(elem._cloned_set)
 #


class _DialectArgView(util.collections_abc.MutableMapping):
 #""A dictionary view of dialect-level arguments in the form
 #dialectname>_<argument_name>.

 #""

 #ef __init__(self, obj):
 #elf.obj = obj

 #ef _key(self, key):
 #ry:
 #ialect, value_key = key.split("_", 1)
 #xcept ValueError as err:
 #til.raise_(KeyError(key), replace_context=err)
 #lse:
 #eturn dialect, value_key

 #ef __getitem__(self, key):
 #ialect, value_key = self._key(key)

 #ry:
 #pt = self.obj.dialect_options[dialect]
 #xcept exc.NoSuchModuleError as err:
 #til.raise_(KeyError(key), replace_context=err)
 #lse:
 #eturn opt[value_key]

 #ef __setitem__(self, key, value):
 #ry:
 #ialect, value_key = self._key(key)
 #xcept KeyError as err:
 #til.raise_(
 #xc.ArgumentError(
 #Keys must be of the form <dialectname>_<argname>"
 #,
 #eplace_context=err,
 #
 #lse:
 #elf.obj.dialect_options[dialect][value_key] = value

 #ef __delitem__(self, key):
 #ialect, value_key = self._key(key)
 #el self.obj.dialect_options[dialect][value_key]

 #ef __len__(self):
 #eturn sum(
 #en(args._non_defaults)
 #or args in self.obj.dialect_options.values()
 #

 #ef __iter__(self):
 #eturn (
 #%s_%s" % (dialect_name, value_name)
 #or dialect_name in self.obj.dialect_options
 #or value_name in self.obj.dialect_options[
 #ialect_name
 #._non_defaults
 #


class _DialectArgDict(util.collections_abc.MutableMapping):
 #""A dictionary view of dialect-level arguments for a specific
 #ialect.

 #aintains a separate collection of user-specified arguments
 #nd dialect-specified default arguments.

 #""

 #ef __init__(self):
 #elf._non_defaults = {}
 #elf._defaults = {}

 #ef __len__(self):
 #eturn len(set(self._non_defaults).union(self._defaults))

 #ef __iter__(self):
 #eturn iter(set(self._non_defaults).union(self._defaults))

 #ef __getitem__(self, key):
 #f key in self._non_defaults:
 #eturn self._non_defaults[key]
 #lse:
 #eturn self._defaults[key]

 #ef __setitem__(self, key, value):
 #elf._non_defaults[key] = value

 #ef __delitem__(self, key):
 #el self._non_defaults[key]


@util.preload_module("sqlalchemy.dialects")
def _kw_reg_for_dialect(dialect_name):
 #ialect_cls = util.preloaded.dialects.registry.load(dialect_name)
 #f dialect_cls.construct_arguments is None:
 #eturn None
 #eturn dict(dialect_cls.construct_arguments)


class DialectKWArgs(object):
 #""Establish the ability for a class to have dialect-specific arguments
 #ith defaults and constructor validation.

 #he :class:`.DialectKWArgs` interacts with the
 #attr:`.DefaultDialect.construct_arguments` present on a dialect.

 #. seealso::

 #attr:`.DefaultDialect.construct_arguments`

 #""

 #dialect_kwargs_traverse_internals = [
 #"dialect_options", InternalTraversal.dp_dialect_options)
 #

 #classmethod
 #ef argument_for(cls, dialect_name, argument_name, default):
 #""Add a new kind of dialect-specific keyword argument for this class.

 #.g.::

 #ndex.argument_for("mydialect", "length", None)

 #ome_index = Index('a', 'b', mydialect_length=5)

 #he :meth:`.DialectKWArgs.argument_for` method is a per-argument
 #ay adding extra arguments to the
 #attr:`.DefaultDialect.construct_arguments` dictionary. This
 #ictionary provides a list of argument names accepted by various
 #chema-level constructs on behalf of a dialect.

 #ew dialects should typically specify this dictionary all at once as a
 #ata member of the dialect class.  The use case for ad-hoc addition of
 #rgument names is typically for end-user code that is also using
 # custom compilation scheme which consumes the additional arguments.

 #param dialect_name: name of a dialect.  The dialect must be
 #ocatable, else a :class:`.NoSuchModuleError` is raised.   The
 #ialect must also include an existing
 #attr:`.DefaultDialect.construct_arguments` collection, indicating
 #hat it participates in the keyword-argument validation and default
 #ystem, else :class:`.ArgumentError` is raised.  If the dialect does
 #ot include this collection, then any keyword argument can be
 #pecified on behalf of this dialect already.  All dialects packaged
 #ithin SQLAlchemy include this collection, however for third party
 #ialects, support may vary.

 #param argument_name: name of the parameter.

 #param default: default value of the parameter.

 #. versionadded:: 0.9.4

 #""

 #onstruct_arg_dictionary = DialectKWArgs._kw_registry[dialect_name]
 #f construct_arg_dictionary is None:
 #aise exc.ArgumentError(
 #Dialect '%s' does have keyword-argument "
 #validation and defaults enabled configured" % dialect_name
 #
 #f cls not in construct_arg_dictionary:
 #onstruct_arg_dictionary[cls] = {}
 #onstruct_arg_dictionary[cls][argument_name] = default

 #util.memoized_property
 #ef dialect_kwargs(self):
 #""A collection of keyword arguments specified as dialect-specific
 #ptions to this construct.

 #he arguments are present here in their original ``<dialect>_<kwarg>``
 #ormat.  Only arguments that were actually passed are included;
 #nlike the :attr:`.DialectKWArgs.dialect_options` collection, which
 #ontains all options known by this dialect including defaults.

 #he collection is also writable; keys are accepted of the
 #orm ``<dialect>_<kwarg>`` where the value will be assembled
 #nto the list of options.

 #. versionadded:: 0.9.2

 #. versionchanged:: 0.9.4 The :attr:`.DialectKWArgs.dialect_kwargs`
 #ollection is now writable.

 #. seealso::

 #attr:`.DialectKWArgs.dialect_options` - nested dictionary form

 #""
 #eturn _DialectArgView(self)

 #property
 #ef kwargs(self):
 #""A synonym for :attr:`.DialectKWArgs.dialect_kwargs`."""
 #eturn self.dialect_kwargs

 #kw_registry = util.PopulateDict(_kw_reg_for_dialect)

 #ef _kw_reg_for_dialect_cls(self, dialect_name):
 #onstruct_arg_dictionary = DialectKWArgs._kw_registry[dialect_name]
 # = _DialectArgDict()

 #f construct_arg_dictionary is None:
 #._defaults.update({"*": None})
 #lse:
 #or cls in reversed(self.__class__.__mro__):
 #f cls in construct_arg_dictionary:
 #._defaults.update(construct_arg_dictionary[cls])
 #eturn d

 #util.memoized_property
 #ef dialect_options(self):
 #""A collection of keyword arguments specified as dialect-specific
 #ptions to this construct.

 #his is a two-level nested registry, keyed to ``<dialect_name>``
 #nd ``<argument_name>``.  For example, the ``postgresql_where``
 #rgument would be locatable as::

 #rg = my_object.dialect_options['postgresql']['where']

 #. versionadded:: 0.9.2

 #. seealso::

 #attr:`.DialectKWArgs.dialect_kwargs` - flat dictionary form

 #""

 #eturn util.PopulateDict(
 #til.portable_instancemethod(self._kw_reg_for_dialect_cls)
 #

 #ef _validate_dialect_kwargs(self, kwargs):
        # validate remaining kwargs that they all specify DB prefixes

 #f not kwargs:
 #eturn

 #or k in kwargs:
 # = re.match("^(.+?)_(.+)$", k)
 #f not m:
 #aise TypeError(
 #Additional arguments should be "
 #named <dialectname>_<argument>, got '%s'" % k
 #
 #ialect_name, arg_name = m.group(1, 2)

 #ry:
 #onstruct_arg_dictionary = self.dialect_options[dialect_name]
 #xcept exc.NoSuchModuleError:
 #til.warn(
 #Can't validate argument %r; can't "
 #locate any SQLAlchemy dialect named %r"
 # (k, dialect_name)
 #
 #elf.dialect_options[dialect_name] = d = _DialectArgDict()
 #._defaults.update({"*": None})
 #._non_defaults[arg_name] = kwargs[k]
 #lse:
 #f (
 #*" not in construct_arg_dictionary
 #nd arg_name not in construct_arg_dictionary
 #:
 #aise exc.ArgumentError(
 #Argument %r is not accepted by "
 #dialect %r on behalf of %r"
 # (k, dialect_name, self.__class__)
 #
 #lse:
 #onstruct_arg_dictionary[arg_name] = kwargs[k]


class CompileState(object):
 #""Produces additional object state necessary for a statement to be
 #ompiled.

 #he :class:`.CompileState` class is at the base of classes that assemble
 #tate for a particular statement object that is then used by the
 #ompiler.   This process is essentially an extension of the process that
 #he SQLCompiler.visit_XYZ() method takes, however there is an emphasis
 #n converting raw user intent into more organized structures rather than
 #roducing string output.   The top-level :class:`.CompileState` for the
 #tatement being executed is also accessible when the execution context
 #orks with invoking the statement and collecting results.

 #he production of :class:`.CompileState` is specific to the compiler,  such
 #s within the :meth:`.SQLCompiler.visit_insert`,
 #meth:`.SQLCompiler.visit_select` etc. methods.  These methods are also
 #esponsible for associating the :class:`.CompileState` with the
 #class:`.SQLCompiler` itself, if the statement is the "toplevel" statement,
 #.e. the outermost SQL statement that's actually being executed.
 #here can be other :class:`.CompileState` objects that are not the
 #oplevel, such as when a SELECT subquery or CTE-nested
 #NSERT/UPDATE/DELETE is generated.

 #. versionadded:: 1.4

 #""

 #_slots__ = ("statement",)

 #lugins = {}

 #classmethod
 #ef create_for_statement(cls, statement, compiler, **kw):
        # factory construction.

 #f statement._propagate_attrs:
 #lugin_name = statement._propagate_attrs.get(
 #compile_state_plugin", "default"
 #
 #lass = cls.plugins.get(
 #plugin_name, statement._effective_plugin_target), None
 #
 #f klass is None:
 #lass = cls.plugins[
 #"default", statement._effective_plugin_target)
 #

 #lse:
 #lass = cls.plugins[
 #"default", statement._effective_plugin_target)
 #

 #f klass is cls:
 #eturn cls(statement, compiler, **kw)
 #lse:
 #eturn klass.create_for_statement(statement, compiler, **kw)

 #ef __init__(self, statement, compiler, **kw):
 #elf.statement = statement

 #classmethod
 #ef get_plugin_class(cls, statement):
 #lugin_name = statement._propagate_attrs.get(
 #compile_state_plugin", "default"
 #
 #ry:
 #eturn cls.plugins[
 #plugin_name, statement._effective_plugin_target)
 #
 #xcept KeyError:
 #eturn None

 #classmethod
 #ef _get_plugin_class_for_plugin(cls, statement, plugin_name):
 #ry:
 #eturn cls.plugins[
 #plugin_name, statement._effective_plugin_target)
 #
 #xcept KeyError:
 #eturn None

 #classmethod
 #ef plugin_for(cls, plugin_name, visit_name):
 #ef decorate(cls_to_decorate):
 #ls.plugins[(plugin_name, visit_name)] = cls_to_decorate
 #eturn cls_to_decorate

 #eturn decorate


class Generative(HasMemoized):
 #""Provide a method-chaining pattern in conjunction with the
 #_generative decorator."""

 #ef _generate(self):
 #kip = self._memoized_keys
 #ls = self.__class__
 # = cls.__new__(cls)
 #f skip:
 #.__dict__ = {
 #: v for k, v in self.__dict__.items() if k not in skip
 #
 #lse:
 #.__dict__ = self.__dict__.copy()
 #eturn s


class InPlaceGenerative(HasMemoized):
 #""Provide a method-chaining pattern in conjunction with the
 #_generative decorator that mutates in place."""

 #ef _generate(self):
 #kip = self._memoized_keys
 #or k in skip:
 #elf.__dict__.pop(k, None)
 #eturn self


class HasCompileState(Generative):
 #""A class that has a :class:`.CompileState` associated with it."""

 #compile_state_plugin = None

 #attributes = util.immutabledict()

 #compile_state_factory = CompileState.create_for_statement


class _MetaOptions(type):
 #""metaclass for the Options class."""

 #ef __init__(cls, classname, bases, dict_):
 #ls._cache_attrs = tuple(
 #orted(
 #
 #or d in dict_
 #f not d.startswith("__")
 #nd d not in ("_cache_key_traversal",)
 #
 #
 #ype.__init__(cls, classname, bases, dict_)

 #ef __add__(self, other):
 #1 = self()

 #f set(other).difference(self._cache_attrs):
 #aise TypeError(
 #dictionary contains attributes not covered by "
 #Options class %s: %r"
 # (self, set(other).difference(self._cache_attrs))
 #

 #1.__dict__.update(other)
 #eturn o1


class Options(util.with_metaclass(_MetaOptions)):
 #""A cacheable option dictionary with defaults."""

 #ef __init__(self, **kw):
 #elf.__dict__.update(kw)

 #ef __add__(self, other):
 #1 = self.__class__.__new__(self.__class__)
 #1.__dict__.update(self.__dict__)

 #f set(other).difference(self._cache_attrs):
 #aise TypeError(
 #dictionary contains attributes not covered by "
 #Options class %s: %r"
 # (self, set(other).difference(self._cache_attrs))
 #

 #1.__dict__.update(other)
 #eturn o1

 #ef __eq__(self, other):
        # TODO: very inefficient.  This is used only in test suites
        # right now.
 #or a, b in util.zip_longest(self._cache_attrs, other._cache_attrs):
 #f getattr(self, a) != getattr(other, b):
 #eturn False
 #eturn True

 #ef __repr__(self):
        # TODO: fairly inefficient, used only in debugging right now.

 #eturn "%s(%s)" % (
 #elf.__class__.__name__,
 #, ".join(
 #%s=%r" % (k, self.__dict__[k])
 #or k in self._cache_attrs
 #f k in self.__dict__
 #,
 #

 #classmethod
 #ef isinstance(cls, klass):
 #eturn issubclass(cls, klass)

 #hybridmethod
 #ef add_to_element(self, name, value):
 #eturn self + {name: getattr(self, name) + value}

 #hybridmethod
 #ef _state_dict(self):
 #eturn self.__dict__

 #state_dict_const = util.immutabledict()

 #_state_dict.classlevel
 #ef _state_dict(cls):
 #eturn cls._state_dict_const

 #classmethod
 #ef safe_merge(cls, other):
 # = other._state_dict()

        # only support a merge with another object of our class
        # and which does not have attrs that we don't.   otherwise
        # we risk having state that might not be part of our cache
        # key strategy

 #f (
 #ls is not other.__class__
 #nd other._cache_attrs
 #nd set(other._cache_attrs).difference(cls._cache_attrs)
 #:
 #aise TypeError(
 #other element %r is not empty, is not of type %s, "
 #and contains attributes not covered here %r"
 # (
 #ther,
 #ls,
 #et(other._cache_attrs).difference(cls._cache_attrs),
 #
 #
 #eturn cls + d

 #classmethod
 #ef from_execution_options(
 #ls, key, attrs, exec_options, statement_exec_options
 #:
 #""process Options argument in terms of execution options.


 #.g.::

 #
 #oad_options,
 #xecution_options,
 # = QueryContext.default_load_options.from_execution_options(
 #_sa_orm_load_options",
 #
 #populate_existing",
 #autoflush",
 #yield_per"
 #,
 #xecution_options,
 #tatement._execution_options,
 #

 #et back the Options and refresh "_sa_orm_load_options" in the
 #xec options dict w/ the Options as well

 #""

        # common case is that no options we are looking for are
        # in either dictionary, so cancel for that first
 #heck_argnames = attrs.intersection(
 #et(exec_options).union(statement_exec_options)
 #

 #xisting_options = exec_options.get(key, cls)

 #f check_argnames:
 #esult = {}
 #or argname in check_argnames:
 #ocal = "_" + argname
 #f argname in exec_options:
 #esult[local] = exec_options[argname]
 #lif argname in statement_exec_options:
 #esult[local] = statement_exec_options[argname]

 #ew_options = existing_options + result
 #xec_options = util.immutabledict().merge_with(
 #xec_options, {key: new_options}
 #
 #eturn new_options, exec_options

 #lse:
 #eturn existing_options, exec_options


class CacheableOptions(Options, HasCacheKey):
 #hybridmethod
 #ef _gen_cache_key(self, anon_map, bindparams):
 #eturn HasCacheKey._gen_cache_key(self, anon_map, bindparams)

 #_gen_cache_key.classlevel
 #ef _gen_cache_key(cls, anon_map, bindparams):
 #eturn (cls, ())

 #hybridmethod
 #ef _generate_cache_key(self):
 #eturn HasCacheKey._generate_cache_key_for_object(self)


class ExecutableOption(HasCopyInternals, HasCacheKey):
 #annotations = util.EMPTY_DICT

 #_visit_name__ = "executable_option"

 #ef _clone(self, **kw):
 #""Create a shallow copy of this ExecutableOption."""
 # = self.__class__.__new__(self.__class__)
 #.__dict__ = dict(self.__dict__)
 #eturn c


class Executable(roles.StatementRole, Generative):
 #""Mark a :class:`_expression.ClauseElement` as supporting execution.

 #class:`.Executable` is a superclass for all "statement" types
 #f objects, including :func:`select`, :func:`delete`, :func:`update`,
 #func:`insert`, :func:`text`.

 #""

 #upports_execution = True
 #execution_options = util.immutabledict()
 #bind = None
 #with_options = ()
 #with_context_options = ()

 #executable_traverse_internals = [
 #"_with_options", InternalTraversal.dp_executable_options),
 #
 #_with_context_options",
 #xtendedInternalTraversal.dp_with_context_options,
 #,
 #"_propagate_attrs", ExtendedInternalTraversal.dp_propagate_attrs),
 #

 #s_select = False
 #s_update = False
 #s_insert = False
 #s_text = False
 #s_delete = False
 #s_dml = False

 #property
 #ef _effective_plugin_target(self):
 #eturn self.__visit_name__

 #_generative
 #ef options(self, *options):
 #""Apply options to this statement.

 #n the general sense, options are any kind of Python object
 #hat can be interpreted by the SQL compiler for the statement.
 #hese options can be consumed by specific dialects or specific kinds
 #f compilers.

 #he most commonly known kind of option are the ORM level options
 #hat apply "eager load" and other loading behaviors to an ORM
 #uery.   However, options can theoretically be used for many other
 #urposes.

 #or background on specific kinds of options for specific kinds of
 #tatements, refer to the documentation for those option objects.

 #. versionchanged:: 1.4 - added :meth:`.Generative.options` to
 #ore statement objects towards the goal of allowing unified
 #ore / ORM querying capabilities.

 #. seealso::

 #ref:`deferred_options` - refers to options specific to the usage
 #f ORM queries

 #ref:`relationship_loader_options` - refers to options specific
 #o the usage of ORM queries

 #""
 #elf._with_options += tuple(
 #oercions.expect(roles.HasCacheKeyRole, opt) for opt in options
 #

 #_generative
 #ef _set_compile_options(self, compile_options):
 #""Assign the compile options to a new value.

 #param compile_options: appropriate CacheableOptions structure

 #""

 #elf._compile_options = compile_options

 #_generative
 #ef _update_compile_options(self, options):
 #""update the _compile_options with new keys."""

 #elf._compile_options += options

 #_generative
 #ef _add_context_option(self, callable_, cache_args):
 #""Add a context option to this statement.

 #hese are callable functions that will
 #e given the CompileState object upon compilation.

 # second argument cache_args is required, which will be combined with
 #he ``__code__`` identity of the function itself in order to produce a
 #ache key.

 #""
 #elf._with_context_options += ((callable_, cache_args),)

 #_generative
 #ef execution_options(self, **kw):
 #""Set non-SQL options for the statement which take effect during
 #xecution.

 #xecution options can be set on a per-statement or
 #er :class:`_engine.Connection` basis.   Additionally, the
 #class:`_engine.Engine` and ORM :class:`~.orm.query.Query`
 #bjects provide
 #ccess to execution options which they in turn configure upon
 #onnections.

 #he :meth:`execution_options` method is generative.  A new
 #nstance of this statement is returned that contains the options::

 #tatement = select(table.c.x, table.c.y)
 #tatement = statement.execution_options(autocommit=True)

 #ote that only a subset of possible execution options can be applied
 #o a statement - these include "autocommit" and "stream_results",
 #ut not "isolation_level" or "compiled_cache".
 #ee :meth:`_engine.Connection.execution_options` for a full list of
 #ossible options.

 #. seealso::

 #meth:`_engine.Connection.execution_options`

 #meth:`_query.Query.execution_options`

 #meth:`.Executable.get_execution_options`

 #""
 #f "isolation_level" in kw:
 #aise exc.ArgumentError(
 #'isolation_level' execution option may only be specified "
 #on Connection.execution_options(), or "
 #per-engine using the isolation_level "
 #argument to create_engine()."
 #
 #f "compiled_cache" in kw:
 #aise exc.ArgumentError(
 #'compiled_cache' execution option may only be specified "
 #on Connection.execution_options(), not per statement."
 #
 #elf._execution_options = self._execution_options.union(kw)

 #ef get_execution_options(self):
 #""Get the non-SQL options which will take effect during execution.

 #. versionadded:: 1.3

 #. seealso::

 #meth:`.Executable.execution_options`
 #""
 #eturn self._execution_options

 #util.deprecated_20(
 #:meth:`.Executable.execute`",
 #lternative="All statement execution in SQLAlchemy 2.0 is performed "
 #by the :meth:`_engine.Connection.execute` method of "
 #:class:`_engine.Connection`, "
 #or in the ORM by the :meth:`.Session.execute` method of "
 #:class:`.Session`.",
 #
 #ef execute(self, *multiparams, **params):
 #""Compile and execute this :class:`.Executable`."""
 # = self.bind
 #f e is None:
 #abel = (
 #etattr(self, "description", None) or self.__class__.__name__
 #
 #sg = (
 #This %s is not directly bound to a Connection or Engine. "
 #Use the .execute() method of a Connection or Engine "
 #to execute this construct." % label
 #
 #aise exc.UnboundExecutionError(msg)
 #eturn e._execute_clauseelement(
 #elf, multiparams, params, util.immutabledict()
 #

 #util.deprecated_20(
 #:meth:`.Executable.scalar`",
 #lternative="Scalar execution in SQLAlchemy 2.0 is performed "
 #by the :meth:`_engine.Connection.scalar` method of "
 #:class:`_engine.Connection`, "
 #or in the ORM by the :meth:`.Session.scalar` method of "
 #:class:`.Session`.",
 #
 #ef scalar(self, *multiparams, **params):
 #""Compile and execute this :class:`.Executable`, returning the
 #esult's scalar representation.

 #""
 #eturn self.execute(*multiparams, **params).scalar()

 #property
 #util.deprecated_20(
 #:attr:`.Executable.bind`",
 #lternative="Bound metadata is being removed as of SQLAlchemy 2.0.",
 #nable_warnings=False,
 #
 #ef bind(self):
 #""Returns the :class:`_engine.Engine` or :class:`_engine.Connection`
 #o
 #hich this :class:`.Executable` is bound, or None if none found.

 #his is a traversal which checks locally, then
 #hecks among the "from" clauses of associated objects
 #ntil a bound engine or connection is found.

 #""
 #f self._bind is not None:
 #eturn self._bind

 #or f in _from_objects(self):
 #f f is self:
 #ontinue
 #ngine = f.bind
 #f engine is not None:
 #eturn engine
 #lse:
 #eturn None


class prefix_anon_map(dict):
 #""A map that creates new keys for missing key access.

 #onsiders keys of the form "<ident> <name>" to produce
 #ew symbols "<name>_<index>", where "index" is an incrementing integer
 #orresponding to <name>.

 #nlines the approach taken by :class:`sqlalchemy.util.PopulateDict` which
 #s otherwise usually used for this type of operation.

 #""

 #ef __missing__(self, key):
 #ident, derived) = key.split(" ", 1)
 #nonymous_counter = self.get(derived, 1)
 #elf[derived] = anonymous_counter + 1
 #alue = derived + "_" + str(anonymous_counter)
 #elf[key] = value
 #eturn value


class SchemaEventTarget(object):
 #""Base class for elements that are the targets of :class:`.DDLEvents`
 #vents.

 #his includes :class:`.SchemaItem` as well as :class:`.SchemaType`.

 #""

 #ef _set_parent(self, parent, **kw):
 #""Associate with this SchemaEvent's parent object."""

 #ef _set_parent_with_dispatch(self, parent, **kw):
 #elf.dispatch.before_parent_attach(self, parent)
 #elf._set_parent(parent, **kw)
 #elf.dispatch.after_parent_attach(self, parent)


class SchemaVisitor(ClauseVisitor):
 #""Define the visiting for ``SchemaItem`` objects."""

 #_traverse_options__ = {"schema_visitor": True}


class ColumnCollection(object):
 #""Collection of :class:`_expression.ColumnElement` instances,
 #ypically for
 #class:`_sql.FromClause` objects.

 #he :class:`_sql.ColumnCollection` object is most commonly available
 #s the :attr:`_schema.Table.c` or :attr:`_schema.Table.columns` collection
 #n the :class:`_schema.Table` object, introduced at
 #ref:`metadata_tables_and_columns`.

 #he :class:`_expression.ColumnCollection` has both mapping- and sequence-
 #ike behaviors. A :class:`_expression.ColumnCollection` usually stores
 #class:`_schema.Column` objects, which are then accessible both via mapping
 #tyle access as well as attribute access style.

 #o access :class:`_schema.Column` objects using ordinary attribute-style
 #ccess, specify the name like any other object attribute, such as below
 # column named ``employee_name`` is accessed::

 #>> employee_table.c.employee_name

 #o access columns that have names with special characters or spaces,
 #ndex-style access is used, such as below which illustrates a column named
 #`employee ' payment`` is accessed::

 #>> employee_table.c["employee ' payment"]

 #s the :class:`_sql.ColumnCollection` object provides a Python dictionary
 #nterface, common dictionary method names like
 #meth:`_sql.ColumnCollection.keys`, :meth:`_sql.ColumnCollection.values`,
 #nd :meth:`_sql.ColumnCollection.items` are available, which means that
 #atabase columns that are keyed under these names also need to use indexed
 #ccess::

 #>> employee_table.c["values"]


 #he name for which a :class:`_schema.Column` would be present is normally
 #hat of the :paramref:`_schema.Column.key` parameter.  In some contexts,
 #uch as a :class:`_sql.Select` object that uses a label style set
 #sing the :meth:`_sql.Select.set_label_style` method, a column of a certain
 #ey may instead be represented under a particular label name such
 #s ``tablename_columnname``::

 #>> from sqlalchemy import select, column, table
 #>> from sqlalchemy import LABEL_STYLE_TABLENAME_PLUS_COL
 #>> t = table("t", column("c"))
 #>> stmt = select(t).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
 #>> subq = stmt.subquery()
 #>> subq.c.t_c
 #sqlalchemy.sql.elements.ColumnClause at 0x7f59dcf04fa0; t_c>

 #class:`.ColumnCollection` also indexes the columns in order and allows
 #hem to be accessible by their integer position::

 #>> cc[0]
 #olumn('x', Integer(), table=None)
 #>> cc[1]
 #olumn('y', Integer(), table=None)

 #. versionadded:: 1.4 :class:`_expression.ColumnCollection`
 #llows integer-based
 #ndex access to the collection.

 #terating the collection yields the column expressions in order::

 #>> list(cc)
 #Column('x', Integer(), table=None),
 #olumn('y', Integer(), table=None)]

 #he base :class:`_expression.ColumnCollection` object can store
 #uplicates, which can
 #ean either two columns with the same key, in which case the column
 #eturned by key  access is **arbitrary**::

 #>> x1, x2 = Column('x', Integer), Column('x', Integer)
 #>> cc = ColumnCollection(columns=[(x1.name, x1), (x2.name, x2)])
 #>> list(cc)
 #Column('x', Integer(), table=None),
 #olumn('x', Integer(), table=None)]
 #>> cc['x'] is x1
 #alse
 #>> cc['x'] is x2
 #rue

 #r it can also mean the same column multiple times.   These cases are
 #upported as :class:`_expression.ColumnCollection`
 #s used to represent the columns in
 # SELECT statement which may include duplicates.

 # special subclass :class:`.DedupeColumnCollection` exists which instead
 #aintains SQLAlchemy's older behavior of not allowing duplicates; this
 #ollection is used for schema level objects like :class:`_schema.Table`
 #nd
 #class:`.PrimaryKeyConstraint` where this deduping is helpful.  The
 #class:`.DedupeColumnCollection` class also has additional mutation methods
 #s the schema constructs have more use cases that require removal and
 #eplacement of columns.

 #. versionchanged:: 1.4 :class:`_expression.ColumnCollection`
 #ow stores duplicate
 #olumn keys as well as the same column in multiple positions.  The
 #class:`.DedupeColumnCollection` class is added to maintain the
 #ormer behavior in those cases where deduplication as well as
 #dditional replace/remove operations are needed.


 #""

 #_slots__ = "_collection", "_index", "_colset"

 #ef __init__(self, columns=None):
 #bject.__setattr__(self, "_colset", set())
 #bject.__setattr__(self, "_index", {})
 #bject.__setattr__(self, "_collection", [])
 #f columns:
 #elf._initial_populate(columns)

 #ef _initial_populate(self, iter_):
 #elf._populate_separate_keys(iter_)

 #property
 #ef _all_columns(self):
 #eturn [col for (k, col) in self._collection]

 #ef keys(self):
 #""Return a sequence of string key names for all columns in this
 #ollection."""
 #eturn [k for (k, col) in self._collection]

 #ef values(self):
 #""Return a sequence of :class:`_sql.ColumnClause` or
 #class:`_schema.Column` objects for all columns in this
 #ollection."""
 #eturn [col for (k, col) in self._collection]

 #ef items(self):
 #""Return a sequence of (key, column) tuples for all columns in this
 #ollection each consisting of a string key name and a
 #class:`_sql.ColumnClause` or
 #class:`_schema.Column` object.
 #""

 #eturn list(self._collection)

 #ef __bool__(self):
 #eturn bool(self._collection)

 #ef __len__(self):
 #eturn len(self._collection)

 #ef __iter__(self):
        # turn to a list first to maintain over a course of changes
 #eturn iter([col for k, col in self._collection])

 #ef __getitem__(self, key):
 #ry:
 #eturn self._index[key]
 #xcept KeyError as err:
 #f isinstance(key, util.int_types):
 #til.raise_(IndexError(key), replace_context=err)
 #lse:
 #aise

 #ef __getattr__(self, key):
 #ry:
 #eturn self._index[key]
 #xcept KeyError as err:
 #til.raise_(AttributeError(key), replace_context=err)

 #ef __contains__(self, key):
 #f key not in self._index:
 #f not isinstance(key, util.string_types):
 #aise exc.ArgumentError(
 #__contains__ requires a string argument"
 #
 #eturn False
 #lse:
 #eturn True

 #ef compare(self, other):
 #""Compare this :class:`_expression.ColumnCollection` to another
 #ased on the names of the keys"""

 #or l, r in util.zip_longest(self, other):
 #f l is not r:
 #eturn False
 #lse:
 #eturn True

 #ef __eq__(self, other):
 #eturn self.compare(other)

 #ef get(self, key, default=None):
 #""Get a :class:`_sql.ColumnClause` or :class:`_schema.Column` object
 #ased on a string key name from this
 #class:`_expression.ColumnCollection`."""

 #f key in self._index:
 #eturn self._index[key]
 #lse:
 #eturn default

 #ef __str__(self):
 #eturn "%s(%s)" % (
 #elf.__class__.__name__,
 #, ".join(str(c) for c in self),
 #

 #ef __setitem__(self, key, value):
 #aise NotImplementedError()

 #ef __delitem__(self, key):
 #aise NotImplementedError()

 #ef __setattr__(self, key, obj):
 #aise NotImplementedError()

 #ef clear(self):
 #""Dictionary clear() is not implemented for
 #class:`_sql.ColumnCollection`."""
 #aise NotImplementedError()

 #ef remove(self, column):
 #""Dictionary remove() is not implemented for
 #class:`_sql.ColumnCollection`."""
 #aise NotImplementedError()

 #ef update(self, iter_):
 #""Dictionary update() is not implemented for
 #class:`_sql.ColumnCollection`."""
 #aise NotImplementedError()

 #_hash__ = None

 #ef _populate_separate_keys(self, iter_):
 #""populate from an iterator of (key, column)"""
 #ols = list(iter_)
 #elf._collection[:] = cols
 #elf._colset.update(c for k, c in self._collection)
 #elf._index.update(
 #idx, c) for idx, (k, c) in enumerate(self._collection)
 #
 #elf._index.update({k: col for k, col in reversed(self._collection)})

 #ef add(self, column, key=None):
 #""Add a column to this :class:`_sql.ColumnCollection`.

 #. note::

 #his method is **not normally used by user-facing code**, as the
 #class:`_sql.ColumnCollection` is usually part of an existing
 #bject such as a :class:`_schema.Table`. To add a
 #class:`_schema.Column` to an existing :class:`_schema.Table`
 #bject, use the :meth:`_schema.Table.append_column` method.

 #""
 #f key is None:
 #ey = column.key

 # = len(self._collection)
 #elf._collection.append((key, column))
 #elf._colset.add(column)
 #elf._index[l] = column
 #f key not in self._index:
 #elf._index[key] = column

 #ef __getstate__(self):
 #eturn {"_collection": self._collection, "_index": self._index}

 #ef __setstate__(self, state):
 #bject.__setattr__(self, "_index", state["_index"])
 #bject.__setattr__(self, "_collection", state["_collection"])
 #bject.__setattr__(
 #elf, "_colset", {col for k, col in self._collection}
 #

 #ef contains_column(self, col):
 #""Checks if a column object exists in this collection"""
 #f col not in self._colset:
 #f isinstance(col, util.string_types):
 #aise exc.ArgumentError(
 #contains_column cannot be used with string arguments. "
 #Use ``col_name in table.c`` instead."
 #
 #eturn False
 #lse:
 #eturn True

 #ef as_immutable(self):
 #""Return an "immutable" form of this
 #class:`_sql.ColumnCollection`."""

 #eturn ImmutableColumnCollection(self)

 #ef corresponding_column(self, column, require_embedded=False):
 #""Given a :class:`_expression.ColumnElement`, return the exported
 #class:`_expression.ColumnElement` object from this
 #class:`_expression.ColumnCollection`
 #hich corresponds to that original :class:`_expression.ColumnElement`
 #ia a common
 #ncestor column.

 #param column: the target :class:`_expression.ColumnElement`
 #o be matched.

 #param require_embedded: only return corresponding columns for
 #he given :class:`_expression.ColumnElement`, if the given
 #class:`_expression.ColumnElement`
 #s actually present within a sub-element
 #f this :class:`_expression.Selectable`.
 #ormally the column will match if
 #t merely shares a common ancestor with one of the exported
 #olumns of this :class:`_expression.Selectable`.

 #. seealso::

 #meth:`_expression.Selectable.corresponding_column`
 # invokes this method
 #gainst the collection returned by
 #attr:`_expression.Selectable.exported_columns`.

 #. versionchanged:: 1.4 the implementation for ``corresponding_column``
 #as moved onto the :class:`_expression.ColumnCollection` itself.

 #""

 #ef embedded(expanded_proxy_set, target_set):
 #or t in target_set.difference(expanded_proxy_set):
 #f not set(_expand_cloned([t])).intersection(
 #xpanded_proxy_set
 #:
 #eturn False
 #eturn True

        # don't dig around if the column is locally present
 #f column in self._colset:
 #eturn column
 #ol, intersect = None, None
 #arget_set = column.proxy_set
 #ols = [c for (k, c) in self._collection]
 #or c in cols:
 #xpanded_proxy_set = set(_expand_cloned(c.proxy_set))
 # = target_set.intersection(expanded_proxy_set)
 #f i and (
 #ot require_embedded
 #r embedded(expanded_proxy_set, target_set)
 #:
 #f col is None:

                    # no corresponding column yet, pick this one.

 #ol, intersect = c, i
 #lif len(i) > len(intersect):

                    # 'c' has a larger field of correspondence than
                    # 'col'. i.e. selectable.c.a1_x->a1.c.x->table.c.x
                    # matches a1.c.x->table.c.x better than
                    # selectable.c.x->table.c.x does.

 #ol, intersect = c, i
 #lif i == intersect:
                    # they have the same field of correspondence. see
                    # which proxy_set has fewer columns in it, which
                    # indicates a closer relationship with the root
                    # column. Also take into account the "weight"
                    # attribute which CompoundSelect() uses to give
                    # higher precedence to columns based on vertical
                    # position in the compound statement, and discard
                    # columns that have no reference to the target
                    # column (also occurs with CompoundSelect)

 #ol_distance = util.reduce(
 #perator.add,
 #
 #c._annotations.get("weight", 1)
 #or sc in col._uncached_proxy_set()
 #f sc.shares_lineage(column)
 #,
 #
 #_distance = util.reduce(
 #perator.add,
 #
 #c._annotations.get("weight", 1)
 #or sc in c._uncached_proxy_set()
 #f sc.shares_lineage(column)
 #,
 #
 #f c_distance < col_distance:
 #ol, intersect = c, i
 #eturn col


class DedupeColumnCollection(ColumnCollection):
 #""A :class:`_expression.ColumnCollection`
 #hat maintains deduplicating behavior.

 #his is useful by schema level objects such as :class:`_schema.Table` and
 #class:`.PrimaryKeyConstraint`.    The collection includes more
 #ophisticated mutator methods as well to suit schema objects which
 #equire mutable column collections.

 #. versionadded:: 1.4

 #""

 #ef add(self, column, key=None):

 #f key is not None and column.key != key:
 #aise exc.ArgumentError(
 #DedupeColumnCollection requires columns be under "
 #the same key as their .key"
 #
 #ey = column.key

 #f key is None:
 #aise exc.ArgumentError(
 #Can't add unnamed column to column collection"
 #

 #f key in self._index:

 #xisting = self._index[key]

 #f existing is column:
 #eturn

 #elf.replace(column)

            # pop out memoized proxy_set as this
            # operation may very well be occurring
            # in a _make_proxy operation
 #til.memoized_property.reset(column, "proxy_set")
 #lse:
 # = len(self._collection)
 #elf._collection.append((key, column))
 #elf._colset.add(column)
 #elf._index[l] = column
 #elf._index[key] = column

 #ef _populate_separate_keys(self, iter_):
 #""populate from an iterator of (key, column)"""
 #ols = list(iter_)

 #eplace_col = []
 #or k, col in cols:
 #f col.key != k:
 #aise exc.ArgumentError(
 #DedupeColumnCollection requires columns be under "
 #the same key as their .key"
 #
 #f col.name in self._index and col.key != col.name:
 #eplace_col.append(col)
 #lif col.key in self._index:
 #eplace_col.append(col)
 #lse:
 #elf._index[k] = col
 #elf._collection.append((k, col))
 #elf._colset.update(c for (k, c) in self._collection)
 #elf._index.update(
 #idx, c) for idx, (k, c) in enumerate(self._collection)
 #
 #or col in replace_col:
 #elf.replace(col)

 #ef extend(self, iter_):
 #elf._populate_separate_keys((col.key, col) for col in iter_)

 #ef remove(self, column):
 #f column not in self._colset:
 #aise ValueError(
 #Can't remove column %r; column is not in this collection"
 # column
 #
 #el self._index[column.key]
 #elf._colset.remove(column)
 #elf._collection[:] = [
 #k, c) for (k, c) in self._collection if c is not column
 #
 #elf._index.update(
 #idx: col for idx, (k, col) in enumerate(self._collection)}
 #
        # delete higher index
 #el self._index[len(self._collection)]

 #ef replace(self, column):
 #""add the given column to this collection, removing unaliased
 #ersions of this column  as well as existing columns with the
 #ame key.

 #.g.::

 # = Table('sometable', metadata, Column('col1', Integer))
 #.columns.replace(Column('col1', Integer, key='columnone'))

 #ill remove the original 'col1' from the collection, and add
 #he new column under the name 'columnname'.

 #sed by schema.Column to override columns during table reflection.

 #""

 #emove_col = set()
        # remove up to two columns based on matches of name as well as key
 #f column.name in self._index and column.key != column.name:
 #ther = self._index[column.name]
 #f other.name == other.key:
 #emove_col.add(other)

 #f column.key in self._index:
 #emove_col.add(self._index[column.key])

 #ew_cols = []
 #eplaced = False
 #or k, col in self._collection:
 #f col in remove_col:
 #f not replaced:
 #eplaced = True
 #ew_cols.append((column.key, column))
 #lse:
 #ew_cols.append((k, col))

 #f remove_col:
 #elf._colset.difference_update(remove_col)

 #f not replaced:
 #ew_cols.append((column.key, column))

 #elf._colset.add(column)
 #elf._collection[:] = new_cols

 #elf._index.clear()
 #elf._index.update(
 #idx: col for idx, (k, col) in enumerate(self._collection)}
 #
 #elf._index.update(self._collection)


class ImmutableColumnCollection(util.ImmutableContainer, ColumnCollection):
 #_slots__ = ("_parent",)

 #ef __init__(self, collection):
 #bject.__setattr__(self, "_parent", collection)
 #bject.__setattr__(self, "_colset", collection._colset)
 #bject.__setattr__(self, "_index", collection._index)
 #bject.__setattr__(self, "_collection", collection._collection)

 #ef __getstate__(self):
 #eturn {"_parent": self._parent}

 #ef __setstate__(self, state):
 #arent = state["_parent"]
 #elf.__init__(parent)

 #dd = extend = remove = util.ImmutableContainer._immutable


class ColumnSet(util.ordered_column_set):
 #ef contains_column(self, col):
 #eturn col in self

 #ef extend(self, cols):
 #or col in cols:
 #elf.add(col)

 #ef __add__(self, other):
 #eturn list(self) + list(other)

 #ef __eq__(self, other):
 # = []
 #or c in other:
 #or local in self:
 #f c.shares_lineage(local):
 #.append(c == local)
 #eturn elements.and_(*l)

 #ef __hash__(self):
 #eturn hash(tuple(x for x in self))


def _bind_or_error(schemaitem, msg=None):

 #til.warn_deprecated_20(
 #The ``bind`` argument for schema methods that invoke SQL "
 #against an engine or connection will be required in SQLAlchemy 2.0."
 #
 #ind = schemaitem.bind
 #f not bind:
 #ame = schemaitem.__class__.__name__
 #abel = getattr(
 #chemaitem, "fullname", getattr(schemaitem, "name", None)
 #
 #f label:
 #tem = "%s object %r" % (name, label)
 #lse:
 #tem = "%s object" % name
 #f msg is None:
 #sg = (
 #%s is not bound to an Engine or Connection.  "
 #Execution can not proceed without a database to execute "
 #against." % item
 #
 #aise exc.UnboundExecutionError(msg)
 #eturn bind


def _entity_namespace(entity):
 #""Return the nearest .entity_namespace for the given entity.

 #f not immediately available, does an iterate to find a sub-element
 #hat has one, if any.

 #""
 #ry:
 #eturn entity.entity_namespace
 #xcept AttributeError:
 #or elem in visitors.iterate(entity):
 #f hasattr(elem, "entity_namespace"):
 #eturn elem.entity_namespace
 #lse:
 #aise


def _entity_namespace_key(entity, key):
 #""Return an entry from an entity_namespace.


 #aises :class:`_exc.InvalidRequestError` rather than attribute error
 #n not found.

 #""

 #ry:
 #s = _entity_namespace(entity)
 #eturn getattr(ns, key)
 #xcept AttributeError as err:
 #til.raise_(
 #xc.InvalidRequestError(
 #Entity namespace for "%s" has no property "%s"'
 # (entity, key)
 #,
 #eplace_context=err,
 #
