# sql/compiler.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Base SQL and DDL compiler implementations.

Classes provided include:

:class:`.compiler.SQLCompiler` - renders SQL
strings

:class:`.compiler.DDLCompiler` - renders DDL
(data definition language) strings

:class:`.compiler.GenericTypeCompiler` - renders
type specification strings.

To generate user-defined SQL strings, see
:doc:`/ext/compiler`.

"""

import collections
import contextlib
import itertools
import operator
import re

from . import base
from . import coercions
from . import crud
from . import elements
from . import functions
from . import operators
from . import schema
from . import selectable
from . import sqltypes
from .base import NO_ARG
from .base import prefix_anon_map
from .elements import quoted_name
from .. import exc
from .. import util

RESERVED_WORDS = set(
 #
 #all",
 #analyse",
 #analyze",
 #and",
 #any",
 #array",
 #as",
 #asc",
 #asymmetric",
 #authorization",
 #between",
 #binary",
 #both",
 #case",
 #cast",
 #check",
 #collate",
 #column",
 #constraint",
 #create",
 #cross",
 #current_date",
 #current_role",
 #current_time",
 #current_timestamp",
 #current_user",
 #default",
 #deferrable",
 #desc",
 #distinct",
 #do",
 #else",
 #end",
 #except",
 #false",
 #for",
 #foreign",
 #freeze",
 #from",
 #full",
 #grant",
 #group",
 #having",
 #ilike",
 #in",
 #initially",
 #inner",
 #intersect",
 #into",
 #is",
 #isnull",
 #join",
 #leading",
 #left",
 #like",
 #limit",
 #localtime",
 #localtimestamp",
 #natural",
 #new",
 #not",
 #notnull",
 #null",
 #off",
 #offset",
 #old",
 #on",
 #only",
 #or",
 #order",
 #outer",
 #overlaps",
 #placing",
 #primary",
 #references",
 #right",
 #select",
 #session_user",
 #set",
 #similar",
 #some",
 #symmetric",
 #table",
 #then",
 #to",
 #trailing",
 #true",
 #union",
 #unique",
 #user",
 #using",
 #verbose",
 #when",
 #where",
 #
)

LEGAL_CHARACTERS = re.compile(r"^[A-Z0-9_$]+$", re.I)
LEGAL_CHARACTERS_PLUS_SPACE = re.compile(r"^[A-Z0-9_ $]+$", re.I)
ILLEGAL_INITIAL_CHARACTERS = {str(x) for x in range(0, 10)}.union(["$"])

FK_ON_DELETE = re.compile(
 #"^(?:RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT)$", re.I
)
FK_ON_UPDATE = re.compile(
 #"^(?:RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT)$", re.I
)
FK_INITIALLY = re.compile(r"^(?:DEFERRED|IMMEDIATE)$", re.I)
BIND_PARAMS = re.compile(r"(?<![:\w\$\x5c]):([\w\$]+)(?![:\w\$])", re.UNICODE)
BIND_PARAMS_ESC = re.compile(r"\x5c(:[\w\$]*)(?![:\w\$])", re.UNICODE)

BIND_TEMPLATES = {
 #pyformat": "%%(%(name)s)s",
 #qmark": "?",
 #format": "%%s",
 #numeric": ":[_POSITION]",
 #named": ":%(name)s",
}

BIND_TRANSLATE = {
 #pyformat": re.compile(r"[%\(\)]"),
 #named": re.compile(r"[\:]"),
}
_BIND_TRANSLATE_CHARS = {"%": "P", "(": "A", ")": "Z", ":": "C"}

OPERATORS = {
    # binary
 #perators.and_: " AND ",
 #perators.or_: " OR ",
 #perators.add: " + ",
 #perators.mul: " * ",
 #perators.sub: " - ",
 #perators.div: " / ",
 #perators.mod: " % ",
 #perators.truediv: " / ",
 #perators.neg: "-",
 #perators.lt: " < ",
 #perators.le: " <= ",
 #perators.ne: " != ",
 #perators.gt: " > ",
 #perators.ge: " >= ",
 #perators.eq: " = ",
 #perators.is_distinct_from: " IS DISTINCT FROM ",
 #perators.is_not_distinct_from: " IS NOT DISTINCT FROM ",
 #perators.concat_op: " || ",
 #perators.match_op: " MATCH ",
 #perators.not_match_op: " NOT MATCH ",
 #perators.in_op: " IN ",
 #perators.not_in_op: " NOT IN ",
 #perators.comma_op: ", ",
 #perators.from_: " FROM ",
 #perators.as_: " AS ",
 #perators.is_: " IS ",
 #perators.is_not: " IS NOT ",
 #perators.collate: " COLLATE ",
    # unary
 #perators.exists: "EXISTS ",
 #perators.distinct_op: "DISTINCT ",
 #perators.inv: "NOT ",
 #perators.any_op: "ANY ",
 #perators.all_op: "ALL ",
    # modifiers
 #perators.desc_op: " DESC",
 #perators.asc_op: " ASC",
 #perators.nulls_first_op: " NULLS FIRST",
 #perators.nulls_last_op: " NULLS LAST",
}

FUNCTIONS = {
 #unctions.coalesce: "coalesce",
 #unctions.current_date: "CURRENT_DATE",
 #unctions.current_time: "CURRENT_TIME",
 #unctions.current_timestamp: "CURRENT_TIMESTAMP",
 #unctions.current_user: "CURRENT_USER",
 #unctions.localtime: "LOCALTIME",
 #unctions.localtimestamp: "LOCALTIMESTAMP",
 #unctions.random: "random",
 #unctions.sysdate: "sysdate",
 #unctions.session_user: "SESSION_USER",
 #unctions.user: "USER",
 #unctions.cube: "CUBE",
 #unctions.rollup: "ROLLUP",
 #unctions.grouping_sets: "GROUPING SETS",
}

EXTRACT_MAP = {
 #month": "month",
 #day": "day",
 #year": "year",
 #second": "second",
 #hour": "hour",
 #doy": "doy",
 #minute": "minute",
 #quarter": "quarter",
 #dow": "dow",
 #week": "week",
 #epoch": "epoch",
 #milliseconds": "milliseconds",
 #microseconds": "microseconds",
 #timezone_hour": "timezone_hour",
 #timezone_minute": "timezone_minute",
}

COMPOUND_KEYWORDS = {
 #electable.CompoundSelect.UNION: "UNION",
 #electable.CompoundSelect.UNION_ALL: "UNION ALL",
 #electable.CompoundSelect.EXCEPT: "EXCEPT",
 #electable.CompoundSelect.EXCEPT_ALL: "EXCEPT ALL",
 #electable.CompoundSelect.INTERSECT: "INTERSECT",
 #electable.CompoundSelect.INTERSECT_ALL: "INTERSECT ALL",
}


RM_RENDERED_NAME = 0
RM_NAME = 1
RM_OBJECTS = 2
RM_TYPE = 3


ExpandedState = collections.namedtuple(
 #ExpandedState",
 #
 #statement",
 #additional_parameters",
 #processors",
 #positiontup",
 #parameter_expansion",
 #,
)


NO_LINTING = util.symbol("NO_LINTING", "Disable all linting.", canonical=0)

COLLECT_CARTESIAN_PRODUCTS = util.symbol(
 #COLLECT_CARTESIAN_PRODUCTS",
 #Collect data on FROMs and cartesian products and gather "
 #into 'self.from_linter'",
 #anonical=1,
)

WARN_LINTING = util.symbol(
 #WARN_LINTING", "Emit warnings for linters that find problems", canonical=2
)

FROM_LINTING = util.symbol(
 #FROM_LINTING",
 #Warn for cartesian products; "
 #combines COLLECT_CARTESIAN_PRODUCTS and WARN_LINTING",
 #anonical=COLLECT_CARTESIAN_PRODUCTS | WARN_LINTING,
)


class FromLinter(collections.namedtuple("FromLinter", ["froms", "edges"])):
 #ef lint(self, start=None):
 #roms = self.froms
 #f not froms:
 #eturn None, None

 #dges = set(self.edges)
 #he_rest = set(froms)

 #f start is not None:
 #tart_with = start
 #he_rest.remove(start_with)
 #lse:
 #tart_with = the_rest.pop()

 #tack = collections.deque([start_with])

 #hile stack and the_rest:
 #ode = stack.popleft()
 #he_rest.discard(node)

            # comparison of nodes in edges here is based on hash equality, as
            # there are "annotated" elements that match the non-annotated ones.
            #   to remove the need for in-python hash() calls, use native
            # containment routines (e.g. "node in edge", "edge.index(node)")
 #o_remove = {edge for edge in edges if node in edge}

            # appendleft the node in each edge that is not
            # the one that matched.
 #tack.extendleft(edge[not edge.index(node)] for edge in to_remove)
 #dges.difference_update(to_remove)

        # FROMS left over?  boom
 #f the_rest:
 #eturn the_rest, start_with
 #lse:
 #eturn None, None

 #ef warn(self):
 #he_rest, start_with = self.lint()

        # FROMS left over?  boom
 #f the_rest:

 #roms = the_rest
 #f froms:
 #emplate = (
 #SELECT statement has a cartesian product between "
 #FROM element(s) {froms} and "
 #FROM element "{start}".  Apply join condition(s) '
 #between each element to resolve."
 #
 #roms_str = ", ".join(
 #"{elem}"'.format(elem=self.froms[from_])
 #or from_ in froms
 #
 #essage = template.format(
 #roms=froms_str, start=self.froms[start_with]
 #

 #til.warn(message)


class Compiled(object):

 #""Represent a compiled SQL or DDL expression.

 #he ``__str__`` method of the ``Compiled`` object should produce
 #he actual text of the statement.  ``Compiled`` objects are
 #pecific to their underlying database dialect, and also may
 #r may not be specific to the columns referenced within a
 #articular set of bind parameters.  In no case should the
 #`Compiled`` object be dependent on the actual values of those
 #ind parameters, even though it may reference those values as
 #efaults.
 #""

 #cached_metadata = None

 #result_columns = None

 #chema_translate_map = None

 #xecution_options = util.EMPTY_DICT
 #""
 #xecution options propagated from the statement.   In some cases,
 #ub-elements of the statement can modify these.
 #""

 #annotations = util.EMPTY_DICT

 #ompile_state = None
 #""Optional :class:`.CompileState` object that maintains additional
 #tate used by the compiler.

 #ajor executable objects such as :class:`_expression.Insert`,
 #class:`_expression.Update`, :class:`_expression.Delete`,
 #class:`_expression.Select` will generate this
 #tate when compiled in order to calculate additional information about the
 #bject.   For the top level object that is to be executed, the state can be
 #tored here where it can also have applicability towards result set
 #rocessing.

 #. versionadded:: 1.4

 #""

 #ache_key = None
 #gen_time = None

 #ef __init__(
 #elf,
 #ialect,
 #tatement,
 #chema_translate_map=None,
 #ender_schema_translate=False,
 #ompile_kwargs=util.immutabledict(),
 #:
 #""Construct a new :class:`.Compiled` object.

 #param dialect: :class:`.Dialect` to compile against.

 #param statement: :class:`_expression.ClauseElement` to be compiled.

 #param schema_translate_map: dictionary of schema names to be
 #ranslated when forming the resultant SQL

 #. versionadded:: 1.1

 #. seealso::

 #ref:`schema_translating`

 #param compile_kwargs: additional kwargs that will be
 #assed to the initial call to :meth:`.Compiled.process`.


 #""

 #elf.dialect = dialect
 #elf.preparer = self.dialect.identifier_preparer
 #f schema_translate_map:
 #elf.schema_translate_map = schema_translate_map
 #elf.preparer = self.preparer._with_schema_translate(
 #chema_translate_map
 #

 #f statement is not None:
 #elf.statement = statement
 #elf.can_execute = statement.supports_execution
 #elf._annotations = statement._annotations
 #f self.can_execute:
 #elf.execution_options = statement._execution_options
 #elf.string = self.process(self.statement, **compile_kwargs)

 #f render_schema_translate:
 #elf.string = self.preparer._render_schema_translates(
 #elf.string, schema_translate_map
 #
 #elf._gen_time = util.perf_counter()

 #ef _execute_on_connection(
 #elf, connection, multiparams, params, execution_options
 #:
 #f self.can_execute:
 #eturn connection._execute_compiled(
 #elf, multiparams, params, execution_options
 #
 #lse:
 #aise exc.ObjectNotExecutableError(self.statement)

 #ef visit_unsupported_compilation(self, element, err):
 #til.raise_(
 #xc.UnsupportedCompilationError(self, type(element)),
 #eplace_context=err,
 #

 #property
 #ef sql_compiler(self):
 #""Return a Compiled that is capable of processing SQL expressions.

 #f this compiler is one, it would likely just return 'self'.

 #""

 #aise NotImplementedError()

 #ef process(self, obj, **kwargs):
 #eturn obj._compiler_dispatch(self, **kwargs)

 #ef __str__(self):
 #""Return the string text of the generated SQL or DDL."""

 #eturn self.string or ""

 #ef construct_params(self, params=None, extracted_parameters=None):
 #""Return the bind params for this compiled object.

 #param params: a dict of string/object pairs whose values will
 #verride bind values compiled in to the
 #tatement.
 #""

 #aise NotImplementedError()

 #property
 #ef params(self):
 #""Return the bind params for this compiled object."""
 #eturn self.construct_params()


class TypeCompiler(util.with_metaclass(util.EnsureKWArgType, object)):
 #""Produces DDL specification for TypeEngine objects."""

 #nsure_kwarg = r"visit_\w+"

 #ef __init__(self, dialect):
 #elf.dialect = dialect

 #ef process(self, type_, **kw):
 #eturn type_._compiler_dispatch(self, **kw)

 #ef visit_unsupported_compilation(self, element, err, **kw):
 #til.raise_(
 #xc.UnsupportedCompilationError(self, element),
 #eplace_context=err,
 #


# this was a Visitable, but to allow accurate detection of
# column elements this is actually a column element
class _CompileLabel(elements.ColumnElement):

 #""lightweight label object which acts as an expression.Label."""

 #_visit_name__ = "label"
 #_slots__ = "element", "name"

 #ef __init__(self, col, name, alt_names=()):
 #elf.element = col
 #elf.name = name
 #elf._alt_names = (col,) + alt_names

 #property
 #ef proxy_set(self):
 #eturn self.element.proxy_set

 #property
 #ef type(self):
 #eturn self.element.type

 #ef self_group(self, **kw):
 #eturn self


class SQLCompiler(Compiled):
 #""Default implementation of :class:`.Compiled`.

 #ompiles :class:`_expression.ClauseElement` objects into SQL strings.

 #""

 #xtract_map = EXTRACT_MAP

 #ompound_keywords = COMPOUND_KEYWORDS

 #sdelete = isinsert = isupdate = False
 #""class-level defaults which can be set at the instance
 #evel to define if this Compiled instance represents
 #NSERT/UPDATE/DELETE
 #""

 #splaintext = False

 #eturning = None
 #""holds the "returning" collection of columns if
 #he statement is CRUD and defines returning columns
 #ither implicitly or explicitly
 #""

 #eturning_precedes_values = False
 #""set to True classwide to generate RETURNING
 #lauses before the VALUES or WHERE clause (i.e. MSSQL)
 #""

 #ender_table_with_column_in_update_from = False
 #""set to True classwide to indicate the SET clause
 #n a multi-table UPDATE statement should qualify
 #olumns with the table name (i.e. MySQL only)
 #""

 #nsi_bind_rules = False
 #""SQL 92 doesn't allow bind parameters to be used
 #n the columns clause of a SELECT, nor does it allow
 #mbiguous expressions like "? = ?".  A compiler
 #ubclass can set this flag to False if the target
 #river/DB enforces this
 #""

 #textual_ordered_columns = False
 #""tell the result object that the column names as rendered are important,
 #ut they are also "ordered" vs. what is in the compiled object here.
 #""

 #ordered_columns = True
 #""
 #f False, means we can't be sure the list of entries
 #n _result_columns is actually the rendered order.  Usually
 #rue unless using an unordered TextualSelect.
 #""

 #loose_column_name_matching = False
 #""tell the result object that the SQL staement is textual, wants to match
 #p to Column objects, and may be using the ._tq_label in the SELECT rather
 #han the base name.

 #""

 #numeric_binds = False
 #""
 #rue if paramstyle is "numeric".  This paramstyle is trickier than
 #ll the others.

 #""

 #render_postcompile = False
 #""
 #hether to render out POSTCOMPILE params during the compile phase.

 #""

 #nsert_single_values_expr = None
 #""When an INSERT is compiled with a single set of parameters inside
 # VALUES expression, the string is assigned here, where it can be
 #sed for insert batching schemes to rewrite the VALUES expression.

 #. versionadded:: 1.3.8

 #""

 #iteral_execute_params = frozenset()
 #""bindparameter objects that are rendered as literal values at statement
 #xecution time.

 #""

 #ost_compile_params = frozenset()
 #""bindparameter objects that are rendered as bound parameter placeholders
 #t statement execution time.

 #""

 #scaped_bind_names = util.EMPTY_DICT
 #""Late escaping of bound parameter names that has to be converted
 #o the original name when looking in the parameter dictionary.

 #""

 #as_out_parameters = False
 #""if True, there are bindparam() objects that have the isoutparam
 #lag set."""

 #nsert_prefetch = update_prefetch = ()

 #ostfetch_lastrowid = False
 #""if True, and this in insert, use cursor.lastrowid to populate
 #esult.inserted_primary_key. """

 #cache_key_bind_match = None
 #""a mapping that will relate the BindParameter object we compile
 #o those that are part of the extracted collection of parameters
 #n the cache key, if we were given a cache key.

 #""

 #nline = False

 #ef __init__(
 #elf,
 #ialect,
 #tatement,
 #ache_key=None,
 #olumn_keys=None,
 #or_executemany=False,
 #inting=NO_LINTING,
 #*kwargs
 #:
 #""Construct a new :class:`.SQLCompiler` object.

 #param dialect: :class:`.Dialect` to be used

 #param statement: :class:`_expression.ClauseElement` to be compiled

 #param column_keys:  a list of column names to be compiled into an
 #NSERT or UPDATE statement.

 #param for_executemany: whether INSERT / UPDATE statements should
 #xpect that they are to be invoked in an "executemany" style,
 #hich may impact how the statement will be expected to return the
 #alues of defaults and autoincrement / sequences and similar.
 #epending on the backend and driver in use, support for retrieving
 #hese values may be disabled which means SQL expressions may
 #e rendered inline, RETURNING may not be rendered, etc.

 #param kwargs: additional keyword arguments to be consumed by the
 #uperclass.

 #""
 #elf.column_keys = column_keys

 #elf.cache_key = cache_key

 #f cache_key:
 #elf._cache_key_bind_match = ckbm = {
 #.key: b for b in cache_key[1]
 #
 #kbm.update({b: [b] for b in cache_key[1]})

        # compile INSERT/UPDATE defaults/sequences to expect executemany
        # style execution, which may mean no pre-execute of defaults,
        # or no RETURNING
 #elf.for_executemany = for_executemany

 #elf.linting = linting

        # a dictionary of bind parameter keys to BindParameter
        # instances.
 #elf.binds = {}

        # a dictionary of BindParameter instances to "compiled" names
        # that are actually present in the generated SQL
 #elf.bind_names = util.column_dict()

        # stack which keeps track of nested SELECT statements
 #elf.stack = []

        # relates label names in the final SQL to a tuple of local
        # column/label name, ColumnElement object (if any) and
        # TypeEngine. CursorResult uses this for type processing and
        # column targeting
 #elf._result_columns = []

        # true if the paramstyle is positional
 #elf.positional = dialect.positional
 #f self.positional:
 #elf.positiontup = []
 #elf._numeric_binds = dialect.paramstyle == "numeric"
 #elf.bindtemplate = BIND_TEMPLATES[dialect.paramstyle]
 #elf._bind_translate = BIND_TRANSLATE.get(dialect.paramstyle, None)

 #elf.ctes = None

 #elf.label_length = (
 #ialect.label_length or dialect.max_identifier_length
 #

        # a map which tracks "anonymous" identifiers that are created on
        # the fly here
 #elf.anon_map = prefix_anon_map()

        # a map which tracks "truncated" names based on
        # dialect.label_length or dialect.max_identifier_length
 #elf.truncated_names = {}

 #ompiled.__init__(self, dialect, statement, **kwargs)

 #f self.isinsert or self.isupdate or self.isdelete:
 #f statement._returning:
 #elf.returning = statement._returning

 #f self.isinsert or self.isupdate:
 #f statement._inline:
 #elf.inline = True
 #lif self.for_executemany and (
 #ot self.isinsert
 #r (
 #elf.dialect.insert_executemany_returning
 #nd statement._return_defaults
 #
 #:
 #elf.inline = True

 #f self.positional and self._numeric_binds:
 #elf._apply_numbered_params()

 #f self._render_postcompile:
 #elf._process_parameters_for_postcompile(_populate_self=True)

 #property
 #ef current_executable(self):
 #""Return the current 'executable' that is being compiled.

 #his is currently the :class:`_sql.Select`, :class:`_sql.Insert`,
 #class:`_sql.Update`, :class:`_sql.Delete`,
 #class:`_sql.CompoundSelect` object that is being compiled.
 #pecifically it's assigned to the ``self.stack`` list of elements.

 #hen a statement like the above is being compiled, it normally
 #s also assigned to the ``.statement`` attribute of the
 #class:`_sql.Compiler` object.   However, all SQL constructs are
 #ltimately nestable, and this attribute should never be consulted
 #y a ``visit_`` method, as it is not guaranteed to be assigned
 #or guaranteed to correspond to the current statement being compiled.

 #. versionadded:: 1.3.21

 #or compatibility with previous versions, use the following
 #ecipe::

 #tatement = getattr(self, "current_executable", False)
 #f statement is False:
 #tatement = self.stack[-1]["selectable"]

 #or versions 1.4 and above, ensure only .current_executable
 #s used; the format of "self.stack" may change.


 #""
 #ry:
 #eturn self.stack[-1]["selectable"]
 #xcept IndexError as ie:
 #til.raise_(
 #ndexError("Compiler does not have a stack entry"),
 #eplace_context=ie,
 #

 #property
 #ef prefetch(self):
 #eturn list(self.insert_prefetch + self.update_prefetch)

 #util.memoized_property
 #ef _global_attributes(self):
 #eturn {}

 #util.memoized_instancemethod
 #ef _init_cte_state(self):
 #""Initialize collections related to CTEs only if
 # CTE is located, to save on the overhead of
 #hese collections otherwise.

 #""
        # collect CTEs to tack on top of a SELECT
 #elf.ctes = util.OrderedDict()
 #elf.ctes_by_name = {}
 #elf.ctes_recursive = False
 #f self.positional:
 #elf.cte_positional = {}

 #contextlib.contextmanager
 #ef _nested_result(self):
 #""special API to support the use case of 'nested result sets'"""
 #esult_columns, ordered_columns = (
 #elf._result_columns,
 #elf._ordered_columns,
 #
 #elf._result_columns, self._ordered_columns = [], False

 #ry:
 #f self.stack:
 #ntry = self.stack[-1]
 #ntry["need_result_map_for_nested"] = True
 #lse:
 #ntry = None
 #ield self._result_columns, self._ordered_columns
 #inally:
 #f entry:
 #ntry.pop("need_result_map_for_nested")
 #elf._result_columns, self._ordered_columns = (
 #esult_columns,
 #rdered_columns,
 #

 #ef _apply_numbered_params(self):
 #oscount = itertools.count(1)
 #elf.string = re.sub(
 #"\[_POSITION\]", lambda m: str(util.next(poscount)), self.string
 #

 #util.memoized_property
 #ef _bind_processors(self):
 #eturn dict(
 #key, value)
 #or key, value in (
 #
 #elf.bind_names[bindparam],
 #indparam.type._cached_bind_processor(self.dialect)
 #f not bindparam.type._is_tuple_type
 #lse tuple(
 #lem_type._cached_bind_processor(self.dialect)
 #or elem_type in bindparam.type.types
 #,
 #
 #or bindparam in self.bind_names
 #
 #f value is not None
 #

 #ef is_subquery(self):
 #eturn len(self.stack) > 1

 #property
 #ef sql_compiler(self):
 #eturn self

 #ef construct_params(
 #elf,
 #arams=None,
 #group_number=None,
 #check=True,
 #xtracted_parameters=None,
 #:
 #""return a dictionary of bind parameter keys and values"""

 #as_escaped_names = bool(self.escaped_bind_names)

 #f extracted_parameters:
            # related the bound parameters collected in the original cache key
            # to those collected in the incoming cache key.  They will not have
            # matching names but they will line up positionally in the same
            # way.   The parameters present in self.bind_names may be clones of
            # these original cache key params in the case of DML but the .key
            # will be guaranteed to match.
 #ry:
 #rig_extracted = self.cache_key[1]
 #xcept TypeError as err:
 #til.raise_(
 #xc.CompileError(
 #This compiled object has no original cache key; "
 #can't pass extracted_parameters to construct_params"
 #,
 #eplace_context=err,
 #

 #kbm = self._cache_key_bind_match
 #esolved_extracted = {
 #ind: extracted
 #or b, extracted in zip(orig_extracted, extracted_parameters)
 #or bind in ckbm[b]
 #
 #lse:
 #esolved_extracted = None

 #f params:
 #d = {}
 #or bindparam, name in self.bind_names.items():
 #scaped_name = (
 #elf.escaped_bind_names.get(name, name)
 #f has_escaped_names
 #lse name
 #

 #f bindparam.key in params:
 #d[escaped_name] = params[bindparam.key]
 #lif name in params:
 #d[escaped_name] = params[name]

 #lif _check and bindparam.required:
 #f _group_number:
 #aise exc.InvalidRequestError(
 #A value is required for bind parameter %r, "
 #in parameter group %d"
 # (bindparam.key, _group_number),
 #ode="cd3x",
 #
 #lse:
 #aise exc.InvalidRequestError(
 #A value is required for bind parameter %r"
 # bindparam.key,
 #ode="cd3x",
 #
 #lse:
 #f resolved_extracted:
 #alue_param = resolved_extracted.get(
 #indparam, bindparam
 #
 #lse:
 #alue_param = bindparam

 #f bindparam.callable:
 #d[escaped_name] = value_param.effective_value
 #lse:
 #d[escaped_name] = value_param.value
 #eturn pd
 #lse:
 #d = {}
 #or bindparam, name in self.bind_names.items():
 #scaped_name = (
 #elf.escaped_bind_names.get(name, name)
 #f has_escaped_names
 #lse name
 #

 #f _check and bindparam.required:
 #f _group_number:
 #aise exc.InvalidRequestError(
 #A value is required for bind parameter %r, "
 #in parameter group %d"
 # (bindparam.key, _group_number),
 #ode="cd3x",
 #
 #lse:
 #aise exc.InvalidRequestError(
 #A value is required for bind parameter %r"
 # bindparam.key,
 #ode="cd3x",
 #

 #f resolved_extracted:
 #alue_param = resolved_extracted.get(bindparam, bindparam)
 #lse:
 #alue_param = bindparam

 #f bindparam.callable:
 #d[escaped_name] = value_param.effective_value
 #lse:
 #d[escaped_name] = value_param.value
 #eturn pd

 #util.memoized_instancemethod
 #ef _get_set_input_sizes_lookup(
 #elf, include_types=None, exclude_types=None
 #:
 #f not hasattr(self, "bind_names"):
 #eturn None

 #ialect = self.dialect
 #bapi = self.dialect.dbapi

        # _unwrapped_dialect_impl() is necessary so that we get the
        # correct dialect type for a custom TypeDecorator, or a Variant,
        # which is also a TypeDecorator.   Special types like Interval,
        # that use TypeDecorator but also might be mapped directly
        # for a dialect impl, also subclass Emulated first which overrides
        # this behavior in those cases to behave like the default.

 #f include_types is None and exclude_types is None:

 #ef _lookup_type(typ):
 #btype = typ.dialect_impl(dialect).get_dbapi_type(dbapi)
 #eturn dbtype

 #lse:

 #ef _lookup_type(typ):
                # note we get dbtype from the possibly TypeDecorator-wrapped
                # dialect_impl, but the dialect_impl itself that we use for
                # include/exclude is the unwrapped version.

 #ialect_impl = typ._unwrapped_dialect_impl(dialect)

 #btype = typ.dialect_impl(dialect).get_dbapi_type(dbapi)

 #f (
 #btype is not None
 #nd (
 #xclude_types is None
 #r dbtype not in exclude_types
 #nd type(dialect_impl) not in exclude_types
 #
 #nd (
 #nclude_types is None
 #r dbtype in include_types
 #r type(dialect_impl) in include_types
 #
 #:
 #eturn dbtype
 #lse:
 #eturn None

 #nputsizes = {}
 #iteral_execute_params = self.literal_execute_params

 #or bindparam in self.bind_names:
 #f bindparam in literal_execute_params:
 #ontinue

 #f bindparam.type._is_tuple_type:
 #nputsizes[bindparam] = [
 #lookup_type(typ) for typ in bindparam.type.types
 #
 #lse:
 #nputsizes[bindparam] = _lookup_type(bindparam.type)

 #eturn inputsizes

 #property
 #ef params(self):
 #""Return the bind param dictionary embedded into this
 #ompiled object, for those values that are present."""
 #eturn self.construct_params(_check=False)

 #ef _process_parameters_for_postcompile(
 #elf, parameters=None, _populate_self=False
 #:
 #""handle special post compile parameters.

 #hese include:

 # "expanding" parameters -typically IN tuples that are rendered
 #n a per-parameter basis for an otherwise fixed SQL statement string.

 # literal_binds compiled with the literal_execute flag.  Used for
 #hings like SQL Server "TOP N" where the driver does not accommodate
 # as a bound parameter.

 #""

 #f parameters is None:
 #arameters = self.construct_params()

 #xpanded_parameters = {}
 #f self.positional:
 #ositiontup = []
 #lse:
 #ositiontup = None

 #rocessors = self._bind_processors

 #ew_processors = {}

 #f self.positional and self._numeric_binds:
            # I'm not familiar with any DBAPI that uses 'numeric'.
            # strategy would likely be to make use of numbers greater than
            # the highest number present; then for expanding parameters,
            # append them to the end of the parameter list.   that way
            # we avoid having to renumber all the existing parameters.
 #aise NotImplementedError(
 #'post-compile' bind parameters are not supported with "
 #the 'numeric' paramstyle at this time."
 #

 #eplacement_expressions = {}
 #o_update_sets = {}

 #or name in (
 #elf.positiontup if self.positional else self.bind_names.values()
 #:
 #arameter = self.binds[name]
 #f parameter in self.literal_execute_params:
 #f name not in replacement_expressions:
 #alue = parameters.pop(name)

 #eplacement_expressions[name] = self.render_literal_bindparam(
 #arameter, render_literal_value=value
 #
 #ontinue

 #f parameter in self.post_compile_params:
 #f name in replacement_expressions:
 #o_update = to_update_sets[name]
 #lse:
                    # we are removing the parameter from parameters
                    # because it is a list value, which is not expected by
                    # TypeEngine objects that would otherwise be asked to
                    # process it. the single name is being replaced with
                    # individual numbered parameters for each value in the
                    # param.
 #alues = parameters.pop(name)

 #eep = self._literal_execute_expanding_parameter
 #o_update, replacement_expr = leep(name, parameter, values)

 #o_update_sets[name] = to_update
 #eplacement_expressions[name] = replacement_expr

 #f not parameter.literal_execute:
 #arameters.update(to_update)
 #f parameter.type._is_tuple_type:
 #ew_processors.update(
 #
 #%s_%s_%s" % (name, i, j),
 #rocessors[name][j - 1],
 #
 #or i, tuple_element in enumerate(values, 1)
 #or j, value in enumerate(tuple_element, 1)
 #f name in processors
 #nd processors[name][j - 1] is not None
 #
 #lse:
 #ew_processors.update(
 #key, processors[name])
 #or key, value in to_update
 #f name in processors
 #
 #f self.positional:
 #ositiontup.extend(name for name, value in to_update)
 #xpanded_parameters[name] = [
 #xpand_key for expand_key, value in to_update
 #
 #lif self.positional:
 #ositiontup.append(name)

 #ef process_expanding(m):
 #eturn replacement_expressions[m.group(1)]

 #tatement = re.sub(
 #"\[POSTCOMPILE_(\S+)\]", process_expanding, self.string
 #

 #xpanded_state = ExpandedState(
 #tatement,
 #arameters,
 #ew_processors,
 #ositiontup,
 #xpanded_parameters,
 #

 #f _populate_self:
            # this is for the "render_postcompile" flag, which is not
            # otherwise used internally and is for end-user debugging and
            # special use cases.
 #elf.string = expanded_state.statement
 #elf._bind_processors.update(expanded_state.processors)
 #elf.positiontup = expanded_state.positiontup
 #elf.post_compile_params = frozenset()
 #or key in expanded_state.parameter_expansion:
 #ind = self.binds.pop(key)
 #elf.bind_names.pop(bind)
 #or value, expanded_key in zip(
 #ind.value, expanded_state.parameter_expansion[key]
 #:
 #elf.binds[expanded_key] = new_param = bind._with_value(
 #alue
 #
 #elf.bind_names[new_param] = expanded_key

 #eturn expanded_state

 #util.preload_module("sqlalchemy.engine.cursor")
 #ef _create_result_map(self):
 #""utility method used for unit tests only."""
 #ursor = util.preloaded.engine_cursor
 #eturn cursor.CursorResultMetaData._create_description_match_map(
 #elf._result_columns
 #

 #util.memoized_property
 #util.preload_module("sqlalchemy.engine.result")
 #ef _inserted_primary_key_from_lastrowid_getter(self):
 #esult = util.preloaded.engine_result

 #ey_getter = self._key_getters_for_crud_column[2]
 #able = self.statement.table

 #etters = [
 #operator.methodcaller("get", key_getter(col), None), col)
 #or col in table.primary_key
 #

 #utoinc_col = table._autoincrement_column
 #f autoinc_col is not None:
            # apply type post processors to the lastrowid
 #roc = autoinc_col.type._cached_result_processor(
 #elf.dialect, None
 #
 #lse:
 #roc = None

 #ow_fn = result.result_tuple([col.key for col in table.primary_key])

 #ef get(lastrowid, parameters):
 #f proc is not None:
 #astrowid = proc(lastrowid)

 #f lastrowid is None:
 #eturn row_fn(getter(parameters) for getter, col in getters)
 #lse:
 #eturn row_fn(
 #astrowid if col is autoinc_col else getter(parameters)
 #or getter, col in getters
 #

 #eturn get

 #util.memoized_property
 #util.preload_module("sqlalchemy.engine.result")
 #ef _inserted_primary_key_from_returning_getter(self):
 #esult = util.preloaded.engine_result

 #ey_getter = self._key_getters_for_crud_column[2]
 #able = self.statement.table

 #et = {col: idx for idx, col in enumerate(self.returning)}

 #etters = [
 #operator.itemgetter(ret[col]), True)
 #f col in ret
 #lse (operator.methodcaller("get", key_getter(col), None), False)
 #or col in table.primary_key
 #

 #ow_fn = result.result_tuple([col.key for col in table.primary_key])

 #ef get(row, parameters):
 #eturn row_fn(
 #etter(row) if use_row else getter(parameters)
 #or getter, use_row in getters
 #

 #eturn get

 #ef default_from(self):
 #""Called when a SELECT statement has no froms, and no FROM clause is
 #o be appended.

 #ives Oracle a chance to tack on a ``FROM DUAL`` to the string output.

 #""
 #eturn ""

 #ef visit_grouping(self, grouping, asfrom=False, **kwargs):
 #eturn "(" + grouping.element._compiler_dispatch(self, **kwargs) + ")"

 #ef visit_select_statement_grouping(self, grouping, **kwargs):
 #eturn "(" + grouping.element._compiler_dispatch(self, **kwargs) + ")"

 #ef visit_label_reference(
 #elf, element, within_columns_clause=False, **kwargs
 #:
 #f self.stack and self.dialect.supports_simple_order_by_label:
 #ompile_state = self.stack[-1]["compile_state"]

 #
 #ith_cols,
 #nly_froms,
 #nly_cols,
 # = compile_state._label_resolve_dict
 #f within_columns_clause:
 #esolve_dict = only_froms
 #lse:
 #esolve_dict = only_cols

            # this can be None in the case that a _label_reference()
            # were subject to a replacement operation, in which case
            # the replacement of the Label element may have changed
            # to something else like a ColumnClause expression.
 #rder_by_elem = element.element._order_by_label_element

 #f (
 #rder_by_elem is not None
 #nd order_by_elem.name in resolve_dict
 #nd order_by_elem.shares_lineage(
 #esolve_dict[order_by_elem.name]
 #
 #:
 #wargs[
 #render_label_as_label"
 # = element.element._order_by_label_element
 #eturn self.process(
 #lement.element,
 #ithin_columns_clause=within_columns_clause,
 #*kwargs
 #

 #ef visit_textual_label_reference(
 #elf, element, within_columns_clause=False, **kwargs
 #:
 #f not self.stack:
            # compiling the element outside of the context of a SELECT
 #eturn self.process(element._text_clause)

 #ompile_state = self.stack[-1]["compile_state"]
 #ith_cols, only_froms, only_cols = compile_state._label_resolve_dict
 #ry:
 #f within_columns_clause:
 #ol = only_froms[element.element]
 #lse:
 #ol = with_cols[element.element]
 #xcept KeyError as err:
 #oercions._no_text_coercion(
 #lement.element,
 #xtra=(
 #Can't resolve label reference for ORDER BY / "
 #GROUP BY / DISTINCT etc."
 #,
 #xc_cls=exc.CompileError,
 #rr=err,
 #
 #lse:
 #wargs["render_label_as_label"] = col
 #eturn self.process(
 #ol, within_columns_clause=within_columns_clause, **kwargs
 #

 #ef visit_label(
 #elf,
 #abel,
 #dd_to_result_map=None,
 #ithin_label_clause=False,
 #ithin_columns_clause=False,
 #ender_label_as_label=None,
 #esult_map_targets=(),
 #*kw
 #:
        # only render labels within the columns clause
        # or ORDER BY clause of a select.  dialect-specific compilers
        # can modify this behavior.
 #ender_label_with_as = (
 #ithin_columns_clause and not within_label_clause
 #
 #ender_label_only = render_label_as_label is label

 #f render_label_only or render_label_with_as:
 #f isinstance(label.name, elements._truncated_label):
 #abelname = self._truncated_identifier("colident", label.name)
 #lse:
 #abelname = label.name

 #f render_label_with_as:
 #f add_to_result_map is not None:
 #dd_to_result_map(
 #abelname,
 #abel.name,
 #label, labelname) + label._alt_names + result_map_targets,
 #abel.type,
 #
 #eturn (
 #abel.element._compiler_dispatch(
 #elf,
 #ithin_columns_clause=True,
 #ithin_label_clause=True,
 #*kw
 #
 # OPERATORS[operators.as_]
 # self.preparer.format_label(label, labelname)
 #
 #lif render_label_only:
 #eturn self.preparer.format_label(label, labelname)
 #lse:
 #eturn label.element._compiler_dispatch(
 #elf, within_columns_clause=False, **kw
 #

 #ef _fallback_column_name(self, column):
 #aise exc.CompileError(
 #Cannot compile Column object until " "its 'name' is assigned."
 #

 #ef visit_lambda_element(self, element, **kw):
 #ql_element = element._resolved
 #eturn self.process(sql_element, **kw)

 #ef visit_column(
 #elf,
 #olumn,
 #dd_to_result_map=None,
 #nclude_table=True,
 #esult_map_targets=(),
 #*kwargs
 #:
 #ame = orig_name = column.name
 #f name is None:
 #ame = self._fallback_column_name(column)

 #s_literal = column.is_literal
 #f not is_literal and isinstance(name, elements._truncated_label):
 #ame = self._truncated_identifier("colident", name)

 #f add_to_result_map is not None:
 #argets = (column, name, column.key) + result_map_targets
 #f column._tq_label:
 #argets += (column._tq_label,)

 #dd_to_result_map(name, orig_name, targets, column.type)

 #f is_literal:
            # note we are not currently accommodating for
            # literal_column(quoted_name('ident', True)) here
 #ame = self.escape_literal_column(name)
 #lse:
 #ame = self.preparer.quote(name)
 #able = column.table
 #f table is None or not include_table or not table.named_with_column:
 #eturn name
 #lse:
 #ffective_schema = self.preparer.schema_for_object(table)

 #f effective_schema:
 #chema_prefix = (
 #elf.preparer.quote_schema(effective_schema) + "."
 #
 #lse:
 #chema_prefix = ""
 #ablename = table.name
 #f isinstance(tablename, elements._truncated_label):
 #ablename = self._truncated_identifier("alias", tablename)

 #eturn schema_prefix + self.preparer.quote(tablename) + "." + name

 #ef visit_collation(self, element, **kw):
 #eturn self.preparer.format_collation(element.collation)

 #ef visit_fromclause(self, fromclause, **kwargs):
 #eturn fromclause.name

 #ef visit_index(self, index, **kwargs):
 #eturn index.name

 #ef visit_typeclause(self, typeclause, **kw):
 #w["type_expression"] = typeclause
 #w["identifier_preparer"] = self.preparer
 #eturn self.dialect.type_compiler.process(typeclause.type, **kw)

 #ef post_process_text(self, text):
 #f self.preparer._double_percents:
 #ext = text.replace("%", "%%")
 #eturn text

 #ef escape_literal_column(self, text):
 #f self.preparer._double_percents:
 #ext = text.replace("%", "%%")
 #eturn text

 #ef visit_textclause(self, textclause, add_to_result_map=None, **kw):
 #ef do_bindparam(m):
 #ame = m.group(1)
 #f name in textclause._bindparams:
 #eturn self.process(textclause._bindparams[name], **kw)
 #lse:
 #eturn self.bindparam_string(name, **kw)

 #f not self.stack:
 #elf.isplaintext = True

 #f add_to_result_map:
            # text() object is present in the columns clause of a
            # select().   Add a no-name entry to the result map so that
            # row[text()] produces a result
 #dd_to_result_map(None, None, (textclause,), sqltypes.NULLTYPE)

        # un-escape any \:params
 #eturn BIND_PARAMS_ESC.sub(
 #ambda m: m.group(1),
 #IND_PARAMS.sub(
 #o_bindparam, self.post_process_text(textclause.text)
 #,
 #

 #ef visit_textual_select(
 #elf, taf, compound_index=None, asfrom=False, **kw
 #:

 #oplevel = not self.stack
 #ntry = self._default_stack_entry if toplevel else self.stack[-1]

 #opulate_result_map = (
 #oplevel
 #r (
 #ompound_index == 0
 #nd entry.get("need_result_map_for_compound", False)
 #
 #r entry.get("need_result_map_for_nested", False)
 #

 #f populate_result_map:
 #elf._ordered_columns = (
 #elf._textual_ordered_columns
 # = taf.positional

            # enable looser result column matching when the SQL text links to
            # Column objects by name only
 #elf._loose_column_name_matching = not taf.positional and bool(
 #af.column_args
 #

 #or c in taf.column_args:
 #elf.process(
 #,
 #ithin_columns_clause=True,
 #dd_to_result_map=self._add_to_result_map,
 #

 #eturn self.process(taf.element, **kw)

 #ef visit_null(self, expr, **kw):
 #eturn "NULL"

 #ef visit_true(self, expr, **kw):
 #f self.dialect.supports_native_boolean:
 #eturn "true"
 #lse:
 #eturn "1"

 #ef visit_false(self, expr, **kw):
 #f self.dialect.supports_native_boolean:
 #eturn "false"
 #lse:
 #eturn "0"

 #ef _generate_delimited_list(self, elements, separator, **kw):
 #eturn separator.join(
 #
 #or s in (c._compiler_dispatch(self, **kw) for c in elements)
 #f s
 #

 #ef _generate_delimited_and_list(self, clauses, **kw):

 #cc, clauses = elements.BooleanClauseList._process_clauses_for_boolean(
 #perators.and_,
 #lements.True_._singleton,
 #lements.False_._singleton,
 #lauses,
 #
 #f lcc == 1:
 #eturn clauses[0]._compiler_dispatch(self, **kw)
 #lse:
 #eparator = OPERATORS[operators.and_]
 #eturn separator.join(
 #
 #or s in (c._compiler_dispatch(self, **kw) for c in clauses)
 #f s
 #

 #ef visit_tuple(self, clauselist, **kw):
 #eturn "(%s)" % self.visit_clauselist(clauselist, **kw)

 #ef visit_clauselist(self, clauselist, **kw):
 #ep = clauselist.operator
 #f sep is None:
 #ep = " "
 #lse:
 #ep = OPERATORS[clauselist.operator]

 #eturn self._generate_delimited_list(clauselist.clauses, sep, **kw)

 #ef visit_case(self, clause, **kwargs):
 # = "CASE "
 #f clause.value is not None:
 # += clause.value._compiler_dispatch(self, **kwargs) + " "
 #or cond, result in clause.whens:
 # += (
 #WHEN "
 # cond._compiler_dispatch(self, **kwargs)
 # " THEN "
 # result._compiler_dispatch(self, **kwargs)
 # " "
 #
 #f clause.else_ is not None:
 # += (
 #ELSE " + clause.else_._compiler_dispatch(self, **kwargs) + " "
 #
 # += "END"
 #eturn x

 #ef visit_type_coerce(self, type_coerce, **kw):
 #eturn type_coerce.typed_expression._compiler_dispatch(self, **kw)

 #ef visit_cast(self, cast, **kwargs):
 #eturn "CAST(%s AS %s)" % (
 #ast.clause._compiler_dispatch(self, **kwargs),
 #ast.typeclause._compiler_dispatch(self, **kwargs),
 #

 #ef _format_frame_clause(self, range_, **kw):

 #eturn "%s AND %s" % (
 #UNBOUNDED PRECEDING"
 #f range_[0] is elements.RANGE_UNBOUNDED
 #lse "CURRENT ROW"
 #f range_[0] is elements.RANGE_CURRENT
 #lse "%s PRECEDING"
 # (self.process(elements.literal(abs(range_[0])), **kw),)
 #f range_[0] < 0
 #lse "%s FOLLOWING"
 # (self.process(elements.literal(range_[0]), **kw),),
 #UNBOUNDED FOLLOWING"
 #f range_[1] is elements.RANGE_UNBOUNDED
 #lse "CURRENT ROW"
 #f range_[1] is elements.RANGE_CURRENT
 #lse "%s PRECEDING"
 # (self.process(elements.literal(abs(range_[1])), **kw),)
 #f range_[1] < 0
 #lse "%s FOLLOWING"
 # (self.process(elements.literal(range_[1]), **kw),),
 #

 #ef visit_over(self, over, **kwargs):
 #f over.range_:
 #ange_ = "RANGE BETWEEN %s" % self._format_frame_clause(
 #ver.range_, **kwargs
 #
 #lif over.rows:
 #ange_ = "ROWS BETWEEN %s" % self._format_frame_clause(
 #ver.rows, **kwargs
 #
 #lse:
 #ange_ = None

 #eturn "%s OVER (%s)" % (
 #ver.element._compiler_dispatch(self, **kwargs),
 # ".join(
 #
 #%s BY %s"
 # (word, clause._compiler_dispatch(self, **kwargs))
 #or word, clause in (
 #"PARTITION", over.partition_by),
 #"ORDER", over.order_by),
 #
 #f clause is not None and len(clause)
 #
 # ([range_] if range_ else [])
 #,
 #

 #ef visit_withingroup(self, withingroup, **kwargs):
 #eturn "%s WITHIN GROUP (ORDER BY %s)" % (
 #ithingroup.element._compiler_dispatch(self, **kwargs),
 #ithingroup.order_by._compiler_dispatch(self, **kwargs),
 #

 #ef visit_funcfilter(self, funcfilter, **kwargs):
 #eturn "%s FILTER (WHERE %s)" % (
 #uncfilter.func._compiler_dispatch(self, **kwargs),
 #uncfilter.criterion._compiler_dispatch(self, **kwargs),
 #

 #ef visit_extract(self, extract, **kwargs):
 #ield = self.extract_map.get(extract.field, extract.field)
 #eturn "EXTRACT(%s FROM %s)" % (
 #ield,
 #xtract.expr._compiler_dispatch(self, **kwargs),
 #

 #ef visit_scalar_function_column(self, element, **kw):
 #ompiled_fn = self.visit_function(element.fn, **kw)
 #ompiled_col = self.visit_column(element, **kw)
 #eturn "(%s).%s" % (compiled_fn, compiled_col)

 #ef visit_function(self, func, add_to_result_map=None, **kwargs):
 #f add_to_result_map is not None:
 #dd_to_result_map(func.name, func.name, (), func.type)

 #isp = getattr(self, "visit_%s_func" % func.name.lower(), None)
 #f disp:
 #ext = disp(func, **kwargs)
 #lse:
 #ame = FUNCTIONS.get(func._deannotate().__class__, None)
 #f name:
 #f func._has_args:
 #ame += "%(expr)s"
 #lse:
 #ame = func.name
 #ame = (
 #elf.preparer.quote(name)
 #f self.preparer._requires_quotes_illegal_chars(name)
 #r isinstance(name, elements.quoted_name)
 #lse name
 #
 #ame = name + "%(expr)s"
 #ext = ".".join(
 #
 #
 #elf.preparer.quote(tok)
 #f self.preparer._requires_quotes_illegal_chars(tok)
 #r isinstance(name, elements.quoted_name)
 #lse tok
 #
 #or tok in func.packagenames
 #
 # [name]
 # % {"expr": self.function_argspec(func, **kwargs)}

 #f func._with_ordinality:
 #ext += " WITH ORDINALITY"
 #eturn text

 #ef visit_next_value_func(self, next_value, **kw):
 #eturn self.visit_sequence(next_value.sequence)

 #ef visit_sequence(self, sequence, **kw):
 #aise NotImplementedError(
 #Dialect '%s' does not support sequence increments."
 # self.dialect.name
 #

 #ef function_argspec(self, func, **kwargs):
 #eturn func.clause_expr._compiler_dispatch(self, **kwargs)

 #ef visit_compound_select(
 #elf, cs, asfrom=False, compound_index=None, **kwargs
 #:
 #oplevel = not self.stack

 #ompile_state = cs._compile_state_factory(cs, self, **kwargs)

 #f toplevel and not self.compile_state:
 #elf.compile_state = compile_state

 #ntry = self._default_stack_entry if toplevel else self.stack[-1]
 #eed_result_map = toplevel or (
 #ot compound_index
 #nd entry.get("need_result_map_for_compound", False)
 #

        # indicates there is already a CompoundSelect in play
 #f compound_index == 0:
 #ntry["select_0"] = cs

 #elf.stack.append(
 #
 #correlate_froms": entry["correlate_froms"],
 #asfrom_froms": entry["asfrom_froms"],
 #selectable": cs,
 #compile_state": compile_state,
 #need_result_map_for_compound": need_result_map,
 #
 #

 #eyword = self.compound_keywords.get(cs.keyword)

 #ext = (" " + keyword + " ").join(
 #
 #._compiler_dispatch(
 #elf, asfrom=asfrom, compound_index=i, **kwargs
 #
 #or i, c in enumerate(cs.selects)
 #
 #

 #wargs["include_table"] = False
 #ext += self.group_by_clause(cs, **dict(asfrom=asfrom, **kwargs))
 #ext += self.order_by_clause(cs, **kwargs)
 #f cs._has_row_limiting_clause:
 #ext += self._row_limit_clause(cs, **kwargs)

 #f self.ctes and toplevel:
 #ext = self._render_cte_clause() + text

 #elf.stack.pop(-1)
 #eturn text

 #ef _row_limit_clause(self, cs, **kwargs):
 #f cs._fetch_clause is not None:
 #eturn self.fetch_clause(cs, **kwargs)
 #lse:
 #eturn self.limit_clause(cs, **kwargs)

 #ef _get_operator_dispatch(self, operator_, qualifier1, qualifier2):
 #ttrname = "visit_%s_%s%s" % (
 #perator_.__name__,
 #ualifier1,
 #_" + qualifier2 if qualifier2 else "",
 #
 #eturn getattr(self, attrname, None)

 #ef visit_unary(
 #elf, unary, add_to_result_map=None, result_map_targets=(), **kw
 #:

 #f add_to_result_map is not None:
 #esult_map_targets += (unary,)
 #w["add_to_result_map"] = add_to_result_map
 #w["result_map_targets"] = result_map_targets

 #f unary.operator:
 #f unary.modifier:
 #aise exc.CompileError(
 #Unary expression does not support operator "
 #and modifier simultaneously"
 #
 #isp = self._get_operator_dispatch(
 #nary.operator, "unary", "operator"
 #
 #f disp:
 #eturn disp(unary, unary.operator, **kw)
 #lse:
 #eturn self._generate_generic_unary_operator(
 #nary, OPERATORS[unary.operator], **kw
 #
 #lif unary.modifier:
 #isp = self._get_operator_dispatch(
 #nary.modifier, "unary", "modifier"
 #
 #f disp:
 #eturn disp(unary, unary.modifier, **kw)
 #lse:
 #eturn self._generate_generic_unary_modifier(
 #nary, OPERATORS[unary.modifier], **kw
 #
 #lse:
 #aise exc.CompileError(
 #Unary expression has no operator or modifier"
 #

 #ef visit_is_true_unary_operator(self, element, operator, **kw):
 #f (
 #lement._is_implicitly_boolean
 #r self.dialect.supports_native_boolean
 #:
 #eturn self.process(element.element, **kw)
 #lse:
 #eturn "%s = 1" % self.process(element.element, **kw)

 #ef visit_is_false_unary_operator(self, element, operator, **kw):
 #f (
 #lement._is_implicitly_boolean
 #r self.dialect.supports_native_boolean
 #:
 #eturn "NOT %s" % self.process(element.element, **kw)
 #lse:
 #eturn "%s = 0" % self.process(element.element, **kw)

 #ef visit_not_match_op_binary(self, binary, operator, **kw):
 #eturn "NOT %s" % self.visit_binary(
 #inary, override_operator=operators.match_op
 #

 #ef visit_not_in_op_binary(self, binary, operator, **kw):
        # The brackets are required in the NOT IN operation because the empty
        # case is handled using the form "(col NOT IN (null) OR 1 = 1)".
        # The presence of the OR makes the brackets required.
 #eturn "(%s)" % self._generate_generic_binary(
 #inary, OPERATORS[operator], **kw
 #

 #ef visit_empty_set_op_expr(self, type_, expand_op):
 #f expand_op is operators.not_in_op:
 #f len(type_) > 1:
 #eturn "(%s)) OR (1 = 1" % (
 #, ".join("NULL" for element in type_)
 #
 #lse:
 #eturn "NULL) OR (1 = 1"
 #lif expand_op is operators.in_op:
 #f len(type_) > 1:
 #eturn "(%s)) AND (1 != 1" % (
 #, ".join("NULL" for element in type_)
 #
 #lse:
 #eturn "NULL) AND (1 != 1"
 #lse:
 #eturn self.visit_empty_set_expr(type_)

 #ef visit_empty_set_expr(self, element_types):
 #aise NotImplementedError(
 #Dialect '%s' does not support empty set expression."
 # self.dialect.name
 #

 #ef _literal_execute_expanding_parameter_literal_binds(
 #elf, parameter, values
 #:

 #f not values:
 #f parameter.type._is_tuple_type:
 #eplacement_expression = (
 #VALUES " if self.dialect.tuple_in_values else ""
 # + self.visit_empty_set_op_expr(
 #arameter.type.types, parameter.expand_op
 #

 #lse:
 #eplacement_expression = self.visit_empty_set_op_expr(
 #parameter.type], parameter.expand_op
 #

 #lif isinstance(values[0], (tuple, list)):
 #ssert parameter.type._is_tuple_type
 #eplacement_expression = (
 #VALUES " if self.dialect.tuple_in_values else ""
 # + ", ".join(
 #(%s)"
 # (
 #, ".join(
 #elf.render_literal_value(value, param_type)
 #or value, param_type in zip(
 #uple_element, parameter.type.types
 #
 #
 #
 #or i, tuple_element in enumerate(values)
 #
 #lse:
 #ssert not parameter.type._is_tuple_type
 #eplacement_expression = ", ".join(
 #elf.render_literal_value(value, parameter.type)
 #or value in values
 #

 #eturn (), replacement_expression

 #ef _literal_execute_expanding_parameter(self, name, parameter, values):

 #f parameter.literal_execute:
 #eturn self._literal_execute_expanding_parameter_literal_binds(
 #arameter, values
 #

 #f not values:
 #o_update = []
 #f parameter.type._is_tuple_type:

 #eplacement_expression = self.visit_empty_set_op_expr(
 #arameter.type.types, parameter.expand_op
 #
 #lse:
 #eplacement_expression = self.visit_empty_set_op_expr(
 #parameter.type], parameter.expand_op
 #

 #lif isinstance(values[0], (tuple, list)):
 #o_update = [
 #"%s_%s_%s" % (name, i, j), value)
 #or i, tuple_element in enumerate(values, 1)
 #or j, value in enumerate(tuple_element, 1)
 #
 #eplacement_expression = (
 #VALUES " if self.dialect.tuple_in_values else ""
 # + ", ".join(
 #(%s)"
 # (
 #, ".join(
 #elf.bindtemplate
 # {"name": to_update[i * len(tuple_element) + j][0]}
 #or j, value in enumerate(tuple_element)
 #
 #
 #or i, tuple_element in enumerate(values)
 #
 #lse:
 #o_update = [
 #"%s_%s" % (name, i), value)
 #or i, value in enumerate(values, 1)
 #
 #eplacement_expression = ", ".join(
 #elf.bindtemplate % {"name": key} for key, value in to_update
 #

 #eturn to_update, replacement_expression

 #ef visit_binary(
 #elf,
 #inary,
 #verride_operator=None,
 #ager_grouping=False,
 #rom_linter=None,
 #ateral_from_linter=None,
 #*kw
 #:
 #f from_linter and operators.is_comparison(binary.operator):
 #f lateral_from_linter is not None:
 #nclosing_lateral = kw["enclosing_lateral"]
 #ateral_from_linter.edges.update(
 #tertools.product(
 #inary.left._from_objects + [enclosing_lateral],
 #inary.right._from_objects + [enclosing_lateral],
 #
 #
 #lse:
 #rom_linter.edges.update(
 #tertools.product(
 #inary.left._from_objects, binary.right._from_objects
 #
 #

        # don't allow "? = ?" to render
 #f (
 #elf.ansi_bind_rules
 #nd isinstance(binary.left, elements.BindParameter)
 #nd isinstance(binary.right, elements.BindParameter)
 #:
 #w["literal_execute"] = True

 #perator_ = override_operator or binary.operator
 #isp = self._get_operator_dispatch(operator_, "binary", None)
 #f disp:
 #eturn disp(binary, operator_, **kw)
 #lse:
 #ry:
 #pstring = OPERATORS[operator_]
 #xcept KeyError as err:
 #til.raise_(
 #xc.UnsupportedCompilationError(self, operator_),
 #eplace_context=err,
 #
 #lse:
 #eturn self._generate_generic_binary(
 #inary,
 #pstring,
 #rom_linter=from_linter,
 #ateral_from_linter=lateral_from_linter,
 #*kw
 #

 #ef visit_function_as_comparison_op_binary(self, element, operator, **kw):
 #eturn self.process(element.sql_function, **kw)

 #ef visit_mod_binary(self, binary, operator, **kw):
 #f self.preparer._double_percents:
 #eturn (
 #elf.process(binary.left, **kw)
 # " %% "
 # self.process(binary.right, **kw)
 #
 #lse:
 #eturn (
 #elf.process(binary.left, **kw)
 # " % "
 # self.process(binary.right, **kw)
 #

 #ef visit_custom_op_binary(self, element, operator, **kw):
 #w["eager_grouping"] = operator.eager_grouping
 #eturn self._generate_generic_binary(
 #lement,
 # " + self.escape_literal_column(operator.opstring) + " ",
 #*kw
 #

 #ef visit_custom_op_unary_operator(self, element, operator, **kw):
 #eturn self._generate_generic_unary_operator(
 #lement, self.escape_literal_column(operator.opstring) + " ", **kw
 #

 #ef visit_custom_op_unary_modifier(self, element, operator, **kw):
 #eturn self._generate_generic_unary_modifier(
 #lement, " " + self.escape_literal_column(operator.opstring), **kw
 #

 #ef _generate_generic_binary(
 #elf, binary, opstring, eager_grouping=False, **kw
 #:

 #in_binary = kw.get("_in_binary", False)

 #w["_in_binary"] = True
 #w["_binary_op"] = binary.operator
 #ext = (
 #inary.left._compiler_dispatch(
 #elf, eager_grouping=eager_grouping, **kw
 #
 # opstring
 # binary.right._compiler_dispatch(
 #elf, eager_grouping=eager_grouping, **kw
 #
 #

 #f _in_binary and eager_grouping:
 #ext = "(%s)" % text
 #eturn text

 #ef _generate_generic_unary_operator(self, unary, opstring, **kw):
 #eturn opstring + unary.element._compiler_dispatch(self, **kw)

 #ef _generate_generic_unary_modifier(self, unary, opstring, **kw):
 #eturn unary.element._compiler_dispatch(self, **kw) + opstring

 #util.memoized_property
 #ef _like_percent_literal(self):
 #eturn elements.literal_column("'%'", type_=sqltypes.STRINGTYPE)

 #ef visit_contains_op_binary(self, binary, operator, **kw):
 #inary = binary._clone()
 #ercent = self._like_percent_literal
 #inary.right = percent.__add__(binary.right).__add__(percent)
 #eturn self.visit_like_op_binary(binary, operator, **kw)

 #ef visit_not_contains_op_binary(self, binary, operator, **kw):
 #inary = binary._clone()
 #ercent = self._like_percent_literal
 #inary.right = percent.__add__(binary.right).__add__(percent)
 #eturn self.visit_not_like_op_binary(binary, operator, **kw)

 #ef visit_startswith_op_binary(self, binary, operator, **kw):
 #inary = binary._clone()
 #ercent = self._like_percent_literal
 #inary.right = percent.__radd__(binary.right)
 #eturn self.visit_like_op_binary(binary, operator, **kw)

 #ef visit_not_startswith_op_binary(self, binary, operator, **kw):
 #inary = binary._clone()
 #ercent = self._like_percent_literal
 #inary.right = percent.__radd__(binary.right)
 #eturn self.visit_not_like_op_binary(binary, operator, **kw)

 #ef visit_endswith_op_binary(self, binary, operator, **kw):
 #inary = binary._clone()
 #ercent = self._like_percent_literal
 #inary.right = percent.__add__(binary.right)
 #eturn self.visit_like_op_binary(binary, operator, **kw)

 #ef visit_not_endswith_op_binary(self, binary, operator, **kw):
 #inary = binary._clone()
 #ercent = self._like_percent_literal
 #inary.right = percent.__add__(binary.right)
 #eturn self.visit_not_like_op_binary(binary, operator, **kw)

 #ef visit_like_op_binary(self, binary, operator, **kw):
 #scape = binary.modifiers.get("escape", None)

        # TODO: use ternary here, not "and"/ "or"
 #eturn "%s LIKE %s" % (
 #inary.left._compiler_dispatch(self, **kw),
 #inary.right._compiler_dispatch(self, **kw),
 # + (
 # ESCAPE " + self.render_literal_value(escape, sqltypes.STRINGTYPE)
 #f escape
 #lse ""
 #

 #ef visit_not_like_op_binary(self, binary, operator, **kw):
 #scape = binary.modifiers.get("escape", None)
 #eturn "%s NOT LIKE %s" % (
 #inary.left._compiler_dispatch(self, **kw),
 #inary.right._compiler_dispatch(self, **kw),
 # + (
 # ESCAPE " + self.render_literal_value(escape, sqltypes.STRINGTYPE)
 #f escape
 #lse ""
 #

 #ef visit_ilike_op_binary(self, binary, operator, **kw):
 #scape = binary.modifiers.get("escape", None)
 #eturn "lower(%s) LIKE lower(%s)" % (
 #inary.left._compiler_dispatch(self, **kw),
 #inary.right._compiler_dispatch(self, **kw),
 # + (
 # ESCAPE " + self.render_literal_value(escape, sqltypes.STRINGTYPE)
 #f escape
 #lse ""
 #

 #ef visit_not_ilike_op_binary(self, binary, operator, **kw):
 #scape = binary.modifiers.get("escape", None)
 #eturn "lower(%s) NOT LIKE lower(%s)" % (
 #inary.left._compiler_dispatch(self, **kw),
 #inary.right._compiler_dispatch(self, **kw),
 # + (
 # ESCAPE " + self.render_literal_value(escape, sqltypes.STRINGTYPE)
 #f escape
 #lse ""
 #

 #ef visit_between_op_binary(self, binary, operator, **kw):
 #ymmetric = binary.modifiers.get("symmetric", False)
 #eturn self._generate_generic_binary(
 #inary, " BETWEEN SYMMETRIC " if symmetric else " BETWEEN ", **kw
 #

 #ef visit_not_between_op_binary(self, binary, operator, **kw):
 #ymmetric = binary.modifiers.get("symmetric", False)
 #eturn self._generate_generic_binary(
 #inary,
 # NOT BETWEEN SYMMETRIC " if symmetric else " NOT BETWEEN ",
 #*kw
 #

 #ef visit_regexp_match_op_binary(self, binary, operator, **kw):
 #aise exc.CompileError(
 #%s dialect does not support regular expressions"
 # self.dialect.name
 #

 #ef visit_not_regexp_match_op_binary(self, binary, operator, **kw):
 #aise exc.CompileError(
 #%s dialect does not support regular expressions"
 # self.dialect.name
 #

 #ef visit_regexp_replace_op_binary(self, binary, operator, **kw):
 #aise exc.CompileError(
 #%s dialect does not support regular expression replacements"
 # self.dialect.name
 #

 #ef visit_bindparam(
 #elf,
 #indparam,
 #ithin_columns_clause=False,
 #iteral_binds=False,
 #kip_bind_expression=False,
 #iteral_execute=False,
 #ender_postcompile=False,
 #*kwargs
 #:
 #f not skip_bind_expression:
 #mpl = bindparam.type.dialect_impl(self.dialect)
 #f impl._has_bind_expression:
 #ind_expression = impl.bind_expression(bindparam)
 #eturn self.process(
 #ind_expression,
 #kip_bind_expression=True,
 #ithin_columns_clause=within_columns_clause,
 #iteral_binds=literal_binds,
 #iteral_execute=literal_execute,
 #*kwargs
 #

 #f not literal_binds:
 #iteral_execute = (
 #iteral_execute
 #r bindparam.literal_execute
 #r (within_columns_clause and self.ansi_bind_rules)
 #
 #ost_compile = literal_execute or bindparam.expanding
 #lse:
 #ost_compile = False

 #f not literal_execute and (literal_binds):
 #et = self.render_literal_bindparam(
 #indparam, within_columns_clause=True, **kwargs
 #
 #f bindparam.expanding:
 #et = "(%s)" % ret
 #eturn ret

 #ame = self._truncate_bindparam(bindparam)

 #f name in self.binds:
 #xisting = self.binds[name]
 #f existing is not bindparam:
 #f (
 #xisting.unique or bindparam.unique
 # and not existing.proxy_set.intersection(bindparam.proxy_set):
 #aise exc.CompileError(
 #Bind parameter '%s' conflicts with "
 #unique bind parameter of the same name" % name
 #
 #lif existing._is_crud or bindparam._is_crud:
 #aise exc.CompileError(
 #bindparam() name '%s' is reserved "
 #for automatic usage in the VALUES or SET "
 #clause of this "
 #insert/update statement.   Please use a "
 #name other than column name when using bindparam() "
 #with insert() or update() (for example, 'b_%s')."
 # (bindparam.key, bindparam.key)
 #

 #elf.binds[bindparam.key] = self.binds[name] = bindparam

        # if we are given a cache key that we're going to match against,
        # relate the bindparam here to one that is most likely present
        # in the "extracted params" portion of the cache key.  this is used
        # to set up a positional mapping that is used to determine the
        # correct parameters for a subsequent use of this compiled with
        # a different set of parameter values.   here, we accommodate for
        # parameters that may have been cloned both before and after the cache
        # key was been generated.
 #kbm = self._cache_key_bind_match
 #f ckbm:
 #or bp in bindparam._cloned_set:
 #f bp.key in ckbm:
 #b = ckbm[bp.key]
 #kbm[cb].append(bindparam)

 #f bindparam.isoutparam:
 #elf.has_out_parameters = True

 #f post_compile:
 #f render_postcompile:
 #elf._render_postcompile = True

 #f literal_execute:
 #elf.literal_execute_params |= {bindparam}
 #lse:
 #elf.post_compile_params |= {bindparam}

 #et = self.bindparam_string(
 #ame,
 #ost_compile=post_compile,
 #xpanding=bindparam.expanding,
 #*kwargs
 #

 #f bindparam.expanding:
 #et = "(%s)" % ret
 #eturn ret

 #ef render_literal_bindparam(
 #elf, bindparam, render_literal_value=NO_ARG, **kw
 #:
 #f render_literal_value is not NO_ARG:
 #alue = render_literal_value
 #lse:
 #f bindparam.value is None and bindparam.callable is None:
 #p = kw.get("_binary_op", None)
 #f op and op not in (operators.is_, operators.is_not):
 #til.warn_limited(
 #Bound parameter '%s' rendering literal NULL in a SQL "
 #expression; comparisons to NULL should not use "
 #operators outside of 'is' or 'is not'",
 #bindparam.key,),
 #
 #eturn self.process(sqltypes.NULLTYPE, **kw)
 #alue = bindparam.effective_value

 #f bindparam.expanding:
 #eep = self._literal_execute_expanding_parameter_literal_binds
 #o_update, replacement_expr = leep(bindparam, value)
 #eturn replacement_expr
 #lse:
 #eturn self.render_literal_value(value, bindparam.type)

 #ef render_literal_value(self, value, type_):
 #""Render the value of a bind parameter as a quoted literal.

 #his is used for statement sections that do not accept bind parameters
 #n the target driver/database.

 #his should be implemented by subclasses using the quoting services
 #f the DBAPI.

 #""

 #rocessor = type_._cached_literal_processor(self.dialect)
 #f processor:
 #eturn processor(value)
 #lse:
 #aise NotImplementedError(
 #Don't know how to literal-quote value %r" % value
 #

 #ef _truncate_bindparam(self, bindparam):
 #f bindparam in self.bind_names:
 #eturn self.bind_names[bindparam]

 #ind_name = bindparam.key
 #f isinstance(bind_name, elements._truncated_label):
 #ind_name = self._truncated_identifier("bindparam", bind_name)

        # add to bind_names for translation
 #elf.bind_names[bindparam] = bind_name

 #eturn bind_name

 #ef _truncated_identifier(self, ident_class, name):
 #f (ident_class, name) in self.truncated_names:
 #eturn self.truncated_names[(ident_class, name)]

 #nonname = name.apply_map(self.anon_map)

 #f len(anonname) > self.label_length - 6:
 #ounter = self.truncated_names.get(ident_class, 1)
 #runcname = (
 #nonname[0 : max(self.label_length - 6, 0)]
 # "_"
 # hex(counter)[2:]
 #
 #elf.truncated_names[ident_class] = counter + 1
 #lse:
 #runcname = anonname
 #elf.truncated_names[(ident_class, name)] = truncname
 #eturn truncname

 #ef _anonymize(self, name):
 #eturn name % self.anon_map

 #ef bindparam_string(
 #elf,
 #ame,
 #ositional_names=None,
 #ost_compile=False,
 #xpanding=False,
 #scaped_from=None,
 #*kw
 #:

 #f self.positional:
 #f positional_names is not None:
 #ositional_names.append(name)
 #lse:
 #elf.positiontup.append(name)
 #lif not post_compile and not escaped_from:
 #r_reg = self._bind_translate
 #f tr_reg.search(name):
                # i'd rather use translate() here but I can't get it to work
                # in all cases under Python 2, not worth it right now
 #ew_name = tr_reg.sub(
 #ambda m: _BIND_TRANSLATE_CHARS[m.group(0)],
 #ame,
 #
 #scaped_from = name
 #ame = new_name

 #f escaped_from:
 #f not self.escaped_bind_names:
 #elf.escaped_bind_names = {}
 #elf.escaped_bind_names[escaped_from] = name
 #f post_compile:
 #eturn "[POSTCOMPILE_%s]" % name
 #lse:
 #eturn self.bindtemplate % {"name": name}

 #ef visit_cte(
 #elf,
 #te,
 #sfrom=False,
 #shint=False,
 #romhints=None,
 #isiting_cte=None,
 #rom_linter=None,
 #*kwargs
 #:
 #elf._init_cte_state()

 #wargs["visiting_cte"] = cte
 #f isinstance(cte.name, elements._truncated_label):
 #te_name = self._truncated_identifier("alias", cte.name)
 #lse:
 #te_name = cte.name

 #s_new_cte = True
 #mbedded_in_current_named_cte = False

 #f cte_name in self.ctes_by_name:
 #xisting_cte = self.ctes_by_name[cte_name]
 #mbedded_in_current_named_cte = visiting_cte is existing_cte

            # we've generated a same-named CTE that we are enclosed in,
            # or this is the same CTE.  just return the name.
 #f cte in existing_cte._restates or cte is existing_cte:
 #s_new_cte = False
 #lif existing_cte in cte._restates:
                # we've generated a same-named CTE that is
                # enclosed in us - we take precedence, so
                # discard the text for the "inner".
 #el self.ctes[existing_cte]
 #lse:
 #aise exc.CompileError(
 #Multiple, unrelated CTEs found with "
 #the same name: %r" % cte_name
 #

 #f asfrom or is_new_cte:
 #f cte._cte_alias is not None:
 #re_alias_cte = cte._cte_alias
 #te_pre_alias_name = cte._cte_alias.name
 #f isinstance(cte_pre_alias_name, elements._truncated_label):
 #te_pre_alias_name = self._truncated_identifier(
 #alias", cte_pre_alias_name
 #
 #lse:
 #re_alias_cte = cte
 #te_pre_alias_name = None

 #f is_new_cte:
 #elf.ctes_by_name[cte_name] = cte

 #f (
 #autocommit" in cte.element._execution_options
 #nd "autocommit" not in self.execution_options
 #:
 #elf.execution_options = self.execution_options.union(
 #
 #autocommit": cte.element._execution_options[
 #autocommit"
 #
 #
 #

 #f pre_alias_cte not in self.ctes:
 #elf.visit_cte(pre_alias_cte, **kwargs)

 #f not cte_pre_alias_name and cte not in self.ctes:
 #f cte.recursive:
 #elf.ctes_recursive = True
 #ext = self.preparer.format_alias(cte, cte_name)
 #f cte.recursive:
 #f isinstance(cte.element, selectable.Select):
 #ol_source = cte.element
 #lif isinstance(cte.element, selectable.CompoundSelect):
 #ol_source = cte.element.selects[0]
 #lse:
 #ssert False, "cte should only be against SelectBase"

                    # TODO: can we get at the .columns_plus_names collection
                    # that is already (or will be?) generated for the SELECT
                    # rather than calling twice?
 #ecur_cols = [
                        # TODO: proxy_name is not technically safe,
                        # see test_cte->
                        # test_with_recursive_no_name_currently_buggy.  not
                        # clear what should be done with such a case
 #allback_label_name or proxy_name
 #or (
 #,
 #roxy_name,
 #allback_label_name,
 #,
 #epeated,
 # in (col_source._generate_columns_plus_names(True))
 #f not repeated
 #

 #ext += "(%s)" % (
 #, ".join(
 #elf.preparer.format_label_name(
 #dent, anon_map=self.anon_map
 #
 #or ident in recur_cols
 #
 #

 #f self.positional:
 #wargs["positional_names"] = self.cte_positional[cte] = []

 #ssert kwargs.get("subquery", False) is False

 #f not self.stack:
                    # toplevel, this is a stringify of the
                    # cte directly.  just compile the inner
                    # the way alias() does.
 #eturn cte.element._compiler_dispatch(
 #elf, asfrom=asfrom, **kwargs
 #
 #lse:
 #refixes = self._generate_prefixes(
 #te, cte._prefixes, **kwargs
 #
 #nner = cte.element._compiler_dispatch(
 #elf, asfrom=True, **kwargs
 #

 #ext += " AS %s\n(%s)" % (prefixes, inner)

 #f cte._suffixes:
 #ext += " " + self._generate_prefixes(
 #te, cte._suffixes, **kwargs
 #

 #elf.ctes[cte] = text

 #f asfrom:
 #f from_linter:
 #rom_linter.froms[cte] = cte_name

 #f not is_new_cte and embedded_in_current_named_cte:
 #eturn self.preparer.format_alias(cte, cte_name)

 #f cte_pre_alias_name:
 #ext = self.preparer.format_alias(cte, cte_pre_alias_name)
 #f self.preparer._requires_quotes(cte_name):
 #te_name = self.preparer.quote(cte_name)
 #ext += self.get_render_as_alias_suffix(cte_name)
 #eturn text
 #lse:
 #eturn self.preparer.format_alias(cte, cte_name)

 #ef visit_table_valued_alias(self, element, **kw):
 #f element._is_lateral:
 #eturn self.visit_lateral(element, **kw)
 #lse:
 #eturn self.visit_alias(element, **kw)

 #ef visit_table_valued_column(self, element, **kw):
 #eturn self.visit_column(element, **kw)

 #ef visit_alias(
 #elf,
 #lias,
 #sfrom=False,
 #shint=False,
 #scrud=False,
 #romhints=None,
 #ubquery=False,
 #ateral=False,
 #nclosing_alias=None,
 #rom_linter=None,
 #*kwargs
 #:

 #f lateral:
 #f "enclosing_lateral" not in kwargs:
                # if lateral is set and enclosing_lateral is not
                # present, we assume we are being called directly
                # from visit_lateral() and we need to set enclosing_lateral.
 #ssert alias._is_lateral
 #wargs["enclosing_lateral"] = alias

            # for lateral objects, we track a second from_linter that is...
            # lateral!  to the level above us.
 #f (
 #rom_linter
 #nd "lateral_from_linter" not in kwargs
 #nd "enclosing_lateral" in kwargs
 #:
 #wargs["lateral_from_linter"] = from_linter

 #f enclosing_alias is not None and enclosing_alias.element is alias:
 #nner = alias.element._compiler_dispatch(
 #elf,
 #sfrom=asfrom,
 #shint=ashint,
 #scrud=iscrud,
 #romhints=fromhints,
 #ateral=lateral,
 #nclosing_alias=alias,
 #*kwargs
 #
 #f subquery and (asfrom or lateral):
 #nner = "(%s)" % (inner,)
 #eturn inner
 #lse:
 #nclosing_alias = kwargs["enclosing_alias"] = alias

 #f asfrom or ashint:
 #f isinstance(alias.name, elements._truncated_label):
 #lias_name = self._truncated_identifier("alias", alias.name)
 #lse:
 #lias_name = alias.name

 #f ashint:
 #eturn self.preparer.format_alias(alias, alias_name)
 #lif asfrom:
 #f from_linter:
 #rom_linter.froms[alias] = alias_name

 #nner = alias.element._compiler_dispatch(
 #elf, asfrom=True, lateral=lateral, **kwargs
 #
 #f subquery:
 #nner = "(%s)" % (inner,)

 #et = inner + self.get_render_as_alias_suffix(
 #elf.preparer.format_alias(alias, alias_name)
 #

 #f alias._supports_derived_columns and alias._render_derived:
 #et += "(%s)" % (
 #, ".join(
 #%s%s"
 # (
 #elf.preparer.quote(col.name),
 # %s"
 # self.dialect.type_compiler.process(
 #ol.type, **kwargs
 #
 #f alias._render_derived_w_types
 #lse "",
 #
 #or col in alias.c
 #
 #

 #f fromhints and alias in fromhints:
 #et = self.format_from_hint_text(
 #et, alias, fromhints[alias], iscrud
 #

 #eturn ret
 #lse:
            # note we cancel the "subquery" flag here as well
 #eturn alias.element._compiler_dispatch(
 #elf, lateral=lateral, **kwargs
 #

 #ef visit_subquery(self, subquery, **kw):
 #w["subquery"] = True
 #eturn self.visit_alias(subquery, **kw)

 #ef visit_lateral(self, lateral_, **kw):
 #w["lateral"] = True
 #eturn "LATERAL %s" % self.visit_alias(lateral_, **kw)

 #ef visit_tablesample(self, tablesample, asfrom=False, **kw):
 #ext = "%s TABLESAMPLE %s" % (
 #elf.visit_alias(tablesample, asfrom=True, **kw),
 #ablesample._get_method()._compiler_dispatch(self, **kw),
 #

 #f tablesample.seed is not None:
 #ext += " REPEATABLE (%s)" % (
 #ablesample.seed._compiler_dispatch(self, **kw)
 #

 #eturn text

 #ef visit_values(self, element, asfrom=False, from_linter=None, **kw):
 #w.setdefault("literal_binds", element.literal_binds)
 # = "VALUES %s" % ", ".join(
 #elf.process(
 #lements.Tuple(
 #ypes=element._column_types, *elem
 #.self_group(),
 #*kw
 #
 #or chunk in element._data
 #or elem in chunk
 #

 #f isinstance(element.name, elements._truncated_label):
 #ame = self._truncated_identifier("values", element.name)
 #lse:
 #ame = element.name

 #f element._is_lateral:
 #ateral = "LATERAL "
 #lse:
 #ateral = ""

 #f asfrom:
 #f from_linter:
 #rom_linter.froms[element] = (
 #ame if name is not None else "(unnamed VALUES element)"
 #

 #f name:
 # = "%s(%s)%s (%s)" % (
 #ateral,
 #,
 #elf.get_render_as_alias_suffix(self.preparer.quote(name)),
 #
 #, ".join(
 #._compiler_dispatch(
 #elf, include_table=False, **kw
 #
 #or c in element.columns
 #
 #,
 #
 #lse:
 # = "%s(%s)" % (lateral, v)
 #eturn v

 #ef get_render_as_alias_suffix(self, alias_name_text):
 #eturn " AS " + alias_name_text

 #ef _add_to_result_map(self, keyname, name, objects, type_):
 #f keyname is None or keyname == "*":
 #elf._ordered_columns = False
 #elf._textual_ordered_columns = True
 #f type_._is_tuple_type:
 #aise exc.CompileError(
 #Most backends don't support SELECTing "
 #from a tuple() object.  If this is an ORM query, "
 #consider using the Bundle object."
 #
 #elf._result_columns.append((keyname, name, objects, type_))

 #ef _label_returning_column(self, stmt, column, column_clause_args=None):
 #""Render a column with necessary labels inside of a RETURNING clause.

 #his method is provided for individual dialects in place of calling
 #he _label_select_column method directly, so that the two use cases
 #f RETURNING vs. SELECT can be disambiguated going forward.

 #. versionadded:: 1.4.21

 #""
 #eturn self._label_select_column(
 #one,
 #olumn,
 #rue,
 #alse,
 #} if column_clause_args is None else column_clause_args,
 #

 #ef _label_select_column(
 #elf,
 #elect,
 #olumn,
 #opulate_result_map,
 #sfrom,
 #olumn_clause_args,
 #ame=None,
 #roxy_name=None,
 #allback_label_name=None,
 #ithin_columns_clause=True,
 #olumn_is_repeated=False,
 #eed_column_expressions=False,
 #:
 #""produce labeled columns present in a select()."""
 #mpl = column.type.dialect_impl(self.dialect)

 #f impl._has_column_expression and (
 #eed_column_expressions or populate_result_map
 #:
 #ol_expr = impl.column_expression(column)
 #lse:
 #ol_expr = column

 #f populate_result_map:
            # pass an "add_to_result_map" callable into the compilation
            # of embedded columns.  this collects information about the
            # column as it will be fetched in the result and is coordinated
            # with cursor.description when the query is executed.
 #dd_to_result_map = self._add_to_result_map

            # if the SELECT statement told us this column is a repeat,
            # wrap the callable with one that prevents the addition of the
            # targets
 #f column_is_repeated:
 #add_to_result_map = add_to_result_map

 #ef add_to_result_map(keyname, name, objects, type_):
 #add_to_result_map(keyname, name, (), type_)

            # if we redefined col_expr for type expressions, wrap the
            # callable with one that adds the original column to the targets
 #lif col_expr is not column:
 #add_to_result_map = add_to_result_map

 #ef add_to_result_map(keyname, name, objects, type_):
 #add_to_result_map(
 #eyname, name, (column,) + objects, type_
 #

 #lse:
 #dd_to_result_map = None

        # this method is used by some of the dialects for RETURNING,
        # which has different inputs.  _label_returning_column was added
        # as the better target for this now however for 1.4 we will keep
        # _label_select_column directly compatible with this use case.
        # these assertions right now set up the current expected inputs
 #ssert within_columns_clause, (
 #_label_select_column is only relevant within "
 #the columns clause of a SELECT or RETURNING"
 #

 #f isinstance(column, elements.Label):
 #f col_expr is not column:
 #esult_expr = _CompileLabel(
 #ol_expr, column.name, alt_names=(column.element,)
 #
 #lse:
 #esult_expr = col_expr

 #lif name:
            # here, _columns_plus_names has determined there's an explicit
            # label name we need to use.  this is the default for
            # tablenames_plus_columnnames as well as when columns are being
            # deduplicated on name

 #ssert (
 #roxy_name is not None
 #, "proxy_name is required if 'name' is passed"

 #esult_expr = _CompileLabel(
 #ol_expr,
 #ame,
 #lt_names=(
 #roxy_name,
                    # this is a hack to allow legacy result column lookups
                    # to work as they did before; this goes away in 2.0.
                    # TODO: this only seems to be tested indirectly
                    # via test/orm/test_deprecations.py.   should be a
                    # resultset test for this
 #olumn._tq_label,
 #,
 #
 #lse:
            # determine here whether this column should be rendered in
            # a labelled context or not, as we were given no required label
            # name from the caller. Here we apply heuristics based on the kind
            # of SQL expression involved.

 #f col_expr is not column:
                # type-specific expression wrapping the given column,
                # so we render a label
 #ender_with_label = True
 #lif isinstance(column, elements.ColumnClause):
                # table-bound column, we render its name as a label if we are
                # inside of a subquery only
 #ender_with_label = (
 #sfrom
 #nd not column.is_literal
 #nd column.table is not None
 #
 #lif isinstance(column, elements.TextClause):
 #ender_with_label = False
 #lif isinstance(column, elements.UnaryExpression):
 #ender_with_label = column.wraps_column_expression or asfrom
 #lif (
                # general class of expressions that don't have a SQL-column
                # addressible name.  includes scalar selects, bind parameters,
                # SQL functions, others
 #ot isinstance(column, elements.NamedColumn)
                # deeper check that indicates there's no natural "name" to
                # this element, which accommodates for custom SQL constructs
                # that might have a ".name" attribute (but aren't SQL
                # functions) but are not implementing this more recently added
                # base class.  in theory the "NamedColumn" check should be
                # enough, however here we seek to maintain legacy behaviors
                # as well.
 #nd column._non_anon_label is None
 #:
 #ender_with_label = True
 #lse:
 #ender_with_label = False

 #f render_with_label:
 #f not fallback_label_name:
                    # used by the RETURNING case right now.  we generate it
                    # here as 3rd party dialects may be referring to
                    # _label_select_column method directly instead of the
                    # just-added _label_returning_column method
 #ssert not column_is_repeated
 #allback_label_name = column._anon_name_label

 #allback_label_name = (
 #lements._truncated_label(fallback_label_name)
 #f not isinstance(
 #allback_label_name, elements._truncated_label
 #
 #lse fallback_label_name
 #

 #esult_expr = _CompileLabel(
 #ol_expr, fallback_label_name, alt_names=(proxy_name,)
 #
 #lse:
 #esult_expr = col_expr

 #olumn_clause_args.update(
 #ithin_columns_clause=within_columns_clause,
 #dd_to_result_map=add_to_result_map,
 #
 #eturn result_expr._compiler_dispatch(self, **column_clause_args)

 #ef format_from_hint_text(self, sqltext, table, hint, iscrud):
 #inttext = self.get_from_hint_text(table, hint)
 #f hinttext:
 #qltext += " " + hinttext
 #eturn sqltext

 #ef get_select_hint_text(self, byfroms):
 #eturn None

 #ef get_from_hint_text(self, table, text):
 #eturn None

 #ef get_crud_hint_text(self, table, text):
 #eturn None

 #ef get_statement_hint_text(self, hint_texts):
 #eturn " ".join(hint_texts)

 #default_stack_entry = util.immutabledict(
 #("correlate_froms", frozenset()), ("asfrom_froms", frozenset())]
 #

 #ef _display_froms_for_select(
 #elf, select_stmt, asfrom, lateral=False, **kw
 #:
        # utility method to help external dialects
        # get the correct from list for a select.
        # specifically the oracle dialect needs this feature
        # right now.
 #oplevel = not self.stack
 #ntry = self._default_stack_entry if toplevel else self.stack[-1]

 #ompile_state = select_stmt._compile_state_factory(select_stmt, self)

 #orrelate_froms = entry["correlate_froms"]
 #sfrom_froms = entry["asfrom_froms"]

 #f asfrom and not lateral:
 #roms = compile_state._get_display_froms(
 #xplicit_correlate_froms=correlate_froms.difference(
 #sfrom_froms
 #,
 #mplicit_correlate_froms=(),
 #
 #lse:
 #roms = compile_state._get_display_froms(
 #xplicit_correlate_froms=correlate_froms,
 #mplicit_correlate_froms=asfrom_froms,
 #
 #eturn froms

 #ranslate_select_structure = None
 #""if not ``None``, should be a callable which accepts ``(select_stmt,
 #*kw)`` and returns a select object.   this is used for structural changes
 #ostly to accommodate for LIMIT/OFFSET schemes

 #""

 #ef visit_select(
 #elf,
 #elect_stmt,
 #sfrom=False,
 #romhints=None,
 #ompound_index=None,
 #elect_wraps_for=None,
 #ateral=False,
 #rom_linter=None,
 #*kwargs
 #:
 #ssert select_wraps_for is None, (
 #SQLAlchemy 1.4 requires use of "
 #the translate_select_structure hook for structural "
 #translations of SELECT objects"
 #

        # initial setup of SELECT.  the compile_state_factory may now
        # be creating a totally different SELECT from the one that was
        # passed in.  for ORM use this will convert from an ORM-state
        # SELECT to a regular "Core" SELECT.  other composed operations
        # such as computation of joins will be performed.
 #ompile_state = select_stmt._compile_state_factory(
 #elect_stmt, self, **kwargs
 #
 #elect_stmt = compile_state.statement

 #oplevel = not self.stack

 #f toplevel and not self.compile_state:
 #elf.compile_state = compile_state

        # translate step for Oracle, SQL Server which often need to
        # restructure the SELECT to allow for LIMIT/OFFSET and possibly
        # other conditions
 #f self.translate_select_structure:
 #ew_select_stmt = self.translate_select_structure(
 #elect_stmt, asfrom=asfrom, **kwargs
 #

            # if SELECT was restructured, maintain a link to the originals
            # and assemble a new compile state
 #f new_select_stmt is not select_stmt:
 #ompile_state_wraps_for = compile_state
 #elect_wraps_for = select_stmt
 #elect_stmt = new_select_stmt

 #ompile_state = select_stmt._compile_state_factory(
 #elect_stmt, self, **kwargs
 #
 #elect_stmt = compile_state.statement

 #ntry = self._default_stack_entry if toplevel else self.stack[-1]

 #opulate_result_map = need_column_expressions = (
 #oplevel
 #r entry.get("need_result_map_for_compound", False)
 #r entry.get("need_result_map_for_nested", False)
 #

        # indicates there is a CompoundSelect in play and we are not the
        # first select
 #f compound_index:
 #opulate_result_map = False

        # this was first proposed as part of #3372; however, it is not
        # reached in current tests and could possibly be an assertion
        # instead.
 #f not populate_result_map and "add_to_result_map" in kwargs:
 #el kwargs["add_to_result_map"]

 #roms = self._setup_select_stack(
 #elect_stmt, compile_state, entry, asfrom, lateral, compound_index
 #

 #olumn_clause_args = kwargs.copy()
 #olumn_clause_args.update(
 #"within_label_clause": False, "within_columns_clause": False}
 #

 #ext = "SELECT "  # we're off to a good start !

 #f select_stmt._hints:
 #int_text, byfrom = self._setup_select_hints(select_stmt)
 #f hint_text:
 #ext += hint_text + " "
 #lse:
 #yfrom = None

 #f select_stmt._independent_ctes:
 #or cte in select_stmt._independent_ctes:
 #te._compiler_dispatch(self, **kwargs)

 #f select_stmt._prefixes:
 #ext += self._generate_prefixes(
 #elect_stmt, select_stmt._prefixes, **kwargs
 #

 #ext += self.get_select_precolumns(select_stmt, **kwargs)
        # the actual list of columns to print in the SELECT column list.
 #nner_columns = [
 #
 #or c in [
 #elf._label_select_column(
 #elect_stmt,
 #olumn,
 #opulate_result_map,
 #sfrom,
 #olumn_clause_args,
 #ame=name,
 #roxy_name=proxy_name,
 #allback_label_name=fallback_label_name,
 #olumn_is_repeated=repeated,
 #eed_column_expressions=need_column_expressions,
 #
 #or (
 #ame,
 #roxy_name,
 #allback_label_name,
 #olumn,
 #epeated,
 # in compile_state.columns_plus_names
 #
 #f c is not None
 #

 #f populate_result_map and select_wraps_for is not None:
            # if this select was generated from translate_select,
            # rewrite the targeted columns in the result map

 #ranslate = dict(
 #ip(
 #
 #ame
 #or (
 #ey,
 #roxy_name,
 #allback_label_name,
 #ame,
 #epeated,
 # in compile_state.columns_plus_names
 #,
 #
 #ame
 #or (
 #ey,
 #roxy_name,
 #allback_label_name,
 #ame,
 #epeated,
 # in compile_state_wraps_for.columns_plus_names
 #,
 #
 #

 #elf._result_columns = [
 #key, name, tuple(translate.get(o, o) for o in obj), type_)
 #or key, name, obj, type_ in self._result_columns
 #

 #ext = self._compose_select_body(
 #ext,
 #elect_stmt,
 #ompile_state,
 #nner_columns,
 #roms,
 #yfrom,
 #oplevel,
 #wargs,
 #

 #f select_stmt._statement_hints:
 #er_dialect = [
 #t
 #or (dialect_name, ht) in select_stmt._statement_hints
 #f dialect_name in ("*", self.dialect.name)
 #
 #f per_dialect:
 #ext += " " + self.get_statement_hint_text(per_dialect)

 #f self.ctes and toplevel:
 #ext = self._render_cte_clause() + text

 #f select_stmt._suffixes:
 #ext += " " + self._generate_prefixes(
 #elect_stmt, select_stmt._suffixes, **kwargs
 #

 #elf.stack.pop(-1)

 #eturn text

 #ef _setup_select_hints(self, select):
 #yfrom = dict(
 #
 #
 #rom_,
 #inttext
 # {"name": from_._compiler_dispatch(self, ashint=True)},
 #
 #or (from_, dialect), hinttext in select._hints.items()
 #f dialect in ("*", self.dialect.name)
 #
 #
 #int_text = self.get_select_hint_text(byfrom)
 #eturn hint_text, byfrom

 #ef _setup_select_stack(
 #elf, select, compile_state, entry, asfrom, lateral, compound_index
 #:
 #orrelate_froms = entry["correlate_froms"]
 #sfrom_froms = entry["asfrom_froms"]

 #f compound_index == 0:
 #ntry["select_0"] = select
 #lif compound_index:
 #elect_0 = entry["select_0"]
 #umcols = len(select_0._all_selected_columns)

 #f len(compile_state.columns_plus_names) != numcols:
 #aise exc.CompileError(
 #All selectables passed to "
 #CompoundSelect must have identical numbers of "
 #columns; select #%d has %d columns, select "
 ##%d has %d"
 # (
 #,
 #umcols,
 #ompound_index + 1,
 #en(select._all_selected_columns),
 #
 #

 #f asfrom and not lateral:
 #roms = compile_state._get_display_froms(
 #xplicit_correlate_froms=correlate_froms.difference(
 #sfrom_froms
 #,
 #mplicit_correlate_froms=(),
 #
 #lse:
 #roms = compile_state._get_display_froms(
 #xplicit_correlate_froms=correlate_froms,
 #mplicit_correlate_froms=asfrom_froms,
 #

 #ew_correlate_froms = set(selectable._from_objects(*froms))
 #ll_correlate_froms = new_correlate_froms.union(correlate_froms)

 #ew_entry = {
 #asfrom_froms": new_correlate_froms,
 #correlate_froms": all_correlate_froms,
 #selectable": select,
 #compile_state": compile_state,
 #
 #elf.stack.append(new_entry)

 #eturn froms

 #ef _compose_select_body(
 #elf,
 #ext,
 #elect,
 #ompile_state,
 #nner_columns,
 #roms,
 #yfrom,
 #oplevel,
 #wargs,
 #:
 #ext += ", ".join(inner_columns)

 #f self.linting & COLLECT_CARTESIAN_PRODUCTS:
 #rom_linter = FromLinter({}, set())
 #arn_linting = self.linting & WARN_LINTING
 #f toplevel:
 #elf.from_linter = from_linter
 #lse:
 #rom_linter = None
 #arn_linting = False

 #f froms:
 #ext += " \nFROM "

 #f select._hints:
 #ext += ", ".join(
 #
 #._compiler_dispatch(
 #elf,
 #sfrom=True,
 #romhints=byfrom,
 #rom_linter=from_linter,
 #*kwargs
 #
 #or f in froms
 #
 #
 #lse:
 #ext += ", ".join(
 #
 #._compiler_dispatch(
 #elf,
 #sfrom=True,
 #rom_linter=from_linter,
 #*kwargs
 #
 #or f in froms
 #
 #
 #lse:
 #ext += self.default_from()

 #f select._where_criteria:
 # = self._generate_delimited_and_list(
 #elect._where_criteria, from_linter=from_linter, **kwargs
 #
 #f t:
 #ext += " \nWHERE " + t

 #f warn_linting:
 #rom_linter.warn()

 #f select._group_by_clauses:
 #ext += self.group_by_clause(select, **kwargs)

 #f select._having_criteria:
 # = self._generate_delimited_and_list(
 #elect._having_criteria, **kwargs
 #
 #f t:
 #ext += " \nHAVING " + t

 #f select._order_by_clauses:
 #ext += self.order_by_clause(select, **kwargs)

 #f select._has_row_limiting_clause:
 #ext += self._row_limit_clause(select, **kwargs)

 #f select._for_update_arg is not None:
 #ext += self.for_update_clause(select, **kwargs)

 #eturn text

 #ef _generate_prefixes(self, stmt, prefixes, **kw):
 #lause = " ".join(
 #refix._compiler_dispatch(self, **kw)
 #or prefix, dialect_name in prefixes
 #f dialect_name is None or dialect_name == self.dialect.name
 #
 #f clause:
 #lause += " "
 #eturn clause

 #ef _render_cte_clause(self):
 #f self.positional:
 #elf.positiontup = (
 #um([self.cte_positional[cte] for cte in self.ctes], [])
 # self.positiontup
 #
 #te_text = self.get_cte_preamble(self.ctes_recursive) + " "
 #te_text += ", \n".join([txt for txt in self.ctes.values()])
 #te_text += "\n "
 #eturn cte_text

 #ef get_cte_preamble(self, recursive):
 #f recursive:
 #eturn "WITH RECURSIVE"
 #lse:
 #eturn "WITH"

 #ef get_select_precolumns(self, select, **kw):
 #""Called when building a ``SELECT`` statement, position is just
 #efore column list.

 #""
 #f select._distinct_on:
 #til.warn_deprecated(
 #DISTINCT ON is currently supported only by the PostgreSQL "
 #dialect.  Use of DISTINCT ON for other backends is currently "
 #silently ignored, however this usage is deprecated, and will "
 #raise CompileError in a future release for all backends "
 #that do not support this syntax.",
 #ersion="1.4",
 #
 #eturn "DISTINCT " if select._distinct else ""

 #ef group_by_clause(self, select, **kw):
 #""allow dialects to customize how GROUP BY is rendered."""

 #roup_by = self._generate_delimited_list(
 #elect._group_by_clauses, OPERATORS[operators.comma_op], **kw
 #
 #f group_by:
 #eturn " GROUP BY " + group_by
 #lse:
 #eturn ""

 #ef order_by_clause(self, select, **kw):
 #""allow dialects to customize how ORDER BY is rendered."""

 #rder_by = self._generate_delimited_list(
 #elect._order_by_clauses, OPERATORS[operators.comma_op], **kw
 #

 #f order_by:
 #eturn " ORDER BY " + order_by
 #lse:
 #eturn ""

 #ef for_update_clause(self, select, **kw):
 #eturn " FOR UPDATE"

 #ef returning_clause(self, stmt, returning_cols):
 #aise exc.CompileError(
 #RETURNING is not supported by this "
 #dialect's statement compiler."
 #

 #ef limit_clause(self, select, **kw):
 #ext = ""
 #f select._limit_clause is not None:
 #ext += "\n LIMIT " + self.process(select._limit_clause, **kw)
 #f select._offset_clause is not None:
 #f select._limit_clause is None:
 #ext += "\n LIMIT -1"
 #ext += " OFFSET " + self.process(select._offset_clause, **kw)
 #eturn text

 #ef fetch_clause(self, select, **kw):
 #ext = ""
 #f select._offset_clause is not None:
 #ext += "\n OFFSET %s ROWS" % self.process(
 #elect._offset_clause, **kw
 #
 #f select._fetch_clause is not None:
 #ext += "\n FETCH FIRST %s%s ROWS %s" % (
 #elf.process(select._fetch_clause, **kw),
 # PERCENT" if select._fetch_clause_options["percent"] else "",
 #WITH TIES"
 #f select._fetch_clause_options["with_ties"]
 #lse "ONLY",
 #
 #eturn text

 #ef visit_table(
 #elf,
 #able,
 #sfrom=False,
 #scrud=False,
 #shint=False,
 #romhints=None,
 #se_schema=True,
 #rom_linter=None,
 #*kwargs
 #:
 #f from_linter:
 #rom_linter.froms[table] = table.fullname

 #f asfrom or ashint:
 #ffective_schema = self.preparer.schema_for_object(table)

 #f use_schema and effective_schema:
 #et = (
 #elf.preparer.quote_schema(effective_schema)
 # "."
 # self.preparer.quote(table.name)
 #
 #lse:
 #et = self.preparer.quote(table.name)
 #f fromhints and table in fromhints:
 #et = self.format_from_hint_text(
 #et, table, fromhints[table], iscrud
 #
 #eturn ret
 #lse:
 #eturn ""

 #ef visit_join(self, join, asfrom=False, from_linter=None, **kwargs):
 #f from_linter:
 #rom_linter.edges.add((join.left, join.right))

 #f join.full:
 #oin_type = " FULL OUTER JOIN "
 #lif join.isouter:
 #oin_type = " LEFT OUTER JOIN "
 #lse:
 #oin_type = " JOIN "
 #eturn (
 #oin.left._compiler_dispatch(
 #elf, asfrom=True, from_linter=from_linter, **kwargs
 #
 # join_type
 # join.right._compiler_dispatch(
 #elf, asfrom=True, from_linter=from_linter, **kwargs
 #
 # " ON "
            # TODO: likely need asfrom=True here?
 # join.onclause._compiler_dispatch(
 #elf, from_linter=from_linter, **kwargs
 #
 #

 #ef _setup_crud_hints(self, stmt, table_text):
 #ialect_hints = dict(
 #
 #table, hint_text)
 #or (table, dialect), hint_text in stmt._hints.items()
 #f dialect in ("*", self.dialect.name)
 #
 #
 #f stmt.table in dialect_hints:
 #able_text = self.format_from_hint_text(
 #able_text, stmt.table, dialect_hints[stmt.table], True
 #
 #eturn dialect_hints, table_text

 #ef visit_insert(self, insert_stmt, **kw):

 #ompile_state = insert_stmt._compile_state_factory(
 #nsert_stmt, self, **kw
 #
 #nsert_stmt = compile_state.statement

 #oplevel = not self.stack

 #f toplevel:
 #elf.isinsert = True
 #f not self.compile_state:
 #elf.compile_state = compile_state

 #elf.stack.append(
 #
 #correlate_froms": set(),
 #asfrom_froms": set(),
 #selectable": insert_stmt,
 #
 #

 #rud_params = crud._get_crud_params(
 #elf, insert_stmt, compile_state, **kw
 #

 #f (
 #ot crud_params
 #nd not self.dialect.supports_default_values
 #nd not self.dialect.supports_default_metavalue
 #nd not self.dialect.supports_empty_insert
 #:
 #aise exc.CompileError(
 #The '%s' dialect with current database "
 #version settings does not support empty "
 #inserts." % self.dialect.name
 #

 #f compile_state._has_multi_parameters:
 #f not self.dialect.supports_multivalues_insert:
 #aise exc.CompileError(
 #The '%s' dialect with current database "
 #version settings does not support "
 #in-place multirow inserts." % self.dialect.name
 #
 #rud_params_single = crud_params[0]
 #lse:
 #rud_params_single = crud_params

 #reparer = self.preparer
 #upports_default_values = self.dialect.supports_default_values

 #ext = "INSERT "

 #f insert_stmt._prefixes:
 #ext += self._generate_prefixes(
 #nsert_stmt, insert_stmt._prefixes, **kw
 #

 #ext += "INTO "
 #able_text = preparer.format_table(insert_stmt.table)

 #f insert_stmt._hints:
 #, table_text = self._setup_crud_hints(insert_stmt, table_text)

 #f insert_stmt._independent_ctes:
 #or cte in insert_stmt._independent_ctes:
 #te._compiler_dispatch(self, **kw)

 #ext += table_text

 #f crud_params_single or not supports_default_values:
 #ext += " (%s)" % ", ".join(
 #expr for c, expr, value in crud_params_single]
 #

 #f self.returning or insert_stmt._returning:
 #eturning_clause = self.returning_clause(
 #nsert_stmt, self.returning or insert_stmt._returning
 #

 #f self.returning_precedes_values:
 #ext += " " + returning_clause
 #lse:
 #eturning_clause = None

 #f insert_stmt.select is not None:
 #elect_text = self.process(self._insert_from_select, **kw)

 #f self.ctes and toplevel and self.dialect.cte_follows_insert:
 #ext += " %s%s" % (self._render_cte_clause(), select_text)
 #lse:
 #ext += " %s" % select_text
 #lif not crud_params and supports_default_values:
 #ext += " DEFAULT VALUES"
 #lif compile_state._has_multi_parameters:
 #ext += " VALUES %s" % (
 #, ".join(
 #(%s)"
 # (", ".join(value for c, expr, value in crud_param_set))
 #or crud_param_set in crud_params
 #
 #
 #lse:
 #nsert_single_values_expr = ", ".join(
 #value for c, expr, value in crud_params]
 #
 #ext += " VALUES (%s)" % insert_single_values_expr
 #f toplevel and insert_stmt._post_values_clause is None:
                # don't assign insert_single_values_expr if _post_values_clause
                # is present.  what this means concretely is that the
                # "fast insert executemany helper" won't be used, in other
                # words we won't convert "executemany()" of many parameter
                # sets into a single INSERT with many elements in VALUES.
                # We can't apply that optimization safely if for example the
                # statement includes a clause like "ON CONFLICT DO UPDATE"
 #elf.insert_single_values_expr = insert_single_values_expr

 #f insert_stmt._post_values_clause is not None:
 #ost_values_clause = self.process(
 #nsert_stmt._post_values_clause, **kw
 #
 #f post_values_clause:
 #ext += " " + post_values_clause

 #f returning_clause and not self.returning_precedes_values:
 #ext += " " + returning_clause

 #f self.ctes and toplevel and not self.dialect.cte_follows_insert:
 #ext = self._render_cte_clause() + text

 #elf.stack.pop(-1)

 #eturn text

 #ef update_limit_clause(self, update_stmt):
 #""Provide a hook for MySQL to add LIMIT to the UPDATE"""
 #eturn None

 #ef update_tables_clause(self, update_stmt, from_table, extra_froms, **kw):
 #""Provide a hook to override the initial table clause
 #n an UPDATE statement.

 #ySQL overrides this.

 #""
 #w["asfrom"] = True
 #eturn from_table._compiler_dispatch(self, iscrud=True, **kw)

 #ef update_from_clause(
 #elf, update_stmt, from_table, extra_froms, from_hints, **kw
 #:
 #""Provide a hook to override the generation of an
 #PDATE..FROM clause.

 #ySQL and MSSQL override this.

 #""
 #aise NotImplementedError(
 #This backend does not support multiple-table "
 #criteria within UPDATE"
 #

 #ef visit_update(self, update_stmt, **kw):
 #ompile_state = update_stmt._compile_state_factory(
 #pdate_stmt, self, **kw
 #
 #pdate_stmt = compile_state.statement

 #oplevel = not self.stack
 #f toplevel:
 #elf.isupdate = True
 #f not self.compile_state:
 #elf.compile_state = compile_state

 #xtra_froms = compile_state._extra_froms
 #s_multitable = bool(extra_froms)

 #f is_multitable:
            # main table might be a JOIN
 #ain_froms = set(selectable._from_objects(update_stmt.table))
 #ender_extra_froms = [
 # for f in extra_froms if f not in main_froms
 #
 #orrelate_froms = main_froms.union(extra_froms)
 #lse:
 #ender_extra_froms = []
 #orrelate_froms = {update_stmt.table}

 #elf.stack.append(
 #
 #correlate_froms": correlate_froms,
 #asfrom_froms": correlate_froms,
 #selectable": update_stmt,
 #
 #

 #ext = "UPDATE "

 #f update_stmt._prefixes:
 #ext += self._generate_prefixes(
 #pdate_stmt, update_stmt._prefixes, **kw
 #

 #able_text = self.update_tables_clause(
 #pdate_stmt, update_stmt.table, render_extra_froms, **kw
 #
 #rud_params = crud._get_crud_params(
 #elf, update_stmt, compile_state, **kw
 #

 #f update_stmt._hints:
 #ialect_hints, table_text = self._setup_crud_hints(
 #pdate_stmt, table_text
 #
 #lse:
 #ialect_hints = None

 #f update_stmt._independent_ctes:
 #or cte in update_stmt._independent_ctes:
 #te._compiler_dispatch(self, **kw)

 #ext += table_text

 #ext += " SET "
 #ext += ", ".join(expr + "=" + value for c, expr, value in crud_params)

 #f self.returning or update_stmt._returning:
 #f self.returning_precedes_values:
 #ext += " " + self.returning_clause(
 #pdate_stmt, self.returning or update_stmt._returning
 #

 #f extra_froms:
 #xtra_from_text = self.update_from_clause(
 #pdate_stmt,
 #pdate_stmt.table,
 #ender_extra_froms,
 #ialect_hints,
 #*kw
 #
 #f extra_from_text:
 #ext += " " + extra_from_text

 #f update_stmt._where_criteria:
 # = self._generate_delimited_and_list(
 #pdate_stmt._where_criteria, **kw
 #
 #f t:
 #ext += " WHERE " + t

 #imit_clause = self.update_limit_clause(update_stmt)
 #f limit_clause:
 #ext += " " + limit_clause

 #f (
 #elf.returning or update_stmt._returning
 # and not self.returning_precedes_values:
 #ext += " " + self.returning_clause(
 #pdate_stmt, self.returning or update_stmt._returning
 #

 #f self.ctes and toplevel:
 #ext = self._render_cte_clause() + text

 #elf.stack.pop(-1)

 #eturn text

 #ef delete_extra_from_clause(
 #elf, update_stmt, from_table, extra_froms, from_hints, **kw
 #:
 #""Provide a hook to override the generation of an
 #ELETE..FROM clause.

 #his can be used to implement DELETE..USING for example.

 #ySQL and MSSQL override this.

 #""
 #aise NotImplementedError(
 #This backend does not support multiple-table "
 #criteria within DELETE"
 #

 #ef delete_table_clause(self, delete_stmt, from_table, extra_froms):
 #eturn from_table._compiler_dispatch(self, asfrom=True, iscrud=True)

 #ef visit_delete(self, delete_stmt, **kw):
 #ompile_state = delete_stmt._compile_state_factory(
 #elete_stmt, self, **kw
 #
 #elete_stmt = compile_state.statement

 #oplevel = not self.stack
 #f toplevel:
 #elf.isdelete = True
 #f not self.compile_state:
 #elf.compile_state = compile_state

 #xtra_froms = compile_state._extra_froms

 #orrelate_froms = {delete_stmt.table}.union(extra_froms)
 #elf.stack.append(
 #
 #correlate_froms": correlate_froms,
 #asfrom_froms": correlate_froms,
 #selectable": delete_stmt,
 #
 #

 #ext = "DELETE "

 #f delete_stmt._prefixes:
 #ext += self._generate_prefixes(
 #elete_stmt, delete_stmt._prefixes, **kw
 #

 #ext += "FROM "
 #able_text = self.delete_table_clause(
 #elete_stmt, delete_stmt.table, extra_froms
 #

 #f delete_stmt._hints:
 #ialect_hints, table_text = self._setup_crud_hints(
 #elete_stmt, table_text
 #
 #lse:
 #ialect_hints = None

 #f delete_stmt._independent_ctes:
 #or cte in delete_stmt._independent_ctes:
 #te._compiler_dispatch(self, **kw)

 #ext += table_text

 #f delete_stmt._returning:
 #f self.returning_precedes_values:
 #ext += " " + self.returning_clause(
 #elete_stmt, delete_stmt._returning
 #

 #f extra_froms:
 #xtra_from_text = self.delete_extra_from_clause(
 #elete_stmt,
 #elete_stmt.table,
 #xtra_froms,
 #ialect_hints,
 #*kw
 #
 #f extra_from_text:
 #ext += " " + extra_from_text

 #f delete_stmt._where_criteria:
 # = self._generate_delimited_and_list(
 #elete_stmt._where_criteria, **kw
 #
 #f t:
 #ext += " WHERE " + t

 #f delete_stmt._returning and not self.returning_precedes_values:
 #ext += " " + self.returning_clause(
 #elete_stmt, delete_stmt._returning
 #

 #f self.ctes and toplevel:
 #ext = self._render_cte_clause() + text

 #elf.stack.pop(-1)

 #eturn text

 #ef visit_savepoint(self, savepoint_stmt):
 #eturn "SAVEPOINT %s" % self.preparer.format_savepoint(savepoint_stmt)

 #ef visit_rollback_to_savepoint(self, savepoint_stmt):
 #eturn "ROLLBACK TO SAVEPOINT %s" % self.preparer.format_savepoint(
 #avepoint_stmt
 #

 #ef visit_release_savepoint(self, savepoint_stmt):
 #eturn "RELEASE SAVEPOINT %s" % self.preparer.format_savepoint(
 #avepoint_stmt
 #


class StrSQLCompiler(SQLCompiler):
 #""A :class:`.SQLCompiler` subclass which allows a small selection
 #f non-standard SQL features to render into a string value.

 #he :class:`.StrSQLCompiler` is invoked whenever a Core expression
 #lement is directly stringified without calling upon the
 #meth:`_expression.ClauseElement.compile` method.
 #t can render a limited set
 #f non-standard SQL constructs to assist in basic stringification,
 #owever for more substantial custom or dialect-specific SQL constructs,
 #t will be necessary to make use of
 #meth:`_expression.ClauseElement.compile`
 #irectly.

 #. seealso::

 #ref:`faq_sql_expression_string`

 #""

 #ef _fallback_column_name(self, column):
 #eturn "<name unknown>"

 #util.preload_module("sqlalchemy.engine.url")
 #ef visit_unsupported_compilation(self, element, err, **kw):
 #f element.stringify_dialect != "default":
 #rl = util.preloaded.engine_url
 #ialect = url.URL.create(element.stringify_dialect).get_dialect()()

 #ompiler = dialect.statement_compiler(dialect, None)
 #f not isinstance(compiler, StrSQLCompiler):
 #eturn compiler.process(element)

 #eturn super(StrSQLCompiler, self).visit_unsupported_compilation(
 #lement, err
 #

 #ef visit_getitem_binary(self, binary, operator, **kw):
 #eturn "%s[%s]" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef visit_json_getitem_op_binary(self, binary, operator, **kw):
 #eturn self.visit_getitem_binary(binary, operator, **kw)

 #ef visit_json_path_getitem_op_binary(self, binary, operator, **kw):
 #eturn self.visit_getitem_binary(binary, operator, **kw)

 #ef visit_sequence(self, seq, **kw):
 #eturn "<next sequence value: %s>" % self.preparer.format_sequence(seq)

 #ef returning_clause(self, stmt, returning_cols):
 #olumns = [
 #elf._label_select_column(None, c, True, False, {})
 #or c in base._select_iterables(returning_cols)
 #

 #eturn "RETURNING " + ", ".join(columns)

 #ef update_from_clause(
 #elf, update_stmt, from_table, extra_froms, from_hints, **kw
 #:
 #w["asfrom"] = True
 #eturn "FROM " + ", ".join(
 #._compiler_dispatch(self, fromhints=from_hints, **kw)
 #or t in extra_froms
 #

 #ef delete_extra_from_clause(
 #elf, update_stmt, from_table, extra_froms, from_hints, **kw
 #:
 #w["asfrom"] = True
 #eturn ", " + ", ".join(
 #._compiler_dispatch(self, fromhints=from_hints, **kw)
 #or t in extra_froms
 #

 #ef visit_empty_set_expr(self, type_):
 #eturn "SELECT 1 WHERE 1!=1"

 #ef get_from_hint_text(self, table, text):
 #eturn "[%s]" % text

 #ef visit_regexp_match_op_binary(self, binary, operator, **kw):
 #eturn self._generate_generic_binary(binary, " <regexp> ", **kw)

 #ef visit_not_regexp_match_op_binary(self, binary, operator, **kw):
 #eturn self._generate_generic_binary(binary, " <not regexp> ", **kw)

 #ef visit_regexp_replace_op_binary(self, binary, operator, **kw):
 #eplacement = binary.modifiers["replacement"]
 #eturn "<regexp replace>(%s, %s, %s)" % (
 #inary.left._compiler_dispatch(self, **kw),
 #inary.right._compiler_dispatch(self, **kw),
 #eplacement._compiler_dispatch(self, **kw),
 #


class DDLCompiler(Compiled):
 #util.memoized_property
 #ef sql_compiler(self):
 #eturn self.dialect.statement_compiler(
 #elf.dialect, None, schema_translate_map=self.schema_translate_map
 #

 #util.memoized_property
 #ef type_compiler(self):
 #eturn self.dialect.type_compiler

 #ef construct_params(self, params=None, extracted_parameters=None):
 #eturn None

 #ef visit_ddl(self, ddl, **kwargs):
        # table events can substitute table and schema name
 #ontext = ddl.context
 #f isinstance(ddl.target, schema.Table):
 #ontext = context.copy()

 #reparer = self.preparer
 #ath = preparer.format_table_seq(ddl.target)
 #f len(path) == 1:
 #able, sch = path[0], ""
 #lse:
 #able, sch = path[-1], path[0]

 #ontext.setdefault("table", table)
 #ontext.setdefault("schema", sch)
 #ontext.setdefault("fullname", preparer.format_table(ddl.target))

 #eturn self.sql_compiler.post_process_text(ddl.statement % context)

 #ef visit_create_schema(self, create, **kw):
 #chema = self.preparer.format_schema(create.element)
 #eturn "CREATE SCHEMA " + schema

 #ef visit_drop_schema(self, drop, **kw):
 #chema = self.preparer.format_schema(drop.element)
 #ext = "DROP SCHEMA " + schema
 #f drop.cascade:
 #ext += " CASCADE"
 #eturn text

 #ef visit_create_table(self, create, **kw):
 #able = create.element
 #reparer = self.preparer

 #ext = "\nCREATE "
 #f table._prefixes:
 #ext += " ".join(table._prefixes) + " "

 #ext += "TABLE "
 #f create.if_not_exists:
 #ext += "IF NOT EXISTS "

 #ext += preparer.format_table(table) + " "

 #reate_table_suffix = self.create_table_suffix(table)
 #f create_table_suffix:
 #ext += create_table_suffix + " "

 #ext += "("

 #eparator = "\n"

        # if only one primary key, specify it along with the column
 #irst_pk = False
 #or create_column in create.columns:
 #olumn = create_column.element
 #ry:
 #rocessed = self.process(
 #reate_column, first_pk=column.primary_key and not first_pk
 #
 #f processed is not None:
 #ext += separator
 #eparator = ", \n"
 #ext += "\t" + processed
 #f column.primary_key:
 #irst_pk = True
 #xcept exc.CompileError as ce:
 #til.raise_(
 #xc.CompileError(
 #til.u("(in table '%s', column '%s'): %s")
 # (table.description, column.name, ce.args[0])
 #,
 #rom_=ce,
 #

 #onst = self.create_table_constraints(
 #able,
 #include_foreign_key_constraints=create.include_foreign_key_constraints,  # noqa
 #
 #f const:
 #ext += separator + "\t" + const

 #ext += "\n)%s\n\n" % self.post_create_table(table)
 #eturn text

 #ef visit_create_column(self, create, first_pk=False, **kw):
 #olumn = create.element

 #f column.system:
 #eturn None

 #ext = self.get_column_specification(column, first_pk=first_pk)
 #onst = " ".join(
 #elf.process(constraint) for constraint in column.constraints
 #
 #f const:
 #ext += " " + const

 #eturn text

 #ef create_table_constraints(
 #elf, table, _include_foreign_key_constraints=None, **kw
 #:

        # On some DB order is significant: visit PK first, then the
        # other constraints (engine.ReflectionTest.testbasic failed on FB2)
 #onstraints = []
 #f table.primary_key:
 #onstraints.append(table.primary_key)

 #ll_fkcs = table.foreign_key_constraints
 #f _include_foreign_key_constraints is not None:
 #mit_fkcs = all_fkcs.difference(_include_foreign_key_constraints)
 #lse:
 #mit_fkcs = set()

 #onstraints.extend(
 #
 #
 #or c in table._sorted_constraints
 #f c is not table.primary_key and c not in omit_fkcs
 #
 #

 #eturn ", \n\t".join(
 #
 #or p in (
 #elf.process(constraint)
 #or constraint in constraints
 #f (
 #onstraint._create_rule is None
 #r constraint._create_rule(self)
 #
 #nd (
 #ot self.dialect.supports_alter
 #r not getattr(constraint, "use_alter", False)
 #
 #
 #f p is not None
 #

 #ef visit_drop_table(self, drop, **kw):
 #ext = "\nDROP TABLE "
 #f drop.if_exists:
 #ext += "IF EXISTS "
 #eturn text + self.preparer.format_table(drop.element)

 #ef visit_drop_view(self, drop, **kw):
 #eturn "\nDROP VIEW " + self.preparer.format_table(drop.element)

 #ef _verify_index_table(self, index):
 #f index.table is None:
 #aise exc.CompileError(
 #Index '%s' is not associated " "with any table." % index.name
 #

 #ef visit_create_index(
 #elf, create, include_schema=False, include_table_schema=True, **kw
 #:
 #ndex = create.element
 #elf._verify_index_table(index)
 #reparer = self.preparer
 #ext = "CREATE "
 #f index.unique:
 #ext += "UNIQUE "
 #f index.name is None:
 #aise exc.CompileError(
 #CREATE INDEX requires that the index have a name"
 #

 #ext += "INDEX "
 #f create.if_not_exists:
 #ext += "IF NOT EXISTS "

 #ext += "%s ON %s (%s)" % (
 #elf._prepared_index_name(index, include_schema=include_schema),
 #reparer.format_table(
 #ndex.table, use_schema=include_table_schema
 #,
 #, ".join(
 #elf.sql_compiler.process(
 #xpr, include_table=False, literal_binds=True
 #
 #or expr in index.expressions
 #,
 #
 #eturn text

 #ef visit_drop_index(self, drop, **kw):
 #ndex = drop.element

 #f index.name is None:
 #aise exc.CompileError(
 #DROP INDEX requires that the index have a name"
 #
 #ext = "\nDROP INDEX "
 #f drop.if_exists:
 #ext += "IF EXISTS "

 #eturn text + self._prepared_index_name(index, include_schema=True)

 #ef _prepared_index_name(self, index, include_schema=False):
 #f index.table is not None:
 #ffective_schema = self.preparer.schema_for_object(index.table)
 #lse:
 #ffective_schema = None
 #f include_schema and effective_schema:
 #chema_name = self.preparer.quote_schema(effective_schema)
 #lse:
 #chema_name = None

 #ndex_name = self.preparer.format_index(index)

 #f schema_name:
 #ndex_name = schema_name + "." + index_name
 #eturn index_name

 #ef visit_add_constraint(self, create, **kw):
 #eturn "ALTER TABLE %s ADD %s" % (
 #elf.preparer.format_table(create.element.table),
 #elf.process(create.element),
 #

 #ef visit_set_table_comment(self, create, **kw):
 #eturn "COMMENT ON TABLE %s IS %s" % (
 #elf.preparer.format_table(create.element),
 #elf.sql_compiler.render_literal_value(
 #reate.element.comment, sqltypes.String()
 #,
 #

 #ef visit_drop_table_comment(self, drop, **kw):
 #eturn "COMMENT ON TABLE %s IS NULL" % self.preparer.format_table(
 #rop.element
 #

 #ef visit_set_column_comment(self, create, **kw):
 #eturn "COMMENT ON COLUMN %s IS %s" % (
 #elf.preparer.format_column(
 #reate.element, use_table=True, use_schema=True
 #,
 #elf.sql_compiler.render_literal_value(
 #reate.element.comment, sqltypes.String()
 #,
 #

 #ef visit_drop_column_comment(self, drop, **kw):
 #eturn "COMMENT ON COLUMN %s IS NULL" % self.preparer.format_column(
 #rop.element, use_table=True
 #

 #ef get_identity_options(self, identity_options):
 #ext = []
 #f identity_options.increment is not None:
 #ext.append("INCREMENT BY %d" % identity_options.increment)
 #f identity_options.start is not None:
 #ext.append("START WITH %d" % identity_options.start)
 #f identity_options.minvalue is not None:
 #ext.append("MINVALUE %d" % identity_options.minvalue)
 #f identity_options.maxvalue is not None:
 #ext.append("MAXVALUE %d" % identity_options.maxvalue)
 #f identity_options.nominvalue is not None:
 #ext.append("NO MINVALUE")
 #f identity_options.nomaxvalue is not None:
 #ext.append("NO MAXVALUE")
 #f identity_options.cache is not None:
 #ext.append("CACHE %d" % identity_options.cache)
 #f identity_options.order is not None:
 #ext.append("ORDER" if identity_options.order else "NO ORDER")
 #f identity_options.cycle is not None:
 #ext.append("CYCLE" if identity_options.cycle else "NO CYCLE")
 #eturn " ".join(text)

 #ef visit_create_sequence(self, create, prefix=None, **kw):
 #ext = "CREATE SEQUENCE %s" % self.preparer.format_sequence(
 #reate.element
 #
 #f prefix:
 #ext += prefix
 #f create.element.start is None:
 #reate.element.start = self.dialect.default_sequence_base
 #ptions = self.get_identity_options(create.element)
 #f options:
 #ext += " " + options
 #eturn text

 #ef visit_drop_sequence(self, drop, **kw):
 #eturn "DROP SEQUENCE %s" % self.preparer.format_sequence(drop.element)

 #ef visit_drop_constraint(self, drop, **kw):
 #onstraint = drop.element
 #f constraint.name is not None:
 #ormatted_name = self.preparer.format_constraint(constraint)
 #lse:
 #ormatted_name = None

 #f formatted_name is None:
 #aise exc.CompileError(
 #Can't emit DROP CONSTRAINT for constraint %r; "
 #it has no name" % drop.element
 #
 #eturn "ALTER TABLE %s DROP CONSTRAINT %s%s" % (
 #elf.preparer.format_table(drop.element.table),
 #ormatted_name,
 #rop.cascade and " CASCADE" or "",
 #

 #ef get_column_specification(self, column, **kwargs):
 #olspec = (
 #elf.preparer.format_column(column)
 # " "
 # self.dialect.type_compiler.process(
 #olumn.type, type_expression=column
 #
 #
 #efault = self.get_column_default_string(column)
 #f default is not None:
 #olspec += " DEFAULT " + default

 #f column.computed is not None:
 #olspec += " " + self.process(column.computed)

 #f (
 #olumn.identity is not None
 #nd self.dialect.supports_identity_columns
 #:
 #olspec += " " + self.process(column.identity)

 #f not column.nullable and (
 #ot column.identity or not self.dialect.supports_identity_columns
 #:
 #olspec += " NOT NULL"
 #eturn colspec

 #ef create_table_suffix(self, table):
 #eturn ""

 #ef post_create_table(self, table):
 #eturn ""

 #ef get_column_default_string(self, column):
 #f isinstance(column.server_default, schema.DefaultClause):
 #f isinstance(column.server_default.arg, util.string_types):
 #eturn self.sql_compiler.render_literal_value(
 #olumn.server_default.arg, sqltypes.STRINGTYPE
 #
 #lse:
 #eturn self.sql_compiler.process(
 #olumn.server_default.arg, literal_binds=True
 #
 #lse:
 #eturn None

 #ef visit_table_or_column_check_constraint(self, constraint, **kw):
 #f constraint.is_column_level:
 #eturn self.visit_column_check_constraint(constraint)
 #lse:
 #eturn self.visit_check_constraint(constraint)

 #ef visit_check_constraint(self, constraint, **kw):
 #ext = ""
 #f constraint.name is not None:
 #ormatted_name = self.preparer.format_constraint(constraint)
 #f formatted_name is not None:
 #ext += "CONSTRAINT %s " % formatted_name
 #ext += "CHECK (%s)" % self.sql_compiler.process(
 #onstraint.sqltext, include_table=False, literal_binds=True
 #
 #ext += self.define_constraint_deferrability(constraint)
 #eturn text

 #ef visit_column_check_constraint(self, constraint, **kw):
 #ext = ""
 #f constraint.name is not None:
 #ormatted_name = self.preparer.format_constraint(constraint)
 #f formatted_name is not None:
 #ext += "CONSTRAINT %s " % formatted_name
 #ext += "CHECK (%s)" % self.sql_compiler.process(
 #onstraint.sqltext, include_table=False, literal_binds=True
 #
 #ext += self.define_constraint_deferrability(constraint)
 #eturn text

 #ef visit_primary_key_constraint(self, constraint, **kw):
 #f len(constraint) == 0:
 #eturn ""
 #ext = ""
 #f constraint.name is not None:
 #ormatted_name = self.preparer.format_constraint(constraint)
 #f formatted_name is not None:
 #ext += "CONSTRAINT %s " % formatted_name
 #ext += "PRIMARY KEY "
 #ext += "(%s)" % ", ".join(
 #elf.preparer.quote(c.name)
 #or c in (
 #onstraint.columns_autoinc_first
 #f constraint._implicit_generated
 #lse constraint.columns
 #
 #
 #ext += self.define_constraint_deferrability(constraint)
 #eturn text

 #ef visit_foreign_key_constraint(self, constraint, **kw):
 #reparer = self.preparer
 #ext = ""
 #f constraint.name is not None:
 #ormatted_name = self.preparer.format_constraint(constraint)
 #f formatted_name is not None:
 #ext += "CONSTRAINT %s " % formatted_name
 #emote_table = list(constraint.elements)[0].column.table
 #ext += "FOREIGN KEY(%s) REFERENCES %s (%s)" % (
 #, ".join(
 #reparer.quote(f.parent.name) for f in constraint.elements
 #,
 #elf.define_constraint_remote_table(
 #onstraint, remote_table, preparer
 #,
 #, ".join(
 #reparer.quote(f.column.name) for f in constraint.elements
 #,
 #
 #ext += self.define_constraint_match(constraint)
 #ext += self.define_constraint_cascades(constraint)
 #ext += self.define_constraint_deferrability(constraint)
 #eturn text

 #ef define_constraint_remote_table(self, constraint, table, preparer):
 #""Format the remote table clause of a CREATE CONSTRAINT clause."""

 #eturn preparer.format_table(table)

 #ef visit_unique_constraint(self, constraint, **kw):
 #f len(constraint) == 0:
 #eturn ""
 #ext = ""
 #f constraint.name is not None:
 #ormatted_name = self.preparer.format_constraint(constraint)
 #f formatted_name is not None:
 #ext += "CONSTRAINT %s " % formatted_name
 #ext += "UNIQUE (%s)" % (
 #, ".join(self.preparer.quote(c.name) for c in constraint)
 #
 #ext += self.define_constraint_deferrability(constraint)
 #eturn text

 #ef define_constraint_cascades(self, constraint):
 #ext = ""
 #f constraint.ondelete is not None:
 #ext += " ON DELETE %s" % self.preparer.validate_sql_phrase(
 #onstraint.ondelete, FK_ON_DELETE
 #
 #f constraint.onupdate is not None:
 #ext += " ON UPDATE %s" % self.preparer.validate_sql_phrase(
 #onstraint.onupdate, FK_ON_UPDATE
 #
 #eturn text

 #ef define_constraint_deferrability(self, constraint):
 #ext = ""
 #f constraint.deferrable is not None:
 #f constraint.deferrable:
 #ext += " DEFERRABLE"
 #lse:
 #ext += " NOT DEFERRABLE"
 #f constraint.initially is not None:
 #ext += " INITIALLY %s" % self.preparer.validate_sql_phrase(
 #onstraint.initially, FK_INITIALLY
 #
 #eturn text

 #ef define_constraint_match(self, constraint):
 #ext = ""
 #f constraint.match is not None:
 #ext += " MATCH %s" % constraint.match
 #eturn text

 #ef visit_computed_column(self, generated, **kw):
 #ext = "GENERATED ALWAYS AS (%s)" % self.sql_compiler.process(
 #enerated.sqltext, include_table=False, literal_binds=True
 #
 #f generated.persisted is True:
 #ext += " STORED"
 #lif generated.persisted is False:
 #ext += " VIRTUAL"
 #eturn text

 #ef visit_identity_column(self, identity, **kw):
 #ext = "GENERATED %s AS IDENTITY" % (
 #ALWAYS" if identity.always else "BY DEFAULT",
 #
 #ptions = self.get_identity_options(identity)
 #f options:
 #ext += " (%s)" % options
 #eturn text


class GenericTypeCompiler(TypeCompiler):
 #ef visit_FLOAT(self, type_, **kw):
 #eturn "FLOAT"

 #ef visit_REAL(self, type_, **kw):
 #eturn "REAL"

 #ef visit_NUMERIC(self, type_, **kw):
 #f type_.precision is None:
 #eturn "NUMERIC"
 #lif type_.scale is None:
 #eturn "NUMERIC(%(precision)s)" % {"precision": type_.precision}
 #lse:
 #eturn "NUMERIC(%(precision)s, %(scale)s)" % {
 #precision": type_.precision,
 #scale": type_.scale,
 #

 #ef visit_DECIMAL(self, type_, **kw):
 #f type_.precision is None:
 #eturn "DECIMAL"
 #lif type_.scale is None:
 #eturn "DECIMAL(%(precision)s)" % {"precision": type_.precision}
 #lse:
 #eturn "DECIMAL(%(precision)s, %(scale)s)" % {
 #precision": type_.precision,
 #scale": type_.scale,
 #

 #ef visit_INTEGER(self, type_, **kw):
 #eturn "INTEGER"

 #ef visit_SMALLINT(self, type_, **kw):
 #eturn "SMALLINT"

 #ef visit_BIGINT(self, type_, **kw):
 #eturn "BIGINT"

 #ef visit_TIMESTAMP(self, type_, **kw):
 #eturn "TIMESTAMP"

 #ef visit_DATETIME(self, type_, **kw):
 #eturn "DATETIME"

 #ef visit_DATE(self, type_, **kw):
 #eturn "DATE"

 #ef visit_TIME(self, type_, **kw):
 #eturn "TIME"

 #ef visit_CLOB(self, type_, **kw):
 #eturn "CLOB"

 #ef visit_NCLOB(self, type_, **kw):
 #eturn "NCLOB"

 #ef _render_string_type(self, type_, name):

 #ext = name
 #f type_.length:
 #ext += "(%d)" % type_.length
 #f type_.collation:
 #ext += ' COLLATE "%s"' % type_.collation
 #eturn text

 #ef visit_CHAR(self, type_, **kw):
 #eturn self._render_string_type(type_, "CHAR")

 #ef visit_NCHAR(self, type_, **kw):
 #eturn self._render_string_type(type_, "NCHAR")

 #ef visit_VARCHAR(self, type_, **kw):
 #eturn self._render_string_type(type_, "VARCHAR")

 #ef visit_NVARCHAR(self, type_, **kw):
 #eturn self._render_string_type(type_, "NVARCHAR")

 #ef visit_TEXT(self, type_, **kw):
 #eturn self._render_string_type(type_, "TEXT")

 #ef visit_BLOB(self, type_, **kw):
 #eturn "BLOB"

 #ef visit_BINARY(self, type_, **kw):
 #eturn "BINARY" + (type_.length and "(%d)" % type_.length or "")

 #ef visit_VARBINARY(self, type_, **kw):
 #eturn "VARBINARY" + (type_.length and "(%d)" % type_.length or "")

 #ef visit_BOOLEAN(self, type_, **kw):
 #eturn "BOOLEAN"

 #ef visit_large_binary(self, type_, **kw):
 #eturn self.visit_BLOB(type_, **kw)

 #ef visit_boolean(self, type_, **kw):
 #eturn self.visit_BOOLEAN(type_, **kw)

 #ef visit_time(self, type_, **kw):
 #eturn self.visit_TIME(type_, **kw)

 #ef visit_datetime(self, type_, **kw):
 #eturn self.visit_DATETIME(type_, **kw)

 #ef visit_date(self, type_, **kw):
 #eturn self.visit_DATE(type_, **kw)

 #ef visit_big_integer(self, type_, **kw):
 #eturn self.visit_BIGINT(type_, **kw)

 #ef visit_small_integer(self, type_, **kw):
 #eturn self.visit_SMALLINT(type_, **kw)

 #ef visit_integer(self, type_, **kw):
 #eturn self.visit_INTEGER(type_, **kw)

 #ef visit_real(self, type_, **kw):
 #eturn self.visit_REAL(type_, **kw)

 #ef visit_float(self, type_, **kw):
 #eturn self.visit_FLOAT(type_, **kw)

 #ef visit_numeric(self, type_, **kw):
 #eturn self.visit_NUMERIC(type_, **kw)

 #ef visit_string(self, type_, **kw):
 #eturn self.visit_VARCHAR(type_, **kw)

 #ef visit_unicode(self, type_, **kw):
 #eturn self.visit_VARCHAR(type_, **kw)

 #ef visit_text(self, type_, **kw):
 #eturn self.visit_TEXT(type_, **kw)

 #ef visit_unicode_text(self, type_, **kw):
 #eturn self.visit_TEXT(type_, **kw)

 #ef visit_enum(self, type_, **kw):
 #eturn self.visit_VARCHAR(type_, **kw)

 #ef visit_null(self, type_, **kw):
 #aise exc.CompileError(
 #Can't generate DDL for %r; "
 #did you forget to specify a "
 #type on this Column?" % type_
 #

 #ef visit_type_decorator(self, type_, **kw):
 #eturn self.process(type_.type_engine(self.dialect), **kw)

 #ef visit_user_defined(self, type_, **kw):
 #eturn type_.get_col_spec(**kw)


class StrSQLTypeCompiler(GenericTypeCompiler):
 #ef process(self, type_, **kw):
 #ry:
 #compiler_dispatch = type_._compiler_dispatch
 #xcept AttributeError:
 #eturn self._visit_unknown(type_, **kw)
 #lse:
 #eturn _compiler_dispatch(self, **kw)

 #ef __getattr__(self, key):
 #f key.startswith("visit_"):
 #eturn self._visit_unknown
 #lse:
 #aise AttributeError(key)

 #ef _visit_unknown(self, type_, **kw):
 #f type_.__class__.__name__ == type_.__class__.__name__.upper():
 #eturn type_.__class__.__name__
 #lse:
 #eturn repr(type_)

 #ef visit_null(self, type_, **kw):
 #eturn "NULL"

 #ef visit_user_defined(self, type_, **kw):
 #ry:
 #et_col_spec = type_.get_col_spec
 #xcept AttributeError:
 #eturn repr(type_)
 #lse:
 #eturn get_col_spec(**kw)


class IdentifierPreparer(object):

 #""Handle quoting and case-folding of identifiers based on options."""

 #eserved_words = RESERVED_WORDS

 #egal_characters = LEGAL_CHARACTERS

 #llegal_initial_characters = ILLEGAL_INITIAL_CHARACTERS

 #chema_for_object = operator.attrgetter("schema")
 #""Return the .schema attribute for an object.

 #or the default IdentifierPreparer, the schema for an object is always
 #he value of the ".schema" attribute.   if the preparer is replaced
 #ith one that has a non-empty schema_translate_map, the value of the
 #.schema" attribute is rendered a symbol that will be converted to a
 #eal schema name from the mapping post-compile.

 #""

 #ef __init__(
 #elf,
 #ialect,
 #nitial_quote='"',
 #inal_quote=None,
 #scape_quote='"',
 #uote_case_sensitive_collations=True,
 #mit_schema=False,
 #:
 #""Construct a new ``IdentifierPreparer`` object.

 #nitial_quote
 #haracter that begins a delimited identifier.

 #inal_quote
 #haracter that ends a delimited identifier. Defaults to
 #initial_quote`.

 #mit_schema
 #revent prepending schema name. Useful for databases that do
 #ot support schemae.
 #""

 #elf.dialect = dialect
 #elf.initial_quote = initial_quote
 #elf.final_quote = final_quote or self.initial_quote
 #elf.escape_quote = escape_quote
 #elf.escape_to_quote = self.escape_quote * 2
 #elf.omit_schema = omit_schema
 #elf.quote_case_sensitive_collations = quote_case_sensitive_collations
 #elf._strings = {}
 #elf._double_percents = self.dialect.paramstyle in (
 #format",
 #pyformat",
 #

 #ef _with_schema_translate(self, schema_translate_map):
 #rep = self.__class__.__new__(self.__class__)
 #rep.__dict__.update(self.__dict__)

 #ef symbol_getter(obj):
 #ame = obj.schema
 #f name in schema_translate_map and obj._use_schema_map:
 #f name is not None and ("[" in name or "]" in name):
 #aise exc.CompileError(
 #Square bracket characters ([]) not supported "
 #in schema translate name '%s'" % name
 #
 #eturn quoted_name(
 #[SCHEMA_%s]" % (name or "_none"), quote=False
 #
 #lse:
 #eturn obj.schema

 #rep.schema_for_object = symbol_getter
 #eturn prep

 #ef _render_schema_translates(self, statement, schema_translate_map):
 # = schema_translate_map
 #f None in d:
 #["_none"] = d[None]

 #ef replace(m):
 #ame = m.group(2)
 #ffective_schema = d[name]
 #f not effective_schema:
 #ffective_schema = self.dialect.default_schema_name
 #f not effective_schema:
                    # TODO: no coverage here
 #aise exc.CompileError(
 #Dialect has no default schema name; can't "
 #use None as dynamic schema target."
 #
 #eturn self.quote_schema(effective_schema)

 #eturn re.sub(r"(\[SCHEMA_([^\]]+)\])", replace, statement)

 #ef _escape_identifier(self, value):
 #""Escape an identifier.

 #ubclasses should override this to provide database-dependent
 #scaping behavior.
 #""

 #alue = value.replace(self.escape_quote, self.escape_to_quote)
 #f self._double_percents:
 #alue = value.replace("%", "%%")
 #eturn value

 #ef _unescape_identifier(self, value):
 #""Canonicalize an escaped identifier.

 #ubclasses should override this to provide database-dependent
 #nescaping behavior that reverses _escape_identifier.
 #""

 #eturn value.replace(self.escape_to_quote, self.escape_quote)

 #ef validate_sql_phrase(self, element, reg):
 #""keyword sequence filter.

 # filter for elements that are intended to represent keyword sequences,
 #uch as "INITIALLY", "INITIALLY DEFERRED", etc.   no special characters
 #hould be present.

 #. versionadded:: 1.3

 #""

 #f element is not None and not reg.match(element):
 #aise exc.CompileError(
 #Unexpected SQL phrase: %r (matching against %r)"
 # (element, reg.pattern)
 #
 #eturn element

 #ef quote_identifier(self, value):
 #""Quote an identifier.

 #ubclasses should override this to provide database-dependent
 #uoting behavior.
 #""

 #eturn (
 #elf.initial_quote
 # self._escape_identifier(value)
 # self.final_quote
 #

 #ef _requires_quotes(self, value):
 #""Return True if the given identifier requires quoting."""
 #c_value = value.lower()
 #eturn (
 #c_value in self.reserved_words
 #r value[0] in self.illegal_initial_characters
 #r not self.legal_characters.match(util.text_type(value))
 #r (lc_value != value)
 #

 #ef _requires_quotes_illegal_chars(self, value):
 #""Return True if the given identifier requires quoting, but
 #ot taking case convention into account."""
 #eturn not self.legal_characters.match(util.text_type(value))

 #ef quote_schema(self, schema, force=None):
 #""Conditionally quote a schema name.


 #he name is quoted if it is a reserved word, contains quote-necessary
 #haracters, or is an instance of :class:`.quoted_name` which includes
 #`quote`` set to ``True``.

 #ubclasses can override this to provide database-dependent
 #uoting behavior for schema names.

 #param schema: string schema name
 #param force: unused

 #. deprecated:: 0.9

 #he :paramref:`.IdentifierPreparer.quote_schema.force`
 #arameter is deprecated and will be removed in a future
 #elease.  This flag has no effect on the behavior of the
 #meth:`.IdentifierPreparer.quote` method; please refer to
 #class:`.quoted_name`.

 #""
 #f force is not None:
            # not using the util.deprecated_params() decorator in this
            # case because of the additional function call overhead on this
            # very performance-critical spot.
 #til.warn_deprecated(
 #The IdentifierPreparer.quote_schema.force parameter is "
 #deprecated and will be removed in a future release.  This "
 #flag has no effect on the behavior of the "
 #IdentifierPreparer.quote method; please refer to "
 #quoted_name().",
                # deprecated 0.9. warning from 1.3
 #ersion="0.9",
 #

 #eturn self.quote(schema)

 #ef quote(self, ident, force=None):
 #""Conditionally quote an identifier.

 #he identifier is quoted if it is a reserved word, contains
 #uote-necessary characters, or is an instance of
 #class:`.quoted_name` which includes ``quote`` set to ``True``.

 #ubclasses can override this to provide database-dependent
 #uoting behavior for identifier names.

 #param ident: string identifier
 #param force: unused

 #. deprecated:: 0.9

 #he :paramref:`.IdentifierPreparer.quote.force`
 #arameter is deprecated and will be removed in a future
 #elease.  This flag has no effect on the behavior of the
 #meth:`.IdentifierPreparer.quote` method; please refer to
 #class:`.quoted_name`.

 #""
 #f force is not None:
            # not using the util.deprecated_params() decorator in this
            # case because of the additional function call overhead on this
            # very performance-critical spot.
 #til.warn_deprecated(
 #The IdentifierPreparer.quote.force parameter is "
 #deprecated and will be removed in a future release.  This "
 #flag has no effect on the behavior of the "
 #IdentifierPreparer.quote method; please refer to "
 #quoted_name().",
                # deprecated 0.9. warning from 1.3
 #ersion="0.9",
 #

 #orce = getattr(ident, "quote", None)

 #f force is None:
 #f ident in self._strings:
 #eturn self._strings[ident]
 #lse:
 #f self._requires_quotes(ident):
 #elf._strings[ident] = self.quote_identifier(ident)
 #lse:
 #elf._strings[ident] = ident
 #eturn self._strings[ident]
 #lif force:
 #eturn self.quote_identifier(ident)
 #lse:
 #eturn ident

 #ef format_collation(self, collation_name):
 #f self.quote_case_sensitive_collations:
 #eturn self.quote(collation_name)
 #lse:
 #eturn collation_name

 #ef format_sequence(self, sequence, use_schema=True):
 #ame = self.quote(sequence.name)

 #ffective_schema = self.schema_for_object(sequence)

 #f (
 #ot self.omit_schema
 #nd use_schema
 #nd effective_schema is not None
 #:
 #ame = self.quote_schema(effective_schema) + "." + name
 #eturn name

 #ef format_label(self, label, name=None):
 #eturn self.quote(name or label.name)

 #ef format_alias(self, alias, name=None):
 #eturn self.quote(name or alias.name)

 #ef format_savepoint(self, savepoint, name=None):
        # Running the savepoint name through quoting is unnecessary
        # for all known dialects.  This is here to support potential
        # third party use cases
 #dent = name or savepoint.ident
 #f self._requires_quotes(ident):
 #dent = self.quote_identifier(ident)
 #eturn ident

 #util.preload_module("sqlalchemy.sql.naming")
 #ef format_constraint(self, constraint, _alembic_quote=True):
 #aming = util.preloaded.sql_naming

 #f constraint.name is elements._NONE_NAME:
 #ame = naming._constraint_name_for_table(
 #onstraint, constraint.table
 #

 #f name is None:
 #eturn None
 #lse:
 #ame = constraint.name

 #f constraint.__visit_name__ == "index":
 #eturn self.truncate_and_render_index_name(
 #ame, _alembic_quote=_alembic_quote
 #
 #lse:
 #eturn self.truncate_and_render_constraint_name(
 #ame, _alembic_quote=_alembic_quote
 #

 #ef truncate_and_render_index_name(self, name, _alembic_quote=True):
        # calculate these at format time so that ad-hoc changes
        # to dialect.max_identifier_length etc. can be reflected
        # as IdentifierPreparer is long lived
 #ax_ = (
 #elf.dialect.max_index_name_length
 #r self.dialect.max_identifier_length
 #
 #eturn self._truncate_and_render_maxlen_name(
 #ame, max_, _alembic_quote
 #

 #ef truncate_and_render_constraint_name(self, name, _alembic_quote=True):
        # calculate these at format time so that ad-hoc changes
        # to dialect.max_identifier_length etc. can be reflected
        # as IdentifierPreparer is long lived
 #ax_ = (
 #elf.dialect.max_constraint_name_length
 #r self.dialect.max_identifier_length
 #
 #eturn self._truncate_and_render_maxlen_name(
 #ame, max_, _alembic_quote
 #

 #ef _truncate_and_render_maxlen_name(self, name, max_, _alembic_quote):
 #f isinstance(name, elements._truncated_label):
 #f len(name) > max_:
 #ame = name[0 : max_ - 8] + "_" + util.md5_hex(name)[-4:]
 #lse:
 #elf.dialect.validate_identifier(name)

 #f not _alembic_quote:
 #eturn name
 #lse:
 #eturn self.quote(name)

 #ef format_index(self, index):
 #eturn self.format_constraint(index)

 #ef format_table(self, table, use_schema=True, name=None):
 #""Prepare a quoted table and schema name."""

 #f name is None:
 #ame = table.name

 #esult = self.quote(name)

 #ffective_schema = self.schema_for_object(table)

 #f not self.omit_schema and use_schema and effective_schema:
 #esult = self.quote_schema(effective_schema) + "." + result
 #eturn result

 #ef format_schema(self, name):
 #""Prepare a quoted schema name."""

 #eturn self.quote(name)

 #ef format_label_name(
 #elf,
 #ame,
 #non_map=None,
 #:
 #""Prepare a quoted column name."""

 #f anon_map is not None and isinstance(
 #ame, elements._truncated_label
 #:
 #ame = name.apply_map(anon_map)

 #eturn self.quote(name)

 #ef format_column(
 #elf,
 #olumn,
 #se_table=False,
 #ame=None,
 #able_name=None,
 #se_schema=False,
 #non_map=None,
 #:
 #""Prepare a quoted column name."""

 #f name is None:
 #ame = column.name

 #f anon_map is not None and isinstance(
 #ame, elements._truncated_label
 #:
 #ame = name.apply_map(anon_map)

 #f not getattr(column, "is_literal", False):
 #f use_table:
 #eturn (
 #elf.format_table(
 #olumn.table, use_schema=use_schema, name=table_name
 #
 # "."
 # self.quote(name)
 #
 #lse:
 #eturn self.quote(name)
 #lse:
            # literal textual elements get stuck into ColumnClause a lot,
            # which shouldn't get quoted

 #f use_table:
 #eturn (
 #elf.format_table(
 #olumn.table, use_schema=use_schema, name=table_name
 #
 # "."
 # name
 #
 #lse:
 #eturn name

 #ef format_table_seq(self, table, use_schema=True):
 #""Format table name and schema as a tuple."""

        # Dialects with more levels in their fully qualified references
        # ('database', 'owner', etc.) could override this and return
        # a longer sequence.

 #ffective_schema = self.schema_for_object(table)

 #f not self.omit_schema and use_schema and effective_schema:
 #eturn (
 #elf.quote_schema(effective_schema),
 #elf.format_table(table, use_schema=False),
 #
 #lse:
 #eturn (self.format_table(table, use_schema=False),)

 #util.memoized_property
 #ef _r_identifiers(self):
 #nitial, final, escaped_final = [
 #e.escape(s)
 #or s in (
 #elf.initial_quote,
 #elf.final_quote,
 #elf._escape_identifier(self.final_quote),
 #
 #
 # = re.compile(
 #"(?:"
 #"(?:%(initial)s((?:%(escaped)s|[^%(final)s])+)%(final)s"
 #"|([^\.]+))(?=\.|$))+"
 # {"initial": initial, "final": final, "escaped": escaped_final}
 #
 #eturn r

 #ef unformat_identifiers(self, identifiers):
 #""Unpack 'schema.table.column'-like strings into components."""

 # = self._r_identifiers
 #eturn [
 #elf._unescape_identifier(i)
 #or i in [a or b for a, b in r.findall(identifiers)]
 #
