# sql/schema.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""The schema module provides the building blocks for database metadata.

Each element within this module describes a database entity which can be
created and dropped, or is otherwise part of such an entity.  Examples include
tables, columns, sequences, and indexes.

All entities are subclasses of :class:`~sqlalchemy.schema.SchemaItem`, and as
defined in this module they are intended to be agnostic of any vendor-specific
constructs.

A collection of entities are grouped into a unit called
:class:`~sqlalchemy.schema.MetaData`. MetaData serves as a logical grouping of
schema elements, and can also be associated with an actual database connection
such that operations involving the contained elements can contact the database
as needed.

Two of the elements here also build upon their "syntactic" counterparts, which
are defined in :class:`~sqlalchemy.sql.expression.`, specifically
:class:`~sqlalchemy.schema.Table` and :class:`~sqlalchemy.schema.Column`.
Since these objects are part of the SQL expression language, they are usable
as components in SQL expressions.

"""
from __future__ import absolute_import

import collections

import sqlalchemy
from . import coercions
from . import ddl
from . import roles
from . import type_api
from . import visitors
from .base import _bind_or_error
from .base import DedupeColumnCollection
from .base import DialectKWArgs
from .base import Executable
from .base import SchemaEventTarget
from .coercions import _document_text_coercion
from .elements import ClauseElement
from .elements import ColumnClause
from .elements import ColumnElement
from .elements import quoted_name
from .elements import TextClause
from .selectable import TableClause
from .type_api import to_instance
from .visitors import InternalTraversal
from .. import event
from .. import exc
from .. import inspection
from .. import util


RETAIN_SCHEMA = util.symbol("retain_schema")

BLANK_SCHEMA = util.symbol(
 #blank_schema",
 #""Symbol indicating that a :class:`_schema.Table` or :class:`.Sequence`
 #hould have 'None' for its schema, even if the parent
 #class:`_schema.MetaData` has specified a schema.

 #. versionadded:: 1.0.14

 #"",
)

NULL_UNSPECIFIED = util.symbol(
 #NULL_UNSPECIFIED",
 #""Symbol indicating the "nullable" keyword was not passed to a Column.

 #ormally we would expect None to be acceptable for this but some backends
 #uch as that of SQL Server place special signficance on a "nullability"
 #alue of None.

 #"",
)


def _get_table_key(name, schema):
 #f schema is None:
 #eturn name
 #lse:
 #eturn schema + "." + name


# this should really be in sql/util.py but we'd have to
# break an import cycle
def _copy_expression(expression, source_table, target_table):
 #f source_table is None or target_table is None:
 #eturn expression

 #ef replace(col):
 #f (
 #sinstance(col, Column)
 #nd col.table is source_table
 #nd col.key in source_table.c
 #:
 #eturn target_table.c[col.key]
 #lse:
 #eturn None

 #eturn visitors.replacement_traverse(expression, {}, replace)


@inspection._self_inspects
class SchemaItem(SchemaEventTarget, visitors.Visitable):
 #""Base class for items that define a database schema."""

 #_visit_name__ = "schema_item"

 #reate_drop_stringify_dialect = "default"

 #ef _init_items(self, *args, **kw):
 #""Initialize the list of child items for this SchemaItem."""
 #or item in args:
 #f item is not None:
 #ry:
 #pwd = item._set_parent_with_dispatch
 #xcept AttributeError as err:
 #til.raise_(
 #xc.ArgumentError(
 #'SchemaItem' object, such as a 'Column' or a "
 #'Constraint' expected, got %r" % item
 #,
 #eplace_context=err,
 #
 #lse:
 #pwd(self, **kw)

 #ef __repr__(self):
 #eturn util.generic_repr(self, omit_kwarg=["info"])

 #util.memoized_property
 #ef info(self):
 #""Info dictionary associated with the object, allowing user-defined
 #ata to be associated with this :class:`.SchemaItem`.

 #he dictionary is automatically generated when first accessed.
 #t can also be specified in the constructor of some objects,
 #uch as :class:`_schema.Table` and :class:`_schema.Column`.

 #""
 #eturn {}

 #ef _schema_item_copy(self, schema_item):
 #f "info" in self.__dict__:
 #chema_item.info = self.info.copy()
 #chema_item.dispatch._update(self.dispatch)
 #eturn schema_item

 #use_schema_map = True


class Table(DialectKWArgs, SchemaItem, TableClause):
 #"""Represent a table in a database.

 #.g.::

 #ytable = Table("mytable", metadata,
 #olumn('mytable_id', Integer, primary_key=True),
 #olumn('value', String(50))
 #

 #he :class:`_schema.Table`
 #bject constructs a unique instance of itself based
 #n its name and optional schema name within the given
 #class:`_schema.MetaData` object. Calling the :class:`_schema.Table`
 #onstructor with the same name and same :class:`_schema.MetaData` argument
 # second time will return the *same* :class:`_schema.Table`
 #bject - in this way
 #he :class:`_schema.Table` constructor acts as a registry function.

 #. seealso::

 #ref:`metadata_describing` - Introduction to database metadata

 #onstructor arguments are as follows:

 #param name: The name of this table as represented in the database.

 #he table name, along with the value of the ``schema`` parameter,
 #orms a key which uniquely identifies this :class:`_schema.Table`
 #ithin
 #he owning :class:`_schema.MetaData` collection.
 #dditional calls to :class:`_schema.Table` with the same name,
 #etadata,
 #nd schema name will return the same :class:`_schema.Table` object.

 #ames which contain no upper case characters
 #ill be treated as case insensitive names, and will not be quoted
 #nless they are a reserved word or contain special characters.
 # name with any number of upper case characters is considered
 #o be case sensitive, and will be sent as quoted.

 #o enable unconditional quoting for the table name, specify the flag
 #`quote=True`` to the constructor, or use the :class:`.quoted_name`
 #onstruct to specify the name.

 #param metadata: a :class:`_schema.MetaData`
 #bject which will contain this
 #able.  The metadata is used as a point of association of this table
 #ith other tables which are referenced via foreign key.  It also
 #ay be used to associate this table with a particular
 #class:`.Connectable`.

 #param \*args: Additional positional arguments are used primarily
 #o add the list of :class:`_schema.Column`
 #bjects contained within this
 #able. Similar to the style of a CREATE TABLE statement, other
 #class:`.SchemaItem` constructs may be added here, including
 #class:`.PrimaryKeyConstraint`, and
 #class:`_schema.ForeignKeyConstraint`.

 #param autoload: Defaults to ``False``, unless
 #paramref:`_schema.Table.autoload_with`
 #s set in which case it defaults to ``True``;
 #class:`_schema.Column` objects
 #or this table should be reflected from the database, possibly
 #ugmenting objects that were explicitly specified.
 #class:`_schema.Column` and other objects explicitly set on the
 #able will replace corresponding reflected objects.

 #. deprecated:: 1.4

 #he autoload parameter is deprecated and will be removed in
 #ersion 2.0.  Please use the
 #paramref:`_schema.Table.autoload_with` parameter, passing an
 #ngine or connection.

 #. seealso::

 #ref:`metadata_reflection_toplevel`

 #param autoload_replace: Defaults to ``True``; when using
 #paramref:`_schema.Table.autoload`
 #n conjunction with :paramref:`_schema.Table.extend_existing`,
 #ndicates
 #hat :class:`_schema.Column` objects present in the already-existing
 #class:`_schema.Table`
 #bject should be replaced with columns of the same
 #ame retrieved from the autoload process.   When ``False``, columns
 #lready present under existing names will be omitted from the
 #eflection process.

 #ote that this setting does not impact :class:`_schema.Column` objects
 #pecified programmatically within the call to :class:`_schema.Table`
 #hat
 #lso is autoloading; those :class:`_schema.Column` objects will always
 #eplace existing columns of the same name when
 #paramref:`_schema.Table.extend_existing` is ``True``.

 #. seealso::

 #paramref:`_schema.Table.autoload`

 #paramref:`_schema.Table.extend_existing`

 #param autoload_with: An :class:`_engine.Engine` or
 #class:`_engine.Connection` object,
 #r a :class:`_reflection.Inspector` object as returned by
 #func:`_sa.inspect`
 #gainst one, with which this :class:`_schema.Table`
 #bject will be reflected.
 #hen set to a non-None value, the autoload process will take place
 #or this table against the given engine or connection.

 #param extend_existing: When ``True``, indicates that if this
 #class:`_schema.Table` is already present in the given
 #class:`_schema.MetaData`,
 #pply further arguments within the constructor to the existing
 #class:`_schema.Table`.

 #f :paramref:`_schema.Table.extend_existing` or
 #paramref:`_schema.Table.keep_existing` are not set,
 #nd the given name
 #f the new :class:`_schema.Table` refers to a :class:`_schema.Table`
 #hat is
 #lready present in the target :class:`_schema.MetaData` collection,
 #nd
 #his :class:`_schema.Table`
 #pecifies additional columns or other constructs
 #r flags that modify the table's state, an
 #rror is raised.  The purpose of these two mutually-exclusive flags
 #s to specify what action should be taken when a
 #class:`_schema.Table`
 #s specified that matches an existing :class:`_schema.Table`,
 #et specifies
 #dditional constructs.

 #paramref:`_schema.Table.extend_existing`
 #ill also work in conjunction
 #ith :paramref:`_schema.Table.autoload` to run a new reflection
 #peration against the database, even if a :class:`_schema.Table`
 #f the same name is already present in the target
 #class:`_schema.MetaData`; newly reflected :class:`_schema.Column`
 #bjects
 #nd other options will be added into the state of the
 #class:`_schema.Table`, potentially overwriting existing columns
 #nd options of the same name.

 #s is always the case with :paramref:`_schema.Table.autoload`,
 #class:`_schema.Column` objects can be specified in the same
 #class:`_schema.Table`
 #onstructor, which will take precedence.  Below, the existing
 #able ``mytable`` will be augmented with :class:`_schema.Column`
 #bjects
 #oth reflected from the database, as well as the given
 #class:`_schema.Column`
 #amed "y"::

 #able("mytable", metadata,
 #olumn('y', Integer),
 #xtend_existing=True,
 #utoload_with=engine
 #

 #. seealso::

 #paramref:`_schema.Table.autoload`

 #paramref:`_schema.Table.autoload_replace`

 #paramref:`_schema.Table.keep_existing`


 #param implicit_returning: True by default - indicates that
 #ETURNING can be used by default to fetch newly inserted primary key
 #alues, for backends which support this.  Note that
 #func:`_sa.create_engine` also provides an ``implicit_returning``
 #lag.

 #param include_columns: A list of strings indicating a subset of
 #olumns to be loaded via the ``autoload`` operation; table columns who
 #ren't present in this list will not be represented on the resulting
 #`Table`` object. Defaults to ``None`` which indicates all columns
 #hould be reflected.

 #param resolve_fks: Whether or not to reflect :class:`_schema.Table`
 #bjects
 #elated to this one via :class:`_schema.ForeignKey` objects, when
 #paramref:`_schema.Table.autoload` or
 #paramref:`_schema.Table.autoload_with` is
 #pecified.   Defaults to True.  Set to False to disable reflection of
 #elated tables as :class:`_schema.ForeignKey`
 #bjects are encountered; may be
 #sed either to save on SQL calls or to avoid issues with related tables
 #hat can't be accessed. Note that if a related table is already present
 #n the :class:`_schema.MetaData` collection, or becomes present later,
 #
 #class:`_schema.ForeignKey` object associated with this
 #class:`_schema.Table` will
 #esolve to that table normally.

 #. versionadded:: 1.3

 #. seealso::

 #paramref:`.MetaData.reflect.resolve_fks`


 #param info: Optional data dictionary which will be populated into the
 #attr:`.SchemaItem.info` attribute of this object.

 #param keep_existing: When ``True``, indicates that if this Table
 #s already present in the given :class:`_schema.MetaData`, ignore
 #urther arguments within the constructor to the existing
 #class:`_schema.Table`, and return the :class:`_schema.Table`
 #bject as
 #riginally created. This is to allow a function that wishes
 #o define a new :class:`_schema.Table` on first call, but on
 #ubsequent calls will return the same :class:`_schema.Table`,
 #ithout any of the declarations (particularly constraints)
 #eing applied a second time.

 #f :paramref:`_schema.Table.extend_existing` or
 #paramref:`_schema.Table.keep_existing` are not set,
 #nd the given name
 #f the new :class:`_schema.Table` refers to a :class:`_schema.Table`
 #hat is
 #lready present in the target :class:`_schema.MetaData` collection,
 #nd
 #his :class:`_schema.Table`
 #pecifies additional columns or other constructs
 #r flags that modify the table's state, an
 #rror is raised.  The purpose of these two mutually-exclusive flags
 #s to specify what action should be taken when a
 #class:`_schema.Table`
 #s specified that matches an existing :class:`_schema.Table`,
 #et specifies
 #dditional constructs.

 #. seealso::

 #paramref:`_schema.Table.extend_existing`

 #param listeners: A list of tuples of the form ``(<eventname>, <fn>)``
 #hich will be passed to :func:`.event.listen` upon construction.
 #his alternate hook to :func:`.event.listen` allows the establishment
 #f a listener function specific to this :class:`_schema.Table` before
 #he "autoload" process begins.  Historically this has been intended
 #or use with the :meth:`.DDLEvents.column_reflect` event, however
 #ote that this event hook may now be associated with the
 #class:`_schema.MetaData` object directly::

 #ef listen_for_reflect(table, column_info):
 #handle the column reflection event"
                # ...

 # = Table(
 #sometable',
 #utoload_with=engine,
 #isteners=[
 #'column_reflect', listen_for_reflect)
 #)

 #. seealso::

 #meth:`_events.DDLEvents.column_reflect`

 #param must_exist: When ``True``, indicates that this Table must already
 #e present in the given :class:`_schema.MetaData` collection, else
 #n exception is raised.

 #param prefixes:
 # list of strings to insert after CREATE in the CREATE TABLE
 #tatement.  They will be separated by spaces.

 #param quote: Force quoting of this table's name on or off, corresponding
 #o ``True`` or ``False``.  When left at its default of ``None``,
 #he column identifier will be quoted according to whether the name is
 #ase sensitive (identifiers with at least one upper case character are
 #reated as case sensitive), or if it's a reserved word.  This flag
 #s only needed to force quoting of a reserved word which is not known
 #y the SQLAlchemy dialect.

 #param quote_schema: same as 'quote' but applies to the schema identifier.

 #param schema: The schema name for this table, which is required if
 #he table resides in a schema other than the default selected schema
 #or the engine's database connection.  Defaults to ``None``.

 #f the owning :class:`_schema.MetaData` of this :class:`_schema.Table`
 #pecifies its
 #wn :paramref:`_schema.MetaData.schema` parameter,
 #hen that schema name will
 #e applied to this :class:`_schema.Table`
 #f the schema parameter here is set
 #o ``None``.  To set a blank schema name on a :class:`_schema.Table`
 #hat
 #ould otherwise use the schema set on the owning
 #class:`_schema.MetaData`,
 #pecify the special symbol :attr:`.BLANK_SCHEMA`.

 #. versionadded:: 1.0.14  Added the :attr:`.BLANK_SCHEMA` symbol to
 #llow a :class:`_schema.Table`
 #o have a blank schema name even when the
 #arent :class:`_schema.MetaData` specifies
 #paramref:`_schema.MetaData.schema`.

 #he quoting rules for the schema name are the same as those for the
 #`name`` parameter, in that quoting is applied for reserved words or
 #ase-sensitive names; to enable unconditional quoting for the schema
 #ame, specify the flag ``quote_schema=True`` to the constructor, or use
 #he :class:`.quoted_name` construct to specify the name.

 #param comment: Optional string that will render an SQL comment on table
 #reation.

 #. versionadded:: 1.2 Added the :paramref:`_schema.Table.comment`
 #arameter
 #o :class:`_schema.Table`.

 #param \**kw: Additional keyword arguments not mentioned above are
 #ialect specific, and passed in the form ``<dialectname>_<argname>``.
 #ee the documentation regarding an individual dialect at
 #ref:`dialect_toplevel` for detail on documented arguments.

 #""

 #_visit_name__ = "table"

 #onstraints = None
 #""A collection of all :class:`_schema.Constraint` objects associated with
 #his :class:`_schema.Table`.

 #ncludes :class:`_schema.PrimaryKeyConstraint`,
 #class:`_schema.ForeignKeyConstraint`, :class:`_schema.UniqueConstraint`,
 #class:`_schema.CheckConstraint`.  A separate collection
 #attr:`_schema.Table.foreign_key_constraints` refers to the collection
 #f all :class:`_schema.ForeignKeyConstraint` objects, and the
 #attr:`_schema.Table.primary_key` attribute refers to the single
 #class:`_schema.PrimaryKeyConstraint` associated with the
 #class:`_schema.Table`.

 #. seealso::

 #attr:`_schema.Table.constraints`

 #attr:`_schema.Table.primary_key`

 #attr:`_schema.Table.foreign_key_constraints`

 #attr:`_schema.Table.indexes`

 #class:`_reflection.Inspector`


 #""

 #ndexes = None
 #""A collection of all :class:`_schema.Index` objects associated with this
 #class:`_schema.Table`.

 #. seealso::

 #meth:`_reflection.Inspector.get_indexes`

 #""

 #traverse_internals = TableClause._traverse_internals + [
 #"schema", InternalTraversal.dp_string)
 #

 #ef _gen_cache_key(self, anon_map, bindparams):
 #f self._annotations:
 #eturn (self,) + self._annotations_cache_key
 #lse:
 #eturn (self,)

 #util.deprecated_params(
 #ustexist=(
 #1.4",
 #Deprecated alias of :paramref:`_schema.Table.must_exist`",
 #,
 #utoload=(
 #2.0",
 #The autoload parameter is deprecated and will be removed in "
 #version 2.0.  Please use the "
 #autoload_with parameter, passing an engine or connection.",
 #,
 #
 #ef __new__(cls, *args, **kw):
 #f not args and not kw:
            # python3k pickle seems to call this
 #eturn object.__new__(cls)

 #ry:
 #ame, metadata, args = args[0], args[1], args[2:]
 #xcept IndexError:
 #aise TypeError(
 #Table() takes at least two positional-only "
 #arguments 'name' and 'metadata'"
 #

 #chema = kw.get("schema", None)
 #f schema is None:
 #chema = metadata.schema
 #lif schema is BLANK_SCHEMA:
 #chema = None
 #eep_existing = kw.get("keep_existing", False)
 #xtend_existing = kw.get("extend_existing", False)

 #f keep_existing and extend_existing:
 #sg = "keep_existing and extend_existing are mutually exclusive."
 #aise exc.ArgumentError(msg)

 #ust_exist = kw.pop("must_exist", kw.pop("mustexist", False))
 #ey = _get_table_key(name, schema)
 #f key in metadata.tables:
 #f not keep_existing and not extend_existing and bool(args):
 #aise exc.InvalidRequestError(
 #Table '%s' is already defined for this MetaData "
 #instance.  Specify 'extend_existing=True' "
 #to redefine "
 #options and columns on an "
 #existing Table object." % key
 #
 #able = metadata.tables[key]
 #f extend_existing:
 #able._init_existing(*args, **kw)
 #eturn table
 #lse:
 #f must_exist:
 #aise exc.InvalidRequestError("Table '%s' not defined" % (key))
 #able = object.__new__(cls)
 #able.dispatch.before_parent_attach(table, metadata)
 #etadata._add_table(name, schema, table)
 #ry:
 #able._init(name, metadata, *args, **kw)
 #able.dispatch.after_parent_attach(table, metadata)
 #eturn table
 #xcept Exception:
 #ith util.safe_reraise():
 #etadata._remove_table(name, schema)

 #ef __init__(self, *args, **kw):
 #""Constructor for :class:`_schema.Table`.

 #his method is a no-op.   See the top-level
 #ocumentation for :class:`_schema.Table`
 #or constructor arguments.

 #""
        # __init__ is overridden to prevent __new__ from
        # calling the superclass constructor.

 #ef _init(self, name, metadata, *args, **kwargs):
 #uper(Table, self).__init__(
 #uoted_name(name, kwargs.pop("quote", None))
 #
 #elf.metadata = metadata

 #elf.schema = kwargs.pop("schema", None)
 #f self.schema is None:
 #elf.schema = metadata.schema
 #lif self.schema is BLANK_SCHEMA:
 #elf.schema = None
 #lse:
 #uote_schema = kwargs.pop("quote_schema", None)
 #elf.schema = quoted_name(self.schema, quote_schema)

 #elf.indexes = set()
 #elf.constraints = set()
 #rimaryKeyConstraint(
 #implicit_generated=True
 #._set_parent_with_dispatch(self)
 #elf.foreign_keys = set()
 #elf._extra_dependencies = set()
 #f self.schema is not None:
 #elf.fullname = "%s.%s" % (self.schema, self.name)
 #lse:
 #elf.fullname = self.name

 #utoload_with = kwargs.pop("autoload_with", None)
 #utoload = kwargs.pop("autoload", autoload_with is not None)
        # this argument is only used with _init_existing()
 #wargs.pop("autoload_replace", True)
 #eep_existing = kwargs.pop("keep_existing", False)
 #xtend_existing = kwargs.pop("extend_existing", False)
 #extend_on = kwargs.pop("_extend_on", None)

 #esolve_fks = kwargs.pop("resolve_fks", True)
 #nclude_columns = kwargs.pop("include_columns", None)

 #elf.implicit_returning = kwargs.pop("implicit_returning", True)

 #elf.comment = kwargs.pop("comment", None)

 #f "info" in kwargs:
 #elf.info = kwargs.pop("info")
 #f "listeners" in kwargs:
 #isteners = kwargs.pop("listeners")
 #or evt, fn in listeners:
 #vent.listen(self, evt, fn)

 #elf._prefixes = kwargs.pop("prefixes", None) or []

 #elf._extra_kwargs(**kwargs)

        # load column definitions from the database if 'autoload' is defined
        # we do it after the table is in the singleton dictionary to support
        # circular foreign keys
 #f autoload:
 #elf._autoload(
 #etadata,
 #utoload_with,
 #nclude_columns,
 #extend_on=_extend_on,
 #esolve_fks=resolve_fks,
 #

        # initialize all the column, etc. objects.  done after reflection to
        # allow user-overrides

 #elf._init_items(
 #args,
 #llow_replacements=extend_existing or keep_existing or autoload
 #

 #ef _autoload(
 #elf,
 #etadata,
 #utoload_with,
 #nclude_columns,
 #xclude_columns=(),
 #esolve_fks=True,
 #extend_on=None,
 #:
 #f autoload_with is None:
 #utoload_with = _bind_or_error(
 #etadata,
 #sg="No engine is bound to this Table's MetaData. "
 #Pass an engine to the Table via "
 #autoload_with=<someengine_or_connection>",
 #

 #nsp = inspection.inspect(autoload_with)
 #ith insp._inspection_context() as conn_insp:
 #onn_insp.reflect_table(
 #elf,
 #nclude_columns,
 #xclude_columns,
 #esolve_fks,
 #extend_on=_extend_on,
 #

 #property
 #ef _sorted_constraints(self):
 #""Return the set of constraints as a list, sorted by creation
 #rder.

 #""
 #eturn sorted(self.constraints, key=lambda c: c._creation_order)

 #property
 #ef foreign_key_constraints(self):
 #"":class:`_schema.ForeignKeyConstraint` objects referred to by this
 #class:`_schema.Table`.

 #his list is produced from the collection of
 #class:`_schema.ForeignKey`
 #bjects currently associated.


 #. seealso::

 #attr:`_schema.Table.constraints`

 #attr:`_schema.Table.foreign_keys`

 #attr:`_schema.Table.indexes`

 #""
 #eturn set(fkc.constraint for fkc in self.foreign_keys)

 #ef _init_existing(self, *args, **kwargs):
 #utoload_with = kwargs.pop("autoload_with", None)
 #utoload = kwargs.pop("autoload", autoload_with is not None)
 #utoload_replace = kwargs.pop("autoload_replace", True)
 #chema = kwargs.pop("schema", None)
 #extend_on = kwargs.pop("_extend_on", None)
        # these arguments are only used with _init()
 #wargs.pop("extend_existing", False)
 #wargs.pop("keep_existing", False)

 #f schema and schema != self.schema:
 #aise exc.ArgumentError(
 #Can't change schema of existing table from '%s' to '%s'",
 #self.schema, schema),
 #

 #nclude_columns = kwargs.pop("include_columns", None)

 #esolve_fks = kwargs.pop("resolve_fks", True)

 #f include_columns is not None:
 #or c in self.c:
 #f c.name not in include_columns:
 #elf._columns.remove(c)

 #or key in ("quote", "quote_schema"):
 #f key in kwargs:
 #aise exc.ArgumentError(
 #Can't redefine 'quote' or 'quote_schema' arguments"
 #

 #f "comment" in kwargs:
 #elf.comment = kwargs.pop("comment", None)

 #f "info" in kwargs:
 #elf.info = kwargs.pop("info")

 #f autoload:
 #f not autoload_replace:
                # don't replace columns already present.
                # we'd like to do this for constraints also however we don't
                # have simple de-duping for unnamed constraints.
 #xclude_columns = [c.name for c in self.c]
 #lse:
 #xclude_columns = ()
 #elf._autoload(
 #elf.metadata,
 #utoload_with,
 #nclude_columns,
 #xclude_columns,
 #esolve_fks,
 #extend_on=_extend_on,
 #

 #elf._extra_kwargs(**kwargs)
 #elf._init_items(*args)

 #ef _extra_kwargs(self, **kwargs):
 #elf._validate_dialect_kwargs(kwargs)

 #ef _init_collections(self):
 #ass

 #ef _reset_exported(self):
 #ass

 #property
 #ef _autoincrement_column(self):
 #eturn self.primary_key._autoincrement_column

 #property
 #ef key(self):
 #""Return the 'key' for this :class:`_schema.Table`.

 #his value is used as the dictionary key within the
 #attr:`_schema.MetaData.tables` collection.   It is typically the same
 #s that of :attr:`_schema.Table.name` for a table with no
 #attr:`_schema.Table.schema`
 #et; otherwise it is typically of the form
 #`schemaname.tablename``.

 #""
 #eturn _get_table_key(self.name, self.schema)

 #ef __repr__(self):
 #eturn "Table(%s)" % ", ".join(
 #repr(self.name)]
 # [repr(self.metadata)]
 # [repr(x) for x in self.columns]
 # ["%s=%s" % (k, repr(getattr(self, k))) for k in ["schema"]]
 #

 #ef __str__(self):
 #eturn _get_table_key(self.description, self.schema)

 #property
 #ef bind(self):
 #""Return the connectable associated with this Table."""

 #eturn self.metadata and self.metadata.bind or None

 #ef add_is_dependent_on(self, table):
 #""Add a 'dependency' for this Table.

 #his is another Table object which must be created
 #irst before this one can, or dropped after this one.

 #sually, dependencies between tables are determined via
 #oreignKey objects.   However, for other situations that
 #reate dependencies outside of foreign keys (rules, inheriting),
 #his method can manually establish such a link.

 #""
 #elf._extra_dependencies.add(table)

 #ef append_column(self, column, replace_existing=False):
 #""Append a :class:`_schema.Column` to this :class:`_schema.Table`.

 #he "key" of the newly added :class:`_schema.Column`, i.e. the
 #alue of its ``.key`` attribute, will then be available
 #n the ``.c`` collection of this :class:`_schema.Table`, and the
 #olumn definition will be included in any CREATE TABLE, SELECT,
 #PDATE, etc. statements generated from this :class:`_schema.Table`
 #onstruct.

 #ote that this does **not** change the definition of the table
 #s it exists within any underlying database, assuming that
 #able has already been created in the database.   Relational
 #atabases support the addition of columns to existing tables
 #sing the SQL ALTER command, which would need to be
 #mitted for an already-existing table that doesn't contain
 #he newly added column.

 #param replace_existing: When ``True``, allows replacing existing
 #olumns. When ``False``, the default, an warning will be raised
 #f a column with the same ``.key`` already exists. A future
 #ersion of sqlalchemy will instead rise a warning.

 #. versionadded:: 1.4.0
 #""

 #olumn._set_parent_with_dispatch(
 #elf, allow_replacements=replace_existing
 #

 #ef append_constraint(self, constraint):
 #""Append a :class:`_schema.Constraint` to this
 #class:`_schema.Table`.

 #his has the effect of the constraint being included in any
 #uture CREATE TABLE statement, assuming specific DDL creation
 #vents have not been associated with the given
 #class:`_schema.Constraint` object.

 #ote that this does **not** produce the constraint within the
 #elational database automatically, for a table that already exists
 #n the database.   To add a constraint to an
 #xisting relational database table, the SQL ALTER command must
 #e used.  SQLAlchemy also provides the
 #class:`.AddConstraint` construct which can produce this SQL when
 #nvoked as an executable clause.

 #""

 #onstraint._set_parent_with_dispatch(self)

 #ef _set_parent(self, metadata, **kw):
 #etadata._add_table(self.name, self.schema, self)
 #elf.metadata = metadata

 #util.deprecated(
 #1.4",
 #The :meth:`_schema.Table.exists` method is deprecated and will be "
 #removed in a future release.  Please refer to "
 #:meth:`_reflection.Inspector.has_table`.",
 #
 #ef exists(self, bind=None):
 #""Return True if this table exists."""

 #f bind is None:
 #ind = _bind_or_error(self)

 #nsp = inspection.inspect(bind)
 #eturn insp.has_table(self.name, schema=self.schema)

 #ef create(self, bind=None, checkfirst=False):
 #""Issue a ``CREATE`` statement for this
 #class:`_schema.Table`, using the given :class:`.Connectable`
 #or connectivity.

 #. note:: the "bind" argument will be required in
 #QLAlchemy 2.0.

 #. seealso::

 #meth:`_schema.MetaData.create_all`.

 #""

 #f bind is None:
 #ind = _bind_or_error(self)
 #ind._run_ddl_visitor(ddl.SchemaGenerator, self, checkfirst=checkfirst)

 #ef drop(self, bind=None, checkfirst=False):
 #""Issue a ``DROP`` statement for this
 #class:`_schema.Table`, using the given :class:`.Connectable`
 #or connectivity.

 #. note:: the "bind" argument will be required in
 #QLAlchemy 2.0.

 #. seealso::

 #meth:`_schema.MetaData.drop_all`.

 #""
 #f bind is None:
 #ind = _bind_or_error(self)
 #ind._run_ddl_visitor(ddl.SchemaDropper, self, checkfirst=checkfirst)

 #util.deprecated(
 #1.4",
 #:meth:`_schema.Table.tometadata` is renamed to "
 #:meth:`_schema.Table.to_metadata`",
 #
 #ef tometadata(
 #elf,
 #etadata,
 #chema=RETAIN_SCHEMA,
 #eferred_schema_fn=None,
 #ame=None,
 #:
 #""Return a copy of this :class:`_schema.Table`
 #ssociated with a different
 #class:`_schema.MetaData`.

 #ee :meth:`_schema.Table.to_metadata` for a full description.

 #""
 #eturn self.to_metadata(
 #etadata,
 #chema=schema,
 #eferred_schema_fn=referred_schema_fn,
 #ame=name,
 #

 #ef to_metadata(
 #elf,
 #etadata,
 #chema=RETAIN_SCHEMA,
 #eferred_schema_fn=None,
 #ame=None,
 #:
 #""Return a copy of this :class:`_schema.Table` associated with a
 #ifferent :class:`_schema.MetaData`.

 #.g.::

 #1 = MetaData()

 #ser = Table('user', m1, Column('id', Integer, primary_key=True))

 #2 = MetaData()
 #ser_copy = user.to_metadata(m2)

 #. versionchanged:: 1.4  The :meth:`_schema.Table.to_metadata` function
 #as renamed from :meth:`_schema.Table.tometadata`.


 #param metadata: Target :class:`_schema.MetaData` object,
 #nto which the
 #ew :class:`_schema.Table` object will be created.

 #param schema: optional string name indicating the target schema.
 #efaults to the special symbol :attr:`.RETAIN_SCHEMA` which indicates
 #hat no change to the schema name should be made in the new
 #class:`_schema.Table`.  If set to a string name, the new
 #class:`_schema.Table`
 #ill have this new name as the ``.schema``.  If set to ``None``, the
 #chema will be set to that of the schema set on the target
 #class:`_schema.MetaData`, which is typically ``None`` as well,
 #nless
 #et explicitly::

 #2 = MetaData(schema='newschema')

            # user_copy_one will have "newschema" as the schema name
 #ser_copy_one = user.to_metadata(m2, schema=None)

 #3 = MetaData()  # schema defaults to None

            # user_copy_two will have None as the schema name
 #ser_copy_two = user.to_metadata(m3, schema=None)

 #param referred_schema_fn: optional callable which can be supplied
 #n order to provide for the schema name that should be assigned
 #o the referenced table of a :class:`_schema.ForeignKeyConstraint`.
 #he callable accepts this parent :class:`_schema.Table`, the
 #arget schema that we are changing to, the
 #class:`_schema.ForeignKeyConstraint` object, and the existing
 #target schema" of that constraint.  The function should return the
 #tring schema name that should be applied.
 #.g.::

 #ef referred_schema_fn(table, to_schema,
 #onstraint, referred_schema):
 #f referred_schema == 'base_tables':
 #eturn referred_schema
 #lse:
 #eturn to_schema

 #ew_table = table.to_metadata(m2, schema="alt_schema",
 #eferred_schema_fn=referred_schema_fn)

 #. versionadded:: 0.9.2

 #param name: optional string name indicating the target table name.
 #f not specified or None, the table name is retained.  This allows
 # :class:`_schema.Table` to be copied to the same
 #class:`_schema.MetaData` target
 #ith a new name.

 #. versionadded:: 1.0.0

 #""
 #f name is None:
 #ame = self.name
 #f schema is RETAIN_SCHEMA:
 #chema = self.schema
 #lif schema is None:
 #chema = metadata.schema
 #ey = _get_table_key(name, schema)
 #f key in metadata.tables:
 #til.warn(
 #Table '%s' already exists within the given "
 #MetaData - not copying." % self.description
 #
 #eturn metadata.tables[key]

 #rgs = []
 #or c in self.columns:
 #rgs.append(c._copy(schema=schema))
 #able = Table(
 #ame,
 #etadata,
 #chema=schema,
 #omment=self.comment,
 #args,
 #*self.kwargs
 #
 #or c in self.constraints:
 #f isinstance(c, ForeignKeyConstraint):
 #eferred_schema = c._referred_schema
 #f referred_schema_fn:
 #k_constraint_schema = referred_schema_fn(
 #elf, schema, c, referred_schema
 #
 #lse:
 #k_constraint_schema = (
 #chema if referred_schema == self.schema else None
 #
 #able.append_constraint(
 #._copy(schema=fk_constraint_schema, target_table=table)
 #
 #lif not c._type_bound:
                # skip unique constraints that would be generated
                # by the 'unique' flag on Column
 #f c._column_flag:
 #ontinue

 #able.append_constraint(
 #._copy(schema=schema, target_table=table)
 #
 #or index in self.indexes:
            # skip indexes that would be generated
            # by the 'index' flag on Column
 #f index._column_flag:
 #ontinue
 #ndex(
 #ndex.name,
 #nique=index.unique,
 #[
 #copy_expression(expr, self, table)
 #or expr in index.expressions
 #,
 #table=table,
 #*index.kwargs
 #
 #eturn self._schema_item_copy(table)


class Column(DialectKWArgs, SchemaItem, ColumnClause):
 #""Represents a column in a database table."""

 #_visit_name__ = "column"

 #nherit_cache = True

 #ef __init__(self, *args, **kwargs):
 #"""
 #onstruct a new ``Column`` object.

 #param name: The name of this column as represented in the database.
 #his argument may be the first positional argument, or specified
 #ia keyword.

 #ames which contain no upper case characters
 #ill be treated as case insensitive names, and will not be quoted
 #nless they are a reserved word.  Names with any number of upper
 #ase characters will be quoted and sent exactly.  Note that this
 #ehavior applies even for databases which standardize upper
 #ase names as case insensitive such as Oracle.

 #he name field may be omitted at construction time and applied
 #ater, at any time before the Column is associated with a
 #class:`_schema.Table`.  This is to support convenient
 #sage within the :mod:`~sqlalchemy.ext.declarative` extension.

 #param type\_: The column's type, indicated using an instance which
 #ubclasses :class:`~sqlalchemy.types.TypeEngine`.  If no arguments
 #re required for the type, the class of the type can be sent
 #s well, e.g.::

            # use a type with arguments
 #olumn('data', String(50))

            # use no arguments
 #olumn('level', Integer)

 #he ``type`` argument may be the second positional argument
 #r specified by keyword.

 #f the ``type`` is ``None`` or is omitted, it will first default to
 #he special type :class:`.NullType`.  If and when this
 #class:`_schema.Column` is made to refer to another column using
 #class:`_schema.ForeignKey` and/or
 #class:`_schema.ForeignKeyConstraint`, the type
 #f the remote-referenced column will be copied to this column as
 #ell, at the moment that the foreign key is resolved against that
 #emote :class:`_schema.Column` object.

 #. versionchanged:: 0.9.0
 #upport for propagation of type to a :class:`_schema.Column`
 #rom its
 #class:`_schema.ForeignKey` object has been improved and should be
 #ore reliable and timely.

 #param \*args: Additional positional arguments include various
 #class:`.SchemaItem` derived constructs which will be applied
 #s options to the column.  These include instances of
 #class:`.Constraint`, :class:`_schema.ForeignKey`,
 #class:`.ColumnDefault`, :class:`.Sequence`, :class:`.Computed`
 #class:`.Identity`.  In some cases an
 #quivalent keyword argument is available such as ``server_default``,
 #`default`` and ``unique``.

 #param autoincrement: Set up "auto increment" semantics for an integer
 #rimary key column.  The default value is the string ``"auto"``
 #hich indicates that a single-column primary key that is of
 #n INTEGER type with no stated client-side or python-side defaults
 #hould receive auto increment semantics automatically;
 #ll other varieties of primary key columns will not.  This
 #ncludes that :term:`DDL` such as PostgreSQL SERIAL or MySQL
 #UTO_INCREMENT will be emitted for this column during a table
 #reate, as well as that the column is assumed to generate new
 #nteger primary key values when an INSERT statement invokes which
 #ill be retrieved by the dialect.  When used in conjunction with
 #class:`.Identity` on a dialect that supports it, this parameter
 #as no effect.

 #he flag may be set to ``True`` to indicate that a column which
 #s part of a composite (e.g. multi-column) primary key should
 #ave autoincrement semantics, though note that only one column
 #ithin a primary key may have this setting.    It can also
 #e set to ``True`` to indicate autoincrement semantics on a
 #olumn that has a client-side or server-side default configured,
 #owever note that not all dialects can accommodate all styles
 #f default as an "autoincrement".  It can also be
 #et to ``False`` on a single-column primary key that has a
 #atatype of INTEGER in order to disable auto increment semantics
 #or that column.

 #. versionchanged:: 1.1 The autoincrement flag now defaults to
 #`"auto"`` which indicates autoincrement semantics by default
 #or single-column integer primary keys only; for composite
 #multi-column) primary keys, autoincrement is never implicitly
 #nabled; as always, ``autoincrement=True`` will allow for
 #t most one of those columns to be an "autoincrement" column.
 #`autoincrement=True`` may also be set on a
 #class:`_schema.Column`
 #hat has an explicit client-side or server-side default,
 #ubject to limitations of the backend database and dialect.


 #he setting *only* has an effect for columns which are:

 # Integer derived (i.e. INT, SMALLINT, BIGINT).

 # Part of the primary key

 # Not referring to another column via :class:`_schema.ForeignKey`,
 #nless
 #he value is specified as ``'ignore_fk'``::

                # turn on autoincrement for this column despite
                # the ForeignKey()
 #olumn('id', ForeignKey('other.id'),
 #rimary_key=True, autoincrement='ignore_fk')

 #t is typically not desirable to have "autoincrement" enabled on a
 #olumn that refers to another via foreign key, as such a column is
 #equired to refer to a value that originates from elsewhere.

 #he setting has these two effects on columns that meet the
 #bove criteria:

 # DDL issued for the column will include database-specific
 #eywords intended to signify this column as an
 #autoincrement" column, such as AUTO INCREMENT on MySQL,
 #ERIAL on PostgreSQL, and IDENTITY on MS-SQL.  It does
 #not* issue AUTOINCREMENT for SQLite since this is a
 #pecial SQLite flag that is not required for autoincrementing
 #ehavior.

 #. seealso::

 #ref:`sqlite_autoincrement`

 # The column will be considered to be available using an
 #autoincrement" method specific to the backend database, such
 #s calling upon ``cursor.lastrowid``, using RETURNING in an
 #NSERT statement to get at a sequence-generated value, or using
 #pecial functions such as "SELECT scope_identity()".
 #hese methods are highly specific to the DBAPIs and databases in
 #se and vary greatly, so care should be taken when associating
 #`autoincrement=True`` with a custom default generation function.


 #param default: A scalar, Python callable, or
 #class:`_expression.ColumnElement` expression representing the
 #default value* for this column, which will be invoked upon insert
 #f this column is otherwise not specified in the VALUES clause of
 #he insert. This is a shortcut to using :class:`.ColumnDefault` as
 # positional argument; see that class for full detail on the
 #tructure of the argument.

 #ontrast this argument to
 #paramref:`_schema.Column.server_default`
 #hich creates a default generator on the database side.

 #. seealso::

 #ref:`metadata_defaults_toplevel`

 #param doc: optional String that can be used by the ORM or similar
 #o document attributes on the Python side.   This attribute does
 #*not** render SQL comments; use the
 #paramref:`_schema.Column.comment`
 #arameter for this purpose.

 #param key: An optional string identifier which will identify this
 #`Column`` object on the :class:`_schema.Table`.
 #hen a key is provided,
 #his is the only identifier referencing the ``Column`` within the
 #pplication, including ORM attribute mapping; the ``name`` field
 #s used only when rendering SQL.

 #param index: When ``True``, indicates that a :class:`_schema.Index`
 #onstruct will be automatically generated for this
 #class:`_schema.Column`, which will result in a "CREATE INDEX"
 #tatement being emitted for the :class:`_schema.Table` when the DDL
 #reate operation is invoked.

 #sing this flag is equivalent to making use of the
 #class:`_schema.Index` construct explicitly at the level of the
 #class:`_schema.Table` construct itself::

 #able(
 #some_table",
 #etadata,
 #olumn("x", Integer),
 #ndex("ix_some_table_x", "x")
 #

 #o add the :paramref:`_schema.Index.unique` flag to the
 #class:`_schema.Index`, set both the
 #paramref:`_schema.Column.unique` and
 #paramref:`_schema.Column.index` flags to True simultaneously,
 #hich will have the effect of rendering the "CREATE UNIQUE INDEX"
 #DL instruction instead of "CREATE INDEX".

 #he name of the index is generated using the
 #ref:`default naming convention <constraint_default_naming_convention>`
 #hich for the :class:`_schema.Index` construct is of the form
 #`ix_<tablename>_<columnname>``.

 #s this flag is intended only as a convenience for the common case
 #f adding a single-column, default configured index to a table
 #efinition, explicit use of the :class:`_schema.Index` construct
 #hould be preferred for most use cases, including composite indexes
 #hat encompass more than one column, indexes with SQL expressions
 #r ordering, backend-specific index configuration options, and
 #ndexes that use a specific name.

 #. note:: the :attr:`_schema.Column.index` attribute on
 #class:`_schema.Column`
 #*does not indicate** if this column is indexed or not, only
 #f this flag was explicitly set here.  To view indexes on
 # column, view the :attr:`_schema.Table.indexes` collection
 #r use :meth:`_reflection.Inspector.get_indexes`.

 #. seealso::

 #ref:`schema_indexes`

 #ref:`constraint_naming_conventions`

 #paramref:`_schema.Column.unique`

 #param info: Optional data dictionary which will be populated into the
 #attr:`.SchemaItem.info` attribute of this object.

 #param nullable: When set to ``False``, will cause the "NOT NULL"
 #hrase to be added when generating DDL for the column.   When
 #`True``, will normally generate nothing (in SQL this defaults to
 #NULL"), except in some very specific backend-specific edge cases
 #here "NULL" may render explicitly.
 #efaults to ``True`` unless :paramref:`_schema.Column.primary_key`
 #s also ``True`` or the column specifies a :class:`_sql.Identity`,
 #n which case it defaults to ``False``.
 #his parameter is only used when issuing CREATE TABLE statements.

 #. note::

 #hen the column specifies a :class:`_sql.Identity` this
 #arameter is in general ignored by the DDL compiler. The
 #ostgreSQL database allows nullable identity column by
 #etting this parameter to ``True`` explicitly.

 #param onupdate: A scalar, Python callable, or
 #class:`~sqlalchemy.sql.expression.ClauseElement` representing a
 #efault value to be applied to the column within UPDATE
 #tatements, which will be invoked upon update if this column is not
 #resent in the SET clause of the update. This is a shortcut to
 #sing :class:`.ColumnDefault` as a positional argument with
 #`for_update=True``.

 #. seealso::

 #ref:`metadata_defaults` - complete discussion of onupdate

 #param primary_key: If ``True``, marks this column as a primary key
 #olumn. Multiple columns can have this flag set to specify
 #omposite primary keys. As an alternative, the primary key of a
 #class:`_schema.Table` can be specified via an explicit
 #class:`.PrimaryKeyConstraint` object.

 #param server_default: A :class:`.FetchedValue` instance, str, Unicode
 #r :func:`~sqlalchemy.sql.expression.text` construct representing
 #he DDL DEFAULT value for the column.

 #tring types will be emitted as-is, surrounded by single quotes::

 #olumn('x', Text, server_default="val")

 # TEXT DEFAULT 'val'

 # :func:`~sqlalchemy.sql.expression.text` expression will be
 #endered as-is, without quotes::

 #olumn('y', DateTime, server_default=text('NOW()'))

 # DATETIME DEFAULT NOW()

 #trings and text() will be converted into a
 #class:`.DefaultClause` object upon initialization.

 #se :class:`.FetchedValue` to indicate that an already-existing
 #olumn will generate a default value on the database side which
 #ill be available to SQLAlchemy for post-fetch after inserts. This
 #onstruct does not specify any DDL and the implementation is left
 #o the database, such as via a trigger.

 #. seealso::

 #ref:`server_defaults` - complete discussion of server side
 #efaults

 #param server_onupdate: A :class:`.FetchedValue` instance
 #epresenting a database-side default generation function,
 #uch as a trigger. This
 #ndicates to SQLAlchemy that a newly generated value will be
 #vailable after updates. This construct does not actually
 #mplement any kind of generation function within the database,
 #hich instead must be specified separately.


 #. warning:: This directive **does not** currently produce MySQL's
 #ON UPDATE CURRENT_TIMESTAMP()" clause.  See
 #ref:`mysql_timestamp_onupdate` for background on how to
 #roduce this clause.

 #. seealso::

 #ref:`triggered_columns`

 #param quote: Force quoting of this column's name on or off,
 #orresponding to ``True`` or ``False``. When left at its default
 #f ``None``, the column identifier will be quoted according to
 #hether the name is case sensitive (identifiers with at least one
 #pper case character are treated as case sensitive), or if it's a
 #eserved word. This flag is only needed to force quoting of a
 #eserved word which is not known by the SQLAlchemy dialect.

 #param unique: When ``True``, and the :paramref:`_schema.Column.index`
 #arameter is left at its default value of ``False``,
 #ndicates that a :class:`_schema.UniqueConstraint`
 #onstruct will be automatically generated for this
 #class:`_schema.Column`,
 #hich will result in a "UNIQUE CONSTRAINT" clause referring
 #o this column being included
 #n the ``CREATE TABLE`` statement emitted, when the DDL create
 #peration for the :class:`_schema.Table` object is invoked.

 #hen this flag is ``True`` while the
 #paramref:`_schema.Column.index` parameter is simultaneously
 #et to ``True``, the effect instead is that a
 #class:`_schema.Index` construct which includes the
 #paramref:`_schema.Index.unique` parameter set to ``True``
 #s generated.  See the documentation for
 #paramref:`_schema.Column.index` for additional detail.

 #sing this flag is equivalent to making use of the
 #class:`_schema.UniqueConstraint` construct explicitly at the
 #evel of the :class:`_schema.Table` construct itself::

 #able(
 #some_table",
 #etadata,
 #olumn("x", Integer),
 #niqueConstraint("x")
 #

 #he :paramref:`_schema.UniqueConstraint.name` parameter
 #f the unique constraint object is left at its default value
 #f ``None``; in the absence of a :ref:`naming convention <constraint_naming_conventions>`
 #or the enclosing :class:`_schema.MetaData`, the UNIQUE CONSTRAINT
 #onstruct will be emitted as unnamed, which typically invokes
 # database-specific naming convention to take place.

 #s this flag is intended only as a convenience for the common case
 #f adding a single-column, default configured unique constraint to a table
 #efinition, explicit use of the :class:`_schema.UniqueConstraint` construct
 #hould be preferred for most use cases, including composite constraints
 #hat encompass more than one column, backend-specific index configuration options, and
 #onstraints that use a specific name.

 #. note:: the :attr:`_schema.Column.unique` attribute on
 #class:`_schema.Column`
 #*does not indicate** if this column has a unique constraint or
 #ot, only if this flag was explicitly set here.  To view
 #ndexes and unique constraints that may involve this column,
 #iew the
 #attr:`_schema.Table.indexes` and/or
 #attr:`_schema.Table.constraints` collections or use
 #meth:`_reflection.Inspector.get_indexes` and/or
 #meth:`_reflection.Inspector.get_unique_constraints`

 #. seealso::

 #ref:`schema_unique_constraint`

 #ref:`constraint_naming_conventions`

 #paramref:`_schema.Column.index`

 #param system: When ``True``, indicates this is a "system" column,
 #hat is a column which is automatically made available by the
 #atabase, and should not be included in the columns list for a
 #`CREATE TABLE`` statement.

 #or more elaborate scenarios where columns should be
 #onditionally rendered differently on different backends,
 #onsider custom compilation rules for :class:`.CreateColumn`.

 #param comment: Optional string that will render an SQL comment on
 #able creation.

 #. versionadded:: 1.2 Added the
 #paramref:`_schema.Column.comment`
 #arameter to :class:`_schema.Column`.


 #""  # noqa E501

 #ame = kwargs.pop("name", None)
 #ype_ = kwargs.pop("type_", None)
 #rgs = list(args)
 #f args:
 #f isinstance(args[0], util.string_types):
 #f name is not None:
 #aise exc.ArgumentError(
 #May not pass name positionally and as a keyword."
 #
 #ame = args.pop(0)
 #f args:
 #oltype = args[0]

 #f hasattr(coltype, "_sqla_type"):
 #f type_ is not None:
 #aise exc.ArgumentError(
 #May not pass type_ positionally and as a keyword."
 #
 #ype_ = args.pop(0)

 #f name is not None:
 #ame = quoted_name(name, kwargs.pop("quote", None))
 #lif "quote" in kwargs:
 #aise exc.ArgumentError(
 #Explicit 'name' is required when " "sending 'quote' argument"
 #

 #uper(Column, self).__init__(name, type_)
 #elf.key = kwargs.pop("key", name)
 #elf.primary_key = primary_key = kwargs.pop("primary_key", False)

 #elf._user_defined_nullable = udn = kwargs.pop(
 #nullable", NULL_UNSPECIFIED
 #

 #f udn is not NULL_UNSPECIFIED:
 #elf.nullable = udn
 #lse:
 #elf.nullable = not primary_key

 #elf.default = kwargs.pop("default", None)
 #elf.server_default = kwargs.pop("server_default", None)
 #elf.server_onupdate = kwargs.pop("server_onupdate", None)

        # these default to None because .index and .unique is *not*
        # an informational flag about Column - there can still be an
        # Index or UniqueConstraint referring to this Column.
 #elf.index = kwargs.pop("index", None)
 #elf.unique = kwargs.pop("unique", None)

 #elf.system = kwargs.pop("system", False)
 #elf.doc = kwargs.pop("doc", None)
 #elf.onupdate = kwargs.pop("onupdate", None)
 #elf.autoincrement = kwargs.pop("autoincrement", "auto")
 #elf.constraints = set()
 #elf.foreign_keys = set()
 #elf.comment = kwargs.pop("comment", None)
 #elf.computed = None
 #elf.identity = None

        # check if this Column is proxying another column
 #f "_proxies" in kwargs:
 #elf._proxies = kwargs.pop("_proxies")
        # otherwise, add DDL-related events
 #lif isinstance(self.type, SchemaEventTarget):
 #elf.type._set_parent_with_dispatch(self)

 #f self.default is not None:
 #f isinstance(self.default, (ColumnDefault, Sequence)):
 #rgs.append(self.default)
 #lse:
 #f getattr(self.type, "_warn_on_bytestring", False):
 #f isinstance(self.default, util.binary_type):
 #til.warn(
 #Unicode column '%s' has non-unicode "
 #default value %r specified."
 # (self.key, self.default)
 #
 #rgs.append(ColumnDefault(self.default))

 #f self.server_default is not None:
 #f isinstance(self.server_default, FetchedValue):
 #rgs.append(self.server_default._as_for_update(False))
 #lse:
 #rgs.append(DefaultClause(self.server_default))

 #f self.onupdate is not None:
 #f isinstance(self.onupdate, (ColumnDefault, Sequence)):
 #rgs.append(self.onupdate)
 #lse:
 #rgs.append(ColumnDefault(self.onupdate, for_update=True))

 #f self.server_onupdate is not None:
 #f isinstance(self.server_onupdate, FetchedValue):
 #rgs.append(self.server_onupdate._as_for_update(True))
 #lse:
 #rgs.append(
 #efaultClause(self.server_onupdate, for_update=True)
 #
 #elf._init_items(*args)

 #til.set_creation_order(self)

 #f "info" in kwargs:
 #elf.info = kwargs.pop("info")

 #elf._extra_kwargs(**kwargs)

 #oreign_keys = None
 #""A collection of all :class:`_schema.ForeignKey` marker objects
 #ssociated with this :class:`_schema.Column`.

 #ach object is a member of a :class:`_schema.Table`-wide
 #class:`_schema.ForeignKeyConstraint`.

 #. seealso::

 #attr:`_schema.Table.foreign_keys`

 #""

 #ndex = None
 #""The value of the :paramref:`_schema.Column.index` parameter.

 #oes not indicate if this :class:`_schema.Column` is actually indexed
 #r not; use :attr:`_schema.Table.indexes`.

 #. seealso::

 #attr:`_schema.Table.indexes`
 #""

 #nique = None
 #""The value of the :paramref:`_schema.Column.unique` parameter.

 #oes not indicate if this :class:`_schema.Column` is actually subject to
 # unique constraint or not; use :attr:`_schema.Table.indexes` and
 #attr:`_schema.Table.constraints`.

 #. seealso::

 #attr:`_schema.Table.indexes`

 #attr:`_schema.Table.constraints`.

 #""

 #ef _extra_kwargs(self, **kwargs):
 #elf._validate_dialect_kwargs(kwargs)

 #ef __str__(self):
 #f self.name is None:
 #eturn "(no name)"
 #lif self.table is not None:
 #f self.table.named_with_column:
 #eturn self.table.description + "." + self.description
 #lse:
 #eturn self.description
 #lse:
 #eturn self.description

 #ef references(self, column):
 #""Return True if this Column references the given column via foreign
 #ey."""

 #or fk in self.foreign_keys:
 #f fk.column.proxy_set.intersection(column.proxy_set):
 #eturn True
 #lse:
 #eturn False

 #ef append_foreign_key(self, fk):
 #k._set_parent_with_dispatch(self)

 #ef __repr__(self):
 #warg = []
 #f self.key != self.name:
 #warg.append("key")
 #f self.primary_key:
 #warg.append("primary_key")
 #f not self.nullable:
 #warg.append("nullable")
 #f self.onupdate:
 #warg.append("onupdate")
 #f self.default:
 #warg.append("default")
 #f self.server_default:
 #warg.append("server_default")
 #f self.comment:
 #warg.append("comment")
 #eturn "Column(%s)" % ", ".join(
 #repr(self.name)]
 # [repr(self.type)]
 # [repr(x) for x in self.foreign_keys if x is not None]
 # [repr(x) for x in self.constraints]
 # [
 #
 #elf.table is not None
 #nd "table=<%s>" % self.table.description
 #r "table=None"
 #
 #
 # ["%s=%s" % (k, repr(getattr(self, k))) for k in kwarg]
 #

 #ef _set_parent(self, table, allow_replacements=True):
 #f not self.name:
 #aise exc.ArgumentError(
 #Column must be constructed with a non-blank name or "
 #assign a non-blank .name before adding to a Table."
 #

 #elf._reset_memoizations()

 #f self.key is None:
 #elf.key = self.name

 #xisting = getattr(self, "table", None)
 #f existing is not None and existing is not table:
 #aise exc.ArgumentError(
 #Column object '%s' already assigned to Table '%s'"
 # (self.key, existing.description)
 #

 #f self.key in table._columns:
 #ol = table._columns.get(self.key)
 #f col is not self:
 #f not allow_replacements:
 #til.warn_deprecated(
 #A column with name '%s' is already present "
 #in table '%s'. Please use method "
 #:meth:`_schema.Table.append_column` with the "
 #parameter ``replace_existing=True`` to replace an "
 #existing column." % (self.key, table.name),
 #1.4",
 #
 #or fk in col.foreign_keys:
 #able.foreign_keys.remove(fk)
 #f fk.constraint in table.constraints:
                        # this might have been removed
                        # already, if it's a composite constraint
                        # and more than one col being replaced
 #able.constraints.remove(fk.constraint)

 #able._columns.replace(self)

 #elf.table = table

 #f self.primary_key:
 #able.primary_key._replace(self)
 #lif self.key in table.primary_key:
 #aise exc.ArgumentError(
 #Trying to redefine primary-key column '%s' as a "
 #non-primary-key column on table '%s'"
 # (self.key, table.fullname)
 #

 #f self.index:
 #f isinstance(self.index, util.string_types):
 #aise exc.ArgumentError(
 #The 'index' keyword argument on Column is boolean only. "
 #To create indexes with a specific name, create an "
 #explicit Index object external to the Table."
 #
 #able.append_constraint(
 #ndex(
 #one, self.key, unique=bool(self.unique), _column_flag=True
 #
 #

 #lif self.unique:
 #f isinstance(self.unique, util.string_types):
 #aise exc.ArgumentError(
 #The 'unique' keyword argument on Column is boolean "
 #only. To create unique constraints or indexes with a "
 #specific name, append an explicit UniqueConstraint to "
 #the Table's list of elements, or create an explicit "
 #Index object external to the Table."
 #
 #able.append_constraint(
 #niqueConstraint(self.key, _column_flag=True)
 #

 #elf._setup_on_memoized_fks(lambda fk: fk._set_remote_table(table))

 #f self.identity and (
 #sinstance(self.default, Sequence)
 #r isinstance(self.onupdate, Sequence)
 #:
 #aise exc.ArgumentError(
 #An column cannot specify both Identity and Sequence."
 #

 #ef _setup_on_memoized_fks(self, fn):
 #k_keys = [
 #(self.table.key, self.key), False),
 #(self.table.key, self.name), True),
 #
 #or fk_key, link_to_name in fk_keys:
 #f fk_key in self.table.metadata._fk_memos:
 #or fk in self.table.metadata._fk_memos[fk_key]:
 #f fk.link_to_name is link_to_name:
 #n(fk)

 #ef _on_table_attach(self, fn):
 #f self.table is not None:
 #n(self, self.table)
 #lse:
 #vent.listen(self, "after_parent_attach", fn)

 #util.deprecated(
 #1.4",
 #The :meth:`_schema.Column.copy` method is deprecated "
 #and will be removed in a future release.",
 #
 #ef copy(self, **kw):
 #eturn self._copy(**kw)

 #ef _copy(self, **kw):
 #""Create a copy of this ``Column``, uninitialized.

 #his is used in :meth:`_schema.Table.to_metadata`.

 #""

        # Constraint objects plus non-constraint-bound ForeignKey objects
 #rgs = [
 #._copy(**kw) for c in self.constraints if not c._type_bound
 # + [c._copy(**kw) for c in self.foreign_keys if not c.constraint]

        # ticket #5276
 #olumn_kwargs = {}
 #or dialect_name in self.dialect_options:
 #ialect_options = self.dialect_options[dialect_name]._non_defaults
 #or (
 #ialect_option_key,
 #ialect_option_value,
 # in dialect_options.items():
 #olumn_kwargs[
 #ialect_name + "_" + dialect_option_key
 # = dialect_option_value

 #erver_default = self.server_default
 #erver_onupdate = self.server_onupdate
 #f isinstance(server_default, (Computed, Identity)):
 #erver_default = server_onupdate = None
 #rgs.append(self.server_default._copy(**kw))

 #ype_ = self.type
 #f isinstance(type_, SchemaEventTarget):
 #ype_ = type_.copy(**kw)

 #f self._user_defined_nullable is not NULL_UNSPECIFIED:
 #olumn_kwargs["nullable"] = self._user_defined_nullable

 # = self._constructor(
 #ame=self.name,
 #ype_=type_,
 #ey=self.key,
 #rimary_key=self.primary_key,
 #nique=self.unique,
 #ystem=self.system,
            # quote=self.quote,  # disabled 2013-08-27 (commit 031ef080)
 #ndex=self.index,
 #utoincrement=self.autoincrement,
 #efault=self.default,
 #erver_default=server_default,
 #nupdate=self.onupdate,
 #erver_onupdate=server_onupdate,
 #oc=self.doc,
 #omment=self.comment,
 #args,
 #*column_kwargs
 #
 #eturn self._schema_item_copy(c)

 #ef _make_proxy(
 #elf, selectable, name=None, key=None, name_is_truncatable=False, **kw
 #:
 #""Create a *proxy* for this column.

 #his is a copy of this ``Column`` referenced by a different parent
 #such as an alias or select statement).  The column should
 #e used only in select scenarios, as its full DDL/default
 #nformation is not transferred.

 #""
 #k = [
 #oreignKey(f.column, _constraint=f.constraint)
 #or f in self.foreign_keys
 #
 #f name is None and self.name is None:
 #aise exc.InvalidRequestError(
 #Cannot initialize a sub-selectable"
 # with this Column object until its 'name' has "
 #been assigned."
 #
 #ry:
 # = self._constructor(
 #oercions.expect(
 #oles.TruncatedLabelRole, name if name else self.name
 #
 #f name_is_truncatable
 #lse (name or self.name),
 #elf.type,
                # this may actually be ._proxy_key when the key is incoming
 #ey=key if key else name if name else self.key,
 #rimary_key=self.primary_key,
 #ullable=self.nullable,
 #proxies=[self],
 #fk
 #
 #xcept TypeError as err:
 #til.raise_(
 #ypeError(
 #Could not create a copy of this %r object.  "
 #Ensure the class includes a _constructor() "
 #attribute or method which accepts the "
 #standard Column constructor arguments, or "
 #references the Column class itself." % self.__class__
 #,
 #rom_=err,
 #

 #.table = selectable
 #._propagate_attrs = selectable._propagate_attrs
 #f selectable._is_clone_of is not None:
 #._is_clone_of = selectable._is_clone_of.columns.get(c.key)
 #f self.primary_key:
 #electable.primary_key.add(c)
 #f fk:
 #electable.foreign_keys.update(fk)
 #eturn c.key, c


class ForeignKey(DialectKWArgs, SchemaItem):
 #""Defines a dependency between two columns.

 #`ForeignKey`` is specified as an argument to a :class:`_schema.Column`
 #bject,
 #.g.::

 # = Table("remote_table", metadata,
 #olumn("remote_id", ForeignKey("main_table.id"))
 #

 #ote that ``ForeignKey`` is only a marker object that defines
 # dependency between two columns.   The actual constraint
 #s in all cases represented by the :class:`_schema.ForeignKeyConstraint`
 #bject.   This object will be generated automatically when
 # ``ForeignKey`` is associated with a :class:`_schema.Column` which
 #n turn is associated with a :class:`_schema.Table`.   Conversely,
 #hen :class:`_schema.ForeignKeyConstraint` is applied to a
 #class:`_schema.Table`,
 #`ForeignKey`` markers are automatically generated to be
 #resent on each associated :class:`_schema.Column`, which are also
 #ssociated with the constraint object.

 #ote that you cannot define a "composite" foreign key constraint,
 #hat is a constraint between a grouping of multiple parent/child
 #olumns, using ``ForeignKey`` objects.   To define this grouping,
 #he :class:`_schema.ForeignKeyConstraint` object must be used, and applied
 #o the :class:`_schema.Table`.   The associated ``ForeignKey`` objects
 #re created automatically.

 #he ``ForeignKey`` objects associated with an individual
 #class:`_schema.Column`
 #bject are available in the `foreign_keys` collection
 #f that column.

 #urther examples of foreign key configuration are in
 #ref:`metadata_foreignkeys`.

 #""

 #_visit_name__ = "foreign_key"

 #ef __init__(
 #elf,
 #olumn,
 #constraint=None,
 #se_alter=False,
 #ame=None,
 #nupdate=None,
 #ndelete=None,
 #eferrable=None,
 #nitially=None,
 #ink_to_name=False,
 #atch=None,
 #nfo=None,
 #*dialect_kw
 #:
 #"""
 #onstruct a column-level FOREIGN KEY.

 #he :class:`_schema.ForeignKey` object when constructed generates a
 #class:`_schema.ForeignKeyConstraint`
 #hich is associated with the parent
 #class:`_schema.Table` object's collection of constraints.

 #param column: A single target column for the key relationship. A
 #class:`_schema.Column` object or a column name as a string:
 #`tablename.columnkey`` or ``schema.tablename.columnkey``.
 #`columnkey`` is the ``key`` which has been assigned to the column
 #defaults to the column name itself), unless ``link_to_name`` is
 #`True`` in which case the rendered name of the column is used.

 #param name: Optional string. An in-database name for the key if
 #constraint` is not provided.

 #param onupdate: Optional string. If set, emit ON UPDATE <value> when
 #ssuing DDL for this constraint. Typical values include CASCADE,
 #ELETE and RESTRICT.

 #param ondelete: Optional string. If set, emit ON DELETE <value> when
 #ssuing DDL for this constraint. Typical values include CASCADE,
 #ELETE and RESTRICT.

 #param deferrable: Optional bool. If set, emit DEFERRABLE or NOT
 #EFERRABLE when issuing DDL for this constraint.

 #param initially: Optional string. If set, emit INITIALLY <value> when
 #ssuing DDL for this constraint.

 #param link_to_name: if True, the string name given in ``column`` is
 #he rendered name of the referenced column, not its locally
 #ssigned ``key``.

 #param use_alter: passed to the underlying
 #class:`_schema.ForeignKeyConstraint`
 #o indicate the constraint should
 #e generated/dropped externally from the CREATE TABLE/ DROP TABLE
 #tatement.  See :paramref:`_schema.ForeignKeyConstraint.use_alter`
 #or further description.

 #. seealso::

 #paramref:`_schema.ForeignKeyConstraint.use_alter`

 #ref:`use_alter`

 #param match: Optional string. If set, emit MATCH <value> when issuing
 #DL for this constraint. Typical values include SIMPLE, PARTIAL
 #nd FULL.

 #param info: Optional data dictionary which will be populated into the
 #attr:`.SchemaItem.info` attribute of this object.

 #. versionadded:: 1.0.0

 #param \**dialect_kw:  Additional keyword arguments are dialect
 #pecific, and passed in the form ``<dialectname>_<argname>``.  The
 #rguments are ultimately handled by a corresponding
 #class:`_schema.ForeignKeyConstraint`.
 #ee the documentation regarding
 #n individual dialect at :ref:`dialect_toplevel` for detail on
 #ocumented arguments.

 #. versionadded:: 0.9.2

 #""

 #elf._colspec = coercions.expect(roles.DDLReferredColumnRole, column)

 #f isinstance(self._colspec, util.string_types):
 #elf._table_column = None
 #lse:
 #elf._table_column = self._colspec

 #f not isinstance(
 #elf._table_column.table, (util.NoneType, TableClause)
 #:
 #aise exc.ArgumentError(
 #ForeignKey received Column not bound "
 #to a Table, got: %r" % self._table_column.table
 #

        # the linked ForeignKeyConstraint.
        # ForeignKey will create this when parent Column
        # is attached to a Table, *or* ForeignKeyConstraint
        # object passes itself in when creating ForeignKey
        # markers.
 #elf.constraint = _constraint
 #elf.parent = None
 #elf.use_alter = use_alter
 #elf.name = name
 #elf.onupdate = onupdate
 #elf.ondelete = ondelete
 #elf.deferrable = deferrable
 #elf.initially = initially
 #elf.link_to_name = link_to_name
 #elf.match = match
 #f info:
 #elf.info = info
 #elf._unvalidated_dialect_kw = dialect_kw

 #ef __repr__(self):
 #eturn "ForeignKey(%r)" % self._get_colspec()

 #util.deprecated(
 #1.4",
 #The :meth:`_schema.ForeignKey.copy` method is deprecated "
 #and will be removed in a future release.",
 #
 #ef copy(self, schema=None, **kw):
 #eturn self._copy(schema=schema, **kw)

 #ef _copy(self, schema=None, **kw):
 #""Produce a copy of this :class:`_schema.ForeignKey` object.

 #he new :class:`_schema.ForeignKey` will not be bound
 #o any :class:`_schema.Column`.

 #his method is usually used by the internal
 #opy procedures of :class:`_schema.Column`, :class:`_schema.Table`,
 #nd :class:`_schema.MetaData`.

 #param schema: The returned :class:`_schema.ForeignKey` will
 #eference the original table and column name, qualified
 #y the given string schema name.

 #""

 #k = ForeignKey(
 #elf._get_colspec(schema=schema),
 #se_alter=self.use_alter,
 #ame=self.name,
 #nupdate=self.onupdate,
 #ndelete=self.ondelete,
 #eferrable=self.deferrable,
 #nitially=self.initially,
 #ink_to_name=self.link_to_name,
 #atch=self.match,
 #*self._unvalidated_dialect_kw
 #
 #eturn self._schema_item_copy(fk)

 #ef _get_colspec(self, schema=None, table_name=None):
 #""Return a string based 'column specification' for this
 #class:`_schema.ForeignKey`.

 #his is usually the equivalent of the string-based "tablename.colname"
 #rgument first passed to the object's constructor.

 #""
 #f schema:
 #schema, tname, colname = self._column_tokens
 #f table_name is not None:
 #name = table_name
 #eturn "%s.%s.%s" % (schema, tname, colname)
 #lif table_name:
 #chema, tname, colname = self._column_tokens
 #f schema:
 #eturn "%s.%s.%s" % (schema, table_name, colname)
 #lse:
 #eturn "%s.%s" % (table_name, colname)
 #lif self._table_column is not None:
 #eturn "%s.%s" % (
 #elf._table_column.table.fullname,
 #elf._table_column.key,
 #
 #lse:
 #eturn self._colspec

 #property
 #ef _referred_schema(self):
 #eturn self._column_tokens[0]

 #ef _table_key(self):
 #f self._table_column is not None:
 #f self._table_column.table is None:
 #eturn None
 #lse:
 #eturn self._table_column.table.key
 #lse:
 #chema, tname, colname = self._column_tokens
 #eturn _get_table_key(tname, schema)

 #arget_fullname = property(_get_colspec)

 #ef references(self, table):
 #""Return True if the given :class:`_schema.Table`
 #s referenced by this
 #class:`_schema.ForeignKey`."""

 #eturn table.corresponding_column(self.column) is not None

 #ef get_referent(self, table):
 #""Return the :class:`_schema.Column` in the given
 #class:`_schema.Table`
 #eferenced by this :class:`_schema.ForeignKey`.

 #eturns None if this :class:`_schema.ForeignKey`
 #oes not reference the given
 #class:`_schema.Table`.

 #""

 #eturn table.corresponding_column(self.column)

 #util.memoized_property
 #ef _column_tokens(self):
 #""parse a string-based _colspec into its component parts."""

 # = self._get_colspec().split(".")
 #f m is None:
 #aise exc.ArgumentError(
 #Invalid foreign key column specification: %s" % self._colspec
 #
 #f len(m) == 1:
 #name = m.pop()
 #olname = None
 #lse:
 #olname = m.pop()
 #name = m.pop()

        # A FK between column 'bar' and table 'foo' can be
        # specified as 'foo', 'foo.bar', 'dbo.foo.bar',
        # 'otherdb.dbo.foo.bar'. Once we have the column name and
        # the table name, treat everything else as the schema
        # name. Some databases (e.g. Sybase) support
        # inter-database foreign keys. See tickets#1341 and --
        # indirectly related -- Ticket #594. This assumes that '.'
        # will never appear *within* any component of the FK.

 #f len(m) > 0:
 #chema = ".".join(m)
 #lse:
 #chema = None
 #eturn schema, tname, colname

 #ef _resolve_col_tokens(self):
 #f self.parent is None:
 #aise exc.InvalidRequestError(
 #this ForeignKey object does not yet have a "
 #parent Column associated with it."
 #

 #lif self.parent.table is None:
 #aise exc.InvalidRequestError(
 #this ForeignKey's parent column is not yet associated "
 #with a Table."
 #

 #arenttable = self.parent.table

        # assertion
        # basically Column._make_proxy() sends the actual
        # target Column to the ForeignKey object, so the
        # string resolution here is never called.
 #or c in self.parent.base_columns:
 #f isinstance(c, Column):
 #ssert c.table is parenttable
 #reak
 #lse:
 #ssert False
        ######################

 #chema, tname, colname = self._column_tokens

 #f schema is None and parenttable.metadata.schema is not None:
 #chema = parenttable.metadata.schema

 #ablekey = _get_table_key(tname, schema)
 #eturn parenttable, tablekey, colname

 #ef _link_to_col_by_colstring(self, parenttable, table, colname):
 #f not hasattr(self.constraint, "_referred_table"):
 #elf.constraint._referred_table = table
 #lse:
 #ssert self.constraint._referred_table is table

 #column = None
 #f colname is None:
            # colname is None in the case that ForeignKey argument
            # was specified as table name only, in which case we
            # match the column name to the same column on the
            # parent.
 #ey = self.parent
 #column = table.c.get(self.parent.key, None)
 #lif self.link_to_name:
 #ey = colname
 #or c in table.c:
 #f c.name == colname:
 #column = c
 #lse:
 #ey = colname
 #column = table.c.get(colname, None)

 #f _column is None:
 #aise exc.NoReferencedColumnError(
 #Could not initialize target column "
 #for ForeignKey '%s' on table '%s': "
 #table '%s' has no column named '%s'"
 # (self._colspec, parenttable.name, table.name, key),
 #able.name,
 #ey,
 #

 #elf._set_target_column(_column)

 #ef _set_target_column(self, column):
 #ssert isinstance(self.parent.table, Table)

        # propagate TypeEngine to parent if it didn't have one
 #f self.parent.type._isnull:
 #elf.parent.type = column.type

        # super-edgy case, if other FKs point to our column,
        # they'd get the type propagated out also.

 #ef set_type(fk):
 #f fk.parent.type._isnull:
 #k.parent.type = column.type

 #elf.parent._setup_on_memoized_fks(set_type)

 #elf.column = column

 #util.memoized_property
 #ef column(self):
 #""Return the target :class:`_schema.Column` referenced by this
 #class:`_schema.ForeignKey`.

 #f no target column has been established, an exception
 #s raised.

 #. versionchanged:: 0.9.0
 #oreign key target column resolution now occurs as soon as both
 #he ForeignKey object and the remote Column to which it refers
 #re both associated with the same MetaData object.

 #""

 #f isinstance(self._colspec, util.string_types):

 #arenttable, tablekey, colname = self._resolve_col_tokens()

 #f tablekey not in parenttable.metadata:
 #aise exc.NoReferencedTableError(
 #Foreign key associated with column '%s' could not find "
 #table '%s' with which to generate a "
 #foreign key to target column '%s'"
 # (self.parent, tablekey, colname),
 #ablekey,
 #
 #lif parenttable.key not in parenttable.metadata:
 #aise exc.InvalidRequestError(
 #Table %s is no longer associated with its "
 #parent MetaData" % parenttable
 #
 #lse:
 #aise exc.NoReferencedColumnError(
 #Could not initialize target column for "
 #ForeignKey '%s' on table '%s': "
 #table '%s' has no column named '%s'"
 # (self._colspec, parenttable.name, tablekey, colname),
 #ablekey,
 #olname,
 #
 #lif hasattr(self._colspec, "__clause_element__"):
 #column = self._colspec.__clause_element__()
 #eturn _column
 #lse:
 #column = self._colspec
 #eturn _column

 #ef _set_parent(self, column, **kw):
 #f self.parent is not None and self.parent is not column:
 #aise exc.InvalidRequestError(
 #This ForeignKey already has a parent !"
 #
 #elf.parent = column
 #elf.parent.foreign_keys.add(self)
 #elf.parent._on_table_attach(self._set_table)

 #ef _set_remote_table(self, table):
 #arenttable, tablekey, colname = self._resolve_col_tokens()
 #elf._link_to_col_by_colstring(parenttable, table, colname)
 #elf.constraint._validate_dest_table(table)

 #ef _remove_from_metadata(self, metadata):
 #arenttable, table_key, colname = self._resolve_col_tokens()
 #k_key = (table_key, colname)

 #f self in metadata._fk_memos[fk_key]:
            # TODO: no test coverage for self not in memos
 #etadata._fk_memos[fk_key].remove(self)

 #ef _set_table(self, column, table):
        # standalone ForeignKey - create ForeignKeyConstraint
        # on the hosting Table when attached to the Table.
 #ssert isinstance(table, Table)
 #f self.constraint is None:
 #elf.constraint = ForeignKeyConstraint(
 #],
 #],
 #se_alter=self.use_alter,
 #ame=self.name,
 #nupdate=self.onupdate,
 #ndelete=self.ondelete,
 #eferrable=self.deferrable,
 #nitially=self.initially,
 #atch=self.match,
 #*self._unvalidated_dialect_kw
 #
 #elf.constraint._append_element(column, self)
 #elf.constraint._set_parent_with_dispatch(table)
 #able.foreign_keys.add(self)
        # set up remote ".column" attribute, or a note to pick it
        # up when the other Table/Column shows up
 #f isinstance(self._colspec, util.string_types):
 #arenttable, table_key, colname = self._resolve_col_tokens()
 #k_key = (table_key, colname)
 #f table_key in parenttable.metadata.tables:
 #able = parenttable.metadata.tables[table_key]
 #ry:
 #elf._link_to_col_by_colstring(parenttable, table, colname)
 #xcept exc.NoReferencedColumnError:
                    # this is OK, we'll try later
 #ass
 #arenttable.metadata._fk_memos[fk_key].append(self)
 #lif hasattr(self._colspec, "__clause_element__"):
 #column = self._colspec.__clause_element__()
 #elf._set_target_column(_column)
 #lse:
 #column = self._colspec
 #elf._set_target_column(_column)


class DefaultGenerator(Executable, SchemaItem):
 #""Base class for column *default* values."""

 #_visit_name__ = "default_generator"

 #s_sequence = False
 #s_server_default = False
 #olumn = None

 #ef __init__(self, for_update=False):
 #elf.for_update = for_update

 #ef _set_parent(self, column, **kw):
 #elf.column = column
 #f self.for_update:
 #elf.column.onupdate = self
 #lse:
 #elf.column.default = self

 #util.deprecated_20(
 #:meth:`.DefaultGenerator.execute`",
 #lternative="All statement execution in SQLAlchemy 2.0 is performed "
 #by the :meth:`_engine.Connection.execute` method of "
 #:class:`_engine.Connection`, "
 #or in the ORM by the :meth:`.Session.execute` method of "
 #:class:`.Session`.",
 #
 #ef execute(self, bind=None):
 #f bind is None:
 #ind = _bind_or_error(self)
 #eturn bind._execute_default(self, (), util.EMPTY_DICT)

 #ef _execute_on_connection(
 #elf, connection, multiparams, params, execution_options
 #:
 #eturn connection._execute_default(
 #elf, multiparams, params, execution_options
 #

 #property
 #ef bind(self):
 #""Return the connectable associated with this default."""
 #f getattr(self, "column", None) is not None:
 #eturn self.column.table.bind
 #lse:
 #eturn None


class ColumnDefault(DefaultGenerator):
 #""A plain default value on a column.

 #his could correspond to a constant, a callable function,
 #r a SQL clause.

 #class:`.ColumnDefault` is generated automatically
 #henever the ``default``, ``onupdate`` arguments of
 #class:`_schema.Column` are used.  A :class:`.ColumnDefault`
 #an be passed positionally as well.

 #or example, the following::

 #olumn('foo', Integer, default=50)

 #s equivalent to::

 #olumn('foo', Integer, ColumnDefault(50))


 #""

 #ef __init__(self, arg, **kwargs):
 #""Construct a new :class:`.ColumnDefault`.


 #param arg: argument representing the default value.
 #ay be one of the following:

 # a plain non-callable Python value, such as a
 #tring, integer, boolean, or other simple type.
 #he default value will be used as is each time.
 # a SQL expression, that is one which derives from
 #class:`_expression.ColumnElement`.  The SQL expression will
 #e rendered into the INSERT or UPDATE statement,
 #r in the case of a primary key column when
 #ETURNING is not used may be
 #re-executed before an INSERT within a SELECT.
 # A Python callable.  The function will be invoked for each
 #ew row subject to an INSERT or UPDATE.
 #he callable must accept exactly
 #ero or one positional arguments.  The one-argument form
 #ill receive an instance of the :class:`.ExecutionContext`,
 #hich provides contextual information as to the current
 #class:`_engine.Connection` in use as well as the current
 #tatement and parameters.

 #""
 #uper(ColumnDefault, self).__init__(**kwargs)
 #f isinstance(arg, FetchedValue):
 #aise exc.ArgumentError(
 #ColumnDefault may not be a server-side default type."
 #
 #f callable(arg):
 #rg = self._maybe_wrap_callable(arg)
 #elf.arg = arg

 #util.memoized_property
 #ef is_callable(self):
 #eturn callable(self.arg)

 #util.memoized_property
 #ef is_clause_element(self):
 #eturn isinstance(self.arg, ClauseElement)

 #util.memoized_property
 #ef is_scalar(self):
 #eturn (
 #ot self.is_callable
 #nd not self.is_clause_element
 #nd not self.is_sequence
 #

 #util.memoized_property
 #util.preload_module("sqlalchemy.sql.sqltypes")
 #ef _arg_is_typed(self):
 #qltypes = util.preloaded.sql_sqltypes

 #f self.is_clause_element:
 #eturn not isinstance(self.arg.type, sqltypes.NullType)
 #lse:
 #eturn False

 #ef _maybe_wrap_callable(self, fn):
 #""Wrap callables that don't accept a context.

 #his is to allow easy compatibility with default callables
 #hat aren't specific to accepting of a context.

 #""
 #ry:
 #rgspec = util.get_callable_argspec(fn, no_self=True)
 #xcept TypeError:
 #eturn util.wrap_callable(lambda ctx: fn(), fn)

 #efaulted = argspec[3] is not None and len(argspec[3]) or 0
 #ositionals = len(argspec[0]) - defaulted

 #f positionals == 0:
 #eturn util.wrap_callable(lambda ctx: fn(), fn)

 #lif positionals == 1:
 #eturn fn
 #lse:
 #aise exc.ArgumentError(
 #ColumnDefault Python function takes zero or one "
 #positional arguments"
 #

 #ef __repr__(self):
 #eturn "ColumnDefault(%r)" % (self.arg,)


class IdentityOptions(object):
 #""Defines options for a named database sequence or an identity column.

 #. versionadded:: 1.3.18

 #. seealso::

 #class:`.Sequence`

 #""

 #ef __init__(
 #elf,
 #tart=None,
 #ncrement=None,
 #invalue=None,
 #axvalue=None,
 #ominvalue=None,
 #omaxvalue=None,
 #ycle=None,
 #ache=None,
 #rder=None,
 #:
 #""Construct a :class:`.IdentityOptions` object.

 #ee the :class:`.Sequence` documentation for a complete description
 #f the parameters.

 #param start: the starting index of the sequence.
 #param increment: the increment value of the sequence.
 #param minvalue: the minimum value of the sequence.
 #param maxvalue: the maximum value of the sequence.
 #param nominvalue: no minimum value of the sequence.
 #param nomaxvalue: no maximum value of the sequence.
 #param cycle: allows the sequence to wrap around when the maxvalue
 #r minvalue has been reached.
 #param cache: optional integer value; number of future values in the
 #equence which are calculated in advance.
 #param order: optional boolean value; if ``True``, renders the
 #RDER keyword.

 #""
 #elf.start = start
 #elf.increment = increment
 #elf.minvalue = minvalue
 #elf.maxvalue = maxvalue
 #elf.nominvalue = nominvalue
 #elf.nomaxvalue = nomaxvalue
 #elf.cycle = cycle
 #elf.cache = cache
 #elf.order = order


class Sequence(IdentityOptions, DefaultGenerator):
 #""Represents a named database sequence.

 #he :class:`.Sequence` object represents the name and configurational
 #arameters of a database sequence.   It also represents
 # construct that can be "executed" by a SQLAlchemy :class:`_engine.Engine`
 #r :class:`_engine.Connection`,
 #endering the appropriate "next value" function
 #or the target database and returning a result.

 #he :class:`.Sequence` is typically associated with a primary key column::

 #ome_table = Table(
 #some_table', metadata,
 #olumn('id', Integer, Sequence('some_table_seq'),
 #rimary_key=True)
 #

 #hen CREATE TABLE is emitted for the above :class:`_schema.Table`, if the
 #arget platform supports sequences, a CREATE SEQUENCE statement will
 #e emitted as well.   For platforms that don't support sequences,
 #he :class:`.Sequence` construct is ignored.

 #. seealso::

 #ref:`defaults_sequences`

 #class:`.CreateSequence`

 #class:`.DropSequence`

 #""

 #_visit_name__ = "sequence"

 #s_sequence = True

 #ef __init__(
 #elf,
 #ame,
 #tart=None,
 #ncrement=None,
 #invalue=None,
 #axvalue=None,
 #ominvalue=None,
 #omaxvalue=None,
 #ycle=None,
 #chema=None,
 #ache=None,
 #rder=None,
 #ata_type=None,
 #ptional=False,
 #uote=None,
 #etadata=None,
 #uote_schema=None,
 #or_update=False,
 #:
 #""Construct a :class:`.Sequence` object.

 #param name: the name of the sequence.

 #param start: the starting index of the sequence.  This value is
 #sed when the CREATE SEQUENCE command is emitted to the database
 #s the value of the "START WITH" clause.   If ``None``, the
 #lause is omitted, which on most platforms indicates a starting
 #alue of 1.
 #param increment: the increment value of the sequence.  This
 #alue is used when the CREATE SEQUENCE command is emitted to
 #he database as the value of the "INCREMENT BY" clause.  If ``None``,
 #he clause is omitted, which on most platforms indicates an
 #ncrement of 1.
 #param minvalue: the minimum value of the sequence.  This
 #alue is used when the CREATE SEQUENCE command is emitted to
 #he database as the value of the "MINVALUE" clause.  If ``None``,
 #he clause is omitted, which on most platforms indicates a
 #invalue of 1 and -2^63-1 for ascending and descending sequences,
 #espectively.

 #. versionadded:: 1.0.7

 #param maxvalue: the maximum value of the sequence.  This
 #alue is used when the CREATE SEQUENCE command is emitted to
 #he database as the value of the "MAXVALUE" clause.  If ``None``,
 #he clause is omitted, which on most platforms indicates a
 #axvalue of 2^63-1 and -1 for ascending and descending sequences,
 #espectively.

 #. versionadded:: 1.0.7

 #param nominvalue: no minimum value of the sequence.  This
 #alue is used when the CREATE SEQUENCE command is emitted to
 #he database as the value of the "NO MINVALUE" clause.  If ``None``,
 #he clause is omitted, which on most platforms indicates a
 #invalue of 1 and -2^63-1 for ascending and descending sequences,
 #espectively.

 #. versionadded:: 1.0.7

 #param nomaxvalue: no maximum value of the sequence.  This
 #alue is used when the CREATE SEQUENCE command is emitted to
 #he database as the value of the "NO MAXVALUE" clause.  If ``None``,
 #he clause is omitted, which on most platforms indicates a
 #axvalue of 2^63-1 and -1 for ascending and descending sequences,
 #espectively.

 #. versionadded:: 1.0.7

 #param cycle: allows the sequence to wrap around when the maxvalue
 #r minvalue has been reached by an ascending or descending sequence
 #espectively.  This value is used when the CREATE SEQUENCE command
 #s emitted to the database as the "CYCLE" clause.  If the limit is
 #eached, the next number generated will be the minvalue or maxvalue,
 #espectively.  If cycle=False (the default) any calls to nextval
 #fter the sequence has reached its maximum value will return an
 #rror.

 #. versionadded:: 1.0.7

 #param schema: optional schema name for the sequence, if located
 #n a schema other than the default.  The rules for selecting the
 #chema name when a :class:`_schema.MetaData`
 #s also present are the same
 #s that of :paramref:`_schema.Table.schema`.

 #param cache: optional integer value; number of future values in the
 #equence which are calculated in advance.  Renders the CACHE keyword
 #nderstood by Oracle and PostgreSQL.

 #. versionadded:: 1.1.12

 #param order: optional boolean value; if ``True``, renders the
 #RDER keyword, understood by Oracle, indicating the sequence is
 #efinitively ordered.   May be necessary to provide deterministic
 #rdering using Oracle RAC.

 #. versionadded:: 1.1.12

 #param data_type: The type to be returned by the sequence, for
 #ialects that allow us to choose between INTEGER, BIGINT, etc.
 #e.g., mssql).

 #. versionadded:: 1.4.0

 #param optional: boolean value, when ``True``, indicates that this
 #class:`.Sequence` object only needs to be explicitly generated
 #n backends that don't provide another way to generate primary
 #ey identifiers.  Currently, it essentially means, "don't create
 #his sequence on the PostgreSQL backend, where the SERIAL keyword
 #reates a sequence for us automatically".
 #param quote: boolean value, when ``True`` or ``False``, explicitly
 #orces quoting of the :paramref:`_schema.Sequence.name` on or off.
 #hen left at its default of ``None``, normal quoting rules based
 #n casing and reserved words take place.
 #param quote_schema: Set the quoting preferences for the ``schema``
 #ame.

 #param metadata: optional :class:`_schema.MetaData` object which this
 #class:`.Sequence` will be associated with.  A :class:`.Sequence`
 #hat is associated with a :class:`_schema.MetaData`
 #ains the following
 #apabilities:

 # The :class:`.Sequence` will inherit the
 #paramref:`_schema.MetaData.schema`
 #arameter specified to the target :class:`_schema.MetaData`, which
 #ffects the production of CREATE / DROP DDL, if any.

 # The :meth:`.Sequence.create` and :meth:`.Sequence.drop` methods
 #utomatically use the engine bound to the :class:`_schema.MetaData`
 #bject, if any.

 # The :meth:`_schema.MetaData.create_all` and
 #meth:`_schema.MetaData.drop_all`
 #ethods will emit CREATE / DROP for this :class:`.Sequence`,
 #ven if the :class:`.Sequence` is not associated with any
 #class:`_schema.Table` / :class:`_schema.Column`
 #hat's a member of this
 #class:`_schema.MetaData`.

 #he above behaviors can only occur if the :class:`.Sequence` is
 #xplicitly associated with the :class:`_schema.MetaData`
 #ia this parameter.

 #. seealso::

 #ref:`sequence_metadata` - full discussion of the
 #paramref:`.Sequence.metadata` parameter.

 #param for_update: Indicates this :class:`.Sequence`, when associated
 #ith a :class:`_schema.Column`,
 #hould be invoked for UPDATE statements
 #n that column's table, rather than for INSERT statements, when
 #o value is otherwise present for that column in the statement.

 #""
 #efaultGenerator.__init__(self, for_update=for_update)
 #dentityOptions.__init__(
 #elf,
 #tart=start,
 #ncrement=increment,
 #invalue=minvalue,
 #axvalue=maxvalue,
 #ominvalue=nominvalue,
 #omaxvalue=nomaxvalue,
 #ycle=cycle,
 #ache=cache,
 #rder=order,
 #
 #elf.name = quoted_name(name, quote)
 #elf.optional = optional
 #f schema is BLANK_SCHEMA:
 #elf.schema = schema = None
 #lif metadata is not None and schema is None and metadata.schema:
 #elf.schema = schema = metadata.schema
 #lse:
 #elf.schema = quoted_name(schema, quote_schema)
 #elf.metadata = metadata
 #elf._key = _get_table_key(name, schema)
 #f metadata:
 #elf._set_metadata(metadata)
 #f data_type is not None:
 #elf.data_type = to_instance(data_type)
 #lse:
 #elf.data_type = None

 #util.memoized_property
 #ef is_callable(self):
 #eturn False

 #util.memoized_property
 #ef is_clause_element(self):
 #eturn False

 #util.preload_module("sqlalchemy.sql.functions")
 #ef next_value(self):
 #""Return a :class:`.next_value` function element
 #hich will render the appropriate increment function
 #or this :class:`.Sequence` within any SQL expression.

 #""
 #f self.bind:
 #eturn util.preloaded.sql_functions.func.next_value(
 #elf, bind=self.bind
 #
 #lse:
 #eturn util.preloaded.sql_functions.func.next_value(self)

 #ef _set_parent(self, column, **kw):
 #uper(Sequence, self)._set_parent(column)
 #olumn._on_table_attach(self._set_table)

 #ef _set_table(self, column, table):
 #elf._set_metadata(table.metadata)

 #ef _set_metadata(self, metadata):
 #elf.metadata = metadata
 #elf.metadata._sequences[self._key] = self

 #property
 #ef bind(self):
 #f self.metadata:
 #eturn self.metadata.bind
 #lse:
 #eturn None

 #ef create(self, bind=None, checkfirst=True):
 #""Creates this sequence in the database.

 #. note:: the "bind" argument will be required in
 #QLAlchemy 2.0.

 #""

 #f bind is None:
 #ind = _bind_or_error(self)
 #ind._run_ddl_visitor(ddl.SchemaGenerator, self, checkfirst=checkfirst)

 #ef drop(self, bind=None, checkfirst=True):
 #""Drops this sequence from the database.

 #. note:: the "bind" argument will be required in
 #QLAlchemy 2.0.

 #""

 #f bind is None:
 #ind = _bind_or_error(self)
 #ind._run_ddl_visitor(ddl.SchemaDropper, self, checkfirst=checkfirst)

 #ef _not_a_column_expr(self):
 #aise exc.InvalidRequestError(
 #This %s cannot be used directly "
 #as a column expression.  Use func.next_value(sequence) "
 #to produce a 'next value' function that's usable "
 #as a column element." % self.__class__.__name__
 #


@inspection._self_inspects
class FetchedValue(SchemaEventTarget):
 #""A marker for a transparent database-side default.

 #se :class:`.FetchedValue` when the database is configured
 #o provide some automatic default for a column.

 #.g.::

 #olumn('foo', Integer, FetchedValue())

 #ould indicate that some trigger or default generator
 #ill create a new value for the ``foo`` column during an
 #NSERT.

 #. seealso::

 #ref:`triggered_columns`

 #""

 #s_server_default = True
 #eflected = False
 #as_argument = False
 #s_clause_element = False

 #ef __init__(self, for_update=False):
 #elf.for_update = for_update

 #ef _as_for_update(self, for_update):
 #f for_update == self.for_update:
 #eturn self
 #lse:
 #eturn self._clone(for_update)

 #ef _clone(self, for_update):
 # = self.__class__.__new__(self.__class__)
 #.__dict__.update(self.__dict__)
 #.__dict__.pop("column", None)
 #.for_update = for_update
 #eturn n

 #ef _set_parent(self, column, **kw):
 #elf.column = column
 #f self.for_update:
 #elf.column.server_onupdate = self
 #lse:
 #elf.column.server_default = self

 #ef __repr__(self):
 #eturn util.generic_repr(self)


class DefaultClause(FetchedValue):
 #""A DDL-specified DEFAULT column value.

 #class:`.DefaultClause` is a :class:`.FetchedValue`
 #hat also generates a "DEFAULT" clause when
 #CREATE TABLE" is emitted.

 #class:`.DefaultClause` is generated automatically
 #henever the ``server_default``, ``server_onupdate`` arguments of
 #class:`_schema.Column` are used.  A :class:`.DefaultClause`
 #an be passed positionally as well.

 #or example, the following::

 #olumn('foo', Integer, server_default="50")

 #s equivalent to::

 #olumn('foo', Integer, DefaultClause("50"))

 #""

 #as_argument = True

 #ef __init__(self, arg, for_update=False, _reflected=False):
 #til.assert_arg_type(
 #rg, (util.string_types[0], ClauseElement, TextClause), "arg"
 #
 #uper(DefaultClause, self).__init__(for_update)
 #elf.arg = arg
 #elf.reflected = _reflected

 #ef __repr__(self):
 #eturn "DefaultClause(%r, for_update=%r)" % (self.arg, self.for_update)


class Constraint(DialectKWArgs, SchemaItem):
 #""A table-level SQL constraint.

 #class:`_schema.Constraint` serves as the base class for the series of
 #onstraint objects that can be associated with :class:`_schema.Table`
 #bjects, including :class:`_schema.PrimaryKeyConstraint`,
 #class:`_schema.ForeignKeyConstraint`
 #class:`_schema.UniqueConstraint`, and
 #class:`_schema.CheckConstraint`.

 #""

 #_visit_name__ = "constraint"

 #ef __init__(
 #elf,
 #ame=None,
 #eferrable=None,
 #nitially=None,
 #create_rule=None,
 #nfo=None,
 #type_bound=False,
 #*dialect_kw
 #:
 #"""Create a SQL constraint.

 #param name:
 #ptional, the in-database name of this ``Constraint``.

 #param deferrable:
 #ptional bool.  If set, emit DEFERRABLE or NOT DEFERRABLE when
 #ssuing DDL for this constraint.

 #param initially:
 #ptional string.  If set, emit INITIALLY <value> when issuing DDL
 #or this constraint.

 #param info: Optional data dictionary which will be populated into the
 #attr:`.SchemaItem.info` attribute of this object.

 #. versionadded:: 1.0.0

 #param \**dialect_kw:  Additional keyword arguments are dialect
 #pecific, and passed in the form ``<dialectname>_<argname>``.  See
 #he documentation regarding an individual dialect at
 #ref:`dialect_toplevel` for detail on documented arguments.

 #param _create_rule:
 #sed internally by some datatypes that also create constraints.

 #param _type_bound:
 #sed internally to indicate that this constraint is associated with
 # specific datatype.

 #""

 #elf.name = name
 #elf.deferrable = deferrable
 #elf.initially = initially
 #f info:
 #elf.info = info
 #elf._create_rule = _create_rule
 #elf._type_bound = _type_bound
 #til.set_creation_order(self)
 #elf._validate_dialect_kwargs(dialect_kw)

 #property
 #ef table(self):
 #ry:
 #f isinstance(self.parent, Table):
 #eturn self.parent
 #xcept AttributeError:
 #ass
 #aise exc.InvalidRequestError(
 #This constraint is not bound to a table.  Did you "
 #mean to call table.append_constraint(constraint) ?"
 #

 #ef _set_parent(self, parent, **kw):
 #elf.parent = parent
 #arent.constraints.add(self)

 #util.deprecated(
 #1.4",
 #The :meth:`_schema.Constraint.copy` method is deprecated "
 #and will be removed in a future release.",
 #
 #ef copy(self, **kw):
 #eturn self._copy(**kw)

 #ef _copy(self, **kw):
 #aise NotImplementedError()


class ColumnCollectionMixin(object):

 #olumns = None
 #""A :class:`_expression.ColumnCollection` of :class:`_schema.Column`
 #bjects.

 #his collection represents the columns which are referred to by
 #his object.

 #""

 #allow_multiple_tables = False

 #ef __init__(self, *columns, **kw):
 #autoattach = kw.pop("_autoattach", True)
 #elf._column_flag = kw.pop("_column_flag", False)
 #elf.columns = DedupeColumnCollection()

 #rocessed_expressions = kw.pop("_gather_expressions", None)
 #f processed_expressions is not None:
 #elf._pending_colargs = []
 #or (
 #xpr,
 #olumn,
 #trname,
 #dd_element,
 # in coercions.expect_col_expression_collection(
 #oles.DDLConstraintColumnRole, columns
 #:
 #elf._pending_colargs.append(add_element)
 #rocessed_expressions.append(expr)
 #lse:
 #elf._pending_colargs = [
 #oercions.expect(roles.DDLConstraintColumnRole, column)
 #or column in columns
 #

 #f _autoattach and self._pending_colargs:
 #elf._check_attach()

 #ef _check_attach(self, evt=False):
 #ol_objs = [c for c in self._pending_colargs if isinstance(c, Column)]

 #ols_w_table = [c for c in col_objs if isinstance(c.table, Table)]

 #ols_wo_table = set(col_objs).difference(cols_w_table)
 #f cols_wo_table:
            # feature #3341 - place event listeners for Column objects
            # such that when all those cols are attached, we autoattach.
 #ssert not evt, "Should not reach here on event call"

            # issue #3411 - don't do the per-column auto-attach if some of the
            # columns are specified as strings.
 #as_string_cols = set(
 # for c in self._pending_colargs if c is not None
 #.difference(col_objs)
 #f not has_string_cols:

 #ef _col_attached(column, table):
                    # this isinstance() corresponds with the
                    # isinstance() above; only want to count Table-bound
                    # columns
 #f isinstance(table, Table):
 #ols_wo_table.discard(column)
 #f not cols_wo_table:
 #elf._check_attach(evt=True)

 #elf._cols_wo_table = cols_wo_table
 #or col in cols_wo_table:
 #ol._on_table_attach(_col_attached)
 #eturn

 #olumns = cols_w_table

 #ables = {c.table for c in columns}
 #f len(tables) == 1:
 #elf._set_parent_with_dispatch(tables.pop())
 #lif len(tables) > 1 and not self._allow_multiple_tables:
 #able = columns[0].table
 #thers = [c for c in columns[1:] if c.table is not table]
 #f others:
 #aise exc.ArgumentError(
 #Column(s) %s are not part of table '%s'."
 # (
 #, ".join("'%s'" % c for c in others),
 #able.description,
 #
 #

 #ef _col_expressions(self, table):
 #eturn [
 #able.c[col] if isinstance(col, util.string_types) else col
 #or col in self._pending_colargs
 #

 #ef _set_parent(self, table, **kw):
 #or col in self._col_expressions(table):
 #f col is not None:
 #elf.columns.add(col)


class ColumnCollectionConstraint(ColumnCollectionMixin, Constraint):
 #""A constraint that proxies a ColumnCollection."""

 #ef __init__(self, *columns, **kw):
 #"""
 #param \*columns:
 # sequence of column names or Column objects.

 #param name:
 #ptional, the in-database name of this constraint.

 #param deferrable:
 #ptional bool.  If set, emit DEFERRABLE or NOT DEFERRABLE when
 #ssuing DDL for this constraint.

 #param initially:
 #ptional string.  If set, emit INITIALLY <value> when issuing DDL
 #or this constraint.

 #param \**kw: other keyword arguments including dialect-specific
 #rguments are propagated to the :class:`.Constraint` superclass.

 #""
 #autoattach = kw.pop("_autoattach", True)
 #column_flag = kw.pop("_column_flag", False)
 #onstraint.__init__(self, **kw)
 #olumnCollectionMixin.__init__(
 #elf, *columns, _autoattach=_autoattach, _column_flag=_column_flag
 #

 #olumns = None
 #""A :class:`_expression.ColumnCollection` representing the set of columns
 #or this constraint.

 #""

 #ef _set_parent(self, table, **kw):
 #onstraint._set_parent(self, table)
 #olumnCollectionMixin._set_parent(self, table)

 #ef __contains__(self, x):
 #eturn x in self.columns

 #util.deprecated(
 #1.4",
 #The :meth:`_schema.ColumnCollectionConstraint.copy` method "
 #is deprecated and will be removed in a future release.",
 #
 #ef copy(self, target_table=None, **kw):
 #eturn self._copy(target_table=target_table, **kw)

 #ef _copy(self, target_table=None, **kw):
        # ticket #5276
 #onstraint_kwargs = {}
 #or dialect_name in self.dialect_options:
 #ialect_options = self.dialect_options[dialect_name]._non_defaults
 #or (
 #ialect_option_key,
 #ialect_option_value,
 # in dialect_options.items():
 #onstraint_kwargs[
 #ialect_name + "_" + dialect_option_key
 # = dialect_option_value

 # = self.__class__(
 #ame=self.name,
 #eferrable=self.deferrable,
 #nitially=self.initially,
 #[
 #copy_expression(expr, self.parent, target_table)
 #or expr in self.columns
 #,
 #*constraint_kwargs
 #
 #eturn self._schema_item_copy(c)

 #ef contains_column(self, col):
 #""Return True if this constraint contains the given column.

 #ote that this object also contains an attribute ``.columns``
 #hich is a :class:`_expression.ColumnCollection` of
 #class:`_schema.Column` objects.

 #""

 #eturn self.columns.contains_column(col)

 #ef __iter__(self):
 #eturn iter(self.columns)

 #ef __len__(self):
 #eturn len(self.columns)


class CheckConstraint(ColumnCollectionConstraint):
 #""A table- or column-level CHECK constraint.

 #an be included in the definition of a Table or Column.
 #""

 #allow_multiple_tables = True

 #_visit_name__ = "table_or_column_check_constraint"

 #_document_text_coercion(
 #sqltext",
 #:class:`.CheckConstraint`",
 #:paramref:`.CheckConstraint.sqltext`",
 #
 #ef __init__(
 #elf,
 #qltext,
 #ame=None,
 #eferrable=None,
 #nitially=None,
 #able=None,
 #nfo=None,
 #create_rule=None,
 #autoattach=True,
 #type_bound=False,
 #*kw
 #:
 #"""Construct a CHECK constraint.

 #param sqltext:
 # string containing the constraint definition, which will be used
 #erbatim, or a SQL expression construct.   If given as a string,
 #he object is converted to a :func:`_expression.text` object.
 #f the textual
 #tring includes a colon character, escape this using a backslash::

 #heckConstraint(r"foo ~ E'a(?\:b|c)d")

 #param name:
 #ptional, the in-database name of the constraint.

 #param deferrable:
 #ptional bool.  If set, emit DEFERRABLE or NOT DEFERRABLE when
 #ssuing DDL for this constraint.

 #param initially:
 #ptional string.  If set, emit INITIALLY <value> when issuing DDL
 #or this constraint.

 #param info: Optional data dictionary which will be populated into the
 #attr:`.SchemaItem.info` attribute of this object.

 #. versionadded:: 1.0.0

 #""

 #elf.sqltext = coercions.expect(roles.DDLExpressionRole, sqltext)
 #olumns = []
 #isitors.traverse(self.sqltext, {}, {"column": columns.append})

 #uper(CheckConstraint, self).__init__(
 #ame=name,
 #eferrable=deferrable,
 #nitially=initially,
 #create_rule=_create_rule,
 #nfo=info,
 #type_bound=_type_bound,
 #autoattach=_autoattach,
 #columns,
 #*kw
 #
 #f table is not None:
 #elf._set_parent_with_dispatch(table)

 #property
 #ef is_column_level(self):
 #eturn not isinstance(self.parent, Table)

 #util.deprecated(
 #1.4",
 #The :meth:`_schema.CheckConstraint.copy` method is deprecated "
 #and will be removed in a future release.",
 #
 #ef copy(self, target_table=None, **kw):
 #eturn self._copy(target_table=target_table, **kw)

 #ef _copy(self, target_table=None, **kw):
 #f target_table is not None:
            # note that target_table is None for the copy process of
            # a column-bound CheckConstraint, so this path is not reached
            # in that case.
 #qltext = _copy_expression(self.sqltext, self.table, target_table)
 #lse:
 #qltext = self.sqltext
 # = CheckConstraint(
 #qltext,
 #ame=self.name,
 #nitially=self.initially,
 #eferrable=self.deferrable,
 #create_rule=self._create_rule,
 #able=target_table,
 #autoattach=False,
 #type_bound=self._type_bound,
 #
 #eturn self._schema_item_copy(c)


class ForeignKeyConstraint(ColumnCollectionConstraint):
 #""A table-level FOREIGN KEY constraint.

 #efines a single column or composite FOREIGN KEY ... REFERENCES
 #onstraint. For a no-frills, single column foreign key, adding a
 #class:`_schema.ForeignKey` to the definition of a :class:`_schema.Column`
 #s a
 #horthand equivalent for an unnamed, single column
 #class:`_schema.ForeignKeyConstraint`.

 #xamples of foreign key configuration are in :ref:`metadata_foreignkeys`.

 #""

 #_visit_name__ = "foreign_key_constraint"

 #ef __init__(
 #elf,
 #olumns,
 #efcolumns,
 #ame=None,
 #nupdate=None,
 #ndelete=None,
 #eferrable=None,
 #nitially=None,
 #se_alter=False,
 #ink_to_name=False,
 #atch=None,
 #able=None,
 #nfo=None,
 #*dialect_kw
 #:
 #"""Construct a composite-capable FOREIGN KEY.

 #param columns: A sequence of local column names. The named columns
 #ust be defined and present in the parent Table. The names should
 #atch the ``key`` given to each column (defaults to the name) unless
 #`link_to_name`` is True.

 #param refcolumns: A sequence of foreign column names or Column
 #bjects. The columns must all be located within the same Table.

 #param name: Optional, the in-database name of the key.

 #param onupdate: Optional string. If set, emit ON UPDATE <value> when
 #ssuing DDL for this constraint. Typical values include CASCADE,
 #ELETE and RESTRICT.

 #param ondelete: Optional string. If set, emit ON DELETE <value> when
 #ssuing DDL for this constraint. Typical values include CASCADE,
 #ELETE and RESTRICT.

 #param deferrable: Optional bool. If set, emit DEFERRABLE or NOT
 #EFERRABLE when issuing DDL for this constraint.

 #param initially: Optional string. If set, emit INITIALLY <value> when
 #ssuing DDL for this constraint.

 #param link_to_name: if True, the string name given in ``column`` is
 #he rendered name of the referenced column, not its locally assigned
 #`key``.

 #param use_alter: If True, do not emit the DDL for this constraint as
 #art of the CREATE TABLE definition. Instead, generate it via an
 #LTER TABLE statement issued after the full collection of tables
 #ave been created, and drop it via an ALTER TABLE statement before
 #he full collection of tables are dropped.

 #he use of :paramref:`_schema.ForeignKeyConstraint.use_alter` is
 #articularly geared towards the case where two or more tables
 #re established within a mutually-dependent foreign key constraint
 #elationship; however, the :meth:`_schema.MetaData.create_all` and
 #meth:`_schema.MetaData.drop_all`
 #ethods will perform this resolution
 #utomatically, so the flag is normally not needed.

 #. versionchanged:: 1.0.0  Automatic resolution of foreign key
 #ycles has been added, removing the need to use the
 #paramref:`_schema.ForeignKeyConstraint.use_alter` in typical use
 #ases.

 #. seealso::

 #ref:`use_alter`

 #param match: Optional string. If set, emit MATCH <value> when issuing
 #DL for this constraint. Typical values include SIMPLE, PARTIAL
 #nd FULL.

 #param info: Optional data dictionary which will be populated into the
 #attr:`.SchemaItem.info` attribute of this object.

 #. versionadded:: 1.0.0

 #param \**dialect_kw:  Additional keyword arguments are dialect
 #pecific, and passed in the form ``<dialectname>_<argname>``.  See
 #he documentation regarding an individual dialect at
 #ref:`dialect_toplevel` for detail on documented arguments.

 #. versionadded:: 0.9.2

 #""

 #onstraint.__init__(
 #elf,
 #ame=name,
 #eferrable=deferrable,
 #nitially=initially,
 #nfo=info,
 #*dialect_kw
 #
 #elf.onupdate = onupdate
 #elf.ondelete = ondelete
 #elf.link_to_name = link_to_name
 #elf.use_alter = use_alter
 #elf.match = match

 #f len(set(columns)) != len(refcolumns):
 #f len(set(columns)) != len(columns):
                # e.g. FOREIGN KEY (a, a) REFERENCES r (b, c)
 #aise exc.ArgumentError(
 #ForeignKeyConstraint with duplicate source column "
 #references are not supported."
 #
 #lse:
                # e.g. FOREIGN KEY (a) REFERENCES r (b, c)
                # paraphrasing https://www.postgresql.org/docs/9.2/static/\
                # ddl-constraints.html
 #aise exc.ArgumentError(
 #ForeignKeyConstraint number "
 #of constrained columns must match the number of "
 #referenced columns."
 #

        # standalone ForeignKeyConstraint - create
        # associated ForeignKey objects which will be applied to hosted
        # Column objects (in col.foreign_keys), either now or when attached
        # to the Table for string-specified names
 #elf.elements = [
 #oreignKey(
 #efcol,
 #constraint=self,
 #ame=self.name,
 #nupdate=self.onupdate,
 #ndelete=self.ondelete,
 #se_alter=self.use_alter,
 #ink_to_name=self.link_to_name,
 #atch=self.match,
 #eferrable=self.deferrable,
 #nitially=self.initially,
 #*self.dialect_kwargs
 #
 #or refcol in refcolumns
 #

 #olumnCollectionMixin.__init__(self, *columns)
 #f table is not None:
 #f hasattr(self, "parent"):
 #ssert table is self.parent
 #elf._set_parent_with_dispatch(table)

 #ef _append_element(self, column, fk):
 #elf.columns.add(column)
 #elf.elements.append(fk)

 #olumns = None
 #""A :class:`_expression.ColumnCollection` representing the set of columns
 #or this constraint.

 #""

 #lements = None
 #""A sequence of :class:`_schema.ForeignKey` objects.

 #ach :class:`_schema.ForeignKey`
 #epresents a single referring column/referred
 #olumn pair.

 #his collection is intended to be read-only.

 #""

 #property
 #ef _elements(self):
        # legacy - provide a dictionary view of (column_key, fk)
 #eturn util.OrderedDict(zip(self.column_keys, self.elements))

 #property
 #ef _referred_schema(self):
 #or elem in self.elements:
 #eturn elem._referred_schema
 #lse:
 #eturn None

 #property
 #ef referred_table(self):
 #""The :class:`_schema.Table` object to which this
 #class:`_schema.ForeignKeyConstraint` references.

 #his is a dynamically calculated attribute which may not be available
 #f the constraint and/or parent table is not yet associated with
 # metadata collection that contains the referred table.

 #. versionadded:: 1.0.0

 #""
 #eturn self.elements[0].column.table

 #ef _validate_dest_table(self, table):
 #able_keys = set([elem._table_key() for elem in self.elements])
 #f None not in table_keys and len(table_keys) > 1:
 #lem0, elem1 = sorted(table_keys)[0:2]
 #aise exc.ArgumentError(
 #ForeignKeyConstraint on %s(%s) refers to "
 #multiple remote tables: %s and %s"
 # (table.fullname, self._col_description, elem0, elem1)
 #

 #property
 #ef column_keys(self):
 #""Return a list of string keys representing the local
 #olumns in this :class:`_schema.ForeignKeyConstraint`.

 #his list is either the original string arguments sent
 #o the constructor of the :class:`_schema.ForeignKeyConstraint`,
 #r if the constraint has been initialized with :class:`_schema.Column`
 #bjects, is the string ``.key`` of each element.

 #. versionadded:: 1.0.0

 #""
 #f hasattr(self, "parent"):
 #eturn self.columns.keys()
 #lse:
 #eturn [
 #ol.key if isinstance(col, ColumnElement) else str(col)
 #or col in self._pending_colargs
 #

 #property
 #ef _col_description(self):
 #eturn ", ".join(self.column_keys)

 #ef _set_parent(self, table, **kw):
 #onstraint._set_parent(self, table)

 #ry:
 #olumnCollectionConstraint._set_parent(self, table)
 #xcept KeyError as ke:
 #til.raise_(
 #xc.ArgumentError(
 #Can't create ForeignKeyConstraint "
 #on table '%s': no column "
 #named '%s' is present." % (table.description, ke.args[0])
 #,
 #rom_=ke,
 #

 #or col, fk in zip(self.columns, self.elements):
 #f not hasattr(fk, "parent") or fk.parent is not col:
 #k._set_parent_with_dispatch(col)

 #elf._validate_dest_table(table)

 #util.deprecated(
 #1.4",
 #The :meth:`_schema.ForeignKeyConstraint.copy` method is deprecated "
 #and will be removed in a future release.",
 #
 #ef copy(self, schema=None, target_table=None, **kw):
 #eturn self._copy(schema=schema, target_table=target_table, **kw)

 #ef _copy(self, schema=None, target_table=None, **kw):
 #kc = ForeignKeyConstraint(
 #x.parent.key for x in self.elements],
 #
 #._get_colspec(
 #chema=schema,
 #able_name=target_table.name
 #f target_table is not None
 #nd x._table_key() == x.parent.table.key
 #lse None,
 #
 #or x in self.elements
 #,
 #ame=self.name,
 #nupdate=self.onupdate,
 #ndelete=self.ondelete,
 #se_alter=self.use_alter,
 #eferrable=self.deferrable,
 #nitially=self.initially,
 #ink_to_name=self.link_to_name,
 #atch=self.match,
 #
 #or self_fk, other_fk in zip(self.elements, fkc.elements):
 #elf_fk._schema_item_copy(other_fk)
 #eturn self._schema_item_copy(fkc)


class PrimaryKeyConstraint(ColumnCollectionConstraint):
 #""A table-level PRIMARY KEY constraint.

 #he :class:`.PrimaryKeyConstraint` object is present automatically
 #n any :class:`_schema.Table` object; it is assigned a set of
 #class:`_schema.Column` objects corresponding to those marked with
 #he :paramref:`_schema.Column.primary_key` flag::

 #>> my_table = Table('mytable', metadata,
 #..                 Column('id', Integer, primary_key=True),
 #..                 Column('version_id', Integer, primary_key=True),
 #..                 Column('data', String(50))
 #..     )
 #>> my_table.primary_key
 #rimaryKeyConstraint(
 #olumn('id', Integer(), table=<mytable>,
 #rimary_key=True, nullable=False),
 #olumn('version_id', Integer(), table=<mytable>,
 #rimary_key=True, nullable=False)
 #

 #he primary key of a :class:`_schema.Table` can also be specified by using
 # :class:`.PrimaryKeyConstraint` object explicitly; in this mode of usage,
 #he "name" of the constraint can also be specified, as well as other
 #ptions which may be recognized by dialects::

 #y_table = Table('mytable', metadata,
 #olumn('id', Integer),
 #olumn('version_id', Integer),
 #olumn('data', String(50)),
 #rimaryKeyConstraint('id', 'version_id',
 #ame='mytable_pk')
 #

 #he two styles of column-specification should generally not be mixed.
 #n warning is emitted if the columns present in the
 #class:`.PrimaryKeyConstraint`
 #on't match the columns that were marked as ``primary_key=True``, if both
 #re present; in this case, the columns are taken strictly from the
 #class:`.PrimaryKeyConstraint` declaration, and those columns otherwise
 #arked as ``primary_key=True`` are ignored.  This behavior is intended to
 #e backwards compatible with previous behavior.

 #. versionchanged:: 0.9.2  Using a mixture of columns within a
 #class:`.PrimaryKeyConstraint` in addition to columns marked as
 #`primary_key=True`` now emits a warning if the lists don't match.
 #he ultimate behavior of ignoring those columns marked with the flag
 #nly is currently maintained for backwards compatibility; this warning
 #ay raise an exception in a future release.

 #or the use case where specific options are to be specified on the
 #class:`.PrimaryKeyConstraint`, but the usual style of using
 #`primary_key=True`` flags is still desirable, an empty
 #class:`.PrimaryKeyConstraint` may be specified, which will take on the
 #rimary key column collection from the :class:`_schema.Table` based on the
 #lags::

 #y_table = Table('mytable', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('version_id', Integer, primary_key=True),
 #olumn('data', String(50)),
 #rimaryKeyConstraint(name='mytable_pk',
 #ssql_clustered=True)
 #

 #. versionadded:: 0.9.2 an empty :class:`.PrimaryKeyConstraint` may now
 #e specified for the purposes of establishing keyword arguments with
 #he constraint, independently of the specification of "primary key"
 #olumns within the :class:`_schema.Table` itself; columns marked as
 #`primary_key=True`` will be gathered into the empty constraint's
 #olumn collection.

 #""

 #_visit_name__ = "primary_key_constraint"

 #ef __init__(self, *columns, **kw):
 #elf._implicit_generated = kw.pop("_implicit_generated", False)
 #uper(PrimaryKeyConstraint, self).__init__(*columns, **kw)

 #ef _set_parent(self, table, **kw):
 #uper(PrimaryKeyConstraint, self)._set_parent(table)

 #f table.primary_key is not self:
 #able.constraints.discard(table.primary_key)
 #able.primary_key = self
 #able.constraints.add(self)

 #able_pks = [c for c in table.c if c.primary_key]
 #f self.columns and table_pks and set(table_pks) != set(self.columns):
 #til.warn(
 #Table '%s' specifies columns %s as primary_key=True, "
 #not matching locally specified columns %s; setting the "
 #current primary key columns to %s. This warning "
 #may become an exception in a future release"
 # (
 #able.name,
 #, ".join("'%s'" % c.name for c in table_pks),
 #, ".join("'%s'" % c.name for c in self.columns),
 #, ".join("'%s'" % c.name for c in self.columns),
 #
 #
 #able_pks[:] = []

 #or c in self.columns:
 #.primary_key = True
 #f c._user_defined_nullable is NULL_UNSPECIFIED:
 #.nullable = False
 #f table_pks:
 #elf.columns.extend(table_pks)

 #ef _reload(self, columns):
 #""repopulate this :class:`.PrimaryKeyConstraint` given
 # set of columns.

 #xisting columns in the table that are marked as primary_key=True
 #re maintained.

 #lso fires a new event.

 #his is basically like putting a whole new
 #class:`.PrimaryKeyConstraint` object on the parent
 #class:`_schema.Table` object without actually replacing the object.

 #he ordering of the given list of columns is also maintained; these
 #olumns will be appended to the list of columns after any which
 #re already present.

 #""
        # set the primary key flag on new columns.
        # note any existing PK cols on the table also have their
        # flag still set.
 #or col in columns:
 #ol.primary_key = True

 #elf.columns.extend(columns)

 #rimaryKeyConstraint._autoincrement_column._reset(self)
 #elf._set_parent_with_dispatch(self.table)

 #ef _replace(self, col):
 #rimaryKeyConstraint._autoincrement_column._reset(self)
 #elf.columns.replace(col)

 #elf.dispatch._sa_event_column_added_to_pk_constraint(self, col)

 #property
 #ef columns_autoinc_first(self):
 #utoinc = self._autoincrement_column

 #f autoinc is not None:
 #eturn [autoinc] + [c for c in self.columns if c is not autoinc]
 #lse:
 #eturn list(self.columns)

 #util.memoized_property
 #ef _autoincrement_column(self):
 #ef _validate_autoinc(col, autoinc_true):
 #f col.type._type_affinity is None or not issubclass(
 #ol.type._type_affinity, type_api.INTEGERTYPE._type_affinity
 #:
 #f autoinc_true:
 #aise exc.ArgumentError(
 #Column type %s on column '%s' is not "
 #compatible with autoincrement=True" % (col.type, col)
 #
 #lse:
 #eturn False
 #lif (
 #ot isinstance(col.default, (type(None), Sequence))
 #nd not autoinc_true
 #:
 #eturn False
 #lif (
 #ol.server_default is not None
 #nd not isinstance(col.server_default, Identity)
 #nd not autoinc_true
 #:
 #eturn False
 #lif col.foreign_keys and col.autoincrement not in (
 #rue,
 #ignore_fk",
 #:
 #eturn False
 #eturn True

 #f len(self.columns) == 1:
 #ol = list(self.columns)[0]

 #f col.autoincrement is True:
 #validate_autoinc(col, True)
 #eturn col
 #lif (
 #ol.autoincrement
 #n (
 #auto",
 #ignore_fk",
 #
 #nd _validate_autoinc(col, False)
 #:
 #eturn col

 #lse:
 #utoinc = None
 #or col in self.columns:
 #f col.autoincrement is True:
 #validate_autoinc(col, True)
 #f autoinc is not None:
 #aise exc.ArgumentError(
 #Only one Column may be marked "
 #autoincrement=True, found both %s and %s."
 # (col.name, autoinc.name)
 #
 #lse:
 #utoinc = col

 #eturn autoinc


class UniqueConstraint(ColumnCollectionConstraint):
 #""A table-level UNIQUE constraint.

 #efines a single column or composite UNIQUE constraint. For a no-frills,
 #ingle column constraint, adding ``unique=True`` to the ``Column``
 #efinition is a shorthand equivalent for an unnamed, single column
 #niqueConstraint.
 #""

 #_visit_name__ = "unique_constraint"


class Index(DialectKWArgs, ColumnCollectionMixin, SchemaItem):
 #""A table-level INDEX.

 #efines a composite (one or more column) INDEX.

 #.g.::

 #ometable = Table("sometable", metadata,
 #olumn("name", String(50)),
 #olumn("address", String(100))
 #

 #ndex("some_index", sometable.c.name)

 #or a no-frills, single column index, adding
 #class:`_schema.Column` also supports ``index=True``::

 #ometable = Table("sometable", metadata,
 #olumn("name", String(50), index=True)
 #

 #or a composite index, multiple columns can be specified::

 #ndex("some_index", sometable.c.name, sometable.c.address)

 #unctional indexes are supported as well, typically by using the
 #data:`.func` construct in conjunction with table-bound
 #class:`_schema.Column` objects::

 #ndex("some_index", func.lower(sometable.c.name))

 #n :class:`.Index` can also be manually associated with a
 #class:`_schema.Table`,
 #ither through inline declaration or using
 #meth:`_schema.Table.append_constraint`.  When this approach is used,
 #he names
 #f the indexed columns can be specified as strings::

 #able("sometable", metadata,
 #olumn("name", String(50)),
 #olumn("address", String(100)),
 #ndex("some_index", "name", "address")
 #

 #o support functional or expression-based indexes in this form, the
 #func:`_expression.text` construct may be used::

 #rom sqlalchemy import text

 #able("sometable", metadata,
 #olumn("name", String(50)),
 #olumn("address", String(100)),
 #ndex("some_index", text("lower(name)"))
 #

 #. versionadded:: 0.9.5 the :func:`_expression.text`
 #onstruct may be used to
 #pecify :class:`.Index` expressions, provided the :class:`.Index`
 #s explicitly associated with the :class:`_schema.Table`.


 #. seealso::

 #ref:`schema_indexes` - General information on :class:`.Index`.

 #ref:`postgresql_indexes` - PostgreSQL-specific options available for
 #he :class:`.Index` construct.

 #ref:`mysql_indexes` - MySQL-specific options available for the
 #class:`.Index` construct.

 #ref:`mssql_indexes` - MSSQL-specific options available for the
 #class:`.Index` construct.

 #""

 #_visit_name__ = "index"

 #ef __init__(self, name, *expressions, **kw):
 #"""Construct an index object.

 #param name:
 #he name of the index

 #param \*expressions:
 #olumn expressions to include in the index.   The expressions
 #re normally instances of :class:`_schema.Column`, but may also
 #e arbitrary SQL expressions which ultimately refer to a
 #class:`_schema.Column`.

 #param unique=False:
 #eyword only argument; if True, create a unique index.

 #param quote=None:
 #eyword only argument; whether to apply quoting to the name of
 #he index.  Works in the same manner as that of
 #paramref:`_schema.Column.quote`.

 #param info=None: Optional data dictionary which will be populated
 #nto the :attr:`.SchemaItem.info` attribute of this object.

 #. versionadded:: 1.0.0

 #param \**kw: Additional keyword arguments not mentioned above are
 #ialect specific, and passed in the form
 #`<dialectname>_<argname>``. See the documentation regarding an
 #ndividual dialect at :ref:`dialect_toplevel` for detail on
 #ocumented arguments.

 #""
 #elf.table = table = None

 #elf.name = quoted_name(name, kw.pop("quote", None))
 #elf.unique = kw.pop("unique", False)
 #column_flag = kw.pop("_column_flag", False)
 #f "info" in kw:
 #elf.info = kw.pop("info")

        # TODO: consider "table" argument being public, but for
        # the purpose of the fix here, it starts as private.
 #f "_table" in kw:
 #able = kw.pop("_table")

 #elf._validate_dialect_kwargs(kw)

 #elf.expressions = []
        # will call _set_parent() if table-bound column
        # objects are present
 #olumnCollectionMixin.__init__(
 #elf,
 #expressions,
 #column_flag=_column_flag,
 #gather_expressions=self.expressions
 #

 #f table is not None:
 #elf._set_parent(table)

 #ef _set_parent(self, table, **kw):
 #olumnCollectionMixin._set_parent(self, table)

 #f self.table is not None and table is not self.table:
 #aise exc.ArgumentError(
 #Index '%s' is against table '%s', and "
 #cannot be associated with table '%s'."
 # (self.name, self.table.description, table.description)
 #
 #elf.table = table
 #able.indexes.add(self)

 #xpressions = self.expressions
 #ol_expressions = self._col_expressions(table)
 #ssert len(expressions) == len(col_expressions)
 #elf.expressions = [
 #xpr if isinstance(expr, ClauseElement) else colexpr
 #or expr, colexpr in zip(expressions, col_expressions)
 #

 #property
 #ef bind(self):
 #""Return the connectable associated with this Index."""

 #eturn self.table.bind

 #ef create(self, bind=None, checkfirst=False):
 #""Issue a ``CREATE`` statement for this
 #class:`.Index`, using the given :class:`.Connectable`
 #or connectivity.

 #. seealso::

 #meth:`_schema.MetaData.create_all`.

 #""
 #f bind is None:
 #ind = _bind_or_error(self)
 #ind._run_ddl_visitor(ddl.SchemaGenerator, self, checkfirst=checkfirst)
 #eturn self

 #ef drop(self, bind=None, checkfirst=False):
 #""Issue a ``DROP`` statement for this
 #class:`.Index`, using the given :class:`.Connectable`
 #or connectivity.

 #. seealso::

 #meth:`_schema.MetaData.drop_all`.

 #""
 #f bind is None:
 #ind = _bind_or_error(self)
 #ind._run_ddl_visitor(ddl.SchemaDropper, self, checkfirst=checkfirst)

 #ef __repr__(self):
 #eturn "Index(%s)" % (
 #, ".join(
 #repr(self.name)]
 # [repr(e) for e in self.expressions]
 # (self.unique and ["unique=True"] or [])
 #
 #


DEFAULT_NAMING_CONVENTION = util.immutabledict({"ix": "ix_%(column_0_label)s"})


class MetaData(SchemaItem):
 #""A collection of :class:`_schema.Table`
 #bjects and their associated schema
 #onstructs.

 #olds a collection of :class:`_schema.Table` objects as well as
 #n optional binding to an :class:`_engine.Engine` or
 #class:`_engine.Connection`.  If bound, the :class:`_schema.Table` objects
 #n the collection and their columns may participate in implicit SQL
 #xecution.

 #he :class:`_schema.Table` objects themselves are stored in the
 #attr:`_schema.MetaData.tables` dictionary.

 #class:`_schema.MetaData` is a thread-safe object for read operations.
 #onstruction of new tables within a single :class:`_schema.MetaData`
 #bject,
 #ither explicitly or via reflection, may not be completely thread-safe.

 #. seealso::

 #ref:`metadata_describing` - Introduction to database metadata

 #""

 #_visit_name__ = "metadata"

 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_schema.MetaData.bind` argument is deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef __init__(
 #elf,
 #ind=None,
 #chema=None,
 #uote_schema=None,
 #aming_convention=None,
 #nfo=None,
 #:
 #""Create a new MetaData object.

 #param bind:
 #n Engine or Connection to bind to.  May also be a string or URL
 #nstance, these are passed to :func:`_sa.create_engine` and
 #his :class:`_schema.MetaData` will
 #e bound to the resulting engine.

 #param schema:
 #he default schema to use for the :class:`_schema.Table`,
 #class:`.Sequence`, and potentially other objects associated with
 #his :class:`_schema.MetaData`. Defaults to ``None``.

 #. seealso::

 #ref:`schema_metadata_schema_name` - details on how the
 #paramref:`_schema.MetaData.schema` parameter is used.

 #paramref:`_schema.Table.schema`

 #paramref:`.Sequence.schema`

 #param quote_schema:
 #ets the ``quote_schema`` flag for those :class:`_schema.Table`,
 #class:`.Sequence`, and other objects which make usage of the
 #ocal ``schema`` name.

 #param info: Optional data dictionary which will be populated into the
 #attr:`.SchemaItem.info` attribute of this object.

 #. versionadded:: 1.0.0

 #param naming_convention: a dictionary referring to values which
 #ill establish default naming conventions for :class:`.Constraint`
 #nd :class:`.Index` objects, for those objects which are not given
 # name explicitly.

 #he keys of this dictionary may be:

 # a constraint or Index class, e.g. the :class:`.UniqueConstraint`,
 #class:`_schema.ForeignKeyConstraint` class, the :class:`.Index`
 #lass

 # a string mnemonic for one of the known constraint classes;
 #`"fk"``, ``"pk"``, ``"ix"``, ``"ck"``, ``"uq"`` for foreign key,
 #rimary key, index, check, and unique constraint, respectively.

 # the string name of a user-defined "token" that can be used
 #o define new naming tokens.

 #he values associated with each "constraint class" or "constraint
 #nemonic" key are string naming templates, such as
 #`"uq_%(table_name)s_%(column_0_name)s"``,
 #hich describe how the name should be composed.  The values
 #ssociated with user-defined "token" keys should be callables of the
 #orm ``fn(constraint, table)``, which accepts the constraint/index
 #bject and :class:`_schema.Table` as arguments, returning a string
 #esult.

 #he built-in names are as follows, some of which may only be
 #vailable for certain types of constraint:

 # ``%(table_name)s`` - the name of the :class:`_schema.Table`
 #bject
 #ssociated with the constraint.

 # ``%(referred_table_name)s`` - the name of the
 #class:`_schema.Table`
 #bject associated with the referencing target of a
 #class:`_schema.ForeignKeyConstraint`.

 # ``%(column_0_name)s`` - the name of the :class:`_schema.Column`
 #t
 #ndex position "0" within the constraint.

 # ``%(column_0N_name)s`` - the name of all :class:`_schema.Column`
 #bjects in order within the constraint, joined without a
 #eparator.

 # ``%(column_0_N_name)s`` - the name of all
 #class:`_schema.Column`
 #bjects in order within the constraint, joined with an
 #nderscore as a separator.

 # ``%(column_0_label)s``, ``%(column_0N_label)s``,
 #`%(column_0_N_label)s`` - the label of either the zeroth
 #class:`_schema.Column` or all :class:`.Columns`, separated with
 #r without an underscore

 # ``%(column_0_key)s``, ``%(column_0N_key)s``,
 #`%(column_0_N_key)s`` - the key of either the zeroth
 #class:`_schema.Column` or all :class:`.Columns`, separated with
 #r without an underscore

 # ``%(referred_column_0_name)s``, ``%(referred_column_0N_name)s``
 #`%(referred_column_0_N_name)s``,  ``%(referred_column_0_key)s``,
 #`%(referred_column_0N_key)s``, ...  column tokens which
 #ender the names/keys/labels of columns that are referenced
 #y a  :class:`_schema.ForeignKeyConstraint`.

 # ``%(constraint_name)s`` - a special key that refers to the
 #xisting name given to the constraint.  When this key is
 #resent, the :class:`.Constraint` object's existing name will be
 #eplaced with one that is composed from template string that
 #ses this token. When this token is present, it is required that
 #he :class:`.Constraint` is given an explicit name ahead of time.

 # user-defined: any additional token may be implemented by passing
 #t along with a ``fn(constraint, table)`` callable to the
 #aming_convention dictionary.

 #. versionadded:: 1.3.0 - added new ``%(column_0N_name)s``,
 #`%(column_0_N_name)s``, and related tokens that produce
 #oncatenations of names, keys, or labels for all columns referred
 #o by a given constraint.

 #. seealso::

 #ref:`constraint_naming_conventions` - for detailed usage
 #xamples.

 #""
 #elf.tables = util.FacadeDict()
 #elf.schema = quoted_name(schema, quote_schema)
 #elf.naming_convention = (
 #aming_convention
 #f naming_convention
 #lse DEFAULT_NAMING_CONVENTION
 #
 #f info:
 #elf.info = info
 #elf._schemas = set()
 #elf._sequences = {}
 #elf._fk_memos = collections.defaultdict(list)

 #elf.bind = bind

 #ables = None
 #""A dictionary of :class:`_schema.Table`
 #bjects keyed to their name or "table key".

 #he exact key is that determined by the :attr:`_schema.Table.key`
 #ttribute;
 #or a table with no :attr:`_schema.Table.schema` attribute,
 #his is the same
 #s :attr:`_schema.Table.name`.  For a table with a schema,
 #t is typically of the
 #orm ``schemaname.tablename``.

 #. seealso::

 #attr:`_schema.MetaData.sorted_tables`

 #""

 #ef __repr__(self):
 #f self.bind:
 #eturn "MetaData(bind=%r)" % self.bind
 #lse:
 #eturn "MetaData()"

 #ef __contains__(self, table_or_key):
 #f not isinstance(table_or_key, util.string_types):
 #able_or_key = table_or_key.key
 #eturn table_or_key in self.tables

 #ef _add_table(self, name, schema, table):
 #ey = _get_table_key(name, schema)
 #elf.tables._insert_item(key, table)
 #f schema:
 #elf._schemas.add(schema)

 #ef _remove_table(self, name, schema):
 #ey = _get_table_key(name, schema)
 #emoved = dict.pop(self.tables, key, None)
 #f removed is not None:
 #or fk in removed.foreign_keys:
 #k._remove_from_metadata(self)
 #f self._schemas:
 #elf._schemas = set(
 #
 #.schema
 #or t in self.tables.values()
 #f t.schema is not None
 #
 #

 #ef __getstate__(self):
 #eturn {
 #tables": self.tables,
 #schema": self.schema,
 #schemas": self._schemas,
 #sequences": self._sequences,
 #fk_memos": self._fk_memos,
 #naming_convention": self.naming_convention,
 #

 #ef __setstate__(self, state):
 #elf.tables = state["tables"]
 #elf.schema = state["schema"]
 #elf.naming_convention = state["naming_convention"]
 #elf._bind = None
 #elf._sequences = state["sequences"]
 #elf._schemas = state["schemas"]
 #elf._fk_memos = state["fk_memos"]

 #ef is_bound(self):
 #""True if this MetaData is bound to an Engine or Connection."""

 #eturn self._bind is not None

 #ef bind(self):
 #""An :class:`_engine.Engine` or :class:`_engine.Connection`
 #o which this
 #class:`_schema.MetaData` is bound.

 #ypically, a :class:`_engine.Engine` is assigned to this attribute
 #o that "implicit execution" may be used, or alternatively
 #s a means of providing engine binding information to an
 #RM :class:`.Session` object::

 #ngine = create_engine("someurl://")
 #etadata.bind = engine

 #. seealso::

 #ref:`dbengine_implicit` - background on "bound metadata"

 #""
 #eturn self._bind

 #util.preload_module("sqlalchemy.engine.url")
 #ef _bind_to(self, bind):
 #""Bind this MetaData to an Engine, Connection, string or URL."""
 #rl = util.preloaded.engine_url
 #f isinstance(bind, util.string_types + (url.URL,)):
 #elf._bind = sqlalchemy.create_engine(bind)
 #lse:
 #elf._bind = bind

 #ind = property(bind, _bind_to)

 #ef clear(self):
 #""Clear all Table objects from this MetaData."""

 #ict.clear(self.tables)
 #elf._schemas.clear()
 #elf._fk_memos.clear()

 #ef remove(self, table):
 #""Remove the given Table object from this MetaData."""

 #elf._remove_table(table.name, table.schema)

 #property
 #ef sorted_tables(self):
 #""Returns a list of :class:`_schema.Table` objects sorted in order of
 #oreign key dependency.

 #he sorting will place :class:`_schema.Table`
 #bjects that have dependencies
 #irst, before the dependencies themselves, representing the
 #rder in which they can be created.   To get the order in which
 #he tables would be dropped, use the ``reversed()`` Python built-in.

 #. warning::

 #he :attr:`.MetaData.sorted_tables` attribute cannot by itself
 #ccommodate automatic resolution of dependency cycles between
 #ables, which are usually caused by mutually dependent foreign key
 #onstraints. When these cycles are detected, the foreign keys
 #f these tables are omitted from consideration in the sort.
 # warning is emitted when this condition occurs, which will be an
 #xception raise in a future release.   Tables which are not part
 #f the cycle will still be returned in dependency order.

 #o resolve these cycles, the
 #paramref:`_schema.ForeignKeyConstraint.use_alter` parameter may be
 #pplied to those constraints which create a cycle.  Alternatively,
 #he :func:`_schema.sort_tables_and_constraints` function will
 #utomatically return foreign key constraints in a separate
 #ollection when cycles are detected so that they may be applied
 #o a schema separately.

 #. versionchanged:: 1.3.17 - a warning is emitted when
 #attr:`.MetaData.sorted_tables` cannot perform a proper sort
 #ue to cyclical dependencies.  This will be an exception in a
 #uture release.  Additionally, the sort will continue to return
 #ther tables not involved in the cycle in dependency order which
 #as not the case previously.

 #. seealso::

 #func:`_schema.sort_tables`

 #func:`_schema.sort_tables_and_constraints`

 #attr:`_schema.MetaData.tables`

 #meth:`_reflection.Inspector.get_table_names`

 #meth:`_reflection.Inspector.get_sorted_table_and_fkc_names`


 #""
 #eturn ddl.sort_tables(
 #orted(self.tables.values(), key=lambda t: t.key)
 #

 #ef reflect(
 #elf,
 #ind=None,
 #chema=None,
 #iews=False,
 #nly=None,
 #xtend_existing=False,
 #utoload_replace=True,
 #esolve_fks=True,
 #*dialect_kwargs
 #:
 #"""Load all available table definitions from the database.

 #utomatically creates ``Table`` entries in this ``MetaData`` for any
 #able available in the database but not yet present in the
 #`MetaData``.  May be called multiple times to pick up tables recently
 #dded to the database, however no special action is taken if a table
 #n this ``MetaData`` no longer exists in the database.

 #param bind:
 # :class:`.Connectable` used to access the database; if None, uses
 #he existing bind on this ``MetaData``, if any.

 #. note:: the "bind" argument will be required in
 #QLAlchemy 2.0.

 #param schema:
 #ptional, query and reflect tables from an alternate schema.
 #f None, the schema associated with this :class:`_schema.MetaData`
 #s used, if any.

 #param views:
 #f True, also reflect views.

 #param only:
 #ptional.  Load only a sub-set of available named tables.  May be
 #pecified as a sequence of names or a callable.

 #f a sequence of names is provided, only those tables will be
 #eflected.  An error is raised if a table is requested but not
 #vailable.  Named tables already present in this ``MetaData`` are
 #gnored.

 #f a callable is provided, it will be used as a boolean predicate to
 #ilter the list of potential table names.  The callable is called
 #ith a table name and this ``MetaData`` instance as positional
 #rguments and should return a true value for any table to reflect.

 #param extend_existing: Passed along to each :class:`_schema.Table` as
 #paramref:`_schema.Table.extend_existing`.

 #. versionadded:: 0.9.1

 #param autoload_replace: Passed along to each :class:`_schema.Table`
 #s
 #paramref:`_schema.Table.autoload_replace`.

 #. versionadded:: 0.9.1

 #param resolve_fks: if True, reflect :class:`_schema.Table`
 #bjects linked
 #o :class:`_schema.ForeignKey` objects located in each
 #class:`_schema.Table`.
 #or :meth:`_schema.MetaData.reflect`,
 #his has the effect of reflecting
 #elated tables that might otherwise not be in the list of tables
 #eing reflected, for example if the referenced table is in a
 #ifferent schema or is omitted via the
 #paramref:`.MetaData.reflect.only` parameter.  When False,
 #class:`_schema.ForeignKey` objects are not followed to the
 #class:`_schema.Table`
 #n which they link, however if the related table is also part of the
 #ist of tables that would be reflected in any case, the
 #class:`_schema.ForeignKey` object will still resolve to its related
 #class:`_schema.Table` after the :meth:`_schema.MetaData.reflect`
 #peration is
 #omplete.   Defaults to True.

 #. versionadded:: 1.3.0

 #. seealso::

 #paramref:`_schema.Table.resolve_fks`

 #param \**dialect_kwargs: Additional keyword arguments not mentioned
 #bove are dialect specific, and passed in the form
 #`<dialectname>_<argname>``.  See the documentation regarding an
 #ndividual dialect at :ref:`dialect_toplevel` for detail on
 #ocumented arguments.

 #. versionadded:: 0.9.2 - Added
 #paramref:`.MetaData.reflect.**dialect_kwargs` to support
 #ialect-level reflection options for all :class:`_schema.Table`
 #bjects reflected.

 #""
 #f bind is None:
 #ind = _bind_or_error(self)

 #ith inspection.inspect(bind)._inspection_context() as insp:
 #eflect_opts = {
 #autoload_with": insp,
 #extend_existing": extend_existing,
 #autoload_replace": autoload_replace,
 #resolve_fks": resolve_fks,
 #_extend_on": set(),
 #

 #eflect_opts.update(dialect_kwargs)

 #f schema is None:
 #chema = self.schema

 #f schema is not None:
 #eflect_opts["schema"] = schema

 #vailable = util.OrderedSet(insp.get_table_names(schema))
 #f views:
 #vailable.update(insp.get_view_names(schema))

 #f schema is not None:
 #vailable_w_schema = util.OrderedSet(
 #"%s.%s" % (schema, name) for name in available]
 #
 #lse:
 #vailable_w_schema = available

 #urrent = set(self.tables)

 #f only is None:
 #oad = [
 #ame
 #or name, schname in zip(available, available_w_schema)
 #f extend_existing or schname not in current
 #
 #lif callable(only):
 #oad = [
 #ame
 #or name, schname in zip(available, available_w_schema)
 #f (extend_existing or schname not in current)
 #nd only(name, self)
 #
 #lse:
 #issing = [name for name in only if name not in available]
 #f missing:
 # = schema and (" schema '%s'" % schema) or ""
 #aise exc.InvalidRequestError(
 #Could not reflect: requested table(s) not available "
 #in %r%s: (%s)" % (bind.engine, s, ", ".join(missing))
 #
 #oad = [
 #ame
 #or name in only
 #f extend_existing or name not in current
 #

 #or name in load:
 #ry:
 #able(name, self, **reflect_opts)
 #xcept exc.UnreflectableTableError as uerr:
 #til.warn("Skipping table %s: %s" % (name, uerr))

 #ef create_all(self, bind=None, tables=None, checkfirst=True):
 #""Create all tables stored in this metadata.

 #onditional by default, will not attempt to recreate tables already
 #resent in the target database.

 #param bind:
 # :class:`.Connectable` used to access the
 #atabase; if None, uses the existing bind on this ``MetaData``, if
 #ny.

 #. note:: the "bind" argument will be required in
 #QLAlchemy 2.0.

 #param tables:
 #ptional list of ``Table`` objects, which is a subset of the total
 #ables in the ``MetaData`` (others are ignored).

 #param checkfirst:
 #efaults to True, don't issue CREATEs for tables already present
 #n the target database.

 #""
 #f bind is None:
 #ind = _bind_or_error(self)
 #ind._run_ddl_visitor(
 #dl.SchemaGenerator, self, checkfirst=checkfirst, tables=tables
 #

 #ef drop_all(self, bind=None, tables=None, checkfirst=True):
 #""Drop all tables stored in this metadata.

 #onditional by default, will not attempt to drop tables not present in
 #he target database.

 #param bind:
 # :class:`.Connectable` used to access the
 #atabase; if None, uses the existing bind on this ``MetaData``, if
 #ny.

 #. note:: the "bind" argument will be required in
 #QLAlchemy 2.0.

 #param tables:
 #ptional list of ``Table`` objects, which is a subset of the
 #otal tables in the ``MetaData`` (others are ignored).

 #param checkfirst:
 #efaults to True, only issue DROPs for tables confirmed to be
 #resent in the target database.

 #""
 #f bind is None:
 #ind = _bind_or_error(self)
 #ind._run_ddl_visitor(
 #dl.SchemaDropper, self, checkfirst=checkfirst, tables=tables
 #


@util.deprecated_cls(
 #1.4",
 #:class:`.ThreadLocalMetaData` is deprecated and will be removed "
 #in a future release.",
 #onstructor="__init__",
)
class ThreadLocalMetaData(MetaData):
 #""A MetaData variant that presents a different ``bind`` in every thread.

 #akes the ``bind`` property of the MetaData a thread-local value, allowing
 #his collection of tables to be bound to different ``Engine``
 #mplementations or connections in each thread.

 #he ThreadLocalMetaData starts off bound to None in each thread.  Binds
 #ust be made explicitly by assigning to the ``bind`` property or using
 #`connect()``.  You can also re-bind dynamically multiple times per
 #hread, just like a regular ``MetaData``.

 #""

 #_visit_name__ = "metadata"

 #ef __init__(self):
 #""Construct a ThreadLocalMetaData."""

 #elf.context = util.threading.local()
 #elf.__engines = {}
 #uper(ThreadLocalMetaData, self).__init__()

 #ef bind(self):
 #""The bound Engine or Connection for this thread.

 #his property may be assigned an Engine or Connection, or assigned a
 #tring or URL to automatically create a basic Engine for this bind
 #ith ``create_engine()``."""

 #eturn getattr(self.context, "_engine", None)

 #util.preload_module("sqlalchemy.engine.url")
 #ef _bind_to(self, bind):
 #""Bind to a Connectable in the caller's thread."""
 #rl = util.preloaded.engine_url
 #f isinstance(bind, util.string_types + (url.URL,)):
 #ry:
 #elf.context._engine = self.__engines[bind]
 #xcept KeyError:
 # = sqlalchemy.create_engine(bind)
 #elf.__engines[bind] = e
 #elf.context._engine = e
 #lse:
            # TODO: this is squirrely.  we shouldn't have to hold onto engines
            # in a case like this
 #f bind not in self.__engines:
 #elf.__engines[bind] = bind
 #elf.context._engine = bind

 #ind = property(bind, _bind_to)

 #ef is_bound(self):
 #""True if there is a bind for this thread."""
 #eturn (
 #asattr(self.context, "_engine")
 #nd self.context._engine is not None
 #

 #ef dispose(self):
 #""Dispose all bound engines, in all thread contexts."""

 #or e in self.__engines.values():
 #f hasattr(e, "dispose"):
 #.dispose()


class Computed(FetchedValue, SchemaItem):
 #""Defines a generated column, i.e. "GENERATED ALWAYS AS" syntax.

 #he :class:`.Computed` construct is an inline construct added to the
 #rgument list of a :class:`_schema.Column` object::

 #rom sqlalchemy import Computed

 #able('square', meta,
 #olumn('side', Float, nullable=False),
 #olumn('area', Float, Computed('side * side'))
 #

 #ee the linked documentation below for complete details.

 #. versionadded:: 1.3.11

 #. seealso::

 #ref:`computed_ddl`

 #""

 #_visit_name__ = "computed_column"

 #_document_text_coercion(
 #sqltext", ":class:`.Computed`", ":paramref:`.Computed.sqltext`"
 #
 #ef __init__(self, sqltext, persisted=None):
 #""Construct a GENERATED ALWAYS AS DDL construct to accompany a
 #class:`_schema.Column`.

 #param sqltext:
 # string containing the column generation expression, which will be
 #sed verbatim, or a SQL expression construct, such as a
 #func:`_expression.text`
 #bject.   If given as a string, the object is converted to a
 #func:`_expression.text` object.

 #param persisted:
 #ptional, controls how this column should be persisted by the
 #atabase.   Possible values are:

 # ``None``, the default, it will use the default persistence
 #efined by the database.
 # ``True``, will render ``GENERATED ALWAYS AS ... STORED``, or the
 #quivalent for the target database if supported.
 # ``False``, will render ``GENERATED ALWAYS AS ... VIRTUAL``, or
 #he equivalent for the target database if supported.

 #pecifying ``True`` or ``False`` may raise an error when the DDL
 #s emitted to the target database if the database does not support
 #hat persistence option.   Leaving this parameter at its default
 #f ``None`` is guaranteed to succeed for all databases that support
 #`GENERATED ALWAYS AS``.

 #""
 #elf.sqltext = coercions.expect(roles.DDLExpressionRole, sqltext)
 #elf.persisted = persisted
 #elf.column = None

 #ef _set_parent(self, parent, **kw):
 #f not isinstance(
 #arent.server_default, (type(None), Computed)
 # or not isinstance(parent.server_onupdate, (type(None), Computed)):
 #aise exc.ArgumentError(
 #A generated column cannot specify a server_default or a "
 #server_onupdate argument"
 #
 #elf.column = parent
 #arent.computed = self
 #elf.column.server_onupdate = self
 #elf.column.server_default = self

 #ef _as_for_update(self, for_update):
 #eturn self

 #util.deprecated(
 #1.4",
 #The :meth:`_schema.Computed.copy` method is deprecated "
 #and will be removed in a future release.",
 #
 #ef copy(self, target_table=None, **kw):
 #eturn self._copy(target_table, **kw)

 #ef _copy(self, target_table=None, **kw):
 #qltext = _copy_expression(
 #elf.sqltext,
 #elf.column.table if self.column is not None else None,
 #arget_table,
 #
 # = Computed(sqltext, persisted=self.persisted)

 #eturn self._schema_item_copy(g)


class Identity(IdentityOptions, FetchedValue, SchemaItem):
 #""Defines an identity column, i.e. "GENERATED { ALWAYS | BY DEFAULT }
 #S IDENTITY" syntax.

 #he :class:`.Identity` construct is an inline construct added to the
 #rgument list of a :class:`_schema.Column` object::

 #rom sqlalchemy import Identity

 #able('foo', meta,
 #olumn('id', Integer, Identity())
 #olumn('description', Text),
 #

 #ee the linked documentation below for complete details.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`identity_ddl`

 #""

 #_visit_name__ = "identity_column"

 #ef __init__(
 #elf,
 #lways=False,
 #n_null=None,
 #tart=None,
 #ncrement=None,
 #invalue=None,
 #axvalue=None,
 #ominvalue=None,
 #omaxvalue=None,
 #ycle=None,
 #ache=None,
 #rder=None,
 #:
 #""Construct a GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY DDL
 #onstruct to accompany a :class:`_schema.Column`.

 #ee the :class:`.Sequence` documentation for a complete description
 #f most parameters.

 #. note::
 #SSQL supports this construct as the preferred alternative to
 #enerate an IDENTITY on a column, but it uses non standard
 #yntax that only support :paramref:`_schema.Identity.start`
 #nd :paramref:`_schema.Identity.increment`.
 #ll other parameters are ignored.

 #param always:
 # boolean, that indicates the type of identity column.
 #f ``False`` is specified, the default, then the user-specified
 #alue takes precedence.
 #f ``True`` is specified, a user-specified value is not accepted (
 #n some backends, like PostgreSQL, OVERRIDING SYSTEM VALUE, or
 #imilar, may be specified in an INSERT to override the sequence
 #alue).
 #ome backends also have a default value for this parameter,
 #`None`` can be used to omit rendering this part in the DDL. It
 #ill be treated as ``False`` if a backend does not have a default
 #alue.

 #param on_null:
 #et to ``True`` to specify ON NULL in conjunction with a
 #`always=False`` identity column. This option is only supported on
 #ome backends, like Oracle.

 #param start: the starting index of the sequence.
 #param increment: the increment value of the sequence.
 #param minvalue: the minimum value of the sequence.
 #param maxvalue: the maximum value of the sequence.
 #param nominvalue: no minimum value of the sequence.
 #param nomaxvalue: no maximum value of the sequence.
 #param cycle: allows the sequence to wrap around when the maxvalue
 #r minvalue has been reached.
 #param cache: optional integer value; number of future values in the
 #equence which are calculated in advance.
 #param order: optional boolean value; if true, renders the
 #RDER keyword.

 #""
 #dentityOptions.__init__(
 #elf,
 #tart=start,
 #ncrement=increment,
 #invalue=minvalue,
 #axvalue=maxvalue,
 #ominvalue=nominvalue,
 #omaxvalue=nomaxvalue,
 #ycle=cycle,
 #ache=cache,
 #rder=order,
 #
 #elf.always = always
 #elf.on_null = on_null
 #elf.column = None

 #ef _set_parent(self, parent, **kw):
 #f not isinstance(
 #arent.server_default, (type(None), Identity)
 # or not isinstance(parent.server_onupdate, type(None)):
 #aise exc.ArgumentError(
 #A column with an Identity object cannot specify a "
 #server_default or a server_onupdate argument"
 #
 #f parent.autoincrement is False:
 #aise exc.ArgumentError(
 #A column with an Identity object cannot specify "
 #autoincrement=False"
 #
 #elf.column = parent

 #arent.identity = self
 #f parent._user_defined_nullable is NULL_UNSPECIFIED:
 #arent.nullable = False

 #arent.server_default = self

 #ef _as_for_update(self, for_update):
 #eturn self

 #util.deprecated(
 #1.4",
 #The :meth:`_schema.Identity.copy` method is deprecated "
 #and will be removed in a future release.",
 #
 #ef copy(self, **kw):
 #eturn self._copy(**kw)

 #ef _copy(self, **kw):
 # = Identity(
 #lways=self.always,
 #n_null=self.on_null,
 #tart=self.start,
 #ncrement=self.increment,
 #invalue=self.minvalue,
 #axvalue=self.maxvalue,
 #ominvalue=self.nominvalue,
 #omaxvalue=self.nomaxvalue,
 #ycle=self.cycle,
 #ache=self.cache,
 #rder=self.order,
 #

 #eturn self._schema_item_copy(i)
