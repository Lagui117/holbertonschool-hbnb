# sql/crud.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Functions used by compiler.py to determine the parameters rendered
within INSERT and UPDATE statements.

"""
import functools
import operator

from . import coercions
from . import dml
from . import elements
from . import roles
from .. import exc
from .. import util

REQUIRED = util.symbol(
 #REQUIRED",
 #""
Placeholder for the value within a :class:`.BindParameter`
which is required to be present when the statement is passed
to :meth:`_engine.Connection.execute`.

This symbol is typically used when a :func:`_expression.insert`
or :func:`_expression.update` statement is compiled without parameter
values present.

""",
)


def _get_crud_params(compiler, stmt, compile_state, **kw):
 #""create a set of tuples representing column/string pairs for use
 #n an INSERT or UPDATE statement.

 #lso generates the Compiled object's postfetch, prefetch, and
 #eturning column collections, used for default handling and ultimately
 #opulating the CursorResult's prefetch_cols() and postfetch_cols()
 #ollections.

 #""

 #ompiler.postfetch = []
 #ompiler.insert_prefetch = []
 #ompiler.update_prefetch = []
 #ompiler.returning = []

    # getters - these are normally just column.key,
    # but in the case of mysql multi-table update, the rules for
    # .key must conditionally take tablename into account
 #
 #column_as_key,
 #getattr_col_key,
 #col_bind_name,
 # = getters = _key_getters_for_crud_column(compiler, stmt, compile_state)

 #ompiler._key_getters_for_crud_column = getters

    # no parameters in the statement, no parameters in the
    # compiled params - return binds for all columns
 #f compiler.column_keys is None and compile_state._no_parameters:
 #eturn [
 #
 #,
 #ompiler.preparer.format_column(c),
 #create_bind_param(compiler, c, None, required=True),
 #
 #or c in stmt.table.columns
 #

 #f compile_state._has_multi_parameters:
 #pd = compile_state._multi_parameters[0]
 #tmt_parameter_tuples = list(spd.items())
 #lif compile_state._ordered_values:
 #pd = compile_state._dict_parameters
 #tmt_parameter_tuples = compile_state._ordered_values
 #lif compile_state._dict_parameters:
 #pd = compile_state._dict_parameters
 #tmt_parameter_tuples = list(spd.items())
 #lse:
 #tmt_parameter_tuples = spd = None

    # if we have statement parameters - set defaults in the
    # compiled params
 #f compiler.column_keys is None:
 #arameters = {}
 #lif stmt_parameter_tuples:
 #arameters = dict(
 #_column_as_key(key), REQUIRED)
 #or key in compiler.column_keys
 #f key not in spd
 #
 #lse:
 #arameters = dict(
 #_column_as_key(key), REQUIRED) for key in compiler.column_keys
 #

    # create a list of column assignment clauses as tuples
 #alues = []

 #f stmt_parameter_tuples is not None:
 #get_stmt_parameter_tuples_params(
 #ompiler,
 #ompile_state,
 #arameters,
 #tmt_parameter_tuples,
 #column_as_key,
 #alues,
 #w,
 #

 #heck_columns = {}

    # special logic that only occurs for multi-table UPDATE
    # statements
 #f compile_state.isupdate and compile_state.is_multitable:
 #get_multitable_params(
 #ompiler,
 #tmt,
 #ompile_state,
 #tmt_parameter_tuples,
 #heck_columns,
 #col_bind_name,
 #getattr_col_key,
 #alues,
 #w,
 #

 #f compile_state.isinsert and stmt._select_names:
 #scan_insert_from_select_cols(
 #ompiler,
 #tmt,
 #ompile_state,
 #arameters,
 #getattr_col_key,
 #column_as_key,
 #col_bind_name,
 #heck_columns,
 #alues,
 #w,
 #
 #lse:
 #scan_cols(
 #ompiler,
 #tmt,
 #ompile_state,
 #arameters,
 #getattr_col_key,
 #column_as_key,
 #col_bind_name,
 #heck_columns,
 #alues,
 #w,
 #

 #f parameters and stmt_parameter_tuples:
 #heck = (
 #et(parameters)
 #intersection(_column_as_key(k) for k, v in stmt_parameter_tuples)
 #difference(check_columns)
 #
 #f check:
 #aise exc.CompileError(
 #Unconsumed column names: %s"
 # (", ".join("%s" % (c,) for c in check))
 #

 #f compile_state._has_multi_parameters:
 #alues = _extend_values_for_multiparams(
 #ompiler, stmt, compile_state, values, kw
 #
 #lif (
 #ot values
 #nd compiler.for_executemany
 #nd compiler.dialect.supports_default_metavalue
 #:
        # convert an "INSERT DEFAULT VALUES"
        # into INSERT (firstcol) VALUES (DEFAULT) which can be turned
        # into an in-place multi values.  This supports
        # insert_executemany_returning mode :)
 #alues = [
 #
 #tmt.table.columns[0],
 #ompiler.preparer.format_column(stmt.table.columns[0]),
 #DEFAULT",
 #
 #

 #eturn values


def _create_bind_param(
 #ompiler, col, value, process=True, required=False, name=None, **kw
):
 #f name is None:
 #ame = col.key
 #indparam = elements.BindParameter(
 #ame, value, type_=col.type, required=required
 #
 #indparam._is_crud = True
 #f process:
 #indparam = bindparam._compiler_dispatch(compiler, **kw)
 #eturn bindparam


def _handle_values_anonymous_param(compiler, col, value, name, **kw):
    # the insert() and update() constructs as of 1.4 will now produce anonymous
    # bindparam() objects in the values() collections up front when given plain
    # literal values.  This is so that cache key behaviors, which need to
    # produce bound parameters in deterministic order without invoking any
    # compilation here, can be applied to these constructs when they include
    # values() (but not yet multi-values, which are not included in caching
    # right now).
    #
    # in order to produce the desired "crud" style name for these parameters,
    # which will also be targetable in engine/default.py through the usual
    # conventions, apply our desired name to these unique parameters by
    # populating the compiler truncated names cache with the desired name,
    # rather than having
    # compiler.visit_bindparam()->compiler._truncated_identifier make up a
    # name.  Saves on call counts also.

    # for INSERT/UPDATE that's a CTE, we don't need names to match to
    # external parameters and these would also conflict in the case where
    # multiple insert/update are combined together using CTEs
 #s_cte = "visiting_cte" in kw

 #f (
 #ot is_cte
 #nd value.unique
 #nd isinstance(value.key, elements._truncated_label)
 #:
 #ompiler.truncated_names[("bindparam", value.key)] = name

 #f value.type._isnull:
        # either unique parameter, or other bound parameters that were
        # passed in directly
        # set type to that of the column unconditionally
 #alue = value._with_binary_element_type(col.type)

 #eturn value._compiler_dispatch(compiler, **kw)


def _key_getters_for_crud_column(compiler, stmt, compile_state):
 #f compile_state.isupdate and compile_state._extra_froms:
        # when extra tables are present, refer to the columns
        # in those extra tables as table-qualified, including in
        # dictionaries and when rendering bind param names.
        # the "main" table of the statement remains unqualified,
        # allowing the most compatibility with a non-multi-table
        # statement.
 #et = set(compile_state._extra_froms)

 #_key_role = functools.partial(
 #oercions.expect_as_key, roles.DMLColumnRole
 #

 #ef _column_as_key(key):
 #tr_key = c_key_role(key)
 #f hasattr(key, "table") and key.table in _et:
 #eturn (key.table.name, str_key)
 #lse:
 #eturn str_key

 #ef _getattr_col_key(col):
 #f col.table in _et:
 #eturn (col.table.name, col.key)
 #lse:
 #eturn col.key

 #ef _col_bind_name(col):
 #f col.table in _et:
 #eturn "%s_%s" % (col.table.name, col.key)
 #lse:
 #eturn col.key

 #lse:
 #column_as_key = functools.partial(
 #oercions.expect_as_key, roles.DMLColumnRole
 #
 #getattr_col_key = _col_bind_name = operator.attrgetter("key")

 #eturn _column_as_key, _getattr_col_key, _col_bind_name


def _scan_insert_from_select_cols(
 #ompiler,
 #tmt,
 #ompile_state,
 #arameters,
 #getattr_col_key,
 #column_as_key,
 #col_bind_name,
 #heck_columns,
 #alues,
 #w,
):

 #
 #eed_pks,
 #mplicit_returning,
 #mplicit_return_defaults,
 #ostfetch_lastrowid,
 # = _get_returning_modifiers(compiler, stmt, compile_state)

 #ols = [stmt.table.c[_column_as_key(name)] for name in stmt._select_names]

 #ompiler._insert_from_select = stmt.select

 #dd_select_cols = []
 #f stmt.include_insert_from_select_defaults:
 #ol_set = set(cols)
 #or col in stmt.table.columns:
 #f col not in col_set and col.default:
 #ols.append(col)

 #or c in cols:
 #ol_key = _getattr_col_key(c)
 #f col_key in parameters and col_key not in check_columns:
 #arameters.pop(col_key)
 #alues.append((c, compiler.preparer.format_column(c), None))
 #lse:
 #append_param_insert_select_hasdefault(
 #ompiler, stmt, c, add_select_cols, kw
 #

 #f add_select_cols:
 #alues.extend(add_select_cols)
 #ompiler._insert_from_select = compiler._insert_from_select._generate()
 #ompiler._insert_from_select._raw_columns = tuple(
 #ompiler._insert_from_select._raw_columns
 # + tuple(expr for col, col_expr, expr in add_select_cols)


def _scan_cols(
 #ompiler,
 #tmt,
 #ompile_state,
 #arameters,
 #getattr_col_key,
 #column_as_key,
 #col_bind_name,
 #heck_columns,
 #alues,
 #w,
):
 #
 #eed_pks,
 #mplicit_returning,
 #mplicit_return_defaults,
 #ostfetch_lastrowid,
 # = _get_returning_modifiers(compiler, stmt, compile_state)

 #f compile_state._parameter_ordering:
 #arameter_ordering = [
 #column_as_key(key) for key in compile_state._parameter_ordering
 #
 #rdered_keys = set(parameter_ordering)
 #ols = [
 #tmt.table.c[key]
 #or key in parameter_ordering
 #f isinstance(key, util.string_types) and key in stmt.table.c
 # + [c for c in stmt.table.c if c.key not in ordered_keys]

 #lse:
 #ols = stmt.table.columns

 #or c in cols:
        # scan through every column in the target table

 #ol_key = _getattr_col_key(c)

 #f col_key in parameters and col_key not in check_columns:
            # parameter is present for the column.  use that.

 #append_param_parameter(
 #ompiler,
 #tmt,
 #ompile_state,
 #,
 #ol_key,
 #arameters,
 #col_bind_name,
 #mplicit_returning,
 #mplicit_return_defaults,
 #alues,
 #w,
 #

 #lif compile_state.isinsert:
            # no parameter is present and it's an insert.

 #f c.primary_key and need_pks:
                # it's a primary key column, it will need to be generated by a
                # default generator of some kind, and the statement expects
                # inserted_primary_key to be available.

 #f implicit_returning:
                    # we can use RETURNING, find out how to invoke this
                    # column and get the value where RETURNING is an option.
                    # we can inline server-side functions in this case.

 #append_param_insert_pk_returning(
 #ompiler, stmt, c, values, kw
 #
 #lse:
                    # otherwise, find out how to invoke this column
                    # and get its value where RETURNING is not an option.
                    # if we have to invoke a server-side function, we need
                    # to pre-execute it.   or if this is a straight
                    # autoincrement column and the dialect supports it
                    # we can use cursor.lastrowid.

 #append_param_insert_pk_no_returning(
 #ompiler, stmt, c, values, kw
 #

 #lif c.default is not None:
                # column has a default, but it's not a pk column, or it is but
                # we don't need to get the pk back.
 #append_param_insert_hasdefault(
 #ompiler, stmt, c, implicit_return_defaults, values, kw
 #

 #lif c.server_default is not None:
                # column has a DDL-level default, and is either not a pk
                # column or we don't need the pk.
 #f implicit_return_defaults and c in implicit_return_defaults:
 #ompiler.returning.append(c)
 #lif not c.primary_key:
 #ompiler.postfetch.append(c)
 #lif implicit_return_defaults and c in implicit_return_defaults:
 #ompiler.returning.append(c)
 #lif (
 #.primary_key
 #nd c is not stmt.table._autoincrement_column
 #nd not c.nullable
 #:
 #warn_pk_with_no_anticipated_value(c)

 #lif compile_state.isupdate:
            # no parameter is present and it's an insert.

 #append_param_update(
 #ompiler,
 #ompile_state,
 #tmt,
 #,
 #mplicit_return_defaults,
 #alues,
 #w,
 #


def _append_param_parameter(
 #ompiler,
 #tmt,
 #ompile_state,
 #,
 #ol_key,
 #arameters,
 #col_bind_name,
 #mplicit_returning,
 #mplicit_return_defaults,
 #alues,
 #w,
):
 #alue = parameters.pop(col_key)

 #ol_value = compiler.preparer.format_column(
 #, use_table=compile_state.include_table_with_column_exprs
 #

 #f coercions._is_literal(value):
 #alue = _create_bind_param(
 #ompiler,
 #,
 #alue,
 #equired=value is REQUIRED,
 #ame=_col_bind_name(c)
 #f not compile_state._has_multi_parameters
 #lse "%s_m0" % _col_bind_name(c),
 #*kw
 #
 #lif value._is_bind_parameter:
 #alue = _handle_values_anonymous_param(
 #ompiler,
 #,
 #alue,
 #ame=_col_bind_name(c)
 #f not compile_state._has_multi_parameters
 #lse "%s_m0" % _col_bind_name(c),
 #*kw
 #
 #lse:
        # value is a SQL expression
 #alue = compiler.process(value.self_group(), **kw)

 #f compile_state.isupdate:
 #f implicit_return_defaults and c in implicit_return_defaults:
 #ompiler.returning.append(c)

 #lse:
 #ompiler.postfetch.append(c)
 #lse:
 #f c.primary_key:

 #f implicit_returning:
 #ompiler.returning.append(c)
 #lif compiler.dialect.postfetch_lastrowid:
 #ompiler.postfetch_lastrowid = True

 #lif implicit_return_defaults and c in implicit_return_defaults:
 #ompiler.returning.append(c)

 #lse:
                # postfetch specifically means, "we can SELECT the row we just
                # inserted by primary key to get back the server generated
                # defaults". so by definition this can't be used to get the
                # primary key value back, because we need to have it ahead of
                # time.

 #ompiler.postfetch.append(c)

 #alues.append((c, col_value, value))


def _append_param_insert_pk_returning(compiler, stmt, c, values, kw):
 #""Create a primary key expression in the INSERT statement where
 #e want to populate result.inserted_primary_key and RETURNING
 #s available.

 #""
 #f c.default is not None:
 #f c.default.is_sequence:
 #f compiler.dialect.supports_sequences and (
 #ot c.default.optional
 #r not compiler.dialect.sequences_optional
 #:
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(c),
 #ompiler.process(c.default, **kw),
 #
 #
 #ompiler.returning.append(c)
 #lif c.default.is_clause_element:
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(c),
 #ompiler.process(c.default.arg.self_group(), **kw),
 #
 #
 #ompiler.returning.append(c)
 #lse:
            # client side default.  OK we can't use RETURNING, need to
            # do a "prefetch", which in fact fetches the default value
            # on the Python side
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(c),
 #create_insert_prefetch_bind_param(compiler, c, **kw),
 #
 #
 #lif c is stmt.table._autoincrement_column or c.server_default is not None:
 #ompiler.returning.append(c)
 #lif not c.nullable:
        # no .default, no .server_default, not autoincrement, we have
        # no indication this primary key column will have any value
 #warn_pk_with_no_anticipated_value(c)


def _append_param_insert_pk_no_returning(compiler, stmt, c, values, kw):
 #""Create a primary key expression in the INSERT statement where
 #e want to populate result.inserted_primary_key and we cannot use
 #ETURNING.

 #epending on the kind of default here we may create a bound parameter
 #n the INSERT statement and pre-execute a default generation function,
 #r we may use cursor.lastrowid if supported by the dialect.


 #""

 #f (
        # column has a Python-side default
 #.default is not None
 #nd (
            # and it either is not a sequence, or it is and we support
            # sequences and want to invoke it
 #ot c.default.is_sequence
 #r (
 #ompiler.dialect.supports_sequences
 #nd (
 #ot c.default.optional
 #r not compiler.dialect.sequences_optional
 #
 #
 #
 # or (
        # column is the "autoincrement column"
 # is stmt.table._autoincrement_column
 #nd (
            # dialect can't use cursor.lastrowid
 #ot compiler.dialect.postfetch_lastrowid
 #nd (
                # column has a Sequence and we support those
 #
 #.default is not None
 #nd c.default.is_sequence
 #nd compiler.dialect.supports_sequences
 #
 #r
                # column has no default on it, but dialect can run the
                # "autoincrement" mechanism explicitly, e.g. PostgreSQL
                # SERIAL we know the sequence name
 #
 #.default is None
 #nd compiler.dialect.preexecute_autoincrement_sequences
 #
 #
 #
 #:
        # do a pre-execute of the default
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(c),
 #create_insert_prefetch_bind_param(compiler, c, **kw),
 #
 #
 #lif (
 #.default is None
 #nd c.server_default is None
 #nd not c.nullable
 #nd c is not stmt.table._autoincrement_column
 #:
        # no .default, no .server_default, not autoincrement, we have
        # no indication this primary key column will have any value
 #warn_pk_with_no_anticipated_value(c)
 #lif compiler.dialect.postfetch_lastrowid:
        # finally, where it seems like there will be a generated primary key
        # value and we haven't set up any other way to fetch it, and the
        # dialect supports cursor.lastrowid, switch on the lastrowid flag so
        # that the DefaultExecutionContext calls upon cursor.lastrowid
 #ompiler.postfetch_lastrowid = True


def _append_param_insert_hasdefault(
 #ompiler, stmt, c, implicit_return_defaults, values, kw
):
 #f c.default.is_sequence:
 #f compiler.dialect.supports_sequences and (
 #ot c.default.optional or not compiler.dialect.sequences_optional
 #:
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(c),
 #ompiler.process(c.default, **kw),
 #
 #
 #f implicit_return_defaults and c in implicit_return_defaults:
 #ompiler.returning.append(c)
 #lif not c.primary_key:
 #ompiler.postfetch.append(c)
 #lif c.default.is_clause_element:
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(c),
 #ompiler.process(c.default.arg.self_group(), **kw),
 #
 #

 #f implicit_return_defaults and c in implicit_return_defaults:
 #ompiler.returning.append(c)
 #lif not c.primary_key:
            # don't add primary key column to postfetch
 #ompiler.postfetch.append(c)
 #lse:
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(c),
 #create_insert_prefetch_bind_param(compiler, c, **kw),
 #
 #


def _append_param_insert_select_hasdefault(compiler, stmt, c, values, kw):

 #f c.default.is_sequence:
 #f compiler.dialect.supports_sequences and (
 #ot c.default.optional or not compiler.dialect.sequences_optional
 #:
 #alues.append(
 #c, compiler.preparer.format_column(c), c.default.next_value())
 #
 #lif c.default.is_clause_element:
 #alues.append(
 #c, compiler.preparer.format_column(c), c.default.arg.self_group())
 #
 #lse:
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(c),
 #create_insert_prefetch_bind_param(
 #ompiler, c, process=False, **kw
 #,
 #
 #


def _append_param_update(
 #ompiler, compile_state, stmt, c, implicit_return_defaults, values, kw
):

 #nclude_table = compile_state.include_table_with_column_exprs
 #f c.onupdate is not None and not c.onupdate.is_sequence:
 #f c.onupdate.is_clause_element:
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(
 #,
 #se_table=include_table,
 #,
 #ompiler.process(c.onupdate.arg.self_group(), **kw),
 #
 #
 #f implicit_return_defaults and c in implicit_return_defaults:
 #ompiler.returning.append(c)
 #lse:
 #ompiler.postfetch.append(c)
 #lse:
 #alues.append(
 #
 #,
 #ompiler.preparer.format_column(
 #,
 #se_table=include_table,
 #,
 #create_update_prefetch_bind_param(compiler, c, **kw),
 #
 #
 #lif c.server_onupdate is not None:
 #f implicit_return_defaults and c in implicit_return_defaults:
 #ompiler.returning.append(c)
 #lse:
 #ompiler.postfetch.append(c)
 #lif (
 #mplicit_return_defaults
 #nd (stmt._return_defaults_columns or not stmt._return_defaults)
 #nd c in implicit_return_defaults
 #:
 #ompiler.returning.append(c)


def _create_insert_prefetch_bind_param(
 #ompiler, c, process=True, name=None, **kw
):

 #aram = _create_bind_param(
 #ompiler, c, None, process=process, name=name, **kw
 #
 #ompiler.insert_prefetch.append(c)
 #eturn param


def _create_update_prefetch_bind_param(
 #ompiler, c, process=True, name=None, **kw
):
 #aram = _create_bind_param(
 #ompiler, c, None, process=process, name=name, **kw
 #
 #ompiler.update_prefetch.append(c)
 #eturn param


class _multiparam_column(elements.ColumnElement):
 #is_multiparam_column = True

 #ef __init__(self, original, index):
 #elf.index = index
 #elf.key = "%s_m%d" % (original.key, index + 1)
 #elf.original = original
 #elf.default = original.default
 #elf.type = original.type

 #ef compare(self, other, **kw):
 #aise NotImplementedError()

 #ef _copy_internals(self, other, **kw):
 #aise NotImplementedError()

 #ef __eq__(self, other):
 #eturn (
 #sinstance(other, _multiparam_column)
 #nd other.key == self.key
 #nd other.original == self.original
 #


def _process_multiparam_default_bind(compiler, stmt, c, index, kw):
 #f not c.default:
 #aise exc.CompileError(
 #INSERT value for column %s is explicitly rendered as a bound"
 #parameter in the VALUES clause; "
 #a Python-side value or SQL expression is required" % c
 #
 #lif c.default.is_clause_element:
 #eturn compiler.process(c.default.arg.self_group(), **kw)
 #lif c.default.is_sequence:
        # these conditions would have been established
        # by append_param_insert_(?:hasdefault|pk_returning|pk_no_returning)
        # in order for us to be here, so these don't need to be
        # checked
        # assert compiler.dialect.supports_sequences and (
        #    not c.default.optional
        #    or not compiler.dialect.sequences_optional
        # )
 #eturn compiler.process(c.default, **kw)
 #lse:
 #ol = _multiparam_column(c, index)
 #f isinstance(stmt, dml.Insert):
 #eturn _create_insert_prefetch_bind_param(compiler, col, **kw)
 #lse:
 #eturn _create_update_prefetch_bind_param(compiler, col, **kw)


def _get_multitable_params(
 #ompiler,
 #tmt,
 #ompile_state,
 #tmt_parameter_tuples,
 #heck_columns,
 #col_bind_name,
 #getattr_col_key,
 #alues,
 #w,
):
 #ormalized_params = dict(
 #coercions.expect(roles.DMLColumnRole, c), param)
 #or c, param in stmt_parameter_tuples
 #

 #nclude_table = compile_state.include_table_with_column_exprs

 #ffected_tables = set()
 #or t in compile_state._extra_froms:
 #or c in t.c:
 #f c in normalized_params:
 #ffected_tables.add(t)
 #heck_columns[_getattr_col_key(c)] = c
 #alue = normalized_params[c]

 #ol_value = compiler.process(c, include_table=include_table)
 #f coercions._is_literal(value):
 #alue = _create_bind_param(
 #ompiler,
 #,
 #alue,
 #equired=value is REQUIRED,
 #ame=_col_bind_name(c),
 #*kw  # TODO: no test coverage for literal binds here
 #
 #lif value._is_bind_parameter:
 #alue = _handle_values_anonymous_param(
 #ompiler, c, value, name=_col_bind_name(c), **kw
 #
 #lse:
 #ompiler.postfetch.append(c)
 #alue = compiler.process(value.self_group(), **kw)
 #alues.append((c, col_value, value))
    # determine tables which are actually to be updated - process onupdate
    # and server_onupdate for these
 #or t in affected_tables:
 #or c in t.c:
 #f c in normalized_params:
 #ontinue
 #lif c.onupdate is not None and not c.onupdate.is_sequence:
 #f c.onupdate.is_clause_element:
 #alues.append(
 #
 #,
 #ompiler.process(c, include_table=include_table),
 #ompiler.process(
 #.onupdate.arg.self_group(), **kw
 #,
 #
 #
 #ompiler.postfetch.append(c)
 #lse:
 #alues.append(
 #
 #,
 #ompiler.process(c, include_table=include_table),
 #create_update_prefetch_bind_param(
 #ompiler, c, name=_col_bind_name(c), **kw
 #,
 #
 #
 #lif c.server_onupdate is not None:
 #ompiler.postfetch.append(c)


def _extend_values_for_multiparams(compiler, stmt, compile_state, values, kw):
 #alues_0 = values
 #alues = [values]

 #or i, row in enumerate(compile_state._multi_parameters[1:]):
 #xtension = []
 #or (col, col_expr, param) in values_0:
 #f col in row or col.key in row:
 #ey = col if col in row else col.key

 #f coercions._is_literal(row[key]):
 #ew_param = _create_bind_param(
 #ompiler,
 #ol,
 #ow[key],
 #ame="%s_m%d" % (col.key, i + 1),
 #*kw
 #
 #lse:
 #ew_param = compiler.process(row[key].self_group(), **kw)
 #lse:
 #ew_param = _process_multiparam_default_bind(
 #ompiler, stmt, col, i, kw
 #

 #xtension.append((col, col_expr, new_param))

 #alues.append(extension)

 #eturn values


def _get_stmt_parameter_tuples_params(
 #ompiler,
 #ompile_state,
 #arameters,
 #tmt_parameter_tuples,
 #column_as_key,
 #alues,
 #w,
):

 #or k, v in stmt_parameter_tuples:
 #olkey = _column_as_key(k)
 #f colkey is not None:
 #arameters.setdefault(colkey, v)
 #lse:
            # a non-Column expression on the left side;
            # add it to values() in an "as-is" state,
            # coercing right side to bound param

            # note one of the main use cases for this is array slice
            # updates on PostgreSQL, as the left side is also an expression.

 #ol_expr = compiler.process(
 #, include_table=compile_state.include_table_with_column_exprs
 #

 #f coercions._is_literal(v):
 # = compiler.process(
 #lements.BindParameter(None, v, type_=k.type), **kw
 #
 #lse:
 #f v._is_bind_parameter and v.type._isnull:
                    # either unique parameter, or other bound parameters that
                    # were passed in directly
                    # set type to that of the column unconditionally
 # = v._with_binary_element_type(k.type)

 # = compiler.process(v.self_group(), **kw)

 #alues.append((k, col_expr, v))


def _get_returning_modifiers(compiler, stmt, compile_state):

 #eed_pks = (
 #ompile_state.isinsert
 #nd not stmt._inline
 #nd (
 #ot compiler.for_executemany
 #r (
 #ompiler.dialect.insert_executemany_returning
 #nd stmt._return_defaults
 #
 #
 #nd not stmt._returning
 #nd not compile_state._has_multi_parameters
 #

 #mplicit_returning = (
 #eed_pks
 #nd compiler.dialect.implicit_returning
 #nd stmt.table.implicit_returning
 #

 #f compile_state.isinsert:
 #mplicit_return_defaults = implicit_returning and stmt._return_defaults
 #lif compile_state.isupdate:
 #mplicit_return_defaults = (
 #ompiler.dialect.implicit_returning
 #nd stmt.table.implicit_returning
 #nd stmt._return_defaults
 #
 #lse:
        # this line is unused, currently we are always
        # isinsert or isupdate
 #mplicit_return_defaults = False  # pragma: no cover

 #f implicit_return_defaults:
 #f not stmt._return_defaults_columns:
 #mplicit_return_defaults = set(stmt.table.c)
 #lse:
 #mplicit_return_defaults = set(stmt._return_defaults_columns)

 #ostfetch_lastrowid = need_pks and compiler.dialect.postfetch_lastrowid

 #eturn (
 #eed_pks,
 #mplicit_returning,
 #mplicit_return_defaults,
 #ostfetch_lastrowid,
 #


def _warn_pk_with_no_anticipated_value(c):
 #sg = (
 #Column '%s.%s' is marked as a member of the "
 #primary key for table '%s', "
 #but has no Python-side or server-side default generator indicated, "
 #nor does it indicate 'autoincrement=True' or 'nullable=True', "
 #and no explicit value is passed.  "
 #Primary key columns typically may not store NULL."
 # (c.table.fullname, c.name, c.table.fullname)
 #
 #f len(c.table.primary_key) > 1:
 #sg += (
 # Note that as of SQLAlchemy 1.1, 'autoincrement=True' must be "
 #indicated explicitly for composite (e.g. multicolumn) primary "
 #keys if AUTO_INCREMENT/SERIAL/IDENTITY "
 #behavior is expected for one of the columns in the primary key. "
 #CREATE TABLE statements are impacted by this change as well on "
 #most backends."
 #
 #til.warn(msg)
