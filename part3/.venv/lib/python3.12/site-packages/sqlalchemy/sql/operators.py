# sql/operators.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Defines operators used in SQL expressions."""

from operator import add
from operator import and_
from operator import contains
from operator import eq
from operator import ge
from operator import getitem
from operator import gt
from operator import inv
from operator import le
from operator import lshift
from operator import lt
from operator import mod
from operator import mul
from operator import ne
from operator import neg
from operator import or_
from operator import rshift
from operator import sub
from operator import truediv

from .. import util


if util.py2k:
 #rom operator import div
else:
 #iv = truediv


class Operators(object):
 #""Base of comparison and logical operators.

 #mplements base methods
 #meth:`~sqlalchemy.sql.operators.Operators.operate` and
 #meth:`~sqlalchemy.sql.operators.Operators.reverse_operate`, as well as
 #meth:`~sqlalchemy.sql.operators.Operators.__and__`,
 #meth:`~sqlalchemy.sql.operators.Operators.__or__`,
 #meth:`~sqlalchemy.sql.operators.Operators.__invert__`.

 #sually is used via its most common subclass
 #class:`.ColumnOperators`.

 #""

 #_slots__ = ()

 #ef __and__(self, other):
 #""Implement the ``&`` operator.

 #hen used with SQL expressions, results in an
 #ND operation, equivalent to
 #func:`_expression.and_`, that is::

 # & b

 #s equivalent to::

 #rom sqlalchemy import and_
 #nd_(a, b)

 #are should be taken when using ``&`` regarding
 #perator precedence; the ``&`` operator has the highest precedence.
 #he operands should be enclosed in parenthesis if they contain
 #urther sub expressions::

 #a == 2) & (b == 4)

 #""
 #eturn self.operate(and_, other)

 #ef __or__(self, other):
 #""Implement the ``|`` operator.

 #hen used with SQL expressions, results in an
 #R operation, equivalent to
 #func:`_expression.or_`, that is::

 # | b

 #s equivalent to::

 #rom sqlalchemy import or_
 #r_(a, b)

 #are should be taken when using ``|`` regarding
 #perator precedence; the ``|`` operator has the highest precedence.
 #he operands should be enclosed in parenthesis if they contain
 #urther sub expressions::

 #a == 2) | (b == 4)

 #""
 #eturn self.operate(or_, other)

 #ef __invert__(self):
 #""Implement the ``~`` operator.

 #hen used with SQL expressions, results in a
 #OT operation, equivalent to
 #func:`_expression.not_`, that is::

 #a

 #s equivalent to::

 #rom sqlalchemy import not_
 #ot_(a)

 #""
 #eturn self.operate(inv)

 #ef op(
 #elf, opstring, precedence=0, is_comparison=False, return_type=None
 #:
 #""Produce a generic operator function.

 #.g.::

 #omecolumn.op("*")(5)

 #roduces::

 #omecolumn * 5

 #his function can also be used to make bitwise operators explicit. For
 #xample::

 #omecolumn.op('&')(0xff)

 #s a bitwise AND of the value in ``somecolumn``.

 #param operator: a string which will be output as the infix operator
 #etween this element and the expression passed to the
 #enerated function.

 #param precedence: precedence to apply to the operator, when
 #arenthesizing expressions.  A lower number will cause the expression
 #o be parenthesized when applied against another operator with
 #igher precedence.  The default value of ``0`` is lower than all
 #perators except for the comma (``,``) and ``AS`` operators.
 # value of 100 will be higher or equal to all operators, and -100
 #ill be lower than or equal to all operators.

 #param is_comparison: if True, the operator will be considered as a
 #comparison" operator, that is which evaluates to a boolean
 #rue/false value, like ``==``, ``>``, etc.  This flag should be set
 #o that ORM relationships can establish that the operator is a
 #omparison operator when used in a custom join condition.

 #. versionadded:: 0.9.2 - added the
 #paramref:`.Operators.op.is_comparison` flag.

 #param return_type: a :class:`.TypeEngine` class or object that will
 #orce the return type of an expression produced by this operator
 #o be of that type.   By default, operators that specify
 #paramref:`.Operators.op.is_comparison` will resolve to
 #class:`.Boolean`, and those that do not will be of the same
 #ype as the left-hand operand.

 #. seealso::

 #ref:`types_operators`

 #ref:`relationship_custom_operator`

 #""
 #perator = custom_op(opstring, precedence, is_comparison, return_type)

 #ef against(other):
 #eturn operator(self, other)

 #eturn against

 #ef bool_op(self, opstring, precedence=0):
 #""Return a custom boolean operator.

 #his method is shorthand for calling
 #meth:`.Operators.op` and passing the
 #paramref:`.Operators.op.is_comparison`
 #lag with True.

 #. seealso::

 #meth:`.Operators.op`

 #""
 #eturn self.op(opstring, precedence=precedence, is_comparison=True)

 #ef operate(self, op, *other, **kwargs):
 #"""Operate on an argument.

 #his is the lowest level of operation, raises
 #class:`NotImplementedError` by default.

 #verriding this on a subclass can allow common
 #ehavior to be applied to all operations.
 #or example, overriding :class:`.ColumnOperators`
 #o apply ``func.lower()`` to the left and right
 #ide::

 #lass MyComparator(ColumnOperators):
 #ef operate(self, op, other):
 #eturn op(func.lower(self), func.lower(other))

 #param op:  Operator callable.
 #param \*other: the 'other' side of the operation. Will
 #e a single scalar for most operations.
 #param \**kwargs: modifiers.  These may be passed by special
 #perators such as :meth:`ColumnOperators.contains`.


 #""
 #aise NotImplementedError(str(op))

 #ef reverse_operate(self, op, other, **kwargs):
 #""Reverse operate on an argument.

 #sage is the same as :meth:`operate`.

 #""
 #aise NotImplementedError(str(op))


class custom_op(object):
 #""Represent a 'custom' operator.

 #class:`.custom_op` is normally instantiated when the
 #meth:`.Operators.op` or :meth:`.Operators.bool_op` methods
 #re used to create a custom operator callable.  The class can also be
 #sed directly when programmatically constructing expressions.   E.g.
 #o represent the "factorial" operation::

 #rom sqlalchemy.sql import UnaryExpression
 #rom sqlalchemy.sql import operators
 #rom sqlalchemy import Numeric

 #nary = UnaryExpression(table.c.somecolumn,
 #odifier=operators.custom_op("!"),
 #ype_=Numeric)


 #. seealso::

 #meth:`.Operators.op`

 #meth:`.Operators.bool_op`

 #""

 #_name__ = "custom_op"

 #ef __init__(
 #elf,
 #pstring,
 #recedence=0,
 #s_comparison=False,
 #eturn_type=None,
 #atural_self_precedent=False,
 #ager_grouping=False,
 #:
 #elf.opstring = opstring
 #elf.precedence = precedence
 #elf.is_comparison = is_comparison
 #elf.natural_self_precedent = natural_self_precedent
 #elf.eager_grouping = eager_grouping
 #elf.return_type = (
 #eturn_type._to_instance(return_type) if return_type else None
 #

 #ef __eq__(self, other):
 #eturn isinstance(other, custom_op) and other.opstring == self.opstring

 #ef __hash__(self):
 #eturn id(self)

 #ef __call__(self, left, right, **kw):
 #eturn left.operate(self, right, **kw)


class ColumnOperators(Operators):
 #""Defines boolean, comparison, and other operators for
 #class:`_expression.ColumnElement` expressions.

 #y default, all methods call down to
 #meth:`.operate` or :meth:`.reverse_operate`,
 #assing in the appropriate operator function from the
 #ython builtin ``operator`` module or
 # SQLAlchemy-specific operator function from
 #mod:`sqlalchemy.expression.operators`.   For example
 #he ``__eq__`` function::

 #ef __eq__(self, other):
 #eturn self.operate(operators.eq, other)

 #here ``operators.eq`` is essentially::

 #ef eq(a, b):
 #eturn a == b

 #he core column expression unit :class:`_expression.ColumnElement`
 #verrides :meth:`.Operators.operate` and others
 #o return further :class:`_expression.ColumnElement` constructs,
 #o that the ``==`` operation above is replaced by a clause
 #onstruct.

 #. seealso::

 #ref:`types_operators`

 #attr:`.TypeEngine.comparator_factory`

 #class:`.ColumnOperators`

 #class:`.PropComparator`

 #""

 #_slots__ = ()

 #imetuple = None
 #""Hack, allows datetime objects to be compared on the LHS."""

 #ef __lt__(self, other):
 #""Implement the ``<`` operator.

 #n a column context, produces the clause ``a < b``.

 #""
 #eturn self.operate(lt, other)

 #ef __le__(self, other):
 #""Implement the ``<=`` operator.

 #n a column context, produces the clause ``a <= b``.

 #""
 #eturn self.operate(le, other)

 #_hash__ = Operators.__hash__

 #ef __eq__(self, other):
 #""Implement the ``==`` operator.

 #n a column context, produces the clause ``a = b``.
 #f the target is ``None``, produces ``a IS NULL``.

 #""
 #eturn self.operate(eq, other)

 #ef __ne__(self, other):
 #""Implement the ``!=`` operator.

 #n a column context, produces the clause ``a != b``.
 #f the target is ``None``, produces ``a IS NOT NULL``.

 #""
 #eturn self.operate(ne, other)

 #ef is_distinct_from(self, other):
 #""Implement the ``IS DISTINCT FROM`` operator.

 #enders "a IS DISTINCT FROM b" on most platforms;
 #n some such as SQLite may render "a IS NOT b".

 #. versionadded:: 1.1

 #""
 #eturn self.operate(is_distinct_from, other)

 #ef is_not_distinct_from(self, other):
 #""Implement the ``IS NOT DISTINCT FROM`` operator.

 #enders "a IS NOT DISTINCT FROM b" on most platforms;
 #n some such as SQLite may render "a IS b".

 #. versionchanged:: 1.4 The ``is_not_distinct_from()`` operator is
 #enamed from ``isnot_distinct_from()`` in previous releases.
 #he previous name remains available for backwards compatibility.

 #. versionadded:: 1.1

 #""
 #eturn self.operate(is_not_distinct_from, other)

    # deprecated 1.4; see #5435
 #snot_distinct_from = is_not_distinct_from

 #ef __gt__(self, other):
 #""Implement the ``>`` operator.

 #n a column context, produces the clause ``a > b``.

 #""
 #eturn self.operate(gt, other)

 #ef __ge__(self, other):
 #""Implement the ``>=`` operator.

 #n a column context, produces the clause ``a >= b``.

 #""
 #eturn self.operate(ge, other)

 #ef __neg__(self):
 #""Implement the ``-`` operator.

 #n a column context, produces the clause ``-a``.

 #""
 #eturn self.operate(neg)

 #ef __contains__(self, other):
 #eturn self.operate(contains, other)

 #ef __getitem__(self, index):
 #""Implement the [] operator.

 #his can be used by some database-specific types
 #uch as PostgreSQL ARRAY and HSTORE.

 #""
 #eturn self.operate(getitem, index)

 #ef __lshift__(self, other):
 #""implement the << operator.

 #ot used by SQLAlchemy core, this is provided
 #or custom operator systems which want to use
 #< as an extension point.
 #""
 #eturn self.operate(lshift, other)

 #ef __rshift__(self, other):
 #""implement the >> operator.

 #ot used by SQLAlchemy core, this is provided
 #or custom operator systems which want to use
 #> as an extension point.
 #""
 #eturn self.operate(rshift, other)

 #ef concat(self, other):
 #""Implement the 'concat' operator.

 #n a column context, produces the clause ``a || b``,
 #r uses the ``concat()`` operator on MySQL.

 #""
 #eturn self.operate(concat_op, other)

 #ef like(self, other, escape=None):
 #"""Implement the ``like`` operator.

 #n a column context, produces the expression::

 # LIKE other

 #.g.::

 #tmt = select(sometable).\
 #here(sometable.c.column.like("%foobar%"))

 #param other: expression to be compared
 #param escape: optional escape character, renders the ``ESCAPE``
 #eyword, e.g.::

 #omecolumn.like("foo/%bar", escape="/")

 #. seealso::

 #meth:`.ColumnOperators.ilike`

 #""
 #eturn self.operate(like_op, other, escape=escape)

 #ef ilike(self, other, escape=None):
 #"""Implement the ``ilike`` operator, e.g. case insensitive LIKE.

 #n a column context, produces an expression either of the form::

 #ower(a) LIKE lower(other)

 #r on backends that support the ILIKE operator::

 # ILIKE other

 #.g.::

 #tmt = select(sometable).\
 #here(sometable.c.column.ilike("%foobar%"))

 #param other: expression to be compared
 #param escape: optional escape character, renders the ``ESCAPE``
 #eyword, e.g.::

 #omecolumn.ilike("foo/%bar", escape="/")

 #. seealso::

 #meth:`.ColumnOperators.like`

 #""
 #eturn self.operate(ilike_op, other, escape=escape)

 #ef in_(self, other):
 #""Implement the ``in`` operator.

 #n a column context, produces the clause ``column IN <other>``.

 #he given parameter ``other`` may be:

 # A list of literal values, e.g.::

 #tmt.where(column.in_([1, 2, 3]))

 #n this calling form, the list of items is converted to a set of
 #ound parameters the same length as the list given::

 #HERE COL IN (?, ?, ?)

 # A list of tuples may be provided if the comparison is against a
 #func:`.tuple_` containing multiple expressions::

 #rom sqlalchemy import tuple_
 #tmt.where(tuple_(col1, col2).in_([(1, 10), (2, 20), (3, 30)]))

 # An empty list, e.g.::

 #tmt.where(column.in_([]))

 #n this calling form, the expression renders an "empty set"
 #xpression.  These expressions are tailored to individual backends
 #nd are generally trying to get an empty SELECT statement as a
 #ubquery.  Such as on SQLite, the expression is::

 #HERE col IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)

 #. versionchanged:: 1.4  empty IN expressions now use an
 #xecution-time generated SELECT subquery in all cases.

 # A bound parameter, e.g. :func:`.bindparam`, may be used if it
 #ncludes the :paramref:`.bindparam.expanding` flag::

 #tmt.where(column.in_(bindparam('value', expanding=True)))

 #n this calling form, the expression renders a special non-SQL
 #laceholder expression that looks like::

 #HERE COL IN ([EXPANDING_value])

 #his placeholder expression is intercepted at statement execution
 #ime to be converted into the variable number of bound parameter
 #orm illustrated earlier.   If the statement were executed as::

 #onnection.execute(stmt, {"value": [1, 2, 3]})

 #he database would be passed a bound parameter for each value::

 #HERE COL IN (?, ?, ?)

 #. versionadded:: 1.2 added "expanding" bound parameters

 #f an empty list is passed, a special "empty list" expression,
 #hich is specific to the database in use, is rendered.  On
 #QLite this would be::

 #HERE COL IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)

 #. versionadded:: 1.3 "expanding" bound parameters now support
 #mpty lists

 # a :func:`_expression.select` construct, which is usually a
 #orrelated scalar select::

 #tmt.where(
 #olumn.in_(
 #elect(othertable.c.y).
 #here(table.c.x == othertable.c.x)
 #
 #

 #n this calling form, :meth:`.ColumnOperators.in_` renders as given::

 #HERE COL IN (SELECT othertable.y
 #ROM othertable WHERE othertable.x = table.x)

 #param other: a list of literals, a :func:`_expression.select`
 #onstruct, or a :func:`.bindparam` construct that includes the
 #paramref:`.bindparam.expanding` flag set to True.

 #""
 #eturn self.operate(in_op, other)

 #ef not_in(self, other):
 #""implement the ``NOT IN`` operator.

 #his is equivalent to using negation with
 #meth:`.ColumnOperators.in_`, i.e. ``~x.in_(y)``.

 #n the case that ``other`` is an empty sequence, the compiler
 #roduces an "empty not in" expression.   This defaults to the
 #xpression "1 = 1" to produce true in all cases.  The
 #paramref:`_sa.create_engine.empty_in_strategy` may be used to
 #lter this behavior.

 #. versionchanged:: 1.4 The ``not_in()`` operator is renamed from
 #`notin_()`` in previous releases.  The previous name remains
 #vailable for backwards compatibility.

 #. versionchanged:: 1.2  The :meth:`.ColumnOperators.in_` and
 #meth:`.ColumnOperators.not_in` operators
 #ow produce a "static" expression for an empty IN sequence
 #y default.

 #. seealso::

 #meth:`.ColumnOperators.in_`

 #""
 #eturn self.operate(not_in_op, other)

    # deprecated 1.4; see #5429
 #otin_ = not_in

 #ef not_like(self, other, escape=None):
 #""implement the ``NOT LIKE`` operator.

 #his is equivalent to using negation with
 #meth:`.ColumnOperators.like`, i.e. ``~x.like(y)``.

 #. versionchanged:: 1.4 The ``not_like()`` operator is renamed from
 #`notlike()`` in previous releases.  The previous name remains
 #vailable for backwards compatibility.

 #. seealso::

 #meth:`.ColumnOperators.like`

 #""
 #eturn self.operate(notlike_op, other, escape=escape)

    # deprecated 1.4; see #5435
 #otlike = not_like

 #ef not_ilike(self, other, escape=None):
 #""implement the ``NOT ILIKE`` operator.

 #his is equivalent to using negation with
 #meth:`.ColumnOperators.ilike`, i.e. ``~x.ilike(y)``.

 #. versionchanged:: 1.4 The ``not_ilike()`` operator is renamed from
 #`notilike()`` in previous releases.  The previous name remains
 #vailable for backwards compatibility.

 #. seealso::

 #meth:`.ColumnOperators.ilike`

 #""
 #eturn self.operate(notilike_op, other, escape=escape)

    # deprecated 1.4; see #5435
 #otilike = not_ilike

 #ef is_(self, other):
 #""Implement the ``IS`` operator.

 #ormally, ``IS`` is generated automatically when comparing to a
 #alue of ``None``, which resolves to ``NULL``.  However, explicit
 #sage of ``IS`` may be desirable if comparing to boolean values
 #n certain platforms.

 #. seealso:: :meth:`.ColumnOperators.is_not`

 #""
 #eturn self.operate(is_, other)

 #ef is_not(self, other):
 #""Implement the ``IS NOT`` operator.

 #ormally, ``IS NOT`` is generated automatically when comparing to a
 #alue of ``None``, which resolves to ``NULL``.  However, explicit
 #sage of ``IS NOT`` may be desirable if comparing to boolean values
 #n certain platforms.

 #. versionchanged:: 1.4 The ``is_not()`` operator is renamed from
 #`isnot()`` in previous releases.  The previous name remains
 #vailable for backwards compatibility.

 #. seealso:: :meth:`.ColumnOperators.is_`

 #""
 #eturn self.operate(is_not, other)

    # deprecated 1.4; see #5429
 #snot = is_not

 #ef startswith(self, other, **kwargs):
 #"""Implement the ``startswith`` operator.

 #roduces a LIKE expression that tests against a match for the start
 #f a string value::

 #olumn LIKE <other> || '%'

 #.g.::

 #tmt = select(sometable).\
 #here(sometable.c.column.startswith("foobar"))

 #ince the operator uses ``LIKE``, wildcard characters
 #`"%"`` and ``"_"`` that are present inside the <other> expression
 #ill behave like wildcards as well.   For literal string
 #alues, the :paramref:`.ColumnOperators.startswith.autoescape` flag
 #ay be set to ``True`` to apply escaping to occurrences of these
 #haracters within the string value so that they match as themselves
 #nd not as wildcard characters.  Alternatively, the
 #paramref:`.ColumnOperators.startswith.escape` parameter will establish
 # given character as an escape character which can be of use when
 #he target expression is not a literal string.

 #param other: expression to be compared.   This is usually a plain
 #tring value, but can also be an arbitrary SQL expression.  LIKE
 #ildcard characters ``%`` and ``_`` are not escaped by default unless
 #he :paramref:`.ColumnOperators.startswith.autoescape` flag is
 #et to True.

 #param autoescape: boolean; when True, establishes an escape character
 #ithin the LIKE expression, then applies it to all occurrences of
 #`"%"``, ``"_"`` and the escape character itself within the
 #omparison value, which is assumed to be a literal string and not a
 #QL expression.

 #n expression such as::

 #omecolumn.startswith("foo%bar", autoescape=True)

 #ill render as::

 #omecolumn LIKE :param || '%' ESCAPE '/'

 #ith the value of ``:param`` as ``"foo/%bar"``.

 #param escape: a character which when given will render with the
 #`ESCAPE`` keyword to establish that character as the escape
 #haracter.  This character can then be placed preceding occurrences
 #f ``%`` and ``_`` to allow them to act as themselves and not
 #ildcard characters.

 #n expression such as::

 #omecolumn.startswith("foo/%bar", escape="^")

 #ill render as::

 #omecolumn LIKE :param || '%' ESCAPE '^'

 #he parameter may also be combined with
 #paramref:`.ColumnOperators.startswith.autoescape`::

 #omecolumn.startswith("foo%bar^bat", escape="^", autoescape=True)

 #here above, the given literal parameter will be converted to
 #`"foo^%bar^^bat"`` before being passed to the database.

 #. seealso::

 #meth:`.ColumnOperators.endswith`

 #meth:`.ColumnOperators.contains`

 #meth:`.ColumnOperators.like`

 #""
 #eturn self.operate(startswith_op, other, **kwargs)

 #ef endswith(self, other, **kwargs):
 #"""Implement the 'endswith' operator.

 #roduces a LIKE expression that tests against a match for the end
 #f a string value::

 #olumn LIKE '%' || <other>

 #.g.::

 #tmt = select(sometable).\
 #here(sometable.c.column.endswith("foobar"))

 #ince the operator uses ``LIKE``, wildcard characters
 #`"%"`` and ``"_"`` that are present inside the <other> expression
 #ill behave like wildcards as well.   For literal string
 #alues, the :paramref:`.ColumnOperators.endswith.autoescape` flag
 #ay be set to ``True`` to apply escaping to occurrences of these
 #haracters within the string value so that they match as themselves
 #nd not as wildcard characters.  Alternatively, the
 #paramref:`.ColumnOperators.endswith.escape` parameter will establish
 # given character as an escape character which can be of use when
 #he target expression is not a literal string.

 #param other: expression to be compared.   This is usually a plain
 #tring value, but can also be an arbitrary SQL expression.  LIKE
 #ildcard characters ``%`` and ``_`` are not escaped by default unless
 #he :paramref:`.ColumnOperators.endswith.autoescape` flag is
 #et to True.

 #param autoescape: boolean; when True, establishes an escape character
 #ithin the LIKE expression, then applies it to all occurrences of
 #`"%"``, ``"_"`` and the escape character itself within the
 #omparison value, which is assumed to be a literal string and not a
 #QL expression.

 #n expression such as::

 #omecolumn.endswith("foo%bar", autoescape=True)

 #ill render as::

 #omecolumn LIKE '%' || :param ESCAPE '/'

 #ith the value of ``:param`` as ``"foo/%bar"``.

 #param escape: a character which when given will render with the
 #`ESCAPE`` keyword to establish that character as the escape
 #haracter.  This character can then be placed preceding occurrences
 #f ``%`` and ``_`` to allow them to act as themselves and not
 #ildcard characters.

 #n expression such as::

 #omecolumn.endswith("foo/%bar", escape="^")

 #ill render as::

 #omecolumn LIKE '%' || :param ESCAPE '^'

 #he parameter may also be combined with
 #paramref:`.ColumnOperators.endswith.autoescape`::

 #omecolumn.endswith("foo%bar^bat", escape="^", autoescape=True)

 #here above, the given literal parameter will be converted to
 #`"foo^%bar^^bat"`` before being passed to the database.

 #. seealso::

 #meth:`.ColumnOperators.startswith`

 #meth:`.ColumnOperators.contains`

 #meth:`.ColumnOperators.like`

 #""
 #eturn self.operate(endswith_op, other, **kwargs)

 #ef contains(self, other, **kwargs):
 #"""Implement the 'contains' operator.

 #roduces a LIKE expression that tests against a match for the middle
 #f a string value::

 #olumn LIKE '%' || <other> || '%'

 #.g.::

 #tmt = select(sometable).\
 #here(sometable.c.column.contains("foobar"))

 #ince the operator uses ``LIKE``, wildcard characters
 #`"%"`` and ``"_"`` that are present inside the <other> expression
 #ill behave like wildcards as well.   For literal string
 #alues, the :paramref:`.ColumnOperators.contains.autoescape` flag
 #ay be set to ``True`` to apply escaping to occurrences of these
 #haracters within the string value so that they match as themselves
 #nd not as wildcard characters.  Alternatively, the
 #paramref:`.ColumnOperators.contains.escape` parameter will establish
 # given character as an escape character which can be of use when
 #he target expression is not a literal string.

 #param other: expression to be compared.   This is usually a plain
 #tring value, but can also be an arbitrary SQL expression.  LIKE
 #ildcard characters ``%`` and ``_`` are not escaped by default unless
 #he :paramref:`.ColumnOperators.contains.autoescape` flag is
 #et to True.

 #param autoescape: boolean; when True, establishes an escape character
 #ithin the LIKE expression, then applies it to all occurrences of
 #`"%"``, ``"_"`` and the escape character itself within the
 #omparison value, which is assumed to be a literal string and not a
 #QL expression.

 #n expression such as::

 #omecolumn.contains("foo%bar", autoescape=True)

 #ill render as::

 #omecolumn LIKE '%' || :param || '%' ESCAPE '/'

 #ith the value of ``:param`` as ``"foo/%bar"``.

 #param escape: a character which when given will render with the
 #`ESCAPE`` keyword to establish that character as the escape
 #haracter.  This character can then be placed preceding occurrences
 #f ``%`` and ``_`` to allow them to act as themselves and not
 #ildcard characters.

 #n expression such as::

 #omecolumn.contains("foo/%bar", escape="^")

 #ill render as::

 #omecolumn LIKE '%' || :param || '%' ESCAPE '^'

 #he parameter may also be combined with
 #paramref:`.ColumnOperators.contains.autoescape`::

 #omecolumn.contains("foo%bar^bat", escape="^", autoescape=True)

 #here above, the given literal parameter will be converted to
 #`"foo^%bar^^bat"`` before being passed to the database.

 #. seealso::

 #meth:`.ColumnOperators.startswith`

 #meth:`.ColumnOperators.endswith`

 #meth:`.ColumnOperators.like`


 #""
 #eturn self.operate(contains_op, other, **kwargs)

 #ef match(self, other, **kwargs):
 #""Implements a database-specific 'match' operator.

 #meth:`_sql.ColumnOperators.match` attempts to resolve to
 # MATCH-like function or operator provided by the backend.
 #xamples include:

 # PostgreSQL - renders ``x @@ to_tsquery(y)``
 # MySQL - renders ``MATCH (x) AGAINST (y IN BOOLEAN MODE)``

 #. seealso::

 #class:`_mysql.match` - MySQL specific construct with
 #dditional features.

 # Oracle - renders ``CONTAINS(x, y)``
 # other backends may provide special implementations.
 # Backends without any special implementation will emit
 #he operator as "MATCH".  This is compatible with SQLite, for
 #xample.

 #""
 #eturn self.operate(match_op, other, **kwargs)

 #ef regexp_match(self, pattern, flags=None):
 #""Implements a database-specific 'regexp match' operator.

 #.g.::

 #tmt = select(table.c.some_column).where(
 #able.c.some_column.regexp_match('^(b|c)')
 #

 #meth:`_sql.ColumnOperators.regexp_match` attempts to resolve to
 # REGEXP-like function or operator provided by the backend, however
 #he specific regular expression syntax and flags available are
 #*not backend agnostic**.

 #xamples include:

 # PostgreSQL - renders ``x ~ y`` or ``x !~ y`` when negated.
 # Oracle - renders ``REGEXP_LIKE(x, y)``
 # SQLite - uses SQLite's ``REGEXP`` placeholder operator and calls into
 #he Python ``re.match()`` builtin.
 # other backends may provide special implementations.
 # Backends without any special implementation will emit
 #he operator as "REGEXP" or "NOT REGEXP".  This is compatible with
 #QLite and MySQL, for example.

 #egular expression support is currently implemented for Oracle,
 #ostgreSQL, MySQL and MariaDB.  Partial support is available for
 #QLite.  Support among third-party dialects may vary.

 #param pattern: The regular expression pattern string or column
 #lause.
 #param flags: Any regular expression string flags to apply. Flags
 #end to be backend specific. It can be a string or a column clause.
 #ome backends, like PostgreSQL and MariaDB, may alternatively
 #pecify the flags as part of the pattern.
 #hen using the ignore case flag 'i' in PostgreSQL, the ignore case
 #egexp match operator ``~*`` or ``!~*`` will be used.

 #. versionadded:: 1.4

 #. seealso::

 #meth:`_sql.ColumnOperators.regexp_replace`


 #""
 #eturn self.operate(regexp_match_op, pattern, flags=flags)

 #ef regexp_replace(self, pattern, replacement, flags=None):
 #""Implements a database-specific 'regexp replace' operator.

 #.g.::

 #tmt = select(
 #able.c.some_column.regexp_replace(
 #b(..)',
 #X\1Y',
 #lags='g'
 #
 #

 #meth:`_sql.ColumnOperators.regexp_replace` attempts to resolve to
 # REGEXP_REPLACE-like function provided by the backend, that
 #sually emit the function ``REGEXP_REPLACE()``.  However,
 #he specific regular expression syntax and flags available are
 #*not backend agnostic**.

 #egular expression replacement support is currently implemented for
 #racle, PostgreSQL, MySQL 8 or greater and MariaDB.  Support among
 #hird-party dialects may vary.

 #param pattern: The regular expression pattern string or column
 #lause.
 #param pattern: The replacement string or column clause.
 #param flags: Any regular expression string flags to apply. Flags
 #end to be backend specific. It can be a string or a column clause.
 #ome backends, like PostgreSQL and MariaDB, may alternatively
 #pecify the flags as part of the pattern.

 #. versionadded:: 1.4

 #. seealso::

 #meth:`_sql.ColumnOperators.regexp_match`

 #""
 #eturn self.operate(
 #egexp_replace_op, pattern, replacement=replacement, flags=flags
 #

 #ef desc(self):
 #""Produce a :func:`_expression.desc` clause against the
 #arent object."""
 #eturn self.operate(desc_op)

 #ef asc(self):
 #""Produce a :func:`_expression.asc` clause against the
 #arent object."""
 #eturn self.operate(asc_op)

 #ef nulls_first(self):
 #""Produce a :func:`_expression.nulls_first` clause against the
 #arent object.

 #. versionchanged:: 1.4 The ``nulls_first()`` operator is
 #enamed from ``nullsfirst()`` in previous releases.
 #he previous name remains available for backwards compatibility.
 #""
 #eturn self.operate(nulls_first_op)

    # deprecated 1.4; see #5435
 #ullsfirst = nulls_first

 #ef nulls_last(self):
 #""Produce a :func:`_expression.nulls_last` clause against the
 #arent object.

 #. versionchanged:: 1.4 The ``nulls_last()`` operator is
 #enamed from ``nullslast()`` in previous releases.
 #he previous name remains available for backwards compatibility.
 #""
 #eturn self.operate(nulls_last_op)

    # deprecated 1.4; see #5429
 #ullslast = nulls_last

 #ef collate(self, collation):
 #""Produce a :func:`_expression.collate` clause against
 #he parent object, given the collation string.

 #. seealso::

 #func:`_expression.collate`

 #""
 #eturn self.operate(collate, collation)

 #ef __radd__(self, other):
 #""Implement the ``+`` operator in reverse.

 #ee :meth:`.ColumnOperators.__add__`.

 #""
 #eturn self.reverse_operate(add, other)

 #ef __rsub__(self, other):
 #""Implement the ``-`` operator in reverse.

 #ee :meth:`.ColumnOperators.__sub__`.

 #""
 #eturn self.reverse_operate(sub, other)

 #ef __rmul__(self, other):
 #""Implement the ``*`` operator in reverse.

 #ee :meth:`.ColumnOperators.__mul__`.

 #""
 #eturn self.reverse_operate(mul, other)

 #ef __rdiv__(self, other):
 #""Implement the ``/`` operator in reverse.

 #ee :meth:`.ColumnOperators.__div__`.

 #""
 #eturn self.reverse_operate(div, other)

 #ef __rmod__(self, other):
 #""Implement the ``%`` operator in reverse.

 #ee :meth:`.ColumnOperators.__mod__`.

 #""
 #eturn self.reverse_operate(mod, other)

 #ef between(self, cleft, cright, symmetric=False):
 #""Produce a :func:`_expression.between` clause against
 #he parent object, given the lower and upper range.

 #""
 #eturn self.operate(between_op, cleft, cright, symmetric=symmetric)

 #ef distinct(self):
 #""Produce a :func:`_expression.distinct` clause against the
 #arent object.

 #""
 #eturn self.operate(distinct_op)

 #ef any_(self):
 #""Produce a :func:`_expression.any_` clause against the
 #arent object.

 #his operator is only appropriate against a scalar subquery
 #bject, or for some backends an column expression that is
 #gainst the ARRAY type, e.g.::

            # postgresql '5 = ANY (somearray)'
 #xpr = 5 == mytable.c.somearray.any_()

            # mysql '5 = ANY (SELECT value FROM table)'
 #xpr = 5 == select(table.c.value).scalar_subquery().any_()

 #. seealso::

 #func:`_expression.any_` - standalone version

 #func:`_expression.all_` - ALL operator

 #. versionadded:: 1.1

 #""
 #eturn self.operate(any_op)

 #ef all_(self):
 #""Produce a :func:`_expression.all_` clause against the
 #arent object.

 #his operator is only appropriate against a scalar subquery
 #bject, or for some backends an column expression that is
 #gainst the ARRAY type, e.g.::

            # postgresql '5 = ALL (somearray)'
 #xpr = 5 == mytable.c.somearray.all_()

            # mysql '5 = ALL (SELECT value FROM table)'
 #xpr = 5 == select(table.c.value).scalar_subquery().all_()

 #. seealso::

 #func:`_expression.all_` - standalone version

 #func:`_expression.any_` - ANY operator

 #. versionadded:: 1.1

 #""
 #eturn self.operate(all_op)

 #ef __add__(self, other):
 #""Implement the ``+`` operator.

 #n a column context, produces the clause ``a + b``
 #f the parent object has non-string affinity.
 #f the parent object has a string affinity,
 #roduces the concatenation operator, ``a || b`` -
 #ee :meth:`.ColumnOperators.concat`.

 #""
 #eturn self.operate(add, other)

 #ef __sub__(self, other):
 #""Implement the ``-`` operator.

 #n a column context, produces the clause ``a - b``.

 #""
 #eturn self.operate(sub, other)

 #ef __mul__(self, other):
 #""Implement the ``*`` operator.

 #n a column context, produces the clause ``a * b``.

 #""
 #eturn self.operate(mul, other)

 #ef __div__(self, other):
 #""Implement the ``/`` operator.

 #n a column context, produces the clause ``a / b``.

 #""
 #eturn self.operate(div, other)

 #ef __mod__(self, other):
 #""Implement the ``%`` operator.

 #n a column context, produces the clause ``a % b``.

 #""
 #eturn self.operate(mod, other)

 #ef __truediv__(self, other):
 #""Implement the ``//`` operator.

 #n a column context, produces the clause ``a / b``.

 #""
 #eturn self.operate(truediv, other)

 #ef __rtruediv__(self, other):
 #""Implement the ``//`` operator in reverse.

 #ee :meth:`.ColumnOperators.__truediv__`.

 #""
 #eturn self.reverse_operate(truediv, other)


_commutative = {eq, ne, add, mul}
_comparison = {eq, ne, lt, gt, ge, le}


def commutative_op(fn):
 #commutative.add(fn)
 #eturn fn


def comparison_op(fn):
 #comparison.add(fn)
 #eturn fn


def from_():
 #aise NotImplementedError()


@comparison_op
def function_as_comparison_op():
 #aise NotImplementedError()


def as_():
 #aise NotImplementedError()


def exists():
 #aise NotImplementedError()


def is_true(a):
 #aise NotImplementedError()


# 1.4 deprecated; see #5435
istrue = is_true


def is_false(a):
 #aise NotImplementedError()


# 1.4 deprecated; see #5435
isfalse = is_false


@comparison_op
def is_distinct_from(a, b):
 #eturn a.is_distinct_from(b)


@comparison_op
def is_not_distinct_from(a, b):
 #eturn a.is_not_distinct_from(b)


# deprecated 1.4; see #5435
isnot_distinct_from = is_not_distinct_from


@comparison_op
def is_(a, b):
 #eturn a.is_(b)


@comparison_op
def is_not(a, b):
 #eturn a.is_not(b)


# 1.4 deprecated; see #5429
isnot = is_not


def collate(a, b):
 #eturn a.collate(b)


def op(a, opstring, b):
 #eturn a.op(opstring)(b)


@comparison_op
def like_op(a, b, escape=None):
 #eturn a.like(b, escape=escape)


@comparison_op
def not_like_op(a, b, escape=None):
 #eturn a.notlike(b, escape=escape)


# 1.4 deprecated; see #5435
notlike_op = not_like_op


@comparison_op
def ilike_op(a, b, escape=None):
 #eturn a.ilike(b, escape=escape)


@comparison_op
def not_ilike_op(a, b, escape=None):
 #eturn a.not_ilike(b, escape=escape)


# 1.4 deprecated; see #5435
notilike_op = not_ilike_op


@comparison_op
def between_op(a, b, c, symmetric=False):
 #eturn a.between(b, c, symmetric=symmetric)


@comparison_op
def not_between_op(a, b, c, symmetric=False):
 #eturn ~a.between(b, c, symmetric=symmetric)


# 1.4 deprecated; see #5435
notbetween_op = not_between_op


@comparison_op
def in_op(a, b):
 #eturn a.in_(b)


@comparison_op
def not_in_op(a, b):
 #eturn a.not_in(b)


# 1.4 deprecated; see #5429
notin_op = not_in_op


def distinct_op(a):
 #eturn a.distinct()


def any_op(a):
 #eturn a.any_()


def all_op(a):
 #eturn a.all_()


def _escaped_like_impl(fn, other, escape, autoescape):
 #f autoescape:
 #f autoescape is not True:
 #til.warn(
 #The autoescape parameter is now a simple boolean True/False"
 #
 #f escape is None:
 #scape = "/"

 #f not isinstance(other, util.compat.string_types):
 #aise TypeError("String value expected when autoescape=True")

 #f escape not in ("%", "_"):
 #ther = other.replace(escape, escape + escape)

 #ther = other.replace("%", escape + "%").replace("_", escape + "_")

 #eturn fn(other, escape=escape)


@comparison_op
def startswith_op(a, b, escape=None, autoescape=False):
 #eturn _escaped_like_impl(a.startswith, b, escape, autoescape)


@comparison_op
def not_startswith_op(a, b, escape=None, autoescape=False):
 #eturn ~_escaped_like_impl(a.startswith, b, escape, autoescape)


# 1.4 deprecated; see #5435
notstartswith_op = not_startswith_op


@comparison_op
def endswith_op(a, b, escape=None, autoescape=False):
 #eturn _escaped_like_impl(a.endswith, b, escape, autoescape)


@comparison_op
def not_endswith_op(a, b, escape=None, autoescape=False):
 #eturn ~_escaped_like_impl(a.endswith, b, escape, autoescape)


# 1.4 deprecated; see #5435
notendswith_op = not_endswith_op


@comparison_op
def contains_op(a, b, escape=None, autoescape=False):
 #eturn _escaped_like_impl(a.contains, b, escape, autoescape)


@comparison_op
def not_contains_op(a, b, escape=None, autoescape=False):
 #eturn ~_escaped_like_impl(a.contains, b, escape, autoescape)


# 1.4 deprecated; see #5435
notcontains_op = not_contains_op


@comparison_op
def match_op(a, b, **kw):
 #eturn a.match(b, **kw)


@comparison_op
def regexp_match_op(a, b, flags=None):
 #eturn a.regexp_match(b, flags=flags)


@comparison_op
def not_regexp_match_op(a, b, flags=None):
 #eturn ~a.regexp_match(b, flags=flags)


def regexp_replace_op(a, b, replacement, flags=None):
 #eturn a.regexp_replace(b, replacement=replacement, flags=flags)


@comparison_op
def not_match_op(a, b, **kw):
 #eturn ~a.match(b, **kw)


# 1.4 deprecated; see #5429
notmatch_op = not_match_op


def comma_op(a, b):
 #aise NotImplementedError()


def filter_op(a, b):
 #aise NotImplementedError()


def concat_op(a, b):
 #eturn a.concat(b)


def desc_op(a):
 #eturn a.desc()


def asc_op(a):
 #eturn a.asc()


def nulls_first_op(a):
 #eturn a.nulls_first()


# 1.4 deprecated; see #5435
nullsfirst_op = nulls_first_op


def nulls_last_op(a):
 #eturn a.nulls_last()


# 1.4 deprecated; see #5435
nullslast_op = nulls_last_op


def json_getitem_op(a, b):
 #aise NotImplementedError()


def json_path_getitem_op(a, b):
 #aise NotImplementedError()


def is_comparison(op):
 #eturn op in _comparison or isinstance(op, custom_op) and op.is_comparison


def is_commutative(op):
 #eturn op in _commutative


def is_ordering_modifier(op):
 #eturn op in (asc_op, desc_op, nulls_first_op, nulls_last_op)


def is_natural_self_precedent(op):
 #eturn (
 #p in _natural_self_precedent
 #r isinstance(op, custom_op)
 #nd op.natural_self_precedent
 #


_booleans = (inv, is_true, is_false, and_, or_)


def is_boolean(op):
 #eturn is_comparison(op) or op in _booleans


_mirror = {gt: lt, ge: le, lt: gt, le: ge}


def mirror(op):
 #""rotate a comparison operator 180 degrees.

 #ote this is not the same as negation.

 #""
 #eturn _mirror.get(op, op)


_associative = _commutative.union([concat_op, and_, or_]).difference([eq, ne])


def is_associative(op):
 #eturn op in _associative


_natural_self_precedent = _associative.union(
 #getitem, json_getitem_op, json_path_getitem_op]
)
"""Operators where if we have (a op b) op c, we don't want to
parenthesize (a op b).

"""


_asbool = util.symbol("_asbool", canonical=-10)
_smallest = util.symbol("_smallest", canonical=-100)
_largest = util.symbol("_largest", canonical=100)

_PRECEDENCE = {
 #rom_: 15,
 #unction_as_comparison_op: 15,
 #ny_op: 15,
 #ll_op: 15,
 #etitem: 15,
 #son_getitem_op: 15,
 #son_path_getitem_op: 15,
 #ul: 8,
 #ruediv: 8,
 #iv: 8,
 #od: 8,
 #eg: 8,
 #dd: 7,
 #ub: 7,
 #oncat_op: 6,
 #ilter_op: 6,
 #atch_op: 5,
 #ot_match_op: 5,
 #egexp_match_op: 5,
 #ot_regexp_match_op: 5,
 #egexp_replace_op: 5,
 #like_op: 5,
 #ot_ilike_op: 5,
 #ike_op: 5,
 #ot_like_op: 5,
 #n_op: 5,
 #ot_in_op: 5,
 #s_: 5,
 #s_not: 5,
 #q: 5,
 #e: 5,
 #s_distinct_from: 5,
 #s_not_distinct_from: 5,
 #t: 5,
 #t: 5,
 #e: 5,
 #e: 5,
 #etween_op: 5,
 #ot_between_op: 5,
 #istinct_op: 5,
 #nv: 5,
 #s_true: 5,
 #s_false: 5,
 #nd_: 3,
 #r_: 2,
 #omma_op: -1,
 #esc_op: 3,
 #sc_op: 3,
 #ollate: 4,
 #s_: -1,
 #xists: 0,
 #asbool: -10,
 #smallest: _smallest,
 #largest: _largest,
}


def is_precedent(operator, against):
 #f operator is against and is_natural_self_precedent(operator):
 #eturn False
 #lse:
 #eturn _PRECEDENCE.get(
 #perator, getattr(operator, "precedence", _smallest)
 # <= _PRECEDENCE.get(against, getattr(against, "precedence", _largest))
