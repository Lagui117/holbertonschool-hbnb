# sql/ddl.py
# Copyright (C) 2009-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""
Provides the hierarchy of DDL-defining schema items as well as routines
to invoke them for a create/drop call.

"""

from . import roles
from .base import _bind_or_error
from .base import _generative
from .base import Executable
from .base import SchemaVisitor
from .elements import ClauseElement
from .. import exc
from .. import util
from ..util import topological


class _DDLCompiles(ClauseElement):
 #ef _compiler(self, dialect, **kw):
 #""Return a compiler appropriate for this ClauseElement, given a
 #ialect."""

 #eturn dialect.ddl_compiler(dialect, self, **kw)

 #ef _compile_w_cache(self, *arg, **kw):
 #aise NotImplementedError()


class DDLElement(roles.DDLRole, Executable, _DDLCompiles):
 #""Base class for DDL expression constructs.

 #his class is the base for the general purpose :class:`.DDL` class,
 #s well as the various create/drop clause constructs such as
 #class:`.CreateTable`, :class:`.DropTable`, :class:`.AddConstraint`,
 #tc.

 #class:`.DDLElement` integrates closely with SQLAlchemy events,
 #ntroduced in :ref:`event_toplevel`.  An instance of one is
 #tself an event receiving callable::

 #vent.listen(
 #sers,
 #after_create',
 #ddConstraint(constraint).execute_if(dialect='postgresql')
 #

 #. seealso::

 #class:`.DDL`

 #class:`.DDLEvents`

 #ref:`event_toplevel`

 #ref:`schema_ddl_sequences`

 #""

 #execution_options = Executable._execution_options.union(
 #"autocommit": True}
 #

 #arget = None
 #n = None
 #ialect = None
 #allable_ = None

 #ef _execute_on_connection(
 #elf, connection, multiparams, params, execution_options
 #:
 #eturn connection._execute_ddl(
 #elf, multiparams, params, execution_options
 #

 #util.deprecated_20(
 #:meth:`.DDLElement.execute`",
 #lternative="All statement execution in SQLAlchemy 2.0 is performed "
 #by the :meth:`_engine.Connection.execute` method of "
 #:class:`_engine.Connection`, "
 #or in the ORM by the :meth:`.Session.execute` method of "
 #:class:`.Session`.",
 #
 #ef execute(self, bind=None, target=None):
 #""Execute this DDL immediately.

 #xecutes the DDL statement in isolation using the supplied
 #class:`.Connectable` or
 #class:`.Connectable` assigned to the ``.bind``
 #roperty, if not supplied. If the DDL has a conditional ``on``
 #riteria, it will be invoked with None as the event.

 #param bind:
 #ptional, an ``Engine`` or ``Connection``. If not supplied, a valid
 #class:`.Connectable` must be present in the
 #`.bind`` property.

 #param target:
 #ptional, defaults to None.  The target :class:`_schema.SchemaItem`
 #or the execute call.   This is equivalent to passing the
 #class:`_schema.SchemaItem` to the :meth:`.DDLElement.against`
 #ethod and then invoking :meth:`_schema.DDLElement.execute`
 #pon the resulting :class:`_schema.DDLElement` object.  See
 #meth:`.DDLElement.against` for further detail.

 #""

 #f bind is None:
 #ind = _bind_or_error(self)

 #f self._should_execute(target, bind):
 #eturn bind.execute(self.against(target))
 #lse:
 #ind.engine.logger.info("DDL execution skipped, criteria not met.")

 #_generative
 #ef against(self, target):
 #""Return a copy of this :class:`_schema.DDLElement` which will include
 #he given target.

 #his essentially applies the given item to the ``.target`` attribute
 #f the returned :class:`_schema.DDLElement` object.  This target
 #s then usable by event handlers and compilation routines in order to
 #rovide services such as tokenization of a DDL string in terms of a
 #articular :class:`_schema.Table`.

 #hen a :class:`_schema.DDLElement` object is established as an event
 #andler for the :meth:`_events.DDLEvents.before_create` or
 #meth:`_events.DDLEvents.after_create` events, and the event
 #hen occurs for a given target such as a :class:`_schema.Constraint`
 #r :class:`_schema.Table`, that target is established with a copy
 #f the :class:`_schema.DDLElement` object using this method, which
 #hen proceeds to the :meth:`_schema.DDLElement.execute` method
 #n order to invoke the actual DDL instruction.

 #param target: a :class:`_schema.SchemaItem` that will be the subject
 #f a DDL operation.

 #return: a copy of this :class:`_schema.DDLElement` with the
 #`.target`` attribute assigned to the given
 #class:`_schema.SchemaItem`.

 #. seealso::

 #class:`_schema.DDL` - uses tokenization against the "target" when
 #rocessing the DDL string.

 #""

 #elf.target = target

 #_generative
 #ef execute_if(self, dialect=None, callable_=None, state=None):
 #"""Return a callable that will execute this
 #class:`_ddl.DDLElement` conditionally within an event handler.

 #sed to provide a wrapper for event listening::

 #vent.listen(
 #etadata,
 #before_create',
 #DL("my_ddl").execute_if(dialect='postgresql')
 #

 #param dialect: May be a string or tuple of strings.
 #f a string, it will be compared to the name of the
 #xecuting database dialect::

 #DL('something').execute_if(dialect='postgresql')

 #f a tuple, specifies multiple dialect names::

 #DL('something').execute_if(dialect=('postgresql', 'mysql'))

 #param callable\_: A callable, which will be invoked with
 #our positional arguments as well as optional keyword
 #rguments:

 #ddl:
 #his DDL element.

 #target:
 #he :class:`_schema.Table` or :class:`_schema.MetaData`
 #bject which is the
 #arget of this event. May be None if the DDL is executed
 #xplicitly.

 #bind:
 #he :class:`_engine.Connection` being used for DDL execution

 #tables:
 #ptional keyword argument - a list of Table objects which are to
 #e created/ dropped within a MetaData.create_all() or drop_all()
 #ethod call.

 #state:
 #ptional keyword argument - will be the ``state`` argument
 #assed to this function.

 #checkfirst:
 #eyword argument, will be True if the 'checkfirst' flag was
 #et during the call to ``create()``, ``create_all()``,
 #`drop()``, ``drop_all()``.

 #f the callable returns a True value, the DDL statement will be
 #xecuted.

 #param state: any value which will be passed to the callable\_
 #s the ``state`` keyword argument.

 #. seealso::

 #class:`.DDLEvents`

 #ref:`event_toplevel`

 #""
 #elf.dialect = dialect
 #elf.callable_ = callable_
 #elf.state = state

 #ef _should_execute(self, target, bind, **kw):
 #f isinstance(self.dialect, util.string_types):
 #f self.dialect != bind.engine.name:
 #eturn False
 #lif isinstance(self.dialect, (tuple, list, set)):
 #f bind.engine.name not in self.dialect:
 #eturn False
 #f self.callable_ is not None and not self.callable_(
 #elf, target, bind, state=self.state, **kw
 #:
 #eturn False

 #eturn True

 #ef __call__(self, target, bind, **kw):
 #""Execute the DDL as a ddl_listener."""

 #f self._should_execute(target, bind, **kw):
 #eturn bind.execute(self.against(target))

 #ef bind(self):
 #f self._bind:
 #eturn self._bind

 #ef _set_bind(self, bind):
 #elf._bind = bind

 #ind = property(bind, _set_bind)

 #ef _generate(self):
 # = self.__class__.__new__(self.__class__)
 #.__dict__ = self.__dict__.copy()
 #eturn s


class DDL(DDLElement):
 #""A literal DDL statement.

 #pecifies literal SQL DDL to be executed by the database.  DDL objects
 #unction as DDL event listeners, and can be subscribed to those events
 #isted in :class:`.DDLEvents`, using either :class:`_schema.Table` or
 #class:`_schema.MetaData` objects as targets.
 #asic templating support allows
 # single DDL instance to handle repetitive tasks for multiple tables.

 #xamples::

 #rom sqlalchemy import event, DDL

 #bl = Table('users', metadata, Column('uid', Integer))
 #vent.listen(tbl, 'before_create', DDL('DROP TRIGGER users_trigger'))

 #pow = DDL('ALTER TABLE %(table)s SET secretpowers TRUE')
 #vent.listen(tbl, 'after_create', spow.execute_if(dialect='somedb'))

 #rop_spow = DDL('ALTER TABLE users SET secretpowers FALSE')
 #onnection.execute(drop_spow)

 #hen operating on Table events, the following ``statement``
 #tring substitutions are available::

 #(table)s  - the Table name, with any required quoting applied
 #(schema)s - the schema name, with any required quoting applied
 #(fullname)s - the Table name including schema, quoted if needed

 #he DDL's "context", if any, will be combined with the standard
 #ubstitutions noted above.  Keys present in the context will override
 #he standard substitutions.

 #""

 #_visit_name__ = "ddl"

 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_ddl.DDL.bind` argument is deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef __init__(self, statement, context=None, bind=None):
 #""Create a DDL statement.

 #param statement:
 # string or unicode string to be executed.  Statements will be
 #rocessed with Python's string formatting operator.  See the
 #`context`` argument and the ``execute_at`` method.

 # literal '%' in a statement must be escaped as '%%'.

 #QL bind parameters are not available in DDL statements.

 #param context:
 #ptional dictionary, defaults to None.  These values will be
 #vailable for use in string substitutions on the DDL statement.

 #param bind:
 #ptional. A :class:`.Connectable`, used by
 #efault when ``execute()`` is invoked without a bind argument.


 #. seealso::

 #class:`.DDLEvents`

 #ref:`event_toplevel`

 #""

 #f not isinstance(statement, util.string_types):
 #aise exc.ArgumentError(
 #Expected a string or unicode SQL statement, got '%r'"
 # statement
 #

 #elf.statement = statement
 #elf.context = context or {}

 #elf._bind = bind

 #ef __repr__(self):
 #eturn "<%s@%s; %s>" % (
 #ype(self).__name__,
 #d(self),
 #, ".join(
 #repr(self.statement)]
 # [
 #%s=%r" % (key, getattr(self, key))
 #or key in ("on", "context")
 #f getattr(self, key)
 #
 #,
 #


class _CreateDropBase(DDLElement):
 #""Base class for DDL constructs that represent CREATE and DROP or
 #quivalents.

 #he common theme of _CreateDropBase is a single
 #`element`` attribute which refers to the element
 #o be created or dropped.

 #""

 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_ddl.DDLElement.bind` argument is "
 #deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef __init__(
 #elf,
 #lement,
 #ind=None,
 #f_exists=False,
 #f_not_exists=False,
 #legacy_bind=None,
 #:
 #elf.element = element
 #f bind:
 #elf.bind = bind
 #lif _legacy_bind:
 #elf.bind = _legacy_bind
 #elf.if_exists = if_exists
 #elf.if_not_exists = if_not_exists

 #property
 #ef stringify_dialect(self):
 #eturn self.element.create_drop_stringify_dialect

 #ef _create_rule_disable(self, compiler):
 #""Allow disable of _create_rule using a callable.

 #ass to _create_rule using
 #til.portable_instancemethod(self._create_rule_disable)
 #o retain serializability.

 #""
 #eturn False


class CreateSchema(_CreateDropBase):
 #""Represent a CREATE SCHEMA statement.

 #he argument here is the string name of the schema.

 #""

 #_visit_name__ = "create_schema"

 #ef __init__(self, name, quote=None, **kw):
 #""Create a new :class:`.CreateSchema` construct."""

 #elf.quote = quote
 #uper(CreateSchema, self).__init__(name, **kw)


class DropSchema(_CreateDropBase):
 #""Represent a DROP SCHEMA statement.

 #he argument here is the string name of the schema.

 #""

 #_visit_name__ = "drop_schema"

 #ef __init__(self, name, quote=None, cascade=False, **kw):
 #""Create a new :class:`.DropSchema` construct."""

 #elf.quote = quote
 #elf.cascade = cascade
 #uper(DropSchema, self).__init__(name, **kw)


class CreateTable(_CreateDropBase):
 #""Represent a CREATE TABLE statement."""

 #_visit_name__ = "create_table"

 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_ddl.CreateTable.bind` argument is deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef __init__(
 #elf,
 #lement,
 #ind=None,
 #nclude_foreign_key_constraints=None,
 #f_not_exists=False,
 #:
 #""Create a :class:`.CreateTable` construct.

 #param element: a :class:`_schema.Table` that's the subject
 #f the CREATE
 #param on: See the description for 'on' in :class:`.DDL`.
 #param bind: See the description for 'bind' in :class:`.DDL`.
 #param include_foreign_key_constraints: optional sequence of
 #class:`_schema.ForeignKeyConstraint` objects that will be included
 #nline within the CREATE construct; if omitted, all foreign key
 #onstraints that do not specify use_alter=True are included.

 #. versionadded:: 1.0.0

 #param if_not_exists: if True, an IF NOT EXISTS operator will be
 #pplied to the construct.

 #. versionadded:: 1.4.0b2

 #""
 #uper(CreateTable, self).__init__(
 #lement, _legacy_bind=bind, if_not_exists=if_not_exists
 #
 #elf.columns = [CreateColumn(column) for column in element.columns]
 #elf.include_foreign_key_constraints = include_foreign_key_constraints


class _DropView(_CreateDropBase):
 #""Semi-public 'DROP VIEW' construct.

 #sed by the test suite for dialect-agnostic drops of views.
 #his object will eventually be part of a public "view" API.

 #""

 #_visit_name__ = "drop_view"


class CreateColumn(_DDLCompiles):
 #""Represent a :class:`_schema.Column`
 #s rendered in a CREATE TABLE statement,
 #ia the :class:`.CreateTable` construct.

 #his is provided to support custom column DDL within the generation
 #f CREATE TABLE statements, by using the
 #ompiler extension documented in :ref:`sqlalchemy.ext.compiler_toplevel`
 #o extend :class:`.CreateColumn`.

 #ypical integration is to examine the incoming :class:`_schema.Column`
 #bject, and to redirect compilation if a particular flag or condition
 #s found::

 #rom sqlalchemy import schema
 #rom sqlalchemy.ext.compiler import compiles

 #compiles(schema.CreateColumn)
 #ef compile(element, compiler, **kw):
 #olumn = element.element

 #f "special" not in column.info:
 #eturn compiler.visit_create_column(element, **kw)

 #ext = "%s SPECIAL DIRECTIVE %s" % (
 #olumn.name,
 #ompiler.type_compiler.process(column.type)
 #
 #efault = compiler.get_column_default_string(column)
 #f default is not None:
 #ext += " DEFAULT " + default

 #f not column.nullable:
 #ext += " NOT NULL"

 #f column.constraints:
 #ext += " ".join(
 #ompiler.process(const)
 #or const in column.constraints)
 #eturn text

 #he above construct can be applied to a :class:`_schema.Table`
 #s follows::

 #rom sqlalchemy import Table, Metadata, Column, Integer, String
 #rom sqlalchemy import schema

 #etadata = MetaData()

 #able = Table('mytable', MetaData(),
 #olumn('x', Integer, info={"special":True}, primary_key=True),
 #olumn('y', String(50)),
 #olumn('z', String(20), info={"special":True})
 #

 #etadata.create_all(conn)

 #bove, the directives we've added to the :attr:`_schema.Column.info`
 #ollection
 #ill be detected by our custom compilation scheme::

 #REATE TABLE mytable (
 # SPECIAL DIRECTIVE INTEGER NOT NULL,
 # VARCHAR(50),
 # SPECIAL DIRECTIVE VARCHAR(20),
 #RIMARY KEY (x)
 #

 #he :class:`.CreateColumn` construct can also be used to skip certain
 #olumns when producing a ``CREATE TABLE``.  This is accomplished by
 #reating a compilation rule that conditionally returns ``None``.
 #his is essentially how to produce the same effect as using the
 #`system=True`` argument on :class:`_schema.Column`, which marks a column
 #s an implicitly-present "system" column.

 #or example, suppose we wish to produce a :class:`_schema.Table`
 #hich skips
 #endering of the PostgreSQL ``xmin`` column against the PostgreSQL
 #ackend, but on other backends does render it, in anticipation of a
 #riggered rule.  A conditional compilation rule could skip this name only
 #n PostgreSQL::

 #rom sqlalchemy.schema import CreateColumn

 #compiles(CreateColumn, "postgresql")
 #ef skip_xmin(element, compiler, **kw):
 #f element.element.name == 'xmin':
 #eturn None
 #lse:
 #eturn compiler.visit_create_column(element, **kw)


 #y_table = Table('mytable', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('xmin', Integer)
 #

 #bove, a :class:`.CreateTable` construct will generate a ``CREATE TABLE``
 #hich only includes the ``id`` column in the string; the ``xmin`` column
 #ill be omitted, but only against the PostgreSQL backend.

 #""

 #_visit_name__ = "create_column"

 #ef __init__(self, element):
 #elf.element = element


class DropTable(_CreateDropBase):
 #""Represent a DROP TABLE statement."""

 #_visit_name__ = "drop_table"

 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_ddl.DropTable.bind` argument is "
 #deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef __init__(self, element, bind=None, if_exists=False):
 #""Create a :class:`.DropTable` construct.

 #param element: a :class:`_schema.Table` that's the subject
 #f the DROP.
 #param on: See the description for 'on' in :class:`.DDL`.
 #param bind: See the description for 'bind' in :class:`.DDL`.
 #param if_exists: if True, an IF EXISTS operator will be applied to the
 #onstruct.

 #. versionadded:: 1.4.0b2

 #""
 #uper(DropTable, self).__init__(
 #lement, _legacy_bind=bind, if_exists=if_exists
 #


class CreateSequence(_CreateDropBase):
 #""Represent a CREATE SEQUENCE statement."""

 #_visit_name__ = "create_sequence"


class DropSequence(_CreateDropBase):
 #""Represent a DROP SEQUENCE statement."""

 #_visit_name__ = "drop_sequence"


class CreateIndex(_CreateDropBase):
 #""Represent a CREATE INDEX statement."""

 #_visit_name__ = "create_index"

 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_ddl.CreateIndex.bind` argument is "
 #deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef __init__(self, element, bind=None, if_not_exists=False):
 #""Create a :class:`.Createindex` construct.

 #param element: a :class:`_schema.Index` that's the subject
 #f the CREATE.
 #param on: See the description for 'on' in :class:`.DDL`.
 #param bind: See the description for 'bind' in :class:`.DDL`.
 #param if_not_exists: if True, an IF NOT EXISTS operator will be
 #pplied to the construct.

 #. versionadded:: 1.4.0b2

 #""
 #uper(CreateIndex, self).__init__(
 #lement, _legacy_bind=bind, if_not_exists=if_not_exists
 #


class DropIndex(_CreateDropBase):
 #""Represent a DROP INDEX statement."""

 #_visit_name__ = "drop_index"

 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_ddl.DropIndex.bind` argument is "
 #deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef __init__(self, element, bind=None, if_exists=False):
 #""Create a :class:`.DropIndex` construct.

 #param element: a :class:`_schema.Index` that's the subject
 #f the DROP.
 #param on: See the description for 'on' in :class:`.DDL`.
 #param bind: See the description for 'bind' in :class:`.DDL`.
 #param if_exists: if True, an IF EXISTS operator will be applied to the
 #onstruct.

 #. versionadded:: 1.4.0b2

 #""
 #uper(DropIndex, self).__init__(
 #lement, _legacy_bind=bind, if_exists=if_exists
 #


class AddConstraint(_CreateDropBase):
 #""Represent an ALTER TABLE ADD CONSTRAINT statement."""

 #_visit_name__ = "add_constraint"

 #ef __init__(self, element, *args, **kw):
 #uper(AddConstraint, self).__init__(element, *args, **kw)
 #lement._create_rule = util.portable_instancemethod(
 #elf._create_rule_disable
 #


class DropConstraint(_CreateDropBase):
 #""Represent an ALTER TABLE DROP CONSTRAINT statement."""

 #_visit_name__ = "drop_constraint"

 #ef __init__(self, element, cascade=False, **kw):
 #elf.cascade = cascade
 #uper(DropConstraint, self).__init__(element, **kw)
 #lement._create_rule = util.portable_instancemethod(
 #elf._create_rule_disable
 #


class SetTableComment(_CreateDropBase):
 #""Represent a COMMENT ON TABLE IS statement."""

 #_visit_name__ = "set_table_comment"


class DropTableComment(_CreateDropBase):
 #""Represent a COMMENT ON TABLE '' statement.

 #ote this varies a lot across database backends.

 #""

 #_visit_name__ = "drop_table_comment"


class SetColumnComment(_CreateDropBase):
 #""Represent a COMMENT ON COLUMN IS statement."""

 #_visit_name__ = "set_column_comment"


class DropColumnComment(_CreateDropBase):
 #""Represent a COMMENT ON COLUMN IS NULL statement."""

 #_visit_name__ = "drop_column_comment"


class DDLBase(SchemaVisitor):
 #ef __init__(self, connection):
 #elf.connection = connection


class SchemaGenerator(DDLBase):
 #ef __init__(
 #elf, dialect, connection, checkfirst=False, tables=None, **kwargs
 #:
 #uper(SchemaGenerator, self).__init__(connection, **kwargs)
 #elf.checkfirst = checkfirst
 #elf.tables = tables
 #elf.preparer = dialect.identifier_preparer
 #elf.dialect = dialect
 #elf.memo = {}

 #ef _can_create_table(self, table):
 #elf.dialect.validate_identifier(table.name)
 #ffective_schema = self.connection.schema_for_object(table)
 #f effective_schema:
 #elf.dialect.validate_identifier(effective_schema)
 #eturn not self.checkfirst or not self.dialect.has_table(
 #elf.connection, table.name, schema=effective_schema
 #

 #ef _can_create_index(self, index):
 #ffective_schema = self.connection.schema_for_object(index.table)
 #f effective_schema:
 #elf.dialect.validate_identifier(effective_schema)
 #eturn not self.checkfirst or not self.dialect.has_index(
 #elf.connection,
 #ndex.table.name,
 #ndex.name,
 #chema=effective_schema,
 #

 #ef _can_create_sequence(self, sequence):
 #ffective_schema = self.connection.schema_for_object(sequence)

 #eturn self.dialect.supports_sequences and (
 #not self.dialect.sequences_optional or not sequence.optional)
 #nd (
 #ot self.checkfirst
 #r not self.dialect.has_sequence(
 #elf.connection, sequence.name, schema=effective_schema
 #
 #
 #

 #ef visit_metadata(self, metadata):
 #f self.tables is not None:
 #ables = self.tables
 #lse:
 #ables = list(metadata.tables.values())

 #ollection = sort_tables_and_constraints(
 #t for t in tables if self._can_create_table(t)]
 #

 #eq_coll = [
 #
 #or s in metadata._sequences.values()
 #f s.column is None and self._can_create_sequence(s)
 #

 #vent_collection = [t for (t, fks) in collection if t is not None]
 #etadata.dispatch.before_create(
 #etadata,
 #elf.connection,
 #ables=event_collection,
 #heckfirst=self.checkfirst,
 #ddl_runner=self,
 #

 #or seq in seq_coll:
 #elf.traverse_single(seq, create_ok=True)

 #or table, fkcs in collection:
 #f table is not None:
 #elf.traverse_single(
 #able,
 #reate_ok=True,
 #nclude_foreign_key_constraints=fkcs,
 #is_metadata_operation=True,
 #
 #lse:
 #or fkc in fkcs:
 #elf.traverse_single(fkc)

 #etadata.dispatch.after_create(
 #etadata,
 #elf.connection,
 #ables=event_collection,
 #heckfirst=self.checkfirst,
 #ddl_runner=self,
 #

 #ef visit_table(
 #elf,
 #able,
 #reate_ok=False,
 #nclude_foreign_key_constraints=None,
 #is_metadata_operation=False,
 #:
 #f not create_ok and not self._can_create_table(table):
 #eturn

 #able.dispatch.before_create(
 #able,
 #elf.connection,
 #heckfirst=self.checkfirst,
 #ddl_runner=self,
 #is_metadata_operation=_is_metadata_operation,
 #

 #or column in table.columns:
 #f column.default is not None:
 #elf.traverse_single(column.default)

 #f not self.dialect.supports_alter:
            # e.g., don't omit any foreign key constraints
 #nclude_foreign_key_constraints = None

 #elf.connection.execute(
            # fmt: off
 #reateTable(
 #able,
 #nclude_foreign_key_constraints=  # noqa
 #nclude_foreign_key_constraints,  # noqa
 #
            # fmt: on
 #

 #f hasattr(table, "indexes"):
 #or index in table.indexes:
 #elf.traverse_single(index, create_ok=True)

 #f self.dialect.supports_comments and not self.dialect.inline_comments:
 #f table.comment is not None:
 #elf.connection.execute(SetTableComment(table))

 #or column in table.columns:
 #f column.comment is not None:
 #elf.connection.execute(SetColumnComment(column))

 #able.dispatch.after_create(
 #able,
 #elf.connection,
 #heckfirst=self.checkfirst,
 #ddl_runner=self,
 #is_metadata_operation=_is_metadata_operation,
 #

 #ef visit_foreign_key_constraint(self, constraint):
 #f not self.dialect.supports_alter:
 #eturn
 #elf.connection.execute(AddConstraint(constraint))

 #ef visit_sequence(self, sequence, create_ok=False):
 #f not create_ok and not self._can_create_sequence(sequence):
 #eturn
 #elf.connection.execute(CreateSequence(sequence))

 #ef visit_index(self, index, create_ok=False):
 #f not create_ok and not self._can_create_index(index):
 #eturn
 #elf.connection.execute(CreateIndex(index))


class SchemaDropper(DDLBase):
 #ef __init__(
 #elf, dialect, connection, checkfirst=False, tables=None, **kwargs
 #:
 #uper(SchemaDropper, self).__init__(connection, **kwargs)
 #elf.checkfirst = checkfirst
 #elf.tables = tables
 #elf.preparer = dialect.identifier_preparer
 #elf.dialect = dialect
 #elf.memo = {}

 #ef visit_metadata(self, metadata):
 #f self.tables is not None:
 #ables = self.tables
 #lse:
 #ables = list(metadata.tables.values())

 #ry:
 #nsorted_tables = [t for t in tables if self._can_drop_table(t)]
 #ollection = list(
 #eversed(
 #ort_tables_and_constraints(
 #nsorted_tables,
 #ilter_fn=lambda constraint: False
 #f not self.dialect.supports_alter
 #r constraint.name is None
 #lse None,
 #
 #
 #
 #xcept exc.CircularDependencyError as err2:
 #f not self.dialect.supports_alter:
 #til.warn(
 #Can't sort tables for DROP; an "
 #unresolvable foreign key "
 #dependency exists between tables: %s; and backend does "
 #not support ALTER.  To restore at least a partial sort, "
 #apply use_alter=True to ForeignKey and "
 #ForeignKeyConstraint "
 #objects involved in the cycle to mark these as known "
 #cycles that will be ignored."
 # (", ".join(sorted([t.fullname for t in err2.cycles])))
 #
 #ollection = [(t, ()) for t in unsorted_tables]
 #lse:
 #til.raise_(
 #xc.CircularDependencyError(
 #rr2.args[0],
 #rr2.cycles,
 #rr2.edges,
 #sg="Can't sort tables for DROP; an "
 #unresolvable foreign key "
 #dependency exists between tables: %s.  Please ensure "
 #that the ForeignKey and ForeignKeyConstraint objects "
 #involved in the cycle have "
 #names so that they can be dropped using "
 #DROP CONSTRAINT."
 # (
 #, ".join(
 #orted([t.fullname for t in err2.cycles])
 #
 #,
 #,
 #rom_=err2,
 #

 #eq_coll = [
 #
 #or s in metadata._sequences.values()
 #f self._can_drop_sequence(s)
 #

 #vent_collection = [t for (t, fks) in collection if t is not None]

 #etadata.dispatch.before_drop(
 #etadata,
 #elf.connection,
 #ables=event_collection,
 #heckfirst=self.checkfirst,
 #ddl_runner=self,
 #

 #or table, fkcs in collection:
 #f table is not None:
 #elf.traverse_single(
 #able,
 #rop_ok=True,
 #is_metadata_operation=True,
 #ignore_sequences=seq_coll,
 #
 #lse:
 #or fkc in fkcs:
 #elf.traverse_single(fkc)

 #or seq in seq_coll:
 #elf.traverse_single(seq, drop_ok=seq.column is None)

 #etadata.dispatch.after_drop(
 #etadata,
 #elf.connection,
 #ables=event_collection,
 #heckfirst=self.checkfirst,
 #ddl_runner=self,
 #

 #ef _can_drop_table(self, table):
 #elf.dialect.validate_identifier(table.name)
 #ffective_schema = self.connection.schema_for_object(table)
 #f effective_schema:
 #elf.dialect.validate_identifier(effective_schema)
 #eturn not self.checkfirst or self.dialect.has_table(
 #elf.connection, table.name, schema=effective_schema
 #

 #ef _can_drop_index(self, index):
 #ffective_schema = self.connection.schema_for_object(index.table)
 #f effective_schema:
 #elf.dialect.validate_identifier(effective_schema)
 #eturn not self.checkfirst or self.dialect.has_index(
 #elf.connection,
 #ndex.table.name,
 #ndex.name,
 #chema=effective_schema,
 #

 #ef _can_drop_sequence(self, sequence):
 #ffective_schema = self.connection.schema_for_object(sequence)
 #eturn self.dialect.supports_sequences and (
 #not self.dialect.sequences_optional or not sequence.optional)
 #nd (
 #ot self.checkfirst
 #r self.dialect.has_sequence(
 #elf.connection, sequence.name, schema=effective_schema
 #
 #
 #

 #ef visit_index(self, index, drop_ok=False):
 #f not drop_ok and not self._can_drop_index(index):
 #eturn

 #elf.connection.execute(DropIndex(index))

 #ef visit_table(
 #elf,
 #able,
 #rop_ok=False,
 #is_metadata_operation=False,
 #ignore_sequences=[],
 #:
 #f not drop_ok and not self._can_drop_table(table):
 #eturn

 #able.dispatch.before_drop(
 #able,
 #elf.connection,
 #heckfirst=self.checkfirst,
 #ddl_runner=self,
 #is_metadata_operation=_is_metadata_operation,
 #

 #elf.connection.execute(DropTable(table))

        # traverse client side defaults which may refer to server-side
        # sequences. noting that some of these client side defaults may also be
        # set up as server side defaults (see https://docs.sqlalchemy.org/en/
        # latest/core/defaults.html#associating-a-sequence-as-the-server-side-
        # default), so have to be dropped after the table is dropped.
 #or column in table.columns:
 #f (
 #olumn.default is not None
 #nd column.default not in _ignore_sequences
 #:
 #elf.traverse_single(column.default)

 #able.dispatch.after_drop(
 #able,
 #elf.connection,
 #heckfirst=self.checkfirst,
 #ddl_runner=self,
 #is_metadata_operation=_is_metadata_operation,
 #

 #ef visit_foreign_key_constraint(self, constraint):
 #f not self.dialect.supports_alter:
 #eturn
 #elf.connection.execute(DropConstraint(constraint))

 #ef visit_sequence(self, sequence, drop_ok=False):

 #f not drop_ok and not self._can_drop_sequence(sequence):
 #eturn
 #elf.connection.execute(DropSequence(sequence))


def sort_tables(
 #ables,
 #kip_fn=None,
 #xtra_dependencies=None,
):
 #""Sort a collection of :class:`_schema.Table` objects based on
 #ependency.

 #his is a dependency-ordered sort which will emit :class:`_schema.Table`
 #bjects such that they will follow their dependent :class:`_schema.Table`
 #bjects.
 #ables are dependent on another based on the presence of
 #class:`_schema.ForeignKeyConstraint`
 #bjects as well as explicit dependencies
 #dded by :meth:`_schema.Table.add_is_dependent_on`.

 #. warning::

 #he :func:`._schema.sort_tables` function cannot by itself
 #ccommodate automatic resolution of dependency cycles between
 #ables, which are usually caused by mutually dependent foreign key
 #onstraints. When these cycles are detected, the foreign keys
 #f these tables are omitted from consideration in the sort.
 # warning is emitted when this condition occurs, which will be an
 #xception raise in a future release.   Tables which are not part
 #f the cycle will still be returned in dependency order.

 #o resolve these cycles, the
 #paramref:`_schema.ForeignKeyConstraint.use_alter` parameter may be
 #pplied to those constraints which create a cycle.  Alternatively,
 #he :func:`_schema.sort_tables_and_constraints` function will
 #utomatically return foreign key constraints in a separate
 #ollection when cycles are detected so that they may be applied
 #o a schema separately.

 #. versionchanged:: 1.3.17 - a warning is emitted when
 #func:`_schema.sort_tables` cannot perform a proper sort due to
 #yclical dependencies.  This will be an exception in a future
 #elease.  Additionally, the sort will continue to return
 #ther tables not involved in the cycle in dependency order
 #hich was not the case previously.

 #param tables: a sequence of :class:`_schema.Table` objects.

 #param skip_fn: optional callable which will be passed a
 #class:`_schema.ForeignKey` object; if it returns True, this
 #onstraint will not be considered as a dependency.  Note this is
 #*different** from the same parameter in
 #func:`.sort_tables_and_constraints`, which is
 #nstead passed the owning :class:`_schema.ForeignKeyConstraint` object.

 #param extra_dependencies: a sequence of 2-tuples of tables which will
 #lso be considered as dependent on each other.

 #. seealso::

 #func:`.sort_tables_and_constraints`

 #attr:`_schema.MetaData.sorted_tables` - uses this function to sort


 #""

 #f skip_fn is not None:

 #ef _skip_fn(fkc):
 #or fk in fkc.elements:
 #f skip_fn(fk):
 #eturn True
 #lse:
 #eturn None

 #lse:
 #skip_fn = None

 #eturn [
 #
 #or (t, fkcs) in sort_tables_and_constraints(
 #ables,
 #ilter_fn=_skip_fn,
 #xtra_dependencies=extra_dependencies,
 #warn_for_cycles=True,
 #
 #f t is not None
 #


def sort_tables_and_constraints(
 #ables, filter_fn=None, extra_dependencies=None, _warn_for_cycles=False
):
 #""Sort a collection of :class:`_schema.Table`  /
 #class:`_schema.ForeignKeyConstraint`
 #bjects.

 #his is a dependency-ordered sort which will emit tuples of
 #`(Table, [ForeignKeyConstraint, ...])`` such that each
 #class:`_schema.Table` follows its dependent :class:`_schema.Table`
 #bjects.
 #emaining :class:`_schema.ForeignKeyConstraint`
 #bjects that are separate due to
 #ependency rules not satisfied by the sort are emitted afterwards
 #s ``(None, [ForeignKeyConstraint ...])``.

 #ables are dependent on another based on the presence of
 #class:`_schema.ForeignKeyConstraint` objects, explicit dependencies
 #dded by :meth:`_schema.Table.add_is_dependent_on`,
 #s well as dependencies
 #tated here using the :paramref:`~.sort_tables_and_constraints.skip_fn`
 #nd/or :paramref:`~.sort_tables_and_constraints.extra_dependencies`
 #arameters.

 #param tables: a sequence of :class:`_schema.Table` objects.

 #param filter_fn: optional callable which will be passed a
 #class:`_schema.ForeignKeyConstraint` object,
 #nd returns a value based on
 #hether this constraint should definitely be included or excluded as
 #n inline constraint, or neither.   If it returns False, the constraint
 #ill definitely be included as a dependency that cannot be subject
 #o ALTER; if True, it will **only** be included as an ALTER result at
 #he end.   Returning None means the constraint is included in the
 #able-based result unless it is detected as part of a dependency cycle.

 #param extra_dependencies: a sequence of 2-tuples of tables which will
 #lso be considered as dependent on each other.

 #. versionadded:: 1.0.0

 #. seealso::

 #func:`.sort_tables`


 #""

 #ixed_dependencies = set()
 #utable_dependencies = set()

 #f extra_dependencies is not None:
 #ixed_dependencies.update(extra_dependencies)

 #emaining_fkcs = set()
 #or table in tables:
 #or fkc in table.foreign_key_constraints:
 #f fkc.use_alter is True:
 #emaining_fkcs.add(fkc)
 #ontinue

 #f filter_fn:
 #iltered = filter_fn(fkc)

 #f filtered is True:
 #emaining_fkcs.add(fkc)
 #ontinue

 #ependent_on = fkc.referred_table
 #f dependent_on is not table:
 #utable_dependencies.add((dependent_on, table))

 #ixed_dependencies.update(
 #parent, table) for parent in table._extra_dependencies
 #

 #ry:
 #andidate_sort = list(
 #opological.sort(
 #ixed_dependencies.union(mutable_dependencies),
 #ables,
 #
 #
 #xcept exc.CircularDependencyError as err:
 #f _warn_for_cycles:
 #til.warn(
 #Cannot correctly sort tables; there are unresolvable cycles "
 #between tables "%s", which is usually caused by mutually '
 #dependent foreign key constraints.  Foreign key constraints "
 #involving these tables will not be considered; this warning "
 #may raise an error in a future release."
 # (", ".join(sorted(t.fullname for t in err.cycles)),)
 #
 #or edge in err.edges:
 #f edge in mutable_dependencies:
 #able = edge[1]
 #f table not in err.cycles:
 #ontinue
 #an_remove = [
 #kc
 #or fkc in table.foreign_key_constraints
 #f filter_fn is None or filter_fn(fkc) is not False
 #
 #emaining_fkcs.update(can_remove)
 #or fkc in can_remove:
 #ependent_on = fkc.referred_table
 #f dependent_on is not table:
 #utable_dependencies.discard((dependent_on, table))
 #andidate_sort = list(
 #opological.sort(
 #ixed_dependencies.union(mutable_dependencies),
 #ables,
 #
 #

 #eturn [
 #table, table.foreign_key_constraints.difference(remaining_fkcs))
 #or table in candidate_sort
 # + [(None, list(remaining_fkcs))]
