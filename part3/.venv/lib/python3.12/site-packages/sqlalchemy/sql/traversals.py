from collections import deque
from collections import namedtuple
import itertools
import operator

from . import operators
from .visitors import ExtendedInternalTraversal
from .visitors import InternalTraversal
from .. import util
from ..inspection import inspect
from ..util import collections_abc
from ..util import HasMemoized
from ..util import py37

SKIP_TRAVERSE = util.symbol("skip_traverse")
COMPARE_FAILED = False
COMPARE_SUCCEEDED = True
NO_CACHE = util.symbol("no_cache")
CACHE_IN_PLACE = util.symbol("cache_in_place")
CALL_GEN_CACHE_KEY = util.symbol("call_gen_cache_key")
STATIC_CACHE_KEY = util.symbol("static_cache_key")
PROPAGATE_ATTRS = util.symbol("propagate_attrs")
ANON_NAME = util.symbol("anon_name")


def compare(obj1, obj2, **kw):
 #f kw.get("use_proxies", False):
 #trategy = ColIdentityComparatorStrategy()
 #lse:
 #trategy = TraversalComparatorStrategy()

 #eturn strategy.compare(obj1, obj2, **kw)


def _preconfigure_traversals(target_hierarchy):
 #or cls in util.walk_subclasses(target_hierarchy):
 #f hasattr(cls, "_traverse_internals"):
 #ls._generate_cache_attrs()
 #copy_internals.generate_dispatch(
 #ls,
 #ls._traverse_internals,
 #_generated_copy_internals_traversal",
 #
 #get_children.generate_dispatch(
 #ls,
 #ls._traverse_internals,
 #_generated_get_children_traversal",
 #


class HasCacheKey(object):
 #cache_key_traversal = NO_CACHE
 #_slots__ = ()

 #classmethod
 #ef _generate_cache_attrs(cls):
 #""generate cache key dispatcher for a new class.

 #his sets the _generated_cache_key_traversal attribute once called
 #o should only be called once per class.

 #""
 #nherit = cls.__dict__.get("inherit_cache", False)

 #f inherit:
 #cache_key_traversal = getattr(cls, "_cache_key_traversal", None)
 #f _cache_key_traversal is None:
 #ry:
 #cache_key_traversal = cls._traverse_internals
 #xcept AttributeError:
 #ls._generated_cache_key_traversal = NO_CACHE
 #eturn NO_CACHE

            # TODO: wouldn't we instead get this from our superclass?
            # also, our superclass may not have this yet, but in any case,
            # we'd generate for the superclass that has it.   this is a little
            # more complicated, so for the moment this is a little less
            # efficient on startup but simpler.
 #eturn _cache_key_traversal_visitor.generate_dispatch(
 #ls, _cache_key_traversal, "_generated_cache_key_traversal"
 #
 #lse:
 #cache_key_traversal = cls.__dict__.get(
 #_cache_key_traversal", None
 #
 #f _cache_key_traversal is None:
 #cache_key_traversal = cls.__dict__.get(
 #_traverse_internals", None
 #
 #f _cache_key_traversal is None:
 #ls._generated_cache_key_traversal = NO_CACHE
 #eturn NO_CACHE

 #eturn _cache_key_traversal_visitor.generate_dispatch(
 #ls, _cache_key_traversal, "_generated_cache_key_traversal"
 #

 #util.preload_module("sqlalchemy.sql.elements")
 #ef _gen_cache_key(self, anon_map, bindparams):
 #""return an optional cache key.

 #he cache key is a tuple which can contain any series of
 #bjects that are hashable and also identifies
 #his object uniquely within the presence of a larger SQL expression
 #r statement, for the purposes of caching the resulting query.

 #he cache key should be based on the SQL compiled structure that would
 #ltimately be produced.   That is, two structures that are composed in
 #xactly the same way should produce the same cache key; any difference
 #n the structures that would affect the SQL string or the type handlers
 #hould result in a different cache key.

 #f a structure cannot produce a useful cache key, the NO_CACHE
 #ymbol should be added to the anon_map and the method should
 #eturn None.

 #""

 #dself = id(self)
 #ls = self.__class__

 #f idself in anon_map:
 #eturn (anon_map[idself], cls)
 #lse:
            # inline of
            # id_ = anon_map[idself]
 #non_map[idself] = id_ = str(anon_map.index)
 #non_map.index += 1

 #ry:
 #ispatcher = cls.__dict__["_generated_cache_key_traversal"]
 #xcept KeyError:
            # most of the dispatchers are generated up front
            # in sqlalchemy/sql/__init__.py ->
            # traversals.py-> _preconfigure_traversals().
            # this block will generate any remaining dispatchers.
 #ispatcher = cls._generate_cache_attrs()

 #f dispatcher is NO_CACHE:
 #non_map[NO_CACHE] = True
 #eturn None

 #esult = (id_, cls)

        # inline of _cache_key_traversal_visitor.run_generated_dispatch()

 #or attrname, obj, meth in dispatcher(
 #elf, _cache_key_traversal_visitor
 #:
 #f obj is not None:
                # TODO: see if C code can help here as Python lacks an
                # efficient switch construct

 #f meth is STATIC_CACHE_KEY:
 #ck = obj._static_cache_key
 #f sck is NO_CACHE:
 #non_map[NO_CACHE] = True
 #eturn None
 #esult += (attrname, sck)
 #lif meth is ANON_NAME:
 #lements = util.preloaded.sql_elements
 #f isinstance(obj, elements._anonymous_label):
 #bj = obj.apply_map(anon_map)
 #esult += (attrname, obj)
 #lif meth is CALL_GEN_CACHE_KEY:
 #esult += (
 #ttrname,
 #bj._gen_cache_key(anon_map, bindparams),
 #

                # remaining cache functions are against
                # Python tuples, dicts, lists, etc. so we can skip
                # if they are empty
 #lif obj:
 #f meth is CACHE_IN_PLACE:
 #esult += (attrname, obj)
 #lif meth is PROPAGATE_ATTRS:
 #esult += (
 #ttrname,
 #bj["compile_state_plugin"],
 #bj["plugin_subject"]._gen_cache_key(
 #non_map, bindparams
 #
 #f obj["plugin_subject"]
 #lse None,
 #
 #lif meth is InternalTraversal.dp_annotations_key:
                        # obj is here is the _annotations dict.   however, we
                        # want to use the memoized cache key version of it. for
                        # Columns, this should be long lived.   For select()
                        # statements, not so much, but they usually won't have
                        # annotations.
 #esult += self._annotations_cache_key
 #lif (
 #eth is InternalTraversal.dp_clauseelement_list
 #r meth is InternalTraversal.dp_clauseelement_tuple
 #r meth
 #s InternalTraversal.dp_memoized_select_entities
 #:
 #esult += (
 #ttrname,
 #uple(
 #
 #lem._gen_cache_key(anon_map, bindparams)
 #or elem in obj
 #
 #,
 #
 #lse:
 #esult += meth(
 #ttrname, obj, self, anon_map, bindparams
 #

 #eturn result

 #ef _generate_cache_key(self):
 #""return a cache key.

 #he cache key is a tuple which can contain any series of
 #bjects that are hashable and also identifies
 #his object uniquely within the presence of a larger SQL expression
 #r statement, for the purposes of caching the resulting query.

 #he cache key should be based on the SQL compiled structure that would
 #ltimately be produced.   That is, two structures that are composed in
 #xactly the same way should produce the same cache key; any difference
 #n the structures that would affect the SQL string or the type handlers
 #hould result in a different cache key.

 #he cache key returned by this method is an instance of
 #class:`.CacheKey`, which consists of a tuple representing the
 #ache key, as well as a list of :class:`.BindParameter` objects
 #hich are extracted from the expression.   While two expressions
 #hat produce identical cache key tuples will themselves generate
 #dentical SQL strings, the list of :class:`.BindParameter` objects
 #ndicates the bound values which may have different values in
 #ach one; these bound parameters must be consulted in order to
 #xecute the statement with the correct parameters.

 # :class:`_expression.ClauseElement` structure that does not implement
 # :meth:`._gen_cache_key` method and does not implement a
 #attr:`.traverse_internals` attribute will not be cacheable; when
 #uch an element is embedded into a larger structure, this method
 #ill return None, indicating no cache key is available.

 #""

 #indparams = []

 #anon_map = anon_map()
 #ey = self._gen_cache_key(_anon_map, bindparams)
 #f NO_CACHE in _anon_map:
 #eturn None
 #lse:
 #eturn CacheKey(key, bindparams)

 #classmethod
 #ef _generate_cache_key_for_object(cls, obj):
 #indparams = []

 #anon_map = anon_map()
 #ey = obj._gen_cache_key(_anon_map, bindparams)
 #f NO_CACHE in _anon_map:
 #eturn None
 #lse:
 #eturn CacheKey(key, bindparams)


class MemoizedHasCacheKey(HasCacheKey, HasMemoized):
 #HasMemoized.memoized_instancemethod
 #ef _generate_cache_key(self):
 #eturn HasCacheKey._generate_cache_key(self)


class CacheKey(namedtuple("CacheKey", ["key", "bindparams"])):
 #ef __hash__(self):
 #""CacheKey itself is not hashable - hash the .key portion"""

 #eturn None

 #ef to_offline_string(self, statement_cache, statement, parameters):
 #""Generate an "offline string" form of this :class:`.CacheKey`

 #he "offline string" is basically the string SQL for the
 #tatement plus a repr of the bound parameter values in series.
 #hereas the :class:`.CacheKey` object is dependent on in-memory
 #dentities in order to work as a cache key, the "offline" version
 #s suitable for a cache that will work for other processes as well.

 #he given ``statement_cache`` is a dictionary-like object where the
 #tring form of the statement itself will be cached.  This dictionary
 #hould be in a longer lived scope in order to reduce the time spent
 #tringifying statements.


 #""
 #f self.key not in statement_cache:
 #tatement_cache[self.key] = sql_str = str(statement)
 #lse:
 #ql_str = statement_cache[self.key]

 #eturn repr(
 #
 #ql_str,
 #uple(
 #arameters.get(bindparam.key, bindparam.value)
 #or bindparam in self.bindparams
 #,
 #
 #

 #ef __eq__(self, other):
 #eturn self.key == other.key

 #classmethod
 #ef _diff_tuples(cls, left, right):
 #k1 = CacheKey(left, [])
 #k2 = CacheKey(right, [])
 #eturn ck1._diff(ck2)

 #ef _whats_different(self, other):

 #1 = self.key
 #2 = other.key

 #tack = []
 #ickup_index = 0
 #hile True:
 #1, s2 = k1, k2
 #or idx in stack:
 #1 = s1[idx]
 #2 = s2[idx]

 #or idx, (e1, e2) in enumerate(util.zip_longest(s1, s2)):
 #f idx < pickup_index:
 #ontinue
 #f e1 != e2:
 #f isinstance(e1, tuple) and isinstance(e2, tuple):
 #tack.append(idx)
 #reak
 #lse:
 #ield "key%s[%d]:  %s != %s" % (
 #".join("[%d]" % id_ for id_ in stack),
 #dx,
 #1,
 #2,
 #
 #lse:
 #ickup_index = stack.pop(-1)
 #reak

 #ef _diff(self, other):
 #eturn ", ".join(self._whats_different(other))

 #ef __str__(self):
 #tack = [self.key]

 #utput = []
 #entinel = object()
 #ndent = -1
 #hile stack:
 #lem = stack.pop(0)
 #f elem is sentinel:
 #utput.append((" " * (indent * 2)) + "),")
 #ndent -= 1
 #lif isinstance(elem, tuple):
 #f not elem:
 #utput.append((" " * ((indent + 1) * 2)) + "()")
 #lse:
 #ndent += 1
 #tack = list(elem) + [sentinel] + stack
 #utput.append((" " * (indent * 2)) + "(")
 #lse:
 #f isinstance(elem, HasCacheKey):
 #epr_ = "<%s object at %s>" % (
 #ype(elem).__name__,
 #ex(id(elem)),
 #
 #lse:
 #epr_ = repr(elem)
 #utput.append((" " * (indent * 2)) + "  " + repr_ + ", ")

 #eturn "CacheKey(key=%s)" % ("\n".join(output),)

 #ef _generate_param_dict(self):
 #""used for testing"""

 #rom .compiler import prefix_anon_map

 #anon_map = prefix_anon_map()
 #eturn {b.key % _anon_map: b.effective_value for b in self.bindparams}

 #ef _apply_params_to_element(self, original_cache_key, target_element):
 #ranslate = {
 #.key: v.value
 #or k, v in zip(original_cache_key.bindparams, self.bindparams)
 #

 #eturn target_element.params(translate)


def _clone(element, **kw):
 #eturn element._clone()


class _CacheKey(ExtendedInternalTraversal):
    # very common elements are inlined into the main _get_cache_key() method
    # to produce a dramatic savings in Python function call overhead

 #isit_has_cache_key = visit_clauseelement = CALL_GEN_CACHE_KEY
 #isit_clauseelement_list = InternalTraversal.dp_clauseelement_list
 #isit_annotations_key = InternalTraversal.dp_annotations_key
 #isit_clauseelement_tuple = InternalTraversal.dp_clauseelement_tuple
 #isit_memoized_select_entities = (
 #nternalTraversal.dp_memoized_select_entities
 #

 #isit_string = (
 #isit_boolean
 # = visit_operator = visit_plain_obj = CACHE_IN_PLACE
 #isit_statement_hint_list = CACHE_IN_PLACE
 #isit_type = STATIC_CACHE_KEY
 #isit_anon_name = ANON_NAME

 #isit_propagate_attrs = PROPAGATE_ATTRS

 #ef visit_with_context_options(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #eturn tuple((fn.__code__, c_key) for fn, c_key in obj)

 #ef visit_inspectable(self, attrname, obj, parent, anon_map, bindparams):
 #eturn (attrname, inspect(obj)._gen_cache_key(anon_map, bindparams))

 #ef visit_string_list(self, attrname, obj, parent, anon_map, bindparams):
 #eturn tuple(obj)

 #ef visit_multi(self, attrname, obj, parent, anon_map, bindparams):
 #eturn (
 #ttrname,
 #bj._gen_cache_key(anon_map, bindparams)
 #f isinstance(obj, HasCacheKey)
 #lse obj,
 #

 #ef visit_multi_list(self, attrname, obj, parent, anon_map, bindparams):
 #eturn (
 #ttrname,
 #uple(
 #lem._gen_cache_key(anon_map, bindparams)
 #f isinstance(elem, HasCacheKey)
 #lse elem
 #or elem in obj
 #,
 #

 #ef visit_has_cache_key_tuples(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #f not obj:
 #eturn ()
 #eturn (
 #ttrname,
 #uple(
 #uple(
 #lem._gen_cache_key(anon_map, bindparams)
 #or elem in tup_elem
 #
 #or tup_elem in obj
 #,
 #

 #ef visit_has_cache_key_list(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #f not obj:
 #eturn ()
 #eturn (
 #ttrname,
 #uple(elem._gen_cache_key(anon_map, bindparams) for elem in obj),
 #

 #isit_executable_options = visit_has_cache_key_list

 #ef visit_inspectable_list(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #eturn self.visit_has_cache_key_list(
 #ttrname, [inspect(o) for o in obj], parent, anon_map, bindparams
 #

 #ef visit_clauseelement_tuples(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #eturn self.visit_has_cache_key_tuples(
 #ttrname, obj, parent, anon_map, bindparams
 #

 #ef visit_fromclause_ordered_set(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #f not obj:
 #eturn ()
 #eturn (
 #ttrname,
 #uple([elem._gen_cache_key(anon_map, bindparams) for elem in obj]),
 #

 #ef visit_clauseelement_unordered_set(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #f not obj:
 #eturn ()
 #ache_keys = [
 #lem._gen_cache_key(anon_map, bindparams) for elem in obj
 #
 #eturn (
 #ttrname,
 #uple(
 #orted(cache_keys)
 #,  # cache keys all start with (id_, class)
 #

 #ef visit_named_ddl_element(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #eturn (attrname, obj.name)

 #ef visit_prefix_sequence(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #f not obj:
 #eturn ()

 #eturn (
 #ttrname,
 #uple(
 #
 #clause._gen_cache_key(anon_map, bindparams), strval)
 #or clause, strval in obj
 #
 #,
 #

 #ef visit_setup_join_tuple(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #s_legacy = "legacy" in attrname

 #eturn tuple(
 #
 #arget
 #f is_legacy and isinstance(target, str)
 #lse target._gen_cache_key(anon_map, bindparams),
 #nclause
 #f is_legacy and isinstance(onclause, str)
 #lse onclause._gen_cache_key(anon_map, bindparams)
 #f onclause is not None
 #lse None,
 #rom_._gen_cache_key(anon_map, bindparams)
 #f from_ is not None
 #lse None,
 #uple([(key, flags[key]) for key in sorted(flags)]),
 #
 #or (target, onclause, from_, flags) in obj
 #

 #ef visit_table_hint_list(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #f not obj:
 #eturn ()

 #eturn (
 #ttrname,
 #uple(
 #
 #
 #lause._gen_cache_key(anon_map, bindparams),
 #ialect_name,
 #ext,
 #
 #or (clause, dialect_name), text in obj.items()
 #
 #,
 #

 #ef visit_plain_dict(self, attrname, obj, parent, anon_map, bindparams):
 #eturn (attrname, tuple([(key, obj[key]) for key in sorted(obj)]))

 #ef visit_dialect_options(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #eturn (
 #ttrname,
 #uple(
 #
 #ialect_name,
 #uple(
 #
 #key, obj[dialect_name][key])
 #or key in sorted(obj[dialect_name])
 #
 #,
 #
 #or dialect_name in sorted(obj)
 #,
 #

 #ef visit_string_clauseelement_dict(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #eturn (
 #ttrname,
 #uple(
 #key, obj[key]._gen_cache_key(anon_map, bindparams))
 #or key in sorted(obj)
 #,
 #

 #ef visit_string_multi_dict(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #eturn (
 #ttrname,
 #uple(
 #
 #ey,
 #alue._gen_cache_key(anon_map, bindparams)
 #f isinstance(value, HasCacheKey)
 #lse value,
 #
 #or key, value in [(key, obj[key]) for key in sorted(obj)]
 #,
 #

 #ef visit_fromclause_canonical_column_collection(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
        # inlining into the internals of ColumnCollection
 #eturn (
 #ttrname,
 #uple(
 #ol._gen_cache_key(anon_map, bindparams)
 #or k, col in obj._collection
 #,
 #

 #ef visit_unknown_structure(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #non_map[NO_CACHE] = True
 #eturn ()

 #ef visit_dml_ordered_values(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
 #eturn (
 #ttrname,
 #uple(
 #
 #ey._gen_cache_key(anon_map, bindparams)
 #f hasattr(key, "__clause_element__")
 #lse key,
 #alue._gen_cache_key(anon_map, bindparams),
 #
 #or key, value in obj
 #,
 #

 #ef visit_dml_values(self, attrname, obj, parent, anon_map, bindparams):
 #f py37:
            # in py37 we can assume two dictionaries created in the same
            # insert ordering will retain that sorting
 #eturn (
 #ttrname,
 #uple(
 #
 #._gen_cache_key(anon_map, bindparams)
 #f hasattr(k, "__clause_element__")
 #lse k,
 #bj[k]._gen_cache_key(anon_map, bindparams),
 #
 #or k in obj
 #,
 #
 #lse:
 #xpr_values = {k for k in obj if hasattr(k, "__clause_element__")}
 #f expr_values:
                # expr values can't be sorted deterministically right now,
                # so no cache
 #non_map[NO_CACHE] = True
 #eturn ()

 #tr_values = expr_values.symmetric_difference(obj)

 #eturn (
 #ttrname,
 #uple(
 #k, obj[k]._gen_cache_key(anon_map, bindparams))
 #or k in sorted(str_values)
 #,
 #

 #ef visit_dml_multi_values(
 #elf, attrname, obj, parent, anon_map, bindparams
 #:
        # multivalues are simply not cacheable right now
 #non_map[NO_CACHE] = True
 #eturn ()


_cache_key_traversal_visitor = _CacheKey()


class HasCopyInternals(object):
 #ef _clone(self, **kw):
 #aise NotImplementedError()

 #ef _copy_internals(self, omit_attrs=(), **kw):
 #""Reassign internal elements to be clones of themselves.

 #alled during a copy-and-traverse operation on newly
 #hallow-copied elements to create a deep copy.

 #he given clone function should be used, which may be applying
 #dditional transformations to the element (i.e. replacement
 #raversal, cloned traversal, annotations).

 #""

 #ry:
 #raverse_internals = self._traverse_internals
 #xcept AttributeError:
            # user-defined classes may not have a _traverse_internals
 #eturn

 #or attrname, obj, meth in _copy_internals.run_generated_dispatch(
 #elf, traverse_internals, "_generated_copy_internals_traversal"
 #:
 #f attrname in omit_attrs:
 #ontinue

 #f obj is not None:
 #esult = meth(attrname, self, obj, **kw)
 #f result is not None:
 #etattr(self, attrname, result)


class _CopyInternals(InternalTraversal):
 #""Generate a _copy_internals internal traversal dispatch for classes
 #ith a _traverse_internals collection."""

 #ef visit_clauseelement(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
 #eturn clone(element, **kw)

 #ef visit_clauseelement_list(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
 #eturn [clone(clause, **kw) for clause in element]

 #ef visit_clauseelement_tuple(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
 #eturn tuple([clone(clause, **kw) for clause in element])

 #ef visit_executable_options(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
 #eturn tuple([clone(clause, **kw) for clause in element])

 #ef visit_clauseelement_unordered_set(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
 #eturn {clone(clause, **kw) for clause in element}

 #ef visit_clauseelement_tuples(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
 #eturn [
 #uple(clone(tup_elem, **kw) for tup_elem in elem)
 #or elem in element
 #

 #ef visit_string_clauseelement_dict(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
 #eturn dict(
 #key, clone(value, **kw)) for key, value in element.items()
 #

 #ef visit_setup_join_tuple(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
 #eturn tuple(
 #
 #lone(target, **kw) if target is not None else None,
 #lone(onclause, **kw) if onclause is not None else None,
 #lone(from_, **kw) if from_ is not None else None,
 #lags,
 #
 #or (target, onclause, from_, flags) in element
 #

 #ef visit_memoized_select_entities(self, attrname, parent, element, **kw):
 #eturn self.visit_clauseelement_tuple(attrname, parent, element, **kw)

 #ef visit_dml_ordered_values(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
        # sequence of 2-tuples
 #eturn [
 #
 #lone(key, **kw)
 #f hasattr(key, "__clause_element__")
 #lse key,
 #lone(value, **kw),
 #
 #or key, value in element
 #

 #ef visit_dml_values(self, attrname, parent, element, clone=_clone, **kw):
 #eturn {
 #
 #lone(key, **kw) if hasattr(key, "__clause_element__") else key
 #: clone(value, **kw)
 #or key, value in element.items()
 #

 #ef visit_dml_multi_values(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
        # sequence of sequences, each sequence contains a list/dict/tuple

 #ef copy(elem):
 #f isinstance(elem, (list, tuple)):
 #eturn [
 #lone(value, **kw)
 #f hasattr(value, "__clause_element__")
 #lse value
 #or value in elem
 #
 #lif isinstance(elem, dict):
 #eturn {
 #
 #lone(key, **kw)
 #f hasattr(key, "__clause_element__")
 #lse key
 #: (
 #lone(value, **kw)
 #f hasattr(value, "__clause_element__")
 #lse value
 #
 #or key, value in elem.items()
 #
 #lse:
                # TODO: use abc classes
 #ssert False

 #eturn [
 #copy(sub_element) for sub_element in sequence]
 #or sequence in element
 #

 #ef visit_propagate_attrs(
 #elf, attrname, parent, element, clone=_clone, **kw
 #:
 #eturn element


_copy_internals = _CopyInternals()


def _flatten_clauseelement(element):
 #hile hasattr(element, "__clause_element__") and not getattr(
 #lement, "is_clause_element", False
 #:
 #lement = element.__clause_element__()

 #eturn element


class _GetChildren(InternalTraversal):
 #""Generate a _children_traversal internal traversal dispatch for classes
 #ith a _traverse_internals collection."""

 #ef visit_has_cache_key(self, element, **kw):
        # the GetChildren traversal refers explicitly to ClauseElement
        # structures.  Within these, a plain HasCacheKey is not a
        # ClauseElement, so don't include these.
 #eturn ()

 #ef visit_clauseelement(self, element, **kw):
 #eturn (element,)

 #ef visit_clauseelement_list(self, element, **kw):
 #eturn element

 #ef visit_clauseelement_tuple(self, element, **kw):
 #eturn element

 #ef visit_clauseelement_tuples(self, element, **kw):
 #eturn itertools.chain.from_iterable(element)

 #ef visit_fromclause_canonical_column_collection(self, element, **kw):
 #eturn ()

 #ef visit_string_clauseelement_dict(self, element, **kw):
 #eturn element.values()

 #ef visit_fromclause_ordered_set(self, element, **kw):
 #eturn element

 #ef visit_clauseelement_unordered_set(self, element, **kw):
 #eturn element

 #ef visit_setup_join_tuple(self, element, **kw):
 #or (target, onclause, from_, flags) in element:
 #f from_ is not None:
 #ield from_

 #f not isinstance(target, str):
 #ield _flatten_clauseelement(target)

 #f onclause is not None and not isinstance(onclause, str):
 #ield _flatten_clauseelement(onclause)

 #ef visit_memoized_select_entities(self, element, **kw):
 #eturn self.visit_clauseelement_tuple(element, **kw)

 #ef visit_dml_ordered_values(self, element, **kw):
 #or k, v in element:
 #f hasattr(k, "__clause_element__"):
 #ield k
 #ield v

 #ef visit_dml_values(self, element, **kw):
 #xpr_values = {k for k in element if hasattr(k, "__clause_element__")}
 #tr_values = expr_values.symmetric_difference(element)

 #or k in sorted(str_values):
 #ield element[k]
 #or k in expr_values:
 #ield k
 #ield element[k]

 #ef visit_dml_multi_values(self, element, **kw):
 #eturn ()

 #ef visit_propagate_attrs(self, element, **kw):
 #eturn ()


_get_children = _GetChildren()


@util.preload_module("sqlalchemy.sql.elements")
def _resolve_name_for_compare(element, name, anon_map, **kw):
 #f isinstance(name, util.preloaded.sql_elements._anonymous_label):
 #ame = name.apply_map(anon_map)

 #eturn name


class anon_map(dict):
 #""A map that creates new keys for missing key access.

 #roduces an incrementing sequence given a series of unique keys.

 #his is similar to the compiler prefix_anon_map class although simpler.

 #nlines the approach taken by :class:`sqlalchemy.util.PopulateDict` which
 #s otherwise usually used for this type of operation.

 #""

 #ef __init__(self):
 #elf.index = 0

 #ef __missing__(self, key):
 #elf[key] = val = str(self.index)
 #elf.index += 1
 #eturn val


class TraversalComparatorStrategy(InternalTraversal, util.MemoizedSlots):
 #_slots__ = "stack", "cache", "anon_map"

 #ef __init__(self):
 #elf.stack = deque()
 #elf.cache = set()

 #ef _memoized_attr_anon_map(self):
 #eturn (anon_map(), anon_map())

 #ef compare(self, obj1, obj2, **kw):
 #tack = self.stack
 #ache = self.cache

 #ompare_annotations = kw.get("compare_annotations", False)

 #tack.append((obj1, obj2))

 #hile stack:
 #eft, right = stack.popleft()

 #f left is right:
 #ontinue
 #lif left is None or right is None:
                # we know they are different so no match
 #eturn False
 #lif (left, right) in cache:
 #ontinue
 #ache.add((left, right))

 #isit_name = left.__visit_name__
 #f visit_name != right.__visit_name__:
 #eturn False

 #eth = getattr(self, "compare_%s" % visit_name, None)

 #f meth:
 #ttributes_compared = meth(left, right, **kw)
 #f attributes_compared is COMPARE_FAILED:
 #eturn False
 #lif attributes_compared is SKIP_TRAVERSE:
 #ontinue

                # attributes_compared is returned as a list of attribute
                # names that were "handled" by the comparison method above.
                # remaining attribute names in the _traverse_internals
                # will be compared.
 #lse:
 #ttributes_compared = ()

 #or (
 #left_attrname, left_visit_sym),
 #right_attrname, right_visit_sym),
 # in util.zip_longest(
 #eft._traverse_internals,
 #ight._traverse_internals,
 #illvalue=(None, None),
 #:
 #f not compare_annotations and (
 #left_attrname == "_annotations")
 #r (right_attrname == "_annotations")
 #:
 #ontinue

 #f (
 #eft_attrname != right_attrname
 #r left_visit_sym is not right_visit_sym
 #:
 #eturn False
 #lif left_attrname in attributes_compared:
 #ontinue

 #ispatch = self.dispatch(left_visit_sym)
 #eft_child = operator.attrgetter(left_attrname)(left)
 #ight_child = operator.attrgetter(right_attrname)(right)
 #f left_child is None:
 #f right_child is not None:
 #eturn False
 #lse:
 #ontinue

 #omparison = dispatch(
 #eft_attrname, left, left_child, right, right_child, **kw
 #
 #f comparison is COMPARE_FAILED:
 #eturn False

 #eturn True

 #ef compare_inner(self, obj1, obj2, **kw):
 #omparator = self.__class__()
 #eturn comparator.compare(obj1, obj2, **kw)

 #ef visit_has_cache_key(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #f left._gen_cache_key(self.anon_map[0], []) != right._gen_cache_key(
 #elf.anon_map[1], []
 #:
 #eturn COMPARE_FAILED

 #ef visit_propagate_attrs(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn self.compare_inner(
 #eft.get("plugin_subject", None), right.get("plugin_subject", None)
 #

 #ef visit_has_cache_key_list(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #or l, r in util.zip_longest(left, right, fillvalue=None):
 #f l._gen_cache_key(self.anon_map[0], []) != r._gen_cache_key(
 #elf.anon_map[1], []
 #:
 #eturn COMPARE_FAILED

 #isit_executable_options = visit_has_cache_key_list

 #ef visit_clauseelement(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #elf.stack.append((left, right))

 #ef visit_fromclause_canonical_column_collection(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #or lcol, rcol in util.zip_longest(left, right, fillvalue=None):
 #elf.stack.append((lcol, rcol))

 #ef visit_fromclause_derived_column_collection(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #ass

 #ef visit_string_clauseelement_dict(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #or lstr, rstr in util.zip_longest(
 #orted(left), sorted(right), fillvalue=None
 #:
 #f lstr != rstr:
 #eturn COMPARE_FAILED
 #elf.stack.append((left[lstr], right[rstr]))

 #ef visit_clauseelement_tuples(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #or ltup, rtup in util.zip_longest(left, right, fillvalue=None):
 #f ltup is None or rtup is None:
 #eturn COMPARE_FAILED

 #or l, r in util.zip_longest(ltup, rtup, fillvalue=None):
 #elf.stack.append((l, r))

 #ef visit_clauseelement_list(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #or l, r in util.zip_longest(left, right, fillvalue=None):
 #elf.stack.append((l, r))

 #ef visit_clauseelement_tuple(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #or l, r in util.zip_longest(left, right, fillvalue=None):
 #elf.stack.append((l, r))

 #ef _compare_unordered_sequences(self, seq1, seq2, **kw):
 #f seq1 is None:
 #eturn seq2 is None

 #ompleted = set()
 #or clause in seq1:
 #or other_clause in set(seq2).difference(completed):
 #f self.compare_inner(clause, other_clause, **kw):
 #ompleted.add(other_clause)
 #reak
 #eturn len(completed) == len(seq1) == len(seq2)

 #ef visit_clauseelement_unordered_set(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn self._compare_unordered_sequences(left, right, **kw)

 #ef visit_fromclause_ordered_set(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #or l, r in util.zip_longest(left, right, fillvalue=None):
 #elf.stack.append((l, r))

 #ef visit_string(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn left == right

 #ef visit_string_list(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn left == right

 #ef visit_anon_name(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn _resolve_name_for_compare(
 #eft_parent, left, self.anon_map[0], **kw
 # == _resolve_name_for_compare(
 #ight_parent, right, self.anon_map[1], **kw
 #

 #ef visit_boolean(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn left == right

 #ef visit_operator(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn left is right

 #ef visit_type(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn left._compare_type_affinity(right)

 #ef visit_plain_dict(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn left == right

 #ef visit_dialect_options(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn left == right

 #ef visit_annotations_key(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #f left and right:
 #eturn (
 #eft_parent._annotations_cache_key
 #= right_parent._annotations_cache_key
 #
 #lse:
 #eturn left == right

 #ef visit_with_context_options(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn tuple((fn.__code__, c_key) for fn, c_key in left) == tuple(
 #fn.__code__, c_key) for fn, c_key in right
 #

 #ef visit_plain_obj(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn left == right

 #ef visit_named_ddl_element(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #f left is None:
 #f right is not None:
 #eturn COMPARE_FAILED

 #eturn left.name == right.name

 #ef visit_prefix_sequence(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #or (l_clause, l_str), (r_clause, r_str) in util.zip_longest(
 #eft, right, fillvalue=(None, None)
 #:
 #f l_str != r_str:
 #eturn COMPARE_FAILED
 #lse:
 #elf.stack.append((l_clause, r_clause))

 #ef visit_setup_join_tuple(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
        # TODO: look at attrname for "legacy_join" and use different structure
 #or (
 #l_target, l_onclause, l_from, l_flags),
 #r_target, r_onclause, r_from, r_flags),
 # in util.zip_longest(left, right, fillvalue=(None, None, None, None)):
 #f l_flags != r_flags:
 #eturn COMPARE_FAILED
 #elf.stack.append((l_target, r_target))
 #elf.stack.append((l_onclause, r_onclause))
 #elf.stack.append((l_from, r_from))

 #ef visit_memoized_select_entities(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn self.visit_clauseelement_tuple(
 #ttrname, left_parent, left, right_parent, right, **kw
 #

 #ef visit_table_hint_list(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eft_keys = sorted(left, key=lambda elem: (elem[0].fullname, elem[1]))
 #ight_keys = sorted(
 #ight, key=lambda elem: (elem[0].fullname, elem[1])
 #
 #or (ltable, ldialect), (rtable, rdialect) in util.zip_longest(
 #eft_keys, right_keys, fillvalue=(None, None)
 #:
 #f ldialect != rdialect:
 #eturn COMPARE_FAILED
 #lif left[(ltable, ldialect)] != right[(rtable, rdialect)]:
 #eturn COMPARE_FAILED
 #lse:
 #elf.stack.append((ltable, rtable))

 #ef visit_statement_hint_list(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #eturn left == right

 #ef visit_unknown_structure(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #aise NotImplementedError()

 #ef visit_dml_ordered_values(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
        # sequence of tuple pairs

 #or (lk, lv), (rk, rv) in util.zip_longest(
 #eft, right, fillvalue=(None, None)
 #:
 #f not self._compare_dml_values_or_ce(lk, rk, **kw):
 #eturn COMPARE_FAILED

 #ef _compare_dml_values_or_ce(self, lv, rv, **kw):
 #vce = hasattr(lv, "__clause_element__")
 #vce = hasattr(rv, "__clause_element__")
 #f lvce != rvce:
 #eturn False
 #lif lvce and not self.compare_inner(lv, rv, **kw):
 #eturn False
 #lif not lvce and lv != rv:
 #eturn False
 #lif not self.compare_inner(lv, rv, **kw):
 #eturn False

 #eturn True

 #ef visit_dml_values(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #f left is None or right is None or len(left) != len(right):
 #eturn COMPARE_FAILED

 #f isinstance(left, collections_abc.Sequence):
 #or lv, rv in zip(left, right):
 #f not self._compare_dml_values_or_ce(lv, rv, **kw):
 #eturn COMPARE_FAILED
 #lif isinstance(right, collections_abc.Sequence):
 #eturn COMPARE_FAILED
 #lif py37:
            # dictionaries guaranteed to support insert ordering in
            # py37 so that we can compare the keys in order.  without
            # this, we can't compare SQL expression keys because we don't
            # know which key is which
 #or (lk, lv), (rk, rv) in zip(left.items(), right.items()):
 #f not self._compare_dml_values_or_ce(lk, rk, **kw):
 #eturn COMPARE_FAILED
 #f not self._compare_dml_values_or_ce(lv, rv, **kw):
 #eturn COMPARE_FAILED
 #lse:
 #or lk in left:
 #v = left[lk]

 #f lk not in right:
 #eturn COMPARE_FAILED
 #v = right[lk]

 #f not self._compare_dml_values_or_ce(lv, rv, **kw):
 #eturn COMPARE_FAILED

 #ef visit_dml_multi_values(
 #elf, attrname, left_parent, left, right_parent, right, **kw
 #:
 #or lseq, rseq in util.zip_longest(left, right, fillvalue=None):
 #f lseq is None or rseq is None:
 #eturn COMPARE_FAILED

 #or ld, rd in util.zip_longest(lseq, rseq, fillvalue=None):
 #f (
 #elf.visit_dml_values(
 #ttrname, left_parent, ld, right_parent, rd, **kw
 #
 #s COMPARE_FAILED
 #:
 #eturn COMPARE_FAILED

 #ef compare_clauselist(self, left, right, **kw):
 #f left.operator is right.operator:
 #f operators.is_associative(left.operator):
 #f self._compare_unordered_sequences(
 #eft.clauses, right.clauses, **kw
 #:
 #eturn ["operator", "clauses"]
 #lse:
 #eturn COMPARE_FAILED
 #lse:
 #eturn ["operator"]
 #lse:
 #eturn COMPARE_FAILED

 #ef compare_binary(self, left, right, **kw):
 #f left.operator == right.operator:
 #f operators.is_commutative(left.operator):
 #f (
 #elf.compare_inner(left.left, right.left, **kw)
 #nd self.compare_inner(left.right, right.right, **kw)
 # or (
 #elf.compare_inner(left.left, right.right, **kw)
 #nd self.compare_inner(left.right, right.left, **kw)
 #:
 #eturn ["operator", "negate", "left", "right"]
 #lse:
 #eturn COMPARE_FAILED
 #lse:
 #eturn ["operator", "negate"]
 #lse:
 #eturn COMPARE_FAILED

 #ef compare_bindparam(self, left, right, **kw):
 #ompare_keys = kw.pop("compare_keys", True)
 #ompare_values = kw.pop("compare_values", True)

 #f compare_values:
 #mit = []
 #lse:
            # this means, "skip these, we already compared"
 #mit = ["callable", "value"]

 #f not compare_keys:
 #mit.append("key")

 #eturn omit


class ColIdentityComparatorStrategy(TraversalComparatorStrategy):
 #ef compare_column_element(
 #elf, left, right, use_proxies=True, equivalents=(), **kw
 #:
 #""Compare ColumnElements using proxies and equivalent collections.

 #his is a comparison strategy specific to the ORM.
 #""

 #o_compare = (right,)
 #f equivalents and right in equivalents:
 #o_compare = equivalents[right].union(to_compare)

 #or oth in to_compare:
 #f use_proxies and left.shares_lineage(oth):
 #eturn SKIP_TRAVERSE
 #lif hash(left) == hash(right):
 #eturn SKIP_TRAVERSE
 #lse:
 #eturn COMPARE_FAILED

 #ef compare_column(self, left, right, **kw):
 #eturn self.compare_column_element(left, right, **kw)

 #ef compare_label(self, left, right, **kw):
 #eturn self.compare_column_element(left, right, **kw)

 #ef compare_table(self, left, right, **kw):
        # tables compare on identity, since it's not really feasible to
        # compare them column by column with the above rules
 #eturn SKIP_TRAVERSE if left is right else COMPARE_FAILED
