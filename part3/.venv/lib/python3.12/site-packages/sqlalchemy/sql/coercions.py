# sql/coercions.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import numbers
import re

from . import operators
from . import roles
from . import visitors
from .base import Options
from .traversals import HasCacheKey
from .visitors import Visitable
from .. import exc
from .. import inspection
from .. import util
from ..util import collections_abc


elements = None
lambdas = None
schema = None
selectable = None
sqltypes = None
traversals = None


def _is_literal(element):
 #""Return whether or not the element is a "literal" in the context
 #f a SQL expression construct.

 #""

 #eturn (
 #ot isinstance(
 #lement,
 #Visitable, schema.SchemaEventTarget),
 #
 #nd not hasattr(element, "__clause_element__")
 #


def _deep_is_literal(element):
 #""Return whether or not the element is a "literal" in the context
 #f a SQL expression construct.

 #oes a deeper more esoteric check than _is_literal.   is used
 #or lambda elements that have to distinguish values that would
 #e bound vs. not without any context.

 #""

 #f isinstance(element, collections_abc.Sequence) and not isinstance(
 #lement, str
 #:
 #or elem in element:
 #f not _deep_is_literal(elem):
 #eturn False
 #lse:
 #eturn True

 #eturn (
 #ot isinstance(
 #lement,
 #
 #isitable,
 #chema.SchemaEventTarget,
 #asCacheKey,
 #ptions,
 #til.langhelpers._symbol,
 #,
 #
 #nd not hasattr(element, "__clause_element__")
 #nd (
 #ot isinstance(element, type)
 #r not issubclass(element, HasCacheKey)
 #
 #


def _document_text_coercion(paramname, meth_rst, param_rst):
 #eturn util.add_parameter_text(
 #aramname,
 #
 #.. warning:: "
 #The %s argument to %s can be passed as a Python string argument, "
 #which will be treated "
 #as **trusted SQL text** and rendered as given.  **DO NOT PASS "
 #UNTRUSTED INPUT TO THIS PARAMETER**."
 #
 # (param_rst, meth_rst),
 #


def _expression_collection_was_a_list(attrname, fnname, args):
 #f args and isinstance(args[0], (list, set, dict)) and len(args) == 1:
 #f isinstance(args[0], list):
 #til.warn_deprecated_20(
 #The "%s" argument to %s(), when referring to a sequence '
 #of items, is now passed as a series of positional "
 #elements, rather than as a list. " % (attrname, fnname)
 #
 #eturn args[0]
 #lse:
 #eturn args


def expect(
 #ole,
 #lement,
 #pply_propagate_attrs=None,
 #rgname=None,
 #ost_inspect=False,
 #*kw
):
 #f (
 #ole.allows_lambda
        # note callable() will not invoke a __getattr__() method, whereas
        # hasattr(obj, "__call__") will. by keeping the callable() check here
        # we prevent most needless calls to hasattr()  and therefore
        # __getattr__(), which is present on ColumnElement.
 #nd callable(element)
 #nd hasattr(element, "__code__")
 #:
 #eturn lambdas.LambdaElement(
 #lement,
 #ole,
 #ambdas.LambdaOptions(**kw),
 #pply_propagate_attrs=apply_propagate_attrs,
 #

    # major case is that we are given a ClauseElement already, skip more
    # elaborate logic up front if possible
 #mpl = _impl_lookup[role]

 #riginal_element = element

 #f not isinstance(
 #lement,
 #elements.ClauseElement, schema.SchemaItem, schema.FetchedValue),
 #:
 #esolved = None

 #f impl._resolve_literal_only:
 #esolved = impl._literal_coercion(element, **kw)
 #lse:

 #riginal_element = element

 #s_clause_element = False

            # this is a special performance optimization for ORM
            # joins used by JoinTargetImpl that we don't go through the
            # work of creating __clause_element__() when we only need the
            # original QueryableAttribute, as the former will do clause
            # adaption and all that which is just thrown away here.
 #f (
 #mpl._skip_clauseelement_for_target_match
 #nd isinstance(element, role)
 #nd hasattr(element, "__clause_element__")
 #:
 #s_clause_element = True
 #lse:
 #hile hasattr(element, "__clause_element__"):
 #s_clause_element = True

 #f not getattr(element, "is_clause_element", False):
 #lement = element.__clause_element__()
 #lse:
 #reak

 #f not is_clause_element:
 #f impl._use_inspection:
 #nsp = inspection.inspect(element, raiseerr=False)
 #f insp is not None:
 #f post_inspect:
 #nsp._post_inspect
 #ry:
 #esolved = insp.__clause_element__()
 #xcept AttributeError:
 #mpl._raise_for_expected(original_element, argname)

 #f resolved is None:
 #esolved = impl._literal_coercion(
 #lement, argname=argname, **kw
 #
 #lse:
 #esolved = element
 #lse:
 #esolved = element

 #f (
 #pply_propagate_attrs is not None
 #nd not apply_propagate_attrs._propagate_attrs
 #nd resolved._propagate_attrs
 #:
 #pply_propagate_attrs._propagate_attrs = resolved._propagate_attrs

 #f impl._role_class in resolved.__class__.__mro__:
 #f impl._post_coercion:
 #esolved = impl._post_coercion(
 #esolved,
 #rgname=argname,
 #riginal_element=original_element,
 #*kw
 #
 #eturn resolved
 #lse:
 #eturn impl._implicit_coercions(
 #riginal_element, resolved, argname=argname, **kw
 #


def expect_as_key(role, element, **kw):
 #w["as_key"] = True
 #eturn expect(role, element, **kw)


def expect_col_expression_collection(role, expressions):
 #or expr in expressions:
 #trname = None
 #olumn = None

 #esolved = expect(role, expr)
 #f isinstance(resolved, util.string_types):
 #trname = resolved = expr
 #lse:
 #ols = []
 #isitors.traverse(resolved, {}, {"column": cols.append})
 #f cols:
 #olumn = cols[0]
 #dd_element = column if column is not None else strname
 #ield resolved, column, strname, add_element


class RoleImpl(object):
 #_slots__ = ("_role_class", "name", "_use_inspection")

 #ef _literal_coercion(self, element, **kw):
 #aise NotImplementedError()

 #post_coercion = None
 #resolve_literal_only = False
 #skip_clauseelement_for_target_match = False

 #ef __init__(self, role_class):
 #elf._role_class = role_class
 #elf.name = role_class._role_name
 #elf._use_inspection = issubclass(role_class, roles.UsesInspection)

 #ef _implicit_coercions(self, element, resolved, argname=None, **kw):
 #elf._raise_for_expected(element, argname, resolved)

 #ef _raise_for_expected(
 #elf,
 #lement,
 #rgname=None,
 #esolved=None,
 #dvice=None,
 #ode=None,
 #rr=None,
 #:
 #f resolved is not None and resolved is not element:
 #ot = "%r object resolved from %r object" % (resolved, element)
 #lse:
 #ot = repr(element)

 #f argname:
 #sg = "%s expected for argument %r; got %s." % (
 #elf.name,
 #rgname,
 #ot,
 #
 #lse:
 #sg = "%s expected, got %s." % (self.name, got)

 #f advice:
 #sg += " " + advice

 #til.raise_(exc.ArgumentError(msg, code=code), replace_context=err)


class _Deannotate(object):
 #_slots__ = ()

 #ef _post_coercion(self, resolved, **kw):
 #rom .util import _deep_deannotate

 #eturn _deep_deannotate(resolved)


class _StringOnly(object):
 #_slots__ = ()

 #resolve_literal_only = True


class _ReturnsStringKey(object):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f isinstance(original_element, util.string_types):
 #eturn original_element
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)

 #ef _literal_coercion(self, element, **kw):
 #eturn element


class _ColumnCoercions(object):
 #_slots__ = ()

 #ef _warn_for_scalar_subquery_coercion(self):
 #til.warn(
 #implicitly coercing SELECT object to scalar subquery; "
 #please use the .scalar_subquery() method to produce a scalar "
 #subquery.",
 #

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f not getattr(resolved, "is_clause_element", False):
 #elf._raise_for_expected(original_element, argname, resolved)
 #lif resolved._is_select_statement:
 #elf._warn_for_scalar_subquery_coercion()
 #eturn resolved.scalar_subquery()
 #lif resolved._is_from_clause and isinstance(
 #esolved, selectable.Subquery
 #:
 #elf._warn_for_scalar_subquery_coercion()
 #eturn resolved.element.scalar_subquery()
 #lif self._role_class.allows_lambda and resolved._is_lambda_element:
 #eturn resolved
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)


def _no_text_coercion(
 #lement, argname=None, exc_cls=exc.ArgumentError, extra=None, err=None
):
 #til.raise_(
 #xc_cls(
 #%(extra)sTextual SQL expression %(expr)r %(argname)sshould be "
 #explicitly declared as text(%(expr)r)"
 # {
 #expr": util.ellipses_string(element),
 #argname": "for argument %s" % (argname,) if argname else "",
 #extra": "%s " % extra if extra else "",
 #
 #,
 #eplace_context=err,
 #


class _NoTextCoercion(object):
 #_slots__ = ()

 #ef _literal_coercion(self, element, argname=None, **kw):
 #f isinstance(element, util.string_types) and issubclass(
 #lements.TextClause, self._role_class
 #:
 #no_text_coercion(element, argname)
 #lse:
 #elf._raise_for_expected(element, argname)


class _CoerceLiterals(object):
 #_slots__ = ()
 #coerce_consts = False
 #coerce_star = False
 #coerce_numerics = False

 #ef _text_coercion(self, element, argname=None):
 #eturn _no_text_coercion(element, argname)

 #ef _literal_coercion(self, element, argname=None, **kw):
 #f isinstance(element, util.string_types):
 #f self._coerce_star and element == "*":
 #eturn elements.ColumnClause("*", is_literal=True)
 #lse:
 #eturn self._text_coercion(element, argname, **kw)

 #f self._coerce_consts:
 #f element is None:
 #eturn elements.Null()
 #lif element is False:
 #eturn elements.False_()
 #lif element is True:
 #eturn elements.True_()

 #f self._coerce_numerics and isinstance(element, (numbers.Number)):
 #eturn elements.ColumnClause(str(element), is_literal=True)

 #elf._raise_for_expected(element, argname)


class LiteralValueImpl(RoleImpl):
 #resolve_literal_only = True

 #ef _implicit_coercions(
 #elf, element, resolved, argname, type_=None, **kw
 #:
 #f not _is_literal(resolved):
 #elf._raise_for_expected(
 #lement, resolved=resolved, argname=argname, **kw
 #

 #eturn elements.BindParameter(None, element, type_=type_, unique=True)

 #ef _literal_coercion(self, element, argname=None, type_=None, **kw):
 #eturn element


class _SelectIsNotFrom(object):
 #_slots__ = ()

 #ef _raise_for_expected(self, element, argname=None, resolved=None, **kw):
 #f isinstance(element, roles.SelectStatementRole) or isinstance(
 #esolved, roles.SelectStatementRole
 #:
 #dvice = (
 #To create a "
 #FROM clause from a %s object, use the .subquery() method."
 # (resolved.__class__ if resolved is not None else element,)
 #
 #ode = "89ve"
 #lse:
 #dvice = code = None

 #eturn super(_SelectIsNotFrom, self)._raise_for_expected(
 #lement,
 #rgname=argname,
 #esolved=resolved,
 #dvice=advice,
 #ode=code,
 #*kw
 #


class HasCacheKeyImpl(RoleImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f isinstance(original_element, traversals.HasCacheKey):
 #eturn original_element
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)

 #ef _literal_coercion(self, element, **kw):
 #eturn element


class ExpressionElementImpl(_ColumnCoercions, RoleImpl):
 #_slots__ = ()

 #ef _literal_coercion(
 #elf, element, name=None, type_=None, argname=None, is_crud=False, **kw
 #:
 #f (
 #lement is None
 #nd not is_crud
 #nd (type_ is None or not type_.should_evaluate_none)
 #:
            # TODO: there's no test coverage now for the
            # "should_evaluate_none" part of this, as outside of "crud" this
            # codepath is not normally used except in some special cases
 #eturn elements.Null()
 #lse:
 #ry:
 #eturn elements.BindParameter(
 #ame, element, type_, unique=True, _is_crud=is_crud
 #
 #xcept exc.ArgumentError as err:
 #elf._raise_for_expected(element, err=err)

 #ef _raise_for_expected(self, element, argname=None, resolved=None, **kw):
 #f isinstance(element, roles.AnonymizedFromClauseRole):
 #dvice = (
 #To create a "
 #column expression from a FROM clause row "
 #as a whole, use the .table_valued() method."
 #
 #lse:
 #dvice = None

 #eturn super(ExpressionElementImpl, self)._raise_for_expected(
 #lement, argname=argname, resolved=resolved, advice=advice, **kw
 #


class BinaryElementImpl(ExpressionElementImpl, RoleImpl):

 #_slots__ = ()

 #ef _literal_coercion(
 #elf, element, expr, operator, bindparam_type=None, argname=None, **kw
 #:
 #ry:
 #eturn expr._bind_param(operator, element, type_=bindparam_type)
 #xcept exc.ArgumentError as err:
 #elf._raise_for_expected(element, err=err)

 #ef _post_coercion(self, resolved, expr, **kw):
 #f resolved.type._isnull and not expr.type._isnull:
 #esolved = resolved._with_binary_element_type(expr.type)
 #eturn resolved


class InElementImpl(RoleImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f resolved._is_from_clause:
 #f (
 #sinstance(resolved, selectable.Alias)
 #nd resolved.element._is_select_statement
 #:
 #elf._warn_for_implicit_coercion(resolved)
 #eturn self._post_coercion(resolved.element, **kw)
 #lse:
 #elf._warn_for_implicit_coercion(resolved)
 #eturn self._post_coercion(resolved.select(), **kw)
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)

 #ef _warn_for_implicit_coercion(self, elem):
 #til.warn(
 #Coercing %s object into a select() for use in IN(); "
 #please pass a select() construct explicitly"
 # (elem.__class__.__name__)
 #

 #ef _literal_coercion(self, element, expr, operator, **kw):
 #f isinstance(element, collections_abc.Iterable) and not isinstance(
 #lement, util.string_types
 #:
 #on_literal_expressions = {}
 #lement = list(element)
 #or o in element:
 #f not _is_literal(o):
 #f not isinstance(o, operators.ColumnOperators):
 #elf._raise_for_expected(element, **kw)
 #lse:
 #on_literal_expressions[o] = o
 #lif o is None:
 #on_literal_expressions[o] = elements.Null()

 #f non_literal_expressions:
 #eturn elements.ClauseList(
 #[
 #on_literal_expressions[o]
 #f o in non_literal_expressions
 #lse expr._bind_param(operator, o)
 #or o in element
 #
 #
 #lse:
 #eturn expr._bind_param(operator, element, expanding=True)

 #lse:
 #elf._raise_for_expected(element, **kw)

 #ef _post_coercion(self, element, expr, operator, **kw):
 #f element._is_select_statement:
            # for IN, we are doing scalar_subquery() coercion without
            # a warning
 #eturn element.scalar_subquery()
 #lif isinstance(element, elements.ClauseList):
 #ssert not len(element.clauses) == 0
 #eturn element.self_group(against=operator)

 #lif isinstance(element, elements.BindParameter):
 #lement = element._clone(maintain_key=True)
 #lement.expanding = True
 #lement.expand_op = operator

 #eturn element
 #lse:
 #eturn element


class OnClauseImpl(_CoerceLiterals, _ColumnCoercions, RoleImpl):
 #_slots__ = ()

 #coerce_consts = True

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, legacy=False, **kw
 #:
 #f legacy and isinstance(resolved, str):
 #eturn resolved
 #lse:
 #eturn super(OnClauseImpl, self)._implicit_coercions(
 #riginal_element,
 #esolved,
 #rgname=argname,
 #egacy=legacy,
 #*kw
 #

 #ef _text_coercion(self, element, argname=None, legacy=False):
 #f legacy and isinstance(element, str):
 #til.warn_deprecated_20(
 #Using strings to indicate relationship names in "
 #Query.join() is deprecated and will be removed in "
 #SQLAlchemy 2.0.  Please use the class-bound attribute "
 #directly."
 #
 #eturn element

 #eturn super(OnClauseImpl, self)._text_coercion(element, argname)

 #ef _post_coercion(self, resolved, original_element=None, **kw):
        # this is a hack right now as we want to use coercion on an
        # ORM InstrumentedAttribute, but we want to return the object
        # itself if it is one, not its clause element.
        # ORM context _join and _legacy_join() would need to be improved
        # to look for annotations in a clause element form.
 #f isinstance(original_element, roles.JoinTargetRole):
 #eturn original_element
 #eturn resolved


class WhereHavingImpl(_CoerceLiterals, _ColumnCoercions, RoleImpl):
 #_slots__ = ()

 #coerce_consts = True

 #ef _text_coercion(self, element, argname=None):
 #eturn _no_text_coercion(element, argname)


class StatementOptionImpl(_CoerceLiterals, RoleImpl):
 #_slots__ = ()

 #coerce_consts = True

 #ef _text_coercion(self, element, argname=None):
 #eturn elements.TextClause(element)


class ColumnArgumentImpl(_NoTextCoercion, RoleImpl):
 #_slots__ = ()


class ColumnArgumentOrKeyImpl(_ReturnsStringKey, RoleImpl):
 #_slots__ = ()


class StrAsPlainColumnImpl(_CoerceLiterals, RoleImpl):
 #_slots__ = ()

 #ef _text_coercion(self, element, argname=None):
 #eturn elements.ColumnClause(element)


class ByOfImpl(_CoerceLiterals, _ColumnCoercions, RoleImpl, roles.ByOfRole):

 #_slots__ = ()

 #coerce_consts = True

 #ef _text_coercion(self, element, argname=None):
 #eturn elements._textual_label_reference(element)


class OrderByImpl(ByOfImpl, RoleImpl):
 #_slots__ = ()

 #ef _post_coercion(self, resolved, **kw):
 #f (
 #sinstance(resolved, self._role_class)
 #nd resolved._order_by_label_element is not None
 #:
 #eturn elements._label_reference(resolved)
 #lse:
 #eturn resolved


class GroupByImpl(ByOfImpl, RoleImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f isinstance(resolved, roles.StrictFromClauseRole):
 #eturn elements.ClauseList(*resolved.c)
 #lse:
 #eturn resolved


class DMLColumnImpl(_ReturnsStringKey, RoleImpl):
 #_slots__ = ()

 #ef _post_coercion(self, element, as_key=False, **kw):
 #f as_key:
 #eturn element.key
 #lse:
 #eturn element


class ConstExprImpl(RoleImpl):
 #_slots__ = ()

 #ef _literal_coercion(self, element, argname=None, **kw):
 #f element is None:
 #eturn elements.Null()
 #lif element is False:
 #eturn elements.False_()
 #lif element is True:
 #eturn elements.True_()
 #lse:
 #elf._raise_for_expected(element, argname)


class TruncatedLabelImpl(_StringOnly, RoleImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f isinstance(original_element, util.string_types):
 #eturn resolved
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)

 #ef _literal_coercion(self, element, argname=None, **kw):
 #""coerce the given value to :class:`._truncated_label`.

 #xisting :class:`._truncated_label` and
 #class:`._anonymous_label` objects are passed
 #nchanged.
 #""

 #f isinstance(element, elements._truncated_label):
 #eturn element
 #lse:
 #eturn elements._truncated_label(element)


class DDLExpressionImpl(_Deannotate, _CoerceLiterals, RoleImpl):

 #_slots__ = ()

 #coerce_consts = True

 #ef _text_coercion(self, element, argname=None):
        # see #5754 for why we can't easily deprecate this coercion.
        # essentially expressions like postgresql_where would have to be
        # text() as they come back from reflection and we don't want to
        # have text() elements wired into the inspection dictionaries.
 #eturn elements.TextClause(element)


class DDLConstraintColumnImpl(_Deannotate, _ReturnsStringKey, RoleImpl):
 #_slots__ = ()


class DDLReferredColumnImpl(DDLConstraintColumnImpl):
 #_slots__ = ()


class LimitOffsetImpl(RoleImpl):
 #_slots__ = ()

 #ef _implicit_coercions(self, element, resolved, argname=None, **kw):
 #f resolved is None:
 #eturn None
 #lse:
 #elf._raise_for_expected(element, argname, resolved)

 #ef _literal_coercion(self, element, name, type_, **kw):
 #f element is None:
 #eturn None
 #lse:
 #alue = util.asint(element)
 #eturn selectable._OffsetLimitParam(
 #ame, value, type_=type_, unique=True
 #


class LabeledColumnExprImpl(ExpressionElementImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f isinstance(resolved, roles.ExpressionElementRole):
 #eturn resolved.label(None)
 #lse:
 #ew = super(LabeledColumnExprImpl, self)._implicit_coercions(
 #riginal_element, resolved, argname=argname, **kw
 #
 #f isinstance(new, roles.ExpressionElementRole):
 #eturn new.label(None)
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)


class ColumnsClauseImpl(_SelectIsNotFrom, _CoerceLiterals, RoleImpl):
 #_slots__ = ()

 #coerce_consts = True
 #coerce_numerics = True
 #coerce_star = True

 #guess_straight_column = re.compile(r"^\w\S*$", re.I)

 #ef _text_coercion(self, element, argname=None):
 #lement = str(element)

 #uess_is_literal = not self._guess_straight_column.match(element)
 #aise exc.ArgumentError(
 #Textual column expression %(column)r %(argname)sshould be "
 #explicitly declared with text(%(column)r), "
 #or use %(literal_column)s(%(column)r) "
 #for more specificity"
 # {
 #column": util.ellipses_string(element),
 #argname": "for argument %s" % (argname,) if argname else "",
 #literal_column": "literal_column"
 #f guess_is_literal
 #lse "column",
 #
 #


class ReturnsRowsImpl(RoleImpl):
 #_slots__ = ()


class StatementImpl(_CoerceLiterals, RoleImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f resolved._is_lambda_element:
 #eturn resolved
 #lse:
 #eturn super(StatementImpl, self)._implicit_coercions(
 #riginal_element, resolved, argname=argname, **kw
 #

 #ef _text_coercion(self, element, argname=None):
 #til.warn_deprecated_20(
 #Using plain strings to indicate SQL statements without using "
 #the text() construct is  "
 #deprecated and will be removed in version 2.0.  Ensure plain "
 #SQL statements are passed using the text() construct."
 #
 #eturn elements.TextClause(element)


class SelectStatementImpl(_NoTextCoercion, RoleImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f resolved._is_text_clause:
 #eturn resolved.columns()
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)


class HasCTEImpl(ReturnsRowsImpl):
 #_slots__ = ()


class IsCTEImpl(RoleImpl):
 #_slots__ = ()


class JoinTargetImpl(RoleImpl):
 #_slots__ = ()

 #skip_clauseelement_for_target_match = True

 #ef _literal_coercion(self, element, legacy=False, **kw):
 #f isinstance(element, str):
 #eturn element

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, legacy=False, **kw
 #:
 #f isinstance(original_element, roles.JoinTargetRole):
            # note that this codepath no longer occurs as of
            # #6550, unless JoinTargetImpl._skip_clauseelement_for_target_match
            # were set to False.
 #eturn original_element
 #lif legacy and isinstance(resolved, str):
 #til.warn_deprecated_20(
 #Using strings to indicate relationship names in "
 #Query.join() is deprecated and will be removed in "
 #SQLAlchemy 2.0.  Please use the class-bound attribute "
 #directly."
 #
 #eturn resolved
 #lif legacy and isinstance(resolved, roles.WhereHavingRole):
 #eturn resolved
 #lif legacy and resolved._is_select_statement:
 #til.warn_deprecated(
 #Implicit coercion of SELECT and textual SELECT "
 #constructs into FROM clauses is deprecated; please call "
 #.subquery() on any Core select or ORM Query object in "
 #order to produce a subquery object.",
 #ersion="1.4",
 #
            # TODO: doing _implicit_subquery here causes tests to fail,
            # how was this working before?  probably that ORM
            # join logic treated it as a select and subquery would happen
            # in _ORMJoin->Join
 #eturn resolved
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)


class FromClauseImpl(_SelectIsNotFrom, _NoTextCoercion, RoleImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf,
 #riginal_element,
 #esolved,
 #rgname=None,
 #xplicit_subquery=False,
 #llow_select=True,
 #*kw
 #:
 #f resolved._is_select_statement:
 #f explicit_subquery:
 #eturn resolved.subquery()
 #lif allow_select:
 #til.warn_deprecated(
 #Implicit coercion of SELECT and textual SELECT "
 #constructs into FROM clauses is deprecated; please call "
 #.subquery() on any Core select or ORM Query object in "
 #order to produce a subquery object.",
 #ersion="1.4",
 #
 #eturn resolved._implicit_subquery
 #lif resolved._is_text_clause:
 #eturn resolved
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)

 #ef _post_coercion(self, element, deannotate=False, **kw):
 #f deannotate:
 #eturn element._deannotate()
 #lse:
 #eturn element


class StrictFromClauseImpl(FromClauseImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf,
 #riginal_element,
 #esolved,
 #rgname=None,
 #llow_select=False,
 #*kw
 #:
 #f resolved._is_select_statement and allow_select:
 #til.warn_deprecated(
 #Implicit coercion of SELECT and textual SELECT constructs "
 #into FROM clauses is deprecated; please call .subquery() "
 #on any Core select or ORM Query object in order to produce a "
 #subquery object.",
 #ersion="1.4",
 #
 #eturn resolved._implicit_subquery
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)


class AnonymizedFromClauseImpl(StrictFromClauseImpl):
 #_slots__ = ()

 #ef _post_coercion(self, element, flat=False, name=None, **kw):
 #ssert name is None

 #eturn element._anonymous_fromclause(flat=flat)


class DMLTableImpl(_SelectIsNotFrom, _NoTextCoercion, RoleImpl):
 #_slots__ = ()

 #ef _post_coercion(self, element, **kw):
 #f "dml_table" in element._annotations:
 #eturn element._annotations["dml_table"]
 #lse:
 #eturn element


class DMLSelectImpl(_NoTextCoercion, RoleImpl):
 #_slots__ = ()

 #ef _implicit_coercions(
 #elf, original_element, resolved, argname=None, **kw
 #:
 #f resolved._is_from_clause:
 #f (
 #sinstance(resolved, selectable.Alias)
 #nd resolved.element._is_select_statement
 #:
 #eturn resolved.element
 #lse:
 #eturn resolved.select()
 #lse:
 #elf._raise_for_expected(original_element, argname, resolved)


class CompoundElementImpl(_NoTextCoercion, RoleImpl):
 #_slots__ = ()

 #ef _raise_for_expected(self, element, argname=None, resolved=None, **kw):
 #f isinstance(element, roles.FromClauseRole):
 #f element._is_subquery:
 #dvice = (
 #Use the plain select() object without "
 #calling .subquery() or .alias()."
 #
 #lse:
 #dvice = (
 #To SELECT from any FROM clause, use the .select() method."
 #
 #lse:
 #dvice = None
 #eturn super(CompoundElementImpl, self)._raise_for_expected(
 #lement, argname=argname, resolved=resolved, advice=advice, **kw
 #


_impl_lookup = {}


for name in dir(roles):
 #ls = getattr(roles, name)
 #f name.endswith("Role"):
 #ame = name.replace("Role", "Impl")
 #f name in globals():
 #mpl = globals()[name](cls)
 #impl_lookup[cls] = impl
