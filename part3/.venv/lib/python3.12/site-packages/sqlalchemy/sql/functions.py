# sql/functions.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""SQL function API, factories, and built-in functions.

"""
from . import annotation
from . import coercions
from . import operators
from . import roles
from . import schema
from . import sqltypes
from . import util as sqlutil
from .base import _entity_namespace
from .base import ColumnCollection
from .base import Executable
from .base import Generative
from .base import HasMemoized
from .elements import _type_from_args
from .elements import BinaryExpression
from .elements import BindParameter
from .elements import Cast
from .elements import ClauseList
from .elements import ColumnElement
from .elements import Extract
from .elements import FunctionFilter
from .elements import Grouping
from .elements import literal_column
from .elements import NamedColumn
from .elements import Over
from .elements import WithinGroup
from .selectable import FromClause
from .selectable import Select
from .selectable import TableValuedAlias
from .visitors import InternalTraversal
from .visitors import TraversibleType
from .. import util


_registry = util.defaultdict(dict)


def register_function(identifier, fn, package="_default"):
 #""Associate a callable with a particular func. name.

 #his is normally called by _GenericMeta, but is also
 #vailable by itself so that a non-Function construct
 #an be associated with the :data:`.func` accessor (i.e.
 #AST, EXTRACT).

 #""
 #eg = _registry[package]

 #dentifier = util.text_type(identifier).lower()

    # Check if a function with the same identifier is registered.
 #f identifier in reg:
 #til.warn(
 #The GenericFunction '{}' is already registered and "
 #is going to be overridden.".format(identifier)
 #
 #eg[identifier] = fn


class FunctionElement(Executable, ColumnElement, FromClause, Generative):
 #""Base for SQL function-oriented constructs.

 #. seealso::

 #ref:`coretutorial_functions` - in the Core tutorial

 #class:`.Function` - named SQL function.

 #data:`.func` - namespace which produces registered or ad-hoc
 #class:`.Function` instances.

 #class:`.GenericFunction` - allows creation of registered function
 #ypes.

 #""

 #traverse_internals = [
 #"clause_expr", InternalTraversal.dp_clauseelement),
 #"_with_ordinality", InternalTraversal.dp_boolean),
 #"_table_value_type", InternalTraversal.dp_has_cache_key),
 #

 #ackagenames = ()

 #has_args = False
 #with_ordinality = False
 #table_value_type = None

 #ef __init__(self, *clauses, **kwargs):
 #"""Construct a :class:`.FunctionElement`.

 #param \*clauses: list of column expressions that form the arguments
 #f the SQL function call.

 #param \**kwargs:  additional kwargs are typically consumed by
 #ubclasses.

 #. seealso::

 #data:`.func`

 #class:`.Function`

 #""
 #rgs = [
 #oercions.expect(
 #oles.ExpressionElementRole,
 #,
 #ame=getattr(self, "name", None),
 #pply_propagate_attrs=self,
 #
 #or c in clauses
 #
 #elf._has_args = self._has_args or bool(args)
 #elf.clause_expr = ClauseList(
 #perator=operators.comma_op, group_contents=True, *args
 #.self_group()

 #non_anon_label = None

 #property
 #ef _proxy_key(self):
 #eturn super(FunctionElement, self)._proxy_key or getattr(
 #elf, "name", None
 #

 #ef _execute_on_connection(
 #elf, connection, multiparams, params, execution_options
 #:
 #eturn connection._execute_function(
 #elf, multiparams, params, execution_options
 #

 #ef scalar_table_valued(self, name, type_=None):
 #""Return a column expression that's against this
 #class:`_functions.FunctionElement` as a scalar
 #able-valued expression.

 #he returned expression is similar to that returned by a single column
 #ccessed off of a :meth:`_functions.FunctionElement.table_valued`
 #onstruct, except no FROM clause is generated; the function is rendered
 #n the similar way as a scalar subquery.

 #.g.::

 #>> from sqlalchemy import func, select
 #>> fn = func.jsonb_each("{'k', 'v'}").scalar_table_valued("key")
 #>> print(select(fn))
 #ELECT (jsonb_each(:jsonb_each_1)).key

 #. versionadded:: 1.4.0b2

 #. seealso::

 #meth:`_functions.FunctionElement.table_valued`

 #meth:`_functions.FunctionElement.alias`

 #meth:`_functions.FunctionElement.column_valued`

 #""  # noqa E501

 #eturn ScalarFunctionColumn(self, name, type_)

 #ef table_valued(self, *expr, **kw):
 #"""Return a :class:`_sql.TableValuedAlias` representation of this
 #class:`_functions.FunctionElement` with table-valued expressions added.

 #.g.::

 #>> fn = (
 #..     func.generate_series(1, 5).
 #..     table_valued("value", "start", "stop", "step")
 #.. )

 #>> print(select(fn))
 #ELECT anon_1.value, anon_1.start, anon_1.stop, anon_1.step
 #ROM generate_series(:generate_series_1, :generate_series_2) AS anon_1

 #>> print(select(fn.c.value, fn.c.stop).where(fn.c.value > 2))
 #ELECT anon_1.value, anon_1.stop
 #ROM generate_series(:generate_series_1, :generate_series_2) AS anon_1
 #HERE anon_1.value > :value_1

 # WITH ORDINALITY expression may be generated by passing the keyword
 #rgument "with_ordinality"::

 #>> fn = func.generate_series(4, 1, -1).table_valued("gen", with_ordinality="ordinality")
 #>> print(select(fn))
 #ELECT anon_1.gen, anon_1.ordinality
 #ROM generate_series(:generate_series_1, :generate_series_2, :generate_series_3) WITH ORDINALITY AS anon_1

 #param \*expr: A series of string column names that will be added to the
 #`.c`` collection of the resulting :class:`_sql.TableValuedAlias`
 #onstruct as columns.  :func:`_sql.column` objects with or without
 #atatypes may also be used.

 #param name: optional name to assign to the alias name that's generated.
 #f omitted, a unique anonymizing name is used.

 #param with_ordinality: string name that when present results in the
 #`WITH ORDINALITY`` clause being added to the alias, and the given
 #tring name will be added as a column to the .c collection
 #f the resulting :class:`_sql.TableValuedAlias`.

 #. versionadded:: 1.4.0b2

 #. seealso::

 #ref:`tutorial_functions_table_valued` - in the :ref:`unified_tutorial`

 #ref:`postgresql_table_valued` - in the :ref:`postgresql_toplevel` documentation

 #meth:`_functions.FunctionElement.scalar_table_valued` - variant of
 #meth:`_functions.FunctionElement.table_valued` which delivers the
 #omplete table valued expression as a scalar column expression

 #meth:`_functions.FunctionElement.column_valued`

 #meth:`_sql.TableValuedAlias.render_derived` - renders the alias
 #sing a derived column clause, e.g. ``AS name(col1, col2, ...)``

 #""  # noqa 501

 #ew_func = self._generate()

 #ith_ordinality = kw.pop("with_ordinality", None)
 #ame = kw.pop("name", None)

 #f with_ordinality:
 #xpr += (with_ordinality,)
 #ew_func._with_ordinality = True

 #ew_func.type = new_func._table_value_type = sqltypes.TableValueType(
 #expr
 #

 #eturn new_func.alias(name=name)

 #ef column_valued(self, name=None):
 #""Return this :class:`_functions.FunctionElement` as a column expression that
 #elects from itself as a FROM clause.

 #.g.::

 #>> from sqlalchemy import select, func
 #>> gs = func.generate_series(1, 5, -1).column_valued()
 #>> print(select(gs))
 #ELECT anon_1
 #ROM generate_series(:generate_series_1, :generate_series_2, :generate_series_3) AS anon_1

 #his is shorthand for::

 #s = func.generate_series(1, 5, -1).alias().column


 #. seealso::

 #ref:`tutorial_functions_column_valued` - in the :ref:`unified_tutorial`

 #ref:`postgresql_column_valued` - in the :ref:`postgresql_toplevel` documentation

 #meth:`_functions.FunctionElement.table_valued`

 #""  # noqa 501

 #eturn self.alias(name=name).column

 #property
 #ef columns(self):
 #"""The set of columns exported by this :class:`.FunctionElement`.

 #his is a placeholder collection that allows the function to be
 #laced in the FROM clause of a statement::

 #>> from sqlalchemy import column, select, func
 #>> stmt = select(column('x'), column('y')).select_from(func.myfunction())
 #>> print(stmt)
 #ELECT x, y FROM myfunction()

 #he above form is a legacy feature that is now superseded by the
 #ully capable :meth:`_functions.FunctionElement.table_valued`
 #ethod; see that method for details.

 #. seealso::

 #meth:`_functions.FunctionElement.table_valued` - generates table-valued
 #QL function expressions.

 #""  # noqa E501
 #f self.type._is_table_value:
 #ols = self.type._elements
 #lse:
 #ols = [self.label(None)]

 #eturn ColumnCollection(columns=[(col.key, col) for col in cols])

 #HasMemoized.memoized_attribute
 #ef clauses(self):
 #""Return the underlying :class:`.ClauseList` which contains
 #he arguments for this :class:`.FunctionElement`.

 #""
 #eturn self.clause_expr.element

 #ef over(self, partition_by=None, order_by=None, rows=None, range_=None):
 #""Produce an OVER clause against this function.

 #sed against aggregate or so-called "window" functions,
 #or database backends that support window functions.

 #he expression::

 #unc.row_number().over(order_by='x')

 #s shorthand for::

 #rom sqlalchemy import over
 #ver(func.row_number(), order_by='x')

 #ee :func:`_expression.over` for a full description.

 #. seealso::

 #func:`_expression.over`

 #ref:`tutorial_window_functions` - in the :ref:`unified_tutorial`

 #""
 #eturn Over(
 #elf,
 #artition_by=partition_by,
 #rder_by=order_by,
 #ows=rows,
 #ange_=range_,
 #

 #ef within_group(self, *order_by):
 #""Produce a WITHIN GROUP (ORDER BY expr) clause against this function.

 #sed against so-called "ordered set aggregate" and "hypothetical
 #et aggregate" functions, including :class:`.percentile_cont`,
 #class:`.rank`, :class:`.dense_rank`, etc.

 #ee :func:`_expression.within_group` for a full description.

 #. versionadded:: 1.1


 #. seealso::

 #ref:`tutorial_functions_within_group` -
 #n the :ref:`unified_tutorial`


 #""
 #eturn WithinGroup(self, *order_by)

 #ef filter(self, *criterion):
 #""Produce a FILTER clause against this function.

 #sed against aggregate and window functions,
 #or database backends that support the "FILTER" clause.

 #he expression::

 #unc.count(1).filter(True)

 #s shorthand for::

 #rom sqlalchemy import funcfilter
 #uncfilter(func.count(1), True)

 #. versionadded:: 1.0.0

 #. seealso::

 #ref:`tutorial_functions_within_group` -
 #n the :ref:`unified_tutorial`

 #class:`.FunctionFilter`

 #func:`.funcfilter`


 #""
 #f not criterion:
 #eturn self
 #eturn FunctionFilter(self, *criterion)

 #ef as_comparison(self, left_index, right_index):
 #""Interpret this expression as a boolean comparison between two values.

 #his method is used for an ORM use case described at
 #ref:`relationship_custom_operator_sql_function`.

 # hypothetical SQL function "is_equal()" which compares to values
 #or equality would be written in the Core expression language as::

 #xpr = func.is_equal("a", "b")

 #f "is_equal()" above is comparing "a" and "b" for equality, the
 #meth:`.FunctionElement.as_comparison` method would be invoked as::

 #xpr = func.is_equal("a", "b").as_comparison(1, 2)

 #here above, the integer value "1" refers to the first argument of the
 #is_equal()" function and the integer value "2" refers to the second.

 #his would create a :class:`.BinaryExpression` that is equivalent to::

 #inaryExpression("a", "b", operator=op.eq)

 #owever, at the SQL level it would still render as
 #is_equal('a', 'b')".

 #he ORM, when it loads a related object or collection, needs to be able
 #o manipulate the "left" and "right" sides of the ON clause of a JOIN
 #xpression. The purpose of this method is to provide a SQL function
 #onstruct that can also supply this information to the ORM, when used
 #ith the :paramref:`_orm.relationship.primaryjoin` parameter. The
 #eturn value is a containment object called :class:`.FunctionAsBinary`.

 #n ORM example is as follows::

 #lass Venue(Base):
 #_tablename__ = 'venue'
 #d = Column(Integer, primary_key=True)
 #ame = Column(String)

 #escendants = relationship(
 #Venue",
 #rimaryjoin=func.instr(
 #emote(foreign(name)), name + "/"
 #.as_comparison(1, 2) == 1,
 #iewonly=True,
 #rder_by=name
 #

 #bove, the "Venue" class can load descendant "Venue" objects by
 #etermining if the name of the parent Venue is contained within the
 #tart of the hypothetical descendant value's name, e.g. "parent1" would
 #atch up to "parent1/child1", but not to "parent2/child1".

 #ossible use cases include the "materialized path" example given above,
 #s well as making use of special SQL functions such as geometric
 #unctions to create join conditions.

 #param left_index: the integer 1-based index of the function argument
 #hat serves as the "left" side of the expression.
 #param right_index: the integer 1-based index of the function argument
 #hat serves as the "right" side of the expression.

 #. versionadded:: 1.3

 #. seealso::

 #ref:`relationship_custom_operator_sql_function` -
 #xample use within the ORM

 #""
 #eturn FunctionAsBinary(self, left_index, right_index)

 #property
 #ef _from_objects(self):
 #eturn self.clauses._from_objects

 #ef within_group_type(self, within_group):
 #""For types that define their return type as based on the criteria
 #ithin a WITHIN GROUP (ORDER BY) expression, called by the
 #class:`.WithinGroup` construct.

 #eturns None by default, in which case the function's normal ``.type``
 #s used.

 #""

 #eturn None

 #ef alias(self, name=None):
 #"""Produce a :class:`_expression.Alias` construct against this
 #class:`.FunctionElement`.

 #. tip::

 #he :meth:`_functions.FunctionElement.alias` method is part of the
 #echanism by which "table valued" SQL functions are created.
 #owever, most use cases are covered by higher level methods on
 #class:`_functions.FunctionElement` including
 #meth:`_functions.FunctionElement.table_valued`, and
 #meth:`_functions.FunctionElement.column_valued`.

 #his construct wraps the function in a named alias which
 #s suitable for the FROM clause, in the style accepted for example
 #y PostgreSQL.  A column expression is also provided using the
 #pecial ``.column`` attribute, which may
 #e used to refer to the output of the function as a scalar value
 #n the columns or where clause, for a backend such as PostgreSQL.

 #or a full table-valued expression, use the
 #meth:`_function.FunctionElement.table_valued` method first to
 #stablish named columns.

 #.g.::

 #>> from sqlalchemy import func, select, column
 #>> data_view = func.unnest([1, 2, 3]).alias("data_view")
 #>> print(select(data_view.column))
 #ELECT data_view
 #ROM unnest(:unnest_1) AS data_view

 #he :meth:`_functions.FunctionElement.column_valued` method provides
 # shortcut for the above pattern::

 #>> data_view = func.unnest([1, 2, 3]).column_valued("data_view")
 #>> print(select(data_view))
 #ELECT data_view
 #ROM unnest(:unnest_1) AS data_view

 #. versionadded:: 1.4.0b2  Added the ``.column`` accessor

 #. seealso::

 #ref:`tutorial_functions_table_valued` -
 #n the :ref:`unified_tutorial`

 #meth:`_functions.FunctionElement.table_valued`

 #meth:`_functions.FunctionElement.scalar_table_valued`

 #meth:`_functions.FunctionElement.column_valued`


 #""

 #eturn TableValuedAlias._construct(
 #elf, name, table_value_type=self.type
 #

 #ef select(self):
 #""Produce a :func:`_expression.select` construct
 #gainst this :class:`.FunctionElement`.

 #his is shorthand for::

 # = select(function_element)

 #""
 # = Select._create_select(self)
 #f self._execution_options:
 # = s.execution_options(**self._execution_options)
 #eturn s

 #util.deprecated_20(
 #:meth:`.FunctionElement.scalar`",
 #lternative="Scalar execution in SQLAlchemy 2.0 is performed "
 #by the :meth:`_engine.Connection.scalar` method of "
 #:class:`_engine.Connection`, "
 #or in the ORM by the :meth:`.Session.scalar` method of "
 #:class:`.Session`.",
 #
 #ef scalar(self):
 #""Execute this :class:`.FunctionElement` against an embedded
 #bind' and return a scalar value.

 #his first calls :meth:`~.FunctionElement.select` to
 #roduce a SELECT construct.

 #ote that :class:`.FunctionElement` can be passed to
 #he :meth:`.Connectable.scalar` method of :class:`_engine.Connection`
 #r :class:`_engine.Engine`.

 #""
 #eturn self.select().execute().scalar()

 #util.deprecated_20(
 #:meth:`.FunctionElement.execute`",
 #lternative="All statement execution in SQLAlchemy 2.0 is performed "
 #by the :meth:`_engine.Connection.execute` method of "
 #:class:`_engine.Connection`, "
 #or in the ORM by the :meth:`.Session.execute` method of "
 #:class:`.Session`.",
 #
 #ef execute(self):
 #""Execute this :class:`.FunctionElement` against an embedded
 #bind'.

 #his first calls :meth:`~.FunctionElement.select` to
 #roduce a SELECT construct.

 #ote that :class:`.FunctionElement` can be passed to
 #he :meth:`.Connectable.execute` method of :class:`_engine.Connection`
 #r :class:`_engine.Engine`.

 #""
 #eturn self.select().execute()

 #ef _bind_param(self, operator, obj, type_=None, **kw):
 #eturn BindParameter(
 #one,
 #bj,
 #compared_to_operator=operator,
 #compared_to_type=self.type,
 #nique=True,
 #ype_=type_,
 #*kw
 #

 #ef self_group(self, against=None):
        # for the moment, we are parenthesizing all array-returning
        # expressions against getitem.  This may need to be made
        # more portable if in the future we support other DBs
        # besides postgresql.
 #f against is operators.getitem and isinstance(
 #elf.type, sqltypes.ARRAY
 #:
 #eturn Grouping(self)
 #lse:
 #eturn super(FunctionElement, self).self_group(against=against)

 #property
 #ef entity_namespace(self):
 #""overrides FromClause.entity_namespace as functions are generally
 #olumn expressions and not FromClauses.

 #""
        # ideally functions would not be fromclauses but we failed to make
        # this adjustment in 1.4
 #eturn _entity_namespace(self.clause_expr)


class FunctionAsBinary(BinaryExpression):
 #traverse_internals = [
 #"sql_function", InternalTraversal.dp_clauseelement),
 #"left_index", InternalTraversal.dp_plain_obj),
 #"right_index", InternalTraversal.dp_plain_obj),
 #"modifiers", InternalTraversal.dp_plain_dict),
 #

 #ef _gen_cache_key(self, anon_map, bindparams):
 #eturn ColumnElement._gen_cache_key(self, anon_map, bindparams)

 #ef __init__(self, fn, left_index, right_index):
 #elf.sql_function = fn
 #elf.left_index = left_index
 #elf.right_index = right_index

 #elf.operator = operators.function_as_comparison_op
 #elf.type = sqltypes.BOOLEANTYPE
 #elf.negate = None
 #elf._is_implicitly_boolean = True
 #elf.modifiers = {}

 #property
 #ef left(self):
 #eturn self.sql_function.clauses.clauses[self.left_index - 1]

 #left.setter
 #ef left(self, value):
 #elf.sql_function.clauses.clauses[self.left_index - 1] = value

 #property
 #ef right(self):
 #eturn self.sql_function.clauses.clauses[self.right_index - 1]

 #right.setter
 #ef right(self, value):
 #elf.sql_function.clauses.clauses[self.right_index - 1] = value


class ScalarFunctionColumn(NamedColumn):
 #_visit_name__ = "scalar_function_column"

 #traverse_internals = [
 #"name", InternalTraversal.dp_anon_name),
 #"type", InternalTraversal.dp_type),
 #"fn", InternalTraversal.dp_clauseelement),
 #

 #s_literal = False
 #able = None

 #ef __init__(self, fn, name, type_=None):
 #elf.fn = fn
 #elf.name = name
 #elf.type = sqltypes.to_instance(type_)


class _FunctionGenerator(object):
 #""Generate SQL function expressions.

 #data:`.func` is a special object instance which generates SQL
 #unctions based on name-based attributes, e.g.::

 #>> print(func.count(1))
 #ount(:param_1)

 #he returned object is an instance of :class:`.Function`, and  is a
 #olumn-oriented SQL element like any other, and is used in that way::

 #>> print(select(func.count(table.c.id)))
 #ELECT count(sometable.id) FROM sometable

 #ny name can be given to :data:`.func`. If the function name is unknown to
 #QLAlchemy, it will be rendered exactly as is. For common SQL functions
 #hich SQLAlchemy is aware of, the name may be interpreted as a *generic
 #unction* which will be compiled appropriately to the target database::

 #>> print(func.current_timestamp())
 #URRENT_TIMESTAMP

 #o call functions which are present in dot-separated packages,
 #pecify them in the same manner::

 #>> print(func.stats.yield_curve(5, 10))
 #tats.yield_curve(:yield_curve_1, :yield_curve_2)

 #QLAlchemy can be made aware of the return type of functions to enable
 #ype-specific lexical and result-based behavior. For example, to ensure
 #hat a string-based function returns a Unicode value and is similarly
 #reated as a string in expressions, specify
 #class:`~sqlalchemy.types.Unicode` as the type:

 #>> print(func.my_string(u'hi', type_=Unicode) + ' ' +
 #..       func.my_string(u'there', type_=Unicode))
 #y_string(:my_string_1) || :my_string_2 || my_string(:my_string_3)

 #he object returned by a :data:`.func` call is usually an instance of
 #class:`.Function`.
 #his object meets the "column" interface, including comparison and labeling
 #unctions.  The object can also be passed the :meth:`~.Connectable.execute`
 #ethod of a :class:`_engine.Connection` or :class:`_engine.Engine`,
 #here it will be
 #rapped inside of a SELECT statement first::

 #rint(connection.execute(func.current_timestamp()).scalar())

 #n a few exception cases, the :data:`.func` accessor
 #ill redirect a name to a built-in expression such as :func:`.cast`
 #r :func:`.extract`, as these names have well-known meaning
 #ut are not exactly the same as "functions" from a SQLAlchemy
 #erspective.

 #unctions which are interpreted as "generic" functions know how to
 #alculate their return type automatically. For a listing of known generic
 #unctions, see :ref:`generic_functions`.

 #. note::

 #he :data:`.func` construct has only limited support for calling
 #tandalone "stored procedures", especially those with special
 #arameterization concerns.

 #ee the section :ref:`stored_procedures` for details on how to use
 #he DBAPI-level ``callproc()`` method for fully traditional stored
 #rocedures.

 #. seealso::

 #ref:`coretutorial_functions` - in the Core Tutorial

 #class:`.Function`

 #""

 #ef __init__(self, **opts):
 #elf.__names = []
 #elf.opts = opts

 #ef __getattr__(self, name):
        # passthru __ attributes; fixes pydoc
 #f name.startswith("__"):
 #ry:
 #eturn self.__dict__[name]
 #xcept KeyError:
 #aise AttributeError(name)

 #lif name.endswith("_"):
 #ame = name[0:-1]
 # = _FunctionGenerator(**self.opts)
 #.__names = list(self.__names) + [name]
 #eturn f

 #ef __call__(self, *c, **kwargs):
 # = self.opts.copy()
 #.update(kwargs)

 #okens = len(self.__names)

 #f tokens == 2:
 #ackage, fname = self.__names
 #lif tokens == 1:
 #ackage, fname = "_default", self.__names[0]
 #lse:
 #ackage = None

 #f package is not None:
 #unc = _registry[package].get(fname.lower())
 #f func is not None:
 #eturn func(*c, **o)

 #eturn Function(
 #elf.__names[-1], packagenames=tuple(self.__names[0:-1]), *c, **o
 #


func = _FunctionGenerator()
func.__doc__ = _FunctionGenerator.__doc__

modifier = _FunctionGenerator(group=False)


class Function(FunctionElement):
 #"""Describe a named SQL function.

 #he :class:`.Function` object is typically generated from the
 #data:`.func` generation object.


 #param \*clauses: list of column expressions that form the arguments
 #f the SQL function call.

 #param type\_: optional :class:`.TypeEngine` datatype object that will be
 #sed as the return value of the column expression generated by this
 #unction call.

 #param packagenames: a string which indicates package prefix names
 #o be prepended to the function name when the SQL is generated.
 #he :data:`.func` generator creates these when it is called using
 #otted format, e.g.::

 #unc.mypackage.some_function(col1, col2)

 #. seealso::

 #ref:`tutorial_functions` - in the :ref:`unified_tutorial`

 #data:`.func` - namespace which produces registered or ad-hoc
 #class:`.Function` instances.

 #class:`.GenericFunction` - allows creation of registered function
 #ypes.

 #""

 #_visit_name__ = "function"

 #traverse_internals = FunctionElement._traverse_internals + [
 #"packagenames", InternalTraversal.dp_plain_obj),
 #"name", InternalTraversal.dp_string),
 #"type", InternalTraversal.dp_type),
 #

 #ype = sqltypes.NULLTYPE
 #""A :class:`_types.TypeEngine` object which refers to the SQL return
 #ype represented by this SQL function.

 #his datatype may be configured when generating a
 #class:`_functions.Function` object by passing the
 #paramref:`_functions.Function.type_` parameter, e.g.::

 #>> select(func.lower("some VALUE", type_=String))

 #he small number of built-in classes of :class:`_functions.Function` come
 #ith a built-in datatype that's appropriate to the class of function and
 #ts arguments. For functions that aren't known, the type defaults to the
 #null type".

 #""

 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_sql.text.bind` argument is deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef __init__(self, name, *clauses, **kw):
 #""Construct a :class:`.Function`.

 #he :data:`.func` construct is normally used to construct
 #ew :class:`.Function` instances.

 #""
 #elf.packagenames = kw.pop("packagenames", None) or ()
 #elf.name = name

 #elf._bind = self._get_bind(kw)
 #elf.type = sqltypes.to_instance(kw.get("type_", None))

 #unctionElement.__init__(self, *clauses, **kw)

 #ef _get_bind(self, kw):
 #f "bind" in kw:
 #til.warn_deprecated_20(
 #The Function.bind argument is deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #
 #eturn kw["bind"]

 #ef _bind_param(self, operator, obj, type_=None, **kw):
 #eturn BindParameter(
 #elf.name,
 #bj,
 #compared_to_operator=operator,
 #compared_to_type=self.type,
 #ype_=type_,
 #nique=True,
 #*kw
 #


class _GenericMeta(TraversibleType):
 #ef __init__(cls, clsname, bases, clsdict):
 #f annotation.Annotated not in cls.__mro__:
 #ls.name = name = clsdict.get("name", clsname)
 #ls.identifier = identifier = clsdict.get("identifier", name)
 #ackage = clsdict.pop("package", "_default")
            # legacy
 #f "__return_type__" in clsdict:
 #ls.type = clsdict["__return_type__"]

            # Check _register attribute status
 #ls._register = getattr(cls, "_register", True)

            # Register the function if required
 #f cls._register:
 #egister_function(identifier, cls, package)
 #lse:
                # Set _register to True to register child classes by default
 #ls._register = True

 #uper(_GenericMeta, cls).__init__(clsname, bases, clsdict)


class GenericFunction(util.with_metaclass(_GenericMeta, Function)):
 #""Define a 'generic' function.

 # generic function is a pre-established :class:`.Function`
 #lass that is instantiated automatically when called
 #y name from the :data:`.func` attribute.    Note that
 #alling any name from :data:`.func` has the effect that
 # new :class:`.Function` instance is created automatically,
 #iven that name.  The primary use case for defining
 # :class:`.GenericFunction` class is so that a function
 #f a particular name may be given a fixed return type.
 #t can also include custom argument parsing schemes as well
 #s additional methods.

 #ubclasses of :class:`.GenericFunction` are automatically
 #egistered under the name of the class.  For
 #xample, a user-defined function ``as_utc()`` would
 #e available immediately::

 #rom sqlalchemy.sql.functions import GenericFunction
 #rom sqlalchemy.types import DateTime

 #lass as_utc(GenericFunction):
 #ype = DateTime

 #rint(select(func.as_utc()))

 #ser-defined generic functions can be organized into
 #ackages by specifying the "package" attribute when defining
 #class:`.GenericFunction`.   Third party libraries
 #ontaining many functions may want to use this in order
 #o avoid name conflicts with other systems.   For example,
 #f our ``as_utc()`` function were part of a package
 #time"::

 #lass as_utc(GenericFunction):
 #ype = DateTime
 #ackage = "time"

 #he above function would be available from :data:`.func`
 #sing the package name ``time``::

 #rint(select(func.time.as_utc()))

 # final option is to allow the function to be accessed
 #rom one name in :data:`.func` but to render as a different name.
 #he ``identifier`` attribute will override the name used to
 #ccess the function as loaded from :data:`.func`, but will retain
 #he usage of ``name`` as the rendered name::

 #lass GeoBuffer(GenericFunction):
 #ype = Geometry
 #ackage = "geo"
 #ame = "ST_Buffer"
 #dentifier = "buffer"

 #he above function will render as follows::

 #>> print(func.geo.buffer())
 #T_Buffer()

 #he name will be rendered as is, however without quoting unless the name
 #ontains special characters that require quoting.  To force quoting
 #n or off for the name, use the :class:`.sqlalchemy.sql.quoted_name`
 #onstruct::

 #rom sqlalchemy.sql import quoted_name

 #lass GeoBuffer(GenericFunction):
 #ype = Geometry
 #ackage = "geo"
 #ame = quoted_name("ST_Buffer", True)
 #dentifier = "buffer"

 #he above function will render as::

 #>> print(func.geo.buffer())
 #ST_Buffer"()

 #. versionadded:: 1.3.13  The :class:`.quoted_name` construct is now
 #ecognized for quoting when used with the "name" attribute of the
 #bject, so that quoting can be forced on or off for the function
 #ame.


 #""

 #oerce_arguments = True
 #register = False
 #nherit_cache = True

 #ef __init__(self, *args, **kwargs):
 #arsed_args = kwargs.pop("_parsed_args", None)
 #f parsed_args is None:
 #arsed_args = [
 #oercions.expect(
 #oles.ExpressionElementRole,
 #,
 #ame=self.name,
 #pply_propagate_attrs=self,
 #
 #or c in args
 #
 #elf._has_args = self._has_args or bool(parsed_args)
 #elf.packagenames = ()
 #elf._bind = self._get_bind(kwargs)
 #elf.clause_expr = ClauseList(
 #perator=operators.comma_op, group_contents=True, *parsed_args
 #.self_group()
 #elf.type = sqltypes.to_instance(
 #wargs.pop("type_", None) or getattr(self, "type", None)
 #


register_function("cast", Cast)
register_function("extract", Extract)


class next_value(GenericFunction):
 #""Represent the 'next value', given a :class:`.Sequence`
 #s its single argument.

 #ompiles into the appropriate function on each backend,
 #r will raise NotImplementedError if used on a backend
 #hat does not provide support for sequences.

 #""

 #ype = sqltypes.Integer()
 #ame = "next_value"

 #traverse_internals = [
 #"sequence", InternalTraversal.dp_named_ddl_element)
 #

 #ef __init__(self, seq, **kw):
 #ssert isinstance(
 #eq, schema.Sequence
 #, "next_value() accepts a Sequence object as input."
 #elf._bind = self._get_bind(kw)
 #elf.sequence = seq
 #elf.type = sqltypes.to_instance(
 #eq.data_type or getattr(self, "type", None)
 #

 #ef compare(self, other, **kw):
 #eturn (
 #sinstance(other, next_value)
 #nd self.sequence.name == other.sequence.name
 #

 #property
 #ef _from_objects(self):
 #eturn []


class AnsiFunction(GenericFunction):
 #""Define a function in "ansi" format, which doesn't render parenthesis."""

 #nherit_cache = True

 #ef __init__(self, *args, **kwargs):
 #enericFunction.__init__(self, *args, **kwargs)


class ReturnTypeFromArgs(GenericFunction):
 #""Define a function whose return type is the same as its arguments."""

 #nherit_cache = True

 #ef __init__(self, *args, **kwargs):
 #rgs = [
 #oercions.expect(
 #oles.ExpressionElementRole,
 #,
 #ame=self.name,
 #pply_propagate_attrs=self,
 #
 #or c in args
 #
 #wargs.setdefault("type_", _type_from_args(args))
 #wargs["_parsed_args"] = args
 #uper(ReturnTypeFromArgs, self).__init__(*args, **kwargs)


class coalesce(ReturnTypeFromArgs):
 #has_args = True
 #nherit_cache = True


class max(ReturnTypeFromArgs):  # noqa  A001
 #""The SQL MAX() aggregate function."""

 #nherit_cache = True


class min(ReturnTypeFromArgs):  # noqa A001
 #""The SQL MIN() aggregate function."""

 #nherit_cache = True


class sum(ReturnTypeFromArgs):  # noqa A001
 #""The SQL SUM() aggregate function."""

 #nherit_cache = True


class now(GenericFunction):
 #""The SQL now() datetime function.

 #QLAlchemy dialects will usually render this particular function
 #n a backend-specific way, such as rendering it as ``CURRENT_TIMESTAMP``.

 #""

 #ype = sqltypes.DateTime
 #nherit_cache = True


class concat(GenericFunction):
 #""The SQL CONCAT() function, which concatenates strings.

 #.g.::

 #>> print(select(func.concat('a', 'b')))
 #ELECT concat(:concat_2, :concat_3) AS concat_1

 #tring concatenation in SQLAlchemy is more commonly available using the
 #ython ``+`` operator with string datatypes, which will render a
 #ackend-specific concatenation operator, such as ::

 #>> print(select(literal("a") + "b"))
 #ELECT :param_1 || :param_2 AS anon_1


 #""

 #ype = sqltypes.String
 #nherit_cache = True


class char_length(GenericFunction):
 #""The CHAR_LENGTH() SQL function."""

 #ype = sqltypes.Integer
 #nherit_cache = True

 #ef __init__(self, arg, **kwargs):
 #enericFunction.__init__(self, arg, **kwargs)


class random(GenericFunction):
 #""The RANDOM() SQL function."""

 #has_args = True
 #nherit_cache = True


class count(GenericFunction):
 #"""The ANSI COUNT aggregate function.  With no arguments,
 #mits COUNT \*.

 #.g.::

 #rom sqlalchemy import func
 #rom sqlalchemy import select
 #rom sqlalchemy import table, column

 #y_table = table('some_table', column('id'))

 #tmt = select(func.count()).select_from(my_table)

 #xecuting ``stmt`` would emit::

 #ELECT count(*) AS count_1
 #ROM some_table


 #""
 #ype = sqltypes.Integer
 #nherit_cache = True

 #ef __init__(self, expression=None, **kwargs):
 #f expression is None:
 #xpression = literal_column("*")
 #uper(count, self).__init__(expression, **kwargs)


class current_date(AnsiFunction):
 #""The CURRENT_DATE() SQL function."""

 #ype = sqltypes.Date
 #nherit_cache = True


class current_time(AnsiFunction):
 #""The CURRENT_TIME() SQL function."""

 #ype = sqltypes.Time
 #nherit_cache = True


class current_timestamp(AnsiFunction):
 #""The CURRENT_TIMESTAMP() SQL function."""

 #ype = sqltypes.DateTime
 #nherit_cache = True


class current_user(AnsiFunction):
 #""The CURRENT_USER() SQL function."""

 #ype = sqltypes.String
 #nherit_cache = True


class localtime(AnsiFunction):
 #""The localtime() SQL function."""

 #ype = sqltypes.DateTime
 #nherit_cache = True


class localtimestamp(AnsiFunction):
 #""The localtimestamp() SQL function."""

 #ype = sqltypes.DateTime
 #nherit_cache = True


class session_user(AnsiFunction):
 #""The SESSION_USER() SQL function."""

 #ype = sqltypes.String
 #nherit_cache = True


class sysdate(AnsiFunction):
 #""The SYSDATE() SQL function."""

 #ype = sqltypes.DateTime
 #nherit_cache = True


class user(AnsiFunction):
 #""The USER() SQL function."""

 #ype = sqltypes.String
 #nherit_cache = True


class array_agg(GenericFunction):
 #""Support for the ARRAY_AGG function.

 #he ``func.array_agg(expr)`` construct returns an expression of
 #ype :class:`_types.ARRAY`.

 #.g.::

 #tmt = select(func.array_agg(table.c.values)[2:5])

 #. versionadded:: 1.1

 #. seealso::

 #func:`_postgresql.array_agg` - PostgreSQL-specific version that
 #eturns :class:`_postgresql.ARRAY`, which has PG-specific operators
 #dded.

 #""

 #ype = sqltypes.ARRAY
 #nherit_cache = True

 #ef __init__(self, *args, **kwargs):
 #rgs = [
 #oercions.expect(
 #oles.ExpressionElementRole, c, apply_propagate_attrs=self
 #
 #or c in args
 #

 #efault_array_type = kwargs.pop("_default_array_type", sqltypes.ARRAY)
 #f "type_" not in kwargs:

 #ype_from_args = _type_from_args(args)
 #f isinstance(type_from_args, sqltypes.ARRAY):
 #wargs["type_"] = type_from_args
 #lse:
 #wargs["type_"] = default_array_type(type_from_args)
 #wargs["_parsed_args"] = args
 #uper(array_agg, self).__init__(*args, **kwargs)


class OrderedSetAgg(GenericFunction):
 #""Define a function where the return type is based on the sort
 #xpression type as defined by the expression passed to the
 #meth:`.FunctionElement.within_group` method."""

 #rray_for_multi_clause = False
 #nherit_cache = True

 #ef within_group_type(self, within_group):
 #unc_clauses = self.clause_expr.element
 #rder_by = sqlutil.unwrap_order_by(within_group.order_by)
 #f self.array_for_multi_clause and len(func_clauses.clauses) > 1:
 #eturn sqltypes.ARRAY(order_by[0].type)
 #lse:
 #eturn order_by[0].type


class mode(OrderedSetAgg):
 #""Implement the ``mode`` ordered-set aggregate function.

 #his function must be used with the :meth:`.FunctionElement.within_group`
 #odifier to supply a sort expression to operate upon.

 #he return type of this function is the same as the sort expression.

 #. versionadded:: 1.1

 #""

 #nherit_cache = True


class percentile_cont(OrderedSetAgg):
 #""Implement the ``percentile_cont`` ordered-set aggregate function.

 #his function must be used with the :meth:`.FunctionElement.within_group`
 #odifier to supply a sort expression to operate upon.

 #he return type of this function is the same as the sort expression,
 #r if the arguments are an array, an :class:`_types.ARRAY` of the sort
 #xpression's type.

 #. versionadded:: 1.1

 #""

 #rray_for_multi_clause = True
 #nherit_cache = True


class percentile_disc(OrderedSetAgg):
 #""Implement the ``percentile_disc`` ordered-set aggregate function.

 #his function must be used with the :meth:`.FunctionElement.within_group`
 #odifier to supply a sort expression to operate upon.

 #he return type of this function is the same as the sort expression,
 #r if the arguments are an array, an :class:`_types.ARRAY` of the sort
 #xpression's type.

 #. versionadded:: 1.1

 #""

 #rray_for_multi_clause = True
 #nherit_cache = True


class rank(GenericFunction):
 #""Implement the ``rank`` hypothetical-set aggregate function.

 #his function must be used with the :meth:`.FunctionElement.within_group`
 #odifier to supply a sort expression to operate upon.

 #he return type of this function is :class:`.Integer`.

 #. versionadded:: 1.1

 #""

 #ype = sqltypes.Integer()
 #nherit_cache = True


class dense_rank(GenericFunction):
 #""Implement the ``dense_rank`` hypothetical-set aggregate function.

 #his function must be used with the :meth:`.FunctionElement.within_group`
 #odifier to supply a sort expression to operate upon.

 #he return type of this function is :class:`.Integer`.

 #. versionadded:: 1.1

 #""

 #ype = sqltypes.Integer()
 #nherit_cache = True


class percent_rank(GenericFunction):
 #""Implement the ``percent_rank`` hypothetical-set aggregate function.

 #his function must be used with the :meth:`.FunctionElement.within_group`
 #odifier to supply a sort expression to operate upon.

 #he return type of this function is :class:`.Numeric`.

 #. versionadded:: 1.1

 #""

 #ype = sqltypes.Numeric()
 #nherit_cache = True


class cume_dist(GenericFunction):
 #""Implement the ``cume_dist`` hypothetical-set aggregate function.

 #his function must be used with the :meth:`.FunctionElement.within_group`
 #odifier to supply a sort expression to operate upon.

 #he return type of this function is :class:`.Numeric`.

 #. versionadded:: 1.1

 #""

 #ype = sqltypes.Numeric()
 #nherit_cache = True


class cube(GenericFunction):
 #"""Implement the ``CUBE`` grouping operation.

 #his function is used as part of the GROUP BY of a statement,
 #.g. :meth:`_expression.Select.group_by`::

 #tmt = select(
 #unc.sum(table.c.value), table.c.col_1, table.c.col_2
 #.group_by(func.cube(table.c.col_1, table.c.col_2))

 #. versionadded:: 1.2

 #""
 #has_args = True
 #nherit_cache = True


class rollup(GenericFunction):
 #"""Implement the ``ROLLUP`` grouping operation.

 #his function is used as part of the GROUP BY of a statement,
 #.g. :meth:`_expression.Select.group_by`::

 #tmt = select(
 #unc.sum(table.c.value), table.c.col_1, table.c.col_2
 #.group_by(func.rollup(table.c.col_1, table.c.col_2))

 #. versionadded:: 1.2

 #""
 #has_args = True
 #nherit_cache = True


class grouping_sets(GenericFunction):
 #"""Implement the ``GROUPING SETS`` grouping operation.

 #his function is used as part of the GROUP BY of a statement,
 #.g. :meth:`_expression.Select.group_by`::

 #tmt = select(
 #unc.sum(table.c.value), table.c.col_1, table.c.col_2
 #.group_by(func.grouping_sets(table.c.col_1, table.c.col_2))

 #n order to group by multiple sets, use the :func:`.tuple_` construct::

 #rom sqlalchemy import tuple_

 #tmt = select(
 #unc.sum(table.c.value),
 #able.c.col_1, table.c.col_2,
 #able.c.col_3
 #.group_by(
 #unc.grouping_sets(
 #uple_(table.c.col_1, table.c.col_2),
 #uple_(table.c.value, table.c.col_3),
 #
 #


 #. versionadded:: 1.2

 #""
 #has_args = True
 #nherit_cache = True
