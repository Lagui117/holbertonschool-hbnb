# sql/selectable.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""The :class:`_expression.FromClause` class of SQL expression elements,
representing
SQL tables and derived rowsets.

"""

import collections
import itertools
from operator import attrgetter

from . import coercions
from . import operators
from . import roles
from . import traversals
from . import type_api
from . import visitors
from .annotation import Annotated
from .annotation import SupportsCloneAnnotations
from .base import _clone
from .base import _cloned_difference
from .base import _cloned_intersection
from .base import _entity_namespace_key
from .base import _expand_cloned
from .base import _from_objects
from .base import _generative
from .base import _select_iterables
from .base import CacheableOptions
from .base import ColumnCollection
from .base import ColumnSet
from .base import CompileState
from .base import DedupeColumnCollection
from .base import Executable
from .base import Generative
from .base import HasCompileState
from .base import HasMemoized
from .base import Immutable
from .base import prefix_anon_map
from .coercions import _document_text_coercion
from .elements import _anonymous_label
from .elements import and_
from .elements import BindParameter
from .elements import BooleanClauseList
from .elements import ClauseElement
from .elements import ClauseList
from .elements import ColumnClause
from .elements import GroupedElement
from .elements import Grouping
from .elements import literal_column
from .elements import TableValuedColumn
from .elements import UnaryExpression
from .visitors import InternalTraversal
from .. import exc
from .. import util
from ..inspection import inspect


class _OffsetLimitParam(BindParameter):
 #nherit_cache = True

 #property
 #ef _limit_offset_value(self):
 #eturn self.effective_value


@util.deprecated(
 #1.4",
 #The standalone :func:`.subquery` function is deprecated "
 #and will be removed in a future release.  Use select().subquery().",
)
def subquery(alias, *args, **kwargs):
 #"""Return an :class:`.Subquery` object derived
 #rom a :class:`_expression.Select`.

 #param alias: the alias name for the subquery

 #param \*args, \**kwargs:  all other arguments are passed through to the
 #func:`_expression.select` function.

 #""
 #eturn Select.create_legacy_select(*args, **kwargs).subquery(alias)


class ReturnsRows(roles.ReturnsRowsRole, ClauseElement):
 #""The base-most class for Core constructs that have some concept of
 #olumns that can represent rows.

 #hile the SELECT statement and TABLE are the primary things we think
 #f in this category,  DML like INSERT, UPDATE and DELETE can also specify
 #ETURNING which means they can be used in CTEs and other forms, and
 #ostgreSQL has functions that return rows also.

 #. versionadded:: 1.4

 #""

 #is_returns_rows = True

    # sub-elements of returns_rows
 #is_from_clause = False
 #is_select_statement = False
 #is_lateral = False

 #property
 #ef selectable(self):
 #eturn self

 #property
 #ef _all_selected_columns(self):
 #""A sequence of column expression objects that represents the
 #selected" columns of this :class:`_expression.ReturnsRows`.

 #his is typically equivalent to .exported_columns except it is
 #elivered in the form of a straight sequence and not  keyed
 #class:`_expression.ColumnCollection`.

 #""
 #aise NotImplementedError()

 #property
 #ef exported_columns(self):
 #""A :class:`_expression.ColumnCollection`
 #hat represents the "exported"
 #olumns of this :class:`_expression.ReturnsRows`.

 #he "exported" columns represent the collection of
 #class:`_expression.ColumnElement`
 #xpressions that are rendered by this SQL
 #onstruct.   There are primary varieties which are the
 #FROM clause columns" of a FROM clause, such as a table, join,
 #r subquery, the "SELECTed columns", which are the columns in
 #he "columns clause" of a SELECT statement, and the RETURNING
 #olumns in a DML statement..

 #. versionadded:: 1.4

 #. seealso::

 #attr:`_expression.FromClause.exported_columns`

 #attr:`_expression.SelectBase.exported_columns`
 #""

 #aise NotImplementedError()


class Selectable(ReturnsRows):
 #""Mark a class as being selectable."""

 #_visit_name__ = "selectable"

 #s_selectable = True

 #ef _refresh_for_new_column(self, column):
 #aise NotImplementedError()

 #ef lateral(self, name=None):
 #""Return a LATERAL alias of this :class:`_expression.Selectable`.

 #he return value is the :class:`_expression.Lateral` construct also
 #rovided by the top-level :func:`_expression.lateral` function.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`lateral_selects` -  overview of usage.

 #""
 #eturn Lateral._construct(self, name)

 #util.deprecated(
 #1.4",
 #essage="The :meth:`.Selectable.replace_selectable` method is "
 #deprecated, and will be removed in a future release.  Similar "
 #functionality is available via the sqlalchemy.sql.visitors module.",
 #
 #util.preload_module("sqlalchemy.sql.util")
 #ef replace_selectable(self, old, alias):
 #""Replace all occurrences of :class:`_expression.FromClause`
 #old' with the given :class:`_expression.Alias`
 #bject, returning a copy of this :class:`_expression.FromClause`.

 #""
 #eturn util.preloaded.sql_util.ClauseAdapter(alias).traverse(self)

 #ef corresponding_column(self, column, require_embedded=False):
 #""Given a :class:`_expression.ColumnElement`, return the exported
 #class:`_expression.ColumnElement` object from the
 #attr:`_expression.Selectable.exported_columns`
 #ollection of this :class:`_expression.Selectable`
 #hich corresponds to that
 #riginal :class:`_expression.ColumnElement` via a common ancestor
 #olumn.

 #param column: the target :class:`_expression.ColumnElement`
 #o be matched.

 #param require_embedded: only return corresponding columns for
 #he given :class:`_expression.ColumnElement`, if the given
 #class:`_expression.ColumnElement`
 #s actually present within a sub-element
 #f this :class:`_expression.Selectable`.
 #ormally the column will match if
 #t merely shares a common ancestor with one of the exported
 #olumns of this :class:`_expression.Selectable`.

 #. seealso::

 #attr:`_expression.Selectable.exported_columns` - the
 #class:`_expression.ColumnCollection`
 #hat is used for the operation.

 #meth:`_expression.ColumnCollection.corresponding_column`
 # implementation
 #ethod.

 #""

 #eturn self.exported_columns.corresponding_column(
 #olumn, require_embedded
 #


class HasPrefixes(object):
 #prefixes = ()

 #has_prefixes_traverse_internals = [
 #"_prefixes", InternalTraversal.dp_prefix_sequence)
 #

 #_generative
 #_document_text_coercion(
 #expr",
 #:meth:`_expression.HasPrefixes.prefix_with`",
 #:paramref:`.HasPrefixes.prefix_with.*expr`",
 #
 #ef prefix_with(self, *expr, **kw):
 #"""Add one or more expressions following the statement keyword, i.e.
 #ELECT, INSERT, UPDATE, or DELETE. Generative.

 #his is used to support backend-specific prefix keywords such as those
 #rovided by MySQL.

 #.g.::

 #tmt = table.insert().prefix_with("LOW_PRIORITY", dialect="mysql")

            # MySQL 5.7 optimizer hints
 #tmt = select(table).prefix_with(
 #/*+ BKA(t1) */", dialect="mysql")

 #ultiple prefixes can be specified by multiple calls
 #o :meth:`_expression.HasPrefixes.prefix_with`.

 #param \*expr: textual or :class:`_expression.ClauseElement`
 #onstruct which
 #ill be rendered following the INSERT, UPDATE, or DELETE
 #eyword.
 #param \**kw: A single keyword 'dialect' is accepted.  This is an
 #ptional string dialect name which will
 #imit rendering of this prefix to only that dialect.

 #""
 #ialect = kw.pop("dialect", None)
 #f kw:
 #aise exc.ArgumentError(
 #Unsupported argument(s): %s" % ",".join(kw)
 #
 #elf._setup_prefixes(expr, dialect)

 #ef _setup_prefixes(self, prefixes, dialect=None):
 #elf._prefixes = self._prefixes + tuple(
 #
 #coercions.expect(roles.StatementOptionRole, p), dialect)
 #or p in prefixes
 #
 #


class HasSuffixes(object):
 #suffixes = ()

 #has_suffixes_traverse_internals = [
 #"_suffixes", InternalTraversal.dp_prefix_sequence)
 #

 #_generative
 #_document_text_coercion(
 #expr",
 #:meth:`_expression.HasSuffixes.suffix_with`",
 #:paramref:`.HasSuffixes.suffix_with.*expr`",
 #
 #ef suffix_with(self, *expr, **kw):
 #"""Add one or more expressions following the statement as a whole.

 #his is used to support backend-specific suffix keywords on
 #ertain constructs.

 #.g.::

 #tmt = select(col1, col2).cte().suffix_with(
 #cycle empno set y_cycle to 1 default 0", dialect="oracle")

 #ultiple suffixes can be specified by multiple calls
 #o :meth:`_expression.HasSuffixes.suffix_with`.

 #param \*expr: textual or :class:`_expression.ClauseElement`
 #onstruct which
 #ill be rendered following the target clause.
 #param \**kw: A single keyword 'dialect' is accepted.  This is an
 #ptional string dialect name which will
 #imit rendering of this suffix to only that dialect.

 #""
 #ialect = kw.pop("dialect", None)
 #f kw:
 #aise exc.ArgumentError(
 #Unsupported argument(s): %s" % ",".join(kw)
 #
 #elf._setup_suffixes(expr, dialect)

 #ef _setup_suffixes(self, suffixes, dialect=None):
 #elf._suffixes = self._suffixes + tuple(
 #
 #coercions.expect(roles.StatementOptionRole, p), dialect)
 #or p in suffixes
 #
 #


class HasHints(object):
 #hints = util.immutabledict()
 #statement_hints = ()

 #has_hints_traverse_internals = [
 #"_statement_hints", InternalTraversal.dp_statement_hint_list),
 #"_hints", InternalTraversal.dp_table_hint_list),
 #

 #ef with_statement_hint(self, text, dialect_name="*"):
 #""Add a statement hint to this :class:`_expression.Select` or
 #ther selectable object.

 #his method is similar to :meth:`_expression.Select.with_hint`
 #xcept that
 #t does not require an individual table, and instead applies to the
 #tatement as a whole.

 #ints here are specific to the backend database and may include
 #irectives such as isolation levels, file directives, fetch directives,
 #tc.

 #. versionadded:: 1.0.0

 #. seealso::

 #meth:`_expression.Select.with_hint`

 #meth:`_expression.Select.prefix_with` - generic SELECT prefixing
 #hich also can suit some database-specific HINT syntaxes such as
 #ySQL optimizer hints

 #""
 #eturn self.with_hint(None, text, dialect_name)

 #_generative
 #ef with_hint(self, selectable, text, dialect_name="*"):
 #"""Add an indexing or other executional context hint for the given
 #electable to this :class:`_expression.Select` or other selectable
 #bject.

 #he text of the hint is rendered in the appropriate
 #ocation for the database backend in use, relative
 #o the given :class:`_schema.Table` or :class:`_expression.Alias`
 #assed as the
 #`selectable`` argument. The dialect implementation
 #ypically uses Python string substitution syntax
 #ith the token ``%(name)s`` to render the name of
 #he table or alias. E.g. when using Oracle, the
 #ollowing::

 #elect(mytable).\
 #ith_hint(mytable, "index(%(name)s ix_mytable)")

 #ould render SQL as::

 #elect /*+ index(mytable ix_mytable) */ ... from mytable

 #he ``dialect_name`` option will limit the rendering of a particular
 #int to a particular backend. Such as, to add hints for both Oracle
 #nd Sybase simultaneously::

 #elect(mytable).\
 #ith_hint(mytable, "index(%(name)s ix_mytable)", 'oracle').\
 #ith_hint(mytable, "WITH INDEX ix_mytable", 'sybase')

 #. seealso::

 #meth:`_expression.Select.with_statement_hint`

 #""
 #f selectable is None:
 #elf._statement_hints += ((dialect_name, text),)
 #lse:
 #elf._hints = self._hints.union(
 #
 #
 #oercions.expect(roles.FromClauseRole, selectable),
 #ialect_name,
 #: text
 #
 #


class FromClause(roles.AnonymizedFromClauseRole, Selectable):
 #""Represent an element that can be used within the ``FROM``
 #lause of a ``SELECT`` statement.

 #he most common forms of :class:`_expression.FromClause` are the
 #class:`_schema.Table` and the :func:`_expression.select` constructs.  Key
 #eatures common to all :class:`_expression.FromClause` objects include:

 # a :attr:`.c` collection, which provides per-name access to a collection
 #f :class:`_expression.ColumnElement` objects.
 # a :attr:`.primary_key` attribute, which is a collection of all those
 #class:`_expression.ColumnElement`
 #bjects that indicate the ``primary_key`` flag.
 # Methods to generate various derivations of a "from" clause, including
 #meth:`_expression.FromClause.alias`,
 #meth:`_expression.FromClause.join`,
 #meth:`_expression.FromClause.select`.


 #""

 #_visit_name__ = "fromclause"
 #amed_with_column = False
 #hide_froms = []

 #chema = None
 #""Define the 'schema' attribute for this :class:`_expression.FromClause`.

 #his is typically ``None`` for most objects except that of
 #class:`_schema.Table`, where it is taken as the value of the
 #paramref:`_schema.Table.schema` argument.

 #""

 #s_selectable = True
 #is_from_clause = True
 #is_join = False

 #use_schema_map = False

 #util.deprecated_params(
 #hereclause=(
 #2.0",
 #The :paramref:`_sql.FromClause.select().whereclause` parameter "
 #is deprecated and will be removed in version 2.0.  "
 #Please make use of "
 #the :meth:`.Select.where` "
 #method to add WHERE criteria to the SELECT statement.",
 #,
 #wargs=(
 #2.0",
 #The :meth:`_sql.FromClause.select` method will no longer accept "
 #keyword arguments in version 2.0.  Please use generative methods "
 #from the "
 #:class:`_sql.Select` construct in order to apply additional "
 #modifications.",
 #,
 #
 #ef select(self, whereclause=None, **kwargs):
 #"""Return a SELECT of this :class:`_expression.FromClause`.


 #.g.::

 #tmt = some_table.select().where(some_table.c.id == 5)

 #param whereclause: a WHERE clause, equivalent to calling the
 #meth:`_sql.Select.where` method.

 #param \**kwargs: additional keyword arguments are passed to the
 #egacy constructor for :class:`_sql.Select` described at
 #meth:`_sql.Select.create_legacy_select`.

 #. seealso::

 #func:`_expression.select` - general purpose
 #ethod which allows for arbitrary column lists.

 #""
 #f whereclause is not None:
 #wargs["whereclause"] = whereclause
 #eturn Select._create_select_from_fromclause(self, [self], **kwargs)

 #ef join(self, right, onclause=None, isouter=False, full=False):
 #""Return a :class:`_expression.Join` from this
 #class:`_expression.FromClause`
 #o another :class:`FromClause`.

 #.g.::

 #rom sqlalchemy import join

 # = user_table.join(address_table,
 #ser_table.c.id == address_table.c.user_id)
 #tmt = select(user_table).select_from(j)

 #ould emit SQL along the lines of::

 #ELECT user.id, user.name FROM user
 #OIN address ON user.id = address.user_id

 #param right: the right side of the join; this is any
 #class:`_expression.FromClause` object such as a
 #class:`_schema.Table` object, and
 #ay also be a selectable-compatible object such as an ORM-mapped
 #lass.

 #param onclause: a SQL expression representing the ON clause of the
 #oin.  If left at ``None``, :meth:`_expression.FromClause.join`
 #ill attempt to
 #oin the two tables based on a foreign key relationship.

 #param isouter: if True, render a LEFT OUTER JOIN, instead of JOIN.

 #param full: if True, render a FULL OUTER JOIN, instead of LEFT OUTER
 #OIN.  Implies :paramref:`.FromClause.join.isouter`.

 #. versionadded:: 1.1

 #. seealso::

 #func:`_expression.join` - standalone function

 #class:`_expression.Join` - the type of object produced

 #""

 #eturn Join(self, right, onclause, isouter, full)

 #ef outerjoin(self, right, onclause=None, full=False):
 #""Return a :class:`_expression.Join` from this
 #class:`_expression.FromClause`
 #o another :class:`FromClause`, with the "isouter" flag set to
 #rue.

 #.g.::

 #rom sqlalchemy import outerjoin

 # = user_table.outerjoin(address_table,
 #ser_table.c.id == address_table.c.user_id)

 #he above is equivalent to::

 # = user_table.join(
 #ddress_table,
 #ser_table.c.id == address_table.c.user_id,
 #souter=True)

 #param right: the right side of the join; this is any
 #class:`_expression.FromClause` object such as a
 #class:`_schema.Table` object, and
 #ay also be a selectable-compatible object such as an ORM-mapped
 #lass.

 #param onclause: a SQL expression representing the ON clause of the
 #oin.  If left at ``None``, :meth:`_expression.FromClause.join`
 #ill attempt to
 #oin the two tables based on a foreign key relationship.

 #param full: if True, render a FULL OUTER JOIN, instead of
 #EFT OUTER JOIN.

 #. versionadded:: 1.1

 #. seealso::

 #meth:`_expression.FromClause.join`

 #class:`_expression.Join`

 #""

 #eturn Join(self, right, onclause, True, full)

 #ef alias(self, name=None, flat=False):
 #""Return an alias of this :class:`_expression.FromClause`.

 #.g.::

 #2 = some_table.alias('a2')

 #he above code creates an :class:`_expression.Alias`
 #bject which can be used
 #s a FROM clause in any SELECT statement.

 #. seealso::

 #ref:`core_tutorial_aliases`

 #func:`_expression.alias`

 #""

 #eturn Alias._construct(self, name)

 #util.preload_module("sqlalchemy.sql.sqltypes")
 #ef table_valued(self):
 #""Return a :class:`_sql.TableValuedColumn` object for this
 #class:`_expression.FromClause`.

 # :class:`_sql.TableValuedColumn` is a :class:`_sql.ColumnElement` that
 #epresents a complete row in a table. Support for this construct is
 #ackend dependent, and is supported in various forms by backends
 #uch as PostgreSQL, Oracle and SQL Server.

 #.g.::

 #>> from sqlalchemy import select, column, func, table
 #>> a = table("a", column("id"), column("x"), column("y"))
 #>> stmt = select(func.row_to_json(a.table_valued()))
 #>> print(stmt)
 #ELECT row_to_json(a) AS row_to_json_1
 #ROM a

 #. versionadded:: 1.4.0b2

 #. seealso::

 #ref:`tutorial_functions` - in the :ref:`unified_tutorial`

 #""
 #eturn TableValuedColumn(self, type_api.TABLEVALUE)

 #ef tablesample(self, sampling, name=None, seed=None):
 #""Return a TABLESAMPLE alias of this :class:`_expression.FromClause`.

 #he return value is the :class:`_expression.TableSample`
 #onstruct also
 #rovided by the top-level :func:`_expression.tablesample` function.

 #. versionadded:: 1.1

 #. seealso::

 #func:`_expression.tablesample` - usage guidelines and parameters

 #""
 #eturn TableSample._construct(self, sampling, name, seed)

 #ef is_derived_from(self, fromclause):
 #""Return ``True`` if this :class:`_expression.FromClause` is
 #derived' from the given ``FromClause``.

 #n example would be an Alias of a Table is derived from that Table.

 #""
        # this is essentially an "identity" check in the base class.
        # Other constructs override this to traverse through
        # contained elements.
 #eturn fromclause in self._cloned_set

 #ef _is_lexical_equivalent(self, other):
 #""Return ``True`` if this :class:`_expression.FromClause` and
 #he other represent the same lexical identity.

 #his tests if either one is a copy of the other, or
 #f they are the same via annotation identity.

 #""
 #eturn self._cloned_set.intersection(other._cloned_set)

 #property
 #ef description(self):
 #""A brief description of this :class:`_expression.FromClause`.

 #sed primarily for error message formatting.

 #""
 #eturn getattr(self, "name", self.__class__.__name__ + " object")

 #ef _generate_fromclause_column_proxies(self, fromclause):
 #romclause._columns._populate_separate_keys(
 #ol._make_proxy(fromclause) for col in self.c
 #

 #property
 #ef exported_columns(self):
 #""A :class:`_expression.ColumnCollection`
 #hat represents the "exported"
 #olumns of this :class:`_expression.Selectable`.

 #he "exported" columns for a :class:`_expression.FromClause`
 #bject are synonymous
 #ith the :attr:`_expression.FromClause.columns` collection.

 #. versionadded:: 1.4

 #. seealso::

 #attr:`_expression.Selectable.exported_columns`

 #attr:`_expression.SelectBase.exported_columns`


 #""
 #eturn self.columns

 #util.memoized_property
 #ef columns(self):
 #""A named-based collection of :class:`_expression.ColumnElement`
 #bjects maintained by this :class:`_expression.FromClause`.

 #he :attr:`.columns`, or :attr:`.c` collection, is the gateway
 #o the construction of SQL expressions using table-bound or
 #ther selectable-bound columns::

 #elect(mytable).where(mytable.c.somecolumn == 5)

 #return: a :class:`.ColumnCollection` object.

 #""

 #f "_columns" not in self.__dict__:
 #elf._init_collections()
 #elf._populate_column_collection()
 #eturn self._columns.as_immutable()

 #property
 #ef entity_namespace(self):
 #""Return a namespace used for name-based access in SQL expressions.

 #his is the namespace that is used to resolve "filter_by()" type
 #xpressions, such as::

 #tmt.filter_by(address='some address')

 #t defaults to the ``.c`` collection, however internally it can
 #e overridden using the "entity_namespace" annotation to deliver
 #lternative results.

 #""
 #eturn self.columns

 #util.memoized_property
 #ef primary_key(self):
 #""Return the iterable collection of :class:`_schema.Column` objects
 #hich comprise the primary key of this :class:`_selectable.FromClause`.

 #or a :class:`_schema.Table` object, this collection is represented
 #y the :class:`_schema.PrimaryKeyConstraint` which itself is an
 #terable collection of :class:`_schema.Column` objects.

 #""
 #elf._init_collections()
 #elf._populate_column_collection()
 #eturn self.primary_key

 #util.memoized_property
 #ef foreign_keys(self):
 #""Return the collection of :class:`_schema.ForeignKey` marker objects
 #hich this FromClause references.

 #ach :class:`_schema.ForeignKey` is a member of a
 #class:`_schema.Table`-wide
 #class:`_schema.ForeignKeyConstraint`.

 #. seealso::

 #attr:`_schema.Table.foreign_key_constraints`

 #""
 #elf._init_collections()
 #elf._populate_column_collection()
 #eturn self.foreign_keys

 #ef _reset_column_collection(self):
 #""Reset the attributes linked to the ``FromClause.c`` attribute.

 #his collection is separate from all the other memoized things
 #s it has shown to be sensitive to being cleared out in situations
 #here enclosing code, typically in a replacement traversal scenario,
 #as already established strong relationships
 #ith the exported columns.

 #he collection is cleared for the case where a table is having a
 #olumn added to it as well as within a Join during copy internals.

 #""

 #or key in ["_columns", "columns", "primary_key", "foreign_keys"]:
 #elf.__dict__.pop(key, None)

 # = property(
 #ttrgetter("columns"),
 #oc="""
 # named-based collection of :class:`_expression.ColumnElement`
 #bjects maintained by this :class:`_expression.FromClause`.

 #he :attr:`_sql.FromClause.c` attribute is an alias for the
 #attr:`_sql.FromClause.columns` atttribute.

 #return: a :class:`.ColumnCollection`

 #"",
 #
 #select_iterable = property(attrgetter("columns"))

 #ef _init_collections(self):
 #ssert "_columns" not in self.__dict__
 #ssert "primary_key" not in self.__dict__
 #ssert "foreign_keys" not in self.__dict__

 #elf._columns = ColumnCollection()
 #elf.primary_key = ColumnSet()
 #elf.foreign_keys = set()

 #property
 #ef _cols_populated(self):
 #eturn "_columns" in self.__dict__

 #ef _populate_column_collection(self):
 #""Called on subclasses to establish the .c collection.

 #ach implementation has a different way of establishing
 #his collection.

 #""

 #ef _refresh_for_new_column(self, column):
 #""Given a column added to the .c collection of an underlying
 #electable, produce the local version of that column, assuming this
 #electable ultimately should proxy this column.

 #his is used to "ping" a derived selectable to add a new column
 #o its .c. collection when a Column has been added to one of the
 #able objects it ultimately derives from.

 #f the given selectable hasn't populated its .c. collection yet,
 #t should at least pass on the message to the contained selectables,
 #ut it will return None.

 #his method is currently used by Declarative to allow Table
 #olumns to be added to a partially constructed inheritance
 #apping that may have already produced joins.  The method
 #sn't public right now, as the full span of implications
 #nd/or caveats aren't yet clear.

 #t's also possible that this functionality could be invoked by
 #efault via an event, which would require that
 #electables maintain a weak referencing collection of all
 #erivations.

 #""
 #elf._reset_column_collection()

 #ef _anonymous_fromclause(self, name=None, flat=False):
 #eturn self.alias(name=name)


LABEL_STYLE_NONE = util.symbol(
 #LABEL_STYLE_NONE",
 #""Label style indicating no automatic labeling should be applied to the
 #olumns clause of a SELECT statement.

 #elow, the columns named ``columna`` are both rendered as is, meaning that
 #he name ``columna`` can only refer to the first occurrence of this name
 #ithin a result set, as well as if the statement were used as a subquery::

 #>> from sqlalchemy import table, column, select, true, LABEL_STYLE_NONE
 #>> table1 = table("table1", column("columna"), column("columnb"))
 #>> table2 = table("table2", column("columna"), column("columnc"))
 #>> print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_NONE))
 #ELECT table1.columna, table1.columnb, table2.columna, table2.columnc
 #ROM table1 JOIN table2 ON true

 #sed with the :meth:`_sql.Select.set_label_style` method.

 #. versionadded:: 1.4

""",  # noqa E501
)

LABEL_STYLE_TABLENAME_PLUS_COL = util.symbol(
 #LABEL_STYLE_TABLENAME_PLUS_COL",
 #""Label style indicating all columns should be labeled as
 #`<tablename>_<columnname>`` when generating the columns clause of a SELECT
 #tatement, to disambiguate same-named columns referenced from different
 #ables, aliases, or subqueries.

 #elow, all column names are given a label so that the two same-named
 #olumns ``columna`` are disambiguated as ``table1_columna`` and
 #`table2_columna`::

 #>> from sqlalchemy import table, column, select, true, LABEL_STYLE_TABLENAME_PLUS_COL
 #>> table1 = table("table1", column("columna"), column("columnb"))
 #>> table2 = table("table2", column("columna"), column("columnc"))
 #>> print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL))
 #ELECT table1.columna AS table1_columna, table1.columnb AS table1_columnb, table2.columna AS table2_columna, table2.columnc AS table2_columnc
 #ROM table1 JOIN table2 ON true

 #sed with the :meth:`_sql.GenerativeSelect.set_label_style` method.
 #quivalent to the legacy method ``Select.apply_labels()``;
 #data:`_sql.LABEL_STYLE_TABLENAME_PLUS_COL` is SQLAlchemy's legacy
 #uto-labeling style. :data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY` provides a
 #ess intrusive approach to disambiguation of same-named column expressions.


 #. versionadded:: 1.4

""",  # noqa E501
)


LABEL_STYLE_DISAMBIGUATE_ONLY = util.symbol(
 #LABEL_STYLE_DISAMBIGUATE_ONLY",
 #""Label style indicating that columns with a name that conflicts with
 #n existing name should be labeled with a semi-anonymizing label
 #hen generating the columns clause of a SELECT statement.

 #elow, most column names are left unaffected, except for the second
 #ccurrence of the name ``columna``, which is labeled using the
 #abel ``columna_1`` to disambiguate it from that of ``tablea.columna``::

 #>> from sqlalchemy import table, column, select, true, LABEL_STYLE_DISAMBIGUATE_ONLY
 #>> table1 = table("table1", column("columna"), column("columnb"))
 #>> table2 = table("table2", column("columna"), column("columnc"))
 #>> print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_DISAMBIGUATE_ONLY))
 #ELECT table1.columna, table1.columnb, table2.columna AS columna_1, table2.columnc
 #ROM table1 JOIN table2 ON true

 #sed with the :meth:`_sql.GenerativeSelect.set_label_style` method,
 #data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY` is the default labeling style
 #or all SELECT statements outside of :term:`1.x style` ORM queries.

 #. versionadded:: 1.4

""",  # noqa: E501,
)


LABEL_STYLE_DEFAULT = LABEL_STYLE_DISAMBIGUATE_ONLY
"""The default label style, refers to
:data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY`.

.. versionadded:: 1.4

"""


class Join(roles.DMLTableRole, FromClause):
 #""Represent a ``JOIN`` construct between two
 #class:`_expression.FromClause`
 #lements.

 #he public constructor function for :class:`_expression.Join`
 #s the module-level
 #func:`_expression.join()` function, as well as the
 #meth:`_expression.FromClause.join` method
 #f any :class:`_expression.FromClause` (e.g. such as
 #class:`_schema.Table`).

 #. seealso::

 #func:`_expression.join`

 #meth:`_expression.FromClause.join`

 #""

 #_visit_name__ = "join"

 #traverse_internals = [
 #"left", InternalTraversal.dp_clauseelement),
 #"right", InternalTraversal.dp_clauseelement),
 #"onclause", InternalTraversal.dp_clauseelement),
 #"isouter", InternalTraversal.dp_boolean),
 #"full", InternalTraversal.dp_boolean),
 #

 #is_join = True

 #ef __init__(self, left, right, onclause=None, isouter=False, full=False):
 #""Construct a new :class:`_expression.Join`.

 #he usual entrypoint here is the :func:`_expression.join`
 #unction or the :meth:`_expression.FromClause.join` method of any
 #class:`_expression.FromClause` object.

 #""
 #elf.left = coercions.expect(
 #oles.FromClauseRole, left, deannotate=True
 #
 #elf.right = coercions.expect(
 #oles.FromClauseRole, right, deannotate=True
 #.self_group()

 #f onclause is None:
 #elf.onclause = self._match_primaries(self.left, self.right)
 #lse:
            # note: taken from If91f61527236fd4d7ae3cad1f24c38be921c90ba
            # not merged yet
 #elf.onclause = coercions.expect(
 #oles.OnClauseRole, onclause
 #.self_group(against=operators._asbool)

 #elf.isouter = isouter
 #elf.full = full

 #classmethod
 #ef _create_outerjoin(cls, left, right, onclause=None, full=False):
 #""Return an ``OUTER JOIN`` clause element.

 #he returned object is an instance of :class:`_expression.Join`.

 #imilar functionality is also available via the
 #meth:`_expression.FromClause.outerjoin` method on any
 #class:`_expression.FromClause`.

 #param left: The left side of the join.

 #param right: The right side of the join.

 #param onclause:  Optional criterion for the ``ON`` clause, is
 #erived from foreign key relationships established between
 #eft and right otherwise.

 #o chain joins together, use the :meth:`_expression.FromClause.join`
 #r
 #meth:`_expression.FromClause.outerjoin` methods on the resulting
 #class:`_expression.Join` object.

 #""
 #eturn cls(left, right, onclause, isouter=True, full=full)

 #classmethod
 #ef _create_join(
 #ls, left, right, onclause=None, isouter=False, full=False
 #:
 #""Produce a :class:`_expression.Join` object, given two
 #class:`_expression.FromClause`
 #xpressions.

 #.g.::

 # = join(user_table, address_table,
 #ser_table.c.id == address_table.c.user_id)
 #tmt = select(user_table).select_from(j)

 #ould emit SQL along the lines of::

 #ELECT user.id, user.name FROM user
 #OIN address ON user.id = address.user_id

 #imilar functionality is available given any
 #class:`_expression.FromClause` object (e.g. such as a
 #class:`_schema.Table`) using
 #he :meth:`_expression.FromClause.join` method.

 #param left: The left side of the join.

 #param right: the right side of the join; this is any
 #class:`_expression.FromClause` object such as a
 #class:`_schema.Table` object, and
 #ay also be a selectable-compatible object such as an ORM-mapped
 #lass.

 #param onclause: a SQL expression representing the ON clause of the
 #oin.  If left at ``None``, :meth:`_expression.FromClause.join`
 #ill attempt to
 #oin the two tables based on a foreign key relationship.

 #param isouter: if True, render a LEFT OUTER JOIN, instead of JOIN.

 #param full: if True, render a FULL OUTER JOIN, instead of JOIN.

 #. versionadded:: 1.1

 #. seealso::

 #meth:`_expression.FromClause.join` - method form,
 #ased on a given left side.

 #class:`_expression.Join` - the type of object produced.

 #""

 #eturn cls(left, right, onclause, isouter, full)

 #property
 #ef description(self):
 #eturn "Join object on %s(%d) and %s(%d)" % (
 #elf.left.description,
 #d(self.left),
 #elf.right.description,
 #d(self.right),
 #

 #ef is_derived_from(self, fromclause):
 #eturn (
            # use hash() to ensure direct comparison to annotated works
            # as well
 #ash(fromclause) == hash(self)
 #r self.left.is_derived_from(fromclause)
 #r self.right.is_derived_from(fromclause)
 #

 #ef self_group(self, against=None):
 #eturn FromGrouping(self)

 #util.preload_module("sqlalchemy.sql.util")
 #ef _populate_column_collection(self):
 #qlutil = util.preloaded.sql_util
 #olumns = [c for c in self.left.columns] + [
 # for c in self.right.columns
 #

 #elf.primary_key.extend(
 #qlutil.reduce_columns(
 #c for c in columns if c.primary_key), self.onclause
 #
 #
 #elf._columns._populate_separate_keys(
 #col._tq_key_label, col) for col in columns
 #
 #elf.foreign_keys.update(
 #tertools.chain(*[col.foreign_keys for col in columns])
 #

 #ef _refresh_for_new_column(self, column):
 #uper(Join, self)._refresh_for_new_column(column)
 #elf.left._refresh_for_new_column(column)
 #elf.right._refresh_for_new_column(column)

 #ef _match_primaries(self, left, right):
 #f isinstance(left, Join):
 #eft_right = left.right
 #lse:
 #eft_right = None
 #eturn self._join_condition(left, right, a_subset=left_right)

 #classmethod
 #ef _join_condition(
 #ls, a, b, a_subset=None, consider_as_foreign_keys=None
 #:
 #""Create a join condition between two tables or selectables.

 #.g.::

 #oin_condition(tablea, tableb)

 #ould produce an expression along the lines of::

 #ablea.c.id==tableb.c.tablea_id

 #he join is determined based on the foreign key relationships
 #etween the two selectables.   If there are multiple ways
 #o join, or no way to join, an error is raised.

 #param a_subset: An optional expression that is a sub-component
 #f ``a``.  An attempt will be made to join to just this sub-component
 #irst before looking at the full ``a`` construct, and if found
 #ill be successful even if there are other ways to join to ``a``.
 #his allows the "right side" of a join to be passed thereby
 #roviding a "natural join".

 #""
 #onstraints = cls._joincond_scan_left_right(
 #, a_subset, b, consider_as_foreign_keys
 #

 #f len(constraints) > 1:
 #ls._joincond_trim_constraints(
 #, b, constraints, consider_as_foreign_keys
 #

 #f len(constraints) == 0:
 #f isinstance(b, FromGrouping):
 #int = (
 # Perhaps you meant to convert the right side to a "
 #subquery using alias()?"
 #
 #lse:
 #int = ""
 #aise exc.NoForeignKeysError(
 #Can't find any foreign key relationships "
 #between '%s' and '%s'.%s"
 # (a.description, b.description, hint)
 #

 #rit = [(x == y) for x, y in list(constraints.values())[0]]
 #f len(crit) == 1:
 #eturn crit[0]
 #lse:
 #eturn and_(*crit)

 #classmethod
 #ef _can_join(cls, left, right, consider_as_foreign_keys=None):
 #f isinstance(left, Join):
 #eft_right = left.right
 #lse:
 #eft_right = None

 #onstraints = cls._joincond_scan_left_right(
 #=left,
 #=right,
 #_subset=left_right,
 #onsider_as_foreign_keys=consider_as_foreign_keys,
 #

 #eturn bool(constraints)

 #classmethod
 #util.preload_module("sqlalchemy.sql.util")
 #ef _joincond_scan_left_right(
 #ls, a, a_subset, b, consider_as_foreign_keys
 #:
 #ql_util = util.preloaded.sql_util

 # = coercions.expect(roles.FromClauseRole, a)
 # = coercions.expect(roles.FromClauseRole, b)

 #onstraints = collections.defaultdict(list)

 #or left in (a_subset, a):
 #f left is None:
 #ontinue
 #or fk in sorted(
 #.foreign_keys, key=lambda fk: fk.parent._creation_order
 #:
 #f (
 #onsider_as_foreign_keys is not None
 #nd fk.parent not in consider_as_foreign_keys
 #:
 #ontinue
 #ry:
 #ol = fk.get_referent(left)
 #xcept exc.NoReferenceError as nrte:
 #able_names = {t.name for t in sql_util.find_tables(left)}
 #f nrte.table_name in table_names:
 #aise
 #lse:
 #ontinue

 #f col is not None:
 #onstraints[fk.constraint].append((col, fk.parent))
 #f left is not b:
 #or fk in sorted(
 #eft.foreign_keys, key=lambda fk: fk.parent._creation_order
 #:
 #f (
 #onsider_as_foreign_keys is not None
 #nd fk.parent not in consider_as_foreign_keys
 #:
 #ontinue
 #ry:
 #ol = fk.get_referent(b)
 #xcept exc.NoReferenceError as nrte:
 #able_names = {t.name for t in sql_util.find_tables(b)}
 #f nrte.table_name in table_names:
 #aise
 #lse:
 #ontinue

 #f col is not None:
 #onstraints[fk.constraint].append((col, fk.parent))
 #f constraints:
 #reak
 #eturn constraints

 #classmethod
 #ef _joincond_trim_constraints(
 #ls, a, b, constraints, consider_as_foreign_keys
 #:
        # more than one constraint matched.  narrow down the list
        # to include just those FKCs that match exactly to
        # "consider_as_foreign_keys".
 #f consider_as_foreign_keys:
 #or const in list(constraints):
 #f set(f.parent for f in const.elements) != set(
 #onsider_as_foreign_keys
 #:
 #el constraints[const]

        # if still multiple constraints, but
        # they all refer to the exact same end result, use it.
 #f len(constraints) > 1:
 #edupe = set(tuple(crit) for crit in constraints.values())
 #f len(dedupe) == 1:
 #ey = list(constraints)[0]
 #onstraints = {key: constraints[key]}

 #f len(constraints) != 1:
 #aise exc.AmbiguousForeignKeysError(
 #Can't determine join between '%s' and '%s'; "
 #tables have more than one foreign key "
 #constraint relationship between them. "
 #Please specify the 'onclause' of this "
 #join explicitly." % (a.description, b.description)
 #

 #util.deprecated_params(
 #hereclause=(
 #2.0",
 #The :paramref:`_sql.Join.select().whereclause` parameter "
 #is deprecated and will be removed in version 2.0.  "
 #Please make use of "
 #the :meth:`.Select.where` "
 #method to add WHERE criteria to the SELECT statement.",
 #,
 #wargs=(
 #2.0",
 #The :meth:`_sql.Join.select` method will no longer accept "
 #keyword arguments in version 2.0.  Please use generative "
 #methods from the "
 #:class:`_sql.Select` construct in order to apply additional "
 #modifications.",
 #,
 #
 #ef select(self, whereclause=None, **kwargs):
 #"""Create a :class:`_expression.Select` from this
 #class:`_expression.Join`.

 #.g.::

 #tmt = table_a.join(table_b, table_a.c.id == table_b.c.a_id)

 #tmt = stmt.select()

 #he above will produce a SQL string resembling::

 #ELECT table_a.id, table_a.col, table_b.id, table_b.a_id
 #ROM table_a JOIN table_b ON table_a.id = table_b.a_id

 #param whereclause: WHERE criteria, same as calling
 #meth:`_sql.Select.where` on the resulting statement

 #param \**kwargs: additional keyword arguments are passed to the
 #egacy constructor for :class:`_sql.Select` described at
 #meth:`_sql.Select.create_legacy_select`.

 #""
 #ollist = [self.left, self.right]

 #f whereclause is not None:
 #wargs["whereclause"] = whereclause
 #eturn Select._create_select_from_fromclause(
 #elf, collist, **kwargs
 #.select_from(self)

 #property
 #util.deprecated_20(
 #:attr:`.Executable.bind`",
 #lternative="Bound metadata is being removed as of SQLAlchemy 2.0.",
 #nable_warnings=False,
 #
 #ef bind(self):
 #""Return the bound engine associated with either the left or right
 #ide of this :class:`_sql.Join`.

 #""

 #eturn self.left.bind or self.right.bind

 #util.preload_module("sqlalchemy.sql.util")
 #ef _anonymous_fromclause(self, name=None, flat=False):
 #qlutil = util.preloaded.sql_util
 #f flat:
 #f name is not None:
 #aise exc.ArgumentError("Can't send name argument with flat")
 #eft_a, right_a = (
 #elf.left._anonymous_fromclause(flat=True),
 #elf.right._anonymous_fromclause(flat=True),
 #
 #dapter = sqlutil.ClauseAdapter(left_a).chain(
 #qlutil.ClauseAdapter(right_a)
 #

 #eturn left_a.join(
 #ight_a,
 #dapter.traverse(self.onclause),
 #souter=self.isouter,
 #ull=self.full,
 #
 #lse:
 #eturn (
 #elf.select()
 #set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)
 #correlate(None)
 #alias(name)
 #

 #util.deprecated_20(
 #:meth:`_sql.Join.alias`",
 #lternative="Create a select + subquery, or alias the "
 #individual tables inside the join, instead.",
 #
 #ef alias(self, name=None, flat=False):
 #"""Return an alias of this :class:`_expression.Join`.

 #he default behavior here is to first produce a SELECT
 #onstruct from this :class:`_expression.Join`, then to produce an
 #class:`_expression.Alias` from that.  So given a join of the form::

 # = table_a.join(table_b, table_a.c.id == table_b.c.a_id)

 #he JOIN by itself would look like::

 #able_a JOIN table_b ON table_a.id = table_b.a_id

 #hereas the alias of the above, ``j.alias()``, would in a
 #ELECT context look like::

 #SELECT table_a.id AS table_a_id, table_b.id AS table_b_id,
 #able_b.a_id AS table_b_a_id
 #ROM table_a
 #OIN table_b ON table_a.id = table_b.a_id) AS anon_1

 #he equivalent long-hand form, given a :class:`_expression.Join`
 #bject ``j``, is::

 #rom sqlalchemy import select, alias
 # = alias(
 #elect(j.left, j.right).\
 #elect_from(j).\
 #et_label_style(LABEL_STYLE_TABLENAME_PLUS_COL).\
 #orrelate(False),
 #ame=name
 #

 #he selectable produced by :meth:`_expression.Join.alias`
 #eatures the same
 #olumns as that of the two individual selectables presented under
 # single name - the individual columns are "auto-labeled", meaning
 #he ``.c.`` collection of the resulting :class:`_expression.Alias`
 #epresents
 #he names of the individual columns using a
 #`<tablename>_<columname>`` scheme::

 #.c.table_a_id
 #.c.table_b_a_id

 #meth:`_expression.Join.alias` also features an alternate
 #ption for aliasing joins which produces no enclosing SELECT and
 #oes not normally apply labels to the column names.  The
 #`flat=True`` option will call :meth:`_expression.FromClause.alias`
 #gainst the left and right sides individually.
 #sing this option, no new ``SELECT`` is produced;
 #e instead, from a construct as below::

 # = table_a.join(table_b, table_a.c.id == table_b.c.a_id)
 # = j.alias(flat=True)

 #e get a result like this::

 #able_a AS table_a_1 JOIN table_b AS table_b_1 ON
 #able_a_1.id = table_b_1.a_id

 #he ``flat=True`` argument is also propagated to the contained
 #electables, so that a composite join such as::

 # = table_a.join(
 #able_b.join(table_c,
 #able_b.c.id == table_c.c.b_id),
 #able_b.c.a_id == table_a.c.id
 #.alias(flat=True)

 #ill produce an expression like::

 #able_a AS table_a_1 JOIN (
 #able_b AS table_b_1 JOIN table_c AS table_c_1
 #N table_b_1.id = table_c_1.b_id
 # ON table_a_1.id = table_b_1.a_id

 #he standalone :func:`_expression.alias` function as well as the
 #ase :meth:`_expression.FromClause.alias`
 #ethod also support the ``flat=True``
 #rgument as a no-op, so that the argument can be passed to the
 #`alias()`` method of any selectable.

 #param name: name given to the alias.

 #param flat: if True, produce an alias of the left and right
 #ides of this :class:`_expression.Join` and return the join of those
 #wo selectables.   This produces join expression that does not
 #nclude an enclosing SELECT.

 #. seealso::

 #ref:`core_tutorial_aliases`

 #func:`_expression.alias`

 #""
 #eturn self._anonymous_fromclause(flat=flat, name=name)

 #property
 #ef _hide_froms(self):
 #eturn itertools.chain(
 #[_from_objects(x.left, x.right) for x in self._cloned_set]
 #

 #property
 #ef _from_objects(self):
 #eturn [self] + self.left._from_objects + self.right._from_objects


class NoInit(object):
 #ef __init__(self, *arg, **kw):
 #aise NotImplementedError(
 #The %s class is not intended to be constructed "
 #directly.  Please use the %s() standalone "
 #function or the %s() method available from appropriate "
 #selectable objects."
 # (
 #elf.__class__.__name__,
 #elf.__class__.__name__.lower(),
 #elf.__class__.__name__.lower(),
 #
 #


# FromClause ->
#   AliasedReturnsRows
#        -> Alias   only for FromClause
#        -> Subquery  only for SelectBase
#        -> CTE only for HasCTE -> SelectBase, DML
#        -> Lateral -> FromClause, but we accept SelectBase
#           w/ non-deprecated coercion
#        -> TableSample -> only for FromClause
class AliasedReturnsRows(NoInit, FromClause):
 #""Base class of aliases against tables, subqueries, and other
 #electables."""

 #is_from_container = True
 #amed_with_column = True

 #supports_derived_columns = False

 #traverse_internals = [
 #"element", InternalTraversal.dp_clauseelement),
 #"name", InternalTraversal.dp_anon_name),
 #

 #classmethod
 #ef _construct(cls, *arg, **kw):
 #bj = cls.__new__(cls)
 #bj._init(*arg, **kw)
 #eturn obj

 #classmethod
 #ef _factory(cls, returnsrows, name=None):
 #""Base factory method.  Subclasses need to provide this."""
 #aise NotImplementedError()

 #ef _init(self, selectable, name=None):
 #elf.element = coercions.expect(
 #oles.ReturnsRowsRole, selectable, apply_propagate_attrs=self
 #
 #elf.element = selectable
 #elf._orig_name = name
 #f name is None:
 #f (
 #sinstance(selectable, FromClause)
 #nd selectable.named_with_column
 #:
 #ame = getattr(selectable, "name", None)
 #f isinstance(name, _anonymous_label):
 #ame = None
 #ame = _anonymous_label.safe_construct(id(self), name or "anon")
 #elf.name = name

 #ef _refresh_for_new_column(self, column):
 #uper(AliasedReturnsRows, self)._refresh_for_new_column(column)
 #elf.element._refresh_for_new_column(column)

 #property
 #ef description(self):
 #ame = self.name
 #f isinstance(name, _anonymous_label):
 #ame = "anon_1"

 #f util.py3k:
 #eturn name
 #lse:
 #eturn name.encode("ascii", "backslashreplace")

 #property
 #ef original(self):
 #""Legacy for dialects that are referring to Alias.original."""
 #eturn self.element

 #ef is_derived_from(self, fromclause):
 #f fromclause in self._cloned_set:
 #eturn True
 #eturn self.element.is_derived_from(fromclause)

 #ef _populate_column_collection(self):
 #elf.element._generate_fromclause_column_proxies(self)

 #ef _copy_internals(self, clone=_clone, **kw):
 #xisting_element = self.element

 #uper(AliasedReturnsRows, self)._copy_internals(clone=clone, **kw)

        # the element clone is usually against a Table that returns the
        # same object.  don't reset exported .c. collections and other
        # memoized details if it was not changed.  this saves a lot on
        # performance.
 #f existing_element is not self.element:
 #elf._reset_column_collection()

 #property
 #ef _from_objects(self):
 #eturn [self]

 #property
 #ef bind(self):
 #eturn self.element.bind


class Alias(roles.DMLTableRole, AliasedReturnsRows):
 #""Represents an table or selectable alias (AS).

 #epresents an alias, as typically applied to any table or
 #ub-select within a SQL statement using the ``AS`` keyword (or
 #ithout the keyword on certain databases such as Oracle).

 #his object is constructed from the :func:`_expression.alias` module
 #evel function as well as the :meth:`_expression.FromClause.alias`
 #ethod available
 #n all :class:`_expression.FromClause` subclasses.

 #. seealso::

 #meth:`_expression.FromClause.alias`

 #""

 #_visit_name__ = "alias"

 #nherit_cache = True

 #classmethod
 #ef _factory(cls, selectable, name=None, flat=False):
 #""Return an :class:`_expression.Alias` object.

 #n :class:`_expression.Alias` represents any
 #class:`_expression.FromClause`
 #ith an alternate name assigned within SQL, typically using the ``AS``
 #lause when generated, e.g. ``SELECT * FROM table AS aliasname``.

 #imilar functionality is available via the
 #meth:`_expression.FromClause.alias`
 #ethod available on all :class:`_expression.FromClause` subclasses.
 #n terms of
 # SELECT object as generated from the :func:`_expression.select`
 #unction, the :meth:`_expression.SelectBase.alias` method returns an
 #class:`_expression.Alias` or similar object which represents a named,
 #arenthesized subquery.

 #hen an :class:`_expression.Alias` is created from a
 #class:`_schema.Table` object,
 #his has the effect of the table being rendered
 #s ``tablename AS aliasname`` in a SELECT statement.

 #or :func:`_expression.select` objects, the effect is that of
 #reating a named subquery, i.e. ``(select ...) AS aliasname``.

 #he ``name`` parameter is optional, and provides the name
 #o use in the rendered SQL.  If blank, an "anonymous" name
 #ill be deterministically generated at compile time.
 #eterministic means the name is guaranteed to be unique against
 #ther constructs used in the same statement, and will also be the
 #ame name for each successive compilation of the same statement
 #bject.

 #param selectable: any :class:`_expression.FromClause` subclass,
 #uch as a table, select statement, etc.

 #param name: string name to be assigned as the alias.
 #f ``None``, a name will be deterministically generated
 #t compile time.

 #param flat: Will be passed through to if the given selectable
 #s an instance of :class:`_expression.Join` - see
 #meth:`_expression.Join.alias`
 #or details.

 #""
 #eturn coercions.expect(
 #oles.FromClauseRole, selectable, allow_select=True
 #.alias(name=name, flat=flat)


class TableValuedAlias(Alias):
 #""An alias against a "table valued" SQL function.

 #his construct provides for a SQL function that returns columns
 #o be used in the FROM clause of a SELECT statement.   The
 #bject is generated using the :meth:`_functions.FunctionElement.table_valued`
 #ethod, e.g.::

 #>> from sqlalchemy import select, func
 #>> fn = func.json_array_elements_text('["one", "two", "three"]').table_valued("value")
 #>> print(select(fn.c.value))
 #ELECT anon_1.value
 #ROM json_array_elements_text(:json_array_elements_text_1) AS anon_1

 #. versionadded:: 1.4.0b2

 #. seealso::

 #ref:`tutorial_functions_table_valued` - in the :ref:`unified_tutorial`

 #""  # noqa E501

 #_visit_name__ = "table_valued_alias"

 #supports_derived_columns = True
 #render_derived = False
 #render_derived_w_types = False

 #traverse_internals = [
 #"element", InternalTraversal.dp_clauseelement),
 #"name", InternalTraversal.dp_anon_name),
 #"_tableval_type", InternalTraversal.dp_type),
 #"_render_derived", InternalTraversal.dp_boolean),
 #"_render_derived_w_types", InternalTraversal.dp_boolean),
 #

 #ef _init(self, selectable, name=None, table_value_type=None):
 #uper(TableValuedAlias, self)._init(selectable, name=name)

 #elf._tableval_type = (
 #ype_api.TABLEVALUE
 #f table_value_type is None
 #lse table_value_type
 #

 #HasMemoized.memoized_attribute
 #ef column(self):
 #""Return a column expression representing this
 #class:`_sql.TableValuedAlias`.

 #his accessor is used to implement the
 #meth:`_functions.FunctionElement.column_valued` method. See that
 #ethod for further details.

 #.g.::

 #>> print(select(func.some_func().table_valued("value").column))
 #ELECT anon_1 FROM some_func() AS anon_1

 #. seealso::

 #meth:`_functions.FunctionElement.column_valued`

 #""

 #eturn TableValuedColumn(self, self._tableval_type)

 #ef alias(self, name=None):
 #""Return a new alias of this :class:`_sql.TableValuedAlias`.

 #his creates a distinct FROM object that will be distinguished
 #rom the original one when used in a SQL statement.

 #""

 #va = TableValuedAlias._construct(self, name=name)
 #f self._render_derived:
 #va._render_derived = True
 #va._render_derived_w_types = self._render_derived_w_types
 #eturn tva

 #ef lateral(self, name=None):
 #""Return a new :class:`_sql.TableValuedAlias` with the lateral flag set,
 #o that it renders as LATERAL.

 #. seealso::

 #func:`_expression.lateral`

 #""
 #va = self.alias(name=name)
 #va._is_lateral = True
 #eturn tva

 #ef render_derived(self, name=None, with_types=False):
 #""Apply "render derived" to this :class:`_sql.TableValuedAlias`.

 #his has the effect of the individual column names listed out
 #fter the alias name in the "AS" sequence, e.g.::

 #>> print(
 #..     select(
 #..         func.unnest(array(["one", "two", "three"])).
 #able_valued("x", with_ordinality="o").render_derived()
 #..     )
 #.. )
 #ELECT anon_1.x, anon_1.o
 #ROM unnest(ARRAY[%(param_1)s, %(param_2)s, %(param_3)s]) WITH ORDINALITY AS anon_1(x, o)

 #he ``with_types`` keyword will render column types inline within
 #he alias expression (this syntax currently applies to the
 #ostgreSQL database)::

 #>> print(
 #..     select(
 #..         func.json_to_recordset(
 #..             '[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]'
 #..         )
 #..         .table_valued(column("a", Integer), column("b", String))
 #..         .render_derived(with_types=True)
 #..     )
 #.. )
 #ELECT anon_1.a, anon_1.b FROM json_to_recordset(:json_to_recordset_1)
 #S anon_1(a INTEGER, b VARCHAR)

 #param name: optional string name that will be applied to the alias
 #enerated.  If left as None, a unique anonymizing name will be used.

 #param with_types: if True, the derived columns will include the
 #atatype specification with each column. This is a special syntax
 #urrently known to be required by PostgreSQL for some SQL functions.

 #""  # noqa E501

        # note: don't use the @_generative system here, keep a reference
        # to the original object.  otherwise you can have re-use of the
        # python id() of the original which can cause name conflicts if
        # a new anon-name grabs the same identifier as the local anon-name
        # (just saw it happen on CI)
 #ew_alias = TableValuedAlias._construct(self, name=name)
 #ew_alias._render_derived = True
 #ew_alias._render_derived_w_types = with_types
 #eturn new_alias


class Lateral(AliasedReturnsRows):
 #""Represent a LATERAL subquery.

 #his object is constructed from the :func:`_expression.lateral` module
 #evel function as well as the :meth:`_expression.FromClause.lateral`
 #ethod available
 #n all :class:`_expression.FromClause` subclasses.

 #hile LATERAL is part of the SQL standard, currently only more recent
 #ostgreSQL versions provide support for this keyword.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`lateral_selects` -  overview of usage.

 #""

 #_visit_name__ = "lateral"
 #is_lateral = True

 #nherit_cache = True

 #classmethod
 #ef _factory(cls, selectable, name=None):
 #""Return a :class:`_expression.Lateral` object.

 #class:`_expression.Lateral` is an :class:`_expression.Alias`
 #ubclass that represents
 # subquery with the LATERAL keyword applied to it.

 #he special behavior of a LATERAL subquery is that it appears in the
 #ROM clause of an enclosing SELECT, but may correlate to other
 #ROM clauses of that SELECT.   It is a special case of subquery
 #nly supported by a small number of backends, currently more recent
 #ostgreSQL versions.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`lateral_selects` -  overview of usage.

 #""
 #eturn coercions.expect(
 #oles.FromClauseRole, selectable, explicit_subquery=True
 #.lateral(name=name)


class TableSample(AliasedReturnsRows):
 #""Represent a TABLESAMPLE clause.

 #his object is constructed from the :func:`_expression.tablesample` module
 #evel function as well as the :meth:`_expression.FromClause.tablesample`
 #ethod
 #vailable on all :class:`_expression.FromClause` subclasses.

 #. versionadded:: 1.1

 #. seealso::

 #func:`_expression.tablesample`

 #""

 #_visit_name__ = "tablesample"

 #traverse_internals = AliasedReturnsRows._traverse_internals + [
 #"sampling", InternalTraversal.dp_clauseelement),
 #"seed", InternalTraversal.dp_clauseelement),
 #

 #classmethod
 #ef _factory(cls, selectable, sampling, name=None, seed=None):
 #""Return a :class:`_expression.TableSample` object.

 #class:`_expression.TableSample` is an :class:`_expression.Alias`
 #ubclass that represents
 # table with the TABLESAMPLE clause applied to it.
 #func:`_expression.tablesample`
 #s also available from the :class:`_expression.FromClause`
 #lass via the
 #meth:`_expression.FromClause.tablesample` method.

 #he TABLESAMPLE clause allows selecting a randomly selected approximate
 #ercentage of rows from a table. It supports multiple sampling methods,
 #ost commonly BERNOULLI and SYSTEM.

 #.g.::

 #rom sqlalchemy import func

 #electable = people.tablesample(
 #unc.bernoulli(1),
 #ame='alias',
 #eed=func.random())
 #tmt = select(selectable.c.people_id)

 #ssuming ``people`` with a column ``people_id``, the above
 #tatement would render as::

 #ELECT alias.people_id FROM
 #eople AS alias TABLESAMPLE bernoulli(:bernoulli_1)
 #EPEATABLE (random())

 #. versionadded:: 1.1

 #param sampling: a ``float`` percentage between 0 and 100 or
 #class:`_functions.Function`.

 #param name: optional alias name

 #param seed: any real-valued SQL expression.  When specified, the
 #EPEATABLE sub-clause is also rendered.

 #""
 #eturn coercions.expect(roles.FromClauseRole, selectable).tablesample(
 #ampling, name=name, seed=seed
 #

 #util.preload_module("sqlalchemy.sql.functions")
 #ef _init(self, selectable, sampling, name=None, seed=None):
 #unctions = util.preloaded.sql_functions
 #f not isinstance(sampling, functions.Function):
 #ampling = functions.func.system(sampling)

 #elf.sampling = sampling
 #elf.seed = seed
 #uper(TableSample, self)._init(selectable, name=name)

 #ef _get_method(self):
 #eturn self.sampling


class CTE(
 #oles.DMLTableRole,
 #oles.IsCTERole,
 #enerative,
 #asPrefixes,
 #asSuffixes,
 #liasedReturnsRows,
):
 #""Represent a Common Table Expression.

 #he :class:`_expression.CTE` object is obtained using the
 #meth:`_sql.SelectBase.cte` method from any SELECT statement. A less often
 #vailable syntax also allows use of the :meth:`_sql.HasCTE.cte` method
 #resent on :term:`DML` constructs such as :class:`_sql.Insert`,
 #class:`_sql.Update` and
 #class:`_sql.Delete`.   See the :meth:`_sql.HasCTE.cte` method for
 #sage details on CTEs.

 #. seealso::

 #ref:`tutorial_subqueries_ctes` - in the 2.0 tutorial

 #meth:`_sql.HasCTE.cte` - examples of calling styles

 #""

 #_visit_name__ = "cte"

 #traverse_internals = (
 #liasedReturnsRows._traverse_internals
 # [
 #"_cte_alias", InternalTraversal.dp_clauseelement),
 #"_restates", InternalTraversal.dp_clauseelement_list),
 #"recursive", InternalTraversal.dp_boolean),
 #
 # HasPrefixes._has_prefixes_traverse_internals
 # HasSuffixes._has_suffixes_traverse_internals
 #

 #classmethod
 #ef _factory(cls, selectable, name=None, recursive=False):
 #"""Return a new :class:`_expression.CTE`,
 #r Common Table Expression instance.

 #lease see :meth:`_expression.HasCTE.cte` for detail on CTE usage.

 #""
 #eturn coercions.expect(roles.HasCTERole, selectable).cte(
 #ame=name, recursive=recursive
 #

 #ef _init(
 #elf,
 #electable,
 #ame=None,
 #ecursive=False,
 #cte_alias=None,
 #restates=(),
 #prefixes=None,
 #suffixes=None,
 #:
 #elf.recursive = recursive
 #elf._cte_alias = _cte_alias
 #elf._restates = _restates
 #f _prefixes:
 #elf._prefixes = _prefixes
 #f _suffixes:
 #elf._suffixes = _suffixes
 #uper(CTE, self)._init(selectable, name=name)

 #ef _populate_column_collection(self):
 #f self._cte_alias is not None:
 #elf._cte_alias._generate_fromclause_column_proxies(self)
 #lse:
 #elf.element._generate_fromclause_column_proxies(self)

 #ef alias(self, name=None, flat=False):
 #""Return an :class:`_expression.Alias` of this
 #class:`_expression.CTE`.

 #his method is a CTE-specific specialization of the
 #meth:`_expression.FromClause.alias` method.

 #. seealso::

 #ref:`core_tutorial_aliases`

 #func:`_expression.alias`

 #""
 #eturn CTE._construct(
 #elf.element,
 #ame=name,
 #ecursive=self.recursive,
 #cte_alias=self,
 #prefixes=self._prefixes,
 #suffixes=self._suffixes,
 #

 #ef union(self, other):
 #eturn CTE._construct(
 #elf.element.union(other),
 #ame=self.name,
 #ecursive=self.recursive,
 #restates=self._restates + (self,),
 #prefixes=self._prefixes,
 #suffixes=self._suffixes,
 #

 #ef union_all(self, other):
 #eturn CTE._construct(
 #elf.element.union_all(other),
 #ame=self.name,
 #ecursive=self.recursive,
 #restates=self._restates + (self,),
 #prefixes=self._prefixes,
 #suffixes=self._suffixes,
 #


class HasCTE(roles.HasCTERole):
 #""Mixin that declares a class to include CTE support.

 #. versionadded:: 1.1

 #""

 #has_ctes_traverse_internals = [
 #"_independent_ctes", InternalTraversal.dp_clauseelement_list),
 #

 #independent_ctes = ()

 #_generative
 #ef add_cte(self, cte):
 #""Add a :class:`_sql.CTE` to this statement object that will be
 #ndependently rendered even if not referenced in the statement
 #therwise.

 #his feature is useful for the use case of embedding a DML statement
 #uch as an INSERT or UPDATE as a CTE inline with a primary statement
 #hat may draw from its results indirectly; while PostgreSQL is known
 #o support this usage, it may not be supported by other backends.

 #.g.::

 #rom sqlalchemy import table, column, select
 # = table('t', column('c1'), column('c2'))

 #ns = t.insert().values({"c1": "x", "c2": "y"}).cte()

 #tmt = select(t).add_cte(ins)

 #ould render::

 #ITH anon_1 AS
 #INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))
 #ELECT t.c1, t.c2
 #ROM t

 #bove, the "anon_1" CTE is not referred towards in the SELECT
 #tatement, however still accomplishes the task of running an INSERT
 #tatement.

 #imilarly in a DML-related context, using the PostgreSQL
 #class:`_postgresql.Insert` construct to generate an "upsert"::

 #rom sqlalchemy import table, column
 #rom sqlalchemy.dialects.postgresql import insert

 # = table("t", column("c1"), column("c2"))

 #elete_statement_cte = (
 #.delete().where(t.c.c1 < 1).cte("deletions")
 #

 #nsert_stmt = insert(t).values({"c1": 1, "c2": 2})
 #pdate_statement = insert_stmt.on_conflict_do_update(
 #ndex_elements=[t.c.c1],
 #et_={
 #c1": insert_stmt.excluded.c1,
 #c2": insert_stmt.excluded.c2,
 #,
 #.add_cte(delete_statement_cte)

 #rint(update_statement)

 #he above statement renders as::

 #ITH deletions AS
 #DELETE FROM t WHERE t.c1 < %(c1_1)s)
 #NSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)
 #N CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2

 #. versionadded:: 1.4.21

 #""
 #te = coercions.expect(roles.IsCTERole, cte)
 #elf._independent_ctes += (cte,)

 #ef cte(self, name=None, recursive=False):
 #"""Return a new :class:`_expression.CTE`,
 #r Common Table Expression instance.

 #ommon table expressions are a SQL standard whereby SELECT
 #tatements can draw upon secondary statements specified along
 #ith the primary statement, using a clause called "WITH".
 #pecial semantics regarding UNION can also be employed to
 #llow "recursive" queries, where a SELECT statement can draw
 #pon the set of rows that have previously been selected.

 #TEs can also be applied to DML constructs UPDATE, INSERT
 #nd DELETE on some databases, both as a source of CTE rows
 #hen combined with RETURNING, as well as a consumer of
 #TE rows.

 #. versionchanged:: 1.1 Added support for UPDATE/INSERT/DELETE as
 #TE, CTEs added to UPDATE/INSERT/DELETE.

 #QLAlchemy detects :class:`_expression.CTE` objects, which are treated
 #imilarly to :class:`_expression.Alias` objects, as special elements
 #o be delivered to the FROM clause of the statement as well
 #s to a WITH clause at the top of the statement.

 #or special prefixes such as PostgreSQL "MATERIALIZED" and
 #NOT MATERIALIZED", the :meth:`_expression.CTE.prefix_with`
 #ethod may be
 #sed to establish these.

 #. versionchanged:: 1.3.13 Added support for prefixes.
 #n particular - MATERIALIZED and NOT MATERIALIZED.

 #param name: name given to the common table expression.  Like
 #meth:`_expression.FromClause.alias`, the name can be left as
 #`None`` in which case an anonymous symbol will be used at query
 #ompile time.
 #param recursive: if ``True``, will render ``WITH RECURSIVE``.
 # recursive common table expression is intended to be used in
 #onjunction with UNION ALL in order to derive rows
 #rom those already selected.

 #he following examples include two from PostgreSQL's documentation at
 #ttps://www.postgresql.org/docs/current/static/queries-with.html,
 #s well as additional examples.

 #xample 1, non recursive::

 #rom sqlalchemy import (Table, Column, String, Integer,
 #etaData, select, func)

 #etadata = MetaData()

 #rders = Table('orders', metadata,
 #olumn('region', String),
 #olumn('amount', Integer),
 #olumn('product', String),
 #olumn('quantity', Integer)
 #

 #egional_sales = select(
 #rders.c.region,
 #unc.sum(orders.c.amount).label('total_sales')
 #.group_by(orders.c.region).cte("regional_sales")


 #op_regions = select(regional_sales.c.region).\
 #here(
 #egional_sales.c.total_sales >
 #elect(
 #unc.sum(regional_sales.c.total_sales) / 10
 #
 #.cte("top_regions")

 #tatement = select(
 #rders.c.region,
 #rders.c.product,
 #unc.sum(orders.c.quantity).label("product_units"),
 #unc.sum(orders.c.amount).label("product_sales")
 #.where(orders.c.region.in_(
 #elect(top_regions.c.region)
 #).group_by(orders.c.region, orders.c.product)

 #esult = conn.execute(statement).fetchall()

 #xample 2, WITH RECURSIVE::

 #rom sqlalchemy import (Table, Column, String, Integer,
 #etaData, select, func)

 #etadata = MetaData()

 #arts = Table('parts', metadata,
 #olumn('part', String),
 #olumn('sub_part', String),
 #olumn('quantity', Integer),
 #

 #ncluded_parts = select(\
 #arts.c.sub_part, parts.c.part, parts.c.quantity\
 #.\
 #here(parts.c.part=='our part').\
 #te(recursive=True)


 #ncl_alias = included_parts.alias()
 #arts_alias = parts.alias()
 #ncluded_parts = included_parts.union_all(
 #elect(
 #arts_alias.c.sub_part,
 #arts_alias.c.part,
 #arts_alias.c.quantity
 #.\
 #here(parts_alias.c.part==incl_alias.c.sub_part)
 #

 #tatement = select(
 #ncluded_parts.c.sub_part,
 #unc.sum(included_parts.c.quantity).
 #abel('total_quantity')
 #.\
 #roup_by(included_parts.c.sub_part)

 #esult = conn.execute(statement).fetchall()

 #xample 3, an upsert using UPDATE and INSERT with CTEs::

 #rom datetime import date
 #rom sqlalchemy import (MetaData, Table, Column, Integer,
 #ate, select, literal, and_, exists)

 #etadata = MetaData()

 #isitors = Table('visitors', metadata,
 #olumn('product_id', Integer, primary_key=True),
 #olumn('date', Date, primary_key=True),
 #olumn('count', Integer),
 #

            # add 5 visitors for the product_id == 1
 #roduct_id = 1
 #ay = date.today()
 #ount = 5

 #pdate_cte = (
 #isitors.update()
 #where(and_(visitors.c.product_id == product_id,
 #isitors.c.date == day))
 #values(count=visitors.c.count + count)
 #returning(literal(1))
 #cte('update_cte')
 #

 #psert = visitors.insert().from_select(
 #visitors.c.product_id, visitors.c.date, visitors.c.count],
 #elect(literal(product_id), literal(day), literal(count))
 #where(~exists(update_cte.select()))
 #

 #onnection.execute(upsert)

 #. seealso::

 #meth:`_orm.Query.cte` - ORM version of
 #meth:`_expression.HasCTE.cte`.

 #""
 #eturn CTE._construct(self, name=name, recursive=recursive)


class Subquery(AliasedReturnsRows):
 #""Represent a subquery of a SELECT.

 # :class:`.Subquery` is created by invoking the
 #meth:`_expression.SelectBase.subquery` method, or for convenience the
 #meth:`_expression.SelectBase.alias` method, on any
 #class:`_expression.SelectBase` subclass
 #hich includes :class:`_expression.Select`,
 #class:`_expression.CompoundSelect`, and
 #class:`_expression.TextualSelect`.  As rendered in a FROM clause,
 #t represents the
 #ody of the SELECT statement inside of parenthesis, followed by the usual
 #AS <somename>" that defines all "alias" objects.

 #he :class:`.Subquery` object is very similar to the
 #class:`_expression.Alias`
 #bject and can be used in an equivalent way.    The difference between
 #class:`_expression.Alias` and :class:`.Subquery` is that
 #class:`_expression.Alias` always
 #ontains a :class:`_expression.FromClause` object whereas
 #class:`.Subquery`
 #lways contains a :class:`_expression.SelectBase` object.

 #. versionadded:: 1.4 The :class:`.Subquery` class was added which now
 #erves the purpose of providing an aliased version of a SELECT
 #tatement.

 #""

 #_visit_name__ = "subquery"

 #is_subquery = True

 #nherit_cache = True

 #classmethod
 #ef _factory(cls, selectable, name=None):
 #""Return a :class:`.Subquery` object."""
 #eturn coercions.expect(
 #oles.SelectStatementRole, selectable
 #.subquery(name=name)

 #util.deprecated(
 #1.4",
 #The :meth:`.Subquery.as_scalar` method, which was previously "
 #``Alias.as_scalar()`` prior to version 1.4, is deprecated and "
 #will be removed in a future release; Please use the "
 #:meth:`_expression.Select.scalar_subquery` method of the "
 #:func:`_expression.select` "
 #construct before constructing a subquery object, or with the ORM "
 #use the :meth:`_query.Query.scalar_subquery` method.",
 #
 #ef as_scalar(self):
 #eturn self.element.set_label_style(LABEL_STYLE_NONE).scalar_subquery()

 #ef _execute_on_connection(
 #elf,
 #onnection,
 #ultiparams,
 #arams,
 #xecution_options,
 #:
 #til.warn_deprecated(
 #Executing a subquery object is deprecated and will raise "
 #ObjectNotExecutableError in an upcoming release.  Please "
 #execute the underlying select() statement directly.",
 #1.4",
 #
 #eturn self.element._execute_on_connection(
 #onnection, multiparams, params, execution_options, _force=True
 #


class FromGrouping(GroupedElement, FromClause):
 #""Represent a grouping of a FROM clause"""

 #traverse_internals = [("element", InternalTraversal.dp_clauseelement)]

 #ef __init__(self, element):
 #elf.element = coercions.expect(roles.FromClauseRole, element)

 #ef _init_collections(self):
 #ass

 #property
 #ef columns(self):
 #eturn self.element.columns

 #property
 #ef primary_key(self):
 #eturn self.element.primary_key

 #property
 #ef foreign_keys(self):
 #eturn self.element.foreign_keys

 #ef is_derived_from(self, element):
 #eturn self.element.is_derived_from(element)

 #ef alias(self, **kw):
 #eturn FromGrouping(self.element.alias(**kw))

 #ef _anonymous_fromclause(self, **kw):
 #eturn FromGrouping(self.element._anonymous_fromclause(**kw))

 #property
 #ef _hide_froms(self):
 #eturn self.element._hide_froms

 #property
 #ef _from_objects(self):
 #eturn self.element._from_objects

 #ef __getstate__(self):
 #eturn {"element": self.element}

 #ef __setstate__(self, state):
 #elf.element = state["element"]


class TableClause(roles.DMLTableRole, Immutable, FromClause):
 #""Represents a minimal "table" construct.

 #his is a lightweight table object that has only a name, a
 #ollection of columns, which are typically produced
 #y the :func:`_expression.column` function, and a schema::

 #rom sqlalchemy import table, column

 #ser = table("user",
 #olumn("id"),
 #olumn("name"),
 #olumn("description"),
 #

 #he :class:`_expression.TableClause` construct serves as the base for
 #he more commonly used :class:`_schema.Table` object, providing
 #he usual set of :class:`_expression.FromClause` services including
 #he ``.c.`` collection and statement generation methods.

 #t does **not** provide all the additional schema-level services
 #f :class:`_schema.Table`, including constraints, references to other
 #ables, or support for :class:`_schema.MetaData`-level services.
 #t's useful
 #n its own as an ad-hoc construct used to generate quick SQL
 #tatements when a more fully fledged :class:`_schema.Table`
 #s not on hand.

 #""

 #_visit_name__ = "table"

 #traverse_internals = [
 #
 #columns",
 #nternalTraversal.dp_fromclause_canonical_column_collection,
 #,
 #"name", InternalTraversal.dp_string),
 #

 #amed_with_column = True

 #mplicit_returning = False
 #"":class:`_expression.TableClause`
 #oesn't support having a primary key or column
 #level defaults, so implicit returning doesn't apply."""

 #autoincrement_column = None
 #""No PK or default support so no autoincrement column."""

 #ef __init__(self, name, *columns, **kw):
 #""Produce a new :class:`_expression.TableClause`.

 #he object returned is an instance of
 #class:`_expression.TableClause`, which
 #epresents the "syntactical" portion of the schema-level
 #class:`_schema.Table` object.
 #t may be used to construct lightweight table constructs.

 #. versionchanged:: 1.0.0 :func:`_expression.table` can now
 #e imported from the plain ``sqlalchemy`` namespace like any
 #ther SQL element.


 #param name: Name of the table.

 #param columns: A collection of :func:`_expression.column` constructs.

 #param schema: The schema name for this table.

 #. versionadded:: 1.3.18 :func:`_expression.table` can now
 #ccept a ``schema`` argument.
 #""

 #uper(TableClause, self).__init__()
 #elf.name = self.fullname = name
 #elf._columns = DedupeColumnCollection()
 #elf.primary_key = ColumnSet()
 #elf.foreign_keys = set()
 #or c in columns:
 #elf.append_column(c)

 #chema = kw.pop("schema", None)
 #f schema is not None:
 #elf.schema = schema
 #f kw:
 #aise exc.ArgumentError("Unsupported argument(s): %s" % list(kw))

 #ef __str__(self):
 #f self.schema is not None:
 #eturn self.schema + "." + self.name
 #lse:
 #eturn self.name

 #ef _refresh_for_new_column(self, column):
 #ass

 #ef _init_collections(self):
 #ass

 #util.memoized_property
 #ef description(self):
 #f util.py3k:
 #eturn self.name
 #lse:
 #eturn self.name.encode("ascii", "backslashreplace")

 #ef append_column(self, c, **kw):
 #xisting = c.table
 #f existing is not None and existing is not self:
 #aise exc.ArgumentError(
 #column object '%s' already assigned to table '%s'"
 # (c.key, existing)
 #

 #elf._columns.add(c)
 #.table = self

 #util.preload_module("sqlalchemy.sql.dml")
 #ef insert(self, values=None, inline=False, **kwargs):
 #""Generate an :func:`_expression.insert` construct against this
 #class:`_expression.TableClause`.

 #.g.::

 #able.insert().values(name='foo')

 #ee :func:`_expression.insert` for argument and usage information.

 #""
 #eturn util.preloaded.sql_dml.Insert(
 #elf, values=values, inline=inline, **kwargs
 #

 #util.preload_module("sqlalchemy.sql.dml")
 #ef update(self, whereclause=None, values=None, inline=False, **kwargs):
 #""Generate an :func:`_expression.update` construct against this
 #class:`_expression.TableClause`.

 #.g.::

 #able.update().where(table.c.id==7).values(name='foo')

 #ee :func:`_expression.update` for argument and usage information.

 #""
 #eturn util.preloaded.sql_dml.Update(
 #elf,
 #hereclause=whereclause,
 #alues=values,
 #nline=inline,
 #*kwargs
 #

 #util.preload_module("sqlalchemy.sql.dml")
 #ef delete(self, whereclause=None, **kwargs):
 #""Generate a :func:`_expression.delete` construct against this
 #class:`_expression.TableClause`.

 #.g.::

 #able.delete().where(table.c.id==7)

 #ee :func:`_expression.delete` for argument and usage information.

 #""
 #eturn util.preloaded.sql_dml.Delete(self, whereclause, **kwargs)

 #property
 #ef _from_objects(self):
 #eturn [self]


class ForUpdateArg(ClauseElement):
 #traverse_internals = [
 #"of", InternalTraversal.dp_clauseelement_list),
 #"nowait", InternalTraversal.dp_boolean),
 #"read", InternalTraversal.dp_boolean),
 #"skip_locked", InternalTraversal.dp_boolean),
 #

 #classmethod
 #ef _from_argument(cls, with_for_update):
 #f isinstance(with_for_update, ForUpdateArg):
 #eturn with_for_update
 #lif with_for_update in (None, False):
 #eturn None
 #lif with_for_update is True:
 #eturn ForUpdateArg()
 #lse:
 #eturn ForUpdateArg(**with_for_update)

 #ef __eq__(self, other):
 #eturn (
 #sinstance(other, ForUpdateArg)
 #nd other.nowait == self.nowait
 #nd other.read == self.read
 #nd other.skip_locked == self.skip_locked
 #nd other.key_share == self.key_share
 #nd other.of is self.of
 #

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)

 #ef __hash__(self):
 #eturn id(self)

 #ef __init__(
 #elf,
 #owait=False,
 #ead=False,
 #f=None,
 #kip_locked=False,
 #ey_share=False,
 #:
 #""Represents arguments specified to
 #meth:`_expression.Select.for_update`.

 #""

 #elf.nowait = nowait
 #elf.read = read
 #elf.skip_locked = skip_locked
 #elf.key_share = key_share
 #f of is not None:
 #elf.of = [
 #oercions.expect(roles.ColumnsClauseRole, elem)
 #or elem in util.to_list(of)
 #
 #lse:
 #elf.of = None


class Values(Generative, FromClause):
 #""Represent a ``VALUES`` construct that can be used as a FROM element
 #n a statement.

 #he :class:`_expression.Values` object is created from the
 #func:`_expression.values` function.

 #. versionadded:: 1.4

 #""

 #amed_with_column = True
 #_visit_name__ = "values"

 #data = ()

 #traverse_internals = [
 #"_column_args", InternalTraversal.dp_clauseelement_list),
 #"_data", InternalTraversal.dp_dml_multi_values),
 #"name", InternalTraversal.dp_string),
 #"literal_binds", InternalTraversal.dp_boolean),
 #

 #ef __init__(self, *columns, **kw):
 #"""Construct a :class:`_expression.Values` construct.

 #he column expressions and the actual data for
 #class:`_expression.Values` are given in two separate steps.  The
 #onstructor receives the column expressions typically as
 #func:`_expression.column` constructs,
 #nd the data is then passed via the
 #meth:`_expression.Values.data` method as a list,
 #hich can be called multiple
 #imes to add more data, e.g.::

 #rom sqlalchemy import column
 #rom sqlalchemy import values

 #alue_expr = values(
 #olumn('id', Integer),
 #olumn('name', String),
 #ame="my_values"
 #.data(
 #(1, 'name1'), (2, 'name2'), (3, 'name3')]
 #

 #param \*columns: column expressions, typically composed using
 #func:`_expression.column` objects.

 #param name: the name for this VALUES construct.  If omitted, the
 #ALUES construct will be unnamed in a SQL expression.   Different
 #ackends may have different requirements here.

 #param literal_binds: Defaults to False.  Whether or not to render
 #he data values inline in the SQL output, rather than using bound
 #arameters.

 #""

 #uper(Values, self).__init__()
 #elf._column_args = columns
 #elf.name = kw.pop("name", None)
 #elf.literal_binds = kw.pop("literal_binds", False)
 #elf.named_with_column = self.name is not None

 #property
 #ef _column_types(self):
 #eturn [col.type for col in self._column_args]

 #_generative
 #ef alias(self, name, **kw):
 #""Return a new :class:`_expression.Values`
 #onstruct that is a copy of this
 #ne with the given name.

 #his method is a VALUES-specific specialization of the
 #meth:`_expression.FromClause.alias` method.

 #. seealso::

 #ref:`core_tutorial_aliases`

 #func:`_expression.alias`

 #""
 #elf.name = name
 #elf.named_with_column = self.name is not None

 #_generative
 #ef lateral(self, name=None):
 #""Return a new :class:`_expression.Values` with the lateral flag set,
 #o that
 #t renders as LATERAL.

 #. seealso::

 #func:`_expression.lateral`

 #""
 #elf._is_lateral = True
 #f name is not None:
 #elf.name = name

 #_generative
 #ef data(self, values):
 #""Return a new :class:`_expression.Values` construct,
 #dding the given data
 #o the data list.

 #.g.::

 #y_values = my_values.data([(1, 'value 1'), (2, 'value2')])

 #param values: a sequence (i.e. list) of tuples that map to the
 #olumn expressions given in the :class:`_expression.Values`
 #onstructor.

 #""

 #elf._data += (values,)

 #ef _populate_column_collection(self):
 #or c in self._column_args:
 #elf._columns.add(c)
 #.table = self

 #property
 #ef _from_objects(self):
 #eturn [self]


class SelectBase(
 #oles.SelectStatementRole,
 #oles.DMLSelectRole,
 #oles.CompoundElementRole,
 #oles.InElementRole,
 #asCTE,
 #xecutable,
 #upportsCloneAnnotations,
 #electable,
):
 #""Base class for SELECT statements.


 #his includes :class:`_expression.Select`,
 #class:`_expression.CompoundSelect` and
 #class:`_expression.TextualSelect`.


 #""

 #is_select_statement = True
 #s_select = True

 #ef _generate_fromclause_column_proxies(self, fromclause):
 #aise NotImplementedError()

 #ef _refresh_for_new_column(self, column):
 #elf._reset_memoizations()

 #property
 #ef selected_columns(self):
 #""A :class:`_expression.ColumnCollection`
 #epresenting the columns that
 #his SELECT statement or similar construct returns in its result set.

 #his collection differs from the :attr:`_expression.FromClause.columns`
 #ollection of a :class:`_expression.FromClause` in that the columns
 #ithin this collection cannot be directly nested inside another SELECT
 #tatement; a subquery must be applied first which provides for the
 #ecessary parenthesization required by SQL.

 #. note::

 #he :attr:`_sql.SelectBase.selected_columns` collection does not
 #nclude expressions established in the columns clause using the
 #func:`_sql.text` construct; these are silently omitted from the
 #ollection. To use plain textual column expressions inside of a
 #class:`_sql.Select` construct, use the :func:`_sql.literal_column`
 #onstruct.

 #. seealso::

 #attr:`_sql.Select.selected_columns`

 #. versionadded:: 1.4

 #""
 #aise NotImplementedError()

 #property
 #ef _all_selected_columns(self):
 #""A sequence of expressions that correspond to what is rendered
 #n the columns clause, including :class:`_sql.TextClause`
 #onstructs.

 #. versionadded:: 1.4.12

 #. seealso::

 #attr:`_sql.SelectBase.exported_columns`

 #""
 #aise NotImplementedError()

 #property
 #ef exported_columns(self):
 #""A :class:`_expression.ColumnCollection`
 #hat represents the "exported"
 #olumns of this :class:`_expression.Selectable`, not including
 #class:`_sql.TextClause` constructs.

 #he "exported" columns for a :class:`_expression.SelectBase`
 #bject are synonymous
 #ith the :attr:`_expression.SelectBase.selected_columns` collection.

 #. versionadded:: 1.4

 #. seealso::

 #attr:`_expression.Select.exported_columns`

 #attr:`_expression.Selectable.exported_columns`

 #attr:`_expression.FromClause.exported_columns`


 #""
 #eturn self.selected_columns

 #property
 #util.deprecated(
 #1.4",
 #The :attr:`_expression.SelectBase.c` and "
 #:attr:`_expression.SelectBase.columns` attributes "
 #are deprecated and will be removed in a future release; these "
 #attributes implicitly create a subquery that should be explicit.  "
 #Please call :meth:`_expression.SelectBase.subquery` "
 #first in order to create "
 #a subquery, which then contains this attribute.  To access the "
 #columns that this SELECT object SELECTs "
 #from, use the :attr:`_expression.SelectBase.selected_columns` "
 #attribute.",
 #
 #ef c(self):
 #eturn self._implicit_subquery.columns

 #property
 #ef columns(self):
 #eturn self.c

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.SelectBase.select` method is deprecated "
 #and will be removed in a future release; this method implicitly "
 #creates a subquery that should be explicit.  "
 #Please call :meth:`_expression.SelectBase.subquery` "
 #first in order to create "
 #a subquery, which then can be selected.",
 #
 #ef select(self, *arg, **kw):
 #eturn self._implicit_subquery.select(*arg, **kw)

 #HasMemoized.memoized_attribute
 #ef _implicit_subquery(self):
 #eturn self.subquery()

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.SelectBase.as_scalar` "
 #method is deprecated and will be "
 #removed in a future release.  Please refer to "
 #:meth:`_expression.SelectBase.scalar_subquery`.",
 #
 #ef as_scalar(self):
 #eturn self.scalar_subquery()

 #ef exists(self):
 #""Return an :class:`_sql.Exists` representation of this selectable,
 #hich can be used as a column expression.

 #he returned object is an instance of :class:`_sql.Exists`.

 #. seealso::

 #func:`_sql.exists`

 #ref:`tutorial_exists` - in the :term:`2.0 style` tutorial.

 #. versionadded:: 1.4

 #""
 #eturn Exists(self)

 #ef scalar_subquery(self):
 #""Return a 'scalar' representation of this selectable, which can be
 #sed as a column expression.

 #he returned object is an instance of :class:`_sql.ScalarSelect`.

 #ypically, a select statement which has only one column in its columns
 #lause is eligible to be used as a scalar expression.  The scalar
 #ubquery can then be used in the WHERE clause or columns clause of
 #n enclosing SELECT.

 #ote that the scalar subquery differentiates from the FROM-level
 #ubquery that can be produced using the
 #meth:`_expression.SelectBase.subquery`
 #ethod.

 #. versionchanged: 1.4 - the ``.as_scalar()`` method was renamed to
 #meth:`_expression.SelectBase.scalar_subquery`.

 #. seealso::

 #ref:`tutorial_scalar_subquery` - in the 2.0 tutorial

 #ref:`scalar_selects` - in the 1.x tutorial

 #""
 #f self._label_style is not LABEL_STYLE_NONE:
 #elf = self.set_label_style(LABEL_STYLE_NONE)

 #eturn ScalarSelect(self)

 #ef label(self, name):
 #""Return a 'scalar' representation of this selectable, embedded as a
 #ubquery with a label.

 #. seealso::

 #meth:`_expression.SelectBase.as_scalar`.

 #""
 #eturn self.scalar_subquery().label(name)

 #ef lateral(self, name=None):
 #""Return a LATERAL alias of this :class:`_expression.Selectable`.

 #he return value is the :class:`_expression.Lateral` construct also
 #rovided by the top-level :func:`_expression.lateral` function.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`lateral_selects` -  overview of usage.

 #""
 #eturn Lateral._factory(self, name)

 #property
 #ef _from_objects(self):
 #eturn [self]

 #ef subquery(self, name=None):
 #""Return a subquery of this :class:`_expression.SelectBase`.

 # subquery is from a SQL perspective a parenthesized, named
 #onstruct that can be placed in the FROM clause of another
 #ELECT statement.

 #iven a SELECT statement such as::

 #tmt = select(table.c.id, table.c.name)

 #he above statement might look like::

 #ELECT table.id, table.name FROM table

 #he subquery form by itself renders the same way, however when
 #mbedded into the FROM clause of another SELECT statement, it becomes
 # named sub-element::

 #ubq = stmt.subquery()
 #ew_stmt = select(subq)

 #he above renders as::

 #ELECT anon_1.id, anon_1.name
 #ROM (SELECT table.id, table.name FROM table) AS anon_1

 #istorically, :meth:`_expression.SelectBase.subquery`
 #s equivalent to calling
 #he :meth:`_expression.FromClause.alias`
 #ethod on a FROM object; however,
 #s a :class:`_expression.SelectBase`
 #bject is not directly  FROM object,
 #he :meth:`_expression.SelectBase.subquery`
 #ethod provides clearer semantics.

 #. versionadded:: 1.4

 #""

 #eturn Subquery._construct(self._ensure_disambiguated_names(), name)

 #ef _ensure_disambiguated_names(self):
 #""Ensure that the names generated by this selectbase will be
 #isambiguated in some way, if possible.

 #""

 #aise NotImplementedError()

 #ef alias(self, name=None, flat=False):
 #""Return a named subquery against this
 #class:`_expression.SelectBase`.

 #or a :class:`_expression.SelectBase` (as opposed to a
 #class:`_expression.FromClause`),
 #his returns a :class:`.Subquery` object which behaves mostly the
 #ame as the :class:`_expression.Alias` object that is used with a
 #class:`_expression.FromClause`.

 #. versionchanged:: 1.4 The :meth:`_expression.SelectBase.alias`
 #ethod is now
 # synonym for the :meth:`_expression.SelectBase.subquery` method.

 #""
 #eturn self.subquery(name=name)


class SelectStatementGrouping(GroupedElement, SelectBase):
 #""Represent a grouping of a :class:`_expression.SelectBase`.

 #his differs from :class:`.Subquery` in that we are still
 #n "inner" SELECT statement, this is strictly for grouping inside of
 #ompound selects.

 #""

 #_visit_name__ = "select_statement_grouping"
 #traverse_internals = [("element", InternalTraversal.dp_clauseelement)]

 #is_select_container = True

 #ef __init__(self, element):
 #elf.element = coercions.expect(roles.SelectStatementRole, element)

 #ef _ensure_disambiguated_names(self):
 #ew_element = self.element._ensure_disambiguated_names()
 #f new_element is not self.element:
 #eturn SelectStatementGrouping(new_element)
 #lse:
 #eturn self

 #ef get_label_style(self):
 #eturn self._label_style

 #ef set_label_style(self, label_style):
 #eturn SelectStatementGrouping(
 #elf.element.set_label_style(label_style)
 #

 #property
 #ef _label_style(self):
 #eturn self.element._label_style

 #property
 #ef select_statement(self):
 #eturn self.element

 #ef self_group(self, against=None):
 #eturn self

 #ef _generate_columns_plus_names(self, anon_for_dupe_key):
 #eturn self.element._generate_columns_plus_names(anon_for_dupe_key)

 #ef _generate_fromclause_column_proxies(self, subquery):
 #elf.element._generate_fromclause_column_proxies(subquery)

 #ef _generate_proxy_for_new_column(self, column, subquery):
 #eturn self.element._generate_proxy_for_new_column(subquery)

 #property
 #ef _all_selected_columns(self):
 #eturn self.element._all_selected_columns

 #property
 #ef selected_columns(self):
 #""A :class:`_expression.ColumnCollection`
 #epresenting the columns that
 #he embedded SELECT statement returns in its result set, not including
 #class:`_sql.TextClause` constructs.

 #. versionadded:: 1.4

 #. seealso::

 #attr:`_sql.Select.selected_columns`

 #""
 #eturn self.element.selected_columns

 #property
 #ef _from_objects(self):
 #eturn self.element._from_objects


class DeprecatedSelectBaseGenerations(object):
 #""A collection of methods available on :class:`_sql.Select` and
 #class:`_sql.CompoundSelect`, these are all **deprecated** methods as they
 #odify the object in-place.

 #""

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.GenerativeSelect.append_order_by` "
 #method is deprecated "
 #and will be removed in a future release.  Use the generative method "
 #:meth:`_expression.GenerativeSelect.order_by`.",
 #
 #ef append_order_by(self, *clauses):
 #""Append the given ORDER BY criterion applied to this selectable.

 #he criterion will be appended to any pre-existing ORDER BY criterion.

 #his is an **in-place** mutation method; the
 #meth:`_expression.GenerativeSelect.order_by` method is preferred,
 #s it
 #rovides standard :term:`method chaining`.

 #. seealso::

 #meth:`_expression.GenerativeSelect.order_by`

 #""
 #elf.order_by.non_generative(self, *clauses)

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.GenerativeSelect.append_group_by` "
 #method is deprecated "
 #and will be removed in a future release.  Use the generative method "
 #:meth:`_expression.GenerativeSelect.group_by`.",
 #
 #ef append_group_by(self, *clauses):
 #""Append the given GROUP BY criterion applied to this selectable.

 #he criterion will be appended to any pre-existing GROUP BY criterion.

 #his is an **in-place** mutation method; the
 #meth:`_expression.GenerativeSelect.group_by` method is preferred,
 #s it
 #rovides standard :term:`method chaining`.


 #""
 #elf.group_by.non_generative(self, *clauses)


class GenerativeSelect(DeprecatedSelectBaseGenerations, SelectBase):
 #""Base class for SELECT statements where additional elements can be
 #dded.

 #his serves as the base for :class:`_expression.Select` and
 #class:`_expression.CompoundSelect`
 #here elements such as ORDER BY, GROUP BY can be added and column
 #endering can be controlled.  Compare to
 #class:`_expression.TextualSelect`, which,
 #hile it subclasses :class:`_expression.SelectBase`
 #nd is also a SELECT construct,
 #epresents a fixed textual string which cannot be altered at this level,
 #nly wrapped as a subquery.

 #""

 #order_by_clauses = ()
 #group_by_clauses = ()
 #limit_clause = None
 #offset_clause = None
 #fetch_clause = None
 #fetch_clause_options = None
 #for_update_arg = None

 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_sql.select.bind` argument is deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef __init__(
 #elf,
 #label_style=LABEL_STYLE_DEFAULT,
 #se_labels=False,
 #imit=None,
 #ffset=None,
 #rder_by=None,
 #roup_by=None,
 #ind=None,
 #:
 #f use_labels:
 #f util.SQLALCHEMY_WARN_20:
 #til.warn_deprecated_20(
 #The use_labels=True keyword argument to GenerativeSelect "
 #is deprecated and will be removed in version 2.0. Please "
 #use "
 #select.set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL) "
 #if you need to replicate this legacy behavior.",
 #tacklevel=4,
 #
 #label_style = LABEL_STYLE_TABLENAME_PLUS_COL

 #elf._label_style = _label_style

 #f limit is not None:
 #elf.limit.non_generative(self, limit)
 #f offset is not None:
 #elf.offset.non_generative(self, offset)

 #f order_by is not None:
 #elf.order_by.non_generative(self, *util.to_list(order_by))
 #f group_by is not None:
 #elf.group_by.non_generative(self, *util.to_list(group_by))

 #elf._bind = bind

 #_generative
 #ef with_for_update(
 #elf,
 #owait=False,
 #ead=False,
 #f=None,
 #kip_locked=False,
 #ey_share=False,
 #:
 #""Specify a ``FOR UPDATE`` clause for this
 #class:`_expression.GenerativeSelect`.

 #.g.::

 #tmt = select(table).with_for_update(nowait=True)

 #n a database like PostgreSQL or Oracle, the above would render a
 #tatement like::

 #ELECT table.a, table.b FROM table FOR UPDATE NOWAIT

 #n other backends, the ``nowait`` option is ignored and instead
 #ould produce::

 #ELECT table.a, table.b FROM table FOR UPDATE

 #hen called with no arguments, the statement will render with
 #he suffix ``FOR UPDATE``.   Additional arguments can then be
 #rovided which allow for common database-specific
 #ariants.

 #param nowait: boolean; will render ``FOR UPDATE NOWAIT`` on Oracle
 #nd PostgreSQL dialects.

 #param read: boolean; will render ``LOCK IN SHARE MODE`` on MySQL,
 #`FOR SHARE`` on PostgreSQL.  On PostgreSQL, when combined with
 #`nowait``, will render ``FOR SHARE NOWAIT``.

 #param of: SQL expression or list of SQL expression elements
 #typically :class:`_schema.Column`
 #bjects or a compatible expression) which
 #ill render into a ``FOR UPDATE OF`` clause; supported by PostgreSQL
 #nd Oracle.  May render as a table or as a column depending on
 #ackend.

 #param skip_locked: boolean, will render ``FOR UPDATE SKIP LOCKED``
 #n Oracle and PostgreSQL dialects or ``FOR SHARE SKIP LOCKED`` if
 #`read=True`` is also specified.

 #param key_share: boolean, will render ``FOR NO KEY UPDATE``,
 #r if combined with ``read=True`` will render ``FOR KEY SHARE``,
 #n the PostgreSQL dialect.

 #""
 #elf._for_update_arg = ForUpdateArg(
 #owait=nowait,
 #ead=read,
 #f=of,
 #kip_locked=skip_locked,
 #ey_share=key_share,
 #

 #ef get_label_style(self):
 #""
 #etrieve the current label style.

 #. versionadded:: 1.4

 #""
 #eturn self._label_style

 #ef set_label_style(self, style):
 #""Return a new selectable with the specified label style.

 #here are three "label styles" available,
 #data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY`,
 #data:`_sql.LABEL_STYLE_TABLENAME_PLUS_COL`, and
 #data:`_sql.LABEL_STYLE_NONE`.   The default style is
 #data:`_sql.LABEL_STYLE_TABLENAME_PLUS_COL`.

 #n modern SQLAlchemy, there is not generally a need to change the
 #abeling style, as per-expression labels are more effectively used by
 #aking use of the :meth:`_sql.ColumnElement.label` method. In past
 #ersions, :data:`_sql.LABEL_STYLE_TABLENAME_PLUS_COL` was used to
 #isambiguate same-named columns from different tables, aliases, or
 #ubqueries; the newer :data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY` now
 #pplies labels only to names that conflict with an existing name so
 #hat the impact of this labeling is minimal.

 #he rationale for disambiguation is mostly so that all column
 #xpressions are available from a given :attr:`_sql.FromClause.c`
 #ollection when a subquery is created.

 #. versionadded:: 1.4 - the
 #meth:`_sql.GenerativeSelect.set_label_style` method replaces the
 #revious combination of ``.apply_labels()``, ``.with_labels()`` and
 #`use_labels=True`` methods and/or parameters.

 #. seealso::

 #data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY`

 #data:`_sql.LABEL_STYLE_TABLENAME_PLUS_COL`

 #data:`_sql.LABEL_STYLE_NONE`

 #data:`_sql.LABEL_STYLE_DEFAULT`

 #""
 #f self._label_style is not style:
 #elf = self._generate()
 #elf._label_style = style
 #eturn self

 #util.deprecated_20(
 #:meth:`_sql.GenerativeSelect.apply_labels`",
 #lternative="Use set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL) "
 #instead.",
 #
 #ef apply_labels(self):
 #eturn self.set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)

 #property
 #ef _group_by_clause(self):
 #""ClauseList access to group_by_clauses for legacy dialects"""
 #eturn ClauseList._construct_raw(
 #perators.comma_op, self._group_by_clauses
 #

 #property
 #ef _order_by_clause(self):
 #""ClauseList access to order_by_clauses for legacy dialects"""
 #eturn ClauseList._construct_raw(
 #perators.comma_op, self._order_by_clauses
 #

 #ef _offset_or_limit_clause(self, element, name=None, type_=None):
 #""Convert the given value to an "offset or limit" clause.

 #his handles incoming integers and converts to an expression; if
 #n expression is already given, it is passed through.

 #""
 #eturn coercions.expect(
 #oles.LimitOffsetRole, element, name=name, type_=type_
 #

 #ef _offset_or_limit_clause_asint(self, clause, attrname):
 #""Convert the "offset or limit" clause of a select construct to an
 #nteger.

 #his is only possible if the value is stored as a simple bound
 #arameter. Otherwise, a compilation error is raised.

 #""
 #f clause is None:
 #eturn None
 #ry:
 #alue = clause._limit_offset_value
 #xcept AttributeError as err:
 #til.raise_(
 #xc.CompileError(
 #This SELECT structure does not use a simple "
 #integer value for %s" % attrname
 #,
 #eplace_context=err,
 #
 #lse:
 #eturn util.asint(value)

 #property
 #ef _limit(self):
 #""Get an integer value for the limit.  This should only be used
 #y code that cannot support a limit as a BindParameter or
 #ther custom clause as it will throw an exception if the limit
 #sn't currently set to an integer.

 #""
 #eturn self._offset_or_limit_clause_asint(self._limit_clause, "limit")

 #ef _simple_int_clause(self, clause):
 #""True if the clause is a simple integer, False
 #f it is not present or is a SQL expression.
 #""
 #eturn isinstance(clause, _OffsetLimitParam)

 #property
 #ef _offset(self):
 #""Get an integer value for the offset.  This should only be used
 #y code that cannot support an offset as a BindParameter or
 #ther custom clause as it will throw an exception if the
 #ffset isn't currently set to an integer.

 #""
 #eturn self._offset_or_limit_clause_asint(
 #elf._offset_clause, "offset"
 #

 #property
 #ef _has_row_limiting_clause(self):
 #eturn (
 #elf._limit_clause is not None
 #r self._offset_clause is not None
 #r self._fetch_clause is not None
 #

 #_generative
 #ef limit(self, limit):
 #""Return a new selectable with the given LIMIT criterion
 #pplied.

 #his is a numerical value which usually renders as a ``LIMIT``
 #xpression in the resulting select.  Backends that don't
 #upport ``LIMIT`` will attempt to provide similar
 #unctionality.

 #. note::

 #he :meth:`_sql.GenerativeSelect.limit` method will replace
 #ny clause applied with :meth:`_sql.GenerativeSelect.fetch`.

 #. versionchanged:: 1.0.0 - :meth:`_expression.Select.limit` can now
 #ccept arbitrary SQL expressions as well as integer values.

 #param limit: an integer LIMIT parameter, or a SQL expression
 #hat provides an integer result. Pass ``None`` to reset it.

 #. seealso::

 #meth:`_sql.GenerativeSelect.fetch`

 #meth:`_sql.GenerativeSelect.offset`

 #""

 #elf._fetch_clause = self._fetch_clause_options = None
 #elf._limit_clause = self._offset_or_limit_clause(limit)

 #_generative
 #ef fetch(self, count, with_ties=False, percent=False):
 #""Return a new selectable with the given FETCH FIRST criterion
 #pplied.

 #his is a numeric value which usually renders as
 #`FETCH {FIRST | NEXT} [ count ] {ROW | ROWS} {ONLY | WITH TIES}``
 #xpression in the resulting select. This functionality is
 #s currently implemented for Oracle, PostgreSQL, MSSQL.

 #se :meth:`_sql.GenerativeSelect.offset` to specify the offset.

 #. note::

 #he :meth:`_sql.GenerativeSelect.fetch` method will replace
 #ny clause applied with :meth:`_sql.GenerativeSelect.limit`.

 #. versionadded:: 1.4

 #param count: an integer COUNT parameter, or a SQL expression
 #hat provides an integer result. When ``percent=True`` this will
 #epresent the percentage of rows to return, not the absolute value.
 #ass ``None`` to reset it.

 #param with_ties: When ``True``, the WITH TIES option is used
 #o return any additional rows that tie for the last place in the
 #esult set according to the ``ORDER BY`` clause. The
 #`ORDER BY`` may be mandatory in this case. Defaults to ``False``

 #param percent: When ``True``, ``count`` represents the percentage
 #f the total number of selected rows to return. Defaults to ``False``

 #. seealso::

 #meth:`_sql.GenerativeSelect.limit`

 #meth:`_sql.GenerativeSelect.offset`

 #""

 #elf._limit_clause = None
 #f count is None:
 #elf._fetch_clause = self._fetch_clause_options = None
 #lse:
 #elf._fetch_clause = self._offset_or_limit_clause(count)
 #elf._fetch_clause_options = {
 #with_ties": with_ties,
 #percent": percent,
 #

 #_generative
 #ef offset(self, offset):
 #""Return a new selectable with the given OFFSET criterion
 #pplied.


 #his is a numeric value which usually renders as an ``OFFSET``
 #xpression in the resulting select.  Backends that don't
 #upport ``OFFSET`` will attempt to provide similar
 #unctionality.


 #. versionchanged:: 1.0.0 - :meth:`_expression.Select.offset` can now
 #ccept arbitrary SQL expressions as well as integer values.

 #param offset: an integer OFFSET parameter, or a SQL expression
 #hat provides an integer result. Pass ``None`` to reset it.

 #. seealso::

 #meth:`_sql.GenerativeSelect.limit`

 #meth:`_sql.GenerativeSelect.fetch`

 #""

 #elf._offset_clause = self._offset_or_limit_clause(offset)

 #_generative
 #util.preload_module("sqlalchemy.sql.util")
 #ef slice(self, start, stop):
 #""Apply LIMIT / OFFSET to this statement based on a slice.

 #he start and stop indices behave like the argument to Python's
 #uilt-in :func:`range` function. This method provides an
 #lternative to using ``LIMIT``/``OFFSET`` to get a slice of the
 #uery.

 #or example, ::

 #tmt = select(User).order_by(User).id.slice(1, 3)

 #enders as

 #. sourcecode:: sql

 #ELECT users.id AS users_id,
 #sers.name AS users_name
 #ROM users ORDER BY users.id
 #IMIT ? OFFSET ?
 #2, 1)

 #. note::

 #he :meth:`_sql.GenerativeSelect.slice` method will replace
 #ny clause applied with :meth:`_sql.GenerativeSelect.fetch`.

 #. versionadded:: 1.4  Added the :meth:`_sql.GenerativeSelect.slice`
 #ethod generalized from the ORM.

 #. seealso::

 #meth:`_sql.GenerativeSelect.limit`

 #meth:`_sql.GenerativeSelect.offset`

 #meth:`_sql.GenerativeSelect.fetch`

 #""
 #ql_util = util.preloaded.sql_util
 #elf._fetch_clause = self._fetch_clause_options = None
 #elf._limit_clause, self._offset_clause = sql_util._make_slice(
 #elf._limit_clause, self._offset_clause, start, stop
 #

 #_generative
 #ef order_by(self, *clauses):
 #"""Return a new selectable with the given list of ORDER BY
 #riterion applied.

 #.g.::

 #tmt = select(table).order_by(table.c.id, table.c.name)

 #param \*clauses: a series of :class:`_expression.ColumnElement`
 #onstructs
 #hich will be used to generate an ORDER BY clause.

 #. seealso::

 #ref:`tutorial_order_by` - in the :ref:`unified_tutorial`

 #ref:`tutorial_order_by_label` - in the :ref:`unified_tutorial`

 #""

 #f len(clauses) == 1 and clauses[0] is None:
 #elf._order_by_clauses = ()
 #lse:
 #elf._order_by_clauses += tuple(
 #oercions.expect(roles.OrderByRole, clause)
 #or clause in clauses
 #

 #_generative
 #ef group_by(self, *clauses):
 #"""Return a new selectable with the given list of GROUP BY
 #riterion applied.

 #.g.::

 #tmt = select(table.c.name, func.max(table.c.stat)).\
 #roup_by(table.c.name)

 #param \*clauses: a series of :class:`_expression.ColumnElement`
 #onstructs
 #hich will be used to generate an GROUP BY clause.

 #. seealso::

 #ref:`tutorial_group_by_w_aggregates` - in the
 #ref:`unified_tutorial`

 #ref:`tutorial_order_by_label` - in the :ref:`unified_tutorial`

 #""

 #f len(clauses) == 1 and clauses[0] is None:
 #elf._group_by_clauses = ()
 #lse:
 #elf._group_by_clauses += tuple(
 #oercions.expect(roles.GroupByRole, clause)
 #or clause in clauses
 #


@CompileState.plugin_for("default", "compound_select")
class CompoundSelectState(CompileState):
 #util.memoized_property
 #ef _label_resolve_dict(self):
        # TODO: this is hacky and slow
 #acky_subquery = self.statement.subquery()
 #acky_subquery.named_with_column = False
 # = dict((c.key, c) for c in hacky_subquery.c)
 #eturn d, d, d


class CompoundSelect(HasCompileState, GenerativeSelect):
 #""Forms the basis of ``UNION``, ``UNION ALL``, and other
 #ELECT-based set operations.


 #. seealso::

 #func:`_expression.union`

 #func:`_expression.union_all`

 #func:`_expression.intersect`

 #func:`_expression.intersect_all`

 #func:`_expression.except`

 #func:`_expression.except_all`

 #""

 #_visit_name__ = "compound_select"

 #traverse_internals = [
 #"selects", InternalTraversal.dp_clauseelement_list),
 #"_limit_clause", InternalTraversal.dp_clauseelement),
 #"_offset_clause", InternalTraversal.dp_clauseelement),
 #"_fetch_clause", InternalTraversal.dp_clauseelement),
 #"_fetch_clause_options", InternalTraversal.dp_plain_dict),
 #"_order_by_clauses", InternalTraversal.dp_clauseelement_list),
 #"_group_by_clauses", InternalTraversal.dp_clauseelement_list),
 #"_for_update_arg", InternalTraversal.dp_clauseelement),
 #"keyword", InternalTraversal.dp_string),
 # + SupportsCloneAnnotations._clone_annotations_traverse_internals

 #NION = util.symbol("UNION")
 #NION_ALL = util.symbol("UNION ALL")
 #XCEPT = util.symbol("EXCEPT")
 #XCEPT_ALL = util.symbol("EXCEPT ALL")
 #NTERSECT = util.symbol("INTERSECT")
 #NTERSECT_ALL = util.symbol("INTERSECT ALL")

 #is_from_container = True

 #ef __init__(self, keyword, *selects, **kwargs):
 #elf._auto_correlate = kwargs.pop("correlate", False)
 #elf.keyword = keyword
 #elf.selects = [
 #oercions.expect(roles.CompoundElementRole, s).self_group(
 #gainst=self
 #
 #or s in selects
 #

 #f kwargs and util.SQLALCHEMY_WARN_20:
 #til.warn_deprecated_20(
 #Set functions such as union(), union_all(), extract(), etc. "
 #in SQLAlchemy 2.0 will accept a "
 #series of SELECT statements only. "
 #Please use generative methods such as order_by() for "
 #additional modifications to this CompoundSelect.",
 #tacklevel=4,
 #

 #enerativeSelect.__init__(self, **kwargs)

 #classmethod
 #ef _create_union(cls, *selects, **kwargs):
 #"""Return a ``UNION`` of multiple selectables.

 #he returned object is an instance of
 #class:`_expression.CompoundSelect`.

 # similar :func:`union()` method is available on all
 #class:`_expression.FromClause` subclasses.

 #param \*selects:
 # list of :class:`_expression.Select` instances.

 #param \**kwargs:
 #vailable keyword arguments are the same as those of
 #func:`select`.

 #""
 #eturn CompoundSelect(CompoundSelect.UNION, *selects, **kwargs)

 #classmethod
 #ef _create_union_all(cls, *selects, **kwargs):
 #"""Return a ``UNION ALL`` of multiple selectables.

 #he returned object is an instance of
 #class:`_expression.CompoundSelect`.

 # similar :func:`union_all()` method is available on all
 #class:`_expression.FromClause` subclasses.

 #param \*selects:
 # list of :class:`_expression.Select` instances.

 #param \**kwargs:
 #vailable keyword arguments are the same as those of
 #func:`select`.

 #""
 #eturn CompoundSelect(CompoundSelect.UNION_ALL, *selects, **kwargs)

 #classmethod
 #ef _create_except(cls, *selects, **kwargs):
 #"""Return an ``EXCEPT`` of multiple selectables.

 #he returned object is an instance of
 #class:`_expression.CompoundSelect`.

 #param \*selects:
 # list of :class:`_expression.Select` instances.

 #param \**kwargs:
 #vailable keyword arguments are the same as those of
 #func:`select`.

 #""
 #eturn CompoundSelect(CompoundSelect.EXCEPT, *selects, **kwargs)

 #classmethod
 #ef _create_except_all(cls, *selects, **kwargs):
 #"""Return an ``EXCEPT ALL`` of multiple selectables.

 #he returned object is an instance of
 #class:`_expression.CompoundSelect`.

 #param \*selects:
 # list of :class:`_expression.Select` instances.

 #param \**kwargs:
 #vailable keyword arguments are the same as those of
 #func:`select`.

 #""
 #eturn CompoundSelect(CompoundSelect.EXCEPT_ALL, *selects, **kwargs)

 #classmethod
 #ef _create_intersect(cls, *selects, **kwargs):
 #"""Return an ``INTERSECT`` of multiple selectables.

 #he returned object is an instance of
 #class:`_expression.CompoundSelect`.

 #param \*selects:
 # list of :class:`_expression.Select` instances.

 #param \**kwargs:
 #vailable keyword arguments are the same as those of
 #func:`select`.

 #""
 #eturn CompoundSelect(CompoundSelect.INTERSECT, *selects, **kwargs)

 #classmethod
 #ef _create_intersect_all(cls, *selects, **kwargs):
 #"""Return an ``INTERSECT ALL`` of multiple selectables.

 #he returned object is an instance of
 #class:`_expression.CompoundSelect`.

 #param \*selects:
 # list of :class:`_expression.Select` instances.

 #param \**kwargs:
 #vailable keyword arguments are the same as those of
 #func:`select`.

 #""
 #eturn CompoundSelect(CompoundSelect.INTERSECT_ALL, *selects, **kwargs)

 #ef _scalar_type(self):
 #eturn self.selects[0]._scalar_type()

 #ef self_group(self, against=None):
 #eturn SelectStatementGrouping(self)

 #ef is_derived_from(self, fromclause):
 #or s in self.selects:
 #f s.is_derived_from(fromclause):
 #eturn True
 #eturn False

 #ef _set_label_style(self, style):
 #f self._label_style is not style:
 #elf = self._generate()
 #elect_0 = self.selects[0]._set_label_style(style)
 #elf.selects = [select_0] + self.selects[1:]

 #eturn self

 #ef _ensure_disambiguated_names(self):
 #ew_select = self.selects[0]._ensure_disambiguated_names()
 #f new_select is not self.selects[0]:
 #elf = self._generate()
 #elf.selects = [new_select] + self.selects[1:]

 #eturn self

 #ef _generate_fromclause_column_proxies(self, subquery):

        # this is a slightly hacky thing - the union exports a
        # column that resembles just that of the *first* selectable.
        # to get at a "composite" column, particularly foreign keys,
        # you have to dig through the proxies collection which we
        # generate below.  We may want to improve upon this, such as
        # perhaps _make_proxy can accept a list of other columns
        # that are "shared" - schema.column can then copy all the
        # ForeignKeys in. this would allow the union() to have all
        # those fks too.
 #elect_0 = self.selects[0]

 #f self._label_style is not LABEL_STYLE_DEFAULT:
 #elect_0 = select_0.set_label_style(self._label_style)
 #elect_0._generate_fromclause_column_proxies(subquery)

        # hand-construct the "_proxies" collection to include all
        # derived columns place a 'weight' annotation corresponding
        # to how low in the list of select()s the column occurs, so
        # that the corresponding_column() operation can resolve
        # conflicts

 #or subq_col, select_cols in zip(
 #ubquery.c._all_columns,
 #ip(*[s.selected_columns for s in self.selects]),
 #:
 #ubq_col._proxies = [
 #._annotate({"weight": i + 1})
 #or (i, c) in enumerate(select_cols)
 #

 #ef _refresh_for_new_column(self, column):
 #uper(CompoundSelect, self)._refresh_for_new_column(column)
 #or select in self.selects:
 #elect._refresh_for_new_column(column)

 #property
 #ef _all_selected_columns(self):
 #eturn self.selects[0]._all_selected_columns

 #property
 #ef selected_columns(self):
 #""A :class:`_expression.ColumnCollection`
 #epresenting the columns that
 #his SELECT statement or similar construct returns in its result set,
 #ot including :class:`_sql.TextClause` constructs.

 #or a :class:`_expression.CompoundSelect`, the
 #attr:`_expression.CompoundSelect.selected_columns`
 #ttribute returns the selected
 #olumns of the first SELECT statement contained within the series of
 #tatements within the set operation.

 #. seealso::

 #attr:`_sql.Select.selected_columns`

 #. versionadded:: 1.4

 #""
 #eturn self.selects[0].selected_columns

 #property
 #util.deprecated_20(
 #:attr:`.Executable.bind`",
 #lternative="Bound metadata is being removed as of SQLAlchemy 2.0.",
 #nable_warnings=False,
 #
 #ef bind(self):
 #""Returns the :class:`_engine.Engine` or :class:`_engine.Connection`
 #o which this :class:`.Executable` is bound, or None if none found.

 #""
 #f self._bind:
 #eturn self._bind
 #or s in self.selects:
 # = s.bind
 #f e:
 #eturn e
 #lse:
 #eturn None

 #bind.setter
 #ef bind(self, bind):
 #elf._bind = bind


class DeprecatedSelectGenerations(object):
 #""A collection of methods available on :class:`_sql.Select`, these
 #re all **deprecated** methods as they modify the :class:`_sql.Select`
 #bject in -place.

 #""

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.Select.append_correlation` "
 #method is deprecated "
 #and will be removed in a future release.  Use the generative "
 #method :meth:`_expression.Select.correlate`.",
 #
 #ef append_correlation(self, fromclause):
 #""Append the given correlation expression to this select()
 #onstruct.

 #his is an **in-place** mutation method; the
 #meth:`_expression.Select.correlate` method is preferred,
 #s it provides
 #tandard :term:`method chaining`.

 #""

 #elf.correlate.non_generative(self, fromclause)

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.Select.append_column` method is deprecated "
 #and will be removed in a future release.  Use the generative "
 #method :meth:`_expression.Select.add_columns`.",
 #
 #ef append_column(self, column):
 #""Append the given column expression to the columns clause of this
 #elect() construct.

 #.g.::

 #y_select.append_column(some_table.c.new_column)

 #his is an **in-place** mutation method; the
 #meth:`_expression.Select.add_columns` method is preferred,
 #s it provides standard
 #term:`method chaining`.

 #""
 #elf.add_columns.non_generative(self, column)

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.Select.append_prefix` method is deprecated "
 #and will be removed in a future release.  Use the generative "
 #method :meth:`_expression.Select.prefix_with`.",
 #
 #ef append_prefix(self, clause):
 #""Append the given columns clause prefix expression to this select()
 #onstruct.

 #his is an **in-place** mutation method; the
 #meth:`_expression.Select.prefix_with` method is preferred,
 #s it provides
 #tandard :term:`method chaining`.

 #""
 #elf.prefix_with.non_generative(self, clause)

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.Select.append_whereclause` "
 #method is deprecated "
 #and will be removed in a future release.  Use the generative "
 #method :meth:`_expression.Select.where`.",
 #
 #ef append_whereclause(self, whereclause):
 #""Append the given expression to this select() construct's WHERE
 #riterion.

 #he expression will be joined to existing WHERE criterion via AND.

 #his is an **in-place** mutation method; the
 #meth:`_expression.Select.where` method is preferred,
 #s it provides standard
 #term:`method chaining`.

 #""
 #elf.where.non_generative(self, whereclause)

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.Select.append_having` method is deprecated "
 #and will be removed in a future release.  Use the generative "
 #method :meth:`_expression.Select.having`.",
 #
 #ef append_having(self, having):
 #""Append the given expression to this select() construct's HAVING
 #riterion.

 #he expression will be joined to existing HAVING criterion via AND.

 #his is an **in-place** mutation method; the
 #meth:`_expression.Select.having` method is preferred,
 #s it provides standard
 #term:`method chaining`.

 #""

 #elf.having.non_generative(self, having)

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.Select.append_from` method is deprecated "
 #and will be removed in a future release.  Use the generative "
 #method :meth:`_expression.Select.select_from`.",
 #
 #ef append_from(self, fromclause):
 #""Append the given :class:`_expression.FromClause` expression
 #o this select() construct's FROM clause.

 #his is an **in-place** mutation method; the
 #meth:`_expression.Select.select_from` method is preferred,
 #s it provides
 #tandard :term:`method chaining`.

 #""
 #elf.select_from.non_generative(self, fromclause)


@CompileState.plugin_for("default", "select")
class SelectState(util.MemoizedSlots, CompileState):
 #_slots__ = (
 #from_clauses",
 #froms",
 #columns_plus_names",
 #_label_resolve_dict",
 #

 #lass default_select_compile_options(CacheableOptions):
 #cache_key_traversal = []

 #ef __init__(self, statement, compiler, **kw):
 #elf.statement = statement
 #elf.from_clauses = statement._from_obj

 #or memoized_entities in statement._memoized_select_entities:
 #elf._setup_joins(
 #emoized_entities._setup_joins, memoized_entities._raw_columns
 #

 #f statement._setup_joins:
 #elf._setup_joins(statement._setup_joins, statement._raw_columns)

 #elf.froms = self._get_froms(statement)

 #elf.columns_plus_names = statement._generate_columns_plus_names(True)

 #classmethod
 #ef _plugin_not_implemented(cls):
 #aise NotImplementedError(
 #The default SELECT construct without plugins does not "
 #implement this method."
 #

 #classmethod
 #ef get_column_descriptions(cls, statement):
 #ls._plugin_not_implemented()

 #classmethod
 #ef from_statement(cls, statement, from_statement):
 #ls._plugin_not_implemented()

 #classmethod
 #ef _column_naming_convention(cls, label_style):

 #able_qualified = label_style is LABEL_STYLE_TABLENAME_PLUS_COL
 #edupe = label_style is not LABEL_STYLE_NONE

 #a = prefix_anon_map()
 #ames = set()

 #ef go(c, col_name=None):
 #f c._is_text_clause:
 #eturn None

 #lif not dedupe:
 #ame = c._proxy_key
 #f name is None:
 #ame = "_no_label"
 #eturn name

 #ame = c._tq_key_label if table_qualified else c._proxy_key

 #f name is None:
 #ame = "_no_label"
 #f name in names:
 #eturn c._anon_label(name) % pa
 #lse:
 #ames.add(name)
 #eturn name

 #lif name in names:
 #eturn (
 #._anon_tq_key_label % pa
 #f table_qualified
 #lse c._anon_key_label % pa
 #
 #lse:
 #ames.add(name)
 #eturn name

 #eturn go

 #ef _get_froms(self, statement):
 #eturn self._normalize_froms(
 #tertools.chain(
 #tertools.chain.from_iterable(
 #
 #lement._from_objects
 #or element in statement._raw_columns
 #
 #,
 #tertools.chain.from_iterable(
 #
 #lement._from_objects
 #or element in statement._where_criteria
 #
 #,
 #elf.from_clauses,
 #,
 #heck_statement=statement,
 #

 #ef _normalize_froms(self, iterable_of_froms, check_statement=None):
 #""given an iterable of things to select FROM, reduce them to what
 #ould actually render in the FROM clause of a SELECT.

 #his does the job of checking for JOINs, tables, etc. that are in fact
 #verlapping due to cloning, adaption, present in overlapping joins,
 #tc.

 #""
 #een = set()
 #roms = []

 #or item in iterable_of_froms:
 #f item._is_subquery and item.element is check_statement:
 #aise exc.InvalidRequestError(
 #select() construct refers to itself as a FROM"
 #

 #f not seen.intersection(item._cloned_set):
 #roms.append(item)
 #een.update(item._cloned_set)

 #f froms:
 #oremove = set(
 #tertools.chain.from_iterable(
 #_expand_cloned(f._hide_froms) for f in froms]
 #
 #
 #f toremove:
                # filter out to FROM clauses not in the list,
                # using a list to maintain ordering
 #roms = [f for f in froms if f not in toremove]

 #eturn froms

 #ef _get_display_froms(
 #elf, explicit_correlate_froms=None, implicit_correlate_froms=None
 #:
 #""Return the full list of 'from' clauses to be displayed.

 #akes into account a set of existing froms which may be
 #endered in the FROM clause of enclosing selects; this Select
 #ay want to leave those absent if it is automatically
 #orrelating.

 #""

 #roms = self.froms

 #f self.statement._correlate:
 #o_correlate = self.statement._correlate
 #f to_correlate:
 #roms = [
 #
 #or f in froms
 #f f
 #ot in _cloned_intersection(
 #cloned_intersection(
 #roms, explicit_correlate_froms or ()
 #,
 #o_correlate,
 #
 #

 #f self.statement._correlate_except is not None:

 #roms = [
 #
 #or f in froms
 #f f
 #ot in _cloned_difference(
 #cloned_intersection(
 #roms, explicit_correlate_froms or ()
 #,
 #elf.statement._correlate_except,
 #
 #

 #f (
 #elf.statement._auto_correlate
 #nd implicit_correlate_froms
 #nd len(froms) > 1
 #:

 #roms = [
 #
 #or f in froms
 #f f
 #ot in _cloned_intersection(froms, implicit_correlate_froms)
 #

 #f not len(froms):
 #aise exc.InvalidRequestError(
 #Select statement '%r"
 #' returned no FROM clauses "
 #due to auto-correlation; "
 #specify correlate(<tables>) "
 #to control correlation "
 #manually." % self.statement
 #

 #eturn froms

 #ef _memoized_attr__label_resolve_dict(self):
 #ith_cols = dict(
 #c._resolve_label or c._tq_label or c.key, c)
 #or c in self.statement._all_selected_columns
 #f c._allow_label_resolve
 #
 #nly_froms = dict(
 #c.key, c)
 #or c in _select_iterables(self.froms)
 #f c._allow_label_resolve
 #
 #nly_cols = with_cols.copy()
 #or key, value in only_froms.items():
 #ith_cols.setdefault(key, value)

 #eturn with_cols, only_froms, only_cols

 #classmethod
 #ef determine_last_joined_entity(cls, stmt):
 #f stmt._setup_joins:
 #eturn stmt._setup_joins[-1][0]
 #lse:
 #eturn None

 #classmethod
 #ef all_selected_columns(cls, statement):
 #eturn [c for c in _select_iterables(statement._raw_columns)]

 #ef _setup_joins(self, args, raw_columns):
 #or (right, onclause, left, flags) in args:
 #souter = flags["isouter"]
 #ull = flags["full"]

 #f left is None:
 #
 #eft,
 #eplace_from_obj_index,
 # = self._join_determine_implicit_left_side(
 #aw_columns, left, right, onclause
 #
 #lse:
 #replace_from_obj_index) = self._join_place_explicit_left_side(
 #eft
 #

 #f replace_from_obj_index is not None:
                # splice into an existing element in the
                # self._from_obj list
 #eft_clause = self.from_clauses[replace_from_obj_index]

 #elf.from_clauses = (
 #elf.from_clauses[:replace_from_obj_index]
 # (
 #oin(
 #eft_clause,
 #ight,
 #nclause,
 #souter=isouter,
 #ull=full,
 #,
 #
 # self.from_clauses[replace_from_obj_index + 1 :]
 #
 #lse:

 #elf.from_clauses = self.from_clauses + (
 #oin(left, right, onclause, isouter=isouter, full=full),
 #

 #util.preload_module("sqlalchemy.sql.util")
 #ef _join_determine_implicit_left_side(
 #elf, raw_columns, left, right, onclause
 #:
 #""When join conditions don't express the left side explicitly,
 #etermine if an existing FROM or entity in this query
 #an serve as the left hand side.

 #""

 #ql_util = util.preloaded.sql_util

 #eplace_from_obj_index = None

 #rom_clauses = self.from_clauses

 #f from_clauses:

 #ndexes = sql_util.find_left_clause_to_join_from(
 #rom_clauses, right, onclause
 #

 #f len(indexes) == 1:
 #eplace_from_obj_index = indexes[0]
 #eft = from_clauses[replace_from_obj_index]
 #lse:
 #otential = {}
 #tatement = self.statement

 #or from_clause in itertools.chain(
 #tertools.chain.from_iterable(
 #element._from_objects for element in raw_columns]
 #,
 #tertools.chain.from_iterable(
 #
 #lement._from_objects
 #or element in statement._where_criteria
 #
 #,
 #:

 #otential[from_clause] = ()

 #ll_clauses = list(potential.keys())
 #ndexes = sql_util.find_left_clause_to_join_from(
 #ll_clauses, right, onclause
 #

 #f len(indexes) == 1:
 #eft = all_clauses[indexes[0]]

 #f len(indexes) > 1:
 #aise exc.InvalidRequestError(
 #Can't determine which FROM clause to join "
 #from, there are multiple FROMS which can "
 #join to this entity. Please use the .select_from() "
 #method to establish an explicit left side, as well as "
 #providing an explicit ON clause if not present already to "
 #help resolve the ambiguity."
 #
 #lif not indexes:
 #aise exc.InvalidRequestError(
 #Don't know how to join to %r. "
 #Please use the .select_from() "
 #method to establish an explicit left side, as well as "
 #providing an explicit ON clause if not present already to "
 #help resolve the ambiguity." % (right,)
 #
 #eturn left, replace_from_obj_index

 #util.preload_module("sqlalchemy.sql.util")
 #ef _join_place_explicit_left_side(self, left):
 #eplace_from_obj_index = None

 #ql_util = util.preloaded.sql_util

 #rom_clauses = list(self.statement._iterate_from_elements())

 #f from_clauses:
 #ndexes = sql_util.find_left_clause_that_matches_given(
 #elf.from_clauses, left
 #
 #lse:
 #ndexes = []

 #f len(indexes) > 1:
 #aise exc.InvalidRequestError(
 #Can't identify which entity in which to assign the "
 #left side of this join.   Please use a more specific "
 #ON clause."
 #

        # have an index, means the left side is already present in
        # an existing FROM in the self._from_obj tuple
 #f indexes:
 #eplace_from_obj_index = indexes[0]

        # no index, means we need to add a new element to the
        # self._from_obj tuple

 #eturn replace_from_obj_index


class _SelectFromElements(object):
 #ef _iterate_from_elements(self):
        # note this does not include elements
        # in _setup_joins or _legacy_setup_joins

 #een = set()
 #or element in self._raw_columns:
 #or fr in element._from_objects:
 #f fr in seen:
 #ontinue
 #een.add(fr)
 #ield fr
 #or element in self._where_criteria:
 #or fr in element._from_objects:
 #f fr in seen:
 #ontinue
 #een.add(fr)
 #ield fr
 #or element in self._from_obj:
 #f element in seen:
 #ontinue
 #een.add(element)
 #ield element


class _MemoizedSelectEntities(
 #raversals.HasCacheKey, traversals.HasCopyInternals, visitors.Traversible
):
 #_visit_name__ = "memoized_select_entities"

 #traverse_internals = [
 #"_raw_columns", InternalTraversal.dp_clauseelement_list),
 #"_setup_joins", InternalTraversal.dp_setup_join_tuple),
 #"_legacy_setup_joins", InternalTraversal.dp_setup_join_tuple),
 #"_with_options", InternalTraversal.dp_executable_options),
 #

 #annotations = util.EMPTY_DICT

 #ef _clone(self, **kw):
 # = self.__class__.__new__(self.__class__)
 #.__dict__ = {k: v for k, v in self.__dict__.items()}
 #._is_clone_of = self
 #eturn c

 #classmethod
 #ef _generate_for_statement(cls, select_stmt):
 #f (
 #elect_stmt._setup_joins
 #r select_stmt._legacy_setup_joins
 #r select_stmt._with_options
 #:
 #elf = _MemoizedSelectEntities()
 #elf._raw_columns = select_stmt._raw_columns
 #elf._setup_joins = select_stmt._setup_joins
 #elf._legacy_setup_joins = select_stmt._legacy_setup_joins
 #elf._with_options = select_stmt._with_options

 #elect_stmt._memoized_select_entities += (self,)
 #elect_stmt._raw_columns = (
 #elect_stmt._setup_joins
 # = (
 #elect_stmt._legacy_setup_joins
 # = select_stmt._with_options = ()


class Select(
 #asPrefixes,
 #asSuffixes,
 #asHints,
 #asCompileState,
 #eprecatedSelectGenerations,
 #SelectFromElements,
 #enerativeSelect,
):
 #""Represents a ``SELECT`` statement.

 #he :class:`_sql.Select` object is normally constructed using the
 #func:`_sql.select` function.  See that function for details.

 #. seealso::

 #func:`_sql.select`

 #ref:`coretutorial_selecting` - in the 1.x tutorial

 #ref:`tutorial_selecting_data` - in the 2.0 tutorial

 #""

 #_visit_name__ = "select"

 #setup_joins = ()
 #legacy_setup_joins = ()
 #memoized_select_entities = ()

 #distinct = False
 #distinct_on = ()
 #correlate = ()
 #correlate_except = None
 #where_criteria = ()
 #having_criteria = ()
 #from_obj = ()
 #auto_correlate = True

 #compile_options = SelectState.default_select_compile_options

 #traverse_internals = (
 #
 #"_raw_columns", InternalTraversal.dp_clauseelement_list),
 #
 #_memoized_select_entities",
 #nternalTraversal.dp_memoized_select_entities,
 #,
 #"_from_obj", InternalTraversal.dp_clauseelement_list),
 #"_where_criteria", InternalTraversal.dp_clauseelement_tuple),
 #"_having_criteria", InternalTraversal.dp_clauseelement_tuple),
 #"_order_by_clauses", InternalTraversal.dp_clauseelement_tuple),
 #"_group_by_clauses", InternalTraversal.dp_clauseelement_tuple),
 #"_setup_joins", InternalTraversal.dp_setup_join_tuple),
 #"_legacy_setup_joins", InternalTraversal.dp_setup_join_tuple),
 #"_correlate", InternalTraversal.dp_clauseelement_tuple),
 #"_correlate_except", InternalTraversal.dp_clauseelement_tuple),
 #"_limit_clause", InternalTraversal.dp_clauseelement),
 #"_offset_clause", InternalTraversal.dp_clauseelement),
 #"_fetch_clause", InternalTraversal.dp_clauseelement),
 #"_fetch_clause_options", InternalTraversal.dp_plain_dict),
 #"_for_update_arg", InternalTraversal.dp_clauseelement),
 #"_distinct", InternalTraversal.dp_boolean),
 #"_distinct_on", InternalTraversal.dp_clauseelement_tuple),
 #"_label_style", InternalTraversal.dp_plain_obj),
 #
 # HasCTE._has_ctes_traverse_internals
 # HasPrefixes._has_prefixes_traverse_internals
 # HasSuffixes._has_suffixes_traverse_internals
 # HasHints._has_hints_traverse_internals
 # SupportsCloneAnnotations._clone_annotations_traverse_internals
 # Executable._executable_traverse_internals
 #

 #cache_key_traversal = _traverse_internals + [
 #"_compile_options", InternalTraversal.dp_has_cache_key)
 #

 #classmethod
 #ef _create_select_from_fromclause(cls, target, entities, *arg, **kw):
 #f arg or kw:
 #eturn Select.create_legacy_select(entities, *arg, **kw)
 #lse:
 #eturn Select._create_select(*entities)

 #classmethod
 #util.deprecated(
 #2.0",
 #The legacy calling style of :func:`_sql.select` is deprecated and "
 #will be removed in SQLAlchemy 2.0.  Please use the new calling "
 #style described at :func:`_sql.select`.",
 #
 #ef create_legacy_select(
 #ls,
 #olumns=None,
 #hereclause=None,
 #rom_obj=None,
 #istinct=False,
 #aving=None,
 #orrelate=True,
 #refixes=None,
 #uffixes=None,
 #*kwargs
 #:
 #""Construct a new :class:`_expression.Select` using the 1.x style API.

 #his method is called implicitly when the :func:`_expression.select`
 #onstruct is used and the first argument is a Python list or other
 #lain sequence object, which is taken to refer to the columns
 #ollection.

 #. versionchanged:: 1.4 Added the :meth:`.Select.create_legacy_select`
 #onstructor which documents the calling style in use when the
 #func:`.select` construct is invoked using 1.x-style arguments.

 #imilar functionality is also available via the
 #meth:`_expression.FromClause.select` method on any
 #class:`_expression.FromClause`.

 #ll arguments which accept :class:`_expression.ClauseElement` arguments
 #lso accept string arguments, which will be converted as appropriate
 #nto either :func:`_expression.text()` or
 #func:`_expression.literal_column()` constructs.

 #. seealso::

 #ref:`coretutorial_selecting` - Core Tutorial description of
 #func:`_expression.select`.

 #param columns:
 # list of :class:`_expression.ColumnElement` or
 #class:`_expression.FromClause`
 #bjects which will form the columns clause of the resulting
 #tatement.   For those objects that are instances of
 #class:`_expression.FromClause` (typically :class:`_schema.Table`
 #r :class:`_expression.Alias`
 #bjects), the :attr:`_expression.FromClause.c`
 #ollection is extracted
 #o form a collection of :class:`_expression.ColumnElement` objects.

 #his parameter will also accept :class:`_expression.TextClause`
 #onstructs as
 #iven, as well as ORM-mapped classes.

 #. note::

 #he :paramref:`_expression.select.columns`
 #arameter is not available
 #n the method form of :func:`_expression.select`, e.g.
 #meth:`_expression.FromClause.select`.

 #. seealso::

 #meth:`_expression.Select.column`

 #meth:`_expression.Select.with_only_columns`

 #param whereclause:
 # :class:`_expression.ClauseElement`
 #xpression which will be used to form the
 #`WHERE`` clause.   It is typically preferable to add WHERE
 #riterion to an existing :class:`_expression.Select`
 #sing method chaining
 #ith :meth:`_expression.Select.where`.

 #. seealso::

 #meth:`_expression.Select.where`

 #param from_obj:
 # list of :class:`_expression.ClauseElement`
 #bjects which will be added to the
 #`FROM`` clause of the resulting statement.  This is equivalent
 #o calling :meth:`_expression.Select.select_from`
 #sing method chaining on
 #n existing :class:`_expression.Select` object.

 #. seealso::

 #meth:`_expression.Select.select_from`
 # full description of explicit
 #ROM clause specification.

 #param bind=None:
 #n :class:`_engine.Engine` or :class:`_engine.Connection` instance
 #o which the
 #esulting :class:`_expression.Select` object will be bound.  The
 #class:`_expression.Select`
 #bject will otherwise automatically bind to
 #hatever :class:`~.base.Connectable` instances can be located within
 #ts contained :class:`_expression.ClauseElement` members.

 #param correlate=True:
 #ndicates that this :class:`_expression.Select`
 #bject should have its
 #ontained :class:`_expression.FromClause`
 #lements "correlated" to an enclosing
 #class:`_expression.Select` object.
 #t is typically preferable to specify
 #orrelations on an existing :class:`_expression.Select`
 #onstruct using
 #meth:`_expression.Select.correlate`.

 #. seealso::

 #meth:`_expression.Select.correlate`
 # full description of correlation.

 #param distinct=False:
 #hen ``True``, applies a ``DISTINCT`` qualifier to the columns
 #lause of the resulting statement.

 #he boolean argument may also be a column expression or list
 #f column expressions - this is a special calling form which
 #s understood by the PostgreSQL dialect to render the
 #`DISTINCT ON (<columns>)`` syntax.

 #`distinct`` is also available on an existing
 #class:`_expression.Select`
 #bject via the :meth:`_expression.Select.distinct` method.

 #. seealso::

 #meth:`_expression.Select.distinct`

 #param group_by:
 # list of :class:`_expression.ClauseElement`
 #bjects which will comprise the
 #`GROUP BY`` clause of the resulting select.  This parameter
 #s typically specified more naturally using the
 #meth:`_expression.Select.group_by` method on an existing
 #class:`_expression.Select`.

 #. seealso::

 #meth:`_expression.Select.group_by`

 #param having:
 # :class:`_expression.ClauseElement`
 #hat will comprise the ``HAVING`` clause
 #f the resulting select when ``GROUP BY`` is used.  This parameter
 #s typically specified more naturally using the
 #meth:`_expression.Select.having` method on an existing
 #class:`_expression.Select`.

 #. seealso::

 #meth:`_expression.Select.having`

 #param limit=None:
 # numerical value which usually renders as a ``LIMIT``
 #xpression in the resulting select.  Backends that don't
 #upport ``LIMIT`` will attempt to provide similar
 #unctionality.    This parameter is typically specified more
 #aturally using the :meth:`_expression.Select.limit`
 #ethod on an existing
 #class:`_expression.Select`.

 #. seealso::

 #meth:`_expression.Select.limit`

 #param offset=None:
 # numeric value which usually renders as an ``OFFSET``
 #xpression in the resulting select.  Backends that don't
 #upport ``OFFSET`` will attempt to provide similar
 #unctionality.  This parameter is typically specified more naturally
 #sing the :meth:`_expression.Select.offset` method on an existing
 #class:`_expression.Select`.

 #. seealso::

 #meth:`_expression.Select.offset`

 #param order_by:
 # scalar or list of :class:`_expression.ClauseElement`
 #bjects which will
 #omprise the ``ORDER BY`` clause of the resulting select.
 #his parameter is typically specified more naturally using the
 #meth:`_expression.Select.order_by` method on an existing
 #class:`_expression.Select`.

 #. seealso::

 #meth:`_expression.Select.order_by`

 #param use_labels=False:
 #hen ``True``, the statement will be generated using labels
 #or each column in the columns clause, which qualify each
 #olumn with its parent table's (or aliases) name so that name
 #onflicts between columns in different tables don't occur.
 #he format of the label is ``<tablename>_<column>``.  The "c"
 #ollection of a :class:`_expression.Subquery` created
 #gainst this :class:`_expression.Select`
 #bject, as well as the :attr:`_expression.Select.selected_columns`
 #ollection of the :class:`_expression.Select` itself, will use these
 #ames for targeting column members.

 #his parameter can also be specified on an existing
 #class:`_expression.Select` object using the
 #meth:`_expression.Select.set_label_style`
 #ethod.

 #. seealso::

 #meth:`_expression.Select.set_label_style`

 #""
 #elf = cls.__new__(cls)

 #elf._auto_correlate = correlate

 #f distinct is not False:
 #f distinct is True:
 #elf.distinct.non_generative(self)
 #lse:
 #elf.distinct.non_generative(self, *util.to_list(distinct))

 #f from_obj is not None:
 #elf.select_from.non_generative(self, *util.to_list(from_obj))

 #ry:
 #ols_present = bool(columns)
 #xcept TypeError as err:
 #til.raise_(
 #xc.ArgumentError(
 #select() construct created in legacy mode, i.e. with "
 #keyword arguments, must provide the columns argument as "
 #a Python list or other iterable.",
 #ode="c9ae",
 #,
 #rom_=err,
 #

 #f cols_present:
 #elf._raw_columns = [
 #oercions.expect(
 #oles.ColumnsClauseRole, c, apply_propagate_attrs=self
 #
 #or c in columns
 #
 #lse:
 #elf._raw_columns = []

 #f whereclause is not None:
 #elf.where.non_generative(self, whereclause)

 #f having is not None:
 #elf.having.non_generative(self, having)

 #f prefixes:
 #elf._setup_prefixes(prefixes)

 #f suffixes:
 #elf._setup_suffixes(suffixes)

 #enerativeSelect.__init__(self, **kwargs)
 #eturn self

 #classmethod
 #ef _create_future_select(cls, *entities):
 #"""Construct a new :class:`_expression.Select` using the 2.
 # style API.

 #. versionadded:: 1.4 - The :func:`_sql.select` function now accepts
 #olumn arguments positionally.   The top-level :func:`_sql.select`
 #unction will automatically use the 1.x or 2.x style API based on
 #he incoming arguments; using :func:`_future.select` from the
 #`sqlalchemy.future`` module will enforce that only the 2.x style
 #onstructor is used.

 #imilar functionality is also available via the
 #meth:`_expression.FromClause.select` method on any
 #class:`_expression.FromClause`.

 #. seealso::

 #ref:`coretutorial_selecting` - Core Tutorial description of
 #func:`_expression.select`.

 #param \*entities:
 #ntities to SELECT from.  For Core usage, this is typically a series
 #f :class:`_expression.ColumnElement` and / or
 #class:`_expression.FromClause`
 #bjects which will form the columns clause of the resulting
 #tatement.   For those objects that are instances of
 #class:`_expression.FromClause` (typically :class:`_schema.Table`
 #r :class:`_expression.Alias`
 #bjects), the :attr:`_expression.FromClause.c`
 #ollection is extracted
 #o form a collection of :class:`_expression.ColumnElement` objects.

 #his parameter will also accept :class:`_expression.TextClause`
 #onstructs as
 #iven, as well as ORM-mapped classes.

 #""

 #elf = cls.__new__(cls)
 #elf._raw_columns = [
 #oercions.expect(
 #oles.ColumnsClauseRole, ent, apply_propagate_attrs=self
 #
 #or ent in entities
 #

 #enerativeSelect.__init__(self)

 #eturn self

 #create_select = _create_future_select

 #classmethod
 #ef _create(cls, *args, **kw):
 #"""Create a :class:`.Select` using either the 1.x or 2.0 constructor
 #tyle.

 #or the legacy calling style, see :meth:`.Select.create_legacy_select`.
 #f the first argument passed is a Python sequence or if keyword
 #rguments are present, this style is used.

 #. versionadded:: 2.0 - the :func:`_future.select` construct is
 #he same construct as the one returned by
 #func:`_expression.select`, except that the function only
 #ccepts the "columns clause" entities up front; the rest of the
 #tate of the SELECT should be built up using generative methods.

 #imilar functionality is also available via the
 #meth:`_expression.FromClause.select` method on any
 #class:`_expression.FromClause`.

 #. seealso::

 #ref:`coretutorial_selecting` - Core Tutorial description of
 #func:`_expression.select`.

 #param \*entities:
 #ntities to SELECT from.  For Core usage, this is typically a series
 #f :class:`_expression.ColumnElement` and / or
 #class:`_expression.FromClause`
 #bjects which will form the columns clause of the resulting
 #tatement.   For those objects that are instances of
 #class:`_expression.FromClause` (typically :class:`_schema.Table`
 #r :class:`_expression.Alias`
 #bjects), the :attr:`_expression.FromClause.c`
 #ollection is extracted
 #o form a collection of :class:`_expression.ColumnElement` objects.

 #his parameter will also accept :class:`_expression.TextClause`
 #onstructs as given, as well as ORM-mapped classes.

 #""
 #f (
 #rgs
 #nd (
 #sinstance(args[0], list)
 #r (
 #asattr(args[0], "__iter__")
 #nd not isinstance(
 #rgs[0], util.string_types + (ClauseElement,)
 #
 #nd inspect(args[0], raiseerr=False) is None
 #nd not hasattr(args[0], "__clause_element__")
 #
 #
 # or kw:
 #eturn cls.create_legacy_select(*args, **kw)
 #lse:
 #eturn cls._create_future_select(*args)

 #ef __init__(self):
 #aise NotImplementedError()

 #ef _scalar_type(self):
 #lem = self._raw_columns[0]
 #ols = list(elem._select_iterable)
 #eturn cols[0].type

 #ef filter(self, *criteria):
 #""A synonym for the :meth:`_future.Select.where` method."""

 #eturn self.where(*criteria)

 #ef _filter_by_zero(self):
 #f self._setup_joins:
 #eth = SelectState.get_plugin_class(
 #elf
 #.determine_last_joined_entity
 #last_joined_entity = meth(self)
 #f _last_joined_entity is not None:
 #eturn _last_joined_entity

 #f self._from_obj:
 #eturn self._from_obj[0]

 #eturn self._raw_columns[0]

 #ef filter_by(self, **kwargs):
 #"""apply the given filtering criterion as a WHERE clause
 #o this select.

 #""
 #rom_entity = self._filter_by_zero()

 #lauses = [
 #entity_namespace_key(from_entity, key) == value
 #or key, value in kwargs.items()
 #
 #eturn self.filter(*clauses)

 #property
 #ef column_descriptions(self):
 #""Return a 'column descriptions' structure which may be
 #term:`plugin-specific`.

 #""
 #eth = SelectState.get_plugin_class(self).get_column_descriptions
 #eturn meth(self)

 #ef from_statement(self, statement):
 #""Apply the columns which this :class:`.Select` would select
 #nto another statement.

 #his operation is :term:`plugin-specific` and will raise a not
 #upported exception if this :class:`_sql.Select` does not select from
 #lugin-enabled entities.


 #he statement is typically either a :func:`_expression.text` or
 #func:`_expression.select` construct, and should return the set of
 #olumns appropriate to the entities represented by this
 #class:`.Select`.

 #. seealso::

 #ref:`orm_queryguide_selecting_text` - usage examples in the
 #RM Querying Guide

 #""
 #eth = SelectState.get_plugin_class(self).from_statement
 #eturn meth(self, statement)

 #_generative
 #ef join(self, target, onclause=None, isouter=False, full=False):
 #"""Create a SQL JOIN against this :class:`_expression.Select`
 #bject's criterion
 #nd apply generatively, returning the newly resulting
 #class:`_expression.Select`.

 #.g.::

 #tmt = select(user_table).join(address_table, user_table.c.id == address_table.c.user_id)

 #he above statement generates SQL similar to::

 #ELECT user.id, user.name FROM user JOIN address ON user.id = address.user_id

 #. versionchanged:: 1.4 :meth:`_expression.Select.join` now creates
 # :class:`_sql.Join` object between a :class:`_sql.FromClause`
 #ource that is within the FROM clause of the existing SELECT,
 #nd a given target :class:`_sql.FromClause`, and then adds
 #his :class:`_sql.Join` to the FROM clause of the newly generated
 #ELECT statement.    This is completely reworked from the behavior
 #n 1.3, which would instead create a subquery of the entire
 #class:`_expression.Select` and then join that subquery to the
 #arget.

 #his is a **backwards incompatible change** as the previous behavior
 #as mostly useless, producing an unnamed subquery rejected by
 #ost databases in any case.   The new behavior is modeled after
 #hat of the very successful :meth:`_orm.Query.join` method in the
 #RM, in order to support the functionality of :class:`_orm.Query`
 #eing available by using a :class:`_sql.Select` object with an
 #class:`_orm.Session`.

 #ee the notes for this change at :ref:`change_select_join`.


 #param target: target table to join towards

 #param onclause: ON clause of the join.  If omitted, an ON clause
 #s generated automatically based on the :class:`_schema.ForeignKey`
 #inkages between the two tables, if one can be unambiguously
 #etermined, otherwise an error is raised.

 #param isouter: if True, generate LEFT OUTER join.  Same as
 #meth:`_expression.Select.outerjoin`.

 #param full: if True, generate FULL OUTER join.

 #. seealso::

 #ref:`tutorial_select_join` - in the :doc:`/tutorial/index`

 #ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel`

 #meth:`_expression.Select.join_from`

 #meth:`_expression.Select.outerjoin`

 #""  # noqa: E501
 #arget = coercions.expect(
 #oles.JoinTargetRole, target, apply_propagate_attrs=self
 #
 #f onclause is not None:
 #nclause = coercions.expect(roles.OnClauseRole, onclause)
 #elf._setup_joins += (
 #target, onclause, None, {"isouter": isouter, "full": full}),
 #

 #ef outerjoin_from(self, from_, target, onclause=None, full=False):
 #"""Create a SQL LEFT OUTER JOIN against this :class:`_expression.Select`
 #bject's criterion
 #nd apply generatively, returning the newly resulting
 #class:`_expression.Select`.

 #sage is the same as that of :meth:`_selectable.Select.join_from`.

 #""
 #eturn self.join_from(
 #rom_, target, onclause=onclause, isouter=True, full=full
 #

 #_generative
 #ef join_from(
 #elf, from_, target, onclause=None, isouter=False, full=False
 #:
 #"""Create a SQL JOIN against this :class:`_expression.Select`
 #bject's criterion
 #nd apply generatively, returning the newly resulting
 #class:`_expression.Select`.

 #.g.::

 #tmt = select(user_table, address_table).join_from(
 #ser_table, address_table, user_table.c.id == address_table.c.user_id
 #

 #he above statement generates SQL similar to::

 #ELECT user.id, user.name, address.id, address.email, address.user_id
 #ROM user JOIN address ON user.id = address.user_id

 #. versionadded:: 1.4

 #param from\_: the left side of the join, will be rendered in the
 #ROM clause and is roughly equivalent to using the
 #meth:`.Select.select_from` method.

 #param target: target table to join towards

 #param onclause: ON clause of the join.

 #param isouter: if True, generate LEFT OUTER join.  Same as
 #meth:`_expression.Select.outerjoin`.

 #param full: if True, generate FULL OUTER join.

 #. seealso::

 #ref:`tutorial_select_join` - in the :doc:`/tutorial/index`

 #ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel`

 #meth:`_expression.Select.join`

 #""  # noqa: E501

        # note the order of parsing from vs. target is important here, as we
        # are also deriving the source of the plugin (i.e. the subject mapper
        # in an ORM query) which should favor the "from_" over the "target"

 #rom_ = coercions.expect(
 #oles.FromClauseRole, from_, apply_propagate_attrs=self
 #
 #arget = coercions.expect(
 #oles.JoinTargetRole, target, apply_propagate_attrs=self
 #
 #f onclause is not None:
 #nclause = coercions.expect(roles.OnClauseRole, onclause)

 #elf._setup_joins += (
 #target, onclause, from_, {"isouter": isouter, "full": full}),
 #

 #ef outerjoin(self, target, onclause=None, full=False):
 #""Create a left outer join.

 #arameters are the same as that of :meth:`_expression.Select.join`.

 #. versionchanged:: 1.4 :meth:`_expression.Select.outerjoin` now
 #reates a :class:`_sql.Join` object between a
 #class:`_sql.FromClause` source that is within the FROM clause of
 #he existing SELECT, and a given target :class:`_sql.FromClause`,
 #nd then adds this :class:`_sql.Join` to the FROM clause of the
 #ewly generated SELECT statement.    This is completely reworked
 #rom the behavior in 1.3, which would instead create a subquery of
 #he entire
 #class:`_expression.Select` and then join that subquery to the
 #arget.

 #his is a **backwards incompatible change** as the previous behavior
 #as mostly useless, producing an unnamed subquery rejected by
 #ost databases in any case.   The new behavior is modeled after
 #hat of the very successful :meth:`_orm.Query.join` method in the
 #RM, in order to support the functionality of :class:`_orm.Query`
 #eing available by using a :class:`_sql.Select` object with an
 #class:`_orm.Session`.

 #ee the notes for this change at :ref:`change_select_join`.

 #. seealso::

 #ref:`tutorial_select_join` - in the :doc:`/tutorial/index`

 #ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel`

 #meth:`_expression.Select.join`

 #""
 #eturn self.join(target, onclause=onclause, isouter=True, full=full)

 #property
 #ef froms(self):
 #""Return the displayed list of :class:`_expression.FromClause`
 #lements.

 #""
 #eturn self._compile_state_factory(self, None)._get_display_froms()

 #property
 #ef inner_columns(self):
 #""An iterator of all :class:`_expression.ColumnElement`
 #xpressions which would
 #e rendered into the columns clause of the resulting SELECT statement.

 #his method is legacy as of 1.4 and is superseded by the
 #attr:`_expression.Select.exported_columns` collection.

 #""

 #eturn iter(self._all_selected_columns)

 #ef is_derived_from(self, fromclause):
 #f self in fromclause._cloned_set:
 #eturn True

 #or f in self._iterate_from_elements():
 #f f.is_derived_from(fromclause):
 #eturn True
 #eturn False

 #ef _copy_internals(self, clone=_clone, **kw):
        # Select() object has been cloned and probably adapted by the
        # given clone function.  Apply the cloning function to internal
        # objects

        # 1. keep a dictionary of the froms we've cloned, and what
        # they've become.  This allows us to ensure the same cloned from
        # is used when other items such as columns are "cloned"

 #ll_the_froms = set(
 #tertools.chain(
 #from_objects(*self._raw_columns),
 #from_objects(*self._where_criteria),
 #
 #

        # do a clone for the froms we've gathered.  what is important here
        # is if any of the things we are selecting from, like tables,
        # were converted into Join objects.   if so, these need to be
        # added to _from_obj explicitly, because otherwise they won't be
        # part of the new state, as they don't associate themselves with
        # their columns.
 #ew_froms = {f: clone(f, **kw) for f in all_the_froms}

        # 2. copy FROM collections, adding in joins that we've created.
 #xisting_from_obj = [clone(f, **kw) for f in self._from_obj]
 #dd_froms = (
 #et(f for f in new_froms.values() if isinstance(f, Join))
 #difference(all_the_froms)
 #difference(existing_from_obj)
 #

 #elf._from_obj = tuple(existing_from_obj) + tuple(add_froms)

        # 3. clone everything else, making sure we use columns
        # corresponding to the froms we just made.
 #ef replace(obj, **kw):
 #f isinstance(obj, ColumnClause) and obj.table in new_froms:
 #ewelem = new_froms[obj.table].corresponding_column(obj)
 #eturn newelem

 #w["replace"] = replace

        # copy everything else.   for table-ish things like correlate,
        # correlate_except, setup_joins, these clone normally.  For
        # column-expression oriented things like raw_columns, where_criteria,
        # order by, we get this from the new froms.
 #uper(Select, self)._copy_internals(
 #lone=clone, omit_attrs=("_from_obj",), **kw
 #

 #elf._reset_memoizations()

 #ef get_children(self, **kwargs):
 #eturn itertools.chain(
 #uper(Select, self).get_children(
 #mit_attrs=["_from_obj", "_correlate", "_correlate_except"]
 #,
 #elf._iterate_from_elements(),
 #

 #_generative
 #ef add_columns(self, *columns):
 #""Return a new :func:`_expression.select` construct with
 #he given column expressions added to its columns clause.

 #.g.::

 #y_select = my_select.add_columns(table.c.new_column)

 #ee the documentation for
 #meth:`_expression.Select.with_only_columns`
 #or guidelines on adding /replacing the columns of a
 #class:`_expression.Select` object.

 #""
 #elf._reset_memoizations()

 #elf._raw_columns = self._raw_columns + [
 #oercions.expect(
 #oles.ColumnsClauseRole, column, apply_propagate_attrs=self
 #
 #or column in columns
 #

 #ef _set_entities(self, entities):
 #elf._raw_columns = [
 #oercions.expect(
 #oles.ColumnsClauseRole, ent, apply_propagate_attrs=self
 #
 #or ent in util.to_list(entities)
 #

 #util.deprecated(
 #1.4",
 #The :meth:`_expression.Select.column` method is deprecated and will "
 #be removed in a future release.  Please use "
 #:meth:`_expression.Select.add_columns`",
 #
 #ef column(self, column):
 #""Return a new :func:`_expression.select` construct with
 #he given column expression added to its columns clause.

 #.g.::

 #y_select = my_select.column(table.c.new_column)

 #ee the documentation for
 #meth:`_expression.Select.with_only_columns`
 #or guidelines on adding /replacing the columns of a
 #class:`_expression.Select` object.

 #""
 #eturn self.add_columns(column)

 #util.preload_module("sqlalchemy.sql.util")
 #ef reduce_columns(self, only_synonyms=True):
 #""Return a new :func:`_expression.select` construct with redundantly
 #amed, equivalently-valued columns removed from the columns clause.

 #Redundant" here means two columns where one refers to the
 #ther either based on foreign key, or via a simple equality
 #omparison in the WHERE clause of the statement.   The primary purpose
 #f this method is to automatically construct a select statement
 #ith all uniquely-named columns, without the need to use
 #able-qualified labels as
 #meth:`_expression.Select.set_label_style`
 #oes.

 #hen columns are omitted based on foreign key, the referred-to
 #olumn is the one that's kept.  When columns are omitted based on
 #HERE equivalence, the first column in the columns clause is the
 #ne that's kept.

 #param only_synonyms: when True, limit the removal of columns
 #o those which have the same name as the equivalent.   Otherwise,
 #ll columns that are equivalent to another are removed.

 #""
 #eturn self.with_only_columns(
 #util.preloaded.sql_util.reduce_columns(
 #elf._all_selected_columns,
 #nly_synonyms=only_synonyms,
 #(self._where_criteria + self._from_obj)
 #
 #

 #_generative
 #ef with_only_columns(self, *columns):
 #"""Return a new :func:`_expression.select` construct with its columns
 #lause replaced with the given columns.

 #his method is exactly equivalent to as if the original
 #func:`_expression.select` had been called with the given columns
 #lause.   I.e. a statement::

 # = select(table1.c.a, table1.c.b)
 # = s.with_only_columns(table1.c.b)

 #hould be exactly equivalent to::

 # = select(table1.c.b)

 #ote that this will also dynamically alter the FROM clause of the
 #tatement if it is not explicitly stated.  To maintain the FROM
 #lause, ensure the :meth:`_sql.Select.select_from` method is
 #sed appropriately::

 # = select(table1.c.a, table2.c.b)
 # = s.select_from(table2.c.b).with_only_columns(table1.c.a)

 #param \*columns: column expressions to be used.

 #. versionchanged:: 1.4 the :meth:`_sql.Select.with_only_columns`
 #ethod accepts the list of column expressions positionally;
 #assing the expressions as a list is deprecated.

 #""

        # memoizations should be cleared here as of
        # I95c560ffcbfa30b26644999412fb6a385125f663 , asserting this
        # is the case for now.
 #elf._assert_no_memoizations()

 #MemoizedSelectEntities._generate_for_statement(self)

 #elf._raw_columns = [
 #oercions.expect(roles.ColumnsClauseRole, c)
 #or c in coercions._expression_collection_was_a_list(
 #columns", "Select.with_only_columns", columns
 #
 #

 #property
 #ef whereclause(self):
 #""Return the completed WHERE clause for this
 #class:`_expression.Select` statement.

 #his assembles the current collection of WHERE criteria
 #nto a single :class:`_expression.BooleanClauseList` construct.


 #. versionadded:: 1.4

 #""

 #eturn BooleanClauseList._construct_for_whereclause(
 #elf._where_criteria
 #

 #whereclause = whereclause

 #_generative
 #ef where(self, *whereclause):
 #""Return a new :func:`_expression.select` construct with
 #he given expression added to
 #ts WHERE clause, joined to the existing clause via AND, if any.

 #""

 #ssert isinstance(self._where_criteria, tuple)

 #or criterion in whereclause:
 #here_criteria = coercions.expect(roles.WhereHavingRole, criterion)
 #elf._where_criteria += (where_criteria,)

 #_generative
 #ef having(self, having):
 #""Return a new :func:`_expression.select` construct with
 #he given expression added to
 #ts HAVING clause, joined to the existing clause via AND, if any.

 #""
 #elf._having_criteria += (
 #oercions.expect(roles.WhereHavingRole, having),
 #

 #_generative
 #ef distinct(self, *expr):
 #"""Return a new :func:`_expression.select` construct which
 #ill apply DISTINCT to its columns clause.

 #param \*expr: optional column expressions.  When present,
 #he PostgreSQL dialect will render a ``DISTINCT ON (<expressions>>)``
 #onstruct.

 #. deprecated:: 1.4 Using \*expr in other dialects is deprecated
 #nd will raise :class:`_exc.CompileError` in a future version.

 #""
 #f expr:
 #elf._distinct = True
 #elf._distinct_on = self._distinct_on + tuple(
 #oercions.expect(roles.ByOfRole, e) for e in expr
 #
 #lse:
 #elf._distinct = True

 #_generative
 #ef select_from(self, *froms):
 #"""Return a new :func:`_expression.select` construct with the
 #iven FROM expression(s)
 #erged into its list of FROM objects.

 #.g.::

 #able1 = table('t1', column('a'))
 #able2 = table('t2', column('b'))
 # = select(table1.c.a).\
 #elect_from(
 #able1.join(table2, table1.c.a==table2.c.b)
 #

 #he "from" list is a unique set on the identity of each element,
 #o adding an already present :class:`_schema.Table`
 #r other selectable
 #ill have no effect.   Passing a :class:`_expression.Join` that refers
 #o an already present :class:`_schema.Table`
 #r other selectable will have
 #he effect of concealing the presence of that selectable as
 #n individual element in the rendered FROM list, instead
 #endering it into a JOIN clause.

 #hile the typical purpose of :meth:`_expression.Select.select_from`
 #s to
 #eplace the default, derived FROM clause with a join, it can
 #lso be called with individual table elements, multiple times
 #f desired, in the case that the FROM clause cannot be fully
 #erived from the columns clause::

 #elect(func.count('*')).select_from(table1)

 #""

 #elf._from_obj += tuple(
 #oercions.expect(
 #oles.FromClauseRole, fromclause, apply_propagate_attrs=self
 #
 #or fromclause in froms
 #

 #_generative
 #ef correlate(self, *fromclauses):
 #"""Return a new :class:`_expression.Select`
 #hich will correlate the given FROM
 #lauses to that of an enclosing :class:`_expression.Select`.

 #alling this method turns off the :class:`_expression.Select` object's
 #efault behavior of "auto-correlation".  Normally, FROM elements
 #hich appear in a :class:`_expression.Select`
 #hat encloses this one via
 #ts :term:`WHERE clause`, ORDER BY, HAVING or
 #term:`columns clause` will be omitted from this
 #class:`_expression.Select`
 #bject's :term:`FROM clause`.
 #etting an explicit correlation collection using the
 #meth:`_expression.Select.correlate`
 #ethod provides a fixed list of FROM objects
 #hat can potentially take place in this process.

 #hen :meth:`_expression.Select.correlate`
 #s used to apply specific FROM clauses
 #or correlation, the FROM elements become candidates for
 #orrelation regardless of how deeply nested this
 #class:`_expression.Select`
 #bject is, relative to an enclosing :class:`_expression.Select`
 #hich refers to
 #he same FROM object.  This is in contrast to the behavior of
 #auto-correlation" which only correlates to an immediate enclosing
 #class:`_expression.Select`.
 #ulti-level correlation ensures that the link
 #etween enclosed and enclosing :class:`_expression.Select`
 #s always via
 #t least one WHERE/ORDER BY/HAVING/columns clause in order for
 #orrelation to take place.

 #f ``None`` is passed, the :class:`_expression.Select`
 #bject will correlate
 #one of its FROM entries, and all will render unconditionally
 #n the local FROM clause.

 #param \*fromclauses: a list of one or more
 #class:`_expression.FromClause`
 #onstructs, or other compatible constructs (i.e. ORM-mapped
 #lasses) to become part of the correlate collection.

 #. seealso::

 #meth:`_expression.Select.correlate_except`

 #ref:`correlated_subqueries`

 #""

 #elf._auto_correlate = False
 #f fromclauses and fromclauses[0] in {None, False}:
 #elf._correlate = ()
 #lse:
 #elf._correlate = self._correlate + tuple(
 #oercions.expect(roles.FromClauseRole, f) for f in fromclauses
 #

 #_generative
 #ef correlate_except(self, *fromclauses):
 #"""Return a new :class:`_expression.Select`
 #hich will omit the given FROM
 #lauses from the auto-correlation process.

 #alling :meth:`_expression.Select.correlate_except` turns off the
 #class:`_expression.Select` object's default behavior of
 #auto-correlation" for the given FROM elements.  An element
 #pecified here will unconditionally appear in the FROM list, while
 #ll other FROM elements remain subject to normal auto-correlation
 #ehaviors.

 #f ``None`` is passed, the :class:`_expression.Select`
 #bject will correlate
 #ll of its FROM entries.

 #param \*fromclauses: a list of one or more
 #class:`_expression.FromClause`
 #onstructs, or other compatible constructs (i.e. ORM-mapped
 #lasses) to become part of the correlate-exception collection.

 #. seealso::

 #meth:`_expression.Select.correlate`

 #ref:`correlated_subqueries`

 #""

 #elf._auto_correlate = False
 #f fromclauses and fromclauses[0] in {None, False}:
 #elf._correlate_except = ()
 #lse:
 #elf._correlate_except = (self._correlate_except or ()) + tuple(
 #oercions.expect(roles.FromClauseRole, f) for f in fromclauses
 #

 #HasMemoized.memoized_attribute
 #ef selected_columns(self):
 #""A :class:`_expression.ColumnCollection`
 #epresenting the columns that
 #his SELECT statement or similar construct returns in its result set,
 #ot including :class:`_sql.TextClause` constructs.

 #his collection differs from the :attr:`_expression.FromClause.columns`
 #ollection of a :class:`_expression.FromClause` in that the columns
 #ithin this collection cannot be directly nested inside another SELECT
 #tatement; a subquery must be applied first which provides for the
 #ecessary parenthesization required by SQL.

 #or a :func:`_expression.select` construct, the collection here is
 #xactly what would be rendered inside the "SELECT" statement, and the
 #class:`_expression.ColumnElement` objects are directly present as they
 #ere given, e.g.::

 #ol1 = column('q', Integer)
 #ol2 = column('p', Integer)
 #tmt = select(col1, col2)

 #bove, ``stmt.selected_columns`` would be a collection that contains
 #he ``col1`` and ``col2`` objects directly. For a statement that is
 #gainst a :class:`_schema.Table` or other
 #class:`_expression.FromClause`, the collection will use the
 #class:`_expression.ColumnElement` objects that are in the
 #attr:`_expression.FromClause.c` collection of the from element.

 #. note::

 #he :attr:`_sql.Select.selected_columns` collection does not
 #nclude expressions established in the columns clause using the
 #func:`_sql.text` construct; these are silently omitted from the
 #ollection. To use plain textual column expressions inside of a
 #class:`_sql.Select` construct, use the :func:`_sql.literal_column`
 #onstruct.


 #. versionadded:: 1.4

 #""

        # compare to SelectState._generate_columns_plus_names, which
        # generates the actual names used in the SELECT string.  that
        # method is more complex because it also renders columns that are
        # fully ambiguous, e.g. same column more than once.
 #onv = SelectState._column_naming_convention(self._label_style)

 #eturn ColumnCollection(
 #
 #conv(c), c)
 #or c in self._all_selected_columns
 #f not c._is_text_clause
 #
 #.as_immutable()

 #HasMemoized.memoized_attribute
 #ef _all_selected_columns(self):
 #eth = SelectState.get_plugin_class(self).all_selected_columns
 #eturn list(meth(self))

 #ef _ensure_disambiguated_names(self):
 #f self._label_style is LABEL_STYLE_NONE:
 #elf = self.set_label_style(LABEL_STYLE_DISAMBIGUATE_ONLY)
 #eturn self

 #ef _generate_columns_plus_names(self, anon_for_dupe_key):
 #""Generate column names as rendered in a SELECT statement by
 #he compiler.

 #his is distinct from the _column_naming_convention generator that's
 #ntended for population of .c collections and similar, which has
 #ifferent rules.   the collection returned here calls upon the
 #column_naming_convention as well.

 #""
 #ols = self._all_selected_columns

 #ey_naming_convention = SelectState._column_naming_convention(
 #elf._label_style
 #

 #ames = {}

 #esult = []
 #esult_append = result.append

 #able_qualified = self._label_style is LABEL_STYLE_TABLENAME_PLUS_COL
 #abel_style_none = self._label_style is LABEL_STYLE_NONE

 #or c in cols:
 #epeated = False

 #f not c._render_label_in_columns_clause:
 #ffective_name = (
 #equired_label_name
 # = fallback_label_name = None
 #lif label_style_none:
 #ffective_name = required_label_name = None
 #allback_label_name = c._non_anon_label or c._anon_name_label
 #lse:
 #f table_qualified:
 #equired_label_name = (
 #ffective_name
 # = fallback_label_name = c._tq_label
 #lse:
 #ffective_name = fallback_label_name = c._non_anon_label
 #equired_label_name = None

 #f effective_name is None:
                    # it seems like this could be _proxy_key and we would
                    # not need _expression_label but it isn't
                    # giving us a clue when to use anon_label instead
 #xpr_label = c._expression_label
 #f expr_label is None:
 #epeated = c._anon_name_label in names
 #ames[c._anon_name_label] = c
 #ffective_name = required_label_name = None

 #f repeated:
                            # here, "required_label_name" is sent as
                            # "None" and "fallback_label_name" is sent.
 #f table_qualified:
 #allback_label_name = c._dedupe_anon_tq_label
 #lse:
 #allback_label_name = c._dedupe_anon_label
 #lse:
 #allback_label_name = c._anon_name_label
 #lse:
 #equired_label_name = (
 #ffective_name
 # = fallback_label_name = expr_label

 #f effective_name is not None:
 #f effective_name in names:
                    # when looking to see if names[name] is the same column as
                    # c, use hash(), so that an annotated version of the column
                    # is seen as the same as the non-annotated
 #f hash(names[effective_name]) != hash(c):

                        # different column under the same name.  apply
                        # disambiguating label
 #f table_qualified:
 #equired_label_name = (
 #allback_label_name
 # = c._anon_tq_label
 #lse:
 #equired_label_name = (
 #allback_label_name
 # = c._anon_name_label

 #f anon_for_dupe_key and required_label_name in names:
                            # here, c._anon_tq_label is definitely unique to
                            # that column identity (or annotated version), so
                            # this should always be true.
                            # this is also an infrequent codepath because
                            # you need two levels of duplication to be here
 #ssert hash(names[required_label_name]) == hash(c)

                            # the column under the disambiguating label is
                            # already present.  apply the "dedupe" label to
                            # subsequent occurrences of the column so that the
                            # original stays non-ambiguous
 #f table_qualified:
 #equired_label_name = (
 #allback_label_name
 # = c._dedupe_anon_tq_label
 #lse:
 #equired_label_name = (
 #allback_label_name
 # = c._dedupe_anon_label
 #epeated = True
 #lse:
 #ames[required_label_name] = c
 #lif anon_for_dupe_key:
                        # same column under the same name. apply the "dedupe"
                        # label so that the original stays non-ambiguous
 #f table_qualified:
 #equired_label_name = (
 #allback_label_name
 # = c._dedupe_anon_tq_label
 #lse:
 #equired_label_name = (
 #allback_label_name
 # = c._dedupe_anon_label
 #epeated = True
 #lse:
 #ames[effective_name] = c

 #esult_append(
 #
                    # string label name, if non-None, must be rendered as a
                    # label, i.e. "AS <name>"
 #equired_label_name,
                    # proxy_key that is to be part of the result map for this
                    # col.  this is also the key in a fromclause.c or
                    # select.selected_columns collection
 #ey_naming_convention(c),
                    # name that can be used to render an "AS <name>" when
                    # we have to render a label even though
                    # required_label_name was not given
 #allback_label_name,
                    # the ColumnElement itself
 #,
                    # True if this is a duplicate of a previous column
                    # in the list of columns
 #epeated,
 #
 #

 #eturn result

 #ef _generate_fromclause_column_proxies(self, subquery):
 #""Generate column proxies to place in the exported ``.c``
 #ollection of a subquery."""

 #rox = [
 #._make_proxy(
 #ubquery,
 #ey=proxy_key,
 #ame=required_label_name,
 #ame_is_truncatable=True,
 #
 #or (
 #equired_label_name,
 #roxy_key,
 #allback_label_name,
 #,
 #epeated,
 # in (self._generate_columns_plus_names(False))
 #f not c._is_text_clause
 #

 #ubquery._columns._populate_separate_keys(prox)

 #ef _needs_parens_for_grouping(self):
 #eturn self._has_row_limiting_clause or bool(
 #elf._order_by_clause.clauses
 #

 #ef self_group(self, against=None):
 #""Return a 'grouping' construct as per the
 #class:`_expression.ClauseElement` specification.

 #his produces an element that can be embedded in an expression. Note
 #hat this method is called automatically as needed when constructing
 #xpressions and should not require explicit use.

 #""
 #f (
 #sinstance(against, CompoundSelect)
 #nd not self._needs_parens_for_grouping()
 #:
 #eturn self
 #lse:
 #eturn SelectStatementGrouping(self)

 #ef union(self, other, **kwargs):
 #""Return a SQL ``UNION`` of this select() construct against
 #he given selectable.

 #""
 #eturn CompoundSelect._create_union(self, other, **kwargs)

 #ef union_all(self, other, **kwargs):
 #""Return a SQL ``UNION ALL`` of this select() construct against
 #he given selectable.

 #""
 #eturn CompoundSelect._create_union_all(self, other, **kwargs)

 #ef except_(self, other, **kwargs):
 #""Return a SQL ``EXCEPT`` of this select() construct against
 #he given selectable.

 #""
 #eturn CompoundSelect._create_except(self, other, **kwargs)

 #ef except_all(self, other, **kwargs):
 #""Return a SQL ``EXCEPT ALL`` of this select() construct against
 #he given selectable.

 #""
 #eturn CompoundSelect._create_except_all(self, other, **kwargs)

 #ef intersect(self, other, **kwargs):
 #""Return a SQL ``INTERSECT`` of this select() construct against
 #he given selectable.

 #""
 #eturn CompoundSelect._create_intersect(self, other, **kwargs)

 #ef intersect_all(self, other, **kwargs):
 #""Return a SQL ``INTERSECT ALL`` of this select() construct
 #gainst the given selectable.

 #""
 #eturn CompoundSelect._create_intersect_all(self, other, **kwargs)

 #property
 #util.deprecated_20(
 #:attr:`.Executable.bind`",
 #lternative="Bound metadata is being removed as of SQLAlchemy 2.0.",
 #nable_warnings=False,
 #
 #ef bind(self):
 #""Returns the :class:`_engine.Engine` or :class:`_engine.Connection`
 #o which this :class:`.Executable` is bound, or None if none found.

 #""
 #f self._bind:
 #eturn self._bind

 #or item in self._iterate_from_elements():
 #f item._is_subquery and item.element is self:
 #aise exc.InvalidRequestError(
 #select() construct refers to itself as a FROM"
 #

 # = item.bind
 #f e:
 #elf._bind = e
 #eturn e
 #lse:
 #reak

 #or c in self._raw_columns:
 # = c.bind
 #f e:
 #elf._bind = e
 #eturn e

 #bind.setter
 #ef bind(self, bind):
 #elf._bind = bind


class ScalarSelect(roles.InElementRole, Generative, Grouping):
 #""Represent a scalar subquery.


 # :class:`_sql.ScalarSelect` is created by invoking the
 #meth:`_sql.SelectBase.scalar_subquery` method.   The object
 #hen participates in other SQL expressions as a SQL column expression
 #ithin the :class:`_sql.ColumnElement` hierarchy.

 #. seealso::

 #meth:`_sql.SelectBase.scalar_subquery`

 #ref:`tutorial_scalar_subquery` - in the 2.0 tutorial

 #ref:`scalar_selects` - in the 1.x tutorial

 #""

 #from_objects = []
 #is_from_container = True
 #is_implicitly_boolean = False
 #nherit_cache = True

 #ef __init__(self, element):
 #elf.element = element
 #elf.type = element._scalar_type()

 #property
 #ef columns(self):
 #aise exc.InvalidRequestError(
 #Scalar Select expression has no "
 #columns; use this object directly "
 #within a column-level expression."
 #

 # = columns

 #_generative
 #ef where(self, crit):
 #""Apply a WHERE clause to the SELECT statement referred to
 #y this :class:`_expression.ScalarSelect`.

 #""
 #elf.element = self.element.where(crit)

 #ef self_group(self, **kwargs):
 #eturn self

 #_generative
 #ef correlate(self, *fromclauses):
 #"""Return a new :class:`_expression.ScalarSelect`
 #hich will correlate the given FROM
 #lauses to that of an enclosing :class:`_expression.Select`.

 #his method is mirrored from the :meth:`_sql.Select.correlate` method
 #f the underlying :class:`_sql.Select`.  The method applies the
 #meth:_sql.Select.correlate` method, then returns a new
 #class:`_sql.ScalarSelect` against that statement.

 #. versionadded:: 1.4 Previously, the
 #meth:`_sql.ScalarSelect.correlate`
 #ethod was only available from :class:`_sql.Select`.

 #param \*fromclauses: a list of one or more
 #class:`_expression.FromClause`
 #onstructs, or other compatible constructs (i.e. ORM-mapped
 #lasses) to become part of the correlate collection.

 #. seealso::

 #meth:`_expression.ScalarSelect.correlate_except`

 #ref:`tutorial_scalar_subquery` - in the 2.0 tutorial

 #ref:`correlated_subqueries` - in the 1.x tutorial


 #""
 #elf.element = self.element.correlate(*fromclauses)

 #_generative
 #ef correlate_except(self, *fromclauses):
 #"""Return a new :class:`_expression.ScalarSelect`
 #hich will omit the given FROM
 #lauses from the auto-correlation process.

 #his method is mirrored from the
 #meth:`_sql.Select.correlate_except` method of the underlying
 #class:`_sql.Select`.  The method applies the
 #meth:_sql.Select.correlate_except` method, then returns a new
 #class:`_sql.ScalarSelect` against that statement.

 #. versionadded:: 1.4 Previously, the
 #meth:`_sql.ScalarSelect.correlate_except`
 #ethod was only available from :class:`_sql.Select`.

 #param \*fromclauses: a list of one or more
 #class:`_expression.FromClause`
 #onstructs, or other compatible constructs (i.e. ORM-mapped
 #lasses) to become part of the correlate-exception collection.

 #. seealso::

 #meth:`_expression.ScalarSelect.correlate`

 #ref:`tutorial_scalar_subquery` - in the 2.0 tutorial

 #ref:`correlated_subqueries` - in the 1.x tutorial


 #""

 #elf.element = self.element.correlate_except(*fromclauses)


class Exists(UnaryExpression):
 #""Represent an ``EXISTS`` clause.

 #ee :func:`_sql.exists` for a description of usage.

 #""

 #from_objects = []
 #nherit_cache = True

 #ef __init__(self, *args, **kwargs):
 #""Construct a new :class:`_expression.Exists` construct.

 #he :func:`_sql.exists` can be invoked by itself to produce an
 #class:`_sql.Exists` construct, which will accept simple WHERE
 #riteria::

 #xists_criteria = exists().where(table1.c.col1 == table2.c.col2)

 #owever, for greater flexibility in constructing the SELECT, an
 #xisting :class:`_sql.Select` construct may be converted to an
 #class:`_sql.Exists`, most conveniently by making use of the
 #meth:`_sql.SelectBase.exists` method::

 #xists_criteria = (
 #elect(table2.c.col2).
 #here(table1.c.col1 == table2.c.col2).
 #xists()
 #

 #he EXISTS criteria is then used inside of an enclosing SELECT::

 #tmt = select(table1.c.col1).where(exists_criteria)

 #he above statement will then be of the form::

 #ELECT col1 FROM table1 WHERE EXISTS
 #SELECT table2.col2 FROM table2 WHERE table2.col2 = table1.col1)

 #. seealso::

 #ref:`tutorial_exists` - in the :term:`2.0 style` tutorial.

 #""  # noqa E501
 #f args and isinstance(args[0], (SelectBase, ScalarSelect)):
 # = args[0]
 #lse:
 #f not args:
 #rgs = (literal_column("*"),)
 # = Select._create(*args, **kwargs).scalar_subquery()

 #naryExpression.__init__(
 #elf,
 #,
 #perator=operators.exists,
 #ype_=type_api.BOOLEANTYPE,
 #raps_column_expression=True,
 #

 #ef _regroup(self, fn):
 #lement = self.element._ungroup()
 #lement = fn(element)
 #eturn element.self_group(against=operators.exists)

 #util.deprecated_params(
 #hereclause=(
 #2.0",
 #The :paramref:`_sql.Exists.select().whereclause` parameter "
 #is deprecated and will be removed in version 2.0.  "
 #Please make use "
 #of the :meth:`.Select.where` "
 #method to add WHERE criteria to the SELECT statement.",
 #,
 #wargs=(
 #2.0",
 #The :meth:`_sql.Exists.select` method will no longer accept "
 #keyword arguments in version 2.0.  "
 #Please use generative methods from the "
 #:class:`_sql.Select` construct in order to apply additional "
 #modifications.",
 #,
 #
 #ef select(self, whereclause=None, **kwargs):
 #"""Return a SELECT of this :class:`_expression.Exists`.

 #.g.::

 #tmt = exists(some_table.c.id).where(some_table.c.id == 5).select()

 #his will produce a statement resembling::

 #ELECT EXISTS (SELECT id FROM some_table WHERE some_table = :param) AS anon_1

 #param whereclause: a WHERE clause, equivalent to calling the
 #meth:`_sql.Select.where` method.

 #param **kwargs: additional keyword arguments are passed to the
 #egacy constructor for :class:`_sql.Select` described at
 #meth:`_sql.Select.create_legacy_select`.

 #. seealso::

 #func:`_expression.select` - general purpose
 #ethod which allows for arbitrary column lists.

 #""  # noqa

 #f whereclause is not None:
 #wargs["whereclause"] = whereclause
 #eturn Select._create_select_from_fromclause(self, [self], **kwargs)

 #ef correlate(self, *fromclause):
 #""Apply correlation to the subquery noted by this :class:`_sql.Exists`.

 #. seealso::

 #meth:`_sql.ScalarSelect.correlate`

 #""
 # = self._clone()
 #.element = self._regroup(
 #ambda element: element.correlate(*fromclause)
 #
 #eturn e

 #ef correlate_except(self, *fromclause):
 #""Apply correlation to the subquery noted by this :class:`_sql.Exists`.

 #. seealso::

 #meth:`_sql.ScalarSelect.correlate_except`

 #""

 # = self._clone()
 #.element = self._regroup(
 #ambda element: element.correlate_except(*fromclause)
 #
 #eturn e

 #ef select_from(self, *froms):
 #""Return a new :class:`_expression.Exists` construct,
 #pplying the given
 #xpression to the :meth:`_expression.Select.select_from`
 #ethod of the select
 #tatement contained.

 #. note:: it is typically preferable to build a :class:`_sql.Select`
 #tatement first, including the desired WHERE clause, then use the
 #meth:`_sql.SelectBase.exists` method to produce an
 #class:`_sql.Exists` object at once.

 #""
 # = self._clone()
 #.element = self._regroup(lambda element: element.select_from(*froms))
 #eturn e

 #ef where(self, clause):
 #""Return a new :func:`_expression.exists` construct with the
 #iven expression added to
 #ts WHERE clause, joined to the existing clause via AND, if any.


 #. note:: it is typically preferable to build a :class:`_sql.Select`
 #tatement first, including the desired WHERE clause, then use the
 #meth:`_sql.SelectBase.exists` method to produce an
 #class:`_sql.Exists` object at once.

 #""
 # = self._clone()
 #.element = self._regroup(lambda element: element.where(clause))
 #eturn e


class TextualSelect(SelectBase):
 #""Wrap a :class:`_expression.TextClause` construct within a
 #class:`_expression.SelectBase`
 #nterface.

 #his allows the :class:`_expression.TextClause` object to gain a
 #`.c`` collection
 #nd other FROM-like capabilities such as
 #meth:`_expression.FromClause.alias`,
 #meth:`_expression.SelectBase.cte`, etc.

 #he :class:`_expression.TextualSelect` construct is produced via the
 #meth:`_expression.TextClause.columns`
 #ethod - see that method for details.

 #. versionchanged:: 1.4 the :class:`_expression.TextualSelect`
 #lass was renamed
 #rom ``TextAsFrom``, to more correctly suit its role as a
 #ELECT-oriented object and not a FROM clause.

 #. seealso::

 #func:`_expression.text`

 #meth:`_expression.TextClause.columns` - primary creation interface.

 #""

 #_visit_name__ = "textual_select"

 #label_style = LABEL_STYLE_NONE

 #traverse_internals = [
 #"element", InternalTraversal.dp_clauseelement),
 #"column_args", InternalTraversal.dp_clauseelement_list),
 # + SupportsCloneAnnotations._clone_annotations_traverse_internals

 #is_textual = True

 #s_text = True
 #s_select = True

 #ef __init__(self, text, columns, positional=False):
 #elf.element = text
        # convert for ORM attributes->columns, etc
 #elf.column_args = [
 #oercions.expect(roles.ColumnsClauseRole, c) for c in columns
 #
 #elf.positional = positional

 #HasMemoized.memoized_attribute
 #ef selected_columns(self):
 #""A :class:`_expression.ColumnCollection`
 #epresenting the columns that
 #his SELECT statement or similar construct returns in its result set,
 #ot including :class:`_sql.TextClause` constructs.

 #his collection differs from the :attr:`_expression.FromClause.columns`
 #ollection of a :class:`_expression.FromClause` in that the columns
 #ithin this collection cannot be directly nested inside another SELECT
 #tatement; a subquery must be applied first which provides for the
 #ecessary parenthesization required by SQL.

 #or a :class:`_expression.TextualSelect` construct, the collection
 #ontains the :class:`_expression.ColumnElement` objects that were
 #assed to the constructor, typically via the
 #meth:`_expression.TextClause.columns` method.


 #. versionadded:: 1.4

 #""
 #eturn ColumnCollection(
 #c.key, c) for c in self.column_args
 #.as_immutable()

 #property
 #ef _all_selected_columns(self):
 #eturn self.column_args

 #ef _set_label_style(self, style):
 #eturn self

 #ef _ensure_disambiguated_names(self):
 #eturn self

 #property
 #ef _bind(self):
 #eturn self.element._bind

 #_generative
 #ef bindparams(self, *binds, **bind_as_values):
 #elf.element = self.element.bindparams(*binds, **bind_as_values)

 #ef _generate_fromclause_column_proxies(self, fromclause):
 #romclause._columns._populate_separate_keys(
 #._make_proxy(fromclause) for c in self.column_args
 #

 #ef _scalar_type(self):
 #eturn self.column_args[0].type


TextAsFrom = TextualSelect
"""Backwards compatibility with the previous name"""


class AnnotatedFromClause(Annotated):
 #ef __init__(self, element, values):
        # force FromClause to generate their internal
        # collections into __dict__
 #lement.c
 #nnotated.__init__(self, element, values)
