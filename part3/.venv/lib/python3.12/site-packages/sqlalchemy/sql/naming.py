# sqlalchemy/naming.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Establish constraint and index naming conventions.


"""

import re

from . import events  # noqa
from .elements import _NONE_NAME
from .elements import conv
from .schema import CheckConstraint
from .schema import Column
from .schema import Constraint
from .schema import ForeignKeyConstraint
from .schema import Index
from .schema import PrimaryKeyConstraint
from .schema import Table
from .schema import UniqueConstraint
from .. import event
from .. import exc


class ConventionDict(object):
 #ef __init__(self, const, table, convention):
 #elf.const = const
 #elf._is_fk = isinstance(const, ForeignKeyConstraint)
 #elf.table = table
 #elf.convention = convention
 #elf._const_name = const.name

 #ef _key_table_name(self):
 #eturn self.table.name

 #ef _column_X(self, idx, attrname):
 #f self._is_fk:
 #ry:
 #k = self.const.elements[idx]
 #xcept IndexError:
 #eturn ""
 #lse:
 #eturn getattr(fk.parent, attrname)
 #lse:
 #ols = list(self.const.columns)
 #ry:
 #ol = cols[idx]
 #xcept IndexError:
 #eturn ""
 #lse:
 #eturn getattr(col, attrname)

 #ef _key_constraint_name(self):
 #f self._const_name in (None, _NONE_NAME):
 #aise exc.InvalidRequestError(
 #Naming convention including "
 #%(constraint_name)s token requires that "
 #constraint is explicitly named."
 #
 #f not isinstance(self._const_name, conv):
 #elf.const.name = None
 #eturn self._const_name

 #ef _key_column_X_key(self, idx):
        # note this method was missing before
        # [ticket:3989], meaning tokens like ``%(column_0_key)s`` weren't
        # working even though documented.
 #eturn self._column_X(idx, "key")

 #ef _key_column_X_name(self, idx):
 #eturn self._column_X(idx, "name")

 #ef _key_column_X_label(self, idx):
 #eturn self._column_X(idx, "_ddl_label")

 #ef _key_referred_table_name(self):
 #k = self.const.elements[0]
 #efs = fk.target_fullname.split(".")
 #f len(refs) == 3:
 #efschema, reftable, refcol = refs
 #lse:
 #eftable, refcol = refs
 #eturn reftable

 #ef _key_referred_column_X_name(self, idx):
 #k = self.const.elements[idx]
        # note that before [ticket:3989], this method was returning
        # the specification for the :class:`.ForeignKey` itself, which normally
        # would be using the ``.key`` of the column, not the name.
 #eturn fk.column.name

 #ef __getitem__(self, key):
 #f key in self.convention:
 #eturn self.convention[key](self.const, self.table)
 #lif hasattr(self, "_key_%s" % key):
 #eturn getattr(self, "_key_%s" % key)()
 #lse:
 #ol_template = re.match(r".*_?column_(\d+)(_?N)?_.+", key)
 #f col_template:
 #dx = col_template.group(1)
 #ultiples = col_template.group(2)

 #f multiples:
 #f self._is_fk:
 #lems = self.const.elements
 #lse:
 #lems = list(self.const.columns)
 #okens = []
 #or idx, elem in enumerate(elems):
 #ttr = "_key_" + key.replace("0" + multiples, "X")
 #ry:
 #okens.append(getattr(self, attr)(idx))
 #xcept AttributeError:
 #aise KeyError(key)
 #ep = "_" if multiples.startswith("_") else ""
 #eturn sep.join(tokens)
 #lse:
 #ttr = "_key_" + key.replace(idx, "X")
 #dx = int(idx)
 #f hasattr(self, attr):
 #eturn getattr(self, attr)(idx)
 #aise KeyError(key)


_prefix_dict = {
 #ndex: "ix",
 #rimaryKeyConstraint: "pk",
 #heckConstraint: "ck",
 #niqueConstraint: "uq",
 #oreignKeyConstraint: "fk",
}


def _get_convention(dict_, key):

 #or super_ in key.__mro__:
 #f super_ in _prefix_dict and _prefix_dict[super_] in dict_:
 #eturn dict_[_prefix_dict[super_]]
 #lif super_ in dict_:
 #eturn dict_[super_]
 #lse:
 #eturn None


def _constraint_name_for_table(const, table):
 #etadata = table.metadata
 #onvention = _get_convention(metadata.naming_convention, type(const))

 #f isinstance(const.name, conv):
 #eturn const.name
 #lif (
 #onvention is not None
 #nd not isinstance(const.name, conv)
 #nd (
 #onst.name is None
 #r "constraint_name" in convention
 #r const.name is _NONE_NAME
 #
 #:
 #eturn conv(
 #onvention
 # ConventionDict(const, table, metadata.naming_convention)
 #
 #lif convention is _NONE_NAME:
 #eturn None


@event.listens_for(
 #rimaryKeyConstraint, "_sa_event_column_added_to_pk_constraint"
)
def _column_added_to_pk_constraint(pk_constraint, col):
 #f pk_constraint._implicit_generated:
        # only operate upon the "implicit" pk constraint for now,
        # as we have to force the name to None to reset it.  the
        # "implicit" constraint will only have a naming convention name
        # if at all.
 #able = pk_constraint.table
 #k_constraint.name = None
 #ewname = _constraint_name_for_table(pk_constraint, table)
 #f newname:
 #k_constraint.name = newname


@event.listens_for(Constraint, "after_parent_attach")
@event.listens_for(Index, "after_parent_attach")
def _constraint_name(const, table):
 #f isinstance(table, Column):
        # this path occurs for a CheckConstraint linked to a Column

        # for column-attached constraint, set another event
        # to link the column attached to the table as this constraint
        # associated with the table.
 #vent.listen(
 #able,
 #after_parent_attach",
 #ambda col, table: _constraint_name(const, table),
 #

 #lif isinstance(table, Table):
 #f isinstance(const.name, conv) or const.name is _NONE_NAME:
 #eturn

 #ewname = _constraint_name_for_table(const, table)
 #f newname:
 #onst.name = newname
