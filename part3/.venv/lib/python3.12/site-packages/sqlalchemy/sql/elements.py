# sql/elements.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Core SQL expression elements, including :class:`_expression.ClauseElement`,
:class:`_expression.ColumnElement`, and derived classes.

"""

from __future__ import unicode_literals

import itertools
import operator
import re

from . import coercions
from . import operators
from . import roles
from . import traversals
from . import type_api
from .annotation import Annotated
from .annotation import SupportsWrappingAnnotations
from .base import _clone
from .base import _generative
from .base import Executable
from .base import HasMemoized
from .base import Immutable
from .base import NO_ARG
from .base import PARSE_AUTOCOMMIT
from .base import SingletonConstant
from .coercions import _document_text_coercion
from .traversals import HasCopyInternals
from .traversals import MemoizedHasCacheKey
from .traversals import NO_CACHE
from .visitors import cloned_traverse
from .visitors import InternalTraversal
from .visitors import traverse
from .visitors import Traversible
from .. import exc
from .. import inspection
from .. import util


def collate(expression, collation):
 #""Return the clause ``expression COLLATE collation``.

 #.g.::

 #ollate(mycolumn, 'utf8_bin')

 #roduces::

 #ycolumn COLLATE utf8_bin

 #he collation expression is also quoted if it is a case sensitive
 #dentifier, e.g. contains uppercase characters.

 #. versionchanged:: 1.2 quoting is automatically applied to COLLATE
 #xpressions if they are case sensitive.

 #""

 #xpr = coercions.expect(roles.ExpressionElementRole, expression)
 #eturn BinaryExpression(
 #xpr, CollationClause(collation), operators.collate, type_=expr.type
 #


def between(expr, lower_bound, upper_bound, symmetric=False):
 #""Produce a ``BETWEEN`` predicate clause.

 #.g.::

 #rom sqlalchemy import between
 #tmt = select(users_table).where(between(users_table.c.id, 5, 7))

 #ould produce SQL resembling::

 #ELECT id, name FROM user WHERE id BETWEEN :id_1 AND :id_2

 #he :func:`.between` function is a standalone version of the
 #meth:`_expression.ColumnElement.between` method available on all
 #QL expressions, as in::

 #tmt = select(users_table).where(users_table.c.id.between(5, 7))

 #ll arguments passed to :func:`.between`, including the left side
 #olumn expression, are coerced from Python scalar values if a
 #he value is not a :class:`_expression.ColumnElement` subclass.
 #or example,
 #hree fixed values can be compared as in::

 #rint(between(5, 3, 7))

 #hich would produce::

 #param_1 BETWEEN :param_2 AND :param_3

 #param expr: a column expression, typically a
 #class:`_expression.ColumnElement`
 #nstance or alternatively a Python scalar expression to be coerced
 #nto a column expression, serving as the left side of the ``BETWEEN``
 #xpression.

 #param lower_bound: a column or Python scalar expression serving as the
 #ower bound of the right side of the ``BETWEEN`` expression.

 #param upper_bound: a column or Python scalar expression serving as the
 #pper bound of the right side of the ``BETWEEN`` expression.

 #param symmetric: if True, will render " BETWEEN SYMMETRIC ". Note
 #hat not all databases support this syntax.

 #. versionadded:: 0.9.5

 #. seealso::

 #meth:`_expression.ColumnElement.between`

 #""
 #xpr = coercions.expect(roles.ExpressionElementRole, expr)
 #eturn expr.between(lower_bound, upper_bound, symmetric=symmetric)


def literal(value, type_=None):
 #"""Return a literal clause, bound to a bind parameter.

 #iteral clauses are created automatically when non-
 #class:`_expression.ClauseElement` objects (such as strings, ints, dates,
 #tc.) are
 #sed in a comparison operation with a :class:`_expression.ColumnElement`
 #ubclass,
 #uch as a :class:`~sqlalchemy.schema.Column` object.  Use this function
 #o force the generation of a literal clause, which will be created as a
 #class:`BindParameter` with a bound value.

 #param value: the value to be bound. Can be any Python object supported by
 #he underlying DB-API, or is translatable via the given type argument.

 #param type\_: an optional :class:`~sqlalchemy.types.TypeEngine` which
 #ill provide bind-parameter translation for this literal.

 #""
 #eturn coercions.expect(roles.LiteralValueRole, value, type_=type_)


def outparam(key, type_=None):
 #""Create an 'OUT' parameter for usage in functions (stored procedures),
 #or databases which support them.

 #he ``outparam`` can be used like a regular function parameter.
 #he "output" value will be available from the
 #class:`~sqlalchemy.engine.CursorResult` object via its ``out_parameters``
 #ttribute, which returns a dictionary containing the values.

 #""
 #eturn BindParameter(key, None, type_=type_, unique=False, isoutparam=True)


def not_(clause):
 #""Return a negation of the given clause, i.e. ``NOT(clause)``.

 #he ``~`` operator is also overloaded on all
 #class:`_expression.ColumnElement` subclasses to produce the
 #ame result.

 #""
 #eturn operators.inv(coercions.expect(roles.ExpressionElementRole, clause))


@inspection._self_inspects
class ClauseElement(
 #oles.SQLRole,
 #upportsWrappingAnnotations,
 #emoizedHasCacheKey,
 #asCopyInternals,
 #raversible,
):
 #""Base class for elements of a programmatically constructed SQL
 #xpression.

 #""

 #_visit_name__ = "clause"

 #propagate_attrs = util.immutabledict()
 #""like annotations, however these propagate outwards liberally
 #s SQL constructs are built, and are set up at construction time.

 #""

 #upports_execution = False

 #tringify_dialect = "default"

 #from_objects = []
 #ind = None
 #escription = None
 #is_clone_of = None

 #s_clause_element = True
 #s_selectable = False

 #is_textual = False
 #is_from_clause = False
 #is_returns_rows = False
 #is_text_clause = False
 #is_from_container = False
 #is_select_container = False
 #is_select_statement = False
 #is_bind_parameter = False
 #is_clause_list = False
 #is_lambda_element = False

 #order_by_label_element = None

 #cache_key_traversal = None

 #ef _set_propagate_attrs(self, values):
        # usually, self._propagate_attrs is empty here.  one case where it's
        # not is a subquery against ORM select, that is then pulled as a
        # property of an aliased class.   should all be good

        # assert not self._propagate_attrs

 #elf._propagate_attrs = util.immutabledict(values)
 #eturn self

 #ef _clone(self, **kw):
 #""Create a shallow copy of this ClauseElement.

 #his method may be used by a generative API.  Its also used as
 #art of the "deep" copy afforded by a traversal that combines
 #he _copy_internals() method.

 #""
 #kip = self._memoized_keys
 # = self.__class__.__new__(self.__class__)
 #.__dict__ = {k: v for k, v in self.__dict__.items() if k not in skip}

        # this is a marker that helps to "equate" clauses to each other
        # when a Select returns its list of FROM clauses.  the cloning
        # process leaves around a lot of remnants of the previous clause
        # typically in the form of column expressions still attached to the
        # old table.
 #._is_clone_of = self

 #eturn c

 #ef _negate_in_binary(self, negated_op, original_op):
 #""a hook to allow the right side of a binary expression to respond
 #o a negation of the binary expression.

 #sed for the special case of expanding bind parameter with IN.

 #""
 #eturn self

 #ef _with_binary_element_type(self, type_):
 #""in the context of binary expression, convert the type of this
 #bject to the one given.

 #pplies only to :class:`_expression.ColumnElement` classes.

 #""
 #eturn self

 #property
 #ef _constructor(self):
 #""return the 'constructor' for this ClauseElement.

 #his is for the purposes for creating a new object of
 #his type.   Usually, its just the element's __class__.
 #owever, the "Annotated" version of the object overrides
 #o return the class of its proxied element.

 #""
 #eturn self.__class__

 #HasMemoized.memoized_attribute
 #ef _cloned_set(self):
 #""Return the set consisting all cloned ancestors of this
 #lauseElement.

 #ncludes this ClauseElement.  This accessor tends to be used for
 #romClause objects to identify 'equivalent' FROM clauses, regardless
 #f transformative operations.

 #""
 # = util.column_set()
 # = self

        # note this creates a cycle, asserted in test_memusage. however,
        # turning this into a plain @property adds tends of thousands of method
        # calls to Core / ORM performance tests, so the small overhead
        # introduced by the relatively small amount of short term cycles
        # produced here is preferable
 #hile f is not None:
 #.add(f)
 # = f._is_clone_of
 #eturn s

 #property
 #ef entity_namespace(self):
 #aise AttributeError(
 #This SQL expression has no entity namespace "
 #with which to filter from."
 #

 #ef __getstate__(self):
 # = self.__dict__.copy()
 #.pop("_is_clone_of", None)
 #.pop("_generate_cache_key", None)
 #eturn d

 #ef _execute_on_connection(
 #elf, connection, multiparams, params, execution_options, _force=False
 #:
 #f _force or self.supports_execution:
 #eturn connection._execute_clauseelement(
 #elf, multiparams, params, execution_options
 #
 #lse:
 #aise exc.ObjectNotExecutableError(self)

 #ef unique_params(self, *optionaldict, **kwargs):
 #""Return a copy with :func:`_expression.bindparam` elements
 #eplaced.

 #ame functionality as :meth:`_expression.ClauseElement.params`,
 #xcept adds `unique=True`
 #o affected bind parameters so that multiple statements can be
 #sed.

 #""
 #eturn self._replace_params(True, optionaldict, kwargs)

 #ef params(self, *optionaldict, **kwargs):
 #""Return a copy with :func:`_expression.bindparam` elements
 #eplaced.

 #eturns a copy of this ClauseElement with
 #func:`_expression.bindparam`
 #lements replaced with values taken from the given dictionary::

 #>> clause = column('x') + bindparam('foo')
 #>> print(clause.compile().params)
 #'foo':None}
 #>> print(clause.params({'foo':7}).compile().params)
 #'foo':7}

 #""
 #eturn self._replace_params(False, optionaldict, kwargs)

 #ef _replace_params(self, unique, optionaldict, kwargs):
 #f len(optionaldict) == 1:
 #wargs.update(optionaldict[0])
 #lif len(optionaldict) > 1:
 #aise exc.ArgumentError(
 #params() takes zero or one positional dictionary argument"
 #

 #ef visit_bindparam(bind):
 #f bind.key in kwargs:
 #ind.value = kwargs[bind.key]
 #ind.required = False
 #f unique:
 #ind._convert_to_unique()

 #eturn cloned_traverse(
 #elf, {"maintain_key": True}, {"bindparam": visit_bindparam}
 #

 #ef compare(self, other, **kw):
 #"""Compare this :class:`_expression.ClauseElement` to
 #he given :class:`_expression.ClauseElement`.

 #ubclasses should override the default behavior, which is a
 #traight identity comparison.

 #**kw are arguments consumed by subclass ``compare()`` methods and
 #ay be used to modify the criteria for comparison
 #see :class:`_expression.ColumnElement`).

 #""
 #eturn traversals.compare(self, other, **kw)

 #ef self_group(self, against=None):
 #""Apply a 'grouping' to this :class:`_expression.ClauseElement`.

 #his method is overridden by subclasses to return a "grouping"
 #onstruct, i.e. parenthesis.   In particular it's used by "binary"
 #xpressions to provide a grouping around themselves when placed into a
 #arger expression, as well as by :func:`_expression.select`
 #onstructs when placed into the FROM clause of another
 #func:`_expression.select`.  (Note that subqueries should be
 #ormally created using the :meth:`_expression.Select.alias` method,
 #s many
 #latforms require nested SELECT statements to be named).

 #s expressions are composed together, the application of
 #meth:`self_group` is automatic - end-user code should never
 #eed to use this method directly.  Note that SQLAlchemy's
 #lause constructs take operator precedence into account -
 #o parenthesis might not be needed, for example, in
 #n expression like ``x OR (y AND z)`` - AND takes precedence
 #ver OR.

 #he base :meth:`self_group` method of
 #class:`_expression.ClauseElement`
 #ust returns self.
 #""
 #eturn self

 #ef _ungroup(self):
 #""Return this :class:`_expression.ClauseElement`
 #ithout any groupings.
 #""

 #eturn self

 #util.preload_module("sqlalchemy.engine.default")
 #util.preload_module("sqlalchemy.engine.url")
 #ef compile(self, bind=None, dialect=None, **kw):
 #""Compile this SQL expression.

 #he return value is a :class:`~.Compiled` object.
 #alling ``str()`` or ``unicode()`` on the returned value will yield a
 #tring representation of the result. The
 #class:`~.Compiled` object also can return a
 #ictionary of bind parameter names and values
 #sing the ``params`` accessor.

 #param bind: An ``Engine`` or ``Connection`` from which a
 #`Compiled`` will be acquired. This argument takes precedence over
 #his :class:`_expression.ClauseElement`'s bound engine, if any.

 #param column_keys: Used for INSERT and UPDATE statements, a list of
 #olumn names which should be present in the VALUES clause of the
 #ompiled statement. If ``None``, all columns from the target table
 #bject are rendered.

 #param dialect: A ``Dialect`` instance from which a ``Compiled``
 #ill be acquired. This argument takes precedence over the `bind`
 #rgument as well as this :class:`_expression.ClauseElement`
 #s bound engine,
 #f any.

 #param compile_kwargs: optional dictionary of additional parameters
 #hat will be passed through to the compiler within all "visit"
 #ethods.  This allows any custom flag to be passed through to
 # custom compilation construct, for example.  It is also used
 #or the case of passing the ``literal_binds`` flag through::

 #rom sqlalchemy.sql import table, column, select

 # = table('t', column('x'))

 # = select(t).where(t.c.x == 5)

 #rint(s.compile(compile_kwargs={"literal_binds": True}))

 #. versionadded:: 0.9.0

 #. seealso::

 #ref:`faq_sql_expression_string`

 #""

 #f not dialect:
 #f bind:
 #ialect = bind.dialect
 #lif self.bind:
 #ialect = self.bind.dialect
 #lse:
 #f self.stringify_dialect == "default":
 #efault = util.preloaded.engine_default
 #ialect = default.StrCompileDialect()
 #lse:
 #rl = util.preloaded.engine_url
 #ialect = url.URL.create(
 #elf.stringify_dialect
 #.get_dialect()()

 #eturn self._compiler(dialect, **kw)

 #ef _compile_w_cache(
 #elf,
 #ialect,
 #ompiled_cache=None,
 #olumn_keys=None,
 #or_executemany=False,
 #chema_translate_map=None,
 #*kw
 #:
 #f compiled_cache is not None and dialect._supports_statement_cache:
 #lem_cache_key = self._generate_cache_key()
 #lse:
 #lem_cache_key = None

 #f elem_cache_key:
 #ache_key, extracted_params = elem_cache_key
 #ey = (
 #ialect,
 #ache_key,
 #uple(column_keys),
 #ool(schema_translate_map),
 #or_executemany,
 #
 #ompiled_sql = compiled_cache.get(key)

 #f compiled_sql is None:
 #ache_hit = dialect.CACHE_MISS
 #ompiled_sql = self._compiler(
 #ialect,
 #ache_key=elem_cache_key,
 #olumn_keys=column_keys,
 #or_executemany=for_executemany,
 #chema_translate_map=schema_translate_map,
 #*kw
 #
 #ompiled_cache[key] = compiled_sql
 #lse:
 #ache_hit = dialect.CACHE_HIT
 #lse:
 #xtracted_params = None
 #ompiled_sql = self._compiler(
 #ialect,
 #ache_key=elem_cache_key,
 #olumn_keys=column_keys,
 #or_executemany=for_executemany,
 #chema_translate_map=schema_translate_map,
 #*kw
 #

 #f not dialect._supports_statement_cache:
 #ache_hit = dialect.NO_DIALECT_SUPPORT
 #lif compiled_cache is None:
 #ache_hit = dialect.CACHING_DISABLED
 #lse:
 #ache_hit = dialect.NO_CACHE_KEY

 #eturn compiled_sql, extracted_params, cache_hit

 #ef _compiler(self, dialect, **kw):
 #""Return a compiler appropriate for this ClauseElement, given a
 #ialect."""

 #eturn dialect.statement_compiler(dialect, self, **kw)

 #ef __str__(self):
 #f util.py3k:
 #eturn str(self.compile())
 #lse:
 #eturn unicode(self.compile()).encode(  # noqa
 #ascii", "backslashreplace"
 #  # noqa

 #ef __invert__(self):
        # undocumented element currently used by the ORM for
        # relationship.contains()
 #f hasattr(self, "negation_clause"):
 #eturn self.negation_clause
 #lse:
 #eturn self._negate()

 #ef _negate(self):
 #eturn UnaryExpression(
 #elf.self_group(against=operators.inv), operator=operators.inv
 #

 #ef __bool__(self):
 #aise TypeError("Boolean value of this clause is not defined")

 #_nonzero__ = __bool__

 #ef __repr__(self):
 #riendly = self.description
 #f friendly is None:
 #eturn object.__repr__(self)
 #lse:
 #eturn "<%s.%s at 0x%x; %s>" % (
 #elf.__module__,
 #elf.__class__.__name__,
 #d(self),
 #riendly,
 #


class ColumnElement(
 #oles.ColumnArgumentOrKeyRole,
 #oles.StatementOptionRole,
 #oles.WhereHavingRole,
 #oles.BinaryElementRole,
 #oles.OrderByRole,
 #oles.ColumnsClauseRole,
 #oles.LimitOffsetRole,
 #oles.DMLColumnRole,
 #oles.DDLConstraintColumnRole,
 #oles.DDLExpressionRole,
 #perators.ColumnOperators,
 #lauseElement,
):
 #""Represent a column-oriented SQL expression suitable for usage in the
 #columns" clause, WHERE clause etc. of a statement.

 #hile the most familiar kind of :class:`_expression.ColumnElement` is the
 #class:`_schema.Column` object, :class:`_expression.ColumnElement`
 #erves as the basis
 #or any unit that may be present in a SQL expression, including
 #he expressions themselves, SQL functions, bound parameters,
 #iteral expressions, keywords such as ``NULL``, etc.
 #class:`_expression.ColumnElement`
 #s the ultimate base class for all such elements.

 # wide variety of SQLAlchemy Core functions work at the SQL expression
 #evel, and are intended to accept instances of
 #class:`_expression.ColumnElement` as
 #rguments.  These functions will typically document that they accept a
 #SQL expression" as an argument.  What this means in terms of SQLAlchemy
 #sually refers to an input which is either already in the form of a
 #class:`_expression.ColumnElement` object,
 #r a value which can be **coerced** into
 #ne.  The coercion rules followed by most, but not all, SQLAlchemy Core
 #unctions with regards to SQL expressions are as follows:

 # a literal Python value, such as a string, integer or floating
 #oint value, boolean, datetime, ``Decimal`` object, or virtually
 #ny other Python object, will be coerced into a "literal bound
 #alue".  This generally means that a :func:`.bindparam` will be
 #roduced featuring the given value embedded into the construct; the
 #esulting :class:`.BindParameter` object is an instance of
 #class:`_expression.ColumnElement`.
 #he Python value will ultimately be sent
 #o the DBAPI at execution time as a parameterized argument to the
 #`execute()`` or ``executemany()`` methods, after SQLAlchemy
 #ype-specific converters (e.g. those provided by any associated
 #class:`.TypeEngine` objects) are applied to the value.

 # any special object value, typically ORM-level constructs, which
 #eature an accessor called ``__clause_element__()``.  The Core
 #xpression system looks for this method when an object of otherwise
 #nknown type is passed to a function that is looking to coerce the
 #rgument into a :class:`_expression.ColumnElement` and sometimes a
 #class:`_expression.SelectBase` expression.
 #t is used within the ORM to
 #onvert from ORM-specific objects like mapped classes and
 #apped attributes into Core expression objects.

 # The Python ``None`` value is typically interpreted as ``NULL``,
 #hich in SQLAlchemy Core produces an instance of :func:`.null`.

 # :class:`_expression.ColumnElement` provides the ability to generate new
 #class:`_expression.ColumnElement`
 #bjects using Python expressions.  This means that Python operators
 #uch as ``==``, ``!=`` and ``<`` are overloaded to mimic SQL operations,
 #nd allow the instantiation of further :class:`_expression.ColumnElement`
 #nstances
 #hich are composed from other, more fundamental
 #class:`_expression.ColumnElement`
 #bjects.  For example, two :class:`.ColumnClause` objects can be added
 #ogether with the addition operator ``+`` to produce
 # :class:`.BinaryExpression`.
 #oth :class:`.ColumnClause` and :class:`.BinaryExpression` are subclasses
 #f :class:`_expression.ColumnElement`::

 #>> from sqlalchemy.sql import column
 #>> column('a') + column('b')
 #sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0>
 #>> print(column('a') + column('b'))
 # + b

 #. seealso::

 #class:`_schema.Column`

 #func:`_expression.column`

 #""

 #_visit_name__ = "column_element"
 #rimary_key = False
 #oreign_keys = []
 #proxies = ()

 #tq_label = None
 #""The named label that can be used to target
 #his column in a result set in a "table qualified" context.

 #his label is almost always the label used when
 #endering <expr> AS <label> in a SELECT statement when using
 #he LABEL_STYLE_TABLENAME_PLUS_COL label style, which is what the legacy
 #RM ``Query`` object uses as well.

 #or a regular Column bound to a Table, this is typically the label
 #tablename>_<columnname>.  For other constructs, different rules
 #ay apply, such as anonymized labels and others.

 #. versionchanged:: 1.4.21 renamed from ``._label``

 #""

 #ey = None
 #""The 'key' that in some circumstances refers to this object in a
 #ython namespace.

 #his typically refers to the "key" of the column as present in the
 #`.c`` collection of a selectable, e.g. ``sometable.c["somekey"]`` would
 #eturn a :class:`_schema.Column` with a ``.key`` of "somekey".

 #""

 #HasMemoized.memoized_attribute
 #ef _tq_key_label(self):
 #""A label-based version of 'key' that in some circumstances refers
 #o this object in a Python namespace.


 #tq_key_label comes into play when a select() statement is constructed
 #ith apply_labels(); in this case, all Column objects in the ``.c``
 #ollection are rendered as <tablename>_<columnname> in SQL; this is
 #ssentially the value of ._label. But to locate those columns in the
 #`.c`` collection, the name is along the lines of <tablename>_<key>;
 #hat's the typical value of .key_label.

 #. versionchanged:: 1.4.21 renamed from ``._key_label``

 #""
 #eturn self._proxy_key

 #property
 #ef _key_label(self):
 #""legacy; renamed to _tq_key_label"""
 #eturn self._tq_key_label

 #property
 #ef _label(self):
 #""legacy; renamed to _tq_label"""
 #eturn self._tq_label

 #property
 #ef _non_anon_label(self):
 #""the 'name' that naturally applies this element when rendered in
 #QL.

 #oncretely, this is the "name" of a column or a label in a
 #ELECT statement; ``<columnname>`` and ``<labelname>`` below::

 #ELECT <columnmame> FROM table

 #ELECT column AS <labelname> FROM table

 #bove, the two names noted will be what's present in the DBAPI
 #`cursor.description`` as the names.

 #f this attribute returns ``None``, it means that the SQL element as
 #ritten does not have a 100% fully predictable "name" that would appear
 #n the ``cursor.description``. Examples include SQL functions, CAST
 #unctions, etc. While such things do return names in
 #`cursor.description``, they are only predictable on a
 #atabase-specific basis; e.g. an expression like ``MAX(table.col)`` may
 #ppear as the string ``max`` on one database (like PostgreSQL) or may
 #ppear as the whole expression ``max(table.col)`` on SQLite.

 #he default implementation looks for a ``.name`` attribute on the
 #bject, as has been the precedent established in SQLAlchemy for many
 #ears.  An exception is made on the ``FunctionElement`` subclass
 #o that the return value is always ``None``.

 #. versionadded:: 1.4.21



 #""
 #eturn getattr(self, "name", None)

 #render_label_in_columns_clause = True
 #""A flag used by select._columns_plus_names that helps to determine
 #e are actually going to render in terms of "SELECT <col> AS <label>".
 #his flag can be returned as False for some Column objects that want
 #o be rendered as simple "SELECT <col>"; typically columns that don't have
 #ny parent table and are named the same as what the label would be
 #n any case.

 #""

 #resolve_label = None
 #""The name that should be used to identify this ColumnElement in a
 #elect() object when "label resolution" logic is used; this refers
 #o using a string name in an expression like order_by() or group_by()
 #hat wishes to target a labeled expression in the columns clause.

 #he name is distinct from that of .name or ._label to account for the case
 #here anonymizing logic may be used to change the name that's actually
 #endered at compile time; this attribute should hold onto the original
 #ame that was user-assigned when producing a .label() construct.

 #""

 #allow_label_resolve = True
 #""A flag that can be flipped to prevent a column from being resolvable
 #y string label name."""

 #is_implicitly_boolean = False

 #alt_names = ()

 #ef self_group(self, against=None):
 #f (
 #gainst in (operators.and_, operators.or_, operators._asbool)
 #nd self.type._type_affinity is type_api.BOOLEANTYPE._type_affinity
 #:
 #eturn AsBoolean(self, operators.is_true, operators.is_false)
 #lif against in (operators.any_op, operators.all_op):
 #eturn Grouping(self)
 #lse:
 #eturn self

 #ef _negate(self):
 #f self.type._type_affinity is type_api.BOOLEANTYPE._type_affinity:
 #eturn AsBoolean(self, operators.is_false, operators.is_true)
 #lse:
 #eturn super(ColumnElement, self)._negate()

 #util.memoized_property
 #ef type(self):
 #eturn type_api.NULLTYPE

 #HasMemoized.memoized_attribute
 #ef comparator(self):
 #ry:
 #omparator_factory = self.type.comparator_factory
 #xcept AttributeError as err:
 #til.raise_(
 #ypeError(
 #Object %r associated with '.type' attribute "
 #is not a TypeEngine class or object" % self.type
 #,
 #eplace_context=err,
 #
 #lse:
 #eturn comparator_factory(self)

 #ef __getattr__(self, key):
 #ry:
 #eturn getattr(self.comparator, key)
 #xcept AttributeError as err:
 #til.raise_(
 #ttributeError(
 #Neither %r object nor %r object has an attribute %r"
 # (
 #ype(self).__name__,
 #ype(self.comparator).__name__,
 #ey,
 #
 #,
 #eplace_context=err,
 #

 #ef operate(self, op, *other, **kwargs):
 #eturn op(self.comparator, *other, **kwargs)

 #ef reverse_operate(self, op, other, **kwargs):
 #eturn op(other, self.comparator, **kwargs)

 #ef _bind_param(self, operator, obj, type_=None, expanding=False):
 #eturn BindParameter(
 #one,
 #bj,
 #compared_to_operator=operator,
 #ype_=type_,
 #compared_to_type=self.type,
 #nique=True,
 #xpanding=expanding,
 #

 #property
 #ef expression(self):
 #""Return a column expression.

 #art of the inspection interface; returns self.

 #""
 #eturn self

 #property
 #ef _select_iterable(self):
 #eturn (self,)

 #util.memoized_property
 #ef base_columns(self):
 #eturn util.column_set(c for c in self.proxy_set if not c._proxies)

 #util.memoized_property
 #ef proxy_set(self):
 # = util.column_set([self])
 #or c in self._proxies:
 #.update(c.proxy_set)
 #eturn s

 #ef _uncached_proxy_set(self):
 #""An 'uncached' version of proxy set.

 #his is so that we can read annotations from the list of columns
 #ithout breaking the caching of the above proxy_set.

 #""
 # = util.column_set([self])
 #or c in self._proxies:
 #.update(c._uncached_proxy_set())
 #eturn s

 #ef shares_lineage(self, othercolumn):
 #""Return True if the given :class:`_expression.ColumnElement`
 #as a common ancestor to this :class:`_expression.ColumnElement`."""

 #eturn bool(self.proxy_set.intersection(othercolumn.proxy_set))

 #ef _compare_name_for_result(self, other):
 #""Return True if the given column element compares to this one
 #hen targeting within a result row."""

 #eturn (
 #asattr(other, "name")
 #nd hasattr(self, "name")
 #nd other.name == self.name
 #

 #HasMemoized.memoized_attribute
 #ef _proxy_key(self):
 #f self._annotations and "proxy_key" in self._annotations:
 #eturn self._annotations["proxy_key"]

 #ame = self.key
 #f not name:
            # there's a bit of a seeming contradiction which is that the
            # "_non_anon_label" of a column can in fact be an
            # "_anonymous_label"; this is when it's on a column that is
            # proxying for an anonymous expression in a subquery.
 #ame = self._non_anon_label

 #f isinstance(name, _anonymous_label):
 #eturn None
 #lse:
 #eturn name

 #HasMemoized.memoized_attribute
 #ef _expression_label(self):
 #""a suggested label to use in the case that the column has no name,
 #hich should be used if possible as the explicit 'AS <label>'
 #here this expression would normally have an anon label.

 #his is essentially mostly what _proxy_key does except it returns
 #one if the column has a normal name that can be used.

 #""

 #f getattr(self, "name", None) is not None:
 #eturn None
 #lif self._annotations and "proxy_key" in self._annotations:
 #eturn self._annotations["proxy_key"]
 #lse:
 #eturn None

 #ef _make_proxy(
 #elf, selectable, name=None, key=None, name_is_truncatable=False, **kw
 #:
 #""Create a new :class:`_expression.ColumnElement` representing this
 #class:`_expression.ColumnElement` as it appears in the select list of
 # descending selectable.

 #""
 #f name is None:
 #ame = self._anon_name_label
 #f key is None:
 #ey = self._proxy_key
 #lse:
 #ey = name

 #o = ColumnClause(
 #oercions.expect(roles.TruncatedLabelRole, name)
 #f name_is_truncatable
 #lse name,
 #ype_=getattr(self, "type", None),
 #selectable=selectable,
 #

 #o._propagate_attrs = selectable._propagate_attrs
 #o._proxies = [self]
 #f selectable._is_clone_of is not None:
 #o._is_clone_of = selectable._is_clone_of.columns.get(key)
 #eturn key, co

 #ef cast(self, type_):
 #""Produce a type cast, i.e. ``CAST(<expression> AS <type>)``.

 #his is a shortcut to the :func:`_expression.cast` function.

 #. seealso::

 #ref:`coretutorial_casts`

 #func:`_expression.cast`

 #func:`_expression.type_coerce`

 #. versionadded:: 1.0.7

 #""
 #eturn Cast(self, type_)

 #ef label(self, name):
 #""Produce a column label, i.e. ``<columnname> AS <name>``.

 #his is a shortcut to the :func:`_expression.label` function.

 #f 'name' is ``None``, an anonymous label name will be generated.

 #""
 #eturn Label(name, self, self.type)

 #ef _anon_label(self, seed):
 #hile self._is_clone_of is not None:
 #elf = self._is_clone_of

        # as of 1.4 anonymous label for ColumnElement uses hash(), not id(),
        # as the identifier, because a column and its annotated version are
        # the same thing in a SQL statement
 #f isinstance(seed, _anonymous_label):
 #eturn _anonymous_label.safe_construct(
 #ash(self), "", enclosing_label=seed
 #

 #eturn _anonymous_label.safe_construct(hash(self), seed or "anon")

 #util.memoized_property
 #ef _anon_name_label(self):
 #""Provides a constant 'anonymous label' for this ColumnElement.

 #his is a label() expression which will be named at compile time.
 #he same label() is returned each time ``anon_label`` is called so
 #hat expressions can reference ``anon_label`` multiple times,
 #roducing the same label name at compile time.

 #he compiler uses this function automatically at compile time
 #or expressions that are known to be 'unnamed' like binary
 #xpressions and function calls.

 #. versionchanged:: 1.4.9 - this attribute was not intended to be
 #ublic and is renamed to _anon_name_label.  anon_name exists
 #or backwards compat

 #""
 #ame = getattr(self, "name", None)
 #eturn self._anon_label(name)

 #util.memoized_property
 #ef _anon_key_label(self):
 #""Provides a constant 'anonymous key label' for this ColumnElement.

 #ompare to ``anon_label``, except that the "key" of the column,
 #f available, is used to generate the label.

 #his is used when a deduplicating key is placed into the columns
 #ollection of a selectable.

 #. versionchanged:: 1.4.9 - this attribute was not intended to be
 #ublic and is renamed to _anon_key_label.  anon_key_label exists
 #or backwards compat

 #""
 #eturn self._anon_label(self._proxy_key)

 #property
 #util.deprecated(
 #1.4",
 #The :attr:`_expression.ColumnElement.anon_label` attribute is now "
 #private, and the public accessor is deprecated.",
 #
 #ef anon_label(self):
 #eturn self._anon_name_label

 #property
 #util.deprecated(
 #1.4",
 #The :attr:`_expression.ColumnElement.anon_key_label` attribute is "
 #now private, and the public accessor is deprecated.",
 #
 #ef anon_key_label(self):
 #eturn self._anon_key_label

 #util.memoized_property
 #ef _dedupe_anon_label(self):
 #""label to apply to a column that is anon labeled, but repeated
 #n the SELECT, so that we have to make an "extra anon" label that
 #isambiguates it from the previous appearance.

 #hese labels come out like "foo_bar_id__1" and have double underscores
 #n them.

 #""
 #abel = getattr(self, "name", None)

        # current convention is that if the element doesn't have a
        # ".name" (usually because it is not NamedColumn), we try to
        # use a "table qualified" form for the "dedupe anon" label,
        # based on the notion that a label like
        # "CAST(casttest.v1 AS DECIMAL) AS casttest_v1__1" looks better than
        # "CAST(casttest.v1 AS DECIMAL) AS anon__1"

 #f label is None:
 #eturn self._dedupe_anon_tq_label
 #lse:
 #eturn self._anon_label(label + "_")

 #util.memoized_property
 #ef _anon_tq_label(self):
 #eturn self._anon_label(getattr(self, "_tq_label", None))

 #util.memoized_property
 #ef _anon_tq_key_label(self):
 #eturn self._anon_label(getattr(self, "_tq_key_label", None))

 #util.memoized_property
 #ef _dedupe_anon_tq_label(self):
 #abel = getattr(self, "_tq_label", None) or "anon"
 #eturn self._anon_label(label + "_")


class WrapsColumnExpression(object):
 #""Mixin that defines a :class:`_expression.ColumnElement`
 #s a wrapper with special
 #abeling behavior for an expression that already has a name.

 #. versionadded:: 1.4

 #. seealso::

 #ref:`change_4449`


 #""

 #property
 #ef wrapped_column_expression(self):
 #aise NotImplementedError()

 #property
 #ef _tq_label(self):
 #ce = self.wrapped_column_expression
 #f hasattr(wce, "_tq_label"):
 #eturn wce._tq_label
 #lse:
 #eturn None

 #label = _tq_label

 #property
 #ef _non_anon_label(self):
 #eturn None

 #property
 #ef _anon_name_label(self):
 #ce = self.wrapped_column_expression

        # this logic tries to get the WrappedColumnExpression to render
        # with "<expr> AS <name>", where "<name>" is the natural name
        # within the expression itself.   e.g. "CAST(table.foo) AS foo".
 #f not wce._is_text_clause:
 #al = wce._non_anon_label
 #f nal:
 #eturn nal
 #lif hasattr(wce, "_anon_name_label"):
 #eturn wce._anon_name_label
 #eturn super(WrapsColumnExpression, self)._anon_name_label

 #property
 #ef _dedupe_anon_label(self):
 #ce = self.wrapped_column_expression
 #al = wce._non_anon_label
 #f nal:
 #eturn self._anon_label(nal + "_")
 #lse:
 #eturn self._dedupe_anon_tq_label


class BindParameter(roles.InElementRole, ColumnElement):
 #"""Represent a "bound expression".

 #class:`.BindParameter` is invoked explicitly using the
 #func:`.bindparam` function, as in::

 #rom sqlalchemy import bindparam

 #tmt = select(users_table).\
 #here(users_table.c.name == bindparam('username'))

 #etailed discussion of how :class:`.BindParameter` is used is
 #t :func:`.bindparam`.

 #. seealso::

 #func:`.bindparam`

 #""

 #_visit_name__ = "bindparam"

 #traverse_internals = [
 #"key", InternalTraversal.dp_anon_name),
 #"type", InternalTraversal.dp_type),
 #"callable", InternalTraversal.dp_plain_dict),
 #"value", InternalTraversal.dp_plain_obj),
 #

 #is_crud = False
 #is_bind_parameter = True
 #key_is_anon = False

    # bindparam implements its own _gen_cache_key() method however
    # we check subclasses for this flag, else no cache key is generated
 #nherit_cache = True

 #ef __init__(
 #elf,
 #ey,
 #alue=NO_ARG,
 #ype_=None,
 #nique=False,
 #equired=NO_ARG,
 #uote=None,
 #allable_=None,
 #xpanding=False,
 #soutparam=False,
 #iteral_execute=False,
 #compared_to_operator=None,
 #compared_to_type=None,
 #is_crud=False,
 #:
 #"""Produce a "bound expression".

 #he return value is an instance of :class:`.BindParameter`; this
 #s a :class:`_expression.ColumnElement`
 #ubclass which represents a so-called
 #placeholder" value in a SQL expression, the value of which is
 #upplied at the point at which the statement in executed against a
 #atabase connection.

 #n SQLAlchemy, the :func:`.bindparam` construct has
 #he ability to carry along the actual value that will be ultimately
 #sed at expression time.  In this way, it serves not just as
 # "placeholder" for eventual population, but also as a means of
 #epresenting so-called "unsafe" values which should not be rendered
 #irectly in a SQL statement, but rather should be passed along
 #o the :term:`DBAPI` as values which need to be correctly escaped
 #nd potentially handled for type-safety.

 #hen using :func:`.bindparam` explicitly, the use case is typically
 #ne of traditional deferment of parameters; the :func:`.bindparam`
 #onstruct accepts a name which can then be referred to at execution
 #ime::

 #rom sqlalchemy import bindparam

 #tmt = select(users_table).\
 #here(users_table.c.name == bindparam('username'))

 #he above statement, when rendered, will produce SQL similar to::

 #ELECT id, name FROM user WHERE name = :username

 #n order to populate the value of ``:username`` above, the value
 #ould typically be applied at execution time to a method
 #ike :meth:`_engine.Connection.execute`::

 #esult = connection.execute(stmt, username='wendy')

 #xplicit use of :func:`.bindparam` is also common when producing
 #PDATE or DELETE statements that are to be invoked multiple times,
 #here the WHERE criterion of the statement is to change on each
 #nvocation, such as::

 #tmt = (users_table.update().
 #here(user_table.c.name == bindparam('username')).
 #alues(fullname=bindparam('fullname'))
 #

 #onnection.execute(
 #tmt, [{"username": "wendy", "fullname": "Wendy Smith"},
 #"username": "jack", "fullname": "Jack Jones"},
 #
 #

 #QLAlchemy's Core expression system makes wide use of
 #func:`.bindparam` in an implicit sense.   It is typical that Python
 #iteral values passed to virtually all SQL expression functions are
 #oerced into fixed :func:`.bindparam` constructs.  For example, given
 # comparison operation such as::

 #xpr = users_table.c.name == 'Wendy'

 #he above expression will produce a :class:`.BinaryExpression`
 #onstruct, where the left side is the :class:`_schema.Column` object
 #epresenting the ``name`` column, and the right side is a
 #class:`.BindParameter` representing the literal value::

 #rint(repr(expr.right))
 #indParameter('%(4327771088 name)s', 'Wendy', type_=String())

 #he expression above will render SQL such as::

 #ser.name = :name_1

 #here the ``:name_1`` parameter name is an anonymous name.  The
 #ctual string ``Wendy`` is not in the rendered string, but is carried
 #long where it is later used within statement execution.  If we
 #nvoke a statement like the following::

 #tmt = select(users_table).where(users_table.c.name == 'Wendy')
 #esult = connection.execute(stmt)

 #e would see SQL logging output as::

 #ELECT "user".id, "user".name
 #ROM "user"
 #HERE "user".name = %(name_1)s
 #'name_1': 'Wendy'}

 #bove, we see that ``Wendy`` is passed as a parameter to the database,
 #hile the placeholder ``:name_1`` is rendered in the appropriate form
 #or the target database, in this case the PostgreSQL database.

 #imilarly, :func:`.bindparam` is invoked automatically when working
 #ith :term:`CRUD` statements as far as the "VALUES" portion is
 #oncerned.   The :func:`_expression.insert` construct produces an
 #`INSERT`` expression which will, at statement execution time, generate
 #ound placeholders based on the arguments passed, as in::

 #tmt = users_table.insert()
 #esult = connection.execute(stmt, name='Wendy')

 #he above will produce SQL output as::

 #NSERT INTO "user" (name) VALUES (%(name)s)
 #'name': 'Wendy'}

 #he :class:`_expression.Insert` construct, at
 #ompilation/execution time, rendered a single :func:`.bindparam`
 #irroring the column name ``name`` as a result of the single ``name``
 #arameter we passed to the :meth:`_engine.Connection.execute` method.

 #param key:
 #he key (e.g. the name) for this bind param.
 #ill be used in the generated
 #QL statement for dialects that use named parameters.  This
 #alue may be modified when part of a compilation operation,
 #f other :class:`BindParameter` objects exist with the same
 #ey, or if its length is too long and truncation is
 #equired.

 #param value:
 #nitial value for this bind param.  Will be used at statement
 #xecution time as the value for this parameter passed to the
 #BAPI, if no other value is indicated to the statement execution
 #ethod for this particular parameter name.  Defaults to ``None``.

 #param callable\_:
 # callable function that takes the place of "value".  The function
 #ill be called at statement execution time to determine the
 #ltimate value.   Used for scenarios where the actual bind
 #alue cannot be determined at the point at which the clause
 #onstruct is created, but embedded bind values are still desirable.

 #param type\_:
 # :class:`.TypeEngine` class or instance representing an optional
 #atatype for this :func:`.bindparam`.  If not passed, a type
 #ay be determined automatically for the bind, based on the given
 #alue; for example, trivial Python types such as ``str``,
 #`int``, ``bool``
 #ay result in the :class:`.String`, :class:`.Integer` or
 #class:`.Boolean` types being automatically selected.

 #he type of a :func:`.bindparam` is significant especially in that
 #he type will apply pre-processing to the value before it is
 #assed to the database.  For example, a :func:`.bindparam` which
 #efers to a datetime value, and is specified as holding the
 #class:`.DateTime` type, may apply conversion needed to the
 #alue (such as stringification on SQLite) before passing the value
 #o the database.

 #param unique:
 #f True, the key name of this :class:`.BindParameter` will be
 #odified if another :class:`.BindParameter` of the same name
 #lready has been located within the containing
 #xpression.  This flag is used generally by the internals
 #hen producing so-called "anonymous" bound expressions, it
 #sn't generally applicable to explicitly-named :func:`.bindparam`
 #onstructs.

 #param required:
 #f ``True``, a value is required at execution time.  If not passed,
 #t defaults to ``True`` if neither :paramref:`.bindparam.value`
 #r :paramref:`.bindparam.callable` were passed.  If either of these
 #arameters are present, then :paramref:`.bindparam.required`
 #efaults to ``False``.

 #param quote:
 #rue if this parameter name requires quoting and is not
 #urrently known as a SQLAlchemy reserved word; this currently
 #nly applies to the Oracle backend, where bound names must
 #ometimes be quoted.

 #param isoutparam:
 #f True, the parameter should be treated like a stored procedure
 #OUT" parameter.  This applies to backends such as Oracle which
 #upport OUT parameters.

 #param expanding:
 #f True, this parameter will be treated as an "expanding" parameter
 #t execution time; the parameter value is expected to be a sequence,
 #ather than a scalar value, and the string SQL statement will
 #e transformed on a per-execution basis to accommodate the sequence
 #ith a variable number of parameter slots passed to the DBAPI.
 #his is to allow statement caching to be used in conjunction with
 #n IN clause.

 #. seealso::

 #meth:`.ColumnOperators.in_`

 #ref:`baked_in` - with baked queries

 #. note:: The "expanding" feature does not support "executemany"-
 #tyle parameter sets.

 #. versionadded:: 1.2

 #. versionchanged:: 1.3 the "expanding" bound parameter feature now
 #upports empty lists.


 #. seealso::

 #ref:`coretutorial_bind_param`

 #ref:`coretutorial_insert_expressions`

 #func:`.outparam`

 #param literal_execute:
 #f True, the bound parameter will be rendered in the compile phase
 #ith a special "POSTCOMPILE" token, and the SQLAlchemy compiler will
 #ender the final value of the parameter into the SQL statement at
 #tatement execution time, omitting the value from the parameter
 #ictionary / list passed to DBAPI ``cursor.execute()``.  This
 #roduces a similar effect as that of using the ``literal_binds``,
 #ompilation flag,  however takes place as the statement is sent to
 #he DBAPI ``cursor.execute()`` method, rather than when the statement
 #s compiled.   The primary use of this
 #apability is for rendering LIMIT / OFFSET clauses for database
 #rivers that can't accommodate for bound parameters in these
 #ontexts, while allowing SQL constructs to be cacheable at the
 #ompilation level.

 #. versionadded:: 1.4 Added "post compile" bound parameters

 #. seealso::

 #ref:`change_4808`.

 #""

 #f required is NO_ARG:
 #equired = value is NO_ARG and callable_ is None
 #f value is NO_ARG:
 #alue = None

 #f quote is not None:
 #ey = quoted_name(key, quote)

 #f unique:
 #elf.key = _anonymous_label.safe_construct(
 #d(self),
 #ey
 #f key is not None and not isinstance(key, _anonymous_label)
 #lse "param",
 #anitize_key=True,
 #
 #elf._key_is_anon = True
 #lif key:
 #elf.key = key
 #lse:
 #elf.key = _anonymous_label.safe_construct(id(self), "param")
 #elf._key_is_anon = True

        # identifying key that won't change across
        # clones, used to identify the bind's logical
        # identity
 #elf._identifying_key = self.key

        # key that was passed in the first place, used to
        # generate new keys
 #elf._orig_key = key or "param"

 #elf.unique = unique
 #elf.value = value
 #elf.callable = callable_
 #elf.isoutparam = isoutparam
 #elf.required = required

        # indicate an "expanding" parameter; the compiler sets this
        # automatically in the compiler _render_in_expr_w_bindparam method
        # for an IN expression
 #elf.expanding = expanding

        # this is another hint to help w/ expanding and is typically
        # set in the compiler _render_in_expr_w_bindparam method for an
        # IN expression
 #elf.expand_op = None

 #elf.literal_execute = literal_execute
 #f _is_crud:
 #elf._is_crud = True

 #f type_ is None:
 #f expanding and value:
 #heck_value = value[0]
 #lse:
 #heck_value = value
 #f _compared_to_type is not None:
 #elf.type = _compared_to_type.coerce_compared_value(
 #compared_to_operator, check_value
 #
 #lse:
 #elf.type = type_api._resolve_value_to_type(check_value)
 #lif isinstance(type_, type):
 #elf.type = type_()
 #lif type_._is_tuple_type and value:
 #f expanding:
 #heck_value = value[0]
 #lse:
 #heck_value = value
 #elf.type = type_._resolve_values_to_types(check_value)
 #lse:
 #elf.type = type_

 #ef _with_value(self, value, maintain_key=False, required=NO_ARG):
 #""Return a copy of this :class:`.BindParameter` with the given value
 #et.
 #""
 #loned = self._clone(maintain_key=maintain_key)
 #loned.value = value
 #loned.callable = None
 #loned.required = required if required is not NO_ARG else self.required
 #f cloned.type is type_api.NULLTYPE:
 #loned.type = type_api._resolve_value_to_type(value)
 #eturn cloned

 #property
 #ef effective_value(self):
 #""Return the value of this bound parameter,
 #aking into account if the ``callable`` parameter
 #as set.

 #he ``callable`` value will be evaluated
 #nd returned if present, else ``value``.

 #""
 #f self.callable:
 #eturn self.callable()
 #lse:
 #eturn self.value

 #ef render_literal_execute(self):
 #""Produce a copy of this bound parameter that will enable the
 #paramref:`_sql.BindParameter.literal_execute` flag.

 #he :paramref:`_sql.BindParameter.literal_execute` flag will
 #ave the effect of the parameter rendered in the compiled SQL
 #tring using ``[POSTCOMPILE]`` form, which is a special form that
 #s converted to be a rendering of the literal value of the parameter
 #t SQL execution time.    The rationale is to support caching
 #f SQL statement strings that can embed per-statement literal values,
 #uch as LIMIT and OFFSET parameters, in the final SQL string that
 #s passed to the DBAPI.   Dialects in particular may want to use
 #his method within custom compilation schemes.

 #. versionadded:: 1.4.5

 #. seealso::

 #ref:`engine_thirdparty_caching`

 #""
 #eturn self.__class__(
 #elf.key,
 #elf.value,
 #ype_=self.type,
 #iteral_execute=True,
 #

 #ef _negate_in_binary(self, negated_op, original_op):
 #f self.expand_op is original_op:
 #ind = self._clone()
 #ind.expand_op = negated_op
 #eturn bind
 #lse:
 #eturn self

 #ef _with_binary_element_type(self, type_):
 # = ClauseElement._clone(self)
 #.type = type_
 #eturn c

 #ef _clone(self, maintain_key=False, **kw):
 # = ClauseElement._clone(self, **kw)
 #f not maintain_key and self.unique:
 #.key = _anonymous_label.safe_construct(
 #d(c), c._orig_key or "param", sanitize_key=True
 #
 #eturn c

 #ef _gen_cache_key(self, anon_map, bindparams):
 #gen_cache_ok = self.__class__.__dict__.get("inherit_cache", False)

 #f not _gen_cache_ok:
 #f anon_map is not None:
 #non_map[NO_CACHE] = True
 #eturn None

 #dself = id(self)
 #f idself in anon_map:
 #eturn (anon_map[idself], self.__class__)
 #lse:
            # inline of
            # id_ = anon_map[idself]
 #non_map[idself] = id_ = str(anon_map.index)
 #non_map.index += 1

 #f bindparams is not None:
 #indparams.append(self)

 #eturn (
 #d_,
 #elf.__class__,
 #elf.type._static_cache_key,
 #elf.key % anon_map if self._key_is_anon else self.key,
 #

 #ef _convert_to_unique(self):
 #f not self.unique:
 #elf.unique = True
 #elf.key = _anonymous_label.safe_construct(
 #d(self), self._orig_key or "param", sanitize_key=True
 #

 #ef __getstate__(self):
 #""execute a deferred value for serialization purposes."""

 # = self.__dict__.copy()
 # = self.value
 #f self.callable:
 # = self.callable()
 #["callable"] = None
 #["value"] = v
 #eturn d

 #ef __setstate__(self, state):
 #f state.get("unique", False):
 #tate["key"] = _anonymous_label.safe_construct(
 #d(self), state.get("_orig_key", "param"), sanitize_key=True
 #
 #elf.__dict__.update(state)

 #ef __repr__(self):
 #eturn "%s(%r, %r, type_=%r)" % (
 #elf.__class__.__name__,
 #elf.key,
 #elf.value,
 #elf.type,
 #


class TypeClause(ClauseElement):
 #""Handle a type keyword in a SQL statement.

 #sed by the ``Case`` statement.

 #""

 #_visit_name__ = "typeclause"

 #traverse_internals = [("type", InternalTraversal.dp_type)]

 #ef __init__(self, type_):
 #elf.type = type_


class TextClause(
 #oles.DDLConstraintColumnRole,
 #oles.DDLExpressionRole,
 #oles.StatementOptionRole,
 #oles.WhereHavingRole,
 #oles.OrderByRole,
 #oles.FromClauseRole,
 #oles.SelectStatementRole,
 #oles.BinaryElementRole,
 #oles.InElementRole,
 #xecutable,
 #lauseElement,
):
 #""Represent a literal SQL text fragment.

 #.g.::

 #rom sqlalchemy import text

 # = text("SELECT * FROM users")
 #esult = connection.execute(t)


 #he :class:`_expression.TextClause` construct is produced using the
 #func:`_expression.text`
 #unction; see that function for full documentation.

 #. seealso::

 #func:`_expression.text`

 #""

 #_visit_name__ = "textclause"

 #traverse_internals = [
 #"_bindparams", InternalTraversal.dp_string_clauseelement_dict),
 #"text", InternalTraversal.dp_string),
 #

 #is_text_clause = True

 #is_textual = True

 #bind_params_regex = re.compile(r"(?<![:\w\x5c]):(\w+)(?!:)", re.UNICODE)
 #execution_options = Executable._execution_options.union(
 #"autocommit": PARSE_AUTOCOMMIT}
 #
 #is_implicitly_boolean = False

 #render_label_in_columns_clause = False

 #hide_froms = ()

 #ef __and__(self, other):
        # support use in select.where(), query.filter()
 #eturn and_(self, other)

 #property
 #ef _select_iterable(self):
 #eturn (self,)

    # help in those cases where text() is
    # interpreted in a column expression situation
 #ey = _label = _resolve_label = None

 #allow_label_resolve = False

 #ef __init__(self, text, bind=None):
 #elf._bind = bind
 #elf._bindparams = {}

 #ef repl(m):
 #elf._bindparams[m.group(1)] = BindParameter(m.group(1))
 #eturn ":%s" % m.group(1)

        # scan the string and search for bind parameter names, add them
        # to the list of bindparams
 #elf.text = self._bind_params_regex.sub(repl, text)

 #classmethod
 #_document_text_coercion("text", ":func:`.text`", ":paramref:`.text.text`")
 #util.deprecated_params(
 #ind=(
 #2.0",
 #The :paramref:`_sql.text.bind` argument is deprecated and "
 #will be removed in SQLAlchemy 2.0.",
 #,
 #
 #ef _create_text(cls, text, bind=None):
 #"""Construct a new :class:`_expression.TextClause` clause,
 #epresenting
 # textual SQL string directly.

 #.g.::

 #rom sqlalchemy import text

 # = text("SELECT * FROM users")
 #esult = connection.execute(t)

 #he advantages :func:`_expression.text`
 #rovides over a plain string are
 #ackend-neutral support for bind parameters, per-statement
 #xecution options, as well as
 #ind parameter and result-column typing behavior, allowing
 #QLAlchemy type constructs to play a role when executing
 # statement that is specified literally.  The construct can also
 #e provided with a ``.c`` collection of column elements, allowing
 #t to be embedded in other SQL expression constructs as a subquery.

 #ind parameters are specified by name, using the format ``:name``.
 #.g.::

 # = text("SELECT * FROM users WHERE id=:user_id")
 #esult = connection.execute(t, user_id=12)

 #or SQL statements where a colon is required verbatim, as within
 #n inline string, use a backslash to escape::

 # = text("SELECT * FROM users WHERE name='\:username'")

 #he :class:`_expression.TextClause`
 #onstruct includes methods which can
 #rovide information about the bound parameters as well as the column
 #alues which would be returned from the textual statement, assuming
 #t's an executable SELECT type of statement.  The
 #meth:`_expression.TextClause.bindparams`
 #ethod is used to provide bound
 #arameter detail, and :meth:`_expression.TextClause.columns`
 #ethod allows
 #pecification of return columns including names and types::

 # = text("SELECT * FROM users WHERE id=:user_id").\
 #indparams(user_id=7).\
 #olumns(id=Integer, name=String)

 #or id, name in connection.execute(t):
 #rint(id, name)

 #he :func:`_expression.text` construct is used in cases when
 # literal string SQL fragment is specified as part of a larger query,
 #uch as for the WHERE clause of a SELECT statement::

 # = select(users.c.id, users.c.name).where(text("id=:user_id"))
 #esult = connection.execute(s, user_id=12)

 #func:`_expression.text` is also used for the construction
 #f a full, standalone statement using plain text.
 #s such, SQLAlchemy refers
 #o it as an :class:`.Executable` object, and it supports
 #he :meth:`Executable.execution_options` method.  For example,
 # :func:`_expression.text`
 #onstruct that should be subject to "autocommit"
 #an be set explicitly so using the
 #paramref:`.Connection.execution_options.autocommit` option::

 # = text("EXEC my_procedural_thing()").\
 #xecution_options(autocommit=True)

 #. deprecated:: 1.4  The "autocommit" execution option is deprecated
 #nd will be removed in SQLAlchemy 2.0.  See
 #ref:`migration_20_autocommit` for discussion.

 #param text:
 #he text of the SQL statement to be created.  Use ``:<param>``
 #o specify bind parameters; they will be compiled to their
 #ngine-specific format.

 #param bind:
 #n optional connection or engine to be used for this text query.

 #. seealso::

 #ref:`sqlexpression_text` - in the Core tutorial


 #""
 #eturn TextClause(text, bind=bind)

 #_generative
 #ef bindparams(self, *binds, **names_to_values):
 #""Establish the values and/or types of bound parameters within
 #his :class:`_expression.TextClause` construct.

 #iven a text construct such as::

 #rom sqlalchemy import text
 #tmt = text("SELECT id, name FROM user WHERE name=:name "
 #AND timestamp=:timestamp")

 #he :meth:`_expression.TextClause.bindparams`
 #ethod can be used to establish
 #he initial value of ``:name`` and ``:timestamp``,
 #sing simple keyword arguments::

 #tmt = stmt.bindparams(name='jack',
 #imestamp=datetime.datetime(2012, 10, 8, 15, 12, 5))

 #here above, new :class:`.BindParameter` objects
 #ill be generated with the names ``name`` and ``timestamp``, and
 #alues of ``jack`` and ``datetime.datetime(2012, 10, 8, 15, 12, 5)``,
 #espectively.  The types will be
 #nferred from the values given, in this case :class:`.String` and
 #class:`.DateTime`.

 #hen specific typing behavior is needed, the positional ``*binds``
 #rgument can be used in which to specify :func:`.bindparam` constructs
 #irectly.  These constructs must include at least the ``key``
 #rgument, then an optional value and type::

 #rom sqlalchemy import bindparam
 #tmt = stmt.bindparams(
 #indparam('name', value='jack', type_=String),
 #indparam('timestamp', type_=DateTime)
 #

 #bove, we specified the type of :class:`.DateTime` for the
 #`timestamp`` bind, and the type of :class:`.String` for the ``name``
 #ind.  In the case of ``name`` we also set the default value of
 #`"jack"``.

 #dditional bound parameters can be supplied at statement execution
 #ime, e.g.::

 #esult = connection.execute(stmt,
 #imestamp=datetime.datetime(2012, 10, 8, 15, 12, 5))

 #he :meth:`_expression.TextClause.bindparams`
 #ethod can be called repeatedly,
 #here it will re-use existing :class:`.BindParameter` objects to add
 #ew information.  For example, we can call
 #meth:`_expression.TextClause.bindparams`
 #irst with typing information, and a
 #econd time with value information, and it will be combined::

 #tmt = text("SELECT id, name FROM user WHERE name=:name "
 #AND timestamp=:timestamp")
 #tmt = stmt.bindparams(
 #indparam('name', type_=String),
 #indparam('timestamp', type_=DateTime)
 #
 #tmt = stmt.bindparams(
 #ame='jack',
 #imestamp=datetime.datetime(2012, 10, 8, 15, 12, 5)
 #

 #he :meth:`_expression.TextClause.bindparams`
 #ethod also supports the concept of
 #*unique** bound parameters.  These are parameters that are
 #uniquified" on name at statement compilation time, so that  multiple
 #func:`_expression.text`
 #onstructs may be combined together without the names
 #onflicting.  To use this feature, specify the
 #paramref:`.BindParameter.unique` flag on each :func:`.bindparam`
 #bject::

 #tmt1 = text("select id from table where name=:name").bindparams(
 #indparam("name", value='name1', unique=True)
 #
 #tmt2 = text("select id from table where name=:name").bindparams(
 #indparam("name", value='name2', unique=True)
 #

 #nion = union_all(
 #tmt1.columns(column("id")),
 #tmt2.columns(column("id"))
 #

 #he above statement will render as::

 #elect id from table where name=:name_1
 #NION ALL select id from table where name=:name_2

 #. versionadded:: 1.3.11  Added support for the
 #paramref:`.BindParameter.unique` flag to work with
 #func:`_expression.text`
 #onstructs.

 #""
 #elf._bindparams = new_params = self._bindparams.copy()

 #or bind in binds:
 #ry:
                # the regex used for text() currently will not match
                # a unique/anonymous key in any case, so use the _orig_key
                # so that a text() construct can support unique parameters
 #xisting = new_params[bind._orig_key]
 #xcept KeyError as err:
 #til.raise_(
 #xc.ArgumentError(
 #This text() construct doesn't define a "
 #bound parameter named %r" % bind._orig_key
 #,
 #eplace_context=err,
 #
 #lse:
 #ew_params[existing._orig_key] = bind

 #or key, value in names_to_values.items():
 #ry:
 #xisting = new_params[key]
 #xcept KeyError as err:
 #til.raise_(
 #xc.ArgumentError(
 #This text() construct doesn't define a "
 #bound parameter named %r" % key
 #,
 #eplace_context=err,
 #
 #lse:
 #ew_params[key] = existing._with_value(value, required=False)

 #util.preload_module("sqlalchemy.sql.selectable")
 #ef columns(self, *cols, **types):
 #"""Turn this :class:`_expression.TextClause` object into a
 #class:`_expression.TextualSelect`
 #bject that serves the same role as a SELECT
 #tatement.

 #he :class:`_expression.TextualSelect` is part of the
 #class:`_expression.SelectBase`
 #ierarchy and can be embedded into another statement by using the
 #meth:`_expression.TextualSelect.subquery` method to produce a
 #class:`.Subquery`
 #bject, which can then be SELECTed from.

 #his function essentially bridges the gap between an entirely
 #extual SELECT statement and the SQL expression language concept
 #f a "selectable"::

 #rom sqlalchemy.sql import column, text

 #tmt = text("SELECT id, name FROM some_table")
 #tmt = stmt.columns(column('id'), column('name')).subquery('st')

 #tmt = select(mytable).\
 #elect_from(
 #ytable.join(stmt, mytable.c.name == stmt.c.name)
 #.where(stmt.c.id > 5)

 #bove, we pass a series of :func:`_expression.column` elements to the
 #meth:`_expression.TextClause.columns` method positionally.  These
 #func:`_expression.column`
 #lements now become first class elements upon the
 #attr:`_expression.TextualSelect.selected_columns` column collection,
 #hich then
 #ecome part of the :attr:`.Subquery.c` collection after
 #meth:`_expression.TextualSelect.subquery` is invoked.

 #he column expressions we pass to
 #meth:`_expression.TextClause.columns` may
 #lso be typed; when we do so, these :class:`.TypeEngine` objects become
 #he effective return type of the column, so that SQLAlchemy's
 #esult-set-processing systems may be used on the return values.
 #his is often needed for types such as date or boolean types, as well
 #s for unicode processing on some dialect configurations::

 #tmt = text("SELECT id, name, timestamp FROM some_table")
 #tmt = stmt.columns(
 #olumn('id', Integer),
 #olumn('name', Unicode),
 #olumn('timestamp', DateTime)
 #

 #or id, name, timestamp in connection.execute(stmt):
 #rint(id, name, timestamp)

 #s a shortcut to the above syntax, keyword arguments referring to
 #ypes alone may be used, if only type conversion is needed::

 #tmt = text("SELECT id, name, timestamp FROM some_table")
 #tmt = stmt.columns(
 #d=Integer,
 #ame=Unicode,
 #imestamp=DateTime
 #

 #or id, name, timestamp in connection.execute(stmt):
 #rint(id, name, timestamp)

 #he positional form of :meth:`_expression.TextClause.columns`
 #lso provides the
 #nique feature of **positional column targeting**, which is
 #articularly useful when using the ORM with complex textual queries. If
 #e specify the columns from our model to
 #meth:`_expression.TextClause.columns`,
 #he result set will match to those columns positionally, meaning the
 #ame or origin of the column in the textual SQL doesn't matter::

 #tmt = text("SELECT users.id, addresses.id, users.id, "
 #users.name, addresses.email_address AS email "
 #FROM users JOIN addresses ON users.id=addresses.user_id "
 #WHERE users.id = 1").columns(
 #ser.id,
 #ddress.id,
 #ddress.user_id,
 #ser.name,
 #ddress.email_address
 #

 #uery = session.query(User).from_statement(stmt).options(
 #ontains_eager(User.addresses))

 #. versionadded:: 1.1 the :meth:`_expression.TextClause.columns`
 #ethod now
 #ffers positional column targeting in the result set when
 #he column expressions are passed purely positionally.

 #he :meth:`_expression.TextClause.columns` method provides a direct
 #oute to calling :meth:`_expression.FromClause.subquery` as well as
 #meth:`_expression.SelectBase.cte`
 #gainst a textual SELECT statement::

 #tmt = stmt.columns(id=Integer, name=String).cte('st')

 #tmt = select(sometable).where(sometable.c.id == stmt.c.id)

 #param \*cols: A series of :class:`_expression.ColumnElement` objects,
 #ypically
 #class:`_schema.Column` objects from a :class:`_schema.Table`
 #r ORM level
 #olumn-mapped attributes, representing a set of columns that this
 #extual string will SELECT from.

 #param \**types: A mapping of string names to :class:`.TypeEngine`
 #ype objects indicating the datatypes to use for names that are
 #ELECTed from the textual string.  Prefer to use the ``*cols``
 #rgument as it also indicates positional ordering.

 #""
 #electable = util.preloaded.sql_selectable
 #ositional_input_cols = [
 #olumnClause(col.key, types.pop(col.key))
 #f col.key in types
 #lse col
 #or col in cols
 #
 #eyed_input_cols = [
 #olumnClause(key, type_) for key, type_ in types.items()
 #

 #eturn selectable.TextualSelect(
 #elf,
 #ositional_input_cols + keyed_input_cols,
 #ositional=bool(positional_input_cols) and not keyed_input_cols,
 #

 #property
 #ef type(self):
 #eturn type_api.NULLTYPE

 #property
 #ef comparator(self):
 #eturn self.type.comparator_factory(self)

 #ef self_group(self, against=None):
 #f against is operators.in_op:
 #eturn Grouping(self)
 #lse:
 #eturn self


class Null(SingletonConstant, roles.ConstExprRole, ColumnElement):
 #""Represent the NULL keyword in a SQL statement.

 #class:`.Null` is accessed as a constant via the
 #func:`.null` function.

 #""

 #_visit_name__ = "null"

 #traverse_internals = []

 #util.memoized_property
 #ef type(self):
 #eturn type_api.NULLTYPE

 #classmethod
 #ef _instance(cls):
 #""Return a constant :class:`.Null` construct."""

 #eturn Null()


Null._create_singleton()


class False_(SingletonConstant, roles.ConstExprRole, ColumnElement):
 #""Represent the ``false`` keyword, or equivalent, in a SQL statement.

 #class:`.False_` is accessed as a constant via the
 #func:`.false` function.

 #""

 #_visit_name__ = "false"
 #traverse_internals = []

 #util.memoized_property
 #ef type(self):
 #eturn type_api.BOOLEANTYPE

 #ef _negate(self):
 #eturn True_()

 #classmethod
 #ef _instance(cls):
 #""Return a :class:`.False_` construct.

 #.g.::

 #>> from sqlalchemy import false
 #>> print(select(t.c.x).where(false()))
 #ELECT x FROM t WHERE false

 # backend which does not support true/false constants will render as
 #n expression against 1 or 0::

 #>> print(select(t.c.x).where(false()))
 #ELECT x FROM t WHERE 0 = 1

 #he :func:`.true` and :func:`.false` constants also feature
 #short circuit" operation within an :func:`.and_` or :func:`.or_`
 #onjunction::

 #>> print(select(t.c.x).where(or_(t.c.x > 5, true())))
 #ELECT x FROM t WHERE true

 #>> print(select(t.c.x).where(and_(t.c.x > 5, false())))
 #ELECT x FROM t WHERE false

 #. versionchanged:: 0.9 :func:`.true` and :func:`.false` feature
 #etter integrated behavior within conjunctions and on dialects
 #hat don't support true/false constants.

 #. seealso::

 #func:`.true`

 #""

 #eturn False_()


False_._create_singleton()


class True_(SingletonConstant, roles.ConstExprRole, ColumnElement):
 #""Represent the ``true`` keyword, or equivalent, in a SQL statement.

 #class:`.True_` is accessed as a constant via the
 #func:`.true` function.

 #""

 #_visit_name__ = "true"

 #traverse_internals = []

 #util.memoized_property
 #ef type(self):
 #eturn type_api.BOOLEANTYPE

 #ef _negate(self):
 #eturn False_()

 #classmethod
 #ef _ifnone(cls, other):
 #f other is None:
 #eturn cls._instance()
 #lse:
 #eturn other

 #classmethod
 #ef _instance(cls):
 #""Return a constant :class:`.True_` construct.

 #.g.::

 #>> from sqlalchemy import true
 #>> print(select(t.c.x).where(true()))
 #ELECT x FROM t WHERE true

 # backend which does not support true/false constants will render as
 #n expression against 1 or 0::

 #>> print(select(t.c.x).where(true()))
 #ELECT x FROM t WHERE 1 = 1

 #he :func:`.true` and :func:`.false` constants also feature
 #short circuit" operation within an :func:`.and_` or :func:`.or_`
 #onjunction::

 #>> print(select(t.c.x).where(or_(t.c.x > 5, true())))
 #ELECT x FROM t WHERE true

 #>> print(select(t.c.x).where(and_(t.c.x > 5, false())))
 #ELECT x FROM t WHERE false

 #. versionchanged:: 0.9 :func:`.true` and :func:`.false` feature
 #etter integrated behavior within conjunctions and on dialects
 #hat don't support true/false constants.

 #. seealso::

 #func:`.false`

 #""

 #eturn True_()


True_._create_singleton()


class ClauseList(
 #oles.InElementRole,
 #oles.OrderByRole,
 #oles.ColumnsClauseRole,
 #oles.DMLColumnRole,
 #lauseElement,
):
 #""Describe a list of clauses, separated by an operator.

 #y default, is comma-separated, such as a column listing.

 #""

 #_visit_name__ = "clauselist"

 #is_clause_list = True

 #traverse_internals = [
 #"clauses", InternalTraversal.dp_clauseelement_list),
 #"operator", InternalTraversal.dp_operator),
 #

 #ef __init__(self, *clauses, **kwargs):
 #elf.operator = kwargs.pop("operator", operators.comma_op)
 #elf.group = kwargs.pop("group", True)
 #elf.group_contents = kwargs.pop("group_contents", True)
 #f kwargs.pop("_flatten_sub_clauses", False):
 #lauses = util.flatten_iterator(clauses)
 #elf._text_converter_role = text_converter_role = kwargs.pop(
 #_literal_as_text_role", roles.WhereHavingRole
 #
 #f self.group_contents:
 #elf.clauses = [
 #oercions.expect(
 #ext_converter_role, clause, apply_propagate_attrs=self
 #.self_group(against=self.operator)
 #or clause in clauses
 #
 #lse:
 #elf.clauses = [
 #oercions.expect(
 #ext_converter_role, clause, apply_propagate_attrs=self
 #
 #or clause in clauses
 #
 #elf._is_implicitly_boolean = operators.is_boolean(self.operator)

 #classmethod
 #ef _construct_raw(cls, operator, clauses=None):
 #elf = cls.__new__(cls)
 #elf.clauses = clauses if clauses else []
 #elf.group = True
 #elf.operator = operator
 #elf.group_contents = True
 #elf._is_implicitly_boolean = False
 #eturn self

 #ef __iter__(self):
 #eturn iter(self.clauses)

 #ef __len__(self):
 #eturn len(self.clauses)

 #property
 #ef _select_iterable(self):
 #eturn itertools.chain.from_iterable(
 #elem._select_iterable for elem in self.clauses]
 #

 #ef append(self, clause):
 #f self.group_contents:
 #elf.clauses.append(
 #oercions.expect(self._text_converter_role, clause).self_group(
 #gainst=self.operator
 #
 #
 #lse:
 #elf.clauses.append(
 #oercions.expect(self._text_converter_role, clause)
 #

 #property
 #ef _from_objects(self):
 #eturn list(itertools.chain(*[c._from_objects for c in self.clauses]))

 #ef self_group(self, against=None):
 #f self.group and operators.is_precedent(self.operator, against):
 #eturn Grouping(self)
 #lse:
 #eturn self


class BooleanClauseList(ClauseList, ColumnElement):
 #_visit_name__ = "clauselist"
 #nherit_cache = True

 #ef __init__(self, *arg, **kw):
 #aise NotImplementedError(
 #BooleanClauseList has a private constructor"
 #

 #classmethod
 #ef _process_clauses_for_boolean(
 #ls, operator, continue_on, skip_on, clauses
 #:
 #as_continue_on = None

 #onvert_clauses = []

 #gainst = operators._asbool
 #cc = 0

 #or clause in clauses:
 #f clause is continue_on:
                # instance of continue_on, like and_(x, y, True, z), store it
                # if we didn't find one already, we will use it if there
                # are no other expressions here.
 #as_continue_on = clause
 #lif clause is skip_on:
                # instance of skip_on, e.g. and_(x, y, False, z), cancels
                # the rest out
 #onvert_clauses = [clause]
 #cc = 1
 #reak
 #lse:
 #f not lcc:
 #cc = 1
 #lse:
 #gainst = operator
                    # technically this would be len(convert_clauses) + 1
                    # however this only needs to indicate "greater than one"
 #cc = 2
 #onvert_clauses.append(clause)

 #f not convert_clauses and has_continue_on is not None:
 #onvert_clauses = [has_continue_on]
 #cc = 1

 #eturn lcc, [c.self_group(against=against) for c in convert_clauses]

 #classmethod
 #ef _construct(cls, operator, continue_on, skip_on, *clauses, **kw):
 #cc, convert_clauses = cls._process_clauses_for_boolean(
 #perator,
 #ontinue_on,
 #kip_on,
 #
 #oercions.expect(roles.WhereHavingRole, clause)
 #or clause in util.coerce_generator_arg(clauses)
 #,
 #

 #f lcc > 1:
            # multiple elements.  Return regular BooleanClauseList
            # which will link elements against the operator.
 #eturn cls._construct_raw(operator, convert_clauses)
 #lif lcc == 1:
            # just one element.  return it as a single boolean element,
            # not a list and discard the operator.
 #eturn convert_clauses[0]
 #lse:
            # no elements period.  deprecated use case.  return an empty
            # ClauseList construct that generates nothing unless it has
            # elements added to it.
 #til.warn_deprecated(
 #Invoking %(name)s() without arguments is deprecated, and "
 #will be disallowed in a future release.   For an empty "
 #%(name)s() construct, use %(name)s(%(continue_on)s, *args)."
 # {
 #name": operator.__name__,
 #continue_on": "True"
 #f continue_on is True_._singleton
 #lse "False",
 #,
 #ersion="1.4",
 #
 #eturn cls._construct_raw(operator)

 #classmethod
 #ef _construct_for_whereclause(cls, clauses):
 #perator, continue_on, skip_on = (
 #perators.and_,
 #rue_._singleton,
 #alse_._singleton,
 #

 #cc, convert_clauses = cls._process_clauses_for_boolean(
 #perator,
 #ontinue_on,
 #kip_on,
 #lauses,  # these are assumed to be coerced already
 #

 #f lcc > 1:
            # multiple elements.  Return regular BooleanClauseList
            # which will link elements against the operator.
 #eturn cls._construct_raw(operator, convert_clauses)
 #lif lcc == 1:
            # just one element.  return it as a single boolean element,
            # not a list and discard the operator.
 #eturn convert_clauses[0]
 #lse:
 #eturn None

 #classmethod
 #ef _construct_raw(cls, operator, clauses=None):
 #elf = cls.__new__(cls)
 #elf.clauses = clauses if clauses else []
 #elf.group = True
 #elf.operator = operator
 #elf.group_contents = True
 #elf.type = type_api.BOOLEANTYPE
 #elf._is_implicitly_boolean = True
 #eturn self

 #classmethod
 #ef and_(cls, *clauses):
 #"""Produce a conjunction of expressions joined by ``AND``.

 #.g.::

 #rom sqlalchemy import and_

 #tmt = select(users_table).where(
 #nd_(
 #sers_table.c.name == 'wendy',
 #sers_table.c.enrolled == True
 #
 #

 #he :func:`.and_` conjunction is also available using the
 #ython ``&`` operator (though note that compound expressions
 #eed to be parenthesized in order to function with Python
 #perator precedence behavior)::

 #tmt = select(users_table).where(
 #users_table.c.name == 'wendy') &
 #users_table.c.enrolled == True)
 #

 #he :func:`.and_` operation is also implicit in some cases;
 #he :meth:`_expression.Select.where`
 #ethod for example can be invoked multiple
 #imes against a statement, which will have the effect of each
 #lause being combined using :func:`.and_`::

 #tmt = select(users_table).\
 #here(users_table.c.name == 'wendy').\
 #here(users_table.c.enrolled == True)

 #he :func:`.and_` construct must be given at least one positional
 #rgument in order to be valid; a :func:`.and_` construct with no
 #rguments is ambiguous.   To produce an "empty" or dynamically
 #enerated :func:`.and_`  expression, from a given list of expressions,
 # "default" element of ``True`` should be specified::

 #riteria = and_(True, *expressions)

 #he above expression will compile to SQL as the expression ``true``
 #r ``1 = 1``, depending on backend, if no other expressions are
 #resent.  If expressions are present, then the ``True`` value is
 #gnored as it does not affect the outcome of an AND expression that
 #as other elements.

 #. deprecated:: 1.4  The :func:`.and_` element now requires that at
 #east one argument is passed; creating the :func:`.and_` construct
 #ith no arguments is deprecated, and will emit a deprecation warning
 #hile continuing to produce a blank SQL string.

 #. seealso::

 #func:`.or_`

 #""
 #eturn cls._construct(
 #perators.and_, True_._singleton, False_._singleton, *clauses
 #

 #classmethod
 #ef or_(cls, *clauses):
 #""Produce a conjunction of expressions joined by ``OR``.

 #.g.::

 #rom sqlalchemy import or_

 #tmt = select(users_table).where(
 #r_(
 #sers_table.c.name == 'wendy',
 #sers_table.c.name == 'jack'
 #
 #

 #he :func:`.or_` conjunction is also available using the
 #ython ``|`` operator (though note that compound expressions
 #eed to be parenthesized in order to function with Python
 #perator precedence behavior)::

 #tmt = select(users_table).where(
 #users_table.c.name == 'wendy') |
 #users_table.c.name == 'jack')
 #

 #he :func:`.or_` construct must be given at least one positional
 #rgument in order to be valid; a :func:`.or_` construct with no
 #rguments is ambiguous.   To produce an "empty" or dynamically
 #enerated :func:`.or_`  expression, from a given list of expressions,
 # "default" element of ``False`` should be specified::

 #r_criteria = or_(False, *expressions)

 #he above expression will compile to SQL as the expression ``false``
 #r ``0 = 1``, depending on backend, if no other expressions are
 #resent.  If expressions are present, then the ``False`` value is
 #gnored as it does not affect the outcome of an OR expression which
 #as other elements.

 #. deprecated:: 1.4  The :func:`.or_` element now requires that at
 #east one argument is passed; creating the :func:`.or_` construct
 #ith no arguments is deprecated, and will emit a deprecation warning
 #hile continuing to produce a blank SQL string.

 #. seealso::

 #func:`.and_`

 #""
 #eturn cls._construct(
 #perators.or_, False_._singleton, True_._singleton, *clauses
 #

 #property
 #ef _select_iterable(self):
 #eturn (self,)

 #ef self_group(self, against=None):
 #f not self.clauses:
 #eturn self
 #lse:
 #eturn super(BooleanClauseList, self).self_group(against=against)

 #ef _negate(self):
 #eturn ClauseList._negate(self)


and_ = BooleanClauseList.and_
or_ = BooleanClauseList.or_


class Tuple(ClauseList, ColumnElement):
 #""Represent a SQL tuple."""

 #_visit_name__ = "tuple"

 #traverse_internals = ClauseList._traverse_internals + []

 #util.preload_module("sqlalchemy.sql.sqltypes")
 #ef __init__(self, *clauses, **kw):
 #""Return a :class:`.Tuple`.

 #ain usage is to produce a composite IN construct using
 #meth:`.ColumnOperators.in_` ::

 #rom sqlalchemy import tuple_

 #uple_(table.c.col1, table.c.col2).in_(
 #(1, 2), (5, 12), (10, 19)]
 #

 #. versionchanged:: 1.3.6 Added support for SQLite IN tuples.

 #. warning::

 #he composite IN construct is not supported by all backends, and is
 #urrently known to work on PostgreSQL, MySQL, and SQLite.
 #nsupported backends will raise a subclass of
 #class:`~sqlalchemy.exc.DBAPIError` when such an expression is
 #nvoked.

 #""
 #qltypes = util.preloaded.sql_sqltypes

 #ypes = kw.pop("types", None)
 #f types is None:
 #lauses = [
 #oercions.expect(roles.ExpressionElementRole, c)
 #or c in clauses
 #
 #lse:
 #f len(types) != len(clauses):
 #aise exc.ArgumentError(
 #Wrong number of elements for %d-tuple: %r "
 # (len(types), clauses)
 #
 #lauses = [
 #oercions.expect(
 #oles.ExpressionElementRole,
 #,
 #ype_=typ if not typ._isnull else None,
 #
 #or typ, c in zip(types, clauses)
 #

 #elf.type = sqltypes.TupleType(*[arg.type for arg in clauses])
 #uper(Tuple, self).__init__(*clauses, **kw)

 #property
 #ef _select_iterable(self):
 #eturn (self,)

 #ef _bind_param(self, operator, obj, type_=None, expanding=False):
 #f expanding:
 #eturn BindParameter(
 #one,
 #alue=obj,
 #compared_to_operator=operator,
 #nique=True,
 #xpanding=True,
 #ype_=self.type,
 #
 #lse:
 #eturn Tuple(
 #[
 #indParameter(
 #one,
 #,
 #compared_to_operator=operator,
 #compared_to_type=compared_to_type,
 #nique=True,
 #ype_=type_,
 #
 #or o, compared_to_type in zip(obj, self.type.types)
 #
 #

 #ef self_group(self, against=None):
        # Tuple is parenthesized by definition.
 #eturn self


class Case(ColumnElement):
 #""Represent a ``CASE`` expression.

 #class:`.Case` is produced using the :func:`.case` factory function,
 #s in::

 #rom sqlalchemy import case

 #tmt = select(users_table).\
 #here(
 #ase(
 #users_table.c.name == 'wendy', 'W'),
 #users_table.c.name == 'jack', 'J'),
 #lse_='E'
 #
 #

 #etails on :class:`.Case` usage is at :func:`.case`.

 #. seealso::

 #func:`.case`

 #""

 #_visit_name__ = "case"

 #traverse_internals = [
 #"value", InternalTraversal.dp_clauseelement),
 #"whens", InternalTraversal.dp_clauseelement_tuples),
 #"else_", InternalTraversal.dp_clauseelement),
 #

    # TODO: for Py2k removal, this will be:
    # def __init__(self, *whens, value=None, else_=None):

 #ef __init__(self, *whens, **kw):
 #"""Produce a ``CASE`` expression.

 #he ``CASE`` construct in SQL is a conditional object that
 #cts somewhat analogously to an "if/then" construct in other
 #anguages.  It returns an instance of :class:`.Case`.

 #func:`.case` in its usual form is passed a series of "when"
 #onstructs, that is, a list of conditions and results as tuples::

 #rom sqlalchemy import case

 #tmt = select(users_table).\
 #here(
 #ase(
 #users_table.c.name == 'wendy', 'W'),
 #users_table.c.name == 'jack', 'J'),
 #lse_='E'
 #
 #

 #he above statement will produce SQL resembling::

 #ELECT id, name FROM user
 #HERE CASE
 #HEN (name = :name_1) THEN :param_1
 #HEN (name = :name_2) THEN :param_2
 #LSE :param_3
 #ND

 #hen simple equality expressions of several values against a single
 #arent column are needed, :func:`.case` also has a "shorthand" format
 #sed via the
 #paramref:`.case.value` parameter, which is passed a column
 #xpression to be compared.  In this form, the :paramref:`.case.whens`
 #arameter is passed as a dictionary containing expressions to be
 #ompared against keyed to result expressions.  The statement below is
 #quivalent to the preceding statement::

 #tmt = select(users_table).\
 #here(
 #ase(
 #"wendy": "W", "jack": "J"},
 #alue=users_table.c.name,
 #lse_='E'
 #
 #

 #he values which are accepted as result values in
 #paramref:`.case.whens` as well as with :paramref:`.case.else_` are
 #oerced from Python literals into :func:`.bindparam` constructs.
 #QL expressions, e.g. :class:`_expression.ColumnElement` constructs,
 #re accepted
 #s well.  To coerce a literal string expression into a constant
 #xpression rendered inline, use the :func:`_expression.literal_column`
 #onstruct,
 #s in::

 #rom sqlalchemy import case, literal_column

 #ase(
 #
 #rderline.c.qty > 100,
 #iteral_column("'greaterthan100'")
 #,
 #
 #rderline.c.qty > 10,
 #iteral_column("'greaterthan10'")
 #,
 #lse_=literal_column("'lessthan10'")
 #

 #he above will render the given constants without using bound
 #arameters for the result values (but still for the comparison
 #alues), as in::

 #ASE
 #HEN (orderline.qty > :qty_1) THEN 'greaterthan100'
 #HEN (orderline.qty > :qty_2) THEN 'greaterthan10'
 #LSE 'lessthan10'
 #ND

 #param \*whens: The criteria to be compared against,
 #paramref:`.case.whens` accepts two different forms, based on
 #hether or not :paramref:`.case.value` is used.

 #. versionchanged:: 1.4 the :func:`_sql.case`
 #unction now accepts the series of WHEN conditions positionally;
 #assing the expressions within a list is deprecated.

 #n the first form, it accepts a list of 2-tuples; each 2-tuple
 #onsists of ``(<sql expression>, <value>)``, where the SQL
 #xpression is a boolean expression and "value" is a resulting value,
 #.g.::

 #ase(
 #users_table.c.name == 'wendy', 'W'),
 #users_table.c.name == 'jack', 'J')
 #

 #n the second form, it accepts a Python dictionary of comparison
 #alues mapped to a resulting value; this form requires
 #paramref:`.case.value` to be present, and values will be compared
 #sing the ``==`` operator, e.g.::

 #ase(
 #"wendy": "W", "jack": "J"},
 #alue=users_table.c.name
 #

 #param value: An optional SQL expression which will be used as a
 #ixed "comparison point" for candidate values within a dictionary
 #assed to :paramref:`.case.whens`.

 #param else\_: An optional SQL expression which will be the evaluated
 #esult of the ``CASE`` construct if all expressions within
 #paramref:`.case.whens` evaluate to false.  When omitted, most
 #atabases will produce a result of NULL if none of the "when"
 #xpressions evaluate to true.


 #""

 #f "whens" in kw:
 #til.warn_deprecated_20(
 #The "whens" argument to case() is now passed using '
 #positional style only, not as a keyword argument."
 #
 #hens = (kw.pop("whens"),)

 #hens = coercions._expression_collection_was_a_list(
 #whens", "case", whens
 #

 #ry:
 #hens = util.dictlike_iteritems(whens)
 #xcept TypeError:
 #ass

 #alue = kw.pop("value", None)
 #f value is not None:
 #henlist = [
 #
 #oercions.expect(
 #oles.ExpressionElementRole,
 #,
 #pply_propagate_attrs=self,
 #.self_group(),
 #oercions.expect(roles.ExpressionElementRole, r),
 #
 #or (c, r) in whens
 #
 #lse:
 #henlist = [
 #
 #oercions.expect(
 #oles.ColumnArgumentRole, c, apply_propagate_attrs=self
 #.self_group(),
 #oercions.expect(roles.ExpressionElementRole, r),
 #
 #or (c, r) in whens
 #

 #f whenlist:
 #ype_ = list(whenlist[-1])[-1].type
 #lse:
 #ype_ = None

 #f value is None:
 #elf.value = None
 #lse:
 #elf.value = coercions.expect(roles.ExpressionElementRole, value)

 #elf.type = type_
 #elf.whens = whenlist

 #lse_ = kw.pop("else_", None)
 #f else_ is not None:
 #elf.else_ = coercions.expect(roles.ExpressionElementRole, else_)
 #lse:
 #elf.else_ = None

 #f kw:
 #aise TypeError("unknown arguments: %s" % (", ".join(sorted(kw))))

 #property
 #ef _from_objects(self):
 #eturn list(
 #tertools.chain(*[x._from_objects for x in self.get_children()])
 #


def literal_column(text, type_=None):
 #"""Produce a :class:`.ColumnClause` object that has the
 #paramref:`_expression.column.is_literal` flag set to True.

 #func:`_expression.literal_column` is similar to
 #func:`_expression.column`, except that
 #t is more often used as a "standalone" column expression that renders
 #xactly as stated; while :func:`_expression.column`
 #tores a string name that
 #ill be assumed to be part of a table and may be quoted as such,
 #func:`_expression.literal_column` can be that,
 #r any other arbitrary column-oriented
 #xpression.

 #param text: the text of the expression; can be any SQL expression.
 #uoting rules will not be applied. To specify a column-name expression
 #hich should be subject to quoting rules, use the :func:`column`
 #unction.

 #param type\_: an optional :class:`~sqlalchemy.types.TypeEngine`
 #bject which will
 #rovide result-set translation and additional expression semantics for
 #his column. If left as ``None`` the type will be :class:`.NullType`.

 #. seealso::

 #func:`_expression.column`

 #func:`_expression.text`

 #ref:`sqlexpression_literal_column`

 #""
 #eturn ColumnClause(text, type_=type_, is_literal=True)


class Cast(WrapsColumnExpression, ColumnElement):
 #""Represent a ``CAST`` expression.

 #class:`.Cast` is produced using the :func:`.cast` factory function,
 #s in::

 #rom sqlalchemy import cast, Numeric

 #tmt = select(cast(product_table.c.unit_price, Numeric(10, 4)))

 #etails on :class:`.Cast` usage is at :func:`.cast`.

 #. seealso::

 #ref:`coretutorial_casts`

 #func:`.cast`

 #func:`.type_coerce` - an alternative to CAST that coerces the type
 #n the Python side only, which is often sufficient to generate the
 #orrect SQL and data coercion.

 #""

 #_visit_name__ = "cast"

 #traverse_internals = [
 #"clause", InternalTraversal.dp_clauseelement),
 #"typeclause", InternalTraversal.dp_clauseelement),
 #

 #ef __init__(self, expression, type_):
 #"""Produce a ``CAST`` expression.

 #func:`.cast` returns an instance of :class:`.Cast`.

 #.g.::

 #rom sqlalchemy import cast, Numeric

 #tmt = select(cast(product_table.c.unit_price, Numeric(10, 4)))

 #he above statement will produce SQL resembling::

 #ELECT CAST(unit_price AS NUMERIC(10, 4)) FROM product

 #he :func:`.cast` function performs two distinct functions when
 #sed.  The first is that it renders the ``CAST`` expression within
 #he resulting SQL string.  The second is that it associates the given
 #ype (e.g. :class:`.TypeEngine` class or instance) with the column
 #xpression on the Python side, which means the expression will take
 #n the expression operator behavior associated with that type,
 #s well as the bound-value handling and result-row-handling behavior
 #f the type.

 #. versionchanged:: 0.9.0 :func:`.cast` now applies the given type
 #o the expression such that it takes effect on the bound-value,
 #.g. the Python-to-database direction, in addition to the
 #esult handling, e.g. database-to-Python, direction.

 #n alternative to :func:`.cast` is the :func:`.type_coerce` function.
 #his function performs the second task of associating an expression
 #ith a specific type, but does not render the ``CAST`` expression
 #n SQL.

 #param expression: A SQL expression, such as a
 #class:`_expression.ColumnElement`
 #xpression or a Python string which will be coerced into a bound
 #iteral value.

 #param type\_: A :class:`.TypeEngine` class or instance indicating
 #he type to which the ``CAST`` should apply.

 #. seealso::

 #ref:`coretutorial_casts`

 #func:`.type_coerce` - an alternative to CAST that coerces the type
 #n the Python side only, which is often sufficient to generate the
 #orrect SQL and data coercion.


 #""
 #elf.type = type_api.to_instance(type_)
 #elf.clause = coercions.expect(
 #oles.ExpressionElementRole,
 #xpression,
 #ype_=self.type,
 #pply_propagate_attrs=self,
 #
 #elf.typeclause = TypeClause(self.type)

 #property
 #ef _from_objects(self):
 #eturn self.clause._from_objects

 #property
 #ef wrapped_column_expression(self):
 #eturn self.clause


class TypeCoerce(WrapsColumnExpression, ColumnElement):
 #""Represent a Python-side type-coercion wrapper.

 #class:`.TypeCoerce` supplies the :func:`_expression.type_coerce`
 #unction; see that function for usage details.

 #. versionchanged:: 1.1 The :func:`.type_coerce` function now produces
 # persistent :class:`.TypeCoerce` wrapper object rather than
 #ranslating the given object in place.

 #. seealso::

 #func:`_expression.type_coerce`

 #func:`.cast`

 #""

 #_visit_name__ = "type_coerce"

 #traverse_internals = [
 #"clause", InternalTraversal.dp_clauseelement),
 #"type", InternalTraversal.dp_type),
 #

 #ef __init__(self, expression, type_):
 #"""Associate a SQL expression with a particular type, without rendering
 #`CAST``.

 #.g.::

 #rom sqlalchemy import type_coerce

 #tmt = select(type_coerce(log_table.date_string, StringDateTime()))

 #he above construct will produce a :class:`.TypeCoerce` object, which
 #oes not modify the rendering in any way on the SQL side, with the
 #ossible exception of a generated label if used in a columns clause
 #ontext::

 #ELECT date_string AS date_string FROM log

 #hen result rows are fetched, the ``StringDateTime`` type processor
 #ill be applied to result rows on behalf of the ``date_string`` column.

 #. note:: the :func:`.type_coerce` construct does not render any
 #QL syntax of its own, including that it does not imply
 #arenthesization.   Please use :meth:`.TypeCoerce.self_group`
 #f explicit parenthesization is required.

 #n order to provide a named label for the expression, use
 #meth:`_expression.ColumnElement.label`::

 #tmt = select(
 #ype_coerce(log_table.date_string, StringDateTime()).label('date')
 #


 # type that features bound-value handling will also have that behavior
 #ake effect when literal values or :func:`.bindparam` constructs are
 #assed to :func:`.type_coerce` as targets.
 #or example, if a type implements the
 #meth:`.TypeEngine.bind_expression`
 #ethod or :meth:`.TypeEngine.bind_processor` method or equivalent,
 #hese functions will take effect at statement compilation/execution
 #ime when a literal value is passed, as in::

            # bound-value handling of MyStringType will be applied to the
            # literal value "some string"
 #tmt = select(type_coerce("some string", MyStringType))

 #hen using :func:`.type_coerce` with composed expressions, note that
 #*parenthesis are not applied**.   If :func:`.type_coerce` is being
 #sed in an operator context where the parenthesis normally present from
 #AST are necessary, use the :meth:`.TypeCoerce.self_group` method::

 #>> some_integer = column("someint", Integer)
 #>> some_string = column("somestr", String)
 #>> expr = type_coerce(some_integer + 5, String) + some_string
 #>> print(expr)
 #omeint + :someint_1 || somestr
 #>> expr = type_coerce(some_integer + 5, String).self_group() + some_string
 #>> print(expr)
 #someint + :someint_1) || somestr

 #param expression: A SQL expression, such as a
 #class:`_expression.ColumnElement`
 #xpression or a Python string which will be coerced into a bound
 #iteral value.

 #param type\_: A :class:`.TypeEngine` class or instance indicating
 #he type to which the expression is coerced.

 #. seealso::

 #ref:`coretutorial_casts`

 #func:`.cast`

 #""  # noqa
 #elf.type = type_api.to_instance(type_)
 #elf.clause = coercions.expect(
 #oles.ExpressionElementRole,
 #xpression,
 #ype_=self.type,
 #pply_propagate_attrs=self,
 #

 #property
 #ef _from_objects(self):
 #eturn self.clause._from_objects

 #HasMemoized.memoized_attribute
 #ef typed_expression(self):
 #f isinstance(self.clause, BindParameter):
 #p = self.clause._clone()
 #p.type = self.type
 #eturn bp
 #lse:
 #eturn self.clause

 #property
 #ef wrapped_column_expression(self):
 #eturn self.clause

 #ef self_group(self, against=None):
 #rouped = self.clause.self_group(against=against)
 #f grouped is not self.clause:
 #eturn TypeCoerce(grouped, self.type)
 #lse:
 #eturn self


class Extract(ColumnElement):
 #""Represent a SQL EXTRACT clause, ``extract(field FROM expr)``."""

 #_visit_name__ = "extract"

 #traverse_internals = [
 #"expr", InternalTraversal.dp_clauseelement),
 #"field", InternalTraversal.dp_string),
 #

 #ef __init__(self, field, expr, **kwargs):
 #""Return a :class:`.Extract` construct.

 #his is typically available as :func:`.extract`
 #s well as ``func.extract`` from the
 #data:`.func` namespace.

 #""
 #elf.type = type_api.INTEGERTYPE
 #elf.field = field
 #elf.expr = coercions.expect(roles.ExpressionElementRole, expr)

 #property
 #ef _from_objects(self):
 #eturn self.expr._from_objects


class _label_reference(ColumnElement):
 #""Wrap a column expression as it appears in a 'reference' context.

 #his expression is any that includes an _order_by_label_element,
 #hich is a Label, or a DESC / ASC construct wrapping a Label.

 #he production of _label_reference() should occur when an expression
 #s added to this context; this includes the ORDER BY or GROUP BY of a
 #ELECT statement, as well as a few other places, such as the ORDER BY
 #ithin an OVER clause.

 #""

 #_visit_name__ = "label_reference"

 #traverse_internals = [("element", InternalTraversal.dp_clauseelement)]

 #ef __init__(self, element):
 #elf.element = element

 #property
 #ef _from_objects(self):
 #eturn ()


class _textual_label_reference(ColumnElement):
 #_visit_name__ = "textual_label_reference"

 #traverse_internals = [("element", InternalTraversal.dp_string)]

 #ef __init__(self, element):
 #elf.element = element

 #util.memoized_property
 #ef _text_clause(self):
 #eturn TextClause._create_text(self.element)


class UnaryExpression(ColumnElement):
 #""Define a 'unary' expression.

 # unary expression has a single column expression
 #nd an operator.  The operator can be placed on the left
 #where it is called the 'operator') or right (where it is called the
 #modifier') of the column expression.

 #class:`.UnaryExpression` is the basis for several unary operators
 #ncluding those used by :func:`.desc`, :func:`.asc`, :func:`.distinct`,
 #func:`.nulls_first` and :func:`.nulls_last`.

 #""

 #_visit_name__ = "unary"

 #traverse_internals = [
 #"element", InternalTraversal.dp_clauseelement),
 #"operator", InternalTraversal.dp_operator),
 #"modifier", InternalTraversal.dp_operator),
 #

 #ef __init__(
 #elf,
 #lement,
 #perator=None,
 #odifier=None,
 #ype_=None,
 #raps_column_expression=False,
 #:
 #elf.operator = operator
 #elf.modifier = modifier
 #elf._propagate_attrs = element._propagate_attrs
 #elf.element = element.self_group(
 #gainst=self.operator or self.modifier
 #
 #elf.type = type_api.to_instance(type_)
 #elf.wraps_column_expression = wraps_column_expression

 #classmethod
 #ef _create_nulls_first(cls, column):
 #""Produce the ``NULLS FIRST`` modifier for an ``ORDER BY`` expression.

 #func:`.nulls_first` is intended to modify the expression produced
 #y :func:`.asc` or :func:`.desc`, and indicates how NULL values
 #hould be handled when they are encountered during ordering::


 #rom sqlalchemy import desc, nulls_first

 #tmt = select(users_table).order_by(
 #ulls_first(desc(users_table.c.name)))

 #he SQL expression from the above would resemble::

 #ELECT id, name FROM user ORDER BY name DESC NULLS FIRST

 #ike :func:`.asc` and :func:`.desc`, :func:`.nulls_first` is typically
 #nvoked from the column expression itself using
 #meth:`_expression.ColumnElement.nulls_first`,
 #ather than as its standalone
 #unction version, as in::

 #tmt = select(users_table).order_by(
 #sers_table.c.name.desc().nulls_first())

 #. versionchanged:: 1.4 :func:`.nulls_first` is renamed from
 #func:`.nullsfirst` in previous releases.
 #he previous name remains available for backwards compatibility.

 #. seealso::

 #func:`.asc`

 #func:`.desc`

 #func:`.nulls_last`

 #meth:`_expression.Select.order_by`

 #""
 #eturn UnaryExpression(
 #oercions.expect(roles.ByOfRole, column),
 #odifier=operators.nulls_first_op,
 #raps_column_expression=False,
 #

 #classmethod
 #ef _create_nulls_last(cls, column):
 #""Produce the ``NULLS LAST`` modifier for an ``ORDER BY`` expression.

 #func:`.nulls_last` is intended to modify the expression produced
 #y :func:`.asc` or :func:`.desc`, and indicates how NULL values
 #hould be handled when they are encountered during ordering::


 #rom sqlalchemy import desc, nulls_last

 #tmt = select(users_table).order_by(
 #ulls_last(desc(users_table.c.name)))

 #he SQL expression from the above would resemble::

 #ELECT id, name FROM user ORDER BY name DESC NULLS LAST

 #ike :func:`.asc` and :func:`.desc`, :func:`.nulls_last` is typically
 #nvoked from the column expression itself using
 #meth:`_expression.ColumnElement.nulls_last`,
 #ather than as its standalone
 #unction version, as in::

 #tmt = select(users_table).order_by(
 #sers_table.c.name.desc().nulls_last())

 #. versionchanged:: 1.4 :func:`.nulls_last` is renamed from
 #func:`.nullslast` in previous releases.
 #he previous name remains available for backwards compatibility.

 #. seealso::

 #func:`.asc`

 #func:`.desc`

 #func:`.nulls_first`

 #meth:`_expression.Select.order_by`

 #""
 #eturn UnaryExpression(
 #oercions.expect(roles.ByOfRole, column),
 #odifier=operators.nulls_last_op,
 #raps_column_expression=False,
 #

 #classmethod
 #ef _create_desc(cls, column):
 #""Produce a descending ``ORDER BY`` clause element.

 #.g.::

 #rom sqlalchemy import desc

 #tmt = select(users_table).order_by(desc(users_table.c.name))

 #ill produce SQL as::

 #ELECT id, name FROM user ORDER BY name DESC

 #he :func:`.desc` function is a standalone version of the
 #meth:`_expression.ColumnElement.desc`
 #ethod available on all SQL expressions,
 #.g.::


 #tmt = select(users_table).order_by(users_table.c.name.desc())

 #param column: A :class:`_expression.ColumnElement` (e.g.
 #calar SQL expression)
 #ith which to apply the :func:`.desc` operation.

 #. seealso::

 #func:`.asc`

 #func:`.nulls_first`

 #func:`.nulls_last`

 #meth:`_expression.Select.order_by`

 #""
 #eturn UnaryExpression(
 #oercions.expect(roles.ByOfRole, column),
 #odifier=operators.desc_op,
 #raps_column_expression=False,
 #

 #classmethod
 #ef _create_asc(cls, column):
 #""Produce an ascending ``ORDER BY`` clause element.

 #.g.::

 #rom sqlalchemy import asc
 #tmt = select(users_table).order_by(asc(users_table.c.name))

 #ill produce SQL as::

 #ELECT id, name FROM user ORDER BY name ASC

 #he :func:`.asc` function is a standalone version of the
 #meth:`_expression.ColumnElement.asc`
 #ethod available on all SQL expressions,
 #.g.::


 #tmt = select(users_table).order_by(users_table.c.name.asc())

 #param column: A :class:`_expression.ColumnElement` (e.g.
 #calar SQL expression)
 #ith which to apply the :func:`.asc` operation.

 #. seealso::

 #func:`.desc`

 #func:`.nulls_first`

 #func:`.nulls_last`

 #meth:`_expression.Select.order_by`

 #""
 #eturn UnaryExpression(
 #oercions.expect(roles.ByOfRole, column),
 #odifier=operators.asc_op,
 #raps_column_expression=False,
 #

 #classmethod
 #ef _create_distinct(cls, expr):
 #""Produce an column-expression-level unary ``DISTINCT`` clause.

 #his applies the ``DISTINCT`` keyword to an individual column
 #xpression, and is typically contained within an aggregate function,
 #s in::

 #rom sqlalchemy import distinct, func
 #tmt = select(func.count(distinct(users_table.c.name)))

 #he above would produce an expression resembling::

 #ELECT COUNT(DISTINCT name) FROM user

 #he :func:`.distinct` function is also available as a column-level
 #ethod, e.g. :meth:`_expression.ColumnElement.distinct`, as in::

 #tmt = select(func.count(users_table.c.name.distinct()))

 #he :func:`.distinct` operator is different from the
 #meth:`_expression.Select.distinct` method of
 #class:`_expression.Select`,
 #hich produces a ``SELECT`` statement
 #ith ``DISTINCT`` applied to the result set as a whole,
 #.g. a ``SELECT DISTINCT`` expression.  See that method for further
 #nformation.

 #. seealso::

 #meth:`_expression.ColumnElement.distinct`

 #meth:`_expression.Select.distinct`

 #data:`.func`

 #""
 #xpr = coercions.expect(roles.ExpressionElementRole, expr)
 #eturn UnaryExpression(
 #xpr,
 #perator=operators.distinct_op,
 #ype_=expr.type,
 #raps_column_expression=False,
 #

 #property
 #ef _order_by_label_element(self):
 #f self.modifier in (operators.desc_op, operators.asc_op):
 #eturn self.element._order_by_label_element
 #lse:
 #eturn None

 #property
 #ef _from_objects(self):
 #eturn self.element._from_objects

 #ef _negate(self):
 #f self.type._type_affinity is type_api.BOOLEANTYPE._type_affinity:
 #eturn UnaryExpression(
 #elf.self_group(against=operators.inv),
 #perator=operators.inv,
 #ype_=type_api.BOOLEANTYPE,
 #raps_column_expression=self.wraps_column_expression,
 #
 #lse:
 #eturn ClauseElement._negate(self)

 #ef self_group(self, against=None):
 #f self.operator and operators.is_precedent(self.operator, against):
 #eturn Grouping(self)
 #lse:
 #eturn self


class CollectionAggregate(UnaryExpression):
 #""Forms the basis for right-hand collection operator modifiers
 #NY and ALL.

 #he ANY and ALL keywords are available in different ways on different
 #ackends.  On PostgreSQL, they only work for an ARRAY type.  On
 #ySQL, they only work for subqueries.

 #""

 #classmethod
 #ef _create_any(cls, expr):
 #""Produce an ANY expression.

 #his may apply to an array type for some dialects (e.g. postgresql),
 #r to a subquery for others (e.g. mysql).  e.g.::

            # postgresql '5 = ANY (somearray)'
 #xpr = 5 == any_(mytable.c.somearray)

            # mysql '5 = ANY (SELECT value FROM table)'
 #xpr = 5 == any_(select(table.c.value))

 #he operator is more conveniently available from any
 #class:`_sql.ColumnElement` object that makes use of the
 #class:`_types.ARRAY` datatype::

 #xpr = mytable.c.somearray.any(5)

 #. seealso::

 #func:`_expression.all_`

 #meth:`_types.ARRAY.any`

 #""

 #xpr = coercions.expect(roles.ExpressionElementRole, expr)

 #xpr = expr.self_group()
 #eturn CollectionAggregate(
 #xpr,
 #perator=operators.any_op,
 #ype_=type_api.NULLTYPE,
 #raps_column_expression=False,
 #

 #classmethod
 #ef _create_all(cls, expr):
 #""Produce an ALL expression.

 #his may apply to an array type for some dialects (e.g. postgresql),
 #r to a subquery for others (e.g. mysql).  e.g.::

            # postgresql '5 = ALL (somearray)'
 #xpr = 5 == all_(mytable.c.somearray)

            # mysql '5 = ALL (SELECT value FROM table)'
 #xpr = 5 == all_(select(table.c.value))

 #he operator is more conveniently available from any
 #class:`_sql.ColumnElement` object that makes use of the
 #class:`_types.ARRAY` datatype::

 #xpr = mytable.c.somearray.all(5)

 #. seealso::

 #func:`_expression.any_`

 #meth:`_types.ARRAY.Comparator.all`

 #""

 #xpr = coercions.expect(roles.ExpressionElementRole, expr)
 #xpr = expr.self_group()
 #eturn CollectionAggregate(
 #xpr,
 #perator=operators.all_op,
 #ype_=type_api.NULLTYPE,
 #raps_column_expression=False,
 #

    # operate and reverse_operate are hardwired to
    # dispatch onto the type comparator directly, so that we can
    # ensure "reversed" behavior.
 #ef operate(self, op, *other, **kwargs):
 #f not operators.is_comparison(op):
 #aise exc.ArgumentError(
 #Only comparison operators may be used with ANY/ALL"
 #
 #wargs["reverse"] = True
 #eturn self.comparator.operate(operators.mirror(op), *other, **kwargs)

 #ef reverse_operate(self, op, other, **kwargs):
        # comparison operators should never call reverse_operate
 #ssert not operators.is_comparison(op)
 #aise exc.ArgumentError(
 #Only comparison operators may be used with ANY/ALL"
 #


class AsBoolean(WrapsColumnExpression, UnaryExpression):
 #nherit_cache = True

 #ef __init__(self, element, operator, negate):
 #elf.element = element
 #elf.type = type_api.BOOLEANTYPE
 #elf.operator = operator
 #elf.negate = negate
 #elf.modifier = None
 #elf.wraps_column_expression = True
 #elf._is_implicitly_boolean = element._is_implicitly_boolean

 #property
 #ef wrapped_column_expression(self):
 #eturn self.element

 #ef self_group(self, against=None):
 #eturn self

 #ef _negate(self):
 #f isinstance(self.element, (True_, False_)):
 #eturn self.element._negate()
 #lse:
 #eturn AsBoolean(self.element, self.negate, self.operator)


class BinaryExpression(ColumnElement):
 #""Represent an expression that is ``LEFT <operator> RIGHT``.

 # :class:`.BinaryExpression` is generated automatically
 #henever two column expressions are used in a Python binary expression::

 #>> from sqlalchemy.sql import column
 #>> column('a') + column('b')
 #sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0>
 #>> print(column('a') + column('b'))
 # + b

 #""

 #_visit_name__ = "binary"

 #traverse_internals = [
 #"left", InternalTraversal.dp_clauseelement),
 #"right", InternalTraversal.dp_clauseelement),
 #"operator", InternalTraversal.dp_operator),
 #"negate", InternalTraversal.dp_operator),
 #"modifiers", InternalTraversal.dp_plain_dict),
 #
 #type",
 #nternalTraversal.dp_type,
 #,  # affects JSON CAST operators
 #

 #is_implicitly_boolean = True
 #""Indicates that any database will know this is a boolean expression
 #ven if the database does not have an explicit boolean datatype.

 #""

 #ef __init__(
 #elf, left, right, operator, type_=None, negate=None, modifiers=None
 #:
        # allow compatibility with libraries that
        # refer to BinaryExpression directly and pass strings
 #f isinstance(operator, util.string_types):
 #perator = operators.custom_op(operator)
 #elf._orig = (left.__hash__(), right.__hash__())
 #elf._propagate_attrs = left._propagate_attrs or right._propagate_attrs
 #elf.left = left.self_group(against=operator)
 #elf.right = right.self_group(against=operator)
 #elf.operator = operator
 #elf.type = type_api.to_instance(type_)
 #elf.negate = negate
 #elf._is_implicitly_boolean = operators.is_boolean(operator)

 #f modifiers is None:
 #elf.modifiers = {}
 #lse:
 #elf.modifiers = modifiers

 #ef __bool__(self):
 #f self.operator in (operator.eq, operator.ne):
 #eturn self.operator(*self._orig)
 #lse:
 #aise TypeError("Boolean value of this clause is not defined")

 #_nonzero__ = __bool__

 #property
 #ef is_comparison(self):
 #eturn operators.is_comparison(self.operator)

 #property
 #ef _from_objects(self):
 #eturn self.left._from_objects + self.right._from_objects

 #ef self_group(self, against=None):

 #f operators.is_precedent(self.operator, against):
 #eturn Grouping(self)
 #lse:
 #eturn self

 #ef _negate(self):
 #f self.negate is not None:
 #eturn BinaryExpression(
 #elf.left,
 #elf.right._negate_in_binary(self.negate, self.operator),
 #elf.negate,
 #egate=self.operator,
 #ype_=self.type,
 #odifiers=self.modifiers,
 #
 #lse:
 #eturn super(BinaryExpression, self)._negate()


class Slice(ColumnElement):
 #""Represent SQL for a Python array-slice object.

 #his is not a specific SQL construct at this level, but
 #ay be interpreted by specific dialects, e.g. PostgreSQL.

 #""

 #_visit_name__ = "slice"

 #traverse_internals = [
 #"start", InternalTraversal.dp_clauseelement),
 #"stop", InternalTraversal.dp_clauseelement),
 #"step", InternalTraversal.dp_clauseelement),
 #

 #ef __init__(self, start, stop, step, _name=None):
 #elf.start = coercions.expect(
 #oles.ExpressionElementRole,
 #tart,
 #ame=_name,
 #ype_=type_api.INTEGERTYPE,
 #
 #elf.stop = coercions.expect(
 #oles.ExpressionElementRole,
 #top,
 #ame=_name,
 #ype_=type_api.INTEGERTYPE,
 #
 #elf.step = coercions.expect(
 #oles.ExpressionElementRole,
 #tep,
 #ame=_name,
 #ype_=type_api.INTEGERTYPE,
 #
 #elf.type = type_api.NULLTYPE

 #ef self_group(self, against=None):
 #ssert against is operator.getitem
 #eturn self


class IndexExpression(BinaryExpression):
 #""Represent the class of expressions that are like an "index"
 #peration."""

 #ass


class GroupedElement(ClauseElement):
 #""Represent any parenthesized expression"""

 #_visit_name__ = "grouping"

 #ef self_group(self, against=None):
 #eturn self

 #ef _ungroup(self):
 #eturn self.element._ungroup()


class Grouping(GroupedElement, ColumnElement):
 #""Represent a grouping within a column expression"""

 #traverse_internals = [
 #"element", InternalTraversal.dp_clauseelement),
 #"type", InternalTraversal.dp_type),
 #

 #ef __init__(self, element):
 #elf.element = element
 #elf.type = getattr(element, "type", type_api.NULLTYPE)

 #ef _with_binary_element_type(self, type_):
 #eturn self.__class__(self.element._with_binary_element_type(type_))

 #util.memoized_property
 #ef _is_implicitly_boolean(self):
 #eturn self.element._is_implicitly_boolean

 #property
 #ef _tq_label(self):
 #eturn (
 #etattr(self.element, "_tq_label", None) or self._anon_name_label
 #

 #property
 #ef _proxies(self):
 #f isinstance(self.element, ColumnElement):
 #eturn [self.element]
 #lse:
 #eturn []

 #property
 #ef _from_objects(self):
 #eturn self.element._from_objects

 #ef __getattr__(self, attr):
 #eturn getattr(self.element, attr)

 #ef __getstate__(self):
 #eturn {"element": self.element, "type": self.type}

 #ef __setstate__(self, state):
 #elf.element = state["element"]
 #elf.type = state["type"]


RANGE_UNBOUNDED = util.symbol("RANGE_UNBOUNDED")
RANGE_CURRENT = util.symbol("RANGE_CURRENT")


class Over(ColumnElement):
 #""Represent an OVER clause.

 #his is a special operator against a so-called
 #window" function, as well as any aggregate function,
 #hich produces results relative to the result set
 #tself.  Most modern SQL backends now support window functions.

 #""

 #_visit_name__ = "over"

 #traverse_internals = [
 #"element", InternalTraversal.dp_clauseelement),
 #"order_by", InternalTraversal.dp_clauseelement),
 #"partition_by", InternalTraversal.dp_clauseelement),
 #"range_", InternalTraversal.dp_plain_obj),
 #"rows", InternalTraversal.dp_plain_obj),
 #

 #rder_by = None
 #artition_by = None

 #lement = None
 #""The underlying expression object to which this :class:`.Over`
 #bject refers towards."""

 #ef __init__(
 #elf, element, partition_by=None, order_by=None, range_=None, rows=None
 #:
 #"""Produce an :class:`.Over` object against a function.

 #sed against aggregate or so-called "window" functions,
 #or database backends that support window functions.

 #func:`_expression.over` is usually called using
 #he :meth:`.FunctionElement.over` method, e.g.::

 #unc.row_number().over(order_by=mytable.c.some_column)

 #ould produce::

 #OW_NUMBER() OVER(ORDER BY some_column)

 #anges are also possible using the :paramref:`.expression.over.range_`
 #nd :paramref:`.expression.over.rows` parameters.  These
 #utually-exclusive parameters each accept a 2-tuple, which contains
 # combination of integers and None::

 #unc.row_number().over(
 #rder_by=my_table.c.some_column, range_=(None, 0))

 #he above would produce::

 #OW_NUMBER() OVER(ORDER BY some_column
 #ANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)

 # value of ``None`` indicates "unbounded", a
 #alue of zero indicates "current row", and negative / positive
 #ntegers indicate "preceding" and "following":

 # RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING::

 #unc.row_number().over(order_by='x', range_=(-5, 10))

 # ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW::

 #unc.row_number().over(order_by='x', rows=(None, 0))

 # RANGE BETWEEN 2 PRECEDING AND UNBOUNDED FOLLOWING::

 #unc.row_number().over(order_by='x', range_=(-2, None))

 # RANGE BETWEEN 1 FOLLOWING AND 3 FOLLOWING::

 #unc.row_number().over(order_by='x', range_=(1, 3))

 #. versionadded:: 1.1 support for RANGE / ROWS within a window


 #param element: a :class:`.FunctionElement`, :class:`.WithinGroup`,
 #r other compatible construct.
 #param partition_by: a column element or string, or a list
 #f such, that will be used as the PARTITION BY clause
 #f the OVER construct.
 #param order_by: a column element or string, or a list
 #f such, that will be used as the ORDER BY clause
 #f the OVER construct.
 #param range\_: optional range clause for the window.  This is a
 #uple value which can contain integer values or ``None``,
 #nd will render a RANGE BETWEEN PRECEDING / FOLLOWING clause.

 #. versionadded:: 1.1

 #param rows: optional rows clause for the window.  This is a tuple
 #alue which can contain integer values or None, and will render
 # ROWS BETWEEN PRECEDING / FOLLOWING clause.

 #. versionadded:: 1.1

 #his function is also available from the :data:`~.expression.func`
 #onstruct itself via the :meth:`.FunctionElement.over` method.

 #. seealso::

 #ref:`tutorial_window_functions` - in the :ref:`unified_tutorial`

 #data:`.expression.func`

 #func:`_expression.within_group`

 #""
 #elf.element = element
 #f order_by is not None:
 #elf.order_by = ClauseList(
 #util.to_list(order_by), _literal_as_text_role=roles.ByOfRole
 #
 #f partition_by is not None:
 #elf.partition_by = ClauseList(
 #util.to_list(partition_by),
 #literal_as_text_role=roles.ByOfRole
 #

 #f range_:
 #elf.range_ = self._interpret_range(range_)
 #f rows:
 #aise exc.ArgumentError(
 #'range_' and 'rows' are mutually exclusive"
 #
 #lse:
 #elf.rows = None
 #lif rows:
 #elf.rows = self._interpret_range(rows)
 #elf.range_ = None
 #lse:
 #elf.rows = self.range_ = None

 #ef __reduce__(self):
 #eturn self.__class__, (
 #elf.element,
 #elf.partition_by,
 #elf.order_by,
 #elf.range_,
 #elf.rows,
 #

 #ef _interpret_range(self, range_):
 #f not isinstance(range_, tuple) or len(range_) != 2:
 #aise exc.ArgumentError("2-tuple expected for range/rows")

 #f range_[0] is None:
 #ower = RANGE_UNBOUNDED
 #lse:
 #ry:
 #ower = int(range_[0])
 #xcept ValueError as err:
 #til.raise_(
 #xc.ArgumentError(
 #Integer or None expected for range value"
 #,
 #eplace_context=err,
 #
 #lse:
 #f lower == 0:
 #ower = RANGE_CURRENT

 #f range_[1] is None:
 #pper = RANGE_UNBOUNDED
 #lse:
 #ry:
 #pper = int(range_[1])
 #xcept ValueError as err:
 #til.raise_(
 #xc.ArgumentError(
 #Integer or None expected for range value"
 #,
 #eplace_context=err,
 #
 #lse:
 #f upper == 0:
 #pper = RANGE_CURRENT

 #eturn lower, upper

 #util.memoized_property
 #ef type(self):
 #eturn self.element.type

 #property
 #ef _from_objects(self):
 #eturn list(
 #tertools.chain(
 #[
 #._from_objects
 #or c in (self.element, self.partition_by, self.order_by)
 #f c is not None
 #
 #
 #


class WithinGroup(ColumnElement):
 #""Represent a WITHIN GROUP (ORDER BY) clause.

 #his is a special operator against so-called
 #ordered set aggregate" and "hypothetical
 #et aggregate" functions, including ``percentile_cont()``,
 #`rank()``, ``dense_rank()``, etc.

 #t's supported only by certain database backends, such as PostgreSQL,
 #racle and MS SQL Server.

 #he :class:`.WithinGroup` construct extracts its type from the
 #ethod :meth:`.FunctionElement.within_group_type`.  If this returns
 #`None``, the function's ``.type`` is used.

 #""

 #_visit_name__ = "withingroup"

 #traverse_internals = [
 #"element", InternalTraversal.dp_clauseelement),
 #"order_by", InternalTraversal.dp_clauseelement),
 #

 #rder_by = None

 #ef __init__(self, element, *order_by):
 #"""Produce a :class:`.WithinGroup` object against a function.

 #sed against so-called "ordered set aggregate" and "hypothetical
 #et aggregate" functions, including :class:`.percentile_cont`,
 #class:`.rank`, :class:`.dense_rank`, etc.

 #func:`_expression.within_group` is usually called using
 #he :meth:`.FunctionElement.within_group` method, e.g.::

 #rom sqlalchemy import within_group
 #tmt = select(
 #epartment.c.id,
 #unc.percentile_cont(0.5).within_group(
 #epartment.c.salary.desc()
 #
 #

 #he above statement would produce SQL similar to
 #`SELECT department.id, percentile_cont(0.5)
 #ITHIN GROUP (ORDER BY department.salary DESC)``.

 #param element: a :class:`.FunctionElement` construct, typically
 #enerated by :data:`~.expression.func`.
 #param \*order_by: one or more column elements that will be used
 #s the ORDER BY clause of the WITHIN GROUP construct.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`tutorial_functions_within_group` - in the
 #ref:`unified_tutorial`

 #data:`.expression.func`

 #func:`_expression.over`

 #""
 #elf.element = element
 #f order_by is not None:
 #elf.order_by = ClauseList(
 #util.to_list(order_by), _literal_as_text_role=roles.ByOfRole
 #

 #ef over(self, partition_by=None, order_by=None, range_=None, rows=None):
 #""Produce an OVER clause against this :class:`.WithinGroup`
 #onstruct.

 #his function has the same signature as that of
 #meth:`.FunctionElement.over`.

 #""
 #eturn Over(
 #elf,
 #artition_by=partition_by,
 #rder_by=order_by,
 #ange_=range_,
 #ows=rows,
 #

 #util.memoized_property
 #ef type(self):
 #gt = self.element.within_group_type(self)
 #f wgt is not None:
 #eturn wgt
 #lse:
 #eturn self.element.type

 #property
 #ef _from_objects(self):
 #eturn list(
 #tertools.chain(
 #[
 #._from_objects
 #or c in (self.element, self.order_by)
 #f c is not None
 #
 #
 #


class FunctionFilter(ColumnElement):
 #""Represent a function FILTER clause.

 #his is a special operator against aggregate and window functions,
 #hich controls which rows are passed to it.
 #t's supported only by certain database backends.

 #nvocation of :class:`.FunctionFilter` is via
 #meth:`.FunctionElement.filter`::

 #unc.count(1).filter(True)

 #. versionadded:: 1.0.0

 #. seealso::

 #meth:`.FunctionElement.filter`

 #""

 #_visit_name__ = "funcfilter"

 #traverse_internals = [
 #"func", InternalTraversal.dp_clauseelement),
 #"criterion", InternalTraversal.dp_clauseelement),
 #

 #riterion = None

 #ef __init__(self, func, *criterion):
 #""Produce a :class:`.FunctionFilter` object against a function.

 #sed against aggregate and window functions,
 #or database backends that support the "FILTER" clause.

 #.g.::

 #rom sqlalchemy import funcfilter
 #uncfilter(func.count(1), MyClass.name == 'some name')

 #ould produce "COUNT(1) FILTER (WHERE myclass.name = 'some name')".

 #his function is also available from the :data:`~.expression.func`
 #onstruct itself via the :meth:`.FunctionElement.filter` method.

 #. versionadded:: 1.0.0

 #. seealso::

 #ref:`tutorial_functions_within_group` - in the
 #ref:`unified_tutorial`

 #meth:`.FunctionElement.filter`

 #""
 #elf.func = func
 #elf.filter(*criterion)

 #ef filter(self, *criterion):
 #""Produce an additional FILTER against the function.

 #his method adds additional criteria to the initial criteria
 #et up by :meth:`.FunctionElement.filter`.

 #ultiple criteria are joined together at SQL render time
 #ia ``AND``.


 #""

 #or criterion in list(criterion):
 #riterion = coercions.expect(roles.WhereHavingRole, criterion)

 #f self.criterion is not None:
 #elf.criterion = self.criterion & criterion
 #lse:
 #elf.criterion = criterion

 #eturn self

 #ef over(self, partition_by=None, order_by=None, range_=None, rows=None):
 #""Produce an OVER clause against this filtered function.

 #sed against aggregate or so-called "window" functions,
 #or database backends that support window functions.

 #he expression::

 #unc.rank().filter(MyClass.y > 5).over(order_by='x')

 #s shorthand for::

 #rom sqlalchemy import over, funcfilter
 #ver(funcfilter(func.rank(), MyClass.y > 5), order_by='x')

 #ee :func:`_expression.over` for a full description.

 #""
 #eturn Over(
 #elf,
 #artition_by=partition_by,
 #rder_by=order_by,
 #ange_=range_,
 #ows=rows,
 #

 #ef self_group(self, against=None):
 #f operators.is_precedent(operators.filter_op, against):
 #eturn Grouping(self)
 #lse:
 #eturn self

 #util.memoized_property
 #ef type(self):
 #eturn self.func.type

 #property
 #ef _from_objects(self):
 #eturn list(
 #tertools.chain(
 #[
 #._from_objects
 #or c in (self.func, self.criterion)
 #f c is not None
 #
 #
 #


class Label(roles.LabeledColumnExprRole, ColumnElement):
 #""Represents a column label (AS).

 #epresent a label, as typically applied to any column-level
 #lement using the ``AS`` sql keyword.

 #""

 #_visit_name__ = "label"

 #traverse_internals = [
 #"name", InternalTraversal.dp_anon_name),
 #"_type", InternalTraversal.dp_type),
 #"_element", InternalTraversal.dp_clauseelement),
 #

 #ef __init__(self, name, element, type_=None):
 #""Return a :class:`Label` object for the
 #iven :class:`_expression.ColumnElement`.

 # label changes the name of an element in the columns clause of a
 #`SELECT`` statement, typically via the ``AS`` SQL keyword.

 #his functionality is more conveniently available via the
 #meth:`_expression.ColumnElement.label` method on
 #class:`_expression.ColumnElement`.

 #param name: label name

 #param obj: a :class:`_expression.ColumnElement`.

 #""

 #f isinstance(element, Label):
 #elf._resolve_label = element._label

 #hile isinstance(element, Label):
 #lement = element.element

 #f name:
 #elf.name = name
 #elf._resolve_label = self.name
 #lse:
 #elf.name = _anonymous_label.safe_construct(
 #d(self), getattr(element, "name", "anon")
 #

 #elf.key = self._tq_label = self._tq_key_label = self.name
 #elf._element = element
 #elf._type = type_
 #elf._proxies = [element]

 #ef __reduce__(self):
 #eturn self.__class__, (self.name, self._element, self._type)

 #util.memoized_property
 #ef _is_implicitly_boolean(self):
 #eturn self.element._is_implicitly_boolean

 #HasMemoized.memoized_attribute
 #ef _allow_label_resolve(self):
 #eturn self.element._allow_label_resolve

 #property
 #ef _order_by_label_element(self):
 #eturn self

 #util.memoized_property
 #ef type(self):
 #eturn type_api.to_instance(
 #elf._type or getattr(self._element, "type", None)
 #

 #HasMemoized.memoized_attribute
 #ef element(self):
 #eturn self._element.self_group(against=operators.as_)

 #ef self_group(self, against=None):
 #eturn self._apply_to_inner(self._element.self_group, against=against)

 #ef _negate(self):
 #eturn self._apply_to_inner(self._element._negate)

 #ef _apply_to_inner(self, fn, *arg, **kw):
 #ub_element = fn(*arg, **kw)
 #f sub_element is not self._element:
 #eturn Label(self.name, sub_element, type_=self._type)
 #lse:
 #eturn self

 #property
 #ef primary_key(self):
 #eturn self.element.primary_key

 #property
 #ef foreign_keys(self):
 #eturn self.element.foreign_keys

 #ef _copy_internals(self, clone=_clone, anonymize_labels=False, **kw):
 #elf._reset_memoizations()
 #elf._element = clone(self._element, **kw)
 #f anonymize_labels:
 #elf.name = self._resolve_label = _anonymous_label.safe_construct(
 #d(self), getattr(self.element, "name", "anon")
 #
 #elf.key = self._tq_label = self._tq_key_label = self.name

 #property
 #ef _from_objects(self):
 #eturn self.element._from_objects

 #ef _make_proxy(self, selectable, name=None, **kw):
 #ame = self.name if not name else name

 #ey, e = self.element._make_proxy(
 #electable,
 #ame=name,
 #isallow_is_literal=True,
 #ame_is_truncatable=isinstance(name, _truncated_label),
 #

        # there was a note here to remove this assertion, which was here
        # to determine if we later could support a use case where
        # the key and name of a label are separate.  But I don't know what
        # that case was.  For now, this is an unexpected case that occurs
        # when a label name conflicts with other columns and select()
        # is attempting to disambiguate an explicit label, which is not what
        # the user would want.   See issue #6090.
 #f key != self.name:
 #aise exc.InvalidRequestError(
 #Label name %s is being renamed to an anonymous label due "
 #to disambiguation "
 #which is not supported right now.  Please use unique names "
 #for explicit labels." % (self.name)
 #

 #._propagate_attrs = selectable._propagate_attrs
 #._proxies.append(self)
 #f self._type is not None:
 #.type = self._type

 #eturn self.key, e


class NamedColumn(ColumnElement):
 #s_literal = False
 #able = None

 #ef _compare_name_for_result(self, other):
 #eturn (hasattr(other, "name") and self.name == other.name) or (
 #asattr(other, "_label") and self._label == other._label
 #

 #util.memoized_property
 #ef description(self):
 #f util.py3k:
 #eturn self.name
 #lse:
 #eturn self.name.encode("ascii", "backslashreplace")

 #HasMemoized.memoized_attribute
 #ef _tq_key_label(self):
 #""table qualified label based on column key.

 #or table-bound columns this is <tablename>_<column key/proxy key>;

 #ll other expressions it resolves to key/proxy key.

 #""
 #roxy_key = self._proxy_key
 #f proxy_key and proxy_key != self.name:
 #eturn self._gen_tq_label(proxy_key)
 #lse:
 #eturn self._tq_label

 #HasMemoized.memoized_attribute
 #ef _tq_label(self):
 #""table qualified label based on column name.

 #or table-bound columns this is <tablename>_<columnname>; all other
 #xpressions it resolves to .name.

 #""
 #eturn self._gen_tq_label(self.name)

 #HasMemoized.memoized_attribute
 #ef _render_label_in_columns_clause(self):
 #eturn True

 #HasMemoized.memoized_attribute
 #ef _non_anon_label(self):
 #eturn self.name

 #ef _gen_tq_label(self, name, dedupe_on_key=True):
 #eturn name

 #ef _bind_param(self, operator, obj, type_=None, expanding=False):
 #eturn BindParameter(
 #elf.key,
 #bj,
 #compared_to_operator=operator,
 #compared_to_type=self.type,
 #ype_=type_,
 #nique=True,
 #xpanding=expanding,
 #

 #ef _make_proxy(
 #elf,
 #electable,
 #ame=None,
 #ame_is_truncatable=False,
 #isallow_is_literal=False,
 #*kw
 #:
 # = ColumnClause(
 #oercions.expect(roles.TruncatedLabelRole, name or self.name)
 #f name_is_truncatable
 #lse (name or self.name),
 #ype_=self.type,
 #selectable=selectable,
 #s_literal=False,
 #
 #._propagate_attrs = selectable._propagate_attrs
 #f name is None:
 #.key = self.key
 #._proxies = [self]
 #f selectable._is_clone_of is not None:
 #._is_clone_of = selectable._is_clone_of.columns.get(c.key)
 #eturn c.key, c


class ColumnClause(
 #oles.DDLReferredColumnRole,
 #oles.LabeledColumnExprRole,
 #oles.StrAsPlainColumnRole,
 #mmutable,
 #amedColumn,
):
 #""Represents a column expression from any textual string.

 #he :class:`.ColumnClause`, a lightweight analogue to the
 #class:`_schema.Column` class, is typically invoked using the
 #func:`_expression.column` function, as in::

 #rom sqlalchemy import column

 #d, name = column("id"), column("name")
 #tmt = select(id, name).select_from("user")

 #he above statement would produce SQL like::

 #ELECT id, name FROM user

 #class:`.ColumnClause` is the immediate superclass of the schema-specific
 #class:`_schema.Column` object.  While the :class:`_schema.Column`
 #lass has all the
 #ame capabilities as :class:`.ColumnClause`, the :class:`.ColumnClause`
 #lass is usable by itself in those cases where behavioral requirements
 #re limited to simple SQL expression generation.  The object has none of
 #he associations with schema-level metadata or with execution-time
 #ehavior that :class:`_schema.Column` does,
 #o in that sense is a "lightweight"
 #ersion of :class:`_schema.Column`.

 #ull details on :class:`.ColumnClause` usage is at
 #func:`_expression.column`.

 #. seealso::

 #func:`_expression.column`

 #class:`_schema.Column`

 #""

 #able = None
 #s_literal = False

 #_visit_name__ = "column"

 #traverse_internals = [
 #"name", InternalTraversal.dp_anon_name),
 #"type", InternalTraversal.dp_type),
 #"table", InternalTraversal.dp_clauseelement),
 #"is_literal", InternalTraversal.dp_boolean),
 #

 #nupdate = default = server_default = server_onupdate = None

 #is_multiparam_column = False

 #ef __init__(self, text, type_=None, is_literal=False, _selectable=None):
 #""Produce a :class:`.ColumnClause` object.

 #he :class:`.ColumnClause` is a lightweight analogue to the
 #class:`_schema.Column` class.  The :func:`_expression.column`
 #unction can
 #e invoked with just a name alone, as in::

 #rom sqlalchemy import column

 #d, name = column("id"), column("name")
 #tmt = select(id, name).select_from("user")

 #he above statement would produce SQL like::

 #ELECT id, name FROM user

 #nce constructed, :func:`_expression.column`
 #ay be used like any other SQL
 #xpression element such as within :func:`_expression.select`
 #onstructs::

 #rom sqlalchemy.sql import column

 #d, name = column("id"), column("name")
 #tmt = select(id, name).select_from("user")

 #he text handled by :func:`_expression.column`
 #s assumed to be handled
 #ike the name of a database column; if the string contains mixed case,
 #pecial characters, or matches a known reserved word on the target
 #ackend, the column expression will render using the quoting
 #ehavior determined by the backend.  To produce a textual SQL
 #xpression that is rendered exactly without any quoting,
 #se :func:`_expression.literal_column` instead,
 #r pass ``True`` as the
 #alue of :paramref:`_expression.column.is_literal`.   Additionally,
 #ull SQL
 #tatements are best handled using the :func:`_expression.text`
 #onstruct.

 #func:`_expression.column` can be used in a table-like
 #ashion by combining it with the :func:`.table` function
 #which is the lightweight analogue to :class:`_schema.Table`
 # to produce
 # working table construct with minimal boilerplate::

 #rom sqlalchemy import table, column, select

 #ser = table("user",
 #olumn("id"),
 #olumn("name"),
 #olumn("description"),
 #

 #tmt = select(user.c.description).where(user.c.name == 'wendy')

 # :func:`_expression.column` / :func:`.table`
 #onstruct like that illustrated
 #bove can be created in an
 #d-hoc fashion and is not associated with any
 #class:`_schema.MetaData`, DDL, or events, unlike its
 #class:`_schema.Table` counterpart.

 #. versionchanged:: 1.0.0 :func:`_expression.column` can now
 #e imported from the plain ``sqlalchemy`` namespace like any
 #ther SQL element.

 #param text: the text of the element.

 #param type: :class:`_types.TypeEngine` object which can associate
 #his :class:`.ColumnClause` with a type.

 #param is_literal: if True, the :class:`.ColumnClause` is assumed to
 #e an exact expression that will be delivered to the output with no
 #uoting rules applied regardless of case sensitive settings. the
 #func:`_expression.literal_column()` function essentially invokes
 #func:`_expression.column` while passing ``is_literal=True``.

 #. seealso::

 #class:`_schema.Column`

 #func:`_expression.literal_column`

 #func:`.table`

 #func:`_expression.text`

 #ref:`sqlexpression_literal_column`

 #""
 #elf.key = self.name = text
 #elf.table = _selectable
 #elf.type = type_api.to_instance(type_)
 #elf.is_literal = is_literal

 #ef get_children(self, column_tables=False, **kw):
        # override base get_children() to not return the Table
        # or selectable that is parent to this column.  Traversals
        # expect the columns of tables and subqueries to be leaf nodes.
 #eturn []

 #property
 #ef entity_namespace(self):
 #f self.table is not None:
 #eturn self.table.entity_namespace
 #lse:
 #eturn super(ColumnClause, self).entity_namespace

 #HasMemoized.memoized_attribute
 #ef _from_objects(self):
 # = self.table
 #f t is not None:
 #eturn [t]
 #lse:
 #eturn []

 #HasMemoized.memoized_attribute
 #ef _render_label_in_columns_clause(self):
 #eturn self.table is not None

 #property
 #ef _ddl_label(self):
 #eturn self._gen_tq_label(self.name, dedupe_on_key=False)

 #ef _compare_name_for_result(self, other):
 #f (
 #elf.is_literal
 #r self.table is None
 #r self.table._is_textual
 #r not hasattr(other, "proxy_set")
 #r (
 #sinstance(other, ColumnClause)
 #nd (
 #ther.is_literal
 #r other.table is None
 #r other.table._is_textual
 #
 #
 #:
 #eturn (hasattr(other, "name") and self.name == other.name) or (
 #asattr(other, "_tq_label")
 #nd self._tq_label == other._tq_label
 #
 #lse:
 #eturn other.proxy_set.intersection(self.proxy_set)

 #ef _gen_tq_label(self, name, dedupe_on_key=True):
 #""generate table-qualified label

 #or a table-bound column this is <tablename>_<columnname>.

 #sed primarily for LABEL_STYLE_TABLENAME_PLUS_COL
 #s well as the .columns collection on a Join object.

 #""
 # = self.table
 #f self.is_literal:
 #eturn None
 #lif t is not None and t.named_with_column:
 #f getattr(t, "schema", None):
 #abel = t.schema.replace(".", "_") + "_" + t.name + "_" + name
 #lse:
 #abel = t.name + "_" + name

            # propagate name quoting rules for labels.
 #f getattr(name, "quote", None) is not None:
 #f isinstance(label, quoted_name):
 #abel.quote = name.quote
 #lse:
 #abel = quoted_name(label, name.quote)
 #lif getattr(t.name, "quote", None) is not None:
                # can't get this situation to occur, so let's
                # assert false on it for now
 #ssert not isinstance(label, quoted_name)
 #abel = quoted_name(label, t.name.quote)

 #f dedupe_on_key:
                # ensure the label name doesn't conflict with that of an
                # existing column.   note that this implies that any Column
                # must **not** set up its _label before its parent table has
                # all of its other Column objects set up.  There are several
                # tables in the test suite which will fail otherwise; example:
                # table "owner" has columns "name" and "owner_name".  Therefore
                # column owner.name cannot use the label "owner_name", it has
                # to be "owner_name_1".
 #f label in t.c:
 #label = label
 #ounter = 1
 #hile _label in t.c:
 #label = label + "_" + str(counter)
 #ounter += 1
 #abel = _label

 #eturn coercions.expect(roles.TruncatedLabelRole, label)

 #lse:
 #eturn name

 #ef _make_proxy(
 #elf,
 #electable,
 #ame=None,
 #ame_is_truncatable=False,
 #isallow_is_literal=False,
 #*kw
 #:
        # the "is_literal" flag normally should never be propagated; a proxied
        # column is always a SQL identifier and never the actual expression
        # being evaluated. however, there is a case where the "is_literal" flag
        # might be used to allow the given identifier to have a fixed quoting
        # pattern already, so maintain the flag for the proxy unless a
        # :class:`.Label` object is creating the proxy.  See [ticket:4730].
 #s_literal = (
 #ot disallow_is_literal
 #nd self.is_literal
 #nd (
                # note this does not accommodate for quoted_name differences
                # right now
 #ame is None
 #r name == self.name
 #
 #
 # = self._constructor(
 #oercions.expect(roles.TruncatedLabelRole, name or self.name)
 #f name_is_truncatable
 #lse (name or self.name),
 #ype_=self.type,
 #selectable=selectable,
 #s_literal=is_literal,
 #
 #._propagate_attrs = selectable._propagate_attrs
 #f name is None:
 #.key = self.key
 #._proxies = [self]
 #f selectable._is_clone_of is not None:
 #._is_clone_of = selectable._is_clone_of.columns.get(c.key)
 #eturn c.key, c


class TableValuedColumn(NamedColumn):
 #_visit_name__ = "table_valued_column"

 #traverse_internals = [
 #"name", InternalTraversal.dp_anon_name),
 #"type", InternalTraversal.dp_type),
 #"scalar_alias", InternalTraversal.dp_clauseelement),
 #

 #ef __init__(self, scalar_alias, type_):
 #elf.scalar_alias = scalar_alias
 #elf.key = self.name = scalar_alias.name
 #elf.type = type_

 #ef _copy_internals(self, clone=_clone, **kw):
 #elf.scalar_alias = clone(self.scalar_alias, **kw)
 #elf.key = self.name = self.scalar_alias.name

 #property
 #ef _from_objects(self):
 #eturn [self.scalar_alias]


class CollationClause(ColumnElement):
 #_visit_name__ = "collation"

 #traverse_internals = [("collation", InternalTraversal.dp_string)]

 #ef __init__(self, collation):
 #elf.collation = collation


class _IdentifiedClause(Executable, ClauseElement):

 #_visit_name__ = "identified"
 #execution_options = Executable._execution_options.union(
 #"autocommit": False}
 #

 #ef __init__(self, ident):
 #elf.ident = ident


class SavepointClause(_IdentifiedClause):
 #_visit_name__ = "savepoint"


class RollbackToSavepointClause(_IdentifiedClause):
 #_visit_name__ = "rollback_to_savepoint"


class ReleaseSavepointClause(_IdentifiedClause):
 #_visit_name__ = "release_savepoint"


class quoted_name(util.MemoizedSlots, util.text_type):
 #""Represent a SQL identifier combined with quoting preferences.

 #class:`.quoted_name` is a Python unicode/str subclass which
 #epresents a particular identifier name along with a
 #`quote`` flag.  This ``quote`` flag, when set to
 #`True`` or ``False``, overrides automatic quoting behavior
 #or this identifier in order to either unconditionally quote
 #r to not quote the name.  If left at its default of ``None``,
 #uoting behavior is applied to the identifier on a per-backend basis
 #ased on an examination of the token itself.

 # :class:`.quoted_name` object with ``quote=True`` is also
 #revented from being modified in the case of a so-called
 #name normalize" option.  Certain database backends, such as
 #racle, Firebird, and DB2 "normalize" case-insensitive names
 #s uppercase.  The SQLAlchemy dialects for these backends
 #onvert from SQLAlchemy's lower-case-means-insensitive convention
 #o the upper-case-means-insensitive conventions of those backends.
 #he ``quote=True`` flag here will prevent this conversion from occurring
 #o support an identifier that's quoted as all lower case against
 #uch a backend.

 #he :class:`.quoted_name` object is normally created automatically
 #hen specifying the name for key schema constructs such as
 #class:`_schema.Table`, :class:`_schema.Column`, and others.
 #he class can also be
 #assed explicitly as the name to any function that receives a name which
 #an be quoted.  Such as to use the :meth:`_engine.Engine.has_table`
 #ethod with
 #n unconditionally quoted name::

 #rom sqlalchemy import create_engine
 #rom sqlalchemy.sql import quoted_name

 #ngine = create_engine("oracle+cx_oracle://some_dsn")
 #ngine.has_table(quoted_name("some_table", True))

 #he above logic will run the "has table" logic against the Oracle backend,
 #assing the name exactly as ``"some_table"`` without converting to
 #pper case.

 #. versionadded:: 0.9.0

 #. versionchanged:: 1.2 The :class:`.quoted_name` construct is now
 #mportable from ``sqlalchemy.sql``, in addition to the previous
 #ocation of ``sqlalchemy.sql.elements``.

 #""

 #_slots__ = "quote", "lower", "upper"

 #ef __new__(cls, value, quote):
 #f value is None:
 #eturn None
        # experimental - don't bother with quoted_name
        # if quote flag is None.  doesn't seem to make any dent
        # in performance however
        # elif not sprcls and quote is None:
        #   return value
 #lif isinstance(value, cls) and (
 #uote is None or value.quote == quote
 #:
 #eturn value
 #elf = super(quoted_name, cls).__new__(cls, value)

 #elf.quote = quote
 #eturn self

 #ef __reduce__(self):
 #eturn quoted_name, (util.text_type(self), self.quote)

 #ef _memoized_method_lower(self):
 #f self.quote:
 #eturn self
 #lse:
 #eturn util.text_type(self).lower()

 #ef _memoized_method_upper(self):
 #f self.quote:
 #eturn self
 #lse:
 #eturn util.text_type(self).upper()

 #ef __repr__(self):
 #f util.py2k:
 #ackslashed = self.encode("ascii", "backslashreplace")
 #f not util.py2k:
 #ackslashed = backslashed.decode("ascii")
 #eturn "'%s'" % backslashed
 #lse:
 #eturn str.__repr__(self)


def _find_columns(clause):
 #""locate Column objects within the given expression."""

 #ols = util.column_set()
 #raverse(clause, {}, {"column": cols.add})
 #eturn cols


def _type_from_args(args):
 #or a in args:
 #f not a.type._isnull:
 #eturn a.type
 #lse:
 #eturn type_api.NULLTYPE


def _corresponding_column_or_error(fromclause, column, require_embedded=False):
 # = fromclause.corresponding_column(
 #olumn, require_embedded=require_embedded
 #
 #f c is None:
 #aise exc.InvalidRequestError(
 #Given column '%s', attached to table '%s', "
 #failed to locate a corresponding column from table '%s'"
 # (column, getattr(column, "table", None), fromclause.description)
 #
 #eturn c


class AnnotatedColumnElement(Annotated):
 #ef __init__(self, element, values):
 #nnotated.__init__(self, element, values)
 #or attr in (
 #comparator",
 #_proxy_key",
 #_tq_key_label",
 #_tq_label",
 #_non_anon_label",
 #:
 #elf.__dict__.pop(attr, None)
 #or attr in ("name", "key", "table"):
 #f self.__dict__.get(attr, False) is None:
 #elf.__dict__.pop(attr)

 #ef _with_annotations(self, values):
 #lone = super(AnnotatedColumnElement, self)._with_annotations(values)
 #lone.__dict__.pop("comparator", None)
 #eturn clone

 #util.memoized_property
 #ef name(self):
 #""pull 'name' from parent, if not present"""
 #eturn self._Annotated__element.name

 #util.memoized_property
 #ef table(self):
 #""pull 'table' from parent, if not present"""
 #eturn self._Annotated__element.table

 #util.memoized_property
 #ef key(self):
 #""pull 'key' from parent, if not present"""
 #eturn self._Annotated__element.key

 #util.memoized_property
 #ef info(self):
 #eturn self._Annotated__element.info

 #util.memoized_property
 #ef _anon_name_label(self):
 #eturn self._Annotated__element._anon_name_label


class _truncated_label(quoted_name):
 #""A unicode subclass used to identify symbolic "
 #names that may require truncation."""

 #_slots__ = ()

 #ef __new__(cls, value, quote=None):
 #uote = getattr(value, "quote", quote)
        # return super(_truncated_label, cls).__new__(cls, value, quote, True)
 #eturn super(_truncated_label, cls).__new__(cls, value, quote)

 #ef __reduce__(self):
 #eturn self.__class__, (util.text_type(self), self.quote)

 #ef apply_map(self, map_):
 #eturn self


class conv(_truncated_label):
 #""Mark a string indicating that a name has already been converted
 #y a naming convention.

 #his is a string subclass that indicates a name that should not be
 #ubject to any further naming conventions.

 #.g. when we create a :class:`.Constraint` using a naming convention
 #s follows::

 # = MetaData(naming_convention={
 #ck": "ck_%(table_name)s_%(constraint_name)s"
 #)
 # = Table('t', m, Column('x', Integer),
 #heckConstraint('x > 5', name='x5'))

 #he name of the above constraint will be rendered as ``"ck_t_x5"``.
 #hat is, the existing name ``x5`` is used in the naming convention as the
 #`constraint_name`` token.

 #n some situations, such as in migration scripts, we may be rendering
 #he above :class:`.CheckConstraint` with a name that's already been
 #onverted.  In order to make sure the name isn't double-modified, the
 #ew name is applied using the :func:`_schema.conv` marker.  We can
 #se this explicitly as follows::


 # = MetaData(naming_convention={
 #ck": "ck_%(table_name)s_%(constraint_name)s"
 #)
 # = Table('t', m, Column('x', Integer),
 #heckConstraint('x > 5', name=conv('ck_t_x5')))

 #here above, the :func:`_schema.conv` marker indicates that the constraint
 #ame here is final, and the name will render as ``"ck_t_x5"`` and not
 #`"ck_t_ck_t_x5"``

 #. versionadded:: 0.9.4

 #. seealso::

 #ref:`constraint_naming_conventions`

 #""

 #_slots__ = ()


_NONE_NAME = util.symbol("NONE_NAME")
"""indicate a 'deferred' name that was ultimately the value None."""

# for backwards compatibility in case
# someone is re-implementing the
# _truncated_identifier() sequence in a custom
# compiler
_generated_label = _truncated_label


class _anonymous_label(_truncated_label):
 #""A unicode subclass used to identify anonymously
 #enerated names."""

 #_slots__ = ()

 #classmethod
 #ef safe_construct(
 #ls, seed, body, enclosing_label=None, sanitize_key=False
 #:

 #f sanitize_key:
 #ody = re.sub(r"[%\(\) \$]+", "_", body).strip("_")

 #abel = "%%(%d %s)s" % (seed, body.replace("%", "%%"))
 #f enclosing_label:
 #abel = "%s%s" % (enclosing_label, label)

 #eturn _anonymous_label(label)

 #ef __add__(self, other):
 #f "%" in other and not isinstance(other, _anonymous_label):
 #ther = util.text_type(other).replace("%", "%%")
 #lse:
 #ther = util.text_type(other)

 #eturn _anonymous_label(
 #uoted_name(
 #til.text_type.__add__(self, other),
 #elf.quote,
 #
 #

 #ef __radd__(self, other):
 #f "%" in other and not isinstance(other, _anonymous_label):
 #ther = util.text_type(other).replace("%", "%%")
 #lse:
 #ther = util.text_type(other)

 #eturn _anonymous_label(
 #uoted_name(
 #til.text_type.__add__(other, self),
 #elf.quote,
 #
 #

 #ef apply_map(self, map_):
 #f self.quote is not None:
            # preserve quoting only if necessary
 #eturn quoted_name(self % map_, self.quote)
 #lse:
            # else skip the constructor call
 #eturn self % map_
