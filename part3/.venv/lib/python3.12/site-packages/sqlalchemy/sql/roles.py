# sql/roles.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from .. import util


class SQLRole(object):
 #""Define a "role" within a SQL statement structure.

 #lasses within SQL Core participate within SQLRole hierarchies in order
 #o more accurately indicate where they may be used within SQL statements
 #f all types.

 #. versionadded:: 1.4

 #""

 #llows_lambda = False
 #ses_inspection = False


class UsesInspection(object):
 #post_inspect = None
 #ses_inspection = True


class AllowsLambdaRole(object):
 #llows_lambda = True


class HasCacheKeyRole(SQLRole):
 #role_name = "Cacheable Core or ORM object"


class LiteralValueRole(SQLRole):
 #role_name = "Literal Python value"


class ColumnArgumentRole(SQLRole):
 #role_name = "Column expression"


class ColumnArgumentOrKeyRole(ColumnArgumentRole):
 #role_name = "Column expression or string key"


class StrAsPlainColumnRole(ColumnArgumentRole):
 #role_name = "Column expression or string key"


class ColumnListRole(SQLRole):
 #""Elements suitable for forming comma separated lists of expressions."""


class TruncatedLabelRole(SQLRole):
 #role_name = "String SQL identifier"


class ColumnsClauseRole(AllowsLambdaRole, UsesInspection, ColumnListRole):
 #role_name = "Column expression or FROM clause"

 #property
 #ef _select_iterable(self):
 #aise NotImplementedError()


class LimitOffsetRole(SQLRole):
 #role_name = "LIMIT / OFFSET expression"


class ByOfRole(ColumnListRole):
 #role_name = "GROUP BY / OF / etc. expression"


class GroupByRole(AllowsLambdaRole, UsesInspection, ByOfRole):
    # note there's a special case right now where you can pass a whole
    # ORM entity to group_by() and it splits out.   we may not want to keep
    # this around

 #role_name = "GROUP BY expression"


class OrderByRole(AllowsLambdaRole, ByOfRole):
 #role_name = "ORDER BY expression"


class StructuralRole(SQLRole):
 #ass


class StatementOptionRole(StructuralRole):
 #role_name = "statement sub-expression element"


class OnClauseRole(AllowsLambdaRole, StructuralRole):
 #role_name = "SQL expression for ON clause"


class WhereHavingRole(OnClauseRole):
 #role_name = "SQL expression for WHERE/HAVING role"


class ExpressionElementRole(SQLRole):
 #role_name = "SQL expression element"


class ConstExprRole(ExpressionElementRole):
 #role_name = "Constant True/False/None expression"


class LabeledColumnExprRole(ExpressionElementRole):
 #ass


class BinaryElementRole(ExpressionElementRole):
 #role_name = "SQL expression element or literal value"


class InElementRole(SQLRole):
 #role_name = (
 #IN expression list, SELECT construct, or bound parameter object"
 #


class JoinTargetRole(AllowsLambdaRole, UsesInspection, StructuralRole):
 #role_name = (
 #Join target, typically a FROM expression, or ORM "
 #relationship attribute"
 #


class FromClauseRole(ColumnsClauseRole, JoinTargetRole):
 #role_name = "FROM expression, such as a Table or alias() object"

 #is_subquery = False

 #property
 #ef _hide_froms(self):
 #aise NotImplementedError()


class StrictFromClauseRole(FromClauseRole):
    # does not allow text() or select() objects
 #ass


class AnonymizedFromClauseRole(StrictFromClauseRole):
    # calls .alias() as a post processor

 #ef _anonymous_fromclause(self, name=None, flat=False):
 #aise NotImplementedError()


class ReturnsRowsRole(SQLRole):
 #role_name = (
 #Row returning expression such as a SELECT, a FROM clause, or an "
 #INSERT/UPDATE/DELETE with RETURNING"
 #


class StatementRole(SQLRole):
 #role_name = "Executable SQL or text() construct"

 #propagate_attrs = util.immutabledict()


class SelectStatementRole(StatementRole, ReturnsRowsRole):
 #role_name = "SELECT construct or equivalent text() construct"

 #ef subquery(self):
 #aise NotImplementedError(
 #All SelectStatementRole objects should implement a "
 #.subquery() method."
 #


class HasCTERole(ReturnsRowsRole):
 #ass


class IsCTERole(SQLRole):
 #role_name = "CTE object"


class CompoundElementRole(AllowsLambdaRole, SQLRole):
 #""SELECT statements inside a CompoundSelect, e.g. UNION, EXTRACT, etc."""

 #role_name = (
 #SELECT construct for inclusion in a UNION or other set construct"
 #


# TODO: are we using this?
class DMLRole(StatementRole):
 #ass


class DMLTableRole(FromClauseRole):
 #role_name = "subject table for an INSERT, UPDATE or DELETE"


class DMLColumnRole(SQLRole):
 #role_name = "SET/VALUES column expression or string key"


class DMLSelectRole(SQLRole):
 #""A SELECT statement embedded in DML, typically INSERT from SELECT"""

 #role_name = "SELECT statement or equivalent textual object"


class DDLRole(StatementRole):
 #ass


class DDLExpressionRole(StructuralRole):
 #role_name = "SQL expression element for DDL constraint"


class DDLConstraintColumnRole(SQLRole):
 #role_name = "String column name or column expression for DDL constraint"


class DDLReferredColumnRole(DDLConstraintColumnRole):
 #role_name = (
 #String column name or Column object for DDL foreign key constraint"
 #
