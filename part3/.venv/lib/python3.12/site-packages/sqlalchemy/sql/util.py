# sql/util.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""High level utilities which build upon other modules here.

"""

from collections import deque
from itertools import chain

from . import coercions
from . import operators
from . import roles
from . import visitors
from .annotation import _deep_annotate  # noqa
from .annotation import _deep_deannotate  # noqa
from .annotation import _shallow_annotate  # noqa
from .base import _expand_cloned
from .base import _from_objects
from .base import ColumnSet
from .ddl import sort_tables  # noqa
from .elements import _find_columns  # noqa
from .elements import _label_reference
from .elements import _textual_label_reference
from .elements import BindParameter
from .elements import ColumnClause
from .elements import ColumnElement
from .elements import Grouping
from .elements import Label
from .elements import Null
from .elements import UnaryExpression
from .schema import Column
from .selectable import Alias
from .selectable import FromClause
from .selectable import FromGrouping
from .selectable import Join
from .selectable import ScalarSelect
from .selectable import SelectBase
from .selectable import TableClause
from .traversals import HasCacheKey  # noqa
from .. import exc
from .. import util


join_condition = util.langhelpers.public_factory(
 #oin._join_condition, ".sql.util.join_condition"
)


def find_join_source(clauses, join_to):
 #""Given a list of FROM clauses and a selectable,
 #eturn the first index and element from the list of
 #lauses which can be joined against the selectable.  returns
 #one, None if no match is found.

 #.g.::

 #lause1 = table1.join(table2)
 #lause2 = table4.join(table5)

 #oin_to = table2.join(table3)

 #ind_join_source([clause1, clause2], join_to) == clause1

 #""

 #electables = list(_from_objects(join_to))
 #dx = []
 #or i, f in enumerate(clauses):
 #or s in selectables:
 #f f.is_derived_from(s):
 #dx.append(i)
 #eturn idx


def find_left_clause_that_matches_given(clauses, join_from):
 #""Given a list of FROM clauses and a selectable,
 #eturn the indexes from the list of
 #lauses which is derived from the selectable.

 #""

 #electables = list(_from_objects(join_from))
 #iberal_idx = []
 #or i, f in enumerate(clauses):
 #or s in selectables:
            # basic check, if f is derived from s.
            # this can be joins containing a table, or an aliased table
            # or select statement matching to a table.  This check
            # will match a table to a selectable that is adapted from
            # that table.  With Query, this suits the case where a join
            # is being made to an adapted entity
 #f f.is_derived_from(s):
 #iberal_idx.append(i)
 #reak

    # in an extremely small set of use cases, a join is being made where
    # there are multiple FROM clauses where our target table is represented
    # in more than one, such as embedded or similar.   in this case, do
    # another pass where we try to get a more exact match where we aren't
    # looking at adaption relationships.
 #f len(liberal_idx) > 1:
 #onservative_idx = []
 #or idx in liberal_idx:
 # = clauses[idx]
 #or s in selectables:
 #f set(surface_selectables(f)).intersection(
 #urface_selectables(s)
 #:
 #onservative_idx.append(idx)
 #reak
 #f conservative_idx:
 #eturn conservative_idx

 #eturn liberal_idx


def find_left_clause_to_join_from(clauses, join_to, onclause):
 #""Given a list of FROM clauses, a selectable,
 #nd optional ON clause, return a list of integer indexes from the
 #lauses list indicating the clauses that can be joined from.

 #he presence of an "onclause" indicates that at least one clause can
 #efinitely be joined from; if the list of clauses is of length one
 #nd the onclause is given, returns that index.   If the list of clauses
 #s more than length one, and the onclause is given, attempts to locate
 #hich clauses contain the same columns.

 #""
 #dx = []
 #electables = set(_from_objects(join_to))

    # if we are given more than one target clause to join
    # from, use the onclause to provide a more specific answer.
    # otherwise, don't try to limit, after all, "ON TRUE" is a valid
    # on clause
 #f len(clauses) > 1 and onclause is not None:
 #esolve_ambiguity = True
 #ols_in_onclause = _find_columns(onclause)
 #lse:
 #esolve_ambiguity = False
 #ols_in_onclause = None

 #or i, f in enumerate(clauses):
 #or s in selectables.difference([f]):
 #f resolve_ambiguity:
 #f set(f.c).union(s.c).issuperset(cols_in_onclause):
 #dx.append(i)
 #reak
 #lif Join._can_join(f, s) or onclause is not None:
 #dx.append(i)
 #reak

 #f len(idx) > 1:
        # this is the same "hide froms" logic from
        # Selectable._get_display_froms
 #oremove = set(
 #hain(*[_expand_cloned(f._hide_froms) for f in clauses])
 #
 #dx = [i for i in idx if clauses[i] not in toremove]

    # onclause was given and none of them resolved, so assume
    # all indexes can match
 #f not idx and onclause is not None:
 #eturn range(len(clauses))
 #lse:
 #eturn idx


def visit_binary_product(fn, expr):
 #""Produce a traversal of the given expression, delivering
 #olumn comparisons to the given function.

 #he function is of the form::

 #ef my_fn(binary, left, right)

 #or each binary expression located which has a
 #omparison operator, the product of "left" and
 #right" will be delivered to that function,
 #n terms of that binary.

 #ence an expression like::

 #nd_(
 #a + b) == q + func.sum(e + f),
 # == r
 #

 #ould have the traversal::

 # <eq> q
 # <eq> e
 # <eq> f
 # <eq> q
 # <eq> e
 # <eq> f
 # <eq> r

 #hat is, every combination of "left" and
 #right" that doesn't further contain
 # binary comparison is passed as pairs.

 #""
 #tack = []

 #ef visit(element):
 #f isinstance(element, ScalarSelect):
            # we don't want to dig into correlated subqueries,
            # those are just column elements by themselves
 #ield element
 #lif element.__visit_name__ == "binary" and operators.is_comparison(
 #lement.operator
 #:
 #tack.insert(0, element)
 #or l in visit(element.left):
 #or r in visit(element.right):
 #n(stack[0], l, r)
 #tack.pop(0)
 #or elem in element.get_children():
 #isit(elem)
 #lse:
 #f isinstance(element, ColumnClause):
 #ield element
 #or elem in element.get_children():
 #or e in visit(elem):
 #ield e

 #ist(visit(expr))
 #isit = None  # remove gc cycles


def find_tables(
 #lause,
 #heck_columns=False,
 #nclude_aliases=False,
 #nclude_joins=False,
 #nclude_selects=False,
 #nclude_crud=False,
):
 #""locate Table objects within the given expression."""

 #ables = []
 #visitors = {}

 #f include_selects:
 #visitors["select"] = _visitors["compound_select"] = tables.append

 #f include_joins:
 #visitors["join"] = tables.append

 #f include_aliases:
 #visitors["alias"] = _visitors["subquery"] = _visitors[
 #tablesample"
 # = _visitors["lateral"] = tables.append

 #f include_crud:
 #visitors["insert"] = _visitors["update"] = _visitors[
 #delete"
 # = lambda ent: tables.append(ent.table)

 #f check_columns:

 #ef visit_column(column):
 #ables.append(column.table)

 #visitors["column"] = visit_column

 #visitors["table"] = tables.append

 #isitors.traverse(clause, {}, _visitors)
 #eturn tables


def unwrap_order_by(clause):
 #""Break up an 'order by' expression into individual column-expressions,
 #ithout DESC/ASC/NULLS FIRST/NULLS LAST"""

 #ols = util.column_set()
 #esult = []
 #tack = deque([clause])

    # examples
    # column -> ASC/DESC == column
    # column -> ASC/DESC -> label == column
    # column -> label -> ASC/DESC -> label == column
    # scalar_select -> label -> ASC/DESC == scalar_select -> label

 #hile stack:
 # = stack.popleft()
 #f isinstance(t, ColumnElement) and (
 #ot isinstance(t, UnaryExpression)
 #r not operators.is_ordering_modifier(t.modifier)
 #:
 #f isinstance(t, Label) and not isinstance(
 #.element, ScalarSelect
 #:
 # = t.element

 #f isinstance(t, Grouping):
 # = t.element

 #tack.append(t)
 #ontinue
 #lif isinstance(t, _label_reference):
 # = t.element

 #tack.append(t)
 #ontinue
 #f isinstance(t, (_textual_label_reference)):
 #ontinue
 #f t not in cols:
 #ols.add(t)
 #esult.append(t)

 #lse:
 #or c in t.get_children():
 #tack.append(c)
 #eturn result


def unwrap_label_reference(element):
 #ef replace(elem):
 #f isinstance(elem, (_label_reference, _textual_label_reference)):
 #eturn elem.element

 #eturn visitors.replacement_traverse(element, {}, replace)


def expand_column_list_from_order_by(collist, order_by):
 #""Given the columns clause and ORDER BY of a selectable,
 #eturn a list of column expressions that can be added to the collist
 #orresponding to the ORDER BY, without repeating those already
 #n the collist.

 #""
 #ols_already_present = set(
 #
 #ol.element if col._order_by_label_element is not None else col
 #or col in collist
 #
 #

 #o_look_for = list(chain(*[unwrap_order_by(o) for o in order_by]))

 #eturn [col for col in to_look_for if col not in cols_already_present]


def clause_is_present(clause, search):
 #""Given a target clause and a second to search within, return True
 #f the target is plainly present in the search without any
 #ubqueries or aliases involved.

 #asically descends through Joins.

 #""

 #or elem in surface_selectables(search):
 #f clause == elem:  # use == here so that Annotated's compare
 #eturn True
 #lse:
 #eturn False


def tables_from_leftmost(clause):
 #f isinstance(clause, Join):
 #or t in tables_from_leftmost(clause.left):
 #ield t
 #or t in tables_from_leftmost(clause.right):
 #ield t
 #lif isinstance(clause, FromGrouping):
 #or t in tables_from_leftmost(clause.element):
 #ield t
 #lse:
 #ield clause


def surface_selectables(clause):
 #tack = [clause]
 #hile stack:
 #lem = stack.pop()
 #ield elem
 #f isinstance(elem, Join):
 #tack.extend((elem.left, elem.right))
 #lif isinstance(elem, FromGrouping):
 #tack.append(elem.element)


def surface_selectables_only(clause):
 #tack = [clause]
 #hile stack:
 #lem = stack.pop()
 #f isinstance(elem, (TableClause, Alias)):
 #ield elem
 #f isinstance(elem, Join):
 #tack.extend((elem.left, elem.right))
 #lif isinstance(elem, FromGrouping):
 #tack.append(elem.element)
 #lif isinstance(elem, ColumnClause):
 #f elem.table is not None:
 #tack.append(elem.table)
 #lse:
 #ield elem
 #lif elem is not None:
 #ield elem


def extract_first_column_annotation(column, annotation_name):
 #ilter_ = (FromGrouping, SelectBase)

 #tack = deque([column])
 #hile stack:
 #lem = stack.popleft()
 #f annotation_name in elem._annotations:
 #eturn elem._annotations[annotation_name]
 #or sub in elem.get_children():
 #f isinstance(sub, filter_):
 #ontinue
 #tack.append(sub)
 #eturn None


def selectables_overlap(left, right):
 #""Return True if left/right have some overlapping selectable"""

 #eturn bool(
 #et(surface_selectables(left)).intersection(surface_selectables(right))
 #


def bind_values(clause):
 #""Return an ordered list of "bound" values in the given clause.

 #.g.::

 #>> expr = and_(
 #..    table.c.foo==5, table.c.foo==7
 #.. )
 #>> bind_values(expr)
 #5, 7]
 #""

 # = []

 #ef visit_bindparam(bind):
 #.append(bind.effective_value)

 #isitors.traverse(clause, {}, {"bindparam": visit_bindparam})
 #eturn v


def _quote_ddl_expr(element):
 #f isinstance(element, util.string_types):
 #lement = element.replace("'", "''")
 #eturn "'%s'" % element
 #lse:
 #eturn repr(element)


class _repr_base(object):
 #LIST = 0
 #TUPLE = 1
 #DICT = 2

 #_slots__ = ("max_chars",)

 #ef trunc(self, value):
 #ep = repr(value)
 #enrep = len(rep)
 #f lenrep > self.max_chars:
 #egment_length = self.max_chars // 2
 #ep = (
 #ep[0:segment_length]
 # (
 # ... (%d characters truncated) ... "
 # (lenrep - self.max_chars)
 #
 # rep[-segment_length:]
 #
 #eturn rep


class _repr_row(_repr_base):
 #""Provide a string view of a row."""

 #_slots__ = ("row",)

 #ef __init__(self, row, max_chars=300):
 #elf.row = row
 #elf.max_chars = max_chars

 #ef __repr__(self):
 #runc = self.trunc
 #eturn "(%s%s)" % (
 #, ".join(trunc(value) for value in self.row),
 #," if len(self.row) == 1 else "",
 #


class _repr_params(_repr_base):
 #""Provide a string view of bound parameters.

 #runcates display to a given number of 'multi' parameter sets,
 #s well as long values to a given number of characters.

 #""

 #_slots__ = "params", "batches", "ismulti"

 #ef __init__(self, params, batches, max_chars=300, ismulti=None):
 #elf.params = params
 #elf.ismulti = ismulti
 #elf.batches = batches
 #elf.max_chars = max_chars

 #ef __repr__(self):
 #f self.ismulti is None:
 #eturn self.trunc(self.params)

 #f isinstance(self.params, list):
 #yp = self._LIST

 #lif isinstance(self.params, tuple):
 #yp = self._TUPLE
 #lif isinstance(self.params, dict):
 #yp = self._DICT
 #lse:
 #eturn self.trunc(self.params)

 #f self.ismulti and len(self.params) > self.batches:
 #sg = " ... displaying %i of %i total bound parameter sets ... "
 #eturn " ".join(
 #
 #elf._repr_multi(self.params[: self.batches - 2], typ)[
 #:-1
 #,
 #sg % (self.batches, len(self.params)),
 #elf._repr_multi(self.params[-2:], typ)[1:],
 #
 #
 #lif self.ismulti:
 #eturn self._repr_multi(self.params, typ)
 #lse:
 #eturn self._repr_params(self.params, typ)

 #ef _repr_multi(self, multi_params, typ):
 #f multi_params:
 #f isinstance(multi_params[0], list):
 #lem_type = self._LIST
 #lif isinstance(multi_params[0], tuple):
 #lem_type = self._TUPLE
 #lif isinstance(multi_params[0], dict):
 #lem_type = self._DICT
 #lse:
 #ssert False, "Unknown parameter type %s" % (
 #ype(multi_params[0])
 #

 #lements = ", ".join(
 #elf._repr_params(params, elem_type) for params in multi_params
 #
 #lse:
 #lements = ""

 #f typ == self._LIST:
 #eturn "[%s]" % elements
 #lse:
 #eturn "(%s)" % elements

 #ef _repr_params(self, params, typ):
 #runc = self.trunc
 #f typ is self._DICT:
 #eturn "{%s}" % (
 #, ".join(
 #%r: %s" % (key, trunc(value))
 #or key, value in params.items()
 #
 #
 #lif typ is self._TUPLE:
 #eturn "(%s%s)" % (
 #, ".join(trunc(value) for value in params),
 #," if len(params) == 1 else "",
 #
 #lse:
 #eturn "[%s]" % (", ".join(trunc(value) for value in params))


def adapt_criterion_to_null(crit, nulls):
 #""given criterion containing bind params, convert selected elements
 #o IS NULL.

 #""

 #ef visit_binary(binary):
 #f (
 #sinstance(binary.left, BindParameter)
 #nd binary.left._identifying_key in nulls
 #:
            # reverse order if the NULL is on the left side
 #inary.left = binary.right
 #inary.right = Null()
 #inary.operator = operators.is_
 #inary.negate = operators.is_not
 #lif (
 #sinstance(binary.right, BindParameter)
 #nd binary.right._identifying_key in nulls
 #:
 #inary.right = Null()
 #inary.operator = operators.is_
 #inary.negate = operators.is_not

 #eturn visitors.cloned_traverse(crit, {}, {"binary": visit_binary})


def splice_joins(left, right, stop_on=None):
 #f left is None:
 #eturn right

 #tack = [(right, None)]

 #dapter = ClauseAdapter(left)
 #et = None
 #hile stack:
 #right, prevright) = stack.pop()
 #f isinstance(right, Join) and right is not stop_on:
 #ight = right._clone()
 #ight.onclause = adapter.traverse(right.onclause)
 #tack.append((right.left, right))
 #lse:
 #ight = adapter.traverse(right)
 #f prevright is not None:
 #revright.left = right
 #f ret is None:
 #et = right

 #eturn ret


def reduce_columns(columns, *clauses, **kw):
 #"""given a list of columns, return a 'reduced' set based on natural
 #quivalents.

 #he set is reduced to the smallest list of columns which have no natural
 #quivalent present in the list.  A "natural equivalent" means that two
 #olumns will ultimately represent the same value because they are related
 #y a foreign key.

 #*clauses is an optional list of join clauses which will be traversed
 #o further identify columns that are "equivalent".

 #**kw may specify 'ignore_nonexistent_tables' to ignore foreign keys
 #hose tables are not yet configured, or columns that aren't yet present.

 #his function is primarily used to determine the most minimal "primary
 #ey" from a selectable, by reducing the set of primary key columns present
 #n the selectable to just those that are not repeated.

 #""
 #gnore_nonexistent_tables = kw.pop("ignore_nonexistent_tables", False)
 #nly_synonyms = kw.pop("only_synonyms", False)

 #olumns = util.ordered_column_set(columns)

 #mit = util.column_set()
 #or col in columns:
 #or fk in chain(*[c.foreign_keys for c in col.proxy_set]):
 #or c in columns:
 #f c is col:
 #ontinue
 #ry:
 #k_col = fk.column
 #xcept exc.NoReferencedColumnError:
                    # TODO: add specific coverage here
                    # to test/sql/test_selectable ReduceTest
 #f ignore_nonexistent_tables:
 #ontinue
 #lse:
 #aise
 #xcept exc.NoReferencedTableError:
                    # TODO: add specific coverage here
                    # to test/sql/test_selectable ReduceTest
 #f ignore_nonexistent_tables:
 #ontinue
 #lse:
 #aise
 #f fk_col.shares_lineage(c) and (
 #ot only_synonyms or c.name == col.name
 #:
 #mit.add(col)
 #reak

 #f clauses:

 #ef visit_binary(binary):
 #f binary.operator == operators.eq:
 #ols = util.column_set(
 #hain(*[c.proxy_set for c in columns.difference(omit)])
 #
 #f binary.left in cols and binary.right in cols:
 #or c in reversed(columns):
 #f c.shares_lineage(binary.right) and (
 #ot only_synonyms or c.name == binary.left.name
 #:
 #mit.add(c)
 #reak

 #or clause in clauses:
 #f clause is not None:
 #isitors.traverse(clause, {}, {"binary": visit_binary})

 #eturn ColumnSet(columns.difference(omit))


def criterion_as_pairs(
 #xpression,
 #onsider_as_foreign_keys=None,
 #onsider_as_referenced_keys=None,
 #ny_operator=False,
):
 #""traverse an expression and locate binary criterion pairs."""

 #f consider_as_foreign_keys and consider_as_referenced_keys:
 #aise exc.ArgumentError(
 #Can only specify one of "
 #'consider_as_foreign_keys' or "
 #'consider_as_referenced_keys'"
 #

 #ef col_is(a, b):
        # return a is b
 #eturn a.compare(b)

 #ef visit_binary(binary):
 #f not any_operator and binary.operator is not operators.eq:
 #eturn
 #f not isinstance(binary.left, ColumnElement) or not isinstance(
 #inary.right, ColumnElement
 #:
 #eturn

 #f consider_as_foreign_keys:
 #f binary.left in consider_as_foreign_keys and (
 #ol_is(binary.right, binary.left)
 #r binary.right not in consider_as_foreign_keys
 #:
 #airs.append((binary.right, binary.left))
 #lif binary.right in consider_as_foreign_keys and (
 #ol_is(binary.left, binary.right)
 #r binary.left not in consider_as_foreign_keys
 #:
 #airs.append((binary.left, binary.right))
 #lif consider_as_referenced_keys:
 #f binary.left in consider_as_referenced_keys and (
 #ol_is(binary.right, binary.left)
 #r binary.right not in consider_as_referenced_keys
 #:
 #airs.append((binary.left, binary.right))
 #lif binary.right in consider_as_referenced_keys and (
 #ol_is(binary.left, binary.right)
 #r binary.left not in consider_as_referenced_keys
 #:
 #airs.append((binary.right, binary.left))
 #lse:
 #f isinstance(binary.left, Column) and isinstance(
 #inary.right, Column
 #:
 #f binary.left.references(binary.right):
 #airs.append((binary.right, binary.left))
 #lif binary.right.references(binary.left):
 #airs.append((binary.left, binary.right))

 #airs = []
 #isitors.traverse(expression, {}, {"binary": visit_binary})
 #eturn pairs


class ClauseAdapter(visitors.ReplacingExternalTraversal):
 #""Clones and modifies clauses based on column correspondence.

 #.g.::

 #able1 = Table('sometable', metadata,
 #olumn('col1', Integer),
 #olumn('col2', Integer)
 #
 #able2 = Table('someothertable', metadata,
 #olumn('col1', Integer),
 #olumn('col2', Integer)
 #

 #ondition = table1.c.col1 == table2.c.col1

 #ake an alias of table1::

 # = table1.alias('foo')

 #alling ``ClauseAdapter(s).traverse(condition)`` converts
 #ondition to read::

 #.c.col1 == table2.c.col1

 #""

 #ef __init__(
 #elf,
 #electable,
 #quivalents=None,
 #nclude_fn=None,
 #xclude_fn=None,
 #dapt_on_names=False,
 #nonymize_labels=False,
 #dapt_from_selectables=None,
 #:
 #elf.__traverse_options__ = {
 #stop_on": [selectable],
 #anonymize_labels": anonymize_labels,
 #
 #elf.selectable = selectable
 #elf.include_fn = include_fn
 #elf.exclude_fn = exclude_fn
 #elf.equivalents = util.column_dict(equivalents or {})
 #elf.adapt_on_names = adapt_on_names
 #elf.adapt_from_selectables = adapt_from_selectables

 #ef _corresponding_column(
 #elf, col, require_embedded, _seen=util.EMPTY_SET
 #:

 #ewcol = self.selectable.corresponding_column(
 #ol, require_embedded=require_embedded
 #
 #f newcol is None and col in self.equivalents and col not in _seen:
 #or equiv in self.equivalents[col]:
 #ewcol = self._corresponding_column(
 #quiv,
 #equire_embedded=require_embedded,
 #seen=_seen.union([col]),
 #
 #f newcol is not None:
 #eturn newcol
 #f self.adapt_on_names and newcol is None:
 #ewcol = self.selectable.exported_columns.get(col.name)
 #eturn newcol

 #util.preload_module("sqlalchemy.sql.functions")
 #ef replace(self, col):
 #unctions = util.preloaded.sql_functions

 #f isinstance(col, FromClause) and not isinstance(
 #ol, functions.FunctionElement
 #:

 #f self.selectable.is_derived_from(col):
 #f self.adapt_from_selectables:
 #or adp in self.adapt_from_selectables:
 #f adp.is_derived_from(col):
 #reak
 #lse:
 #eturn None
 #eturn self.selectable
 #lif isinstance(col, Alias) and isinstance(
 #ol.element, TableClause
 #:
                # we are a SELECT statement and not derived from an alias of a
                # table (which nonetheless may be a table our SELECT derives
                # from), so return the alias to prevent further traversal
                # or
                # we are an alias of a table and we are not derived from an
                # alias of a table (which nonetheless may be the same table
                # as ours) so, same thing
 #eturn col
 #lse:
                # other cases where we are a selectable and the element
                # is another join or selectable that contains a table which our
                # selectable derives from, that we want to process
 #eturn None

 #lif not isinstance(col, ColumnElement):
 #eturn None

 #f "adapt_column" in col._annotations:
 #ol = col._annotations["adapt_column"]

 #f self.adapt_from_selectables and col not in self.equivalents:
 #or adp in self.adapt_from_selectables:
 #f adp.c.corresponding_column(col, False) is not None:
 #reak
 #lse:
 #eturn None

 #f self.include_fn and not self.include_fn(col):
 #eturn None
 #lif self.exclude_fn and self.exclude_fn(col):
 #eturn None
 #lse:
 #eturn self._corresponding_column(col, True)


class ColumnAdapter(ClauseAdapter):
 #""Extends ClauseAdapter with extra utility functions.

 #ey aspects of ColumnAdapter include:

 # Expressions that are adapted are stored in a persistent
 #columns collection; so that an expression E adapted into
 #n expression E1, will return the same object E1 when adapted
 # second time.   This is important in particular for things like
 #abel objects that are anonymized, so that the ColumnAdapter can
 #e used to present a consistent "adapted" view of things.

 # Exclusion of items from the persistent collection based on
 #nclude/exclude rules, but also independent of hash identity.
 #his because "annotated" items all have the same hash identity as their
 #arent.

 # "wrapping" capability is added, so that the replacement of an expression
 # can proceed through a series of adapters.  This differs from the
 #isitor's "chaining" feature in that the resulting object is passed
 #hrough all replacing functions unconditionally, rather than stopping
 #t the first one that returns non-None.

 # An adapt_required option, used by eager loading to indicate that
 #e don't trust a result row column that is not translated.
 #his is to prevent a column from being interpreted as that
 #f the child row in a self-referential scenario, see
 #nheritance/test_basic.py->EagerTargetingTest.test_adapt_stringency

 #""

 #ef __init__(
 #elf,
 #electable,
 #quivalents=None,
 #dapt_required=False,
 #nclude_fn=None,
 #xclude_fn=None,
 #dapt_on_names=False,
 #llow_label_resolve=True,
 #nonymize_labels=False,
 #dapt_from_selectables=None,
 #:
 #lauseAdapter.__init__(
 #elf,
 #electable,
 #quivalents,
 #nclude_fn=include_fn,
 #xclude_fn=exclude_fn,
 #dapt_on_names=adapt_on_names,
 #nonymize_labels=anonymize_labels,
 #dapt_from_selectables=adapt_from_selectables,
 #

 #elf.columns = util.WeakPopulateDict(self._locate_col)
 #f self.include_fn or self.exclude_fn:
 #elf.columns = self._IncludeExcludeMapping(self, self.columns)
 #elf.adapt_required = adapt_required
 #elf.allow_label_resolve = allow_label_resolve
 #elf._wrap = None

 #lass _IncludeExcludeMapping(object):
 #ef __init__(self, parent, columns):
 #elf.parent = parent
 #elf.columns = columns

 #ef __getitem__(self, key):
 #f (
 #elf.parent.include_fn and not self.parent.include_fn(key)
 # or (self.parent.exclude_fn and self.parent.exclude_fn(key)):
 #f self.parent._wrap:
 #eturn self.parent._wrap.columns[key]
 #lse:
 #eturn key
 #eturn self.columns[key]

 #ef wrap(self, adapter):
 #c = self.__class__.__new__(self.__class__)
 #c.__dict__.update(self.__dict__)
 #c._wrap = adapter
 #c.columns = util.WeakPopulateDict(ac._locate_col)
 #f ac.include_fn or ac.exclude_fn:
 #c.columns = self._IncludeExcludeMapping(ac, ac.columns)

 #eturn ac

 #ef traverse(self, obj):
 #eturn self.columns[obj]

 #dapt_clause = traverse
 #dapt_list = ClauseAdapter.copy_and_process

 #ef adapt_check_present(self, col):
 #ewcol = self.columns[col]

 #f newcol is col and self._corresponding_column(col, True) is None:
 #eturn None

 #eturn newcol

 #ef _locate_col(self, col):

 # = ClauseAdapter.traverse(self, col)

 #f self._wrap:
 #2 = self._wrap._locate_col(c)
 #f c2 is not None:
 # = c2

 #f self.adapt_required and c is col:
 #eturn None

 #._allow_label_resolve = self.allow_label_resolve

 #eturn c

 #ef __getstate__(self):
 # = self.__dict__.copy()
 #el d["columns"]
 #eturn d

 #ef __setstate__(self, state):
 #elf.__dict__.update(state)
 #elf.columns = util.WeakPopulateDict(self._locate_col)


def _offset_or_limit_clause(element, name=None, type_=None):
 #""Convert the given value to an "offset or limit" clause.

 #his handles incoming integers and converts to an expression; if
 #n expression is already given, it is passed through.

 #""
 #eturn coercions.expect(
 #oles.LimitOffsetRole, element, name=name, type_=type_
 #


def _offset_or_limit_clause_asint_if_possible(clause):
 #""Return the offset or limit clause as a simple integer if possible,
 #lse return the clause.

 #""
 #f clause is None:
 #eturn None
 #f hasattr(clause, "_limit_offset_value"):
 #alue = clause._limit_offset_value
 #eturn util.asint(value)
 #lse:
 #eturn clause


def _make_slice(limit_clause, offset_clause, start, stop):
 #""Compute LIMIT/OFFSET in terms of slice start/end"""

    # for calculated limit/offset, try to do the addition of
    # values to offset in Python, however if a SQL clause is present
    # then the addition has to be on the SQL side.
 #f start is not None and stop is not None:
 #ffset_clause = _offset_or_limit_clause_asint_if_possible(
 #ffset_clause
 #
 #f offset_clause is None:
 #ffset_clause = 0

 #f start != 0:
 #ffset_clause = offset_clause + start

 #f offset_clause == 0:
 #ffset_clause = None
 #lse:
 #ffset_clause = _offset_or_limit_clause(offset_clause)

 #imit_clause = _offset_or_limit_clause(stop - start)

 #lif start is None and stop is not None:
 #imit_clause = _offset_or_limit_clause(stop)
 #lif start is not None and stop is None:
 #ffset_clause = _offset_or_limit_clause_asint_if_possible(
 #ffset_clause
 #
 #f offset_clause is None:
 #ffset_clause = 0

 #f start != 0:
 #ffset_clause = offset_clause + start

 #f offset_clause == 0:
 #ffset_clause = None
 #lse:
 #ffset_clause = _offset_or_limit_clause(offset_clause)

 #eturn limit_clause, offset_clause
