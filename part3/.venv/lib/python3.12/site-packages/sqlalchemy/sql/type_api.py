# sql/types_api.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Base types API.

"""


from . import operators
from .base import SchemaEventTarget
from .traversals import NO_CACHE
from .visitors import Traversible
from .visitors import TraversibleType
from .. import exc
from .. import util

# these are back-assigned by sqltypes.
BOOLEANTYPE = None
INTEGERTYPE = None
NULLTYPE = None
STRINGTYPE = None
MATCHTYPE = None
INDEXABLE = None
TABLEVALUE = None
_resolve_value_to_type = None


class TypeEngine(Traversible):
 #""The ultimate base class for all SQL datatypes.

 #ommon subclasses of :class:`.TypeEngine` include
 #class:`.String`, :class:`.Integer`, and :class:`.Boolean`.

 #or an overview of the SQLAlchemy typing system, see
 #ref:`types_toplevel`.

 #. seealso::

 #ref:`types_toplevel`

 #""

 #sqla_type = True
 #isnull = False
 #is_tuple_type = False
 #is_table_value = False
 #is_array = False
 #is_type_decorator = False

 #lass Comparator(operators.ColumnOperators):
 #""Base class for custom comparison operations defined at the
 #ype level.  See :attr:`.TypeEngine.comparator_factory`.


 #""

 #_slots__ = "expr", "type"

 #efault_comparator = None

 #ef __clause_element__(self):
 #eturn self.expr

 #ef __init__(self, expr):
 #elf.expr = expr
 #elf.type = expr.type

 #util.preload_module("sqlalchemy.sql.default_comparator")
 #ef operate(self, op, *other, **kwargs):
 #efault_comparator = util.preloaded.sql_default_comparator
 # = default_comparator.operator_lookup[op.__name__]
 #eturn o[0](self.expr, op, *(other + o[1:]), **kwargs)

 #util.preload_module("sqlalchemy.sql.default_comparator")
 #ef reverse_operate(self, op, other, **kwargs):
 #efault_comparator = util.preloaded.sql_default_comparator
 # = default_comparator.operator_lookup[op.__name__]
 #eturn o[0](self.expr, op, other, reverse=True, *o[1:], **kwargs)

 #ef _adapt_expression(self, op, other_comparator):
 #""evaluate the return type of <self> <op> <othertype>,
 #nd apply any adaptations to the given operator.

 #his method determines the type of a resulting binary expression
 #iven two source types and an operator.   For example, two
 #class:`_schema.Column` objects, both of the type
 #class:`.Integer`, will
 #roduce a :class:`.BinaryExpression` that also has the type
 #class:`.Integer` when compared via the addition (``+``) operator.
 #owever, using the addition operator with an :class:`.Integer`
 #nd a :class:`.Date` object will produce a :class:`.Date`, assuming
 #days delta" behavior by the database (in reality, most databases
 #ther than PostgreSQL don't accept this particular operation).

 #he method returns a tuple of the form <operator>, <type>.
 #he resulting operator and type will be those applied to the
 #esulting :class:`.BinaryExpression` as the final operator and the
 #ight-hand side of the expression.

 #ote that only a subset of operators make usage of
 #meth:`._adapt_expression`,
 #ncluding math operators and user-defined operators, but not
 #oolean comparison or special SQL keywords like MATCH or BETWEEN.

 #""

 #eturn op, self.type

 #ef __reduce__(self):
 #eturn _reconstitute_comparator, (self.expr,)

 #ashable = True
 #""Flag, if False, means values from this type aren't hashable.

 #sed by the ORM when uniquing result lists.

 #""

 #omparator_factory = Comparator
 #""A :class:`.TypeEngine.Comparator` class which will apply
 #o operations performed by owning :class:`_expression.ColumnElement`
 #bjects.

 #he :attr:`.comparator_factory` attribute is a hook consulted by
 #he core expression system when column and SQL expression operations
 #re performed.   When a :class:`.TypeEngine.Comparator` class is
 #ssociated with this attribute, it allows custom re-definition of
 #ll existing operators, as well as definition of new operators.
 #xisting operators include those provided by Python operator overloading
 #uch as :meth:`.operators.ColumnOperators.__add__` and
 #meth:`.operators.ColumnOperators.__eq__`,
 #hose provided as standard
 #ttributes of :class:`.operators.ColumnOperators` such as
 #meth:`.operators.ColumnOperators.like`
 #nd :meth:`.operators.ColumnOperators.in_`.

 #udimentary usage of this hook is allowed through simple subclassing
 #f existing types, or alternatively by using :class:`.TypeDecorator`.
 #ee the documentation section :ref:`types_operators` for examples.

 #""

 #ort_key_function = None
 #""A sorting function that can be passed as the key to sorted.

 #he default value of ``None`` indicates that the values stored by
 #his type are self-sorting.

 #. versionadded:: 1.3.8

 #""

 #hould_evaluate_none = False
 #""If True, the Python constant ``None`` is considered to be handled
 #xplicitly by this type.

 #he ORM uses this flag to indicate that a positive value of ``None``
 #s passed to the column in an INSERT statement, rather than omitting
 #he column from the INSERT statement which has the effect of firing
 #ff column-level defaults.   It also allows types which have special
 #ehavior for Python None, such as a JSON type, to indicate that
 #hey'd like to handle the None value explicitly.

 #o set this flag on an existing type, use the
 #meth:`.TypeEngine.evaluates_none` method.

 #. seealso::

 #meth:`.TypeEngine.evaluates_none`

 #. versionadded:: 1.1


 #""

 #ef evaluates_none(self):
 #""Return a copy of this type which has the :attr:`.should_evaluate_none`
 #lag set to True.

 #.g.::

 #able(
 #some_table', metadata,
 #olumn(
 #tring(50).evaluates_none(),
 #ullable=True,
 #erver_default='no value')
 #

 #he ORM uses this flag to indicate that a positive value of ``None``
 #s passed to the column in an INSERT statement, rather than omitting
 #he column from the INSERT statement which has the effect of firing
 #ff column-level defaults.   It also allows for types which have
 #pecial behavior associated with the Python None value to indicate
 #hat the value doesn't necessarily translate into SQL NULL; a
 #rime example of this is a JSON type which may wish to persist the
 #SON value ``'null'``.

 #n all cases, the actual NULL SQL value can be always be
 #ersisted in any column by using
 #he :obj:`_expression.null` SQL construct in an INSERT statement
 #r associated with an ORM-mapped attribute.

 #. note::

 #he "evaluates none" flag does **not** apply to a value
 #f ``None`` passed to :paramref:`_schema.Column.default` or
 #paramref:`_schema.Column.server_default`; in these cases,
 #`None``
 #till means "no default".

 #. versionadded:: 1.1

 #. seealso::

 #ref:`session_forcing_null` - in the ORM documentation

 #paramref:`.postgresql.JSON.none_as_null` - PostgreSQL JSON
 #nteraction with this flag.

 #attr:`.TypeEngine.should_evaluate_none` - class-level flag

 #""
 #yp = self.copy()
 #yp.should_evaluate_none = True
 #eturn typ

 #ef copy(self, **kw):
 #eturn self.adapt(self.__class__)

 #ef compare_against_backend(self, dialect, conn_type):
 #""Compare this type against the given backend type.

 #his function is currently not implemented for SQLAlchemy
 #ypes, and for all built in types will return ``None``.  However,
 #t can be implemented by a user-defined type
 #here it can be consumed by schema comparison tools such as
 #lembic autogenerate.

 # future release of SQLAlchemy will potentially implement this method
 #or builtin types as well.

 #he function should return True if this type is equivalent to the
 #iven type; the type is typically reflected from the database
 #o should be database specific.  The dialect in use is also
 #assed.   It can also return False to assert that the type is
 #ot equivalent.

 #param dialect: a :class:`.Dialect` that is involved in the comparison.

 #param conn_type: the type object reflected from the backend.

 #. versionadded:: 1.0.3

 #""
 #eturn None

 #ef copy_value(self, value):
 #eturn value

 #ef literal_processor(self, dialect):
 #""Return a conversion function for processing literal values that are
 #o be rendered directly without using binds.

 #his function is used when the compiler makes use of the
 #literal_binds" flag, typically used in DDL generation as well
 #s in certain scenarios where backends don't accept bound parameters.

 #. versionadded:: 0.9.0

 #""
 #eturn None

 #ef bind_processor(self, dialect):
 #""Return a conversion function for processing bind values.

 #eturns a callable which will receive a bind parameter value
 #s the sole positional argument and will return a value to
 #end to the DB-API.

 #f processing is not necessary, the method should return ``None``.

 #param dialect: Dialect instance in use.

 #""
 #eturn None

 #ef result_processor(self, dialect, coltype):
 #""Return a conversion function for processing result row values.

 #eturns a callable which will receive a result row column
 #alue as the sole positional argument and will return a value
 #o return to the user.

 #f processing is not necessary, the method should return ``None``.

 #param dialect: Dialect instance in use.

 #param coltype: DBAPI coltype argument received in cursor.description.

 #""
 #eturn None

 #ef column_expression(self, colexpr):
 #""Given a SELECT column expression, return a wrapping SQL expression.

 #his is typically a SQL function that wraps a column expression
 #s rendered in the columns clause of a SELECT statement.
 #t is used for special data types that require
 #olumns to be wrapped in some special database function in order
 #o coerce the value before being sent back to the application.
 #t is the SQL analogue of the :meth:`.TypeEngine.result_processor`
 #ethod.

 #he method is evaluated at statement compile time, as opposed
 #o statement construction time.

 #. seealso::

 #ref:`types_sql_value_processing`

 #""

 #eturn None

 #util.memoized_property
 #ef _has_column_expression(self):
 #""memoized boolean, check if column_expression is implemented.

 #llows the method to be skipped for the vast majority of expression
 #ypes that don't use this feature.

 #""

 #eturn (
 #elf.__class__.column_expression.__code__
 #s not TypeEngine.column_expression.__code__
 #

 #ef bind_expression(self, bindvalue):
 #""Given a bind value (i.e. a :class:`.BindParameter` instance),
 #eturn a SQL expression in its place.

 #his is typically a SQL function that wraps the existing bound
 #arameter within the statement.  It is used for special data types
 #hat require literals being wrapped in some special database function
 #n order to coerce an application-level value into a database-specific
 #ormat.  It is the SQL analogue of the
 #meth:`.TypeEngine.bind_processor` method.

 #he method is evaluated at statement compile time, as opposed
 #o statement construction time.

 #ote that this method, when implemented, should always return
 #he exact same structure, without any conditional logic, as it
 #ay be used in an executemany() call against an arbitrary number
 #f bound parameter sets.

 #. seealso::

 #ref:`types_sql_value_processing`

 #""
 #eturn None

 #util.memoized_property
 #ef _has_bind_expression(self):
 #""memoized boolean, check if bind_expression is implemented.

 #llows the method to be skipped for the vast majority of expression
 #ypes that don't use this feature.

 #""

 #eturn util.method_is_overridden(self, TypeEngine.bind_expression)

 #staticmethod
 #ef _to_instance(cls_or_self):
 #eturn to_instance(cls_or_self)

 #ef compare_values(self, x, y):
 #""Compare two values for equality."""

 #eturn x == y

 #ef get_dbapi_type(self, dbapi):
 #""Return the corresponding type object from the underlying DB-API, if
 #ny.

 #his can be useful for calling ``setinputsizes()``, for example.

 #""
 #eturn None

 #property
 #ef python_type(self):
 #""Return the Python type object expected to be returned
 #y instances of this type, if known.

 #asically, for those types which enforce a return type,
 #r are known across the board to do such for all common
 #BAPIs (like ``int`` for example), will return that type.

 #f a return type is not defined, raises
 #`NotImplementedError``.

 #ote that any type also accommodates NULL in SQL which
 #eans you can also get back ``None`` from any type
 #n practice.

 #""
 #aise NotImplementedError()

 #ef with_variant(self, type_, dialect_name):
 #"""Produce a new type object that will utilize the given
 #ype when applied to the dialect of the given name.

 #.g.::

 #rom sqlalchemy.types import String
 #rom sqlalchemy.dialects import mysql

 # = String()

 # = s.with_variant(mysql.VARCHAR(collation='foo'), 'mysql')

 #he construction of :meth:`.TypeEngine.with_variant` is always
 #rom the "fallback" type to that which is dialect specific.
 #he returned type is an instance of :class:`.Variant`, which
 #tself provides a :meth:`.Variant.with_variant`
 #hat can be called repeatedly.

 #param type\_: a :class:`.TypeEngine` that will be selected
 #s a variant from the originating type, when a dialect
 #f the given name is in use.
 #param dialect_name: base name of the dialect which uses
 #his type. (i.e. ``'postgresql'``, ``'mysql'``, etc.)

 #""
 #eturn Variant(self, {dialect_name: to_instance(type_)})

 #util.memoized_property
 #ef _type_affinity(self):
 #""Return a rudimental 'affinity' value expressing the general class
 #f type."""

 #yp = None
 #or t in self.__class__.__mro__:
 #f t in (TypeEngine, UserDefinedType):
 #eturn typ
 #lif issubclass(t, (TypeEngine, UserDefinedType)):
 #yp = t
 #lse:
 #eturn self.__class__

 #util.memoized_property
 #ef _generic_type_affinity(self):
 #est_camelcase = None
 #est_uppercase = None

 #f not isinstance(self, (TypeEngine, UserDefinedType)):
 #eturn self.__class__

 #or t in self.__class__.__mro__:
 #f (
 #.__module__
 #n (
 #sqlalchemy.sql.sqltypes",
 #sqlalchemy.sql.type_api",
 #
 #nd issubclass(t, TypeEngine)
 #nd t is not TypeEngine
 #nd t.__name__[0] != "_"
 #:
 #f t.__name__.isupper() and not best_uppercase:
 #est_uppercase = t
 #lif not t.__name__.isupper() and not best_camelcase:
 #est_camelcase = t

 #eturn best_camelcase or best_uppercase or NULLTYPE.__class__

 #ef as_generic(self, allow_nulltype=False):
 #""
 #eturn an instance of the generic type corresponding to this type
 #sing heuristic rule. The method may be overridden if this
 #euristic rule is not sufficient.

 #>> from sqlalchemy.dialects.mysql import INTEGER
 #>> INTEGER(display_width=4).as_generic()
 #nteger()

 #>> from sqlalchemy.dialects.mysql import NVARCHAR
 #>> NVARCHAR(length=100).as_generic()
 #nicode(length=100)

 #. versionadded:: 1.4.0b2


 #. seealso::

 #ref:`metadata_reflection_dbagnostic_types` - describes the
 #se of :meth:`_types.TypeEngine.as_generic` in conjunction with
 #he :meth:`_sql.DDLEvents.column_reflect` event, which is its
 #ntended use.

 #""
 #f (
 #ot allow_nulltype
 #nd self._generic_type_affinity == NULLTYPE.__class__
 #:
 #aise NotImplementedError(
 #Default TypeEngine.as_generic() "
 #heuristic method was unsuccessful for {}. A custom "
 #as_generic() method must be implemented for this "
 #type class.".format(
 #elf.__class__.__module__ + "." + self.__class__.__name__
 #
 #

 #eturn util.constructor_copy(self, self._generic_type_affinity)

 #ef dialect_impl(self, dialect):
 #""Return a dialect-specific implementation for this
 #class:`.TypeEngine`.

 #""
 #ry:
 #eturn dialect._type_memos[self]["impl"]
 #xcept KeyError:
 #eturn self._dialect_info(dialect)["impl"]

 #ef _unwrapped_dialect_impl(self, dialect):
 #""Return the 'unwrapped' dialect impl for this type.

 #or a type that applies wrapping logic (e.g. TypeDecorator), give
 #s the real, actual dialect-level type that is used.

 #his is used by TypeDecorator itself as well at least one case where
 #ialects need to check that a particular specific dialect-level
 #ype is in use, within the :meth:`.DefaultDialect.set_input_sizes`
 #ethod.

 #""
 #eturn self.dialect_impl(dialect)

 #ef _cached_literal_processor(self, dialect):
 #""Return a dialect-specific literal processor for this type."""
 #ry:
 #eturn dialect._type_memos[self]["literal"]
 #xcept KeyError:
 #ass
        # avoid KeyError context coming into literal_processor() function
        # raises
 # = self._dialect_info(dialect)
 #["literal"] = lp = d["impl"].literal_processor(dialect)
 #eturn lp

 #ef _cached_bind_processor(self, dialect):
 #""Return a dialect-specific bind processor for this type."""

 #ry:
 #eturn dialect._type_memos[self]["bind"]
 #xcept KeyError:
 #ass
        # avoid KeyError context coming into bind_processor() function
        # raises
 # = self._dialect_info(dialect)
 #["bind"] = bp = d["impl"].bind_processor(dialect)
 #eturn bp

 #ef _cached_result_processor(self, dialect, coltype):
 #""Return a dialect-specific result processor for this type."""

 #ry:
 #eturn dialect._type_memos[self][coltype]
 #xcept KeyError:
 #ass
        # avoid KeyError context coming into result_processor() function
        # raises
 # = self._dialect_info(dialect)
        # key assumption: DBAPI type codes are
        # constants.  Else this dictionary would
        # grow unbounded.
 #[coltype] = rp = d["impl"].result_processor(dialect, coltype)
 #eturn rp

 #ef _cached_custom_processor(self, dialect, key, fn):
 #ry:
 #eturn dialect._type_memos[self][key]
 #xcept KeyError:
 #ass
        # avoid KeyError context coming into fn() function
        # raises
 # = self._dialect_info(dialect)
 #mpl = d["impl"]
 #[key] = result = fn(impl)
 #eturn result

 #ef _dialect_info(self, dialect):
 #""Return a dialect-specific registry which
 #aches a dialect-specific implementation, bind processing
 #unction, and one or more result processing functions."""

 #f self in dialect._type_memos:
 #eturn dialect._type_memos[self]
 #lse:
 #mpl = self._gen_dialect_impl(dialect)
 #f impl is self:
 #mpl = self.adapt(type(self))
            # this can't be self, else we create a cycle
 #ssert impl is not self
 #ialect._type_memos[self] = d = {"impl": impl}
 #eturn d

 #ef _gen_dialect_impl(self, dialect):
 #eturn dialect.type_descriptor(self)

 #util.memoized_property
 #ef _static_cache_key(self):
 #ames = util.get_cls_kwargs(self.__class__)
 #eturn (self.__class__,) + tuple(
 #
 #,
 #elf.__dict__[k]._static_cache_key
 #f isinstance(self.__dict__[k], TypeEngine)
 #lse self.__dict__[k],
 #
 #or k in names
 #f k in self.__dict__ and not k.startswith("_")
 #

 #ef adapt(self, cls, **kw):
 #""Produce an "adapted" form of this type, given an "impl" class
 #o work with.

 #his method is used internally to associate generic
 #ypes with "implementation" types that are specific to a particular
 #ialect.
 #""
 #eturn util.constructor_copy(self, cls, **kw)

 #ef coerce_compared_value(self, op, value):
 #""Suggest a type for a 'coerced' Python value in an expression.

 #iven an operator and value, gives the type a chance
 #o return a type which the value should be coerced into.

 #he default behavior here is conservative; if the right-hand
 #ide is already coerced into a SQL type based on its
 #ython type, it is usually left alone.

 #nd-user functionality extension here should generally be via
 #class:`.TypeDecorator`, which provides more liberal behavior in that
 #t defaults to coercing the other side of the expression into this
 #ype, thus applying special Python conversions above and beyond those
 #eeded by the DBAPI to both ides. It also provides the public method
 #meth:`.TypeDecorator.coerce_compared_value` which is intended for
 #nd-user customization of this behavior.

 #""
 #coerced_type = _resolve_value_to_type(value)
 #f (
 #coerced_type is NULLTYPE
 #r _coerced_type._type_affinity is self._type_affinity
 #:
 #eturn self
 #lse:
 #eturn _coerced_type

 #ef _compare_type_affinity(self, other):
 #eturn self._type_affinity is other._type_affinity

 #ef compile(self, dialect=None):
 #""Produce a string-compiled form of this :class:`.TypeEngine`.

 #hen called with no arguments, uses a "default" dialect
 #o produce a string result.

 #param dialect: a :class:`.Dialect` instance.

 #""
        # arg, return value is inconsistent with
        # ClauseElement.compile()....this is a mistake.

 #f not dialect:
 #ialect = self._default_dialect()

 #eturn dialect.type_compiler.process(self)

 #util.preload_module("sqlalchemy.engine.default")
 #ef _default_dialect(self):
 #efault = util.preloaded.engine_default
 #eturn default.StrCompileDialect()

 #ef __str__(self):
 #f util.py2k:
 #eturn unicode(self.compile()).encode(  # noqa
 #ascii", "backslashreplace"
 #  # noqa
 #lse:
 #eturn str(self.compile())

 #ef __repr__(self):
 #eturn util.generic_repr(self)


class VisitableCheckKWArg(util.EnsureKWArgType, TraversibleType):
 #ass


class UserDefinedType(util.with_metaclass(VisitableCheckKWArg, TypeEngine)):
 #""Base for user defined types.

 #his should be the base of new types.  Note that
 #or most cases, :class:`.TypeDecorator` is probably
 #ore appropriate::

 #mport sqlalchemy.types as types

 #lass MyType(types.UserDefinedType):
 #ef __init__(self, precision = 8):
 #elf.precision = precision

 #ef get_col_spec(self, **kw):
 #eturn "MYTYPE(%s)" % self.precision

 #ef bind_processor(self, dialect):
 #ef process(value):
 #eturn value
 #eturn process

 #ef result_processor(self, dialect, coltype):
 #ef process(value):
 #eturn value
 #eturn process

 #nce the type is made, it's immediately usable::

 #able = Table('foo', meta,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', MyType(16))
 #

 #he ``get_col_spec()`` method will in most cases receive a keyword
 #rgument ``type_expression`` which refers to the owning expression
 #f the type as being compiled, such as a :class:`_schema.Column` or
 #func:`.cast` construct.  This keyword is only sent if the method
 #ccepts keyword arguments (e.g. ``**kw``) in its argument signature;
 #ntrospection is used to check for this in order to support legacy
 #orms of this function.

 #. versionadded:: 1.0.0 the owning expression is passed to
 #he ``get_col_spec()`` method via the keyword argument
 #`type_expression``, if it receives ``**kw`` in its signature.

 #""

 #_visit_name__ = "user_defined"

 #nsure_kwarg = "get_col_spec"

 #ef coerce_compared_value(self, op, value):
 #""Suggest a type for a 'coerced' Python value in an expression.

 #efault behavior for :class:`.UserDefinedType` is the
 #ame as that of :class:`.TypeDecorator`; by default it returns
 #`self``, assuming the compared value should be coerced into
 #he same type as this one.  See
 #meth:`.TypeDecorator.coerce_compared_value` for more detail.

 #""

 #eturn self


class Emulated(object):
 #""Mixin for base types that emulate the behavior of a DB-native type.

 #n :class:`.Emulated` type will use an available database type
 #n conjunction with Python-side routines and/or database constraints
 #n order to approximate the behavior of a database type that is provided
 #atively by some backends.  When a native-providing backend is in
 #se, the native version of the type is used.  This native version
 #hould include the :class:`.NativeForEmulated` mixin to allow it to be
 #istinguished from :class:`.Emulated`.

 #urrent examples of :class:`.Emulated` are:  :class:`.Interval`,
 #class:`.Enum`, :class:`.Boolean`.

 #. versionadded:: 1.2.0b3

 #""

 #ef adapt_to_emulated(self, impltype, **kw):
 #""Given an impl class, adapt this type to the impl assuming "emulated".

 #he impl should also be an "emulated" version of this type,
 #ost likely the same class as this type itself.

 #.g.: sqltypes.Enum adapts to the Enum class.

 #""
 #eturn super(Emulated, self).adapt(impltype, **kw)

 #ef adapt(self, impltype, **kw):
 #f hasattr(impltype, "adapt_emulated_to_native"):
 #f self.native:
                # native support requested, dialect gave us a native
                # implementor, pass control over to it
 #eturn impltype.adapt_emulated_to_native(self, **kw)
 #lse:
                # non-native support, let the native implementor
                # decide also, at the moment this is just to help debugging
                # as only the default logic is implemented.
 #eturn impltype.adapt_native_to_emulated(self, **kw)
 #lse:
 #f issubclass(impltype, self.__class__):
 #eturn self.adapt_to_emulated(impltype, **kw)
 #lse:
 #eturn super(Emulated, self).adapt(impltype, **kw)


class NativeForEmulated(object):
 #""Indicates DB-native types supported by an :class:`.Emulated` type.

 #. versionadded:: 1.2.0b3

 #""

 #classmethod
 #ef adapt_native_to_emulated(cls, impl, **kw):
 #""Given an impl, adapt this type's class to the impl assuming
 #emulated".


 #""
 #mpltype = impl.__class__
 #eturn impl.adapt(impltype, **kw)

 #classmethod
 #ef adapt_emulated_to_native(cls, impl, **kw):
 #""Given an impl, adapt this type's class to the impl assuming "native".

 #he impl will be an :class:`.Emulated` class but not a
 #class:`.NativeForEmulated`.

 #.g.: postgresql.ENUM produces a type given an Enum instance.

 #""
 #eturn cls(**kw)


class TypeDecorator(SchemaEventTarget, TypeEngine):
 #""Allows the creation of types which add additional functionality
 #o an existing type.

 #his method is preferred to direct subclassing of SQLAlchemy's
 #uilt-in types as it ensures that all required functionality of
 #he underlying type is kept in place.

 #ypical usage::

 #mport sqlalchemy.types as types

 #lass MyType(types.TypeDecorator):
 #''Prefixes Unicode values with "PREFIX:" on the way in and
 #trips it off on the way out.
 #''

 #mpl = types.Unicode

 #ache_ok = True

 #ef process_bind_param(self, value, dialect):
 #eturn "PREFIX:" + value

 #ef process_result_value(self, value, dialect):
 #eturn value[7:]

 #ef copy(self, **kw):
 #eturn MyType(self.impl.length)

 #he class-level ``impl`` attribute is required, and can reference any
 #class:`.TypeEngine` class.  Alternatively, the :meth:`load_dialect_impl`
 #ethod can be used to provide different type classes based on the dialect
 #iven; in this case, the ``impl`` variable can reference
 #`TypeEngine`` as a placeholder.

 #he :attr:`.TypeDecorator.cache_ok` class-level flag indicates if this
 #ustom :class:`.TypeDecorator` is safe to be used as part of a cache key.
 #his flag defaults to ``None`` which will initially generate a warning
 #hen the SQL compiler attempts to generate a cache key for a statement
 #hat uses this type.  If the :class:`.TypeDecorator` is not guaranteed
 #o produce the same bind/result behavior and SQL generation
 #very time, this flag should be set to ``False``; otherwise if the
 #lass produces the same behavior each time, it may be set to ``True``.
 #ee :attr:`.TypeDecorator.cache_ok` for further notes on how this works.

 #ypes that receive a Python type that isn't similar to the ultimate type
 #sed may want to define the :meth:`TypeDecorator.coerce_compared_value`
 #ethod. This is used to give the expression system a hint when coercing
 #ython objects into bind parameters within expressions. Consider this
 #xpression::

 #ytable.c.somecol + datetime.date(2009, 5, 15)

 #bove, if "somecol" is an ``Integer`` variant, it makes sense that
 #e're doing date arithmetic, where above is usually interpreted
 #y databases as adding a number of days to the given date.
 #he expression system does the right thing by not attempting to
 #oerce the "date()" value into an integer-oriented bind parameter.

 #owever, in the case of ``TypeDecorator``, we are usually changing an
 #ncoming Python type to something new - ``TypeDecorator`` by default will
 #coerce" the non-typed side to be the same type as itself. Such as below,
 #e define an "epoch" type that stores a date value as an integer::

 #lass MyEpochType(types.TypeDecorator):
 #mpl = types.Integer

 #poch = datetime.date(1970, 1, 1)

 #ef process_bind_param(self, value, dialect):
 #eturn (value - self.epoch).days

 #ef process_result_value(self, value, dialect):
 #eturn self.epoch + timedelta(days=value)

 #ur expression of ``somecol + date`` with the above type will coerce the
 #date" on the right side to also be treated as ``MyEpochType``.

 #his behavior can be overridden via the
 #meth:`~TypeDecorator.coerce_compared_value` method, which returns a type
 #hat should be used for the value of the expression. Below we set it such
 #hat an integer value will be treated as an ``Integer``, and any other
 #alue is assumed to be a date and will be treated as a ``MyEpochType``::

 #ef coerce_compared_value(self, op, value):
 #f isinstance(value, int):
 #eturn Integer()
 #lse:
 #eturn self

 #. warning::

 #ote that the **behavior of coerce_compared_value is not inherited
 #y default from that of the base type**.
 #f the :class:`.TypeDecorator` is augmenting a
 #ype that requires special logic for certain types of operators,
 #his method **must** be overridden.  A key example is when decorating
 #he :class:`_postgresql.JSON` and :class:`_postgresql.JSONB` types;
 #he default rules of :meth:`.TypeEngine.coerce_compared_value` should
 #e used in order to deal with operators like index operations::

 #lass MyJsonType(TypeDecorator):
 #mpl = postgresql.JSON

 #ache_ok = True

 #ef coerce_compared_value(self, op, value):
 #eturn self.impl.coerce_compared_value(op, value)

 #ithout the above step, index operations such as ``mycol['foo']``
 #ill cause the index value ``'foo'`` to be JSON encoded.

 #""

 #_visit_name__ = "type_decorator"

 #is_type_decorator = True

 #ef __init__(self, *args, **kwargs):
 #""Construct a :class:`.TypeDecorator`.

 #rguments sent here are passed to the constructor
 #f the class assigned to the ``impl`` class level attribute,
 #ssuming the ``impl`` is a callable, and the resulting
 #bject is assigned to the ``self.impl`` instance attribute
 #thus overriding the class attribute of the same name).

 #f the class level ``impl`` is not a callable (the unusual case),
 #t will be assigned to the same instance attribute 'as-is',
 #gnoring those arguments passed to the constructor.

 #ubclasses can override this to customize the generation
 #f ``self.impl`` entirely.

 #""

 #f not hasattr(self.__class__, "impl"):
 #aise AssertionError(
 #TypeDecorator implementations "
 #require a class-level variable "
 #'impl' which refers to the class of "
 #type being decorated"
 #
 #elf.impl = to_instance(self.__class__.impl, *args, **kwargs)

 #oerce_to_is_types = (util.NoneType,)
 #""Specify those Python types which should be coerced at the expression
 #evel to "IS <constant>" when compared using ``==`` (and same for
 #`IS NOT`` in conjunction with ``!=``).

 #or most SQLAlchemy types, this includes ``NoneType``, as well as
 #`bool``.

 #class:`.TypeDecorator` modifies this list to only include ``NoneType``,
 #s typedecorator implementations that deal with boolean types are common.

 #ustom :class:`.TypeDecorator` classes can override this attribute to
 #eturn an empty tuple, in which case no values will be coerced to
 #onstants.

 #""

 #ache_ok = None
 #""Indicate if statements using this :class:`.TypeDecorator` are "safe to
 #ache".

 #he default value ``None`` will emit a warning and then not allow caching
 #f a statement which includes this type.   Set to ``False`` to disable
 #tatements using this type from being cached at all without a warning.
 #hen set to ``True``, the object's class and selected elements from its
 #tate will be used as part of the cache key, e.g.::

 #lass MyType(TypeDecorator):
 #mpl = String

 #ache_ok = True

 #ef __init__(self, choices):
 #elf.choices = tuple(choices)
 #elf.internal_only = True

 #he cache key for the above type would be equivalent to::

 #<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))

 #he caching scheme will extract attributes from the type that correspond
 #o the names of parameters in the ``__init__()`` method.  Above, the
 #choices" attribute becomes part of the cache key but "internal_only"
 #oes not, because there is no parameter named "internal_only".

 #he requirements for cacheable elements is that they are hashable
 #nd also that they indicate the same SQL rendered for expressions using
 #his type every time for a given cache value.

 #. versionadded:: 1.4.14 - added the ``cache_ok`` flag to allow
 #ome configurability of caching for :class:`.TypeDecorator` classes.

 #. seealso::

 #ref:`sql_caching`

 #""

 #lass Comparator(TypeEngine.Comparator):
 #""A :class:`.TypeEngine.Comparator` that is specific to
 #class:`.TypeDecorator`.

 #ser-defined :class:`.TypeDecorator` classes should not typically
 #eed to modify this.


 #""

 #_slots__ = ()

 #ef operate(self, op, *other, **kwargs):
 #wargs["_python_is_types"] = self.expr.type.coerce_to_is_types
 #eturn super(TypeDecorator.Comparator, self).operate(
 #p, *other, **kwargs
 #

 #ef reverse_operate(self, op, other, **kwargs):
 #wargs["_python_is_types"] = self.expr.type.coerce_to_is_types
 #eturn super(TypeDecorator.Comparator, self).reverse_operate(
 #p, other, **kwargs
 #

 #property
 #ef comparator_factory(self):
 #f TypeDecorator.Comparator in self.impl.comparator_factory.__mro__:
 #eturn self.impl.comparator_factory
 #lse:
 #eturn type(
 #TDComparator",
 #TypeDecorator.Comparator, self.impl.comparator_factory),
 #},
 #

 #property
 #ef _static_cache_key(self):
 #f self.cache_ok is None:
 #til.warn(
 #TypeDecorator %r will not produce a cache key because "
 #the ``cache_ok`` flag is not set to True.  "
 #Set this flag to True if this type object's "
 #state is safe to use in a cache key, or False to "
 #disable this warning." % self
 #
 #lif self.cache_ok is True:
 #eturn super(TypeDecorator, self)._static_cache_key

 #eturn NO_CACHE

 #ef _gen_dialect_impl(self, dialect):
 #""
        #todo
 #""
 #dapted = dialect.type_descriptor(self)
 #f adapted is not self:
 #eturn adapted

        # otherwise adapt the impl type, link
        # to a copy of this TypeDecorator and return
        # that.
 #ypedesc = self.load_dialect_impl(dialect).dialect_impl(dialect)
 #t = self.copy()
 #f not isinstance(tt, self.__class__):
 #aise AssertionError(
 #Type object %s does not properly "
 #implement the copy() method, it must "
 #return an object of type %s" % (self, self.__class__)
 #
 #t.impl = typedesc
 #eturn tt

 #property
 #ef _type_affinity(self):
 #""
        #todo
 #""
 #eturn self.impl._type_affinity

 #ef _set_parent(self, column, outer=False, **kw):
 #""Support SchemaEventTarget"""

 #uper(TypeDecorator, self)._set_parent(column)

 #f not outer and isinstance(self.impl, SchemaEventTarget):
 #elf.impl._set_parent(column, outer=False, **kw)

 #ef _set_parent_with_dispatch(self, parent):
 #""Support SchemaEventTarget"""

 #uper(TypeDecorator, self)._set_parent_with_dispatch(
 #arent, outer=True
 #

 #f isinstance(self.impl, SchemaEventTarget):
 #elf.impl._set_parent_with_dispatch(parent)

 #ef type_engine(self, dialect):
 #""Return a dialect-specific :class:`.TypeEngine` instance
 #or this :class:`.TypeDecorator`.

 #n most cases this returns a dialect-adapted form of
 #he :class:`.TypeEngine` type represented by ``self.impl``.
 #akes usage of :meth:`dialect_impl`.
 #ehavior can be customized here by overriding
 #meth:`load_dialect_impl`.

 #""
 #dapted = dialect.type_descriptor(self)
 #f not isinstance(adapted, type(self)):
 #eturn adapted
 #lse:
 #eturn self.load_dialect_impl(dialect)

 #ef load_dialect_impl(self, dialect):
 #""Return a :class:`.TypeEngine` object corresponding to a dialect.

 #his is an end-user override hook that can be used to provide
 #iffering types depending on the given dialect.  It is used
 #y the :class:`.TypeDecorator` implementation of :meth:`type_engine`
 #o help determine what type should ultimately be returned
 #or a given :class:`.TypeDecorator`.

 #y default returns ``self.impl``.

 #""
 #eturn self.impl

 #ef _unwrapped_dialect_impl(self, dialect):
 #""Return the 'unwrapped' dialect impl for this type.

 #his is used by the :meth:`.DefaultDialect.set_input_sizes`
 #ethod.

 #""
        # some dialects have a lookup for a TypeDecorator subclass directly.
        # postgresql.INTERVAL being the main example
 #yp = self.dialect_impl(dialect)

        # if we are still a type decorator, load the per-dialect switch
        # (such as what Variant uses), then get the dialect impl for that.
 #f isinstance(typ, self.__class__):
 #eturn typ.load_dialect_impl(dialect).dialect_impl(dialect)
 #lse:
 #eturn typ

 #ef __getattr__(self, key):
 #""Proxy all other undefined accessors to the underlying
 #mplementation."""
 #eturn getattr(self.impl, key)

 #ef process_literal_param(self, value, dialect):
 #""Receive a literal parameter value to be rendered inline within
 # statement.

 #his method is used when the compiler renders a
 #iteral value without using binds, typically within DDL
 #uch as in the "server default" of a column or an expression
 #ithin a CHECK constraint.

 #he returned string will be rendered into the output string.

 #. versionadded:: 0.9.0

 #""
 #aise NotImplementedError()

 #ef process_bind_param(self, value, dialect):
 #""Receive a bound parameter value to be converted.

 #ubclasses override this method to return the
 #alue that should be passed along to the underlying
 #class:`.TypeEngine` object, and from there to the
 #BAPI ``execute()`` method.

 #he operation could be anything desired to perform custom
 #ehavior, such as transforming or serializing data.
 #his could also be used as a hook for validating logic.

 #his operation should be designed with the reverse operation
 #n mind, which would be the process_result_value method of
 #his class.

 #param value: Data to operate upon, of any type expected by
 #his method in the subclass.  Can be ``None``.
 #param dialect: the :class:`.Dialect` in use.

 #""

 #aise NotImplementedError()

 #ef process_result_value(self, value, dialect):
 #""Receive a result-row column value to be converted.

 #ubclasses should implement this method to operate on data
 #etched from the database.

 #ubclasses override this method to return the
 #alue that should be passed back to the application,
 #iven a value that is already processed by
 #he underlying :class:`.TypeEngine` object, originally
 #rom the DBAPI cursor method ``fetchone()`` or similar.

 #he operation could be anything desired to perform custom
 #ehavior, such as transforming or serializing data.
 #his could also be used as a hook for validating logic.

 #param value: Data to operate upon, of any type expected by
 #his method in the subclass.  Can be ``None``.
 #param dialect: the :class:`.Dialect` in use.

 #his operation should be designed to be reversible by
 #he "process_bind_param" method of this class.

 #""

 #aise NotImplementedError()

 #util.memoized_property
 #ef _has_bind_processor(self):
 #""memoized boolean, check if process_bind_param is implemented.

 #llows the base process_bind_param to raise
 #otImplementedError without needing to test an expensive
 #xception throw.

 #""

 #eturn util.method_is_overridden(
 #elf, TypeDecorator.process_bind_param
 #

 #util.memoized_property
 #ef _has_literal_processor(self):
 #""memoized boolean, check if process_literal_param is implemented."""

 #eturn util.method_is_overridden(
 #elf, TypeDecorator.process_literal_param
 #

 #ef literal_processor(self, dialect):
 #""Provide a literal processing function for the given
 #class:`.Dialect`.

 #ubclasses here will typically override
 #meth:`.TypeDecorator.process_literal_param` instead of this method
 #irectly.

 #y default, this method makes use of
 #meth:`.TypeDecorator.process_bind_param` if that method is
 #mplemented, where :meth:`.TypeDecorator.process_literal_param` is
 #ot.  The rationale here is that :class:`.TypeDecorator` typically
 #eals with Python conversions of data that are above the layer of
 #atabase presentation.  With the value converted by
 #meth:`.TypeDecorator.process_bind_param`, the underlying type will
 #hen handle whether it needs to be presented to the DBAPI as a bound
 #arameter or to the database as an inline SQL value.

 #. versionadded:: 0.9.0

 #""
 #f self._has_literal_processor:
 #rocess_param = self.process_literal_param
 #lif self._has_bind_processor:
            # the bind processor should normally be OK
            # for TypeDecorator since it isn't doing DB-level
            # handling, the handling here won't be different for bound vs.
            # literals.
 #rocess_param = self.process_bind_param
 #lse:
 #rocess_param = None

 #f process_param:
 #mpl_processor = self.impl.literal_processor(dialect)
 #f impl_processor:

 #ef process(value):
 #eturn impl_processor(process_param(value, dialect))

 #lse:

 #ef process(value):
 #eturn process_param(value, dialect)

 #eturn process
 #lse:
 #eturn self.impl.literal_processor(dialect)

 #ef bind_processor(self, dialect):
 #""Provide a bound value processing function for the
 #iven :class:`.Dialect`.

 #his is the method that fulfills the :class:`.TypeEngine`
 #ontract for bound value conversion.   :class:`.TypeDecorator`
 #ill wrap a user-defined implementation of
 #meth:`process_bind_param` here.

 #ser-defined code can override this method directly,
 #hough its likely best to use :meth:`process_bind_param` so that
 #he processing provided by ``self.impl`` is maintained.

 #param dialect: Dialect instance in use.

 #his method is the reverse counterpart to the
 #meth:`result_processor` method of this class.

 #""
 #f self._has_bind_processor:
 #rocess_param = self.process_bind_param
 #mpl_processor = self.impl.bind_processor(dialect)
 #f impl_processor:

 #ef process(value):
 #eturn impl_processor(process_param(value, dialect))

 #lse:

 #ef process(value):
 #eturn process_param(value, dialect)

 #eturn process
 #lse:
 #eturn self.impl.bind_processor(dialect)

 #util.memoized_property
 #ef _has_result_processor(self):
 #""memoized boolean, check if process_result_value is implemented.

 #llows the base process_result_value to raise
 #otImplementedError without needing to test an expensive
 #xception throw.

 #""

 #eturn util.method_is_overridden(
 #elf, TypeDecorator.process_result_value
 #

 #ef result_processor(self, dialect, coltype):
 #""Provide a result value processing function for the given
 #class:`.Dialect`.

 #his is the method that fulfills the :class:`.TypeEngine`
 #ontract for result value conversion.   :class:`.TypeDecorator`
 #ill wrap a user-defined implementation of
 #meth:`process_result_value` here.

 #ser-defined code can override this method directly,
 #hough its likely best to use :meth:`process_result_value` so that
 #he processing provided by ``self.impl`` is maintained.

 #param dialect: Dialect instance in use.
 #param coltype: A SQLAlchemy data type

 #his method is the reverse counterpart to the
 #meth:`bind_processor` method of this class.

 #""
 #f self._has_result_processor:
 #rocess_value = self.process_result_value
 #mpl_processor = self.impl.result_processor(dialect, coltype)
 #f impl_processor:

 #ef process(value):
 #eturn process_value(impl_processor(value), dialect)

 #lse:

 #ef process(value):
 #eturn process_value(value, dialect)

 #eturn process
 #lse:
 #eturn self.impl.result_processor(dialect, coltype)

 #util.memoized_property
 #ef _has_bind_expression(self):

 #eturn (
 #til.method_is_overridden(self, TypeDecorator.bind_expression)
 #r self.impl._has_bind_expression
 #

 #ef bind_expression(self, bindparam):
 #eturn self.impl.bind_expression(bindparam)

 #util.memoized_property
 #ef _has_column_expression(self):
 #""memoized boolean, check if column_expression is implemented.

 #llows the method to be skipped for the vast majority of expression
 #ypes that don't use this feature.

 #""

 #eturn (
 #til.method_is_overridden(self, TypeDecorator.column_expression)
 #r self.impl._has_column_expression
 #

 #ef column_expression(self, column):
 #eturn self.impl.column_expression(column)

 #ef coerce_compared_value(self, op, value):
 #""Suggest a type for a 'coerced' Python value in an expression.

 #y default, returns self.   This method is called by
 #he expression system when an object using this type is
 #n the left or right side of an expression against a plain Python
 #bject which does not yet have a SQLAlchemy type assigned::

 #xpr = table.c.somecolumn + 35

 #here above, if ``somecolumn`` uses this type, this method will
 #e called with the value ``operator.add``
 #nd ``35``.  The return value is whatever SQLAlchemy type should
 #e used for ``35`` for this particular operation.

 #""
 #eturn self

 #ef copy(self, **kw):
 #""Produce a copy of this :class:`.TypeDecorator` instance.

 #his is a shallow copy and is provided to fulfill part of
 #he :class:`.TypeEngine` contract.  It usually does not
 #eed to be overridden unless the user-defined :class:`.TypeDecorator`
 #as local state that should be deep-copied.

 #""

 #nstance = self.__class__.__new__(self.__class__)
 #nstance.__dict__.update(self.__dict__)
 #eturn instance

 #ef get_dbapi_type(self, dbapi):
 #""Return the DBAPI type object represented by this
 #class:`.TypeDecorator`.

 #y default this calls upon :meth:`.TypeEngine.get_dbapi_type` of the
 #nderlying "impl".
 #""
 #eturn self.impl.get_dbapi_type(dbapi)

 #ef compare_values(self, x, y):
 #""Given two values, compare them for equality.

 #y default this calls upon :meth:`.TypeEngine.compare_values`
 #f the underlying "impl", which in turn usually
 #ses the Python equals operator ``==``.

 #his function is used by the ORM to compare
 #n original-loaded value with an intercepted
 #changed" value, to determine if a net change
 #as occurred.

 #""
 #eturn self.impl.compare_values(x, y)

 #property
 #ef sort_key_function(self):
 #eturn self.impl.sort_key_function

 #ef __repr__(self):
 #eturn util.generic_repr(self, to_inspect=self.impl)


class Variant(TypeDecorator):
 #""A wrapping type that selects among a variety of
 #mplementations based on dialect in use.

 #he :class:`.Variant` type is typically constructed
 #sing the :meth:`.TypeEngine.with_variant` method.

 #. seealso:: :meth:`.TypeEngine.with_variant` for an example of use.

 #""

 #ache_ok = True

 #ef __init__(self, base, mapping):
 #""Construct a new :class:`.Variant`.

 #param base: the base 'fallback' type
 #param mapping: dictionary of string dialect names to
 #class:`.TypeEngine` instances.

 #""
 #elf.impl = base
 #elf.mapping = mapping

 #util.memoized_property
 #ef _static_cache_key(self):
        # TODO: needs tests in test/sql/test_compare.py
 #eturn (self.__class__,) + (
 #elf.impl._static_cache_key,
 #uple(
 #key, self.mapping[key]._static_cache_key)
 #or key in sorted(self.mapping)
 #,
 #

 #ef coerce_compared_value(self, operator, value):
 #esult = self.impl.coerce_compared_value(operator, value)
 #f result is self.impl:
 #eturn self
 #lse:
 #eturn result

 #ef load_dialect_impl(self, dialect):
 #f dialect.name in self.mapping:
 #eturn self.mapping[dialect.name]
 #lse:
 #eturn self.impl

 #ef _set_parent(self, column, outer=False, **kw):
 #""Support SchemaEventTarget"""

 #f isinstance(self.impl, SchemaEventTarget):
 #elf.impl._set_parent(column, **kw)
 #or impl in self.mapping.values():
 #f isinstance(impl, SchemaEventTarget):
 #mpl._set_parent(column, **kw)

 #ef _set_parent_with_dispatch(self, parent):
 #""Support SchemaEventTarget"""

 #f isinstance(self.impl, SchemaEventTarget):
 #elf.impl._set_parent_with_dispatch(parent)
 #or impl in self.mapping.values():
 #f isinstance(impl, SchemaEventTarget):
 #mpl._set_parent_with_dispatch(parent)

 #ef with_variant(self, type_, dialect_name):
 #"""Return a new :class:`.Variant` which adds the given
 #ype + dialect name to the mapping, in addition to the
 #apping present in this :class:`.Variant`.

 #param type\_: a :class:`.TypeEngine` that will be selected
 #s a variant from the originating type, when a dialect
 #f the given name is in use.
 #param dialect_name: base name of the dialect which uses
 #his type. (i.e. ``'postgresql'``, ``'mysql'``, etc.)

 #""

 #f dialect_name in self.mapping:
 #aise exc.ArgumentError(
 #Dialect '%s' is already present in "
 #the mapping for this Variant" % dialect_name
 #
 #apping = self.mapping.copy()
 #apping[dialect_name] = type_
 #eturn Variant(self.impl, mapping)

 #property
 #ef comparator_factory(self):
 #""express comparison behavior in terms of the base type"""
 #eturn self.impl.comparator_factory


def _reconstitute_comparator(expression):
 #eturn expression.comparator


def to_instance(typeobj, *arg, **kw):
 #f typeobj is None:
 #eturn NULLTYPE

 #f callable(typeobj):
 #eturn typeobj(*arg, **kw)
 #lse:
 #eturn typeobj


def adapt_type(typeobj, colspecs):
 #f isinstance(typeobj, type):
 #ypeobj = typeobj()
 #or t in typeobj.__class__.__mro__[0:-1]:
 #ry:
 #mpltype = colspecs[t]
 #reak
 #xcept KeyError:
 #ass
 #lse:
        # couldn't adapt - so just return the type itself
        # (it may be a user-defined type)
 #eturn typeobj
    # if we adapted the given generic type to a database-specific type,
    # but it turns out the originally given "generic" type
    # is actually a subclass of our resulting type, then we were already
    # given a more specific type than that required; so use that.
 #f issubclass(typeobj.__class__, impltype):
 #eturn typeobj
 #eturn typeobj.adapt(impltype)
