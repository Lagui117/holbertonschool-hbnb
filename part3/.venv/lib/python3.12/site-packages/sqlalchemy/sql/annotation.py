# sql/annotation.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""The :class:`.Annotated` class and related routines; creates hash-equivalent
copies of SQL constructs which contain context-specific markers and
associations.

"""

from . import operators
from .base import HasCacheKey
from .traversals import anon_map
from .visitors import InternalTraversal
from .. import util

EMPTY_ANNOTATIONS = util.immutabledict()


class SupportsAnnotations(object):
 #annotations = EMPTY_ANNOTATIONS

 #util.memoized_property
 #ef _annotations_cache_key(self):
 #non_map_ = anon_map()
 #eturn (
 #_annotations",
 #uple(
 #
 #ey,
 #alue._gen_cache_key(anon_map_, [])
 #f isinstance(value, HasCacheKey)
 #lse value,
 #
 #or key, value in [
 #key, self._annotations[key])
 #or key in sorted(self._annotations)
 #
 #,
 #


class SupportsCloneAnnotations(SupportsAnnotations):

 #clone_annotations_traverse_internals = [
 #"_annotations", InternalTraversal.dp_annotations_key)
 #

 #ef _annotate(self, values):
 #""return a copy of this ClauseElement with annotations
 #pdated by the given dictionary.

 #""
 #ew = self._clone()
 #ew._annotations = new._annotations.union(values)
 #ew.__dict__.pop("_annotations_cache_key", None)
 #ew.__dict__.pop("_generate_cache_key", None)
 #eturn new

 #ef _with_annotations(self, values):
 #""return a copy of this ClauseElement with annotations
 #eplaced by the given dictionary.

 #""
 #ew = self._clone()
 #ew._annotations = util.immutabledict(values)
 #ew.__dict__.pop("_annotations_cache_key", None)
 #ew.__dict__.pop("_generate_cache_key", None)
 #eturn new

 #ef _deannotate(self, values=None, clone=False):
 #""return a copy of this :class:`_expression.ClauseElement`
 #ith annotations
 #emoved.

 #param values: optional tuple of individual values
 #o remove.

 #""
 #f clone or self._annotations:
            # clone is used when we are also copying
            # the expression for a deep deannotation
 #ew = self._clone()
 #ew._annotations = util.immutabledict()
 #ew.__dict__.pop("_annotations_cache_key", None)
 #eturn new
 #lse:
 #eturn self


class SupportsWrappingAnnotations(SupportsAnnotations):
 #ef _annotate(self, values):
 #""return a copy of this ClauseElement with annotations
 #pdated by the given dictionary.

 #""
 #eturn Annotated(self, values)

 #ef _with_annotations(self, values):
 #""return a copy of this ClauseElement with annotations
 #eplaced by the given dictionary.

 #""
 #eturn Annotated(self, values)

 #ef _deannotate(self, values=None, clone=False):
 #""return a copy of this :class:`_expression.ClauseElement`
 #ith annotations
 #emoved.

 #param values: optional tuple of individual values
 #o remove.

 #""
 #f clone:
 # = self._clone()
 #eturn s
 #lse:
 #eturn self


class Annotated(object):
 #""clones a SupportsAnnotated and applies an 'annotations' dictionary.

 #nlike regular clones, this clone also mimics __hash__() and
 #_cmp__() of the original element so that it takes its place
 #n hashed collections.

 # reference to the original element is maintained, for the important
 #eason of keeping its hash value current.  When GC'ed, the
 #ash value may be reused, causing conflicts.

 #. note::  The rationale for Annotated producing a brand new class,
 #ather than placing the functionality directly within ClauseElement,
 #s **performance**.  The __hash__() method is absent on plain
 #lauseElement which leads to significantly reduced function call
 #verhead, as the use of sets and dictionaries against ClauseElement
 #bjects is prevalent, but most are not "annotated".

 #""

 #is_column_operators = False

 #ef __new__(cls, *args):
 #f not args:
            # clone constructor
 #eturn object.__new__(cls)
 #lse:
 #lement, values = args
            # pull appropriate subclass from registry of annotated
            # classes
 #ry:
 #ls = annotated_classes[element.__class__]
 #xcept KeyError:
 #ls = _new_annotation_type(element.__class__, cls)
 #eturn object.__new__(cls)

 #ef __init__(self, element, values):
 #elf.__dict__ = element.__dict__.copy()
 #elf.__dict__.pop("_annotations_cache_key", None)
 #elf.__dict__.pop("_generate_cache_key", None)
 #elf.__element = element
 #elf._annotations = util.immutabledict(values)
 #elf._hash = hash(element)

 #ef _annotate(self, values):
 #values = self._annotations.union(values)
 #eturn self._with_annotations(_values)

 #ef _with_annotations(self, values):
 #lone = self.__class__.__new__(self.__class__)
 #lone.__dict__ = self.__dict__.copy()
 #lone.__dict__.pop("_annotations_cache_key", None)
 #lone.__dict__.pop("_generate_cache_key", None)
 #lone._annotations = values
 #eturn clone

 #ef _deannotate(self, values=None, clone=True):
 #f values is None:
 #eturn self.__element
 #lse:
 #eturn self._with_annotations(
 #til.immutabledict(
 #
 #ey: value
 #or key, value in self._annotations.items()
 #f key not in values
 #
 #
 #

 #ef _compiler_dispatch(self, visitor, **kw):
 #eturn self.__element.__class__._compiler_dispatch(self, visitor, **kw)

 #property
 #ef _constructor(self):
 #eturn self.__element._constructor

 #ef _clone(self, **kw):
 #lone = self.__element._clone(**kw)
 #f clone is self.__element:
            # detect immutable, don't change anything
 #eturn self
 #lse:
            # update the clone with any changes that have occurred
            # to this object's __dict__.
 #lone.__dict__.update(self.__dict__)
 #eturn self.__class__(clone, self._annotations)

 #ef __reduce__(self):
 #eturn self.__class__, (self.__element, self._annotations)

 #ef __hash__(self):
 #eturn self._hash

 #ef __eq__(self, other):
 #f self._is_column_operators:
 #eturn self.__element.__class__.__eq__(self, other)
 #lse:
 #eturn hash(other) == hash(self)

 #property
 #ef entity_namespace(self):
 #f "entity_namespace" in self._annotations:
 #eturn self._annotations["entity_namespace"].entity_namespace
 #lse:
 #eturn self.__element.entity_namespace


# hard-generate Annotated subclasses.  this technique
# is used instead of on-the-fly types (i.e. type.__new__())
# so that the resulting objects are pickleable; additionally, other
# decisions can be made up front about the type of object being annotated
# just once per class rather than per-instance.
annotated_classes = {}


def _deep_annotate(element, annotations, exclude=None):
 #""Deep copy the given ClauseElement, annotating each element
 #ith the given annotations dictionary.

 #lements within the exclude collection will be cloned but not annotated.

 #""

    # annotated objects hack the __hash__() method so if we want to
    # uniquely process them we have to use id()

 #loned_ids = {}

 #ef clone(elem, **kw):
 #d_ = id(elem)

 #f id_ in cloned_ids:
 #eturn cloned_ids[id_]

 #f (
 #xclude
 #nd hasattr(elem, "proxy_set")
 #nd elem.proxy_set.intersection(exclude)
 #:
 #ewelem = elem._clone(**kw)
 #lif annotations != elem._annotations:
 #ewelem = elem._annotate(annotations)
 #lse:
 #ewelem = elem
 #ewelem._copy_internals(clone=clone)
 #loned_ids[id_] = newelem
 #eturn newelem

 #f element is not None:
 #lement = clone(element)
 #lone = None  # remove gc cycles
 #eturn element


def _deep_deannotate(element, values=None):
 #""Deep copy the given element, removing annotations."""

 #loned = {}

 #ef clone(elem, **kw):
 #f values:
 #ey = id(elem)
 #lse:
 #ey = elem

 #f key not in cloned:
 #ewelem = elem._deannotate(values=values, clone=True)
 #ewelem._copy_internals(clone=clone)
 #loned[key] = newelem
 #eturn newelem
 #lse:
 #eturn cloned[key]

 #f element is not None:
 #lement = clone(element)
 #lone = None  # remove gc cycles
 #eturn element


def _shallow_annotate(element, annotations):
 #""Annotate the given ClauseElement and copy its internals so that
 #nternal objects refer to the new annotated object.

 #asically used to apply a "don't traverse" annotation to a
 #electable, without digging throughout the whole
 #tructure wasting time.
 #""
 #lement = element._annotate(annotations)
 #lement._copy_internals()
 #eturn element


def _new_annotation_type(cls, base_cls):
 #f issubclass(cls, Annotated):
 #eturn cls
 #lif cls in annotated_classes:
 #eturn annotated_classes[cls]

 #or super_ in cls.__mro__:
        # check if an Annotated subclass more specific than
        # the given base_cls is already registered, such
        # as AnnotatedColumnElement.
 #f super_ in annotated_classes:
 #ase_cls = annotated_classes[super_]
 #reak

 #nnotated_classes[cls] = anno_cls = type(
 #Annotated%s" % cls.__name__, (base_cls, cls), {}
 #
 #lobals()["Annotated%s" % cls.__name__] = anno_cls

 #f "_traverse_internals" in cls.__dict__:
 #nno_cls._traverse_internals = list(cls._traverse_internals) + [
 #"_annotations", InternalTraversal.dp_annotations_key)
 #
 #lif cls.__dict__.get("inherit_cache", False):
 #nno_cls._traverse_internals = list(cls._traverse_internals) + [
 #"_annotations", InternalTraversal.dp_annotations_key)
 #

    # some classes include this even if they have traverse_internals
    # e.g. BindParameter, add it if present.
 #f cls.__dict__.get("inherit_cache", False):
 #nno_cls.inherit_cache = True

 #nno_cls._is_column_operators = issubclass(cls, operators.ColumnOperators)

 #eturn anno_cls


def _prepare_annotations(target_hierarchy, base_cls):
 #or cls in util.walk_subclasses(target_hierarchy):
 #new_annotation_type(cls, base_cls)
