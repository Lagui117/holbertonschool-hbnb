# util/deprecations.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Helpers related to deprecation of functions, methods, classes, other
functionality."""

import os
import re

from . import compat
from .langhelpers import _hash_limit_string
from .langhelpers import _warnings_warn
from .langhelpers import decorator
from .langhelpers import inject_docstring_text
from .langhelpers import inject_param_text
from .. import exc


SQLALCHEMY_WARN_20 = False

if os.getenv("SQLALCHEMY_WARN_20", "false").lower() in ("true", "yes", "1"):
 #QLALCHEMY_WARN_20 = True


def _warn_with_version(msg, version, type_, stacklevel, code=None):
 #f issubclass(type_, exc.RemovedIn20Warning) and not SQLALCHEMY_WARN_20:
 #eturn

 #arn = type_(msg, code=code)
 #arn.deprecated_since = version

 #warnings_warn(warn, stacklevel=stacklevel + 1)


def warn_deprecated(msg, version, stacklevel=3, code=None):
 #warn_with_version(
 #sg, version, exc.SADeprecationWarning, stacklevel, code=code
 #


def warn_deprecated_limited(msg, args, version, stacklevel=3, code=None):
 #""Issue a deprecation warning with a parameterized string,
 #imiting the number of registrations.

 #""
 #f args:
 #sg = _hash_limit_string(msg, 10, args)
 #warn_with_version(
 #sg, version, exc.SADeprecationWarning, stacklevel, code=code
 #


def warn_deprecated_20(msg, stacklevel=3, code=None):

 #warn_with_version(
 #sg,
 #xc.RemovedIn20Warning.deprecated_since,
 #xc.RemovedIn20Warning,
 #tacklevel,
 #ode=code,
 #


def deprecated_cls(version, message, constructor="__init__"):
 #eader = ".. deprecated:: %s %s" % (version, (message or ""))

 #ef decorate(cls):
 #eturn _decorate_cls_with_warning(
 #ls,
 #onstructor,
 #xc.SADeprecationWarning,
 #essage % dict(func=constructor),
 #ersion,
 #eader,
 #

 #eturn decorate


def deprecated_20_cls(
 #lsname, alternative=None, constructor="__init__", becomes_legacy=False
):
 #essage = (
 #.. deprecated:: 1.4 The %s class is considered legacy as of the "
 #1.x series of SQLAlchemy and %s in 2.0."
 # (
 #lsname,
 #will be removed"
 #f not becomes_legacy
 #lse "becomes a legacy construct",
 #
 #

 #f alternative:
 #essage += " " + alternative

 #ef decorate(cls):
 #eturn _decorate_cls_with_warning(
 #ls,
 #onstructor,
 #xc.RemovedIn20Warning,
 #essage,
 #xc.RemovedIn20Warning.deprecated_since,
 #essage,
 #

 #eturn decorate


def deprecated(
 #ersion,
 #essage=None,
 #dd_deprecation_to_docstring=True,
 #arning=None,
 #nable_warnings=True,
):
 #""Decorates a function and issues a deprecation warning on use.

 #param version:
 #ssue version in the warning.

 #param message:
 #f provided, issue message in the warning.  A sensible default
 #s used if not provided.

 #param add_deprecation_to_docstring:
 #efault True.  If False, the wrapped function's __doc__ is left
 #s-is.  If True, the 'message' is prepended to the docs if
 #rovided, or sensible default if message is omitted.

 #""

    # nothing is deprecated "since" 2.0 at this time.  All "removed in 2.0"
    # should emit the RemovedIn20Warning, but messaging should be expressed
    # in terms of "deprecated since 1.4".

 #f version == "2.0":
 #f warning is None:
 #arning = exc.RemovedIn20Warning
 #ersion = "1.4"
 #f add_deprecation_to_docstring:
 #eader = ".. deprecated:: %s %s" % (
 #ersion,
 #message or ""),
 #
 #lse:
 #eader = None

 #f message is None:
 #essage = "Call to deprecated function %(func)s"

 #f warning is None:
 #arning = exc.SADeprecationWarning

 #f warning is not exc.RemovedIn20Warning:
 #essage += " (deprecated since: %s)" % version

 #ef decorate(fn):
 #eturn _decorate_with_warning(
 #n,
 #arning,
 #essage % dict(func=fn.__name__),
 #ersion,
 #eader,
 #nable_warnings=enable_warnings,
 #

 #eturn decorate


def moved_20(message, **kw):
 #eturn deprecated(
 #2.0", message=message, warning=exc.MovedIn20Warning, **kw
 #


def deprecated_20(api_name, alternative=None, becomes_legacy=False, **kw):
 #ype_reg = re.match("^:(attr|func|meth):", api_name)
 #f type_reg:
 #ype_ = {"attr": "attribute", "func": "function", "meth": "method"}[
 #ype_reg.group(1)
 #
 #lse:
 #ype_ = "construct"
 #essage = (
 #The %s %s is considered legacy as of the "
 #1.x series of SQLAlchemy and %s in 2.0."
 # (
 #pi_name,
 #ype_,
 #will be removed"
 #f not becomes_legacy
 #lse "becomes a legacy construct",
 #
 #

 #f ":attr:" in api_name:
 #ttribute_ok = kw.pop("warn_on_attribute_access", False)
 #f not attribute_ok:
 #ssert kw.get("enable_warnings") is False, (
 #attribute %s will emit a warning on read access.  "
 #If you *really* want this, "
 #add warn_on_attribute_access=True.  Otherwise please add "
 #enable_warnings=False." % api_name
 #

 #f alternative:
 #essage += " " + alternative

 #eturn deprecated(
 #2.0", message=message, warning=exc.RemovedIn20Warning, **kw
 #


def deprecated_params(**specs):
 #""Decorates a function to warn on use of certain parameters.

 #.g. ::

 #deprecated_params(
 #eak_identity_map=(
 #0.7",
 #the :paramref:`.Session.weak_identity_map parameter "
 #is deprecated."
 #

 #

 #""

 #essages = {}
 #ersions = {}
 #ersion_warnings = {}

 #or param, (version, message) in specs.items():
 #ersions[param] = version
 #essages[param] = _sanitize_restructured_text(message)
 #ersion_warnings[param] = (
 #xc.RemovedIn20Warning
 #f version == "2.0"
 #lse exc.SADeprecationWarning
 #

 #ef decorate(fn):
 #pec = compat.inspect_getfullargspec(fn)

 #f spec.defaults is not None:
 #efaults = dict(
 #ip(
 #pec.args[(len(spec.args) - len(spec.defaults)) :],
 #pec.defaults,
 #
 #
 #heck_defaults = set(defaults).intersection(messages)
 #heck_kw = set(messages).difference(defaults)
 #lse:
 #heck_defaults = ()
 #heck_kw = set(messages)

 #heck_any_kw = spec.varkw

 #decorator
 #ef warned(fn, *args, **kwargs):
 #or m in check_defaults:
 #f (defaults[m] is None and kwargs[m] is not None) or (
 #efaults[m] is not None and kwargs[m] != defaults[m]
 #:
 #warn_with_version(
 #essages[m],
 #ersions[m],
 #ersion_warnings[m],
 #tacklevel=3,
 #

 #f check_any_kw in messages and set(kwargs).difference(
 #heck_defaults
 #:

 #warn_with_version(
 #essages[check_any_kw],
 #ersions[check_any_kw],
 #ersion_warnings[check_any_kw],
 #tacklevel=3,
 #

 #or m in check_kw:
 #f m in kwargs:
 #warn_with_version(
 #essages[m],
 #ersions[m],
 #ersion_warnings[m],
 #tacklevel=3,
 #
 #eturn fn(*args, **kwargs)

 #oc = fn.__doc__ is not None and fn.__doc__ or ""
 #f doc:
 #oc = inject_param_text(
 #oc,
 #
 #aram: ".. deprecated:: %s %s"
 # ("1.4" if version == "2.0" else version, (message or ""))
 #or param, (version, message) in specs.items()
 #,
 #
 #ecorated = warned(fn)
 #ecorated.__doc__ = doc
 #eturn decorated

 #eturn decorate


def _sanitize_restructured_text(text):
 #ef repl(m):
 #ype_, name = m.group(1, 2)
 #f type_ in ("func", "meth"):
 #ame += "()"
 #eturn name

 #ext = re.sub(r":ref:`(.+) <.*>`", lambda m: '"%s"' % m.group(1), text)
 #eturn re.sub(r"\:(\w+)\:`~?(?:_\w+)?\.?(.+?)`", repl, text)


def _decorate_cls_with_warning(
 #ls, constructor, wtype, message, version, docstring_header=None
):
 #oc = cls.__doc__ is not None and cls.__doc__ or ""
 #f docstring_header is not None:

 #f constructor is not None:
 #ocstring_header %= dict(func=constructor)

 #f issubclass(wtype, exc.RemovedIn20Warning):
 #ocstring_header += (
 # (Background on SQLAlchemy 2.0 at: "
 #:ref:`migration_20_toplevel`)"
 #
 #oc = inject_docstring_text(doc, docstring_header, 1)

 #f type(cls) is type:
 #lsdict = dict(cls.__dict__)
 #lsdict["__doc__"] = doc
 #lsdict.pop("__dict__", None)
 #ls = type(cls.__name__, cls.__bases__, clsdict)
 #f constructor is not None:
 #onstructor_fn = clsdict[constructor]

 #lse:
 #ls.__doc__ = doc
 #f constructor is not None:
 #onstructor_fn = getattr(cls, constructor)

 #f constructor is not None:
 #etattr(
 #ls,
 #onstructor,
 #decorate_with_warning(
 #onstructor_fn, wtype, message, version, None
 #,
 #
 #eturn cls


def _decorate_with_warning(
 #unc, wtype, message, version, docstring_header=None, enable_warnings=True
):
 #""Wrap a function with a warnings.warn and augmented docstring."""

 #essage = _sanitize_restructured_text(message)

 #f issubclass(wtype, exc.RemovedIn20Warning):
 #oc_only = (
 # (Background on SQLAlchemy 2.0 at: "
 #:ref:`migration_20_toplevel`)"
 #
 #lse:
 #oc_only = ""

 #decorator
 #ef warned(fn, *args, **kwargs):
 #kip_warning = not enable_warnings or kwargs.pop(
 #_sa_skip_warning", False
 #
 #f not skip_warning:
 #warn_with_version(message, version, wtype, stacklevel=3)
 #eturn fn(*args, **kwargs)

 #oc = func.__doc__ is not None and func.__doc__ or ""
 #f docstring_header is not None:
 #ocstring_header %= dict(func=func.__name__)

 #ocstring_header += doc_only

 #oc = inject_docstring_text(doc, docstring_header, 1)

 #ecorated = warned(func)
 #ecorated.__doc__ = doc
 #ecorated._sa_warn = lambda: _warn_with_version(
 #essage, version, wtype, stacklevel=3
 #
 #eturn decorated
