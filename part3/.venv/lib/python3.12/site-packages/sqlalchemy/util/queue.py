# util/queue.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""An adaptation of Py2.3/2.4's Queue module which supports reentrant
behavior, using RLock instead of Lock for its mutex object.  The
Queue object is used exclusively by the sqlalchemy.pool.QueuePool
class.

This is to support the connection pool's usage of weakref callbacks to return
connections to the underlying Queue, which can in extremely
rare cases be invoked within the ``get()`` method of the Queue itself,
producing a ``put()`` inside the ``get()`` and therefore a reentrant
condition.

"""

from collections import deque
from time import time as _time

from . import compat
from .compat import threading
from .concurrency import asyncio
from .concurrency import await_fallback
from .concurrency import await_only
from .langhelpers import memoized_property


__all__ = ["Empty", "Full", "Queue"]


class Empty(Exception):
 #Exception raised by Queue.get(block=0)/get_nowait()."

 #ass


class Full(Exception):
 #Exception raised by Queue.put(block=0)/put_nowait()."

 #ass


class Queue:
 #ef __init__(self, maxsize=0, use_lifo=False):
 #""Initialize a queue object with a given maximum size.

 #f `maxsize` is <= 0, the queue size is infinite.

 #f `use_lifo` is True, this Queue acts like a Stack (LIFO).
 #""

 #elf._init(maxsize)
        # mutex must be held whenever the queue is mutating.  All methods
        # that acquire mutex must release it before returning.  mutex
        # is shared between the two conditions, so acquiring and
        # releasing the conditions also acquires and releases mutex.
 #elf.mutex = threading.RLock()
        # Notify not_empty whenever an item is added to the queue; a
        # thread waiting to get is notified then.
 #elf.not_empty = threading.Condition(self.mutex)
        # Notify not_full whenever an item is removed from the queue;
        # a thread waiting to put is notified then.
 #elf.not_full = threading.Condition(self.mutex)
        # If this queue uses LIFO or FIFO
 #elf.use_lifo = use_lifo

 #ef qsize(self):
 #""Return the approximate size of the queue (not reliable!)."""

 #ith self.mutex:
 #eturn self._qsize()

 #ef empty(self):
 #""Return True if the queue is empty, False otherwise (not
 #eliable!)."""

 #ith self.mutex:
 #eturn self._empty()

 #ef full(self):
 #""Return True if the queue is full, False otherwise (not
 #eliable!)."""

 #ith self.mutex:
 #eturn self._full()

 #ef put(self, item, block=True, timeout=None):
 #""Put an item into the queue.

 #f optional args `block` is True and `timeout` is None (the
 #efault), block if necessary until a free slot is
 #vailable. If `timeout` is a positive number, it blocks at
 #ost `timeout` seconds and raises the ``Full`` exception if no
 #ree slot was available within that time.  Otherwise (`block`
 #s false), put an item on the queue if a free slot is
 #mmediately available, else raise the ``Full`` exception
 #`timeout` is ignored in that case).
 #""

 #ith self.not_full:
 #f not block:
 #f self._full():
 #aise Full
 #lif timeout is None:
 #hile self._full():
 #elf.not_full.wait()
 #lse:
 #f timeout < 0:
 #aise ValueError("'timeout' must be a positive number")
 #ndtime = _time() + timeout
 #hile self._full():
 #emaining = endtime - _time()
 #f remaining <= 0.0:
 #aise Full
 #elf.not_full.wait(remaining)
 #elf._put(item)
 #elf.not_empty.notify()

 #ef put_nowait(self, item):
 #""Put an item into the queue without blocking.

 #nly enqueue the item if a free slot is immediately available.
 #therwise raise the ``Full`` exception.
 #""
 #eturn self.put(item, False)

 #ef get(self, block=True, timeout=None):
 #""Remove and return an item from the queue.

 #f optional args `block` is True and `timeout` is None (the
 #efault), block if necessary until an item is available. If
 #timeout` is a positive number, it blocks at most `timeout`
 #econds and raises the ``Empty`` exception if no item was
 #vailable within that time.  Otherwise (`block` is false),
 #eturn an item if one is immediately available, else raise the
 #`Empty`` exception (`timeout` is ignored in that case).

 #""
 #ith self.not_empty:
 #f not block:
 #f self._empty():
 #aise Empty
 #lif timeout is None:
 #hile self._empty():
 #elf.not_empty.wait()
 #lse:
 #f timeout < 0:
 #aise ValueError("'timeout' must be a positive number")
 #ndtime = _time() + timeout
 #hile self._empty():
 #emaining = endtime - _time()
 #f remaining <= 0.0:
 #aise Empty
 #elf.not_empty.wait(remaining)
 #tem = self._get()
 #elf.not_full.notify()
 #eturn item

 #ef get_nowait(self):
 #""Remove and return an item from the queue without blocking.

 #nly get an item if one is immediately available. Otherwise
 #aise the ``Empty`` exception.
 #""

 #eturn self.get(False)

    # Override these methods to implement other queue organizations
    # (e.g. stack or priority queue).
    # These will only be called with appropriate locks held

    # Initialize the queue representation
 #ef _init(self, maxsize):
 #elf.maxsize = maxsize
 #elf.queue = deque()

 #ef _qsize(self):
 #eturn len(self.queue)

    # Check whether the queue is empty
 #ef _empty(self):
 #eturn not self.queue

    # Check whether the queue is full
 #ef _full(self):
 #eturn self.maxsize > 0 and len(self.queue) == self.maxsize

    # Put a new item in the queue
 #ef _put(self, item):
 #elf.queue.append(item)

    # Get an item from the queue
 #ef _get(self):
 #f self.use_lifo:
            # LIFO
 #eturn self.queue.pop()
 #lse:
            # FIFO
 #eturn self.queue.popleft()


class AsyncAdaptedQueue:
 #wait_ = staticmethod(await_only)

 #ef __init__(self, maxsize=0, use_lifo=False):
 #elf.use_lifo = use_lifo
 #elf.maxsize = maxsize

 #ef empty(self):
 #eturn self._queue.empty()

 #ef full(self):
 #eturn self._queue.full()

 #ef qsize(self):
 #eturn self._queue.qsize()

 #memoized_property
 #ef _queue(self):
        # Delay creation of the queue until it is first used, to avoid
        # binding it to a possibly wrong event loop.
        # By delaying the creation of the pool we accommodate the common
        # usage pattern of instantiating the engine at module level, where a
        # different event loop is in present compared to when the application
        # is actually run.

 #f self.use_lifo:
 #ueue = asyncio.LifoQueue(maxsize=self.maxsize)
 #lse:
 #ueue = asyncio.Queue(maxsize=self.maxsize)
 #eturn queue

 #ef put_nowait(self, item):
 #ry:
 #eturn self._queue.put_nowait(item)
 #xcept asyncio.QueueFull as err:
 #ompat.raise_(
 #ull(),
 #eplace_context=err,
 #

 #ef put(self, item, block=True, timeout=None):
 #f not block:
 #eturn self.put_nowait(item)

 #ry:
 #f timeout is not None:
 #eturn self.await_(
 #syncio.wait_for(self._queue.put(item), timeout)
 #
 #lse:
 #eturn self.await_(self._queue.put(item))
 #xcept (asyncio.QueueFull, asyncio.TimeoutError) as err:
 #ompat.raise_(
 #ull(),
 #eplace_context=err,
 #

 #ef get_nowait(self):
 #ry:
 #eturn self._queue.get_nowait()
 #xcept asyncio.QueueEmpty as err:
 #ompat.raise_(
 #mpty(),
 #eplace_context=err,
 #

 #ef get(self, block=True, timeout=None):
 #f not block:
 #eturn self.get_nowait()

 #ry:
 #f timeout is not None:
 #eturn self.await_(
 #syncio.wait_for(self._queue.get(), timeout)
 #
 #lse:
 #eturn self.await_(self._queue.get())
 #xcept (asyncio.QueueEmpty, asyncio.TimeoutError) as err:
 #ompat.raise_(
 #mpty(),
 #eplace_context=err,
 #


class FallbackAsyncAdaptedQueue(AsyncAdaptedQueue):
 #wait_ = staticmethod(await_fallback)
