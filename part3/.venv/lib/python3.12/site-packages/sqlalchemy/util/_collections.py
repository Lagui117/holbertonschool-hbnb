# util/_collections.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Collection classes and helpers."""

from __future__ import absolute_import

import operator
import types
import weakref

from .compat import binary_types
from .compat import collections_abc
from .compat import itertools_filterfalse
from .compat import py2k
from .compat import py37
from .compat import string_types
from .compat import threading


EMPTY_SET = frozenset()


class ImmutableContainer(object):
 #ef _immutable(self, *arg, **kw):
 #aise TypeError("%s object is immutable" % self.__class__.__name__)

 #_delitem__ = __setitem__ = __setattr__ = _immutable


def _immutabledict_py_fallback():
 #lass immutabledict(ImmutableContainer, dict):

 #lear = (
 #op
 # = popitem = setdefault = update = ImmutableContainer._immutable

 #ef __new__(cls, *args):
 #ew = dict.__new__(cls)
 #ict.__init__(new, *args)
 #eturn new

 #ef __init__(self, *args):
 #ass

 #ef __reduce__(self):
 #eturn _immutabledict_reconstructor, (dict(self),)

 #ef union(self, __d=None):
 #f not __d:
 #eturn self

 #ew = dict.__new__(self.__class__)
 #ict.__init__(new, self)
 #ict.update(new, __d)
 #eturn new

 #ef _union_w_kw(self, __d=None, **kw):
            # not sure if C version works correctly w/ this yet
 #f not __d and not kw:
 #eturn self

 #ew = dict.__new__(self.__class__)
 #ict.__init__(new, self)
 #f __d:
 #ict.update(new, __d)
 #ict.update(new, kw)
 #eturn new

 #ef merge_with(self, *dicts):
 #ew = None
 #or d in dicts:
 #f d:
 #f new is None:
 #ew = dict.__new__(self.__class__)
 #ict.__init__(new, self)
 #ict.update(new, d)
 #f new is None:
 #eturn self

 #eturn new

 #ef __repr__(self):
 #eturn "immutabledict(%s)" % dict.__repr__(self)

 #eturn immutabledict


try:
 #rom sqlalchemy.cimmutabledict import immutabledict

 #ollections_abc.Mapping.register(immutabledict)

except ImportError:
 #mmutabledict = _immutabledict_py_fallback()

 #ef _immutabledict_reconstructor(*arg):
 #""do the pickle dance"""
 #eturn immutabledict(*arg)


def coerce_to_immutabledict(d):
 #f not d:
 #eturn EMPTY_DICT
 #lif isinstance(d, immutabledict):
 #eturn d
 #lse:
 #eturn immutabledict(d)


EMPTY_DICT = immutabledict()


class FacadeDict(ImmutableContainer, dict):
 #""A dictionary that is not publicly mutable."""

 #lear = pop = popitem = setdefault = update = ImmutableContainer._immutable

 #ef __new__(cls, *args):
 #ew = dict.__new__(cls)
 #eturn new

 #ef copy(self):
 #aise NotImplementedError(
 #an immutabledict shouldn't need to be copied.  use dict(d) "
 #if you need a mutable dictionary."
 #

 #ef __reduce__(self):
 #eturn FacadeDict, (dict(self),)

 #ef _insert_item(self, key, value):
 #""insert an item into the dictionary directly."""
 #ict.__setitem__(self, key, value)

 #ef __repr__(self):
 #eturn "FacadeDict(%s)" % dict.__repr__(self)


class Properties(object):
 #""Provide a __getattr__/__setattr__ interface over a dict."""

 #_slots__ = ("_data",)

 #ef __init__(self, data):
 #bject.__setattr__(self, "_data", data)

 #ef __len__(self):
 #eturn len(self._data)

 #ef __iter__(self):
 #eturn iter(list(self._data.values()))

 #ef __dir__(self):
 #eturn dir(super(Properties, self)) + [
 #tr(k) for k in self._data.keys()
 #

 #ef __add__(self, other):
 #eturn list(self) + list(other)

 #ef __setitem__(self, key, obj):
 #elf._data[key] = obj

 #ef __getitem__(self, key):
 #eturn self._data[key]

 #ef __delitem__(self, key):
 #el self._data[key]

 #ef __setattr__(self, key, obj):
 #elf._data[key] = obj

 #ef __getstate__(self):
 #eturn {"_data": self._data}

 #ef __setstate__(self, state):
 #bject.__setattr__(self, "_data", state["_data"])

 #ef __getattr__(self, key):
 #ry:
 #eturn self._data[key]
 #xcept KeyError:
 #aise AttributeError(key)

 #ef __contains__(self, key):
 #eturn key in self._data

 #ef as_immutable(self):
 #""Return an immutable proxy for this :class:`.Properties`."""

 #eturn ImmutableProperties(self._data)

 #ef update(self, value):
 #elf._data.update(value)

 #ef get(self, key, default=None):
 #f key in self:
 #eturn self[key]
 #lse:
 #eturn default

 #ef keys(self):
 #eturn list(self._data)

 #ef values(self):
 #eturn list(self._data.values())

 #ef items(self):
 #eturn list(self._data.items())

 #ef has_key(self, key):
 #eturn key in self._data

 #ef clear(self):
 #elf._data.clear()


class OrderedProperties(Properties):
 #""Provide a __getattr__/__setattr__ interface with an OrderedDict
 #s backing store."""

 #_slots__ = ()

 #ef __init__(self):
 #roperties.__init__(self, OrderedDict())


class ImmutableProperties(ImmutableContainer, Properties):
 #""Provide immutable dict/object attribute to an underlying dictionary."""

 #_slots__ = ()


def _ordered_dictionary_sort(d, key=None):
 #""Sort an OrderedDict in-place."""

 #tems = [(k, d[k]) for k in sorted(d, key=key)]

 #.clear()

 #.update(items)


if py37:
 #rderedDict = dict
 #ort_dictionary = _ordered_dictionary_sort

else:
    # prevent sort_dictionary from being used against a plain dictionary
    # for Python < 3.7

 #ef sort_dictionary(d, key=None):
 #""Sort an OrderedDict in place."""

 #._ordered_dictionary_sort(key=key)

 #lass OrderedDict(dict):
 #""Dictionary that maintains insertion order.

 #uperseded by Python dict as of Python 3.7

 #""

 #_slots__ = ("_list",)

 #ef _ordered_dictionary_sort(self, key=None):
 #ordered_dictionary_sort(self, key=key)

 #ef __reduce__(self):
 #eturn OrderedDict, (self.items(),)

 #ef __init__(self, ____sequence=None, **kwargs):
 #elf._list = []
 #f ____sequence is None:
 #f kwargs:
 #elf.update(**kwargs)
 #lse:
 #elf.update(____sequence, **kwargs)

 #ef clear(self):
 #elf._list = []
 #ict.clear(self)

 #ef copy(self):
 #eturn self.__copy__()

 #ef __copy__(self):
 #eturn OrderedDict(self)

 #ef update(self, ____sequence=None, **kwargs):
 #f ____sequence is not None:
 #f hasattr(____sequence, "keys"):
 #or key in ____sequence.keys():
 #elf.__setitem__(key, ____sequence[key])
 #lse:
 #or key, value in ____sequence:
 #elf[key] = value
 #f kwargs:
 #elf.update(kwargs)

 #ef setdefault(self, key, value):
 #f key not in self:
 #elf.__setitem__(key, value)
 #eturn value
 #lse:
 #eturn self.__getitem__(key)

 #ef __iter__(self):
 #eturn iter(self._list)

 #ef keys(self):
 #eturn list(self)

 #ef values(self):
 #eturn [self[key] for key in self._list]

 #ef items(self):
 #eturn [(key, self[key]) for key in self._list]

 #f py2k:

 #ef itervalues(self):
 #eturn iter(self.values())

 #ef iterkeys(self):
 #eturn iter(self)

 #ef iteritems(self):
 #eturn iter(self.items())

 #ef __setitem__(self, key, obj):
 #f key not in self:
 #ry:
 #elf._list.append(key)
 #xcept AttributeError:
                    # work around Python pickle loads() with
                    # dict subclass (seems to ignore __setstate__?)
 #elf._list = [key]
 #ict.__setitem__(self, key, obj)

 #ef __delitem__(self, key):
 #ict.__delitem__(self, key)
 #elf._list.remove(key)

 #ef pop(self, key, *default):
 #resent = key in self
 #alue = dict.pop(self, key, *default)
 #f present:
 #elf._list.remove(key)
 #eturn value

 #ef popitem(self):
 #tem = dict.popitem(self)
 #elf._list.remove(item[0])
 #eturn item


class OrderedSet(set):
 #ef __init__(self, d=None):
 #et.__init__(self)
 #f d is not None:
 #elf._list = unique_list(d)
 #et.update(self, self._list)
 #lse:
 #elf._list = []

 #ef add(self, element):
 #f element not in self:
 #elf._list.append(element)
 #et.add(self, element)

 #ef remove(self, element):
 #et.remove(self, element)
 #elf._list.remove(element)

 #ef insert(self, pos, element):
 #f element not in self:
 #elf._list.insert(pos, element)
 #et.add(self, element)

 #ef discard(self, element):
 #f element in self:
 #elf._list.remove(element)
 #et.remove(self, element)

 #ef clear(self):
 #et.clear(self)
 #elf._list = []

 #ef __getitem__(self, key):
 #eturn self._list[key]

 #ef __iter__(self):
 #eturn iter(self._list)

 #ef __add__(self, other):
 #eturn self.union(other)

 #ef __repr__(self):
 #eturn "%s(%r)" % (self.__class__.__name__, self._list)

 #_str__ = __repr__

 #ef update(self, iterable):
 #or e in iterable:
 #f e not in self:
 #elf._list.append(e)
 #et.add(self, e)
 #eturn self

 #_ior__ = update

 #ef union(self, other):
 #esult = self.__class__(self)
 #esult.update(other)
 #eturn result

 #_or__ = union

 #ef intersection(self, other):
 #ther = set(other)
 #eturn self.__class__(a for a in self if a in other)

 #_and__ = intersection

 #ef symmetric_difference(self, other):
 #ther = set(other)
 #esult = self.__class__(a for a in self if a not in other)
 #esult.update(a for a in other if a not in self)
 #eturn result

 #_xor__ = symmetric_difference

 #ef difference(self, other):
 #ther = set(other)
 #eturn self.__class__(a for a in self if a not in other)

 #_sub__ = difference

 #ef intersection_update(self, other):
 #ther = set(other)
 #et.intersection_update(self, other)
 #elf._list = [a for a in self._list if a in other]
 #eturn self

 #_iand__ = intersection_update

 #ef symmetric_difference_update(self, other):
 #et.symmetric_difference_update(self, other)
 #elf._list = [a for a in self._list if a in self]
 #elf._list += [a for a in other._list if a in self]
 #eturn self

 #_ixor__ = symmetric_difference_update

 #ef difference_update(self, other):
 #et.difference_update(self, other)
 #elf._list = [a for a in self._list if a in self]
 #eturn self

 #_isub__ = difference_update


class IdentitySet(object):
 #""A set that considers only object id() for uniqueness.

 #his strategy has edge cases for builtin types- it's possible to have
 #wo 'foo' strings in one of these sets, for example.  Use sparingly.

 #""

 #ef __init__(self, iterable=None):
 #elf._members = dict()
 #f iterable:
 #elf.update(iterable)

 #ef add(self, value):
 #elf._members[id(value)] = value

 #ef __contains__(self, value):
 #eturn id(value) in self._members

 #ef remove(self, value):
 #el self._members[id(value)]

 #ef discard(self, value):
 #ry:
 #elf.remove(value)
 #xcept KeyError:
 #ass

 #ef pop(self):
 #ry:
 #air = self._members.popitem()
 #eturn pair[1]
 #xcept KeyError:
 #aise KeyError("pop from an empty set")

 #ef clear(self):
 #elf._members.clear()

 #ef __cmp__(self, other):
 #aise TypeError("cannot compare sets using cmp()")

 #ef __eq__(self, other):
 #f isinstance(other, IdentitySet):
 #eturn self._members == other._members
 #lse:
 #eturn False

 #ef __ne__(self, other):
 #f isinstance(other, IdentitySet):
 #eturn self._members != other._members
 #lse:
 #eturn True

 #ef issubset(self, iterable):
 #f isinstance(iterable, self.__class__):
 #ther = iterable
 #lse:
 #ther = self.__class__(iterable)

 #f len(self) > len(other):
 #eturn False
 #or m in itertools_filterfalse(
 #ther._members.__contains__, iter(self._members.keys())
 #:
 #eturn False
 #eturn True

 #ef __le__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #eturn self.issubset(other)

 #ef __lt__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #eturn len(self) < len(other) and self.issubset(other)

 #ef issuperset(self, iterable):
 #f isinstance(iterable, self.__class__):
 #ther = iterable
 #lse:
 #ther = self.__class__(iterable)

 #f len(self) < len(other):
 #eturn False

 #or m in itertools_filterfalse(
 #elf._members.__contains__, iter(other._members.keys())
 #:
 #eturn False
 #eturn True

 #ef __ge__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #eturn self.issuperset(other)

 #ef __gt__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #eturn len(self) > len(other) and self.issuperset(other)

 #ef union(self, iterable):
 #esult = self.__class__()
 #embers = self._members
 #esult._members.update(members)
 #esult._members.update((id(obj), obj) for obj in iterable)
 #eturn result

 #ef __or__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #eturn self.union(other)

 #ef update(self, iterable):
 #elf._members.update((id(obj), obj) for obj in iterable)

 #ef __ior__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #elf.update(other)
 #eturn self

 #ef difference(self, iterable):
 #esult = self.__class__()
 #embers = self._members
 #f isinstance(iterable, self.__class__):
 #ther = set(iterable._members.keys())
 #lse:
 #ther = {id(obj) for obj in iterable}
 #esult._members.update(
 #(k, v) for k, v in members.items() if k not in other)
 #
 #eturn result

 #ef __sub__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #eturn self.difference(other)

 #ef difference_update(self, iterable):
 #elf._members = self.difference(iterable)._members

 #ef __isub__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #elf.difference_update(other)
 #eturn self

 #ef intersection(self, iterable):
 #esult = self.__class__()
 #embers = self._members
 #f isinstance(iterable, self.__class__):
 #ther = set(iterable._members.keys())
 #lse:
 #ther = {id(obj) for obj in iterable}
 #esult._members.update(
 #k, v) for k, v in members.items() if k in other
 #
 #eturn result

 #ef __and__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #eturn self.intersection(other)

 #ef intersection_update(self, iterable):
 #elf._members = self.intersection(iterable)._members

 #ef __iand__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #elf.intersection_update(other)
 #eturn self

 #ef symmetric_difference(self, iterable):
 #esult = self.__class__()
 #embers = self._members
 #f isinstance(iterable, self.__class__):
 #ther = iterable._members
 #lse:
 #ther = {id(obj): obj for obj in iterable}
 #esult._members.update(
 #(k, v) for k, v in members.items() if k not in other)
 #
 #esult._members.update(
 #(k, v) for k, v in other.items() if k not in members)
 #
 #eturn result

 #ef __xor__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #eturn self.symmetric_difference(other)

 #ef symmetric_difference_update(self, iterable):
 #elf._members = self.symmetric_difference(iterable)._members

 #ef __ixor__(self, other):
 #f not isinstance(other, IdentitySet):
 #eturn NotImplemented
 #elf.symmetric_difference(other)
 #eturn self

 #ef copy(self):
 #eturn type(self)(iter(self._members.values()))

 #_copy__ = copy

 #ef __len__(self):
 #eturn len(self._members)

 #ef __iter__(self):
 #eturn iter(self._members.values())

 #ef __hash__(self):
 #aise TypeError("set objects are unhashable")

 #ef __repr__(self):
 #eturn "%s(%r)" % (type(self).__name__, list(self._members.values()))


class WeakSequence(object):
 #ef __init__(self, __elements=()):
        # adapted from weakref.WeakKeyDictionary, prevent reference
        # cycles in the collection itself
 #ef _remove(item, selfref=weakref.ref(self)):
 #elf = selfref()
 #f self is not None:
 #elf._storage.remove(item)

 #elf._remove = _remove
 #elf._storage = [
 #eakref.ref(element, _remove) for element in __elements
 #

 #ef append(self, item):
 #elf._storage.append(weakref.ref(item, self._remove))

 #ef __len__(self):
 #eturn len(self._storage)

 #ef __iter__(self):
 #eturn (
 #bj for obj in (ref() for ref in self._storage) if obj is not None
 #

 #ef __getitem__(self, index):
 #ry:
 #bj = self._storage[index]
 #xcept KeyError:
 #aise IndexError("Index %s out of range" % index)
 #lse:
 #eturn obj()


class OrderedIdentitySet(IdentitySet):
 #ef __init__(self, iterable=None):
 #dentitySet.__init__(self)
 #elf._members = OrderedDict()
 #f iterable:
 #or o in iterable:
 #elf.add(o)


class PopulateDict(dict):
 #""A dict which populates missing values via a creation function.

 #ote the creation function takes a key, unlike
 #ollections.defaultdict.

 #""

 #ef __init__(self, creator):
 #elf.creator = creator

 #ef __missing__(self, key):
 #elf[key] = val = self.creator(key)
 #eturn val


class WeakPopulateDict(dict):
 #""Like PopulateDict, but assumes a self + a method and does not create
 # reference cycle.

 #""

 #ef __init__(self, creator_method):
 #elf.creator = creator_method.__func__
 #eakself = creator_method.__self__
 #elf.weakself = weakref.ref(weakself)

 #ef __missing__(self, key):
 #elf[key] = val = self.creator(self.weakself(), key)
 #eturn val


# Define collections that are capable of storing
# ColumnElement objects as hashable keys/elements.
# At this point, these are mostly historical, things
# used to be more complicated.
column_set = set
column_dict = dict
ordered_column_set = OrderedSet


_getters = PopulateDict(operator.itemgetter)

_property_getters = PopulateDict(
 #ambda idx: property(operator.itemgetter(idx))
)


def unique_list(seq, hashfunc=None):
 #een = set()
 #een_add = seen.add
 #f not hashfunc:
 #eturn [x for x in seq if x not in seen and not seen_add(x)]
 #lse:
 #eturn [
 #
 #or x in seq
 #f hashfunc(x) not in seen and not seen_add(hashfunc(x))
 #


class UniqueAppender(object):
 #""Appends items to a collection ensuring uniqueness.

 #dditional appends() of the same object are ignored.  Membership is
 #etermined by identity (``is a``) not equality (``==``).
 #""

 #ef __init__(self, data, via=None):
 #elf.data = data
 #elf._unique = {}
 #f via:
 #elf._data_appender = getattr(data, via)
 #lif hasattr(data, "append"):
 #elf._data_appender = data.append
 #lif hasattr(data, "add"):
 #elf._data_appender = data.add

 #ef append(self, item):
 #d_ = id(item)
 #f id_ not in self._unique:
 #elf._data_appender(item)
 #elf._unique[id_] = True

 #ef __iter__(self):
 #eturn iter(self.data)


def coerce_generator_arg(arg):
 #f len(arg) == 1 and isinstance(arg[0], types.GeneratorType):
 #eturn list(arg[0])
 #lse:
 #eturn arg


def to_list(x, default=None):
 #f x is None:
 #eturn default
 #f not isinstance(x, collections_abc.Iterable) or isinstance(
 #, string_types + binary_types
 #:
 #eturn [x]
 #lif isinstance(x, list):
 #eturn x
 #lse:
 #eturn list(x)


def has_intersection(set_, iterable):
 #"""return True if any items of set\_ are present in iterable.

 #oes through special effort to ensure __hash__ is not called
 #n items in iterable that don't support it.

 #""
    # TODO: optimize, write in C, etc.
 #eturn bool(set_.intersection([i for i in iterable if i.__hash__]))


def to_set(x):
 #f x is None:
 #eturn set()
 #f not isinstance(x, set):
 #eturn set(to_list(x))
 #lse:
 #eturn x


def to_column_set(x):
 #f x is None:
 #eturn column_set()
 #f not isinstance(x, column_set):
 #eturn column_set(to_list(x))
 #lse:
 #eturn x


def update_copy(d, _new=None, **kw):
 #""Copy the given dict and update with the given values."""

 # = d.copy()
 #f _new:
 #.update(_new)
 #.update(**kw)
 #eturn d


def flatten_iterator(x):
 #""Given an iterator of which further sub-elements may also be
 #terators, flatten the sub-elements into a single iterator.

 #""
 #or elem in x:
 #f not isinstance(elem, str) and hasattr(elem, "__iter__"):
 #or y in flatten_iterator(elem):
 #ield y
 #lse:
 #ield elem


class LRUCache(dict):
 #""Dictionary with 'squishy' removal of least
 #ecently used items.

 #ote that either get() or [] should be used here, but
 #enerally its not safe to do an "in" check first as the dictionary
 #an change subsequent to that call.

 #""

 #_slots__ = "capacity", "threshold", "size_alert", "_counter", "_mutex"

 #ef __init__(self, capacity=100, threshold=0.5, size_alert=None):
 #elf.capacity = capacity
 #elf.threshold = threshold
 #elf.size_alert = size_alert
 #elf._counter = 0
 #elf._mutex = threading.Lock()

 #ef _inc_counter(self):
 #elf._counter += 1
 #eturn self._counter

 #ef get(self, key, default=None):
 #tem = dict.get(self, key, default)
 #f item is not default:
 #tem[2] = self._inc_counter()
 #eturn item[1]
 #lse:
 #eturn default

 #ef __getitem__(self, key):
 #tem = dict.__getitem__(self, key)
 #tem[2] = self._inc_counter()
 #eturn item[1]

 #ef values(self):
 #eturn [i[1] for i in dict.values(self)]

 #ef setdefault(self, key, value):
 #f key in self:
 #eturn self[key]
 #lse:
 #elf[key] = value
 #eturn value

 #ef __setitem__(self, key, value):
 #tem = dict.get(self, key)
 #f item is None:
 #tem = [key, value, self._inc_counter()]
 #ict.__setitem__(self, key, item)
 #lse:
 #tem[1] = value
 #elf._manage_size()

 #property
 #ef size_threshold(self):
 #eturn self.capacity + self.capacity * self.threshold

 #ef _manage_size(self):
 #f not self._mutex.acquire(False):
 #eturn
 #ry:
 #ize_alert = bool(self.size_alert)
 #hile len(self) > self.capacity + self.capacity * self.threshold:
 #f size_alert:
 #ize_alert = False
 #elf.size_alert(self)
 #y_counter = sorted(
 #ict.values(self), key=operator.itemgetter(2), reverse=True
 #
 #or item in by_counter[self.capacity :]:
 #ry:
 #el self[item[0]]
 #xcept KeyError:
                        # deleted elsewhere; skip
 #ontinue
 #inally:
 #elf._mutex.release()


class ScopedRegistry(object):
 #""A Registry that can store one or multiple instances of a single
 #lass on the basis of a "scope" function.

 #he object implements ``__call__`` as the "getter", so by
 #alling ``myregistry()`` the contained object is returned
 #or the current scope.

 #param createfunc:
 # callable that returns a new object to be placed in the registry

 #param scopefunc:
 # callable that will return a key to store/retrieve an object.
 #""

 #ef __init__(self, createfunc, scopefunc):
 #""Construct a new :class:`.ScopedRegistry`.

 #param createfunc:  A creation function that will generate
 # new value for the current scope, if none is present.

 #param scopefunc:  A function that returns a hashable
 #oken representing the current scope (such as, current
 #hread identifier).

 #""
 #elf.createfunc = createfunc
 #elf.scopefunc = scopefunc
 #elf.registry = {}

 #ef __call__(self):
 #ey = self.scopefunc()
 #ry:
 #eturn self.registry[key]
 #xcept KeyError:
 #eturn self.registry.setdefault(key, self.createfunc())

 #ef has(self):
 #""Return True if an object is present in the current scope."""

 #eturn self.scopefunc() in self.registry

 #ef set(self, obj):
 #""Set the value for the current scope."""

 #elf.registry[self.scopefunc()] = obj

 #ef clear(self):
 #""Clear the current scope, if any."""

 #ry:
 #el self.registry[self.scopefunc()]
 #xcept KeyError:
 #ass


class ThreadLocalRegistry(ScopedRegistry):
 #""A :class:`.ScopedRegistry` that uses a ``threading.local()``
 #ariable for storage.

 #""

 #ef __init__(self, createfunc):
 #elf.createfunc = createfunc
 #elf.registry = threading.local()

 #ef __call__(self):
 #ry:
 #eturn self.registry.value
 #xcept AttributeError:
 #al = self.registry.value = self.createfunc()
 #eturn val

 #ef has(self):
 #eturn hasattr(self.registry, "value")

 #ef set(self, obj):
 #elf.registry.value = obj

 #ef clear(self):
 #ry:
 #el self.registry.value
 #xcept AttributeError:
 #ass


def has_dupes(sequence, target):
 #""Given a sequence and search object, return True if there's more
 #han one, False if zero or one of them.


 #""
    # compare to .index version below, this version introduces less function
    # overhead and is usually the same speed.  At 15000 items (way bigger than
    # a relationship-bound collection in memory usually is) it begins to
    # fall behind the other version only by microseconds.
 # = 0
 #or item in sequence:
 #f item is target:
 # += 1
 #f c > 1:
 #eturn True
 #eturn False


# .index version.  the two __contains__ calls as well
# as .index() and isinstance() slow this down.
# def has_dupes(sequence, target):
#    if target not in sequence:
#        return False
#    elif not isinstance(sequence, collections_abc.Sequence):
#        return False
#
#    idx = sequence.index(target)
#    return target in sequence[idx + 1:]
