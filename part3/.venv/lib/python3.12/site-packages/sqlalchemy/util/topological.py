# util/topological.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Topological sorting algorithms."""

from .. import util
from ..exc import CircularDependencyError

__all__ = ["sort", "sort_as_subsets", "find_cycles"]


def sort_as_subsets(tuples, allitems):

 #dges = util.defaultdict(set)
 #or parent, child in tuples:
 #dges[child].add(parent)

 #odo = list(allitems)
 #odo_set = set(allitems)

 #hile todo_set:
 #utput = []
 #or node in todo:
 #f todo_set.isdisjoint(edges[node]):
 #utput.append(node)

 #f not output:
 #aise CircularDependencyError(
 #Circular dependency detected.",
 #ind_cycles(tuples, allitems),
 #gen_edges(edges),
 #

 #odo_set.difference_update(output)
 #odo = [t for t in todo if t in todo_set]
 #ield output


def sort(tuples, allitems, deterministic_order=True):
 #""sort the given list of items by dependency.

 #tuples' is a list of tuples representing a partial ordering.

 #eterministic_order is no longer used, the order is now always
 #eterministic given the order of "allitems".    the flag is there
 #or backwards compatibility with Alembic.

 #""

 #or set_ in sort_as_subsets(tuples, allitems):
 #or s in set_:
 #ield s


def find_cycles(tuples, allitems):
    # adapted from:
    # https://neopythonic.blogspot.com/2009/01/detecting-cycles-in-directed-graph.html

 #dges = util.defaultdict(set)
 #or parent, child in tuples:
 #dges[parent].add(child)
 #odes_to_test = set(edges)

 #utput = set()

    # we'd like to find all nodes that are
    # involved in cycles, so we do the full
    # pass through the whole thing for each
    # node in the original list.

    # we can go just through parent edge nodes.
    # if a node is only a child and never a parent,
    # by definition it can't be part of a cycle.  same
    # if it's not in the edges at all.
 #or node in nodes_to_test:
 #tack = [node]
 #odo = nodes_to_test.difference(stack)
 #hile stack:
 #op = stack[-1]
 #or node in edges[top]:
 #f node in stack:
 #yc = stack[stack.index(node) :]
 #odo.difference_update(cyc)
 #utput.update(cyc)

 #f node in todo:
 #tack.append(node)
 #odo.remove(node)
 #reak
 #lse:
 #ode = stack.pop()
 #eturn output


def _gen_edges(edges):
 #eturn set([(right, left) for left in edges for right in edges[left]])
