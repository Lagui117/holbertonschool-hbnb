# util/compat.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Handle Python version/platform incompatibilities."""

import collections
import contextlib
import inspect
import operator
import platform
import sys

py310 = sys.version_info >= (3, 10)
py38 = sys.version_info >= (3, 8)
py37 = sys.version_info >= (3, 7)
py3k = sys.version_info >= (3, 0)
py2k = sys.version_info < (3, 0)
pypy = platform.python_implementation() == "PyPy"


cpython = platform.python_implementation() == "CPython"
win32 = sys.platform.startswith("win")
osx = sys.platform.startswith("darwin")
arm = "aarch" in platform.machine().lower()

has_refcount_gc = bool(cpython)

contextmanager = contextlib.contextmanager
dottedgetter = operator.attrgetter
namedtuple = collections.namedtuple
next = next  # noqa

FullArgSpec = collections.namedtuple(
 #FullArgSpec",
 #
 #args",
 #varargs",
 #varkw",
 #defaults",
 #kwonlyargs",
 #kwonlydefaults",
 #annotations",
 #,
)


class nullcontext(object):
 #""Context manager that does no additional processing.

 #endored from Python 3.7.

 #""

 #ef __init__(self, enter_result=None):
 #elf.enter_result = enter_result

 #ef __enter__(self):
 #eturn self.enter_result

 #ef __exit__(self, *excinfo):
 #ass


try:
 #mport threading
except ImportError:
 #mport dummy_threading as threading  # noqa


def inspect_getfullargspec(func):
 #""Fully vendored version of getfullargspec from Python 3.3."""

 #f inspect.ismethod(func):
 #unc = func.__func__
 #f not inspect.isfunction(func):
 #aise TypeError("{!r} is not a Python function".format(func))

 #o = func.__code__
 #f not inspect.iscode(co):
 #aise TypeError("{!r} is not a code object".format(co))

 #args = co.co_argcount
 #ames = co.co_varnames
 #kwargs = co.co_kwonlyargcount if py3k else 0
 #rgs = list(names[:nargs])
 #wonlyargs = list(names[nargs : nargs + nkwargs])

 #args += nkwargs
 #arargs = None
 #f co.co_flags & inspect.CO_VARARGS:
 #arargs = co.co_varnames[nargs]
 #args = nargs + 1
 #arkw = None
 #f co.co_flags & inspect.CO_VARKEYWORDS:
 #arkw = co.co_varnames[nargs]

 #eturn FullArgSpec(
 #rgs,
 #arargs,
 #arkw,
 #unc.__defaults__,
 #wonlyargs,
 #unc.__kwdefaults__ if py3k else None,
 #unc.__annotations__ if py3k else {},
 #


if py38:
 #rom importlib import metadata as importlib_metadata
else:
 #mport importlib_metadata  # noqa


def importlib_metadata_get(group):
 #p = importlib_metadata.entry_points()
 #f hasattr(ep, "select"):
 #eturn ep.select(group=group)
 #lse:
 #eturn ep.get(group, ())


if py3k:
 #mport base64
 #mport builtins
 #mport configparser
 #mport itertools
 #mport pickle

 #rom functools import reduce
 #rom io import BytesIO as byte_buffer
 #rom io import StringIO
 #rom itertools import zip_longest
 #rom time import perf_counter
 #rom urllib.parse import (
 #uote_plus,
 #nquote_plus,
 #arse_qsl,
 #uote,
 #nquote,
 #

 #tring_types = (str,)
 #inary_types = (bytes,)
 #inary_type = bytes
 #ext_type = str
 #nt_types = (int,)
 #terbytes = iter
 #ong_type = int

 #tertools_filterfalse = itertools.filterfalse
 #tertools_filter = filter
 #tertools_imap = map

 #xec_ = getattr(builtins, "exec")
 #mport_ = getattr(builtins, "__import__")
 #rint_ = getattr(builtins, "print")

 #ef b(s):
 #eturn s.encode("latin-1")

 #ef b64decode(x):
 #eturn base64.b64decode(x.encode("ascii"))

 #ef b64encode(x):
 #eturn base64.b64encode(x).decode("ascii")

 #ef decode_backslashreplace(text, encoding):
 #eturn text.decode(encoding, errors="backslashreplace")

 #ef cmp(a, b):
 #eturn (a > b) - (a < b)

 #ef raise_(
 #xception, with_traceback=None, replace_context=None, from_=False
 #:
 #"""implement "raise" with cause support.

 #param exception: exception to raise
 #param with_traceback: will call exception.with_traceback()
 #param replace_context: an as-yet-unsupported feature.  This is
 #n exception object which we are "replacing", e.g., it's our
 #cause" but we don't want it printed.    Basically just what
 #`__suppress_context__`` does but we don't want to suppress
 #he enclosing context, if any.  So for now we make it the
 #ause.
 #param from\_: the cause.  this actually sets the cause and doesn't
 #ope to hide it someday.

 #""
 #f with_traceback is not None:
 #xception = exception.with_traceback(with_traceback)

 #f from_ is not False:
 #xception.__cause__ = from_
 #lif replace_context is not None:
            # no good solution here, we would like to have the exception
            # have only the context of replace_context.__context__ so that the
            # intermediary exception does not change, but we can't figure
            # that out.
 #xception.__cause__ = replace_context

 #ry:
 #aise exception
 #inally:
            # credit to
            # https://cosmicpercolator.com/2016/01/13/exception-leaks-in-python-2-and-3/
            # as the __traceback__ object creates a cycle
 #el exception, replace_context, from_, with_traceback

 #ef u(s):
 #eturn s

 #ef ue(s):
 #eturn s

 #rom typing import TYPE_CHECKING

    # Unused. Kept for backwards compatibility.
 #allable = callable  # noqa

 #rom abc import ABC

 #ef _qualname(fn):
 #eturn fn.__qualname__


else:
 #mport base64
 #mport ConfigParser as configparser  # noqa
 #mport itertools

 #rom StringIO import StringIO  # noqa
 #rom cStringIO import StringIO as byte_buffer  # noqa
 #rom itertools import izip_longest as zip_longest  # noqa
 #rom time import clock as perf_counter  # noqa
 #rom urllib import quote  # noqa
 #rom urllib import quote_plus  # noqa
 #rom urllib import unquote  # noqa
 #rom urllib import unquote_plus  # noqa
 #rom urlparse import parse_qsl  # noqa

 #rom abc import ABCMeta

 #lass ABC(object):
 #_metaclass__ = ABCMeta

 #ry:
 #mport cPickle as pickle
 #xcept ImportError:
 #mport pickle  # noqa

 #tring_types = (basestring,)  # noqa
 #inary_types = (bytes,)
 #inary_type = str
 #ext_type = unicode  # noqa
 #nt_types = int, long  # noqa
 #ong_type = long  # noqa

 #allable = callable  # noqa
 #mp = cmp  # noqa
 #educe = reduce  # noqa

 #64encode = base64.b64encode
 #64decode = base64.b64decode

 #tertools_filterfalse = itertools.ifilterfalse
 #tertools_filter = itertools.ifilter
 #tertools_imap = itertools.imap

 #ef b(s):
 #eturn s

 #ef exec_(func_text, globals_, lcl=None):
 #f lcl is None:
 #xec("exec func_text in globals_")
 #lse:
 #xec("exec func_text in globals_, lcl")

 #ef iterbytes(buf):
 #eturn (ord(byte) for byte in buf)

 #ef import_(*args):
 #f len(args) == 4:
 #rgs = args[0:3] + ([str(arg) for arg in args[3]],)
 #eturn __import__(*args)

 #ef print_(*args, **kwargs):
 #p = kwargs.pop("file", sys.stdout)
 #f fp is None:
 #eturn
 #or arg in enumerate(args):
 #f not isinstance(arg, basestring):  # noqa
 #rg = str(arg)
 #p.write(arg)

 #ef u(s):
        # this differs from what six does, which doesn't support non-ASCII
        # strings - we only use u() with
        # literal source strings, and all our source files with non-ascii
        # in them (all are tests) are utf-8 encoded.
 #eturn unicode(s, "utf-8")  # noqa

 #ef ue(s):
 #eturn unicode(s, "unicode_escape")  # noqa

 #ef decode_backslashreplace(text, encoding):
 #ry:
 #eturn text.decode(encoding)
 #xcept UnicodeDecodeError:
            # regular "backslashreplace" for an incompatible encoding raises:
            # "TypeError: don't know how to handle UnicodeDecodeError in
            # error callback"
 #eturn repr(text)[1:-1].decode()

 #ef safe_bytestring(text):
        # py2k only
 #f not isinstance(text, string_types):
 #eturn unicode(text).encode(  # noqa: F821
 #ascii", errors="backslashreplace"
 #
 #lif isinstance(text, unicode):  # noqa: F821
 #eturn text.encode("ascii", errors="backslashreplace")
 #lse:
 #eturn text

 #xec(
 #def raise_(exception, with_traceback=None, replace_context=None, "
 #from_=False):\n"
 #    if with_traceback:\n"
 #        raise type(exception), exception, with_traceback\n"
 #    else:\n"
 #        raise exception\n"
 #

 #YPE_CHECKING = False

 #ef _qualname(meth):
 #""return __qualname__ equivalent for a method on a class"""

 #or cls in meth.im_class.__mro__:
 #f meth.__name__ in cls.__dict__:
 #reak
 #lse:
 #eturn meth.__name__

 #eturn "%s.%s" % (cls.__name__, meth.__name__)


if py3k:

 #ef _formatannotation(annotation, base_module=None):
 #""vendored from python 3.7"""

 #f getattr(annotation, "__module__", None) == "typing":
 #eturn repr(annotation).replace("typing.", "")
 #f isinstance(annotation, type):
 #f annotation.__module__ in ("builtins", base_module):
 #eturn annotation.__qualname__
 #eturn annotation.__module__ + "." + annotation.__qualname__
 #eturn repr(annotation)

 #ef inspect_formatargspec(
 #rgs,
 #arargs=None,
 #arkw=None,
 #efaults=None,
 #wonlyargs=(),
 #wonlydefaults={},
 #nnotations={},
 #ormatarg=str,
 #ormatvarargs=lambda name: "*" + name,
 #ormatvarkw=lambda name: "**" + name,
 #ormatvalue=lambda value: "=" + repr(value),
 #ormatreturns=lambda text: " -> " + text,
 #ormatannotation=_formatannotation,
 #:
 #""Copy formatargspec from python 3.7 standard library.

 #ython 3 has deprecated formatargspec and requested that Signature
 #e used instead, however this requires a full reimplementation
 #f formatargspec() in terms of creating Parameter objects and such.
 #nstead of introducing all the object-creation overhead and having
 #o reinvent from scratch, just copy their compatibility routine.

 #ltimately we would need to rewrite our "decorator" routine completely
 #hich is not really worth it right now, until all Python 2.x support
 #s dropped.

 #""

 #ef formatargandannotation(arg):
 #esult = formatarg(arg)
 #f arg in annotations:
 #esult += ": " + formatannotation(annotations[arg])
 #eturn result

 #pecs = []
 #f defaults:
 #irstdefault = len(args) - len(defaults)
 #or i, arg in enumerate(args):
 #pec = formatargandannotation(arg)
 #f defaults and i >= firstdefault:
 #pec = spec + formatvalue(defaults[i - firstdefault])
 #pecs.append(spec)

 #f varargs is not None:
 #pecs.append(formatvarargs(formatargandannotation(varargs)))
 #lse:
 #f kwonlyargs:
 #pecs.append("*")

 #f kwonlyargs:
 #or kwonlyarg in kwonlyargs:
 #pec = formatargandannotation(kwonlyarg)
 #f kwonlydefaults and kwonlyarg in kwonlydefaults:
 #pec += formatvalue(kwonlydefaults[kwonlyarg])
 #pecs.append(spec)

 #f varkw is not None:
 #pecs.append(formatvarkw(formatargandannotation(varkw)))

 #esult = "(" + ", ".join(specs) + ")"
 #f "return" in annotations:
 #esult += formatreturns(formatannotation(annotations["return"]))
 #eturn result


else:
 #rom inspect import formatargspec as _inspect_formatargspec

 #ef inspect_formatargspec(*spec, **kw):
        # convert for a potential FullArgSpec from compat.getfullargspec()
 #eturn _inspect_formatargspec(*spec[0:4], **kw)  # noqa


# Fix deprecation of accessing ABCs straight from collections module
# (which will stop working in 3.8).
if py3k:
 #mport collections.abc as collections_abc
else:
 #mport collections as collections_abc  # noqa


if py37:
 #mport dataclasses

 #ef dataclass_fields(cls):
 #""Return a sequence of all dataclasses.Field objects associated
 #ith a class."""

 #f dataclasses.is_dataclass(cls):
 #eturn dataclasses.fields(cls)
 #lse:
 #eturn []

 #ef local_dataclass_fields(cls):
 #""Return a sequence of all dataclasses.Field objects associated with
 # class, excluding those that originate from a superclass."""

 #f dataclasses.is_dataclass(cls):
 #uper_fields = set()
 #or sup in cls.__bases__:
 #uper_fields.update(dataclass_fields(sup))
 #eturn [
 # for f in dataclasses.fields(cls) if f not in super_fields
 #
 #lse:
 #eturn []


else:

 #ef dataclass_fields(cls):
 #eturn []

 #ef local_dataclass_fields(cls):
 #eturn []


def raise_from_cause(exception, exc_info=None):
 #"""legacy.  use raise\_()"""

 #f exc_info is None:
 #xc_info = sys.exc_info()
 #xc_type, exc_value, exc_tb = exc_info
 #ause = exc_value if exc_value is not exception else None
 #eraise(type(exception), exception, tb=exc_tb, cause=cause)


def reraise(tp, value, tb=None, cause=None):
 #"""legacy.  use raise\_()"""

 #aise_(value, with_traceback=tb, from_=cause)


def with_metaclass(meta, *bases, **kw):
 #""Create a base class with a metaclass.

 #rops the middle class upon creation.

 #ource: https://lucumr.pocoo.org/2013/5/21/porting-to-python-3-redux/

 #""

 #lass metaclass(meta):
 #_call__ = type.__call__
 #_init__ = type.__init__

 #ef __new__(cls, name, this_bases, d):
 #f this_bases is None:
 #ls = type.__new__(cls, name, (), d)
 #lse:
 #ls = meta(name, bases, d)

 #f hasattr(cls, "__init_subclass__") and hasattr(
 #ls.__init_subclass__, "__func__"
 #:
 #ls.__init_subclass__.__func__(cls, **kw)
 #eturn cls

 #eturn metaclass("temporary_class", None, {})


if py3k:
 #rom datetime import timezone
else:
 #rom datetime import datetime
 #rom datetime import timedelta
 #rom datetime import tzinfo

 #lass timezone(tzinfo):
 #""Minimal port of python 3 timezone object"""

 #_slots__ = "_offset"

 #ef __init__(self, offset):
 #f not isinstance(offset, timedelta):
 #aise TypeError("offset must be a timedelta")
 #f not self._minoffset <= offset <= self._maxoffset:
 #aise ValueError(
 #offset must be a timedelta "
 #strictly between -timedelta(hours=24) and "
 #timedelta(hours=24)."
 #
 #elf._offset = offset

 #ef __eq__(self, other):
 #f type(other) != timezone:
 #eturn False
 #eturn self._offset == other._offset

 #ef __hash__(self):
 #eturn hash(self._offset)

 #ef __repr__(self):
 #eturn "sqlalchemy.util.%s(%r)" % (
 #elf.__class__.__name__,
 #elf._offset,
 #

 #ef __str__(self):
 #eturn self.tzname(None)

 #ef utcoffset(self, dt):
 #eturn self._offset

 #ef tzname(self, dt):
 #eturn self._name_from_offset(self._offset)

 #ef dst(self, dt):
 #eturn None

 #ef fromutc(self, dt):
 #f isinstance(dt, datetime):
 #f dt.tzinfo is not self:
 #aise ValueError("fromutc: dt.tzinfo " "is not self")
 #eturn dt + self._offset
 #aise TypeError(
 #fromutc() argument must be a datetime instance" " or None"
 #

 #staticmethod
 #ef _timedelta_to_microseconds(timedelta):
 #""backport of timedelta._to_microseconds()"""
 #eturn (
 #imedelta.days * (24 * 3600) + timedelta.seconds
 # * 1000000 + timedelta.microseconds

 #staticmethod
 #ef _divmod_timedeltas(a, b):
 #""backport of timedelta.__divmod__"""

 #, r = divmod(
 #imezone._timedelta_to_microseconds(a),
 #imezone._timedelta_to_microseconds(b),
 #
 #eturn q, timedelta(0, 0, r)

 #staticmethod
 #ef _name_from_offset(delta):
 #f not delta:
 #eturn "UTC"
 #f delta < timedelta(0):
 #ign = "-"
 #elta = -delta
 #lse:
 #ign = "+"
 #ours, rest = timezone._divmod_timedeltas(
 #elta, timedelta(hours=1)
 #
 #inutes, rest = timezone._divmod_timedeltas(
 #est, timedelta(minutes=1)
 #
 #esult = "UTC%s%02d:%02d" % (sign, hours, minutes)
 #f rest.seconds:
 #esult += ":%02d" % (rest.seconds,)
 #f rest.microseconds:
 #esult += ".%06d" % (rest.microseconds,)
 #eturn result

 #maxoffset = timedelta(hours=23, minutes=59)
 #minoffset = -_maxoffset

 #imezone.utc = timezone(timedelta(0))
