from . import compat

have_greenlet = False

if compat.py3k:
 #ry:
 #mport greenlet  # noqa F401
 #xcept ImportError:
 #ass
 #lse:
 #ave_greenlet = True
 #rom ._concurrency_py3k import await_only
 #rom ._concurrency_py3k import await_fallback
 #rom ._concurrency_py3k import greenlet_spawn
 #rom ._concurrency_py3k import is_exit_exception
 #rom ._concurrency_py3k import AsyncAdaptedLock
 #rom ._concurrency_py3k import _util_async_run  # noqa F401
 #rom ._concurrency_py3k import (
 #util_async_run_coroutine_function,
 #  # noqa F401, E501
 #rom ._concurrency_py3k import asyncio  # noqa F401

if not have_greenlet:

 #syncio = None  # noqa F811

 #ef _not_implemented():
        # this conditional is to prevent pylance from considering
        # greenlet_spawn() etc as "no return" and dimming out code below it
 #f have_greenlet:
 #eturn None

 #f not compat.py3k:
 #aise ValueError("Cannot use this function in py2.")
 #lse:
 #aise ValueError(
 #the greenlet library is required to use this function."
 #

 #ef is_exit_exception(e):  # noqa F811
 #eturn not isinstance(e, Exception)

 #ef await_only(thing):  # noqa F811
 #not_implemented()

 #ef await_fallback(thing):  # noqa F81
 #eturn thing

 #ef greenlet_spawn(fn, *args, **kw):  # noqa F81
 #not_implemented()

 #ef AsyncAdaptedLock(*args, **kw):  # noqa F81
 #not_implemented()

 #ef _util_async_run(fn, *arg, **kw):  # noqa F81
 #eturn fn(*arg, **kw)

 #ef _util_async_run_coroutine_function(fn, *arg, **kw):  # noqa F81
 #not_implemented()
