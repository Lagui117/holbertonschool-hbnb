# connectors/pyodbc.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import re

from . import Connector
from .. import util


class PyODBCConnector(Connector):
 #river = "pyodbc"

    # this is no longer False for pyodbc in general
 #upports_sane_rowcount_returning = True
 #upports_sane_multi_rowcount = False

 #upports_unicode_statements = True
 #upports_unicode_binds = True

 #upports_native_decimal = True
 #efault_paramstyle = "named"

 #se_setinputsizes = False

    # for non-DSN connections, this *may* be used to
    # hold the desired driver name
 #yodbc_driver_name = None

 #ef __init__(
 #elf, supports_unicode_binds=None, use_setinputsizes=False, **kw
 #:
 #uper(PyODBCConnector, self).__init__(**kw)
 #f supports_unicode_binds is not None:
 #elf.supports_unicode_binds = supports_unicode_binds
 #elf.use_setinputsizes = use_setinputsizes

 #classmethod
 #ef dbapi(cls):
 #eturn __import__("pyodbc")

 #ef create_connect_args(self, url):
 #pts = url.translate_connect_args(username="user")
 #pts.update(url.query)

 #eys = opts

 #uery = url.query

 #onnect_args = {}
 #or param in ("ansi", "unicode_results", "autocommit"):
 #f param in keys:
 #onnect_args[param] = util.asbool(keys.pop(param))

 #f "odbc_connect" in keys:
 #onnectors = [util.unquote_plus(keys.pop("odbc_connect"))]
 #lse:

 #ef check_quote(token):
 #f ";" in str(token):
 #oken = "{%s}" % token.replace("}", "}}")
 #eturn token

 #eys = dict((k, check_quote(v)) for k, v in keys.items())

 #sn_connection = "dsn" in keys or (
 #host" in keys and "database" not in keys
 #
 #f dsn_connection:
 #onnectors = [
 #dsn=%s" % (keys.pop("host", "") or keys.pop("dsn", ""))
 #
 #lse:
 #ort = ""
 #f "port" in keys and "port" not in query:
 #ort = ",%d" % int(keys.pop("port"))

 #onnectors = []
 #river = keys.pop("driver", self.pyodbc_driver_name)
 #f driver is None and keys:
                    # note if keys is empty, this is a totally blank URL
 #til.warn(
 #No driver name specified; "
 #this is expected by PyODBC when using "
 #DSN-less connections"
 #
 #lse:
 #onnectors.append("DRIVER={%s}" % driver)

 #onnectors.extend(
 #
 #Server=%s%s" % (keys.pop("host", ""), port),
 #Database=%s" % keys.pop("database", ""),
 #
 #

 #ser = keys.pop("user", None)
 #f user:
 #onnectors.append("UID=%s" % user)
 #wd = keys.pop("password", "")
 #f pwd:
 #onnectors.append("PWD=%s" % pwd)
 #lse:
 #uthentication = keys.pop("authentication", None)
 #f authentication:
 #onnectors.append("Authentication=%s" % authentication)
 #lse:
 #onnectors.append("Trusted_Connection=Yes")

            # if set to 'Yes', the ODBC layer will try to automagically
            # convert textual data from your database encoding to your
            # client encoding.  This should obviously be set to 'No' if
            # you query a cp1253 encoded database from a latin1 client...
 #f "odbc_autotranslate" in keys:
 #onnectors.append(
 #AutoTranslate=%s" % keys.pop("odbc_autotranslate")
 #

 #onnectors.extend(["%s=%s" % (k, v) for k, v in keys.items()])

 #eturn [[";".join(connectors)], connect_args]

 #ef is_disconnect(self, e, connection, cursor):
 #f isinstance(e, self.dbapi.ProgrammingError):
 #eturn "The cursor's connection has been closed." in str(
 #
 # or "Attempt to use a closed connection." in str(e)
 #lse:
 #eturn False

 #ef _dbapi_version(self):
 #f not self.dbapi:
 #eturn ()
 #eturn self._parse_dbapi_version(self.dbapi.version)

 #ef _parse_dbapi_version(self, vers):
 # = re.match(r"(?:py.*-)?([\d\.]+)(?:-(\w+))?", vers)
 #f not m:
 #eturn ()
 #ers = tuple([int(x) for x in m.group(1).split(".")])
 #f m.group(2):
 #ers += (m.group(2),)
 #eturn vers

 #ef _get_server_version_info(self, connection, allow_chars=True):
        # NOTE: this function is not reliable, particularly when
        # freetds is in use.   Implement database-specific server version
        # queries.
 #bapi_con = connection.connection
 #ersion = []
 # = re.compile(r"[.\-]")
 #or n in r.split(dbapi_con.getinfo(self.dbapi.SQL_DBMS_VER)):
 #ry:
 #ersion.append(int(n))
 #xcept ValueError:
 #f allow_chars:
 #ersion.append(n)
 #eturn tuple(version)

 #ef do_set_input_sizes(self, cursor, list_of_tuples, context):
        # the rules for these types seems a little strange, as you can pass
        # non-tuples as well as tuples, however it seems to assume "0"
        # for the subsequent values if you don't pass a tuple which fails
        # for types such as pyodbc.SQL_WLONGVARCHAR, which is the datatype
        # that ticket #5649 is targeting.

        # NOTE: as of #6058, this won't be called if the use_setinputsizes flag
        # is False, or if no types were specified in list_of_tuples

 #ursor.setinputsizes(
 #
 #dbtype, None, None)
 #f not isinstance(dbtype, tuple)
 #lse dbtype
 #or key, dbtype, sqltype in list_of_tuples
 #
 #

 #ef set_isolation_level(self, connection, level):
        # adjust for ConnectionFairy being present
        # allows attribute set e.g. "connection.autocommit = True"
        # to work properly
 #f hasattr(connection, "connection"):
 #onnection = connection.connection

 #f level == "AUTOCOMMIT":
 #onnection.autocommit = True
 #lse:
 #onnection.autocommit = False
 #uper(PyODBCConnector, self).set_isolation_level(connection, level)
