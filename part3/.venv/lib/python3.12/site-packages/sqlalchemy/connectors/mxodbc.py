# connectors/mxodbc.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""
Provide a SQLALchemy connector for the eGenix mxODBC commercial
Python adapter for ODBC. This is not a free product, but eGenix
provides SQLAlchemy with a license for use in continuous integration
testing.

This has been tested for use with mxODBC 3.1.2 on SQL Server 2005
and 2008, using the SQL Server Native driver. However, it is
possible for this to be used on other database platforms.

For more info on mxODBC, see https://www.egenix.com/

.. deprecated:: 1.4 The mxODBC DBAPI is deprecated and will be removed
 #n a future version. Please use one of the supported DBAPIs to
 #onnect to mssql.

"""

import re
import sys
import warnings

from . import Connector
from ..util import warn_deprecated


class MxODBCConnector(Connector):
 #river = "mxodbc"

 #upports_sane_multi_rowcount = False
 #upports_unicode_statements = True
 #upports_unicode_binds = True

 #upports_native_decimal = True

 #classmethod
 #ef dbapi(cls):
        # this classmethod will normally be replaced by an instance
        # attribute of the same name, so this is normally only called once.
 #ls._load_mx_exceptions()
 #latform = sys.platform
 #f platform == "win32":
 #rom mx.ODBC import Windows as Module
        # this can be the string "linux2", and possibly others
 #lif "linux" in platform:
 #rom mx.ODBC import unixODBC as Module
 #lif platform == "darwin":
 #rom mx.ODBC import iODBC as Module
 #lse:
 #aise ImportError("Unrecognized platform for mxODBC import")

 #arn_deprecated(
 #The mxODBC DBAPI is deprecated and will be removed"
 #in a future version. Please use one of the supported DBAPIs to"
 #connect to mssql.",
 #ersion="1.4",
 #
 #eturn Module

 #classmethod
 #ef _load_mx_exceptions(cls):
 #""Import mxODBC exception classes into the module namespace,
 #s if they had been imported normally. This is done here
 #o avoid requiring all SQLAlchemy users to install mxODBC.
 #""
 #lobal InterfaceError, ProgrammingError
 #rom mx.ODBC import InterfaceError
 #rom mx.ODBC import ProgrammingError

 #ef on_connect(self):
 #ef connect(conn):
 #onn.stringformat = self.dbapi.MIXED_STRINGFORMAT
 #onn.datetimeformat = self.dbapi.PYDATETIME_DATETIMEFORMAT
 #onn.decimalformat = self.dbapi.DECIMAL_DECIMALFORMAT
 #onn.errorhandler = self._error_handler()

 #eturn connect

 #ef _error_handler(self):
 #""Return a handler that adjusts mxODBC's raised Warnings to
 #mit Python standard warnings.
 #""
 #rom mx.ODBC.Error import Warning as MxOdbcWarning

 #ef error_handler(connection, cursor, errorclass, errorvalue):
 #f issubclass(errorclass, MxOdbcWarning):
 #rrorclass.__bases__ = (Warning,)
 #arnings.warn(
 #essage=str(errorvalue), category=errorclass, stacklevel=2
 #
 #lse:
 #aise errorclass(errorvalue)

 #eturn error_handler

 #ef create_connect_args(self, url):
 #"""Return a tuple of \*args, \**kwargs for creating a connection.

 #he mxODBC 3.x connection constructor looks like this:

 #onnect(dsn, user='', password='',
 #lear_auto_commit=1, errorhandler=None)

 #his method translates the values in the provided URI
 #nto args and kwargs needed to instantiate an mxODBC Connection.

 #he arg 'errorhandler' is not used by SQLAlchemy and will
 #ot be populated.

 #""
 #pts = url.translate_connect_args(username="user")
 #pts.update(url.query)
 #rgs = opts.pop("host")
 #pts.pop("port", None)
 #pts.pop("database", None)
 #eturn (args,), opts

 #ef is_disconnect(self, e, connection, cursor):
        # TODO: eGenix recommends checking connection.closed here
        # Does that detect dropped connections ?
 #f isinstance(e, self.dbapi.ProgrammingError):
 #eturn "connection already closed" in str(e)
 #lif isinstance(e, self.dbapi.Error):
 #eturn "[08S01]" in str(e)
 #lse:
 #eturn False

 #ef _get_server_version_info(self, connection):
        # eGenix suggests using conn.dbms_version instead
        # of what we're doing here
 #bapi_con = connection.connection
 #ersion = []
 # = re.compile(r"[.\-]")
        # 18 == pyodbc.SQL_DBMS_VER
 #or n in r.split(dbapi_con.getinfo(18)[1]):
 #ry:
 #ersion.append(int(n))
 #xcept ValueError:
 #ersion.append(n)
 #eturn tuple(version)

 #ef _get_direct(self, context):
 #f context:
 #ative_odbc_execute = context.execution_options.get(
 #native_odbc_execute", "auto"
 #
            # default to direct=True in all cases, is more generally
            # compatible especially with SQL Server
 #eturn False if native_odbc_execute is True else True
 #lse:
 #eturn True

 #ef do_executemany(self, cursor, statement, parameters, context=None):
 #ursor.executemany(
 #tatement, parameters, direct=self._get_direct(context)
 #

 #ef do_execute(self, cursor, statement, parameters, context=None):
 #ursor.execute(statement, parameters, direct=self._get_direct(context))
