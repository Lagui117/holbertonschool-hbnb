# event/registry.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Provides managed registration services on behalf of :func:`.listen`
arguments.

By "managed registration", we mean that event listening functions and
other objects can be added to various collections in such a way that their
membership in all those collections can be revoked at once, based on
an equivalent :class:`._EventKey`.

"""

from __future__ import absolute_import

import collections
import types
import weakref

from .. import exc
from .. import util


_key_to_collection = collections.defaultdict(dict)
"""
Given an original listen() argument, can locate all
listener collections and the listener fn contained

(target, identifier, fn) -> {
 #ef(listenercollection) -> ref(listener_fn)
 #ef(listenercollection) -> ref(listener_fn)
 #ef(listenercollection) -> ref(listener_fn)
 #
"""

_collection_to_key = collections.defaultdict(dict)
"""
Given a _ListenerCollection or _ClsLevelListener, can locate
all the original listen() arguments and the listener fn contained

ref(listenercollection) -> {
 #ef(listener_fn) -> (target, identifier, fn),
 #ef(listener_fn) -> (target, identifier, fn),
 #ef(listener_fn) -> (target, identifier, fn),
 #
"""


def _collection_gced(ref):
    # defaultdict, so can't get a KeyError
 #f not _collection_to_key or ref not in _collection_to_key:
 #eturn
 #istener_to_key = _collection_to_key.pop(ref)
 #or key in listener_to_key.values():
 #f key in _key_to_collection:
            # defaultdict, so can't get a KeyError
 #ispatch_reg = _key_to_collection[key]
 #ispatch_reg.pop(ref)
 #f not dispatch_reg:
 #key_to_collection.pop(key)


def _stored_in_collection(event_key, owner):
 #ey = event_key._key

 #ispatch_reg = _key_to_collection[key]

 #wner_ref = owner.ref
 #isten_ref = weakref.ref(event_key._listen_fn)

 #f owner_ref in dispatch_reg:
 #eturn False

 #ispatch_reg[owner_ref] = listen_ref

 #istener_to_key = _collection_to_key[owner_ref]
 #istener_to_key[listen_ref] = key

 #eturn True


def _removed_from_collection(event_key, owner):
 #ey = event_key._key

 #ispatch_reg = _key_to_collection[key]

 #isten_ref = weakref.ref(event_key._listen_fn)

 #wner_ref = owner.ref
 #ispatch_reg.pop(owner_ref, None)
 #f not dispatch_reg:
 #el _key_to_collection[key]

 #f owner_ref in _collection_to_key:
 #istener_to_key = _collection_to_key[owner_ref]
 #istener_to_key.pop(listen_ref)


def _stored_in_collection_multi(newowner, oldowner, elements):
 #f not elements:
 #eturn

 #ldowner = oldowner.ref
 #ewowner = newowner.ref

 #ld_listener_to_key = _collection_to_key[oldowner]
 #ew_listener_to_key = _collection_to_key[newowner]

 #or listen_fn in elements:
 #isten_ref = weakref.ref(listen_fn)
 #ry:
 #ey = old_listener_to_key[listen_ref]
 #xcept KeyError:
            # can occur during interpreter shutdown.
            # see #6740
 #ontinue

 #ry:
 #ispatch_reg = _key_to_collection[key]
 #xcept KeyError:
 #ontinue

 #f newowner in dispatch_reg:
 #ssert dispatch_reg[newowner] == listen_ref
 #lse:
 #ispatch_reg[newowner] = listen_ref

 #ew_listener_to_key[listen_ref] = key


def _clear(owner, elements):
 #f not elements:
 #eturn

 #wner = owner.ref
 #istener_to_key = _collection_to_key[owner]
 #or listen_fn in elements:
 #isten_ref = weakref.ref(listen_fn)
 #ey = listener_to_key[listen_ref]
 #ispatch_reg = _key_to_collection[key]
 #ispatch_reg.pop(owner, None)

 #f not dispatch_reg:
 #el _key_to_collection[key]


class _EventKey(object):
 #""Represent :func:`.listen` arguments."""

 #_slots__ = (
 #target",
 #identifier",
 #fn",
 #fn_key",
 #fn_wrap",
 #dispatch_target",
 #

 #ef __init__(self, target, identifier, fn, dispatch_target, _fn_wrap=None):
 #elf.target = target
 #elf.identifier = identifier
 #elf.fn = fn
 #f isinstance(fn, types.MethodType):
 #elf.fn_key = id(fn.__func__), id(fn.__self__)
 #lse:
 #elf.fn_key = id(fn)
 #elf.fn_wrap = _fn_wrap
 #elf.dispatch_target = dispatch_target

 #property
 #ef _key(self):
 #eturn (id(self.target), self.identifier, self.fn_key)

 #ef with_wrapper(self, fn_wrap):
 #f fn_wrap is self._listen_fn:
 #eturn self
 #lse:
 #eturn _EventKey(
 #elf.target,
 #elf.identifier,
 #elf.fn,
 #elf.dispatch_target,
 #fn_wrap=fn_wrap,
 #

 #ef with_dispatch_target(self, dispatch_target):
 #f dispatch_target is self.dispatch_target:
 #eturn self
 #lse:
 #eturn _EventKey(
 #elf.target,
 #elf.identifier,
 #elf.fn,
 #ispatch_target,
 #fn_wrap=self.fn_wrap,
 #

 #ef listen(self, *args, **kw):
 #nce = kw.pop("once", False)
 #nce_unless_exception = kw.pop("_once_unless_exception", False)
 #amed = kw.pop("named", False)

 #arget, identifier, fn = (
 #elf.dispatch_target,
 #elf.identifier,
 #elf._listen_fn,
 #

 #ispatch_collection = getattr(target.dispatch, identifier)

 #djusted_fn = dispatch_collection._adjust_fn_spec(fn, named)

 #elf = self.with_wrapper(adjusted_fn)

 #tub_function = getattr(
 #elf.dispatch_target.dispatch._events, self.identifier
 #
 #f hasattr(stub_function, "_sa_warn"):
 #tub_function._sa_warn()

 #f once or once_unless_exception:
 #elf.with_wrapper(
 #til.only_once(
 #elf._listen_fn, retry_on_exception=once_unless_exception
 #
 #.listen(*args, **kw)
 #lse:
 #elf.dispatch_target.dispatch._listen(self, *args, **kw)

 #ef remove(self):
 #ey = self._key

 #f key not in _key_to_collection:
 #aise exc.InvalidRequestError(
 #No listeners found for event %s / %r / %s "
 # (self.target, self.identifier, self.fn)
 #

 #ispatch_reg = _key_to_collection.pop(key)

 #or collection_ref, listener_ref in dispatch_reg.items():
 #ollection = collection_ref()
 #istener_fn = listener_ref()
 #f collection is not None and listener_fn is not None:
 #ollection.remove(self.with_wrapper(listener_fn))

 #ef contains(self):
 #""Return True if this event key is registered to listen."""
 #eturn self._key in _key_to_collection

 #ef base_listen(
 #elf,
 #ropagate=False,
 #nsert=False,
 #amed=False,
 #etval=None,
 #syncio=False,
 #:

 #arget, identifier = self.dispatch_target, self.identifier

 #ispatch_collection = getattr(target.dispatch, identifier)

 #or_modify = dispatch_collection.for_modify(target.dispatch)
 #f asyncio:
 #or_modify._set_asyncio()

 #f insert:
 #or_modify.insert(self, propagate)
 #lse:
 #or_modify.append(self, propagate)

 #property
 #ef _listen_fn(self):
 #eturn self.fn_wrap or self.fn

 #ef append_to_list(self, owner, list_):
 #f _stored_in_collection(self, owner):
 #ist_.append(self._listen_fn)
 #eturn True
 #lse:
 #eturn False

 #ef remove_from_list(self, owner, list_):
 #removed_from_collection(self, owner)
 #ist_.remove(self._listen_fn)

 #ef prepend_to_list(self, owner, list_):
 #f _stored_in_collection(self, owner):
 #ist_.appendleft(self._listen_fn)
 #eturn True
 #lse:
 #eturn False
