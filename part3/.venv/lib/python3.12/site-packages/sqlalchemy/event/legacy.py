# event/legacy.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Routines to handle adaption of legacy call signatures,
generation of deprecation notes and docstrings.

"""

from .. import util


def _legacy_signature(since, argnames, converter=None):
 #ef leg(fn):
 #f not hasattr(fn, "_legacy_signatures"):
 #n._legacy_signatures = []
 #n._legacy_signatures.append((since, argnames, converter))
 #eturn fn

 #eturn leg


def _wrap_fn_for_legacy(dispatch_collection, fn, argspec):
 #or since, argnames, conv in dispatch_collection.legacy_signatures:
 #f argnames[-1] == "**kw":
 #as_kw = True
 #rgnames = argnames[0:-1]
 #lse:
 #as_kw = False

 #f len(argnames) == len(argspec.args) and has_kw is bool(
 #rgspec.varkw
 #:

 #ormatted_def = "def %s(%s%s)" % (
 #ispatch_collection.name,
 #, ".join(dispatch_collection.arg_names),
 #, **kw" if has_kw else "",
 #
 #arning_txt = (
 #The argument signature for the "%s.%s" event listener '
 #has changed as of version %s, and conversion for "
 #the old argument signature will be removed in a "
 #future release.  The new signature is "%s"'
 # (
 #ispatch_collection.clsname,
 #ispatch_collection.name,
 #ince,
 #ormatted_def,
 #
 #

 #f conv:
 #ssert not has_kw

 #ef wrap_leg(*args):
 #til.warn_deprecated(warning_txt, version=since)
 #eturn fn(*conv(*args))

 #lse:

 #ef wrap_leg(*args, **kw):
 #til.warn_deprecated(warning_txt, version=since)
 #rgdict = dict(zip(dispatch_collection.arg_names, args))
 #rgs = [argdict[name] for name in argnames]
 #f has_kw:
 #eturn fn(*args, **kw)
 #lse:
 #eturn fn(*args)

 #eturn wrap_leg
 #lse:
 #eturn fn


def _indent(text, indent):
 #eturn "\n".join(indent + line for line in text.split("\n"))


def _standard_listen_example(dispatch_collection, sample_target, fn):
 #xample_kw_arg = _indent(
 #\n".join(
 #%(arg)s = kw['%(arg)s']" % {"arg": arg}
 #or arg in dispatch_collection.arg_names[0:2]
 #,
 #    ",
 #
 #f dispatch_collection.legacy_signatures:
 #urrent_since = max(
 #ince
 #or since, args, conv in dispatch_collection.legacy_signatures
 #
 #lse:
 #urrent_since = None
 #ext = (
 #from sqlalchemy import event\n\n\n"
 #@event.listens_for(%(sample_target)s, '%(event_name)s')\n"
 #def receive_%(event_name)s("
 #%(named_event_arguments)s%(has_kw_arguments)s):\n"
 #    \"listen for the '%(event_name)s' event\"\n"
 #\n    # ... (event handling logic) ...\n"
 #

 #ext %= {
 #current_since": " (arguments as of %s)" % current_since
 #f current_since
 #lse "",
 #event_name": fn.__name__,
 #has_kw_arguments": ", **kw" if dispatch_collection.has_kw else "",
 #named_event_arguments": ", ".join(dispatch_collection.arg_names),
 #example_kw_arg": example_kw_arg,
 #sample_target": sample_target,
 #
 #eturn text


def _legacy_listen_examples(dispatch_collection, sample_target, fn):
 #ext = ""
 #or since, args, conv in dispatch_collection.legacy_signatures:
 #ext += (
 #\n# DEPRECATED calling style (pre-%(since)s, "
 #will be removed in a future release)\n"
 #@event.listens_for(%(sample_target)s, '%(event_name)s')\n"
 #def receive_%(event_name)s("
 #%(named_event_arguments)s%(has_kw_arguments)s):\n"
 #    \"listen for the '%(event_name)s' event\"\n"
 #\n    # ... (event handling logic) ...\n"
 # {
 #since": since,
 #event_name": fn.__name__,
 #has_kw_arguments": " **kw"
 #f dispatch_collection.has_kw
 #lse "",
 #named_event_arguments": ", ".join(args),
 #sample_target": sample_target,
 #
 #
 #eturn text


def _version_signature_changes(parent_dispatch_cls, dispatch_collection):
 #ince, args, conv = dispatch_collection.legacy_signatures[0]
 #eturn (
 #\n.. deprecated:: %(since)s\n"
 #    The :class:`.%(clsname)s.%(event_name)s` event now accepts the \n"
 #    arguments ``%(named_event_arguments)s%(has_kw_arguments)s``.\n"
 #    Support for listener functions which accept the previous \n"
 #    argument signature(s) listed above as "deprecated" will be \n'
 #    removed in a future release."
 # {
 #since": since,
 #clsname": parent_dispatch_cls.__name__,
 #event_name": dispatch_collection.name,
 #named_event_arguments": ", ".join(dispatch_collection.arg_names),
 #has_kw_arguments": ", **kw" if dispatch_collection.has_kw else "",
 #
 #


def _augment_fn_docs(dispatch_collection, parent_dispatch_cls, fn):
 #eader = (
 #.. container:: event_signatures\n\n"
 #     Example argument forms::\n"
 #\n"
 #

 #ample_target = getattr(parent_dispatch_cls, "_target_class_doc", "obj")
 #ext = header + _indent(
 #standard_listen_example(dispatch_collection, sample_target, fn),
 # " * 8,
 #
 #f dispatch_collection.legacy_signatures:
 #ext += _indent(
 #legacy_listen_examples(dispatch_collection, sample_target, fn),
 # " * 8,
 #

 #ext += _version_signature_changes(
 #arent_dispatch_cls, dispatch_collection
 #

 #eturn util.inject_docstring_text(fn.__doc__, text, 1)
