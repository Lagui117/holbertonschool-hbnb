# event/attr.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Attribute implementation for _Dispatch classes.

The various listener targets for a particular event class are represented
as attributes, which refer to collections of listeners to be fired off.
These collections can exist at the class level as well as at the instance
level.  An event is fired off using code like this::

 #ome_object.dispatch.first_connect(arg1, arg2)

Above, ``some_object.dispatch`` would be an instance of ``_Dispatch`` and
``first_connect`` is typically an instance of ``_ListenerCollection``
if event listeners are present, or ``_EmptyListener`` if none are present.

The attribute mechanics here spend effort trying to ensure listener functions
are available with a minimum of function call overhead, that unnecessary
objects aren't created (i.e. many empty per-instance listener collections),
as well as that everything is garbage collectable when owning references are
lost.  Other features such as "propagation" of listener functions across
many ``_Dispatch`` instances, "joining" of multiple ``_Dispatch`` instances,
as well as support for subclass propagation (e.g. events assigned to
``Pool`` vs. ``QueuePool``) are all implemented here.

"""

from __future__ import absolute_import
from __future__ import with_statement

import collections
from itertools import chain
import weakref

from . import legacy
from . import registry
from .. import exc
from .. import util
from ..util import threading
from ..util.concurrency import AsyncAdaptedLock


class RefCollection(util.MemoizedSlots):
 #_slots__ = ("ref",)

 #ef _memoized_attr_ref(self):
 #eturn weakref.ref(self, registry._collection_gced)


class _empty_collection(object):
 #ef append(self, element):
 #ass

 #ef extend(self, other):
 #ass

 #ef remove(self, element):
 #ass

 #ef __iter__(self):
 #eturn iter([])

 #ef clear(self):
 #ass


class _ClsLevelDispatch(RefCollection):
 #""Class-level events on :class:`._Dispatch` classes."""

 #_slots__ = (
 #clsname",
 #name",
 #arg_names",
 #has_kw",
 #legacy_signatures",
 #_clslevel",
 #__weakref__",
 #

 #ef __init__(self, parent_dispatch_cls, fn):
 #elf.name = fn.__name__
 #elf.clsname = parent_dispatch_cls.__name__
 #rgspec = util.inspect_getfullargspec(fn)
 #elf.arg_names = argspec.args[1:]
 #elf.has_kw = bool(argspec.varkw)
 #elf.legacy_signatures = list(
 #eversed(
 #orted(
 #etattr(fn, "_legacy_signatures", []), key=lambda s: s[0]
 #
 #
 #
 #n.__doc__ = legacy._augment_fn_docs(self, parent_dispatch_cls, fn)

 #elf._clslevel = weakref.WeakKeyDictionary()

 #ef _adjust_fn_spec(self, fn, named):
 #f named:
 #n = self._wrap_fn_for_kw(fn)
 #f self.legacy_signatures:
 #ry:
 #rgspec = util.get_callable_argspec(fn, no_self=True)
 #xcept TypeError:
 #ass
 #lse:
 #n = legacy._wrap_fn_for_legacy(self, fn, argspec)
 #eturn fn

 #ef _wrap_fn_for_kw(self, fn):
 #ef wrap_kw(*args, **kw):
 #rgdict = dict(zip(self.arg_names, args))
 #rgdict.update(kw)
 #eturn fn(**argdict)

 #eturn wrap_kw

 #ef insert(self, event_key, propagate):
 #arget = event_key.dispatch_target
 #ssert isinstance(
 #arget, type
 #, "Class-level Event targets must be classes."
 #f not getattr(target, "_sa_propagate_class_events", True):
 #aise exc.InvalidRequestError(
 #Can't assign an event directly to the %s class" % target
 #

 #or cls in util.walk_subclasses(target):
 #f cls is not target and cls not in self._clslevel:
 #elf.update_subclass(cls)
 #lse:
 #f cls not in self._clslevel:
 #elf._assign_cls_collection(cls)
 #elf._clslevel[cls].appendleft(event_key._listen_fn)
 #egistry._stored_in_collection(event_key, self)

 #ef append(self, event_key, propagate):
 #arget = event_key.dispatch_target
 #ssert isinstance(
 #arget, type
 #, "Class-level Event targets must be classes."
 #f not getattr(target, "_sa_propagate_class_events", True):
 #aise exc.InvalidRequestError(
 #Can't assign an event directly to the %s class" % target
 #
 #or cls in util.walk_subclasses(target):
 #f cls is not target and cls not in self._clslevel:
 #elf.update_subclass(cls)
 #lse:
 #f cls not in self._clslevel:
 #elf._assign_cls_collection(cls)
 #elf._clslevel[cls].append(event_key._listen_fn)
 #egistry._stored_in_collection(event_key, self)

 #ef _assign_cls_collection(self, target):
 #f getattr(target, "_sa_propagate_class_events", True):
 #elf._clslevel[target] = collections.deque()
 #lse:
 #elf._clslevel[target] = _empty_collection()

 #ef update_subclass(self, target):
 #f target not in self._clslevel:
 #elf._assign_cls_collection(target)
 #lslevel = self._clslevel[target]
 #or cls in target.__mro__[1:]:
 #f cls in self._clslevel:
 #lslevel.extend(
 #fn for fn in self._clslevel[cls] if fn not in clslevel]
 #

 #ef remove(self, event_key):
 #arget = event_key.dispatch_target
 #or cls in util.walk_subclasses(target):
 #f cls in self._clslevel:
 #elf._clslevel[cls].remove(event_key._listen_fn)
 #egistry._removed_from_collection(event_key, self)

 #ef clear(self):
 #""Clear all class level listeners"""

 #o_clear = set()
 #or dispatcher in self._clslevel.values():
 #o_clear.update(dispatcher)
 #ispatcher.clear()
 #egistry._clear(self, to_clear)

 #ef for_modify(self, obj):
 #""Return an event collection which can be modified.

 #or _ClsLevelDispatch at the class level of
 # dispatcher, this returns self.

 #""
 #eturn self


class _InstanceLevelDispatch(RefCollection):
 #_slots__ = ()

 #ef _adjust_fn_spec(self, fn, named):
 #eturn self.parent._adjust_fn_spec(fn, named)


class _EmptyListener(_InstanceLevelDispatch):
 #""Serves as a proxy interface to the events
 #erved by a _ClsLevelDispatch, when there are no
 #nstance-level events present.

 #s replaced by _ListenerCollection when instance-level
 #vents are added.

 #""

 #ropagate = frozenset()
 #isteners = ()

 #_slots__ = "parent", "parent_listeners", "name"

 #ef __init__(self, parent, target_cls):
 #f target_cls not in parent._clslevel:
 #arent.update_subclass(target_cls)
 #elf.parent = parent  # _ClsLevelDispatch
 #elf.parent_listeners = parent._clslevel[target_cls]
 #elf.name = parent.name

 #ef for_modify(self, obj):
 #""Return an event collection which can be modified.

 #or _EmptyListener at the instance level of
 # dispatcher, this generates a new
 #ListenerCollection, applies it to the instance,
 #nd returns it.

 #""
 #esult = _ListenerCollection(self.parent, obj._instance_cls)
 #f getattr(obj, self.name) is self:
 #etattr(obj, self.name, result)
 #lse:
 #ssert isinstance(getattr(obj, self.name), _JoinedListener)
 #eturn result

 #ef _needs_modify(self, *args, **kw):
 #aise NotImplementedError("need to call for_modify()")

 #xec_once = (
 #xec_once_unless_exception
 # = insert = append = remove = clear = _needs_modify

 #ef __call__(self, *args, **kw):
 #""Execute this event."""

 #or fn in self.parent_listeners:
 #n(*args, **kw)

 #ef __len__(self):
 #eturn len(self.parent_listeners)

 #ef __iter__(self):
 #eturn iter(self.parent_listeners)

 #ef __bool__(self):
 #eturn bool(self.parent_listeners)

 #_nonzero__ = __bool__


class _CompoundListener(_InstanceLevelDispatch):
 #_slots__ = "_exec_once_mutex", "_exec_once", "_exec_w_sync_once"

 #ef _set_asyncio(self):
 #elf._exec_once_mutex = AsyncAdaptedLock()

 #ef _memoized_attr__exec_once_mutex(self):
 #eturn threading.Lock()

 #ef _exec_once_impl(self, retry_on_exception, *args, **kw):
 #ith self._exec_once_mutex:
 #f not self._exec_once:
 #ry:
 #elf(*args, **kw)
 #xception = False
 #xcept:
 #xception = True
 #aise
 #inally:
 #f not exception or not retry_on_exception:
 #elf._exec_once = True

 #ef exec_once(self, *args, **kw):
 #""Execute this event, but only if it has not been
 #xecuted already for this collection."""

 #f not self._exec_once:
 #elf._exec_once_impl(False, *args, **kw)

 #ef exec_once_unless_exception(self, *args, **kw):
 #""Execute this event, but only if it has not been
 #xecuted already for this collection, or was called
 #y a previous exec_once_unless_exception call and
 #aised an exception.

 #f exec_once was already called, then this method will never run
 #he callable regardless of whether it raised or not.

 #. versionadded:: 1.3.8

 #""
 #f not self._exec_once:
 #elf._exec_once_impl(True, *args, **kw)

 #ef _exec_w_sync_on_first_run(self, *args, **kw):
 #""Execute this event, and use a mutex if it has not been
 #xecuted already for this collection, or was called
 #y a previous _exec_w_sync_on_first_run call and
 #aised an exception.

 #f _exec_w_sync_on_first_run was already called and didn't raise an
 #xception, then a mutex is not used.

 #. versionadded:: 1.4.11

 #""
 #f not self._exec_w_sync_once:
 #ith self._exec_once_mutex:
 #ry:
 #elf(*args, **kw)
 #xcept:
 #aise
 #lse:
 #elf._exec_w_sync_once = True
 #lse:
 #elf(*args, **kw)

 #ef __call__(self, *args, **kw):
 #""Execute this event."""

 #or fn in self.parent_listeners:
 #n(*args, **kw)
 #or fn in self.listeners:
 #n(*args, **kw)

 #ef __len__(self):
 #eturn len(self.parent_listeners) + len(self.listeners)

 #ef __iter__(self):
 #eturn chain(self.parent_listeners, self.listeners)

 #ef __bool__(self):
 #eturn bool(self.listeners or self.parent_listeners)

 #_nonzero__ = __bool__


class _ListenerCollection(_CompoundListener):
 #""Instance-level attributes on instances of :class:`._Dispatch`.

 #epresents a collection of listeners.

 #s of 0.7.9, _ListenerCollection is only first
 #reated via the _EmptyListener.for_modify() method.

 #""

 #_slots__ = (
 #parent_listeners",
 #parent",
 #name",
 #listeners",
 #propagate",
 #__weakref__",
 #

 #ef __init__(self, parent, target_cls):
 #f target_cls not in parent._clslevel:
 #arent.update_subclass(target_cls)
 #elf._exec_once = False
 #elf._exec_w_sync_once = False
 #elf.parent_listeners = parent._clslevel[target_cls]
 #elf.parent = parent
 #elf.name = parent.name
 #elf.listeners = collections.deque()
 #elf.propagate = set()

 #ef for_modify(self, obj):
 #""Return an event collection which can be modified.

 #or _ListenerCollection at the instance level of
 # dispatcher, this returns self.

 #""
 #eturn self

 #ef _update(self, other, only_propagate=True):
 #""Populate from the listeners in another :class:`_Dispatch`
 #bject."""

 #xisting_listeners = self.listeners
 #xisting_listener_set = set(existing_listeners)
 #elf.propagate.update(other.propagate)
 #ther_listeners = [
 #
 #or l in other.listeners
 #f l not in existing_listener_set
 #nd not only_propagate
 #r l in self.propagate
 #

 #xisting_listeners.extend(other_listeners)

 #o_associate = other.propagate.union(other_listeners)
 #egistry._stored_in_collection_multi(self, other, to_associate)

 #ef insert(self, event_key, propagate):
 #f event_key.prepend_to_list(self, self.listeners):
 #f propagate:
 #elf.propagate.add(event_key._listen_fn)

 #ef append(self, event_key, propagate):
 #f event_key.append_to_list(self, self.listeners):
 #f propagate:
 #elf.propagate.add(event_key._listen_fn)

 #ef remove(self, event_key):
 #elf.listeners.remove(event_key._listen_fn)
 #elf.propagate.discard(event_key._listen_fn)
 #egistry._removed_from_collection(event_key, self)

 #ef clear(self):
 #egistry._clear(self, self.listeners)
 #elf.propagate.clear()
 #elf.listeners.clear()


class _JoinedListener(_CompoundListener):
 #_slots__ = "parent", "name", "local", "parent_listeners"

 #ef __init__(self, parent, name, local):
 #elf._exec_once = False
 #elf.parent = parent
 #elf.name = name
 #elf.local = local
 #elf.parent_listeners = self.local

 #property
 #ef listeners(self):
 #eturn getattr(self.parent, self.name)

 #ef _adjust_fn_spec(self, fn, named):
 #eturn self.local._adjust_fn_spec(fn, named)

 #ef for_modify(self, obj):
 #elf.local = self.parent_listeners = self.local.for_modify(obj)
 #eturn self

 #ef insert(self, event_key, propagate):
 #elf.local.insert(event_key, propagate)

 #ef append(self, event_key, propagate):
 #elf.local.append(event_key, propagate)

 #ef remove(self, event_key):
 #elf.local.remove(event_key)

 #ef clear(self):
 #aise NotImplementedError()
