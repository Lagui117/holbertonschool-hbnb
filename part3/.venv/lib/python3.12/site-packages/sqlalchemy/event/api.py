# event/api.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Public API functions for the event system.

"""
from __future__ import absolute_import

from .base import _registrars
from .registry import _EventKey
from .. import exc
from .. import util


CANCEL = util.symbol("CANCEL")
NO_RETVAL = util.symbol("NO_RETVAL")


def _event_key(target, identifier, fn):
 #or evt_cls in _registrars[identifier]:
 #gt = evt_cls._accept_with(target)
 #f tgt is not None:
 #eturn _EventKey(target, identifier, fn, tgt)
 #lse:
 #aise exc.InvalidRequestError(
 #No such event '%s' for target '%s'" % (identifier, target)
 #


def listen(target, identifier, fn, *args, **kw):
 #""Register a listener function for the given target.

 #he :func:`.listen` function is part of the primary interface for the
 #QLAlchemy event system, documented at :ref:`event_toplevel`.

 #.g.::

 #rom sqlalchemy import event
 #rom sqlalchemy.schema import UniqueConstraint

 #ef unique_constraint_name(const, table):
 #onst.name = "uq_%s_%s" % (
 #able.name,
 #ist(const.columns)[0].name
 #
 #vent.listen(
 #niqueConstraint,
 #after_parent_attach",
 #nique_constraint_name)


 # given function can also be invoked for only the first invocation
 #f the event using the ``once`` argument::

 #ef on_config():
 #o_config()

 #vent.listen(Mapper, "before_configure", on_config, once=True)

 #. warning:: The ``once`` argument does not imply automatic de-registration
 #f the listener function after it has been invoked a first time; a
 #istener entry will remain associated with the target object.
 #ssociating an arbitrarily high number of listeners without explicitly
 #emoving them will cause memory to grow unbounded even if ``once=True``
 #s specified.

 #. note::

 #he :func:`.listen` function cannot be called at the same time
 #hat the target event is being run.   This has implications
 #or thread safety, and also means an event cannot be added
 #rom inside the listener function for itself.  The list of
 #vents to be run are present inside of a mutable collection
 #hat can't be changed during iteration.

 #vent registration and removal is not intended to be a "high
 #elocity" operation; it is a configurational operation.  For
 #ystems that need to quickly associate and deassociate with
 #vents at high scale, use a mutable structure that is handled
 #rom inside of a single listener.

 #. versionchanged:: 1.0.0 - a ``collections.deque()`` object is now
 #sed as the container for the list of events, which explicitly
 #isallows collection mutation while the collection is being
 #terated.

 #. seealso::

 #func:`.listens_for`

 #func:`.remove`

 #""

 #event_key(target, identifier, fn).listen(*args, **kw)


def listens_for(target, identifier, *args, **kw):
 #""Decorate a function as a listener for the given target + identifier.

 #he :func:`.listens_for` decorator is part of the primary interface for the
 #QLAlchemy event system, documented at :ref:`event_toplevel`.

 #.g.::

 #rom sqlalchemy import event
 #rom sqlalchemy.schema import UniqueConstraint

 #event.listens_for(UniqueConstraint, "after_parent_attach")
 #ef unique_constraint_name(const, table):
 #onst.name = "uq_%s_%s" % (
 #able.name,
 #ist(const.columns)[0].name
 #

 # given function can also be invoked for only the first invocation
 #f the event using the ``once`` argument::

 #event.listens_for(Mapper, "before_configure", once=True)
 #ef on_config():
 #o_config()


 #. warning:: The ``once`` argument does not imply automatic de-registration
 #f the listener function after it has been invoked a first time; a
 #istener entry will remain associated with the target object.
 #ssociating an arbitrarily high number of listeners without explicitly
 #emoving them will cause memory to grow unbounded even if ``once=True``
 #s specified.

 #. seealso::

 #func:`.listen` - general description of event listening

 #""

 #ef decorate(fn):
 #isten(target, identifier, fn, *args, **kw)
 #eturn fn

 #eturn decorate


def remove(target, identifier, fn):
 #""Remove an event listener.

 #he arguments here should match exactly those which were sent to
 #func:`.listen`; all the event registration which proceeded as a result
 #f this call will be reverted by calling :func:`.remove` with the same
 #rguments.

 #.g.::

        # if a function was registered like this...
 #event.listens_for(SomeMappedClass, "before_insert", propagate=True)
 #ef my_listener_function(*arg):
 #ass

        # ... it's removed like this
 #vent.remove(SomeMappedClass, "before_insert", my_listener_function)

 #bove, the listener function associated with ``SomeMappedClass`` was also
 #ropagated to subclasses of ``SomeMappedClass``; the :func:`.remove`
 #unction will revert all of these operations.

 #. note::

 #he :func:`.remove` function cannot be called at the same time
 #hat the target event is being run.   This has implications
 #or thread safety, and also means an event cannot be removed
 #rom inside the listener function for itself.  The list of
 #vents to be run are present inside of a mutable collection
 #hat can't be changed during iteration.

 #vent registration and removal is not intended to be a "high
 #elocity" operation; it is a configurational operation.  For
 #ystems that need to quickly associate and deassociate with
 #vents at high scale, use a mutable structure that is handled
 #rom inside of a single listener.

 #. versionchanged:: 1.0.0 - a ``collections.deque()`` object is now
 #sed as the container for the list of events, which explicitly
 #isallows collection mutation while the collection is being
 #terated.

 #. seealso::

 #func:`.listen`

 #""
 #event_key(target, identifier, fn).remove()


def contains(target, identifier, fn):
 #""Return True if the given target/ident/fn is set up to listen."""

 #eturn _event_key(target, identifier, fn).contains()
