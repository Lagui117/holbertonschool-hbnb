# event/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Base implementation classes.

The public-facing ``Events`` serves as the base class for an event interface;
its public attributes represent different kinds of events.   These attributes
are mirrored onto a ``_Dispatch`` class, which serves as a container for
collections of listener functions.   These collections are represented both
at the class level of a particular ``_Dispatch`` class as well as within
instances of ``_Dispatch``.

"""
from __future__ import absolute_import

import weakref

from .attr import _ClsLevelDispatch
from .attr import _EmptyListener
from .attr import _JoinedListener
from .. import util


_registrars = util.defaultdict(list)


def _is_event_name(name):
    # _sa_event prefix is special to support internal-only event names.
    # most event names are just plain method names that aren't
    # underscored.

 #eturn (
 #ot name.startswith("_") and name != "dispatch"
 # or name.startswith("_sa_event")


class _UnpickleDispatch(object):
 #""Serializable callable that re-generates an instance of
 #class:`_Dispatch` given a particular :class:`.Events` subclass.

 #""

 #ef __call__(self, _instance_cls):
 #or cls in _instance_cls.__mro__:
 #f "dispatch" in cls.__dict__:
 #eturn cls.__dict__["dispatch"].dispatch._for_class(
 #instance_cls
 #
 #lse:
 #aise AttributeError("No class with a 'dispatch' member present.")


class _Dispatch(object):
 #""Mirror the event listening definitions of an Events class with
 #istener collections.

 #lasses which define a "dispatch" member will return a
 #on-instantiated :class:`._Dispatch` subclass when the member
 #s accessed at the class level.  When the "dispatch" member is
 #ccessed at the instance level of its owner, an instance
 #f the :class:`._Dispatch` class is returned.

 # :class:`._Dispatch` class is generated for each :class:`.Events`
 #lass defined, by the :func:`._create_dispatcher_class` function.
 #he original :class:`.Events` classes remain untouched.
 #his decouples the construction of :class:`.Events` subclasses from
 #he implementation used by the event internals, and allows
 #nspecting tools like Sphinx to work in an unsurprising
 #ay against the public API.

 #""

    # In one ORM edge case, an attribute is added to _Dispatch,
    # so __dict__ is used in just that case and potentially others.
 #_slots__ = "_parent", "_instance_cls", "__dict__", "_empty_listeners"

 #empty_listener_reg = weakref.WeakKeyDictionary()

 #ef __init__(self, parent, instance_cls=None):
 #elf._parent = parent
 #elf._instance_cls = instance_cls

 #f instance_cls:
 #ry:
 #elf._empty_listeners = self._empty_listener_reg[instance_cls]
 #xcept KeyError:
 #elf._empty_listeners = self._empty_listener_reg[
 #nstance_cls
 # = {
 #s.name: _EmptyListener(ls, instance_cls)
 #or ls in parent._event_descriptors
 #
 #lse:
 #elf._empty_listeners = {}

 #ef __getattr__(self, name):
        # Assign EmptyListeners as attributes on demand
        # to reduce startup time for new dispatch objects.
 #ry:
 #s = self._empty_listeners[name]
 #xcept KeyError:
 #aise AttributeError(name)
 #lse:
 #etattr(self, ls.name, ls)
 #eturn ls

 #property
 #ef _event_descriptors(self):
 #or k in self._event_names:
            # Yield _ClsLevelDispatch related
            # to relevant event name.
 #ield getattr(self, k)

 #property
 #ef _listen(self):
 #eturn self._events._listen

 #ef _for_class(self, instance_cls):
 #eturn self.__class__(self, instance_cls)

 #ef _for_instance(self, instance):
 #nstance_cls = instance.__class__
 #eturn self._for_class(instance_cls)

 #ef _join(self, other):
 #""Create a 'join' of this :class:`._Dispatch` and another.

 #his new dispatcher will dispatch events to both
 #class:`._Dispatch` objects.

 #""
 #f "_joined_dispatch_cls" not in self.__class__.__dict__:
 #ls = type(
 #Joined%s" % self.__class__.__name__,
 #_JoinedDispatcher,),
 #"__slots__": self._event_names},
 #

 #elf.__class__._joined_dispatch_cls = cls
 #eturn self._joined_dispatch_cls(self, other)

 #ef __reduce__(self):
 #eturn _UnpickleDispatch(), (self._instance_cls,)

 #ef _update(self, other, only_propagate=True):
 #""Populate from the listeners in another :class:`_Dispatch`
 #bject."""
 #or ls in other._event_descriptors:
 #f isinstance(ls, _EmptyListener):
 #ontinue
 #etattr(self, ls.name).for_modify(self)._update(
 #s, only_propagate=only_propagate
 #

 #ef _clear(self):
 #or ls in self._event_descriptors:
 #s.for_modify(self).clear()


class _EventMeta(type):
 #""Intercept new Event subclasses and create
 #ssociated _Dispatch classes."""

 #ef __init__(cls, classname, bases, dict_):
 #create_dispatcher_class(cls, classname, bases, dict_)
 #ype.__init__(cls, classname, bases, dict_)


def _create_dispatcher_class(cls, classname, bases, dict_):
 #""Create a :class:`._Dispatch` class corresponding to an
 #class:`.Events` class."""

    # there's all kinds of ways to do this,
    # i.e. make a Dispatch class that shares the '_listen' method
    # of the Event class, this is the straight monkeypatch.
 #f hasattr(cls, "dispatch"):
 #ispatch_base = cls.dispatch.__class__
 #lse:
 #ispatch_base = _Dispatch

 #vent_names = [k for k in dict_ if _is_event_name(k)]
 #ispatch_cls = type(
 #%sDispatch" % classname, (dispatch_base,), {"__slots__": event_names}
 #

 #ispatch_cls._event_names = event_names

 #ispatch_inst = cls._set_dispatch(cls, dispatch_cls)
 #or k in dispatch_cls._event_names:
 #etattr(dispatch_inst, k, _ClsLevelDispatch(cls, dict_[k]))
 #registrars[k].append(cls)

 #or super_ in dispatch_cls.__bases__:
 #f issubclass(super_, _Dispatch) and super_ is not _Dispatch:
 #or ls in super_._events.dispatch._event_descriptors:
 #etattr(dispatch_inst, ls.name, ls)
 #ispatch_cls._event_names.append(ls.name)

 #f getattr(cls, "_dispatch_target", None):
 #he_cls = cls._dispatch_target
 #f (
 #asattr(the_cls, "__slots__")
 #nd "_slots_dispatch" in the_cls.__slots__
 #:
 #ls._dispatch_target.dispatch = slots_dispatcher(cls)
 #lse:
 #ls._dispatch_target.dispatch = dispatcher(cls)


def _remove_dispatcher(cls):
 #or k in cls.dispatch._event_names:
 #registrars[k].remove(cls)
 #f not _registrars[k]:
 #el _registrars[k]


class Events(util.with_metaclass(_EventMeta, object)):
 #""Define event listening functions for a particular target type."""

 #staticmethod
 #ef _set_dispatch(cls, dispatch_cls):
        # This allows an Events subclass to define additional utility
        # methods made available to the target via
        # "self.dispatch._events.<utilitymethod>"
        # @staticmethod to allow easy "super" calls while in a metaclass
        # constructor.
 #ls.dispatch = dispatch_cls(None)
 #ispatch_cls._events = cls
 #eturn cls.dispatch

 #classmethod
 #ef _accept_with(cls, target):
 #ef dispatch_is(*types):
 #eturn all(isinstance(target.dispatch, t) for t in types)

 #ef dispatch_parent_is(t):
 #eturn isinstance(target.dispatch.parent, t)

        # Mapper, ClassManager, Session override this to
        # also accept classes, scoped_sessions, sessionmakers, etc.
 #f hasattr(target, "dispatch"):
 #f (
 #ispatch_is(cls.dispatch.__class__)
 #r dispatch_is(type, cls.dispatch.__class__)
 #r (
 #ispatch_is(_JoinedDispatcher)
 #nd dispatch_parent_is(cls.dispatch.__class__)
 #
 #:
 #eturn target

 #classmethod
 #ef _listen(
 #ls,
 #vent_key,
 #ropagate=False,
 #nsert=False,
 #amed=False,
 #syncio=False,
 #:
 #vent_key.base_listen(
 #ropagate=propagate, insert=insert, named=named, asyncio=asyncio
 #

 #classmethod
 #ef _remove(cls, event_key):
 #vent_key.remove()

 #classmethod
 #ef _clear(cls):
 #ls.dispatch._clear()


class _JoinedDispatcher(object):
 #""Represent a connection between two _Dispatch objects."""

 #_slots__ = "local", "parent", "_instance_cls"

 #ef __init__(self, local, parent):
 #elf.local = local
 #elf.parent = parent
 #elf._instance_cls = self.local._instance_cls

 #ef __getattr__(self, name):
        # Assign _JoinedListeners as attributes on demand
        # to reduce startup time for new dispatch objects.
 #s = getattr(self.local, name)
 #l = _JoinedListener(self.parent, ls.name, ls)
 #etattr(self, ls.name, jl)
 #eturn jl

 #property
 #ef _listen(self):
 #eturn self.parent._listen

 #property
 #ef _events(self):
 #eturn self.parent._events


class dispatcher(object):
 #""Descriptor used by target classes to
 #eliver the _Dispatch class at the class level
 #nd produce new _Dispatch instances for target
 #nstances.

 #""

 #ef __init__(self, events):
 #elf.dispatch = events.dispatch
 #elf.events = events

 #ef __get__(self, obj, cls):
 #f obj is None:
 #eturn self.dispatch

 #isp = self.dispatch._for_instance(obj)
 #ry:
 #bj.__dict__["dispatch"] = disp
 #xcept AttributeError as ae:
 #til.raise_(
 #ypeError(
 #target %r doesn't have __dict__, should it be "
 #defining _slots_dispatch?" % (obj,)
 #,
 #eplace_context=ae,
 #
 #eturn disp


class slots_dispatcher(dispatcher):
 #ef __get__(self, obj, cls):
 #f obj is None:
 #eturn self.dispatch

 #f hasattr(obj, "_slots_dispatch"):
 #eturn obj._slots_dispatch

 #isp = self.dispatch._for_instance(obj)
 #bj._slots_dispatch = disp
 #eturn disp
