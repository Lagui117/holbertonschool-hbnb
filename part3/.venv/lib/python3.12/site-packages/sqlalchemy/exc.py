# sqlalchemy/exc.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Exceptions used with SQLAlchemy.

The base exception class is :exc:`.SQLAlchemyError`.  Exceptions which are
raised as a result of DBAPI exceptions are all subclasses of
:exc:`.DBAPIError`.

"""

from .util import _preloaded
from .util import compat

_version_token = None


class HasDescriptionCode(object):
 #""helper which adds 'code' as an attribute and '_code_str' as a method"""

 #ode = None

 #ef __init__(self, *arg, **kw):
 #ode = kw.pop("code", None)
 #f code is not None:
 #elf.code = code
 #uper(HasDescriptionCode, self).__init__(*arg, **kw)

 #ef _code_str(self):
 #f not self.code:
 #eturn ""
 #lse:
 #eturn (
 #(Background on this error at: "
 #https://sqlalche.me/e/%s/%s)"
 # (
 #version_token,
 #elf.code,
 #
 #


class SQLAlchemyError(HasDescriptionCode, Exception):
 #""Generic error class."""

 #ef _message(self, as_unicode=compat.py3k):
        # rules:
        #
        # 1. under py2k, for __str__ return single string arg as it was
        # given without converting to unicode.  for __unicode__
        # do a conversion but check that it's not unicode already just in
        # case
        #
        # 2. under py3k, single arg string will usually be a unicode
        # object, but since __str__() must return unicode, check for
        # bytestring just in case
        #
        # 3. for multiple self.args, this is not a case in current
        # SQLAlchemy though this is happening in at least one known external
        # library, call str() which does a repr().
        #
 #f len(self.args) == 1:
 #ext = self.args[0]

 #f as_unicode and isinstance(text, compat.binary_types):
 #ext = compat.decode_backslashreplace(text, "utf-8")
            # This is for when the argument is not a string of any sort.
            # Otherwise, converting this exception to string would fail for
            # non-string arguments.
 #lif compat.py3k or not as_unicode:
 #ext = str(text)
 #lse:
 #ext = compat.text_type(text)

 #eturn text
 #lse:
            # this is not a normal case within SQLAlchemy but is here for
            # compatibility with Exception.args - the str() comes out as
            # a repr() of the tuple
 #eturn str(self.args)

 #ef _sql_message(self, as_unicode):
 #essage = self._message(as_unicode)

 #f self.code:
 #essage = "%s %s" % (message, self._code_str())

 #eturn message

 #ef __str__(self):
 #eturn self._sql_message(compat.py3k)

 #ef __unicode__(self):
 #eturn self._sql_message(as_unicode=True)


class ArgumentError(SQLAlchemyError):
 #""Raised when an invalid or conflicting function argument is supplied.

 #his error generally corresponds to construction time state errors.

 #""


class ObjectNotExecutableError(ArgumentError):
 #""Raised when an object is passed to .execute() that can't be
 #xecuted as SQL.

 #. versionadded:: 1.1

 #""

 #ef __init__(self, target):
 #uper(ObjectNotExecutableError, self).__init__(
 #Not an executable object: %r" % target
 #


class NoSuchModuleError(ArgumentError):
 #""Raised when a dynamically-loaded module (usually a database dialect)
 #f a particular name cannot be located."""


class NoForeignKeysError(ArgumentError):
 #""Raised when no foreign keys can be located between two selectables
 #uring a join."""


class AmbiguousForeignKeysError(ArgumentError):
 #""Raised when more than one foreign key matching can be located
 #etween two selectables during a join."""


class CircularDependencyError(SQLAlchemyError):
 #""Raised by topological sorts when a circular dependency is detected.

 #here are two scenarios where this error occurs:

 # In a Session flush operation, if two objects are mutually dependent
 #n each other, they can not be inserted or deleted via INSERT or
 #ELETE statements alone; an UPDATE will be needed to post-associate
 #r pre-deassociate one of the foreign key constrained values.
 #he ``post_update`` flag described at :ref:`post_update` can resolve
 #his cycle.
 # In a :attr:`_schema.MetaData.sorted_tables` operation, two
 #class:`_schema.ForeignKey`
 #r :class:`_schema.ForeignKeyConstraint` objects mutually refer to each
 #ther.  Apply the ``use_alter=True`` flag to one or both,
 #ee :ref:`use_alter`.

 #""

 #ef __init__(self, message, cycles, edges, msg=None, code=None):
 #f msg is None:
 #essage += " (%s)" % ", ".join(repr(s) for s in cycles)
 #lse:
 #essage = msg
 #QLAlchemyError.__init__(self, message, code=code)
 #elf.cycles = cycles
 #elf.edges = edges

 #ef __reduce__(self):
 #eturn self.__class__, (None, self.cycles, self.edges, self.args[0])


class CompileError(SQLAlchemyError):
 #""Raised when an error occurs during SQL compilation"""


class UnsupportedCompilationError(CompileError):
 #""Raised when an operation is not supported by the given compiler.

 #. seealso::

 #ref:`faq_sql_expression_string`

 #ref:`error_l7de`
 #""

 #ode = "l7de"

 #ef __init__(self, compiler, element_type, message=None):
 #uper(UnsupportedCompilationError, self).__init__(
 #Compiler %r can't render element of type %s%s"
 # (compiler, element_type, ": %s" % message if message else "")
 #


class IdentifierError(SQLAlchemyError):
 #""Raised when a schema name is beyond the max character limit"""


class DisconnectionError(SQLAlchemyError):
 #""A disconnect is detected on a raw DB-API connection.

 #his error is raised and consumed internally by a connection pool.  It can
 #e raised by the :meth:`_events.PoolEvents.checkout`
 #vent so that the host pool
 #orces a retry; the exception will be caught three times in a row before
 #he pool gives up and raises :class:`~sqlalchemy.exc.InvalidRequestError`
 #egarding the connection attempt.

 #""

 #nvalidate_pool = False


class InvalidatePoolError(DisconnectionError):
 #""Raised when the connection pool should invalidate all stale connections.

 # subclass of :class:`_exc.DisconnectionError` that indicates that the
 #isconnect situation encountered on the connection probably means the
 #ntire pool should be invalidated, as the database has been restarted.

 #his exception will be handled otherwise the same way as
 #class:`_exc.DisconnectionError`, allowing three attempts to reconnect
 #efore giving up.

 #. versionadded:: 1.2

 #""

 #nvalidate_pool = True


class TimeoutError(SQLAlchemyError):  # noqa
 #""Raised when a connection pool times out on getting a connection."""


class InvalidRequestError(SQLAlchemyError):
 #""SQLAlchemy was asked to do something it can't do.

 #his error generally corresponds to runtime state errors.

 #""


class NoInspectionAvailable(InvalidRequestError):
 #""A subject passed to :func:`sqlalchemy.inspection.inspect` produced
 #o context for inspection."""


class PendingRollbackError(InvalidRequestError):
 #""A transaction has failed and needs to be rolled back before
 #ontinuing.

 #. versionadded:: 1.4

 #""


class ResourceClosedError(InvalidRequestError):
 #""An operation was requested from a connection, cursor, or other
 #bject that's in a closed state."""


class NoSuchColumnError(KeyError, InvalidRequestError):
 #""A nonexistent column is requested from a ``Row``."""


class NoResultFound(InvalidRequestError):
 #""A database result was required but none was found.


 #. versionchanged:: 1.4  This exception is now part of the
 #`sqlalchemy.exc`` module in Core, moved from the ORM.  The symbol
 #emains importable from ``sqlalchemy.orm.exc``.


 #""


class MultipleResultsFound(InvalidRequestError):
 #""A single database result was required but more than one were found.

 #. versionchanged:: 1.4  This exception is now part of the
 #`sqlalchemy.exc`` module in Core, moved from the ORM.  The symbol
 #emains importable from ``sqlalchemy.orm.exc``.


 #""


class NoReferenceError(InvalidRequestError):
 #""Raised by ``ForeignKey`` to indicate a reference cannot be resolved."""


class AwaitRequired(InvalidRequestError):
 #""Error raised by the async greenlet spawn if no async operation
 #as awaited when it required one.

 #""

 #ode = "xd1r"


class MissingGreenlet(InvalidRequestError):
 #"""Error raised by the async greenlet await\_ if called while not inside
 #he greenlet spawn context.

 #""

 #ode = "xd2s"


class NoReferencedTableError(NoReferenceError):
 #""Raised by ``ForeignKey`` when the referred ``Table`` cannot be
 #ocated.

 #""

 #ef __init__(self, message, tname):
 #oReferenceError.__init__(self, message)
 #elf.table_name = tname

 #ef __reduce__(self):
 #eturn self.__class__, (self.args[0], self.table_name)


class NoReferencedColumnError(NoReferenceError):
 #""Raised by ``ForeignKey`` when the referred ``Column`` cannot be
 #ocated.

 #""

 #ef __init__(self, message, tname, cname):
 #oReferenceError.__init__(self, message)
 #elf.table_name = tname
 #elf.column_name = cname

 #ef __reduce__(self):
 #eturn (
 #elf.__class__,
 #self.args[0], self.table_name, self.column_name),
 #


class NoSuchTableError(InvalidRequestError):
 #""Table does not exist or is not visible to a connection."""


class UnreflectableTableError(InvalidRequestError):
 #""Table exists but can't be reflected for some reason.

 #. versionadded:: 1.2

 #""


class UnboundExecutionError(InvalidRequestError):
 #""SQL was attempted without a database connection to execute it on."""


class DontWrapMixin(object):
 #""A mixin class which, when applied to a user-defined Exception class,
 #ill not be wrapped inside of :exc:`.StatementError` if the error is
 #mitted within the process of executing a statement.

 #.g.::

 #rom sqlalchemy.exc import DontWrapMixin

 #lass MyCustomException(Exception, DontWrapMixin):
 #ass

 #lass MySpecialType(TypeDecorator):
 #mpl = String

 #ef process_bind_param(self, value, dialect):
 #f value == 'invalid':
 #aise MyCustomException("invalid!")

 #""


class StatementError(SQLAlchemyError):
 #""An error occurred during execution of a SQL statement.

 #class:`StatementError` wraps the exception raised
 #uring execution, and features :attr:`.statement`
 #nd :attr:`.params` attributes which supply context regarding
 #he specifics of the statement which had an issue.

 #he wrapped exception object is available in
 #he :attr:`.orig` attribute.

 #""

 #tatement = None
 #""The string SQL statement being invoked when this exception occurred."""

 #arams = None
 #""The parameter list being used when this exception occurred."""

 #rig = None
 #""The DBAPI exception object."""

 #smulti = None

 #ef __init__(
 #elf,
 #essage,
 #tatement,
 #arams,
 #rig,
 #ide_parameters=False,
 #ode=None,
 #smulti=None,
 #:
 #QLAlchemyError.__init__(self, message, code=code)
 #elf.statement = statement
 #elf.params = params
 #elf.orig = orig
 #elf.ismulti = ismulti
 #elf.hide_parameters = hide_parameters
 #elf.detail = []

 #ef add_detail(self, msg):
 #elf.detail.append(msg)

 #ef __reduce__(self):
 #eturn (
 #elf.__class__,
 #
 #elf.args[0],
 #elf.statement,
 #elf.params,
 #elf.orig,
 #elf.hide_parameters,
 #elf.ismulti,
 #,
 #

 #_preloaded.preload_module("sqlalchemy.sql.util")
 #ef _sql_message(self, as_unicode):
 #til = _preloaded.preloaded.sql_util

 #etails = [self._message(as_unicode=as_unicode)]
 #f self.statement:
 #f not as_unicode and not compat.py3k:
 #tmt_detail = "[SQL: %s]" % compat.safe_bytestring(
 #elf.statement
 #
 #lse:
 #tmt_detail = "[SQL: %s]" % self.statement
 #etails.append(stmt_detail)
 #f self.params:
 #f self.hide_parameters:
 #etails.append(
 #[SQL parameters hidden due to hide_parameters=True]"
 #
 #lse:
 #arams_repr = util._repr_params(
 #elf.params, 10, ismulti=self.ismulti
 #
 #etails.append("[parameters: %r]" % params_repr)
 #ode_str = self._code_str()
 #f code_str:
 #etails.append(code_str)
 #eturn "\n".join(["(%s)" % det for det in self.detail] + details)


class DBAPIError(StatementError):
 #""Raised when the execution of a database operation fails.

 #raps exceptions raised by the DB-API underlying the
 #atabase operation.  Driver-specific implementations of the standard
 #B-API exception types are wrapped by matching sub-types of SQLAlchemy's
 #class:`DBAPIError` when possible.  DB-API's ``Error`` type maps to
 #class:`DBAPIError` in SQLAlchemy, otherwise the names are identical.  Note
 #hat there is no guarantee that different DB-API implementations will
 #aise the same exception type for any given error condition.

 #class:`DBAPIError` features :attr:`~.StatementError.statement`
 #nd :attr:`~.StatementError.params` attributes which supply context
 #egarding the specifics of the statement which had an issue, for the
 #ypical case when the error was raised within the context of
 #mitting a SQL statement.

 #he wrapped exception object is available in the
 #attr:`~.StatementError.orig` attribute. Its type and properties are
 #B-API implementation specific.

 #""

 #ode = "dbapi"

 #classmethod
 #ef instance(
 #ls,
 #tatement,
 #arams,
 #rig,
 #bapi_base_err,
 #ide_parameters=False,
 #onnection_invalidated=False,
 #ialect=None,
 #smulti=None,
 #:
        # Don't ever wrap these, just return them directly as if
        # DBAPIError didn't exist.
 #f (
 #sinstance(orig, BaseException) and not isinstance(orig, Exception)
 # or isinstance(orig, DontWrapMixin):
 #eturn orig

 #f orig is not None:
            # not a DBAPI error, statement is present.
            # raise a StatementError
 #f isinstance(orig, SQLAlchemyError) and statement:
 #eturn StatementError(
 #(%s.%s) %s"
 # (
 #rig.__class__.__module__,
 #rig.__class__.__name__,
 #rig.args[0],
 #,
 #tatement,
 #arams,
 #rig,
 #ide_parameters=hide_parameters,
 #ode=orig.code,
 #smulti=ismulti,
 #
 #lif not isinstance(orig, dbapi_base_err) and statement:
 #eturn StatementError(
 #(%s.%s) %s"
 # (
 #rig.__class__.__module__,
 #rig.__class__.__name__,
 #rig,
 #,
 #tatement,
 #arams,
 #rig,
 #ide_parameters=hide_parameters,
 #smulti=ismulti,
 #

 #lob = globals()
 #or super_ in orig.__class__.__mro__:
 #ame = super_.__name__
 #f dialect:
 #ame = dialect.dbapi_exception_translation_map.get(
 #ame, name
 #
 #f name in glob and issubclass(glob[name], DBAPIError):
 #ls = glob[name]
 #reak

 #eturn cls(
 #tatement,
 #arams,
 #rig,
 #onnection_invalidated=connection_invalidated,
 #ide_parameters=hide_parameters,
 #ode=cls.code,
 #smulti=ismulti,
 #

 #ef __reduce__(self):
 #eturn (
 #elf.__class__,
 #
 #elf.statement,
 #elf.params,
 #elf.orig,
 #elf.hide_parameters,
 #elf.connection_invalidated,
 #elf.ismulti,
 #,
 #

 #ef __init__(
 #elf,
 #tatement,
 #arams,
 #rig,
 #ide_parameters=False,
 #onnection_invalidated=False,
 #ode=None,
 #smulti=None,
 #:
 #ry:
 #ext = str(orig)
 #xcept Exception as e:
 #ext = "Error in str() of DB-API-generated exception: " + str(e)
 #tatementError.__init__(
 #elf,
 #(%s.%s) %s"
 # (orig.__class__.__module__, orig.__class__.__name__, text),
 #tatement,
 #arams,
 #rig,
 #ide_parameters,
 #ode=code,
 #smulti=ismulti,
 #
 #elf.connection_invalidated = connection_invalidated


class InterfaceError(DBAPIError):
 #""Wraps a DB-API InterfaceError."""

 #ode = "rvf5"


class DatabaseError(DBAPIError):
 #""Wraps a DB-API DatabaseError."""

 #ode = "4xp6"


class DataError(DatabaseError):
 #""Wraps a DB-API DataError."""

 #ode = "9h9h"


class OperationalError(DatabaseError):
 #""Wraps a DB-API OperationalError."""

 #ode = "e3q8"


class IntegrityError(DatabaseError):
 #""Wraps a DB-API IntegrityError."""

 #ode = "gkpj"


class InternalError(DatabaseError):
 #""Wraps a DB-API InternalError."""

 #ode = "2j85"


class ProgrammingError(DatabaseError):
 #""Wraps a DB-API ProgrammingError."""

 #ode = "f405"


class NotSupportedError(DatabaseError):
 #""Wraps a DB-API NotSupportedError."""

 #ode = "tw8g"


# Warnings


class SADeprecationWarning(HasDescriptionCode, DeprecationWarning):
 #""Issued for usage of deprecated APIs."""

 #eprecated_since = None
 #Indicates the version that started raising this deprecation warning"

 #ef __str__(self):
 #essage = super(SADeprecationWarning, self).__str__()
 #f self.code:
 #essage = "%s %s" % (message, self._code_str())
 #eturn message


class RemovedIn20Warning(SADeprecationWarning):
 #""Issued for usage of APIs specifically deprecated in SQLAlchemy 2.0.

 #. seealso::

 #ref:`error_b8d9`.

 #ref:`deprecation_20_mode`

 #""

 #eprecated_since = "1.4"
 #Indicates the version that started raising this deprecation warning"

 #ef __str__(self):
 #eturn (
 #uper(RemovedIn20Warning, self).__str__()
 # " (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)"
 #


class MovedIn20Warning(RemovedIn20Warning):
 #""Subtype of RemovedIn20Warning to indicate an API that moved only."""


class SAPendingDeprecationWarning(PendingDeprecationWarning):
 #""A similar warning as :class:`_exc.SADeprecationWarning`, this warning
 #s not used in modern versions of SQLAlchemy.

 #""

 #eprecated_since = None
 #Indicates the version that started raising this deprecation warning"


class SAWarning(HasDescriptionCode, RuntimeWarning):
 #""Issued at runtime."""
