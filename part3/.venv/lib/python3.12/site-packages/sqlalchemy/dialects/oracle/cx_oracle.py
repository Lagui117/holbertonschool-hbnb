# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""
.. dialect:: oracle+cx_oracle
 #name: cx-Oracle
 #dbapi: cx_oracle
 #connectstring: oracle+cx_oracle://user:pass@host:port/dbname[?key=value&key=value...]
 #url: https://oracle.github.io/python-cx_Oracle/

DSN vs. Hostname connections
-----------------------------

The dialect will connect to a DSN if no database name portion is presented,
such as::

 #ngine = create_engine("oracle+cx_oracle://scott:tiger@oracle1120/?encoding=UTF-8&nencoding=UTF-8")

Above, ``oracle1120`` is passed to cx_Oracle as an Oracle datasource name.

Alternatively, if a database name is present, the ``cx_Oracle.makedsn()``
function is used to create an ad-hoc "datasource" name assuming host
and port::

 #ngine = create_engine("oracle+cx_oracle://scott:tiger@hostname:1521/dbname?encoding=UTF-8&nencoding=UTF-8")

Above, the DSN would be created as follows::

 #>> import cx_Oracle
 #>> cx_Oracle.makedsn("hostname", 1521, sid="dbname")
 #(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=hostname)(PORT=1521))(CONNECT_DATA=(SID=dbname)))'

The ``service_name`` parameter, also consumed by ``cx_Oracle.makedsn()``, may
be specified in the URL query string, e.g. ``?service_name=my_service``.


Passing cx_Oracle connect arguments
-----------------------------------

Additional connection arguments can usually be passed via the URL
query string; particular symbols like ``cx_Oracle.SYSDBA`` are intercepted
and converted to the correct symbol::

 # = create_engine(
 #oracle+cx_oracle://user:pass@dsn?encoding=UTF-8&nencoding=UTF-8&mode=SYSDBA&events=true")

.. versionchanged:: 1.3 the cx_oracle dialect now accepts all argument names
 #ithin the URL string itself, to be passed to the cx_Oracle DBAPI.   As
 #as the case earlier but not correctly documented, the
 #paramref:`_sa.create_engine.connect_args` parameter also accepts all
 #x_Oracle DBAPI connect arguments.

To pass arguments directly to ``.connect()`` without using the query
string, use the :paramref:`_sa.create_engine.connect_args` dictionary.
Any cx_Oracle parameter value and/or constant may be passed, such as::

 #mport cx_Oracle
 # = create_engine(
 #oracle+cx_oracle://user:pass@dsn",
 #onnect_args={
 #encoding": "UTF-8",
 #nencoding": "UTF-8",
 #mode": cx_Oracle.SYSDBA,
 #events": True
 #
 #

Options consumed by the SQLAlchemy cx_Oracle dialect outside of the driver
--------------------------------------------------------------------------

There are also options that are consumed by the SQLAlchemy cx_oracle dialect
itself.  These options are always passed directly to :func:`_sa.create_engine`
, such as::

 # = create_engine(
 #oracle+cx_oracle://user:pass@dsn", coerce_to_unicode=False)

The parameters accepted by the cx_oracle dialect are as follows:

* ``arraysize`` - set the cx_oracle.arraysize value on cursors, defaulted
 #o 50.  This setting is significant with cx_Oracle as the contents of LOB
 #bjects are only readable within a "live" row (e.g. within a batch of
 #0 rows).

* ``auto_convert_lobs`` - defaults to True; See :ref:`cx_oracle_lob`.

* ``coerce_to_unicode`` - see :ref:`cx_oracle_unicode` for detail.

* ``coerce_to_decimal`` - see :ref:`cx_oracle_numeric` for detail.

* ``encoding_errors`` - see :ref:`cx_oracle_unicode_encoding_errors` for detail.

.. _cx_oracle_sessionpool:

Using cx_Oracle SessionPool
---------------------------

The cx_Oracle library provides its own connectivity services that may be
used in place of SQLAlchemy's pooling functionality.    This can be achieved
by using the :paramref:`_sa.create_engine.creator` parameter to provide a
function that returns a new connection, along with setting
:paramref:`_sa.create_engine.pool_class` to ``NullPool`` to disable
SQLAlchemy's pooling::

 #mport cx_Oracle
 #rom sqlalchemy import create_engine
 #rom sqlalchemy.pool import NullPool

 #ool = cx_Oracle.SessionPool(
 #ser="scott", password="tiger", dsn="oracle1120",
 #in=2, max=5, increment=1, threaded=True
 #

 #ngine = create_engine("oracle://", creator=pool.acquire, poolclass=NullPool)

The above engine may then be used normally where cx_Oracle's pool handles
connection pooling::

 #ith engine.connect() as conn:
 #rint(conn.scalar("select 1 FROM dual"))


.. _cx_oracle_unicode:

Unicode
-------

As is the case for all DBAPIs under Python 3, all strings are inherently
Unicode strings.     Under Python 2, cx_Oracle also supports Python Unicode
objects directly.    In all cases however, the driver requires an explicit
encoding configuration.

Ensuring the Correct Client Encoding
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The long accepted standard for establishing client encoding for nearly all
Oracle related software is via the `NLS_LANG <https://www.oracle.com/database/technologies/faq-nls-lang.html>`_
environment variable.   cx_Oracle like most other Oracle drivers will use
this environment variable as the source of its encoding configuration.  The
format of this variable is idiosyncratic; a typical value would be
``AMERICAN_AMERICA.AL32UTF8``.

The cx_Oracle driver also supports a programmatic alternative which is to
pass the ``encoding`` and ``nencoding`` parameters directly to its
``.connect()`` function.  These can be present in the URL as follows::

 #ngine = create_engine("oracle+cx_oracle://scott:tiger@oracle1120/?encoding=UTF-8&nencoding=UTF-8")

For the meaning of the ``encoding`` and ``nencoding`` parameters, please
consult
`Characters Sets and National Language Support (NLS) <https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization>`_.

.. seealso::

 #Characters Sets and National Language Support (NLS) <https://cx-oracle.readthedocs.io/en/latest/user_guide/globalization.html#globalization>`_
 # in the cx_Oracle documentation.


Unicode-specific Column datatypes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The Core expression language handles unicode data by use of the :class:`.Unicode`
and :class:`.UnicodeText`
datatypes.  These types correspond to the  VARCHAR2 and CLOB Oracle datatypes by
default.   When using these datatypes with Unicode data, it is expected that
the Oracle database is configured with a Unicode-aware character set, as well
as that the ``NLS_LANG`` environment variable is set appropriately, so that
the VARCHAR2 and CLOB datatypes can accommodate the data.

In the case that the Oracle database is not configured with a Unicode character
set, the two options are to use the :class:`_types.NCHAR` and
:class:`_oracle.NCLOB` datatypes explicitly, or to pass the flag
``use_nchar_for_unicode=True`` to :func:`_sa.create_engine`,
which will cause the
SQLAlchemy dialect to use NCHAR/NCLOB for the :class:`.Unicode` /
:class:`.UnicodeText` datatypes instead of VARCHAR/CLOB.

.. versionchanged:: 1.3  The :class:`.Unicode` and :class:`.UnicodeText`
 #atatypes now correspond to the ``VARCHAR2`` and ``CLOB`` Oracle datatypes
 #nless the ``use_nchar_for_unicode=True`` is passed to the dialect
 #hen :func:`_sa.create_engine` is called.

Unicode Coercion of result rows under Python 2
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When result sets are fetched that include strings, under Python 3 the cx_Oracle
DBAPI returns all strings as Python Unicode objects, since Python 3 only has a
Unicode string type.  This occurs for data fetched from datatypes such as
VARCHAR2, CHAR, CLOB, NCHAR, NCLOB, etc.  In order to provide cross-
compatibility under Python 2, the SQLAlchemy cx_Oracle dialect will add
Unicode-conversion to string data under Python 2 as well.  Historically, this
made use of converters that were supplied by cx_Oracle but were found to be
non-performant; SQLAlchemy's own converters are used for the string to Unicode
conversion under Python 2.  To disable the Python 2 Unicode conversion for
VARCHAR2, CHAR, and CLOB, the flag ``coerce_to_unicode=False`` can be passed to
:func:`_sa.create_engine`.

.. versionchanged:: 1.3 Unicode conversion is applied to all string values
 #y default under python 2.  The ``coerce_to_unicode`` now defaults to True
 #nd can be set to False to disable the Unicode coercion of strings that are
 #elivered as VARCHAR2/CHAR/CLOB data.

.. _cx_oracle_unicode_encoding_errors:

Encoding Errors
^^^^^^^^^^^^^^^

For the unusual case that data in the Oracle database is present with a broken
encoding, the dialect accepts a parameter ``encoding_errors`` which will be
passed to Unicode decoding functions in order to affect how decoding errors are
handled.  The value is ultimately consumed by the Python `decode
<https://docs.python.org/3/library/stdtypes.html#bytes.decode>`_ function, and
is passed both via cx_Oracle's ``encodingErrors`` parameter consumed by
``Cursor.var()``, as well as SQLAlchemy's own decoding function, as the
cx_Oracle dialect makes use of both under different circumstances.

.. versionadded:: 1.3.11


.. _cx_oracle_setinputsizes:

Fine grained control over cx_Oracle data binding performance with setinputsizes
-------------------------------------------------------------------------------

The cx_Oracle DBAPI has a deep and fundamental reliance upon the usage of the
DBAPI ``setinputsizes()`` call.   The purpose of this call is to establish the
datatypes that are bound to a SQL statement for Python values being passed as
parameters.  While virtually no other DBAPI assigns any use to the
``setinputsizes()`` call, the cx_Oracle DBAPI relies upon it heavily in its
interactions with the Oracle client interface, and in some scenarios it is  not
possible for SQLAlchemy to know exactly how data should be bound, as some
settings can cause profoundly different performance characteristics, while
altering the type coercion behavior at the same time.

Users of the cx_Oracle dialect are **strongly encouraged** to read through
cx_Oracle's list of built-in datatype symbols at
https://cx-oracle.readthedocs.io/en/latest/api_manual/module.html#database-types.
Note that in some cases, significant performance degradation can occur when
using these types vs. not, in particular when specifying ``cx_Oracle.CLOB``.

On the SQLAlchemy side, the :meth:`.DialectEvents.do_setinputsizes` event can
be used both for runtime visibility (e.g. logging) of the setinputsizes step as
well as to fully control how ``setinputsizes()`` is used on a per-statement
basis.

.. versionadded:: 1.2.9 Added :meth:`.DialectEvents.setinputsizes`


Example 1 - logging all setinputsizes calls
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following example illustrates how to log the intermediary values from a
SQLAlchemy perspective before they are converted to the raw ``setinputsizes()``
parameter dictionary.  The keys of the dictionary are :class:`.BindParameter`
objects which have a ``.key`` and a ``.type`` attribute::

 #rom sqlalchemy import create_engine, event

 #ngine = create_engine("oracle+cx_oracle://scott:tiger@host/xe")

 #event.listens_for(engine, "do_setinputsizes")
 #ef _log_setinputsizes(inputsizes, cursor, statement, parameters, context):
 #or bindparam, dbapitype in inputsizes.items():
 #og.info(
 #Bound parameter name: %s  SQLAlchemy type: %r  "
 #DBAPI object: %s",
 #indparam.key, bindparam.type, dbapitype)

Example 2 - remove all bindings to CLOB
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``CLOB`` datatype in cx_Oracle incurs a significant performance overhead,
however is set by default for the ``Text`` type within the SQLAlchemy 1.2
series.   This setting can be modified as follows::

 #rom sqlalchemy import create_engine, event
 #rom cx_Oracle import CLOB

 #ngine = create_engine("oracle+cx_oracle://scott:tiger@host/xe")

 #event.listens_for(engine, "do_setinputsizes")
 #ef _remove_clob(inputsizes, cursor, statement, parameters, context):
 #or bindparam, dbapitype in list(inputsizes.items()):
 #f dbapitype is CLOB:
 #el inputsizes[bindparam]

.. _cx_oracle_returning:

RETURNING Support
-----------------

The cx_Oracle dialect implements RETURNING using OUT parameters.
The dialect supports RETURNING fully, however cx_Oracle 6 is recommended
for complete support.

.. _cx_oracle_lob:

LOB Objects
-----------

cx_oracle returns oracle LOBs using the cx_oracle.LOB object.  SQLAlchemy
converts these to strings so that the interface of the Binary type is
consistent with that of other backends, which takes place within a cx_Oracle
outputtypehandler.

cx_Oracle prior to version 6 would require that LOB objects be read before
a new batch of rows would be read, as determined by the ``cursor.arraysize``.
As of the 6 series, this limitation has been lifted.  Nevertheless, because
SQLAlchemy pre-reads these LOBs up front, this issue is avoided in any case.

To disable the auto "read()" feature of the dialect, the flag
``auto_convert_lobs=False`` may be passed to :func:`_sa.create_engine`.  Under
the cx_Oracle 5 series, having this flag turned off means there is the chance
of reading from a stale LOB object if not read as it is fetched.   With
cx_Oracle 6, this issue is resolved.

.. versionchanged:: 1.2  the LOB handling system has been greatly simplified
 #nternally to make use of outputtypehandlers, and no longer makes use
 #f alternate "buffered" result set objects.

Two Phase Transactions Not Supported
-------------------------------------

Two phase transactions are **not supported** under cx_Oracle due to poor
driver support.   As of cx_Oracle 6.0b1, the interface for
two phase transactions has been changed to be more of a direct pass-through
to the underlying OCI layer with less automation.  The additional logic
to support this system is not implemented in SQLAlchemy.

.. _cx_oracle_numeric:

Precision Numerics
------------------

SQLAlchemy's numeric types can handle receiving and returning values as Python
``Decimal`` objects or float objects.  When a :class:`.Numeric` object, or a
subclass such as :class:`.Float`, :class:`_oracle.DOUBLE_PRECISION` etc. is in
use, the :paramref:`.Numeric.asdecimal` flag determines if values should be
coerced to ``Decimal`` upon return, or returned as float objects.   To make
matters more complicated under Oracle, Oracle's ``NUMBER`` type can also
represent integer values if the "scale" is zero, so the Oracle-specific
:class:`_oracle.NUMBER` type takes this into account as well.

The cx_Oracle dialect makes extensive use of connection- and cursor-level
"outputtypehandler" callables in order to coerce numeric values as requested.
These callables are specific to the specific flavor of :class:`.Numeric` in
use, as well as if no SQLAlchemy typing objects are present.   There are
observed scenarios where Oracle may sends incomplete or ambiguous information
about the numeric types being returned, such as a query where the numeric types
are buried under multiple levels of subquery.  The type handlers do their best
to make the right decision in all cases, deferring to the underlying cx_Oracle
DBAPI for all those cases where the driver can make the best decision.

When no typing objects are present, as when executing plain SQL strings, a
default "outputtypehandler" is present which will generally return numeric
values which specify precision and scale as Python ``Decimal`` objects.  To
disable this coercion to decimal for performance reasons, pass the flag
``coerce_to_decimal=False`` to :func:`_sa.create_engine`::

 #ngine = create_engine("oracle+cx_oracle://dsn", coerce_to_decimal=False)

The ``coerce_to_decimal`` flag only impacts the results of plain string
SQL statements that are not otherwise associated with a :class:`.Numeric`
SQLAlchemy type (or a subclass of such).

.. versionchanged:: 1.2  The numeric handling system for cx_Oracle has been
 #eworked to take advantage of newer cx_Oracle features as well
 #s better integration of outputtypehandlers.

"""  # noqa

from __future__ import absolute_import

import decimal
import random
import re

from . import base as oracle
from .base import OracleCompiler
from .base import OracleDialect
from .base import OracleExecutionContext
from ... import exc
from ... import processors
from ... import types as sqltypes
from ... import util
from ...engine import cursor as _cursor
from ...util import compat


class _OracleInteger(sqltypes.Integer):
 #ef get_dbapi_type(self, dbapi):
        # see https://github.com/oracle/python-cx_Oracle/issues/
        # 208#issuecomment-409715955
 #eturn int

 #ef _cx_oracle_var(self, dialect, cursor):
 #x_Oracle = dialect.dbapi
 #eturn cursor.var(
 #x_Oracle.STRING, 255, arraysize=cursor.arraysize, outconverter=int
 #

 #ef _cx_oracle_outputtypehandler(self, dialect):
 #ef handler(cursor, name, default_type, size, precision, scale):
 #eturn self._cx_oracle_var(dialect, cursor)

 #eturn handler


class _OracleNumeric(sqltypes.Numeric):
 #s_number = False

 #ef bind_processor(self, dialect):
 #f self.scale == 0:
 #eturn None
 #lif self.asdecimal:
 #rocessor = processors.to_decimal_processor_factory(
 #ecimal.Decimal, self._effective_decimal_return_scale
 #

 #ef process(value):
 #f isinstance(value, (int, float)):
 #eturn processor(value)
 #lif value is not None and value.is_infinite():
 #eturn float(value)
 #lse:
 #eturn value

 #eturn process
 #lse:
 #eturn processors.to_float

 #ef result_processor(self, dialect, coltype):
 #eturn None

 #ef _cx_oracle_outputtypehandler(self, dialect):
 #x_Oracle = dialect.dbapi

 #s_cx_oracle_6 = dialect._is_cx_oracle_6

 #ef handler(cursor, name, default_type, size, precision, scale):
 #utconverter = None

 #f precision:
 #f self.asdecimal:
 #f default_type == cx_Oracle.NATIVE_FLOAT:
                        # receiving float and doing Decimal after the fact
                        # allows for float("inf") to be handled
 #ype_ = default_type
 #utconverter = decimal.Decimal
 #lif is_cx_oracle_6:
 #ype_ = decimal.Decimal
 #lse:
 #ype_ = cx_Oracle.STRING
 #utconverter = dialect._to_decimal
 #lse:
 #f self.is_number and scale == 0:
                        # integer. cx_Oracle is observed to handle the widest
                        # variety of ints when no directives are passed,
                        # from 5.2 to 7.0.  See [ticket:4457]
 #eturn None
 #lse:
 #ype_ = cx_Oracle.NATIVE_FLOAT

 #lse:
 #f self.asdecimal:
 #f default_type == cx_Oracle.NATIVE_FLOAT:
 #ype_ = default_type
 #utconverter = decimal.Decimal
 #lif is_cx_oracle_6:
 #ype_ = decimal.Decimal
 #lse:
 #ype_ = cx_Oracle.STRING
 #utconverter = dialect._to_decimal
 #lse:
 #f self.is_number and scale == 0:
                        # integer. cx_Oracle is observed to handle the widest
                        # variety of ints when no directives are passed,
                        # from 5.2 to 7.0.  See [ticket:4457]
 #eturn None
 #lse:
 #ype_ = cx_Oracle.NATIVE_FLOAT

 #eturn cursor.var(
 #ype_,
 #55,
 #rraysize=cursor.arraysize,
 #utconverter=outconverter,
 #

 #eturn handler


class _OracleBinaryFloat(_OracleNumeric):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.NATIVE_FLOAT


class _OracleBINARY_FLOAT(_OracleBinaryFloat, oracle.BINARY_FLOAT):
 #ass


class _OracleBINARY_DOUBLE(_OracleBinaryFloat, oracle.BINARY_DOUBLE):
 #ass


class _OracleNUMBER(_OracleNumeric):
 #s_number = True


class _OracleDate(sqltypes.Date):
 #ef bind_processor(self, dialect):
 #eturn None

 #ef result_processor(self, dialect, coltype):
 #ef process(value):
 #f value is not None:
 #eturn value.date()
 #lse:
 #eturn value

 #eturn process


# TODO: the names used across CHAR / VARCHAR / NCHAR / NVARCHAR
# here are inconsistent and not very good
class _OracleChar(sqltypes.CHAR):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.FIXED_CHAR


class _OracleNChar(sqltypes.NCHAR):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.FIXED_NCHAR


class _OracleUnicodeStringNCHAR(oracle.NVARCHAR2):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.NCHAR


class _OracleUnicodeStringCHAR(sqltypes.Unicode):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.LONG_STRING


class _OracleUnicodeTextNCLOB(oracle.NCLOB):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.NCLOB


class _OracleUnicodeTextCLOB(sqltypes.UnicodeText):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.CLOB


class _OracleText(sqltypes.Text):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.CLOB


class _OracleLong(oracle.LONG):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.LONG_STRING


class _OracleString(sqltypes.String):
 #ass


class _OracleEnum(sqltypes.Enum):
 #ef bind_processor(self, dialect):
 #num_proc = sqltypes.Enum.bind_processor(self, dialect)

 #ef process(value):
 #aw_str = enum_proc(value)
 #eturn raw_str

 #eturn process


class _OracleBinary(sqltypes.LargeBinary):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.BLOB

 #ef bind_processor(self, dialect):
 #eturn None

 #ef result_processor(self, dialect, coltype):
 #f not dialect.auto_convert_lobs:
 #eturn None
 #lse:
 #eturn super(_OracleBinary, self).result_processor(
 #ialect, coltype
 #


class _OracleInterval(oracle.INTERVAL):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.INTERVAL


class _OracleRaw(oracle.RAW):
 #ass


class _OracleRowid(oracle.ROWID):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.ROWID


class OracleCompiler_cx_oracle(OracleCompiler):
 #oracle_cx_sql_compiler = True

 #ef bindparam_string(self, name, **kw):
 #uote = getattr(name, "quote", None)
 #f (
 #uote is True
 #r quote is not False
 #nd self.preparer._bindparam_requires_quotes(name)
 #nd not kw.get("post_compile", False)
 #:
            # interesting to note about expanding parameters - since the
            # new parameters take the form <paramname>_<int>, at least if
            # they are originally formed from reserved words, they no longer
            # need quoting :).    names that include illegal characters
            # won't work however.
 #uoted_name = '"%s"' % name
 #w["escaped_from"] = name
 #ame = quoted_name

 #eturn OracleCompiler.bindparam_string(self, name, **kw)


class OracleExecutionContext_cx_oracle(OracleExecutionContext):
 #ut_parameters = None

 #ef _generate_out_parameter_vars(self):
        # check for has_out_parameters or RETURNING, create cx_Oracle.var
        # objects if so
 #f self.compiled.returning or self.compiled.has_out_parameters:
 #uoted_bind_names = self.compiled.escaped_bind_names
 #or bindparam in self.compiled.binds.values():
 #f bindparam.isoutparam:
 #ame = self.compiled.bind_names[bindparam]
 #ype_impl = bindparam.type.dialect_impl(self.dialect)

 #f hasattr(type_impl, "_cx_oracle_var"):
 #elf.out_parameters[name] = type_impl._cx_oracle_var(
 #elf.dialect, self.cursor
 #
 #lse:
 #btype = type_impl.get_dbapi_type(self.dialect.dbapi)

 #x_Oracle = self.dialect.dbapi

 #f dbtype is None:
 #aise exc.InvalidRequestError(
 #Cannot create out parameter for "
 #parameter "
 #%r - its type %r is not supported by"
 # cx_oracle" % (bindparam.key, bindparam.type)
 #

 #f compat.py2k and dbtype in (
 #x_Oracle.CLOB,
 #x_Oracle.NCLOB,
 #:
 #utconverter = (
 #rocessors.to_unicode_processor_factory(
 #elf.dialect.encoding,
 #rrors=self.dialect.encoding_errors,
 #
 #
 #elf.out_parameters[name] = self.cursor.var(
 #btype,
 #utconverter=lambda value: outconverter(
 #alue.read()
 #,
 #

 #lif dbtype in (
 #x_Oracle.BLOB,
 #x_Oracle.CLOB,
 #x_Oracle.NCLOB,
 #:
 #elf.out_parameters[name] = self.cursor.var(
 #btype, outconverter=lambda value: value.read()
 #
 #lif compat.py2k and isinstance(
 #ype_impl, sqltypes.Unicode
 #:
 #utconverter = (
 #rocessors.to_unicode_processor_factory(
 #elf.dialect.encoding,
 #rrors=self.dialect.encoding_errors,
 #
 #
 #elf.out_parameters[name] = self.cursor.var(
 #btype, outconverter=outconverter
 #
 #lse:
 #elf.out_parameters[name] = self.cursor.var(dbtype)
 #elf.parameters[0][
 #uoted_bind_names.get(name, name)
 # = self.out_parameters[name]

 #ef _generate_cursor_outputtype_handler(self):
 #utput_handlers = {}

 #or (keyname, name, objects, type_) in self.compiled._result_columns:
 #andler = type_._cached_custom_processor(
 #elf.dialect,
 #cx_oracle_outputtypehandler",
 #elf._get_cx_oracle_type_handler,
 #

 #f handler:
 #enormalized_name = self.dialect.denormalize_name(keyname)
 #utput_handlers[denormalized_name] = handler

 #f output_handlers:
 #efault_handler = self._dbapi_connection.outputtypehandler

 #ef output_type_handler(
 #ursor, name, default_type, size, precision, scale
 #:
 #f name in output_handlers:
 #eturn output_handlers[name](
 #ursor, name, default_type, size, precision, scale
 #
 #lse:
 #eturn default_handler(
 #ursor, name, default_type, size, precision, scale
 #

 #elf.cursor.outputtypehandler = output_type_handler

 #ef _get_cx_oracle_type_handler(self, impl):
 #f hasattr(impl, "_cx_oracle_outputtypehandler"):
 #eturn impl._cx_oracle_outputtypehandler(self.dialect)
 #lse:
 #eturn None

 #ef pre_exec(self):
 #f not getattr(self.compiled, "_oracle_cx_sql_compiler", False):
 #eturn

 #elf.out_parameters = {}

 #elf._generate_out_parameter_vars()

 #elf._generate_cursor_outputtype_handler()

 #elf.include_set_input_sizes = self.dialect._include_setinputsizes

 #ef post_exec(self):
 #f self.compiled and self.out_parameters and self.compiled.returning:
            # create a fake cursor result from the out parameters. unlike
            # get_out_parameter_values(), the result-row handlers here will be
            # applied at the Result level
 #eturning_params = [
 #elf.dialect._returningval(self.out_parameters["ret_%d" % i])
 #or i in range(len(self.out_parameters))
 #

 #etch_strategy = _cursor.FullyBufferedCursorFetchStrategy(
 #elf.cursor,
 #
 #getattr(col, "name", col._anon_name_label), None)
 #or col in self.compiled.returning
 #,
 #nitial_buffer=[tuple(returning_params)],
 #

 #elf.cursor_fetch_strategy = fetch_strategy

 #ef create_cursor(self):
 # = self._dbapi_connection.cursor()
 #f self.dialect.arraysize:
 #.arraysize = self.dialect.arraysize

 #eturn c

 #ef get_out_parameter_values(self, out_param_names):
        # this method should not be called when the compiler has
        # RETURNING as we've turned the has_out_parameters flag set to
        # False.
 #ssert not self.compiled.returning

 #eturn [
 #elf.dialect._paramval(self.out_parameters[name])
 #or name in out_param_names
 #


class OracleDialect_cx_oracle(OracleDialect):
 #upports_statement_cache = True
 #xecution_ctx_cls = OracleExecutionContext_cx_oracle
 #tatement_compiler = OracleCompiler_cx_oracle

 #upports_sane_rowcount = True
 #upports_sane_multi_rowcount = True

 #upports_unicode_statements = True
 #upports_unicode_binds = True

 #se_setinputsizes = True

 #river = "cx_oracle"

 #olspecs = {
 #qltypes.Numeric: _OracleNumeric,
 #qltypes.Float: _OracleNumeric,
 #racle.BINARY_FLOAT: _OracleBINARY_FLOAT,
 #racle.BINARY_DOUBLE: _OracleBINARY_DOUBLE,
 #qltypes.Integer: _OracleInteger,
 #racle.NUMBER: _OracleNUMBER,
 #qltypes.Date: _OracleDate,
 #qltypes.LargeBinary: _OracleBinary,
 #qltypes.Boolean: oracle._OracleBoolean,
 #qltypes.Interval: _OracleInterval,
 #racle.INTERVAL: _OracleInterval,
 #qltypes.Text: _OracleText,
 #qltypes.String: _OracleString,
 #qltypes.UnicodeText: _OracleUnicodeTextCLOB,
 #qltypes.CHAR: _OracleChar,
 #qltypes.NCHAR: _OracleNChar,
 #qltypes.Enum: _OracleEnum,
 #racle.LONG: _OracleLong,
 #racle.RAW: _OracleRaw,
 #qltypes.Unicode: _OracleUnicodeStringCHAR,
 #qltypes.NVARCHAR: _OracleUnicodeStringNCHAR,
 #racle.NCLOB: _OracleUnicodeTextNCLOB,
 #racle.ROWID: _OracleRowid,
 #

 #xecute_sequence_format = list

 #cx_oracle_threaded = None

 #util.deprecated_params(
 #hreaded=(
 #1.3",
 #The 'threaded' parameter to the cx_oracle dialect "
 #is deprecated as a dialect-level argument, and will be removed "
 #in a future release.  As of version 1.3, it defaults to False "
 #rather than True.  The 'threaded' option can be passed to "
 #cx_Oracle directly in the URL query string passed to "
 #:func:`_sa.create_engine`.",
 #
 #
 #ef __init__(
 #elf,
 #uto_convert_lobs=True,
 #oerce_to_unicode=True,
 #oerce_to_decimal=True,
 #rraysize=50,
 #ncoding_errors=None,
 #hreaded=None,
 #*kwargs
 #:

 #racleDialect.__init__(self, **kwargs)
 #elf.arraysize = arraysize
 #elf.encoding_errors = encoding_errors
 #f threaded is not None:
 #elf._cx_oracle_threaded = threaded
 #elf.auto_convert_lobs = auto_convert_lobs
 #elf.coerce_to_unicode = coerce_to_unicode
 #elf.coerce_to_decimal = coerce_to_decimal
 #f self._use_nchar_for_unicode:
 #elf.colspecs = self.colspecs.copy()
 #elf.colspecs[sqltypes.Unicode] = _OracleUnicodeStringNCHAR
 #elf.colspecs[sqltypes.UnicodeText] = _OracleUnicodeTextNCLOB

 #x_Oracle = self.dbapi

 #f cx_Oracle is None:
 #elf._include_setinputsizes = {}
 #elf.cx_oracle_ver = (0, 0, 0)
 #lse:
 #elf.cx_oracle_ver = self._parse_cx_oracle_ver(cx_Oracle.version)
 #f self.cx_oracle_ver < (5, 2) and self.cx_oracle_ver > (0, 0, 0):
 #aise exc.InvalidRequestError(
 #cx_Oracle version 5.2 and above are supported"
 #

 #elf._include_setinputsizes = {
 #x_Oracle.DATETIME,
 #x_Oracle.NCLOB,
 #x_Oracle.CLOB,
 #x_Oracle.LOB,
 #x_Oracle.NCHAR,
 #x_Oracle.FIXED_NCHAR,
 #x_Oracle.BLOB,
 #x_Oracle.FIXED_CHAR,
 #x_Oracle.TIMESTAMP,
 #OracleInteger,
 #OracleBINARY_FLOAT,
 #OracleBINARY_DOUBLE,
 #

 #elf._paramval = lambda value: value.getvalue()

            # https://github.com/oracle/python-cx_Oracle/issues/176#issuecomment-386821291
            # https://github.com/oracle/python-cx_Oracle/issues/224
 #elf._values_are_lists = self.cx_oracle_ver >= (6, 3)
 #f self._values_are_lists:
 #x_Oracle.__future__.dml_ret_array_val = True

 #ef _returningval(value):
 #ry:
 #eturn value.values[0][0]
 #xcept IndexError:
 #eturn None

 #elf._returningval = _returningval
 #lse:
 #elf._returningval = self._paramval

 #elf._is_cx_oracle_6 = self.cx_oracle_ver >= (6,)

 #property
 #ef _cursor_var_unicode_kwargs(self):
 #f self.encoding_errors:
 #f self.cx_oracle_ver >= (6, 4):
 #eturn {"encodingErrors": self.encoding_errors}
 #lse:
 #til.warn(
 #cx_oracle version %r does not support encodingErrors"
 # (self.cx_oracle_ver,)
 #

 #eturn {}

 #ef _parse_cx_oracle_ver(self, version):
 # = re.match(r"(\d+)\.(\d+)(?:\.(\d+))?", version)
 #f m:
 #eturn tuple(int(x) for x in m.group(1, 2, 3) if x is not None)
 #lse:
 #eturn (0, 0, 0)

 #classmethod
 #ef dbapi(cls):
 #mport cx_Oracle

 #eturn cx_Oracle

 #ef initialize(self, connection):
 #uper(OracleDialect_cx_oracle, self).initialize(connection)
 #f self._is_oracle_8:
 #elf.supports_unicode_binds = False

 #elf._detect_decimal_char(connection)

 #ef get_isolation_level(self, connection):
        # sources:

        # general idea of transaction id, have to start one, etc.
        # https://stackoverflow.com/questions/10711204/how-to-check-isoloation-level

        # how to decode xid cols from v$transaction to match
        # https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:9532779900346079444

        # Oracle tuple comparison without using IN:
        # https://www.sql-workbench.eu/comparison/tuple_comparison.html

 #ith connection.cursor() as cursor:
            # this is the only way to ensure a transaction is started without
            # actually running DML.   There's no way to see the configured
            # isolation level without getting it from v$transaction which
            # means transaction has to be started.
 #utval = cursor.var(str)
 #ursor.execute(
 #""
 #egin
 #trans_id := dbms_transaction.local_transaction_id( TRUE );
 #nd;
 #"",
 #"trans_id": outval},
 #
 #rans_id = outval.getvalue()
 #idusn, xidslot, xidsqn = trans_id.split(".", 2)

 #ursor.execute(
 #SELECT CASE BITAND(t.flag, POWER(2, 28)) "
 #WHEN 0 THEN 'READ COMMITTED' "
 #ELSE 'SERIALIZABLE' END AS isolation_level "
 #FROM v$transaction t WHERE "
 #(t.xidusn, t.xidslot, t.xidsqn) = "
 #((:xidusn, :xidslot, :xidsqn))",
 #"xidusn": xidusn, "xidslot": xidslot, "xidsqn": xidsqn},
 #
 #ow = cursor.fetchone()
 #f row is None:
 #aise exc.InvalidRequestError(
 #could not retrieve isolation level"
 #
 #esult = row[0]

 #eturn result

 #ef set_isolation_level(self, connection, level):
 #f hasattr(connection, "connection"):
 #bapi_connection = connection.connection
 #lse:
 #bapi_connection = connection
 #f level == "AUTOCOMMIT":
 #bapi_connection.autocommit = True
 #lse:
 #bapi_connection.autocommit = False
 #onnection.rollback()
 #ith connection.cursor() as cursor:
 #ursor.execute("ALTER SESSION SET ISOLATION_LEVEL=%s" % level)

 #ef _detect_decimal_char(self, connection):
        # we have the option to change this setting upon connect,
        # or just look at what it is upon connect and convert.
        # to minimize the chance of interference with changes to
        # NLS_TERRITORY or formatting behavior of the DB, we opt
        # to just look at it

 #elf._decimal_char = connection.exec_driver_sql(
 #select value from nls_session_parameters "
 #where parameter = 'NLS_NUMERIC_CHARACTERS'"
 #.scalar()[0]
 #f self._decimal_char != ".":
 #detect_decimal = self._detect_decimal
 #to_decimal = self._to_decimal

 #elf._detect_decimal = lambda value: _detect_decimal(
 #alue.replace(self._decimal_char, ".")
 #
 #elf._to_decimal = lambda value: _to_decimal(
 #alue.replace(self._decimal_char, ".")
 #

 #ef _detect_decimal(self, value):
 #f "." in value:
 #eturn self._to_decimal(value)
 #lse:
 #eturn int(value)

 #to_decimal = decimal.Decimal

 #ef _generate_connection_outputtype_handler(self):
 #""establish the default outputtypehandler established at the
 #onnection level.

 #""

 #ialect = self
 #x_Oracle = dialect.dbapi

 #umber_handler = _OracleNUMBER(
 #sdecimal=True
 #._cx_oracle_outputtypehandler(dialect)
 #loat_handler = _OracleNUMBER(
 #sdecimal=False
 #._cx_oracle_outputtypehandler(dialect)

 #ef output_type_handler(
 #ursor, name, default_type, size, precision, scale
 #:

 #f (
 #efault_type == cx_Oracle.NUMBER
 #nd default_type is not cx_Oracle.NATIVE_FLOAT
 #:
 #f not dialect.coerce_to_decimal:
 #eturn None
 #lif precision == 0 and scale in (0, -127):
                    # ambiguous type, this occurs when selecting
                    # numbers from deep subqueries
 #eturn cursor.var(
 #x_Oracle.STRING,
 #55,
 #utconverter=dialect._detect_decimal,
 #rraysize=cursor.arraysize,
 #
 #lif precision and scale > 0:
 #eturn number_handler(
 #ursor, name, default_type, size, precision, scale
 #
 #lse:
 #eturn float_handler(
 #ursor, name, default_type, size, precision, scale
 #

            # allow all strings to come back natively as Unicode
 #lif (
 #ialect.coerce_to_unicode
 #nd default_type
 #n (
 #x_Oracle.STRING,
 #x_Oracle.FIXED_CHAR,
 #
 #nd default_type is not cx_Oracle.CLOB
 #nd default_type is not cx_Oracle.NCLOB
 #:
 #f compat.py2k:
 #utconverter = processors.to_unicode_processor_factory(
 #ialect.encoding, errors=dialect.encoding_errors
 #
 #eturn cursor.var(
 #x_Oracle.STRING,
 #ize,
 #ursor.arraysize,
 #utconverter=outconverter,
 #
 #lse:
 #eturn cursor.var(
 #til.text_type,
 #ize,
 #ursor.arraysize,
 #*dialect._cursor_var_unicode_kwargs
 #

 #lif dialect.auto_convert_lobs and default_type in (
 #x_Oracle.CLOB,
 #x_Oracle.NCLOB,
 #:
 #f compat.py2k:
 #utconverter = processors.to_unicode_processor_factory(
 #ialect.encoding, errors=dialect.encoding_errors
 #
 #eturn cursor.var(
 #x_Oracle.LONG_STRING,
 #ize,
 #ursor.arraysize,
 #utconverter=outconverter,
 #
 #lse:
 #eturn cursor.var(
 #x_Oracle.LONG_STRING,
 #ize,
 #ursor.arraysize,
 #*dialect._cursor_var_unicode_kwargs
 #

 #lif dialect.auto_convert_lobs and default_type in (
 #x_Oracle.BLOB,
 #:
 #eturn cursor.var(
 #x_Oracle.LONG_BINARY,
 #ize,
 #ursor.arraysize,
 #

 #eturn output_type_handler

 #ef on_connect(self):

 #utput_type_handler = self._generate_connection_outputtype_handler()

 #ef on_connect(conn):
 #onn.outputtypehandler = output_type_handler

 #eturn on_connect

 #ef create_connect_args(self, url):
 #pts = dict(url.query)

 #or opt in ("use_ansi", "auto_convert_lobs"):
 #f opt in opts:
 #til.warn_deprecated(
 #cx_oracle dialect option %r should only be passed to "
 #create_engine directly, not within the URL string" % opt,
 #ersion="1.3",
 #
 #til.coerce_kw_type(opts, opt, bool)
 #etattr(self, opt, opts.pop(opt))

 #atabase = url.database
 #ervice_name = opts.pop("service_name", None)
 #f database or service_name:
            # if we have a database, then we have a remote host
 #ort = url.port
 #f port:
 #ort = int(port)
 #lse:
 #ort = 1521

 #f database and service_name:
 #aise exc.InvalidRequestError(
 #"service_name" option shouldn\'t '
 #be used with a "database" part of the url'
 #
 #f database:
 #akedsn_kwargs = {"sid": database}
 #f service_name:
 #akedsn_kwargs = {"service_name": service_name}

 #sn = self.dbapi.makedsn(url.host, port, **makedsn_kwargs)
 #lse:
            # we have a local tnsname
 #sn = url.host

 #f dsn is not None:
 #pts["dsn"] = dsn
 #f url.password is not None:
 #pts["password"] = url.password
 #f url.username is not None:
 #pts["user"] = url.username

 #f self._cx_oracle_threaded is not None:
 #pts.setdefault("threaded", self._cx_oracle_threaded)

 #ef convert_cx_oracle_constant(value):
 #f isinstance(value, util.string_types):
 #ry:
 #nt_val = int(value)
 #xcept ValueError:
 #alue = value.upper()
 #eturn getattr(self.dbapi, value)
 #lse:
 #eturn int_val
 #lse:
 #eturn value

 #til.coerce_kw_type(opts, "mode", convert_cx_oracle_constant)
 #til.coerce_kw_type(opts, "threaded", bool)
 #til.coerce_kw_type(opts, "events", bool)
 #til.coerce_kw_type(opts, "purity", convert_cx_oracle_constant)
 #eturn ([], opts)

 #ef _get_server_version_info(self, connection):
 #eturn tuple(int(x) for x in connection.connection.version.split("."))

 #ef is_disconnect(self, e, connection, cursor):
 #error,) = e.args
 #f isinstance(
 #, (self.dbapi.InterfaceError, self.dbapi.DatabaseError)
 # and "not connected" in str(e):
 #eturn True

 #f hasattr(error, "code"):
            # ORA-00028: your session has been killed
            # ORA-03114: not connected to ORACLE
            # ORA-03113: end-of-file on communication channel
            # ORA-03135: connection lost contact
            # ORA-01033: ORACLE initialization or shutdown in progress
            # ORA-02396: exceeded maximum idle time, please connect again
            # TODO: Others ?
 #eturn error.code in (28, 3114, 3113, 3135, 1033, 2396)
 #lse:
 #eturn False

 #ef create_xid(self):
 #""create a two-phase transaction ID.

 #his id will be passed to do_begin_twophase(), do_rollback_twophase(),
 #o_commit_twophase().  its format is unspecified.

 #""

 #d_ = random.randint(0, 2 ** 128)
 #eturn (0x1234, "%032x" % id_, "%032x" % 9)

 #ef do_executemany(self, cursor, statement, parameters, context=None):
 #f isinstance(parameters, tuple):
 #arameters = list(parameters)
 #ursor.executemany(statement, parameters)

 #ef do_begin_twophase(self, connection, xid):
 #onnection.connection.begin(*xid)
 #onnection.connection.info["cx_oracle_xid"] = xid

 #ef do_prepare_twophase(self, connection, xid):
 #esult = connection.connection.prepare()
 #onnection.info["cx_oracle_prepared"] = result

 #ef do_rollback_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:
 #elf.do_rollback(connection.connection)
        # TODO: need to end XA state here

 #ef do_commit_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:

 #f not is_prepared:
 #elf.do_commit(connection.connection)
 #lse:
 #f recover:
 #aise NotImplementedError(
 #2pc recovery not implemented for cx_Oracle"
 #
 #ci_prepared = connection.info["cx_oracle_prepared"]
 #f oci_prepared:
 #elf.do_commit(connection.connection)
        # TODO: need to end XA state here

 #ef do_set_input_sizes(self, cursor, list_of_tuples, context):
 #f self.positional:
            # not usually used, here to support if someone is modifying
            # the dialect to use positional style
 #ursor.setinputsizes(
 #[dbtype for key, dbtype, sqltype in list_of_tuples]
 #
 #lse:
 #ollection = (
 #key, dbtype)
 #or key, dbtype, sqltype in list_of_tuples
 #f dbtype
 #

 #f not self.supports_unicode_binds:
                # oracle 8 only
 #ollection = (
 #self.dialect._encoder(key)[0], dbtype)
 #or key, dbtype in collection
 #

 #ursor.setinputsizes(**{key: dbtype for key, dbtype in collection})

 #ef do_recover_twophase(self, connection):
 #aise NotImplementedError(
 #recover two phase query for cx_Oracle not implemented"
 #


dialect = OracleDialect_cx_oracle
