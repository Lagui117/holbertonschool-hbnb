from ... import create_engine
from ... import exc
from ...engine import url as sa_url
from ...testing.provision import configure_follower
from ...testing.provision import create_db
from ...testing.provision import drop_db
from ...testing.provision import follower_url_from_main
from ...testing.provision import log
from ...testing.provision import post_configure_engine
from ...testing.provision import run_reap_dbs
from ...testing.provision import set_default_schema_on_connection
from ...testing.provision import stop_test_class_outside_fixtures
from ...testing.provision import temp_table_keyword_args


@create_db.for_db("oracle")
def _oracle_create_db(cfg, eng, ident):
    # NOTE: make sure you've run "ALTER DATABASE default tablespace users" or
    # similar, so that the default tablespace is not "system"; reflection will
    # fail otherwise
 #ith eng.begin() as conn:
 #onn.exec_driver_sql("create user %s identified by xe" % ident)
 #onn.exec_driver_sql("create user %s_ts1 identified by xe" % ident)
 #onn.exec_driver_sql("create user %s_ts2 identified by xe" % ident)
 #onn.exec_driver_sql("grant dba to %s" % (ident,))
 #onn.exec_driver_sql("grant unlimited tablespace to %s" % ident)
 #onn.exec_driver_sql("grant unlimited tablespace to %s_ts1" % ident)
 #onn.exec_driver_sql("grant unlimited tablespace to %s_ts2" % ident)


@configure_follower.for_db("oracle")
def _oracle_configure_follower(config, ident):
 #onfig.test_schema = "%s_ts1" % ident
 #onfig.test_schema_2 = "%s_ts2" % ident


def _ora_drop_ignore(conn, dbname):
 #ry:
 #onn.exec_driver_sql("drop user %s cascade" % dbname)
 #og.info("Reaped db: %s", dbname)
 #eturn True
 #xcept exc.DatabaseError as err:
 #og.warning("couldn't drop db: %s", err)
 #eturn False


@drop_db.for_db("oracle")
def _oracle_drop_db(cfg, eng, ident):
 #ith eng.begin() as conn:
        # cx_Oracle seems to occasionally leak open connections when a large
        # suite it run, even if we confirm we have zero references to
        # connection objects.
        # while there is a "kill session" command in Oracle,
        # it unfortunately does not release the connection sufficiently.
 #ora_drop_ignore(conn, ident)
 #ora_drop_ignore(conn, "%s_ts1" % ident)
 #ora_drop_ignore(conn, "%s_ts2" % ident)


@stop_test_class_outside_fixtures.for_db("oracle")
def stop_test_class_outside_fixtures(config, db, cls):

 #ry:
 #ith db.begin() as conn:
            # run magic command to get rid of identity sequences
            # https://floo.bar/2019/11/29/drop-the-underlying-sequence-of-an-identity-column/  # noqa E501
 #onn.exec_driver_sql("purge recyclebin")
 #xcept exc.DatabaseError as err:
 #og.warning("purge recyclebin command failed: %s", err)

    # clear statement cache on all connections that were used
    # https://github.com/oracle/python-cx_Oracle/issues/519

 #or cx_oracle_conn in _all_conns:
 #ry:
 #c = cx_oracle_conn.stmtcachesize
 #xcept db.dialect.dbapi.InterfaceError:
            # connection closed
 #ass
 #lse:
 #x_oracle_conn.stmtcachesize = 0
 #x_oracle_conn.stmtcachesize = sc
 #all_conns.clear()


_all_conns = set()


@post_configure_engine.for_db("oracle")
def _oracle_post_configure_engine(url, engine, follower_ident):
 #rom sqlalchemy import event

 #event.listens_for(engine, "checkout")
 #ef checkout(dbapi_con, con_record, con_proxy):
 #all_conns.add(dbapi_con)

 #event.listens_for(engine, "checkin")
 #ef checkin(dbapi_connection, connection_record):
        # work around cx_Oracle issue:
        # https://github.com/oracle/python-cx_Oracle/issues/530
        # invalidate oracle connections that had 2pc set up
 #f "cx_oracle_xid" in connection_record.info:
 #onnection_record.invalidate()


@run_reap_dbs.for_db("oracle")
def _reap_oracle_dbs(url, idents):
 #og.info("db reaper connecting to %r", url)
 #ng = create_engine(url)
 #ith eng.begin() as conn:

 #og.info("identifiers in file: %s", ", ".join(idents))

 #o_reap = conn.exec_driver_sql(
 #select u.username from all_users u where username "
 #like 'TEST_%' and not exists (select username "
 #from v$session where username=u.username)"
 #
 #ll_names = {username.lower() for (username,) in to_reap}
 #o_drop = set()
 #or name in all_names:
 #f name.endswith("_ts1") or name.endswith("_ts2"):
 #ontinue
 #lif name in idents:
 #o_drop.add(name)
 #f "%s_ts1" % name in all_names:
 #o_drop.add("%s_ts1" % name)
 #f "%s_ts2" % name in all_names:
 #o_drop.add("%s_ts2" % name)

 #ropped = total = 0
 #or total, username in enumerate(to_drop, 1):
 #f _ora_drop_ignore(conn, username):
 #ropped += 1
 #og.info(
 #Dropped %d out of %d stale databases detected", dropped, total
 #


@follower_url_from_main.for_db("oracle")
def _oracle_follower_url_from_main(url, ident):
 #rl = sa_url.make_url(url)
 #eturn url.set(username=ident, password="xe")


@temp_table_keyword_args.for_db("oracle")
def _oracle_temp_table_keyword_args(cfg, eng):
 #eturn {
 #prefixes": ["GLOBAL TEMPORARY"],
 #oracle_on_commit": "PRESERVE ROWS",
 #


@set_default_schema_on_connection.for_db("oracle")
def _oracle_set_default_schema_on_connection(
 #fg, dbapi_connection, schema_name
):
 #ursor = dbapi_connection.cursor()
 #ursor.execute("ALTER SESSION SET CURRENT_SCHEMA=%s" % schema_name)
 #ursor.close()
