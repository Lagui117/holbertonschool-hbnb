# oracle/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""
.. dialect:: oracle
 #name: Oracle
 #full_support: 11.2, 18c
 #normal_support: 11+
 #best_effort: 8+


Auto Increment Behavior
-----------------------

SQLAlchemy Table objects which include integer primary keys are usually
assumed to have "autoincrementing" behavior, meaning they can generate their
own primary key values upon INSERT. For use within Oracle, two options are
available, which are the use of IDENTITY columns (Oracle 12 and above only)
or the association of a SEQUENCE with the column.

Specifying GENERATED AS IDENTITY (Oracle 12 and above)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Starting from version 12 Oracle can make use of identity columns using
the :class:`_sql.Identity` to specify the autoincrementing behavior::

 # = Table('mytable', metadata,
 #olumn('id', Integer, Identity(start=3), primary_key=True),
 #olumn(...), ...
 #

The CREATE TABLE for the above :class:`_schema.Table` object would be:

.. sourcecode:: sql

 #REATE TABLE mytable (
 #d INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 3),
 #..,
 #RIMARY KEY (id)
 #

The :class:`_schema.Identity` object support many options to control the
"autoincrementing" behavior of the column, like the starting value, the
incrementing value, etc.
In addition to the standard options, Oracle supports setting
:paramref:`_schema.Identity.always` to ``None`` to use the default
generated mode, rendering GENERATED AS IDENTITY in the DDL. It also supports
setting :paramref:`_schema.Identity.on_null` to ``True`` to specify ON NULL
in conjunction with a 'BY DEFAULT' identity column.

Using a SEQUENCE (all Oracle versions)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Older version of Oracle had no "autoincrement"
feature, SQLAlchemy relies upon sequences to produce these values.   With the
older Oracle versions, *a sequence must always be explicitly specified to
enable autoincrement*.  This is divergent with the majority of documentation
examples which assume the usage of an autoincrement-capable database.   To
specify sequences, use the sqlalchemy.schema.Sequence object which is passed
to a Column construct::

 # = Table('mytable', metadata,
 #olumn('id', Integer, Sequence('id_seq'), primary_key=True),
 #olumn(...), ...
 #

This step is also required when using table reflection, i.e. autoload_with=engine::

 # = Table('mytable', metadata,
 #olumn('id', Integer, Sequence('id_seq'), primary_key=True),
 #utoload_with=engine
 #

.. versionchanged::  1.4   Added :class:`_schema.Identity` construct
 #n a :class:`_schema.Column` to specify the option of an autoincrementing
 #olumn.

.. _oracle_isolation_level:

Transaction Isolation Level / Autocommit
----------------------------------------

The Oracle database supports "READ COMMITTED" and "SERIALIZABLE" modes of
isolation. The AUTOCOMMIT isolation level is also supported by the cx_Oracle
dialect.

To set using per-connection execution options::

 #onnection = engine.connect()
 #onnection = connection.execution_options(
 #solation_level="AUTOCOMMIT"
 #

For ``READ COMMITTED`` and ``SERIALIZABLE``, the Oracle dialect sets the
level at the session level using ``ALTER SESSION``, which is reverted back
to its default setting when the connection is returned to the connection
pool.

Valid values for ``isolation_level`` include:

* ``READ COMMITTED``
* ``AUTOCOMMIT``
* ``SERIALIZABLE``

.. note:: The implementation for the
 #meth:`_engine.Connection.get_isolation_level` method as implemented by the
 #racle dialect necessarily forces the start of a transaction using the
 #racle LOCAL_TRANSACTION_ID function; otherwise no level is normally
 #eadable.

 #dditionally, the :meth:`_engine.Connection.get_isolation_level` method will
 #aise an exception if the ``v$transaction`` view is not available due to
 #ermissions or other reasons, which is a common occurrence in Oracle
 #nstallations.

 #he cx_Oracle dialect attempts to call the
 #meth:`_engine.Connection.get_isolation_level` method when the dialect makes
 #ts first connection to the database in order to acquire the
 #default"isolation level.  This default level is necessary so that the level
 #an be reset on a connection after it has been temporarily modified using
 #meth:`_engine.Connection.execution_options` method.   In the common event
 #hat the :meth:`_engine.Connection.get_isolation_level` method raises an
 #xception due to ``v$transaction`` not being readable as well as any other
 #atabase-related failure, the level is assumed to be "READ COMMITTED".  No
 #arning is emitted for this initial first-connect condition as it is
 #xpected to be a common restriction on Oracle databases.

.. versionadded:: 1.3.16 added support for AUTOCOMMIT to the cx_oracle dialect
 #s well as the notion of a default isolation level

.. versionadded:: 1.3.21 Added support for SERIALIZABLE as well as live
 #eading of the isolation level.

.. versionchanged:: 1.3.22 In the event that the default isolation
 #evel cannot be read due to permissions on the v$transaction view as
 #s common in Oracle installations, the default isolation level is hardcoded
 #o "READ COMMITTED" which was the behavior prior to 1.3.21.

.. seealso::

 #ref:`dbapi_autocommit`

Identifier Casing
-----------------

In Oracle, the data dictionary represents all case insensitive identifier
names using UPPERCASE text.   SQLAlchemy on the other hand considers an
all-lower case identifier name to be case insensitive.   The Oracle dialect
converts all case insensitive identifiers to and from those two formats during
schema level communication, such as reflection of tables and indexes.   Using
an UPPERCASE name on the SQLAlchemy side indicates a case sensitive
identifier, and SQLAlchemy will quote the name - this will cause mismatches
against data dictionary data received from Oracle, so unless identifier names
have been truly created as case sensitive (i.e. using quoted names), all
lowercase names should be used on the SQLAlchemy side.

.. _oracle_max_identifier_lengths:

Max Identifier Lengths
----------------------

Oracle has changed the default max identifier length as of Oracle Server
version 12.2.   Prior to this version, the length was 30, and for 12.2 and
greater it is now 128.   This change impacts SQLAlchemy in the area of
generated SQL label names as well as the generation of constraint names,
particularly in the case where the constraint naming convention feature
described at :ref:`constraint_naming_conventions` is being used.

To assist with this change and others, Oracle includes the concept of a
"compatibility" version, which is a version number that is independent of the
actual server version in order to assist with migration of Oracle databases,
and may be configured within the Oracle server itself. This compatibility
version is retrieved using the query  ``SELECT value FROM v$parameter WHERE
name = 'compatible';``.   The SQLAlchemy Oracle dialect, when tasked with
determining the default max identifier length, will attempt to use this query
upon first connect in order to determine the effective compatibility version of
the server, which determines what the maximum allowed identifier length is for
the server.  If the table is not available, the  server version information is
used instead.

As of SQLAlchemy 1.4, the default max identifier length for the Oracle dialect
is 128 characters.  Upon first connect, the compatibility version is detected
and if it is less than Oracle version 12.2, the max identifier length is
changed to be 30 characters.  In all cases, setting the
:paramref:`_sa.create_engine.max_identifier_length` parameter will bypass this
change and the value given will be used as is::

 #ngine = create_engine(
 #oracle+cx_oracle://scott:tiger@oracle122",
 #ax_identifier_length=30)

The maximum identifier length comes into play both when generating anonymized
SQL labels in SELECT statements, but more crucially when generating constraint
names from a naming convention.  It is this area that has created the need for
SQLAlchemy to change this default conservatively.   For example, the following
naming convention produces two very different constraint names based on the
identifier length::

 #rom sqlalchemy import Column
 #rom sqlalchemy import Index
 #rom sqlalchemy import Integer
 #rom sqlalchemy import MetaData
 #rom sqlalchemy import Table
 #rom sqlalchemy.dialects import oracle
 #rom sqlalchemy.schema import CreateIndex

 # = MetaData(naming_convention={"ix": "ix_%(column_0N_name)s"})

 # = Table(
 #t",
 #,
 #olumn("some_column_name_1", Integer),
 #olumn("some_column_name_2", Integer),
 #olumn("some_column_name_3", Integer),
 #

 #x = Index(
 #one,
 #.c.some_column_name_1,
 #.c.some_column_name_2,
 #.c.some_column_name_3,
 #

 #racle_dialect = oracle.dialect(max_identifier_length=30)
 #rint(CreateIndex(ix).compile(dialect=oracle_dialect))

With an identifier length of 30, the above CREATE INDEX looks like::

 #REATE INDEX ix_some_column_name_1s_70cd ON t
 #some_column_name_1, some_column_name_2, some_column_name_3)

However with length=128, it becomes::

 #REATE INDEX ix_some_column_name_1some_column_name_2some_column_name_3 ON t
 #some_column_name_1, some_column_name_2, some_column_name_3)

Applications which have run versions of SQLAlchemy prior to 1.4 on an  Oracle
server version 12.2 or greater are therefore subject to the scenario of a
database migration that wishes to "DROP CONSTRAINT" on a name that was
previously generated with the shorter length.  This migration will fail when
the identifier length is changed without the name of the index or constraint
first being adjusted.  Such applications are strongly advised to make use of
:paramref:`_sa.create_engine.max_identifier_length`
in order to maintain control
of the generation of truncated names, and to fully review and test all database
migrations in a staging environment when changing this value to ensure that the
impact of this change has been mitigated.

.. versionchanged:: 1.4 the default max_identifier_length for Oracle is 128
 #haracters, which is adjusted down to 30 upon first connect if an older
 #ersion of Oracle server (compatibility version < 12.2) is detected.


LIMIT/OFFSET Support
--------------------

Oracle has no direct support for LIMIT and OFFSET until version 12c.
To achieve this behavior across all widely used versions of Oracle starting
with the 8 series, SQLAlchemy currently makes use of ROWNUM to achieve
LIMIT/OFFSET; the exact methodology is taken from
https://blogs.oracle.com/oraclemagazine/on-rownum-and-limiting-results .

There is currently a single option to affect its behavior:

* the "FIRST_ROWS()" optimization keyword is not used by default.  To enable
 #he usage of this optimization directive, specify ``optimize_limits=True``
 #o :func:`_sa.create_engine`.

.. versionchanged:: 1.4
 #he Oracle dialect renders limit/offset integer values using a "post
 #ompile" scheme which renders the integer directly before passing the
 #tatement to the cursor for execution.   The ``use_binds_for_limits`` flag
 #o longer has an effect.

 #. seealso::

 #ref:`change_4808`.

Support for changing the row number strategy, which would include one that
makes use of the ``row_number()`` window function as well as one that makes
use of the Oracle 12c  "FETCH FIRST N ROW / OFFSET N ROWS" keywords may be
added in a future release.


.. _oracle_returning:

RETURNING Support
-----------------

The Oracle database supports a limited form of RETURNING, in order to retrieve
result sets of matched rows from INSERT, UPDATE and DELETE statements.
Oracle's RETURNING..INTO syntax only supports one row being returned, as it
relies upon OUT parameters in order to function.  In addition, supported
DBAPIs have further limitations (see :ref:`cx_oracle_returning`).

SQLAlchemy's "implicit returning" feature, which employs RETURNING within an
INSERT and sometimes an UPDATE statement in order to fetch newly generated
primary key values and other SQL defaults and expressions, is normally enabled
on the Oracle backend.  By default, "implicit returning" typically only
fetches the value of a single ``nextval(some_seq)`` expression embedded into
an INSERT in order to increment a sequence within an INSERT statement and get
the value back at the same time. To disable this feature across the board,
specify ``implicit_returning=False`` to :func:`_sa.create_engine`::

 #ngine = create_engine("oracle://scott:tiger@dsn",
 #mplicit_returning=False)

Implicit returning can also be disabled on a table-by-table basis as a table
option::

    # Core Table
 #y_table = Table("my_table", metadata, ..., implicit_returning=False)


    # declarative
 #lass MyClass(Base):
 #_tablename__ = 'my_table'
 #_table_args__ = {"implicit_returning": False}

.. seealso::

 #ref:`cx_oracle_returning` - additional cx_oracle-specific restrictions on
 #mplicit returning.

ON UPDATE CASCADE
-----------------

Oracle doesn't have native ON UPDATE CASCADE functionality.  A trigger based
solution is available at
https://asktom.oracle.com/tkyte/update_cascade/index.html .

When using the SQLAlchemy ORM, the ORM has limited ability to manually issue
cascading updates - specify ForeignKey objects using the
"deferrable=True, initially='deferred'" keyword arguments,
and specify "passive_updates=False" on each relationship().

Oracle 8 Compatibility
----------------------

When Oracle 8 is detected, the dialect internally configures itself to the
following behaviors:

* the use_ansi flag is set to False.  This has the effect of converting all
 #OIN phrases into the WHERE clause, and in the case of LEFT OUTER JOIN
 #akes use of Oracle's (+) operator.

* the NVARCHAR2 and NCLOB datatypes are no longer generated as DDL when
 #he :class:`~sqlalchemy.types.Unicode` is used - VARCHAR2 and CLOB are
 #ssued instead.   This because these types don't seem to work correctly on
 #racle 8 even though they are available.  The
 #class:`~sqlalchemy.types.NVARCHAR` and
 #class:`~sqlalchemy.dialects.oracle.NCLOB` types will always generate
 #VARCHAR2 and NCLOB.

* the "native unicode" mode is disabled when using cx_oracle, i.e. SQLAlchemy
 #ncodes all Python unicode objects to "string" before passing in as bind
 #arameters.

Synonym/DBLINK Reflection
-------------------------

When using reflection with Table objects, the dialect can optionally search
for tables indicated by synonyms, either in local or remote schemas or
accessed over DBLINK, by passing the flag ``oracle_resolve_synonyms=True`` as
a keyword argument to the :class:`_schema.Table` construct::

 #ome_table = Table('some_table', autoload_with=some_engine,
 #racle_resolve_synonyms=True)

When this flag is set, the given name (such as ``some_table`` above) will
be searched not just in the ``ALL_TABLES`` view, but also within the
``ALL_SYNONYMS`` view to see if this name is actually a synonym to another
name.  If the synonym is located and refers to a DBLINK, the oracle dialect
knows how to locate the table's information using DBLINK syntax(e.g.
``@dblink``).

``oracle_resolve_synonyms`` is accepted wherever reflection arguments are
accepted, including methods such as :meth:`_schema.MetaData.reflect` and
:meth:`_reflection.Inspector.get_columns`.

If synonyms are not in use, this flag should be left disabled.

.. _oracle_constraint_reflection:

Constraint Reflection
---------------------

The Oracle dialect can return information about foreign key, unique, and
CHECK constraints, as well as indexes on tables.

Raw information regarding these constraints can be acquired using
:meth:`_reflection.Inspector.get_foreign_keys`,
:meth:`_reflection.Inspector.get_unique_constraints`,
:meth:`_reflection.Inspector.get_check_constraints`, and
:meth:`_reflection.Inspector.get_indexes`.

.. versionchanged:: 1.2  The Oracle dialect can now reflect UNIQUE and
 #HECK constraints.

When using reflection at the :class:`_schema.Table` level, the
:class:`_schema.Table`
will also include these constraints.

Note the following caveats:

* When using the :meth:`_reflection.Inspector.get_check_constraints` method,
 #racle
 #uilds a special "IS NOT NULL" constraint for columns that specify
 #NOT NULL".  This constraint is **not** returned by default; to include
 #he "IS NOT NULL" constraints, pass the flag ``include_all=True``::

 #rom sqlalchemy import create_engine, inspect

 #ngine = create_engine("oracle+cx_oracle://s:t@dsn")
 #nspector = inspect(engine)
 #ll_check_constraints = inspector.get_check_constraints(
 #some_table", include_all=True)

* in most cases, when reflecting a :class:`_schema.Table`,
 # UNIQUE constraint will
 #*not** be available as a :class:`.UniqueConstraint` object, as Oracle
 #irrors unique constraints with a UNIQUE index in most cases (the exception
 #eems to be when two or more unique constraints represent the same columns);
 #he :class:`_schema.Table` will instead represent these using
 #class:`.Index`
 #ith the ``unique=True`` flag set.

* Oracle creates an implicit index for the primary key of a table; this index
 #s **excluded** from all index results.

* the list of columns reflected for an index will not include column names
 #hat start with SYS_NC.

Table names with SYSTEM/SYSAUX tablespaces
-------------------------------------------

The :meth:`_reflection.Inspector.get_table_names` and
:meth:`_reflection.Inspector.get_temp_table_names`
methods each return a list of table names for the current engine. These methods
are also part of the reflection which occurs within an operation such as
:meth:`_schema.MetaData.reflect`.  By default,
these operations exclude the ``SYSTEM``
and ``SYSAUX`` tablespaces from the operation.   In order to change this, the
default list of tablespaces excluded can be changed at the engine level using
the ``exclude_tablespaces`` parameter::

    # exclude SYSAUX and SOME_TABLESPACE, but not SYSTEM
 # = create_engine(
 #oracle://scott:tiger@xe",
 #xclude_tablespaces=["SYSAUX", "SOME_TABLESPACE"])

.. versionadded:: 1.1

DateTime Compatibility
----------------------

Oracle has no datatype known as ``DATETIME``, it instead has only ``DATE``,
which can actually store a date and time value.  For this reason, the Oracle
dialect provides a type :class:`_oracle.DATE` which is a subclass of
:class:`.DateTime`.   This type has no special behavior, and is only
present as a "marker" for this type; additionally, when a database column
is reflected and the type is reported as ``DATE``, the time-supporting
:class:`_oracle.DATE` type is used.

.. versionchanged:: 0.9.4 Added :class:`_oracle.DATE` to subclass
 #class:`.DateTime`.  This is a change as previous versions
 #ould reflect a ``DATE`` column as :class:`_types.DATE`, which subclasses
 #class:`.Date`.   The only significance here is for schemes that are
 #xamining the type of column for use in special Python translations or
 #or migrating schemas to other database backends.

.. _oracle_table_options:

Oracle Table Options
-------------------------

The CREATE TABLE phrase supports the following options with Oracle
in conjunction with the :class:`_schema.Table` construct:


* ``ON COMMIT``::

 #able(
 #some_table", metadata, ...,
 #refixes=['GLOBAL TEMPORARY'], oracle_on_commit='PRESERVE ROWS')

.. versionadded:: 1.0.0

* ``COMPRESS``::

 #able('mytable', metadata, Column('data', String(32)),
 #racle_compress=True)

 #able('mytable', metadata, Column('data', String(32)),
 #racle_compress=6)

 #he ``oracle_compress`` parameter accepts either an integer compression
 #evel, or ``True`` to use the default compression level.

.. versionadded:: 1.0.0

.. _oracle_index_options:

Oracle Specific Index Options
-----------------------------

Bitmap Indexes
~~~~~~~~~~~~~~

You can specify the ``oracle_bitmap`` parameter to create a bitmap index
instead of a B-tree index::

 #ndex('my_index', my_table.c.data, oracle_bitmap=True)

Bitmap indexes cannot be unique and cannot be compressed. SQLAlchemy will not
check for such limitations, only the database will.

.. versionadded:: 1.0.0

Index compression
~~~~~~~~~~~~~~~~~

Oracle has a more efficient storage mode for indexes containing lots of
repeated values. Use the ``oracle_compress`` parameter to turn on key
compression::

 #ndex('my_index', my_table.c.data, oracle_compress=True)

 #ndex('my_index', my_table.c.data1, my_table.c.data2, unique=True,
 #racle_compress=1)

The ``oracle_compress`` parameter accepts either an integer specifying the
number of prefix columns to compress, or ``True`` to use the default (all
columns for non-unique indexes, all but the last column for unique indexes).

.. versionadded:: 1.0.0

"""  # noqa

from itertools import groupby
import re

from ... import Computed
from ... import exc
from ... import schema as sa_schema
from ... import sql
from ... import util
from ...engine import default
from ...engine import reflection
from ...sql import compiler
from ...sql import expression
from ...sql import sqltypes
from ...sql import util as sql_util
from ...sql import visitors
from ...types import BLOB
from ...types import CHAR
from ...types import CLOB
from ...types import FLOAT
from ...types import INTEGER
from ...types import NCHAR
from ...types import NVARCHAR
from ...types import TIMESTAMP
from ...types import VARCHAR
from ...util import compat

RESERVED_WORDS = set(
 #SHARE RAW DROP BETWEEN FROM DESC OPTION PRIOR LONG THEN "
 #DEFAULT ALTER IS INTO MINUS INTEGER NUMBER GRANT IDENTIFIED "
 #ALL TO ORDER ON FLOAT DATE HAVING CLUSTER NOWAIT RESOURCE "
 #ANY TABLE INDEX FOR UPDATE WHERE CHECK SMALLINT WITH DELETE "
 #BY ASC REVOKE LIKE SIZE RENAME NOCOMPRESS NULL GROUP VALUES "
 #AS IN VIEW EXCLUSIVE COMPRESS SYNONYM SELECT INSERT EXISTS "
 #NOT TRIGGER ELSE CREATE INTERSECT PCTFREE DISTINCT USER "
 #CONNECT SET MODE OF UNIQUE VARCHAR2 VARCHAR LOCK OR CHAR "
 #DECIMAL UNION PUBLIC AND START UID COMMENT CURRENT LEVEL".split()
)

NO_ARG_FNS = set(
 #UID CURRENT_DATE SYSDATE USER " "CURRENT_TIME CURRENT_TIMESTAMP".split()
)


class RAW(sqltypes._Binary):
 #_visit_name__ = "RAW"


OracleRaw = RAW


class NCLOB(sqltypes.Text):
 #_visit_name__ = "NCLOB"


class VARCHAR2(VARCHAR):
 #_visit_name__ = "VARCHAR2"


NVARCHAR2 = NVARCHAR


class NUMBER(sqltypes.Numeric, sqltypes.Integer):
 #_visit_name__ = "NUMBER"

 #ef __init__(self, precision=None, scale=None, asdecimal=None):
 #f asdecimal is None:
 #sdecimal = bool(scale and scale > 0)

 #uper(NUMBER, self).__init__(
 #recision=precision, scale=scale, asdecimal=asdecimal
 #

 #ef adapt(self, impltype):
 #et = super(NUMBER, self).adapt(impltype)
        # leave a hint for the DBAPI handler
 #et._is_oracle_number = True
 #eturn ret

 #property
 #ef _type_affinity(self):
 #f bool(self.scale and self.scale > 0):
 #eturn sqltypes.Numeric
 #lse:
 #eturn sqltypes.Integer


class DOUBLE_PRECISION(sqltypes.Float):
 #_visit_name__ = "DOUBLE_PRECISION"


class BINARY_DOUBLE(sqltypes.Float):
 #_visit_name__ = "BINARY_DOUBLE"


class BINARY_FLOAT(sqltypes.Float):
 #_visit_name__ = "BINARY_FLOAT"


class BFILE(sqltypes.LargeBinary):
 #_visit_name__ = "BFILE"


class LONG(sqltypes.Text):
 #_visit_name__ = "LONG"


class DATE(sqltypes.DateTime):
 #""Provide the oracle DATE type.

 #his type has no special Python behavior, except that it subclasses
 #class:`_types.DateTime`; this is to suit the fact that the Oracle
 #`DATE`` type supports a time value.

 #. versionadded:: 0.9.4

 #""

 #_visit_name__ = "DATE"

 #ef _compare_type_affinity(self, other):
 #eturn other._type_affinity in (sqltypes.DateTime, sqltypes.Date)


class INTERVAL(sqltypes.NativeForEmulated, sqltypes._AbstractInterval):
 #_visit_name__ = "INTERVAL"

 #ef __init__(self, day_precision=None, second_precision=None):
 #""Construct an INTERVAL.

 #ote that only DAY TO SECOND intervals are currently supported.
 #his is due to a lack of support for YEAR TO MONTH intervals
 #ithin available DBAPIs.

 #param day_precision: the day precision value.  this is the number of
 #igits to store for the day field.  Defaults to "2"
 #param second_precision: the second precision value.  this is the
 #umber of digits to store for the fractional seconds field.
 #efaults to "6".

 #""
 #elf.day_precision = day_precision
 #elf.second_precision = second_precision

 #classmethod
 #ef _adapt_from_generic_interval(cls, interval):
 #eturn INTERVAL(
 #ay_precision=interval.day_precision,
 #econd_precision=interval.second_precision,
 #

 #property
 #ef _type_affinity(self):
 #eturn sqltypes.Interval

 #ef as_generic(self, allow_nulltype=False):
 #eturn sqltypes.Interval(
 #ative=True,
 #econd_precision=self.second_precision,
 #ay_precision=self.day_precision,
 #

 #ef coerce_compared_value(self, op, value):
 #eturn self


class ROWID(sqltypes.TypeEngine):
 #""Oracle ROWID type.

 #hen used in a cast() or similar, generates ROWID.

 #""

 #_visit_name__ = "ROWID"


class _OracleBoolean(sqltypes.Boolean):
 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.NUMBER


colspecs = {
 #qltypes.Boolean: _OracleBoolean,
 #qltypes.Interval: INTERVAL,
 #qltypes.DateTime: DATE,
}

ischema_names = {
 #VARCHAR2": VARCHAR,
 #NVARCHAR2": NVARCHAR,
 #CHAR": CHAR,
 #NCHAR": NCHAR,
 #DATE": DATE,
 #NUMBER": NUMBER,
 #BLOB": BLOB,
 #BFILE": BFILE,
 #CLOB": CLOB,
 #NCLOB": NCLOB,
 #TIMESTAMP": TIMESTAMP,
 #TIMESTAMP WITH TIME ZONE": TIMESTAMP,
 #INTERVAL DAY TO SECOND": INTERVAL,
 #RAW": RAW,
 #FLOAT": FLOAT,
 #DOUBLE PRECISION": DOUBLE_PRECISION,
 #LONG": LONG,
 #BINARY_DOUBLE": BINARY_DOUBLE,
 #BINARY_FLOAT": BINARY_FLOAT,
}


class OracleTypeCompiler(compiler.GenericTypeCompiler):
    # Note:
    # Oracle DATE == DATETIME
    # Oracle does not allow milliseconds in DATE
    # Oracle does not support TIME columns

 #ef visit_datetime(self, type_, **kw):
 #eturn self.visit_DATE(type_, **kw)

 #ef visit_float(self, type_, **kw):
 #eturn self.visit_FLOAT(type_, **kw)

 #ef visit_unicode(self, type_, **kw):
 #f self.dialect._use_nchar_for_unicode:
 #eturn self.visit_NVARCHAR2(type_, **kw)
 #lse:
 #eturn self.visit_VARCHAR2(type_, **kw)

 #ef visit_INTERVAL(self, type_, **kw):
 #eturn "INTERVAL DAY%s TO SECOND%s" % (
 #ype_.day_precision is not None
 #nd "(%d)" % type_.day_precision
 #r "",
 #ype_.second_precision is not None
 #nd "(%d)" % type_.second_precision
 #r "",
 #

 #ef visit_LONG(self, type_, **kw):
 #eturn "LONG"

 #ef visit_TIMESTAMP(self, type_, **kw):
 #f type_.timezone:
 #eturn "TIMESTAMP WITH TIME ZONE"
 #lse:
 #eturn "TIMESTAMP"

 #ef visit_DOUBLE_PRECISION(self, type_, **kw):
 #eturn self._generate_numeric(type_, "DOUBLE PRECISION", **kw)

 #ef visit_BINARY_DOUBLE(self, type_, **kw):
 #eturn self._generate_numeric(type_, "BINARY_DOUBLE", **kw)

 #ef visit_BINARY_FLOAT(self, type_, **kw):
 #eturn self._generate_numeric(type_, "BINARY_FLOAT", **kw)

 #ef visit_FLOAT(self, type_, **kw):
        # don't support conversion between decimal/binary
        # precision yet
 #w["no_precision"] = True
 #eturn self._generate_numeric(type_, "FLOAT", **kw)

 #ef visit_NUMBER(self, type_, **kw):
 #eturn self._generate_numeric(type_, "NUMBER", **kw)

 #ef _generate_numeric(
 #elf, type_, name, precision=None, scale=None, no_precision=False, **kw
 #:
 #f precision is None:
 #recision = type_.precision

 #f scale is None:
 #cale = getattr(type_, "scale", None)

 #f no_precision or precision is None:
 #eturn name
 #lif scale is None:
 # = "%(name)s(%(precision)s)"
 #eturn n % {"name": name, "precision": precision}
 #lse:
 # = "%(name)s(%(precision)s, %(scale)s)"
 #eturn n % {"name": name, "precision": precision, "scale": scale}

 #ef visit_string(self, type_, **kw):
 #eturn self.visit_VARCHAR2(type_, **kw)

 #ef visit_VARCHAR2(self, type_, **kw):
 #eturn self._visit_varchar(type_, "", "2")

 #ef visit_NVARCHAR2(self, type_, **kw):
 #eturn self._visit_varchar(type_, "N", "2")

 #isit_NVARCHAR = visit_NVARCHAR2

 #ef visit_VARCHAR(self, type_, **kw):
 #eturn self._visit_varchar(type_, "", "")

 #ef _visit_varchar(self, type_, n, num):
 #f not type_.length:
 #eturn "%(n)sVARCHAR%(two)s" % {"two": num, "n": n}
 #lif not n and self.dialect._supports_char_length:
 #archar = "VARCHAR%(two)s(%(length)s CHAR)"
 #eturn varchar % {"length": type_.length, "two": num}
 #lse:
 #archar = "%(n)sVARCHAR%(two)s(%(length)s)"
 #eturn varchar % {"length": type_.length, "two": num, "n": n}

 #ef visit_text(self, type_, **kw):
 #eturn self.visit_CLOB(type_, **kw)

 #ef visit_unicode_text(self, type_, **kw):
 #f self.dialect._use_nchar_for_unicode:
 #eturn self.visit_NCLOB(type_, **kw)
 #lse:
 #eturn self.visit_CLOB(type_, **kw)

 #ef visit_large_binary(self, type_, **kw):
 #eturn self.visit_BLOB(type_, **kw)

 #ef visit_big_integer(self, type_, **kw):
 #eturn self.visit_NUMBER(type_, precision=19, **kw)

 #ef visit_boolean(self, type_, **kw):
 #eturn self.visit_SMALLINT(type_, **kw)

 #ef visit_RAW(self, type_, **kw):
 #f type_.length:
 #eturn "RAW(%(length)s)" % {"length": type_.length}
 #lse:
 #eturn "RAW"

 #ef visit_ROWID(self, type_, **kw):
 #eturn "ROWID"


class OracleCompiler(compiler.SQLCompiler):
 #""Oracle compiler modifies the lexical structure of Select
 #tatements to work under non-ANSI configured Oracle databases, if
 #he use_ansi flag is False.
 #""

 #ompound_keywords = util.update_copy(
 #ompiler.SQLCompiler.compound_keywords,
 #expression.CompoundSelect.EXCEPT: "MINUS"},
 #

 #ef __init__(self, *args, **kwargs):
 #elf.__wheres = {}
 #uper(OracleCompiler, self).__init__(*args, **kwargs)

 #ef visit_mod_binary(self, binary, operator, **kw):
 #eturn "mod(%s, %s)" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef visit_now_func(self, fn, **kw):
 #eturn "CURRENT_TIMESTAMP"

 #ef visit_char_length_func(self, fn, **kw):
 #eturn "LENGTH" + self.function_argspec(fn, **kw)

 #ef visit_match_op_binary(self, binary, operator, **kw):
 #eturn "CONTAINS (%s, %s)" % (
 #elf.process(binary.left),
 #elf.process(binary.right),
 #

 #ef visit_true(self, expr, **kw):
 #eturn "1"

 #ef visit_false(self, expr, **kw):
 #eturn "0"

 #ef get_cte_preamble(self, recursive):
 #eturn "WITH"

 #ef get_select_hint_text(self, byfroms):
 #eturn " ".join("/*+ %s */" % text for table, text in byfroms.items())

 #ef function_argspec(self, fn, **kw):
 #f len(fn.clauses) > 0 or fn.name.upper() not in NO_ARG_FNS:
 #eturn compiler.SQLCompiler.function_argspec(self, fn, **kw)
 #lse:
 #eturn ""

 #ef visit_function(self, func, **kw):
 #ext = super(OracleCompiler, self).visit_function(func, **kw)
 #f kw.get("asfrom", False):
 #ext = "TABLE (%s)" % func
 #eturn text

 #ef visit_table_valued_column(self, element, **kw):
 #ext = super(OracleCompiler, self).visit_table_valued_column(
 #lement, **kw
 #
 #ext = "COLUMN_VALUE " + text
 #eturn text

 #ef default_from(self):
 #""Called when a ``SELECT`` statement has no froms,
 #nd no ``FROM`` clause is to be appended.

 #he Oracle compiler tacks a "FROM DUAL" to the statement.
 #""

 #eturn " FROM DUAL"

 #ef visit_join(self, join, from_linter=None, **kwargs):
 #f self.dialect.use_ansi:
 #eturn compiler.SQLCompiler.visit_join(
 #elf, join, from_linter=from_linter, **kwargs
 #
 #lse:
 #f from_linter:
 #rom_linter.edges.add((join.left, join.right))

 #wargs["asfrom"] = True
 #f isinstance(join.right, expression.FromGrouping):
 #ight = join.right.element
 #lse:
 #ight = join.right
 #eturn (
 #elf.process(join.left, from_linter=from_linter, **kwargs)
 # ", "
 # self.process(right, from_linter=from_linter, **kwargs)
 #

 #ef _get_nonansi_join_whereclause(self, froms):
 #lauses = []

 #ef visit_join(join):
 #f join.isouter:
                # https://docs.oracle.com/database/121/SQLRF/queries006.htm#SQLRF52354
                # "apply the outer join operator (+) to all columns of B in
                # the join condition in the WHERE clause" - that is,
                # unconditionally regardless of operator or the other side
 #ef visit_binary(binary):
 #f isinstance(
 #inary.left, expression.ColumnClause
 # and join.right.is_derived_from(binary.left.table):
 #inary.left = _OuterJoinColumn(binary.left)
 #lif isinstance(
 #inary.right, expression.ColumnClause
 # and join.right.is_derived_from(binary.right.table):
 #inary.right = _OuterJoinColumn(binary.right)

 #lauses.append(
 #isitors.cloned_traverse(
 #oin.onclause, {}, {"binary": visit_binary}
 #
 #
 #lse:
 #lauses.append(join.onclause)

 #or j in join.left, join.right:
 #f isinstance(j, expression.Join):
 #isit_join(j)
 #lif isinstance(j, expression.FromGrouping):
 #isit_join(j.element)

 #or f in froms:
 #f isinstance(f, expression.Join):
 #isit_join(f)

 #f not clauses:
 #eturn None
 #lse:
 #eturn sql.and_(*clauses)

 #ef visit_outer_join_column(self, vc, **kw):
 #eturn self.process(vc.column, **kw) + "(+)"

 #ef visit_sequence(self, seq, **kw):
 #eturn self.preparer.format_sequence(seq) + ".nextval"

 #ef get_render_as_alias_suffix(self, alias_name_text):
 #""Oracle doesn't like ``FROM table AS alias``"""

 #eturn " " + alias_name_text

 #ef returning_clause(self, stmt, returning_cols):
 #olumns = []
 #inds = []

 #or i, column in enumerate(
 #xpression._select_iterables(returning_cols)
 #:
 #f (
 #elf.isupdate
 #nd isinstance(column, sa_schema.Column)
 #nd isinstance(column.server_default, Computed)
 #nd not self.dialect._supports_update_returning_computed_cols
 #:
 #til.warn(
 #Computed columns don't work with Oracle UPDATE "
 #statements that use RETURNING; the value of the column "
 #*before* the UPDATE takes place is returned.   It is "
 #advised to not use RETURNING with an Oracle computed "
 #column.  Consider setting implicit_returning to False on "
 #the Table object in order to avoid implicit RETURNING "
 #clauses from being generated for this Table."
 #
 #f column.type._has_column_expression:
 #ol_expr = column.type.column_expression(column)
 #lse:
 #ol_expr = column

 #utparam = sql.outparam("ret_%d" % i, type_=column.type)
 #elf.binds[outparam.key] = outparam
 #inds.append(
 #elf.bindparam_string(self._truncate_bindparam(outparam))
 #

            # ensure the ExecutionContext.get_out_parameters() method is
            # *not* called; the cx_Oracle dialect wants to handle these
            # parameters separately
 #elf.has_out_parameters = False

 #olumns.append(self.process(col_expr, within_columns_clause=False))

 #elf._add_to_result_map(
 #etattr(col_expr, "name", col_expr._anon_name_label),
 #etattr(col_expr, "name", col_expr._anon_name_label),
 #
 #olumn,
 #etattr(column, "name", None),
 #etattr(column, "key", None),
 #,
 #olumn.type,
 #

 #eturn "RETURNING " + ", ".join(columns) + " INTO " + ", ".join(binds)

 #ef translate_select_structure(self, select_stmt, **kwargs):
 #elect = select_stmt

 #f not getattr(select, "_oracle_visit", None):
 #f not self.dialect.use_ansi:
 #roms = self._display_froms_for_select(
 #elect, kwargs.get("asfrom", False)
 #
 #hereclause = self._get_nonansi_join_whereclause(froms)
 #f whereclause is not None:
 #elect = select.where(whereclause)
 #elect._oracle_visit = True

            # if fetch is used this is not needed
 #f (
 #elect._has_row_limiting_clause
 #nd select._fetch_clause is None
 #:
 #imit_clause = select._limit_clause
 #ffset_clause = select._offset_clause

 #f select._simple_int_clause(limit_clause):
 #imit_clause = limit_clause.render_literal_execute()

 #f select._simple_int_clause(offset_clause):
 #ffset_clause = offset_clause.render_literal_execute()

                # currently using form at:
                # https://blogs.oracle.com/oraclemagazine/\
                # on-rownum-and-limiting-results

 #rig_select = select
 #elect = select._generate()
 #elect._oracle_visit = True

                # add expressions to accommodate FOR UPDATE OF
 #or_update = select._for_update_arg
 #f for_update is not None and for_update.of:
 #or_update = for_update._clone()
 #or_update._copy_internals()

 #or elem in for_update.of:
 #f not select.selected_columns.contains_column(elem):
 #elect = select.add_columns(elem)

                # Wrap the middle select and add the hint
 #nner_subquery = select.alias()
 #imitselect = sql.select(
 #[
 #
 #or c in inner_subquery.c
 #f orig_select.selected_columns.corresponding_column(c)
 #s not None
 #
 #

 #f (
 #imit_clause is not None
 #nd self.dialect.optimize_limits
 #nd select._simple_int_clause(limit_clause)
 #:
 #imitselect = limitselect.prefix_with(
 #xpression.text(
 #/*+ FIRST_ROWS(%s) */"
 # self.process(limit_clause, **kwargs)
 #
 #

 #imitselect._oracle_visit = True
 #imitselect._is_wrapper = True

                # add expressions to accommodate FOR UPDATE OF
 #f for_update is not None and for_update.of:

 #dapter = sql_util.ClauseAdapter(inner_subquery)
 #or_update.of = [
 #dapter.traverse(elem) for elem in for_update.of
 #

                # If needed, add the limiting clause
 #f limit_clause is not None:
 #f select._simple_int_clause(limit_clause) and (
 #ffset_clause is None
 #r select._simple_int_clause(offset_clause)
 #:
 #ax_row = limit_clause

 #f offset_clause is not None:
 #ax_row = max_row + offset_clause

 #lse:
 #ax_row = limit_clause

 #f offset_clause is not None:
 #ax_row = max_row + offset_clause
 #imitselect = limitselect.where(
 #ql.literal_column("ROWNUM") <= max_row
 #

                # If needed, add the ora_rn, and wrap again with offset.
 #f offset_clause is None:
 #imitselect._for_update_arg = for_update
 #elect = limitselect
 #lse:
 #imitselect = limitselect.add_columns(
 #ql.literal_column("ROWNUM").label("ora_rn")
 #
 #imitselect._oracle_visit = True
 #imitselect._is_wrapper = True

 #f for_update is not None and for_update.of:
 #imitselect_cols = limitselect.selected_columns
 #or elem in for_update.of:
 #f (
 #imitselect_cols.corresponding_column(elem)
 #s None
 #:
 #imitselect = limitselect.add_columns(elem)

 #imit_subquery = limitselect.alias()
 #rigselect_cols = orig_select.selected_columns
 #ffsetselect = sql.select(
 #[
 #
 #or c in limit_subquery.c
 #f origselect_cols.corresponding_column(c)
 #s not None
 #
 #

 #ffsetselect._oracle_visit = True
 #ffsetselect._is_wrapper = True

 #f for_update is not None and for_update.of:
 #dapter = sql_util.ClauseAdapter(limit_subquery)
 #or_update.of = [
 #dapter.traverse(elem) for elem in for_update.of
 #

 #ffsetselect = offsetselect.where(
 #ql.literal_column("ora_rn") > offset_clause
 #

 #ffsetselect._for_update_arg = for_update
 #elect = offsetselect

 #eturn select

 #ef limit_clause(self, select, **kw):
 #eturn ""

 #ef visit_empty_set_expr(self, type_):
 #eturn "SELECT 1 FROM DUAL WHERE 1!=1"

 #ef for_update_clause(self, select, **kw):
 #f self.is_subquery():
 #eturn ""

 #mp = " FOR UPDATE"

 #f select._for_update_arg.of:
 #mp += " OF " + ", ".join(
 #elf.process(elem, **kw) for elem in select._for_update_arg.of
 #

 #f select._for_update_arg.nowait:
 #mp += " NOWAIT"
 #f select._for_update_arg.skip_locked:
 #mp += " SKIP LOCKED"

 #eturn tmp

 #ef visit_is_distinct_from_binary(self, binary, operator, **kw):
 #eturn "DECODE(%s, %s, 0, 1) = 1" % (
 #elf.process(binary.left),
 #elf.process(binary.right),
 #

 #ef visit_is_not_distinct_from_binary(self, binary, operator, **kw):
 #eturn "DECODE(%s, %s, 0, 1) = 0" % (
 #elf.process(binary.left),
 #elf.process(binary.right),
 #

 #ef _get_regexp_args(self, binary, kw):
 #tring = self.process(binary.left, **kw)
 #attern = self.process(binary.right, **kw)
 #lags = binary.modifiers["flags"]
 #f flags is not None:
 #lags = self.process(flags, **kw)
 #eturn string, pattern, flags

 #ef visit_regexp_match_op_binary(self, binary, operator, **kw):
 #tring, pattern, flags = self._get_regexp_args(binary, kw)
 #f flags is None:
 #eturn "REGEXP_LIKE(%s, %s)" % (string, pattern)
 #lse:
 #eturn "REGEXP_LIKE(%s, %s, %s)" % (string, pattern, flags)

 #ef visit_not_regexp_match_op_binary(self, binary, operator, **kw):
 #eturn "NOT %s" % self.visit_regexp_match_op_binary(
 #inary, operator, **kw
 #

 #ef visit_regexp_replace_op_binary(self, binary, operator, **kw):
 #tring, pattern, flags = self._get_regexp_args(binary, kw)
 #eplacement = self.process(binary.modifiers["replacement"], **kw)
 #f flags is None:
 #eturn "REGEXP_REPLACE(%s, %s, %s)" % (
 #tring,
 #attern,
 #eplacement,
 #
 #lse:
 #eturn "REGEXP_REPLACE(%s, %s, %s, %s)" % (
 #tring,
 #attern,
 #eplacement,
 #lags,
 #


class OracleDDLCompiler(compiler.DDLCompiler):
 #ef define_constraint_cascades(self, constraint):
 #ext = ""
 #f constraint.ondelete is not None:
 #ext += " ON DELETE %s" % constraint.ondelete

        # oracle has no ON UPDATE CASCADE -
        # its only available via triggers
        # https://asktom.oracle.com/tkyte/update_cascade/index.html
 #f constraint.onupdate is not None:
 #til.warn(
 #Oracle does not contain native UPDATE CASCADE "
 #functionality - onupdates will not be rendered for foreign "
 #keys.  Consider using deferrable=True, initially='deferred' "
 #or triggers."
 #

 #eturn text

 #ef visit_drop_table_comment(self, drop):
 #eturn "COMMENT ON TABLE %s IS ''" % self.preparer.format_table(
 #rop.element
 #

 #ef visit_create_index(self, create):
 #ndex = create.element
 #elf._verify_index_table(index)
 #reparer = self.preparer
 #ext = "CREATE "
 #f index.unique:
 #ext += "UNIQUE "
 #f index.dialect_options["oracle"]["bitmap"]:
 #ext += "BITMAP "
 #ext += "INDEX %s ON %s (%s)" % (
 #elf._prepared_index_name(index, include_schema=True),
 #reparer.format_table(index.table, use_schema=True),
 #, ".join(
 #elf.sql_compiler.process(
 #xpr, include_table=False, literal_binds=True
 #
 #or expr in index.expressions
 #,
 #
 #f index.dialect_options["oracle"]["compress"] is not False:
 #f index.dialect_options["oracle"]["compress"] is True:
 #ext += " COMPRESS"
 #lse:
 #ext += " COMPRESS %d" % (
 #ndex.dialect_options["oracle"]["compress"]
 #
 #eturn text

 #ef post_create_table(self, table):
 #able_opts = []
 #pts = table.dialect_options["oracle"]

 #f opts["on_commit"]:
 #n_commit_options = opts["on_commit"].replace("_", " ").upper()
 #able_opts.append("\n ON COMMIT %s" % on_commit_options)

 #f opts["compress"]:
 #f opts["compress"] is True:
 #able_opts.append("\n COMPRESS")
 #lse:
 #able_opts.append("\n COMPRESS FOR %s" % (opts["compress"]))

 #eturn "".join(table_opts)

 #ef get_identity_options(self, identity_options):
 #ext = super(OracleDDLCompiler, self).get_identity_options(
 #dentity_options
 #
 #ext = text.replace("NO MINVALUE", "NOMINVALUE")
 #ext = text.replace("NO MAXVALUE", "NOMAXVALUE")
 #ext = text.replace("NO CYCLE", "NOCYCLE")
 #ext = text.replace("NO ORDER", "NOORDER")
 #eturn text

 #ef visit_computed_column(self, generated):
 #ext = "GENERATED ALWAYS AS (%s)" % self.sql_compiler.process(
 #enerated.sqltext, include_table=False, literal_binds=True
 #
 #f generated.persisted is True:
 #aise exc.CompileError(
 #Oracle computed columns do not support 'stored' persistence; "
 #set the 'persisted' flag to None or False for Oracle support."
 #
 #lif generated.persisted is False:
 #ext += " VIRTUAL"
 #eturn text

 #ef visit_identity_column(self, identity, **kw):
 #f identity.always is None:
 #ind = ""
 #lse:
 #ind = "ALWAYS" if identity.always else "BY DEFAULT"
 #ext = "GENERATED %s" % kind
 #f identity.on_null:
 #ext += " ON NULL"
 #ext += " AS IDENTITY"
 #ptions = self.get_identity_options(identity)
 #f options:
 #ext += " (%s)" % options
 #eturn text


class OracleIdentifierPreparer(compiler.IdentifierPreparer):

 #eserved_words = {x.lower() for x in RESERVED_WORDS}
 #llegal_initial_characters = {str(dig) for dig in range(0, 10)}.union(
 #"_", "$"]
 #

 #ef _bindparam_requires_quotes(self, value):
 #""Return True if the given identifier requires quoting."""
 #c_value = value.lower()
 #eturn (
 #c_value in self.reserved_words
 #r value[0] in self.illegal_initial_characters
 #r not self.legal_characters.match(util.text_type(value))
 #

 #ef format_savepoint(self, savepoint):
 #ame = savepoint.ident.lstrip("_")
 #eturn super(OracleIdentifierPreparer, self).format_savepoint(
 #avepoint, name
 #


class OracleExecutionContext(default.DefaultExecutionContext):
 #ef fire_sequence(self, seq, type_):
 #eturn self._execute_scalar(
 #SELECT "
 # self.identifier_preparer.format_sequence(seq)
 # ".nextval FROM DUAL",
 #ype_,
 #


class OracleDialect(default.DefaultDialect):
 #ame = "oracle"
 #upports_statement_cache = True
 #upports_alter = True
 #upports_unicode_statements = False
 #upports_unicode_binds = False
 #ax_identifier_length = 128

 #upports_simple_order_by_label = False
 #te_follows_insert = True

 #upports_sequences = True
 #equences_optional = False
 #ostfetch_lastrowid = False

 #efault_paramstyle = "named"
 #olspecs = colspecs
 #schema_names = ischema_names
 #equires_name_normalize = True

 #upports_comments = True

 #upports_default_values = False
 #upports_default_metavalue = True
 #upports_empty_insert = False
 #upports_identity_columns = True

 #tatement_compiler = OracleCompiler
 #dl_compiler = OracleDDLCompiler
 #ype_compiler = OracleTypeCompiler
 #reparer = OracleIdentifierPreparer
 #xecution_ctx_cls = OracleExecutionContext

 #eflection_options = ("oracle_resolve_synonyms",)

 #use_nchar_for_unicode = False

 #onstruct_arguments = [
 #
 #a_schema.Table,
 #"resolve_synonyms": False, "on_commit": None, "compress": False},
 #,
 #sa_schema.Index, {"bitmap": False, "compress": False}),
 #

 #util.deprecated_params(
 #se_binds_for_limits=(
 #1.4",
 #The ``use_binds_for_limits`` Oracle dialect parameter is "
 #deprecated. The dialect now renders LIMIT /OFFSET integers "
 #inline in all cases using a post-compilation hook, so that the "
 #value is still represented by a 'bound parameter' on the Core "
 #Expression side.",
 #
 #
 #ef __init__(
 #elf,
 #se_ansi=True,
 #ptimize_limits=False,
 #se_binds_for_limits=None,
 #se_nchar_for_unicode=False,
 #xclude_tablespaces=("SYSTEM", "SYSAUX"),
 #*kwargs
 #:
 #efault.DefaultDialect.__init__(self, **kwargs)
 #elf._use_nchar_for_unicode = use_nchar_for_unicode
 #elf.use_ansi = use_ansi
 #elf.optimize_limits = optimize_limits
 #elf.exclude_tablespaces = exclude_tablespaces

 #ef initialize(self, connection):
 #uper(OracleDialect, self).initialize(connection)

 #elf.implicit_returning = self.__dict__.get(
 #implicit_returning", self.server_version_info > (10,)
 #

 #f self._is_oracle_8:
 #elf.colspecs = self.colspecs.copy()
 #elf.colspecs.pop(sqltypes.Interval)
 #elf.use_ansi = False

 #elf.supports_identity_columns = self.server_version_info >= (12,)

 #ef _get_effective_compat_server_version_info(self, connection):
        # dialect does not need compat levels below 12.2, so don't query
        # in those cases

 #f self.server_version_info < (12, 2):
 #eturn self.server_version_info
 #ry:
 #ompat = connection.exec_driver_sql(
 #SELECT value FROM v$parameter WHERE name = 'compatible'"
 #.scalar()
 #xcept exc.DBAPIError:
 #ompat = None

 #f compat:
 #ry:
 #eturn tuple(int(x) for x in compat.split("."))
 #xcept:
 #eturn self.server_version_info
 #lse:
 #eturn self.server_version_info

 #property
 #ef _is_oracle_8(self):
 #eturn self.server_version_info and self.server_version_info < (9,)

 #property
 #ef _supports_table_compression(self):
 #eturn self.server_version_info and self.server_version_info >= (10, 1)

 #property
 #ef _supports_table_compress_for(self):
 #eturn self.server_version_info and self.server_version_info >= (11,)

 #property
 #ef _supports_char_length(self):
 #eturn not self._is_oracle_8

 #property
 #ef _supports_update_returning_computed_cols(self):
        # on version 18 this error is no longet present while it happens on 11
        # it may work also on versions before the 18
 #eturn self.server_version_info and self.server_version_info >= (18,)

 #ef do_release_savepoint(self, connection, name):
        # Oracle does not support RELEASE SAVEPOINT
 #ass

 #ef _check_max_identifier_length(self, connection):
 #f self._get_effective_compat_server_version_info(connection) < (
 #2,
 #,
 #:
 #eturn 30
 #lse:
            # use the default
 #eturn None

 #ef _check_unicode_returns(self, connection):
 #dditional_tests = [
 #xpression.cast(
 #xpression.literal_column("'test nvarchar2 returns'"),
 #qltypes.NVARCHAR(60),
 #
 #
 #eturn super(OracleDialect, self)._check_unicode_returns(
 #onnection, additional_tests
 #

 #isolation_lookup = ["READ COMMITTED", "SERIALIZABLE"]

 #ef get_isolation_level(self, connection):
 #aise NotImplementedError("implemented by cx_Oracle dialect")

 #ef get_default_isolation_level(self, dbapi_conn):
 #ry:
 #eturn self.get_isolation_level(dbapi_conn)
 #xcept NotImplementedError:
 #aise
 #xcept:
 #eturn "READ COMMITTED"

 #ef set_isolation_level(self, connection, level):
 #aise NotImplementedError("implemented by cx_Oracle dialect")

 #ef has_table(self, connection, table_name, schema=None):
 #elf._ensure_has_table_connection(connection)

 #f not schema:
 #chema = self.default_schema_name
 #ursor = connection.execute(
 #ql.text(
 #SELECT table_name FROM all_tables "
 #WHERE table_name = :name AND owner = :schema_name"
 #,
 #ict(
 #ame=self.denormalize_name(table_name),
 #chema_name=self.denormalize_name(schema),
 #,
 #
 #eturn cursor.first() is not None

 #ef has_sequence(self, connection, sequence_name, schema=None):
 #f not schema:
 #chema = self.default_schema_name
 #ursor = connection.execute(
 #ql.text(
 #SELECT sequence_name FROM all_sequences "
 #WHERE sequence_name = :name AND "
 #sequence_owner = :schema_name"
 #,
 #ict(
 #ame=self.denormalize_name(sequence_name),
 #chema_name=self.denormalize_name(schema),
 #,
 #
 #eturn cursor.first() is not None

 #ef _get_default_schema_name(self, connection):
 #eturn self.normalize_name(
 #onnection.exec_driver_sql(
 #select sys_context( 'userenv', 'current_schema' ) from dual"
 #.scalar()
 #

 #ef _resolve_synonym(
 #elf,
 #onnection,
 #esired_owner=None,
 #esired_synonym=None,
 #esired_table=None,
 #:
 #""search for a local synonym matching the given desired owner/name.

 #f desired_owner is None, attempts to locate a distinct owner.

 #eturns the actual name, owner, dblink name, and synonym name if
 #ound.
 #""

 # = (
 #SELECT owner, table_owner, table_name, db_link, "
 #synonym_name FROM all_synonyms WHERE "
 #
 #lauses = []
 #arams = {}
 #f desired_synonym:
 #lauses.append("synonym_name = :synonym_name")
 #arams["synonym_name"] = desired_synonym
 #f desired_owner:
 #lauses.append("owner = :desired_owner")
 #arams["desired_owner"] = desired_owner
 #f desired_table:
 #lauses.append("table_name = :tname")
 #arams["tname"] = desired_table

 # += " AND ".join(clauses)

 #esult = connection.execution_options(future_result=True).execute(
 #ql.text(q), params
 #
 #f desired_owner:
 #ow = result.mappings().first()
 #f row:
 #eturn (
 #ow["table_name"],
 #ow["table_owner"],
 #ow["db_link"],
 #ow["synonym_name"],
 #
 #lse:
 #eturn None, None, None, None
 #lse:
 #ows = result.mappings().all()
 #f len(rows) > 1:
 #aise AssertionError(
 #There are multiple tables visible to the schema, you "
 #must specify owner"
 #
 #lif len(rows) == 1:
 #ow = rows[0]
 #eturn (
 #ow["table_name"],
 #ow["table_owner"],
 #ow["db_link"],
 #ow["synonym_name"],
 #
 #lse:
 #eturn None, None, None, None

 #reflection.cache
 #ef _prepare_reflection_args(
 #elf,
 #onnection,
 #able_name,
 #chema=None,
 #esolve_synonyms=False,
 #blink="",
 #*kw
 #:

 #f resolve_synonyms:
 #ctual_name, owner, dblink, synonym = self._resolve_synonym(
 #onnection,
 #esired_owner=self.denormalize_name(schema),
 #esired_synonym=self.denormalize_name(table_name),
 #
 #lse:
 #ctual_name, owner, dblink, synonym = None, None, None, None
 #f not actual_name:
 #ctual_name = self.denormalize_name(table_name)

 #f dblink:
            # using user_db_links here since all_db_links appears
            # to have more restricted permissions.
            # https://docs.oracle.com/cd/B28359_01/server.111/b28310/ds_admin005.htm
            # will need to hear from more users if we are doing
            # the right thing here.  See [ticket:2619]
 #wner = connection.scalar(
 #ql.text(
 #SELECT username FROM user_db_links " "WHERE db_link=:link"
 #,
 #ict(link=dblink),
 #
 #blink = "@" + dblink
 #lif not owner:
 #wner = self.denormalize_name(schema or self.default_schema_name)

 #eturn (actual_name, owner, dblink or "", synonym)

 #reflection.cache
 #ef get_schema_names(self, connection, **kw):
 # = "SELECT username FROM all_users ORDER BY username"
 #ursor = connection.exec_driver_sql(s)
 #eturn [self.normalize_name(row[0]) for row in cursor]

 #reflection.cache
 #ef get_table_names(self, connection, schema=None, **kw):
 #chema = self.denormalize_name(schema or self.default_schema_name)

        # note that table_names() isn't loading DBLINKed or synonym'ed tables
 #f schema is None:
 #chema = self.default_schema_name

 #ql_str = "SELECT table_name FROM all_tables WHERE "
 #f self.exclude_tablespaces:
 #ql_str += (
 #nvl(tablespace_name, 'no tablespace') "
 #NOT IN (%s) AND "
 # (", ".join(["'%s'" % ts for ts in self.exclude_tablespaces]))
 #
 #ql_str += (
 #OWNER = :owner " "AND IOT_NAME IS NULL " "AND DURATION IS NULL"
 #

 #ursor = connection.execute(sql.text(sql_str), dict(owner=schema))
 #eturn [self.normalize_name(row[0]) for row in cursor]

 #reflection.cache
 #ef get_temp_table_names(self, connection, **kw):
 #chema = self.denormalize_name(self.default_schema_name)

 #ql_str = "SELECT table_name FROM all_tables WHERE "
 #f self.exclude_tablespaces:
 #ql_str += (
 #nvl(tablespace_name, 'no tablespace') "
 #NOT IN (%s) AND "
 # (", ".join(["'%s'" % ts for ts in self.exclude_tablespaces]))
 #
 #ql_str += (
 #OWNER = :owner "
 #AND IOT_NAME IS NULL "
 #AND DURATION IS NOT NULL"
 #

 #ursor = connection.execute(sql.text(sql_str), dict(owner=schema))
 #eturn [self.normalize_name(row[0]) for row in cursor]

 #reflection.cache
 #ef get_view_names(self, connection, schema=None, **kw):
 #chema = self.denormalize_name(schema or self.default_schema_name)
 # = sql.text("SELECT view_name FROM all_views WHERE owner = :owner")
 #ursor = connection.execute(
 #, dict(owner=self.denormalize_name(schema))
 #
 #eturn [self.normalize_name(row[0]) for row in cursor]

 #reflection.cache
 #ef get_sequence_names(self, connection, schema=None, **kw):
 #f not schema:
 #chema = self.default_schema_name
 #ursor = connection.execute(
 #ql.text(
 #SELECT sequence_name FROM all_sequences "
 #WHERE sequence_owner = :schema_name"
 #,
 #ict(schema_name=self.denormalize_name(schema)),
 #
 #eturn [self.normalize_name(row[0]) for row in cursor]

 #reflection.cache
 #ef get_table_options(self, connection, table_name, schema=None, **kw):
 #ptions = {}

 #esolve_synonyms = kw.get("oracle_resolve_synonyms", False)
 #blink = kw.get("dblink", "")
 #nfo_cache = kw.get("info_cache")

 #table_name, schema, dblink, synonym) = self._prepare_reflection_args(
 #onnection,
 #able_name,
 #chema,
 #esolve_synonyms,
 #blink,
 #nfo_cache=info_cache,
 #

 #arams = {"table_name": table_name}

 #olumns = ["table_name"]
 #f self._supports_table_compression:
 #olumns.append("compression")
 #f self._supports_table_compress_for:
 #olumns.append("compress_for")

 #ext = (
 #SELECT %(columns)s "
 #FROM ALL_TABLES%(dblink)s "
 #WHERE table_name = :table_name"
 #

 #f schema is not None:
 #arams["owner"] = schema
 #ext += " AND owner = :owner "
 #ext = text % {"dblink": dblink, "columns": ", ".join(columns)}

 #esult = connection.execute(sql.text(text), params)

 #nabled = dict(DISABLED=False, ENABLED=True)

 #ow = result.first()
 #f row:
 #f "compression" in row._fields and enabled.get(
 #ow.compression, False
 #:
 #f "compress_for" in row._fields:
 #ptions["oracle_compress"] = row.compress_for
 #lse:
 #ptions["oracle_compress"] = True

 #eturn options

 #reflection.cache
 #ef get_columns(self, connection, table_name, schema=None, **kw):
 #""

 #w arguments can be:

 #racle_resolve_synonyms

 #blink

 #""

 #esolve_synonyms = kw.get("oracle_resolve_synonyms", False)
 #blink = kw.get("dblink", "")
 #nfo_cache = kw.get("info_cache")

 #table_name, schema, dblink, synonym) = self._prepare_reflection_args(
 #onnection,
 #able_name,
 #chema,
 #esolve_synonyms,
 #blink,
 #nfo_cache=info_cache,
 #
 #olumns = []
 #f self._supports_char_length:
 #har_length_col = "char_length"
 #lse:
 #har_length_col = "data_length"

 #f self.server_version_info >= (12,):
 #dentity_cols = """\
 #ol.default_on_null,
 #
 #ELECT id.generation_type || ',' || id.IDENTITY_OPTIONS
 #ROM ALL_TAB_IDENTITY_COLS%(dblink)s id
 #HERE col.table_name = id.table_name
 #ND col.column_name = id.column_name
 #ND col.owner = id.owner
 # AS identity_options""" % {
 #dblink": dblink
 #
 #lse:
 #dentity_cols = "NULL as default_on_null, NULL as identity_options"

 #arams = {"table_name": table_name}
 #ext = """
 #ELECT
 #ol.column_name,
 #ol.data_type,
 #ol.%(char_length_col)s,
 #ol.data_precision,
 #ol.data_scale,
 #ol.nullable,
 #ol.data_default,
 #om.comments,
 #ol.virtual_column,
 #(identity_cols)s
 #ROM all_tab_cols%(dblink)s col
 #EFT JOIN all_col_comments%(dblink)s com
 #N col.table_name = com.table_name
 #ND col.column_name = com.column_name
 #ND col.owner = com.owner
 #HERE col.table_name = :table_name
 #ND col.hidden_column = 'NO'
 #""
 #f schema is not None:
 #arams["owner"] = schema
 #ext += " AND col.owner = :owner "
 #ext += " ORDER BY col.column_id"
 #ext = text % {
 #dblink": dblink,
 #char_length_col": char_length_col,
 #identity_cols": identity_cols,
 #

 # = connection.execute(sql.text(text), params)

 #or row in c:
 #olname = self.normalize_name(row[0])
 #rig_colname = row[0]
 #oltype = row[1]
 #ength = row[2]
 #recision = row[3]
 #cale = row[4]
 #ullable = row[5] == "Y"
 #efault = row[6]
 #omment = row[7]
 #enerated = row[8]
 #efault_on_nul = row[9]
 #dentity_options = row[10]

 #f coltype == "NUMBER":
 #f precision is None and scale == 0:
 #oltype = INTEGER()
 #lse:
 #oltype = NUMBER(precision, scale)
 #lif coltype == "FLOAT":
                # TODO: support "precision" here as "binary_precision"
 #oltype = FLOAT()
 #lif coltype in ("VARCHAR2", "NVARCHAR2", "CHAR", "NCHAR"):
 #oltype = self.ischema_names.get(coltype)(length)
 #lif "WITH TIME ZONE" in coltype:
 #oltype = TIMESTAMP(timezone=True)
 #lse:
 #oltype = re.sub(r"\(\d+\)", "", coltype)
 #ry:
 #oltype = self.ischema_names[coltype]
 #xcept KeyError:
 #til.warn(
 #Did not recognize type '%s' of column '%s'"
 # (coltype, colname)
 #
 #oltype = sqltypes.NULLTYPE

 #f generated == "YES":
 #omputed = dict(sqltext=default)
 #efault = None
 #lse:
 #omputed = None

 #f identity_options is not None:
 #dentity = self._parse_identity_options(
 #dentity_options, default_on_nul
 #
 #efault = None
 #lse:
 #dentity = None

 #dict = {
 #name": colname,
 #type": coltype,
 #nullable": nullable,
 #default": default,
 #autoincrement": "auto",
 #comment": comment,
 #
 #f orig_colname.lower() == orig_colname:
 #dict["quote"] = True
 #f computed is not None:
 #dict["computed"] = computed
 #f identity is not None:
 #dict["identity"] = identity

 #olumns.append(cdict)
 #eturn columns

 #ef _parse_identity_options(self, identity_options, default_on_nul):
        # identity_options is a string that starts with 'ALWAYS,' or
        # 'BY DEFAULT,' and continues with
        # START WITH: 1, INCREMENT BY: 1, MAX_VALUE: 123, MIN_VALUE: 1,
        # CYCLE_FLAG: N, CACHE_SIZE: 1, ORDER_FLAG: N, SCALE_FLAG: N,
        # EXTEND_FLAG: N, SESSION_FLAG: N, KEEP_VALUE: N
 #arts = [p.strip() for p in identity_options.split(",")]
 #dentity = {
 #always": parts[0] == "ALWAYS",
 #on_null": default_on_nul == "YES",
 #

 #or part in parts[1:]:
 #ption, value = part.split(":")
 #alue = value.strip()

 #f "START WITH" in option:
 #dentity["start"] = compat.long_type(value)
 #lif "INCREMENT BY" in option:
 #dentity["increment"] = compat.long_type(value)
 #lif "MAX_VALUE" in option:
 #dentity["maxvalue"] = compat.long_type(value)
 #lif "MIN_VALUE" in option:
 #dentity["minvalue"] = compat.long_type(value)
 #lif "CYCLE_FLAG" in option:
 #dentity["cycle"] = value == "Y"
 #lif "CACHE_SIZE" in option:
 #dentity["cache"] = compat.long_type(value)
 #lif "ORDER_FLAG" in option:
 #dentity["order"] = value == "Y"
 #eturn identity

 #reflection.cache
 #ef get_table_comment(
 #elf,
 #onnection,
 #able_name,
 #chema=None,
 #esolve_synonyms=False,
 #blink="",
 #*kw
 #:

 #nfo_cache = kw.get("info_cache")
 #table_name, schema, dblink, synonym) = self._prepare_reflection_args(
 #onnection,
 #able_name,
 #chema,
 #esolve_synonyms,
 #blink,
 #nfo_cache=info_cache,
 #

 #f not schema:
 #chema = self.default_schema_name

 #OMMENT_SQL = """
 #ELECT comments
 #ROM all_tab_comments
 #HERE table_name = :table_name AND owner = :schema_name
 #""

 # = connection.execute(
 #ql.text(COMMENT_SQL),
 #ict(table_name=table_name, schema_name=schema),
 #
 #eturn {"text": c.scalar()}

 #reflection.cache
 #ef get_indexes(
 #elf,
 #onnection,
 #able_name,
 #chema=None,
 #esolve_synonyms=False,
 #blink="",
 #*kw
 #:

 #nfo_cache = kw.get("info_cache")
 #table_name, schema, dblink, synonym) = self._prepare_reflection_args(
 #onnection,
 #able_name,
 #chema,
 #esolve_synonyms,
 #blink,
 #nfo_cache=info_cache,
 #
 #ndexes = []

 #arams = {"table_name": table_name}
 #ext = (
 #SELECT a.index_name, a.column_name, "
 #\nb.index_type, b.uniqueness, b.compression, b.prefix_length "
 #\nFROM ALL_IND_COLUMNS%(dblink)s a, "
 #\nALL_INDEXES%(dblink)s b "
 #\nWHERE "
 #\na.index_name = b.index_name "
 #\nAND a.table_owner = b.table_owner "
 #\nAND a.table_name = b.table_name "
 #\nAND a.table_name = :table_name "
 #

 #f schema is not None:
 #arams["schema"] = schema
 #ext += "AND a.table_owner = :schema "

 #ext += "ORDER BY a.index_name, a.column_position"

 #ext = text % {"dblink": dblink}

 # = sql.text(text)
 #p = connection.execute(q, params)
 #ndexes = []
 #ast_index_name = None
 #k_constraint = self.get_pk_constraint(
 #onnection,
 #able_name,
 #chema,
 #esolve_synonyms=resolve_synonyms,
 #blink=dblink,
 #nfo_cache=kw.get("info_cache"),
 #

 #niqueness = dict(NONUNIQUE=False, UNIQUE=True)
 #nabled = dict(DISABLED=False, ENABLED=True)

 #racle_sys_col = re.compile(r"SYS_NC\d+\$", re.IGNORECASE)

 #ndex = None
 #or rset in rp:
 #ndex_name_normalized = self.normalize_name(rset.index_name)

            # skip primary key index.  This is refined as of
            # [ticket:5421].  Note that ALL_INDEXES.GENERATED will by "Y"
            # if the name of this index was generated by Oracle, however
            # if a named primary key constraint was created then this flag
            # is false.
 #f (
 #k_constraint
 #nd index_name_normalized == pk_constraint["name"]
 #:
 #ontinue

 #f rset.index_name != last_index_name:
 #ndex = dict(
 #ame=index_name_normalized,
 #olumn_names=[],
 #ialect_options={},
 #
 #ndexes.append(index)
 #ndex["unique"] = uniqueness.get(rset.uniqueness, False)

 #f rset.index_type in ("BITMAP", "FUNCTION-BASED BITMAP"):
 #ndex["dialect_options"]["oracle_bitmap"] = True
 #f enabled.get(rset.compression, False):
 #ndex["dialect_options"][
 #oracle_compress"
 # = rset.prefix_length

            # filter out Oracle SYS_NC names.  could also do an outer join
            # to the all_tab_columns table and check for real col names there.
 #f not oracle_sys_col.match(rset.column_name):
 #ndex["column_names"].append(
 #elf.normalize_name(rset.column_name)
 #
 #ast_index_name = rset.index_name

 #eturn indexes

 #reflection.cache
 #ef _get_constraint_data(
 #elf, connection, table_name, schema=None, dblink="", **kw
 #:

 #arams = {"table_name": table_name}

 #ext = (
 #SELECT"
 #\nac.constraint_name,"  # 0
 #\nac.constraint_type,"  # 1
 #\nloc.column_name AS local_column,"  # 2
 #\nrem.table_name AS remote_table,"  # 3
 #\nrem.column_name AS remote_column,"  # 4
 #\nrem.owner AS remote_owner,"  # 5
 #\nloc.position as loc_pos,"  # 6
 #\nrem.position as rem_pos,"  # 7
 #\nac.search_condition,"  # 8
 #\nac.delete_rule"  # 9
 #\nFROM all_constraints%(dblink)s ac,"
 #\nall_cons_columns%(dblink)s loc,"
 #\nall_cons_columns%(dblink)s rem"
 #\nWHERE ac.table_name = :table_name"
 #\nAND ac.constraint_type IN ('R','P', 'U', 'C')"
 #

 #f schema is not None:
 #arams["owner"] = schema
 #ext += "\nAND ac.owner = :owner"

 #ext += (
 #\nAND ac.owner = loc.owner"
 #\nAND ac.constraint_name = loc.constraint_name"
 #\nAND ac.r_owner = rem.owner(+)"
 #\nAND ac.r_constraint_name = rem.constraint_name(+)"
 #\nAND (rem.position IS NULL or loc.position=rem.position)"
 #\nORDER BY ac.constraint_name, loc.position"
 #

 #ext = text % {"dblink": dblink}
 #p = connection.execute(sql.text(text), params)
 #onstraint_data = rp.fetchall()
 #eturn constraint_data

 #reflection.cache
 #ef get_pk_constraint(self, connection, table_name, schema=None, **kw):
 #esolve_synonyms = kw.get("oracle_resolve_synonyms", False)
 #blink = kw.get("dblink", "")
 #nfo_cache = kw.get("info_cache")

 #table_name, schema, dblink, synonym) = self._prepare_reflection_args(
 #onnection,
 #able_name,
 #chema,
 #esolve_synonyms,
 #blink,
 #nfo_cache=info_cache,
 #
 #keys = []
 #onstraint_name = None
 #onstraint_data = self._get_constraint_data(
 #onnection,
 #able_name,
 #chema,
 #blink,
 #nfo_cache=kw.get("info_cache"),
 #

 #or row in constraint_data:
 #
 #ons_name,
 #ons_type,
 #ocal_column,
 #emote_table,
 #emote_column,
 #emote_owner,
 # = row[0:2] + tuple([self.normalize_name(x) for x in row[2:6]])
 #f cons_type == "P":
 #f constraint_name is None:
 #onstraint_name = self.normalize_name(cons_name)
 #keys.append(local_column)
 #eturn {"constrained_columns": pkeys, "name": constraint_name}

 #reflection.cache
 #ef get_foreign_keys(self, connection, table_name, schema=None, **kw):
 #""

 #w arguments can be:

 #racle_resolve_synonyms

 #blink

 #""
 #equested_schema = schema  # to check later on
 #esolve_synonyms = kw.get("oracle_resolve_synonyms", False)
 #blink = kw.get("dblink", "")
 #nfo_cache = kw.get("info_cache")

 #table_name, schema, dblink, synonym) = self._prepare_reflection_args(
 #onnection,
 #able_name,
 #chema,
 #esolve_synonyms,
 #blink,
 #nfo_cache=info_cache,
 #

 #onstraint_data = self._get_constraint_data(
 #onnection,
 #able_name,
 #chema,
 #blink,
 #nfo_cache=kw.get("info_cache"),
 #

 #ef fkey_rec():
 #eturn {
 #name": None,
 #constrained_columns": [],
 #referred_schema": None,
 #referred_table": None,
 #referred_columns": [],
 #options": {},
 #

 #keys = util.defaultdict(fkey_rec)

 #or row in constraint_data:
 #
 #ons_name,
 #ons_type,
 #ocal_column,
 #emote_table,
 #emote_column,
 #emote_owner,
 # = row[0:2] + tuple([self.normalize_name(x) for x in row[2:6]])

 #ons_name = self.normalize_name(cons_name)

 #f cons_type == "R":
 #f remote_table is None:
                    # ticket 363
 #til.warn(
 #
 #Got 'None' querying 'table_name' from "
 #all_cons_columns%(dblink)s - does the user have "
 #proper rights to the table?"
 #
 # {"dblink": dblink}
 #
 #ontinue

 #ec = fkeys[cons_name]
 #ec["name"] = cons_name
 #ocal_cols, remote_cols = (
 #ec["constrained_columns"],
 #ec["referred_columns"],
 #

 #f not rec["referred_table"]:
 #f resolve_synonyms:
 #
 #ef_remote_name,
 #ef_remote_owner,
 #ef_dblink,
 #ef_synonym,
 # = self._resolve_synonym(
 #onnection,
 #esired_owner=self.denormalize_name(remote_owner),
 #esired_table=self.denormalize_name(remote_table),
 #
 #f ref_synonym:
 #emote_table = self.normalize_name(ref_synonym)
 #emote_owner = self.normalize_name(
 #ef_remote_owner
 #

 #ec["referred_table"] = remote_table

 #f (
 #equested_schema is not None
 #r self.denormalize_name(remote_owner) != schema
 #:
 #ec["referred_schema"] = remote_owner

 #f row[9] != "NO ACTION":
 #ec["options"]["ondelete"] = row[9]

 #ocal_cols.append(local_column)
 #emote_cols.append(remote_column)

 #eturn list(fkeys.values())

 #reflection.cache
 #ef get_unique_constraints(
 #elf, connection, table_name, schema=None, **kw
 #:
 #esolve_synonyms = kw.get("oracle_resolve_synonyms", False)
 #blink = kw.get("dblink", "")
 #nfo_cache = kw.get("info_cache")

 #table_name, schema, dblink, synonym) = self._prepare_reflection_args(
 #onnection,
 #able_name,
 #chema,
 #esolve_synonyms,
 #blink,
 #nfo_cache=info_cache,
 #

 #onstraint_data = self._get_constraint_data(
 #onnection,
 #able_name,
 #chema,
 #blink,
 #nfo_cache=kw.get("info_cache"),
 #

 #nique_keys = filter(lambda x: x[1] == "U", constraint_data)
 #niques_group = groupby(unique_keys, lambda x: x[0])

 #ndex_names = {
 #x["name"]
 #or ix in self.get_indexes(connection, table_name, schema=schema)
 #
 #eturn [
 #
 #name": name,
 #column_names": cols,
 #duplicates_index": name if name in index_names else None,
 #
 #or name, cols in [
 #
 #elf.normalize_name(i[0]),
 #self.normalize_name(x[2]) for x in i[1]],
 #
 #or i in uniques_group
 #
 #

 #reflection.cache
 #ef get_view_definition(
 #elf,
 #onnection,
 #iew_name,
 #chema=None,
 #esolve_synonyms=False,
 #blink="",
 #*kw
 #:
 #nfo_cache = kw.get("info_cache")
 #view_name, schema, dblink, synonym) = self._prepare_reflection_args(
 #onnection,
 #iew_name,
 #chema,
 #esolve_synonyms,
 #blink,
 #nfo_cache=info_cache,
 #

 #arams = {"view_name": view_name}
 #ext = "SELECT text FROM all_views WHERE view_name=:view_name"

 #f schema is not None:
 #ext += " AND owner = :schema"
 #arams["schema"] = schema

 #p = connection.execute(sql.text(text), params).scalar()
 #f rp:
 #f util.py2k:
 #p = rp.decode(self.encoding)
 #eturn rp
 #lse:
 #eturn None

 #reflection.cache
 #ef get_check_constraints(
 #elf, connection, table_name, schema=None, include_all=False, **kw
 #:
 #esolve_synonyms = kw.get("oracle_resolve_synonyms", False)
 #blink = kw.get("dblink", "")
 #nfo_cache = kw.get("info_cache")

 #table_name, schema, dblink, synonym) = self._prepare_reflection_args(
 #onnection,
 #able_name,
 #chema,
 #esolve_synonyms,
 #blink,
 #nfo_cache=info_cache,
 #

 #onstraint_data = self._get_constraint_data(
 #onnection,
 #able_name,
 #chema,
 #blink,
 #nfo_cache=kw.get("info_cache"),
 #

 #heck_constraints = filter(lambda x: x[1] == "C", constraint_data)

 #eturn [
 #"name": self.normalize_name(cons[0]), "sqltext": cons[8]}
 #or cons in check_constraints
 #f include_all or not re.match(r"..+?. IS NOT NULL$", cons[8])
 #


class _OuterJoinColumn(sql.ClauseElement):
 #_visit_name__ = "outer_join_column"

 #ef __init__(self, column):
 #elf.column = column
