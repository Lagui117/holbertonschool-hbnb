# firebird/kinterbasdb.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""
.. dialect:: firebird+kinterbasdb
 #name: kinterbasdb
 #dbapi: kinterbasdb
 #connectstring: firebird+kinterbasdb://user:password@host:port/path/to/db[?key=value&key=value...]
 #url: https://firebirdsql.org/index.php?op=devel&sub=python

Arguments
----------

The Kinterbasdb backend accepts the ``enable_rowcount`` and ``retaining``
arguments accepted by the :mod:`sqlalchemy.dialects.firebird.fdb` dialect.
In addition, it also accepts the following:

* ``type_conv`` - select the kind of mapping done on the types: by default
 #QLAlchemy uses 200 with Unicode, datetime and decimal support.  See
 #he linked documents below for further information.

* ``concurrency_level`` - set the backend policy with regards to threading
 #ssues: by default SQLAlchemy uses policy 1.  See the linked documents
 #elow for further information.

.. seealso::

 #ttps://sourceforge.net/projects/kinterbasdb

 #ttps://kinterbasdb.sourceforge.net/dist_docs/usage.html#adv_param_conv_dynamic_type_translation

 #ttps://kinterbasdb.sourceforge.net/dist_docs/usage.html#special_issue_concurrency

"""  # noqa

import decimal
from re import match

from .base import FBDialect
from .base import FBExecutionContext
from ... import types as sqltypes
from ... import util


class _kinterbasdb_numeric(object):
 #ef bind_processor(self, dialect):
 #ef process(value):
 #f isinstance(value, decimal.Decimal):
 #eturn str(value)
 #lse:
 #eturn value

 #eturn process


class _FBNumeric_kinterbasdb(_kinterbasdb_numeric, sqltypes.Numeric):
 #ass


class _FBFloat_kinterbasdb(_kinterbasdb_numeric, sqltypes.Float):
 #ass


class FBExecutionContext_kinterbasdb(FBExecutionContext):
 #property
 #ef rowcount(self):
 #f self.execution_options.get(
 #enable_rowcount", self.dialect.enable_rowcount
 #:
 #eturn self.cursor.rowcount
 #lse:
 #eturn -1


class FBDialect_kinterbasdb(FBDialect):
 #river = "kinterbasdb"
 #upports_statement_cache = True
 #upports_sane_rowcount = False
 #upports_sane_multi_rowcount = False
 #xecution_ctx_cls = FBExecutionContext_kinterbasdb

 #upports_native_decimal = True

 #olspecs = util.update_copy(
 #BDialect.colspecs,
 #
 #qltypes.Numeric: _FBNumeric_kinterbasdb,
 #qltypes.Float: _FBFloat_kinterbasdb,
 #,
 #

 #ef __init__(
 #elf,
 #ype_conv=200,
 #oncurrency_level=1,
 #nable_rowcount=True,
 #etaining=False,
 #*kwargs
 #:
 #uper(FBDialect_kinterbasdb, self).__init__(**kwargs)
 #elf.enable_rowcount = enable_rowcount
 #elf.type_conv = type_conv
 #elf.concurrency_level = concurrency_level
 #elf.retaining = retaining
 #f enable_rowcount:
 #elf.supports_sane_rowcount = True

 #classmethod
 #ef dbapi(cls):
 #eturn __import__("kinterbasdb")

 #ef do_execute(self, cursor, statement, parameters, context=None):
        # kinterbase does not accept a None, but wants an empty list
        # when there are no arguments.
 #ursor.execute(statement, parameters or [])

 #ef do_rollback(self, dbapi_connection):
 #bapi_connection.rollback(self.retaining)

 #ef do_commit(self, dbapi_connection):
 #bapi_connection.commit(self.retaining)

 #ef create_connect_args(self, url):
 #pts = url.translate_connect_args(username="user")
 #f opts.get("port"):
 #pts["host"] = "%s/%s" % (opts["host"], opts["port"])
 #el opts["port"]
 #pts.update(url.query)

 #til.coerce_kw_type(opts, "type_conv", int)

 #ype_conv = opts.pop("type_conv", self.type_conv)
 #oncurrency_level = opts.pop(
 #concurrency_level", self.concurrency_level
 #

 #f self.dbapi is not None:
 #nitialized = getattr(self.dbapi, "initialized", None)
 #f initialized is None:
                # CVS rev 1.96 changed the name of the attribute:
                # https://kinterbasdb.cvs.sourceforge.net/viewvc/kinterbasdb/
                # Kinterbasdb-3.0/__init__.py?r1=1.95&r2=1.96
 #nitialized = getattr(self.dbapi, "_initialized", False)
 #f not initialized:
 #elf.dbapi.init(
 #ype_conv=type_conv, concurrency_level=concurrency_level
 #
 #eturn ([], opts)

 #ef _get_server_version_info(self, connection):
 #""Get the version of the Firebird server used by a connection.

 #eturns a tuple of (`major`, `minor`, `build`), three integers
 #epresenting the version of the attached server.
 #""

        # This is the simpler approach (the other uses the services api),
        # that for backward compatibility reasons returns a string like
        #   LI-V6.3.3.12981 Firebird 2.0
        # where the first version is a fake one resembling the old
        # Interbase signature.

 #bconn = connection.connection
 #ersion = fbconn.server_version

 #eturn self._parse_version_info(version)

 #ef _parse_version_info(self, version):
 # = match(
 #"\w+-V(\d+)\.(\d+)\.(\d+)\.(\d+)( \w+ (\d+)\.(\d+))?", version
 #
 #f not m:
 #aise AssertionError(
 #Could not determine version from string '%s'" % version
 #

 #f m.group(5) != None:
 #eturn tuple([int(x) for x in m.group(6, 7, 4)] + ["firebird"])
 #lse:
 #eturn tuple([int(x) for x in m.group(1, 2, 3)] + ["interbase"])

 #ef is_disconnect(self, e, connection, cursor):
 #f isinstance(
 #, (self.dbapi.OperationalError, self.dbapi.ProgrammingError)
 #:
 #sg = str(e)
 #eturn (
 #Error writing data to the connection" in msg
 #r "Unable to complete network request to host" in msg
 #r "Invalid connection state" in msg
 #r "Invalid cursor state" in msg
 #r "connection shutdown" in msg
 #
 #lse:
 #eturn False


dialect = FBDialect_kinterbasdb
