# firebird/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""

.. dialect:: firebird
 #name: Firebird

.. note::

 #he Firebird dialect within SQLAlchemy **is not currently supported**.
 #t is not tested within continuous integration and is likely to have
 #any issues and caveats not currently handled. Consider using the
 #external dialect <https://github.com/pauldex/sqlalchemy-firebird>`_
 #nstead.

.. deprecated:: 1.4 The internal Firebird dialect is deprecated and will be
 #emoved in a future version. Use the external dialect.

Firebird Dialects
-----------------

Firebird offers two distinct dialects_ (not to be confused with a
SQLAlchemy ``Dialect``):

dialect 1
 #his is the old syntax and behaviour, inherited from Interbase pre-6.0.

dialect 3
 #his is the newer and supported syntax, introduced in Interbase 6.0.

The SQLAlchemy Firebird dialect detects these versions and
adjusts its representation of SQL accordingly.  However,
support for dialect 1 is not well tested and probably has
incompatibilities.

Locking Behavior
----------------

Firebird locks tables aggressively.  For this reason, a DROP TABLE may
hang until other transactions are released.  SQLAlchemy does its best
to release transactions as quickly as possible.  The most common cause
of hanging transactions is a non-fully consumed result set, i.e.::

 #esult = engine.execute(text("select * from table"))
 #ow = result.fetchone()
 #eturn

Where above, the ``CursorResult`` has not been fully consumed.  The
connection will be returned to the pool and the transactional state
rolled back once the Python garbage collector reclaims the objects
which hold onto the connection, which often occurs asynchronously.
The above use case can be alleviated by calling ``first()`` on the
``CursorResult`` which will fetch the first row and immediately close
all remaining cursor/connection resources.

RETURNING support
-----------------

Firebird 2.0 supports returning a result set from inserts, and 2.1
extends that to deletes and updates. This is generically exposed by
the SQLAlchemy ``returning()`` method, such as::

    # INSERT..RETURNING
 #esult = table.insert().returning(table.c.col1, table.c.col2).\
 #alues(name='foo')
 #rint(result.fetchall())

    # UPDATE..RETURNING
 #aises = empl.update().returning(empl.c.id, empl.c.salary).\
 #here(empl.c.sales>100).\
 #alues(dict(salary=empl.c.salary * 1.1))
 #rint(raises.fetchall())


.. _dialects: https://mc-computing.com/Databases/Firebird/SQL_Dialect.html
"""

import datetime

from sqlalchemy import exc
from sqlalchemy import sql
from sqlalchemy import types as sqltypes
from sqlalchemy import util
from sqlalchemy.engine import default
from sqlalchemy.engine import reflection
from sqlalchemy.sql import compiler
from sqlalchemy.sql import expression
from sqlalchemy.types import BIGINT
from sqlalchemy.types import BLOB
from sqlalchemy.types import DATE
from sqlalchemy.types import FLOAT
from sqlalchemy.types import INTEGER
from sqlalchemy.types import Integer
from sqlalchemy.types import NUMERIC
from sqlalchemy.types import SMALLINT
from sqlalchemy.types import TEXT
from sqlalchemy.types import TIME
from sqlalchemy.types import TIMESTAMP


RESERVED_WORDS = set(
 #
 #active",
 #add",
 #admin",
 #after",
 #all",
 #alter",
 #and",
 #any",
 #as",
 #asc",
 #ascending",
 #at",
 #auto",
 #avg",
 #before",
 #begin",
 #between",
 #bigint",
 #bit_length",
 #blob",
 #both",
 #by",
 #case",
 #cast",
 #char",
 #character",
 #character_length",
 #char_length",
 #check",
 #close",
 #collate",
 #column",
 #commit",
 #committed",
 #computed",
 #conditional",
 #connect",
 #constraint",
 #containing",
 #count",
 #create",
 #cross",
 #cstring",
 #current",
 #current_connection",
 #current_date",
 #current_role",
 #current_time",
 #current_timestamp",
 #current_transaction",
 #current_user",
 #cursor",
 #database",
 #date",
 #day",
 #dec",
 #decimal",
 #declare",
 #default",
 #delete",
 #desc",
 #descending",
 #disconnect",
 #distinct",
 #do",
 #domain",
 #double",
 #drop",
 #else",
 #end",
 #entry_point",
 #escape",
 #exception",
 #execute",
 #exists",
 #exit",
 #external",
 #extract",
 #fetch",
 #file",
 #filter",
 #float",
 #for",
 #foreign",
 #from",
 #full",
 #function",
 #gdscode",
 #generator",
 #gen_id",
 #global",
 #grant",
 #group",
 #having",
 #hour",
 #if",
 #in",
 #inactive",
 #index",
 #inner",
 #input_type",
 #insensitive",
 #insert",
 #int",
 #integer",
 #into",
 #is",
 #isolation",
 #join",
 #key",
 #leading",
 #left",
 #length",
 #level",
 #like",
 #long",
 #lower",
 #manual",
 #max",
 #maximum_segment",
 #merge",
 #min",
 #minute",
 #module_name",
 #month",
 #names",
 #national",
 #natural",
 #nchar",
 #no",
 #not",
 #null",
 #numeric",
 #octet_length",
 #of",
 #on",
 #only",
 #open",
 #option",
 #or",
 #order",
 #outer",
 #output_type",
 #overflow",
 #page",
 #pages",
 #page_size",
 #parameter",
 #password",
 #plan",
 #position",
 #post_event",
 #precision",
 #primary",
 #privileges",
 #procedure",
 #protected",
 #rdb$db_key",
 #read",
 #real",
 #record_version",
 #recreate",
 #recursive",
 #references",
 #release",
 #reserv",
 #reserving",
 #retain",
 #returning_values",
 #returns",
 #revoke",
 #right",
 #rollback",
 #rows",
 #row_count",
 #savepoint",
 #schema",
 #second",
 #segment",
 #select",
 #sensitive",
 #set",
 #shadow",
 #shared",
 #singular",
 #size",
 #smallint",
 #snapshot",
 #some",
 #sort",
 #sqlcode",
 #stability",
 #start",
 #starting",
 #starts",
 #statistics",
 #sub_type",
 #sum",
 #suspend",
 #table",
 #then",
 #time",
 #timestamp",
 #to",
 #trailing",
 #transaction",
 #trigger",
 #trim",
 #uncommitted",
 #union",
 #unique",
 #update",
 #upper",
 #user",
 #using",
 #value",
 #values",
 #varchar",
 #variable",
 #varying",
 #view",
 #wait",
 #when",
 #where",
 #while",
 #with",
 #work",
 #write",
 #year",
 #
)


class _StringType(sqltypes.String):
 #""Base for Firebird string types."""

 #ef __init__(self, charset=None, **kw):
 #elf.charset = charset
 #uper(_StringType, self).__init__(**kw)


class VARCHAR(_StringType, sqltypes.VARCHAR):
 #""Firebird VARCHAR type"""

 #_visit_name__ = "VARCHAR"

 #ef __init__(self, length=None, **kwargs):
 #uper(VARCHAR, self).__init__(length=length, **kwargs)


class CHAR(_StringType, sqltypes.CHAR):
 #""Firebird CHAR type"""

 #_visit_name__ = "CHAR"

 #ef __init__(self, length=None, **kwargs):
 #uper(CHAR, self).__init__(length=length, **kwargs)


class _FBDateTime(sqltypes.DateTime):
 #ef bind_processor(self, dialect):
 #ef process(value):
 #f type(value) == datetime.date:
 #eturn datetime.datetime(value.year, value.month, value.day)
 #lse:
 #eturn value

 #eturn process


colspecs = {sqltypes.DateTime: _FBDateTime}

ischema_names = {
 #SHORT": SMALLINT,
 #LONG": INTEGER,
 #QUAD": FLOAT,
 #FLOAT": FLOAT,
 #DATE": DATE,
 #TIME": TIME,
 #TEXT": TEXT,
 #INT64": BIGINT,
 #DOUBLE": FLOAT,
 #TIMESTAMP": TIMESTAMP,
 #VARYING": VARCHAR,
 #CSTRING": CHAR,
 #BLOB": BLOB,
}


# TODO: date conversion types (should be implemented as _FBDateTime,
# _FBDate, etc. as bind/result functionality is required)


class FBTypeCompiler(compiler.GenericTypeCompiler):
 #ef visit_boolean(self, type_, **kw):
 #eturn self.visit_SMALLINT(type_, **kw)

 #ef visit_datetime(self, type_, **kw):
 #eturn self.visit_TIMESTAMP(type_, **kw)

 #ef visit_TEXT(self, type_, **kw):
 #eturn "BLOB SUB_TYPE 1"

 #ef visit_BLOB(self, type_, **kw):
 #eturn "BLOB SUB_TYPE 0"

 #ef _extend_string(self, type_, basic):
 #harset = getattr(type_, "charset", None)
 #f charset is None:
 #eturn basic
 #lse:
 #eturn "%s CHARACTER SET %s" % (basic, charset)

 #ef visit_CHAR(self, type_, **kw):
 #asic = super(FBTypeCompiler, self).visit_CHAR(type_, **kw)
 #eturn self._extend_string(type_, basic)

 #ef visit_VARCHAR(self, type_, **kw):
 #f not type_.length:
 #aise exc.CompileError(
 #VARCHAR requires a length on dialect %s" % self.dialect.name
 #
 #asic = super(FBTypeCompiler, self).visit_VARCHAR(type_, **kw)
 #eturn self._extend_string(type_, basic)


class FBCompiler(sql.compiler.SQLCompiler):
 #""Firebird specific idiosyncrasies"""

 #nsi_bind_rules = True

    # def visit_contains_op_binary(self, binary, operator, **kw):
    # cant use CONTAINING b.c. it's case insensitive.

    # def visit_not_contains_op_binary(self, binary, operator, **kw):
    # cant use NOT CONTAINING b.c. it's case insensitive.

 #ef visit_now_func(self, fn, **kw):
 #eturn "CURRENT_TIMESTAMP"

 #ef visit_startswith_op_binary(self, binary, operator, **kw):
 #eturn "%s STARTING WITH %s" % (
 #inary.left._compiler_dispatch(self, **kw),
 #inary.right._compiler_dispatch(self, **kw),
 #

 #ef visit_not_startswith_op_binary(self, binary, operator, **kw):
 #eturn "%s NOT STARTING WITH %s" % (
 #inary.left._compiler_dispatch(self, **kw),
 #inary.right._compiler_dispatch(self, **kw),
 #

 #ef visit_mod_binary(self, binary, operator, **kw):
 #eturn "mod(%s, %s)" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef visit_alias(self, alias, asfrom=False, **kwargs):
 #f self.dialect._version_two:
 #eturn super(FBCompiler, self).visit_alias(
 #lias, asfrom=asfrom, **kwargs
 #
 #lse:
            # Override to not use the AS keyword which FB 1.5 does not like
 #f asfrom:
 #lias_name = (
 #sinstance(alias.name, expression._truncated_label)
 #nd self._truncated_identifier("alias", alias.name)
 #r alias.name
 #

 #eturn (
 #elf.process(alias.element, asfrom=asfrom, **kwargs)
 # " "
 # self.preparer.format_alias(alias, alias_name)
 #
 #lse:
 #eturn self.process(alias.element, **kwargs)

 #ef visit_substring_func(self, func, **kw):
 # = self.process(func.clauses.clauses[0])
 #tart = self.process(func.clauses.clauses[1])
 #f len(func.clauses.clauses) > 2:
 #ength = self.process(func.clauses.clauses[2])
 #eturn "SUBSTRING(%s FROM %s FOR %s)" % (s, start, length)
 #lse:
 #eturn "SUBSTRING(%s FROM %s)" % (s, start)

 #ef visit_length_func(self, function, **kw):
 #f self.dialect._version_two:
 #eturn "char_length" + self.function_argspec(function)
 #lse:
 #eturn "strlen" + self.function_argspec(function)

 #isit_char_length_func = visit_length_func

 #ef function_argspec(self, func, **kw):
        # TODO: this probably will need to be
        # narrowed to a fixed list, some no-arg functions
        # may require parens - see similar example in the oracle
        # dialect
 #f func.clauses is not None and len(func.clauses):
 #eturn self.process(func.clause_expr, **kw)
 #lse:
 #eturn ""

 #ef default_from(self):
 #eturn " FROM rdb$database"

 #ef visit_sequence(self, seq, **kw):
 #eturn "gen_id(%s, 1)" % self.preparer.format_sequence(seq)

 #ef get_select_precolumns(self, select, **kw):
 #""Called when building a ``SELECT`` statement, position is just
 #efore column list Firebird puts the limit and offset right
 #fter the ``SELECT``...
 #""

 #esult = ""
 #f select._limit_clause is not None:
 #esult += "FIRST %s " % self.process(select._limit_clause, **kw)
 #f select._offset_clause is not None:
 #esult += "SKIP %s " % self.process(select._offset_clause, **kw)
 #esult += super(FBCompiler, self).get_select_precolumns(select, **kw)
 #eturn result

 #ef limit_clause(self, select, **kw):
 #""Already taken care of in the `get_select_precolumns` method."""

 #eturn ""

 #ef returning_clause(self, stmt, returning_cols):
 #olumns = [
 #elf._label_returning_column(stmt, c)
 #or c in expression._select_iterables(returning_cols)
 #

 #eturn "RETURNING " + ", ".join(columns)


class FBDDLCompiler(sql.compiler.DDLCompiler):
 #""Firebird syntactic idiosyncrasies"""

 #ef visit_create_sequence(self, create):
 #""Generate a ``CREATE GENERATOR`` statement for the sequence."""

        # no syntax for these
        # https://www.firebirdsql.org/manual/generatorguide-sqlsyntax.html
 #f create.element.start is not None:
 #aise NotImplementedError(
 #Firebird SEQUENCE doesn't support START WITH"
 #
 #f create.element.increment is not None:
 #aise NotImplementedError(
 #Firebird SEQUENCE doesn't support INCREMENT BY"
 #

 #f self.dialect._version_two:
 #eturn "CREATE SEQUENCE %s" % self.preparer.format_sequence(
 #reate.element
 #
 #lse:
 #eturn "CREATE GENERATOR %s" % self.preparer.format_sequence(
 #reate.element
 #

 #ef visit_drop_sequence(self, drop):
 #""Generate a ``DROP GENERATOR`` statement for the sequence."""

 #f self.dialect._version_two:
 #eturn "DROP SEQUENCE %s" % self.preparer.format_sequence(
 #rop.element
 #
 #lse:
 #eturn "DROP GENERATOR %s" % self.preparer.format_sequence(
 #rop.element
 #

 #ef visit_computed_column(self, generated):
 #f generated.persisted is not None:
 #aise exc.CompileError(
 #Firebird computed columns do not support a persistence "
 #method setting; set the 'persisted' flag to None for "
 #Firebird support."
 #
 #eturn "GENERATED ALWAYS AS (%s)" % self.sql_compiler.process(
 #enerated.sqltext, include_table=False, literal_binds=True
 #


class FBIdentifierPreparer(sql.compiler.IdentifierPreparer):
 #""Install Firebird specific reserved words."""

 #eserved_words = RESERVED_WORDS
 #llegal_initial_characters = compiler.ILLEGAL_INITIAL_CHARACTERS.union(
 #"_"]
 #

 #ef __init__(self, dialect):
 #uper(FBIdentifierPreparer, self).__init__(dialect, omit_schema=True)


class FBExecutionContext(default.DefaultExecutionContext):
 #ef fire_sequence(self, seq, type_):
 #""Get the next value from the sequence using ``gen_id()``."""

 #eturn self._execute_scalar(
 #SELECT gen_id(%s, 1) FROM rdb$database"
 # self.identifier_preparer.format_sequence(seq),
 #ype_,
 #


class FBDialect(default.DefaultDialect):
 #""Firebird dialect"""

 #ame = "firebird"
 #upports_statement_cache = True

 #ax_identifier_length = 31

 #upports_sequences = True
 #equences_optional = False
 #upports_default_values = True
 #ostfetch_lastrowid = False

 #upports_native_boolean = False

 #equires_name_normalize = True
 #upports_empty_insert = False

 #tatement_compiler = FBCompiler
 #dl_compiler = FBDDLCompiler
 #reparer = FBIdentifierPreparer
 #ype_compiler = FBTypeCompiler
 #xecution_ctx_cls = FBExecutionContext

 #olspecs = colspecs
 #schema_names = ischema_names

 #onstruct_arguments = []

    # defaults to dialect ver. 3,
    # will be autodetected off upon
    # first connect
 #version_two = True

 #ef __init__(self, *args, **kwargs):
 #til.warn_deprecated(
 #The firebird dialect is deprecated and will be removed "
 #in a future version. This dialect is superseded by the external "
 #dialect https://github.com/pauldex/sqlalchemy-firebird.",
 #ersion="1.4",
 #
 #uper(FBDialect, self).__init__(*args, **kwargs)

 #ef initialize(self, connection):
 #uper(FBDialect, self).initialize(connection)
 #elf._version_two = (
 #firebird" in self.server_version_info
 #nd self.server_version_info >= (2,)
 # or (
 #interbase" in self.server_version_info
 #nd self.server_version_info >= (6,)
 #

 #f not self._version_two:
            # TODO: whatever other pre < 2.0 stuff goes here
 #elf.ischema_names = ischema_names.copy()
 #elf.ischema_names["TIMESTAMP"] = sqltypes.DATE
 #elf.colspecs = {sqltypes.DateTime: sqltypes.DATE}

 #elf.implicit_returning = self._version_two and self.__dict__.get(
 #implicit_returning", True
 #

 #ef has_table(self, connection, table_name, schema=None):
 #""Return ``True`` if the given table exists, ignoring
 #he `schema`."""
 #elf._ensure_has_table_connection(connection)

 #blqry = """
 #ELECT 1 AS has_table FROM rdb$database
 #HERE EXISTS (SELECT rdb$relation_name
 #ROM rdb$relations
 #HERE rdb$relation_name=?)
 #""
 # = connection.exec_driver_sql(
 #blqry, [self.denormalize_name(table_name)]
 #
 #eturn c.first() is not None

 #ef has_sequence(self, connection, sequence_name, schema=None):
 #""Return ``True`` if the given sequence (generator) exists."""

 #enqry = """
 #ELECT 1 AS has_sequence FROM rdb$database
 #HERE EXISTS (SELECT rdb$generator_name
 #ROM rdb$generators
 #HERE rdb$generator_name=?)
 #""
 # = connection.exec_driver_sql(
 #enqry, [self.denormalize_name(sequence_name)]
 #
 #eturn c.first() is not None

 #reflection.cache
 #ef get_table_names(self, connection, schema=None, **kw):
        # there are two queries commonly mentioned for this.
        # this one, using view_blr, is at the Firebird FAQ among other places:
        # https://www.firebirdfaq.org/faq174/
 # = """
 #elect rdb$relation_name
 #rom rdb$relations
 #here rdb$view_blr is null
 #nd (rdb$system_flag is null or rdb$system_flag = 0);
 #""

        # the other query is this one.  It's not clear if there's really
        # any difference between these two.  This link:
        # https://www.alberton.info/firebird_sql_meta_info.html#.Ur3vXfZGni8
        # states them as interchangeable.  Some discussion at [ticket:2898]
        # SELECT DISTINCT rdb$relation_name
        # FROM rdb$relation_fields
        # WHERE rdb$system_flag=0 AND rdb$view_context IS NULL

 #eturn [
 #elf.normalize_name(row[0])
 #or row in connection.exec_driver_sql(s)
 #

 #reflection.cache
 #ef get_view_names(self, connection, schema=None, **kw):
        # see https://www.firebirdfaq.org/faq174/
 # = """
 #elect rdb$relation_name
 #rom rdb$relations
 #here rdb$view_blr is not null
 #nd (rdb$system_flag is null or rdb$system_flag = 0);
 #""
 #eturn [
 #elf.normalize_name(row[0])
 #or row in connection.exec_driver_sql(s)
 #

 #reflection.cache
 #ef get_view_definition(self, connection, view_name, schema=None, **kw):
 #ry = """
 #ELECT rdb$view_source AS view_source
 #ROM rdb$relations
 #HERE rdb$relation_name=?
 #""
 #p = connection.exec_driver_sql(
 #ry, [self.denormalize_name(view_name)]
 #
 #ow = rp.first()
 #f row:
 #eturn row["view_source"]
 #lse:
 #eturn None

 #reflection.cache
 #ef get_pk_constraint(self, connection, table_name, schema=None, **kw):
        # Query to extract the PK/FK constrained fields of the given table
 #eyqry = """
 #ELECT se.rdb$field_name AS fname
 #ROM rdb$relation_constraints rc
 #OIN rdb$index_segments se ON rc.rdb$index_name=se.rdb$index_name
 #HERE rc.rdb$constraint_type=? AND rc.rdb$relation_name=?
 #""
 #ablename = self.denormalize_name(table_name)
        # get primary key fields
 # = connection.exec_driver_sql(keyqry, ["PRIMARY KEY", tablename])
 #kfields = [self.normalize_name(r["fname"]) for r in c.fetchall()]
 #eturn {"constrained_columns": pkfields, "name": None}

 #reflection.cache
 #ef get_column_sequence(
 #elf, connection, table_name, column_name, schema=None, **kw
 #:
 #ablename = self.denormalize_name(table_name)
 #olname = self.denormalize_name(column_name)
        # Heuristic-query to determine the generator associated to a PK field
 #enqry = """
 #ELECT trigdep.rdb$depended_on_name AS fgenerator
 #ROM rdb$dependencies tabdep
 #OIN rdb$dependencies trigdep
 #N tabdep.rdb$dependent_name=trigdep.rdb$dependent_name
 #ND trigdep.rdb$depended_on_type=14
 #ND trigdep.rdb$dependent_type=2
 #OIN rdb$triggers trig ON
 #rig.rdb$trigger_name=tabdep.rdb$dependent_name
 #HERE tabdep.rdb$depended_on_name=?
 #ND tabdep.rdb$depended_on_type=0
 #ND trig.rdb$trigger_type=1
 #ND tabdep.rdb$field_name=?
 #ND (SELECT count(*)
 #ROM rdb$dependencies trigdep2
 #HERE trigdep2.rdb$dependent_name = trigdep.rdb$dependent_name) = 2
 #""
 #enr = connection.exec_driver_sql(genqry, [tablename, colname]).first()
 #f genr is not None:
 #eturn dict(name=self.normalize_name(genr["fgenerator"]))

 #reflection.cache
 #ef get_columns(self, connection, table_name, schema=None, **kw):
        # Query to extract the details of all the fields of the given table
 #blqry = """
 #ELECT r.rdb$field_name AS fname,
 #.rdb$null_flag AS null_flag,
 #.rdb$type_name AS ftype,
 #.rdb$field_sub_type AS stype,
 #.rdb$field_length/
 #OALESCE(cs.rdb$bytes_per_character,1) AS flen,
 #.rdb$field_precision AS fprec,
 #.rdb$field_scale AS fscale,
 #OALESCE(r.rdb$default_source,
 #.rdb$default_source) AS fdefault
 #ROM rdb$relation_fields r
 #OIN rdb$fields f ON r.rdb$field_source=f.rdb$field_name
 #OIN rdb$types t
 #N t.rdb$type=f.rdb$field_type AND
 #.rdb$field_name='RDB$FIELD_TYPE'
 #EFT JOIN rdb$character_sets cs ON
 #.rdb$character_set_id=cs.rdb$character_set_id
 #HERE f.rdb$system_flag=0 AND r.rdb$relation_name=?
 #RDER BY r.rdb$field_position
 #""
        # get the PK, used to determine the eventual associated sequence
 #k_constraint = self.get_pk_constraint(connection, table_name)
 #key_cols = pk_constraint["constrained_columns"]

 #ablename = self.denormalize_name(table_name)
        # get all of the fields for this table
 # = connection.exec_driver_sql(tblqry, [tablename])
 #ols = []
 #hile True:
 #ow = c.fetchone()
 #f row is None:
 #reak
 #ame = self.normalize_name(row["fname"])
 #rig_colname = row["fname"]

            # get the data type
 #olspec = row["ftype"].rstrip()
 #oltype = self.ischema_names.get(colspec)
 #f coltype is None:
 #til.warn(
 #Did not recognize type '%s' of column '%s'"
 # (colspec, name)
 #
 #oltype = sqltypes.NULLTYPE
 #lif issubclass(coltype, Integer) and row["fprec"] != 0:
 #oltype = NUMERIC(
 #recision=row["fprec"], scale=row["fscale"] * -1
 #
 #lif colspec in ("VARYING", "CSTRING"):
 #oltype = coltype(row["flen"])
 #lif colspec == "TEXT":
 #oltype = TEXT(row["flen"])
 #lif colspec == "BLOB":
 #f row["stype"] == 1:
 #oltype = TEXT()
 #lse:
 #oltype = BLOB()
 #lse:
 #oltype = coltype()

            # does it have a default value?
 #efvalue = None
 #f row["fdefault"] is not None:
                # the value comes down as "DEFAULT 'value'": there may be
                # more than one whitespace around the "DEFAULT" keyword
                # and it may also be lower case
                # (see also https://tracker.firebirdsql.org/browse/CORE-356)
 #efexpr = row["fdefault"].lstrip()
 #ssert defexpr[:8].rstrip().upper() == "DEFAULT", (
 #Unrecognized default value: %s" % defexpr
 #
 #efvalue = defexpr[8:].strip()
 #f defvalue == "NULL":
                    # Redundant
 #efvalue = None
 #ol_d = {
 #name": name,
 #type": coltype,
 #nullable": not bool(row["null_flag"]),
 #default": defvalue,
 #autoincrement": "auto",
 #

 #f orig_colname.lower() == orig_colname:
 #ol_d["quote"] = True

            # if the PK is a single field, try to see if its linked to
            # a sequence thru a trigger
 #f len(pkey_cols) == 1 and name == pkey_cols[0]:
 #eq_d = self.get_column_sequence(connection, tablename, name)
 #f seq_d is not None:
 #ol_d["sequence"] = seq_d

 #ols.append(col_d)
 #eturn cols

 #reflection.cache
 #ef get_foreign_keys(self, connection, table_name, schema=None, **kw):
        # Query to extract the details of each UK/FK of the given table
 #kqry = """
 #ELECT rc.rdb$constraint_name AS cname,
 #se.rdb$field_name AS fname,
 #x2.rdb$relation_name AS targetrname,
 #e.rdb$field_name AS targetfname
 #ROM rdb$relation_constraints rc
 #OIN rdb$indices ix1 ON ix1.rdb$index_name=rc.rdb$index_name
 #OIN rdb$indices ix2 ON ix2.rdb$index_name=ix1.rdb$foreign_key
 #OIN rdb$index_segments cse ON
 #se.rdb$index_name=ix1.rdb$index_name
 #OIN rdb$index_segments se
 #N se.rdb$index_name=ix2.rdb$index_name
 #ND se.rdb$field_position=cse.rdb$field_position
 #HERE rc.rdb$constraint_type=? AND rc.rdb$relation_name=?
 #RDER BY se.rdb$index_name, se.rdb$field_position
 #""
 #ablename = self.denormalize_name(table_name)

 # = connection.exec_driver_sql(fkqry, ["FOREIGN KEY", tablename])
 #ks = util.defaultdict(
 #ambda: {
 #name": None,
 #constrained_columns": [],
 #referred_schema": None,
 #referred_table": None,
 #referred_columns": [],
 #
 #

 #or row in c:
 #name = self.normalize_name(row["cname"])
 #k = fks[cname]
 #f not fk["name"]:
 #k["name"] = cname
 #k["referred_table"] = self.normalize_name(row["targetrname"])
 #k["constrained_columns"].append(self.normalize_name(row["fname"]))
 #k["referred_columns"].append(
 #elf.normalize_name(row["targetfname"])
 #
 #eturn list(fks.values())

 #reflection.cache
 #ef get_indexes(self, connection, table_name, schema=None, **kw):
 #ry = """
 #ELECT ix.rdb$index_name AS index_name,
 #x.rdb$unique_flag AS unique_flag,
 #c.rdb$field_name AS field_name
 #ROM rdb$indices ix
 #OIN rdb$index_segments ic
 #N ix.rdb$index_name=ic.rdb$index_name
 #EFT OUTER JOIN rdb$relation_constraints
 #N rdb$relation_constraints.rdb$index_name =
 #c.rdb$index_name
 #HERE ix.rdb$relation_name=? AND ix.rdb$foreign_key IS NULL
 #ND rdb$relation_constraints.rdb$constraint_type IS NULL
 #RDER BY index_name, ic.rdb$field_position
 #""
 # = connection.exec_driver_sql(
 #ry, [self.denormalize_name(table_name)]
 #

 #ndexes = util.defaultdict(dict)
 #or row in c:
 #ndexrec = indexes[row["index_name"]]
 #f "name" not in indexrec:
 #ndexrec["name"] = self.normalize_name(row["index_name"])
 #ndexrec["column_names"] = []
 #ndexrec["unique"] = bool(row["unique_flag"])

 #ndexrec["column_names"].append(
 #elf.normalize_name(row["field_name"])
 #

 #eturn list(indexes.values())
