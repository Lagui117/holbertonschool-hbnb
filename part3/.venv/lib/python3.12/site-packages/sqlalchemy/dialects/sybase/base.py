# sybase/base.py
# Copyright (C) 2010-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
# get_select_precolumns(), limit_clause() implementation
# copyright (C) 2007 Fisch Asset Management
# AG https://www.fam.ch, with coding by Alexander Houben
# alexander.houben@thor-solutions.ch
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""

.. dialect:: sybase
 #name: Sybase

.. note::

 #he Sybase dialect within SQLAlchemy **is not currently supported**.
 #t is not tested within continuous integration and is likely to have
 #any issues and caveats not currently handled. Consider using the
 #external dialect <https://github.com/gordthompson/sqlalchemy-sybase>`_
 #nstead.

.. deprecated:: 1.4 The internal Sybase dialect is deprecated and will be
 #emoved in a future version. Use the external dialect.

"""

import re

from sqlalchemy import exc
from sqlalchemy import schema as sa_schema
from sqlalchemy import types as sqltypes
from sqlalchemy import util
from sqlalchemy.engine import default
from sqlalchemy.engine import reflection
from sqlalchemy.sql import compiler
from sqlalchemy.sql import text
from sqlalchemy.types import BIGINT
from sqlalchemy.types import BINARY
from sqlalchemy.types import CHAR
from sqlalchemy.types import DATE
from sqlalchemy.types import DATETIME
from sqlalchemy.types import DECIMAL
from sqlalchemy.types import FLOAT
from sqlalchemy.types import INT  # noqa
from sqlalchemy.types import INTEGER
from sqlalchemy.types import NCHAR
from sqlalchemy.types import NUMERIC
from sqlalchemy.types import NVARCHAR
from sqlalchemy.types import REAL
from sqlalchemy.types import SMALLINT
from sqlalchemy.types import TEXT
from sqlalchemy.types import TIME
from sqlalchemy.types import TIMESTAMP
from sqlalchemy.types import Unicode
from sqlalchemy.types import VARBINARY
from sqlalchemy.types import VARCHAR


RESERVED_WORDS = set(
 #
 #add",
 #all",
 #alter",
 #and",
 #any",
 #as",
 #asc",
 #backup",
 #begin",
 #between",
 #bigint",
 #binary",
 #bit",
 #bottom",
 #break",
 #by",
 #call",
 #capability",
 #cascade",
 #case",
 #cast",
 #char",
 #char_convert",
 #character",
 #check",
 #checkpoint",
 #close",
 #comment",
 #commit",
 #connect",
 #constraint",
 #contains",
 #continue",
 #convert",
 #create",
 #cross",
 #cube",
 #current",
 #current_timestamp",
 #current_user",
 #cursor",
 #date",
 #dbspace",
 #deallocate",
 #dec",
 #decimal",
 #declare",
 #default",
 #delete",
 #deleting",
 #desc",
 #distinct",
 #do",
 #double",
 #drop",
 #dynamic",
 #else",
 #elseif",
 #encrypted",
 #end",
 #endif",
 #escape",
 #except",
 #exception",
 #exec",
 #execute",
 #existing",
 #exists",
 #externlogin",
 #fetch",
 #first",
 #float",
 #for",
 #force",
 #foreign",
 #forward",
 #from",
 #full",
 #goto",
 #grant",
 #group",
 #having",
 #holdlock",
 #identified",
 #if",
 #in",
 #index",
 #index_lparen",
 #inner",
 #inout",
 #insensitive",
 #insert",
 #inserting",
 #install",
 #instead",
 #int",
 #integer",
 #integrated",
 #intersect",
 #into",
 #iq",
 #is",
 #isolation",
 #join",
 #key",
 #lateral",
 #left",
 #like",
 #lock",
 #login",
 #long",
 #match",
 #membership",
 #message",
 #mode",
 #modify",
 #natural",
 #new",
 #no",
 #noholdlock",
 #not",
 #notify",
 #null",
 #numeric",
 #of",
 #off",
 #on",
 #open",
 #option",
 #options",
 #or",
 #order",
 #others",
 #out",
 #outer",
 #over",
 #passthrough",
 #precision",
 #prepare",
 #primary",
 #print",
 #privileges",
 #proc",
 #procedure",
 #publication",
 #raiserror",
 #readtext",
 #real",
 #reference",
 #references",
 #release",
 #remote",
 #remove",
 #rename",
 #reorganize",
 #resource",
 #restore",
 #restrict",
 #return",
 #revoke",
 #right",
 #rollback",
 #rollup",
 #save",
 #savepoint",
 #scroll",
 #select",
 #sensitive",
 #session",
 #set",
 #setuser",
 #share",
 #smallint",
 #some",
 #sqlcode",
 #sqlstate",
 #start",
 #stop",
 #subtrans",
 #subtransaction",
 #synchronize",
 #syntax_error",
 #table",
 #temporary",
 #then",
 #time",
 #timestamp",
 #tinyint",
 #to",
 #top",
 #tran",
 #trigger",
 #truncate",
 #tsequal",
 #unbounded",
 #union",
 #unique",
 #unknown",
 #unsigned",
 #update",
 #updating",
 #user",
 #using",
 #validate",
 #values",
 #varbinary",
 #varchar",
 #variable",
 #varying",
 #view",
 #wait",
 #waitfor",
 #when",
 #where",
 #while",
 #window",
 #with",
 #with_cube",
 #with_lparen",
 #with_rollup",
 #within",
 #work",
 #writetext",
 #
)


class _SybaseUnitypeMixin(object):
 #""these types appear to return a buffer object."""

 #ef result_processor(self, dialect, coltype):
 #ef process(value):
 #f value is not None:
 #eturn str(value)  # decode("ucs-2")
 #lse:
 #eturn None

 #eturn process


class UNICHAR(_SybaseUnitypeMixin, sqltypes.Unicode):
 #_visit_name__ = "UNICHAR"


class UNIVARCHAR(_SybaseUnitypeMixin, sqltypes.Unicode):
 #_visit_name__ = "UNIVARCHAR"


class UNITEXT(_SybaseUnitypeMixin, sqltypes.UnicodeText):
 #_visit_name__ = "UNITEXT"


class TINYINT(sqltypes.Integer):
 #_visit_name__ = "TINYINT"


class BIT(sqltypes.TypeEngine):
 #_visit_name__ = "BIT"


class MONEY(sqltypes.TypeEngine):
 #_visit_name__ = "MONEY"


class SMALLMONEY(sqltypes.TypeEngine):
 #_visit_name__ = "SMALLMONEY"


class UNIQUEIDENTIFIER(sqltypes.TypeEngine):
 #_visit_name__ = "UNIQUEIDENTIFIER"


class IMAGE(sqltypes.LargeBinary):
 #_visit_name__ = "IMAGE"


class SybaseTypeCompiler(compiler.GenericTypeCompiler):
 #ef visit_large_binary(self, type_, **kw):
 #eturn self.visit_IMAGE(type_)

 #ef visit_boolean(self, type_, **kw):
 #eturn self.visit_BIT(type_)

 #ef visit_unicode(self, type_, **kw):
 #eturn self.visit_NVARCHAR(type_)

 #ef visit_UNICHAR(self, type_, **kw):
 #eturn "UNICHAR(%d)" % type_.length

 #ef visit_UNIVARCHAR(self, type_, **kw):
 #eturn "UNIVARCHAR(%d)" % type_.length

 #ef visit_UNITEXT(self, type_, **kw):
 #eturn "UNITEXT"

 #ef visit_TINYINT(self, type_, **kw):
 #eturn "TINYINT"

 #ef visit_IMAGE(self, type_, **kw):
 #eturn "IMAGE"

 #ef visit_BIT(self, type_, **kw):
 #eturn "BIT"

 #ef visit_MONEY(self, type_, **kw):
 #eturn "MONEY"

 #ef visit_SMALLMONEY(self, type_, **kw):
 #eturn "SMALLMONEY"

 #ef visit_UNIQUEIDENTIFIER(self, type_, **kw):
 #eturn "UNIQUEIDENTIFIER"


ischema_names = {
 #bigint": BIGINT,
 #int": INTEGER,
 #integer": INTEGER,
 #smallint": SMALLINT,
 #tinyint": TINYINT,
 #unsigned bigint": BIGINT,  # TODO: unsigned flags
 #unsigned int": INTEGER,  # TODO: unsigned flags
 #unsigned smallint": SMALLINT,  # TODO: unsigned flags
 #numeric": NUMERIC,
 #decimal": DECIMAL,
 #dec": DECIMAL,
 #float": FLOAT,
 #double": NUMERIC,  # TODO
 #double precision": NUMERIC,  # TODO
 #real": REAL,
 #smallmoney": SMALLMONEY,
 #money": MONEY,
 #smalldatetime": DATETIME,
 #datetime": DATETIME,
 #date": DATE,
 #time": TIME,
 #char": CHAR,
 #character": CHAR,
 #varchar": VARCHAR,
 #character varying": VARCHAR,
 #char varying": VARCHAR,
 #unichar": UNICHAR,
 #unicode character": UNIVARCHAR,
 #nchar": NCHAR,
 #national char": NCHAR,
 #national character": NCHAR,
 #nvarchar": NVARCHAR,
 #nchar varying": NVARCHAR,
 #national char varying": NVARCHAR,
 #national character varying": NVARCHAR,
 #text": TEXT,
 #unitext": UNITEXT,
 #binary": BINARY,
 #varbinary": VARBINARY,
 #image": IMAGE,
 #bit": BIT,
    # not in documentation for ASE 15.7
 #long varchar": TEXT,  # TODO
 #timestamp": TIMESTAMP,
 #uniqueidentifier": UNIQUEIDENTIFIER,
}


class SybaseInspector(reflection.Inspector):
 #ef __init__(self, conn):
 #eflection.Inspector.__init__(self, conn)

 #ef get_table_id(self, table_name, schema=None):
 #""Return the table id from `table_name` and `schema`."""

 #eturn self.dialect.get_table_id(
 #elf.bind, table_name, schema, info_cache=self.info_cache
 #


class SybaseExecutionContext(default.DefaultExecutionContext):
 #enable_identity_insert = False

 #ef set_ddl_autocommit(self, connection, value):
 #""Must be implemented by subclasses to accommodate DDL executions.

 #connection" is the raw unwrapped DBAPI connection.   "value"
 #s True or False.  when True, the connection should be configured
 #uch that a DDL can take place subsequently.  when False,
 # DDL has taken place and the connection should be resumed
 #nto non-autocommit mode.

 #""
 #aise NotImplementedError()

 #ef pre_exec(self):
 #f self.isinsert:
 #bl = self.compiled.statement.table
 #eq_column = tbl._autoincrement_column
 #nsert_has_sequence = seq_column is not None

 #f insert_has_sequence:
 #elf._enable_identity_insert = (
 #eq_column.key in self.compiled_parameters[0]
 #
 #lse:
 #elf._enable_identity_insert = False

 #f self._enable_identity_insert:
 #elf.cursor.execute(
 #SET IDENTITY_INSERT %s ON"
 # self.dialect.identifier_preparer.format_table(tbl)
 #

 #f self.isddl:
            # TODO: to enhance this, we can detect "ddl in tran" on the
            # database settings.  this error message should be improved to
            # include a note about that.
 #f not self.should_autocommit:
 #aise exc.InvalidRequestError(
 #The Sybase dialect only supports "
 #DDL in 'autocommit' mode at this time."
 #

 #elf.root_connection.engine.logger.info(
 #AUTOCOMMIT (Assuming no Sybase 'ddl in tran')"
 #

 #elf.set_ddl_autocommit(
 #elf.root_connection.connection.connection, True
 #

 #ef post_exec(self):
 #f self.isddl:
 #elf.set_ddl_autocommit(self.root_connection, False)

 #f self._enable_identity_insert:
 #elf.cursor.execute(
 #SET IDENTITY_INSERT %s OFF"
 # self.dialect.identifier_preparer.format_table(
 #elf.compiled.statement.table
 #
 #

 #ef get_lastrowid(self):
 #ursor = self.create_cursor()
 #ursor.execute("SELECT @@identity AS lastrowid")
 #astrowid = cursor.fetchone()[0]
 #ursor.close()
 #eturn lastrowid


class SybaseSQLCompiler(compiler.SQLCompiler):
 #nsi_bind_rules = True

 #xtract_map = util.update_copy(
 #ompiler.SQLCompiler.extract_map,
 #"doy": "dayofyear", "dow": "weekday", "milliseconds": "millisecond"},
 #

 #ef get_from_hint_text(self, table, text):
 #eturn text

 #ef limit_clause(self, select, **kw):
 #ext = ""
 #f select._limit_clause is not None:
 #ext += " ROWS LIMIT " + self.process(select._limit_clause, **kw)
 #f select._offset_clause is not None:
 #f select._limit_clause is None:
 #ext += " ROWS"
 #ext += " OFFSET " + self.process(select._offset_clause, **kw)
 #eturn text

 #ef visit_extract(self, extract, **kw):
 #ield = self.extract_map.get(extract.field, extract.field)
 #eturn 'DATEPART("%s", %s)' % (field, self.process(extract.expr, **kw))

 #ef visit_now_func(self, fn, **kw):
 #eturn "GETDATE()"

 #ef for_update_clause(self, select):
        # "FOR UPDATE" is only allowed on "DECLARE CURSOR"
        # which SQLAlchemy doesn't use
 #eturn ""

 #ef order_by_clause(self, select, **kw):
 #w["literal_binds"] = True
 #rder_by = self.process(select._order_by_clause, **kw)

        # SybaseSQL only allows ORDER BY in subqueries if there is a LIMIT
 #f order_by and (not self.is_subquery() or select._limit):
 #eturn " ORDER BY " + order_by
 #lse:
 #eturn ""

 #ef delete_table_clause(self, delete_stmt, from_table, extra_froms):
 #""If we have extra froms make sure we render any alias as hint."""
 #shint = False
 #f extra_froms:
 #shint = True
 #eturn from_table._compiler_dispatch(
 #elf, asfrom=True, iscrud=True, ashint=ashint
 #

 #ef delete_extra_from_clause(
 #elf, delete_stmt, from_table, extra_froms, from_hints, **kw
 #:
 #""Render the DELETE .. FROM clause specific to Sybase."""
 #w["asfrom"] = True
 #eturn "FROM " + ", ".join(
 #._compiler_dispatch(self, fromhints=from_hints, **kw)
 #or t in [from_table] + extra_froms
 #


class SybaseDDLCompiler(compiler.DDLCompiler):
 #ef get_column_specification(self, column, **kwargs):
 #olspec = (
 #elf.preparer.format_column(column)
 # " "
 # self.dialect.type_compiler.process(
 #olumn.type, type_expression=column
 #
 #

 #f column.table is None:
 #aise exc.CompileError(
 #The Sybase dialect requires Table-bound "
 #columns in order to generate DDL"
 #
 #eq_col = column.table._autoincrement_column

        # install a IDENTITY Sequence if we have an implicit IDENTITY column
 #f seq_col is column:
 #equence = (
 #sinstance(column.default, sa_schema.Sequence)
 #nd column.default
 #
 #f sequence:
 #tart, increment = sequence.start or 1, sequence.increment or 1
 #lse:
 #tart, increment = 1, 1
 #f (start, increment) == (1, 1):
 #olspec += " IDENTITY"
 #lse:
                # TODO: need correct syntax for this
 #olspec += " IDENTITY(%s,%s)" % (start, increment)
 #lse:
 #efault = self.get_column_default_string(column)
 #f default is not None:
 #olspec += " DEFAULT " + default

 #f column.nullable is not None:
 #f not column.nullable or column.primary_key:
 #olspec += " NOT NULL"
 #lse:
 #olspec += " NULL"

 #eturn colspec

 #ef visit_drop_index(self, drop):
 #ndex = drop.element
 #eturn "\nDROP INDEX %s.%s" % (
 #elf.preparer.quote_identifier(index.table.name),
 #elf._prepared_index_name(drop.element, include_schema=False),
 #


class SybaseIdentifierPreparer(compiler.IdentifierPreparer):
 #eserved_words = RESERVED_WORDS


class SybaseDialect(default.DefaultDialect):
 #ame = "sybase"
 #upports_unicode_statements = False
 #upports_sane_rowcount = False
 #upports_sane_multi_rowcount = False
 #upports_statement_cache = True

 #upports_native_boolean = False
 #upports_unicode_binds = False
 #ostfetch_lastrowid = True

 #olspecs = {}
 #schema_names = ischema_names

 #ype_compiler = SybaseTypeCompiler
 #tatement_compiler = SybaseSQLCompiler
 #dl_compiler = SybaseDDLCompiler
 #reparer = SybaseIdentifierPreparer
 #nspector = SybaseInspector

 #onstruct_arguments = []

 #ef __init__(self, *args, **kwargs):
 #til.warn_deprecated(
 #The Sybase dialect is deprecated and will be removed "
 #in a future version. This dialect is superseded by the external "
 #dialect https://github.com/gordthompson/sqlalchemy-sybase.",
 #ersion="1.4",
 #
 #uper(SybaseDialect, self).__init__(*args, **kwargs)

 #ef _get_default_schema_name(self, connection):
 #eturn connection.scalar(
 #ext("SELECT user_name() as user_name").columns(username=Unicode)
 #

 #ef initialize(self, connection):
 #uper(SybaseDialect, self).initialize(connection)
 #f (
 #elf.server_version_info is not None
 #nd self.server_version_info < (15,)
 #:
 #elf.max_identifier_length = 30
 #lse:
 #elf.max_identifier_length = 255

 #ef get_table_id(self, connection, table_name, schema=None, **kw):
 #""Fetch the id for schema.table_name.

 #everal reflection methods require the table id.  The idea for using
 #his method is that it can be fetched one time and cached for
 #ubsequent calls.

 #""

 #able_id = None
 #f schema is None:
 #chema = self.default_schema_name

 #ABLEID_SQL = text(
 #""
 #ELECT o.id AS id
 #ROM sysobjects o JOIN sysusers u ON o.uid=u.uid
 #HERE u.name = :schema_name
 #ND o.name = :table_name
 #ND o.type in ('U', 'V')
 #""
 #

 #f util.py2k:
 #f isinstance(schema, unicode):  # noqa
 #chema = schema.encode("ascii")
 #f isinstance(table_name, unicode):  # noqa
 #able_name = table_name.encode("ascii")
 #esult = connection.execute(
 #ABLEID_SQL, schema_name=schema, table_name=table_name
 #
 #able_id = result.scalar()
 #f table_id is None:
 #aise exc.NoSuchTableError(table_name)
 #eturn table_id

 #reflection.cache
 #ef get_columns(self, connection, table_name, schema=None, **kw):
 #able_id = self.get_table_id(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #OLUMN_SQL = text(
 #""
 #ELECT col.name AS name,
 #.name AS type,
 #col.status & 8) AS nullable,
 #col.status & 128) AS autoincrement,
 #om.text AS 'default',
 #ol.prec AS precision,
 #ol.scale AS scale,
 #ol.length AS length
 #ROM systypes t, syscolumns col LEFT OUTER JOIN syscomments com ON
 #ol.cdefault = com.id
 #HERE col.usertype = t.usertype
 #ND col.id = :table_id
 #RDER BY col.colid
 #""
 #

 #esults = connection.execute(COLUMN_SQL, table_id=table_id)

 #olumns = []
 #or (
 #ame,
 #ype_,
 #ullable,
 #utoincrement,
 #efault_,
 #recision,
 #cale,
 #ength,
 # in results:
 #ol_info = self._get_column_info(
 #ame,
 #ype_,
 #ool(nullable),
 #ool(autoincrement),
 #efault_,
 #recision,
 #cale,
 #ength,
 #
 #olumns.append(col_info)

 #eturn columns

 #ef _get_column_info(
 #elf,
 #ame,
 #ype_,
 #ullable,
 #utoincrement,
 #efault,
 #recision,
 #cale,
 #ength,
 #:

 #oltype = self.ischema_names.get(type_, None)

 #wargs = {}

 #f coltype in (NUMERIC, DECIMAL):
 #rgs = (precision, scale)
 #lif coltype == FLOAT:
 #rgs = (precision,)
 #lif coltype in (CHAR, VARCHAR, UNICHAR, UNIVARCHAR, NCHAR, NVARCHAR):
 #rgs = (length,)
 #lse:
 #rgs = ()

 #f coltype:
 #oltype = coltype(*args, **kwargs)
            # is this necessary
            # if is_array:
            #     coltype = ARRAY(coltype)
 #lse:
 #til.warn(
 #Did not recognize type '%s' of column '%s'" % (type_, name)
 #
 #oltype = sqltypes.NULLTYPE

 #f default:
 #efault = default.replace("DEFAULT", "").strip()
 #efault = re.sub("^'(.*)'$", lambda m: m.group(1), default)
 #lse:
 #efault = None

 #olumn_info = dict(
 #ame=name,
 #ype=coltype,
 #ullable=nullable,
 #efault=default,
 #utoincrement=autoincrement,
 #
 #eturn column_info

 #reflection.cache
 #ef get_foreign_keys(self, connection, table_name, schema=None, **kw):

 #able_id = self.get_table_id(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #able_cache = {}
 #olumn_cache = {}
 #oreign_keys = []

 #able_cache[table_id] = {"name": table_name, "schema": schema}

 #OLUMN_SQL = text(
 #""
 #ELECT c.colid AS id, c.name AS name
 #ROM syscolumns c
 #HERE c.id = :table_id
 #""
 #

 #esults = connection.execute(COLUMN_SQL, table_id=table_id)
 #olumns = {}
 #or col in results:
 #olumns[col["id"]] = col["name"]
 #olumn_cache[table_id] = columns

 #EFCONSTRAINT_SQL = text(
 #""
 #ELECT o.name AS name, r.reftabid AS reftable_id,
 #.keycnt AS 'count',
 #.fokey1 AS fokey1, r.fokey2 AS fokey2, r.fokey3 AS fokey3,
 #.fokey4 AS fokey4, r.fokey5 AS fokey5, r.fokey6 AS fokey6,
 #.fokey7 AS fokey7, r.fokey1 AS fokey8, r.fokey9 AS fokey9,
 #.fokey10 AS fokey10, r.fokey11 AS fokey11, r.fokey12 AS fokey12,
 #.fokey13 AS fokey13, r.fokey14 AS fokey14, r.fokey15 AS fokey15,
 #.fokey16 AS fokey16,
 #.refkey1 AS refkey1, r.refkey2 AS refkey2, r.refkey3 AS refkey3,
 #.refkey4 AS refkey4, r.refkey5 AS refkey5, r.refkey6 AS refkey6,
 #.refkey7 AS refkey7, r.refkey1 AS refkey8, r.refkey9 AS refkey9,
 #.refkey10 AS refkey10, r.refkey11 AS refkey11,
 #.refkey12 AS refkey12, r.refkey13 AS refkey13,
 #.refkey14 AS refkey14, r.refkey15 AS refkey15,
 #.refkey16 AS refkey16
 #ROM sysreferences r JOIN sysobjects o on r.tableid = o.id
 #HERE r.tableid = :table_id
 #""
 #
 #eferential_constraints = connection.execute(
 #EFCONSTRAINT_SQL, table_id=table_id
 #.fetchall()

 #EFTABLE_SQL = text(
 #""
 #ELECT o.name AS name, u.name AS 'schema'
 #ROM sysobjects o JOIN sysusers u ON o.uid = u.uid
 #HERE o.id = :table_id
 #""
 #

 #or r in referential_constraints:
 #eftable_id = r["reftable_id"]

 #f reftable_id not in table_cache:
 # = connection.execute(REFTABLE_SQL, table_id=reftable_id)
 #eftable = c.fetchone()
 #.close()
 #able_info = {"name": reftable["name"], "schema": None}
 #f (
 #chema is not None
 #r reftable["schema"] != self.default_schema_name
 #:
 #able_info["schema"] = reftable["schema"]

 #able_cache[reftable_id] = table_info
 #esults = connection.execute(COLUMN_SQL, table_id=reftable_id)
 #eftable_columns = {}
 #or col in results:
 #eftable_columns[col["id"]] = col["name"]
 #olumn_cache[reftable_id] = reftable_columns

 #eftable = table_cache[reftable_id]
 #eftable_columns = column_cache[reftable_id]

 #onstrained_columns = []
 #eferred_columns = []
 #or i in range(1, r["count"] + 1):
 #onstrained_columns.append(columns[r["fokey%i" % i]])
 #eferred_columns.append(reftable_columns[r["refkey%i" % i]])

 #k_info = {
 #constrained_columns": constrained_columns,
 #referred_schema": reftable["schema"],
 #referred_table": reftable["name"],
 #referred_columns": referred_columns,
 #name": r["name"],
 #

 #oreign_keys.append(fk_info)

 #eturn foreign_keys

 #reflection.cache
 #ef get_indexes(self, connection, table_name, schema=None, **kw):
 #able_id = self.get_table_id(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #NDEX_SQL = text(
 #""
 #ELECT object_name(i.id) AS table_name,
 #.keycnt AS 'count',
 #.name AS name,
 #i.status & 0x2) AS 'unique',
 #ndex_col(object_name(i.id), i.indid, 1) AS col_1,
 #ndex_col(object_name(i.id), i.indid, 2) AS col_2,
 #ndex_col(object_name(i.id), i.indid, 3) AS col_3,
 #ndex_col(object_name(i.id), i.indid, 4) AS col_4,
 #ndex_col(object_name(i.id), i.indid, 5) AS col_5,
 #ndex_col(object_name(i.id), i.indid, 6) AS col_6,
 #ndex_col(object_name(i.id), i.indid, 7) AS col_7,
 #ndex_col(object_name(i.id), i.indid, 8) AS col_8,
 #ndex_col(object_name(i.id), i.indid, 9) AS col_9,
 #ndex_col(object_name(i.id), i.indid, 10) AS col_10,
 #ndex_col(object_name(i.id), i.indid, 11) AS col_11,
 #ndex_col(object_name(i.id), i.indid, 12) AS col_12,
 #ndex_col(object_name(i.id), i.indid, 13) AS col_13,
 #ndex_col(object_name(i.id), i.indid, 14) AS col_14,
 #ndex_col(object_name(i.id), i.indid, 15) AS col_15,
 #ndex_col(object_name(i.id), i.indid, 16) AS col_16
 #ROM sysindexes i, sysobjects o
 #HERE o.id = i.id
 #ND o.id = :table_id
 #ND (i.status & 2048) = 0
 #ND i.indid BETWEEN 1 AND 254
 #""
 #

 #esults = connection.execute(INDEX_SQL, table_id=table_id)
 #ndexes = []
 #or r in results:
 #olumn_names = []
 #or i in range(1, r["count"]):
 #olumn_names.append(r["col_%i" % (i,)])
 #ndex_info = {
 #name": r["name"],
 #unique": bool(r["unique"]),
 #column_names": column_names,
 #
 #ndexes.append(index_info)

 #eturn indexes

 #reflection.cache
 #ef get_pk_constraint(self, connection, table_name, schema=None, **kw):
 #able_id = self.get_table_id(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #K_SQL = text(
 #""
 #ELECT object_name(i.id) AS table_name,
 #.keycnt AS 'count',
 #.name AS name,
 #ndex_col(object_name(i.id), i.indid, 1) AS pk_1,
 #ndex_col(object_name(i.id), i.indid, 2) AS pk_2,
 #ndex_col(object_name(i.id), i.indid, 3) AS pk_3,
 #ndex_col(object_name(i.id), i.indid, 4) AS pk_4,
 #ndex_col(object_name(i.id), i.indid, 5) AS pk_5,
 #ndex_col(object_name(i.id), i.indid, 6) AS pk_6,
 #ndex_col(object_name(i.id), i.indid, 7) AS pk_7,
 #ndex_col(object_name(i.id), i.indid, 8) AS pk_8,
 #ndex_col(object_name(i.id), i.indid, 9) AS pk_9,
 #ndex_col(object_name(i.id), i.indid, 10) AS pk_10,
 #ndex_col(object_name(i.id), i.indid, 11) AS pk_11,
 #ndex_col(object_name(i.id), i.indid, 12) AS pk_12,
 #ndex_col(object_name(i.id), i.indid, 13) AS pk_13,
 #ndex_col(object_name(i.id), i.indid, 14) AS pk_14,
 #ndex_col(object_name(i.id), i.indid, 15) AS pk_15,
 #ndex_col(object_name(i.id), i.indid, 16) AS pk_16
 #ROM sysindexes i, sysobjects o
 #HERE o.id = i.id
 #ND o.id = :table_id
 #ND (i.status & 2048) = 2048
 #ND i.indid BETWEEN 1 AND 254
 #""
 #

 #esults = connection.execute(PK_SQL, table_id=table_id)
 #ks = results.fetchone()
 #esults.close()

 #onstrained_columns = []
 #f pks:
 #or i in range(1, pks["count"] + 1):
 #onstrained_columns.append(pks["pk_%i" % (i,)])
 #eturn {
 #constrained_columns": constrained_columns,
 #name": pks["name"],
 #
 #lse:
 #eturn {"constrained_columns": [], "name": None}

 #reflection.cache
 #ef get_schema_names(self, connection, **kw):

 #CHEMA_SQL = text("SELECT u.name AS name FROM sysusers u")

 #chemas = connection.execute(SCHEMA_SQL)

 #eturn [s["name"] for s in schemas]

 #reflection.cache
 #ef get_table_names(self, connection, schema=None, **kw):
 #f schema is None:
 #chema = self.default_schema_name

 #ABLE_SQL = text(
 #""
 #ELECT o.name AS name
 #ROM sysobjects o JOIN sysusers u ON o.uid = u.uid
 #HERE u.name = :schema_name
 #ND o.type = 'U'
 #""
 #

 #f util.py2k:
 #f isinstance(schema, unicode):  # noqa
 #chema = schema.encode("ascii")

 #ables = connection.execute(TABLE_SQL, schema_name=schema)

 #eturn [t["name"] for t in tables]

 #reflection.cache
 #ef get_view_definition(self, connection, view_name, schema=None, **kw):
 #f schema is None:
 #chema = self.default_schema_name

 #IEW_DEF_SQL = text(
 #""
 #ELECT c.text
 #ROM syscomments c JOIN sysobjects o ON c.id = o.id
 #HERE o.name = :view_name
 #ND o.type = 'V'
 #""
 #

 #f util.py2k:
 #f isinstance(view_name, unicode):  # noqa
 #iew_name = view_name.encode("ascii")

 #iew = connection.execute(VIEW_DEF_SQL, view_name=view_name)

 #eturn view.scalar()

 #reflection.cache
 #ef get_view_names(self, connection, schema=None, **kw):
 #f schema is None:
 #chema = self.default_schema_name

 #IEW_SQL = text(
 #""
 #ELECT o.name AS name
 #ROM sysobjects o JOIN sysusers u ON o.uid = u.uid
 #HERE u.name = :schema_name
 #ND o.type = 'V'
 #""
 #

 #f util.py2k:
 #f isinstance(schema, unicode):  # noqa
 #chema = schema.encode("ascii")
 #iews = connection.execute(VIEW_SQL, schema_name=schema)

 #eturn [v["name"] for v in views]

 #ef has_table(self, connection, table_name, schema=None):
 #elf._ensure_has_table_connection(connection)

 #ry:
 #elf.get_table_id(connection, table_name, schema)
 #xcept exc.NoSuchTableError:
 #eturn False
 #lse:
 #eturn True
