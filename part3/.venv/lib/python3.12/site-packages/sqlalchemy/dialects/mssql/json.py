from ... import types as sqltypes

# technically, all the dialect-specific datatypes that don't have any special
# behaviors would be private with names like _MSJson. However, we haven't been
# doing this for mysql.JSON or sqlite.JSON which both have JSON / JSONIndexType
# / JSONPathType in their json.py files, so keep consistent with that
# sub-convention for now.  A future change can update them all to be
# package-private at once.


class JSON(sqltypes.JSON):
 #""MSSQL JSON type.

 #SSQL supports JSON-formatted data as of SQL Server 2016.

 #he :class:`_mssql.JSON` datatype at the DDL level will represent the
 #atatype as ``NVARCHAR(max)``, but provides for JSON-level comparison
 #unctions as well as Python coercion behavior.

 #class:`_mssql.JSON` is used automatically whenever the base
 #class:`_types.JSON` datatype is used against a SQL Server backend.

 #. seealso::

 #class:`_types.JSON` - main documentation for the generic
 #ross-platform JSON datatype.

 #he :class:`_mssql.JSON` type supports persistence of JSON values
 #s well as the core index operations provided by :class:`_types.JSON`
 #atatype, by adapting the operations to render the ``JSON_VALUE``
 #r ``JSON_QUERY`` functions at the database level.

 #he SQL Server :class:`_mssql.JSON` type necessarily makes use of the
 #`JSON_QUERY`` and ``JSON_VALUE`` functions when querying for elements
 #f a JSON object.   These two functions have a major restriction in that
 #hey are **mutually exclusive** based on the type of object to be returned.
 #he ``JSON_QUERY`` function **only** returns a JSON dictionary or list,
 #ut not an individual string, numeric, or boolean element; the
 #`JSON_VALUE`` function **only** returns an individual string, numeric,
 #r boolean element.   **both functions either return NULL or raise
 #n error if they are not used against the correct expected value**.

 #o handle this awkward requirement, indexed access rules are as follows:

 #. When extracting a sub element from a JSON that is itself a JSON
 #ictionary or list, the :meth:`_types.JSON.Comparator.as_json` accessor
 #hould be used::

 #tmt = select(
 #ata_table.c.data["some key"].as_json()
 #.where(
 #ata_table.c.data["some key"].as_json() == {"sub": "structure"}
 #

 #. When extracting a sub element from a JSON that is a plain boolean,
 #tring, integer, or float, use the appropriate method among
 #meth:`_types.JSON.Comparator.as_boolean`,
 #meth:`_types.JSON.Comparator.as_string`,
 #meth:`_types.JSON.Comparator.as_integer`,
 #meth:`_types.JSON.Comparator.as_float`::

 #tmt = select(
 #ata_table.c.data["some key"].as_string()
 #.where(
 #ata_table.c.data["some key"].as_string() == "some string"
 #

 #. versionadded:: 1.4


 #""

    # note there was a result processor here that was looking for "number",
    # but none of the tests seem to exercise it.


# Note: these objects currently match exactly those of MySQL, however since
# these are not generalizable to all JSON implementations, remain separately
# implemented for each dialect.
class _FormatTypeMixin(object):
 #ef _format_value(self, value):
 #aise NotImplementedError()

 #ef bind_processor(self, dialect):
 #uper_proc = self.string_bind_processor(dialect)

 #ef process(value):
 #alue = self._format_value(value)
 #f super_proc:
 #alue = super_proc(value)
 #eturn value

 #eturn process

 #ef literal_processor(self, dialect):
 #uper_proc = self.string_literal_processor(dialect)

 #ef process(value):
 #alue = self._format_value(value)
 #f super_proc:
 #alue = super_proc(value)
 #eturn value

 #eturn process


class JSONIndexType(_FormatTypeMixin, sqltypes.JSON.JSONIndexType):
 #ef _format_value(self, value):
 #f isinstance(value, int):
 #alue = "$[%s]" % value
 #lse:
 #alue = '$."%s"' % value
 #eturn value


class JSONPathType(_FormatTypeMixin, sqltypes.JSON.JSONPathType):
 #ef _format_value(self, value):
 #eturn "$%s" % (
 #".join(
 #
 #[%s]" % elem if isinstance(elem, int) else '."%s"' % elem
 #or elem in value
 #
 #
 #
