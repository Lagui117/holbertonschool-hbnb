# mssql/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""
.. dialect:: mssql
 #name: Microsoft SQL Server
 #full_support: 2017
 #normal_support: 2012+
 #best_effort: 2005+

.. _mssql_external_dialects:

External Dialects
-----------------

In addition to the above DBAPI layers with native SQLAlchemy support, there
are third-party dialects for other DBAPI layers that are compatible
with SQL Server. See the "External Dialects" list on the
:ref:`dialect_toplevel` page.

.. _mssql_identity:

Auto Increment Behavior / IDENTITY Columns
------------------------------------------

SQL Server provides so-called "auto incrementing" behavior using the
``IDENTITY`` construct, which can be placed on any single integer column in a
table. SQLAlchemy considers ``IDENTITY`` within its default "autoincrement"
behavior for an integer primary key column, described at
:paramref:`_schema.Column.autoincrement`.  This means that by default,
the first
integer primary key column in a :class:`_schema.Table`
will be considered to be the
identity column - unless it is associated with a :class:`.Sequence` - and will
generate DDL as such::

 #rom sqlalchemy import Table, MetaData, Column, Integer

 # = MetaData()
 # = Table('t', m,
 #olumn('id', Integer, primary_key=True),
 #olumn('x', Integer))
 #.create_all(engine)

The above example will generate DDL as:

.. sourcecode:: sql

 #REATE TABLE t (
 #d INTEGER NOT NULL IDENTITY,
 # INTEGER NULL,
 #RIMARY KEY (id)
 #

For the case where this default generation of ``IDENTITY`` is not desired,
specify ``False`` for the :paramref:`_schema.Column.autoincrement` flag,
on the first integer primary key column::

 # = MetaData()
 # = Table('t', m,
 #olumn('id', Integer, primary_key=True, autoincrement=False),
 #olumn('x', Integer))
 #.create_all(engine)

To add the ``IDENTITY`` keyword to a non-primary key column, specify
``True`` for the :paramref:`_schema.Column.autoincrement` flag on the desired
:class:`_schema.Column` object, and ensure that
:paramref:`_schema.Column.autoincrement`
is set to ``False`` on any integer primary key column::

 # = MetaData()
 # = Table('t', m,
 #olumn('id', Integer, primary_key=True, autoincrement=False),
 #olumn('x', Integer, autoincrement=True))
 #.create_all(engine)

.. versionchanged::  1.4   Added :class:`_schema.Identity` construct
 #n a :class:`_schema.Column` to specify the start and increment
 #arameters of an IDENTITY. These replace
 #he use of the :class:`.Sequence` object in order to specify these values.

.. deprecated:: 1.4

 #he ``mssql_identity_start`` and ``mssql_identity_increment`` parameters
 #o :class:`_schema.Column` are deprecated and should we replaced by
 #n :class:`_schema.Identity` object. Specifying both ways of configuring
 #n IDENTITY will result in a compile error.
 #hese options are also no longer returned as part of the
 #`dialect_options`` key in :meth:`_reflection.Inspector.get_columns`.
 #se the information in the ``identity`` key instead.

.. deprecated:: 1.3

 #he use of :class:`.Sequence` to specify IDENTITY characteristics is
 #eprecated and will be removed in a future release.   Please use
 #he :class:`_schema.Identity` object parameters
 #paramref:`_schema.Identity.start` and
 #paramref:`_schema.Identity.increment`.

.. versionchanged::  1.4   Removed the ability to use a :class:`.Sequence`
 #bject to modify IDENTITY characteristics. :class:`.Sequence` objects
 #ow only manipulate true T-SQL SEQUENCE types.

.. note::

 #here can only be one IDENTITY column on the table.  When using
 #`autoincrement=True`` to enable the IDENTITY keyword, SQLAlchemy does not
 #uard against multiple columns specifying the option simultaneously.  The
 #QL Server database will instead reject the ``CREATE TABLE`` statement.

.. note::

 #n INSERT statement which attempts to provide a value for a column that is
 #arked with IDENTITY will be rejected by SQL Server.   In order for the
 #alue to be accepted, a session-level option "SET IDENTITY_INSERT" must be
 #nabled.   The SQLAlchemy SQL Server dialect will perform this operation
 #utomatically when using a core :class:`_expression.Insert`
 #onstruct; if the
 #xecution specifies a value for the IDENTITY column, the "IDENTITY_INSERT"
 #ption will be enabled for the span of that statement's invocation.However,
 #his scenario is not high performing and should not be relied upon for
 #ormal use.   If a table doesn't actually require IDENTITY behavior in its
 #nteger primary key column, the keyword should be disabled when creating
 #he table by ensuring that ``autoincrement=False`` is set.

Controlling "Start" and "Increment"
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Specific control over the "start" and "increment" values for
the ``IDENTITY`` generator are provided using the
:paramref:`_schema.Identity.start` and :paramref:`_schema.Identity.increment`
parameters passed to the :class:`_schema.Identity` object::

 #rom sqlalchemy import Table, Integer, Column, Identity

 #est = Table(
 #test', metadata,
 #olumn(
 #id',
 #nteger,
 #rimary_key=True,
 #dentity(start=100, increment=10)
 #,
 #olumn('name', String(20))
 #

The CREATE TABLE for the above :class:`_schema.Table` object would be:

.. sourcecode:: sql

 #REATE TABLE test (
 #d INTEGER NOT NULL IDENTITY(100,10) PRIMARY KEY,
 #ame VARCHAR(20) NULL,
 #

.. note::

 #he :class:`_schema.Identity` object supports many other parameter in
 #ddition to ``start`` and ``increment``. These are not supported by
 #QL Server and will be ignored when generating the CREATE TABLE ddl.

.. versionchanged:: 1.3.19  The :class:`_schema.Identity` object is
 #ow used to affect the
 #`IDENTITY`` generator for a :class:`_schema.Column` under  SQL Server.
 #reviously, the :class:`.Sequence` object was used.  As SQL Server now
 #upports real sequences as a separate construct, :class:`.Sequence` will be
 #unctional in the normal way starting from SQLAlchemy version 1.4.

INSERT behavior
^^^^^^^^^^^^^^^^

Handling of the ``IDENTITY`` column at INSERT time involves two key
techniques. The most common is being able to fetch the "last inserted value"
for a given ``IDENTITY`` column, a process which SQLAlchemy performs
implicitly in many cases, most importantly within the ORM.

The process for fetching this value has several variants:

* In the vast majority of cases, RETURNING is used in conjunction with INSERT
 #tatements on SQL Server in order to get newly generated primary key values:

 #. sourcecode:: sql

 #NSERT INTO t (x) OUTPUT inserted.id VALUES (?)

* When RETURNING is not available or has been disabled via
 #`implicit_returning=False``, either the ``scope_identity()`` function or
 #he ``@@identity`` variable is used; behavior varies by backend:

 # when using PyODBC, the phrase ``; select scope_identity()`` will be
 #ppended to the end of the INSERT statement; a second result set will be
 #etched in order to receive the value.  Given a table as::

 # = Table('t', m, Column('id', Integer, primary_key=True),
 #olumn('x', Integer),
 #mplicit_returning=False)

 #n INSERT will look like:

 #. sourcecode:: sql

 #NSERT INTO t (x) VALUES (?); select scope_identity()

 # Other dialects such as pymssql will call upon
 #`SELECT scope_identity() AS lastrowid`` subsequent to an INSERT
 #tatement. If the flag ``use_scope_identity=False`` is passed to
 #func:`_sa.create_engine`,
 #he statement ``SELECT @@identity AS lastrowid``
 #s used instead.

A table that contains an ``IDENTITY`` column will prohibit an INSERT statement
that refers to the identity column explicitly.  The SQLAlchemy dialect will
detect when an INSERT construct, created using a core
:func:`_expression.insert`
construct (not a plain string SQL), refers to the identity column, and
in this case will emit ``SET IDENTITY_INSERT ON`` prior to the insert
statement proceeding, and ``SET IDENTITY_INSERT OFF`` subsequent to the
execution.  Given this example::

 # = MetaData()
 # = Table('t', m, Column('id', Integer, primary_key=True),
 #olumn('x', Integer))
 #.create_all(engine)

 #ith engine.begin() as conn:
 #onn.execute(t.insert(), {'id': 1, 'x':1}, {'id':2, 'x':2})

The above column will be created with IDENTITY, however the INSERT statement
we emit is specifying explicit values.  In the echo output we can see
how SQLAlchemy handles this:

.. sourcecode:: sql

 #REATE TABLE t (
 #d INTEGER NOT NULL IDENTITY(1,1),
 # INTEGER NULL,
 #RIMARY KEY (id)
 #

 #OMMIT
 #ET IDENTITY_INSERT t ON
 #NSERT INTO t (id, x) VALUES (?, ?)
 #(1, 1), (2, 2))
 #ET IDENTITY_INSERT t OFF
 #OMMIT



This
is an auxiliary use case suitable for testing and bulk insert scenarios.

SEQUENCE support
----------------

The :class:`.Sequence` object now creates "real" sequences, i.e.,
``CREATE SEQUENCE``. To provide compatibility with other dialects,
:class:`.Sequence` defaults to a start value of 1, even though the
T-SQL defaults is -9223372036854775808.

.. versionadded:: 1.4.0

MAX on VARCHAR / NVARCHAR
-------------------------

SQL Server supports the special string "MAX" within the
:class:`_types.VARCHAR` and :class:`_types.NVARCHAR` datatypes,
to indicate "maximum length possible".   The dialect currently handles this as
a length of "None" in the base type, rather than supplying a
dialect-specific version of these types, so that a base type
specified such as ``VARCHAR(None)`` can assume "unlengthed" behavior on
more than one backend without using dialect-specific types.

To build a SQL Server VARCHAR or NVARCHAR with MAX length, use None::

 #y_table = Table(
 #my_table', metadata,
 #olumn('my_data', VARCHAR(None)),
 #olumn('my_n_data', NVARCHAR(None))
 #


Collation Support
-----------------

Character collations are supported by the base string types,
specified by the string argument "collation"::

 #rom sqlalchemy import VARCHAR
 #olumn('login', VARCHAR(32, collation='Latin1_General_CI_AS'))

When such a column is associated with a :class:`_schema.Table`, the
CREATE TABLE statement for this column will yield::

 #ogin VARCHAR(32) COLLATE Latin1_General_CI_AS NULL

LIMIT/OFFSET Support
--------------------

MSSQL has added support for LIMIT / OFFSET as of SQL Server 2012, via the
"OFFSET n ROWS" and "FETCH NEXT n ROWS" clauses.  SQLAlchemy supports these
syntaxes automatically if SQL Server 2012 or greater is detected.

.. versionchanged:: 1.4 support added for SQL Server "OFFSET n ROWS" and
 #FETCH NEXT n ROWS" syntax.

For statements that specify only LIMIT and no OFFSET, all versions of SQL
Server support the TOP keyword.   This syntax is used for all SQL Server
versions when no OFFSET clause is present.  A statement such as::

 #elect(some_table).limit(5)

will render similarly to::

 #ELECT TOP 5 col1, col2.. FROM table

For versions of SQL Server prior to SQL Server 2012, a statement that uses
LIMIT and OFFSET, or just OFFSET alone, will be rendered using the
``ROW_NUMBER()`` window function.   A statement such as::

 #elect(some_table).order_by(some_table.c.col3).limit(5).offset(10)

will render similarly to::

 #ELECT anon_1.col1, anon_1.col2 FROM (SELECT col1, col2,
 #OW_NUMBER() OVER (ORDER BY col3) AS
 #ssql_rn FROM table WHERE t.x = :x_1) AS
 #non_1 WHERE mssql_rn > :param_1 AND mssql_rn <= :param_2 + :param_1

Note that when using LIMIT and/or OFFSET, whether using the older
or newer SQL Server syntaxes, the statement must have an ORDER BY as well,
else a :class:`.CompileError` is raised.

.. _mssql_isolation_level:

Transaction Isolation Level
---------------------------

All SQL Server dialects support setting of transaction isolation level
both via a dialect-specific parameter
:paramref:`_sa.create_engine.isolation_level`
accepted by :func:`_sa.create_engine`,
as well as the :paramref:`.Connection.execution_options.isolation_level`
argument as passed to
:meth:`_engine.Connection.execution_options`.
This feature works by issuing the
command ``SET TRANSACTION ISOLATION LEVEL <level>`` for
each new connection.

To set isolation level using :func:`_sa.create_engine`::

 #ngine = create_engine(
 #mssql+pyodbc://scott:tiger@ms_2008",
 #solation_level="REPEATABLE READ"
 #

To set using per-connection execution options::

 #onnection = engine.connect()
 #onnection = connection.execution_options(
 #solation_level="READ COMMITTED"
 #

Valid values for ``isolation_level`` include:

* ``AUTOCOMMIT`` - pyodbc / pymssql-specific
* ``READ COMMITTED``
* ``READ UNCOMMITTED``
* ``REPEATABLE READ``
* ``SERIALIZABLE``
* ``SNAPSHOT`` - specific to SQL Server

.. versionadded:: 1.2 added AUTOCOMMIT isolation level setting

.. seealso::

 #ref:`dbapi_autocommit`

Nullability
-----------
MSSQL has support for three levels of column nullability. The default
nullability allows nulls and is explicit in the CREATE TABLE
construct::

 #ame VARCHAR(20) NULL

If ``nullable=None`` is specified then no specification is made. In
other words the database's configured default is used. This will
render::

 #ame VARCHAR(20)

If ``nullable`` is ``True`` or ``False`` then the column will be
``NULL`` or ``NOT NULL`` respectively.

Date / Time Handling
--------------------
DATE and TIME are supported.   Bind parameters are converted
to datetime.datetime() objects as required by most MSSQL drivers,
and results are processed from strings if needed.
The DATE and TIME types are not available for MSSQL 2005 and
previous - if a server version below 2008 is detected, DDL
for these types will be issued as DATETIME.

.. _mssql_large_type_deprecation:

Large Text/Binary Type Deprecation
----------------------------------

Per
`SQL Server 2012/2014 Documentation <https://technet.microsoft.com/en-us/library/ms187993.aspx>`_,
the ``NTEXT``, ``TEXT`` and ``IMAGE`` datatypes are to be removed from SQL
Server in a future release.   SQLAlchemy normally relates these types to the
:class:`.UnicodeText`, :class:`_expression.TextClause` and
:class:`.LargeBinary` datatypes.

In order to accommodate this change, a new flag ``deprecate_large_types``
is added to the dialect, which will be automatically set based on detection
of the server version in use, if not otherwise set by the user.  The
behavior of this flag is as follows:

* When this flag is ``True``, the :class:`.UnicodeText`,
 #class:`_expression.TextClause` and
 #class:`.LargeBinary` datatypes, when used to render DDL, will render the
 #ypes ``NVARCHAR(max)``, ``VARCHAR(max)``, and ``VARBINARY(max)``,
 #espectively.  This is a new behavior as of the addition of this flag.

* When this flag is ``False``, the :class:`.UnicodeText`,
 #class:`_expression.TextClause` and
 #class:`.LargeBinary` datatypes, when used to render DDL, will render the
 #ypes ``NTEXT``, ``TEXT``, and ``IMAGE``,
 #espectively.  This is the long-standing behavior of these types.

* The flag begins with the value ``None``, before a database connection is
 #stablished.   If the dialect is used to render DDL without the flag being
 #et, it is interpreted the same as ``False``.

* On first connection, the dialect detects if SQL Server version 2012 or
 #reater is in use; if the flag is still at ``None``, it sets it to ``True``
 #r ``False`` based on whether 2012 or greater is detected.

* The flag can be set to either ``True`` or ``False`` when the dialect
 #s created, typically via :func:`_sa.create_engine`::

 #ng = create_engine("mssql+pymssql://user:pass@host/db",
 #eprecate_large_types=True)

* Complete control over whether the "old" or "new" types are rendered is
 #vailable in all SQLAlchemy versions by using the UPPERCASE type objects
 #nstead: :class:`_types.NVARCHAR`, :class:`_types.VARCHAR`,
 #class:`_types.VARBINARY`, :class:`_types.TEXT`, :class:`_mssql.NTEXT`,
 #class:`_mssql.IMAGE`
 #ill always remain fixed and always output exactly that
 #ype.

.. versionadded:: 1.0.0

.. _multipart_schema_names:

Multipart Schema Names
----------------------

SQL Server schemas sometimes require multiple parts to their "schema"
qualifier, that is, including the database name and owner name as separate
tokens, such as ``mydatabase.dbo.some_table``. These multipart names can be set
at once using the :paramref:`_schema.Table.schema` argument of
:class:`_schema.Table`::

 #able(
 #some_table", metadata,
 #olumn("q", String(50)),
 #chema="mydatabase.dbo"
 #

When performing operations such as table or component reflection, a schema
argument that contains a dot will be split into separate
"database" and "owner"  components in order to correctly query the SQL
Server information schema tables, as these two values are stored separately.
Additionally, when rendering the schema name for DDL or SQL, the two
components will be quoted separately for case sensitive names and other
special characters.   Given an argument as below::

 #able(
 #some_table", metadata,
 #olumn("q", String(50)),
 #chema="MyDataBase.dbo"
 #

The above schema would be rendered as ``[MyDataBase].dbo``, and also in
reflection, would be reflected using "dbo" as the owner and "MyDataBase"
as the database name.

To control how the schema name is broken into database / owner,
specify brackets (which in SQL Server are quoting characters) in the name.
Below, the "owner" will be considered as ``MyDataBase.dbo`` and the
"database" will be None::

 #able(
 #some_table", metadata,
 #olumn("q", String(50)),
 #chema="[MyDataBase.dbo]"
 #

To individually specify both database and owner name with special characters
or embedded dots, use two sets of brackets::

 #able(
 #some_table", metadata,
 #olumn("q", String(50)),
 #chema="[MyDataBase.Period].[MyOwner.Dot]"
 #


.. versionchanged:: 1.2 the SQL Server dialect now treats brackets as
 #dentifier delimeters splitting the schema into separate database
 #nd owner tokens, to allow dots within either name itself.

.. _legacy_schema_rendering:

Legacy Schema Mode
------------------

Very old versions of the MSSQL dialect introduced the behavior such that a
schema-qualified table would be auto-aliased when used in a
SELECT statement; given a table::

 #ccount_table = Table(
 #account', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('info', String(100)),
 #chema="customer_schema"
 #

this legacy mode of rendering would assume that "customer_schema.account"
would not be accepted by all parts of the SQL statement, as illustrated
below::

 #>> eng = create_engine("mssql+pymssql://mydsn", legacy_schema_aliasing=True)
 #>> print(account_table.select().compile(eng))
 #ELECT account_1.id, account_1.info
 #ROM customer_schema.account AS account_1

This mode of behavior is now off by default, as it appears to have served
no purpose; however in the case that legacy applications rely upon it,
it is available using the ``legacy_schema_aliasing`` argument to
:func:`_sa.create_engine` as illustrated above.

.. versionchanged:: 1.1 the ``legacy_schema_aliasing`` flag introduced
 #n version 1.0.5 to allow disabling of legacy mode for schemas now
 #efaults to False.

.. deprecated:: 1.4

 #he ``legacy_schema_aliasing`` flag is now
 #eprecated and will be removed in a future release.

.. _mssql_indexes:

Clustered Index Support
-----------------------

The MSSQL dialect supports clustered indexes (and primary keys) via the
``mssql_clustered`` option.  This option is available to :class:`.Index`,
:class:`.UniqueConstraint`. and :class:`.PrimaryKeyConstraint`.

To generate a clustered index::

 #ndex("my_index", table.c.x, mssql_clustered=True)

which renders the index as ``CREATE CLUSTERED INDEX my_index ON table (x)``.

To generate a clustered primary key use::

 #able('my_table', metadata,
 #olumn('x', ...),
 #olumn('y', ...),
 #rimaryKeyConstraint("x", "y", mssql_clustered=True))

which will render the table, for example, as::

 #REATE TABLE my_table (x INTEGER NOT NULL, y INTEGER NOT NULL,
 #RIMARY KEY CLUSTERED (x, y))

Similarly, we can generate a clustered unique constraint using::

 #able('my_table', metadata,
 #olumn('x', ...),
 #olumn('y', ...),
 #rimaryKeyConstraint("x"),
 #niqueConstraint("y", mssql_clustered=True),
 #

To explicitly request a non-clustered primary key (for example, when
a separate clustered index is desired), use::

 #able('my_table', metadata,
 #olumn('x', ...),
 #olumn('y', ...),
 #rimaryKeyConstraint("x", "y", mssql_clustered=False))

which will render the table, for example, as::

 #REATE TABLE my_table (x INTEGER NOT NULL, y INTEGER NOT NULL,
 #RIMARY KEY NONCLUSTERED (x, y))

.. versionchanged:: 1.1 the ``mssql_clustered`` option now defaults
 #o None, rather than False.  ``mssql_clustered=False`` now explicitly
 #enders the NONCLUSTERED clause, whereas None omits the CLUSTERED
 #lause entirely, allowing SQL Server defaults to take effect.


MSSQL-Specific Index Options
-----------------------------

In addition to clustering, the MSSQL dialect supports other special options
for :class:`.Index`.

INCLUDE
^^^^^^^

The ``mssql_include`` option renders INCLUDE(colname) for the given string
names::

 #ndex("my_index", table.c.x, mssql_include=['y'])

would render the index as ``CREATE INDEX my_index ON table (x) INCLUDE (y)``

.. _mssql_index_where:

Filtered Indexes
^^^^^^^^^^^^^^^^

The ``mssql_where`` option renders WHERE(condition) for the given string
names::

 #ndex("my_index", table.c.x, mssql_where=table.c.x > 10)

would render the index as ``CREATE INDEX my_index ON table (x) WHERE x > 10``.

.. versionadded:: 1.3.4

Index ordering
^^^^^^^^^^^^^^

Index ordering is available via functional expressions, such as::

 #ndex("my_index", table.c.x.desc())

would render the index as ``CREATE INDEX my_index ON table (x DESC)``

.. seealso::

 #ref:`schema_indexes_functional`

Compatibility Levels
--------------------
MSSQL supports the notion of setting compatibility levels at the
database level. This allows, for instance, to run a database that
is compatible with SQL2000 while running on a SQL2005 database
server. ``server_version_info`` will always return the database
server version information (in this case SQL2005) and not the
compatibility level information. Because of this, if running under
a backwards compatibility mode SQLAlchemy may attempt to use T-SQL
statements that are unable to be parsed by the database server.

Triggers
--------

SQLAlchemy by default uses OUTPUT INSERTED to get at newly
generated primary key values via IDENTITY columns or other
server side defaults.   MS-SQL does not
allow the usage of OUTPUT INSERTED on tables that have triggers.
To disable the usage of OUTPUT INSERTED on a per-table basis,
specify ``implicit_returning=False`` for each :class:`_schema.Table`
which has triggers::

 #able('mytable', metadata,
 #olumn('id', Integer, primary_key=True),
        # ...,
 #mplicit_returning=False
 #

Declarative form::

 #lass MyClass(Base):
        # ...
 #_table_args__ = {'implicit_returning':False}


This option can also be specified engine-wide using the
``implicit_returning=False`` argument on :func:`_sa.create_engine`.

.. _mssql_rowcount_versioning:

Rowcount Support / ORM Versioning
---------------------------------

The SQL Server drivers may have limited ability to return the number
of rows updated from an UPDATE or DELETE statement.

As of this writing, the PyODBC driver is not able to return a rowcount when
OUTPUT INSERTED is used.  This impacts the SQLAlchemy ORM's versioning feature
in many cases where server-side value generators are in use in that while the
versioning operations can succeed, the ORM cannot always check that an UPDATE
or DELETE statement matched the number of rows expected, which is how it
verifies that the version identifier matched.   When this condition occurs, a
warning will be emitted but the operation will proceed.

The use of OUTPUT INSERTED can be disabled by setting the
:paramref:`_schema.Table.implicit_returning` flag to ``False`` on a particular
:class:`_schema.Table`, which in declarative looks like::

 #lass MyTable(Base):
 #_tablename__ = 'mytable'
 #d = Column(Integer, primary_key=True)
 #tuff = Column(String(10))
 #imestamp = Column(TIMESTAMP(), default=text('DEFAULT'))
 #_mapper_args__ = {
 #version_id_col': timestamp,
 #version_id_generator': False,
 #
 #_table_args__ = {
 #implicit_returning': False
 #

Enabling Snapshot Isolation
---------------------------

SQL Server has a default transaction
isolation mode that locks entire tables, and causes even mildly concurrent
applications to have long held locks and frequent deadlocks.
Enabling snapshot isolation for the database as a whole is recommended
for modern levels of concurrency support.  This is accomplished via the
following ALTER DATABASE commands executed at the SQL prompt::

 #LTER DATABASE MyDatabase SET ALLOW_SNAPSHOT_ISOLATION ON

 #LTER DATABASE MyDatabase SET READ_COMMITTED_SNAPSHOT ON

Background on SQL Server snapshot isolation is available at
https://msdn.microsoft.com/en-us/library/ms175095.aspx.

"""  # noqa

import codecs
import datetime
import operator
import re

from . import information_schema as ischema
from .json import JSON
from .json import JSONIndexType
from .json import JSONPathType
from ... import exc
from ... import Identity
from ... import schema as sa_schema
from ... import Sequence
from ... import sql
from ... import types as sqltypes
from ... import util
from ...engine import cursor as _cursor
from ...engine import default
from ...engine import reflection
from ...sql import coercions
from ...sql import compiler
from ...sql import elements
from ...sql import expression
from ...sql import func
from ...sql import quoted_name
from ...sql import roles
from ...sql import util as sql_util
from ...types import BIGINT
from ...types import BINARY
from ...types import CHAR
from ...types import DATE
from ...types import DATETIME
from ...types import DECIMAL
from ...types import FLOAT
from ...types import INTEGER
from ...types import NCHAR
from ...types import NUMERIC
from ...types import NVARCHAR
from ...types import SMALLINT
from ...types import TEXT
from ...types import VARCHAR
from ...util import compat
from ...util import update_wrapper
from ...util.langhelpers import public_factory


# https://sqlserverbuilds.blogspot.com/
MS_2017_VERSION = (14,)
MS_2016_VERSION = (13,)
MS_2014_VERSION = (12,)
MS_2012_VERSION = (11,)
MS_2008_VERSION = (10,)
MS_2005_VERSION = (9,)
MS_2000_VERSION = (8,)

RESERVED_WORDS = set(
 #
 #add",
 #all",
 #alter",
 #and",
 #any",
 #as",
 #asc",
 #authorization",
 #backup",
 #begin",
 #between",
 #break",
 #browse",
 #bulk",
 #by",
 #cascade",
 #case",
 #check",
 #checkpoint",
 #close",
 #clustered",
 #coalesce",
 #collate",
 #column",
 #commit",
 #compute",
 #constraint",
 #contains",
 #containstable",
 #continue",
 #convert",
 #create",
 #cross",
 #current",
 #current_date",
 #current_time",
 #current_timestamp",
 #current_user",
 #cursor",
 #database",
 #dbcc",
 #deallocate",
 #declare",
 #default",
 #delete",
 #deny",
 #desc",
 #disk",
 #distinct",
 #distributed",
 #double",
 #drop",
 #dump",
 #else",
 #end",
 #errlvl",
 #escape",
 #except",
 #exec",
 #execute",
 #exists",
 #exit",
 #external",
 #fetch",
 #file",
 #fillfactor",
 #for",
 #foreign",
 #freetext",
 #freetexttable",
 #from",
 #full",
 #function",
 #goto",
 #grant",
 #group",
 #having",
 #holdlock",
 #identity",
 #identity_insert",
 #identitycol",
 #if",
 #in",
 #index",
 #inner",
 #insert",
 #intersect",
 #into",
 #is",
 #join",
 #key",
 #kill",
 #left",
 #like",
 #lineno",
 #load",
 #merge",
 #national",
 #nocheck",
 #nonclustered",
 #not",
 #null",
 #nullif",
 #of",
 #off",
 #offsets",
 #on",
 #open",
 #opendatasource",
 #openquery",
 #openrowset",
 #openxml",
 #option",
 #or",
 #order",
 #outer",
 #over",
 #percent",
 #pivot",
 #plan",
 #precision",
 #primary",
 #print",
 #proc",
 #procedure",
 #public",
 #raiserror",
 #read",
 #readtext",
 #reconfigure",
 #references",
 #replication",
 #restore",
 #restrict",
 #return",
 #revert",
 #revoke",
 #right",
 #rollback",
 #rowcount",
 #rowguidcol",
 #rule",
 #save",
 #schema",
 #securityaudit",
 #select",
 #session_user",
 #set",
 #setuser",
 #shutdown",
 #some",
 #statistics",
 #system_user",
 #table",
 #tablesample",
 #textsize",
 #then",
 #to",
 #top",
 #tran",
 #transaction",
 #trigger",
 #truncate",
 #tsequal",
 #union",
 #unique",
 #unpivot",
 #update",
 #updatetext",
 #use",
 #user",
 #values",
 #varying",
 #view",
 #waitfor",
 #when",
 #where",
 #while",
 #with",
 #writetext",
 #
)


class REAL(sqltypes.REAL):
 #_visit_name__ = "REAL"

 #ef __init__(self, **kw):
        # REAL is a synonym for FLOAT(24) on SQL server.
        # it is only accepted as the word "REAL" in DDL, the numeric
        # precision value is not allowed to be present
 #w.setdefault("precision", 24)
 #uper(REAL, self).__init__(**kw)


class TINYINT(sqltypes.Integer):
 #_visit_name__ = "TINYINT"


# MSSQL DATE/TIME types have varied behavior, sometimes returning
# strings.  MSDate/TIME check for everything, and always
# filter bind parameters into datetime objects (required by pyodbc,
# not sure about other dialects).


class _MSDate(sqltypes.Date):
 #ef bind_processor(self, dialect):
 #ef process(value):
 #f type(value) == datetime.date:
 #eturn datetime.datetime(value.year, value.month, value.day)
 #lse:
 #eturn value

 #eturn process

 #reg = re.compile(r"(\d+)-(\d+)-(\d+)")

 #ef result_processor(self, dialect, coltype):
 #ef process(value):
 #f isinstance(value, datetime.datetime):
 #eturn value.date()
 #lif isinstance(value, util.string_types):
 # = self._reg.match(value)
 #f not m:
 #aise ValueError(
 #could not parse %r as a date value" % (value,)
 #
 #eturn datetime.date(*[int(x or 0) for x in m.groups()])
 #lse:
 #eturn value

 #eturn process


class TIME(sqltypes.TIME):
 #ef __init__(self, precision=None, **kwargs):
 #elf.precision = precision
 #uper(TIME, self).__init__()

 #_zero_date = datetime.date(1900, 1, 1)

 #ef bind_processor(self, dialect):
 #ef process(value):
 #f isinstance(value, datetime.datetime):
 #alue = datetime.datetime.combine(
 #elf.__zero_date, value.time()
 #
 #lif isinstance(value, datetime.time):
 #""issue #5339
 #er: https://github.com/mkleehammer/pyodbc/wiki/Tips-and-Tricks-by-Database-Platform#time-columns
 #ass TIME value as string
 #""  # noqa
 #alue = str(value)
 #eturn value

 #eturn process

 #reg = re.compile(r"(\d+):(\d+):(\d+)(?:\.(\d{0,6}))?")

 #ef result_processor(self, dialect, coltype):
 #ef process(value):
 #f isinstance(value, datetime.datetime):
 #eturn value.time()
 #lif isinstance(value, util.string_types):
 # = self._reg.match(value)
 #f not m:
 #aise ValueError(
 #could not parse %r as a time value" % (value,)
 #
 #eturn datetime.time(*[int(x or 0) for x in m.groups()])
 #lse:
 #eturn value

 #eturn process


_MSTime = TIME


class _DateTimeBase(object):
 #ef bind_processor(self, dialect):
 #ef process(value):
 #f type(value) == datetime.date:
 #eturn datetime.datetime(value.year, value.month, value.day)
 #lse:
 #eturn value

 #eturn process


class _MSDateTime(_DateTimeBase, sqltypes.DateTime):
 #ass


class SMALLDATETIME(_DateTimeBase, sqltypes.DateTime):
 #_visit_name__ = "SMALLDATETIME"


class DATETIME2(_DateTimeBase, sqltypes.DateTime):
 #_visit_name__ = "DATETIME2"

 #ef __init__(self, precision=None, **kw):
 #uper(DATETIME2, self).__init__(**kw)
 #elf.precision = precision


class DATETIMEOFFSET(_DateTimeBase, sqltypes.DateTime):
 #_visit_name__ = "DATETIMEOFFSET"

 #ef __init__(self, precision=None, **kw):
 #uper(DATETIMEOFFSET, self).__init__(**kw)
 #elf.precision = precision


class _UnicodeLiteral(object):
 #ef literal_processor(self, dialect):
 #ef process(value):

 #alue = value.replace("'", "''")

 #f dialect.identifier_preparer._double_percents:
 #alue = value.replace("%", "%%")

 #eturn "N'%s'" % value

 #eturn process


class _MSUnicode(_UnicodeLiteral, sqltypes.Unicode):
 #ass


class _MSUnicodeText(_UnicodeLiteral, sqltypes.UnicodeText):
 #ass


class TIMESTAMP(sqltypes._Binary):
 #""Implement the SQL Server TIMESTAMP type.

 #ote this is **completely different** than the SQL Standard
 #IMESTAMP type, which is not supported by SQL Server.  It
 #s a read-only datatype that does not support INSERT of values.

 #. versionadded:: 1.2

 #. seealso::

 #class:`_mssql.ROWVERSION`

 #""

 #_visit_name__ = "TIMESTAMP"

    # expected by _Binary to be present
 #ength = None

 #ef __init__(self, convert_int=False):
 #""Construct a TIMESTAMP or ROWVERSION type.

 #param convert_int: if True, binary integer values will
 #e converted to integers on read.

 #. versionadded:: 1.2

 #""
 #elf.convert_int = convert_int

 #ef result_processor(self, dialect, coltype):
 #uper_ = super(TIMESTAMP, self).result_processor(dialect, coltype)
 #f self.convert_int:

 #ef process(value):
 #alue = super_(value)
 #f value is not None:
                    # https://stackoverflow.com/a/30403242/34549
 #alue = int(codecs.encode(value, "hex"), 16)
 #eturn value

 #eturn process
 #lse:
 #eturn super_


class ROWVERSION(TIMESTAMP):
 #""Implement the SQL Server ROWVERSION type.

 #he ROWVERSION datatype is a SQL Server synonym for the TIMESTAMP
 #atatype, however current SQL Server documentation suggests using
 #OWVERSION for new datatypes going forward.

 #he ROWVERSION datatype does **not** reflect (e.g. introspect) from the
 #atabase as itself; the returned datatype will be
 #class:`_mssql.TIMESTAMP`.

 #his is a read-only datatype that does not support INSERT of values.

 #. versionadded:: 1.2

 #. seealso::

 #class:`_mssql.TIMESTAMP`

 #""

 #_visit_name__ = "ROWVERSION"


class NTEXT(sqltypes.UnicodeText):

 #""MSSQL NTEXT type, for variable-length unicode text up to 2^30
 #haracters."""

 #_visit_name__ = "NTEXT"


class VARBINARY(sqltypes.VARBINARY, sqltypes.LargeBinary):
 #""The MSSQL VARBINARY type.

 #his type is present to support "deprecate_large_types" mode where
 #ither ``VARBINARY(max)`` or IMAGE is rendered.   Otherwise, this type
 #bject is redundant vs. :class:`_types.VARBINARY`.

 #. versionadded:: 1.0.0

 #. seealso::

 #ref:`mssql_large_type_deprecation`



 #""

 #_visit_name__ = "VARBINARY"


class IMAGE(sqltypes.LargeBinary):
 #_visit_name__ = "IMAGE"


class XML(sqltypes.Text):
 #""MSSQL XML type.

 #his is a placeholder type for reflection purposes that does not include
 #ny Python-side datatype support.   It also does not currently support
 #dditional arguments, such as "CONTENT", "DOCUMENT",
 #xml_schema_collection".

 #. versionadded:: 1.1.11

 #""

 #_visit_name__ = "XML"


class BIT(sqltypes.Boolean):
 #""MSSQL BIT type.

 #oth pyodbc and pymssql return values from BIT columns as
 #ython <class 'bool'> so just subclass Boolean.

 #""

 #_visit_name__ = "BIT"


class MONEY(sqltypes.TypeEngine):
 #_visit_name__ = "MONEY"


class SMALLMONEY(sqltypes.TypeEngine):
 #_visit_name__ = "SMALLMONEY"


class UNIQUEIDENTIFIER(sqltypes.TypeEngine):
 #_visit_name__ = "UNIQUEIDENTIFIER"


class SQL_VARIANT(sqltypes.TypeEngine):
 #_visit_name__ = "SQL_VARIANT"


class TryCast(sql.elements.Cast):
 #""Represent a SQL Server TRY_CAST expression."""

 #_visit_name__ = "try_cast"

 #tringify_dialect = "mssql"

 #ef __init__(self, *arg, **kw):
 #""Create a TRY_CAST expression.

 #class:`.TryCast` is a subclass of SQLAlchemy's :class:`.Cast`
 #onstruct, and works in the same way, except that the SQL expression
 #endered is "TRY_CAST" rather than "CAST"::

 #rom sqlalchemy import select
 #rom sqlalchemy import Numeric
 #rom sqlalchemy.dialects.mssql import try_cast

 #tmt = select(
 #ry_cast(product_table.c.unit_price, Numeric(10, 4))
 #

 #he above would render::

 #ELECT TRY_CAST (product_table.unit_price AS NUMERIC(10, 4))
 #ROM product_table

 #. versionadded:: 1.3.7

 #""
 #uper(TryCast, self).__init__(*arg, **kw)


try_cast = public_factory(TryCast, ".dialects.mssql.try_cast")

# old names.
MSDateTime = _MSDateTime
MSDate = _MSDate
MSReal = REAL
MSTinyInteger = TINYINT
MSTime = TIME
MSSmallDateTime = SMALLDATETIME
MSDateTime2 = DATETIME2
MSDateTimeOffset = DATETIMEOFFSET
MSText = TEXT
MSNText = NTEXT
MSString = VARCHAR
MSNVarchar = NVARCHAR
MSChar = CHAR
MSNChar = NCHAR
MSBinary = BINARY
MSVarBinary = VARBINARY
MSImage = IMAGE
MSBit = BIT
MSMoney = MONEY
MSSmallMoney = SMALLMONEY
MSUniqueIdentifier = UNIQUEIDENTIFIER
MSVariant = SQL_VARIANT

ischema_names = {
 #int": INTEGER,
 #bigint": BIGINT,
 #smallint": SMALLINT,
 #tinyint": TINYINT,
 #varchar": VARCHAR,
 #nvarchar": NVARCHAR,
 #char": CHAR,
 #nchar": NCHAR,
 #text": TEXT,
 #ntext": NTEXT,
 #decimal": DECIMAL,
 #numeric": NUMERIC,
 #float": FLOAT,
 #datetime": DATETIME,
 #datetime2": DATETIME2,
 #datetimeoffset": DATETIMEOFFSET,
 #date": DATE,
 #time": TIME,
 #smalldatetime": SMALLDATETIME,
 #binary": BINARY,
 #varbinary": VARBINARY,
 #bit": BIT,
 #real": REAL,
 #image": IMAGE,
 #xml": XML,
 #timestamp": TIMESTAMP,
 #money": MONEY,
 #smallmoney": SMALLMONEY,
 #uniqueidentifier": UNIQUEIDENTIFIER,
 #sql_variant": SQL_VARIANT,
}


class MSTypeCompiler(compiler.GenericTypeCompiler):
 #ef _extend(self, spec, type_, length=None):
 #""Extend a string-type declaration with standard SQL
 #OLLATE annotations.

 #""

 #f getattr(type_, "collation", None):
 #ollation = "COLLATE %s" % type_.collation
 #lse:
 #ollation = None

 #f not length:
 #ength = type_.length

 #f length:
 #pec = spec + "(%s)" % length

 #eturn " ".join([c for c in (spec, collation) if c is not None])

 #ef visit_FLOAT(self, type_, **kw):
 #recision = getattr(type_, "precision", None)
 #f precision is None:
 #eturn "FLOAT"
 #lse:
 #eturn "FLOAT(%(precision)s)" % {"precision": precision}

 #ef visit_TINYINT(self, type_, **kw):
 #eturn "TINYINT"

 #ef visit_TIME(self, type_, **kw):
 #recision = getattr(type_, "precision", None)
 #f precision is not None:
 #eturn "TIME(%s)" % precision
 #lse:
 #eturn "TIME"

 #ef visit_TIMESTAMP(self, type_, **kw):
 #eturn "TIMESTAMP"

 #ef visit_ROWVERSION(self, type_, **kw):
 #eturn "ROWVERSION"

 #ef visit_datetime(self, type_, **kw):
 #f type_.timezone:
 #eturn self.visit_DATETIMEOFFSET(type_, **kw)
 #lse:
 #eturn self.visit_DATETIME(type_, **kw)

 #ef visit_DATETIMEOFFSET(self, type_, **kw):
 #recision = getattr(type_, "precision", None)
 #f precision is not None:
 #eturn "DATETIMEOFFSET(%s)" % type_.precision
 #lse:
 #eturn "DATETIMEOFFSET"

 #ef visit_DATETIME2(self, type_, **kw):
 #recision = getattr(type_, "precision", None)
 #f precision is not None:
 #eturn "DATETIME2(%s)" % precision
 #lse:
 #eturn "DATETIME2"

 #ef visit_SMALLDATETIME(self, type_, **kw):
 #eturn "SMALLDATETIME"

 #ef visit_unicode(self, type_, **kw):
 #eturn self.visit_NVARCHAR(type_, **kw)

 #ef visit_text(self, type_, **kw):
 #f self.dialect.deprecate_large_types:
 #eturn self.visit_VARCHAR(type_, **kw)
 #lse:
 #eturn self.visit_TEXT(type_, **kw)

 #ef visit_unicode_text(self, type_, **kw):
 #f self.dialect.deprecate_large_types:
 #eturn self.visit_NVARCHAR(type_, **kw)
 #lse:
 #eturn self.visit_NTEXT(type_, **kw)

 #ef visit_NTEXT(self, type_, **kw):
 #eturn self._extend("NTEXT", type_)

 #ef visit_TEXT(self, type_, **kw):
 #eturn self._extend("TEXT", type_)

 #ef visit_VARCHAR(self, type_, **kw):
 #eturn self._extend("VARCHAR", type_, length=type_.length or "max")

 #ef visit_CHAR(self, type_, **kw):
 #eturn self._extend("CHAR", type_)

 #ef visit_NCHAR(self, type_, **kw):
 #eturn self._extend("NCHAR", type_)

 #ef visit_NVARCHAR(self, type_, **kw):
 #eturn self._extend("NVARCHAR", type_, length=type_.length or "max")

 #ef visit_date(self, type_, **kw):
 #f self.dialect.server_version_info < MS_2008_VERSION:
 #eturn self.visit_DATETIME(type_, **kw)
 #lse:
 #eturn self.visit_DATE(type_, **kw)

 #ef visit_time(self, type_, **kw):
 #f self.dialect.server_version_info < MS_2008_VERSION:
 #eturn self.visit_DATETIME(type_, **kw)
 #lse:
 #eturn self.visit_TIME(type_, **kw)

 #ef visit_large_binary(self, type_, **kw):
 #f self.dialect.deprecate_large_types:
 #eturn self.visit_VARBINARY(type_, **kw)
 #lse:
 #eturn self.visit_IMAGE(type_, **kw)

 #ef visit_IMAGE(self, type_, **kw):
 #eturn "IMAGE"

 #ef visit_XML(self, type_, **kw):
 #eturn "XML"

 #ef visit_VARBINARY(self, type_, **kw):
 #eturn self._extend("VARBINARY", type_, length=type_.length or "max")

 #ef visit_boolean(self, type_, **kw):
 #eturn self.visit_BIT(type_)

 #ef visit_BIT(self, type_, **kw):
 #eturn "BIT"

 #ef visit_JSON(self, type_, **kw):
        # this is a bit of a break with SQLAlchemy's convention of
        # "UPPERCASE name goes to UPPERCASE type name with no modification"
 #eturn self._extend("NVARCHAR", type_, length="max")

 #ef visit_MONEY(self, type_, **kw):
 #eturn "MONEY"

 #ef visit_SMALLMONEY(self, type_, **kw):
 #eturn "SMALLMONEY"

 #ef visit_UNIQUEIDENTIFIER(self, type_, **kw):
 #eturn "UNIQUEIDENTIFIER"

 #ef visit_SQL_VARIANT(self, type_, **kw):
 #eturn "SQL_VARIANT"


class MSExecutionContext(default.DefaultExecutionContext):
 #enable_identity_insert = False
 #select_lastrowid = False
 #lastrowid = None
 #rowcount = None
 #result_strategy = None

 #ef _opt_encode(self, statement):

 #f not self.dialect.supports_unicode_statements:
 #ncoded = self.dialect._encoder(statement)[0]
 #lse:
 #ncoded = statement

 #f self.compiled and self.compiled.schema_translate_map:

 #st = self.compiled.preparer._render_schema_translates
 #ncoded = rst(encoded, self.compiled.schema_translate_map)

 #eturn encoded

 #ef pre_exec(self):
 #""Activate IDENTITY_INSERT if needed."""

 #f self.isinsert:
 #bl = self.compiled.compile_state.dml_table
 #d_column = tbl._autoincrement_column
 #nsert_has_identity = (id_column is not None) and (
 #ot isinstance(id_column.default, Sequence)
 #

 #f insert_has_identity:
 #ompile_state = self.compiled.compile_state
 #elf._enable_identity_insert = (
 #d_column.key in self.compiled_parameters[0]
 # or (
 #ompile_state._dict_parameters
 #nd (
 #d_column.key in compile_state._dict_parameters
 #r id_column in compile_state._dict_parameters
 #
 #

 #lse:
 #elf._enable_identity_insert = False

 #elf._select_lastrowid = (
 #ot self.compiled.inline
 #nd insert_has_identity
 #nd not self.compiled.returning
 #nd not self._enable_identity_insert
 #nd not self.executemany
 #

 #f self._enable_identity_insert:
 #elf.root_connection._cursor_execute(
 #elf.cursor,
 #elf._opt_encode(
 #SET IDENTITY_INSERT %s ON"
 # self.identifier_preparer.format_table(tbl)
 #,
 #),
 #elf,
 #

 #ef post_exec(self):
 #""Disable IDENTITY_INSERT if enabled."""

 #onn = self.root_connection

 #f self.isinsert or self.isupdate or self.isdelete:
 #elf._rowcount = self.cursor.rowcount

 #f self._select_lastrowid:
 #f self.dialect.use_scope_identity:
 #onn._cursor_execute(
 #elf.cursor,
 #SELECT scope_identity() AS lastrowid",
 #),
 #elf,
 #
 #lse:
 #onn._cursor_execute(
 #elf.cursor, "SELECT @@identity AS lastrowid", (), self
 #
            # fetchall() ensures the cursor is consumed without closing it
 #ow = self.cursor.fetchall()[0]
 #elf._lastrowid = int(row[0])

 #lif (
 #elf.isinsert or self.isupdate or self.isdelete
 # and self.compiled.returning:
 #elf.cursor_fetch_strategy = (
 #cursor.FullyBufferedCursorFetchStrategy(
 #elf.cursor,
 #elf.cursor.description,
 #elf.cursor.fetchall(),
 #
 #

 #f self._enable_identity_insert:
 #onn._cursor_execute(
 #elf.cursor,
 #elf._opt_encode(
 #SET IDENTITY_INSERT %s OFF"
 # self.identifier_preparer.format_table(
 #elf.compiled.compile_state.dml_table
 #
 #,
 #),
 #elf,
 #

 #ef get_lastrowid(self):
 #eturn self._lastrowid

 #property
 #ef rowcount(self):
 #f self._rowcount is not None:
 #eturn self._rowcount
 #lse:
 #eturn self.cursor.rowcount

 #ef handle_dbapi_exception(self, e):
 #f self._enable_identity_insert:
 #ry:
 #elf.cursor.execute(
 #elf._opt_encode(
 #SET IDENTITY_INSERT %s OFF"
 # self.identifier_preparer.format_table(
 #elf.compiled.compile_state.dml_table
 #
 #
 #
 #xcept Exception:
 #ass

 #ef get_result_cursor_strategy(self, result):
 #f self._result_strategy:
 #eturn self._result_strategy
 #lse:
 #eturn super(MSExecutionContext, self).get_result_cursor_strategy(
 #esult
 #

 #ef fire_sequence(self, seq, type_):
 #eturn self._execute_scalar(
 #
 #SELECT NEXT VALUE FOR %s"
 # self.identifier_preparer.format_sequence(seq)
 #,
 #ype_,
 #

 #ef get_insert_default(self, column):
 #f (
 #sinstance(column, sa_schema.Column)
 #nd column is column.table._autoincrement_column
 #nd isinstance(column.default, sa_schema.Sequence)
 #nd column.default.optional
 #:
 #eturn None
 #eturn super(MSExecutionContext, self).get_insert_default(column)


class MSSQLCompiler(compiler.SQLCompiler):
 #eturning_precedes_values = True

 #xtract_map = util.update_copy(
 #ompiler.SQLCompiler.extract_map,
 #
 #doy": "dayofyear",
 #dow": "weekday",
 #milliseconds": "millisecond",
 #microseconds": "microsecond",
 #,
 #

 #ef __init__(self, *args, **kwargs):
 #elf.tablealiases = {}
 #uper(MSSQLCompiler, self).__init__(*args, **kwargs)

 #ef _with_legacy_schema_aliasing(fn):
 #ef decorate(self, *arg, **kw):
 #f self.dialect.legacy_schema_aliasing:
 #eturn fn(self, *arg, **kw)
 #lse:
 #uper_ = getattr(super(MSSQLCompiler, self), fn.__name__)
 #eturn super_(*arg, **kw)

 #eturn decorate

 #ef visit_now_func(self, fn, **kw):
 #eturn "CURRENT_TIMESTAMP"

 #ef visit_current_date_func(self, fn, **kw):
 #eturn "GETDATE()"

 #ef visit_length_func(self, fn, **kw):
 #eturn "LEN%s" % self.function_argspec(fn, **kw)

 #ef visit_char_length_func(self, fn, **kw):
 #eturn "LEN%s" % self.function_argspec(fn, **kw)

 #ef visit_concat_op_binary(self, binary, operator, **kw):
 #eturn "%s + %s" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef visit_true(self, expr, **kw):
 #eturn "1"

 #ef visit_false(self, expr, **kw):
 #eturn "0"

 #ef visit_match_op_binary(self, binary, operator, **kw):
 #eturn "CONTAINS (%s, %s)" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef get_select_precolumns(self, select, **kw):
 #""MS-SQL puts TOP, it's version of LIMIT here"""

 # = super(MSSQLCompiler, self).get_select_precolumns(select, **kw)

 #f select._has_row_limiting_clause and self._use_top(select):
            # ODBC drivers and possibly others
            # don't support bind params in the SELECT clause on SQL Server.
            # so have to use literal here.
 #w["literal_execute"] = True
 # += "TOP %s " % self.process(
 #elf._get_limit_or_fetch(select), **kw
 #
 #f select._fetch_clause is not None:
 #f select._fetch_clause_options["percent"]:
 # += "PERCENT "
 #f select._fetch_clause_options["with_ties"]:
 # += "WITH TIES "

 #eturn s

 #ef get_from_hint_text(self, table, text):
 #eturn text

 #ef get_crud_hint_text(self, table, text):
 #eturn text

 #ef _get_limit_or_fetch(self, select):
 #f select._fetch_clause is None:
 #eturn select._limit_clause
 #lse:
 #eturn select._fetch_clause

 #ef _use_top(self, select):
 #eturn (select._offset_clause is None) and (
 #elect._simple_int_clause(select._limit_clause)
 #r (
                # limit can use TOP with is by itself. fetch only uses TOP
                # when it needs to because of PERCENT and/or WITH TIES
 #elect._simple_int_clause(select._fetch_clause)
 #nd (
 #elect._fetch_clause_options["percent"]
 #r select._fetch_clause_options["with_ties"]
 #
 #
 #

 #ef fetch_clause(self, cs, **kwargs):
 #eturn ""

 #ef limit_clause(self, cs, **kwargs):
 #eturn ""

 #ef _check_can_use_fetch_limit(self, select):
        # to use ROW_NUMBER(), an ORDER BY is required.
        # OFFSET are FETCH are options of the ORDER BY clause
 #f not select._order_by_clause.clauses:
 #aise exc.CompileError(
 #MSSQL requires an order_by when "
 #using an OFFSET or a non-simple "
 #LIMIT clause"
 #

 #f select._fetch_clause_options is not None and (
 #elect._fetch_clause_options["percent"]
 #r select._fetch_clause_options["with_ties"]
 #:
 #aise exc.CompileError(
 #MSSQL needs TOP to use PERCENT and/or WITH TIES. "
 #Only simple fetch without offset can be used."
 #

 #ef _row_limit_clause(self, select, **kw):
 #""MSSQL 2012 supports OFFSET/FETCH operators
 #se it instead subquery with row_number

 #""

 #f self.dialect._supports_offset_fetch and not self._use_top(select):
 #elf._check_can_use_fetch_limit(select)

 #ext = ""

 #f select._offset_clause is not None:
 #ffset_str = self.process(select._offset_clause, **kw)
 #lse:
 #ffset_str = "0"
 #ext += "\n OFFSET %s ROWS" % offset_str

 #imit = self._get_limit_or_fetch(select)

 #f limit is not None:
 #ext += "\n FETCH FIRST %s ROWS ONLY" % self.process(
 #imit, **kw
 #
 #eturn text
 #lse:
 #eturn ""

 #ef visit_try_cast(self, element, **kw):
 #eturn "TRY_CAST (%s AS %s)" % (
 #elf.process(element.clause, **kw),
 #elf.process(element.typeclause, **kw),
 #

 #ef translate_select_structure(self, select_stmt, **kwargs):
 #""Look for ``LIMIT`` and OFFSET in a select statement, and if
 #o tries to wrap it in a subquery with ``row_number()`` criterion.
 #SSQL 2012 and above are excluded

 #""
 #elect = select_stmt

 #f (
 #elect._has_row_limiting_clause
 #nd not self.dialect._supports_offset_fetch
 #nd not self._use_top(select)
 #nd not getattr(select, "_mssql_visit", None)
 #:
 #elf._check_can_use_fetch_limit(select)

 #order_by_clauses = [
 #ql_util.unwrap_label_reference(elem)
 #or elem in select._order_by_clause.clauses
 #

 #imit_clause = self._get_limit_or_fetch(select)
 #ffset_clause = select._offset_clause

 #elect = select._generate()
 #elect._mssql_visit = True
 #elect = (
 #elect.add_columns(
 #ql.func.ROW_NUMBER()
 #over(order_by=_order_by_clauses)
 #label("mssql_rn")
 #
 #order_by(None)
 #alias()
 #

 #ssql_rn = sql.column("mssql_rn")
 #imitselect = sql.select(
 #[c for c in select.c if c.key != "mssql_rn"]
 #
 #f offset_clause is not None:
 #imitselect = limitselect.where(mssql_rn > offset_clause)
 #f limit_clause is not None:
 #imitselect = limitselect.where(
 #ssql_rn <= (limit_clause + offset_clause)
 #
 #lse:
 #imitselect = limitselect.where(mssql_rn <= (limit_clause))
 #eturn limitselect
 #lse:
 #eturn select

 #_with_legacy_schema_aliasing
 #ef visit_table(self, table, mssql_aliased=False, iscrud=False, **kwargs):
 #f mssql_aliased is table or iscrud:
 #eturn super(MSSQLCompiler, self).visit_table(table, **kwargs)

        # alias schema-qualified tables
 #lias = self._schema_aliased_table(table)
 #f alias is not None:
 #eturn self.process(alias, mssql_aliased=table, **kwargs)
 #lse:
 #eturn super(MSSQLCompiler, self).visit_table(table, **kwargs)

 #_with_legacy_schema_aliasing
 #ef visit_alias(self, alias, **kw):
        # translate for schema-qualified table aliases
 #w["mssql_aliased"] = alias.element
 #eturn super(MSSQLCompiler, self).visit_alias(alias, **kw)

 #_with_legacy_schema_aliasing
 #ef visit_column(self, column, add_to_result_map=None, **kw):
 #f (
 #olumn.table is not None
 #nd (not self.isupdate and not self.isdelete)
 #r self.is_subquery()
 #:
            # translate for schema-qualified table aliases
 # = self._schema_aliased_table(column.table)
 #f t is not None:
 #onverted = elements._corresponding_column_or_error(t, column)
 #f add_to_result_map is not None:
 #dd_to_result_map(
 #olumn.name,
 #olumn.name,
 #column, column.name, column.key),
 #olumn.type,
 #

 #eturn super(MSSQLCompiler, self).visit_column(converted, **kw)

 #eturn super(MSSQLCompiler, self).visit_column(
 #olumn, add_to_result_map=add_to_result_map, **kw
 #

 #ef _schema_aliased_table(self, table):
 #f getattr(table, "schema", None) is not None:
 #f table not in self.tablealiases:
 #elf.tablealiases[table] = table.alias()
 #eturn self.tablealiases[table]
 #lse:
 #eturn None

 #ef visit_extract(self, extract, **kw):
 #ield = self.extract_map.get(extract.field, extract.field)
 #eturn "DATEPART(%s, %s)" % (field, self.process(extract.expr, **kw))

 #ef visit_savepoint(self, savepoint_stmt):
 #eturn "SAVE TRANSACTION %s" % self.preparer.format_savepoint(
 #avepoint_stmt
 #

 #ef visit_rollback_to_savepoint(self, savepoint_stmt):
 #eturn "ROLLBACK TRANSACTION %s" % self.preparer.format_savepoint(
 #avepoint_stmt
 #

 #ef visit_binary(self, binary, **kwargs):
 #""Move bind parameters to the right-hand side of an operator, where
 #ossible.

 #""
 #f (
 #sinstance(binary.left, expression.BindParameter)
 #nd binary.operator == operator.eq
 #nd not isinstance(binary.right, expression.BindParameter)
 #:
 #eturn self.process(
 #xpression.BinaryExpression(
 #inary.right, binary.left, binary.operator
 #,
 #*kwargs
 #
 #eturn super(MSSQLCompiler, self).visit_binary(binary, **kwargs)

 #ef returning_clause(self, stmt, returning_cols):
        # SQL server returning clause requires that the columns refer to
        # the virtual table names "inserted" or "deleted".   Here, we make
        # a simple alias of our table with that name, and then adapt the
        # columns we have from the list of RETURNING columns to that new name
        # so that they render as "inserted.<colname>" / "deleted.<colname>".

 #f self.isinsert or self.isupdate:
 #arget = stmt.table.alias("inserted")
 #lse:
 #arget = stmt.table.alias("deleted")

 #dapter = sql_util.ClauseAdapter(target)

        # adapter.traverse() takes a column from our target table and returns
        # the one that is linked to the "inserted" / "deleted" tables.  So  in
        # order to retrieve these values back from the result  (e.g. like
        # row[column]), tell the compiler to also add the original unadapted
        # column to the result map.   Before #4877, these were  (unknowingly)
        # falling back using string name matching in the result set which
        # necessarily used an expensive KeyError in order to match.

 #olumns = [
 #elf._label_returning_column(
 #tmt,
 #dapter.traverse(c),
 #"result_map_targets": (c,)},
 #
 #or c in expression._select_iterables(returning_cols)
 #

 #eturn "OUTPUT " + ", ".join(columns)

 #ef get_cte_preamble(self, recursive):
        # SQL Server finds it too inconvenient to accept
        # an entirely optional, SQL standard specified,
        # "RECURSIVE" word with their "WITH",
        # so here we go
 #eturn "WITH"

 #ef label_select_column(self, select, column, asfrom):
 #f isinstance(column, expression.Function):
 #eturn column.label(None)
 #lse:
 #eturn super(MSSQLCompiler, self).label_select_column(
 #elect, column, asfrom
 #

 #ef for_update_clause(self, select, **kw):
        # "FOR UPDATE" is only allowed on "DECLARE CURSOR" which
        # SQLAlchemy doesn't use
 #eturn ""

 #ef order_by_clause(self, select, **kw):
        # MSSQL only allows ORDER BY in subqueries if there is a LIMIT
 #f (
 #elf.is_subquery()
 #nd not select._limit
 #nd (
 #elect._offset is None
 #r not self.dialect._supports_offset_fetch
 #
 #:
            # avoid processing the order by clause if we won't end up
            # using it, because we don't want all the bind params tacked
            # onto the positional list if that is what the dbapi requires
 #eturn ""

 #rder_by = self.process(select._order_by_clause, **kw)

 #f order_by:
 #eturn " ORDER BY " + order_by
 #lse:
 #eturn ""

 #ef update_from_clause(
 #elf, update_stmt, from_table, extra_froms, from_hints, **kw
 #:
 #""Render the UPDATE..FROM clause specific to MSSQL.

 #n MSSQL, if the UPDATE statement involves an alias of the table to
 #e updated, then the table itself must be added to the FROM list as
 #ell. Otherwise, it is optional. Here, we add it regardless.

 #""
 #eturn "FROM " + ", ".join(
 #._compiler_dispatch(self, asfrom=True, fromhints=from_hints, **kw)
 #or t in [from_table] + extra_froms
 #

 #ef delete_table_clause(self, delete_stmt, from_table, extra_froms):
 #""If we have extra froms make sure we render any alias as hint."""
 #shint = False
 #f extra_froms:
 #shint = True
 #eturn from_table._compiler_dispatch(
 #elf, asfrom=True, iscrud=True, ashint=ashint
 #

 #ef delete_extra_from_clause(
 #elf, delete_stmt, from_table, extra_froms, from_hints, **kw
 #:
 #""Render the DELETE .. FROM clause specific to MSSQL.

 #es, it has the FROM keyword twice.

 #""
 #eturn "FROM " + ", ".join(
 #._compiler_dispatch(self, asfrom=True, fromhints=from_hints, **kw)
 #or t in [from_table] + extra_froms
 #

 #ef visit_empty_set_expr(self, type_):
 #eturn "SELECT 1 WHERE 1!=1"

 #ef visit_is_distinct_from_binary(self, binary, operator, **kw):
 #eturn "NOT EXISTS (SELECT %s INTERSECT SELECT %s)" % (
 #elf.process(binary.left),
 #elf.process(binary.right),
 #

 #ef visit_is_not_distinct_from_binary(self, binary, operator, **kw):
 #eturn "EXISTS (SELECT %s INTERSECT SELECT %s)" % (
 #elf.process(binary.left),
 #elf.process(binary.right),
 #

 #ef _render_json_extract_from_binary(self, binary, operator, **kw):
        # note we are intentionally calling upon the process() calls in the
        # order in which they appear in the SQL String as this is used
        # by positional parameter rendering

 #f binary.type._type_affinity is sqltypes.JSON:
 #eturn "JSON_QUERY(%s, %s)" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

        # as with other dialects, start with an explicit test for NULL
 #ase_expression = "CASE JSON_VALUE(%s, %s) WHEN NULL THEN NULL" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #f binary.type._type_affinity is sqltypes.Integer:
 #ype_expression = "ELSE CAST(JSON_VALUE(%s, %s) AS INTEGER)" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #
 #lif binary.type._type_affinity is sqltypes.Numeric:
 #ype_expression = "ELSE CAST(JSON_VALUE(%s, %s) AS %s)" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #FLOAT"
 #f isinstance(binary.type, sqltypes.Float)
 #lse "NUMERIC(%s, %s)"
 # (binary.type.precision, binary.type.scale),
 #
 #lif binary.type._type_affinity is sqltypes.Boolean:
            # the NULL handling is particularly weird with boolean, so
            # explicitly return numeric (BIT) constants
 #ype_expression = (
 #WHEN 'true' THEN 1 WHEN 'false' THEN 0 ELSE NULL"
 #
 #lif binary.type._type_affinity is sqltypes.String:
            # TODO: does this comment (from mysql) apply to here, too?
            #       this fails with a JSON value that's a four byte unicode
            #       string.  SQLite has the same problem at the moment
 #ype_expression = "ELSE JSON_VALUE(%s, %s)" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #
 #lse:
            # other affinity....this is not expected right now
 #ype_expression = "ELSE JSON_QUERY(%s, %s)" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #eturn case_expression + " " + type_expression + " END"

 #ef visit_json_getitem_op_binary(self, binary, operator, **kw):
 #eturn self._render_json_extract_from_binary(binary, operator, **kw)

 #ef visit_json_path_getitem_op_binary(self, binary, operator, **kw):
 #eturn self._render_json_extract_from_binary(binary, operator, **kw)

 #ef visit_sequence(self, seq, **kw):
 #eturn "NEXT VALUE FOR %s" % self.preparer.format_sequence(seq)


class MSSQLStrictCompiler(MSSQLCompiler):

 #""A subclass of MSSQLCompiler which disables the usage of bind
 #arameters where not allowed natively by MS-SQL.

 # dialect may use this compiler on a platform where native
 #inds are used.

 #""

 #nsi_bind_rules = True

 #ef visit_in_op_binary(self, binary, operator, **kw):
 #w["literal_execute"] = True
 #eturn "%s IN %s" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef visit_not_in_op_binary(self, binary, operator, **kw):
 #w["literal_execute"] = True
 #eturn "%s NOT IN %s" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef render_literal_value(self, value, type_):
 #""
 #or date and datetime values, convert to a string
 #ormat acceptable to MSSQL. That seems to be the
 #o-called ODBC canonical date format which looks
 #ike this:

 #yyy-mm-dd hh:mi:ss.mmm(24h)

 #or other data types, call the base class implementation.
 #""
        # datetime and date are both subclasses of datetime.date
 #f issubclass(type(value), datetime.date):
            # SQL Server wants single quotes around the date string.
 #eturn "'" + str(value) + "'"
 #lse:
 #eturn super(MSSQLStrictCompiler, self).render_literal_value(
 #alue, type_
 #


class MSDDLCompiler(compiler.DDLCompiler):
 #ef get_column_specification(self, column, **kwargs):
 #olspec = self.preparer.format_column(column)

        # type is not accepted in a computed column
 #f column.computed is not None:
 #olspec += " " + self.process(column.computed)
 #lse:
 #olspec += " " + self.dialect.type_compiler.process(
 #olumn.type, type_expression=column
 #

 #f column.nullable is not None:
 #f (
 #ot column.nullable
 #r column.primary_key
 #r isinstance(column.default, sa_schema.Sequence)
 #r column.autoincrement is True
 #r column.identity
 #:
 #olspec += " NOT NULL"
 #lif column.computed is None:
                # don't specify "NULL" for computed columns
 #olspec += " NULL"

 #f column.table is None:
 #aise exc.CompileError(
 #mssql requires Table-bound columns "
 #in order to generate DDL"
 #

 #_opt = column.dialect_options["mssql"]
 #tart = d_opt["identity_start"]
 #ncrement = d_opt["identity_increment"]
 #f start is not None or increment is not None:
 #f column.identity:
 #aise exc.CompileError(
 #Cannot specify options 'mssql_identity_start' and/or "
 #'mssql_identity_increment' while also using the "
 #'Identity' construct."
 #
 #til.warn_deprecated(
 #The dialect options 'mssql_identity_start' and "
 #'mssql_identity_increment' are deprecated. "
 #Use the 'Identity' object instead.",
 #1.4",
 #

 #f column.identity:
 #olspec += self.process(column.identity, **kwargs)
 #lif (
 #olumn is column.table._autoincrement_column
 #r column.autoincrement is True
 # and (
 #ot isinstance(column.default, Sequence) or column.default.optional
 #:
 #olspec += self.process(Identity(start=start, increment=increment))
 #lse:
 #efault = self.get_column_default_string(column)
 #f default is not None:
 #olspec += " DEFAULT " + default

 #eturn colspec

 #ef visit_create_index(self, create, include_schema=False):
 #ndex = create.element
 #elf._verify_index_table(index)
 #reparer = self.preparer
 #ext = "CREATE "
 #f index.unique:
 #ext += "UNIQUE "

        # handle clustering option
 #lustered = index.dialect_options["mssql"]["clustered"]
 #f clustered is not None:
 #f clustered:
 #ext += "CLUSTERED "
 #lse:
 #ext += "NONCLUSTERED "

 #ext += "INDEX %s ON %s (%s)" % (
 #elf._prepared_index_name(index, include_schema=include_schema),
 #reparer.format_table(index.table),
 #, ".join(
 #elf.sql_compiler.process(
 #xpr, include_table=False, literal_binds=True
 #
 #or expr in index.expressions
 #,
 #

        # handle other included columns
 #f index.dialect_options["mssql"]["include"]:
 #nclusions = [
 #ndex.table.c[col]
 #f isinstance(col, util.string_types)
 #lse col
 #or col in index.dialect_options["mssql"]["include"]
 #

 #ext += " INCLUDE (%s)" % ", ".join(
 #preparer.quote(c.name) for c in inclusions]
 #

 #hereclause = index.dialect_options["mssql"]["where"]

 #f whereclause is not None:
 #hereclause = coercions.expect(
 #oles.DDLExpressionRole, whereclause
 #

 #here_compiled = self.sql_compiler.process(
 #hereclause, include_table=False, literal_binds=True
 #
 #ext += " WHERE " + where_compiled

 #eturn text

 #ef visit_drop_index(self, drop):
 #eturn "\nDROP INDEX %s ON %s" % (
 #elf._prepared_index_name(drop.element, include_schema=False),
 #elf.preparer.format_table(drop.element.table),
 #

 #ef visit_primary_key_constraint(self, constraint):
 #f len(constraint) == 0:
 #eturn ""
 #ext = ""
 #f constraint.name is not None:
 #ext += "CONSTRAINT %s " % self.preparer.format_constraint(
 #onstraint
 #
 #ext += "PRIMARY KEY "

 #lustered = constraint.dialect_options["mssql"]["clustered"]
 #f clustered is not None:
 #f clustered:
 #ext += "CLUSTERED "
 #lse:
 #ext += "NONCLUSTERED "

 #ext += "(%s)" % ", ".join(
 #elf.preparer.quote(c.name) for c in constraint
 #
 #ext += self.define_constraint_deferrability(constraint)
 #eturn text

 #ef visit_unique_constraint(self, constraint):
 #f len(constraint) == 0:
 #eturn ""
 #ext = ""
 #f constraint.name is not None:
 #ormatted_name = self.preparer.format_constraint(constraint)
 #f formatted_name is not None:
 #ext += "CONSTRAINT %s " % formatted_name
 #ext += "UNIQUE "

 #lustered = constraint.dialect_options["mssql"]["clustered"]
 #f clustered is not None:
 #f clustered:
 #ext += "CLUSTERED "
 #lse:
 #ext += "NONCLUSTERED "

 #ext += "(%s)" % ", ".join(
 #elf.preparer.quote(c.name) for c in constraint
 #
 #ext += self.define_constraint_deferrability(constraint)
 #eturn text

 #ef visit_computed_column(self, generated):
 #ext = "AS (%s)" % self.sql_compiler.process(
 #enerated.sqltext, include_table=False, literal_binds=True
 #
        # explicitly check for True|False since None means server default
 #f generated.persisted is True:
 #ext += " PERSISTED"
 #eturn text

 #ef visit_create_sequence(self, create, **kw):
 #refix = None
 #f create.element.data_type is not None:
 #ata_type = create.element.data_type
 #refix = " AS %s" % self.type_compiler.process(data_type)
 #eturn super(MSDDLCompiler, self).visit_create_sequence(
 #reate, prefix=prefix, **kw
 #

 #ef visit_identity_column(self, identity, **kw):
 #ext = " IDENTITY"
 #f identity.start is not None or identity.increment is not None:
 #tart = 1 if identity.start is None else identity.start
 #ncrement = 1 if identity.increment is None else identity.increment
 #ext += "(%s,%s)" % (start, increment)
 #eturn text


class MSIdentifierPreparer(compiler.IdentifierPreparer):
 #eserved_words = RESERVED_WORDS

 #ef __init__(self, dialect):
 #uper(MSIdentifierPreparer, self).__init__(
 #ialect,
 #nitial_quote="[",
 #inal_quote="]",
 #uote_case_sensitive_collations=False,
 #

 #ef _escape_identifier(self, value):
 #eturn value.replace("]", "]]")

 #ef _unescape_identifier(self, value):
 #eturn value.replace("]]", "]")

 #ef quote_schema(self, schema, force=None):
 #""Prepare a quoted table and schema name."""

        # need to re-implement the deprecation warning entirely
 #f force is not None:
            # not using the util.deprecated_params() decorator in this
            # case because of the additional function call overhead on this
            # very performance-critical spot.
 #til.warn_deprecated(
 #The IdentifierPreparer.quote_schema.force parameter is "
 #deprecated and will be removed in a future release.  This "
 #flag has no effect on the behavior of the "
 #IdentifierPreparer.quote method; please refer to "
 #quoted_name().",
 #ersion="1.3",
 #

 #bname, owner = _schema_elements(schema)
 #f dbname:
 #esult = "%s.%s" % (self.quote(dbname), self.quote(owner))
 #lif owner:
 #esult = self.quote(owner)
 #lse:
 #esult = ""
 #eturn result


def _db_plus_owner_listing(fn):
 #ef wrap(dialect, connection, schema=None, **kw):
 #bname, owner = _owner_plus_db(dialect, schema)
 #eturn _switch_db(
 #bname,
 #onnection,
 #n,
 #ialect,
 #onnection,
 #bname,
 #wner,
 #chema,
 #*kw
 #

 #eturn update_wrapper(wrap, fn)


def _db_plus_owner(fn):
 #ef wrap(dialect, connection, tablename, schema=None, **kw):
 #bname, owner = _owner_plus_db(dialect, schema)
 #eturn _switch_db(
 #bname,
 #onnection,
 #n,
 #ialect,
 #onnection,
 #ablename,
 #bname,
 #wner,
 #chema,
 #*kw
 #

 #eturn update_wrapper(wrap, fn)


def _switch_db(dbname, connection, fn, *arg, **kw):
 #f dbname:
 #urrent_db = connection.exec_driver_sql("select db_name()").scalar()
 #f current_db != dbname:
 #onnection.exec_driver_sql(
 #use %s" % connection.dialect.identifier_preparer.quote(dbname)
 #
 #ry:
 #eturn fn(*arg, **kw)
 #inally:
 #f dbname and current_db != dbname:
 #onnection.exec_driver_sql(
 #use %s"
 # connection.dialect.identifier_preparer.quote(current_db)
 #


def _owner_plus_db(dialect, schema):
 #f not schema:
 #eturn None, dialect.default_schema_name
 #lif "." in schema:
 #eturn _schema_elements(schema)
 #lse:
 #eturn None, schema


_memoized_schema = util.LRUCache()


def _schema_elements(schema):
 #f isinstance(schema, quoted_name) and schema.quote:
 #eturn None, schema

 #f schema in _memoized_schema:
 #eturn _memoized_schema[schema]

    # tests for this function are in:
    # test/dialect/mssql/test_reflection.py ->
    #           OwnerPlusDBTest.test_owner_database_pairs
    # test/dialect/mssql/test_compiler.py -> test_force_schema_*
    # test/dialect/mssql/test_compiler.py -> test_schema_many_tokens_*
    #

 #ush = []
 #ymbol = ""
 #racket = False
 #as_brackets = False
 #or token in re.split(r"(\[|\]|\.)", schema):
 #f not token:
 #ontinue
 #f token == "[":
 #racket = True
 #as_brackets = True
 #lif token == "]":
 #racket = False
 #lif not bracket and token == ".":
 #f has_brackets:
 #ush.append("[%s]" % symbol)
 #lse:
 #ush.append(symbol)
 #ymbol = ""
 #as_brackets = False
 #lse:
 #ymbol += token
 #f symbol:
 #ush.append(symbol)
 #f len(push) > 1:
 #bname, owner = ".".join(push[0:-1]), push[-1]

        # test for internal brackets
 #f re.match(r".*\].*\[.*", dbname[1:-1]):
 #bname = quoted_name(dbname, quote=False)
 #lse:
 #bname = dbname.lstrip("[").rstrip("]")

 #lif len(push):
 #bname, owner = None, push[0]
 #lse:
 #bname, owner = None, None

 #memoized_schema[schema] = dbname, owner
 #eturn dbname, owner


class MSDialect(default.DefaultDialect):
    # will assume it's at least mssql2005
 #ame = "mssql"
 #upports_statement_cache = True
 #upports_default_values = True
 #upports_empty_insert = False
 #xecution_ctx_cls = MSExecutionContext
 #se_scope_identity = True
 #ax_identifier_length = 128
 #chema_name = "dbo"

 #mplicit_returning = True
 #ull_returning = True

 #olspecs = {
 #qltypes.DateTime: _MSDateTime,
 #qltypes.Date: _MSDate,
 #qltypes.JSON: JSON,
 #qltypes.JSON.JSONIndexType: JSONIndexType,
 #qltypes.JSON.JSONPathType: JSONPathType,
 #qltypes.Time: TIME,
 #qltypes.Unicode: _MSUnicode,
 #qltypes.UnicodeText: _MSUnicodeText,
 #

 #ngine_config_types = default.DefaultDialect.engine_config_types.union(
 #"legacy_schema_aliasing": util.asbool}
 #

 #schema_names = ischema_names

 #upports_sequences = True
 #equences_optional = True
    # T-SQL's actual default is -9223372036854775808
 #efault_sequence_base = 1

 #upports_native_boolean = False
 #on_native_boolean_check_constraint = False
 #upports_unicode_binds = True
 #ostfetch_lastrowid = True
 #supports_offset_fetch = False
 #supports_nvarchar_max = False

 #egacy_schema_aliasing = False

 #erver_version_info = ()

 #tatement_compiler = MSSQLCompiler
 #dl_compiler = MSDDLCompiler
 #ype_compiler = MSTypeCompiler
 #reparer = MSIdentifierPreparer

 #onstruct_arguments = [
 #sa_schema.PrimaryKeyConstraint, {"clustered": None}),
 #sa_schema.UniqueConstraint, {"clustered": None}),
 #sa_schema.Index, {"clustered": None, "include": None, "where": None}),
 #
 #a_schema.Column,
 #"identity_start": None, "identity_increment": None},
 #,
 #

 #ef __init__(
 #elf,
 #uery_timeout=None,
 #se_scope_identity=True,
 #chema_name="dbo",
 #solation_level=None,
 #eprecate_large_types=None,
 #son_serializer=None,
 #son_deserializer=None,
 #egacy_schema_aliasing=None,
 #*opts
 #:
 #elf.query_timeout = int(query_timeout or 0)
 #elf.schema_name = schema_name

 #elf.use_scope_identity = use_scope_identity
 #elf.deprecate_large_types = deprecate_large_types

 #f legacy_schema_aliasing is not None:
 #til.warn_deprecated(
 #The legacy_schema_aliasing parameter is "
 #deprecated and will be removed in a future release.",
 #1.4",
 #
 #elf.legacy_schema_aliasing = legacy_schema_aliasing

 #uper(MSDialect, self).__init__(**opts)

 #elf.isolation_level = isolation_level
 #elf._json_serializer = json_serializer
 #elf._json_deserializer = json_deserializer

 #ef do_savepoint(self, connection, name):
        # give the DBAPI a push
 #onnection.exec_driver_sql("IF @@TRANCOUNT = 0 BEGIN TRANSACTION")
 #uper(MSDialect, self).do_savepoint(connection, name)

 #ef do_release_savepoint(self, connection, name):
        # SQL Server does not support RELEASE SAVEPOINT
 #ass

 #isolation_lookup = set(
 #
 #SERIALIZABLE",
 #READ UNCOMMITTED",
 #READ COMMITTED",
 #REPEATABLE READ",
 #SNAPSHOT",
 #
 #

 #ef set_isolation_level(self, connection, level):
 #evel = level.replace("_", " ")
 #f level not in self._isolation_lookup:
 #aise exc.ArgumentError(
 #Invalid value '%s' for isolation_level. "
 #Valid isolation levels for %s are %s"
 # (level, self.name, ", ".join(self._isolation_lookup))
 #
 #ursor = connection.cursor()
 #ursor.execute("SET TRANSACTION ISOLATION LEVEL %s" % level)
 #ursor.close()
 #f level == "SNAPSHOT":
 #onnection.commit()

 #ef get_isolation_level(self, connection):
 #ast_error = None

 #iews = ("sys.dm_exec_sessions", "sys.dm_pdw_nodes_exec_sessions")
 #or view in views:
 #ursor = connection.cursor()
 #ry:
 #ursor.execute(
 #""
 #ELECT CASE transaction_isolation_level
 #HEN 0 THEN NULL
 #HEN 1 THEN 'READ UNCOMMITTED'
 #HEN 2 THEN 'READ COMMITTED'
 #HEN 3 THEN 'REPEATABLE READ'
 #HEN 4 THEN 'SERIALIZABLE'
 #HEN 5 THEN 'SNAPSHOT' END AS TRANSACTION_ISOLATION_LEVEL
 #ROM %s
 #here session_id = @@SPID
 #""
 # view
 #
 #al = cursor.fetchone()[0]
 #xcept self.dbapi.Error as err:
                # Python3 scoping rules
 #ast_error = err
 #ontinue
 #lse:
 #eturn val.upper()
 #inally:
 #ursor.close()
 #lse:
            # note that the NotImplementedError is caught by
            # DefaultDialect, so the warning here is all that displays
 #til.warn(
 #Could not fetch transaction isolation level, "
 #tried views: %s; final error was: %s" % (views, last_error)
 #
 #aise NotImplementedError(
 #Can't fetch isolation level on this particular "
 #SQL Server version. tried views: %s; final error was: %s"
 # (views, last_error)
 #

 #ef initialize(self, connection):
 #uper(MSDialect, self).initialize(connection)
 #elf._setup_version_attributes()
 #elf._setup_supports_nvarchar_max(connection)

 #ef on_connect(self):
 #f self.isolation_level is not None:

 #ef connect(conn):
 #elf.set_isolation_level(conn, self.isolation_level)

 #eturn connect
 #lse:
 #eturn None

 #ef _setup_version_attributes(self):
 #f self.server_version_info[0] not in list(range(8, 17)):
 #til.warn(
 #Unrecognized server version info '%s'.  Some SQL Server "
 #features may not function properly."
 # ".".join(str(x) for x in self.server_version_info)
 #

 #f self.server_version_info >= MS_2008_VERSION:
 #elf.supports_multivalues_insert = True
 #f self.deprecate_large_types is None:
 #elf.deprecate_large_types = (
 #elf.server_version_info >= MS_2012_VERSION
 #

 #elf._supports_offset_fetch = (
 #elf.server_version_info and self.server_version_info[0] >= 11
 #

 #ef _setup_supports_nvarchar_max(self, connection):
 #ry:
 #onnection.scalar(
 #ql.text("SELECT CAST('test max support' AS NVARCHAR(max))")
 #
 #xcept exc.DBAPIError:
 #elf._supports_nvarchar_max = False
 #lse:
 #elf._supports_nvarchar_max = True

 #ef _get_default_schema_name(self, connection):
 #uery = sql.text("SELECT schema_name()")
 #efault_schema_name = connection.scalar(query)
 #f default_schema_name is not None:
            # guard against the case where the default_schema_name is being
            # fed back into a table reflection function.
 #eturn quoted_name(default_schema_name, quote=True)
 #lse:
 #eturn self.schema_name

 #_db_plus_owner
 #ef has_table(self, connection, tablename, dbname, owner, schema):
 #elf._ensure_has_table_connection(connection)
 #f tablename.startswith("#"):  # temporary table
 #ables = ischema.mssql_temp_table_columns

 # = sql.select(tables.c.table_name).where(
 #ables.c.table_name.like(
 #elf._temp_table_name_like_pattern(tablename)
 #
 #

 #esult = connection.execute(s.limit(1))
 #eturn result.scalar() is not None
 #lse:
 #ables = ischema.tables

 # = sql.select(tables.c.table_name).where(
 #ql.and_(
 #ables.c.table_type == "BASE TABLE",
 #ables.c.table_name == tablename,
 #
 #

 #f owner:
 # = s.where(tables.c.table_schema == owner)

 # = connection.execute(s)

 #eturn c.first() is not None

 #_db_plus_owner
 #ef has_sequence(self, connection, sequencename, dbname, owner, schema):
 #equences = ischema.sequences

 # = sql.select(sequences.c.sequence_name).where(
 #equences.c.sequence_name == sequencename
 #

 #f owner:
 # = s.where(sequences.c.sequence_schema == owner)

 # = connection.execute(s)

 #eturn c.first() is not None

 #reflection.cache
 #_db_plus_owner_listing
 #ef get_sequence_names(self, connection, dbname, owner, schema, **kw):
 #equences = ischema.sequences

 # = sql.select(sequences.c.sequence_name)
 #f owner:
 # = s.where(sequences.c.sequence_schema == owner)

 # = connection.execute(s)

 #eturn [row[0] for row in c]

 #reflection.cache
 #ef get_schema_names(self, connection, **kw):
 # = sql.select(ischema.schemata.c.schema_name).order_by(
 #schema.schemata.c.schema_name
 #
 #chema_names = [r[0] for r in connection.execute(s)]
 #eturn schema_names

 #reflection.cache
 #_db_plus_owner_listing
 #ef get_table_names(self, connection, dbname, owner, schema, **kw):
 #ables = ischema.tables
 # = (
 #ql.select(tables.c.table_name)
 #where(
 #ql.and_(
 #ables.c.table_schema == owner,
 #ables.c.table_type == "BASE TABLE",
 #
 #
 #order_by(tables.c.table_name)
 #
 #able_names = [r[0] for r in connection.execute(s)]
 #eturn table_names

 #reflection.cache
 #_db_plus_owner_listing
 #ef get_view_names(self, connection, dbname, owner, schema, **kw):
 #ables = ischema.tables
 # = (
 #ql.select(tables.c.table_name)
 #where(
 #ql.and_(
 #ables.c.table_schema == owner,
 #ables.c.table_type == "VIEW",
 #
 #
 #order_by(tables.c.table_name)
 #
 #iew_names = [r[0] for r in connection.execute(s)]
 #eturn view_names

 #reflection.cache
 #_db_plus_owner
 #ef get_indexes(self, connection, tablename, dbname, owner, schema, **kw):
 #ilter_definition = (
 #ind.filter_definition"
 #f self.server_version_info >= MS_2008_VERSION
 #lse "NULL as filter_definition"
 #
 #p = connection.execution_options(future_result=True).execute(
 #ql.text(
 #select ind.index_id, ind.is_unique, ind.name, "
 #%s "
 #from sys.indexes as ind join sys.tables as tab on "
 #ind.object_id=tab.object_id "
 #join sys.schemas as sch on sch.schema_id=tab.schema_id "
 #where tab.name = :tabname "
 #and sch.name=:schname "
 #and ind.is_primary_key=0 and ind.type != 0"
 # filter_definition
 #
 #bindparams(
 #ql.bindparam("tabname", tablename, ischema.CoerceUnicode()),
 #ql.bindparam("schname", owner, ischema.CoerceUnicode()),
 #
 #columns(name=sqltypes.Unicode())
 #
 #ndexes = {}
 #or row in rp.mappings():
 #ndexes[row["index_id"]] = {
 #name": row["name"],
 #unique": row["is_unique"] == 1,
 #column_names": [],
 #include_columns": [],
 #

 #f row["filter_definition"] is not None:
 #ndexes[row["index_id"]].setdefault("dialect_options", {})[
 #mssql_where"
 # = row["filter_definition"]

 #p = connection.execution_options(future_result=True).execute(
 #ql.text(
 #select ind_col.index_id, ind_col.object_id, col.name, "
 #ind_col.is_included_column "
 #from sys.columns as col "
 #join sys.tables as tab on tab.object_id=col.object_id "
 #join sys.index_columns as ind_col on "
 #(ind_col.column_id=col.column_id and "
 #ind_col.object_id=tab.object_id) "
 #join sys.schemas as sch on sch.schema_id=tab.schema_id "
 #where tab.name=:tabname "
 #and sch.name=:schname"
 #
 #bindparams(
 #ql.bindparam("tabname", tablename, ischema.CoerceUnicode()),
 #ql.bindparam("schname", owner, ischema.CoerceUnicode()),
 #
 #columns(name=sqltypes.Unicode())
 #
 #or row in rp.mappings():
 #f row["index_id"] in indexes:
 #f row["is_included_column"]:
 #ndexes[row["index_id"]]["include_columns"].append(
 #ow["name"]
 #
 #lse:
 #ndexes[row["index_id"]]["column_names"].append(
 #ow["name"]
 #

 #eturn list(indexes.values())

 #reflection.cache
 #_db_plus_owner
 #ef get_view_definition(
 #elf, connection, viewname, dbname, owner, schema, **kw
 #:
 #p = connection.execute(
 #ql.text(
 #select definition from sys.sql_modules as mod, "
 #sys.views as views, "
 #sys.schemas as sch"
 # where "
 #mod.object_id=views.object_id and "
 #views.schema_id=sch.schema_id and "
 #views.name=:viewname and sch.name=:schname"
 #.bindparams(
 #ql.bindparam("viewname", viewname, ischema.CoerceUnicode()),
 #ql.bindparam("schname", owner, ischema.CoerceUnicode()),
 #
 #

 #f rp:
 #iew_def = rp.scalar()
 #eturn view_def

 #ef _temp_table_name_like_pattern(self, tablename):
 #eturn tablename + (("___%") if not tablename.startswith("##") else "")

 #ef _get_internal_temp_table_name(self, connection, tablename):
        # it's likely that schema is always "dbo", but since we can
        # get it here, let's get it.
        # see https://stackoverflow.com/questions/8311959/
        # specifying-schema-for-temporary-tables

 #ry:
 #eturn connection.execute(
 #ql.text(
 #select table_schema, table_name "
 #from tempdb.information_schema.tables "
 #where table_name like :p1"
 #,
 #"p1": self._temp_table_name_like_pattern(tablename)},
 #.one()
 #xcept exc.MultipleResultsFound as me:
 #til.raise_(
 #xc.UnreflectableTableError(
 #Found more than one temporary table named '%s' in tempdb "
 #at this time. Cannot reliably resolve that name to its "
 #internal table name." % tablename
 #,
 #eplace_context=me,
 #
 #xcept exc.NoResultFound as ne:
 #til.raise_(
 #xc.NoSuchTableError(
 #Unable to find a temporary table named '%s' in tempdb."
 # tablename
 #,
 #eplace_context=ne,
 #

 #reflection.cache
 #_db_plus_owner
 #ef get_columns(self, connection, tablename, dbname, owner, schema, **kw):
 #s_temp_table = tablename.startswith("#")
 #f is_temp_table:
 #wner, tablename = self._get_internal_temp_table_name(
 #onnection, tablename
 #

 #olumns = ischema.mssql_temp_table_columns
 #lse:
 #olumns = ischema.columns

 #omputed_cols = ischema.computed_columns
 #dentity_cols = ischema.identity_columns
 #f owner:
 #hereclause = sql.and_(
 #olumns.c.table_name == tablename,
 #olumns.c.table_schema == owner,
 #
 #ull_name = columns.c.table_schema + "." + columns.c.table_name
 #lse:
 #hereclause = columns.c.table_name == tablename
 #ull_name = columns.c.table_name

 #oin = columns.join(
 #omputed_cols,
 #nclause=sql.and_(
 #omputed_cols.c.object_id == func.object_id(full_name),
 #omputed_cols.c.name == columns.c.column_name,
 #,
 #souter=True,
 #.join(
 #dentity_cols,
 #nclause=sql.and_(
 #dentity_cols.c.object_id == func.object_id(full_name),
 #dentity_cols.c.name == columns.c.column_name,
 #,
 #souter=True,
 #

 #f self._supports_nvarchar_max:
 #omputed_definition = computed_cols.c.definition
 #lse:
            # tds_version 4.2 does not support NVARCHAR(MAX)
 #omputed_definition = sql.cast(
 #omputed_cols.c.definition, NVARCHAR(4000)
 #

 # = (
 #ql.select(
 #olumns,
 #omputed_definition,
 #omputed_cols.c.is_persisted,
 #dentity_cols.c.is_identity,
 #dentity_cols.c.seed_value,
 #dentity_cols.c.increment_value,
 #
 #where(whereclause)
 #select_from(join)
 #order_by(columns.c.ordinal_position)
 #

 # = connection.execution_options(future_result=True).execute(s)

 #ols = []
 #or row in c.mappings():
 #ame = row[columns.c.column_name]
 #ype_ = row[columns.c.data_type]
 #ullable = row[columns.c.is_nullable] == "YES"
 #harlen = row[columns.c.character_maximum_length]
 #umericprec = row[columns.c.numeric_precision]
 #umericscale = row[columns.c.numeric_scale]
 #efault = row[columns.c.column_default]
 #ollation = row[columns.c.collation_name]
 #efinition = row[computed_definition]
 #s_persisted = row[computed_cols.c.is_persisted]
 #s_identity = row[identity_cols.c.is_identity]
 #dentity_start = row[identity_cols.c.seed_value]
 #dentity_increment = row[identity_cols.c.increment_value]

 #oltype = self.ischema_names.get(type_, None)

 #wargs = {}
 #f coltype in (
 #SString,
 #SChar,
 #SNVarchar,
 #SNChar,
 #SText,
 #SNText,
 #SBinary,
 #SVarBinary,
 #qltypes.LargeBinary,
 #:
 #f charlen == -1:
 #harlen = None
 #wargs["length"] = charlen
 #f collation:
 #wargs["collation"] = collation

 #f coltype is None:
 #til.warn(
 #Did not recognize type '%s' of column '%s'"
 # (type_, name)
 #
 #oltype = sqltypes.NULLTYPE
 #lse:
 #f issubclass(coltype, sqltypes.Numeric):
 #wargs["precision"] = numericprec

 #f not issubclass(coltype, sqltypes.Float):
 #wargs["scale"] = numericscale

 #oltype = coltype(**kwargs)
 #dict = {
 #name": name,
 #type": coltype,
 #nullable": nullable,
 #default": default,
 #autoincrement": is_identity is not None,
 #

 #f definition is not None and is_persisted is not None:
 #dict["computed"] = {
 #sqltext": definition,
 #persisted": is_persisted,
 #

 #f is_identity is not None:
                # identity_start and identity_increment are Decimal or None
 #f identity_start is None or identity_increment is None:
 #dict["identity"] = {}
 #lse:
 #f isinstance(coltype, sqltypes.BigInteger):
 #tart = compat.long_type(identity_start)
 #ncrement = compat.long_type(identity_increment)
 #lif isinstance(coltype, sqltypes.Integer):
 #tart = int(identity_start)
 #ncrement = int(identity_increment)
 #lse:
 #tart = identity_start
 #ncrement = identity_increment

 #dict["identity"] = {
 #start": start,
 #increment": increment,
 #

 #ols.append(cdict)

 #eturn cols

 #reflection.cache
 #_db_plus_owner
 #ef get_pk_constraint(
 #elf, connection, tablename, dbname, owner, schema, **kw
 #:
 #keys = []
 #C = ischema.constraints
 # = ischema.key_constraints.alias("C")

        # Primary key constraints
 # = (
 #ql.select(
 #.c.column_name, TC.c.constraint_type, C.c.constraint_name
 #
 #where(
 #ql.and_(
 #C.c.constraint_name == C.c.constraint_name,
 #C.c.table_schema == C.c.table_schema,
 #.c.table_name == tablename,
 #.c.table_schema == owner,
 #,
 #
 #order_by(TC.c.constraint_name, C.c.ordinal_position)
 #
 # = connection.execution_options(future_result=True).execute(s)
 #onstraint_name = None
 #or row in c.mappings():
 #f "PRIMARY" in row[TC.c.constraint_type.name]:
 #keys.append(row["COLUMN_NAME"])
 #f constraint_name is None:
 #onstraint_name = row[C.c.constraint_name.name]
 #eturn {"constrained_columns": pkeys, "name": constraint_name}

 #reflection.cache
 #_db_plus_owner
 #ef get_foreign_keys(
 #elf, connection, tablename, dbname, owner, schema, **kw
 #:
 #R = ischema.ref_constraints
 # = ischema.key_constraints.alias("C")
 # = ischema.key_constraints.alias("R")
        # Foreign key constraints
 # = (
 #ql.select(
 #.c.column_name,
 #.c.table_schema,
 #.c.table_name,
 #.c.column_name,
 #R.c.constraint_name,
 #R.c.match_option,
 #R.c.update_rule,
 #R.c.delete_rule,
 #
 #where(
 #ql.and_(
 #.c.table_name == tablename,
 #.c.table_schema == owner,
 #R.c.constraint_schema == C.c.table_schema,
 #.c.constraint_name == RR.c.constraint_name,
 #.c.constraint_name == RR.c.unique_constraint_name,
 #.c.constraint_schema == RR.c.unique_constraint_schema,
 #.c.ordinal_position == R.c.ordinal_position,
 #
 #
 #order_by(RR.c.constraint_name, R.c.ordinal_position)
 #

        # group rows by constraint ID, to handle multi-column FKs
 #keys = []

 #ef fkey_rec():
 #eturn {
 #name": None,
 #constrained_columns": [],
 #referred_schema": None,
 #referred_table": None,
 #referred_columns": [],
 #

 #keys = util.defaultdict(fkey_rec)

 #or r in connection.execute(s).fetchall():
 #col, rschema, rtbl, rcol, rfknm, fkmatch, fkuprule, fkdelrule = r

 #ec = fkeys[rfknm]
 #ec["name"] = rfknm
 #f not rec["referred_table"]:
 #ec["referred_table"] = rtbl
 #f schema is not None or owner != rschema:
 #f dbname:
 #schema = dbname + "." + rschema
 #ec["referred_schema"] = rschema

 #ocal_cols, remote_cols = (
 #ec["constrained_columns"],
 #ec["referred_columns"],
 #

 #ocal_cols.append(scol)
 #emote_cols.append(rcol)

 #eturn list(fkeys.values())
