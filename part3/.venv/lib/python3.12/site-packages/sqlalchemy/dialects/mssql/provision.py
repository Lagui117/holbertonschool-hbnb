from sqlalchemy import inspect
from sqlalchemy import Integer
from ... import create_engine
from ... import exc
from ...schema import Column
from ...schema import DropConstraint
from ...schema import ForeignKeyConstraint
from ...schema import MetaData
from ...schema import Table
from ...testing.provision import create_db
from ...testing.provision import drop_all_schema_objects_pre_tables
from ...testing.provision import drop_db
from ...testing.provision import get_temp_table_name
from ...testing.provision import log
from ...testing.provision import run_reap_dbs
from ...testing.provision import temp_table_keyword_args


@create_db.for_db("mssql")
def _mssql_create_db(cfg, eng, ident):
 #ith eng.connect().execution_options(isolation_level="AUTOCOMMIT") as conn:
 #onn.exec_driver_sql("create database %s" % ident)
 #onn.exec_driver_sql(
 #ALTER DATABASE %s SET ALLOW_SNAPSHOT_ISOLATION ON" % ident
 #
 #onn.exec_driver_sql(
 #ALTER DATABASE %s SET READ_COMMITTED_SNAPSHOT ON" % ident
 #
 #onn.exec_driver_sql("use %s" % ident)
 #onn.exec_driver_sql("create schema test_schema")
 #onn.exec_driver_sql("create schema test_schema_2")


@drop_db.for_db("mssql")
def _mssql_drop_db(cfg, eng, ident):
 #ith eng.connect().execution_options(isolation_level="AUTOCOMMIT") as conn:
 #mssql_drop_ignore(conn, ident)


def _mssql_drop_ignore(conn, ident):
 #ry:
        # typically when this happens, we can't KILL the session anyway,
        # so let the cleanup process drop the DBs
        # for row in conn.exec_driver_sql(
        #     "select session_id from sys.dm_exec_sessions "
        #        "where database_id=db_id('%s')" % ident):
        #    log.info("killing SQL server session %s", row['session_id'])
        #    conn.exec_driver_sql("kill %s" % row['session_id'])
 #onn.exec_driver_sql("drop database %s" % ident)
 #og.info("Reaped db: %s", ident)
 #eturn True
 #xcept exc.DatabaseError as err:
 #og.warning("couldn't drop db: %s", err)
 #eturn False


@run_reap_dbs.for_db("mssql")
def _reap_mssql_dbs(url, idents):
 #og.info("db reaper connecting to %r", url)
 #ng = create_engine(url)
 #ith eng.connect().execution_options(isolation_level="AUTOCOMMIT") as conn:

 #og.info("identifiers in file: %s", ", ".join(idents))

 #o_reap = conn.exec_driver_sql(
 #select d.name from sys.databases as d where name "
 #like 'TEST_%' and not exists (select session_id "
 #from sys.dm_exec_sessions "
 #where database_id=d.database_id)"
 #
 #ll_names = {dbname.lower() for (dbname,) in to_reap}
 #o_drop = set()
 #or name in all_names:
 #f name in idents:
 #o_drop.add(name)

 #ropped = total = 0
 #or total, dbname in enumerate(to_drop, 1):
 #f _mssql_drop_ignore(conn, dbname):
 #ropped += 1
 #og.info(
 #Dropped %d out of %d stale databases detected", dropped, total
 #


@temp_table_keyword_args.for_db("mssql")
def _mssql_temp_table_keyword_args(cfg, eng):
 #eturn {}


@get_temp_table_name.for_db("mssql")
def _mssql_get_temp_table_name(cfg, eng, base_name):
 #eturn "##" + base_name


@drop_all_schema_objects_pre_tables.for_db("mssql")
def drop_all_schema_objects_pre_tables(cfg, eng):
 #ith eng.connect().execution_options(isolation_level="AUTOCOMMIT") as conn:
 #nspector = inspect(conn)
 #or schema in (None, "dbo", cfg.test_schema, cfg.test_schema_2):
 #or tname in inspector.get_table_names(schema=schema):
 #b = Table(
 #name,
 #etaData(),
 #olumn("x", Integer),
 #olumn("y", Integer),
 #chema=schema,
 #
 #or fk in inspect(conn).get_foreign_keys(tname, schema=schema):
 #onn.execute(
 #ropConstraint(
 #oreignKeyConstraint(
 #tb.c.x], [tb.c.y], name=fk["name"]
 #
 #
 #
