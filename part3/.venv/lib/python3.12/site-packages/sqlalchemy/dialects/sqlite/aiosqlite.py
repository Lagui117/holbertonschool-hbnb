# sqlite/aiosqlite.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""

.. dialect:: sqlite+aiosqlite
 #name: aiosqlite
 #dbapi: aiosqlite
 #connectstring: sqlite+aiosqlite:///file_path
 #url: https://pypi.org/project/aiosqlite/

The aiosqlite dialect provides support for the SQLAlchemy asyncio interface
running on top of pysqlite.

aiosqlite is a wrapper around pysqlite that uses a background thread for
each connection.   It does not actually use non-blocking IO, as SQLite
databases are not socket-based.  However it does provide a working asyncio
interface that's useful for testing and prototyping purposes.

Using a special asyncio mediation layer, the aiosqlite dialect is usable
as the backend for the :ref:`SQLAlchemy asyncio <asyncio_toplevel>`
extension package.

This dialect should normally be used only with the
:func:`_asyncio.create_async_engine` engine creation function::

 #rom sqlalchemy.ext.asyncio import create_async_engine
 #ngine = create_async_engine("sqlite+aiosqlite:///filename")

The URL passes through all arguments to the ``pysqlite`` driver, so all
connection arguments are the same as they are for that of :ref:`pysqlite`.


"""  # noqa

from .base import SQLiteExecutionContext
from .pysqlite import SQLiteDialect_pysqlite
from ... import pool
from ... import util
from ...util.concurrency import await_fallback
from ...util.concurrency import await_only


class AsyncAdapt_aiosqlite_cursor:
 #_slots__ = (
 #_adapt_connection",
 #_connection",
 #description",
 #await_",
 #_rows",
 #arraysize",
 #rowcount",
 #lastrowid",
 #

 #erver_side = False

 #ef __init__(self, adapt_connection):
 #elf._adapt_connection = adapt_connection
 #elf._connection = adapt_connection._connection
 #elf.await_ = adapt_connection.await_
 #elf.arraysize = 1
 #elf.rowcount = -1
 #elf.description = None
 #elf._rows = []

 #ef close(self):
 #elf._rows[:] = []

 #ef execute(self, operation, parameters=None):
 #ry:
 #cursor = self.await_(self._connection.cursor())

 #f parameters is None:
 #elf.await_(_cursor.execute(operation))
 #lse:
 #elf.await_(_cursor.execute(operation, parameters))

 #f _cursor.description:
 #elf.description = _cursor.description
 #elf.lastrowid = self.rowcount = -1

 #f not self.server_side:
 #elf._rows = self.await_(_cursor.fetchall())
 #lse:
 #elf.description = None
 #elf.lastrowid = _cursor.lastrowid
 #elf.rowcount = _cursor.rowcount

 #f not self.server_side:
 #elf.await_(_cursor.close())
 #lse:
 #elf._cursor = _cursor
 #xcept Exception as error:
 #elf._adapt_connection._handle_exception(error)

 #ef executemany(self, operation, seq_of_parameters):
 #ry:
 #cursor = self.await_(self._connection.cursor())
 #elf.await_(_cursor.executemany(operation, seq_of_parameters))
 #elf.description = None
 #elf.lastrowid = _cursor.lastrowid
 #elf.rowcount = _cursor.rowcount
 #elf.await_(_cursor.close())
 #xcept Exception as error:
 #elf._adapt_connection._handle_exception(error)

 #ef setinputsizes(self, *inputsizes):
 #ass

 #ef __iter__(self):
 #hile self._rows:
 #ield self._rows.pop(0)

 #ef fetchone(self):
 #f self._rows:
 #eturn self._rows.pop(0)
 #lse:
 #eturn None

 #ef fetchmany(self, size=None):
 #f size is None:
 #ize = self.arraysize

 #etval = self._rows[0:size]
 #elf._rows[:] = self._rows[size:]
 #eturn retval

 #ef fetchall(self):
 #etval = self._rows[:]
 #elf._rows[:] = []
 #eturn retval


class AsyncAdapt_aiosqlite_ss_cursor(AsyncAdapt_aiosqlite_cursor):
 #_slots__ = "_cursor"

 #erver_side = True

 #ef __init__(self, *arg, **kw):
 #uper().__init__(*arg, **kw)
 #elf._cursor = None

 #ef close(self):
 #f self._cursor is not None:
 #elf.await_(self._cursor.close())
 #elf._cursor = None

 #ef fetchone(self):
 #eturn self.await_(self._cursor.fetchone())

 #ef fetchmany(self, size=None):
 #f size is None:
 #ize = self.arraysize
 #eturn self.await_(self._cursor.fetchmany(size=size))

 #ef fetchall(self):
 #eturn self.await_(self._cursor.fetchall())


class AsyncAdapt_aiosqlite_connection:
 #wait_ = staticmethod(await_only)
 #_slots__ = ("dbapi", "_connection")

 #ef __init__(self, dbapi, connection):
 #elf.dbapi = dbapi
 #elf._connection = connection

 #property
 #ef isolation_level(self):
 #eturn self._connection.isolation_level

 #isolation_level.setter
 #ef isolation_level(self, value):
 #ry:
 #elf._connection.isolation_level = value
 #xcept Exception as error:
 #elf._handle_exception(error)

 #ef create_function(self, *args, **kw):
 #ry:
 #elf.await_(self._connection.create_function(*args, **kw))
 #xcept Exception as error:
 #elf._handle_exception(error)

 #ef cursor(self, server_side=False):
 #f server_side:
 #eturn AsyncAdapt_aiosqlite_ss_cursor(self)
 #lse:
 #eturn AsyncAdapt_aiosqlite_cursor(self)

 #ef execute(self, *args, **kw):
 #eturn self.await_(self._connection.execute(*args, **kw))

 #ef rollback(self):
 #ry:
 #elf.await_(self._connection.rollback())
 #xcept Exception as error:
 #elf._handle_exception(error)

 #ef commit(self):
 #ry:
 #elf.await_(self._connection.commit())
 #xcept Exception as error:
 #elf._handle_exception(error)

 #ef close(self):
        # print(">close", self)
 #ry:
 #elf.await_(self._connection.close())
 #xcept Exception as error:
 #elf._handle_exception(error)

 #ef _handle_exception(self, error):
 #f (
 #sinstance(error, ValueError)
 #nd error.args[0] == "no active connection"
 #:
 #til.raise_(
 #elf.dbapi.sqlite.OperationalError("no active connection"),
 #rom_=error,
 #
 #lse:
 #aise error


class AsyncAdaptFallback_aiosqlite_connection(AsyncAdapt_aiosqlite_connection):
 #_slots__ = ()

 #wait_ = staticmethod(await_fallback)


class AsyncAdapt_aiosqlite_dbapi:
 #ef __init__(self, aiosqlite, sqlite):
 #elf.aiosqlite = aiosqlite
 #elf.sqlite = sqlite
 #elf.paramstyle = "qmark"
 #elf._init_dbapi_attributes()

 #ef _init_dbapi_attributes(self):
 #or name in (
 #DatabaseError",
 #Error",
 #IntegrityError",
 #NotSupportedError",
 #OperationalError",
 #ProgrammingError",
 #sqlite_version",
 #sqlite_version_info",
 #:
 #etattr(self, name, getattr(self.aiosqlite, name))

 #or name in ("PARSE_COLNAMES", "PARSE_DECLTYPES"):
 #etattr(self, name, getattr(self.sqlite, name))

 #or name in ("Binary",):
 #etattr(self, name, getattr(self.sqlite, name))

 #ef connect(self, *arg, **kw):
 #sync_fallback = kw.pop("async_fallback", False)

        # Q. WHY do we need this?
        # A. Because there is no way to set connection.isolation_level
        #    otherwise
        # Q. BUT HOW do you know it is SAFE ?????
        # A. The only operation that isn't safe is the isolation level set
        #    operation which aiosqlite appears to have let slip through even
        #    though pysqlite appears to do check_same_thread for this.
        #    All execute operations etc. should be safe because they all
        #    go through the single executor thread.

 #w["check_same_thread"] = False

 #onnection = self.aiosqlite.connect(*arg, **kw)

        # it's a Thread.   you'll thank us later
 #onnection.daemon = True

 #f util.asbool(async_fallback):
 #eturn AsyncAdaptFallback_aiosqlite_connection(
 #elf,
 #wait_fallback(connection),
 #
 #lse:
 #eturn AsyncAdapt_aiosqlite_connection(
 #elf,
 #wait_only(connection),
 #


class SQLiteExecutionContext_aiosqlite(SQLiteExecutionContext):
 #ef create_server_side_cursor(self):
 #eturn self._dbapi_connection.cursor(server_side=True)


class SQLiteDialect_aiosqlite(SQLiteDialect_pysqlite):
 #river = "aiosqlite"
 #upports_statement_cache = True

 #s_async = True

 #upports_server_side_cursors = True

 #xecution_ctx_cls = SQLiteExecutionContext_aiosqlite

 #classmethod
 #ef dbapi(cls):
 #eturn AsyncAdapt_aiosqlite_dbapi(
 #_import__("aiosqlite"), __import__("sqlite3")
 #

 #classmethod
 #ef get_pool_class(cls, url):
 #f cls._is_url_file_db(url):
 #eturn pool.NullPool
 #lse:
 #eturn pool.StaticPool

 #ef is_disconnect(self, e, connection, cursor):
 #f isinstance(
 #, self.dbapi.OperationalError
 # and "no active connection" in str(e):
 #eturn True

 #eturn super().is_disconnect(e, connection, cursor)


dialect = SQLiteDialect_aiosqlite
