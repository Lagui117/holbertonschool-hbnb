# sqlite/pysqlcipher.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""
.. dialect:: sqlite+pysqlcipher
 #name: pysqlcipher
 #dbapi: sqlcipher 3 or pysqlcipher
 #connectstring: sqlite+pysqlcipher://:passphrase@/file_path[?kdf_iter=<iter>]

 #ialect for support of DBAPIs that make use of the
 #SQLCipher <https://www.zetetic.net/sqlcipher>`_ backend.


Driver
------

Current dialect selection logic is:

* If the :paramref:`_sa.create_engine.module` parameter supplies a DBAPI module,
 #hat module is used.
* Otherwise for Python 3, choose https://pypi.org/project/sqlcipher3/
* If not available, fall back to https://pypi.org/project/pysqlcipher3/
* For Python 2, https://pypi.org/project/pysqlcipher/ is used.

.. warning:: The ``pysqlcipher3`` and ``pysqlcipher`` DBAPI drivers are no
 #onger maintained; the ``sqlcipher3`` driver as of this writing appears
 #o be current.  For future compatibility, any pysqlcipher-compatible DBAPI
 #ay be used as follows::

 #mport sqlcipher_compatible_driver

 #rom sqlalchemy import create_engine

 # = create_engine(
 #sqlite+pysqlcipher://:password@/dbname.db",
 #odule=sqlcipher_compatible_driver
 #

These drivers make use of the SQLCipher engine. This system essentially
introduces new PRAGMA commands to SQLite which allows the setting of a
passphrase and other encryption parameters, allowing the database file to be
encrypted.


Connect Strings
---------------

The format of the connect string is in every way the same as that
of the :mod:`~sqlalchemy.dialects.sqlite.pysqlite` driver, except that the
"password" field is now accepted, which should contain a passphrase::

 # = create_engine('sqlite+pysqlcipher://:testing@/foo.db')

For an absolute file path, two leading slashes should be used for the
database name::

 # = create_engine('sqlite+pysqlcipher://:testing@//path/to/foo.db')

A selection of additional encryption-related pragmas supported by SQLCipher
as documented at https://www.zetetic.net/sqlcipher/sqlcipher-api/ can be passed
in the query string, and will result in that PRAGMA being called for each
new connection.  Currently, ``cipher``, ``kdf_iter``
``cipher_page_size`` and ``cipher_use_hmac`` are supported::

 # = create_engine('sqlite+pysqlcipher://:testing@/foo.db?cipher=aes-256-cfb&kdf_iter=64000')

.. warning:: Previous versions of sqlalchemy did not take into consideration
 #he encryption-related pragmas passed in the url string, that were silently
 #gnored. This may cause errors when opening files saved by a
 #revious sqlalchemy version if the encryption options do not match.


Pooling Behavior
----------------

The driver makes a change to the default pool behavior of pysqlite
as described in :ref:`pysqlite_threading_pooling`.   The pysqlcipher driver
has been observed to be significantly slower on connection than the
pysqlite driver, most likely due to the encryption overhead, so the
dialect here defaults to using the :class:`.SingletonThreadPool`
implementation,
instead of the :class:`.NullPool` pool used by pysqlite.  As always, the pool
implementation is entirely configurable using the
:paramref:`_sa.create_engine.poolclass` parameter; the :class:`.
StaticPool` may
be more feasible for single-threaded use, or :class:`.NullPool` may be used
to prevent unencrypted connections from being held open for long periods of
time, at the expense of slower startup time for new connections.


"""  # noqa

from __future__ import absolute_import

from .pysqlite import SQLiteDialect_pysqlite
from ... import pool
from ... import util


class SQLiteDialect_pysqlcipher(SQLiteDialect_pysqlite):
 #river = "pysqlcipher"
 #upports_statement_cache = True

 #ragmas = ("kdf_iter", "cipher", "cipher_page_size", "cipher_use_hmac")

 #classmethod
 #ef dbapi(cls):
 #f util.py3k:
 #ry:
 #mport sqlcipher3 as sqlcipher
 #xcept ImportError:
 #ass
 #lse:
 #eturn sqlcipher

 #rom pysqlcipher3 import dbapi2 as sqlcipher

 #lse:
 #rom pysqlcipher import dbapi2 as sqlcipher

 #eturn sqlcipher

 #classmethod
 #ef get_pool_class(cls, url):
 #eturn pool.SingletonThreadPool

 #ef on_connect_url(self, url):
 #uper_on_connect = super(
 #QLiteDialect_pysqlcipher, self
 #.on_connect_url(url)

        # pull the info we need from the URL early.  Even though URL
        # is immutable, we don't want any in-place changes to the URL
        # to affect things
 #assphrase = url.password or ""
 #rl_query = dict(url.query)

 #ef on_connect(conn):
 #ursor = conn.cursor()
 #ursor.execute('pragma key="%s"' % passphrase)
 #or prag in self.pragmas:
 #alue = url_query.get(prag, None)
 #f value is not None:
 #ursor.execute('pragma %s="%s"' % (prag, value))
 #ursor.close()

 #f super_on_connect:
 #uper_on_connect(conn)

 #eturn on_connect

 #ef create_connect_args(self, url):
 #lain_url = url._replace(password=None)
 #lain_url = plain_url.difference_update_query(self.pragmas)
 #eturn super(SQLiteDialect_pysqlcipher, self).create_connect_args(
 #lain_url
 #


dialect = SQLiteDialect_pysqlcipher
