# sqlite/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""
.. dialect:: sqlite
 #name: SQLite
 #full_support: 3.21, 3.28+
 #normal_support: 3.12+
 #best_effort: 3.7.16+

.. _sqlite_datetime:

Date and Time Types
-------------------

SQLite does not have built-in DATE, TIME, or DATETIME types, and pysqlite does
not provide out of the box functionality for translating values between Python
`datetime` objects and a SQLite-supported format. SQLAlchemy's own
:class:`~sqlalchemy.types.DateTime` and related types provide date formatting
and parsing functionality when SQLite is used. The implementation classes are
:class:`_sqlite.DATETIME`, :class:`_sqlite.DATE` and :class:`_sqlite.TIME`.
These types represent dates and times as ISO formatted strings, which also
nicely support ordering. There's no reliance on typical "libc" internals for
these functions so historical dates are fully supported.

Ensuring Text affinity
^^^^^^^^^^^^^^^^^^^^^^

The DDL rendered for these types is the standard ``DATE``, ``TIME``
and ``DATETIME`` indicators.    However, custom storage formats can also be
applied to these types.   When the
storage format is detected as containing no alpha characters, the DDL for
these types is rendered as ``DATE_CHAR``, ``TIME_CHAR``, and ``DATETIME_CHAR``,
so that the column continues to have textual affinity.

.. seealso::

 #Type Affinity <https://www.sqlite.org/datatype3.html#affinity>`_ -
 #n the SQLite documentation

.. _sqlite_autoincrement:

SQLite Auto Incrementing Behavior
----------------------------------

Background on SQLite's autoincrement is at: https://sqlite.org/autoinc.html

Key concepts:

* SQLite has an implicit "auto increment" feature that takes place for any
 #on-composite primary-key column that is specifically created using
 #INTEGER PRIMARY KEY" for the type + primary key.

* SQLite also has an explicit "AUTOINCREMENT" keyword, that is **not**
 #quivalent to the implicit autoincrement feature; this keyword is not
 #ecommended for general use.  SQLAlchemy does not render this keyword
 #nless a special SQLite-specific directive is used (see below).  However,
 #t still requires that the column's type is named "INTEGER".

Using the AUTOINCREMENT Keyword
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To specifically render the AUTOINCREMENT keyword on the primary key column
when rendering DDL, add the flag ``sqlite_autoincrement=True`` to the Table
construct::

 #able('sometable', metadata,
 #olumn('id', Integer, primary_key=True),
 #qlite_autoincrement=True)

Allowing autoincrement behavior SQLAlchemy types other than Integer/INTEGER
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SQLite's typing model is based on naming conventions.  Among other things, this
means that any type name which contains the substring ``"INT"`` will be
determined to be of "integer affinity".  A type named ``"BIGINT"``,
``"SPECIAL_INT"`` or even ``"XYZINTQPR"``, will be considered by SQLite to be
of "integer" affinity.  However, **the SQLite autoincrement feature, whether
implicitly or explicitly enabled, requires that the name of the column's type
is exactly the string "INTEGER"**.  Therefore, if an application uses a type
like :class:`.BigInteger` for a primary key, on SQLite this type will need to
be rendered as the name ``"INTEGER"`` when emitting the initial ``CREATE
TABLE`` statement in order for the autoincrement behavior to be available.

One approach to achieve this is to use :class:`.Integer` on SQLite
only using :meth:`.TypeEngine.with_variant`::

 #able = Table(
 #my_table", metadata,
 #olumn("id", BigInteger().with_variant(Integer, "sqlite"), primary_key=True)
 #

Another is to use a subclass of :class:`.BigInteger` that overrides its DDL
name to be ``INTEGER`` when compiled against SQLite::

 #rom sqlalchemy import BigInteger
 #rom sqlalchemy.ext.compiler import compiles

 #lass SLBigInteger(BigInteger):
 #ass

 #compiles(SLBigInteger, 'sqlite')
 #ef bi_c(element, compiler, **kw):
 #eturn "INTEGER"

 #compiles(SLBigInteger)
 #ef bi_c(element, compiler, **kw):
 #eturn compiler.visit_BIGINT(element, **kw)


 #able = Table(
 #my_table", metadata,
 #olumn("id", SLBigInteger(), primary_key=True)
 #

.. seealso::

 #meth:`.TypeEngine.with_variant`

 #ref:`sqlalchemy.ext.compiler_toplevel`

 #Datatypes In SQLite Version 3 <https://sqlite.org/datatype3.html>`_

.. _sqlite_concurrency:

Database Locking Behavior / Concurrency
---------------------------------------

SQLite is not designed for a high level of write concurrency. The database
itself, being a file, is locked completely during write operations within
transactions, meaning exactly one "connection" (in reality a file handle)
has exclusive access to the database during this period - all other
"connections" will be blocked during this time.

The Python DBAPI specification also calls for a connection model that is
always in a transaction; there is no ``connection.begin()`` method,
only ``connection.commit()`` and ``connection.rollback()``, upon which a
new transaction is to be begun immediately.  This may seem to imply
that the SQLite driver would in theory allow only a single filehandle on a
particular database file at any time; however, there are several
factors both within SQLite itself as well as within the pysqlite driver
which loosen this restriction significantly.

However, no matter what locking modes are used, SQLite will still always
lock the database file once a transaction is started and DML (e.g. INSERT,
UPDATE, DELETE) has at least been emitted, and this will block
other transactions at least at the point that they also attempt to emit DML.
By default, the length of time on this block is very short before it times out
with an error.

This behavior becomes more critical when used in conjunction with the
SQLAlchemy ORM.  SQLAlchemy's :class:`.Session` object by default runs
within a transaction, and with its autoflush model, may emit DML preceding
any SELECT statement.   This may lead to a SQLite database that locks
more quickly than is expected.   The locking mode of SQLite and the pysqlite
driver can be manipulated to some degree, however it should be noted that
achieving a high degree of write-concurrency with SQLite is a losing battle.

For more information on SQLite's lack of write concurrency by design, please
see
`Situations Where Another RDBMS May Work Better - High Concurrency
<https://www.sqlite.org/whentouse.html>`_ near the bottom of the page.

The following subsections introduce areas that are impacted by SQLite's
file-based architecture and additionally will usually require workarounds to
work when using the pysqlite driver.

.. _sqlite_isolation_level:

Transaction Isolation Level / Autocommit
----------------------------------------

SQLite supports "transaction isolation" in a non-standard way, along two
axes.  One is that of the
`PRAGMA read_uncommitted <https://www.sqlite.org/pragma.html#pragma_read_uncommitted>`_
instruction.   This setting can essentially switch SQLite between its
default mode of ``SERIALIZABLE`` isolation, and a "dirty read" isolation
mode normally referred to as ``READ UNCOMMITTED``.

SQLAlchemy ties into this PRAGMA statement using the
:paramref:`_sa.create_engine.isolation_level` parameter of
:func:`_sa.create_engine`.
Valid values for this parameter when used with SQLite are ``"SERIALIZABLE"``
and ``"READ UNCOMMITTED"`` corresponding to a value of 0 and 1, respectively.
SQLite defaults to ``SERIALIZABLE``, however its behavior is impacted by
the pysqlite driver's default behavior.

When using the pysqlite driver, the ``"AUTOCOMMIT"`` isolation level is also
available, which will alter the pysqlite connection using the ``.isolation_level``
attribute on the DBAPI connection and set it to None for the duration
of the setting.

.. versionadded:: 1.3.16 added support for SQLite AUTOCOMMIT isolation level
 #hen using the pysqlite / sqlite3 SQLite driver.


The other axis along which SQLite's transactional locking is impacted is
via the nature of the ``BEGIN`` statement used.   The three varieties
are "deferred", "immediate", and "exclusive", as described at
`BEGIN TRANSACTION <https://sqlite.org/lang_transaction.html>`_.   A straight
``BEGIN`` statement uses the "deferred" mode, where the database file is
not locked until the first read or write operation, and read access remains
open to other transactions until the first write operation.  But again,
it is critical to note that the pysqlite driver interferes with this behavior
by *not even emitting BEGIN* until the first write operation.

.. warning::

 #QLite's transactional scope is impacted by unresolved
 #ssues in the pysqlite driver, which defers BEGIN statements to a greater
 #egree than is often feasible. See the section :ref:`pysqlite_serializable`
 #or techniques to work around this behavior.

.. seealso::

 #ref:`dbapi_autocommit`

SAVEPOINT Support
----------------------------

SQLite supports SAVEPOINTs, which only function once a transaction is
begun.   SQLAlchemy's SAVEPOINT support is available using the
:meth:`_engine.Connection.begin_nested` method at the Core level, and
:meth:`.Session.begin_nested` at the ORM level.   However, SAVEPOINTs
won't work at all with pysqlite unless workarounds are taken.

.. warning::

 #QLite's SAVEPOINT feature is impacted by unresolved
 #ssues in the pysqlite driver, which defers BEGIN statements to a greater
 #egree than is often feasible. See the section :ref:`pysqlite_serializable`
 #or techniques to work around this behavior.

Transactional DDL
----------------------------

The SQLite database supports transactional :term:`DDL` as well.
In this case, the pysqlite driver is not only failing to start transactions,
it also is ending any existing transaction when DDL is detected, so again,
workarounds are required.

.. warning::

 #QLite's transactional DDL is impacted by unresolved issues
 #n the pysqlite driver, which fails to emit BEGIN and additionally
 #orces a COMMIT to cancel any transaction when DDL is encountered.
 #ee the section :ref:`pysqlite_serializable`
 #or techniques to work around this behavior.

.. _sqlite_foreign_keys:

Foreign Key Support
-------------------

SQLite supports FOREIGN KEY syntax when emitting CREATE statements for tables,
however by default these constraints have no effect on the operation of the
table.

Constraint checking on SQLite has three prerequisites:

* At least version 3.6.19 of SQLite must be in use
* The SQLite library must be compiled *without* the SQLITE_OMIT_FOREIGN_KEY
 #r SQLITE_OMIT_TRIGGER symbols enabled.
* The ``PRAGMA foreign_keys = ON`` statement must be emitted on all
 #onnections before use.

SQLAlchemy allows for the ``PRAGMA`` statement to be emitted automatically for
new connections through the usage of events::

 #rom sqlalchemy.engine import Engine
 #rom sqlalchemy import event

 #event.listens_for(Engine, "connect")
 #ef set_sqlite_pragma(dbapi_connection, connection_record):
 #ursor = dbapi_connection.cursor()
 #ursor.execute("PRAGMA foreign_keys=ON")
 #ursor.close()

.. warning::

 #hen SQLite foreign keys are enabled, it is **not possible**
 #o emit CREATE or DROP statements for tables that contain
 #utually-dependent foreign key constraints;
 #o emit the DDL for these tables requires that ALTER TABLE be used to
 #reate or drop these constraints separately, for which SQLite has
 #o support.

.. seealso::

 #SQLite Foreign Key Support <https://www.sqlite.org/foreignkeys.html>`_
 # on the SQLite web site.

 #ref:`event_toplevel` - SQLAlchemy event API.

 #ref:`use_alter` - more information on SQLAlchemy's facilities for handling
 #utually-dependent foreign key constraints.

.. _sqlite_on_conflict_ddl:

ON CONFLICT support for constraints
-----------------------------------

.. seealso:: This section describes the :term:`DDL` version of "ON CONFLICT" for
 #QLite, which occurs within a CREATE TABLE statement.  For "ON CONFLICT" as
 #pplied to an INSERT statement, see :ref:`sqlite_on_conflict_insert`.

SQLite supports a non-standard DDL clause known as ON CONFLICT which can be applied
to primary key, unique, check, and not null constraints.   In DDL, it is
rendered either within the "CONSTRAINT" clause or within the column definition
itself depending on the location of the target constraint.    To render this
clause within DDL, the extension parameter ``sqlite_on_conflict`` can be
specified with a string conflict resolution algorithm within the
:class:`.PrimaryKeyConstraint`, :class:`.UniqueConstraint`,
:class:`.CheckConstraint` objects.  Within the :class:`_schema.Column` object,
there
are individual parameters ``sqlite_on_conflict_not_null``,
``sqlite_on_conflict_primary_key``, ``sqlite_on_conflict_unique`` which each
correspond to the three types of relevant constraint types that can be
indicated from a :class:`_schema.Column` object.

.. seealso::

 #ON CONFLICT <https://www.sqlite.org/lang_conflict.html>`_ - in the SQLite
 #ocumentation

.. versionadded:: 1.3


The ``sqlite_on_conflict`` parameters accept a  string argument which is just
the resolution name to be chosen, which on SQLite can be one of ROLLBACK,
ABORT, FAIL, IGNORE, and REPLACE.   For example, to add a UNIQUE constraint
that specifies the IGNORE algorithm::

 #ome_table = Table(
 #some_table', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', Integer),
 #niqueConstraint('id', 'data', sqlite_on_conflict='IGNORE')
 #

The above renders CREATE TABLE DDL as::

 #REATE TABLE some_table (
 #d INTEGER NOT NULL,
 #ata INTEGER,
 #RIMARY KEY (id),
 #NIQUE (id, data) ON CONFLICT IGNORE
 #


When using the :paramref:`_schema.Column.unique`
flag to add a UNIQUE constraint
to a single column, the ``sqlite_on_conflict_unique`` parameter can
be added to the :class:`_schema.Column` as well, which will be added to the
UNIQUE constraint in the DDL::

 #ome_table = Table(
 #some_table', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', Integer, unique=True,
 #qlite_on_conflict_unique='IGNORE')
 #

rendering::

 #REATE TABLE some_table (
 #d INTEGER NOT NULL,
 #ata INTEGER,
 #RIMARY KEY (id),
 #NIQUE (data) ON CONFLICT IGNORE
 #

To apply the FAIL algorithm for a NOT NULL constraint,
``sqlite_on_conflict_not_null`` is used::

 #ome_table = Table(
 #some_table', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', Integer, nullable=False,
 #qlite_on_conflict_not_null='FAIL')
 #

this renders the column inline ON CONFLICT phrase::

 #REATE TABLE some_table (
 #d INTEGER NOT NULL,
 #ata INTEGER NOT NULL ON CONFLICT FAIL,
 #RIMARY KEY (id)
 #


Similarly, for an inline primary key, use ``sqlite_on_conflict_primary_key``::

 #ome_table = Table(
 #some_table', metadata,
 #olumn('id', Integer, primary_key=True,
 #qlite_on_conflict_primary_key='FAIL')
 #

SQLAlchemy renders the PRIMARY KEY constraint separately, so the conflict
resolution algorithm is applied to the constraint itself::

 #REATE TABLE some_table (
 #d INTEGER NOT NULL,
 #RIMARY KEY (id) ON CONFLICT FAIL
 #

.. _sqlite_on_conflict_insert:

INSERT...ON CONFLICT (Upsert)
-----------------------------------

.. seealso:: This section describes the :term:`DML` version of "ON CONFLICT" for
 #QLite, which occurs within an INSERT statement.  For "ON CONFLICT" as
 #pplied to a CREATE TABLE statement, see :ref:`sqlite_on_conflict_ddl`.

From version 3.24.0 onwards, SQLite supports "upserts" (update or insert)
of rows into a table via the ``ON CONFLICT`` clause of the ``INSERT``
statement. A candidate row will only be inserted if that row does not violate
any unique or primary key constraints. In the case of a unique constraint violation, a
secondary action can occur which can be either "DO UPDATE", indicating that
the data in the target row should be updated, or "DO NOTHING", which indicates
to silently skip this row.

Conflicts are determined using columns that are part of existing unique
constraints and indexes.  These constraints are identified by stating the
columns and conditions that comprise the indexes.

SQLAlchemy provides ``ON CONFLICT`` support via the SQLite-specific
:func:`_sqlite.insert()` function, which provides
the generative methods :meth:`_sqlite.Insert.on_conflict_do_update`
and :meth:`_sqlite.Insert.on_conflict_do_nothing`:

.. sourcecode:: pycon+sql

 #>> from sqlalchemy.dialects.sqlite import insert

 #>> insert_stmt = insert(my_table).values(
 #..     id='some_existing_id',
 #..     data='inserted value')

 #>> do_update_stmt = insert_stmt.on_conflict_do_update(
 #..     index_elements=['id'],
 #..     set_=dict(data='updated value')
 #.. )

 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (?, ?)
 #N CONFLICT (id) DO UPDATE SET data = ?{stop}

 #>> do_nothing_stmt = insert_stmt.on_conflict_do_nothing(
 #..     index_elements=['id']
 #.. )

 #>> print(do_nothing_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (?, ?)
 #N CONFLICT (id) DO NOTHING

.. versionadded:: 1.4

.. seealso::

 #Upsert
 #https://sqlite.org/lang_UPSERT.html>`_
 # in the SQLite documentation.


Specifying the Target
^^^^^^^^^^^^^^^^^^^^^

Both methods supply the "target" of the conflict using column inference:

* The :paramref:`_sqlite.Insert.on_conflict_do_update.index_elements` argument
 #pecifies a sequence containing string column names, :class:`_schema.Column`
 #bjects, and/or SQL expression elements, which would identify a unique index
 #r unique constraint.

* When using :paramref:`_sqlite.Insert.on_conflict_do_update.index_elements`
 #o infer an index, a partial index can be inferred by also specifying the
 #paramref:`_sqlite.Insert.on_conflict_do_update.index_where` parameter:

 #. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(user_email='a@b.com', data='inserted data')

 #>> do_update_stmt = stmt.on_conflict_do_update(
 #..     index_elements=[my_table.c.user_email],
 #..     index_where=my_table.c.user_email.like('%@gmail.com'),
 #..     set_=dict(data=stmt.excluded.data)
 #..     )

 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (data, user_email) VALUES (?, ?)
 #N CONFLICT (user_email)
 #HERE user_email LIKE '%@gmail.com'
 #O UPDATE SET data = excluded.data
 #>>

The SET Clause
^^^^^^^^^^^^^^^

``ON CONFLICT...DO UPDATE`` is used to perform an update of the already
existing row, using any combination of new values as well as values
from the proposed insertion. These values are specified using the
:paramref:`_sqlite.Insert.on_conflict_do_update.set_` parameter.  This
parameter accepts a dictionary which consists of direct values
for UPDATE:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(id='some_id', data='inserted value')

 #>> do_update_stmt = stmt.on_conflict_do_update(
 #..     index_elements=['id'],
 #..     set_=dict(data='updated value')
 #.. )

 #>> print(do_update_stmt)

 #opensql}INSERT INTO my_table (id, data) VALUES (?, ?)
 #N CONFLICT (id) DO UPDATE SET data = ?

.. warning::

 #he :meth:`_sqlite.Insert.on_conflict_do_update` method does **not** take
 #nto account Python-side default UPDATE values or generation functions,
 #.g. those specified using :paramref:`_schema.Column.onupdate`. These
 #alues will not be exercised for an ON CONFLICT style of UPDATE, unless
 #hey are manually specified in the
 #paramref:`_sqlite.Insert.on_conflict_do_update.set_` dictionary.

Updating using the Excluded INSERT Values
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In order to refer to the proposed insertion row, the special alias
:attr:`~.sqlite.Insert.excluded` is available as an attribute on
the :class:`_sqlite.Insert` object; this object creates an "excluded." prefix
on a column, that informs the DO UPDATE to update the row with the value that
would have been inserted had the constraint not failed:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(
 #..     id='some_id',
 #..     data='inserted value',
 #..     author='jlh'
 #.. )

 #>> do_update_stmt = stmt.on_conflict_do_update(
 #..     index_elements=['id'],
 #..     set_=dict(data='updated value', author=stmt.excluded.author)
 #.. )

 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data, author) VALUES (?, ?, ?)
 #N CONFLICT (id) DO UPDATE SET data = ?, author = excluded.author

Additional WHERE Criteria
^^^^^^^^^^^^^^^^^^^^^^^^^

The :meth:`_sqlite.Insert.on_conflict_do_update` method also accepts
a WHERE clause using the :paramref:`_sqlite.Insert.on_conflict_do_update.where`
parameter, which will limit those rows which receive an UPDATE:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(
 #..     id='some_id',
 #..     data='inserted value',
 #..     author='jlh'
 #.. )

 #>> on_update_stmt = stmt.on_conflict_do_update(
 #..     index_elements=['id'],
 #..     set_=dict(data='updated value', author=stmt.excluded.author),
 #..     where=(my_table.c.status == 2)
 #.. )
 #>> print(on_update_stmt)
 #opensql}INSERT INTO my_table (id, data, author) VALUES (?, ?, ?)
 #N CONFLICT (id) DO UPDATE SET data = ?, author = excluded.author
 #HERE my_table.status = ?


Skipping Rows with DO NOTHING
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``ON CONFLICT`` may be used to skip inserting a row entirely
if any conflict with a unique constraint occurs; below this is illustrated
using the :meth:`_sqlite.Insert.on_conflict_do_nothing` method:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(id='some_id', data='inserted value')
 #>> stmt = stmt.on_conflict_do_nothing(index_elements=['id'])
 #>> print(stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (?, ?) ON CONFLICT (id) DO NOTHING


If ``DO NOTHING`` is used without specifying any columns or constraint,
it has the effect of skipping the INSERT for any unique violation which
occurs:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(id='some_id', data='inserted value')
 #>> stmt = stmt.on_conflict_do_nothing()
 #>> print(stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (?, ?) ON CONFLICT DO NOTHING

.. _sqlite_type_reflection:

Type Reflection
---------------

SQLite types are unlike those of most other database backends, in that
the string name of the type usually does not correspond to a "type" in a
one-to-one fashion.  Instead, SQLite links per-column typing behavior
to one of five so-called "type affinities" based on a string matching
pattern for the type.

SQLAlchemy's reflection process, when inspecting types, uses a simple
lookup table to link the keywords returned to provided SQLAlchemy types.
This lookup table is present within the SQLite dialect as it is for all
other dialects.  However, the SQLite dialect has a different "fallback"
routine for when a particular type name is not located in the lookup map;
it instead implements the SQLite "type affinity" scheme located at
https://www.sqlite.org/datatype3.html section 2.1.

The provided typemap will make direct associations from an exact string
name match for the following types:

:class:`_types.BIGINT`, :class:`_types.BLOB`,
:class:`_types.BOOLEAN`, :class:`_types.BOOLEAN`,
:class:`_types.CHAR`, :class:`_types.DATE`,
:class:`_types.DATETIME`, :class:`_types.FLOAT`,
:class:`_types.DECIMAL`, :class:`_types.FLOAT`,
:class:`_types.INTEGER`, :class:`_types.INTEGER`,
:class:`_types.NUMERIC`, :class:`_types.REAL`,
:class:`_types.SMALLINT`, :class:`_types.TEXT`,
:class:`_types.TIME`, :class:`_types.TIMESTAMP`,
:class:`_types.VARCHAR`, :class:`_types.NVARCHAR`,
:class:`_types.NCHAR`

When a type name does not match one of the above types, the "type affinity"
lookup is used instead:

* :class:`_types.INTEGER` is returned if the type name includes the
 #tring ``INT``
* :class:`_types.TEXT` is returned if the type name includes the
 #tring ``CHAR``, ``CLOB`` or ``TEXT``
* :class:`_types.NullType` is returned if the type name includes the
 #tring ``BLOB``
* :class:`_types.REAL` is returned if the type name includes the string
 #`REAL``, ``FLOA`` or ``DOUB``.
* Otherwise, the :class:`_types.NUMERIC` type is used.

.. versionadded:: 0.9.3 Support for SQLite type affinity rules when reflecting
 #olumns.


.. _sqlite_partial_index:

Partial Indexes
---------------

A partial index, e.g. one which uses a WHERE clause, can be specified
with the DDL system using the argument ``sqlite_where``::

 #bl = Table('testtbl', m, Column('data', Integer))
 #dx = Index('test_idx1', tbl.c.data,
 #qlite_where=and_(tbl.c.data > 5, tbl.c.data < 10))

The index will be rendered at create time as::

 #REATE INDEX test_idx1 ON testtbl (data)
 #HERE data > 5 AND data < 10

.. versionadded:: 0.9.9

.. _sqlite_dotted_column_names:

Dotted Column Names
-------------------

Using table or column names that explicitly have periods in them is
**not recommended**.   While this is generally a bad idea for relational
databases in general, as the dot is a syntactically significant character,
the SQLite driver up until version **3.10.0** of SQLite has a bug which
requires that SQLAlchemy filter out these dots in result sets.

.. versionchanged:: 1.1

 #he following SQLite issue has been resolved as of version 3.10.0
 #f SQLite.  SQLAlchemy as of **1.1** automatically disables its internal
 #orkarounds based on detection of this version.

The bug, entirely outside of SQLAlchemy, can be illustrated thusly::

 #mport sqlite3

 #ssert sqlite3.sqlite_version_info < (3, 10, 0), "bug is fixed in this version"

 #onn = sqlite3.connect(":memory:")
 #ursor = conn.cursor()

 #ursor.execute("create table x (a integer, b integer)")
 #ursor.execute("insert into x (a, b) values (1, 1)")
 #ursor.execute("insert into x (a, b) values (2, 2)")

 #ursor.execute("select x.a, x.b from x")
 #ssert [c[0] for c in cursor.description] == ['a', 'b']

 #ursor.execute('''
 #elect x.a, x.b from x where a=1
 #nion
 #elect x.a, x.b from x where a=2
 #'')
 #ssert [c[0] for c in cursor.description] == ['a', 'b'], \
 #c[0] for c in cursor.description]

The second assertion fails::

 #raceback (most recent call last):
 #ile "test.py", line 19, in <module>
 #c[0] for c in cursor.description]
 #ssertionError: ['x.a', 'x.b']

Where above, the driver incorrectly reports the names of the columns
including the name of the table, which is entirely inconsistent vs.
when the UNION is not present.

SQLAlchemy relies upon column names being predictable in how they match
to the original statement, so the SQLAlchemy dialect has no choice but
to filter these out::


 #rom sqlalchemy import create_engine

 #ng = create_engine("sqlite://")
 #onn = eng.connect()

 #onn.exec_driver_sql("create table x (a integer, b integer)")
 #onn.exec_driver_sql("insert into x (a, b) values (1, 1)")
 #onn.exec_driver_sql("insert into x (a, b) values (2, 2)")

 #esult = conn.exec_driver_sql("select x.a, x.b from x")
 #ssert result.keys() == ["a", "b"]

 #esult = conn.exec_driver_sql('''
 #elect x.a, x.b from x where a=1
 #nion
 #elect x.a, x.b from x where a=2
 #'')
 #ssert result.keys() == ["a", "b"]

Note that above, even though SQLAlchemy filters out the dots, *both
names are still addressable*::

 #>> row = result.first()
 #>> row["a"]
 #
 #>> row["x.a"]
 #
 #>> row["b"]
 #
 #>> row["x.b"]
 #

Therefore, the workaround applied by SQLAlchemy only impacts
:meth:`_engine.CursorResult.keys` and :meth:`.Row.keys()` in the public API. In
the very specific case where an application is forced to use column names that
contain dots, and the functionality of :meth:`_engine.CursorResult.keys` and
:meth:`.Row.keys()` is required to return these dotted names unmodified,
the ``sqlite_raw_colnames`` execution option may be provided, either on a
per-:class:`_engine.Connection` basis::

 #esult = conn.execution_options(sqlite_raw_colnames=True).exec_driver_sql('''
 #elect x.a, x.b from x where a=1
 #nion
 #elect x.a, x.b from x where a=2
 #'')
 #ssert result.keys() == ["x.a", "x.b"]

or on a per-:class:`_engine.Engine` basis::

 #ngine = create_engine("sqlite://", execution_options={"sqlite_raw_colnames": True})

When using the per-:class:`_engine.Engine` execution option, note that
**Core and ORM queries that use UNION may not function properly**.

SQLite-specific table options
-----------------------------

One option for CREATE TABLE is supported directly by the SQLite
dialect in conjunction with the :class:`_schema.Table` construct:

* ``WITHOUT ROWID``::

 #able("some_table", metadata, ..., sqlite_with_rowid=False)

.. seealso::

 #SQLite CREATE TABLE options
 #https://www.sqlite.org/lang_createtable.html>`_

"""  # noqa

import datetime
import numbers
import re

from .json import JSON
from .json import JSONIndexType
from .json import JSONPathType
from ... import exc
from ... import processors
from ... import schema as sa_schema
from ... import sql
from ... import types as sqltypes
from ... import util
from ...engine import default
from ...engine import reflection
from ...sql import coercions
from ...sql import ColumnElement
from ...sql import compiler
from ...sql import elements
from ...sql import roles
from ...sql import schema
from ...types import BLOB  # noqa
from ...types import BOOLEAN  # noqa
from ...types import CHAR  # noqa
from ...types import DECIMAL  # noqa
from ...types import FLOAT  # noqa
from ...types import INTEGER  # noqa
from ...types import NUMERIC  # noqa
from ...types import REAL  # noqa
from ...types import SMALLINT  # noqa
from ...types import TEXT  # noqa
from ...types import TIMESTAMP  # noqa
from ...types import VARCHAR  # noqa


class _SQliteJson(JSON):
 #ef result_processor(self, dialect, coltype):
 #efault_processor = super(_SQliteJson, self).result_processor(
 #ialect, coltype
 #

 #ef process(value):
 #ry:
 #eturn default_processor(value)
 #xcept TypeError:
 #f isinstance(value, numbers.Number):
 #eturn value
 #lse:
 #aise

 #eturn process


class _DateTimeMixin(object):
 #reg = None
 #storage_format = None

 #ef __init__(self, storage_format=None, regexp=None, **kw):
 #uper(_DateTimeMixin, self).__init__(**kw)
 #f regexp is not None:
 #elf._reg = re.compile(regexp)
 #f storage_format is not None:
 #elf._storage_format = storage_format

 #property
 #ef format_is_text_affinity(self):
 #""return True if the storage format will automatically imply
 # TEXT affinity.

 #f the storage format contains no non-numeric characters,
 #t will imply a NUMERIC storage format on SQLite; in this case,
 #he type will generate its DDL as DATE_CHAR, DATETIME_CHAR,
 #IME_CHAR.

 #. versionadded:: 1.0.0

 #""
 #pec = self._storage_format % {
 #year": 0,
 #month": 0,
 #day": 0,
 #hour": 0,
 #minute": 0,
 #second": 0,
 #microsecond": 0,
 #
 #eturn bool(re.search(r"[^0-9]", spec))

 #ef adapt(self, cls, **kw):
 #f issubclass(cls, _DateTimeMixin):
 #f self._storage_format:
 #w["storage_format"] = self._storage_format
 #f self._reg:
 #w["regexp"] = self._reg
 #eturn super(_DateTimeMixin, self).adapt(cls, **kw)

 #ef literal_processor(self, dialect):
 #p = self.bind_processor(dialect)

 #ef process(value):
 #eturn "'%s'" % bp(value)

 #eturn process


class DATETIME(_DateTimeMixin, sqltypes.DateTime):
 #"""Represent a Python datetime object in SQLite using a string.

 #he default string storage format is::

 #%(year)04d-%(month)02d-%(day)02d %(hour)02d:%(minute)02d:%(second)02d.%(microsecond)06d"

 #.g.::

 #021-03-15 12:05:57.105542

 #he storage format can be customized to some degree using the
 #`storage_format`` and ``regexp`` parameters, such as::

 #mport re
 #rom sqlalchemy.dialects.sqlite import DATETIME

 #t = DATETIME(storage_format="%(year)04d/%(month)02d/%(day)02d "
 #%(hour)02d:%(minute)02d:%(second)02d",
 #egexp=r"(\d+)/(\d+)/(\d+) (\d+)-(\d+)-(\d+)"
 #

 #param storage_format: format string which will be applied to the dict
 #ith keys year, month, day, hour, minute, second, and microsecond.

 #param regexp: regular expression which will be applied to incoming result
 #ows. If the regexp contains named groups, the resulting match dict is
 #pplied to the Python datetime() constructor as keyword arguments.
 #therwise, if positional groups are used, the datetime() constructor
 #s called with positional arguments via
 #`*map(int, match_obj.groups(0))``.

 #""  # noqa

 #storage_format = (
 #%(year)04d-%(month)02d-%(day)02d "
 #%(hour)02d:%(minute)02d:%(second)02d.%(microsecond)06d"
 #

 #ef __init__(self, *args, **kwargs):
 #runcate_microseconds = kwargs.pop("truncate_microseconds", False)
 #uper(DATETIME, self).__init__(*args, **kwargs)
 #f truncate_microseconds:
 #ssert "storage_format" not in kwargs, (
 #You can specify only "
 #one of truncate_microseconds or storage_format."
 #
 #ssert "regexp" not in kwargs, (
 #You can specify only one of "
 #truncate_microseconds or regexp."
 #
 #elf._storage_format = (
 #%(year)04d-%(month)02d-%(day)02d "
 #%(hour)02d:%(minute)02d:%(second)02d"
 #

 #ef bind_processor(self, dialect):
 #atetime_datetime = datetime.datetime
 #atetime_date = datetime.date
 #ormat_ = self._storage_format

 #ef process(value):
 #f value is None:
 #eturn None
 #lif isinstance(value, datetime_datetime):
 #eturn format_ % {
 #year": value.year,
 #month": value.month,
 #day": value.day,
 #hour": value.hour,
 #minute": value.minute,
 #second": value.second,
 #microsecond": value.microsecond,
 #
 #lif isinstance(value, datetime_date):
 #eturn format_ % {
 #year": value.year,
 #month": value.month,
 #day": value.day,
 #hour": 0,
 #minute": 0,
 #second": 0,
 #microsecond": 0,
 #
 #lse:
 #aise TypeError(
 #SQLite DateTime type only accepts Python "
 #datetime and date objects as input."
 #

 #eturn process

 #ef result_processor(self, dialect, coltype):
 #f self._reg:
 #eturn processors.str_to_datetime_processor_factory(
 #elf._reg, datetime.datetime
 #
 #lse:
 #eturn processors.str_to_datetime


class DATE(_DateTimeMixin, sqltypes.Date):
 #"""Represent a Python date object in SQLite using a string.

 #he default string storage format is::

 #%(year)04d-%(month)02d-%(day)02d"

 #.g.::

 #011-03-15

 #he storage format can be customized to some degree using the
 #`storage_format`` and ``regexp`` parameters, such as::

 #mport re
 #rom sqlalchemy.dialects.sqlite import DATE

 # = DATE(
 #torage_format="%(month)02d/%(day)02d/%(year)04d",
 #egexp=re.compile("(?P<month>\d+)/(?P<day>\d+)/(?P<year>\d+)")
 #

 #param storage_format: format string which will be applied to the
 #ict with keys year, month, and day.

 #param regexp: regular expression which will be applied to
 #ncoming result rows. If the regexp contains named groups, the
 #esulting match dict is applied to the Python date() constructor
 #s keyword arguments. Otherwise, if positional groups are used, the
 #ate() constructor is called with positional arguments via
 #`*map(int, match_obj.groups(0))``.
 #""

 #storage_format = "%(year)04d-%(month)02d-%(day)02d"

 #ef bind_processor(self, dialect):
 #atetime_date = datetime.date
 #ormat_ = self._storage_format

 #ef process(value):
 #f value is None:
 #eturn None
 #lif isinstance(value, datetime_date):
 #eturn format_ % {
 #year": value.year,
 #month": value.month,
 #day": value.day,
 #
 #lse:
 #aise TypeError(
 #SQLite Date type only accepts Python "
 #date objects as input."
 #

 #eturn process

 #ef result_processor(self, dialect, coltype):
 #f self._reg:
 #eturn processors.str_to_datetime_processor_factory(
 #elf._reg, datetime.date
 #
 #lse:
 #eturn processors.str_to_date


class TIME(_DateTimeMixin, sqltypes.Time):
 #"""Represent a Python time object in SQLite using a string.

 #he default string storage format is::

 #%(hour)02d:%(minute)02d:%(second)02d.%(microsecond)06d"

 #.g.::

 #2:05:57.10558

 #he storage format can be customized to some degree using the
 #`storage_format`` and ``regexp`` parameters, such as::

 #mport re
 #rom sqlalchemy.dialects.sqlite import TIME

 # = TIME(storage_format="%(hour)02d-%(minute)02d-"
 #%(second)02d-%(microsecond)06d",
 #egexp=re.compile("(\d+)-(\d+)-(\d+)-(?:-(\d+))?")
 #

 #param storage_format: format string which will be applied to the dict
 #ith keys hour, minute, second, and microsecond.

 #param regexp: regular expression which will be applied to incoming result
 #ows. If the regexp contains named groups, the resulting match dict is
 #pplied to the Python time() constructor as keyword arguments. Otherwise,
 #f positional groups are used, the time() constructor is called with
 #ositional arguments via ``*map(int, match_obj.groups(0))``.
 #""

 #storage_format = "%(hour)02d:%(minute)02d:%(second)02d.%(microsecond)06d"

 #ef __init__(self, *args, **kwargs):
 #runcate_microseconds = kwargs.pop("truncate_microseconds", False)
 #uper(TIME, self).__init__(*args, **kwargs)
 #f truncate_microseconds:
 #ssert "storage_format" not in kwargs, (
 #You can specify only "
 #one of truncate_microseconds or storage_format."
 #
 #ssert "regexp" not in kwargs, (
 #You can specify only one of "
 #truncate_microseconds or regexp."
 #
 #elf._storage_format = "%(hour)02d:%(minute)02d:%(second)02d"

 #ef bind_processor(self, dialect):
 #atetime_time = datetime.time
 #ormat_ = self._storage_format

 #ef process(value):
 #f value is None:
 #eturn None
 #lif isinstance(value, datetime_time):
 #eturn format_ % {
 #hour": value.hour,
 #minute": value.minute,
 #second": value.second,
 #microsecond": value.microsecond,
 #
 #lse:
 #aise TypeError(
 #SQLite Time type only accepts Python "
 #time objects as input."
 #

 #eturn process

 #ef result_processor(self, dialect, coltype):
 #f self._reg:
 #eturn processors.str_to_datetime_processor_factory(
 #elf._reg, datetime.time
 #
 #lse:
 #eturn processors.str_to_time


colspecs = {
 #qltypes.Date: DATE,
 #qltypes.DateTime: DATETIME,
 #qltypes.JSON: _SQliteJson,
 #qltypes.JSON.JSONIndexType: JSONIndexType,
 #qltypes.JSON.JSONPathType: JSONPathType,
 #qltypes.Time: TIME,
}

ischema_names = {
 #BIGINT": sqltypes.BIGINT,
 #BLOB": sqltypes.BLOB,
 #BOOL": sqltypes.BOOLEAN,
 #BOOLEAN": sqltypes.BOOLEAN,
 #CHAR": sqltypes.CHAR,
 #DATE": sqltypes.DATE,
 #DATE_CHAR": sqltypes.DATE,
 #DATETIME": sqltypes.DATETIME,
 #DATETIME_CHAR": sqltypes.DATETIME,
 #DOUBLE": sqltypes.FLOAT,
 #DECIMAL": sqltypes.DECIMAL,
 #FLOAT": sqltypes.FLOAT,
 #INT": sqltypes.INTEGER,
 #INTEGER": sqltypes.INTEGER,
 #JSON": JSON,
 #NUMERIC": sqltypes.NUMERIC,
 #REAL": sqltypes.REAL,
 #SMALLINT": sqltypes.SMALLINT,
 #TEXT": sqltypes.TEXT,
 #TIME": sqltypes.TIME,
 #TIME_CHAR": sqltypes.TIME,
 #TIMESTAMP": sqltypes.TIMESTAMP,
 #VARCHAR": sqltypes.VARCHAR,
 #NVARCHAR": sqltypes.NVARCHAR,
 #NCHAR": sqltypes.NCHAR,
}


class SQLiteCompiler(compiler.SQLCompiler):
 #xtract_map = util.update_copy(
 #ompiler.SQLCompiler.extract_map,
 #
 #month": "%m",
 #day": "%d",
 #year": "%Y",
 #second": "%S",
 #hour": "%H",
 #doy": "%j",
 #minute": "%M",
 #epoch": "%s",
 #dow": "%w",
 #week": "%W",
 #,
 #

 #ef visit_now_func(self, fn, **kw):
 #eturn "CURRENT_TIMESTAMP"

 #ef visit_localtimestamp_func(self, func, **kw):
 #eturn 'DATETIME(CURRENT_TIMESTAMP, "localtime")'

 #ef visit_true(self, expr, **kw):
 #eturn "1"

 #ef visit_false(self, expr, **kw):
 #eturn "0"

 #ef visit_char_length_func(self, fn, **kw):
 #eturn "length%s" % self.function_argspec(fn)

 #ef visit_cast(self, cast, **kwargs):
 #f self.dialect.supports_cast:
 #eturn super(SQLiteCompiler, self).visit_cast(cast, **kwargs)
 #lse:
 #eturn self.process(cast.clause, **kwargs)

 #ef visit_extract(self, extract, **kw):
 #ry:
 #eturn "CAST(STRFTIME('%s', %s) AS INTEGER)" % (
 #elf.extract_map[extract.field],
 #elf.process(extract.expr, **kw),
 #
 #xcept KeyError as err:
 #til.raise_(
 #xc.CompileError(
 #%s is not a valid extract argument." % extract.field
 #,
 #eplace_context=err,
 #

 #ef limit_clause(self, select, **kw):
 #ext = ""
 #f select._limit_clause is not None:
 #ext += "\n LIMIT " + self.process(select._limit_clause, **kw)
 #f select._offset_clause is not None:
 #f select._limit_clause is None:
 #ext += "\n LIMIT " + self.process(sql.literal(-1))
 #ext += " OFFSET " + self.process(select._offset_clause, **kw)
 #lse:
 #ext += " OFFSET " + self.process(sql.literal(0), **kw)
 #eturn text

 #ef for_update_clause(self, select, **kw):
        # sqlite has no "FOR UPDATE" AFAICT
 #eturn ""

 #ef visit_is_distinct_from_binary(self, binary, operator, **kw):
 #eturn "%s IS NOT %s" % (
 #elf.process(binary.left),
 #elf.process(binary.right),
 #

 #ef visit_is_not_distinct_from_binary(self, binary, operator, **kw):
 #eturn "%s IS %s" % (
 #elf.process(binary.left),
 #elf.process(binary.right),
 #

 #ef visit_json_getitem_op_binary(self, binary, operator, **kw):
 #f binary.type._type_affinity is sqltypes.JSON:
 #xpr = "JSON_QUOTE(JSON_EXTRACT(%s, %s))"
 #lse:
 #xpr = "JSON_EXTRACT(%s, %s)"

 #eturn expr % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef visit_json_path_getitem_op_binary(self, binary, operator, **kw):
 #f binary.type._type_affinity is sqltypes.JSON:
 #xpr = "JSON_QUOTE(JSON_EXTRACT(%s, %s))"
 #lse:
 #xpr = "JSON_EXTRACT(%s, %s)"

 #eturn expr % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef visit_empty_set_op_expr(self, type_, expand_op):
        # slightly old SQLite versions don't seem to be able to handle
        # the empty set impl
 #eturn self.visit_empty_set_expr(type_)

 #ef visit_empty_set_expr(self, element_types):
 #eturn "SELECT %s FROM (SELECT %s) WHERE 1!=1" % (
 #, ".join("1" for type_ in element_types or [INTEGER()]),
 #, ".join("1" for type_ in element_types or [INTEGER()]),
 #

 #ef visit_regexp_match_op_binary(self, binary, operator, **kw):
 #eturn self._generate_generic_binary(binary, " REGEXP ", **kw)

 #ef visit_not_regexp_match_op_binary(self, binary, operator, **kw):
 #eturn self._generate_generic_binary(binary, " NOT REGEXP ", **kw)

 #ef _on_conflict_target(self, clause, **kw):
 #f clause.constraint_target is not None:
 #arget_text = "(%s)" % clause.constraint_target
 #lif clause.inferred_target_elements is not None:
 #arget_text = "(%s)" % ", ".join(
 #
 #elf.preparer.quote(c)
 #f isinstance(c, util.string_types)
 #lse self.process(c, include_table=False, use_schema=False)
 #
 #or c in clause.inferred_target_elements
 #
 #f clause.inferred_target_whereclause is not None:
 #arget_text += " WHERE %s" % self.process(
 #lause.inferred_target_whereclause,
 #nclude_table=False,
 #se_schema=False,
 #iteral_binds=True,
 #

 #lse:
 #arget_text = ""

 #eturn target_text

 #ef visit_on_conflict_do_nothing(self, on_conflict, **kw):

 #arget_text = self._on_conflict_target(on_conflict, **kw)

 #f target_text:
 #eturn "ON CONFLICT %s DO NOTHING" % target_text
 #lse:
 #eturn "ON CONFLICT DO NOTHING"

 #ef visit_on_conflict_do_update(self, on_conflict, **kw):
 #lause = on_conflict

 #arget_text = self._on_conflict_target(on_conflict, **kw)

 #ction_set_ops = []

 #et_parameters = dict(clause.update_values_to_set)
        # create a list of column assignment clauses as tuples

 #nsert_statement = self.stack[-1]["selectable"]
 #ols = insert_statement.table.c
 #or c in cols:
 #ol_key = c.key

 #f col_key in set_parameters:
 #alue = set_parameters.pop(col_key)
 #lif c in set_parameters:
 #alue = set_parameters.pop(c)
 #lse:
 #ontinue

 #f coercions._is_literal(value):
 #alue = elements.BindParameter(None, value, type_=c.type)

 #lse:
 #f (
 #sinstance(value, elements.BindParameter)
 #nd value.type._isnull
 #:
 #alue = value._clone()
 #alue.type = c.type
 #alue_text = self.process(value.self_group(), use_schema=False)

 #ey_text = self.preparer.quote(col_key)
 #ction_set_ops.append("%s = %s" % (key_text, value_text))

        # check for names that don't match columns
 #f set_parameters:
 #til.warn(
 #Additional column names not matching "
 #any column keys in table '%s': %s"
 # (
 #elf.current_executable.table.name,
 #", ".join("'%s'" % c for c in set_parameters)),
 #
 #
 #or k, v in set_parameters.items():
 #ey_text = (
 #elf.preparer.quote(k)
 #f isinstance(k, util.string_types)
 #lse self.process(k, use_schema=False)
 #
 #alue_text = self.process(
 #oercions.expect(roles.ExpressionElementRole, v),
 #se_schema=False,
 #
 #ction_set_ops.append("%s = %s" % (key_text, value_text))

 #ction_text = ", ".join(action_set_ops)
 #f clause.update_whereclause is not None:
 #ction_text += " WHERE %s" % self.process(
 #lause.update_whereclause, include_table=True, use_schema=False
 #

 #eturn "ON CONFLICT %s DO UPDATE SET %s" % (target_text, action_text)


class SQLiteDDLCompiler(compiler.DDLCompiler):
 #ef get_column_specification(self, column, **kwargs):

 #oltype = self.dialect.type_compiler.process(
 #olumn.type, type_expression=column
 #
 #olspec = self.preparer.format_column(column) + " " + coltype
 #efault = self.get_column_default_string(column)
 #f default is not None:
 #f isinstance(column.server_default.arg, ColumnElement):
 #efault = "(" + default + ")"
 #olspec += " DEFAULT " + default

 #f not column.nullable:
 #olspec += " NOT NULL"

 #n_conflict_clause = column.dialect_options["sqlite"][
 #on_conflict_not_null"
 #
 #f on_conflict_clause is not None:
 #olspec += " ON CONFLICT " + on_conflict_clause

 #f column.primary_key:
 #f (
 #olumn.autoincrement is True
 #nd len(column.table.primary_key.columns) != 1
 #:
 #aise exc.CompileError(
 #SQLite does not support autoincrement for "
 #composite primary keys"
 #

 #f (
 #olumn.table.dialect_options["sqlite"]["autoincrement"]
 #nd len(column.table.primary_key.columns) == 1
 #nd issubclass(column.type._type_affinity, sqltypes.Integer)
 #nd not column.foreign_keys
 #:
 #olspec += " PRIMARY KEY"

 #n_conflict_clause = column.dialect_options["sqlite"][
 #on_conflict_primary_key"
 #
 #f on_conflict_clause is not None:
 #olspec += " ON CONFLICT " + on_conflict_clause

 #olspec += " AUTOINCREMENT"

 #f column.computed is not None:
 #olspec += " " + self.process(column.computed)

 #eturn colspec

 #ef visit_primary_key_constraint(self, constraint):
        # for columns with sqlite_autoincrement=True,
        # the PRIMARY KEY constraint can only be inline
        # with the column itself.
 #f len(constraint.columns) == 1:
 # = list(constraint)[0]
 #f (
 #.primary_key
 #nd c.table.dialect_options["sqlite"]["autoincrement"]
 #nd issubclass(c.type._type_affinity, sqltypes.Integer)
 #nd not c.foreign_keys
 #:
 #eturn None

 #ext = super(SQLiteDDLCompiler, self).visit_primary_key_constraint(
 #onstraint
 #

 #n_conflict_clause = constraint.dialect_options["sqlite"][
 #on_conflict"
 #
 #f on_conflict_clause is None and len(constraint.columns) == 1:
 #n_conflict_clause = list(constraint)[0].dialect_options["sqlite"][
 #on_conflict_primary_key"
 #

 #f on_conflict_clause is not None:
 #ext += " ON CONFLICT " + on_conflict_clause

 #eturn text

 #ef visit_unique_constraint(self, constraint):
 #ext = super(SQLiteDDLCompiler, self).visit_unique_constraint(
 #onstraint
 #

 #n_conflict_clause = constraint.dialect_options["sqlite"][
 #on_conflict"
 #
 #f on_conflict_clause is None and len(constraint.columns) == 1:
 #ol1 = list(constraint)[0]
 #f isinstance(col1, schema.SchemaItem):
 #n_conflict_clause = list(constraint)[0].dialect_options[
 #sqlite"
 #["on_conflict_unique"]

 #f on_conflict_clause is not None:
 #ext += " ON CONFLICT " + on_conflict_clause

 #eturn text

 #ef visit_check_constraint(self, constraint):
 #ext = super(SQLiteDDLCompiler, self).visit_check_constraint(
 #onstraint
 #

 #n_conflict_clause = constraint.dialect_options["sqlite"][
 #on_conflict"
 #

 #f on_conflict_clause is not None:
 #ext += " ON CONFLICT " + on_conflict_clause

 #eturn text

 #ef visit_column_check_constraint(self, constraint):
 #ext = super(SQLiteDDLCompiler, self).visit_column_check_constraint(
 #onstraint
 #

 #f constraint.dialect_options["sqlite"]["on_conflict"] is not None:
 #aise exc.CompileError(
 #SQLite does not support on conflict clause for "
 #column check constraint"
 #

 #eturn text

 #ef visit_foreign_key_constraint(self, constraint):

 #ocal_table = constraint.elements[0].parent.table
 #emote_table = constraint.elements[0].column.table

 #f local_table.schema != remote_table.schema:
 #eturn None
 #lse:
 #eturn super(SQLiteDDLCompiler, self).visit_foreign_key_constraint(
 #onstraint
 #

 #ef define_constraint_remote_table(self, constraint, table, preparer):
 #""Format the remote table clause of a CREATE CONSTRAINT clause."""

 #eturn preparer.format_table(table, use_schema=False)

 #ef visit_create_index(
 #elf, create, include_schema=False, include_table_schema=True
 #:
 #ndex = create.element
 #elf._verify_index_table(index)
 #reparer = self.preparer
 #ext = "CREATE "
 #f index.unique:
 #ext += "UNIQUE "

 #ext += "INDEX "

 #f create.if_not_exists:
 #ext += "IF NOT EXISTS "

 #ext += "%s ON %s (%s)" % (
 #elf._prepared_index_name(index, include_schema=True),
 #reparer.format_table(index.table, use_schema=False),
 #, ".join(
 #elf.sql_compiler.process(
 #xpr, include_table=False, literal_binds=True
 #
 #or expr in index.expressions
 #,
 #

 #hereclause = index.dialect_options["sqlite"]["where"]
 #f whereclause is not None:
 #here_compiled = self.sql_compiler.process(
 #hereclause, include_table=False, literal_binds=True
 #
 #ext += " WHERE " + where_compiled

 #eturn text

 #ef post_create_table(self, table):
 #f table.dialect_options["sqlite"]["with_rowid"] is False:
 #eturn "\n WITHOUT ROWID"
 #eturn ""


class SQLiteTypeCompiler(compiler.GenericTypeCompiler):
 #ef visit_large_binary(self, type_, **kw):
 #eturn self.visit_BLOB(type_)

 #ef visit_DATETIME(self, type_, **kw):
 #f (
 #ot isinstance(type_, _DateTimeMixin)
 #r type_.format_is_text_affinity
 #:
 #eturn super(SQLiteTypeCompiler, self).visit_DATETIME(type_)
 #lse:
 #eturn "DATETIME_CHAR"

 #ef visit_DATE(self, type_, **kw):
 #f (
 #ot isinstance(type_, _DateTimeMixin)
 #r type_.format_is_text_affinity
 #:
 #eturn super(SQLiteTypeCompiler, self).visit_DATE(type_)
 #lse:
 #eturn "DATE_CHAR"

 #ef visit_TIME(self, type_, **kw):
 #f (
 #ot isinstance(type_, _DateTimeMixin)
 #r type_.format_is_text_affinity
 #:
 #eturn super(SQLiteTypeCompiler, self).visit_TIME(type_)
 #lse:
 #eturn "TIME_CHAR"

 #ef visit_JSON(self, type_, **kw):
        # note this name provides NUMERIC affinity, not TEXT.
        # should not be an issue unless the JSON value consists of a single
        # numeric value.   JSONTEXT can be used if this case is required.
 #eturn "JSON"


class SQLiteIdentifierPreparer(compiler.IdentifierPreparer):
 #eserved_words = set(
 #
 #add",
 #after",
 #all",
 #alter",
 #analyze",
 #and",
 #as",
 #asc",
 #attach",
 #autoincrement",
 #before",
 #begin",
 #between",
 #by",
 #cascade",
 #case",
 #cast",
 #check",
 #collate",
 #column",
 #commit",
 #conflict",
 #constraint",
 #create",
 #cross",
 #current_date",
 #current_time",
 #current_timestamp",
 #database",
 #default",
 #deferrable",
 #deferred",
 #delete",
 #desc",
 #detach",
 #distinct",
 #drop",
 #each",
 #else",
 #end",
 #escape",
 #except",
 #exclusive",
 #exists",
 #explain",
 #false",
 #fail",
 #for",
 #foreign",
 #from",
 #full",
 #glob",
 #group",
 #having",
 #if",
 #ignore",
 #immediate",
 #in",
 #index",
 #indexed",
 #initially",
 #inner",
 #insert",
 #instead",
 #intersect",
 #into",
 #is",
 #isnull",
 #join",
 #key",
 #left",
 #like",
 #limit",
 #match",
 #natural",
 #not",
 #notnull",
 #null",
 #of",
 #offset",
 #on",
 #or",
 #order",
 #outer",
 #plan",
 #pragma",
 #primary",
 #query",
 #raise",
 #references",
 #reindex",
 #rename",
 #replace",
 #restrict",
 #right",
 #rollback",
 #row",
 #select",
 #set",
 #table",
 #temp",
 #temporary",
 #then",
 #to",
 #transaction",
 #trigger",
 #true",
 #union",
 #unique",
 #update",
 #using",
 #vacuum",
 #values",
 #view",
 #virtual",
 #when",
 #where",
 #
 #


class SQLiteExecutionContext(default.DefaultExecutionContext):
 #util.memoized_property
 #ef _preserve_raw_colnames(self):
 #eturn (
 #ot self.dialect._broken_dotted_colnames
 #r self.execution_options.get("sqlite_raw_colnames", False)
 #

 #ef _translate_colname(self, colname):
        # TODO: detect SQLite version 3.10.0 or greater;
        # see [ticket:3633]

        # adjust for dotted column names.  SQLite
        # in the case of UNION may store col names as
        # "tablename.colname", or if using an attached database,
        # "database.tablename.colname", in cursor.description
 #f not self._preserve_raw_colnames and "." in colname:
 #eturn colname.split(".")[-1], colname
 #lse:
 #eturn colname, None


class SQLiteDialect(default.DefaultDialect):
 #ame = "sqlite"
 #upports_alter = False
 #upports_unicode_statements = True
 #upports_unicode_binds = True

    # SQlite supports "DEFAULT VALUES" but *does not* support
    # "VALUES (DEFAULT)"
 #upports_default_values = True
 #upports_default_metavalue = False

 #upports_empty_insert = False
 #upports_cast = True
 #upports_multivalues_insert = True
 #uple_in_values = True
 #upports_statement_cache = True

 #efault_paramstyle = "qmark"
 #xecution_ctx_cls = SQLiteExecutionContext
 #tatement_compiler = SQLiteCompiler
 #dl_compiler = SQLiteDDLCompiler
 #ype_compiler = SQLiteTypeCompiler
 #reparer = SQLiteIdentifierPreparer
 #schema_names = ischema_names
 #olspecs = colspecs
 #solation_level = None

 #onstruct_arguments = [
 #
 #a_schema.Table,
 #
 #autoincrement": False,
 #with_rowid": True,
 #,
 #,
 #sa_schema.Index, {"where": None}),
 #
 #a_schema.Column,
 #
 #on_conflict_primary_key": None,
 #on_conflict_not_null": None,
 #on_conflict_unique": None,
 #,
 #,
 #sa_schema.Constraint, {"on_conflict": None}),
 #

 #broken_fk_pragma_quotes = False
 #broken_dotted_colnames = False

 #util.deprecated_params(
 #json_serializer=(
 #1.3.7",
 #The _json_serializer argument to the SQLite dialect has "
 #been renamed to the correct name of json_serializer.  The old "
 #argument name will be removed in a future release.",
 #,
 #json_deserializer=(
 #1.3.7",
 #The _json_deserializer argument to the SQLite dialect has "
 #been renamed to the correct name of json_deserializer.  The old "
 #argument name will be removed in a future release.",
 #,
 #
 #ef __init__(
 #elf,
 #solation_level=None,
 #ative_datetime=False,
 #son_serializer=None,
 #son_deserializer=None,
 #json_serializer=None,
 #json_deserializer=None,
 #*kwargs
 #:
 #efault.DefaultDialect.__init__(self, **kwargs)
 #elf.isolation_level = isolation_level

 #f _json_serializer:
 #son_serializer = _json_serializer
 #f _json_deserializer:
 #son_deserializer = _json_deserializer
 #elf._json_serializer = json_serializer
 #elf._json_deserializer = json_deserializer

        # this flag used by pysqlite dialect, and perhaps others in the
        # future, to indicate the driver is handling date/timestamp
        # conversions (and perhaps datetime/time as well on some hypothetical
        # driver ?)
 #elf.native_datetime = native_datetime

 #f self.dbapi is not None:
 #f self.dbapi.sqlite_version_info < (3, 7, 16):
 #til.warn(
 #SQLite version %s is older than 3.7.16, and will not "
 #support right nested joins, as are sometimes used in "
 #more complex ORM scenarios.  SQLAlchemy 1.4 and above "
 #no longer tries to rewrite these joins."
 # (self.dbapi.sqlite_version_info,)
 #

 #elf._broken_dotted_colnames = self.dbapi.sqlite_version_info < (
 #,
 #0,
 #,
 #
 #elf.supports_default_values = self.dbapi.sqlite_version_info >= (
 #,
 #,
 #,
 #
 #elf.supports_cast = self.dbapi.sqlite_version_info >= (3, 2, 3)
 #elf.supports_multivalues_insert = (
                # https://www.sqlite.org/releaselog/3_7_11.html
 #elf.dbapi.sqlite_version_info
 #= (3, 7, 11)
 #
            # see https://www.sqlalchemy.org/trac/ticket/2568
            # as well as https://www.sqlite.org/src/info/600482d161
 #elf._broken_fk_pragma_quotes = self.dbapi.sqlite_version_info < (
 #,
 #,
 #4,
 #

 #isolation_lookup = {"READ UNCOMMITTED": 1, "SERIALIZABLE": 0}

 #ef set_isolation_level(self, connection, level):
 #ry:
 #solation_level = self._isolation_lookup[level.replace("_", " ")]
 #xcept KeyError as err:
 #til.raise_(
 #xc.ArgumentError(
 #Invalid value '%s' for isolation_level. "
 #Valid isolation levels for %s are %s"
 # (level, self.name, ", ".join(self._isolation_lookup))
 #,
 #eplace_context=err,
 #
 #ursor = connection.cursor()
 #ursor.execute("PRAGMA read_uncommitted = %d" % isolation_level)
 #ursor.close()

 #ef get_isolation_level(self, connection):
 #ursor = connection.cursor()
 #ursor.execute("PRAGMA read_uncommitted")
 #es = cursor.fetchone()
 #f res:
 #alue = res[0]
 #lse:
            # https://www.sqlite.org/changes.html#version_3_3_3
            # "Optional READ UNCOMMITTED isolation (instead of the
            # default isolation level of SERIALIZABLE) and
            # table level locking when database connections
            # share a common cache.""
            # pre-SQLite 3.3.0 default to 0
 #alue = 0
 #ursor.close()
 #f value == 0:
 #eturn "SERIALIZABLE"
 #lif value == 1:
 #eturn "READ UNCOMMITTED"
 #lse:
 #ssert False, "Unknown isolation level %s" % value

 #ef on_connect(self):
 #f self.isolation_level is not None:

 #ef connect(conn):
 #elf.set_isolation_level(conn, self.isolation_level)

 #eturn connect
 #lse:
 #eturn None

 #reflection.cache
 #ef get_schema_names(self, connection, **kw):
 # = "PRAGMA database_list"
 #l = connection.exec_driver_sql(s)

 #eturn [db[1] for db in dl if db[1] != "temp"]

 #reflection.cache
 #ef get_table_names(self, connection, schema=None, **kw):
 #f schema is not None:
 #schema = self.identifier_preparer.quote_identifier(schema)
 #aster = "%s.sqlite_master" % qschema
 #lse:
 #aster = "sqlite_master"
 # = ("SELECT name FROM %s " "WHERE type='table' ORDER BY name") % (
 #aster,
 #
 #s = connection.exec_driver_sql(s)
 #eturn [row[0] for row in rs]

 #reflection.cache
 #ef get_temp_table_names(self, connection, **kw):
 # = (
 #SELECT name FROM sqlite_temp_master "
 #WHERE type='table' ORDER BY name "
 #
 #s = connection.exec_driver_sql(s)

 #eturn [row[0] for row in rs]

 #reflection.cache
 #ef get_temp_view_names(self, connection, **kw):
 # = (
 #SELECT name FROM sqlite_temp_master "
 #WHERE type='view' ORDER BY name "
 #
 #s = connection.exec_driver_sql(s)

 #eturn [row[0] for row in rs]

 #ef has_table(self, connection, table_name, schema=None):
 #elf._ensure_has_table_connection(connection)

 #nfo = self._get_table_pragma(
 #onnection, "table_info", table_name, schema=schema
 #
 #eturn bool(info)

 #ef _get_default_schema_name(self, connection):
 #eturn "main"

 #reflection.cache
 #ef get_view_names(self, connection, schema=None, **kw):
 #f schema is not None:
 #schema = self.identifier_preparer.quote_identifier(schema)
 #aster = "%s.sqlite_master" % qschema
 #lse:
 #aster = "sqlite_master"
 # = ("SELECT name FROM %s " "WHERE type='view' ORDER BY name") % (
 #aster,
 #
 #s = connection.exec_driver_sql(s)

 #eturn [row[0] for row in rs]

 #reflection.cache
 #ef get_view_definition(self, connection, view_name, schema=None, **kw):
 #f schema is not None:
 #schema = self.identifier_preparer.quote_identifier(schema)
 #aster = "%s.sqlite_master" % qschema
 # = ("SELECT sql FROM %s WHERE name = ? AND type='view'") % (
 #aster,
 #
 #s = connection.exec_driver_sql(s, (view_name,))
 #lse:
 #ry:
 # = (
 #SELECT sql FROM "
 # (SELECT * FROM sqlite_master UNION ALL "
 #  SELECT * FROM sqlite_temp_master) "
 #WHERE name = ? "
 #AND type='view'"
 #
 #s = connection.exec_driver_sql(s, (view_name,))
 #xcept exc.DBAPIError:
 # = (
 #SELECT sql FROM sqlite_master WHERE name = ? "
 #AND type='view'"
 #
 #s = connection.exec_driver_sql(s, (view_name,))

 #esult = rs.fetchall()
 #f result:
 #eturn result[0].sql

 #reflection.cache
 #ef get_columns(self, connection, table_name, schema=None, **kw):
 #ragma = "table_info"
        # computed columns are threaded as hidden, they require table_xinfo
 #f self.server_version_info >= (3, 31):
 #ragma = "table_xinfo"
 #nfo = self._get_table_pragma(
 #onnection, pragma, table_name, schema=schema
 #
 #olumns = []
 #ablesql = None
 #or row in info:
 #ame = row[1]
 #ype_ = row[2].upper()
 #ullable = not row[3]
 #efault = row[4]
 #rimary_key = row[5]
 #idden = row[6] if pragma == "table_xinfo" else 0

            # hidden has value 0 for normal columns, 1 for hidden columns,
            # 2 for computed virtual columns and 3 for computed stored columns
            # https://www.sqlite.org/src/info/069351b85f9a706f60d3e98fbc8aaf40c374356b967c0464aede30ead3d9d18b
 #f hidden == 1:
 #ontinue

 #enerated = bool(hidden)
 #ersisted = hidden == 3

 #f tablesql is None and generated:
 #ablesql = self._get_table_sql(
 #onnection, table_name, schema, **kw
 #

 #olumns.append(
 #elf._get_column_info(
 #ame,
 #ype_,
 #ullable,
 #efault,
 #rimary_key,
 #enerated,
 #ersisted,
 #ablesql,
 #
 #
 #eturn columns

 #ef _get_column_info(
 #elf,
 #ame,
 #ype_,
 #ullable,
 #efault,
 #rimary_key,
 #enerated,
 #ersisted,
 #ablesql,
 #:

 #f generated:
            # the type of a column "cc INTEGER GENERATED ALWAYS AS (1 + 42)"
            # somehow is "INTEGER GENERATED ALWAYS"
 #ype_ = re.sub("generated", "", type_, flags=re.IGNORECASE)
 #ype_ = re.sub("always", "", type_, flags=re.IGNORECASE).strip()

 #oltype = self._resolve_type_affinity(type_)

 #f default is not None:
 #efault = util.text_type(default)

 #olspec = {
 #name": name,
 #type": coltype,
 #nullable": nullable,
 #default": default,
 #autoincrement": "auto",
 #primary_key": primary_key,
 #
 #f generated:
 #qltext = ""
 #f tablesql:
 #attern = r"[^,]*\s+AS\s+\(([^,]*)\)\s*(?:virtual|stored)?"
 #atch = re.search(
 #e.escape(name) + pattern, tablesql, re.IGNORECASE
 #
 #f match:
 #qltext = match.group(1)
 #olspec["computed"] = {"sqltext": sqltext, "persisted": persisted}
 #eturn colspec

 #ef _resolve_type_affinity(self, type_):
 #""Return a data type from a reflected column, using affinity rules.

 #QLite's goal for universal compatibility introduces some complexity
 #uring reflection, as a column's defined type might not actually be a
 #ype that SQLite understands - or indeed, my not be defined *at all*.
 #nternally, SQLite handles this with a 'data type affinity' for each
 #olumn definition, mapping to one of 'TEXT', 'NUMERIC', 'INTEGER',
 #REAL', or 'NONE' (raw bits). The algorithm that determines this is
 #isted in https://www.sqlite.org/datatype3.html section 2.1.

 #his method allows SQLAlchemy to support that algorithm, while still
 #roviding access to smarter reflection utilities by recognizing
 #olumn definitions that SQLite only supports through affinity (like
 #ATE and DOUBLE).

 #""
 #atch = re.match(r"([\w ]+)(\(.*?\))?", type_)
 #f match:
 #oltype = match.group(1)
 #rgs = match.group(2)
 #lse:
 #oltype = ""
 #rgs = ""

 #f coltype in self.ischema_names:
 #oltype = self.ischema_names[coltype]
 #lif "INT" in coltype:
 #oltype = sqltypes.INTEGER
 #lif "CHAR" in coltype or "CLOB" in coltype or "TEXT" in coltype:
 #oltype = sqltypes.TEXT
 #lif "BLOB" in coltype or not coltype:
 #oltype = sqltypes.NullType
 #lif "REAL" in coltype or "FLOA" in coltype or "DOUB" in coltype:
 #oltype = sqltypes.REAL
 #lse:
 #oltype = sqltypes.NUMERIC

 #f args is not None:
 #rgs = re.findall(r"(\d+)", args)
 #ry:
 #oltype = coltype(*[int(a) for a in args])
 #xcept TypeError:
 #til.warn(
 #Could not instantiate type %s with "
 #reflected arguments %s; using no arguments."
 # (coltype, args)
 #
 #oltype = coltype()
 #lse:
 #oltype = coltype()

 #eturn coltype

 #reflection.cache
 #ef get_pk_constraint(self, connection, table_name, schema=None, **kw):
 #onstraint_name = None
 #able_data = self._get_table_sql(connection, table_name, schema=schema)
 #f table_data:
 #K_PATTERN = r"CONSTRAINT (\w+) PRIMARY KEY"
 #esult = re.search(PK_PATTERN, table_data, re.I)
 #onstraint_name = result.group(1) if result else None

 #ols = self.get_columns(connection, table_name, schema, **kw)
 #ols.sort(key=lambda col: col.get("primary_key"))
 #keys = []
 #or col in cols:
 #f col["primary_key"]:
 #keys.append(col["name"])

 #eturn {"constrained_columns": pkeys, "name": constraint_name}

 #reflection.cache
 #ef get_foreign_keys(self, connection, table_name, schema=None, **kw):
        # sqlite makes this *extremely difficult*.
        # First, use the pragma to get the actual FKs.
 #ragma_fks = self._get_table_pragma(
 #onnection, "foreign_key_list", table_name, schema=schema
 #

 #ks = {}

 #or row in pragma_fks:
 #numerical_id, rtbl, lcol, rcol) = (row[0], row[2], row[3], row[4])

 #f not rcol:
                # no referred column, which means it was not named in the
                # original DDL.  The referred columns of the foreign key
                # constraint are therefore the primary key of the referred
                # table.
 #eferred_pk = self.get_pk_constraint(
 #onnection, rtbl, schema=schema, **kw
 #
                # note that if table doesn't exist, we still get back a record,
                # just it has no columns in it
 #eferred_columns = referred_pk["constrained_columns"]
 #lse:
                # note we use this list only if this is the first column
                # in the constraint.  for subsequent columns we ignore the
                # list and append "rcol" if present.
 #eferred_columns = []

 #f self._broken_fk_pragma_quotes:
 #tbl = re.sub(r"^[\"\[`\']|[\"\]`\']$", "", rtbl)

 #f numerical_id in fks:
 #k = fks[numerical_id]
 #lse:
 #k = fks[numerical_id] = {
 #name": None,
 #constrained_columns": [],
 #referred_schema": schema,
 #referred_table": rtbl,
 #referred_columns": referred_columns,
 #options": {},
 #
 #ks[numerical_id] = fk

 #k["constrained_columns"].append(lcol)

 #f rcol:
 #k["referred_columns"].append(rcol)

 #ef fk_sig(constrained_columns, referred_table, referred_columns):
 #eturn (
 #uple(constrained_columns)
 # (referred_table,)
 # tuple(referred_columns)
 #

        # then, parse the actual SQL and attempt to find DDL that matches
        # the names as well.   SQLite saves the DDL in whatever format
        # it was typed in as, so need to be liberal here.

 #eys_by_signature = dict(
 #
 #k_sig(
 #k["constrained_columns"],
 #k["referred_table"],
 #k["referred_columns"],
 #,
 #k,
 #
 #or fk in fks.values()
 #

 #able_data = self._get_table_sql(connection, table_name, schema=schema)
 #f table_data is None:
            # system tables, etc.
 #eturn []

 #ef parse_fks():
 #K_PATTERN = (
 #"(?:CONSTRAINT (\w+) +)?"
 #"FOREIGN KEY *\( *(.+?) *\) +"
 #'REFERENCES +(?:(?:"(.+?)")|([a-z0-9_]+)) *\((.+?)\) *'
 #"((?:ON (?:DELETE|UPDATE) "
 #"(?:SET NULL|SET DEFAULT|CASCADE|RESTRICT|NO ACTION) *)*)"
 #
 #or match in re.finditer(FK_PATTERN, table_data, re.I):
 #
 #onstraint_name,
 #onstrained_columns,
 #eferred_quoted_name,
 #eferred_name,
 #eferred_columns,
 #nupdatedelete,
 # = match.group(1, 2, 3, 4, 5, 6)
 #onstrained_columns = list(
 #elf._find_cols_in_sig(constrained_columns)
 #
 #f not referred_columns:
 #eferred_columns = constrained_columns
 #lse:
 #eferred_columns = list(
 #elf._find_cols_in_sig(referred_columns)
 #
 #eferred_name = referred_quoted_name or referred_name
 #ptions = {}

 #or token in re.split(r" *\bON\b *", onupdatedelete.upper()):
 #f token.startswith("DELETE"):
 #ndelete = token[6:].strip()
 #f ondelete and ondelete != "NO ACTION":
 #ptions["ondelete"] = ondelete
 #lif token.startswith("UPDATE"):
 #nupdate = token[6:].strip()
 #f onupdate and onupdate != "NO ACTION":
 #ptions["onupdate"] = onupdate
 #ield (
 #onstraint_name,
 #onstrained_columns,
 #eferred_name,
 #eferred_columns,
 #ptions,
 #

 #keys = []

 #or (
 #onstraint_name,
 #onstrained_columns,
 #eferred_name,
 #eferred_columns,
 #ptions,
 # in parse_fks():
 #ig = fk_sig(constrained_columns, referred_name, referred_columns)
 #f sig not in keys_by_signature:
 #til.warn(
 #WARNING: SQL-parsed foreign key constraint "
 #'%s' could not be located in PRAGMA "
 #foreign_keys for table %s" % (sig, table_name)
 #
 #ontinue
 #ey = keys_by_signature.pop(sig)
 #ey["name"] = constraint_name
 #ey["options"] = options
 #keys.append(key)
        # assume the remainders are the unnamed, inline constraints, just
        # use them as is as it's extremely difficult to parse inline
        # constraints
 #keys.extend(keys_by_signature.values())
 #eturn fkeys

 #ef _find_cols_in_sig(self, sig):
 #or match in re.finditer(r'(?:"(.+?)")|([a-z0-9_]+)', sig, re.I):
 #ield match.group(1) or match.group(2)

 #reflection.cache
 #ef get_unique_constraints(
 #elf, connection, table_name, schema=None, **kw
 #:

 #uto_index_by_sig = {}
 #or idx in self.get_indexes(
 #onnection,
 #able_name,
 #chema=schema,
 #nclude_auto_indexes=True,
 #*kw
 #:
 #f not idx["name"].startswith("sqlite_autoindex"):
 #ontinue
 #ig = tuple(idx["column_names"])
 #uto_index_by_sig[sig] = idx

 #able_data = self._get_table_sql(
 #onnection, table_name, schema=schema, **kw
 #
 #f not table_data:
 #eturn []

 #nique_constraints = []

 #ef parse_uqs():
 #NIQUE_PATTERN = r'(?:CONSTRAINT "?(.+?)"? +)?UNIQUE *\((.+?)\)'
 #NLINE_UNIQUE_PATTERN = (
 #'(?:(".+?")|([a-z0-9]+)) ' r"+[a-z0-9_ ]+? +UNIQUE"
 #

 #or match in re.finditer(UNIQUE_PATTERN, table_data, re.I):
 #ame, cols = match.group(1, 2)
 #ield name, list(self._find_cols_in_sig(cols))

            # we need to match inlines as well, as we seek to differentiate
            # a UNIQUE constraint from a UNIQUE INDEX, even though these
            # are kind of the same thing :)
 #or match in re.finditer(INLINE_UNIQUE_PATTERN, table_data, re.I):
 #ols = list(
 #elf._find_cols_in_sig(match.group(1) or match.group(2))
 #
 #ield None, cols

 #or name, cols in parse_uqs():
 #ig = tuple(cols)
 #f sig in auto_index_by_sig:
 #uto_index_by_sig.pop(sig)
 #arsed_constraint = {"name": name, "column_names": cols}
 #nique_constraints.append(parsed_constraint)
        # NOTE: auto_index_by_sig might not be empty here,
        # the PRIMARY KEY may have an entry.
 #eturn unique_constraints

 #reflection.cache
 #ef get_check_constraints(self, connection, table_name, schema=None, **kw):
 #able_data = self._get_table_sql(
 #onnection, table_name, schema=schema, **kw
 #
 #f not table_data:
 #eturn []

 #HECK_PATTERN = r"(?:CONSTRAINT (\w+) +)?" r"CHECK *\( *(.+) *\),? *"
 #heck_constraints = []
        # NOTE: we aren't using re.S here because we actually are
        # taking advantage of each CHECK constraint being all on one
        # line in the table definition in order to delineate.  This
        # necessarily makes assumptions as to how the CREATE TABLE
        # was emitted.
 #or match in re.finditer(CHECK_PATTERN, table_data, re.I):
 #heck_constraints.append(
 #"sqltext": match.group(2), "name": match.group(1)}
 #

 #eturn check_constraints

 #reflection.cache
 #ef get_indexes(self, connection, table_name, schema=None, **kw):
 #ragma_indexes = self._get_table_pragma(
 #onnection, "index_list", table_name, schema=schema
 #
 #ndexes = []

 #nclude_auto_indexes = kw.pop("include_auto_indexes", False)
 #or row in pragma_indexes:
            # ignore implicit primary key index.
            # https://www.mail-archive.com/sqlite-users@sqlite.org/msg30517.html
 #f not include_auto_indexes and row[1].startswith(
 #sqlite_autoindex"
 #:
 #ontinue
 #ndexes.append(dict(name=row[1], column_names=[], unique=row[2]))

        # loop thru unique indexes to get the column names.
 #or idx in list(indexes):
 #ragma_index = self._get_table_pragma(
 #onnection, "index_info", idx["name"]
 #

 #or row in pragma_index:
 #f row[2] is None:
 #til.warn(
 #Skipped unsupported reflection of "
 #expression-based index %s" % idx["name"]
 #
 #ndexes.remove(idx)
 #reak
 #lse:
 #dx["column_names"].append(row[2])
 #eturn indexes

 #reflection.cache
 #ef _get_table_sql(self, connection, table_name, schema=None, **kw):
 #f schema:
 #chema_expr = "%s." % (
 #elf.identifier_preparer.quote_identifier(schema)
 #
 #lse:
 #chema_expr = ""
 #ry:
 # = (
 #SELECT sql FROM "
 # (SELECT * FROM %(schema)ssqlite_master UNION ALL "
 #  SELECT * FROM %(schema)ssqlite_temp_master) "
 #WHERE name = ? "
 #AND type = 'table'" % {"schema": schema_expr}
 #
 #s = connection.exec_driver_sql(s, (table_name,))
 #xcept exc.DBAPIError:
 # = (
 #SELECT sql FROM %(schema)ssqlite_master "
 #WHERE name = ? "
 #AND type = 'table'" % {"schema": schema_expr}
 #
 #s = connection.exec_driver_sql(s, (table_name,))
 #eturn rs.scalar()

 #ef _get_table_pragma(self, connection, pragma, table_name, schema=None):
 #uote = self.identifier_preparer.quote_identifier
 #f schema is not None:
 #tatements = ["PRAGMA %s." % quote(schema)]
 #lse:
            # because PRAGMA looks in all attached databases if no schema
            # given, need to specify "main" schema, however since we want
            # 'temp' tables in the same namespace as 'main', need to run
            # the PRAGMA twice
 #tatements = ["PRAGMA main.", "PRAGMA temp."]

 #table = quote(table_name)
 #or statement in statements:
 #tatement = "%s%s(%s)" % (statement, pragma, qtable)
 #ursor = connection.exec_driver_sql(statement)
 #f not cursor._soft_closed:
                # work around SQLite issue whereby cursor.description
                # is blank when PRAGMA returns no rows:
                # https://www.sqlite.org/cvstrac/tktview?tn=1884
 #esult = cursor.fetchall()
 #lse:
 #esult = []
 #f result:
 #eturn result
 #lse:
 #eturn []
