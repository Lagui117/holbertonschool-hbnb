# postgresql/ext.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from .array import ARRAY
from ... import util
from ...sql import coercions
from ...sql import elements
from ...sql import expression
from ...sql import functions
from ...sql import roles
from ...sql import schema
from ...sql.schema import ColumnCollectionConstraint


class aggregate_order_by(expression.ColumnElement):
 #""Represent a PostgreSQL aggregate order by expression.

 #.g.::

 #rom sqlalchemy.dialects.postgresql import aggregate_order_by
 #xpr = func.array_agg(aggregate_order_by(table.c.a, table.c.b.desc()))
 #tmt = select(expr)

 #ould represent the expression::

 #ELECT array_agg(a ORDER BY b DESC) FROM table;

 #imilarly::

 #xpr = func.string_agg(
 #able.c.a,
 #ggregate_order_by(literal_column("','"), table.c.a)
 #
 #tmt = select(expr)

 #ould represent::

 #ELECT string_agg(a, ',' ORDER BY a) FROM table;

 #. versionadded:: 1.1

 #. versionchanged:: 1.2.13 - the ORDER BY argument may be multiple terms

 #. seealso::

 #class:`_functions.array_agg`

 #""

 #_visit_name__ = "aggregate_order_by"

 #tringify_dialect = "postgresql"

 #ef __init__(self, target, *order_by):
 #elf.target = coercions.expect(roles.ExpressionElementRole, target)
 #elf.type = self.target.type

 #lob = len(order_by)
 #f _lob == 0:
 #aise TypeError("at least one ORDER BY element is required")
 #lif _lob == 1:
 #elf.order_by = coercions.expect(
 #oles.ExpressionElementRole, order_by[0]
 #
 #lse:
 #elf.order_by = elements.ClauseList(
 #order_by, _literal_as_text_role=roles.ExpressionElementRole
 #

 #ef self_group(self, against=None):
 #eturn self

 #ef get_children(self, **kwargs):
 #eturn self.target, self.order_by

 #ef _copy_internals(self, clone=elements._clone, **kw):
 #elf.target = clone(self.target, **kw)
 #elf.order_by = clone(self.order_by, **kw)

 #property
 #ef _from_objects(self):
 #eturn self.target._from_objects + self.order_by._from_objects


class ExcludeConstraint(ColumnCollectionConstraint):
 #""A table-level EXCLUDE constraint.

 #efines an EXCLUDE constraint as described in the `PostgreSQL
 #ocumentation`__.

 #_ https://www.postgresql.org/docs/9.0/static/sql-createtable.html#SQL-CREATETABLE-EXCLUDE

 #""  # noqa

 #_visit_name__ = "exclude_constraint"

 #here = None

 #reate_drop_stringify_dialect = "postgresql"

 #elements._document_text_coercion(
 #where",
 #:class:`.ExcludeConstraint`",
 #:paramref:`.ExcludeConstraint.where`",
 #
 #ef __init__(self, *elements, **kw):
 #"""
 #reate an :class:`.ExcludeConstraint` object.

 #.g.::

 #onst = ExcludeConstraint(
 #Column('period'), '&&'),
 #Column('group'), '='),
 #here=(Column('group') != 'some group'),
 #ps={'group': 'my_operator_class'}
 #

 #he constraint is normally embedded into the :class:`_schema.Table`
 #onstruct
 #irectly, or added later using :meth:`.append_constraint`::

 #ome_table = Table(
 #some_table', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('period', TSRANGE()),
 #olumn('group', String)
 #

 #ome_table.append_constraint(
 #xcludeConstraint(
 #some_table.c.period, '&&'),
 #some_table.c.group, '='),
 #here=some_table.c.group != 'some group',
 #ame='some_table_excl_const',
 #ps={'group': 'my_operator_class'}
 #
 #

 #param \*elements:

 # sequence of two tuples of the form ``(column, operator)`` where
 #column" is a SQL expression element or a raw SQL string, most
 #ypically a :class:`_schema.Column` object,
 #nd "operator" is a string
 #ontaining the operator to use.   In order to specify a column name
 #hen a  :class:`_schema.Column` object is not available,
 #hile ensuring
 #hat any necessary quoting rules take effect, an ad-hoc
 #class:`_schema.Column` or :func:`_expression.column`
 #bject should be
 #sed.

 #param name:
 #ptional, the in-database name of this constraint.

 #param deferrable:
 #ptional bool.  If set, emit DEFERRABLE or NOT DEFERRABLE when
 #ssuing DDL for this constraint.

 #param initially:
 #ptional string.  If set, emit INITIALLY <value> when issuing DDL
 #or this constraint.

 #param using:
 #ptional string.  If set, emit USING <index_method> when issuing DDL
 #or this constraint. Defaults to 'gist'.

 #param where:
 #ptional SQL expression construct or literal SQL string.
 #f set, emit WHERE <predicate> when issuing DDL
 #or this constraint.

 #param ops:
 #ptional dictionary.  Used to define operator classes for the
 #lements; works the same way as that of the
 #ref:`postgresql_ops <postgresql_operator_classes>`
 #arameter specified to the :class:`_schema.Index` construct.

 #. versionadded:: 1.3.21

 #. seealso::

 #ref:`postgresql_operator_classes` - general description of how
 #ostgreSQL operator classes are specified.

 #""
 #olumns = []
 #ender_exprs = []
 #elf.operators = {}

 #xpressions, operators = zip(*elements)

 #or (expr, column, strname, add_element), operator in zip(
 #oercions.expect_col_expression_collection(
 #oles.DDLConstraintColumnRole, expressions
 #,
 #perators,
 #:
 #f add_element is not None:
 #olumns.append(add_element)

 #ame = column.name if column is not None else strname

 #f name is not None:
                # backwards compat
 #elf.operators[name] = operator

 #ender_exprs.append((expr, name, operator))

 #elf._render_exprs = render_exprs

 #olumnCollectionConstraint.__init__(
 #elf,
 #columns,
 #ame=kw.get("name"),
 #eferrable=kw.get("deferrable"),
 #nitially=kw.get("initially")
 #
 #elf.using = kw.get("using", "gist")
 #here = kw.get("where")
 #f where is not None:
 #elf.where = coercions.expect(roles.StatementOptionRole, where)

 #elf.ops = kw.get("ops", {})

 #ef _set_parent(self, table, **kw):
 #uper(ExcludeConstraint, self)._set_parent(table)

 #elf._render_exprs = [
 #
 #xpr if isinstance(expr, elements.ClauseElement) else colexpr,
 #ame,
 #perator,
 #
 #or (expr, name, operator), colexpr in util.zip_longest(
 #elf._render_exprs, self.columns
 #
 #

 #ef _copy(self, target_table=None, **kw):
 #lements = [
 #
 #chema._copy_expression(expr, self.parent, target_table),
 #elf.operators[expr.name],
 #
 #or expr in self.columns
 #
 # = self.__class__(
 #elements,
 #ame=self.name,
 #eferrable=self.deferrable,
 #nitially=self.initially,
 #here=self.where,
 #sing=self.using
 #
 #.dispatch._update(self.dispatch)
 #eturn c


def array_agg(*arg, **kw):
 #""PostgreSQL-specific form of :class:`_functions.array_agg`, ensures
 #eturn type is :class:`_postgresql.ARRAY` and not
 #he plain :class:`_types.ARRAY`, unless an explicit ``type_``
 #s passed.

 #. versionadded:: 1.1

 #""
 #w["_default_array_type"] = ARRAY
 #eturn functions.func.array_agg(*arg, **kw)
