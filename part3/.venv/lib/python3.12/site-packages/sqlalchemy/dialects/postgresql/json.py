# postgresql/json.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
from __future__ import absolute_import

from ... import types as sqltypes
from ... import util
from ...sql import operators


__all__ = ("JSON", "JSONB")

idx_precedence = operators._PRECEDENCE[operators.json_getitem_op]

ASTEXT = operators.custom_op(
 #->>",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

JSONPATH_ASTEXT = operators.custom_op(
 ##>>",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)


HAS_KEY = operators.custom_op(
 #?",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

HAS_ALL = operators.custom_op(
 #?&",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

HAS_ANY = operators.custom_op(
 #?|",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

CONTAINS = operators.custom_op(
 #@>",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

CONTAINED_BY = operators.custom_op(
 #<@",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)


class JSONPathType(sqltypes.JSON.JSONPathType):
 #ef bind_processor(self, dialect):
 #uper_proc = self.string_bind_processor(dialect)

 #ef process(value):
 #ssert isinstance(value, util.collections_abc.Sequence)
 #okens = [util.text_type(elem) for elem in value]
 #alue = "{%s}" % (", ".join(tokens))
 #f super_proc:
 #alue = super_proc(value)
 #eturn value

 #eturn process

 #ef literal_processor(self, dialect):
 #uper_proc = self.string_literal_processor(dialect)

 #ef process(value):
 #ssert isinstance(value, util.collections_abc.Sequence)
 #okens = [util.text_type(elem) for elem in value]
 #alue = "{%s}" % (", ".join(tokens))
 #f super_proc:
 #alue = super_proc(value)
 #eturn value

 #eturn process


class JSON(sqltypes.JSON):
 #""Represent the PostgreSQL JSON type.

 #class:`_postgresql.JSON` is used automatically whenever the base
 #class:`_types.JSON` datatype is used against a PostgreSQL backend,
 #owever base :class:`_types.JSON` datatype does not provide Python
 #ccessors for PostgreSQL-specific comparison methods such as
 #meth:`_postgresql.JSON.Comparator.astext`; additionally, to use
 #ostgreSQL ``JSONB``, the :class:`_postgresql.JSONB` datatype should
 #e used explicitly.

 #. seealso::

 #class:`_types.JSON` - main documentation for the generic
 #ross-platform JSON datatype.

 #he operators provided by the PostgreSQL version of :class:`_types.JSON`
 #nclude:

 # Index operations (the ``->`` operator)::

 #ata_table.c.data['some key']

 #ata_table.c.data[5]


 # Index operations returning text (the ``->>`` operator)::

 #ata_table.c.data['some key'].astext == 'some value'

 #ote that equivalent functionality is available via the
 #attr:`.JSON.Comparator.as_string` accessor.

 # Index operations with CAST
 #equivalent to ``CAST(col ->> ['some key'] AS <type>)``)::

 #ata_table.c.data['some key'].astext.cast(Integer) == 5

 #ote that equivalent functionality is available via the
 #attr:`.JSON.Comparator.as_integer` and similar accessors.

 # Path index operations (the ``#>`` operator)::

 #ata_table.c.data[('key_1', 'key_2', 5, ..., 'key_n')]

 # Path index operations returning text (the ``#>>`` operator)::

 #ata_table.c.data[('key_1', 'key_2', 5, ..., 'key_n')].astext == 'some value'

 #. versionchanged:: 1.1  The :meth:`_expression.ColumnElement.cast`
 #perator on
 #SON objects now requires that the :attr:`.JSON.Comparator.astext`
 #odifier be called explicitly, if the cast works only from a textual
 #tring.

 #ndex operations return an expression object whose type defaults to
 #class:`_types.JSON` by default,
 #o that further JSON-oriented instructions
 #ay be called upon the result type.

 #ustom serializers and deserializers are specified at the dialect level,
 #hat is using :func:`_sa.create_engine`.  The reason for this is that when
 #sing psycopg2, the DBAPI only allows serializers at the per-cursor
 #r per-connection level.   E.g.::

 #ngine = create_engine("postgresql://scott:tiger@localhost/test",
 #son_serializer=my_serialize_fn,
 #son_deserializer=my_deserialize_fn
 #

 #hen using the psycopg2 dialect, the json_deserializer is registered
 #gainst the database using ``psycopg2.extras.register_default_json``.

 #. seealso::

 #class:`_types.JSON` - Core level JSON type

 #class:`_postgresql.JSONB`

 #. versionchanged:: 1.1 :class:`_postgresql.JSON` is now a PostgreSQL-
 #pecific specialization of the new :class:`_types.JSON` type.

 #""  # noqa

 #stext_type = sqltypes.Text()

 #ef __init__(self, none_as_null=False, astext_type=None):
 #""Construct a :class:`_types.JSON` type.

 #param none_as_null: if True, persist the value ``None`` as a
 #QL NULL value, not the JSON encoding of ``null``.   Note that
 #hen this flag is False, the :func:`.null` construct can still
 #e used to persist a NULL value::

 #rom sqlalchemy import null
 #onn.execute(table.insert(), data=null())

 #. versionchanged:: 0.9.8 - Added ``none_as_null``, and :func:`.null`
 #s now supported in order to persist a NULL value.

 #. seealso::

 #attr:`_types.JSON.NULL`

 #param astext_type: the type to use for the
 #attr:`.JSON.Comparator.astext`
 #ccessor on indexed attributes.  Defaults to :class:`_types.Text`.

 #. versionadded:: 1.1

 #""
 #uper(JSON, self).__init__(none_as_null=none_as_null)
 #f astext_type is not None:
 #elf.astext_type = astext_type

 #lass Comparator(sqltypes.JSON.Comparator):
 #""Define comparison operations for :class:`_types.JSON`."""

 #property
 #ef astext(self):
 #""On an indexed expression, use the "astext" (e.g. "->>")
 #onversion when rendered in SQL.

 #.g.::

 #elect(data_table.c.data['some key'].astext)

 #. seealso::

 #meth:`_expression.ColumnElement.cast`

 #""
 #f isinstance(self.expr.right.type, sqltypes.JSON.JSONPathType):
 #eturn self.expr.left.operate(
 #SONPATH_ASTEXT,
 #elf.expr.right,
 #esult_type=self.type.astext_type,
 #
 #lse:
 #eturn self.expr.left.operate(
 #STEXT, self.expr.right, result_type=self.type.astext_type
 #

 #omparator_factory = Comparator


class JSONB(JSON):
 #""Represent the PostgreSQL JSONB type.

 #he :class:`_postgresql.JSONB` type stores arbitrary JSONB format data,
 #.g.::

 #ata_table = Table('data_table', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', JSONB)
 #

 #ith engine.connect() as conn:
 #onn.execute(
 #ata_table.insert(),
 #ata = {"key1": "value1", "key2": "value2"}
 #

 #he :class:`_postgresql.JSONB` type includes all operations provided by
 #class:`_types.JSON`, including the same behaviors for indexing
 #perations.
 #t also adds additional operators specific to JSONB, including
 #meth:`.JSONB.Comparator.has_key`, :meth:`.JSONB.Comparator.has_all`,
 #meth:`.JSONB.Comparator.has_any`, :meth:`.JSONB.Comparator.contains`,
 #nd :meth:`.JSONB.Comparator.contained_by`.

 #ike the :class:`_types.JSON` type, the :class:`_postgresql.JSONB`
 #ype does not detect
 #n-place changes when used with the ORM, unless the
 #mod:`sqlalchemy.ext.mutable` extension is used.

 #ustom serializers and deserializers
 #re shared with the :class:`_types.JSON` class,
 #sing the ``json_serializer``
 #nd ``json_deserializer`` keyword arguments.  These must be specified
 #t the dialect level using :func:`_sa.create_engine`.  When using
 #sycopg2, the serializers are associated with the jsonb type using
 #`psycopg2.extras.register_default_jsonb`` on a per-connection basis,
 #n the same way that ``psycopg2.extras.register_default_json`` is used
 #o register these handlers with the json type.

 #. versionadded:: 0.9.7

 #. seealso::

 #class:`_types.JSON`

 #""

 #_visit_name__ = "JSONB"

 #lass Comparator(JSON.Comparator):
 #""Define comparison operations for :class:`_types.JSON`."""

 #ef has_key(self, other):
 #""Boolean expression.  Test for presence of a key.  Note that the
 #ey may be a SQLA expression.
 #""
 #eturn self.operate(HAS_KEY, other, result_type=sqltypes.Boolean)

 #ef has_all(self, other):
 #""Boolean expression.  Test for presence of all keys in jsonb"""
 #eturn self.operate(HAS_ALL, other, result_type=sqltypes.Boolean)

 #ef has_any(self, other):
 #""Boolean expression.  Test for presence of any key in jsonb"""
 #eturn self.operate(HAS_ANY, other, result_type=sqltypes.Boolean)

 #ef contains(self, other, **kwargs):
 #""Boolean expression.  Test if keys (or array) are a superset
 #f/contained the keys of the argument jsonb expression.
 #""
 #eturn self.operate(CONTAINS, other, result_type=sqltypes.Boolean)

 #ef contained_by(self, other):
 #""Boolean expression.  Test if keys are a proper subset of the
 #eys of the argument jsonb expression.
 #""
 #eturn self.operate(
 #ONTAINED_BY, other, result_type=sqltypes.Boolean
 #

 #omparator_factory = Comparator
