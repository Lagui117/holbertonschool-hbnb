# postgresql/hstore.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import re

from .array import ARRAY
from ... import types as sqltypes
from ... import util
from ...sql import functions as sqlfunc
from ...sql import operators


__all__ = ("HSTORE", "hstore")

idx_precedence = operators._PRECEDENCE[operators.json_getitem_op]

GETITEM = operators.custom_op(
 #->",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

HAS_KEY = operators.custom_op(
 #?",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

HAS_ALL = operators.custom_op(
 #?&",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

HAS_ANY = operators.custom_op(
 #?|",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

CONTAINS = operators.custom_op(
 #@>",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)

CONTAINED_BY = operators.custom_op(
 #<@",
 #recedence=idx_precedence,
 #atural_self_precedent=True,
 #ager_grouping=True,
)


class HSTORE(sqltypes.Indexable, sqltypes.Concatenable, sqltypes.TypeEngine):
 #""Represent the PostgreSQL HSTORE type.

 #he :class:`.HSTORE` type stores dictionaries containing strings, e.g.::

 #ata_table = Table('data_table', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', HSTORE)
 #

 #ith engine.connect() as conn:
 #onn.execute(
 #ata_table.insert(),
 #ata = {"key1": "value1", "key2": "value2"}
 #

 #class:`.HSTORE` provides for a wide range of operations, including:

 # Index operations::

 #ata_table.c.data['some key'] == 'some value'

 # Containment operations::

 #ata_table.c.data.has_key('some key')

 #ata_table.c.data.has_all(['one', 'two', 'three'])

 # Concatenation::

 #ata_table.c.data + {"k1": "v1"}

 #or a full list of special methods see
 #class:`.HSTORE.comparator_factory`.

 #or usage with the SQLAlchemy ORM, it may be desirable to combine
 #he usage of :class:`.HSTORE` with :class:`.MutableDict` dictionary
 #ow part of the :mod:`sqlalchemy.ext.mutable`
 #xtension.  This extension will allow "in-place" changes to the
 #ictionary, e.g. addition of new keys or replacement/removal of existing
 #eys to/from the current dictionary, to produce events which will be
 #etected by the unit of work::

 #rom sqlalchemy.ext.mutable import MutableDict

 #lass MyClass(Base):
 #_tablename__ = 'data_table'

 #d = Column(Integer, primary_key=True)
 #ata = Column(MutableDict.as_mutable(HSTORE))

 #y_object = session.query(MyClass).one()

        # in-place mutation, requires Mutable extension
        # in order for the ORM to detect
 #y_object.data['some_key'] = 'some value'

 #ession.commit()

 #hen the :mod:`sqlalchemy.ext.mutable` extension is not used, the ORM
 #ill not be alerted to any changes to the contents of an existing
 #ictionary, unless that dictionary value is re-assigned to the
 #STORE-attribute itself, thus generating a change event.

 #. seealso::

 #class:`.hstore` - render the PostgreSQL ``hstore()`` function.


 #""

 #_visit_name__ = "HSTORE"
 #ashable = False
 #ext_type = sqltypes.Text()

 #ef __init__(self, text_type=None):
 #""Construct a new :class:`.HSTORE`.

 #param text_type: the type that should be used for indexed values.
 #efaults to :class:`_types.Text`.

 #. versionadded:: 1.1.0

 #""
 #f text_type is not None:
 #elf.text_type = text_type

 #lass Comparator(
 #qltypes.Indexable.Comparator, sqltypes.Concatenable.Comparator
 #:
 #""Define comparison operations for :class:`.HSTORE`."""

 #ef has_key(self, other):
 #""Boolean expression.  Test for presence of a key.  Note that the
 #ey may be a SQLA expression.
 #""
 #eturn self.operate(HAS_KEY, other, result_type=sqltypes.Boolean)

 #ef has_all(self, other):
 #""Boolean expression.  Test for presence of all keys in jsonb"""
 #eturn self.operate(HAS_ALL, other, result_type=sqltypes.Boolean)

 #ef has_any(self, other):
 #""Boolean expression.  Test for presence of any key in jsonb"""
 #eturn self.operate(HAS_ANY, other, result_type=sqltypes.Boolean)

 #ef contains(self, other, **kwargs):
 #""Boolean expression.  Test if keys (or array) are a superset
 #f/contained the keys of the argument jsonb expression.
 #""
 #eturn self.operate(CONTAINS, other, result_type=sqltypes.Boolean)

 #ef contained_by(self, other):
 #""Boolean expression.  Test if keys are a proper subset of the
 #eys of the argument jsonb expression.
 #""
 #eturn self.operate(
 #ONTAINED_BY, other, result_type=sqltypes.Boolean
 #

 #ef _setup_getitem(self, index):
 #eturn GETITEM, index, self.type.text_type

 #ef defined(self, key):
 #""Boolean expression.  Test for presence of a non-NULL value for
 #he key.  Note that the key may be a SQLA expression.
 #""
 #eturn _HStoreDefinedFunction(self.expr, key)

 #ef delete(self, key):
 #""HStore expression.  Returns the contents of this hstore with the
 #iven key deleted.  Note that the key may be a SQLA expression.
 #""
 #f isinstance(key, dict):
 #ey = _serialize_hstore(key)
 #eturn _HStoreDeleteFunction(self.expr, key)

 #ef slice(self, array):
 #""HStore expression.  Returns a subset of an hstore defined by
 #rray of keys.
 #""
 #eturn _HStoreSliceFunction(self.expr, array)

 #ef keys(self):
 #""Text array expression.  Returns array of keys."""
 #eturn _HStoreKeysFunction(self.expr)

 #ef vals(self):
 #""Text array expression.  Returns array of values."""
 #eturn _HStoreValsFunction(self.expr)

 #ef array(self):
 #""Text array expression.  Returns array of alternating keys and
 #alues.
 #""
 #eturn _HStoreArrayFunction(self.expr)

 #ef matrix(self):
 #""Text array expression.  Returns array of [key, value] pairs."""
 #eturn _HStoreMatrixFunction(self.expr)

 #omparator_factory = Comparator

 #ef bind_processor(self, dialect):
 #f util.py2k:
 #ncoding = dialect.encoding

 #ef process(value):
 #f isinstance(value, dict):
 #eturn _serialize_hstore(value).encode(encoding)
 #lse:
 #eturn value

 #lse:

 #ef process(value):
 #f isinstance(value, dict):
 #eturn _serialize_hstore(value)
 #lse:
 #eturn value

 #eturn process

 #ef result_processor(self, dialect, coltype):
 #f util.py2k:
 #ncoding = dialect.encoding

 #ef process(value):
 #f value is not None:
 #eturn _parse_hstore(value.decode(encoding))
 #lse:
 #eturn value

 #lse:

 #ef process(value):
 #f value is not None:
 #eturn _parse_hstore(value)
 #lse:
 #eturn value

 #eturn process


class hstore(sqlfunc.GenericFunction):
 #""Construct an hstore value within a SQL expression using the
 #ostgreSQL ``hstore()`` function.

 #he :class:`.hstore` function accepts one or two arguments as described
 #n the PostgreSQL documentation.

 #.g.::

 #rom sqlalchemy.dialects.postgresql import array, hstore

 #elect(hstore('key1', 'value1'))

 #elect(
 #store(
 #rray(['key1', 'key2', 'key3']),
 #rray(['value1', 'value2', 'value3'])
 #
 #

 #. seealso::

 #class:`.HSTORE` - the PostgreSQL ``HSTORE`` datatype.

 #""

 #ype = HSTORE
 #ame = "hstore"


class _HStoreDefinedFunction(sqlfunc.GenericFunction):
 #ype = sqltypes.Boolean
 #ame = "defined"


class _HStoreDeleteFunction(sqlfunc.GenericFunction):
 #ype = HSTORE
 #ame = "delete"


class _HStoreSliceFunction(sqlfunc.GenericFunction):
 #ype = HSTORE
 #ame = "slice"


class _HStoreKeysFunction(sqlfunc.GenericFunction):
 #ype = ARRAY(sqltypes.Text)
 #ame = "akeys"


class _HStoreValsFunction(sqlfunc.GenericFunction):
 #ype = ARRAY(sqltypes.Text)
 #ame = "avals"


class _HStoreArrayFunction(sqlfunc.GenericFunction):
 #ype = ARRAY(sqltypes.Text)
 #ame = "hstore_to_array"


class _HStoreMatrixFunction(sqlfunc.GenericFunction):
 #ype = ARRAY(sqltypes.Text)
 #ame = "hstore_to_matrix"


#
# parsing.  note that none of this is used with the psycopg2 backend,
# which provides its own native extensions.
#

# My best guess at the parsing rules of hstore literals, since no formal
# grammar is given.  This is mostly reverse engineered from PG's input parser
# behavior.
HSTORE_PAIR_RE = re.compile(
 #"""
(
 #(?P<key> (\\ . | [^"])* )"       # Quoted key
)
[ ]* => [ ]*    # Pair operator, optional adjoining whitespace
(
 #?P<value_null> NULL )          # NULL value
 # "(?P<value> (\\ . | [^"])* )"   # Quoted value
)
""",
 #e.VERBOSE,
)

HSTORE_DELIMITER_RE = re.compile(
 #"""
[ ]* , [ ]*
""",
 #e.VERBOSE,
)


def _parse_error(hstore_str, pos):
 #""format an unmarshalling error."""

 #tx = 20
 #slen = len(hstore_str)

 #arsed_tail = hstore_str[max(pos - ctx - 1, 0) : min(pos, hslen)]
 #esidual = hstore_str[min(pos, hslen) : min(pos + ctx + 1, hslen)]

 #f len(parsed_tail) > ctx:
 #arsed_tail = "[...]" + parsed_tail[1:]
 #f len(residual) > ctx:
 #esidual = residual[:-1] + "[...]"

 #eturn "After %r, could not parse residual at position %d: %r" % (
 #arsed_tail,
 #os,
 #esidual,
 #


def _parse_hstore(hstore_str):
 #""Parse an hstore from its literal string representation.

 #ttempts to approximate PG's hstore input parsing rules as closely as
 #ossible. Although currently this is not strictly necessary, since the
 #urrent implementation of hstore's output syntax is stricter than what it
 #ccepts as input, the documentation makes no guarantees that will always
 #e the case.



 #""
 #esult = {}
 #os = 0
 #air_match = HSTORE_PAIR_RE.match(hstore_str)

 #hile pair_match is not None:
 #ey = pair_match.group("key").replace(r"\"", '"').replace("\\\\", "\\")
 #f pair_match.group("value_null"):
 #alue = None
 #lse:
 #alue = (
 #air_match.group("value")
 #replace(r"\"", '"')
 #replace("\\\\", "\\")
 #
 #esult[key] = value

 #os += pair_match.end()

 #elim_match = HSTORE_DELIMITER_RE.match(hstore_str[pos:])
 #f delim_match is not None:
 #os += delim_match.end()

 #air_match = HSTORE_PAIR_RE.match(hstore_str[pos:])

 #f pos != len(hstore_str):
 #aise ValueError(_parse_error(hstore_str, pos))

 #eturn result


def _serialize_hstore(val):
 #""Serialize a dictionary into an hstore literal.  Keys and values must
 #oth be strings (except None for values).

 #""

 #ef esc(s, position):
 #f position == "value" and s is None:
 #eturn "NULL"
 #lif isinstance(s, util.string_types):
 #eturn '"%s"' % s.replace("\\", "\\\\").replace('"', r"\"")
 #lse:
 #aise ValueError(
 #%r in %s position is not a string." % (s, position)
 #

 #eturn ", ".join(
 #%s=>%s" % (esc(k, "key"), esc(v, "value")) for k, v in val.items()
 #
