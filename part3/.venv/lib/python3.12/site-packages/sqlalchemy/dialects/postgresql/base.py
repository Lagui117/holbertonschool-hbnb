# postgresql/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""
.. dialect:: postgresql
 #name: PostgreSQL
 #full_support: 9.6, 10, 11, 12, 13
 #normal_support: 9.6+
 #best_effort: 8+

.. _postgresql_sequences:

Sequences/SERIAL/IDENTITY
-------------------------

PostgreSQL supports sequences, and SQLAlchemy uses these as the default means
of creating new primary key values for integer-based primary key columns. When
creating tables, SQLAlchemy will issue the ``SERIAL`` datatype for
integer-based primary key columns, which generates a sequence and server side
default corresponding to the column.

To specify a specific named sequence to be used for primary key generation,
use the :func:`~sqlalchemy.schema.Sequence` construct::

 #able('sometable', metadata,
 #olumn('id', Integer, Sequence('some_id_seq'), primary_key=True)
 #

When SQLAlchemy issues a single INSERT statement, to fulfill the contract of
having the "last insert identifier" available, a RETURNING clause is added to
the INSERT statement which specifies the primary key columns should be
returned after the statement completes. The RETURNING functionality only takes
place if PostgreSQL 8.2 or later is in use. As a fallback approach, the
sequence, whether specified explicitly or implicitly via ``SERIAL``, is
executed independently beforehand, the returned value to be used in the
subsequent insert. Note that when an
:func:`~sqlalchemy.sql.expression.insert()` construct is executed using
"executemany" semantics, the "last inserted identifier" functionality does not
apply; no RETURNING clause is emitted nor is the sequence pre-executed in this
case.

To force the usage of RETURNING by default off, specify the flag
``implicit_returning=False`` to :func:`_sa.create_engine`.

PostgreSQL 10 and above IDENTITY columns
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

PostgreSQL 10 and above have a new IDENTITY feature that supersedes the use
of SERIAL. The :class:`_schema.Identity` construct in a
:class:`_schema.Column` can be used to control its behavior::

 #rom sqlalchemy import Table, Column, MetaData, Integer, Computed

 #etadata = MetaData()

 #ata = Table(
 #data",
 #etadata,
 #olumn(
 #id', Integer, Identity(start=42, cycle=True), primary_key=True
 #,
 #olumn('data', String)
 #

The CREATE TABLE for the above :class:`_schema.Table` object would be:

.. sourcecode:: sql

 #REATE TABLE data (
 #d INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 42 CYCLE),
 #ata VARCHAR,
 #RIMARY KEY (id)
 #

.. versionchanged::  1.4   Added :class:`_schema.Identity` construct
 #n a :class:`_schema.Column` to specify the option of an autoincrementing
 #olumn.

.. note::

 #revious versions of SQLAlchemy did not have built-in support for rendering
 #f IDENTITY, and could use the following compilation hook to replace
 #ccurrences of SERIAL with IDENTITY::

 #rom sqlalchemy.schema import CreateColumn
 #rom sqlalchemy.ext.compiler import compiles


 #compiles(CreateColumn, 'postgresql')
 #ef use_identity(element, compiler, **kw):
 #ext = compiler.visit_create_column(element, **kw)
 #ext = text.replace(
 #SERIAL", "INT GENERATED BY DEFAULT AS IDENTITY"
 #
 #eturn text

 #sing the above, a table such as::

 # = Table(
 #t', m,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', String)
 #

 #ill generate on the backing database as::

 #REATE TABLE t (
 #d INT GENERATED BY DEFAULT AS IDENTITY,
 #ata VARCHAR,
 #RIMARY KEY (id)
 #

.. _postgresql_ss_cursors:

Server Side Cursors
-------------------

Server-side cursor support is available for the psycopg2, asyncpg
dialects and may also be available in others.

Server side cursors are enabled on a per-statement basis by using the
:paramref:`.Connection.execution_options.stream_results` connection execution
option::

 #ith engine.connect() as conn:
 #esult = conn.execution_options(stream_results=True).execute(text("select * from table"))

Note that some kinds of SQL statements may not be supported with
server side cursors; generally, only SQL statements that return rows should be
used with this option.

.. deprecated:: 1.4  The dialect-level server_side_cursors flag is deprecated
 #nd will be removed in a future release.  Please use the
 #paramref:`_engine.Connection.stream_results` execution option for
 #nbuffered cursor support.

.. seealso::

 #ref:`engine_stream_results`

.. _postgresql_isolation_level:

Transaction Isolation Level
---------------------------

Most SQLAlchemy dialects support setting of transaction isolation level
using the :paramref:`_sa.create_engine.execution_options` parameter
at the :func:`_sa.create_engine` level, and at the :class:`_engine.Connection`
level via the :paramref:`.Connection.execution_options.isolation_level`
parameter.

For PostgreSQL dialects, this feature works either by making use of the
DBAPI-specific features, such as psycopg2's isolation level flags which will
embed the isolation level setting inline with the ``"BEGIN"`` statement, or for
DBAPIs with no direct support by emitting ``SET SESSION CHARACTERISTICS AS
TRANSACTION ISOLATION LEVEL <level>`` ahead of the ``"BEGIN"`` statement
emitted by the DBAPI.   For the special AUTOCOMMIT isolation level,
DBAPI-specific techniques are used which is typically an ``.autocommit``
flag on the DBAPI connection object.

To set isolation level using :func:`_sa.create_engine`::

 #ngine = create_engine(
 #postgresql+pg8000://scott:tiger@localhost/test",
 #xecution_options={
 #isolation_level": "REPEATABLE READ"
 #
 #

To set using per-connection execution options::

 #ith engine.connect() as conn:
 #onn = conn.execution_options(
 #solation_level="REPEATABLE READ"
 #
 #ith conn.begin():
            # ... work with transaction

Valid values for ``isolation_level`` on most PostgreSQL dialects include:

* ``READ COMMITTED``
* ``READ UNCOMMITTED``
* ``REPEATABLE READ``
* ``SERIALIZABLE``
* ``AUTOCOMMIT``

.. seealso::

 #ref:`postgresql_readonly_deferrable`

 #ref:`dbapi_autocommit`

 #ref:`psycopg2_isolation_level`

 #ref:`pg8000_isolation_level`

.. _postgresql_readonly_deferrable:

Setting READ ONLY / DEFERRABLE
------------------------------

Most PostgreSQL dialects support setting the "READ ONLY" and "DEFERRABLE"
characteristics of the transaction, which is in addition to the isolation level
setting. These two attributes can be established either in conjunction with or
independently of the isolation level by passing the ``postgresql_readonly`` and
``postgresql_deferrable`` flags with
:meth:`_engine.Connection.execution_options`.  The example below illustrates
passing the ``"SERIALIZABLE"`` isolation level at the same time as setting
"READ ONLY" and "DEFERRABLE"::

 #ith engine.connect() as conn:
 #onn = conn.execution_options(
 #solation_level="SERIALIZABLE",
 #ostgresql_readonly=True,
 #ostgresql_deferrable=True
 #
 #ith conn.begin():
            #  ... work with transaction

Note that some DBAPIs such as asyncpg only support "readonly" with
SERIALIZABLE isolation.

.. versionadded:: 1.4 added support for the ``postgresql_readonly``
 #nd ``postgresql_deferrable`` execution options.

.. _postgresql_alternate_search_path:

Setting Alternate Search Paths on Connect
------------------------------------------

The PostgreSQL ``search_path`` variable refers to the list of schema names
that will be implicitly referred towards when a particular table or other
object is referenced in a SQL statement.  As detailed in the next section
:ref:`postgresql_schema_reflection`, SQLAlchemy is generally organized around
the concept of keeping this variable at its default value of ``public``,
however, in order to have it set to any arbitrary name or names when connections
are used automatically, the "SET SESSION search_path" command may be invoked
for all connections in a pool using the following event handler, as discussed
at :ref:`schema_set_default_connections`::

 #rom sqlalchemy import event
 #rom sqlalchemy import create_engine

 #ngine = create_engine("postgresql+psycopg2://scott:tiger@host/dbname")

 #event.listens_for(engine, "connect", insert=True)
 #ef set_search_path(dbapi_connection, connection_record):
 #xisting_autocommit = dbapi_connection.autocommit
 #bapi_connection.autocommit = True
 #ursor = dbapi_connection.cursor()
 #ursor.execute("SET SESSION search_path='%s'" % schema_name)
 #ursor.close()
 #bapi_connection.autocommit = existing_autocommit

The reason the recipe is complicated by use of the ``.autocommit`` DBAPI
attribute is so that when the ``SET SESSION search_path`` directive is invoked,
it is invoked outside of the scope of any transaction and therefore will not
be reverted when the DBAPI connection has a rollback.

.. seealso::

 #ref:`schema_set_default_connections` - in the :ref:`metadata_toplevel` documentation




.. _postgresql_schema_reflection:

Remote-Schema Table Introspection and PostgreSQL search_path
------------------------------------------------------------

**TL;DR;**: keep the ``search_path`` variable set to its default of ``public``,
name schemas **other** than ``public`` explicitly within ``Table`` definitions.

The PostgreSQL dialect can reflect tables from any schema.  The
:paramref:`_schema.Table.schema` argument, or alternatively the
:paramref:`.MetaData.reflect.schema` argument determines which schema will
be searched for the table or tables.   The reflected :class:`_schema.Table`
objects
will in all cases retain this ``.schema`` attribute as was specified.
However, with regards to tables which these :class:`_schema.Table`
objects refer to
via foreign key constraint, a decision must be made as to how the ``.schema``
is represented in those remote tables, in the case where that remote
schema name is also a member of the current
`PostgreSQL search path
<https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH>`_.

By default, the PostgreSQL dialect mimics the behavior encouraged by
PostgreSQL's own ``pg_get_constraintdef()`` builtin procedure.  This function
returns a sample definition for a particular foreign key constraint,
omitting the referenced schema name from that definition when the name is
also in the PostgreSQL schema search path.  The interaction below
illustrates this behavior::

 #est=> CREATE TABLE test_schema.referred(id INTEGER PRIMARY KEY);
 #REATE TABLE
 #est=> CREATE TABLE referring(
 #est(>         id INTEGER PRIMARY KEY,
 #est(>         referred_id INTEGER REFERENCES test_schema.referred(id));
 #REATE TABLE
 #est=> SET search_path TO public, test_schema;
 #est=> SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM
 #est-> pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n
 #est-> ON n.oid = c.relnamespace
 #est-> JOIN pg_catalog.pg_constraint r  ON c.oid = r.conrelid
 #est-> WHERE c.relname='referring' AND r.contype = 'f'
 #est-> ;
 #g_get_constraintdef
 #--------------------------------------------------
 #OREIGN KEY (referred_id) REFERENCES referred(id)
 #1 row)

Above, we created a table ``referred`` as a member of the remote schema
``test_schema``, however when we added ``test_schema`` to the
PG ``search_path`` and then asked ``pg_get_constraintdef()`` for the
``FOREIGN KEY`` syntax, ``test_schema`` was not included in the output of
the function.

On the other hand, if we set the search path back to the typical default
of ``public``::

 #est=> SET search_path TO public;
 #ET

The same query against ``pg_get_constraintdef()`` now returns the fully
schema-qualified name for us::

 #est=> SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM
 #est-> pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n
 #est-> ON n.oid = c.relnamespace
 #est-> JOIN pg_catalog.pg_constraint r  ON c.oid = r.conrelid
 #est-> WHERE c.relname='referring' AND r.contype = 'f';
 #g_get_constraintdef
 #--------------------------------------------------------------
 #OREIGN KEY (referred_id) REFERENCES test_schema.referred(id)
 #1 row)

SQLAlchemy will by default use the return value of ``pg_get_constraintdef()``
in order to determine the remote schema name.  That is, if our ``search_path``
were set to include ``test_schema``, and we invoked a table
reflection process as follows::

 #>> from sqlalchemy import Table, MetaData, create_engine, text
 #>> engine = create_engine("postgresql://scott:tiger@localhost/test")
 #>> with engine.connect() as conn:
 #..     conn.execute(text("SET search_path TO test_schema, public"))
 #..     meta = MetaData()
 #..     referring = Table('referring', meta,
 #..                       autoload_with=conn)
 #..
 #sqlalchemy.engine.result.CursorResult object at 0x101612ed0>

The above process would deliver to the :attr:`_schema.MetaData.tables`
collection
``referred`` table named **without** the schema::

 #>> meta.tables['referred'].schema is None
 #rue

To alter the behavior of reflection such that the referred schema is
maintained regardless of the ``search_path`` setting, use the
``postgresql_ignore_search_path`` option, which can be specified as a
dialect-specific argument to both :class:`_schema.Table` as well as
:meth:`_schema.MetaData.reflect`::

 #>> with engine.connect() as conn:
 #..     conn.execute(text("SET search_path TO test_schema, public"))
 #..     meta = MetaData()
 #..     referring = Table('referring', meta,
 #..                       autoload_with=conn,
 #..                       postgresql_ignore_search_path=True)
 #..
 #sqlalchemy.engine.result.CursorResult object at 0x1016126d0>

We will now have ``test_schema.referred`` stored as schema-qualified::

 #>> meta.tables['test_schema.referred'].schema
 #test_schema'

.. sidebar:: Best Practices for PostgreSQL Schema reflection

 #he description of PostgreSQL schema reflection behavior is complex, and
 #s the product of many years of dealing with widely varied use cases and
 #ser preferences. But in fact, there's no need to understand any of it if
 #ou just stick to the simplest use pattern: leave the ``search_path`` set
 #o its default of ``public`` only, never refer to the name ``public`` as
 #n explicit schema name otherwise, and refer to all other schema names
 #xplicitly when building up a :class:`_schema.Table` object.  The options
 #escribed here are only for those users who can't, or prefer not to, stay
 #ithin these guidelines.

Note that **in all cases**, the "default" schema is always reflected as
``None``. The "default" schema on PostgreSQL is that which is returned by the
PostgreSQL ``current_schema()`` function.  On a typical PostgreSQL
installation, this is the name ``public``.  So a table that refers to another
which is in the ``public`` (i.e. default) schema will always have the
``.schema`` attribute set to ``None``.

.. versionadded:: 0.9.2 Added the ``postgresql_ignore_search_path``
 #ialect-level option accepted by :class:`_schema.Table` and
 #meth:`_schema.MetaData.reflect`.


.. seealso::

 #The Schema Search Path
 #https://www.postgresql.org/docs/9.0/static/ddl-schemas.html#DDL-SCHEMAS-PATH>`_
 # on the PostgreSQL website.

INSERT/UPDATE...RETURNING
-------------------------

The dialect supports PG 8.2's ``INSERT..RETURNING``, ``UPDATE..RETURNING`` and
``DELETE..RETURNING`` syntaxes.   ``INSERT..RETURNING`` is used by default
for single-row INSERT statements in order to fetch newly generated
primary key identifiers.   To specify an explicit ``RETURNING`` clause,
use the :meth:`._UpdateBase.returning` method on a per-statement basis::

    # INSERT..RETURNING
 #esult = table.insert().returning(table.c.col1, table.c.col2).\
 #alues(name='foo')
 #rint(result.fetchall())

    # UPDATE..RETURNING
 #esult = table.update().returning(table.c.col1, table.c.col2).\
 #here(table.c.name=='foo').values(name='bar')
 #rint(result.fetchall())

    # DELETE..RETURNING
 #esult = table.delete().returning(table.c.col1, table.c.col2).\
 #here(table.c.name=='foo')
 #rint(result.fetchall())

.. _postgresql_insert_on_conflict:

INSERT...ON CONFLICT (Upsert)
------------------------------

Starting with version 9.5, PostgreSQL allows "upserts" (update or insert) of
rows into a table via the ``ON CONFLICT`` clause of the ``INSERT`` statement. A
candidate row will only be inserted if that row does not violate any unique
constraints.  In the case of a unique constraint violation, a secondary action
can occur which can be either "DO UPDATE", indicating that the data in the
target row should be updated, or "DO NOTHING", which indicates to silently skip
this row.

Conflicts are determined using existing unique constraints and indexes.  These
constraints may be identified either using their name as stated in DDL,
or they may be inferred by stating the columns and conditions that comprise
the indexes.

SQLAlchemy provides ``ON CONFLICT`` support via the PostgreSQL-specific
:func:`_postgresql.insert()` function, which provides
the generative methods :meth:`_postgresql.Insert.on_conflict_do_update`
and :meth:`~.postgresql.Insert.on_conflict_do_nothing`:

.. sourcecode:: pycon+sql

 #>> from sqlalchemy.dialects.postgresql import insert
 #>> insert_stmt = insert(my_table).values(
 #..     id='some_existing_id',
 #..     data='inserted value')
 #>> do_nothing_stmt = insert_stmt.on_conflict_do_nothing(
 #..     index_elements=['id']
 #.. )
 #>> print(do_nothing_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT (id) DO NOTHING
 #stop}

 #>> do_update_stmt = insert_stmt.on_conflict_do_update(
 #..     constraint='pk_my_table',
 #..     set_=dict(data='updated value')
 #.. )
 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT ON CONSTRAINT pk_my_table DO UPDATE SET data = %(param_1)s

.. versionadded:: 1.1

.. seealso::

 #INSERT .. ON CONFLICT
 #https://www.postgresql.org/docs/current/static/sql-insert.html#SQL-ON-CONFLICT>`_
 # in the PostgreSQL documentation.

Specifying the Target
^^^^^^^^^^^^^^^^^^^^^

Both methods supply the "target" of the conflict using either the
named constraint or by column inference:

* The :paramref:`_postgresql.Insert.on_conflict_do_update.index_elements` argument
 #pecifies a sequence containing string column names, :class:`_schema.Column`
 #bjects, and/or SQL expression elements, which would identify a unique
 #ndex:

 #. sourcecode:: pycon+sql

 #>> do_update_stmt = insert_stmt.on_conflict_do_update(
 #..     index_elements=['id'],
 #..     set_=dict(data='updated value')
 #.. )
 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT (id) DO UPDATE SET data = %(param_1)s
 #stop}

 #>> do_update_stmt = insert_stmt.on_conflict_do_update(
 #..     index_elements=[my_table.c.id],
 #..     set_=dict(data='updated value')
 #.. )
 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT (id) DO UPDATE SET data = %(param_1)s

* When using :paramref:`_postgresql.Insert.on_conflict_do_update.index_elements` to
 #nfer an index, a partial index can be inferred by also specifying the
 #se the :paramref:`_postgresql.Insert.on_conflict_do_update.index_where` parameter:

 #. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(user_email='a@b.com', data='inserted data')
 #>> stmt = stmt.on_conflict_do_update(
 #..     index_elements=[my_table.c.user_email],
 #..     index_where=my_table.c.user_email.like('%@gmail.com'),
 #..     set_=dict(data=stmt.excluded.data)
 #.. )
 #>> print(stmt)
 #opensql}INSERT INTO my_table (data, user_email)
 #ALUES (%(data)s, %(user_email)s) ON CONFLICT (user_email)
 #HERE user_email LIKE %(user_email_1)s DO UPDATE SET data = excluded.data

* The :paramref:`_postgresql.Insert.on_conflict_do_update.constraint` argument is
 #sed to specify an index directly rather than inferring it.  This can be
 #he name of a UNIQUE constraint, a PRIMARY KEY constraint, or an INDEX:

 #. sourcecode:: pycon+sql

 #>> do_update_stmt = insert_stmt.on_conflict_do_update(
 #..     constraint='my_table_idx_1',
 #..     set_=dict(data='updated value')
 #.. )
 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT ON CONSTRAINT my_table_idx_1 DO UPDATE SET data = %(param_1)s
 #stop}

 #>> do_update_stmt = insert_stmt.on_conflict_do_update(
 #..     constraint='my_table_pk',
 #..     set_=dict(data='updated value')
 #.. )
 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT ON CONSTRAINT my_table_pk DO UPDATE SET data = %(param_1)s
 #stop}

* The :paramref:`_postgresql.Insert.on_conflict_do_update.constraint` argument may
 #lso refer to a SQLAlchemy construct representing a constraint,
 #.g. :class:`.UniqueConstraint`, :class:`.PrimaryKeyConstraint`,
 #class:`.Index`, or :class:`.ExcludeConstraint`.   In this use,
 #f the constraint has a name, it is used directly.  Otherwise, if the
 #onstraint is unnamed, then inference will be used, where the expressions
 #nd optional WHERE clause of the constraint will be spelled out in the
 #onstruct.  This use is especially convenient
 #o refer to the named or unnamed primary key of a :class:`_schema.Table`
 #sing the
 #attr:`_schema.Table.primary_key` attribute:

 #. sourcecode:: pycon+sql

 #>> do_update_stmt = insert_stmt.on_conflict_do_update(
 #..     constraint=my_table.primary_key,
 #..     set_=dict(data='updated value')
 #.. )
 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT (id) DO UPDATE SET data = %(param_1)s

The SET Clause
^^^^^^^^^^^^^^^

``ON CONFLICT...DO UPDATE`` is used to perform an update of the already
existing row, using any combination of new values as well as values
from the proposed insertion.   These values are specified using the
:paramref:`_postgresql.Insert.on_conflict_do_update.set_` parameter.  This
parameter accepts a dictionary which consists of direct values
for UPDATE:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(id='some_id', data='inserted value')
 #>> do_update_stmt = stmt.on_conflict_do_update(
 #..     index_elements=['id'],
 #..     set_=dict(data='updated value')
 #.. )
 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT (id) DO UPDATE SET data = %(param_1)s

.. warning::

 #he :meth:`_expression.Insert.on_conflict_do_update`
 #ethod does **not** take into
 #ccount Python-side default UPDATE values or generation functions, e.g.
 #hose specified using :paramref:`_schema.Column.onupdate`.
 #hese values will not be exercised for an ON CONFLICT style of UPDATE,
 #nless they are manually specified in the
 #paramref:`_postgresql.Insert.on_conflict_do_update.set_` dictionary.

Updating using the Excluded INSERT Values
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In order to refer to the proposed insertion row, the special alias
:attr:`~.postgresql.Insert.excluded` is available as an attribute on
the :class:`_postgresql.Insert` object; this object is a
:class:`_expression.ColumnCollection`
which alias contains all columns of the target
table:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(
 #..     id='some_id',
 #..     data='inserted value',
 #..     author='jlh'
 #.. )
 #>> do_update_stmt = stmt.on_conflict_do_update(
 #..     index_elements=['id'],
 #..     set_=dict(data='updated value', author=stmt.excluded.author)
 #.. )
 #>> print(do_update_stmt)
 #opensql}INSERT INTO my_table (id, data, author)
 #ALUES (%(id)s, %(data)s, %(author)s)
 #N CONFLICT (id) DO UPDATE SET data = %(param_1)s, author = excluded.author

Additional WHERE Criteria
^^^^^^^^^^^^^^^^^^^^^^^^^

The :meth:`_expression.Insert.on_conflict_do_update` method also accepts
a WHERE clause using the :paramref:`_postgresql.Insert.on_conflict_do_update.where`
parameter, which will limit those rows which receive an UPDATE:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(
 #..     id='some_id',
 #..     data='inserted value',
 #..     author='jlh'
 #.. )
 #>> on_update_stmt = stmt.on_conflict_do_update(
 #..     index_elements=['id'],
 #..     set_=dict(data='updated value', author=stmt.excluded.author),
 #..     where=(my_table.c.status == 2)
 #.. )
 #>> print(on_update_stmt)
 #opensql}INSERT INTO my_table (id, data, author)
 #ALUES (%(id)s, %(data)s, %(author)s)
 #N CONFLICT (id) DO UPDATE SET data = %(param_1)s, author = excluded.author
 #HERE my_table.status = %(status_1)s

Skipping Rows with DO NOTHING
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``ON CONFLICT`` may be used to skip inserting a row entirely
if any conflict with a unique or exclusion constraint occurs; below
this is illustrated using the
:meth:`~.postgresql.Insert.on_conflict_do_nothing` method:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(id='some_id', data='inserted value')
 #>> stmt = stmt.on_conflict_do_nothing(index_elements=['id'])
 #>> print(stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT (id) DO NOTHING

If ``DO NOTHING`` is used without specifying any columns or constraint,
it has the effect of skipping the INSERT for any unique or exclusion
constraint violation which occurs:

.. sourcecode:: pycon+sql

 #>> stmt = insert(my_table).values(id='some_id', data='inserted value')
 #>> stmt = stmt.on_conflict_do_nothing()
 #>> print(stmt)
 #opensql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s)
 #N CONFLICT DO NOTHING

.. _postgresql_match:

Full Text Search
----------------

SQLAlchemy makes available the PostgreSQL ``@@`` operator via the
:meth:`_expression.ColumnElement.match`
method on any textual column expression.
On a PostgreSQL dialect, an expression like the following::

 #elect(sometable.c.text.match("search string"))

will emit to the database::

 #ELECT text @@ to_tsquery('search string') FROM table

The PostgreSQL text search functions such as ``to_tsquery()``
and ``to_tsvector()`` are available
explicitly using the standard :data:`.func` construct.  For example::

 #elect(func.to_tsvector('fat cats ate rats').match('cat & rat'))

Emits the equivalent of::

 #ELECT to_tsvector('fat cats ate rats') @@ to_tsquery('cat & rat')

The :class:`_postgresql.TSVECTOR` type can provide for explicit CAST::

 #rom sqlalchemy.dialects.postgresql import TSVECTOR
 #rom sqlalchemy import select, cast
 #elect(cast("some text", TSVECTOR))

produces a statement equivalent to::

 #ELECT CAST('some text' AS TSVECTOR) AS anon_1

Full Text Searches in PostgreSQL are influenced by a combination of: the
PostgreSQL setting of ``default_text_search_config``, the ``regconfig`` used
to build the GIN/GiST indexes, and the ``regconfig`` optionally passed in
during a query.

When performing a Full Text Search against a column that has a GIN or
GiST index that is already pre-computed (which is common on full text
searches) one may need to explicitly pass in a particular PostgreSQL
``regconfig`` value to ensure the query-planner utilizes the index and does
not re-compute the column on demand.

In order to provide for this explicit query planning, or to use different
search strategies, the ``match`` method accepts a ``postgresql_regconfig``
keyword argument::

 #elect(mytable.c.id).where(
 #ytable.c.title.match('somestring', postgresql_regconfig='english')
 #

Emits the equivalent of::

 #ELECT mytable.id FROM mytable
 #HERE mytable.title @@ to_tsquery('english', 'somestring')

One can also specifically pass in a `'regconfig'` value to the
``to_tsvector()`` command as the initial argument::

 #elect(mytable.c.id).where(
 #unc.to_tsvector('english', mytable.c.title )\
 #match('somestring', postgresql_regconfig='english')
 #

produces a statement equivalent to::

 #ELECT mytable.id FROM mytable
 #HERE to_tsvector('english', mytable.title) @@
 #o_tsquery('english', 'somestring')

It is recommended that you use the ``EXPLAIN ANALYZE...`` tool from
PostgreSQL to ensure that you are generating queries with SQLAlchemy that
take full advantage of any indexes you may have created for full text search.

FROM ONLY ...
-------------

The dialect supports PostgreSQL's ONLY keyword for targeting only a particular
table in an inheritance hierarchy. This can be used to produce the
``SELECT ... FROM ONLY``, ``UPDATE ONLY ...``, and ``DELETE FROM ONLY ...``
syntaxes. It uses SQLAlchemy's hints mechanism::

    # SELECT ... FROM ONLY ...
 #esult = table.select().with_hint(table, 'ONLY', 'postgresql')
 #rint(result.fetchall())

    # UPDATE ONLY ...
 #able.update(values=dict(foo='bar')).with_hint('ONLY',
 #ialect_name='postgresql')

    # DELETE FROM ONLY ...
 #able.delete().with_hint('ONLY', dialect_name='postgresql')


.. _postgresql_indexes:

PostgreSQL-Specific Index Options
---------------------------------

Several extensions to the :class:`.Index` construct are available, specific
to the PostgreSQL dialect.

Covering Indexes
^^^^^^^^^^^^^^^^

The ``postgresql_include`` option renders INCLUDE(colname) for the given
string names::

 #ndex("my_index", table.c.x, postgresql_include=['y'])

would render the index as ``CREATE INDEX my_index ON table (x) INCLUDE (y)``

Note that this feature requires PostgreSQL 11 or later.

.. versionadded:: 1.4

.. _postgresql_partial_indexes:

Partial Indexes
^^^^^^^^^^^^^^^

Partial indexes add criterion to the index definition so that the index is
applied to a subset of rows.   These can be specified on :class:`.Index`
using the ``postgresql_where`` keyword argument::

 #ndex('my_index', my_table.c.id, postgresql_where=my_table.c.value > 10)

.. _postgresql_operator_classes:

Operator Classes
^^^^^^^^^^^^^^^^

PostgreSQL allows the specification of an *operator class* for each column of
an index (see
https://www.postgresql.org/docs/8.3/interactive/indexes-opclass.html).
The :class:`.Index` construct allows these to be specified via the
``postgresql_ops`` keyword argument::

 #ndex(
 #my_index', my_table.c.id, my_table.c.data,
 #ostgresql_ops={
 #data': 'text_pattern_ops',
 #id': 'int4_ops'
 #)

Note that the keys in the ``postgresql_ops`` dictionaries are the
"key" name of the :class:`_schema.Column`, i.e. the name used to access it from
the ``.c`` collection of :class:`_schema.Table`, which can be configured to be
different than the actual name of the column as expressed in the database.

If ``postgresql_ops`` is to be used against a complex SQL expression such
as a function call, then to apply to the column it must be given a label
that is identified in the dictionary by name, e.g.::

 #ndex(
 #my_index', my_table.c.id,
 #unc.lower(my_table.c.data).label('data_lower'),
 #ostgresql_ops={
 #data_lower': 'text_pattern_ops',
 #id': 'int4_ops'
 #)

Operator classes are also supported by the
:class:`_postgresql.ExcludeConstraint` construct using the
:paramref:`_postgresql.ExcludeConstraint.ops` parameter. See that parameter for
details.

.. versionadded:: 1.3.21 added support for operator classes with
 #class:`_postgresql.ExcludeConstraint`.


Index Types
^^^^^^^^^^^

PostgreSQL provides several index types: B-Tree, Hash, GiST, and GIN, as well
as the ability for users to create their own (see
https://www.postgresql.org/docs/8.3/static/indexes-types.html). These can be
specified on :class:`.Index` using the ``postgresql_using`` keyword argument::

 #ndex('my_index', my_table.c.data, postgresql_using='gin')

The value passed to the keyword argument will be simply passed through to the
underlying CREATE INDEX command, so it *must* be a valid index type for your
version of PostgreSQL.

.. _postgresql_index_storage:

Index Storage Parameters
^^^^^^^^^^^^^^^^^^^^^^^^

PostgreSQL allows storage parameters to be set on indexes. The storage
parameters available depend on the index method used by the index. Storage
parameters can be specified on :class:`.Index` using the ``postgresql_with``
keyword argument::

 #ndex('my_index', my_table.c.data, postgresql_with={"fillfactor": 50})

.. versionadded:: 1.0.6

PostgreSQL allows to define the tablespace in which to create the index.
The tablespace can be specified on :class:`.Index` using the
``postgresql_tablespace`` keyword argument::

 #ndex('my_index', my_table.c.data, postgresql_tablespace='my_tablespace')

.. versionadded:: 1.1

Note that the same option is available on :class:`_schema.Table` as well.

.. _postgresql_index_concurrently:

Indexes with CONCURRENTLY
^^^^^^^^^^^^^^^^^^^^^^^^^

The PostgreSQL index option CONCURRENTLY is supported by passing the
flag ``postgresql_concurrently`` to the :class:`.Index` construct::

 #bl = Table('testtbl', m, Column('data', Integer))

 #dx1 = Index('test_idx1', tbl.c.data, postgresql_concurrently=True)

The above index construct will render DDL for CREATE INDEX, assuming
PostgreSQL 8.2 or higher is detected or for a connection-less dialect, as::

 #REATE INDEX CONCURRENTLY test_idx1 ON testtbl (data)

For DROP INDEX, assuming PostgreSQL 9.2 or higher is detected or for
a connection-less dialect, it will emit::

 #ROP INDEX CONCURRENTLY test_idx1

.. versionadded:: 1.1 support for CONCURRENTLY on DROP INDEX.  The
 #ONCURRENTLY keyword is now only emitted if a high enough version
 #f PostgreSQL is detected on the connection (or for a connection-less
 #ialect).

When using CONCURRENTLY, the PostgreSQL database requires that the statement
be invoked outside of a transaction block.   The Python DBAPI enforces that
even for a single statement, a transaction is present, so to use this
construct, the DBAPI's "autocommit" mode must be used::

 #etadata = MetaData()
 #able = Table(
 #foo", metadata,
 #olumn("id", String))
 #ndex = Index(
 #foo_idx", table.c.id, postgresql_concurrently=True)

 #ith engine.connect() as conn:
 #ith conn.execution_options(isolation_level='AUTOCOMMIT'):
 #able.create(conn)

.. seealso::

 #ref:`postgresql_isolation_level`

.. _postgresql_index_reflection:

PostgreSQL Index Reflection
---------------------------

The PostgreSQL database creates a UNIQUE INDEX implicitly whenever the
UNIQUE CONSTRAINT construct is used.   When inspecting a table using
:class:`_reflection.Inspector`, the :meth:`_reflection.Inspector.get_indexes`
and the :meth:`_reflection.Inspector.get_unique_constraints`
will report on these
two constructs distinctly; in the case of the index, the key
``duplicates_constraint`` will be present in the index entry if it is
detected as mirroring a constraint.   When performing reflection using
``Table(..., autoload_with=engine)``, the UNIQUE INDEX is **not** returned
in :attr:`_schema.Table.indexes` when it is detected as mirroring a
:class:`.UniqueConstraint` in the :attr:`_schema.Table.constraints` collection
.

.. versionchanged:: 1.0.0 - :class:`_schema.Table` reflection now includes
 #class:`.UniqueConstraint` objects present in the
 #attr:`_schema.Table.constraints`
 #ollection; the PostgreSQL backend will no longer include a "mirrored"
 #class:`.Index` construct in :attr:`_schema.Table.indexes`
 #f it is detected
 #s corresponding to a unique constraint.

Special Reflection Options
--------------------------

The :class:`_reflection.Inspector`
used for the PostgreSQL backend is an instance
of :class:`.PGInspector`, which offers additional methods::

 #rom sqlalchemy import create_engine, inspect

 #ngine = create_engine("postgresql+psycopg2://localhost/test")
 #nsp = inspect(engine)  # will be a PGInspector

 #rint(insp.get_enums())

.. autoclass:: PGInspector
 #members:

.. _postgresql_table_options:

PostgreSQL Table Options
------------------------

Several options for CREATE TABLE are supported directly by the PostgreSQL
dialect in conjunction with the :class:`_schema.Table` construct:

* ``TABLESPACE``::

 #able("some_table", metadata, ..., postgresql_tablespace='some_tablespace')

 #he above option is also available on the :class:`.Index` construct.

* ``ON COMMIT``::

 #able("some_table", metadata, ..., postgresql_on_commit='PRESERVE ROWS')

* ``WITH OIDS``::

 #able("some_table", metadata, ..., postgresql_with_oids=True)

* ``WITHOUT OIDS``::

 #able("some_table", metadata, ..., postgresql_with_oids=False)

* ``INHERITS``::

 #able("some_table", metadata, ..., postgresql_inherits="some_supertable")

 #able("some_table", metadata, ..., postgresql_inherits=("t1", "t2", ...))

 #. versionadded:: 1.0.0

* ``PARTITION BY``::

 #able("some_table", metadata, ...,
 #ostgresql_partition_by='LIST (part_column)')

 #. versionadded:: 1.2.6

.. seealso::

 #PostgreSQL CREATE TABLE options
 #https://www.postgresql.org/docs/current/static/sql-createtable.html>`_

.. _postgresql_table_valued_overview:

Table values, Table and Column valued functions, Row and Tuple objects
-----------------------------------------------------------------------

PostgreSQL makes great use of modern SQL forms such as table-valued functions,
tables and rows as values.   These constructs are commonly used as part
of PostgreSQL's support for complex datatypes such as JSON, ARRAY, and other
datatypes.  SQLAlchemy's SQL expression language has native support for
most table-valued and row-valued forms.

.. _postgresql_table_valued:

Table-Valued Functions
^^^^^^^^^^^^^^^^^^^^^^^

Many PostgreSQL built-in functions are intended to be used in the FROM clause
of a SELECT statement, and are capable of returning table rows or sets of table
rows. A large portion of PostgreSQL's JSON functions for example such as
``json_array_elements()``, ``json_object_keys()``, ``json_each_text()``,
``json_each()``, ``json_to_record()``, ``json_populate_recordset()`` use such
forms. These classes of SQL function calling forms in SQLAlchemy are available
using the :meth:`_functions.FunctionElement.table_valued` method in conjunction
with :class:`_functions.Function` objects generated from the :data:`_sql.func`
namespace.

Examples from PostgreSQL's reference documentation follow below:

* ``json_each()``::

 #>> from sqlalchemy import select, func
 #>> stmt = select(func.json_each('{"a":"foo", "b":"bar"}').table_valued("key", "value"))
 #>> print(stmt)
 #ELECT anon_1.key, anon_1.value
 #ROM json_each(:json_each_1) AS anon_1

* ``json_populate_record()``::

 #>> from sqlalchemy import select, func, literal_column
 #>> stmt = select(
 #..     func.json_populate_record(
 #..         literal_column("null::myrowtype"),
 #..         '{"a":1,"b":2}'
 #..     ).table_valued("a", "b", name="x")
 #.. )
 #>> print(stmt)
 #ELECT x.a, x.b
 #ROM json_populate_record(null::myrowtype, :json_populate_record_1) AS x

* ``json_to_record()`` - this form uses a PostgreSQL specific form of derived
 #olumns in the alias, where we may make use of :func:`_sql.column` elements with
 #ypes to produce them.  The :meth:`_functions.FunctionElement.table_valued`
 #ethod produces  a :class:`_sql.TableValuedAlias` construct, and the method
 #meth:`_sql.TableValuedAlias.render_derived` method sets up the derived
 #olumns specification::

 #>> from sqlalchemy import select, func, column, Integer, Text
 #>> stmt = select(
 #..     func.json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}').table_valued(
 #..         column("a", Integer), column("b", Text), column("d", Text),
 #..     ).render_derived(name="x", with_types=True)
 #.. )
 #>> print(stmt)
 #ELECT x.a, x.b, x.d
 #ROM json_to_record(:json_to_record_1) AS x(a INTEGER, b TEXT, d TEXT)

* ``WITH ORDINALITY`` - part of the SQL standard, ``WITH ORDINALITY`` adds an
 #rdinal counter to the output of a function and is accepted by a limited set
 #f PostgreSQL functions including ``unnest()`` and ``generate_series()``. The
 #meth:`_functions.FunctionElement.table_valued` method accepts a keyword
 #arameter ``with_ordinality`` for this purpose, which accepts the string name
 #hat will be applied to the "ordinality" column::

 #>> from sqlalchemy import select, func
 #>> stmt = select(
 #..     func.generate_series(4, 1, -1).table_valued("value", with_ordinality="ordinality")
 #.. )
 #>> print(stmt)
 #ELECT anon_1.value, anon_1.ordinality
 #ROM generate_series(:generate_series_1, :generate_series_2, :generate_series_3) WITH ORDINALITY AS anon_1

.. versionadded:: 1.4.0b2

.. seealso::

 #ref:`tutorial_functions_table_valued` - in the :ref:`unified_tutorial`

.. _postgresql_column_valued:

Column Valued Functions
^^^^^^^^^^^^^^^^^^^^^^^

Similar to the table valued function, a column valued function is present
in the FROM clause, but delivers itself to the columns clause as a single
scalar value.  PostgreSQL functions such as ``json_array_elements()``,
``unnest()`` and ``generate_series()`` may use this form. Column valued functions are available using the
:meth:`_functions.FunctionElement.column_valued` method of :class:`_functions.FunctionElement`:

* ``json_array_elements()``::

 #>> from sqlalchemy import select, func
 #>> stmt = select(func.json_array_elements('["one", "two"]').column_valued("x"))
 #>> print(stmt)
 #ELECT x
 #ROM json_array_elements(:json_array_elements_1) AS x

* ``unnest()`` - in order to generate a PostgreSQL ARRAY literal, the
 #func:`_postgresql.array` construct may be used::


 #>> from sqlalchemy.dialects.postgresql import array
 #>> from sqlalchemy import select, func
 #>> stmt = select(func.unnest(array([1, 2])).column_valued())
 #>> print(stmt)
 #ELECT anon_1
 #ROM unnest(ARRAY[%(param_1)s, %(param_2)s]) AS anon_1

 #he function can of course be used against an existing table-bound column
 #hat's of type :class:`_types.ARRAY`::

 #>> from sqlalchemy import table, column, ARRAY, Integer
 #>> from sqlalchemy import select, func
 #>> t = table("t", column('value', ARRAY(Integer)))
 #>> stmt = select(func.unnest(t.c.value).column_valued("unnested_value"))
 #>> print(stmt)
 #ELECT unnested_value
 #ROM unnest(t.value) AS unnested_value

.. seealso::

 #ref:`tutorial_functions_column_valued` - in the :ref:`unified_tutorial`


Row Types
^^^^^^^^^

Built-in support for rendering a ``ROW`` may be approximated using
``func.ROW`` with the :attr:`_sa.func` namespace, or by using the
:func:`_sql.tuple_` construct::

 #>> from sqlalchemy import table, column, func, tuple_
 #>> t = table("t", column("id"), column("fk"))
 #>> stmt = t.select().where(
 #..     tuple_(t.c.id, t.c.fk) > (1,2)
 #.. ).where(
 #..     func.ROW(t.c.id, t.c.fk) < func.ROW(3, 7)
 #.. )
 #>> print(stmt)
 #ELECT t.id, t.fk
 #ROM t
 #HERE (t.id, t.fk) > (:param_1, :param_2) AND ROW(t.id, t.fk) < ROW(:ROW_1, :ROW_2)

.. seealso::

 #PostgreSQL Row Constructors
 #https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS>`_

 #PostgreSQL Row Constructor Comparison
 #https://www.postgresql.org/docs/current/functions-comparisons.html#ROW-WISE-COMPARISON>`_

Table Types passed to Functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

PostgreSQL supports passing a table as an argument to a function, which it
refers towards as a "record" type. SQLAlchemy :class:`_sql.FromClause` objects
such as :class:`_schema.Table` support this special form using the
:meth:`_sql.FromClause.table_valued` method, which is comparable to the
:meth:`_functions.FunctionElement.table_valued` method except that the collection
of columns is already established by that of the :class:`_sql.FromClause`
itself::


 #>> from sqlalchemy import table, column, func, select
 #>> a = table( "a", column("id"), column("x"), column("y"))
 #>> stmt = select(func.row_to_json(a.table_valued()))
 #>> print(stmt)
 #ELECT row_to_json(a) AS row_to_json_1
 #ROM a

.. versionadded:: 1.4.0b2


ARRAY Types
-----------

The PostgreSQL dialect supports arrays, both as multidimensional column types
as well as array literals:

* :class:`_postgresql.ARRAY` - ARRAY datatype

* :class:`_postgresql.array` - array literal

* :func:`_postgresql.array_agg` - ARRAY_AGG SQL function

* :class:`_postgresql.aggregate_order_by` - helper for PG's ORDER BY aggregate
 #unction syntax.

JSON Types
----------

The PostgreSQL dialect supports both JSON and JSONB datatypes, including
psycopg2's native support and support for all of PostgreSQL's special
operators:

* :class:`_postgresql.JSON`

* :class:`_postgresql.JSONB`

HSTORE Type
-----------

The PostgreSQL HSTORE type as well as hstore literals are supported:

* :class:`_postgresql.HSTORE` - HSTORE datatype

* :class:`_postgresql.hstore` - hstore literal

ENUM Types
----------

PostgreSQL has an independently creatable TYPE structure which is used
to implement an enumerated type.   This approach introduces significant
complexity on the SQLAlchemy side in terms of when this type should be
CREATED and DROPPED.   The type object is also an independently reflectable
entity.   The following sections should be consulted:

* :class:`_postgresql.ENUM` - DDL and typing support for ENUM.

* :meth:`.PGInspector.get_enums` - retrieve a listing of current ENUM types

* :meth:`.postgresql.ENUM.create` , :meth:`.postgresql.ENUM.drop` - individual
 #REATE and DROP commands for ENUM.

.. _postgresql_array_of_enum:

Using ENUM with ARRAY
^^^^^^^^^^^^^^^^^^^^^

The combination of ENUM and ARRAY is not directly supported by backend
DBAPIs at this time.   Prior to SQLAlchemy 1.3.17, a special workaround
was needed in order to allow this combination to work, described below.

.. versionchanged:: 1.3.17 The combination of ENUM and ARRAY is now directly
 #andled by SQLAlchemy's implementation without any workarounds needed.

.. sourcecode:: python

 #rom sqlalchemy import TypeDecorator
 #rom sqlalchemy.dialects.postgresql import ARRAY

 #lass ArrayOfEnum(TypeDecorator):
 #mpl = ARRAY

 #ef bind_expression(self, bindvalue):
 #eturn sa.cast(bindvalue, self)

 #ef result_processor(self, dialect, coltype):
 #uper_rp = super(ArrayOfEnum, self).result_processor(
 #ialect, coltype)

 #ef handle_raw_string(value):
 #nner = re.match(r"^{(.*)}$", value).group(1)
 #eturn inner.split(",") if inner else []

 #ef process(value):
 #f value is None:
 #eturn None
 #eturn super_rp(handle_raw_string(value))
 #eturn process

E.g.::

 #able(
 #mydata', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', ArrayOfEnum(ENUM('a', 'b, 'c', name='myenum')))

 #

This type is not included as a built-in type as it would be incompatible
with a DBAPI that suddenly decides to support ARRAY of ENUM directly in
a new version.

.. _postgresql_array_of_json:

Using JSON/JSONB with ARRAY
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Similar to using ENUM, prior to SQLAlchemy 1.3.17, for an ARRAY of JSON/JSONB
we need to render the appropriate CAST.   Current psycopg2 drivers accommodate
the result set correctly without any special steps.

.. versionchanged:: 1.3.17 The combination of JSON/JSONB and ARRAY is now
 #irectly handled by SQLAlchemy's implementation without any workarounds
 #eeded.

.. sourcecode:: python

 #lass CastingArray(ARRAY):
 #ef bind_expression(self, bindvalue):
 #eturn sa.cast(bindvalue, self)

E.g.::

 #able(
 #mydata', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', CastingArray(JSONB))
 #


"""  # noqa E501

from collections import defaultdict
import datetime as dt
import re
from uuid import UUID as _python_UUID

from . import array as _array
from . import hstore as _hstore
from . import json as _json
from . import ranges as _ranges
from ... import exc
from ... import schema
from ... import sql
from ... import util
from ...engine import characteristics
from ...engine import default
from ...engine import reflection
from ...sql import coercions
from ...sql import compiler
from ...sql import elements
from ...sql import expression
from ...sql import roles
from ...sql import sqltypes
from ...sql import util as sql_util
from ...sql.ddl import DDLBase
from ...types import BIGINT
from ...types import BOOLEAN
from ...types import CHAR
from ...types import DATE
from ...types import FLOAT
from ...types import INTEGER
from ...types import NUMERIC
from ...types import REAL
from ...types import SMALLINT
from ...types import TEXT
from ...types import VARCHAR


IDX_USING = re.compile(r"^(?:btree|hash|gist|gin|[\w_]+)$", re.I)

AUTOCOMMIT_REGEXP = re.compile(
 #"\s*(?:UPDATE|INSERT|CREATE|DELETE|DROP|ALTER|GRANT|REVOKE|"
 #IMPORT FOREIGN SCHEMA|REFRESH MATERIALIZED VIEW|TRUNCATE)",
 #e.I | re.UNICODE,
)

RESERVED_WORDS = set(
 #
 #all",
 #analyse",
 #analyze",
 #and",
 #any",
 #array",
 #as",
 #asc",
 #asymmetric",
 #both",
 #case",
 #cast",
 #check",
 #collate",
 #column",
 #constraint",
 #create",
 #current_catalog",
 #current_date",
 #current_role",
 #current_time",
 #current_timestamp",
 #current_user",
 #default",
 #deferrable",
 #desc",
 #distinct",
 #do",
 #else",
 #end",
 #except",
 #false",
 #fetch",
 #for",
 #foreign",
 #from",
 #grant",
 #group",
 #having",
 #in",
 #initially",
 #intersect",
 #into",
 #leading",
 #limit",
 #localtime",
 #localtimestamp",
 #new",
 #not",
 #null",
 #of",
 #off",
 #offset",
 #old",
 #on",
 #only",
 #or",
 #order",
 #placing",
 #primary",
 #references",
 #returning",
 #select",
 #session_user",
 #some",
 #symmetric",
 #table",
 #then",
 #to",
 #trailing",
 #true",
 #union",
 #unique",
 #user",
 #using",
 #variadic",
 #when",
 #where",
 #window",
 #with",
 #authorization",
 #between",
 #binary",
 #cross",
 #current_schema",
 #freeze",
 #full",
 #ilike",
 #inner",
 #is",
 #isnull",
 #join",
 #left",
 #like",
 #natural",
 #notnull",
 #outer",
 #over",
 #overlaps",
 #right",
 #similar",
 #verbose",
 #
)

_DECIMAL_TYPES = (1231, 1700)
_FLOAT_TYPES = (700, 701, 1021, 1022)
_INT_TYPES = (20, 21, 23, 26, 1005, 1007, 1016)


class BYTEA(sqltypes.LargeBinary):
 #_visit_name__ = "BYTEA"


class DOUBLE_PRECISION(sqltypes.Float):
 #_visit_name__ = "DOUBLE_PRECISION"


class INET(sqltypes.TypeEngine):
 #_visit_name__ = "INET"


PGInet = INET


class CIDR(sqltypes.TypeEngine):
 #_visit_name__ = "CIDR"


PGCidr = CIDR


class MACADDR(sqltypes.TypeEngine):
 #_visit_name__ = "MACADDR"


PGMacAddr = MACADDR


class MONEY(sqltypes.TypeEngine):

 #"""Provide the PostgreSQL MONEY type.

 #epending on driver, result rows using this type may return a
 #tring value which includes currency symbols.

 #or this reason, it may be preferable to provide conversion to a
 #umerically-based currency datatype using :class:`_types.TypeDecorator`::

 #mport re
 #mport decimal
 #rom sqlalchemy import TypeDecorator

 #lass NumericMoney(TypeDecorator):
 #mpl = MONEY

 #ef process_result_value(self, value: Any, dialect: Any) -> None:
 #f value is not None:
                    # adjust this for the currency and numeric
 # = re.match(r"\$([\d.]+)", value)
 #f m:
 #alue = decimal.Decimal(m.group(1))
 #eturn value

 #lternatively, the conversion may be applied as a CAST using
 #he :meth:`_types.TypeDecorator.column_expression` method as follows::

 #mport decimal
 #rom sqlalchemy import cast
 #rom sqlalchemy import TypeDecorator

 #lass NumericMoney(TypeDecorator):
 #mpl = MONEY

 #ef column_expression(self, column: Any):
 #eturn cast(column, Numeric())

 #. versionadded:: 1.2

 #""

 #_visit_name__ = "MONEY"


class OID(sqltypes.TypeEngine):

 #""Provide the PostgreSQL OID type.

 #. versionadded:: 0.9.5

 #""

 #_visit_name__ = "OID"


class REGCLASS(sqltypes.TypeEngine):

 #""Provide the PostgreSQL REGCLASS type.

 #. versionadded:: 1.2.7

 #""

 #_visit_name__ = "REGCLASS"


class TIMESTAMP(sqltypes.TIMESTAMP):
 #ef __init__(self, timezone=False, precision=None):
 #uper(TIMESTAMP, self).__init__(timezone=timezone)
 #elf.precision = precision


class TIME(sqltypes.TIME):
 #ef __init__(self, timezone=False, precision=None):
 #uper(TIME, self).__init__(timezone=timezone)
 #elf.precision = precision


class INTERVAL(sqltypes.NativeForEmulated, sqltypes._AbstractInterval):

 #""PostgreSQL INTERVAL type."""

 #_visit_name__ = "INTERVAL"
 #ative = True

 #ef __init__(self, precision=None, fields=None):
 #""Construct an INTERVAL.

 #param precision: optional integer precision value
 #param fields: string fields specifier.  allows storage of fields
 #o be limited, such as ``"YEAR"``, ``"MONTH"``, ``"DAY TO HOUR"``,
 #tc.

 #. versionadded:: 1.2

 #""
 #elf.precision = precision
 #elf.fields = fields

 #classmethod
 #ef adapt_emulated_to_native(cls, interval, **kw):
 #eturn INTERVAL(precision=interval.second_precision)

 #property
 #ef _type_affinity(self):
 #eturn sqltypes.Interval

 #ef as_generic(self, allow_nulltype=False):
 #eturn sqltypes.Interval(native=True, second_precision=self.precision)

 #property
 #ef python_type(self):
 #eturn dt.timedelta

 #ef coerce_compared_value(self, op, value):
 #eturn self


PGInterval = INTERVAL


class BIT(sqltypes.TypeEngine):
 #_visit_name__ = "BIT"

 #ef __init__(self, length=None, varying=False):
 #f not varying:
            # BIT without VARYING defaults to length 1
 #elf.length = length or 1
 #lse:
            # but BIT VARYING can be unlimited-length, so no default
 #elf.length = length
 #elf.varying = varying


PGBit = BIT


class UUID(sqltypes.TypeEngine):

 #""PostgreSQL UUID type.

 #epresents the UUID column type, interpreting
 #ata either as natively returned by the DBAPI
 #r as Python uuid objects.

 #he UUID type is currently known to work within the prominent DBAPI
 #rivers supported by SQLAlchemy including psycopg2, pg8000 and
 #syncpg. Support for other DBAPI drivers may be incomplete or non-present.

 #""

 #_visit_name__ = "UUID"

 #ef __init__(self, as_uuid=False):
 #""Construct a UUID type.


 #param as_uuid=False: if True, values will be interpreted
 #s Python uuid objects, converting to/from string via the
 #BAPI.

 #""
 #elf.as_uuid = as_uuid

 #ef coerce_compared_value(self, op, value):
 #""See :meth:`.TypeEngine.coerce_compared_value` for a description."""

 #f isinstance(value, util.string_types):
 #eturn self
 #lse:
 #eturn super(UUID, self).coerce_compared_value(op, value)

 #ef bind_processor(self, dialect):
 #f self.as_uuid:

 #ef process(value):
 #f value is not None:
 #alue = util.text_type(value)
 #eturn value

 #eturn process
 #lse:
 #eturn None

 #ef result_processor(self, dialect, coltype):
 #f self.as_uuid:

 #ef process(value):
 #f value is not None:
 #alue = _python_UUID(value)
 #eturn value

 #eturn process
 #lse:
 #eturn None


PGUuid = UUID


class TSVECTOR(sqltypes.TypeEngine):

 #""The :class:`_postgresql.TSVECTOR` type implements the PostgreSQL
 #ext search type TSVECTOR.

 #t can be used to do full text queries on natural language
 #ocuments.

 #. versionadded:: 0.9.0

 #. seealso::

 #ref:`postgresql_match`

 #""

 #_visit_name__ = "TSVECTOR"


class ENUM(sqltypes.NativeForEmulated, sqltypes.Enum):

 #""PostgreSQL ENUM type.

 #his is a subclass of :class:`_types.Enum` which includes
 #upport for PG's ``CREATE TYPE`` and ``DROP TYPE``.

 #hen the builtin type :class:`_types.Enum` is used and the
 #paramref:`.Enum.native_enum` flag is left at its default of
 #rue, the PostgreSQL backend will use a :class:`_postgresql.ENUM`
 #ype as the implementation, so the special create/drop rules
 #ill be used.

 #he create/drop behavior of ENUM is necessarily intricate, due to the
 #wkward relationship the ENUM type has in relationship to the
 #arent table, in that it may be "owned" by just a single table, or
 #ay be shared among many tables.

 #hen using :class:`_types.Enum` or :class:`_postgresql.ENUM`
 #n an "inline" fashion, the ``CREATE TYPE`` and ``DROP TYPE`` is emitted
 #orresponding to when the :meth:`_schema.Table.create` and
 #meth:`_schema.Table.drop`
 #ethods are called::

 #able = Table('sometable', metadata,
 #olumn('some_enum', ENUM('a', 'b', 'c', name='myenum'))
 #

 #able.create(engine)  # will emit CREATE ENUM and CREATE TABLE
 #able.drop(engine)  # will emit DROP TABLE and DROP ENUM

 #o use a common enumerated type between multiple tables, the best
 #ractice is to declare the :class:`_types.Enum` or
 #class:`_postgresql.ENUM` independently, and associate it with the
 #class:`_schema.MetaData` object itself::

 #y_enum = ENUM('a', 'b', 'c', name='myenum', metadata=metadata)

 #1 = Table('sometable_one', metadata,
 #olumn('some_enum', myenum)
 #

 #2 = Table('sometable_two', metadata,
 #olumn('some_enum', myenum)
 #

 #hen this pattern is used, care must still be taken at the level
 #f individual table creates.  Emitting CREATE TABLE without also
 #pecifying ``checkfirst=True`` will still cause issues::

 #1.create(engine) # will fail: no such type 'myenum'

 #f we specify ``checkfirst=True``, the individual table-level create
 #peration will check for the ``ENUM`` and create if not exists::

        # will check if enum exists, and emit CREATE TYPE if not
 #1.create(engine, checkfirst=True)

 #hen using a metadata-level ENUM type, the type will always be created
 #nd dropped if either the metadata-wide create/drop is called::

 #etadata.create_all(engine)  # will emit CREATE TYPE
 #etadata.drop_all(engine)  # will emit DROP TYPE

 #he type can also be created and dropped directly::

 #y_enum.create(engine)
 #y_enum.drop(engine)

 #. versionchanged:: 1.0.0 The PostgreSQL :class:`_postgresql.ENUM` type
 #ow behaves more strictly with regards to CREATE/DROP.  A metadata-level
 #NUM type will only be created and dropped at the metadata level,
 #ot the table level, with the exception of
 #`table.create(checkfirst=True)``.
 #he ``table.drop()`` call will now emit a DROP TYPE for a table-level
 #numerated type.

 #""

 #ative_enum = True

 #ef __init__(self, *enums, **kw):
 #""Construct an :class:`_postgresql.ENUM`.

 #rguments are the same as that of
 #class:`_types.Enum`, but also including
 #he following parameters.

 #param create_type: Defaults to True.
 #ndicates that ``CREATE TYPE`` should be
 #mitted, after optionally checking for the
 #resence of the type, when the parent
 #able is being created; and additionally
 #hat ``DROP TYPE`` is called when the table
 #s dropped.    When ``False``, no check
 #ill be performed and no ``CREATE TYPE``
 #r ``DROP TYPE`` is emitted, unless
 #meth:`~.postgresql.ENUM.create`
 #r :meth:`~.postgresql.ENUM.drop`
 #re called directly.
 #etting to ``False`` is helpful
 #hen invoking a creation scheme to a SQL file
 #ithout access to the actual database -
 #he :meth:`~.postgresql.ENUM.create` and
 #meth:`~.postgresql.ENUM.drop` methods can
 #e used to emit SQL to a target bind.

 #""
 #elf.create_type = kw.pop("create_type", True)
 #uper(ENUM, self).__init__(*enums, **kw)

 #classmethod
 #ef adapt_emulated_to_native(cls, impl, **kw):
 #""Produce a PostgreSQL native :class:`_postgresql.ENUM` from plain
 #class:`.Enum`.

 #""
 #w.setdefault("validate_strings", impl.validate_strings)
 #w.setdefault("name", impl.name)
 #w.setdefault("schema", impl.schema)
 #w.setdefault("inherit_schema", impl.inherit_schema)
 #w.setdefault("metadata", impl.metadata)
 #w.setdefault("_create_events", False)
 #w.setdefault("values_callable", impl.values_callable)
 #w.setdefault("omit_aliases", impl._omit_aliases)
 #eturn cls(**kw)

 #ef create(self, bind=None, checkfirst=True):
 #""Emit ``CREATE TYPE`` for this
 #class:`_postgresql.ENUM`.

 #f the underlying dialect does not support
 #ostgreSQL CREATE TYPE, no action is taken.

 #param bind: a connectable :class:`_engine.Engine`,
 #class:`_engine.Connection`, or similar object to emit
 #QL.
 #param checkfirst: if ``True``, a query against
 #he PG catalog will be first performed to see
 #f the type does not exist already before
 #reating.

 #""
 #f not bind.dialect.supports_native_enum:
 #eturn

 #ind._run_ddl_visitor(self.EnumGenerator, self, checkfirst=checkfirst)

 #ef drop(self, bind=None, checkfirst=True):
 #""Emit ``DROP TYPE`` for this
 #class:`_postgresql.ENUM`.

 #f the underlying dialect does not support
 #ostgreSQL DROP TYPE, no action is taken.

 #param bind: a connectable :class:`_engine.Engine`,
 #class:`_engine.Connection`, or similar object to emit
 #QL.
 #param checkfirst: if ``True``, a query against
 #he PG catalog will be first performed to see
 #f the type actually exists before dropping.

 #""
 #f not bind.dialect.supports_native_enum:
 #eturn

 #ind._run_ddl_visitor(self.EnumDropper, self, checkfirst=checkfirst)

 #lass EnumGenerator(DDLBase):
 #ef __init__(self, dialect, connection, checkfirst=False, **kwargs):
 #uper(ENUM.EnumGenerator, self).__init__(connection, **kwargs)
 #elf.checkfirst = checkfirst

 #ef _can_create_enum(self, enum):
 #f not self.checkfirst:
 #eturn True

 #ffective_schema = self.connection.schema_for_object(enum)

 #eturn not self.connection.dialect.has_type(
 #elf.connection, enum.name, schema=effective_schema
 #

 #ef visit_enum(self, enum):
 #f not self._can_create_enum(enum):
 #eturn

 #elf.connection.execute(CreateEnumType(enum))

 #lass EnumDropper(DDLBase):
 #ef __init__(self, dialect, connection, checkfirst=False, **kwargs):
 #uper(ENUM.EnumDropper, self).__init__(connection, **kwargs)
 #elf.checkfirst = checkfirst

 #ef _can_drop_enum(self, enum):
 #f not self.checkfirst:
 #eturn True

 #ffective_schema = self.connection.schema_for_object(enum)

 #eturn self.connection.dialect.has_type(
 #elf.connection, enum.name, schema=effective_schema
 #

 #ef visit_enum(self, enum):
 #f not self._can_drop_enum(enum):
 #eturn

 #elf.connection.execute(DropEnumType(enum))

 #ef _check_for_name_in_memos(self, checkfirst, kw):
 #""Look in the 'ddl runner' for 'memos', then
 #ote our name in that collection.

 #his to ensure a particular named enum is operated
 #pon only once within any kind of create/drop
 #equence without relying upon "checkfirst".

 #""
 #f not self.create_type:
 #eturn True
 #f "_ddl_runner" in kw:
 #dl_runner = kw["_ddl_runner"]
 #f "_pg_enums" in ddl_runner.memo:
 #g_enums = ddl_runner.memo["_pg_enums"]
 #lse:
 #g_enums = ddl_runner.memo["_pg_enums"] = set()
 #resent = (self.schema, self.name) in pg_enums
 #g_enums.add((self.schema, self.name))
 #eturn present
 #lse:
 #eturn False

 #ef _on_table_create(self, target, bind, checkfirst=False, **kw):
 #f (
 #heckfirst
 #r (
 #ot self.metadata
 #nd not kw.get("_is_metadata_operation", False)
 #
 # and not self._check_for_name_in_memos(checkfirst, kw):
 #elf.create(bind=bind, checkfirst=checkfirst)

 #ef _on_table_drop(self, target, bind, checkfirst=False, **kw):
 #f (
 #ot self.metadata
 #nd not kw.get("_is_metadata_operation", False)
 #nd not self._check_for_name_in_memos(checkfirst, kw)
 #:
 #elf.drop(bind=bind, checkfirst=checkfirst)

 #ef _on_metadata_create(self, target, bind, checkfirst=False, **kw):
 #f not self._check_for_name_in_memos(checkfirst, kw):
 #elf.create(bind=bind, checkfirst=checkfirst)

 #ef _on_metadata_drop(self, target, bind, checkfirst=False, **kw):
 #f not self._check_for_name_in_memos(checkfirst, kw):
 #elf.drop(bind=bind, checkfirst=checkfirst)


colspecs = {
 #qltypes.ARRAY: _array.ARRAY,
 #qltypes.Interval: INTERVAL,
 #qltypes.Enum: ENUM,
 #qltypes.JSON.JSONPathType: _json.JSONPathType,
 #qltypes.JSON: _json.JSON,
}

ischema_names = {
 #_array": _array.ARRAY,
 #hstore": _hstore.HSTORE,
 #json": _json.JSON,
 #jsonb": _json.JSONB,
 #int4range": _ranges.INT4RANGE,
 #int8range": _ranges.INT8RANGE,
 #numrange": _ranges.NUMRANGE,
 #daterange": _ranges.DATERANGE,
 #tsrange": _ranges.TSRANGE,
 #tstzrange": _ranges.TSTZRANGE,
 #integer": INTEGER,
 #bigint": BIGINT,
 #smallint": SMALLINT,
 #character varying": VARCHAR,
 #character": CHAR,
 #"char"': sqltypes.String,
 #name": sqltypes.String,
 #text": TEXT,
 #numeric": NUMERIC,
 #float": FLOAT,
 #real": REAL,
 #inet": INET,
 #cidr": CIDR,
 #uuid": UUID,
 #bit": BIT,
 #bit varying": BIT,
 #macaddr": MACADDR,
 #money": MONEY,
 #oid": OID,
 #regclass": REGCLASS,
 #double precision": DOUBLE_PRECISION,
 #timestamp": TIMESTAMP,
 #timestamp with time zone": TIMESTAMP,
 #timestamp without time zone": TIMESTAMP,
 #time with time zone": TIME,
 #time without time zone": TIME,
 #date": DATE,
 #time": TIME,
 #bytea": BYTEA,
 #boolean": BOOLEAN,
 #interval": INTERVAL,
 #tsvector": TSVECTOR,
}


class PGCompiler(compiler.SQLCompiler):
 #ef visit_array(self, element, **kw):
 #eturn "ARRAY[%s]" % self.visit_clauselist(element, **kw)

 #ef visit_slice(self, element, **kw):
 #eturn "%s:%s" % (
 #elf.process(element.start, **kw),
 #elf.process(element.stop, **kw),
 #

 #ef visit_json_getitem_op_binary(
 #elf, binary, operator, _cast_applied=False, **kw
 #:
 #f (
 #ot _cast_applied
 #nd binary.type._type_affinity is not sqltypes.JSON
 #:
 #w["_cast_applied"] = True
 #eturn self.process(sql.cast(binary, binary.type), **kw)

 #w["eager_grouping"] = True

 #eturn self._generate_generic_binary(
 #inary, " -> " if not _cast_applied else " ->> ", **kw
 #

 #ef visit_json_path_getitem_op_binary(
 #elf, binary, operator, _cast_applied=False, **kw
 #:
 #f (
 #ot _cast_applied
 #nd binary.type._type_affinity is not sqltypes.JSON
 #:
 #w["_cast_applied"] = True
 #eturn self.process(sql.cast(binary, binary.type), **kw)

 #w["eager_grouping"] = True
 #eturn self._generate_generic_binary(
 #inary, " #> " if not _cast_applied else " #>> ", **kw
 #

 #ef visit_getitem_binary(self, binary, operator, **kw):
 #eturn "%s[%s]" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef visit_aggregate_order_by(self, element, **kw):
 #eturn "%s ORDER BY %s" % (
 #elf.process(element.target, **kw),
 #elf.process(element.order_by, **kw),
 #

 #ef visit_match_op_binary(self, binary, operator, **kw):
 #f "postgresql_regconfig" in binary.modifiers:
 #egconfig = self.render_literal_value(
 #inary.modifiers["postgresql_regconfig"], sqltypes.STRINGTYPE
 #
 #f regconfig:
 #eturn "%s @@ to_tsquery(%s, %s)" % (
 #elf.process(binary.left, **kw),
 #egconfig,
 #elf.process(binary.right, **kw),
 #
 #eturn "%s @@ to_tsquery(%s)" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 #

 #ef visit_ilike_op_binary(self, binary, operator, **kw):
 #scape = binary.modifiers.get("escape", None)

 #eturn "%s ILIKE %s" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 # + (
 # ESCAPE " + self.render_literal_value(escape, sqltypes.STRINGTYPE)
 #f escape
 #lse ""
 #

 #ef visit_not_ilike_op_binary(self, binary, operator, **kw):
 #scape = binary.modifiers.get("escape", None)
 #eturn "%s NOT ILIKE %s" % (
 #elf.process(binary.left, **kw),
 #elf.process(binary.right, **kw),
 # + (
 # ESCAPE " + self.render_literal_value(escape, sqltypes.STRINGTYPE)
 #f escape
 #lse ""
 #

 #ef _regexp_match(self, base_op, binary, operator, kw):
 #lags = binary.modifiers["flags"]
 #f flags is None:
 #eturn self._generate_generic_binary(
 #inary, " %s " % base_op, **kw
 #
 #f isinstance(flags, elements.BindParameter) and flags.value == "i":
 #eturn self._generate_generic_binary(
 #inary, " %s* " % base_op, **kw
 #
 #lags = self.process(flags, **kw)
 #tring = self.process(binary.left, **kw)
 #attern = self.process(binary.right, **kw)
 #eturn "%s %s CONCAT('(?', %s, ')', %s)" % (
 #tring,
 #ase_op,
 #lags,
 #attern,
 #

 #ef visit_regexp_match_op_binary(self, binary, operator, **kw):
 #eturn self._regexp_match("~", binary, operator, kw)

 #ef visit_not_regexp_match_op_binary(self, binary, operator, **kw):
 #eturn self._regexp_match("!~", binary, operator, kw)

 #ef visit_regexp_replace_op_binary(self, binary, operator, **kw):
 #tring = self.process(binary.left, **kw)
 #attern = self.process(binary.right, **kw)
 #lags = binary.modifiers["flags"]
 #f flags is not None:
 #lags = self.process(flags, **kw)
 #eplacement = self.process(binary.modifiers["replacement"], **kw)
 #f flags is None:
 #eturn "REGEXP_REPLACE(%s, %s, %s)" % (
 #tring,
 #attern,
 #eplacement,
 #
 #lse:
 #eturn "REGEXP_REPLACE(%s, %s, %s, %s)" % (
 #tring,
 #attern,
 #eplacement,
 #lags,
 #

 #ef visit_empty_set_expr(self, element_types):
        # cast the empty set to the type we are comparing against.  if
        # we are comparing against the null type, pick an arbitrary
        # datatype for the empty set
 #eturn "SELECT %s WHERE 1!=1" % (
 #, ".join(
 #CAST(NULL AS %s)"
 # self.dialect.type_compiler.process(
 #NTEGER() if type_._isnull else type_
 #
 #or type_ in element_types or [INTEGER()]
 #,
 #

 #ef render_literal_value(self, value, type_):
 #alue = super(PGCompiler, self).render_literal_value(value, type_)

 #f self.dialect._backslash_escapes:
 #alue = value.replace("\\", "\\\\")
 #eturn value

 #ef visit_sequence(self, seq, **kw):
 #eturn "nextval('%s')" % self.preparer.format_sequence(seq)

 #ef limit_clause(self, select, **kw):
 #ext = ""
 #f select._limit_clause is not None:
 #ext += " \n LIMIT " + self.process(select._limit_clause, **kw)
 #f select._offset_clause is not None:
 #f select._limit_clause is None:
 #ext += "\n LIMIT ALL"
 #ext += " OFFSET " + self.process(select._offset_clause, **kw)
 #eturn text

 #ef format_from_hint_text(self, sqltext, table, hint, iscrud):
 #f hint.upper() != "ONLY":
 #aise exc.CompileError("Unrecognized hint: %r" % hint)
 #eturn "ONLY " + sqltext

 #ef get_select_precolumns(self, select, **kw):
        # Do not call super().get_select_precolumns because
        # it will warn/raise when distinct on is present
 #f select._distinct or select._distinct_on:
 #f select._distinct_on:
 #eturn (
 #DISTINCT ON ("
 # ", ".join(
 #
 #elf.process(col, **kw)
 #or col in select._distinct_on
 #
 #
 # ") "
 #
 #lse:
 #eturn "DISTINCT "
 #lse:
 #eturn ""

 #ef for_update_clause(self, select, **kw):

 #f select._for_update_arg.read:
 #f select._for_update_arg.key_share:
 #mp = " FOR KEY SHARE"
 #lse:
 #mp = " FOR SHARE"
 #lif select._for_update_arg.key_share:
 #mp = " FOR NO KEY UPDATE"
 #lse:
 #mp = " FOR UPDATE"

 #f select._for_update_arg.of:

 #ables = util.OrderedSet()
 #or c in select._for_update_arg.of:
 #ables.update(sql_util.surface_selectables_only(c))

 #mp += " OF " + ", ".join(
 #elf.process(table, ashint=True, use_schema=False, **kw)
 #or table in tables
 #

 #f select._for_update_arg.nowait:
 #mp += " NOWAIT"
 #f select._for_update_arg.skip_locked:
 #mp += " SKIP LOCKED"

 #eturn tmp

 #ef returning_clause(self, stmt, returning_cols):

 #olumns = [
 #elf._label_returning_column(stmt, c)
 #or c in expression._select_iterables(returning_cols)
 #

 #eturn "RETURNING " + ", ".join(columns)

 #ef visit_substring_func(self, func, **kw):
 # = self.process(func.clauses.clauses[0], **kw)
 #tart = self.process(func.clauses.clauses[1], **kw)
 #f len(func.clauses.clauses) > 2:
 #ength = self.process(func.clauses.clauses[2], **kw)
 #eturn "SUBSTRING(%s FROM %s FOR %s)" % (s, start, length)
 #lse:
 #eturn "SUBSTRING(%s FROM %s)" % (s, start)

 #ef _on_conflict_target(self, clause, **kw):

 #f clause.constraint_target is not None:
            # target may be a name of an Index, UniqueConstraint or
            # ExcludeConstraint.  While there is a separate
            # "max_identifier_length" for indexes, PostgreSQL uses the same
            # length for all objects so we can use
            # truncate_and_render_constraint_name
 #arget_text = (
 #ON CONSTRAINT %s"
 # self.preparer.truncate_and_render_constraint_name(
 #lause.constraint_target
 #
 #
 #lif clause.inferred_target_elements is not None:
 #arget_text = "(%s)" % ", ".join(
 #
 #elf.preparer.quote(c)
 #f isinstance(c, util.string_types)
 #lse self.process(c, include_table=False, use_schema=False)
 #
 #or c in clause.inferred_target_elements
 #
 #f clause.inferred_target_whereclause is not None:
 #arget_text += " WHERE %s" % self.process(
 #lause.inferred_target_whereclause,
 #nclude_table=False,
 #se_schema=False,
 #
 #lse:
 #arget_text = ""

 #eturn target_text

 #ef visit_on_conflict_do_nothing(self, on_conflict, **kw):

 #arget_text = self._on_conflict_target(on_conflict, **kw)

 #f target_text:
 #eturn "ON CONFLICT %s DO NOTHING" % target_text
 #lse:
 #eturn "ON CONFLICT DO NOTHING"

 #ef visit_on_conflict_do_update(self, on_conflict, **kw):

 #lause = on_conflict

 #arget_text = self._on_conflict_target(on_conflict, **kw)

 #ction_set_ops = []

 #et_parameters = dict(clause.update_values_to_set)
        # create a list of column assignment clauses as tuples

 #nsert_statement = self.stack[-1]["selectable"]
 #ols = insert_statement.table.c
 #or c in cols:
 #ol_key = c.key

 #f col_key in set_parameters:
 #alue = set_parameters.pop(col_key)
 #lif c in set_parameters:
 #alue = set_parameters.pop(c)
 #lse:
 #ontinue

 #f coercions._is_literal(value):
 #alue = elements.BindParameter(None, value, type_=c.type)

 #lse:
 #f (
 #sinstance(value, elements.BindParameter)
 #nd value.type._isnull
 #:
 #alue = value._clone()
 #alue.type = c.type
 #alue_text = self.process(value.self_group(), use_schema=False)

 #ey_text = self.preparer.quote(col_key)
 #ction_set_ops.append("%s = %s" % (key_text, value_text))

        # check for names that don't match columns
 #f set_parameters:
 #til.warn(
 #Additional column names not matching "
 #any column keys in table '%s': %s"
 # (
 #elf.current_executable.table.name,
 #", ".join("'%s'" % c for c in set_parameters)),
 #
 #
 #or k, v in set_parameters.items():
 #ey_text = (
 #elf.preparer.quote(k)
 #f isinstance(k, util.string_types)
 #lse self.process(k, use_schema=False)
 #
 #alue_text = self.process(
 #oercions.expect(roles.ExpressionElementRole, v),
 #se_schema=False,
 #
 #ction_set_ops.append("%s = %s" % (key_text, value_text))

 #ction_text = ", ".join(action_set_ops)
 #f clause.update_whereclause is not None:
 #ction_text += " WHERE %s" % self.process(
 #lause.update_whereclause, include_table=True, use_schema=False
 #

 #eturn "ON CONFLICT %s DO UPDATE SET %s" % (target_text, action_text)

 #ef update_from_clause(
 #elf, update_stmt, from_table, extra_froms, from_hints, **kw
 #:
 #w["asfrom"] = True
 #eturn "FROM " + ", ".join(
 #._compiler_dispatch(self, fromhints=from_hints, **kw)
 #or t in extra_froms
 #

 #ef delete_extra_from_clause(
 #elf, delete_stmt, from_table, extra_froms, from_hints, **kw
 #:
 #""Render the DELETE .. USING clause specific to PostgreSQL."""
 #w["asfrom"] = True
 #eturn "USING " + ", ".join(
 #._compiler_dispatch(self, fromhints=from_hints, **kw)
 #or t in extra_froms
 #

 #ef fetch_clause(self, select, **kw):
        # pg requires parens for non literal clauses. It's also required for
        # bind parameters if a ::type casts is used by the driver (asyncpg),
        # so it's easiest to just always add it
 #ext = ""
 #f select._offset_clause is not None:
 #ext += "\n OFFSET (%s) ROWS" % self.process(
 #elect._offset_clause, **kw
 #
 #f select._fetch_clause is not None:
 #ext += "\n FETCH FIRST (%s)%s ROWS %s" % (
 #elf.process(select._fetch_clause, **kw),
 # PERCENT" if select._fetch_clause_options["percent"] else "",
 #WITH TIES"
 #f select._fetch_clause_options["with_ties"]
 #lse "ONLY",
 #
 #eturn text


class PGDDLCompiler(compiler.DDLCompiler):
 #ef get_column_specification(self, column, **kwargs):

 #olspec = self.preparer.format_column(column)
 #mpl_type = column.type.dialect_impl(self.dialect)
 #f isinstance(impl_type, sqltypes.TypeDecorator):
 #mpl_type = impl_type.impl

 #as_identity = (
 #olumn.identity is not None
 #nd self.dialect.supports_identity_columns
 #

 #f (
 #olumn.primary_key
 #nd column is column.table._autoincrement_column
 #nd (
 #elf.dialect.supports_smallserial
 #r not isinstance(impl_type, sqltypes.SmallInteger)
 #
 #nd not has_identity
 #nd (
 #olumn.default is None
 #r (
 #sinstance(column.default, schema.Sequence)
 #nd column.default.optional
 #
 #
 #:
 #f isinstance(impl_type, sqltypes.BigInteger):
 #olspec += " BIGSERIAL"
 #lif isinstance(impl_type, sqltypes.SmallInteger):
 #olspec += " SMALLSERIAL"
 #lse:
 #olspec += " SERIAL"
 #lse:
 #olspec += " " + self.dialect.type_compiler.process(
 #olumn.type,
 #ype_expression=column,
 #dentifier_preparer=self.preparer,
 #
 #efault = self.get_column_default_string(column)
 #f default is not None:
 #olspec += " DEFAULT " + default

 #f column.computed is not None:
 #olspec += " " + self.process(column.computed)
 #f has_identity:
 #olspec += " " + self.process(column.identity)

 #f not column.nullable and not has_identity:
 #olspec += " NOT NULL"
 #lif column.nullable and has_identity:
 #olspec += " NULL"
 #eturn colspec

 #ef visit_check_constraint(self, constraint):
 #f constraint._type_bound:
 #yp = list(constraint.columns)[0].type
 #f (
 #sinstance(typ, sqltypes.ARRAY)
 #nd isinstance(typ.item_type, sqltypes.Enum)
 #nd not typ.item_type.native_enum
 #:
 #aise exc.CompileError(
 #PostgreSQL dialect cannot produce the CHECK constraint "
 #for ARRAY of non-native ENUM; please specify "
 #create_constraint=False on this Enum datatype."
 #

 #eturn super(PGDDLCompiler, self).visit_check_constraint(constraint)

 #ef visit_drop_table_comment(self, drop):
 #eturn "COMMENT ON TABLE %s IS NULL" % self.preparer.format_table(
 #rop.element
 #

 #ef visit_create_enum_type(self, create):
 #ype_ = create.element

 #eturn "CREATE TYPE %s AS ENUM (%s)" % (
 #elf.preparer.format_type(type_),
 #, ".join(
 #elf.sql_compiler.process(sql.literal(e), literal_binds=True)
 #or e in type_.enums
 #,
 #

 #ef visit_drop_enum_type(self, drop):
 #ype_ = drop.element

 #eturn "DROP TYPE %s" % (self.preparer.format_type(type_))

 #ef visit_create_index(self, create):
 #reparer = self.preparer
 #ndex = create.element
 #elf._verify_index_table(index)
 #ext = "CREATE "
 #f index.unique:
 #ext += "UNIQUE "
 #ext += "INDEX "

 #f self.dialect._supports_create_index_concurrently:
 #oncurrently = index.dialect_options["postgresql"]["concurrently"]
 #f concurrently:
 #ext += "CONCURRENTLY "

 #f create.if_not_exists:
 #ext += "IF NOT EXISTS "

 #ext += "%s ON %s " % (
 #elf._prepared_index_name(index, include_schema=False),
 #reparer.format_table(index.table),
 #

 #sing = index.dialect_options["postgresql"]["using"]
 #f using:
 #ext += (
 #USING %s "
 # self.preparer.validate_sql_phrase(using, IDX_USING).lower()
 #

 #ps = index.dialect_options["postgresql"]["ops"]
 #ext += "(%s)" % (
 #, ".join(
 #
 #elf.sql_compiler.process(
 #xpr.self_group()
 #f not isinstance(expr, expression.ColumnClause)
 #lse expr,
 #nclude_table=False,
 #iteral_binds=True,
 #
 # (
 #" " + ops[expr.key])
 #f hasattr(expr, "key") and expr.key in ops
 #lse ""
 #
 #or expr in index.expressions
 #
 #
 #

 #ncludeclause = index.dialect_options["postgresql"]["include"]
 #f includeclause:
 #nclusions = [
 #ndex.table.c[col]
 #f isinstance(col, util.string_types)
 #lse col
 #or col in includeclause
 #
 #ext += " INCLUDE (%s)" % ", ".join(
 #preparer.quote(c.name) for c in inclusions]
 #

 #ithclause = index.dialect_options["postgresql"]["with"]
 #f withclause:
 #ext += " WITH (%s)" % (
 #, ".join(
 #
 #%s = %s" % storage_parameter
 #or storage_parameter in withclause.items()
 #
 #
 #

 #ablespace_name = index.dialect_options["postgresql"]["tablespace"]
 #f tablespace_name:
 #ext += " TABLESPACE %s" % preparer.quote(tablespace_name)

 #hereclause = index.dialect_options["postgresql"]["where"]
 #f whereclause is not None:
 #hereclause = coercions.expect(
 #oles.DDLExpressionRole, whereclause
 #

 #here_compiled = self.sql_compiler.process(
 #hereclause, include_table=False, literal_binds=True
 #
 #ext += " WHERE " + where_compiled

 #eturn text

 #ef visit_drop_index(self, drop):
 #ndex = drop.element

 #ext = "\nDROP INDEX "

 #f self.dialect._supports_drop_index_concurrently:
 #oncurrently = index.dialect_options["postgresql"]["concurrently"]
 #f concurrently:
 #ext += "CONCURRENTLY "

 #f drop.if_exists:
 #ext += "IF EXISTS "

 #ext += self._prepared_index_name(index, include_schema=True)
 #eturn text

 #ef visit_exclude_constraint(self, constraint, **kw):
 #ext = ""
 #f constraint.name is not None:
 #ext += "CONSTRAINT %s " % self.preparer.format_constraint(
 #onstraint
 #
 #lements = []
 #or expr, name, op in constraint._render_exprs:
 #w["include_table"] = False
 #xclude_element = self.sql_compiler.process(expr, **kw) + (
 #" " + constraint.ops[expr.key])
 #f hasattr(expr, "key") and expr.key in constraint.ops
 #lse ""
 #

 #lements.append("%s WITH %s" % (exclude_element, op))
 #ext += "EXCLUDE USING %s (%s)" % (
 #elf.preparer.validate_sql_phrase(
 #onstraint.using, IDX_USING
 #.lower(),
 #, ".join(elements),
 #
 #f constraint.where is not None:
 #ext += " WHERE (%s)" % self.sql_compiler.process(
 #onstraint.where, literal_binds=True
 #
 #ext += self.define_constraint_deferrability(constraint)
 #eturn text

 #ef post_create_table(self, table):
 #able_opts = []
 #g_opts = table.dialect_options["postgresql"]

 #nherits = pg_opts.get("inherits")
 #f inherits is not None:
 #f not isinstance(inherits, (list, tuple)):
 #nherits = (inherits,)
 #able_opts.append(
 #\n INHERITS ( "
 # ", ".join(self.preparer.quote(name) for name in inherits)
 # " )"
 #

 #f pg_opts["partition_by"]:
 #able_opts.append("\n PARTITION BY %s" % pg_opts["partition_by"])

 #f pg_opts["with_oids"] is True:
 #able_opts.append("\n WITH OIDS")
 #lif pg_opts["with_oids"] is False:
 #able_opts.append("\n WITHOUT OIDS")

 #f pg_opts["on_commit"]:
 #n_commit_options = pg_opts["on_commit"].replace("_", " ").upper()
 #able_opts.append("\n ON COMMIT %s" % on_commit_options)

 #f pg_opts["tablespace"]:
 #ablespace_name = pg_opts["tablespace"]
 #able_opts.append(
 #\n TABLESPACE %s" % self.preparer.quote(tablespace_name)
 #

 #eturn "".join(table_opts)

 #ef visit_computed_column(self, generated):
 #f generated.persisted is False:
 #aise exc.CompileError(
 #PostrgreSQL computed columns do not support 'virtual' "
 #persistence; set the 'persisted' flag to None or True for "
 #PostgreSQL support."
 #

 #eturn "GENERATED ALWAYS AS (%s) STORED" % self.sql_compiler.process(
 #enerated.sqltext, include_table=False, literal_binds=True
 #

 #ef visit_create_sequence(self, create, **kw):
 #refix = None
 #f create.element.data_type is not None:
 #refix = " AS %s" % self.type_compiler.process(
 #reate.element.data_type
 #

 #eturn super(PGDDLCompiler, self).visit_create_sequence(
 #reate, prefix=prefix, **kw
 #


class PGTypeCompiler(compiler.GenericTypeCompiler):
 #ef visit_TSVECTOR(self, type_, **kw):
 #eturn "TSVECTOR"

 #ef visit_INET(self, type_, **kw):
 #eturn "INET"

 #ef visit_CIDR(self, type_, **kw):
 #eturn "CIDR"

 #ef visit_MACADDR(self, type_, **kw):
 #eturn "MACADDR"

 #ef visit_MONEY(self, type_, **kw):
 #eturn "MONEY"

 #ef visit_OID(self, type_, **kw):
 #eturn "OID"

 #ef visit_REGCLASS(self, type_, **kw):
 #eturn "REGCLASS"

 #ef visit_FLOAT(self, type_, **kw):
 #f not type_.precision:
 #eturn "FLOAT"
 #lse:
 #eturn "FLOAT(%(precision)s)" % {"precision": type_.precision}

 #ef visit_DOUBLE_PRECISION(self, type_, **kw):
 #eturn "DOUBLE PRECISION"

 #ef visit_BIGINT(self, type_, **kw):
 #eturn "BIGINT"

 #ef visit_HSTORE(self, type_, **kw):
 #eturn "HSTORE"

 #ef visit_JSON(self, type_, **kw):
 #eturn "JSON"

 #ef visit_JSONB(self, type_, **kw):
 #eturn "JSONB"

 #ef visit_INT4RANGE(self, type_, **kw):
 #eturn "INT4RANGE"

 #ef visit_INT8RANGE(self, type_, **kw):
 #eturn "INT8RANGE"

 #ef visit_NUMRANGE(self, type_, **kw):
 #eturn "NUMRANGE"

 #ef visit_DATERANGE(self, type_, **kw):
 #eturn "DATERANGE"

 #ef visit_TSRANGE(self, type_, **kw):
 #eturn "TSRANGE"

 #ef visit_TSTZRANGE(self, type_, **kw):
 #eturn "TSTZRANGE"

 #ef visit_datetime(self, type_, **kw):
 #eturn self.visit_TIMESTAMP(type_, **kw)

 #ef visit_enum(self, type_, **kw):
 #f not type_.native_enum or not self.dialect.supports_native_enum:
 #eturn super(PGTypeCompiler, self).visit_enum(type_, **kw)
 #lse:
 #eturn self.visit_ENUM(type_, **kw)

 #ef visit_ENUM(self, type_, identifier_preparer=None, **kw):
 #f identifier_preparer is None:
 #dentifier_preparer = self.dialect.identifier_preparer
 #eturn identifier_preparer.format_type(type_)

 #ef visit_TIMESTAMP(self, type_, **kw):
 #eturn "TIMESTAMP%s %s" % (
 #(%d)" % type_.precision
 #f getattr(type_, "precision", None) is not None
 #lse "",
 #type_.timezone and "WITH" or "WITHOUT") + " TIME ZONE",
 #

 #ef visit_TIME(self, type_, **kw):
 #eturn "TIME%s %s" % (
 #(%d)" % type_.precision
 #f getattr(type_, "precision", None) is not None
 #lse "",
 #type_.timezone and "WITH" or "WITHOUT") + " TIME ZONE",
 #

 #ef visit_INTERVAL(self, type_, **kw):
 #ext = "INTERVAL"
 #f type_.fields is not None:
 #ext += " " + type_.fields
 #f type_.precision is not None:
 #ext += " (%d)" % type_.precision
 #eturn text

 #ef visit_BIT(self, type_, **kw):
 #f type_.varying:
 #ompiled = "BIT VARYING"
 #f type_.length is not None:
 #ompiled += "(%d)" % type_.length
 #lse:
 #ompiled = "BIT(%d)" % type_.length
 #eturn compiled

 #ef visit_UUID(self, type_, **kw):
 #eturn "UUID"

 #ef visit_large_binary(self, type_, **kw):
 #eturn self.visit_BYTEA(type_, **kw)

 #ef visit_BYTEA(self, type_, **kw):
 #eturn "BYTEA"

 #ef visit_ARRAY(self, type_, **kw):

 #nner = self.process(type_.item_type, **kw)
 #eturn re.sub(
 #"((?: COLLATE.*)?)$",
 #
 #"%s\1"
 # (
 #[]"
 # (type_.dimensions if type_.dimensions is not None else 1)
 #
 #,
 #nner,
 #ount=1,
 #


class PGIdentifierPreparer(compiler.IdentifierPreparer):

 #eserved_words = RESERVED_WORDS

 #ef _unquote_identifier(self, value):
 #f value[0] == self.initial_quote:
 #alue = value[1:-1].replace(
 #elf.escape_to_quote, self.escape_quote
 #
 #eturn value

 #ef format_type(self, type_, use_schema=True):
 #f not type_.name:
 #aise exc.CompileError("PostgreSQL ENUM type requires a name.")

 #ame = self.quote(type_.name)
 #ffective_schema = self.schema_for_object(type_)

 #f (
 #ot self.omit_schema
 #nd use_schema
 #nd effective_schema is not None
 #:
 #ame = self.quote_schema(effective_schema) + "." + name
 #eturn name


class PGInspector(reflection.Inspector):
 #ef get_table_oid(self, table_name, schema=None):
 #""Return the OID for the given table name."""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_table_oid(
 #onn, table_name, schema, info_cache=self.info_cache
 #

 #ef get_enums(self, schema=None):
 #""Return a list of ENUM objects.

 #ach member is a dictionary containing these fields:

 # name - name of the enum
 # schema - the schema name for the enum.
 # visible - boolean, whether or not this enum is visible
 #n the default search path.
 # labels - a list of string labels that apply to the enum.

 #param schema: schema name.  If None, the default schema
 #typically 'public') is used.  May also be set to '*' to
 #ndicate load enums for all schemas.

 #. versionadded:: 1.0.0

 #""
 #chema = schema or self.default_schema_name
 #ith self._operation_context() as conn:
 #eturn self.dialect._load_enums(conn, schema)

 #ef get_foreign_table_names(self, schema=None):
 #""Return a list of FOREIGN TABLE names.

 #ehavior is similar to that of
 #meth:`_reflection.Inspector.get_table_names`,
 #xcept that the list is limited to those tables that report a
 #`relkind`` value of ``f``.

 #. versionadded:: 1.0.0

 #""
 #chema = schema or self.default_schema_name
 #ith self._operation_context() as conn:
 #eturn self.dialect._get_foreign_table_names(conn, schema)

 #ef get_view_names(self, schema=None, include=("plain", "materialized")):
 #""Return all view names in `schema`.

 #param schema: Optional, retrieve names from a non-default schema.
 #or special quoting, use :class:`.quoted_name`.

 #param include: specify which types of views to return.  Passed
 #s a string value (for a single type) or a tuple (for any number
 #f types).  Defaults to ``('plain', 'materialized')``.

 #. versionadded:: 1.1

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_view_names(
 #onn, schema, info_cache=self.info_cache, include=include
 #


class CreateEnumType(schema._CreateDropBase):
 #_visit_name__ = "create_enum_type"


class DropEnumType(schema._CreateDropBase):
 #_visit_name__ = "drop_enum_type"


class PGExecutionContext(default.DefaultExecutionContext):
 #ef fire_sequence(self, seq, type_):
 #eturn self._execute_scalar(
 #
 #select nextval('%s')"
 # self.identifier_preparer.format_sequence(seq)
 #,
 #ype_,
 #

 #ef get_insert_default(self, column):
 #f column.primary_key and column is column.table._autoincrement_column:
 #f column.server_default and column.server_default.has_argument:

                # pre-execute passive defaults on primary key columns
 #eturn self._execute_scalar(
 #select %s" % column.server_default.arg, column.type
 #

 #lif column.default is None or (
 #olumn.default.is_sequence and column.default.optional
 #:
                # execute the sequence associated with a SERIAL primary
                # key column. for non-primary-key SERIAL, the ID just
                # generates server side.

 #ry:
 #eq_name = column._postgresql_seq_name
 #xcept AttributeError:
 #ab = column.table.name
 #ol = column.name
 #ab = tab[0 : 29 + max(0, (29 - len(col)))]
 #ol = col[0 : 29 + max(0, (29 - len(tab)))]
 #ame = "%s_%s_seq" % (tab, col)
 #olumn._postgresql_seq_name = seq_name = name

 #f column.table is not None:
 #ffective_schema = self.connection.schema_for_object(
 #olumn.table
 #
 #lse:
 #ffective_schema = None

 #f effective_schema is not None:
 #xc = 'select nextval(\'"%s"."%s"\')' % (
 #ffective_schema,
 #eq_name,
 #
 #lse:
 #xc = "select nextval('\"%s\"')" % (seq_name,)

 #eturn self._execute_scalar(exc, column.type)

 #eturn super(PGExecutionContext, self).get_insert_default(column)

 #ef should_autocommit_text(self, statement):
 #eturn AUTOCOMMIT_REGEXP.match(statement)


class PGReadOnlyConnectionCharacteristic(
 #haracteristics.ConnectionCharacteristic
):
 #ransactional = True

 #ef reset_characteristic(self, dialect, dbapi_conn):
 #ialect.set_readonly(dbapi_conn, False)

 #ef set_characteristic(self, dialect, dbapi_conn, value):
 #ialect.set_readonly(dbapi_conn, value)

 #ef get_characteristic(self, dialect, dbapi_conn):
 #eturn dialect.get_readonly(dbapi_conn)


class PGDeferrableConnectionCharacteristic(
 #haracteristics.ConnectionCharacteristic
):
 #ransactional = True

 #ef reset_characteristic(self, dialect, dbapi_conn):
 #ialect.set_deferrable(dbapi_conn, False)

 #ef set_characteristic(self, dialect, dbapi_conn, value):
 #ialect.set_deferrable(dbapi_conn, value)

 #ef get_characteristic(self, dialect, dbapi_conn):
 #eturn dialect.get_deferrable(dbapi_conn)


class PGDialect(default.DefaultDialect):
 #ame = "postgresql"
 #upports_statement_cache = True
 #upports_alter = True
 #ax_identifier_length = 63
 #upports_sane_rowcount = True

 #upports_native_enum = True
 #upports_native_boolean = True
 #upports_smallserial = True

 #upports_sequences = True
 #equences_optional = True
 #reexecute_autoincrement_sequences = True
 #ostfetch_lastrowid = False

 #upports_comments = True
 #upports_default_values = True

 #upports_default_metavalue = True

 #upports_empty_insert = False
 #upports_multivalues_insert = True
 #upports_identity_columns = True

 #efault_paramstyle = "pyformat"
 #schema_names = ischema_names
 #olspecs = colspecs

 #tatement_compiler = PGCompiler
 #dl_compiler = PGDDLCompiler
 #ype_compiler = PGTypeCompiler
 #reparer = PGIdentifierPreparer
 #xecution_ctx_cls = PGExecutionContext
 #nspector = PGInspector
 #solation_level = None

 #mplicit_returning = True
 #ull_returning = True

 #onnection_characteristics = (
 #efault.DefaultDialect.connection_characteristics
 #
 #onnection_characteristics = connection_characteristics.union(
 #
 #postgresql_readonly": PGReadOnlyConnectionCharacteristic(),
 #postgresql_deferrable": PGDeferrableConnectionCharacteristic(),
 #
 #

 #onstruct_arguments = [
 #
 #chema.Index,
 #
 #using": False,
 #include": None,
 #where": None,
 #ops": {},
 #concurrently": False,
 #with": {},
 #tablespace": None,
 #,
 #,
 #
 #chema.Table,
 #
 #ignore_search_path": False,
 #tablespace": None,
 #partition_by": None,
 #with_oids": None,
 #on_commit": None,
 #inherits": None,
 #,
 #,
 #

 #eflection_options = ("postgresql_ignore_search_path",)

 #backslash_escapes = True
 #supports_create_index_concurrently = True
 #supports_drop_index_concurrently = True

 #ef __init__(
 #elf,
 #solation_level=None,
 #son_serializer=None,
 #son_deserializer=None,
 #*kwargs
 #:
 #efault.DefaultDialect.__init__(self, **kwargs)

        # the isolation_level parameter to the PGDialect itself is legacy.
        # still works however the execution_options method is the one that
        # is documented.
 #elf.isolation_level = isolation_level
 #elf._json_deserializer = json_deserializer
 #elf._json_serializer = json_serializer

 #ef initialize(self, connection):
 #uper(PGDialect, self).initialize(connection)

 #f self.server_version_info <= (8, 2):
 #elf.full_returning = self.implicit_returning = False

 #elf.supports_native_enum = self.server_version_info >= (8, 3)
 #f not self.supports_native_enum:
 #elf.colspecs = self.colspecs.copy()
            # pop base Enum type
 #elf.colspecs.pop(sqltypes.Enum, None)
            # psycopg2, others may have placed ENUM here as well
 #elf.colspecs.pop(ENUM, None)

        # https://www.postgresql.org/docs/9.3/static/release-9-2.html#AEN116689
 #elf.supports_smallserial = self.server_version_info >= (9, 2)

 #f self.server_version_info < (8, 2):
 #elf._backslash_escapes = False
 #lse:
            # ensure this query is not emitted on server version < 8.2
            # as it will fail
 #td_string = connection.exec_driver_sql(
 #show standard_conforming_strings"
 #.scalar()
 #elf._backslash_escapes = std_string == "off"

 #elf._supports_create_index_concurrently = (
 #elf.server_version_info >= (8, 2)
 #
 #elf._supports_drop_index_concurrently = self.server_version_info >= (
 #,
 #,
 #
 #elf.supports_identity_columns = self.server_version_info >= (10,)

 #ef on_connect(self):
 #f self.isolation_level is not None:

 #ef connect(conn):
 #elf.set_isolation_level(conn, self.isolation_level)

 #eturn connect
 #lse:
 #eturn None

 #isolation_lookup = set(
 #
 #SERIALIZABLE",
 #READ UNCOMMITTED",
 #READ COMMITTED",
 #REPEATABLE READ",
 #
 #

 #ef set_isolation_level(self, connection, level):
 #evel = level.replace("_", " ")
 #f level not in self._isolation_lookup:
 #aise exc.ArgumentError(
 #Invalid value '%s' for isolation_level. "
 #Valid isolation levels for %s are %s"
 # (level, self.name, ", ".join(self._isolation_lookup))
 #
 #ursor = connection.cursor()
 #ursor.execute(
 #SET SESSION CHARACTERISTICS AS TRANSACTION "
 #ISOLATION LEVEL %s" % level
 #
 #ursor.execute("COMMIT")
 #ursor.close()

 #ef get_isolation_level(self, connection):
 #ursor = connection.cursor()
 #ursor.execute("show transaction isolation level")
 #al = cursor.fetchone()[0]
 #ursor.close()
 #eturn val.upper()

 #ef set_readonly(self, connection, value):
 #aise NotImplementedError()

 #ef get_readonly(self, connection):
 #aise NotImplementedError()

 #ef set_deferrable(self, connection, value):
 #aise NotImplementedError()

 #ef get_deferrable(self, connection):
 #aise NotImplementedError()

 #ef do_begin_twophase(self, connection, xid):
 #elf.do_begin(connection.connection)

 #ef do_prepare_twophase(self, connection, xid):
 #onnection.exec_driver_sql("PREPARE TRANSACTION '%s'" % xid)

 #ef do_rollback_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:
 #f is_prepared:
 #f recover:
                # FIXME: ugly hack to get out of transaction
                # context when committing recoverable transactions
                # Must find out a way how to make the dbapi not
                # open a transaction.
 #onnection.exec_driver_sql("ROLLBACK")
 #onnection.exec_driver_sql("ROLLBACK PREPARED '%s'" % xid)
 #onnection.exec_driver_sql("BEGIN")
 #elf.do_rollback(connection.connection)
 #lse:
 #elf.do_rollback(connection.connection)

 #ef do_commit_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:
 #f is_prepared:
 #f recover:
 #onnection.exec_driver_sql("ROLLBACK")
 #onnection.exec_driver_sql("COMMIT PREPARED '%s'" % xid)
 #onnection.exec_driver_sql("BEGIN")
 #elf.do_rollback(connection.connection)
 #lse:
 #elf.do_commit(connection.connection)

 #ef do_recover_twophase(self, connection):
 #esultset = connection.execute(
 #ql.text("SELECT gid FROM pg_prepared_xacts")
 #
 #eturn [row[0] for row in resultset]

 #ef _get_default_schema_name(self, connection):
 #eturn connection.exec_driver_sql("select current_schema()").scalar()

 #ef has_schema(self, connection, schema):
 #uery = (
 #select nspname from pg_namespace " "where lower(nspname)=:schema"
 #
 #ursor = connection.execute(
 #ql.text(query).bindparams(
 #ql.bindparam(
 #schema",
 #til.text_type(schema.lower()),
 #ype_=sqltypes.Unicode,
 #
 #
 #

 #eturn bool(cursor.first())

 #ef has_table(self, connection, table_name, schema=None):
 #elf._ensure_has_table_connection(connection)
        # seems like case gets folded in pg_class...
 #f schema is None:
 #ursor = connection.execute(
 #ql.text(
 #select relname from pg_class c join pg_namespace n on "
 #n.oid=c.relnamespace where "
 #pg_catalog.pg_table_is_visible(c.oid) "
 #and relname=:name"
 #.bindparams(
 #ql.bindparam(
 #name",
 #til.text_type(table_name),
 #ype_=sqltypes.Unicode,
 #
 #
 #
 #lse:
 #ursor = connection.execute(
 #ql.text(
 #select relname from pg_class c join pg_namespace n on "
 #n.oid=c.relnamespace where n.nspname=:schema and "
 #relname=:name"
 #.bindparams(
 #ql.bindparam(
 #name",
 #til.text_type(table_name),
 #ype_=sqltypes.Unicode,
 #,
 #ql.bindparam(
 #schema",
 #til.text_type(schema),
 #ype_=sqltypes.Unicode,
 #,
 #
 #
 #eturn bool(cursor.first())

 #ef has_sequence(self, connection, sequence_name, schema=None):
 #f schema is None:
 #chema = self.default_schema_name
 #ursor = connection.execute(
 #ql.text(
 #SELECT relname FROM pg_class c join pg_namespace n on "
 #n.oid=c.relnamespace where relkind='S' and "
 #n.nspname=:schema and relname=:name"
 #.bindparams(
 #ql.bindparam(
 #name",
 #til.text_type(sequence_name),
 #ype_=sqltypes.Unicode,
 #,
 #ql.bindparam(
 #schema",
 #til.text_type(schema),
 #ype_=sqltypes.Unicode,
 #,
 #
 #

 #eturn bool(cursor.first())

 #ef has_type(self, connection, type_name, schema=None):
 #f schema is not None:
 #uery = """
 #ELECT EXISTS (
 #ELECT * FROM pg_catalog.pg_type t, pg_catalog.pg_namespace n
 #HERE t.typnamespace = n.oid
 #ND t.typname = :typname
 #ND n.nspname = :nspname
 #
 #""
 #uery = sql.text(query)
 #lse:
 #uery = """
 #ELECT EXISTS (
 #ELECT * FROM pg_catalog.pg_type t
 #HERE t.typname = :typname
 #ND pg_type_is_visible(t.oid)
 #
 #""
 #uery = sql.text(query)
 #uery = query.bindparams(
 #ql.bindparam(
 #typname", util.text_type(type_name), type_=sqltypes.Unicode
 #
 #
 #f schema is not None:
 #uery = query.bindparams(
 #ql.bindparam(
 #nspname", util.text_type(schema), type_=sqltypes.Unicode
 #
 #
 #ursor = connection.execute(query)
 #eturn bool(cursor.scalar())

 #ef _get_server_version_info(self, connection):
 # = connection.exec_driver_sql("select version()").scalar()
 # = re.match(
 #".*(?:PostgreSQL|EnterpriseDB) "
 #"(\d+)\.?(\d+)?(?:\.(\d+))?(?:\.\d+)?(?:devel|beta)?",
 #,
 #
 #f not m:
 #aise AssertionError(
 #Could not determine version from string '%s'" % v
 #
 #eturn tuple([int(x) for x in m.group(1, 2, 3) if x is not None])

 #reflection.cache
 #ef get_table_oid(self, connection, table_name, schema=None, **kw):
 #""Fetch the oid for schema.table_name.

 #everal reflection methods require the table oid.  The idea for using
 #his method is that it can be fetched one time and cached for
 #ubsequent calls.

 #""
 #able_oid = None
 #f schema is not None:
 #chema_where_clause = "n.nspname = :schema"
 #lse:
 #chema_where_clause = "pg_catalog.pg_table_is_visible(c.oid)"
 #uery = (
 #""
 #ELECT c.oid
 #ROM pg_catalog.pg_class c
 #EFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
 #HERE (%s)
 #ND c.relname = :table_name AND c.relkind in
 #'r', 'v', 'm', 'f', 'p')
 #""
 # schema_where_clause
 #
        # Since we're binding to unicode, table_name and schema_name must be
        # unicode.
 #able_name = util.text_type(table_name)
 #f schema is not None:
 #chema = util.text_type(schema)
 # = sql.text(query).bindparams(table_name=sqltypes.Unicode)
 # = s.columns(oid=sqltypes.Integer)
 #f schema:
 # = s.bindparams(sql.bindparam("schema", type_=sqltypes.Unicode))
 # = connection.execute(s, dict(table_name=table_name, schema=schema))
 #able_oid = c.scalar()
 #f table_oid is None:
 #aise exc.NoSuchTableError(table_name)
 #eturn table_oid

 #reflection.cache
 #ef get_schema_names(self, connection, **kw):
 #esult = connection.execute(
 #ql.text(
 #SELECT nspname FROM pg_namespace "
 #WHERE nspname NOT LIKE 'pg_%' "
 #ORDER BY nspname"
 #.columns(nspname=sqltypes.Unicode)
 #
 #eturn [name for name, in result]

 #reflection.cache
 #ef get_table_names(self, connection, schema=None, **kw):
 #esult = connection.execute(
 #ql.text(
 #SELECT c.relname FROM pg_class c "
 #JOIN pg_namespace n ON n.oid = c.relnamespace "
 #WHERE n.nspname = :schema AND c.relkind in ('r', 'p')"
 #.columns(relname=sqltypes.Unicode),
 #ict(
 #chema=schema
 #f schema is not None
 #lse self.default_schema_name
 #,
 #
 #eturn [name for name, in result]

 #reflection.cache
 #ef _get_foreign_table_names(self, connection, schema=None, **kw):
 #esult = connection.execute(
 #ql.text(
 #SELECT c.relname FROM pg_class c "
 #JOIN pg_namespace n ON n.oid = c.relnamespace "
 #WHERE n.nspname = :schema AND c.relkind = 'f'"
 #.columns(relname=sqltypes.Unicode),
 #ict(
 #chema=schema
 #f schema is not None
 #lse self.default_schema_name
 #,
 #
 #eturn [name for name, in result]

 #reflection.cache
 #ef get_view_names(
 #elf, connection, schema=None, include=("plain", "materialized"), **kw
 #:

 #nclude_kind = {"plain": "v", "materialized": "m"}
 #ry:
 #inds = [include_kind[i] for i in util.to_list(include)]
 #xcept KeyError:
 #aise ValueError(
 #include %r unknown, needs to be a sequence containing "
 #one or both of 'plain' and 'materialized'" % (include,)
 #
 #f not kinds:
 #aise ValueError(
 #empty include, needs to be a sequence containing "
 #one or both of 'plain' and 'materialized'"
 #

 #esult = connection.execute(
 #ql.text(
 #SELECT c.relname FROM pg_class c "
 #JOIN pg_namespace n ON n.oid = c.relnamespace "
 #WHERE n.nspname = :schema AND c.relkind IN (%s)"
 # (", ".join("'%s'" % elem for elem in kinds))
 #.columns(relname=sqltypes.Unicode),
 #ict(
 #chema=schema
 #f schema is not None
 #lse self.default_schema_name
 #,
 #
 #eturn [name for name, in result]

 #reflection.cache
 #ef get_sequence_names(self, connection, schema=None, **kw):
 #f not schema:
 #chema = self.default_schema_name
 #ursor = connection.execute(
 #ql.text(
 #SELECT relname FROM pg_class c join pg_namespace n on "
 #n.oid=c.relnamespace where relkind='S' and "
 #n.nspname=:schema"
 #.bindparams(
 #ql.bindparam(
 #schema",
 #til.text_type(schema),
 #ype_=sqltypes.Unicode,
 #,
 #
 #
 #eturn [row[0] for row in cursor]

 #reflection.cache
 #ef get_view_definition(self, connection, view_name, schema=None, **kw):
 #iew_def = connection.scalar(
 #ql.text(
 #SELECT pg_get_viewdef(c.oid) view_def FROM pg_class c "
 #JOIN pg_namespace n ON n.oid = c.relnamespace "
 #WHERE n.nspname = :schema AND c.relname = :view_name "
 #AND c.relkind IN ('v', 'm')"
 #.columns(view_def=sqltypes.Unicode),
 #ict(
 #chema=schema
 #f schema is not None
 #lse self.default_schema_name,
 #iew_name=view_name,
 #,
 #
 #eturn view_def

 #reflection.cache
 #ef get_columns(self, connection, table_name, schema=None, **kw):

 #able_oid = self.get_table_oid(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #enerated = (
 #a.attgenerated as generated"
 #f self.server_version_info >= (12,)
 #lse "NULL as generated"
 #
 #f self.server_version_info >= (10,):
            # a.attidentity != '' is required or it will reflect also
            # serial columns as identity.
 #dentity = """\
 #SELECT json_build_object(
 #always', a.attidentity = 'a',
 #start', s.seqstart,
 #increment', s.seqincrement,
 #minvalue', s.seqmin,
 #maxvalue', s.seqmax,
 #cache', s.seqcache,
 #cycle', s.seqcycle)
 #ROM pg_catalog.pg_sequence s
 #OIN pg_catalog.pg_class c on s.seqrelid = c."oid"
 #HERE c.relkind = 'S'
 #ND a.attidentity != ''
 #ND s.seqrelid = pg_catalog.pg_get_serial_sequence(
 #.attrelid::regclass::text, a.attname
 #::regclass::oid
 # as identity_options\
 #""
 #lse:
 #dentity = "NULL as identity_options"

 #QL_COLS = """
 #ELECT a.attname,
 #g_catalog.format_type(a.atttypid, a.atttypmod),
 #
 #ELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid)
 #ROM pg_catalog.pg_attrdef d
 #HERE d.adrelid = a.attrelid AND d.adnum = a.attnum
 #ND a.atthasdef
 # AS DEFAULT,
 #.attnotnull,
 #.attrelid as table_oid,
 #gd.description as comment,
 #s,
 #s
 #ROM pg_catalog.pg_attribute a
 #EFT JOIN pg_catalog.pg_description pgd ON (
 #gd.objoid = a.attrelid AND pgd.objsubid = a.attnum)
 #HERE a.attrelid = :table_oid
 #ND a.attnum > 0 AND NOT a.attisdropped
 #RDER BY a.attnum
 #"" % (
 #enerated,
 #dentity,
 #
 # = (
 #ql.text(SQL_COLS)
 #bindparams(sql.bindparam("table_oid", type_=sqltypes.Integer))
 #columns(attname=sqltypes.Unicode, default=sqltypes.Unicode)
 #
 # = connection.execute(s, dict(table_oid=table_oid))
 #ows = c.fetchall()

        # dictionary with (name, ) if default search path or (schema, name)
        # as keys
 #omains = self._load_domains(connection)

        # dictionary with (name, ) if default search path or (schema, name)
        # as keys
 #nums = dict(
 #(rec["name"],), rec)
 #f rec["visible"]
 #lse ((rec["schema"], rec["name"]), rec)
 #or rec in self._load_enums(connection, schema="*")
 #

        # format columns
 #olumns = []

 #or (
 #ame,
 #ormat_type,
 #efault_,
 #otnull,
 #able_oid,
 #omment,
 #enerated,
 #dentity,
 # in rows:
 #olumn_info = self._get_column_info(
 #ame,
 #ormat_type,
 #efault_,
 #otnull,
 #omains,
 #nums,
 #chema,
 #omment,
 #enerated,
 #dentity,
 #
 #olumns.append(column_info)
 #eturn columns

 #ef _get_column_info(
 #elf,
 #ame,
 #ormat_type,
 #efault,
 #otnull,
 #omains,
 #nums,
 #chema,
 #omment,
 #enerated,
 #dentity,
 #:
 #ef _handle_array_type(attype):
 #eturn (
                # strip '[]' from integer[], etc.
 #e.sub(r"\[\]$", "", attype),
 #ttype.endswith("[]"),
 #

        # strip (*) from character varying(5), timestamp(5)
        # with time zone, geometry(POLYGON), etc.
 #ttype = re.sub(r"\(.*\)", "", format_type)

        # strip '[]' from integer[], etc. and check if an array
 #ttype, is_array = _handle_array_type(attype)

        # strip quotes from case sensitive enum or domain names
 #num_or_domain_key = tuple(util.quoted_token_parser(attype))

 #ullable = not notnull

 #harlen = re.search(r"\(([\d,]+)\)", format_type)
 #f charlen:
 #harlen = charlen.group(1)
 #rgs = re.search(r"\((.*)\)", format_type)
 #f args and args.group(1):
 #rgs = tuple(re.split(r"\s*,\s*", args.group(1)))
 #lse:
 #rgs = ()
 #wargs = {}

 #f attype == "numeric":
 #f charlen:
 #rec, scale = charlen.split(",")
 #rgs = (int(prec), int(scale))
 #lse:
 #rgs = ()
 #lif attype == "double precision":
 #rgs = (53,)
 #lif attype == "integer":
 #rgs = ()
 #lif attype in ("timestamp with time zone", "time with time zone"):
 #wargs["timezone"] = True
 #f charlen:
 #wargs["precision"] = int(charlen)
 #rgs = ()
 #lif attype in (
 #timestamp without time zone",
 #time without time zone",
 #time",
 #:
 #wargs["timezone"] = False
 #f charlen:
 #wargs["precision"] = int(charlen)
 #rgs = ()
 #lif attype == "bit varying":
 #wargs["varying"] = True
 #f charlen:
 #rgs = (int(charlen),)
 #lse:
 #rgs = ()
 #lif attype.startswith("interval"):
 #ield_match = re.match(r"interval (.+)", attype, re.I)
 #f charlen:
 #wargs["precision"] = int(charlen)
 #f field_match:
 #wargs["fields"] = field_match.group(1)
 #ttype = "interval"
 #rgs = ()
 #lif charlen:
 #rgs = (int(charlen),)

 #hile True:
            # looping here to suit nested domains
 #f attype in self.ischema_names:
 #oltype = self.ischema_names[attype]
 #reak
 #lif enum_or_domain_key in enums:
 #num = enums[enum_or_domain_key]
 #oltype = ENUM
 #wargs["name"] = enum["name"]
 #f not enum["visible"]:
 #wargs["schema"] = enum["schema"]
 #rgs = tuple(enum["labels"])
 #reak
 #lif enum_or_domain_key in domains:
 #omain = domains[enum_or_domain_key]
 #ttype = domain["attype"]
 #ttype, is_array = _handle_array_type(attype)
                # strip quotes from case sensitive enum or domain names
 #num_or_domain_key = tuple(util.quoted_token_parser(attype))
                # A table can't override a not null on the domain,
                # but can override nullable
 #ullable = nullable and domain["nullable"]
 #f domain["default"] and not default:
                    # It can, however, override the default
                    # value, but can't set it to null.
 #efault = domain["default"]
 #ontinue
 #lse:
 #oltype = None
 #reak

 #f coltype:
 #oltype = coltype(*args, **kwargs)
 #f is_array:
 #oltype = self.ischema_names["_array"](coltype)
 #lse:
 #til.warn(
 #Did not recognize type '%s' of column '%s'" % (attype, name)
 #
 #oltype = sqltypes.NULLTYPE

        # If a zero byte or blank string depending on driver (is also absent
        # for older PG versions), then not a generated column. Otherwise, s =
        # stored. (Other values might be added in the future.)
 #f generated not in (None, "", b"\x00"):
 #omputed = dict(
 #qltext=default, persisted=generated in ("s", b"s")
 #
 #efault = None
 #lse:
 #omputed = None

        # adjust the default value
 #utoincrement = False
 #f default is not None:
 #atch = re.search(r"""(nextval\(')([^']+)('.*$)""", default)
 #f match is not None:
 #f issubclass(coltype._type_affinity, sqltypes.Integer):
 #utoincrement = True
                # the default is related to a Sequence
 #ch = schema
 #f "." not in match.group(2) and sch is not None:
                    # unconditionally quote the schema name.  this could
                    # later be enhanced to obey quoting rules /
                    # "quote schema"
 #efault = (
 #atch.group(1)
 # ('"%s"' % sch)
 # "."
 # match.group(2)
 # match.group(3)
 #

 #olumn_info = dict(
 #ame=name,
 #ype=coltype,
 #ullable=nullable,
 #efault=default,
 #utoincrement=autoincrement or identity is not None,
 #omment=comment,
 #
 #f computed is not None:
 #olumn_info["computed"] = computed
 #f identity is not None:
 #olumn_info["identity"] = identity
 #eturn column_info

 #reflection.cache
 #ef get_pk_constraint(self, connection, table_name, schema=None, **kw):
 #able_oid = self.get_table_oid(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #f self.server_version_info < (8, 4):
 #K_SQL = """
 #ELECT a.attname
 #ROM
 #g_class t
 #oin pg_index ix on t.oid = ix.indrelid
 #oin pg_attribute a
 #n t.oid=a.attrelid AND %s
 #HERE
 #.oid = :table_oid and ix.indisprimary = 't'
 #RDER BY a.attnum
 #"" % self._pg_index_any(
 #a.attnum", "ix.indkey"
 #

 #lse:
            # unnest() and generate_subscripts() both introduced in
            # version 8.4
 #K_SQL = """
 #ELECT a.attname
 #ROM pg_attribute a JOIN (
 #ELECT unnest(ix.indkey) attnum,
 #enerate_subscripts(ix.indkey, 1) ord
 #ROM pg_index ix
 #HERE ix.indrelid = :table_oid AND ix.indisprimary
 # k ON a.attnum=k.attnum
 #HERE a.attrelid = :table_oid
 #RDER BY k.ord
 #""
 # = sql.text(PK_SQL).columns(attname=sqltypes.Unicode)
 # = connection.execute(t, dict(table_oid=table_oid))
 #ols = [r[0] for r in c.fetchall()]

 #K_CONS_SQL = """
 #ELECT conname
 #ROM  pg_catalog.pg_constraint r
 #HERE r.conrelid = :table_oid AND r.contype = 'p'
 #RDER BY 1
 #""
 # = sql.text(PK_CONS_SQL).columns(conname=sqltypes.Unicode)
 # = connection.execute(t, dict(table_oid=table_oid))
 #ame = c.scalar()

 #eturn {"constrained_columns": cols, "name": name}

 #reflection.cache
 #ef get_foreign_keys(
 #elf,
 #onnection,
 #able_name,
 #chema=None,
 #ostgresql_ignore_search_path=False,
 #*kw
 #:
 #reparer = self.identifier_preparer
 #able_oid = self.get_table_oid(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #K_SQL = """
 #ELECT r.conname,
 #g_catalog.pg_get_constraintdef(r.oid, true) as condef,
 #.nspname as conschema
 #ROM  pg_catalog.pg_constraint r,
 #g_namespace n,
 #g_class c

 #HERE r.conrelid = :table AND
 #.contype = 'f' AND
 #.oid = confrelid AND
 #.oid = c.relnamespace
 #RDER BY 1
 #""
        # https://www.postgresql.org/docs/9.0/static/sql-createtable.html
 #K_REGEX = re.compile(
 #"FOREIGN KEY \((.*?)\) REFERENCES (?:(.*?)\.)?(.*?)\((.*?)\)"
 #"[\s]?(MATCH (FULL|PARTIAL|SIMPLE)+)?"
 #"[\s]?(ON UPDATE "
 #"(CASCADE|RESTRICT|NO ACTION|SET NULL|SET DEFAULT)+)?"
 #"[\s]?(ON DELETE "
 #"(CASCADE|RESTRICT|NO ACTION|SET NULL|SET DEFAULT)+)?"
 #"[\s]?(DEFERRABLE|NOT DEFERRABLE)?"
 #"[\s]?(INITIALLY (DEFERRED|IMMEDIATE)+)?"
 #

 # = sql.text(FK_SQL).columns(
 #onname=sqltypes.Unicode, condef=sqltypes.Unicode
 #
 # = connection.execute(t, dict(table=table_oid))
 #keys = []
 #or conname, condef, conschema in c.fetchall():
 # = re.search(FK_REGEX, condef).groups()

 #
 #onstrained_columns,
 #eferred_schema,
 #eferred_table,
 #eferred_columns,
 #,
 #atch,
 #,
 #nupdate,
 #,
 #ndelete,
 #eferrable,
 #,
 #nitially,
 # = m

 #f deferrable is not None:
 #eferrable = True if deferrable == "DEFERRABLE" else False
 #onstrained_columns = [
 #reparer._unquote_identifier(x)
 #or x in re.split(r"\s*,\s*", constrained_columns)
 #

 #f postgresql_ignore_search_path:
                # when ignoring search path, we use the actual schema
                # provided it isn't the "default" schema
 #f conschema != self.default_schema_name:
 #eferred_schema = conschema
 #lse:
 #eferred_schema = schema
 #lif referred_schema:
                # referred_schema is the schema that we regexp'ed from
                # pg_get_constraintdef().  If the schema is in the search
                # path, pg_get_constraintdef() will give us None.
 #eferred_schema = preparer._unquote_identifier(referred_schema)
 #lif schema is not None and schema == conschema:
                # If the actual schema matches the schema of the table
                # we're reflecting, then we will use that.
 #eferred_schema = schema

 #eferred_table = preparer._unquote_identifier(referred_table)
 #eferred_columns = [
 #reparer._unquote_identifier(x)
 #or x in re.split(r"\s*,\s", referred_columns)
 #
 #ptions = {
 #: v
 #or k, v in [
 #"onupdate", onupdate),
 #"ondelete", ondelete),
 #"initially", initially),
 #"deferrable", deferrable),
 #"match", match),
 #
 #f v is not None and v != "NO ACTION"
 #
 #key_d = {
 #name": conname,
 #constrained_columns": constrained_columns,
 #referred_schema": referred_schema,
 #referred_table": referred_table,
 #referred_columns": referred_columns,
 #options": options,
 #
 #keys.append(fkey_d)
 #eturn fkeys

 #ef _pg_index_any(self, col, compare_to):
 #f self.server_version_info < (8, 1):
            # https://www.postgresql.org/message-id/10279.1124395722@sss.pgh.pa.us
            # "In CVS tip you could replace this with "attnum = ANY (indkey)".
            # Unfortunately, most array support doesn't work on int2vector in
            # pre-8.1 releases, so I think you're kinda stuck with the above
            # for now.
            # regards, tom lane"
 #eturn "(%s)" % " OR ".join(
 #%s[%d] = %s" % (compare_to, ind, col) for ind in range(0, 10)
 #
 #lse:
 #eturn "%s = ANY(%s)" % (col, compare_to)

 #reflection.cache
 #ef get_indexes(self, connection, table_name, schema, **kw):
 #able_oid = self.get_table_oid(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

        # cast indkey as varchar since it's an int2vector,
        # returned as a list by some drivers such as pypostgresql

 #f self.server_version_info < (8, 5):
 #DX_SQL = """
 #ELECT
 #.relname as relname,
 #x.indisunique, ix.indexprs, ix.indpred,
 #.attname, a.attnum, NULL, ix.indkey%s,
 #s, %s, am.amname,
 #ULL as indnkeyatts
 #ROM
 #g_class t
 #oin pg_index ix on t.oid = ix.indrelid
 #oin pg_class i on i.oid = ix.indexrelid
 #eft outer join
 #g_attribute a
 #n t.oid = a.attrelid and %s
 #eft outer join
 #g_am am
 #n i.relam = am.oid
 #HERE
 #.relkind IN ('r', 'v', 'f', 'm')
 #nd t.oid = :table_oid
 #nd ix.indisprimary = 'f'
 #RDER BY
 #.relname,
 #.relname
 #"" % (
                # version 8.3 here was based on observing the
                # cast does not work in PG 8.2.4, does work in 8.3.0.
                # nothing in PG changelogs regarding this.
 #::varchar" if self.server_version_info >= (8, 3) else "",
 #ix.indoption::varchar"
 #f self.server_version_info >= (8, 3)
 #lse "NULL",
 #i.reloptions"
 #f self.server_version_info >= (8, 2)
 #lse "NULL",
 #elf._pg_index_any("a.attnum", "ix.indkey"),
 #
 #lse:
 #DX_SQL = """
 #ELECT
 #.relname as relname,
 #x.indisunique, ix.indexprs,
 #.attname, a.attnum, c.conrelid, ix.indkey::varchar,
 #x.indoption::varchar, i.reloptions, am.amname,
 #g_get_expr(ix.indpred, ix.indrelid),
 #s as indnkeyatts
 #ROM
 #g_class t
 #oin pg_index ix on t.oid = ix.indrelid
 #oin pg_class i on i.oid = ix.indexrelid
 #eft outer join
 #g_attribute a
 #n t.oid = a.attrelid and a.attnum = ANY(ix.indkey)
 #eft outer join
 #g_constraint c
 #n (ix.indrelid = c.conrelid and
 #x.indexrelid = c.conindid and
 #.contype in ('p', 'u', 'x'))
 #eft outer join
 #g_am am
 #n i.relam = am.oid
 #HERE
 #.relkind IN ('r', 'v', 'f', 'm', 'p')
 #nd t.oid = :table_oid
 #nd ix.indisprimary = 'f'
 #RDER BY
 #.relname,
 #.relname
 #"" % (
 #ix.indnkeyatts"
 #f self.server_version_info >= (11, 0)
 #lse "NULL",
 #

 # = sql.text(IDX_SQL).columns(
 #elname=sqltypes.Unicode, attname=sqltypes.Unicode
 #
 # = connection.execute(t, dict(table_oid=table_oid))

 #ndexes = defaultdict(lambda: defaultdict(dict))

 #v_idx_name = None
 #or row in c.fetchall():
 #
 #dx_name,
 #nique,
 #xpr,
 #ol,
 #ol_num,
 #onrelid,
 #dx_key,
 #dx_option,
 #ptions,
 #mname,
 #ilter_definition,
 #ndnkeyatts,
 # = row

 #f expr:
 #f idx_name != sv_idx_name:
 #til.warn(
 #Skipped unsupported reflection of "
 #expression-based index %s" % idx_name
 #
 #v_idx_name = idx_name
 #ontinue

 #as_idx = idx_name in indexes
 #ndex = indexes[idx_name]
 #f col is not None:
 #ndex["cols"][col_num] = col
 #f not has_idx:
 #dx_keys = idx_key.split()
                # "The number of key columns in the index, not counting any
                # included columns, which are merely stored and do not
                # participate in the index semantics"
 #f indnkeyatts and idx_keys[indnkeyatts:]:
                    # this is a "covering index" which has INCLUDE columns
                    # as well as regular index columns
 #nc_keys = idx_keys[indnkeyatts:]
 #dx_keys = idx_keys[:indnkeyatts]
 #lse:
 #nc_keys = []

 #ndex["key"] = [int(k.strip()) for k in idx_keys]
 #ndex["inc"] = [int(k.strip()) for k in inc_keys]

                # (new in pg 8.3)
                # "pg_index.indoption" is list of ints, one per column/expr.
                # int acts as bitmask: 0x01=DESC, 0x02=NULLSFIRST
 #orting = {}
 #or col_idx, col_flags in enumerate(
 #idx_option or "").split()
 #:
 #ol_flags = int(col_flags.strip())
 #ol_sorting = ()
                    # try to set flags only if they differ from PG defaults...
 #f col_flags & 0x01:
 #ol_sorting += ("desc",)
 #f not (col_flags & 0x02):
 #ol_sorting += ("nulls_last",)
 #lse:
 #f col_flags & 0x02:
 #ol_sorting += ("nulls_first",)
 #f col_sorting:
 #orting[col_idx] = col_sorting
 #f sorting:
 #ndex["sorting"] = sorting

 #ndex["unique"] = unique
 #f conrelid is not None:
 #ndex["duplicates_constraint"] = idx_name
 #f options:
 #ndex["options"] = dict(
 #option.split("=") for option in options]
 #

                # it *might* be nice to include that this is 'btree' in the
                # reflection info.  But we don't want an Index object
                # to have a ``postgresql_using`` in it that is just the
                # default, so for the moment leaving this out.
 #f amname and amname != "btree":
 #ndex["amname"] = amname

 #f filter_definition:
 #ndex["postgresql_where"] = filter_definition

 #esult = []
 #or name, idx in indexes.items():
 #ntry = {
 #name": name,
 #unique": idx["unique"],
 #column_names": [idx["cols"][i] for i in idx["key"]],
 #
 #f self.server_version_info >= (11, 0):
 #ntry["include_columns"] = [idx["cols"][i] for i in idx["inc"]]
 #f "duplicates_constraint" in idx:
 #ntry["duplicates_constraint"] = idx["duplicates_constraint"]
 #f "sorting" in idx:
 #ntry["column_sorting"] = dict(
 #idx["cols"][idx["key"][i]], value)
 #or i, value in idx["sorting"].items()
 #
 #f "options" in idx:
 #ntry.setdefault("dialect_options", {})[
 #postgresql_with"
 # = idx["options"]
 #f "amname" in idx:
 #ntry.setdefault("dialect_options", {})[
 #postgresql_using"
 # = idx["amname"]
 #f "postgresql_where" in idx:
 #ntry.setdefault("dialect_options", {})[
 #postgresql_where"
 # = idx["postgresql_where"]
 #esult.append(entry)
 #eturn result

 #reflection.cache
 #ef get_unique_constraints(
 #elf, connection, table_name, schema=None, **kw
 #:
 #able_oid = self.get_table_oid(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #NIQUE_SQL = """
 #ELECT
 #ons.conname as name,
 #ons.conkey as key,
 #.attnum as col_num,
 #.attname as col_name
 #ROM
 #g_catalog.pg_constraint cons
 #oin pg_attribute a
 #n cons.conrelid = a.attrelid AND
 #.attnum = ANY(cons.conkey)
 #HERE
 #ons.conrelid = :table_oid AND
 #ons.contype = 'u'
 #""

 # = sql.text(UNIQUE_SQL).columns(col_name=sqltypes.Unicode)
 # = connection.execute(t, dict(table_oid=table_oid))

 #niques = defaultdict(lambda: defaultdict(dict))
 #or row in c.fetchall():
 #c = uniques[row.name]
 #c["key"] = row.key
 #c["cols"][row.col_num] = row.col_name

 #eturn [
 #"name": name, "column_names": [uc["cols"][i] for i in uc["key"]]}
 #or name, uc in uniques.items()
 #

 #reflection.cache
 #ef get_table_comment(self, connection, table_name, schema=None, **kw):
 #able_oid = self.get_table_oid(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #OMMENT_SQL = """
 #ELECT
 #gd.description as table_comment
 #ROM
 #g_catalog.pg_description pgd
 #HERE
 #gd.objsubid = 0 AND
 #gd.objoid = :table_oid
 #""

 # = connection.execute(
 #ql.text(COMMENT_SQL), dict(table_oid=table_oid)
 #
 #eturn {"text": c.scalar()}

 #reflection.cache
 #ef get_check_constraints(self, connection, table_name, schema=None, **kw):
 #able_oid = self.get_table_oid(
 #onnection, table_name, schema, info_cache=kw.get("info_cache")
 #

 #HECK_SQL = """
 #ELECT
 #ons.conname as name,
 #g_get_constraintdef(cons.oid) as src
 #ROM
 #g_catalog.pg_constraint cons
 #HERE
 #ons.conrelid = :table_oid AND
 #ons.contype = 'c'
 #""

 # = connection.execute(sql.text(CHECK_SQL), dict(table_oid=table_oid))

 #et = []
 #or name, src in c:
            # samples:
            # "CHECK (((a > 1) AND (a < 5)))"
            # "CHECK (((a = 1) OR ((a > 2) AND (a < 5))))"
            # "CHECK (((a > 1) AND (a < 5))) NOT VALID"
            # "CHECK (some_boolean_function(a))"
            # "CHECK (((a\n < 1)\n OR\n (a\n >= 5))\n)"

 # = re.match(
 #"^CHECK *\((.+)\)( NOT VALID)?$", src, flags=re.DOTALL
 #
 #f not m:
 #til.warn("Could not parse CHECK constraint text: %r" % src)
 #qltext = ""
 #lse:
 #qltext = re.compile(
 #"^[\s\n]*\((.+)\)[\s\n]*$", flags=re.DOTALL
 #.sub(r"\1", m.group(1))
 #ntry = {"name": name, "sqltext": sqltext}
 #f m and m.group(2):
 #ntry["dialect_options"] = {"not_valid": True}

 #et.append(entry)
 #eturn ret

 #ef _load_enums(self, connection, schema=None):
 #chema = schema or self.default_schema_name
 #f not self.supports_native_enum:
 #eturn {}

        # Load data types for enums:
 #QL_ENUMS = """
 #ELECT t.typname as "name",
 #- no enum defaults in 8.4 at least
 #- t.typdefault as "default",
 #g_catalog.pg_type_is_visible(t.oid) as "visible",
 #.nspname as "schema",
 #.enumlabel as "label"
 #ROM pg_catalog.pg_type t
 #EFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
 #EFT JOIN pg_catalog.pg_enum e ON t.oid = e.enumtypid
 #HERE t.typtype = 'e'
 #""

 #f schema != "*":
 #QL_ENUMS += "AND n.nspname = :schema "

        # e.oid gives us label order within an enum
 #QL_ENUMS += 'ORDER BY "schema", "name", e.oid'

 # = sql.text(SQL_ENUMS).columns(
 #ttname=sqltypes.Unicode, label=sqltypes.Unicode
 #

 #f schema != "*":
 # = s.bindparams(schema=schema)

 # = connection.execute(s)

 #nums = []
 #num_by_name = {}
 #or enum in c.fetchall():
 #ey = (enum.schema, enum.name)
 #f key in enum_by_name:
 #num_by_name[key]["labels"].append(enum.label)
 #lse:
 #num_by_name[key] = enum_rec = {
 #name": enum.name,
 #schema": enum.schema,
 #visible": enum.visible,
 #labels": [],
 #
 #f enum.label is not None:
 #num_rec["labels"].append(enum.label)
 #nums.append(enum_rec)
 #eturn enums

 #ef _load_domains(self, connection):
        # Load data types for domains:
 #QL_DOMAINS = """
 #ELECT t.typname as "name",
 #g_catalog.format_type(t.typbasetype, t.typtypmod) as "attype",
 #ot t.typnotnull as "nullable",
 #.typdefault as "default",
 #g_catalog.pg_type_is_visible(t.oid) as "visible",
 #.nspname as "schema"
 #ROM pg_catalog.pg_type t
 #EFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
 #HERE t.typtype = 'd'
 #""

 # = sql.text(SQL_DOMAINS)
 # = connection.execution_options(future_result=True).execute(s)

 #omains = {}
 #or domain in c.mappings():
 #omain = domain
            # strip (30) from character varying(30)
 #ttype = re.search(r"([^\(]+)", domain["attype"]).group(1)
            # 'visible' just means whether or not the domain is in a
            # schema that's on the search path -- or not overridden by
            # a schema with higher precedence. If it's not visible,
            # it will be prefixed with the schema-name when it's used.
 #f domain["visible"]:
 #ey = (domain["name"],)
 #lse:
 #ey = (domain["schema"], domain["name"])

 #omains[key] = {
 #attype": attype,
 #nullable": domain["nullable"],
 #default": domain["default"],
 #

 #eturn domains
