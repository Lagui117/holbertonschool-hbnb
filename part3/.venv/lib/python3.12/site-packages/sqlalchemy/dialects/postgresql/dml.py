# postgresql/on_conflict.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from . import ext
from ... import util
from ...sql import coercions
from ...sql import roles
from ...sql import schema
from ...sql.base import _exclusive_against
from ...sql.base import _generative
from ...sql.base import ColumnCollection
from ...sql.dml import Insert as StandardInsert
from ...sql.elements import ClauseElement
from ...sql.expression import alias
from ...util.langhelpers import public_factory


__all__ = ("Insert", "insert")


class Insert(StandardInsert):
 #""PostgreSQL-specific implementation of INSERT.

 #dds methods for PG-specific syntaxes such as ON CONFLICT.

 #he :class:`_postgresql.Insert` object is created using the
 #func:`sqlalchemy.dialects.postgresql.insert` function.

 #. versionadded:: 1.1

 #""

 #tringify_dialect = "postgresql"

 #util.memoized_property
 #ef excluded(self):
 #""Provide the ``excluded`` namespace for an ON CONFLICT statement

 #G's ON CONFLICT clause allows reference to the row that would
 #e inserted, known as ``excluded``.  This attribute provides
 #ll columns in this row to be referenceable.

 #. tip::  The :attr:`_postgresql.Insert.excluded` attribute is an
 #nstance of :class:`_expression.ColumnCollection`, which provides
 #n interface the same as that of the :attr:`_schema.Table.c`
 #ollection described at :ref:`metadata_tables_and_columns`.
 #ith this collection, ordinary names are accessible like attributes
 #e.g. ``stmt.excluded.some_column``), but special names and
 #ictionary method names should be accessed using indexed access,
 #uch as ``stmt.excluded["column name"]`` or
 #`stmt.excluded["values"]``.   See the docstring for
 #class:`_expression.ColumnCollection` for further examples.

 #. seealso::

 #ref:`postgresql_insert_on_conflict` - example of how
 #o use :attr:`_expression.Insert.excluded`

 #""
 #eturn alias(self.table, name="excluded").columns

 #on_conflict_exclusive = _exclusive_against(
 #_post_values_clause",
 #sgs={
 #_post_values_clause": "This Insert construct already has "
 #an ON CONFLICT clause established"
 #,
 #

 #_generative
 #_on_conflict_exclusive
 #ef on_conflict_do_update(
 #elf,
 #onstraint=None,
 #ndex_elements=None,
 #ndex_where=None,
 #et_=None,
 #here=None,
 #:
 #"""
 #pecifies a DO UPDATE SET action for ON CONFLICT clause.

 #ither the ``constraint`` or ``index_elements`` argument is
 #equired, but only one of these can be specified.

 #param constraint:
 #he name of a unique or exclusion constraint on the table,
 #r the constraint object itself if it has a .name attribute.

 #param index_elements:
 # sequence consisting of string column names, :class:`_schema.Column`
 #bjects, or other column expression objects that will be used
 #o infer a target index.

 #param index_where:
 #dditional WHERE criterion that can be used to infer a
 #onditional target index.

 #param set\_:
 # dictionary or other mapping object
 #here the keys are either names of columns in the target table,
 #r :class:`_schema.Column` objects or other ORM-mapped columns
 #atching that of the target table, and expressions or literals
 #s values, specifying the ``SET`` actions to take.

 #. versionadded:: 1.4 The
 #paramref:`_postgresql.Insert.on_conflict_do_update.set_`
 #arameter supports :class:`_schema.Column` objects from the target
 #class:`_schema.Table` as keys.

 #. warning:: This dictionary does **not** take into account
 #ython-specified default UPDATE values or generation functions,
 #.g. those specified using :paramref:`_schema.Column.onupdate`.
 #hese values will not be exercised for an ON CONFLICT style of
 #PDATE, unless they are manually specified in the
 #paramref:`.Insert.on_conflict_do_update.set_` dictionary.

 #param where:
 #ptional argument. If present, can be a literal SQL
 #tring or an acceptable expression for a ``WHERE`` clause
 #hat restricts the rows affected by ``DO UPDATE SET``. Rows
 #ot meeting the ``WHERE`` condition will not be updated
 #effectively a ``DO NOTHING`` for those rows).

 #. versionadded:: 1.1


 #. seealso::

 #ref:`postgresql_insert_on_conflict`

 #""
 #elf._post_values_clause = OnConflictDoUpdate(
 #onstraint, index_elements, index_where, set_, where
 #

 #_generative
 #_on_conflict_exclusive
 #ef on_conflict_do_nothing(
 #elf, constraint=None, index_elements=None, index_where=None
 #:
 #""
 #pecifies a DO NOTHING action for ON CONFLICT clause.

 #he ``constraint`` and ``index_elements`` arguments
 #re optional, but only one of these can be specified.

 #param constraint:
 #he name of a unique or exclusion constraint on the table,
 #r the constraint object itself if it has a .name attribute.

 #param index_elements:
 # sequence consisting of string column names, :class:`_schema.Column`
 #bjects, or other column expression objects that will be used
 #o infer a target index.

 #param index_where:
 #dditional WHERE criterion that can be used to infer a
 #onditional target index.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`postgresql_insert_on_conflict`

 #""
 #elf._post_values_clause = OnConflictDoNothing(
 #onstraint, index_elements, index_where
 #


insert = public_factory(
 #nsert, ".dialects.postgresql.insert", ".dialects.postgresql.Insert"
)


class OnConflictClause(ClauseElement):
 #tringify_dialect = "postgresql"

 #ef __init__(self, constraint=None, index_elements=None, index_where=None):

 #f constraint is not None:
 #f not isinstance(constraint, util.string_types) and isinstance(
 #onstraint,
 #schema.Index, schema.Constraint, ext.ExcludeConstraint),
 #:
 #onstraint = getattr(constraint, "name") or constraint

 #f constraint is not None:
 #f index_elements is not None:
 #aise ValueError(
 #'constraint' and 'index_elements' are mutually exclusive"
 #

 #f isinstance(constraint, util.string_types):
 #elf.constraint_target = constraint
 #elf.inferred_target_elements = None
 #elf.inferred_target_whereclause = None
 #lif isinstance(constraint, schema.Index):
 #ndex_elements = constraint.expressions
 #ndex_where = constraint.dialect_options["postgresql"].get(
 #where"
 #
 #lif isinstance(constraint, ext.ExcludeConstraint):
 #ndex_elements = constraint.columns
 #ndex_where = constraint.where
 #lse:
 #ndex_elements = constraint.columns
 #ndex_where = constraint.dialect_options["postgresql"].get(
 #where"
 #

 #f index_elements is not None:
 #elf.constraint_target = None
 #elf.inferred_target_elements = index_elements
 #elf.inferred_target_whereclause = index_where
 #lif constraint is None:
 #elf.constraint_target = (
 #elf.inferred_target_elements
 # = self.inferred_target_whereclause = None


class OnConflictDoNothing(OnConflictClause):
 #_visit_name__ = "on_conflict_do_nothing"


class OnConflictDoUpdate(OnConflictClause):
 #_visit_name__ = "on_conflict_do_update"

 #ef __init__(
 #elf,
 #onstraint=None,
 #ndex_elements=None,
 #ndex_where=None,
 #et_=None,
 #here=None,
 #:
 #uper(OnConflictDoUpdate, self).__init__(
 #onstraint=constraint,
 #ndex_elements=index_elements,
 #ndex_where=index_where,
 #

 #f (
 #elf.inferred_target_elements is None
 #nd self.constraint_target is None
 #:
 #aise ValueError(
 #Either constraint or index_elements, "
 #but not both, must be specified unless DO NOTHING"
 #

 #f isinstance(set_, dict):
 #f not set_:
 #aise ValueError("set parameter dictionary must not be empty")
 #lif isinstance(set_, ColumnCollection):
 #et_ = dict(set_)
 #lse:
 #aise ValueError(
 #set parameter must be a non-empty dictionary "
 #or a ColumnCollection such as the `.c.` collection "
 #of a Table object"
 #
 #elf.update_values_to_set = [
 #coercions.expect(roles.DMLColumnRole, key), value)
 #or key, value in set_.items()
 #
 #elf.update_whereclause = where
