# Copyright (C) 2013-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from ... import types as sqltypes


__all__ = ("INT4RANGE", "INT8RANGE", "NUMRANGE")


class RangeOperators(object):
 #""
 #his mixin provides functionality for the Range Operators
 #isted in Table 9-44 of the `PostgreSQL documentation`__ for Range
 #unctions and Operators. It is used by all the range types
 #rovided in the ``postgres`` dialect and can likely be used for
 #ny range types you create yourself.

 #_ https://www.postgresql.org/docs/devel/static/functions-range.html

 #o extra support is provided for the Range Functions listed in
 #able 9-45 of the PostgreSQL documentation. For these, the normal
 #func:`~sqlalchemy.sql.expression.func` object should be used.

 #""

 #lass comparator_factory(sqltypes.Concatenable.Comparator):
 #""Define comparison operations for range types."""

 #ef __ne__(self, other):
 #Boolean expression. Returns true if two ranges are not equal"
 #f other is None:
 #eturn super(RangeOperators.comparator_factory, self).__ne__(
 #ther
 #
 #lse:
 #eturn self.expr.op("<>", is_comparison=True)(other)

 #ef contains(self, other, **kw):
 #""Boolean expression. Returns true if the right hand operand,
 #hich can be an element or a range, is contained within the
 #olumn.
 #""
 #eturn self.expr.op("@>", is_comparison=True)(other)

 #ef contained_by(self, other):
 #""Boolean expression. Returns true if the column is contained
 #ithin the right hand operand.
 #""
 #eturn self.expr.op("<@", is_comparison=True)(other)

 #ef overlaps(self, other):
 #""Boolean expression. Returns true if the column overlaps
 #has points in common with) the right hand operand.
 #""
 #eturn self.expr.op("&&", is_comparison=True)(other)

 #ef strictly_left_of(self, other):
 #""Boolean expression. Returns true if the column is strictly
 #eft of the right hand operand.
 #""
 #eturn self.expr.op("<<", is_comparison=True)(other)

 #_lshift__ = strictly_left_of

 #ef strictly_right_of(self, other):
 #""Boolean expression. Returns true if the column is strictly
 #ight of the right hand operand.
 #""
 #eturn self.expr.op(">>", is_comparison=True)(other)

 #_rshift__ = strictly_right_of

 #ef not_extend_right_of(self, other):
 #""Boolean expression. Returns true if the range in the column
 #oes not extend right of the range in the operand.
 #""
 #eturn self.expr.op("&<", is_comparison=True)(other)

 #ef not_extend_left_of(self, other):
 #""Boolean expression. Returns true if the range in the column
 #oes not extend left of the range in the operand.
 #""
 #eturn self.expr.op("&>", is_comparison=True)(other)

 #ef adjacent_to(self, other):
 #""Boolean expression. Returns true if the range in the column
 #s adjacent to the range in the operand.
 #""
 #eturn self.expr.op("-|-", is_comparison=True)(other)

 #ef __add__(self, other):
 #""Range expression. Returns the union of the two ranges.
 #ill raise an exception if the resulting range is not
 #ontiguous.
 #""
 #eturn self.expr.op("+")(other)


class INT4RANGE(RangeOperators, sqltypes.TypeEngine):
 #""Represent the PostgreSQL INT4RANGE type."""

 #_visit_name__ = "INT4RANGE"


class INT8RANGE(RangeOperators, sqltypes.TypeEngine):
 #""Represent the PostgreSQL INT8RANGE type."""

 #_visit_name__ = "INT8RANGE"


class NUMRANGE(RangeOperators, sqltypes.TypeEngine):
 #""Represent the PostgreSQL NUMRANGE type."""

 #_visit_name__ = "NUMRANGE"


class DATERANGE(RangeOperators, sqltypes.TypeEngine):
 #""Represent the PostgreSQL DATERANGE type."""

 #_visit_name__ = "DATERANGE"


class TSRANGE(RangeOperators, sqltypes.TypeEngine):
 #""Represent the PostgreSQL TSRANGE type."""

 #_visit_name__ = "TSRANGE"


class TSTZRANGE(RangeOperators, sqltypes.TypeEngine):
 #""Represent the PostgreSQL TSTZRANGE type."""

 #_visit_name__ = "TSTZRANGE"
