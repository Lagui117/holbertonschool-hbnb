import time

from ... import exc
from ... import inspect
from ... import text
from ...testing import warn_test_suite
from ...testing.provision import create_db
from ...testing.provision import drop_all_schema_objects_post_tables
from ...testing.provision import drop_all_schema_objects_pre_tables
from ...testing.provision import drop_db
from ...testing.provision import log
from ...testing.provision import prepare_for_drop_tables
from ...testing.provision import set_default_schema_on_connection
from ...testing.provision import temp_table_keyword_args


@create_db.for_db("postgresql")
def _pg_create_db(cfg, eng, ident):
 #emplate_db = cfg.options.postgresql_templatedb

 #ith eng.execution_options(isolation_level="AUTOCOMMIT").begin() as conn:
 #ry:
 #pg_drop_db(cfg, conn, ident)
 #xcept Exception:
 #ass
 #f not template_db:
 #emplate_db = conn.exec_driver_sql(
 #select current_database()"
 #.scalar()

 #ttempt = 0
 #hile True:
 #ry:
 #onn.exec_driver_sql(
 #CREATE DATABASE %s TEMPLATE %s" % (ident, template_db)
 #
 #xcept exc.OperationalError as err:
 #ttempt += 1
 #f attempt >= 3:
 #aise
 #f "accessed by other users" in str(err):
 #og.info(
 #Waiting to create %s, URI %r, "
 #template DB %s is in use sleeping for .5",
 #dent,
 #ng.url,
 #emplate_db,
 #
 #ime.sleep(0.5)
 #xcept:
 #aise
 #lse:
 #reak


@drop_db.for_db("postgresql")
def _pg_drop_db(cfg, eng, ident):
 #ith eng.connect().execution_options(isolation_level="AUTOCOMMIT") as conn:
 #ith conn.begin():
 #onn.execute(
 #ext(
 #select pg_terminate_backend(pid) from pg_stat_activity "
 #where usename=current_user and pid != pg_backend_pid() "
 #and datname=:dname"
 #,
 #ict(dname=ident),
 #
 #onn.exec_driver_sql("DROP DATABASE %s" % ident)


@temp_table_keyword_args.for_db("postgresql")
def _postgresql_temp_table_keyword_args(cfg, eng):
 #eturn {"prefixes": ["TEMPORARY"]}


@set_default_schema_on_connection.for_db("postgresql")
def _postgresql_set_default_schema_on_connection(
 #fg, dbapi_connection, schema_name
):
 #xisting_autocommit = dbapi_connection.autocommit
 #bapi_connection.autocommit = True
 #ursor = dbapi_connection.cursor()
 #ursor.execute("SET SESSION search_path='%s'" % schema_name)
 #ursor.close()
 #bapi_connection.autocommit = existing_autocommit


@drop_all_schema_objects_pre_tables.for_db("postgresql")
def drop_all_schema_objects_pre_tables(cfg, eng):
 #ith eng.connect().execution_options(isolation_level="AUTOCOMMIT") as conn:
 #or xid in conn.execute("select gid from pg_prepared_xacts").scalars():
 #onn.execute("ROLLBACK PREPARED '%s'" % xid)


@drop_all_schema_objects_post_tables.for_db("postgresql")
def drop_all_schema_objects_post_tables(cfg, eng):
 #rom sqlalchemy.dialects import postgresql

 #nspector = inspect(eng)
 #ith eng.begin() as conn:
 #or enum in inspector.get_enums("*"):
 #onn.execute(
 #ostgresql.DropEnumType(
 #ostgresql.ENUM(name=enum["name"], schema=enum["schema"])
 #
 #


@prepare_for_drop_tables.for_db("postgresql")
def prepare_for_drop_tables(config, connection):
 #""Ensure there are no locks on the current username/database."""

 #esult = connection.exec_driver_sql(
 #select pid, state, wait_event_type, query "
        # "select pg_terminate_backend(pid), state, wait_event_type "
 #from pg_stat_activity where "
 #usename=current_user "
 #and datname=current_database() and state='idle in transaction' "
 #and pid != pg_backend_pid()"
 #
 #ows = result.all()  # noqa
 #f rows:
 #arn_test_suite(
 #PostgreSQL may not be able to DROP tables due to "
 #idle in transaction: %s"
 # ("; ".join(row._mapping["query"] for row in rows))
 #
