# postgresql/array.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import re

from ... import types as sqltypes
from ... import util
from ...sql import coercions
from ...sql import expression
from ...sql import operators
from ...sql import roles


def Any(other, arrexpr, operator=operators.eq):
 #""A synonym for the :meth:`.ARRAY.Comparator.any` method.

 #his method is legacy and is here for backwards-compatibility.

 #. seealso::

 #func:`_expression.any_`

 #""

 #eturn arrexpr.any(other, operator)


def All(other, arrexpr, operator=operators.eq):
 #""A synonym for the :meth:`.ARRAY.Comparator.all` method.

 #his method is legacy and is here for backwards-compatibility.

 #. seealso::

 #func:`_expression.all_`

 #""

 #eturn arrexpr.all(other, operator)


class array(expression.ClauseList, expression.ColumnElement):

 #""A PostgreSQL ARRAY literal.

 #his is used to produce ARRAY literals in SQL expressions, e.g.::

 #rom sqlalchemy.dialects.postgresql import array
 #rom sqlalchemy.dialects import postgresql
 #rom sqlalchemy import select, func

 #tmt = select(array([1,2]) + array([3,4,5]))

 #rint(stmt.compile(dialect=postgresql.dialect()))

 #roduces the SQL::

 #ELECT ARRAY[%(param_1)s, %(param_2)s] ||
 #RRAY[%(param_3)s, %(param_4)s, %(param_5)s]) AS anon_1

 #n instance of :class:`.array` will always have the datatype
 #class:`_types.ARRAY`.  The "inner" type of the array is inferred from
 #he values present, unless the ``type_`` keyword argument is passed::

 #rray(['foo', 'bar'], type_=CHAR)

 #ultidimensional arrays are produced by nesting :class:`.array` constructs.
 #he dimensionality of the final :class:`_types.ARRAY`
 #ype is calculated by
 #ecursively adding the dimensions of the inner :class:`_types.ARRAY`
 #ype::

 #tmt = select(
 #rray([
 #rray([1, 2]), array([3, 4]), array([column('q'), column('x')])
 #)
 #
 #rint(stmt.compile(dialect=postgresql.dialect()))

 #roduces::

 #ELECT ARRAY[ARRAY[%(param_1)s, %(param_2)s],
 #RRAY[%(param_3)s, %(param_4)s], ARRAY[q, x]] AS anon_1

 #. versionadded:: 1.3.6 added support for multidimensional array literals

 #. seealso::

 #class:`_postgresql.ARRAY`

 #""

 #_visit_name__ = "array"

 #tringify_dialect = "postgresql"

 #ef __init__(self, clauses, **kw):
 #lauses = [
 #oercions.expect(roles.ExpressionElementRole, c) for c in clauses
 #

 #uper(array, self).__init__(*clauses, **kw)

 #elf._type_tuple = [arg.type for arg in clauses]
 #ain_type = kw.pop(
 #type_",
 #elf._type_tuple[0] if self._type_tuple else sqltypes.NULLTYPE,
 #

 #f isinstance(main_type, ARRAY):
 #elf.type = ARRAY(
 #ain_type.item_type,
 #imensions=main_type.dimensions + 1
 #f main_type.dimensions is not None
 #lse 2,
 #
 #lse:
 #elf.type = ARRAY(main_type)

 #property
 #ef _select_iterable(self):
 #eturn (self,)

 #ef _bind_param(self, operator, obj, _assume_scalar=False, type_=None):
 #f _assume_scalar or operator is operators.getitem:
 #eturn expression.BindParameter(
 #one,
 #bj,
 #compared_to_operator=operator,
 #ype_=type_,
 #compared_to_type=self.type,
 #nique=True,
 #

 #lse:
 #eturn array(
 #
 #elf._bind_param(
 #perator, o, _assume_scalar=True, type_=type_
 #
 #or o in obj
 #
 #

 #ef self_group(self, against=None):
 #f against in (operators.any_op, operators.all_op, operators.getitem):
 #eturn expression.Grouping(self)
 #lse:
 #eturn self


CONTAINS = operators.custom_op("@>", precedence=5)

CONTAINED_BY = operators.custom_op("<@", precedence=5)

OVERLAP = operators.custom_op("&&", precedence=5)


class ARRAY(sqltypes.ARRAY):

 #""PostgreSQL ARRAY type.

 #. versionchanged:: 1.1 The :class:`_postgresql.ARRAY` type is now
 # subclass of the core :class:`_types.ARRAY` type.

 #he :class:`_postgresql.ARRAY` type is constructed in the same way
 #s the core :class:`_types.ARRAY` type; a member type is required, and a
 #umber of dimensions is recommended if the type is to be used for more
 #han one dimension::

 #rom sqlalchemy.dialects import postgresql

 #ytable = Table("mytable", metadata,
 #olumn("data", postgresql.ARRAY(Integer, dimensions=2))
 #

 #he :class:`_postgresql.ARRAY` type provides all operations defined on the
 #ore :class:`_types.ARRAY` type, including support for "dimensions",
 #ndexed access, and simple matching such as
 #meth:`.types.ARRAY.Comparator.any` and
 #meth:`.types.ARRAY.Comparator.all`.  :class:`_postgresql.ARRAY`
 #lass also
 #rovides PostgreSQL-specific methods for containment operations, including
 #meth:`.postgresql.ARRAY.Comparator.contains`
 #meth:`.postgresql.ARRAY.Comparator.contained_by`, and
 #meth:`.postgresql.ARRAY.Comparator.overlap`, e.g.::

 #ytable.c.data.contains([1, 2])

 #he :class:`_postgresql.ARRAY` type may not be supported on all
 #ostgreSQL DBAPIs; it is currently known to work on psycopg2 only.

 #dditionally, the :class:`_postgresql.ARRAY`
 #ype does not work directly in
 #onjunction with the :class:`.ENUM` type.  For a workaround, see the
 #pecial type at :ref:`postgresql_array_of_enum`.

 #. seealso::

 #class:`_types.ARRAY` - base array type

 #class:`_postgresql.array` - produces a literal array value.

 #""

 #lass Comparator(sqltypes.ARRAY.Comparator):

 #""Define comparison operations for :class:`_types.ARRAY`.

 #ote that these operations are in addition to those provided
 #y the base :class:`.types.ARRAY.Comparator` class, including
 #meth:`.types.ARRAY.Comparator.any` and
 #meth:`.types.ARRAY.Comparator.all`.

 #""

 #ef contains(self, other, **kwargs):
 #""Boolean expression.  Test if elements are a superset of the
 #lements of the argument array expression.
 #""
 #eturn self.operate(CONTAINS, other, result_type=sqltypes.Boolean)

 #ef contained_by(self, other):
 #""Boolean expression.  Test if elements are a proper subset of the
 #lements of the argument array expression.
 #""
 #eturn self.operate(
 #ONTAINED_BY, other, result_type=sqltypes.Boolean
 #

 #ef overlap(self, other):
 #""Boolean expression.  Test if array has elements in common with
 #n argument array expression.
 #""
 #eturn self.operate(OVERLAP, other, result_type=sqltypes.Boolean)

 #omparator_factory = Comparator

 #ef __init__(
 #elf, item_type, as_tuple=False, dimensions=None, zero_indexes=False
 #:
 #""Construct an ARRAY.

 #.g.::

 #olumn('myarray', ARRAY(Integer))

 #rguments are:

 #param item_type: The data type of items of this array. Note that
 #imensionality is irrelevant here, so multi-dimensional arrays like
 #`INTEGER[][]``, are constructed as ``ARRAY(Integer)``, not as
 #`ARRAY(ARRAY(Integer))`` or such.

 #param as_tuple=False: Specify whether return results
 #hould be converted to tuples from lists. DBAPIs such
 #s psycopg2 return lists by default. When tuples are
 #eturned, the results are hashable.

 #param dimensions: if non-None, the ARRAY will assume a fixed
 #umber of dimensions.  This will cause the DDL emitted for this
 #RRAY to include the exact number of bracket clauses ``[]``,
 #nd will also optimize the performance of the type overall.
 #ote that PG arrays are always implicitly "non-dimensioned",
 #eaning they can store any number of dimensions no matter how
 #hey were declared.

 #param zero_indexes=False: when True, index values will be converted
 #etween Python zero-based and PostgreSQL one-based indexes, e.g.
 # value of one will be added to all index values before passing
 #o the database.

 #. versionadded:: 0.9.5


 #""
 #f isinstance(item_type, ARRAY):
 #aise ValueError(
 #Do not nest ARRAY types; ARRAY(basetype) "
 #handles multi-dimensional arrays of basetype"
 #
 #f isinstance(item_type, type):
 #tem_type = item_type()
 #elf.item_type = item_type
 #elf.as_tuple = as_tuple
 #elf.dimensions = dimensions
 #elf.zero_indexes = zero_indexes

 #property
 #ef hashable(self):
 #eturn self.as_tuple

 #property
 #ef python_type(self):
 #eturn list

 #ef compare_values(self, x, y):
 #eturn x == y

 #ef _proc_array(self, arr, itemproc, dim, collection):
 #f dim is None:
 #rr = list(arr)
 #f (
 #im == 1
 #r dim is None
 #nd (
                # this has to be (list, tuple), or at least
                # not hasattr('__iter__'), since Py3K strings
                # etc. have __iter__
 #ot arr
 #r not isinstance(arr[0], (list, tuple))
 #
 #:
 #f itemproc:
 #eturn collection(itemproc(x) for x in arr)
 #lse:
 #eturn collection(arr)
 #lse:
 #eturn collection(
 #elf._proc_array(
 #,
 #temproc,
 #im - 1 if dim is not None else None,
 #ollection,
 #
 #or x in arr
 #

 #util.memoized_property
 #ef _against_native_enum(self):
 #eturn (
 #sinstance(self.item_type, sqltypes.Enum)
 #nd self.item_type.native_enum
 #

 #ef bind_expression(self, bindvalue):
 #eturn bindvalue

 #ef bind_processor(self, dialect):
 #tem_proc = self.item_type.dialect_impl(dialect).bind_processor(
 #ialect
 #

 #ef process(value):
 #f value is None:
 #eturn value
 #lse:
 #eturn self._proc_array(
 #alue, item_proc, self.dimensions, list
 #

 #eturn process

 #ef result_processor(self, dialect, coltype):
 #tem_proc = self.item_type.dialect_impl(dialect).result_processor(
 #ialect, coltype
 #

 #ef process(value):
 #f value is None:
 #eturn value
 #lse:
 #eturn self._proc_array(
 #alue,
 #tem_proc,
 #elf.dimensions,
 #uple if self.as_tuple else list,
 #

 #f self._against_native_enum:
 #uper_rp = process

 #ef handle_raw_string(value):
 #nner = re.match(r"^{(.*)}$", value).group(1)
 #eturn inner.split(",") if inner else []

 #ef process(value):
 #f value is None:
 #eturn value
                # isinstance(value, util.string_types) is required to handle
                # the # case where a TypeDecorator for and Array of Enum is
                # used like was required in sa < 1.3.17
 #eturn super_rp(
 #andle_raw_string(value)
 #f isinstance(value, util.string_types)
 #lse value
 #

 #eturn process
