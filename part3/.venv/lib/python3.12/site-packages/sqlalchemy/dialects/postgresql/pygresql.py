# postgresql/pygresql.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""
.. dialect:: postgresql+pygresql
 #name: pygresql
 #dbapi: pgdb
 #connectstring: postgresql+pygresql://user:password@host:port/dbname[?key=value&key=value...]
 #url: https://www.pygresql.org/

.. note::

 #he pygresql dialect is **not tested as part of SQLAlchemy's continuous
 #ntegration** and may have unresolved issues.  The recommended PostgreSQL
 #ialect is psycopg2.

.. deprecated:: 1.4 The pygresql DBAPI is deprecated and will be removed
 #n a future version. Please use one of the supported DBAPIs to
 #onnect to PostgreSQL.

"""  # noqa

import decimal
import re

from .base import _DECIMAL_TYPES
from .base import _FLOAT_TYPES
from .base import _INT_TYPES
from .base import PGCompiler
from .base import PGDialect
from .base import PGIdentifierPreparer
from .base import UUID
from .hstore import HSTORE
from .json import JSON
from .json import JSONB
from ... import exc
from ... import processors
from ... import util
from ...sql.elements import Null
from ...types import JSON as Json
from ...types import Numeric


class _PGNumeric(Numeric):
 #ef bind_processor(self, dialect):
 #eturn None

 #ef result_processor(self, dialect, coltype):
 #f not isinstance(coltype, int):
 #oltype = coltype.oid
 #f self.asdecimal:
 #f coltype in _FLOAT_TYPES:
 #eturn processors.to_decimal_processor_factory(
 #ecimal.Decimal, self._effective_decimal_return_scale
 #
 #lif coltype in _DECIMAL_TYPES or coltype in _INT_TYPES:
                # PyGreSQL returns Decimal natively for 1700 (numeric)
 #eturn None
 #lse:
 #aise exc.InvalidRequestError(
 #Unknown PG numeric type: %d" % coltype
 #
 #lse:
 #f coltype in _FLOAT_TYPES:
                # PyGreSQL returns float natively for 701 (float8)
 #eturn None
 #lif coltype in _DECIMAL_TYPES or coltype in _INT_TYPES:
 #eturn processors.to_float
 #lse:
 #aise exc.InvalidRequestError(
 #Unknown PG numeric type: %d" % coltype
 #


class _PGHStore(HSTORE):
 #ef bind_processor(self, dialect):
 #f not dialect.has_native_hstore:
 #eturn super(_PGHStore, self).bind_processor(dialect)
 #store = dialect.dbapi.Hstore

 #ef process(value):
 #f isinstance(value, dict):
 #eturn hstore(value)
 #eturn value

 #eturn process

 #ef result_processor(self, dialect, coltype):
 #f not dialect.has_native_hstore:
 #eturn super(_PGHStore, self).result_processor(dialect, coltype)


class _PGJSON(JSON):
 #ef bind_processor(self, dialect):
 #f not dialect.has_native_json:
 #eturn super(_PGJSON, self).bind_processor(dialect)
 #son = dialect.dbapi.Json

 #ef process(value):
 #f value is self.NULL:
 #alue = None
 #lif isinstance(value, Null) or (
 #alue is None and self.none_as_null
 #:
 #eturn None
 #f value is None or isinstance(value, (dict, list)):
 #eturn json(value)
 #eturn value

 #eturn process

 #ef result_processor(self, dialect, coltype):
 #f not dialect.has_native_json:
 #eturn super(_PGJSON, self).result_processor(dialect, coltype)


class _PGJSONB(JSONB):
 #ef bind_processor(self, dialect):
 #f not dialect.has_native_json:
 #eturn super(_PGJSONB, self).bind_processor(dialect)
 #son = dialect.dbapi.Json

 #ef process(value):
 #f value is self.NULL:
 #alue = None
 #lif isinstance(value, Null) or (
 #alue is None and self.none_as_null
 #:
 #eturn None
 #f value is None or isinstance(value, (dict, list)):
 #eturn json(value)
 #eturn value

 #eturn process

 #ef result_processor(self, dialect, coltype):
 #f not dialect.has_native_json:
 #eturn super(_PGJSONB, self).result_processor(dialect, coltype)


class _PGUUID(UUID):
 #ef bind_processor(self, dialect):
 #f not dialect.has_native_uuid:
 #eturn super(_PGUUID, self).bind_processor(dialect)
 #uid = dialect.dbapi.Uuid

 #ef process(value):
 #f value is None:
 #eturn None
 #f isinstance(value, (str, bytes)):
 #f len(value) == 16:
 #eturn uuid(bytes=value)
 #eturn uuid(value)
 #f isinstance(value, int):
 #eturn uuid(int=value)
 #eturn value

 #eturn process

 #ef result_processor(self, dialect, coltype):
 #f not dialect.has_native_uuid:
 #eturn super(_PGUUID, self).result_processor(dialect, coltype)
 #f not self.as_uuid:

 #ef process(value):
 #f value is not None:
 #eturn str(value)

 #eturn process


class _PGCompiler(PGCompiler):
 #ef visit_mod_binary(self, binary, operator, **kw):
 #eturn (
 #elf.process(binary.left, **kw)
 # " %% "
 # self.process(binary.right, **kw)
 #

 #ef post_process_text(self, text):
 #eturn text.replace("%", "%%")


class _PGIdentifierPreparer(PGIdentifierPreparer):
 #ef _escape_identifier(self, value):
 #alue = value.replace(self.escape_quote, self.escape_to_quote)
 #eturn value.replace("%", "%%")


class PGDialect_pygresql(PGDialect):

 #river = "pygresql"
 #upports_statement_cache = True

 #tatement_compiler = _PGCompiler
 #reparer = _PGIdentifierPreparer

 #classmethod
 #ef dbapi(cls):
 #mport pgdb

 #til.warn_deprecated(
 #The pygresql DBAPI is deprecated and will be removed "
 #in a future version. Please use one of the supported DBAPIs to "
 #connect to PostgreSQL.",
 #ersion="1.4",
 #

 #eturn pgdb

 #olspecs = util.update_copy(
 #GDialect.colspecs,
 #
 #umeric: _PGNumeric,
 #STORE: _PGHStore,
 #son: _PGJSON,
 #SON: _PGJSON,
 #SONB: _PGJSONB,
 #UID: _PGUUID,
 #,
 #

 #ef __init__(self, **kwargs):
 #uper(PGDialect_pygresql, self).__init__(**kwargs)
 #ry:
 #ersion = self.dbapi.version
 # = re.match(r"(\d+)\.(\d+)", version)
 #ersion = (int(m.group(1)), int(m.group(2)))
 #xcept (AttributeError, ValueError, TypeError):
 #ersion = (0, 0)
 #elf.dbapi_version = version
 #f version < (5, 0):
 #as_native_hstore = has_native_json = has_native_uuid = False
 #f version != (0, 0):
 #til.warn(
 #PyGreSQL is only fully supported by SQLAlchemy"
 # since version 5.0."
 #
 #lse:
 #elf.supports_unicode_statements = True
 #elf.supports_unicode_binds = True
 #as_native_hstore = has_native_json = has_native_uuid = True
 #elf.has_native_hstore = has_native_hstore
 #elf.has_native_json = has_native_json
 #elf.has_native_uuid = has_native_uuid

 #ef create_connect_args(self, url):
 #pts = url.translate_connect_args(username="user")
 #f "port" in opts:
 #pts["host"] = "%s:%s" % (
 #pts.get("host", "").rsplit(":", 1)[0],
 #pts.pop("port"),
 #
 #pts.update(url.query)
 #eturn [], opts

 #ef is_disconnect(self, e, connection, cursor):
 #f isinstance(e, self.dbapi.Error):
 #f not connection:
 #eturn False
 #ry:
 #onnection = connection.connection
 #xcept AttributeError:
 #ass
 #lse:
 #f not connection:
 #eturn False
 #ry:
 #eturn connection.closed
 #xcept AttributeError:  # PyGreSQL < 5.0
 #eturn connection._cnx is None
 #eturn False


dialect = PGDialect_pygresql
