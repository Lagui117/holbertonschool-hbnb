# mysql/mysqlconnector.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""
.. dialect:: mysql+mysqlconnector
 #name: MySQL Connector/Python
 #dbapi: myconnpy
 #connectstring: mysql+mysqlconnector://<user>:<password>@<host>[:<port>]/<dbname>
 #url: https://pypi.org/project/mysql-connector-python/

.. note::

 #he MySQL Connector/Python DBAPI has had many issues since its release,
 #ome of which may remain unresolved, and the mysqlconnector dialect is
 #*not tested as part of SQLAlchemy's continuous integration**.
 #he recommended MySQL dialects are mysqlclient and PyMySQL.

"""  # noqa

import re

from .base import BIT
from .base import MySQLCompiler
from .base import MySQLDialect
from .base import MySQLIdentifierPreparer
from ... import processors
from ... import util


class MySQLCompiler_mysqlconnector(MySQLCompiler):
 #ef visit_mod_binary(self, binary, operator, **kw):
 #f self.dialect._mysqlconnector_double_percents:
 #eturn (
 #elf.process(binary.left, **kw)
 # " %% "
 # self.process(binary.right, **kw)
 #
 #lse:
 #eturn (
 #elf.process(binary.left, **kw)
 # " % "
 # self.process(binary.right, **kw)
 #

 #ef post_process_text(self, text):
 #f self.dialect._mysqlconnector_double_percents:
 #eturn text.replace("%", "%%")
 #lse:
 #eturn text

 #ef escape_literal_column(self, text):
 #f self.dialect._mysqlconnector_double_percents:
 #eturn text.replace("%", "%%")
 #lse:
 #eturn text


class MySQLIdentifierPreparer_mysqlconnector(MySQLIdentifierPreparer):
 #property
 #ef _double_percents(self):
 #eturn self.dialect._mysqlconnector_double_percents

 #_double_percents.setter
 #ef _double_percents(self, value):
 #ass

 #ef _escape_identifier(self, value):
 #alue = value.replace(self.escape_quote, self.escape_to_quote)
 #f self.dialect._mysqlconnector_double_percents:
 #eturn value.replace("%", "%%")
 #lse:
 #eturn value


class _myconnpyBIT(BIT):
 #ef result_processor(self, dialect, coltype):
 #""MySQL-connector already converts mysql bits, so."""

 #eturn None


class MySQLDialect_mysqlconnector(MySQLDialect):
 #river = "mysqlconnector"
 #upports_statement_cache = True

 #upports_unicode_binds = True

 #upports_sane_rowcount = True
 #upports_sane_multi_rowcount = True

 #upports_native_decimal = True

 #efault_paramstyle = "format"
 #tatement_compiler = MySQLCompiler_mysqlconnector

 #reparer = MySQLIdentifierPreparer_mysqlconnector

 #olspecs = util.update_copy(MySQLDialect.colspecs, {BIT: _myconnpyBIT})

 #ef __init__(self, *arg, **kw):
 #uper(MySQLDialect_mysqlconnector, self).__init__(*arg, **kw)

        # hack description encoding since mysqlconnector randomly
        # returns bytes or not
 #elf._description_decoder = (
 #rocessors.to_conditional_unicode_processor_factory
 #(self.description_encoding)

 #ef _check_unicode_description(self, connection):
        # hack description encoding since mysqlconnector randomly
        # returns bytes or not
 #eturn False

 #property
 #ef description_encoding(self):
        # total guess
 #eturn "latin-1"

 #util.memoized_property
 #ef supports_unicode_statements(self):
 #eturn util.py3k or self._mysqlconnector_version_info > (2, 0)

 #classmethod
 #ef dbapi(cls):
 #rom mysql import connector

 #eturn connector

 #ef do_ping(self, dbapi_connection):
 #ry:
 #bapi_connection.ping(False)
 #xcept self.dbapi.Error as err:
 #f self.is_disconnect(err, dbapi_connection, None):
 #eturn False
 #lse:
 #aise
 #lse:
 #eturn True

 #ef create_connect_args(self, url):
 #pts = url.translate_connect_args(username="user")

 #pts.update(url.query)

 #til.coerce_kw_type(opts, "allow_local_infile", bool)
 #til.coerce_kw_type(opts, "autocommit", bool)
 #til.coerce_kw_type(opts, "buffered", bool)
 #til.coerce_kw_type(opts, "compress", bool)
 #til.coerce_kw_type(opts, "connection_timeout", int)
 #til.coerce_kw_type(opts, "connect_timeout", int)
 #til.coerce_kw_type(opts, "consume_results", bool)
 #til.coerce_kw_type(opts, "force_ipv6", bool)
 #til.coerce_kw_type(opts, "get_warnings", bool)
 #til.coerce_kw_type(opts, "pool_reset_session", bool)
 #til.coerce_kw_type(opts, "pool_size", int)
 #til.coerce_kw_type(opts, "raise_on_warnings", bool)
 #til.coerce_kw_type(opts, "raw", bool)
 #til.coerce_kw_type(opts, "ssl_verify_cert", bool)
 #til.coerce_kw_type(opts, "use_pure", bool)
 #til.coerce_kw_type(opts, "use_unicode", bool)

        # unfortunately, MySQL/connector python refuses to release a
        # cursor without reading fully, so non-buffered isn't an option
 #pts.setdefault("buffered", True)

        # FOUND_ROWS must be set in ClientFlag to enable
        # supports_sane_rowcount.
 #f self.dbapi is not None:
 #ry:
 #rom mysql.connector.constants import ClientFlag

 #lient_flags = opts.get(
 #client_flags", ClientFlag.get_default()
 #
 #lient_flags |= ClientFlag.FOUND_ROWS
 #pts["client_flags"] = client_flags
 #xcept Exception:
 #ass
 #eturn [[], opts]

 #util.memoized_property
 #ef _mysqlconnector_version_info(self):
 #f self.dbapi and hasattr(self.dbapi, "__version__"):
 # = re.match(r"(\d+)\.(\d+)(?:\.(\d+))?", self.dbapi.__version__)
 #f m:
 #eturn tuple(int(x) for x in m.group(1, 2, 3) if x is not None)

 #util.memoized_property
 #ef _mysqlconnector_double_percents(self):
 #eturn not util.py3k and self._mysqlconnector_version_info < (2, 0)

 #ef _detect_charset(self, connection):
 #eturn connection.connection.charset

 #ef _extract_error_code(self, exception):
 #eturn exception.errno

 #ef is_disconnect(self, e, connection, cursor):
 #rrnos = (2006, 2013, 2014, 2045, 2055, 2048)
 #xceptions = (self.dbapi.OperationalError, self.dbapi.InterfaceError)
 #f isinstance(e, exceptions):
 #eturn (
 #.errno in errnos
 #r "MySQL Connection not available." in str(e)
 #r "Connection to MySQL is not available" in str(e)
 #
 #lse:
 #eturn False

 #ef _compat_fetchall(self, rp, charset=None):
 #eturn rp.fetchall()

 #ef _compat_fetchone(self, rp, charset=None):
 #eturn rp.fetchone()

 #isolation_lookup = set(
 #
 #SERIALIZABLE",
 #READ UNCOMMITTED",
 #READ COMMITTED",
 #REPEATABLE READ",
 #AUTOCOMMIT",
 #
 #

 #ef _set_isolation_level(self, connection, level):
 #f level == "AUTOCOMMIT":
 #onnection.autocommit = True
 #lse:
 #onnection.autocommit = False
 #uper(MySQLDialect_mysqlconnector, self)._set_isolation_level(
 #onnection, level
 #


dialect = MySQLDialect_mysqlconnector
