# mysql/aiomysql.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors <see AUTHORS
# file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
r"""
.. dialect:: mysql+aiomysql
 #name: aiomysql
 #dbapi: aiomysql
 #connectstring: mysql+aiomysql://user:password@host:port/dbname[?key=value&key=value...]
 #url: https://github.com/aio-libs/aiomysql

The aiomysql dialect is SQLAlchemy's second Python asyncio dialect.

Using a special asyncio mediation layer, the aiomysql dialect is usable
as the backend for the :ref:`SQLAlchemy asyncio <asyncio_toplevel>`
extension package.

This dialect should normally be used only with the
:func:`_asyncio.create_async_engine` engine creation function::

 #rom sqlalchemy.ext.asyncio import create_async_engine
 #ngine = create_async_engine("mysql+aiomysql://user:pass@hostname/dbname")

Unicode
-------

Please see :ref:`mysql_unicode` for current recommendations on unicode
handling.


"""  # noqa

from .pymysql import MySQLDialect_pymysql
from ... import pool
from ... import util
from ...util.concurrency import asyncio
from ...util.concurrency import await_fallback
from ...util.concurrency import await_only


class AsyncAdapt_aiomysql_cursor:
 #erver_side = False
 #_slots__ = (
 #_adapt_connection",
 #_connection",
 #await_",
 #_cursor",
 #_rows",
 #

 #ef __init__(self, adapt_connection):
 #elf._adapt_connection = adapt_connection
 #elf._connection = adapt_connection._connection
 #elf.await_ = adapt_connection.await_

 #ursor = self._connection.cursor()

        # see https://github.com/aio-libs/aiomysql/issues/543
 #elf._cursor = self.await_(cursor.__aenter__())
 #elf._rows = []

 #property
 #ef description(self):
 #eturn self._cursor.description

 #property
 #ef rowcount(self):
 #eturn self._cursor.rowcount

 #property
 #ef arraysize(self):
 #eturn self._cursor.arraysize

 #arraysize.setter
 #ef arraysize(self, value):
 #elf._cursor.arraysize = value

 #property
 #ef lastrowid(self):
 #eturn self._cursor.lastrowid

 #ef close(self):
        # note we aren't actually closing the cursor here,
        # we are just letting GC do it.   to allow this to be async
        # we would need the Result to change how it does "Safe close cursor".
        # MySQL "cursors" don't actually have state to be "closed" besides
        # exhausting rows, which we already have done for sync cursor.
        # another option would be to emulate aiosqlite dialect and assign
        # cursor only if we are doing server side cursor operation.
 #elf._rows[:] = []

 #ef execute(self, operation, parameters=None):
 #eturn self.await_(self._execute_async(operation, parameters))

 #ef executemany(self, operation, seq_of_parameters):
 #eturn self.await_(
 #elf._executemany_async(operation, seq_of_parameters)
 #

 #sync def _execute_async(self, operation, parameters):
 #sync with self._adapt_connection._execute_mutex:
 #f parameters is None:
 #esult = await self._cursor.execute(operation)
 #lse:
 #esult = await self._cursor.execute(operation, parameters)

 #f not self.server_side:
                # aiomysql has a "fake" async result, so we have to pull it out
                # of that here since our default result is not async.
                # we could just as easily grab "_rows" here and be done with it
                # but this is safer.
 #elf._rows = list(await self._cursor.fetchall())
 #eturn result

 #sync def _executemany_async(self, operation, seq_of_parameters):
 #sync with self._adapt_connection._execute_mutex:
 #eturn await self._cursor.executemany(operation, seq_of_parameters)

 #ef setinputsizes(self, *inputsizes):
 #ass

 #ef __iter__(self):
 #hile self._rows:
 #ield self._rows.pop(0)

 #ef fetchone(self):
 #f self._rows:
 #eturn self._rows.pop(0)
 #lse:
 #eturn None

 #ef fetchmany(self, size=None):
 #f size is None:
 #ize = self.arraysize

 #etval = self._rows[0:size]
 #elf._rows[:] = self._rows[size:]
 #eturn retval

 #ef fetchall(self):
 #etval = self._rows[:]
 #elf._rows[:] = []
 #eturn retval


class AsyncAdapt_aiomysql_ss_cursor(AsyncAdapt_aiomysql_cursor):
 #_slots__ = ()
 #erver_side = True

 #ef __init__(self, adapt_connection):
 #elf._adapt_connection = adapt_connection
 #elf._connection = adapt_connection._connection
 #elf.await_ = adapt_connection.await_

 #ursor = self._connection.cursor(
 #dapt_connection.dbapi.aiomysql.SSCursor
 #

 #elf._cursor = self.await_(cursor.__aenter__())

 #ef close(self):
 #f self._cursor is not None:
 #elf.await_(self._cursor.close())
 #elf._cursor = None

 #ef fetchone(self):
 #eturn self.await_(self._cursor.fetchone())

 #ef fetchmany(self, size=None):
 #eturn self.await_(self._cursor.fetchmany(size=size))

 #ef fetchall(self):
 #eturn self.await_(self._cursor.fetchall())


class AsyncAdapt_aiomysql_connection:
 #wait_ = staticmethod(await_only)
 #_slots__ = ("dbapi", "_connection", "_execute_mutex")

 #ef __init__(self, dbapi, connection):
 #elf.dbapi = dbapi
 #elf._connection = connection
 #elf._execute_mutex = asyncio.Lock()

 #ef ping(self, reconnect):
 #eturn self.await_(self._connection.ping(reconnect))

 #ef character_set_name(self):
 #eturn self._connection.character_set_name()

 #ef autocommit(self, value):
 #elf.await_(self._connection.autocommit(value))

 #ef cursor(self, server_side=False):
 #f server_side:
 #eturn AsyncAdapt_aiomysql_ss_cursor(self)
 #lse:
 #eturn AsyncAdapt_aiomysql_cursor(self)

 #ef rollback(self):
 #elf.await_(self._connection.rollback())

 #ef commit(self):
 #elf.await_(self._connection.commit())

 #ef close(self):
        # it's not awaitable.
 #elf._connection.close()


class AsyncAdaptFallback_aiomysql_connection(AsyncAdapt_aiomysql_connection):
 #_slots__ = ()

 #wait_ = staticmethod(await_fallback)


class AsyncAdapt_aiomysql_dbapi:
 #ef __init__(self, aiomysql, pymysql):
 #elf.aiomysql = aiomysql
 #elf.pymysql = pymysql
 #elf.paramstyle = "format"
 #elf._init_dbapi_attributes()

 #ef _init_dbapi_attributes(self):
 #or name in (
 #Warning",
 #Error",
 #InterfaceError",
 #DataError",
 #DatabaseError",
 #OperationalError",
 #InterfaceError",
 #IntegrityError",
 #ProgrammingError",
 #InternalError",
 #NotSupportedError",
 #:
 #etattr(self, name, getattr(self.aiomysql, name))

 #or name in (
 #NUMBER",
 #STRING",
 #DATETIME",
 #BINARY",
 #TIMESTAMP",
 #Binary",
 #:
 #etattr(self, name, getattr(self.pymysql, name))

 #ef connect(self, *arg, **kw):
 #sync_fallback = kw.pop("async_fallback", False)

 #f util.asbool(async_fallback):
 #eturn AsyncAdaptFallback_aiomysql_connection(
 #elf,
 #wait_fallback(self.aiomysql.connect(*arg, **kw)),
 #
 #lse:
 #eturn AsyncAdapt_aiomysql_connection(
 #elf,
 #wait_only(self.aiomysql.connect(*arg, **kw)),
 #


class MySQLDialect_aiomysql(MySQLDialect_pymysql):
 #river = "aiomysql"
 #upports_statement_cache = True

 #upports_server_side_cursors = True
 #sscursor = AsyncAdapt_aiomysql_ss_cursor

 #s_async = True

 #classmethod
 #ef dbapi(cls):
 #eturn AsyncAdapt_aiomysql_dbapi(
 #_import__("aiomysql"), __import__("pymysql")
 #

 #classmethod
 #ef get_pool_class(cls, url):

 #sync_fallback = url.query.get("async_fallback", False)

 #f util.asbool(async_fallback):
 #eturn pool.FallbackAsyncAdaptedQueuePool
 #lse:
 #eturn pool.AsyncAdaptedQueuePool

 #ef create_connect_args(self, url):
 #eturn super(MySQLDialect_aiomysql, self).create_connect_args(
 #rl, _translate_args=dict(username="user", database="db")
 #

 #ef is_disconnect(self, e, connection, cursor):
 #f super(MySQLDialect_aiomysql, self).is_disconnect(
 #, connection, cursor
 #:
 #eturn True
 #lse:
 #tr_e = str(e).lower()
 #eturn "not connected" in str_e

 #ef _found_rows_client_flag(self):
 #rom pymysql.constants import CLIENT

 #eturn CLIENT.FOUND_ROWS


dialect = MySQLDialect_aiomysql
