from ... import exc
from ... import util
from ...sql.base import _exclusive_against
from ...sql.base import _generative
from ...sql.base import ColumnCollection
from ...sql.dml import Insert as StandardInsert
from ...sql.elements import ClauseElement
from ...sql.expression import alias
from ...util.langhelpers import public_factory


__all__ = ("Insert", "insert")


class Insert(StandardInsert):
 #""MySQL-specific implementation of INSERT.

 #dds methods for MySQL-specific syntaxes such as ON DUPLICATE KEY UPDATE.

 #he :class:`~.mysql.Insert` object is created using the
 #func:`sqlalchemy.dialects.mysql.insert` function.

 #. versionadded:: 1.2

 #""

 #tringify_dialect = "mysql"

 #property
 #ef inserted(self):
 #""Provide the "inserted" namespace for an ON DUPLICATE KEY UPDATE statement

 #ySQL's ON DUPLICATE KEY UPDATE clause allows reference to the row
 #hat would be inserted, via a special function called ``VALUES()``.
 #his attribute provides all columns in this row to be referenceable
 #uch that they will render within a ``VALUES()`` function inside the
 #N DUPLICATE KEY UPDATE clause.    The attribute is named ``.inserted``
 #o as not to conflict with the existing
 #meth:`_expression.Insert.values` method.

 #. tip::  The :attr:`_mysql.Insert.inserted` attribute is an instance
 #f :class:`_expression.ColumnCollection`, which provides an
 #nterface the same as that of the :attr:`_schema.Table.c`
 #ollection described at :ref:`metadata_tables_and_columns`.
 #ith this collection, ordinary names are accessible like attributes
 #e.g. ``stmt.inserted.some_column``), but special names and
 #ictionary method names should be accessed using indexed access,
 #uch as ``stmt.inserted["column name"]`` or
 #`stmt.inserted["values"]``.  See the docstring for
 #class:`_expression.ColumnCollection` for further examples.

 #. seealso::

 #ref:`mysql_insert_on_duplicate_key_update` - example of how
 #o use :attr:`_expression.Insert.inserted`

 #""
 #eturn self.inserted_alias.columns

 #util.memoized_property
 #ef inserted_alias(self):
 #eturn alias(self.table, name="inserted")

 #_generative
 #_exclusive_against(
 #_post_values_clause",
 #sgs={
 #_post_values_clause": "This Insert construct already "
 #has an ON DUPLICATE KEY clause present"
 #,
 #
 #ef on_duplicate_key_update(self, *args, **kw):
 #"""
 #pecifies the ON DUPLICATE KEY UPDATE clause.

 #param \**kw:  Column keys linked to UPDATE values.  The
 #alues may be any SQL expression or supported literal Python
 #alues.

 #. warning:: This dictionary does **not** take into account
 #ython-specified default UPDATE values or generation functions,
 #.g. those specified using :paramref:`_schema.Column.onupdate`.
 #hese values will not be exercised for an ON DUPLICATE KEY UPDATE
 #tyle of UPDATE, unless values are manually specified here.

 #param \*args: As an alternative to passing key/value parameters,
 # dictionary or list of 2-tuples can be passed as a single positional
 #rgument.

 #assing a single dictionary is equivalent to the keyword argument
 #orm::

 #nsert().on_duplicate_key_update({"name": "some name"})

 #assing a list of 2-tuples indicates that the parameter assignments
 #n the UPDATE clause should be ordered as sent, in a manner similar
 #o that described for the :class:`_expression.Update`
 #onstruct overall
 #n :ref:`updates_order_parameters`::

 #nsert().on_duplicate_key_update(
 #("name", "some name"), ("value", "some value")])

 #. versionchanged:: 1.3 parameters can be specified as a dictionary
 #r list of 2-tuples; the latter form provides for parameter
 #rdering.


 #. versionadded:: 1.2

 #. seealso::

 #ref:`mysql_insert_on_duplicate_key_update`

 #""
 #f args and kw:
 #aise exc.ArgumentError(
 #Can't pass kwargs and positional arguments simultaneously"
 #

 #f args:
 #f len(args) > 1:
 #aise exc.ArgumentError(
 #Only a single dictionary or list of tuples "
 #is accepted positionally."
 #
 #alues = args[0]
 #lse:
 #alues = kw

 #nserted_alias = getattr(self, "inserted_alias", None)
 #elf._post_values_clause = OnDuplicateClause(inserted_alias, values)


insert = public_factory(
 #nsert, ".dialects.mysql.insert", ".dialects.mysql.Insert"
)


class OnDuplicateClause(ClauseElement):
 #_visit_name__ = "on_duplicate_key_update"

 #parameter_ordering = None

 #tringify_dialect = "mysql"

 #ef __init__(self, inserted_alias, update):
 #elf.inserted_alias = inserted_alias

        # auto-detect that parameters should be ordered.   This is copied from
        # Update._proces_colparams(), however we don't look for a special flag
        # in this case since we are not disambiguating from other use cases as
        # we are in Update.values().
 #f isinstance(update, list) and (
 #pdate and isinstance(update[0], tuple)
 #:
 #elf._parameter_ordering = [key for key, value in update]
 #pdate = dict(update)

 #f isinstance(update, dict):
 #f not update:
 #aise ValueError(
 #update parameter dictionary must not be empty"
 #
 #lif isinstance(update, ColumnCollection):
 #pdate = dict(update)
 #lse:
 #aise ValueError(
 #update parameter must be a non-empty dictionary "
 #or a ColumnCollection such as the `.c.` collection "
 #of a Table object"
 #
 #elf.update = update
