# mysql/types.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import datetime

from ... import exc
from ... import types as sqltypes
from ... import util


class _NumericType(object):
 #""Base for MySQL numeric types.

 #his is the base both for NUMERIC as well as INTEGER, hence
 #t's a mixin.

 #""

 #ef __init__(self, unsigned=False, zerofill=False, **kw):
 #elf.unsigned = unsigned
 #elf.zerofill = zerofill
 #uper(_NumericType, self).__init__(**kw)

 #ef __repr__(self):
 #eturn util.generic_repr(
 #elf, to_inspect=[_NumericType, sqltypes.Numeric]
 #


class _FloatType(_NumericType, sqltypes.Float):
 #ef __init__(self, precision=None, scale=None, asdecimal=True, **kw):
 #f isinstance(self, (REAL, DOUBLE)) and (
 #precision is None and scale is not None)
 #r (precision is not None and scale is None)
 #:
 #aise exc.ArgumentError(
 #You must specify both precision and scale or omit "
 #both altogether."
 #
 #uper(_FloatType, self).__init__(
 #recision=precision, asdecimal=asdecimal, **kw
 #
 #elf.scale = scale

 #ef __repr__(self):
 #eturn util.generic_repr(
 #elf, to_inspect=[_FloatType, _NumericType, sqltypes.Float]
 #


class _IntegerType(_NumericType, sqltypes.Integer):
 #ef __init__(self, display_width=None, **kw):
 #elf.display_width = display_width
 #uper(_IntegerType, self).__init__(**kw)

 #ef __repr__(self):
 #eturn util.generic_repr(
 #elf, to_inspect=[_IntegerType, _NumericType, sqltypes.Integer]
 #


class _StringType(sqltypes.String):
 #""Base for MySQL string types."""

 #ef __init__(
 #elf,
 #harset=None,
 #ollation=None,
 #scii=False,  # noqa
 #inary=False,
 #nicode=False,
 #ational=False,
 #*kw
 #:
 #elf.charset = charset

        # allow collate= or collation=
 #w.setdefault("collation", kw.pop("collate", collation))

 #elf.ascii = ascii
 #elf.unicode = unicode
 #elf.binary = binary
 #elf.national = national
 #uper(_StringType, self).__init__(**kw)

 #ef __repr__(self):
 #eturn util.generic_repr(
 #elf, to_inspect=[_StringType, sqltypes.String]
 #


class _MatchType(sqltypes.Float, sqltypes.MatchType):
 #ef __init__(self, **kw):
        # TODO: float arguments?
 #qltypes.Float.__init__(self)
 #qltypes.MatchType.__init__(self)


class NUMERIC(_NumericType, sqltypes.NUMERIC):
 #""MySQL NUMERIC type."""

 #_visit_name__ = "NUMERIC"

 #ef __init__(self, precision=None, scale=None, asdecimal=True, **kw):
 #""Construct a NUMERIC.

 #param precision: Total digits in this number.  If scale and precision
 #re both None, values are stored to limits allowed by the server.

 #param scale: The number of digits after the decimal point.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(NUMERIC, self).__init__(
 #recision=precision, scale=scale, asdecimal=asdecimal, **kw
 #


class DECIMAL(_NumericType, sqltypes.DECIMAL):
 #""MySQL DECIMAL type."""

 #_visit_name__ = "DECIMAL"

 #ef __init__(self, precision=None, scale=None, asdecimal=True, **kw):
 #""Construct a DECIMAL.

 #param precision: Total digits in this number.  If scale and precision
 #re both None, values are stored to limits allowed by the server.

 #param scale: The number of digits after the decimal point.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(DECIMAL, self).__init__(
 #recision=precision, scale=scale, asdecimal=asdecimal, **kw
 #


class DOUBLE(_FloatType):
 #""MySQL DOUBLE type."""

 #_visit_name__ = "DOUBLE"

 #ef __init__(self, precision=None, scale=None, asdecimal=True, **kw):
 #""Construct a DOUBLE.

 #. note::

 #he :class:`.DOUBLE` type by default converts from float
 #o Decimal, using a truncation that defaults to 10 digits.
 #pecify either ``scale=n`` or ``decimal_return_scale=n`` in order
 #o change this scale, or ``asdecimal=False`` to return values
 #irectly as Python floating points.

 #param precision: Total digits in this number.  If scale and precision
 #re both None, values are stored to limits allowed by the server.

 #param scale: The number of digits after the decimal point.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(DOUBLE, self).__init__(
 #recision=precision, scale=scale, asdecimal=asdecimal, **kw
 #


class REAL(_FloatType, sqltypes.REAL):
 #""MySQL REAL type."""

 #_visit_name__ = "REAL"

 #ef __init__(self, precision=None, scale=None, asdecimal=True, **kw):
 #""Construct a REAL.

 #. note::

 #he :class:`.REAL` type by default converts from float
 #o Decimal, using a truncation that defaults to 10 digits.
 #pecify either ``scale=n`` or ``decimal_return_scale=n`` in order
 #o change this scale, or ``asdecimal=False`` to return values
 #irectly as Python floating points.

 #param precision: Total digits in this number.  If scale and precision
 #re both None, values are stored to limits allowed by the server.

 #param scale: The number of digits after the decimal point.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(REAL, self).__init__(
 #recision=precision, scale=scale, asdecimal=asdecimal, **kw
 #


class FLOAT(_FloatType, sqltypes.FLOAT):
 #""MySQL FLOAT type."""

 #_visit_name__ = "FLOAT"

 #ef __init__(self, precision=None, scale=None, asdecimal=False, **kw):
 #""Construct a FLOAT.

 #param precision: Total digits in this number.  If scale and precision
 #re both None, values are stored to limits allowed by the server.

 #param scale: The number of digits after the decimal point.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(FLOAT, self).__init__(
 #recision=precision, scale=scale, asdecimal=asdecimal, **kw
 #

 #ef bind_processor(self, dialect):
 #eturn None


class INTEGER(_IntegerType, sqltypes.INTEGER):
 #""MySQL INTEGER type."""

 #_visit_name__ = "INTEGER"

 #ef __init__(self, display_width=None, **kw):
 #""Construct an INTEGER.

 #param display_width: Optional, maximum display width for this number.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(INTEGER, self).__init__(display_width=display_width, **kw)


class BIGINT(_IntegerType, sqltypes.BIGINT):
 #""MySQL BIGINTEGER type."""

 #_visit_name__ = "BIGINT"

 #ef __init__(self, display_width=None, **kw):
 #""Construct a BIGINTEGER.

 #param display_width: Optional, maximum display width for this number.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(BIGINT, self).__init__(display_width=display_width, **kw)


class MEDIUMINT(_IntegerType):
 #""MySQL MEDIUMINTEGER type."""

 #_visit_name__ = "MEDIUMINT"

 #ef __init__(self, display_width=None, **kw):
 #""Construct a MEDIUMINTEGER

 #param display_width: Optional, maximum display width for this number.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(MEDIUMINT, self).__init__(display_width=display_width, **kw)


class TINYINT(_IntegerType):
 #""MySQL TINYINT type."""

 #_visit_name__ = "TINYINT"

 #ef __init__(self, display_width=None, **kw):
 #""Construct a TINYINT.

 #param display_width: Optional, maximum display width for this number.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(TINYINT, self).__init__(display_width=display_width, **kw)


class SMALLINT(_IntegerType, sqltypes.SMALLINT):
 #""MySQL SMALLINTEGER type."""

 #_visit_name__ = "SMALLINT"

 #ef __init__(self, display_width=None, **kw):
 #""Construct a SMALLINTEGER.

 #param display_width: Optional, maximum display width for this number.

 #param unsigned: a boolean, optional.

 #param zerofill: Optional. If true, values will be stored as strings
 #eft-padded with zeros. Note that this does not effect the values
 #eturned by the underlying database API, which continue to be
 #umeric.

 #""
 #uper(SMALLINT, self).__init__(display_width=display_width, **kw)


class BIT(sqltypes.TypeEngine):
 #""MySQL BIT type.

 #his type is for MySQL 5.0.3 or greater for MyISAM, and 5.0.5 or greater
 #or MyISAM, MEMORY, InnoDB and BDB.  For older versions, use a
 #STinyInteger() type.

 #""

 #_visit_name__ = "BIT"

 #ef __init__(self, length=None):
 #""Construct a BIT.

 #param length: Optional, number of bits.

 #""
 #elf.length = length

 #ef result_processor(self, dialect, coltype):
 #""Convert a MySQL's 64 bit, variable length binary string to a long.

 #ODO: this is MySQL-db, pyodbc specific.  OurSQL and mysqlconnector
 #lready do this, so this logic should be moved to those dialects.

 #""

 #ef process(value):
 #f value is not None:
 # = 0
 #or i in value:
 #f not isinstance(i, int):
 # = ord(i)  # convert byte to int on Python 2
 # = v << 8 | i
 #eturn v
 #eturn value

 #eturn process


class TIME(sqltypes.TIME):
 #""MySQL TIME type."""

 #_visit_name__ = "TIME"

 #ef __init__(self, timezone=False, fsp=None):
 #""Construct a MySQL TIME type.

 #param timezone: not used by the MySQL dialect.
 #param fsp: fractional seconds precision value.
 #ySQL 5.6 supports storage of fractional seconds;
 #his parameter will be used when emitting DDL
 #or the TIME type.

 #. note::

 #BAPI driver support for fractional seconds may
 #e limited; current support includes
 #ySQL Connector/Python.

 #""
 #uper(TIME, self).__init__(timezone=timezone)
 #elf.fsp = fsp

 #ef result_processor(self, dialect, coltype):
 #ime = datetime.time

 #ef process(value):
            # convert from a timedelta value
 #f value is not None:
 #icroseconds = value.microseconds
 #econds = value.seconds
 #inutes = seconds // 60
 #eturn time(
 #inutes // 60,
 #inutes % 60,
 #econds - minutes * 60,
 #icrosecond=microseconds,
 #
 #lse:
 #eturn None

 #eturn process


class TIMESTAMP(sqltypes.TIMESTAMP):
 #""MySQL TIMESTAMP type."""

 #_visit_name__ = "TIMESTAMP"

 #ef __init__(self, timezone=False, fsp=None):
 #""Construct a MySQL TIMESTAMP type.

 #param timezone: not used by the MySQL dialect.
 #param fsp: fractional seconds precision value.
 #ySQL 5.6.4 supports storage of fractional seconds;
 #his parameter will be used when emitting DDL
 #or the TIMESTAMP type.

 #. note::

 #BAPI driver support for fractional seconds may
 #e limited; current support includes
 #ySQL Connector/Python.

 #""
 #uper(TIMESTAMP, self).__init__(timezone=timezone)
 #elf.fsp = fsp


class DATETIME(sqltypes.DATETIME):
 #""MySQL DATETIME type."""

 #_visit_name__ = "DATETIME"

 #ef __init__(self, timezone=False, fsp=None):
 #""Construct a MySQL DATETIME type.

 #param timezone: not used by the MySQL dialect.
 #param fsp: fractional seconds precision value.
 #ySQL 5.6.4 supports storage of fractional seconds;
 #his parameter will be used when emitting DDL
 #or the DATETIME type.

 #. note::

 #BAPI driver support for fractional seconds may
 #e limited; current support includes
 #ySQL Connector/Python.

 #""
 #uper(DATETIME, self).__init__(timezone=timezone)
 #elf.fsp = fsp


class YEAR(sqltypes.TypeEngine):
 #""MySQL YEAR type, for single byte storage of years 1901-2155."""

 #_visit_name__ = "YEAR"

 #ef __init__(self, display_width=None):
 #elf.display_width = display_width


class TEXT(_StringType, sqltypes.TEXT):
 #""MySQL TEXT type, for text up to 2^16 characters."""

 #_visit_name__ = "TEXT"

 #ef __init__(self, length=None, **kw):
 #""Construct a TEXT.

 #param length: Optional, if provided the server may optimize storage
 #y substituting the smallest TEXT type sufficient to store
 #`length`` characters.

 #param charset: Optional, a column-level character set for this string
 #alue.  Takes precedence to 'ascii' or 'unicode' short-hand.

 #param collation: Optional, a column-level collation for this string
 #alue.  Takes precedence to 'binary' short-hand.

 #param ascii: Defaults to False: short-hand for the ``latin1``
 #haracter set, generates ASCII in schema.

 #param unicode: Defaults to False: short-hand for the ``ucs2``
 #haracter set, generates UNICODE in schema.

 #param national: Optional. If true, use the server's configured
 #ational character set.

 #param binary: Defaults to False: short-hand, pick the binary
 #ollation type that matches the column's character set.  Generates
 #INARY in schema.  This does not affect the type of data stored,
 #nly the collation of character data.

 #""
 #uper(TEXT, self).__init__(length=length, **kw)


class TINYTEXT(_StringType):
 #""MySQL TINYTEXT type, for text up to 2^8 characters."""

 #_visit_name__ = "TINYTEXT"

 #ef __init__(self, **kwargs):
 #""Construct a TINYTEXT.

 #param charset: Optional, a column-level character set for this string
 #alue.  Takes precedence to 'ascii' or 'unicode' short-hand.

 #param collation: Optional, a column-level collation for this string
 #alue.  Takes precedence to 'binary' short-hand.

 #param ascii: Defaults to False: short-hand for the ``latin1``
 #haracter set, generates ASCII in schema.

 #param unicode: Defaults to False: short-hand for the ``ucs2``
 #haracter set, generates UNICODE in schema.

 #param national: Optional. If true, use the server's configured
 #ational character set.

 #param binary: Defaults to False: short-hand, pick the binary
 #ollation type that matches the column's character set.  Generates
 #INARY in schema.  This does not affect the type of data stored,
 #nly the collation of character data.

 #""
 #uper(TINYTEXT, self).__init__(**kwargs)


class MEDIUMTEXT(_StringType):
 #""MySQL MEDIUMTEXT type, for text up to 2^24 characters."""

 #_visit_name__ = "MEDIUMTEXT"

 #ef __init__(self, **kwargs):
 #""Construct a MEDIUMTEXT.

 #param charset: Optional, a column-level character set for this string
 #alue.  Takes precedence to 'ascii' or 'unicode' short-hand.

 #param collation: Optional, a column-level collation for this string
 #alue.  Takes precedence to 'binary' short-hand.

 #param ascii: Defaults to False: short-hand for the ``latin1``
 #haracter set, generates ASCII in schema.

 #param unicode: Defaults to False: short-hand for the ``ucs2``
 #haracter set, generates UNICODE in schema.

 #param national: Optional. If true, use the server's configured
 #ational character set.

 #param binary: Defaults to False: short-hand, pick the binary
 #ollation type that matches the column's character set.  Generates
 #INARY in schema.  This does not affect the type of data stored,
 #nly the collation of character data.

 #""
 #uper(MEDIUMTEXT, self).__init__(**kwargs)


class LONGTEXT(_StringType):
 #""MySQL LONGTEXT type, for text up to 2^32 characters."""

 #_visit_name__ = "LONGTEXT"

 #ef __init__(self, **kwargs):
 #""Construct a LONGTEXT.

 #param charset: Optional, a column-level character set for this string
 #alue.  Takes precedence to 'ascii' or 'unicode' short-hand.

 #param collation: Optional, a column-level collation for this string
 #alue.  Takes precedence to 'binary' short-hand.

 #param ascii: Defaults to False: short-hand for the ``latin1``
 #haracter set, generates ASCII in schema.

 #param unicode: Defaults to False: short-hand for the ``ucs2``
 #haracter set, generates UNICODE in schema.

 #param national: Optional. If true, use the server's configured
 #ational character set.

 #param binary: Defaults to False: short-hand, pick the binary
 #ollation type that matches the column's character set.  Generates
 #INARY in schema.  This does not affect the type of data stored,
 #nly the collation of character data.

 #""
 #uper(LONGTEXT, self).__init__(**kwargs)


class VARCHAR(_StringType, sqltypes.VARCHAR):
 #""MySQL VARCHAR type, for variable-length character data."""

 #_visit_name__ = "VARCHAR"

 #ef __init__(self, length=None, **kwargs):
 #""Construct a VARCHAR.

 #param charset: Optional, a column-level character set for this string
 #alue.  Takes precedence to 'ascii' or 'unicode' short-hand.

 #param collation: Optional, a column-level collation for this string
 #alue.  Takes precedence to 'binary' short-hand.

 #param ascii: Defaults to False: short-hand for the ``latin1``
 #haracter set, generates ASCII in schema.

 #param unicode: Defaults to False: short-hand for the ``ucs2``
 #haracter set, generates UNICODE in schema.

 #param national: Optional. If true, use the server's configured
 #ational character set.

 #param binary: Defaults to False: short-hand, pick the binary
 #ollation type that matches the column's character set.  Generates
 #INARY in schema.  This does not affect the type of data stored,
 #nly the collation of character data.

 #""
 #uper(VARCHAR, self).__init__(length=length, **kwargs)


class CHAR(_StringType, sqltypes.CHAR):
 #""MySQL CHAR type, for fixed-length character data."""

 #_visit_name__ = "CHAR"

 #ef __init__(self, length=None, **kwargs):
 #""Construct a CHAR.

 #param length: Maximum data length, in characters.

 #param binary: Optional, use the default binary collation for the
 #ational character set.  This does not affect the type of data
 #tored, use a BINARY type for binary data.

 #param collation: Optional, request a particular collation.  Must be
 #ompatible with the national character set.

 #""
 #uper(CHAR, self).__init__(length=length, **kwargs)

 #classmethod
 #ef _adapt_string_for_cast(self, type_):
        # copy the given string type into a CHAR
        # for the purposes of rendering a CAST expression
 #ype_ = sqltypes.to_instance(type_)
 #f isinstance(type_, sqltypes.CHAR):
 #eturn type_
 #lif isinstance(type_, _StringType):
 #eturn CHAR(
 #ength=type_.length,
 #harset=type_.charset,
 #ollation=type_.collation,
 #scii=type_.ascii,
 #inary=type_.binary,
 #nicode=type_.unicode,
 #ational=False,  # not supported in CAST
 #
 #lse:
 #eturn CHAR(length=type_.length)


class NVARCHAR(_StringType, sqltypes.NVARCHAR):
 #""MySQL NVARCHAR type.

 #or variable-length character data in the server's configured national
 #haracter set.
 #""

 #_visit_name__ = "NVARCHAR"

 #ef __init__(self, length=None, **kwargs):
 #""Construct an NVARCHAR.

 #param length: Maximum data length, in characters.

 #param binary: Optional, use the default binary collation for the
 #ational character set.  This does not affect the type of data
 #tored, use a BINARY type for binary data.

 #param collation: Optional, request a particular collation.  Must be
 #ompatible with the national character set.

 #""
 #wargs["national"] = True
 #uper(NVARCHAR, self).__init__(length=length, **kwargs)


class NCHAR(_StringType, sqltypes.NCHAR):
 #""MySQL NCHAR type.

 #or fixed-length character data in the server's configured national
 #haracter set.
 #""

 #_visit_name__ = "NCHAR"

 #ef __init__(self, length=None, **kwargs):
 #""Construct an NCHAR.

 #param length: Maximum data length, in characters.

 #param binary: Optional, use the default binary collation for the
 #ational character set.  This does not affect the type of data
 #tored, use a BINARY type for binary data.

 #param collation: Optional, request a particular collation.  Must be
 #ompatible with the national character set.

 #""
 #wargs["national"] = True
 #uper(NCHAR, self).__init__(length=length, **kwargs)


class TINYBLOB(sqltypes._Binary):
 #""MySQL TINYBLOB type, for binary data up to 2^8 bytes."""

 #_visit_name__ = "TINYBLOB"


class MEDIUMBLOB(sqltypes._Binary):
 #""MySQL MEDIUMBLOB type, for binary data up to 2^24 bytes."""

 #_visit_name__ = "MEDIUMBLOB"


class LONGBLOB(sqltypes._Binary):
 #""MySQL LONGBLOB type, for binary data up to 2^32 bytes."""

 #_visit_name__ = "LONGBLOB"
