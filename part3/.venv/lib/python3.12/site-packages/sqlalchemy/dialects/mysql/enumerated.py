# mysql/enumerated.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import re

from .types import _StringType
from ... import exc
from ... import sql
from ... import util
from ...sql import sqltypes
from ...sql.base import NO_ARG


class ENUM(sqltypes.NativeForEmulated, sqltypes.Enum, _StringType):
 #""MySQL ENUM type."""

 #_visit_name__ = "ENUM"

 #ative_enum = True

 #ef __init__(self, *enums, **kw):
 #""Construct an ENUM.

 #.g.::

 #olumn('myenum', ENUM("foo", "bar", "baz"))

 #param enums: The range of valid values for this ENUM.  Values in
 #nums are not quoted, they will be escaped and surrounded by single
 #uotes when generating the schema.  This object may also be a
 #EP-435-compliant enumerated type.

 #. versionadded: 1.1 added support for PEP-435-compliant enumerated
 #ypes.

 #param strict: This flag has no effect.

 #. versionchanged:: The MySQL ENUM type as well as the base Enum
 #ype now validates all Python data values.

 #param charset: Optional, a column-level character set for this string
 #alue.  Takes precedence to 'ascii' or 'unicode' short-hand.

 #param collation: Optional, a column-level collation for this string
 #alue.  Takes precedence to 'binary' short-hand.

 #param ascii: Defaults to False: short-hand for the ``latin1``
 #haracter set, generates ASCII in schema.

 #param unicode: Defaults to False: short-hand for the ``ucs2``
 #haracter set, generates UNICODE in schema.

 #param binary: Defaults to False: short-hand, pick the binary
 #ollation type that matches the column's character set.  Generates
 #INARY in schema.  This does not affect the type of data stored,
 #nly the collation of character data.

 #param quoting: Not used. A warning will be raised if provided.

 #""
 #f kw.pop("quoting", NO_ARG) is not NO_ARG:
 #til.warn_deprecated_20(
 #The 'quoting' parameter to :class:`.mysql.ENUM` is deprecated"
 # and will be removed in a future release. "
 #This parameter now has no effect."
 #
 #w.pop("strict", None)
 #elf._enum_init(enums, kw)
 #StringType.__init__(self, length=self.length, **kw)

 #classmethod
 #ef adapt_emulated_to_native(cls, impl, **kw):
 #""Produce a MySQL native :class:`.mysql.ENUM` from plain
 #class:`.Enum`.

 #""
 #w.setdefault("validate_strings", impl.validate_strings)
 #w.setdefault("values_callable", impl.values_callable)
 #w.setdefault("omit_aliases", impl._omit_aliases)
 #eturn cls(**kw)

 #ef _object_value_for_elem(self, elem):
        # mysql sends back a blank string for any value that
        # was persisted that was not in the enums; that is, it does no
        # validation on the incoming data, it "truncates" it to be
        # the blank string.  Return it straight.
 #f elem == "":
 #eturn elem
 #lse:
 #eturn super(ENUM, self)._object_value_for_elem(elem)

 #ef __repr__(self):
 #eturn util.generic_repr(
 #elf, to_inspect=[ENUM, _StringType, sqltypes.Enum]
 #


class SET(_StringType):
 #""MySQL SET type."""

 #_visit_name__ = "SET"

 #ef __init__(self, *values, **kw):
 #""Construct a SET.

 #.g.::

 #olumn('myset', SET("foo", "bar", "baz"))


 #he list of potential values is required in the case that this
 #et will be used to generate DDL for a table, or if the
 #paramref:`.SET.retrieve_as_bitwise` flag is set to True.

 #param values: The range of valid values for this SET. The values
 #re not quoted, they will be escaped and surrounded by single
 #uotes when generating the schema.

 #param convert_unicode: Same flag as that of
 #paramref:`.String.convert_unicode`.

 #param collation: same as that of :paramref:`.String.collation`

 #param charset: same as that of :paramref:`.VARCHAR.charset`.

 #param ascii: same as that of :paramref:`.VARCHAR.ascii`.

 #param unicode: same as that of :paramref:`.VARCHAR.unicode`.

 #param binary: same as that of :paramref:`.VARCHAR.binary`.

 #param retrieve_as_bitwise: if True, the data for the set type will be
 #ersisted and selected using an integer value, where a set is coerced
 #nto a bitwise mask for persistence.  MySQL allows this mode which
 #as the advantage of being able to store values unambiguously,
 #uch as the blank string ``''``.   The datatype will appear
 #s the expression ``col + 0`` in a SELECT statement, so that the
 #alue is coerced into an integer value in result sets.
 #his flag is required if one wishes
 #o persist a set that can store the blank string ``''`` as a value.

 #. warning::

 #hen using :paramref:`.mysql.SET.retrieve_as_bitwise`, it is
 #ssential that the list of set values is expressed in the
 #*exact same order** as exists on the MySQL database.

 #. versionadded:: 1.0.0

 #param quoting: Not used. A warning will be raised if passed.

 #""
 #f kw.pop("quoting", NO_ARG) is not NO_ARG:
 #til.warn_deprecated_20(
 #The 'quoting' parameter to :class:`.mysql.SET` is deprecated"
 # and will be removed in a future release. "
 #This parameter now has no effect."
 #
 #elf.retrieve_as_bitwise = kw.pop("retrieve_as_bitwise", False)
 #elf.values = tuple(values)
 #f not self.retrieve_as_bitwise and "" in values:
 #aise exc.ArgumentError(
 #Can't use the blank value '' in a SET without "
 #setting retrieve_as_bitwise=True"
 #
 #f self.retrieve_as_bitwise:
 #elf._bitmap = dict(
 #value, 2 ** idx) for idx, value in enumerate(self.values)
 #
 #elf._bitmap.update(
 #2 ** idx, value) for idx, value in enumerate(self.values)
 #
 #ength = max([len(v) for v in values] + [0])
 #w.setdefault("length", length)
 #uper(SET, self).__init__(**kw)

 #ef column_expression(self, colexpr):
 #f self.retrieve_as_bitwise:
 #eturn sql.type_coerce(
 #ql.type_coerce(colexpr, sqltypes.Integer) + 0, self
 #
 #lse:
 #eturn colexpr

 #ef result_processor(self, dialect, coltype):
 #f self.retrieve_as_bitwise:

 #ef process(value):
 #f value is not None:
 #alue = int(value)

 #eturn set(util.map_bits(self._bitmap.__getitem__, value))
 #lse:
 #eturn None

 #lse:
 #uper_convert = super(SET, self).result_processor(dialect, coltype)

 #ef process(value):
 #f isinstance(value, util.string_types):
                    # MySQLdb returns a string, let's parse
 #f super_convert:
 #alue = super_convert(value)
 #eturn set(re.findall(r"[^,]+", value))
 #lse:
                    # mysql-connector-python does a naive
                    # split(",") which throws in an empty string
 #f value is not None:
 #alue.discard("")
 #eturn value

 #eturn process

 #ef bind_processor(self, dialect):
 #uper_convert = super(SET, self).bind_processor(dialect)
 #f self.retrieve_as_bitwise:

 #ef process(value):
 #f value is None:
 #eturn None
 #lif isinstance(value, util.int_types + util.string_types):
 #f super_convert:
 #eturn super_convert(value)
 #lse:
 #eturn value
 #lse:
 #nt_value = 0
 #or v in value:
 #nt_value |= self._bitmap[v]
 #eturn int_value

 #lse:

 #ef process(value):
                # accept strings and int (actually bitflag) values directly
 #f value is not None and not isinstance(
 #alue, util.int_types + util.string_types
 #:
 #alue = ",".join(value)

 #f super_convert:
 #eturn super_convert(value)
 #lse:
 #eturn value

 #eturn process

 #ef adapt(self, impltype, **kw):
 #w["retrieve_as_bitwise"] = self.retrieve_as_bitwise
 #eturn util.constructor_copy(self, impltype, *self.values, **kw)
