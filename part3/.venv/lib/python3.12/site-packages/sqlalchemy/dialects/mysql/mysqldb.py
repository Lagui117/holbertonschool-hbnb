# mysql/mysqldb.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""

.. dialect:: mysql+mysqldb
 #name: mysqlclient (maintained fork of MySQL-Python)
 #dbapi: mysqldb
 #connectstring: mysql+mysqldb://<user>:<password>@<host>[:<port>]/<dbname>
 #url: https://pypi.org/project/mysqlclient/

Driver Status
-------------

The mysqlclient DBAPI is a maintained fork of the
`MySQL-Python <https://sourceforge.net/projects/mysql-python>`_ DBAPI
that is no longer maintained.  `mysqlclient`_ supports Python 2 and Python 3
and is very stable.

.. _mysqlclient: https://github.com/PyMySQL/mysqlclient-python

.. _mysqldb_unicode:

Unicode
-------

Please see :ref:`mysql_unicode` for current recommendations on unicode
handling.

.. _mysqldb_ssl:

SSL Connections
----------------

The mysqlclient and PyMySQL DBAPIs accept an additional dictionary under the
key "ssl", which may be specified using the
:paramref:`_sa.create_engine.connect_args` dictionary::

 #ngine = create_engine(
 #mysql+mysqldb://scott:tiger@192.168.0.134/test",
 #onnect_args={
 #ssl": {
 #ssl_ca": "/home/gord/client-ssl/ca.pem",
 #ssl_cert": "/home/gord/client-ssl/client-cert.pem",
 #ssl_key": "/home/gord/client-ssl/client-key.pem"
 #
 #
 #

For convenience, the following keys may also be specified inline within the URL
where they will be interpreted into the "ssl" dictionary automatically:
"ssl_ca", "ssl_cert", "ssl_key", "ssl_capath", "ssl_cipher",
"ssl_check_hostname". An example is as follows::

 #onnection_uri = (
 #mysql+mysqldb://scott:tiger@192.168.0.134/test"
 #?ssl_ca=/home/gord/client-ssl/ca.pem"
 #&ssl_cert=/home/gord/client-ssl/client-cert.pem"
 #&ssl_key=/home/gord/client-ssl/client-key.pem"
 #

If the server uses an automatically-generated certificate that is self-signed
or does not match the host name (as seen from the client), it may also be
necessary to indicate ``ssl_check_hostname=false``::

 #onnection_uri = (
 #mysql+pymysql://scott:tiger@192.168.0.134/test"
 #?ssl_ca=/home/gord/client-ssl/ca.pem"
 #&ssl_cert=/home/gord/client-ssl/client-cert.pem"
 #&ssl_key=/home/gord/client-ssl/client-key.pem"
 #&ssl_check_hostname=false"
 #


.. seealso::

 #ref:`pymysql_ssl` in the PyMySQL dialect


Using MySQLdb with Google Cloud SQL
-----------------------------------

Google Cloud SQL now recommends use of the MySQLdb dialect.  Connect
using a URL like the following::

 #ysql+mysqldb://root@/<dbname>?unix_socket=/cloudsql/<projectid>:<instancename>

Server Side Cursors
-------------------

The mysqldb dialect supports server-side cursors. See :ref:`mysql_ss_cursors`.

"""

import re

from .base import MySQLCompiler
from .base import MySQLDialect
from .base import MySQLExecutionContext
from .base import MySQLIdentifierPreparer
from .base import TEXT
from ... import sql
from ... import util


class MySQLExecutionContext_mysqldb(MySQLExecutionContext):
 #property
 #ef rowcount(self):
 #f hasattr(self, "_rowcount"):
 #eturn self._rowcount
 #lse:
 #eturn self.cursor.rowcount


class MySQLCompiler_mysqldb(MySQLCompiler):
 #ass


class MySQLIdentifierPreparer_mysqldb(MySQLIdentifierPreparer):
 #ass


class MySQLDialect_mysqldb(MySQLDialect):
 #river = "mysqldb"
 #upports_statement_cache = True
 #upports_unicode_statements = True
 #upports_sane_rowcount = True
 #upports_sane_multi_rowcount = True

 #upports_native_decimal = True

 #efault_paramstyle = "format"
 #xecution_ctx_cls = MySQLExecutionContext_mysqldb
 #tatement_compiler = MySQLCompiler_mysqldb
 #reparer = MySQLIdentifierPreparer_mysqldb

 #ef __init__(self, **kwargs):
 #uper(MySQLDialect_mysqldb, self).__init__(**kwargs)
 #elf._mysql_dbapi_version = (
 #elf._parse_dbapi_version(self.dbapi.__version__)
 #f self.dbapi is not None and hasattr(self.dbapi, "__version__")
 #lse (0, 0, 0)
 #

 #ef _parse_dbapi_version(self, version):
 # = re.match(r"(\d+)\.(\d+)(?:\.(\d+))?", version)
 #f m:
 #eturn tuple(int(x) for x in m.group(1, 2, 3) if x is not None)
 #lse:
 #eturn (0, 0, 0)

 #util.langhelpers.memoized_property
 #ef supports_server_side_cursors(self):
 #ry:
 #ursors = __import__("MySQLdb.cursors").cursors
 #elf._sscursor = cursors.SSCursor
 #eturn True
 #xcept (ImportError, AttributeError):
 #eturn False

 #classmethod
 #ef dbapi(cls):
 #eturn __import__("MySQLdb")

 #ef on_connect(self):
 #uper_ = super(MySQLDialect_mysqldb, self).on_connect()

 #ef on_connect(conn):
 #f super_ is not None:
 #uper_(conn)

 #harset_name = conn.character_set_name()

 #f charset_name is not None:
 #ursor = conn.cursor()
 #ursor.execute("SET NAMES %s" % charset_name)
 #ursor.close()

 #eturn on_connect

 #ef do_ping(self, dbapi_connection):
 #ry:
 #bapi_connection.ping(False)
 #xcept self.dbapi.Error as err:
 #f self.is_disconnect(err, dbapi_connection, None):
 #eturn False
 #lse:
 #aise
 #lse:
 #eturn True

 #ef do_executemany(self, cursor, statement, parameters, context=None):
 #owcount = cursor.executemany(statement, parameters)
 #f context is not None:
 #ontext._rowcount = rowcount

 #ef _check_unicode_returns(self, connection):
        # work around issue fixed in
        # https://github.com/farcepest/MySQLdb1/commit/cd44524fef63bd3fcb71947392326e9742d520e8
        # specific issue w/ the utf8mb4_bin collation and unicode returns

 #ollation = connection.exec_driver_sql(
 #show collation where %s = 'utf8mb4' and %s = 'utf8mb4_bin'"
 # (
 #elf.identifier_preparer.quote("Charset"),
 #elf.identifier_preparer.quote("Collation"),
 #
 #.scalar()
 #as_utf8mb4_bin = self.server_version_info > (5,) and collation
 #f has_utf8mb4_bin:
 #dditional_tests = [
 #ql.collate(
 #ql.cast(
 #ql.literal_column("'test collated returns'"),
 #EXT(charset="utf8mb4"),
 #,
 #utf8mb4_bin",
 #
 #
 #lse:
 #dditional_tests = []
 #eturn super(MySQLDialect_mysqldb, self)._check_unicode_returns(
 #onnection, additional_tests
 #

 #ef create_connect_args(self, url, _translate_args=None):
 #f _translate_args is None:
 #translate_args = dict(
 #atabase="db", username="user", password="passwd"
 #

 #pts = url.translate_connect_args(**_translate_args)
 #pts.update(url.query)

 #til.coerce_kw_type(opts, "compress", bool)
 #til.coerce_kw_type(opts, "connect_timeout", int)
 #til.coerce_kw_type(opts, "read_timeout", int)
 #til.coerce_kw_type(opts, "write_timeout", int)
 #til.coerce_kw_type(opts, "client_flag", int)
 #til.coerce_kw_type(opts, "local_infile", int)
        # Note: using either of the below will cause all strings to be
        # returned as Unicode, both in raw SQL operations and with column
        # types like String and MSString.
 #til.coerce_kw_type(opts, "use_unicode", bool)
 #til.coerce_kw_type(opts, "charset", str)

        # Rich values 'cursorclass' and 'conv' are not supported via
        # query string.

 #sl = {}
 #eys = [
 #"ssl_ca", str),
 #"ssl_key", str),
 #"ssl_cert", str),
 #"ssl_capath", str),
 #"ssl_cipher", str),
 #"ssl_check_hostname", bool),
 #
 #or key, kw_type in keys:
 #f key in opts:
 #sl[key[4:]] = opts[key]
 #til.coerce_kw_type(ssl, key[4:], kw_type)
 #el opts[key]
 #f ssl:
 #pts["ssl"] = ssl

        # FOUND_ROWS must be set in CLIENT_FLAGS to enable
        # supports_sane_rowcount.
 #lient_flag = opts.get("client_flag", 0)

 #lient_flag_found_rows = self._found_rows_client_flag()
 #f client_flag_found_rows is not None:
 #lient_flag |= client_flag_found_rows
 #pts["client_flag"] = client_flag
 #eturn [[], opts]

 #ef _found_rows_client_flag(self):
 #f self.dbapi is not None:
 #ry:
 #LIENT_FLAGS = __import__(
 #elf.dbapi.__name__ + ".constants.CLIENT"
 #.constants.CLIENT
 #xcept (AttributeError, ImportError):
 #eturn None
 #lse:
 #eturn CLIENT_FLAGS.FOUND_ROWS
 #lse:
 #eturn None

 #ef _extract_error_code(self, exception):
 #eturn exception.args[0]

 #ef _detect_charset(self, connection):
 #""Sniff out the character set in use for connection results."""

 #ry:
            # note: the SQL here would be
            # "SHOW VARIABLES LIKE 'character_set%%'"
 #set_name = connection.connection.character_set_name
 #xcept AttributeError:
 #til.warn(
 #No 'character_set_name' can be detected with "
 #this MySQL-Python version; "
 #please upgrade to a recent version of MySQL-Python.  "
 #Assuming latin1."
 #
 #eturn "latin1"
 #lse:
 #eturn cset_name()

 #isolation_lookup = set(
 #
 #SERIALIZABLE",
 #READ UNCOMMITTED",
 #READ COMMITTED",
 #REPEATABLE READ",
 #AUTOCOMMIT",
 #
 #

 #ef _set_isolation_level(self, connection, level):
 #f level == "AUTOCOMMIT":
 #onnection.autocommit(True)
 #lse:
 #onnection.autocommit(False)
 #uper(MySQLDialect_mysqldb, self)._set_isolation_level(
 #onnection, level
 #


dialect = MySQLDialect_mysqldb
