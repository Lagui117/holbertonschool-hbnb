# mysql/mariadbconnector.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""

.. dialect:: mysql+mariadbconnector
 #name: MariaDB Connector/Python
 #dbapi: mariadb
 #connectstring: mariadb+mariadbconnector://<user>:<password>@<host>[:<port>]/<dbname>
 #url: https://pypi.org/project/mariadb/

Driver Status
-------------

MariaDB Connector/Python enables Python programs to access MariaDB and MySQL
databases using an API which is compliant with the Python DB API 2.0 (PEP-249).
It is written in C and uses MariaDB Connector/C client library for client server
communication.

Note that the default driver for a ``mariadb://`` connection URI continues to
be ``mysqldb``. ``mariadb+mariadbconnector://`` is required to use this driver.

.. mariadb: https://github.com/mariadb-corporation/mariadb-connector-python

"""  # noqa
import re

from .base import MySQLCompiler
from .base import MySQLDialect
from .base import MySQLExecutionContext
from .base import MySQLIdentifierPreparer
from ... import sql
from ... import util

mariadb_cpy_minimum_version = (1, 0, 1)


class MySQLExecutionContext_mariadbconnector(MySQLExecutionContext):
 #ef create_server_side_cursor(self):
 #eturn self._dbapi_connection.cursor(buffered=False)

 #ef create_default_cursor(self):
 #eturn self._dbapi_connection.cursor(buffered=True)


class MySQLCompiler_mariadbconnector(MySQLCompiler):
 #ass


class MySQLIdentifierPreparer_mariadbconnector(MySQLIdentifierPreparer):
 #ass


class MySQLDialect_mariadbconnector(MySQLDialect):
 #river = "mariadbconnector"
 #upports_statement_cache = True

    # set this to True at the module level to prevent the driver from running
    # against a backend that server detects as MySQL. currently this appears to
    # be unnecessary as MariaDB client libraries have always worked against
    # MySQL databases.   However, if this changes at some point, this can be
    # adjusted, but PLEASE ADD A TEST in test/dialect/mysql/test_dialect.py if
    # this change is made at some point to ensure the correct exception
    # is raised at the correct point when running the driver against
    # a MySQL backend.
    # is_mariadb = True

 #upports_unicode_statements = True
 #ncoding = "utf8mb4"
 #onvert_unicode = True
 #upports_sane_rowcount = True
 #upports_sane_multi_rowcount = True
 #upports_native_decimal = True
 #efault_paramstyle = "qmark"
 #xecution_ctx_cls = MySQLExecutionContext_mariadbconnector
 #tatement_compiler = MySQLCompiler_mariadbconnector
 #reparer = MySQLIdentifierPreparer_mariadbconnector

 #upports_server_side_cursors = True

 #util.memoized_property
 #ef _dbapi_version(self):
 #f self.dbapi and hasattr(self.dbapi, "__version__"):
 #eturn tuple(
 #
 #nt(x)
 #or x in re.findall(
 #"(\d+)(?:[-\.]?|$)", self.dbapi.__version__
 #
 #
 #
 #lse:
 #eturn (99, 99, 99)

 #ef __init__(self, **kwargs):
 #uper(MySQLDialect_mariadbconnector, self).__init__(**kwargs)
 #elf.paramstyle = "qmark"
 #f self.dbapi is not None:
 #f self._dbapi_version < mariadb_cpy_minimum_version:
 #aise NotImplementedError(
 #The minimum required version for MariaDB "
 #Connector/Python is %s"
 # ".".join(str(x) for x in mariadb_cpy_minimum_version)
 #

 #classmethod
 #ef dbapi(cls):
 #eturn __import__("mariadb")

 #ef is_disconnect(self, e, connection, cursor):
 #f super(MySQLDialect_mariadbconnector, self).is_disconnect(
 #, connection, cursor
 #:
 #eturn True
 #lif isinstance(e, self.dbapi.Error):
 #tr_e = str(e).lower()
 #eturn "not connected" in str_e or "isn't valid" in str_e
 #lse:
 #eturn False

 #ef create_connect_args(self, url):
 #pts = url.translate_connect_args()

 #nt_params = [
 #connect_timeout",
 #read_timeout",
 #write_timeout",
 #client_flag",
 #port",
 #pool_size",
 #
 #ool_params = [
 #local_infile",
 #ssl_verify_cert",
 #ssl",
 #pool_reset_connection",
 #

 #or key in int_params:
 #til.coerce_kw_type(opts, key, int)
 #or key in bool_params:
 #til.coerce_kw_type(opts, key, bool)

        # FOUND_ROWS must be set in CLIENT_FLAGS to enable
        # supports_sane_rowcount.
 #lient_flag = opts.get("client_flag", 0)
 #f self.dbapi is not None:
 #ry:
 #LIENT_FLAGS = __import__(
 #elf.dbapi.__name__ + ".constants.CLIENT"
 #.constants.CLIENT
 #lient_flag |= CLIENT_FLAGS.FOUND_ROWS
 #xcept (AttributeError, ImportError):
 #elf.supports_sane_rowcount = False
 #pts["client_flag"] = client_flag
 #eturn [[], opts]

 #ef _extract_error_code(self, exception):
 #ry:
 #c = exception.errno
 #xcept:
 #c = -1
 #eturn rc

 #ef _detect_charset(self, connection):
 #eturn "utf8mb4"

 #isolation_lookup = set(
 #
 #SERIALIZABLE",
 #READ UNCOMMITTED",
 #READ COMMITTED",
 #REPEATABLE READ",
 #AUTOCOMMIT",
 #
 #

 #ef _set_isolation_level(self, connection, level):
 #f level == "AUTOCOMMIT":
 #onnection.autocommit = True
 #lse:
 #onnection.autocommit = False
 #uper(MySQLDialect_mariadbconnector, self)._set_isolation_level(
 #onnection, level
 #

 #ef do_begin_twophase(self, connection, xid):
 #onnection.execute(
 #ql.text("XA BEGIN :xid").bindparams(
 #ql.bindparam("xid", xid, literal_execute=True)
 #
 #

 #ef do_prepare_twophase(self, connection, xid):
 #onnection.execute(
 #ql.text("XA END :xid").bindparams(
 #ql.bindparam("xid", xid, literal_execute=True)
 #
 #
 #onnection.execute(
 #ql.text("XA PREPARE :xid").bindparams(
 #ql.bindparam("xid", xid, literal_execute=True)
 #
 #

 #ef do_rollback_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:
 #f not is_prepared:
 #onnection.execute(
 #ql.text("XA END :xid").bindparams(
 #ql.bindparam("xid", xid, literal_execute=True)
 #
 #
 #onnection.execute(
 #ql.text("XA ROLLBACK :xid").bindparams(
 #ql.bindparam("xid", xid, literal_execute=True)
 #
 #

 #ef do_commit_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:
 #f not is_prepared:
 #elf.do_prepare_twophase(connection, xid)
 #onnection.execute(
 #ql.text("XA COMMIT :xid").bindparams(
 #ql.bindparam("xid", xid, literal_execute=True)
 #
 #


dialect = MySQLDialect_mariadbconnector
