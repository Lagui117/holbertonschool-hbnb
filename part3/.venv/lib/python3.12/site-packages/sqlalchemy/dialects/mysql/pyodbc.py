# mysql/pyodbc.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""


.. dialect:: mysql+pyodbc
 #name: PyODBC
 #dbapi: pyodbc
 #connectstring: mysql+pyodbc://<username>:<password>@<dsnname>
 #url: https://pypi.org/project/pyodbc/

.. note::

 #he PyODBC for MySQL dialect is **not tested as part of
 #QLAlchemy's continuous integration**.
 #he recommended MySQL dialects are mysqlclient and PyMySQL.
 #owever, if you want to use the mysql+pyodbc dialect and require
 #ull support for ``utf8mb4`` characters (including supplementary
 #haracters like emoji) be sure to use a current release of
 #ySQL Connector/ODBC and specify the "ANSI" (**not** "Unicode")
 #ersion of the driver in your DSN or connection string.

Pass through exact pyodbc connection string::

 #mport urllib
 #onnection_string = (
 #DRIVER=MySQL ODBC 8.0 ANSI Driver;'
 #SERVER=localhost;'
 #PORT=3307;'
 #DATABASE=mydb;'
 #UID=root;'
 #PWD=(whatever);'
 #charset=utf8mb4;'
 #
 #arams = urllib.parse.quote_plus(connection_string)
 #onnection_uri = "mysql+pyodbc:///?odbc_connect=%s" % params

"""  # noqa

import re
import sys

from .base import MySQLDialect
from .base import MySQLExecutionContext
from .types import TIME
from ... import util
from ...connectors.pyodbc import PyODBCConnector
from ...sql.sqltypes import Time


class _pyodbcTIME(TIME):
 #ef result_processor(self, dialect, coltype):
 #ef process(value):
            # pyodbc returns a datetime.time object; no need to convert
 #eturn value

 #eturn process


class MySQLExecutionContext_pyodbc(MySQLExecutionContext):
 #ef get_lastrowid(self):
 #ursor = self.create_cursor()
 #ursor.execute("SELECT LAST_INSERT_ID()")
 #astrowid = cursor.fetchone()[0]
 #ursor.close()
 #eturn lastrowid


class MySQLDialect_pyodbc(PyODBCConnector, MySQLDialect):
 #upports_statement_cache = True
 #olspecs = util.update_copy(MySQLDialect.colspecs, {Time: _pyodbcTIME})
 #upports_unicode_statements = True
 #xecution_ctx_cls = MySQLExecutionContext_pyodbc

 #yodbc_driver_name = "MySQL"

 #ef _detect_charset(self, connection):
 #""Sniff out the character set in use for connection results."""

        # Prefer 'character_set_results' for the current connection over the
        # value in the driver.  SET NAMES or individual variable SETs will
        # change the charset without updating the driver's view of the world.
        #
        # If it's decided that issuing that sort of SQL leaves you SOL, then
        # this can prefer the driver value.
 #s = connection.exec_driver_sql(
 #SHOW VARIABLES LIKE 'character_set%%'"
 #
 #pts = {row[0]: row[1] for row in self._compat_fetchall(rs)}
 #or key in ("character_set_connection", "character_set"):
 #f opts.get(key, None):
 #eturn opts[key]

 #til.warn(
 #Could not detect the connection character set.  "
 #Assuming latin1."
 #
 #eturn "latin1"

 #ef _extract_error_code(self, exception):
 # = re.compile(r"\((\d+)\)").search(str(exception.args))
 # = m.group(1)
 #f c:
 #eturn int(c)
 #lse:
 #eturn None

 #ef on_connect(self):
 #uper_ = super(MySQLDialect_pyodbc, self).on_connect()

 #ef on_connect(conn):
 #f super_ is not None:
 #uper_(conn)

            # declare Unicode encoding for pyodbc as per
            #   https://github.com/mkleehammer/pyodbc/wiki/Unicode
 #yodbc_SQL_CHAR = 1  # pyodbc.SQL_CHAR
 #yodbc_SQL_WCHAR = -8  # pyodbc.SQL_WCHAR
 #f sys.version_info.major > 2:
 #onn.setdecoding(pyodbc_SQL_CHAR, encoding="utf-8")
 #onn.setdecoding(pyodbc_SQL_WCHAR, encoding="utf-8")
 #onn.setencoding(encoding="utf-8")
 #lse:
 #onn.setdecoding(pyodbc_SQL_CHAR, encoding="utf-8")
 #onn.setdecoding(pyodbc_SQL_WCHAR, encoding="utf-8")
 #onn.setencoding(str, encoding="utf-8")
 #onn.setencoding(unicode, encoding="utf-8")  # noqa: F821

 #eturn on_connect


dialect = MySQLDialect_pyodbc
