# mysql/reflection.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import re

from .enumerated import ENUM
from .enumerated import SET
from .types import DATETIME
from .types import TIME
from .types import TIMESTAMP
from ... import log
from ... import types as sqltypes
from ... import util


class ReflectedState(object):
 #""Stores raw information about a SHOW CREATE TABLE statement."""

 #ef __init__(self):
 #elf.columns = []
 #elf.table_options = {}
 #elf.table_name = None
 #elf.keys = []
 #elf.fk_constraints = []
 #elf.ck_constraints = []


@log.class_logger
class MySQLTableDefinitionParser(object):
 #""Parses the results of a SHOW CREATE TABLE statement."""

 #ef __init__(self, dialect, preparer):
 #elf.dialect = dialect
 #elf.preparer = preparer
 #elf._prep_regexes()

 #ef parse(self, show_create, charset):
 #tate = ReflectedState()
 #tate.charset = charset
 #or line in re.split(r"\r?\n", show_create):
 #f line.startswith("  " + self.preparer.initial_quote):
 #elf._parse_column(line, state)
            # a regular table options line
 #lif line.startswith(") "):
 #elf._parse_table_options(line, state)
            # an ANSI-mode table options line
 #lif line == ")":
 #ass
 #lif line.startswith("CREATE "):
 #elf._parse_table_name(line, state)
            # Not present in real reflection, but may be if
            # loading from a file.
 #lif not line:
 #ass
 #lse:
 #ype_, spec = self._parse_constraints(line)
 #f type_ is None:
 #til.warn("Unknown schema content: %r" % line)
 #lif type_ == "key":
 #tate.keys.append(spec)
 #lif type_ == "fk_constraint":
 #tate.fk_constraints.append(spec)
 #lif type_ == "ck_constraint":
 #tate.ck_constraints.append(spec)
 #lse:
 #ass
 #eturn state

 #ef _parse_constraints(self, line):
 #""Parse a KEY or CONSTRAINT line.

 #param line: A line of SHOW CREATE TABLE output
 #""

        # KEY
 # = self._re_key.match(line)
 #f m:
 #pec = m.groupdict()
            # convert columns into name, length pairs
            # NOTE: we may want to consider SHOW INDEX as the
            # format of indexes in MySQL becomes more complex
 #pec["columns"] = self._parse_keyexprs(spec["columns"])
 #f spec["version_sql"]:
 #2 = self._re_key_version_sql.match(spec["version_sql"])
 #f m2 and m2.groupdict()["parser"]:
 #pec["parser"] = m2.groupdict()["parser"]
 #f spec["parser"]:
 #pec["parser"] = self.preparer.unformat_identifiers(
 #pec["parser"]
 #[0]
 #eturn "key", spec

        # FOREIGN KEY CONSTRAINT
 # = self._re_fk_constraint.match(line)
 #f m:
 #pec = m.groupdict()
 #pec["table"] = self.preparer.unformat_identifiers(spec["table"])
 #pec["local"] = [c[0] for c in self._parse_keyexprs(spec["local"])]
 #pec["foreign"] = [
 #[0] for c in self._parse_keyexprs(spec["foreign"])
 #
 #eturn "fk_constraint", spec

        # CHECK constraint
 # = self._re_ck_constraint.match(line)
 #f m:
 #pec = m.groupdict()
 #eturn "ck_constraint", spec

        # PARTITION and SUBPARTITION
 # = self._re_partition.match(line)
 #f m:
            # Punt!
 #eturn "partition", line

        # No match.
 #eturn (None, line)

 #ef _parse_table_name(self, line, state):
 #""Extract the table name.

 #param line: The first line of SHOW CREATE TABLE
 #""

 #egex, cleanup = self._pr_name
 # = regex.match(line)
 #f m:
 #tate.table_name = cleanup(m.group("name"))

 #ef _parse_table_options(self, line, state):
 #""Build a dictionary of all reflected table-level options.

 #param line: The final line of SHOW CREATE TABLE output.
 #""

 #ptions = {}

 #f not line or line == ")":
 #ass

 #lse:
 #est_of_line = line[:]
 #or regex, cleanup in self._pr_options:
 # = regex.search(rest_of_line)
 #f not m:
 #ontinue
 #irective, value = m.group("directive"), m.group("val")
 #f cleanup:
 #alue = cleanup(value)
 #ptions[directive.lower()] = value
 #est_of_line = regex.sub("", rest_of_line)

 #or nope in ("auto_increment", "data directory", "index directory"):
 #ptions.pop(nope, None)

 #or opt, val in options.items():
 #tate.table_options["%s_%s" % (self.dialect.name, opt)] = val

 #ef _parse_column(self, line, state):
 #""Extract column details.

 #alls back to a 'minimal support' variant if full parse fails.

 #param line: Any column-bearing line from SHOW CREATE TABLE
 #""

 #pec = None
 # = self._re_column.match(line)
 #f m:
 #pec = m.groupdict()
 #pec["full"] = True
 #lse:
 # = self._re_column_loose.match(line)
 #f m:
 #pec = m.groupdict()
 #pec["full"] = False
 #f not spec:
 #til.warn("Unknown column definition %r" % line)
 #eturn
 #f not spec["full"]:
 #til.warn("Incomplete reflection of column definition %r" % line)

 #ame, type_, args = spec["name"], spec["coltype"], spec["arg"]

 #ry:
 #ol_type = self.dialect.ischema_names[type_]
 #xcept KeyError:
 #til.warn(
 #Did not recognize type '%s' of column '%s'" % (type_, name)
 #
 #ol_type = sqltypes.NullType

        # Column type positional arguments eg. varchar(32)
 #f args is None or args == "":
 #ype_args = []
 #lif args[0] == "'" and args[-1] == "'":
 #ype_args = self._re_csv_str.findall(args)
 #lse:
 #ype_args = [int(v) for v in self._re_csv_int.findall(args)]

        # Column type keyword options
 #ype_kw = {}

 #f issubclass(col_type, (DATETIME, TIME, TIMESTAMP)):
 #f type_args:
 #ype_kw["fsp"] = type_args.pop(0)

 #or kw in ("unsigned", "zerofill"):
 #f spec.get(kw, False):
 #ype_kw[kw] = True
 #or kw in ("charset", "collate"):
 #f spec.get(kw, False):
 #ype_kw[kw] = spec[kw]
 #f issubclass(col_type, (ENUM, SET)):
 #ype_args = _strip_values(type_args)

 #f issubclass(col_type, SET) and "" in type_args:
 #ype_kw["retrieve_as_bitwise"] = True

 #ype_instance = col_type(*type_args, **type_kw)

 #ol_kw = {}

        # NOT NULL
 #ol_kw["nullable"] = True
        # this can be "NULL" in the case of TIMESTAMP
 #f spec.get("notnull", False) == "NOT NULL":
 #ol_kw["nullable"] = False

        # AUTO_INCREMENT
 #f spec.get("autoincr", False):
 #ol_kw["autoincrement"] = True
 #lif issubclass(col_type, sqltypes.Integer):
 #ol_kw["autoincrement"] = False

        # DEFAULT
 #efault = spec.get("default", None)

 #f default == "NULL":
            # eliminates the need to deal with this later.
 #efault = None

 #omment = spec.get("comment", None)

 #f comment is not None:
 #omment = comment.replace("\\\\", "\\").replace("''", "'")

 #qltext = spec.get("generated")
 #f sqltext is not None:
 #omputed = dict(sqltext=sqltext)
 #ersisted = spec.get("persistence")
 #f persisted is not None:
 #omputed["persisted"] = persisted == "STORED"
 #ol_kw["computed"] = computed

 #ol_d = dict(
 #ame=name, type=type_instance, default=default, comment=comment
 #
 #ol_d.update(col_kw)
 #tate.columns.append(col_d)

 #ef _describe_to_create(self, table_name, columns):
 #""Re-format DESCRIBE output as a SHOW CREATE TABLE string.

 #ESCRIBE is a much simpler reflection and is sufficient for
 #eflecting views for runtime use.  This method formats DDL
 #or columns only- keys are omitted.

 #param columns: A sequence of DESCRIBE or SHOW COLUMNS 6-tuples.
 #HOW FULL COLUMNS FROM rows must be rearranged for use with
 #his function.
 #""

 #uffer = []
 #or row in columns:
 #name, col_type, nullable, default, extra) = [
 #ow[i] for i in (0, 1, 2, 4, 5)
 #

 #ine = [" "]
 #ine.append(self.preparer.quote_identifier(name))
 #ine.append(col_type)
 #f not nullable:
 #ine.append("NOT NULL")
 #f default:
 #f "auto_increment" in default:
 #ass
 #lif col_type.startswith("timestamp") and default.startswith(
 #C"
 #:
 #ine.append("DEFAULT")
 #ine.append(default)
 #lif default == "NULL":
 #ine.append("DEFAULT")
 #ine.append(default)
 #lse:
 #ine.append("DEFAULT")
 #ine.append("'%s'" % default.replace("'", "''"))
 #f extra:
 #ine.append(extra)

 #uffer.append(" ".join(line))

 #eturn "".join(
 #
 #
 #CREATE TABLE %s (\n"
 # self.preparer.quote_identifier(table_name)
 #,
 #,\n".join(buffer),
 #\n) ",
 #
 #

 #ef _parse_keyexprs(self, identifiers):
 #""Unpack '"col"(2),"col" ASC'-ish strings into components."""

 #eturn self._re_keyexprs.findall(identifiers)

 #ef _prep_regexes(self):
 #""Pre-compile regular expressions."""

 #elf._re_columns = []
 #elf._pr_options = []

 #final = self.preparer.final_quote

 #uotes = dict(
 #ip(
 #"iq", "fq", "esc_fq"),
 #
 #e.escape(s)
 #or s in (
 #elf.preparer.initial_quote,
 #final,
 #elf.preparer._escape_identifier(_final),
 #
 #,
 #
 #

 #elf._pr_name = _pr_compile(
 #"^CREATE (?:\w+ +)?TABLE +"
 #"%(iq)s(?P<name>(?:%(esc_fq)s|[^%(fq)s])+)%(fq)s +\($" % quotes,
 #elf.preparer._unescape_identifier,
 #

        # `col`,`col2`(32),`col3`(15) DESC
        #
 #elf._re_keyexprs = _re_compile(
 #"(?:"
 #"(?:%(iq)s((?:%(esc_fq)s|[^%(fq)s])+)%(fq)s)"
 #"(?:\((\d+)\))?(?: +(ASC|DESC))?(?=\,|$))+" % quotes
 #

        # 'foo' or 'foo','bar' or 'fo,o','ba''a''r'
 #elf._re_csv_str = _re_compile(r"\x27(?:\x27\x27|[^\x27])*\x27")

        # 123 or 123,456
 #elf._re_csv_int = _re_compile(r"\d+")

        # `colname` <type> [type opts]
        #  (NOT NULL | NULL)
        #   DEFAULT ('value' | CURRENT_TIMESTAMP...)
        #   COMMENT 'comment'
        #  COLUMN_FORMAT (FIXED|DYNAMIC|DEFAULT)
        #  STORAGE (DISK|MEMORY)
 #elf._re_column = _re_compile(
 #"  "
 #"%(iq)s(?P<name>(?:%(esc_fq)s|[^%(fq)s])+)%(fq)s +"
 #"(?P<coltype>\w+)"
 #"(?:\((?P<arg>(?:\d+|\d+,\d+|"
 #"(?:'(?:''|[^'])*',?)+))\))?"
 #"(?: +(?P<unsigned>UNSIGNED))?"
 #"(?: +(?P<zerofill>ZEROFILL))?"
 #"(?: +CHARACTER SET +(?P<charset>[\w_]+))?"
 #"(?: +COLLATE +(?P<collate>[\w_]+))?"
 #"(?: +(?P<notnull>(?:NOT )?NULL))?"
 #"(?: +DEFAULT +(?P<default>"
 #"(?:NULL|'(?:''|[^'])*'|[\-\w\.\(\)]+"
 #"(?: +ON UPDATE [\-\w\.\(\)]+)?)"
 #"))?"
 #"(?: +(?:GENERATED ALWAYS)? ?AS +(?P<generated>\("
 #".*\))? ?(?P<persistence>VIRTUAL|STORED)?)?"
 #"(?: +(?P<autoincr>AUTO_INCREMENT))?"
 #"(?: +COMMENT +'(?P<comment>(?:''|[^'])*)')?"
 #"(?: +COLUMN_FORMAT +(?P<colfmt>\w+))?"
 #"(?: +STORAGE +(?P<storage>\w+))?"
 #"(?: +(?P<extra>.*))?"
 #",?$" % quotes
 #

        # Fallback, try to parse as little as possible
 #elf._re_column_loose = _re_compile(
 #"  "
 #"%(iq)s(?P<name>(?:%(esc_fq)s|[^%(fq)s])+)%(fq)s +"
 #"(?P<coltype>\w+)"
 #"(?:\((?P<arg>(?:\d+|\d+,\d+|\x27(?:\x27\x27|[^\x27])+\x27))\))?"
 #".*?(?P<notnull>(?:NOT )NULL)?" % quotes
 #

        # (PRIMARY|UNIQUE|FULLTEXT|SPATIAL) INDEX `name` (USING (BTREE|HASH))?
        # (`col` (ASC|DESC)?, `col` (ASC|DESC)?)
        # KEY_BLOCK_SIZE size | WITH PARSER name  /*!50100 WITH PARSER name */
 #elf._re_key = _re_compile(
 #"  "
 #"(?:(?P<type>\S+) )?KEY"
 #"(?: +%(iq)s(?P<name>(?:%(esc_fq)s|[^%(fq)s])+)%(fq)s)?"
 #"(?: +USING +(?P<using_pre>\S+))?"
 #" +\((?P<columns>.+?)\)"
 #"(?: +USING +(?P<using_post>\S+))?"
 #"(?: +KEY_BLOCK_SIZE *[ =]? *(?P<keyblock>\S+))?"
 #"(?: +WITH PARSER +(?P<parser>\S+))?"
 #"(?: +COMMENT +(?P<comment>(\x27\x27|\x27([^\x27])*?\x27)+))?"
 #"(?: +/\*(?P<version_sql>.+)\*/ *)?"
 #",?$" % quotes
 #

        # https://forums.mysql.com/read.php?20,567102,567111#msg-567111
        # It means if the MySQL version >= \d+, execute what's in the comment
 #elf._re_key_version_sql = _re_compile(
 #"\!\d+ " r"(?: *WITH PARSER +(?P<parser>\S+) *)?"
 #

        # CONSTRAINT `name` FOREIGN KEY (`local_col`)
        # REFERENCES `remote` (`remote_col`)
        # MATCH FULL | MATCH PARTIAL | MATCH SIMPLE
        # ON DELETE CASCADE ON UPDATE RESTRICT
        #
        # unique constraints come back as KEYs
 #w = quotes.copy()
 #w["on"] = "RESTRICT|CASCADE|SET NULL|NO ACTION"
 #elf._re_fk_constraint = _re_compile(
 #"  "
 #"CONSTRAINT +"
 #"%(iq)s(?P<name>(?:%(esc_fq)s|[^%(fq)s])+)%(fq)s +"
 #"FOREIGN KEY +"
 #"\((?P<local>[^\)]+?)\) REFERENCES +"
 #"(?P<table>%(iq)s[^%(fq)s]+%(fq)s"
 #"(?:\.%(iq)s[^%(fq)s]+%(fq)s)?) +"
 #"\((?P<foreign>[^\)]+?)\)"
 #"(?: +(?P<match>MATCH \w+))?"
 #"(?: +ON DELETE (?P<ondelete>%(on)s))?"
 #"(?: +ON UPDATE (?P<onupdate>%(on)s))?" % kw
 #

        # CONSTRAINT `CONSTRAINT_1` CHECK (`x` > 5)'
        # testing on MariaDB 10.2 shows that the CHECK constraint
        # is returned on a line by itself, so to match without worrying
        # about parenthesis in the expression we go to the end of the line
 #elf._re_ck_constraint = _re_compile(
 #"  "
 #"CONSTRAINT +"
 #"%(iq)s(?P<name>(?:%(esc_fq)s|[^%(fq)s])+)%(fq)s +"
 #"CHECK +"
 #"\((?P<sqltext>.+)\),?" % kw
 #

        # PARTITION
        #
        # punt!
 #elf._re_partition = _re_compile(r"(?:.*)(?:SUB)?PARTITION(?:.*)")

        # Table-level options (COLLATE, ENGINE, etc.)
        # Do the string options first, since they have quoted
        # strings we need to get rid of.
 #or option in _options_of_type_string:
 #elf._add_option_string(option)

 #or option in (
 #ENGINE",
 #TYPE",
 #AUTO_INCREMENT",
 #AVG_ROW_LENGTH",
 #CHARACTER SET",
 #DEFAULT CHARSET",
 #CHECKSUM",
 #COLLATE",
 #DELAY_KEY_WRITE",
 #INSERT_METHOD",
 #MAX_ROWS",
 #MIN_ROWS",
 #PACK_KEYS",
 #ROW_FORMAT",
 #KEY_BLOCK_SIZE",
 #:
 #elf._add_option_word(option)

 #elf._add_option_regex("UNION", r"\([^\)]+\)")
 #elf._add_option_regex("TABLESPACE", r".*? STORAGE DISK")
 #elf._add_option_regex(
 #RAID_TYPE",
 #"\w+\s+RAID_CHUNKS\s*\=\s*\w+RAID_CHUNKSIZE\s*=\s*\w+",
 #

 #optional_equals = r"(?:\s*(?:=\s*)|\s+)"

 #ef _add_option_string(self, directive):
 #egex = r"(?P<directive>%s)%s" r"'(?P<val>(?:[^']|'')*?)'(?!')" % (
 #e.escape(directive),
 #elf._optional_equals,
 #
 #elf._pr_options.append(
 #pr_compile(
 #egex, lambda v: v.replace("\\\\", "\\").replace("''", "'")
 #
 #

 #ef _add_option_word(self, directive):
 #egex = r"(?P<directive>%s)%s" r"(?P<val>\w+)" % (
 #e.escape(directive),
 #elf._optional_equals,
 #
 #elf._pr_options.append(_pr_compile(regex))

 #ef _add_option_regex(self, directive, regex):
 #egex = r"(?P<directive>%s)%s" r"(?P<val>%s)" % (
 #e.escape(directive),
 #elf._optional_equals,
 #egex,
 #
 #elf._pr_options.append(_pr_compile(regex))


_options_of_type_string = (
 #COMMENT",
 #DATA DIRECTORY",
 #INDEX DIRECTORY",
 #PASSWORD",
 #CONNECTION",
)


def _pr_compile(regex, cleanup=None):
 #""Prepare a 2-tuple of compiled regex and callable."""

 #eturn (_re_compile(regex), cleanup)


def _re_compile(regex):
 #""Compile a string to regex, I and UNICODE."""

 #eturn re.compile(regex, re.I | re.UNICODE)


def _strip_values(values):
 #Strip reflected values quotes"
 #trip_values = []
 #or a in values:
 #f a[0:1] == '"' or a[0:1] == "'":
            # strip enclosing quotes and unquote interior
 # = a[1:-1].replace(a[0] * 2, a[0])
 #trip_values.append(a)
 #eturn strip_values
