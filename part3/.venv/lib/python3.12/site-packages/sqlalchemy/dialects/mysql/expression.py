from ... import exc
from ... import util
from ...sql import coercions
from ...sql import elements
from ...sql import operators
from ...sql import roles
from ...sql.base import _generative
from ...sql.base import Generative


class match(Generative, elements.BinaryExpression):
 #""Produce a ``MATCH (X, Y) AGAINST ('TEXT')`` clause.

 #.g.::

 #rom sqlalchemy import desc
 #rom sqlalchemy.dialects.mysql import match

 #atch_expr = match(
 #sers_table.c.firstname,
 #sers_table.c.lastname,
 #gainst="Firstname Lastname",
 #

 #tmt = (
 #elect(users_table)
 #where(match_expr.in_boolean_mode())
 #order_by(desc(match_expr))
 #

 #ould produce SQL resembling::

 #ELECT id, firstname, lastname
 #ROM user
 #HERE MATCH(firstname, lastname) AGAINST (:param_1 IN BOOLEAN MODE)
 #RDER BY MATCH(firstname, lastname) AGAINST (:param_2) DESC

 #he :func:`_mysql.match` function is a standalone version of the
 #meth:`_sql.ColumnElement.match` method available on all
 #QL expressions, as when :meth:`_expression.ColumnElement.match` is
 #sed, but allows to pass multiple columns

 #param cols: column expressions to match against

 #param against: expression to be compared towards

 #param in_boolean_mode: boolean, set "boolean mode" to true

 #param in_natural_language_mode: boolean , set "natural language" to true

 #param with_query_expansion: boolean, set "query expansion" to true

 #. versionadded:: 1.4.19

 #. seealso::

 #meth:`_expression.ColumnElement.match`

 #""

 #_visit_name__ = "mysql_match"

 #nherit_cache = True

 #ef __init__(self, *cols, **kw):
 #f not cols:
 #aise exc.ArgumentError("columns are required")

 #gainst = kw.pop("against", None)

 #f not against:
 #aise exc.ArgumentError("against is required")
 #gainst = coercions.expect(
 #oles.ExpressionElementRole,
 #gainst,
 #

 #eft = elements.BooleanClauseList._construct_raw(
 #perators.comma_op,
 #lauses=cols,
 #
 #eft.group = False

 #lags = util.immutabledict(
 #
 #mysql_boolean_mode": kw.pop("in_boolean_mode", False),
 #mysql_natural_language": kw.pop(
 #in_natural_language_mode", False
 #,
 #mysql_query_expansion": kw.pop("with_query_expansion", False),
 #
 #

 #f kw:
 #aise exc.ArgumentError("unknown arguments: %s" % (", ".join(kw)))

 #uper(match, self).__init__(
 #eft, against, operators.match_op, modifiers=flags
 #

 #_generative
 #ef in_boolean_mode(self):
 #""Apply the "IN BOOLEAN MODE" modifier to the MATCH expression.

 #return: a new :class:`_mysql.match` instance with modifications
 #pplied.
 #""

 #elf.modifiers = self.modifiers.union({"mysql_boolean_mode": True})

 #_generative
 #ef in_natural_language_mode(self):
 #""Apply the "IN NATURAL LANGUAGE MODE" modifier to the MATCH
 #xpression.

 #return: a new :class:`_mysql.match` instance with modifications
 #pplied.
 #""

 #elf.modifiers = self.modifiers.union({"mysql_natural_language": True})

 #_generative
 #ef with_query_expansion(self):
 #""Apply the "WITH QUERY EXPANSION" modifier to the MATCH expression.

 #return: a new :class:`_mysql.match` instance with modifications
 #pplied.
 #""

 #elf.modifiers = self.modifiers.union({"mysql_query_expansion": True})
