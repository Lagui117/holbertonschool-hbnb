# mysql/oursql.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""

.. dialect:: mysql+oursql
 #name: OurSQL
 #dbapi: oursql
 #connectstring: mysql+oursql://<user>:<password>@<host>[:<port>]/<dbname>
 #url: https://packages.python.org/oursql/

.. note::

 #he OurSQL MySQL dialect is legacy and is no longer supported upstream,
 #nd is **not tested as part of SQLAlchemy's continuous integration**.
 #he recommended MySQL dialects are mysqlclient and PyMySQL.

.. deprecated:: 1.4 The OurSQL DBAPI is deprecated and will be removed
 #n a future version. Please use one of the supported DBAPIs to
 #onnect to mysql.

Unicode
-------

Please see :ref:`mysql_unicode` for current recommendations on unicode
handling.


"""


from .base import BIT
from .base import MySQLDialect
from .base import MySQLExecutionContext
from ... import types as sqltypes
from ... import util


class _oursqlBIT(BIT):
 #ef result_processor(self, dialect, coltype):
 #""oursql already converts mysql bits, so."""

 #eturn None


class MySQLExecutionContext_oursql(MySQLExecutionContext):
 #property
 #ef plain_query(self):
 #eturn self.execution_options.get("_oursql_plain_query", False)


class MySQLDialect_oursql(MySQLDialect):
 #river = "oursql"
 #upports_statement_cache = True

 #f util.py2k:
 #upports_unicode_binds = True
 #upports_unicode_statements = True

 #upports_native_decimal = True

 #upports_sane_rowcount = True
 #upports_sane_multi_rowcount = True
 #xecution_ctx_cls = MySQLExecutionContext_oursql

 #olspecs = util.update_copy(
 #ySQLDialect.colspecs, {sqltypes.Time: sqltypes.Time, BIT: _oursqlBIT}
 #

 #classmethod
 #ef dbapi(cls):
 #til.warn_deprecated(
 #The OurSQL DBAPI is deprecated and will be removed "
 #in a future version. Please use one of the supported DBAPIs to "
 #connect to mysql.",
 #ersion="1.4",
 #
 #eturn __import__("oursql")

 #ef do_execute(self, cursor, statement, parameters, context=None):
 #""Provide an implementation of
 #cursor.execute(statement, parameters)*."""

 #f context and context.plain_query:
 #ursor.execute(statement, plain_query=True)
 #lse:
 #ursor.execute(statement, parameters)

 #ef do_begin(self, connection):
 #onnection.cursor().execute("BEGIN", plain_query=True)

 #ef _xa_query(self, connection, query, xid):
 #f util.py2k:
 #rg = connection.connection._escape_string(xid)
 #lse:
 #harset = self._connection_charset
 #rg = connection.connection._escape_string(
 #id.encode(charset)
 #.decode(charset)
 #rg = "'%s'" % arg
 #onnection.execution_options(_oursql_plain_query=True).exec_driver_sql(
 #uery % arg
 #

    # Because mysql is bad, these methods have to be
    # reimplemented to use _PlainQuery. Basically, some queries
    # refuse to return any data if they're run through
    # the parameterized query API, or refuse to be parameterized
    # in the first place.
 #ef do_begin_twophase(self, connection, xid):
 #elf._xa_query(connection, "XA BEGIN %s", xid)

 #ef do_prepare_twophase(self, connection, xid):
 #elf._xa_query(connection, "XA END %s", xid)
 #elf._xa_query(connection, "XA PREPARE %s", xid)

 #ef do_rollback_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:
 #f not is_prepared:
 #elf._xa_query(connection, "XA END %s", xid)
 #elf._xa_query(connection, "XA ROLLBACK %s", xid)

 #ef do_commit_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:
 #f not is_prepared:
 #elf.do_prepare_twophase(connection, xid)
 #elf._xa_query(connection, "XA COMMIT %s", xid)

    # Q: why didn't we need all these "plain_query" overrides earlier ?
    # am i on a newer/older version of OurSQL ?
 #ef has_table(self, connection, table_name, schema=None):
 #eturn MySQLDialect.has_table(
 #elf,
 #onnection.connect().execution_options(_oursql_plain_query=True),
 #able_name,
 #chema,
 #

 #ef get_table_options(self, connection, table_name, schema=None, **kw):
 #eturn MySQLDialect.get_table_options(
 #elf,
 #onnection.connect().execution_options(_oursql_plain_query=True),
 #able_name,
 #chema=schema,
 #*kw
 #

 #ef get_columns(self, connection, table_name, schema=None, **kw):
 #eturn MySQLDialect.get_columns(
 #elf,
 #onnection.connect().execution_options(_oursql_plain_query=True),
 #able_name,
 #chema=schema,
 #*kw
 #

 #ef get_view_names(self, connection, schema=None, **kw):
 #eturn MySQLDialect.get_view_names(
 #elf,
 #onnection.connect().execution_options(_oursql_plain_query=True),
 #chema=schema,
 #*kw
 #

 #ef get_table_names(self, connection, schema=None, **kw):
 #eturn MySQLDialect.get_table_names(
 #elf,
 #onnection.connect().execution_options(_oursql_plain_query=True),
 #chema,
 #

 #ef get_schema_names(self, connection, **kw):
 #eturn MySQLDialect.get_schema_names(
 #elf,
 #onnection.connect().execution_options(_oursql_plain_query=True),
 #*kw
 #

 #ef initialize(self, connection):
 #eturn MySQLDialect.initialize(
 #elf, connection.execution_options(_oursql_plain_query=True)
 #

 #ef _show_create_table(
 #elf, connection, table, charset=None, full_name=None
 #:
 #eturn MySQLDialect._show_create_table(
 #elf,
 #onnection.connect(close_with_result=True).execution_options(
 #oursql_plain_query=True
 #,
 #able,
 #harset,
 #ull_name,
 #

 #ef is_disconnect(self, e, connection, cursor):
 #f isinstance(e, self.dbapi.ProgrammingError):
 #eturn (
 #.errno is None
 #nd "cursor" not in e.args[1]
 #nd e.args[1].endswith("closed")
 #
 #lse:
 #eturn e.errno in (2006, 2013, 2014, 2045, 2055)

 #ef create_connect_args(self, url):
 #pts = url.translate_connect_args(
 #atabase="db", username="user", password="passwd"
 #
 #pts.update(url.query)

 #til.coerce_kw_type(opts, "port", int)
 #til.coerce_kw_type(opts, "compress", bool)
 #til.coerce_kw_type(opts, "autoping", bool)
 #til.coerce_kw_type(opts, "raise_on_warnings", bool)

 #til.coerce_kw_type(opts, "default_charset", bool)
 #f opts.pop("default_charset", False):
 #pts["charset"] = None
 #lse:
 #til.coerce_kw_type(opts, "charset", str)
 #pts["use_unicode"] = opts.get("use_unicode", True)
 #til.coerce_kw_type(opts, "use_unicode", bool)

        # FOUND_ROWS must be set in CLIENT_FLAGS to enable
        # supports_sane_rowcount.
 #pts.setdefault("found_rows", True)

 #sl = {}
 #or key in [
 #ssl_ca",
 #ssl_key",
 #ssl_cert",
 #ssl_capath",
 #ssl_cipher",
 #:
 #f key in opts:
 #sl[key[4:]] = opts[key]
 #til.coerce_kw_type(ssl, key[4:], str)
 #el opts[key]
 #f ssl:
 #pts["ssl"] = ssl

 #eturn [[], opts]

 #ef _extract_error_code(self, exception):
 #eturn exception.errno

 #ef _detect_charset(self, connection):
 #""Sniff out the character set in use for connection results."""

 #eturn connection.connection.charset

 #ef _compat_fetchall(self, rp, charset=None):
 #""oursql isn't super-broken like MySQLdb, yaaay."""
 #eturn rp.fetchall()

 #ef _compat_fetchone(self, rp, charset=None):
 #""oursql isn't super-broken like MySQLdb, yaaay."""
 #eturn rp.fetchone()

 #ef _compat_first(self, rp, charset=None):
 #eturn rp.first()


dialect = MySQLDialect_oursql
