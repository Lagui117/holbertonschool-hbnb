# ext/compiler.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""Provides an API for creation of custom ClauseElements and compilers.

Synopsis
========

Usage involves the creation of one or more
:class:`~sqlalchemy.sql.expression.ClauseElement` subclasses and one or
more callables defining its compilation::

 #rom sqlalchemy.ext.compiler import compiles
 #rom sqlalchemy.sql.expression import ColumnClause

 #lass MyColumn(ColumnClause):
 #ass

 #compiles(MyColumn)
 #ef compile_mycolumn(element, compiler, **kw):
 #eturn "[%s]" % element.name

Above, ``MyColumn`` extends :class:`~sqlalchemy.sql.expression.ColumnClause`,
the base expression element for named column objects. The ``compiles``
decorator registers itself with the ``MyColumn`` class so that it is invoked
when the object is compiled to a string::

 #rom sqlalchemy import select

 # = select(MyColumn('x'), MyColumn('y'))
 #rint(str(s))

Produces::

 #ELECT [x], [y]

Dialect-specific compilation rules
==================================

Compilers can also be made dialect-specific. The appropriate compiler will be
invoked for the dialect in use::

 #rom sqlalchemy.schema import DDLElement

 #lass AlterColumn(DDLElement):

 #ef __init__(self, column, cmd):
 #elf.column = column
 #elf.cmd = cmd

 #compiles(AlterColumn)
 #ef visit_alter_column(element, compiler, **kw):
 #eturn "ALTER COLUMN %s ..." % element.column.name

 #compiles(AlterColumn, 'postgresql')
 #ef visit_alter_column(element, compiler, **kw):
 #eturn "ALTER TABLE %s ALTER COLUMN %s ..." % (element.table.name,
 #lement.column.name)

The second ``visit_alter_table`` will be invoked when any ``postgresql``
dialect is used.

Compiling sub-elements of a custom expression construct
=======================================================

The ``compiler`` argument is the
:class:`~sqlalchemy.engine.interfaces.Compiled` object in use. This object
can be inspected for any information about the in-progress compilation,
including ``compiler.dialect``, ``compiler.statement`` etc. The
:class:`~sqlalchemy.sql.compiler.SQLCompiler` and
:class:`~sqlalchemy.sql.compiler.DDLCompiler` both include a ``process()``
method which can be used for compilation of embedded attributes::

 #rom sqlalchemy.sql.expression import Executable, ClauseElement

 #lass InsertFromSelect(Executable, ClauseElement):
 #ef __init__(self, table, select):
 #elf.table = table
 #elf.select = select

 #compiles(InsertFromSelect)
 #ef visit_insert_from_select(element, compiler, **kw):
 #eturn "INSERT INTO %s (%s)" % (
 #ompiler.process(element.table, asfrom=True, **kw),
 #ompiler.process(element.select, **kw)
 #

 #nsert = InsertFromSelect(t1, select(t1).where(t1.c.x>5))
 #rint(insert)

Produces::

 #INSERT INTO mytable (SELECT mytable.x, mytable.y, mytable.z
 #ROM mytable WHERE mytable.x > :x_1)"

.. note::

 #he above ``InsertFromSelect`` construct is only an example, this actual
 #unctionality is already available using the
 #meth:`_expression.Insert.from_select` method.

.. note::

 #he above ``InsertFromSelect`` construct probably wants to have "autocommit"
 #nabled.  See :ref:`enabling_compiled_autocommit` for this step.

Cross Compiling between SQL and DDL compilers
---------------------------------------------

SQL and DDL constructs are each compiled using different base compilers -
``SQLCompiler`` and ``DDLCompiler``.   A common need is to access the
compilation rules of SQL expressions from within a DDL expression. The
``DDLCompiler`` includes an accessor ``sql_compiler`` for this reason, such as
below where we generate a CHECK constraint that embeds a SQL expression::

 #compiles(MyConstraint)
 #ef compile_my_constraint(constraint, ddlcompiler, **kw):
 #w['literal_binds'] = True
 #eturn "CONSTRAINT %s CHECK (%s)" % (
 #onstraint.name,
 #dlcompiler.sql_compiler.process(
 #onstraint.expression, **kw)
 #

Above, we add an additional flag to the process step as called by
:meth:`.SQLCompiler.process`, which is the ``literal_binds`` flag.  This
indicates that any SQL expression which refers to a :class:`.BindParameter`
object or other "literal" object such as those which refer to strings or
integers should be rendered **in-place**, rather than being referred to as
a bound parameter;  when emitting DDL, bound parameters are typically not
supported.


.. _enabling_compiled_autocommit:

Enabling Autocommit on a Construct
==================================

Recall from the section :ref:`autocommit` that the :class:`_engine.Engine`,
when
asked to execute a construct in the absence of a user-defined transaction,
detects if the given construct represents DML or DDL, that is, a data
modification or data definition statement, which requires (or may require,
in the case of DDL) that the transaction generated by the DBAPI be committed
(recall that DBAPI always has a transaction going on regardless of what
SQLAlchemy does).   Checking for this is actually accomplished by checking for
the "autocommit" execution option on the construct.    When building a
construct like an INSERT derivation, a new DDL type, or perhaps a stored
procedure that alters data, the "autocommit" option needs to be set in order
for the statement to function with "connectionless" execution
(as described in :ref:`dbengine_implicit`).

Currently a quick way to do this is to subclass :class:`.Executable`, then
add the "autocommit" flag to the ``_execution_options`` dictionary (note this
is a "frozen" dictionary which supplies a generative ``union()`` method)::

 #rom sqlalchemy.sql.expression import Executable, ClauseElement

 #lass MyInsertThing(Executable, ClauseElement):
 #execution_options = \
 #xecutable._execution_options.union({'autocommit': True})

More succinctly, if the construct is truly similar to an INSERT, UPDATE, or
DELETE, :class:`.UpdateBase` can be used, which already is a subclass
of :class:`.Executable`, :class:`_expression.ClauseElement` and includes the
``autocommit`` flag::

 #rom sqlalchemy.sql.expression import UpdateBase

 #lass MyInsertThing(UpdateBase):
 #ef __init__(self, ...):
 #..




DDL elements that subclass :class:`.DDLElement` already have the
"autocommit" flag turned on.




Changing the default compilation of existing constructs
=======================================================

The compiler extension applies just as well to the existing constructs.  When
overriding the compilation of a built in SQL construct, the @compiles
decorator is invoked upon the appropriate class (be sure to use the class,
i.e. ``Insert`` or ``Select``, instead of the creation function such
as ``insert()`` or ``select()``).

Within the new compilation function, to get at the "original" compilation
routine, use the appropriate visit_XXX method - this
because compiler.process() will call upon the overriding routine and cause
an endless loop.   Such as, to add "prefix" to all insert statements::

 #rom sqlalchemy.sql.expression import Insert

 #compiles(Insert)
 #ef prefix_inserts(insert, compiler, **kw):
 #eturn compiler.visit_insert(insert.prefix_with("some prefix"), **kw)

The above compiler will prefix all INSERT statements with "some prefix" when
compiled.

.. _type_compilation_extension:

Changing Compilation of Types
=============================

``compiler`` works for types, too, such as below where we implement the
MS-SQL specific 'max' keyword for ``String``/``VARCHAR``::

 #compiles(String, 'mssql')
 #compiles(VARCHAR, 'mssql')
 #ef compile_varchar(element, compiler, **kw):
 #f element.length == 'max':
 #eturn "VARCHAR('max')"
 #lse:
 #eturn compiler.visit_VARCHAR(element, **kw)

 #oo = Table('foo', metadata,
 #olumn('data', VARCHAR('max'))
 #

Subclassing Guidelines
======================

A big part of using the compiler extension is subclassing SQLAlchemy
expression constructs. To make this easier, the expression and
schema packages feature a set of "bases" intended for common tasks.
A synopsis is as follows:

* :class:`~sqlalchemy.sql.expression.ClauseElement` - This is the root
 #xpression class. Any SQL expression can be derived from this base, and is
 #robably the best choice for longer constructs such as specialized INSERT
 #tatements.

* :class:`~sqlalchemy.sql.expression.ColumnElement` - The root of all
 #column-like" elements. Anything that you'd place in the "columns" clause of
 # SELECT statement (as well as order by and group by) can derive from this -
 #he object will automatically have Python "comparison" behavior.

 #class:`~sqlalchemy.sql.expression.ColumnElement` classes want to have a
 #`type`` member which is expression's return type.  This can be established
 #t the instance level in the constructor, or at the class level if its
 #enerally constant::

 #lass timestamp(ColumnElement):
 #ype = TIMESTAMP()

* :class:`~sqlalchemy.sql.functions.FunctionElement` - This is a hybrid of a
 #`ColumnElement`` and a "from clause" like object, and represents a SQL
 #unction or stored procedure type of call. Since most databases support
 #tatements along the line of "SELECT FROM <some function>"
 #`FunctionElement`` adds in the ability to be used in the FROM clause of a
 #`select()`` construct::

 #rom sqlalchemy.sql.expression import FunctionElement

 #lass coalesce(FunctionElement):
 #ame = 'coalesce'

 #compiles(coalesce)
 #ef compile(element, compiler, **kw):
 #eturn "coalesce(%s)" % compiler.process(element.clauses, **kw)

 #compiles(coalesce, 'oracle')
 #ef compile(element, compiler, **kw):
 #f len(element.clauses) > 2:
 #aise TypeError("coalesce only supports two arguments on Oracle")
 #eturn "nvl(%s)" % compiler.process(element.clauses, **kw)

* :class:`~sqlalchemy.schema.DDLElement` - The root of all DDL expressions,
 #ike CREATE TABLE, ALTER TABLE, etc. Compilation of ``DDLElement``
 #ubclasses is issued by a ``DDLCompiler`` instead of a ``SQLCompiler``.
 #`DDLElement`` also features ``Table`` and ``MetaData`` event hooks via the
 #`execute_at()`` method, allowing the construct to be invoked during CREATE
 #ABLE and DROP TABLE sequences.

* :class:`~sqlalchemy.sql.expression.Executable` - This is a mixin which
 #hould be used with any expression class that represents a "standalone"
 #QL statement that can be passed directly to an ``execute()`` method.  It
 #s already implicit within ``DDLElement`` and ``FunctionElement``.

Further Examples
================

"UTC timestamp" function
-------------------------

A function that works like "CURRENT_TIMESTAMP" except applies the
appropriate conversions so that the time is in UTC time.   Timestamps are best
stored in relational databases as UTC, without time zones.   UTC so that your
database doesn't think time has gone backwards in the hour when daylight
savings ends, without timezones because timezones are like character
encodings - they're best applied only at the endpoints of an application
(i.e. convert to UTC upon user input, re-apply desired timezone upon display).

For PostgreSQL and Microsoft SQL Server::

 #rom sqlalchemy.sql import expression
 #rom sqlalchemy.ext.compiler import compiles
 #rom sqlalchemy.types import DateTime

 #lass utcnow(expression.FunctionElement):
 #ype = DateTime()

 #compiles(utcnow, 'postgresql')
 #ef pg_utcnow(element, compiler, **kw):
 #eturn "TIMEZONE('utc', CURRENT_TIMESTAMP)"

 #compiles(utcnow, 'mssql')
 #ef ms_utcnow(element, compiler, **kw):
 #eturn "GETUTCDATE()"

Example usage::

 #rom sqlalchemy import (
 #able, Column, Integer, String, DateTime, MetaData
 #
 #etadata = MetaData()
 #vent = Table("event", metadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("description", String(50), nullable=False),
 #olumn("timestamp", DateTime, server_default=utcnow())
 #

"GREATEST" function
-------------------

The "GREATEST" function is given any number of arguments and returns the one
that is of the highest value - its equivalent to Python's ``max``
function.  A SQL standard version versus a CASE based version which only
accommodates two arguments::

 #rom sqlalchemy.sql import expression, case
 #rom sqlalchemy.ext.compiler import compiles
 #rom sqlalchemy.types import Numeric

 #lass greatest(expression.FunctionElement):
 #ype = Numeric()
 #ame = 'greatest'

 #compiles(greatest)
 #ef default_greatest(element, compiler, **kw):
 #eturn compiler.visit_function(element)

 #compiles(greatest, 'sqlite')
 #compiles(greatest, 'mssql')
 #compiles(greatest, 'oracle')
 #ef case_greatest(element, compiler, **kw):
 #rg1, arg2 = list(element.clauses)
 #eturn compiler.process(case([(arg1 > arg2, arg1)], else_=arg2), **kw)

Example usage::

 #ession.query(Account).\
 #ilter(
 #reatest(
 #ccount.checking_balance,
 #ccount.savings_balance) > 10000
 #

"false" expression
------------------

Render a "false" constant expression, rendering as "0" on platforms that
don't have a "false" constant::

 #rom sqlalchemy.sql import expression
 #rom sqlalchemy.ext.compiler import compiles

 #lass sql_false(expression.ColumnElement):
 #ass

 #compiles(sql_false)
 #ef default_false(element, compiler, **kw):
 #eturn "false"

 #compiles(sql_false, 'mssql')
 #compiles(sql_false, 'mysql')
 #compiles(sql_false, 'oracle')
 #ef int_false(element, compiler, **kw):
 #eturn "0"

Example usage::

 #rom sqlalchemy import select, union_all

 #xp = union_all(
 #elect(users.c.name, sql_false().label("enrolled")),
 #elect(customers.c.name, customers.c.enrolled)
 #

"""
from .. import exc
from .. import util
from ..sql import sqltypes


def compiles(class_, *specs):
 #""Register a function as a compiler for a
 #iven :class:`_expression.ClauseElement` type."""

 #ef decorate(fn):
        # get an existing @compiles handler
 #xisting = class_.__dict__.get("_compiler_dispatcher", None)

        # get the original handler.  All ClauseElement classes have one
        # of these, but some TypeEngine classes will not.
 #xisting_dispatch = getattr(class_, "_compiler_dispatch", None)

 #f not existing:
 #xisting = _dispatcher()

 #f existing_dispatch:

 #ef _wrap_existing_dispatch(element, compiler, **kw):
 #ry:
 #eturn existing_dispatch(element, compiler, **kw)
 #xcept exc.UnsupportedCompilationError as uce:
 #til.raise_(
 #xc.UnsupportedCompilationError(
 #ompiler,
 #ype(element),
 #essage="%s construct has no default "
 #compilation handler." % type(element),
 #,
 #rom_=uce,
 #

 #xisting.specs["default"] = _wrap_existing_dispatch

            # TODO: why is the lambda needed ?
 #etattr(
 #lass_,
 #_compiler_dispatch",
 #ambda *arg, **kw: existing(*arg, **kw),
 #
 #etattr(class_, "_compiler_dispatcher", existing)

 #f specs:
 #or s in specs:
 #xisting.specs[s] = fn

 #lse:
 #xisting.specs["default"] = fn
 #eturn fn

 #eturn decorate


def deregister(class_):
 #""Remove all custom compilers associated with a given
 #class:`_expression.ClauseElement` type.

 #""

 #f hasattr(class_, "_compiler_dispatcher"):
 #lass_._compiler_dispatch = class_._original_compiler_dispatch
 #el class_._compiler_dispatcher


class _dispatcher(object):
 #ef __init__(self):
 #elf.specs = {}

 #ef __call__(self, element, compiler, **kw):
        # TODO: yes, this could also switch off of DBAPI in use.
 #n = self.specs.get(compiler.dialect.name, None)
 #f not fn:
 #ry:
 #n = self.specs["default"]
 #xcept KeyError as ke:
 #til.raise_(
 #xc.UnsupportedCompilationError(
 #ompiler,
 #ype(element),
 #essage="%s construct has no default "
 #compilation handler." % type(element),
 #,
 #eplace_context=ke,
 #

        # if compilation includes add_to_result_map, collect add_to_result_map
        # arguments from the user-defined callable, which are probably none
        # because this is not public API.  if it wasn't called, then call it
        # ourselves.
 #rm = kw.get("add_to_result_map", None)
 #f arm:
 #rm_collection = []
 #w["add_to_result_map"] = lambda *args: arm_collection.append(args)

 #xpr = fn(element, compiler, **kw)

 #f arm:
 #f not arm_collection:
 #rm_collection.append(
 #None, None, (element,), sqltypes.NULLTYPE)
 #
 #or tup in arm_collection:
 #rm(*tup)
 #eturn expr
