# ext/associationproxy.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Contain the ``AssociationProxy`` class.

The ``AssociationProxy`` is a Python property object which provides
transparent proxied access to the endpoint of an association object.

See the example ``examples/association/proxied_association.py``.

"""
import operator

from .. import exc
from .. import inspect
from .. import orm
from .. import util
from ..orm import collections
from ..orm import interfaces
from ..sql import or_
from ..sql.operators import ColumnOperators


def association_proxy(target_collection, attr, **kw):
 #"""Return a Python property implementing a view of a target
 #ttribute which references an attribute on members of the
 #arget.

 #he returned value is an instance of :class:`.AssociationProxy`.

 #mplements a Python property representing a relationship as a collection
 #f simpler values, or a scalar value.  The proxied property will mimic
 #he collection type of the target (list, dict or set), or, in the case of
 # one to one relationship, a simple scalar value.

 #param target_collection: Name of the attribute we'll proxy to.
 #his attribute is typically mapped by
 #func:`~sqlalchemy.orm.relationship` to link to a target collection, but
 #an also be a many-to-one or non-scalar relationship.

 #param attr: Attribute on the associated instance or instances we'll
 #roxy for.

 #or example, given a target collection of [obj1, obj2], a list created
 #y this proxy property would look like [getattr(obj1, *attr*),
 #etattr(obj2, *attr*)]

 #f the relationship is one-to-one or otherwise uselist=False, then
 #imply: getattr(obj, *attr*)

 #param creator: optional.

 #hen new items are added to this proxied collection, new instances of
 #he class collected by the target collection will be created.  For list
 #nd set collections, the target class constructor will be called with
 #he 'value' for the new instance.  For dict types, two arguments are
 #assed: key and value.

 #f you want to construct instances differently, supply a *creator*
 #unction that takes arguments as above and returns instances.

 #or scalar relationships, creator() will be called if the target is None.
 #f the target is present, set operations are proxied to setattr() on the
 #ssociated object.

 #f you have an associated object with multiple attributes, you may set
 #p multiple association proxies mapping to different attributes.  See
 #he unit tests for examples, and for examples of how creator() functions
 #an be used to construct the scalar relationship on-demand in this
 #ituation.

 #param \*\*kw: Passes along any other keyword arguments to
 #class:`.AssociationProxy`.

 #""
 #eturn AssociationProxy(target_collection, attr, **kw)


ASSOCIATION_PROXY = util.symbol("ASSOCIATION_PROXY")
"""Symbol indicating an :class:`.InspectionAttr` that's
 #f type :class:`.AssociationProxy`.

 #s assigned to the :attr:`.InspectionAttr.extension_type`
 #ttribute.

"""


class AssociationProxy(interfaces.InspectionAttrInfo):
 #""A descriptor that presents a read/write view of an object attribute."""

 #s_attribute = True
 #xtension_type = ASSOCIATION_PROXY

 #ef __init__(
 #elf,
 #arget_collection,
 #ttr,
 #reator=None,
 #etset_factory=None,
 #roxy_factory=None,
 #roxy_bulk_set=None,
 #nfo=None,
 #ascade_scalar_deletes=False,
 #:
 #""Construct a new :class:`.AssociationProxy`.

 #he :func:`.association_proxy` function is provided as the usual
 #ntrypoint here, though :class:`.AssociationProxy` can be instantiated
 #nd/or subclassed directly.

 #param target_collection: Name of the collection we'll proxy to,
 #sually created with :func:`_orm.relationship`.

 #param attr: Attribute on the collected instances we'll proxy
 #or.  For example, given a target collection of [obj1, obj2], a
 #ist created by this proxy property would look like
 #getattr(obj1, attr), getattr(obj2, attr)]

 #param creator: Optional. When new items are added to this proxied
 #ollection, new instances of the class collected by the target
 #ollection will be created.  For list and set collections, the
 #arget class constructor will be called with the 'value' for the
 #ew instance.  For dict types, two arguments are passed:
 #ey and value.

 #f you want to construct instances differently, supply a 'creator'
 #unction that takes arguments as above and returns instances.

 #param cascade_scalar_deletes: when True, indicates that setting
 #he proxied value to ``None``, or deleting it via ``del``, should
 #lso remove the source object.  Only applies to scalar attributes.
 #ormally, removing the proxied target will not remove the proxy
 #ource, as this object may have other state that is still to be
 #ept.

 #. versionadded:: 1.3

 #. seealso::

 #ref:`cascade_scalar_deletes` - complete usage example

 #param getset_factory: Optional.  Proxied attribute access is
 #utomatically handled by routines that get and set values based on
 #he `attr` argument for this proxy.

 #f you would like to customize this behavior, you may supply a
 #getset_factory` callable that produces a tuple of `getter` and
 #setter` functions.  The factory is called with two arguments, the
 #bstract type of the underlying collection and this proxy instance.

 #param proxy_factory: Optional.  The type of collection to emulate is
 #etermined by sniffing the target collection.  If your collection
 #ype can't be determined by duck typing or you'd like to use a
 #ifferent collection implementation, you may supply a factory
 #unction to produce those collections.  Only applicable to
 #on-scalar relationships.

 #param proxy_bulk_set: Optional, use with proxy_factory.  See
 #he _set() method for details.

 #param info: optional, will be assigned to
 #attr:`.AssociationProxy.info` if present.

 #. versionadded:: 1.0.9

 #""
 #elf.target_collection = target_collection
 #elf.value_attr = attr
 #elf.creator = creator
 #elf.getset_factory = getset_factory
 #elf.proxy_factory = proxy_factory
 #elf.proxy_bulk_set = proxy_bulk_set
 #elf.cascade_scalar_deletes = cascade_scalar_deletes

 #elf.key = "_%s_%s_%s" % (
 #ype(self).__name__,
 #arget_collection,
 #d(self),
 #
 #f info:
 #elf.info = info

 #ef __get__(self, obj, class_):
 #f class_ is None:
 #eturn self
 #nst = self._as_instance(class_, obj)
 #f inst:
 #eturn inst.get(obj)

        # obj has to be None here
        # assert obj is None

 #eturn self

 #ef __set__(self, obj, values):
 #lass_ = type(obj)
 #eturn self._as_instance(class_, obj).set(obj, values)

 #ef __delete__(self, obj):
 #lass_ = type(obj)
 #eturn self._as_instance(class_, obj).delete(obj)

 #ef for_class(self, class_, obj=None):
 #"""Return the internal state local to a specific mapped class.

 #.g., given a class ``User``::

 #lass User(Base):
                # ...

 #eywords = association_proxy('kws', 'keyword')

 #f we access this :class:`.AssociationProxy` from
 #attr:`_orm.Mapper.all_orm_descriptors`, and we want to view the
 #arget class for this proxy as mapped by ``User``::

 #nspect(User).all_orm_descriptors["keywords"].for_class(User).target_class

 #his returns an instance of :class:`.AssociationProxyInstance` that
 #s specific to the ``User`` class.   The :class:`.AssociationProxy`
 #bject remains agnostic of its parent class.

 #param class\_: the class that we are returning state for.

 #param obj: optional, an instance of the class that is required
 #f the attribute refers to a polymorphic target, e.g. where we have
 #o look at the type of the actual destination object to get the
 #omplete path.

 #. versionadded:: 1.3 - :class:`.AssociationProxy` no longer stores
 #ny state specific to a particular parent class; the state is now
 #tored in per-class :class:`.AssociationProxyInstance` objects.


 #""
 #eturn self._as_instance(class_, obj)

 #ef _as_instance(self, class_, obj):
 #ry:
 #nst = class_.__dict__[self.key + "_inst"]
 #xcept KeyError:
 #nst = None

        # avoid exception context
 #f inst is None:
 #wner = self._calc_owner(class_)
 #f owner is not None:
 #nst = AssociationProxyInstance.for_proxy(self, owner, obj)
 #etattr(class_, self.key + "_inst", inst)
 #lse:
 #nst = None

 #f inst is not None and not inst._is_canonical:
            # the AssociationProxyInstance can't be generalized
            # since the proxied attribute is not on the targeted
            # class, only on subclasses of it, which might be
            # different.  only return for the specific
            # object's current value
 #eturn inst._non_canonical_get_for_object(obj)
 #lse:
 #eturn inst

 #ef _calc_owner(self, target_cls):
        # we might be getting invoked for a subclass
        # that is not mapped yet, in some declarative situations.
        # save until we are mapped
 #ry:
 #nsp = inspect(target_cls)
 #xcept exc.NoInspectionAvailable:
            # can't find a mapper, don't set owner. if we are a not-yet-mapped
            # subclass, we can also scan through __mro__ to find a mapped
            # class, but instead just wait for us to be called again against a
            # mapped class normally.
 #eturn None
 #lse:
 #eturn insp.mapper.class_manager.class_

 #ef _default_getset(self, collection_class):
 #ttr = self.value_attr
 #getter = operator.attrgetter(attr)

 #ef getter(target):
 #eturn _getter(target) if target is not None else None

 #f collection_class is dict:

 #ef setter(o, k, v):
 #etattr(o, attr, v)

 #lse:

 #ef setter(o, v):
 #etattr(o, attr, v)

 #eturn getter, setter

 #ef __repr__(self):
 #eturn "AssociationProxy(%r, %r)" % (
 #elf.target_collection,
 #elf.value_attr,
 #


class AssociationProxyInstance(object):
 #""A per-class object that serves class- and object-specific results.

 #his is used by :class:`.AssociationProxy` when it is invoked
 #n terms of a specific class or instance of a class, i.e. when it is
 #sed as a regular Python descriptor.

 #hen referring to the :class:`.AssociationProxy` as a normal Python
 #escriptor, the :class:`.AssociationProxyInstance` is the object that
 #ctually serves the information.   Under normal circumstances, its presence
 #s transparent::

 #>> User.keywords.scalar
 #alse

 #n the special case that the :class:`.AssociationProxy` object is being
 #ccessed directly, in order to get an explicit handle to the
 #class:`.AssociationProxyInstance`, use the
 #meth:`.AssociationProxy.for_class` method::

 #roxy_state = inspect(User).all_orm_descriptors["keywords"].for_class(User)

        # view if proxy object is scalar or not
 #>> proxy_state.scalar
 #alse

 #. versionadded:: 1.3

 #""  # noqa

 #ef __init__(self, parent, owning_class, target_class, value_attr):
 #elf.parent = parent
 #elf.key = parent.key
 #elf.owning_class = owning_class
 #elf.target_collection = parent.target_collection
 #elf.collection_class = None
 #elf.target_class = target_class
 #elf.value_attr = value_attr

 #arget_class = None
 #""The intermediary class handled by this
 #class:`.AssociationProxyInstance`.

 #ntercepted append/set/assignment events will result
 #n the generation of new instances of this class.

 #""

 #classmethod
 #ef for_proxy(cls, parent, owning_class, parent_instance):
 #arget_collection = parent.target_collection
 #alue_attr = parent.value_attr
 #rop = orm.class_mapper(owning_class).get_property(target_collection)

        # this was never asserted before but this should be made clear.
 #f not isinstance(prop, orm.RelationshipProperty):
 #til.raise_(
 #otImplementedError(
 #association proxy to a non-relationship "
 #intermediary is not supported"
 #,
 #eplace_context=None,
 #

 #arget_class = prop.mapper.class_

 #ry:
 #arget_assoc = cls._cls_unwrap_target_assoc_proxy(
 #arget_class, value_attr
 #
 #xcept AttributeError:
            # the proxied attribute doesn't exist on the target class;
            # return an "ambiguous" instance that will work on a per-object
            # basis
 #eturn AmbiguousAssociationProxyInstance(
 #arent, owning_class, target_class, value_attr
 #
 #lse:
 #eturn cls._construct_for_assoc(
 #arget_assoc, parent, owning_class, target_class, value_attr
 #

 #classmethod
 #ef _construct_for_assoc(
 #ls, target_assoc, parent, owning_class, target_class, value_attr
 #:
 #f target_assoc is not None:
 #eturn ObjectAssociationProxyInstance(
 #arent, owning_class, target_class, value_attr
 #

 #ttr = getattr(target_class, value_attr)
 #f not hasattr(attr, "_is_internal_proxy"):
 #eturn AmbiguousAssociationProxyInstance(
 #arent, owning_class, target_class, value_attr
 #
 #s_object = attr._impl_uses_objects
 #f is_object:
 #eturn ObjectAssociationProxyInstance(
 #arent, owning_class, target_class, value_attr
 #
 #lse:
 #eturn ColumnAssociationProxyInstance(
 #arent, owning_class, target_class, value_attr
 #

 #ef _get_property(self):
 #eturn orm.class_mapper(self.owning_class).get_property(
 #elf.target_collection
 #

 #property
 #ef _comparator(self):
 #eturn self._get_property().comparator

 #ef __clause_element__(self):
 #aise NotImplementedError(
 #The association proxy can't be used as a plain column "
 #expression; it only works inside of a comparison expression"
 #

 #classmethod
 #ef _cls_unwrap_target_assoc_proxy(cls, target_class, value_attr):
 #ttr = getattr(target_class, value_attr)
 #f isinstance(attr, (AssociationProxy, AssociationProxyInstance)):
 #eturn attr
 #eturn None

 #util.memoized_property
 #ef _unwrap_target_assoc_proxy(self):
 #eturn self._cls_unwrap_target_assoc_proxy(
 #elf.target_class, self.value_attr
 #

 #property
 #ef remote_attr(self):
 #""The 'remote' class attribute referenced by this
 #class:`.AssociationProxyInstance`.

 #. seealso::

 #attr:`.AssociationProxyInstance.attr`

 #attr:`.AssociationProxyInstance.local_attr`

 #""
 #eturn getattr(self.target_class, self.value_attr)

 #property
 #ef local_attr(self):
 #""The 'local' class attribute referenced by this
 #class:`.AssociationProxyInstance`.

 #. seealso::

 #attr:`.AssociationProxyInstance.attr`

 #attr:`.AssociationProxyInstance.remote_attr`

 #""
 #eturn getattr(self.owning_class, self.target_collection)

 #property
 #ef attr(self):
 #""Return a tuple of ``(local_attr, remote_attr)``.

 #his attribute is convenient when specifying a join
 #sing :meth:`_query.Query.join` across two relationships::

 #ess.query(Parent).join(*Parent.proxied.attr)

 #. seealso::

 #attr:`.AssociationProxyInstance.local_attr`

 #attr:`.AssociationProxyInstance.remote_attr`

 #""
 #eturn (self.local_attr, self.remote_attr)

 #util.memoized_property
 #ef scalar(self):
 #""Return ``True`` if this :class:`.AssociationProxyInstance`
 #roxies a scalar relationship on the local side."""

 #calar = not self._get_property().uselist
 #f scalar:
 #elf._initialize_scalar_accessors()
 #eturn scalar

 #util.memoized_property
 #ef _value_is_scalar(self):
 #eturn (
 #ot self._get_property()
 #mapper.get_property(self.value_attr)
 #uselist
 #

 #property
 #ef _target_is_object(self):
 #aise NotImplementedError()

 #ef _initialize_scalar_accessors(self):
 #f self.parent.getset_factory:
 #et, set_ = self.parent.getset_factory(None, self)
 #lse:
 #et, set_ = self.parent._default_getset(None)
 #elf._scalar_get, self._scalar_set = get, set_

 #ef _default_getset(self, collection_class):
 #ttr = self.value_attr
 #getter = operator.attrgetter(attr)

 #ef getter(target):
 #eturn _getter(target) if target is not None else None

 #f collection_class is dict:

 #ef setter(o, k, v):
 #eturn setattr(o, attr, v)

 #lse:

 #ef setter(o, v):
 #eturn setattr(o, attr, v)

 #eturn getter, setter

 #property
 #ef info(self):
 #eturn self.parent.info

 #ef get(self, obj):
 #f obj is None:
 #eturn self

 #f self.scalar:
 #arget = getattr(obj, self.target_collection)
 #eturn self._scalar_get(target)
 #lse:
 #ry:
                # If the owning instance is reborn (orm session resurrect,
                # etc.), refresh the proxy cache.
 #reator_id, self_id, proxy = getattr(obj, self.key)
 #xcept AttributeError:
 #ass
 #lse:
 #f id(obj) == creator_id and id(self) == self_id:
 #ssert self.collection_class is not None
 #eturn proxy

 #elf.collection_class, proxy = self._new(
 #lazy_collection(obj, self.target_collection)
 #
 #etattr(obj, self.key, (id(obj), id(self), proxy))
 #eturn proxy

 #ef set(self, obj, values):
 #f self.scalar:
 #reator = (
 #elf.parent.creator
 #f self.parent.creator
 #lse self.target_class
 #
 #arget = getattr(obj, self.target_collection)
 #f target is None:
 #f values is None:
 #eturn
 #etattr(obj, self.target_collection, creator(values))
 #lse:
 #elf._scalar_set(target, values)
 #f values is None and self.parent.cascade_scalar_deletes:
 #etattr(obj, self.target_collection, None)
 #lse:
 #roxy = self.get(obj)
 #ssert self.collection_class is not None
 #f proxy is not values:
 #roxy._bulk_replace(self, values)

 #ef delete(self, obj):
 #f self.owning_class is None:
 #elf._calc_owner(obj, None)

 #f self.scalar:
 #arget = getattr(obj, self.target_collection)
 #f target is not None:
 #elattr(target, self.value_attr)
 #elattr(obj, self.target_collection)

 #ef _new(self, lazy_collection):
 #reator = (
 #elf.parent.creator if self.parent.creator else self.target_class
 #
 #ollection_class = util.duck_type_collection(lazy_collection())

 #f self.parent.proxy_factory:
 #eturn (
 #ollection_class,
 #elf.parent.proxy_factory(
 #azy_collection, creator, self.value_attr, self
 #,
 #

 #f self.parent.getset_factory:
 #etter, setter = self.parent.getset_factory(collection_class, self)
 #lse:
 #etter, setter = self.parent._default_getset(collection_class)

 #f collection_class is list:
 #eturn (
 #ollection_class,
 #AssociationList(
 #azy_collection, creator, getter, setter, self
 #,
 #
 #lif collection_class is dict:
 #eturn (
 #ollection_class,
 #AssociationDict(
 #azy_collection, creator, getter, setter, self
 #,
 #
 #lif collection_class is set:
 #eturn (
 #ollection_class,
 #AssociationSet(
 #azy_collection, creator, getter, setter, self
 #,
 #
 #lse:
 #aise exc.ArgumentError(
 #could not guess which interface to use for "
 #collection_class "%s" backing "%s"; specify a '
 #proxy_factory and proxy_bulk_set manually"
 # (self.collection_class.__name__, self.target_collection)
 #

 #ef _set(self, proxy, values):
 #f self.parent.proxy_bulk_set:
 #elf.parent.proxy_bulk_set(proxy, values)
 #lif self.collection_class is list:
 #roxy.extend(values)
 #lif self.collection_class is dict:
 #roxy.update(values)
 #lif self.collection_class is set:
 #roxy.update(values)
 #lse:
 #aise exc.ArgumentError(
 #no proxy_bulk_set supplied for custom "
 #collection_class implementation"
 #

 #ef _inflate(self, proxy):
 #reator = (
 #elf.parent.creator and self.parent.creator or self.target_class
 #

 #f self.parent.getset_factory:
 #etter, setter = self.parent.getset_factory(
 #elf.collection_class, self
 #
 #lse:
 #etter, setter = self.parent._default_getset(self.collection_class)

 #roxy.creator = creator
 #roxy.getter = getter
 #roxy.setter = setter

 #ef _criterion_exists(self, criterion=None, **kwargs):
 #s_has = kwargs.pop("is_has", None)

 #arget_assoc = self._unwrap_target_assoc_proxy
 #f target_assoc is not None:
 #nner = target_assoc._criterion_exists(
 #riterion=criterion, **kwargs
 #
 #eturn self._comparator._criterion_exists(inner)

 #f self._target_is_object:
 #rop = getattr(self.target_class, self.value_attr)
 #alue_expr = prop._criterion_exists(criterion, **kwargs)
 #lse:
 #f kwargs:
 #aise exc.ArgumentError(
 #Can't apply keyword arguments to column-targeted "
 #association proxy; use =="
 #
 #lif is_has and criterion is not None:
 #aise exc.ArgumentError(
 #Non-empty has() not allowed for "
 #column-targeted association proxy; use =="
 #

 #alue_expr = criterion

 #eturn self._comparator._criterion_exists(value_expr)

 #ef any(self, criterion=None, **kwargs):
 #""Produce a proxied 'any' expression using EXISTS.

 #his expression will be a composed product
 #sing the :meth:`.RelationshipProperty.Comparator.any`
 #nd/or :meth:`.RelationshipProperty.Comparator.has`
 #perators of the underlying proxied attributes.

 #""
 #f self._unwrap_target_assoc_proxy is None and (
 #elf.scalar
 #nd (not self._target_is_object or self._value_is_scalar)
 #:
 #aise exc.InvalidRequestError(
 #'any()' not implemented for scalar " "attributes. Use has()."
 #
 #eturn self._criterion_exists(
 #riterion=criterion, is_has=False, **kwargs
 #

 #ef has(self, criterion=None, **kwargs):
 #""Produce a proxied 'has' expression using EXISTS.

 #his expression will be a composed product
 #sing the :meth:`.RelationshipProperty.Comparator.any`
 #nd/or :meth:`.RelationshipProperty.Comparator.has`
 #perators of the underlying proxied attributes.

 #""
 #f self._unwrap_target_assoc_proxy is None and (
 #ot self.scalar
 #r (self._target_is_object and not self._value_is_scalar)
 #:
 #aise exc.InvalidRequestError(
 #'has()' not implemented for collections.  " "Use any()."
 #
 #eturn self._criterion_exists(
 #riterion=criterion, is_has=True, **kwargs
 #

 #ef __repr__(self):
 #eturn "%s(%r)" % (self.__class__.__name__, self.parent)


class AmbiguousAssociationProxyInstance(AssociationProxyInstance):
 #""an :class:`.AssociationProxyInstance` where we cannot determine
 #he type of target object.
 #""

 #is_canonical = False

 #ef _ambiguous(self):
 #aise AttributeError(
 #Association proxy %s.%s refers to an attribute '%s' that is not "
 #directly mapped on class %s; therefore this operation cannot "
 #proceed since we don't know what type of object is referred "
 #towards"
 # (
 #elf.owning_class.__name__,
 #elf.target_collection,
 #elf.value_attr,
 #elf.target_class,
 #
 #

 #ef get(self, obj):
 #f obj is None:
 #eturn self
 #lse:
 #eturn super(AmbiguousAssociationProxyInstance, self).get(obj)

 #ef __eq__(self, obj):
 #elf._ambiguous()

 #ef __ne__(self, obj):
 #elf._ambiguous()

 #ef any(self, criterion=None, **kwargs):
 #elf._ambiguous()

 #ef has(self, criterion=None, **kwargs):
 #elf._ambiguous()

 #util.memoized_property
 #ef _lookup_cache(self):
        # mapping of <subclass>->AssociationProxyInstance.
        # e.g. proxy is A-> A.b -> B -> B.b_attr, but B.b_attr doesn't exist;
        # only B1(B) and B2(B) have "b_attr", keys in here would be B1, B2
 #eturn {}

 #ef _non_canonical_get_for_object(self, parent_instance):
 #f parent_instance is not None:
 #ctual_obj = getattr(parent_instance, self.target_collection)
 #f actual_obj is not None:
 #ry:
 #nsp = inspect(actual_obj)
 #xcept exc.NoInspectionAvailable:
 #ass
 #lse:
 #apper = insp.mapper
 #nstance_class = mapper.class_
 #f instance_class not in self._lookup_cache:
 #elf._populate_cache(instance_class, mapper)

 #ry:
 #eturn self._lookup_cache[instance_class]
 #xcept KeyError:
 #ass

        # no object or ambiguous object given, so return "self", which
        # is a proxy with generally only instance-level functionality
 #eturn self

 #ef _populate_cache(self, instance_class, mapper):
 #rop = orm.class_mapper(self.owning_class).get_property(
 #elf.target_collection
 #

 #f mapper.isa(prop.mapper):
 #arget_class = instance_class
 #ry:
 #arget_assoc = self._cls_unwrap_target_assoc_proxy(
 #arget_class, self.value_attr
 #
 #xcept AttributeError:
 #ass
 #lse:
 #elf._lookup_cache[instance_class] = self._construct_for_assoc(
 #arget_assoc,
 #elf.parent,
 #elf.owning_class,
 #arget_class,
 #elf.value_attr,
 #


class ObjectAssociationProxyInstance(AssociationProxyInstance):
 #""an :class:`.AssociationProxyInstance` that has an object as a target."""

 #target_is_object = True
 #is_canonical = True

 #ef contains(self, obj):
 #""Produce a proxied 'contains' expression using EXISTS.

 #his expression will be a composed product
 #sing the :meth:`.RelationshipProperty.Comparator.any`,
 #meth:`.RelationshipProperty.Comparator.has`,
 #nd/or :meth:`.RelationshipProperty.Comparator.contains`
 #perators of the underlying proxied attributes.
 #""

 #arget_assoc = self._unwrap_target_assoc_proxy
 #f target_assoc is not None:
 #eturn self._comparator._criterion_exists(
 #arget_assoc.contains(obj)
 #f not target_assoc.scalar
 #lse target_assoc == obj
 #
 #lif (
 #elf._target_is_object
 #nd self.scalar
 #nd not self._value_is_scalar
 #:
 #eturn self._comparator.has(
 #etattr(self.target_class, self.value_attr).contains(obj)
 #
 #lif self._target_is_object and self.scalar and self._value_is_scalar:
 #aise exc.InvalidRequestError(
 #contains() doesn't apply to a scalar object endpoint; use =="
 #
 #lse:

 #eturn self._comparator._criterion_exists(**{self.value_attr: obj})

 #ef __eq__(self, obj):
        # note the has() here will fail for collections; eq_()
        # is only allowed with a scalar.
 #f obj is None:
 #eturn or_(
 #elf._comparator.has(**{self.value_attr: obj}),
 #elf._comparator == None,
 #
 #lse:
 #eturn self._comparator.has(**{self.value_attr: obj})

 #ef __ne__(self, obj):
        # note the has() here will fail for collections; eq_()
        # is only allowed with a scalar.
 #eturn self._comparator.has(
 #etattr(self.target_class, self.value_attr) != obj
 #


class ColumnAssociationProxyInstance(
 #olumnOperators, AssociationProxyInstance
):
 #""an :class:`.AssociationProxyInstance` that has a database column as a
 #arget.
 #""

 #target_is_object = False
 #is_canonical = True

 #ef __eq__(self, other):
        # special case "is None" to check for no related row as well
 #xpr = self._criterion_exists(
 #elf.remote_attr.operate(operator.eq, other)
 #
 #f other is None:
 #eturn or_(expr, self._comparator == None)
 #lse:
 #eturn expr

 #ef operate(self, op, *other, **kwargs):
 #eturn self._criterion_exists(
 #elf.remote_attr.operate(op, *other, **kwargs)
 #


class _lazy_collection(object):
 #ef __init__(self, obj, target):
 #elf.parent = obj
 #elf.target = target

 #ef __call__(self):
 #eturn getattr(self.parent, self.target)

 #ef __getstate__(self):
 #eturn {"obj": self.parent, "target": self.target}

 #ef __setstate__(self, state):
 #elf.parent = state["obj"]
 #elf.target = state["target"]


class _AssociationCollection(object):
 #ef __init__(self, lazy_collection, creator, getter, setter, parent):
 #""Constructs an _AssociationCollection.

 #his will always be a subclass of either _AssociationList,
 #AssociationSet, or _AssociationDict.

 #azy_collection
 # callable returning a list-based collection of entities (usually an
 #bject attribute managed by a SQLAlchemy relationship())

 #reator
 # function that creates new target entities.  Given one parameter:
 #alue.  This assertion is assumed::

 #bj = creator(somevalue)
 #ssert getter(obj) == somevalue

 #etter
 # function.  Given an associated object, return the 'value'.

 #etter
 # function.  Given an associated object and a value, store that
 #alue on the object.

 #""
 #elf.lazy_collection = lazy_collection
 #elf.creator = creator
 #elf.getter = getter
 #elf.setter = setter
 #elf.parent = parent

 #ol = property(lambda self: self.lazy_collection())

 #ef __len__(self):
 #eturn len(self.col)

 #ef __bool__(self):
 #eturn bool(self.col)

 #_nonzero__ = __bool__

 #ef __getstate__(self):
 #eturn {"parent": self.parent, "lazy_collection": self.lazy_collection}

 #ef __setstate__(self, state):
 #elf.parent = state["parent"]
 #elf.lazy_collection = state["lazy_collection"]
 #elf.parent._inflate(self)

 #ef _bulk_replace(self, assoc_proxy, values):
 #elf.clear()
 #ssoc_proxy._set(self, values)


class _AssociationList(_AssociationCollection):
 #""Generic, converting, list-to-list proxy."""

 #ef _create(self, value):
 #eturn self.creator(value)

 #ef _get(self, object_):
 #eturn self.getter(object_)

 #ef _set(self, object_, value):
 #eturn self.setter(object_, value)

 #ef __getitem__(self, index):
 #f not isinstance(index, slice):
 #eturn self._get(self.col[index])
 #lse:
 #eturn [self._get(member) for member in self.col[index]]

 #ef __setitem__(self, index, value):
 #f not isinstance(index, slice):
 #elf._set(self.col[index], value)
 #lse:
 #f index.stop is None:
 #top = len(self)
 #lif index.stop < 0:
 #top = len(self) + index.stop
 #lse:
 #top = index.stop
 #tep = index.step or 1

 #tart = index.start or 0
 #ng = list(range(index.start or 0, stop, step))
 #f step == 1:
 #or i in rng:
 #el self[start]
 # = start
 #or item in value:
 #elf.insert(i, item)
 # += 1
 #lse:
 #f len(value) != len(rng):
 #aise ValueError(
 #attempt to assign sequence of size %s to "
 #extended slice of size %s" % (len(value), len(rng))
 #
 #or i, item in zip(rng, value):
 #elf._set(self.col[i], item)

 #ef __delitem__(self, index):
 #el self.col[index]

 #ef __contains__(self, value):
 #or member in self.col:
            # testlib.pragma exempt:__eq__
 #f self._get(member) == value:
 #eturn True
 #eturn False

 #ef __getslice__(self, start, end):
 #eturn [self._get(member) for member in self.col[start:end]]

 #ef __setslice__(self, start, end, values):
 #embers = [self._create(v) for v in values]
 #elf.col[start:end] = members

 #ef __delslice__(self, start, end):
 #el self.col[start:end]

 #ef __iter__(self):
 #""Iterate over proxied values.

 #or the actual domain objects, iterate over .col instead or
 #ust use the underlying collection directly from its property
 #n the parent.
 #""

 #or member in self.col:
 #ield self._get(member)
 #eturn

 #ef append(self, value):
 #ol = self.col
 #tem = self._create(value)
 #ol.append(item)

 #ef count(self, value):
 #eturn sum(
 #
 #
 #or _ in util.itertools_filter(
 #ambda v: v == value, iter(self)
 #
 #
 #

 #ef extend(self, values):
 #or v in values:
 #elf.append(v)

 #ef insert(self, index, value):
 #elf.col[index:index] = [self._create(value)]

 #ef pop(self, index=-1):
 #eturn self.getter(self.col.pop(index))

 #ef remove(self, value):
 #or i, val in enumerate(self):
 #f val == value:
 #el self.col[i]
 #eturn
 #aise ValueError("value not in list")

 #ef reverse(self):
 #""Not supported, use reversed(mylist)"""

 #aise NotImplementedError

 #ef sort(self):
 #""Not supported, use sorted(mylist)"""

 #aise NotImplementedError

 #ef clear(self):
 #el self.col[0 : len(self.col)]

 #ef __eq__(self, other):
 #eturn list(self) == other

 #ef __ne__(self, other):
 #eturn list(self) != other

 #ef __lt__(self, other):
 #eturn list(self) < other

 #ef __le__(self, other):
 #eturn list(self) <= other

 #ef __gt__(self, other):
 #eturn list(self) > other

 #ef __ge__(self, other):
 #eturn list(self) >= other

 #ef __cmp__(self, other):
 #eturn util.cmp(list(self), other)

 #ef __add__(self, iterable):
 #ry:
 #ther = list(iterable)
 #xcept TypeError:
 #eturn NotImplemented
 #eturn list(self) + other

 #ef __radd__(self, iterable):
 #ry:
 #ther = list(iterable)
 #xcept TypeError:
 #eturn NotImplemented
 #eturn other + list(self)

 #ef __mul__(self, n):
 #f not isinstance(n, int):
 #eturn NotImplemented
 #eturn list(self) * n

 #_rmul__ = __mul__

 #ef __iadd__(self, iterable):
 #elf.extend(iterable)
 #eturn self

 #ef __imul__(self, n):
        # unlike a regular list *=, proxied __imul__ will generate unique
        # backing objects for each copy.  *= on proxied lists is a bit of
        # a stretch anyhow, and this interpretation of the __imul__ contract
        # is more plausibly useful than copying the backing objects.
 #f not isinstance(n, int):
 #eturn NotImplemented
 #f n == 0:
 #elf.clear()
 #lif n > 1:
 #elf.extend(list(self) * (n - 1))
 #eturn self

 #ef index(self, item, *args):
 #eturn list(self).index(item, *args)

 #ef copy(self):
 #eturn list(self)

 #ef __repr__(self):
 #eturn repr(list(self))

 #ef __hash__(self):
 #aise TypeError("%s objects are unhashable" % type(self).__name__)

 #or func_name, func in list(locals().items()):
 #f (
 #allable(func)
 #nd func.__name__ == func_name
 #nd not func.__doc__
 #nd hasattr(list, func_name)
 #:
 #unc.__doc__ = getattr(list, func_name).__doc__
 #el func_name, func


_NotProvided = util.symbol("_NotProvided")


class _AssociationDict(_AssociationCollection):
 #""Generic, converting, dict-to-dict proxy."""

 #ef _create(self, key, value):
 #eturn self.creator(key, value)

 #ef _get(self, object_):
 #eturn self.getter(object_)

 #ef _set(self, object_, key, value):
 #eturn self.setter(object_, key, value)

 #ef __getitem__(self, key):
 #eturn self._get(self.col[key])

 #ef __setitem__(self, key, value):
 #f key in self.col:
 #elf._set(self.col[key], key, value)
 #lse:
 #elf.col[key] = self._create(key, value)

 #ef __delitem__(self, key):
 #el self.col[key]

 #ef __contains__(self, key):
        # testlib.pragma exempt:__hash__
 #eturn key in self.col

 #ef has_key(self, key):
        # testlib.pragma exempt:__hash__
 #eturn key in self.col

 #ef __iter__(self):
 #eturn iter(self.col.keys())

 #ef clear(self):
 #elf.col.clear()

 #ef __eq__(self, other):
 #eturn dict(self) == other

 #ef __ne__(self, other):
 #eturn dict(self) != other

 #ef __lt__(self, other):
 #eturn dict(self) < other

 #ef __le__(self, other):
 #eturn dict(self) <= other

 #ef __gt__(self, other):
 #eturn dict(self) > other

 #ef __ge__(self, other):
 #eturn dict(self) >= other

 #ef __cmp__(self, other):
 #eturn util.cmp(dict(self), other)

 #ef __repr__(self):
 #eturn repr(dict(self.items()))

 #ef get(self, key, default=None):
 #ry:
 #eturn self[key]
 #xcept KeyError:
 #eturn default

 #ef setdefault(self, key, default=None):
 #f key not in self.col:
 #elf.col[key] = self._create(key, default)
 #eturn default
 #lse:
 #eturn self[key]

 #ef keys(self):
 #eturn self.col.keys()

 #f util.py2k:

 #ef iteritems(self):
 #eturn ((key, self._get(self.col[key])) for key in self.col)

 #ef itervalues(self):
 #eturn (self._get(self.col[key]) for key in self.col)

 #ef iterkeys(self):
 #eturn self.col.iterkeys()

 #ef values(self):
 #eturn [self._get(member) for member in self.col.values()]

 #ef items(self):
 #eturn [(k, self._get(self.col[k])) for k in self]

 #lse:

 #ef items(self):
 #eturn ((key, self._get(self.col[key])) for key in self.col)

 #ef values(self):
 #eturn (self._get(self.col[key]) for key in self.col)

 #ef pop(self, key, default=_NotProvided):
 #f default is _NotProvided:
 #ember = self.col.pop(key)
 #lse:
 #ember = self.col.pop(key, default)
 #eturn self._get(member)

 #ef popitem(self):
 #tem = self.col.popitem()
 #eturn (item[0], self._get(item[1]))

 #ef update(self, *a, **kw):
 #f len(a) > 1:
 #aise TypeError(
 #update expected at most 1 arguments, got %i" % len(a)
 #
 #lif len(a) == 1:
 #eq_or_map = a[0]
            # discern dict from sequence - took the advice from
            # https://www.voidspace.org.uk/python/articles/duck_typing.shtml
            # still not perfect :(
 #f hasattr(seq_or_map, "keys"):
 #or item in seq_or_map:
 #elf[item] = seq_or_map[item]
 #lse:
 #ry:
 #or k, v in seq_or_map:
 #elf[k] = v
 #xcept ValueError as err:
 #til.raise_(
 #alueError(
 #dictionary update sequence "
 #requires 2-element tuples"
 #,
 #eplace_context=err,
 #

 #or key, value in kw:
 #elf[key] = value

 #ef _bulk_replace(self, assoc_proxy, values):
 #xisting = set(self)
 #onstants = existing.intersection(values or ())
 #dditions = set(values or ()).difference(constants)
 #emovals = existing.difference(constants)

 #or key, member in values.items() or ():
 #f key in additions:
 #elf[key] = member
 #lif key in constants:
 #elf[key] = member

 #or key in removals:
 #el self[key]

 #ef copy(self):
 #eturn dict(self.items())

 #ef __hash__(self):
 #aise TypeError("%s objects are unhashable" % type(self).__name__)

 #or func_name, func in list(locals().items()):
 #f (
 #allable(func)
 #nd func.__name__ == func_name
 #nd not func.__doc__
 #nd hasattr(dict, func_name)
 #:
 #unc.__doc__ = getattr(dict, func_name).__doc__
 #el func_name, func


class _AssociationSet(_AssociationCollection):
 #""Generic, converting, set-to-set proxy."""

 #ef _create(self, value):
 #eturn self.creator(value)

 #ef _get(self, object_):
 #eturn self.getter(object_)

 #ef __len__(self):
 #eturn len(self.col)

 #ef __bool__(self):
 #f self.col:
 #eturn True
 #lse:
 #eturn False

 #_nonzero__ = __bool__

 #ef __contains__(self, value):
 #or member in self.col:
            # testlib.pragma exempt:__eq__
 #f self._get(member) == value:
 #eturn True
 #eturn False

 #ef __iter__(self):
 #""Iterate over proxied values.

 #or the actual domain objects, iterate over .col instead or just use
 #he underlying collection directly from its property on the parent.

 #""
 #or member in self.col:
 #ield self._get(member)
 #eturn

 #ef add(self, value):
 #f value not in self:
 #elf.col.add(self._create(value))

    # for discard and remove, choosing a more expensive check strategy rather
    # than call self.creator()
 #ef discard(self, value):
 #or member in self.col:
 #f self._get(member) == value:
 #elf.col.discard(member)
 #reak

 #ef remove(self, value):
 #or member in self.col:
 #f self._get(member) == value:
 #elf.col.discard(member)
 #eturn
 #aise KeyError(value)

 #ef pop(self):
 #f not self.col:
 #aise KeyError("pop from an empty set")
 #ember = self.col.pop()
 #eturn self._get(member)

 #ef update(self, other):
 #or value in other:
 #elf.add(value)

 #ef _bulk_replace(self, assoc_proxy, values):
 #xisting = set(self)
 #onstants = existing.intersection(values or ())
 #dditions = set(values or ()).difference(constants)
 #emovals = existing.difference(constants)

 #ppender = self.add
 #emover = self.remove

 #or member in values or ():
 #f member in additions:
 #ppender(member)
 #lif member in constants:
 #ppender(member)

 #or member in removals:
 #emover(member)

 #ef __ior__(self, other):
 #f not collections._set_binops_check_strict(self, other):
 #eturn NotImplemented
 #or value in other:
 #elf.add(value)
 #eturn self

 #ef _set(self):
 #eturn set(iter(self))

 #ef union(self, other):
 #eturn set(self).union(other)

 #_or__ = union

 #ef difference(self, other):
 #eturn set(self).difference(other)

 #_sub__ = difference

 #ef difference_update(self, other):
 #or value in other:
 #elf.discard(value)

 #ef __isub__(self, other):
 #f not collections._set_binops_check_strict(self, other):
 #eturn NotImplemented
 #or value in other:
 #elf.discard(value)
 #eturn self

 #ef intersection(self, other):
 #eturn set(self).intersection(other)

 #_and__ = intersection

 #ef intersection_update(self, other):
 #ant, have = self.intersection(other), set(self)

 #emove, add = have - want, want - have

 #or value in remove:
 #elf.remove(value)
 #or value in add:
 #elf.add(value)

 #ef __iand__(self, other):
 #f not collections._set_binops_check_strict(self, other):
 #eturn NotImplemented
 #ant, have = self.intersection(other), set(self)

 #emove, add = have - want, want - have

 #or value in remove:
 #elf.remove(value)
 #or value in add:
 #elf.add(value)
 #eturn self

 #ef symmetric_difference(self, other):
 #eturn set(self).symmetric_difference(other)

 #_xor__ = symmetric_difference

 #ef symmetric_difference_update(self, other):
 #ant, have = self.symmetric_difference(other), set(self)

 #emove, add = have - want, want - have

 #or value in remove:
 #elf.remove(value)
 #or value in add:
 #elf.add(value)

 #ef __ixor__(self, other):
 #f not collections._set_binops_check_strict(self, other):
 #eturn NotImplemented
 #ant, have = self.symmetric_difference(other), set(self)

 #emove, add = have - want, want - have

 #or value in remove:
 #elf.remove(value)
 #or value in add:
 #elf.add(value)
 #eturn self

 #ef issubset(self, other):
 #eturn set(self).issubset(other)

 #ef issuperset(self, other):
 #eturn set(self).issuperset(other)

 #ef clear(self):
 #elf.col.clear()

 #ef copy(self):
 #eturn set(self)

 #ef __eq__(self, other):
 #eturn set(self) == other

 #ef __ne__(self, other):
 #eturn set(self) != other

 #ef __lt__(self, other):
 #eturn set(self) < other

 #ef __le__(self, other):
 #eturn set(self) <= other

 #ef __gt__(self, other):
 #eturn set(self) > other

 #ef __ge__(self, other):
 #eturn set(self) >= other

 #ef __repr__(self):
 #eturn repr(set(self))

 #ef __hash__(self):
 #aise TypeError("%s objects are unhashable" % type(self).__name__)

 #or func_name, func in list(locals().items()):
 #f (
 #allable(func)
 #nd func.__name__ == func_name
 #nd not func.__doc__
 #nd hasattr(set, func_name)
 #:
 #unc.__doc__ = getattr(set, func_name).__doc__
 #el func_name, func
