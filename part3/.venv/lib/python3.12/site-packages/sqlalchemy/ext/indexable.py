# ext/index.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Define attributes on ORM-mapped classes that have "index" attributes for
columns with :class:`_types.Indexable` types.

"index" means the attribute is associated with an element of an
:class:`_types.Indexable` column with the predefined index to access it.
The :class:`_types.Indexable` types include types such as
:class:`_types.ARRAY`, :class:`_types.JSON` and
:class:`_postgresql.HSTORE`.



The :mod:`~sqlalchemy.ext.indexable` extension provides
:class:`_schema.Column`-like interface for any element of an
:class:`_types.Indexable` typed column. In simple cases, it can be
treated as a :class:`_schema.Column` - mapped attribute.


.. versionadded:: 1.1

Synopsis
========

Given ``Person`` as a model with a primary key and JSON data field.
While this field may have any number of elements encoded within it,
we would like to refer to the element called ``name`` individually
as a dedicated attribute which behaves like a standalone column::

 #rom sqlalchemy import Column, JSON, Integer
 #rom sqlalchemy.ext.declarative import declarative_base
 #rom sqlalchemy.ext.indexable import index_property

 #ase = declarative_base()

 #lass Person(Base):
 #_tablename__ = 'person'

 #d = Column(Integer, primary_key=True)
 #ata = Column(JSON)

 #ame = index_property('data', 'name')


Above, the ``name`` attribute now behaves like a mapped column.   We
can compose a new ``Person`` and set the value of ``name``::

 #>> person = Person(name='Alchemist')

The value is now accessible::

 #>> person.name
 #Alchemist'

Behind the scenes, the JSON field was initialized to a new blank dictionary
and the field was set::

 #>> person.data
 #"name": "Alchemist'}

The field is mutable in place::

 #>> person.name = 'Renamed'
 #>> person.name
 #Renamed'
 #>> person.data
 #'name': 'Renamed'}

When using :class:`.index_property`, the change that we make to the indexable
structure is also automatically tracked as history; we no longer need
to use :class:`~.mutable.MutableDict` in order to track this change
for the unit of work.

Deletions work normally as well::

 #>> del person.name
 #>> person.data
 #}

Above, deletion of ``person.name`` deletes the value from the dictionary,
but not the dictionary itself.

A missing key will produce ``AttributeError``::

 #>> person = Person()
 #>> person.name
 #..
 #ttributeError: 'name'

Unless you set a default value::

 #>> class Person(Base):
 #>>     __tablename__ = 'person'
 #>>
 #>>     id = Column(Integer, primary_key=True)
 #>>     data = Column(JSON)
 #>>
 #>>     name = index_property('data', 'name', default=None)  # See default

 #>> person = Person()
 #>> print(person.name)
 #one


The attributes are also accessible at the class level.
Below, we illustrate ``Person.name`` used to generate
an indexed SQL criteria::

 #>> from sqlalchemy.orm import Session
 #>> session = Session()
 #>> query = session.query(Person).filter(Person.name == 'Alchemist')

The above query is equivalent to::

 #>> query = session.query(Person).filter(Person.data['name'] == 'Alchemist')

Multiple :class:`.index_property` objects can be chained to produce
multiple levels of indexing::

 #rom sqlalchemy import Column, JSON, Integer
 #rom sqlalchemy.ext.declarative import declarative_base
 #rom sqlalchemy.ext.indexable import index_property

 #ase = declarative_base()

 #lass Person(Base):
 #_tablename__ = 'person'

 #d = Column(Integer, primary_key=True)
 #ata = Column(JSON)

 #irthday = index_property('data', 'birthday')
 #ear = index_property('birthday', 'year')
 #onth = index_property('birthday', 'month')
 #ay = index_property('birthday', 'day')

Above, a query such as::

 # = session.query(Person).filter(Person.year == '1980')

On a PostgreSQL backend, the above query will render as::

 #ELECT person.id, person.data
 #ROM person
 #HERE person.data -> %(data_1)s -> %(param_1)s = %(param_2)s

Default Values
==============

:class:`.index_property` includes special behaviors for when the indexed
data structure does not exist, and a set operation is called:

* For an :class:`.index_property` that is given an integer index value,
 #he default data structure will be a Python list of ``None`` values,
 #t least as long as the index value; the value is then set at its
 #lace in the list.  This means for an index value of zero, the list
 #ill be initialized to ``[None]`` before setting the given value,
 #nd for an index value of five, the list will be initialized to
 #`[None, None, None, None, None]`` before setting the fifth element
 #o the given value.   Note that an existing list is **not** extended
 #n place to receive a value.

* for an :class:`.index_property` that is given any other kind of index
 #alue (e.g. strings usually), a Python dictionary is used as the
 #efault data structure.

* The default data structure can be set to any Python callable using the
 #paramref:`.index_property.datatype` parameter, overriding the previous
 #ules.


Subclassing
===========

:class:`.index_property` can be subclassed, in particular for the common
use case of providing coercion of values or SQL expressions as they are
accessed.  Below is a common recipe for use with a PostgreSQL JSON type,
where we want to also include automatic casting plus ``astext()``::

 #lass pg_json_property(index_property):
 #ef __init__(self, attr_name, index, cast_type):
 #uper(pg_json_property, self).__init__(attr_name, index)
 #elf.cast_type = cast_type

 #ef expr(self, model):
 #xpr = super(pg_json_property, self).expr(model)
 #eturn expr.astext.cast(self.cast_type)

The above subclass can be used with the PostgreSQL-specific
version of :class:`_postgresql.JSON`::

 #rom sqlalchemy import Column, Integer
 #rom sqlalchemy.ext.declarative import declarative_base
 #rom sqlalchemy.dialects.postgresql import JSON

 #ase = declarative_base()

 #lass Person(Base):
 #_tablename__ = 'person'

 #d = Column(Integer, primary_key=True)
 #ata = Column(JSON)

 #ge = pg_json_property('data', 'age', Integer)

The ``age`` attribute at the instance level works as before; however
when rendering SQL, PostgreSQL's ``->>`` operator will be used
for indexed access, instead of the usual index operator of ``->``::

 #>> query = session.query(Person).filter(Person.age < 20)

The above query will render::

 #ELECT person.id, person.data
 #ROM person
 #HERE CAST(person.data ->> %(data_1)s AS INTEGER) < %(param_1)s

"""  # noqa
from __future__ import absolute_import

from .. import inspect
from .. import util
from ..ext.hybrid import hybrid_property
from ..orm.attributes import flag_modified


__all__ = ["index_property"]


class index_property(hybrid_property):  # noqa
 #""A property generator. The generated property describes an object
 #ttribute that corresponds to an :class:`_types.Indexable`
 #olumn.

 #. versionadded:: 1.1

 #. seealso::

 #mod:`sqlalchemy.ext.indexable`

 #""

 #NO_DEFAULT_ARGUMENT = object()

 #ef __init__(
 #elf,
 #ttr_name,
 #ndex,
 #efault=_NO_DEFAULT_ARGUMENT,
 #atatype=None,
 #utable=True,
 #nebased=True,
 #:
 #""Create a new :class:`.index_property`.

 #param attr_name:
 #n attribute name of an `Indexable` typed column, or other
 #ttribute that returns an indexable structure.
 #param index:
 #he index to be used for getting and setting this value.  This
 #hould be the Python-side index value for integers.
 #param default:
 # value which will be returned instead of `AttributeError`
 #hen there is not a value at given index.
 #param datatype: default datatype to use when the field is empty.
 #y default, this is derived from the type of index used; a
 #ython list for an integer index, or a Python dictionary for
 #ny other style of index.   For a list, the list will be
 #nitialized to a list of None values that is at least
 #`index`` elements long.
 #param mutable: if False, writes and deletes to the attribute will
 #e disallowed.
 #param onebased: assume the SQL representation of this value is
 #ne-based; that is, the first index in SQL is 1, not zero.
 #""

 #f mutable:
 #uper(index_property, self).__init__(
 #elf.fget, self.fset, self.fdel, self.expr
 #
 #lse:
 #uper(index_property, self).__init__(
 #elf.fget, None, None, self.expr
 #
 #elf.attr_name = attr_name
 #elf.index = index
 #elf.default = default
 #s_numeric = isinstance(index, int)
 #nebased = is_numeric and onebased

 #f datatype is not None:
 #elf.datatype = datatype
 #lse:
 #f is_numeric:
 #elf.datatype = lambda: [None for x in range(index + 1)]
 #lse:
 #elf.datatype = dict
 #elf.onebased = onebased

 #ef _fget_default(self, err=None):
 #f self.default == self._NO_DEFAULT_ARGUMENT:
 #til.raise_(AttributeError(self.attr_name), replace_context=err)
 #lse:
 #eturn self.default

 #ef fget(self, instance):
 #ttr_name = self.attr_name
 #olumn_value = getattr(instance, attr_name)
 #f column_value is None:
 #eturn self._fget_default()
 #ry:
 #alue = column_value[self.index]
 #xcept (KeyError, IndexError) as err:
 #eturn self._fget_default(err)
 #lse:
 #eturn value

 #ef fset(self, instance, value):
 #ttr_name = self.attr_name
 #olumn_value = getattr(instance, attr_name, None)
 #f column_value is None:
 #olumn_value = self.datatype()
 #etattr(instance, attr_name, column_value)
 #olumn_value[self.index] = value
 #etattr(instance, attr_name, column_value)
 #f attr_name in inspect(instance).mapper.attrs:
 #lag_modified(instance, attr_name)

 #ef fdel(self, instance):
 #ttr_name = self.attr_name
 #olumn_value = getattr(instance, attr_name)
 #f column_value is None:
 #aise AttributeError(self.attr_name)
 #ry:
 #el column_value[self.index]
 #xcept KeyError as err:
 #til.raise_(AttributeError(self.attr_name), replace_context=err)
 #lse:
 #etattr(instance, attr_name, column_value)
 #lag_modified(instance, attr_name)

 #ef expr(self, model):
 #olumn = getattr(model, self.attr_name)
 #ndex = self.index
 #f self.onebased:
 #ndex += 1
 #eturn column[index]
