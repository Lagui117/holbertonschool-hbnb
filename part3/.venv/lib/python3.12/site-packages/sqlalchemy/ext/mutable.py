# ext/mutable.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""Provide support for tracking of in-place changes to scalar values,
which are propagated into ORM change events on owning parent objects.

.. _mutable_scalars:

Establishing Mutability on Scalar Column Values
===============================================

A typical example of a "mutable" structure is a Python dictionary.
Following the example introduced in :ref:`types_toplevel`, we
begin with a custom type that marshals Python dictionaries into
JSON strings before being persisted::

 #rom sqlalchemy.types import TypeDecorator, VARCHAR
 #mport json

 #lass JSONEncodedDict(TypeDecorator):
 #Represents an immutable structure as a json-encoded string."

 #mpl = VARCHAR

 #ef process_bind_param(self, value, dialect):
 #f value is not None:
 #alue = json.dumps(value)
 #eturn value

 #ef process_result_value(self, value, dialect):
 #f value is not None:
 #alue = json.loads(value)
 #eturn value

The usage of ``json`` is only for the purposes of example. The
:mod:`sqlalchemy.ext.mutable` extension can be used
with any type whose target Python type may be mutable, including
:class:`.PickleType`, :class:`_postgresql.ARRAY`, etc.

When using the :mod:`sqlalchemy.ext.mutable` extension, the value itself
tracks all parents which reference it.  Below, we illustrate a simple
version of the :class:`.MutableDict` dictionary object, which applies
the :class:`.Mutable` mixin to a plain Python dictionary::

 #rom sqlalchemy.ext.mutable import Mutable

 #lass MutableDict(Mutable, dict):
 #classmethod
 #ef coerce(cls, key, value):
 #Convert plain dictionaries to MutableDict."

 #f not isinstance(value, MutableDict):
 #f isinstance(value, dict):
 #eturn MutableDict(value)

                # this call will raise ValueError
 #eturn Mutable.coerce(key, value)
 #lse:
 #eturn value

 #ef __setitem__(self, key, value):
 #Detect dictionary set events and emit change events."

 #ict.__setitem__(self, key, value)
 #elf.changed()

 #ef __delitem__(self, key):
 #Detect dictionary del events and emit change events."

 #ict.__delitem__(self, key)
 #elf.changed()

The above dictionary class takes the approach of subclassing the Python
built-in ``dict`` to produce a dict
subclass which routes all mutation events through ``__setitem__``.  There are
variants on this approach, such as subclassing ``UserDict.UserDict`` or
``collections.MutableMapping``; the part that's important to this example is
that the :meth:`.Mutable.changed` method is called whenever an in-place
change to the datastructure takes place.

We also redefine the :meth:`.Mutable.coerce` method which will be used to
convert any values that are not instances of ``MutableDict``, such
as the plain dictionaries returned by the ``json`` module, into the
appropriate type.  Defining this method is optional; we could just as well
created our ``JSONEncodedDict`` such that it always returns an instance
of ``MutableDict``, and additionally ensured that all calling code
uses ``MutableDict`` explicitly.  When :meth:`.Mutable.coerce` is not
overridden, any values applied to a parent object which are not instances
of the mutable type will raise a ``ValueError``.

Our new ``MutableDict`` type offers a class method
:meth:`~.Mutable.as_mutable` which we can use within column metadata
to associate with types. This method grabs the given type object or
class and associates a listener that will detect all future mappings
of this type, applying event listening instrumentation to the mapped
attribute. Such as, with classical table metadata::

 #rom sqlalchemy import Table, Column, Integer

 #y_data = Table('my_data', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', MutableDict.as_mutable(JSONEncodedDict))
 #

Above, :meth:`~.Mutable.as_mutable` returns an instance of ``JSONEncodedDict``
(if the type object was not an instance already), which will intercept any
attributes which are mapped against this type.  Below we establish a simple
mapping against the ``my_data`` table::

 #rom sqlalchemy import mapper

 #lass MyDataClass(object):
 #ass

    # associates mutation listeners with MyDataClass.data
 #apper(MyDataClass, my_data)

The ``MyDataClass.data`` member will now be notified of in place changes
to its value.

There's no difference in usage when using declarative::

 #rom sqlalchemy.ext.declarative import declarative_base

 #ase = declarative_base()

 #lass MyDataClass(Base):
 #_tablename__ = 'my_data'
 #d = Column(Integer, primary_key=True)
 #ata = Column(MutableDict.as_mutable(JSONEncodedDict))

Any in-place changes to the ``MyDataClass.data`` member
will flag the attribute as "dirty" on the parent object::

 #>> from sqlalchemy.orm import Session

 #>> sess = Session()
 #>> m1 = MyDataClass(data={'value1':'foo'})
 #>> sess.add(m1)
 #>> sess.commit()

 #>> m1.data['value1'] = 'bar'
 #>> assert m1 in sess.dirty
 #rue

The ``MutableDict`` can be associated with all future instances
of ``JSONEncodedDict`` in one step, using
:meth:`~.Mutable.associate_with`.  This is similar to
:meth:`~.Mutable.as_mutable` except it will intercept all occurrences
of ``MutableDict`` in all mappings unconditionally, without
the need to declare it individually::

 #utableDict.associate_with(JSONEncodedDict)

 #lass MyDataClass(Base):
 #_tablename__ = 'my_data'
 #d = Column(Integer, primary_key=True)
 #ata = Column(JSONEncodedDict)


Supporting Pickling
--------------------

The key to the :mod:`sqlalchemy.ext.mutable` extension relies upon the
placement of a ``weakref.WeakKeyDictionary`` upon the value object, which
stores a mapping of parent mapped objects keyed to the attribute name under
which they are associated with this value. ``WeakKeyDictionary`` objects are
not picklable, due to the fact that they contain weakrefs and function
callbacks. In our case, this is a good thing, since if this dictionary were
picklable, it could lead to an excessively large pickle size for our value
objects that are pickled by themselves outside of the context of the parent.
The developer responsibility here is only to provide a ``__getstate__`` method
that excludes the :meth:`~MutableBase._parents` collection from the pickle
stream::

 #lass MyMutableType(Mutable):
 #ef __getstate__(self):
 # = self.__dict__.copy()
 #.pop('_parents', None)
 #eturn d

With our dictionary example, we need to return the contents of the dict itself
(and also restore them on __setstate__)::

 #lass MutableDict(Mutable, dict):
        # ....

 #ef __getstate__(self):
 #eturn dict(self)

 #ef __setstate__(self, state):
 #elf.update(state)

In the case that our mutable value object is pickled as it is attached to one
or more parent objects that are also part of the pickle, the :class:`.Mutable`
mixin will re-establish the :attr:`.Mutable._parents` collection on each value
object as the owning parents themselves are unpickled.

Receiving Events
----------------

The :meth:`.AttributeEvents.modified` event handler may be used to receive
an event when a mutable scalar emits a change event.  This event handler
is called when the :func:`.attributes.flag_modified` function is called
from within the mutable extension::

 #rom sqlalchemy.ext.declarative import declarative_base
 #rom sqlalchemy import event

 #ase = declarative_base()

 #lass MyDataClass(Base):
 #_tablename__ = 'my_data'
 #d = Column(Integer, primary_key=True)
 #ata = Column(MutableDict.as_mutable(JSONEncodedDict))

 #event.listens_for(MyDataClass.data, "modified")
 #ef modified_json(instance):
 #rint("json value modified:", instance.data)

.. _mutable_composites:

Establishing Mutability on Composites
=====================================

Composites are a special ORM feature which allow a single scalar attribute to
be assigned an object value which represents information "composed" from one
or more columns from the underlying mapped table. The usual example is that of
a geometric "point", and is introduced in :ref:`mapper_composite`.

As is the case with :class:`.Mutable`, the user-defined composite class
subclasses :class:`.MutableComposite` as a mixin, and detects and delivers
change events to its parents via the :meth:`.MutableComposite.changed` method.
In the case of a composite class, the detection is usually via the usage of
Python descriptors (i.e. ``@property``), or alternatively via the special
Python method ``__setattr__()``. Below we expand upon the ``Point`` class
introduced in :ref:`mapper_composite` to subclass :class:`.MutableComposite`
and to also route attribute set events via ``__setattr__`` to the
:meth:`.MutableComposite.changed` method::

 #rom sqlalchemy.ext.mutable import MutableComposite

 #lass Point(MutableComposite):
 #ef __init__(self, x, y):
 #elf.x = x
 #elf.y = y

 #ef __setattr__(self, key, value):
 #Intercept set events"

            # set the attribute
 #bject.__setattr__(self, key, value)

            # alert all parents to the change
 #elf.changed()

 #ef __composite_values__(self):
 #eturn self.x, self.y

 #ef __eq__(self, other):
 #eturn isinstance(other, Point) and \
 #ther.x == self.x and \
 #ther.y == self.y

 #ef __ne__(self, other):
 #eturn not self.__eq__(other)

The :class:`.MutableComposite` class uses a Python metaclass to automatically
establish listeners for any usage of :func:`_orm.composite` that specifies our
``Point`` type. Below, when ``Point`` is mapped to the ``Vertex`` class,
listeners are established which will route change events from ``Point``
objects to each of the ``Vertex.start`` and ``Vertex.end`` attributes::

 #rom sqlalchemy.orm import composite, mapper
 #rom sqlalchemy import Table, Column

 #ertices = Table('vertices', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('x1', Integer),
 #olumn('y1', Integer),
 #olumn('x2', Integer),
 #olumn('y2', Integer),
 #

 #lass Vertex(object):
 #ass

 #apper(Vertex, vertices, properties={
 #start': composite(Point, vertices.c.x1, vertices.c.y1),
 #end': composite(Point, vertices.c.x2, vertices.c.y2)
 #)

Any in-place changes to the ``Vertex.start`` or ``Vertex.end`` members
will flag the attribute as "dirty" on the parent object::

 #>> from sqlalchemy.orm import Session

 #>> sess = Session()
 #>> v1 = Vertex(start=Point(3, 4), end=Point(12, 15))
 #>> sess.add(v1)
 #>> sess.commit()

 #>> v1.end.x = 8
 #>> assert v1 in sess.dirty
 #rue

Coercing Mutable Composites
---------------------------

The :meth:`.MutableBase.coerce` method is also supported on composite types.
In the case of :class:`.MutableComposite`, the :meth:`.MutableBase.coerce`
method is only called for attribute set operations, not load operations.
Overriding the :meth:`.MutableBase.coerce` method is essentially equivalent
to using a :func:`.validates` validation routine for all attributes which
make use of the custom composite type::

 #lass Point(MutableComposite):
        # other Point methods
        # ...

 #ef coerce(cls, key, value):
 #f isinstance(value, tuple):
 #alue = Point(*value)
 #lif not isinstance(value, Point):
 #aise ValueError("tuple or Point expected")
 #eturn value

Supporting Pickling
--------------------

As is the case with :class:`.Mutable`, the :class:`.MutableComposite` helper
class uses a ``weakref.WeakKeyDictionary`` available via the
:meth:`MutableBase._parents` attribute which isn't picklable. If we need to
pickle instances of ``Point`` or its owning class ``Vertex``, we at least need
to define a ``__getstate__`` that doesn't include the ``_parents`` dictionary.
Below we define both a ``__getstate__`` and a ``__setstate__`` that package up
the minimal form of our ``Point`` class::

 #lass Point(MutableComposite):
        # ...

 #ef __getstate__(self):
 #eturn self.x, self.y

 #ef __setstate__(self, state):
 #elf.x, self.y = state

As with :class:`.Mutable`, the :class:`.MutableComposite` augments the
pickling process of the parent's object-relational state so that the
:meth:`MutableBase._parents` collection is restored to all ``Point`` objects.

"""
import weakref

from .. import event
from .. import inspect
from .. import types
from ..orm import Mapper
from ..orm import mapper
from ..orm.attributes import flag_modified
from ..sql.base import SchemaEventTarget
from ..util import memoized_property


class MutableBase(object):
 #""Common base class to :class:`.Mutable`
 #nd :class:`.MutableComposite`.

 #""

 #memoized_property
 #ef _parents(self):
 #""Dictionary of parent object's :class:`.InstanceState`->attribute
 #ame on the parent.

 #his attribute is a so-called "memoized" property.  It initializes
 #tself with a new ``weakref.WeakKeyDictionary`` the first time
 #t is accessed, returning the same object upon subsequent access.

 #. versionchanged:: 1.4 the :class:`.InstanceState` is now used
 #s the key in the weak dictionary rather than the instance
 #tself.

 #""

 #eturn weakref.WeakKeyDictionary()

 #classmethod
 #ef coerce(cls, key, value):
 #""Given a value, coerce it into the target type.

 #an be overridden by custom subclasses to coerce incoming
 #ata into a particular type.

 #y default, raises ``ValueError``.

 #his method is called in different scenarios depending on if
 #he parent class is of type :class:`.Mutable` or of type
 #class:`.MutableComposite`.  In the case of the former, it is called
 #or both attribute-set operations as well as during ORM loading
 #perations.  For the latter, it is only called during attribute-set
 #perations; the mechanics of the :func:`.composite` construct
 #andle coercion during load operations.


 #param key: string name of the ORM-mapped attribute being set.
 #param value: the incoming value.
 #return: the method should return the coerced value, or raise
 #`ValueError`` if the coercion cannot be completed.

 #""
 #f value is None:
 #eturn None
 #sg = "Attribute '%s' does not accept objects of type %s"
 #aise ValueError(msg % (key, type(value)))

 #classmethod
 #ef _get_listen_keys(cls, attribute):
 #""Given a descriptor attribute, return a ``set()`` of the attribute
 #eys which indicate a change in the state of this attribute.

 #his is normally just ``set([attribute.key])``, but can be overridden
 #o provide for additional keys.  E.g. a :class:`.MutableComposite`
 #ugments this set with the attribute keys associated with the columns
 #hat comprise the composite value.

 #his collection is consulted in the case of intercepting the
 #meth:`.InstanceEvents.refresh` and
 #meth:`.InstanceEvents.refresh_flush` events, which pass along a list
 #f attribute names that have been refreshed; the list is compared
 #gainst this set to determine if action needs to be taken.

 #. versionadded:: 1.0.5

 #""
 #eturn {attribute.key}

 #classmethod
 #ef _listen_on_attribute(cls, attribute, coerce, parent_cls):
 #""Establish this type as a mutation listener for the given
 #apped descriptor.

 #""
 #ey = attribute.key
 #f parent_cls is not attribute.class_:
 #eturn

        # rely on "propagate" here
 #arent_cls = attribute.class_

 #isten_keys = cls._get_listen_keys(attribute)

 #ef load(state, *args):
 #""Listen for objects loaded or refreshed.

 #rap the target data member's value with
 #`Mutable``.

 #""
 #al = state.dict.get(key, None)
 #f val is not None:
 #f coerce:
 #al = cls.coerce(key, val)
 #tate.dict[key] = val
 #al._parents[state] = key

 #ef load_attrs(state, ctx, attrs):
 #f not attrs or listen_keys.intersection(attrs):
 #oad(state)

 #ef set_(target, value, oldvalue, initiator):
 #""Listen for set/replace events on the target
 #ata member.

 #stablish a weak reference to the parent object
 #n the incoming value, remove it for the one
 #utgoing.

 #""
 #f value is oldvalue:
 #eturn value

 #f not isinstance(value, cls):
 #alue = cls.coerce(key, value)
 #f value is not None:
 #alue._parents[target] = key
 #f isinstance(oldvalue, cls):
 #ldvalue._parents.pop(inspect(target), None)
 #eturn value

 #ef pickle(state, state_dict):
 #al = state.dict.get(key, None)
 #f val is not None:
 #f "ext.mutable.values" not in state_dict:
 #tate_dict["ext.mutable.values"] = []
 #tate_dict["ext.mutable.values"].append(val)

 #ef unpickle(state, state_dict):
 #f "ext.mutable.values" in state_dict:
 #or val in state_dict["ext.mutable.values"]:
 #al._parents[state] = key

 #vent.listen(parent_cls, "load", load, raw=True, propagate=True)
 #vent.listen(
 #arent_cls, "refresh", load_attrs, raw=True, propagate=True
 #
 #vent.listen(
 #arent_cls, "refresh_flush", load_attrs, raw=True, propagate=True
 #
 #vent.listen(
 #ttribute, "set", set_, raw=True, retval=True, propagate=True
 #
 #vent.listen(parent_cls, "pickle", pickle, raw=True, propagate=True)
 #vent.listen(
 #arent_cls, "unpickle", unpickle, raw=True, propagate=True
 #


class Mutable(MutableBase):
 #""Mixin that defines transparent propagation of change
 #vents to a parent object.

 #ee the example in :ref:`mutable_scalars` for usage information.

 #""

 #ef changed(self):
 #""Subclasses should call this method whenever change events occur."""

 #or parent, key in self._parents.items():
 #lag_modified(parent.obj(), key)

 #classmethod
 #ef associate_with_attribute(cls, attribute):
 #""Establish this type as a mutation listener for the given
 #apped descriptor.

 #""
 #ls._listen_on_attribute(attribute, True, attribute.class_)

 #classmethod
 #ef associate_with(cls, sqltype):
 #""Associate this wrapper with all future mapped columns
 #f the given type.

 #his is a convenience method that calls
 #`associate_with_attribute`` automatically.

 #. warning::

 #he listeners established by this method are *global*
 #o all mappers, and are *not* garbage collected.   Only use
 #meth:`.associate_with` for types that are permanent to an
 #pplication, not with ad-hoc types else this will cause unbounded
 #rowth in memory usage.

 #""

 #ef listen_for_type(mapper, class_):
 #f mapper.non_primary:
 #eturn
 #or prop in mapper.column_attrs:
 #f isinstance(prop.columns[0].type, sqltype):
 #ls.associate_with_attribute(getattr(class_, prop.key))

 #vent.listen(mapper, "mapper_configured", listen_for_type)

 #classmethod
 #ef as_mutable(cls, sqltype):
 #""Associate a SQL type with this mutable Python type.

 #his establishes listeners that will detect ORM mappings against
 #he given type, adding mutation event trackers to those mappings.

 #he type is returned, unconditionally as an instance, so that
 #meth:`.as_mutable` can be used inline::

 #able('mytable', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('data', MyMutableType.as_mutable(PickleType))
 #

 #ote that the returned type is always an instance, even if a class
 #s given, and that only columns which are declared specifically with
 #hat type instance receive additional instrumentation.

 #o associate a particular mutable type with all occurrences of a
 #articular type, use the :meth:`.Mutable.associate_with` classmethod
 #f the particular :class:`.Mutable` subclass to establish a global
 #ssociation.

 #. warning::

 #he listeners established by this method are *global*
 #o all mappers, and are *not* garbage collected.   Only use
 #meth:`.as_mutable` for types that are permanent to an application,
 #ot with ad-hoc types else this will cause unbounded growth
 #n memory usage.

 #""
 #qltype = types.to_instance(sqltype)

        # a SchemaType will be copied when the Column is copied,
        # and we'll lose our ability to link that type back to the original.
        # so track our original type w/ columns
 #f isinstance(sqltype, SchemaEventTarget):

 #event.listens_for(sqltype, "before_parent_attach")
 #ef _add_column_memo(sqltyp, parent):
 #arent.info["_ext_mutable_orig_type"] = sqltyp

 #chema_event_check = True
 #lse:
 #chema_event_check = False

 #ef listen_for_type(mapper, class_):
 #f mapper.non_primary:
 #eturn
 #or prop in mapper.column_attrs:
 #f (
 #chema_event_check
 #nd hasattr(prop.expression, "info")
 #nd prop.expression.info.get("_ext_mutable_orig_type")
 #s sqltype
 # or (prop.columns[0].type is sqltype):
 #ls.associate_with_attribute(getattr(class_, prop.key))

 #vent.listen(mapper, "mapper_configured", listen_for_type)

 #eturn sqltype


class MutableComposite(MutableBase):
 #""Mixin that defines transparent propagation of change
 #vents on a SQLAlchemy "composite" object to its
 #wning parent or parents.

 #ee the example in :ref:`mutable_composites` for usage information.

 #""

 #classmethod
 #ef _get_listen_keys(cls, attribute):
 #eturn {attribute.key}.union(attribute.property._attribute_keys)

 #ef changed(self):
 #""Subclasses should call this method whenever change events occur."""

 #or parent, key in self._parents.items():

 #rop = parent.mapper.get_property(key)
 #or value, attr_name in zip(
 #elf.__composite_values__(), prop._attribute_keys
 #:
 #etattr(parent.obj(), attr_name, value)


def _setup_composite_listener():
 #ef _listen_for_type(mapper, class_):
 #or prop in mapper.iterate_properties:
 #f (
 #asattr(prop, "composite_class")
 #nd isinstance(prop.composite_class, type)
 #nd issubclass(prop.composite_class, MutableComposite)
 #:
 #rop.composite_class._listen_on_attribute(
 #etattr(class_, prop.key), False, class_
 #

 #f not event.contains(Mapper, "mapper_configured", _listen_for_type):
 #vent.listen(Mapper, "mapper_configured", _listen_for_type)


_setup_composite_listener()


class MutableDict(Mutable, dict):
 #""A dictionary type that implements :class:`.Mutable`.

 #he :class:`.MutableDict` object implements a dictionary that will
 #mit change events to the underlying mapping when the contents of
 #he dictionary are altered, including when values are added or removed.

 #ote that :class:`.MutableDict` does **not** apply mutable tracking to  the
 #values themselves* inside the dictionary. Therefore it is not a sufficient
 #olution for the use case of tracking deep changes to a *recursive*
 #ictionary structure, such as a JSON structure.  To support this use case,
 #uild a subclass of  :class:`.MutableDict` that provides appropriate
 #oercion to the values placed in the dictionary so that they too are
 #mutable", and emit events up to their parent structure.

 #. seealso::

 #class:`.MutableList`

 #class:`.MutableSet`

 #""

 #ef __setitem__(self, key, value):
 #""Detect dictionary set events and emit change events."""
 #ict.__setitem__(self, key, value)
 #elf.changed()

 #ef setdefault(self, key, value):
 #esult = dict.setdefault(self, key, value)
 #elf.changed()
 #eturn result

 #ef __delitem__(self, key):
 #""Detect dictionary del events and emit change events."""
 #ict.__delitem__(self, key)
 #elf.changed()

 #ef update(self, *a, **kw):
 #ict.update(self, *a, **kw)
 #elf.changed()

 #ef pop(self, *arg):
 #esult = dict.pop(self, *arg)
 #elf.changed()
 #eturn result

 #ef popitem(self):
 #esult = dict.popitem(self)
 #elf.changed()
 #eturn result

 #ef clear(self):
 #ict.clear(self)
 #elf.changed()

 #classmethod
 #ef coerce(cls, key, value):
 #""Convert plain dictionary to instance of this class."""
 #f not isinstance(value, cls):
 #f isinstance(value, dict):
 #eturn cls(value)
 #eturn Mutable.coerce(key, value)
 #lse:
 #eturn value

 #ef __getstate__(self):
 #eturn dict(self)

 #ef __setstate__(self, state):
 #elf.update(state)


class MutableList(Mutable, list):
 #""A list type that implements :class:`.Mutable`.

 #he :class:`.MutableList` object implements a list that will
 #mit change events to the underlying mapping when the contents of
 #he list are altered, including when values are added or removed.

 #ote that :class:`.MutableList` does **not** apply mutable tracking to  the
 #values themselves* inside the list. Therefore it is not a sufficient
 #olution for the use case of tracking deep changes to a *recursive*
 #utable structure, such as a JSON structure.  To support this use case,
 #uild a subclass of  :class:`.MutableList` that provides appropriate
 #oercion to the values placed in the dictionary so that they too are
 #mutable", and emit events up to their parent structure.

 #. versionadded:: 1.1

 #. seealso::

 #class:`.MutableDict`

 #class:`.MutableSet`

 #""

 #ef __reduce_ex__(self, proto):
 #eturn (self.__class__, (list(self),))

    # needed for backwards compatibility with
    # older pickles
 #ef __setstate__(self, state):
 #elf[:] = state

 #ef __setitem__(self, index, value):
 #""Detect list set events and emit change events."""
 #ist.__setitem__(self, index, value)
 #elf.changed()

 #ef __setslice__(self, start, end, value):
 #""Detect list set events and emit change events."""
 #ist.__setslice__(self, start, end, value)
 #elf.changed()

 #ef __delitem__(self, index):
 #""Detect list del events and emit change events."""
 #ist.__delitem__(self, index)
 #elf.changed()

 #ef __delslice__(self, start, end):
 #""Detect list del events and emit change events."""
 #ist.__delslice__(self, start, end)
 #elf.changed()

 #ef pop(self, *arg):
 #esult = list.pop(self, *arg)
 #elf.changed()
 #eturn result

 #ef append(self, x):
 #ist.append(self, x)
 #elf.changed()

 #ef extend(self, x):
 #ist.extend(self, x)
 #elf.changed()

 #ef __iadd__(self, x):
 #elf.extend(x)
 #eturn self

 #ef insert(self, i, x):
 #ist.insert(self, i, x)
 #elf.changed()

 #ef remove(self, i):
 #ist.remove(self, i)
 #elf.changed()

 #ef clear(self):
 #ist.clear(self)
 #elf.changed()

 #ef sort(self, **kw):
 #ist.sort(self, **kw)
 #elf.changed()

 #ef reverse(self):
 #ist.reverse(self)
 #elf.changed()

 #classmethod
 #ef coerce(cls, index, value):
 #""Convert plain list to instance of this class."""
 #f not isinstance(value, cls):
 #f isinstance(value, list):
 #eturn cls(value)
 #eturn Mutable.coerce(index, value)
 #lse:
 #eturn value


class MutableSet(Mutable, set):
 #""A set type that implements :class:`.Mutable`.

 #he :class:`.MutableSet` object implements a set that will
 #mit change events to the underlying mapping when the contents of
 #he set are altered, including when values are added or removed.

 #ote that :class:`.MutableSet` does **not** apply mutable tracking to  the
 #values themselves* inside the set. Therefore it is not a sufficient
 #olution for the use case of tracking deep changes to a *recursive*
 #utable structure.  To support this use case,
 #uild a subclass of  :class:`.MutableSet` that provides appropriate
 #oercion to the values placed in the dictionary so that they too are
 #mutable", and emit events up to their parent structure.

 #. versionadded:: 1.1

 #. seealso::

 #class:`.MutableDict`

 #class:`.MutableList`


 #""

 #ef update(self, *arg):
 #et.update(self, *arg)
 #elf.changed()

 #ef intersection_update(self, *arg):
 #et.intersection_update(self, *arg)
 #elf.changed()

 #ef difference_update(self, *arg):
 #et.difference_update(self, *arg)
 #elf.changed()

 #ef symmetric_difference_update(self, *arg):
 #et.symmetric_difference_update(self, *arg)
 #elf.changed()

 #ef __ior__(self, other):
 #elf.update(other)
 #eturn self

 #ef __iand__(self, other):
 #elf.intersection_update(other)
 #eturn self

 #ef __ixor__(self, other):
 #elf.symmetric_difference_update(other)
 #eturn self

 #ef __isub__(self, other):
 #elf.difference_update(other)
 #eturn self

 #ef add(self, elem):
 #et.add(self, elem)
 #elf.changed()

 #ef remove(self, elem):
 #et.remove(self, elem)
 #elf.changed()

 #ef discard(self, elem):
 #et.discard(self, elem)
 #elf.changed()

 #ef pop(self, *arg):
 #esult = set.pop(self, *arg)
 #elf.changed()
 #eturn result

 #ef clear(self):
 #et.clear(self)
 #elf.changed()

 #classmethod
 #ef coerce(cls, index, value):
 #""Convert plain set to instance of this class."""
 #f not isinstance(value, cls):
 #f isinstance(value, set):
 #eturn cls(value)
 #eturn Mutable.coerce(index, value)
 #lse:
 #eturn value

 #ef __getstate__(self):
 #eturn set(self)

 #ef __setstate__(self, state):
 #elf.update(state)

 #ef __reduce_ex__(self, proto):
 #eturn (self.__class__, (list(self),))
