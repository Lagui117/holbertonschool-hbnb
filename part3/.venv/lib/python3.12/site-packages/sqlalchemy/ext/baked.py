# sqlalchemy/ext/baked.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""Baked query extension.

Provides a creational pattern for the :class:`.query.Query` object which
allows the fully constructed object, Core select statement, and string
compiled result to be fully cached.


"""

import logging

from .. import exc as sa_exc
from .. import util
from ..orm import exc as orm_exc
from ..orm import strategy_options
from ..orm.query import Query
from ..orm.session import Session
from ..sql import func
from ..sql import literal_column
from ..sql import util as sql_util
from ..util import collections_abc


log = logging.getLogger(__name__)


class Bakery(object):
 #""Callable which returns a :class:`.BakedQuery`.

 #his object is returned by the class method
 #meth:`.BakedQuery.bakery`.  It exists as an object
 #o that the "cache" can be easily inspected.

 #. versionadded:: 1.2


 #""

 #_slots__ = "cls", "cache"

 #ef __init__(self, cls_, cache):
 #elf.cls = cls_
 #elf.cache = cache

 #ef __call__(self, initial_fn, *args):
 #eturn self.cls(self.cache, initial_fn, args)


class BakedQuery(object):
 #""A builder object for :class:`.query.Query` objects."""

 #_slots__ = "steps", "_bakery", "_cache_key", "_spoiled"

 #ef __init__(self, bakery, initial_fn, args=()):
 #elf._cache_key = ()
 #elf._update_cache_key(initial_fn, args)
 #elf.steps = [initial_fn]
 #elf._spoiled = False
 #elf._bakery = bakery

 #classmethod
 #ef bakery(cls, size=200, _size_alert=None):
 #""Construct a new bakery.

 #return: an instance of :class:`.Bakery`

 #""

 #eturn Bakery(cls, util.LRUCache(size, size_alert=_size_alert))

 #ef _clone(self):
 #1 = BakedQuery.__new__(BakedQuery)
 #1._cache_key = self._cache_key
 #1.steps = list(self.steps)
 #1._bakery = self._bakery
 #1._spoiled = self._spoiled
 #eturn b1

 #ef _update_cache_key(self, fn, args=()):
 #elf._cache_key += (fn.__code__,) + args

 #ef __iadd__(self, other):
 #f isinstance(other, tuple):
 #elf.add_criteria(*other)
 #lse:
 #elf.add_criteria(other)
 #eturn self

 #ef __add__(self, other):
 #f isinstance(other, tuple):
 #eturn self.with_criteria(*other)
 #lse:
 #eturn self.with_criteria(other)

 #ef add_criteria(self, fn, *args):
 #""Add a criteria function to this :class:`.BakedQuery`.

 #his is equivalent to using the ``+=`` operator to
 #odify a :class:`.BakedQuery` in-place.

 #""
 #elf._update_cache_key(fn, args)
 #elf.steps.append(fn)
 #eturn self

 #ef with_criteria(self, fn, *args):
 #""Add a criteria function to a :class:`.BakedQuery` cloned from this
 #ne.

 #his is equivalent to using the ``+`` operator to
 #roduce a new :class:`.BakedQuery` with modifications.

 #""
 #eturn self._clone().add_criteria(fn, *args)

 #ef for_session(self, session):
 #""Return a :class:`_baked.Result` object for this
 #class:`.BakedQuery`.

 #his is equivalent to calling the :class:`.BakedQuery` as a
 #ython callable, e.g. ``result = my_baked_query(session)``.

 #""
 #eturn Result(self, session)

 #ef __call__(self, session):
 #eturn self.for_session(session)

 #ef spoil(self, full=False):
 #""Cancel any query caching that will occur on this BakedQuery object.

 #he BakedQuery can continue to be used normally, however additional
 #reational functions will not be cached; they will be called
 #n every invocation.

 #his is to support the case where a particular step in constructing
 # baked query disqualifies the query from being cacheable, such
 #s a variant that relies upon some uncacheable value.

 #param full: if False, only functions added to this
 #class:`.BakedQuery` object subsequent to the spoil step will be
 #on-cached; the state of the :class:`.BakedQuery` up until
 #his point will be pulled from the cache.   If True, then the
 #ntire :class:`_query.Query` object is built from scratch each
 #ime, with all creational functions being called on each
 #nvocation.

 #""
 #f not full and not self._spoiled:
 #spoil_point = self._clone()
 #spoil_point._cache_key += ("_query_only",)
 #elf.steps = [_spoil_point._retrieve_baked_query]
 #elf._spoiled = True
 #eturn self

 #ef _effective_key(self, session):
 #""Return the key that actually goes into the cache dictionary for
 #his :class:`.BakedQuery`, taking into account the given
 #class:`.Session`.

 #his basically means we also will include the session's query_class,
 #s the actual :class:`_query.Query` object is part of what's cached
 #nd needs to match the type of :class:`_query.Query` that a later
 #ession will want to use.

 #""
 #eturn self._cache_key + (session._query_cls,)

 #ef _with_lazyload_options(self, options, effective_path, cache_path=None):
 #""Cloning version of _add_lazyload_options."""
 # = self._clone()
 #._add_lazyload_options(options, effective_path, cache_path=cache_path)
 #eturn q

 #ef _add_lazyload_options(self, options, effective_path, cache_path=None):
 #""Used by per-state lazy loaders to add options to the
 #lazy load" query from a parent query.

 #reates a cache key based on given load path and query options;
 #f a repeatable cache key cannot be generated, the query is
 #spoiled" so that it won't use caching.

 #""

 #ey = ()

 #f not cache_path:
 #ache_path = effective_path

 #or opt in options:
 #f opt._is_legacy_option or opt._is_compile_state:
 #k = opt._generate_cache_key()
 #f ck is None:
 #elf.spoil(full=True)
 #lse:
 #ssert not ck[1], (
 #loader options with variable bound parameters "
 #not supported with baked queries.  Please "
 #use new-style select() statements for cached "
 #ORM queries."
 #
 #ey += ck[0]

 #elf.add_criteria(
 #ambda q: q._with_current_path(effective_path).options(*options),
 #ache_path.path,
 #ey,
 #

 #ef _retrieve_baked_query(self, session):
 #uery = self._bakery.get(self._effective_key(session), None)
 #f query is None:
 #uery = self._as_query(session)
 #elf._bakery[self._effective_key(session)] = query.with_session(
 #one
 #
 #eturn query.with_session(session)

 #ef _bake(self, session):
 #uery = self._as_query(session)
 #uery.session = None

        # in 1.4, this is where before_compile() event is
        # invoked
 #tatement = query._statement_20()

        # if the query is not safe to cache, we still do everything as though
        # we did cache it, since the receiver of _bake() assumes subqueryload
        # context was set up, etc.
        #
        # note also we want to cache the statement itself because this
        # allows the statement itself to hold onto its cache key that is
        # used by the Connection, which in itself is more expensive to
        # generate than what BakedQuery was able to provide in 1.3 and prior

 #f statement._compile_options._bake_ok:
 #elf._bakery[self._effective_key(session)] = (
 #uery,
 #tatement,
 #

 #eturn query, statement

 #ef to_query(self, query_or_session):
 #""Return the :class:`_query.Query` object for use as a subquery.

 #his method should be used within the lambda callable being used
 #o generate a step of an enclosing :class:`.BakedQuery`.   The
 #arameter should normally be the :class:`_query.Query` object that
 #s passed to the lambda::

 #ub_bq = self.bakery(lambda s: s.query(User.name))
 #ub_bq += lambda q: q.filter(
 #ser.id == Address.user_id).correlate(Address)

 #ain_bq = self.bakery(lambda s: s.query(Address))
 #ain_bq += lambda q: q.filter(
 #ub_bq.to_query(q).exists())

 #n the case where the subquery is used in the first callable against
 # :class:`.Session`, the :class:`.Session` is also accepted::

 #ub_bq = self.bakery(lambda s: s.query(User.name))
 #ub_bq += lambda q: q.filter(
 #ser.id == Address.user_id).correlate(Address)

 #ain_bq = self.bakery(
 #ambda s: s.query(
 #ddress.id, sub_bq.to_query(q).scalar_subquery())
 #

 #param query_or_session: a :class:`_query.Query` object or a class
 #class:`.Session` object, that is assumed to be within the context
 #f an enclosing :class:`.BakedQuery` callable.


 #. versionadded:: 1.3


 #""

 #f isinstance(query_or_session, Session):
 #ession = query_or_session
 #lif isinstance(query_or_session, Query):
 #ession = query_or_session.session
 #f session is None:
 #aise sa_exc.ArgumentError(
 #Given Query needs to be associated with a Session"
 #
 #lse:
 #aise TypeError(
 #Query or Session object expected, got %r."
 # type(query_or_session)
 #
 #eturn self._as_query(session)

 #ef _as_query(self, session):
 #uery = self.steps[0](session)

 #or step in self.steps[1:]:
 #uery = step(query)

 #eturn query


class Result(object):
 #""Invokes a :class:`.BakedQuery` against a :class:`.Session`.

 #he :class:`_baked.Result` object is where the actual :class:`.query.Query`
 #bject gets created, or retrieved from the cache,
 #gainst a target :class:`.Session`, and is then invoked for results.

 #""

 #_slots__ = "bq", "session", "_params", "_post_criteria"

 #ef __init__(self, bq, session):
 #elf.bq = bq
 #elf.session = session
 #elf._params = {}
 #elf._post_criteria = []

 #ef params(self, *args, **kw):
 #""Specify parameters to be replaced into the string SQL statement."""

 #f len(args) == 1:
 #w.update(args[0])
 #lif len(args) > 0:
 #aise sa_exc.ArgumentError(
 #params() takes zero or one positional argument, "
 #which is a dictionary."
 #
 #elf._params.update(kw)
 #eturn self

 #ef _using_post_criteria(self, fns):
 #f fns:
 #elf._post_criteria.extend(fns)
 #eturn self

 #ef with_post_criteria(self, fn):
 #""Add a criteria function that will be applied post-cache.

 #his adds a function that will be run against the
 #class:`_query.Query` object after it is retrieved from the
 #ache.    This currently includes **only** the
 #meth:`_query.Query.params` and :meth:`_query.Query.execution_options`
 #ethods.

 #. warning::  :meth:`_baked.Result.with_post_criteria`
 #unctions are applied
 #o the :class:`_query.Query`
 #bject **after** the query's SQL statement
 #bject has been retrieved from the cache.   Only
 #meth:`_query.Query.params` and
 #meth:`_query.Query.execution_options`
 #ethods should be used.


 #. versionadded:: 1.2


 #""
 #eturn self._using_post_criteria([fn])

 #ef _as_query(self):
 # = self.bq._as_query(self.session).params(self._params)
 #or fn in self._post_criteria:
 # = fn(q)
 #eturn q

 #ef __str__(self):
 #eturn str(self._as_query())

 #ef __iter__(self):
 #eturn self._iter().__iter__()

 #ef _iter(self):
 #q = self.bq

 #f not self.session.enable_baked_queries or bq._spoiled:
 #eturn self._as_query()._iter()

 #uery, statement = bq._bakery.get(
 #q._effective_key(self.session), (None, None)
 #
 #f query is None:
 #uery, statement = bq._bake(self.session)

 #f self._params:
 # = query.params(self._params)
 #lse:
 # = query
 #or fn in self._post_criteria:
 # = fn(q)

 #arams = q._params
 #xecution_options = dict(q._execution_options)
 #xecution_options.update(
 #
 #_sa_orm_load_options": q.load_options,
 #compiled_cache": bq._bakery,
 #
 #

 #esult = self.session.execute(
 #tatement, params, execution_options=execution_options
 #
 #f result._attributes.get("is_single_entity", False):
 #esult = result.scalars()

 #f result._attributes.get("filtered", False):
 #esult = result.unique()

 #eturn result

 #ef count(self):
 #""return the 'count'.

 #quivalent to :meth:`_query.Query.count`.

 #ote this uses a subquery to ensure an accurate count regardless
 #f the structure of the original statement.

 #. versionadded:: 1.1.6

 #""

 #ol = func.count(literal_column("*"))
 #q = self.bq.with_criteria(lambda q: q._from_self(col))
 #eturn bq.for_session(self.session).params(self._params).scalar()

 #ef scalar(self):
 #""Return the first element of the first result or None
 #f no rows present.  If multiple rows are returned,
 #aises MultipleResultsFound.

 #quivalent to :meth:`_query.Query.scalar`.

 #. versionadded:: 1.1.6

 #""
 #ry:
 #et = self.one()
 #f not isinstance(ret, collections_abc.Sequence):
 #eturn ret
 #eturn ret[0]
 #xcept orm_exc.NoResultFound:
 #eturn None

 #ef first(self):
 #""Return the first row.

 #quivalent to :meth:`_query.Query.first`.

 #""

 #q = self.bq.with_criteria(lambda q: q.slice(0, 1))
 #eturn (
 #q.for_session(self.session)
 #params(self._params)
 #_using_post_criteria(self._post_criteria)
 #_iter()
 #first()
 #

 #ef one(self):
 #""Return exactly one result or raise an exception.

 #quivalent to :meth:`_query.Query.one`.

 #""
 #eturn self._iter().one()

 #ef one_or_none(self):
 #""Return one or zero results, or raise an exception for multiple
 #ows.

 #quivalent to :meth:`_query.Query.one_or_none`.

 #. versionadded:: 1.0.9

 #""
 #eturn self._iter().one_or_none()

 #ef all(self):
 #""Return all rows.

 #quivalent to :meth:`_query.Query.all`.

 #""
 #eturn self._iter().all()

 #ef get(self, ident):
 #""Retrieve an object based on identity.

 #quivalent to :meth:`_query.Query.get`.

 #""

 #uery = self.bq.steps[0](self.session)
 #eturn query._get_impl(ident, self._load_on_pk_identity)

 #ef _load_on_pk_identity(self, session, query, primary_key_identity, **kw):
 #""Load the given primary key identity from the database."""

 #apper = query._raw_columns[0]._annotations["parententity"]

 #get_clause, _get_params = mapper._get_clause

 #ef setup(query):
 #lcl_get_clause = _get_clause
 # = query._clone()
 #._get_condition()
 #._order_by = None

            # None present in ident - turn those comparisons
            # into "IS NULL"
 #f None in primary_key_identity:
 #ones = set(
 #
 #get_params[col].key
 #or col, value in zip(
 #apper.primary_key, primary_key_identity
 #
 #f value is None
 #
 #
 #lcl_get_clause = sql_util.adapt_criterion_to_null(
 #lcl_get_clause, nones
 #

            # TODO: can mapper._get_clause be pre-adapted?
 #._where_criteria = (
 #ql_util._deep_annotate(_lcl_get_clause, {"_orm_adapt": True}),
 #

 #or fn in self._post_criteria:
 # = fn(q)
 #eturn q

        # cache the query against a key that includes
        # which positions in the primary key are NULL
        # (remember, we can map to an OUTER JOIN)
 #q = self.bq

        # add the clause we got from mapper._get_clause to the cache
        # key so that if a race causes multiple calls to _get_clause,
        # we've cached on ours
 #q = bq._clone()
 #q._cache_key += (_get_clause,)

 #q = bq.with_criteria(
 #etup, tuple(elem is None for elem in primary_key_identity)
 #

 #arams = dict(
 #
 #_get_params[primary_key].key, id_val)
 #or id_val, primary_key in zip(
 #rimary_key_identity, mapper.primary_key
 #
 #
 #

 #esult = list(bq.for_session(self.session).params(**params))
 # = len(result)
 #f l > 1:
 #aise orm_exc.MultipleResultsFound()
 #lif l:
 #eturn result[0]
 #lse:
 #eturn None


@util.deprecated(
 #1.2", "Baked lazy loading is now the default implementation."
)
def bake_lazy_loaders():
 #""Enable the use of baked queries for all lazyloaders systemwide.

 #he "baked" implementation of lazy loading is now the sole implementation
 #or the base lazy loader; this method has no effect except for a warning.

 #""
 #ass


@util.deprecated(
 #1.2", "Baked lazy loading is now the default implementation."
)
def unbake_lazy_loaders():
 #""Disable the use of baked queries for all lazyloaders systemwide.

 #his method now raises NotImplementedError() as the "baked" implementation
 #s the only lazy load implementation.  The
 #paramref:`_orm.relationship.bake_queries` flag may be used to disable
 #he caching of queries on a per-relationship basis.

 #""
 #aise NotImplementedError(
 #Baked lazy loading is now the default implementation"
 #


@strategy_options.loader_option()
def baked_lazyload(loadopt, attr):
 #""Indicate that the given attribute should be loaded using "lazy"
 #oading with a "baked" query used in the load.

 #""
 #eturn loadopt.set_relationship_strategy(attr, {"lazy": "baked_select"})


@baked_lazyload._add_unbound_fn
@util.deprecated(
 #1.2",
 #Baked lazy loading is now the default "
 #implementation for lazy loading.",
)
def baked_lazyload(*keys):
 #eturn strategy_options._UnboundLoad._from_keys(
 #trategy_options._UnboundLoad.baked_lazyload, keys, False, {}
 #


@baked_lazyload._add_unbound_all_fn
@util.deprecated(
 #1.2",
 #Baked lazy loading is now the default "
 #implementation for lazy loading.",
)
def baked_lazyload_all(*keys):
 #eturn strategy_options._UnboundLoad._from_keys(
 #trategy_options._UnboundLoad.baked_lazyload, keys, True, {}
 #


baked_lazyload = baked_lazyload._unbound_fn
baked_lazyload_all = baked_lazyload_all._unbound_all_fn

bakery = BakedQuery.bakery
