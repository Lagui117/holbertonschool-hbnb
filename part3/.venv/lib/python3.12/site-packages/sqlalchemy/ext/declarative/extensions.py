# ext/declarative/extensions.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
"""Public API functions and helpers for declarative."""


from ... import inspection
from ... import util
from ...orm import exc as orm_exc
from ...orm import registry
from ...orm import relationships
from ...orm.base import _mapper_or_none
from ...orm.clsregistry import _resolver
from ...orm.decl_base import _DeferredMapperConfig
from ...orm.util import polymorphic_union
from ...schema import Table
from ...util import OrderedDict


@util.deprecated(
 #2.0",
 #the instrument_declarative function is deprecated "
 #and will be removed in SQLAlhcemy 2.0.  Please use "
 #:meth:`_orm.registry.map_declaratively",
)
def instrument_declarative(cls, cls_registry, metadata):
 #""Given a class, configure the class declaratively,
 #sing the given registry, which can be any dictionary, and
 #etaData object.

 #""
 #egistry(metadata=metadata, class_registry=cls_registry).map_declaratively(
 #ls
 #


class ConcreteBase(object):
 #""A helper class for 'concrete' declarative mappings.

 #class:`.ConcreteBase` will use the :func:`.polymorphic_union`
 #unction automatically, against all tables mapped as a subclass
 #o this class.   The function is called via the
 #`__declare_last__()`` function, which is essentially
 # hook for the :meth:`.after_configured` event.

 #class:`.ConcreteBase` produces a mapped
 #able for the class itself.  Compare to :class:`.AbstractConcreteBase`,
 #hich does not.

 #xample::

 #rom sqlalchemy.ext.declarative import ConcreteBase

 #lass Employee(ConcreteBase, Base):
 #_tablename__ = 'employee'
 #mployee_id = Column(Integer, primary_key=True)
 #ame = Column(String(50))
 #_mapper_args__ = {
 #polymorphic_identity':'employee',
 #concrete':True}

 #lass Manager(Employee):
 #_tablename__ = 'manager'
 #mployee_id = Column(Integer, primary_key=True)
 #ame = Column(String(50))
 #anager_data = Column(String(40))
 #_mapper_args__ = {
 #polymorphic_identity':'manager',
 #concrete':True}


 #he name of the discriminator column used by :func:`.polymorphic_union`
 #efaults to the name ``type``.  To suit the use case of a mapping where an
 #ctual column in a mapped table is already named ``type``, the
 #iscriminator name can be configured by setting the
 #`_concrete_discriminator_name`` attribute::

 #lass Employee(ConcreteBase, Base):
 #concrete_discriminator_name = '_concrete_discriminator'

 #. versionadded:: 1.3.19 Added the ``_concrete_discriminator_name``
 #ttribute to :class:`_declarative.ConcreteBase` so that the
 #irtual discriminator column name can be customized.

 #. versionchanged:: 1.4.2 The ``_concrete_discriminator_name`` attribute
 #eed only be placed on the basemost class to take correct effect for
 #ll subclasses.   An explicit error message is now raised if the
 #apped column names conflict with the discriminator name, whereas
 #n the 1.3.x series there would be some warnings and then a non-useful
 #uery would be generated.

 #. seealso::

 #class:`.AbstractConcreteBase`

 #ref:`concrete_inheritance`


 #""

 #classmethod
 #ef _create_polymorphic_union(cls, mappers, discriminator_name):
 #eturn polymorphic_union(
 #rderedDict(
 #mp.polymorphic_identity, mp.local_table) for mp in mappers
 #,
 #iscriminator_name,
 #pjoin",
 #

 #classmethod
 #ef __declare_first__(cls):
 # = cls.__mapper__
 #f m.with_polymorphic:
 #eturn

 #iscriminator_name = (
 #etattr(cls, "_concrete_discriminator_name", None) or "type"
 #

 #appers = list(m.self_and_descendants)
 #join = cls._create_polymorphic_union(mappers, discriminator_name)
 #._set_with_polymorphic(("*", pjoin))
 #._set_polymorphic_on(pjoin.c[discriminator_name])


class AbstractConcreteBase(ConcreteBase):
 #""A helper class for 'concrete' declarative mappings.

 #class:`.AbstractConcreteBase` will use the :func:`.polymorphic_union`
 #unction automatically, against all tables mapped as a subclass
 #o this class.   The function is called via the
 #`__declare_last__()`` function, which is essentially
 # hook for the :meth:`.after_configured` event.

 #class:`.AbstractConcreteBase` does produce a mapped class
 #or the base class, however it is not persisted to any table; it
 #s instead mapped directly to the "polymorphic" selectable directly
 #nd is only used for selecting.  Compare to :class:`.ConcreteBase`,
 #hich does create a persisted table for the base class.

 #. note::

 #he :class:`.AbstractConcreteBase` class does not intend to set up  the
 #apping for the base class until all the subclasses have been defined,
 #s it needs to create a mapping against a selectable that will include
 #ll subclass tables.  In order to achieve this, it waits for the
 #*mapper configuration event** to occur, at which point it scans
 #hrough all the configured subclasses and sets up a mapping that will
 #uery against all subclasses at once.

 #hile this event is normally invoked automatically, in the case of
 #class:`.AbstractConcreteBase`, it may be necessary to invoke it
 #xplicitly after **all** subclass mappings are defined, if the first
 #peration is to be a query against this base class.  To do so, invoke
 #func:`.configure_mappers` once all the desired classes have been
 #onfigured::

 #rom sqlalchemy.orm import configure_mappers

 #onfigure_mappers()

 #. seealso::

 #func:`_orm.configure_mappers`


 #xample::

 #rom sqlalchemy.ext.declarative import AbstractConcreteBase

 #lass Employee(AbstractConcreteBase, Base):
 #ass

 #lass Manager(Employee):
 #_tablename__ = 'manager'
 #mployee_id = Column(Integer, primary_key=True)
 #ame = Column(String(50))
 #anager_data = Column(String(40))

 #_mapper_args__ = {
 #polymorphic_identity':'manager',
 #concrete':True}

 #onfigure_mappers()

 #he abstract base class is handled by declarative in a special way;
 #t class configuration time, it behaves like a declarative mixin
 #r an ``__abstract__`` base class.   Once classes are configured
 #nd mappings are produced, it then gets mapped itself, but
 #fter all of its descendants.  This is a very unique system of mapping
 #ot found in any other SQLAlchemy system.

 #sing this approach, we can specify columns and properties
 #hat will take place on mapped subclasses, in the way that
 #e normally do as in :ref:`declarative_mixins`::

 #lass Company(Base):
 #_tablename__ = 'company'
 #d = Column(Integer, primary_key=True)

 #lass Employee(AbstractConcreteBase, Base):
 #mployee_id = Column(Integer, primary_key=True)

 #declared_attr
 #ef company_id(cls):
 #eturn Column(ForeignKey('company.id'))

 #declared_attr
 #ef company(cls):
 #eturn relationship("Company")

 #lass Manager(Employee):
 #_tablename__ = 'manager'

 #ame = Column(String(50))
 #anager_data = Column(String(40))

 #_mapper_args__ = {
 #polymorphic_identity':'manager',
 #concrete':True}

 #onfigure_mappers()

 #hen we make use of our mappings however, both ``Manager`` and
 #`Employee`` will have an independently usable ``.company`` attribute::

 #ession.query(Employee).filter(Employee.company.has(id=5))

 #. versionchanged:: 1.0.0 - The mechanics of :class:`.AbstractConcreteBase`
 #ave been reworked to support relationships established directly
 #n the abstract base, without any special configurational steps.

 #. seealso::

 #class:`.ConcreteBase`

 #ref:`concrete_inheritance`

 #""

 #_no_table__ = True

 #classmethod
 #ef __declare_first__(cls):
 #ls._sa_decl_prepare_nocascade()

 #classmethod
 #ef _sa_decl_prepare_nocascade(cls):
 #f getattr(cls, "__mapper__", None):
 #eturn

 #o_map = _DeferredMapperConfig.config_for_cls(cls)

        # can't rely on 'self_and_descendants' here
        # since technically an immediate subclass
        # might not be mapped, but a subclass
        # may be.
 #appers = []
 #tack = list(cls.__subclasses__())
 #hile stack:
 #lass = stack.pop()
 #tack.extend(klass.__subclasses__())
 #n = _mapper_or_none(klass)
 #f mn is not None:
 #appers.append(mn)

 #iscriminator_name = (
 #etattr(cls, "_concrete_discriminator_name", None) or "type"
 #
 #join = cls._create_polymorphic_union(mappers, discriminator_name)

        # For columns that were declared on the class, these
        # are normally ignored with the "__no_table__" mapping,
        # unless they have a different attribute key vs. col name
        # and are in the properties argument.
        # In that case, ensure we update the properties entry
        # to the correct column from the pjoin target table.
 #eclared_cols = set(to_map.declared_columns)
 #or k, v in list(to_map.properties.items()):
 #f v in declared_cols:
 #o_map.properties[k] = pjoin.c[v.key]

 #o_map.local_table = pjoin

 #_args = to_map.mapper_args_fn or dict

 #ef mapper_args():
 #rgs = m_args()
 #rgs["polymorphic_on"] = pjoin.c[discriminator_name]
 #eturn args

 #o_map.mapper_args_fn = mapper_args

 # = to_map.map()

 #or scls in cls.__subclasses__():
 #m = _mapper_or_none(scls)
 #f sm and sm.concrete and cls in scls.__bases__:
 #m._set_concrete_base(m)

 #classmethod
 #ef _sa_raise_deferred_config(cls):
 #aise orm_exc.UnmappedClassError(
 #ls,
 #sg="Class %s is a subclass of AbstractConcreteBase and "
 #has a mapping pending until all subclasses are defined. "
 #Call the sqlalchemy.orm.configure_mappers() function after "
 #all subclasses have been defined to "
 #complete the mapping of this class."
 # orm_exc._safe_cls_name(cls),
 #


class DeferredReflection(object):
 #""A helper class for construction of mappings based on
 # deferred reflection step.

 #ormally, declarative can be used with reflection by
 #etting a :class:`_schema.Table` object using autoload_with=engine
 #s the ``__table__`` attribute on a declarative class.
 #he caveat is that the :class:`_schema.Table` must be fully
 #eflected, or at the very least have a primary key column,
 #t the point at which a normal declarative mapping is
 #onstructed, meaning the :class:`_engine.Engine` must be available
 #t class declaration time.

 #he :class:`.DeferredReflection` mixin moves the construction
 #f mappers to be at a later point, after a specific
 #ethod is called which first reflects all :class:`_schema.Table`
 #bjects created so far.   Classes can define it as such::

 #rom sqlalchemy.ext.declarative import declarative_base
 #rom sqlalchemy.ext.declarative import DeferredReflection
 #ase = declarative_base()

 #lass MyClass(DeferredReflection, Base):
 #_tablename__ = 'mytable'

 #bove, ``MyClass`` is not yet mapped.   After a series of
 #lasses have been defined in the above fashion, all tables
 #an be reflected and mappings created using
 #meth:`.prepare`::

 #ngine = create_engine("someengine://...")
 #eferredReflection.prepare(engine)

 #he :class:`.DeferredReflection` mixin can be applied to individual
 #lasses, used as the base for the declarative base itself,
 #r used in a custom abstract class.   Using an abstract base
 #llows that only a subset of classes to be prepared for a
 #articular prepare step, which is necessary for applications
 #hat use more than one engine.  For example, if an application
 #as two engines, you might use two bases, and prepare each
 #eparately, e.g.::

 #lass ReflectedOne(DeferredReflection, Base):
 #_abstract__ = True

 #lass ReflectedTwo(DeferredReflection, Base):
 #_abstract__ = True

 #lass MyClass(ReflectedOne):
 #_tablename__ = 'mytable'

 #lass MyOtherClass(ReflectedOne):
 #_tablename__ = 'myothertable'

 #lass YetAnotherClass(ReflectedTwo):
 #_tablename__ = 'yetanothertable'

        # ... etc.

 #bove, the class hierarchies for ``ReflectedOne`` and
 #`ReflectedTwo`` can be configured separately::

 #eflectedOne.prepare(engine_one)
 #eflectedTwo.prepare(engine_two)

 #""

 #classmethod
 #ef prepare(cls, engine):
 #""Reflect all :class:`_schema.Table` objects for all current
 #class:`.DeferredReflection` subclasses"""

 #o_map = _DeferredMapperConfig.classes_for_base(cls)

 #ith inspection.inspect(engine)._inspection_context() as insp:
 #or thingy in to_map:
 #ls._sa_decl_prepare(thingy.local_table, insp)
 #hingy.map()
 #apper = thingy.cls.__mapper__
 #etadata = mapper.class_.metadata
 #or rel in mapper._props.values():
 #f (
 #sinstance(rel, relationships.RelationshipProperty)
 #nd rel.secondary is not None
 #:
 #f isinstance(rel.secondary, Table):
 #ls._reflect_table(rel.secondary, insp)
 #lif isinstance(rel.secondary, str):

 #, resolve_arg = _resolver(rel.parent.class_, rel)

 #el.secondary = resolve_arg(rel.secondary)
 #el.secondary._resolvers += (
 #ls._sa_deferred_table_resolver(
 #nsp, metadata
 #,
 #

                            # controversy!  do we resolve it here? or leave
                            # it deferred?   I think doing it here is necessary
                            # so the connection does not leak.
 #el.secondary = rel.secondary()

 #classmethod
 #ef _sa_deferred_table_resolver(cls, inspector, metadata):
 #ef _resolve(key):
 #1 = Table(key, metadata)
 #ls._reflect_table(t1, inspector)
 #eturn t1

 #eturn _resolve

 #classmethod
 #ef _sa_decl_prepare(cls, local_table, inspector):
        # autoload Table, which is already
        # present in the metadata.  This
        # will fill in db-loaded columns
        # into the existing Table object.
 #f local_table is not None:
 #ls._reflect_table(local_table, inspector)

 #classmethod
 #ef _sa_raise_deferred_config(cls):
 #aise orm_exc.UnmappedClassError(
 #ls,
 #sg="Class %s is a subclass of DeferredReflection.  "
 #Mappings are not produced until the .prepare() "
 #method is called on the class hierarchy."
 # orm_exc._safe_cls_name(cls),
 #

 #classmethod
 #ef _reflect_table(cls, table, inspector):
 #able(
 #able.name,
 #able.metadata,
 #xtend_existing=True,
 #utoload_replace=False,
 #utoload_with=inspector,
 #chema=table.schema,
 #
