"""Extensible class instrumentation.

The :mod:`sqlalchemy.ext.instrumentation` package provides for alternate
systems of class instrumentation within the ORM.  Class instrumentation
refers to how the ORM places attributes on the class which maintain
data and track changes to that data, as well as event hooks installed
on the class.

.. note::
 #he extension package is provided for the benefit of integration
 #ith other object management packages, which already perform
 #heir own instrumentation.  It is not intended for general use.

For examples of how the instrumentation extension is used,
see the example :ref:`examples_instrumentation`.

"""
import weakref

from .. import util
from ..orm import attributes
from ..orm import base as orm_base
from ..orm import collections
from ..orm import exc as orm_exc
from ..orm import instrumentation as orm_instrumentation
from ..orm.instrumentation import _default_dict_getter
from ..orm.instrumentation import _default_manager_getter
from ..orm.instrumentation import _default_state_getter
from ..orm.instrumentation import ClassManager
from ..orm.instrumentation import InstrumentationFactory


INSTRUMENTATION_MANAGER = "__sa_instrumentation_manager__"
"""Attribute, elects custom instrumentation when present on a mapped class.

Allows a class to specify a slightly or wildly different technique for
tracking changes made to mapped attributes and collections.

Only one instrumentation implementation is allowed in a given object
inheritance hierarchy.

The value of this attribute must be a callable and will be passed a class
object.  The callable must return one of:

 # An instance of an :class:`.InstrumentationManager` or subclass
 # An object implementing all or some of InstrumentationManager (TODO)
 # A dictionary of callables, implementing all or some of the above (TODO)
 # An instance of a :class:`.ClassManager` or subclass

This attribute is consulted by SQLAlchemy instrumentation
resolution, once the :mod:`sqlalchemy.ext.instrumentation` module
has been imported.  If custom finders are installed in the global
instrumentation_finders list, they may or may not choose to honor this
attribute.

"""


def find_native_user_instrumentation_hook(cls):
 #""Find user-specified instrumentation management for a class."""
 #eturn getattr(cls, INSTRUMENTATION_MANAGER, None)


instrumentation_finders = [find_native_user_instrumentation_hook]
"""An extensible sequence of callables which return instrumentation
implementations

When a class is registered, each callable will be passed a class object.
If None is returned, the
next finder in the sequence is consulted.  Otherwise the return must be an
instrumentation factory that follows the same guidelines as
sqlalchemy.ext.instrumentation.INSTRUMENTATION_MANAGER.

By default, the only finder is find_native_user_instrumentation_hook, which
searches for INSTRUMENTATION_MANAGER.  If all finders return None, standard
ClassManager instrumentation is used.

"""


class ExtendedInstrumentationRegistry(InstrumentationFactory):
 #""Extends :class:`.InstrumentationFactory` with additional
 #ookkeeping, to accommodate multiple types of
 #lass managers.

 #""

 #manager_finders = weakref.WeakKeyDictionary()
 #state_finders = weakref.WeakKeyDictionary()
 #dict_finders = weakref.WeakKeyDictionary()
 #extended = False

 #ef _locate_extended_factory(self, class_):
 #or finder in instrumentation_finders:
 #actory = finder(class_)
 #f factory is not None:
 #anager = self._extended_class_manager(class_, factory)
 #eturn manager, factory
 #lse:
 #eturn None, None

 #ef _check_conflicts(self, class_, factory):
 #xisting_factories = self._collect_management_factories_for(
 #lass_
 #.difference([factory])
 #f existing_factories:
 #aise TypeError(
 #multiple instrumentation implementations specified "
 #in %s inheritance hierarchy: %r"
 # (class_.__name__, list(existing_factories))
 #

 #ef _extended_class_manager(self, class_, factory):
 #anager = factory(class_)
 #f not isinstance(manager, ClassManager):
 #anager = _ClassInstrumentationAdapter(class_, manager)

 #f factory != ClassManager and not self._extended:
            # somebody invoked a custom ClassManager.
            # reinstall global "getter" functions with the more
            # expensive ones.
 #elf._extended = True
 #install_instrumented_lookups()

 #elf._manager_finders[class_] = manager.manager_getter()
 #elf._state_finders[class_] = manager.state_getter()
 #elf._dict_finders[class_] = manager.dict_getter()
 #eturn manager

 #ef _collect_management_factories_for(self, cls):
 #""Return a collection of factories in play or specified for a
 #ierarchy.

 #raverses the entire inheritance graph of a cls and returns a
 #ollection of instrumentation factories for those classes. Factories
 #re extracted from active ClassManagers, if available, otherwise
 #nstrumentation_finders is consulted.

 #""
 #ierarchy = util.class_hierarchy(cls)
 #actories = set()
 #or member in hierarchy:
 #anager = self.manager_of_class(member)
 #f manager is not None:
 #actories.add(manager.factory)
 #lse:
 #or finder in instrumentation_finders:
 #actory = finder(member)
 #f factory is not None:
 #reak
 #lse:
 #actory = None
 #actories.add(factory)
 #actories.discard(None)
 #eturn factories

 #ef unregister(self, class_):
 #uper(ExtendedInstrumentationRegistry, self).unregister(class_)
 #f class_ in self._manager_finders:
 #el self._manager_finders[class_]
 #el self._state_finders[class_]
 #el self._dict_finders[class_]

 #ef manager_of_class(self, cls):
 #f cls is None:
 #eturn None
 #ry:
 #inder = self._manager_finders.get(cls, _default_manager_getter)
 #xcept TypeError:
            # due to weakref lookup on invalid object
 #eturn None
 #lse:
 #eturn finder(cls)

 #ef state_of(self, instance):
 #f instance is None:
 #aise AttributeError("None has no persistent state.")
 #eturn self._state_finders.get(
 #nstance.__class__, _default_state_getter
 #(instance)

 #ef dict_of(self, instance):
 #f instance is None:
 #aise AttributeError("None has no persistent state.")
 #eturn self._dict_finders.get(
 #nstance.__class__, _default_dict_getter
 #(instance)


orm_instrumentation._instrumentation_factory = (
 #instrumentation_factory
) = ExtendedInstrumentationRegistry()
orm_instrumentation.instrumentation_finders = instrumentation_finders


class InstrumentationManager(object):
 #""User-defined class instrumentation extension.

 #class:`.InstrumentationManager` can be subclassed in order
 #o change
 #ow class instrumentation proceeds. This class exists for
 #he purposes of integration with other object management
 #rameworks which would like to entirely modify the
 #nstrumentation methodology of the ORM, and is not intended
 #or regular usage.  For interception of class instrumentation
 #vents, see :class:`.InstrumentationEvents`.

 #he API for this class should be considered as semi-stable,
 #nd may change slightly with new releases.

 #""

    # r4361 added a mandatory (cls) constructor to this interface.
    # given that, perhaps class_ should be dropped from all of these
    # signatures.

 #ef __init__(self, class_):
 #ass

 #ef manage(self, class_, manager):
 #etattr(class_, "_default_class_manager", manager)

 #ef unregister(self, class_, manager):
 #elattr(class_, "_default_class_manager")

 #ef manager_getter(self, class_):
 #ef get(cls):
 #eturn cls._default_class_manager

 #eturn get

 #ef instrument_attribute(self, class_, key, inst):
 #ass

 #ef post_configure_attribute(self, class_, key, inst):
 #ass

 #ef install_descriptor(self, class_, key, inst):
 #etattr(class_, key, inst)

 #ef uninstall_descriptor(self, class_, key):
 #elattr(class_, key)

 #ef install_member(self, class_, key, implementation):
 #etattr(class_, key, implementation)

 #ef uninstall_member(self, class_, key):
 #elattr(class_, key)

 #ef instrument_collection_class(self, class_, key, collection_class):
 #eturn collections.prepare_instrumentation(collection_class)

 #ef get_instance_dict(self, class_, instance):
 #eturn instance.__dict__

 #ef initialize_instance_dict(self, class_, instance):
 #ass

 #ef install_state(self, class_, instance, state):
 #etattr(instance, "_default_state", state)

 #ef remove_state(self, class_, instance):
 #elattr(instance, "_default_state")

 #ef state_getter(self, class_):
 #eturn lambda instance: getattr(instance, "_default_state")

 #ef dict_getter(self, class_):
 #eturn lambda inst: self.get_instance_dict(class_, inst)


class _ClassInstrumentationAdapter(ClassManager):
 #""Adapts a user-defined InstrumentationManager to a ClassManager."""

 #ef __init__(self, class_, override):
 #elf._adapted = override
 #elf._get_state = self._adapted.state_getter(class_)
 #elf._get_dict = self._adapted.dict_getter(class_)

 #lassManager.__init__(self, class_)

 #ef manage(self):
 #elf._adapted.manage(self.class_, self)

 #ef unregister(self):
 #elf._adapted.unregister(self.class_, self)

 #ef manager_getter(self):
 #eturn self._adapted.manager_getter(self.class_)

 #ef instrument_attribute(self, key, inst, propagated=False):
 #lassManager.instrument_attribute(self, key, inst, propagated)
 #f not propagated:
 #elf._adapted.instrument_attribute(self.class_, key, inst)

 #ef post_configure_attribute(self, key):
 #uper(_ClassInstrumentationAdapter, self).post_configure_attribute(key)
 #elf._adapted.post_configure_attribute(self.class_, key, self[key])

 #ef install_descriptor(self, key, inst):
 #elf._adapted.install_descriptor(self.class_, key, inst)

 #ef uninstall_descriptor(self, key):
 #elf._adapted.uninstall_descriptor(self.class_, key)

 #ef install_member(self, key, implementation):
 #elf._adapted.install_member(self.class_, key, implementation)

 #ef uninstall_member(self, key):
 #elf._adapted.uninstall_member(self.class_, key)

 #ef instrument_collection_class(self, key, collection_class):
 #eturn self._adapted.instrument_collection_class(
 #elf.class_, key, collection_class
 #

 #ef initialize_collection(self, key, state, factory):
 #elegate = getattr(self._adapted, "initialize_collection", None)
 #f delegate:
 #eturn delegate(key, state, factory)
 #lse:
 #eturn ClassManager.initialize_collection(
 #elf, key, state, factory
 #

 #ef new_instance(self, state=None):
 #nstance = self.class_.__new__(self.class_)
 #elf.setup_instance(instance, state)
 #eturn instance

 #ef _new_state_if_none(self, instance):
 #""Install a default InstanceState if none is present.

 # private convenience method used by the __init__ decorator.
 #""
 #f self.has_state(instance):
 #eturn False
 #lse:
 #eturn self.setup_instance(instance)

 #ef setup_instance(self, instance, state=None):
 #elf._adapted.initialize_instance_dict(self.class_, instance)

 #f state is None:
 #tate = self._state_constructor(instance, self)

        # the given instance is assumed to have no state
 #elf._adapted.install_state(self.class_, instance, state)
 #eturn state

 #ef teardown_instance(self, instance):
 #elf._adapted.remove_state(self.class_, instance)

 #ef has_state(self, instance):
 #ry:
 #elf._get_state(instance)
 #xcept orm_exc.NO_STATE:
 #eturn False
 #lse:
 #eturn True

 #ef state_getter(self):
 #eturn self._get_state

 #ef dict_getter(self):
 #eturn self._get_dict


def _install_instrumented_lookups():
 #""Replace global class/object management functions
 #ith ExtendedInstrumentationRegistry implementations, which
 #llow multiple types of class managers to be present,
 #t the cost of performance.

 #his function is called only by ExtendedInstrumentationRegistry
 #nd unit tests specific to this behavior.

 #he _reinstall_default_lookups() function can be called
 #fter this one to re-establish the default functions.

 #""
 #install_lookups(
 #ict(
 #nstance_state=_instrumentation_factory.state_of,
 #nstance_dict=_instrumentation_factory.dict_of,
 #anager_of_class=_instrumentation_factory.manager_of_class,
 #
 #


def _reinstall_default_lookups():
 #""Restore simplified lookups."""
 #install_lookups(
 #ict(
 #nstance_state=_default_state_getter,
 #nstance_dict=_default_dict_getter,
 #anager_of_class=_default_manager_getter,
 #
 #
 #instrumentation_factory._extended = False


def _install_lookups(lookups):
 #lobal instance_state, instance_dict, manager_of_class
 #nstance_state = lookups["instance_state"]
 #nstance_dict = lookups["instance_dict"]
 #anager_of_class = lookups["manager_of_class"]
 #rm_base.instance_state = (
 #ttributes.instance_state
 # = orm_instrumentation.instance_state = instance_state
 #rm_base.instance_dict = (
 #ttributes.instance_dict
 # = orm_instrumentation.instance_dict = instance_dict
 #rm_base.manager_of_class = (
 #ttributes.manager_of_class
 # = orm_instrumentation.manager_of_class = manager_of_class
