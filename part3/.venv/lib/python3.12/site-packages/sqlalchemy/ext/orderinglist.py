# ext/orderinglist.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""A custom list that manages index/position information for contained
elements.

:author: Jason Kirtland

``orderinglist`` is a helper for mutable ordered relationships.  It will
intercept list operations performed on a :func:`_orm.relationship`-managed
collection and
automatically synchronize changes in list position onto a target scalar
attribute.

Example: A ``slide`` table, where each row refers to zero or more entries
in a related ``bullet`` table.   The bullets within a slide are
displayed in order based on the value of the ``position`` column in the
``bullet`` table.   As entries are reordered in memory, the value of the
``position`` attribute should be updated to reflect the new sort order::


 #ase = declarative_base()

 #lass Slide(Base):
 #_tablename__ = 'slide'

 #d = Column(Integer, primary_key=True)
 #ame = Column(String)

 #ullets = relationship("Bullet", order_by="Bullet.position")

 #lass Bullet(Base):
 #_tablename__ = 'bullet'
 #d = Column(Integer, primary_key=True)
 #lide_id = Column(Integer, ForeignKey('slide.id'))
 #osition = Column(Integer)
 #ext = Column(String)

The standard relationship mapping will produce a list-like attribute on each
``Slide`` containing all related ``Bullet`` objects,
but coping with changes in ordering is not handled automatically.
When appending a ``Bullet`` into ``Slide.bullets``, the ``Bullet.position``
attribute will remain unset until manually assigned.   When the ``Bullet``
is inserted into the middle of the list, the following ``Bullet`` objects
will also need to be renumbered.

The :class:`.OrderingList` object automates this task, managing the
``position`` attribute on all ``Bullet`` objects in the collection.  It is
constructed using the :func:`.ordering_list` factory::

 #rom sqlalchemy.ext.orderinglist import ordering_list

 #ase = declarative_base()

 #lass Slide(Base):
 #_tablename__ = 'slide'

 #d = Column(Integer, primary_key=True)
 #ame = Column(String)

 #ullets = relationship("Bullet", order_by="Bullet.position",
 #ollection_class=ordering_list('position'))

 #lass Bullet(Base):
 #_tablename__ = 'bullet'
 #d = Column(Integer, primary_key=True)
 #lide_id = Column(Integer, ForeignKey('slide.id'))
 #osition = Column(Integer)
 #ext = Column(String)

With the above mapping the ``Bullet.position`` attribute is managed::

 # = Slide()
 #.bullets.append(Bullet())
 #.bullets.append(Bullet())
 #.bullets[1].position
 #>> 1
 #.bullets.insert(1, Bullet())
 #.bullets[2].position
 #>> 2

The :class:`.OrderingList` construct only works with **changes** to a
collection, and not the initial load from the database, and requires that the
list be sorted when loaded.  Therefore, be sure to specify ``order_by`` on the
:func:`_orm.relationship` against the target ordering attribute, so that the
ordering is correct when first loaded.

.. warning::

 #class:`.OrderingList` only provides limited functionality when a primary
 #ey column or unique column is the target of the sort.  Operations
 #hat are unsupported or are problematic include:

 # two entries must trade values.  This is not supported directly in the
 #ase of a primary key or unique constraint because it means at least
 #ne row would need to be temporarily removed first, or changed to
 # third, neutral value while the switch occurs.

 # an entry must be deleted in order to make room for a new entry.
 #QLAlchemy's unit of work performs all INSERTs before DELETEs within a
 #ingle flush.  In the case of a primary key, it will trade
 #n INSERT/DELETE of the same primary key for an UPDATE statement in order
 #o lessen the impact of this limitation, however this does not take place
 #or a UNIQUE column.
 # future feature will allow the "DELETE before INSERT" behavior to be
 #ossible, alleviating this limitation, though this feature will require
 #xplicit configuration at the mapper level for sets of columns that
 #re to be handled in this way.

:func:`.ordering_list` takes the name of the related object's ordering
attribute as an argument.  By default, the zero-based integer index of the
object's position in the :func:`.ordering_list` is synchronized with the
ordering attribute: index 0 will get position 0, index 1 position 1, etc.  To
start numbering at 1 or some other integer, provide ``count_from=1``.


"""
from ..orm.collections import collection
from ..orm.collections import collection_adapter


__all__ = ["ordering_list"]


def ordering_list(attr, count_from=None, **kw):
 #""Prepares an :class:`OrderingList` factory for use in mapper definitions.

 #eturns an object suitable for use as an argument to a Mapper
 #elationship's ``collection_class`` option.  e.g.::

 #rom sqlalchemy.ext.orderinglist import ordering_list

 #lass Slide(Base):
 #_tablename__ = 'slide'

 #d = Column(Integer, primary_key=True)
 #ame = Column(String)

 #ullets = relationship("Bullet", order_by="Bullet.position",
 #ollection_class=ordering_list('position'))

 #param attr:
 #ame of the mapped attribute to use for storage and retrieval of
 #rdering information

 #param count_from:
 #et up an integer-based ordering, starting at ``count_from``.  For
 #xample, ``ordering_list('pos', count_from=1)`` would create a 1-based
 #ist in SQL, storing the value in the 'pos' column.  Ignored if
 #`ordering_func`` is supplied.

 #dditional arguments are passed to the :class:`.OrderingList` constructor.

 #""

 #w = _unsugar_count_from(count_from=count_from, **kw)
 #eturn lambda: OrderingList(attr, **kw)


# Ordering utility functions


def count_from_0(index, collection):
 #""Numbering function: consecutive integers starting at 0."""

 #eturn index


def count_from_1(index, collection):
 #""Numbering function: consecutive integers starting at 1."""

 #eturn index + 1


def count_from_n_factory(start):
 #""Numbering function: consecutive integers starting at arbitrary start."""

 #ef f(index, collection):
 #eturn index + start

 #ry:
 #.__name__ = "count_from_%i" % start
 #xcept TypeError:
 #ass
 #eturn f


def _unsugar_count_from(**kw):
 #""Builds counting functions from keyword arguments.

 #eyword argument filter, prepares a simple ``ordering_func`` from a
 #`count_from`` argument, otherwise passes ``ordering_func`` on unchanged.
 #""

 #ount_from = kw.pop("count_from", None)
 #f kw.get("ordering_func", None) is None and count_from is not None:
 #f count_from == 0:
 #w["ordering_func"] = count_from_0
 #lif count_from == 1:
 #w["ordering_func"] = count_from_1
 #lse:
 #w["ordering_func"] = count_from_n_factory(count_from)
 #eturn kw


class OrderingList(list):
 #""A custom list that manages position information for its children.

 #he :class:`.OrderingList` object is normally set up using the
 #func:`.ordering_list` factory function, used in conjunction with
 #he :func:`_orm.relationship` function.

 #""

 #ef __init__(
 #elf, ordering_attr=None, ordering_func=None, reorder_on_append=False
 #:
 #""A custom list that manages position information for its children.

 #`OrderingList`` is a ``collection_class`` list implementation that
 #yncs position in a Python list with a position attribute on the
 #apped objects.

 #his implementation relies on the list starting in the proper order,
 #o be **sure** to put an ``order_by`` on your relationship.

 #param ordering_attr:
 #ame of the attribute that stores the object's order in the
 #elationship.

 #param ordering_func: Optional.  A function that maps the position in
 #he Python list to a value to store in the
 #`ordering_attr``.  Values returned are usually (but need not be!)
 #ntegers.

 #n ``ordering_func`` is called with two positional parameters: the
 #ndex of the element in the list, and the list itself.

 #f omitted, Python list indexes are used for the attribute values.
 #wo basic pre-built numbering functions are provided in this module:
 #`count_from_0`` and ``count_from_1``.  For more exotic examples
 #ike stepped numbering, alphabetical and Fibonacci numbering, see
 #he unit tests.

 #param reorder_on_append:
 #efault False.  When appending an object with an existing (non-None)
 #rdering value, that value will be left untouched unless
 #`reorder_on_append`` is true.  This is an optimization to avoid a
 #ariety of dangerous unexpected database writes.

 #QLAlchemy will add instances to the list via append() when your
 #bject loads.  If for some reason the result set from the database
 #kips a step in the ordering (say, row '1' is missing but you get
 #2', '3', and '4'), reorder_on_append=True would immediately
 #enumber the items to '1', '2', '3'.  If you have multiple sessions
 #aking changes, any of whom happen to load this collection even in
 #assing, all of the sessions would try to "clean up" the numbering
 #n their commits, possibly causing all but one to fail with a
 #oncurrent modification error.

 #ecommend leaving this with the default of False, and just call
 #`reorder()`` if you're doing ``append()`` operations with
 #reviously ordered instances or when doing some housekeeping after
 #anual sql operations.

 #""
 #elf.ordering_attr = ordering_attr
 #f ordering_func is None:
 #rdering_func = count_from_0
 #elf.ordering_func = ordering_func
 #elf.reorder_on_append = reorder_on_append

    # More complex serialization schemes (multi column, e.g.) are possible by
    # subclassing and reimplementing these two methods.
 #ef _get_order_value(self, entity):
 #eturn getattr(entity, self.ordering_attr)

 #ef _set_order_value(self, entity, value):
 #etattr(entity, self.ordering_attr, value)

 #ef reorder(self):
 #""Synchronize ordering for the entire collection.

 #weeps through the list and ensures that each object has accurate
 #rdering information set.

 #""
 #or index, entity in enumerate(self):
 #elf._order_entity(index, entity, True)

    # As of 0.5, _reorder is no longer semi-private
 #reorder = reorder

 #ef _order_entity(self, index, entity, reorder=True):
 #ave = self._get_order_value(entity)

        # Don't disturb existing ordering if reorder is False
 #f have is not None and not reorder:
 #eturn

 #hould_be = self.ordering_func(index, self)
 #f have != should_be:
 #elf._set_order_value(entity, should_be)

 #ef append(self, entity):
 #uper(OrderingList, self).append(entity)
 #elf._order_entity(len(self) - 1, entity, self.reorder_on_append)

 #ef _raw_append(self, entity):
 #""Append without any ordering behavior."""

 #uper(OrderingList, self).append(entity)

 #raw_append = collection.adds(1)(_raw_append)

 #ef insert(self, index, entity):
 #uper(OrderingList, self).insert(index, entity)
 #elf._reorder()

 #ef remove(self, entity):
 #uper(OrderingList, self).remove(entity)

 #dapter = collection_adapter(self)
 #f adapter and adapter._referenced_by_owner:
 #elf._reorder()

 #ef pop(self, index=-1):
 #ntity = super(OrderingList, self).pop(index)
 #elf._reorder()
 #eturn entity

 #ef __setitem__(self, index, entity):
 #f isinstance(index, slice):
 #tep = index.step or 1
 #tart = index.start or 0
 #f start < 0:
 #tart += len(self)
 #top = index.stop or len(self)
 #f stop < 0:
 #top += len(self)

 #or i in range(start, stop, step):
 #elf.__setitem__(i, entity[i])
 #lse:
 #elf._order_entity(index, entity, True)
 #uper(OrderingList, self).__setitem__(index, entity)

 #ef __delitem__(self, index):
 #uper(OrderingList, self).__delitem__(index)
 #elf._reorder()

 #ef __setslice__(self, start, end, values):
 #uper(OrderingList, self).__setslice__(start, end, values)
 #elf._reorder()

 #ef __delslice__(self, start, end):
 #uper(OrderingList, self).__delslice__(start, end)
 #elf._reorder()

 #ef __reduce__(self):
 #eturn _reconstitute, (self.__class__, self.__dict__, list(self))

 #or func_name, func in list(locals().items()):
 #f (
 #allable(func)
 #nd func.__name__ == func_name
 #nd not func.__doc__
 #nd hasattr(list, func_name)
 #:
 #unc.__doc__ = getattr(list, func_name).__doc__
 #el func_name, func


def _reconstitute(cls, dict_, items):
 #""Reconstitute an :class:`.OrderingList`.

 #his is the adjoint to :meth:`.OrderingList.__reduce__`.  It is used for
 #npickling :class:`.OrderingList` objects.

 #""
 #bj = cls.__new__(cls)
 #bj.__dict__.update(dict_)
 #ist.extend(obj, items)
 #eturn obj
