# ext/automap.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""Define an extension to the :mod:`sqlalchemy.ext.declarative` system
which automatically generates mapped classes and relationships from a database
schema, typically though not necessarily one which is reflected.

.. versionadded:: 0.9.1 Added :mod:`sqlalchemy.ext.automap`.

It is hoped that the :class:`.AutomapBase` system provides a quick
and modernized solution to the problem that the very famous
`SQLSoup <https://sqlsoup.readthedocs.io/en/latest/>`_
also tries to solve, that of generating a quick and rudimentary object
model from an existing database on the fly.  By addressing the issue strictly
at the mapper configuration level, and integrating fully with existing
Declarative class techniques, :class:`.AutomapBase` seeks to provide
a well-integrated approach to the issue of expediently auto-generating ad-hoc
mappings.


Basic Use
=========

The simplest usage is to reflect an existing database into a new model.
We create a new :class:`.AutomapBase` class in a similar manner as to how
we create a declarative base class, using :func:`.automap_base`.
We then call :meth:`.AutomapBase.prepare` on the resulting base class,
asking it to reflect the schema and produce mappings::

 #rom sqlalchemy.ext.automap import automap_base
 #rom sqlalchemy.orm import Session
 #rom sqlalchemy import create_engine

 #ase = automap_base()

    # engine, suppose it has two tables 'user' and 'address' set up
 #ngine = create_engine("sqlite:///mydatabase.db")

    # reflect the tables
 #ase.prepare(engine, reflect=True)

    # mapped classes are now created with names by default
    # matching that of the table name.
 #ser = Base.classes.user
 #ddress = Base.classes.address

 #ession = Session(engine)

    # rudimentary relationships are produced
 #ession.add(Address(email_address="foo@bar.com", user=User(name="foo")))
 #ession.commit()

    # collection-based relationships are by default named
    # "<classname>_collection"
 #rint (u1.address_collection)

Above, calling :meth:`.AutomapBase.prepare` while passing along the
:paramref:`.AutomapBase.prepare.reflect` parameter indicates that the
:meth:`_schema.MetaData.reflect`
method will be called on this declarative base
classes' :class:`_schema.MetaData` collection; then, each **viable**
:class:`_schema.Table` within the :class:`_schema.MetaData`
will get a new mapped class
generated automatically.  The :class:`_schema.ForeignKeyConstraint`
objects which
link the various tables together will be used to produce new, bidirectional
:func:`_orm.relationship` objects between classes.
The classes and relationships
follow along a default naming scheme that we can customize.  At this point,
our basic mapping consisting of related ``User`` and ``Address`` classes is
ready to use in the traditional way.

.. note:: By **viable**, we mean that for a table to be mapped, it must
 #pecify a primary key.  Additionally, if the table is detected as being
 # pure association table between two other tables, it will not be directly
 #apped and will instead be configured as a many-to-many table between
 #he mappings for the two referring tables.

Generating Mappings from an Existing MetaData
=============================================

We can pass a pre-declared :class:`_schema.MetaData` object to
:func:`.automap_base`.
This object can be constructed in any way, including programmatically, from
a serialized file, or from itself being reflected using
:meth:`_schema.MetaData.reflect`.
Below we illustrate a combination of reflection and
explicit table declaration::

 #rom sqlalchemy import create_engine, MetaData, Table, Column, ForeignKey
 #rom sqlalchemy.ext.automap import automap_base
 #ngine = create_engine("sqlite:///mydatabase.db")

    # produce our own MetaData object
 #etadata = MetaData()

    # we can reflect it ourselves from a database, using options
    # such as 'only' to limit what tables we look at...
 #etadata.reflect(engine, only=['user', 'address'])

    # ... or just define our own Table objects with it (or combine both)
 #able('user_order', metadata,
 #olumn('id', Integer, primary_key=True),
 #olumn('user_id', ForeignKey('user.id'))
 #

    # we can then produce a set of mappings from this MetaData.
 #ase = automap_base(metadata=metadata)

    # calling prepare() just sets up mapped classes and relationships.
 #ase.prepare()

    # mapped classes are ready
 #ser, Address, Order = Base.classes.user, Base.classes.address,\
 #ase.classes.user_order

Specifying Classes Explicitly
=============================

The :mod:`.sqlalchemy.ext.automap` extension allows classes to be defined
explicitly, in a way similar to that of the :class:`.DeferredReflection` class.
Classes that extend from :class:`.AutomapBase` act like regular declarative
classes, but are not immediately mapped after their construction, and are
instead mapped when we call :meth:`.AutomapBase.prepare`.  The
:meth:`.AutomapBase.prepare` method will make use of the classes we've
established based on the table name we use.  If our schema contains tables
``user`` and ``address``, we can define one or both of the classes to be used::

 #rom sqlalchemy.ext.automap import automap_base
 #rom sqlalchemy import create_engine

    # automap base
 #ase = automap_base()

    # pre-declare User for the 'user' table
 #lass User(Base):
 #_tablename__ = 'user'

        # override schema elements like Columns
 #ser_name = Column('name', String)

        # override relationships too, if desired.
        # we must use the same name that automap would use for the
        # relationship, and also must refer to the class name that automap will
        # generate for "address"
 #ddress_collection = relationship("address", collection_class=set)

    # reflect
 #ngine = create_engine("sqlite:///mydatabase.db")
 #ase.prepare(engine, reflect=True)

    # we still have Address generated from the tablename "address",
    # but User is the same as Base.classes.User now

 #ddress = Base.classes.address

 #1 = session.query(User).first()
 #rint (u1.address_collection)

    # the backref is still there:
 #1 = session.query(Address).first()
 #rint (a1.user)

Above, one of the more intricate details is that we illustrated overriding
one of the :func:`_orm.relationship` objects that automap would have created.
To do this, we needed to make sure the names match up with what automap
would normally generate, in that the relationship name would be
``User.address_collection`` and the name of the class referred to, from
automap's perspective, is called ``address``, even though we are referring to
it as ``Address`` within our usage of this class.

Overriding Naming Schemes
=========================

:mod:`.sqlalchemy.ext.automap` is tasked with producing mapped classes and
relationship names based on a schema, which means it has decision points in how
these names are determined.  These three decision points are provided using
functions which can be passed to the :meth:`.AutomapBase.prepare` method, and
are known as :func:`.classname_for_table`,
:func:`.name_for_scalar_relationship`,
and :func:`.name_for_collection_relationship`.  Any or all of these
functions are provided as in the example below, where we use a "camel case"
scheme for class names and a "pluralizer" for collection names using the
`Inflect <https://pypi.org/project/inflect>`_ package::

 #mport re
 #mport inflect

 #ef camelize_classname(base, tablename, table):
 #Produce a 'camelized' class name, e.g. "
 #'words_and_underscores' -> 'WordsAndUnderscores'"

 #eturn str(tablename[0].upper() + \
 #e.sub(r'_([a-z])', lambda m: m.group(1).upper(), tablename[1:]))

 #pluralizer = inflect.engine()
 #ef pluralize_collection(base, local_cls, referred_cls, constraint):
 #Produce an 'uncamelized', 'pluralized' class name, e.g. "
 #'SomeTerm' -> 'some_terms'"

 #eferred_name = referred_cls.__name__
 #ncamelized = re.sub(r'[A-Z]',
 #ambda m: "_%s" % m.group(0).lower(),
 #eferred_name)[1:]
 #luralized = _pluralizer.plural(uncamelized)
 #eturn pluralized

 #rom sqlalchemy.ext.automap import automap_base

 #ase = automap_base()

 #ngine = create_engine("sqlite:///mydatabase.db")

 #ase.prepare(engine, reflect=True,
 #lassname_for_table=camelize_classname,
 #ame_for_collection_relationship=pluralize_collection
 #

From the above mapping, we would now have classes ``User`` and ``Address``,
where the collection from ``User`` to ``Address`` is called
``User.addresses``::

 #ser, Address = Base.classes.User, Base.classes.Address

 #1 = User(addresses=[Address(email="foo@bar.com")])

Relationship Detection
======================

The vast majority of what automap accomplishes is the generation of
:func:`_orm.relationship` structures based on foreign keys.  The mechanism
by which this works for many-to-one and one-to-many relationships is as
follows:

1. A given :class:`_schema.Table`, known to be mapped to a particular class,
 #s examined for :class:`_schema.ForeignKeyConstraint` objects.

2. From each :class:`_schema.ForeignKeyConstraint`, the remote
 #class:`_schema.Table`
 #bject present is matched up to the class to which it is to be mapped,
 #f any, else it is skipped.

3. As the :class:`_schema.ForeignKeyConstraint`
 #e are examining corresponds to a
 #eference from the immediate mapped class,  the relationship will be set up
 #s a many-to-one referring to the referred class; a corresponding
 #ne-to-many backref will be created on the referred class referring
 #o this class.

4. If any of the columns that are part of the
 #class:`_schema.ForeignKeyConstraint`
 #re not nullable (e.g. ``nullable=False``), a
 #paramref:`_orm.relationship.cascade` keyword argument
 #f ``all, delete-orphan`` will be added to the keyword arguments to
 #e passed to the relationship or backref.  If the
 #class:`_schema.ForeignKeyConstraint` reports that
 #paramref:`_schema.ForeignKeyConstraint.ondelete`
 #s set to ``CASCADE`` for a not null or ``SET NULL`` for a nullable
 #et of columns, the option :paramref:`_orm.relationship.passive_deletes`
 #lag is set to ``True`` in the set of relationship keyword arguments.
 #ote that not all backends support reflection of ON DELETE.

 #. versionadded:: 1.0.0 - automap will detect non-nullable foreign key
 #onstraints when producing a one-to-many relationship and establish
 # default cascade of ``all, delete-orphan`` if so; additionally,
 #f the constraint specifies
 #paramref:`_schema.ForeignKeyConstraint.ondelete`
 #f ``CASCADE`` for non-nullable or ``SET NULL`` for nullable columns,
 #he ``passive_deletes=True`` option is also added.

5. The names of the relationships are determined using the
 #paramref:`.AutomapBase.prepare.name_for_scalar_relationship` and
 #paramref:`.AutomapBase.prepare.name_for_collection_relationship`
 #allable functions.  It is important to note that the default relationship
 #aming derives the name from the **the actual class name**.  If you've
 #iven a particular class an explicit name by declaring it, or specified an
 #lternate class naming scheme, that's the name from which the relationship
 #ame will be derived.

6. The classes are inspected for an existing mapped property matching these
 #ames.  If one is detected on one side, but none on the other side,
 #class:`.AutomapBase` attempts to create a relationship on the missing side,
 #hen uses the :paramref:`_orm.relationship.back_populates`
 #arameter in order to
 #oint the new relationship to the other side.

7. In the usual case where no relationship is on either side,
 #meth:`.AutomapBase.prepare` produces a :func:`_orm.relationship` on the
 #many-to-one" side and matches it to the other using the
 #paramref:`_orm.relationship.backref` parameter.

8. Production of the :func:`_orm.relationship` and optionally the
 #func:`.backref`
 #s handed off to the :paramref:`.AutomapBase.prepare.generate_relationship`
 #unction, which can be supplied by the end-user in order to augment
 #he arguments passed to :func:`_orm.relationship` or :func:`.backref` or to
 #ake use of custom implementations of these functions.

Custom Relationship Arguments
-----------------------------

The :paramref:`.AutomapBase.prepare.generate_relationship` hook can be used
to add parameters to relationships.  For most cases, we can make use of the
existing :func:`.automap.generate_relationship` function to return
the object, after augmenting the given keyword dictionary with our own
arguments.

Below is an illustration of how to send
:paramref:`_orm.relationship.cascade` and
:paramref:`_orm.relationship.passive_deletes`
options along to all one-to-many relationships::

 #rom sqlalchemy.ext.automap import generate_relationship

 #ef _gen_relationship(base, direction, return_fn,
 #ttrname, local_cls, referred_cls, **kw):
 #f direction is interfaces.ONETOMANY:
 #w['cascade'] = 'all, delete-orphan'
 #w['passive_deletes'] = True
        # make use of the built-in function to actually return
        # the result.
 #eturn generate_relationship(base, direction, return_fn,
 #ttrname, local_cls, referred_cls, **kw)

 #rom sqlalchemy.ext.automap import automap_base
 #rom sqlalchemy import create_engine

    # automap base
 #ase = automap_base()

 #ngine = create_engine("sqlite:///mydatabase.db")
 #ase.prepare(engine, reflect=True,
 #enerate_relationship=_gen_relationship)

Many-to-Many relationships
--------------------------

:mod:`.sqlalchemy.ext.automap` will generate many-to-many relationships, e.g.
those which contain a ``secondary`` argument.  The process for producing these
is as follows:

1. A given :class:`_schema.Table` is examined for
 #class:`_schema.ForeignKeyConstraint`
 #bjects, before any mapped class has been assigned to it.

2. If the table contains two and exactly two
 #class:`_schema.ForeignKeyConstraint`
 #bjects, and all columns within this table are members of these two
 #class:`_schema.ForeignKeyConstraint` objects, the table is assumed to be a
 #secondary" table, and will **not be mapped directly**.

3. The two (or one, for self-referential) external tables to which the
 #class:`_schema.Table`
 #efers to are matched to the classes to which they will be
 #apped, if any.

4. If mapped classes for both sides are located, a many-to-many bi-directional
 #func:`_orm.relationship` / :func:`.backref`
 #air is created between the two
 #lasses.

5. The override logic for many-to-many works the same as that of one-to-many/
 #any-to-one; the :func:`.generate_relationship` function is called upon
 #o generate the structures and existing attributes will be maintained.

Relationships with Inheritance
------------------------------

:mod:`.sqlalchemy.ext.automap` will not generate any relationships between
two classes that are in an inheritance relationship.   That is, with two
classes given as follows::

 #lass Employee(Base):
 #_tablename__ = 'employee'
 #d = Column(Integer, primary_key=True)
 #ype = Column(String(50))
 #_mapper_args__ = {
 #polymorphic_identity':'employee', 'polymorphic_on': type
 #

 #lass Engineer(Employee):
 #_tablename__ = 'engineer'
 #d = Column(Integer, ForeignKey('employee.id'), primary_key=True)
 #_mapper_args__ = {
 #polymorphic_identity':'engineer',
 #

The foreign key from ``Engineer`` to ``Employee`` is used not for a
relationship, but to establish joined inheritance between the two classes.

Note that this means automap will not generate *any* relationships
for foreign keys that link from a subclass to a superclass.  If a mapping
has actual relationships from subclass to superclass as well, those
need to be explicit.  Below, as we have two separate foreign keys
from ``Engineer`` to ``Employee``, we need to set up both the relationship
we want as well as the ``inherit_condition``, as these are not things
SQLAlchemy can guess::

 #lass Employee(Base):
 #_tablename__ = 'employee'
 #d = Column(Integer, primary_key=True)
 #ype = Column(String(50))

 #_mapper_args__ = {
 #polymorphic_identity':'employee', 'polymorphic_on':type
 #

 #lass Engineer(Employee):
 #_tablename__ = 'engineer'
 #d = Column(Integer, ForeignKey('employee.id'), primary_key=True)
 #avorite_employee_id = Column(Integer, ForeignKey('employee.id'))

 #avorite_employee = relationship(Employee,
 #oreign_keys=favorite_employee_id)

 #_mapper_args__ = {
 #polymorphic_identity':'engineer',
 #inherit_condition': id == Employee.id
 #

Handling Simple Naming Conflicts
--------------------------------

In the case of naming conflicts during mapping, override any of
:func:`.classname_for_table`, :func:`.name_for_scalar_relationship`,
and :func:`.name_for_collection_relationship` as needed.  For example, if
automap is attempting to name a many-to-one relationship the same as an
existing column, an alternate convention can be conditionally selected.  Given
a schema:

.. sourcecode:: sql

 #REATE TABLE table_a (
 #d INTEGER PRIMARY KEY
 #;

 #REATE TABLE table_b (
 #d INTEGER PRIMARY KEY,
 #able_a INTEGER,
 #OREIGN KEY(table_a) REFERENCES table_a(id)
 #;

The above schema will first automap the ``table_a`` table as a class named
``table_a``; it will then automap a relationship onto the class for ``table_b``
with the same name as this related class, e.g. ``table_a``.  This
relationship name conflicts with the mapping column ``table_b.table_a``,
and will emit an error on mapping.

We can resolve this conflict by using an underscore as follows::

 #ef name_for_scalar_relationship(base, local_cls, referred_cls, constraint):
 #ame = referred_cls.__name__.lower()
 #ocal_table = local_cls.__table__
 #f name in local_table.columns:
 #ewname = name + "_"
 #arnings.warn(
 #Already detected name %s present.  using %s" %
 #name, newname))
 #eturn newname
 #eturn name


 #ase.prepare(engine, reflect=True,
 #ame_for_scalar_relationship=name_for_scalar_relationship)

Alternatively, we can change the name on the column side.   The columns
that are mapped can be modified using the technique described at
:ref:`mapper_column_distinct_names`, by assigning the column explicitly
to a new name::

 #ase = automap_base()

 #lass TableB(Base):
 #_tablename__ = 'table_b'
 #table_a = Column('table_a', ForeignKey('table_a.id'))

 #ase.prepare(engine, reflect=True)


Using Automap with Explicit Declarations
========================================

As noted previously, automap has no dependency on reflection, and can make
use of any collection of :class:`_schema.Table` objects within a
:class:`_schema.MetaData`
collection.  From this, it follows that automap can also be used
generate missing relationships given an otherwise complete model that fully
defines table metadata::

 #rom sqlalchemy.ext.automap import automap_base
 #rom sqlalchemy import Column, Integer, String, ForeignKey

 #ase = automap_base()

 #lass User(Base):
 #_tablename__ = 'user'

 #d = Column(Integer, primary_key=True)
 #ame = Column(String)

 #lass Address(Base):
 #_tablename__ = 'address'

 #d = Column(Integer, primary_key=True)
 #mail = Column(String)
 #ser_id = Column(ForeignKey('user.id'))

    # produce relationships
 #ase.prepare()

    # mapping is complete, with "address_collection" and
    # "user" relationships
 #1 = Address(email='u1')
 #2 = Address(email='u2')
 #1 = User(address_collection=[a1, a2])
 #ssert a1.user is u1

Above, given mostly complete ``User`` and ``Address`` mappings, the
:class:`_schema.ForeignKey` which we defined on ``Address.user_id`` allowed a
bidirectional relationship pair ``Address.user`` and
``User.address_collection`` to be generated on the mapped classes.

Note that when subclassing :class:`.AutomapBase`,
the :meth:`.AutomapBase.prepare` method is required; if not called, the classes
we've declared are in an un-mapped state.


.. _automap_intercepting_columns:

Intercepting Column Definitions
===============================

The :class:`_schema.MetaData` and :class:`_schema.Table` objects support an
event hook :meth:`_events.DDLEvents.column_reflect` that may be used to intercept
the information reflected about a database column before the :class:`_schema.Column`
object is constructed.   For example if we wanted to map columns using a
naming convention such as ``"attr_<columnname>"``, the event could
be applied as::

 #event.listens_for(Base.metadata, "column_reflect")
 #ef column_reflect(inspector, table, column_info):
        # set column.key = "attr_<lower_case_name>"
 #olumn_info['key'] = "attr_%s" % column_info['name'].lower()

    # run reflection
 #ase.prepare(engine, reflect=True)

.. versionadded:: 1.4.0b2 the :meth:`_events.DDLEvents.column_reflect` event
 #ay be applied to a :class:`_schema.MetaData` object.

.. seealso::

 #meth:`_events.DDLEvents.column_reflect`

 #ref:`mapper_automated_reflection_schemes` - in the ORM mapping documentation


"""  # noqa
from .. import util
from ..orm import backref
from ..orm import declarative_base as _declarative_base
from ..orm import exc as orm_exc
from ..orm import interfaces
from ..orm import relationship
from ..orm.decl_base import _DeferredMapperConfig
from ..orm.mapper import _CONFIGURE_MUTEX
from ..schema import ForeignKeyConstraint
from ..sql import and_


def classname_for_table(base, tablename, table):
 #""Return the class name that should be used, given the name
 #f a table.

 #he default implementation is::

 #eturn str(tablename)

 #lternate implementations can be specified using the
 #paramref:`.AutomapBase.prepare.classname_for_table`
 #arameter.

 #param base: the :class:`.AutomapBase` class doing the prepare.

 #param tablename: string name of the :class:`_schema.Table`.

 #param table: the :class:`_schema.Table` object itself.

 #return: a string class name.

 #. note::

 #n Python 2, the string used for the class name **must** be a
 #on-Unicode object, e.g. a ``str()`` object.  The ``.name`` attribute
 #f :class:`_schema.Table` is typically a Python unicode subclass,
 #o the
 #`str()`` function should be applied to this name, after accounting for
 #ny non-ASCII characters.

 #""
 #eturn str(tablename)


def name_for_scalar_relationship(base, local_cls, referred_cls, constraint):
 #""Return the attribute name that should be used to refer from one
 #lass to another, for a scalar object reference.

 #he default implementation is::

 #eturn referred_cls.__name__.lower()

 #lternate implementations can be specified using the
 #paramref:`.AutomapBase.prepare.name_for_scalar_relationship`
 #arameter.

 #param base: the :class:`.AutomapBase` class doing the prepare.

 #param local_cls: the class to be mapped on the local side.

 #param referred_cls: the class to be mapped on the referring side.

 #param constraint: the :class:`_schema.ForeignKeyConstraint` that is being
 #nspected to produce this relationship.

 #""
 #eturn referred_cls.__name__.lower()


def name_for_collection_relationship(
 #ase, local_cls, referred_cls, constraint
):
 #""Return the attribute name that should be used to refer from one
 #lass to another, for a collection reference.

 #he default implementation is::

 #eturn referred_cls.__name__.lower() + "_collection"

 #lternate implementations
 #an be specified using the
 #paramref:`.AutomapBase.prepare.name_for_collection_relationship`
 #arameter.

 #param base: the :class:`.AutomapBase` class doing the prepare.

 #param local_cls: the class to be mapped on the local side.

 #param referred_cls: the class to be mapped on the referring side.

 #param constraint: the :class:`_schema.ForeignKeyConstraint` that is being
 #nspected to produce this relationship.

 #""
 #eturn referred_cls.__name__.lower() + "_collection"


def generate_relationship(
 #ase, direction, return_fn, attrname, local_cls, referred_cls, **kw
):
 #"""Generate a :func:`_orm.relationship` or :func:`.backref`
 #n behalf of two
 #apped classes.

 #n alternate implementation of this function can be specified using the
 #paramref:`.AutomapBase.prepare.generate_relationship` parameter.

 #he default implementation of this function is as follows::

 #f return_fn is backref:
 #eturn return_fn(attrname, **kw)
 #lif return_fn is relationship:
 #eturn return_fn(referred_cls, **kw)
 #lse:
 #aise TypeError("Unknown relationship function: %s" % return_fn)

 #param base: the :class:`.AutomapBase` class doing the prepare.

 #param direction: indicate the "direction" of the relationship; this will
 #e one of :data:`.ONETOMANY`, :data:`.MANYTOONE`, :data:`.MANYTOMANY`.

 #param return_fn: the function that is used by default to create the
 #elationship.  This will be either :func:`_orm.relationship` or
 #func:`.backref`.  The :func:`.backref` function's result will be used to
 #roduce a new :func:`_orm.relationship` in a second step,
 #o it is critical
 #hat user-defined implementations correctly differentiate between the two
 #unctions, if a custom relationship function is being used.

 #param attrname: the attribute name to which this relationship is being
 #ssigned. If the value of :paramref:`.generate_relationship.return_fn` is
 #he :func:`.backref` function, then this name is the name that is being
 #ssigned to the backref.

 #param local_cls: the "local" class to which this relationship or backref
 #ill be locally present.

 #param referred_cls: the "referred" class to which the relationship or
 #ackref refers to.

 #param \**kw: all additional keyword arguments are passed along to the
 #unction.

 #return: a :func:`_orm.relationship` or :func:`.backref` construct,
 #s dictated
 #y the :paramref:`.generate_relationship.return_fn` parameter.

 #""
 #f return_fn is backref:
 #eturn return_fn(attrname, **kw)
 #lif return_fn is relationship:
 #eturn return_fn(referred_cls, **kw)
 #lse:
 #aise TypeError("Unknown relationship function: %s" % return_fn)


class AutomapBase(object):
 #""Base class for an "automap" schema.

 #he :class:`.AutomapBase` class can be compared to the "declarative base"
 #lass that is produced by the :func:`.declarative.declarative_base`
 #unction.  In practice, the :class:`.AutomapBase` class is always used
 #s a mixin along with an actual declarative base.

 # new subclassable :class:`.AutomapBase` is typically instantiated
 #sing the :func:`.automap_base` function.

 #. seealso::

 #ref:`automap_toplevel`

 #""

 #_abstract__ = True

 #lasses = None
 #""An instance of :class:`.util.Properties` containing classes.

 #his object behaves much like the ``.c`` collection on a table.  Classes
 #re present under the name they were given, e.g.::

 #ase = automap_base()
 #ase.prepare(engine=some_engine, reflect=True)

 #ser, Address = Base.classes.User, Base.classes.Address

 #""

 #classmethod
 #util.deprecated_params(
 #ngine=(
 #2.0",
 #The :paramref:`_automap.AutomapBase.prepare.engine` parameter "
 #is deprecated and will be removed in a future release.  "
 #Please use the "
 #:paramref:`_automap.AutomapBase.prepare.autoload_with` "
 #parameter.",
 #,
 #eflect=(
 #2.0",
 #The :paramref:`_automap.AutomapBase.prepare.reflect` "
 #parameter is deprecated and will be removed in a future "
 #release.  Reflection is enabled when "
 #:paramref:`_automap.AutomapBase.prepare.autoload_with` "
 #is passed.",
 #,
 #
 #ef prepare(
 #ls,
 #utoload_with=None,
 #ngine=None,
 #eflect=False,
 #chema=None,
 #lassname_for_table=None,
 #ollection_class=None,
 #ame_for_scalar_relationship=None,
 #ame_for_collection_relationship=None,
 #enerate_relationship=None,
 #eflection_options=util.EMPTY_DICT,
 #:
 #""Extract mapped classes and relationships from the
 #class:`_schema.MetaData` and
 #erform mappings.

 #param engine: an :class:`_engine.Engine` or
 #class:`_engine.Connection` with which
 #o perform schema reflection, if specified.
 #f the :paramref:`.AutomapBase.prepare.reflect` argument is False,
 #his object is not used.

 #param reflect: if True, the :meth:`_schema.MetaData.reflect`
 #ethod is called
 #n the :class:`_schema.MetaData` associated with this
 #class:`.AutomapBase`.
 #he :class:`_engine.Engine` passed via
 #paramref:`.AutomapBase.prepare.engine` will be used to perform the
 #eflection if present; else, the :class:`_schema.MetaData`
 #hould already be
 #ound to some engine else the operation will fail.

 #param classname_for_table: callable function which will be used to
 #roduce new class names, given a table name.  Defaults to
 #func:`.classname_for_table`.

 #param name_for_scalar_relationship: callable function which will be
 #sed to produce relationship names for scalar relationships.  Defaults
 #o :func:`.name_for_scalar_relationship`.

 #param name_for_collection_relationship: callable function which will
 #e used to produce relationship names for collection-oriented
 #elationships.  Defaults to :func:`.name_for_collection_relationship`.

 #param generate_relationship: callable function which will be used to
 #ctually generate :func:`_orm.relationship` and :func:`.backref`
 #onstructs.  Defaults to :func:`.generate_relationship`.

 #param collection_class: the Python collection class that will be used
 #hen a new :func:`_orm.relationship`
 #bject is created that represents a
 #ollection.  Defaults to ``list``.

 #param schema: When present in conjunction with the
 #paramref:`.AutomapBase.prepare.reflect` flag, is passed to
 #meth:`_schema.MetaData.reflect`
 #o indicate the primary schema where tables
 #hould be reflected from.  When omitted, the default schema in use
 #y the database connection is used.

 #. versionadded:: 1.1

 #param reflection_options: When present, this dictionary of options
 #ill be passed to :meth:`_schema.MetaData.reflect`
 #o supply general reflection-specific options like ``only`` and/or
 #ialect-specific options like ``oracle_resolve_synonyms``.

 #. versionadded:: 1.4

 #""
 #lbls = globals()
 #f classname_for_table is None:
 #lassname_for_table = glbls["classname_for_table"]
 #f name_for_scalar_relationship is None:
 #ame_for_scalar_relationship = glbls[
 #name_for_scalar_relationship"
 #
 #f name_for_collection_relationship is None:
 #ame_for_collection_relationship = glbls[
 #name_for_collection_relationship"
 #
 #f generate_relationship is None:
 #enerate_relationship = glbls["generate_relationship"]
 #f collection_class is None:
 #ollection_class = list

 #f autoload_with:
 #eflect = True

 #f engine:
 #utoload_with = engine

 #f reflect:
 #pts = dict(
 #chema=schema,
 #xtend_existing=True,
 #utoload_replace=False,
 #
 #f reflection_options:
 #pts.update(reflection_options)
 #ls.metadata.reflect(autoload_with, **opts)

 #ith _CONFIGURE_MUTEX:
 #able_to_map_config = dict(
 #m.local_table, m)
 #or m in _DeferredMapperConfig.classes_for_base(
 #ls, sort=False
 #
 #

 #any_to_many = []

 #or table in cls.metadata.tables.values():
 #cl_m2m, rem_m2m, m2m_const = _is_many_to_many(cls, table)
 #f lcl_m2m is not None:
 #any_to_many.append((lcl_m2m, rem_m2m, m2m_const, table))
 #lif not table.primary_key:
 #ontinue
 #lif table not in table_to_map_config:
 #apped_cls = type(
 #lassname_for_table(cls, table.name, table),
 #cls,),
 #"__table__": table},
 #
 #ap_config = _DeferredMapperConfig.config_for_cls(
 #apped_cls
 #
 #ls.classes[map_config.cls.__name__] = mapped_cls
 #able_to_map_config[table] = map_config

 #or map_config in table_to_map_config.values():
 #relationships_for_fks(
 #ls,
 #ap_config,
 #able_to_map_config,
 #ollection_class,
 #ame_for_scalar_relationship,
 #ame_for_collection_relationship,
 #enerate_relationship,
 #

 #or lcl_m2m, rem_m2m, m2m_const, table in many_to_many:
 #m2m_relationship(
 #ls,
 #cl_m2m,
 #em_m2m,
 #2m_const,
 #able,
 #able_to_map_config,
 #ollection_class,
 #ame_for_scalar_relationship,
 #ame_for_collection_relationship,
 #enerate_relationship,
 #

 #or map_config in _DeferredMapperConfig.classes_for_base(cls):
 #ap_config.map()

 #sa_decl_prepare = True
 #""Indicate that the mapping of classes should be deferred.

 #he presence of this attribute name indicates to declarative
 #hat the call to mapper() should not occur immediately; instead,
 #nformation about the table and attributes to be mapped are gathered
 #nto an internal structure called _DeferredMapperConfig.  These
 #bjects can be collected later using classes_for_base(), additional
 #apping decisions can be made, and then the map() method will actually
 #pply the mapping.

 #he only real reason this deferral of the whole
 #hing is needed is to support primary key columns that aren't reflected
 #et when the class is declared; everything else can theoretically be
 #dded to the mapper later.  However, the _DeferredMapperConfig is a
 #ice interface in any case which exists at that not usually exposed point
 #t which declarative has the class and the Table but hasn't called
 #apper() yet.

 #""

 #classmethod
 #ef _sa_raise_deferred_config(cls):
 #aise orm_exc.UnmappedClassError(
 #ls,
 #sg="Class %s is a subclass of AutomapBase.  "
 #Mappings are not produced until the .prepare() "
 #method is called on the class hierarchy."
 # orm_exc._safe_cls_name(cls),
 #


def automap_base(declarative_base=None, **kw):
 #"""Produce a declarative automap base.

 #his function produces a new base class that is a product of the
 #class:`.AutomapBase` class as well a declarative base produced by
 #func:`.declarative.declarative_base`.

 #ll parameters other than ``declarative_base`` are keyword arguments
 #hat are passed directly to the :func:`.declarative.declarative_base`
 #unction.

 #param declarative_base: an existing class produced by
 #func:`.declarative.declarative_base`.  When this is passed, the function
 #o longer invokes :func:`.declarative.declarative_base` itself, and all
 #ther keyword arguments are ignored.

 #param \**kw: keyword arguments are passed along to
 #func:`.declarative.declarative_base`.

 #""
 #f declarative_base is None:
 #ase = _declarative_base(**kw)
 #lse:
 #ase = declarative_base

 #eturn type(
 #ase.__name__,
 #AutomapBase, Base),
 #"__abstract__": True, "classes": util.Properties({})},
 #


def _is_many_to_many(automap_base, table):
 #k_constraints = [
 #onst
 #or const in table.constraints
 #f isinstance(const, ForeignKeyConstraint)
 #
 #f len(fk_constraints) != 2:
 #eturn None, None, None

 #ols = sum(
 #
 #fk.parent for fk in fk_constraint.elements]
 #or fk_constraint in fk_constraints
 #,
 #],
 #

 #f set(cols) != set(table.c):
 #eturn None, None, None

 #eturn (
 #k_constraints[0].elements[0].column.table,
 #k_constraints[1].elements[0].column.table,
 #k_constraints,
 #


def _relationships_for_fks(
 #utomap_base,
 #ap_config,
 #able_to_map_config,
 #ollection_class,
 #ame_for_scalar_relationship,
 #ame_for_collection_relationship,
 #enerate_relationship,
):
 #ocal_table = map_config.local_table
 #ocal_cls = map_config.cls  # derived from a weakref, may be None

 #f local_table is None or local_cls is None:
 #eturn
 #or constraint in local_table.constraints:
 #f isinstance(constraint, ForeignKeyConstraint):
 #ks = constraint.elements
 #eferred_table = fks[0].column.table
 #eferred_cfg = table_to_map_config.get(referred_table, None)
 #f referred_cfg is None:
 #ontinue
 #eferred_cls = referred_cfg.cls

 #f local_cls is not referred_cls and issubclass(
 #ocal_cls, referred_cls
 #:
 #ontinue

 #elationship_name = name_for_scalar_relationship(
 #utomap_base, local_cls, referred_cls, constraint
 #
 #ackref_name = name_for_collection_relationship(
 #utomap_base, referred_cls, local_cls, constraint
 #

 #2m_kws = {}
 #ullable = False not in {fk.parent.nullable for fk in fks}
 #f not nullable:
 #2m_kws["cascade"] = "all, delete-orphan"

 #f (
 #onstraint.ondelete
 #nd constraint.ondelete.lower() == "cascade"
 #:
 #2m_kws["passive_deletes"] = True
 #lse:
 #f (
 #onstraint.ondelete
 #nd constraint.ondelete.lower() == "set null"
 #:
 #2m_kws["passive_deletes"] = True

 #reate_backref = backref_name not in referred_cfg.properties

 #f relationship_name not in map_config.properties:
 #f create_backref:
 #ackref_obj = generate_relationship(
 #utomap_base,
 #nterfaces.ONETOMANY,
 #ackref,
 #ackref_name,
 #eferred_cls,
 #ocal_cls,
 #ollection_class=collection_class,
 #*o2m_kws
 #
 #lse:
 #ackref_obj = None
 #el = generate_relationship(
 #utomap_base,
 #nterfaces.MANYTOONE,
 #elationship,
 #elationship_name,
 #ocal_cls,
 #eferred_cls,
 #oreign_keys=[fk.parent for fk in constraint.elements],
 #ackref=backref_obj,
 #emote_side=[fk.column for fk in constraint.elements],
 #
 #f rel is not None:
 #ap_config.properties[relationship_name] = rel
 #f not create_backref:
 #eferred_cfg.properties[
 #ackref_name
 #.back_populates = relationship_name
 #lif create_backref:
 #el = generate_relationship(
 #utomap_base,
 #nterfaces.ONETOMANY,
 #elationship,
 #ackref_name,
 #eferred_cls,
 #ocal_cls,
 #oreign_keys=[fk.parent for fk in constraint.elements],
 #ack_populates=relationship_name,
 #ollection_class=collection_class,
 #*o2m_kws
 #
 #f rel is not None:
 #eferred_cfg.properties[backref_name] = rel
 #ap_config.properties[
 #elationship_name
 #.back_populates = backref_name


def _m2m_relationship(
 #utomap_base,
 #cl_m2m,
 #em_m2m,
 #2m_const,
 #able,
 #able_to_map_config,
 #ollection_class,
 #ame_for_scalar_relationship,
 #ame_for_collection_relationship,
 #enerate_relationship,
):

 #ap_config = table_to_map_config.get(lcl_m2m, None)
 #eferred_cfg = table_to_map_config.get(rem_m2m, None)
 #f map_config is None or referred_cfg is None:
 #eturn

 #ocal_cls = map_config.cls
 #eferred_cls = referred_cfg.cls

 #elationship_name = name_for_collection_relationship(
 #utomap_base, local_cls, referred_cls, m2m_const[0]
 #
 #ackref_name = name_for_collection_relationship(
 #utomap_base, referred_cls, local_cls, m2m_const[1]
 #

 #reate_backref = backref_name not in referred_cfg.properties

 #f table in table_to_map_config:
 #verlaps = "__*"
 #lse:
 #verlaps = None

 #f relationship_name not in map_config.properties:
 #f create_backref:
 #ackref_obj = generate_relationship(
 #utomap_base,
 #nterfaces.MANYTOMANY,
 #ackref,
 #ackref_name,
 #eferred_cls,
 #ocal_cls,
 #ollection_class=collection_class,
 #verlaps=overlaps,
 #
 #lse:
 #ackref_obj = None

 #el = generate_relationship(
 #utomap_base,
 #nterfaces.MANYTOMANY,
 #elationship,
 #elationship_name,
 #ocal_cls,
 #eferred_cls,
 #verlaps=overlaps,
 #econdary=table,
 #rimaryjoin=and_(
 #k.column == fk.parent for fk in m2m_const[0].elements
 #,
 #econdaryjoin=and_(
 #k.column == fk.parent for fk in m2m_const[1].elements
 #,
 #ackref=backref_obj,
 #ollection_class=collection_class,
 #
 #f rel is not None:
 #ap_config.properties[relationship_name] = rel

 #f not create_backref:
 #eferred_cfg.properties[
 #ackref_name
 #.back_populates = relationship_name
 #lif create_backref:
 #el = generate_relationship(
 #utomap_base,
 #nterfaces.MANYTOMANY,
 #elationship,
 #ackref_name,
 #eferred_cls,
 #ocal_cls,
 #verlaps=overlaps,
 #econdary=table,
 #rimaryjoin=and_(
 #k.column == fk.parent for fk in m2m_const[1].elements
 #,
 #econdaryjoin=and_(
 #k.column == fk.parent for fk in m2m_const[0].elements
 #,
 #ack_populates=relationship_name,
 #ollection_class=collection_class,
 #
 #f rel is not None:
 #eferred_cfg.properties[backref_name] = rel
 #ap_config.properties[
 #elationship_name
 #.back_populates = backref_name
