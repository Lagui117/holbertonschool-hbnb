# ext/hybrid.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

r"""Define attributes on ORM-mapped classes that have "hybrid" behavior.

"hybrid" means the attribute has distinct behaviors defined at the
class level and at the instance level.

The :mod:`~sqlalchemy.ext.hybrid` extension provides a special form of
method decorator, is around 50 lines of code and has almost no
dependencies on the rest of SQLAlchemy.  It can, in theory, work with
any descriptor-based expression system.

Consider a mapping ``Interval``, representing integer ``start`` and ``end``
values. We can define higher level functions on mapped classes that produce SQL
expressions at the class level, and Python expression evaluation at the
instance level.  Below, each function decorated with :class:`.hybrid_method` or
:class:`.hybrid_property` may receive ``self`` as an instance of the class, or
as the class itself::

 #rom sqlalchemy import Column, Integer
 #rom sqlalchemy.ext.declarative import declarative_base
 #rom sqlalchemy.orm import Session, aliased
 #rom sqlalchemy.ext.hybrid import hybrid_property, hybrid_method

 #ase = declarative_base()

 #lass Interval(Base):
 #_tablename__ = 'interval'

 #d = Column(Integer, primary_key=True)
 #tart = Column(Integer, nullable=False)
 #nd = Column(Integer, nullable=False)

 #ef __init__(self, start, end):
 #elf.start = start
 #elf.end = end

 #hybrid_property
 #ef length(self):
 #eturn self.end - self.start

 #hybrid_method
 #ef contains(self, point):
 #eturn (self.start <= point) & (point <= self.end)

 #hybrid_method
 #ef intersects(self, other):
 #eturn self.contains(other.start) | self.contains(other.end)

Above, the ``length`` property returns the difference between the
``end`` and ``start`` attributes.  With an instance of ``Interval``,
this subtraction occurs in Python, using normal Python descriptor
mechanics::

 #>> i1 = Interval(5, 10)
 #>> i1.length
 #

When dealing with the ``Interval`` class itself, the :class:`.hybrid_property`
descriptor evaluates the function body given the ``Interval`` class as
the argument, which when evaluated with SQLAlchemy expression mechanics
(here using the :attr:`.QueryableAttribute.expression` accessor)
returns a new SQL expression::

 #>> print(Interval.length.expression)
 #nterval."end" - interval.start

 #>> print(Session().query(Interval).filter(Interval.length > 10))
 #ELECT interval.id AS interval_id, interval.start AS interval_start,
 #nterval."end" AS interval_end
 #ROM interval
 #HERE interval."end" - interval.start > :param_1

ORM methods such as :meth:`_query.Query.filter_by`
generally use ``getattr()`` to
locate attributes, so can also be used with hybrid attributes::

 #>> print(Session().query(Interval).filter_by(length=5))
 #ELECT interval.id AS interval_id, interval.start AS interval_start,
 #nterval."end" AS interval_end
 #ROM interval
 #HERE interval."end" - interval.start = :param_1

The ``Interval`` class example also illustrates two methods,
``contains()`` and ``intersects()``, decorated with
:class:`.hybrid_method`. This decorator applies the same idea to
methods that :class:`.hybrid_property` applies to attributes.   The
methods return boolean values, and take advantage of the Python ``|``
and ``&`` bitwise operators to produce equivalent instance-level and
SQL expression-level boolean behavior::

 #>> i1.contains(6)
 #rue
 #>> i1.contains(15)
 #alse
 #>> i1.intersects(Interval(7, 18))
 #rue
 #>> i1.intersects(Interval(25, 29))
 #alse

 #>> print(Session().query(Interval).filter(Interval.contains(15)))
 #ELECT interval.id AS interval_id, interval.start AS interval_start,
 #nterval."end" AS interval_end
 #ROM interval
 #HERE interval.start <= :start_1 AND interval."end" > :end_1

 #>> ia = aliased(Interval)
 #>> print(Session().query(Interval, ia).filter(Interval.intersects(ia)))
 #ELECT interval.id AS interval_id, interval.start AS interval_start,
 #nterval."end" AS interval_end, interval_1.id AS interval_1_id,
 #nterval_1.start AS interval_1_start, interval_1."end" AS interval_1_end
 #ROM interval, interval AS interval_1
 #HERE interval.start <= interval_1.start
 #ND interval."end" > interval_1.start
 #R interval.start <= interval_1."end"
 #ND interval."end" > interval_1."end"

.. _hybrid_distinct_expression:

Defining Expression Behavior Distinct from Attribute Behavior
--------------------------------------------------------------

Our usage of the ``&`` and ``|`` bitwise operators above was
fortunate, considering our functions operated on two boolean values to
return a new one.   In many cases, the construction of an in-Python
function and a SQLAlchemy SQL expression have enough differences that
two separate Python expressions should be defined.  The
:mod:`~sqlalchemy.ext.hybrid` decorators define the
:meth:`.hybrid_property.expression` modifier for this purpose.   As an
example we'll define the radius of the interval, which requires the
usage of the absolute value function::

 #rom sqlalchemy import func

 #lass Interval(object):
        # ...

 #hybrid_property
 #ef radius(self):
 #eturn abs(self.length) / 2

 #radius.expression
 #ef radius(cls):
 #eturn func.abs(cls.length) / 2

Above the Python function ``abs()`` is used for instance-level
operations, the SQL function ``ABS()`` is used via the :data:`.func`
object for class-level expressions::

 #>> i1.radius
 #

 #>> print(Session().query(Interval).filter(Interval.radius > 5))
 #ELECT interval.id AS interval_id, interval.start AS interval_start,
 #nterval."end" AS interval_end
 #ROM interval
 #HERE abs(interval."end" - interval.start) / :abs_1 > :param_1

.. note:: When defining an expression for a hybrid property or method, the
 #xpression method **must** retain the name of the original hybrid, else
 #he new hybrid with the additional state will be attached to the class
 #ith the non-matching name. To use the example above::

 #lass Interval(object):
        # ...

 #hybrid_property
 #ef radius(self):
 #eturn abs(self.length) / 2

        # WRONG - the non-matching name will cause this function to be
        # ignored
 #radius.expression
 #ef radius_expression(cls):
 #eturn func.abs(cls.length) / 2

 #his is also true for other mutator methods, such as
 #meth:`.hybrid_property.update_expression`. This is the same behavior
 #s that of the ``@property`` construct that is part of standard Python.

Defining Setters
----------------

Hybrid properties can also define setter methods.  If we wanted
``length`` above, when set, to modify the endpoint value::

 #lass Interval(object):
        # ...

 #hybrid_property
 #ef length(self):
 #eturn self.end - self.start

 #length.setter
 #ef length(self, value):
 #elf.end = self.start + value

The ``length(self, value)`` method is now called upon set::

 #>> i1 = Interval(5, 10)
 #>> i1.length
 #
 #>> i1.length = 12
 #>> i1.end
 #7

.. _hybrid_bulk_update:

Allowing Bulk ORM Update
------------------------

A hybrid can define a custom "UPDATE" handler for when using the
:meth:`_query.Query.update` method, allowing the hybrid to be used in the
SET clause of the update.

Normally, when using a hybrid with :meth:`_query.Query.update`, the SQL
expression is used as the column that's the target of the SET.  If our
``Interval`` class had a hybrid ``start_point`` that linked to
``Interval.start``, this could be substituted directly::

 #ession.query(Interval).update({Interval.start_point: 10})

However, when using a composite hybrid like ``Interval.length``, this
hybrid represents more than one column.   We can set up a handler that will
accommodate a value passed to :meth:`_query.Query.update` which can affect
this, using the :meth:`.hybrid_property.update_expression` decorator.
A handler that works similarly to our setter would be::

 #lass Interval(object):
        # ...

 #hybrid_property
 #ef length(self):
 #eturn self.end - self.start

 #length.setter
 #ef length(self, value):
 #elf.end = self.start + value

 #length.update_expression
 #ef length(cls, value):
 #eturn [
 #cls.end, cls.start + value)
 #

Above, if we use ``Interval.length`` in an UPDATE expression as::

 #ession.query(Interval).update(
 #Interval.length: 25}, synchronize_session='fetch')

We'll get an UPDATE statement along the lines of::

 #PDATE interval SET end=start + :value

In some cases, the default "evaluate" strategy can't perform the SET
expression in Python; while the addition operator we're using above
is supported, for more complex SET expressions it will usually be necessary
to use either the "fetch" or False synchronization strategy as illustrated
above.

.. note:: For ORM bulk updates to work with hybrids, the function name
 #f the hybrid must match that of how it is accessed.    Something
 #ike this wouldn't work::

 #lass Interval(object):
            # ...

 #ef _get(self):
 #eturn self.end - self.start

 #ef _set(self, value):
 #elf.end = self.start + value

 #ef _update_expr(cls, value):
 #eturn [
 #cls.end, cls.start + value)
 #

 #ength = hybrid_property(
 #get=_get, fset=_set, update_expr=_update_expr
 #

 #he Python descriptor protocol does not provide any reliable way for
 # descriptor to know what attribute name it was accessed as, and
 #he UPDATE scheme currently relies upon being able to access the
 #ttribute from an instance by name in order to perform the instance
 #ynchronization step.

.. versionadded:: 1.2 added support for bulk updates to hybrid properties.

Working with Relationships
--------------------------

There's no essential difference when creating hybrids that work with
related objects as opposed to column-based data. The need for distinct
expressions tends to be greater.  The two variants we'll illustrate
are the "join-dependent" hybrid, and the "correlated subquery" hybrid.

Join-Dependent Relationship Hybrid
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Consider the following declarative
mapping which relates a ``User`` to a ``SavingsAccount``::

 #rom sqlalchemy import Column, Integer, ForeignKey, Numeric, String
 #rom sqlalchemy.orm import relationship
 #rom sqlalchemy.ext.declarative import declarative_base
 #rom sqlalchemy.ext.hybrid import hybrid_property

 #ase = declarative_base()

 #lass SavingsAccount(Base):
 #_tablename__ = 'account'
 #d = Column(Integer, primary_key=True)
 #ser_id = Column(Integer, ForeignKey('user.id'), nullable=False)
 #alance = Column(Numeric(15, 5))

 #lass User(Base):
 #_tablename__ = 'user'
 #d = Column(Integer, primary_key=True)
 #ame = Column(String(100), nullable=False)

 #ccounts = relationship("SavingsAccount", backref="owner")

 #hybrid_property
 #ef balance(self):
 #f self.accounts:
 #eturn self.accounts[0].balance
 #lse:
 #eturn None

 #balance.setter
 #ef balance(self, value):
 #f not self.accounts:
 #ccount = Account(owner=self)
 #lse:
 #ccount = self.accounts[0]
 #ccount.balance = value

 #balance.expression
 #ef balance(cls):
 #eturn SavingsAccount.balance

The above hybrid property ``balance`` works with the first
``SavingsAccount`` entry in the list of accounts for this user.   The
in-Python getter/setter methods can treat ``accounts`` as a Python
list available on ``self``.

However, at the expression level, it's expected that the ``User`` class will
be used in an appropriate context such that an appropriate join to
``SavingsAccount`` will be present::

 #>> print(Session().query(User, User.balance).
 #..       join(User.accounts).filter(User.balance > 5000))
 #ELECT "user".id AS user_id, "user".name AS user_name,
 #ccount.balance AS account_balance
 #ROM "user" JOIN account ON "user".id = account.user_id
 #HERE account.balance > :balance_1

Note however, that while the instance level accessors need to worry
about whether ``self.accounts`` is even present, this issue expresses
itself differently at the SQL expression level, where we basically
would use an outer join::

 #>> from sqlalchemy import or_
 #>> print (Session().query(User, User.balance).outerjoin(User.accounts).
 #..         filter(or_(User.balance < 5000, User.balance == None)))
 #ELECT "user".id AS user_id, "user".name AS user_name,
 #ccount.balance AS account_balance
 #ROM "user" LEFT OUTER JOIN account ON "user".id = account.user_id
 #HERE account.balance <  :balance_1 OR account.balance IS NULL

Correlated Subquery Relationship Hybrid
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We can, of course, forego being dependent on the enclosing query's usage
of joins in favor of the correlated subquery, which can portably be packed
into a single column expression. A correlated subquery is more portable, but
often performs more poorly at the SQL level. Using the same technique
illustrated at :ref:`mapper_column_property_sql_expressions`,
we can adjust our ``SavingsAccount`` example to aggregate the balances for
*all* accounts, and use a correlated subquery for the column expression::

 #rom sqlalchemy import Column, Integer, ForeignKey, Numeric, String
 #rom sqlalchemy.orm import relationship
 #rom sqlalchemy.ext.declarative import declarative_base
 #rom sqlalchemy.ext.hybrid import hybrid_property
 #rom sqlalchemy import select, func

 #ase = declarative_base()

 #lass SavingsAccount(Base):
 #_tablename__ = 'account'
 #d = Column(Integer, primary_key=True)
 #ser_id = Column(Integer, ForeignKey('user.id'), nullable=False)
 #alance = Column(Numeric(15, 5))

 #lass User(Base):
 #_tablename__ = 'user'
 #d = Column(Integer, primary_key=True)
 #ame = Column(String(100), nullable=False)

 #ccounts = relationship("SavingsAccount", backref="owner")

 #hybrid_property
 #ef balance(self):
 #eturn sum(acc.balance for acc in self.accounts)

 #balance.expression
 #ef balance(cls):
 #eturn select(func.sum(SavingsAccount.balance)).\
 #here(SavingsAccount.user_id==cls.id).\
 #abel('total_balance')

The above recipe will give us the ``balance`` column which renders
a correlated SELECT::

 #>> print(s.query(User).filter(User.balance > 400))
 #ELECT "user".id AS user_id, "user".name AS user_name
 #ROM "user"
 #HERE (SELECT sum(account.balance) AS sum_1
 #ROM account
 #HERE account.user_id = "user".id) > :param_1

.. _hybrid_custom_comparators:

Building Custom Comparators
---------------------------

The hybrid property also includes a helper that allows construction of
custom comparators. A comparator object allows one to customize the
behavior of each SQLAlchemy expression operator individually.  They
are useful when creating custom types that have some highly
idiosyncratic behavior on the SQL side.

.. note::  The :meth:`.hybrid_property.comparator` decorator introduced
 #n this section **replaces** the use of the
 #meth:`.hybrid_property.expression` decorator.
 #hey cannot be used together.

The example class below allows case-insensitive comparisons on the attribute
named ``word_insensitive``::

 #rom sqlalchemy.ext.hybrid import Comparator, hybrid_property
 #rom sqlalchemy import func, Column, Integer, String
 #rom sqlalchemy.orm import Session
 #rom sqlalchemy.ext.declarative import declarative_base

 #ase = declarative_base()

 #lass CaseInsensitiveComparator(Comparator):
 #ef __eq__(self, other):
 #eturn func.lower(self.__clause_element__()) == func.lower(other)

 #lass SearchWord(Base):
 #_tablename__ = 'searchword'
 #d = Column(Integer, primary_key=True)
 #ord = Column(String(255), nullable=False)

 #hybrid_property
 #ef word_insensitive(self):
 #eturn self.word.lower()

 #word_insensitive.comparator
 #ef word_insensitive(cls):
 #eturn CaseInsensitiveComparator(cls.word)

Above, SQL expressions against ``word_insensitive`` will apply the ``LOWER()``
SQL function to both sides::

 #>> print(Session().query(SearchWord).filter_by(word_insensitive="Trucks"))
 #ELECT searchword.id AS searchword_id, searchword.word AS searchword_word
 #ROM searchword
 #HERE lower(searchword.word) = lower(:lower_1)

The ``CaseInsensitiveComparator`` above implements part of the
:class:`.ColumnOperators` interface.   A "coercion" operation like
lowercasing can be applied to all comparison operations (i.e. ``eq``,
``lt``, ``gt``, etc.) using :meth:`.Operators.operate`::

 #lass CaseInsensitiveComparator(Comparator):
 #ef operate(self, op, other):
 #eturn op(func.lower(self.__clause_element__()), func.lower(other))

.. _hybrid_reuse_subclass:

Reusing Hybrid Properties across Subclasses
-------------------------------------------

A hybrid can be referred to from a superclass, to allow modifying
methods like :meth:`.hybrid_property.getter`, :meth:`.hybrid_property.setter`
to be used to redefine those methods on a subclass.  This is similar to
how the standard Python ``@property`` object works::

 #lass FirstNameOnly(Base):
        # ...

 #irst_name = Column(String)

 #hybrid_property
 #ef name(self):
 #eturn self.first_name

 #name.setter
 #ef name(self, value):
 #elf.first_name = value

 #lass FirstNameLastName(FirstNameOnly):
        # ...

 #ast_name = Column(String)

 #FirstNameOnly.name.getter
 #ef name(self):
 #eturn self.first_name + ' ' + self.last_name

 #name.setter
 #ef name(self, value):
 #elf.first_name, self.last_name = value.split(' ', 1)

Above, the ``FirstNameLastName`` class refers to the hybrid from
``FirstNameOnly.name`` to repurpose its getter and setter for the subclass.

When overriding :meth:`.hybrid_property.expression` and
:meth:`.hybrid_property.comparator` alone as the first reference to the
superclass, these names conflict with the same-named accessors on the class-
level :class:`.QueryableAttribute` object returned at the class level.  To
override these methods when referring directly to the parent class descriptor,
add the special qualifier :attr:`.hybrid_property.overrides`, which will de-
reference the instrumented attribute back to the hybrid object::

 #lass FirstNameLastName(FirstNameOnly):
        # ...

 #ast_name = Column(String)

 #FirstNameOnly.name.overrides.expression
 #ef name(cls):
 #eturn func.concat(cls.first_name, ' ', cls.last_name)

.. versionadded:: 1.2 Added :meth:`.hybrid_property.getter` as well as the
 #bility to redefine accessors per-subclass.


Hybrid Value Objects
--------------------

Note in our previous example, if we were to compare the ``word_insensitive``
attribute of a ``SearchWord`` instance to a plain Python string, the plain
Python string would not be coerced to lower case - the
``CaseInsensitiveComparator`` we built, being returned by
``@word_insensitive.comparator``, only applies to the SQL side.

A more comprehensive form of the custom comparator is to construct a *Hybrid
Value Object*. This technique applies the target value or expression to a value
object which is then returned by the accessor in all cases.   The value object
allows control of all operations upon the value as well as how compared values
are treated, both on the SQL expression side as well as the Python value side.
Replacing the previous ``CaseInsensitiveComparator`` class with a new
``CaseInsensitiveWord`` class::

 #lass CaseInsensitiveWord(Comparator):
 #Hybrid value representing a lower case representation of a word."

 #ef __init__(self, word):
 #f isinstance(word, basestring):
 #elf.word = word.lower()
 #lif isinstance(word, CaseInsensitiveWord):
 #elf.word = word.word
 #lse:
 #elf.word = func.lower(word)

 #ef operate(self, op, other):
 #f not isinstance(other, CaseInsensitiveWord):
 #ther = CaseInsensitiveWord(other)
 #eturn op(self.word, other.word)

 #ef __clause_element__(self):
 #eturn self.word

 #ef __str__(self):
 #eturn self.word

 #ey = 'word'
 #Label to apply to Query tuple results"

Above, the ``CaseInsensitiveWord`` object represents ``self.word``, which may
be a SQL function, or may be a Python native.   By overriding ``operate()`` and
``__clause_element__()`` to work in terms of ``self.word``, all comparison
operations will work against the "converted" form of ``word``, whether it be
SQL side or Python side. Our ``SearchWord`` class can now deliver the
``CaseInsensitiveWord`` object unconditionally from a single hybrid call::

 #lass SearchWord(Base):
 #_tablename__ = 'searchword'
 #d = Column(Integer, primary_key=True)
 #ord = Column(String(255), nullable=False)

 #hybrid_property
 #ef word_insensitive(self):
 #eturn CaseInsensitiveWord(self.word)

The ``word_insensitive`` attribute now has case-insensitive comparison behavior
universally, including SQL expression vs. Python expression (note the Python
value is converted to lower case on the Python side here)::

 #>> print(Session().query(SearchWord).filter_by(word_insensitive="Trucks"))
 #ELECT searchword.id AS searchword_id, searchword.word AS searchword_word
 #ROM searchword
 #HERE lower(searchword.word) = :lower_1

SQL expression versus SQL expression::

 #>> sw1 = aliased(SearchWord)
 #>> sw2 = aliased(SearchWord)
 #>> print(Session().query(
 #..                    sw1.word_insensitive,
 #..                    sw2.word_insensitive).\
 #..                        filter(
 #..                            sw1.word_insensitive > sw2.word_insensitive
 #..                        ))
 #ELECT lower(searchword_1.word) AS lower_1,
 #ower(searchword_2.word) AS lower_2
 #ROM searchword AS searchword_1, searchword AS searchword_2
 #HERE lower(searchword_1.word) > lower(searchword_2.word)

Python only expression::

 #>> ws1 = SearchWord(word="SomeWord")
 #>> ws1.word_insensitive == "sOmEwOrD"
 #rue
 #>> ws1.word_insensitive == "XOmEwOrX"
 #alse
 #>> print(ws1.word_insensitive)
 #omeword

The Hybrid Value pattern is very useful for any kind of value that may have
multiple representations, such as timestamps, time deltas, units of
measurement, currencies and encrypted passwords.

.. seealso::

 #Hybrids and Value Agnostic Types
 #https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/>`_
 # on the techspot.zzzeek.org blog

 #Value Agnostic Types, Part II
 #https://techspot.zzzeek.org/2011/10/29/value-agnostic-types-part-ii/>`_ -
 #n the techspot.zzzeek.org blog

.. _hybrid_transformers:

Building Transformers
----------------------

A *transformer* is an object which can receive a :class:`_query.Query`
object and
return a new one.   The :class:`_query.Query` object includes a method
:meth:`.with_transformation` that returns a new :class:`_query.Query`
transformed by
the given function.

We can combine this with the :class:`.Comparator` class to produce one type
of recipe which can both set up the FROM clause of a query as well as assign
filtering criterion.

Consider a mapped class ``Node``, which assembles using adjacency list into a
hierarchical tree pattern::

 #rom sqlalchemy import Column, Integer, ForeignKey
 #rom sqlalchemy.orm import relationship
 #rom sqlalchemy.ext.declarative import declarative_base
 #ase = declarative_base()

 #lass Node(Base):
 #_tablename__ = 'node'
 #d = Column(Integer, primary_key=True)
 #arent_id = Column(Integer, ForeignKey('node.id'))
 #arent = relationship("Node", remote_side=id)

Suppose we wanted to add an accessor ``grandparent``.  This would return the
``parent`` of ``Node.parent``.  When we have an instance of ``Node``, this is
simple::

 #rom sqlalchemy.ext.hybrid import hybrid_property

 #lass Node(Base):
        # ...

 #hybrid_property
 #ef grandparent(self):
 #eturn self.parent.parent

For the expression, things are not so clear.   We'd need to construct a
:class:`_query.Query` where we :meth:`_query.Query.join` twice along
``Node.parent`` to get to the ``grandparent``.   We can instead return a
transforming callable that we'll combine with the :class:`.Comparator` class to
receive any :class:`_query.Query` object, and return a new one that's joined to
the ``Node.parent`` attribute and filtered based on the given criterion::

 #rom sqlalchemy.ext.hybrid import Comparator

 #lass GrandparentTransformer(Comparator):
 #ef operate(self, op, other):
 #ef transform(q):
 #ls = self.__clause_element__()
 #arent_alias = aliased(cls)
 #eturn q.join(parent_alias, cls.parent).\
 #ilter(op(parent_alias.parent, other))
 #eturn transform

 #ase = declarative_base()

 #lass Node(Base):
 #_tablename__ = 'node'
 #d = Column(Integer, primary_key=True)
 #arent_id = Column(Integer, ForeignKey('node.id'))
 #arent = relationship("Node", remote_side=id)

 #hybrid_property
 #ef grandparent(self):
 #eturn self.parent.parent

 #grandparent.comparator
 #ef grandparent(cls):
 #eturn GrandparentTransformer(cls)

The ``GrandparentTransformer`` overrides the core :meth:`.Operators.operate`
method at the base of the :class:`.Comparator` hierarchy to return a query-
transforming callable, which then runs the given comparison operation in a
particular context. Such as, in the example above, the ``operate`` method is
called, given the :attr:`.Operators.eq` callable as well as the right side of
the comparison ``Node(id=5)``.  A function ``transform`` is then returned which
will transform a :class:`_query.Query` first to join to ``Node.parent``,
then to
compare ``parent_alias`` using :attr:`.Operators.eq` against the left and right
sides, passing into :meth:`_query.Query.filter`:

.. sourcecode:: pycon+sql

 #>> from sqlalchemy.orm import Session
 #>> session = Session()
 #sql}>>> session.query(Node).\
 #..        with_transformation(Node.grandparent==Node(id=5)).\
 #..        all()
 #ELECT node.id AS node_id, node.parent_id AS node_parent_id
 #ROM node JOIN node AS node_1 ON node_1.id = node.parent_id
 #HERE :param_1 = node_1.parent_id
 #stop}

We can modify the pattern to be more verbose but flexible by separating the
"join" step from the "filter" step.  The tricky part here is ensuring that
successive instances of ``GrandparentTransformer`` use the same
:class:`.AliasedClass` object against ``Node``.  Below we use a simple
memoizing approach that associates a ``GrandparentTransformer`` with each
class::

 #lass Node(Base):

        # ...

 #grandparent.comparator
 #ef grandparent(cls):
            # memoize a GrandparentTransformer
            # per class
 #f '_gp' not in cls.__dict__:
 #ls._gp = GrandparentTransformer(cls)
 #eturn cls._gp

 #lass GrandparentTransformer(Comparator):

 #ef __init__(self, cls):
 #elf.parent_alias = aliased(cls)

 #property
 #ef join(self):
 #ef go(q):
 #eturn q.join(self.parent_alias, Node.parent)
 #eturn go

 #ef operate(self, op, other):
 #eturn op(self.parent_alias.parent, other)

.. sourcecode:: pycon+sql

 #sql}>>> session.query(Node).\
 #..            with_transformation(Node.grandparent.join).\
 #..            filter(Node.grandparent==Node(id=5))
 #ELECT node.id AS node_id, node.parent_id AS node_parent_id
 #ROM node JOIN node AS node_1 ON node_1.id = node.parent_id
 #HERE :param_1 = node_1.parent_id
 #stop}

The "transformer" pattern is an experimental pattern that starts to make usage
of some functional programming paradigms. While it's only recommended for
advanced and/or patient developers, there's probably a whole lot of amazing
things it can be used for.

"""  # noqa
from .. import util
from ..orm import attributes
from ..orm import interfaces
from ..sql import elements

HYBRID_METHOD = util.symbol("HYBRID_METHOD")
"""Symbol indicating an :class:`InspectionAttr` that's
 #f type :class:`.hybrid_method`.

 #s assigned to the :attr:`.InspectionAttr.extension_type`
 #ttribute.

 #. seealso::

 #attr:`_orm.Mapper.all_orm_attributes`

"""

HYBRID_PROPERTY = util.symbol("HYBRID_PROPERTY")
"""Symbol indicating an :class:`InspectionAttr` that's
 #f type :class:`.hybrid_method`.

 #s assigned to the :attr:`.InspectionAttr.extension_type`
 #ttribute.

 #. seealso::

 #attr:`_orm.Mapper.all_orm_attributes`

"""


class hybrid_method(interfaces.InspectionAttrInfo):
 #""A decorator which allows definition of a Python object method with both
 #nstance-level and class-level behavior.

 #""

 #s_attribute = True
 #xtension_type = HYBRID_METHOD

 #ef __init__(self, func, expr=None):
 #""Create a new :class:`.hybrid_method`.

 #sage is typically via decorator::

 #rom sqlalchemy.ext.hybrid import hybrid_method

 #lass SomeClass(object):
 #hybrid_method
 #ef value(self, x, y):
 #eturn self._value + x + y

 #value.expression
 #ef value(self, x, y):
 #eturn func.some_function(self._value, x, y)

 #""
 #elf.func = func
 #elf.expression(expr or func)

 #ef __get__(self, instance, owner):
 #f instance is None:
 #eturn self.expr.__get__(owner, owner.__class__)
 #lse:
 #eturn self.func.__get__(instance, owner)

 #ef expression(self, expr):
 #""Provide a modifying decorator that defines a
 #QL-expression producing method."""

 #elf.expr = expr
 #f not self.expr.__doc__:
 #elf.expr.__doc__ = self.func.__doc__
 #eturn self


class hybrid_property(interfaces.InspectionAttrInfo):
 #""A decorator which allows definition of a Python descriptor with both
 #nstance-level and class-level behavior.

 #""

 #s_attribute = True
 #xtension_type = HYBRID_PROPERTY

 #ef __init__(
 #elf,
 #get,
 #set=None,
 #del=None,
 #xpr=None,
 #ustom_comparator=None,
 #pdate_expr=None,
 #:
 #""Create a new :class:`.hybrid_property`.

 #sage is typically via decorator::

 #rom sqlalchemy.ext.hybrid import hybrid_property

 #lass SomeClass(object):
 #hybrid_property
 #ef value(self):
 #eturn self._value

 #value.setter
 #ef value(self, value):
 #elf._value = value

 #""
 #elf.fget = fget
 #elf.fset = fset
 #elf.fdel = fdel
 #elf.expr = expr
 #elf.custom_comparator = custom_comparator
 #elf.update_expr = update_expr
 #til.update_wrapper(self, fget)

 #ef __get__(self, instance, owner):
 #f instance is None:
 #eturn self._expr_comparator(owner)
 #lse:
 #eturn self.fget(instance)

 #ef __set__(self, instance, value):
 #f self.fset is None:
 #aise AttributeError("can't set attribute")
 #elf.fset(instance, value)

 #ef __delete__(self, instance):
 #f self.fdel is None:
 #aise AttributeError("can't delete attribute")
 #elf.fdel(instance)

 #ef _copy(self, **kw):
 #efaults = {
 #ey: value
 #or key, value in self.__dict__.items()
 #f not key.startswith("_")
 #
 #efaults.update(**kw)
 #eturn type(self)(**defaults)

 #property
 #ef overrides(self):
 #""Prefix for a method that is overriding an existing attribute.

 #he :attr:`.hybrid_property.overrides` accessor just returns
 #his hybrid object, which when called at the class level from
 # parent class, will de-reference the "instrumented attribute"
 #ormally returned at this level, and allow modifying decorators
 #ike :meth:`.hybrid_property.expression` and
 #meth:`.hybrid_property.comparator`
 #o be used without conflicting with the same-named attributes
 #ormally present on the :class:`.QueryableAttribute`::

 #lass SuperClass(object):
                # ...

 #hybrid_property
 #ef foobar(self):
 #eturn self._foobar

 #lass SubClass(SuperClass):
                # ...

 #SuperClass.foobar.overrides.expression
 #ef foobar(cls):
 #eturn func.subfoobar(self._foobar)

 #. versionadded:: 1.2

 #. seealso::

 #ref:`hybrid_reuse_subclass`

 #""
 #eturn self

 #ef getter(self, fget):
 #""Provide a modifying decorator that defines a getter method.

 #. versionadded:: 1.2

 #""

 #eturn self._copy(fget=fget)

 #ef setter(self, fset):
 #""Provide a modifying decorator that defines a setter method."""

 #eturn self._copy(fset=fset)

 #ef deleter(self, fdel):
 #""Provide a modifying decorator that defines a deletion method."""

 #eturn self._copy(fdel=fdel)

 #ef expression(self, expr):
 #""Provide a modifying decorator that defines a SQL-expression
 #roducing method.

 #hen a hybrid is invoked at the class level, the SQL expression given
 #ere is wrapped inside of a specialized :class:`.QueryableAttribute`,
 #hich is the same kind of object used by the ORM to represent other
 #apped attributes.   The reason for this is so that other class-level
 #ttributes such as docstrings and a reference to the hybrid itself may
 #e maintained within the structure that's returned, without any
 #odifications to the original SQL expression passed in.

 #. note::

 #hen referring to a hybrid property  from an owning class (e.g.
 #`SomeClass.some_hybrid``), an instance of
 #class:`.QueryableAttribute` is returned, representing the
 #xpression or comparator object as well as this  hybrid object.
 #owever, that object itself has accessors called ``expression`` and
 #`comparator``; so when attempting to override these decorators on a
 #ubclass, it may be necessary to qualify it using the
 #attr:`.hybrid_property.overrides` modifier first.  See that
 #odifier for details.

 #. seealso::

 #ref:`hybrid_distinct_expression`

 #""

 #eturn self._copy(expr=expr)

 #ef comparator(self, comparator):
 #""Provide a modifying decorator that defines a custom
 #omparator producing method.

 #he return value of the decorated method should be an instance of
 #class:`~.hybrid.Comparator`.

 #. note::  The :meth:`.hybrid_property.comparator` decorator
 #*replaces** the use of the :meth:`.hybrid_property.expression`
 #ecorator.  They cannot be used together.

 #hen a hybrid is invoked at the class level, the
 #class:`~.hybrid.Comparator` object given here is wrapped inside of a
 #pecialized :class:`.QueryableAttribute`, which is the same kind of
 #bject used by the ORM to represent other mapped attributes.   The
 #eason for this is so that other class-level attributes such as
 #ocstrings and a reference to the hybrid itself may be maintained
 #ithin the structure that's returned, without any modifications to the
 #riginal comparator object passed in.

 #. note::

 #hen referring to a hybrid property  from an owning class (e.g.
 #`SomeClass.some_hybrid``), an instance of
 #class:`.QueryableAttribute` is returned, representing the
 #xpression or comparator object as this  hybrid object.  However,
 #hat object itself has accessors called ``expression`` and
 #`comparator``; so when attempting to override these decorators on a
 #ubclass, it may be necessary to qualify it using the
 #attr:`.hybrid_property.overrides` modifier first.  See that
 #odifier for details.

 #""
 #eturn self._copy(custom_comparator=comparator)

 #ef update_expression(self, meth):
 #""Provide a modifying decorator that defines an UPDATE tuple
 #roducing method.

 #he method accepts a single value, which is the value to be
 #endered into the SET clause of an UPDATE statement.  The method
 #hould then process this value into individual column expressions
 #hat fit into the ultimate SET clause, and return them as a
 #equence of 2-tuples.  Each tuple
 #ontains a column expression as the key and a value to be rendered.

 #.g.::

 #lass Person(Base):
                # ...

 #irst_name = Column(String)
 #ast_name = Column(String)

 #hybrid_property
 #ef fullname(self):
 #eturn first_name + " " + last_name

 #fullname.update_expression
 #ef fullname(cls, value):
 #name, lname = value.split(" ", 1)
 #eturn [
 #cls.first_name, fname),
 #cls.last_name, lname)
 #

 #. versionadded:: 1.2

 #""
 #eturn self._copy(update_expr=meth)

 #util.memoized_property
 #ef _expr_comparator(self):
 #f self.custom_comparator is not None:
 #eturn self._get_comparator(self.custom_comparator)
 #lif self.expr is not None:
 #eturn self._get_expr(self.expr)
 #lse:
 #eturn self._get_expr(self.fget)

 #ef _get_expr(self, expr):
 #ef _expr(cls):
 #eturn ExprComparator(cls, expr(cls), self)

 #til.update_wrapper(_expr, expr)

 #eturn self._get_comparator(_expr)

 #ef _get_comparator(self, comparator):

 #roxy_attr = attributes.create_proxied_attribute(self)

 #ef expr_comparator(owner):
            # because this is the descriptor protocol, we don't really know
            # what our attribute name is.  so search for it through the
            # MRO.
 #or lookup in owner.__mro__:
 #f self.__name__ in lookup.__dict__:
 #f lookup.__dict__[self.__name__] is self:
 #ame = self.__name__
 #reak
 #lse:
 #ame = attributes.NO_KEY

 #eturn proxy_attr(
 #wner,
 #ame,
 #elf,
 #omparator(owner),
 #oc=comparator.__doc__ or self.__doc__,
 #

 #eturn expr_comparator


class Comparator(interfaces.PropComparator):
 #""A helper class that allows easy construction of custom
 #class:`~.orm.interfaces.PropComparator`
 #lasses for usage with hybrids."""

 #roperty = None

 #ef __init__(self, expression):
 #elf.expression = expression

 #ef __clause_element__(self):
 #xpr = self.expression
 #f hasattr(expr, "__clause_element__"):
 #xpr = expr.__clause_element__()
 #eturn expr

 #ef adapt_to_entity(self, adapt_to_entity):
        # interesting....
 #eturn self


class ExprComparator(Comparator):
 #ef __init__(self, cls, expression, hybrid):
 #elf.cls = cls
 #elf.expression = expression
 #elf.hybrid = hybrid

 #ef __getattr__(self, key):
 #eturn getattr(self.expression, key)

 #property
 #ef info(self):
 #eturn self.hybrid.info

 #ef _bulk_update_tuples(self, value):
 #f isinstance(value, elements.BindParameter):
 #alue = value.value

 #f isinstance(self.expression, attributes.QueryableAttribute):
 #eturn self.expression._bulk_update_tuples(value)
 #lif self.hybrid.update_expr is not None:
 #eturn self.hybrid.update_expr(self.cls, value)
 #lse:
 #eturn [(self.expression, value)]

 #property
 #ef property(self):
 #eturn self.expression.property

 #ef operate(self, op, *other, **kwargs):
 #eturn op(self.expression, *other, **kwargs)

 #ef reverse_operate(self, op, other, **kwargs):
 #eturn op(other, self.expression, **kwargs)
