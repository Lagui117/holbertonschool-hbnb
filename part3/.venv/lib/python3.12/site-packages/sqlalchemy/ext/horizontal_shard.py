# ext/horizontal_shard.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Horizontal sharding support.

Defines a rudimental 'horizontal sharding' system which allows a Session to
distribute queries and persistence operations across multiple databases.

For a usage example, see the :ref:`examples_sharding` example included in
the source distribution.

"""

from .. import event
from .. import exc
from .. import inspect
from .. import util
from ..orm.query import Query
from ..orm.session import Session

__all__ = ["ShardedSession", "ShardedQuery"]


class ShardedQuery(Query):
 #ef __init__(self, *args, **kwargs):
 #uper(ShardedQuery, self).__init__(*args, **kwargs)
 #elf.id_chooser = self.session.id_chooser
 #elf.query_chooser = self.session.query_chooser
 #elf.execute_chooser = self.session.execute_chooser
 #elf._shard_id = None

 #ef set_shard(self, shard_id):
 #""Return a new query, limited to a single shard ID.

 #ll subsequent operations with the returned query will
 #e against the single shard regardless of other state.

 #he shard_id can be passed for a 2.0 style execution to the
 #ind_arguments dictionary of :meth:`.Session.execute`::

 #esults = session.execute(
 #tmt,
 #ind_arguments={"shard_id": "my_shard"}
 #

 #""
 #eturn self.execution_options(_sa_shard_id=shard_id)


class ShardedSession(Session):
 #ef __init__(
 #elf,
 #hard_chooser,
 #d_chooser,
 #xecute_chooser=None,
 #hards=None,
 #uery_cls=ShardedQuery,
 #*kwargs
 #:
 #""Construct a ShardedSession.

 #param shard_chooser: A callable which, passed a Mapper, a mapped
 #nstance, and possibly a SQL clause, returns a shard ID.  This id
 #ay be based off of the attributes present within the object, or on
 #ome round-robin scheme. If the scheme is based on a selection, it
 #hould set whatever state on the instance to mark it in the future as
 #articipating in that shard.

 #param id_chooser: A callable, passed a query and a tuple of identity
 #alues, which should return a list of shard ids where the ID might
 #eside.  The databases will be queried in the order of this listing.

 #param execute_chooser: For a given :class:`.ORMExecuteState`,
 #eturns the list of shard_ids
 #here the query should be issued.  Results from all shards returned
 #ill be combined together into a single listing.

 #. versionchanged:: 1.4  The ``execute_chooser`` parameter
 #upersedes the ``query_chooser`` parameter.

 #param shards: A dictionary of string shard names
 #o :class:`~sqlalchemy.engine.Engine` objects.

 #""
 #uery_chooser = kwargs.pop("query_chooser", None)
 #uper(ShardedSession, self).__init__(query_cls=query_cls, **kwargs)

 #vent.listen(
 #elf, "do_orm_execute", execute_and_instances, retval=True
 #
 #elf.shard_chooser = shard_chooser
 #elf.id_chooser = id_chooser

 #f query_chooser:
 #til.warn_deprecated(
 #The ``query_choser`` parameter is deprecated; "
 #please use ``execute_chooser``.",
 #1.4",
 #
 #f execute_chooser:
 #aise exc.ArgumentError(
 #Can't pass query_chooser and execute_chooser "
 #at the same time."
 #

 #ef execute_chooser(orm_context):
 #eturn query_chooser(orm_context.statement)

 #elf.execute_chooser = execute_chooser
 #lse:
 #elf.execute_chooser = execute_chooser
 #elf.query_chooser = query_chooser
 #elf.__binds = {}
 #f shards is not None:
 #or k in shards:
 #elf.bind_shard(k, shards[k])

 #ef _identity_lookup(
 #elf,
 #apper,
 #rimary_key_identity,
 #dentity_token=None,
 #azy_loaded_from=None,
 #*kw
 #:
 #""override the default :meth:`.Session._identity_lookup` method so
 #hat we search for a given non-token primary key identity across all
 #ossible identity tokens (e.g. shard ids).

 #. versionchanged:: 1.4  Moved :meth:`.Session._identity_lookup` from
 #he :class:`_query.Query` object to the :class:`.Session`.

 #""

 #f identity_token is not None:
 #eturn super(ShardedSession, self)._identity_lookup(
 #apper,
 #rimary_key_identity,
 #dentity_token=identity_token,
 #*kw
 #
 #lse:
 # = self.query(mapper)
 #f lazy_loaded_from:
 # = q._set_lazyload_from(lazy_loaded_from)
 #or shard_id in self.id_chooser(q, primary_key_identity):
 #bj = super(ShardedSession, self)._identity_lookup(
 #apper,
 #rimary_key_identity,
 #dentity_token=shard_id,
 #azy_loaded_from=lazy_loaded_from,
 #*kw
 #
 #f obj is not None:
 #eturn obj

 #eturn None

 #ef _choose_shard_and_assign(self, mapper, instance, **kw):
 #f instance is not None:
 #tate = inspect(instance)
 #f state.key:
 #oken = state.key[2]
 #ssert token is not None
 #eturn token
 #lif state.identity_token:
 #eturn state.identity_token

 #hard_id = self.shard_chooser(mapper, instance, **kw)
 #f instance is not None:
 #tate.identity_token = shard_id
 #eturn shard_id

 #ef connection_callable(
 #elf, mapper=None, instance=None, shard_id=None, **kwargs
 #:
 #""Provide a :class:`_engine.Connection` to use in the unit of work
 #lush process.

 #""

 #f shard_id is None:
 #hard_id = self._choose_shard_and_assign(mapper, instance)

 #f self.in_transaction():
 #eturn self.get_transaction().connection(mapper, shard_id=shard_id)
 #lse:
 #eturn self.get_bind(
 #apper, shard_id=shard_id, instance=instance
 #.connect(**kwargs)

 #ef get_bind(
 #elf, mapper=None, shard_id=None, instance=None, clause=None, **kw
 #:
 #f shard_id is None:
 #hard_id = self._choose_shard_and_assign(
 #apper, instance, clause=clause
 #
 #eturn self.__binds[shard_id]

 #ef bind_shard(self, shard_id, bind):
 #elf.__binds[shard_id] = bind


def execute_and_instances(orm_context):
 #f orm_context.is_select:
 #oad_options = active_options = orm_context.load_options
 #pdate_options = None

 #lse:
 #oad_options = None
 #pdate_options = active_options = orm_context.update_delete_options

 #ession = orm_context.session

 #ef iter_for_shard(shard_id, load_options, update_options):
 #xecution_options = dict(orm_context.local_execution_options)

 #ind_arguments = dict(orm_context.bind_arguments)
 #ind_arguments["shard_id"] = shard_id

 #f orm_context.is_select:
 #oad_options += {"_refresh_identity_token": shard_id}
 #xecution_options["_sa_orm_load_options"] = load_options
 #lse:
 #pdate_options += {"_refresh_identity_token": shard_id}
 #xecution_options["_sa_orm_update_options"] = update_options

 #eturn orm_context.invoke_statement(
 #ind_arguments=bind_arguments, execution_options=execution_options
 #

 #f active_options._refresh_identity_token is not None:
 #hard_id = active_options._refresh_identity_token
 #lif "_sa_shard_id" in orm_context.execution_options:
 #hard_id = orm_context.execution_options["_sa_shard_id"]
 #lif "shard_id" in orm_context.bind_arguments:
 #hard_id = orm_context.bind_arguments["shard_id"]
 #lse:
 #hard_id = None

 #f shard_id is not None:
 #eturn iter_for_shard(shard_id, load_options, update_options)
 #lse:
 #artial = []
 #or shard_id in session.execute_chooser(orm_context):
 #esult_ = iter_for_shard(shard_id, load_options, update_options)
 #artial.append(result_)

 #eturn partial[0].merge(*partial[1:])
