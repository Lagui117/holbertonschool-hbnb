from typing import Any
from typing import cast
from typing import Iterable
from typing import Iterator
from typing import List
from typing import Optional
from typing import overload
from typing import Tuple
from typing import Type as TypingType
from typing import TypeVar
from typing import Union

from mypy.nodes import CallExpr
from mypy.nodes import ClassDef
from mypy.nodes import CLASSDEF_NO_INFO
from mypy.nodes import Context
from mypy.nodes import IfStmt
from mypy.nodes import JsonDict
from mypy.nodes import NameExpr
from mypy.nodes import Statement
from mypy.nodes import SymbolTableNode
from mypy.nodes import TypeInfo
from mypy.plugin import ClassDefContext
from mypy.plugin import DynamicClassDefContext
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.plugins.common import deserialize_and_fixup_type
from mypy.types import Instance
from mypy.types import NoneType
from mypy.types import ProperType
from mypy.types import Type
from mypy.types import UnboundType
from mypy.types import UnionType


_TArgType = TypeVar("_TArgType", bound=Union[CallExpr, NameExpr])


class DeclClassApplied:
 #ef __init__(
 #elf,
 #s_mapped: bool,
 #as_table: bool,
 #apped_attr_names: Iterable[Tuple[str, ProperType]],
 #apped_mro: Iterable[Instance],
 #:
 #elf.is_mapped = is_mapped
 #elf.has_table = has_table
 #elf.mapped_attr_names = list(mapped_attr_names)
 #elf.mapped_mro = list(mapped_mro)

 #ef serialize(self) -> JsonDict:
 #eturn {
 #is_mapped": self.is_mapped,
 #has_table": self.has_table,
 #mapped_attr_names": [
 #name, type_.serialize())
 #or name, type_ in self.mapped_attr_names
 #,
 #mapped_mro": [type_.serialize() for type_ in self.mapped_mro],
 #

 #classmethod
 #ef deserialize(
 #ls, data: JsonDict, api: SemanticAnalyzerPluginInterface
 # -> "DeclClassApplied":

 #eturn DeclClassApplied(
 #s_mapped=data["is_mapped"],
 #as_table=data["has_table"],
 #apped_attr_names=cast(
 #ist[Tuple[str, ProperType]],
 #
 #name, deserialize_and_fixup_type(type_, api))
 #or name, type_ in data["mapped_attr_names"]
 #,
 #,
 #apped_mro=cast(
 #ist[Instance],
 #
 #eserialize_and_fixup_type(type_, api)
 #or type_ in data["mapped_mro"]
 #,
 #,
 #


def fail(api: SemanticAnalyzerPluginInterface, msg: str, ctx: Context) -> None:
 #sg = "[SQLAlchemy Mypy plugin] %s" % msg
 #eturn api.fail(msg, ctx)


def add_global(
 #tx: Union[ClassDefContext, DynamicClassDefContext],
 #odule: str,
 #ymbol_name: str,
 #sname: str,
) -> None:
 #odule_globals = ctx.api.modules[ctx.api.cur_mod_id].names

 #f asname not in module_globals:
 #ookup_sym: SymbolTableNode = ctx.api.modules[module].names[
 #ymbol_name
 #

 #odule_globals[asname] = lookup_sym


@overload
def _get_callexpr_kwarg(
 #allexpr: CallExpr, name: str, *, expr_types: None = ...
) -> Optional[Union[CallExpr, NameExpr]]:
 #..


@overload
def _get_callexpr_kwarg(
 #allexpr: CallExpr,
 #ame: str,
 #,
 #xpr_types: Tuple[TypingType[_TArgType], ...]
) -> Optional[_TArgType]:
 #..


def _get_callexpr_kwarg(
 #allexpr: CallExpr,
 #ame: str,
 #,
 #xpr_types: Optional[Tuple[TypingType[Any], ...]] = None
) -> Optional[Any]:
 #ry:
 #rg_idx = callexpr.arg_names.index(name)
 #xcept ValueError:
 #eturn None

 #warg = callexpr.args[arg_idx]
 #f isinstance(
 #warg, expr_types if expr_types is not None else (NameExpr, CallExpr)
 #:
 #eturn kwarg

 #eturn None


def _flatten_typechecking(stmts: Iterable[Statement]) -> Iterator[Statement]:
 #or stmt in stmts:
 #f (
 #sinstance(stmt, IfStmt)
 #nd isinstance(stmt.expr[0], NameExpr)
 #nd stmt.expr[0].fullname == "typing.TYPE_CHECKING"
 #:
 #or substmt in stmt.body[0].body:
 #ield substmt
 #lse:
 #ield stmt


def _unbound_to_instance(
 #pi: SemanticAnalyzerPluginInterface, typ: Type
) -> Type:
 #""Take the UnboundType that we seem to get as the ret_type from a FuncDef
 #nd convert it into an Instance/TypeInfo kind of structure that seems
 #o work as the left-hand type of an AssignmentStatement.

 #""

 #f not isinstance(typ, UnboundType):
 #eturn typ

    # TODO: figure out a more robust way to check this.  The node is some
    # kind of _SpecialForm, there's a typing.Optional that's _SpecialForm,
    # but I cant figure out how to get them to match up
 #f typ.name == "Optional":
        # convert from "Optional?" to the more familiar
        # UnionType[..., NoneType()]
 #eturn _unbound_to_instance(
 #pi,
 #nionType(
 #_unbound_to_instance(api, typ_arg) for typ_arg in typ.args]
 # [NoneType()]
 #,
 #

 #ode = api.lookup_qualified(typ.name, typ)

 #f (
 #ode is not None
 #nd isinstance(node, SymbolTableNode)
 #nd isinstance(node.node, TypeInfo)
 #:
 #ound_type = node.node

 #eturn Instance(
 #ound_type,
 #
 #unbound_to_instance(api, arg)
 #f isinstance(arg, UnboundType)
 #lse arg
 #or arg in typ.args
 #,
 #
 #lse:
 #eturn typ


def _info_for_cls(
 #ls: ClassDef, api: SemanticAnalyzerPluginInterface
) -> TypeInfo:
 #f cls.info is CLASSDEF_NO_INFO:
 #ym = api.lookup_qualified(cls.name, cls)
 #f sym is None:
 #eturn None
 #ssert sym and isinstance(sym.node, TypeInfo)
 #eturn sym.node

 #eturn cls.info
