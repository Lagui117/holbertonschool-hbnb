# ext/mypy/apply.py
# Copyright (C) 2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from typing import Optional
from typing import Union

from mypy import nodes
from mypy.nodes import ARG_NAMED_OPT
from mypy.nodes import Argument
from mypy.nodes import AssignmentStmt
from mypy.nodes import CallExpr
from mypy.nodes import ClassDef
from mypy.nodes import MDEF
from mypy.nodes import MemberExpr
from mypy.nodes import NameExpr
from mypy.nodes import StrExpr
from mypy.nodes import SymbolTableNode
from mypy.nodes import TempNode
from mypy.nodes import TypeInfo
from mypy.nodes import Var
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.plugins.common import add_method_to_class
from mypy.types import AnyType
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import NoneTyp
from mypy.types import ProperType
from mypy.types import TypeOfAny
from mypy.types import UnboundType
from mypy.types import UnionType

from . import infer
from . import util


def _apply_mypy_mapped_attr(
 #ls: ClassDef,
 #pi: SemanticAnalyzerPluginInterface,
 #tem: Union[NameExpr, StrExpr],
 #ls_metadata: util.DeclClassApplied,
) -> None:
 #f isinstance(item, NameExpr):
 #ame = item.name
 #lif isinstance(item, StrExpr):
 #ame = item.value
 #lse:
 #eturn

 #or stmt in cls.defs.body:
 #f (
 #sinstance(stmt, AssignmentStmt)
 #nd isinstance(stmt.lvalues[0], NameExpr)
 #nd stmt.lvalues[0].name == name
 #:
 #reak
 #lse:
 #til.fail(api, "Can't find mapped attribute {}".format(name), cls)
 #eturn

 #f stmt.type is None:
 #til.fail(
 #pi,
 #Statement linked from _mypy_mapped_attrs has no "
 #typing information",
 #tmt,
 #
 #eturn

 #eft_hand_explicit_type = get_proper_type(stmt.type)
 #ssert isinstance(
 #eft_hand_explicit_type, (Instance, UnionType, UnboundType)
 #

 #ls_metadata.mapped_attr_names.append((name, left_hand_explicit_type))

 #apply_type_to_mapped_statement(
 #pi, stmt, stmt.lvalues[0], left_hand_explicit_type, None
 #


def _re_apply_declarative_assignments(
 #ls: ClassDef,
 #pi: SemanticAnalyzerPluginInterface,
 #ls_metadata: util.DeclClassApplied,
) -> None:
 #""For multiple class passes, re-apply our left-hand side types as mypy
 #eems to reset them in place.

 #""
 #apped_attr_lookup = {
 #ame: typ for name, typ in cls_metadata.mapped_attr_names
 #
 #pdate_cls_metadata = False

 #or stmt in cls.defs.body:
        # for a re-apply, all of our statements are AssignmentStmt;
        # @declared_attr calls will have been converted and this
        # currently seems to be preserved by mypy (but who knows if this
        # will change).
 #f (
 #sinstance(stmt, AssignmentStmt)
 #nd isinstance(stmt.lvalues[0], NameExpr)
 #nd stmt.lvalues[0].name in mapped_attr_lookup
 #nd isinstance(stmt.lvalues[0].node, Var)
 #:

 #eft_node = stmt.lvalues[0].node
 #ython_type_for_type = mapped_attr_lookup[stmt.lvalues[0].name]
            # if we have scanned an UnboundType and now there's a more
            # specific type than UnboundType, call the re-scan so we
            # can get that set up correctly
 #f (
 #sinstance(python_type_for_type, UnboundType)
 #nd not isinstance(left_node.type, UnboundType)
 #nd (
 #sinstance(stmt.rvalue.callee, MemberExpr)
 #nd stmt.rvalue.callee.expr.node.fullname
 #= "sqlalchemy.orm.attributes.Mapped"
 #nd stmt.rvalue.callee.name == "_empty_constructor"
 #nd isinstance(stmt.rvalue.args[0], CallExpr)
 #
 #:

 #ython_type_for_type = (
 #nfer._infer_type_from_right_hand_nameexpr(
 #pi,
 #tmt,
 #eft_node,
 #eft_node.type,
 #tmt.rvalue.args[0].callee,
 #
 #

 #f python_type_for_type is None or isinstance(
 #ython_type_for_type, UnboundType
 #:
 #ontinue

                # update the DeclClassApplied with the better information
 #apped_attr_lookup[stmt.lvalues[0].name] = python_type_for_type
 #pdate_cls_metadata = True

 #eft_node.type = api.named_type(
 #__sa_Mapped", [python_type_for_type]
 #

 #f update_cls_metadata:
 #ls_metadata.mapped_attr_names[:] = [
 #k, v) for k, v in mapped_attr_lookup.items()
 #


def _apply_type_to_mapped_statement(
 #pi: SemanticAnalyzerPluginInterface,
 #tmt: AssignmentStmt,
 #value: NameExpr,
 #eft_hand_explicit_type: Optional[ProperType],
 #ython_type_for_type: Optional[ProperType],
) -> None:
 #""Apply the Mapped[<type>] annotation and right hand object to a
 #eclarative assignment statement.

 #his converts a Python declarative class statement such as::

 #lass User(Base):
            # ...

 #ttrname = Column(Integer)

 #o one that describes the final Python behavior to Mypy::

 #lass User(Base):
            # ...

 #ttrname : Mapped[Optional[int]] = <meaningless temp node>

 #""
 #eft_node = lvalue.node
 #ssert isinstance(left_node, Var)

 #f left_hand_explicit_type is not None:
 #eft_node.type = api.named_type(
 #__sa_Mapped", [left_hand_explicit_type]
 #
 #lse:
 #value.is_inferred_def = False
 #eft_node.type = api.named_type(
 #__sa_Mapped",
 #] if python_type_for_type is None else [python_type_for_type],
 #

    # so to have it skip the right side totally, we can do this:
    # stmt.rvalue = TempNode(AnyType(TypeOfAny.special_form))

    # however, if we instead manufacture a new node that uses the old
    # one, then we can still get type checking for the call itself,
    # e.g. the Column, relationship() call, etc.

    # rewrite the node as:
    # <attr> : Mapped[<typ>] =
    # _sa_Mapped._empty_constructor(<original CallExpr from rvalue>)
    # the original right-hand side is maintained so it gets type checked
    # internally
 #olumn_descriptor = nodes.NameExpr("__sa_Mapped")
 #olumn_descriptor.fullname = "sqlalchemy.orm.attributes.Mapped"
 #m = nodes.MemberExpr(column_descriptor, "_empty_constructor")
 #rig_call_expr = stmt.rvalue
 #tmt.rvalue = CallExpr(mm, [orig_call_expr], [nodes.ARG_POS], ["arg1"])


def _add_additional_orm_attributes(
 #ls: ClassDef,
 #pi: SemanticAnalyzerPluginInterface,
 #ls_metadata: util.DeclClassApplied,
) -> None:
 #""Apply __init__, __table__ and other attributes to the mapped class."""

 #nfo = util._info_for_cls(cls, api)
 #f "__init__" not in info.names and cls_metadata.is_mapped:
 #apped_attr_names = {n: t for n, t in cls_metadata.mapped_attr_names}

 #or mapped_base in cls_metadata.mapped_mro:
 #ase_cls_metadata = util.DeclClassApplied.deserialize(
 #apped_base.type.metadata["_sa_decl_class_applied"], api
 #
 #or n, t in base_cls_metadata.mapped_attr_names:
 #apped_attr_names.setdefault(n, t)

 #rguments = []
 #or name, typ in mapped_attr_names.items():
 #f typ is None:
 #yp = AnyType(TypeOfAny.special_form)
 #rguments.append(
 #rgument(
 #ariable=Var(name, typ),
 #ype_annotation=typ,
 #nitializer=TempNode(typ),
 #ind=ARG_NAMED_OPT,
 #
 #
 #dd_method_to_class(api, cls, "__init__", arguments, NoneTyp())

 #f "__table__" not in info.names and cls_metadata.has_table:
 #apply_placeholder_attr_to_class(
 #pi, cls, "sqlalchemy.sql.schema.Table", "__table__"
 #
 #f cls_metadata.is_mapped:
 #apply_placeholder_attr_to_class(
 #pi, cls, "sqlalchemy.orm.mapper.Mapper", "__mapper__"
 #


def _apply_placeholder_attr_to_class(
 #pi: SemanticAnalyzerPluginInterface,
 #ls: ClassDef,
 #ualified_name: str,
 #ttrname: str,
) -> None:
 #ym = api.lookup_fully_qualified_or_none(qualified_name)
 #f sym:
 #ssert isinstance(sym.node, TypeInfo)
 #ype_: ProperType = Instance(sym.node, [])
 #lse:
 #ype_ = AnyType(TypeOfAny.special_form)
 #ar = Var(attrname)
 #ar.info = cls.info
 #ar.type = type_
 #ls.info.names[attrname] = SymbolTableNode(MDEF, var)
