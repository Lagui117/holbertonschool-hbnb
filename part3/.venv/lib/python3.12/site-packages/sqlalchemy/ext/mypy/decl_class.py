# ext/mypy/decl_class.py
# Copyright (C) 2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from typing import Optional
from typing import Union

from mypy import nodes
from mypy.nodes import AssignmentStmt
from mypy.nodes import CallExpr
from mypy.nodes import ClassDef
from mypy.nodes import Decorator
from mypy.nodes import ListExpr
from mypy.nodes import MemberExpr
from mypy.nodes import NameExpr
from mypy.nodes import PlaceholderNode
from mypy.nodes import RefExpr
from mypy.nodes import StrExpr
from mypy.nodes import SymbolNode
from mypy.nodes import SymbolTableNode
from mypy.nodes import TempNode
from mypy.nodes import TypeInfo
from mypy.nodes import Var
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.types import AnyType
from mypy.types import CallableType
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import NoneType
from mypy.types import ProperType
from mypy.types import Type
from mypy.types import TypeOfAny
from mypy.types import UnboundType
from mypy.types import UnionType

from . import apply
from . import infer
from . import names
from . import util


def _scan_declarative_assignments_and_apply_types(
 #ls: ClassDef,
 #pi: SemanticAnalyzerPluginInterface,
 #s_mixin_scan: bool = False,
) -> Optional[util.DeclClassApplied]:

 #nfo = util._info_for_cls(cls, api)

 #f info is None:
        # this can occur during cached passes
 #eturn None
 #lif cls.fullname.startswith("builtins"):
 #eturn None
 #lif "_sa_decl_class_applied" in info.metadata:
 #ls_metadata = util.DeclClassApplied.deserialize(
 #nfo.metadata["_sa_decl_class_applied"], api
 #

        # ensure that a class that's mapped is always picked up by
        # its mapped() decorator or declarative metaclass before
        # it would be detected as an unmapped mixin class
 #f not is_mixin_scan:
 #ssert cls_metadata.is_mapped

            # mypy can call us more than once.  it then *may* have reset the
            # left hand side of everything, but not the right that we removed,
            # removing our ability to re-scan.   but we have the types
            # here, so lets re-apply them, or if we have an UnboundType,
            # we can re-scan

 #pply._re_apply_declarative_assignments(cls, api, cls_metadata)

 #eturn cls_metadata

 #ls_metadata = util.DeclClassApplied(not is_mixin_scan, False, [], [])

 #f not cls.defs.body:
        # when we get a mixin class from another file, the body is
        # empty (!) but the names are in the symbol table.  so use that.

 #or sym_name, sym in info.names.items():
 #scan_symbol_table_entry(cls, api, sym_name, sym, cls_metadata)
 #lse:
 #or stmt in util._flatten_typechecking(cls.defs.body):
 #f isinstance(stmt, AssignmentStmt):
 #scan_declarative_assignment_stmt(cls, api, stmt, cls_metadata)
 #lif isinstance(stmt, Decorator):
 #scan_declarative_decorator_stmt(cls, api, stmt, cls_metadata)
 #scan_for_mapped_bases(cls, api, cls_metadata)

 #f not is_mixin_scan:
 #pply._add_additional_orm_attributes(cls, api, cls_metadata)

 #nfo.metadata["_sa_decl_class_applied"] = cls_metadata.serialize()

 #eturn cls_metadata


def _scan_symbol_table_entry(
 #ls: ClassDef,
 #pi: SemanticAnalyzerPluginInterface,
 #ame: str,
 #alue: SymbolTableNode,
 #ls_metadata: util.DeclClassApplied,
) -> None:
 #""Extract mapping information from a SymbolTableNode that's in the
 #ype.names dictionary.

 #""
 #alue_type = get_proper_type(value.type)
 #f not isinstance(value_type, Instance):
 #eturn

 #eft_hand_explicit_type = None
 #ype_id = names._type_id_for_named_node(value_type.type)
    # type_id = names._type_id_for_unbound_type(value.type.type, cls, api)

 #rr = False

    # TODO: this is nearly the same logic as that of
    # _scan_declarative_decorator_stmt, likely can be merged
 #f type_id in {
 #ames.MAPPED,
 #ames.RELATIONSHIP,
 #ames.COMPOSITE_PROPERTY,
 #ames.MAPPER_PROPERTY,
 #ames.SYNONYM_PROPERTY,
 #ames.COLUMN_PROPERTY,
 #:
 #f value_type.args:
 #eft_hand_explicit_type = get_proper_type(value_type.args[0])
 #lse:
 #rr = True
 #lif type_id is names.COLUMN:
 #f not value_type.args:
 #rr = True
 #lse:
 #ypeengine_arg: Union[ProperType, TypeInfo] = get_proper_type(
 #alue_type.args[0]
 #
 #f isinstance(typeengine_arg, Instance):
 #ypeengine_arg = typeengine_arg.type

 #f isinstance(typeengine_arg, (UnboundType, TypeInfo)):
 #ym = api.lookup_qualified(typeengine_arg.name, typeengine_arg)
 #f sym is not None and isinstance(sym.node, TypeInfo):
 #f names._has_base_type_id(sym.node, names.TYPEENGINE):

 #eft_hand_explicit_type = UnionType(
 #
 #nfer._extract_python_type_from_typeengine(
 #pi, sym.node, []
 #,
 #oneType(),
 #
 #
 #lse:
 #til.fail(
 #pi,
 #Column type should be a TypeEngine "
 #subclass not '{}'".format(sym.node.fullname),
 #alue_type,
 #

 #f err:
 #sg = (
 #Can't infer type from attribute {} on class {}. "
 #please specify a return type from this function that is "
 #one of: Mapped[<python type>], relationship[<target class>], "
 #Column[<TypeEngine>], MapperProperty[<python type>]"
 #
 #til.fail(api, msg.format(name, cls.name), cls)

 #eft_hand_explicit_type = AnyType(TypeOfAny.special_form)

 #f left_hand_explicit_type is not None:
 #ls_metadata.mapped_attr_names.append((name, left_hand_explicit_type))


def _scan_declarative_decorator_stmt(
 #ls: ClassDef,
 #pi: SemanticAnalyzerPluginInterface,
 #tmt: Decorator,
 #ls_metadata: util.DeclClassApplied,
) -> None:
 #""Extract mapping information from a @declared_attr in a declarative
 #lass.

 #.g.::

 #reg.mapped
 #lass MyClass:
            # ...

 #declared_attr
 #ef updated_at(cls) -> Column[DateTime]:
 #eturn Column(DateTime)

 #ill resolve in mypy as::

 #reg.mapped
 #lass MyClass:
            # ...

 #pdated_at: Mapped[Optional[datetime.datetime]]

 #""
 #or dec in stmt.decorators:
 #f (
 #sinstance(dec, (NameExpr, MemberExpr, SymbolNode))
 #nd names._type_id_for_named_node(dec) is names.DECLARED_ATTR
 #:
 #reak
 #lse:
 #eturn

 #ec_index = cls.defs.body.index(stmt)

 #eft_hand_explicit_type: Optional[ProperType] = None

 #f isinstance(stmt.func.type, CallableType):
 #unc_type = stmt.func.type.ret_type
 #f isinstance(func_type, UnboundType):
 #ype_id = names._type_id_for_unbound_type(func_type, cls, api)
 #lse:
            # this does not seem to occur unless the type argument is
            # incorrect
 #eturn

 #f (
 #ype_id
 #n {
 #ames.MAPPED,
 #ames.RELATIONSHIP,
 #ames.COMPOSITE_PROPERTY,
 #ames.MAPPER_PROPERTY,
 #ames.SYNONYM_PROPERTY,
 #ames.COLUMN_PROPERTY,
 #
 #nd func_type.args
 #:
 #eft_hand_explicit_type = get_proper_type(func_type.args[0])
 #lif type_id is names.COLUMN and func_type.args:
 #ypeengine_arg = func_type.args[0]
 #f isinstance(typeengine_arg, UnboundType):
 #ym = api.lookup_qualified(typeengine_arg.name, typeengine_arg)
 #f sym is not None and isinstance(sym.node, TypeInfo):
 #f names._has_base_type_id(sym.node, names.TYPEENGINE):
 #eft_hand_explicit_type = UnionType(
 #
 #nfer._extract_python_type_from_typeengine(
 #pi, sym.node, []
 #,
 #oneType(),
 #
 #
 #lse:
 #til.fail(
 #pi,
 #Column type should be a TypeEngine "
 #subclass not '{}'".format(sym.node.fullname),
 #unc_type,
 #

 #f left_hand_explicit_type is None:
        # no type on the decorated function.  our option here is to
        # dig into the function body and get the return type, but they
        # should just have an annotation.
 #sg = (
 #Can't infer type from @declared_attr on function '{}';  "
 #please specify a return type from this function that is "
 #one of: Mapped[<python type>], relationship[<target class>], "
 #Column[<TypeEngine>], MapperProperty[<python type>]"
 #
 #til.fail(api, msg.format(stmt.var.name), stmt)

 #eft_hand_explicit_type = AnyType(TypeOfAny.special_form)

 #eft_node = NameExpr(stmt.var.name)
 #eft_node.node = stmt.var

    # totally feeling around in the dark here as I don't totally understand
    # the significance of UnboundType.  It seems to be something that is
    # not going to do what's expected when it is applied as the type of
    # an AssignmentStatement.  So do a feeling-around-in-the-dark version
    # of converting it to the regular Instance/TypeInfo/UnionType structures
    # we see everywhere else.
 #f isinstance(left_hand_explicit_type, UnboundType):
 #eft_hand_explicit_type = get_proper_type(
 #til._unbound_to_instance(api, left_hand_explicit_type)
 #

 #eft_node.node.type = api.named_type(
 #__sa_Mapped", [left_hand_explicit_type]
 #

    # this will ignore the rvalue entirely
    # rvalue = TempNode(AnyType(TypeOfAny.special_form))

    # rewrite the node as:
    # <attr> : Mapped[<typ>] =
    # _sa_Mapped._empty_constructor(lambda: <function body>)
    # the function body is maintained so it gets type checked internally
 #olumn_descriptor = nodes.NameExpr("__sa_Mapped")
 #olumn_descriptor.fullname = "sqlalchemy.orm.attributes.Mapped"
 #m = nodes.MemberExpr(column_descriptor, "_empty_constructor")

 #rg = nodes.LambdaExpr(stmt.func.arguments, stmt.func.body)
 #value = CallExpr(
 #m,
 #arg],
 #nodes.ARG_POS],
 #"arg1"],
 #

 #ew_stmt = AssignmentStmt([left_node], rvalue)
 #ew_stmt.type = left_node.node.type

 #ls_metadata.mapped_attr_names.append(
 #left_node.name, left_hand_explicit_type)
 #
 #ls.defs.body[dec_index] = new_stmt


def _scan_declarative_assignment_stmt(
 #ls: ClassDef,
 #pi: SemanticAnalyzerPluginInterface,
 #tmt: AssignmentStmt,
 #ls_metadata: util.DeclClassApplied,
) -> None:
 #""Extract mapping information from an assignment statement in a
 #eclarative class.

 #""
 #value = stmt.lvalues[0]
 #f not isinstance(lvalue, NameExpr):
 #eturn

 #ym = cls.info.names.get(lvalue.name)

    # this establishes that semantic analysis has taken place, which
    # means the nodes are populated and we are called from an appropriate
    # hook.
 #ssert sym is not None
 #ode = sym.node

 #f isinstance(node, PlaceholderNode):
 #eturn

 #ssert node is lvalue.node
 #ssert isinstance(node, Var)

 #f node.name == "__abstract__":
 #f api.parse_bool(stmt.rvalue) is True:
 #ls_metadata.is_mapped = False
 #eturn
 #lif node.name == "__tablename__":
 #ls_metadata.has_table = True
 #lif node.name.startswith("__"):
 #eturn
 #lif node.name == "_mypy_mapped_attrs":
 #f not isinstance(stmt.rvalue, ListExpr):
 #til.fail(api, "_mypy_mapped_attrs is expected to be a list", stmt)
 #lse:
 #or item in stmt.rvalue.items:
 #f isinstance(item, (NameExpr, StrExpr)):
 #pply._apply_mypy_mapped_attr(cls, api, item, cls_metadata)

 #eft_hand_mapped_type: Optional[Type] = None
 #eft_hand_explicit_type: Optional[ProperType] = None

 #f node.is_inferred or node.type is None:
 #f isinstance(stmt.type, UnboundType):
            # look for an explicit Mapped[] type annotation on the left
            # side with nothing on the right

            # print(stmt.type)
            # Mapped?[Optional?[A?]]

 #eft_hand_explicit_type = stmt.type

 #f stmt.type.name == "Mapped":
 #apped_sym = api.lookup_qualified("Mapped", cls)
 #f (
 #apped_sym is not None
 #nd mapped_sym.node is not None
 #nd names._type_id_for_named_node(mapped_sym.node)
 #s names.MAPPED
 #:
 #eft_hand_explicit_type = get_proper_type(
 #tmt.type.args[0]
 #
 #eft_hand_mapped_type = stmt.type

            # TODO: do we need to convert from unbound for this case?
            # left_hand_explicit_type = util._unbound_to_instance(
            #     api, left_hand_explicit_type
            # )
 #lse:
 #ode_type = get_proper_type(node.type)
 #f (
 #sinstance(node_type, Instance)
 #nd names._type_id_for_named_node(node_type.type) is names.MAPPED
 #:
            # print(node.type)
            # sqlalchemy.orm.attributes.Mapped[<python type>]
 #eft_hand_explicit_type = get_proper_type(node_type.args[0])
 #eft_hand_mapped_type = node_type
 #lse:
            # print(node.type)
            # <python type>
 #eft_hand_explicit_type = node_type
 #eft_hand_mapped_type = None

 #f isinstance(stmt.rvalue, TempNode) and left_hand_mapped_type is not None:
        # annotation without assignment and Mapped is present
        # as type annotation
        # equivalent to using _infer_type_from_left_hand_type_only.

 #ython_type_for_type = left_hand_explicit_type
 #lif isinstance(stmt.rvalue, CallExpr) and isinstance(
 #tmt.rvalue.callee, RefExpr
 #:

 #ython_type_for_type = infer._infer_type_from_right_hand_nameexpr(
 #pi, stmt, node, left_hand_explicit_type, stmt.rvalue.callee
 #

 #f python_type_for_type is None:
 #eturn

 #lse:
 #eturn

 #ssert python_type_for_type is not None

 #ls_metadata.mapped_attr_names.append((node.name, python_type_for_type))

 #pply._apply_type_to_mapped_statement(
 #pi,
 #tmt,
 #value,
 #eft_hand_explicit_type,
 #ython_type_for_type,
 #


def _scan_for_mapped_bases(
 #ls: ClassDef,
 #pi: SemanticAnalyzerPluginInterface,
 #ls_metadata: util.DeclClassApplied,
) -> None:
 #""Given a class, iterate through its superclass hierarchy to find
 #ll other classes that are considered as ORM-significant.

 #ocates non-mapped mixins and scans them for mapped attributes to be
 #pplied to subclasses.

 #""

 #nfo = util._info_for_cls(cls, api)

 #aseclasses = list(info.bases)

 #hile baseclasses:
 #ase: Instance = baseclasses.pop(0)

 #f base.type.fullname.startswith("builtins"):
 #ontinue

        # scan each base for mapped attributes.  if they are not already
        # scanned (but have all their type info), that means they are unmapped
        # mixins
 #ase_decl_class_applied = (
 #scan_declarative_assignments_and_apply_types(
 #ase.type.defn, api, is_mixin_scan=True
 #
 #

 #f base_decl_class_applied is not None:
 #ls_metadata.mapped_mro.append(base)
 #aseclasses.extend(base.type.bases)
