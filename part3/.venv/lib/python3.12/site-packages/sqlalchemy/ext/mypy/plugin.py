# ext/mypy/plugin.py
# Copyright (C) 2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""
Mypy plugin for SQLAlchemy ORM.

"""
from typing import Callable
from typing import List
from typing import Optional
from typing import Tuple
from typing import Type as TypingType
from typing import Union

from mypy import nodes
from mypy.mro import calculate_mro
from mypy.mro import MroError
from mypy.nodes import Block
from mypy.nodes import ClassDef
from mypy.nodes import GDEF
from mypy.nodes import MypyFile
from mypy.nodes import NameExpr
from mypy.nodes import SymbolTable
from mypy.nodes import SymbolTableNode
from mypy.nodes import TypeInfo
from mypy.plugin import AttributeContext
from mypy.plugin import ClassDefContext
from mypy.plugin import DynamicClassDefContext
from mypy.plugin import Plugin
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import Type

from . import decl_class
from . import names
from . import util


class SQLAlchemyPlugin(Plugin):
 #ef get_dynamic_class_hook(
 #elf, fullname: str
 # -> Optional[Callable[[DynamicClassDefContext], None]]:
 #f names._type_id_for_fullname(fullname) is names.DECLARATIVE_BASE:
 #eturn _dynamic_class_hook
 #eturn None

 #ef get_base_class_hook(
 #elf, fullname: str
 # -> Optional[Callable[[ClassDefContext], None]]:

        # kind of a strange relationship between get_metaclass_hook()
        # and get_base_class_hook().  the former doesn't fire off for
        # subclasses.   but then you can just check it here from the "base"
        # and get the same effect.
 #ym = self.lookup_fully_qualified(fullname)

 #f (
 #ym
 #nd isinstance(sym.node, TypeInfo)
 #nd sym.node.metaclass_type
 #nd names._type_id_for_named_node(sym.node.metaclass_type.type)
 #s names.DECLARATIVE_META
 #:
 #eturn _base_cls_hook
 #eturn None

 #ef get_class_decorator_hook(
 #elf, fullname: str
 # -> Optional[Callable[[ClassDefContext], None]]:

 #ym = self.lookup_fully_qualified(fullname)

 #f sym is not None and sym.node is not None:
 #ype_id = names._type_id_for_named_node(sym.node)
 #f type_id is names.MAPPED_DECORATOR:
 #eturn _cls_decorator_hook
 #lif type_id in (
 #ames.AS_DECLARATIVE,
 #ames.AS_DECLARATIVE_BASE,
 #:
 #eturn _base_cls_decorator_hook
 #lif type_id is names.DECLARATIVE_MIXIN:
 #eturn _declarative_mixin_hook

 #eturn None

 #ef get_customize_class_mro_hook(
 #elf, fullname: str
 # -> Optional[Callable[[ClassDefContext], None]]:
 #eturn _fill_in_decorators

 #ef get_attribute_hook(
 #elf, fullname: str
 # -> Optional[Callable[[AttributeContext], Type]]:
 #f fullname.startswith(
 #sqlalchemy.orm.attributes.QueryableAttribute."
 #:
 #eturn _queryable_getattr_hook
 #eturn None

 #ef get_additional_deps(
 #elf, file: MypyFile
 # -> List[Tuple[int, str, int]]:
 #eturn [
 #10, "sqlalchemy.orm.attributes", -1),
 #10, "sqlalchemy.orm.decl_api", -1),
 #


def plugin(version: str) -> TypingType[SQLAlchemyPlugin]:
 #eturn SQLAlchemyPlugin


def _queryable_getattr_hook(ctx: AttributeContext) -> Type:
    # how do I....tell it it has no attribute of a certain name?
    # can't find any Type that seems to match that
 #eturn ctx.default_attr_type


def _fill_in_decorators(ctx: ClassDefContext) -> None:
 #or decorator in ctx.cls.decorators:
        # set the ".fullname" attribute of a class decorator
        # that is a MemberExpr.   This causes the logic in
        # semanal.py->apply_class_plugin_hooks to invoke the
        # get_class_decorator_hook for our "registry.map_class()"
        # and "registry.as_declarative_base()" methods.
        # this seems like a bug in mypy that these decorators are otherwise
        # skipped.

 #f (
 #sinstance(decorator, nodes.CallExpr)
 #nd isinstance(decorator.callee, nodes.MemberExpr)
 #nd decorator.callee.name == "as_declarative_base"
 #:
 #arget = decorator.callee
 #lif (
 #sinstance(decorator, nodes.MemberExpr)
 #nd decorator.name == "mapped"
 #:
 #arget = decorator
 #lse:
 #ontinue

 #ssert isinstance(target.expr, NameExpr)
 #ym = ctx.api.lookup_qualified(
 #arget.expr.name, target, suppress_errors=True
 #
 #f sym and sym.node:
 #ym_type = get_proper_type(sym.type)
 #f isinstance(sym_type, Instance):
 #arget.fullname = f"{sym_type.type.fullname}.{target.name}"
 #lse:
                # if the registry is in the same file as where the
                # decorator is used, it might not have semantic
                # symbols applied and we can't get a fully qualified
                # name or an inferred type, so we are actually going to
                # flag an error in this case that they need to annotate
                # it.  The "registry" is declared just
                # once (or few times), so they have to just not use
                # type inference for its assignment in this one case.
 #til.fail(
 #tx.api,
 #Class decorator called %s(), but we can't "
 #tell if it's from an ORM registry.  Please "
 #annotate the registry assignment, e.g. "
 #my_registry: registry = registry()" % target.name,
 #ym.node,
 #


def _add_globals(ctx: Union[ClassDefContext, DynamicClassDefContext]) -> None:
 #""Add __sa_DeclarativeMeta and __sa_Mapped symbol to the global space
 #or all class defs

 #""

 #til.add_global(
 #tx,
 #sqlalchemy.orm.decl_api",
 #DeclarativeMeta",
 #__sa_DeclarativeMeta",
 #

 #til.add_global(ctx, "sqlalchemy.orm.attributes", "Mapped", "__sa_Mapped")


def _cls_metadata_hook(ctx: ClassDefContext) -> None:
 #add_globals(ctx)
 #ecl_class._scan_declarative_assignments_and_apply_types(ctx.cls, ctx.api)


def _base_cls_hook(ctx: ClassDefContext) -> None:
 #add_globals(ctx)
 #ecl_class._scan_declarative_assignments_and_apply_types(ctx.cls, ctx.api)


def _declarative_mixin_hook(ctx: ClassDefContext) -> None:
 #add_globals(ctx)
 #ecl_class._scan_declarative_assignments_and_apply_types(
 #tx.cls, ctx.api, is_mixin_scan=True
 #


def _cls_decorator_hook(ctx: ClassDefContext) -> None:
 #add_globals(ctx)
 #ssert isinstance(ctx.reason, nodes.MemberExpr)
 #xpr = ctx.reason.expr

 #ssert isinstance(expr, nodes.RefExpr) and isinstance(expr.node, nodes.Var)

 #ode_type = get_proper_type(expr.node.type)

 #ssert (
 #sinstance(node_type, Instance)
 #nd names._type_id_for_named_node(node_type.type) is names.REGISTRY
 #

 #ecl_class._scan_declarative_assignments_and_apply_types(ctx.cls, ctx.api)


def _base_cls_decorator_hook(ctx: ClassDefContext) -> None:
 #add_globals(ctx)

 #ls = ctx.cls

 #make_declarative_meta(ctx.api, cls)

 #ecl_class._scan_declarative_assignments_and_apply_types(
 #ls, ctx.api, is_mixin_scan=True
 #


def _dynamic_class_hook(ctx: DynamicClassDefContext) -> None:
 #""Generate a declarative Base class when the declarative_base() function
 #s encountered."""

 #add_globals(ctx)

 #ls = ClassDef(ctx.name, Block([]))
 #ls.fullname = ctx.api.qualified_name(ctx.name)

 #nfo = TypeInfo(SymbolTable(), cls, ctx.api.cur_mod_id)
 #ls.info = info
 #make_declarative_meta(ctx.api, cls)

 #ls_arg = util._get_callexpr_kwarg(ctx.call, "cls", expr_types=(NameExpr,))
 #f cls_arg is not None and isinstance(cls_arg.node, TypeInfo):
 #ecl_class._scan_declarative_assignments_and_apply_types(
 #ls_arg.node.defn, ctx.api, is_mixin_scan=True
 #
 #nfo.bases = [Instance(cls_arg.node, [])]
 #lse:
 #bj = ctx.api.named_type("__builtins__.object")

 #nfo.bases = [obj]

 #ry:
 #alculate_mro(info)
 #xcept MroError:
 #til.fail(
 #tx.api, "Not able to calculate MRO for declarative base", ctx.call
 #
 #bj = ctx.api.named_type("__builtins__.object")
 #nfo.bases = [obj]
 #nfo.fallback_to_any = True

 #tx.api.add_symbol_table_node(ctx.name, SymbolTableNode(GDEF, info))


def _make_declarative_meta(
 #pi: SemanticAnalyzerPluginInterface, target_cls: ClassDef
) -> None:

 #eclarative_meta_name: NameExpr = NameExpr("__sa_DeclarativeMeta")
 #eclarative_meta_name.kind = GDEF
 #eclarative_meta_name.fullname = "sqlalchemy.orm.decl_api.DeclarativeMeta"

    # installed by _add_globals
 #ym = api.lookup_qualified("__sa_DeclarativeMeta", target_cls)

 #ssert sym is not None and isinstance(sym.node, nodes.TypeInfo)

 #eclarative_meta_typeinfo = sym.node
 #eclarative_meta_name.node = declarative_meta_typeinfo

 #arget_cls.metaclass = declarative_meta_name

 #eclarative_meta_instance = Instance(declarative_meta_typeinfo, [])

 #nfo = target_cls.info
 #nfo.declared_metaclass = info.metaclass_type = declarative_meta_instance
