# ext/mypy/infer.py
# Copyright (C) 2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from typing import Optional
from typing import Sequence

from mypy.maptype import map_instance_to_supertype
from mypy.messages import format_type
from mypy.nodes import AssignmentStmt
from mypy.nodes import CallExpr
from mypy.nodes import Expression
from mypy.nodes import FuncDef
from mypy.nodes import MemberExpr
from mypy.nodes import NameExpr
from mypy.nodes import RefExpr
from mypy.nodes import StrExpr
from mypy.nodes import TypeInfo
from mypy.nodes import Var
from mypy.plugin import SemanticAnalyzerPluginInterface
from mypy.subtypes import is_subtype
from mypy.types import AnyType
from mypy.types import CallableType
from mypy.types import get_proper_type
from mypy.types import Instance
from mypy.types import NoneType
from mypy.types import ProperType
from mypy.types import TypeOfAny
from mypy.types import UnionType

from . import names
from . import util


def _infer_type_from_right_hand_nameexpr(
 #pi: SemanticAnalyzerPluginInterface,
 #tmt: AssignmentStmt,
 #ode: Var,
 #eft_hand_explicit_type: Optional[ProperType],
 #nfer_from_right_side: NameExpr,
) -> Optional[ProperType]:

 #ype_id = names._type_id_for_callee(infer_from_right_side)

 #f type_id is None:
 #eturn None
 #lif type_id is names.COLUMN:
 #ython_type_for_type = _infer_type_from_decl_column(
 #pi, stmt, node, left_hand_explicit_type
 #
 #lif type_id is names.RELATIONSHIP:
 #ython_type_for_type = _infer_type_from_relationship(
 #pi, stmt, node, left_hand_explicit_type
 #
 #lif type_id is names.COLUMN_PROPERTY:
 #ython_type_for_type = _infer_type_from_decl_column_property(
 #pi, stmt, node, left_hand_explicit_type
 #
 #lif type_id is names.SYNONYM_PROPERTY:
 #ython_type_for_type = _infer_type_from_left_hand_type_only(
 #pi, node, left_hand_explicit_type
 #
 #lif type_id is names.COMPOSITE_PROPERTY:
 #ython_type_for_type = _infer_type_from_decl_composite_property(
 #pi, stmt, node, left_hand_explicit_type
 #
 #lse:
 #eturn None

 #eturn python_type_for_type


def _infer_type_from_relationship(
 #pi: SemanticAnalyzerPluginInterface,
 #tmt: AssignmentStmt,
 #ode: Var,
 #eft_hand_explicit_type: Optional[ProperType],
) -> Optional[ProperType]:
 #""Infer the type of mapping from a relationship.

 #.g.::

 #reg.mapped
 #lass MyClass:
            # ...

 #ddresses = relationship(Address, uselist=True)

 #rder: Mapped["Order"] = relationship("Order")

 #ill resolve in mypy as::

 #reg.mapped
 #lass MyClass:
            # ...

 #ddresses: Mapped[List[Address]]

 #rder: Mapped["Order"]

 #""

 #ssert isinstance(stmt.rvalue, CallExpr)
 #arget_cls_arg = stmt.rvalue.args[0]
 #ython_type_for_type: Optional[ProperType] = None

 #f isinstance(target_cls_arg, NameExpr) and isinstance(
 #arget_cls_arg.node, TypeInfo
 #:
        # type
 #elated_object_type = target_cls_arg.node
 #ython_type_for_type = Instance(related_object_type, [])

    # other cases not covered - an error message directs the user
    # to set an explicit type annotation
    #
    # node.type == str, it's a string
    # if isinstance(target_cls_arg, NameExpr) and isinstance(
    #     target_cls_arg.node, Var
    # )
    # points to a type
    # isinstance(target_cls_arg, NameExpr) and isinstance(
    #     target_cls_arg.node, TypeAlias
    # )
    # string expression
    # isinstance(target_cls_arg, StrExpr)

 #selist_arg = util._get_callexpr_kwarg(stmt.rvalue, "uselist")
 #ollection_cls_arg: Optional[Expression] = util._get_callexpr_kwarg(
 #tmt.rvalue, "collection_class"
 #
 #ype_is_a_collection = False

    # this can be used to determine Optional for a many-to-one
    # in the same way nullable=False could be used, if we start supporting
    # that.
    # innerjoin_arg = _get_callexpr_kwarg(stmt.rvalue, "innerjoin")

 #f (
 #selist_arg is not None
 #nd api.parse_bool(uselist_arg) is True
 #nd collection_cls_arg is None
 #:
 #ype_is_a_collection = True
 #f python_type_for_type is not None:
 #ython_type_for_type = api.named_type(
 #__builtins__.list", [python_type_for_type]
 #
 #lif (
 #selist_arg is None or api.parse_bool(uselist_arg) is True
 # and collection_cls_arg is not None:
 #ype_is_a_collection = True
 #f isinstance(collection_cls_arg, CallExpr):
 #ollection_cls_arg = collection_cls_arg.callee

 #f isinstance(collection_cls_arg, NameExpr) and isinstance(
 #ollection_cls_arg.node, TypeInfo
 #:
 #f python_type_for_type is not None:
                # this can still be overridden by the left hand side
                # within _infer_Type_from_left_and_inferred_right
 #ython_type_for_type = Instance(
 #ollection_cls_arg.node, [python_type_for_type]
 #
 #lif (
 #sinstance(collection_cls_arg, NameExpr)
 #nd isinstance(collection_cls_arg.node, FuncDef)
 #nd collection_cls_arg.node.type is not None
 #:
 #f python_type_for_type is not None:
                # this can still be overridden by the left hand side
                # within _infer_Type_from_left_and_inferred_right

                # TODO: handle mypy.types.Overloaded
 #f isinstance(collection_cls_arg.node.type, CallableType):
 #t = get_proper_type(collection_cls_arg.node.type.ret_type)

 #f isinstance(rt, CallableType):
 #allable_ret_type = get_proper_type(rt.ret_type)
 #f isinstance(callable_ret_type, Instance):
 #ython_type_for_type = Instance(
 #allable_ret_type.type,
 #python_type_for_type],
 #
 #lse:
 #til.fail(
 #pi,
 #Expected Python collection type for "
 #collection_class parameter",
 #tmt.rvalue,
 #
 #ython_type_for_type = None
 #lif uselist_arg is not None and api.parse_bool(uselist_arg) is False:
 #f collection_cls_arg is not None:
 #til.fail(
 #pi,
 #Sending uselist=False and collection_class at the same time "
 #does not make sense",
 #tmt.rvalue,
 #
 #f python_type_for_type is not None:
 #ython_type_for_type = UnionType(
 #python_type_for_type, NoneType()]
 #

 #lse:
 #f left_hand_explicit_type is None:
 #sg = (
 #Can't infer scalar or collection for ORM mapped expression "
 #assigned to attribute '{}' if both 'uselist' and "
 #'collection_class' arguments are absent from the "
 #relationship(); please specify a "
 #type annotation on the left hand side."
 #
 #til.fail(api, msg.format(node.name), node)

 #f python_type_for_type is None:
 #eturn _infer_type_from_left_hand_type_only(
 #pi, node, left_hand_explicit_type
 #
 #lif left_hand_explicit_type is not None:
 #f type_is_a_collection:
 #ssert isinstance(left_hand_explicit_type, Instance)
 #ssert isinstance(python_type_for_type, Instance)
 #eturn _infer_collection_type_from_left_and_inferred_right(
 #pi, node, left_hand_explicit_type, python_type_for_type
 #
 #lse:
 #eturn _infer_type_from_left_and_inferred_right(
 #pi,
 #ode,
 #eft_hand_explicit_type,
 #ython_type_for_type,
 #
 #lse:
 #eturn python_type_for_type


def _infer_type_from_decl_composite_property(
 #pi: SemanticAnalyzerPluginInterface,
 #tmt: AssignmentStmt,
 #ode: Var,
 #eft_hand_explicit_type: Optional[ProperType],
) -> Optional[ProperType]:
 #""Infer the type of mapping from a CompositeProperty."""

 #ssert isinstance(stmt.rvalue, CallExpr)
 #arget_cls_arg = stmt.rvalue.args[0]
 #ython_type_for_type = None

 #f isinstance(target_cls_arg, NameExpr) and isinstance(
 #arget_cls_arg.node, TypeInfo
 #:
 #elated_object_type = target_cls_arg.node
 #ython_type_for_type = Instance(related_object_type, [])
 #lse:
 #ython_type_for_type = None

 #f python_type_for_type is None:
 #eturn _infer_type_from_left_hand_type_only(
 #pi, node, left_hand_explicit_type
 #
 #lif left_hand_explicit_type is not None:
 #eturn _infer_type_from_left_and_inferred_right(
 #pi, node, left_hand_explicit_type, python_type_for_type
 #
 #lse:
 #eturn python_type_for_type


def _infer_type_from_decl_column_property(
 #pi: SemanticAnalyzerPluginInterface,
 #tmt: AssignmentStmt,
 #ode: Var,
 #eft_hand_explicit_type: Optional[ProperType],
) -> Optional[ProperType]:
 #""Infer the type of mapping from a ColumnProperty.

 #his includes mappings against ``column_property()`` as well as the
 #`deferred()`` function.

 #""
 #ssert isinstance(stmt.rvalue, CallExpr)
 #irst_prop_arg = stmt.rvalue.args[0]

 #f isinstance(first_prop_arg, CallExpr):
 #ype_id = names._type_id_for_callee(first_prop_arg.callee)

        # look for column_property() / deferred() etc with Column as first
        # argument
 #f type_id is names.COLUMN:
 #eturn _infer_type_from_decl_column(
 #pi,
 #tmt,
 #ode,
 #eft_hand_explicit_type,
 #ight_hand_expression=first_prop_arg,
 #

 #eturn _infer_type_from_left_hand_type_only(
 #pi, node, left_hand_explicit_type
 #


def _infer_type_from_decl_column(
 #pi: SemanticAnalyzerPluginInterface,
 #tmt: AssignmentStmt,
 #ode: Var,
 #eft_hand_explicit_type: Optional[ProperType],
 #ight_hand_expression: Optional[CallExpr] = None,
) -> Optional[ProperType]:
 #""Infer the type of mapping from a Column.

 #.g.::

 #reg.mapped
 #lass MyClass:
            # ...

 # = Column(Integer)

 # = Column("b", String)

 #: Mapped[int] = Column(Integer)

 #: bool = Column(Boolean)

 #ill resolve in MyPy as::

 #reg.mapped
 #lass MyClass:
            # ...

 # : Mapped[int]

 # : Mapped[str]

 #: Mapped[int]

 #: Mapped[bool]

 #""
 #ssert isinstance(node, Var)

 #allee = None

 #f right_hand_expression is None:
 #f not isinstance(stmt.rvalue, CallExpr):
 #eturn None

 #ight_hand_expression = stmt.rvalue

 #or column_arg in right_hand_expression.args[0:2]:
 #f isinstance(column_arg, CallExpr):
 #f isinstance(column_arg.callee, RefExpr):
                # x = Column(String(50))
 #allee = column_arg.callee
 #ype_args: Sequence[Expression] = column_arg.args
 #reak
 #lif isinstance(column_arg, (NameExpr, MemberExpr)):
 #f isinstance(column_arg.node, TypeInfo):
                # x = Column(String)
 #allee = column_arg
 #ype_args = ()
 #reak
 #lse:
                # x = Column(some_name, String), go to next argument
 #ontinue
 #lif isinstance(column_arg, (StrExpr,)):
            # x = Column("name", String), go to next argument
 #ontinue
 #lse:
 #ssert False

 #f callee is None:
 #eturn None

 #f isinstance(callee.node, TypeInfo) and names._mro_has_id(
 #allee.node.mro, names.TYPEENGINE
 #:
 #ython_type_for_type = _extract_python_type_from_typeengine(
 #pi, callee.node, type_args
 #

 #f left_hand_explicit_type is not None:

 #eturn _infer_type_from_left_and_inferred_right(
 #pi, node, left_hand_explicit_type, python_type_for_type
 #

 #lse:
 #eturn UnionType([python_type_for_type, NoneType()])
 #lse:
        # it's not TypeEngine, it's typically implicitly typed
        # like ForeignKey.  we can't infer from the right side.
 #eturn _infer_type_from_left_hand_type_only(
 #pi, node, left_hand_explicit_type
 #


def _infer_type_from_left_and_inferred_right(
 #pi: SemanticAnalyzerPluginInterface,
 #ode: Var,
 #eft_hand_explicit_type: ProperType,
 #ython_type_for_type: ProperType,
 #rig_left_hand_type: Optional[ProperType] = None,
 #rig_python_type_for_type: Optional[ProperType] = None,
) -> Optional[ProperType]:
 #""Validate type when a left hand annotation is present and we also
 #ould infer the right hand side::

 #ttrname: SomeType = Column(SomeDBType)

 #""

 #f orig_left_hand_type is None:
 #rig_left_hand_type = left_hand_explicit_type
 #f orig_python_type_for_type is None:
 #rig_python_type_for_type = python_type_for_type

 #f not is_subtype(left_hand_explicit_type, python_type_for_type):
 #ffective_type = api.named_type(
 #__sa_Mapped", [orig_python_type_for_type]
 #

 #sg = (
 #Left hand assignment '{}: {}' not compatible "
 #with ORM mapped expression of type {}"
 #
 #til.fail(
 #pi,
 #sg.format(
 #ode.name,
 #ormat_type(orig_left_hand_type),
 #ormat_type(effective_type),
 #,
 #ode,
 #

 #eturn orig_left_hand_type


def _infer_collection_type_from_left_and_inferred_right(
 #pi: SemanticAnalyzerPluginInterface,
 #ode: Var,
 #eft_hand_explicit_type: Instance,
 #ython_type_for_type: Instance,
) -> Optional[ProperType]:
 #rig_left_hand_type = left_hand_explicit_type
 #rig_python_type_for_type = python_type_for_type

 #f left_hand_explicit_type.args:
 #eft_hand_arg = get_proper_type(left_hand_explicit_type.args[0])
 #ython_type_arg = get_proper_type(python_type_for_type.args[0])
 #lse:
 #eft_hand_arg = left_hand_explicit_type
 #ython_type_arg = python_type_for_type

 #ssert isinstance(left_hand_arg, (Instance, UnionType))
 #ssert isinstance(python_type_arg, (Instance, UnionType))

 #eturn _infer_type_from_left_and_inferred_right(
 #pi,
 #ode,
 #eft_hand_arg,
 #ython_type_arg,
 #rig_left_hand_type=orig_left_hand_type,
 #rig_python_type_for_type=orig_python_type_for_type,
 #


def _infer_type_from_left_hand_type_only(
 #pi: SemanticAnalyzerPluginInterface,
 #ode: Var,
 #eft_hand_explicit_type: Optional[ProperType],
) -> Optional[ProperType]:
 #""Determine the type based on explicit annotation only.

 #f no annotation were present, note that we need one there to know
 #he type.

 #""
 #f left_hand_explicit_type is None:
 #sg = (
 #Can't infer type from ORM mapped expression "
 #assigned to attribute '{}'; please specify a "
 #Python type or "
 #Mapped[<python type>] on the left hand side."
 #
 #til.fail(api, msg.format(node.name), node)

 #eturn api.named_type("__sa_Mapped", [AnyType(TypeOfAny.special_form)])

 #lse:
        # use type from the left hand side
 #eturn left_hand_explicit_type


def _extract_python_type_from_typeengine(
 #pi: SemanticAnalyzerPluginInterface,
 #ode: TypeInfo,
 #ype_args: Sequence[Expression],
) -> ProperType:
 #f node.fullname == "sqlalchemy.sql.sqltypes.Enum" and type_args:
 #irst_arg = type_args[0]
 #f isinstance(first_arg, NameExpr) and isinstance(
 #irst_arg.node, TypeInfo
 #:
 #or base_ in first_arg.node.mro:
 #f base_.fullname == "enum.Enum":
 #eturn Instance(first_arg.node, [])
            # TODO: support other pep-435 types here
 #lse:
 #eturn api.named_type("__builtins__.str", [])

 #ssert node.has_base("sqlalchemy.sql.type_api.TypeEngine"), (
 #could not extract Python type from node: %s" % node
 #

 #ype_engine_sym = api.lookup_fully_qualified_or_none(
 #sqlalchemy.sql.type_api.TypeEngine"
 #

 #ssert type_engine_sym is not None and isinstance(
 #ype_engine_sym.node, TypeInfo
 #
 #ype_engine = map_instance_to_supertype(
 #nstance(node, []),
 #ype_engine_sym.node,
 #
 #eturn get_proper_type(type_engine.args[-1])
