# ext/asyncio/result.py
# Copyright (C) 2020-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import operator

from ...engine.result import _NO_ROW
from ...engine.result import FilterResult
from ...engine.result import FrozenResult
from ...engine.result import MergedResult
from ...util.concurrency import greenlet_spawn


class AsyncCommon(FilterResult):
 #sync def close(self):
 #""Close this result."""

 #wait greenlet_spawn(self._real_result.close)


class AsyncResult(AsyncCommon):
 #""An asyncio wrapper around a :class:`_result.Result` object.

 #he :class:`_asyncio.AsyncResult` only applies to statement executions that
 #se a server-side cursor.  It is returned only from the
 #meth:`_asyncio.AsyncConnection.stream` and
 #meth:`_asyncio.AsyncSession.stream` methods.

 #. note:: As is the case with :class:`_engine.Result`, this object is
 #sed for ORM results returned by :meth:`_asyncio.AsyncSession.execute`,
 #hich can yield instances of ORM mapped objects either individually or
 #ithin tuple-like rows.  Note that these result objects do not
 #eduplicate instances or rows automatically as is the case with the
 #egacy :class:`_orm.Query` object. For in-Python de-duplication of
 #nstances or rows, use the :meth:`_asyncio.AsyncResult.unique` modifier
 #ethod.

 #. versionadded:: 1.4

 #""

 #ef __init__(self, real_result):
 #elf._real_result = real_result

 #elf._metadata = real_result._metadata
 #elf._unique_filter_state = real_result._unique_filter_state

        # BaseCursorResult pre-generates the "_row_getter".  Use that
        # if available rather than building a second one
 #f "_row_getter" in real_result.__dict__:
 #elf._set_memoized_attribute(
 #_row_getter", real_result.__dict__["_row_getter"]
 #

 #ef keys(self):
 #""Return the :meth:`_engine.Result.keys` collection from the
 #nderlying :class:`_engine.Result`.

 #""
 #eturn self._metadata.keys

 #ef unique(self, strategy=None):
 #""Apply unique filtering to the objects returned by this
 #class:`_asyncio.AsyncResult`.

 #efer to :meth:`_engine.Result.unique` in the synchronous
 #QLAlchemy API for a complete behavioral description.


 #""
 #elf._unique_filter_state = (set(), strategy)
 #eturn self

 #ef columns(self, *col_expressions):
 #"""Establish the columns that should be returned in each row.

 #efer to :meth:`_engine.Result.columns` in the synchronous
 #QLAlchemy API for a complete behavioral description.


 #""
 #eturn self._column_slices(col_expressions)

 #sync def partitions(self, size=None):
 #""Iterate through sub-lists of rows of the size given.

 #n async iterator is returned::

 #sync def scroll_results(connection):
 #esult = await connection.stream(select(users_table))

 #sync for partition in result.partitions(100):
 #rint("list of rows: %s" % partition)

 #. seealso::

 #meth:`_engine.Result.partitions`

 #""

 #etter = self._manyrow_getter

 #hile True:
 #artition = await greenlet_spawn(getter, self, size)
 #f partition:
 #ield partition
 #lse:
 #reak

 #sync def fetchone(self):
 #""Fetch one row.

 #hen all rows are exhausted, returns None.

 #his method is provided for backwards compatibility with
 #QLAlchemy 1.x.x.

 #o fetch the first row of a result only, use the
 #meth:`_engine.Result.first` method.  To iterate through all
 #ows, iterate the :class:`_engine.Result` object directly.

 #return: a :class:`.Row` object if no filters are applied, or None
 #f no rows remain.

 #""
 #ow = await greenlet_spawn(self._onerow_getter, self)
 #f row is _NO_ROW:
 #eturn None
 #lse:
 #eturn row

 #sync def fetchmany(self, size=None):
 #""Fetch many rows.

 #hen all rows are exhausted, returns an empty list.

 #his method is provided for backwards compatibility with
 #QLAlchemy 1.x.x.

 #o fetch rows in groups, use the
 #meth:`._asyncio.AsyncResult.partitions` method.

 #return: a list of :class:`.Row` objects.

 #. seealso::

 #meth:`_asyncio.AsyncResult.partitions`

 #""

 #eturn await greenlet_spawn(self._manyrow_getter, self, size)

 #sync def all(self):
 #""Return all rows in a list.

 #loses the result set after invocation.   Subsequent invocations
 #ill return an empty list.

 #return: a list of :class:`.Row` objects.

 #""

 #eturn await greenlet_spawn(self._allrows)

 #ef __aiter__(self):
 #eturn self

 #sync def __anext__(self):
 #ow = await greenlet_spawn(self._onerow_getter, self)
 #f row is _NO_ROW:
 #aise StopAsyncIteration()
 #lse:
 #eturn row

 #sync def first(self):
 #""Fetch the first row or None if no row is present.

 #loses the result set and discards remaining rows.

 #. note::  This method returns one **row**, e.g. tuple, by default. To
 #eturn exactly one single scalar value, that is, the first column of
 #he first row, use the :meth:`_asyncio.AsyncResult.scalar` method,
 #r combine :meth:`_asyncio.AsyncResult.scalars` and
 #meth:`_asyncio.AsyncResult.first`.

 #return: a :class:`.Row` object, or None
 #f no rows remain.

 #. seealso::

 #meth:`_asyncio.AsyncResult.scalar`

 #meth:`_asyncio.AsyncResult.one`

 #""
 #eturn await greenlet_spawn(self._only_one_row, False, False, False)

 #sync def one_or_none(self):
 #""Return at most one result or raise an exception.

 #eturns ``None`` if the result has no rows.
 #aises :class:`.MultipleResultsFound`
 #f multiple rows are returned.

 #. versionadded:: 1.4

 #return: The first :class:`.Row` or None if no row is available.

 #raises: :class:`.MultipleResultsFound`

 #. seealso::

 #meth:`_asyncio.AsyncResult.first`

 #meth:`_asyncio.AsyncResult.one`

 #""
 #eturn await greenlet_spawn(self._only_one_row, True, False, False)

 #sync def scalar_one(self):
 #""Return exactly one scalar result or raise an exception.

 #his is equivalent to calling :meth:`_asyncio.AsyncResult.scalars` and
 #hen :meth:`_asyncio.AsyncResult.one`.

 #. seealso::

 #meth:`_asyncio.AsyncResult.one`

 #meth:`_asyncio.AsyncResult.scalars`

 #""
 #eturn await greenlet_spawn(self._only_one_row, True, True, True)

 #sync def scalar_one_or_none(self):
 #""Return exactly one or no scalar result.

 #his is equivalent to calling :meth:`_asyncio.AsyncResult.scalars` and
 #hen :meth:`_asyncio.AsyncResult.one_or_none`.

 #. seealso::

 #meth:`_asyncio.AsyncResult.one_or_none`

 #meth:`_asyncio.AsyncResult.scalars`

 #""
 #eturn await greenlet_spawn(self._only_one_row, True, False, True)

 #sync def one(self):
 #""Return exactly one row or raise an exception.

 #aises :class:`.NoResultFound` if the result returns no
 #ows, or :class:`.MultipleResultsFound` if multiple rows
 #ould be returned.

 #. note::  This method returns one **row**, e.g. tuple, by default.
 #o return exactly one single scalar value, that is, the first
 #olumn of the first row, use the
 #meth:`_asyncio.AsyncResult.scalar_one` method, or combine
 #meth:`_asyncio.AsyncResult.scalars` and
 #meth:`_asyncio.AsyncResult.one`.

 #. versionadded:: 1.4

 #return: The first :class:`.Row`.

 #raises: :class:`.MultipleResultsFound`, :class:`.NoResultFound`

 #. seealso::

 #meth:`_asyncio.AsyncResult.first`

 #meth:`_asyncio.AsyncResult.one_or_none`

 #meth:`_asyncio.AsyncResult.scalar_one`

 #""
 #eturn await greenlet_spawn(self._only_one_row, True, True, False)

 #sync def scalar(self):
 #""Fetch the first column of the first row, and close the result set.

 #eturns None if there are no rows to fetch.

 #o validation is performed to test if additional rows remain.

 #fter calling this method, the object is fully closed,
 #.g. the :meth:`_engine.CursorResult.close`
 #ethod will have been called.

 #return: a Python scalar value , or None if no rows remain.

 #""
 #eturn await greenlet_spawn(self._only_one_row, False, False, True)

 #sync def freeze(self):
 #""Return a callable object that will produce copies of this
 #class:`_asyncio.AsyncResult` when invoked.

 #he callable object returned is an instance of
 #class:`_engine.FrozenResult`.

 #his is used for result set caching.  The method must be called
 #n the result when it has been unconsumed, and calling the method
 #ill consume the result fully.   When the :class:`_engine.FrozenResult`
 #s retrieved from a cache, it can be called any number of times where
 #t will produce a new :class:`_engine.Result` object each time
 #gainst its stored set of rows.

 #. seealso::

 #ref:`do_orm_execute_re_executing` - example usage within the
 #RM to implement a result-set cache.

 #""

 #eturn await greenlet_spawn(FrozenResult, self)

 #ef merge(self, *others):
 #""Merge this :class:`_asyncio.AsyncResult` with other compatible result
 #bjects.

 #he object returned is an instance of :class:`_engine.MergedResult`,
 #hich will be composed of iterators from the given result
 #bjects.

 #he new result will use the metadata from this result object.
 #he subsequent result objects must be against an identical
 #et of result / cursor metadata, otherwise the behavior is
 #ndefined.

 #""
 #eturn MergedResult(self._metadata, (self,) + others)

 #ef scalars(self, index=0):
 #""Return an :class:`_asyncio.AsyncScalarResult` filtering object which
 #ill return single elements rather than :class:`_row.Row` objects.

 #efer to :meth:`_result.Result.scalars` in the synchronous
 #QLAlchemy API for a complete behavioral description.

 #param index: integer or row key indicating the column to be fetched
 #rom each row, defaults to ``0`` indicating the first column.

 #return: a new :class:`_asyncio.AsyncScalarResult` filtering object
 #eferring to this :class:`_asyncio.AsyncResult` object.

 #""
 #eturn AsyncScalarResult(self._real_result, index)

 #ef mappings(self):
 #""Apply a mappings filter to returned rows, returning an instance of
 #class:`_asyncio.AsyncMappingResult`.

 #hen this filter is applied, fetching rows will return
 #class:`.RowMapping` objects instead of :class:`.Row` objects.

 #efer to :meth:`_result.Result.mappings` in the synchronous
 #QLAlchemy API for a complete behavioral description.

 #return: a new :class:`_asyncio.AsyncMappingResult` filtering object
 #eferring to the underlying :class:`_result.Result` object.

 #""

 #eturn AsyncMappingResult(self._real_result)


class AsyncScalarResult(AsyncCommon):
 #""A wrapper for a :class:`_asyncio.AsyncResult` that returns scalar values
 #ather than :class:`_row.Row` values.

 #he :class:`_asyncio.AsyncScalarResult` object is acquired by calling the
 #meth:`_asyncio.AsyncResult.scalars` method.

 #efer to the :class:`_result.ScalarResult` object in the synchronous
 #QLAlchemy API for a complete behavioral description.

 #. versionadded:: 1.4

 #""

 #generate_rows = False

 #ef __init__(self, real_result, index):
 #elf._real_result = real_result

 #f real_result._source_supports_scalars:
 #elf._metadata = real_result._metadata
 #elf._post_creational_filter = None
 #lse:
 #elf._metadata = real_result._metadata._reduce([index])
 #elf._post_creational_filter = operator.itemgetter(0)

 #elf._unique_filter_state = real_result._unique_filter_state

 #ef unique(self, strategy=None):
 #""Apply unique filtering to the objects returned by this
 #class:`_asyncio.AsyncScalarResult`.

 #ee :meth:`_asyncio.AsyncResult.unique` for usage details.

 #""
 #elf._unique_filter_state = (set(), strategy)
 #eturn self

 #sync def partitions(self, size=None):
 #""Iterate through sub-lists of elements of the size given.

 #quivalent to :meth:`_asyncio.AsyncResult.partitions` except that
 #calar values, rather than :class:`_result.Row` objects,
 #re returned.

 #""

 #etter = self._manyrow_getter

 #hile True:
 #artition = await greenlet_spawn(getter, self, size)
 #f partition:
 #ield partition
 #lse:
 #reak

 #sync def fetchall(self):
 #""A synonym for the :meth:`_asyncio.AsyncScalarResult.all` method."""

 #eturn await greenlet_spawn(self._allrows)

 #sync def fetchmany(self, size=None):
 #""Fetch many objects.

 #quivalent to :meth:`_asyncio.AsyncResult.fetchmany` except that
 #calar values, rather than :class:`_result.Row` objects,
 #re returned.

 #""
 #eturn await greenlet_spawn(self._manyrow_getter, self, size)

 #sync def all(self):
 #""Return all scalar values in a list.

 #quivalent to :meth:`_asyncio.AsyncResult.all` except that
 #calar values, rather than :class:`_result.Row` objects,
 #re returned.

 #""
 #eturn await greenlet_spawn(self._allrows)

 #ef __aiter__(self):
 #eturn self

 #sync def __anext__(self):
 #ow = await greenlet_spawn(self._onerow_getter, self)
 #f row is _NO_ROW:
 #aise StopAsyncIteration()
 #lse:
 #eturn row

 #sync def first(self):
 #""Fetch the first object or None if no object is present.

 #quivalent to :meth:`_asyncio.AsyncResult.first` except that
 #calar values, rather than :class:`_result.Row` objects,
 #re returned.

 #""
 #eturn await greenlet_spawn(self._only_one_row, False, False, False)

 #sync def one_or_none(self):
 #""Return at most one object or raise an exception.

 #quivalent to :meth:`_asyncio.AsyncResult.one_or_none` except that
 #calar values, rather than :class:`_result.Row` objects,
 #re returned.

 #""
 #eturn await greenlet_spawn(self._only_one_row, True, False, False)

 #sync def one(self):
 #""Return exactly one object or raise an exception.

 #quivalent to :meth:`_asyncio.AsyncResult.one` except that
 #calar values, rather than :class:`_result.Row` objects,
 #re returned.

 #""
 #eturn await greenlet_spawn(self._only_one_row, True, True, False)


class AsyncMappingResult(AsyncCommon):
 #""A wrapper for a :class:`_asyncio.AsyncResult` that returns dictionary values
 #ather than :class:`_engine.Row` values.

 #he :class:`_asyncio.AsyncMappingResult` object is acquired by calling the
 #meth:`_asyncio.AsyncResult.mappings` method.

 #efer to the :class:`_result.MappingResult` object in the synchronous
 #QLAlchemy API for a complete behavioral description.

 #. versionadded:: 1.4

 #""

 #generate_rows = True

 #post_creational_filter = operator.attrgetter("_mapping")

 #ef __init__(self, result):
 #elf._real_result = result
 #elf._unique_filter_state = result._unique_filter_state
 #elf._metadata = result._metadata
 #f result._source_supports_scalars:
 #elf._metadata = self._metadata._reduce([0])

 #ef keys(self):
 #""Return an iterable view which yields the string keys that would
 #e represented by each :class:`.Row`.

 #he view also can be tested for key containment using the Python
 #`in`` operator, which will test both for the string keys represented
 #n the view, as well as for alternate keys such as column objects.

 #. versionchanged:: 1.4 a key view object is returned rather than a
 #lain list.


 #""
 #eturn self._metadata.keys

 #ef unique(self, strategy=None):
 #""Apply unique filtering to the objects returned by this
 #class:`_asyncio.AsyncMappingResult`.

 #ee :meth:`_asyncio.AsyncResult.unique` for usage details.

 #""
 #elf._unique_filter_state = (set(), strategy)
 #eturn self

 #ef columns(self, *col_expressions):
 #"""Establish the columns that should be returned in each row."""
 #eturn self._column_slices(col_expressions)

 #sync def partitions(self, size=None):
 #""Iterate through sub-lists of elements of the size given.

 #quivalent to :meth:`_asyncio.AsyncResult.partitions` except that
 #apping values, rather than :class:`_result.Row` objects,
 #re returned.

 #""

 #etter = self._manyrow_getter

 #hile True:
 #artition = await greenlet_spawn(getter, self, size)
 #f partition:
 #ield partition
 #lse:
 #reak

 #sync def fetchall(self):
 #""A synonym for the :meth:`_asyncio.AsyncMappingResult.all` method."""

 #eturn await greenlet_spawn(self._allrows)

 #sync def fetchone(self):
 #""Fetch one object.

 #quivalent to :meth:`_asyncio.AsyncResult.fetchone` except that
 #apping values, rather than :class:`_result.Row` objects,
 #re returned.

 #""

 #ow = await greenlet_spawn(self._onerow_getter, self)
 #f row is _NO_ROW:
 #eturn None
 #lse:
 #eturn row

 #sync def fetchmany(self, size=None):
 #""Fetch many objects.

 #quivalent to :meth:`_asyncio.AsyncResult.fetchmany` except that
 #apping values, rather than :class:`_result.Row` objects,
 #re returned.

 #""

 #eturn await greenlet_spawn(self._manyrow_getter, self, size)

 #sync def all(self):
 #""Return all scalar values in a list.

 #quivalent to :meth:`_asyncio.AsyncResult.all` except that
 #apping values, rather than :class:`_result.Row` objects,
 #re returned.

 #""

 #eturn await greenlet_spawn(self._allrows)

 #ef __aiter__(self):
 #eturn self

 #sync def __anext__(self):
 #ow = await greenlet_spawn(self._onerow_getter, self)
 #f row is _NO_ROW:
 #aise StopAsyncIteration()
 #lse:
 #eturn row

 #sync def first(self):
 #""Fetch the first object or None if no object is present.

 #quivalent to :meth:`_asyncio.AsyncResult.first` except that
 #apping values, rather than :class:`_result.Row` objects,
 #re returned.


 #""
 #eturn await greenlet_spawn(self._only_one_row, False, False, False)

 #sync def one_or_none(self):
 #""Return at most one object or raise an exception.

 #quivalent to :meth:`_asyncio.AsyncResult.one_or_none` except that
 #apping values, rather than :class:`_result.Row` objects,
 #re returned.

 #""
 #eturn await greenlet_spawn(self._only_one_row, True, False, False)

 #sync def one(self):
 #""Return exactly one object or raise an exception.

 #quivalent to :meth:`_asyncio.AsyncResult.one` except that
 #apping values, rather than :class:`_result.Row` objects,
 #re returned.

 #""
 #eturn await greenlet_spawn(self._only_one_row, True, True, False)
