# ext/asyncio/engine.py
# Copyright (C) 2020-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
from . import exc as async_exc
from .base import ProxyComparable
from .base import StartableContext
from .result import AsyncResult
from ... import exc
from ... import util
from ...engine import create_engine as _create_engine
from ...engine.base import NestedTransaction
from ...future import Connection
from ...future import Engine
from ...util.concurrency import greenlet_spawn


def create_async_engine(*arg, **kw):
 #""Create a new async engine instance.

 #rguments passed to :func:`_asyncio.create_async_engine` are mostly
 #dentical to those passed to the :func:`_sa.create_engine` function.
 #he specified dialect must be an asyncio-compatible dialect
 #uch as :ref:`dialect-postgresql-asyncpg`.

 #. versionadded:: 1.4

 #""

 #f kw.get("server_side_cursors", False):
 #aise async_exc.AsyncMethodRequired(
 #Can't set server_side_cursors for async engine globally; "
 #use the connection.stream() method for an async "
 #streaming result set"
 #
 #w["future"] = True
 #ync_engine = _create_engine(*arg, **kw)
 #eturn AsyncEngine(sync_engine)


class AsyncConnectable:
 #_slots__ = "_slots_dispatch", "__weakref__"


@util.create_proxy_methods(
 #onnection,
 #:class:`_future.Connection`",
 #:class:`_asyncio.AsyncConnection`",
 #lassmethods=[],
 #ethods=[],
 #ttributes=[
 #closed",
 #invalidated",
 #dialect",
 #default_isolation_level",
 #,
)
class AsyncConnection(ProxyComparable, StartableContext, AsyncConnectable):
 #""An asyncio proxy for a :class:`_engine.Connection`.

 #class:`_asyncio.AsyncConnection` is acquired using the
 #meth:`_asyncio.AsyncEngine.connect`
 #ethod of :class:`_asyncio.AsyncEngine`::

 #rom sqlalchemy.ext.asyncio import create_async_engine
 #ngine = create_async_engine("postgresql+asyncpg://user:pass@host/dbname")

 #sync with engine.connect() as conn:
 #esult = await conn.execute(select(table))

 #. versionadded:: 1.4

 #""  # noqa

    # AsyncConnection is a thin proxy; no state should be added here
    # that is not retrievable from the "sync" engine / connection, e.g.
    # current transaction, info, etc.   It should be possible to
    # create a new AsyncConnection that matches this one given only the
    # "sync" elements.
 #_slots__ = (
 #sync_engine",
 #sync_connection",
 #

 #ef __init__(self, async_engine, sync_connection=None):
 #elf.engine = async_engine
 #elf.sync_engine = async_engine.sync_engine
 #elf.sync_connection = self._assign_proxied(sync_connection)

 #classmethod
 #ef _regenerate_proxy_for_target(cls, target):
 #eturn AsyncConnection(
 #syncEngine._retrieve_proxy_for_target(target.engine), target
 #

 #sync def start(self, is_ctxmanager=False):
 #""Start this :class:`_asyncio.AsyncConnection` object's context
 #utside of using a Python ``with:`` block.

 #""
 #f self.sync_connection:
 #aise exc.InvalidRequestError("connection is already started")
 #elf.sync_connection = self._assign_proxied(
 #wait (greenlet_spawn(self.sync_engine.connect))
 #
 #eturn self

 #property
 #ef connection(self):
 #""Not implemented for async; call
 #meth:`_asyncio.AsyncConnection.get_raw_connection`.

 #""
 #aise exc.InvalidRequestError(
 #AsyncConnection.connection accessor is not implemented as the "
 #attribute may need to reconnect on an invalidated connection.  "
 #Use the get_raw_connection() method."
 #

 #sync def get_raw_connection(self):
 #""Return the pooled DBAPI-level connection in use by this
 #class:`_asyncio.AsyncConnection`.

 #his is typically the SQLAlchemy connection-pool proxied connection
 #hich then has an attribute .connection that refers to the actual
 #BAPI-level connection.
 #""
 #onn = self._sync_connection()

 #eturn await greenlet_spawn(getattr, conn, "connection")

 #property
 #ef _proxied(self):
 #eturn self.sync_connection

 #property
 #ef info(self):
 #""Return the :attr:`_engine.Connection.info` dictionary of the
 #nderlying :class:`_engine.Connection`.

 #his dictionary is freely writable for user-defined state to be
 #ssociated with the database connection.

 #his attribute is only available if the :class:`.AsyncConnection` is
 #urrently connected.   If the :attr:`.AsyncConnection.closed` attribute
 #s ``True``, then accessing this attribute will raise
 #class:`.ResourceClosedError`.

 #. versionadded:: 1.4.0b2

 #""
 #eturn self.sync_connection.info

 #ef _sync_connection(self):
 #f not self.sync_connection:
 #elf._raise_for_not_started()
 #eturn self.sync_connection

 #ef begin(self):
 #""Begin a transaction prior to autobegin occurring."""
 #elf._sync_connection()
 #eturn AsyncTransaction(self)

 #ef begin_nested(self):
 #""Begin a nested transaction and return a transaction handle."""
 #elf._sync_connection()
 #eturn AsyncTransaction(self, nested=True)

 #sync def invalidate(self, exception=None):
 #""Invalidate the underlying DBAPI connection associated with
 #his :class:`_engine.Connection`.

 #ee the method :meth:`_engine.Connection.invalidate` for full
 #etail on this method.

 #""

 #onn = self._sync_connection()
 #eturn await greenlet_spawn(conn.invalidate, exception=exception)

 #sync def get_isolation_level(self):
 #onn = self._sync_connection()
 #eturn await greenlet_spawn(conn.get_isolation_level)

 #sync def set_isolation_level(self):
 #onn = self._sync_connection()
 #eturn await greenlet_spawn(conn.get_isolation_level)

 #ef in_transaction(self):
 #""Return True if a transaction is in progress.

 #. versionadded:: 1.4.0b2

 #""

 #onn = self._sync_connection()

 #eturn conn.in_transaction()

 #ef in_nested_transaction(self):
 #""Return True if a transaction is in progress.

 #. versionadded:: 1.4.0b2

 #""
 #onn = self._sync_connection()

 #eturn conn.in_nested_transaction()

 #ef get_transaction(self):
 #""Return an :class:`.AsyncTransaction` representing the current
 #ransaction, if any.

 #his makes use of the underlying synchronous connection's
 #meth:`_engine.Connection.get_transaction` method to get the current
 #class:`_engine.Transaction`, which is then proxied in a new
 #class:`.AsyncTransaction` object.

 #. versionadded:: 1.4.0b2

 #""
 #onn = self._sync_connection()

 #rans = conn.get_transaction()
 #f trans is not None:
 #eturn AsyncTransaction._retrieve_proxy_for_target(trans)
 #lse:
 #eturn None

 #ef get_nested_transaction(self):
 #""Return an :class:`.AsyncTransaction` representing the current
 #ested (savepoint) transaction, if any.

 #his makes use of the underlying synchronous connection's
 #meth:`_engine.Connection.get_nested_transaction` method to get the
 #urrent :class:`_engine.Transaction`, which is then proxied in a new
 #class:`.AsyncTransaction` object.

 #. versionadded:: 1.4.0b2

 #""
 #onn = self._sync_connection()

 #rans = conn.get_nested_transaction()
 #f trans is not None:
 #eturn AsyncTransaction._retrieve_proxy_for_target(trans)
 #lse:
 #eturn None

 #sync def execution_options(self, **opt):
 #"""Set non-SQL options for the connection which take effect
 #uring execution.

 #his returns this :class:`_asyncio.AsyncConnection` object with
 #he new options added.

 #ee :meth:`_future.Connection.execution_options` for full details
 #n this method.

 #""

 #onn = self._sync_connection()
 #2 = await greenlet_spawn(conn.execution_options, **opt)
 #ssert c2 is conn
 #eturn self

 #sync def commit(self):
 #""Commit the transaction that is currently in progress.

 #his method commits the current transaction if one has been started.
 #f no transaction was started, the method has no effect, assuming
 #he connection is in a non-invalidated state.

 # transaction is begun on a :class:`_future.Connection` automatically
 #henever a statement is first executed, or when the
 #meth:`_future.Connection.begin` method is called.

 #""
 #onn = self._sync_connection()
 #wait greenlet_spawn(conn.commit)

 #sync def rollback(self):
 #""Roll back the transaction that is currently in progress.

 #his method rolls back the current transaction if one has been started.
 #f no transaction was started, the method has no effect.  If a
 #ransaction was started and the connection is in an invalidated state,
 #he transaction is cleared using this method.

 # transaction is begun on a :class:`_future.Connection` automatically
 #henever a statement is first executed, or when the
 #meth:`_future.Connection.begin` method is called.


 #""
 #onn = self._sync_connection()
 #wait greenlet_spawn(conn.rollback)

 #sync def close(self):
 #""Close this :class:`_asyncio.AsyncConnection`.

 #his has the effect of also rolling back the transaction if one
 #s in place.

 #""
 #onn = self._sync_connection()
 #wait greenlet_spawn(conn.close)

 #sync def exec_driver_sql(
 #elf,
 #tatement,
 #arameters=None,
 #xecution_options=util.EMPTY_DICT,
 #:
 #"""Executes a driver-level SQL string and return buffered
 #class:`_engine.Result`.

 #""

 #onn = self._sync_connection()

 #esult = await greenlet_spawn(
 #onn.exec_driver_sql,
 #tatement,
 #arameters,
 #xecution_options,
 #require_await=True,
 #
 #f result.context._is_server_side:
 #aise async_exc.AsyncMethodRequired(
 #Can't use the connection.exec_driver_sql() method with a "
 #server-side cursor."
 #Use the connection.stream() method for an async "
 #streaming result set."
 #

 #eturn result

 #sync def stream(
 #elf,
 #tatement,
 #arameters=None,
 #xecution_options=util.EMPTY_DICT,
 #:
 #""Execute a statement and return a streaming
 #class:`_asyncio.AsyncResult` object."""

 #onn = self._sync_connection()

 #esult = await greenlet_spawn(
 #onn._execute_20,
 #tatement,
 #arameters,
 #til.EMPTY_DICT.merge_with(
 #xecution_options, {"stream_results": True}
 #,
 #require_await=True,
 #
 #f not result.context._is_server_side:
            # TODO: real exception here
 #ssert False, "server side result expected"
 #eturn AsyncResult(result)

 #sync def execute(
 #elf,
 #tatement,
 #arameters=None,
 #xecution_options=util.EMPTY_DICT,
 #:
 #"""Executes a SQL statement construct and return a buffered
 #class:`_engine.Result`.

 #param object: The statement to be executed.  This is always
 #n object that is in both the :class:`_expression.ClauseElement` and
 #class:`_expression.Executable` hierarchies, including:

 # :class:`_expression.Select`
 # :class:`_expression.Insert`, :class:`_expression.Update`,
 #class:`_expression.Delete`
 # :class:`_expression.TextClause` and
 #class:`_expression.TextualSelect`
 # :class:`_schema.DDL` and objects which inherit from
 #class:`_schema.DDLElement`

 #param parameters: parameters which will be bound into the statement.
 #his may be either a dictionary of parameter names to values,
 #r a mutable sequence (e.g. a list) of dictionaries.  When a
 #ist of dictionaries is passed, the underlying statement execution
 #ill make use of the DBAPI ``cursor.executemany()`` method.
 #hen a single dictionary is passed, the DBAPI ``cursor.execute()``
 #ethod will be used.

 #param execution_options: optional dictionary of execution options,
 #hich will be associated with the statement execution.  This
 #ictionary can provide a subset of the options that are accepted
 #y :meth:`_future.Connection.execution_options`.

 #return: a :class:`_engine.Result` object.

 #""
 #onn = self._sync_connection()

 #esult = await greenlet_spawn(
 #onn._execute_20,
 #tatement,
 #arameters,
 #xecution_options,
 #require_await=True,
 #
 #f result.context._is_server_side:
 #aise async_exc.AsyncMethodRequired(
 #Can't use the connection.execute() method with a "
 #server-side cursor."
 #Use the connection.stream() method for an async "
 #streaming result set."
 #
 #eturn result

 #sync def scalar(
 #elf,
 #tatement,
 #arameters=None,
 #xecution_options=util.EMPTY_DICT,
 #:
 #"""Executes a SQL statement construct and returns a scalar object.

 #his method is shorthand for invoking the
 #meth:`_engine.Result.scalar` method after invoking the
 #meth:`_future.Connection.execute` method.  Parameters are equivalent.

 #return: a scalar Python value representing the first column of the
 #irst row returned.

 #""
 #esult = await self.execute(statement, parameters, execution_options)
 #eturn result.scalar()

 #sync def run_sync(self, fn, *arg, **kw):
 #""Invoke the given sync callable passing self as the first argument.

 #his method maintains the asyncio event loop all the way through
 #o the database connection by running the given callable in a
 #pecially instrumented greenlet.

 #.g.::

 #ith async_engine.begin() as conn:
 #wait conn.run_sync(metadata.create_all)

 #. note::

 #he provided callable is invoked inline within the asyncio event
 #oop, and will block on traditional IO calls.  IO within this
 #allable should only call into SQLAlchemy's asyncio database
 #PIs which will be properly adapted to the greenlet context.

 #. seealso::

 #ref:`session_run_sync`
 #""

 #onn = self._sync_connection()

 #eturn await greenlet_spawn(fn, conn, *arg, **kw)

 #ef __await__(self):
 #eturn self.start().__await__()

 #sync def __aexit__(self, type_, value, traceback):
 #wait self.close()


@util.create_proxy_methods(
 #ngine,
 #:class:`_future.Engine`",
 #:class:`_asyncio.AsyncEngine`",
 #lassmethods=[],
 #ethods=[
 #clear_compiled_cache",
 #update_execution_options",
 #get_execution_options",
 #,
 #ttributes=["url", "pool", "dialect", "engine", "name", "driver", "echo"],
)
class AsyncEngine(ProxyComparable, AsyncConnectable):
 #""An asyncio proxy for a :class:`_engine.Engine`.

 #class:`_asyncio.AsyncEngine` is acquired using the
 #func:`_asyncio.create_async_engine` function::

 #rom sqlalchemy.ext.asyncio import create_async_engine
 #ngine = create_async_engine("postgresql+asyncpg://user:pass@host/dbname")

 #. versionadded:: 1.4

 #""  # noqa

    # AsyncEngine is a thin proxy; no state should be added here
    # that is not retrievable from the "sync" engine / connection, e.g.
    # current transaction, info, etc.   It should be possible to
    # create a new AsyncEngine that matches this one given only the
    # "sync" elements.
 #_slots__ = ("sync_engine", "_proxied")

 #connection_cls = AsyncConnection

 #option_cls: type

 #lass _trans_ctx(StartableContext):
 #ef __init__(self, conn):
 #elf.conn = conn

 #sync def start(self, is_ctxmanager=False):
 #wait self.conn.start(is_ctxmanager=is_ctxmanager)
 #elf.transaction = self.conn.begin()
 #wait self.transaction.__aenter__()

 #eturn self.conn

 #sync def __aexit__(self, type_, value, traceback):
 #wait self.transaction.__aexit__(type_, value, traceback)
 #wait self.conn.close()

 #ef __init__(self, sync_engine):
 #f not sync_engine.dialect.is_async:
 #aise exc.InvalidRequestError(
 #The asyncio extension requires an async driver to be used. "
 #"The loaded {sync_engine.dialect.driver!r} is not async."
 #
 #elf.sync_engine = self._proxied = self._assign_proxied(sync_engine)

 #classmethod
 #ef _regenerate_proxy_for_target(cls, target):
 #eturn AsyncEngine(target)

 #ef begin(self):
 #""Return a context manager which when entered will deliver an
 #class:`_asyncio.AsyncConnection` with an
 #class:`_asyncio.AsyncTransaction` established.

 #.g.::

 #sync with async_engine.begin() as conn:
 #wait conn.execute(
 #ext("insert into table (x, y, z) values (1, 2, 3)")
 #
 #wait conn.execute(text("my_special_procedure(5)"))


 #""
 #onn = self.connect()
 #eturn self._trans_ctx(conn)

 #ef connect(self):
 #""Return an :class:`_asyncio.AsyncConnection` object.

 #he :class:`_asyncio.AsyncConnection` will procure a database
 #onnection from the underlying connection pool when it is entered
 #s an async context manager::

 #sync with async_engine.connect() as conn:
 #esult = await conn.execute(select(user_table))

 #he :class:`_asyncio.AsyncConnection` may also be started outside of a
 #ontext manager by invoking its :meth:`_asyncio.AsyncConnection.start`
 #ethod.

 #""

 #eturn self._connection_cls(self)

 #sync def raw_connection(self):
 #""Return a "raw" DBAPI connection from the connection pool.

 #. seealso::

 #ref:`dbapi_connections`

 #""
 #eturn await greenlet_spawn(self.sync_engine.raw_connection)

 #ef execution_options(self, **opt):
 #""Return a new :class:`_asyncio.AsyncEngine` that will provide
 #class:`_asyncio.AsyncConnection` objects with the given execution
 #ptions.

 #roxied from :meth:`_future.Engine.execution_options`.  See that
 #ethod for details.

 #""

 #eturn AsyncEngine(self.sync_engine.execution_options(**opt))

 #sync def dispose(self):
 #""Dispose of the connection pool used by this
 #class:`_asyncio.AsyncEngine`.

 #his will close all connection pool connections that are
 #*currently checked in**.  See the documentation for the underlying
 #meth:`_future.Engine.dispose` method for further notes.

 #. seealso::

 #meth:`_future.Engine.dispose`

 #""

 #eturn await greenlet_spawn(self.sync_engine.dispose)


class AsyncTransaction(ProxyComparable, StartableContext):
 #""An asyncio proxy for a :class:`_engine.Transaction`."""

 #_slots__ = ("connection", "sync_transaction", "nested")

 #ef __init__(self, connection, nested=False):
 #elf.connection = connection  # AsyncConnection
 #elf.sync_transaction = None  # sqlalchemy.engine.Transaction
 #elf.nested = nested

 #classmethod
 #ef _regenerate_proxy_for_target(cls, target):
 #ync_connection = target.connection
 #ync_transaction = target
 #ested = isinstance(target, NestedTransaction)

 #sync_connection = AsyncConnection._retrieve_proxy_for_target(
 #ync_connection
 #
 #ssert async_connection is not None

 #bj = cls.__new__(cls)
 #bj.connection = async_connection
 #bj.sync_transaction = obj._assign_proxied(sync_transaction)
 #bj.nested = nested
 #eturn obj

 #ef _sync_transaction(self):
 #f not self.sync_transaction:
 #elf._raise_for_not_started()
 #eturn self.sync_transaction

 #property
 #ef _proxied(self):
 #eturn self.sync_transaction

 #property
 #ef is_valid(self):
 #eturn self._sync_transaction().is_valid

 #property
 #ef is_active(self):
 #eturn self._sync_transaction().is_active

 #sync def close(self):
 #""Close this :class:`.Transaction`.

 #f this transaction is the base transaction in a begin/commit
 #esting, the transaction will rollback().  Otherwise, the
 #ethod returns.

 #his is used to cancel a Transaction without affecting the scope of
 #n enclosing transaction.

 #""
 #wait greenlet_spawn(self._sync_transaction().close)

 #sync def rollback(self):
 #""Roll back this :class:`.Transaction`."""
 #wait greenlet_spawn(self._sync_transaction().rollback)

 #sync def commit(self):
 #""Commit this :class:`.Transaction`."""

 #wait greenlet_spawn(self._sync_transaction().commit)

 #sync def start(self, is_ctxmanager=False):
 #""Start this :class:`_asyncio.AsyncTransaction` object's context
 #utside of using a Python ``with:`` block.

 #""

 #elf.sync_transaction = self._assign_proxied(
 #wait greenlet_spawn(
 #elf.connection._sync_connection().begin_nested
 #f self.nested
 #lse self.connection._sync_connection().begin
 #
 #
 #f is_ctxmanager:
 #elf.sync_transaction.__enter__()
 #eturn self

 #sync def __aexit__(self, type_, value, traceback):
 #wait greenlet_spawn(
 #elf._sync_transaction().__exit__, type_, value, traceback
 #


def _get_sync_engine_or_connection(async_engine):
 #f isinstance(async_engine, AsyncConnection):
 #eturn async_engine.sync_connection

 #ry:
 #eturn async_engine.sync_engine
 #xcept AttributeError as e:
 #aise exc.ArgumentError(
 #AsyncEngine expected, got %r" % async_engine
 # from e
