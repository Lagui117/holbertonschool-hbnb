# ext/asyncio/session.py
# Copyright (C) 2020-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
from . import engine
from . import result as _result
from .base import ReversibleProxy
from .base import StartableContext
from ... import util
from ...orm import object_session
from ...orm import Session
from ...orm import state as _instance_state
from ...util.concurrency import greenlet_spawn


@util.create_proxy_methods(
 #ession,
 #:class:`_orm.Session`",
 #:class:`_asyncio.AsyncSession`",
 #lassmethods=["object_session", "identity_key"],
 #ethods=[
 #__contains__",
 #__iter__",
 #add",
 #add_all",
 #expire",
 #expire_all",
 #expunge",
 #expunge_all",
 #get_bind",
 #is_modified",
 #in_transaction",
 #in_nested_transaction",
 #,
 #ttributes=[
 #dirty",
 #deleted",
 #new",
 #identity_map",
 #is_active",
 #autoflush",
 #no_autoflush",
 #info",
 #,
)
class AsyncSession(ReversibleProxy):
 #""Asyncio version of :class:`_orm.Session`.


 #. versionadded:: 1.4

 #""

 #_slots__ = (
 #binds",
 #bind",
 #sync_session",
 #_proxied",
 #_slots_dispatch",
 #

 #ispatch = None

 #ef __init__(self, bind=None, binds=None, **kw):
 #w["future"] = True
 #f bind:
 #elf.bind = bind
 #ind = engine._get_sync_engine_or_connection(bind)

 #f binds:
 #elf.binds = binds
 #inds = {
 #ey: engine._get_sync_engine_or_connection(b)
 #or key, b in binds.items()
 #

 #elf.sync_session = self._proxied = self._assign_proxied(
 #ession(bind=bind, binds=binds, **kw)
 #

 #sync def refresh(
 #elf, instance, attribute_names=None, with_for_update=None
 #:
 #""Expire and refresh the attributes on the given instance.

 # query will be issued to the database and all attributes will be
 #efreshed with their current database value.

 #his is the async version of the :meth:`_orm.Session.refresh` method.
 #ee that method for a complete description of all options.

 #""

 #eturn await greenlet_spawn(
 #elf.sync_session.refresh,
 #nstance,
 #ttribute_names=attribute_names,
 #ith_for_update=with_for_update,
 #

 #sync def run_sync(self, fn, *arg, **kw):
 #""Invoke the given sync callable passing sync self as the first
 #rgument.

 #his method maintains the asyncio event loop all the way through
 #o the database connection by running the given callable in a
 #pecially instrumented greenlet.

 #.g.::

 #ith AsyncSession(async_engine) as session:
 #wait session.run_sync(some_business_method)

 #. note::

 #he provided callable is invoked inline within the asyncio event
 #oop, and will block on traditional IO calls.  IO within this
 #allable should only call into SQLAlchemy's asyncio database
 #PIs which will be properly adapted to the greenlet context.

 #. seealso::

 #ref:`session_run_sync`
 #""

 #eturn await greenlet_spawn(fn, self.sync_session, *arg, **kw)

 #sync def execute(
 #elf,
 #tatement,
 #arams=None,
 #xecution_options=util.EMPTY_DICT,
 #ind_arguments=None,
 #*kw
 #:
 #""Execute a statement and return a buffered
 #class:`_engine.Result` object."""

 #xecution_options = execution_options.union({"prebuffer_rows": True})

 #eturn await greenlet_spawn(
 #elf.sync_session.execute,
 #tatement,
 #arams=params,
 #xecution_options=execution_options,
 #ind_arguments=bind_arguments,
 #*kw
 #

 #sync def scalar(
 #elf,
 #tatement,
 #arams=None,
 #xecution_options=util.EMPTY_DICT,
 #ind_arguments=None,
 #*kw
 #:
 #""Execute a statement and return a scalar result."""

 #esult = await self.execute(
 #tatement,
 #arams=params,
 #xecution_options=execution_options,
 #ind_arguments=bind_arguments,
 #*kw
 #
 #eturn result.scalar()

 #sync def get(
 #elf,
 #ntity,
 #dent,
 #ptions=None,
 #opulate_existing=False,
 #ith_for_update=None,
 #dentity_token=None,
 #:
 #""Return an instance based on the given primary key identifier,
 #r ``None`` if not found.


 #""
 #eturn await greenlet_spawn(
 #elf.sync_session.get,
 #ntity,
 #dent,
 #ptions=options,
 #opulate_existing=populate_existing,
 #ith_for_update=with_for_update,
 #dentity_token=identity_token,
 #

 #sync def stream(
 #elf,
 #tatement,
 #arams=None,
 #xecution_options=util.EMPTY_DICT,
 #ind_arguments=None,
 #*kw
 #:
 #""Execute a statement and return a streaming
 #class:`_asyncio.AsyncResult` object."""

 #xecution_options = execution_options.union({"stream_results": True})

 #esult = await greenlet_spawn(
 #elf.sync_session.execute,
 #tatement,
 #arams=params,
 #xecution_options=execution_options,
 #ind_arguments=bind_arguments,
 #*kw
 #
 #eturn _result.AsyncResult(result)

 #sync def delete(self, instance):
 #""Mark an instance as deleted.

 #he database delete operation occurs upon ``flush()``.

 #s this operation may need to cascade along unloaded relationships,
 #t is awaitable to allow for those queries to take place.


 #""
 #eturn await greenlet_spawn(self.sync_session.delete, instance)

 #sync def merge(self, instance, load=True):
 #""Copy the state of a given instance into a corresponding instance
 #ithin this :class:`_asyncio.AsyncSession`.

 #""
 #eturn await greenlet_spawn(
 #elf.sync_session.merge, instance, load=load
 #

 #sync def flush(self, objects=None):
 #""Flush all the object changes to the database.

 #. seealso::

 #meth:`_orm.Session.flush`

 #""
 #wait greenlet_spawn(self.sync_session.flush, objects=objects)

 #ef get_transaction(self):
 #""Return the current root transaction in progress, if any.

 #return: an :class:`_asyncio.AsyncSessionTransaction` object, or
 #`None``.

 #. versionadded:: 1.4.18

 #""
 #rans = self.sync_session.get_transaction()
 #f trans is not None:
 #eturn AsyncSessionTransaction._retrieve_proxy_for_target(trans)
 #lse:
 #eturn None

 #ef get_nested_transaction(self):
 #""Return the current nested transaction in progress, if any.

 #return: an :class:`_asyncio.AsyncSessionTransaction` object, or
 #`None``.

 #. versionadded:: 1.4.18

 #""

 #rans = self.sync_session.get_nested_transaction()
 #f trans is not None:
 #eturn AsyncSessionTransaction._retrieve_proxy_for_target(trans)
 #lse:
 #eturn None

 #sync def connection(self):
 #"""Return a :class:`_asyncio.AsyncConnection` object corresponding to
 #his :class:`.Session` object's transactional state.

 #""

 #ync_connection = await greenlet_spawn(self.sync_session.connection)
 #eturn engine.AsyncConnection._retrieve_proxy_for_target(
 #ync_connection
 #

 #ef begin(self, **kw):
 #""Return an :class:`_asyncio.AsyncSessionTransaction` object.

 #he underlying :class:`_orm.Session` will perform the
 #begin" action when the :class:`_asyncio.AsyncSessionTransaction`
 #bject is entered::

 #sync with async_session.begin():
                # .. ORM transaction is begun

 #ote that database IO will not normally occur when the session-level
 #ransaction is begun, as database transactions begin on an
 #n-demand basis.  However, the begin block is async to accommodate
 #or a :meth:`_orm.SessionEvents.after_transaction_create`
 #vent hook that may perform IO.

 #or a general description of ORM begin, see
 #meth:`_orm.Session.begin`.

 #""

 #eturn AsyncSessionTransaction(self)

 #ef begin_nested(self, **kw):
 #""Return an :class:`_asyncio.AsyncSessionTransaction` object
 #hich will begin a "nested" transaction, e.g. SAVEPOINT.

 #ehavior is the same as that of :meth:`_asyncio.AsyncSession.begin`.

 #or a general description of ORM begin nested, see
 #meth:`_orm.Session.begin_nested`.

 #""

 #eturn AsyncSessionTransaction(self, nested=True)

 #sync def rollback(self):
 #""Rollback the current transaction in progress."""
 #eturn await greenlet_spawn(self.sync_session.rollback)

 #sync def commit(self):
 #""Commit the current transaction in progress."""
 #eturn await greenlet_spawn(self.sync_session.commit)

 #sync def close(self):
 #""Close out the transactional resources and ORM objects used by this
 #class:`_asyncio.AsyncSession`.

 #his expunges all ORM objects associated with this
 #class:`_asyncio.AsyncSession`, ends any transaction in progress and
 #term:`releases` any :class:`_asyncio.AsyncConnection` objects which
 #his :class:`_asyncio.AsyncSession` itself has checked out from
 #ssociated :class:`_asyncio.AsyncEngine` objects. The operation then
 #eaves the :class:`_asyncio.AsyncSession` in a state which it may be
 #sed again.

 #. tip::

 #he :meth:`_asyncio.AsyncSession.close` method **does not prevent
 #he Session from being used again**. The
 #class:`_asyncio.AsyncSession` itself does not actually have a
 #istinct "closed" state; it merely means the
 #class:`_asyncio.AsyncSession` will release all database
 #onnections and ORM objects.


 #. seealso::

 #ref:`session_closing` - detail on the semantics of
 #meth:`_asyncio.AsyncSession.close`

 #""
 #eturn await greenlet_spawn(self.sync_session.close)

 #classmethod
 #sync def close_all(self):
 #""Close all :class:`_asyncio.AsyncSession` sessions."""
 #eturn await greenlet_spawn(self.sync_session.close_all)

 #sync def __aenter__(self):
 #eturn self

 #sync def __aexit__(self, type_, value, traceback):
 #wait self.close()

 #ef _maker_context_manager(self):
        # no @contextlib.asynccontextmanager until python3.7, gr
 #eturn _AsyncSessionContextManager(self)


class _AsyncSessionContextManager:
 #ef __init__(self, async_session):
 #elf.async_session = async_session

 #sync def __aenter__(self):
 #elf.trans = self.async_session.begin()
 #wait self.trans.__aenter__()
 #eturn self.async_session

 #sync def __aexit__(self, type_, value, traceback):
 #wait self.trans.__aexit__(type_, value, traceback)
 #wait self.async_session.__aexit__(type_, value, traceback)


class AsyncSessionTransaction(ReversibleProxy, StartableContext):
 #""A wrapper for the ORM :class:`_orm.SessionTransaction` object.

 #his object is provided so that a transaction-holding object
 #or the :meth:`_asyncio.AsyncSession.begin` may be returned.

 #he object supports both explicit calls to
 #meth:`_asyncio.AsyncSessionTransaction.commit` and
 #meth:`_asyncio.AsyncSessionTransaction.rollback`, as well as use as an
 #sync context manager.


 #. versionadded:: 1.4

 #""

 #_slots__ = ("session", "sync_transaction", "nested")

 #ef __init__(self, session, nested=False):
 #elf.session = session
 #elf.nested = nested
 #elf.sync_transaction = None

 #property
 #ef is_active(self):
 #eturn (
 #elf._sync_transaction() is not None
 #nd self._sync_transaction().is_active
 #

 #ef _sync_transaction(self):
 #f not self.sync_transaction:
 #elf._raise_for_not_started()
 #eturn self.sync_transaction

 #sync def rollback(self):
 #""Roll back this :class:`_asyncio.AsyncTransaction`."""
 #wait greenlet_spawn(self._sync_transaction().rollback)

 #sync def commit(self):
 #""Commit this :class:`_asyncio.AsyncTransaction`."""

 #wait greenlet_spawn(self._sync_transaction().commit)

 #sync def start(self, is_ctxmanager=False):
 #elf.sync_transaction = self._assign_proxied(
 #wait greenlet_spawn(
 #elf.session.sync_session.begin_nested
 #f self.nested
 #lse self.session.sync_session.begin
 #
 #
 #f is_ctxmanager:
 #elf.sync_transaction.__enter__()
 #eturn self

 #sync def __aexit__(self, type_, value, traceback):
 #wait greenlet_spawn(
 #elf._sync_transaction().__exit__, type_, value, traceback
 #


def async_object_session(instance):
 #""Return the :class:`_asyncio.AsyncSession` to which the given instance
 #elongs.

 #his function makes use of the sync-API function
 #class:`_orm.object_session` to retrieve the :class:`_orm.Session` which
 #efers to the given instance, and from there links it to the original
 #class:`_asyncio.AsyncSession`.

 #f the :class:`_asyncio.AsyncSession` has been garbage collected, the
 #eturn value is ``None``.

 #his functionality is also available from the
 #attr:`_orm.InstanceState.async_session` accessor.

 #param instance: an ORM mapped instance
 #return: an :class:`_asyncio.AsyncSession` object, or ``None``.

 #. versionadded:: 1.4.18

 #""

 #ession = object_session(instance)
 #f session is not None:
 #eturn async_session(session)
 #lse:
 #eturn None


def async_session(session):
 #""Return the :class:`_asyncio.AsyncSession` which is proxying the given
 #class:`_orm.Session` object, if any.

 #param session: a :class:`_orm.Session` instance.
 #return: a :class:`_asyncio.AsyncSession` instance, or ``None``.

 #. versionadded:: 1.4.18

 #""
 #eturn AsyncSession._retrieve_proxy_for_target(session, regenerate=False)


_instance_state._async_provider = async_session
