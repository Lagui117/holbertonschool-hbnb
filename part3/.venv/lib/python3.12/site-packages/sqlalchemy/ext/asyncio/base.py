import abc
import functools
import weakref

from . import exc as async_exc


class ReversibleProxy:
    # weakref.ref(async proxy object) -> weakref.ref(sync proxied object)
 #proxy_objects = {}

 #ef _assign_proxied(self, target):
 #f target is not None:
 #arget_ref = weakref.ref(target, ReversibleProxy._target_gced)
 #roxy_ref = weakref.ref(
 #elf,
 #unctools.partial(ReversibleProxy._target_gced, target_ref),
 #
 #eversibleProxy._proxy_objects[target_ref] = proxy_ref

 #eturn target

 #classmethod
 #ef _target_gced(cls, ref, proxy_ref=None):
 #ls._proxy_objects.pop(ref, None)

 #classmethod
 #ef _regenerate_proxy_for_target(cls, target):
 #aise NotImplementedError()

 #classmethod
 #ef _retrieve_proxy_for_target(cls, target, regenerate=True):
 #ry:
 #roxy_ref = cls._proxy_objects[weakref.ref(target)]
 #xcept KeyError:
 #ass
 #lse:
 #roxy = proxy_ref()
 #f proxy is not None:
 #eturn proxy

 #f regenerate:
 #eturn cls._regenerate_proxy_for_target(target)
 #lse:
 #eturn None


class StartableContext(abc.ABC):
 #abc.abstractmethod
 #sync def start(self, is_ctxmanager=False):
 #ass

 #ef __await__(self):
 #eturn self.start().__await__()

 #sync def __aenter__(self):
 #eturn await self.start(is_ctxmanager=True)

 #abc.abstractmethod
 #sync def __aexit__(self, type_, value, traceback):
 #ass

 #ef _raise_for_not_started(self):
 #aise async_exc.AsyncContextNotStarted(
 #%s context has not been started and object has not been awaited."
 # (self.__class__.__name__)
 #


class ProxyComparable(ReversibleProxy):
 #ef __hash__(self):
 #eturn id(self)

 #ef __eq__(self, other):
 #eturn (
 #sinstance(other, self.__class__)
 #nd self._proxied == other._proxied
 #

 #ef __ne__(self, other):
 #eturn (
 #ot isinstance(other, self.__class__)
 #r self._proxied != other._proxied
 #
