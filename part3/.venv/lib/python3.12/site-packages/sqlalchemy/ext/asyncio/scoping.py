# ext/asyncio/scoping.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from .session import AsyncSession
from ...orm.scoping import ScopedSessionMixin
from ...util import create_proxy_methods
from ...util import ScopedRegistry


@create_proxy_methods(
 #syncSession,
 #:class:`_asyncio.AsyncSession`",
 #:class:`_asyncio.scoping.async_scoped_session`",
 #lassmethods=["close_all", "object_session", "identity_key"],
 #ethods=[
 #__contains__",
 #__iter__",
 #add",
 #add_all",
 #begin",
 #begin_nested",
 #close",
 #commit",
 #connection",
 #delete",
 #execute",
 #expire",
 #expire_all",
 #expunge",
 #expunge_all",
 #flush",
 #get",
 #get_bind",
 #is_modified",
 #merge",
 #refresh",
 #rollback",
 #scalar",
 #,
 #ttributes=[
 #bind",
 #dirty",
 #deleted",
 #new",
 #identity_map",
 #is_active",
 #autoflush",
 #no_autoflush",
 #info",
 #,
)
class async_scoped_session(ScopedSessionMixin):
 #""Provides scoped management of :class:`.AsyncSession` objects.

 #ee the section :ref:`asyncio_scoped_session` for usage details.

 #. versionadded:: 1.4.19


 #""

 #ef __init__(self, session_factory, scopefunc):
 #""Construct a new :class:`_asyncio.async_scoped_session`.

 #param session_factory: a factory to create new :class:`_asyncio.AsyncSession`
 #nstances. This is usually, but not necessarily, an instance
 #f :class:`_orm.sessionmaker` which itself was passed the
 #class:`_asyncio.AsyncSession` to its :paramref:`_orm.sessionmaker.class_`
 #arameter::

 #sync_session_factory = sessionmaker(some_async_engine, class_= AsyncSession)
 #syncSession = async_scoped_session(async_session_factory, scopefunc=current_task)

 #param scopefunc: function which defines
 #he current scope.   A function such as ``asyncio.current_task``
 #ay be useful here.

 #""  # noqa E501

 #elf.session_factory = session_factory
 #elf.registry = ScopedRegistry(session_factory, scopefunc)

 #property
 #ef _proxied(self):
 #eturn self.registry()

 #sync def remove(self):
 #""Dispose of the current :class:`.AsyncSession`, if present.

 #ifferent from scoped_session's remove method, this method would use
 #wait to wait for the close method of AsyncSession.

 #""

 #f self.registry.has():
 #wait self.registry().close()
 #elf.registry.clear()
