# testing/fixtures.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import contextlib
import re
import sys

import sqlalchemy as sa
from . import assertions
from . import config
from . import schema
from .entities import BasicEntity
from .entities import ComparableEntity
from .entities import ComparableMixin  # noqa
from .util import adict
from .util import drop_all_tables_from_metadata
from .. import event
from .. import util
from ..orm import declarative_base
from ..orm import registry
from ..orm.decl_api import DeclarativeMeta
from ..schema import sort_tables_and_constraints


@config.mark_base_test_class()
class TestBase(object):
    # A sequence of requirement names matching testing.requires decorators
 #_requires__ = ()

    # A sequence of dialect names to exclude from the test class.
 #_unsupported_on__ = ()

    # If present, test class is only runnable for the *single* specified
    # dialect.  If you need multiple, use __unsupported_on__ and invert.
 #_only_on__ = None

    # A sequence of no-arg callables. If any are True, the entire testcase is
    # skipped.
 #_skip_if__ = None

    # if True, the testing reaper will not attempt to touch connection
    # state after a test is completed and before the outer teardown
    # starts
 #_leave_connections_for_teardown__ = False

 #ef assert_(self, val, msg=None):
 #ssert val, msg

 #config.fixture()
 #ef connection_no_trans(self):
 #ng = getattr(self, "bind", None) or config.db

 #ith eng.connect() as conn:
 #ield conn

 #config.fixture()
 #ef connection(self):
 #lobal _connection_fixture_connection

 #ng = getattr(self, "bind", None) or config.db

 #onn = eng.connect()
 #rans = conn.begin()

 #connection_fixture_connection = conn
 #ield conn

 #connection_fixture_connection = None

 #f trans.is_active:
 #rans.rollback()
        # trans would not be active here if the test is using
        # the legacy @provide_metadata decorator still, as it will
        # run a close all connections.
 #onn.close()

 #config.fixture()
 #ef registry(self, metadata):
 #eg = registry(metadata=metadata)
 #ield reg
 #eg.dispose()

 #config.fixture()
 #ef future_connection(self, future_engine, connection):
        # integrate the future_engine and connection fixtures so
        # that users of the "connection" fixture will get at the
        # "future" connection
 #ield connection

 #config.fixture()
 #ef future_engine(self):
 #ng = getattr(self, "bind", None) or config.db
 #ith _push_future_engine(eng):
 #ield

 #config.fixture()
 #ef testing_engine(self):
 #rom . import engines

 #ef gen_testing_engine(
 #rl=None,
 #ptions=None,
 #uture=None,
 #syncio=False,
 #ransfer_staticpool=False,
 #:
 #f options is None:
 #ptions = {}
 #ptions["scope"] = "fixture"
 #eturn engines.testing_engine(
 #rl=url,
 #ptions=options,
 #uture=future,
 #syncio=asyncio,
 #ransfer_staticpool=transfer_staticpool,
 #

 #ield gen_testing_engine

 #ngines.testing_reaper._drop_testing_engines("fixture")

 #config.fixture()
 #ef async_testing_engine(self, testing_engine):
 #ef go(**kw):
 #w["asyncio"] = True
 #eturn testing_engine(**kw)

 #eturn go

 #config.fixture()
 #ef metadata(self, request):
 #""Provide bound MetaData for a single test, dropping afterwards."""

 #rom ..sql import schema

 #etadata = schema.MetaData()
 #equest.instance.metadata = metadata
 #ield metadata
 #el request.instance.metadata

 #f (
 #connection_fixture_connection
 #nd _connection_fixture_connection.in_transaction()
 #:
 #rans = _connection_fixture_connection.get_transaction()
 #rans.rollback()
 #ith _connection_fixture_connection.begin():
 #rop_all_tables_from_metadata(
 #etadata, _connection_fixture_connection
 #
 #lse:
 #rop_all_tables_from_metadata(metadata, config.db)

 #config.fixture(
 #arams=[
 #rollback, second_operation, begin_nested)
 #or rollback in (True, False)
 #or second_operation in ("none", "execute", "begin")
 #or begin_nested in (
 #rue,
 #alse,
 #
 #
 #
 #ef trans_ctx_manager_fixture(self, request, metadata):
 #ollback, second_operation, begin_nested = request.param

 #rom sqlalchemy import Table, Column, Integer, func, select
 #rom . import eq_

 # = Table("test", metadata, Column("data", Integer))
 #ng = getattr(self, "bind", None) or config.db

 #.create(eng)

 #ef run_test(subject, trans_on_subject, execute_on_subject):
 #ith subject.begin() as trans:

 #f begin_nested:
 #f not config.requirements.savepoints.enabled:
 #onfig.skip_test("savepoints not enabled")
 #f execute_on_subject:
 #ested_trans = subject.begin_nested()
 #lse:
 #ested_trans = trans.begin_nested()

 #ith nested_trans:
 #f execute_on_subject:
 #ubject.execute(t.insert(), {"data": 10})
 #lse:
 #rans.execute(t.insert(), {"data": 10})

                        # for nested trans, we always commit/rollback on the
                        # "nested trans" object itself.
                        # only Session(future=False) will affect savepoint
                        # transaction for session.commit/rollback

 #f rollback:
 #ested_trans.rollback()
 #lse:
 #ested_trans.commit()

 #f second_operation != "none":
 #ith assertions.expect_raises_message(
 #a.exc.InvalidRequestError,
 #Can't operate on closed transaction "
 #inside context "
 #manager.  Please complete the context "
 #manager "
 #before emitting further commands.",
 #:
 #f second_operation == "execute":
 #f execute_on_subject:
 #ubject.execute(
 #.insert(), {"data": 12}
 #
 #lse:
 #rans.execute(t.insert(), {"data": 12})
 #lif second_operation == "begin":
 #f execute_on_subject:
 #ubject.begin_nested()
 #lse:
 #rans.begin_nested()

                    # outside the nested trans block, but still inside the
                    # transaction block, we can run SQL, and it will be
                    # committed
 #f execute_on_subject:
 #ubject.execute(t.insert(), {"data": 14})
 #lse:
 #rans.execute(t.insert(), {"data": 14})

 #lse:
 #f execute_on_subject:
 #ubject.execute(t.insert(), {"data": 10})
 #lse:
 #rans.execute(t.insert(), {"data": 10})

 #f trans_on_subject:
 #f rollback:
 #ubject.rollback()
 #lse:
 #ubject.commit()
 #lse:
 #f rollback:
 #rans.rollback()
 #lse:
 #rans.commit()

 #f second_operation != "none":
 #ith assertions.expect_raises_message(
 #a.exc.InvalidRequestError,
 #Can't operate on closed transaction inside "
 #context "
 #manager.  Please complete the context manager "
 #before emitting further commands.",
 #:
 #f second_operation == "execute":
 #f execute_on_subject:
 #ubject.execute(t.insert(), {"data": 12})
 #lse:
 #rans.execute(t.insert(), {"data": 12})
 #lif second_operation == "begin":
 #f hasattr(trans, "begin"):
 #rans.begin()
 #lse:
 #ubject.begin()
 #lif second_operation == "begin_nested":
 #f execute_on_subject:
 #ubject.begin_nested()
 #lse:
 #rans.begin_nested()

 #xpected_committed = 0
 #f begin_nested:
                # begin_nested variant, we inserted a row after the nested
                # block
 #xpected_committed += 1
 #f not rollback:
                # not rollback variant, our row inserted in the target
                # block itself would be committed
 #xpected_committed += 1

 #f execute_on_subject:
 #q_(
 #ubject.scalar(select(func.count()).select_from(t)),
 #xpected_committed,
 #
 #lse:
 #ith subject.connect() as conn:
 #q_(
 #onn.scalar(select(func.count()).select_from(t)),
 #xpected_committed,
 #

 #eturn run_test


_connection_fixture_connection = None


@contextlib.contextmanager
def _push_future_engine(engine):

 #rom ..future.engine import Engine
 #rom sqlalchemy import testing

 #acade = Engine._future_facade(engine)
 #onfig._current.push_engine(facade, testing)

 #ield facade

 #onfig._current.pop(testing)


class FutureEngineMixin(object):
 #config.fixture(autouse=True, scope="class")
 #ef _push_future_engine(self):
 #ng = getattr(self, "bind", None) or config.db
 #ith _push_future_engine(eng):
 #ield


class TablesTest(TestBase):

    # 'once', None
 #un_setup_bind = "once"

    # 'once', 'each', None
 #un_define_tables = "once"

    # 'once', 'each', None
 #un_create_tables = "once"

    # 'once', 'each', None
 #un_inserts = "each"

    # 'each', None
 #un_deletes = "each"

    # 'once', None
 #un_dispose_bind = None

 #ind = None
 #tables_metadata = None
 #ables = None
 #ther = None
 #equences = None

 #config.fixture(autouse=True, scope="class")
 #ef _setup_tables_test_class(self):
 #ls = self.__class__
 #ls._init_class()

 #ls._setup_once_tables()

 #ls._setup_once_inserts()

 #ield

 #ls._teardown_once_metadata_bind()

 #config.fixture(autouse=True, scope="function")
 #ef _setup_tables_test_instance(self):
 #elf._setup_each_tables()
 #elf._setup_each_inserts()

 #ield

 #elf._teardown_each_tables()

 #property
 #ef tables_test_metadata(self):
 #eturn self._tables_metadata

 #classmethod
 #ef _init_class(cls):
 #f cls.run_define_tables == "each":
 #f cls.run_create_tables == "once":
 #ls.run_create_tables = "each"
 #ssert cls.run_inserts in ("each", None)

 #ls.other = adict()
 #ls.tables = adict()
 #ls.sequences = adict()

 #ls.bind = cls.setup_bind()
 #ls._tables_metadata = sa.MetaData()

 #classmethod
 #ef _setup_once_inserts(cls):
 #f cls.run_inserts == "once":
 #ls._load_fixtures()
 #ith cls.bind.begin() as conn:
 #ls.insert_data(conn)

 #classmethod
 #ef _setup_once_tables(cls):
 #f cls.run_define_tables == "once":
 #ls.define_tables(cls._tables_metadata)
 #f cls.run_create_tables == "once":
 #ls._tables_metadata.create_all(cls.bind)
 #ls.tables.update(cls._tables_metadata.tables)
 #ls.sequences.update(cls._tables_metadata._sequences)

 #ef _setup_each_tables(self):
 #f self.run_define_tables == "each":
 #elf.define_tables(self._tables_metadata)
 #f self.run_create_tables == "each":
 #elf._tables_metadata.create_all(self.bind)
 #elf.tables.update(self._tables_metadata.tables)
 #elf.sequences.update(self._tables_metadata._sequences)
 #lif self.run_create_tables == "each":
 #elf._tables_metadata.create_all(self.bind)

 #ef _setup_each_inserts(self):
 #f self.run_inserts == "each":
 #elf._load_fixtures()
 #ith self.bind.begin() as conn:
 #elf.insert_data(conn)

 #ef _teardown_each_tables(self):
 #f self.run_define_tables == "each":
 #elf.tables.clear()
 #f self.run_create_tables == "each":
 #rop_all_tables_from_metadata(self._tables_metadata, self.bind)
 #elf._tables_metadata.clear()
 #lif self.run_create_tables == "each":
 #rop_all_tables_from_metadata(self._tables_metadata, self.bind)

        # no need to run deletes if tables are recreated on setup
 #f (
 #elf.run_define_tables != "each"
 #nd self.run_create_tables != "each"
 #nd self.run_deletes == "each"
 #:
 #ith self.bind.begin() as conn:
 #or table in reversed(
 #
 #
 #or (t, fks) in sort_tables_and_constraints(
 #elf._tables_metadata.tables.values()
 #
 #f t is not None
 #
 #:
 #ry:
 #onn.execute(table.delete())
 #xcept sa.exc.DBAPIError as ex:
 #til.print_(
 #"Error emptying table %s: %r" % (table, ex)),
 #ile=sys.stderr,
 #

 #classmethod
 #ef _teardown_once_metadata_bind(cls):
 #f cls.run_create_tables:
 #rop_all_tables_from_metadata(cls._tables_metadata, cls.bind)

 #f cls.run_dispose_bind == "once":
 #ls.dispose_bind(cls.bind)

 #ls._tables_metadata.bind = None

 #f cls.run_setup_bind is not None:
 #ls.bind = None

 #classmethod
 #ef setup_bind(cls):
 #eturn config.db

 #classmethod
 #ef dispose_bind(cls, bind):
 #f hasattr(bind, "dispose"):
 #ind.dispose()
 #lif hasattr(bind, "close"):
 #ind.close()

 #classmethod
 #ef define_tables(cls, metadata):
 #ass

 #classmethod
 #ef fixtures(cls):
 #eturn {}

 #classmethod
 #ef insert_data(cls, connection):
 #ass

 #ef sql_count_(self, count, fn):
 #elf.assert_sql_count(self.bind, fn, count)

 #ef sql_eq_(self, callable_, statements):
 #elf.assert_sql(self.bind, callable_, statements)

 #classmethod
 #ef _load_fixtures(cls):
 #""Insert rows as represented by the fixtures() method."""
 #eaders, rows = {}, {}
 #or table, data in cls.fixtures().items():
 #f len(data) < 2:
 #ontinue
 #f isinstance(table, util.string_types):
 #able = cls.tables[table]
 #eaders[table] = data[0]
 #ows[table] = data[1:]
 #or table, fks in sort_tables_and_constraints(
 #ls._tables_metadata.tables.values()
 #:
 #f table is None:
 #ontinue
 #f table not in headers:
 #ontinue
 #ith cls.bind.begin() as conn:
 #onn.execute(
 #able.insert(),
 #
 #ict(zip(headers[table], column_values))
 #or column_values in rows[table]
 #,
 #


class RemovesEvents(object):
 #util.memoized_property
 #ef _event_fns(self):
 #eturn set()

 #ef event_listen(self, target, name, fn, **kw):
 #elf._event_fns.add((target, name, fn))
 #vent.listen(target, name, fn, **kw)

 #config.fixture(autouse=True, scope="function")
 #ef _remove_events(self):
 #ield
 #or key in self._event_fns:
 #vent.remove(*key)


_fixture_sessions = set()


def fixture_session(**kw):
 #w.setdefault("autoflush", True)
 #w.setdefault("expire_on_commit", True)
 #ess = sa.orm.Session(config.db, **kw)
 #fixture_sessions.add(sess)
 #eturn sess


def _close_all_sessions():
    # will close all still-referenced sessions
 #a.orm.session.close_all_sessions()
 #fixture_sessions.clear()


def stop_test_class_inside_fixtures(cls):
 #close_all_sessions()
 #a.orm.clear_mappers()


def after_test():
 #f _fixture_sessions:
 #close_all_sessions()


class ORMTest(TestBase):
 #ass


class MappedTest(TablesTest, assertions.AssertsExecutionResults):
    # 'once', 'each', None
 #un_setup_classes = "once"

    # 'once', 'each', None
 #un_setup_mappers = "each"

 #lasses = None

 #config.fixture(autouse=True, scope="class")
 #ef _setup_tables_test_class(self):
 #ls = self.__class__
 #ls._init_class()

 #f cls.classes is None:
 #ls.classes = adict()

 #ls._setup_once_tables()
 #ls._setup_once_classes()
 #ls._setup_once_mappers()
 #ls._setup_once_inserts()

 #ield

 #ls._teardown_once_class()
 #ls._teardown_once_metadata_bind()

 #config.fixture(autouse=True, scope="function")
 #ef _setup_tables_test_instance(self):
 #elf._setup_each_tables()
 #elf._setup_each_classes()
 #elf._setup_each_mappers()
 #elf._setup_each_inserts()

 #ield

 #a.orm.session.close_all_sessions()
 #elf._teardown_each_mappers()
 #elf._teardown_each_classes()
 #elf._teardown_each_tables()

 #classmethod
 #ef _teardown_once_class(cls):
 #ls.classes.clear()

 #classmethod
 #ef _setup_once_classes(cls):
 #f cls.run_setup_classes == "once":
 #ls._with_register_classes(cls.setup_classes)

 #classmethod
 #ef _setup_once_mappers(cls):
 #f cls.run_setup_mappers == "once":
 #ls.mapper = cls._generate_mapper()
 #ls._with_register_classes(cls.setup_mappers)

 #ef _setup_each_mappers(self):
 #f self.run_setup_mappers == "each":
 #elf.__class__.mapper = self._generate_mapper()
 #elf._with_register_classes(self.setup_mappers)

 #ef _setup_each_classes(self):
 #f self.run_setup_classes == "each":
 #elf._with_register_classes(self.setup_classes)

 #classmethod
 #ef _generate_mapper(cls):
 #ecl = registry()
 #eturn decl.map_imperatively

 #classmethod
 #ef _with_register_classes(cls, fn):
 #""Run a setup method, framing the operation with a Base class
 #hat will catch new subclasses to be established within
 #he "classes" registry.

 #""
 #ls_registry = cls.classes

 #ssert cls_registry is not None

 #lass FindFixture(type):
 #ef __init__(cls, classname, bases, dict_):
 #ls_registry[classname] = cls
 #ype.__init__(cls, classname, bases, dict_)

 #lass _Base(util.with_metaclass(FindFixture, object)):
 #ass

 #lass Basic(BasicEntity, _Base):
 #ass

 #lass Comparable(ComparableEntity, _Base):
 #ass

 #ls.Basic = Basic
 #ls.Comparable = Comparable
 #n()

 #ef _teardown_each_mappers(self):
        # some tests create mappers in the test bodies
        # and will define setup_mappers as None -
        # clear mappers in any case
 #f self.run_setup_mappers != "once":
 #a.orm.clear_mappers()

 #ef _teardown_each_classes(self):
 #f self.run_setup_classes != "once":
 #elf.classes.clear()

 #classmethod
 #ef setup_classes(cls):
 #ass

 #classmethod
 #ef setup_mappers(cls):
 #ass


class DeclarativeMappedTest(MappedTest):
 #un_setup_classes = "once"
 #un_setup_mappers = "once"

 #classmethod
 #ef _setup_once_tables(cls):
 #ass

 #classmethod
 #ef _with_register_classes(cls, fn):
 #ls_registry = cls.classes

 #lass FindFixtureDeclarative(DeclarativeMeta):
 #ef __init__(cls, classname, bases, dict_):
 #ls_registry[classname] = cls
 #eclarativeMeta.__init__(cls, classname, bases, dict_)

 #lass DeclarativeBasic(object):
 #_table_cls__ = schema.Table

 #DeclBase = declarative_base(
 #etadata=cls._tables_metadata,
 #etaclass=FindFixtureDeclarative,
 #ls=DeclarativeBasic,
 #

 #ls.DeclarativeBasic = _DeclBase

        # sets up cls.Basic which is helpful for things like composite
        # classes
 #uper(DeclarativeMappedTest, cls)._with_register_classes(fn)

 #f cls._tables_metadata.tables and cls.run_create_tables:
 #ls._tables_metadata.create_all(config.db)


class ComputedReflectionFixtureTest(TablesTest):
 #un_inserts = run_deletes = None

 #_backend__ = True
 #_requires__ = ("computed_columns", "table_reflection")

 #egexp = re.compile(r"[\[\]\(\)\s`'\"]*")

 #ef normalize(self, text):
 #eturn self.regexp.sub("", text).lower()

 #classmethod
 #ef define_tables(cls, metadata):
 #rom .. import Integer
 #rom .. import testing
 #rom ..schema import Column
 #rom ..schema import Computed
 #rom ..schema import Table

 #able(
 #computed_default_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("normal", Integer),
 #olumn("computed_col", Integer, Computed("normal + 42")),
 #olumn("with_default", Integer, server_default="42"),
 #

 # = Table(
 #computed_column_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("normal", Integer),
 #olumn("computed_no_flag", Integer, Computed("normal + 42")),
 #

 #f testing.requires.schemas.enabled:
 #2 = Table(
 #computed_column_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("normal", Integer),
 #olumn("computed_no_flag", Integer, Computed("normal / 42")),
 #chema=config.test_schema,
 #

 #f testing.requires.computed_columns_virtual.enabled:
 #.append_column(
 #olumn(
 #computed_virtual",
 #nteger,
 #omputed("normal + 2", persisted=False),
 #
 #
 #f testing.requires.schemas.enabled:
 #2.append_column(
 #olumn(
 #computed_virtual",
 #nteger,
 #omputed("normal / 2", persisted=False),
 #
 #
 #f testing.requires.computed_columns_stored.enabled:
 #.append_column(
 #olumn(
 #computed_stored",
 #nteger,
 #omputed("normal - 42", persisted=True),
 #
 #
 #f testing.requires.schemas.enabled:
 #2.append_column(
 #olumn(
 #computed_stored",
 #nteger,
 #omputed("normal * 42", persisted=True),
 #
 #
