# testing/requirements.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Global database feature support policy.

Provides decorators to mark tests requiring specific feature support from the
target database.

External dialect test suites should subclass SuiteRequirements
to provide specific inclusion/exclusions.

"""

import platform
import sys

from . import exclusions
from . import only_on
from .. import util
from ..pool import QueuePool


class Requirements(object):
 #ass


class SuiteRequirements(Requirements):
 #property
 #ef create_table(self):
 #""target platform can emit basic CreateTable DDL."""

 #eturn exclusions.open()

 #property
 #ef drop_table(self):
 #""target platform can emit basic DropTable DDL."""

 #eturn exclusions.open()

 #property
 #ef table_ddl_if_exists(self):
 #""target platform supports IF NOT EXISTS / IF EXISTS for tables."""

 #eturn exclusions.closed()

 #property
 #ef index_ddl_if_exists(self):
 #""target platform supports IF NOT EXISTS / IF EXISTS for indexes."""

 #eturn exclusions.closed()

 #property
 #ef foreign_keys(self):
 #""Target database must support foreign keys."""

 #eturn exclusions.open()

 #property
 #ef table_value_constructor(self):
 #""Database / dialect supports a query like::

 #ELECT * FROM VALUES ( (c1, c2), (c1, c2), ...)
 #S some_table(col1, col2)

 #QLAlchemy generates this with the :func:`_sql.values` function.

 #""
 #eturn exclusions.closed()

 #property
 #ef standard_cursor_sql(self):
 #""Target database passes SQL-92 style statements to cursor.execute()
 #hen a statement like select() or insert() is run.

 # very small portion of dialect-level tests will ensure that certain
 #onditions are present in SQL strings, and these tests use very basic
 #QL that will work on any SQL-like platform in order to assert results.

 #t's normally a given for any pep-249 DBAPI that a statement like
 #SELECT id, name FROM table WHERE some_table.id=5" will work.
 #owever, there are dialects that don't actually produce SQL Strings
 #nd instead may work with symbolic objects instead, or dialects that
 #ren't working with SQL, so for those this requirement can be marked
 #s excluded.

 #""

 #eturn exclusions.open()

 #property
 #ef on_update_cascade(self):
 #""target database must support ON UPDATE..CASCADE behavior in
 #oreign keys."""

 #eturn exclusions.open()

 #property
 #ef non_updating_cascade(self):
 #""target database must *not* support ON UPDATE..CASCADE behavior in
 #oreign keys."""
 #eturn exclusions.closed()

 #property
 #ef deferrable_fks(self):
 #eturn exclusions.closed()

 #property
 #ef on_update_or_deferrable_fks(self):
        # TODO: exclusions should be composable,
        # somehow only_if([x, y]) isn't working here, negation/conjunctions
        # getting confused.
 #eturn exclusions.only_if(
 #ambda: self.on_update_cascade.enabled
 #r self.deferrable_fks.enabled
 #

 #property
 #ef queue_pool(self):
 #""target database is using QueuePool"""

 #ef go(config):
 #eturn isinstance(config.db.pool, QueuePool)

 #eturn exclusions.only_if(go)

 #property
 #ef self_referential_foreign_keys(self):
 #""Target database must support self-referential foreign keys."""

 #eturn exclusions.open()

 #property
 #ef foreign_key_ddl(self):
 #""Target database must support the DDL phrases for FOREIGN KEY."""

 #eturn exclusions.open()

 #property
 #ef named_constraints(self):
 #""target database must support names for constraints."""

 #eturn exclusions.open()

 #property
 #ef subqueries(self):
 #""Target database must support subqueries."""

 #eturn exclusions.open()

 #property
 #ef offset(self):
 #""target database can render OFFSET, or an equivalent, in a
 #ELECT.
 #""

 #eturn exclusions.open()

 #property
 #ef bound_limit_offset(self):
 #""target database can render LIMIT and/or OFFSET using a bound
 #arameter
 #""

 #eturn exclusions.open()

 #property
 #ef sql_expression_limit_offset(self):
 #""target database can render LIMIT and/or OFFSET with a complete
 #QL expression, such as one that uses the addition operator.
 #arameter
 #""

 #eturn exclusions.open()

 #property
 #ef parens_in_union_contained_select_w_limit_offset(self):
 #""Target database must support parenthesized SELECT in UNION
 #hen LIMIT/OFFSET is specifically present.

 #.g. (SELECT ...) UNION (SELECT ..)

 #his is known to fail on SQLite.

 #""
 #eturn exclusions.open()

 #property
 #ef parens_in_union_contained_select_wo_limit_offset(self):
 #""Target database must support parenthesized SELECT in UNION
 #hen OFFSET/LIMIT is specifically not present.

 #.g. (SELECT ... LIMIT ..) UNION (SELECT .. OFFSET ..)

 #his is known to fail on SQLite.  It also fails on Oracle
 #ecause without LIMIT/OFFSET, there is currently no step that
 #reates an additional subquery.

 #""
 #eturn exclusions.open()

 #property
 #ef boolean_col_expressions(self):
 #""Target database must support boolean expressions as columns"""

 #eturn exclusions.closed()

 #property
 #ef nullable_booleans(self):
 #""Target database allows boolean columns to store NULL."""

 #eturn exclusions.open()

 #property
 #ef nullsordering(self):
 #""Target backends that support nulls ordering."""

 #eturn exclusions.closed()

 #property
 #ef standalone_binds(self):
 #""target database/driver supports bound parameters as column expressions
 #ithout being in the context of a typed column.

 #""
 #eturn exclusions.closed()

 #property
 #ef standalone_null_binds_whereclause(self):
 #""target database/driver supports bound parameters with NULL in the
 #HERE clause, in situations where it has to be typed.

 #""
 #eturn exclusions.open()

 #property
 #ef intersect(self):
 #""Target database must support INTERSECT or equivalent."""
 #eturn exclusions.closed()

 #property
 #ef except_(self):
 #""Target database must support EXCEPT or equivalent (i.e. MINUS)."""
 #eturn exclusions.closed()

 #property
 #ef window_functions(self):
 #""Target database must support window functions."""
 #eturn exclusions.closed()

 #property
 #ef ctes(self):
 #""Target database supports CTEs"""

 #eturn exclusions.closed()

 #property
 #ef ctes_with_update_delete(self):
 #""target database supports CTES that ride on top of a normal UPDATE
 #r DELETE statement which refers to the CTE in a correlated subquery.

 #""

 #eturn exclusions.closed()

 #property
 #ef ctes_on_dml(self):
 #""target database supports CTES which consist of INSERT, UPDATE
 #r DELETE *within* the CTE, e.g. WITH x AS (UPDATE....)"""

 #eturn exclusions.closed()

 #property
 #ef autoincrement_insert(self):
 #""target platform generates new surrogate integer primary key values
 #hen insert() is executed, excluding the pk column."""

 #eturn exclusions.open()

 #property
 #ef fetch_rows_post_commit(self):
 #""target platform will allow cursor.fetchone() to proceed after a
 #OMMIT.

 #ypically this refers to an INSERT statement with RETURNING which
 #s invoked within "autocommit".   If the row can be returned
 #fter the autocommit, then this rule can be open.

 #""

 #eturn exclusions.open()

 #property
 #ef group_by_complex_expression(self):
 #""target platform supports SQL expressions in GROUP BY

 #.g.

 #ELECT x + y AS somelabel FROM table GROUP BY x + y

 #""

 #eturn exclusions.open()

 #property
 #ef sane_rowcount(self):
 #eturn exclusions.skip_if(
 #ambda config: not config.db.dialect.supports_sane_rowcount,
 #driver doesn't support 'sane' rowcount",
 #

 #property
 #ef sane_multi_rowcount(self):
 #eturn exclusions.fails_if(
 #ambda config: not config.db.dialect.supports_sane_multi_rowcount,
 #driver %(driver)s %(doesnt_support)s 'sane' multi row count",
 #

 #property
 #ef sane_rowcount_w_returning(self):
 #eturn exclusions.fails_if(
 #ambda config: not (
 #onfig.db.dialect.supports_sane_rowcount_returning
 #,
 #driver doesn't support 'sane' rowcount when returning is on",
 #

 #property
 #ef empty_inserts(self):
 #""target platform supports INSERT with no values, i.e.
 #NSERT DEFAULT VALUES or equivalent."""

 #eturn exclusions.only_if(
 #ambda config: config.db.dialect.supports_empty_insert
 #r config.db.dialect.supports_default_values
 #r config.db.dialect.supports_default_metavalue,
 #empty inserts not supported",
 #

 #property
 #ef empty_inserts_executemany(self):
 #""target platform supports INSERT with no values, i.e.
 #NSERT DEFAULT VALUES or equivalent, within executemany()"""

 #eturn self.empty_inserts

 #property
 #ef insert_from_select(self):
 #""target platform supports INSERT from a SELECT."""

 #eturn exclusions.open()

 #property
 #ef full_returning(self):
 #""target platform supports RETURNING completely, including
 #ultiple rows returned.

 #""

 #eturn exclusions.only_if(
 #ambda config: config.db.dialect.full_returning,
 #%(database)s %(does_support)s 'RETURNING of multiple rows'",
 #

 #property
 #ef insert_executemany_returning(self):
 #""target platform supports RETURNING when INSERT is used with
 #xecutemany(), e.g. multiple parameter sets, indicating
 #s many rows come back as do parameter sets were passed.

 #""

 #eturn exclusions.only_if(
 #ambda config: config.db.dialect.insert_executemany_returning,
 #%(database)s %(does_support)s 'RETURNING of "
 #multiple rows with INSERT executemany'",
 #

 #property
 #ef returning(self):
 #""target platform supports RETURNING for at least one row.

 #. seealso::

 #attr:`.Requirements.full_returning`

 #""

 #eturn exclusions.only_if(
 #ambda config: config.db.dialect.implicit_returning,
 #%(database)s %(does_support)s 'RETURNING of a single row'",
 #

 #property
 #ef tuple_in(self):
 #""Target platform supports the syntax
 #(x, y) IN ((x1, y1), (x2, y2), ...)"
 #""

 #eturn exclusions.closed()

 #property
 #ef tuple_in_w_empty(self):
 #""Target platform tuple IN w/ empty set"""
 #eturn self.tuple_in

 #property
 #ef duplicate_names_in_cursor_description(self):
 #""target platform supports a SELECT statement that has
 #he same name repeated more than once in the columns list."""

 #eturn exclusions.open()

 #property
 #ef denormalized_names(self):
 #""Target database must have 'denormalized', i.e.
 #PPERCASE as case insensitive names."""

 #eturn exclusions.skip_if(
 #ambda config: not config.db.dialect.requires_name_normalize,
 #Backend does not require denormalized names.",
 #

 #property
 #ef multivalues_inserts(self):
 #""target database must support multiple VALUES clauses in an
 #NSERT statement."""

 #eturn exclusions.skip_if(
 #ambda config: not config.db.dialect.supports_multivalues_insert,
 #Backend does not support multirow inserts.",
 #

 #property
 #ef implements_get_lastrowid(self):
 #""target dialect implements the executioncontext.get_lastrowid()
 #ethod without reliance on RETURNING.

 #""
 #eturn exclusions.open()

 #property
 #ef emulated_lastrowid(self):
 #""target dialect retrieves cursor.lastrowid, or fetches
 #rom a database-side function after an insert() construct executes,
 #ithin the get_lastrowid() method.

 #nly dialects that "pre-execute", or need RETURNING to get last
 #nserted id, would return closed/fail/skip for this.

 #""
 #eturn exclusions.closed()

 #property
 #ef emulated_lastrowid_even_with_sequences(self):
 #""target dialect retrieves cursor.lastrowid or an equivalent
 #fter an insert() construct executes, even if the table has a
 #equence on it.

 #""
 #eturn exclusions.closed()

 #property
 #ef dbapi_lastrowid(self):
 #""target platform includes a 'lastrowid' accessor on the DBAPI
 #ursor object.

 #""
 #eturn exclusions.closed()

 #property
 #ef views(self):
 #""Target database must support VIEWs."""

 #eturn exclusions.closed()

 #property
 #ef schemas(self):
 #""Target database must support external schemas, and have one
 #amed 'test_schema'."""

 #eturn only_on(lambda config: config.db.dialect.supports_schemas)

 #property
 #ef cross_schema_fk_reflection(self):
 #""target system must support reflection of inter-schema
 #oreign keys"""
 #eturn exclusions.closed()

 #property
 #ef foreign_key_constraint_name_reflection(self):
 #""Target supports refleciton of FOREIGN KEY constraints and
 #ill return the name of the constraint that was used in the
 #CONSTRANT <name> FOREIGN KEY" DDL.

 #ySQL prior to version 8 and MariaDB prior to version 10.5
 #on't support this.

 #""
 #eturn exclusions.closed()

 #property
 #ef implicit_default_schema(self):
 #""target system has a strong concept of 'default' schema that can
 #e referred to implicitly.

 #asically, PostgreSQL.

 #""
 #eturn exclusions.closed()

 #property
 #ef default_schema_name_switch(self):
 #""target dialect implements provisioning module including
 #et_default_schema_on_connection"""

 #eturn exclusions.closed()

 #property
 #ef server_side_cursors(self):
 #""Target dialect must support server side cursors."""

 #eturn exclusions.only_if(
 #lambda config: config.db.dialect.supports_server_side_cursors],
 #no server side cursors support",
 #

 #property
 #ef sequences(self):
 #""Target database must support SEQUENCEs."""

 #eturn exclusions.only_if(
 #lambda config: config.db.dialect.supports_sequences],
 #no sequence support",
 #

 #property
 #ef no_sequences(self):
 #""the opposite of "sequences", DB does not support sequences at
 #ll."""

 #eturn exclusions.NotPredicate(self.sequences)

 #property
 #ef sequences_optional(self):
 #""Target database supports sequences, but also optionally
 #s a means of generating new PK values."""

 #eturn exclusions.only_if(
 #
 #ambda config: config.db.dialect.supports_sequences
 #nd config.db.dialect.sequences_optional
 #,
 #no sequence support, or sequences not optional",
 #

 #property
 #ef supports_lastrowid(self):
 #""target database / driver supports cursor.lastrowid as a means
 #f retrieving the last inserted primary key value.

 #ote that if the target DB supports sequences also, this is still
 #ssumed to work.  This is a new use case brought on by MariaDB 10.3.

 #""
 #eturn exclusions.only_if(
 #lambda config: config.db.dialect.postfetch_lastrowid]
 #

 #property
 #ef no_lastrowid_support(self):
 #""the opposite of supports_lastrowid"""
 #eturn exclusions.only_if(
 #lambda config: not config.db.dialect.postfetch_lastrowid]
 #

 #property
 #ef reflects_pk_names(self):
 #eturn exclusions.closed()

 #property
 #ef table_reflection(self):
 #eturn exclusions.open()

 #property
 #ef comment_reflection(self):
 #eturn exclusions.closed()

 #property
 #ef view_column_reflection(self):
 #""target database must support retrieval of the columns in a view,
 #imilarly to how a table is inspected.

 #his does not include the full CREATE VIEW definition.

 #""
 #eturn self.views

 #property
 #ef view_reflection(self):
 #""target database must support inspection of the full CREATE VIEW
 #efinition."""
 #eturn self.views

 #property
 #ef schema_reflection(self):
 #eturn self.schemas

 #property
 #ef primary_key_constraint_reflection(self):
 #eturn exclusions.open()

 #property
 #ef foreign_key_constraint_reflection(self):
 #eturn exclusions.open()

 #property
 #ef foreign_key_constraint_option_reflection_ondelete(self):
 #eturn exclusions.closed()

 #property
 #ef fk_constraint_option_reflection_ondelete_restrict(self):
 #eturn exclusions.closed()

 #property
 #ef fk_constraint_option_reflection_ondelete_noaction(self):
 #eturn exclusions.closed()

 #property
 #ef foreign_key_constraint_option_reflection_onupdate(self):
 #eturn exclusions.closed()

 #property
 #ef fk_constraint_option_reflection_onupdate_restrict(self):
 #eturn exclusions.closed()

 #property
 #ef temp_table_reflection(self):
 #eturn exclusions.open()

 #property
 #ef temp_table_reflect_indexes(self):
 #eturn self.temp_table_reflection

 #property
 #ef temp_table_names(self):
 #""target dialect supports listing of temporary table names"""
 #eturn exclusions.closed()

 #property
 #ef temporary_tables(self):
 #""target database supports temporary tables"""
 #eturn exclusions.open()

 #property
 #ef temporary_views(self):
 #""target database supports temporary views"""
 #eturn exclusions.closed()

 #property
 #ef index_reflection(self):
 #eturn exclusions.open()

 #property
 #ef index_reflects_included_columns(self):
 #eturn exclusions.closed()

 #property
 #ef indexes_with_ascdesc(self):
 #""target database supports CREATE INDEX with per-column ASC/DESC."""
 #eturn exclusions.open()

 #property
 #ef indexes_with_expressions(self):
 #""target database supports CREATE INDEX against SQL expressions."""
 #eturn exclusions.closed()

 #property
 #ef unique_constraint_reflection(self):
 #""target dialect supports reflection of unique constraints"""
 #eturn exclusions.open()

 #property
 #ef check_constraint_reflection(self):
 #""target dialect supports reflection of check constraints"""
 #eturn exclusions.closed()

 #property
 #ef duplicate_key_raises_integrity_error(self):
 #""target dialect raises IntegrityError when reporting an INSERT
 #ith a primary key violation.  (hint: it should)

 #""
 #eturn exclusions.open()

 #property
 #ef unbounded_varchar(self):
 #""Target database must support VARCHAR with no length"""

 #eturn exclusions.open()

 #property
 #ef unicode_data(self):
 #""Target database/dialect must support Python unicode objects with
 #on-ASCII characters represented, delivered as bound parameters
 #s well as in result rows.

 #""
 #eturn exclusions.open()

 #property
 #ef unicode_ddl(self):
 #""Target driver must support some degree of non-ascii symbol
 #ames.
 #""
 #eturn exclusions.closed()

 #property
 #ef symbol_names_w_double_quote(self):
 #""Target driver can create tables with a name like 'some " table'"""
 #eturn exclusions.open()

 #property
 #ef datetime_literals(self):
 #""target dialect supports rendering of a date, time, or datetime as a
 #iteral string, e.g. via the TypeEngine.literal_processor() method.

 #""

 #eturn exclusions.closed()

 #property
 #ef datetime(self):
 #""target dialect supports representation of Python
 #atetime.datetime() objects."""

 #eturn exclusions.open()

 #property
 #ef datetime_microseconds(self):
 #""target dialect supports representation of Python
 #atetime.datetime() with microsecond objects."""

 #eturn exclusions.open()

 #property
 #ef timestamp_microseconds(self):
 #""target dialect supports representation of Python
 #atetime.datetime() with microsecond objects but only
 #f TIMESTAMP is used."""
 #eturn exclusions.closed()

 #property
 #ef datetime_historic(self):
 #""target dialect supports representation of Python
 #atetime.datetime() objects with historic (pre 1970) values."""

 #eturn exclusions.closed()

 #property
 #ef date(self):
 #""target dialect supports representation of Python
 #atetime.date() objects."""

 #eturn exclusions.open()

 #property
 #ef date_coerces_from_datetime(self):
 #""target dialect accepts a datetime object as the target
 #f a date column."""

 #eturn exclusions.open()

 #property
 #ef date_historic(self):
 #""target dialect supports representation of Python
 #atetime.datetime() objects with historic (pre 1970) values."""

 #eturn exclusions.closed()

 #property
 #ef time(self):
 #""target dialect supports representation of Python
 #atetime.time() objects."""

 #eturn exclusions.open()

 #property
 #ef time_microseconds(self):
 #""target dialect supports representation of Python
 #atetime.time() with microsecond objects."""

 #eturn exclusions.open()

 #property
 #ef binary_comparisons(self):
 #""target database/driver can allow BLOB/BINARY fields to be compared
 #gainst a bound parameter value.
 #""

 #eturn exclusions.open()

 #property
 #ef binary_literals(self):
 #""target backend supports simple binary literals, e.g. an
 #xpression like::

 #ELECT CAST('foo' AS BINARY)

 #here ``BINARY`` is the type emitted from :class:`.LargeBinary`,
 #.g. it could be ``BLOB`` or similar.

 #asically fails on Oracle.

 #""

 #eturn exclusions.open()

 #property
 #ef autocommit(self):
 #""target dialect supports 'AUTOCOMMIT' as an isolation_level"""
 #eturn exclusions.closed()

 #property
 #ef isolation_level(self):
 #""target dialect supports general isolation level settings.

 #ote that this requirement, when enabled, also requires that
 #he get_isolation_levels() method be implemented.

 #""
 #eturn exclusions.closed()

 #ef get_isolation_levels(self, config):
 #""Return a structure of supported isolation levels for the current
 #esting dialect.

 #he structure indicates to the testing suite what the expected
 #default" isolation should be, as well as the other values that
 #re accepted.  The dictionary has two keys, "default" and "supported".
 #he "supported" key refers to a list of all supported levels and
 #t should include AUTOCOMMIT if the dialect supports it.

 #f the :meth:`.DefaultRequirements.isolation_level` requirement is
 #ot open, then this method has no return value.

 #.g.::

 #>> testing.requirements.get_isolation_levels()
 #
 #default": "READ_COMMITED",
 #supported": [
 #SERIALIZABLE", "READ UNCOMMITTED",
 #READ COMMITTED", "REPEATABLE READ",
 #AUTOCOMMIT"
 #
 #
 #""

 #property
 #ef json_type(self):
 #""target platform implements a native JSON type."""

 #eturn exclusions.closed()

 #property
 #ef json_array_indexes(self):
 #""target platform supports numeric array indexes
 #ithin a JSON structure"""

 #eturn self.json_type

 #property
 #ef json_index_supplementary_unicode_element(self):
 #eturn exclusions.open()

 #property
 #ef legacy_unconditional_json_extract(self):
 #""Backend has a JSON_EXTRACT or similar function that returns a
 #alid JSON string in all cases.

 #sed to test a legacy feature and is not needed.

 #""
 #eturn exclusions.closed()

 #property
 #ef precision_numerics_general(self):
 #""target backend has general support for moderately high-precision
 #umerics."""
 #eturn exclusions.open()

 #property
 #ef precision_numerics_enotation_small(self):
 #""target backend supports Decimal() objects using E notation
 #o represent very small values."""
 #eturn exclusions.closed()

 #property
 #ef precision_numerics_enotation_large(self):
 #""target backend supports Decimal() objects using E notation
 #o represent very large values."""
 #eturn exclusions.closed()

 #property
 #ef precision_numerics_many_significant_digits(self):
 #""target backend supports values with many digits on both sides,
 #uch as 319438950232418390.273596, 87673.594069654243

 #""
 #eturn exclusions.closed()

 #property
 #ef cast_precision_numerics_many_significant_digits(self):
 #""same as precision_numerics_many_significant_digits but within the
 #ontext of a CAST statement (hello MySQL)

 #""
 #eturn self.precision_numerics_many_significant_digits

 #property
 #ef implicit_decimal_binds(self):
 #""target backend will return a selected Decimal as a Decimal, not
 # string.

 #.g.::

 #xpr = decimal.Decimal("15.7563")

 #alue = e.scalar(
 #elect(literal(expr))
 #

 #ssert value == expr

 #ee :ticket:`4036`

 #""

 #eturn exclusions.open()

 #property
 #ef nested_aggregates(self):
 #""target database can select an aggregate from a subquery that's
 #lso using an aggregate

 #""
 #eturn exclusions.open()

 #property
 #ef recursive_fk_cascade(self):
 #""target database must support ON DELETE CASCADE on a self-referential
 #oreign key

 #""
 #eturn exclusions.open()

 #property
 #ef precision_numerics_retains_significant_digits(self):
 #""A precision numeric type will return empty significant digits,
 #.e. a value such as 10.000 will come back in Decimal form with
 #he .000 maintained."""

 #eturn exclusions.closed()

 #property
 #ef precision_generic_float_type(self):
 #""target backend will return native floating point numbers with at
 #east seven decimal places when using the generic Float type.

 #""
 #eturn exclusions.open()

 #property
 #ef floats_to_four_decimals(self):
 #""target backend can return a floating-point number with four
 #ignificant digits (such as 15.7563) accurately
 #i.e. without FP inaccuracies, such as 15.75629997253418).

 #""
 #eturn exclusions.open()

 #property
 #ef fetch_null_from_numeric(self):
 #""target backend doesn't crash when you try to select a NUMERIC
 #alue that has a value of NULL.

 #dded to support Pyodbc bug #351.
 #""

 #eturn exclusions.open()

 #property
 #ef text_type(self):
 #""Target database must support an unbounded Text() "
 #type such as TEXT or CLOB"""

 #eturn exclusions.open()

 #property
 #ef empty_strings_varchar(self):
 #""target database can persist/return an empty string with a
 #archar.

 #""
 #eturn exclusions.open()

 #property
 #ef empty_strings_text(self):
 #""target database can persist/return an empty string with an
 #nbounded text."""

 #eturn exclusions.open()

 #property
 #ef expressions_against_unbounded_text(self):
 #""target database supports use of an unbounded textual field in a
 #HERE clause."""

 #eturn exclusions.open()

 #property
 #ef selectone(self):
 #""target driver must support the literal statement 'select 1'"""
 #eturn exclusions.open()

 #property
 #ef savepoints(self):
 #""Target database must support savepoints."""

 #eturn exclusions.closed()

 #property
 #ef two_phase_transactions(self):
 #""Target database must support two-phase transactions."""

 #eturn exclusions.closed()

 #property
 #ef update_from(self):
 #""Target must support UPDATE..FROM syntax"""
 #eturn exclusions.closed()

 #property
 #ef delete_from(self):
 #""Target must support DELETE FROM..FROM or DELETE..USING syntax"""
 #eturn exclusions.closed()

 #property
 #ef update_where_target_in_subquery(self):
 #""Target must support UPDATE (or DELETE) where the same table is
 #resent in a subquery in the WHERE clause.

 #his is an ANSI-standard syntax that apparently MySQL can't handle,
 #uch as::

 #PDATE documents SET flag=1 WHERE documents.title IN
 #SELECT max(documents.title) AS title
 #ROM documents GROUP BY documents.user_id
 #

 #""
 #eturn exclusions.open()

 #property
 #ef mod_operator_as_percent_sign(self):
 #""target database must use a plain percent '%' as the 'modulus'
 #perator."""
 #eturn exclusions.closed()

 #property
 #ef percent_schema_names(self):
 #""target backend supports weird identifiers with percent signs
 #n them, e.g. 'some % column'.

 #his is a very weird use case but often has problems because of
 #BAPIs that use python formatting.  It's not a critical use
 #ase either.

 #""
 #eturn exclusions.closed()

 #property
 #ef order_by_col_from_union(self):
 #""target database supports ordering by a column from a SELECT
 #nside of a UNION

 #.g.  (SELECT id, ...) UNION (SELECT id, ...) ORDER BY id

 #""
 #eturn exclusions.open()

 #property
 #ef order_by_label_with_expression(self):
 #""target backend supports ORDER BY a column label within an
 #xpression.

 #asically this::

 #elect data as foo from test order by foo || 'bar'

 #ots of databases including PostgreSQL don't support this,
 #o this is off by default.

 #""
 #eturn exclusions.closed()

 #property
 #ef order_by_collation(self):
 #ef check(config):
 #ry:
 #elf.get_order_by_collation(config)
 #eturn False
 #xcept NotImplementedError:
 #eturn True

 #eturn exclusions.skip_if(check)

 #ef get_order_by_collation(self, config):
 #aise NotImplementedError()

 #property
 #ef unicode_connections(self):
 #""Target driver must support non-ASCII characters being passed at
 #ll.
 #""
 #eturn exclusions.open()

 #property
 #ef graceful_disconnects(self):
 #""Target driver must raise a DBAPI-level exception, such as
 #nterfaceError, when the underlying connection has been closed
 #nd the execute() method is called.
 #""
 #eturn exclusions.open()

 #property
 #ef independent_connections(self):
 #""
 #arget must support simultaneous, independent database connections.
 #""
 #eturn exclusions.open()

 #property
 #ef skip_mysql_on_windows(self):
 #""Catchall for a large variety of MySQL on Windows failures"""
 #eturn exclusions.open()

 #property
 #ef ad_hoc_engines(self):
 #""Test environment must allow ad-hoc engine/connection creation.

 #Bs that scale poorly for many connections, even when closed, i.e.
 #racle, may use the "--low-connections" option which flags this
 #equirement as not present.

 #""
 #eturn exclusions.skip_if(
 #ambda config: config.options.low_connections
 #

 #property
 #ef no_windows(self):
 #eturn exclusions.skip_if(self._running_on_windows())

 #ef _running_on_windows(self):
 #eturn exclusions.LambdaPredicate(
 #ambda: platform.system() == "Windows",
 #escription="running on Windows",
 #

 #property
 #ef timing_intensive(self):
 #eturn exclusions.requires_tag("timing_intensive")

 #property
 #ef memory_intensive(self):
 #eturn exclusions.requires_tag("memory_intensive")

 #property
 #ef threading_with_mock(self):
 #""Mark tests that use threading and mock at the same time - stability
 #ssues have been observed with coverage + python 3.3

 #""
 #eturn exclusions.skip_if(
 #ambda config: util.py3k and config.options.has_coverage,
 #Stability issues with coverage + py3k",
 #

 #property
 #ef sqlalchemy2_stubs(self):
 #ef check(config):
 #ry:
 #_import__("sqlalchemy-stubs.ext.mypy")
 #xcept ImportError:
 #eturn False
 #lse:
 #eturn True

 #eturn exclusions.only_if(check)

 #property
 #ef python2(self):
 #eturn exclusions.skip_if(
 #ambda: sys.version_info >= (3,),
 #Python version 2.xx is required.",
 #

 #property
 #ef python3(self):
 #eturn exclusions.skip_if(
 #ambda: sys.version_info < (3,), "Python version 3.xx is required."
 #

 #property
 #ef pep520(self):
 #eturn self.python36

 #property
 #ef python36(self):
 #eturn exclusions.skip_if(
 #ambda: sys.version_info < (3, 6),
 #Python version 3.6 or greater is required.",
 #

 #property
 #ef python37(self):
 #eturn exclusions.skip_if(
 #ambda: sys.version_info < (3, 7),
 #Python version 3.7 or greater is required.",
 #

 #property
 #ef dataclasses(self):
 #eturn self.python37

 #property
 #ef cpython(self):
 #eturn exclusions.only_if(
 #ambda: util.cpython, "cPython interpreter needed"
 #

 #property
 #ef patch_library(self):
 #ef check_lib():
 #ry:
 #_import__("patch")
 #xcept ImportError:
 #eturn False
 #lse:
 #eturn True

 #eturn exclusions.only_if(check_lib, "patch library needed")

 #property
 #ef non_broken_pickle(self):
 #rom sqlalchemy.util import pickle

 #eturn exclusions.only_if(
 #ambda: util.cpython
 #nd pickle.__name__ == "cPickle"
 #r sys.version_info >= (3, 2),
 #Needs cPickle+cPython or newer Python 3 pickle",
 #

 #property
 #ef predictable_gc(self):
 #""target platform must remove all cycles unconditionally when
 #c.collect() is called, as well as clean out unreferenced subclasses.

 #""
 #eturn self.cpython

 #property
 #ef no_coverage(self):
 #""Test should be skipped if coverage is enabled.

 #his is to block tests that exercise libraries that seem to be
 #ensitive to coverage, such as PostgreSQL notice logging.

 #""
 #eturn exclusions.skip_if(
 #ambda config: config.options.has_coverage,
 #Issues observed when coverage is enabled",
 #

 #ef _has_mysql_on_windows(self, config):
 #eturn False

 #ef _has_mysql_fully_case_sensitive(self, config):
 #eturn False

 #property
 #ef sqlite(self):
 #eturn exclusions.skip_if(lambda: not self._has_sqlite())

 #property
 #ef cextensions(self):
 #eturn exclusions.skip_if(
 #ambda: not util.has_compiled_ext(), "C extensions not installed"
 #

 #ef _has_sqlite(self):
 #rom sqlalchemy import create_engine

 #ry:
 #reate_engine("sqlite://")
 #eturn True
 #xcept ImportError:
 #eturn False

 #property
 #ef async_dialect(self):
 #""dialect makes use of await_() to invoke operations on the DBAPI."""

 #eturn exclusions.closed()

 #property
 #ef computed_columns(self):
 #Supports computed columns"
 #eturn exclusions.closed()

 #property
 #ef computed_columns_stored(self):
 #Supports computed columns with `persisted=True`"
 #eturn exclusions.closed()

 #property
 #ef computed_columns_virtual(self):
 #Supports computed columns with `persisted=False`"
 #eturn exclusions.closed()

 #property
 #ef computed_columns_default_persisted(self):
 #""If the default persistence is virtual or stored when `persisted`
 #s omitted"""
 #eturn exclusions.closed()

 #property
 #ef computed_columns_reflect_persisted(self):
 #""If persistence information is returned by the reflection of
 #omputed columns"""
 #eturn exclusions.closed()

 #property
 #ef supports_distinct_on(self):
 #""If a backend supports the DISTINCT ON in a select"""
 #eturn exclusions.closed()

 #property
 #ef supports_is_distinct_from(self):
 #""Supports some form of "x IS [NOT] DISTINCT FROM y" construct.
 #ifferent dialects will implement their own flavour, e.g.,
 #qlite will emit "x IS NOT y" instead of "x IS DISTINCT FROM y".

 #. seealso::

 #meth:`.ColumnOperators.is_distinct_from`

 #""
 #eturn exclusions.skip_if(
 #ambda config: not config.db.dialect.supports_is_distinct_from,
 #driver doesn't support an IS DISTINCT FROM construct",
 #

 #property
 #ef identity_columns(self):
 #""If a backend supports GENERATED { ALWAYS | BY DEFAULT }
 #S IDENTITY"""
 #eturn exclusions.closed()

 #property
 #ef identity_columns_standard(self):
 #""If a backend supports GENERATED { ALWAYS | BY DEFAULT }
 #S IDENTITY with a standard syntax.
 #his is mainly to exclude MSSql.
 #""
 #eturn exclusions.closed()

 #property
 #ef regexp_match(self):
 #""backend supports the regexp_match operator."""
 #eturn exclusions.closed()

 #property
 #ef regexp_replace(self):
 #""backend supports the regexp_replace operator."""
 #eturn exclusions.closed()

 #property
 #ef fetch_first(self):
 #""backend supports the fetch first clause."""
 #eturn exclusions.closed()

 #property
 #ef fetch_percent(self):
 #""backend supports the fetch first clause with percent."""
 #eturn exclusions.closed()

 #property
 #ef fetch_ties(self):
 #""backend supports the fetch first clause with ties."""
 #eturn exclusions.closed()

 #property
 #ef fetch_no_order_by(self):
 #""backend supports the fetch first without order by"""
 #eturn exclusions.closed()

 #property
 #ef fetch_offset_with_options(self):
 #""backend supports the offset when using fetch first with percent
 #r ties. basically this is "not mssql"
 #""
 #eturn exclusions.closed()

 #property
 #ef autoincrement_without_sequence(self):
 #""If autoincrement=True on a column does not require an explicit
 #equence. This should be false only for oracle.
 #""
 #eturn exclusions.open()
