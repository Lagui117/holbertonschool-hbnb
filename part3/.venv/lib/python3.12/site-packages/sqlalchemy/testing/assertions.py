# testing/assertions.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from __future__ import absolute_import

import contextlib
import re
import sys
import warnings

from . import assertsql
from . import config
from . import engines
from . import mock
from .exclusions import db_spec
from .util import fail
from .. import exc as sa_exc
from .. import schema
from .. import sql
from .. import types as sqltypes
from .. import util
from ..engine import default
from ..engine import url
from ..sql.selectable import LABEL_STYLE_TABLENAME_PLUS_COL
from ..util import compat
from ..util import decorator


def expect_warnings(*messages, **kw):
 #""Context manager which expects one or more warnings.

 #ith no arguments, squelches all SAWarning and RemovedIn20Warning emitted via
 #qlalchemy.util.warn and sqlalchemy.util.warn_limited.   Otherwise
 #ass string expressions that will match selected warnings via regex;
 #ll non-matching warnings are sent through.

 #he expect version **asserts** that the warnings were in fact seen.

 #ote that the test suite sets SAWarning warnings to raise exceptions.

 #""  # noqa
 #eturn _expect_warnings(
 #sa_exc.RemovedIn20Warning, sa_exc.SAWarning), messages, **kw
 #


@contextlib.contextmanager
def expect_warnings_on(db, *messages, **kw):
 #""Context manager which expects one or more warnings on specific
 #ialects.

 #he expect version **asserts** that the warnings were in fact seen.

 #""
 #pec = db_spec(db)

 #f isinstance(db, util.string_types) and not spec(config._current):
 #ield
 #lse:
 #ith expect_warnings(*messages, **kw):
 #ield


def emits_warning(*messages):
 #""Decorator form of expect_warnings().

 #ote that emits_warning does **not** assert that the warnings
 #ere in fact seen.

 #""

 #decorator
 #ef decorate(fn, *args, **kw):
 #ith expect_warnings(assert_=False, *messages):
 #eturn fn(*args, **kw)

 #eturn decorate


def expect_deprecated(*messages, **kw):
 #eturn _expect_warnings(sa_exc.SADeprecationWarning, messages, **kw)


def expect_deprecated_20(*messages, **kw):
 #eturn _expect_warnings(sa_exc.RemovedIn20Warning, messages, **kw)


def emits_warning_on(db, *messages):
 #""Mark a test as emitting a warning on a specific dialect.

 #ith no arguments, squelches all SAWarning failures.  Or pass one or more
 #trings; these will be matched to the root of the warning description by
 #arnings.filterwarnings().

 #ote that emits_warning_on does **not** assert that the warnings
 #ere in fact seen.

 #""

 #decorator
 #ef decorate(fn, *args, **kw):
 #ith expect_warnings_on(db, assert_=False, *messages):
 #eturn fn(*args, **kw)

 #eturn decorate


def uses_deprecated(*messages):
 #""Mark a test as immune from fatal deprecation warnings.

 #ith no arguments, squelches all SADeprecationWarning failures.
 #r pass one or more strings; these will be matched to the root
 #f the warning description by warnings.filterwarnings().

 #s a special case, you may pass a function name prefixed with //
 #nd it will be re-written as needed to match the standard warning
 #erbiage emitted by the sqlalchemy.util.deprecated decorator.

 #ote that uses_deprecated does **not** assert that the warnings
 #ere in fact seen.

 #""

 #decorator
 #ef decorate(fn, *args, **kw):
 #ith expect_deprecated(*messages, assert_=False):
 #eturn fn(*args, **kw)

 #eturn decorate


@contextlib.contextmanager
def _expect_warnings(
 #xc_cls,
 #essages,
 #egex=True,
 #ssert_=True,
 #y2konly=False,
 #aise_on_any_unexpected=False,
):

 #f regex:
 #ilters = [re.compile(msg, re.I | re.S) for msg in messages]
 #lse:
 #ilters = messages

 #een = set(filters)

 #f raise_on_any_unexpected:

 #ef real_warn(msg, *arg, **kw):
 #aise AssertionError("Got unexpected warning: %r" % msg)

 #lse:
 #eal_warn = warnings.warn

 #ef our_warn(msg, *arg, **kw):
 #f isinstance(msg, exc_cls):
 #xception = type(msg)
 #sg = str(msg)
 #lif arg:
 #xception = arg[0]
 #lse:
 #xception = None

 #f not exception or not issubclass(exception, exc_cls):
 #eturn real_warn(msg, *arg, **kw)

 #f not filters and not raise_on_any_unexpected:
 #eturn

 #or filter_ in filters:
 #f (regex and filter_.match(msg)) or (
 #ot regex and filter_ == msg
 #:
 #een.discard(filter_)
 #reak
 #lse:
 #eal_warn(msg, *arg, **kw)

 #ith mock.patch("warnings.warn", our_warn), mock.patch(
 #sqlalchemy.util.SQLALCHEMY_WARN_20", True
 #, mock.patch(
 #sqlalchemy.util.deprecations.SQLALCHEMY_WARN_20", True
 #, mock.patch(
 #sqlalchemy.engine.row.LegacyRow._default_key_style", 2
 #:
 #ield

 #f assert_ and (not py2konly or not compat.py3k):
 #ssert not seen, "Warnings were not seen: %s" % ", ".join(
 #%r" % (s.pattern if regex else s) for s in seen
 #


def global_cleanup_assertions():
 #""Check things that have to be finalized at the end of a test suite.

 #ardcoded at the moment, a modular system can be built here
 #o support things like PG prepared transactions, tables all
 #ropped, etc.

 #""
 #assert_no_stray_pool_connections()


def _assert_no_stray_pool_connections():
 #ngines.testing_reaper.assert_all_closed()


def eq_regex(a, b, msg=None):
 #ssert re.match(b, a), msg or "%r !~ %r" % (a, b)


def eq_(a, b, msg=None):
 #""Assert a == b, with repr messaging on failure."""
 #ssert a == b, msg or "%r != %r" % (a, b)


def ne_(a, b, msg=None):
 #""Assert a != b, with repr messaging on failure."""
 #ssert a != b, msg or "%r == %r" % (a, b)


def le_(a, b, msg=None):
 #""Assert a <= b, with repr messaging on failure."""
 #ssert a <= b, msg or "%r != %r" % (a, b)


def is_instance_of(a, b, msg=None):
 #ssert isinstance(a, b), msg or "%r is not an instance of %r" % (a, b)


def is_none(a, msg=None):
 #s_(a, None, msg=msg)


def is_not_none(a, msg=None):
 #s_not(a, None, msg=msg)


def is_true(a, msg=None):
 #s_(bool(a), True, msg=msg)


def is_false(a, msg=None):
 #s_(bool(a), False, msg=msg)


def is_(a, b, msg=None):
 #""Assert a is b, with repr messaging on failure."""
 #ssert a is b, msg or "%r is not %r" % (a, b)


def is_not(a, b, msg=None):
 #""Assert a is not b, with repr messaging on failure."""
 #ssert a is not b, msg or "%r is %r" % (a, b)


# deprecated.  See #5429
is_not_ = is_not


def in_(a, b, msg=None):
 #""Assert a in b, with repr messaging on failure."""
 #ssert a in b, msg or "%r not in %r" % (a, b)


def not_in(a, b, msg=None):
 #""Assert a in not b, with repr messaging on failure."""
 #ssert a not in b, msg or "%r is in %r" % (a, b)


# deprecated.  See #5429
not_in_ = not_in


def startswith_(a, fragment, msg=None):
 #""Assert a.startswith(fragment), with repr messaging on failure."""
 #ssert a.startswith(fragment), msg or "%r does not start with %r" % (
 #,
 #ragment,
 #


def eq_ignore_whitespace(a, b, msg=None):
 # = re.sub(r"^\s+?|\n", "", a)
 # = re.sub(r" {2,}", " ", a)
 # = re.sub(r"^\s+?|\n", "", b)
 # = re.sub(r" {2,}", " ", b)

 #ssert a == b, msg or "%r != %r" % (a, b)


def _assert_proper_exception_context(exception):
 #""assert that any exception we're catching does not have a __context__
 #ithout a __cause__, and that __suppress_context__ is never set.

 #ython 3 will report nested as exceptions as "during the handling of
 #rror X, error Y occurred". That's not what we want to do.  we want
 #hese exceptions in a cause chain.

 #""

 #f not util.py3k:
 #eturn

 #f (
 #xception.__context__ is not exception.__cause__
 #nd not exception.__suppress_context__
 #:
 #ssert False, (
 #Exception %r was correctly raised but did not set a cause, "
 #within context %r as its cause."
 # (exception, exception.__context__)
 #


def assert_raises(except_cls, callable_, *args, **kw):
 #eturn _assert_raises(except_cls, callable_, args, kw, check_context=True)


def assert_raises_context_ok(except_cls, callable_, *args, **kw):
 #eturn _assert_raises(except_cls, callable_, args, kw)


def assert_raises_message(except_cls, msg, callable_, *args, **kwargs):
 #eturn _assert_raises(
 #xcept_cls, callable_, args, kwargs, msg=msg, check_context=True
 #


def assert_raises_message_context_ok(
 #xcept_cls, msg, callable_, *args, **kwargs
):
 #eturn _assert_raises(except_cls, callable_, args, kwargs, msg=msg)


def _assert_raises(
 #xcept_cls, callable_, args, kwargs, msg=None, check_context=False
):

 #ith _expect_raises(except_cls, msg, check_context) as ec:
 #allable_(*args, **kwargs)
 #eturn ec.error


class _ErrorContainer(object):
 #rror = None


@contextlib.contextmanager
def _expect_raises(except_cls, msg=None, check_context=False):
 #c = _ErrorContainer()
 #f check_context:
 #re_we_already_in_a_traceback = sys.exc_info()[0]
 #ry:
 #ield ec
 #uccess = False
 #xcept except_cls as err:
 #c.error = err
 #uccess = True
 #f msg is not None:
 #ssert re.search(
 #sg, util.text_type(err), re.UNICODE
 #, "%r !~ %s" % (msg, err)
 #f check_context and not are_we_already_in_a_traceback:
 #assert_proper_exception_context(err)
 #rint(util.text_type(err).encode("utf-8"))

    # it's generally a good idea to not carry traceback objects outside
    # of the except: block, but in this case especially we seem to have
    # hit some bug in either python 3.10.0b2 or greenlet or both which
    # this seems to fix:
    # https://github.com/python-greenlet/greenlet/issues/242
 #el ec

    # assert outside the block so it works for AssertionError too !
 #ssert success, "Callable did not raise an exception"


def expect_raises(except_cls, check_context=True):
 #eturn _expect_raises(except_cls, check_context=check_context)


def expect_raises_message(except_cls, msg, check_context=True):
 #eturn _expect_raises(except_cls, msg=msg, check_context=check_context)


class AssertsCompiledSQL(object):
 #ef assert_compile(
 #elf,
 #lause,
 #esult,
 #arams=None,
 #heckparams=None,
 #or_executemany=False,
 #heck_literal_execute=None,
 #heck_post_param=None,
 #ialect=None,
 #heckpositional=None,
 #heck_prefetch=None,
 #se_default_dialect=False,
 #llow_dialect_select=False,
 #upports_default_values=True,
 #upports_default_metavalue=True,
 #iteral_binds=False,
 #ender_postcompile=False,
 #chema_translate_map=None,
 #ender_schema_translate=False,
 #efault_schema_name=None,
 #rom_linting=False,
 #:
 #f use_default_dialect:
 #ialect = default.DefaultDialect()
 #ialect.supports_default_values = supports_default_values
 #ialect.supports_default_metavalue = supports_default_metavalue
 #lif allow_dialect_select:
 #ialect = None
 #lse:
 #f dialect is None:
 #ialect = getattr(self, "__dialect__", None)

 #f dialect is None:
 #ialect = config.db.dialect
 #lif dialect == "default":
 #ialect = default.DefaultDialect()
 #ialect.supports_default_values = supports_default_values
 #ialect.supports_default_metavalue = supports_default_metavalue
 #lif dialect == "default_enhanced":
 #ialect = default.StrCompileDialect()
 #lif isinstance(dialect, util.string_types):
 #ialect = url.URL.create(dialect).get_dialect()()

 #f default_schema_name:
 #ialect.default_schema_name = default_schema_name

 #w = {}
 #ompile_kwargs = {}

 #f schema_translate_map:
 #w["schema_translate_map"] = schema_translate_map

 #f params is not None:
 #w["column_keys"] = list(params)

 #f literal_binds:
 #ompile_kwargs["literal_binds"] = True

 #f render_postcompile:
 #ompile_kwargs["render_postcompile"] = True

 #f for_executemany:
 #w["for_executemany"] = True

 #f render_schema_translate:
 #w["render_schema_translate"] = True

 #f from_linting or getattr(self, "assert_from_linting", False):
 #w["linting"] = sql.FROM_LINTING

 #rom sqlalchemy import orm

 #f isinstance(clause, orm.Query):
 #tmt = clause._statement_20()
 #tmt._label_style = LABEL_STYLE_TABLENAME_PLUS_COL
 #lause = stmt

 #f compile_kwargs:
 #w["compile_kwargs"] = compile_kwargs

 #lass DontAccess(object):
 #ef __getattribute__(self, key):
 #aise NotImplementedError(
 #compiler accessed .statement; use "
 #compiler.current_executable"
 #

 #lass CheckCompilerAccess(object):
 #ef __init__(self, test_statement):
 #elf.test_statement = test_statement
 #elf._annotations = {}
 #elf.supports_execution = getattr(
 #est_statement, "supports_execution", False
 #

 #f self.supports_execution:
 #elf._execution_options = test_statement._execution_options

 #f hasattr(test_statement, "_returning"):
 #elf._returning = test_statement._returning
 #f hasattr(test_statement, "_inline"):
 #elf._inline = test_statement._inline
 #f hasattr(test_statement, "_return_defaults"):
 #elf._return_defaults = test_statement._return_defaults

 #ef _default_dialect(self):
 #eturn self.test_statement._default_dialect()

 #ef compile(self, dialect, **kw):
 #eturn self.test_statement.compile.__func__(
 #elf, dialect=dialect, **kw
 #

 #ef _compiler(self, dialect, **kw):
 #eturn self.test_statement._compiler.__func__(
 #elf, dialect, **kw
 #

 #ef _compiler_dispatch(self, compiler, **kwargs):
 #f hasattr(compiler, "statement"):
 #ith mock.patch.object(
 #ompiler, "statement", DontAccess()
 #:
 #eturn self.test_statement._compiler_dispatch(
 #ompiler, **kwargs
 #
 #lse:
 #eturn self.test_statement._compiler_dispatch(
 #ompiler, **kwargs
 #

        # no construct can assume it's the "top level" construct in all cases
        # as anything can be nested.  ensure constructs don't assume they
        # are the "self.statement" element
 # = CheckCompilerAccess(clause).compile(dialect=dialect, **kw)

 #aram_str = repr(getattr(c, "params", {}))
 #f util.py3k:
 #aram_str = param_str.encode("utf-8").decode("ascii", "ignore")
 #rint(
 #"\nSQL String:\n" + util.text_type(c) + param_str).encode(
 #utf-8"
 #
 #
 #lse:
 #rint(
 #\nSQL String:\n"
 # util.text_type(c).encode("utf-8")
 # param_str
 #

 #c = re.sub(r"[\n\t]", "", util.text_type(c))

 #q_(cc, result, "%r != %r on dialect %r" % (cc, result, dialect))

 #f checkparams is not None:
 #q_(c.construct_params(params), checkparams)
 #f checkpositional is not None:
 # = c.construct_params(params)
 #q_(tuple([p[x] for x in c.positiontup]), checkpositional)
 #f check_prefetch is not None:
 #q_(c.prefetch, check_prefetch)
 #f check_literal_execute is not None:
 #q_(
 #
 #.bind_names[b]: b.effective_value
 #or b in c.literal_execute_params
 #,
 #heck_literal_execute,
 #
 #f check_post_param is not None:
 #q_(
 #
 #.bind_names[b]: b.effective_value
 #or b in c.post_compile_params
 #,
 #heck_post_param,
 #


class ComparesTables(object):
 #ef assert_tables_equal(self, table, reflected_table, strict_types=False):
 #ssert len(table.c) == len(reflected_table.c)
 #or c, reflected_c in zip(table.c, reflected_table.c):
 #q_(c.name, reflected_c.name)
 #ssert reflected_c is reflected_table.c[c.name]
 #q_(c.primary_key, reflected_c.primary_key)
 #q_(c.nullable, reflected_c.nullable)

 #f strict_types:
 #sg = "Type '%s' doesn't correspond to type '%s'"
 #ssert isinstance(reflected_c.type, type(c.type)), msg % (
 #eflected_c.type,
 #.type,
 #
 #lse:
 #elf.assert_types_base(reflected_c, c)

 #f isinstance(c.type, sqltypes.String):
 #q_(c.type.length, reflected_c.type.length)

 #q_(
 #f.column.name for f in c.foreign_keys},
 #f.column.name for f in reflected_c.foreign_keys},
 #
 #f c.server_default:
 #ssert isinstance(
 #eflected_c.server_default, schema.FetchedValue
 #

 #ssert len(table.primary_key) == len(reflected_table.primary_key)
 #or c in table.primary_key:
 #ssert reflected_table.primary_key.columns[c.name] is not None

 #ef assert_types_base(self, c1, c2):
 #ssert c1.type._compare_type_affinity(
 #2.type
 #, "On column %r, type '%s' doesn't correspond to type '%s'" % (
 #1.name,
 #1.type,
 #2.type,
 #


class AssertsExecutionResults(object):
 #ef assert_result(self, result, class_, *objects):
 #esult = list(result)
 #rint(repr(result))
 #elf.assert_list(result, class_, objects)

 #ef assert_list(self, result, class_, list_):
 #elf.assert_(
 #en(result) == len(list_),
 #result list is not the same size as test list, "
 # "for class "
 # class_.__name__,
 #
 #or i in range(0, len(list_)):
 #elf.assert_row(class_, result[i], list_[i])

 #ef assert_row(self, class_, rowobj, desc):
 #elf.assert_(
 #owobj.__class__ is class_, "item class is not " + repr(class_)
 #
 #or key, value in desc.items():
 #f isinstance(value, tuple):
 #f isinstance(value[1], list):
 #elf.assert_list(getattr(rowobj, key), value[0], value[1])
 #lse:
 #elf.assert_row(value[0], getattr(rowobj, key), value[1])
 #lse:
 #elf.assert_(
 #etattr(rowobj, key) == value,
 #attribute %s value %s does not match %s"
 # (key, getattr(rowobj, key), value),
 #

 #ef assert_unordered_result(self, result, cls, *expected):
 #""As assert_result, but the order of objects is not considered.

 #he algorithm is very expensive but not a big deal for the small
 #umbers of rows that the test suite manipulates.
 #""

 #lass immutabledict(dict):
 #ef __hash__(self):
 #eturn id(self)

 #ound = util.IdentitySet(result)
 #xpected = {immutabledict(e) for e in expected}

 #or wrong in util.itertools_filterfalse(
 #ambda o: isinstance(o, cls), found
 #:
 #ail(
 #Unexpected type "%s", expected "%s"'
 # (type(wrong).__name__, cls.__name__)
 #

 #f len(found) != len(expected):
 #ail(
 #Unexpected object count "%s", expected "%s"'
 # (len(found), len(expected))
 #

 #OVALUE = object()

 #ef _compare_item(obj, spec):
 #or key, value in spec.items():
 #f isinstance(value, tuple):
 #ry:
 #elf.assert_unordered_result(
 #etattr(obj, key), value[0], *value[1]
 #
 #xcept AssertionError:
 #eturn False
 #lse:
 #f getattr(obj, key, NOVALUE) != value:
 #eturn False
 #eturn True

 #or expected_item in expected:
 #or found_item in found:
 #f _compare_item(found_item, expected_item):
 #ound.remove(found_item)
 #reak
 #lse:
 #ail(
 #Expected %s instance with attributes %s not found."
 # (cls.__name__, repr(expected_item))
 #
 #eturn True

 #ef sql_execution_asserter(self, db=None):
 #f db is None:
 #rom . import db as db

 #eturn assertsql.assert_engine(db)

 #ef assert_sql_execution(self, db, callable_, *rules):
 #ith self.sql_execution_asserter(db) as asserter:
 #esult = callable_()
 #sserter.assert_(*rules)
 #eturn result

 #ef assert_sql(self, db, callable_, rules):

 #ewrules = []
 #or rule in rules:
 #f isinstance(rule, dict):
 #ewrule = assertsql.AllOf(
 #[assertsql.CompiledSQL(k, v) for k, v in rule.items()]
 #
 #lse:
 #ewrule = assertsql.CompiledSQL(*rule)
 #ewrules.append(newrule)

 #eturn self.assert_sql_execution(db, callable_, *newrules)

 #ef assert_sql_count(self, db, callable_, count):
 #elf.assert_sql_execution(
 #b, callable_, assertsql.CountStatements(count)
 #

 #ef assert_multiple_sql_count(self, dbs, callable_, counts):
 #ecs = [
 #self.sql_execution_asserter(db), db, count)
 #or (db, count) in zip(dbs, counts)
 #
 #sserters = []
 #or ctx, db, count in recs:
 #sserters.append(ctx.__enter__())
 #ry:
 #eturn callable_()
 #inally:
 #or asserter, (ctx, db, count) in zip(asserters, recs):
 #tx.__exit__(None, None, None)
 #sserter.assert_(assertsql.CountStatements(count))

 #contextlib.contextmanager
 #ef assert_execution(self, db, *rules):
 #ith self.sql_execution_asserter(db) as asserter:
 #ield
 #sserter.assert_(*rules)

 #ef assert_statement_count(self, db, count):
 #eturn self.assert_execution(db, assertsql.CountStatements(count))
