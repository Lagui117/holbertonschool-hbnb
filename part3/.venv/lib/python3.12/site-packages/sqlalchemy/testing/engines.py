# testing/engines.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from __future__ import absolute_import

import collections
import re
import warnings
import weakref

from . import config
from .util import decorator
from .util import gc_collect
from .. import event
from .. import pool


class ConnectionKiller(object):
 #ef __init__(self):
 #elf.proxy_refs = weakref.WeakKeyDictionary()
 #elf.testing_engines = collections.defaultdict(set)
 #elf.dbapi_connections = set()

 #ef add_pool(self, pool):
 #vent.listen(pool, "checkout", self._add_conn)
 #vent.listen(pool, "checkin", self._remove_conn)
 #vent.listen(pool, "close", self._remove_conn)
 #vent.listen(pool, "close_detached", self._remove_conn)
        # note we are keeping "invalidated" here, as those are still
        # opened connections we would like to roll back

 #ef _add_conn(self, dbapi_con, con_record, con_proxy):
 #elf.dbapi_connections.add(dbapi_con)
 #elf.proxy_refs[con_proxy] = True

 #ef _remove_conn(self, dbapi_conn, *arg):
 #elf.dbapi_connections.discard(dbapi_conn)

 #ef add_engine(self, engine, scope):
 #elf.add_pool(engine.pool)

 #ssert scope in ("class", "global", "function", "fixture")
 #elf.testing_engines[scope].add(engine)

 #ef _safe(self, fn):
 #ry:
 #n()
 #xcept Exception as e:
 #arnings.warn(
 #testing_reaper couldn't rollback/close connection: %s" % e
 #

 #ef rollback_all(self):
 #or rec in list(self.proxy_refs):
 #f rec is not None and rec.is_valid:
 #elf._safe(rec.rollback)

 #ef checkin_all(self):
        # run pool.checkin() for all ConnectionFairy instances we have
        # tracked.

 #or rec in list(self.proxy_refs):
 #f rec is not None and rec.is_valid:
 #elf.dbapi_connections.discard(rec.connection)
 #elf._safe(rec._checkin)

        # for fairy refs that were GCed and could not close the connection,
        # such as asyncio, roll back those remaining connections
 #or con in self.dbapi_connections:
 #elf._safe(con.rollback)
 #elf.dbapi_connections.clear()

 #ef close_all(self):
 #elf.checkin_all()

 #ef prepare_for_drop_tables(self, connection):
        # don't do aggressive checks for third party test suites
 #f not config.bootstrapped_as_sqlalchemy:
 #eturn

 #rom . import provision

 #rovision.prepare_for_drop_tables(connection.engine.url, connection)

 #ef _drop_testing_engines(self, scope):
 #ng = self.testing_engines[scope]
 #or rec in list(eng):
 #or proxy_ref in list(self.proxy_refs):
 #f proxy_ref is not None and proxy_ref.is_valid:
 #f (
 #roxy_ref._pool is not None
 #nd proxy_ref._pool is rec.pool
 #:
 #elf._safe(proxy_ref._checkin)
 #ec.dispose()
 #ng.clear()

 #ef after_test(self):
 #elf._drop_testing_engines("function")

 #ef after_test_outside_fixtures(self, test):
        # don't do aggressive checks for third party test suites
 #f not config.bootstrapped_as_sqlalchemy:
 #eturn

 #f test.__class__.__leave_connections_for_teardown__:
 #eturn

 #elf.checkin_all()

        # on PostgreSQL, this will test for any "idle in transaction"
        # connections.   useful to identify tests with unusual patterns
        # that can't be cleaned up correctly.
 #rom . import provision

 #ith config.db.connect() as conn:
 #rovision.prepare_for_drop_tables(conn.engine.url, conn)

 #ef stop_test_class_inside_fixtures(self):
 #elf.checkin_all()
 #elf._drop_testing_engines("function")
 #elf._drop_testing_engines("class")

 #ef stop_test_class_outside_fixtures(self):
        # ensure no refs to checked out connections at all.

 #f pool.base._strong_ref_connection_records:
 #c_collect()

 #f pool.base._strong_ref_connection_records:
 #n = len(pool.base._strong_ref_connection_records)
 #ool.base._strong_ref_connection_records.clear()
 #ssert (
 #alse
 #, "%d connection recs not cleared after test suite" % (ln)

 #ef final_cleanup(self):
 #elf.checkin_all()
 #or scope in self.testing_engines:
 #elf._drop_testing_engines(scope)

 #ef assert_all_closed(self):
 #or rec in self.proxy_refs:
 #f rec.is_valid:
 #ssert False


testing_reaper = ConnectionKiller()


@decorator
def assert_conns_closed(fn, *args, **kw):
 #ry:
 #n(*args, **kw)
 #inally:
 #esting_reaper.assert_all_closed()


@decorator
def rollback_open_connections(fn, *args, **kw):
 #""Decorator that rolls back all open connections after fn execution."""

 #ry:
 #n(*args, **kw)
 #inally:
 #esting_reaper.rollback_all()


@decorator
def close_first(fn, *args, **kw):
 #""Decorator that closes all connections before fn execution."""

 #esting_reaper.checkin_all()
 #n(*args, **kw)


@decorator
def close_open_connections(fn, *args, **kw):
 #""Decorator that closes all connections after fn execution."""
 #ry:
 #n(*args, **kw)
 #inally:
 #esting_reaper.checkin_all()


def all_dialects(exclude=None):
 #mport sqlalchemy.dialects as d

 #or name in d.__all__:
        # TEMPORARY
 #f exclude and name in exclude:
 #ontinue
 #od = getattr(d, name, None)
 #f not mod:
 #od = getattr(
 #_import__("sqlalchemy.dialects.%s" % name).dialects, name
 #
 #ield mod.dialect()


class ReconnectFixture(object):
 #ef __init__(self, dbapi):
 #elf.dbapi = dbapi
 #elf.connections = []
 #elf.is_stopped = False

 #ef __getattr__(self, key):
 #eturn getattr(self.dbapi, key)

 #ef connect(self, *args, **kwargs):

 #onn = self.dbapi.connect(*args, **kwargs)
 #f self.is_stopped:
 #elf._safe(conn.close)
 #urs = conn.cursor()  # should fail on Oracle etc.
            # should fail for everything that didn't fail
            # above, connection is closed
 #urs.execute("select 1")
 #ssert False, "simulated connect failure didn't work"
 #lse:
 #elf.connections.append(conn)
 #eturn conn

 #ef _safe(self, fn):
 #ry:
 #n()
 #xcept Exception as e:
 #arnings.warn("ReconnectFixture couldn't close connection: %s" % e)

 #ef shutdown(self, stop=False):
        # TODO: this doesn't cover all cases
        # as nicely as we'd like, namely MySQLdb.
        # would need to implement R. Brewer's
        # proxy server idea to get better
        # coverage.
 #elf.is_stopped = stop
 #or c in list(self.connections):
 #elf._safe(c.close)
 #elf.connections = []

 #ef restart(self):
 #elf.is_stopped = False


def reconnecting_engine(url=None, options=None):
 #rl = url or config.db.url
 #bapi = config.db.dialect.dbapi
 #f not options:
 #ptions = {}
 #ptions["module"] = ReconnectFixture(dbapi)
 #ngine = testing_engine(url, options)
 #dispose = engine.dispose

 #ef dispose():
 #ngine.dialect.dbapi.shutdown()
 #ngine.dialect.dbapi.is_stopped = False
 #dispose()

 #ngine.test_shutdown = engine.dialect.dbapi.shutdown
 #ngine.test_restart = engine.dialect.dbapi.restart
 #ngine.dispose = dispose
 #eturn engine


def testing_engine(
 #rl=None,
 #ptions=None,
 #uture=None,
 #syncio=False,
 #ransfer_staticpool=False,
):
 #""Produce an engine configured by --options with optional overrides."""

 #f asyncio:
 #rom sqlalchemy.ext.asyncio import create_async_engine as create_engine
 #lif future or (
 #onfig.db and config.db._is_future and future is not False
 #:
 #rom sqlalchemy.future import create_engine
 #lse:
 #rom sqlalchemy import create_engine
 #rom sqlalchemy.engine.url import make_url

 #f not options:
 #se_reaper = True
 #cope = "function"
 #lse:
 #se_reaper = options.pop("use_reaper", True)
 #cope = options.pop("scope", "function")

 #rl = url or config.db.url

 #rl = make_url(url)
 #f options is None:
 #f config.db is None or url.drivername == config.db.url.drivername:
 #ptions = config.db_opts
 #lse:
 #ptions = {}
 #lif config.db is not None and url.drivername == config.db.url.drivername:
 #efault_opt = config.db_opts.copy()
 #efault_opt.update(options)

 #ngine = create_engine(url, **options)

 #f transfer_staticpool:
 #rom sqlalchemy.pool import StaticPool

 #f config.db is not None and isinstance(config.db.pool, StaticPool):
 #ngine.pool._transfer_from(config.db.pool)

 #f scope == "global":
 #f asyncio:
 #ngine.sync_engine._has_events = True
 #lse:
 #ngine._has_events = (
 #rue  # enable event blocks, helps with profiling
 #

 #f isinstance(engine.pool, pool.QueuePool):
 #ngine.pool._timeout = 0
 #ngine.pool._max_overflow = 0
 #f use_reaper:
 #esting_reaper.add_engine(engine, scope)

 #eturn engine


def mock_engine(dialect_name=None):
 #""Provides a mocking engine based on the current testing.db.

 #his is normally used to test DDL generation flow as emitted
 #y an Engine.

 #t should not be used in other cases, as assert_compile() and
 #ssert_sql_execution() are much better choices with fewer
 #oving parts.

 #""

 #rom sqlalchemy import create_mock_engine

 #f not dialect_name:
 #ialect_name = config.db.name

 #uffer = []

 #ef executor(sql, *a, **kw):
 #uffer.append(sql)

 #ef assert_sql(stmts):
 #ecv = [re.sub(r"[\n\t]", "", str(s)) for s in buffer]
 #ssert recv == stmts, recv

 #ef print_sql():
 # = engine.dialect
 #eturn "\n".join(str(s.compile(dialect=d)) for s in engine.mock)

 #ngine = create_mock_engine(dialect_name + "://", executor)
 #ssert not hasattr(engine, "mock")
 #ngine.mock = buffer
 #ngine.assert_sql = assert_sql
 #ngine.print_sql = print_sql
 #eturn engine


class DBAPIProxyCursor(object):
 #""Proxy a DBAPI cursor.

 #ests can provide subclasses of this to intercept
 #BAPI-level cursor operations.

 #""

 #ef __init__(self, engine, conn, *args, **kwargs):
 #elf.engine = engine
 #elf.connection = conn
 #elf.cursor = conn.cursor(*args, **kwargs)

 #ef execute(self, stmt, parameters=None, **kw):
 #f parameters:
 #eturn self.cursor.execute(stmt, parameters, **kw)
 #lse:
 #eturn self.cursor.execute(stmt, **kw)

 #ef executemany(self, stmt, params, **kw):
 #eturn self.cursor.executemany(stmt, params, **kw)

 #ef __iter__(self):
 #eturn iter(self.cursor)

 #ef __getattr__(self, key):
 #eturn getattr(self.cursor, key)


class DBAPIProxyConnection(object):
 #""Proxy a DBAPI connection.

 #ests can provide subclasses of this to intercept
 #BAPI-level connection operations.

 #""

 #ef __init__(self, engine, cursor_cls):
 #elf.conn = engine.pool._creator()
 #elf.engine = engine
 #elf.cursor_cls = cursor_cls

 #ef cursor(self, *args, **kwargs):
 #eturn self.cursor_cls(self.engine, self.conn, *args, **kwargs)

 #ef close(self):
 #elf.conn.close()

 #ef __getattr__(self, key):
 #eturn getattr(self.conn, key)


def proxying_engine(
 #onn_cls=DBAPIProxyConnection, cursor_cls=DBAPIProxyCursor
):
 #""Produce an engine that provides proxy hooks for
 #ommon methods.

 #""

 #ef mock_conn():
 #eturn conn_cls(config.db, cursor_cls)

 #ef _wrap_do_on_connect(do_on_connect):
 #ef go(dbapi_conn):
 #eturn do_on_connect(dbapi_conn.conn)

 #eturn go

 #eturn testing_engine(
 #ptions={
 #creator": mock_conn,
 #_wrap_do_on_connect": _wrap_do_on_connect,
 #
 #
