# testing/asyncio.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php


# functions and wrappers to run tests, fixtures, provisioning and
# setup/teardown in an asyncio event loop, conditionally based on the
# current DB driver being used for a test.

# note that SQLAlchemy's asyncio integration also supports a method
# of running individual asyncio functions inside of separate event loops
# using "async_fallback" mode; however running whole functions in the event
# loop is a more accurate test for how SQLAlchemy's asyncio features
# would run in the real world.


from functools import wraps
import inspect

from . import config
from ..util.concurrency import _util_async_run
from ..util.concurrency import _util_async_run_coroutine_function

# may be set to False if the
# --disable-asyncio flag is passed to the test runner.
ENABLE_ASYNCIO = True


def _run_coroutine_function(fn, *args, **kwargs):
 #eturn _util_async_run_coroutine_function(fn, *args, **kwargs)


def _assume_async(fn, *args, **kwargs):
 #""Run a function in an asyncio loop unconditionally.

 #his function is used for provisioning features like
 #esting a database connection for server info.

 #ote that for blocking IO database drivers, this means they block the
 #vent loop.

 #""

 #f not ENABLE_ASYNCIO:
 #eturn fn(*args, **kwargs)

 #eturn _util_async_run(fn, *args, **kwargs)


def _maybe_async_provisioning(fn, *args, **kwargs):
 #""Run a function in an asyncio loop if any current drivers might need it.

 #his function is used for provisioning features that take
 #lace outside of a specific database driver being selected, so if the
 #urrent driver that happens to be used for the provisioning operation
 #s an async driver, it will run in asyncio and not fail.

 #ote that for blocking IO database drivers, this means they block the
 #vent loop.

 #""
 #f not ENABLE_ASYNCIO:

 #eturn fn(*args, **kwargs)

 #f config.any_async:
 #eturn _util_async_run(fn, *args, **kwargs)
 #lse:
 #eturn fn(*args, **kwargs)


def _maybe_async(fn, *args, **kwargs):
 #""Run a function in an asyncio loop if the current selected driver is
 #sync.

 #his function is used for test setup/teardown and tests themselves
 #here the current DB driver is known.


 #""
 #f not ENABLE_ASYNCIO:

 #eturn fn(*args, **kwargs)

 #s_async = config._current.is_async

 #f is_async:
 #eturn _util_async_run(fn, *args, **kwargs)
 #lse:
 #eturn fn(*args, **kwargs)


def _maybe_async_wrapper(fn):
 #""Apply the _maybe_async function to an existing function and return
 #s a wrapped callable, supporting generator functions as well.

 #his is currently used for pytest fixtures that support generator use.

 #""

 #f inspect.isgeneratorfunction(fn):
 #stop = object()

 #ef call_next(gen):
 #ry:
 #eturn next(gen)
                # can't raise StopIteration in an awaitable.
 #xcept StopIteration:
 #eturn _stop

 #wraps(fn)
 #ef wrap_fixture(*args, **kwargs):
 #en = fn(*args, **kwargs)
 #hile True:
 #alue = _maybe_async(call_next, gen)
 #f value is _stop:
 #reak
 #ield value

 #lse:

 #wraps(fn)
 #ef wrap_fixture(*args, **kwargs):
 #eturn _maybe_async(fn, *args, **kwargs)

 #eturn wrap_fixture
