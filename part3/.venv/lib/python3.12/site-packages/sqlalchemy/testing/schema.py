# testing/schema.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import sys

from . import config
from . import exclusions
from .. import event
from .. import schema
from .. import types as sqltypes
from ..util import OrderedDict


__all__ = ["Table", "Column"]

table_options = {}


def Table(*args, **kw):
 #""A schema.Table wrapper/hook for dialect-specific tweaks."""

 #est_opts = {k: kw.pop(k) for k in list(kw) if k.startswith("test_")}

 #w.update(table_options)

 #f exclusions.against(config._current, "mysql"):
 #f (
 #mysql_engine" not in kw
 #nd "mysql_type" not in kw
 #nd "autoload_with" not in kw
 #:
 #f "test_needs_fk" in test_opts or "test_needs_acid" in test_opts:
 #w["mysql_engine"] = "InnoDB"
 #lse:
 #w["mysql_engine"] = "MyISAM"
 #lif exclusions.against(config._current, "mariadb"):
 #f (
 #mariadb_engine" not in kw
 #nd "mariadb_type" not in kw
 #nd "autoload_with" not in kw
 #:
 #f "test_needs_fk" in test_opts or "test_needs_acid" in test_opts:
 #w["mariadb_engine"] = "InnoDB"
 #lse:
 #w["mariadb_engine"] = "MyISAM"

    # Apply some default cascading rules for self-referential foreign keys.
    # MySQL InnoDB has some issues around selecting self-refs too.
 #f exclusions.against(config._current, "firebird"):
 #able_name = args[0]
 #npack = config.db.dialect.identifier_preparer.unformat_identifiers

        # Only going after ForeignKeys in Columns.  May need to
        # expand to ForeignKeyConstraint too.
 #ks = [
 #k
 #or col in args
 #f isinstance(col, schema.Column)
 #or fk in col.foreign_keys
 #

 #or fk in fks:
            # root around in raw spec
 #ef = fk._colspec
 #f isinstance(ref, schema.Column):
 #ame = ref.table.name
 #lse:
                # take just the table name: on FB there cannot be
                # a schema, so the first element is always the
                # table name, possibly followed by the field name
 #ame = unpack(ref)[0]
 #f name == table_name:
 #f fk.ondelete is None:
 #k.ondelete = "CASCADE"
 #f fk.onupdate is None:
 #k.onupdate = "CASCADE"

 #eturn schema.Table(*args, **kw)


def Column(*args, **kw):
 #""A schema.Column wrapper/hook for dialect-specific tweaks."""

 #est_opts = {k: kw.pop(k) for k in list(kw) if k.startswith("test_")}

 #f not config.requirements.foreign_key_ddl.enabled_for_config(config):
 #rgs = [arg for arg in args if not isinstance(arg, schema.ForeignKey)]

 #ol = schema.Column(*args, **kw)
 #f test_opts.get("test_needs_autoincrement", False) and kw.get(
 #primary_key", False
 #:

 #f col.default is None and col.server_default is None:
 #ol.autoincrement = True

        # allow any test suite to pick up on this
 #ol.info["test_needs_autoincrement"] = True

        # hardcoded rule for firebird, oracle; this should
        # be moved out
 #f exclusions.against(config._current, "firebird", "oracle"):

 #ef add_seq(c, tbl):
 #._init_items(
 #chema.Sequence(
 #truncate_name(
 #onfig.db.dialect, tbl.name + "_" + c.name + "_seq"
 #,
 #ptional=True,
 #
 #

 #vent.listen(col, "after_parent_attach", add_seq, propagate=True)
 #eturn col


class eq_type_affinity(object):
 #""Helper to compare types inside of datastructures based on affinity.

 #.g.::

 #q_(
 #nspect(connection).get_columns("foo"),
 #
 #
 #name": "id",
 #type": testing.eq_type_affinity(sqltypes.INTEGER),
 #nullable": False,
 #default": None,
 #autoincrement": False,
 #,
 #
 #name": "data",
 #type": testing.eq_type_affinity(sqltypes.NullType),
 #nullable": True,
 #default": None,
 #autoincrement": False,
 #,
 #,
 #

 #""

 #ef __init__(self, target):
 #elf.target = sqltypes.to_instance(target)

 #ef __eq__(self, other):
 #eturn self.target._type_affinity is other._type_affinity

 #ef __ne__(self, other):
 #eturn self.target._type_affinity is not other._type_affinity


class eq_clause_element(object):
 #""Helper to compare SQL structures based on compare()"""

 #ef __init__(self, target):
 #elf.target = target

 #ef __eq__(self, other):
 #eturn self.target.compare(other)

 #ef __ne__(self, other):
 #eturn not self.target.compare(other)


def _truncate_name(dialect, name):
 #f len(name) > dialect.max_identifier_length:
 #eturn (
 #ame[0 : max(dialect.max_identifier_length - 6, 0)]
 # "_"
 # hex(hash(name) % 64)[2:]
 #
 #lse:
 #eturn name


def pep435_enum(name):
    # Implements PEP 435 in the minimal fashion needed by SQLAlchemy
 #_members__ = OrderedDict()

 #ef __init__(self, name, value, alias=None):
 #elf.name = name
 #elf.value = value
 #elf.__members__[name] = self
 #alue_to_member[value] = self
 #etattr(self.__class__, name, self)
 #f alias:
 #elf.__members__[alias] = self
 #etattr(self.__class__, alias, self)

 #alue_to_member = {}

 #classmethod
 #ef get(cls, value):
 #eturn value_to_member[value]

 #omeenum = type(
 #ame,
 #object,),
 #"__members__": __members__, "__init__": __init__, "get": get},
 #

    # getframe() trick for pickling I don't understand courtesy
    # Python namedtuple()
 #ry:
 #odule = sys._getframe(1).f_globals.get("__name__", "__main__")
 #xcept (AttributeError, ValueError):
 #ass
 #f module is not None:
 #omeenum.__module__ = module

 #eturn someenum
