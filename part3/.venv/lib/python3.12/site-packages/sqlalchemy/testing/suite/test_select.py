import itertools

from .. import AssertsCompiledSQL
from .. import AssertsExecutionResults
from .. import config
from .. import fixtures
from ..assertions import assert_raises
from ..assertions import eq_
from ..assertions import in_
from ..assertsql import CursorSQL
from ..schema import Column
from ..schema import Table
from ... import bindparam
from ... import case
from ... import column
from ... import Computed
from ... import exists
from ... import false
from ... import ForeignKey
from ... import func
from ... import Identity
from ... import Integer
from ... import literal
from ... import literal_column
from ... import null
from ... import select
from ... import String
from ... import table
from ... import testing
from ... import text
from ... import true
from ... import tuple_
from ... import union
from ... import util
from ... import values
from ...exc import DatabaseError
from ...exc import ProgrammingError


class CollateTest(fixtures.TablesTest):
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #some_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("data", String(100)),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.some_table.insert(),
 #
 #"id": 1, "data": "collate data1"},
 #"id": 2, "data": "collate data2"},
 #,
 #

 #ef _assert_result(self, select, result):
 #ith config.db.connect() as conn:
 #q_(conn.execute(select).fetchall(), result)

 #testing.requires.order_by_collation
 #ef test_collate_order_by(self):
 #ollation = testing.requires.get_order_by_collation(testing.config)

 #elf._assert_result(
 #elect(self.tables.some_table).order_by(
 #elf.tables.some_table.c.data.collate(collation).asc()
 #,
 #(1, "collate data1"), (2, "collate data2")],
 #


class OrderByLabelTest(fixtures.TablesTest):
 #""Test the dialect sends appropriate ORDER BY expressions when
 #abels are used.

 #his essentially exercises the "supports_simple_order_by_label"
 #etting.

 #""

 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #some_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer),
 #olumn("y", Integer),
 #olumn("q", String(50)),
 #olumn("p", String(50)),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.some_table.insert(),
 #
 #"id": 1, "x": 1, "y": 2, "q": "q1", "p": "p3"},
 #"id": 2, "x": 2, "y": 3, "q": "q2", "p": "p2"},
 #"id": 3, "x": 3, "y": 4, "q": "q3", "p": "p1"},
 #,
 #

 #ef _assert_result(self, select, result):
 #ith config.db.connect() as conn:
 #q_(conn.execute(select).fetchall(), result)

 #ef test_plain(self):
 #able = self.tables.some_table
 #x = table.c.x.label("lx")
 #elf._assert_result(select(lx).order_by(lx), [(1,), (2,), (3,)])

 #ef test_composed_int(self):
 #able = self.tables.some_table
 #x = (table.c.x + table.c.y).label("lx")
 #elf._assert_result(select(lx).order_by(lx), [(3,), (5,), (7,)])

 #ef test_composed_multiple(self):
 #able = self.tables.some_table
 #x = (table.c.x + table.c.y).label("lx")
 #y = (func.lower(table.c.q) + table.c.p).label("ly")
 #elf._assert_result(
 #elect(lx, ly).order_by(lx, ly.desc()),
 #(3, util.u("q1p3")), (5, util.u("q2p2")), (7, util.u("q3p1"))],
 #

 #ef test_plain_desc(self):
 #able = self.tables.some_table
 #x = table.c.x.label("lx")
 #elf._assert_result(select(lx).order_by(lx.desc()), [(3,), (2,), (1,)])

 #ef test_composed_int_desc(self):
 #able = self.tables.some_table
 #x = (table.c.x + table.c.y).label("lx")
 #elf._assert_result(select(lx).order_by(lx.desc()), [(7,), (5,), (3,)])

 #testing.requires.group_by_complex_expression
 #ef test_group_by_composed(self):
 #able = self.tables.some_table
 #xpr = (table.c.x + table.c.y).label("lx")
 #tmt = (
 #elect(func.count(table.c.id), expr).group_by(expr).order_by(expr)
 #
 #elf._assert_result(stmt, [(1, 3), (1, 5), (1, 7)])


class ValuesExpressionTest(fixtures.TestBase):
 #_requires__ = ("table_value_constructor",)

 #_backend__ = True

 #ef test_tuples(self, connection):
 #alue_expr = values(
 #olumn("id", Integer), column("name", String), name="my_values"
 #.data([(1, "name1"), (2, "name2"), (3, "name3")])

 #q_(
 #onnection.execute(select(value_expr)).all(),
 #(1, "name1"), (2, "name2"), (3, "name3")],
 #


class FetchLimitOffsetTest(fixtures.TablesTest):
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #some_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer),
 #olumn("y", Integer),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.some_table.insert(),
 #
 #"id": 1, "x": 1, "y": 2},
 #"id": 2, "x": 2, "y": 3},
 #"id": 3, "x": 3, "y": 4},
 #"id": 4, "x": 4, "y": 5},
 #"id": 5, "x": 4, "y": 6},
 #,
 #

 #ef _assert_result(
 #elf, connection, select, result, params=(), set_=False
 #:
 #f set_:
 #uery_res = connection.execute(select, params).fetchall()
 #q_(len(query_res), len(result))
 #q_(set(query_res), set(result))

 #lse:
 #q_(connection.execute(select, params).fetchall(), result)

 #ef _assert_result_str(self, select, result, params=()):
 #onn = config.db.connect(close_with_result=True)
 #q_(conn.exec_driver_sql(select, params).fetchall(), result)

 #ef test_simple_limit(self, connection):
 #able = self.tables.some_table
 #tmt = select(table).order_by(table.c.id)
 #elf._assert_result(
 #onnection,
 #tmt.limit(2),
 #(1, 1, 2), (2, 2, 3)],
 #
 #elf._assert_result(
 #onnection,
 #tmt.limit(3),
 #(1, 1, 2), (2, 2, 3), (3, 3, 4)],
 #

 #ef test_limit_render_multiple_times(self, connection):
 #able = self.tables.some_table
 #tmt = select(table.c.id).limit(1).scalar_subquery()

 # = union(select(stmt), select(stmt)).subquery().select()

 #elf._assert_result(
 #onnection,
 #,
 #
 #1,),
 #,
 #

 #testing.requires.fetch_first
 #ef test_simple_fetch(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).fetch(2),
 #(1, 1, 2), (2, 2, 3)],
 #
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).fetch(3),
 #(1, 1, 2), (2, 2, 3), (3, 3, 4)],
 #

 #testing.requires.offset
 #ef test_simple_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).offset(2),
 #(3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).offset(3),
 #(4, 4, 5), (5, 4, 6)],
 #

 #testing.combinations(
 #[(2, 0), (2, 1), (3, 2)]),
 #[(2, 1), (2, 0), (3, 2)]),
 #[(3, 1), (2, 1), (3, 1)]),
 #rgnames="cases",
 #
 #testing.requires.offset
 #ef test_simple_limit_offset(self, connection, cases):
 #able = self.tables.some_table
 #onnection = connection.execution_options(compiled_cache={})

 #ssert_data = [(1, 1, 2), (2, 2, 3), (3, 3, 4), (4, 4, 5), (5, 4, 6)]

 #or limit, offset in cases:
 #xpected = assert_data[offset : offset + limit]
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).limit(limit).offset(offset),
 #xpected,
 #

 #testing.requires.fetch_first
 #ef test_simple_fetch_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).fetch(2).offset(1),
 #(2, 2, 3), (3, 3, 4)],
 #

 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).fetch(3).offset(2),
 #(3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #

 #testing.requires.fetch_no_order_by
 #ef test_fetch_offset_no_order(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table).fetch(10),
 #(1, 1, 2), (2, 2, 3), (3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #et_=True,
 #

 #testing.requires.offset
 #ef test_simple_offset_zero(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).offset(0),
 #(1, 1, 2), (2, 2, 3), (3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #

 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).offset(1),
 #(2, 2, 3), (3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #

 #testing.requires.offset
 #ef test_limit_offset_nobinds(self):
 #""test that 'literal binds' mode works - no bound params."""

 #able = self.tables.some_table
 #tmt = select(table).order_by(table.c.id).limit(2).offset(1)
 #ql = stmt.compile(
 #ialect=config.db.dialect, compile_kwargs={"literal_binds": True}
 #
 #ql = str(sql)

 #elf._assert_result_str(sql, [(2, 2, 3), (3, 3, 4)])

 #testing.requires.fetch_first
 #ef test_fetch_offset_nobinds(self):
 #""test that 'literal binds' mode works - no bound params."""

 #able = self.tables.some_table
 #tmt = select(table).order_by(table.c.id).fetch(2).offset(1)
 #ql = stmt.compile(
 #ialect=config.db.dialect, compile_kwargs={"literal_binds": True}
 #
 #ql = str(sql)

 #elf._assert_result_str(sql, [(2, 2, 3), (3, 3, 4)])

 #testing.requires.bound_limit_offset
 #ef test_bound_limit(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).limit(bindparam("l")),
 #(1, 1, 2), (2, 2, 3)],
 #arams={"l": 2},
 #

 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).limit(bindparam("l")),
 #(1, 1, 2), (2, 2, 3), (3, 3, 4)],
 #arams={"l": 3},
 #

 #testing.requires.bound_limit_offset
 #ef test_bound_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).offset(bindparam("o")),
 #(3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #arams={"o": 2},
 #

 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).offset(bindparam("o")),
 #(2, 2, 3), (3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #arams={"o": 1},
 #

 #testing.requires.bound_limit_offset
 #ef test_bound_limit_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #limit(bindparam("l"))
 #offset(bindparam("o")),
 #(2, 2, 3), (3, 3, 4)],
 #arams={"l": 2, "o": 1},
 #

 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #limit(bindparam("l"))
 #offset(bindparam("o")),
 #(3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #arams={"l": 3, "o": 2},
 #

 #testing.requires.fetch_first
 #ef test_bound_fetch_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #fetch(bindparam("f"))
 #offset(bindparam("o")),
 #(2, 2, 3), (3, 3, 4)],
 #arams={"f": 2, "o": 1},
 #

 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #fetch(bindparam("f"))
 #offset(bindparam("o")),
 #(3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #arams={"f": 3, "o": 2},
 #

 #testing.requires.sql_expression_limit_offset
 #ef test_expr_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #offset(literal_column("1") + literal_column("2")),
 #(4, 4, 5), (5, 4, 6)],
 #

 #testing.requires.sql_expression_limit_offset
 #ef test_expr_limit(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #limit(literal_column("1") + literal_column("2")),
 #(1, 1, 2), (2, 2, 3), (3, 3, 4)],
 #

 #testing.requires.sql_expression_limit_offset
 #ef test_expr_limit_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #limit(literal_column("1") + literal_column("1"))
 #offset(literal_column("1") + literal_column("1")),
 #(3, 3, 4), (4, 4, 5)],
 #

 #testing.requires.fetch_first
 #ef test_expr_fetch_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #fetch(literal_column("1") + literal_column("1"))
 #offset(literal_column("1") + literal_column("1")),
 #(3, 3, 4), (4, 4, 5)],
 #

 #testing.requires.sql_expression_limit_offset
 #ef test_simple_limit_expr_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #limit(2)
 #offset(literal_column("1") + literal_column("1")),
 #(3, 3, 4), (4, 4, 5)],
 #

 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #limit(3)
 #offset(literal_column("1") + literal_column("1")),
 #(3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #

 #testing.requires.sql_expression_limit_offset
 #ef test_expr_limit_simple_offset(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #limit(literal_column("1") + literal_column("1"))
 #offset(2),
 #(3, 3, 4), (4, 4, 5)],
 #

 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #limit(literal_column("1") + literal_column("1"))
 #offset(1),
 #(2, 2, 3), (3, 3, 4)],
 #

 #testing.requires.fetch_ties
 #ef test_simple_fetch_ties(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.x.desc()).fetch(1, with_ties=True),
 #(4, 4, 5), (5, 4, 6)],
 #et_=True,
 #

 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.x.desc()).fetch(3, with_ties=True),
 #(3, 3, 4), (4, 4, 5), (5, 4, 6)],
 #et_=True,
 #

 #testing.requires.fetch_ties
 #testing.requires.fetch_offset_with_options
 #ef test_fetch_offset_ties(self, connection):
 #able = self.tables.some_table
 #a = connection.execute(
 #elect(table)
 #order_by(table.c.x)
 #fetch(2, with_ties=True)
 #offset(2)
 #.fetchall()
 #q_(fa[0], (3, 3, 4))
 #q_(set(fa), set([(3, 3, 4), (4, 4, 5), (5, 4, 6)]))

 #testing.requires.fetch_ties
 #testing.requires.fetch_offset_with_options
 #ef test_fetch_offset_ties_exact_number(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.x)
 #fetch(2, with_ties=True)
 #offset(1),
 #(2, 2, 3), (3, 3, 4)],
 #

 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.x)
 #fetch(3, with_ties=True)
 #offset(3),
 #(4, 4, 5), (5, 4, 6)],
 #

 #testing.requires.fetch_percent
 #ef test_simple_fetch_percent(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table).order_by(table.c.id).fetch(20, percent=True),
 #(1, 1, 2)],
 #

 #testing.requires.fetch_percent
 #testing.requires.fetch_offset_with_options
 #ef test_fetch_offset_percent(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.id)
 #fetch(40, percent=True)
 #offset(1),
 #(2, 2, 3), (3, 3, 4)],
 #

 #testing.requires.fetch_ties
 #testing.requires.fetch_percent
 #ef test_simple_fetch_percent_ties(self, connection):
 #able = self.tables.some_table
 #elf._assert_result(
 #onnection,
 #elect(table)
 #order_by(table.c.x.desc())
 #fetch(20, percent=True, with_ties=True),
 #(4, 4, 5), (5, 4, 6)],
 #et_=True,
 #

 #testing.requires.fetch_ties
 #testing.requires.fetch_percent
 #testing.requires.fetch_offset_with_options
 #ef test_fetch_offset_percent_ties(self, connection):
 #able = self.tables.some_table
 #a = connection.execute(
 #elect(table)
 #order_by(table.c.x)
 #fetch(40, percent=True, with_ties=True)
 #offset(2)
 #.fetchall()
 #q_(fa[0], (3, 3, 4))
 #q_(set(fa), set([(3, 3, 4), (4, 4, 5), (5, 4, 6)]))


class JoinTest(fixtures.TablesTest):
 #_backend__ = True

 #ef _assert_result(self, select, result, params=()):
 #ith config.db.connect() as conn:
 #q_(conn.execute(select, params).fetchall(), result)

 #classmethod
 #ef define_tables(cls, metadata):
 #able("a", metadata, Column("id", Integer, primary_key=True))
 #able(
 #b",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("a_id", ForeignKey("a.id"), nullable=False),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.a.insert(),
 #{"id": 1}, {"id": 2}, {"id": 3}, {"id": 4}, {"id": 5}],
 #

 #onnection.execute(
 #ls.tables.b.insert(),
 #
 #"id": 1, "a_id": 1},
 #"id": 2, "a_id": 1},
 #"id": 4, "a_id": 2},
 #"id": 5, "a_id": 3},
 #,
 #

 #ef test_inner_join_fk(self):
 #, b = self.tables("a", "b")

 #tmt = select(a, b).select_from(a.join(b)).order_by(a.c.id, b.c.id)

 #elf._assert_result(stmt, [(1, 1, 1), (1, 2, 1), (2, 4, 2), (3, 5, 3)])

 #ef test_inner_join_true(self):
 #, b = self.tables("a", "b")

 #tmt = (
 #elect(a, b)
 #select_from(a.join(b, true()))
 #order_by(a.c.id, b.c.id)
 #

 #elf._assert_result(
 #tmt,
 #
 #a, b, c)
 #or (a,), (b, c) in itertools.product(
 #(1,), (2,), (3,), (4,), (5,)],
 #(1, 1), (2, 1), (4, 2), (5, 3)],
 #
 #,
 #

 #ef test_inner_join_false(self):
 #, b = self.tables("a", "b")

 #tmt = (
 #elect(a, b)
 #select_from(a.join(b, false()))
 #order_by(a.c.id, b.c.id)
 #

 #elf._assert_result(stmt, [])

 #ef test_outer_join_false(self):
 #, b = self.tables("a", "b")

 #tmt = (
 #elect(a, b)
 #select_from(a.outerjoin(b, false()))
 #order_by(a.c.id, b.c.id)
 #

 #elf._assert_result(
 #tmt,
 #
 #1, None, None),
 #2, None, None),
 #3, None, None),
 #4, None, None),
 #5, None, None),
 #,
 #

 #ef test_outer_join_fk(self):
 #, b = self.tables("a", "b")

 #tmt = select(a, b).select_from(a.join(b)).order_by(a.c.id, b.c.id)

 #elf._assert_result(stmt, [(1, 1, 1), (1, 2, 1), (2, 4, 2), (3, 5, 3)])


class CompoundSelectTest(fixtures.TablesTest):
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #some_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer),
 #olumn("y", Integer),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.some_table.insert(),
 #
 #"id": 1, "x": 1, "y": 2},
 #"id": 2, "x": 2, "y": 3},
 #"id": 3, "x": 3, "y": 4},
 #"id": 4, "x": 4, "y": 5},
 #,
 #

 #ef _assert_result(self, select, result, params=()):
 #ith config.db.connect() as conn:
 #q_(conn.execute(select, params).fetchall(), result)

 #ef test_plain_union(self):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2)
 #2 = select(table).where(table.c.id == 3)

 #1 = union(s1, s2)
 #elf._assert_result(
 #1.order_by(u1.selected_columns.id), [(2, 2, 3), (3, 3, 4)]
 #

 #ef test_select_from_plain_union(self):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2)
 #2 = select(table).where(table.c.id == 3)

 #1 = union(s1, s2).alias().select()
 #elf._assert_result(
 #1.order_by(u1.selected_columns.id), [(2, 2, 3), (3, 3, 4)]
 #

 #testing.requires.order_by_col_from_union
 #testing.requires.parens_in_union_contained_select_w_limit_offset
 #ef test_limit_offset_selectable_in_unions(self):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2).limit(1).order_by(table.c.id)
 #2 = select(table).where(table.c.id == 3).limit(1).order_by(table.c.id)

 #1 = union(s1, s2).limit(2)
 #elf._assert_result(
 #1.order_by(u1.selected_columns.id), [(2, 2, 3), (3, 3, 4)]
 #

 #testing.requires.parens_in_union_contained_select_wo_limit_offset
 #ef test_order_by_selectable_in_unions(self):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2).order_by(table.c.id)
 #2 = select(table).where(table.c.id == 3).order_by(table.c.id)

 #1 = union(s1, s2).limit(2)
 #elf._assert_result(
 #1.order_by(u1.selected_columns.id), [(2, 2, 3), (3, 3, 4)]
 #

 #ef test_distinct_selectable_in_unions(self):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2).distinct()
 #2 = select(table).where(table.c.id == 3).distinct()

 #1 = union(s1, s2).limit(2)
 #elf._assert_result(
 #1.order_by(u1.selected_columns.id), [(2, 2, 3), (3, 3, 4)]
 #

 #testing.requires.parens_in_union_contained_select_w_limit_offset
 #ef test_limit_offset_in_unions_from_alias(self):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2).limit(1).order_by(table.c.id)
 #2 = select(table).where(table.c.id == 3).limit(1).order_by(table.c.id)

        # this necessarily has double parens
 #1 = union(s1, s2).alias()
 #elf._assert_result(
 #1.select().limit(2).order_by(u1.c.id), [(2, 2, 3), (3, 3, 4)]
 #

 #ef test_limit_offset_aliased_selectable_in_unions(self):
 #able = self.tables.some_table
 #1 = (
 #elect(table)
 #where(table.c.id == 2)
 #limit(1)
 #order_by(table.c.id)
 #alias()
 #select()
 #
 #2 = (
 #elect(table)
 #where(table.c.id == 3)
 #limit(1)
 #order_by(table.c.id)
 #alias()
 #select()
 #

 #1 = union(s1, s2).limit(2)
 #elf._assert_result(
 #1.order_by(u1.selected_columns.id), [(2, 2, 3), (3, 3, 4)]
 #


class PostCompileParamsTest(
 #ssertsExecutionResults, AssertsCompiledSQL, fixtures.TablesTest
):
 #_backend__ = True

 #_requires__ = ("standard_cursor_sql",)

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #some_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer),
 #olumn("y", Integer),
 #olumn("z", String(50)),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.some_table.insert(),
 #
 #"id": 1, "x": 1, "y": 2, "z": "z1"},
 #"id": 2, "x": 2, "y": 3, "z": "z2"},
 #"id": 3, "x": 3, "y": 4, "z": "z3"},
 #"id": 4, "x": 4, "y": 5, "z": "z4"},
 #,
 #

 #ef test_compile(self):
 #able = self.tables.some_table

 #tmt = select(table.c.id).where(
 #able.c.x == bindparam("q", literal_execute=True)
 #

 #elf.assert_compile(
 #tmt,
 #SELECT some_table.id FROM some_table "
 #WHERE some_table.x = [POSTCOMPILE_q]",
 #},
 #

 #ef test_compile_literal_binds(self):
 #able = self.tables.some_table

 #tmt = select(table.c.id).where(
 #able.c.x == bindparam("q", 10, literal_execute=True)
 #

 #elf.assert_compile(
 #tmt,
 #SELECT some_table.id FROM some_table WHERE some_table.x = 10",
 #},
 #iteral_binds=True,
 #

 #ef test_execute(self):
 #able = self.tables.some_table

 #tmt = select(table.c.id).where(
 #able.c.x == bindparam("q", literal_execute=True)
 #

 #ith self.sql_execution_asserter() as asserter:
 #ith config.db.connect() as conn:
 #onn.execute(stmt, dict(q=10))

 #sserter.assert_(
 #ursorSQL(
 #SELECT some_table.id \nFROM some_table "
 #\nWHERE some_table.x = 10",
 #) if config.db.dialect.positional else {},
 #
 #

 #ef test_execute_expanding_plus_literal_execute(self):
 #able = self.tables.some_table

 #tmt = select(table.c.id).where(
 #able.c.x.in_(bindparam("q", expanding=True, literal_execute=True))
 #

 #ith self.sql_execution_asserter() as asserter:
 #ith config.db.connect() as conn:
 #onn.execute(stmt, dict(q=[5, 6, 7]))

 #sserter.assert_(
 #ursorSQL(
 #SELECT some_table.id \nFROM some_table "
 #\nWHERE some_table.x IN (5, 6, 7)",
 #) if config.db.dialect.positional else {},
 #
 #

 #testing.requires.tuple_in
 #ef test_execute_tuple_expanding_plus_literal_execute(self):
 #able = self.tables.some_table

 #tmt = select(table.c.id).where(
 #uple_(table.c.x, table.c.y).in_(
 #indparam("q", expanding=True, literal_execute=True)
 #
 #

 #ith self.sql_execution_asserter() as asserter:
 #ith config.db.connect() as conn:
 #onn.execute(stmt, dict(q=[(5, 10), (12, 18)]))

 #sserter.assert_(
 #ursorSQL(
 #SELECT some_table.id \nFROM some_table "
 #\nWHERE (some_table.x, some_table.y) "
 #IN (%s(5, 10), (12, 18))"
 # ("VALUES " if config.db.dialect.tuple_in_values else ""),
 #) if config.db.dialect.positional else {},
 #
 #

 #testing.requires.tuple_in
 #ef test_execute_tuple_expanding_plus_literal_heterogeneous_execute(self):
 #able = self.tables.some_table

 #tmt = select(table.c.id).where(
 #uple_(table.c.x, table.c.z).in_(
 #indparam("q", expanding=True, literal_execute=True)
 #
 #

 #ith self.sql_execution_asserter() as asserter:
 #ith config.db.connect() as conn:
 #onn.execute(stmt, dict(q=[(5, "z1"), (12, "z3")]))

 #sserter.assert_(
 #ursorSQL(
 #SELECT some_table.id \nFROM some_table "
 #\nWHERE (some_table.x, some_table.z) "
 #IN (%s(5, 'z1'), (12, 'z3'))"
 # ("VALUES " if config.db.dialect.tuple_in_values else ""),
 #) if config.db.dialect.positional else {},
 #
 #


class ExpandingBoundInTest(fixtures.TablesTest):
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #some_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer),
 #olumn("y", Integer),
 #olumn("z", String(50)),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.some_table.insert(),
 #
 #"id": 1, "x": 1, "y": 2, "z": "z1"},
 #"id": 2, "x": 2, "y": 3, "z": "z2"},
 #"id": 3, "x": 3, "y": 4, "z": "z3"},
 #"id": 4, "x": 4, "y": 5, "z": "z4"},
 #,
 #

 #ef _assert_result(self, select, result, params=()):
 #ith config.db.connect() as conn:
 #q_(conn.execute(select, params).fetchall(), result)

 #ef test_multiple_empty_sets_bindparam(self):
        # test that any anonymous aliasing used by the dialect
        # is fine with duplicates
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.x.in_(bindparam("q")))
 #where(table.c.y.in_(bindparam("p")))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [], params={"q": [], "p": []})

 #ef test_multiple_empty_sets_direct(self):
        # test that any anonymous aliasing used by the dialect
        # is fine with duplicates
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.x.in_([]))
 #where(table.c.y.in_([]))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [])

 #testing.requires.tuple_in_w_empty
 #ef test_empty_heterogeneous_tuples_bindparam(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(tuple_(table.c.x, table.c.z).in_(bindparam("q")))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [], params={"q": []})

 #testing.requires.tuple_in_w_empty
 #ef test_empty_heterogeneous_tuples_direct(self):
 #able = self.tables.some_table

 #ef go(val, expected):
 #tmt = (
 #elect(table.c.id)
 #where(tuple_(table.c.x, table.c.z).in_(val))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, expected)

 #o([], [])
 #o([(2, "z2"), (3, "z3"), (4, "z4")], [(2,), (3,), (4,)])
 #o([], [])

 #testing.requires.tuple_in_w_empty
 #ef test_empty_homogeneous_tuples_bindparam(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(tuple_(table.c.x, table.c.y).in_(bindparam("q")))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [], params={"q": []})

 #testing.requires.tuple_in_w_empty
 #ef test_empty_homogeneous_tuples_direct(self):
 #able = self.tables.some_table

 #ef go(val, expected):
 #tmt = (
 #elect(table.c.id)
 #where(tuple_(table.c.x, table.c.y).in_(val))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, expected)

 #o([], [])
 #o([(1, 2), (2, 3), (3, 4)], [(1,), (2,), (3,)])
 #o([], [])

 #ef test_bound_in_scalar_bindparam(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.x.in_(bindparam("q")))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [(2,), (3,), (4,)], params={"q": [2, 3, 4]})

 #ef test_bound_in_scalar_direct(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.x.in_([2, 3, 4]))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [(2,), (3,), (4,)])

 #ef test_nonempty_in_plus_empty_notin(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.x.in_([2, 3]))
 #where(table.c.id.not_in([]))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [(2,), (3,)])

 #ef test_empty_in_plus_notempty_notin(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.x.in_([]))
 #where(table.c.id.not_in([2, 3]))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [])

 #testing.requires.tuple_in
 #ef test_bound_in_two_tuple_bindparam(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(tuple_(table.c.x, table.c.y).in_(bindparam("q")))
 #order_by(table.c.id)
 #
 #elf._assert_result(
 #tmt, [(2,), (3,), (4,)], params={"q": [(2, 3), (3, 4), (4, 5)]}
 #

 #testing.requires.tuple_in
 #ef test_bound_in_two_tuple_direct(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(tuple_(table.c.x, table.c.y).in_([(2, 3), (3, 4), (4, 5)]))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [(2,), (3,), (4,)])

 #testing.requires.tuple_in
 #ef test_bound_in_heterogeneous_two_tuple_bindparam(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(tuple_(table.c.x, table.c.z).in_(bindparam("q")))
 #order_by(table.c.id)
 #
 #elf._assert_result(
 #tmt,
 #(2,), (3,), (4,)],
 #arams={"q": [(2, "z2"), (3, "z3"), (4, "z4")]},
 #

 #testing.requires.tuple_in
 #ef test_bound_in_heterogeneous_two_tuple_direct(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(
 #uple_(table.c.x, table.c.z).in_(
 #(2, "z2"), (3, "z3"), (4, "z4")]
 #
 #
 #order_by(table.c.id)
 #
 #elf._assert_result(
 #tmt,
 #(2,), (3,), (4,)],
 #

 #testing.requires.tuple_in
 #ef test_bound_in_heterogeneous_two_tuple_text_bindparam(self):
        # note this becomes ARRAY if we dont use expanding
        # explicitly right now
 #tmt = text(
 #select id FROM some_table WHERE (x, z) IN :q ORDER BY id"
 #.bindparams(bindparam("q", expanding=True))
 #elf._assert_result(
 #tmt,
 #(2,), (3,), (4,)],
 #arams={"q": [(2, "z2"), (3, "z3"), (4, "z4")]},
 #

 #ef test_empty_set_against_integer_bindparam(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.x.in_(bindparam("q")))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [], params={"q": []})

 #ef test_empty_set_against_integer_direct(self):
 #able = self.tables.some_table
 #tmt = select(table.c.id).where(table.c.x.in_([])).order_by(table.c.id)
 #elf._assert_result(stmt, [])

 #ef test_empty_set_against_integer_negation_bindparam(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.x.not_in(bindparam("q")))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [(1,), (2,), (3,), (4,)], params={"q": []})

 #ef test_empty_set_against_integer_negation_direct(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id).where(table.c.x.not_in([])).order_by(table.c.id)
 #
 #elf._assert_result(stmt, [(1,), (2,), (3,), (4,)])

 #ef test_empty_set_against_string_bindparam(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.z.in_(bindparam("q")))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [], params={"q": []})

 #ef test_empty_set_against_string_direct(self):
 #able = self.tables.some_table
 #tmt = select(table.c.id).where(table.c.z.in_([])).order_by(table.c.id)
 #elf._assert_result(stmt, [])

 #ef test_empty_set_against_string_negation_bindparam(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id)
 #where(table.c.z.not_in(bindparam("q")))
 #order_by(table.c.id)
 #
 #elf._assert_result(stmt, [(1,), (2,), (3,), (4,)], params={"q": []})

 #ef test_empty_set_against_string_negation_direct(self):
 #able = self.tables.some_table
 #tmt = (
 #elect(table.c.id).where(table.c.z.not_in([])).order_by(table.c.id)
 #
 #elf._assert_result(stmt, [(1,), (2,), (3,), (4,)])

 #ef test_null_in_empty_set_is_false_bindparam(self, connection):
 #tmt = select(
 #ase(
 #
 #ull().in_(bindparam("foo", value=())),
 #rue(),
 #,
 #lse_=false(),
 #
 #
 #n_(connection.execute(stmt).fetchone()[0], (False, 0))

 #ef test_null_in_empty_set_is_false_direct(self, connection):
 #tmt = select(
 #ase(
 #
 #ull().in_([]),
 #rue(),
 #,
 #lse_=false(),
 #
 #
 #n_(connection.execute(stmt).fetchone()[0], (False, 0))


class LikeFunctionsTest(fixtures.TablesTest):
 #_backend__ = True

 #un_inserts = "once"
 #un_deletes = None

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #some_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("data", String(50)),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.some_table.insert(),
 #
 #"id": 1, "data": "abcdefg"},
 #"id": 2, "data": "ab/cdefg"},
 #"id": 3, "data": "ab%cdefg"},
 #"id": 4, "data": "ab_cdefg"},
 #"id": 5, "data": "abcde/fg"},
 #"id": 6, "data": "abcde%fg"},
 #"id": 7, "data": "ab#cdefg"},
 #"id": 8, "data": "ab9cdefg"},
 #"id": 9, "data": "abcde#fg"},
 #"id": 10, "data": "abcd9fg"},
 #"id": 11, "data": None},
 #,
 #

 #ef _test(self, expr, expected):
 #ome_table = self.tables.some_table

 #ith config.db.connect() as conn:
 #ows = {
 #alue
 #or value, in conn.execute(select(some_table.c.id).where(expr))
 #

 #q_(rows, expected)

 #ef test_startswith_unescaped(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.startswith("ab%c"), {1, 2, 3, 4, 5, 6, 7, 8, 9, 10})

 #ef test_startswith_autoescape(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.startswith("ab%c", autoescape=True), {3})

 #ef test_startswith_sqlexpr(self):
 #ol = self.tables.some_table.c.data
 #elf._test(
 #ol.startswith(literal_column("'ab%c'")),
 #1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
 #

 #ef test_startswith_escape(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.startswith("ab##c", escape="#"), {7})

 #ef test_startswith_autoescape_escape(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.startswith("ab%c", autoescape=True, escape="#"), {3})
 #elf._test(col.startswith("ab#c", autoescape=True, escape="#"), {7})

 #ef test_endswith_unescaped(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.endswith("e%fg"), {1, 2, 3, 4, 5, 6, 7, 8, 9})

 #ef test_endswith_sqlexpr(self):
 #ol = self.tables.some_table.c.data
 #elf._test(
 #ol.endswith(literal_column("'e%fg'")), {1, 2, 3, 4, 5, 6, 7, 8, 9}
 #

 #ef test_endswith_autoescape(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.endswith("e%fg", autoescape=True), {6})

 #ef test_endswith_escape(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.endswith("e##fg", escape="#"), {9})

 #ef test_endswith_autoescape_escape(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.endswith("e%fg", autoescape=True, escape="#"), {6})
 #elf._test(col.endswith("e#fg", autoescape=True, escape="#"), {9})

 #ef test_contains_unescaped(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.contains("b%cde"), {1, 2, 3, 4, 5, 6, 7, 8, 9})

 #ef test_contains_autoescape(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.contains("b%cde", autoescape=True), {3})

 #ef test_contains_escape(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.contains("b##cde", escape="#"), {7})

 #ef test_contains_autoescape_escape(self):
 #ol = self.tables.some_table.c.data
 #elf._test(col.contains("b%cd", autoescape=True, escape="#"), {3})
 #elf._test(col.contains("b#cd", autoescape=True, escape="#"), {7})

 #testing.requires.regexp_match
 #ef test_not_regexp_match(self):
 #ol = self.tables.some_table.c.data
 #elf._test(~col.regexp_match("a.cde"), {2, 3, 4, 7, 8, 10})

 #testing.requires.regexp_replace
 #ef test_regexp_replace(self):
 #ol = self.tables.some_table.c.data
 #elf._test(
 #ol.regexp_replace("a.cde", "FOO").contains("FOO"), {1, 5, 6, 9}
 #

 #testing.requires.regexp_match
 #testing.combinations(
 #"a.cde", {1, 5, 6, 9}),
 #"abc", {1, 5, 6, 9, 10}),
 #"^abc", {1, 5, 6, 9, 10}),
 #"9cde", {8}),
 #"^a", set(range(1, 11))),
 #"(b|c)", set(range(1, 11))),
 #"^(b|c)", set()),
 #
 #ef test_regexp_match(self, text, expected):
 #ol = self.tables.some_table.c.data
 #elf._test(col.regexp_match(text), expected)


class ComputedColumnTest(fixtures.TablesTest):
 #_backend__ = True
 #_requires__ = ("computed_columns",)

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #square",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("side", Integer),
 #olumn("area", Integer, Computed("side * side")),
 #olumn("perimeter", Integer, Computed("4 * side")),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.square.insert(),
 #{"id": 1, "side": 10}, {"id": 10, "side": 42}],
 #

 #ef test_select_all(self):
 #ith config.db.connect() as conn:
 #es = conn.execute(
 #elect(text("*"))
 #select_from(self.tables.square)
 #order_by(self.tables.square.c.id)
 #.fetchall()
 #q_(res, [(1, 10, 100, 40), (10, 42, 1764, 168)])

 #ef test_select_columns(self):
 #ith config.db.connect() as conn:
 #es = conn.execute(
 #elect(
 #elf.tables.square.c.area, self.tables.square.c.perimeter
 #
 #select_from(self.tables.square)
 #order_by(self.tables.square.c.id)
 #.fetchall()
 #q_(res, [(100, 40), (1764, 168)])


class IdentityColumnTest(fixtures.TablesTest):
 #_backend__ = True
 #_requires__ = ("identity_columns",)
 #un_inserts = "once"
 #un_deletes = "once"

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #tbl_a",
 #etadata,
 #olumn(
 #id",
 #nteger,
 #dentity(
 #lways=True, start=42, nominvalue=True, nomaxvalue=True
 #,
 #rimary_key=True,
 #,
 #olumn("desc", String(100)),
 #
 #able(
 #tbl_b",
 #etadata,
 #olumn(
 #id",
 #nteger,
 #dentity(increment=-5, start=0, minvalue=-1000, maxvalue=0),
 #rimary_key=True,
 #,
 #olumn("desc", String(100)),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.tbl_a.insert(),
 #{"desc": "a"}, {"desc": "b"}],
 #
 #onnection.execute(
 #ls.tables.tbl_b.insert(),
 #{"desc": "a"}, {"desc": "b"}],
 #
 #onnection.execute(
 #ls.tables.tbl_b.insert(),
 #{"id": 42, "desc": "c"}],
 #

 #ef test_select_all(self, connection):
 #es = connection.execute(
 #elect(text("*"))
 #select_from(self.tables.tbl_a)
 #order_by(self.tables.tbl_a.c.id)
 #.fetchall()
 #q_(res, [(42, "a"), (43, "b")])

 #es = connection.execute(
 #elect(text("*"))
 #select_from(self.tables.tbl_b)
 #order_by(self.tables.tbl_b.c.id)
 #.fetchall()
 #q_(res, [(-5, "b"), (0, "a"), (42, "c")])

 #ef test_select_columns(self, connection):

 #es = connection.execute(
 #elect(self.tables.tbl_a.c.id).order_by(self.tables.tbl_a.c.id)
 #.fetchall()
 #q_(res, [(42,), (43,)])

 #testing.requires.identity_columns_standard
 #ef test_insert_always_error(self, connection):
 #ef fn():
 #onnection.execute(
 #elf.tables.tbl_a.insert(),
 #{"id": 200, "desc": "a"}],
 #

 #ssert_raises((DatabaseError, ProgrammingError), fn)


class IdentityAutoincrementTest(fixtures.TablesTest):
 #_backend__ = True
 #_requires__ = ("autoincrement_without_sequence",)

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #tbl",
 #etadata,
 #olumn(
 #id",
 #nteger,
 #dentity(),
 #rimary_key=True,
 #utoincrement=True,
 #,
 #olumn("desc", String(100)),
 #

 #ef test_autoincrement_with_identity(self, connection):
 #es = connection.execute(self.tables.tbl.insert(), {"desc": "row"})
 #es = connection.execute(self.tables.tbl.select()).first()
 #q_(res, (1, "row"))


class ExistsTest(fixtures.TablesTest):
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #stuff",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("data", String(50)),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.stuff.insert(),
 #
 #"id": 1, "data": "some data"},
 #"id": 2, "data": "some data"},
 #"id": 3, "data": "some data"},
 #"id": 4, "data": "some other data"},
 #,
 #

 #ef test_select_exists(self, connection):
 #tuff = self.tables.stuff
 #q_(
 #onnection.execute(
 #elect(literal(1)).where(
 #xists().where(stuff.c.data == "some data")
 #
 #.fetchall(),
 #(1,)],
 #

 #ef test_select_exists_false(self, connection):
 #tuff = self.tables.stuff
 #q_(
 #onnection.execute(
 #elect(literal(1)).where(
 #xists().where(stuff.c.data == "no data")
 #
 #.fetchall(),
 #],
 #


class DistinctOnTest(AssertsCompiledSQL, fixtures.TablesTest):
 #_backend__ = True

 #testing.fails_if(testing.requires.supports_distinct_on)
 #ef test_distinct_on(self):
 #tm = select("*").distinct(column("q")).select_from(table("foo"))
 #ith testing.expect_deprecated(
 #DISTINCT ON is currently supported only by the PostgreSQL "
 #:
 #elf.assert_compile(stm, "SELECT DISTINCT * FROM foo")


class IsOrIsNotDistinctFromTest(fixtures.TablesTest):
 #_backend__ = True
 #_requires__ = ("supports_is_distinct_from",)

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #is_distinct_test",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("col_a", Integer, nullable=True),
 #olumn("col_b", Integer, nullable=True),
 #

 #testing.combinations(
 #"both_int_different", 0, 1, 1),
 #"both_int_same", 1, 1, 0),
 #"one_null_first", None, 1, 1),
 #"one_null_second", 0, None, 1),
 #"both_null", None, None, 0),
 #d_="iaaa",
 #rgnames="col_a_value, col_b_value, expected_row_count_for_is",
 #
 #ef test_is_or_is_not_distinct_from(
 #elf, col_a_value, col_b_value, expected_row_count_for_is, connection
 #:
 #bl = self.tables.is_distinct_test

 #onnection.execute(
 #bl.insert(),
 #{"id": 1, "col_a": col_a_value, "col_b": col_b_value}],
 #

 #esult = connection.execute(
 #bl.select().where(tbl.c.col_a.is_distinct_from(tbl.c.col_b))
 #.fetchall()
 #q_(
 #en(result),
 #xpected_row_count_for_is,
 #

 #xpected_row_count_for_is_not = (
 # if expected_row_count_for_is == 0 else 0
 #
 #esult = connection.execute(
 #bl.select().where(tbl.c.col_a.is_not_distinct_from(tbl.c.col_b))
 #.fetchall()
 #q_(
 #en(result),
 #xpected_row_count_for_is_not,
 #
