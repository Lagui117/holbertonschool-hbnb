from sqlalchemy import bindparam
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import select
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import testing
from sqlalchemy import text
from sqlalchemy.testing import eq_
from sqlalchemy.testing import fixtures


class RowCountTest(fixtures.TablesTest):
 #""test rowcount functionality"""

 #_requires__ = ("sane_rowcount",)
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #employees",
 #etadata,
 #olumn(
 #employee_id",
 #nteger,
 #utoincrement=False,
 #rimary_key=True,
 #,
 #olumn("name", String(50)),
 #olumn("department", String(1)),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #ls.data = data = [
 #"Angela", "A"),
 #"Andrew", "A"),
 #"Anand", "A"),
 #"Bob", "B"),
 #"Bobette", "B"),
 #"Buffy", "B"),
 #"Charlie", "C"),
 #"Cynthia", "C"),
 #"Chris", "C"),
 #

 #mployees_table = cls.tables.employees
 #onnection.execute(
 #mployees_table.insert(),
 #
 #"employee_id": i, "name": n, "department": d}
 #or i, (n, d) in enumerate(data)
 #,
 #

 #ef test_basic(self, connection):
 #mployees_table = self.tables.employees
 # = select(
 #mployees_table.c.name, employees_table.c.department
 #.order_by(employees_table.c.employee_id)
 #ows = connection.execute(s).fetchall()

 #q_(rows, self.data)

 #ef test_update_rowcount1(self, connection):
 #mployees_table = self.tables.employees

        # WHERE matches 3, 3 rows changed
 #epartment = employees_table.c.department
 # = connection.execute(
 #mployees_table.update(department == "C"), {"department": "Z"}
 #
 #ssert r.rowcount == 3

 #ef test_update_rowcount2(self, connection):
 #mployees_table = self.tables.employees

        # WHERE matches 3, 0 rows changed
 #epartment = employees_table.c.department

 # = connection.execute(
 #mployees_table.update(department == "C"), {"department": "C"}
 #
 #q_(r.rowcount, 3)

 #testing.requires.sane_rowcount_w_returning
 #ef test_update_rowcount_return_defaults(self, connection):
 #mployees_table = self.tables.employees

 #epartment = employees_table.c.department
 #tmt = (
 #mployees_table.update(department == "C")
 #values(name=employees_table.c.department + "Z")
 #return_defaults()
 #

 # = connection.execute(stmt)
 #q_(r.rowcount, 3)

 #ef test_raw_sql_rowcount(self, connection):
        # test issue #3622, make sure eager rowcount is called for text
 #esult = connection.exec_driver_sql(
 #update employees set department='Z' where department='C'"
 #
 #q_(result.rowcount, 3)

 #ef test_text_rowcount(self, connection):
        # test issue #3622, make sure eager rowcount is called for text
 #esult = connection.execute(
 #ext("update employees set department='Z' " "where department='C'")
 #
 #q_(result.rowcount, 3)

 #ef test_delete_rowcount(self, connection):
 #mployees_table = self.tables.employees

        # WHERE matches 3, 3 rows deleted
 #epartment = employees_table.c.department
 # = connection.execute(employees_table.delete(department == "C"))
 #q_(r.rowcount, 3)

 #testing.requires.sane_multi_rowcount
 #ef test_multi_update_rowcount(self, connection):
 #mployees_table = self.tables.employees
 #tmt = (
 #mployees_table.update()
 #where(employees_table.c.name == bindparam("emp_name"))
 #values(department="C")
 #

 # = connection.execute(
 #tmt,
 #
 #"emp_name": "Bob"},
 #"emp_name": "Cynthia"},
 #"emp_name": "nonexistent"},
 #,
 #

 #q_(r.rowcount, 2)

 #testing.requires.sane_multi_rowcount
 #ef test_multi_delete_rowcount(self, connection):
 #mployees_table = self.tables.employees

 #tmt = employees_table.delete().where(
 #mployees_table.c.name == bindparam("emp_name")
 #

 # = connection.execute(
 #tmt,
 #
 #"emp_name": "Bob"},
 #"emp_name": "Cynthia"},
 #"emp_name": "nonexistent"},
 #,
 #

 #q_(r.rowcount, 2)
