from .. import fixtures
from ..assertions import eq_
from ..schema import Column
from ..schema import Table
from ... import Integer
from ... import select
from ... import testing
from ... import union


class DeprecatedCompoundSelectTest(fixtures.TablesTest):
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #some_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("x", Integer),
 #olumn("y", Integer),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.some_table.insert(),
 #
 #"id": 1, "x": 1, "y": 2},
 #"id": 2, "x": 2, "y": 3},
 #"id": 3, "x": 3, "y": 4},
 #"id": 4, "x": 4, "y": 5},
 #,
 #

 #ef _assert_result(self, conn, select, result, params=()):
 #q_(conn.execute(select, params).fetchall(), result)

 #ef test_plain_union(self, connection):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2)
 #2 = select(table).where(table.c.id == 3)

 #1 = union(s1, s2)
 #ith testing.expect_deprecated(
 #The SelectBase.c and SelectBase.columns "
 #attributes are deprecated"
 #:
 #elf._assert_result(
 #onnection, u1.order_by(u1.c.id), [(2, 2, 3), (3, 3, 4)]
 #

    # note we've had to remove one use case entirely, which is this
    # one.   the Select gets its FROMS from the WHERE clause and the
    # columns clause, but not the ORDER BY, which means the old ".c" system
    # allowed you to "order_by(s.c.foo)" to get an unnamed column in the
    # ORDER BY without adding the SELECT into the FROM and breaking the
    # query.  Users will have to adjust for this use case if they were doing
    # it before.
 #ef _dont_test_select_from_plain_union(self, connection):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2)
 #2 = select(table).where(table.c.id == 3)

 #1 = union(s1, s2).alias().select()
 #ith testing.expect_deprecated(
 #The SelectBase.c and SelectBase.columns "
 #attributes are deprecated"
 #:
 #elf._assert_result(
 #onnection, u1.order_by(u1.c.id), [(2, 2, 3), (3, 3, 4)]
 #

 #testing.requires.order_by_col_from_union
 #testing.requires.parens_in_union_contained_select_w_limit_offset
 #ef test_limit_offset_selectable_in_unions(self, connection):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2).limit(1).order_by(table.c.id)
 #2 = select(table).where(table.c.id == 3).limit(1).order_by(table.c.id)

 #1 = union(s1, s2).limit(2)
 #ith testing.expect_deprecated(
 #The SelectBase.c and SelectBase.columns "
 #attributes are deprecated"
 #:
 #elf._assert_result(
 #onnection, u1.order_by(u1.c.id), [(2, 2, 3), (3, 3, 4)]
 #

 #testing.requires.parens_in_union_contained_select_wo_limit_offset
 #ef test_order_by_selectable_in_unions(self, connection):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2).order_by(table.c.id)
 #2 = select(table).where(table.c.id == 3).order_by(table.c.id)

 #1 = union(s1, s2).limit(2)
 #ith testing.expect_deprecated(
 #The SelectBase.c and SelectBase.columns "
 #attributes are deprecated"
 #:
 #elf._assert_result(
 #onnection, u1.order_by(u1.c.id), [(2, 2, 3), (3, 3, 4)]
 #

 #ef test_distinct_selectable_in_unions(self, connection):
 #able = self.tables.some_table
 #1 = select(table).where(table.c.id == 2).distinct()
 #2 = select(table).where(table.c.id == 3).distinct()

 #1 = union(s1, s2).limit(2)
 #ith testing.expect_deprecated(
 #The SelectBase.c and SelectBase.columns "
 #attributes are deprecated"
 #:
 #elf._assert_result(
 #onnection, u1.order_by(u1.c.id), [(2, 2, 3), (3, 3, 4)]
 #

 #ef test_limit_offset_aliased_selectable_in_unions(self, connection):
 #able = self.tables.some_table
 #1 = (
 #elect(table)
 #where(table.c.id == 2)
 #limit(1)
 #order_by(table.c.id)
 #alias()
 #select()
 #
 #2 = (
 #elect(table)
 #where(table.c.id == 3)
 #limit(1)
 #order_by(table.c.id)
 #alias()
 #select()
 #

 #1 = union(s1, s2).limit(2)
 #ith testing.expect_deprecated(
 #The SelectBase.c and SelectBase.columns "
 #attributes are deprecated"
 #:
 #elf._assert_result(
 #onnection, u1.order_by(u1.c.id), [(2, 2, 3), (3, 3, 4)]
 #
