import datetime

from .. import engines
from .. import fixtures
from ..assertions import eq_
from ..config import requirements
from ..schema import Column
from ..schema import Table
from ... import DateTime
from ... import func
from ... import Integer
from ... import select
from ... import sql
from ... import String
from ... import testing
from ... import text
from ... import util


class RowFetchTest(fixtures.TablesTest):
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #plain_pk",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("data", String(50)),
 #
 #able(
 #has_dates",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("today", DateTime),
 #

 #classmethod
 #ef insert_data(cls, connection):
 #onnection.execute(
 #ls.tables.plain_pk.insert(),
 #
 #"id": 1, "data": "d1"},
 #"id": 2, "data": "d2"},
 #"id": 3, "data": "d3"},
 #,
 #

 #onnection.execute(
 #ls.tables.has_dates.insert(),
 #{"id": 1, "today": datetime.datetime(2006, 5, 12, 12, 0, 0)}],
 #

 #ef test_via_attr(self, connection):
 #ow = connection.execute(
 #elf.tables.plain_pk.select().order_by(self.tables.plain_pk.c.id)
 #.first()

 #q_(row.id, 1)
 #q_(row.data, "d1")

 #ef test_via_string(self, connection):
 #ow = connection.execute(
 #elf.tables.plain_pk.select().order_by(self.tables.plain_pk.c.id)
 #.first()

 #q_(row._mapping["id"], 1)
 #q_(row._mapping["data"], "d1")

 #ef test_via_int(self, connection):
 #ow = connection.execute(
 #elf.tables.plain_pk.select().order_by(self.tables.plain_pk.c.id)
 #.first()

 #q_(row[0], 1)
 #q_(row[1], "d1")

 #ef test_via_col_object(self, connection):
 #ow = connection.execute(
 #elf.tables.plain_pk.select().order_by(self.tables.plain_pk.c.id)
 #.first()

 #q_(row._mapping[self.tables.plain_pk.c.id], 1)
 #q_(row._mapping[self.tables.plain_pk.c.data], "d1")

 #requirements.duplicate_names_in_cursor_description
 #ef test_row_with_dupe_names(self, connection):
 #esult = connection.execute(
 #elect(
 #elf.tables.plain_pk.c.data,
 #elf.tables.plain_pk.c.data.label("data"),
 #.order_by(self.tables.plain_pk.c.id)
 #
 #ow = result.first()
 #q_(result.keys(), ["data", "data"])
 #q_(row, ("d1", "d1"))

 #ef test_row_w_scalar_select(self, connection):
 #""test that a scalar select as a column is returned as such
 #nd that type conversion works OK.

 #this is half a SQLAlchemy Core test and half to catch database
 #ackends that may have unusual behavior with scalar selects.)

 #""
 #atetable = self.tables.has_dates
 # = select(datetable.alias("x").c.today).scalar_subquery()
 #2 = select(datetable.c.id, s.label("somelabel"))
 #ow = connection.execute(s2).first()

 #q_(row.somelabel, datetime.datetime(2006, 5, 12, 12, 0, 0))


class PercentSchemaNamesTest(fixtures.TablesTest):
 #""tests using percent signs, spaces in table and column names.

 #his didn't work for PostgreSQL / MySQL drivers for a long time
 #ut is now supported.

 #""

 #_requires__ = ("percent_schema_names",)

 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #ls.tables.percent_table = Table(
 #percent%table",
 #etadata,
 #olumn("percent%", Integer),
 #olumn("spaces % more spaces", Integer),
 #
 #ls.tables.lightweight_percent_table = sql.table(
 #percent%table",
 #ql.column("percent%"),
 #ql.column("spaces % more spaces"),
 #

 #ef test_single_roundtrip(self, connection):
 #ercent_table = self.tables.percent_table
 #or params in [
 #"percent%": 5, "spaces % more spaces": 12},
 #"percent%": 7, "spaces % more spaces": 11},
 #"percent%": 9, "spaces % more spaces": 10},
 #"percent%": 11, "spaces % more spaces": 9},
 #:
 #onnection.execute(percent_table.insert(), params)
 #elf._assert_table(connection)

 #ef test_executemany_roundtrip(self, connection):
 #ercent_table = self.tables.percent_table
 #onnection.execute(
 #ercent_table.insert(), {"percent%": 5, "spaces % more spaces": 12}
 #
 #onnection.execute(
 #ercent_table.insert(),
 #
 #"percent%": 7, "spaces % more spaces": 11},
 #"percent%": 9, "spaces % more spaces": 10},
 #"percent%": 11, "spaces % more spaces": 9},
 #,
 #
 #elf._assert_table(connection)

 #ef _assert_table(self, conn):
 #ercent_table = self.tables.percent_table
 #ightweight_percent_table = self.tables.lightweight_percent_table

 #or table in (
 #ercent_table,
 #ercent_table.alias(),
 #ightweight_percent_table,
 #ightweight_percent_table.alias(),
 #:
 #q_(
 #ist(
 #onn.execute(table.select().order_by(table.c["percent%"]))
 #,
 #(5, 12), (7, 11), (9, 10), (11, 9)],
 #

 #q_(
 #ist(
 #onn.execute(
 #able.select()
 #where(table.c["spaces % more spaces"].in_([9, 10]))
 #order_by(table.c["percent%"])
 #
 #,
 #(9, 10), (11, 9)],
 #

 #ow = conn.execute(
 #able.select().order_by(table.c["percent%"])
 #.first()
 #q_(row._mapping["percent%"], 5)
 #q_(row._mapping["spaces % more spaces"], 12)

 #q_(row._mapping[table.c["percent%"]], 5)
 #q_(row._mapping[table.c["spaces % more spaces"]], 12)

 #onn.execute(
 #ercent_table.update().values(
 #percent_table.c["spaces % more spaces"]: 15}
 #
 #

 #q_(
 #ist(
 #onn.execute(
 #ercent_table.select().order_by(
 #ercent_table.c["percent%"]
 #
 #
 #,
 #(5, 15), (7, 15), (9, 15), (11, 15)],
 #


class ServerSideCursorsTest(
 #ixtures.TestBase, testing.AssertsExecutionResults
):

 #_requires__ = ("server_side_cursors",)

 #_backend__ = True

 #ef _is_server_side(self, cursor):
        # TODO: this is a huge issue as it prevents these tests from being
        # usable by third party dialects.
 #f self.engine.dialect.driver == "psycopg2":
 #eturn bool(cursor.name)
 #lif self.engine.dialect.driver == "pymysql":
 #scursor = __import__("pymysql.cursors").cursors.SSCursor
 #eturn isinstance(cursor, sscursor)
 #lif self.engine.dialect.driver == "aiomysql":
 #eturn cursor.server_side
 #lif self.engine.dialect.driver == "mysqldb":
 #scursor = __import__("MySQLdb.cursors").cursors.SSCursor
 #eturn isinstance(cursor, sscursor)
 #lif self.engine.dialect.driver == "mariadbconnector":
 #eturn not cursor.buffered
 #lif self.engine.dialect.driver in ("asyncpg", "aiosqlite"):
 #eturn cursor.server_side
 #lif self.engine.dialect.driver == "pg8000":
 #eturn getattr(cursor, "server_side", False)
 #lse:
 #eturn False

 #ef _fixture(self, server_side_cursors):
 #f server_side_cursors:
 #ith testing.expect_deprecated(
 #The create_engine.server_side_cursors parameter is "
 #deprecated and will be removed in a future release.  "
 #Please use the Connection.execution_options.stream_results "
 #parameter."
 #:
 #elf.engine = engines.testing_engine(
 #ptions={"server_side_cursors": server_side_cursors}
 #
 #lse:
 #elf.engine = engines.testing_engine(
 #ptions={"server_side_cursors": server_side_cursors}
 #
 #eturn self.engine

 #testing.combinations(
 #"global_string", True, "select 1", True),
 #"global_text", True, text("select 1"), True),
 #"global_expr", True, select(1), True),
 #"global_off_explicit", False, text("select 1"), False),
 #
 #stmt_option",
 #alse,
 #elect(1).execution_options(stream_results=True),
 #rue,
 #,
 #
 #stmt_option_disabled",
 #rue,
 #elect(1).execution_options(stream_results=False),
 #alse,
 #,
 #"for_update_expr", True, select(1).with_for_update(), True),
        # TODO: need a real requirement for this, or dont use this test
 #
 #for_update_string",
 #rue,
 #SELECT 1 FOR UPDATE",
 #rue,
 #esting.skip_if("sqlite"),
 #,
 #"text_no_ss", False, text("select 42"), False),
 #
 #text_ss_option",
 #alse,
 #ext("select 42").execution_options(stream_results=True),
 #rue,
 #,
 #d_="iaaa",
 #rgnames="engine_ss_arg, statement, cursor_ss_status",
 #
 #ef test_ss_cursor_status(
 #elf, engine_ss_arg, statement, cursor_ss_status
 #:
 #ngine = self._fixture(engine_ss_arg)
 #ith engine.begin() as conn:
 #f isinstance(statement, util.string_types):
 #esult = conn.exec_driver_sql(statement)
 #lse:
 #esult = conn.execute(statement)
 #q_(self._is_server_side(result.cursor), cursor_ss_status)
 #esult.close()

 #ef test_conn_option(self):
 #ngine = self._fixture(False)

 #ith engine.connect() as conn:
            # should be enabled for this one
 #esult = conn.execution_options(
 #tream_results=True
 #.exec_driver_sql("select 1")
 #ssert self._is_server_side(result.cursor)

 #ef test_stmt_enabled_conn_option_disabled(self):
 #ngine = self._fixture(False)

 # = select(1).execution_options(stream_results=True)

 #ith engine.connect() as conn:
            # not this one
 #esult = conn.execution_options(stream_results=False).execute(s)
 #ssert not self._is_server_side(result.cursor)

 #ef test_aliases_and_ss(self):
 #ngine = self._fixture(False)
 #1 = (
 #elect(sql.literal_column("1").label("x"))
 #execution_options(stream_results=True)
 #subquery()
 #

        # options don't propagate out when subquery is used as a FROM clause
 #ith engine.begin() as conn:
 #esult = conn.execute(s1.select())
 #ssert not self._is_server_side(result.cursor)
 #esult.close()

 #2 = select(1).select_from(s1)
 #ith engine.begin() as conn:
 #esult = conn.execute(s2)
 #ssert not self._is_server_side(result.cursor)
 #esult.close()

 #ef test_roundtrip_fetchall(self, metadata):
 #d = self.metadata

 #ngine = self._fixture(True)
 #est_table = Table(
 #test_table",
 #d,
 #olumn("id", Integer, primary_key=True),
 #olumn("data", String(50)),
 #

 #ith engine.begin() as connection:
 #est_table.create(connection, checkfirst=True)
 #onnection.execute(test_table.insert(), dict(data="data1"))
 #onnection.execute(test_table.insert(), dict(data="data2"))
 #q_(
 #onnection.execute(
 #est_table.select().order_by(test_table.c.id)
 #.fetchall(),
 #(1, "data1"), (2, "data2")],
 #
 #onnection.execute(
 #est_table.update()
 #where(test_table.c.id == 2)
 #values(data=test_table.c.data + " updated")
 #
 #q_(
 #onnection.execute(
 #est_table.select().order_by(test_table.c.id)
 #.fetchall(),
 #(1, "data1"), (2, "data2 updated")],
 #
 #onnection.execute(test_table.delete())
 #q_(
 #onnection.scalar(
 #elect(func.count("*")).select_from(test_table)
 #,
 #,
 #

 #ef test_roundtrip_fetchmany(self, metadata):
 #d = self.metadata

 #ngine = self._fixture(True)
 #est_table = Table(
 #test_table",
 #d,
 #olumn("id", Integer, primary_key=True),
 #olumn("data", String(50)),
 #

 #ith engine.begin() as connection:
 #est_table.create(connection, checkfirst=True)
 #onnection.execute(
 #est_table.insert(),
 #dict(data="data%d" % i) for i in range(1, 20)],
 #

 #esult = connection.execute(
 #est_table.select().order_by(test_table.c.id)
 #

 #q_(
 #esult.fetchmany(5),
 #(i, "data%d" % i) for i in range(1, 6)],
 #
 #q_(
 #esult.fetchmany(10),
 #(i, "data%d" % i) for i in range(6, 16)],
 #
 #q_(result.fetchall(), [(i, "data%d" % i) for i in range(16, 20)])
