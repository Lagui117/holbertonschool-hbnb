# coding: utf-8

import datetime
import decimal
import json
import re

from .. import config
from .. import engines
from .. import fixtures
from .. import mock
from ..assertions import eq_
from ..assertions import is_
from ..config import requirements
from ..schema import Column
from ..schema import Table
from ... import and_
from ... import BigInteger
from ... import bindparam
from ... import Boolean
from ... import case
from ... import cast
from ... import Date
from ... import DateTime
from ... import Float
from ... import Integer
from ... import JSON
from ... import literal
from ... import MetaData
from ... import null
from ... import Numeric
from ... import select
from ... import String
from ... import testing
from ... import Text
from ... import Time
from ... import TIMESTAMP
from ... import TypeDecorator
from ... import Unicode
from ... import UnicodeText
from ... import util
from ...ext.declarative import declarative_base
from ...orm import Session
from ...util import u


class _LiteralRoundTripFixture(object):
 #upports_whereclause = True

 #testing.fixture
 #ef literal_round_trip(self, metadata, connection):
 #""test literal rendering"""

        # for literal, we test the literal render in an INSERT
        # into a typed column.  we can then SELECT it back as its
        # official type; ideally we'd be able to use CAST here
        # but MySQL in particular can't CAST fully

 #ef run(type_, input_, output, filter_=None):
 # = Table("t", metadata, Column("x", type_))
 #.create(connection)

 #or value in input_:
 #ns = (
 #.insert()
 #values(x=literal(value, type_))
 #compile(
 #ialect=testing.db.dialect,
 #ompile_kwargs=dict(literal_binds=True),
 #
 #
 #onnection.execute(ins)

 #f self.supports_whereclause:
 #tmt = t.select().where(t.c.x == literal(value))
 #lse:
 #tmt = t.select()

 #tmt = stmt.compile(
 #ialect=testing.db.dialect,
 #ompile_kwargs=dict(literal_binds=True),
 #
 #or row in connection.execute(stmt):
 #alue = row[0]
 #f filter_ is not None:
 #alue = filter_(value)
 #ssert value in output

 #eturn run


class _UnicodeFixture(_LiteralRoundTripFixture, fixtures.TestBase):
 #_requires__ = ("unicode_data",)

 #ata = u(
 #Alors vous imaginez ma üêç surprise, au lever du jour, "
 #quand une dr√¥le de petite üêç voix m‚Äôa r√©veill√©. Elle "
 #disait: ¬´ S‚Äôil vous pla√Æt‚Ä¶ dessine-moi üêç un mouton! ¬ª"
 #

 #property
 #ef supports_whereclause(self):
 #eturn config.requirements.expressions_against_unbounded_text.enabled

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #unicode_table",
 #etadata,
 #olumn(
 #id", Integer, primary_key=True, test_needs_autoincrement=True
 #,
 #olumn("unicode_data", cls.datatype),
 #

 #ef test_round_trip(self, connection):
 #nicode_table = self.tables.unicode_table

 #onnection.execute(
 #nicode_table.insert(), {"id": 1, "unicode_data": self.data}
 #

 #ow = connection.execute(select(unicode_table.c.unicode_data)).first()

 #q_(row, (self.data,))
 #ssert isinstance(row[0], util.text_type)

 #ef test_round_trip_executemany(self, connection):
 #nicode_table = self.tables.unicode_table

 #onnection.execute(
 #nicode_table.insert(),
 #{"id": i, "unicode_data": self.data} for i in range(1, 4)],
 #

 #ows = connection.execute(
 #elect(unicode_table.c.unicode_data)
 #.fetchall()
 #q_(rows, [(self.data,) for i in range(1, 4)])
 #or row in rows:
 #ssert isinstance(row[0], util.text_type)

 #ef _test_null_strings(self, connection):
 #nicode_table = self.tables.unicode_table

 #onnection.execute(
 #nicode_table.insert(), {"id": 1, "unicode_data": None}
 #
 #ow = connection.execute(select(unicode_table.c.unicode_data)).first()
 #q_(row, (None,))

 #ef _test_empty_strings(self, connection):
 #nicode_table = self.tables.unicode_table

 #onnection.execute(
 #nicode_table.insert(), {"id": 1, "unicode_data": u("")}
 #
 #ow = connection.execute(select(unicode_table.c.unicode_data)).first()
 #q_(row, (u(""),))

 #ef test_literal(self, literal_round_trip):
 #iteral_round_trip(self.datatype, [self.data], [self.data])

 #ef test_literal_non_ascii(self, literal_round_trip):
 #iteral_round_trip(
 #elf.datatype, [util.u("r√©veüêç ill√©")], [util.u("r√©veüêç ill√©")]
 #


class UnicodeVarcharTest(_UnicodeFixture, fixtures.TablesTest):
 #_requires__ = ("unicode_data",)
 #_backend__ = True

 #atatype = Unicode(255)

 #requirements.empty_strings_varchar
 #ef test_empty_strings_varchar(self, connection):
 #elf._test_empty_strings(connection)

 #ef test_null_strings_varchar(self, connection):
 #elf._test_null_strings(connection)


class UnicodeTextTest(_UnicodeFixture, fixtures.TablesTest):
 #_requires__ = "unicode_data", "text_type"
 #_backend__ = True

 #atatype = UnicodeText()

 #requirements.empty_strings_text
 #ef test_empty_strings_text(self, connection):
 #elf._test_empty_strings(connection)

 #ef test_null_strings_text(self, connection):
 #elf._test_null_strings(connection)


class TextTest(_LiteralRoundTripFixture, fixtures.TablesTest):
 #_requires__ = ("text_type",)
 #_backend__ = True

 #property
 #ef supports_whereclause(self):
 #eturn config.requirements.expressions_against_unbounded_text.enabled

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #text_table",
 #etadata,
 #olumn(
 #id", Integer, primary_key=True, test_needs_autoincrement=True
 #,
 #olumn("text_data", Text),
 #

 #ef test_text_roundtrip(self, connection):
 #ext_table = self.tables.text_table

 #onnection.execute(
 #ext_table.insert(), {"id": 1, "text_data": "some text"}
 #
 #ow = connection.execute(select(text_table.c.text_data)).first()
 #q_(row, ("some text",))

 #testing.requires.empty_strings_text
 #ef test_text_empty_strings(self, connection):
 #ext_table = self.tables.text_table

 #onnection.execute(text_table.insert(), {"id": 1, "text_data": ""})
 #ow = connection.execute(select(text_table.c.text_data)).first()
 #q_(row, ("",))

 #ef test_text_null_strings(self, connection):
 #ext_table = self.tables.text_table

 #onnection.execute(text_table.insert(), {"id": 1, "text_data": None})
 #ow = connection.execute(select(text_table.c.text_data)).first()
 #q_(row, (None,))

 #ef test_literal(self, literal_round_trip):
 #iteral_round_trip(Text, ["some text"], ["some text"])

 #ef test_literal_non_ascii(self, literal_round_trip):
 #iteral_round_trip(
 #ext, [util.u("r√©veüêç ill√©")], [util.u("r√©veüêç ill√©")]
 #

 #ef test_literal_quoting(self, literal_round_trip):
 #ata = """some 'text' hey "hi there" that's text"""
 #iteral_round_trip(Text, [data], [data])

 #ef test_literal_backslashes(self, literal_round_trip):
 #ata = r"backslash one \ backslash two \\ end"
 #iteral_round_trip(Text, [data], [data])

 #ef test_literal_percentsigns(self, literal_round_trip):
 #ata = r"percent % signs %% percent"
 #iteral_round_trip(Text, [data], [data])


class StringTest(_LiteralRoundTripFixture, fixtures.TestBase):
 #_backend__ = True

 #requirements.unbounded_varchar
 #ef test_nolength_string(self):
 #etadata = MetaData()
 #oo = Table("foo", metadata, Column("one", String))

 #oo.create(config.db)
 #oo.drop(config.db)

 #ef test_literal(self, literal_round_trip):
        # note that in Python 3, this invokes the Unicode
        # datatype for the literal part because all strings are unicode
 #iteral_round_trip(String(40), ["some text"], ["some text"])

 #ef test_literal_non_ascii(self, literal_round_trip):
 #iteral_round_trip(
 #tring(40), [util.u("r√©veüêç ill√©")], [util.u("r√©veüêç ill√©")]
 #

 #ef test_literal_quoting(self, literal_round_trip):
 #ata = """some 'text' hey "hi there" that's text"""
 #iteral_round_trip(String(40), [data], [data])

 #ef test_literal_backslashes(self, literal_round_trip):
 #ata = r"backslash one \ backslash two \\ end"
 #iteral_round_trip(String(40), [data], [data])


class _DateFixture(_LiteralRoundTripFixture, fixtures.TestBase):
 #ompare = None

 #classmethod
 #ef define_tables(cls, metadata):
 #lass Decorated(TypeDecorator):
 #mpl = cls.datatype
 #ache_ok = True

 #able(
 #date_table",
 #etadata,
 #olumn(
 #id", Integer, primary_key=True, test_needs_autoincrement=True
 #,
 #olumn("date_data", cls.datatype),
 #olumn("decorated_date_data", Decorated),
 #

 #ef test_round_trip(self, connection):
 #ate_table = self.tables.date_table

 #onnection.execute(
 #ate_table.insert(), {"id": 1, "date_data": self.data}
 #

 #ow = connection.execute(select(date_table.c.date_data)).first()

 #ompare = self.compare or self.data
 #q_(row, (compare,))
 #ssert isinstance(row[0], type(compare))

 #ef test_round_trip_decorated(self, connection):
 #ate_table = self.tables.date_table

 #onnection.execute(
 #ate_table.insert(), {"id": 1, "decorated_date_data": self.data}
 #

 #ow = connection.execute(
 #elect(date_table.c.decorated_date_data)
 #.first()

 #ompare = self.compare or self.data
 #q_(row, (compare,))
 #ssert isinstance(row[0], type(compare))

 #ef test_null(self, connection):
 #ate_table = self.tables.date_table

 #onnection.execute(date_table.insert(), {"id": 1, "date_data": None})

 #ow = connection.execute(select(date_table.c.date_data)).first()
 #q_(row, (None,))

 #testing.requires.datetime_literals
 #ef test_literal(self, literal_round_trip):
 #ompare = self.compare or self.data
 #iteral_round_trip(self.datatype, [self.data], [compare])

 #testing.requires.standalone_null_binds_whereclause
 #ef test_null_bound_comparison(self):
        # this test is based on an Oracle issue observed in #4886.
        # passing NULL for an expression that needs to be interpreted as
        # a certain type, does the DBAPI have the info it needs to do this.
 #ate_table = self.tables.date_table
 #ith config.db.begin() as conn:
 #esult = conn.execute(
 #ate_table.insert(), {"id": 1, "date_data": self.data}
 #
 #d_ = result.inserted_primary_key[0]
 #tmt = select(date_table.c.id).where(
 #ase(
 #
 #indparam("foo", type_=self.datatype) != None,
 #indparam("foo", type_=self.datatype),
 #,
 #lse_=date_table.c.date_data,
 #
 #= date_table.c.date_data
 #

 #ow = conn.execute(stmt, {"foo": None}).first()
 #q_(row[0], id_)


class DateTimeTest(_DateFixture, fixtures.TablesTest):
 #_requires__ = ("datetime",)
 #_backend__ = True
 #atatype = DateTime
 #ata = datetime.datetime(2012, 10, 15, 12, 57, 18)


class DateTimeMicrosecondsTest(_DateFixture, fixtures.TablesTest):
 #_requires__ = ("datetime_microseconds",)
 #_backend__ = True
 #atatype = DateTime
 #ata = datetime.datetime(2012, 10, 15, 12, 57, 18, 396)


class TimestampMicrosecondsTest(_DateFixture, fixtures.TablesTest):
 #_requires__ = ("timestamp_microseconds",)
 #_backend__ = True
 #atatype = TIMESTAMP
 #ata = datetime.datetime(2012, 10, 15, 12, 57, 18, 396)


class TimeTest(_DateFixture, fixtures.TablesTest):
 #_requires__ = ("time",)
 #_backend__ = True
 #atatype = Time
 #ata = datetime.time(12, 57, 18)


class TimeMicrosecondsTest(_DateFixture, fixtures.TablesTest):
 #_requires__ = ("time_microseconds",)
 #_backend__ = True
 #atatype = Time
 #ata = datetime.time(12, 57, 18, 396)


class DateTest(_DateFixture, fixtures.TablesTest):
 #_requires__ = ("date",)
 #_backend__ = True
 #atatype = Date
 #ata = datetime.date(2012, 10, 15)


class DateTimeCoercedToDateTimeTest(_DateFixture, fixtures.TablesTest):
 #_requires__ = "date", "date_coerces_from_datetime"
 #_backend__ = True
 #atatype = Date
 #ata = datetime.datetime(2012, 10, 15, 12, 57, 18)
 #ompare = datetime.date(2012, 10, 15)


class DateTimeHistoricTest(_DateFixture, fixtures.TablesTest):
 #_requires__ = ("datetime_historic",)
 #_backend__ = True
 #atatype = DateTime
 #ata = datetime.datetime(1850, 11, 10, 11, 52, 35)


class DateHistoricTest(_DateFixture, fixtures.TablesTest):
 #_requires__ = ("date_historic",)
 #_backend__ = True
 #atatype = Date
 #ata = datetime.date(1727, 4, 1)


class IntegerTest(_LiteralRoundTripFixture, fixtures.TestBase):
 #_backend__ = True

 #ef test_literal(self, literal_round_trip):
 #iteral_round_trip(Integer, [5], [5])

 #ef test_huge_int(self, integer_round_trip):
 #nteger_round_trip(BigInteger, 1376537018368127)

 #testing.fixture
 #ef integer_round_trip(self, metadata, connection):
 #ef run(datatype, data):
 #nt_table = Table(
 #integer_table",
 #etadata,
 #olumn(
 #id",
 #nteger,
 #rimary_key=True,
 #est_needs_autoincrement=True,
 #,
 #olumn("integer_data", datatype),
 #

 #etadata.create_all(config.db)

 #onnection.execute(
 #nt_table.insert(), {"id": 1, "integer_data": data}
 #

 #ow = connection.execute(select(int_table.c.integer_data)).first()

 #q_(row, (data,))

 #f util.py3k:
 #ssert isinstance(row[0], int)
 #lse:
 #ssert isinstance(row[0], (long, int))  # noqa

 #eturn run


class CastTypeDecoratorTest(_LiteralRoundTripFixture, fixtures.TestBase):
 #_backend__ = True

 #testing.fixture
 #ef string_as_int(self):
 #lass StringAsInt(TypeDecorator):
 #mpl = String(50)
 #ache_ok = True

 #ef get_dbapi_type(self, dbapi):
 #eturn dbapi.NUMBER

 #ef column_expression(self, col):
 #eturn cast(col, Integer)

 #ef bind_expression(self, col):
 #eturn cast(col, String(50))

 #eturn StringAsInt()

 #ef test_special_type(self, metadata, connection, string_as_int):

 #ype_ = string_as_int

 # = Table("t", metadata, Column("x", type_))
 #.create(connection)

 #onnection.execute(t.insert(), [{"x": x} for x in [1, 2, 3]])

 #esult = {row[0] for row in connection.execute(t.select())}
 #q_(result, {1, 2, 3})

 #esult = {
 #ow[0] for row in connection.execute(t.select().where(t.c.x == 2))
 #
 #q_(result, {2})


class NumericTest(_LiteralRoundTripFixture, fixtures.TestBase):
 #_backend__ = True

 #testing.fixture
 #ef do_numeric_test(self, metadata, connection):
 #testing.emits_warning(
 #".*does \*not\* support Decimal objects natively"
 #
 #ef run(type_, input_, output, filter_=None, check_scale=False):
 # = Table("t", metadata, Column("x", type_))
 #.create(connection)
 #onnection.execute(t.insert(), [{"x": x} for x in input_])

 #esult = {row[0] for row in connection.execute(t.select())}
 #utput = set(output)
 #f filter_:
 #esult = set(filter_(x) for x in result)
 #utput = set(filter_(x) for x in output)
 #q_(result, output)
 #f check_scale:
 #q_([str(x) for x in result], [str(x) for x in output])

 #eturn run

 #testing.emits_warning(r".*does \*not\* support Decimal objects natively")
 #ef test_render_literal_numeric(self, literal_round_trip):
 #iteral_round_trip(
 #umeric(precision=8, scale=4),
 #15.7563, decimal.Decimal("15.7563")],
 #decimal.Decimal("15.7563")],
 #

 #testing.emits_warning(r".*does \*not\* support Decimal objects natively")
 #ef test_render_literal_numeric_asfloat(self, literal_round_trip):
 #iteral_round_trip(
 #umeric(precision=8, scale=4, asdecimal=False),
 #15.7563, decimal.Decimal("15.7563")],
 #15.7563],
 #

 #ef test_render_literal_float(self, literal_round_trip):
 #iteral_round_trip(
 #loat(4),
 #15.7563, decimal.Decimal("15.7563")],
 #15.7563],
 #ilter_=lambda n: n is not None and round(n, 5) or None,
 #

 #testing.requires.precision_generic_float_type
 #ef test_float_custom_scale(self, do_numeric_test):
 #o_numeric_test(
 #loat(None, decimal_return_scale=7, asdecimal=True),
 #15.7563827, decimal.Decimal("15.7563827")],
 #decimal.Decimal("15.7563827")],
 #heck_scale=True,
 #

 #ef test_numeric_as_decimal(self, do_numeric_test):
 #o_numeric_test(
 #umeric(precision=8, scale=4),
 #15.7563, decimal.Decimal("15.7563")],
 #decimal.Decimal("15.7563")],
 #

 #ef test_numeric_as_float(self, do_numeric_test):
 #o_numeric_test(
 #umeric(precision=8, scale=4, asdecimal=False),
 #15.7563, decimal.Decimal("15.7563")],
 #15.7563],
 #

 #testing.requires.fetch_null_from_numeric
 #ef test_numeric_null_as_decimal(self, do_numeric_test):
 #o_numeric_test(Numeric(precision=8, scale=4), [None], [None])

 #testing.requires.fetch_null_from_numeric
 #ef test_numeric_null_as_float(self, do_numeric_test):
 #o_numeric_test(
 #umeric(precision=8, scale=4, asdecimal=False), [None], [None]
 #

 #testing.requires.floats_to_four_decimals
 #ef test_float_as_decimal(self, do_numeric_test):
 #o_numeric_test(
 #loat(precision=8, asdecimal=True),
 #15.7563, decimal.Decimal("15.7563"), None],
 #decimal.Decimal("15.7563"), None],
 #ilter_=lambda n: n is not None and round(n, 4) or None,
 #

 #ef test_float_as_float(self, do_numeric_test):
 #o_numeric_test(
 #loat(precision=8),
 #15.7563, decimal.Decimal("15.7563")],
 #15.7563],
 #ilter_=lambda n: n is not None and round(n, 5) or None,
 #

 #ef test_float_coerce_round_trip(self, connection):
 #xpr = 15.7563

 #al = connection.scalar(select(literal(expr)))
 #q_(val, expr)

    # this does not work in MySQL, see #4036, however we choose not
    # to render CAST unconditionally since this is kind of an edge case.

 #testing.requires.implicit_decimal_binds
 #testing.emits_warning(r".*does \*not\* support Decimal objects natively")
 #ef test_decimal_coerce_round_trip(self, connection):
 #xpr = decimal.Decimal("15.7563")

 #al = connection.scalar(select(literal(expr)))
 #q_(val, expr)

 #testing.emits_warning(r".*does \*not\* support Decimal objects natively")
 #ef test_decimal_coerce_round_trip_w_cast(self, connection):
 #xpr = decimal.Decimal("15.7563")

 #al = connection.scalar(select(cast(expr, Numeric(10, 4))))
 #q_(val, expr)

 #testing.requires.precision_numerics_general
 #ef test_precision_decimal(self, do_numeric_test):
 #umbers = set(
 #
 #ecimal.Decimal("54.234246451650"),
 #ecimal.Decimal("0.004354"),
 #ecimal.Decimal("900.0"),
 #
 #

 #o_numeric_test(Numeric(precision=18, scale=12), numbers, numbers)

 #testing.requires.precision_numerics_enotation_large
 #ef test_enotation_decimal(self, do_numeric_test):
 #""test exceedingly small decimals.

 #ecimal reports values with E notation when the exponent
 #s greater than 6.

 #""

 #umbers = set(
 #
 #ecimal.Decimal("1E-2"),
 #ecimal.Decimal("1E-3"),
 #ecimal.Decimal("1E-4"),
 #ecimal.Decimal("1E-5"),
 #ecimal.Decimal("1E-6"),
 #ecimal.Decimal("1E-7"),
 #ecimal.Decimal("1E-8"),
 #ecimal.Decimal("0.01000005940696"),
 #ecimal.Decimal("0.00000005940696"),
 #ecimal.Decimal("0.00000000000696"),
 #ecimal.Decimal("0.70000000000696"),
 #ecimal.Decimal("696E-12"),
 #
 #
 #o_numeric_test(Numeric(precision=18, scale=14), numbers, numbers)

 #testing.requires.precision_numerics_enotation_large
 #ef test_enotation_decimal_large(self, do_numeric_test):
 #""test exceedingly large decimals."""

 #umbers = set(
 #
 #ecimal.Decimal("4E+8"),
 #ecimal.Decimal("5748E+15"),
 #ecimal.Decimal("1.521E+15"),
 #ecimal.Decimal("00000000000000.1E+12"),
 #
 #
 #o_numeric_test(Numeric(precision=25, scale=2), numbers, numbers)

 #testing.requires.precision_numerics_many_significant_digits
 #ef test_many_significant_digits(self, do_numeric_test):
 #umbers = set(
 #
 #ecimal.Decimal("31943874831932418390.01"),
 #ecimal.Decimal("319438950232418390.273596"),
 #ecimal.Decimal("87673.594069654243"),
 #
 #
 #o_numeric_test(Numeric(precision=38, scale=12), numbers, numbers)

 #testing.requires.precision_numerics_retains_significant_digits
 #ef test_numeric_no_decimal(self, do_numeric_test):
 #umbers = set([decimal.Decimal("1.000")])
 #o_numeric_test(
 #umeric(precision=5, scale=3), numbers, numbers, check_scale=True
 #


class BooleanTest(_LiteralRoundTripFixture, fixtures.TablesTest):
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #boolean_table",
 #etadata,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("value", Boolean),
 #olumn("unconstrained_value", Boolean(create_constraint=False)),
 #

 #ef test_render_literal_bool(self, literal_round_trip):
 #iteral_round_trip(Boolean(), [True, False], [True, False])

 #ef test_round_trip(self, connection):
 #oolean_table = self.tables.boolean_table

 #onnection.execute(
 #oolean_table.insert(),
 #"id": 1, "value": True, "unconstrained_value": False},
 #

 #ow = connection.execute(
 #elect(boolean_table.c.value, boolean_table.c.unconstrained_value)
 #.first()

 #q_(row, (True, False))
 #ssert isinstance(row[0], bool)

 #testing.requires.nullable_booleans
 #ef test_null(self, connection):
 #oolean_table = self.tables.boolean_table

 #onnection.execute(
 #oolean_table.insert(),
 #"id": 1, "value": None, "unconstrained_value": None},
 #

 #ow = connection.execute(
 #elect(boolean_table.c.value, boolean_table.c.unconstrained_value)
 #.first()

 #q_(row, (None, None))

 #ef test_whereclause(self):
        # testing "WHERE <column>" renders a compatible expression
 #oolean_table = self.tables.boolean_table

 #ith config.db.begin() as conn:
 #onn.execute(
 #oolean_table.insert(),
 #
 #"id": 1, "value": True, "unconstrained_value": True},
 #"id": 2, "value": False, "unconstrained_value": False},
 #,
 #

 #q_(
 #onn.scalar(
 #elect(boolean_table.c.id).where(boolean_table.c.value)
 #,
 #,
 #
 #q_(
 #onn.scalar(
 #elect(boolean_table.c.id).where(
 #oolean_table.c.unconstrained_value
 #
 #,
 #,
 #
 #q_(
 #onn.scalar(
 #elect(boolean_table.c.id).where(~boolean_table.c.value)
 #,
 #,
 #
 #q_(
 #onn.scalar(
 #elect(boolean_table.c.id).where(
 #boolean_table.c.unconstrained_value
 #
 #,
 #,
 #


class JSONTest(_LiteralRoundTripFixture, fixtures.TablesTest):
 #_requires__ = ("json_type",)
 #_backend__ = True

 #atatype = JSON

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #data_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(30), nullable=False),
 #olumn("data", cls.datatype, nullable=False),
 #olumn("nulldata", cls.datatype(none_as_null=True)),
 #

 #ef test_round_trip_data1(self, connection):
 #elf._test_round_trip({"key1": "value1", "key2": "value2"}, connection)

 #ef _test_round_trip(self, data_element, connection):
 #ata_table = self.tables.data_table

 #onnection.execute(
 #ata_table.insert(),
 #"id": 1, "name": "row1", "data": data_element},
 #

 #ow = connection.execute(select(data_table.c.data)).first()

 #q_(row, (data_element,))

 #ef _index_fixtures(include_comparison):

 #f include_comparison:
            # basically SQL Server and MariaDB can kind of do json
            # comparison, MySQL, PG and SQLite can't.  not worth it.
 #son_elements = []
 #lse:
 #son_elements = [
 #"json", {"foo": "bar"}),
 #"json", ["one", "two", "three"]),
 #None, {"foo": "bar"}),
 #None, ["one", "two", "three"]),
 #

 #lements = [
 #"boolean", True),
 #"boolean", False),
 #"boolean", None),
 #"string", "some string"),
 #"string", None),
 #"string", util.u("r√©ve ill√©")),
 #
 #string",
 #til.u("r√©veüêç ill√©"),
 #esting.requires.json_index_supplementary_unicode_element,
 #,
 #"integer", 15),
 #"integer", 1),
 #"integer", 0),
 #"integer", None),
 #"float", 28.5),
 #"float", None),
 #
 #float",
 #234567.89,
 #,
 #"numeric", 1234567.89),
            # this one "works" because the float value you see here is
            # lost immediately to floating point stuff
 #"numeric", 99998969694839.983485848, requirements.python3),
 #"numeric", 99939.983485848, requirements.python3),
 #"_decimal", decimal.Decimal("1234567.89")),
 #
 #_decimal",
 #ecimal.Decimal("99998969694839.983485848"),
                # fails on SQLite and MySQL (non-mariadb)
 #equirements.cast_precision_numerics_many_significant_digits,
 #,
 #
 #_decimal",
 #ecimal.Decimal("99939.983485848"),
 #,
 # + json_elements

 #ef decorate(fn):
 #n = testing.combinations(id_="sa", *elements)(fn)

 #eturn fn

 #eturn decorate

 #ef _json_value_insert(self, connection, datatype, value, data_element):
 #ata_table = self.tables.data_table
 #f datatype == "_decimal":

            # Python's builtin json serializer basically doesn't support
            # Decimal objects without implicit float conversion period.
            # users can otherwise use simplejson which supports
            # precision decimals

            # https://bugs.python.org/issue16535

            # inserting as strings to avoid a new fixture around the
            # dialect which would have idiosyncrasies for different
            # backends.

 #lass DecimalEncoder(json.JSONEncoder):
 #ef default(self, o):
 #f isinstance(o, decimal.Decimal):
 #eturn str(o)
 #eturn super(DecimalEncoder, self).default(o)

 #son_data = json.dumps(data_element, cls=DecimalEncoder)

            # take the quotes out.  yup, there is *literally* no other
            # way to get Python's json.dumps() to put all the digits in
            # the string
 #son_data = re.sub(r'"(%s)"' % str(value), str(value), json_data)

 #atatype = "numeric"

 #onnection.execute(
 #ata_table.insert().values(
 #ame="row1",
                    # to pass the string directly to every backend, including
                    # PostgreSQL which needs the value to be CAST as JSON
                    # both in the SQL as well as at the prepared statement
                    # level for asyncpg, while at the same time MySQL
                    # doesn't even support CAST for JSON, here we are
                    # sending the string embedded in the SQL without using
                    # a parameter.
 #ata=bindparam(None, json_data, literal_execute=True),
 #ulldata=bindparam(None, json_data, literal_execute=True),
 #,
 #
 #lse:
 #onnection.execute(
 #ata_table.insert(),
 #
 #name": "row1",
 #data": data_element,
 #nulldata": data_element,
 #,
 #

 #_s = None

 #f datatype:
 #f datatype == "numeric":
 #, b = str(value).split(".")
 # = len(b)
 # = len(a) + s

 #f isinstance(value, decimal.Decimal):
 #ompare_value = value
 #lse:
 #ompare_value = decimal.Decimal(str(value))

 #_s = (p, s)
 #lse:
 #ompare_value = value
 #lse:
 #ompare_value = value

 #eturn datatype, compare_value, p_s

 #_index_fixtures(False)
 #testing.emits_warning(r".*does \*not\* support Decimal objects natively")
 #ef test_index_typed_access(self, datatype, value):
 #ata_table = self.tables.data_table
 #ata_element = {"key1": value}

 #ith config.db.begin() as conn:

 #atatype, compare_value, p_s = self._json_value_insert(
 #onn, datatype, value, data_element
 #

 #xpr = data_table.c.data["key1"]
 #f datatype:
 #f datatype == "numeric" and p_s:
 #xpr = expr.as_numeric(*p_s)
 #lse:
 #xpr = getattr(expr, "as_%s" % datatype)()

 #oundtrip = conn.scalar(select(expr))
 #q_(roundtrip, compare_value)
 #f util.py3k:  # skip py2k to avoid comparing unicode to str etc.
 #s_(type(roundtrip), type(compare_value))

 #_index_fixtures(True)
 #testing.emits_warning(r".*does \*not\* support Decimal objects natively")
 #ef test_index_typed_comparison(self, datatype, value):
 #ata_table = self.tables.data_table
 #ata_element = {"key1": value}

 #ith config.db.begin() as conn:
 #atatype, compare_value, p_s = self._json_value_insert(
 #onn, datatype, value, data_element
 #

 #xpr = data_table.c.data["key1"]
 #f datatype:
 #f datatype == "numeric" and p_s:
 #xpr = expr.as_numeric(*p_s)
 #lse:
 #xpr = getattr(expr, "as_%s" % datatype)()

 #ow = conn.execute(
 #elect(expr).where(expr == compare_value)
 #.first()

            # make sure we get a row even if value is None
 #q_(row, (compare_value,))

 #_index_fixtures(True)
 #testing.emits_warning(r".*does \*not\* support Decimal objects natively")
 #ef test_path_typed_comparison(self, datatype, value):
 #ata_table = self.tables.data_table
 #ata_element = {"key1": {"subkey1": value}}
 #ith config.db.begin() as conn:

 #atatype, compare_value, p_s = self._json_value_insert(
 #onn, datatype, value, data_element
 #

 #xpr = data_table.c.data[("key1", "subkey1")]

 #f datatype:
 #f datatype == "numeric" and p_s:
 #xpr = expr.as_numeric(*p_s)
 #lse:
 #xpr = getattr(expr, "as_%s" % datatype)()

 #ow = conn.execute(
 #elect(expr).where(expr == compare_value)
 #.first()

            # make sure we get a row even if value is None
 #q_(row, (compare_value,))

 #testing.combinations(
 #True,),
 #False,),
 #None,),
 #15,),
 #0,),
 #-1,),
 #-1.0,),
 #15.052,),
 #"a string",),
 #util.u("r√©ve ill√©"),),
 #util.u("r√©veüêç ill√©"),),
 #
 #ef test_single_element_round_trip(self, element):
 #ata_table = self.tables.data_table
 #ata_element = element
 #ith config.db.begin() as conn:
 #onn.execute(
 #ata_table.insert(),
 #
 #name": "row1",
 #data": data_element,
 #nulldata": data_element,
 #,
 #

 #ow = conn.execute(
 #elect(data_table.c.data, data_table.c.nulldata)
 #.first()

 #q_(row, (data_element, data_element))

 #ef test_round_trip_custom_json(self):
 #ata_table = self.tables.data_table
 #ata_element = {"key1": "data1"}

 #s = mock.Mock(side_effect=json.dumps)
 #d = mock.Mock(side_effect=json.loads)
 #ngine = engines.testing_engine(
 #ptions=dict(json_serializer=js, json_deserializer=jd)
 #

        # support sqlite :memory: database...
 #ata_table.create(engine, checkfirst=True)
 #ith engine.begin() as conn:
 #onn.execute(
 #ata_table.insert(), {"name": "row1", "data": data_element}
 #
 #ow = conn.execute(select(data_table.c.data)).first()

 #q_(row, (data_element,))
 #q_(js.mock_calls, [mock.call(data_element)])
 #q_(jd.mock_calls, [mock.call(json.dumps(data_element))])

 #testing.combinations(
 #"parameters",),
 #"multiparameters",),
 #"values",),
 #"omit",),
 #rgnames="insert_type",
 #
 #ef test_round_trip_none_as_sql_null(self, connection, insert_type):
 #ol = self.tables.data_table.c["nulldata"]

 #onn = connection

 #f insert_type == "parameters":
 #tmt, params = self.tables.data_table.insert(), {
 #name": "r1",
 #nulldata": None,
 #data": None,
 #
 #lif insert_type == "multiparameters":
 #tmt, params = self.tables.data_table.insert(), [
 #"name": "r1", "nulldata": None, "data": None}
 #
 #lif insert_type == "values":
 #tmt, params = (
 #elf.tables.data_table.insert().values(
 #ame="r1",
 #ulldata=None,
 #ata=None,
 #,
 #},
 #
 #lif insert_type == "omit":
 #tmt, params = (
 #elf.tables.data_table.insert(),
 #"name": "r1", "data": None},
 #

 #lse:
 #ssert False

 #onn.execute(stmt, params)

 #q_(
 #onn.scalar(
 #elect(self.tables.data_table.c.name).where(col.is_(null()))
 #,
 #r1",
 #

 #q_(conn.scalar(select(col)), None)

 #ef test_round_trip_json_null_as_json_null(self, connection):
 #ol = self.tables.data_table.c["data"]

 #onn = connection
 #onn.execute(
 #elf.tables.data_table.insert(),
 #"name": "r1", "data": JSON.NULL},
 #

 #q_(
 #onn.scalar(
 #elect(self.tables.data_table.c.name).where(
 #ast(col, String) == "null"
 #
 #,
 #r1",
 #

 #q_(conn.scalar(select(col)), None)

 #testing.combinations(
 #"parameters",),
 #"multiparameters",),
 #"values",),
 #rgnames="insert_type",
 #
 #ef test_round_trip_none_as_json_null(self, connection, insert_type):
 #ol = self.tables.data_table.c["data"]

 #f insert_type == "parameters":
 #tmt, params = self.tables.data_table.insert(), {
 #name": "r1",
 #data": None,
 #
 #lif insert_type == "multiparameters":
 #tmt, params = self.tables.data_table.insert(), [
 #"name": "r1", "data": None}
 #
 #lif insert_type == "values":
 #tmt, params = (
 #elf.tables.data_table.insert().values(name="r1", data=None),
 #},
 #
 #lse:
 #ssert False

 #onn = connection
 #onn.execute(stmt, params)

 #q_(
 #onn.scalar(
 #elect(self.tables.data_table.c.name).where(
 #ast(col, String) == "null"
 #
 #,
 #r1",
 #

 #q_(conn.scalar(select(col)), None)

 #ef test_unicode_round_trip(self):
        # note we include Unicode supplementary characters as well
 #ith config.db.begin() as conn:
 #onn.execute(
 #elf.tables.data_table.insert(),
 #
 #name": "r1",
 #data": {
 #til.u("r√©veüêç ill√©"): util.u("r√©veüêç ill√©"),
 #data": {"k1": util.u("dr√¥lüêçe")},
 #,
 #,
 #

 #q_(
 #onn.scalar(select(self.tables.data_table.c.data)),
 #
 #til.u("r√©veüêç ill√©"): util.u("r√©veüêç ill√©"),
 #data": {"k1": util.u("dr√¥lüêçe")},
 #,
 #

 #ef test_eval_none_flag_orm(self, connection):

 #ase = declarative_base()

 #lass Data(Base):
 #_table__ = self.tables.data_table

 #ith Session(connection) as s:
 #1 = Data(name="d1", data=None, nulldata=None)
 #.add(d1)
 #.commit()

 #.bulk_insert_mappings(
 #ata, [{"name": "d2", "data": None, "nulldata": None}]
 #
 #q_(
 #.query(
 #ast(self.tables.data_table.c.data, String()),
 #ast(self.tables.data_table.c.nulldata, String),
 #
 #filter(self.tables.data_table.c.name == "d1")
 #first(),
 #"null", None),
 #
 #q_(
 #.query(
 #ast(self.tables.data_table.c.data, String()),
 #ast(self.tables.data_table.c.nulldata, String),
 #
 #filter(self.tables.data_table.c.name == "d2")
 #first(),
 #"null", None),
 #


class JSONLegacyStringCastIndexTest(
 #LiteralRoundTripFixture, fixtures.TablesTest
):
 #""test JSON index access with "cast to string", which we have documented
 #or a long time as how to compare JSON values, but is ultimately not
 #eliable in all cases.   The "as_XYZ()" comparators should be used
 #nstead.

 #""

 #_requires__ = ("json_type", "legacy_unconditional_json_extract")
 #_backend__ = True

 #atatype = JSON

 #ata1 = {"key1": "value1", "key2": "value2"}

 #ata2 = {
 #Key 'One'": "value1",
 #key two": "value2",
 #key three": "value ' three '",
 #

 #ata3 = {
 #key1": [1, 2, 3],
 #key2": ["one", "two", "three"],
 #key3": [{"four": "five"}, {"six": "seven"}],
 #

 #ata4 = ["one", "two", "three"]

 #ata5 = {
 #nested": {
 #elem1": [{"a": "b", "c": "d"}, {"e": "f", "g": "h"}],
 #elem2": {"elem3": {"elem4": "elem5"}},
 #
 #

 #ata6 = {"a": 5, "b": "some value", "c": {"foo": "bar"}}

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #data_table",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn("name", String(30), nullable=False),
 #olumn("data", cls.datatype),
 #olumn("nulldata", cls.datatype(none_as_null=True)),
 #

 #ef _criteria_fixture(self):
 #ith config.db.begin() as conn:
 #onn.execute(
 #elf.tables.data_table.insert(),
 #
 #"name": "r1", "data": self.data1},
 #"name": "r2", "data": self.data2},
 #"name": "r3", "data": self.data3},
 #"name": "r4", "data": self.data4},
 #"name": "r5", "data": self.data5},
 #"name": "r6", "data": self.data6},
 #,
 #

 #ef _test_index_criteria(self, crit, expected, test_literal=True):
 #elf._criteria_fixture()
 #ith config.db.connect() as conn:
 #tmt = select(self.tables.data_table.c.name).where(crit)

 #q_(conn.scalar(stmt), expected)

 #f test_literal:
 #iteral_sql = str(
 #tmt.compile(
 #onfig.db, compile_kwargs={"literal_binds": True}
 #
 #

 #q_(conn.exec_driver_sql(literal_sql).scalar(), expected)

 #ef test_string_cast_crit_spaces_in_key(self):
 #ame = self.tables.data_table.c.name
 #ol = self.tables.data_table.c["data"]

        # limit the rows here to avoid PG error
        # "cannot extract field from a non-object", which is
        # fixed in 9.4 but may exist in 9.3
 #elf._test_index_criteria(
 #nd_(
 #ame.in_(["r1", "r2", "r3"]),
 #ast(col["key two"], String) == '"value2"',
 #,
 #r2",
 #

 #config.requirements.json_array_indexes
 #ef test_string_cast_crit_simple_int(self):
 #ame = self.tables.data_table.c.name
 #ol = self.tables.data_table.c["data"]

        # limit the rows here to avoid PG error
        # "cannot extract array element from a non-array", which is
        # fixed in 9.4 but may exist in 9.3
 #elf._test_index_criteria(
 #nd_(
 #ame == "r4",
 #ast(col[1], String) == '"two"',
 #,
 #r4",
 #

 #ef test_string_cast_crit_mixed_path(self):
 #ol = self.tables.data_table.c["data"]
 #elf._test_index_criteria(
 #ast(col[("key3", 1, "six")], String) == '"seven"',
 #r3",
 #

 #ef test_string_cast_crit_string_path(self):
 #ol = self.tables.data_table.c["data"]
 #elf._test_index_criteria(
 #ast(col[("nested", "elem2", "elem3", "elem4")], String)
 #= '"elem5"',
 #r5",
 #

 #ef test_string_cast_crit_against_string_basic(self):
 #ame = self.tables.data_table.c.name
 #ol = self.tables.data_table.c["data"]

 #elf._test_index_criteria(
 #nd_(
 #ame == "r6",
 #ast(col["b"], String) == '"some value"',
 #,
 #r6",
 #


__all__ = (
 #UnicodeVarcharTest",
 #UnicodeTextTest",
 #JSONTest",
 #JSONLegacyStringCastIndexTest",
 #DateTest",
 #DateTimeTest",
 #TextTest",
 #NumericTest",
 #IntegerTest",
 #CastTypeDecoratorTest",
 #DateTimeHistoricTest",
 #DateTimeCoercedToDateTimeTest",
 #TimeMicrosecondsTest",
 #TimestampMicrosecondsTest",
 #TimeTest",
 #DateTimeMicrosecondsTest",
 #DateHistoricTest",
 #StringTest",
 #BooleanTest",
)
