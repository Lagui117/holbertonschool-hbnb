#! coding: utf-8

from . import testing
from .. import assert_raises
from .. import config
from .. import engines
from .. import eq_
from .. import fixtures
from .. import ne_
from .. import provide_metadata
from ..config import requirements
from ..provision import set_default_schema_on_connection
from ..schema import Column
from ..schema import Table
from ... import bindparam
from ... import event
from ... import exc
from ... import Integer
from ... import literal_column
from ... import select
from ... import String
from ...util import compat


class ExceptionTest(fixtures.TablesTest):
 #""Test basic exception wrapping.

 #BAPIs vary a lot in exception behavior so to actually anticipate
 #pecific exceptions from real round trips, we need to be conservative.

 #""

 #un_deletes = "each"

 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #manual_pk",
 #etadata,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("data", String(50)),
 #

 #requirements.duplicate_key_raises_integrity_error
 #ef test_integrity_error(self):

 #ith config.db.connect() as conn:

 #rans = conn.begin()
 #onn.execute(
 #elf.tables.manual_pk.insert(), {"id": 1, "data": "d1"}
 #

 #ssert_raises(
 #xc.IntegrityError,
 #onn.execute,
 #elf.tables.manual_pk.insert(),
 #"id": 1, "data": "d1"},
 #

 #rans.rollback()

 #ef test_exception_with_non_ascii(self):
 #ith config.db.connect() as conn:
 #ry:
                # try to create an error message that likely has non-ascii
                # characters in the DBAPI's message string.  unfortunately
                # there's no way to make this happen with some drivers like
                # mysqlclient, pymysql.  this at least does produce a non-
                # ascii error message for cx_oracle, psycopg2
 #onn.execute(select(literal_column(u"m√©il")))
 #ssert False
 #xcept exc.DBAPIError as err:
 #rr_str = str(err)

 #ssert str(err.orig) in str(err)

            # test that we are actually getting string on Py2k, unicode
            # on Py3k.
 #f compat.py2k:
 #ssert isinstance(err_str, str)
 #lse:
 #ssert isinstance(err_str, str)


class IsolationLevelTest(fixtures.TestBase):
 #_backend__ = True

 #_requires__ = ("isolation_level",)

 #ef _get_non_default_isolation_level(self):
 #evels = requirements.get_isolation_levels(config)

 #efault = levels["default"]
 #upported = levels["supported"]

 # = set(supported).difference(["AUTOCOMMIT", default])
 #f s:
 #eturn s.pop()
 #lse:
 #onfig.skip_test("no non-default isolation level available")

 #ef test_default_isolation_level(self):
 #q_(
 #onfig.db.dialect.default_isolation_level,
 #equirements.get_isolation_levels(config)["default"],
 #

 #ef test_non_default_isolation_level(self):
 #on_default = self._get_non_default_isolation_level()

 #ith config.db.connect() as conn:
 #xisting = conn.get_isolation_level()

 #e_(existing, non_default)

 #onn.execution_options(isolation_level=non_default)

 #q_(conn.get_isolation_level(), non_default)

 #onn.dialect.reset_isolation_level(conn.connection)

 #q_(conn.get_isolation_level(), existing)

 #ef test_all_levels(self):
 #evels = requirements.get_isolation_levels(config)

 #ll_levels = levels["supported"]

 #or level in set(all_levels).difference(["AUTOCOMMIT"]):
 #ith config.db.connect() as conn:
 #onn.execution_options(isolation_level=level)

 #q_(conn.get_isolation_level(), level)

 #rans = conn.begin()
 #rans.rollback()

 #q_(conn.get_isolation_level(), level)

 #ith config.db.connect() as conn:
 #q_(
 #onn.get_isolation_level(),
 #evels["default"],
 #


class AutocommitIsolationTest(fixtures.TablesTest):

 #un_deletes = "each"

 #_requires__ = ("autocommit",)

 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #some_table",
 #etadata,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("data", String(50)),
 #est_needs_acid=True,
 #

 #ef _test_conn_autocommits(self, conn, autocommit):
 #rans = conn.begin()
 #onn.execute(
 #elf.tables.some_table.insert(), {"id": 1, "data": "some data"}
 #
 #rans.rollback()

 #q_(
 #onn.scalar(select(self.tables.some_table.c.id)),
 # if autocommit else None,
 #

 #ith conn.begin():
 #onn.execute(self.tables.some_table.delete())

 #ef test_autocommit_on(self, connection_no_trans):
 #onn = connection_no_trans
 #2 = conn.execution_options(isolation_level="AUTOCOMMIT")
 #elf._test_conn_autocommits(c2, True)

 #2.dialect.reset_isolation_level(c2.connection)

 #elf._test_conn_autocommits(conn, False)

 #ef test_autocommit_off(self, connection_no_trans):
 #onn = connection_no_trans
 #elf._test_conn_autocommits(conn, False)

 #ef test_turn_autocommit_off_via_default_iso_level(
 #elf, connection_no_trans
 #:
 #onn = connection_no_trans
 #onn = conn.execution_options(isolation_level="AUTOCOMMIT")
 #elf._test_conn_autocommits(conn, True)

 #onn.execution_options(
 #solation_level=requirements.get_isolation_levels(config)[
 #default"
 #
 #
 #elf._test_conn_autocommits(conn, False)


class EscapingTest(fixtures.TestBase):
 #provide_metadata
 #ef test_percent_sign_round_trip(self):
 #""test that the DBAPI accommodates for escaped / nonescaped
 #ercent signs in a way that matches the compiler

 #""
 # = self.metadata
 # = Table("t", m, Column("data", String(50)))
 #.create(config.db)
 #ith config.db.begin() as conn:
 #onn.execute(t.insert(), dict(data="some % value"))
 #onn.execute(t.insert(), dict(data="some %% other value"))

 #q_(
 #onn.scalar(
 #elect(t.c.data).where(
 #.c.data == literal_column("'some % value'")
 #
 #,
 #some % value",
 #

 #q_(
 #onn.scalar(
 #elect(t.c.data).where(
 #.c.data == literal_column("'some %% other value'")
 #
 #,
 #some %% other value",
 #


class WeCanSetDefaultSchemaWEventsTest(fixtures.TestBase):
 #_backend__ = True

 #_requires__ = ("default_schema_name_switch",)

 #ef test_control_case(self):
 #efault_schema_name = config.db.dialect.default_schema_name

 #ng = engines.testing_engine()
 #ith eng.connect():
 #ass

 #q_(eng.dialect.default_schema_name, default_schema_name)

 #ef test_wont_work_wo_insert(self):
 #efault_schema_name = config.db.dialect.default_schema_name

 #ng = engines.testing_engine()

 #event.listens_for(eng, "connect")
 #ef on_connect(dbapi_connection, connection_record):
 #et_default_schema_on_connection(
 #onfig, dbapi_connection, config.test_schema
 #

 #ith eng.connect() as conn:
 #hat_it_should_be = eng.dialect._get_default_schema_name(conn)
 #q_(what_it_should_be, config.test_schema)

 #q_(eng.dialect.default_schema_name, default_schema_name)

 #ef test_schema_change_on_connect(self):
 #ng = engines.testing_engine()

 #event.listens_for(eng, "connect", insert=True)
 #ef on_connect(dbapi_connection, connection_record):
 #et_default_schema_on_connection(
 #onfig, dbapi_connection, config.test_schema
 #

 #ith eng.connect() as conn:
 #hat_it_should_be = eng.dialect._get_default_schema_name(conn)
 #q_(what_it_should_be, config.test_schema)

 #q_(eng.dialect.default_schema_name, config.test_schema)

 #ef test_schema_change_works_w_transactions(self):
 #ng = engines.testing_engine()

 #event.listens_for(eng, "connect", insert=True)
 #ef on_connect(dbapi_connection, *arg):
 #et_default_schema_on_connection(
 #onfig, dbapi_connection, config.test_schema
 #

 #ith eng.connect() as conn:
 #rans = conn.begin()
 #hat_it_should_be = eng.dialect._get_default_schema_name(conn)
 #q_(what_it_should_be, config.test_schema)
 #rans.rollback()

 #hat_it_should_be = eng.dialect._get_default_schema_name(conn)
 #q_(what_it_should_be, config.test_schema)

 #q_(eng.dialect.default_schema_name, config.test_schema)


class FutureWeCanSetDefaultSchemaWEventsTest(
 #ixtures.FutureEngineMixin, WeCanSetDefaultSchemaWEventsTest
):
 #ass


class DifficultParametersTest(fixtures.TestBase):
 #_backend__ = True

 #testing.combinations(
 #"boring",),
 #"per cent",),
 #"per % cent",),
 #"%percent",),
 #"par(ens)",),
 #"percent%(ens)yah",),
 #"col:ons",),
 #"more :: %colons%",),
 #"/slashes/",),
 #"more/slashes",),
 #"q?marks",),
 #"1param",),
 #"1col:on",),
 #rgnames="name",
 #
 #ef test_round_trip(self, name, connection, metadata):
 # = Table(
 #t",
 #etadata,
 #olumn("id", Integer, primary_key=True),
 #olumn(name, String(50), nullable=False),
 #

        # table is created
 #.create(connection)

        # automatic param generated by insert
 #onnection.execute(t.insert().values({"id": 1, name: "some name"}))

        # automatic param generated by criteria, plus selecting the column
 #tmt = select(t.c[name]).where(t.c[name] == "some name")

 #q_(connection.scalar(stmt), "some name")

        # use the name in a param explicitly
 #tmt = select(t.c[name]).where(t.c[name] == bindparam(name))

 #ow = connection.execute(stmt, {name: "some name"}).first()

        # name works as the key from cursor.description
 #q_(row._mapping[name], "some name")
