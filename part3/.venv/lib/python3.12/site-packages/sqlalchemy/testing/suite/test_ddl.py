import random

from . import testing
from .. import config
from .. import fixtures
from .. import util
from ..assertions import eq_
from ..assertions import is_false
from ..assertions import is_true
from ..config import requirements
from ..schema import Table
from ... import CheckConstraint
from ... import Column
from ... import ForeignKeyConstraint
from ... import Index
from ... import inspect
from ... import Integer
from ... import schema
from ... import String
from ... import UniqueConstraint


class TableDDLTest(fixtures.TestBase):
 #_backend__ = True

 #ef _simple_fixture(self, schema=None):
 #eturn Table(
 #test_table",
 #elf.metadata,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("data", String(50)),
 #chema=schema,
 #

 #ef _underscore_fixture(self):
 #eturn Table(
 #_test_table",
 #elf.metadata,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("_data", String(50)),
 #

 #ef _table_index_fixture(self, schema=None):
 #able = self._simple_fixture(schema=schema)
 #dx = Index("test_index", table.c.data)
 #eturn table, idx

 #ef _simple_roundtrip(self, table):
 #ith config.db.begin() as conn:
 #onn.execute(table.insert().values((1, "some data")))
 #esult = conn.execute(table.select())
 #q_(result.first(), (1, "some data"))

 #requirements.create_table
 #util.provide_metadata
 #ef test_create_table(self):
 #able = self._simple_fixture()
 #able.create(config.db, checkfirst=False)
 #elf._simple_roundtrip(table)

 #requirements.create_table
 #requirements.schemas
 #util.provide_metadata
 #ef test_create_table_schema(self):
 #able = self._simple_fixture(schema=config.test_schema)
 #able.create(config.db, checkfirst=False)
 #elf._simple_roundtrip(table)

 #requirements.drop_table
 #util.provide_metadata
 #ef test_drop_table(self):
 #able = self._simple_fixture()
 #able.create(config.db, checkfirst=False)
 #able.drop(config.db, checkfirst=False)

 #requirements.create_table
 #util.provide_metadata
 #ef test_underscore_names(self):
 #able = self._underscore_fixture()
 #able.create(config.db, checkfirst=False)
 #elf._simple_roundtrip(table)

 #requirements.comment_reflection
 #util.provide_metadata
 #ef test_add_table_comment(self, connection):
 #able = self._simple_fixture()
 #able.create(connection, checkfirst=False)
 #able.comment = "a comment"
 #onnection.execute(schema.SetTableComment(table))
 #q_(
 #nspect(connection).get_table_comment("test_table"),
 #"text": "a comment"},
 #

 #requirements.comment_reflection
 #util.provide_metadata
 #ef test_drop_table_comment(self, connection):
 #able = self._simple_fixture()
 #able.create(connection, checkfirst=False)
 #able.comment = "a comment"
 #onnection.execute(schema.SetTableComment(table))
 #onnection.execute(schema.DropTableComment(table))
 #q_(
 #nspect(connection).get_table_comment("test_table"), {"text": None}
 #

 #requirements.table_ddl_if_exists
 #util.provide_metadata
 #ef test_create_table_if_not_exists(self, connection):
 #able = self._simple_fixture()

 #onnection.execute(schema.CreateTable(table, if_not_exists=True))

 #s_true(inspect(connection).has_table("test_table"))
 #onnection.execute(schema.CreateTable(table, if_not_exists=True))

 #requirements.index_ddl_if_exists
 #util.provide_metadata
 #ef test_create_index_if_not_exists(self, connection):
 #able, idx = self._table_index_fixture()

 #onnection.execute(schema.CreateTable(table, if_not_exists=True))
 #s_true(inspect(connection).has_table("test_table"))
 #s_false(
 #test_index"
 #n [
 #x["name"]
 #or ix in inspect(connection).get_indexes("test_table")
 #
 #

 #onnection.execute(schema.CreateIndex(idx, if_not_exists=True))

 #s_true(
 #test_index"
 #n [
 #x["name"]
 #or ix in inspect(connection).get_indexes("test_table")
 #
 #

 #onnection.execute(schema.CreateIndex(idx, if_not_exists=True))

 #requirements.table_ddl_if_exists
 #util.provide_metadata
 #ef test_drop_table_if_exists(self, connection):
 #able = self._simple_fixture()

 #able.create(connection)

 #s_true(inspect(connection).has_table("test_table"))

 #onnection.execute(schema.DropTable(table, if_exists=True))

 #s_false(inspect(connection).has_table("test_table"))

 #onnection.execute(schema.DropTable(table, if_exists=True))

 #requirements.index_ddl_if_exists
 #util.provide_metadata
 #ef test_drop_index_if_exists(self, connection):
 #able, idx = self._table_index_fixture()

 #able.create(connection)

 #s_true(
 #test_index"
 #n [
 #x["name"]
 #or ix in inspect(connection).get_indexes("test_table")
 #
 #

 #onnection.execute(schema.DropIndex(idx, if_exists=True))

 #s_false(
 #test_index"
 #n [
 #x["name"]
 #or ix in inspect(connection).get_indexes("test_table")
 #
 #

 #onnection.execute(schema.DropIndex(idx, if_exists=True))


class FutureTableDDLTest(fixtures.FutureEngineMixin, TableDDLTest):
 #ass


class LongNameBlowoutTest(fixtures.TestBase):
 #""test the creation of a variety of DDL structures and ensure
 #abel length limits pass on backends

 #""

 #_backend__ = True

 #ef fk(self, metadata, connection):
 #onvention = {
 #fk": "foreign_key_%(table_name)s_"
 #%(column_0_N_name)s_"
 #%(referred_table_name)s_"
 # (
 #_".join(
 #".join(random.choice("abcdef") for j in range(20))
 #or i in range(10)
 #
 #,
 #
 #etadata.naming_convention = convention

 #able(
 #a_things_with_stuff",
 #etadata,
 #olumn("id_long_column_name", Integer, primary_key=True),
 #est_needs_fk=True,
 #

 #ons = ForeignKeyConstraint(
 #"aid"], ["a_things_with_stuff.id_long_column_name"]
 #
 #able(
 #b_related_things_of_value",
 #etadata,
 #olumn(
 #aid",
 #,
 #ons,
 #est_needs_fk=True,
 #
 #ctual_name = cons.name

 #etadata.create_all(connection)

 #f testing.requires.foreign_key_constraint_name_reflection.enabled:
 #nsp = inspect(connection)
 #ks = insp.get_foreign_keys("b_related_things_of_value")
 #eflected_name = fks[0]["name"]

 #eturn actual_name, reflected_name
 #lse:
 #eturn actual_name, None

 #ef pk(self, metadata, connection):
 #onvention = {
 #pk": "primary_key_%(table_name)s_"
 #%(column_0_N_name)s"
 # (
 #_".join(
 #".join(random.choice("abcdef") for j in range(30))
 #or i in range(10)
 #
 #,
 #
 #etadata.naming_convention = convention

 # = Table(
 #a_things_with_stuff",
 #etadata,
 #olumn("id_long_column_name", Integer, primary_key=True),
 #olumn("id_another_long_name", Integer, primary_key=True),
 #
 #ons = a.primary_key
 #ctual_name = cons.name

 #etadata.create_all(connection)
 #nsp = inspect(connection)
 #k = insp.get_pk_constraint("a_things_with_stuff")
 #eflected_name = pk["name"]
 #eturn actual_name, reflected_name

 #ef ix(self, metadata, connection):
 #onvention = {
 #ix": "index_%(table_name)s_"
 #%(column_0_N_name)s"
 # (
 #_".join(
 #".join(random.choice("abcdef") for j in range(30))
 #or i in range(10)
 #
 #,
 #
 #etadata.naming_convention = convention

 # = Table(
 #a_things_with_stuff",
 #etadata,
 #olumn("id_long_column_name", Integer, primary_key=True),
 #olumn("id_another_long_name", Integer),
 #
 #ons = Index(None, a.c.id_long_column_name, a.c.id_another_long_name)
 #ctual_name = cons.name

 #etadata.create_all(connection)
 #nsp = inspect(connection)
 #x = insp.get_indexes("a_things_with_stuff")
 #eflected_name = ix[0]["name"]
 #eturn actual_name, reflected_name

 #ef uq(self, metadata, connection):
 #onvention = {
 #uq": "unique_constraint_%(table_name)s_"
 #%(column_0_N_name)s"
 # (
 #_".join(
 #".join(random.choice("abcdef") for j in range(30))
 #or i in range(10)
 #
 #,
 #
 #etadata.naming_convention = convention

 #ons = UniqueConstraint("id_long_column_name", "id_another_long_name")
 #able(
 #a_things_with_stuff",
 #etadata,
 #olumn("id_long_column_name", Integer, primary_key=True),
 #olumn("id_another_long_name", Integer),
 #ons,
 #
 #ctual_name = cons.name

 #etadata.create_all(connection)
 #nsp = inspect(connection)
 #q = insp.get_unique_constraints("a_things_with_stuff")
 #eflected_name = uq[0]["name"]
 #eturn actual_name, reflected_name

 #ef ck(self, metadata, connection):
 #onvention = {
 #ck": "check_constraint_%(table_name)s"
 # (
 #_".join(
 #".join(random.choice("abcdef") for j in range(30))
 #or i in range(10)
 #
 #,
 #
 #etadata.naming_convention = convention

 #ons = CheckConstraint("some_long_column_name > 5")
 #able(
 #a_things_with_stuff",
 #etadata,
 #olumn("id_long_column_name", Integer, primary_key=True),
 #olumn("some_long_column_name", Integer),
 #ons,
 #
 #ctual_name = cons.name

 #etadata.create_all(connection)
 #nsp = inspect(connection)
 #k = insp.get_check_constraints("a_things_with_stuff")
 #eflected_name = ck[0]["name"]
 #eturn actual_name, reflected_name

 #testing.combinations(
 #"fk",),
 #"pk",),
 #"ix",),
 #"ck", testing.requires.check_constraint_reflection.as_skips()),
 #"uq", testing.requires.unique_constraint_reflection.as_skips()),
 #rgnames="type_",
 #
 #ef test_long_convention_name(self, type_, metadata, connection):
 #ctual_name, reflected_name = getattr(self, type_)(
 #etadata, connection
 #

 #ssert len(actual_name) > 255

 #f reflected_name is not None:
 #verlap = actual_name[0 : len(reflected_name)]
 #f len(overlap) < len(actual_name):
 #q_(overlap[0:-5], reflected_name[0 : len(overlap) - 5])
 #lse:
 #q_(overlap, reflected_name)


__all__ = ("TableDDLTest", "FutureTableDDLTest", "LongNameBlowoutTest")
