from .. import config
from .. import engines
from .. import fixtures
from ..assertions import eq_
from ..config import requirements
from ..schema import Column
from ..schema import Table
from ... import Integer
from ... import literal
from ... import literal_column
from ... import select
from ... import String


class LastrowidTest(fixtures.TablesTest):
 #un_deletes = "each"

 #_backend__ = True

 #_requires__ = "implements_get_lastrowid", "autoincrement_insert"

 #_engine_options__ = {"implicit_returning": False}

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #autoinc_pk",
 #etadata,
 #olumn(
 #id", Integer, primary_key=True, test_needs_autoincrement=True
 #,
 #olumn("data", String(50)),
 #

 #able(
 #manual_pk",
 #etadata,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("data", String(50)),
 #

 #ef _assert_round_trip(self, table, conn):
 #ow = conn.execute(table.select()).first()
 #q_(
 #ow,
 #
 #onn.dialect.default_sequence_base,
 #some data",
 #,
 #

 #ef test_autoincrement_on_insert(self, connection):

 #onnection.execute(
 #elf.tables.autoinc_pk.insert(), dict(data="some data")
 #
 #elf._assert_round_trip(self.tables.autoinc_pk, connection)

 #ef test_last_inserted_id(self, connection):

 # = connection.execute(
 #elf.tables.autoinc_pk.insert(), dict(data="some data")
 #
 #k = connection.scalar(select(self.tables.autoinc_pk.c.id))
 #q_(r.inserted_primary_key, (pk,))

 #requirements.dbapi_lastrowid
 #ef test_native_lastrowid_autoinc(self, connection):
 # = connection.execute(
 #elf.tables.autoinc_pk.insert(), dict(data="some data")
 #
 #astrowid = r.lastrowid
 #k = connection.scalar(select(self.tables.autoinc_pk.c.id))
 #q_(lastrowid, pk)


class InsertBehaviorTest(fixtures.TablesTest):
 #un_deletes = "each"
 #_backend__ = True

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #autoinc_pk",
 #etadata,
 #olumn(
 #id", Integer, primary_key=True, test_needs_autoincrement=True
 #,
 #olumn("data", String(50)),
 #
 #able(
 #manual_pk",
 #etadata,
 #olumn("id", Integer, primary_key=True, autoincrement=False),
 #olumn("data", String(50)),
 #
 #able(
 #includes_defaults",
 #etadata,
 #olumn(
 #id", Integer, primary_key=True, test_needs_autoincrement=True
 #,
 #olumn("data", String(50)),
 #olumn("x", Integer, default=5),
 #olumn(
 #y",
 #nteger,
 #efault=literal_column("2", type_=Integer) + literal(2),
 #,
 #

 #requirements.autoincrement_insert
 #ef test_autoclose_on_insert(self):
 #f requirements.returning.enabled:
 #ngine = engines.testing_engine(
 #ptions={"implicit_returning": False}
 #
 #lse:
 #ngine = config.db

 #ith engine.begin() as conn:
 # = conn.execute(
 #elf.tables.autoinc_pk.insert(), dict(data="some data")
 #
 #ssert r._soft_closed
 #ssert not r.closed
 #ssert r.is_insert

        # new as of I8091919d45421e3f53029b8660427f844fee0228; for the moment
        # an insert where the PK was taken from a row that the dialect
        # selected, as is the case for mssql/pyodbc, will still report
        # returns_rows as true because there's a cursor description.  in that
        # case, the row had to have been consumed at least.
 #ssert not r.returns_rows or r.fetchone() is None

 #requirements.returning
 #ef test_autoclose_on_insert_implicit_returning(self, connection):
 # = connection.execute(
 #elf.tables.autoinc_pk.insert(), dict(data="some data")
 #
 #ssert r._soft_closed
 #ssert not r.closed
 #ssert r.is_insert

        # note we are experimenting with having this be True
        # as of I8091919d45421e3f53029b8660427f844fee0228 .
        # implicit returning has fetched the row, but it still is a
        # "returns rows"
 #ssert r.returns_rows

        # and we should be able to fetchone() on it, we just get no row
 #q_(r.fetchone(), None)

        # and the keys, etc.
 #q_(r.keys(), ["id"])

        # but the dialect took in the row already.   not really sure
        # what the best behavior is.

 #requirements.empty_inserts
 #ef test_empty_insert(self, connection):
 # = connection.execute(self.tables.autoinc_pk.insert())
 #ssert r._soft_closed
 #ssert not r.closed

 # = connection.execute(
 #elf.tables.autoinc_pk.select().where(
 #elf.tables.autoinc_pk.c.id != None
 #
 #
 #q_(len(r.all()), 1)

 #requirements.empty_inserts_executemany
 #ef test_empty_insert_multiple(self, connection):
 # = connection.execute(self.tables.autoinc_pk.insert(), [{}, {}, {}])
 #ssert r._soft_closed
 #ssert not r.closed

 # = connection.execute(
 #elf.tables.autoinc_pk.select().where(
 #elf.tables.autoinc_pk.c.id != None
 #
 #

 #q_(len(r.all()), 3)

 #requirements.insert_from_select
 #ef test_insert_from_select_autoinc(self, connection):
 #rc_table = self.tables.manual_pk
 #est_table = self.tables.autoinc_pk
 #onnection.execute(
 #rc_table.insert(),
 #
 #ict(id=1, data="data1"),
 #ict(id=2, data="data2"),
 #ict(id=3, data="data3"),
 #,
 #

 #esult = connection.execute(
 #est_table.insert().from_select(
 #"data",),
 #elect(src_table.c.data).where(
 #rc_table.c.data.in_(["data2", "data3"])
 #,
 #
 #

 #q_(result.inserted_primary_key, (None,))

 #esult = connection.execute(
 #elect(dest_table.c.data).order_by(dest_table.c.data)
 #
 #q_(result.fetchall(), [("data2",), ("data3",)])

 #requirements.insert_from_select
 #ef test_insert_from_select_autoinc_no_rows(self, connection):
 #rc_table = self.tables.manual_pk
 #est_table = self.tables.autoinc_pk

 #esult = connection.execute(
 #est_table.insert().from_select(
 #"data",),
 #elect(src_table.c.data).where(
 #rc_table.c.data.in_(["data2", "data3"])
 #,
 #
 #
 #q_(result.inserted_primary_key, (None,))

 #esult = connection.execute(
 #elect(dest_table.c.data).order_by(dest_table.c.data)
 #

 #q_(result.fetchall(), [])

 #requirements.insert_from_select
 #ef test_insert_from_select(self, connection):
 #able = self.tables.manual_pk
 #onnection.execute(
 #able.insert(),
 #
 #ict(id=1, data="data1"),
 #ict(id=2, data="data2"),
 #ict(id=3, data="data3"),
 #,
 #

 #onnection.execute(
 #able.insert()
 #inline()
 #from_select(
 #"id", "data"),
 #elect(table.c.id + 5, table.c.data).where(
 #able.c.data.in_(["data2", "data3"])
 #,
 #
 #

 #q_(
 #onnection.execute(
 #elect(table.c.data).order_by(table.c.data)
 #.fetchall(),
 #("data1",), ("data2",), ("data2",), ("data3",), ("data3",)],
 #

 #requirements.insert_from_select
 #ef test_insert_from_select_with_defaults(self, connection):
 #able = self.tables.includes_defaults
 #onnection.execute(
 #able.insert(),
 #
 #ict(id=1, data="data1"),
 #ict(id=2, data="data2"),
 #ict(id=3, data="data3"),
 #,
 #

 #onnection.execute(
 #able.insert()
 #inline()
 #from_select(
 #"id", "data"),
 #elect(table.c.id + 5, table.c.data).where(
 #able.c.data.in_(["data2", "data3"])
 #,
 #
 #

 #q_(
 #onnection.execute(
 #elect(table).order_by(table.c.data, table.c.id)
 #.fetchall(),
 #
 #1, "data1", 5, 4),
 #2, "data2", 5, 4),
 #7, "data2", 5, 4),
 #3, "data3", 5, 4),
 #8, "data3", 5, 4),
 #,
 #


class ReturningTest(fixtures.TablesTest):
 #un_create_tables = "each"
 #_requires__ = "returning", "autoincrement_insert"
 #_backend__ = True

 #_engine_options__ = {"implicit_returning": True}

 #ef _assert_round_trip(self, table, conn):
 #ow = conn.execute(table.select()).first()
 #q_(
 #ow,
 #
 #onn.dialect.default_sequence_base,
 #some data",
 #,
 #

 #classmethod
 #ef define_tables(cls, metadata):
 #able(
 #autoinc_pk",
 #etadata,
 #olumn(
 #id", Integer, primary_key=True, test_needs_autoincrement=True
 #,
 #olumn("data", String(50)),
 #

 #requirements.fetch_rows_post_commit
 #ef test_explicit_returning_pk_autocommit(self, connection):
 #able = self.tables.autoinc_pk
 # = connection.execute(
 #able.insert().returning(table.c.id), dict(data="some data")
 #
 #k = r.first()[0]
 #etched_pk = connection.scalar(select(table.c.id))
 #q_(fetched_pk, pk)

 #ef test_explicit_returning_pk_no_autocommit(self, connection):
 #able = self.tables.autoinc_pk
 # = connection.execute(
 #able.insert().returning(table.c.id), dict(data="some data")
 #
 #k = r.first()[0]
 #etched_pk = connection.scalar(select(table.c.id))
 #q_(fetched_pk, pk)

 #ef test_autoincrement_on_insert_implicit_returning(self, connection):

 #onnection.execute(
 #elf.tables.autoinc_pk.insert(), dict(data="some data")
 #
 #elf._assert_round_trip(self.tables.autoinc_pk, connection)

 #ef test_last_inserted_id_implicit_returning(self, connection):

 # = connection.execute(
 #elf.tables.autoinc_pk.insert(), dict(data="some data")
 #
 #k = connection.scalar(select(self.tables.autoinc_pk.c.id))
 #q_(r.inserted_primary_key, (pk,))


__all__ = ("LastrowidTest", "InsertBehaviorTest", "ReturningTest")
