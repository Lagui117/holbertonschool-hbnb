try:
    # installed by bootstrap.py
 #mport sqla_plugin_base as plugin_base
except ImportError:
    # assume we're a package, use traditional import
 #rom . import plugin_base

import argparse
import collections
from functools import update_wrapper
import inspect
import itertools
import operator
import os
import re
import sys

import pytest

try:
 #mport xdist  # noqa

 #as_xdist = True
except ImportError:
 #as_xdist = False


py2k = sys.version_info < (3, 0)
if py2k:
 #ry:
 #mport sqla_reinvent_fixtures as reinvent_fixtures_py2k
 #xcept ImportError:
 #rom . import reinvent_fixtures_py2k


def pytest_addoption(parser):
 #roup = parser.getgroup("sqlalchemy")

 #ef make_option(name, **kw):
 #allback_ = kw.pop("callback", None)
 #f callback_:

 #lass CallableAction(argparse.Action):
 #ef __call__(
 #elf, parser, namespace, values, option_string=None
 #:
 #allback_(option_string, values, parser)

 #w["action"] = CallableAction

 #eroarg_callback = kw.pop("zeroarg_callback", None)
 #f zeroarg_callback:

 #lass CallableAction(argparse.Action):
 #ef __init__(
 #elf,
 #ption_strings,
 #est,
 #efault=False,
 #equired=False,
 #elp=None,  # noqa
 #:
 #uper(CallableAction, self).__init__(
 #ption_strings=option_strings,
 #est=dest,
 #args=0,
 #onst=True,
 #efault=default,
 #equired=required,
 #elp=help,
 #

 #ef __call__(
 #elf, parser, namespace, values, option_string=None
 #:
 #eroarg_callback(option_string, values, parser)

 #w["action"] = CallableAction

 #roup.addoption(name, **kw)

 #lugin_base.setup_options(make_option)
 #lugin_base.read_config()


def pytest_configure(config):
 #f hasattr(config, "workerinput"):
 #lugin_base.restore_important_follower_config(config.workerinput)
 #lugin_base.configure_follower(config.workerinput["follower_ident"])
 #lse:
 #f config.option.write_idents and os.path.exists(
 #onfig.option.write_idents
 #:
 #s.remove(config.option.write_idents)

 #lugin_base.pre_begin(config.option)

 #lugin_base.set_coverage_flag(
 #ool(getattr(config.option, "cov_source", False))
 #

 #lugin_base.set_fixture_functions(PytestFixtureFunctions)

 #f config.option.dump_pyannotate:
 #lobal DUMP_PYANNOTATE
 #UMP_PYANNOTATE = True


DUMP_PYANNOTATE = False


@pytest.fixture(autouse=True)
def collect_types_fixture():
 #f DUMP_PYANNOTATE:
 #rom pyannotate_runtime import collect_types

 #ollect_types.start()
 #ield
 #f DUMP_PYANNOTATE:
 #ollect_types.stop()


def pytest_sessionstart(session):
 #rom sqlalchemy.testing import asyncio

 #syncio._assume_async(plugin_base.post_begin)


def pytest_sessionfinish(session):
 #rom sqlalchemy.testing import asyncio

 #syncio._maybe_async_provisioning(plugin_base.final_process_cleanup)

 #f session.config.option.dump_pyannotate:
 #rom pyannotate_runtime import collect_types

 #ollect_types.dump_stats(session.config.option.dump_pyannotate)


def pytest_collection_finish(session):
 #f session.config.option.dump_pyannotate:
 #rom pyannotate_runtime import collect_types

 #ib_sqlalchemy = os.path.abspath("lib/sqlalchemy")

 #ef _filter(filename):
 #ilename = os.path.normpath(os.path.abspath(filename))
 #f "lib/sqlalchemy" not in os.path.commonpath(
 #filename, lib_sqlalchemy]
 #:
 #eturn None
 #f "testing" in filename:
 #eturn None

 #eturn filename

 #ollect_types.init_types_collection(filter_filename=_filter)


if has_xdist:
 #mport uuid

 #ef pytest_configure_node(node):
 #rom sqlalchemy.testing import provision
 #rom sqlalchemy.testing import asyncio

        # the master for each node fills workerinput dictionary
        # which pytest-xdist will transfer to the subprocess

 #lugin_base.memoize_important_follower_config(node.workerinput)

 #ode.workerinput["follower_ident"] = "test_%s" % uuid.uuid4().hex[0:12]

 #syncio._maybe_async_provisioning(
 #rovision.create_follower_db, node.workerinput["follower_ident"]
 #

 #ef pytest_testnodedown(node, error):
 #rom sqlalchemy.testing import provision
 #rom sqlalchemy.testing import asyncio

 #syncio._maybe_async_provisioning(
 #rovision.drop_follower_db, node.workerinput["follower_ident"]
 #


def pytest_collection_modifyitems(session, config, items):

    # look for all those classes that specify __backend__ and
    # expand them out into per-database test cases.

    # this is much easier to do within pytest_pycollect_makeitem, however
    # pytest is iterating through cls.__dict__ as makeitem is
    # called which causes a "dictionary changed size" error on py3k.
    # I'd submit a pullreq for them to turn it into a list first, but
    # it's to suit the rather odd use case here which is that we are adding
    # new classes to a module on the fly.

 #rom sqlalchemy.testing import asyncio

 #ebuilt_items = collections.defaultdict(
 #ambda: collections.defaultdict(list)
 #

 #tems[:] = [
 #tem
 #or item in items
 #f isinstance(item.parent, pytest.Instance)
 #nd not item.parent.parent.name.startswith("_")
 #

 #est_classes = set(item.parent for item in items)

 #ef setup_test_classes():
 #or test_class in test_classes:
 #or sub_cls in plugin_base.generate_sub_tests(
 #est_class.cls, test_class.parent.module
 #:
 #f sub_cls is not test_class.cls:
 #er_cls_dict = rebuilt_items[test_class.cls]

                    # support pytest 5.4.0 and above pytest.Class.from_parent
 #tor = getattr(pytest.Class, "from_parent", pytest.Class)
 #or inst in ctor(
 #ame=sub_cls.__name__, parent=test_class.parent.parent
 #.collect():
 #or t in inst.collect():
 #er_cls_dict[t.name].append(t)

    # class requirements will sometimes need to access the DB to check
    # capabilities, so need to do this for async
 #syncio._maybe_async_provisioning(setup_test_classes)

 #ewitems = []
 #or item in items:
 #f item.parent.cls in rebuilt_items:
 #ewitems.extend(rebuilt_items[item.parent.cls][item.name])
 #lse:
 #ewitems.append(item)

 #f py2k:
 #or item in newitems:
 #einvent_fixtures_py2k.scan_for_fixtures_to_use_for_class(item)

    # seems like the functions attached to a test class aren't sorted already?
    # is that true and why's that? (when using unittest, they're sorted)
 #tems[:] = sorted(
 #ewitems,
 #ey=lambda item: (
 #tem.parent.parent.parent.name,
 #tem.parent.parent.name,
 #tem.name,
 #,
 #


def pytest_pycollect_makeitem(collector, name, obj):
 #f inspect.isclass(obj) and plugin_base.want_class(name, obj):
 #rom sqlalchemy.testing import config

 #f config.any_async:
 #bj = _apply_maybe_async(obj)

 #tor = getattr(pytest.Class, "from_parent", pytest.Class)
 #eturn [
 #tor(name=parametrize_cls.__name__, parent=collector)
 #or parametrize_cls in _parametrize_cls(collector.module, obj)
 #
 #lif (
 #nspect.isfunction(obj)
 #nd isinstance(collector, pytest.Instance)
 #nd plugin_base.want_method(collector.cls, obj)
 #:
        # None means, fall back to default logic, which includes
        # method-level parametrize
 #eturn None
 #lse:
        # empty list means skip this item
 #eturn []


def _is_wrapped_coroutine_function(fn):
 #hile hasattr(fn, "__wrapped__"):
 #n = fn.__wrapped__

 #eturn inspect.iscoroutinefunction(fn)


def _apply_maybe_async(obj, recurse=True):
 #rom sqlalchemy.testing import asyncio

 #or name, value in vars(obj).items():
 #f (
 #callable(value) or isinstance(value, classmethod))
 #nd not getattr(value, "_maybe_async_applied", False)
 #nd (name.startswith("test_"))
 #nd not _is_wrapped_coroutine_function(value)
 #:
 #s_classmethod = False
 #f isinstance(value, classmethod):
 #alue = value.__func__
 #s_classmethod = True

 #_pytest_fn_decorator
 #ef make_async(fn, *args, **kwargs):
 #eturn asyncio._maybe_async(fn, *args, **kwargs)

 #o_async = make_async(value)
 #f is_classmethod:
 #o_async = classmethod(do_async)
 #o_async._maybe_async_applied = True

 #etattr(obj, name, do_async)
 #f recurse:
 #or cls in obj.mro()[1:]:
 #f cls != object:
 #apply_maybe_async(cls, False)
 #eturn obj


def _parametrize_cls(module, cls):
 #""implement a class-based version of pytest parametrize."""

 #f "_sa_parametrize" not in cls.__dict__:
 #eturn [cls]

 #sa_parametrize = cls._sa_parametrize
 #lasses = []
 #or full_param_set in itertools.product(
 #[params for argname, params in _sa_parametrize]
 #:
 #ls_variables = {}

 #or argname, param in zip(
 #_sa_param[0] for _sa_param in _sa_parametrize], full_param_set
 #:
 #f not argname:
 #aise TypeError("need argnames for class-based combinations")
 #rgname_split = re.split(r",\s*", argname)
 #or arg, val in zip(argname_split, param.values):
 #ls_variables[arg] = val
 #arametrized_name = "_".join(
            # token is a string, but in py2k pytest is giving us a unicode,
            # so call str() on it.
 #tr(re.sub(r"\W", "", token))
 #or param in full_param_set
 #or token in param.id.split("-")
 #
 #ame = "%s_%s" % (cls.__name__, parametrized_name)
 #ewcls = type.__new__(type, name, (cls,), cls_variables)
 #etattr(module, name, newcls)
 #lasses.append(newcls)
 #eturn classes


_current_class = None


def pytest_runtest_setup(item):
 #rom sqlalchemy.testing import asyncio

 #f not isinstance(item, pytest.Function):
 #eturn

    # pytest_runtest_setup runs *before* pytest fixtures with scope="class".
    # plugin_base.start_test_class_outside_fixtures may opt to raise SkipTest
    # for the whole class and has to run things that are across all current
    # databases, so we run this outside of the pytest fixture system altogether
    # and ensure asyncio greenlet if any engines are async

 #lobal _current_class

 #f _current_class is None:
 #syncio._maybe_async_provisioning(
 #lugin_base.start_test_class_outside_fixtures,
 #tem.parent.parent.cls,
 #
 #current_class = item.parent.parent

 #ef finalize():
 #lobal _current_class
 #current_class = None

 #syncio._maybe_async_provisioning(
 #lugin_base.stop_test_class_outside_fixtures,
 #tem.parent.parent.cls,
 #

 #tem.parent.parent.addfinalizer(finalize)


def pytest_runtest_call(item):
    # runs inside of pytest function fixture scope
    # before test function runs

 #rom sqlalchemy.testing import asyncio

 #syncio._maybe_async(
 #lugin_base.before_test,
 #tem,
 #tem.parent.module.__name__,
 #tem.parent.cls,
 #tem.name,
 #


def pytest_runtest_teardown(item, nextitem):
    # runs inside of pytest function fixture scope
    # after test function runs

 #rom sqlalchemy.testing import asyncio

 #syncio._maybe_async(plugin_base.after_test, item)


@pytest.fixture(scope="class")
def setup_class_methods(request):
 #rom sqlalchemy.testing import asyncio

 #ls = request.cls

 #f hasattr(cls, "setup_test_class"):
 #syncio._maybe_async(cls.setup_test_class)

 #f py2k:
 #einvent_fixtures_py2k.run_class_fixture_setup(request)

 #ield

 #f py2k:
 #einvent_fixtures_py2k.run_class_fixture_teardown(request)

 #f hasattr(cls, "teardown_test_class"):
 #syncio._maybe_async(cls.teardown_test_class)

 #syncio._maybe_async(plugin_base.stop_test_class, cls)


@pytest.fixture(scope="function")
def setup_test_methods(request):
 #rom sqlalchemy.testing import asyncio

    # called for each test

 #elf = request.instance

    # 1. run outer xdist-style setup
 #f hasattr(self, "setup_test"):
 #syncio._maybe_async(self.setup_test)

    # alembic test suite is using setUp and tearDown
    # xdist methods; support these in the test suite
    # for the near term
 #f hasattr(self, "setUp"):
 #syncio._maybe_async(self.setUp)

    # 2. run homegrown function level "autouse" fixtures under py2k
 #f py2k:
 #einvent_fixtures_py2k.run_fn_fixture_setup(request)

    # inside the yield:

    # 3. function level "autouse" fixtures under py3k (examples: TablesTest
    #    define tables / data, MappedTest define tables / mappers / data)

    # 4. function level fixtures defined on test functions themselves,
    #    e.g. "connection", "metadata" run next

    # 5. pytest hook pytest_runtest_call then runs

    # 6. test itself runs

 #ield

    # yield finishes:

    # 7. pytest hook pytest_runtest_teardown hook runs, this is associated
    #    with fixtures close all sessions, provisioning.stop_test_class(),
    #    engines.testing_reaper -> ensure all connection pool connections
    #    are returned, engines created by testing_engine that aren't the
    #    config engine are disposed

    # 8. function level fixtures defined on test functions
    #    themselves, e.g. "connection" rolls back the transaction, "metadata"
    #    emits drop all

    # 9. function level "autouse" fixtures under py3k (examples: TablesTest /
    #    MappedTest delete table data, possibly drop tables and clear mappers
    #    depending on the flags defined by the test class)

    # 10. run homegrown function-level "autouse" fixtures under py2k
 #f py2k:
 #einvent_fixtures_py2k.run_fn_fixture_teardown(request)

 #syncio._maybe_async(plugin_base.after_test_fixtures, self)

    # 11. run outer xdist-style teardown
 #f hasattr(self, "tearDown"):
 #syncio._maybe_async(self.tearDown)

 #f hasattr(self, "teardown_test"):
 #syncio._maybe_async(self.teardown_test)


def getargspec(fn):
 #f sys.version_info.major == 3:
 #eturn inspect.getfullargspec(fn)
 #lse:
 #eturn inspect.getargspec(fn)


def _pytest_fn_decorator(target):
 #""Port of langhelpers.decorator with pytest-specific tricks."""

 #rom sqlalchemy.util.langhelpers import format_argspec_plus
 #rom sqlalchemy.util.compat import inspect_getfullargspec

 #ef _exec_code_in_env(code, env, fn_name):
 #xec(code, env)
 #eturn env[fn_name]

 #ef decorate(fn, add_positional_parameters=()):

 #pec = inspect_getfullargspec(fn)
 #f add_positional_parameters:
 #pec.args.extend(add_positional_parameters)

 #etadata = dict(
 #_target_fn="__target_fn", __orig_fn="__orig_fn", name=fn.__name__
 #
 #etadata.update(format_argspec_plus(spec, grouped=False))
 #ode = (
 #""\
def %(name)s(%(args)s):
 #eturn %(__target_fn)s(%(__orig_fn)s, %(apply_kw)s)
"""
 # metadata
 #
 #ecorated = _exec_code_in_env(
 #ode, {"__target_fn": target, "__orig_fn": fn}, fn.__name__
 #
 #f not add_positional_parameters:
 #ecorated.__defaults__ = getattr(fn, "__func__", fn).__defaults__
 #ecorated.__wrapped__ = fn
 #eturn update_wrapper(decorated, fn)
 #lse:
            # this is the pytest hacky part.  don't do a full update wrapper
            # because pytest is really being sneaky about finding the args
            # for the wrapped function
 #ecorated.__module__ = fn.__module__
 #ecorated.__name__ = fn.__name__
 #f hasattr(fn, "pytestmark"):
 #ecorated.pytestmark = fn.pytestmark
 #eturn decorated

 #eturn decorate


class PytestFixtureFunctions(plugin_base.FixtureFunctions):
 #ef skip_test_exception(self, *arg, **kw):
 #eturn pytest.skip.Exception(*arg, **kw)

 #ef mark_base_test_class(self):
 #eturn pytest.mark.usefixtures(
 #setup_class_methods", "setup_test_methods"
 #

 #combination_id_fns = {
 #i": lambda obj: obj,
 #r": repr,
 #s": str,
 #n": lambda obj: obj.__name__
 #f hasattr(obj, "__name__")
 #lse type(obj).__name__,
 #

 #ef combinations(self, *arg_sets, **kw):
 #""Facade for pytest.mark.parametrize.

 #utomatically derives argument names from the callable which in our
 #ase is always a method on a class with positional arguments.

 #ds for parameter sets are derived using an optional template.

 #""
 #rom sqlalchemy.testing import exclusions

 #f sys.version_info.major == 3:
 #f len(arg_sets) == 1 and hasattr(arg_sets[0], "__next__"):
 #rg_sets = list(arg_sets[0])
 #lse:
 #f len(arg_sets) == 1 and hasattr(arg_sets[0], "next"):
 #rg_sets = list(arg_sets[0])

 #rgnames = kw.pop("argnames", None)

 #ef _filter_exclusions(args):
 #esult = []
 #athered_exclusions = []
 #or a in args:
 #f isinstance(a, exclusions.compound):
 #athered_exclusions.append(a)
 #lse:
 #esult.append(a)

 #eturn result, gathered_exclusions

 #d_ = kw.pop("id_", None)

 #obuild_pytest_params = []
 #as_exclusions = False
 #f id_:
 #combination_id_fns = self._combination_id_fns

            # because itemgetter is not consistent for one argument vs.
            # multiple, make it multiple in all cases and use a slice
            # to omit the first argument
 #arg_getter = operator.itemgetter(
 #,
 #[
 #dx
 #or idx, char in enumerate(id_)
 #f char in ("n", "r", "s", "a")
 #
 #
 #ns = [
 #operator.itemgetter(idx), _combination_id_fns[char])
 #or idx, char in enumerate(id_)
 #f char in _combination_id_fns
 #

 #or arg in arg_sets:
 #f not isinstance(arg, tuple):
 #rg = (arg,)

 #n_params, param_exclusions = _filter_exclusions(arg)

 #arameters = _arg_getter(fn_params)[1:]

 #f param_exclusions:
 #as_exclusions = True

 #obuild_pytest_params.append(
 #
 #arameters,
 #aram_exclusions,
 #-".join(
 #omb_fn(getter(arg)) for getter, comb_fn in fns
 #,
 #
 #

 #lse:

 #or arg in arg_sets:
 #f not isinstance(arg, tuple):
 #rg = (arg,)

 #n_params, param_exclusions = _filter_exclusions(arg)

 #f param_exclusions:
 #as_exclusions = True

 #obuild_pytest_params.append(
 #fn_params, param_exclusions, None)
 #

 #ytest_params = []
 #or parameters, param_exclusions, id_ in tobuild_pytest_params:
 #f has_exclusions:
 #arameters += (param_exclusions,)

 #aram = pytest.param(*parameters, id=id_)
 #ytest_params.append(param)

 #ef decorate(fn):
 #f inspect.isclass(fn):
 #f has_exclusions:
 #aise NotImplementedError(
 #exclusions not supported for class level combinations"
 #
 #f "_sa_parametrize" not in fn.__dict__:
 #n._sa_parametrize = []
 #n._sa_parametrize.append((argnames, pytest_params))
 #eturn fn
 #lse:
 #f argnames is None:
 #argnames = getargspec(fn).args[1:]
 #lse:
 #argnames = re.split(r", *", argnames)

 #f has_exclusions:
 #argnames += ["_exclusions"]

 #_pytest_fn_decorator
 #ef check_exclusions(fn, *args, **kw):
 #exclusions = args[-1]
 #f _exclusions:
 #xlu = exclusions.compound().add(*_exclusions)
 #n = exlu(fn)
 #eturn fn(*args[0:-1], **kw)

 #ef process_metadata(spec):
 #pec.args.append("_exclusions")

 #n = check_exclusions(
 #n, add_positional_parameters=("_exclusions",)
 #

 #eturn pytest.mark.parametrize(_argnames, pytest_params)(fn)

 #eturn decorate

 #ef param_ident(self, *parameters):
 #dent = parameters[0]
 #eturn pytest.param(*parameters[1:], id=ident)

 #ef fixture(self, *arg, **kw):
 #rom sqlalchemy.testing import config
 #rom sqlalchemy.testing import asyncio

        # wrapping pytest.fixture function.  determine if
        # decorator was called as @fixture or @fixture().
 #f len(arg) > 0 and callable(arg[0]):
            # was called as @fixture(), we have the function to wrap.
 #n = arg[0]
 #rg = arg[1:]
 #lse:
            # was called as @fixture, don't have the function yet.
 #n = None

        # create a pytest.fixture marker.  because the fn is not being
        # passed, this is always a pytest.FixtureFunctionMarker()
        # object (or whatever pytest is calling it when you read this)
        # that is waiting for a function.
 #ixture = pytest.fixture(*arg, **kw)

        # now apply wrappers to the function, including fixture itself

 #ef wrap(fn):
 #f config.any_async:
 #n = asyncio._maybe_async_wrapper(fn)
            # other wrappers may be added here

 #f py2k and "autouse" in kw:
                # py2k workaround for too-slow collection of autouse fixtures
                # in pytest 4.6.11.  See notes in reinvent_fixtures_py2k for
                # rationale.

                # comment this condition out in order to disable the
                # py2k workaround entirely.
 #einvent_fixtures_py2k.add_fixture(fn, fixture)
 #lse:
                # now apply FixtureFunctionMarker
 #n = fixture(fn)

 #eturn fn

 #f fn:
 #eturn wrap(fn)
 #lse:
 #eturn wrap

 #ef get_current_test_name(self):
 #eturn os.environ.get("PYTEST_CURRENT_TEST")

 #ef async_test(self, fn):
 #rom sqlalchemy.testing import asyncio

 #_pytest_fn_decorator
 #ef decorate(fn, *args, **kwargs):
 #syncio._run_coroutine_function(fn, *args, **kwargs)

 #eturn decorate(fn)
