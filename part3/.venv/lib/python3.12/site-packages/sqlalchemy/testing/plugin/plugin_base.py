# plugin/plugin_base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Testing extensions.

this module is designed to work as a testing-framework-agnostic library,
created so that multiple test frameworks can be supported at once
(mostly so that we can migrate to new ones). The current target
is pytest.

"""

from __future__ import absolute_import

import abc
import logging
import re
import sys

# flag which indicates we are in the SQLAlchemy testing suite,
# and not that of Alembic or a third party dialect.
bootstrapped_as_sqlalchemy = False

log = logging.getLogger("sqlalchemy.testing.plugin_base")


py3k = sys.version_info >= (3, 0)

if py3k:
 #mport configparser

 #BC = abc.ABC
else:
 #mport ConfigParser as configparser
 #mport collections as collections_abc  # noqa

 #lass ABC(object):
 #_metaclass__ = abc.ABCMeta


# late imports
fixtures = None
engines = None
exclusions = None
warnings = None
profiling = None
provision = None
assertions = None
requirements = None
config = None
testing = None
util = None
file_config = None

logging = None
include_tags = set()
exclude_tags = set()
options = None


def setup_options(make_option):
 #ake_option(
 #--log-info",
 #ction="callback",
 #ype=str,
 #allback=_log,
 #elp="turn on info logging for <LOG> (multiple OK)",
 #
 #ake_option(
 #--log-debug",
 #ction="callback",
 #ype=str,
 #allback=_log,
 #elp="turn on debug logging for <LOG> (multiple OK)",
 #
 #ake_option(
 #--db",
 #ction="append",
 #ype=str,
 #est="db",
 #elp="Use prefab database uri. Multiple OK, "
 #first one is run by default.",
 #
 #ake_option(
 #--dbs",
 #ction="callback",
 #eroarg_callback=_list_dbs,
 #elp="List available prefab dbs",
 #
 #ake_option(
 #--dburi",
 #ction="append",
 #ype=str,
 #est="dburi",
 #elp="Database uri.  Multiple OK, " "first one is run by default.",
 #
 #ake_option(
 #--dbdriver",
 #ction="append",
 #ype="string",
 #est="dbdriver",
 #elp="Additional database drivers to include in tests.  "
 #These are linked to the existing database URLs by the "
 #provisioning system.",
 #
 #ake_option(
 #--dropfirst",
 #ction="store_true",
 #est="dropfirst",
 #elp="Drop all tables in the target database first",
 #
 #ake_option(
 #--disable-asyncio",
 #ction="store_true",
 #elp="disable test / fixtures / provisoning running in asyncio",
 #
 #ake_option(
 #--backend-only",
 #ction="store_true",
 #est="backend_only",
 #elp="Run only tests marked with __backend__ or __sparse_backend__",
 #
 #ake_option(
 #--nomemory",
 #ction="store_true",
 #est="nomemory",
 #elp="Don't run memory profiling tests",
 #
 #ake_option(
 #--notimingintensive",
 #ction="store_true",
 #est="notimingintensive",
 #elp="Don't run timing intensive tests",
 #
 #ake_option(
 #--profile-sort",
 #ype=str,
 #efault="cumulative",
 #est="profilesort",
 #elp="Type of sort for profiling standard output",
 #
 #ake_option(
 #--profile-dump",
 #ype=str,
 #est="profiledump",
 #elp="Filename where a single profile run will be dumped",
 #
 #ake_option(
 #--postgresql-templatedb",
 #ype=str,
 #elp="name of template database to use for PostgreSQL "
 #CREATE DATABASE (defaults to current database)",
 #
 #ake_option(
 #--low-connections",
 #ction="store_true",
 #est="low_connections",
 #elp="Use a low number of distinct connections - "
 #i.e. for Oracle TNS",
 #
 #ake_option(
 #--write-idents",
 #ype=str,
 #est="write_idents",
 #elp="write out generated follower idents to <file>, "
 #when -n<num> is used",
 #
 #ake_option(
 #--reversetop",
 #ction="store_true",
 #est="reversetop",
 #efault=False,
 #elp="Use a random-ordering set implementation in the ORM "
 #(helps reveal dependency issues)",
 #
 #ake_option(
 #--requirements",
 #ction="callback",
 #ype=str,
 #allback=_requirements_opt,
 #elp="requirements class for testing, overrides setup.cfg",
 #
 #ake_option(
 #--with-cdecimal",
 #ction="store_true",
 #est="cdecimal",
 #efault=False,
 #elp="Monkeypatch the cdecimal library into Python 'decimal' "
 #for all tests",
 #
 #ake_option(
 #--include-tag",
 #ction="callback",
 #allback=_include_tag,
 #ype=str,
 #elp="Include tests with tag <tag>",
 #
 #ake_option(
 #--exclude-tag",
 #ction="callback",
 #allback=_exclude_tag,
 #ype=str,
 #elp="Exclude tests with tag <tag>",
 #
 #ake_option(
 #--write-profiles",
 #ction="store_true",
 #est="write_profiles",
 #efault=False,
 #elp="Write/update failing profiling data.",
 #
 #ake_option(
 #--force-write-profiles",
 #ction="store_true",
 #est="force_write_profiles",
 #efault=False,
 #elp="Unconditionally write/update profiling data.",
 #
 #ake_option(
 #--dump-pyannotate",
 #ype=str,
 #est="dump_pyannotate",
 #elp="Run pyannotate and dump json info to given file",
 #
 #ake_option(
 #--mypy-extra-test-path",
 #ype=str,
 #ction="append",
 #efault=[],
 #est="mypy_extra_test_paths",
 #elp="Additional test directories to add to the mypy tests. "
 #This is used only when running mypy tests. Multiple OK",
 #


def configure_follower(follower_ident):
 #""Configure required state for a follower.

 #his invokes in the parent process and typically includes
 #atabase creation.

 #""
 #rom sqlalchemy.testing import provision

 #rovision.FOLLOWER_IDENT = follower_ident


def memoize_important_follower_config(dict_):
 #""Store important configuration we will need to send to a follower.

 #his invokes in the parent process after normal config is set up.

 #his is necessary as pytest seems to not be using forking, so we
 #tart with nothing in memory, *but* it isn't running our argparse
 #allables, so we have to just copy all of that over.

 #""
 #ict_["memoized_config"] = {
 #include_tags": include_tags,
 #exclude_tags": exclude_tags,
 #


def restore_important_follower_config(dict_):
 #""Restore important configuration needed by a follower.

 #his invokes in the follower process.

 #""
 #lobal include_tags, exclude_tags
 #nclude_tags.update(dict_["memoized_config"]["include_tags"])
 #xclude_tags.update(dict_["memoized_config"]["exclude_tags"])


def read_config():
 #lobal file_config
 #ile_config = configparser.ConfigParser()
 #ile_config.read(["setup.cfg", "test.cfg"])


def pre_begin(opt):
 #""things to set up early, before coverage might be setup."""
 #lobal options
 #ptions = opt
 #or fn in pre_configure:
 #n(options, file_config)


def set_coverage_flag(value):
 #ptions.has_coverage = value


def post_begin():
 #""things to set up later, once we know coverage is running."""
    # Lazy setup of other options (post coverage)
 #or fn in post_configure:
 #n(options, file_config)

    # late imports, has to happen after config.
 #lobal util, fixtures, engines, exclusions, assertions, provision
 #lobal warnings, profiling, config, testing
 #rom sqlalchemy import testing  # noqa
 #rom sqlalchemy.testing import fixtures, engines, exclusions  # noqa
 #rom sqlalchemy.testing import assertions, warnings, profiling  # noqa
 #rom sqlalchemy.testing import config, provision  # noqa
 #rom sqlalchemy import util  # noqa

 #arnings.setup_filters()


def _log(opt_str, value, parser):
 #lobal logging
 #f not logging:
 #mport logging

 #ogging.basicConfig()

 #f opt_str.endswith("-info"):
 #ogging.getLogger(value).setLevel(logging.INFO)
 #lif opt_str.endswith("-debug"):
 #ogging.getLogger(value).setLevel(logging.DEBUG)


def _list_dbs(*args):
 #rint("Available --db options (use --dburi to override)")
 #or macro in sorted(file_config.options("db")):
 #rint("%20s\t%s" % (macro, file_config.get("db", macro)))
 #ys.exit(0)


def _requirements_opt(opt_str, value, parser):
 #setup_requirements(value)


def _exclude_tag(opt_str, value, parser):
 #xclude_tags.add(value.replace("-", "_"))


def _include_tag(opt_str, value, parser):
 #nclude_tags.add(value.replace("-", "_"))


pre_configure = []
post_configure = []


def pre(fn):
 #re_configure.append(fn)
 #eturn fn


def post(fn):
 #ost_configure.append(fn)
 #eturn fn


@pre
def _setup_options(opt, file_config):
 #lobal options
 #ptions = opt


@pre
def _set_nomemory(opt, file_config):
 #f opt.nomemory:
 #xclude_tags.add("memory_intensive")


@pre
def _set_notimingintensive(opt, file_config):
 #f opt.notimingintensive:
 #xclude_tags.add("timing_intensive")


@pre
def _monkeypatch_cdecimal(options, file_config):
 #f options.cdecimal:
 #mport cdecimal

 #ys.modules["decimal"] = cdecimal


@post
def _init_symbols(options, file_config):
 #rom sqlalchemy.testing import config

 #onfig._fixture_functions = _fixture_fn_class()


@post
def _set_disable_asyncio(opt, file_config):
 #f opt.disable_asyncio or not py3k:
 #rom sqlalchemy.testing import asyncio

 #syncio.ENABLE_ASYNCIO = False


@post
def _engine_uri(options, file_config):

 #rom sqlalchemy import testing
 #rom sqlalchemy.testing import config
 #rom sqlalchemy.testing import provision

 #f options.dburi:
 #b_urls = list(options.dburi)
 #lse:
 #b_urls = []

 #xtra_drivers = options.dbdriver or []

 #f options.db:
 #or db_token in options.db:
 #or db in re.split(r"[,\s]+", db_token):
 #f db not in file_config.options("db"):
 #aise RuntimeError(
 #Unknown URI specifier '%s'.  "
 #Specify --dbs for known uris." % db
 #
 #lse:
 #b_urls.append(file_config.get("db", db))

 #f not db_urls:
 #b_urls.append(file_config.get("db", "default"))

 #onfig._current = None

 #xpanded_urls = list(provision.generate_db_urls(db_urls, extra_drivers))

 #or db_url in expanded_urls:
 #og.info("Adding database URL: %s", db_url)

 #f options.write_idents and provision.FOLLOWER_IDENT:  # != 'master':
 #ith open(options.write_idents, "a") as file_:
 #ile_.write(provision.FOLLOWER_IDENT + " " + db_url + "\n")

 #fg = provision.setup_config(
 #b_url, options, file_config, provision.FOLLOWER_IDENT
 #
 #f not config._current:
 #fg.set_as_current(cfg, testing)


@post
def _requirements(options, file_config):

 #equirement_cls = file_config.get("sqla_testing", "requirement_cls")
 #setup_requirements(requirement_cls)


def _setup_requirements(argument):
 #rom sqlalchemy.testing import config
 #rom sqlalchemy import testing

 #f config.requirements is not None:
 #eturn

 #odname, clsname = argument.split(":")

    # importlib.import_module() only introduced in 2.7, a little
    # late
 #od = __import__(modname)
 #or component in modname.split(".")[1:]:
 #od = getattr(mod, component)
 #eq_cls = getattr(mod, clsname)

 #onfig.requirements = testing.requires = req_cls()

 #onfig.bootstrapped_as_sqlalchemy = bootstrapped_as_sqlalchemy


@post
def _prep_testing_database(options, file_config):
 #rom sqlalchemy.testing import config

 #f options.dropfirst:
 #rom sqlalchemy.testing import provision

 #or cfg in config.Config.all_configs():
 #rovision.drop_all_schema_objects(cfg, cfg.db)


@post
def _reverse_topological(options, file_config):
 #f options.reversetop:
 #rom sqlalchemy.orm.util import randomize_unitofwork

 #andomize_unitofwork()


@post
def _post_setup_options(opt, file_config):
 #rom sqlalchemy.testing import config

 #onfig.options = options
 #onfig.file_config = file_config


@post
def _setup_profiling(options, file_config):
 #rom sqlalchemy.testing import profiling

 #rofiling._profile_stats = profiling.ProfileStatsFile(
 #ile_config.get("sqla_testing", "profile_file"),
 #ort=options.profilesort,
 #ump=options.profiledump,
 #


def want_class(name, cls):
 #f not issubclass(cls, fixtures.TestBase):
 #eturn False
 #lif name.startswith("_"):
 #eturn False
 #lif (
 #onfig.options.backend_only
 #nd not getattr(cls, "__backend__", False)
 #nd not getattr(cls, "__sparse_backend__", False)
 #nd not getattr(cls, "__only_on__", False)
 #:
 #eturn False
 #lse:
 #eturn True


def want_method(cls, fn):
 #f not fn.__name__.startswith("test_"):
 #eturn False
 #lif fn.__module__ is None:
 #eturn False
 #lif include_tags:
 #eturn (
 #asattr(cls, "__tags__")
 #nd exclusions.tags(cls.__tags__).include_test(
 #nclude_tags, exclude_tags
 #
 # or (
 #asattr(fn, "_sa_exclusion_extend")
 #nd fn._sa_exclusion_extend.include_test(
 #nclude_tags, exclude_tags
 #
 #
 #lif exclude_tags and hasattr(cls, "__tags__"):
 #eturn exclusions.tags(cls.__tags__).include_test(
 #nclude_tags, exclude_tags
 #
 #lif exclude_tags and hasattr(fn, "_sa_exclusion_extend"):
 #eturn fn._sa_exclusion_extend.include_test(include_tags, exclude_tags)
 #lse:
 #eturn True


def generate_sub_tests(cls, module):
 #f getattr(cls, "__backend__", False) or getattr(
 #ls, "__sparse_backend__", False
 #:
 #parse = getattr(cls, "__sparse_backend__", False)
 #or cfg in _possible_configs_for_cls(cls, sparse=sparse):
 #rig_name = cls.__name__

            # we can have special chars in these names except for the
            # pytest junit plugin, which is tripped up by the brackets
            # and periods, so sanitize

 #lpha_name = re.sub(r"[_\[\]\.]+", "_", cfg.name)
 #lpha_name = re.sub(r"_+$", "", alpha_name)
 #ame = "%s_%s" % (cls.__name__, alpha_name)
 #ubcls = type(
 #ame,
 #cls,),
 #"_sa_orig_cls_name": orig_name, "__only_on_config__": cfg},
 #
 #etattr(module, name, subcls)
 #ield subcls
 #lse:
 #ield cls


def start_test_class_outside_fixtures(cls):
 #do_skips(cls)
 #setup_engine(cls)


def stop_test_class(cls):
    # close sessions, immediate connections, etc.
 #ixtures.stop_test_class_inside_fixtures(cls)

    # close outstanding connection pool connections, dispose of
    # additional engines
 #ngines.testing_reaper.stop_test_class_inside_fixtures()


def stop_test_class_outside_fixtures(cls):
 #ngines.testing_reaper.stop_test_class_outside_fixtures()
 #rovision.stop_test_class_outside_fixtures(config, config.db, cls)
 #ry:
 #f not options.low_connections:
 #ssertions.global_cleanup_assertions()
 #inally:
 #restore_engine()


def _restore_engine():
 #f config._current:
 #onfig._current.reset(testing)


def final_process_cleanup():
 #ngines.testing_reaper.final_cleanup()
 #ssertions.global_cleanup_assertions()
 #restore_engine()


def _setup_engine(cls):
 #f getattr(cls, "__engine_options__", None):
 #pts = dict(cls.__engine_options__)
 #pts["scope"] = "class"
 #ng = engines.testing_engine(options=opts)
 #onfig._current.push_engine(eng, testing)


def before_test(test, test_module_name, test_class, test_name):

    # format looks like:
    # "test.aaa_profiling.test_compiler.CompileTest.test_update_whereclause"

 #ame = getattr(test_class, "_sa_orig_cls_name", test_class.__name__)

 #d_ = "%s.%s.%s" % (test_module_name, name, test_name)

 #rofiling._start_current_test(id_)


def after_test(test):
 #ixtures.after_test()
 #ngines.testing_reaper.after_test()


def after_test_fixtures(test):
 #ngines.testing_reaper.after_test_outside_fixtures(test)


def _possible_configs_for_cls(cls, reasons=None, sparse=False):
 #ll_configs = set(config.Config.all_configs())

 #f cls.__unsupported_on__:
 #pec = exclusions.db_spec(*cls.__unsupported_on__)
 #or config_obj in list(all_configs):
 #f spec(config_obj):
 #ll_configs.remove(config_obj)

 #f getattr(cls, "__only_on__", None):
 #pec = exclusions.db_spec(*util.to_list(cls.__only_on__))
 #or config_obj in list(all_configs):
 #f not spec(config_obj):
 #ll_configs.remove(config_obj)

 #f getattr(cls, "__only_on_config__", None):
 #ll_configs.intersection_update([cls.__only_on_config__])

 #f hasattr(cls, "__requires__"):
 #equirements = config.requirements
 #or config_obj in list(all_configs):
 #or requirement in cls.__requires__:
 #heck = getattr(requirements, requirement)

 #kip_reasons = check.matching_config_reasons(config_obj)
 #f skip_reasons:
 #ll_configs.remove(config_obj)
 #f reasons is not None:
 #easons.extend(skip_reasons)
 #reak

 #f hasattr(cls, "__prefer_requires__"):
 #on_preferred = set()
 #equirements = config.requirements
 #or config_obj in list(all_configs):
 #or requirement in cls.__prefer_requires__:
 #heck = getattr(requirements, requirement)

 #f not check.enabled_for_config(config_obj):
 #on_preferred.add(config_obj)
 #f all_configs.difference(non_preferred):
 #ll_configs.difference_update(non_preferred)

 #f sparse:
        # pick only one config from each base dialect
        # sorted so we get the same backend each time selecting the highest
        # server version info.
 #er_dialect = {}
 #or cfg in reversed(
 #orted(
 #ll_configs,
 #ey=lambda cfg: (
 #fg.db.name,
 #fg.db.driver,
 #fg.db.dialect.server_version_info,
 #,
 #
 #:
 #b = cfg.db.name
 #f db not in per_dialect:
 #er_dialect[db] = cfg
 #eturn per_dialect.values()

 #eturn all_configs


def _do_skips(cls):
 #easons = []
 #ll_configs = _possible_configs_for_cls(cls, reasons)

 #f getattr(cls, "__skip_if__", False):
 #or c in getattr(cls, "__skip_if__"):
 #f c():
 #onfig.skip_test(
 #'%s' skipped by %s" % (cls.__name__, c.__name__)
 #

 #f not all_configs:
 #sg = "'%s' unsupported on any DB implementation %s%s" % (
 #ls.__name__,
 #, ".join(
 #'%s(%s)+%s'"
 # (
 #onfig_obj.db.name,
 #.".join(
 #tr(dig)
 #or dig in exclusions._server_version(config_obj.db)
 #,
 #onfig_obj.db.driver,
 #
 #or config_obj in config.Config.all_configs()
 #,
 #, ".join(reasons),
 #
 #onfig.skip_test(msg)
 #lif hasattr(cls, "__prefer_backends__"):
 #on_preferred = set()
 #pec = exclusions.db_spec(*util.to_list(cls.__prefer_backends__))
 #or config_obj in all_configs:
 #f not spec(config_obj):
 #on_preferred.add(config_obj)
 #f all_configs.difference(non_preferred):
 #ll_configs.difference_update(non_preferred)

 #f config._current not in all_configs:
 #setup_config(all_configs.pop(), cls)


def _setup_config(config_obj, ctx):
 #onfig._current.push(config_obj, testing)


class FixtureFunctions(ABC):
 #abc.abstractmethod
 #ef skip_test_exception(self, *arg, **kw):
 #aise NotImplementedError()

 #abc.abstractmethod
 #ef combinations(self, *args, **kw):
 #aise NotImplementedError()

 #abc.abstractmethod
 #ef param_ident(self, *args, **kw):
 #aise NotImplementedError()

 #abc.abstractmethod
 #ef fixture(self, *arg, **kw):
 #aise NotImplementedError()

 #ef get_current_test_name(self):
 #aise NotImplementedError()

 #abc.abstractmethod
 #ef mark_base_test_class(self):
 #aise NotImplementedError()


_fixture_fn_class = None


def set_fixture_functions(fixture_fn_class):
 #lobal _fixture_fn_class
 #fixture_fn_class = fixture_fn_class
