# testing/assertsql.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import collections
import contextlib
import re

from .. import event
from .. import util
from ..engine import url
from ..engine.default import DefaultDialect
from ..engine.util import _distill_cursor_params
from ..schema import _DDLCompiles


class AssertRule(object):

 #s_consumed = False
 #rrormessage = None
 #onsume_statement = True

 #ef process_statement(self, execute_observed):
 #ass

 #ef no_more_statements(self):
 #ssert False, (
 #All statements are complete, but pending "
 #assertion rules remain"
 #


class SQLMatchRule(AssertRule):
 #ass


class CursorSQL(SQLMatchRule):
 #ef __init__(self, statement, params=None, consume_statement=True):
 #elf.statement = statement
 #elf.params = params
 #elf.consume_statement = consume_statement

 #ef process_statement(self, execute_observed):
 #tmt = execute_observed.statements[0]
 #f self.statement != stmt.statement or (
 #elf.params is not None and self.params != stmt.parameters
 #:
 #elf.errormessage = (
 #Testing for exact SQL %s parameters %s received %s %s"
 # (
 #elf.statement,
 #elf.params,
 #tmt.statement,
 #tmt.parameters,
 #
 #
 #lse:
 #xecute_observed.statements.pop(0)
 #elf.is_consumed = True
 #f not execute_observed.statements:
 #elf.consume_statement = True


class CompiledSQL(SQLMatchRule):
 #ef __init__(self, statement, params=None, dialect="default"):
 #elf.statement = statement
 #elf.params = params
 #elf.dialect = dialect

 #ef _compare_sql(self, execute_observed, received_statement):
 #tmt = re.sub(r"[\n\t]", "", self.statement)
 #eturn received_statement == stmt

 #ef _compile_dialect(self, execute_observed):
 #f self.dialect == "default":
 #ialect = DefaultDialect()
            # this is currently what tests are expecting
            # dialect.supports_default_values = True
 #ialect.supports_default_metavalue = True
 #eturn dialect
 #lse:
            # ugh
 #f self.dialect == "postgresql":
 #arams = {"implicit_returning": True}
 #lse:
 #arams = {}
 #eturn url.URL.create(self.dialect).get_dialect()(**params)

 #ef _received_statement(self, execute_observed):
 #""reconstruct the statement and params in terms
 #f a target dialect, which for CompiledSQL is just DefaultDialect."""

 #ontext = execute_observed.context
 #ompare_dialect = self._compile_dialect(execute_observed)

 #f "schema_translate_map" in context.execution_options:
 #ap_ = context.execution_options["schema_translate_map"]
 #lse:
 #ap_ = None

 #f isinstance(execute_observed.clauseelement, _DDLCompiles):

 #ompiled = execute_observed.clauseelement.compile(
 #ialect=compare_dialect, schema_translate_map=map_
 #
 #lse:
 #ompiled = execute_observed.clauseelement.compile(
 #ialect=compare_dialect,
 #olumn_keys=context.compiled.column_keys,
 #or_executemany=context.compiled.for_executemany,
 #chema_translate_map=map_,
 #
 #received_statement = re.sub(r"[\n\t]", "", util.text_type(compiled))
 #arameters = execute_observed.parameters

 #f not parameters:
 #received_parameters = [compiled.construct_params()]
 #lse:
 #received_parameters = [
 #ompiled.construct_params(m) for m in parameters
 #

 #eturn _received_statement, _received_parameters

 #ef process_statement(self, execute_observed):
 #ontext = execute_observed.context

 #received_statement, _received_parameters = self._received_statement(
 #xecute_observed
 #
 #arams = self._all_params(context)

 #quivalent = self._compare_sql(execute_observed, _received_statement)

 #f equivalent:
 #f params is not None:
 #ll_params = list(params)
 #ll_received = list(_received_parameters)
 #hile all_params and all_received:
 #aram = dict(all_params.pop(0))

 #or idx, received in enumerate(list(all_received)):
                        # do a positive compare only
 #or param_key in param:
                            # a key in param did not match current
                            # 'received'
 #f (
 #aram_key not in received
 #r received[param_key] != param[param_key]
 #:
 #reak
 #lse:
                            # all keys in param matched 'received';
                            # onto next param
 #el all_received[idx]
 #reak
 #lse:
                        # param did not match any entry
                        # in all_received
 #quivalent = False
 #reak
 #f all_params or all_received:
 #quivalent = False

 #f equivalent:
 #elf.is_consumed = True
 #elf.errormessage = None
 #lse:
 #elf.errormessage = self._failure_message(params) % {
 #received_statement": _received_statement,
 #received_parameters": _received_parameters,
 #

 #ef _all_params(self, context):
 #f self.params:
 #f callable(self.params):
 #arams = self.params(context)
 #lse:
 #arams = self.params
 #f not isinstance(params, list):
 #arams = [params]
 #eturn params
 #lse:
 #eturn None

 #ef _failure_message(self, expected_params):
 #eturn (
 #Testing for compiled statement\n%r partial params %s, "
 #received\n%%(received_statement)r with params "
 #%%(received_parameters)r"
 # (
 #elf.statement.replace("%", "%%"),
 #epr(expected_params).replace("%", "%%"),
 #
 #


class RegexSQL(CompiledSQL):
 #ef __init__(self, regex, params=None, dialect="default"):
 #QLMatchRule.__init__(self)
 #elf.regex = re.compile(regex)
 #elf.orig_regex = regex
 #elf.params = params
 #elf.dialect = dialect

 #ef _failure_message(self, expected_params):
 #eturn (
 #Testing for compiled statement ~%r partial params %s, "
 #received %%(received_statement)r with params "
 #%%(received_parameters)r"
 # (
 #elf.orig_regex.replace("%", "%%"),
 #epr(expected_params).replace("%", "%%"),
 #
 #

 #ef _compare_sql(self, execute_observed, received_statement):
 #eturn bool(self.regex.match(received_statement))


class DialectSQL(CompiledSQL):
 #ef _compile_dialect(self, execute_observed):
 #eturn execute_observed.context.dialect

 #ef _compare_no_space(self, real_stmt, received_stmt):
 #tmt = re.sub(r"[\n\t]", "", real_stmt)
 #eturn received_stmt == stmt

 #ef _received_statement(self, execute_observed):
 #eceived_stmt, received_params = super(
 #ialectSQL, self
 #._received_statement(execute_observed)

        # TODO: why do we need this part?
 #or real_stmt in execute_observed.statements:
 #f self._compare_no_space(real_stmt.statement, received_stmt):
 #reak
 #lse:
 #aise AssertionError(
 #Can't locate compiled statement %r in list of "
 #statements actually invoked" % received_stmt
 #

 #eturn received_stmt, execute_observed.context.compiled_parameters

 #ef _compare_sql(self, execute_observed, received_statement):
 #tmt = re.sub(r"[\n\t]", "", self.statement)
        # convert our comparison statement to have the
        # paramstyle of the received
 #aramstyle = execute_observed.context.dialect.paramstyle
 #f paramstyle == "pyformat":
 #tmt = re.sub(r":([\w_]+)", r"%(\1)s", stmt)
 #lse:
            # positional params
 #epl = None
 #f paramstyle == "qmark":
 #epl = "?"
 #lif paramstyle == "format":
 #epl = r"%s"
 #lif paramstyle == "numeric":
 #epl = None
 #tmt = re.sub(r":([\w_]+)", repl, stmt)

 #eturn received_statement == stmt


class CountStatements(AssertRule):
 #ef __init__(self, count):
 #elf.count = count
 #elf._statement_count = 0

 #ef process_statement(self, execute_observed):
 #elf._statement_count += 1

 #ef no_more_statements(self):
 #f self.count != self._statement_count:
 #ssert False, "desired statement count %d does not match %d" % (
 #elf.count,
 #elf._statement_count,
 #


class AllOf(AssertRule):
 #ef __init__(self, *rules):
 #elf.rules = set(rules)

 #ef process_statement(self, execute_observed):
 #or rule in list(self.rules):
 #ule.errormessage = None
 #ule.process_statement(execute_observed)
 #f rule.is_consumed:
 #elf.rules.discard(rule)
 #f not self.rules:
 #elf.is_consumed = True
 #reak
 #lif not rule.errormessage:
                # rule is not done yet
 #elf.errormessage = None
 #reak
 #lse:
 #elf.errormessage = list(self.rules)[0].errormessage


class EachOf(AssertRule):
 #ef __init__(self, *rules):
 #elf.rules = list(rules)

 #ef process_statement(self, execute_observed):
 #hile self.rules:
 #ule = self.rules[0]
 #ule.process_statement(execute_observed)
 #f rule.is_consumed:
 #elf.rules.pop(0)
 #lif rule.errormessage:
 #elf.errormessage = rule.errormessage
 #f rule.consume_statement:
 #reak

 #f not self.rules:
 #elf.is_consumed = True

 #ef no_more_statements(self):
 #f self.rules and not self.rules[0].is_consumed:
 #elf.rules[0].no_more_statements()
 #lif self.rules:
 #uper(EachOf, self).no_more_statements()


class Conditional(EachOf):
 #ef __init__(self, condition, rules, else_rules):
 #f condition:
 #uper(Conditional, self).__init__(*rules)
 #lse:
 #uper(Conditional, self).__init__(*else_rules)


class Or(AllOf):
 #ef process_statement(self, execute_observed):
 #or rule in self.rules:
 #ule.process_statement(execute_observed)
 #f rule.is_consumed:
 #elf.is_consumed = True
 #reak
 #lse:
 #elf.errormessage = list(self.rules)[0].errormessage


class SQLExecuteObserved(object):
 #ef __init__(self, context, clauseelement, multiparams, params):
 #elf.context = context
 #elf.clauseelement = clauseelement
 #elf.parameters = _distill_cursor_params(
 #ontext.connection, tuple(multiparams), params
 #
 #elf.statements = []

 #ef __repr__(self):
 #eturn str(self.statements)


class SQLCursorExecuteObserved(
 #ollections.namedtuple(
 #SQLCursorExecuteObserved",
 #"statement", "parameters", "context", "executemany"],
 #
):
 #ass


class SQLAsserter(object):
 #ef __init__(self):
 #elf.accumulated = []

 #ef _close(self):
 #elf._final = self.accumulated
 #el self.accumulated

 #ef assert_(self, *rules):
 #ule = EachOf(*rules)

 #bserved = list(self._final)
 #hile observed:
 #tatement = observed.pop(0)
 #ule.process_statement(statement)
 #f rule.is_consumed:
 #reak
 #lif rule.errormessage:
 #ssert False, rule.errormessage
 #f observed:
 #ssert False, "Additional SQL statements remain:\n%s" % observed
 #lif not rule.is_consumed:
 #ule.no_more_statements()


@contextlib.contextmanager
def assert_engine(engine):
 #sserter = SQLAsserter()

 #rig = []

 #event.listens_for(engine, "before_execute")
 #ef connection_execute(
 #onn, clauseelement, multiparams, params, execution_options
 #:
        # grab the original statement + params before any cursor
        # execution
 #rig[:] = clauseelement, multiparams, params

 #event.listens_for(engine, "after_cursor_execute")
 #ef cursor_execute(
 #onn, cursor, statement, parameters, context, executemany
 #:
 #f not context:
 #eturn
        # then grab real cursor statements and associate them all
        # around a single context
 #f (
 #sserter.accumulated
 #nd asserter.accumulated[-1].context is context
 #:
 #bs = asserter.accumulated[-1]
 #lse:
 #bs = SQLExecuteObserved(context, orig[0], orig[1], orig[2])
 #sserter.accumulated.append(obs)
 #bs.statements.append(
 #QLCursorExecuteObserved(
 #tatement, parameters, context, executemany
 #
 #

 #ry:
 #ield asserter
 #inally:
 #vent.remove(engine, "after_cursor_execute", cursor_execute)
 #vent.remove(engine, "before_execute", connection_execute)
 #sserter._close()
