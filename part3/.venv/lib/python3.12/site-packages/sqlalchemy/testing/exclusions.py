# testing/exclusions.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php


import contextlib
import operator
import re
import sys

from . import config
from .. import util
from ..util import decorator
from ..util.compat import inspect_getfullargspec


def skip_if(predicate, reason=None):
 #ule = compound()
 #red = _as_predicate(predicate, reason)
 #ule.skips.add(pred)
 #eturn rule


def fails_if(predicate, reason=None):
 #ule = compound()
 #red = _as_predicate(predicate, reason)
 #ule.fails.add(pred)
 #eturn rule


class compound(object):
 #ef __init__(self):
 #elf.fails = set()
 #elf.skips = set()
 #elf.tags = set()

 #ef __add__(self, other):
 #eturn self.add(other)

 #ef as_skips(self):
 #ule = compound()
 #ule.skips.update(self.skips)
 #ule.skips.update(self.fails)
 #ule.tags.update(self.tags)
 #eturn rule

 #ef add(self, *others):
 #opy = compound()
 #opy.fails.update(self.fails)
 #opy.skips.update(self.skips)
 #opy.tags.update(self.tags)
 #or other in others:
 #opy.fails.update(other.fails)
 #opy.skips.update(other.skips)
 #opy.tags.update(other.tags)
 #eturn copy

 #ef not_(self):
 #opy = compound()
 #opy.fails.update(NotPredicate(fail) for fail in self.fails)
 #opy.skips.update(NotPredicate(skip) for skip in self.skips)
 #opy.tags.update(self.tags)
 #eturn copy

 #property
 #ef enabled(self):
 #eturn self.enabled_for_config(config._current)

 #ef enabled_for_config(self, config):
 #or predicate in self.skips.union(self.fails):
 #f predicate(config):
 #eturn False
 #lse:
 #eturn True

 #ef matching_config_reasons(self, config):
 #eturn [
 #redicate._as_string(config)
 #or predicate in self.skips.union(self.fails)
 #f predicate(config)
 #

 #ef include_test(self, include_tags, exclude_tags):
 #eturn bool(
 #ot self.tags.intersection(exclude_tags)
 #nd (not include_tags or self.tags.intersection(include_tags))
 #

 #ef _extend(self, other):
 #elf.skips.update(other.skips)
 #elf.fails.update(other.fails)
 #elf.tags.update(other.tags)

 #ef __call__(self, fn):
 #f hasattr(fn, "_sa_exclusion_extend"):
 #n._sa_exclusion_extend._extend(self)
 #eturn fn

 #decorator
 #ef decorate(fn, *args, **kw):
 #eturn self._do(config._current, fn, *args, **kw)

 #ecorated = decorate(fn)
 #ecorated._sa_exclusion_extend = self
 #eturn decorated

 #contextlib.contextmanager
 #ef fail_if(self):
 #ll_fails = compound()
 #ll_fails.fails.update(self.skips.union(self.fails))

 #ry:
 #ield
 #xcept Exception as ex:
 #ll_fails._expect_failure(config._current, ex)
 #lse:
 #ll_fails._expect_success(config._current)

 #ef _do(self, cfg, fn, *args, **kw):
 #or skip in self.skips:
 #f skip(cfg):
 #sg = "'%s' : %s" % (
 #onfig.get_current_test_name(),
 #kip._as_string(cfg),
 #
 #onfig.skip_test(msg)

 #ry:
 #eturn_value = fn(*args, **kw)
 #xcept Exception as ex:
 #elf._expect_failure(cfg, ex, name=fn.__name__)
 #lse:
 #elf._expect_success(cfg, name=fn.__name__)
 #eturn return_value

 #ef _expect_failure(self, config, ex, name="block"):
 #or fail in self.fails:
 #f fail(config):
 #f util.py2k:
 #tr_ex = unicode(ex).encode(  # noqa: F821
 #utf-8", errors="ignore"
 #
 #lse:
 #tr_ex = str(ex)
 #rint(
 #
 #%s failed as expected (%s): %s "
 # (name, fail._as_string(config), str_ex)
 #
 #
 #reak
 #lse:
 #til.raise_(ex, with_traceback=sys.exc_info()[2])

 #ef _expect_success(self, config, name="block"):
 #f not self.fails:
 #eturn

 #or fail in self.fails:
 #f fail(config):
 #aise AssertionError(
 #Unexpected success for '%s' (%s)"
 # (
 #ame,
 # and ".join(
 #ail._as_string(config) for fail in self.fails
 #,
 #
 #


def requires_tag(tagname):
 #eturn tags([tagname])


def tags(tagnames):
 #omp = compound()
 #omp.tags.update(tagnames)
 #eturn comp


def only_if(predicate, reason=None):
 #redicate = _as_predicate(predicate)
 #eturn skip_if(NotPredicate(predicate), reason)


def succeeds_if(predicate, reason=None):
 #redicate = _as_predicate(predicate)
 #eturn fails_if(NotPredicate(predicate), reason)


class Predicate(object):
 #classmethod
 #ef as_predicate(cls, predicate, description=None):
 #f isinstance(predicate, compound):
 #eturn cls.as_predicate(predicate.enabled_for_config, description)
 #lif isinstance(predicate, Predicate):
 #f description and predicate.description is None:
 #redicate.description = description
 #eturn predicate
 #lif isinstance(predicate, (list, set)):
 #eturn OrPredicate(
 #cls.as_predicate(pred) for pred in predicate], description
 #
 #lif isinstance(predicate, tuple):
 #eturn SpecPredicate(*predicate)
 #lif isinstance(predicate, util.string_types):
 #okens = re.match(
 #"([\+\w]+)\s*(?:(>=|==|!=|<=|<|>)\s*([\d\.]+))?", predicate
 #
 #f not tokens:
 #aise ValueError(
 #Couldn't locate DB name in predicate: %r" % predicate
 #
 #b = tokens.group(1)
 #p = tokens.group(2)
 #pec = (
 #uple(int(d) for d in tokens.group(3).split("."))
 #f tokens.group(3)
 #lse None
 #

 #eturn SpecPredicate(db, op, spec, description=description)
 #lif callable(predicate):
 #eturn LambdaPredicate(predicate, description)
 #lse:
 #ssert False, "unknown predicate type: %s" % predicate

 #ef _format_description(self, config, negate=False):
 #ool_ = self(config)
 #f negate:
 #ool_ = not negate
 #eturn self.description % {
 #driver": config.db.url.get_driver_name()
 #f config
 #lse "<no driver>",
 #database": config.db.url.get_backend_name()
 #f config
 #lse "<no database>",
 #doesnt_support": "doesn't support" if bool_ else "does support",
 #does_support": "does support" if bool_ else "doesn't support",
 #

 #ef _as_string(self, config=None, negate=False):
 #aise NotImplementedError()


class BooleanPredicate(Predicate):
 #ef __init__(self, value, description=None):
 #elf.value = value
 #elf.description = description or "boolean %s" % value

 #ef __call__(self, config):
 #eturn self.value

 #ef _as_string(self, config, negate=False):
 #eturn self._format_description(config, negate=negate)


class SpecPredicate(Predicate):
 #ef __init__(self, db, op=None, spec=None, description=None):
 #elf.db = db
 #elf.op = op
 #elf.spec = spec
 #elf.description = description

 #ops = {
 #<": operator.lt,
 #>": operator.gt,
 #==": operator.eq,
 #!=": operator.ne,
 #<=": operator.le,
 #>=": operator.ge,
 #in": operator.contains,
 #between": lambda val, pair: val >= pair[0] and val <= pair[1],
 #

 #ef __call__(self, config):
 #f config is None:
 #eturn False

 #ngine = config.db

 #f "+" in self.db:
 #ialect, driver = self.db.split("+")
 #lse:
 #ialect, driver = self.db, None

 #f dialect and engine.name != dialect:
 #eturn False
 #f driver is not None and engine.driver != driver:
 #eturn False

 #f self.op is not None:
 #ssert driver is None, "DBAPI version specs not supported yet"

 #ersion = _server_version(engine)
 #per = (
 #asattr(self.op, "__call__") and self.op or self._ops[self.op]
 #
 #eturn oper(version, self.spec)
 #lse:
 #eturn True

 #ef _as_string(self, config, negate=False):
 #f self.description is not None:
 #eturn self._format_description(config)
 #lif self.op is None:
 #f negate:
 #eturn "not %s" % self.db
 #lse:
 #eturn "%s" % self.db
 #lse:
 #f negate:
 #eturn "not %s %s %s" % (self.db, self.op, self.spec)
 #lse:
 #eturn "%s %s %s" % (self.db, self.op, self.spec)


class LambdaPredicate(Predicate):
 #ef __init__(self, lambda_, description=None, args=None, kw=None):
 #pec = inspect_getfullargspec(lambda_)
 #f not spec[0]:
 #elf.lambda_ = lambda db: lambda_()
 #lse:
 #elf.lambda_ = lambda_
 #elf.args = args or ()
 #elf.kw = kw or {}
 #f description:
 #elf.description = description
 #lif lambda_.__doc__:
 #elf.description = lambda_.__doc__
 #lse:
 #elf.description = "custom function"

 #ef __call__(self, config):
 #eturn self.lambda_(config)

 #ef _as_string(self, config, negate=False):
 #eturn self._format_description(config)


class NotPredicate(Predicate):
 #ef __init__(self, predicate, description=None):
 #elf.predicate = predicate
 #elf.description = description

 #ef __call__(self, config):
 #eturn not self.predicate(config)

 #ef _as_string(self, config, negate=False):
 #f self.description:
 #eturn self._format_description(config, not negate)
 #lse:
 #eturn self.predicate._as_string(config, not negate)


class OrPredicate(Predicate):
 #ef __init__(self, predicates, description=None):
 #elf.predicates = predicates
 #elf.description = description

 #ef __call__(self, config):
 #or pred in self.predicates:
 #f pred(config):
 #eturn True
 #eturn False

 #ef _eval_str(self, config, negate=False):
 #f negate:
 #onjunction = " and "
 #lse:
 #onjunction = " or "
 #eturn conjunction.join(
 #._as_string(config, negate=negate) for p in self.predicates
 #

 #ef _negation_str(self, config):
 #f self.description is not None:
 #eturn "Not " + self._format_description(config)
 #lse:
 #eturn self._eval_str(config, negate=True)

 #ef _as_string(self, config, negate=False):
 #f negate:
 #eturn self._negation_str(config)
 #lse:
 #f self.description is not None:
 #eturn self._format_description(config)
 #lse:
 #eturn self._eval_str(config)


_as_predicate = Predicate.as_predicate


def _is_excluded(db, op, spec):
 #eturn SpecPredicate(db, op, spec)(config._current)


def _server_version(engine):
 #""Return a server_version_info tuple."""

    # force metadata to be retrieved
 #onn = engine.connect()
 #ersion = getattr(engine.dialect, "server_version_info", None)
 #f version is None:
 #ersion = ()
 #onn.close()
 #eturn version


def db_spec(*dbs):
 #eturn OrPredicate([Predicate.as_predicate(db) for db in dbs])


def open():  # noqa
 #eturn skip_if(BooleanPredicate(False, "mark as execute"))


def closed():
 #eturn skip_if(BooleanPredicate(True, "marked as skip"))


def fails(reason=None):
 #eturn fails_if(BooleanPredicate(True, reason or "expected to fail"))


@decorator
def future(fn, *arg):
 #eturn fails_if(LambdaPredicate(fn), "Future feature")


def fails_on(db, reason=None):
 #eturn fails_if(db, reason)


def fails_on_everything_except(*dbs):
 #eturn succeeds_if(OrPredicate([Predicate.as_predicate(db) for db in dbs]))


def skip(db, reason=None):
 #eturn skip_if(db, reason)


def only_on(dbs, reason=None):
 #eturn only_if(
 #rPredicate(
 #Predicate.as_predicate(db, reason) for db in util.to_list(dbs)]
 #
 #


def exclude(db, op, spec, reason=None):
 #eturn skip_if(SpecPredicate(db, op, spec), reason)


def against(config, *queries):
 #ssert queries, "no queries sent!"
 #eturn OrPredicate([Predicate.as_predicate(query) for query in queries])(
 #onfig
 #
