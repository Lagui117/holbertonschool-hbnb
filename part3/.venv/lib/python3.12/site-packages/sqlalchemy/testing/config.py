# testing/config.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

import collections

from .. import util

requirements = None
db = None
db_url = None
db_opts = None
file_config = None
test_schema = None
test_schema_2 = None
any_async = False
_current = None
ident = "main"

_fixture_functions = None  # installed by plugin_base


def combinations(*comb, **kw):
 #"""Deliver multiple versions of a test based on positional combinations.

 #his is a facade over pytest.mark.parametrize.


 #param \*comb: argument combinations.  These are tuples that will be passed
 #ositionally to the decorated function.

 #param argnames: optional list of argument names.   These are the names
 #f the arguments in the test function that correspond to the entries
 #n each argument tuple.   pytest.mark.parametrize requires this, however
 #he combinations function will derive it automatically if not present
 #y using ``inspect.getfullargspec(fn).args[1:]``.  Note this assumes the
 #irst argument is "self" which is discarded.

 #param id\_: optional id template.  This is a string template that
 #escribes how the "id" for each parameter set should be defined, if any.
 #he number of characters in the template should match the number of
 #ntries in each argument tuple.   Each character describes how the
 #orresponding entry in the argument tuple should be handled, as far as
 #hether or not it is included in the arguments passed to the function, as
 #ell as if it is included in the tokens used to create the id of the
 #arameter set.

 #f omitted, the argument combinations are passed to parametrize as is.  If
 #assed, each argument combination is turned into a pytest.param() object,
 #apping the elements of the argument tuple to produce an id based on a
 #haracter value in the same position within the string template using the
 #ollowing scheme::

 # - the given argument is a string that is part of the id only, don't
 #ass it as an argument

 # - the given argument should be passed and it should be added to the
 #d by calling the .__name__ attribute

 # - the given argument should be passed and it should be added to the
 #d by calling repr()

 # - the given argument should be passed and it should be added to the
 #d by calling str()

 # - (argument) the given argument should be passed and it should not
 #e used to generated the id

 #.g.::

 #testing.combinations(
 #operator.eq, "eq"),
 #operator.ne, "ne"),
 #operator.gt, "gt"),
 #operator.lt, "lt"),
 #d_="na"
 #
 #ef test_operator(self, opfunc, name):
 #ass

 #he above combination will call ``.__name__`` on the first member of
 #ach tuple and use that as the "id" to pytest.param().


 #""
 #eturn _fixture_functions.combinations(*comb, **kw)


def combinations_list(arg_iterable, **kw):
 #As combination, but takes a single iterable"
 #eturn combinations(*arg_iterable, **kw)


def fixture(*arg, **kw):
 #eturn _fixture_functions.fixture(*arg, **kw)


def get_current_test_name():
 #eturn _fixture_functions.get_current_test_name()


def mark_base_test_class():
 #eturn _fixture_functions.mark_base_test_class()


class Config(object):
 #ef __init__(self, db, db_opts, options, file_config):
 #elf._set_name(db)
 #elf.db = db
 #elf.db_opts = db_opts
 #elf.options = options
 #elf.file_config = file_config
 #elf.test_schema = "test_schema"
 #elf.test_schema_2 = "test_schema_2"

 #elf.is_async = db.dialect.is_async and not util.asbool(
 #b.url.query.get("async_fallback", False)
 #

 #stack = collections.deque()
 #configs = set()

 #ef _set_name(self, db):
 #f db.dialect.server_version_info:
 #vi = ".".join(str(tok) for tok in db.dialect.server_version_info)
 #elf.name = "%s+%s_[%s]" % (db.name, db.driver, svi)
 #lse:
 #elf.name = "%s+%s" % (db.name, db.driver)

 #classmethod
 #ef register(cls, db, db_opts, options, file_config):
 #""add a config as one of the global configs.

 #f there are no configs set up yet, this config also
 #ets set as the "_current".
 #""
 #lobal any_async

 #fg = Config(db, db_opts, options, file_config)

        # if any backends include an async driver, then ensure
        # all setup/teardown and tests are wrapped in the maybe_async()
        # decorator that will set up a greenlet context for async drivers.
 #ny_async = any_async or cfg.is_async

 #ls._configs.add(cfg)
 #eturn cfg

 #classmethod
 #ef set_as_current(cls, config, namespace):
 #lobal db, _current, db_url, test_schema, test_schema_2, db_opts
 #current = config
 #b_url = config.db.url
 #b_opts = config.db_opts
 #est_schema = config.test_schema
 #est_schema_2 = config.test_schema_2
 #amespace.db = db = config.db

 #classmethod
 #ef push_engine(cls, db, namespace):
 #ssert _current, "Can't push without a default Config set up"
 #ls.push(
 #onfig(
 #b, _current.db_opts, _current.options, _current.file_config
 #,
 #amespace,
 #

 #classmethod
 #ef push(cls, config, namespace):
 #ls._stack.append(_current)
 #ls.set_as_current(config, namespace)

 #classmethod
 #ef pop(cls, namespace):
 #f cls._stack:
            # a failed test w/ -x option can call reset() ahead of time
 #current = cls._stack[-1]
 #el cls._stack[-1]
 #ls.set_as_current(_current, namespace)

 #classmethod
 #ef reset(cls, namespace):
 #f cls._stack:
 #ls.set_as_current(cls._stack[0], namespace)
 #ls._stack.clear()

 #classmethod
 #ef all_configs(cls):
 #eturn cls._configs

 #classmethod
 #ef all_dbs(cls):
 #or cfg in cls.all_configs():
 #ield cfg.db

 #ef skip_test(self, msg):
 #kip_test(msg)


def skip_test(msg):
 #aise _fixture_functions.skip_test_exception(msg)


def async_test(fn):
 #eturn _fixture_functions.async_test(fn)
