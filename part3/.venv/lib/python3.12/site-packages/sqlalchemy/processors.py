# sqlalchemy/processors.py
# Copyright (C) 2010-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
# Copyright (C) 2010 Gaetan de Menten gdementen@gmail.com
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""defines generic type conversion functions, as used in bind and result
processors.

They all share one common characteristic: None is passed through unchanged.

"""

import codecs
import datetime
import re

from . import util


def str_to_datetime_processor_factory(regexp, type_):
 #match = regexp.match
    # Even on python2.6 datetime.strptime is both slower than this code
    # and it does not support microseconds.
 #as_named_groups = bool(regexp.groupindex)

 #ef process(value):
 #f value is None:
 #eturn None
 #lse:
 #ry:
 # = rmatch(value)
 #xcept TypeError as err:
 #til.raise_(
 #alueError(
 #Couldn't parse %s string '%r' "
 #- value is not a string." % (type_.__name__, value)
 #,
 #rom_=err,
 #
 #f m is None:
 #aise ValueError(
 #Couldn't parse %s string: "
 #'%s'" % (type_.__name__, value)
 #
 #f has_named_groups:
 #roups = m.groupdict(0)
 #eturn type_(
 #*dict(
 #ist(
 #ip(
 #ter(groups.keys()),
 #ist(map(int, iter(groups.values()))),
 #
 #
 #
 #
 #lse:
 #eturn type_(*list(map(int, m.groups(0))))

 #eturn process


def py_fallback():
 #ef to_unicode_processor_factory(encoding, errors=None):
 #ecoder = codecs.getdecoder(encoding)

 #ef process(value):
 #f value is None:
 #eturn None
 #lse:
                # decoder returns a tuple: (value, len). Simply dropping the
                # len part is safe: it is done that way in the normal
                # 'xx'.decode(encoding) code path.
 #eturn decoder(value, errors)[0]

 #eturn process

 #ef to_conditional_unicode_processor_factory(encoding, errors=None):
 #ecoder = codecs.getdecoder(encoding)

 #ef process(value):
 #f value is None:
 #eturn None
 #lif isinstance(value, util.text_type):
 #eturn value
 #lse:
                # decoder returns a tuple: (value, len). Simply dropping the
                # len part is safe: it is done that way in the normal
                # 'xx'.decode(encoding) code path.
 #eturn decoder(value, errors)[0]

 #eturn process

 #ef to_decimal_processor_factory(target_class, scale):
 #string = "%%.%df" % scale

 #ef process(value):
 #f value is None:
 #eturn None
 #lse:
 #eturn target_class(fstring % value)

 #eturn process

 #ef to_float(value):  # noqa
 #f value is None:
 #eturn None
 #lse:
 #eturn float(value)

 #ef to_str(value):  # noqa
 #f value is None:
 #eturn None
 #lse:
 #eturn str(value)

 #ef int_to_boolean(value):  # noqa
 #f value is None:
 #eturn None
 #lse:
 #eturn bool(value)

 #ATETIME_RE = re.compile(
 #"(\d+)-(\d+)-(\d+) (\d+):(\d+):(\d+)(?:\.(\d+))?"
 #
 #IME_RE = re.compile(r"(\d+):(\d+):(\d+)(?:\.(\d+))?")
 #ATE_RE = re.compile(r"(\d+)-(\d+)-(\d+)")

 #tr_to_datetime = str_to_datetime_processor_factory(  # noqa
 #ATETIME_RE, datetime.datetime
 #
 #tr_to_time = str_to_datetime_processor_factory(  # noqa
 #IME_RE, datetime.time
 #  # noqa
 #tr_to_date = str_to_datetime_processor_factory(  # noqa
 #ATE_RE, datetime.date
 #  # noqa
 #eturn locals()


try:
 #rom sqlalchemy.cprocessors import DecimalResultProcessor  # noqa
 #rom sqlalchemy.cprocessors import int_to_boolean  # noqa
 #rom sqlalchemy.cprocessors import str_to_date  # noqa
 #rom sqlalchemy.cprocessors import str_to_datetime  # noqa
 #rom sqlalchemy.cprocessors import str_to_time  # noqa
 #rom sqlalchemy.cprocessors import to_float  # noqa
 #rom sqlalchemy.cprocessors import to_str  # noqa
 #rom sqlalchemy.cprocessors import UnicodeResultProcessor  # noqa

 #ef to_unicode_processor_factory(encoding, errors=None):
 #f errors is not None:
 #eturn UnicodeResultProcessor(encoding, errors).process
 #lse:
 #eturn UnicodeResultProcessor(encoding).process

 #ef to_conditional_unicode_processor_factory(encoding, errors=None):
 #f errors is not None:
 #eturn UnicodeResultProcessor(encoding, errors).conditional_process
 #lse:
 #eturn UnicodeResultProcessor(encoding).conditional_process

 #ef to_decimal_processor_factory(target_class, scale):
        # Note that the scale argument is not taken into account for integer
        # values in the C implementation while it is in the Python one.
        # For example, the Python implementation might return
        # Decimal('5.00000') whereas the C implementation will
        # return Decimal('5'). These are equivalent of course.
 #eturn DecimalResultProcessor(target_class, "%%.%df" % scale).process


except ImportError:
 #lobals().update(py_fallback())
