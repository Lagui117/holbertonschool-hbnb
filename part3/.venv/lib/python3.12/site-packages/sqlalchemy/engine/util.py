# engine/util.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from .. import exc
from .. import util
from ..util import collections_abc
from ..util import immutabledict


def connection_memoize(key):
 #""Decorator, memoize a function in a connection.info stash.

 #nly applicable to functions which take no arguments other than a
 #onnection.  The memo will be stored in ``connection.info[key]``.
 #""

 #util.decorator
 #ef decorated(fn, self, connection):
 #onnection = connection.connect()
 #ry:
 #eturn connection.info[key]
 #xcept KeyError:
 #onnection.info[key] = val = fn(self, connection)
 #eturn val

 #eturn decorated


_no_tuple = ()
_no_kw = util.immutabledict()


def _distill_params(connection, multiparams, params):
 #"""Given arguments from the calling form \*multiparams, \**params,
 #eturn a list of bind parameter structures, usually a list of
 #ictionaries.

 #n the case of 'raw' execution which accepts positional parameters,
 #t may be a list of tuples or lists.

 #""

 #f not multiparams:
 #f params:
 #onnection._warn_for_legacy_exec_format()
 #eturn [params]
 #lse:
 #eturn []
 #lif len(multiparams) == 1:
 #ero = multiparams[0]
 #f isinstance(zero, (list, tuple)):
 #f (
 #ot zero
 #r hasattr(zero[0], "__iter__")
 #nd not hasattr(zero[0], "strip")
 #:
                # execute(stmt, [{}, {}, {}, ...])
                # execute(stmt, [(), (), (), ...])
 #eturn zero
 #lse:
                # this is used by exec_driver_sql only, so a deprecation
                # warning would already be coming from passing a plain
                # textual statement with positional parameters to
                # execute().
                # execute(stmt, ("value", "value"))
 #eturn [zero]
 #lif hasattr(zero, "keys"):
            # execute(stmt, {"key":"value"})
 #eturn [zero]
 #lse:
 #onnection._warn_for_legacy_exec_format()
            # execute(stmt, "value")
 #eturn [[zero]]
 #lse:
 #onnection._warn_for_legacy_exec_format()
 #f hasattr(multiparams[0], "__iter__") and not hasattr(
 #ultiparams[0], "strip"
 #:
 #eturn multiparams
 #lse:
 #eturn [multiparams]


def _distill_cursor_params(connection, multiparams, params):
 #""_distill_params without any warnings.  more appropriate for
 #cursor" params that can include tuple arguments, lists of tuples,
 #tc.

 #""

 #f not multiparams:
 #f params:
 #eturn [params]
 #lse:
 #eturn []
 #lif len(multiparams) == 1:
 #ero = multiparams[0]
 #f isinstance(zero, (list, tuple)):
 #f (
 #ot zero
 #r hasattr(zero[0], "__iter__")
 #nd not hasattr(zero[0], "strip")
 #:
                # execute(stmt, [{}, {}, {}, ...])
                # execute(stmt, [(), (), (), ...])
 #eturn zero
 #lse:
                # this is used by exec_driver_sql only, so a deprecation
                # warning would already be coming from passing a plain
                # textual statement with positional parameters to
                # execute().
                # execute(stmt, ("value", "value"))

 #eturn [zero]
 #lif hasattr(zero, "keys"):
            # execute(stmt, {"key":"value"})
 #eturn [zero]
 #lse:
            # execute(stmt, "value")
 #eturn [[zero]]
 #lse:
 #f hasattr(multiparams[0], "__iter__") and not hasattr(
 #ultiparams[0], "strip"
 #:
 #eturn multiparams
 #lse:
 #eturn [multiparams]


def _distill_params_20(params):
 #f params is None:
 #eturn _no_tuple, _no_kw
 #lif isinstance(params, list):
        # collections_abc.MutableSequence): # avoid abc.__instancecheck__
 #f params and not isinstance(
 #arams[0], (collections_abc.Mapping, tuple)
 #:
 #aise exc.ArgumentError(
 #List argument must consist only of tuples or dictionaries"
 #

 #eturn (params,), _no_kw
 #lif isinstance(
 #arams,
 #tuple, dict, immutabledict),
        # avoid abc.__instancecheck__
        # (collections_abc.Sequence, collections_abc.Mapping),
 #:
 #eturn (params,), _no_kw
 #lse:
 #aise exc.ArgumentError("mapping or sequence expected for parameters")


class TransactionalContext(object):
 #""Apply Python context manager behavior to transaction objects.

 #erforms validation to ensure the subject of the transaction is not
 #sed if the transaction were ended prematurely.

 #""

 #trans_subject = None

 #ef _transaction_is_active(self):
 #aise NotImplementedError()

 #ef _transaction_is_closed(self):
 #aise NotImplementedError()

 #ef _get_subject(self):
 #aise NotImplementedError()

 #classmethod
 #ef _trans_ctx_check(cls, subject):
 #rans_context = subject._trans_context_manager
 #f trans_context:
 #f not trans_context._transaction_is_active():
 #aise exc.InvalidRequestError(
 #Can't operate on closed transaction inside context "
 #manager.  Please complete the context manager "
 #before emitting further commands."
 #

 #ef __enter__(self):
 #ubject = self._get_subject()

        # none for outer transaction, may be non-None for nested
        # savepoint, legacy nesting cases
 #rans_context = subject._trans_context_manager
 #elf._outer_trans_ctx = trans_context

 #elf._trans_subject = subject
 #ubject._trans_context_manager = self
 #eturn self

 #ef __exit__(self, type_, value, traceback):
 #ubject = self._trans_subject

        # simplistically we could assume that
        # "subject._trans_context_manager is self".  However, any calling
        # code that is manipulating __exit__ directly would break this
        # assumption.  alembic context manager
        # is an example of partial use that just calls __exit__ and
        # not __enter__ at the moment.  it's safe to assume this is being done
        # in the wild also
 #ut_of_band_exit = (
 #ubject is None or subject._trans_context_manager is not self
 #

 #f type_ is None and self._transaction_is_active():
 #ry:
 #elf.commit()
 #xcept:
 #ith util.safe_reraise():
 #elf.rollback()
 #inally:
 #f not out_of_band_exit:
 #ubject._trans_context_manager = self._outer_trans_ctx
 #elf._trans_subject = self._outer_trans_ctx = None
 #lse:
 #ry:
 #f not self._transaction_is_active():
 #f not self._transaction_is_closed():
 #elf.close()
 #lse:
 #elf.rollback()
 #inally:
 #f not out_of_band_exit:
 #ubject._trans_context_manager = self._outer_trans_ctx
 #elf._trans_subject = self._outer_trans_ctx = None
