# engine/url.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Provides the :class:`~sqlalchemy.engine.url.URL` class which encapsulates
information about a database connection specification.

The URL object is created automatically when
:func:`~sqlalchemy.engine.create_engine` is called with a string
argument; alternatively, the URL is a public-facing construct which can
be used directly and is also accepted directly by ``create_engine()``.
"""

import re

from .interfaces import Dialect
from .. import exc
from .. import util
from ..dialects import plugins
from ..dialects import registry
from ..util import collections_abc
from ..util import compat


class URL(
 #til.namedtuple(
 #URL",
 #
 #drivername",
 #username",
 #password",
 #host",
 #port",
 #database",
 #query",
 #,
 #
):
 #""
 #epresent the components of a URL used to connect to a database.

 #his object is suitable to be passed directly to a
 #func:`_sa.create_engine` call.  The fields of the URL are parsed
 #rom a string by the :func:`.make_url` function.  The string
 #ormat of the URL is an RFC-1738-style string.

 #o create a new :class:`_engine.URL` object, use the
 #func:`_engine.url.make_url` function.  To construct a :class:`_engine.URL`
 #rogrammatically, use the :meth:`_engine.URL.create` constructor.

 #. versionchanged:: 1.4

 #he :class:`_engine.URL` object is now an immutable object.  To
 #reate a URL, use the :func:`_engine.make_url` or
 #meth:`_engine.URL.create` function / method.  To modify
 # :class:`_engine.URL`, use methods like
 #meth:`_engine.URL.set` and
 #meth:`_engine.URL.update_query_dict` to return a new
 #class:`_engine.URL` object with modifications.   See notes for this
 #hange at :ref:`change_5526`.

 #class:`_engine.URL` contains the following attributes:

 # :attr:`_engine.URL.drivername`: database backend and driver name, such as
 #`postgresql+psycopg2``
 # :attr:`_engine.URL.username`: username string
 # :attr:`_engine.URL.password`: password, which is normally a string but
 #ay also be any object that has a ``__str__()`` method.
 # :attr:`_engine.URL.host`: string hostname
 # :attr:`_engine.URL.port`: integer port number
 # :attr:`_engine.URL.database`: string database name
 # :attr:`_engine.URL.query`: an immutable mapping representing the query
 #tring.  contains strings for keys and either strings or tuples of
 #trings for values.


 #""

 #ef __new__(self, *arg, **kw):
 #f not kw and len(arg) == 7:
 #eturn super(URL, self).__new__(self, *arg, **kw)
 #lse:
 #til.warn_deprecated(
 #Calling URL() directly is deprecated and will be disabled "
 #in a future release.  The public constructor for URL is "
 #now the URL.create() method.",
 #1.4",
 #
 #eturn URL.create(*arg, **kw)

 #classmethod
 #ef create(
 #ls,
 #rivername,
 #sername=None,
 #assword=None,
 #ost=None,
 #ort=None,
 #atabase=None,
 #uery=util.EMPTY_DICT,
 #:
 #""Create a new :class:`_engine.URL` object.

 #param drivername: the name of the database backend. This name will
 #orrespond to a module in sqlalchemy/databases or a third party
 #lug-in.
 #param username: The user name.
 #param password: database password.  May be a string or an object that
 #an be stringified with ``str()``.
 #param host: The name of the host.
 #param port: The port number.
 #param database: The database name.
 #param query: A dictionary of string keys to string values to be passed
 #o the dialect and/or the DBAPI upon connect.   To specify non-string
 #arameters to a Python DBAPI directly, use the
 #paramref:`_sa.create_engine.connect_args` parameter to
 #func:`_sa.create_engine`.   See also
 #attr:`_engine.URL.normalized_query` for a dictionary that is
 #onsistently string->list of string.
 #return: new :class:`_engine.URL` object.

 #. versionadded:: 1.4

 #he :class:`_engine.URL` object is now an **immutable named
 #uple**.  In addition, the ``query`` dictionary is also immutable.
 #o create a URL, use the :func:`_engine.url.make_url` or
 #meth:`_engine.URL.create` function/ method.  To modify a
 #class:`_engine.URL`, use the :meth:`_engine.URL.set` and
 #meth:`_engine.URL.update_query` methods.

 #""

 #eturn cls(
 #ls._assert_str(drivername, "drivername"),
 #ls._assert_none_str(username, "username"),
 #assword,
 #ls._assert_none_str(host, "host"),
 #ls._assert_port(port),
 #ls._assert_none_str(database, "database"),
 #ls._str_dict(query),
 #

 #classmethod
 #ef _assert_port(cls, port):
 #f port is None:
 #eturn None
 #ry:
 #eturn int(port)
 #xcept TypeError:
 #aise TypeError("Port argument must be an integer or None")

 #classmethod
 #ef _assert_str(cls, v, paramname):
 #f v is None:
 #eturn v

 #f not isinstance(v, compat.string_types):
 #aise TypeError("%s must be a string" % paramname)
 #eturn v

 #classmethod
 #ef _assert_none_str(cls, v, paramname):
 #f v is None:
 #eturn v

 #eturn cls._assert_str(v, paramname)

 #classmethod
 #ef _str_dict(cls, dict_):
 #f dict_ is None:
 #eturn util.EMPTY_DICT

 #ef _assert_value(val):
 #f isinstance(val, str):
 #eturn val
 #lif isinstance(val, collections_abc.Sequence):
 #eturn tuple(_assert_value(elem) for elem in val)
 #lse:
 #aise TypeError(
 #Query dictionary values must be strings or "
 #sequences of strings"
 #

 #ef _assert_str(v):
 #f not isinstance(v, compat.string_types):
 #aise TypeError("Query dictionary keys must be strings")
 #eturn v

 #f isinstance(dict_, collections_abc.Sequence):
 #ict_items = dict_
 #lse:
 #ict_items = dict_.items()

 #eturn util.immutabledict(
 #
 #assert_str(key): _assert_value(
 #alue,
 #
 #or key, value in dict_items
 #
 #

 #ef set(
 #elf,
 #rivername=None,
 #sername=None,
 #assword=None,
 #ost=None,
 #ort=None,
 #atabase=None,
 #uery=None,
 #:
 #""return a new :class:`_engine.URL` object with modifications.

 #alues are used if they are non-None.  To set a value to ``None``
 #xplicitly, use the :meth:`_engine.URL._replace` method adapted
 #rom ``namedtuple``.

 #param drivername: new drivername
 #param username: new username
 #param password: new password
 #param host: new hostname
 #param port: new port
 #param query: new query parameters, passed a dict of string keys
 #eferring to string or sequence of string values.  Fully
 #eplaces the previous list of arguments.

 #return: new :class:`_engine.URL` object.

 #. versionadded:: 1.4

 #. seealso::

 #meth:`_engine.URL.update_query_dict`

 #""

 #w = {}
 #f drivername is not None:
 #w["drivername"] = drivername
 #f username is not None:
 #w["username"] = username
 #f password is not None:
 #w["password"] = password
 #f host is not None:
 #w["host"] = host
 #f port is not None:
 #w["port"] = port
 #f database is not None:
 #w["database"] = database
 #f query is not None:
 #w["query"] = query

 #eturn self._replace(**kw)

 #ef _replace(self, **kw):
 #""Override ``namedtuple._replace()`` to provide argument checking."""

 #f "drivername" in kw:
 #elf._assert_str(kw["drivername"], "drivername")
 #or name in "username", "host", "database":
 #f name in kw:
 #elf._assert_none_str(kw[name], name)
 #f "port" in kw:
 #elf._assert_port(kw["port"])
 #f "query" in kw:
 #w["query"] = self._str_dict(kw["query"])

 #eturn super(URL, self)._replace(**kw)

 #ef update_query_string(self, query_string, append=False):
 #""Return a new :class:`_engine.URL` object with the :attr:`_engine.URL.query`
 #arameter dictionary updated by the given query string.

 #.g.::

 #>> from sqlalchemy.engine import make_url
 #>> url = make_url("postgresql://user:pass@host/dbname")
 #>> url = url.update_query_string("alt_host=host1&alt_host=host2&ssl_cipher=%2Fpath%2Fto%2Fcrt")
 #>> str(url)
 #postgresql://user:pass@host/dbname?alt_host=host1&alt_host=host2&ssl_cipher=%2Fpath%2Fto%2Fcrt'

 #param query_string: a URL escaped query string, not including the
 #uestion mark.

 #param append: if True, parameters in the existing query string will
 #ot be removed; new parameters will be in addition to those present.
 #f left at its default of False, keys present in the given query
 #arameters will replace those of the existing query string.

 #. versionadded:: 1.4

 #. seealso::

 #attr:`_engine.URL.query`

 #meth:`_engine.URL.update_query_dict`

 #""  # noqa: E501
 #eturn self.update_query_pairs(
 #til.parse_qsl(query_string), append=append
 #

 #ef update_query_pairs(self, key_value_pairs, append=False):
 #""Return a new :class:`_engine.URL` object with the
 #attr:`_engine.URL.query`
 #arameter dictionary updated by the given sequence of key/value pairs

 #.g.::

 #>> from sqlalchemy.engine import make_url
 #>> url = make_url("postgresql://user:pass@host/dbname")
 #>> url = url.update_query_pairs([("alt_host", "host1"), ("alt_host", "host2"), ("ssl_cipher", "/path/to/crt")])
 #>> str(url)
 #postgresql://user:pass@host/dbname?alt_host=host1&alt_host=host2&ssl_cipher=%2Fpath%2Fto%2Fcrt'

 #param key_value_pairs: A sequence of tuples containing two strings
 #ach.

 #param append: if True, parameters in the existing query string will
 #ot be removed; new parameters will be in addition to those present.
 #f left at its default of False, keys present in the given query
 #arameters will replace those of the existing query string.

 #. versionadded:: 1.4

 #. seealso::

 #attr:`_engine.URL.query`

 #meth:`_engine.URL.difference_update_query`

 #meth:`_engine.URL.set`

 #""  # noqa: E501

 #xisting_query = self.query
 #ew_keys = {}

 #or key, value in key_value_pairs:
 #f key in new_keys:
 #ew_keys[key] = util.to_list(new_keys[key])
 #ew_keys[key].append(value)
 #lse:
 #ew_keys[key] = value

 #f append:
 #ew_query = {}

 #or k in new_keys:
 #f k in existing_query:
 #ew_query[k] = util.to_list(
 #xisting_query[k]
 # + util.to_list(new_keys[k])
 #lse:
 #ew_query[k] = new_keys[k]

 #ew_query.update(
 #
 #: existing_query[k]
 #or k in set(existing_query).difference(new_keys)
 #
 #
 #lse:
 #ew_query = self.query.union(new_keys)
 #eturn self.set(query=new_query)

 #ef update_query_dict(self, query_parameters, append=False):
 #""Return a new :class:`_engine.URL` object with the
 #attr:`_engine.URL.query` parameter dictionary updated by the given
 #ictionary.

 #he dictionary typically contains string keys and string values.
 #n order to represent a query parameter that is expressed multiple
 #imes, pass a sequence of string values.

 #.g.::


 #>> from sqlalchemy.engine import make_url
 #>> url = make_url("postgresql://user:pass@host/dbname")
 #>> url = url.update_query_dict({"alt_host": ["host1", "host2"], "ssl_cipher": "/path/to/crt"})
 #>> str(url)
 #postgresql://user:pass@host/dbname?alt_host=host1&alt_host=host2&ssl_cipher=%2Fpath%2Fto%2Fcrt'


 #param query_parameters: A dictionary with string keys and values
 #hat are either strings, or sequences of strings.

 #param append: if True, parameters in the existing query string will
 #ot be removed; new parameters will be in addition to those present.
 #f left at its default of False, keys present in the given query
 #arameters will replace those of the existing query string.


 #. versionadded:: 1.4

 #. seealso::

 #attr:`_engine.URL.query`

 #meth:`_engine.URL.update_query_string`

 #meth:`_engine.URL.update_query_pairs`

 #meth:`_engine.URL.difference_update_query`

 #meth:`_engine.URL.set`

 #""  # noqa: E501
 #eturn self.update_query_pairs(query_parameters.items(), append=append)

 #ef difference_update_query(self, names):
 #""
 #emove the given names from the :attr:`_engine.URL.query` dictionary,
 #eturning the new :class:`_engine.URL`.

 #.g.::

 #rl = url.difference_update_query(['foo', 'bar'])

 #quivalent to using :meth:`_engine.URL.set` as follows::

 #rl = url.set(
 #uery={
 #ey: url.query[key]
 #or key in set(url.query).difference(['foo', 'bar'])
 #
 #

 #. versionadded:: 1.4

 #. seealso::

 #attr:`_engine.URL.query`

 #meth:`_engine.URL.update_query_dict`

 #meth:`_engine.URL.set`

 #""

 #f not set(names).intersection(self.query):
 #eturn self

 #eturn URL(
 #elf.drivername,
 #elf.username,
 #elf.password,
 #elf.host,
 #elf.port,
 #elf.database,
 #til.immutabledict(
 #
 #ey: self.query[key]
 #or key in set(self.query).difference(names)
 #
 #,
 #

 #util.memoized_property
 #ef normalized_query(self):
 #""Return the :attr:`_engine.URL.query` dictionary with values normalized
 #nto sequences.

 #s the :attr:`_engine.URL.query` dictionary may contain either
 #tring values or sequences of string values to differentiate between
 #arameters that are specified multiple times in the query string,
 #ode that needs to handle multiple parameters generically will wish
 #o use this attribute so that all parameters present are presented
 #s sequences.   Inspiration is from Python's ``urllib.parse.parse_qs``
 #unction.  E.g.::


 #>> from sqlalchemy.engine import make_url
 #>> url = make_url("postgresql://user:pass@host/dbname?alt_host=host1&alt_host=host2&ssl_cipher=%2Fpath%2Fto%2Fcrt")
 #>> url.query
 #mmutabledict({'alt_host': ('host1', 'host2'), 'ssl_cipher': '/path/to/crt'})
 #>> url.normalized_query
 #mmutabledict({'alt_host': ('host1', 'host2'), 'ssl_cipher': ('/path/to/crt',)})

 #""  # noqa: E501

 #eturn util.immutabledict(
 #
 #: (v,) if not isinstance(v, tuple) else v
 #or k, v in self.query.items()
 #
 #

 #util.deprecated(
 #1.4",
 #The :meth:`_engine.URL.__to_string__ method is deprecated and will "
 #be removed in a future release.  Please use the "
 #:meth:`_engine.URL.render_as_string` method.",
 #
 #ef __to_string__(self, hide_password=True):
 #""Render this :class:`_engine.URL` object as a string.

 #param hide_password: Defaults to True.   The password is not shown
 #n the string unless this is set to False.

 #""
 #eturn self.render_as_string(hide_password=hide_password)

 #ef render_as_string(self, hide_password=True):
 #""Render this :class:`_engine.URL` object as a string.

 #his method is used when the ``__str__()`` or ``__repr__()``
 #ethods are used.   The method directly includes additional options.

 #param hide_password: Defaults to True.   The password is not shown
 #n the string unless this is set to False.

 #""
 # = self.drivername + "://"
 #f self.username is not None:
 # += _rfc_1738_quote(self.username)
 #f self.password is not None:
 # += ":" + (
 #***"
 #f hide_password
 #lse _rfc_1738_quote(str(self.password))
 #
 # += "@"
 #f self.host is not None:
 #f ":" in self.host:
 # += "[%s]" % self.host
 #lse:
 # += self.host
 #f self.port is not None:
 # += ":" + str(self.port)
 #f self.database is not None:
 # += "/" + self.database
 #f self.query:
 #eys = list(self.query)
 #eys.sort()
 # += "?" + "&".join(
 #%s=%s" % (util.quote_plus(k), util.quote_plus(element))
 #or k in keys
 #or element in util.to_list(self.query[k])
 #
 #eturn s

 #ef __str__(self):
 #eturn self.render_as_string(hide_password=False)

 #ef __repr__(self):
 #eturn self.render_as_string()

 #ef __hash__(self):
 #eturn hash(str(self))

 #ef __eq__(self, other):
 #eturn (
 #sinstance(other, URL)
 #nd self.drivername == other.drivername
 #nd self.username == other.username
 #nd self.password == other.password
 #nd self.host == other.host
 #nd self.database == other.database
 #nd self.query == other.query
 #nd self.port == other.port
 #

 #ef __ne__(self, other):
 #eturn not self == other

 #ef get_backend_name(self):
 #""Return the backend name.

 #his is the name that corresponds to the database backend in
 #se, and is the portion of the :attr:`_engine.URL.drivername`
 #hat is to the left of the plus sign.

 #""
 #f "+" not in self.drivername:
 #eturn self.drivername
 #lse:
 #eturn self.drivername.split("+")[0]

 #ef get_driver_name(self):
 #""Return the backend name.

 #his is the name that corresponds to the DBAPI driver in
 #se, and is the portion of the :attr:`_engine.URL.drivername`
 #hat is to the right of the plus sign.

 #f the :attr:`_engine.URL.drivername` does not include a plus sign,
 #hen the default :class:`_engine.Dialect` for this :class:`_engine.URL`
 #s imported in order to get the driver name.

 #""

 #f "+" not in self.drivername:
 #eturn self.get_dialect().driver
 #lse:
 #eturn self.drivername.split("+")[1]

 #ef _instantiate_plugins(self, kwargs):
 #lugin_names = util.to_list(self.query.get("plugin", ()))
 #lugin_names += kwargs.get("plugins", [])

 #wargs = dict(kwargs)

 #oaded_plugins = [
 #lugins.load(plugin_name)(self, kwargs)
 #or plugin_name in plugin_names
 #

 # = self.difference_update_query(["plugin", "plugins"])

 #or plugin in loaded_plugins:
 #ew_u = plugin.update_url(u)
 #f new_u is not None:
 # = new_u

 #wargs.pop("plugins", None)

 #eturn u, loaded_plugins, kwargs

 #ef _get_entrypoint(self):
 #""Return the "entry point" dialect class.

 #his is normally the dialect itself except in the case when the
 #eturned class implements the get_dialect_cls() method.

 #""
 #f "+" not in self.drivername:
 #ame = self.drivername
 #lse:
 #ame = self.drivername.replace("+", ".")
 #ls = registry.load(name)
        # check for legacy dialects that
        # would return a module with 'dialect' as the
        # actual class
 #f (
 #asattr(cls, "dialect")
 #nd isinstance(cls.dialect, type)
 #nd issubclass(cls.dialect, Dialect)
 #:
 #eturn cls.dialect
 #lse:
 #eturn cls

 #ef get_dialect(self):
 #""Return the SQLAlchemy :class:`_engine.Dialect` class corresponding
 #o this URL's driver name.

 #""
 #ntrypoint = self._get_entrypoint()
 #ialect_cls = entrypoint.get_dialect_cls(self)
 #eturn dialect_cls

 #ef translate_connect_args(self, names=[], **kw):
 #"""Translate url attributes into a dictionary of connection arguments.

 #eturns attributes of this url (`host`, `database`, `username`,
 #password`, `port`) as a plain dictionary.  The attribute names are
 #sed as the keys by default.  Unset or false attributes are omitted
 #rom the final dictionary.

 #param \**kw: Optional, alternate key names for url attributes.

 #param names: Deprecated.  Same purpose as the keyword-based alternate
 #ames, but correlates the name to the original positionally.
 #""

 #ranslated = {}
 #ttribute_names = ["host", "database", "username", "password", "port"]
 #or sname in attribute_names:
 #f names:
 #ame = names.pop(0)
 #lif sname in kw:
 #ame = kw[sname]
 #lse:
 #ame = sname
 #f name is not None and getattr(self, sname, False):
 #ranslated[name] = getattr(self, sname)
 #eturn translated


def make_url(name_or_url):
 #""Given a string or unicode instance, produce a new URL instance.

 #he given string is parsed according to the RFC 1738 spec.  If an
 #xisting URL object is passed, just returns the object.
 #""

 #f isinstance(name_or_url, util.string_types):
 #eturn _parse_rfc1738_args(name_or_url)
 #lse:
 #eturn name_or_url


def _parse_rfc1738_args(name):
 #attern = re.compile(
 #"""
 #?P<name>[\w\+]+)://
 #?:
 #?P<username>[^:/]*)
 #?::(?P<password>[^@]*))?
 #)?
 #?:
 #?:
 #[(?P<ipv6host>[^/\?]+)\] |
 #?P<ipv4host>[^/:\?]+)
 #?
 #?::(?P<port>[^/\?]*))?
 #?
 #?:/(?P<database>[^\?]*))?
 #?:\?(?P<query>.*))?
 #"",
 #e.X,
 #

 # = pattern.match(name)
 #f m is not None:
 #omponents = m.groupdict()
 #f components["query"] is not None:
 #uery = {}

 #or key, value in util.parse_qsl(components["query"]):
 #f util.py2k:
 #ey = key.encode("ascii")
 #f key in query:
 #uery[key] = util.to_list(query[key])
 #uery[key].append(value)
 #lse:
 #uery[key] = value
 #lse:
 #uery = None
 #omponents["query"] = query

 #f components["username"] is not None:
 #omponents["username"] = _rfc_1738_unquote(components["username"])

 #f components["password"] is not None:
 #omponents["password"] = _rfc_1738_unquote(components["password"])

 #pv4host = components.pop("ipv4host")
 #pv6host = components.pop("ipv6host")
 #omponents["host"] = ipv4host or ipv6host
 #ame = components.pop("name")

 #f components["port"]:
 #omponents["port"] = int(components["port"])

 #eturn URL.create(name, **components)

 #lse:
 #aise exc.ArgumentError(
 #Could not parse rfc1738 URL from string '%s'" % name
 #


def _rfc_1738_quote(text):
 #eturn re.sub(r"[:@/]", lambda m: "%%%X" % ord(m.group(0)), text)


def _rfc_1738_unquote(text):
 #eturn util.unquote(text)


def _parse_keyvalue_args(name):
 # = re.match(r"(\w+)://(.*)", name)
 #f m is not None:
 #name, args) = m.group(1, 2)
 #pts = dict(util.parse_qsl(args))
 #eturn URL(name, *opts)
 #lse:
 #eturn None
