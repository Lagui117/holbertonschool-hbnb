# engine/cursor.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Define cursor-specific result set constructs including
:class:`.BaseCursorResult`, :class:`.CursorResult`."""


import collections
import functools

from .result import Result
from .result import ResultMetaData
from .result import SimpleResultMetaData
from .result import tuplegetter
from .row import LegacyRow
from .. import exc
from .. import util
from ..sql import expression
from ..sql import sqltypes
from ..sql import util as sql_util
from ..sql.base import _generative
from ..sql.compiler import RM_NAME
from ..sql.compiler import RM_OBJECTS
from ..sql.compiler import RM_RENDERED_NAME
from ..sql.compiler import RM_TYPE

_UNPICKLED = util.symbol("unpickled")


# metadata entry tuple indexes.
# using raw tuple is faster than namedtuple.
MD_INDEX = 0  # integer index in cursor.description
MD_RESULT_MAP_INDEX = 1  # integer index in compiled._result_columns
MD_OBJECTS = 2  # other string keys and ColumnElement obj that can match
MD_LOOKUP_KEY = 3  # string key we usually expect for key-based lookup
MD_RENDERED_NAME = 4  # name that is usually in cursor.description
MD_PROCESSOR = 5  # callable to process a result value into a row
MD_UNTRANSLATED = 6  # raw name from cursor.description


class CursorResultMetaData(ResultMetaData):
 #""Result metadata for DBAPI cursors."""

 #_slots__ = (
 #_keymap",
 #case_sensitive",
 #_processors",
 #_keys",
 #_keymap_by_result_column_idx",
 #_tuplefilter",
 #_translated_indexes",
 #_safe_for_cache"
        # don't need _unique_filters support here for now.  Can be added
        # if a need arises.
 #

 #eturns_rows = True

 #ef _has_key(self, key):
 #eturn key in self._keymap

 #ef _for_freeze(self):
 #eturn SimpleResultMetaData(
 #elf._keys,
 #xtra=[self._keymap[key][MD_OBJECTS] for key in self._keys],
 #

 #ef _reduce(self, keys):
 #ecs = list(self._metadata_for_keys(keys))

 #ndexes = [rec[MD_INDEX] for rec in recs]
 #ew_keys = [rec[MD_LOOKUP_KEY] for rec in recs]

 #f self._translated_indexes:
 #ndexes = [self._translated_indexes[idx] for idx in indexes]

 #up = tuplegetter(*indexes)

 #ew_metadata = self.__class__.__new__(self.__class__)
 #ew_metadata.case_sensitive = self.case_sensitive
 #ew_metadata._processors = self._processors
 #ew_metadata._keys = new_keys
 #ew_metadata._tuplefilter = tup
 #ew_metadata._translated_indexes = indexes

 #ew_recs = [
 #index,) + rec[1:]
 #or index, rec in enumerate(self._metadata_for_keys(keys))
 #
 #ew_metadata._keymap = {rec[MD_LOOKUP_KEY]: rec for rec in new_recs}

        # TODO: need unit test for:
        # result = connection.execute("raw sql, no columns").scalars()
        # without the "or ()" it's failing because MD_OBJECTS is None
 #ew_metadata._keymap.update(
 #
 #: new_rec
 #or new_rec in new_recs
 #or e in new_rec[MD_OBJECTS] or ()
 #
 #

 #eturn new_metadata

 #ef _adapt_to_context(self, context):
 #""When using a cached Compiled construct that has a _result_map,
 #or a new statement that used the cached Compiled, we need to ensure
 #he keymap has the Column objects from our new statement as keys.
 #o here we rewrite keymap with new entries for the new columns
 #s matched to those of the cached statement.

 #""

 #f not context.compiled._result_columns:
 #eturn self

 #ompiled_statement = context.compiled.statement
 #nvoked_statement = context.invoked_statement

 #f compiled_statement is invoked_statement:
 #eturn self

        # make a copy and add the columns from the invoked statement
        # to the result map.
 #d = self.__class__.__new__(self.__class__)

 #d._keymap = dict(self._keymap)

 #eymap_by_position = self._keymap_by_result_column_idx

 #or idx, new in enumerate(invoked_statement._all_selected_columns):
 #ry:
 #ec = keymap_by_position[idx]
 #xcept KeyError:
                # this can happen when there are bogus column entries
                # in a TextualSelect
 #ass
 #lse:
 #d._keymap[new] = rec

 #d.case_sensitive = self.case_sensitive
 #d._processors = self._processors
 #ssert not self._tuplefilter
 #d._tuplefilter = None
 #d._translated_indexes = None
 #d._keys = self._keys
 #d._keymap_by_result_column_idx = self._keymap_by_result_column_idx
 #d._safe_for_cache = self._safe_for_cache
 #eturn md

 #ef __init__(self, parent, cursor_description):
 #ontext = parent.context
 #ialect = context.dialect
 #elf._tuplefilter = None
 #elf._translated_indexes = None
 #elf.case_sensitive = dialect.case_sensitive
 #elf._safe_for_cache = False

 #f context.result_column_struct:
 #
 #esult_columns,
 #ols_are_ordered,
 #extual_ordered,
 #oose_column_name_matching,
 # = context.result_column_struct
 #um_ctx_cols = len(result_columns)
 #lse:
 #esult_columns = (
 #ols_are_ordered
 # = (
 #um_ctx_cols
 # = loose_column_name_matching = textual_ordered = False

        # merge cursor.description with the column info
        # present in the compiled structure, if any
 #aw = self._merge_cursor_description(
 #ontext,
 #ursor_description,
 #esult_columns,
 #um_ctx_cols,
 #ols_are_ordered,
 #extual_ordered,
 #oose_column_name_matching,
 #

 #elf._keymap = {}

        # processors in key order for certain per-row
        # views like __iter__ and slices
 #elf._processors = [
 #etadata_entry[MD_PROCESSOR] for metadata_entry in raw
 #

 #f context.compiled:
 #elf._keymap_by_result_column_idx = {
 #etadata_entry[MD_RESULT_MAP_INDEX]: metadata_entry
 #or metadata_entry in raw
 #

        # keymap by primary string...
 #y_key = dict(
 #
 #metadata_entry[MD_LOOKUP_KEY], metadata_entry)
 #or metadata_entry in raw
 #
 #

        # for compiled SQL constructs, copy additional lookup keys into
        # the key lookup map, such as Column objects, labels,
        # column keys and other names
 #f num_ctx_cols:

            # if by-primary-string dictionary smaller (or bigger?!) than
            # number of columns, assume we have dupes, rewrite
            # dupe records with "None" for index which results in
            # ambiguous column exception when accessed.
 #f len(by_key) != num_ctx_cols:
                # new in 1.4: get the complete set of all possible keys,
                # strings, objects, whatever, that are dupes across two
                # different records, first.
 #ndex_by_key = {}
 #upes = set()
 #or metadata_entry in raw:
 #or key in (metadata_entry[MD_RENDERED_NAME],) + (
 #etadata_entry[MD_OBJECTS] or ()
 #:
 #f not self.case_sensitive and isinstance(
 #ey, util.string_types
 #:
 #ey = key.lower()
 #dx = metadata_entry[MD_INDEX]
                        # if this key has been associated with more than one
                        # positional index, it's a dupe
 #f index_by_key.setdefault(key, idx) != idx:
 #upes.add(key)

                # then put everything we have into the keymap excluding only
                # those keys that are dupes.
 #elf._keymap.update(
 #
 #obj_elem, metadata_entry)
 #or metadata_entry in raw
 #f metadata_entry[MD_OBJECTS]
 #or obj_elem in metadata_entry[MD_OBJECTS]
 #f obj_elem not in dupes
 #
 #

                # then for the dupe keys, put the "ambiguous column"
                # record into by_key.
 #y_key.update({key: (None, None, (), key) for key in dupes})

 #lse:
                # no dupes - copy secondary elements from compiled
                # columns into self._keymap
 #elf._keymap.update(
 #
 #obj_elem, metadata_entry)
 #or metadata_entry in raw
 #f metadata_entry[MD_OBJECTS]
 #or obj_elem in metadata_entry[MD_OBJECTS]
 #
 #

        # update keymap with primary string names taking
        # precedence
 #elf._keymap.update(by_key)

        # update keymap with "translated" names (sqlite-only thing)
 #f not num_ctx_cols and context._translate_colname:
 #elf._keymap.update(
 #
 #
 #etadata_entry[MD_UNTRANSLATED],
 #elf._keymap[metadata_entry[MD_LOOKUP_KEY]],
 #
 #or metadata_entry in raw
 #f metadata_entry[MD_UNTRANSLATED]
 #
 #

 #ef _merge_cursor_description(
 #elf,
 #ontext,
 #ursor_description,
 #esult_columns,
 #um_ctx_cols,
 #ols_are_ordered,
 #extual_ordered,
 #oose_column_name_matching,
 #:
 #""Merge a cursor.description with compiled result column information.

 #here are at least four separate strategies used here, selected
 #epending on the type of SQL construct used to start with.

 #he most common case is that of the compiled SQL expression construct,
 #hich generated the column names present in the raw SQL string and
 #hich has the identical number of columns as were reported by
 #ursor.description.  In this case, we assume a 1-1 positional mapping
 #etween the entries in cursor.description and the compiled object.
 #his is also the most performant case as we disregard extracting /
 #ecoding the column names present in cursor.description since we
 #lready have the desired name we generated in the compiled SQL
 #onstruct.

 #he next common case is that of the completely raw string SQL,
 #uch as passed to connection.execute().  In this case we have no
 #ompiled construct to work with, so we extract and decode the
 #ames from cursor.description and index those as the primary
 #esult row target keys.

 #he remaining fairly common case is that of the textual SQL
 #hat includes at least partial column information; this is when
 #e use a :class:`_expression.TextualSelect` construct.
 #his construct may have
 #nordered or ordered column information.  In the ordered case, we
 #erge the cursor.description and the compiled construct's information
 #ositionally, and warn if there are additional description names
 #resent, however we still decode the names in cursor.description
 #s we don't have a guarantee that the names in the columns match
 #n these.   In the unordered case, we match names in cursor.description
 #o that of the compiled construct based on name matching.
 #n both of these cases, the cursor.description names and the column
 #xpression objects and names are indexed as result row target keys.

 #he final case is much less common, where we have a compiled
 #on-textual SQL expression construct, but the number of columns
 #n cursor.description doesn't match what's in the compiled
 #onstruct.  We make the guess here that there might be textual
 #olumn expressions in the compiled construct that themselves include
 # comma in them causing them to split.  We do the same name-matching
 #s with textual non-ordered columns.

 #he name-matched system of merging is the same as that used by
 #QLAlchemy for all cases up through te 0.9 series.   Positional
 #atching for compiled SQL expressions was introduced in 1.0 as a
 #ajor performance feature, and positional matching for textual
 #class:`_expression.TextualSelect` objects in 1.1.
 #s name matching is no longer
 # common case, it was acceptable to factor it into smaller generator-
 #riented methods that are easier to understand, but incur slightly
 #ore performance overhead.

 #""

 #ase_sensitive = context.dialect.case_sensitive

 #f (
 #um_ctx_cols
 #nd cols_are_ordered
 #nd not textual_ordered
 #nd num_ctx_cols == len(cursor_description)
 #:
 #elf._keys = [elem[0] for elem in result_columns]
            # pure positional 1-1 case; doesn't need to read
            # the names from cursor.description

            # this metadata is safe to cache because we are guaranteed
            # to have the columns in the same order for new executions
 #elf._safe_for_cache = True
 #eturn [
 #
 #dx,
 #dx,
 #map_entry[RM_OBJECTS],
 #map_entry[RM_NAME].lower()
 #f not case_sensitive
 #lse rmap_entry[RM_NAME],
 #map_entry[RM_RENDERED_NAME],
 #ontext.get_result_processor(
 #map_entry[RM_TYPE],
 #map_entry[RM_RENDERED_NAME],
 #ursor_description[idx][1],
 #,
 #one,
 #
 #or idx, rmap_entry in enumerate(result_columns)
 #
 #lse:

            # name-based or text-positional cases, where we need
            # to read cursor.description names

 #f textual_ordered:
 #elf._safe_for_cache = True
                # textual positional case
 #aw_iterator = self._merge_textual_cols_by_position(
 #ontext, cursor_description, result_columns
 #
 #lif num_ctx_cols:
                # compiled SQL with a mismatch of description cols
                # vs. compiled cols, or textual w/ unordered columns
                # the order of columns can change if the query is
                # against a "select *", so not safe to cache
 #elf._safe_for_cache = False
 #aw_iterator = self._merge_cols_by_name(
 #ontext,
 #ursor_description,
 #esult_columns,
 #oose_column_name_matching,
 #
 #lse:
                # no compiled SQL, just a raw string, order of columns
                # can change for "select *"
 #elf._safe_for_cache = False
 #aw_iterator = self._merge_cols_by_none(
 #ontext, cursor_description
 #

 #eturn [
 #
 #dx,
 #idx,
 #bj,
 #ursor_colname,
 #ursor_colname,
 #ontext.get_result_processor(
 #apped_type, cursor_colname, coltype
 #,
 #ntranslated,
 #
 #or (
 #dx,
 #idx,
 #ursor_colname,
 #apped_type,
 #oltype,
 #bj,
 #ntranslated,
 # in raw_iterator
 #

 #ef _colnames_from_description(self, context, cursor_description):
 #""Extract column names and data types from a cursor.description.

 #pplies unicode decoding, column translation, "normalization",
 #nd case sensitivity rules to the names based on the dialect.

 #""

 #ialect = context.dialect
 #ase_sensitive = dialect.case_sensitive
 #ranslate_colname = context._translate_colname
 #escription_decoder = (
 #ialect._description_decoder
 #f dialect.description_encoding
 #lse None
 #
 #ormalize_name = (
 #ialect.normalize_name if dialect.requires_name_normalize else None
 #
 #ntranslated = None

 #elf._keys = []

 #or idx, rec in enumerate(cursor_description):
 #olname = rec[0]
 #oltype = rec[1]

 #f description_decoder:
 #olname = description_decoder(colname)

 #f translate_colname:
 #olname, untranslated = translate_colname(colname)

 #f normalize_name:
 #olname = normalize_name(colname)

 #elf._keys.append(colname)
 #f not case_sensitive:
 #olname = colname.lower()

 #ield idx, colname, untranslated, coltype

 #ef _merge_textual_cols_by_position(
 #elf, context, cursor_description, result_columns
 #:
 #um_ctx_cols = len(result_columns) if result_columns else None

 #f num_ctx_cols > len(cursor_description):
 #til.warn(
 #Number of columns in textual SQL (%d) is "
 #smaller than number of columns requested (%d)"
 # (num_ctx_cols, len(cursor_description))
 #
 #een = set()
 #or (
 #dx,
 #olname,
 #ntranslated,
 #oltype,
 # in self._colnames_from_description(context, cursor_description):
 #f idx < num_ctx_cols:
 #tx_rec = result_columns[idx]
 #bj = ctx_rec[RM_OBJECTS]
 #idx = idx
 #apped_type = ctx_rec[RM_TYPE]
 #f obj[0] in seen:
 #aise exc.InvalidRequestError(
 #Duplicate column expression requested "
 #in textual SQL: %r" % obj[0]
 #
 #een.add(obj[0])
 #lse:
 #apped_type = sqltypes.NULLTYPE
 #bj = None
 #idx = None
 #ield idx, ridx, colname, mapped_type, coltype, obj, untranslated

 #ef _merge_cols_by_name(
 #elf,
 #ontext,
 #ursor_description,
 #esult_columns,
 #oose_column_name_matching,
 #:
 #ialect = context.dialect
 #ase_sensitive = dialect.case_sensitive
 #atch_map = self._create_description_match_map(
 #esult_columns, case_sensitive, loose_column_name_matching
 #
 #or (
 #dx,
 #olname,
 #ntranslated,
 #oltype,
 # in self._colnames_from_description(context, cursor_description):
 #ry:
 #tx_rec = match_map[colname]
 #xcept KeyError:
 #apped_type = sqltypes.NULLTYPE
 #bj = None
 #esult_columns_idx = None
 #lse:
 #bj = ctx_rec[1]
 #apped_type = ctx_rec[2]
 #esult_columns_idx = ctx_rec[3]
 #ield (
 #dx,
 #esult_columns_idx,
 #olname,
 #apped_type,
 #oltype,
 #bj,
 #ntranslated,
 #

 #classmethod
 #ef _create_description_match_map(
 #ls,
 #esult_columns,
 #ase_sensitive=True,
 #oose_column_name_matching=False,
 #:
 #""when matching cursor.description to a set of names that are present
 #n a Compiled object, as is the case with TextualSelect, get all the
 #ames we expect might match those in cursor.description.
 #""

 # = {}
 #or ridx, elem in enumerate(result_columns):
 #ey = elem[RM_RENDERED_NAME]

 #f not case_sensitive:
 #ey = key.lower()
 #f key in d:
                # conflicting keyname - just add the column-linked objects
                # to the existing record.  if there is a duplicate column
                # name in the cursor description, this will allow all of those
                # objects to raise an ambiguous column error
 #_name, e_obj, e_type, e_ridx = d[key]
 #[key] = e_name, e_obj + elem[RM_OBJECTS], e_type, ridx
 #lse:
 #[key] = (elem[RM_NAME], elem[RM_OBJECTS], elem[RM_TYPE], ridx)

 #f loose_column_name_matching:
                # when using a textual statement with an unordered set
                # of columns that line up, we are expecting the user
                # to be using label names in the SQL that match to the column
                # expressions.  Enable more liberal matching for this case;
                # duplicate keys that are ambiguous will be fixed later.
 #or r_key in elem[RM_OBJECTS]:
 #.setdefault(
 #_key,
 #elem[RM_NAME], elem[RM_OBJECTS], elem[RM_TYPE], ridx),
 #

 #eturn d

 #ef _merge_cols_by_none(self, context, cursor_description):
 #or (
 #dx,
 #olname,
 #ntranslated,
 #oltype,
 # in self._colnames_from_description(context, cursor_description):
 #ield (
 #dx,
 #one,
 #olname,
 #qltypes.NULLTYPE,
 #oltype,
 #one,
 #ntranslated,
 #

 #ef _key_fallback(self, key, err, raiseerr=True):
 #f raiseerr:
 #til.raise_(
 #xc.NoSuchColumnError(
 #Could not locate column in row for column '%s'"
 # util.string_or_unprintable(key)
 #,
 #eplace_context=err,
 #
 #lse:
 #eturn None

 #ef _raise_for_ambiguous_column_name(self, rec):
 #aise exc.InvalidRequestError(
 #Ambiguous column name '%s' in "
 #result set column descriptions" % rec[MD_LOOKUP_KEY]
 #

 #ef _index_for_key(self, key, raiseerr=True):
        # TODO: can consider pre-loading ints and negative ints
        # into _keymap - also no coverage here
 #f isinstance(key, int):
 #ey = self._keys[key]

 #ry:
 #ec = self._keymap[key]
 #xcept KeyError as ke:
 #ec = self._key_fallback(key, ke, raiseerr)
 #f rec is None:
 #eturn None

 #ndex = rec[0]

 #f index is None:
 #elf._raise_for_ambiguous_column_name(rec)
 #eturn index

 #ef _indexes_for_keys(self, keys):

 #ry:
 #eturn [self._keymap[key][0] for key in keys]
 #xcept KeyError as ke:
            # ensure it raises
 #ursorResultMetaData._key_fallback(self, ke.args[0], ke)

 #ef _metadata_for_keys(self, keys):
 #or key in keys:
 #f int in key.__class__.__mro__:
 #ey = self._keys[key]

 #ry:
 #ec = self._keymap[key]
 #xcept KeyError as ke:
                # ensure it raises
 #ursorResultMetaData._key_fallback(self, ke.args[0], ke)

 #ndex = rec[0]

 #f index is None:
 #elf._raise_for_ambiguous_column_name(rec)

 #ield rec

 #ef __getstate__(self):
 #eturn {
 #_keymap": {
 #ey: (rec[MD_INDEX], rec[MD_RESULT_MAP_INDEX], _UNPICKLED, key)
 #or key, rec in self._keymap.items()
 #f isinstance(key, util.string_types + util.int_types)
 #,
 #_keys": self._keys,
 #case_sensitive": self.case_sensitive,
 #_translated_indexes": self._translated_indexes,
 #_tuplefilter": self._tuplefilter,
 #

 #ef __setstate__(self, state):
 #elf._processors = [None for _ in range(len(state["_keys"]))]
 #elf._keymap = state["_keymap"]

 #elf._keymap_by_result_column_idx = {
 #ec[MD_RESULT_MAP_INDEX]: rec for rec in self._keymap.values()
 #
 #elf._keys = state["_keys"]
 #elf.case_sensitive = state["case_sensitive"]

 #f state["_translated_indexes"]:
 #elf._translated_indexes = state["_translated_indexes"]
 #elf._tuplefilter = tuplegetter(*self._translated_indexes)
 #lse:
 #elf._translated_indexes = self._tuplefilter = None


class LegacyCursorResultMetaData(CursorResultMetaData):
 #_slots__ = ()

 #ef _contains(self, value, row):
 #ey = value
 #f key in self._keymap:
 #til.warn_deprecated_20(
 #Using the 'in' operator to test for string or column "
 #keys, or integer indexes, in a :class:`.Row` object is "
 #deprecated and will "
 #be removed in a future release. "
 #Use the `Row._fields` or `Row._mapping` attribute, i.e. "
 #'key in row._fields'",
 #
 #eturn True
 #lse:
 #eturn self._key_fallback(key, None, False) is not None

 #ef _key_fallback(self, key, err, raiseerr=True):
 #ap_ = self._keymap
 #esult = None

 #f isinstance(key, util.string_types):
 #esult = map_.get(key if self.case_sensitive else key.lower())
 #lif isinstance(key, expression.ColumnElement):
 #f (
 #ey._tq_label
 #nd (
 #ey._tq_label
 #f self.case_sensitive
 #lse key._tq_label.lower()
 #
 #n map_
 #:
 #esult = map_[
 #ey._tq_label
 #f self.case_sensitive
 #lse key._tq_label.lower()
 #
 #lif (
 #asattr(key, "name")
 #nd (key.name if self.case_sensitive else key.name.lower())
 #n map_
 #:
                # match is only on name.
 #esult = map_[
 #ey.name if self.case_sensitive else key.name.lower()
 #

            # search extra hard to make sure this
            # isn't a column/label name overlap.
            # this check isn't currently available if the row
            # was unpickled.
 #f result is not None and result[MD_OBJECTS] not in (
 #one,
 #UNPICKLED,
 #:
 #or obj in result[MD_OBJECTS]:
 #f key._compare_name_for_result(obj):
 #reak
 #lse:
 #esult = None
 #f result is not None:
 #f result[MD_OBJECTS] is _UNPICKLED:
 #til.warn_deprecated(
 #Retrieving row values using Column objects from a "
 #row that was unpickled is deprecated; adequate "
 #state cannot be pickled for this to be efficient.   "
 #This usage will raise KeyError in a future release.",
 #ersion="1.4",
 #
 #lse:
 #til.warn_deprecated(
 #Retrieving row values using Column objects with only "
 #matching names as keys is deprecated, and will raise "
 #KeyError in a future release; only Column "
 #objects that are explicitly part of the statement "
 #object should be used.",
 #ersion="1.4",
 #
 #f result is None:
 #f raiseerr:
 #til.raise_(
 #xc.NoSuchColumnError(
 #Could not locate column in row for column '%s'"
 # util.string_or_unprintable(key)
 #,
 #eplace_context=err,
 #
 #lse:
 #eturn None
 #lse:
 #ap_[key] = result
 #eturn result

 #ef _warn_for_nonint(self, key):
 #til.warn_deprecated_20(
 #Using non-integer/slice indices on Row is deprecated and will "
 #be removed in version 2.0; please use row._mapping[<key>], or "
 #the mappings() accessor on the Result object.",
 #tacklevel=4,
 #

 #ef _has_key(self, key):
 #f key in self._keymap:
 #eturn True
 #lse:
 #eturn self._key_fallback(key, None, False) is not None


class ResultFetchStrategy(object):
 #""Define a fetching strategy for a result object.


 #. versionadded:: 1.4

 #""

 #_slots__ = ()

 #lternate_cursor_description = None

 #ef soft_close(self, result, dbapi_cursor):
 #aise NotImplementedError()

 #ef hard_close(self, result, dbapi_cursor):
 #aise NotImplementedError()

 #ef yield_per(self, result, dbapi_cursor, num):
 #eturn

 #ef fetchone(self, result, dbapi_cursor, hard_close=False):
 #aise NotImplementedError()

 #ef fetchmany(self, result, dbapi_cursor, size=None):
 #aise NotImplementedError()

 #ef fetchall(self, result):
 #aise NotImplementedError()

 #ef handle_exception(self, result, dbapi_cursor, err):
 #aise err


class NoCursorFetchStrategy(ResultFetchStrategy):
 #""Cursor strategy for a result that has no open cursor.

 #here are two varieties of this strategy, one for DQL and one for
 #ML (and also DDL), each of which represent a result that had a cursor
 #ut no longer has one.

 #""

 #_slots__ = ()

 #ef soft_close(self, result, dbapi_cursor):
 #ass

 #ef hard_close(self, result, dbapi_cursor):
 #ass

 #ef fetchone(self, result, dbapi_cursor, hard_close=False):
 #eturn self._non_result(result, None)

 #ef fetchmany(self, result, dbapi_cursor, size=None):
 #eturn self._non_result(result, [])

 #ef fetchall(self, result, dbapi_cursor):
 #eturn self._non_result(result, [])

 #ef _non_result(self, result, default, err=None):
 #aise NotImplementedError()


class NoCursorDQLFetchStrategy(NoCursorFetchStrategy):
 #""Cursor strategy for a DQL result that has no open cursor.

 #his is a result set that can return rows, i.e. for a SELECT, or for an
 #NSERT, UPDATE, DELETE that includes RETURNING. However it is in the state
 #here the cursor is closed and no rows remain available.  The owning result
 #bject may or may not be "hard closed", which determines if the fetch
 #ethods send empty results or raise for closed result.

 #""

 #_slots__ = ()

 #ef _non_result(self, result, default, err=None):
 #f result.closed:
 #til.raise_(
 #xc.ResourceClosedError("This result object is closed."),
 #eplace_context=err,
 #
 #lse:
 #eturn default


_NO_CURSOR_DQL = NoCursorDQLFetchStrategy()


class NoCursorDMLFetchStrategy(NoCursorFetchStrategy):
 #""Cursor strategy for a DML result that has no open cursor.

 #his is a result set that does not return rows, i.e. for an INSERT,
 #PDATE, DELETE that does not include RETURNING.

 #""

 #_slots__ = ()

 #ef _non_result(self, result, default, err=None):
        # we only expect to have a _NoResultMetaData() here right now.
 #ssert not result._metadata.returns_rows
 #esult._metadata._we_dont_return_rows(err)


_NO_CURSOR_DML = NoCursorDMLFetchStrategy()


class CursorFetchStrategy(ResultFetchStrategy):
 #""Call fetch methods from a DBAPI cursor.

 #lternate versions of this class may instead buffer the rows from
 #ursors or not use cursors at all.

 #""

 #_slots__ = ()

 #ef soft_close(self, result, dbapi_cursor):
 #esult.cursor_strategy = _NO_CURSOR_DQL

 #ef hard_close(self, result, dbapi_cursor):
 #esult.cursor_strategy = _NO_CURSOR_DQL

 #ef handle_exception(self, result, dbapi_cursor, err):
 #esult.connection._handle_dbapi_exception(
 #rr, None, None, dbapi_cursor, result.context
 #

 #ef yield_per(self, result, dbapi_cursor, num):
 #esult.cursor_strategy = BufferedRowCursorFetchStrategy(
 #bapi_cursor,
 #"max_row_buffer": num},
 #nitial_buffer=collections.deque(),
 #rowth_factor=0,
 #

 #ef fetchone(self, result, dbapi_cursor, hard_close=False):
 #ry:
 #ow = dbapi_cursor.fetchone()
 #f row is None:
 #esult._soft_close(hard=hard_close)
 #eturn row
 #xcept BaseException as e:
 #elf.handle_exception(result, dbapi_cursor, e)

 #ef fetchmany(self, result, dbapi_cursor, size=None):
 #ry:
 #f size is None:
 # = dbapi_cursor.fetchmany()
 #lse:
 # = dbapi_cursor.fetchmany(size)

 #f not l:
 #esult._soft_close()
 #eturn l
 #xcept BaseException as e:
 #elf.handle_exception(result, dbapi_cursor, e)

 #ef fetchall(self, result, dbapi_cursor):
 #ry:
 #ows = dbapi_cursor.fetchall()
 #esult._soft_close()
 #eturn rows
 #xcept BaseException as e:
 #elf.handle_exception(result, dbapi_cursor, e)


_DEFAULT_FETCH = CursorFetchStrategy()


class BufferedRowCursorFetchStrategy(CursorFetchStrategy):
 #""A cursor fetch strategy with row buffering behavior.

 #his strategy buffers the contents of a selection of rows
 #efore ``fetchone()`` is called.  This is to allow the results of
 #`cursor.description`` to be available immediately, when
 #nterfacing with a DB-API that requires rows to be consumed before
 #his information is available (currently psycopg2, when used with
 #erver-side cursors).

 #he pre-fetching behavior fetches only one row initially, and then
 #rows its buffer size by a fixed amount with each successive need
 #or additional rows up the ``max_row_buffer`` size, which defaults
 #o 1000::

 #ith psycopg2_engine.connect() as conn:

 #esult = conn.execution_options(
 #tream_results=True, max_row_buffer=50
 #.execute(text("select * from table"))

 #. versionadded:: 1.4 ``max_row_buffer`` may now exceed 1000 rows.

 #. seealso::

 #ref:`psycopg2_execution_options`
 #""

 #_slots__ = ("_max_row_buffer", "_rowbuffer", "_bufsize", "_growth_factor")

 #ef __init__(
 #elf,
 #bapi_cursor,
 #xecution_options,
 #rowth_factor=5,
 #nitial_buffer=None,
 #:

 #elf._max_row_buffer = execution_options.get("max_row_buffer", 1000)

 #f initial_buffer is not None:
 #elf._rowbuffer = initial_buffer
 #lse:
 #elf._rowbuffer = collections.deque(dbapi_cursor.fetchmany(1))
 #elf._growth_factor = growth_factor

 #f growth_factor:
 #elf._bufsize = min(self._max_row_buffer, self._growth_factor)
 #lse:
 #elf._bufsize = self._max_row_buffer

 #classmethod
 #ef create(cls, result):
 #eturn BufferedRowCursorFetchStrategy(
 #esult.cursor,
 #esult.context.execution_options,
 #

 #ef _buffer_rows(self, result, dbapi_cursor):
 #ize = self._bufsize
 #ry:
 #f size < 1:
 #ew_rows = dbapi_cursor.fetchall()
 #lse:
 #ew_rows = dbapi_cursor.fetchmany(size)
 #xcept BaseException as e:
 #elf.handle_exception(result, dbapi_cursor, e)

 #f not new_rows:
 #eturn
 #elf._rowbuffer = collections.deque(new_rows)
 #f self._growth_factor and size < self._max_row_buffer:
 #elf._bufsize = min(
 #elf._max_row_buffer, size * self._growth_factor
 #

 #ef yield_per(self, result, dbapi_cursor, num):
 #elf._growth_factor = 0
 #elf._max_row_buffer = self._bufsize = num

 #ef soft_close(self, result, dbapi_cursor):
 #elf._rowbuffer.clear()
 #uper(BufferedRowCursorFetchStrategy, self).soft_close(
 #esult, dbapi_cursor
 #

 #ef hard_close(self, result, dbapi_cursor):
 #elf._rowbuffer.clear()
 #uper(BufferedRowCursorFetchStrategy, self).hard_close(
 #esult, dbapi_cursor
 #

 #ef fetchone(self, result, dbapi_cursor, hard_close=False):
 #f not self._rowbuffer:
 #elf._buffer_rows(result, dbapi_cursor)
 #f not self._rowbuffer:
 #ry:
 #esult._soft_close(hard=hard_close)
 #xcept BaseException as e:
 #elf.handle_exception(result, dbapi_cursor, e)
 #eturn None
 #eturn self._rowbuffer.popleft()

 #ef fetchmany(self, result, dbapi_cursor, size=None):
 #f size is None:
 #eturn self.fetchall(result, dbapi_cursor)

 #uf = list(self._rowbuffer)
 #b = len(buf)
 #f size > lb:
 #ry:
 #uf.extend(dbapi_cursor.fetchmany(size - lb))
 #xcept BaseException as e:
 #elf.handle_exception(result, dbapi_cursor, e)

 #esult = buf[0:size]
 #elf._rowbuffer = collections.deque(buf[size:])
 #eturn result

 #ef fetchall(self, result, dbapi_cursor):
 #ry:
 #et = list(self._rowbuffer) + list(dbapi_cursor.fetchall())
 #elf._rowbuffer.clear()
 #esult._soft_close()
 #eturn ret
 #xcept BaseException as e:
 #elf.handle_exception(result, dbapi_cursor, e)


class FullyBufferedCursorFetchStrategy(CursorFetchStrategy):
 #""A cursor strategy that buffers rows fully upon creation.

 #sed for operations where a result is to be delivered
 #fter the database conversation can not be continued,
 #uch as MSSQL INSERT...OUTPUT after an autocommit.

 #""

 #_slots__ = ("_rowbuffer", "alternate_cursor_description")

 #ef __init__(
 #elf, dbapi_cursor, alternate_description=None, initial_buffer=None
 #:
 #elf.alternate_cursor_description = alternate_description
 #f initial_buffer is not None:
 #elf._rowbuffer = collections.deque(initial_buffer)
 #lse:
 #elf._rowbuffer = collections.deque(dbapi_cursor.fetchall())

 #ef yield_per(self, result, dbapi_cursor, num):
 #ass

 #ef soft_close(self, result, dbapi_cursor):
 #elf._rowbuffer.clear()
 #uper(FullyBufferedCursorFetchStrategy, self).soft_close(
 #esult, dbapi_cursor
 #

 #ef hard_close(self, result, dbapi_cursor):
 #elf._rowbuffer.clear()
 #uper(FullyBufferedCursorFetchStrategy, self).hard_close(
 #esult, dbapi_cursor
 #

 #ef fetchone(self, result, dbapi_cursor, hard_close=False):
 #f self._rowbuffer:
 #eturn self._rowbuffer.popleft()
 #lse:
 #esult._soft_close(hard=hard_close)
 #eturn None

 #ef fetchmany(self, result, dbapi_cursor, size=None):
 #f size is None:
 #eturn self.fetchall(result, dbapi_cursor)

 #uf = list(self._rowbuffer)
 #ows = buf[0:size]
 #elf._rowbuffer = collections.deque(buf[size:])
 #f not rows:
 #esult._soft_close()
 #eturn rows

 #ef fetchall(self, result, dbapi_cursor):
 #et = self._rowbuffer
 #elf._rowbuffer = collections.deque()
 #esult._soft_close()
 #eturn ret


class _NoResultMetaData(ResultMetaData):
 #_slots__ = ()

 #eturns_rows = False

 #ef _we_dont_return_rows(self, err=None):
 #til.raise_(
 #xc.ResourceClosedError(
 #This result object does not return rows. "
 #It has been closed automatically."
 #,
 #eplace_context=err,
 #

 #ef _index_for_key(self, keys, raiseerr):
 #elf._we_dont_return_rows()

 #ef _metadata_for_keys(self, key):
 #elf._we_dont_return_rows()

 #ef _reduce(self, keys):
 #elf._we_dont_return_rows()

 #property
 #ef _keymap(self):
 #elf._we_dont_return_rows()

 #property
 #ef keys(self):
 #elf._we_dont_return_rows()


class _LegacyNoResultMetaData(_NoResultMetaData):
 #property
 #ef keys(self):
 #til.warn_deprecated_20(
 #Calling the .keys() method on a result set that does not return "
 #rows is deprecated and will raise ResourceClosedError in "
 #SQLAlchemy 2.0.",
 #
 #eturn []


_NO_RESULT_METADATA = _NoResultMetaData()
_LEGACY_NO_RESULT_METADATA = _LegacyNoResultMetaData()


class BaseCursorResult(object):
 #""Base class for database result objects."""

 #ut_parameters = None
 #metadata = None
 #soft_closed = False
 #losed = False

 #ef __init__(self, context, cursor_strategy, cursor_description):
 #elf.context = context
 #elf.dialect = context.dialect
 #elf.cursor = context.cursor
 #elf.cursor_strategy = cursor_strategy
 #elf.connection = context.root_connection
 #elf._echo = echo = (
 #elf.connection._echo and context.engine._should_log_debug()
 #

 #f cursor_description is not None:
            # inline of Result._row_getter(), set up an initial row
            # getter assuming no transformations will be called as this
            # is the most common case

 #f echo:
 #og = self.context.connection._log_debug

 #ef log_row(row):
 #og("Row %r", sql_util._repr_row(row))
 #eturn row

 #elf._row_logging_fn = log_row
 #lse:
 #og_row = None

 #etadata = self._init_metadata(context, cursor_description)

 #eymap = metadata._keymap
 #rocessors = metadata._processors
 #rocess_row = self._process_row
 #ey_style = process_row._default_key_style
 #make_row = functools.partial(
 #rocess_row, metadata, processors, keymap, key_style
 #
 #f log_row:

 #ef make_row(row):
 #ade_row = _make_row(row)
 #og_row(made_row)
 #eturn made_row

 #lse:
 #ake_row = _make_row
 #elf._set_memoized_attribute("_row_getter", make_row)

 #lse:
 #elf._metadata = self._no_result_metadata

 #ef _init_metadata(self, context, cursor_description):

 #f context.compiled:
 #f context.compiled._cached_metadata:
 #etadata = self.context.compiled._cached_metadata
 #lse:
 #etadata = self._cursor_metadata(self, cursor_description)
 #f metadata._safe_for_cache:
 #ontext.compiled._cached_metadata = metadata

            # result rewrite/ adapt step.  this is to suit the case
            # when we are invoked against a cached Compiled object, we want
            # to rewrite the ResultMetaData to reflect the Column objects
            # that are in our current SQL statement object, not the one
            # that is associated with the cached Compiled object.
            # the Compiled object may also tell us to not
            # actually do this step; this is to support the ORM where
            # it is to produce a new Result object in any case, and will
            # be using the cached Column objects against this database result
            # so we don't want to rewrite them.
            #
            # Basically this step suits the use case where the end user
            # is using Core SQL expressions and is accessing columns in the
            # result row using row._mapping[table.c.column].
 #ompiled = context.compiled
 #f (
 #ompiled
 #nd compiled._result_columns
 #nd context.cache_hit is context.dialect.CACHE_HIT
 #nd not context.execution_options.get(
 #_result_disable_adapt_to_context", False
 #
 #nd compiled.statement is not context.invoked_statement
 #:
 #etadata = metadata._adapt_to_context(context)

 #elf._metadata = metadata

 #lse:
 #elf._metadata = metadata = self._cursor_metadata(
 #elf, cursor_description
 #
 #f self._echo:
 #ontext.connection._log_debug(
 #Col %r", tuple(x[0] for x in cursor_description)
 #
 #eturn metadata

 #ef _soft_close(self, hard=False):
 #""Soft close this :class:`_engine.CursorResult`.

 #his releases all DBAPI cursor resources, but leaves the
 #ursorResult "open" from a semantic perspective, meaning the
 #etchXXX() methods will continue to return empty results.

 #his method is called automatically when:

 # all result rows are exhausted using the fetchXXX() methods.
 # cursor.description is None.

 #his method is **not public**, but is documented in order to clarify
 #he "autoclose" process used.

 #. versionadded:: 1.0.0

 #. seealso::

 #meth:`_engine.CursorResult.close`


 #""

 #f (not hard and self._soft_closed) or (hard and self.closed):
 #eturn

 #f hard:
 #elf.closed = True
 #elf.cursor_strategy.hard_close(self, self.cursor)
 #lse:
 #elf.cursor_strategy.soft_close(self, self.cursor)

 #f not self._soft_closed:
 #ursor = self.cursor
 #elf.cursor = None
 #elf.connection._safe_close_cursor(cursor)
 #elf._soft_closed = True

 #property
 #ef inserted_primary_key_rows(self):
 #""Return the value of :attr:`_engine.CursorResult.inserted_primary_key`
 #s a row contained within a list; some dialects may support a
 #ultiple row form as well.

 #. note:: As indicated below, in current SQLAlchemy versions this
 #ccessor is only useful beyond what's already supplied by
 #attr:`_engine.CursorResult.inserted_primary_key` when using the
 #ref:`postgresql_psycopg2` dialect.   Future versions hope to
 #eneralize this feature to more dialects.

 #his accessor is added to support dialects that offer the feature
 #hat is currently implemented by the :ref:`psycopg2_executemany_mode`
 #eature, currently **only the psycopg2 dialect**, which provides
 #or many rows to be INSERTed at once while still retaining the
 #ehavior of being able to return server-generated primary key values.

 # **When using the psycopg2 dialect, or other dialects that may support
 #fast executemany" style inserts in upcoming releases** : When
 #nvoking an INSERT statement while passing a list of rows as the
 #econd argument to :meth:`_engine.Connection.execute`, this accessor
 #ill then provide a list of rows, where each row contains the primary
 #ey value for each row that was INSERTed.

 # **When using all other dialects / backends that don't yet support
 #his feature**: This accessor is only useful for **single row INSERT
 #tatements**, and returns the same information as that of the
 #attr:`_engine.CursorResult.inserted_primary_key` within a
 #ingle-element list. When an INSERT statement is executed in
 #onjunction with a list of rows to be INSERTed, the list will contain
 #ne row per row inserted in the statement, however it will contain
 #`None`` for any server-generated values.

 #uture releases of SQLAlchemy will further generalize the
 #fast execution helper" feature of psycopg2 to suit other dialects,
 #hus allowing this accessor to be of more general use.

 #. versionadded:: 1.4

 #. seealso::

 #attr:`_engine.CursorResult.inserted_primary_key`

 #""
 #f not self.context.compiled:
 #aise exc.InvalidRequestError(
 #Statement is not a compiled " "expression construct."
 #
 #lif not self.context.isinsert:
 #aise exc.InvalidRequestError(
 #Statement is not an insert() " "expression construct."
 #
 #lif self.context._is_explicit_returning:
 #aise exc.InvalidRequestError(
 #Can't call inserted_primary_key "
 #when returning() "
 #is used."
 #
 #eturn self.context.inserted_primary_key_rows

 #property
 #ef inserted_primary_key(self):
 #""Return the primary key for the row just inserted.

 #he return value is a :class:`_result.Row` object representing
 # named tuple of primary key values in the order in which the
 #rimary key columns are configured in the source
 #class:`_schema.Table`.

 #. versionchanged:: 1.4.8 - the
 #attr:`_engine.CursorResult.inserted_primary_key`
 #alue is now a named tuple via the :class:`_result.Row` class,
 #ather than a plain tuple.

 #his accessor only applies to single row :func:`_expression.insert`
 #onstructs which did not explicitly specify
 #meth:`_expression.Insert.returning`.    Support for multirow inserts,
 #hile not yet available for most backends, would be accessed using
 #he :attr:`_engine.CursorResult.inserted_primary_key_rows` accessor.

 #ote that primary key columns which specify a server_default clause, or
 #therwise do not qualify as "autoincrement" columns (see the notes at
 #class:`_schema.Column`), and were generated using the database-side
 #efault, will appear in this list as ``None`` unless the backend
 #upports "returning" and the insert statement executed with the
 #implicit returning" enabled.

 #aises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
 #tatement is not a compiled expression construct
 #r is not an insert() construct.

 #""

 #f self.context.executemany:
 #aise exc.InvalidRequestError(
 #This statement was an executemany call; if primary key "
 #returning is supported, please "
 #use .inserted_primary_key_rows."
 #

 #kp = self.inserted_primary_key_rows
 #f ikp:
 #eturn ikp[0]
 #lse:
 #eturn None

 #ef last_updated_params(self):
 #""Return the collection of updated parameters from this
 #xecution.

 #aises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
 #tatement is not a compiled expression construct
 #r is not an update() construct.

 #""
 #f not self.context.compiled:
 #aise exc.InvalidRequestError(
 #Statement is not a compiled " "expression construct."
 #
 #lif not self.context.isupdate:
 #aise exc.InvalidRequestError(
 #Statement is not an update() " "expression construct."
 #
 #lif self.context.executemany:
 #eturn self.context.compiled_parameters
 #lse:
 #eturn self.context.compiled_parameters[0]

 #ef last_inserted_params(self):
 #""Return the collection of inserted parameters from this
 #xecution.

 #aises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
 #tatement is not a compiled expression construct
 #r is not an insert() construct.

 #""
 #f not self.context.compiled:
 #aise exc.InvalidRequestError(
 #Statement is not a compiled " "expression construct."
 #
 #lif not self.context.isinsert:
 #aise exc.InvalidRequestError(
 #Statement is not an insert() " "expression construct."
 #
 #lif self.context.executemany:
 #eturn self.context.compiled_parameters
 #lse:
 #eturn self.context.compiled_parameters[0]

 #property
 #ef returned_defaults_rows(self):
 #""Return a list of rows each containing the values of default
 #olumns that were fetched using
 #he :meth:`.ValuesBase.return_defaults` feature.

 #he return value is a list of :class:`.Row` objects.

 #. versionadded:: 1.4

 #""
 #eturn self.context.returned_default_rows

 #property
 #ef returned_defaults(self):
 #""Return the values of default columns that were fetched using
 #he :meth:`.ValuesBase.return_defaults` feature.

 #he value is an instance of :class:`.Row`, or ``None``
 #f :meth:`.ValuesBase.return_defaults` was not used or if the
 #ackend does not support RETURNING.

 #. versionadded:: 0.9.0

 #. seealso::

 #meth:`.ValuesBase.return_defaults`

 #""

 #f self.context.executemany:
 #aise exc.InvalidRequestError(
 #This statement was an executemany call; if return defaults "
 #is supported, please use .returned_defaults_rows."
 #

 #ows = self.context.returned_default_rows
 #f rows:
 #eturn rows[0]
 #lse:
 #eturn None

 #ef lastrow_has_defaults(self):
 #""Return ``lastrow_has_defaults()`` from the underlying
 #class:`.ExecutionContext`.

 #ee :class:`.ExecutionContext` for details.

 #""

 #eturn self.context.lastrow_has_defaults()

 #ef postfetch_cols(self):
 #""Return ``postfetch_cols()`` from the underlying
 #class:`.ExecutionContext`.

 #ee :class:`.ExecutionContext` for details.

 #aises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
 #tatement is not a compiled expression construct
 #r is not an insert() or update() construct.

 #""

 #f not self.context.compiled:
 #aise exc.InvalidRequestError(
 #Statement is not a compiled " "expression construct."
 #
 #lif not self.context.isinsert and not self.context.isupdate:
 #aise exc.InvalidRequestError(
 #Statement is not an insert() or update() "
 #expression construct."
 #
 #eturn self.context.postfetch_cols

 #ef prefetch_cols(self):
 #""Return ``prefetch_cols()`` from the underlying
 #class:`.ExecutionContext`.

 #ee :class:`.ExecutionContext` for details.

 #aises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
 #tatement is not a compiled expression construct
 #r is not an insert() or update() construct.

 #""

 #f not self.context.compiled:
 #aise exc.InvalidRequestError(
 #Statement is not a compiled " "expression construct."
 #
 #lif not self.context.isinsert and not self.context.isupdate:
 #aise exc.InvalidRequestError(
 #Statement is not an insert() or update() "
 #expression construct."
 #
 #eturn self.context.prefetch_cols

 #ef supports_sane_rowcount(self):
 #""Return ``supports_sane_rowcount`` from the dialect.

 #ee :attr:`_engine.CursorResult.rowcount` for background.

 #""

 #eturn self.dialect.supports_sane_rowcount

 #ef supports_sane_multi_rowcount(self):
 #""Return ``supports_sane_multi_rowcount`` from the dialect.

 #ee :attr:`_engine.CursorResult.rowcount` for background.

 #""

 #eturn self.dialect.supports_sane_multi_rowcount

 #util.memoized_property
 #ef rowcount(self):
 #""Return the 'rowcount' for this result.

 #he 'rowcount' reports the number of rows *matched*
 #y the WHERE criterion of an UPDATE or DELETE statement.

 #. note::

 #otes regarding :attr:`_engine.CursorResult.rowcount`:


 # This attribute returns the number of rows *matched*,
 #hich is not necessarily the same as the number of rows
 #hat were actually *modified* - an UPDATE statement, for example,
 #ay have no net change on a given row if the SET values
 #iven are the same as those present in the row already.
 #uch a row would be matched but not modified.
 #n backends that feature both styles, such as MySQL,
 #owcount is configured by default to return the match
 #ount in all cases.

 # :attr:`_engine.CursorResult.rowcount`
 #s *only* useful in conjunction
 #ith an UPDATE or DELETE statement.  Contrary to what the Python
 #BAPI says, it does *not* return the
 #umber of rows available from the results of a SELECT statement
 #s DBAPIs cannot support this functionality when rows are
 #nbuffered.

 # :attr:`_engine.CursorResult.rowcount`
 #ay not be fully implemented by
 #ll dialects.  In particular, most DBAPIs do not support an
 #ggregate rowcount result from an executemany call.
 #he :meth:`_engine.CursorResult.supports_sane_rowcount` and
 #meth:`_engine.CursorResult.supports_sane_multi_rowcount` methods
 #ill report from the dialect if each usage is known to be
 #upported.

 # Statements that use RETURNING may not return a correct
 #owcount.

 #. seealso::

 #ref:`tutorial_update_delete_rowcount` - in the :ref:`unified_tutorial`

 #""  # noqa E501

 #ry:
 #eturn self.context.rowcount
 #xcept BaseException as e:
 #elf.cursor_strategy.handle_exception(self, self.cursor, e)

 #property
 #ef lastrowid(self):
 #""Return the 'lastrowid' accessor on the DBAPI cursor.

 #his is a DBAPI specific method and is only functional
 #or those backends which support it, for statements
 #here it is appropriate.  It's behavior is not
 #onsistent across backends.

 #sage of this method is normally unnecessary when
 #sing insert() expression constructs; the
 #attr:`~CursorResult.inserted_primary_key` attribute provides a
 #uple of primary key values for a newly inserted row,
 #egardless of database backend.

 #""
 #ry:
 #eturn self.context.get_lastrowid()
 #xcept BaseException as e:
 #elf.cursor_strategy.handle_exception(self, self.cursor, e)

 #property
 #ef returns_rows(self):
 #""True if this :class:`_engine.CursorResult` returns zero or more rows.

 #.e. if it is legal to call the methods
 #meth:`_engine.CursorResult.fetchone`,
 #meth:`_engine.CursorResult.fetchmany`
 #meth:`_engine.CursorResult.fetchall`.

 #verall, the value of :attr:`_engine.CursorResult.returns_rows` should
 #lways be synonymous with whether or not the DBAPI cursor had a
 #`.description`` attribute, indicating the presence of result columns,
 #oting that a cursor that returns zero rows still has a
 #`.description`` if a row-returning statement was emitted.

 #his attribute should be True for all results that are against
 #ELECT statements, as well as for DML statements INSERT/UPDATE/DELETE
 #hat use RETURNING.   For INSERT/UPDATE/DELETE statements that were
 #ot using RETURNING, the value will usually be False, however
 #here are some dialect-specific exceptions to this, such as when
 #sing the MSSQL / pyodbc dialect a SELECT is emitted inline in
 #rder to retrieve an inserted primary key value.


 #""
 #eturn self._metadata.returns_rows

 #property
 #ef is_insert(self):
 #""True if this :class:`_engine.CursorResult` is the result
 #f a executing an expression language compiled
 #func:`_expression.insert` construct.

 #hen True, this implies that the
 #attr:`inserted_primary_key` attribute is accessible,
 #ssuming the statement did not include
 # user defined "returning" construct.

 #""
 #eturn self.context.isinsert


class CursorResult(BaseCursorResult, Result):
 #""A Result that is representing state from a DBAPI cursor.

 #. versionchanged:: 1.4  The :class:`.CursorResult` and
 #class:`.LegacyCursorResult`
 #lasses replace the previous :class:`.ResultProxy` interface.
 #hese classes are based on the :class:`.Result` calling API
 #hich provides an updated usage model and calling facade for
 #QLAlchemy Core and SQLAlchemy ORM.

 #eturns database rows via the :class:`.Row` class, which provides
 #dditional API features and behaviors on top of the raw data returned by
 #he DBAPI.   Through the use of filters such as the :meth:`.Result.scalars`
 #ethod, other kinds of objects may also be returned.

 #ithin the scope of the 1.x series of SQLAlchemy, Core SQL results in
 #ersion 1.4 return an instance of :class:`._engine.LegacyCursorResult`
 #hich takes the place of the ``CursorResult`` class used for the 1.3 series
 #nd previously.  This object returns rows as :class:`.LegacyRow` objects,
 #hich maintains Python mapping (i.e. dictionary) like behaviors upon the
 #bject itself.  Going forward, the :attr:`.Row._mapping` attribute should
 #e used for dictionary behaviors.

 #. seealso::

 #ref:`coretutorial_selecting` - introductory material for accessing
 #class:`_engine.CursorResult` and :class:`.Row` objects.

 #""

 #cursor_metadata = CursorResultMetaData
 #cursor_strategy_cls = CursorFetchStrategy
 #no_result_metadata = _NO_RESULT_METADATA

 #ef _fetchiter_impl(self):
 #etchone = self.cursor_strategy.fetchone

 #hile True:
 #ow = fetchone(self, self.cursor)
 #f row is None:
 #reak
 #ield row

 #ef _fetchone_impl(self, hard_close=False):
 #eturn self.cursor_strategy.fetchone(self, self.cursor, hard_close)

 #ef _fetchall_impl(self):
 #eturn self.cursor_strategy.fetchall(self, self.cursor)

 #ef _fetchmany_impl(self, size=None):
 #eturn self.cursor_strategy.fetchmany(self, self.cursor, size)

 #ef _raw_row_iterator(self):
 #eturn self._fetchiter_impl()

 #ef merge(self, *others):
 #erged_result = super(CursorResult, self).merge(*others)
 #etup_rowcounts = not self._metadata.returns_rows
 #f setup_rowcounts:
 #erged_result.rowcount = sum(
 #esult.rowcount for result in (self,) + others
 #
 #eturn merged_result

 #ef close(self):
 #""Close this :class:`_engine.CursorResult`.

 #his closes out the underlying DBAPI cursor corresponding to the
 #tatement execution, if one is still present.  Note that the DBAPI
 #ursor is automatically released when the :class:`_engine.CursorResult`
 #xhausts all available rows.  :meth:`_engine.CursorResult.close` is
 #enerally an optional method except in the case when discarding a
 #class:`_engine.CursorResult` that still has additional rows pending
 #or fetch.

 #fter this method is called, it is no longer valid to call upon
 #he fetch methods, which will raise a :class:`.ResourceClosedError`
 #n subsequent use.

 #. seealso::

 #ref:`connections_toplevel`

 #""
 #elf._soft_close(hard=True)

 #_generative
 #ef yield_per(self, num):
 #elf._yield_per = num
 #elf.cursor_strategy.yield_per(self, self.cursor, num)


class LegacyCursorResult(CursorResult):
 #""Legacy version of :class:`.CursorResult`.

 #his class includes connection "connection autoclose" behavior for use with
 #connectionless" execution, as well as delivers rows using the
 #class:`.LegacyRow` row implementation.

 #. versionadded:: 1.4

 #""

 #autoclose_connection = False
 #process_row = LegacyRow
 #cursor_metadata = LegacyCursorResultMetaData
 #cursor_strategy_cls = CursorFetchStrategy

 #no_result_metadata = _LEGACY_NO_RESULT_METADATA

 #ef close(self):
 #""Close this :class:`_engine.LegacyCursorResult`.

 #his method has the same behavior as that of
 #meth:`._engine.CursorResult`, but it also may close
 #he underlying :class:`.Connection` for the case of "connectionless"
 #xecution.

 #. deprecated:: 2.0 "connectionless" execution is deprecated and will
 #e removed in version 2.0.   Version 2.0 will feature the
 #class:`_future.Result`
 #bject that will no longer affect the status
 #f the originating connection in any case.

 #fter this method is called, it is no longer valid to call upon
 #he fetch methods, which will raise a :class:`.ResourceClosedError`
 #n subsequent use.

 #. seealso::

 #ref:`connections_toplevel`

 #ref:`dbengine_implicit`
 #""
 #elf._soft_close(hard=True)

 #ef _soft_close(self, hard=False):
 #oft_closed = self._soft_closed
 #uper(LegacyCursorResult, self)._soft_close(hard=hard)
 #f (
 #ot soft_closed
 #nd self._soft_closed
 #nd self._autoclose_connection
 #:
 #elf.connection.close()


ResultProxy = LegacyCursorResult


class BufferedRowResultProxy(ResultProxy):
 #""A ResultProxy with row buffering behavior.

 #. deprecated::  1.4 this class is now supplied using a strategy object.
 #ee :class:`.BufferedRowCursorFetchStrategy`.

 #""

 #cursor_strategy_cls = BufferedRowCursorFetchStrategy


class FullyBufferedResultProxy(ResultProxy):
 #""A result proxy that buffers rows fully upon creation.

 #. deprecated::  1.4 this class is now supplied using a strategy object.
 #ee :class:`.FullyBufferedCursorFetchStrategy`.

 #""

 #cursor_strategy_cls = FullyBufferedCursorFetchStrategy


class BufferedColumnRow(LegacyRow):
 #""Row is now BufferedColumn in all cases"""


class BufferedColumnResultProxy(ResultProxy):
 #""A ResultProxy with column buffering behavior.

 #. versionchanged:: 1.4   This is now the default behavior of the Row
 #nd this class does not change behavior in any way.

 #""

 #process_row = BufferedColumnRow
