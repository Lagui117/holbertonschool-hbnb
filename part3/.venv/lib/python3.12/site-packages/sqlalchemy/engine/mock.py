# engine/mock.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from operator import attrgetter

from . import base
from . import url as _url
from .. import util
from ..sql import ddl


class MockConnection(base.Connectable):
 #ef __init__(self, dialect, execute):
 #elf._dialect = dialect
 #elf.execute = execute

 #ngine = property(lambda s: s)
 #ialect = property(attrgetter("_dialect"))
 #ame = property(lambda s: s._dialect.name)

 #ef schema_for_object(self, obj):
 #eturn obj.schema

 #ef connect(self, **kwargs):
 #eturn self

 #ef execution_options(self, **kw):
 #eturn self

 #ef compiler(self, statement, parameters, **kwargs):
 #eturn self._dialect.compiler(
 #tatement, parameters, engine=self, **kwargs
 #

 #ef create(self, entity, **kwargs):
 #wargs["checkfirst"] = False

 #dl.SchemaGenerator(self.dialect, self, **kwargs).traverse_single(
 #ntity
 #

 #ef drop(self, entity, **kwargs):
 #wargs["checkfirst"] = False

 #dl.SchemaDropper(self.dialect, self, **kwargs).traverse_single(entity)

 #ef _run_ddl_visitor(
 #elf, visitorcallable, element, connection=None, **kwargs
 #:
 #wargs["checkfirst"] = False
 #isitorcallable(self.dialect, self, **kwargs).traverse_single(element)

 #ef execute(self, object_, *multiparams, **params):
 #aise NotImplementedError()


def create_mock_engine(url, executor, **kw):
 #""Create a "mock" engine used for echoing DDL.

 #his is a utility function used for debugging or storing the output of DDL
 #equences as generated by :meth:`_schema.MetaData.create_all`
 #nd related methods.

 #he function accepts a URL which is used only to determine the kind of
 #ialect to be used, as well as an "executor" callable function which
 #ill receive a SQL expression object and parameters, which can then be
 #choed or otherwise printed.   The executor's return value is not handled,
 #or does the engine allow regular string statements to be invoked, and
 #s therefore only useful for DDL that is sent to the database without
 #eceiving any results.

 #.g.::

 #rom sqlalchemy import create_mock_engine

 #ef dump(sql, *multiparams, **params):
 #rint(sql.compile(dialect=engine.dialect))

 #ngine = create_mock_engine('postgresql://', dump)
 #etadata.create_all(engine, checkfirst=False)

 #param url: A string URL which typically needs to contain only the
 #atabase backend name.

 #param executor: a callable which receives the arguments ``sql``,
 #`*multiparams`` and ``**params``.  The ``sql`` parameter is typically
 #n instance of :class:`.DDLElement`, which can then be compiled into a
 #tring using :meth:`.DDLElement.compile`.

 #. versionadded:: 1.4 - the :func:`.create_mock_engine` function replaces
 #he previous "mock" engine strategy used with
 #func:`_sa.create_engine`.

 #. seealso::

 #ref:`faq_ddl_as_string`

 #""

    # create url.URL object
 # = _url.make_url(url)

 #ialect_cls = u.get_dialect()

 #ialect_args = {}
    # consume dialect arguments from kwargs
 #or k in util.get_cls_kwargs(dialect_cls):
 #f k in kw:
 #ialect_args[k] = kw.pop(k)

    # create dialect
 #ialect = dialect_cls(**dialect_args)

 #eturn MockConnection(dialect, executor)
