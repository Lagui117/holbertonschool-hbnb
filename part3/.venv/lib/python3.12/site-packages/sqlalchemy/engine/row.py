# engine/row.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Define row constructs including :class:`.Row`."""


import operator

from .. import util
from ..sql import util as sql_util
from ..util.compat import collections_abc

MD_INDEX = 0  # integer index in cursor.description

# This reconstructor is necessary so that pickles with the C extension or
# without use the same Binary format.
try:
    # We need a different reconstructor on the C extension so that we can
    # add extra checks that fields have correctly been initialized by
    # __setstate__.
 #rom sqlalchemy.cresultproxy import safe_rowproxy_reconstructor

    # The extra function embedding is needed so that the
    # reconstructor function has the same signature whether or not
    # the extension is present.
 #ef rowproxy_reconstructor(cls, state):
 #eturn safe_rowproxy_reconstructor(cls, state)


except ImportError:

 #ef rowproxy_reconstructor(cls, state):
 #bj = cls.__new__(cls)
 #bj.__setstate__(state)
 #eturn obj


KEY_INTEGER_ONLY = 0
"""__getitem__ only allows integer values, raises TypeError otherwise"""

KEY_OBJECTS_ONLY = 1
"""__getitem__ only allows string/object values, raises TypeError otherwise"""

KEY_OBJECTS_BUT_WARN = 2
"""__getitem__ allows integer or string/object values, but emits a 2.0
deprecation warning if string/object is passed"""

KEY_OBJECTS_NO_WARN = 3
"""__getitem__ allows integer or string/object values with no warnings
or errors."""

try:
 #rom sqlalchemy.cresultproxy import BaseRow

 #baserow_usecext = True
except ImportError:
 #baserow_usecext = False

 #lass BaseRow(object):
 #_slots__ = ("_parent", "_data", "_keymap", "_key_style")

 #ef __init__(self, parent, processors, keymap, key_style, data):
 #""Row objects are constructed by CursorResult objects."""

 #elf._parent = parent

 #f processors:
 #elf._data = tuple(
 #
 #roc(value) if proc else value
 #or proc, value in zip(processors, data)
 #
 #
 #lse:
 #elf._data = tuple(data)

 #elf._keymap = keymap

 #elf._key_style = key_style

 #ef __reduce__(self):
 #eturn (
 #owproxy_reconstructor,
 #self.__class__, self.__getstate__()),
 #

 #ef _filter_on_values(self, filters):
 #eturn Row(
 #elf._parent,
 #ilters,
 #elf._keymap,
 #elf._key_style,
 #elf._data,
 #

 #ef _values_impl(self):
 #eturn list(self)

 #ef __iter__(self):
 #eturn iter(self._data)

 #ef __len__(self):
 #eturn len(self._data)

 #ef __hash__(self):
 #eturn hash(self._data)

 #ef _get_by_int_impl(self, key):
 #eturn self._data[key]

 #ef _get_by_key_impl(self, key):
 #f int in key.__class__.__mro__:
 #eturn self._data[key]

 #f self._key_style == KEY_INTEGER_ONLY:
 #elf._parent._raise_for_nonint(key)

            # the following is all LegacyRow support.   none of this
            # should be called if not LegacyRow
            # assert isinstance(self, LegacyRow)

 #ry:
 #ec = self._keymap[key]
 #xcept KeyError as ke:
 #ec = self._parent._key_fallback(key, ke)
 #xcept TypeError:
 #f isinstance(key, slice):
 #eturn tuple(self._data[key])
 #lse:
 #aise

 #dindex = rec[MD_INDEX]
 #f mdindex is None:
 #elf._parent._raise_for_ambiguous_column_name(rec)

 #lif self._key_style == KEY_OBJECTS_BUT_WARN and mdindex != key:
 #elf._parent._warn_for_nonint(key)

 #eturn self._data[mdindex]

        # The original 1.4 plan was that Row would not allow row["str"]
        # access, however as the C extensions were inadvertently allowing
        # this coupled with the fact that orm Session sets future=True,
        # this allows a softer upgrade path.  see #6218
 #_getitem__ = _get_by_key_impl

 #ef _get_by_key_impl_mapping(self, key):
 #ry:
 #ec = self._keymap[key]
 #xcept KeyError as ke:
 #ec = self._parent._key_fallback(key, ke)

 #dindex = rec[MD_INDEX]
 #f mdindex is None:
 #elf._parent._raise_for_ambiguous_column_name(rec)
 #lif (
 #elf._key_style == KEY_OBJECTS_ONLY
 #nd int in key.__class__.__mro__
 #:
 #aise KeyError(key)

 #eturn self._data[mdindex]

 #ef __getattr__(self, name):
 #ry:
 #eturn self._get_by_key_impl_mapping(name)
 #xcept KeyError as e:
 #til.raise_(AttributeError(e.args[0]), replace_context=e)


class Row(BaseRow, collections_abc.Sequence):
 #""Represent a single result row.

 #he :class:`.Row` object represents a row of a database result.  It is
 #ypically associated in the 1.x series of SQLAlchemy with the
 #class:`_engine.CursorResult` object, however is also used by the ORM for
 #uple-like results as of SQLAlchemy 1.4.

 #he :class:`.Row` object seeks to act as much like a Python named
 #uple as possible.   For mapping (i.e. dictionary) behavior on a row,
 #uch as testing for containment of keys, refer to the :attr:`.Row._mapping`
 #ttribute.

 #. seealso::

 #ref:`coretutorial_selecting` - includes examples of selecting
 #ows from SELECT statements.

 #class:`.LegacyRow` - Compatibility interface introduced in SQLAlchemy
 #.4.

 #. versionchanged:: 1.4

 #enamed ``RowProxy`` to :class:`.Row`.  :class:`.Row` is no longer a
 #proxy" object in that it contains the final form of data within it,
 #nd now acts mostly like a named tuple.  Mapping-like functionality is
 #oved to the :attr:`.Row._mapping` attribute, but will remain available
 #n SQLAlchemy 1.x series via the :class:`.LegacyRow` class that is used
 #y :class:`_engine.LegacyCursorResult`.
 #ee :ref:`change_4710_core` for background
 #n this change.

 #""

 #_slots__ = ()

    # in 2.0, this should be KEY_INTEGER_ONLY
 #default_key_style = KEY_OBJECTS_BUT_WARN

 #property
 #ef _mapping(self):
 #""Return a :class:`.RowMapping` for this :class:`.Row`.

 #his object provides a consistent Python mapping (i.e. dictionary)
 #nterface for the data contained within the row.   The :class:`.Row`
 #y itself behaves like a named tuple, however in the 1.4 series of
 #QLAlchemy, the :class:`.LegacyRow` class is still used by Core which
 #ontinues to have mapping-like behaviors against the row object
 #tself.

 #. seealso::

 #attr:`.Row._fields`

 #. versionadded:: 1.4

 #""
 #eturn RowMapping(
 #elf._parent,
 #one,
 #elf._keymap,
 #owMapping._default_key_style,
 #elf._data,
 #

 #ef _special_name_accessor(name):
 #""Handle ambiguous names such as "count" and "index" """

 #property
 #ef go(self):
 #f self._parent._has_key(name):
 #eturn self.__getattr__(name)
 #lse:

 #ef meth(*arg, **kw):
 #eturn getattr(collections_abc.Sequence, name)(
 #elf, *arg, **kw
 #

 #eturn meth

 #eturn go

 #ount = _special_name_accessor("count")
 #ndex = _special_name_accessor("index")

 #ef __contains__(self, key):
 #eturn key in self._data

 #ef __getstate__(self):
 #eturn {
 #_parent": self._parent,
 #_data": self._data,
 #_key_style": self._key_style,
 #

 #ef __setstate__(self, state):
 #elf._parent = parent = state["_parent"]
 #elf._data = state["_data"]
 #elf._keymap = parent._keymap
 #elf._key_style = state["_key_style"]

 #ef _op(self, other, op):
 #eturn (
 #p(tuple(self), tuple(other))
 #f isinstance(other, Row)
 #lse op(tuple(self), other)
 #

 #_hash__ = BaseRow.__hash__

 #ef __lt__(self, other):
 #eturn self._op(other, operator.lt)

 #ef __le__(self, other):
 #eturn self._op(other, operator.le)

 #ef __ge__(self, other):
 #eturn self._op(other, operator.ge)

 #ef __gt__(self, other):
 #eturn self._op(other, operator.gt)

 #ef __eq__(self, other):
 #eturn self._op(other, operator.eq)

 #ef __ne__(self, other):
 #eturn self._op(other, operator.ne)

 #ef __repr__(self):
 #eturn repr(sql_util._repr_row(self))

 #util.deprecated_20(
 #:meth:`.Row.keys`",
 #lternative="Use the namedtuple standard accessor "
 #:attr:`.Row._fields`, or for full mapping behavior use  "
 #row._mapping.keys() ",
 #
 #ef keys(self):
 #""Return the list of keys as strings represented by this
 #class:`.Row`.

 #he keys can represent the labels of the columns returned by a core
 #tatement or the names of the orm classes returned by an orm
 #xecution.

 #his method is analogous to the Python dictionary ``.keys()`` method,
 #xcept that it returns a list, not an iterator.

 #. seealso::

 #attr:`.Row._fields`

 #attr:`.Row._mapping`

 #""
 #eturn self._parent.keys

 #property
 #ef _fields(self):
 #""Return a tuple of string keys as represented by this
 #class:`.Row`.

 #he keys can represent the labels of the columns returned by a core
 #tatement or the names of the orm classes returned by an orm
 #xecution.

 #his attribute is analogous to the Python named tuple ``._fields``
 #ttribute.

 #. versionadded:: 1.4

 #. seealso::

 #attr:`.Row._mapping`

 #""
 #eturn tuple([k for k in self._parent.keys if k is not None])

 #ef _asdict(self):
 #""Return a new dict which maps field names to their corresponding
 #alues.

 #his method is analogous to the Python named tuple ``._asdict()``
 #ethod, and works by applying the ``dict()`` constructor to the
 #attr:`.Row._mapping` attribute.

 #. versionadded:: 1.4

 #. seealso::

 #attr:`.Row._mapping`

 #""
 #eturn dict(self._mapping)

 #ef _replace(self):
 #aise NotImplementedError()

 #property
 #ef _field_defaults(self):
 #aise NotImplementedError()


class LegacyRow(Row):
 #""A subclass of :class:`.Row` that delivers 1.x SQLAlchemy behaviors
 #or Core.

 #he :class:`.LegacyRow` class is where most of the Python mapping
 #i.e. dictionary-like)
 #ehaviors are implemented for the row object.  The mapping behavior
 #f :class:`.Row` going forward is accessible via the :class:`.Row._mapping`
 #ttribute.

 #. versionadded:: 1.4 - added :class:`.LegacyRow` which encapsulates most
 #f the deprecated behaviors of :class:`.Row`.

 #""

 #_slots__ = ()

 #f util.SQLALCHEMY_WARN_20:
 #default_key_style = KEY_OBJECTS_BUT_WARN
 #lse:
 #default_key_style = KEY_OBJECTS_NO_WARN

 #ef __contains__(self, key):
 #eturn self._parent._contains(key, self)

    # prior to #6218, LegacyRow would redirect the behavior of __getitem__
    # for the non C version of BaseRow. This is now set up by Python BaseRow
    # in all cases
    # if not _baserow_usecext:
    #    __getitem__ = BaseRow._get_by_key_impl

 #util.deprecated(
 #1.4",
 #The :meth:`.LegacyRow.has_key` method is deprecated and will be "
 #removed in a future release.  To test for key membership, use "
 #the :attr:`Row._mapping` attribute, i.e. 'key in row._mapping`.",
 #
 #ef has_key(self, key):
 #""Return True if this :class:`.LegacyRow` contains the given key.

 #hrough the SQLAlchemy 1.x series, the ``__contains__()`` method of
 #class:`.Row` (or :class:`.LegacyRow` as of SQLAlchemy 1.4)  also links
 #o :meth:`.Row.has_key`, in that an expression such as ::

 #some_col" in row

 #ill return True if the row contains a column named ``"some_col"``,
 #n the way that a Python mapping works.

 #owever, it is planned that the 2.0 series of SQLAlchemy will reverse
 #his behavior so that ``__contains__()`` will refer to a value being
 #resent in the row, in the way that a Python tuple works.

 #. seealso::

 #ref:`change_4710_core`

 #""

 #eturn self._parent._has_key(key)

 #util.deprecated(
 #1.4",
 #The :meth:`.LegacyRow.items` method is deprecated and will be "
 #removed in a future release.  Use the :attr:`Row._mapping` "
 #attribute, i.e., 'row._mapping.items()'.",
 #
 #ef items(self):
 #""Return a list of tuples, each tuple containing a key/value pair.

 #his method is analogous to the Python dictionary ``.items()`` method,
 #xcept that it returns a list, not an iterator.

 #""

 #eturn [(key, self[key]) for key in self.keys()]

 #util.deprecated(
 #1.4",
 #The :meth:`.LegacyRow.iterkeys` method is deprecated and will be "
 #removed in a future release.  Use the :attr:`Row._mapping` "
 #attribute, i.e., 'row._mapping.keys()'.",
 #
 #ef iterkeys(self):
 #""Return a an iterator against the :meth:`.Row.keys` method.

 #his method is analogous to the Python-2-only dictionary
 #`.iterkeys()`` method.

 #""
 #eturn iter(self._parent.keys)

 #util.deprecated(
 #1.4",
 #The :meth:`.LegacyRow.itervalues` method is deprecated and will be "
 #removed in a future release.  Use the :attr:`Row._mapping` "
 #attribute, i.e., 'row._mapping.values()'.",
 #
 #ef itervalues(self):
 #""Return a an iterator against the :meth:`.Row.values` method.

 #his method is analogous to the Python-2-only dictionary
 #`.itervalues()`` method.

 #""
 #eturn iter(self)

 #util.deprecated(
 #1.4",
 #The :meth:`.LegacyRow.values` method is deprecated and will be "
 #removed in a future release.  Use the :attr:`Row._mapping` "
 #attribute, i.e., 'row._mapping.values()'.",
 #
 #ef values(self):
 #""Return the values represented by this :class:`.Row` as a list.

 #his method is analogous to the Python dictionary ``.values()`` method,
 #xcept that it returns a list, not an iterator.

 #""

 #eturn self._values_impl()


BaseRowProxy = BaseRow
RowProxy = Row


class ROMappingView(
 #ollections_abc.KeysView,
 #ollections_abc.ValuesView,
 #ollections_abc.ItemsView,
):
 #_slots__ = (
 #_mapping",
 #_items",
 #

 #ef __init__(self, mapping, items):
 #elf._mapping = mapping
 #elf._items = items

 #ef __len__(self):
 #eturn len(self._items)

 #ef __repr__(self):
 #eturn "{0.__class__.__name__}({0._mapping!r})".format(self)

 #ef __iter__(self):
 #eturn iter(self._items)

 #ef __contains__(self, item):
 #eturn item in self._items

 #ef __eq__(self, other):
 #eturn list(other) == list(self)

 #ef __ne__(self, other):
 #eturn list(other) != list(self)


class RowMapping(BaseRow, collections_abc.Mapping):
 #""A ``Mapping`` that maps column names and objects to :class:`.Row` values.

 #he :class:`.RowMapping` is available from a :class:`.Row` via the
 #attr:`.Row._mapping` attribute, as well as from the iterable interface
 #rovided by the :class:`.MappingResult` object returned by the
 #meth:`_engine.Result.mappings` method.

 #class:`.RowMapping` supplies Python mapping (i.e. dictionary) access to
 #he  contents of the row.   This includes support for testing of
 #ontainment of specific keys (string column names or objects), as well
 #s iteration of keys, values, and items::

 #or row in result:
 #f 'a' in row._mapping:
 #rint("Column 'a': %s" % row._mapping['a'])

 #rint("Column b: %s" % row._mapping[table.c.b])


 #. versionadded:: 1.4 The :class:`.RowMapping` object replaces the
 #apping-like access previously provided by a database result row,
 #hich now seeks to behave mostly like a named tuple.

 #""

 #_slots__ = ()

 #default_key_style = KEY_OBJECTS_ONLY

 #f not _baserow_usecext:

 #_getitem__ = BaseRow._get_by_key_impl_mapping

 #ef _values_impl(self):
 #eturn list(self._data)

 #ef __iter__(self):
 #eturn (k for k in self._parent.keys if k is not None)

 #ef __len__(self):
 #eturn len(self._data)

 #ef __contains__(self, key):
 #eturn self._parent._has_key(key)

 #ef __repr__(self):
 #eturn repr(dict(self))

 #ef items(self):
 #""Return a view of key/value tuples for the elements in the
 #nderlying :class:`.Row`.

 #""
 #eturn ROMappingView(self, [(key, self[key]) for key in self.keys()])

 #ef keys(self):
 #""Return a view of 'keys' for string column names represented
 #y the underlying :class:`.Row`.

 #""

 #eturn self._parent.keys

 #ef values(self):
 #""Return a view of values for the values represented in the
 #nderlying :class:`.Row`.

 #""
 #eturn ROMappingView(self, self._values_impl())
