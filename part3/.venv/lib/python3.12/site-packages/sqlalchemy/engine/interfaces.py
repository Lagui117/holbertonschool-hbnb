# engine/interfaces.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Define core interfaces used by the engine system."""

from .. import util
from ..sql.compiler import Compiled  # noqa
from ..sql.compiler import TypeCompiler  # noqa


class Dialect(object):
 #""Define the behavior of a specific database and DB-API combination.

 #ny aspect of metadata definition, SQL query generation,
 #xecution, result-set handling, or anything else which varies
 #etween databases is defined under the general category of the
 #ialect.  The Dialect acts as a factory for other
 #atabase-specific object implementations including
 #xecutionContext, Compiled, DefaultGenerator, and TypeEngine.

 #. note:: Third party dialects should not subclass :class:`.Dialect`
 #irectly.  Instead, subclass :class:`.default.DefaultDialect` or
 #escendant class.

 #ll dialects include the following attributes.   There are many other
 #ttributes that may be supported as well:

 #`name``
 #dentifying name for the dialect from a DBAPI-neutral point of view
 #i.e. 'sqlite')

 #`driver``
 #dentifying name for the dialect's DBAPI

 #`positional``
 #rue if the paramstyle for this Dialect is positional.

 #`paramstyle``
 #he paramstyle to be used (some DB-APIs support multiple
 #aramstyles).

 #`encoding``
 #ype of encoding to use for unicode, usually defaults to
 #utf-8'.

 #`statement_compiler``
 # :class:`.Compiled` class used to compile SQL statements

 #`ddl_compiler``
 # :class:`.Compiled` class used to compile DDL statements

 #`server_version_info``
 # tuple containing a version number for the DB backend in use.
 #his value is only available for supporting dialects, and is
 #ypically populated during the initial connection to the database.

 #`default_schema_name``
 #he name of the default schema.  This value is only available for
 #upporting dialects, and is typically populated during the
 #nitial connection to the database.

 #`execution_ctx_cls``
 # :class:`.ExecutionContext` class used to handle statement execution

 #`execute_sequence_format``
 #ither the 'tuple' or 'list' type, depending on what cursor.execute()
 #ccepts for the second argument (they vary).

 #`preparer``
 # :class:`~sqlalchemy.sql.compiler.IdentifierPreparer` class used to
 #uote identifiers.

 #`supports_alter``
 #`True`` if the database supports ``ALTER TABLE`` - used only for
 #enerating foreign key constraints in certain circumstances

 #`max_identifier_length``
 #he maximum length of identifier names.

 #`supports_sane_rowcount``
 #ndicate whether the dialect properly implements rowcount for
 #`UPDATE`` and ``DELETE`` statements.

 #`supports_sane_multi_rowcount``
 #ndicate whether the dialect properly implements rowcount for
 #`UPDATE`` and ``DELETE`` statements when executed via
 #xecutemany.

 #`preexecute_autoincrement_sequences``
 #rue if 'implicit' primary key functions must be executed separately
 #n order to get their value.   This is currently oriented towards
 #ostgreSQL.

 #`implicit_returning``
 #se RETURNING or equivalent during INSERT execution in order to load
 #ewly generated primary keys and other column defaults in one execution,
 #hich are then available via inserted_primary_key.
 #f an insert statement has returning() specified explicitly,
 #he "implicit" functionality is not used and inserted_primary_key
 #ill not be available.

 #`colspecs``
 # dictionary of TypeEngine classes from sqlalchemy.types mapped
 #o subclasses that are specific to the dialect class.  This
 #ictionary is class-level only and is not accessed from the
 #ialect instance itself.

 #`supports_default_values``
 #ndicates if the construct ``INSERT INTO tablename DEFAULT
 #ALUES`` is supported

 #`supports_sequences``
 #ndicates if the dialect supports CREATE SEQUENCE or similar.

 #`sequences_optional``
 #f True, indicates if the "optional" flag on the Sequence() construct
 #hould signal to not generate a CREATE SEQUENCE. Applies only to
 #ialects that support sequences. Currently used only to allow PostgreSQL
 #ERIAL to be used on a column that specifies Sequence() for usage on
 #ther backends.

 #`supports_native_enum``
 #ndicates if the dialect supports a native ENUM construct.
 #his will prevent types.Enum from generating a CHECK
 #onstraint when that type is used.

 #`supports_native_boolean``
 #ndicates if the dialect supports a native boolean construct.
 #his will prevent types.Boolean from generating a CHECK
 #onstraint when that type is used.

 #`dbapi_exception_translation_map``
 # dictionary of names that will contain as values the names of
 #ep-249 exceptions ("IntegrityError", "OperationalError", etc)
 #eyed to alternate class names, to support the case where a
 #BAPI has exception classes that aren't named as they are
 #eferred to (e.g. IntegrityError = MyException).   In the vast
 #ajority of cases this dictionary is empty.

 #. versionadded:: 1.0.5

 #""

 #has_events = False

 #upports_statement_cache = True
 #""indicates if this dialect supports caching.

 #ll dialects that are compatible with statement caching should set this
 #lag to True directly on each dialect class and subclass that supports
 #t.  SQLAlchemy tests that this flag is locally present on each dialect
 #ubclass before it will use statement caching.  This is to provide
 #afety for legacy or new dialects that are not yet fully tested to be
 #ompliant with SQL statement caching.

 #. versionadded:: 1.4.5

 #. seealso::

 #ref:`engine_thirdparty_caching`

 #""

 #ef create_connect_args(self, url):
 #""Build DB-API compatible connection arguments.

 #iven a :class:`.URL` object, returns a tuple
 #onsisting of a ``(*args, **kwargs)`` suitable to send directly
 #o the dbapi's connect function.   The arguments are sent to the
 #meth:`.Dialect.connect` method which then runs the DBAPI-level
 #`connect()`` function.

 #he method typically makes use of the
 #meth:`.URL.translate_connect_args`
 #ethod in order to generate a dictionary of options.

 #he default implementation is::

 #ef create_connect_args(self, url):
 #pts = url.translate_connect_args()
 #pts.update(url.query)
 #eturn [[], opts]

 #param url: a :class:`.URL` object

 #return: a tuple of ``(*args, **kwargs)`` which will be passed to the
 #meth:`.Dialect.connect` method.

 #. seealso::

 #meth:`.URL.translate_connect_args`

 #""

 #aise NotImplementedError()

 #classmethod
 #ef type_descriptor(cls, typeobj):
 #""Transform a generic type to a dialect-specific type.

 #ialect classes will usually use the
 #func:`_types.adapt_type` function in the types module to
 #ccomplish this.

 #he returned result is cached *per dialect class* so can
 #ontain no dialect-instance state.

 #""

 #aise NotImplementedError()

 #ef initialize(self, connection):
 #""Called during strategized creation of the dialect with a
 #onnection.

 #llows dialects to configure options based on server version info or
 #ther properties.

 #he connection passed here is a SQLAlchemy Connection object,
 #ith full capabilities.

 #he initialize() method of the base dialect should be called via
 #uper().

 #. note:: as of SQLAlchemy 1.4, this method is called **before**
 #ny :meth:`_engine.Dialect.on_connect` hooks are called.

 #""

 #ass

 #ef get_columns(self, connection, table_name, schema=None, **kw):
 #""Return information about columns in `table_name`.

 #iven a :class:`_engine.Connection`, a string
 #table_name`, and an optional string `schema`, return column
 #nformation as a list of dictionaries with these keys:

 #ame
 #he column's name

 #ype
 #sqlalchemy.types#TypeEngine]

 #ullable
 #oolean

 #efault
 #he column's default value

 #utoincrement
 #oolean

 #equence
 # dictionary of the form
 #'name' : str, 'start' :int, 'increment': int, 'minvalue': int,
 #maxvalue': int, 'nominvalue': bool, 'nomaxvalue': bool,
 #cycle': bool, 'cache': int, 'order': bool}

 #dditional column attributes may be present.
 #""

 #aise NotImplementedError()

 #ef get_pk_constraint(self, connection, table_name, schema=None, **kw):
 #""Return information about the primary key constraint on
 #able_name`.

 #iven a :class:`_engine.Connection`, a string
 #table_name`, and an optional string `schema`, return primary
 #ey information as a dictionary with these keys:

 #onstrained_columns
 # list of column names that make up the primary key

 #ame
 #ptional name of the primary key constraint.

 #""
 #aise NotImplementedError()

 #ef get_foreign_keys(self, connection, table_name, schema=None, **kw):
 #""Return information about foreign_keys in `table_name`.

 #iven a :class:`_engine.Connection`, a string
 #table_name`, and an optional string `schema`, return foreign
 #ey information as a list of dicts with these keys:

 #ame
 #he constraint's name

 #onstrained_columns
 # list of column names that make up the foreign key

 #eferred_schema
 #he name of the referred schema

 #eferred_table
 #he name of the referred table

 #eferred_columns
 # list of column names in the referred table that correspond to
 #onstrained_columns
 #""

 #aise NotImplementedError()

 #ef get_table_names(self, connection, schema=None, **kw):
 #""Return a list of table names for `schema`."""

 #aise NotImplementedError()

 #ef get_temp_table_names(self, connection, schema=None, **kw):
 #""Return a list of temporary table names on the given connection,
 #f supported by the underlying backend.

 #""

 #aise NotImplementedError()

 #ef get_view_names(self, connection, schema=None, **kw):
 #""Return a list of all view names available in the database.

 #param schema: schema name to query, if not the default schema.
 #""

 #aise NotImplementedError()

 #ef get_sequence_names(self, connection, schema=None, **kw):
 #""Return a list of all sequence names available in the database.

 #param schema: schema name to query, if not the default schema.

 #. versionadded:: 1.4
 #""

 #aise NotImplementedError()

 #ef get_temp_view_names(self, connection, schema=None, **kw):
 #""Return a list of temporary view names on the given connection,
 #f supported by the underlying backend.

 #""

 #aise NotImplementedError()

 #ef get_view_definition(self, connection, view_name, schema=None, **kw):
 #""Return view definition.

 #iven a :class:`_engine.Connection`, a string
 #view_name`, and an optional string `schema`, return the view
 #efinition.
 #""

 #aise NotImplementedError()

 #ef get_indexes(self, connection, table_name, schema=None, **kw):
 #""Return information about indexes in `table_name`.

 #iven a :class:`_engine.Connection`, a string
 #table_name` and an optional string `schema`, return index
 #nformation as a list of dictionaries with these keys:

 #ame
 #he index's name

 #olumn_names
 #ist of column names in order

 #nique
 #oolean
 #""

 #aise NotImplementedError()

 #ef get_unique_constraints(
 #elf, connection, table_name, schema=None, **kw
 #:
 #"""Return information about unique constraints in `table_name`.

 #iven a string `table_name` and an optional string `schema`, return
 #nique constraint information as a list of dicts with these keys:

 #ame
 #he unique constraint's name

 #olumn_names
 #ist of column names in order

 #**kw
 #ther options passed to the dialect's get_unique_constraints()
 #ethod.

 #. versionadded:: 0.9.0

 #""

 #aise NotImplementedError()

 #ef get_check_constraints(self, connection, table_name, schema=None, **kw):
 #"""Return information about check constraints in `table_name`.

 #iven a string `table_name` and an optional string `schema`, return
 #heck constraint information as a list of dicts with these keys:

 # ``name`` -
 #he check constraint's name

 # ``sqltext`` -
 #he check constraint's SQL expression

 # ``**kw`` -
 #ther options passed to the dialect's get_check_constraints()
 #ethod.

 #. versionadded:: 1.1.0

 #""

 #aise NotImplementedError()

 #ef get_table_comment(self, connection, table_name, schema=None, **kw):
 #"""Return the "comment" for the table identified by `table_name`.

 #iven a string `table_name` and an optional string `schema`, return
 #able comment information as a dictionary with this key:

 #ext
 #ext of the comment

 #aises ``NotImplementedError`` for dialects that don't support
 #omments.

 #. versionadded:: 1.2

 #""

 #aise NotImplementedError()

 #ef normalize_name(self, name):
 #""convert the given name to lowercase if it is detected as
 #ase insensitive.

 #his method is only used if the dialect defines
 #equires_name_normalize=True.

 #""
 #aise NotImplementedError()

 #ef denormalize_name(self, name):
 #""convert the given name to a case insensitive identifier
 #or the backend if it is an all-lowercase name.

 #his method is only used if the dialect defines
 #equires_name_normalize=True.

 #""
 #aise NotImplementedError()

 #ef has_table(self, connection, table_name, schema=None, **kw):
 #""For internal dialect use, check the existence of a particular table
 #n the database.

 #iven a :class:`_engine.Connection` object, a string table_name and
 #ptional schema name, return True if the given table exists in the
 #atabase, False otherwise.

 #his method serves as the underlying implementation of the
 #ublic facing :meth:`.Inspector.has_table` method, and is also used
 #nternally to implement the "checkfirst" behavior for methods like
 #meth:`_schema.Table.create` and :meth:`_schema.MetaData.create_all`.

 #. note:: This method is used internally by SQLAlchemy, and is
 #ublished so that third-party dialects may provide an
 #mplementation. It is **not** the public API for checking for table
 #resence. Please use the :meth:`.Inspector.has_table` method.
 #lternatively, for legacy cross-compatibility, the
 #meth:`_engine.Engine.has_table` method may be used.

 #""

 #aise NotImplementedError()

 #ef has_index(self, connection, table_name, index_name, schema=None):
 #""Check the existence of a particular index name in the database.

 #iven a :class:`_engine.Connection` object, a string
 #table_name` and string index name, return True if an index of the
 #iven name on the given table exists, false otherwise.

 #he :class:`.DefaultDialect` implements this in terms of the
 #meth:`.Dialect.has_table` and :meth:`.Dialect.get_indexes` methods,
 #owever dialects can implement a more performant version.


 #. versionadded:: 1.4

 #""

 #aise NotImplementedError()

 #ef has_sequence(self, connection, sequence_name, schema=None, **kw):
 #""Check the existence of a particular sequence in the database.

 #iven a :class:`_engine.Connection` object and a string
 #sequence_name`, return True if the given sequence exists in
 #he database, False otherwise.
 #""

 #aise NotImplementedError()

 #ef _get_server_version_info(self, connection):
 #""Retrieve the server version info from the given connection.

 #his is used by the default implementation to populate the
 #server_version_info" attribute and is called exactly
 #nce upon first connect.

 #""

 #aise NotImplementedError()

 #ef _get_default_schema_name(self, connection):
 #""Return the string name of the currently selected schema from
 #he given connection.

 #his is used by the default implementation to populate the
 #default_schema_name" attribute and is called exactly
 #nce upon first connect.

 #""

 #aise NotImplementedError()

 #ef do_begin(self, dbapi_connection):
 #""Provide an implementation of ``connection.begin()``, given a
 #B-API connection.

 #he DBAPI has no dedicated "begin" method and it is expected
 #hat transactions are implicit.  This hook is provided for those
 #BAPIs that might need additional help in this area.

 #ote that :meth:`.Dialect.do_begin` is not called unless a
 #class:`.Transaction` object is in use.  The
 #meth:`.Dialect.do_autocommit`
 #ook is provided for DBAPIs that need some extra commands emitted
 #fter a commit in order to enter the next transaction, when the
 #QLAlchemy :class:`_engine.Connection`
 #s used in its default "autocommit"
 #ode.

 #param dbapi_connection: a DBAPI connection, typically
 #roxied within a :class:`.ConnectionFairy`.

 #""

 #aise NotImplementedError()

 #ef do_rollback(self, dbapi_connection):
 #""Provide an implementation of ``connection.rollback()``, given
 # DB-API connection.

 #param dbapi_connection: a DBAPI connection, typically
 #roxied within a :class:`.ConnectionFairy`.

 #""

 #aise NotImplementedError()

 #ef do_commit(self, dbapi_connection):
 #""Provide an implementation of ``connection.commit()``, given a
 #B-API connection.

 #param dbapi_connection: a DBAPI connection, typically
 #roxied within a :class:`.ConnectionFairy`.

 #""

 #aise NotImplementedError()

 #ef do_close(self, dbapi_connection):
 #""Provide an implementation of ``connection.close()``, given a DBAPI
 #onnection.

 #his hook is called by the :class:`_pool.Pool`
 #hen a connection has been
 #etached from the pool, or is being returned beyond the normal
 #apacity of the pool.

 #""

 #aise NotImplementedError()

 #ef do_set_input_sizes(self, cursor, list_of_tuples, context):
 #""invoke the cursor.setinputsizes() method with appropriate arguments

 #his hook is called if the dialect.use_inputsizes flag is set to True.
 #arameter data is passed in a list of tuples (paramname, dbtype,
 #qltype), where ``paramname`` is the key of the parameter in the
 #tatement, ``dbtype`` is the DBAPI datatype and ``sqltype`` is the
 #QLAlchemy type. The order of tuples is in the correct parameter order.

 #. versionadded:: 1.4


 #""
 #aise NotImplementedError()

 #ef create_xid(self):
 #""Create a two-phase transaction ID.

 #his id will be passed to do_begin_twophase(),
 #o_rollback_twophase(), do_commit_twophase().  Its format is
 #nspecified.
 #""

 #aise NotImplementedError()

 #ef do_savepoint(self, connection, name):
 #""Create a savepoint with the given name.

 #param connection: a :class:`_engine.Connection`.
 #param name: savepoint name.

 #""

 #aise NotImplementedError()

 #ef do_rollback_to_savepoint(self, connection, name):
 #""Rollback a connection to the named savepoint.

 #param connection: a :class:`_engine.Connection`.
 #param name: savepoint name.

 #""

 #aise NotImplementedError()

 #ef do_release_savepoint(self, connection, name):
 #""Release the named savepoint on a connection.

 #param connection: a :class:`_engine.Connection`.
 #param name: savepoint name.
 #""

 #aise NotImplementedError()

 #ef do_begin_twophase(self, connection, xid):
 #""Begin a two phase transaction on the given connection.

 #param connection: a :class:`_engine.Connection`.
 #param xid: xid

 #""

 #aise NotImplementedError()

 #ef do_prepare_twophase(self, connection, xid):
 #""Prepare a two phase transaction on the given connection.

 #param connection: a :class:`_engine.Connection`.
 #param xid: xid

 #""

 #aise NotImplementedError()

 #ef do_rollback_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:
 #""Rollback a two phase transaction on the given connection.

 #param connection: a :class:`_engine.Connection`.
 #param xid: xid
 #param is_prepared: whether or not
 #meth:`.TwoPhaseTransaction.prepare` was called.
 #param recover: if the recover flag was passed.

 #""

 #aise NotImplementedError()

 #ef do_commit_twophase(
 #elf, connection, xid, is_prepared=True, recover=False
 #:
 #""Commit a two phase transaction on the given connection.


 #param connection: a :class:`_engine.Connection`.
 #param xid: xid
 #param is_prepared: whether or not
 #meth:`.TwoPhaseTransaction.prepare` was called.
 #param recover: if the recover flag was passed.

 #""

 #aise NotImplementedError()

 #ef do_recover_twophase(self, connection):
 #""Recover list of uncommitted prepared two phase transaction
 #dentifiers on the given connection.

 #param connection: a :class:`_engine.Connection`.

 #""

 #aise NotImplementedError()

 #ef do_executemany(self, cursor, statement, parameters, context=None):
 #""Provide an implementation of ``cursor.executemany(statement,
 #arameters)``."""

 #aise NotImplementedError()

 #ef do_execute(self, cursor, statement, parameters, context=None):
 #""Provide an implementation of ``cursor.execute(statement,
 #arameters)``."""

 #aise NotImplementedError()

 #ef do_execute_no_params(
 #elf, cursor, statement, parameters, context=None
 #:
 #""Provide an implementation of ``cursor.execute(statement)``.

 #he parameter collection should not be sent.

 #""

 #aise NotImplementedError()

 #ef is_disconnect(self, e, connection, cursor):
 #""Return True if the given DB-API error indicates an invalid
 #onnection"""

 #aise NotImplementedError()

 #ef connect(self, *cargs, **cparams):
 #"""Establish a connection using this dialect's DBAPI.

 #he default implementation of this method is::

 #ef connect(self, *cargs, **cparams):
 #eturn self.dbapi.connect(*cargs, **cparams)

 #he ``*cargs, **cparams`` parameters are generated directly
 #rom this dialect's :meth:`.Dialect.create_connect_args` method.

 #his method may be used for dialects that need to perform programmatic
 #er-connection steps when a new connection is procured from the
 #BAPI.


 #param \*cargs: positional parameters returned from the
 #meth:`.Dialect.create_connect_args` method

 #param \*\*cparams: keyword parameters returned from the
 #meth:`.Dialect.create_connect_args` method.

 #return: a DBAPI connection, typically from the :pep:`249` module
 #evel ``.connect()`` function.

 #. seealso::

 #meth:`.Dialect.create_connect_args`

 #meth:`.Dialect.on_connect`

 #""

 #ef on_connect_url(self, url):
 #""return a callable which sets up a newly created DBAPI connection.

 #his method is a new hook that supersedes the
 #meth:`_engine.Dialect.on_connect` method when implemented by a
 #ialect.   When not implemented by a dialect, it invokes the
 #meth:`_engine.Dialect.on_connect` method directly to maintain
 #ompatibility with existing dialects.   There is no deprecation
 #or :meth:`_engine.Dialect.on_connect` expected.

 #he callable should accept a single argument "conn" which is the
 #BAPI connection itself.  The inner callable has no
 #eturn value.

 #.g.::

 #lass MyDialect(default.DefaultDialect):
                # ...

 #ef on_connect_url(self, url):
 #ef do_on_connect(connection):
 #onnection.execute("SET SPECIAL FLAGS etc")

 #eturn do_on_connect

 #his is used to set dialect-wide per-connection options such as
 #solation modes, Unicode modes, etc.

 #his method differs from :meth:`_engine.Dialect.on_connect` in that
 #t is passed the :class:`_engine.URL` object that's relevant to the
 #onnect args.  Normally the only way to get this is from the
 #meth:`_engine.Dialect.on_connect` hook is to look on the
 #class:`_engine.Engine` itself, however this URL object may have been
 #eplaced by plugins.

 #. note::

 #he default implementation of
 #meth:`_engine.Dialect.on_connect_url` is to invoke the
 #meth:`_engine.Dialect.on_connect` method. Therefore if a dialect
 #mplements this method, the :meth:`_engine.Dialect.on_connect`
 #ethod **will not be called** unless the overriding dialect calls
 #t directly from here.

 #. versionadded:: 1.4.3 added :meth:`_engine.Dialect.on_connect_url`
 #hich normally calls into :meth:`_engine.Dialect.on_connect`.

 #param url: a :class:`_engine.URL` object representing the
 #class:`_engine.URL` that was passed to the
 #meth:`_engine.Dialect.create_connect_args` method.

 #return: a callable that accepts a single DBAPI connection as an
 #rgument, or None.

 #. seealso::

 #meth:`_engine.Dialect.on_connect`

 #""
 #eturn self.on_connect()

 #ef on_connect(self):
 #""return a callable which sets up a newly created DBAPI connection.

 #he callable should accept a single argument "conn" which is the
 #BAPI connection itself.  The inner callable has no
 #eturn value.

 #.g.::

 #lass MyDialect(default.DefaultDialect):
                # ...

 #ef on_connect(self):
 #ef do_on_connect(connection):
 #onnection.execute("SET SPECIAL FLAGS etc")

 #eturn do_on_connect

 #his is used to set dialect-wide per-connection options such as
 #solation modes, Unicode modes, etc.

 #he "do_on_connect" callable is invoked by using the
 #meth:`_events.PoolEvents.connect` event
 #ook, then unwrapping the DBAPI connection and passing it into the
 #allable.

 #. versionchanged:: 1.4 the on_connect hook is no longer called twice
 #or the first connection of a dialect.  The on_connect hook is still
 #alled before the :meth:`_engine.Dialect.initialize` method however.

 #. versionchanged:: 1.4.3 the on_connect hook is invoked from a new
 #ethod on_connect_url that passes the URL that was used to create
 #he connect args.   Dialects can implement on_connect_url instead
 #f on_connect if they need the URL object that was used for the
 #onnection in order to get additional context.

 #f None is returned, no event listener is generated.

 #return: a callable that accepts a single DBAPI connection as an
 #rgument, or None.

 #. seealso::

 #meth:`.Dialect.connect` - allows the DBAPI ``connect()`` sequence
 #tself to be controlled.

 #meth:`.Dialect.on_connect_url` - supersedes
 #meth:`.Dialect.on_connect` to also receive the
 #class:`_engine.URL` object in context.

 #""
 #eturn None

 #ef reset_isolation_level(self, dbapi_conn):
 #""Given a DBAPI connection, revert its isolation to the default.

 #ote that this is a dialect-level method which is used as part
 #f the implementation of the :class:`_engine.Connection` and
 #class:`_engine.Engine`
 #solation level facilities; these APIs should be preferred for
 #ost typical use cases.

 #. seealso::

 #meth:`_engine.Connection.get_isolation_level`
 # view current level

 #attr:`_engine.Connection.default_isolation_level`
 # view default level

 #paramref:`.Connection.execution_options.isolation_level` -
 #et per :class:`_engine.Connection` isolation level

 #paramref:`_sa.create_engine.isolation_level` -
 #et per :class:`_engine.Engine` isolation level

 #""

 #aise NotImplementedError()

 #ef set_isolation_level(self, dbapi_conn, level):
 #""Given a DBAPI connection, set its isolation level.

 #ote that this is a dialect-level method which is used as part
 #f the implementation of the :class:`_engine.Connection` and
 #class:`_engine.Engine`
 #solation level facilities; these APIs should be preferred for
 #ost typical use cases.

 #. seealso::

 #meth:`_engine.Connection.get_isolation_level`
 # view current level

 #attr:`_engine.Connection.default_isolation_level`
 # view default level

 #paramref:`.Connection.execution_options.isolation_level` -
 #et per :class:`_engine.Connection` isolation level

 #paramref:`_sa.create_engine.isolation_level` -
 #et per :class:`_engine.Engine` isolation level

 #""

 #aise NotImplementedError()

 #ef get_isolation_level(self, dbapi_conn):
 #""Given a DBAPI connection, return its isolation level.

 #hen working with a :class:`_engine.Connection` object,
 #he corresponding
 #BAPI connection may be procured using the
 #attr:`_engine.Connection.connection` accessor.

 #ote that this is a dialect-level method which is used as part
 #f the implementation of the :class:`_engine.Connection` and
 #class:`_engine.Engine` isolation level facilities;
 #hese APIs should be preferred for most typical use cases.


 #. seealso::

 #meth:`_engine.Connection.get_isolation_level`
 # view current level

 #attr:`_engine.Connection.default_isolation_level`
 # view default level

 #paramref:`.Connection.execution_options.isolation_level` -
 #et per :class:`_engine.Connection` isolation level

 #paramref:`_sa.create_engine.isolation_level` -
 #et per :class:`_engine.Engine` isolation level


 #""

 #aise NotImplementedError()

 #ef get_default_isolation_level(self, dbapi_conn):
 #""Given a DBAPI connection, return its isolation level, or
 # default isolation level if one cannot be retrieved.

 #his method may only raise NotImplementedError and
 #*must not raise any other exception**, as it is used implicitly upon
 #irst connect.

 #he method **must return a value** for a dialect that supports
 #solation level settings, as this level is what will be reverted
 #owards when a per-connection isolation level change is made.

 #he method defaults to using the :meth:`.Dialect.get_isolation_level`
 #ethod unless overridden by a dialect.

 #. versionadded:: 1.3.22

 #""
 #aise NotImplementedError()

 #classmethod
 #ef get_dialect_cls(cls, url):
 #""Given a URL, return the :class:`.Dialect` that will be used.

 #his is a hook that allows an external plugin to provide functionality
 #round an existing dialect, by allowing the plugin to be loaded
 #rom the url based on an entrypoint, and then the plugin returns
 #he actual dialect to be used.

 #y default this just returns the cls.

 #. versionadded:: 1.0.3

 #""
 #eturn cls

 #classmethod
 #ef load_provisioning(cls):
 #""set up the provision.py module for this dialect.

 #or dialects that include a provision.py module that sets up
 #rovisioning followers, this method should initiate that process.

 # typical implementation would be::

 #classmethod
 #ef load_provisioning(cls):
 #_import__("mydialect.provision")

 #he default method assumes a module named ``provision.py`` inside
 #he owning package of the current dialect, based on the ``__module__``
 #ttribute::

 #classmethod
 #ef load_provisioning(cls):
 #ackage = ".".join(cls.__module__.split(".")[0:-1])
 #ry:
 #_import__(package + ".provision")
 #xcept ImportError:
 #ass

 #. versionadded:: 1.3.14

 #""

 #classmethod
 #ef engine_created(cls, engine):
 #""A convenience hook called before returning the final
 #class:`_engine.Engine`.

 #f the dialect returned a different class from the
 #meth:`.get_dialect_cls`
 #ethod, then the hook is called on both classes, first on
 #he dialect class returned by the :meth:`.get_dialect_cls` method and
 #hen on the class on which the method was called.

 #he hook should be used by dialects and/or wrappers to apply special
 #vents to the engine or its components.   In particular, it allows
 # dialect-wrapping class to apply dialect-level events.

 #. versionadded:: 1.0.3

 #""
 #ass


class CreateEnginePlugin(object):
 #""A set of hooks intended to augment the construction of an
 #class:`_engine.Engine` object based on entrypoint names in a URL.

 #he purpose of :class:`_engine.CreateEnginePlugin` is to allow third-party
 #ystems to apply engine, pool and dialect level event listeners without
 #he need for the target application to be modified; instead, the plugin
 #ames can be added to the database URL.  Target applications for
 #class:`_engine.CreateEnginePlugin` include:

 # connection and SQL performance tools, e.g. which use events to track
 #umber of checkouts and/or time spent with statements

 # connectivity plugins such as proxies

 # rudimentary :class:`_engine.CreateEnginePlugin` that attaches a logger
 #o an :class:`_engine.Engine` object might look like::


 #mport logging

 #rom sqlalchemy.engine import CreateEnginePlugin
 #rom sqlalchemy import event

 #lass LogCursorEventsPlugin(CreateEnginePlugin):
 #ef __init__(self, url, kwargs):
                # consume the parameter "log_cursor_logging_name" from the
                # URL query
 #ogging_name = url.query.get("log_cursor_logging_name", "log_cursor")

 #elf.log = logging.getLogger(logging_name)

 #ef update_url(self, url):
 #update the URL to one that no longer includes our parameters"
 #eturn url.difference_update_query(["log_cursor_logging_name"])

 #ef engine_created(self, engine):
 #attach an event listener after the new Engine is constructed"
 #vent.listen(engine, "before_cursor_execute", self._log_event)


 #ef _log_event(
 #elf,
 #onn,
 #ursor,
 #tatement,
 #arameters,
 #ontext,
 #xecutemany):

 #elf.log.info("Plugin logged cursor event: %s", statement)



 #lugins are registered using entry points in a similar way as that
 #f dialects::

 #ntry_points={
 #sqlalchemy.plugins': [
 #log_cursor_plugin = myapp.plugins:LogCursorEventsPlugin'
 #

 # plugin that uses the above names would be invoked from a database
 #RL as in::

 #rom sqlalchemy import create_engine

 #ngine = create_engine(
 #mysql+pymysql://scott:tiger@localhost/test?"
 #plugin=log_cursor_plugin&log_cursor_logging_name=mylogger"
 #

 #he ``plugin`` URL parameter supports multiple instances, so that a URL
 #ay specify multiple plugins; they are loaded in the order stated
 #n the URL::

 #ngine = create_engine(
 #mysql+pymysql://scott:tiger@localhost/test?"
 #plugin=plugin_one&plugin=plugin_twp&plugin=plugin_three")

 #he plugin names may also be passed directly to :func:`_sa.create_engine`
 #sing the :paramref:`_sa.create_engine.plugins` argument::

 #ngine = create_engine(
 #mysql+pymysql://scott:tiger@localhost/test",
 #lugins=["myplugin"])

 #. versionadded:: 1.2.3  plugin names can also be specified
 #o :func:`_sa.create_engine` as a list

 # plugin may consume plugin-specific arguments from the
 #class:`_engine.URL` object as well as the ``kwargs`` dictionary, which is
 #he dictionary of arguments passed to the :func:`_sa.create_engine`
 #all.  "Consuming" these arguments includes that they must be removed
 #hen the plugin initializes, so that the arguments are not passed along
 #o the :class:`_engine.Dialect` constructor, where they will raise an
 #class:`_exc.ArgumentError` because they are not known by the dialect.

 #s of version 1.4 of SQLAlchemy, arguments should continue to be consumed
 #rom the ``kwargs`` dictionary directly, by removing the values with a
 #ethod such as ``dict.pop``. Arguments from the :class:`_engine.URL` object
 #hould be consumed by implementing the
 #meth:`_engine.CreateEnginePlugin.update_url` method, returning a new copy
 #f the :class:`_engine.URL` with plugin-specific parameters removed::

 #lass MyPlugin(CreateEnginePlugin):
 #ef __init__(self, url, kwargs):
 #elf.my_argument_one = url.query['my_argument_one']
 #elf.my_argument_two = url.query['my_argument_two']
 #elf.my_argument_three = kwargs.pop('my_argument_three', None)

 #ef update_url(self, url):
 #eturn url.difference_update_query(
 #"my_argument_one", "my_argument_two"]
 #

 #rguments like those illustrated above would be consumed from a
 #func:`_sa.create_engine` call such as::

 #rom sqlalchemy import create_engine

 #ngine = create_engine(
 #mysql+pymysql://scott:tiger@localhost/test?"
 #plugin=myplugin&my_argument_one=foo&my_argument_two=bar",
 #y_argument_three='bat'
 #

 #. versionchanged:: 1.4

 #he :class:`_engine.URL` object is now immutable; a
 #class:`_engine.CreateEnginePlugin` that needs to alter the
 #class:`_engine.URL` should implement the newly added
 #meth:`_engine.CreateEnginePlugin.update_url` method, which
 #s invoked after the plugin is constructed.

 #or migration, construct the plugin in the following way, checking
 #or the existence of the :meth:`_engine.CreateEnginePlugin.update_url`
 #ethod to detect which version is running::

 #lass MyPlugin(CreateEnginePlugin):
 #ef __init__(self, url, kwargs):
 #f hasattr(CreateEnginePlugin, "update_url"):
                        # detect the 1.4 API
 #elf.my_argument_one = url.query['my_argument_one']
 #elf.my_argument_two = url.query['my_argument_two']
 #lse:
                        # detect the 1.3 and earlier API - mutate the
                        # URL directly
 #elf.my_argument_one = url.query.pop('my_argument_one')
 #elf.my_argument_two = url.query.pop('my_argument_two')

 #elf.my_argument_three = kwargs.pop('my_argument_three', None)

 #ef update_url(self, url):
                    # this method is only called in the 1.4 version
 #eturn url.difference_update_query(
 #"my_argument_one", "my_argument_two"]
 #

 #. seealso::

 #ref:`change_5526` - overview of the :class:`_engine.URL` change which
 #lso includes notes regarding :class:`_engine.CreateEnginePlugin`.


 #hen the engine creation process completes and produces the
 #class:`_engine.Engine` object, it is again passed to the plugin via the
 #meth:`_engine.CreateEnginePlugin.engine_created` hook.  In this hook, additional
 #hanges can be made to the engine, most typically involving setup of
 #vents (e.g. those defined in :ref:`core_event_toplevel`).

 #. versionadded:: 1.1

 #""  # noqa: E501

 #ef __init__(self, url, kwargs):
 #""Construct a new :class:`.CreateEnginePlugin`.

 #he plugin object is instantiated individually for each call
 #o :func:`_sa.create_engine`.  A single :class:`_engine.
 #ngine` will be
 #assed to the :meth:`.CreateEnginePlugin.engine_created` method
 #orresponding to this URL.

 #param url: the :class:`_engine.URL` object.  The plugin may inspect
 #he :class:`_engine.URL` for arguments.  Arguments used by the
 #lugin should be removed, by returning an updated :class:`_engine.URL`
 #rom the :meth:`_engine.CreateEnginePlugin.update_url` method.

 #. versionchanged::  1.4

 #he :class:`_engine.URL` object is now immutable, so a
 #class:`_engine.CreateEnginePlugin` that needs to alter the
 #class:`_engine.URL` object should implement the
 #meth:`_engine.CreateEnginePlugin.update_url` method.

 #param kwargs: The keyword arguments passed to
 #func:`_sa.create_engine`.

 #""
 #elf.url = url

 #ef update_url(self, url):
 #""Update the :class:`_engine.URL`.

 # new :class:`_engine.URL` should be returned.   This method is
 #ypically used to consume configuration arguments from the
 #class:`_engine.URL` which must be removed, as they will not be
 #ecognized by the dialect.  The
 #meth:`_engine.URL.difference_update_query` method is available
 #o remove these arguments.   See the docstring at
 #class:`_engine.CreateEnginePlugin` for an example.


 #. versionadded:: 1.4

 #""

 #ef handle_dialect_kwargs(self, dialect_cls, dialect_args):
 #""parse and modify dialect kwargs"""

 #ef handle_pool_kwargs(self, pool_cls, pool_args):
 #""parse and modify pool kwargs"""

 #ef engine_created(self, engine):
 #""Receive the :class:`_engine.Engine`
 #bject when it is fully constructed.

 #he plugin may make additional changes to the engine, such as
 #egistering engine or connection pool events.

 #""


class ExecutionContext(object):
 #""A messenger object for a Dialect that corresponds to a single
 #xecution.

 #xecutionContext should have these data members:

 #onnection
 #onnection object which can be freely used by default value
 #enerators to execute SQL.  This Connection should reference the
 #ame underlying connection/transactional resources of
 #oot_connection.

 #oot_connection
 #onnection object which is the source of this ExecutionContext.  This
 #onnection may have close_with_result=True set, in which case it can
 #nly be used once.

 #ialect
 #ialect which created this ExecutionContext.

 #ursor
 #B-API cursor procured from the connection,

 #ompiled
 #f passed to constructor, sqlalchemy.engine.base.Compiled object
 #eing executed,

 #tatement
 #tring version of the statement to be executed.  Is either
 #assed to the constructor, or must be created from the
 #ql.Compiled object by the time pre_exec() has completed.

 #arameters
 #ind parameters passed to the execute() method.  For compiled
 #tatements, this is a dictionary or list of dictionaries.  For
 #extual statements, it should be in a format suitable for the
 #ialect's paramstyle (i.e. dict or list of dicts for non
 #ositional, list or list of lists/tuples for positional).

 #sinsert
 #rue if the statement is an INSERT.

 #supdate
 #rue if the statement is an UPDATE.

 #hould_autocommit
 #rue if the statement is a "committable" statement.

 #refetch_cols
 # list of Column objects for which a client-side default
 #as fired off.  Applies to inserts and updates.

 #ostfetch_cols
 # list of Column objects for which a server-side default or
 #nline SQL expression value was fired off.  Applies to inserts
 #nd updates.
 #""

 #ef create_cursor(self):
 #""Return a new cursor generated from this ExecutionContext's
 #onnection.

 #ome dialects may wish to change the behavior of
 #onnection.cursor(), such as postgresql which may return a PG
 #server side" cursor.
 #""

 #aise NotImplementedError()

 #ef pre_exec(self):
 #""Called before an execution of a compiled statement.

 #f a compiled statement was passed to this ExecutionContext,
 #he `statement` and `parameters` datamembers must be
 #nitialized after this statement is complete.
 #""

 #aise NotImplementedError()

 #ef get_out_parameter_values(self, out_param_names):
 #""Return a sequence of OUT parameter values from a cursor.

 #or dialects that support OUT parameters, this method will be called
 #hen there is a :class:`.SQLCompiler` object which has the
 #attr:`.SQLCompiler.has_out_parameters` flag set.  This flag in turn
 #ill be set to True if the statement itself has :class:`.BindParameter`
 #bjects that have the ``.isoutparam`` flag set which are consumed by
 #he :meth:`.SQLCompiler.visit_bindparam` method.  If the dialect
 #ompiler produces :class:`.BindParameter` objects with ``.isoutparam``
 #et which are not handled by :meth:`.SQLCompiler.visit_bindparam`, it
 #hould set this flag explicitly.

 #he list of names that were rendered for each bound parameter
 #s passed to the method.  The method should then return a sequence of
 #alues corresponding to the list of parameter objects. Unlike in
 #revious SQLAlchemy versions, the values can be the **raw values** from
 #he DBAPI; the execution context will apply the appropriate type
 #andler based on what's present in self.compiled.binds and update the
 #alues.  The processed dictionary will then be made available via the
 #`.out_parameters`` collection on the result object.  Note that
 #QLAlchemy 1.4 has multiple kinds of result object as part of the 2.0
 #ransition.

 #. versionadded:: 1.4 - added
 #meth:`.ExecutionContext.get_out_parameter_values`, which is invoked
 #utomatically by the :class:`.DefaultExecutionContext` when there
 #re :class:`.BindParameter` objects with the ``.isoutparam`` flag
 #et.  This replaces the practice of setting out parameters within
 #he now-removed ``get_result_proxy()`` method.

 #. seealso::

 #meth:`.ExecutionContext.get_result_cursor_strategy`

 #""
 #aise NotImplementedError()

 #ef post_exec(self):
 #""Called after the execution of a compiled statement.

 #f a compiled statement was passed to this ExecutionContext,
 #he `last_insert_ids`, `last_inserted_params`, etc.
 #atamembers should be available after this method completes.
 #""

 #aise NotImplementedError()

 #ef get_result_cursor_strategy(self, result):
 #""Return a result cursor strategy for a given result object.

 #his method is implemented by the :class:`.DefaultDialect` and is
 #nly needed by implementing dialects in the case where some special
 #teps regarding the cursor must be taken, such as manufacturing
 #ake results from some other element of the cursor, or pre-buffering
 #he cursor's results.

 # simplified version of the default implementation is::

 #rom sqlalchemy.engine.result import DefaultCursorFetchStrategy

 #lass MyExecutionContext(DefaultExecutionContext):
 #ef get_result_cursor_strategy(self, result):
 #eturn DefaultCursorFetchStrategy.create(result)

 #bove, the :class:`.DefaultCursorFetchStrategy` will be applied
 #o the result object.   For results that are pre-buffered from a
 #ursor that might be closed, an implementation might be::


 #rom sqlalchemy.engine.result import (
 #ullyBufferedCursorFetchStrategy
 #

 #lass MyExecutionContext(DefaultExecutionContext):
 #pre_buffered_result = None

 #ef pre_exec(self):
 #f self.special_condition_prebuffer_cursor():
 #elf._pre_buffered_result = (
 #elf.cursor.description,
 #elf.cursor.fetchall()
 #

 #ef get_result_cursor_strategy(self, result):
 #f self._pre_buffered_result:
 #escription, cursor_buffer = self._pre_buffered_result
 #eturn (
 #ullyBufferedCursorFetchStrategy.
 #reate_from_buffer(
 #esult, description, cursor_buffer
 #
 #
 #lse:
 #eturn DefaultCursorFetchStrategy.create(result)

 #his method replaces the previous not-quite-documented
 #`get_result_proxy()`` method.

 #. versionadded:: 1.4  - result objects now interpret cursor results
 #ased on a pluggable "strategy" object, which is delivered
 #y the :class:`.ExecutionContext` via the
 #meth:`.ExecutionContext.get_result_cursor_strategy` method.

 #. seealso::

 #meth:`.ExecutionContext.get_out_parameter_values`

 #""
 #aise NotImplementedError()

 #ef handle_dbapi_exception(self, e):
 #""Receive a DBAPI exception which occurred upon execute, result
 #etch, etc."""

 #aise NotImplementedError()

 #ef should_autocommit_text(self, statement):
 #""Parse the given textual statement and return True if it refers to
 # "committable" statement"""

 #aise NotImplementedError()

 #ef lastrow_has_defaults(self):
 #""Return True if the last INSERT or UPDATE row contained
 #nlined or database-side defaults.
 #""

 #aise NotImplementedError()

 #ef get_rowcount(self):
 #""Return the DBAPI ``cursor.rowcount`` value, or in some
 #ases an interpreted value.

 #ee :attr:`_engine.CursorResult.rowcount` for details on this.

 #""

 #aise NotImplementedError()


@util.deprecated_20_cls(
 #:class:`.Connectable`",
 #lternative=(
 #The :class:`_engine.Engine` will be the only Core "
 #object that features a .connect() method, and the "
 #:class:`_engine.Connection` will be the only object that features "
 #an .execute() method."
 #,
 #onstructor=None,
)
class Connectable(object):
 #""Interface for an object which supports execution of SQL constructs.

 #he two implementations of :class:`.Connectable` are
 #class:`_engine.Connection` and :class:`_engine.Engine`.

 #onnectable must also implement the 'dialect' member which references a
 #class:`.Dialect` instance.

 #""

 #ef connect(self, **kwargs):
 #""Return a :class:`_engine.Connection` object.

 #epending on context, this may be ``self`` if this object
 #s already an instance of :class:`_engine.Connection`, or a newly
 #rocured :class:`_engine.Connection` if this object is an instance
 #f :class:`_engine.Engine`.

 #""

 #ngine = None
 #""The :class:`_engine.Engine` instance referred to by this
 #class:`.Connectable`.

 #ay be ``self`` if this is already an :class:`_engine.Engine`.

 #""

 #ef execute(self, object_, *multiparams, **params):
 #""Executes the given construct and returns a
 #class:`_engine.CursorResult`.
 #""
 #aise NotImplementedError()

 #ef scalar(self, object_, *multiparams, **params):
 #""Executes and returns the first column of the first row.

 #he underlying cursor is closed after execution.
 #""
 #aise NotImplementedError()

 #ef _run_visitor(self, visitorcallable, element, **kwargs):
 #aise NotImplementedError()

 #ef _execute_clauseelement(self, elem, multiparams=None, params=None):
 #aise NotImplementedError()


class ExceptionContext(object):
 #""Encapsulate information about an error condition in progress.

 #his object exists solely to be passed to the
 #meth:`_events.ConnectionEvents.handle_error` event,
 #upporting an interface that
 #an be extended without backwards-incompatibility.

 #. versionadded:: 0.9.7

 #""

 #onnection = None
 #""The :class:`_engine.Connection` in use during the exception.

 #his member is present, except in the case of a failure when
 #irst connecting.

 #. seealso::

 #attr:`.ExceptionContext.engine`


 #""

 #ngine = None
 #""The :class:`_engine.Engine` in use during the exception.

 #his member should always be present, even in the case of a failure
 #hen first connecting.

 #. versionadded:: 1.0.0

 #""

 #ursor = None
 #""The DBAPI cursor object.

 #ay be None.

 #""

 #tatement = None
 #""String SQL statement that was emitted directly to the DBAPI.

 #ay be None.

 #""

 #arameters = None
 #""Parameter collection that was emitted directly to the DBAPI.

 #ay be None.

 #""

 #riginal_exception = None
 #""The exception object which was caught.

 #his member is always present.

 #""

 #qlalchemy_exception = None
 #""The :class:`sqlalchemy.exc.StatementError` which wraps the original,
 #nd will be raised if exception handling is not circumvented by the event.

 #ay be None, as not all exception types are wrapped by SQLAlchemy.
 #or DBAPI-level exceptions that subclass the dbapi's Error class, this
 #ield will always be present.

 #""

 #hained_exception = None
 #""The exception that was returned by the previous handler in the
 #xception chain, if any.

 #f present, this exception will be the one ultimately raised by
 #QLAlchemy unless a subsequent handler replaces it.

 #ay be None.

 #""

 #xecution_context = None
 #""The :class:`.ExecutionContext` corresponding to the execution
 #peration in progress.

 #his is present for statement execution operations, but not for
 #perations such as transaction begin/end.  It also is not present when
 #he exception was raised before the :class:`.ExecutionContext`
 #ould be constructed.

 #ote that the :attr:`.ExceptionContext.statement` and
 #attr:`.ExceptionContext.parameters` members may represent a
 #ifferent value than that of the :class:`.ExecutionContext`,
 #otentially in the case where a
 #meth:`_events.ConnectionEvents.before_cursor_execute` event or similar
 #odified the statement/parameters to be sent.

 #ay be None.

 #""

 #s_disconnect = None
 #""Represent whether the exception as occurred represents a "disconnect"
 #ondition.

 #his flag will always be True or False within the scope of the
 #meth:`_events.ConnectionEvents.handle_error` handler.

 #QLAlchemy will defer to this flag in order to determine whether or not
 #he connection should be invalidated subsequently.    That is, by
 #ssigning to this flag, a "disconnect" event which then results in
 # connection and pool invalidation can be invoked or prevented by
 #hanging this flag.


 #. note:: The pool "pre_ping" handler enabled using the
 #paramref:`_sa.create_engine.pool_pre_ping` parameter does **not**
 #onsult this event before deciding if the "ping" returned false,
 #s opposed to receiving an unhandled error.   For this use case, the
 #ref:`legacy recipe based on engine_connect() may be used
 #pool_disconnects_pessimistic_custom>`.  A future API allow more
 #omprehensive customization of the "disconnect" detection mechanism
 #cross all functions.

 #""

 #nvalidate_pool_on_disconnect = True
 #""Represent whether all connections in the pool should be invalidated
 #hen a "disconnect" condition is in effect.

 #etting this flag to False within the scope of the
 #meth:`_events.ConnectionEvents.handle_error`
 #vent will have the effect such
 #hat the full collection of connections in the pool will not be
 #nvalidated during a disconnect; only the current connection that is the
 #ubject of the error will actually be invalidated.

 #he purpose of this flag is for custom disconnect-handling schemes where
 #he invalidation of other connections in the pool is to be performed
 #ased on other conditions, or even on a per-connection basis.

 #. versionadded:: 1.0.3

 #""
