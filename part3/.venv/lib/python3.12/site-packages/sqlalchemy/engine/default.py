# engine/default.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Default implementations of per-dialect sqlalchemy.engine classes.

These are semi-private implementation classes which are only of importance
to database dialect authors; dialects will usually use the classes here
as the base class for their own corresponding classes.

"""

import codecs
import functools
import random
import re
import weakref

from . import characteristics
from . import cursor as _cursor
from . import interfaces
from .base import Connection
from .. import event
from .. import exc
from .. import pool
from .. import processors
from .. import types as sqltypes
from .. import util
from ..sql import compiler
from ..sql import expression
from ..sql.elements import quoted_name

AUTOCOMMIT_REGEXP = re.compile(
 #"\s*(?:UPDATE|INSERT|CREATE|DELETE|DROP|ALTER)", re.I | re.UNICODE
)

# When we're handed literal SQL, ensure it's a SELECT query
SERVER_SIDE_CURSOR_RE = re.compile(r"\s*SELECT", re.I | re.UNICODE)


CACHE_HIT = util.symbol("CACHE_HIT")
CACHE_MISS = util.symbol("CACHE_MISS")
CACHING_DISABLED = util.symbol("CACHING_DISABLED")
NO_CACHE_KEY = util.symbol("NO_CACHE_KEY")
NO_DIALECT_SUPPORT = util.symbol("NO_DIALECT_SUPPORT")


class DefaultDialect(interfaces.Dialect):
 #""Default implementation of Dialect"""

 #tatement_compiler = compiler.SQLCompiler
 #dl_compiler = compiler.DDLCompiler
 #ype_compiler = compiler.GenericTypeCompiler
 #reparer = compiler.IdentifierPreparer
 #upports_alter = True
 #upports_comments = False
 #nline_comments = False
 #se_setinputsizes = False
 #upports_statement_cache = True

    # the first value we'd get for an autoincrement
    # column.
 #efault_sequence_base = 1

    # most DBAPIs happy with this for execute().
    # not cx_oracle.
 #xecute_sequence_format = tuple

 #upports_schemas = True
 #upports_views = True
 #upports_sequences = False
 #equences_optional = False
 #reexecute_autoincrement_sequences = False
 #upports_identity_columns = False
 #ostfetch_lastrowid = True
 #mplicit_returning = False
 #ull_returning = False
 #nsert_executemany_returning = False

 #te_follows_insert = False

 #upports_native_enum = False
 #upports_native_boolean = False
 #on_native_boolean_check_constraint = True

 #upports_simple_order_by_label = True

 #uple_in_values = False

 #onnection_characteristics = util.immutabledict(
 #"isolation_level": characteristics.IsolationLevelCharacteristic()}
 #

 #ngine_config_types = util.immutabledict(
 #
 #"convert_unicode", util.bool_or_str("force")),
 #"pool_timeout", util.asint),
 #"echo", util.bool_or_str("debug")),
 #"echo_pool", util.bool_or_str("debug")),
 #"pool_recycle", util.asint),
 #"pool_size", util.asint),
 #"max_overflow", util.asint),
 #"future", util.asbool),
 #
 #

    # if the NUMERIC type
    # returns decimal.Decimal.
    # *not* the FLOAT type however.
 #upports_native_decimal = False

 #f util.py3k:
 #upports_unicode_statements = True
 #upports_unicode_binds = True
 #eturns_unicode_strings = sqltypes.String.RETURNS_UNICODE
 #escription_encoding = None
 #lse:
 #upports_unicode_statements = False
 #upports_unicode_binds = False
 #eturns_unicode_strings = sqltypes.String.RETURNS_UNKNOWN
 #escription_encoding = "use_encoding"

 #ame = "default"

    # length at which to truncate
    # any identifier.
 #ax_identifier_length = 9999
 #user_defined_max_identifier_length = None

 #solation_level = None

    # sub-categories of max_identifier_length.
    # currently these accommodate for MySQL which allows alias names
    # of 255 but DDL names only of 64.
 #ax_index_name_length = None
 #ax_constraint_name_length = None

 #upports_sane_rowcount = True
 #upports_sane_multi_rowcount = True
 #olspecs = {}
 #efault_paramstyle = "named"

 #upports_default_values = False
 #""dialect supports INSERT... DEFAULT VALUES syntax"""

 #upports_default_metavalue = False
 #""dialect supports INSERT... VALUES (DEFAULT) syntax"""

    # not sure if this is a real thing but the compiler will deliver it
    # if this is the only flag enabled.
 #upports_empty_insert = True
 #""dialect supports INSERT () VALUES ()"""

 #upports_multivalues_insert = False

 #upports_is_distinct_from = True

 #upports_server_side_cursors = False

 #erver_side_cursors = False

    # extra record-level locking features (#4860)
 #upports_for_update_of = False

 #erver_version_info = None

 #efault_schema_name = None

 #onstruct_arguments = None
 #""Optional set of argument specifiers for various SQLAlchemy
 #onstructs, typically schema items.

 #o implement, establish as a series of tuples, as in::

 #onstruct_arguments = [
 #schema.Index, {
 #using": False,
 #where": None,
 #ops": None
 #)
 #

 #f the above construct is established on the PostgreSQL dialect,
 #he :class:`.Index` construct will now accept the keyword arguments
 #`postgresql_using``, ``postgresql_where``, nad ``postgresql_ops``.
 #ny other argument specified to the constructor of :class:`.Index`
 #hich is prefixed with ``postgresql_`` will raise :class:`.ArgumentError`.

 # dialect which does not include a ``construct_arguments`` member will
 #ot participate in the argument validation system.  For such a dialect,
 #ny argument name is accepted by all participating constructs, within
 #he namespace of arguments prefixed with that dialect name.  The rationale
 #ere is so that third-party dialects that haven't yet implemented this
 #eature continue to function in the old way.

 #. versionadded:: 0.9.2

 #. seealso::

 #class:`.DialectKWArgs` - implementing base class which consumes
 #attr:`.DefaultDialect.construct_arguments`


 #""

    # indicates symbol names are
    # UPPERCASEd if they are case insensitive
    # within the database.
    # if this is True, the methods normalize_name()
    # and denormalize_name() must be provided.
 #equires_name_normalize = False

 #eflection_options = ()

 #bapi_exception_translation_map = util.immutabledict()
 #""mapping used in the extremely unusual case that a DBAPI's
 #ublished exceptions don't actually have the __name__ that they
 #re linked towards.

 #. versionadded:: 1.0.5

 #""

 #s_async = False

 #ACHE_HIT = CACHE_HIT
 #ACHE_MISS = CACHE_MISS
 #ACHING_DISABLED = CACHING_DISABLED
 #O_CACHE_KEY = NO_CACHE_KEY
 #O_DIALECT_SUPPORT = NO_DIALECT_SUPPORT

 #util.deprecated_params(
 #onvert_unicode=(
 #1.3",
 #The :paramref:`_sa.create_engine.convert_unicode` parameter "
 #and corresponding dialect-level parameters are deprecated, "
 #and will be removed in a future release.  Modern DBAPIs support "
 #Python Unicode natively and this parameter is unnecessary.",
 #,
 #mpty_in_strategy=(
 #1.4",
 #The :paramref:`_sa.create_engine.empty_in_strategy` keyword is "
 #deprecated, and no longer has any effect.  All IN expressions "
 #are now rendered using "
 #the "expanding parameter" strategy which renders a set of bound'
 #expressions, or an "empty set" SELECT, at statement execution'
 #time.",
 #,
 #ase_sensitive=(
 #1.4",
 #The :paramref:`_sa.create_engine.case_sensitive` parameter "
 #is deprecated and will be removed in a future release. "
 #Applications should work with result column names in a case "
 #sensitive fashion.",
 #,
 #erver_side_cursors=(
 #1.4",
 #The :paramref:`_sa.create_engine.server_side_cursors` parameter "
 #is deprecated and will be removed in a future release.  Please "
 #use the "
 #:paramref:`_engine.Connection.execution_options.stream_results` "
 #parameter.",
 #,
 #
 #ef __init__(
 #elf,
 #onvert_unicode=False,
 #ncoding="utf-8",
 #aramstyle=None,
 #bapi=None,
 #mplicit_returning=None,
 #ase_sensitive=True,
 #upports_native_boolean=None,
 #ax_identifier_length=None,
 #abel_length=None,
        # int() is because the @deprecated_params decorator cannot accommodate
        # the direct reference to the "NO_LINTING" object
 #ompiler_linting=int(compiler.NO_LINTING),
 #erver_side_cursors=False,
 #*kwargs
 #:

 #f not getattr(self, "ported_sqla_06", True):
 #til.warn(
 #The %s dialect is not yet ported to the 0.6 format"
 # self.name
 #

 #f server_side_cursors:
 #f not self.supports_server_side_cursors:
 #aise exc.ArgumentError(
 #Dialect %s does not support server side cursors" % self
 #
 #lse:
 #elf.server_side_cursors = True

 #elf.convert_unicode = convert_unicode
 #elf.encoding = encoding
 #elf.positional = False
 #elf._ischema = None
 #elf.dbapi = dbapi
 #f paramstyle is not None:
 #elf.paramstyle = paramstyle
 #lif self.dbapi is not None:
 #elf.paramstyle = self.dbapi.paramstyle
 #lse:
 #elf.paramstyle = self.default_paramstyle
 #f implicit_returning is not None:
 #elf.implicit_returning = implicit_returning
 #elf.positional = self.paramstyle in ("qmark", "format", "numeric")
 #elf.identifier_preparer = self.preparer(self)
 #elf.type_compiler = self.type_compiler(self)
 #f supports_native_boolean is not None:
 #elf.supports_native_boolean = supports_native_boolean
 #elf.case_sensitive = case_sensitive

 #elf._user_defined_max_identifier_length = max_identifier_length
 #f self._user_defined_max_identifier_length:
 #elf.max_identifier_length = (
 #elf._user_defined_max_identifier_length
 #
 #elf.label_length = label_length
 #elf.compiler_linting = compiler_linting
 #f self.description_encoding == "use_encoding":
 #elf._description_decoder = (
 #rocessors.to_unicode_processor_factory
 #(encoding)
 #lif self.description_encoding is not None:
 #elf._description_decoder = (
 #rocessors.to_unicode_processor_factory
 #(self.description_encoding)
 #elf._encoder = codecs.getencoder(self.encoding)
 #elf._decoder = processors.to_unicode_processor_factory(self.encoding)

 #ef _ensure_has_table_connection(self, arg):

 #f not isinstance(arg, Connection):
 #aise exc.ArgumentError(
 #The argument passed to Dialect.has_table() should be a "
 #%s, got %s. "
 #Additionally, the Dialect.has_table() method is for "
 #internal dialect "
 #use only; please use "
 #``inspect(some_engine).has_table(<tablename>>)`` "
 #for public API use." % (Connection, type(arg))
 #

 #util.memoized_property
 #ef _supports_statement_cache(self):
 #eturn (
 #elf.__class__.__dict__.get("supports_statement_cache", False)
 #s True
 #

 #util.memoized_property
 #ef _type_memos(self):
 #eturn weakref.WeakKeyDictionary()

 #property
 #ef dialect_description(self):
 #eturn self.name + "+" + self.driver

 #property
 #ef supports_sane_rowcount_returning(self):
 #""True if this dialect supports sane rowcount even if RETURNING is
 #n use.

 #or dialects that don't support RETURNING, this is synonymous with
 #`supports_sane_rowcount``.

 #""
 #eturn self.supports_sane_rowcount

 #classmethod
 #ef get_pool_class(cls, url):
 #eturn getattr(cls, "poolclass", pool.QueuePool)

 #ef get_dialect_pool_class(self, url):
 #eturn self.get_pool_class(url)

 #classmethod
 #ef load_provisioning(cls):
 #ackage = ".".join(cls.__module__.split(".")[0:-1])
 #ry:
 #_import__(package + ".provision")
 #xcept ImportError:
 #ass

 #ef initialize(self, connection):
 #ry:
 #elf.server_version_info = self._get_server_version_info(
 #onnection
 #
 #xcept NotImplementedError:
 #elf.server_version_info = None
 #ry:
 #elf.default_schema_name = self._get_default_schema_name(
 #onnection
 #
 #xcept NotImplementedError:
 #elf.default_schema_name = None

 #ry:
 #elf.default_isolation_level = self.get_default_isolation_level(
 #onnection.connection
 #
 #xcept NotImplementedError:
 #elf.default_isolation_level = None

 #f self.returns_unicode_strings is sqltypes.String.RETURNS_UNKNOWN:
 #f util.py3k:
 #aise exc.InvalidRequestError(
 #RETURNS_UNKNOWN is unsupported in Python 3"
 #
 #elf.returns_unicode_strings = self._check_unicode_returns(
 #onnection
 #

 #f (
 #elf.description_encoding is not None
 #nd self._check_unicode_description(connection)
 #:
 #elf._description_decoder = self.description_encoding = None

 #f not self._user_defined_max_identifier_length:
 #ax_ident_length = self._check_max_identifier_length(connection)
 #f max_ident_length:
 #elf.max_identifier_length = max_ident_length

 #f (
 #elf.label_length
 #nd self.label_length > self.max_identifier_length
 #:
 #aise exc.ArgumentError(
 #Label length of %d is greater than this dialect's"
 # maximum identifier length of %d"
 # (self.label_length, self.max_identifier_length)
 #

 #ef on_connect(self):
        # inherits the docstring from interfaces.Dialect.on_connect
 #eturn None

 #ef _check_max_identifier_length(self, connection):
 #""Perform a connection / server version specific check to determine
 #he max_identifier_length.

 #f the dialect's class level max_identifier_length should be used,
 #an return None.

 #. versionadded:: 1.3.9

 #""
 #eturn None

 #ef get_default_isolation_level(self, dbapi_conn):
 #""Given a DBAPI connection, return its isolation level, or
 # default isolation level if one cannot be retrieved.

 #ay be overridden by subclasses in order to provide a
 #fallback" isolation level for databases that cannot reliably
 #etrieve the actual isolation level.

 #y default, calls the :meth:`_engine.Interfaces.get_isolation_level`
 #ethod, propagating any exceptions raised.

 #. versionadded:: 1.3.22

 #""
 #eturn self.get_isolation_level(dbapi_conn)

 #ef _check_unicode_returns(self, connection, additional_tests=None):
        # this now runs in py2k only and will be removed in 2.0; disabled for
        # Python 3 in all cases under #5315
 #f util.py2k and not self.supports_unicode_statements:
 #ast_to = util.binary_type
 #lse:
 #ast_to = util.text_type

 #f self.positional:
 #arameters = self.execute_sequence_format()
 #lse:
 #arameters = {}

 #ef check_unicode(test):
 #tatement = cast_to(expression.select(test).compile(dialect=self))
 #ry:
 #ursor = connection.connection.cursor()
 #onnection._cursor_execute(cursor, statement, parameters)
 #ow = cursor.fetchone()
 #ursor.close()
 #xcept exc.DBAPIError as de:
                # note that _cursor_execute() will have closed the cursor
                # if an exception is thrown.
 #til.warn(
 #Exception attempting to "
 #detect unicode returns: %r" % de
 #
 #eturn False
 #lse:
 #eturn isinstance(row[0], util.text_type)

 #ests = [
            # detect plain VARCHAR
 #xpression.cast(
 #xpression.literal_column("'test plain returns'"),
 #qltypes.VARCHAR(60),
 #,
            # detect if there's an NVARCHAR type with different behavior
            # available
 #xpression.cast(
 #xpression.literal_column("'test unicode returns'"),
 #qltypes.Unicode(60),
 #,
 #

 #f additional_tests:
 #ests += additional_tests

 #esults = {check_unicode(test) for test in tests}

 #f results.issuperset([True, False]):
 #eturn sqltypes.String.RETURNS_CONDITIONAL
 #lse:
 #eturn (
 #qltypes.String.RETURNS_UNICODE
 #f results == {True}
 #lse sqltypes.String.RETURNS_BYTES
 #

 #ef _check_unicode_description(self, connection):
        # all DBAPIs on Py2K return cursor.description as encoded

 #f util.py2k and not self.supports_unicode_statements:
 #ast_to = util.binary_type
 #lse:
 #ast_to = util.text_type

 #ursor = connection.connection.cursor()
 #ry:
 #ursor.execute(
 #ast_to(
 #xpression.select(
 #xpression.literal_column("'x'").label("some_label")
 #.compile(dialect=self)
 #
 #
 #eturn isinstance(cursor.description[0][0], util.text_type)
 #inally:
 #ursor.close()

 #ef type_descriptor(self, typeobj):
 #""Provide a database-specific :class:`.TypeEngine` object, given
 #he generic object which comes from the types module.

 #his method looks for a dictionary called
 #`colspecs`` as a class or instance-level variable,
 #nd passes on to :func:`_types.adapt_type`.

 #""
 #eturn sqltypes.adapt_type(typeobj, self.colspecs)

 #ef has_index(self, connection, table_name, index_name, schema=None):
 #f not self.has_table(connection, table_name, schema=schema):
 #eturn False
 #or idx in self.get_indexes(connection, table_name, schema=schema):
 #f idx["name"] == index_name:
 #eturn True
 #lse:
 #eturn False

 #ef validate_identifier(self, ident):
 #f len(ident) > self.max_identifier_length:
 #aise exc.IdentifierError(
 #Identifier '%s' exceeds maximum length of %d characters"
 # (ident, self.max_identifier_length)
 #

 #ef connect(self, *cargs, **cparams):
        # inherits the docstring from interfaces.Dialect.connect
 #eturn self.dbapi.connect(*cargs, **cparams)

 #ef create_connect_args(self, url):
        # inherits the docstring from interfaces.Dialect.create_connect_args
 #pts = url.translate_connect_args()
 #pts.update(url.query)
 #eturn [[], opts]

 #ef set_engine_execution_options(self, engine, opts):
 #upported_names = set(self.connection_characteristics).intersection(
 #pts
 #
 #f supported_names:
 #haracteristics = util.immutabledict(
 #name, opts[name]) for name in supported_names
 #

 #event.listens_for(engine, "engine_connect")
 #ef set_connection_characteristics(connection, branch):
 #f not branch:
 #elf._set_connection_characteristics(
 #onnection, characteristics
 #

 #ef set_connection_execution_options(self, connection, opts):
 #upported_names = set(self.connection_characteristics).intersection(
 #pts
 #
 #f supported_names:
 #haracteristics = util.immutabledict(
 #name, opts[name]) for name in supported_names
 #
 #elf._set_connection_characteristics(connection, characteristics)

 #ef _set_connection_characteristics(self, connection, characteristics):

 #haracteristic_values = [
 #name, self.connection_characteristics[name], value)
 #or name, value in characteristics.items()
 #

 #f connection.in_transaction():
 #rans_objs = [
 #name, obj)
 #or name, obj, value in characteristic_values
 #f obj.transactional
 #
 #f trans_objs:
 #f connection._is_future:
 #aise exc.InvalidRequestError(
 #This connection has already begun a transaction; "
 #%s may not be altered until transaction end"
 # (", ".join(name for name, obj in trans_objs))
 #
 #lse:
 #til.warn(
 #Connection is already established with a "
 #Transaction; "
 #setting %s may implicitly rollback or "
 #commit "
 #the existing transaction, or have no effect until "
 #next transaction"
 # (", ".join(name for name, obj in trans_objs))
 #

 #bapi_connection = connection.connection.connection
 #or name, characteristic, value in characteristic_values:
 #haracteristic.set_characteristic(self, dbapi_connection, value)
 #onnection.connection._connection_record.finalize_callback.append(
 #unctools.partial(self._reset_characteristics, characteristics)
 #

 #ef _reset_characteristics(self, characteristics, dbapi_connection):
 #or characteristic_name in characteristics:
 #haracteristic = self.connection_characteristics[
 #haracteristic_name
 #
 #haracteristic.reset_characteristic(self, dbapi_connection)

 #ef do_begin(self, dbapi_connection):
 #ass

 #ef do_rollback(self, dbapi_connection):
 #bapi_connection.rollback()

 #ef do_commit(self, dbapi_connection):
 #bapi_connection.commit()

 #ef do_close(self, dbapi_connection):
 #bapi_connection.close()

 #util.memoized_property
 #ef _dialect_specific_select_one(self):
 #eturn str(expression.select(1).compile(dialect=self))

 #ef do_ping(self, dbapi_connection):
 #ursor = None
 #ry:
 #ursor = dbapi_connection.cursor()
 #ry:
 #ursor.execute(self._dialect_specific_select_one)
 #inally:
 #ursor.close()
 #xcept self.dbapi.Error as err:
 #f self.is_disconnect(err, dbapi_connection, cursor):
 #eturn False
 #lse:
 #aise
 #lse:
 #eturn True

 #ef create_xid(self):
 #""Create a random two-phase transaction ID.

 #his id will be passed to do_begin_twophase(), do_rollback_twophase(),
 #o_commit_twophase().  Its format is unspecified.
 #""

 #eturn "_sa_%032x" % random.randint(0, 2 ** 128)

 #ef do_savepoint(self, connection, name):
 #onnection.execute(expression.SavepointClause(name))

 #ef do_rollback_to_savepoint(self, connection, name):
 #onnection.execute(expression.RollbackToSavepointClause(name))

 #ef do_release_savepoint(self, connection, name):
 #onnection.execute(expression.ReleaseSavepointClause(name))

 #ef do_executemany(self, cursor, statement, parameters, context=None):
 #ursor.executemany(statement, parameters)

 #ef do_execute(self, cursor, statement, parameters, context=None):
 #ursor.execute(statement, parameters)

 #ef do_execute_no_params(self, cursor, statement, context=None):
 #ursor.execute(statement)

 #ef is_disconnect(self, e, connection, cursor):
 #eturn False

 #ef reset_isolation_level(self, dbapi_conn):
        # default_isolation_level is read from the first connection
        # after the initial set of 'isolation_level', if any, so is
        # the configured default of this dialect.
 #elf.set_isolation_level(dbapi_conn, self.default_isolation_level)

 #ef normalize_name(self, name):
 #f name is None:
 #eturn None
 #f util.py2k:
 #f isinstance(name, str):
 #ame = name.decode(self.encoding)

 #ame_lower = name.lower()
 #ame_upper = name.upper()

 #f name_upper == name_lower:
            # name has no upper/lower conversion, e.g. non-european characters.
            # return unchanged
 #eturn name
 #lif name_upper == name and not (
 #elf.identifier_preparer._requires_quotes
 #(name_lower):
            # name is all uppercase and doesn't require quoting; normalize
            # to all lower case
 #eturn name_lower
 #lif name_lower == name:
            # name is all lower case, which if denormalized means we need to
            # force quoting on it
 #eturn quoted_name(name, quote=True)
 #lse:
            # name is mixed case, means it will be quoted in SQL when used
            # later, no normalizes
 #eturn name

 #ef denormalize_name(self, name):
 #f name is None:
 #eturn None

 #ame_lower = name.lower()
 #ame_upper = name.upper()

 #f name_upper == name_lower:
            # name has no upper/lower conversion, e.g. non-european characters.
            # return unchanged
 #eturn name
 #lif name_lower == name and not (
 #elf.identifier_preparer._requires_quotes
 #(name_lower):
 #ame = name_upper
 #f util.py2k:
 #f not self.supports_unicode_binds:
 #ame = name.encode(self.encoding)
 #lse:
 #ame = unicode(name)  # noqa
 #eturn name


class _RendersLiteral(object):
 #ef literal_processor(self, dialect):
 #ef process(value):
 #eturn "'%s'" % value

 #eturn process


class _StrDateTime(_RendersLiteral, sqltypes.DateTime):
 #ass


class _StrDate(_RendersLiteral, sqltypes.Date):
 #ass


class _StrTime(_RendersLiteral, sqltypes.Time):
 #ass


class StrCompileDialect(DefaultDialect):

 #tatement_compiler = compiler.StrSQLCompiler
 #dl_compiler = compiler.DDLCompiler
 #ype_compiler = compiler.StrSQLTypeCompiler
 #reparer = compiler.IdentifierPreparer

 #upports_statement_cache = True

 #upports_identity_columns = True

 #upports_sequences = True
 #equences_optional = True
 #reexecute_autoincrement_sequences = False
 #mplicit_returning = False

 #upports_native_boolean = True

 #upports_multivalues_insert = True
 #upports_simple_order_by_label = True

 #olspecs = {
 #qltypes.DateTime: _StrDateTime,
 #qltypes.Date: _StrDate,
 #qltypes.Time: _StrTime,
 #


class DefaultExecutionContext(interfaces.ExecutionContext):
 #sinsert = False
 #supdate = False
 #sdelete = False
 #s_crud = False
 #s_text = False
 #sddl = False
 #xecutemany = False
 #ompiled = None
 #tatement = None
 #esult_column_struct = None
 #eturned_default_rows = None
 #xecution_options = util.immutabledict()

 #nclude_set_input_sizes = None
 #xclude_set_input_sizes = None

 #ursor_fetch_strategy = _cursor._DEFAULT_FETCH

 #ache_stats = None
 #nvoked_statement = None

 #is_implicit_returning = False
 #is_explicit_returning = False
 #is_future_result = False
 #is_server_side = False

 #soft_closed = False

    # a hook for SQLite's translation of
    # result column names
    # NOTE: pyhive is using this hook, can't remove it :(
 #translate_colname = None

 #expanded_parameters = util.immutabledict()

 #ache_hit = NO_CACHE_KEY

 #classmethod
 #ef _init_ddl(
 #ls,
 #ialect,
 #onnection,
 #bapi_connection,
 #xecution_options,
 #ompiled_ddl,
 #:
 #""Initialize execution context for a DDLElement construct."""

 #elf = cls.__new__(cls)
 #elf.root_connection = connection
 #elf._dbapi_connection = dbapi_connection
 #elf.dialect = connection.dialect

 #elf.compiled = compiled = compiled_ddl
 #elf.isddl = True

 #elf.execution_options = execution_options

 #elf._is_future_result = (
 #onnection._is_future
 #r self.execution_options.get("future_result", False)
 #

 #elf.unicode_statement = util.text_type(compiled)
 #f compiled.schema_translate_map:
 #chema_translate_map = self.execution_options.get(
 #schema_translate_map", {}
 #

 #st = compiled.preparer._render_schema_translates
 #elf.unicode_statement = rst(
 #elf.unicode_statement, schema_translate_map
 #

 #f not dialect.supports_unicode_statements:
 #elf.statement = dialect._encoder(self.unicode_statement)[0]
 #lse:
 #elf.statement = self.unicode_statement

 #elf.cursor = self.create_cursor()
 #elf.compiled_parameters = []

 #f dialect.positional:
 #elf.parameters = [dialect.execute_sequence_format()]
 #lse:
 #elf.parameters = [{}]

 #eturn self

 #classmethod
 #ef _init_compiled(
 #ls,
 #ialect,
 #onnection,
 #bapi_connection,
 #xecution_options,
 #ompiled,
 #arameters,
 #nvoked_statement,
 #xtracted_parameters,
 #ache_hit=CACHING_DISABLED,
 #:
 #""Initialize execution context for a Compiled construct."""

 #elf = cls.__new__(cls)
 #elf.root_connection = connection
 #elf._dbapi_connection = dbapi_connection
 #elf.dialect = connection.dialect
 #elf.extracted_parameters = extracted_parameters
 #elf.invoked_statement = invoked_statement
 #elf.compiled = compiled
 #elf.cache_hit = cache_hit

 #elf.execution_options = execution_options

 #elf._is_future_result = (
 #onnection._is_future
 #r self.execution_options.get("future_result", False)
 #

 #elf.result_column_struct = (
 #ompiled._result_columns,
 #ompiled._ordered_columns,
 #ompiled._textual_ordered_columns,
 #ompiled._loose_column_name_matching,
 #
 #elf.isinsert = compiled.isinsert
 #elf.isupdate = compiled.isupdate
 #elf.isdelete = compiled.isdelete
 #elf.is_text = compiled.isplaintext

 #f self.isinsert or self.isupdate or self.isdelete:
 #elf.is_crud = True
 #elf._is_explicit_returning = bool(compiled.statement._returning)
 #elf._is_implicit_returning = bool(
 #ompiled.returning and not compiled.statement._returning
 #

 #f not parameters:
 #elf.compiled_parameters = [
 #ompiled.construct_params(
 #xtracted_parameters=extracted_parameters
 #
 #
 #lse:
 #elf.compiled_parameters = [
 #ompiled.construct_params(
 #,
 #group_number=grp,
 #xtracted_parameters=extracted_parameters,
 #
 #or grp, m in enumerate(parameters)
 #

 #elf.executemany = len(parameters) > 1

        # this must occur before create_cursor() since the statement
        # has to be regexed in some cases for server side cursor
 #f util.py2k:
 #elf.unicode_statement = util.text_type(compiled.string)
 #lse:
 #elf.unicode_statement = compiled.string

 #elf.cursor = self.create_cursor()

 #f self.compiled.insert_prefetch or self.compiled.update_prefetch:
 #f self.executemany:
 #elf._process_executemany_defaults()
 #lse:
 #elf._process_executesingle_defaults()

 #rocessors = compiled._bind_processors

 #f compiled.literal_execute_params or compiled.post_compile_params:
 #f self.executemany:
 #aise exc.InvalidRequestError(
 #'literal_execute' or 'expanding' parameters can't be "
 #used with executemany()"
 #

 #xpanded_state = compiled._process_parameters_for_postcompile(
 #elf.compiled_parameters[0]
 #

            # re-assign self.unicode_statement
 #elf.unicode_statement = expanded_state.statement

            # used by set_input_sizes() which is needed for Oracle
 #elf._expanded_parameters = expanded_state.parameter_expansion

 #rocessors = dict(processors)
 #rocessors.update(expanded_state.processors)
 #ositiontup = expanded_state.positiontup
 #lif compiled.positional:
 #ositiontup = self.compiled.positiontup

 #f compiled.schema_translate_map:
 #chema_translate_map = self.execution_options.get(
 #schema_translate_map", {}
 #
 #st = compiled.preparer._render_schema_translates
 #elf.unicode_statement = rst(
 #elf.unicode_statement, schema_translate_map
 #

        # final self.unicode_statement is now assigned, encode if needed
        # by dialect
 #f not dialect.supports_unicode_statements:
 #elf.statement = self.unicode_statement.encode(
 #elf.dialect.encoding
 #
 #lse:
 #elf.statement = self.unicode_statement

        # Convert the dictionary of bind parameter values
        # into a dict or list to be sent to the DBAPI's
        # execute() or executemany() method.
 #arameters = []
 #f compiled.positional:
 #or compiled_params in self.compiled_parameters:
 #aram = [
 #rocessors[key](compiled_params[key])
 #f key in processors
 #lse compiled_params[key]
 #or key in positiontup
 #
 #arameters.append(dialect.execute_sequence_format(param))
 #lse:
 #ncode = not dialect.supports_unicode_statements
 #f encode:
 #ncoder = dialect._encoder
 #or compiled_params in self.compiled_parameters:

 #f encode:
 #aram = {
 #ncoder(key)[0]: processors[key](compiled_params[key])
 #f key in processors
 #lse compiled_params[key]
 #or key in compiled_params
 #
 #lse:
 #aram = {
 #ey: processors[key](compiled_params[key])
 #f key in processors
 #lse compiled_params[key]
 #or key in compiled_params
 #

 #arameters.append(param)

 #elf.parameters = dialect.execute_sequence_format(parameters)

 #eturn self

 #classmethod
 #ef _init_statement(
 #ls,
 #ialect,
 #onnection,
 #bapi_connection,
 #xecution_options,
 #tatement,
 #arameters,
 #:
 #""Initialize execution context for a string SQL statement."""

 #elf = cls.__new__(cls)
 #elf.root_connection = connection
 #elf._dbapi_connection = dbapi_connection
 #elf.dialect = connection.dialect
 #elf.is_text = True

 #elf.execution_options = execution_options

 #elf._is_future_result = (
 #onnection._is_future
 #r self.execution_options.get("future_result", False)
 #

 #f not parameters:
 #f self.dialect.positional:
 #elf.parameters = [dialect.execute_sequence_format()]
 #lse:
 #elf.parameters = [{}]
 #lif isinstance(parameters[0], dialect.execute_sequence_format):
 #elf.parameters = parameters
 #lif isinstance(parameters[0], dict):
 #f dialect.supports_unicode_statements:
 #elf.parameters = parameters
 #lse:
 #elf.parameters = [
 #dialect._encoder(k)[0]: d[k] for k in d}
 #or d in parameters
 # or [{}]
 #lse:
 #elf.parameters = [
 #ialect.execute_sequence_format(p) for p in parameters
 #

 #elf.executemany = len(parameters) > 1

 #f not dialect.supports_unicode_statements and isinstance(
 #tatement, util.text_type
 #:
 #elf.unicode_statement = statement
 #elf.statement = dialect._encoder(statement)[0]
 #lse:
 #elf.statement = self.unicode_statement = statement

 #elf.cursor = self.create_cursor()
 #eturn self

 #classmethod
 #ef _init_default(
 #ls, dialect, connection, dbapi_connection, execution_options
 #:
 #""Initialize execution context for a ColumnDefault construct."""

 #elf = cls.__new__(cls)
 #elf.root_connection = connection
 #elf._dbapi_connection = dbapi_connection
 #elf.dialect = connection.dialect

 #elf.execution_options = execution_options

 #elf._is_future_result = (
 #onnection._is_future
 #r self.execution_options.get("future_result", False)
 #

 #elf.cursor = self.create_cursor()
 #eturn self

 #ef _get_cache_stats(self):
 #f self.compiled is None:
 #eturn "raw sql"

 #ow = util.perf_counter()

 #h = self.cache_hit

 #f ch is NO_CACHE_KEY:
 #eturn "no key %.5fs" % (now - self.compiled._gen_time,)
 #lif ch is CACHE_HIT:
 #eturn "cached since %.4gs ago" % (now - self.compiled._gen_time,)
 #lif ch is CACHE_MISS:
 #eturn "generated in %.5fs" % (now - self.compiled._gen_time,)
 #lif ch is CACHING_DISABLED:
 #eturn "caching disabled %.5fs" % (now - self.compiled._gen_time,)
 #lif ch is NO_DIALECT_SUPPORT:
 #eturn "dialect %s+%s does not support caching %.5fs" % (
 #elf.dialect.name,
 #elf.dialect.driver,
 #ow - self.compiled._gen_time,
 #
 #lse:
 #eturn "unknown"

 #util.memoized_property
 #ef identifier_preparer(self):
 #f self.compiled:
 #eturn self.compiled.preparer
 #lif "schema_translate_map" in self.execution_options:
 #eturn self.dialect.identifier_preparer._with_schema_translate(
 #elf.execution_options["schema_translate_map"]
 #
 #lse:
 #eturn self.dialect.identifier_preparer

 #util.memoized_property
 #ef engine(self):
 #eturn self.root_connection.engine

 #util.memoized_property
 #ef postfetch_cols(self):
 #eturn self.compiled.postfetch

 #util.memoized_property
 #ef prefetch_cols(self):
 #f self.isinsert:
 #eturn self.compiled.insert_prefetch
 #lif self.isupdate:
 #eturn self.compiled.update_prefetch
 #lse:
 #eturn ()

 #util.memoized_property
 #ef returning_cols(self):
 #elf.compiled.returning

 #util.memoized_property
 #ef no_parameters(self):
 #eturn self.execution_options.get("no_parameters", False)

 #util.memoized_property
 #ef should_autocommit(self):
 #utocommit = self.execution_options.get(
 #autocommit",
 #ot self.compiled
 #nd self.statement
 #nd expression.PARSE_AUTOCOMMIT
 #r False,
 #

 #f autocommit is expression.PARSE_AUTOCOMMIT:
 #eturn self.should_autocommit_text(self.unicode_statement)
 #lse:
 #eturn autocommit

 #ef _execute_scalar(self, stmt, type_, parameters=None):
 #""Execute a string statement on the current cursor, returning a
 #calar result.

 #sed to fire off sequences, default phrases, and "select lastrowid"
 #ypes of statements individually or in the context of a parent INSERT
 #r UPDATE statement.

 #""

 #onn = self.root_connection
 #f (
 #sinstance(stmt, util.text_type)
 #nd not self.dialect.supports_unicode_statements
 #:
 #tmt = self.dialect._encoder(stmt)[0]

 #f "schema_translate_map" in self.execution_options:
 #chema_translate_map = self.execution_options.get(
 #schema_translate_map", {}
 #

 #st = self.identifier_preparer._render_schema_translates
 #tmt = rst(stmt, schema_translate_map)

 #f not parameters:
 #f self.dialect.positional:
 #arameters = self.dialect.execute_sequence_format()
 #lse:
 #arameters = {}

 #onn._cursor_execute(self.cursor, stmt, parameters, context=self)
 # = self.cursor.fetchone()[0]
 #f type_ is not None:
            # apply type post processors to the result
 #roc = type_._cached_result_processor(
 #elf.dialect, self.cursor.description[0][1]
 #
 #f proc:
 #eturn proc(r)
 #eturn r

 #property
 #ef connection(self):
 #onn = self.root_connection
 #f conn._is_future:
 #eturn conn
 #lse:
 #eturn conn._branch()

 #ef should_autocommit_text(self, statement):
 #eturn AUTOCOMMIT_REGEXP.match(statement)

 #ef _use_server_side_cursor(self):
 #f not self.dialect.supports_server_side_cursors:
 #eturn False

 #f self.dialect.server_side_cursors:
            # this is deprecated
 #se_server_side = self.execution_options.get(
 #stream_results", True
 # and (
 #
 #elf.compiled
 #nd isinstance(
 #elf.compiled.statement, expression.Selectable
 #
 #r (
 #
 #ot self.compiled
 #r isinstance(
 #elf.compiled.statement, expression.TextClause
 #
 #
 #nd self.unicode_statement
 #nd SERVER_SIDE_CURSOR_RE.match(self.unicode_statement)
 #
 #
 #
 #lse:
 #se_server_side = self.execution_options.get(
 #stream_results", False
 #

 #eturn use_server_side

 #ef create_cursor(self):
 #f (
            # inlining initial preference checks for SS cursors
 #elf.dialect.supports_server_side_cursors
 #nd (
 #elf.execution_options.get("stream_results", False)
 #r (
 #elf.dialect.server_side_cursors
 #nd self._use_server_side_cursor()
 #
 #
 #:
 #elf._is_server_side = True
 #eturn self.create_server_side_cursor()
 #lse:
 #elf._is_server_side = False
 #eturn self.create_default_cursor()

 #ef create_default_cursor(self):
 #eturn self._dbapi_connection.cursor()

 #ef create_server_side_cursor(self):
 #aise NotImplementedError()

 #ef pre_exec(self):
 #ass

 #ef get_out_parameter_values(self, names):
 #aise NotImplementedError(
 #This dialect does not support OUT parameters"
 #

 #ef post_exec(self):
 #ass

 #ef get_result_processor(self, type_, colname, coltype):
 #""Return a 'result processor' for a given type as present in
 #ursor.description.

 #his has a default implementation that dialects can override
 #or context-sensitive result type handling.

 #""
 #eturn type_._cached_result_processor(self.dialect, coltype)

 #ef get_lastrowid(self):
 #""return self.cursor.lastrowid, or equivalent, after an INSERT.

 #his may involve calling special cursor functions, issuing a new SELECT
 #n the cursor (or a new one), or returning a stored value that was
 #alculated within post_exec().

 #his function will only be called for dialects which support "implicit"
 #rimary key generation, keep preexecute_autoincrement_sequences set to
 #alse, and when no explicit id value was bound to the statement.

 #he function is called once for an INSERT statement that would need to
 #eturn the last inserted primary key for those dialects that make use
 #f the lastrowid concept.  In these cases, it is called directly after
 #meth:`.ExecutionContext.post_exec`.

 #""
 #eturn self.cursor.lastrowid

 #ef handle_dbapi_exception(self, e):
 #ass

 #property
 #ef rowcount(self):
 #eturn self.cursor.rowcount

 #ef supports_sane_rowcount(self):
 #eturn self.dialect.supports_sane_rowcount

 #ef supports_sane_multi_rowcount(self):
 #eturn self.dialect.supports_sane_multi_rowcount

 #ef _setup_result_proxy(self):
 #f self.is_crud or self.is_text:
 #esult = self._setup_dml_or_text_result()
 #lse:
 #trategy = self.cursor_fetch_strategy
 #f self._is_server_side and strategy is _cursor._DEFAULT_FETCH:
 #trategy = _cursor.BufferedRowCursorFetchStrategy(
 #elf.cursor, self.execution_options
 #
 #ursor_description = (
 #trategy.alternate_cursor_description
 #r self.cursor.description
 #
 #f cursor_description is None:
 #trategy = _cursor._NO_CURSOR_DQL

 #f self._is_future_result:
 #f self.root_connection.should_close_with_result:
 #aise exc.InvalidRequestError(
 #can't use future_result=True with close_with_result"
 #
 #esult = _cursor.CursorResult(
 #elf, strategy, cursor_description
 #
 #lse:
 #esult = _cursor.LegacyCursorResult(
 #elf, strategy, cursor_description
 #

 #f (
 #elf.compiled
 #nd not self.isddl
 #nd self.compiled.has_out_parameters
 #:
 #elf._setup_out_parameters(result)

 #elf._soft_closed = result._soft_closed

 #eturn result

 #ef _setup_out_parameters(self, result):

 #ut_bindparams = [
 #param, name)
 #or param, name in self.compiled.bind_names.items()
 #f param.isoutparam
 #
 #ut_parameters = {}

 #or bindparam, raw_value in zip(
 #param for param, name in out_bindparams],
 #elf.get_out_parameter_values(
 #name for param, name in out_bindparams]
 #,
 #:

 #ype_ = bindparam.type
 #mpl_type = type_.dialect_impl(self.dialect)
 #bapi_type = impl_type.get_dbapi_type(self.dialect.dbapi)
 #esult_processor = impl_type.result_processor(
 #elf.dialect, dbapi_type
 #
 #f result_processor is not None:
 #aw_value = result_processor(raw_value)
 #ut_parameters[bindparam.key] = raw_value

 #esult.out_parameters = out_parameters

 #ef _setup_dml_or_text_result(self):
 #f self.isinsert:
 #f self.compiled.postfetch_lastrowid:
 #elf.inserted_primary_key_rows = (
 #elf._setup_ins_pk_from_lastrowid()
 #
            # else if not self._is_implicit_returning,
            # the default inserted_primary_key_rows accessor will
            # return an "empty" primary key collection when accessed.

 #trategy = self.cursor_fetch_strategy
 #f self._is_server_side and strategy is _cursor._DEFAULT_FETCH:
 #trategy = _cursor.BufferedRowCursorFetchStrategy(
 #elf.cursor, self.execution_options
 #
 #ursor_description = (
 #trategy.alternate_cursor_description or self.cursor.description
 #
 #f cursor_description is None:
 #trategy = _cursor._NO_CURSOR_DML

 #f self._is_future_result:
 #esult = _cursor.CursorResult(self, strategy, cursor_description)
 #lse:
 #esult = _cursor.LegacyCursorResult(
 #elf, strategy, cursor_description
 #

 #f self.isinsert:
 #f self._is_implicit_returning:
 #ows = result.all()

 #elf.returned_default_rows = rows

 #elf.inserted_primary_key_rows = (
 #elf._setup_ins_pk_from_implicit_returning(result, rows)
 #

                # test that it has a cursor metadata that is accurate. the
                # first row will have been fetched and current assumptions
                # are that the result has only one row, until executemany()
                # support is added here.
 #ssert result._metadata.returns_rows
 #esult._soft_close()
 #lif not self._is_explicit_returning:
 #esult._soft_close()

                # we assume here the result does not return any rows.
                # *usually*, this will be true.  However, some dialects
                # such as that of MSSQL/pyodbc need to SELECT a post fetch
                # function so this is not necessarily true.
                # assert not result.returns_rows

 #lif self.isupdate and self._is_implicit_returning:
 #ow = result.fetchone()
 #elf.returned_default_rows = [row]
 #esult._soft_close()

            # test that it has a cursor metadata that is accurate.
            # the rows have all been fetched however.
 #ssert result._metadata.returns_rows

 #lif not result._metadata.returns_rows:
            # no results, get rowcount
            # (which requires open cursor on some drivers
            # such as kintersbasdb, mxodbc)
 #esult.rowcount
 #esult._soft_close()
 #eturn result

 #util.memoized_property
 #ef inserted_primary_key_rows(self):
        # if no specific "get primary key" strategy was set up
        # during execution, return a "default" primary key based
        # on what's in the compiled_parameters and nothing else.
 #eturn self._setup_ins_pk_from_empty()

 #ef _setup_ins_pk_from_lastrowid(self):

 #etter = self.compiled._inserted_primary_key_from_lastrowid_getter

 #astrowid = self.get_lastrowid()
 #eturn [getter(lastrowid, self.compiled_parameters[0])]

 #ef _setup_ins_pk_from_empty(self):
 #etter = self.compiled._inserted_primary_key_from_lastrowid_getter

 #eturn [getter(None, param) for param in self.compiled_parameters]

 #ef _setup_ins_pk_from_implicit_returning(self, result, rows):

 #f not rows:
 #eturn []

 #etter = self.compiled._inserted_primary_key_from_returning_getter
 #ompiled_params = self.compiled_parameters

 #eturn [
 #etter(row, param) for row, param in zip(rows, compiled_params)
 #

 #ef lastrow_has_defaults(self):
 #eturn (self.isinsert or self.isupdate) and bool(
 #elf.compiled.postfetch
 #

 #ef _set_input_sizes(self):
 #""Given a cursor and ClauseParameters, call the appropriate
 #tyle of ``setinputsizes()`` on the cursor, using DB-API types
 #rom the bind parameter's ``TypeEngine`` objects.

 #his method only called by those dialects which require it,
 #urrently cx_oracle.

 #""
 #f self.isddl or self.is_text:
 #eturn

 #nputsizes = self.compiled._get_set_input_sizes_lookup(
 #nclude_types=self.include_set_input_sizes,
 #xclude_types=self.exclude_set_input_sizes,
 #

 #f inputsizes is None:
 #eturn

 #f self.dialect._has_events:
 #nputsizes = dict(inputsizes)
 #elf.dialect.dispatch.do_setinputsizes(
 #nputsizes, self.cursor, self.statement, self.parameters, self
 #

 #as_escaped_names = bool(self.compiled.escaped_bind_names)
 #f has_escaped_names:
 #scaped_bind_names = self.compiled.escaped_bind_names

 #f self.dialect.positional:
 #tems = [
 #key, self.compiled.binds[key])
 #or key in self.compiled.positiontup
 #
 #lse:
 #tems = [
 #key, bindparam)
 #or bindparam, key in self.compiled.bind_names.items()
 #

 #eneric_inputsizes = []
 #or key, bindparam in items:
 #f bindparam in self.compiled.literal_execute_params:
 #ontinue

 #f key in self._expanded_parameters:
 #f bindparam.type._is_tuple_type:
 #um = len(bindparam.type.types)
 #btypes = inputsizes[bindparam]
 #eneric_inputsizes.extend(
 #
 #
 #scaped_bind_names.get(paramname, paramname)
 #f has_escaped_names
 #lse paramname
 #,
 #btypes[idx % num],
 #indparam.type.types[idx % num],
 #
 #or idx, paramname in enumerate(
 #elf._expanded_parameters[key]
 #
 #
 #lse:
 #btype = inputsizes.get(bindparam, None)
 #eneric_inputsizes.extend(
 #
 #
 #scaped_bind_names.get(paramname, paramname)
 #f has_escaped_names
 #lse paramname
 #,
 #btype,
 #indparam.type,
 #
 #or paramname in self._expanded_parameters[key]
 #
 #lse:
 #btype = inputsizes.get(bindparam, None)

 #scaped_name = (
 #scaped_bind_names.get(key, key)
 #f has_escaped_names
 #lse key
 #

 #eneric_inputsizes.append(
 #escaped_name, dbtype, bindparam.type)
 #
 #ry:
 #elf.dialect.do_set_input_sizes(
 #elf.cursor, generic_inputsizes, self
 #
 #xcept BaseException as e:
 #elf.root_connection._handle_dbapi_exception(
 #, None, None, None, self
 #

 #ef _exec_default(self, column, default, type_):
 #f default.is_sequence:
 #eturn self.fire_sequence(default, type_)
 #lif default.is_callable:
 #elf.current_column = column
 #eturn default.arg(self)
 #lif default.is_clause_element:
 #eturn self._exec_default_clause_element(column, default, type_)
 #lse:
 #eturn default.arg

 #ef _exec_default_clause_element(self, column, default, type_):
        # execute a default that's a complete clause element.  Here, we have
        # to re-implement a miniature version of the compile->parameters->
        # cursor.execute() sequence, since we don't want to modify the state
        # of the connection  / result in progress or create new connection/
        # result objects etc.
        # .. versionchanged:: 1.4

 #f not default._arg_is_typed:
 #efault_arg = expression.type_coerce(default.arg, type_)
 #lse:
 #efault_arg = default.arg
 #ompiled = expression.select(default_arg).compile(dialect=self.dialect)
 #ompiled_params = compiled.construct_params()
 #rocessors = compiled._bind_processors
 #f compiled.positional:
 #ositiontup = compiled.positiontup
 #arameters = self.dialect.execute_sequence_format(
 #
 #rocessors[key](compiled_params[key])
 #f key in processors
 #lse compiled_params[key]
 #or key in positiontup
 #
 #
 #lse:
 #arameters = dict(
 #
 #ey,
 #rocessors[key](compiled_params[key])
 #f key in processors
 #lse compiled_params[key],
 #
 #or key in compiled_params
 #
 #eturn self._execute_scalar(
 #til.text_type(compiled), type_, parameters=parameters
 #

 #urrent_parameters = None
 #""A dictionary of parameters applied to the current row.

 #his attribute is only available in the context of a user-defined default
 #eneration function, e.g. as described at :ref:`context_default_functions`.
 #t consists of a dictionary which includes entries for each column/value
 #air that is to be part of the INSERT or UPDATE statement. The keys of the
 #ictionary will be the key value of each :class:`_schema.Column`,
 #hich is usually
 #ynonymous with the name.

 #ote that the :attr:`.DefaultExecutionContext.current_parameters` attribute
 #oes not accommodate for the "multi-values" feature of the
 #meth:`_expression.Insert.values` method.  The
 #meth:`.DefaultExecutionContext.get_current_parameters` method should be
 #referred.

 #. seealso::

 #meth:`.DefaultExecutionContext.get_current_parameters`

 #ref:`context_default_functions`

 #""

 #ef get_current_parameters(self, isolate_multiinsert_groups=True):
 #""Return a dictionary of parameters applied to the current row.

 #his method can only be used in the context of a user-defined default
 #eneration function, e.g. as described at
 #ref:`context_default_functions`. When invoked, a dictionary is
 #eturned which includes entries for each column/value pair that is part
 #f the INSERT or UPDATE statement. The keys of the dictionary will be
 #he key value of each :class:`_schema.Column`,
 #hich is usually synonymous
 #ith the name.

 #param isolate_multiinsert_groups=True: indicates that multi-valued
 #NSERT constructs created using :meth:`_expression.Insert.values`
 #hould be
 #andled by returning only the subset of parameters that are local
 #o the current column default invocation.   When ``False``, the
 #aw parameters of the statement are returned including the
 #aming convention used in the case of multi-valued INSERT.

 #. versionadded:: 1.2  added
 #meth:`.DefaultExecutionContext.get_current_parameters`
 #hich provides more functionality over the existing
 #attr:`.DefaultExecutionContext.current_parameters`
 #ttribute.

 #. seealso::

 #attr:`.DefaultExecutionContext.current_parameters`

 #ref:`context_default_functions`

 #""
 #ry:
 #arameters = self.current_parameters
 #olumn = self.current_column
 #xcept AttributeError:
 #aise exc.InvalidRequestError(
 #get_current_parameters() can only be invoked in the "
 #context of a Python side column default function"
 #

 #ompile_state = self.compiled.compile_state
 #f (
 #solate_multiinsert_groups
 #nd self.isinsert
 #nd compile_state._has_multi_parameters
 #:
 #f column._is_multiparam_column:
 #ndex = column.index + 1
 # = {column.original.key: parameters[column.key]}
 #lse:
 # = {column.key: parameters[column.key]}
 #ndex = 0
 #eys = compile_state._dict_parameters.keys()
 #.update(
 #key, parameters["%s_m%d" % (key, index)]) for key in keys
 #
 #eturn d
 #lse:
 #eturn parameters

 #ef get_insert_default(self, column):
 #f column.default is None:
 #eturn None
 #lse:
 #eturn self._exec_default(column, column.default, column.type)

 #ef get_update_default(self, column):
 #f column.onupdate is None:
 #eturn None
 #lse:
 #eturn self._exec_default(column, column.onupdate, column.type)

 #ef _process_executemany_defaults(self):
 #ey_getter = self.compiled._key_getters_for_crud_column[2]

 #calar_defaults = {}

 #nsert_prefetch = self.compiled.insert_prefetch
 #pdate_prefetch = self.compiled.update_prefetch

        # pre-determine scalar Python-side defaults
        # to avoid many calls of get_insert_default()/
        # get_update_default()
 #or c in insert_prefetch:
 #f c.default and c.default.is_scalar:
 #calar_defaults[c] = c.default.arg
 #or c in update_prefetch:
 #f c.onupdate and c.onupdate.is_scalar:
 #calar_defaults[c] = c.onupdate.arg

 #or param in self.compiled_parameters:
 #elf.current_parameters = param
 #or c in insert_prefetch:
 #f c in scalar_defaults:
 #al = scalar_defaults[c]
 #lse:
 #al = self.get_insert_default(c)
 #f val is not None:
 #aram[key_getter(c)] = val
 #or c in update_prefetch:
 #f c in scalar_defaults:
 #al = scalar_defaults[c]
 #lse:
 #al = self.get_update_default(c)
 #f val is not None:
 #aram[key_getter(c)] = val

 #el self.current_parameters

 #ef _process_executesingle_defaults(self):
 #ey_getter = self.compiled._key_getters_for_crud_column[2]
 #elf.current_parameters = (
 #ompiled_parameters
 # = self.compiled_parameters[0]

 #or c in self.compiled.insert_prefetch:
 #f c.default and not c.default.is_sequence and c.default.is_scalar:
 #al = c.default.arg
 #lse:
 #al = self.get_insert_default(c)

 #f val is not None:
 #ompiled_parameters[key_getter(c)] = val

 #or c in self.compiled.update_prefetch:
 #al = self.get_update_default(c)

 #f val is not None:
 #ompiled_parameters[key_getter(c)] = val
 #el self.current_parameters


DefaultDialect.execution_ctx_cls = DefaultExecutionContext
