# sqlalchemy/engine/events.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php


from .base import Engine
from .interfaces import Connectable
from .interfaces import Dialect
from .. import event
from .. import exc


class ConnectionEvents(event.Events):
 #""Available events for :class:`.Connectable`, which includes
 #class:`_engine.Connection` and :class:`_engine.Engine`.

 #he methods here define the name of an event as well as the names of
 #embers that are passed to listener functions.

 #n event listener can be associated with any :class:`.Connectable`
 #lass or instance, such as an :class:`_engine.Engine`, e.g.::

 #rom sqlalchemy import event, create_engine

 #ef before_cursor_execute(conn, cursor, statement, parameters, context,
 #xecutemany):
 #og.info("Received statement: %s", statement)

 #ngine = create_engine('postgresql://scott:tiger@localhost/test')
 #vent.listen(engine, "before_cursor_execute", before_cursor_execute)

 #r with a specific :class:`_engine.Connection`::

 #ith engine.begin() as conn:
 #event.listens_for(conn, 'before_cursor_execute')
 #ef before_cursor_execute(conn, cursor, statement, parameters,
 #ontext, executemany):
 #og.info("Received statement: %s", statement)

 #hen the methods are called with a `statement` parameter, such as in
 #meth:`.after_cursor_execute` or :meth:`.before_cursor_execute`,
 #he statement is the exact SQL string that was prepared for transmission
 #o the DBAPI ``cursor`` in the connection's :class:`.Dialect`.

 #he :meth:`.before_execute` and :meth:`.before_cursor_execute`
 #vents can also be established with the ``retval=True`` flag, which
 #llows modification of the statement and parameters to be sent
 #o the database.  The :meth:`.before_cursor_execute` event is
 #articularly useful here to add ad-hoc string transformations, such
 #s comments, to all executions::

 #rom sqlalchemy.engine import Engine
 #rom sqlalchemy import event

 #event.listens_for(Engine, "before_cursor_execute", retval=True)
 #ef comment_sql_calls(conn, cursor, statement, parameters,
 #ontext, executemany):
 #tatement = statement + " -- some comment"
 #eturn statement, parameters

 #. note:: :class:`_events.ConnectionEvents` can be established on any
 #ombination of :class:`_engine.Engine`, :class:`_engine.Connection`,
 #s well
 #s instances of each of those classes.  Events across all
 #our scopes will fire off for a given instance of
 #class:`_engine.Connection`.  However, for performance reasons, the
 #class:`_engine.Connection` object determines at instantiation time
 #hether or not its parent :class:`_engine.Engine` has event listeners
 #stablished.   Event listeners added to the :class:`_engine.Engine`
 #lass or to an instance of :class:`_engine.Engine`
 #after* the instantiation
 #f a dependent :class:`_engine.Connection` instance will usually
 #not* be available on that :class:`_engine.Connection` instance.
 #he newly
 #dded listeners will instead take effect for
 #class:`_engine.Connection`
 #nstances created subsequent to those event listeners being
 #stablished on the parent :class:`_engine.Engine` class or instance.

 #param retval=False: Applies to the :meth:`.before_execute` and
 #meth:`.before_cursor_execute` events only.  When True, the
 #ser-defined event function must have a return value, which
 #s a tuple of parameters that replace the given statement
 #nd parameters.  See those methods for a description of
 #pecific return arguments.

 #""

 #target_class_doc = "SomeEngine"
 #dispatch_target = Connectable

 #classmethod
 #ef _listen(cls, event_key, retval=False):
 #arget, identifier, fn = (
 #vent_key.dispatch_target,
 #vent_key.identifier,
 #vent_key._listen_fn,
 #

 #arget._has_events = True

 #f not retval:
 #f identifier == "before_execute":
 #rig_fn = fn

 #ef wrap_before_execute(
 #onn, clauseelement, multiparams, params, execution_options
 #:
 #rig_fn(
 #onn,
 #lauseelement,
 #ultiparams,
 #arams,
 #xecution_options,
 #
 #eturn clauseelement, multiparams, params

 #n = wrap_before_execute
 #lif identifier == "before_cursor_execute":
 #rig_fn = fn

 #ef wrap_before_cursor_execute(
 #onn, cursor, statement, parameters, context, executemany
 #:
 #rig_fn(
 #onn,
 #ursor,
 #tatement,
 #arameters,
 #ontext,
 #xecutemany,
 #
 #eturn statement, parameters

 #n = wrap_before_cursor_execute
 #lif retval and identifier not in (
 #before_execute",
 #before_cursor_execute",
 #handle_error",
 #:
 #aise exc.ArgumentError(
 #Only the 'before_execute', "
 #'before_cursor_execute' and 'handle_error' engine "
 #event listeners accept the 'retval=True' "
 #argument."
 #
 #vent_key.with_wrapper(fn).base_listen()

 #event._legacy_signature(
 #1.4",
 #"conn", "clauseelement", "multiparams", "params"],
 #ambda conn, clauseelement, multiparams, params, execution_options: (
 #onn,
 #lauseelement,
 #ultiparams,
 #arams,
 #,
 #
 #ef before_execute(
 #elf, conn, clauseelement, multiparams, params, execution_options
 #:
 #""Intercept high level execute() events, receiving uncompiled
 #QL constructs and other objects prior to rendering into SQL.

 #his event is good for debugging SQL compilation issues as well
 #s early manipulation of the parameters being sent to the database,
 #s the parameter lists will be in a consistent format here.

 #his event can be optionally established with the ``retval=True``
 #lag.  The ``clauseelement``, ``multiparams``, and ``params``
 #rguments should be returned as a three-tuple in this case::

 #event.listens_for(Engine, "before_execute", retval=True)
 #ef before_execute(conn, clauseelement, multiparams, params):
                # do something with clauseelement, multiparams, params
 #eturn clauseelement, multiparams, params

 #param conn: :class:`_engine.Connection` object
 #param clauseelement: SQL expression construct, :class:`.Compiled`
 #nstance, or string statement passed to
 #meth:`_engine.Connection.execute`.
 #param multiparams: Multiple parameter sets, a list of dictionaries.
 #param params: Single parameter set, a single dictionary.
 #param execution_options: dictionary of execution
 #ptions passed along with the statement, if any.  This is a merge
 #f all options that will be used, including those of the statement,
 #he connection, and those passed in to the method itself for
 #he 2.0 style of execution.

 #. versionadded: 1.4

 #. seealso::

 #meth:`.before_cursor_execute`

 #""

 #event._legacy_signature(
 #1.4",
 #"conn", "clauseelement", "multiparams", "params", "result"],
 #ambda conn, clauseelement, multiparams, params, execution_options, result: (  # noqa
 #onn,
 #lauseelement,
 #ultiparams,
 #arams,
 #esult,
 #,
 #
 #ef after_execute(
 #elf,
 #onn,
 #lauseelement,
 #ultiparams,
 #arams,
 #xecution_options,
 #esult,
 #:
 #""Intercept high level execute() events after execute.


 #param conn: :class:`_engine.Connection` object
 #param clauseelement: SQL expression construct, :class:`.Compiled`
 #nstance, or string statement passed to
 #meth:`_engine.Connection.execute`.
 #param multiparams: Multiple parameter sets, a list of dictionaries.
 #param params: Single parameter set, a single dictionary.
 #param execution_options: dictionary of execution
 #ptions passed along with the statement, if any.  This is a merge
 #f all options that will be used, including those of the statement,
 #he connection, and those passed in to the method itself for
 #he 2.0 style of execution.

 #. versionadded: 1.4

 #param result: :class:`_engine.CursorResult` generated by the
 #xecution.

 #""

 #ef before_cursor_execute(
 #elf, conn, cursor, statement, parameters, context, executemany
 #:
 #""Intercept low-level cursor execute() events before execution,
 #eceiving the string SQL statement and DBAPI-specific parameter list to
 #e invoked against a cursor.

 #his event is a good choice for logging as well as late modifications
 #o the SQL string.  It's less ideal for parameter modifications except
 #or those which are specific to a target backend.

 #his event can be optionally established with the ``retval=True``
 #lag.  The ``statement`` and ``parameters`` arguments should be
 #eturned as a two-tuple in this case::

 #event.listens_for(Engine, "before_cursor_execute", retval=True)
 #ef before_cursor_execute(conn, cursor, statement,
 #arameters, context, executemany):
                # do something with statement, parameters
 #eturn statement, parameters

 #ee the example at :class:`_events.ConnectionEvents`.

 #param conn: :class:`_engine.Connection` object
 #param cursor: DBAPI cursor object
 #param statement: string SQL statement, as to be passed to the DBAPI
 #param parameters: Dictionary, tuple, or list of parameters being
 #assed to the ``execute()`` or ``executemany()`` method of the
 #BAPI ``cursor``.  In some cases may be ``None``.
 #param context: :class:`.ExecutionContext` object in use.  May
 #e ``None``.
 #param executemany: boolean, if ``True``, this is an ``executemany()``
 #all, if ``False``, this is an ``execute()`` call.

 #. seealso::

 #meth:`.before_execute`

 #meth:`.after_cursor_execute`

 #""

 #ef after_cursor_execute(
 #elf, conn, cursor, statement, parameters, context, executemany
 #:
 #""Intercept low-level cursor execute() events after execution.

 #param conn: :class:`_engine.Connection` object
 #param cursor: DBAPI cursor object.  Will have results pending
 #f the statement was a SELECT, but these should not be consumed
 #s they will be needed by the :class:`_engine.CursorResult`.
 #param statement: string SQL statement, as passed to the DBAPI
 #param parameters: Dictionary, tuple, or list of parameters being
 #assed to the ``execute()`` or ``executemany()`` method of the
 #BAPI ``cursor``.  In some cases may be ``None``.
 #param context: :class:`.ExecutionContext` object in use.  May
 #e ``None``.
 #param executemany: boolean, if ``True``, this is an ``executemany()``
 #all, if ``False``, this is an ``execute()`` call.

 #""

 #ef handle_error(self, exception_context):
 #"""Intercept all exceptions processed by the
 #class:`_engine.Connection`.

 #his includes all exceptions emitted by the DBAPI as well as
 #ithin SQLAlchemy's statement invocation process, including
 #ncoding errors and other statement validation errors.  Other areas
 #n which the event is invoked include transaction begin and end,
 #esult row fetching, cursor creation.

 #ote that :meth:`.handle_error` may support new kinds of exceptions
 #nd new calling scenarios at *any time*.  Code which uses this
 #vent must expect new calling patterns to be present in minor
 #eleases.

 #o support the wide variety of members that correspond to an exception,
 #s well as to allow extensibility of the event without backwards
 #ncompatibility, the sole argument received is an instance of
 #class:`.ExceptionContext`.   This object contains data members
 #epresenting detail about the exception.

 #se cases supported by this hook include:

 # read-only, low-level exception handling for logging and
 #ebugging purposes
 # exception re-writing
 # Establishing or disabling whether a connection or the owning
 #onnection pool is invalidated or expired in response to a
 #pecific exception [1]_.

 #he hook is called while the cursor from the failed operation
 #if any) is still open and accessible.   Special cleanup operations
 #an be called on this cursor; SQLAlchemy will attempt to close
 #his cursor subsequent to this hook being invoked.  If the connection
 #s in "autocommit" mode, the transaction also remains open within
 #he scope of this hook; the rollback of the per-statement transaction
 #lso occurs after the hook is called.

 #. note::

 #. [1] The pool "pre_ping" handler enabled using the
 #paramref:`_sa.create_engine.pool_pre_ping` parameter does
 #*not** consult this event before deciding if the "ping"
 #eturned false, as opposed to receiving an unhandled error.
 #or this use case, the :ref:`legacy recipe based on
 #ngine_connect() may be used
 #pool_disconnects_pessimistic_custom>`.  A future API allow
 #ore comprehensive customization of the "disconnect"
 #etection mechanism across all functions.

 # handler function has two options for replacing
 #he SQLAlchemy-constructed exception into one that is user
 #efined.   It can either raise this new exception directly, in
 #hich case all further event listeners are bypassed and the
 #xception will be raised, after appropriate cleanup as taken
 #lace::

 #event.listens_for(Engine, "handle_error")
 #ef handle_exception(context):
 #f isinstance(context.original_exception,
 #sycopg2.OperationalError) and \
 #failed" in str(context.original_exception):
 #aise MySpecialException("failed operation")

 #. warning::  Because the
 #meth:`_events.ConnectionEvents.handle_error`
 #vent specifically provides for exceptions to be re-thrown as
 #he ultimate exception raised by the failed statement,
 #*stack traces will be misleading** if the user-defined event
 #andler itself fails and throws an unexpected exception;
 #he stack trace may not illustrate the actual code line that
 #ailed!  It is advised to code carefully here and use
 #ogging and/or inline debugging if unexpected exceptions are
 #ccurring.

 #lternatively, a "chained" style of event handling can be
 #sed, by configuring the handler with the ``retval=True``
 #odifier and returning the new exception instance from the
 #unction.  In this case, event handling will continue onto the
 #ext handler.   The "chained" exception is available using
 #attr:`.ExceptionContext.chained_exception`::

 #event.listens_for(Engine, "handle_error", retval=True)
 #ef handle_exception(context):
 #f context.chained_exception is not None and \
 #special" in context.chained_exception.message:
 #eturn MySpecialException("failed",
 #ause=context.chained_exception)

 #andlers that return ``None`` may be used within the chain; when
 # handler returns ``None``, the previous exception instance,
 #f any, is maintained as the current exception that is passed onto the
 #ext handler.

 #hen a custom exception is raised or returned, SQLAlchemy raises
 #his new exception as-is, it is not wrapped by any SQLAlchemy
 #bject.  If the exception is not a subclass of
 #class:`sqlalchemy.exc.StatementError`,
 #ertain features may not be available; currently this includes
 #he ORM's feature of adding a detail hint about "autoflush" to
 #xceptions raised within the autoflush process.

 #param context: an :class:`.ExceptionContext` object.  See this
 #lass for details on all available members.

 #. versionadded:: 0.9.7 Added the
 #meth:`_events.ConnectionEvents.handle_error` hook.

 #. versionchanged:: 1.1 The :meth:`.handle_error` event will now
 #eceive all exceptions that inherit from ``BaseException``,
 #ncluding ``SystemExit`` and ``KeyboardInterrupt``.  The setting for
 #attr:`.ExceptionContext.is_disconnect` is ``True`` in this case and
 #he default for
 #attr:`.ExceptionContext.invalidate_pool_on_disconnect` is
 #`False``.

 #. versionchanged:: 1.0.0 The :meth:`.handle_error` event is now
 #nvoked when an :class:`_engine.Engine` fails during the initial
 #all to :meth:`_engine.Engine.connect`, as well as when a
 #class:`_engine.Connection` object encounters an error during a
 #econnect operation.

 #. versionchanged:: 1.0.0 The :meth:`.handle_error` event is
 #ot fired off when a dialect makes use of the
 #`skip_user_error_events`` execution option.   This is used
 #y dialects which intend to catch SQLAlchemy-specific exceptions
 #ithin specific operations, such as when the MySQL dialect detects
 # table not present within the ``has_table()`` dialect method.
 #rior to 1.0.0, code which implements :meth:`.handle_error` needs
 #o ensure that exceptions thrown in these scenarios are re-raised
 #ithout modification.

 #""

 #ef engine_connect(self, conn, branch):
 #""Intercept the creation of a new :class:`_engine.Connection`.

 #his event is called typically as the direct result of calling
 #he :meth:`_engine.Engine.connect` method.

 #t differs from the :meth:`_events.PoolEvents.connect` method, which
 #efers to the actual connection to a database at the DBAPI level;
 # DBAPI connection may be pooled and reused for many operations.
 #n contrast, this event refers only to the production of a higher level
 #class:`_engine.Connection` wrapper around such a DBAPI connection.

 #t also differs from the :meth:`_events.PoolEvents.checkout` event
 #n that it is specific to the :class:`_engine.Connection` object,
 #ot the
 #BAPI connection that :meth:`_events.PoolEvents.checkout` deals with,
 #lthough
 #his DBAPI connection is available here via the
 #attr:`_engine.Connection.connection` attribute.
 #ut note there can in fact
 #e multiple :meth:`_events.PoolEvents.checkout`
 #vents within the lifespan
 #f a single :class:`_engine.Connection` object, if that
 #class:`_engine.Connection`
 #s invalidated and re-established.  There can also be multiple
 #class:`_engine.Connection`
 #bjects generated for the same already-checked-out
 #BAPI connection, in the case that a "branch" of a
 #class:`_engine.Connection`
 #s produced.

 #param conn: :class:`_engine.Connection` object.
 #param branch: if True, this is a "branch" of an existing
 #class:`_engine.Connection`.  A branch is generated within the course
 #f a statement execution to invoke supplemental statements, most
 #ypically to pre-execute a SELECT of a default value for the purposes
 #f an INSERT statement.

 #. seealso::

 #meth:`_events.PoolEvents.checkout`
 #he lower-level pool checkout event
 #or an individual DBAPI connection

 #""

 #ef set_connection_execution_options(self, conn, opts):
 #""Intercept when the :meth:`_engine.Connection.execution_options`
 #ethod is called.

 #his method is called after the new :class:`_engine.Connection`
 #as been
 #roduced, with the newly updated execution options collection, but
 #efore the :class:`.Dialect` has acted upon any of those new options.

 #ote that this method is not called when a new
 #class:`_engine.Connection`
 #s produced which is inheriting execution options from its parent
 #class:`_engine.Engine`; to intercept this condition, use the
 #meth:`_events.ConnectionEvents.engine_connect` event.

 #param conn: The newly copied :class:`_engine.Connection` object

 #param opts: dictionary of options that were passed to the
 #meth:`_engine.Connection.execution_options` method.

 #. versionadded:: 0.9.0

 #. seealso::

 #meth:`_events.ConnectionEvents.set_engine_execution_options`
 # event
 #hich is called when :meth:`_engine.Engine.execution_options`
 #s called.


 #""

 #ef set_engine_execution_options(self, engine, opts):
 #""Intercept when the :meth:`_engine.Engine.execution_options`
 #ethod is called.

 #he :meth:`_engine.Engine.execution_options` method produces a shallow
 #opy of the :class:`_engine.Engine` which stores the new options.
 #hat new
 #class:`_engine.Engine` is passed here.
 # particular application of this
 #ethod is to add a :meth:`_events.ConnectionEvents.engine_connect`
 #vent
 #andler to the given :class:`_engine.Engine`
 #hich will perform some per-
 #class:`_engine.Connection` task specific to these execution options.

 #param conn: The newly copied :class:`_engine.Engine` object

 #param opts: dictionary of options that were passed to the
 #meth:`_engine.Connection.execution_options` method.

 #. versionadded:: 0.9.0

 #. seealso::

 #meth:`_events.ConnectionEvents.set_connection_execution_options`
 # event
 #hich is called when :meth:`_engine.Connection.execution_options`
 #s
 #alled.

 #""

 #ef engine_disposed(self, engine):
 #""Intercept when the :meth:`_engine.Engine.dispose` method is called.

 #he :meth:`_engine.Engine.dispose` method instructs the engine to
 #dispose" of it's connection pool (e.g. :class:`_pool.Pool`), and
 #eplaces it with a new one.  Disposing of the old pool has the
 #ffect that existing checked-in connections are closed.  The new
 #ool does not establish any new connections until it is first used.

 #his event can be used to indicate that resources related to the
 #class:`_engine.Engine` should also be cleaned up,
 #eeping in mind that the
 #class:`_engine.Engine`
 #an still be used for new requests in which case
 #t re-acquires connection resources.

 #. versionadded:: 1.0.5

 #""

 #ef begin(self, conn):
 #""Intercept begin() events.

 #param conn: :class:`_engine.Connection` object

 #""

 #ef rollback(self, conn):
 #""Intercept rollback() events, as initiated by a
 #class:`.Transaction`.

 #ote that the :class:`_pool.Pool` also "auto-rolls back"
 # DBAPI connection upon checkin, if the ``reset_on_return``
 #lag is set to its default value of ``'rollback'``.
 #o intercept this
 #ollback, use the :meth:`_events.PoolEvents.reset` hook.

 #param conn: :class:`_engine.Connection` object

 #. seealso::

 #meth:`_events.PoolEvents.reset`

 #""

 #ef commit(self, conn):
 #""Intercept commit() events, as initiated by a
 #class:`.Transaction`.

 #ote that the :class:`_pool.Pool` may also "auto-commit"
 # DBAPI connection upon checkin, if the ``reset_on_return``
 #lag is set to the value ``'commit'``.  To intercept this
 #ommit, use the :meth:`_events.PoolEvents.reset` hook.

 #param conn: :class:`_engine.Connection` object
 #""

 #ef savepoint(self, conn, name):
 #""Intercept savepoint() events.

 #param conn: :class:`_engine.Connection` object
 #param name: specified name used for the savepoint.

 #""

 #ef rollback_savepoint(self, conn, name, context):
 #""Intercept rollback_savepoint() events.

 #param conn: :class:`_engine.Connection` object
 #param name: specified name used for the savepoint.
 #param context: not used

 #""
        # TODO: deprecate "context"

 #ef release_savepoint(self, conn, name, context):
 #""Intercept release_savepoint() events.

 #param conn: :class:`_engine.Connection` object
 #param name: specified name used for the savepoint.
 #param context: not used

 #""
        # TODO: deprecate "context"

 #ef begin_twophase(self, conn, xid):
 #""Intercept begin_twophase() events.

 #param conn: :class:`_engine.Connection` object
 #param xid: two-phase XID identifier

 #""

 #ef prepare_twophase(self, conn, xid):
 #""Intercept prepare_twophase() events.

 #param conn: :class:`_engine.Connection` object
 #param xid: two-phase XID identifier
 #""

 #ef rollback_twophase(self, conn, xid, is_prepared):
 #""Intercept rollback_twophase() events.

 #param conn: :class:`_engine.Connection` object
 #param xid: two-phase XID identifier
 #param is_prepared: boolean, indicates if
 #meth:`.TwoPhaseTransaction.prepare` was called.

 #""

 #ef commit_twophase(self, conn, xid, is_prepared):
 #""Intercept commit_twophase() events.

 #param conn: :class:`_engine.Connection` object
 #param xid: two-phase XID identifier
 #param is_prepared: boolean, indicates if
 #meth:`.TwoPhaseTransaction.prepare` was called.

 #""


class DialectEvents(event.Events):
 #""event interface for execution-replacement functions.

 #hese events allow direct instrumentation and replacement
 #f key dialect functions which interact with the DBAPI.

 #. note::

 #class:`.DialectEvents` hooks should be considered **semi-public**
 #nd experimental.
 #hese hooks are not for general use and are only for those situations
 #here intricate re-statement of DBAPI mechanics must be injected onto
 #n existing dialect.  For general-use statement-interception events,
 #lease use the :class:`_events.ConnectionEvents` interface.

 #. seealso::

 #meth:`_events.ConnectionEvents.before_cursor_execute`

 #meth:`_events.ConnectionEvents.before_execute`

 #meth:`_events.ConnectionEvents.after_cursor_execute`

 #meth:`_events.ConnectionEvents.after_execute`


 #. versionadded:: 0.9.4

 #""

 #target_class_doc = "SomeEngine"
 #dispatch_target = Dialect

 #classmethod
 #ef _listen(cls, event_key, retval=False):
 #arget = event_key.dispatch_target

 #arget._has_events = True
 #vent_key.base_listen()

 #classmethod
 #ef _accept_with(cls, target):
 #f isinstance(target, type):
 #f issubclass(target, Engine):
 #eturn Dialect
 #lif issubclass(target, Dialect):
 #eturn target
 #lif isinstance(target, Engine):
 #eturn target.dialect
 #lse:
 #eturn target

 #ef do_connect(self, dialect, conn_rec, cargs, cparams):
 #""Receive connection arguments before a connection is made.

 #eturn a DBAPI connection to halt further events from invoking;
 #he returned connection will be used.

 #lternatively, the event can manipulate the cargs and/or cparams
 #ollections; cargs will always be a Python list that can be mutated
 #n-place and cparams a Python dictionary.  Return None to
 #llow control to pass to the next event handler and ultimately
 #o allow the dialect to connect normally, given the updated
 #rguments.

 #. versionadded:: 1.0.3

 #. seealso::

 #ref:`custom_dbapi_args`

 #""

 #ef do_executemany(self, cursor, statement, parameters, context):
 #""Receive a cursor to have executemany() called.

 #eturn the value True to halt further events from invoking,
 #nd to indicate that the cursor execution has already taken
 #lace within the event handler.

 #""

 #ef do_execute_no_params(self, cursor, statement, context):
 #""Receive a cursor to have execute() with no parameters called.

 #eturn the value True to halt further events from invoking,
 #nd to indicate that the cursor execution has already taken
 #lace within the event handler.

 #""

 #ef do_execute(self, cursor, statement, parameters, context):
 #""Receive a cursor to have execute() called.

 #eturn the value True to halt further events from invoking,
 #nd to indicate that the cursor execution has already taken
 #lace within the event handler.

 #""

 #ef do_setinputsizes(
 #elf, inputsizes, cursor, statement, parameters, context
 #:
 #""Receive the setinputsizes dictionary for possible modification.

 #his event is emitted in the case where the dialect makes use of the
 #BAPI ``cursor.setinputsizes()`` method which passes information about
 #arameter binding for a particular statement.   The given
 #`inputsizes`` dictionary will contain :class:`.BindParameter` objects
 #s keys, linked to DBAPI-specific type objects as values; for
 #arameters that are not bound, they are added to the dictionary with
 #`None`` as the value, which means the parameter will not be included
 #n the ultimate setinputsizes call.   The event may be used to inspect
 #nd/or log the datatypes that are being bound, as well as to modify the
 #ictionary in place.  Parameters can be added, modified, or removed
 #rom this dictionary.   Callers will typically want to inspect the
 #attr:`.BindParameter.type` attribute of the given bind objects in
 #rder to make decisions about the DBAPI object.

 #fter the event, the ``inputsizes`` dictionary is converted into
 #n appropriate datastructure to be passed to ``cursor.setinputsizes``;
 #ither a list for a positional bound parameter execution style,
 #r a dictionary of string parameter keys to DBAPI type objects for
 # named bound parameter execution style.

 #he setinputsizes hook overall is only used for dialects which include
 #he flag ``use_setinputsizes=True``.  Dialects which use this
 #nclude cx_Oracle, pg8000, asyncpg, and pyodbc dialects.

 #. note::

 #or use with pyodbc, the ``use_setinputsizes`` flag
 #ust be passed to the dialect, e.g.::

 #reate_engine("mssql+pyodbc://...", use_setinputsizes=True)

 #. seealso::

 #ref:`mssql_pyodbc_setinputsizes`

 #. versionadded:: 1.2.9

 #. seealso::

 #ref:`cx_oracle_setinputsizes`

 #""
 #ass
