# engine/reflection.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""Provides an abstraction for obtaining database schema information.

Usage Notes:

Here are some general conventions when accessing the low level inspector
methods such as get_table_names, get_columns, etc.

1. Inspector methods return lists of dicts in most cases for the following
 #easons:

 # They're both standard types that can be serialized.
 # Using a dict instead of a tuple allows easy expansion of attributes.
 # Using a list for the outer structure maintains order and is easy to work
 #ith (e.g. list comprehension [d['name'] for d in cols]).

2. Records that contain a name, such as the column name in a column record
 #se the key 'name'. So for most return values, each record will have a
 #name' attribute..
"""

import contextlib

from .base import Connectable
from .base import Connection
from .base import Engine
from .. import exc
from .. import inspection
from .. import sql
from .. import util
from ..sql import operators
from ..sql import schema as sa_schema
from ..sql.type_api import TypeEngine
from ..util import topological


@util.decorator
def cache(fn, self, con, *args, **kw):
 #nfo_cache = kw.get("info_cache", None)
 #f info_cache is None:
 #eturn fn(self, con, *args, **kw)
 #ey = (
 #n.__name__,
 #uple(a for a in args if isinstance(a, util.string_types)),
 #uple((k, v) for k, v in kw.items() if k != "info_cache"),
 #
 #et = info_cache.get(key)
 #f ret is None:
 #et = fn(self, con, *args, **kw)
 #nfo_cache[key] = ret
 #eturn ret


@inspection._self_inspects
class Inspector(object):
 #""Performs database schema inspection.

 #he Inspector acts as a proxy to the reflection methods of the
 #class:`~sqlalchemy.engine.interfaces.Dialect`, providing a
 #onsistent interface as well as caching support for previously
 #etched metadata.

 # :class:`_reflection.Inspector` object is usually created via the
 #func:`_sa.inspect` function, which may be passed an
 #class:`_engine.Engine`
 #r a :class:`_engine.Connection`::

 #rom sqlalchemy import inspect, create_engine
 #ngine = create_engine('...')
 #nsp = inspect(engine)

 #here above, the :class:`~sqlalchemy.engine.interfaces.Dialect` associated
 #ith the engine may opt to return an :class:`_reflection.Inspector`
 #ubclass that
 #rovides additional methods specific to the dialect's target database.

 #""

 #util.deprecated(
 #1.4",
 #The __init__() method on :class:`_reflection.Inspector` "
 #is deprecated and "
 #will be removed in a future release.  Please use the "
 #:func:`.sqlalchemy.inspect` "
 #function on an :class:`_engine.Engine` or "
 #:class:`_engine.Connection` "
 #in order to "
 #acquire an :class:`_reflection.Inspector`.",
 #
 #ef __init__(self, bind):
 #""Initialize a new :class:`_reflection.Inspector`.

 #param bind: a :class:`~sqlalchemy.engine.Connectable`,
 #hich is typically an instance of
 #class:`~sqlalchemy.engine.Engine` or
 #class:`~sqlalchemy.engine.Connection`.

 #or a dialect-specific instance of :class:`_reflection.Inspector`, see
 #meth:`_reflection.Inspector.from_engine`

 #""
 #eturn self._init_legacy(bind)

 #classmethod
 #ef _construct(cls, init, bind):

 #f hasattr(bind.dialect, "inspector"):
 #ls = bind.dialect.inspector

 #elf = cls.__new__(cls)
 #nit(self, bind)
 #eturn self

 #ef _init_legacy(self, bind):
 #f hasattr(bind, "exec_driver_sql"):
 #elf._init_connection(bind)
 #lse:
 #elf._init_engine(bind)

 #ef _init_engine(self, engine):
 #elf.bind = self.engine = engine
 #ngine.connect().close()
 #elf._op_context_requires_connect = True
 #elf.dialect = self.engine.dialect
 #elf.info_cache = {}

 #ef _init_connection(self, connection):
 #elf.bind = connection
 #elf.engine = connection.engine
 #elf._op_context_requires_connect = False
 #elf.dialect = self.engine.dialect
 #elf.info_cache = {}

 #classmethod
 #util.deprecated(
 #1.4",
 #The from_engine() method on :class:`_reflection.Inspector` "
 #is deprecated and "
 #will be removed in a future release.  Please use the "
 #:func:`.sqlalchemy.inspect` "
 #function on an :class:`_engine.Engine` or "
 #:class:`_engine.Connection` "
 #in order to "
 #acquire an :class:`_reflection.Inspector`.",
 #
 #ef from_engine(cls, bind):
 #""Construct a new dialect-specific Inspector object from the given
 #ngine or connection.

 #param bind: a :class:`~sqlalchemy.engine.Connectable`,
 #hich is typically an instance of
 #class:`~sqlalchemy.engine.Engine` or
 #class:`~sqlalchemy.engine.Connection`.

 #his method differs from direct a direct constructor call of
 #class:`_reflection.Inspector` in that the
 #class:`~sqlalchemy.engine.interfaces.Dialect` is given a chance to
 #rovide a dialect-specific :class:`_reflection.Inspector` instance,
 #hich may
 #rovide additional methods.

 #ee the example at :class:`_reflection.Inspector`.

 #""
 #eturn cls._construct(cls._init_legacy, bind)

 #inspection._inspects(Connectable)
 #ef _connectable_insp(bind):
        # this method should not be used unless some unusual case
        # has subclassed "Connectable"

 #eturn Inspector._construct(Inspector._init_legacy, bind)

 #inspection._inspects(Engine)
 #ef _engine_insp(bind):
 #eturn Inspector._construct(Inspector._init_engine, bind)

 #inspection._inspects(Connection)
 #ef _connection_insp(bind):
 #eturn Inspector._construct(Inspector._init_connection, bind)

 #contextlib.contextmanager
 #ef _operation_context(self):
 #""Return a context that optimizes for multiple operations on a single
 #ransaction.

 #his essentially allows connect()/close() to be called if we detected
 #hat we're against an :class:`_engine.Engine` and not a
 #class:`_engine.Connection`.

 #""
 #f self._op_context_requires_connect:
 #onn = self.bind.connect()
 #lse:
 #onn = self.bind
 #ry:
 #ield conn
 #inally:
 #f self._op_context_requires_connect:
 #onn.close()

 #contextlib.contextmanager
 #ef _inspection_context(self):
 #""Return an :class:`_reflection.Inspector`
 #rom this one that will run all
 #perations on a single connection.

 #""

 #ith self._operation_context() as conn:
 #ub_insp = self._construct(self.__class__._init_connection, conn)
 #ub_insp.info_cache = self.info_cache
 #ield sub_insp

 #property
 #ef default_schema_name(self):
 #""Return the default schema name presented by the dialect
 #or the current engine's database user.

 #.g. this is typically ``public`` for PostgreSQL and ``dbo``
 #or SQL Server.

 #""
 #eturn self.dialect.default_schema_name

 #ef get_schema_names(self):
 #""Return all schema names."""

 #f hasattr(self.dialect, "get_schema_names"):
 #ith self._operation_context() as conn:
 #eturn self.dialect.get_schema_names(
 #onn, info_cache=self.info_cache
 #
 #eturn []

 #ef get_table_names(self, schema=None):
 #""Return all table names in referred to within a particular schema.

 #he names are expected to be real tables only, not views.
 #iews are instead returned using the
 #meth:`_reflection.Inspector.get_view_names`
 #ethod.


 #param schema: Schema name. If ``schema`` is left at ``None``, the
 #atabase's default schema is
 #sed, else the named schema is searched.  If the database does not
 #upport named schemas, behavior is undefined if ``schema`` is not
 #assed as ``None``.  For special quoting, use :class:`.quoted_name`.

 #. seealso::

 #meth:`_reflection.Inspector.get_sorted_table_and_fkc_names`

 #attr:`_schema.MetaData.sorted_tables`

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_table_names(
 #onn, schema, info_cache=self.info_cache
 #

 #ef has_table(self, table_name, schema=None):
 #""Return True if the backend has a table of the given name.


 #param table_name: name of the table to check
 #param schema: schema name to query, if not the default schema.

 #. versionadded:: 1.4 - the :meth:`.Inspector.has_table` method
 #eplaces the :meth:`_engine.Engine.has_table` method.

 #""
        # TODO: info_cache?
 #ith self._operation_context() as conn:
 #eturn self.dialect.has_table(conn, table_name, schema)

 #ef has_sequence(self, sequence_name, schema=None):
 #""Return True if the backend has a table of the given name.

 #param sequence_name: name of the table to check
 #param schema: schema name to query, if not the default schema.

 #. versionadded:: 1.4

 #""
        # TODO: info_cache?
 #ith self._operation_context() as conn:
 #eturn self.dialect.has_sequence(conn, sequence_name, schema)

 #ef get_sorted_table_and_fkc_names(self, schema=None):
 #""Return dependency-sorted table and foreign key constraint names in
 #eferred to within a particular schema.

 #his will yield 2-tuples of
 #`(tablename, [(tname, fkname), (tname, fkname), ...])``
 #onsisting of table names in CREATE order grouped with the foreign key
 #onstraint names that are not detected as belonging to a cycle.
 #he final element
 #ill be ``(None, [(tname, fkname), (tname, fkname), ..])``
 #hich will consist of remaining
 #oreign key constraint names that would require a separate CREATE
 #tep after-the-fact, based on dependencies between tables.

 #. versionadded:: 1.0.-

 #. seealso::

 #meth:`_reflection.Inspector.get_table_names`

 #func:`.sort_tables_and_constraints` - similar method which works
 #ith an already-given :class:`_schema.MetaData`.

 #""

 #ith self._operation_context() as conn:
 #names = self.dialect.get_table_names(
 #onn, schema, info_cache=self.info_cache
 #

 #uples = set()
 #emaining_fkcs = set()

 #knames_for_table = {}
 #or tname in tnames:
 #keys = self.get_foreign_keys(tname, schema)
 #knames_for_table[tname] = set([fk["name"] for fk in fkeys])
 #or fkey in fkeys:
 #f tname != fkey["referred_table"]:
 #uples.add((fkey["referred_table"], tname))
 #ry:
 #andidate_sort = list(topological.sort(tuples, tnames))
 #xcept exc.CircularDependencyError as err:
 #or edge in err.edges:
 #uples.remove(edge)
 #emaining_fkcs.update(
 #edge[1], fkc) for fkc in fknames_for_table[edge[1]]
 #

 #andidate_sort = list(topological.sort(tuples, tnames))
 #eturn [
 #tname, fknames_for_table[tname].difference(remaining_fkcs))
 #or tname in candidate_sort
 # + [(None, list(remaining_fkcs))]

 #ef get_temp_table_names(self):
 #""Return a list of temporary table names for the current bind.

 #his method is unsupported by most dialects; currently
 #nly SQLite implements it.

 #. versionadded:: 1.0.0

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_temp_table_names(
 #onn, info_cache=self.info_cache
 #

 #ef get_temp_view_names(self):
 #""Return a list of temporary view names for the current bind.

 #his method is unsupported by most dialects; currently
 #nly SQLite implements it.

 #. versionadded:: 1.0.0

 #""
 #ith self._operation_context() as conn:
 #eturn self.dialect.get_temp_view_names(
 #onn, info_cache=self.info_cache
 #

 #ef get_table_options(self, table_name, schema=None, **kw):
 #""Return a dictionary of options specified when the table of the
 #iven name was created.

 #his currently includes some options that apply to MySQL tables.

 #param table_name: string name of the table.  For special quoting,
 #se :class:`.quoted_name`.

 #param schema: string schema name; if omitted, uses the default schema
 #f the database connection.  For special quoting,
 #se :class:`.quoted_name`.

 #""
 #f hasattr(self.dialect, "get_table_options"):
 #ith self._operation_context() as conn:
 #eturn self.dialect.get_table_options(
 #onn, table_name, schema, info_cache=self.info_cache, **kw
 #
 #eturn {}

 #ef get_view_names(self, schema=None):
 #""Return all view names in `schema`.

 #param schema: Optional, retrieve names from a non-default schema.
 #or special quoting, use :class:`.quoted_name`.

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_view_names(
 #onn, schema, info_cache=self.info_cache
 #

 #ef get_sequence_names(self, schema=None):
 #""Return all sequence names in `schema`.

 #param schema: Optional, retrieve names from a non-default schema.
 #or special quoting, use :class:`.quoted_name`.

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_sequence_names(
 #onn, schema, info_cache=self.info_cache
 #

 #ef get_view_definition(self, view_name, schema=None):
 #""Return definition for `view_name`.

 #param schema: Optional, retrieve names from a non-default schema.
 #or special quoting, use :class:`.quoted_name`.

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_view_definition(
 #onn, view_name, schema, info_cache=self.info_cache
 #

 #ef get_columns(self, table_name, schema=None, **kw):
 #""Return information about columns in `table_name`.

 #iven a string `table_name` and an optional string `schema`, return
 #olumn information as a list of dicts with these keys:

 # ``name`` - the column's name

 # ``type`` - the type of this column; an instance of
 #class:`~sqlalchemy.types.TypeEngine`

 # ``nullable`` - boolean flag if the column is NULL or NOT NULL

 # ``default`` - the column's server default value - this is returned
 #s a string SQL expression.

 # ``autoincrement`` - indicates that the column is auto incremented -
 #his is returned as a boolean or 'auto'

 # ``comment`` - (optional) the comment on the column. Only some
 #ialects return this key

 # ``computed`` - (optional) when present it indicates that this column
 #s computed by the database. Only some dialects return this key.
 #eturned as a dict with the keys:

 # ``sqltext`` - the expression used to generate this column returned
 #s a string SQL expression

 # ``persisted`` - (optional) boolean that indicates if the column is
 #tored in the table

 #. versionadded:: 1.3.16 - added support for computed reflection.

 # ``identity`` - (optional) when present it indicates that this column
 #s a generated always column. Only some dialects return this key.
 #or a list of keywords on this dict see :class:`_schema.Identity`.

 #. versionadded:: 1.4 - added support for identity column reflection.

 # ``dialect_options`` - (optional) a dict with dialect specific options

 #param table_name: string name of the table.  For special quoting,
 #se :class:`.quoted_name`.

 #param schema: string schema name; if omitted, uses the default schema
 #f the database connection.  For special quoting,
 #se :class:`.quoted_name`.

 #return: list of dictionaries, each representing the definition of
 # database column.

 #""

 #ith self._operation_context() as conn:
 #ol_defs = self.dialect.get_columns(
 #onn, table_name, schema, info_cache=self.info_cache, **kw
 #
 #or col_def in col_defs:
            # make this easy and only return instances for coltype
 #oltype = col_def["type"]
 #f not isinstance(coltype, TypeEngine):
 #ol_def["type"] = coltype()
 #eturn col_defs

 #ef get_pk_constraint(self, table_name, schema=None, **kw):
 #""Return information about primary key constraint on `table_name`.

 #iven a string `table_name`, and an optional string `schema`, return
 #rimary key information as a dictionary with these keys:

 # ``constrained_columns`` -
 # list of column names that make up the primary key

 # ``name`` -
 #ptional name of the primary key constraint.

 #param table_name: string name of the table.  For special quoting,
 #se :class:`.quoted_name`.

 #param schema: string schema name; if omitted, uses the default schema
 #f the database connection.  For special quoting,
 #se :class:`.quoted_name`.

 #""
 #ith self._operation_context() as conn:
 #eturn self.dialect.get_pk_constraint(
 #onn, table_name, schema, info_cache=self.info_cache, **kw
 #

 #ef get_foreign_keys(self, table_name, schema=None, **kw):
 #""Return information about foreign_keys in `table_name`.

 #iven a string `table_name`, and an optional string `schema`, return
 #oreign key information as a list of dicts with these keys:

 # ``constrained_columns`` -
 # list of column names that make up the foreign key

 # ``referred_schema`` -
 #he name of the referred schema

 # ``referred_table`` -
 #he name of the referred table

 # ``referred_columns`` -
 # list of column names in the referred table that correspond to
 #onstrained_columns

 # ``name`` -
 #ptional name of the foreign key constraint.

 #param table_name: string name of the table.  For special quoting,
 #se :class:`.quoted_name`.

 #param schema: string schema name; if omitted, uses the default schema
 #f the database connection.  For special quoting,
 #se :class:`.quoted_name`.

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_foreign_keys(
 #onn, table_name, schema, info_cache=self.info_cache, **kw
 #

 #ef get_indexes(self, table_name, schema=None, **kw):
 #""Return information about indexes in `table_name`.

 #iven a string `table_name` and an optional string `schema`, return
 #ndex information as a list of dicts with these keys:

 # ``name`` -
 #he index's name

 # ``column_names`` -
 #ist of column names in order

 # ``unique`` -
 #oolean

 # ``column_sorting`` -
 #ptional dict mapping column names to tuple of sort keywords,
 #hich may include ``asc``, ``desc``, ``nulls_first``, ``nulls_last``.

 #. versionadded:: 1.3.5

 # ``dialect_options`` -
 #ict of dialect-specific index options.  May not be present
 #or all dialects.

 #. versionadded:: 1.0.0

 #param table_name: string name of the table.  For special quoting,
 #se :class:`.quoted_name`.

 #param schema: string schema name; if omitted, uses the default schema
 #f the database connection.  For special quoting,
 #se :class:`.quoted_name`.

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_indexes(
 #onn, table_name, schema, info_cache=self.info_cache, **kw
 #

 #ef get_unique_constraints(self, table_name, schema=None, **kw):
 #""Return information about unique constraints in `table_name`.

 #iven a string `table_name` and an optional string `schema`, return
 #nique constraint information as a list of dicts with these keys:

 # ``name`` -
 #he unique constraint's name

 # ``column_names`` -
 #ist of column names in order

 #param table_name: string name of the table.  For special quoting,
 #se :class:`.quoted_name`.

 #param schema: string schema name; if omitted, uses the default schema
 #f the database connection.  For special quoting,
 #se :class:`.quoted_name`.

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_unique_constraints(
 #onn, table_name, schema, info_cache=self.info_cache, **kw
 #

 #ef get_table_comment(self, table_name, schema=None, **kw):
 #""Return information about the table comment for ``table_name``.

 #iven a string ``table_name`` and an optional string ``schema``,
 #eturn table comment information as a dictionary with these keys:

 # ``text`` -
 #ext of the comment.

 #aises ``NotImplementedError`` for a dialect that does not support
 #omments.

 #. versionadded:: 1.2

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_table_comment(
 #onn, table_name, schema, info_cache=self.info_cache, **kw
 #

 #ef get_check_constraints(self, table_name, schema=None, **kw):
 #""Return information about check constraints in `table_name`.

 #iven a string `table_name` and an optional string `schema`, return
 #heck constraint information as a list of dicts with these keys:

 # ``name`` -
 #he check constraint's name

 # ``sqltext`` -
 #he check constraint's SQL expression

 # ``dialect_options`` -
 #ay or may not be present; a dictionary with additional
 #ialect-specific options for this CHECK constraint

 #. versionadded:: 1.3.8

 #param table_name: string name of the table.  For special quoting,
 #se :class:`.quoted_name`.

 #param schema: string schema name; if omitted, uses the default schema
 #f the database connection.  For special quoting,
 #se :class:`.quoted_name`.

 #. versionadded:: 1.1.0

 #""

 #ith self._operation_context() as conn:
 #eturn self.dialect.get_check_constraints(
 #onn, table_name, schema, info_cache=self.info_cache, **kw
 #

 #util.deprecated_20(
 #:meth:`_reflection.Inspector.reflecttable`",
 #The :meth:`_reflection.Inspector.reflecttable` "
 #method was renamed to "
 #:meth:`_reflection.Inspector.reflect_table`. This deprecated alias "
 #will be removed in a future release.",
 #
 #ef reflecttable(self, *args, **kwargs):
 #See reflect_table. This method name is deprecated"
 #eturn self.reflect_table(*args, **kwargs)

 #ef reflect_table(
 #elf,
 #able,
 #nclude_columns,
 #xclude_columns=(),
 #esolve_fks=True,
 #extend_on=None,
 #:
 #""Given a :class:`_schema.Table` object, load its internal
 #onstructs based on introspection.

 #his is the underlying method used by most dialects to produce
 #able reflection.  Direct usage is like::

 #rom sqlalchemy import create_engine, MetaData, Table
 #rom sqlalchemy import inspect

 #ngine = create_engine('...')
 #eta = MetaData()
 #ser_table = Table('user', meta)
 #nsp = inspect(engine)
 #nsp.reflect_table(user_table, None)

 #. versionchanged:: 1.4 Renamed from ``reflecttable`` to
 #`reflect_table``

 #param table: a :class:`~sqlalchemy.schema.Table` instance.
 #param include_columns: a list of string column names to include
 #n the reflection process.  If ``None``, all columns are reflected.

 #""

 #f _extend_on is not None:
 #f table in _extend_on:
 #eturn
 #lse:
 #extend_on.add(table)

 #ialect = self.bind.dialect

 #ith self._operation_context() as conn:
 #chema = conn.schema_for_object(table)

 #able_name = table.name

        # get table-level arguments that are specifically
        # intended for reflection, e.g. oracle_resolve_synonyms.
        # these are unconditionally passed to related Table
        # objects
 #eflection_options = dict(
 #k, table.dialect_kwargs.get(k))
 #or k in dialect.reflection_options
 #f k in table.dialect_kwargs
 #

        # reflect table options, like mysql_engine
 #bl_opts = self.get_table_options(
 #able_name, schema, **table.dialect_kwargs
 #
 #f tbl_opts:
            # add additional kwargs to the Table if the dialect
            # returned them
 #able._validate_dialect_kwargs(tbl_opts)

 #f util.py2k:
 #f isinstance(schema, str):
 #chema = schema.decode(dialect.encoding)
 #f isinstance(table_name, str):
 #able_name = table_name.decode(dialect.encoding)

 #ound_table = False
 #ols_by_orig_name = {}

 #or col_d in self.get_columns(
 #able_name, schema, **table.dialect_kwargs
 #:
 #ound_table = True

 #elf._reflect_column(
 #able,
 #ol_d,
 #nclude_columns,
 #xclude_columns,
 #ols_by_orig_name,
 #

 #f not found_table:
 #aise exc.NoSuchTableError(table.name)

 #elf._reflect_pk(
 #able_name, schema, table, cols_by_orig_name, exclude_columns
 #

 #elf._reflect_fk(
 #able_name,
 #chema,
 #able,
 #ols_by_orig_name,
 #xclude_columns,
 #esolve_fks,
 #extend_on,
 #eflection_options,
 #

 #elf._reflect_indexes(
 #able_name,
 #chema,
 #able,
 #ols_by_orig_name,
 #nclude_columns,
 #xclude_columns,
 #eflection_options,
 #

 #elf._reflect_unique_constraints(
 #able_name,
 #chema,
 #able,
 #ols_by_orig_name,
 #nclude_columns,
 #xclude_columns,
 #eflection_options,
 #

 #elf._reflect_check_constraints(
 #able_name,
 #chema,
 #able,
 #ols_by_orig_name,
 #nclude_columns,
 #xclude_columns,
 #eflection_options,
 #

 #elf._reflect_table_comment(
 #able_name, schema, table, reflection_options
 #

 #ef _reflect_column(
 #elf, table, col_d, include_columns, exclude_columns, cols_by_orig_name
 #:

 #rig_name = col_d["name"]

 #able.metadata.dispatch.column_reflect(self, table, col_d)
 #able.dispatch.column_reflect(self, table, col_d)

        # fetch name again as column_reflect is allowed to
        # change it
 #ame = col_d["name"]
 #f (include_columns and name not in include_columns) or (
 #xclude_columns and name in exclude_columns
 #:
 #eturn

 #oltype = col_d["type"]

 #ol_kw = dict(
 #k, col_d[k])
 #or k in [
 #nullable",
 #autoincrement",
 #quote",
 #info",
 #key",
 #comment",
 #
 #f k in col_d
 #

 #f "dialect_options" in col_d:
 #ol_kw.update(col_d["dialect_options"])

 #olargs = []
 #f col_d.get("default") is not None:
 #efault = col_d["default"]
 #f isinstance(default, sql.elements.TextClause):
 #efault = sa_schema.DefaultClause(default, _reflected=True)
 #lif not isinstance(default, sa_schema.FetchedValue):
 #efault = sa_schema.DefaultClause(
 #ql.text(col_d["default"]), _reflected=True
 #

 #olargs.append(default)

 #f "computed" in col_d:
 #omputed = sa_schema.Computed(**col_d["computed"])
 #olargs.append(computed)

 #f "identity" in col_d:
 #omputed = sa_schema.Identity(**col_d["identity"])
 #olargs.append(computed)

 #f "sequence" in col_d:
 #elf._reflect_col_sequence(col_d, colargs)

 #ols_by_orig_name[orig_name] = col = sa_schema.Column(
 #ame, coltype, *colargs, **col_kw
 #

 #f col.key in table.primary_key:
 #ol.primary_key = True
 #able.append_column(col, replace_existing=True)

 #ef _reflect_col_sequence(self, col_d, colargs):
 #f "sequence" in col_d:
            # TODO: mssql and sybase are using this.
 #eq = col_d["sequence"]
 #equence = sa_schema.Sequence(seq["name"], 1, 1)
 #f "start" in seq:
 #equence.start = seq["start"]
 #f "increment" in seq:
 #equence.increment = seq["increment"]
 #olargs.append(sequence)

 #ef _reflect_pk(
 #elf, table_name, schema, table, cols_by_orig_name, exclude_columns
 #:
 #k_cons = self.get_pk_constraint(
 #able_name, schema, **table.dialect_kwargs
 #
 #f pk_cons:
 #k_cols = [
 #ols_by_orig_name[pk]
 #or pk in pk_cons["constrained_columns"]
 #f pk in cols_by_orig_name and pk not in exclude_columns
 #

            # update pk constraint name
 #able.primary_key.name = pk_cons.get("name")

            # tell the PKConstraint to re-initialize
            # its column collection
 #able.primary_key._reload(pk_cols)

 #ef _reflect_fk(
 #elf,
 #able_name,
 #chema,
 #able,
 #ols_by_orig_name,
 #xclude_columns,
 #esolve_fks,
 #extend_on,
 #eflection_options,
 #:
 #keys = self.get_foreign_keys(
 #able_name, schema, **table.dialect_kwargs
 #
 #or fkey_d in fkeys:
 #onname = fkey_d["name"]
            # look for columns by orig name in cols_by_orig_name,
            # but support columns that are in-Python only as fallback
 #onstrained_columns = [
 #ols_by_orig_name[c].key if c in cols_by_orig_name else c
 #or c in fkey_d["constrained_columns"]
 #
 #f exclude_columns and set(constrained_columns).intersection(
 #xclude_columns
 #:
 #ontinue
 #eferred_schema = fkey_d["referred_schema"]
 #eferred_table = fkey_d["referred_table"]
 #eferred_columns = fkey_d["referred_columns"]
 #efspec = []
 #f referred_schema is not None:
 #f resolve_fks:
 #a_schema.Table(
 #eferred_table,
 #able.metadata,
 #chema=referred_schema,
 #utoload_with=self.bind,
 #extend_on=_extend_on,
 #*reflection_options
 #
 #or column in referred_columns:
 #efspec.append(
 #.".join([referred_schema, referred_table, column])
 #
 #lse:
 #f resolve_fks:
 #a_schema.Table(
 #eferred_table,
 #able.metadata,
 #utoload_with=self.bind,
 #chema=sa_schema.BLANK_SCHEMA,
 #extend_on=_extend_on,
 #*reflection_options
 #
 #or column in referred_columns:
 #efspec.append(".".join([referred_table, column]))
 #f "options" in fkey_d:
 #ptions = fkey_d["options"]
 #lse:
 #ptions = {}
 #able.append_constraint(
 #a_schema.ForeignKeyConstraint(
 #onstrained_columns,
 #efspec,
 #onname,
 #ink_to_name=True,
 #*options
 #
 #

 #index_sort_exprs = [
 #"asc", operators.asc_op),
 #"desc", operators.desc_op),
 #"nulls_first", operators.nulls_first_op),
 #"nulls_last", operators.nulls_last_op),
 #

 #ef _reflect_indexes(
 #elf,
 #able_name,
 #chema,
 #able,
 #ols_by_orig_name,
 #nclude_columns,
 #xclude_columns,
 #eflection_options,
 #:
        # Indexes
 #ndexes = self.get_indexes(table_name, schema)
 #or index_d in indexes:
 #ame = index_d["name"]
 #olumns = index_d["column_names"]
 #olumn_sorting = index_d.get("column_sorting", {})
 #nique = index_d["unique"]
 #lavor = index_d.get("type", "index")
 #ialect_options = index_d.get("dialect_options", {})

 #uplicates = index_d.get("duplicates_constraint")
 #f include_columns and not set(columns).issubset(include_columns):
 #til.warn(
 #Omitting %s key for (%s), key covers omitted columns."
 # (flavor, ", ".join(columns))
 #
 #ontinue
 #f duplicates:
 #ontinue
            # look for columns by orig name in cols_by_orig_name,
            # but support columns that are in-Python only as fallback
 #dx_cols = []
 #or c in columns:
 #ry:
 #dx_col = (
 #ols_by_orig_name[c]
 #f c in cols_by_orig_name
 #lse table.c[c]
 #
 #xcept KeyError:
 #til.warn(
 #%s key '%s' was not located in "
 #columns for table '%s'" % (flavor, c, table_name)
 #
 #ontinue
 #_sorting = column_sorting.get(c, ())
 #or k, op in self._index_sort_exprs:
 #f k in c_sorting:
 #dx_col = op(idx_col)
 #dx_cols.append(idx_col)

 #a_schema.Index(
 #ame,
 #idx_cols,
 #table=table,
 #*dict(list(dialect_options.items()) + [("unique", unique)])
 #

 #ef _reflect_unique_constraints(
 #elf,
 #able_name,
 #chema,
 #able,
 #ols_by_orig_name,
 #nclude_columns,
 #xclude_columns,
 #eflection_options,
 #:

        # Unique Constraints
 #ry:
 #onstraints = self.get_unique_constraints(table_name, schema)
 #xcept NotImplementedError:
            # optional dialect feature
 #eturn

 #or const_d in constraints:
 #onname = const_d["name"]
 #olumns = const_d["column_names"]
 #uplicates = const_d.get("duplicates_index")
 #f include_columns and not set(columns).issubset(include_columns):
 #til.warn(
 #Omitting unique constraint key for (%s), "
 #key covers omitted columns." % ", ".join(columns)
 #
 #ontinue
 #f duplicates:
 #ontinue
            # look for columns by orig name in cols_by_orig_name,
            # but support columns that are in-Python only as fallback
 #onstrained_cols = []
 #or c in columns:
 #ry:
 #onstrained_col = (
 #ols_by_orig_name[c]
 #f c in cols_by_orig_name
 #lse table.c[c]
 #
 #xcept KeyError:
 #til.warn(
 #unique constraint key '%s' was not located in "
 #columns for table '%s'" % (c, table_name)
 #
 #lse:
 #onstrained_cols.append(constrained_col)
 #able.append_constraint(
 #a_schema.UniqueConstraint(*constrained_cols, name=conname)
 #

 #ef _reflect_check_constraints(
 #elf,
 #able_name,
 #chema,
 #able,
 #ols_by_orig_name,
 #nclude_columns,
 #xclude_columns,
 #eflection_options,
 #:
 #ry:
 #onstraints = self.get_check_constraints(table_name, schema)
 #xcept NotImplementedError:
            # optional dialect feature
 #eturn

 #or const_d in constraints:
 #able.append_constraint(sa_schema.CheckConstraint(**const_d))

 #ef _reflect_table_comment(
 #elf, table_name, schema, table, reflection_options
 #:
 #ry:
 #omment_dict = self.get_table_comment(table_name, schema)
 #xcept NotImplementedError:
 #eturn
 #lse:
 #able.comment = comment_dict.get("text", None)
