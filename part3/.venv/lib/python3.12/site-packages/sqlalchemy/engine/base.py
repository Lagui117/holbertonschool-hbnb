# engine/base.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php
from __future__ import with_statement

import contextlib
import sys

from .interfaces import Connectable
from .interfaces import ExceptionContext
from .util import _distill_params
from .util import _distill_params_20
from .util import TransactionalContext
from .. import exc
from .. import inspection
from .. import log
from .. import util
from ..sql import compiler
from ..sql import util as sql_util


"""Defines :class:`_engine.Connection` and :class:`_engine.Engine`.

"""

_EMPTY_EXECUTION_OPTS = util.immutabledict()


class Connection(Connectable):
 #""Provides high-level functionality for a wrapped DB-API connection.

 #*This is the SQLAlchemy 1.x.x version** of the :class:`_engine.Connection`
 #lass.   For the :term:`2.0 style` version, which features some API
 #ifferences, see :class:`_future.Connection`.

 #he :class:`_engine.Connection` object is procured by calling
 #he :meth:`_engine.Engine.connect` method of the :class:`_engine.Engine`
 #bject, and provides services for execution of SQL statements as well
 #s transaction control.

 #he Connection object is **not** thread-safe.  While a Connection can be
 #hared among threads using properly synchronized access, it is still
 #ossible that the underlying DBAPI connection may not support shared
 #ccess between threads.  Check the DBAPI documentation for details.

 #he Connection object represents a single DBAPI connection checked out
 #rom the connection pool. In this state, the connection pool has no affect
 #pon the connection, including its expiration or timeout state. For the
 #onnection pool to properly manage connections, connections should be
 #eturned to the connection pool (i.e. ``connection.close()``) whenever the
 #onnection is not in use.

 #. index::
 #ingle: thread safety; Connection

 #""

 #is_future = False
 #sqla_logger_namespace = "sqlalchemy.engine.Connection"

    # used by sqlalchemy.engine.util.TransactionalContext
 #trans_context_manager = None

 #ef __init__(
 #elf,
 #ngine,
 #onnection=None,
 #lose_with_result=False,
 #branch_from=None,
 #execution_options=None,
 #dispatch=None,
 #has_events=None,
 #allow_revalidate=True,
 #:
 #""Construct a new Connection."""
 #elf.engine = engine
 #elf.dialect = engine.dialect
 #elf.__branch_from = _branch_from

 #f _branch_from:
            # branching is always "from" the root connection
 #ssert _branch_from.__branch_from is None
 #elf._dbapi_connection = connection
 #elf._execution_options = _execution_options
 #elf._echo = _branch_from._echo
 #elf.should_close_with_result = False
 #elf.dispatch = _dispatch
 #elf._has_events = _branch_from._has_events
 #lse:
 #elf._dbapi_connection = (
 #onnection
 #f connection is not None
 #lse engine.raw_connection()
 #

 #elf._transaction = self._nested_transaction = None
 #elf.__savepoint_seq = 0
 #elf.__in_begin = False
 #elf.should_close_with_result = close_with_result

 #elf.__can_reconnect = _allow_revalidate
 #elf._echo = self.engine._should_log_info()

 #f _has_events is None:
                # if _has_events is sent explicitly as False,
                # then don't join the dispatch of the engine; we don't
                # want to handle any of the engine's events in that case.
 #elf.dispatch = self.dispatch._join(engine.dispatch)
 #elf._has_events = _has_events or (
 #has_events is None and engine._has_events
 #

 #ssert not _execution_options
 #elf._execution_options = engine._execution_options

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.engine_connect(self, _branch_from is not None)

 #util.memoized_property
 #ef _message_formatter(self):
 #f "logging_token" in self._execution_options:
 #oken = self._execution_options["logging_token"]
 #eturn lambda msg: "[%s] %s" % (token, msg)
 #lse:
 #eturn None

 #ef _log_info(self, message, *arg, **kw):
 #mt = self._message_formatter

 #f fmt:
 #essage = fmt(message)

 #elf.engine.logger.info(message, *arg, **kw)

 #ef _log_debug(self, message, *arg, **kw):
 #mt = self._message_formatter

 #f fmt:
 #essage = fmt(message)

 #elf.engine.logger.debug(message, *arg, **kw)

 #property
 #ef _schema_translate_map(self):
 #eturn self._execution_options.get("schema_translate_map", None)

 #ef schema_for_object(self, obj):
 #""Return the schema name for the given schema item taking into
 #ccount current schema translate map.

 #""

 #ame = obj.schema
 #chema_translate_map = self._execution_options.get(
 #schema_translate_map", None
 #

 #f (
 #chema_translate_map
 #nd name in schema_translate_map
 #nd obj._use_schema_map
 #:
 #eturn schema_translate_map[name]
 #lse:
 #eturn name

 #ef _branch(self):
 #""Return a new Connection which references this Connection's
 #ngine and connection; but does not have close_with_result enabled,
 #nd also whose close() method does nothing.

 #. deprecated:: 1.4 the "branching" concept will be removed in
 #QLAlchemy 2.0 as well as the "Connection.connect()" method which
 #s the only consumer for this.

 #he Core uses this very sparingly, only in the case of
 #ustom SQL default functions that are to be INSERTed as the
 #rimary key of a row where we need to get the value back, so we have
 #o invoke it distinctly - this is a very uncommon case.

 #serland code accesses _branch() when the connect()
 #ethod is called.  The branched connection
 #cts as much as possible like the parent, except that it stays
 #onnected when a close() event occurs.

 #""
 #eturn self.engine._connection_cls(
 #elf.engine,
 #elf._dbapi_connection,
 #branch_from=self.__branch_from if self.__branch_from else self,
 #execution_options=self._execution_options,
 #has_events=self._has_events,
 #dispatch=self.dispatch,
 #

 #ef _generate_for_options(self):
 #""define connection method chaining behavior for execution_options"""

 #f self._is_future:
 #eturn self
 #lse:
 # = self.__class__.__new__(self.__class__)
 #.__dict__ = self.__dict__.copy()
 #eturn c

 #ef __enter__(self):
 #eturn self

 #ef __exit__(self, type_, value, traceback):
 #elf.close()

 #ef execution_options(self, **opt):
 #""" Set non-SQL options for the connection which take effect
 #uring execution.

 #or a "future" style connection, this method returns this same
 #class:`_future.Connection` object with the new options added.

 #or a legacy connection, this method returns a copy of this
 #class:`_engine.Connection` which references the same underlying DBAPI
 #onnection, but also defines the given execution options which will
 #ake effect for a call to
 #meth:`execute`. As the new :class:`_engine.Connection` references the
 #ame underlying resource, it's usually a good idea to ensure that
 #he copies will be discarded immediately, which is implicit if used
 #s in::

 #esult = connection.execution_options(stream_results=True).\
 #xecute(stmt)

 #ote that any key/value can be passed to
 #meth:`_engine.Connection.execution_options`,
 #nd it will be stored in the
 #`_execution_options`` dictionary of the :class:`_engine.Connection`.
 #t
 #s suitable for usage by end-user schemes to communicate with
 #vent listeners, for example.

 #he keywords that are currently recognized by SQLAlchemy itself
 #nclude all those listed under :meth:`.Executable.execution_options`,
 #s well as others that are specific to :class:`_engine.Connection`.

 #param autocommit: Available on: Connection, statement.
 #hen True, a COMMIT will be invoked after execution
 #hen executed in 'autocommit' mode, i.e. when an explicit
 #ransaction is not begun on the connection.   Note that this
 #s **library level, not DBAPI level autocommit**.  The DBAPI
 #onnection will remain in a real transaction unless the
 #AUTOCOMMIT" isolation level is used.

 #. deprecated:: 1.4  The "autocommit" execution option is deprecated
 #nd will be removed in SQLAlchemy 2.0.  See
 #ref:`migration_20_autocommit` for discussion.

 #param compiled_cache: Available on: Connection.
 # dictionary where :class:`.Compiled` objects
 #ill be cached when the :class:`_engine.Connection`
 #ompiles a clause
 #xpression into a :class:`.Compiled` object.  This dictionary will
 #upersede the statement cache that may be configured on the
 #class:`_engine.Engine` itself.   If set to None, caching
 #s disabled, even if the engine has a configured cache size.

 #ote that the ORM makes use of its own "compiled" caches for
 #ome operations, including flush operations.  The caching
 #sed by the ORM internally supersedes a cache dictionary
 #pecified here.

 #param logging_token: Available on: :class:`_engine.Connection`,
 #class:`_engine.Engine`.

 #dds the specified string token surrounded by brackets in log
 #essages logged by the connection, i.e. the logging that's enabled
 #ither via the :paramref:`_sa.create_engine.echo` flag or via the
 #`logging.getLogger("sqlalchemy.engine")`` logger. This allows a
 #er-connection or per-sub-engine token to be available which is
 #seful for debugging concurrent connection scenarios.

 #. versionadded:: 1.4.0b2

 #. seealso::

 #ref:`dbengine_logging_tokens` - usage example

 #paramref:`_sa.create_engine.logging_name` - adds a name to the
 #ame used by the Python logger object itself.

 #param isolation_level: Available on: :class:`_engine.Connection`.

 #et the transaction isolation level for the lifespan of this
 #class:`_engine.Connection` object.
 #alid values include those string
 #alues accepted by the :paramref:`_sa.create_engine.isolation_level`
 #arameter passed to :func:`_sa.create_engine`.  These levels are
 #emi-database specific; see individual dialect documentation for
 #alid levels.

 #he isolation level option applies the isolation level by emitting
 #tatements on the  DBAPI connection, and **necessarily affects the
 #riginal Connection object overall**, not just the copy that is
 #eturned by the call to :meth:`_engine.Connection.execution_options`
 #ethod.  The isolation level will remain at the given setting until
 #he DBAPI connection itself is returned to the connection pool, i.e.
 #he :meth:`_engine.Connection.close` method on the original
 #class:`_engine.Connection` is called,
 #here  an event handler will emit
 #dditional statements on the DBAPI connection in order to revert the
 #solation level change.

 #. warning::  The ``isolation_level`` execution option should
 #*not** be used when a transaction is already established, that
 #s, the :meth:`_engine.Connection.begin`
 #ethod or similar has been
 #alled.  A database cannot change the isolation level on a
 #ransaction in progress, and different DBAPIs and/or
 #QLAlchemy dialects may implicitly roll back or commit
 #he transaction, or not affect the connection at all.

 #. note:: The ``isolation_level`` execution option is implicitly
 #eset if the :class:`_engine.Connection` is invalidated, e.g. via
 #he :meth:`_engine.Connection.invalidate` method, or if a
 #isconnection error occurs.  The new connection produced after
 #he invalidation will not have the isolation level re-applied
 #o it automatically.

 #. seealso::

 #paramref:`_sa.create_engine.isolation_level`
 # set per :class:`_engine.Engine` isolation level

 #meth:`_engine.Connection.get_isolation_level`
 # view current level

 #ref:`SQLite Transaction Isolation <sqlite_isolation_level>`

 #ref:`PostgreSQL Transaction Isolation <postgresql_isolation_level>`

 #ref:`MySQL Transaction Isolation <mysql_isolation_level>`

 #ref:`SQL Server Transaction Isolation <mssql_isolation_level>`

 #ref:`session_transaction_isolation` - for the ORM

 #param no_parameters: When ``True``, if the final parameter
 #ist or dictionary is totally empty, will invoke the
 #tatement on the cursor as ``cursor.execute(statement)``,
 #ot passing the parameter collection at all.
 #ome DBAPIs such as psycopg2 and mysql-python consider
 #ercent signs as significant only when parameters are
 #resent; this option allows code to generate SQL
 #ontaining percent signs (and possibly other characters)
 #hat is neutral regarding whether it's executed by the DBAPI
 #r piped into a script that's later invoked by
 #ommand line tools.

 #param stream_results: Available on: Connection, statement.
 #ndicate to the dialect that results should be
 #streamed" and not pre-buffered, if possible.  This is a limitation
 #f many DBAPIs.  The flag is currently understood within a subset
 #f dialects within the PostgreSQL and MySQL categories, and
 #ay be supported by other third party dialects as well.

 #. seealso::

 #ref:`engine_stream_results`

 #param schema_translate_map: Available on: Connection, Engine.
 # dictionary mapping schema names to schema names, that will be
 #pplied to the :paramref:`_schema.Table.schema` element of each
 #class:`_schema.Table`
 #ncountered when SQL or DDL expression elements
 #re compiled into strings; the resulting schema name will be
 #onverted based on presence in the map of the original name.

 #. versionadded:: 1.1

 #. seealso::

 #ref:`schema_translating`

 #. seealso::

 #meth:`_engine.Engine.execution_options`

 #meth:`.Executable.execution_options`

 #meth:`_engine.Connection.get_execution_options`


 #""  # noqa
 # = self._generate_for_options()
 #._execution_options = c._execution_options.union(opt)
 #f self._has_events or self.engine._has_events:
 #elf.dispatch.set_connection_execution_options(c, opt)
 #elf.dialect.set_connection_execution_options(c, opt)
 #eturn c

 #ef get_execution_options(self):
 #""Get the non-SQL options which will take effect during execution.

 #. versionadded:: 1.3

 #. seealso::

 #meth:`_engine.Connection.execution_options`
 #""
 #eturn self._execution_options

 #property
 #ef closed(self):
 #""Return True if this connection is closed."""

        # note this is independent for a "branched" connection vs.
        # the base

 #eturn self._dbapi_connection is None and not self.__can_reconnect

 #property
 #ef invalidated(self):
 #""Return True if this connection was invalidated."""

        # prior to 1.4, "invalid" was stored as a state independent of
        # "closed", meaning an invalidated connection could be "closed",
        # the _dbapi_connection would be None and closed=True, yet the
        # "invalid" flag would stay True.  This meant that there were
        # three separate states (open/valid, closed/valid, closed/invalid)
        # when there is really no reason for that; a connection that's
        # "closed" does not need to be "invalid".  So the state is now
        # represented by the two facts alone.

 #f self.__branch_from:
 #eturn self.__branch_from.invalidated

 #eturn self._dbapi_connection is None and not self.closed

 #property
 #ef connection(self):
 #""The underlying DB-API connection managed by this Connection.

 #. seealso::


 #ref:`dbapi_connections`

 #""

 #f self._dbapi_connection is None:
 #ry:
 #eturn self._revalidate_connection()
 #xcept (exc.PendingRollbackError, exc.ResourceClosedError):
 #aise
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)
 #lse:
 #eturn self._dbapi_connection

 #ef get_isolation_level(self):
 #""Return the current isolation level assigned to this
 #class:`_engine.Connection`.

 #his will typically be the default isolation level as determined
 #y the dialect, unless if the
 #paramref:`.Connection.execution_options.isolation_level`
 #eature has been used to alter the isolation level on a
 #er-:class:`_engine.Connection` basis.

 #his attribute will typically perform a live SQL operation in order
 #o procure the current isolation level, so the value returned is the
 #ctual level on the underlying DBAPI connection regardless of how
 #his state was set.  Compare to the
 #attr:`_engine.Connection.default_isolation_level` accessor
 #hich returns the dialect-level setting without performing a SQL
 #uery.

 #. versionadded:: 0.9.9

 #. seealso::

 #attr:`_engine.Connection.default_isolation_level`
 # view default level

 #paramref:`_sa.create_engine.isolation_level`
 # set per :class:`_engine.Engine` isolation level

 #paramref:`.Connection.execution_options.isolation_level`
 # set per :class:`_engine.Connection` isolation level

 #""
 #ry:
 #eturn self.dialect.get_isolation_level(self.connection)
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)

 #property
 #ef default_isolation_level(self):
 #""The default isolation level assigned to this
 #class:`_engine.Connection`.

 #his is the isolation level setting that the
 #class:`_engine.Connection`
 #as when first procured via the :meth:`_engine.Engine.connect` method.
 #his level stays in place until the
 #paramref:`.Connection.execution_options.isolation_level` is used
 #o change the setting on a per-:class:`_engine.Connection` basis.

 #nlike :meth:`_engine.Connection.get_isolation_level`,
 #his attribute is set
 #head of time from the first connection procured by the dialect,
 #o SQL query is not invoked when this accessor is called.

 #. versionadded:: 0.9.9

 #. seealso::

 #meth:`_engine.Connection.get_isolation_level`
 # view current level

 #paramref:`_sa.create_engine.isolation_level`
 # set per :class:`_engine.Engine` isolation level

 #paramref:`.Connection.execution_options.isolation_level`
 # set per :class:`_engine.Connection` isolation level

 #""
 #eturn self.dialect.default_isolation_level

 #ef _invalid_transaction(self):
 #f self.invalidated:
 #aise exc.PendingRollbackError(
 #Can't reconnect until invalid %stransaction is rolled "
 #back."
 # (
 #savepoint "
 #f self._nested_transaction is not None
 #lse ""
 #,
 #ode="8s2b",
 #
 #lse:
 #ssert not self._is_future
 #aise exc.PendingRollbackError(
 #This connection is on an inactive %stransaction.  "
 #Please rollback() fully before proceeding."
 # (
 #savepoint "
 #f self._nested_transaction is not None
 #lse ""
 #,
 #ode="8s2a",
 #

 #ef _revalidate_connection(self):
 #f self.__branch_from:
 #eturn self.__branch_from._revalidate_connection()
 #f self.__can_reconnect and self.invalidated:
 #f self._transaction is not None:
 #elf._invalid_transaction()
 #elf._dbapi_connection = self.engine.raw_connection(
 #connection=self
 #
 #eturn self._dbapi_connection
 #aise exc.ResourceClosedError("This Connection is closed")

 #property
 #ef _still_open_and_dbapi_connection_is_valid(self):
 #eturn self._dbapi_connection is not None and getattr(
 #elf._dbapi_connection, "is_valid", False
 #

 #property
 #ef info(self):
 #""Info dictionary associated with the underlying DBAPI connection
 #eferred to by this :class:`_engine.Connection`, allowing user-defined
 #ata to be associated with the connection.

 #he data here will follow along with the DBAPI connection including
 #fter it is returned to the connection pool and used again
 #n subsequent instances of :class:`_engine.Connection`.

 #""

 #eturn self.connection.info

 #util.deprecated_20(":meth:`.Connection.connect`")
 #ef connect(self, close_with_result=False):
 #""Returns a branched version of this :class:`_engine.Connection`.

 #he :meth:`_engine.Connection.close` method on the returned
 #class:`_engine.Connection` can be called and this
 #class:`_engine.Connection` will remain open.

 #his method provides usage symmetry with
 #meth:`_engine.Engine.connect`, including for usage
 #ith context managers.

 #""

 #eturn self._branch()

 #ef invalidate(self, exception=None):
 #""Invalidate the underlying DBAPI connection associated with
 #his :class:`_engine.Connection`.

 #n attempt will be made to close the underlying DBAPI connection
 #mmediately; however if this operation fails, the error is logged
 #ut not raised.  The connection is then discarded whether or not
 #lose() succeeded.

 #pon the next use (where "use" typically means using the
 #meth:`_engine.Connection.execute` method or similar),
 #his :class:`_engine.Connection` will attempt to
 #rocure a new DBAPI connection using the services of the
 #class:`_pool.Pool` as a source of connectivity (e.g.
 # "reconnection").

 #f a transaction was in progress (e.g. the
 #meth:`_engine.Connection.begin` method has been called) when
 #meth:`_engine.Connection.invalidate` method is called, at the DBAPI
 #evel all state associated with this transaction is lost, as
 #he DBAPI connection is closed.  The :class:`_engine.Connection`
 #ill not allow a reconnection to proceed until the
 #class:`.Transaction` object is ended, by calling the
 #meth:`.Transaction.rollback` method; until that point, any attempt at
 #ontinuing to use the :class:`_engine.Connection` will raise an
 #class:`~sqlalchemy.exc.InvalidRequestError`.
 #his is to prevent applications from accidentally
 #ontinuing an ongoing transactional operations despite the
 #act that the transaction has been lost due to an
 #nvalidation.

 #he :meth:`_engine.Connection.invalidate` method,
 #ust like auto-invalidation,
 #ill at the connection pool level invoke the
 #meth:`_events.PoolEvents.invalidate` event.

 #param exception: an optional ``Exception`` instance that's the
 #eason for the invalidation.  is passed along to event handlers
 #nd logging functions.

 #. seealso::

 #ref:`pool_connection_invalidation`

 #""

 #f self.__branch_from:
 #eturn self.__branch_from.invalidate(exception=exception)

 #f self.invalidated:
 #eturn

 #f self.closed:
 #aise exc.ResourceClosedError("This Connection is closed")

 #f self._still_open_and_dbapi_connection_is_valid:
 #elf._dbapi_connection.invalidate(exception)
 #elf._dbapi_connection = None

 #ef detach(self):
 #""Detach the underlying DB-API connection from its connection pool.

 #.g.::

 #ith engine.connect() as conn:
 #onn.detach()
 #onn.execute(text("SET search_path TO schema1, schema2"))

                # work with connection

            # connection is fully closed (since we used "with:", can
            # also call .close())

 #his :class:`_engine.Connection` instance will remain usable.
 #hen closed
 #or exited from a context manager context as above),
 #he DB-API connection will be literally closed and not
 #eturned to its originating pool.

 #his method can be used to insulate the rest of an application
 #rom a modified state on a connection (such as a transaction
 #solation level or similar).

 #""

 #elf._dbapi_connection.detach()

 #ef _autobegin(self):
 #elf.begin()

 #ef begin(self):
 #""Begin a transaction and return a transaction handle.

 #he returned object is an instance of :class:`.Transaction`.
 #his object represents the "scope" of the transaction,
 #hich completes when either the :meth:`.Transaction.rollback`
 #r :meth:`.Transaction.commit` method is called.

 #. tip::

 #he :meth:`_engine.Connection.begin` method is invoked when using
 #he :meth:`_engine.Engine.begin` context manager method as well.
 #ll documentation that refers to behaviors specific to the
 #meth:`_engine.Connection.begin` method also apply to use of the
 #meth:`_engine.Engine.begin` method.

 #egacy use: nested calls to :meth:`.begin` on the same
 #class:`_engine.Connection` will return new :class:`.Transaction`
 #bjects that represent an emulated transaction within the scope of the
 #nclosing transaction, that is::

 #rans = conn.begin()   # outermost transaction
 #rans2 = conn.begin()  # "nested"
 #rans2.commit()        # does nothing
 #rans.commit()         # actually commits

 #alls to :meth:`.Transaction.commit` only have an effect
 #hen invoked via the outermost :class:`.Transaction` object, though the
 #meth:`.Transaction.rollback` method of any of the
 #class:`.Transaction` objects will roll back the
 #ransaction.

 #. tip::

 #he above "nesting" behavior is a legacy behavior specific to
 #term:`1.x style` use and will be removed in SQLAlchemy 2.0. For
 #otes on :term:`2.0 style` use, see
 #meth:`_future.Connection.begin`.


 #. seealso::

 #meth:`_engine.Connection.begin_nested` - use a SAVEPOINT

 #meth:`_engine.Connection.begin_twophase` -
 #se a two phase /XID transaction

 #meth:`_engine.Engine.begin` - context manager available from
 #class:`_engine.Engine`

 #""
 #f self._is_future:
 #ssert not self.__branch_from
 #lif self.__branch_from:
 #eturn self.__branch_from.begin()

 #f self.__in_begin:
            # for dialects that emit SQL within the process of
            # dialect.do_begin() or dialect.do_begin_twophase(), this
            # flag prevents "autobegin" from being emitted within that
            # process, while allowing self._transaction to remain at None
            # until it's complete.
 #eturn
 #lif self._transaction is None:
 #elf._transaction = RootTransaction(self)
 #eturn self._transaction
 #lse:
 #f self._is_future:
 #aise exc.InvalidRequestError(
 #a transaction is already begun for this connection"
 #
 #lse:
 #eturn MarkerTransaction(self)

 #ef begin_nested(self):
 #""Begin a nested transaction (i.e. SAVEPOINT) and return a
 #ransaction handle, assuming an outer transaction is already
 #stablished.

 #ested transactions require SAVEPOINT support in the
 #nderlying database.  Any transaction in the hierarchy may
 #`commit`` and ``rollback``, however the outermost transaction
 #till controls the overall ``commit`` or ``rollback`` of the
 #ransaction of a whole.

 #he legacy form of :meth:`_engine.Connection.begin_nested` method has
 #lternate behaviors based on whether or not the
 #meth:`_engine.Connection.begin` method was called previously. If
 #meth:`_engine.Connection.begin` was not called, then this method will
 #ehave the same as the :meth:`_engine.Connection.begin` method and
 #eturn a :class:`.RootTransaction` object that begins and commits a
 #eal transaction - **no savepoint is invoked**. If
 #meth:`_engine.Connection.begin` **has** been called, and a
 #class:`.RootTransaction` is already established, then this method
 #eturns an instance of :class:`.NestedTransaction` which will invoke
 #nd manage the scope of a SAVEPOINT.

 #. tip::

 #he above mentioned behavior of
 #meth:`_engine.Connection.begin_nested` is a legacy behavior
 #pecific to :term:`1.x style` use. In :term:`2.0 style` use, the
 #meth:`_future.Connection.begin_nested` method instead autobegins
 #he outer transaction that can be committed using
 #commit-as-you-go" style; see
 #meth:`_future.Connection.begin_nested` for migration details.

 #. versionchanged:: 1.4.13 The behavior of
 #meth:`_engine.Connection.begin_nested`
 #s returning a :class:`.RootTransaction` if
 #meth:`_engine.Connection.begin` were not called has been restored
 #s was the case in 1.3.x versions; in previous 1.4.x versions, an
 #uter transaction would be "autobegun" but would not be committed.


 #. seealso::

 #meth:`_engine.Connection.begin`

 #meth:`_engine.Connection.begin_twophase`

 #""
 #f self._is_future:
 #ssert not self.__branch_from
 #lif self.__branch_from:
 #eturn self.__branch_from.begin_nested()

 #f self._transaction is None:
 #f not self._is_future:
 #til.warn_deprecated_20(
 #Calling Connection.begin_nested() in 2.0 style use will "
 #return a NestedTransaction (SAVEPOINT) in all cases, "
 #that will not commit the outer transaction.  For code "
 #that is cross-compatible between 1.x and 2.0 style use, "
 #ensure Connection.begin() is called before calling "
 #Connection.begin_nested()."
 #
 #eturn self.begin()
 #lse:
 #elf._autobegin()

 #eturn NestedTransaction(self)

 #ef begin_twophase(self, xid=None):
 #""Begin a two-phase or XA transaction and return a transaction
 #andle.

 #he returned object is an instance of :class:`.TwoPhaseTransaction`,
 #hich in addition to the methods provided by
 #class:`.Transaction`, also provides a
 #meth:`~.TwoPhaseTransaction.prepare` method.

 #param xid: the two phase transaction id.  If not supplied, a
 #andom id will be generated.

 #. seealso::

 #meth:`_engine.Connection.begin`

 #meth:`_engine.Connection.begin_twophase`

 #""

 #f self.__branch_from:
 #eturn self.__branch_from.begin_twophase(xid=xid)

 #f self._transaction is not None:
 #aise exc.InvalidRequestError(
 #Cannot start a two phase transaction when a transaction "
 #is already in progress."
 #
 #f xid is None:
 #id = self.engine.dialect.create_xid()
 #eturn TwoPhaseTransaction(self, xid)

 #ef recover_twophase(self):
 #eturn self.engine.dialect.do_recover_twophase(self)

 #ef rollback_prepared(self, xid, recover=False):
 #elf.engine.dialect.do_rollback_twophase(self, xid, recover=recover)

 #ef commit_prepared(self, xid, recover=False):
 #elf.engine.dialect.do_commit_twophase(self, xid, recover=recover)

 #ef in_transaction(self):
 #""Return True if a transaction is in progress."""
 #f self.__branch_from is not None:
 #eturn self.__branch_from.in_transaction()

 #eturn self._transaction is not None and self._transaction.is_active

 #ef in_nested_transaction(self):
 #""Return True if a transaction is in progress."""
 #f self.__branch_from is not None:
 #eturn self.__branch_from.in_nested_transaction()

 #eturn (
 #elf._nested_transaction is not None
 #nd self._nested_transaction.is_active
 #

 #ef _is_autocommit(self):
 #eturn (
 #elf._execution_options.get("isolation_level", None)
 #= "AUTOCOMMIT"
 #

 #ef get_transaction(self):
 #""Return the current root transaction in progress, if any.

 #. versionadded:: 1.4

 #""

 #f self.__branch_from is not None:
 #eturn self.__branch_from.get_transaction()

 #eturn self._transaction

 #ef get_nested_transaction(self):
 #""Return the current nested transaction in progress, if any.

 #. versionadded:: 1.4

 #""
 #f self.__branch_from is not None:

 #eturn self.__branch_from.get_nested_transaction()

 #eturn self._nested_transaction

 #ef _begin_impl(self, transaction):
 #ssert not self.__branch_from

 #f self._echo:
 #elf._log_info("BEGIN (implicit)")

 #elf.__in_begin = True

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.begin(self)

 #ry:
 #elf.engine.dialect.do_begin(self.connection)
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)
 #inally:
 #elf.__in_begin = False

 #ef _rollback_impl(self):
 #ssert not self.__branch_from

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.rollback(self)

 #f self._still_open_and_dbapi_connection_is_valid:
 #f self._echo:
 #f self._is_autocommit():
 #elf._log_info(
 #ROLLBACK using DBAPI connection.rollback(), "
 #DBAPI should ignore due to autocommit mode"
 #
 #lse:
 #elf._log_info("ROLLBACK")
 #ry:
 #elf.engine.dialect.do_rollback(self.connection)
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)

 #ef _commit_impl(self, autocommit=False):
 #ssert not self.__branch_from

        # AUTOCOMMIT isolation-level is a dialect-specific concept, however
        # if a connection has this set as the isolation level, we can skip
        # the "autocommit" warning as the operation will do "autocommit"
        # in any case
 #f autocommit and not self._is_autocommit():
 #til.warn_deprecated_20(
 #The current statement is being autocommitted using "
 #implicit autocommit, which will be removed in "
 #SQLAlchemy 2.0. "
 #Use the .begin() method of Engine or Connection in order to "
 #use an explicit transaction for DML and DDL statements."
 #

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.commit(self)

 #f self._echo:
 #f self._is_autocommit():
 #elf._log_info(
 #COMMIT using DBAPI connection.commit(), "
 #DBAPI should ignore due to autocommit mode"
 #
 #lse:
 #elf._log_info("COMMIT")
 #ry:
 #elf.engine.dialect.do_commit(self.connection)
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)

 #ef _savepoint_impl(self, name=None):
 #ssert not self.__branch_from

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.savepoint(self, name)

 #f name is None:
 #elf.__savepoint_seq += 1
 #ame = "sa_savepoint_%s" % self.__savepoint_seq
 #f self._still_open_and_dbapi_connection_is_valid:
 #elf.engine.dialect.do_savepoint(self, name)
 #eturn name

 #ef _rollback_to_savepoint_impl(self, name):
 #ssert not self.__branch_from

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.rollback_savepoint(self, name, None)

 #f self._still_open_and_dbapi_connection_is_valid:
 #elf.engine.dialect.do_rollback_to_savepoint(self, name)

 #ef _release_savepoint_impl(self, name):
 #ssert not self.__branch_from

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.release_savepoint(self, name, None)

 #f self._still_open_and_dbapi_connection_is_valid:
 #elf.engine.dialect.do_release_savepoint(self, name)

 #ef _begin_twophase_impl(self, transaction):
 #ssert not self.__branch_from

 #f self._echo:
 #elf._log_info("BEGIN TWOPHASE (implicit)")
 #f self._has_events or self.engine._has_events:
 #elf.dispatch.begin_twophase(self, transaction.xid)

 #f self._still_open_and_dbapi_connection_is_valid:
 #elf.__in_begin = True
 #ry:
 #elf.engine.dialect.do_begin_twophase(self, transaction.xid)
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)
 #inally:
 #elf.__in_begin = False

 #ef _prepare_twophase_impl(self, xid):
 #ssert not self.__branch_from

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.prepare_twophase(self, xid)

 #f self._still_open_and_dbapi_connection_is_valid:
 #ssert isinstance(self._transaction, TwoPhaseTransaction)
 #ry:
 #elf.engine.dialect.do_prepare_twophase(self, xid)
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)

 #ef _rollback_twophase_impl(self, xid, is_prepared):
 #ssert not self.__branch_from

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.rollback_twophase(self, xid, is_prepared)

 #f self._still_open_and_dbapi_connection_is_valid:
 #ssert isinstance(self._transaction, TwoPhaseTransaction)
 #ry:
 #elf.engine.dialect.do_rollback_twophase(
 #elf, xid, is_prepared
 #
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)

 #ef _commit_twophase_impl(self, xid, is_prepared):
 #ssert not self.__branch_from

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.commit_twophase(self, xid, is_prepared)

 #f self._still_open_and_dbapi_connection_is_valid:
 #ssert isinstance(self._transaction, TwoPhaseTransaction)
 #ry:
 #elf.engine.dialect.do_commit_twophase(self, xid, is_prepared)
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)

 #ef _autorollback(self):
 #f self.__branch_from:
 #elf.__branch_from._autorollback()

 #f not self.in_transaction():
 #elf._rollback_impl()

 #ef _warn_for_legacy_exec_format(self):
 #til.warn_deprecated_20(
 #The connection.execute() method in "
 #SQLAlchemy 2.0 will accept parameters as a single "
 #dictionary or a "
 #single sequence of dictionaries only. "
 #Parameters passed as keyword arguments, tuples or positionally "
 #oriented dictionaries and/or tuples "
 #will no longer be accepted."
 #

 #ef close(self):
 #""Close this :class:`_engine.Connection`.

 #his results in a release of the underlying database
 #esources, that is, the DBAPI connection referenced
 #nternally. The DBAPI connection is typically restored
 #ack to the connection-holding :class:`_pool.Pool` referenced
 #y the :class:`_engine.Engine` that produced this
 #class:`_engine.Connection`. Any transactional state present on
 #he DBAPI connection is also unconditionally released via
 #he DBAPI connection's ``rollback()`` method, regardless
 #f any :class:`.Transaction` object that may be
 #utstanding with regards to this :class:`_engine.Connection`.

 #fter :meth:`_engine.Connection.close` is called, the
 #class:`_engine.Connection` is permanently in a closed state,
 #nd will allow no further operations.

 #""

 #f self.__branch_from:
 #ssert not self._is_future
 #til.warn_deprecated_20(
 #The .close() method on a so-called 'branched' connection is "
 #deprecated as of 1.4, as are 'branched' connections overall, "
 #and will be removed in a future release.  If this is a "
 #default-handling function, don't close the connection."
 #
 #elf._dbapi_connection = None
 #elf.__can_reconnect = False
 #eturn

 #f self._transaction:
 #elf._transaction.close()
 #kip_reset = True
 #lse:
 #kip_reset = False

 #f self._dbapi_connection is not None:
 #onn = self._dbapi_connection

            # as we just closed the transaction, close the connection
            # pool connection without doing an additional reset
 #f skip_reset:
 #onn._close_no_reset()
 #lse:
 #onn.close()

            # There is a slight chance that conn.close() may have
            # triggered an invalidation here in which case
            # _dbapi_connection would already be None, however usually
            # it will be non-None here and in a "closed" state.
 #elf._dbapi_connection = None
 #elf.__can_reconnect = False

 #ef scalar(self, object_, *multiparams, **params):
 #""Executes and returns the first column of the first row.

 #he underlying result/cursor is closed after execution.
 #""

 #eturn self.execute(object_, *multiparams, **params).scalar()

 #ef execute(self, statement, *multiparams, **params):
 #"""Executes a SQL statement construct and returns a
 #class:`_engine.CursorResult`.

 #param statement: The statement to be executed.  May be
 #ne of:

 # a plain string (deprecated)
 # any :class:`_expression.ClauseElement` construct that is also
 # subclass of :class:`.Executable`, such as a
 #func:`_expression.select` construct
 # a :class:`.FunctionElement`, such as that generated
 #y :data:`.func`, will be automatically wrapped in
 # SELECT statement, which is then executed.
 # a :class:`.DDLElement` object
 # a :class:`.DefaultGenerator` object
 # a :class:`.Compiled` object

 #. deprecated:: 2.0 passing a string to
 #meth:`_engine.Connection.execute` is
 #eprecated and will be removed in version 2.0.  Use the
 #func:`_expression.text` construct with
 #meth:`_engine.Connection.execute`, or the
 #meth:`_engine.Connection.exec_driver_sql`
 #ethod to invoke a driver-level
 #QL string.

 #param \*multiparams/\**params: represent bound parameter
 #alues to be used in the execution.   Typically,
 #he format is either a collection of one or more
 #ictionaries passed to \*multiparams::

 #onn.execute(
 #able.insert(),
 #"id":1, "value":"v1"},
 #"id":2, "value":"v2"}
 #

 #..or individual key/values interpreted by \**params::

 #onn.execute(
 #able.insert(), id=1, value="v1"
 #

 #n the case that a plain SQL string is passed, and the underlying
 #BAPI accepts positional bind parameters, a collection of tuples
 #r individual values in \*multiparams may be passed::

 #onn.execute(
 #INSERT INTO table (id, value) VALUES (?, ?)",
 #1, "v1"), (2, "v2")
 #

 #onn.execute(
 #INSERT INTO table (id, value) VALUES (?, ?)",
 #, "v1"
 #

 #ote above, the usage of a question mark "?" or other
 #ymbol is contingent upon the "paramstyle" accepted by the DBAPI
 #n use, which may be any of "qmark", "named", "pyformat", "format",
 #numeric".   See `pep-249
 #https://www.python.org/dev/peps/pep-0249/>`_ for details on
 #aramstyle.

 #o execute a textual SQL statement which uses bound parameters in a
 #BAPI-agnostic way, use the :func:`_expression.text` construct.

 #. deprecated:: 2.0 use of tuple or scalar positional parameters
 #s deprecated. All params should be dicts or sequences of dicts.
 #se :meth:`.exec_driver_sql` to execute a plain string with
 #uple or scalar positional parameters.

 #""

 #f isinstance(statement, util.string_types):
 #til.warn_deprecated_20(
 #Passing a string to Connection.execute() is "
 #deprecated and will be removed in version 2.0.  Use the "
 #text() construct, "
 #or the Connection.exec_driver_sql() method to invoke a "
 #driver-level SQL string."
 #

 #eturn self._exec_driver_sql(
 #tatement,
 #ultiparams,
 #arams,
 #EMPTY_EXECUTION_OPTS,
 #uture=False,
 #

 #ry:
 #eth = statement._execute_on_connection
 #xcept AttributeError as err:
 #til.raise_(
 #xc.ObjectNotExecutableError(statement), replace_context=err
 #
 #lse:
 #eturn meth(self, multiparams, params, _EMPTY_EXECUTION_OPTS)

 #ef _execute_function(self, func, multiparams, params, execution_options):
 #""Execute a sql.FunctionElement object."""

 #eturn self._execute_clauseelement(
 #unc.select(), multiparams, params, execution_options
 #

 #ef _execute_default(
 #elf,
 #efault,
 #ultiparams,
 #arams,
        # migrate is calling this directly :(
 #xecution_options=_EMPTY_EXECUTION_OPTS,
 #:
 #""Execute a schema.ColumnDefault object."""

 #xecution_options = self._execution_options.merge_with(
 #xecution_options
 #

 #istilled_parameters = _distill_params(self, multiparams, params)

 #f self._has_events or self.engine._has_events:
 #
 #istilled_params,
 #vent_multiparams,
 #vent_params,
 # = self._invoke_before_exec_event(
 #efault, distilled_parameters, execution_options
 #

 #ry:
 #onn = self._dbapi_connection
 #f conn is None:
 #onn = self._revalidate_connection()

 #ialect = self.dialect
 #tx = dialect.execution_ctx_cls._init_default(
 #ialect, self, conn, execution_options
 #
 #xcept (exc.PendingRollbackError, exc.ResourceClosedError):
 #aise
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(e, None, None, None, None)

 #et = ctx._exec_default(None, default, None)
 #f self.should_close_with_result:
 #elf.close()

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.after_execute(
 #elf,
 #efault,
 #vent_multiparams,
 #vent_params,
 #xecution_options,
 #et,
 #

 #eturn ret

 #ef _execute_ddl(self, ddl, multiparams, params, execution_options):
 #""Execute a schema.DDL object."""

 #xecution_options = ddl._execution_options.merge_with(
 #elf._execution_options, execution_options
 #

 #istilled_parameters = _distill_params(self, multiparams, params)

 #f self._has_events or self.engine._has_events:
 #
 #istilled_params,
 #vent_multiparams,
 #vent_params,
 # = self._invoke_before_exec_event(
 #dl, distilled_parameters, execution_options
 #

 #xec_opts = self._execution_options.merge_with(execution_options)
 #chema_translate_map = exec_opts.get("schema_translate_map", None)

 #ialect = self.dialect

 #ompiled = ddl.compile(
 #ialect=dialect, schema_translate_map=schema_translate_map
 #
 #et = self._execute_context(
 #ialect,
 #ialect.execution_ctx_cls._init_ddl,
 #ompiled,
 #one,
 #xecution_options,
 #ompiled,
 #
 #f self._has_events or self.engine._has_events:
 #elf.dispatch.after_execute(
 #elf,
 #dl,
 #vent_multiparams,
 #vent_params,
 #xecution_options,
 #et,
 #
 #eturn ret

 #ef _invoke_before_exec_event(
 #elf, elem, distilled_params, execution_options
 #:

 #f len(distilled_params) == 1:
 #vent_multiparams, event_params = [], distilled_params[0]
 #lse:
 #vent_multiparams, event_params = distilled_params, {}

 #or fn in self.dispatch.before_execute:
 #lem, event_multiparams, event_params = fn(
 #elf,
 #lem,
 #vent_multiparams,
 #vent_params,
 #xecution_options,
 #

 #f event_multiparams:
 #istilled_params = list(event_multiparams)
 #f event_params:
 #aise exc.InvalidRequestError(
 #Event handler can't return non-empty multiparams "
 #and params at the same time"
 #
 #lif event_params:
 #istilled_params = [event_params]
 #lse:
 #istilled_params = []

 #eturn distilled_params, event_multiparams, event_params

 #ef _execute_clauseelement(
 #elf, elem, multiparams, params, execution_options
 #:
 #""Execute a sql.ClauseElement object."""

 #xecution_options = elem._execution_options.merge_with(
 #elf._execution_options, execution_options
 #

 #istilled_params = _distill_params(self, multiparams, params)

 #as_events = self._has_events or self.engine._has_events
 #f has_events:
 #
 #istilled_params,
 #vent_multiparams,
 #vent_params,
 # = self._invoke_before_exec_event(
 #lem, distilled_params, execution_options
 #

 #f distilled_params:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
 #eys = sorted(distilled_params[0])
 #or_executemany = len(distilled_params) > 1
 #lse:
 #eys = []
 #or_executemany = False

 #ialect = self.dialect

 #chema_translate_map = execution_options.get(
 #schema_translate_map", None
 #

 #ompiled_cache = execution_options.get(
 #compiled_cache", self.engine._compiled_cache
 #

 #ompiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
 #ialect=dialect,
 #ompiled_cache=compiled_cache,
 #olumn_keys=keys,
 #or_executemany=for_executemany,
 #chema_translate_map=schema_translate_map,
 #inting=self.dialect.compiler_linting | compiler.WARN_LINTING,
 #
 #et = self._execute_context(
 #ialect,
 #ialect.execution_ctx_cls._init_compiled,
 #ompiled_sql,
 #istilled_params,
 #xecution_options,
 #ompiled_sql,
 #istilled_params,
 #lem,
 #xtracted_params,
 #ache_hit=cache_hit,
 #
 #f has_events:
 #elf.dispatch.after_execute(
 #elf,
 #lem,
 #vent_multiparams,
 #vent_params,
 #xecution_options,
 #et,
 #
 #eturn ret

 #ef _execute_compiled(
 #elf,
 #ompiled,
 #ultiparams,
 #arams,
 #xecution_options=_EMPTY_EXECUTION_OPTS,
 #:
 #""Execute a sql.Compiled object.

 #ODO: why do we have this?   likely deprecate or remove

 #""

 #xecution_options = compiled.execution_options.merge_with(
 #elf._execution_options, execution_options
 #
 #istilled_parameters = _distill_params(self, multiparams, params)

 #f self._has_events or self.engine._has_events:
 #
 #istilled_params,
 #vent_multiparams,
 #vent_params,
 # = self._invoke_before_exec_event(
 #ompiled, distilled_parameters, execution_options
 #

 #ialect = self.dialect

 #et = self._execute_context(
 #ialect,
 #ialect.execution_ctx_cls._init_compiled,
 #ompiled,
 #istilled_parameters,
 #xecution_options,
 #ompiled,
 #istilled_parameters,
 #one,
 #one,
 #
 #f self._has_events or self.engine._has_events:
 #elf.dispatch.after_execute(
 #elf,
 #ompiled,
 #vent_multiparams,
 #vent_params,
 #xecution_options,
 #et,
 #
 #eturn ret

 #ef _exec_driver_sql(
 #elf, statement, multiparams, params, execution_options, future
 #:

 #xecution_options = self._execution_options.merge_with(
 #xecution_options
 #

 #istilled_parameters = _distill_params(self, multiparams, params)

 #f not future:
 #f self._has_events or self.engine._has_events:
 #
 #istilled_params,
 #vent_multiparams,
 #vent_params,
 # = self._invoke_before_exec_event(
 #tatement, distilled_parameters, execution_options
 #

 #ialect = self.dialect
 #et = self._execute_context(
 #ialect,
 #ialect.execution_ctx_cls._init_statement,
 #tatement,
 #istilled_parameters,
 #xecution_options,
 #tatement,
 #istilled_parameters,
 #

 #f not future:
 #f self._has_events or self.engine._has_events:
 #elf.dispatch.after_execute(
 #elf,
 #tatement,
 #vent_multiparams,
 #vent_params,
 #xecution_options,
 #et,
 #
 #eturn ret

 #ef _execute_20(
 #elf,
 #tatement,
 #arameters=None,
 #xecution_options=_EMPTY_EXECUTION_OPTS,
 #:
 #rgs_10style, kwargs_10style = _distill_params_20(parameters)
 #ry:
 #eth = statement._execute_on_connection
 #xcept AttributeError as err:
 #til.raise_(
 #xc.ObjectNotExecutableError(statement), replace_context=err
 #
 #lse:
 #eturn meth(self, args_10style, kwargs_10style, execution_options)

 #ef exec_driver_sql(
 #elf, statement, parameters=None, execution_options=None
 #:
 #"""Executes a SQL statement construct and returns a
 #class:`_engine.CursorResult`.

 #param statement: The statement str to be executed.   Bound parameters
 #ust use the underlying DBAPI's paramstyle, such as "qmark",
 #pyformat", "format", etc.

 #param parameters: represent bound parameter values to be used in the
 #xecution.  The format is one of:   a dictionary of named parameters,
 # tuple of positional parameters, or a list containing either
 #ictionaries or tuples for multiple-execute support.

 #.g. multiple dictionaries::


 #onn.exec_driver_sql(
 #INSERT INTO table (id, value) VALUES (%(id)s, %(value)s)",
 #{"id":1, "value":"v1"}, {"id":2, "value":"v2"}]
 #

 #ingle dictionary::

 #onn.exec_driver_sql(
 #INSERT INTO table (id, value) VALUES (%(id)s, %(value)s)",
 #ict(id=1, value="v1")
 #

 #ingle tuple::

 #onn.exec_driver_sql(
 #INSERT INTO table (id, value) VALUES (?, ?)",
 #1, 'v1')
 #

 #. note:: The :meth:`_engine.Connection.exec_driver_sql` method does
 #ot participate in the
 #meth:`_events.ConnectionEvents.before_execute` and
 #meth:`_events.ConnectionEvents.after_execute` events.   To
 #ntercept calls to :meth:`_engine.Connection.exec_driver_sql`, use
 #meth:`_events.ConnectionEvents.before_cursor_execute` and
 #meth:`_events.ConnectionEvents.after_cursor_execute`.

 #. seealso::

 #pep:`249`

 #""

 #rgs_10style, kwargs_10style = _distill_params_20(parameters)

 #eturn self._exec_driver_sql(
 #tatement,
 #rgs_10style,
 #wargs_10style,
 #xecution_options,
 #uture=True,
 #

 #ef _execute_context(
 #elf,
 #ialect,
 #onstructor,
 #tatement,
 #arameters,
 #xecution_options,
 #args,
 #*kw
 #:
 #""Create an :class:`.ExecutionContext` and execute, returning
 # :class:`_engine.CursorResult`."""

 #ranched = self
 #f self.__branch_from:
            # if this is a "branched" connection, do everything in terms
            # of the "root" connection, *except* for .close(), which is
            # the only feature that branching provides
 #elf = self.__branch_from

 #ry:
 #onn = self._dbapi_connection
 #f conn is None:
 #onn = self._revalidate_connection()

 #ontext = constructor(
 #ialect, self, conn, execution_options, *args, **kw
 #
 #xcept (exc.PendingRollbackError, exc.ResourceClosedError):
 #aise
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(
 #, util.text_type(statement), parameters, None, None
 #

 #f (
 #elf._transaction
 #nd not self._transaction.is_active
 #r (
 #elf._nested_transaction
 #nd not self._nested_transaction.is_active
 #
 #:
 #elf._invalid_transaction()

 #lif self._trans_context_manager:
 #ransactionalContext._trans_ctx_check(self)

 #f self._is_future and self._transaction is None:
 #elf._autobegin()

 #ontext.pre_exec()

 #f dialect.use_setinputsizes:
 #ontext._set_input_sizes()

 #ursor, statement, parameters = (
 #ontext.cursor,
 #ontext.statement,
 #ontext.parameters,
 #

 #f not context.executemany:
 #arameters = parameters[0]

 #f self._has_events or self.engine._has_events:
 #or fn in self.dispatch.before_cursor_execute:
 #tatement, parameters = fn(
 #elf,
 #ursor,
 #tatement,
 #arameters,
 #ontext,
 #ontext.executemany,
 #

 #f self._echo:

 #elf._log_info(statement)

 #tats = context._get_cache_stats()

 #f not self.engine.hide_parameters:
 #elf._log_info(
 #[%s] %r",
 #tats,
 #ql_util._repr_params(
 #arameters, batches=10, ismulti=context.executemany
 #,
 #
 #lse:
 #elf._log_info(
 #[%s] [SQL parameters hidden due to hide_parameters=True]"
 # (stats,)
 #

 #vt_handled = False
 #ry:
 #f context.executemany:
 #f self.dialect._has_events:
 #or fn in self.dialect.dispatch.do_executemany:
 #f fn(cursor, statement, parameters, context):
 #vt_handled = True
 #reak
 #f not evt_handled:
 #elf.dialect.do_executemany(
 #ursor, statement, parameters, context
 #
 #lif not parameters and context.no_parameters:
 #f self.dialect._has_events:
 #or fn in self.dialect.dispatch.do_execute_no_params:
 #f fn(cursor, statement, context):
 #vt_handled = True
 #reak
 #f not evt_handled:
 #elf.dialect.do_execute_no_params(
 #ursor, statement, context
 #
 #lse:
 #f self.dialect._has_events:
 #or fn in self.dialect.dispatch.do_execute:
 #f fn(cursor, statement, parameters, context):
 #vt_handled = True
 #reak
 #f not evt_handled:
 #elf.dialect.do_execute(
 #ursor, statement, parameters, context
 #

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.after_cursor_execute(
 #elf,
 #ursor,
 #tatement,
 #arameters,
 #ontext,
 #ontext.executemany,
 #

 #ontext.post_exec()

 #esult = context._setup_result_proxy()

 #f not self._is_future:
 #hould_close_with_result = branched.should_close_with_result

 #f not result._soft_closed and should_close_with_result:
 #esult._autoclose_connection = True

 #f (
                    # usually we're in a transaction so avoid relatively
                    # expensive / legacy should_autocommit call
 #elf._transaction is None
 #nd context.should_autocommit
 #:
 #elf._commit_impl(autocommit=True)

                # for "connectionless" execution, we have to close this
                # Connection after the statement is complete.
                # legacy stuff.
 #f should_close_with_result and context._soft_closed:
 #ssert not self._is_future

                    # CursorResult already exhausted rows / has no rows.
                    # close us now
 #ranched.close()

 #xcept BaseException as e:
 #elf._handle_dbapi_exception(
 #, statement, parameters, cursor, context
 #

 #eturn result

 #ef _cursor_execute(self, cursor, statement, parameters, context=None):
 #""Execute a statement + params on the given cursor.

 #dds appropriate logging and exception handling.

 #his method is used by DefaultDialect for special-case
 #xecutions, such as for sequences and column defaults.
 #he path of statement execution in the majority of cases
 #erminates at _execute_context().

 #""
 #f self._has_events or self.engine._has_events:
 #or fn in self.dispatch.before_cursor_execute:
 #tatement, parameters = fn(
 #elf, cursor, statement, parameters, context, False
 #

 #f self._echo:
 #elf._log_info(statement)
 #elf._log_info("[raw sql] %r", parameters)
 #ry:
 #or fn in (
 #)
 #f not self.dialect._has_events
 #lse self.dialect.dispatch.do_execute
 #:
 #f fn(cursor, statement, parameters, context):
 #reak
 #lse:
 #elf.dialect.do_execute(cursor, statement, parameters, context)
 #xcept BaseException as e:
 #elf._handle_dbapi_exception(
 #, statement, parameters, cursor, context
 #

 #f self._has_events or self.engine._has_events:
 #elf.dispatch.after_cursor_execute(
 #elf, cursor, statement, parameters, context, False
 #

 #ef _safe_close_cursor(self, cursor):
 #""Close the given cursor, catching exceptions
 #nd turning into log warnings.

 #""
 #ry:
 #ursor.close()
 #xcept Exception:
            # log the error through the connection pool's logger.
 #elf.engine.pool.logger.error(
 #Error closing cursor", exc_info=True
 #

 #reentrant_error = False
 #is_disconnect = False

 #ef _handle_dbapi_exception(
 #elf, e, statement, parameters, cursor, context
 #:
 #xc_info = sys.exc_info()

 #s_exit_exception = util.is_exit_exception(e)

 #f not self._is_disconnect:
 #elf._is_disconnect = (
 #sinstance(e, self.dialect.dbapi.Error)
 #nd not self.closed
 #nd self.dialect.is_disconnect(
 #,
 #elf._dbapi_connection if not self.invalidated else None,
 #ursor,
 #
 # or (is_exit_exception and not self.closed)

 #nvalidate_pool_on_disconnect = not is_exit_exception

 #f self._reentrant_error:
 #til.raise_(
 #xc.DBAPIError.instance(
 #tatement,
 #arameters,
 #,
 #elf.dialect.dbapi.Error,
 #ide_parameters=self.engine.hide_parameters,
 #ialect=self.dialect,
 #smulti=context.executemany
 #f context is not None
 #lse None,
 #,
 #ith_traceback=exc_info[2],
 #rom_=e,
 #
 #elf._reentrant_error = True
 #ry:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
 #hould_wrap = isinstance(e, self.dialect.dbapi.Error) or (
 #tatement is not None
 #nd context is None
 #nd not is_exit_exception
 #

 #f should_wrap:
 #qlalchemy_exception = exc.DBAPIError.instance(
 #tatement,
 #arameters,
 #,
 #elf.dialect.dbapi.Error,
 #ide_parameters=self.engine.hide_parameters,
 #onnection_invalidated=self._is_disconnect,
 #ialect=self.dialect,
 #smulti=context.executemany
 #f context is not None
 #lse None,
 #
 #lse:
 #qlalchemy_exception = None

 #ewraise = None

 #f (
 #elf._has_events or self.engine._has_events
 # and not self._execution_options.get(
 #skip_user_error_events", False
 #:
 #tx = ExceptionContextImpl(
 #,
 #qlalchemy_exception,
 #elf.engine,
 #elf,
 #ursor,
 #tatement,
 #arameters,
 #ontext,
 #elf._is_disconnect,
 #nvalidate_pool_on_disconnect,
 #

 #or fn in self.dispatch.handle_error:
 #ry:
                        # handler returns an exception;
                        # call next handler in a chain
 #er_fn = fn(ctx)
 #f per_fn is not None:
 #tx.chained_exception = newraise = per_fn
 #xcept Exception as _raised:
                        # handler raises an exception - stop processing
 #ewraise = _raised
 #reak

 #f self._is_disconnect != ctx.is_disconnect:
 #elf._is_disconnect = ctx.is_disconnect
 #f sqlalchemy_exception:
 #qlalchemy_exception.connection_invalidated = (
 #tx.is_disconnect
 #

                # set up potentially user-defined value for
                # invalidate pool.
 #nvalidate_pool_on_disconnect = (
 #tx.invalidate_pool_on_disconnect
 #

 #f should_wrap and context:
 #ontext.handle_dbapi_exception(e)

 #f not self._is_disconnect:
 #f cursor:
 #elf._safe_close_cursor(cursor)
 #ith util.safe_reraise(warn_only=True):
 #elf._autorollback()

 #f newraise:
 #til.raise_(newraise, with_traceback=exc_info[2], from_=e)
 #lif should_wrap:
 #til.raise_(
 #qlalchemy_exception, with_traceback=exc_info[2], from_=e
 #
 #lse:
 #til.raise_(exc_info[1], with_traceback=exc_info[2])

 #inally:
 #el self._reentrant_error
 #f self._is_disconnect:
 #el self._is_disconnect
 #f not self.invalidated:
 #bapi_conn_wrapper = self._dbapi_connection
 #f invalidate_pool_on_disconnect:
 #elf.engine.pool._invalidate(dbapi_conn_wrapper, e)
 #elf.invalidate(e)
 #f self.should_close_with_result:
 #ssert not self._is_future
 #elf.close()

 #classmethod
 #ef _handle_dbapi_exception_noconnection(cls, e, dialect, engine):
 #xc_info = sys.exc_info()

 #s_disconnect = dialect.is_disconnect(e, None, None)

 #hould_wrap = isinstance(e, dialect.dbapi.Error)

 #f should_wrap:
 #qlalchemy_exception = exc.DBAPIError.instance(
 #one,
 #one,
 #,
 #ialect.dbapi.Error,
 #ide_parameters=engine.hide_parameters,
 #onnection_invalidated=is_disconnect,
 #
 #lse:
 #qlalchemy_exception = None

 #ewraise = None

 #f engine._has_events:
 #tx = ExceptionContextImpl(
 #,
 #qlalchemy_exception,
 #ngine,
 #one,
 #one,
 #one,
 #one,
 #one,
 #s_disconnect,
 #rue,
 #
 #or fn in engine.dispatch.handle_error:
 #ry:
                    # handler returns an exception;
                    # call next handler in a chain
 #er_fn = fn(ctx)
 #f per_fn is not None:
 #tx.chained_exception = newraise = per_fn
 #xcept Exception as _raised:
                    # handler raises an exception - stop processing
 #ewraise = _raised
 #reak

 #f sqlalchemy_exception and is_disconnect != ctx.is_disconnect:
 #qlalchemy_exception.connection_invalidated = (
 #s_disconnect
 # = ctx.is_disconnect

 #f newraise:
 #til.raise_(newraise, with_traceback=exc_info[2], from_=e)
 #lif should_wrap:
 #til.raise_(
 #qlalchemy_exception, with_traceback=exc_info[2], from_=e
 #
 #lse:
 #til.raise_(exc_info[1], with_traceback=exc_info[2])

 #ef _run_ddl_visitor(self, visitorcallable, element, **kwargs):
 #""run a DDL visitor.

 #his method is only here so that the MockConnection can change the
 #ptions given to the visitor so that "checkfirst" is skipped.

 #""
 #isitorcallable(self.dialect, self, **kwargs).traverse_single(element)

 #util.deprecated(
 #1.4",
 #The :meth:`_engine.Connection.transaction` "
 #method is deprecated and will be "
 #removed in a future release.  Use the :meth:`_engine.Engine.begin` "
 #context manager instead.",
 #
 #ef transaction(self, callable_, *args, **kwargs):
 #"""Execute the given function within a transaction boundary.

 #he function is passed this :class:`_engine.Connection`
 #s the first argument, followed by the given \*args and \**kwargs,
 #.g.::

 #ef do_something(conn, x, y):
 #onn.execute(text("some statement"), {'x':x, 'y':y})

 #onn.transaction(do_something, 5, 10)

 #he operations inside the function are all invoked within the
 #ontext of a single :class:`.Transaction`.
 #pon success, the transaction is committed.  If an
 #xception is raised, the transaction is rolled back
 #efore propagating the exception.

 #. note::

 #he :meth:`.transaction` method is superseded by
 #he usage of the Python ``with:`` statement, which can
 #e used with :meth:`_engine.Connection.begin`::

 #ith conn.begin():
 #onn.execute(text("some statement"), {'x':5, 'y':10})

 #s well as with :meth:`_engine.Engine.begin`::

 #ith engine.begin() as conn:
 #onn.execute(text("some statement"), {'x':5, 'y':10})

 #. seealso::

 #meth:`_engine.Engine.begin` - engine-level transactional
 #ontext

 #meth:`_engine.Engine.transaction` - engine-level version of
 #meth:`_engine.Connection.transaction`

 #""

 #wargs["_sa_skip_warning"] = True
 #rans = self.begin()
 #ry:
 #et = self.run_callable(callable_, *args, **kwargs)
 #rans.commit()
 #eturn ret
 #xcept:
 #ith util.safe_reraise():
 #rans.rollback()

 #util.deprecated(
 #1.4",
 #The :meth:`_engine.Connection.run_callable` "
 #method is deprecated and will "
 #be removed in a future release.  Invoke the callable function "
 #directly, passing the Connection.",
 #
 #ef run_callable(self, callable_, *args, **kwargs):
 #"""Given a callable object or function, execute it, passing
 # :class:`_engine.Connection` as the first argument.

 #he given \*args and \**kwargs are passed subsequent
 #o the :class:`_engine.Connection` argument.

 #his function, along with :meth:`_engine.Engine.run_callable`,
 #llows a function to be run with a :class:`_engine.Connection`
 #r :class:`_engine.Engine` object without the need to know
 #hich one is being dealt with.

 #""
 #eturn callable_(self, *args, **kwargs)


class ExceptionContextImpl(ExceptionContext):
 #""Implement the :class:`.ExceptionContext` interface."""

 #ef __init__(
 #elf,
 #xception,
 #qlalchemy_exception,
 #ngine,
 #onnection,
 #ursor,
 #tatement,
 #arameters,
 #ontext,
 #s_disconnect,
 #nvalidate_pool_on_disconnect,
 #:
 #elf.engine = engine
 #elf.connection = connection
 #elf.sqlalchemy_exception = sqlalchemy_exception
 #elf.original_exception = exception
 #elf.execution_context = context
 #elf.statement = statement
 #elf.parameters = parameters
 #elf.is_disconnect = is_disconnect
 #elf.invalidate_pool_on_disconnect = invalidate_pool_on_disconnect


class Transaction(TransactionalContext):
 #""Represent a database transaction in progress.

 #he :class:`.Transaction` object is procured by
 #alling the :meth:`_engine.Connection.begin` method of
 #class:`_engine.Connection`::

 #rom sqlalchemy import create_engine
 #ngine = create_engine("postgresql://scott:tiger@localhost/test")
 #onnection = engine.connect()
 #rans = connection.begin()
 #onnection.execute(text("insert into x (a, b) values (1, 2)"))
 #rans.commit()

 #he object provides :meth:`.rollback` and :meth:`.commit`
 #ethods in order to control transaction boundaries.  It
 #lso implements a context manager interface so that
 #he Python ``with`` statement can be used with the
 #meth:`_engine.Connection.begin` method::

 #ith connection.begin():
 #onnection.execute(text("insert into x (a, b) values (1, 2)"))

 #he Transaction object is **not** threadsafe.

 #. seealso::

 #meth:`_engine.Connection.begin`

 #meth:`_engine.Connection.begin_twophase`

 #meth:`_engine.Connection.begin_nested`

 #. index::
 #ingle: thread safety; Transaction
 #""

 #_slots__ = ()

 #is_root = False

 #ef __init__(self, connection):
 #aise NotImplementedError()

 #ef _do_deactivate(self):
 #""do whatever steps are necessary to set this transaction as
 #deactive", however leave this transaction object in place as far
 #s the connection's state.

 #or a "real" transaction this should roll back the transaction
 #nd ensure this transaction is no longer a reset agent.

 #his is used for nesting of marker transactions where the marker
 #an set the "real" transaction as rolled back, however it stays
 #n place.

 #or 2.0 we hope to remove this nesting feature.

 #""
 #aise NotImplementedError()

 #property
 #ef _deactivated_from_connection(self):
 #""True if this transaction is totally deactivated from the connection
 #nd therefore can no longer affect its state.

 #""
 #aise NotImplementedError()

 #ef _do_close(self):
 #aise NotImplementedError()

 #ef _do_rollback(self):
 #aise NotImplementedError()

 #ef _do_commit(self):
 #aise NotImplementedError()

 #property
 #ef is_valid(self):
 #eturn self.is_active and not self.connection.invalidated

 #ef close(self):
 #""Close this :class:`.Transaction`.

 #f this transaction is the base transaction in a begin/commit
 #esting, the transaction will rollback().  Otherwise, the
 #ethod returns.

 #his is used to cancel a Transaction without affecting the scope of
 #n enclosing transaction.

 #""
 #ry:
 #elf._do_close()
 #inally:
 #ssert not self.is_active

 #ef rollback(self):
 #""Roll back this :class:`.Transaction`.

 #he implementation of this may vary based on the type of transaction in
 #se:

 # For a simple database transaction (e.g. :class:`.RootTransaction`),
 #t corresponds to a ROLLBACK.

 # For a :class:`.NestedTransaction`, it corresponds to a
 #ROLLBACK TO SAVEPOINT" operation.

 # For a :class:`.TwoPhaseTransaction`, DBAPI-specific methods for two
 #hase transactions may be used.


 #""
 #ry:
 #elf._do_rollback()
 #inally:
 #ssert not self.is_active

 #ef commit(self):
 #""Commit this :class:`.Transaction`.

 #he implementation of this may vary based on the type of transaction in
 #se:

 # For a simple database transaction (e.g. :class:`.RootTransaction`),
 #t corresponds to a COMMIT.

 # For a :class:`.NestedTransaction`, it corresponds to a
 #RELEASE SAVEPOINT" operation.

 # For a :class:`.TwoPhaseTransaction`, DBAPI-specific methods for two
 #hase transactions may be used.

 #""
 #ry:
 #elf._do_commit()
 #inally:
 #ssert not self.is_active

 #ef _get_subject(self):
 #eturn self.connection

 #ef _transaction_is_active(self):
 #eturn self.is_active

 #ef _transaction_is_closed(self):
 #eturn not self._deactivated_from_connection


class MarkerTransaction(Transaction):
 #""A 'marker' transaction that is used for nested begin() calls.

 #. deprecated:: 1.4 future connection for 2.0 won't support this pattern.

 #""

 #_slots__ = ("connection", "_is_active", "_transaction")

 #ef __init__(self, connection):
 #ssert connection._transaction is not None
 #f not connection._transaction.is_active:
 #aise exc.InvalidRequestError(
 #the current transaction on this connection is inactive.  "
 #Please issue a rollback first."
 #

 #ssert not connection._is_future
 #til.warn_deprecated_20(
 #Calling .begin() when a transaction is already begun, creating "
 #a 'sub' transaction, is deprecated "
 #and will be removed in 2.0.  See the documentation section "
 #'Migrating from the nesting pattern' for background on how "
 #to migrate from this pattern."
 #

 #elf.connection = connection

 #f connection._trans_context_manager:
 #ransactionalContext._trans_ctx_check(connection)

 #f connection._nested_transaction is not None:
 #elf._transaction = connection._nested_transaction
 #lse:
 #elf._transaction = connection._transaction
 #elf._is_active = True

 #property
 #ef _deactivated_from_connection(self):
 #eturn not self.is_active

 #property
 #ef is_active(self):
 #eturn self._is_active and self._transaction.is_active

 #ef _deactivate(self):
 #elf._is_active = False

 #ef _do_close(self):
        # does not actually roll back the root
 #elf._deactivate()

 #ef _do_rollback(self):
        # does roll back the root
 #f self._is_active:
 #ry:
 #elf._transaction._do_deactivate()
 #inally:
 #elf._deactivate()

 #ef _do_commit(self):
 #elf._deactivate()


class RootTransaction(Transaction):
 #""Represent the "root" transaction on a :class:`_engine.Connection`.

 #his corresponds to the current "BEGIN/COMMIT/ROLLBACK" that's occurring
 #or the :class:`_engine.Connection`. The :class:`_engine.RootTransaction`
 #s created by calling upon the :meth:`_engine.Connection.begin` method, and
 #emains associated with the :class:`_engine.Connection` throughout its
 #ctive span. The current :class:`_engine.RootTransaction` in use is
 #ccessible via the :attr:`_engine.Connection.get_transaction` method of
 #class:`_engine.Connection`.

 #n :term:`2.0 style` use, the :class:`_future.Connection` also employs
 #autobegin" behavior that will create a new
 #class:`_engine.RootTransaction` whenever a connection in a
 #on-transactional state is used to emit commands on the DBAPI connection.
 #he scope of the :class:`_engine.RootTransaction` in 2.0 style
 #se can be controlled using the :meth:`_future.Connection.commit` and
 #meth:`_future.Connection.rollback` methods.


 #""

 #is_root = True

 #_slots__ = ("connection", "is_active")

 #ef __init__(self, connection):
 #ssert connection._transaction is None
 #f connection._trans_context_manager:
 #ransactionalContext._trans_ctx_check(connection)
 #elf.connection = connection
 #elf._connection_begin_impl()
 #onnection._transaction = self

 #elf.is_active = True

 #ef _deactivate_from_connection(self):
 #f self.is_active:
 #ssert self.connection._transaction is self
 #elf.is_active = False

 #lif self.connection._transaction is not self:
 #til.warn("transaction already deassociated from connection")

 #property
 #ef _deactivated_from_connection(self):
 #eturn self.connection._transaction is not self

 #ef _do_deactivate(self):
        # called from a MarkerTransaction to cancel this root transaction.
        # the transaction stays in place as connection._transaction, but
        # is no longer active and is no longer the reset agent for the
        # pooled connection.   the connection won't support a new begin()
        # until this transaction is explicitly closed, rolled back,
        # or committed.

 #ssert self.connection._transaction is self

 #f self.is_active:
 #elf._connection_rollback_impl()

        # handle case where a savepoint was created inside of a marker
        # transaction that refers to a root.  nested has to be cancelled
        # also.
 #f self.connection._nested_transaction:
 #elf.connection._nested_transaction._cancel()

 #elf._deactivate_from_connection()

 #ef _connection_begin_impl(self):
 #elf.connection._begin_impl(self)

 #ef _connection_rollback_impl(self):
 #elf.connection._rollback_impl()

 #ef _connection_commit_impl(self):
 #elf.connection._commit_impl()

 #ef _close_impl(self, try_deactivate=False):
 #ry:
 #f self.is_active:
 #elf._connection_rollback_impl()

 #f self.connection._nested_transaction:
 #elf.connection._nested_transaction._cancel()
 #inally:
 #f self.is_active or try_deactivate:
 #elf._deactivate_from_connection()
 #f self.connection._transaction is self:
 #elf.connection._transaction = None

 #ssert not self.is_active
 #ssert self.connection._transaction is not self

 #ef _do_close(self):
 #elf._close_impl()

 #ef _do_rollback(self):
 #elf._close_impl(try_deactivate=True)

 #ef _do_commit(self):
 #f self.is_active:
 #ssert self.connection._transaction is self

 #ry:
 #elf._connection_commit_impl()
 #inally:
                # whether or not commit succeeds, cancel any
                # nested transactions, make this transaction "inactive"
                # and remove it as a reset agent
 #f self.connection._nested_transaction:
 #elf.connection._nested_transaction._cancel()

 #elf._deactivate_from_connection()

            # ...however only remove as the connection's current transaction
            # if commit succeeded.  otherwise it stays on so that a rollback
            # needs to occur.
 #elf.connection._transaction = None
 #lse:
 #f self.connection._transaction is self:
 #elf.connection._invalid_transaction()
 #lse:
 #aise exc.InvalidRequestError("This transaction is inactive")

 #ssert not self.is_active
 #ssert self.connection._transaction is not self


class NestedTransaction(Transaction):
 #""Represent a 'nested', or SAVEPOINT transaction.

 #he :class:`.NestedTransaction` object is created by calling the
 #meth:`_engine.Connection.begin_nested` method of
 #class:`_engine.Connection`.

 #hen using :class:`.NestedTransaction`, the semantics of "begin" /
 #commit" / "rollback" are as follows:

 # the "begin" operation corresponds to the "BEGIN SAVEPOINT" command, where
 #he savepoint is given an explicit name that is part of the state
 #f this object.

 # The :meth:`.NestedTransaction.commit` method corresponds to a
 #RELEASE SAVEPOINT" operation, using the savepoint identifier associated
 #ith this :class:`.NestedTransaction`.

 # The :meth:`.NestedTransaction.rollback` method corresponds to a
 #ROLLBACK TO SAVEPOINT" operation, using the savepoint identifier
 #ssociated with this :class:`.NestedTransaction`.

 #he rationale for mimicking the semantics of an outer transaction in
 #erms of savepoints so that code may deal with a "savepoint" transaction
 #nd an "outer" transaction in an agnostic way.

 #. seealso::

 #ref:`session_begin_nested` - ORM version of the SAVEPOINT API.

 #""

 #_slots__ = ("connection", "is_active", "_savepoint", "_previous_nested")

 #ef __init__(self, connection):
 #ssert connection._transaction is not None
 #f connection._trans_context_manager:
 #ransactionalContext._trans_ctx_check(connection)
 #elf.connection = connection
 #elf._savepoint = self.connection._savepoint_impl()
 #elf.is_active = True
 #elf._previous_nested = connection._nested_transaction
 #onnection._nested_transaction = self

 #ef _deactivate_from_connection(self, warn=True):
 #f self.connection._nested_transaction is self:
 #elf.connection._nested_transaction = self._previous_nested
 #lif warn:
 #til.warn(
 #nested transaction already deassociated from connection"
 #

 #property
 #ef _deactivated_from_connection(self):
 #eturn self.connection._nested_transaction is not self

 #ef _cancel(self):
        # called by RootTransaction when the outer transaction is
        # committed, rolled back, or closed to cancel all savepoints
        # without any action being taken
 #elf.is_active = False
 #elf._deactivate_from_connection()
 #f self._previous_nested:
 #elf._previous_nested._cancel()

 #ef _close_impl(self, deactivate_from_connection, warn_already_deactive):
 #ry:
 #f self.is_active and self.connection._transaction.is_active:
 #elf.connection._rollback_to_savepoint_impl(self._savepoint)
 #inally:
 #elf.is_active = False

 #f deactivate_from_connection:
 #elf._deactivate_from_connection(warn=warn_already_deactive)

 #ssert not self.is_active
 #f deactivate_from_connection:
 #ssert self.connection._nested_transaction is not self

 #ef _do_deactivate(self):
 #elf._close_impl(False, False)

 #ef _do_close(self):
 #elf._close_impl(True, False)

 #ef _do_rollback(self):
 #elf._close_impl(True, True)

 #ef _do_commit(self):
 #f self.is_active:
 #ry:
 #elf.connection._release_savepoint_impl(self._savepoint)
 #inally:
                # nested trans becomes inactive on failed release
                # unconditionally.  this prevents it from trying to
                # emit SQL when it rolls back.
 #elf.is_active = False

            # but only de-associate from connection if it succeeded
 #elf._deactivate_from_connection()
 #lse:
 #f self.connection._nested_transaction is self:
 #elf.connection._invalid_transaction()
 #lse:
 #aise exc.InvalidRequestError(
 #This nested transaction is inactive"
 #


class TwoPhaseTransaction(RootTransaction):
 #""Represent a two-phase transaction.

 # new :class:`.TwoPhaseTransaction` object may be procured
 #sing the :meth:`_engine.Connection.begin_twophase` method.

 #he interface is the same as that of :class:`.Transaction`
 #ith the addition of the :meth:`prepare` method.

 #""

 #_slots__ = ("connection", "is_active", "xid", "_is_prepared")

 #ef __init__(self, connection, xid):
 #elf._is_prepared = False
 #elf.xid = xid
 #uper(TwoPhaseTransaction, self).__init__(connection)

 #ef prepare(self):
 #""Prepare this :class:`.TwoPhaseTransaction`.

 #fter a PREPARE, the transaction can be committed.

 #""
 #f not self.is_active:
 #aise exc.InvalidRequestError("This transaction is inactive")
 #elf.connection._prepare_twophase_impl(self.xid)
 #elf._is_prepared = True

 #ef _connection_begin_impl(self):
 #elf.connection._begin_twophase_impl(self)

 #ef _connection_rollback_impl(self):
 #elf.connection._rollback_twophase_impl(self.xid, self._is_prepared)

 #ef _connection_commit_impl(self):
 #elf.connection._commit_twophase_impl(self.xid, self._is_prepared)


class Engine(Connectable, log.Identified):
 #""
 #onnects a :class:`~sqlalchemy.pool.Pool` and
 #class:`~sqlalchemy.engine.interfaces.Dialect` together to provide a
 #ource of database connectivity and behavior.

 #his is the **SQLAlchemy 1.x version** of :class:`_engine.Engine`.  For
 #he :term:`2.0 style` version, which includes  some API differences,
 #ee :class:`_future.Engine`.

 #n :class:`_engine.Engine` object is instantiated publicly using the
 #func:`~sqlalchemy.create_engine` function.

 #. seealso::

 #doc:`/core/engines`

 #ref:`connections_toplevel`

 #""

 #execution_options = _EMPTY_EXECUTION_OPTS
 #has_events = False
 #connection_cls = Connection
 #sqla_logger_namespace = "sqlalchemy.engine.Engine"
 #is_future = False

 #schema_translate_map = None

 #ef __init__(
 #elf,
 #ool,
 #ialect,
 #rl,
 #ogging_name=None,
 #cho=None,
 #uery_cache_size=500,
 #xecution_options=None,
 #ide_parameters=False,
 #:
 #elf.pool = pool
 #elf.url = url
 #elf.dialect = dialect
 #f logging_name:
 #elf.logging_name = logging_name
 #elf.echo = echo
 #elf.hide_parameters = hide_parameters
 #f query_cache_size != 0:
 #elf._compiled_cache = util.LRUCache(
 #uery_cache_size, size_alert=self._lru_size_alert
 #
 #lse:
 #elf._compiled_cache = None
 #og.instance_logger(self, echoflag=echo)
 #f execution_options:
 #elf.update_execution_options(**execution_options)

 #ef _lru_size_alert(self, cache):
 #f self._should_log_info:
 #elf.logger.info(
 #Compiled cache size pruning from %d items to %d.  "
 #Increase cache size to reduce the frequency of pruning.",
 #en(cache),
 #ache.capacity,
 #

 #property
 #ef engine(self):
 #eturn self

 #ef clear_compiled_cache(self):
 #""Clear the compiled cache associated with the dialect.

 #his applies **only** to the built-in cache that is established
 #ia the :paramref:`_engine.create_engine.query_cache_size` parameter.
 #t will not impact any dictionary caches that were passed via the
 #paramref:`.Connection.execution_options.query_cache` parameter.

 #. versionadded:: 1.4

 #""
 #f self._compiled_cache:
 #elf._compiled_cache.clear()

 #ef update_execution_options(self, **opt):
 #"""Update the default execution_options dictionary
 #f this :class:`_engine.Engine`.

 #he given keys/values in \**opt are added to the
 #efault execution options that will be used for
 #ll connections.  The initial contents of this dictionary
 #an be sent via the ``execution_options`` parameter
 #o :func:`_sa.create_engine`.

 #. seealso::

 #meth:`_engine.Connection.execution_options`

 #meth:`_engine.Engine.execution_options`

 #""
 #elf._execution_options = self._execution_options.union(opt)
 #elf.dispatch.set_engine_execution_options(self, opt)
 #elf.dialect.set_engine_execution_options(self, opt)

 #ef execution_options(self, **opt):
 #""Return a new :class:`_engine.Engine` that will provide
 #class:`_engine.Connection` objects with the given execution options.

 #he returned :class:`_engine.Engine` remains related to the original
 #class:`_engine.Engine` in that it shares the same connection pool and
 #ther state:

 # The :class:`_pool.Pool` used by the new :class:`_engine.Engine`
 #s the
 #ame instance.  The :meth:`_engine.Engine.dispose`
 #ethod will replace
 #he connection pool instance for the parent engine as well
 #s this one.
 # Event listeners are "cascaded" - meaning, the new
 #class:`_engine.Engine`
 #nherits the events of the parent, and new events can be associated
 #ith the new :class:`_engine.Engine` individually.
 # The logging configuration and logging_name is copied from the parent
 #class:`_engine.Engine`.

 #he intent of the :meth:`_engine.Engine.execution_options` method is
 #o implement "sharding" schemes where multiple :class:`_engine.Engine`
 #bjects refer to the same connection pool, but are differentiated
 #y options that would be consumed by a custom event::

 #rimary_engine = create_engine("mysql://")
 #hard1 = primary_engine.execution_options(shard_id="shard1")
 #hard2 = primary_engine.execution_options(shard_id="shard2")

 #bove, the ``shard1`` engine serves as a factory for
 #class:`_engine.Connection`
 #bjects that will contain the execution option
 #`shard_id=shard1``, and ``shard2`` will produce
 #class:`_engine.Connection`
 #bjects that contain the execution option ``shard_id=shard2``.

 #n event handler can consume the above execution option to perform
 # schema switch or other operation, given a connection.  Below
 #e emit a MySQL ``use`` statement to switch databases, at the same
 #ime keeping track of which database we've established using the
 #attr:`_engine.Connection.info` dictionary,
 #hich gives us a persistent
 #torage space that follows the DBAPI connection::

 #rom sqlalchemy import event
 #rom sqlalchemy.engine import Engine

 #hards = {"default": "base", shard_1: "db1", "shard_2": "db2"}

 #event.listens_for(Engine, "before_cursor_execute")
 #ef _switch_shard(conn, cursor, stmt,
 #arams, context, executemany):
 #hard_id = conn._execution_options.get('shard_id', "default")
 #urrent_shard = conn.info.get("current_shard", None)

 #f current_shard != shard_id:
 #ursor.execute("use %s" % shards[shard_id])
 #onn.info["current_shard"] = shard_id

 #. seealso::

 #meth:`_engine.Connection.execution_options`
 # update execution options
 #n a :class:`_engine.Connection` object.

 #meth:`_engine.Engine.update_execution_options`
 # update the execution
 #ptions for a given :class:`_engine.Engine` in place.

 #meth:`_engine.Engine.get_execution_options`


 #""
 #eturn self._option_cls(self, opt)

 #ef get_execution_options(self):
 #""Get the non-SQL options which will take effect during execution.

 #. versionadded: 1.3

 #. seealso::

 #meth:`_engine.Engine.execution_options`
 #""
 #eturn self._execution_options

 #property
 #ef name(self):
 #""String name of the :class:`~sqlalchemy.engine.interfaces.Dialect`
 #n use by this :class:`Engine`."""

 #eturn self.dialect.name

 #property
 #ef driver(self):
 #""Driver name of the :class:`~sqlalchemy.engine.interfaces.Dialect`
 #n use by this :class:`Engine`."""

 #eturn self.dialect.driver

 #cho = log.echo_property()

 #ef __repr__(self):
 #eturn "Engine(%r)" % (self.url,)

 #ef dispose(self):
 #""Dispose of the connection pool used by this
 #class:`_engine.Engine`.

 #his has the effect of fully closing all **currently checked in**
 #atabase connections.  Connections that are still checked out
 #ill **not** be closed, however they will no longer be associated
 #ith this :class:`_engine.Engine`,
 #o when they are closed individually,
 #ventually the :class:`_pool.Pool` which they are associated with will
 #e garbage collected and they will be closed out fully, if
 #ot already closed on checkin.

 # new connection pool is created immediately after the old one has
 #een disposed.   This new pool, like all SQLAlchemy connection pools,
 #oes not make any actual connections to the database until one is
 #irst requested, so as long as the :class:`_engine.Engine`
 #sn't used again,
 #o new connections will be made.

 #. seealso::

 #ref:`engine_disposal`

 #""
 #elf.pool.dispose()
 #elf.pool = self.pool.recreate()
 #elf.dispatch.engine_disposed(self)

 #ef _execute_default(
 #elf, default, multiparams=(), params=util.EMPTY_DICT
 #:
 #ith self.connect() as conn:
 #eturn conn._execute_default(default, multiparams, params)

 #contextlib.contextmanager
 #ef _optional_conn_ctx_manager(self, connection=None):
 #f connection is None:
 #ith self.connect() as conn:
 #ield conn
 #lse:
 #ield connection

 #lass _trans_ctx(object):
 #ef __init__(self, conn, transaction, close_with_result):
 #elf.conn = conn
 #elf.transaction = transaction
 #elf.close_with_result = close_with_result

 #ef __enter__(self):
 #elf.transaction.__enter__()
 #eturn self.conn

 #ef __exit__(self, type_, value, traceback):
 #ry:
 #elf.transaction.__exit__(type_, value, traceback)
 #inally:
 #f not self.close_with_result:
 #elf.conn.close()

 #ef begin(self, close_with_result=False):
 #""Return a context manager delivering a :class:`_engine.Connection`
 #ith a :class:`.Transaction` established.

 #.g.::

 #ith engine.begin() as conn:
 #onn.execute(
 #ext("insert into table (x, y, z) values (1, 2, 3)")
 #
 #onn.execute(text("my_special_procedure(5)"))

 #pon successful operation, the :class:`.Transaction`
 #s committed.  If an error is raised, the :class:`.Transaction`
 #s rolled back.

 #egacy use only: the ``close_with_result`` flag is normally ``False``,
 #nd indicates that the :class:`_engine.Connection` will be closed when
 #he operation is complete. When set to ``True``, it indicates the
 #class:`_engine.Connection` is in "single use" mode, where the
 #class:`_engine.CursorResult` returned by the first call to
 #meth:`_engine.Connection.execute` will close the
 #class:`_engine.Connection` when that :class:`_engine.CursorResult` has
 #xhausted all result rows.

 #. seealso::

 #meth:`_engine.Engine.connect` - procure a
 #class:`_engine.Connection` from
 #n :class:`_engine.Engine`.

 #meth:`_engine.Connection.begin` - start a :class:`.Transaction`
 #or a particular :class:`_engine.Connection`.

 #""
 #f self._connection_cls._is_future:
 #onn = self.connect()
 #lse:
 #onn = self.connect(close_with_result=close_with_result)
 #ry:
 #rans = conn.begin()
 #xcept:
 #ith util.safe_reraise():
 #onn.close()
 #eturn Engine._trans_ctx(conn, trans, close_with_result)

 #util.deprecated(
 #1.4",
 #The :meth:`_engine.Engine.transaction` "
 #method is deprecated and will be "
 #removed in a future release.  Use the :meth:`_engine.Engine.begin` "
 #context "
 #manager instead.",
 #
 #ef transaction(self, callable_, *args, **kwargs):
 #"""Execute the given function within a transaction boundary.

 #he function is passed a :class:`_engine.Connection` newly procured
 #rom :meth:`_engine.Engine.connect` as the first argument,
 #ollowed by the given \*args and \**kwargs.

 #.g.::

 #ef do_something(conn, x, y):
 #onn.execute(text("some statement"), {'x':x, 'y':y})

 #ngine.transaction(do_something, 5, 10)

 #he operations inside the function are all invoked within the
 #ontext of a single :class:`.Transaction`.
 #pon success, the transaction is committed.  If an
 #xception is raised, the transaction is rolled back
 #efore propagating the exception.

 #. note::

 #he :meth:`.transaction` method is superseded by
 #he usage of the Python ``with:`` statement, which can
 #e used with :meth:`_engine.Engine.begin`::

 #ith engine.begin() as conn:
 #onn.execute(text("some statement"), {'x':5, 'y':10})

 #. seealso::

 #meth:`_engine.Engine.begin` - engine-level transactional
 #ontext

 #meth:`_engine.Connection.transaction`
 # connection-level version of
 #meth:`_engine.Engine.transaction`

 #""
 #wargs["_sa_skip_warning"] = True
 #ith self.connect() as conn:
 #eturn conn.transaction(callable_, *args, **kwargs)

 #util.deprecated(
 #1.4",
 #The :meth:`_engine.Engine.run_callable` "
 #method is deprecated and will be "
 #removed in a future release.  Use the :meth:`_engine.Engine.begin` "
 #context manager instead.",
 #
 #ef run_callable(self, callable_, *args, **kwargs):
 #"""Given a callable object or function, execute it, passing
 # :class:`_engine.Connection` as the first argument.

 #he given \*args and \**kwargs are passed subsequent
 #o the :class:`_engine.Connection` argument.

 #his function, along with :meth:`_engine.Connection.run_callable`,
 #llows a function to be run with a :class:`_engine.Connection`
 #r :class:`_engine.Engine` object without the need to know
 #hich one is being dealt with.

 #""
 #wargs["_sa_skip_warning"] = True
 #ith self.connect() as conn:
 #eturn conn.run_callable(callable_, *args, **kwargs)

 #ef _run_ddl_visitor(self, visitorcallable, element, **kwargs):
 #ith self.begin() as conn:
 #onn._run_ddl_visitor(visitorcallable, element, **kwargs)

 #util.deprecated_20(
 #:meth:`_engine.Engine.execute`",
 #lternative="All statement execution in SQLAlchemy 2.0 is performed "
 #by the :meth:`_engine.Connection.execute` method of "
 #:class:`_engine.Connection`, "
 #or in the ORM by the :meth:`.Session.execute` method of "
 #:class:`.Session`.",
 #
 #ef execute(self, statement, *multiparams, **params):
 #""Executes the given construct and returns a
 #class:`_engine.CursorResult`.

 #he arguments are the same as those used by
 #meth:`_engine.Connection.execute`.

 #ere, a :class:`_engine.Connection` is acquired using the
 #meth:`_engine.Engine.connect` method, and the statement executed
 #ith that connection. The returned :class:`_engine.CursorResult`
 #s flagged
 #uch that when the :class:`_engine.CursorResult` is exhausted and its
 #nderlying cursor is closed, the :class:`_engine.Connection`
 #reated here
 #ill also be closed, which allows its associated DBAPI connection
 #esource to be returned to the connection pool.

 #""
 #onnection = self.connect(close_with_result=True)
 #eturn connection.execute(statement, *multiparams, **params)

 #util.deprecated_20(
 #:meth:`_engine.Engine.scalar`",
 #lternative="All statement execution in SQLAlchemy 2.0 is performed "
 #by the :meth:`_engine.Connection.execute` method of "
 #:class:`_engine.Connection`, "
 #or in the ORM by the :meth:`.Session.execute` method of "
 #:class:`.Session`; the :meth:`_future.Result.scalar` "
 #method can then be "
 #used to return a scalar result.",
 #
 #ef scalar(self, statement, *multiparams, **params):
 #""Executes and returns the first column of the first row.

 #he underlying result/cursor is closed after execution.
 #""
 #eturn self.execute(statement, *multiparams, **params).scalar()

 #ef _execute_clauseelement(
 #elf,
 #lem,
 #ultiparams=None,
 #arams=None,
 #xecution_options=_EMPTY_EXECUTION_OPTS,
 #:
 #onnection = self.connect(close_with_result=True)
 #eturn connection._execute_clauseelement(
 #lem, multiparams, params, execution_options
 #

 #ef _execute_compiled(
 #elf,
 #ompiled,
 #ultiparams,
 #arams,
 #xecution_options=_EMPTY_EXECUTION_OPTS,
 #:
 #onnection = self.connect(close_with_result=True)
 #eturn connection._execute_compiled(
 #ompiled, multiparams, params, execution_options
 #

 #ef connect(self, close_with_result=False):
 #""Return a new :class:`_engine.Connection` object.

 #he :class:`_engine.Connection` object is a facade that uses a DBAPI
 #onnection internally in order to communicate with the database.  This
 #onnection is procured from the connection-holding :class:`_pool.Pool`
 #eferenced by this :class:`_engine.Engine`. When the
 #meth:`_engine.Connection.close` method of the
 #class:`_engine.Connection` object
 #s called, the underlying DBAPI connection is then returned to the
 #onnection pool, where it may be used again in a subsequent call to
 #meth:`_engine.Engine.connect`.

 #""

 #eturn self._connection_cls(self, close_with_result=close_with_result)

 #util.deprecated(
 #1.4",
 #The :meth:`_engine.Engine.table_names` "
 #method is deprecated and will be "
 #removed in a future release.  Please refer to "
 #:meth:`_reflection.Inspector.get_table_names`.",
 #
 #ef table_names(self, schema=None, connection=None):
 #""Return a list of all table names available in the database.

 #param schema: Optional, retrieve names from a non-default schema.

 #param connection: Optional, use a specified connection.
 #""
 #ith self._optional_conn_ctx_manager(connection) as conn:
 #nsp = inspection.inspect(conn)
 #eturn insp.get_table_names(schema)

 #util.deprecated(
 #1.4",
 #The :meth:`_engine.Engine.has_table` "
 #method is deprecated and will be "
 #removed in a future release.  Please refer to "
 #:meth:`_reflection.Inspector.has_table`.",
 #
 #ef has_table(self, table_name, schema=None):
 #""Return True if the given backend has a table of the given name.

 #. seealso::

 #ref:`metadata_reflection_inspector` - detailed schema inspection
 #sing the :class:`_reflection.Inspector` interface.

 #class:`.quoted_name` - used to pass quoting information along
 #ith a schema identifier.

 #""
 #ith self._optional_conn_ctx_manager(None) as conn:
 #nsp = inspection.inspect(conn)
 #eturn insp.has_table(table_name, schema=schema)

 #ef _wrap_pool_connect(self, fn, connection):
 #ialect = self.dialect
 #ry:
 #eturn fn()
 #xcept dialect.dbapi.Error as e:
 #f connection is None:
 #onnection._handle_dbapi_exception_noconnection(
 #, dialect, self
 #
 #lse:
 #til.raise_(
 #ys.exc_info()[1], with_traceback=sys.exc_info()[2]
 #

 #ef raw_connection(self, _connection=None):
 #""Return a "raw" DBAPI connection from the connection pool.

 #he returned object is a proxied version of the DBAPI
 #onnection object used by the underlying driver in use.
 #he object will have all the same behavior as the real DBAPI
 #onnection, except that its ``close()`` method will result in the
 #onnection being returned to the pool, rather than being closed
 #or real.

 #his method provides direct DBAPI connection access for
 #pecial situations when the API provided by
 #class:`_engine.Connection`
 #s not needed.   When a :class:`_engine.Connection` object is already
 #resent, the DBAPI connection is available using
 #he :attr:`_engine.Connection.connection` accessor.

 #. seealso::

 #ref:`dbapi_connections`

 #""
 #eturn self._wrap_pool_connect(self.pool.connect, _connection)


class OptionEngineMixin(object):
 #sa_propagate_class_events = False

 #ef __init__(self, proxied, execution_options):
 #elf._proxied = proxied
 #elf.url = proxied.url
 #elf.dialect = proxied.dialect
 #elf.logging_name = proxied.logging_name
 #elf.echo = proxied.echo
 #elf._compiled_cache = proxied._compiled_cache
 #elf.hide_parameters = proxied.hide_parameters
 #og.instance_logger(self, echoflag=self.echo)

        # note: this will propagate events that are assigned to the parent
        # engine after this OptionEngine is created.   Since we share
        # the events of the parent we also disallow class-level events
        # to apply to the OptionEngine class directly.
        #
        # the other way this can work would be to transfer existing
        # events only, using:
        # self.dispatch._update(proxied.dispatch)
        #
        # that might be more appropriate however it would be a behavioral
        # change for logic that assigns events to the parent engine and
        # would like it to take effect for the already-created sub-engine.
 #elf.dispatch = self.dispatch._join(proxied.dispatch)

 #elf._execution_options = proxied._execution_options
 #elf.update_execution_options(**execution_options)

 #ef _get_pool(self):
 #eturn self._proxied.pool

 #ef _set_pool(self, pool):
 #elf._proxied.pool = pool

 #ool = property(_get_pool, _set_pool)

 #ef _get_has_events(self):
 #eturn self._proxied._has_events or self.__dict__.get(
 #_has_events", False
 #

 #ef _set_has_events(self, value):
 #elf.__dict__["_has_events"] = value

 #has_events = property(_get_has_events, _set_has_events)


class OptionEngine(OptionEngineMixin, Engine):
 #ass


Engine._option_cls = OptionEngine
