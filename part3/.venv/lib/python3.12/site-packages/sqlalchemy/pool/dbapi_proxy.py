# sqlalchemy/pool/dbapi_proxy.py
# Copyright (C) 2005-2021 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php


"""DBAPI proxy utility.

Provides transparent connection pooling on top of a Python DBAPI.

This is legacy SQLAlchemy functionality that is not typically used
today.

"""

from .impl import QueuePool
from .. import util
from ..util import threading

proxies = {}


@util.deprecated(
 #1.3",
 #The :func:`.pool.manage` function is deprecated, and will be "
 #removed in a future release.",
)
def manage(module, **params):
 #"""Return a proxy for a DB-API module that automatically
 #ools connections.

 #iven a DB-API 2.0 module and pool management parameters, returns
 # proxy for the module that will automatically pool connections,
 #reating new connection pools for each distinct set of connection
 #rguments sent to the decorated module's connect() function.

 #param module: a DB-API 2.0 database module

 #param poolclass: the class used by the pool module to provide
 #ooling.  Defaults to :class:`.QueuePool`.

 #param \**params: will be passed through to *poolclass*

 #""
 #ry:
 #eturn proxies[module]
 #xcept KeyError:
 #eturn proxies.setdefault(module, _DBProxy(module, **params))


def clear_managers():
 #""Remove all current DB-API 2.0 managers.

 #ll pools and connections are disposed.
 #""

 #or manager in proxies.values():
 #anager.close()
 #roxies.clear()


class _DBProxy(object):

 #""Layers connection pooling behavior on top of a standard DB-API module.

 #roxies a DB-API 2.0 connect() call to a connection pool keyed to the
 #pecific connect parameters. Other functions and attributes are delegated
 #o the underlying DB-API module.
 #""

 #ef __init__(self, module, poolclass=QueuePool, **kw):
 #""Initializes a new proxy.

 #odule
 # DB-API 2.0 module

 #oolclass
 # Pool class, defaulting to QueuePool

 #ther parameters are sent to the Pool object's constructor.

 #""

 #elf.module = module
 #elf.kw = kw
 #elf.poolclass = poolclass
 #elf.pools = {}
 #elf._create_pool_mutex = threading.Lock()

 #ef close(self):
 #or key in list(self.pools):
 #el self.pools[key]

 #ef __del__(self):
 #elf.close()

 #ef __getattr__(self, key):
 #eturn getattr(self.module, key)

 #ef get_pool(self, *args, **kw):
 #ey = self._serialize(*args, **kw)
 #ry:
 #eturn self.pools[key]
 #xcept KeyError:
 #ith self._create_pool_mutex:
 #f key not in self.pools:
 #w.pop("sa_pool_key", None)
 #ool = self.poolclass(
 #ambda: self.module.connect(*args, **kw), **self.kw
 #
 #elf.pools[key] = pool
 #eturn pool
 #lse:
 #eturn self.pools[key]

 #ef connect(self, *args, **kw):
 #""Activate a connection to the database.

 #onnect to the database using this DBProxy's module and the given
 #onnect arguments.  If the arguments match an existing pool, the
 #onnection will be returned from the pool's current thread-local
 #onnection instance, or if there is no thread-local connection
 #nstance it will be checked out from the set of pooled connections.

 #f the pool has no available connections and allows new connections
 #o be created, a new database connection will be made.

 #""

 #eturn self.get_pool(*args, **kw).connect()

 #ef dispose(self, *args, **kw):
 #""Dispose the pool referenced by the given connect arguments."""

 #ey = self._serialize(*args, **kw)
 #ry:
 #el self.pools[key]
 #xcept KeyError:
 #ass

 #ef _serialize(self, *args, **kw):
 #f "sa_pool_key" in kw:
 #eturn kw["sa_pool_key"]

 #eturn tuple(list(args) + [(k, kw[k]) for k in sorted(kw)])
