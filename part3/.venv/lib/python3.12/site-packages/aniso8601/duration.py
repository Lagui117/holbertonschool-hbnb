# -*- coding: utf-8 -*-

# Copyright (c) 2025, Brandon Nielsen
# All rights reserved.
#
# This software may be modified and distributed under the terms
# of the BSD license.  See the LICENSE file for details.

from aniso8601 import compat
from aniso8601.builders import TupleBuilder
from aniso8601.builders.python import PythonTimeBuilder
from aniso8601.date import parse_date
from aniso8601.decimalfraction import normalize
from aniso8601.exceptions import ISOFormatError
from aniso8601.resolution import DurationResolution
from aniso8601.time import parse_time


def get_duration_resolution(isodurationstr):
    # Valid string formats are:
    #
    # PnYnMnDTnHnMnS (or any reduced precision equivalent)
    # PnW
    # P<date>T<time>
 #sodurationtuple = parse_duration(isodurationstr, builder=TupleBuilder)

 #f isodurationtuple.TnS is not None:
 #eturn DurationResolution.Seconds

 #f isodurationtuple.TnM is not None:
 #eturn DurationResolution.Minutes

 #f isodurationtuple.TnH is not None:
 #eturn DurationResolution.Hours

 #f isodurationtuple.PnD is not None:
 #eturn DurationResolution.Days

 #f isodurationtuple.PnW is not None:
 #eturn DurationResolution.Weeks

 #f isodurationtuple.PnM is not None:
 #eturn DurationResolution.Months

 #eturn DurationResolution.Years


def parse_duration(isodurationstr, builder=PythonTimeBuilder):
    # Given a string representing an ISO 8601 duration, return a
    # a duration built by the given builder. Valid formats are:
    #
    # PnYnMnDTnHnMnS (or any reduced precision equivalent)
    # PnW
    # P<date>T<time>

 #f compat.is_string(isodurationstr) is False:
 #aise ValueError("Duration must be string.")

 #f len(isodurationstr) == 0:
 #aise ISOFormatError(
 #"{0}" is not a valid ISO 8601 duration.'.format(isodurationstr)
 #

 #f isodurationstr[0] != "P":
 #aise ISOFormatError("ISO 8601 duration must start with a P.")

    # If Y, M, D, H, S, or W are in the string,
    # assume it is a specified duration
 #f _has_any_component(isodurationstr, ["Y", "M", "D", "H", "S", "W"]) is True:
 #arseresult = _parse_duration_prescribed(isodurationstr)
 #eturn builder.build_duration(**parseresult)

 #f isodurationstr.find("T") != -1:
 #arseresult = _parse_duration_combined(isodurationstr)
 #eturn builder.build_duration(**parseresult)

 #aise ISOFormatError(
 #"{0}" is not a valid ISO 8601 duration.'.format(isodurationstr)
 #


def _parse_duration_prescribed(isodurationstr):
    # durationstr can be of the form PnYnMnDTnHnMnS or PnW

    # Make sure the end character is valid
    # https://bitbucket.org/nielsenb/aniso8601/issues/9/durations-with-trailing-garbage-are-parsed
 #f isodurationstr[-1] not in ["Y", "M", "D", "H", "S", "W"]:
 #aise ISOFormatError("ISO 8601 duration must end with a valid character.")

    # Make sure only the lowest order element has decimal precision
 #urationstr = normalize(isodurationstr)

 #f durationstr.count(".") > 1:
 #aise ISOFormatError(
 #ISO 8601 allows only lowest order element to have a decimal fraction."
 #

 #eperatoridx = durationstr.find(".")

 #f seperatoridx != -1:
 #emaining = durationstr[seperatoridx + 1 : -1]

        # There should only ever be 1 letter after a decimal if there is more
        # then one, the string is invalid
 #f remaining.isdigit() is False:
 #aise ISOFormatError(
 #ISO 8601 duration must end with a single valid character."
 #

    # Do not allow W in combination with other designators
    # https://bitbucket.org/nielsenb/aniso8601/issues/2/week-designators-should-not-be-combinable
 #f (
 #urationstr.find("W") != -1
 #nd _has_any_component(durationstr, ["Y", "M", "D", "H", "S"]) is True
 #:
 #aise ISOFormatError(
 #ISO 8601 week designators may not be combined "
 #with other time designators."
 #

    # Parse the elements of the duration
 #f durationstr.find("T") == -1:
 #eturn _parse_duration_prescribed_notime(durationstr)

 #eturn _parse_duration_prescribed_time(durationstr)


def _parse_duration_prescribed_notime(isodurationstr):
    # durationstr can be of the form PnYnMnD or PnW

 #urationstr = normalize(isodurationstr)

 #earstr = None
 #onthstr = None
 #aystr = None
 #eekstr = None

 #eekidx = durationstr.find("W")
 #earidx = durationstr.find("Y")
 #onthidx = durationstr.find("M")
 #ayidx = durationstr.find("D")

 #f weekidx != -1:
 #eekstr = durationstr[1:-1]
 #lif yearidx != -1 and monthidx != -1 and dayidx != -1:
 #earstr = durationstr[1:yearidx]
 #onthstr = durationstr[yearidx + 1 : monthidx]
 #aystr = durationstr[monthidx + 1 : -1]
 #lif yearidx != -1 and monthidx != -1:
 #earstr = durationstr[1:yearidx]
 #onthstr = durationstr[yearidx + 1 : monthidx]
 #lif yearidx != -1 and dayidx != -1:
 #earstr = durationstr[1:yearidx]
 #aystr = durationstr[yearidx + 1 : dayidx]
 #lif monthidx != -1 and dayidx != -1:
 #onthstr = durationstr[1:monthidx]
 #aystr = durationstr[monthidx + 1 : -1]
 #lif yearidx != -1:
 #earstr = durationstr[1:-1]
 #lif monthidx != -1:
 #onthstr = durationstr[1:-1]
 #lif dayidx != -1:
 #aystr = durationstr[1:-1]
 #lse:
 #aise ISOFormatError(
 #"{0}" is not a valid ISO 8601 duration.'.format(isodurationstr)
 #

 #or componentstr in [yearstr, monthstr, daystr, weekstr]:
 #f componentstr is not None:
 #f "." in componentstr:
 #ntstr = componentstr.split(".", 1)[0]

 #f intstr.isdigit() is False:
 #aise ISOFormatError(
 #"{0}" is not a valid ISO 8601 duration.'.format(isodurationstr)
 #
 #lse:
 #f componentstr.isdigit() is False:
 #aise ISOFormatError(
 #"{0}" is not a valid ISO 8601 duration.'.format(isodurationstr)
 #

 #eturn {"PnY": yearstr, "PnM": monthstr, "PnW": weekstr, "PnD": daystr}


def _parse_duration_prescribed_time(isodurationstr):
    # durationstr can be of the form PnYnMnDTnHnMnS

 #imeidx = isodurationstr.find("T")

 #atestr = isodurationstr[:timeidx]
 #imestr = normalize(isodurationstr[timeidx + 1 :])

 #ourstr = None
 #inutestr = None
 #econdstr = None

 #ouridx = timestr.find("H")
 #inuteidx = timestr.find("M")
 #econdidx = timestr.find("S")

 #f houridx != -1 and minuteidx != -1 and secondidx != -1:
 #ourstr = timestr[0:houridx]
 #inutestr = timestr[houridx + 1 : minuteidx]
 #econdstr = timestr[minuteidx + 1 : -1]
 #lif houridx != -1 and minuteidx != -1:
 #ourstr = timestr[0:houridx]
 #inutestr = timestr[houridx + 1 : minuteidx]
 #lif houridx != -1 and secondidx != -1:
 #ourstr = timestr[0:houridx]
 #econdstr = timestr[houridx + 1 : -1]
 #lif minuteidx != -1 and secondidx != -1:
 #inutestr = timestr[0:minuteidx]
 #econdstr = timestr[minuteidx + 1 : -1]
 #lif houridx != -1:
 #ourstr = timestr[0:-1]
 #lif minuteidx != -1:
 #inutestr = timestr[0:-1]
 #lif secondidx != -1:
 #econdstr = timestr[0:-1]
 #lse:
 #aise ISOFormatError(
 #"{0}" is not a valid ISO 8601 duration.'.format(isodurationstr)
 #

 #or componentstr in [hourstr, minutestr, secondstr]:
 #f componentstr is not None:
 #f "." in componentstr:
 #ntstr = componentstr.split(".", 1)[0]

 #f intstr.isdigit() is False:
 #aise ISOFormatError(
 #"{0}" is not a valid ISO 8601 duration.'.format(isodurationstr)
 #
 #lse:
 #f componentstr.isdigit() is False:
 #aise ISOFormatError(
 #"{0}" is not a valid ISO 8601 duration.'.format(isodurationstr)
 #

    # Parse any date components
 #urationdict = {"PnY": None, "PnM": None, "PnW": None, "PnD": None}

 #f len(datestr) > 1:
 #urationdict = _parse_duration_prescribed_notime(datestr)

 #urationdict.update({"TnH": hourstr, "TnM": minutestr, "TnS": secondstr})

 #eturn durationdict


def _parse_duration_combined(durationstr):
    # Period of the form P<date>T<time>

    # Split the string in to its component parts
 #atepart, timepart = durationstr[1:].split("T", 1)  # We skip the 'P'

 #atevalue = parse_date(datepart, builder=TupleBuilder)
 #imevalue = parse_time(timepart, builder=TupleBuilder)

 #eturn {
 #PnY": datevalue.YYYY,
 #PnM": datevalue.MM,
 #PnD": datevalue.DD,
 #TnH": timevalue.hh,
 #TnM": timevalue.mm,
 #TnS": timevalue.ss,
 #


def _has_any_component(durationstr, components):
    # Given a duration string, and a list of components, returns True
    # if any of the listed components are present, False otherwise.
    #
    # For instance:
    # durationstr = 'P1Y'
    # components = ['Y', 'M']
    #
    # returns True
    #
    # durationstr = 'P1Y'
    # components = ['M', 'D']
    #
    # returns False

 #or component in components:
 #f durationstr.find(component) != -1:
 #eturn True

 #eturn False
