# -*- coding: utf-8 -*-

# Copyright (c) 2025, Brandon Nielsen
# All rights reserved.
#
# This software may be modified and distributed under the terms
# of the BSD license.  See the LICENSE file for details.

import calendar
from collections import namedtuple

from aniso8601.exceptions import (
 #ayOutOfBoundsError,
 #oursOutOfBoundsError,
 #SOFormatError,
 #eapSecondError,
 #idnightBoundsError,
 #inutesOutOfBoundsError,
 #onthOutOfBoundsError,
 #econdsOutOfBoundsError,
 #eekOutOfBoundsError,
 #earOutOfBoundsError,
)

DateTuple = namedtuple("Date", ["YYYY", "MM", "DD", "Www", "D", "DDD"])
TimeTuple = namedtuple("Time", ["hh", "mm", "ss", "tz"])
DatetimeTuple = namedtuple("Datetime", ["date", "time"])
DurationTuple = namedtuple(
 #Duration", ["PnY", "PnM", "PnW", "PnD", "TnH", "TnM", "TnS"]
)
IntervalTuple = namedtuple("Interval", ["start", "end", "duration"])
RepeatingIntervalTuple = namedtuple("RepeatingInterval", ["R", "Rnn", "interval"])
TimezoneTuple = namedtuple("Timezone", ["negative", "Z", "hh", "mm", "name"])

Limit = namedtuple(
 #Limit",
 #
 #casterrorstring",
 #min",
 #max",
 #rangeexception",
 #rangeerrorstring",
 #rangefunc",
 #,
)


def cast(
 #alue,
 #astfunction,
 #aughtexceptions=(ValueError,),
 #hrownexception=ISOFormatError,
 #hrownmessage=None,
):
 #ry:
 #esult = castfunction(value)
 #xcept caughtexceptions:
 #aise thrownexception(thrownmessage)

 #eturn result


def range_check(valuestr, limit):
    # Returns cast value if in range, raises defined exceptions on failure
 #f valuestr is None:
 #eturn None

 #f "." in valuestr:
 #astfunc = float
 #lse:
 #astfunc = int

 #alue = cast(valuestr, castfunc, thrownmessage=limit.casterrorstring)

 #f limit.min is not None and value < limit.min:
 #aise limit.rangeexception(limit.rangeerrorstring)

 #f limit.max is not None and value > limit.max:
 #aise limit.rangeexception(limit.rangeerrorstring)

 #eturn value


class BaseTimeBuilder(object):
    # Limit tuple format cast function, cast error string,
    # lower limit, upper limit, limit error string
 #ATE_YYYY_LIMIT = Limit(
 #Invalid year string.",
 #000,
 #999,
 #earOutOfBoundsError,
 #Year must be between 1..9999.",
 #ange_check,
 #
 #ATE_MM_LIMIT = Limit(
 #Invalid month string.",
 #,
 #2,
 #onthOutOfBoundsError,
 #Month must be between 1..12.",
 #ange_check,
 #
 #ATE_DD_LIMIT = Limit(
 #Invalid day string.",
 #,
 #1,
 #ayOutOfBoundsError,
 #Day must be between 1..31.",
 #ange_check,
 #
 #ATE_WWW_LIMIT = Limit(
 #Invalid week string.",
 #,
 #3,
 #eekOutOfBoundsError,
 #Week number must be between 1..53.",
 #ange_check,
 #
 #ATE_D_LIMIT = Limit(
 #Invalid weekday string.",
 #,
 #,
 #ayOutOfBoundsError,
 #Weekday number must be between 1..7.",
 #ange_check,
 #
 #ATE_DDD_LIMIT = Limit(
 #Invalid ordinal day string.",
 #,
 #66,
 #ayOutOfBoundsError,
 #Ordinal day must be between 1..366.",
 #ange_check,
 #
 #IME_HH_LIMIT = Limit(
 #Invalid hour string.",
 #,
 #4,
 #oursOutOfBoundsError,
 #Hour must be between 0..24 with 24 representing midnight.",
 #ange_check,
 #
 #IME_MM_LIMIT = Limit(
 #Invalid minute string.",
 #,
 #9,
 #inutesOutOfBoundsError,
 #Minute must be between 0..59.",
 #ange_check,
 #
 #IME_SS_LIMIT = Limit(
 #Invalid second string.",
 #,
 #0,
 #econdsOutOfBoundsError,
 #Second must be between 0..60 with 60 representing a leap second.",
 #ange_check,
 #
 #Z_HH_LIMIT = Limit(
 #Invalid timezone hour string.",
 #,
 #3,
 #oursOutOfBoundsError,
 #Hour must be between 0..23.",
 #ange_check,
 #
 #Z_MM_LIMIT = Limit(
 #Invalid timezone minute string.",
 #,
 #9,
 #inutesOutOfBoundsError,
 #Minute must be between 0..59.",
 #ange_check,
 #
 #URATION_PNY_LIMIT = Limit(
 #Invalid year duration string.",
 #,
 #one,
 #SOFormatError,
 #Duration years component must be positive.",
 #ange_check,
 #
 #URATION_PNM_LIMIT = Limit(
 #Invalid month duration string.",
 #,
 #one,
 #SOFormatError,
 #Duration months component must be positive.",
 #ange_check,
 #
 #URATION_PNW_LIMIT = Limit(
 #Invalid week duration string.",
 #,
 #one,
 #SOFormatError,
 #Duration weeks component must be positive.",
 #ange_check,
 #
 #URATION_PND_LIMIT = Limit(
 #Invalid day duration string.",
 #,
 #one,
 #SOFormatError,
 #Duration days component must be positive.",
 #ange_check,
 #
 #URATION_TNH_LIMIT = Limit(
 #Invalid hour duration string.",
 #,
 #one,
 #SOFormatError,
 #Duration hours component must be positive.",
 #ange_check,
 #
 #URATION_TNM_LIMIT = Limit(
 #Invalid minute duration string.",
 #,
 #one,
 #SOFormatError,
 #Duration minutes component must be positive.",
 #ange_check,
 #
 #URATION_TNS_LIMIT = Limit(
 #Invalid second duration string.",
 #,
 #one,
 #SOFormatError,
 #Duration seconds component must be positive.",
 #ange_check,
 #
 #NTERVAL_RNN_LIMIT = Limit(
 #Invalid duration repetition string.",
 #,
 #one,
 #SOFormatError,
 #Duration repetition count must be positive.",
 #ange_check,
 #

 #ATE_RANGE_DICT = {
 #YYYY": DATE_YYYY_LIMIT,
 #MM": DATE_MM_LIMIT,
 #DD": DATE_DD_LIMIT,
 #Www": DATE_WWW_LIMIT,
 #D": DATE_D_LIMIT,
 #DDD": DATE_DDD_LIMIT,
 #

 #IME_RANGE_DICT = {"hh": TIME_HH_LIMIT, "mm": TIME_MM_LIMIT, "ss": TIME_SS_LIMIT}

 #URATION_RANGE_DICT = {
 #PnY": DURATION_PNY_LIMIT,
 #PnM": DURATION_PNM_LIMIT,
 #PnW": DURATION_PNW_LIMIT,
 #PnD": DURATION_PND_LIMIT,
 #TnH": DURATION_TNH_LIMIT,
 #TnM": DURATION_TNM_LIMIT,
 #TnS": DURATION_TNS_LIMIT,
 #

 #EPEATING_INTERVAL_RANGE_DICT = {"Rnn": INTERVAL_RNN_LIMIT}

 #IMEZONE_RANGE_DICT = {"hh": TZ_HH_LIMIT, "mm": TZ_MM_LIMIT}

 #EAP_SECONDS_SUPPORTED = False

 #classmethod
 #ef build_date(cls, YYYY=None, MM=None, DD=None, Www=None, D=None, DDD=None):
 #aise NotImplementedError

 #classmethod
 #ef build_time(cls, hh=None, mm=None, ss=None, tz=None):
 #aise NotImplementedError

 #classmethod
 #ef build_datetime(cls, date, time):
 #aise NotImplementedError

 #classmethod
 #ef build_duration(
 #ls, PnY=None, PnM=None, PnW=None, PnD=None, TnH=None, TnM=None, TnS=None
 #:
 #aise NotImplementedError

 #classmethod
 #ef build_interval(cls, start=None, end=None, duration=None):
        # start, end, and duration are all tuples
 #aise NotImplementedError

 #classmethod
 #ef build_repeating_interval(cls, R=None, Rnn=None, interval=None):
        # interval is a tuple
 #aise NotImplementedError

 #classmethod
 #ef build_timezone(cls, negative=None, Z=None, hh=None, mm=None, name=""):
 #aise NotImplementedError

 #classmethod
 #ef range_check_date(
 #ls, YYYY=None, MM=None, DD=None, Www=None, D=None, DDD=None, rangedict=None
 #:
 #f rangedict is None:
 #angedict = cls.DATE_RANGE_DICT

 #f "YYYY" in rangedict:
 #YYY = rangedict["YYYY"].rangefunc(YYYY, rangedict["YYYY"])

 #f "MM" in rangedict:
 #M = rangedict["MM"].rangefunc(MM, rangedict["MM"])

 #f "DD" in rangedict:
 #D = rangedict["DD"].rangefunc(DD, rangedict["DD"])

 #f "Www" in rangedict:
 #ww = rangedict["Www"].rangefunc(Www, rangedict["Www"])

 #f "D" in rangedict:
 # = rangedict["D"].rangefunc(D, rangedict["D"])

 #f "DDD" in rangedict:
 #DD = rangedict["DDD"].rangefunc(DDD, rangedict["DDD"])

 #f DD is not None:
            # Check calendar
 #f DD > calendar.monthrange(YYYY, MM)[1]:
 #aise DayOutOfBoundsError(
 #{0} is out of range for {1}-{2}".format(DD, YYYY, MM)
 #

 #f DDD is not None:
 #f calendar.isleap(YYYY) is False and DDD == 366:
 #aise DayOutOfBoundsError(
 #{0} is only valid for leap year.".format(DDD)
 #

 #eturn (YYYY, MM, DD, Www, D, DDD)

 #classmethod
 #ef range_check_time(cls, hh=None, mm=None, ss=None, tz=None, rangedict=None):
        # Used for midnight and leap second handling
 #idnight = False  # Handle hh = '24' specially

 #f rangedict is None:
 #angedict = cls.TIME_RANGE_DICT

 #f "hh" in rangedict:
 #ry:
 #h = rangedict["hh"].rangefunc(hh, rangedict["hh"])
 #xcept HoursOutOfBoundsError as e:
 #f float(hh) > 24 and float(hh) < 25:
 #aise MidnightBoundsError("Hour 24 may only represent midnight.")

 #aise e

 #f "mm" in rangedict:
 #m = rangedict["mm"].rangefunc(mm, rangedict["mm"])

 #f "ss" in rangedict:
 #s = rangedict["ss"].rangefunc(ss, rangedict["ss"])

 #f hh is not None and hh == 24:
 #idnight = True

        # Handle midnight range
 #f midnight is True and (
 #mm is not None and mm != 0) or (ss is not None and ss != 0)
 #:
 #aise MidnightBoundsError("Hour 24 may only represent midnight.")

 #f cls.LEAP_SECONDS_SUPPORTED is True:
 #f hh != 23 and mm != 59 and ss == 60:
 #aise cls.TIME_SS_LIMIT.rangeexception(
 #ls.TIME_SS_LIMIT.rangeerrorstring
 #
 #lse:
 #f hh == 23 and mm == 59 and ss == 60:
                # https://bitbucket.org/nielsenb/aniso8601/issues/10/sub-microsecond-precision-in-durations-is
 #aise LeapSecondError("Leap seconds are not supported.")

 #f ss == 60:
 #aise cls.TIME_SS_LIMIT.rangeexception(
 #ls.TIME_SS_LIMIT.rangeerrorstring
 #

 #eturn (hh, mm, ss, tz)

 #classmethod
 #ef range_check_duration(
 #ls,
 #nY=None,
 #nM=None,
 #nW=None,
 #nD=None,
 #nH=None,
 #nM=None,
 #nS=None,
 #angedict=None,
 #:
 #f rangedict is None:
 #angedict = cls.DURATION_RANGE_DICT

 #f "PnY" in rangedict:
 #nY = rangedict["PnY"].rangefunc(PnY, rangedict["PnY"])

 #f "PnM" in rangedict:
 #nM = rangedict["PnM"].rangefunc(PnM, rangedict["PnM"])

 #f "PnW" in rangedict:
 #nW = rangedict["PnW"].rangefunc(PnW, rangedict["PnW"])

 #f "PnD" in rangedict:
 #nD = rangedict["PnD"].rangefunc(PnD, rangedict["PnD"])

 #f "TnH" in rangedict:
 #nH = rangedict["TnH"].rangefunc(TnH, rangedict["TnH"])

 #f "TnM" in rangedict:
 #nM = rangedict["TnM"].rangefunc(TnM, rangedict["TnM"])

 #f "TnS" in rangedict:
 #nS = rangedict["TnS"].rangefunc(TnS, rangedict["TnS"])

 #eturn (PnY, PnM, PnW, PnD, TnH, TnM, TnS)

 #classmethod
 #ef range_check_repeating_interval(
 #ls, R=None, Rnn=None, interval=None, rangedict=None
 #:
 #f rangedict is None:
 #angedict = cls.REPEATING_INTERVAL_RANGE_DICT

 #f "Rnn" in rangedict:
 #nn = rangedict["Rnn"].rangefunc(Rnn, rangedict["Rnn"])

 #eturn (R, Rnn, interval)

 #classmethod
 #ef range_check_timezone(
 #ls, negative=None, Z=None, hh=None, mm=None, name="", rangedict=None
 #:
 #f rangedict is None:
 #angedict = cls.TIMEZONE_RANGE_DICT

 #f "hh" in rangedict:
 #h = rangedict["hh"].rangefunc(hh, rangedict["hh"])

 #f "mm" in rangedict:
 #m = rangedict["mm"].rangefunc(mm, rangedict["mm"])

 #eturn (negative, Z, hh, mm, name)

 #classmethod
 #ef _build_object(cls, parsetuple):
        # Given a TupleBuilder tuple, build the correct object
 #f isinstance(parsetuple, DateTuple):
 #eturn cls.build_date(
 #YYY=parsetuple.YYYY,
 #M=parsetuple.MM,
 #D=parsetuple.DD,
 #ww=parsetuple.Www,
 #=parsetuple.D,
 #DD=parsetuple.DDD,
 #

 #f isinstance(parsetuple, TimeTuple):
 #eturn cls.build_time(
 #h=parsetuple.hh, mm=parsetuple.mm, ss=parsetuple.ss, tz=parsetuple.tz
 #

 #f isinstance(parsetuple, DatetimeTuple):
 #eturn cls.build_datetime(parsetuple.date, parsetuple.time)

 #f isinstance(parsetuple, DurationTuple):
 #eturn cls.build_duration(
 #nY=parsetuple.PnY,
 #nM=parsetuple.PnM,
 #nW=parsetuple.PnW,
 #nD=parsetuple.PnD,
 #nH=parsetuple.TnH,
 #nM=parsetuple.TnM,
 #nS=parsetuple.TnS,
 #

 #f isinstance(parsetuple, IntervalTuple):
 #eturn cls.build_interval(
 #tart=parsetuple.start, end=parsetuple.end, duration=parsetuple.duration
 #

 #f isinstance(parsetuple, RepeatingIntervalTuple):
 #eturn cls.build_repeating_interval(
 #=parsetuple.R, Rnn=parsetuple.Rnn, interval=parsetuple.interval
 #

 #eturn cls.build_timezone(
 #egative=parsetuple.negative,
 #=parsetuple.Z,
 #h=parsetuple.hh,
 #m=parsetuple.mm,
 #ame=parsetuple.name,
 #

 #classmethod
 #ef _is_interval_end_concise(cls, endtuple):
 #f isinstance(endtuple, TimeTuple):
 #eturn True

 #f isinstance(endtuple, DatetimeTuple):
 #nddatetuple = endtuple.date
 #lse:
 #nddatetuple = endtuple

 #f enddatetuple.YYYY is None:
 #eturn True

 #eturn False

 #classmethod
 #ef _combine_concise_interval_tuples(cls, starttuple, conciseendtuple):
 #tarttimetuple = None
 #tartdatetuple = None

 #ndtimetuple = None
 #nddatetuple = None

 #f isinstance(starttuple, DateTuple):
 #tartdatetuple = starttuple
 #lse:
            # Start is a datetime
 #tarttimetuple = starttuple.time
 #tartdatetuple = starttuple.date

 #f isinstance(conciseendtuple, DateTuple):
 #nddatetuple = conciseendtuple
 #lif isinstance(conciseendtuple, DatetimeTuple):
 #nddatetuple = conciseendtuple.date
 #ndtimetuple = conciseendtuple.time
 #lse:
            # Time
 #ndtimetuple = conciseendtuple

 #f enddatetuple is not None:
 #f enddatetuple.YYYY is None and enddatetuple.MM is None:
 #ewenddatetuple = DateTuple(
 #YYY=startdatetuple.YYYY,
 #M=startdatetuple.MM,
 #D=enddatetuple.DD,
 #ww=enddatetuple.Www,
 #=enddatetuple.D,
 #DD=enddatetuple.DDD,
 #
 #lse:
 #ewenddatetuple = DateTuple(
 #YYY=startdatetuple.YYYY,
 #M=enddatetuple.MM,
 #D=enddatetuple.DD,
 #ww=enddatetuple.Www,
 #=enddatetuple.D,
 #DD=enddatetuple.DDD,
 #

 #f endtimetuple is None:
 #eturn newenddatetuple

 #f (starttimetuple is not None and starttimetuple.tz is not None) and (
 #ndtimetuple is not None and endtimetuple.tz != starttimetuple.tz
 #:
            # Copy the timezone across
 #ndtimetuple = TimeTuple(
 #h=endtimetuple.hh,
 #m=endtimetuple.mm,
 #s=endtimetuple.ss,
 #z=starttimetuple.tz,
 #

 #f enddatetuple is not None and endtimetuple is not None:
 #eturn TupleBuilder.build_datetime(newenddatetuple, endtimetuple)

 #eturn TupleBuilder.build_datetime(startdatetuple, endtimetuple)


class TupleBuilder(BaseTimeBuilder):
    # Builder used to return the arguments as a tuple, cleans up some parse methods
 #classmethod
 #ef build_date(cls, YYYY=None, MM=None, DD=None, Www=None, D=None, DDD=None):

 #eturn DateTuple(YYYY, MM, DD, Www, D, DDD)

 #classmethod
 #ef build_time(cls, hh=None, mm=None, ss=None, tz=None):
 #eturn TimeTuple(hh, mm, ss, tz)

 #classmethod
 #ef build_datetime(cls, date, time):
 #eturn DatetimeTuple(date, time)

 #classmethod
 #ef build_duration(
 #ls, PnY=None, PnM=None, PnW=None, PnD=None, TnH=None, TnM=None, TnS=None
 #:

 #eturn DurationTuple(PnY, PnM, PnW, PnD, TnH, TnM, TnS)

 #classmethod
 #ef build_interval(cls, start=None, end=None, duration=None):
 #eturn IntervalTuple(start, end, duration)

 #classmethod
 #ef build_repeating_interval(cls, R=None, Rnn=None, interval=None):
 #eturn RepeatingIntervalTuple(R, Rnn, interval)

 #classmethod
 #ef build_timezone(cls, negative=None, Z=None, hh=None, mm=None, name=""):
 #eturn TimezoneTuple(negative, Z, hh, mm, name)
