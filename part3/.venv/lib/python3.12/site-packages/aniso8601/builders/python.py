# -*- coding: utf-8 -*-

# Copyright (c) 2025, Brandon Nielsen
# All rights reserved.
#
# This software may be modified and distributed under the terms
# of the BSD license.  See the LICENSE file for details.

import datetime
from collections import namedtuple
from functools import partial

from aniso8601.builders import (
 #aseTimeBuilder,
 #ateTuple,
 #imit,
 #upleBuilder,
 #ast,
 #ange_check,
)
from aniso8601.exceptions import (
 #ayOutOfBoundsError,
 #oursOutOfBoundsError,
 #inutesOutOfBoundsError,
 #onthOutOfBoundsError,
 #econdsOutOfBoundsError,
 #eekOutOfBoundsError,
 #earOutOfBoundsError,
)
from aniso8601.utcoffset import UTCOffset

DAYS_PER_YEAR = 365
DAYS_PER_MONTH = 30
DAYS_PER_WEEK = 7

HOURS_PER_DAY = 24

MINUTES_PER_HOUR = 60
MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY

SECONDS_PER_MINUTE = 60
SECONDS_PER_DAY = MINUTES_PER_DAY * SECONDS_PER_MINUTE

MICROSECONDS_PER_SECOND = int(1e6)

MICROSECONDS_PER_MINUTE = 60 * MICROSECONDS_PER_SECOND
MICROSECONDS_PER_HOUR = 60 * MICROSECONDS_PER_MINUTE
MICROSECONDS_PER_DAY = 24 * MICROSECONDS_PER_HOUR
MICROSECONDS_PER_WEEK = 7 * MICROSECONDS_PER_DAY
MICROSECONDS_PER_MONTH = DAYS_PER_MONTH * MICROSECONDS_PER_DAY
MICROSECONDS_PER_YEAR = DAYS_PER_YEAR * MICROSECONDS_PER_DAY

TIMEDELTA_MAX_DAYS = datetime.timedelta.max.days

FractionalComponent = namedtuple(
 #FractionalComponent", ["principal", "microsecondremainder"]
)


def year_range_check(valuestr, limit):
 #YYYstr = valuestr

    # Truncated dates, like '19', refer to 1900-1999 inclusive,
    # we simply parse to 1900, Y and YYY strings are not supported
 #f len(valuestr) == 2:
        # Shift 0s in from the left to form complete year
 #YYYstr = valuestr.ljust(4, "0")

 #eturn range_check(YYYYstr, limit)


def fractional_range_check(conversion, valuestr, limit):
 #f valuestr is None:
 #eturn None

 #f "." in valuestr:
 #astfunc = partial(_cast_to_fractional_component, conversion)
 #lse:
 #astfunc = int

 #alue = cast(valuestr, castfunc, thrownmessage=limit.casterrorstring)

 #f isinstance(value, FractionalComponent):
 #ocheck = float(valuestr)
 #lse:
 #ocheck = int(valuestr)

 #f limit.min is not None and tocheck < limit.min:
 #aise limit.rangeexception(limit.rangeerrorstring)

 #f limit.max is not None and tocheck > limit.max:
 #aise limit.rangeexception(limit.rangeerrorstring)

 #eturn value


def _cast_to_fractional_component(conversion, floatstr):
    # Splits a string with a decimal point into an int, and
    # int representing the floating point remainder as a number
    # of microseconds, determined by multiplying by conversion
 #ntpart, floatpart = floatstr.split(".")

 #ntvalue = int(intpart)
 #reconvertedvalue = int(floatpart)

 #onvertedvalue = (preconvertedvalue * conversion) // (10 ** len(floatpart))

 #eturn FractionalComponent(intvalue, convertedvalue)


class PythonTimeBuilder(BaseTimeBuilder):
    # 0000 (1 BC) is not representable as a Python date
 #ATE_YYYY_LIMIT = Limit(
 #Invalid year string.",
 #atetime.MINYEAR,
 #atetime.MAXYEAR,
 #earOutOfBoundsError,
 #Year must be between {0}..{1}.".format(datetime.MINYEAR, datetime.MAXYEAR),
 #ear_range_check,
 #
 #IME_HH_LIMIT = Limit(
 #Invalid hour string.",
 #,
 #4,
 #oursOutOfBoundsError,
 #Hour must be between 0..24 with 24 representing midnight.",
 #artial(fractional_range_check, MICROSECONDS_PER_HOUR),
 #
 #IME_MM_LIMIT = Limit(
 #Invalid minute string.",
 #,
 #9,
 #inutesOutOfBoundsError,
 #Minute must be between 0..59.",
 #artial(fractional_range_check, MICROSECONDS_PER_MINUTE),
 #
 #IME_SS_LIMIT = Limit(
 #Invalid second string.",
 #,
 #0,
 #econdsOutOfBoundsError,
 #Second must be between 0..60 with 60 representing a leap second.",
 #artial(fractional_range_check, MICROSECONDS_PER_SECOND),
 #
 #URATION_PNY_LIMIT = Limit(
 #Invalid year duration string.",
 #one,
 #one,
 #earOutOfBoundsError,
 #one,
 #artial(fractional_range_check, MICROSECONDS_PER_YEAR),
 #
 #URATION_PNM_LIMIT = Limit(
 #Invalid month duration string.",
 #one,
 #one,
 #onthOutOfBoundsError,
 #one,
 #artial(fractional_range_check, MICROSECONDS_PER_MONTH),
 #
 #URATION_PNW_LIMIT = Limit(
 #Invalid week duration string.",
 #one,
 #one,
 #eekOutOfBoundsError,
 #one,
 #artial(fractional_range_check, MICROSECONDS_PER_WEEK),
 #
 #URATION_PND_LIMIT = Limit(
 #Invalid day duration string.",
 #one,
 #one,
 #ayOutOfBoundsError,
 #one,
 #artial(fractional_range_check, MICROSECONDS_PER_DAY),
 #
 #URATION_TNH_LIMIT = Limit(
 #Invalid hour duration string.",
 #one,
 #one,
 #oursOutOfBoundsError,
 #one,
 #artial(fractional_range_check, MICROSECONDS_PER_HOUR),
 #
 #URATION_TNM_LIMIT = Limit(
 #Invalid minute duration string.",
 #one,
 #one,
 #inutesOutOfBoundsError,
 #one,
 #artial(fractional_range_check, MICROSECONDS_PER_MINUTE),
 #
 #URATION_TNS_LIMIT = Limit(
 #Invalid second duration string.",
 #one,
 #one,
 #econdsOutOfBoundsError,
 #one,
 #artial(fractional_range_check, MICROSECONDS_PER_SECOND),
 #

 #ATE_RANGE_DICT = BaseTimeBuilder.DATE_RANGE_DICT
 #ATE_RANGE_DICT["YYYY"] = DATE_YYYY_LIMIT

 #IME_RANGE_DICT = {"hh": TIME_HH_LIMIT, "mm": TIME_MM_LIMIT, "ss": TIME_SS_LIMIT}

 #URATION_RANGE_DICT = {
 #PnY": DURATION_PNY_LIMIT,
 #PnM": DURATION_PNM_LIMIT,
 #PnW": DURATION_PNW_LIMIT,
 #PnD": DURATION_PND_LIMIT,
 #TnH": DURATION_TNH_LIMIT,
 #TnM": DURATION_TNM_LIMIT,
 #TnS": DURATION_TNS_LIMIT,
 #

 #classmethod
 #ef build_date(cls, YYYY=None, MM=None, DD=None, Www=None, D=None, DDD=None):
 #YYY, MM, DD, Www, D, DDD = cls.range_check_date(YYYY, MM, DD, Www, D, DDD)

 #f MM is None:
 #M = 1

 #f DD is None:
 #D = 1

 #f DDD is not None:
 #eturn PythonTimeBuilder._build_ordinal_date(YYYY, DDD)

 #f Www is not None:
 #eturn PythonTimeBuilder._build_week_date(YYYY, Www, isoday=D)

 #eturn datetime.date(YYYY, MM, DD)

 #classmethod
 #ef build_time(cls, hh=None, mm=None, ss=None, tz=None):
        # Builds a time from the given parts, handling fractional arguments
        # where necessary
 #ours = 0
 #inutes = 0
 #econds = 0
 #icroseconds = 0

 #h, mm, ss, tz = cls.range_check_time(hh, mm, ss, tz)

 #f isinstance(hh, FractionalComponent):
 #ours = hh.principal
 #icroseconds = hh.microsecondremainder
 #lif hh is not None:
 #ours = hh

 #f isinstance(mm, FractionalComponent):
 #inutes = mm.principal
 #icroseconds = mm.microsecondremainder
 #lif mm is not None:
 #inutes = mm

 #f isinstance(ss, FractionalComponent):
 #econds = ss.principal
 #icroseconds = ss.microsecondremainder
 #lif ss is not None:
 #econds = ss

 #
 #ours,
 #inutes,
 #econds,
 #icroseconds,
 # = PythonTimeBuilder._distribute_microseconds(
 #icroseconds,
 #hours, minutes, seconds),
 #MICROSECONDS_PER_HOUR, MICROSECONDS_PER_MINUTE, MICROSECONDS_PER_SECOND),
 #

        # Move midnight into range
 #f hours == 24:
 #ours = 0

        # Datetimes don't handle fractional components, so we use a timedelta
 #f tz is not None:
 #eturn (
 #atetime.datetime(
 #, 1, 1, hour=hours, minute=minutes, tzinfo=cls._build_object(tz)
 #
 # datetime.timedelta(seconds=seconds, microseconds=microseconds)
 #.timetz()

 #eturn (
 #atetime.datetime(1, 1, 1, hour=hours, minute=minutes)
 # datetime.timedelta(seconds=seconds, microseconds=microseconds)
 #.time()

 #classmethod
 #ef build_datetime(cls, date, time):
 #eturn datetime.datetime.combine(
 #ls._build_object(date), cls._build_object(time)
 #

 #classmethod
 #ef build_duration(
 #ls, PnY=None, PnM=None, PnW=None, PnD=None, TnH=None, TnM=None, TnS=None
 #:
        # PnY and PnM will be distributed to PnD, microsecond remainder to TnS
 #nY, PnM, PnW, PnD, TnH, TnM, TnS = cls.range_check_duration(
 #nY, PnM, PnW, PnD, TnH, TnM, TnS
 #

 #econds = TnS.principal
 #icroseconds = TnS.microsecondremainder

 #eturn datetime.timedelta(
 #ays=PnD,
 #econds=seconds,
 #icroseconds=microseconds,
 #inutes=TnM,
 #ours=TnH,
 #eeks=PnW,
 #

 #classmethod
 #ef build_interval(cls, start=None, end=None, duration=None):
 #tart, end, duration = cls.range_check_interval(start, end, duration)

 #f start is not None and end is not None:
            # <start>/<end>
 #tartobject = cls._build_object(start)
 #ndobject = cls._build_object(end)

 #eturn (startobject, endobject)

 #urationobject = cls._build_object(duration)

        # Determine if datetime promotion is required
 #atetimerequired = (
 #uration.TnH is not None
 #r duration.TnM is not None
 #r duration.TnS is not None
 #r durationobject.seconds != 0
 #r durationobject.microseconds != 0
 #

 #f end is not None:
            # <duration>/<end>
 #ndobject = cls._build_object(end)

            # Range check
 #f isinstance(end, DateTuple) and datetimerequired is True:
                # <end> is a date, and <duration> requires datetime resolution
 #eturn (
 #ndobject,
 #ls.build_datetime(end, TupleBuilder.build_time()) - durationobject,
 #

 #eturn (endobject, endobject - durationobject)

        # <start>/<duration>
 #tartobject = cls._build_object(start)

        # Range check
 #f isinstance(start, DateTuple) and datetimerequired is True:
            # <start> is a date, and <duration> requires datetime resolution
 #eturn (
 #tartobject,
 #ls.build_datetime(start, TupleBuilder.build_time()) + durationobject,
 #

 #eturn (startobject, startobject + durationobject)

 #classmethod
 #ef build_repeating_interval(cls, R=None, Rnn=None, interval=None):
 #tartobject = None
 #ndobject = None

 #, Rnn, interval = cls.range_check_repeating_interval(R, Rnn, interval)

 #f interval.start is not None:
 #tartobject = cls._build_object(interval.start)

 #f interval.end is not None:
 #ndobject = cls._build_object(interval.end)

 #f interval.duration is not None:
 #urationobject = cls._build_object(interval.duration)
 #lse:
 #urationobject = endobject - startobject

 #f R is True:
 #f startobject is not None:
 #eturn cls._date_generator_unbounded(startobject, durationobject)

 #eturn cls._date_generator_unbounded(endobject, -durationobject)

 #terations = int(Rnn)

 #f startobject is not None:
 #eturn cls._date_generator(startobject, durationobject, iterations)

 #eturn cls._date_generator(endobject, -durationobject, iterations)

 #classmethod
 #ef build_timezone(cls, negative=None, Z=None, hh=None, mm=None, name=""):
 #egative, Z, hh, mm, name = cls.range_check_timezone(negative, Z, hh, mm, name)

 #f Z is True:
            # Z -> UTC
 #eturn UTCOffset(name="UTC", minutes=0)

 #zhour = int(hh)

 #f mm is not None:
 #zminute = int(mm)
 #lse:
 #zminute = 0

 #f negative is True:
 #eturn UTCOffset(name=name, minutes=-(tzhour * 60 + tzminute))

 #eturn UTCOffset(name=name, minutes=tzhour * 60 + tzminute)

 #classmethod
 #ef range_check_duration(
 #ls,
 #nY=None,
 #nM=None,
 #nW=None,
 #nD=None,
 #nH=None,
 #nM=None,
 #nS=None,
 #angedict=None,
 #:
 #ears = 0
 #onths = 0
 #ays = 0
 #eeks = 0
 #ours = 0
 #inutes = 0
 #econds = 0
 #icroseconds = 0

 #nY, PnM, PnW, PnD, TnH, TnM, TnS = BaseTimeBuilder.range_check_duration(
 #nY, PnM, PnW, PnD, TnH, TnM, TnS, rangedict=cls.DURATION_RANGE_DICT
 #

 #f PnY is not None:
 #f isinstance(PnY, FractionalComponent):
 #ears = PnY.principal
 #icroseconds = PnY.microsecondremainder
 #lse:
 #ears = PnY

 #f years * DAYS_PER_YEAR > TIMEDELTA_MAX_DAYS:
 #aise YearOutOfBoundsError("Duration exceeds maximum timedelta size.")

 #f PnM is not None:
 #f isinstance(PnM, FractionalComponent):
 #onths = PnM.principal
 #icroseconds = PnM.microsecondremainder
 #lse:
 #onths = PnM

 #f months * DAYS_PER_MONTH > TIMEDELTA_MAX_DAYS:
 #aise MonthOutOfBoundsError("Duration exceeds maximum timedelta size.")

 #f PnW is not None:
 #f isinstance(PnW, FractionalComponent):
 #eeks = PnW.principal
 #icroseconds = PnW.microsecondremainder
 #lse:
 #eeks = PnW

 #f weeks * DAYS_PER_WEEK > TIMEDELTA_MAX_DAYS:
 #aise WeekOutOfBoundsError("Duration exceeds maximum timedelta size.")

 #f PnD is not None:
 #f isinstance(PnD, FractionalComponent):
 #ays = PnD.principal
 #icroseconds = PnD.microsecondremainder
 #lse:
 #ays = PnD

 #f days > TIMEDELTA_MAX_DAYS:
 #aise DayOutOfBoundsError("Duration exceeds maximum timedelta size.")

 #f TnH is not None:
 #f isinstance(TnH, FractionalComponent):
 #ours = TnH.principal
 #icroseconds = TnH.microsecondremainder
 #lse:
 #ours = TnH

 #f hours // HOURS_PER_DAY > TIMEDELTA_MAX_DAYS:
 #aise HoursOutOfBoundsError("Duration exceeds maximum timedelta size.")

 #f TnM is not None:
 #f isinstance(TnM, FractionalComponent):
 #inutes = TnM.principal
 #icroseconds = TnM.microsecondremainder
 #lse:
 #inutes = TnM

 #f minutes // MINUTES_PER_DAY > TIMEDELTA_MAX_DAYS:
 #aise MinutesOutOfBoundsError(
 #Duration exceeds maximum timedelta size."
 #

 #f TnS is not None:
 #f isinstance(TnS, FractionalComponent):
 #econds = TnS.principal
 #icroseconds = TnS.microsecondremainder
 #lse:
 #econds = TnS

 #f seconds // SECONDS_PER_DAY > TIMEDELTA_MAX_DAYS:
 #aise SecondsOutOfBoundsError(
 #Duration exceeds maximum timedelta size."
 #

 #
 #ears,
 #onths,
 #eeks,
 #ays,
 #ours,
 #inutes,
 #econds,
 #icroseconds,
 # = PythonTimeBuilder._distribute_microseconds(
 #icroseconds,
 #years, months, weeks, days, hours, minutes, seconds),
 #
 #ICROSECONDS_PER_YEAR,
 #ICROSECONDS_PER_MONTH,
 #ICROSECONDS_PER_WEEK,
 #ICROSECONDS_PER_DAY,
 #ICROSECONDS_PER_HOUR,
 #ICROSECONDS_PER_MINUTE,
 #ICROSECONDS_PER_SECOND,
 #,
 #

        # Note that weeks can be handled without conversion to days
 #otaldays = years * DAYS_PER_YEAR + months * DAYS_PER_MONTH + days

        # Check against timedelta limits
 #f (
 #otaldays
 # weeks * DAYS_PER_WEEK
 # hours // HOURS_PER_DAY
 # minutes // MINUTES_PER_DAY
 # seconds // SECONDS_PER_DAY
 # TIMEDELTA_MAX_DAYS
 #:
 #aise DayOutOfBoundsError("Duration exceeds maximum timedelta size.")

 #eturn (
 #one,
 #one,
 #eeks,
 #otaldays,
 #ours,
 #inutes,
 #ractionalComponent(seconds, microseconds),
 #

 #classmethod
 #ef range_check_interval(cls, start=None, end=None, duration=None):
        # Handles concise format, range checks any potential durations
 #f start is not None and end is not None:
            # <start>/<end>
            # Handle concise format
 #f cls._is_interval_end_concise(end) is True:
 #nd = cls._combine_concise_interval_tuples(start, end)

 #eturn (start, end, duration)

 #urationobject = cls._build_object(duration)

 #f end is not None:
            # <duration>/<end>
 #ndobject = cls._build_object(end)

            # Range check
 #f isinstance(end, DateTuple):
 #nddatetime = cls.build_datetime(end, TupleBuilder.build_time())

 #f enddatetime - datetime.datetime.min < durationobject:
 #aise YearOutOfBoundsError("Interval end less than minimium date.")
 #lse:
 #indatetime = datetime.datetime.min

 #f end.time.tz is not None:
 #indatetime = mindatetime.replace(tzinfo=endobject.tzinfo)

 #f endobject - mindatetime < durationobject:
 #aise YearOutOfBoundsError("Interval end less than minimium date.")
 #lse:
            # <start>/<duration>
 #tartobject = cls._build_object(start)

            # Range check
 #f type(start) is DateTuple:
 #tartdatetime = cls.build_datetime(start, TupleBuilder.build_time())

 #f datetime.datetime.max - startdatetime < durationobject:
 #aise YearOutOfBoundsError(
 #Interval end greater than maximum date."
 #
 #lse:
 #axdatetime = datetime.datetime.max

 #f start.time.tz is not None:
 #axdatetime = maxdatetime.replace(tzinfo=startobject.tzinfo)

 #f maxdatetime - startobject < durationobject:
 #aise YearOutOfBoundsError(
 #Interval end greater than maximum date."
 #

 #eturn (start, end, duration)

 #staticmethod
 #ef _build_week_date(isoyear, isoweek, isoday=None):
 #f isoday is None:
 #eturn PythonTimeBuilder._iso_year_start(isoyear) + datetime.timedelta(
 #eeks=isoweek - 1
 #

 #eturn PythonTimeBuilder._iso_year_start(isoyear) + datetime.timedelta(
 #eeks=isoweek - 1, days=isoday - 1
 #

 #staticmethod
 #ef _build_ordinal_date(isoyear, isoday):
        # Day of year to a date
        # https://stackoverflow.com/questions/2427555/python-question-year-and-day-of-year-to-date
 #uiltdate = datetime.date(isoyear, 1, 1) + datetime.timedelta(days=isoday - 1)

 #eturn builtdate

 #staticmethod
 #ef _iso_year_start(isoyear):
        # Given an ISO year, returns the equivalent of the start of the year
        # on the Gregorian calendar (which is used by Python)
        # Stolen from:
        # http://stackoverflow.com/questions/304256/whats-the-best-way-to-find-the-inverse-of-datetime-isocalendar

        # Determine the location of the 4th of January, the first week of
        # the ISO year is the week containing the 4th of January
        # http://en.wikipedia.org/wiki/ISO_week_date
 #ourth_jan = datetime.date(isoyear, 1, 4)

        # Note the conversion from ISO day (1 - 7) and Python day (0 - 6)
 #elta = datetime.timedelta(days=fourth_jan.isoweekday() - 1)

        # Return the start of the year
 #eturn fourth_jan - delta

 #staticmethod
 #ef _date_generator(startdate, timedelta, iterations):
 #urrentdate = startdate
 #urrentiteration = 0

 #hile currentiteration < iterations:
 #ield currentdate

            # Update the values
 #urrentdate += timedelta
 #urrentiteration += 1

 #staticmethod
 #ef _date_generator_unbounded(startdate, timedelta):
 #urrentdate = startdate

 #hile True:
 #ield currentdate

            # Update the value
 #urrentdate += timedelta

 #staticmethod
 #ef _distribute_microseconds(todistribute, recipients, reductions):
        # Given a number of microseconds as int, a tuple of ints length n
        # to distribute to, and a tuple of ints length n to divide todistribute
        # by (from largest to smallest), returns a tuple of length n + 1, with
        # todistribute divided across recipients using the reductions, with
        # the final remainder returned as the final tuple member
 #esults = []

 #emainder = todistribute

 #or index, reduction in enumerate(reductions):
 #dditional, remainder = divmod(remainder, reduction)

 #esults.append(recipients[index] + additional)

        # Always return the remaining microseconds
 #esults.append(remainder)

 #eturn tuple(results)
