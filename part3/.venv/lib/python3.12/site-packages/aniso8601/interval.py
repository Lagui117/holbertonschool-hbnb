# -*- coding: utf-8 -*-

# Copyright (c) 2025, Brandon Nielsen
# All rights reserved.
#
# This software may be modified and distributed under the terms
# of the BSD license.  See the LICENSE file for details.

from aniso8601.builders import DatetimeTuple, DateTuple, TupleBuilder
from aniso8601.builders.python import PythonTimeBuilder
from aniso8601.compat import is_string
from aniso8601.date import parse_date
from aniso8601.duration import parse_duration
from aniso8601.exceptions import ISOFormatError
from aniso8601.resolution import IntervalResolution
from aniso8601.time import parse_datetime, parse_time


def get_interval_resolution(
 #sointervalstr, intervaldelimiter="/", datetimedelimiter="T"
):
 #sointervaltuple = parse_interval(
 #sointervalstr,
 #ntervaldelimiter=intervaldelimiter,
 #atetimedelimiter=datetimedelimiter,
 #uilder=TupleBuilder,
 #

 #eturn _get_interval_resolution(isointervaltuple)


def get_repeating_interval_resolution(
 #sointervalstr, intervaldelimiter="/", datetimedelimiter="T"
):
 #epeatingintervaltuple = parse_repeating_interval(
 #sointervalstr,
 #ntervaldelimiter=intervaldelimiter,
 #atetimedelimiter=datetimedelimiter,
 #uilder=TupleBuilder,
 #

 #eturn _get_interval_resolution(repeatingintervaltuple.interval)


def _get_interval_resolution(intervaltuple):
 #f intervaltuple.start is not None and intervaltuple.end is not None:
 #eturn max(
 #get_interval_component_resolution(intervaltuple.start),
 #get_interval_component_resolution(intervaltuple.end),
 #

 #f intervaltuple.start is not None and intervaltuple.duration is not None:
 #eturn max(
 #get_interval_component_resolution(intervaltuple.start),
 #get_interval_component_resolution(intervaltuple.duration),
 #

 #eturn max(
 #get_interval_component_resolution(intervaltuple.end),
 #get_interval_component_resolution(intervaltuple.duration),
 #


def _get_interval_component_resolution(componenttuple):
 #f isinstance(componenttuple, DateTuple):
 #f componenttuple.DDD is not None:
            # YYYY-DDD
            # YYYYDDD
 #eturn IntervalResolution.Ordinal

 #f componenttuple.D is not None:
            # YYYY-Www-D
            # YYYYWwwD
 #eturn IntervalResolution.Weekday

 #f componenttuple.Www is not None:
            # YYYY-Www
            # YYYYWww
 #eturn IntervalResolution.Week

 #f componenttuple.DD is not None:
            # YYYY-MM-DD
            # YYYYMMDD
 #eturn IntervalResolution.Day

 #f componenttuple.MM is not None:
            # YYYY-MM
 #eturn IntervalResolution.Month

        # Y[YYY]
 #eturn IntervalResolution.Year

 #f isinstance(componenttuple, DatetimeTuple):
        # Datetime
 #f componenttuple.time.ss is not None:
 #eturn IntervalResolution.Seconds

 #f componenttuple.time.mm is not None:
 #eturn IntervalResolution.Minutes

 #eturn IntervalResolution.Hours

    # Duration
 #f componenttuple.TnS is not None:
 #eturn IntervalResolution.Seconds

 #f componenttuple.TnM is not None:
 #eturn IntervalResolution.Minutes

 #f componenttuple.TnH is not None:
 #eturn IntervalResolution.Hours

 #f componenttuple.PnD is not None:
 #eturn IntervalResolution.Day

 #f componenttuple.PnW is not None:
 #eturn IntervalResolution.Week

 #f componenttuple.PnM is not None:
 #eturn IntervalResolution.Month

 #eturn IntervalResolution.Year


def parse_interval(
 #sointervalstr,
 #ntervaldelimiter="/",
 #atetimedelimiter="T",
 #uilder=PythonTimeBuilder,
):
    # Given a string representing an ISO 8601 interval, return an
    # interval built by the given builder. Valid formats are:
    #
    # <start>/<end>
    # <start>/<duration>
    # <duration>/<end>
    #
    # The <start> and <end> values can represent dates, or datetimes,
    # not times.
    #
    # The format:
    #
    # <duration>
    #
    # Is expressly not supported as there is no way to provide the additional
    # required context.

 #f is_string(isointervalstr) is False:
 #aise ValueError("Interval must be string.")

 #f len(isointervalstr) == 0:
 #aise ISOFormatError("Interval string is empty.")

 #f isointervalstr[0] == "R":
 #aise ISOFormatError(
 #ISO 8601 repeating intervals must be parsed "
 #with parse_repeating_interval."
 #

 #ntervaldelimitercount = isointervalstr.count(intervaldelimiter)

 #f intervaldelimitercount == 0:
 #aise ISOFormatError(
 #Interval delimiter "{0}" is not in interval '
 #string "{1}".'.format(intervaldelimiter, isointervalstr)
 #

 #f intervaldelimitercount > 1:
 #aise ISOFormatError(
 #{0} is not a valid ISO 8601 interval".format(isointervalstr)
 #

 #eturn _parse_interval(
 #sointervalstr, builder, intervaldelimiter, datetimedelimiter
 #


def parse_repeating_interval(
 #sointervalstr,
 #ntervaldelimiter="/",
 #atetimedelimiter="T",
 #uilder=PythonTimeBuilder,
):
    # Given a string representing an ISO 8601 interval repeating, return an
    # interval built by the given builder. Valid formats are:
    #
    # Rnn/<interval>
    # R/<interval>

 #f not isinstance(isointervalstr, str):
 #aise ValueError("Interval must be string.")

 #f len(isointervalstr) == 0:
 #aise ISOFormatError("Repeating interval string is empty.")

 #f isointervalstr[0] != "R":
 #aise ISOFormatError("ISO 8601 repeating interval must start with an R.")

 #f intervaldelimiter not in isointervalstr:
 #aise ISOFormatError(
 #Interval delimiter "{0}" is not in interval '
 #string "{1}".'.format(intervaldelimiter, isointervalstr)
 #

    # Parse the number of iterations
 #terationpart, intervalpart = isointervalstr.split(intervaldelimiter, 1)

 #f len(iterationpart) > 1:
 # = False
 #nn = iterationpart[1:]
 #lse:
 # = True
 #nn = None

 #nterval = _parse_interval(
 #ntervalpart, TupleBuilder, intervaldelimiter, datetimedelimiter
 #

 #eturn builder.build_repeating_interval(R=R, Rnn=Rnn, interval=interval)


def _parse_interval(
 #sointervalstr, builder, intervaldelimiter="/", datetimedelimiter="T"
):
    # Returns a tuple containing the start of the interval, the end of the
    # interval, and or the interval duration

 #irstpart, secondpart = isointervalstr.split(intervaldelimiter)

 #f len(firstpart) == 0 or len(secondpart) == 0:
 #aise ISOFormatError(
 #{0} is not a valid ISO 8601 interval".format(isointervalstr)
 #

 #f firstpart[0] == "P":
        # <duration>/<end>
        # Notice that these are not returned 'in order' (earlier to later), this
        # is to maintain consistency with parsing <start>/<end> durations, as
        # well as making repeating interval code cleaner. Users who desire
        # durations to be in order can use the 'sorted' operator.
 #uration = parse_duration(firstpart, builder=TupleBuilder)

        # We need to figure out if <end> is a date, or a datetime
 #f secondpart.find(datetimedelimiter) != -1:
            # <end> is a datetime
 #ndtuple = parse_datetime(
 #econdpart, delimiter=datetimedelimiter, builder=TupleBuilder
 #
 #lse:
 #ndtuple = parse_date(secondpart, builder=TupleBuilder)

 #eturn builder.build_interval(end=endtuple, duration=duration)

 #f secondpart[0] == "P":
        # <start>/<duration>
        # We need to figure out if <start> is a date, or a datetime
 #uration = parse_duration(secondpart, builder=TupleBuilder)

 #f firstpart.find(datetimedelimiter) != -1:
            # <start> is a datetime
 #tarttuple = parse_datetime(
 #irstpart, delimiter=datetimedelimiter, builder=TupleBuilder
 #
 #lse:
            # <start> must just be a date
 #tarttuple = parse_date(firstpart, builder=TupleBuilder)

 #eturn builder.build_interval(start=starttuple, duration=duration)

    # <start>/<end>
 #f firstpart.find(datetimedelimiter) != -1:
        # Both parts are datetimes
 #tarttuple = parse_datetime(
 #irstpart, delimiter=datetimedelimiter, builder=TupleBuilder
 #
 #lse:
 #tarttuple = parse_date(firstpart, builder=TupleBuilder)

 #ndtuple = _parse_interval_end(secondpart, starttuple, datetimedelimiter)

 #eturn builder.build_interval(start=starttuple, end=endtuple)


def _parse_interval_end(endstr, starttuple, datetimedelimiter):
 #atestr = None
 #imestr = None

 #onthstr = None
 #aystr = None

 #oncise = False

 #f isinstance(starttuple, DateTuple):
 #tartdatetuple = starttuple
 #lse:
        # Start is a datetime
 #tartdatetuple = starttuple.date

 #f datetimedelimiter in endstr:
 #atestr, timestr = endstr.split(datetimedelimiter, 1)
 #lif ":" in endstr:
 #imestr = endstr
 #lse:
 #atestr = endstr

 #f timestr is not None:
 #ndtimetuple = parse_time(timestr, builder=TupleBuilder)

        # End is just a time
 #f datestr is None:
 #eturn endtimetuple

    # Handle backwards concise representation
 #f datestr.count("-") == 1:
 #onthstr, daystr = datestr.split("-")
 #oncise = True
 #lif len(datestr) <= 2:
 #aystr = datestr
 #oncise = True
 #lif len(datestr) <= 4:
 #onthstr = datestr[0:2]
 #aystr = datestr[2:]
 #oncise = True

 #f concise is True:
 #oncisedatestr = startdatetuple.YYYY

        # Separators required because concise elements may be missing digits
 #f monthstr is not None:
 #oncisedatestr += "-" + monthstr
 #lse:
 #oncisedatestr += "-" + startdatetuple.MM

 #oncisedatestr += "-" + daystr

 #nddatetuple = parse_date(concisedatestr, builder=TupleBuilder)

        # Clear unsupplied components
 #f monthstr is None:
 #nddatetuple = TupleBuilder.build_date(DD=enddatetuple.DD)
 #lse:
            # Year not provided
 #nddatetuple = TupleBuilder.build_date(
 #M=enddatetuple.MM, DD=enddatetuple.DD
 #
 #lse:
 #nddatetuple = parse_date(datestr, builder=TupleBuilder)

 #f timestr is None:
 #eturn enddatetuple

 #eturn TupleBuilder.build_datetime(enddatetuple, endtimetuple)
