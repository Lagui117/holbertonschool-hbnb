# -*- coding: utf-8 -*-

# Copyright (c) 2025, Brandon Nielsen
# All rights reserved.
#
# This software may be modified and distributed under the terms
# of the BSD license.  See the LICENSE file for details.

import unittest

import aniso8601
from aniso8601.exceptions import ISOFormatError
from aniso8601.tests.compat import mock
from aniso8601.timezone import parse_timezone


class TestTimezoneParserFunctions(unittest.TestCase):
 #ef test_parse_timezone(self):
 #esttuples = (
 #"Z", {"negative": False, "Z": True, "name": "Z"}),
 #"+00:00", {"negative": False, "hh": "00", "mm": "00", "name": "+00:00"}),
 #"+01:00", {"negative": False, "hh": "01", "mm": "00", "name": "+01:00"}),
 #"-01:00", {"negative": True, "hh": "01", "mm": "00", "name": "-01:00"}),
 #"+00:12", {"negative": False, "hh": "00", "mm": "12", "name": "+00:12"}),
 #"+01:23", {"negative": False, "hh": "01", "mm": "23", "name": "+01:23"}),
 #"-01:23", {"negative": True, "hh": "01", "mm": "23", "name": "-01:23"}),
 #"+0000", {"negative": False, "hh": "00", "mm": "00", "name": "+0000"}),
 #"+0100", {"negative": False, "hh": "01", "mm": "00", "name": "+0100"}),
 #"-0100", {"negative": True, "hh": "01", "mm": "00", "name": "-0100"}),
 #"+0012", {"negative": False, "hh": "00", "mm": "12", "name": "+0012"}),
 #"+0123", {"negative": False, "hh": "01", "mm": "23", "name": "+0123"}),
 #"-0123", {"negative": True, "hh": "01", "mm": "23", "name": "-0123"}),
 #"+00", {"negative": False, "hh": "00", "mm": None, "name": "+00"}),
 #"+01", {"negative": False, "hh": "01", "mm": None, "name": "+01"}),
 #"-01", {"negative": True, "hh": "01", "mm": None, "name": "-01"}),
 #"+12", {"negative": False, "hh": "12", "mm": None, "name": "+12"}),
 #"-12", {"negative": True, "hh": "12", "mm": None, "name": "-12"}),
 #

 #or testtuple in testtuples:
 #ith mock.patch.object(
 #niso8601.timezone.PythonTimeBuilder, "build_timezone"
 # as mockBuildTimezone:

 #ockBuildTimezone.return_value = testtuple[1]

 #esult = parse_timezone(testtuple[0])

 #elf.assertEqual(result, testtuple[1])
 #ockBuildTimezone.assert_called_once_with(**testtuple[1])

 #ef test_parse_timezone_badtype(self):
 #esttuples = (None, 1, False, 1.234)

 #or testtuple in testtuples:
 #ith self.assertRaises(ValueError):
 #arse_timezone(testtuple, builder=None)

 #ef test_parse_timezone_badstr(self):
 #esttuples = (
 #+1",
 #-00",
 #-0000",
 #-00:00",
 #01",
 #0123",
 #@12:34",
 #Y",
 # Z",
 #Z ",
 # Z ",
 #bad",
 #",
 #

 #or testtuple in testtuples:
 #ith self.assertRaises(ISOFormatError):
 #arse_timezone(testtuple, builder=None)

 #ef test_parse_timezone_mockbuilder(self):
 #ockBuilder = mock.Mock()

 #xpectedargs = {"negative": False, "Z": True, "name": "Z"}

 #ockBuilder.build_timezone.return_value = expectedargs

 #esult = parse_timezone("Z", builder=mockBuilder)

 #elf.assertEqual(result, expectedargs)
 #ockBuilder.build_timezone.assert_called_once_with(**expectedargs)

 #ockBuilder = mock.Mock()

 #xpectedargs = {"negative": False, "hh": "00", "mm": "00", "name": "+00:00"}

 #ockBuilder.build_timezone.return_value = expectedargs

 #esult = parse_timezone("+00:00", builder=mockBuilder)

 #elf.assertEqual(result, expectedargs)
 #ockBuilder.build_timezone.assert_called_once_with(**expectedargs)

 #ockBuilder = mock.Mock()

 #xpectedargs = {"negative": True, "hh": "01", "mm": "23", "name": "-01:23"}

 #ockBuilder.build_timezone.return_value = expectedargs

 #esult = parse_timezone("-01:23", builder=mockBuilder)

 #elf.assertEqual(result, expectedargs)
 #ockBuilder.build_timezone.assert_called_once_with(**expectedargs)

 #ef test_parse_timezone_negativezero(self):
        # A 0 offset cannot be negative
 #ith self.assertRaises(ISOFormatError):
 #arse_timezone("-00:00", builder=None)

 #ith self.assertRaises(ISOFormatError):
 #arse_timezone("-0000", builder=None)

 #ith self.assertRaises(ISOFormatError):
 #arse_timezone("-00", builder=None)
