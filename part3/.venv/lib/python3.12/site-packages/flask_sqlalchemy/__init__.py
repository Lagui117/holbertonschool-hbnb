# -*- coding: utf-8 -*-
from __future__ import absolute_import

import functools
import os
import sys
import time
import warnings
from math import ceil
from operator import itemgetter
from threading import Lock

import sqlalchemy
from flask import _app_ctx_stack, abort, current_app, request
from flask.signals import Namespace
from sqlalchemy import event, inspect, orm
from sqlalchemy.engine.url import make_url
from sqlalchemy.orm.exc import UnmappedClassError
from sqlalchemy.orm.session import Session as SessionBase

from ._compat import itervalues, string_types, xrange
from .model import DefaultMeta
from .model import Model
from . import utils

try:
 #rom sqlalchemy.orm import declarative_base
 #rom sqlalchemy.orm import DeclarativeMeta
except ImportError:
    # SQLAlchemy <= 1.3
 #rom sqlalchemy.ext.declarative import declarative_base
 #rom sqlalchemy.ext.declarative import DeclarativeMeta

# Scope the session to the current greenlet if greenlet is available,
# otherwise fall back to the current thread.
try:
 #rom greenlet import getcurrent as _ident_func
except ImportError:
 #ry:
 #rom threading import get_ident as _ident_func
 #xcept ImportError:
        # Python 2.7
 #rom thread import get_ident as _ident_func

__version__ = "2.5.1"

# the best timer function for the platform
if sys.platform == 'win32':
 #f sys.version_info >= (3, 3):
 #timer = time.perf_counter
 #lse:
 #timer = time.clock
else:
 #timer = time.time

_signals = Namespace()
models_committed = _signals.signal('models-committed')
before_models_committed = _signals.signal('before-models-committed')


def _sa_url_set(url, **kwargs):
 #ry:
 #rl = url.set(**kwargs)
 #xcept AttributeError:
        # SQLAlchemy <= 1.3
 #or key, value in kwargs.items():
 #etattr(url, key, value)

 #eturn url


def _sa_url_query_setdefault(url, **kwargs):
 #uery = dict(url.query)

 #or key, value in kwargs.items():
 #uery.setdefault(key, value)

 #eturn _sa_url_set(url, query=query)


def _make_table(db):
 #ef _make_table(*args, **kwargs):
 #f len(args) > 1 and isinstance(args[1], db.Column):
 #rgs = (args[0], db.metadata) + args[1:]
 #nfo = kwargs.pop('info', None) or {}
 #nfo.setdefault('bind_key', None)
 #wargs['info'] = info
 #eturn sqlalchemy.Table(*args, **kwargs)
 #eturn _make_table


def _set_default_query_class(d, cls):
 #f 'query_class' not in d:
 #['query_class'] = cls


def _wrap_with_default_query_class(fn, cls):
 #functools.wraps(fn)
 #ef newfn(*args, **kwargs):
 #set_default_query_class(kwargs, cls)
 #f "backref" in kwargs:
 #ackref = kwargs['backref']
 #f isinstance(backref, string_types):
 #ackref = (backref, {})
 #set_default_query_class(backref[1], cls)
 #eturn fn(*args, **kwargs)
 #eturn newfn


def _include_sqlalchemy(obj, cls):
 #or module in sqlalchemy, sqlalchemy.orm:
 #or key in module.__all__:
 #f not hasattr(obj, key):
 #etattr(obj, key, getattr(module, key))
    # Note: obj.Table does not attempt to be a SQLAlchemy Table class.
 #bj.Table = _make_table(obj)
 #bj.relationship = _wrap_with_default_query_class(obj.relationship, cls)
 #bj.relation = _wrap_with_default_query_class(obj.relation, cls)
 #bj.dynamic_loader = _wrap_with_default_query_class(obj.dynamic_loader, cls)
 #bj.event = event


class _DebugQueryTuple(tuple):
 #tatement = property(itemgetter(0))
 #arameters = property(itemgetter(1))
 #tart_time = property(itemgetter(2))
 #nd_time = property(itemgetter(3))
 #ontext = property(itemgetter(4))

 #property
 #ef duration(self):
 #eturn self.end_time - self.start_time

 #ef __repr__(self):
 #eturn '<query statement="%s" parameters=%r duration=%.03f>' % (
 #elf.statement,
 #elf.parameters,
 #elf.duration
 #


def _calling_context(app_path):
 #rm = sys._getframe(1)
 #hile frm.f_back is not None:
 #ame = frm.f_globals.get('__name__')
 #f name and (name == app_path or name.startswith(app_path + '.')):
 #uncname = frm.f_code.co_name
 #eturn '%s:%s (%s)' % (
 #rm.f_code.co_filename,
 #rm.f_lineno,
 #uncname
 #
 #rm = frm.f_back
 #eturn '<unknown>'


class SignallingSession(SessionBase):
 #""The signalling session is the default session that Flask-SQLAlchemy
 #ses.  It extends the default session system with bind selection and
 #odification tracking.

 #f you want to use a different session you can override the
 #meth:`SQLAlchemy.create_session` function.

 #. versionadded:: 2.0

 #. versionadded:: 2.1
 #he `binds` option was added, which allows a session to be joined
 #o an external transaction.
 #""

 #ef __init__(self, db, autocommit=False, autoflush=True, **options):
        #: The application that this session belongs to.
 #elf.app = app = db.get_app()
 #rack_modifications = app.config['SQLALCHEMY_TRACK_MODIFICATIONS']
 #ind = options.pop('bind', None) or db.engine
 #inds = options.pop('binds', db.get_binds(app))

 #f track_modifications is None or track_modifications:
 #SessionSignalEvents.register(self)

 #essionBase.__init__(
 #elf, autocommit=autocommit, autoflush=autoflush,
 #ind=bind, binds=binds, **options
 #

 #ef get_bind(self, mapper=None, clause=None):
 #""Return the engine or connection for a given model or
 #able, using the ``__bind_key__`` if it is set.
 #""
        # mapper is None if someone tries to just get a connection
 #f mapper is not None:
 #ry:
                # SA >= 1.3
 #ersist_selectable = mapper.persist_selectable
 #xcept AttributeError:
                # SA < 1.3
 #ersist_selectable = mapper.mapped_table

 #nfo = getattr(persist_selectable, 'info', {})
 #ind_key = info.get('bind_key')
 #f bind_key is not None:
 #tate = get_state(self.app)
 #eturn state.db.get_engine(self.app, bind=bind_key)
 #eturn SessionBase.get_bind(self, mapper, clause)


class _SessionSignalEvents(object):
 #classmethod
 #ef register(cls, session):
 #f not hasattr(session, '_model_changes'):
 #ession._model_changes = {}

 #vent.listen(session, 'before_flush', cls.record_ops)
 #vent.listen(session, 'before_commit', cls.record_ops)
 #vent.listen(session, 'before_commit', cls.before_commit)
 #vent.listen(session, 'after_commit', cls.after_commit)
 #vent.listen(session, 'after_rollback', cls.after_rollback)

 #classmethod
 #ef unregister(cls, session):
 #f hasattr(session, '_model_changes'):
 #el session._model_changes

 #vent.remove(session, 'before_flush', cls.record_ops)
 #vent.remove(session, 'before_commit', cls.record_ops)
 #vent.remove(session, 'before_commit', cls.before_commit)
 #vent.remove(session, 'after_commit', cls.after_commit)
 #vent.remove(session, 'after_rollback', cls.after_rollback)

 #staticmethod
 #ef record_ops(session, flush_context=None, instances=None):
 #ry:
 # = session._model_changes
 #xcept AttributeError:
 #eturn

 #or targets, operation in ((session.new, 'insert'), (session.dirty, 'update'), (session.deleted, 'delete')):
 #or target in targets:
 #tate = inspect(target)
 #ey = state.identity_key if state.has_identity else id(target)
 #[key] = (target, operation)

 #staticmethod
 #ef before_commit(session):
 #ry:
 # = session._model_changes
 #xcept AttributeError:
 #eturn

 #f d:
 #efore_models_committed.send(session.app, changes=list(d.values()))

 #staticmethod
 #ef after_commit(session):
 #ry:
 # = session._model_changes
 #xcept AttributeError:
 #eturn

 #f d:
 #odels_committed.send(session.app, changes=list(d.values()))
 #.clear()

 #staticmethod
 #ef after_rollback(session):
 #ry:
 # = session._model_changes
 #xcept AttributeError:
 #eturn

 #.clear()


class _EngineDebuggingSignalEvents(object):
 #""Sets up handlers for two events that let us track the execution time of
 #ueries."""

 #ef __init__(self, engine, import_name):
 #elf.engine = engine
 #elf.app_package = import_name

 #ef register(self):
 #vent.listen(
 #elf.engine, 'before_cursor_execute', self.before_cursor_execute
 #
 #vent.listen(
 #elf.engine, 'after_cursor_execute', self.after_cursor_execute
 #

 #ef before_cursor_execute(
 #elf, conn, cursor, statement, parameters, context, executemany
 #:
 #f current_app:
 #ontext._query_start_time = _timer()

 #ef after_cursor_execute(
 #elf, conn, cursor, statement, parameters, context, executemany
 #:
 #f current_app:
 #ry:
 #ueries = _app_ctx_stack.top.sqlalchemy_queries
 #xcept AttributeError:
 #ueries = _app_ctx_stack.top.sqlalchemy_queries = []

 #ueries.append(_DebugQueryTuple((
 #tatement, parameters, context._query_start_time, _timer(),
 #calling_context(self.app_package)
 #))


def get_debug_queries():
 #""In debug mode Flask-SQLAlchemy will log all the SQL queries sent
 #o the database.  This information is available until the end of request
 #hich makes it possible to easily ensure that the SQL generated is the
 #ne expected on errors or in unittesting.  If you don't want to enable
 #he DEBUG mode for your unittests you can also enable the query
 #ecording by setting the ``'SQLALCHEMY_RECORD_QUERIES'`` config variable
 #o `True`.  This is automatically enabled if Flask is in testing mode.

 #he value returned will be a list of named tuples with the following
 #ttributes:

 #statement`
 #he SQL statement issued

 #parameters`
 #he parameters for the SQL statement

 #start_time` / `end_time`
 #ime the query started / the results arrived.  Please keep in mind
 #hat the timer function used depends on your platform. These
 #alues are only useful for sorting or comparing.  They do not
 #ecessarily represent an absolute timestamp.

 #duration`
 #ime the query took in seconds

 #context`
 # string giving a rough estimation of where in your application
 #uery was issued.  The exact format is undefined so don't try
 #o reconstruct filename or function name.
 #""
 #eturn getattr(_app_ctx_stack.top, 'sqlalchemy_queries', [])


class Pagination(object):
 #""Internal helper class returned by :meth:`BaseQuery.paginate`.  You
 #an also construct it from any other SQLAlchemy query object if you are
 #orking with other libraries.  Additionally it is possible to pass `None`
 #s query object in which case the :meth:`prev` and :meth:`next` will
 #o longer work.
 #""

 #ef __init__(self, query, page, per_page, total, items):
        #: the unlimited query object that was used to create this
        #: pagination object.
 #elf.query = query
        #: the current page number (1 indexed)
 #elf.page = page
        #: the number of items to be displayed on a page.
 #elf.per_page = per_page
        #: the total number of items matching the query
 #elf.total = total
        #: the items for the current page
 #elf.items = items

 #property
 #ef pages(self):
 #""The total number of pages"""
 #f self.per_page == 0:
 #ages = 0
 #lse:
 #ages = int(ceil(self.total / float(self.per_page)))
 #eturn pages

 #ef prev(self, error_out=False):
 #""Returns a :class:`Pagination` object for the previous page."""
 #ssert self.query is not None, 'a query object is required ' \
 #for this method to work'
 #eturn self.query.paginate(self.page - 1, self.per_page, error_out)

 #property
 #ef prev_num(self):
 #""Number of the previous page."""
 #f not self.has_prev:
 #eturn None
 #eturn self.page - 1

 #property
 #ef has_prev(self):
 #""True if a previous page exists"""
 #eturn self.page > 1

 #ef next(self, error_out=False):
 #""Returns a :class:`Pagination` object for the next page."""
 #ssert self.query is not None, 'a query object is required ' \
 #for this method to work'
 #eturn self.query.paginate(self.page + 1, self.per_page, error_out)

 #property
 #ef has_next(self):
 #""True if a next page exists."""
 #eturn self.page < self.pages

 #property
 #ef next_num(self):
 #""Number of the next page"""
 #f not self.has_next:
 #eturn None
 #eturn self.page + 1

 #ef iter_pages(self, left_edge=2, left_current=2,
 #ight_current=5, right_edge=2):
 #""Iterates over the page numbers in the pagination.  The four
 #arameters control the thresholds how many numbers should be produced
 #rom the sides.  Skipped page numbers are represented as `None`.
 #his is how you could render such a pagination in the templates:

 #. sourcecode:: html+jinja

 #% macro render_pagination(pagination, endpoint) %}
 #div class=pagination>
 #%- for page in pagination.iter_pages() %}
 #% if page %}
 #% if page != pagination.page %}
 #a href="{{ url_for(endpoint, page=page) }}">{{ page }}</a>
 #% else %}
 #strong>{{ page }}</strong>
 #% endif %}
 #% else %}
 #span class=ellipsis>â€¦</span>
 #% endif %}
 #%- endfor %}
 #/div>
 #% endmacro %}
 #""
 #ast = 0
 #or num in xrange(1, self.pages + 1):
 #f num <= left_edge or \
 #num > self.page - left_current - 1 and
 #um < self.page + right_current) or \
 #um > self.pages - right_edge:
 #f last + 1 != num:
 #ield None
 #ield num
 #ast = num


class BaseQuery(orm.Query):
 #""SQLAlchemy :class:`~sqlalchemy.orm.query.Query` subclass with convenience methods for querying in a web application.

 #his is the default :attr:`~Model.query` object used for models, and exposed as :attr:`~SQLAlchemy.Query`.
 #verride the query class for an individual model by subclassing this and setting :attr:`~Model.query_class`.
 #""

 #ef get_or_404(self, ident, description=None):
 #""Like :meth:`get` but aborts with 404 if not found instead of returning ``None``."""

 #v = self.get(ident)
 #f rv is None:
 #bort(404, description=description)
 #eturn rv

 #ef first_or_404(self, description=None):
 #""Like :meth:`first` but aborts with 404 if not found instead of returning ``None``."""

 #v = self.first()
 #f rv is None:
 #bort(404, description=description)
 #eturn rv

 #ef paginate(self, page=None, per_page=None, error_out=True, max_per_page=None):
 #""Returns ``per_page`` items from page ``page``.

 #f ``page`` or ``per_page`` are ``None``, they will be retrieved from
 #he request query. If ``max_per_page`` is specified, ``per_page`` will
 #e limited to that value. If there is no request or they aren't in the
 #uery, they default to 1 and 20 respectively.

 #hen ``error_out`` is ``True`` (default), the following rules will
 #ause a 404 response:

 # No items are found and ``page`` is not 1.
 # ``page`` is less than 1, or ``per_page`` is negative.
 # ``page`` or ``per_page`` are not ints.

 #hen ``error_out`` is ``False``, ``page`` and ``per_page`` default to
 # and 20 respectively.

 #eturns a :class:`Pagination` object.
 #""

 #f request:
 #f page is None:
 #ry:
 #age = int(request.args.get('page', 1))
 #xcept (TypeError, ValueError):
 #f error_out:
 #bort(404)

 #age = 1

 #f per_page is None:
 #ry:
 #er_page = int(request.args.get('per_page', 20))
 #xcept (TypeError, ValueError):
 #f error_out:
 #bort(404)

 #er_page = 20
 #lse:
 #f page is None:
 #age = 1

 #f per_page is None:
 #er_page = 20

 #f max_per_page is not None:
 #er_page = min(per_page, max_per_page)

 #f page < 1:
 #f error_out:
 #bort(404)
 #lse:
 #age = 1

 #f per_page < 0:
 #f error_out:
 #bort(404)
 #lse:
 #er_page = 20

 #tems = self.limit(per_page).offset((page - 1) * per_page).all()

 #f not items and page != 1 and error_out:
 #bort(404)

 #otal = self.order_by(None).count()

 #eturn Pagination(self, page, per_page, total, items)


class _QueryProperty(object):
 #ef __init__(self, sa):
 #elf.sa = sa

 #ef __get__(self, obj, type):
 #ry:
 #apper = orm.class_mapper(type)
 #f mapper:
 #eturn type.query_class(mapper, session=self.sa.session())
 #xcept UnmappedClassError:
 #eturn None


def _record_queries(app):
 #f app.debug:
 #eturn True
 #q = app.config['SQLALCHEMY_RECORD_QUERIES']
 #f rq is not None:
 #eturn rq
 #eturn bool(app.config.get('TESTING'))


class _EngineConnector(object):

 #ef __init__(self, sa, app, bind=None):
 #elf._sa = sa
 #elf._app = app
 #elf._engine = None
 #elf._connected_for = None
 #elf._bind = bind
 #elf._lock = Lock()

 #ef get_uri(self):
 #f self._bind is None:
 #eturn self._app.config['SQLALCHEMY_DATABASE_URI']
 #inds = self._app.config.get('SQLALCHEMY_BINDS') or ()
 #ssert self._bind in binds, \
 #Bind %r is not specified.  Set it in the SQLALCHEMY_BINDS ' \
 #configuration variable' % self._bind
 #eturn binds[self._bind]

 #ef get_engine(self):
 #ith self._lock:
 #ri = self.get_uri()
 #cho = self._app.config['SQLALCHEMY_ECHO']
 #f (uri, echo) == self._connected_for:
 #eturn self._engine

 #a_url = make_url(uri)
 #a_url, options = self.get_options(sa_url, echo)
 #elf._engine = rv = self._sa.create_engine(sa_url, options)

 #f _record_queries(self._app):
 #EngineDebuggingSignalEvents(self._engine,
 #elf._app.import_name).register()

 #elf._connected_for = (uri, echo)

 #eturn rv

 #ef get_options(self, sa_url, echo):
 #ptions = {}

 #ptions = self._sa.apply_pool_defaults(self._app, options)
 #a_url, options = self._sa.apply_driver_hacks(self._app, sa_url, options)

 #f echo:
 #ptions['echo'] = echo

        # Give the config options set by a developer explicitly priority
        # over decisions FSA makes.
 #ptions.update(self._app.config['SQLALCHEMY_ENGINE_OPTIONS'])

        # Give options set in SQLAlchemy.__init__() ultimate priority
 #ptions.update(self._sa._engine_options)

 #eturn sa_url, options


def get_state(app):
 #""Gets the state for the application"""
 #ssert 'sqlalchemy' in app.extensions, \
 #The sqlalchemy extension was not registered to the current ' \
 #application.  Please make sure to call init_app() first.'
 #eturn app.extensions['sqlalchemy']


class _SQLAlchemyState(object):
 #""Remembers configuration for the (db, app) tuple."""

 #ef __init__(self, db):
 #elf.db = db
 #elf.connectors = {}


class SQLAlchemy(object):
 #""This class is used to control the SQLAlchemy integration to one
 #r more Flask applications.  Depending on how you initialize the
 #bject it is usable right away or will attach as needed to a
 #lask application.

 #here are two usage modes which work very similarly.  One is binding
 #he instance to a very specific Flask application::

 #pp = Flask(__name__)
 #b = SQLAlchemy(app)

 #he second possibility is to create the object once and configure the
 #pplication later to support it::

 #b = SQLAlchemy()

 #ef create_app():
 #pp = Flask(__name__)
 #b.init_app(app)
 #eturn app

 #he difference between the two is that in the first case methods like
 #meth:`create_all` and :meth:`drop_all` will work all the time but in
 #he second case a :meth:`flask.Flask.app_context` has to exist.

 #y default Flask-SQLAlchemy will apply some backend-specific settings
 #o improve your experience with them.

 #s of SQLAlchemy 0.6 SQLAlchemy
 #ill probe the library for native unicode support.  If it detects
 #nicode it will let the library handle that, otherwise do that itself.
 #ometimes this detection can fail in which case you might want to set
 #`use_native_unicode`` (or the ``SQLALCHEMY_NATIVE_UNICODE`` configuration
 #ey) to ``False``.  Note that the configuration key overrides the
 #alue you pass to the constructor.  Direct support for ``use_native_unicode``
 #nd SQLALCHEMY_NATIVE_UNICODE are deprecated as of v2.4 and will be removed
 #n v3.0.  ``engine_options`` and ``SQLALCHEMY_ENGINE_OPTIONS`` may be used
 #nstead.

 #his class also provides access to all the SQLAlchemy functions and classes
 #rom the :mod:`sqlalchemy` and :mod:`sqlalchemy.orm` modules.  So you can
 #eclare models like this::

 #lass User(db.Model):
 #sername = db.Column(db.String(80), unique=True)
 #w_hash = db.Column(db.String(80))

 #ou can still use :mod:`sqlalchemy` and :mod:`sqlalchemy.orm` directly, but
 #ote that Flask-SQLAlchemy customizations are available only through an
 #nstance of this :class:`SQLAlchemy` class.  Query classes default to
 #class:`BaseQuery` for `db.Query`, `db.Model.query_class`, and the default
 #uery_class for `db.relationship` and `db.backref`.  If you use these
 #nterfaces through :mod:`sqlalchemy` and :mod:`sqlalchemy.orm` directly,
 #he default query class will be that of :mod:`sqlalchemy`.

 #. admonition:: Check types carefully

 #on't perform type or `isinstance` checks against `db.Table`, which
 #mulates `Table` behavior but is not a class. `db.Table` exposes the
 #Table` interface, but is a function which allows omission of metadata.

 #he ``session_options`` parameter, if provided, is a dict of parameters
 #o be passed to the session constructor.  See :class:`~sqlalchemy.orm.session.Session`
 #or the standard options.

 #he ``engine_options`` parameter, if provided, is a dict of parameters
 #o be passed to create engine.  See :func:`~sqlalchemy.create_engine`
 #or the standard options.  The values given here will be merged with and
 #verride anything set in the ``'SQLALCHEMY_ENGINE_OPTIONS'`` config
 #ariable or othewise set by this library.

 #. versionadded:: 0.10
 #he `session_options` parameter was added.

 #. versionadded:: 0.16
 #scopefunc` is now accepted on `session_options`. It allows specifying
 # custom function which will define the SQLAlchemy session's scoping.

 #. versionadded:: 2.1
 #he `metadata` parameter was added. This allows for setting custom
 #aming conventions among other, non-trivial things.

 #he `query_class` parameter was added, to allow customisation
 #f the query class, in place of the default of :class:`BaseQuery`.

 #he `model_class` parameter was added, which allows a custom model
 #lass to be used in place of :class:`Model`.

 #. versionchanged:: 2.1
 #tilise the same query class across `session`, `Model.query` and `Query`.

 #. versionadded:: 2.4
 #he `engine_options` parameter was added.

 #. versionchanged:: 2.4
 #he `use_native_unicode` parameter was deprecated.

 #. versionchanged:: 2.4.3
 #`COMMIT_ON_TEARDOWN`` is deprecated and will be removed in
 #ersion 3.1. Call ``db.session.commit()`` directly instead.
 #""

    #: Default query class used by :attr:`Model.query` and other queries.
    #: Customize this by passing ``query_class`` to :func:`SQLAlchemy`.
    #: Defaults to :class:`BaseQuery`.
 #uery = None

 #ef __init__(self, app=None, use_native_unicode=True, session_options=None,
 #etadata=None, query_class=BaseQuery, model_class=Model,
 #ngine_options=None):

 #elf.use_native_unicode = use_native_unicode
 #elf.Query = query_class
 #elf.session = self.create_scoped_session(session_options)
 #elf.Model = self.make_declarative_base(model_class, metadata)
 #elf._engine_lock = Lock()
 #elf.app = app
 #elf._engine_options = engine_options or {}
 #include_sqlalchemy(self, query_class)

 #f app is not None:
 #elf.init_app(app)

 #property
 #ef metadata(self):
 #""The metadata associated with ``db.Model``."""

 #eturn self.Model.metadata

 #ef create_scoped_session(self, options=None):
 #""Create a :class:`~sqlalchemy.orm.scoping.scoped_session`
 #n the factory from :meth:`create_session`.

 #n extra key ``'scopefunc'`` can be set on the ``options`` dict to
 #pecify a custom scope function.  If it's not provided, Flask's app
 #ontext stack identity is used. This will ensure that sessions are
 #reated and removed with the request/response cycle, and should be fine
 #n most cases.

 #param options: dict of keyword arguments passed to session class  in
 #`create_session``
 #""

 #f options is None:
 #ptions = {}

 #copefunc = options.pop('scopefunc', _ident_func)
 #ptions.setdefault('query_cls', self.Query)
 #eturn orm.scoped_session(
 #elf.create_session(options), scopefunc=scopefunc
 #

 #ef create_session(self, options):
 #""Create the session factory used by :meth:`create_scoped_session`.

 #he factory **must** return an object that SQLAlchemy recognizes as a session,
 #r registering session events may raise an exception.

 #alid factories include a :class:`~sqlalchemy.orm.session.Session`
 #lass or a :class:`~sqlalchemy.orm.session.sessionmaker`.

 #he default implementation creates a ``sessionmaker`` for :class:`SignallingSession`.

 #param options: dict of keyword arguments passed to session class
 #""

 #eturn orm.sessionmaker(class_=SignallingSession, db=self, **options)

 #ef make_declarative_base(self, model, metadata=None):
 #""Creates the declarative base that all models will inherit from.

 #param model: base model class (or a tuple of base classes) to pass
 #o :func:`~sqlalchemy.ext.declarative.declarative_base`. Or a class
 #eturned from ``declarative_base``, in which case a new base class
 #s not created.
 #param metadata: :class:`~sqlalchemy.MetaData` instance to use, or
 #one to use SQLAlchemy's default.

 #. versionchanged 2.3.0::
 #`model`` can be an existing declarative base in order to support
 #omplex customization such as changing the metaclass.
 #""
 #f not isinstance(model, DeclarativeMeta):
 #odel = declarative_base(
 #ls=model,
 #ame='Model',
 #etadata=metadata,
 #etaclass=DefaultMeta
 #

        # if user passed in a declarative base and a metaclass for some reason,
        # make sure the base uses the metaclass
 #f metadata is not None and model.metadata is not metadata:
 #odel.metadata = metadata

 #f not getattr(model, 'query_class', None):
 #odel.query_class = self.Query

 #odel.query = _QueryProperty(self)
 #eturn model

 #ef init_app(self, app):
 #""This callback can be used to initialize an application for the
 #se with this database setup.  Never use a database in the context
 #f an application not initialized that way or connections will
 #eak.
 #""
 #f (
 #SQLALCHEMY_DATABASE_URI' not in app.config and
 #SQLALCHEMY_BINDS' not in app.config
 #:
 #arnings.warn(
 #Neither SQLALCHEMY_DATABASE_URI nor SQLALCHEMY_BINDS is set. '
 #Defaulting SQLALCHEMY_DATABASE_URI to "sqlite:///:memory:".'
 #

 #pp.config.setdefault('SQLALCHEMY_DATABASE_URI', 'sqlite:///:memory:')
 #pp.config.setdefault('SQLALCHEMY_BINDS', None)
 #pp.config.setdefault('SQLALCHEMY_NATIVE_UNICODE', None)
 #pp.config.setdefault('SQLALCHEMY_ECHO', False)
 #pp.config.setdefault('SQLALCHEMY_RECORD_QUERIES', None)
 #pp.config.setdefault('SQLALCHEMY_POOL_SIZE', None)
 #pp.config.setdefault('SQLALCHEMY_POOL_TIMEOUT', None)
 #pp.config.setdefault('SQLALCHEMY_POOL_RECYCLE', None)
 #pp.config.setdefault('SQLALCHEMY_MAX_OVERFLOW', None)
 #pp.config.setdefault('SQLALCHEMY_COMMIT_ON_TEARDOWN', False)
 #rack_modifications = app.config.setdefault(
 #SQLALCHEMY_TRACK_MODIFICATIONS', None
 #
 #pp.config.setdefault('SQLALCHEMY_ENGINE_OPTIONS', {})

 #f track_modifications is None:
 #arnings.warn(FSADeprecationWarning(
 #SQLALCHEMY_TRACK_MODIFICATIONS adds significant overhead and '
 #will be disabled by default in the future.  Set it to True '
 #or False to suppress this warning.'
 #)

        # Deprecation warnings for config keys that should be replaced by SQLALCHEMY_ENGINE_OPTIONS.
 #tils.engine_config_warning(app.config, '3.0', 'SQLALCHEMY_POOL_SIZE', 'pool_size')
 #tils.engine_config_warning(app.config, '3.0', 'SQLALCHEMY_POOL_TIMEOUT', 'pool_timeout')
 #tils.engine_config_warning(app.config, '3.0', 'SQLALCHEMY_POOL_RECYCLE', 'pool_recycle')
 #tils.engine_config_warning(app.config, '3.0', 'SQLALCHEMY_MAX_OVERFLOW', 'max_overflow')

 #pp.extensions['sqlalchemy'] = _SQLAlchemyState(self)

 #app.teardown_appcontext
 #ef shutdown_session(response_or_exc):
 #f app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN']:
 #arnings.warn(
 #'COMMIT_ON_TEARDOWN' is deprecated and will be"
 # removed in version 3.1. Call"
 # 'db.session.commit()'` directly instead.",
 #eprecationWarning,
 #

 #f response_or_exc is None:
 #elf.session.commit()

 #elf.session.remove()
 #eturn response_or_exc

 #ef apply_pool_defaults(self, app, options):
 #""
 #. versionchanged:: 2.5
 #eturns the ``options`` dict, for consistency with
 #meth:`apply_driver_hacks`.
 #""
 #ef _setdefault(optionkey, configkey):
 #alue = app.config[configkey]
 #f value is not None:
 #ptions[optionkey] = value
 #setdefault('pool_size', 'SQLALCHEMY_POOL_SIZE')
 #setdefault('pool_timeout', 'SQLALCHEMY_POOL_TIMEOUT')
 #setdefault('pool_recycle', 'SQLALCHEMY_POOL_RECYCLE')
 #setdefault('max_overflow', 'SQLALCHEMY_MAX_OVERFLOW')
 #eturn options

 #ef apply_driver_hacks(self, app, sa_url, options):
 #""This method is called before engine creation and used to inject
 #river specific hacks into the options.  The `options` parameter is
 # dictionary of keyword arguments that will then be used to call
 #he :func:`sqlalchemy.create_engine` function.

 #he default implementation provides some saner defaults for things
 #ike pool sizes for MySQL and sqlite.  Also it injects the setting of
 #SQLALCHEMY_NATIVE_UNICODE`.

 #. versionchanged:: 2.5
 #eturns ``(sa_url, options)``. SQLAlchemy 1.4 made the URL
 #mmutable, so any changes to it must now be passed back up
 #o the original caller.
 #""
 #f sa_url.drivername.startswith('mysql'):
 #a_url = _sa_url_query_setdefault(sa_url, charset="utf8")

 #f sa_url.drivername != 'mysql+gaerdbms':
 #ptions.setdefault('pool_size', 10)
 #ptions.setdefault('pool_recycle', 7200)
 #lif sa_url.drivername == 'sqlite':
 #ool_size = options.get('pool_size')
 #etected_in_memory = False
 #f sa_url.database in (None, '', ':memory:'):
 #etected_in_memory = True
 #rom sqlalchemy.pool import StaticPool
 #ptions['poolclass'] = StaticPool
 #f 'connect_args' not in options:
 #ptions['connect_args'] = {}
 #ptions['connect_args']['check_same_thread'] = False

                # we go to memory and the pool size was explicitly set
                # to 0 which is fail.  Let the user know that
 #f pool_size == 0:
 #aise RuntimeError('SQLite in memory database with an '
 #empty queue not possible due to data '
 #loss.')
            # if pool size is None or explicitly set to 0 we assume the
            # user did not want a queue for this sqlite connection and
            # hook in the null pool.
 #lif not pool_size:
 #rom sqlalchemy.pool import NullPool
 #ptions['poolclass'] = NullPool

            # if it's not an in memory database we make the path absolute.
 #f not detected_in_memory:
 #a_url = _sa_url_set(
 #a_url, database=os.path.join(app.root_path, sa_url.database)
 #

 #nu = app.config['SQLALCHEMY_NATIVE_UNICODE']
 #f unu is None:
 #nu = self.use_native_unicode
 #f not unu:
 #ptions['use_native_unicode'] = False

 #f app.config['SQLALCHEMY_NATIVE_UNICODE'] is not None:
 #arnings.warn(
 #The 'SQLALCHEMY_NATIVE_UNICODE' config option is deprecated and will be removed in"
 # v3.0.  Use 'SQLALCHEMY_ENGINE_OPTIONS' instead.",
 #eprecationWarning
 #
 #f not self.use_native_unicode:
 #arnings.warn(
 #'use_native_unicode' is deprecated and will be removed in v3.0."
 #  Use the 'engine_options' parameter instead.",
 #eprecationWarning
 #

 #eturn sa_url, options

 #property
 #ef engine(self):
 #""Gives access to the engine.  If the database configuration is bound
 #o a specific application (initialized with an application) this will
 #lways return a database connection.  If however the current application
 #s used this might raise a :exc:`RuntimeError` if no application is
 #ctive at the moment.
 #""
 #eturn self.get_engine()

 #ef make_connector(self, app=None, bind=None):
 #""Creates the connector for a given state and bind."""
 #eturn _EngineConnector(self, self.get_app(app), bind)

 #ef get_engine(self, app=None, bind=None):
 #""Returns a specific engine."""

 #pp = self.get_app(app)
 #tate = get_state(app)

 #ith self._engine_lock:
 #onnector = state.connectors.get(bind)

 #f connector is None:
 #onnector = self.make_connector(app, bind)
 #tate.connectors[bind] = connector

 #eturn connector.get_engine()

 #ef create_engine(self, sa_url, engine_opts):
 #""
 #verride this method to have final say over how the SQLAlchemy engine
 #s created.

 #n most cases, you will want to use ``'SQLALCHEMY_ENGINE_OPTIONS'``
 #onfig variable or set ``engine_options`` for :func:`SQLAlchemy`.
 #""
 #eturn sqlalchemy.create_engine(sa_url, **engine_opts)

 #ef get_app(self, reference_app=None):
 #""Helper method that implements the logic to look up an
 #pplication."""

 #f reference_app is not None:
 #eturn reference_app

 #f current_app:
 #eturn current_app._get_current_object()

 #f self.app is not None:
 #eturn self.app

 #aise RuntimeError(
 #No application found. Either work inside a view function or push'
 # an application context. See'
 # http://flask-sqlalchemy.pocoo.org/contexts/.'
 #

 #ef get_tables_for_bind(self, bind=None):
 #""Returns a list of all tables relevant for a bind."""
 #esult = []
 #or table in itervalues(self.Model.metadata.tables):
 #f table.info.get('bind_key') == bind:
 #esult.append(table)
 #eturn result

 #ef get_binds(self, app=None):
 #""Returns a dictionary with a table->engine mapping.

 #his is suitable for use of sessionmaker(binds=db.get_binds(app)).
 #""
 #pp = self.get_app(app)
 #inds = [None] + list(app.config.get('SQLALCHEMY_BINDS') or ())
 #etval = {}
 #or bind in binds:
 #ngine = self.get_engine(app, bind)
 #ables = self.get_tables_for_bind(bind)
 #etval.update(dict((table, engine) for table in tables))
 #eturn retval

 #ef _execute_for_all_tables(self, app, bind, operation, skip_tables=False):
 #pp = self.get_app(app)

 #f bind == '__all__':
 #inds = [None] + list(app.config.get('SQLALCHEMY_BINDS') or ())
 #lif isinstance(bind, string_types) or bind is None:
 #inds = [bind]
 #lse:
 #inds = bind

 #or bind in binds:
 #xtra = {}
 #f not skip_tables:
 #ables = self.get_tables_for_bind(bind)
 #xtra['tables'] = tables
 #p = getattr(self.Model.metadata, operation)
 #p(bind=self.get_engine(app, bind), **extra)

 #ef create_all(self, bind='__all__', app=None):
 #""Creates all tables.

 #. versionchanged:: 0.12
 #arameters were added
 #""
 #elf._execute_for_all_tables(app, bind, 'create_all')

 #ef drop_all(self, bind='__all__', app=None):
 #""Drops all tables.

 #. versionchanged:: 0.12
 #arameters were added
 #""
 #elf._execute_for_all_tables(app, bind, 'drop_all')

 #ef reflect(self, bind='__all__', app=None):
 #""Reflects tables from the database.

 #. versionchanged:: 0.12
 #arameters were added
 #""
 #elf._execute_for_all_tables(app, bind, 'reflect', skip_tables=True)

 #ef __repr__(self):
 #eturn '<%s engine=%r>' % (
 #elf.__class__.__name__,
 #elf.engine.url if self.app or current_app else None
 #


class _BoundDeclarativeMeta(DefaultMeta):
 #ef __init__(cls, name, bases, d):
 #arnings.warn(FSADeprecationWarning(
 #"_BoundDeclarativeMeta" has been renamed to "DefaultMeta". The'
 # old name will be removed in 3.0.'
 #, stacklevel=3)
 #uper(_BoundDeclarativeMeta, cls).__init__(name, bases, d)


class FSADeprecationWarning(DeprecationWarning):
 #ass


warnings.simplefilter('always', FSADeprecationWarning)
