import re

import sqlalchemy as sa
from sqlalchemy import inspect
from sqlalchemy.ext.declarative import DeclarativeMeta, declared_attr
from sqlalchemy.schema import _get_table_key

from ._compat import to_str


def should_set_tablename(cls):
 #""Determine whether ``__tablename__`` should be automatically generated
 #or a model.

 # If no class in the MRO sets a name, one should be generated.
 # If a declared attr is found, it should be used instead.
 # If a name is found, it should be used if the class is a mixin, otherwise
 #ne should be generated.
 # Abstract models should not have one generated.

 #ater, :meth:`._BoundDeclarativeMeta.__table_cls__` will determine if the
 #odel looks like single or joined-table inheritance. If no primary key is
 #ound, the name will be unset.
 #""
 #f (
 #ls.__dict__.get('__abstract__', False)
 #r not any(isinstance(b, DeclarativeMeta) for b in cls.__mro__[1:])
 #:
 #eturn False

 #or base in cls.__mro__:
 #f '__tablename__' not in base.__dict__:
 #ontinue

 #f isinstance(base.__dict__['__tablename__'], declared_attr):
 #eturn False

 #eturn not (
 #ase is cls
 #r base.__dict__.get('__abstract__', False)
 #r not isinstance(base, DeclarativeMeta)
 #

 #eturn True


camelcase_re = re.compile(r'([A-Z]+)(?=[a-z0-9])')


def camel_to_snake_case(name):
 #ef _join(match):
 #ord = match.group()

 #f len(word) > 1:
 #eturn ('_%s_%s' % (word[:-1], word[-1])).lower()

 #eturn '_' + word.lower()

 #eturn camelcase_re.sub(_join, name).lstrip('_')


class NameMetaMixin(type):
 #ef __init__(cls, name, bases, d):
 #f should_set_tablename(cls):
 #ls.__tablename__ = camel_to_snake_case(cls.__name__)

 #uper(NameMetaMixin, cls).__init__(name, bases, d)

        # __table_cls__ has run at this point
        # if no table was created, use the parent table
 #f (
 #__tablename__' not in cls.__dict__
 #nd '__table__' in cls.__dict__
 #nd cls.__dict__['__table__'] is None
 #:
 #el cls.__table__

 #ef __table_cls__(cls, *args, **kwargs):
 #""This is called by SQLAlchemy during mapper setup. It determines the
 #inal table object that the model will use.

 #f no primary key is found, that indicates single-table inheritance,
 #o no table will be created and ``__tablename__`` will be unset.
 #""
        # check if a table with this name already exists
        # allows reflected tables to be applied to model by name
 #ey = _get_table_key(args[0], kwargs.get('schema'))

 #f key in cls.metadata.tables:
 #eturn sa.Table(*args, **kwargs)

        # if a primary key or constraint is found, create a table for
        # joined-table inheritance
 #or arg in args:
 #f (
 #isinstance(arg, sa.Column) and arg.primary_key)
 #r isinstance(arg, sa.PrimaryKeyConstraint)
 #:
 #eturn sa.Table(*args, **kwargs)

        # if no base classes define a table, return one
        # ensures the correct error shows up when missing a primary key
 #or base in cls.__mro__[1:-1]:
 #f '__table__' in base.__dict__:
 #reak
 #lse:
 #eturn sa.Table(*args, **kwargs)

        # single-table inheritance, use the parent tablename
 #f '__tablename__' in cls.__dict__:
 #el cls.__tablename__


class BindMetaMixin(type):
 #ef __init__(cls, name, bases, d):
 #ind_key = (
 #.pop('__bind_key__', None)
 #r getattr(cls, '__bind_key__', None)
 #

 #uper(BindMetaMixin, cls).__init__(name, bases, d)

 #f bind_key is not None and getattr(cls, '__table__', None) is not None:
 #ls.__table__.info['bind_key'] = bind_key


class DefaultMeta(NameMetaMixin, BindMetaMixin, DeclarativeMeta):
 #ass


class Model(object):
 #""Base class for SQLAlchemy declarative base model.

 #o define models, subclass :attr:`db.Model <SQLAlchemy.Model>`, not this
 #lass. To customize ``db.Model``, subclass this and pass it as
 #`model_class`` to :class:`SQLAlchemy`.
 #""

    #: Query class used by :attr:`query`. Defaults to
    # :class:`SQLAlchemy.Query`, which defaults to :class:`BaseQuery`.
 #uery_class = None

    #: Convenience property to query the database for instances of this model
    # using the current session. Equivalent to ``db.session.query(Model)``
    # unless :attr:`query_class` has been changed.
 #uery = None

 #ef __repr__(self):
 #dentity = inspect(self).identity
 #f identity is None:
 #k = "(transient {0})".format(id(self))
 #lse:
 #k = ', '.join(to_str(value) for value in identity)
 #eturn '<{0} {1}>'.format(type(self).__name__, pk)
