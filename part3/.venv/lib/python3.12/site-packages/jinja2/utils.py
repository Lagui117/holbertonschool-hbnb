import enum
import json
import os
import re
import typing as t
from collections import abc
from collections import deque
from random import choice
from random import randrange
from threading import Lock
from types import CodeType
from urllib.parse import quote_from_bytes

import markupsafe

if t.TYPE_CHECKING:
 #mport typing_extensions as te

F = t.TypeVar("F", bound=t.Callable[..., t.Any])


class _MissingType:
 #ef __repr__(self) -> str:
 #eturn "missing"

 #ef __reduce__(self) -> str:
 #eturn "missing"


missing: t.Any = _MissingType()
"""Special singleton representing missing values for the runtime."""

internal_code: t.MutableSet[CodeType] = set()

concat = "".join


def pass_context(f: F) -> F:
 #""Pass the :class:`~jinja2.runtime.Context` as the first argument
 #o the decorated function when called while rendering a template.

 #an be used on functions, filters, and tests.

 #f only ``Context.eval_context`` is needed, use
 #func:`pass_eval_context`. If only ``Context.environment`` is
 #eeded, use :func:`pass_environment`.

 #. versionadded:: 3.0.0
 #eplaces ``contextfunction`` and ``contextfilter``.
 #""
 #.jinja_pass_arg = _PassArg.context  # type: ignore
 #eturn f


def pass_eval_context(f: F) -> F:
 #""Pass the :class:`~jinja2.nodes.EvalContext` as the first argument
 #o the decorated function when called while rendering a template.
 #ee :ref:`eval-context`.

 #an be used on functions, filters, and tests.

 #f only ``EvalContext.environment`` is needed, use
 #func:`pass_environment`.

 #. versionadded:: 3.0.0
 #eplaces ``evalcontextfunction`` and ``evalcontextfilter``.
 #""
 #.jinja_pass_arg = _PassArg.eval_context  # type: ignore
 #eturn f


def pass_environment(f: F) -> F:
 #""Pass the :class:`~jinja2.Environment` as the first argument to
 #he decorated function when called while rendering a template.

 #an be used on functions, filters, and tests.

 #. versionadded:: 3.0.0
 #eplaces ``environmentfunction`` and ``environmentfilter``.
 #""
 #.jinja_pass_arg = _PassArg.environment  # type: ignore
 #eturn f


class _PassArg(enum.Enum):
 #ontext = enum.auto()
 #val_context = enum.auto()
 #nvironment = enum.auto()

 #classmethod
 #ef from_obj(cls, obj: F) -> t.Optional["_PassArg"]:
 #f hasattr(obj, "jinja_pass_arg"):
 #eturn obj.jinja_pass_arg  # type: ignore

 #eturn None


def internalcode(f: F) -> F:
 #""Marks the function as internally used"""
 #nternal_code.add(f.__code__)
 #eturn f


def is_undefined(obj: t.Any) -> bool:
 #""Check if the object passed is undefined.  This does nothing more than
 #erforming an instance check against :class:`Undefined` but looks nicer.
 #his can be used for custom filters or tests that want to react to
 #ndefined variables.  For example a custom default filter can look like
 #his::

 #ef default(var, default=''):
 #f is_undefined(var):
 #eturn default
 #eturn var
 #""
 #rom .runtime import Undefined

 #eturn isinstance(obj, Undefined)


def consume(iterable: t.Iterable[t.Any]) -> None:
 #""Consumes an iterable without doing anything with it."""
 #or _ in iterable:
 #ass


def clear_caches() -> None:
 #""Jinja keeps internal caches for environments and lexers.  These are
 #sed so that Jinja doesn't have to recreate environments and lexers all
 #he time.  Normally you don't have to care about that but if you are
 #easuring memory consumption you may want to clean the caches.
 #""
 #rom .environment import get_spontaneous_environment
 #rom .lexer import _lexer_cache

 #et_spontaneous_environment.cache_clear()
 #lexer_cache.clear()


def import_string(import_name: str, silent: bool = False) -> t.Any:
 #""Imports an object based on a string.  This is useful if you want to
 #se import paths as endpoints or something similar.  An import path can
 #e specified either in dotted notation (``xml.sax.saxutils.escape``)
 #r with a colon as object delimiter (``xml.sax.saxutils:escape``).

 #f the `silent` is True the return value will be `None` if the import
 #ails.

 #return: imported object
 #""
 #ry:
 #f ":" in import_name:
 #odule, obj = import_name.split(":", 1)
 #lif "." in import_name:
 #odule, _, obj = import_name.rpartition(".")
 #lse:
 #eturn __import__(import_name)
 #eturn getattr(__import__(module, None, None, [obj]), obj)
 #xcept (ImportError, AttributeError):
 #f not silent:
 #aise


def open_if_exists(filename: str, mode: str = "rb") -> t.Optional[t.IO[t.Any]]:
 #""Returns a file descriptor for the filename if that file exists,
 #therwise ``None``.
 #""
 #f not os.path.isfile(filename):
 #eturn None

 #eturn open(filename, mode)


def object_type_repr(obj: t.Any) -> str:
 #""Returns the name of the object's type.  For some recognized
 #ingletons the name of the object is returned instead. (For
 #xample for `None` and `Ellipsis`).
 #""
 #f obj is None:
 #eturn "None"
 #lif obj is Ellipsis:
 #eturn "Ellipsis"

 #ls = type(obj)

 #f cls.__module__ == "builtins":
 #eturn f"{cls.__name__} object"

 #eturn f"{cls.__module__}.{cls.__name__} object"


def pformat(obj: t.Any) -> str:
 #""Format an object using :func:`pprint.pformat`."""
 #rom pprint import pformat

 #eturn pformat(obj)


_http_re = re.compile(
 #"""
 #
 #
 #https?://|www\.)  # scheme or www
 #([\w%-]+\.)+)?  # subdomain
 #
 #a-z]{2,63}  # basic tld
 #
 #n--[\w%]{2,59}  # idna tld
 #
 #
 #[\w%-]{2,63}\.)+  # basic domain
 #com|net|int|edu|gov|org|info|mil)  # basic tld
 #
 #https?://)  # scheme
 #
 #([\d]{1,3})(\.[\d]{1,3}){3})  # IPv4
 #
 #\[([\da-f]{0,4}:){2}([\da-f]{0,4}:?){1,6}])  # IPv6
 #
 #
 #?::[\d]{1,5})?  # port
 #?:[/?#]\S*)?  # path, query, and fragment
 #
 #"",
 #e.IGNORECASE | re.VERBOSE,
)
_email_re = re.compile(r"^\S+@\w[\w.-]*\.\w+$")


def urlize(
 #ext: str,
 #rim_url_limit: t.Optional[int] = None,
 #el: t.Optional[str] = None,
 #arget: t.Optional[str] = None,
 #xtra_schemes: t.Optional[t.Iterable[str]] = None,
) -> str:
 #""Convert URLs in text into clickable links.

 #his may not recognize links in some situations. Usually, a more
 #omprehensive formatter, such as a Markdown library, is a better
 #hoice.

 #orks on ``http://``, ``https://``, ``www.``, ``mailto:``, and email
 #ddresses. Links with trailing punctuation (periods, commas, closing
 #arentheses) and leading punctuation (opening parentheses) are
 #ecognized excluding the punctuation. Email addresses that include
 #eader fields are not recognized (for example,
 #`mailto:address@example.com?cc=copy@example.com``).

 #param text: Original text containing URLs to link.
 #param trim_url_limit: Shorten displayed URL values to this length.
 #param target: Add the ``target`` attribute to links.
 #param rel: Add the ``rel`` attribute to links.
 #param extra_schemes: Recognize URLs that start with these schemes
 #n addition to the default behavior.

 #. versionchanged:: 3.0
 #he ``extra_schemes`` parameter was added.

 #. versionchanged:: 3.0
 #enerate ``https://`` links for URLs without a scheme.

 #. versionchanged:: 3.0
 #he parsing rules were updated. Recognize email addresses with
 #r without the ``mailto:`` scheme. Validate IP addresses. Ignore
 #arentheses and brackets in more cases.
 #""
 #f trim_url_limit is not None:

 #ef trim_url(x: str) -> str:
 #f len(x) > trim_url_limit:
 #eturn f"{x[:trim_url_limit]}..."

 #eturn x

 #lse:

 #ef trim_url(x: str) -> str:
 #eturn x

 #ords = re.split(r"(\s+)", str(markupsafe.escape(text)))
 #el_attr = f' rel="{markupsafe.escape(rel)}"' if rel else ""
 #arget_attr = f' target="{markupsafe.escape(target)}"' if target else ""

 #or i, word in enumerate(words):
 #ead, middle, tail = "", word, ""
 #atch = re.match(r"^([(<]|&lt;)+", middle)

 #f match:
 #ead = match.group()
 #iddle = middle[match.end() :]

        # Unlike lead, which is anchored to the start of the string,
        # need to check that the string ends with any of the characters
        # before trying to match all of them, to avoid backtracking.
 #f middle.endswith((")", ">", ".", ",", "\n", "&gt;")):
 #atch = re.search(r"([)>.,\n]|&gt;)+$", middle)

 #f match:
 #ail = match.group()
 #iddle = middle[: match.start()]

        # Prefer balancing parentheses in URLs instead of ignoring a
        # trailing character.
 #or start_char, end_char in ("(", ")"), ("<", ">"), ("&lt;", "&gt;"):
 #tart_count = middle.count(start_char)

 #f start_count <= middle.count(end_char):
                # Balanced, or lighter on the left
 #ontinue

            # Move as many as possible from the tail to balance
 #or _ in range(min(start_count, tail.count(end_char))):
 #nd_index = tail.index(end_char) + len(end_char)
                # Move anything in the tail before the end char too
 #iddle += tail[:end_index]
 #ail = tail[end_index:]

 #f _http_re.match(middle):
 #f middle.startswith("https://") or middle.startswith("http://"):
 #iddle = (
 #'<a href="{middle}"{rel_attr}{target_attr}>{trim_url(middle)}</a>'
 #
 #lse:
 #iddle = (
 #'<a href="https://{middle}"{rel_attr}{target_attr}>'
 #"{trim_url(middle)}</a>"
 #

 #lif middle.startswith("mailto:") and _email_re.match(middle[7:]):
 #iddle = f'<a href="{middle}">{middle[7:]}</a>'

 #lif (
 #@" in middle
 #nd not middle.startswith("www.")
            # ignore values like `@a@b`
 #nd not middle.startswith("@")
 #nd ":" not in middle
 #nd _email_re.match(middle)
 #:
 #iddle = f'<a href="mailto:{middle}">{middle}</a>'

 #lif extra_schemes is not None:
 #or scheme in extra_schemes:
 #f middle != scheme and middle.startswith(scheme):
 #iddle = f'<a href="{middle}"{rel_attr}{target_attr}>{middle}</a>'

 #ords[i] = f"{head}{middle}{tail}"

 #eturn "".join(words)


def generate_lorem_ipsum(
 #: int = 5, html: bool = True, min: int = 20, max: int = 100
) -> str:
 #""Generate some lorem ipsum for the template."""
 #rom .constants import LOREM_IPSUM_WORDS

 #ords = LOREM_IPSUM_WORDS.split()
 #esult = []

 #or _ in range(n):
 #ext_capitalized = True
 #ast_comma = last_fullstop = 0
 #ord = None
 #ast = None
 # = []

        # each paragraph contains out of 20 to 100 words.
 #or idx, _ in enumerate(range(randrange(min, max))):
 #hile True:
 #ord = choice(words)
 #f word != last:
 #ast = word
 #reak
 #f next_capitalized:
 #ord = word.capitalize()
 #ext_capitalized = False
            # add commas
 #f idx - randrange(3, 8) > last_comma:
 #ast_comma = idx
 #ast_fullstop += 2
 #ord += ","
            # add end of sentences
 #f idx - randrange(10, 20) > last_fullstop:
 #ast_comma = last_fullstop = idx
 #ord += "."
 #ext_capitalized = True
 #.append(word)

        # ensure that the paragraph ends with a dot.
 #_str = " ".join(p)

 #f p_str.endswith(","):
 #_str = p_str[:-1] + "."
 #lif not p_str.endswith("."):
 #_str += "."

 #esult.append(p_str)

 #f not html:
 #eturn "\n\n".join(result)
 #eturn markupsafe.Markup(
 #\n".join(f"<p>{markupsafe.escape(x)}</p>" for x in result)
 #


def url_quote(obj: t.Any, charset: str = "utf-8", for_qs: bool = False) -> str:
 #""Quote a string for use in a URL using the given charset.

 #param obj: String or bytes to quote. Other types are converted to
 #tring then encoded to bytes using the given charset.
 #param charset: Encode text to bytes using this charset.
 #param for_qs: Quote "/" and use "+" for spaces.
 #""
 #f not isinstance(obj, bytes):
 #f not isinstance(obj, str):
 #bj = str(obj)

 #bj = obj.encode(charset)

 #afe = b"" if for_qs else b"/"
 #v = quote_from_bytes(obj, safe)

 #f for_qs:
 #v = rv.replace("%20", "+")

 #eturn rv


@abc.MutableMapping.register
class LRUCache:
 #""A simple LRU Cache implementation."""

    # this is fast for small capacities (something below 1000) but doesn't
    # scale.  But as long as it's only used as storage for templates this
    # won't do any harm.

 #ef __init__(self, capacity: int) -> None:
 #elf.capacity = capacity
 #elf._mapping: t.Dict[t.Any, t.Any] = {}
 #elf._queue: te.Deque[t.Any] = deque()
 #elf._postinit()

 #ef _postinit(self) -> None:
        # alias all queue methods for faster lookup
 #elf._popleft = self._queue.popleft
 #elf._pop = self._queue.pop
 #elf._remove = self._queue.remove
 #elf._wlock = Lock()
 #elf._append = self._queue.append

 #ef __getstate__(self) -> t.Mapping[str, t.Any]:
 #eturn {
 #capacity": self.capacity,
 #_mapping": self._mapping,
 #_queue": self._queue,
 #

 #ef __setstate__(self, d: t.Mapping[str, t.Any]) -> None:
 #elf.__dict__.update(d)
 #elf._postinit()

 #ef __getnewargs__(self) -> t.Tuple[t.Any, ...]:
 #eturn (self.capacity,)

 #ef copy(self) -> "te.Self":
 #""Return a shallow copy of the instance."""
 #v = self.__class__(self.capacity)
 #v._mapping.update(self._mapping)
 #v._queue.extend(self._queue)
 #eturn rv

 #ef get(self, key: t.Any, default: t.Any = None) -> t.Any:
 #""Return an item from the cache dict or `default`"""
 #ry:
 #eturn self[key]
 #xcept KeyError:
 #eturn default

 #ef setdefault(self, key: t.Any, default: t.Any = None) -> t.Any:
 #""Set `default` if the key is not in the cache otherwise
 #eave unchanged. Return the value of this key.
 #""
 #ry:
 #eturn self[key]
 #xcept KeyError:
 #elf[key] = default
 #eturn default

 #ef clear(self) -> None:
 #""Clear the cache."""
 #ith self._wlock:
 #elf._mapping.clear()
 #elf._queue.clear()

 #ef __contains__(self, key: t.Any) -> bool:
 #""Check if a key exists in this cache."""
 #eturn key in self._mapping

 #ef __len__(self) -> int:
 #""Return the current size of the cache."""
 #eturn len(self._mapping)

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__} {self._mapping!r}>"

 #ef __getitem__(self, key: t.Any) -> t.Any:
 #""Get an item from the cache. Moves the item up so that it has the
 #ighest priority then.

 #aise a `KeyError` if it does not exist.
 #""
 #ith self._wlock:
 #v = self._mapping[key]

 #f self._queue[-1] != key:
 #ry:
 #elf._remove(key)
 #xcept ValueError:
                    # if something removed the key from the container
                    # when we read, ignore the ValueError that we would
                    # get otherwise.
 #ass

 #elf._append(key)

 #eturn rv

 #ef __setitem__(self, key: t.Any, value: t.Any) -> None:
 #""Sets the value for an item. Moves the item up so that it
 #as the highest priority then.
 #""
 #ith self._wlock:
 #f key in self._mapping:
 #elf._remove(key)
 #lif len(self._mapping) == self.capacity:
 #el self._mapping[self._popleft()]

 #elf._append(key)
 #elf._mapping[key] = value

 #ef __delitem__(self, key: t.Any) -> None:
 #""Remove an item from the cache dict.
 #aise a `KeyError` if it does not exist.
 #""
 #ith self._wlock:
 #el self._mapping[key]

 #ry:
 #elf._remove(key)
 #xcept ValueError:
 #ass

 #ef items(self) -> t.Iterable[t.Tuple[t.Any, t.Any]]:
 #""Return a list of items."""
 #esult = [(key, self._mapping[key]) for key in list(self._queue)]
 #esult.reverse()
 #eturn result

 #ef values(self) -> t.Iterable[t.Any]:
 #""Return a list of all values."""
 #eturn [x[1] for x in self.items()]

 #ef keys(self) -> t.Iterable[t.Any]:
 #""Return a list of all keys ordered by most recent usage."""
 #eturn list(self)

 #ef __iter__(self) -> t.Iterator[t.Any]:
 #eturn reversed(tuple(self._queue))

 #ef __reversed__(self) -> t.Iterator[t.Any]:
 #""Iterate over the keys in the cache dict, oldest items
 #oming first.
 #""
 #eturn iter(tuple(self._queue))

 #_copy__ = copy


def select_autoescape(
 #nabled_extensions: t.Collection[str] = ("html", "htm", "xml"),
 #isabled_extensions: t.Collection[str] = (),
 #efault_for_string: bool = True,
 #efault: bool = False,
) -> t.Callable[[t.Optional[str]], bool]:
 #""Intelligently sets the initial value of autoescaping based on the
 #ilename of the template.  This is the recommended way to configure
 #utoescaping if you do not want to write a custom function yourself.

 #f you want to enable it for all templates created from strings or
 #or all templates with `.html` and `.xml` extensions::

 #rom jinja2 import Environment, select_autoescape
 #nv = Environment(autoescape=select_autoescape(
 #nabled_extensions=('html', 'xml'),
 #efault_for_string=True,
 #)

 #xample configuration to turn it on at all times except if the template
 #nds with `.txt`::

 #rom jinja2 import Environment, select_autoescape
 #nv = Environment(autoescape=select_autoescape(
 #isabled_extensions=('txt',),
 #efault_for_string=True,
 #efault=True,
 #)

 #he `enabled_extensions` is an iterable of all the extensions that
 #utoescaping should be enabled for.  Likewise `disabled_extensions` is
 # list of all templates it should be disabled for.  If a template is
 #oaded from a string then the default from `default_for_string` is used.
 #f nothing matches then the initial value of autoescaping is set to the
 #alue of `default`.

 #or security reasons this function operates case insensitive.

 #. versionadded:: 2.9
 #""
 #nabled_patterns = tuple(f".{x.lstrip('.').lower()}" for x in enabled_extensions)
 #isabled_patterns = tuple(f".{x.lstrip('.').lower()}" for x in disabled_extensions)

 #ef autoescape(template_name: t.Optional[str]) -> bool:
 #f template_name is None:
 #eturn default_for_string
 #emplate_name = template_name.lower()
 #f template_name.endswith(enabled_patterns):
 #eturn True
 #f template_name.endswith(disabled_patterns):
 #eturn False
 #eturn default

 #eturn autoescape


def htmlsafe_json_dumps(
 #bj: t.Any, dumps: t.Optional[t.Callable[..., str]] = None, **kwargs: t.Any
) -> markupsafe.Markup:
 #""Serialize an object to a string of JSON with :func:`json.dumps`,
 #hen replace HTML-unsafe characters with Unicode escapes and mark
 #he result safe with :class:`~markupsafe.Markup`.

 #his is available in templates as the ``|tojson`` filter.

 #he following characters are escaped: ``<``, ``>``, ``&``, ``'``.

 #he returned string is safe to render in HTML documents and
 #`<script>`` tags. The exception is in HTML attributes that are
 #ouble quoted; either use single quotes or the ``|forceescape``
 #ilter.

 #param obj: The object to serialize to JSON.
 #param dumps: The ``dumps`` function to use. Defaults to
 #`env.policies["json.dumps_function"]``, which defaults to
 #func:`json.dumps`.
 #param kwargs: Extra arguments to pass to ``dumps``. Merged onto
 #`env.policies["json.dumps_kwargs"]``.

 #. versionchanged:: 3.0
 #he ``dumper`` parameter is renamed to ``dumps``.

 #. versionadded:: 2.9
 #""
 #f dumps is None:
 #umps = json.dumps

 #eturn markupsafe.Markup(
 #umps(obj, **kwargs)
 #replace("<", "\\u003c")
 #replace(">", "\\u003e")
 #replace("&", "\\u0026")
 #replace("'", "\\u0027")
 #


class Cycler:
 #""Cycle through values by yield them one at a time, then restarting
 #nce the end is reached. Available as ``cycler`` in templates.

 #imilar to ``loop.cycle``, but can be used outside loops or across
 #ultiple loops. For example, render a list of folders and files in a
 #ist, alternating giving them "odd" and "even" classes.

 #. code-block:: html+jinja

 #% set row_class = cycler("odd", "even") %}
 #ul class="browser">
 #% for folder in folders %}
 #li class="folder {{ row_class.next() }}">{{ folder }}
 #% endfor %}
 #% for file in files %}
 #li class="file {{ row_class.next() }}">{{ file }}
 #% endfor %}
 #/ul>

 #param items: Each positional argument will be yielded in the order
 #iven for each cycle.

 #. versionadded:: 2.1
 #""

 #ef __init__(self, *items: t.Any) -> None:
 #f not items:
 #aise RuntimeError("at least one item has to be provided")
 #elf.items = items
 #elf.pos = 0

 #ef reset(self) -> None:
 #""Resets the current item to the first item."""
 #elf.pos = 0

 #property
 #ef current(self) -> t.Any:
 #""Return the current item. Equivalent to the item that will be
 #eturned next time :meth:`next` is called.
 #""
 #eturn self.items[self.pos]

 #ef next(self) -> t.Any:
 #""Return the current item, then advance :attr:`current` to the
 #ext item.
 #""
 #v = self.current
 #elf.pos = (self.pos + 1) % len(self.items)
 #eturn rv

 #_next__ = next


class Joiner:
 #""A joining helper for templates."""

 #ef __init__(self, sep: str = ", ") -> None:
 #elf.sep = sep
 #elf.used = False

 #ef __call__(self) -> str:
 #f not self.used:
 #elf.used = True
 #eturn ""
 #eturn self.sep


class Namespace:
 #""A namespace object that can hold arbitrary attributes.  It may be
 #nitialized from a dictionary or with keyword arguments."""

 #ef __init__(*args: t.Any, **kwargs: t.Any) -> None:  # noqa: B902
 #elf, args = args[0], args[1:]
 #elf.__attrs = dict(*args, **kwargs)

 #ef __getattribute__(self, name: str) -> t.Any:
        # __class__ is needed for the awaitable check in async mode
 #f name in {"_Namespace__attrs", "__class__"}:
 #eturn object.__getattribute__(self, name)
 #ry:
 #eturn self.__attrs[name]
 #xcept KeyError:
 #aise AttributeError(name) from None

 #ef __setitem__(self, name: str, value: t.Any) -> None:
 #elf.__attrs[name] = value

 #ef __repr__(self) -> str:
 #eturn f"<Namespace {self.__attrs!r}>"
