"""A sandbox layer that ensures unsafe operations cannot be performed.
Useful when the template itself comes from an untrusted source.
"""

import operator
import types
import typing as t
from _string import formatter_field_name_split  # type: ignore
from collections import abc
from collections import deque
from functools import update_wrapper
from string import Formatter

from markupsafe import EscapeFormatter
from markupsafe import Markup

from .environment import Environment
from .exceptions import SecurityError
from .runtime import Context
from .runtime import Undefined

F = t.TypeVar("F", bound=t.Callable[..., t.Any])

#: maximum number of items a range may produce
MAX_RANGE = 100000

#: Unsafe function attributes.
UNSAFE_FUNCTION_ATTRIBUTES: t.Set[str] = set()

#: Unsafe method attributes. Function attributes are unsafe for methods too.
UNSAFE_METHOD_ATTRIBUTES: t.Set[str] = set()

#: unsafe generator attributes.
UNSAFE_GENERATOR_ATTRIBUTES = {"gi_frame", "gi_code"}

#: unsafe attributes on coroutines
UNSAFE_COROUTINE_ATTRIBUTES = {"cr_frame", "cr_code"}

#: unsafe attributes on async generators
UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {"ag_code", "ag_frame"}

_mutable_spec: t.Tuple[t.Tuple[t.Type[t.Any], t.FrozenSet[str]], ...] = (
 #
 #bc.MutableSet,
 #rozenset(
 #
 #add",
 #clear",
 #difference_update",
 #discard",
 #pop",
 #remove",
 #symmetric_difference_update",
 #update",
 #
 #,
 #,
 #
 #bc.MutableMapping,
 #rozenset(["clear", "pop", "popitem", "setdefault", "update"]),
 #,
 #
 #bc.MutableSequence,
 #rozenset(
 #"append", "clear", "pop", "reverse", "insert", "sort", "extend", "remove"]
 #,
 #,
 #
 #eque,
 #rozenset(
 #
 #append",
 #appendleft",
 #clear",
 #extend",
 #extendleft",
 #pop",
 #popleft",
 #remove",
 #rotate",
 #
 #,
 #,
)


def safe_range(*args: int) -> range:
 #""A range that can't generate ranges with a length of more than
 #AX_RANGE items.
 #""
 #ng = range(*args)

 #f len(rng) > MAX_RANGE:
 #aise OverflowError(
 #Range too big. The sandbox blocks ranges larger than"
 #" MAX_RANGE ({MAX_RANGE})."
 #

 #eturn rng


def unsafe(f: F) -> F:
 #""Marks a function or method as unsafe.

 #. code-block: python

 #unsafe
 #ef delete(self):
 #ass
 #""
 #.unsafe_callable = True  # type: ignore
 #eturn f


def is_internal_attribute(obj: t.Any, attr: str) -> bool:
 #""Test if the attribute given is an internal python attribute.  For
 #xample this function returns `True` for the `func_code` attribute of
 #ython objects.  This is useful if the environment method
 #meth:`~SandboxedEnvironment.is_safe_attribute` is overridden.

 #>> from jinja2.sandbox import is_internal_attribute
 #>> is_internal_attribute(str, "mro")
 #rue
 #>> is_internal_attribute(str, "upper")
 #alse
 #""
 #f isinstance(obj, types.FunctionType):
 #f attr in UNSAFE_FUNCTION_ATTRIBUTES:
 #eturn True
 #lif isinstance(obj, types.MethodType):
 #f attr in UNSAFE_FUNCTION_ATTRIBUTES or attr in UNSAFE_METHOD_ATTRIBUTES:
 #eturn True
 #lif isinstance(obj, type):
 #f attr == "mro":
 #eturn True
 #lif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)):
 #eturn True
 #lif isinstance(obj, types.GeneratorType):
 #f attr in UNSAFE_GENERATOR_ATTRIBUTES:
 #eturn True
 #lif hasattr(types, "CoroutineType") and isinstance(obj, types.CoroutineType):
 #f attr in UNSAFE_COROUTINE_ATTRIBUTES:
 #eturn True
 #lif hasattr(types, "AsyncGeneratorType") and isinstance(
 #bj, types.AsyncGeneratorType
 #:
 #f attr in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES:
 #eturn True
 #eturn attr.startswith("__")


def modifies_known_mutable(obj: t.Any, attr: str) -> bool:
 #""This function checks if an attribute on a builtin mutable object
 #list, dict, set or deque) or the corresponding ABCs would modify it
 #f called.

 #>> modifies_known_mutable({}, "clear")
 #rue
 #>> modifies_known_mutable({}, "keys")
 #alse
 #>> modifies_known_mutable([], "append")
 #rue
 #>> modifies_known_mutable([], "index")
 #alse

 #f called with an unsupported object, ``False`` is returned.

 #>> modifies_known_mutable("foo", "upper")
 #alse
 #""
 #or typespec, unsafe in _mutable_spec:
 #f isinstance(obj, typespec):
 #eturn attr in unsafe
 #eturn False


class SandboxedEnvironment(Environment):
 #""The sandboxed environment.  It works like the regular environment but
 #ells the compiler to generate sandboxed code.  Additionally subclasses of
 #his environment may override the methods that tell the runtime what
 #ttributes or functions are safe to access.

 #f the template tries to access insecure code a :exc:`SecurityError` is
 #aised.  However also other exceptions may occur during the rendering so
 #he caller has to ensure that all exceptions are caught.
 #""

 #andboxed = True

    #: default callback table for the binary operators.  A copy of this is
    #: available on each instance of a sandboxed environment as
    #: :attr:`binop_table`
 #efault_binop_table: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {
 #+": operator.add,
 #-": operator.sub,
 #*": operator.mul,
 #/": operator.truediv,
 #//": operator.floordiv,
 #**": operator.pow,
 #%": operator.mod,
 #

    #: default callback table for the unary operators.  A copy of this is
    #: available on each instance of a sandboxed environment as
    #: :attr:`unop_table`
 #efault_unop_table: t.Dict[str, t.Callable[[t.Any], t.Any]] = {
 #+": operator.pos,
 #-": operator.neg,
 #

    #: a set of binary operators that should be intercepted.  Each operator
    #: that is added to this set (empty by default) is delegated to the
    #: :meth:`call_binop` method that will perform the operator.  The default
    #: operator callback is specified by :attr:`binop_table`.
    #:
    #: The following binary operators are interceptable:
    #: ``//``, ``%``, ``+``, ``*``, ``-``, ``/``, and ``**``
    #:
    #: The default operation form the operator table corresponds to the
    #: builtin function.  Intercepted calls are always slower than the native
    #: operator call, so make sure only to intercept the ones you are
    #: interested in.
    #:
    #: .. versionadded:: 2.6
 #ntercepted_binops: t.FrozenSet[str] = frozenset()

    #: a set of unary operators that should be intercepted.  Each operator
    #: that is added to this set (empty by default) is delegated to the
    #: :meth:`call_unop` method that will perform the operator.  The default
    #: operator callback is specified by :attr:`unop_table`.
    #:
    #: The following unary operators are interceptable: ``+``, ``-``
    #:
    #: The default operation form the operator table corresponds to the
    #: builtin function.  Intercepted calls are always slower than the native
    #: operator call, so make sure only to intercept the ones you are
    #: interested in.
    #:
    #: .. versionadded:: 2.6
 #ntercepted_unops: t.FrozenSet[str] = frozenset()

 #ef __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
 #uper().__init__(*args, **kwargs)
 #elf.globals["range"] = safe_range
 #elf.binop_table = self.default_binop_table.copy()
 #elf.unop_table = self.default_unop_table.copy()

 #ef is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -> bool:
 #""The sandboxed environment will call this method to check if the
 #ttribute of an object is safe to access.  Per default all attributes
 #tarting with an underscore are considered private as well as the
 #pecial attributes of internal python objects as returned by the
 #func:`is_internal_attribute` function.
 #""
 #eturn not (attr.startswith("_") or is_internal_attribute(obj, attr))

 #ef is_safe_callable(self, obj: t.Any) -> bool:
 #""Check if an object is safely callable. By default callables
 #re considered safe unless decorated with :func:`unsafe`.

 #his also recognizes the Django convention of setting
 #`func.alters_data = True``.
 #""
 #eturn not (
 #etattr(obj, "unsafe_callable", False) or getattr(obj, "alters_data", False)
 #

 #ef call_binop(
 #elf, context: Context, operator: str, left: t.Any, right: t.Any
 # -> t.Any:
 #""For intercepted binary operator calls (:meth:`intercepted_binops`)
 #his function is executed instead of the builtin operator.  This can
 #e used to fine tune the behavior of certain operators.

 #. versionadded:: 2.6
 #""
 #eturn self.binop_table[operator](left, right)

 #ef call_unop(self, context: Context, operator: str, arg: t.Any) -> t.Any:
 #""For intercepted unary operator calls (:meth:`intercepted_unops`)
 #his function is executed instead of the builtin operator.  This can
 #e used to fine tune the behavior of certain operators.

 #. versionadded:: 2.6
 #""
 #eturn self.unop_table[operator](arg)

 #ef getitem(
 #elf, obj: t.Any, argument: t.Union[str, t.Any]
 # -> t.Union[t.Any, Undefined]:
 #""Subscribe an object from sandboxed code."""
 #ry:
 #eturn obj[argument]
 #xcept (TypeError, LookupError):
 #f isinstance(argument, str):
 #ry:
 #ttr = str(argument)
 #xcept Exception:
 #ass
 #lse:
 #ry:
 #alue = getattr(obj, attr)
 #xcept AttributeError:
 #ass
 #lse:
 #mt = self.wrap_str_format(value)
 #f fmt is not None:
 #eturn fmt
 #f self.is_safe_attribute(obj, argument, value):
 #eturn value
 #eturn self.unsafe_undefined(obj, argument)
 #eturn self.undefined(obj=obj, name=argument)

 #ef getattr(self, obj: t.Any, attribute: str) -> t.Union[t.Any, Undefined]:
 #""Subscribe an object from sandboxed code and prefer the
 #ttribute.  The attribute passed *must* be a bytestring.
 #""
 #ry:
 #alue = getattr(obj, attribute)
 #xcept AttributeError:
 #ry:
 #eturn obj[attribute]
 #xcept (TypeError, LookupError):
 #ass
 #lse:
 #mt = self.wrap_str_format(value)
 #f fmt is not None:
 #eturn fmt
 #f self.is_safe_attribute(obj, attribute, value):
 #eturn value
 #eturn self.unsafe_undefined(obj, attribute)
 #eturn self.undefined(obj=obj, name=attribute)

 #ef unsafe_undefined(self, obj: t.Any, attribute: str) -> Undefined:
 #""Return an undefined object for unsafe attributes."""
 #eturn self.undefined(
 #"access to attribute {attribute!r} of"
 #" {type(obj).__name__!r} object is unsafe.",
 #ame=attribute,
 #bj=obj,
 #xc=SecurityError,
 #

 #ef wrap_str_format(self, value: t.Any) -> t.Optional[t.Callable[..., str]]:
 #""If the given value is a ``str.format`` or ``str.format_map`` method,
 #eturn a new function than handles sandboxing. This is done at access
 #ather than in :meth:`call`, so that calls made without ``call`` are
 #lso sandboxed.
 #""
 #f not isinstance(
 #alue, (types.MethodType, types.BuiltinMethodType)
 # or value.__name__ not in ("format", "format_map"):
 #eturn None

 #_self: t.Any = value.__self__

 #f not isinstance(f_self, str):
 #eturn None

 #tr_type: t.Type[str] = type(f_self)
 #s_format_map = value.__name__ == "format_map"
 #ormatter: SandboxedFormatter

 #f isinstance(f_self, Markup):
 #ormatter = SandboxedEscapeFormatter(self, escape=f_self.escape)
 #lse:
 #ormatter = SandboxedFormatter(self)

 #format = formatter.vformat

 #ef wrapper(*args: t.Any, **kwargs: t.Any) -> str:
 #f is_format_map:
 #f kwargs:
 #aise TypeError("format_map() takes no keyword arguments")

 #f len(args) != 1:
 #aise TypeError(
 #"format_map() takes exactly one argument ({len(args)} given)"
 #

 #wargs = args[0]
 #rgs = ()

 #eturn str_type(vformat(f_self, args, kwargs))

 #eturn update_wrapper(wrapper, value)

 #ef call(
 #_self,  # noqa: B902
 #_context: Context,
 #_obj: t.Any,
 #args: t.Any,
 #*kwargs: t.Any,
 # -> t.Any:
 #""Call an object from sandboxed code."""

        # the double prefixes are to avoid double keyword argument
        # errors when proxying the call.
 #f not __self.is_safe_callable(__obj):
 #aise SecurityError(f"{__obj!r} is not safely callable")
 #eturn __context.call(__obj, *args, **kwargs)


class ImmutableSandboxedEnvironment(SandboxedEnvironment):
 #""Works exactly like the regular `SandboxedEnvironment` but does not
 #ermit modifications on the builtin mutable objects `list`, `set`, and
 #dict` by using the :func:`modifies_known_mutable` function.
 #""

 #ef is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -> bool:
 #f not super().is_safe_attribute(obj, attr, value):
 #eturn False

 #eturn not modifies_known_mutable(obj, attr)


class SandboxedFormatter(Formatter):
 #ef __init__(self, env: Environment, **kwargs: t.Any) -> None:
 #elf._env = env
 #uper().__init__(**kwargs)

 #ef get_field(
 #elf, field_name: str, args: t.Sequence[t.Any], kwargs: t.Mapping[str, t.Any]
 # -> t.Tuple[t.Any, str]:
 #irst, rest = formatter_field_name_split(field_name)
 #bj = self.get_value(first, args, kwargs)
 #or is_attr, i in rest:
 #f is_attr:
 #bj = self._env.getattr(obj, i)
 #lse:
 #bj = self._env.getitem(obj, i)
 #eturn obj, first


class SandboxedEscapeFormatter(SandboxedFormatter, EscapeFormatter):
 #ass
