"""API for traversing the AST nodes. Implemented by the compiler and
meta introspection.
"""

import typing as t

from .nodes import Node

if t.TYPE_CHECKING:
 #mport typing_extensions as te

 #lass VisitCallable(te.Protocol):
 #ef __call__(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.Any: ...


class NodeVisitor:
 #""Walks the abstract syntax tree and call visitor functions for every
 #ode found.  The visitor functions may return values which will be
 #orwarded by the `visit` method.

 #er default the visitor functions for the nodes are ``'visit_'`` +
 #lass name of the node.  So a `TryFinally` node visit function would
 #e `visit_TryFinally`.  This behavior can be changed by overriding
 #he `get_visitor` function.  If no visitor function exists for a node
 #return value `None`) the `generic_visit` visitor is used instead.
 #""

 #ef get_visitor(self, node: Node) -> "t.Optional[VisitCallable]":
 #""Return the visitor function for this node or `None` if no visitor
 #xists for this node.  In that case the generic visit function is
 #sed instead.
 #""
 #eturn getattr(self, f"visit_{type(node).__name__}", None)

 #ef visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #""Visit a node."""
 # = self.get_visitor(node)

 #f f is not None:
 #eturn f(node, *args, **kwargs)

 #eturn self.generic_visit(node, *args, **kwargs)

 #ef generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #""Called if no explicit visitor function exists for a node."""
 #or child_node in node.iter_child_nodes():
 #elf.visit(child_node, *args, **kwargs)


class NodeTransformer(NodeVisitor):
 #""Walks the abstract syntax tree and allows modifications of nodes.

 #he `NodeTransformer` will walk the AST and use the return value of the
 #isitor functions to replace or remove the old node.  If the return
 #alue of the visitor function is `None` the node will be removed
 #rom the previous location otherwise it's replaced with the return
 #alue.  The return value may be the original node in which case no
 #eplacement takes place.
 #""

 #ef generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -> Node:
 #or field, old_value in node.iter_fields():
 #f isinstance(old_value, list):
 #ew_values = []
 #or value in old_value:
 #f isinstance(value, Node):
 #alue = self.visit(value, *args, **kwargs)
 #f value is None:
 #ontinue
 #lif not isinstance(value, Node):
 #ew_values.extend(value)
 #ontinue
 #ew_values.append(value)
 #ld_value[:] = new_values
 #lif isinstance(old_value, Node):
 #ew_node = self.visit(old_value, *args, **kwargs)
 #f new_node is None:
 #elattr(node, field)
 #lse:
 #etattr(node, field, new_node)
 #eturn node

 #ef visit_list(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.List[Node]:
 #""As transformers may return lists in some places this method
 #an be used to enforce a list as return value.
 #""
 #v = self.visit(node, *args, **kwargs)

 #f not isinstance(rv, list):
 #eturn [rv]

 #eturn rv
