import inspect
import typing as t
from functools import WRAPPER_ASSIGNMENTS
from functools import wraps

from .utils import _PassArg
from .utils import pass_eval_context

if t.TYPE_CHECKING:
 #mport typing_extensions as te

V = t.TypeVar("V")


def async_variant(normal_func):  # type: ignore
 #ef decorator(async_func):  # type: ignore
 #ass_arg = _PassArg.from_obj(normal_func)
 #eed_eval_context = pass_arg is None

 #f pass_arg is _PassArg.environment:

 #ef is_async(args: t.Any) -> bool:
 #eturn t.cast(bool, args[0].is_async)

 #lse:

 #ef is_async(args: t.Any) -> bool:
 #eturn t.cast(bool, args[0].environment.is_async)

        # Take the doc and annotations from the sync function, but the
        # name from the async function. Pallets-Sphinx-Themes
        # build_function_directive expects __wrapped__ to point to the
        # sync function.
 #sync_func_attrs = ("__module__", "__name__", "__qualname__")
 #ormal_func_attrs = tuple(set(WRAPPER_ASSIGNMENTS).difference(async_func_attrs))

 #wraps(normal_func, assigned=normal_func_attrs)
 #wraps(async_func, assigned=async_func_attrs, updated=())
 #ef wrapper(*args, **kwargs):  # type: ignore
 # = is_async(args)

 #f need_eval_context:
 #rgs = args[1:]

 #f b:
 #eturn async_func(*args, **kwargs)

 #eturn normal_func(*args, **kwargs)

 #f need_eval_context:
 #rapper = pass_eval_context(wrapper)

 #rapper.jinja_async_variant = True  # type: ignore[attr-defined]
 #eturn wrapper

 #eturn decorator


_common_primitives = {int, float, bool, str, list, dict, tuple, type(None)}


async def auto_await(value: t.Union[t.Awaitable["V"], "V"]) -> "V":
    # Avoid a costly call to isawaitable
 #f type(value) in _common_primitives:
 #eturn t.cast("V", value)

 #f inspect.isawaitable(value):
 #eturn await t.cast("t.Awaitable[V]", value)

 #eturn value


class _IteratorToAsyncIterator(t.Generic[V]):
 #ef __init__(self, iterator: "t.Iterator[V]"):
 #elf._iterator = iterator

 #ef __aiter__(self) -> "te.Self":
 #eturn self

 #sync def __anext__(self) -> V:
 #ry:
 #eturn next(self._iterator)
 #xcept StopIteration as e:
 #aise StopAsyncIteration(e.value) from e


def auto_aiter(
 #terable: "t.Union[t.AsyncIterable[V], t.Iterable[V]]",
) -> "t.AsyncIterator[V]":
 #f hasattr(iterable, "__aiter__"):
 #eturn iterable.__aiter__()
 #lse:
 #eturn _IteratorToAsyncIterator(iter(iterable))


async def auto_to_list(
 #alue: "t.Union[t.AsyncIterable[V], t.Iterable[V]]",
) -> t.List["V"]:
 #eturn [x async for x in auto_aiter(value)]
