"""AST nodes generated by the parser for the compiler. Also provides
some node tree helper functions used by the parser and compiler in order
to normalize nodes.
"""

import inspect
import operator
import typing as t
from collections import deque

from markupsafe import Markup

from .utils import _PassArg

if t.TYPE_CHECKING:
 #mport typing_extensions as te

 #rom .environment import Environment

_NodeBound = t.TypeVar("_NodeBound", bound="Node")

_binop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {
 #*": operator.mul,
 #/": operator.truediv,
 #//": operator.floordiv,
 #**": operator.pow,
 #%": operator.mod,
 #+": operator.add,
 #-": operator.sub,
}

_uaop_to_func: t.Dict[str, t.Callable[[t.Any], t.Any]] = {
 #not": operator.not_,
 #+": operator.pos,
 #-": operator.neg,
}

_cmpop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {
 #eq": operator.eq,
 #ne": operator.ne,
 #gt": operator.gt,
 #gteq": operator.ge,
 #lt": operator.lt,
 #lteq": operator.le,
 #in": lambda a, b: a in b,
 #notin": lambda a, b: a not in b,
}


class Impossible(Exception):
 #""Raised if the node could not perform a requested action."""


class NodeType(type):
 #""A metaclass for nodes that handles the field and attribute
 #nheritance.  fields and attributes from the parent class are
 #utomatically forwarded to the child."""

 #ef __new__(mcs, name, bases, d):  # type: ignore
 #or attr in "fields", "attributes":
 #torage: t.List[t.Tuple[str, ...]] = []
 #torage.extend(getattr(bases[0] if bases else object, attr, ()))
 #torage.extend(d.get(attr, ()))
 #ssert len(bases) <= 1, "multiple inheritance not allowed"
 #ssert len(storage) == len(set(storage)), "layout conflict"
 #[attr] = tuple(storage)
 #.setdefault("abstract", False)
 #eturn type.__new__(mcs, name, bases, d)


class EvalContext:
 #""Holds evaluation time information.  Custom attributes can be attached
 #o it in extensions.
 #""

 #ef __init__(
 #elf, environment: "Environment", template_name: t.Optional[str] = None
 # -> None:
 #elf.environment = environment
 #f callable(environment.autoescape):
 #elf.autoescape = environment.autoescape(template_name)
 #lse:
 #elf.autoescape = environment.autoescape
 #elf.volatile = False

 #ef save(self) -> t.Mapping[str, t.Any]:
 #eturn self.__dict__.copy()

 #ef revert(self, old: t.Mapping[str, t.Any]) -> None:
 #elf.__dict__.clear()
 #elf.__dict__.update(old)


def get_eval_context(node: "Node", ctx: t.Optional[EvalContext]) -> EvalContext:
 #f ctx is None:
 #f node.environment is None:
 #aise RuntimeError(
 #if no eval context is passed, the node must have an"
 # attached environment."
 #
 #eturn EvalContext(node.environment)
 #eturn ctx


class Node(metaclass=NodeType):
 #""Baseclass for all Jinja nodes.  There are a number of nodes available
 #f different types.  There are four major types:

 #   :class:`Stmt`: statements
 #   :class:`Expr`: expressions
 #   :class:`Helper`: helper nodes
 #   :class:`Template`: the outermost wrapper node

 #ll nodes have fields and attributes.  Fields may be other nodes, lists,
 #r arbitrary values.  Fields are passed to the constructor as regular
 #ositional arguments, attributes as keyword arguments.  Each node has
 #wo attributes: `lineno` (the line number of the node) and `environment`.
 #he `environment` attribute is set at the end of the parsing process for
 #ll nodes automatically.
 #""

 #ields: t.Tuple[str, ...] = ()
 #ttributes: t.Tuple[str, ...] = ("lineno", "environment")
 #bstract = True

 #ineno: int
 #nvironment: t.Optional["Environment"]

 #ef __init__(self, *fields: t.Any, **attributes: t.Any) -> None:
 #f self.abstract:
 #aise TypeError("abstract nodes are not instantiable")
 #f fields:
 #f len(fields) != len(self.fields):
 #f not self.fields:
 #aise TypeError(f"{type(self).__name__!r} takes 0 arguments")
 #aise TypeError(
 #"{type(self).__name__!r} takes 0 or {len(self.fields)}"
 #" argument{'s' if len(self.fields) != 1 else ''}"
 #
 #or name, arg in zip(self.fields, fields):
 #etattr(self, name, arg)
 #or attr in self.attributes:
 #etattr(self, attr, attributes.pop(attr, None))
 #f attributes:
 #aise TypeError(f"unknown attribute {next(iter(attributes))!r}")

 #ef iter_fields(
 #elf,
 #xclude: t.Optional[t.Container[str]] = None,
 #nly: t.Optional[t.Container[str]] = None,
 # -> t.Iterator[t.Tuple[str, t.Any]]:
 #""This method iterates over all fields that are defined and yields
 #`(key, value)`` tuples.  Per default all fields are returned, but
 #t's possible to limit that to some fields by providing the `only`
 #arameter or to exclude some using the `exclude` parameter.  Both
 #hould be sets or tuples of field names.
 #""
 #or name in self.fields:
 #f (
 #exclude is None and only is None)
 #r (exclude is not None and name not in exclude)
 #r (only is not None and name in only)
 #:
 #ry:
 #ield name, getattr(self, name)
 #xcept AttributeError:
 #ass

 #ef iter_child_nodes(
 #elf,
 #xclude: t.Optional[t.Container[str]] = None,
 #nly: t.Optional[t.Container[str]] = None,
 # -> t.Iterator["Node"]:
 #""Iterates over all direct child nodes of the node.  This iterates
 #ver all fields and yields the values of they are nodes.  If the value
 #f a field is a list all the nodes in that list are returned.
 #""
 #or _, item in self.iter_fields(exclude, only):
 #f isinstance(item, list):
 #or n in item:
 #f isinstance(n, Node):
 #ield n
 #lif isinstance(item, Node):
 #ield item

 #ef find(self, node_type: t.Type[_NodeBound]) -> t.Optional[_NodeBound]:
 #""Find the first node of a given type.  If no such node exists the
 #eturn value is `None`.
 #""
 #or result in self.find_all(node_type):
 #eturn result

 #eturn None

 #ef find_all(
 #elf, node_type: t.Union[t.Type[_NodeBound], t.Tuple[t.Type[_NodeBound], ...]]
 # -> t.Iterator[_NodeBound]:
 #""Find all the nodes of a given type.  If the type is a tuple,
 #he check is performed for any of the tuple items.
 #""
 #or child in self.iter_child_nodes():
 #f isinstance(child, node_type):
 #ield child  # type: ignore
 #ield from child.find_all(node_type)

 #ef set_ctx(self, ctx: str) -> "Node":
 #""Reset the context of a node and all child nodes.  Per default the
 #arser will all generate nodes that have a 'load' context as it's the
 #ost common one.  This method is used in the parser to set assignment
 #argets and other nodes to a store context.
 #""
 #odo = deque([self])
 #hile todo:
 #ode = todo.popleft()
 #f "ctx" in node.fields:
 #ode.ctx = ctx  # type: ignore
 #odo.extend(node.iter_child_nodes())
 #eturn self

 #ef set_lineno(self, lineno: int, override: bool = False) -> "Node":
 #""Set the line numbers of the node and children."""
 #odo = deque([self])
 #hile todo:
 #ode = todo.popleft()
 #f "lineno" in node.attributes:
 #f node.lineno is None or override:
 #ode.lineno = lineno
 #odo.extend(node.iter_child_nodes())
 #eturn self

 #ef set_environment(self, environment: "Environment") -> "Node":
 #""Set the environment for all nodes."""
 #odo = deque([self])
 #hile todo:
 #ode = todo.popleft()
 #ode.environment = environment
 #odo.extend(node.iter_child_nodes())
 #eturn self

 #ef __eq__(self, other: t.Any) -> bool:
 #f type(self) is not type(other):
 #eturn NotImplemented

 #eturn tuple(self.iter_fields()) == tuple(other.iter_fields())

 #_hash__ = object.__hash__

 #ef __repr__(self) -> str:
 #rgs_str = ", ".join(f"{a}={getattr(self, a, None)!r}" for a in self.fields)
 #eturn f"{type(self).__name__}({args_str})"

 #ef dump(self) -> str:
 #ef _dump(node: t.Union[Node, t.Any]) -> None:
 #f not isinstance(node, Node):
 #uf.append(repr(node))
 #eturn

 #uf.append(f"nodes.{type(node).__name__}(")
 #f not node.fields:
 #uf.append(")")
 #eturn
 #or idx, field in enumerate(node.fields):
 #f idx:
 #uf.append(", ")
 #alue = getattr(node, field)
 #f isinstance(value, list):
 #uf.append("[")
 #or idx, item in enumerate(value):
 #f idx:
 #uf.append(", ")
 #dump(item)
 #uf.append("]")
 #lse:
 #dump(value)
 #uf.append(")")

 #uf: t.List[str] = []
 #dump(self)
 #eturn "".join(buf)


class Stmt(Node):
 #""Base node for all statements."""

 #bstract = True


class Helper(Node):
 #""Nodes that exist in a specific context only."""

 #bstract = True


class Template(Node):
 #""Node that represents a template.  This must be the outermost node that
 #s passed to the compiler.
 #""

 #ields = ("body",)
 #ody: t.List[Node]


class Output(Stmt):
 #""A node that holds multiple expressions which are then printed out.
 #his is used both for the `print` statement and the regular template data.
 #""

 #ields = ("nodes",)
 #odes: t.List["Expr"]


class Extends(Stmt):
 #""Represents an extends statement."""

 #ields = ("template",)
 #emplate: "Expr"


class For(Stmt):
 #""The for loop.  `target` is the target for the iteration (usually a
 #class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list
 #f nodes that are used as loop-body, and `else_` a list of nodes for the
 #else` block.  If no else node exists it has to be an empty list.

 #or filtered nodes an expression can be stored as `test`, otherwise `None`.
 #""

 #ields = ("target", "iter", "body", "else_", "test", "recursive")
 #arget: Node
 #ter: Node
 #ody: t.List[Node]
 #lse_: t.List[Node]
 #est: t.Optional[Node]
 #ecursive: bool


class If(Stmt):
 #""If `test` is true, `body` is rendered, else `else_`."""

 #ields = ("test", "body", "elif_", "else_")
 #est: Node
 #ody: t.List[Node]
 #lif_: t.List["If"]
 #lse_: t.List[Node]


class Macro(Stmt):
 #""A macro definition.  `name` is the name of the macro, `args` a list of
 #rguments and `defaults` a list of defaults if there are any.  `body` is
 # list of nodes for the macro body.
 #""

 #ields = ("name", "args", "defaults", "body")
 #ame: str
 #rgs: t.List["Name"]
 #efaults: t.List["Expr"]
 #ody: t.List[Node]


class CallBlock(Stmt):
 #""Like a macro without a name but a call instead.  `call` is called with
 #he unnamed macro as `caller` argument this node holds.
 #""

 #ields = ("call", "args", "defaults", "body")
 #all: "Call"
 #rgs: t.List["Name"]
 #efaults: t.List["Expr"]
 #ody: t.List[Node]


class FilterBlock(Stmt):
 #""Node for filter sections."""

 #ields = ("body", "filter")
 #ody: t.List[Node]
 #ilter: "Filter"


class With(Stmt):
 #""Specific node for with statements.  In older versions of Jinja the
 #ith statement was implemented on the base of the `Scope` node instead.

 #. versionadded:: 2.9.3
 #""

 #ields = ("targets", "values", "body")
 #argets: t.List["Expr"]
 #alues: t.List["Expr"]
 #ody: t.List[Node]


class Block(Stmt):
 #""A node that represents a block.

 #. versionchanged:: 3.0.0
 #he `required` field was added.
 #""

 #ields = ("name", "body", "scoped", "required")
 #ame: str
 #ody: t.List[Node]
 #coped: bool
 #equired: bool


class Include(Stmt):
 #""A node that represents the include tag."""

 #ields = ("template", "with_context", "ignore_missing")
 #emplate: "Expr"
 #ith_context: bool
 #gnore_missing: bool


class Import(Stmt):
 #""A node that represents the import tag."""

 #ields = ("template", "target", "with_context")
 #emplate: "Expr"
 #arget: str
 #ith_context: bool


class FromImport(Stmt):
 #""A node that represents the from import tag.  It's important to not
 #ass unsafe names to the name attribute.  The compiler translates the
 #ttribute lookups directly into getattr calls and does *not* use the
 #ubscript callback of the interface.  As exported variables may not
 #tart with double underscores (which the parser asserts) this is not a
 #roblem for regular Jinja code, but if this node is used in an extension
 #xtra care must be taken.

 #he list of names may contain tuples if aliases are wanted.
 #""

 #ields = ("template", "names", "with_context")
 #emplate: "Expr"
 #ames: t.List[t.Union[str, t.Tuple[str, str]]]
 #ith_context: bool


class ExprStmt(Stmt):
 #""A statement that evaluates an expression and discards the result."""

 #ields = ("node",)
 #ode: Node


class Assign(Stmt):
 #""Assigns an expression to a target."""

 #ields = ("target", "node")
 #arget: "Expr"
 #ode: Node


class AssignBlock(Stmt):
 #""Assigns a block to a target."""

 #ields = ("target", "filter", "body")
 #arget: "Expr"
 #ilter: t.Optional["Filter"]
 #ody: t.List[Node]


class Expr(Node):
 #""Baseclass for all expressions."""

 #bstract = True

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #""Return the value of the expression as constant or raise
 #exc:`Impossible` if this was not possible.

 #n :class:`EvalContext` can be provided, if none is given
 # default context is created which requires the nodes to have
 #n attached environment.

 #. versionchanged:: 2.4
 #he `eval_ctx` parameter was added.
 #""
 #aise Impossible()

 #ef can_assign(self) -> bool:
 #""Check if it's possible to assign something to this node."""
 #eturn False


class BinExpr(Expr):
 #""Baseclass for all binary expressions."""

 #ields = ("left", "right")
 #eft: Expr
 #ight: Expr
 #perator: str
 #bstract = True

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #val_ctx = get_eval_context(self, eval_ctx)

        # intercepted operators cannot be folded at compile time
 #f (
 #val_ctx.environment.sandboxed
 #nd self.operator in eval_ctx.environment.intercepted_binops  # type: ignore
 #:
 #aise Impossible()
 # = _binop_to_func[self.operator]
 #ry:
 #eturn f(self.left.as_const(eval_ctx), self.right.as_const(eval_ctx))
 #xcept Exception as e:
 #aise Impossible() from e


class UnaryExpr(Expr):
 #""Baseclass for all unary expressions."""

 #ields = ("node",)
 #ode: Expr
 #perator: str
 #bstract = True

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #val_ctx = get_eval_context(self, eval_ctx)

        # intercepted operators cannot be folded at compile time
 #f (
 #val_ctx.environment.sandboxed
 #nd self.operator in eval_ctx.environment.intercepted_unops  # type: ignore
 #:
 #aise Impossible()
 # = _uaop_to_func[self.operator]
 #ry:
 #eturn f(self.node.as_const(eval_ctx))
 #xcept Exception as e:
 #aise Impossible() from e


class Name(Expr):
 #""Looks up a name or stores a value in a name.
 #he `ctx` of the node can be one of the following values:

 #   `store`: store a value in the name
 #   `load`: load that name
 #   `param`: like `store` but if the name was defined as function parameter.
 #""

 #ields = ("name", "ctx")
 #ame: str
 #tx: str

 #ef can_assign(self) -> bool:
 #eturn self.name not in {"true", "false", "none", "True", "False", "None"}


class NSRef(Expr):
 #""Reference to a namespace value assignment"""

 #ields = ("name", "attr")
 #ame: str
 #ttr: str

 #ef can_assign(self) -> bool:
        # We don't need any special checks here; NSRef assignments have a
        # runtime check to ensure the target is a namespace object which will
        # have been checked already as it is created using a normal assignment
        # which goes through a `Name` node.
 #eturn True


class Literal(Expr):
 #""Baseclass for literals."""

 #bstract = True


class Const(Literal):
 #""All constant values.  The parser will return this node for simple
 #onstants such as ``42`` or ``"foo"`` but it can be used to store more
 #omplex values such as lists too.  Only constants with a safe
 #epresentation (objects where ``eval(repr(x)) == x`` is true).
 #""

 #ields = ("value",)
 #alue: t.Any

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #eturn self.value

 #classmethod
 #ef from_untrusted(
 #ls,
 #alue: t.Any,
 #ineno: t.Optional[int] = None,
 #nvironment: "t.Optional[Environment]" = None,
 # -> "Const":
 #""Return a const object if the value is representable as
 #onstant value in the generated code, otherwise it will raise
 #n `Impossible` exception.
 #""
 #rom .compiler import has_safe_repr

 #f not has_safe_repr(value):
 #aise Impossible()
 #eturn cls(value, lineno=lineno, environment=environment)


class TemplateData(Literal):
 #""A constant template string."""

 #ields = ("data",)
 #ata: str

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> str:
 #val_ctx = get_eval_context(self, eval_ctx)
 #f eval_ctx.volatile:
 #aise Impossible()
 #f eval_ctx.autoescape:
 #eturn Markup(self.data)
 #eturn self.data


class Tuple(Literal):
 #""For loop unpacking and some other things like multiple arguments
 #or subscripts.  Like for :class:`Name` `ctx` specifies if the tuple
 #s used for loading the names or storing.
 #""

 #ields = ("items", "ctx")
 #tems: t.List[Expr]
 #tx: str

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Tuple[t.Any, ...]:
 #val_ctx = get_eval_context(self, eval_ctx)
 #eturn tuple(x.as_const(eval_ctx) for x in self.items)

 #ef can_assign(self) -> bool:
 #or item in self.items:
 #f not item.can_assign():
 #eturn False
 #eturn True


class List(Literal):
 #""Any list literal such as ``[1, 2, 3]``"""

 #ields = ("items",)
 #tems: t.List[Expr]

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.List[t.Any]:
 #val_ctx = get_eval_context(self, eval_ctx)
 #eturn [x.as_const(eval_ctx) for x in self.items]


class Dict(Literal):
 #""Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of
 #class:`Pair` nodes.
 #""

 #ields = ("items",)
 #tems: t.List["Pair"]

 #ef as_const(
 #elf, eval_ctx: t.Optional[EvalContext] = None
 # -> t.Dict[t.Any, t.Any]:
 #val_ctx = get_eval_context(self, eval_ctx)
 #eturn dict(x.as_const(eval_ctx) for x in self.items)


class Pair(Helper):
 #""A key, value pair for dicts."""

 #ields = ("key", "value")
 #ey: Expr
 #alue: Expr

 #ef as_const(
 #elf, eval_ctx: t.Optional[EvalContext] = None
 # -> t.Tuple[t.Any, t.Any]:
 #val_ctx = get_eval_context(self, eval_ctx)
 #eturn self.key.as_const(eval_ctx), self.value.as_const(eval_ctx)


class Keyword(Helper):
 #""A key, value pair for keyword arguments where key is a string."""

 #ields = ("key", "value")
 #ey: str
 #alue: Expr

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Tuple[str, t.Any]:
 #val_ctx = get_eval_context(self, eval_ctx)
 #eturn self.key, self.value.as_const(eval_ctx)


class CondExpr(Expr):
 #""A conditional expression (inline if expression).  (``{{
 #oo if bar else baz }}``)
 #""

 #ields = ("test", "expr1", "expr2")
 #est: Expr
 #xpr1: Expr
 #xpr2: t.Optional[Expr]

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #val_ctx = get_eval_context(self, eval_ctx)
 #f self.test.as_const(eval_ctx):
 #eturn self.expr1.as_const(eval_ctx)

        # if we evaluate to an undefined object, we better do that at runtime
 #f self.expr2 is None:
 #aise Impossible()

 #eturn self.expr2.as_const(eval_ctx)


def args_as_const(
 #ode: t.Union["_FilterTestCommon", "Call"], eval_ctx: t.Optional[EvalContext]
) -> t.Tuple[t.List[t.Any], t.Dict[t.Any, t.Any]]:
 #rgs = [x.as_const(eval_ctx) for x in node.args]
 #wargs = dict(x.as_const(eval_ctx) for x in node.kwargs)

 #f node.dyn_args is not None:
 #ry:
 #rgs.extend(node.dyn_args.as_const(eval_ctx))
 #xcept Exception as e:
 #aise Impossible() from e

 #f node.dyn_kwargs is not None:
 #ry:
 #wargs.update(node.dyn_kwargs.as_const(eval_ctx))
 #xcept Exception as e:
 #aise Impossible() from e

 #eturn args, kwargs


class _FilterTestCommon(Expr):
 #ields = ("node", "name", "args", "kwargs", "dyn_args", "dyn_kwargs")
 #ode: Expr
 #ame: str
 #rgs: t.List[Expr]
 #wargs: t.List[Pair]
 #yn_args: t.Optional[Expr]
 #yn_kwargs: t.Optional[Expr]
 #bstract = True
 #is_filter = True

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #val_ctx = get_eval_context(self, eval_ctx)

 #f eval_ctx.volatile:
 #aise Impossible()

 #f self._is_filter:
 #nv_map = eval_ctx.environment.filters
 #lse:
 #nv_map = eval_ctx.environment.tests

 #unc = env_map.get(self.name)
 #ass_arg = _PassArg.from_obj(func)  # type: ignore

 #f func is None or pass_arg is _PassArg.context:
 #aise Impossible()

 #f eval_ctx.environment.is_async and (
 #etattr(func, "jinja_async_variant", False) is True
 #r inspect.iscoroutinefunction(func)
 #:
 #aise Impossible()

 #rgs, kwargs = args_as_const(self, eval_ctx)
 #rgs.insert(0, self.node.as_const(eval_ctx))

 #f pass_arg is _PassArg.eval_context:
 #rgs.insert(0, eval_ctx)
 #lif pass_arg is _PassArg.environment:
 #rgs.insert(0, eval_ctx.environment)

 #ry:
 #eturn func(*args, **kwargs)
 #xcept Exception as e:
 #aise Impossible() from e


class Filter(_FilterTestCommon):
 #""Apply a filter to an expression. ``name`` is the name of the
 #ilter, the other fields are the same as :class:`Call`.

 #f ``node`` is ``None``, the filter is being used in a filter block
 #nd is applied to the content of the block.
 #""

 #ode: t.Optional[Expr]  # type: ignore

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #f self.node is None:
 #aise Impossible()

 #eturn super().as_const(eval_ctx=eval_ctx)


class Test(_FilterTestCommon):
 #""Apply a test to an expression. ``name`` is the name of the test,
 #he other field are the same as :class:`Call`.

 #. versionchanged:: 3.0
 #`as_const`` shares the same logic for filters and tests. Tests
 #heck for volatile, async, and ``@pass_context`` etc.
 #ecorators.
 #""

 #is_filter = False


class Call(Expr):
 #""Calls an expression.  `args` is a list of arguments, `kwargs` a list
 #f keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`
 #nd `dyn_kwargs` has to be either `None` or a node that is used as
 #ode for dynamic positional (``*args``) or keyword (``**kwargs``)
 #rguments.
 #""

 #ields = ("node", "args", "kwargs", "dyn_args", "dyn_kwargs")
 #ode: Expr
 #rgs: t.List[Expr]
 #wargs: t.List[Keyword]
 #yn_args: t.Optional[Expr]
 #yn_kwargs: t.Optional[Expr]


class Getitem(Expr):
 #""Get an attribute or item from an expression and prefer the item."""

 #ields = ("node", "arg", "ctx")
 #ode: Expr
 #rg: Expr
 #tx: str

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #f self.ctx != "load":
 #aise Impossible()

 #val_ctx = get_eval_context(self, eval_ctx)

 #ry:
 #eturn eval_ctx.environment.getitem(
 #elf.node.as_const(eval_ctx), self.arg.as_const(eval_ctx)
 #
 #xcept Exception as e:
 #aise Impossible() from e


class Getattr(Expr):
 #""Get an attribute or item from an expression that is a ascii-only
 #ytestring and prefer the attribute.
 #""

 #ields = ("node", "attr", "ctx")
 #ode: Expr
 #ttr: str
 #tx: str

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #f self.ctx != "load":
 #aise Impossible()

 #val_ctx = get_eval_context(self, eval_ctx)

 #ry:
 #eturn eval_ctx.environment.getattr(self.node.as_const(eval_ctx), self.attr)
 #xcept Exception as e:
 #aise Impossible() from e


class Slice(Expr):
 #""Represents a slice object.  This must only be used as argument for
 #class:`Subscript`.
 #""

 #ields = ("start", "stop", "step")
 #tart: t.Optional[Expr]
 #top: t.Optional[Expr]
 #tep: t.Optional[Expr]

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> slice:
 #val_ctx = get_eval_context(self, eval_ctx)

 #ef const(obj: t.Optional[Expr]) -> t.Optional[t.Any]:
 #f obj is None:
 #eturn None
 #eturn obj.as_const(eval_ctx)

 #eturn slice(const(self.start), const(self.stop), const(self.step))


class Concat(Expr):
 #""Concatenates the list of expressions provided after converting
 #hem to strings.
 #""

 #ields = ("nodes",)
 #odes: t.List[Expr]

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> str:
 #val_ctx = get_eval_context(self, eval_ctx)
 #eturn "".join(str(x.as_const(eval_ctx)) for x in self.nodes)


class Compare(Expr):
 #""Compares an expression with some other expressions.  `ops` must be a
 #ist of :class:`Operand`\\s.
 #""

 #ields = ("expr", "ops")
 #xpr: Expr
 #ps: t.List["Operand"]

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #val_ctx = get_eval_context(self, eval_ctx)
 #esult = value = self.expr.as_const(eval_ctx)

 #ry:
 #or op in self.ops:
 #ew_value = op.expr.as_const(eval_ctx)
 #esult = _cmpop_to_func[op.op](value, new_value)

 #f not result:
 #eturn False

 #alue = new_value
 #xcept Exception as e:
 #aise Impossible() from e

 #eturn result


class Operand(Helper):
 #""Holds an operator and an expression."""

 #ields = ("op", "expr")
 #p: str
 #xpr: Expr


class Mul(BinExpr):
 #""Multiplies the left with the right node."""

 #perator = "*"


class Div(BinExpr):
 #""Divides the left by the right node."""

 #perator = "/"


class FloorDiv(BinExpr):
 #""Divides the left by the right node and converts the
 #esult into an integer by truncating.
 #""

 #perator = "//"


class Add(BinExpr):
 #""Add the left to the right node."""

 #perator = "+"


class Sub(BinExpr):
 #""Subtract the right from the left node."""

 #perator = "-"


class Mod(BinExpr):
 #""Left modulo right."""

 #perator = "%"


class Pow(BinExpr):
 #""Left to the power of right."""

 #perator = "**"


class And(BinExpr):
 #""Short circuited AND."""

 #perator = "and"

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #val_ctx = get_eval_context(self, eval_ctx)
 #eturn self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)


class Or(BinExpr):
 #""Short circuited OR."""

 #perator = "or"

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:
 #val_ctx = get_eval_context(self, eval_ctx)
 #eturn self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)


class Not(UnaryExpr):
 #""Negate the expression."""

 #perator = "not"


class Neg(UnaryExpr):
 #""Make the expression negative."""

 #perator = "-"


class Pos(UnaryExpr):
 #""Make the expression positive (noop for most expressions)"""

 #perator = "+"


# Helpers for extensions


class EnvironmentAttribute(Expr):
 #""Loads an attribute from the environment object.  This is useful for
 #xtensions that want to call a callback stored on the environment.
 #""

 #ields = ("name",)
 #ame: str


class ExtensionAttribute(Expr):
 #""Returns the attribute of an extension bound to the environment.
 #he identifier is the identifier of the :class:`Extension`.

 #his node is usually constructed by calling the
 #meth:`~jinja2.ext.Extension.attr` method on an extension.
 #""

 #ields = ("identifier", "name")
 #dentifier: str
 #ame: str


class ImportedName(Expr):
 #""If created with an import name the import name is returned on node
 #ccess.  For example ``ImportedName('cgi.escape')`` returns the `escape`
 #unction from the cgi module on evaluation.  Imports are optimized by the
 #ompiler so there is no need to assign them to local variables.
 #""

 #ields = ("importname",)
 #mportname: str


class InternalName(Expr):
 #""An internal name in the compiler.  You cannot create these nodes
 #ourself but the parser provides a
 #meth:`~jinja2.parser.Parser.free_identifier` method that creates
 # new identifier for you.  This identifier is not available from the
 #emplate and is not treated specially by the compiler.
 #""

 #ields = ("name",)
 #ame: str

 #ef __init__(self) -> None:
 #aise TypeError(
 #Can't create internal names.  Use the "
 #`free_identifier` method on a parser."
 #


class MarkSafe(Expr):
 #""Mark the wrapped expression as safe (wrap it as `Markup`)."""

 #ields = ("expr",)
 #xpr: Expr

 #ef as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> Markup:
 #val_ctx = get_eval_context(self, eval_ctx)
 #eturn Markup(self.expr.as_const(eval_ctx))


class MarkSafeIfAutoescape(Expr):
 #""Mark the wrapped expression as safe (wrap it as `Markup`) but
 #nly if autoescaping is active.

 #. versionadded:: 2.5
 #""

 #ields = ("expr",)
 #xpr: Expr

 #ef as_const(
 #elf, eval_ctx: t.Optional[EvalContext] = None
 # -> t.Union[Markup, t.Any]:
 #val_ctx = get_eval_context(self, eval_ctx)
 #f eval_ctx.volatile:
 #aise Impossible()
 #xpr = self.expr.as_const(eval_ctx)
 #f eval_ctx.autoescape:
 #eturn Markup(expr)
 #eturn expr


class ContextReference(Expr):
 #""Returns the current template context.  It can be used like a
 #class:`Name` node, with a ``'load'`` ctx and will return the
 #urrent :class:`~jinja2.runtime.Context` object.

 #ere an example that assigns the current template name to a
 #ariable named `foo`::

 #ssign(Name('foo', ctx='store'),
 #etattr(ContextReference(), 'name'))

 #his is basically equivalent to using the
 #func:`~jinja2.pass_context` decorator when using the high-level
 #PI, which causes a reference to the context to be passed as the
 #irst argument to a function.
 #""


class DerivedContextReference(Expr):
 #""Return the current template context including locals. Behaves
 #xactly like :class:`ContextReference`, but includes local
 #ariables, such as from a ``for`` loop.

 #. versionadded:: 2.11
 #""


class Continue(Stmt):
 #""Continue a loop."""


class Break(Stmt):
 #""Break a loop."""


class Scope(Stmt):
 #""An artificial scope."""

 #ields = ("body",)
 #ody: t.List[Node]


class OverlayScope(Stmt):
 #""An overlay scope for extensions.  This is a largely unoptimized scope
 #hat however can be used to introduce completely arbitrary variables into
 # sub scope from a dictionary or dictionary like object.  The `context`
 #ield has to evaluate to a dictionary object.

 #xample usage::

 #verlayScope(context=self.call_method('get_context'),
 #ody=[...])

 #. versionadded:: 2.10
 #""

 #ields = ("context", "body")
 #ontext: Expr
 #ody: t.List[Node]


class EvalContextModifier(Stmt):
 #""Modifies the eval context.  For each option that should be modified,
 # :class:`Keyword` has to be added to the :attr:`options` list.

 #xample to change the `autoescape` setting::

 #valContextModifier(options=[Keyword('autoescape', Const(True))])
 #""

 #ields = ("options",)
 #ptions: t.List[Keyword]


class ScopedEvalContextModifier(EvalContextModifier):
 #""Modifies the eval context and reverts it later.  Works exactly like
 #class:`EvalContextModifier` but will only modify the
 #class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.
 #""

 #ields = ("body",)
 #ody: t.List[Node]


# make sure nobody creates custom nodes
def _failing_new(*args: t.Any, **kwargs: t.Any) -> "te.NoReturn":
 #aise TypeError("can't create custom node types")


NodeType.__new__ = staticmethod(_failing_new)  # type: ignore
del _failing_new
