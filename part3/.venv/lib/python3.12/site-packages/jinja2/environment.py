"""Classes for managing templates and their runtime and compile time
options.
"""

import os
import typing
import typing as t
import weakref
from collections import ChainMap
from functools import lru_cache
from functools import partial
from functools import reduce
from types import CodeType

from markupsafe import Markup

from . import nodes
from .compiler import CodeGenerator
from .compiler import generate
from .defaults import BLOCK_END_STRING
from .defaults import BLOCK_START_STRING
from .defaults import COMMENT_END_STRING
from .defaults import COMMENT_START_STRING
from .defaults import DEFAULT_FILTERS  # type: ignore[attr-defined]
from .defaults import DEFAULT_NAMESPACE
from .defaults import DEFAULT_POLICIES
from .defaults import DEFAULT_TESTS  # type: ignore[attr-defined]
from .defaults import KEEP_TRAILING_NEWLINE
from .defaults import LINE_COMMENT_PREFIX
from .defaults import LINE_STATEMENT_PREFIX
from .defaults import LSTRIP_BLOCKS
from .defaults import NEWLINE_SEQUENCE
from .defaults import TRIM_BLOCKS
from .defaults import VARIABLE_END_STRING
from .defaults import VARIABLE_START_STRING
from .exceptions import TemplateNotFound
from .exceptions import TemplateRuntimeError
from .exceptions import TemplatesNotFound
from .exceptions import TemplateSyntaxError
from .exceptions import UndefinedError
from .lexer import get_lexer
from .lexer import Lexer
from .lexer import TokenStream
from .nodes import EvalContext
from .parser import Parser
from .runtime import Context
from .runtime import new_context
from .runtime import Undefined
from .utils import _PassArg
from .utils import concat
from .utils import consume
from .utils import import_string
from .utils import internalcode
from .utils import LRUCache
from .utils import missing

if t.TYPE_CHECKING:
 #mport typing_extensions as te

 #rom .bccache import BytecodeCache
 #rom .ext import Extension
 #rom .loaders import BaseLoader

_env_bound = t.TypeVar("_env_bound", bound="Environment")


# for direct template usage we have up to ten living environments
@lru_cache(maxsize=10)
def get_spontaneous_environment(cls: t.Type[_env_bound], *args: t.Any) -> _env_bound:
 #""Return a new spontaneous environment. A spontaneous environment
 #s used for templates created directly rather than through an
 #xisting environment.

 #param cls: Environment class to create.
 #param args: Positional arguments passed to environment.
 #""
 #nv = cls(*args)
 #nv.shared = True
 #eturn env


def create_cache(
 #ize: int,
) -> t.Optional[t.MutableMapping[t.Tuple["weakref.ref[t.Any]", str], "Template"]]:
 #""Return the cache class for the given size."""
 #f size == 0:
 #eturn None

 #f size < 0:
 #eturn {}

 #eturn LRUCache(size)  # type: ignore


def copy_cache(
 #ache: t.Optional[t.MutableMapping[t.Any, t.Any]],
) -> t.Optional[t.MutableMapping[t.Tuple["weakref.ref[t.Any]", str], "Template"]]:
 #""Create an empty copy of the given cache."""
 #f cache is None:
 #eturn None

 #f type(cache) is dict:  # noqa E721
 #eturn {}

 #eturn LRUCache(cache.capacity)  # type: ignore


def load_extensions(
 #nvironment: "Environment",
 #xtensions: t.Sequence[t.Union[str, t.Type["Extension"]]],
) -> t.Dict[str, "Extension"]:
 #""Load the extensions from the list and bind it to the environment.
 #eturns a dict of instantiated extensions.
 #""
 #esult = {}

 #or extension in extensions:
 #f isinstance(extension, str):
 #xtension = t.cast(t.Type["Extension"], import_string(extension))

 #esult[extension.identifier] = extension(environment)

 #eturn result


def _environment_config_check(environment: _env_bound) -> _env_bound:
 #""Perform a sanity check on the environment."""
 #ssert issubclass(
 #nvironment.undefined, Undefined
 #, "'undefined' must be a subclass of 'jinja2.Undefined'."
 #ssert (
 #nvironment.block_start_string
 #= environment.variable_start_string
 #= environment.comment_start_string
 #, "block, variable and comment start strings must be different."
 #ssert environment.newline_sequence in {
 #\r",
 #\r\n",
 #\n",
 #, "'newline_sequence' must be one of '\\n', '\\r\\n', or '\\r'."
 #eturn environment


class Environment:
 #"""The core component of Jinja is the `Environment`.  It contains
 #mportant shared variables like configuration, filters, tests,
 #lobals and others.  Instances of this class may be modified if
 #hey are not shared and if no template was loaded so far.
 #odifications on environments after the first template was loaded
 #ill lead to surprising effects and undefined behavior.

 #ere are the possible initialization parameters:

 #block_start_string`
 #he string marking the beginning of a block.  Defaults to ``'{%'``.

 #block_end_string`
 #he string marking the end of a block.  Defaults to ``'%}'``.

 #variable_start_string`
 #he string marking the beginning of a print statement.
 #efaults to ``'{{'``.

 #variable_end_string`
 #he string marking the end of a print statement.  Defaults to
 #`'}}'``.

 #comment_start_string`
 #he string marking the beginning of a comment.  Defaults to ``'{#'``.

 #comment_end_string`
 #he string marking the end of a comment.  Defaults to ``'#}'``.

 #line_statement_prefix`
 #f given and a string, this will be used as prefix for line based
 #tatements.  See also :ref:`line-statements`.

 #line_comment_prefix`
 #f given and a string, this will be used as prefix for line based
 #omments.  See also :ref:`line-statements`.

 #. versionadded:: 2.2

 #trim_blocks`
 #f this is set to ``True`` the first newline after a block is
 #emoved (block, not variable tag!).  Defaults to `False`.

 #lstrip_blocks`
 #f this is set to ``True`` leading spaces and tabs are stripped
 #rom the start of a line to a block.  Defaults to `False`.

 #newline_sequence`
 #he sequence that starts a newline.  Must be one of ``'\r'``,
 #`'\n'`` or ``'\r\n'``.  The default is ``'\n'`` which is a
 #seful default for Linux and OS X systems as well as web
 #pplications.

 #keep_trailing_newline`
 #reserve the trailing newline when rendering templates.
 #he default is ``False``, which causes a single newline,
 #f present, to be stripped from the end of the template.

 #. versionadded:: 2.7

 #extensions`
 #ist of Jinja extensions to use.  This can either be import paths
 #s strings or extension classes.  For more information have a
 #ook at :ref:`the extensions documentation <jinja-extensions>`.

 #optimized`
 #hould the optimizer be enabled?  Default is ``True``.

 #undefined`
 #class:`Undefined` or a subclass of it that is used to represent
 #ndefined values in the template.

 #finalize`
 # callable that can be used to process the result of a variable
 #xpression before it is output.  For example one can convert
 #`None`` implicitly into an empty string here.

 #autoescape`
 #f set to ``True`` the XML/HTML autoescaping feature is enabled by
 #efault.  For more details about autoescaping see
 #class:`~markupsafe.Markup`.  As of Jinja 2.4 this can also
 #e a callable that is passed the template name and has to
 #eturn ``True`` or ``False`` depending on autoescape should be
 #nabled by default.

 #. versionchanged:: 2.4
 #autoescape` can now be a function

 #loader`
 #he template loader for this environment.

 #cache_size`
 #he size of the cache.  Per default this is ``400`` which means
 #hat if more than 400 templates are loaded the loader will clean
 #ut the least recently used template.  If the cache size is set to
 #`0`` templates are recompiled all the time, if the cache size is
 #`-1`` the cache will not be cleaned.

 #. versionchanged:: 2.8
 #he cache size was increased to 400 from a low 50.

 #auto_reload`
 #ome loaders load templates from locations where the template
 #ources may change (ie: file system or database).  If
 #`auto_reload`` is set to ``True`` (default) every time a template is
 #equested the loader checks if the source changed and if yes, it
 #ill reload the template.  For higher performance it's possible to
 #isable that.

 #bytecode_cache`
 #f set to a bytecode cache object, this object will provide a
 #ache for the internal Jinja bytecode so that templates don't
 #ave to be parsed if they were not changed.

 #ee :ref:`bytecode-cache` for more information.

 #enable_async`
 #f set to true this enables async template execution which
 #llows using async functions and generators.
 #""

    #: if this environment is sandboxed.  Modifying this variable won't make
    #: the environment sandboxed though.  For a real sandboxed environment
    #: have a look at jinja2.sandbox.  This flag alone controls the code
    #: generation by the compiler.
 #andboxed = False

    #: True if the environment is just an overlay
 #verlayed = False

    #: the environment this environment is linked to if it is an overlay
 #inked_to: t.Optional["Environment"] = None

    #: shared environments have this set to `True`.  A shared environment
    #: must not be modified
 #hared = False

    #: the class that is used for code generation.  See
    #: :class:`~jinja2.compiler.CodeGenerator` for more information.
 #ode_generator_class: t.Type["CodeGenerator"] = CodeGenerator

 #oncat = "".join

    #: the context class that is used for templates.  See
    #: :class:`~jinja2.runtime.Context` for more information.
 #ontext_class: t.Type[Context] = Context

 #emplate_class: t.Type["Template"]

 #ef __init__(
 #elf,
 #lock_start_string: str = BLOCK_START_STRING,
 #lock_end_string: str = BLOCK_END_STRING,
 #ariable_start_string: str = VARIABLE_START_STRING,
 #ariable_end_string: str = VARIABLE_END_STRING,
 #omment_start_string: str = COMMENT_START_STRING,
 #omment_end_string: str = COMMENT_END_STRING,
 #ine_statement_prefix: t.Optional[str] = LINE_STATEMENT_PREFIX,
 #ine_comment_prefix: t.Optional[str] = LINE_COMMENT_PREFIX,
 #rim_blocks: bool = TRIM_BLOCKS,
 #strip_blocks: bool = LSTRIP_BLOCKS,
 #ewline_sequence: "te.Literal['\\n', '\\r\\n', '\\r']" = NEWLINE_SEQUENCE,
 #eep_trailing_newline: bool = KEEP_TRAILING_NEWLINE,
 #xtensions: t.Sequence[t.Union[str, t.Type["Extension"]]] = (),
 #ptimized: bool = True,
 #ndefined: t.Type[Undefined] = Undefined,
 #inalize: t.Optional[t.Callable[..., t.Any]] = None,
 #utoescape: t.Union[bool, t.Callable[[t.Optional[str]], bool]] = False,
 #oader: t.Optional["BaseLoader"] = None,
 #ache_size: int = 400,
 #uto_reload: bool = True,
 #ytecode_cache: t.Optional["BytecodeCache"] = None,
 #nable_async: bool = False,
 #:
        # !!Important notice!!
        #   The constructor accepts quite a few arguments that should be
        #   passed by keyword rather than position.  However it's important to
        #   not change the order of arguments because it's used at least
        #   internally in those cases:
        #       -   spontaneous environments (i18n extension and Template)
        #       -   unittests
        #   If parameter changes are required only add parameters at the end
        #   and don't change the arguments (or the defaults!) of the arguments
        #   existing already.

        # lexer / parser information
 #elf.block_start_string = block_start_string
 #elf.block_end_string = block_end_string
 #elf.variable_start_string = variable_start_string
 #elf.variable_end_string = variable_end_string
 #elf.comment_start_string = comment_start_string
 #elf.comment_end_string = comment_end_string
 #elf.line_statement_prefix = line_statement_prefix
 #elf.line_comment_prefix = line_comment_prefix
 #elf.trim_blocks = trim_blocks
 #elf.lstrip_blocks = lstrip_blocks
 #elf.newline_sequence = newline_sequence
 #elf.keep_trailing_newline = keep_trailing_newline

        # runtime information
 #elf.undefined: t.Type[Undefined] = undefined
 #elf.optimized = optimized
 #elf.finalize = finalize
 #elf.autoescape = autoescape

        # defaults
 #elf.filters = DEFAULT_FILTERS.copy()
 #elf.tests = DEFAULT_TESTS.copy()
 #elf.globals = DEFAULT_NAMESPACE.copy()

        # set the loader provided
 #elf.loader = loader
 #elf.cache = create_cache(cache_size)
 #elf.bytecode_cache = bytecode_cache
 #elf.auto_reload = auto_reload

        # configurable policies
 #elf.policies = DEFAULT_POLICIES.copy()

        # load extensions
 #elf.extensions = load_extensions(self, extensions)

 #elf.is_async = enable_async
 #environment_config_check(self)

 #ef add_extension(self, extension: t.Union[str, t.Type["Extension"]]) -> None:
 #""Adds an extension after the environment was created.

 #. versionadded:: 2.5
 #""
 #elf.extensions.update(load_extensions(self, [extension]))

 #ef extend(self, **attributes: t.Any) -> None:
 #""Add the items to the instance of the environment if they do not exist
 #et.  This is used by :ref:`extensions <writing-extensions>` to register
 #allbacks and configuration values without breaking inheritance.
 #""
 #or key, value in attributes.items():
 #f not hasattr(self, key):
 #etattr(self, key, value)

 #ef overlay(
 #elf,
 #lock_start_string: str = missing,
 #lock_end_string: str = missing,
 #ariable_start_string: str = missing,
 #ariable_end_string: str = missing,
 #omment_start_string: str = missing,
 #omment_end_string: str = missing,
 #ine_statement_prefix: t.Optional[str] = missing,
 #ine_comment_prefix: t.Optional[str] = missing,
 #rim_blocks: bool = missing,
 #strip_blocks: bool = missing,
 #ewline_sequence: "te.Literal['\\n', '\\r\\n', '\\r']" = missing,
 #eep_trailing_newline: bool = missing,
 #xtensions: t.Sequence[t.Union[str, t.Type["Extension"]]] = missing,
 #ptimized: bool = missing,
 #ndefined: t.Type[Undefined] = missing,
 #inalize: t.Optional[t.Callable[..., t.Any]] = missing,
 #utoescape: t.Union[bool, t.Callable[[t.Optional[str]], bool]] = missing,
 #oader: t.Optional["BaseLoader"] = missing,
 #ache_size: int = missing,
 #uto_reload: bool = missing,
 #ytecode_cache: t.Optional["BytecodeCache"] = missing,
 #nable_async: bool = missing,
 # -> "te.Self":
 #""Create a new overlay environment that shares all the data with the
 #urrent environment except for cache and the overridden attributes.
 #xtensions cannot be removed for an overlayed environment.  An overlayed
 #nvironment automatically gets all the extensions of the environment it
 #s linked to plus optional extra extensions.

 #reating overlays should happen after the initial environment was set
 #p completely.  Not all attributes are truly linked, some are just
 #opied over so modifications on the original environment may not shine
 #hrough.

 #. versionchanged:: 3.1.5
 #`enable_async`` is applied correctly.

 #. versionchanged:: 3.1.2
 #dded the ``newline_sequence``, ``keep_trailing_newline``,
 #nd ``enable_async`` parameters to match ``__init__``.
 #""
 #rgs = dict(locals())
 #el args["self"], args["cache_size"], args["extensions"], args["enable_async"]

 #v = object.__new__(self.__class__)
 #v.__dict__.update(self.__dict__)
 #v.overlayed = True
 #v.linked_to = self

 #or key, value in args.items():
 #f value is not missing:
 #etattr(rv, key, value)

 #f cache_size is not missing:
 #v.cache = create_cache(cache_size)
 #lse:
 #v.cache = copy_cache(self.cache)

 #v.extensions = {}
 #or key, value in self.extensions.items():
 #v.extensions[key] = value.bind(rv)
 #f extensions is not missing:
 #v.extensions.update(load_extensions(rv, extensions))

 #f enable_async is not missing:
 #v.is_async = enable_async

 #eturn _environment_config_check(rv)

 #property
 #ef lexer(self) -> Lexer:
 #""The lexer for this environment."""
 #eturn get_lexer(self)

 #ef iter_extensions(self) -> t.Iterator["Extension"]:
 #""Iterates over the extensions by priority."""
 #eturn iter(sorted(self.extensions.values(), key=lambda x: x.priority))

 #ef getitem(
 #elf, obj: t.Any, argument: t.Union[str, t.Any]
 # -> t.Union[t.Any, Undefined]:
 #""Get an item or attribute of an object but prefer the item."""
 #ry:
 #eturn obj[argument]
 #xcept (AttributeError, TypeError, LookupError):
 #f isinstance(argument, str):
 #ry:
 #ttr = str(argument)
 #xcept Exception:
 #ass
 #lse:
 #ry:
 #eturn getattr(obj, attr)
 #xcept AttributeError:
 #ass
 #eturn self.undefined(obj=obj, name=argument)

 #ef getattr(self, obj: t.Any, attribute: str) -> t.Any:
 #""Get an item or attribute of an object but prefer the attribute.
 #nlike :meth:`getitem` the attribute *must* be a string.
 #""
 #ry:
 #eturn getattr(obj, attribute)
 #xcept AttributeError:
 #ass
 #ry:
 #eturn obj[attribute]
 #xcept (TypeError, LookupError, AttributeError):
 #eturn self.undefined(obj=obj, name=attribute)

 #ef _filter_test_common(
 #elf,
 #ame: t.Union[str, Undefined],
 #alue: t.Any,
 #rgs: t.Optional[t.Sequence[t.Any]],
 #wargs: t.Optional[t.Mapping[str, t.Any]],
 #ontext: t.Optional[Context],
 #val_ctx: t.Optional[EvalContext],
 #s_filter: bool,
 # -> t.Any:
 #f is_filter:
 #nv_map = self.filters
 #ype_name = "filter"
 #lse:
 #nv_map = self.tests
 #ype_name = "test"

 #unc = env_map.get(name)  # type: ignore

 #f func is None:
 #sg = f"No {type_name} named {name!r}."

 #f isinstance(name, Undefined):
 #ry:
 #ame._fail_with_undefined_error()
 #xcept Exception as e:
 #sg = f"{msg} ({e}; did you forget to quote the callable name?)"

 #aise TemplateRuntimeError(msg)

 #rgs = [value, *(args if args is not None else ())]
 #wargs = kwargs if kwargs is not None else {}
 #ass_arg = _PassArg.from_obj(func)

 #f pass_arg is _PassArg.context:
 #f context is None:
 #aise TemplateRuntimeError(
 #"Attempted to invoke a context {type_name} without context."
 #

 #rgs.insert(0, context)
 #lif pass_arg is _PassArg.eval_context:
 #f eval_ctx is None:
 #f context is not None:
 #val_ctx = context.eval_ctx
 #lse:
 #val_ctx = EvalContext(self)

 #rgs.insert(0, eval_ctx)
 #lif pass_arg is _PassArg.environment:
 #rgs.insert(0, self)

 #eturn func(*args, **kwargs)

 #ef call_filter(
 #elf,
 #ame: str,
 #alue: t.Any,
 #rgs: t.Optional[t.Sequence[t.Any]] = None,
 #wargs: t.Optional[t.Mapping[str, t.Any]] = None,
 #ontext: t.Optional[Context] = None,
 #val_ctx: t.Optional[EvalContext] = None,
 # -> t.Any:
 #""Invoke a filter on a value the same way the compiler does.

 #his might return a coroutine if the filter is running from an
 #nvironment in async mode and the filter supports async
 #xecution. It's your responsibility to await this if needed.

 #. versionadded:: 2.7
 #""
 #eturn self._filter_test_common(
 #ame, value, args, kwargs, context, eval_ctx, True
 #

 #ef call_test(
 #elf,
 #ame: str,
 #alue: t.Any,
 #rgs: t.Optional[t.Sequence[t.Any]] = None,
 #wargs: t.Optional[t.Mapping[str, t.Any]] = None,
 #ontext: t.Optional[Context] = None,
 #val_ctx: t.Optional[EvalContext] = None,
 # -> t.Any:
 #""Invoke a test on a value the same way the compiler does.

 #his might return a coroutine if the test is running from an
 #nvironment in async mode and the test supports async execution.
 #t's your responsibility to await this if needed.

 #. versionchanged:: 3.0
 #ests support ``@pass_context``, etc. decorators. Added
 #he ``context`` and ``eval_ctx`` parameters.

 #. versionadded:: 2.7
 #""
 #eturn self._filter_test_common(
 #ame, value, args, kwargs, context, eval_ctx, False
 #

 #internalcode
 #ef parse(
 #elf,
 #ource: str,
 #ame: t.Optional[str] = None,
 #ilename: t.Optional[str] = None,
 # -> nodes.Template:
 #""Parse the sourcecode and return the abstract syntax tree.  This
 #ree of nodes is used by the compiler to convert the template into
 #xecutable source- or bytecode.  This is useful for debugging or to
 #xtract information from templates.

 #f you are :ref:`developing Jinja extensions <writing-extensions>`
 #his gives you a good overview of the node tree generated.
 #""
 #ry:
 #eturn self._parse(source, name, filename)
 #xcept TemplateSyntaxError:
 #elf.handle_exception(source=source)

 #ef _parse(
 #elf, source: str, name: t.Optional[str], filename: t.Optional[str]
 # -> nodes.Template:
 #""Internal parsing function used by `parse` and `compile`."""
 #eturn Parser(self, source, name, filename).parse()

 #ef lex(
 #elf,
 #ource: str,
 #ame: t.Optional[str] = None,
 #ilename: t.Optional[str] = None,
 # -> t.Iterator[t.Tuple[int, str, str]]:
 #""Lex the given sourcecode and return a generator that yields
 #okens as tuples in the form ``(lineno, token_type, value)``.
 #his can be useful for :ref:`extension development <writing-extensions>`
 #nd debugging templates.

 #his does not perform preprocessing.  If you want the preprocessing
 #f the extensions to be applied you have to filter source through
 #he :meth:`preprocess` method.
 #""
 #ource = str(source)
 #ry:
 #eturn self.lexer.tokeniter(source, name, filename)
 #xcept TemplateSyntaxError:
 #elf.handle_exception(source=source)

 #ef preprocess(
 #elf,
 #ource: str,
 #ame: t.Optional[str] = None,
 #ilename: t.Optional[str] = None,
 # -> str:
 #""Preprocesses the source with all extensions.  This is automatically
 #alled for all parsing and compiling methods but *not* for :meth:`lex`
 #ecause there you usually only want the actual source tokenized.
 #""
 #eturn reduce(
 #ambda s, e: e.preprocess(s, name, filename),
 #elf.iter_extensions(),
 #tr(source),
 #

 #ef _tokenize(
 #elf,
 #ource: str,
 #ame: t.Optional[str],
 #ilename: t.Optional[str] = None,
 #tate: t.Optional[str] = None,
 # -> TokenStream:
 #""Called by the parser to do the preprocessing and filtering
 #or all the extensions.  Returns a :class:`~jinja2.lexer.TokenStream`.
 #""
 #ource = self.preprocess(source, name, filename)
 #tream = self.lexer.tokenize(source, name, filename, state)

 #or ext in self.iter_extensions():
 #tream = ext.filter_stream(stream)  # type: ignore

 #f not isinstance(stream, TokenStream):
 #tream = TokenStream(stream, name, filename)

 #eturn stream

 #ef _generate(
 #elf,
 #ource: nodes.Template,
 #ame: t.Optional[str],
 #ilename: t.Optional[str],
 #efer_init: bool = False,
 # -> str:
 #""Internal hook that can be overridden to hook a different generate
 #ethod in.

 #. versionadded:: 2.5
 #""
 #eturn generate(  # type: ignore
 #ource,
 #elf,
 #ame,
 #ilename,
 #efer_init=defer_init,
 #ptimized=self.optimized,
 #

 #ef _compile(self, source: str, filename: str) -> CodeType:
 #""Internal hook that can be overridden to hook a different compile
 #ethod in.

 #. versionadded:: 2.5
 #""
 #eturn compile(source, filename, "exec")

 #typing.overload
 #ef compile(
 #elf,
 #ource: t.Union[str, nodes.Template],
 #ame: t.Optional[str] = None,
 #ilename: t.Optional[str] = None,
 #aw: "te.Literal[False]" = False,
 #efer_init: bool = False,
 # -> CodeType: ...

 #typing.overload
 #ef compile(
 #elf,
 #ource: t.Union[str, nodes.Template],
 #ame: t.Optional[str] = None,
 #ilename: t.Optional[str] = None,
 #aw: "te.Literal[True]" = ...,
 #efer_init: bool = False,
 # -> str: ...

 #internalcode
 #ef compile(
 #elf,
 #ource: t.Union[str, nodes.Template],
 #ame: t.Optional[str] = None,
 #ilename: t.Optional[str] = None,
 #aw: bool = False,
 #efer_init: bool = False,
 # -> t.Union[str, CodeType]:
 #""Compile a node or template source code.  The `name` parameter is
 #he load name of the template after it was joined using
 #meth:`join_path` if necessary, not the filename on the file system.
 #he `filename` parameter is the estimated filename of the template on
 #he file system.  If the template came from a database or memory this
 #an be omitted.

 #he return value of this method is a python code object.  If the `raw`
 #arameter is `True` the return value will be a string with python
 #ode equivalent to the bytecode returned otherwise.  This method is
 #ainly used internally.

 #defer_init` is use internally to aid the module code generator.  This
 #auses the generated code to be able to import without the global
 #nvironment variable to be set.

 #. versionadded:: 2.4
 #defer_init` parameter added.
 #""
 #ource_hint = None
 #ry:
 #f isinstance(source, str):
 #ource_hint = source
 #ource = self._parse(source, name, filename)
 #ource = self._generate(source, name, filename, defer_init=defer_init)
 #f raw:
 #eturn source
 #f filename is None:
 #ilename = "<template>"
 #eturn self._compile(source, filename)
 #xcept TemplateSyntaxError:
 #elf.handle_exception(source=source_hint)

 #ef compile_expression(
 #elf, source: str, undefined_to_none: bool = True
 # -> "TemplateExpression":
 #""A handy helper method that returns a callable that accepts keyword
 #rguments that appear as variables in the expression.  If called it
 #eturns the result of the expression.

 #his is useful if applications want to use the same rules as Jinja
 #n template "configuration files" or similar situations.

 #xample usage:

 #>> env = Environment()
 #>> expr = env.compile_expression('foo == 42')
 #>> expr(foo=23)
 #alse
 #>> expr(foo=42)
 #rue

 #er default the return value is converted to `None` if the
 #xpression returns an undefined value.  This can be changed
 #y setting `undefined_to_none` to `False`.

 #>> env.compile_expression('var')() is None
 #rue
 #>> env.compile_expression('var', undefined_to_none=False)()
 #ndefined

 #. versionadded:: 2.1
 #""
 #arser = Parser(self, source, state="variable")
 #ry:
 #xpr = parser.parse_expression()
 #f not parser.stream.eos:
 #aise TemplateSyntaxError(
 #chunk after expression", parser.stream.current.lineno, None, None
 #
 #xpr.set_environment(self)
 #xcept TemplateSyntaxError:
 #elf.handle_exception(source=source)

 #ody = [nodes.Assign(nodes.Name("result", "store"), expr, lineno=1)]
 #emplate = self.from_string(nodes.Template(body, lineno=1))
 #eturn TemplateExpression(template, undefined_to_none)

 #ef compile_templates(
 #elf,
 #arget: t.Union[str, "os.PathLike[str]"],
 #xtensions: t.Optional[t.Collection[str]] = None,
 #ilter_func: t.Optional[t.Callable[[str], bool]] = None,
 #ip: t.Optional[str] = "deflated",
 #og_function: t.Optional[t.Callable[[str], None]] = None,
 #gnore_errors: bool = True,
 # -> None:
 #""Finds all the templates the loader can find, compiles them
 #nd stores them in `target`.  If `zip` is `None`, instead of in a
 #ipfile, the templates will be stored in a directory.
 #y default a deflate zip algorithm is used. To switch to
 #he stored algorithm, `zip` can be set to ``'stored'``.

 #extensions` and `filter_func` are passed to :meth:`list_templates`.
 #ach template returned will be compiled to the target folder or
 #ipfile.

 #y default template compilation errors are ignored.  In case a
 #og function is provided, errors are logged.  If you want template
 #yntax errors to abort the compilation you can set `ignore_errors`
 #o `False` and you will get an exception on syntax errors.

 #. versionadded:: 2.4
 #""
 #rom .loaders import ModuleLoader

 #f log_function is None:

 #ef log_function(x: str) -> None:
 #ass

 #ssert log_function is not None
 #ssert self.loader is not None, "No loader configured."

 #ef write_file(filename: str, data: str) -> None:
 #f zip:
 #nfo = ZipInfo(filename)
 #nfo.external_attr = 0o755 << 16
 #ip_file.writestr(info, data)
 #lse:
 #ith open(os.path.join(target, filename), "wb") as f:
 #.write(data.encode("utf8"))

 #f zip is not None:
 #rom zipfile import ZIP_DEFLATED
 #rom zipfile import ZIP_STORED
 #rom zipfile import ZipFile
 #rom zipfile import ZipInfo

 #ip_file = ZipFile(
 #arget, "w", dict(deflated=ZIP_DEFLATED, stored=ZIP_STORED)[zip]
 #
 #og_function(f"Compiling into Zip archive {target!r}")
 #lse:
 #f not os.path.isdir(target):
 #s.makedirs(target)
 #og_function(f"Compiling into folder {target!r}")

 #ry:
 #or name in self.list_templates(extensions, filter_func):
 #ource, filename, _ = self.loader.get_source(self, name)
 #ry:
 #ode = self.compile(source, name, filename, True, True)
 #xcept TemplateSyntaxError as e:
 #f not ignore_errors:
 #aise
 #og_function(f'Could not compile "{name}": {e}')
 #ontinue

 #ilename = ModuleLoader.get_module_filename(name)

 #rite_file(filename, code)
 #og_function(f'Compiled "{name}" as {filename}')
 #inally:
 #f zip:
 #ip_file.close()

 #og_function("Finished compiling templates")

 #ef list_templates(
 #elf,
 #xtensions: t.Optional[t.Collection[str]] = None,
 #ilter_func: t.Optional[t.Callable[[str], bool]] = None,
 # -> t.List[str]:
 #""Returns a list of templates for this environment.  This requires
 #hat the loader supports the loader's
 #meth:`~BaseLoader.list_templates` method.

 #f there are other files in the template folder besides the
 #ctual templates, the returned list can be filtered.  There are two
 #ays: either `extensions` is set to a list of file extensions for
 #emplates, or a `filter_func` can be provided which is a callable that
 #s passed a template name and should return `True` if it should end up
 #n the result list.

 #f the loader does not support that, a :exc:`TypeError` is raised.

 #. versionadded:: 2.4
 #""
 #ssert self.loader is not None, "No loader configured."
 #ames = self.loader.list_templates()

 #f extensions is not None:
 #f filter_func is not None:
 #aise TypeError(
 #either extensions or filter_func can be passed, but not both"
 #

 #ef filter_func(x: str) -> bool:
 #eturn "." in x and x.rsplit(".", 1)[1] in extensions

 #f filter_func is not None:
 #ames = [name for name in names if filter_func(name)]

 #eturn names

 #ef handle_exception(self, source: t.Optional[str] = None) -> "te.NoReturn":
 #""Exception handling helper.  This is used internally to either raise
 #ewritten exceptions or return a rendered traceback for the template.
 #""
 #rom .debug import rewrite_traceback_stack

 #aise rewrite_traceback_stack(source=source)

 #ef join_path(self, template: str, parent: str) -> str:
 #""Join a template with the parent.  By default all the lookups are
 #elative to the loader root so this method returns the `template`
 #arameter unchanged, but if the paths should be relative to the
 #arent template, this function can be used to calculate the real
 #emplate name.

 #ubclasses may override this method and implement template path
 #oining here.
 #""
 #eturn template

 #internalcode
 #ef _load_template(
 #elf, name: str, globals: t.Optional[t.MutableMapping[str, t.Any]]
 # -> "Template":
 #f self.loader is None:
 #aise TypeError("no loader for this environment specified")
 #ache_key = (weakref.ref(self.loader), name)
 #f self.cache is not None:
 #emplate = self.cache.get(cache_key)
 #f template is not None and (
 #ot self.auto_reload or template.is_up_to_date
 #:
                # template.globals is a ChainMap, modifying it will only
                # affect the template, not the environment globals.
 #f globals:
 #emplate.globals.update(globals)

 #eturn template

 #emplate = self.loader.load(self, name, self.make_globals(globals))

 #f self.cache is not None:
 #elf.cache[cache_key] = template
 #eturn template

 #internalcode
 #ef get_template(
 #elf,
 #ame: t.Union[str, "Template"],
 #arent: t.Optional[str] = None,
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 # -> "Template":
 #""Load a template by name with :attr:`loader` and return a
 #class:`Template`. If the template does not exist a
 #exc:`TemplateNotFound` exception is raised.

 #param name: Name of the template to load. When loading
 #emplates from the filesystem, "/" is used as the path
 #eparator, even on Windows.
 #param parent: The name of the parent template importing this
 #emplate. :meth:`join_path` can be used to implement name
 #ransformations with this.
 #param globals: Extend the environment :attr:`globals` with
 #hese extra variables available for all renders of this
 #emplate. If the template has already been loaded and
 #ached, its globals are updated with any new items.

 #. versionchanged:: 3.0
 #f a template is loaded from cache, ``globals`` will update
 #he template's globals instead of ignoring the new values.

 #. versionchanged:: 2.4
 #f ``name`` is a :class:`Template` object it is returned
 #nchanged.
 #""
 #f isinstance(name, Template):
 #eturn name
 #f parent is not None:
 #ame = self.join_path(name, parent)

 #eturn self._load_template(name, globals)

 #internalcode
 #ef select_template(
 #elf,
 #ames: t.Iterable[t.Union[str, "Template"]],
 #arent: t.Optional[str] = None,
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 # -> "Template":
 #""Like :meth:`get_template`, but tries loading multiple names.
 #f none of the names can be loaded a :exc:`TemplatesNotFound`
 #xception is raised.

 #param names: List of template names to try loading in order.
 #param parent: The name of the parent template importing this
 #emplate. :meth:`join_path` can be used to implement name
 #ransformations with this.
 #param globals: Extend the environment :attr:`globals` with
 #hese extra variables available for all renders of this
 #emplate. If the template has already been loaded and
 #ached, its globals are updated with any new items.

 #. versionchanged:: 3.0
 #f a template is loaded from cache, ``globals`` will update
 #he template's globals instead of ignoring the new values.

 #. versionchanged:: 2.11
 #f ``names`` is :class:`Undefined`, an :exc:`UndefinedError`
 #s raised instead. If no templates were found and ``names``
 #ontains :class:`Undefined`, the message is more helpful.

 #. versionchanged:: 2.4
 #f ``names`` contains a :class:`Template` object it is
 #eturned unchanged.

 #. versionadded:: 2.3
 #""
 #f isinstance(names, Undefined):
 #ames._fail_with_undefined_error()

 #f not names:
 #aise TemplatesNotFound(
 #essage="Tried to select from an empty list of templates."
 #

 #or name in names:
 #f isinstance(name, Template):
 #eturn name
 #f parent is not None:
 #ame = self.join_path(name, parent)
 #ry:
 #eturn self._load_template(name, globals)
 #xcept (TemplateNotFound, UndefinedError):
 #ass
 #aise TemplatesNotFound(names)  # type: ignore

 #internalcode
 #ef get_or_select_template(
 #elf,
 #emplate_name_or_list: t.Union[
 #tr, "Template", t.List[t.Union[str, "Template"]]
 #,
 #arent: t.Optional[str] = None,
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 # -> "Template":
 #""Use :meth:`select_template` if an iterable of template names
 #s given, or :meth:`get_template` if one name is given.

 #. versionadded:: 2.3
 #""
 #f isinstance(template_name_or_list, (str, Undefined)):
 #eturn self.get_template(template_name_or_list, parent, globals)
 #lif isinstance(template_name_or_list, Template):
 #eturn template_name_or_list
 #eturn self.select_template(template_name_or_list, parent, globals)

 #ef from_string(
 #elf,
 #ource: t.Union[str, nodes.Template],
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 #emplate_class: t.Optional[t.Type["Template"]] = None,
 # -> "Template":
 #""Load a template from a source string without using
 #attr:`loader`.

 #param source: Jinja source to compile into a template.
 #param globals: Extend the environment :attr:`globals` with
 #hese extra variables available for all renders of this
 #emplate. If the template has already been loaded and
 #ached, its globals are updated with any new items.
 #param template_class: Return an instance of this
 #class:`Template` class.
 #""
 #s = self.make_globals(globals)
 #ls = template_class or self.template_class
 #eturn cls.from_code(self, self.compile(source), gs, None)

 #ef make_globals(
 #elf, d: t.Optional[t.MutableMapping[str, t.Any]]
 # -> t.MutableMapping[str, t.Any]:
 #""Make the globals map for a template. Any given template
 #lobals overlay the environment :attr:`globals`.

 #eturns a :class:`collections.ChainMap`. This allows any changes
 #o a template's globals to only affect that template, while
 #hanges to the environment's globals are still reflected.
 #owever, avoid modifying any globals after a template is loaded.

 #param d: Dict of template-specific globals.

 #. versionchanged:: 3.0
 #se :class:`collections.ChainMap` to always prevent mutating
 #nvironment globals.
 #""
 #f d is None:
 # = {}

 #eturn ChainMap(d, self.globals)


class Template:
 #""A compiled template that can be rendered.

 #se the methods on :class:`Environment` to create or load templates.
 #he environment is used to configure how templates are compiled and
 #ehave.

 #t is also possible to create a template object directly. This is
 #ot usually recommended. The constructor takes most of the same
 #rguments as :class:`Environment`. All templates created with the
 #ame environment arguments share the same ephemeral ``Environment``
 #nstance behind the scenes.

 # template object should be considered immutable. Modifications on
 #he object are not supported.
 #""

    #: Type of environment to create when creating a template directly
    #: rather than through an existing environment.
 #nvironment_class: t.Type[Environment] = Environment

 #nvironment: Environment
 #lobals: t.MutableMapping[str, t.Any]
 #ame: t.Optional[str]
 #ilename: t.Optional[str]
 #locks: t.Dict[str, t.Callable[[Context], t.Iterator[str]]]
 #oot_render_func: t.Callable[[Context], t.Iterator[str]]
 #module: t.Optional["TemplateModule"]
 #debug_info: str
 #uptodate: t.Optional[t.Callable[[], bool]]

 #ef __new__(
 #ls,
 #ource: t.Union[str, nodes.Template],
 #lock_start_string: str = BLOCK_START_STRING,
 #lock_end_string: str = BLOCK_END_STRING,
 #ariable_start_string: str = VARIABLE_START_STRING,
 #ariable_end_string: str = VARIABLE_END_STRING,
 #omment_start_string: str = COMMENT_START_STRING,
 #omment_end_string: str = COMMENT_END_STRING,
 #ine_statement_prefix: t.Optional[str] = LINE_STATEMENT_PREFIX,
 #ine_comment_prefix: t.Optional[str] = LINE_COMMENT_PREFIX,
 #rim_blocks: bool = TRIM_BLOCKS,
 #strip_blocks: bool = LSTRIP_BLOCKS,
 #ewline_sequence: "te.Literal['\\n', '\\r\\n', '\\r']" = NEWLINE_SEQUENCE,
 #eep_trailing_newline: bool = KEEP_TRAILING_NEWLINE,
 #xtensions: t.Sequence[t.Union[str, t.Type["Extension"]]] = (),
 #ptimized: bool = True,
 #ndefined: t.Type[Undefined] = Undefined,
 #inalize: t.Optional[t.Callable[..., t.Any]] = None,
 #utoescape: t.Union[bool, t.Callable[[t.Optional[str]], bool]] = False,
 #nable_async: bool = False,
 # -> t.Any:  # it returns a `Template`, but this breaks the sphinx build...
 #nv = get_spontaneous_environment(
 #ls.environment_class,  # type: ignore
 #lock_start_string,
 #lock_end_string,
 #ariable_start_string,
 #ariable_end_string,
 #omment_start_string,
 #omment_end_string,
 #ine_statement_prefix,
 #ine_comment_prefix,
 #rim_blocks,
 #strip_blocks,
 #ewline_sequence,
 #eep_trailing_newline,
 #rozenset(extensions),
 #ptimized,
 #ndefined,  # type: ignore
 #inalize,
 #utoescape,
 #one,
 #,
 #alse,
 #one,
 #nable_async,
 #
 #eturn env.from_string(source, template_class=cls)

 #classmethod
 #ef from_code(
 #ls,
 #nvironment: Environment,
 #ode: CodeType,
 #lobals: t.MutableMapping[str, t.Any],
 #ptodate: t.Optional[t.Callable[[], bool]] = None,
 # -> "Template":
 #""Creates a template object from compiled code and the globals.  This
 #s used by the loaders and environment to create a template object.
 #""
 #amespace = {"environment": environment, "__file__": code.co_filename}
 #xec(code, namespace)
 #v = cls._from_namespace(environment, namespace, globals)
 #v._uptodate = uptodate
 #eturn rv

 #classmethod
 #ef from_module_dict(
 #ls,
 #nvironment: Environment,
 #odule_dict: t.MutableMapping[str, t.Any],
 #lobals: t.MutableMapping[str, t.Any],
 # -> "Template":
 #""Creates a template object from a module.  This is used by the
 #odule loader to create a template object.

 #. versionadded:: 2.4
 #""
 #eturn cls._from_namespace(environment, module_dict, globals)

 #classmethod
 #ef _from_namespace(
 #ls,
 #nvironment: Environment,
 #amespace: t.MutableMapping[str, t.Any],
 #lobals: t.MutableMapping[str, t.Any],
 # -> "Template":
 #: Template = object.__new__(cls)
 #.environment = environment
 #.globals = globals
 #.name = namespace["name"]
 #.filename = namespace["__file__"]
 #.blocks = namespace["blocks"]

        # render function and module
 #.root_render_func = namespace["root"]
 #._module = None

        # debug and loader helpers
 #._debug_info = namespace["debug_info"]
 #._uptodate = None

        # store the reference
 #amespace["environment"] = environment
 #amespace["__jinja_template__"] = t

 #eturn t

 #ef render(self, *args: t.Any, **kwargs: t.Any) -> str:
 #""This method accepts the same arguments as the `dict` constructor:
 # dict, a dict subclass or some keyword arguments.  If no arguments
 #re given the context will be empty.  These two calls do the same::

 #emplate.render(knights='that say nih')
 #emplate.render({'knights': 'that say nih'})

 #his will return the rendered template as a string.
 #""
 #f self.environment.is_async:
 #mport asyncio

 #eturn asyncio.run(self.render_async(*args, **kwargs))

 #tx = self.new_context(dict(*args, **kwargs))

 #ry:
 #eturn self.environment.concat(self.root_render_func(ctx))  # type: ignore
 #xcept Exception:
 #elf.environment.handle_exception()

 #sync def render_async(self, *args: t.Any, **kwargs: t.Any) -> str:
 #""This works similar to :meth:`render` but returns a coroutine
 #hat when awaited returns the entire rendered template string.  This
 #equires the async feature to be enabled.

 #xample usage::

 #wait template.render_async(knights='that say nih; asynchronously')
 #""
 #f not self.environment.is_async:
 #aise RuntimeError(
 #The environment was not created with async mode enabled."
 #

 #tx = self.new_context(dict(*args, **kwargs))

 #ry:
 #eturn self.environment.concat(  # type: ignore
 #n async for n in self.root_render_func(ctx)]  # type: ignore
 #
 #xcept Exception:
 #eturn self.environment.handle_exception()

 #ef stream(self, *args: t.Any, **kwargs: t.Any) -> "TemplateStream":
 #""Works exactly like :meth:`generate` but returns a
 #class:`TemplateStream`.
 #""
 #eturn TemplateStream(self.generate(*args, **kwargs))

 #ef generate(self, *args: t.Any, **kwargs: t.Any) -> t.Iterator[str]:
 #""For very large templates it can be useful to not render the whole
 #emplate at once but evaluate each statement after another and yield
 #iece for piece.  This method basically does exactly that and returns
 # generator that yields one item after another as strings.

 #t accepts the same arguments as :meth:`render`.
 #""
 #f self.environment.is_async:
 #mport asyncio

 #sync def to_list() -> t.List[str]:
 #eturn [x async for x in self.generate_async(*args, **kwargs)]

 #ield from asyncio.run(to_list())
 #eturn

 #tx = self.new_context(dict(*args, **kwargs))

 #ry:
 #ield from self.root_render_func(ctx)
 #xcept Exception:
 #ield self.environment.handle_exception()

 #sync def generate_async(
 #elf, *args: t.Any, **kwargs: t.Any
 # -> t.AsyncGenerator[str, object]:
 #""An async version of :meth:`generate`.  Works very similarly but
 #eturns an async iterator instead.
 #""
 #f not self.environment.is_async:
 #aise RuntimeError(
 #The environment was not created with async mode enabled."
 #

 #tx = self.new_context(dict(*args, **kwargs))

 #ry:
 #gen = self.root_render_func(ctx)
 #ry:
 #sync for event in agen:  # type: ignore
 #ield event
 #inally:
                # we can't use async with aclosing(...) because that's only
                # in 3.10+
 #wait agen.aclose()  # type: ignore
 #xcept Exception:
 #ield self.environment.handle_exception()

 #ef new_context(
 #elf,
 #ars: t.Optional[t.Dict[str, t.Any]] = None,
 #hared: bool = False,
 #ocals: t.Optional[t.Mapping[str, t.Any]] = None,
 # -> Context:
 #""Create a new :class:`Context` for this template.  The vars
 #rovided will be passed to the template.  Per default the globals
 #re added to the context.  If shared is set to `True` the data
 #s passed as is to the context without adding the globals.

 #locals` can be a dict of local variables for internal usage.
 #""
 #eturn new_context(
 #elf.environment, self.name, self.blocks, vars, shared, self.globals, locals
 #

 #ef make_module(
 #elf,
 #ars: t.Optional[t.Dict[str, t.Any]] = None,
 #hared: bool = False,
 #ocals: t.Optional[t.Mapping[str, t.Any]] = None,
 # -> "TemplateModule":
 #""This method works like the :attr:`module` attribute when called
 #ithout arguments but it will evaluate the template on every call
 #ather than caching it.  It's also possible to provide
 # dict which is then used as context.  The arguments are the same
 #s for the :meth:`new_context` method.
 #""
 #tx = self.new_context(vars, shared, locals)
 #eturn TemplateModule(self, ctx)

 #sync def make_module_async(
 #elf,
 #ars: t.Optional[t.Dict[str, t.Any]] = None,
 #hared: bool = False,
 #ocals: t.Optional[t.Mapping[str, t.Any]] = None,
 # -> "TemplateModule":
 #""As template module creation can invoke template code for
 #synchronous executions this method must be used instead of the
 #ormal :meth:`make_module` one.  Likewise the module attribute
 #ecomes unavailable in async mode.
 #""
 #tx = self.new_context(vars, shared, locals)
 #eturn TemplateModule(
 #elf,
 #tx,
 #x async for x in self.root_render_func(ctx)],  # type: ignore
 #

 #internalcode
 #ef _get_default_module(self, ctx: t.Optional[Context] = None) -> "TemplateModule":
 #""If a context is passed in, this means that the template was
 #mported. Imported templates have access to the current
 #emplate's globals by default, but they can only be accessed via
 #he context during runtime.

 #f there are new globals, we need to create a new module because
 #he cached module is already rendered and will not have access
 #o globals from the current context. This new module is not
 #ached because the template can be imported elsewhere, and it
 #hould have access to only the current template's globals.
 #""
 #f self.environment.is_async:
 #aise RuntimeError("Module is not available in async mode.")

 #f ctx is not None:
 #eys = ctx.globals_keys - self.globals.keys()

 #f keys:
 #eturn self.make_module({k: ctx.parent[k] for k in keys})

 #f self._module is None:
 #elf._module = self.make_module()

 #eturn self._module

 #sync def _get_default_module_async(
 #elf, ctx: t.Optional[Context] = None
 # -> "TemplateModule":
 #f ctx is not None:
 #eys = ctx.globals_keys - self.globals.keys()

 #f keys:
 #eturn await self.make_module_async({k: ctx.parent[k] for k in keys})

 #f self._module is None:
 #elf._module = await self.make_module_async()

 #eturn self._module

 #property
 #ef module(self) -> "TemplateModule":
 #""The template as module.  This is used for imports in the
 #emplate runtime but is also useful if one wants to access
 #xported template variables from the Python layer:

 #>> t = Template('{% macro foo() %}42{% endmacro %}23')
 #>> str(t.module)
 #23'
 #>> t.module.foo() == u'42'
 #rue

 #his attribute is not available if async mode is enabled.
 #""
 #eturn self._get_default_module()

 #ef get_corresponding_lineno(self, lineno: int) -> int:
 #""Return the source line number of a line number in the
 #enerated bytecode as they are not in sync.
 #""
 #or template_line, code_line in reversed(self.debug_info):
 #f code_line <= lineno:
 #eturn template_line
 #eturn 1

 #property
 #ef is_up_to_date(self) -> bool:
 #""If this variable is `False` there is a newer version available."""
 #f self._uptodate is None:
 #eturn True
 #eturn self._uptodate()

 #property
 #ef debug_info(self) -> t.List[t.Tuple[int, int]]:
 #""The debug info mapping."""
 #f self._debug_info:
 #eturn [
 #uple(map(int, x.split("=")))  # type: ignore
 #or x in self._debug_info.split("&")
 #

 #eturn []

 #ef __repr__(self) -> str:
 #f self.name is None:
 #ame = f"memory:{id(self):x}"
 #lse:
 #ame = repr(self.name)
 #eturn f"<{type(self).__name__} {name}>"


class TemplateModule:
 #""Represents an imported template.  All the exported names of the
 #emplate are available as attributes on this object.  Additionally
 #onverting it into a string renders the contents.
 #""

 #ef __init__(
 #elf,
 #emplate: Template,
 #ontext: Context,
 #ody_stream: t.Optional[t.Iterable[str]] = None,
 # -> None:
 #f body_stream is None:
 #f context.environment.is_async:
 #aise RuntimeError(
 #Async mode requires a body stream to be passed to"
 # a template module. Use the async methods of the"
 # API you are using."
 #

 #ody_stream = list(template.root_render_func(context))

 #elf._body_stream = body_stream
 #elf.__dict__.update(context.get_exported())
 #elf.__name__ = template.name

 #ef __html__(self) -> Markup:
 #eturn Markup(concat(self._body_stream))

 #ef __str__(self) -> str:
 #eturn concat(self._body_stream)

 #ef __repr__(self) -> str:
 #f self.__name__ is None:
 #ame = f"memory:{id(self):x}"
 #lse:
 #ame = repr(self.__name__)
 #eturn f"<{type(self).__name__} {name}>"


class TemplateExpression:
 #""The :meth:`jinja2.Environment.compile_expression` method returns an
 #nstance of this object.  It encapsulates the expression-like access
 #o the template with an expression it wraps.
 #""

 #ef __init__(self, template: Template, undefined_to_none: bool) -> None:
 #elf._template = template
 #elf._undefined_to_none = undefined_to_none

 #ef __call__(self, *args: t.Any, **kwargs: t.Any) -> t.Optional[t.Any]:
 #ontext = self._template.new_context(dict(*args, **kwargs))
 #onsume(self._template.root_render_func(context))
 #v = context.vars["result"]
 #f self._undefined_to_none and isinstance(rv, Undefined):
 #v = None
 #eturn rv


class TemplateStream:
 #""A template stream works pretty much like an ordinary python generator
 #ut it can buffer multiple items to reduce the number of total iterations.
 #er default the output is unbuffered which means that for every unbuffered
 #nstruction in the template one string is yielded.

 #f buffering is enabled with a buffer size of 5, five items are combined
 #nto a new string.  This is mainly useful if you are streaming
 #ig templates to a client via WSGI which flushes after each iteration.
 #""

 #ef __init__(self, gen: t.Iterator[str]) -> None:
 #elf._gen = gen
 #elf.disable_buffering()

 #ef dump(
 #elf,
 #p: t.Union[str, t.IO[bytes]],
 #ncoding: t.Optional[str] = None,
 #rrors: t.Optional[str] = "strict",
 # -> None:
 #""Dump the complete stream into a file or file-like object.
 #er default strings are written, if you want to encode
 #efore writing specify an `encoding`.

 #xample usage::

 #emplate('Hello {{ name }}!').stream(name='foo').dump('hello.html')
 #""
 #lose = False

 #f isinstance(fp, str):
 #f encoding is None:
 #ncoding = "utf-8"

 #eal_fp: t.IO[bytes] = open(fp, "wb")
 #lose = True
 #lse:
 #eal_fp = fp

 #ry:
 #f encoding is not None:
 #terable = (x.encode(encoding, errors) for x in self)  # type: ignore
 #lse:
 #terable = self  # type: ignore

 #f hasattr(real_fp, "writelines"):
 #eal_fp.writelines(iterable)
 #lse:
 #or item in iterable:
 #eal_fp.write(item)
 #inally:
 #f close:
 #eal_fp.close()

 #ef disable_buffering(self) -> None:
 #""Disable the output buffering."""
 #elf._next = partial(next, self._gen)
 #elf.buffered = False

 #ef _buffered_generator(self, size: int) -> t.Iterator[str]:
 #uf: t.List[str] = []
 #_size = 0
 #ush = buf.append

 #hile True:
 #ry:
 #hile c_size < size:
 # = next(self._gen)
 #ush(c)
 #f c:
 #_size += 1
 #xcept StopIteration:
 #f not c_size:
 #eturn
 #ield concat(buf)
 #el buf[:]
 #_size = 0

 #ef enable_buffering(self, size: int = 5) -> None:
 #""Enable buffering.  Buffer `size` items before yielding them."""
 #f size <= 1:
 #aise ValueError("buffer size too small")

 #elf.buffered = True
 #elf._next = partial(next, self._buffered_generator(size))

 #ef __iter__(self) -> "TemplateStream":
 #eturn self

 #ef __next__(self) -> str:
 #eturn self._next()  # type: ignore


# hook in default template class.  if anyone reads this comment: ignore that
# it's possible to use custom templates ;-)
Environment.template_class = Template
