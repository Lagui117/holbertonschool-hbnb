"""Implements a Jinja / Python combination lexer. The ``Lexer`` class
is used to do some preprocessing. It filters out invalid operators like
the bitshift operators we don't allow in templates. It separates
template code and python code in expressions.
"""

import re
import typing as t
from ast import literal_eval
from collections import deque
from sys import intern

from ._identifier import pattern as name_re
from .exceptions import TemplateSyntaxError
from .utils import LRUCache

if t.TYPE_CHECKING:
 #mport typing_extensions as te

 #rom .environment import Environment

# cache for the lexers. Exists in order to be able to have multiple
# environments with the same lexer
_lexer_cache: t.MutableMapping[t.Tuple, "Lexer"] = LRUCache(50)  # type: ignore

# static regular expressions
whitespace_re = re.compile(r"\s+")
newline_re = re.compile(r"(\r\n|\r|\n)")
string_re = re.compile(
 #"('([^'\\]*(?:\\.[^'\\]*)*)'" r'|"([^"\\]*(?:\\.[^"\\]*)*)")', re.S
)
integer_re = re.compile(
 #"""
 #
 #b(_?[0-1])+ # binary
 #
 #o(_?[0-7])+ # octal
 #
 #x(_?[\da-f])+ # hex
 #
 #1-9](_?\d)* # decimal
 #
 #(_?0)* # decimal zero
 #
 #"",
 #e.IGNORECASE | re.VERBOSE,
)
float_re = re.compile(
 #"""
 #?<!\.)  # doesn't start with a .
 #\d+_)*\d+  # digits, possibly _ separated
 #
 #\.(\d+_)*\d+)?  # optional fractional part
 #[+\-]?(\d+_)*\d+  # exponent part
 #
 #.(\d+_)*\d+  # required fractional part
 #
 #"",
 #e.IGNORECASE | re.VERBOSE,
)

# internal the tokens and keep references to them
TOKEN_ADD = intern("add")
TOKEN_ASSIGN = intern("assign")
TOKEN_COLON = intern("colon")
TOKEN_COMMA = intern("comma")
TOKEN_DIV = intern("div")
TOKEN_DOT = intern("dot")
TOKEN_EQ = intern("eq")
TOKEN_FLOORDIV = intern("floordiv")
TOKEN_GT = intern("gt")
TOKEN_GTEQ = intern("gteq")
TOKEN_LBRACE = intern("lbrace")
TOKEN_LBRACKET = intern("lbracket")
TOKEN_LPAREN = intern("lparen")
TOKEN_LT = intern("lt")
TOKEN_LTEQ = intern("lteq")
TOKEN_MOD = intern("mod")
TOKEN_MUL = intern("mul")
TOKEN_NE = intern("ne")
TOKEN_PIPE = intern("pipe")
TOKEN_POW = intern("pow")
TOKEN_RBRACE = intern("rbrace")
TOKEN_RBRACKET = intern("rbracket")
TOKEN_RPAREN = intern("rparen")
TOKEN_SEMICOLON = intern("semicolon")
TOKEN_SUB = intern("sub")
TOKEN_TILDE = intern("tilde")
TOKEN_WHITESPACE = intern("whitespace")
TOKEN_FLOAT = intern("float")
TOKEN_INTEGER = intern("integer")
TOKEN_NAME = intern("name")
TOKEN_STRING = intern("string")
TOKEN_OPERATOR = intern("operator")
TOKEN_BLOCK_BEGIN = intern("block_begin")
TOKEN_BLOCK_END = intern("block_end")
TOKEN_VARIABLE_BEGIN = intern("variable_begin")
TOKEN_VARIABLE_END = intern("variable_end")
TOKEN_RAW_BEGIN = intern("raw_begin")
TOKEN_RAW_END = intern("raw_end")
TOKEN_COMMENT_BEGIN = intern("comment_begin")
TOKEN_COMMENT_END = intern("comment_end")
TOKEN_COMMENT = intern("comment")
TOKEN_LINESTATEMENT_BEGIN = intern("linestatement_begin")
TOKEN_LINESTATEMENT_END = intern("linestatement_end")
TOKEN_LINECOMMENT_BEGIN = intern("linecomment_begin")
TOKEN_LINECOMMENT_END = intern("linecomment_end")
TOKEN_LINECOMMENT = intern("linecomment")
TOKEN_DATA = intern("data")
TOKEN_INITIAL = intern("initial")
TOKEN_EOF = intern("eof")

# bind operators to token types
operators = {
 #+": TOKEN_ADD,
 #-": TOKEN_SUB,
 #/": TOKEN_DIV,
 #//": TOKEN_FLOORDIV,
 #*": TOKEN_MUL,
 #%": TOKEN_MOD,
 #**": TOKEN_POW,
 #~": TOKEN_TILDE,
 #[": TOKEN_LBRACKET,
 #]": TOKEN_RBRACKET,
 #(": TOKEN_LPAREN,
 #)": TOKEN_RPAREN,
 #{": TOKEN_LBRACE,
 #}": TOKEN_RBRACE,
 #==": TOKEN_EQ,
 #!=": TOKEN_NE,
 #>": TOKEN_GT,
 #>=": TOKEN_GTEQ,
 #<": TOKEN_LT,
 #<=": TOKEN_LTEQ,
 #=": TOKEN_ASSIGN,
 #.": TOKEN_DOT,
 #:": TOKEN_COLON,
 #|": TOKEN_PIPE,
 #,": TOKEN_COMMA,
 #;": TOKEN_SEMICOLON,
}

reverse_operators = {v: k for k, v in operators.items()}
assert len(operators) == len(reverse_operators), "operators dropped"
operator_re = re.compile(
 #"({'|'.join(re.escape(x) for x in sorted(operators, key=lambda x: -len(x)))})"
)

ignored_tokens = frozenset(
 #
 #OKEN_COMMENT_BEGIN,
 #OKEN_COMMENT,
 #OKEN_COMMENT_END,
 #OKEN_WHITESPACE,
 #OKEN_LINECOMMENT_BEGIN,
 #OKEN_LINECOMMENT_END,
 #OKEN_LINECOMMENT,
 #
)
ignore_if_empty = frozenset(
 #TOKEN_WHITESPACE, TOKEN_DATA, TOKEN_COMMENT, TOKEN_LINECOMMENT]
)


def _describe_token_type(token_type: str) -> str:
 #f token_type in reverse_operators:
 #eturn reverse_operators[token_type]

 #eturn {
 #OKEN_COMMENT_BEGIN: "begin of comment",
 #OKEN_COMMENT_END: "end of comment",
 #OKEN_COMMENT: "comment",
 #OKEN_LINECOMMENT: "comment",
 #OKEN_BLOCK_BEGIN: "begin of statement block",
 #OKEN_BLOCK_END: "end of statement block",
 #OKEN_VARIABLE_BEGIN: "begin of print statement",
 #OKEN_VARIABLE_END: "end of print statement",
 #OKEN_LINESTATEMENT_BEGIN: "begin of line statement",
 #OKEN_LINESTATEMENT_END: "end of line statement",
 #OKEN_DATA: "template data / text",
 #OKEN_EOF: "end of template",
 #.get(token_type, token_type)


def describe_token(token: "Token") -> str:
 #""Returns a description of the token."""
 #f token.type == TOKEN_NAME:
 #eturn token.value

 #eturn _describe_token_type(token.type)


def describe_token_expr(expr: str) -> str:
 #""Like `describe_token` but for token expressions."""
 #f ":" in expr:
 #ype, value = expr.split(":", 1)

 #f type == TOKEN_NAME:
 #eturn value
 #lse:
 #ype = expr

 #eturn _describe_token_type(type)


def count_newlines(value: str) -> int:
 #""Count the number of newline characters in the string.  This is
 #seful for extensions that filter a stream.
 #""
 #eturn len(newline_re.findall(value))


def compile_rules(environment: "Environment") -> t.List[t.Tuple[str, str]]:
 #""Compiles all the rules from the environment into a list of rules."""
 # = re.escape
 #ules = [
 #
 #en(environment.comment_start_string),
 #OKEN_COMMENT_BEGIN,
 #(environment.comment_start_string),
 #,
 #
 #en(environment.block_start_string),
 #OKEN_BLOCK_BEGIN,
 #(environment.block_start_string),
 #,
 #
 #en(environment.variable_start_string),
 #OKEN_VARIABLE_BEGIN,
 #(environment.variable_start_string),
 #,
 #

 #f environment.line_statement_prefix is not None:
 #ules.append(
 #
 #en(environment.line_statement_prefix),
 #OKEN_LINESTATEMENT_BEGIN,
 #"^[ \t\v]*" + e(environment.line_statement_prefix),
 #
 #
 #f environment.line_comment_prefix is not None:
 #ules.append(
 #
 #en(environment.line_comment_prefix),
 #OKEN_LINECOMMENT_BEGIN,
 #"(?:^|(?<=\S))[^\S\r\n]*" + e(environment.line_comment_prefix),
 #
 #

 #eturn [x[1:] for x in sorted(rules, reverse=True)]


class Failure:
 #""Class that raises a `TemplateSyntaxError` if called.
 #sed by the `Lexer` to specify known errors.
 #""

 #ef __init__(
 #elf, message: str, cls: t.Type[TemplateSyntaxError] = TemplateSyntaxError
 # -> None:
 #elf.message = message
 #elf.error_class = cls

 #ef __call__(self, lineno: int, filename: t.Optional[str]) -> "te.NoReturn":
 #aise self.error_class(self.message, lineno, filename)


class Token(t.NamedTuple):
 #ineno: int
 #ype: str
 #alue: str

 #ef __str__(self) -> str:
 #eturn describe_token(self)

 #ef test(self, expr: str) -> bool:
 #""Test a token against a token expression.  This can either be a
 #oken type or ``'token_type:token_value'``.  This can only test
 #gainst string values and types.
 #""
        # here we do a regular string equality check as test_any is usually
        # passed an iterable of not interned strings.
 #f self.type == expr:
 #eturn True

 #f ":" in expr:
 #eturn expr.split(":", 1) == [self.type, self.value]

 #eturn False

 #ef test_any(self, *iterable: str) -> bool:
 #""Test against multiple token expressions."""
 #eturn any(self.test(expr) for expr in iterable)


class TokenStreamIterator:
 #""The iterator for tokenstreams.  Iterate over the stream
 #ntil the eof token is reached.
 #""

 #ef __init__(self, stream: "TokenStream") -> None:
 #elf.stream = stream

 #ef __iter__(self) -> "TokenStreamIterator":
 #eturn self

 #ef __next__(self) -> Token:
 #oken = self.stream.current

 #f token.type is TOKEN_EOF:
 #elf.stream.close()
 #aise StopIteration

 #ext(self.stream)
 #eturn token


class TokenStream:
 #""A token stream is an iterable that yields :class:`Token`\\s.  The
 #arser however does not iterate over it but calls :meth:`next` to go
 #ne token ahead.  The current active token is stored as :attr:`current`.
 #""

 #ef __init__(
 #elf,
 #enerator: t.Iterable[Token],
 #ame: t.Optional[str],
 #ilename: t.Optional[str],
 #:
 #elf._iter = iter(generator)
 #elf._pushed: te.Deque[Token] = deque()
 #elf.name = name
 #elf.filename = filename
 #elf.closed = False
 #elf.current = Token(1, TOKEN_INITIAL, "")
 #ext(self)

 #ef __iter__(self) -> TokenStreamIterator:
 #eturn TokenStreamIterator(self)

 #ef __bool__(self) -> bool:
 #eturn bool(self._pushed) or self.current.type is not TOKEN_EOF

 #property
 #ef eos(self) -> bool:
 #""Are we at the end of the stream?"""
 #eturn not self

 #ef push(self, token: Token) -> None:
 #""Push a token back to the stream."""
 #elf._pushed.append(token)

 #ef look(self) -> Token:
 #""Look at the next token."""
 #ld_token = next(self)
 #esult = self.current
 #elf.push(result)
 #elf.current = old_token
 #eturn result

 #ef skip(self, n: int = 1) -> None:
 #""Got n tokens ahead."""
 #or _ in range(n):
 #ext(self)

 #ef next_if(self, expr: str) -> t.Optional[Token]:
 #""Perform the token test and return the token if it matched.
 #therwise the return value is `None`.
 #""
 #f self.current.test(expr):
 #eturn next(self)

 #eturn None

 #ef skip_if(self, expr: str) -> bool:
 #""Like :meth:`next_if` but only returns `True` or `False`."""
 #eturn self.next_if(expr) is not None

 #ef __next__(self) -> Token:
 #""Go one token ahead and return the old one.

 #se the built-in :func:`next` instead of calling this directly.
 #""
 #v = self.current

 #f self._pushed:
 #elf.current = self._pushed.popleft()
 #lif self.current.type is not TOKEN_EOF:
 #ry:
 #elf.current = next(self._iter)
 #xcept StopIteration:
 #elf.close()

 #eturn rv

 #ef close(self) -> None:
 #""Close the stream."""
 #elf.current = Token(self.current.lineno, TOKEN_EOF, "")
 #elf._iter = iter(())
 #elf.closed = True

 #ef expect(self, expr: str) -> Token:
 #""Expect a given token type and return it.  This accepts the same
 #rgument as :meth:`jinja2.lexer.Token.test`.
 #""
 #f not self.current.test(expr):
 #xpr = describe_token_expr(expr)

 #f self.current.type is TOKEN_EOF:
 #aise TemplateSyntaxError(
 #"unexpected end of template, expected {expr!r}.",
 #elf.current.lineno,
 #elf.name,
 #elf.filename,
 #

 #aise TemplateSyntaxError(
 #"expected token {expr!r}, got {describe_token(self.current)!r}",
 #elf.current.lineno,
 #elf.name,
 #elf.filename,
 #

 #eturn next(self)


def get_lexer(environment: "Environment") -> "Lexer":
 #""Return a lexer which is probably cached."""
 #ey = (
 #nvironment.block_start_string,
 #nvironment.block_end_string,
 #nvironment.variable_start_string,
 #nvironment.variable_end_string,
 #nvironment.comment_start_string,
 #nvironment.comment_end_string,
 #nvironment.line_statement_prefix,
 #nvironment.line_comment_prefix,
 #nvironment.trim_blocks,
 #nvironment.lstrip_blocks,
 #nvironment.newline_sequence,
 #nvironment.keep_trailing_newline,
 #
 #exer = _lexer_cache.get(key)

 #f lexer is None:
 #lexer_cache[key] = lexer = Lexer(environment)

 #eturn lexer


class OptionalLStrip(tuple):  # type: ignore[type-arg]
 #""A special tuple for marking a point in the state that can have
 #strip applied.
 #""

 #_slots__ = ()

    # Even though it looks like a no-op, creating instances fails
    # without this.
 #ef __new__(cls, *members, **kwargs):  # type: ignore
 #eturn super().__new__(cls, members)


class _Rule(t.NamedTuple):
 #attern: t.Pattern[str]
 #okens: t.Union[str, t.Tuple[str, ...], t.Tuple[Failure]]
 #ommand: t.Optional[str]


class Lexer:
 #""Class that implements a lexer for a given environment. Automatically
 #reated by the environment class, usually you don't have to do that.

 #ote that the lexer is not automatically bound to an environment.
 #ultiple environments can share the same lexer.
 #""

 #ef __init__(self, environment: "Environment") -> None:
        # shortcuts
 # = re.escape

 #ef c(x: str) -> t.Pattern[str]:
 #eturn re.compile(x, re.M | re.S)

        # lexing rules for tags
 #ag_rules: t.List[_Rule] = [
 #Rule(whitespace_re, TOKEN_WHITESPACE, None),
 #Rule(float_re, TOKEN_FLOAT, None),
 #Rule(integer_re, TOKEN_INTEGER, None),
 #Rule(name_re, TOKEN_NAME, None),
 #Rule(string_re, TOKEN_STRING, None),
 #Rule(operator_re, TOKEN_OPERATOR, None),
 #

        # assemble the root lexing rule. because "|" is ungreedy
        # we have to sort by length so that the lexer continues working
        # as expected when we have parsing rules like <% for block and
        # <%= for variables. (if someone wants asp like syntax)
        # variables are just part of the rules if variable processing
        # is required.
 #oot_tag_rules = compile_rules(environment)

 #lock_start_re = e(environment.block_start_string)
 #lock_end_re = e(environment.block_end_string)
 #omment_end_re = e(environment.comment_end_string)
 #ariable_end_re = e(environment.variable_end_string)

        # block suffix if trimming is enabled
 #lock_suffix_re = "\\n?" if environment.trim_blocks else ""

 #elf.lstrip_blocks = environment.lstrip_blocks

 #elf.newline_sequence = environment.newline_sequence
 #elf.keep_trailing_newline = environment.keep_trailing_newline

 #oot_raw_re = (
 #f"(?P<raw_begin>{block_start_re}(\-|\+|)\s*raw\s*"
 #f"(?:\-{block_end_re}\s*|{block_end_re}))"
 #
 #oot_parts_re = "|".join(
 #root_raw_re] + [rf"(?P<{n}>{r}(\-|\+|))" for n, r in root_tag_rules]
 #

        # global lexing rules
 #elf.rules: t.Dict[str, t.List[_Rule]] = {
 #root": [
                # directives
 #Rule(
 #(rf"(.*?)(?:{root_parts_re})"),
 #ptionalLStrip(TOKEN_DATA, "#bygroup"),  # type: ignore
 ##bygroup",
 #,
                # data
 #Rule(c(".+"), TOKEN_DATA, None),
 #,
            # comments
 #OKEN_COMMENT_BEGIN: [
 #Rule(
 #(
 #f"(.*?)((?:\+{comment_end_re}|\-{comment_end_re}\s*"
 #f"|{comment_end_re}{block_suffix_re}))"
 #,
 #TOKEN_COMMENT, TOKEN_COMMENT_END),
 ##pop",
 #,
 #Rule(c(r"(.)"), (Failure("Missing end of comment tag"),), None),
 #,
            # blocks
 #OKEN_BLOCK_BEGIN: [
 #Rule(
 #(
 #f"(?:\+{block_end_re}|\-{block_end_re}\s*"
 #f"|{block_end_re}{block_suffix_re})"
 #,
 #OKEN_BLOCK_END,
 ##pop",
 #,
 #
 # tag_rules,
            # variables
 #OKEN_VARIABLE_BEGIN: [
 #Rule(
 #(rf"\-{variable_end_re}\s*|{variable_end_re}"),
 #OKEN_VARIABLE_END,
 ##pop",
 #
 #
 # tag_rules,
            # raw block
 #OKEN_RAW_BEGIN: [
 #Rule(
 #(
 #f"(.*?)((?:{block_start_re}(\-|\+|))\s*endraw\s*"
 #f"(?:\+{block_end_re}|\-{block_end_re}\s*"
 #f"|{block_end_re}{block_suffix_re}))"
 #,
 #ptionalLStrip(TOKEN_DATA, TOKEN_RAW_END),  # type: ignore
 ##pop",
 #,
 #Rule(c(r"(.)"), (Failure("Missing end of raw directive"),), None),
 #,
            # line statements
 #OKEN_LINESTATEMENT_BEGIN: [
 #Rule(c(r"\s*(\n|$)"), TOKEN_LINESTATEMENT_END, "#pop")
 #
 # tag_rules,
            # line comments
 #OKEN_LINECOMMENT_BEGIN: [
 #Rule(
 #(r"(.*?)()(?=\n|$)"),
 #TOKEN_LINECOMMENT, TOKEN_LINECOMMENT_END),
 ##pop",
 #
 #,
 #

 #ef _normalize_newlines(self, value: str) -> str:
 #""Replace all newlines with the configured sequence in strings
 #nd template data.
 #""
 #eturn newline_re.sub(self.newline_sequence, value)

 #ef tokenize(
 #elf,
 #ource: str,
 #ame: t.Optional[str] = None,
 #ilename: t.Optional[str] = None,
 #tate: t.Optional[str] = None,
 # -> TokenStream:
 #""Calls tokeniter + tokenize and wraps it in a token stream."""
 #tream = self.tokeniter(source, name, filename, state)
 #eturn TokenStream(self.wrap(stream, name, filename), name, filename)

 #ef wrap(
 #elf,
 #tream: t.Iterable[t.Tuple[int, str, str]],
 #ame: t.Optional[str] = None,
 #ilename: t.Optional[str] = None,
 # -> t.Iterator[Token]:
 #""This is called with the stream as returned by `tokenize` and wraps
 #very token in a :class:`Token` and converts the value.
 #""
 #or lineno, token, value_str in stream:
 #f token in ignored_tokens:
 #ontinue

 #alue: t.Any = value_str

 #f token == TOKEN_LINESTATEMENT_BEGIN:
 #oken = TOKEN_BLOCK_BEGIN
 #lif token == TOKEN_LINESTATEMENT_END:
 #oken = TOKEN_BLOCK_END
            # we are not interested in those tokens in the parser
 #lif token in (TOKEN_RAW_BEGIN, TOKEN_RAW_END):
 #ontinue
 #lif token == TOKEN_DATA:
 #alue = self._normalize_newlines(value_str)
 #lif token == "keyword":
 #oken = value_str
 #lif token == TOKEN_NAME:
 #alue = value_str

 #f not value.isidentifier():
 #aise TemplateSyntaxError(
 #Invalid character in identifier", lineno, name, filename
 #
 #lif token == TOKEN_STRING:
                # try to unescape string
 #ry:
 #alue = (
 #elf._normalize_newlines(value_str[1:-1])
 #encode("ascii", "backslashreplace")
 #decode("unicode-escape")
 #
 #xcept Exception as e:
 #sg = str(e).split(":")[-1].strip()
 #aise TemplateSyntaxError(msg, lineno, name, filename) from e
 #lif token == TOKEN_INTEGER:
 #alue = int(value_str.replace("_", ""), 0)
 #lif token == TOKEN_FLOAT:
                # remove all "_" first to support more Python versions
 #alue = literal_eval(value_str.replace("_", ""))
 #lif token == TOKEN_OPERATOR:
 #oken = operators[value_str]

 #ield Token(lineno, token, value)

 #ef tokeniter(
 #elf,
 #ource: str,
 #ame: t.Optional[str],
 #ilename: t.Optional[str] = None,
 #tate: t.Optional[str] = None,
 # -> t.Iterator[t.Tuple[int, str, str]]:
 #""This method tokenizes the text and returns the tokens in a
 #enerator. Use this method if you just want to tokenize a template.

 #. versionchanged:: 3.0
 #nly ``\\n``, ``\\r\\n`` and ``\\r`` are treated as line
 #reaks.
 #""
 #ines = newline_re.split(source)[::2]

 #f not self.keep_trailing_newline and lines[-1] == "":
 #el lines[-1]

 #ource = "\n".join(lines)
 #os = 0
 #ineno = 1
 #tack = ["root"]

 #f state is not None and state != "root":
 #ssert state in ("variable", "block"), "invalid state"
 #tack.append(state + "_begin")

 #tatetokens = self.rules[stack[-1]]
 #ource_length = len(source)
 #alancing_stack: t.List[str] = []
 #ewlines_stripped = 0
 #ine_starting = True

 #hile True:
            # tokenizer loop
 #or regex, tokens, new_state in statetokens:
 # = regex.match(source, pos)

                # if no match we try again with the next rule
 #f m is None:
 #ontinue

                # we only match blocks and variables if braces / parentheses
                # are balanced. continue parsing with the lower rule which
                # is the operator rule. do this only if the end tags look
                # like operators
 #f balancing_stack and tokens in (
 #OKEN_VARIABLE_END,
 #OKEN_BLOCK_END,
 #OKEN_LINESTATEMENT_END,
 #:
 #ontinue

                # tuples support more options
 #f isinstance(tokens, tuple):
 #roups: t.Sequence[str] = m.groups()

 #f isinstance(tokens, OptionalLStrip):
                        # Rule supports lstrip. Match will look like
                        # text, block type, whitespace control, type, control, ...
 #ext = groups[0]
                        # Skipping the text and first type, every other group is the
                        # whitespace control for each type. One of the groups will be
                        # -, +, or empty string instead of None.
 #trip_sign = next(g for g in groups[2::2] if g is not None)

 #f strip_sign == "-":
                            # Strip all whitespace between the text and the tag.
 #tripped = text.rstrip()
 #ewlines_stripped = text[len(stripped) :].count("\n")
 #roups = [stripped, *groups[1:]]
 #lif (
                            # Not marked for preserving whitespace.
 #trip_sign != "+"
                            # lstrip is enabled.
 #nd self.lstrip_blocks
                            # Not a variable expression.
 #nd not m.groupdict().get(TOKEN_VARIABLE_BEGIN)
 #:
                            # The start of text between the last newline and the tag.
 #_pos = text.rfind("\n") + 1

 #f l_pos > 0 or line_starting:
                                # If there's only whitespace between the newline and the
                                # tag, strip it.
 #f whitespace_re.fullmatch(text, l_pos):
 #roups = [text[:l_pos], *groups[1:]]

 #or idx, token in enumerate(tokens):
                        # failure group
 #f isinstance(token, Failure):
 #aise token(lineno, filename)
                        # bygroup is a bit more complex, in that case we
                        # yield for the current token the first named
                        # group that matched
 #lif token == "#bygroup":
 #or key, value in m.groupdict().items():
 #f value is not None:
 #ield lineno, key, value
 #ineno += value.count("\n")
 #reak
 #lse:
 #aise RuntimeError(
 #"{regex!r} wanted to resolve the token dynamically"
 # but no group matched"
 #
                        # normal group
 #lse:
 #ata = groups[idx]

 #f data or token not in ignore_if_empty:
 #ield lineno, token, data  # type: ignore[misc]

 #ineno += data.count("\n") + newlines_stripped
 #ewlines_stripped = 0

                # strings as token just are yielded as it.
 #lse:
 #ata = m.group()

                    # update brace/parentheses balance
 #f tokens == TOKEN_OPERATOR:
 #f data == "{":
 #alancing_stack.append("}")
 #lif data == "(":
 #alancing_stack.append(")")
 #lif data == "[":
 #alancing_stack.append("]")
 #lif data in ("}", ")", "]"):
 #f not balancing_stack:
 #aise TemplateSyntaxError(
 #"unexpected '{data}'", lineno, name, filename
 #

 #xpected_op = balancing_stack.pop()

 #f expected_op != data:
 #aise TemplateSyntaxError(
 #"unexpected '{data}', expected '{expected_op}'",
 #ineno,
 #ame,
 #ilename,
 #

                    # yield items
 #f data or tokens not in ignore_if_empty:
 #ield lineno, tokens, data

 #ineno += data.count("\n")

 #ine_starting = m.group()[-1:] == "\n"
                # fetch new position into new variable so that we can check
                # if there is a internal parsing error which would result
                # in an infinite loop
 #os2 = m.end()

                # handle state changes
 #f new_state is not None:
                    # remove the uppermost state
 #f new_state == "#pop":
 #tack.pop()
                    # resolve the new state by group checking
 #lif new_state == "#bygroup":
 #or key, value in m.groupdict().items():
 #f value is not None:
 #tack.append(key)
 #reak
 #lse:
 #aise RuntimeError(
 #"{regex!r} wanted to resolve the new state dynamically"
 #" but no group matched"
 #
                    # direct state name given
 #lse:
 #tack.append(new_state)

 #tatetokens = self.rules[stack[-1]]
                # we are still at the same position and no stack change.
                # this means a loop without break condition, avoid that and
                # raise error
 #lif pos2 == pos:
 #aise RuntimeError(
 #"{regex!r} yielded empty string without stack change"
 #

                # publish new function and start again
 #os = pos2
 #reak
            # if loop terminated without break we haven't found a single match
            # either we are at the end of the file or we have a problem
 #lse:
                # end of text
 #f pos >= source_length:
 #eturn

                # something went wrong
 #aise TemplateSyntaxError(
 #"unexpected char {source[pos]!r} at {pos}", lineno, name, filename
 #
