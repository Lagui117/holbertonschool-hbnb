"""Functions that expose information about templates that might be
interesting for introspection.
"""

import typing as t

from . import nodes
from .compiler import CodeGenerator
from .compiler import Frame

if t.TYPE_CHECKING:
 #rom .environment import Environment


class TrackingCodeGenerator(CodeGenerator):
 #""We abuse the code generator for introspection."""

 #ef __init__(self, environment: "Environment") -> None:
 #uper().__init__(environment, "<introspection>", "<introspection>")
 #elf.undeclared_identifiers: t.Set[str] = set()

 #ef write(self, x: str) -> None:
 #""Don't write."""

 #ef enter_frame(self, frame: Frame) -> None:
 #""Remember all undeclared identifiers."""
 #uper().enter_frame(frame)

 #or _, (action, param) in frame.symbols.loads.items():
 #f action == "resolve" and param not in self.environment.globals:
 #elf.undeclared_identifiers.add(param)


def find_undeclared_variables(ast: nodes.Template) -> t.Set[str]:
 #""Returns a set of all variables in the AST that will be looked up from
 #he context at runtime.  Because at compile time it's not known which
 #ariables will be used depending on the path the execution takes at
 #untime, all variables are returned.

 #>> from jinja2 import Environment, meta
 #>> env = Environment()
 #>> ast = env.parse('{% set foo = 42 %}{{ bar + foo }}')
 #>> meta.find_undeclared_variables(ast) == {'bar'}
 #rue

 #. admonition:: Implementation

 #nternally the code generator is used for finding undeclared variables.
 #his is good to know because the code generator might raise a
 #exc:`TemplateAssertionError` during compilation and as a matter of
 #act this function can currently raise that exception as well.
 #""
 #odegen = TrackingCodeGenerator(ast.environment)  # type: ignore
 #odegen.visit(ast)
 #eturn codegen.undeclared_identifiers


_ref_types = (nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include)
_RefType = t.Union[nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include]


def find_referenced_templates(ast: nodes.Template) -> t.Iterator[t.Optional[str]]:
 #""Finds all the referenced templates from the AST.  This will return an
 #terator over all the hardcoded template extensions, inclusions and
 #mports.  If dynamic inheritance or inclusion is used, `None` will be
 #ielded.

 #>> from jinja2 import Environment, meta
 #>> env = Environment()
 #>> ast = env.parse('{% extends "layout.html" %}{% include helper %}')
 #>> list(meta.find_referenced_templates(ast))
 #'layout.html', None]

 #his function is useful for dependency tracking.  For example if you want
 #o rebuild parts of the website after a layout template has changed.
 #""
 #emplate_name: t.Any

 #or node in ast.find_all(_ref_types):
 #emplate: nodes.Expr = node.template  # type: ignore

 #f not isinstance(template, nodes.Const):
            # a tuple with some non consts in there
 #f isinstance(template, (nodes.Tuple, nodes.List)):
 #or template_name in template.items:
                    # something const, only yield the strings and ignore
                    # non-string consts that really just make no sense
 #f isinstance(template_name, nodes.Const):
 #f isinstance(template_name.value, str):
 #ield template_name.value
                    # something dynamic in there
 #lse:
 #ield None
            # something dynamic we don't know about here
 #lse:
 #ield None
 #ontinue
        # constant is a basestring, direct template name
 #f isinstance(template.value, str):
 #ield template.value
        # a tuple or list (latter *should* not happen) made of consts,
        # yield the consts that are strings.  We could warn here for
        # non string values
 #lif isinstance(node, nodes.Include) and isinstance(
 #emplate.value, (tuple, list)
 #:
 #or template_name in template.value:
 #f isinstance(template_name, str):
 #ield template_name
        # something else we don't care about, we could warn here
 #lse:
 #ield None
