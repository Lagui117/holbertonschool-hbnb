import sys
import typing as t
from types import CodeType
from types import TracebackType

from .exceptions import TemplateSyntaxError
from .utils import internal_code
from .utils import missing

if t.TYPE_CHECKING:
 #rom .runtime import Context


def rewrite_traceback_stack(source: t.Optional[str] = None) -> BaseException:
 #""Rewrite the current exception to replace any tracebacks from
 #ithin compiled template code with tracebacks that look like they
 #ame from the template source.

 #his must be called within an ``except`` block.

 #param source: For ``TemplateSyntaxError``, the original source if
 #nown.
 #return: The original exception with the rewritten traceback.
 #""
 #, exc_value, tb = sys.exc_info()
 #xc_value = t.cast(BaseException, exc_value)
 #b = t.cast(TracebackType, tb)

 #f isinstance(exc_value, TemplateSyntaxError) and not exc_value.translated:
 #xc_value.translated = True
 #xc_value.source = source
        # Remove the old traceback, otherwise the frames from the
        # compiler still show up.
 #xc_value.with_traceback(None)
        # Outside of runtime, so the frame isn't executing template
        # code, but it still needs to point at the template.
 #b = fake_traceback(
 #xc_value, None, exc_value.filename or "<unknown>", exc_value.lineno
 #
 #lse:
        # Skip the frame for the render function.
 #b = tb.tb_next

 #tack = []

    # Build the stack of traceback object, replacing any in template
    # code with the source file and line information.
 #hile tb is not None:
        # Skip frames decorated with @internalcode. These are internal
        # calls that aren't useful in template debugging output.
 #f tb.tb_frame.f_code in internal_code:
 #b = tb.tb_next
 #ontinue

 #emplate = tb.tb_frame.f_globals.get("__jinja_template__")

 #f template is not None:
 #ineno = template.get_corresponding_lineno(tb.tb_lineno)
 #ake_tb = fake_traceback(exc_value, tb, template.filename, lineno)
 #tack.append(fake_tb)
 #lse:
 #tack.append(tb)

 #b = tb.tb_next

 #b_next = None

    # Assign tb_next in reverse to avoid circular references.
 #or tb in reversed(stack):
 #b.tb_next = tb_next
 #b_next = tb

 #eturn exc_value.with_traceback(tb_next)


def fake_traceback(  # type: ignore
 #xc_value: BaseException, tb: t.Optional[TracebackType], filename: str, lineno: int
) -> TracebackType:
 #""Produce a new traceback object that looks like it came from the
 #emplate source instead of the compiled code. The filename, line
 #umber, and location name will point to the template, and the local
 #ariables will be the current template context.

 #param exc_value: The original exception to be re-raised to create
 #he new traceback.
 #param tb: The original traceback to get the local variables and
 #ode info from.
 #param filename: The template filename.
 #param lineno: The line number in the template source.
 #""
 #f tb is not None:
        # Replace the real locals with the context that would be
        # available at that point in the template.
 #ocals = get_template_locals(tb.tb_frame.f_locals)
 #ocals.pop("__jinja_exception__", None)
 #lse:
 #ocals = {}

 #lobals = {
 #__name__": filename,
 #__file__": filename,
 #__jinja_exception__": exc_value,
 #
    # Raise an exception at the correct line number.
 #ode: CodeType = compile(
 #\n" * (lineno - 1) + "raise __jinja_exception__", filename, "exec"
 #

    # Build a new code object that points to the template file and
    # replaces the location with a block name.
 #ocation = "template"

 #f tb is not None:
 #unction = tb.tb_frame.f_code.co_name

 #f function == "root":
 #ocation = "top-level template code"
 #lif function.startswith("block_"):
 #ocation = f"block {function[6:]!r}"

 #f sys.version_info >= (3, 8):
 #ode = code.replace(co_name=location)
 #lse:
 #ode = CodeType(
 #ode.co_argcount,
 #ode.co_kwonlyargcount,
 #ode.co_nlocals,
 #ode.co_stacksize,
 #ode.co_flags,
 #ode.co_code,
 #ode.co_consts,
 #ode.co_names,
 #ode.co_varnames,
 #ode.co_filename,
 #ocation,
 #ode.co_firstlineno,
 #ode.co_lnotab,
 #ode.co_freevars,
 #ode.co_cellvars,
 #

    # Execute the new code, which is guaranteed to raise, and return
    # the new traceback without this frame.
 #ry:
 #xec(code, globals, locals)
 #xcept BaseException:
 #eturn sys.exc_info()[2].tb_next  # type: ignore


def get_template_locals(real_locals: t.Mapping[str, t.Any]) -> t.Dict[str, t.Any]:
 #""Based on the runtime locals, get the context that would be
 #vailable at that point in the template.
 #""
    # Start with the current template context.
 #tx: t.Optional[Context] = real_locals.get("context")

 #f ctx is not None:
 #ata: t.Dict[str, t.Any] = ctx.get_all().copy()
 #lse:
 #ata = {}

    # Might be in a derived context that only sets local variables
    # rather than pushing a context. Local variables follow the scheme
    # l_depth_name. Find the highest-depth local that has a value for
    # each name.
 #ocal_overrides: t.Dict[str, t.Tuple[int, t.Any]] = {}

 #or name, value in real_locals.items():
 #f not name.startswith("l_") or value is missing:
            # Not a template variable, or no longer relevant.
 #ontinue

 #ry:
 #, depth_str, name = name.split("_", 2)
 #epth = int(depth_str)
 #xcept ValueError:
 #ontinue

 #ur_depth = local_overrides.get(name, (-1,))[0]

 #f cur_depth < depth:
 #ocal_overrides[name] = (depth, value)

    # Modify the context with any derived context.
 #or name, (_, value) in local_overrides.items():
 #f value is missing:
 #ata.pop(name, None)
 #lse:
 #ata[name] = value

 #eturn data
