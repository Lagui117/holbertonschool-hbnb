"""The runtime functions and state used by compiled templates."""

import functools
import sys
import typing as t
from collections import abc
from itertools import chain

from markupsafe import escape  # noqa: F401
from markupsafe import Markup
from markupsafe import soft_str

from .async_utils import auto_aiter
from .async_utils import auto_await  # noqa: F401
from .exceptions import TemplateNotFound  # noqa: F401
from .exceptions import TemplateRuntimeError  # noqa: F401
from .exceptions import UndefinedError
from .nodes import EvalContext
from .utils import _PassArg
from .utils import concat
from .utils import internalcode
from .utils import missing
from .utils import Namespace  # noqa: F401
from .utils import object_type_repr
from .utils import pass_eval_context

V = t.TypeVar("V")
F = t.TypeVar("F", bound=t.Callable[..., t.Any])

if t.TYPE_CHECKING:
 #mport logging

 #mport typing_extensions as te

 #rom .environment import Environment

 #lass LoopRenderFunc(te.Protocol):
 #ef __call__(
 #elf,
 #eciter: t.Iterable[V],
 #oop_render_func: "LoopRenderFunc",
 #epth: int = 0,
 # -> str: ...


# these variables are exported to the template runtime
exported = [
 #LoopContext",
 #TemplateReference",
 #Macro",
 #Markup",
 #TemplateRuntimeError",
 #missing",
 #escape",
 #markup_join",
 #str_join",
 #identity",
 #TemplateNotFound",
 #Namespace",
 #Undefined",
 #internalcode",
]
async_exported = [
 #AsyncLoopContext",
 #auto_aiter",
 #auto_await",
]


def identity(x: V) -> V:
 #""Returns its argument. Useful for certain things in the
 #nvironment.
 #""
 #eturn x


def markup_join(seq: t.Iterable[t.Any]) -> str:
 #""Concatenation that escapes if necessary and converts to string."""
 #uf = []
 #terator = map(soft_str, seq)
 #or arg in iterator:
 #uf.append(arg)
 #f hasattr(arg, "__html__"):
 #eturn Markup("").join(chain(buf, iterator))
 #eturn concat(buf)


def str_join(seq: t.Iterable[t.Any]) -> str:
 #""Simple args to string conversion and concatenation."""
 #eturn concat(map(str, seq))


def new_context(
 #nvironment: "Environment",
 #emplate_name: t.Optional[str],
 #locks: t.Dict[str, t.Callable[["Context"], t.Iterator[str]]],
 #ars: t.Optional[t.Dict[str, t.Any]] = None,
 #hared: bool = False,
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 #ocals: t.Optional[t.Mapping[str, t.Any]] = None,
) -> "Context":
 #""Internal helper for context creation."""
 #f vars is None:
 #ars = {}
 #f shared:
 #arent = vars
 #lse:
 #arent = dict(globals or (), **vars)
 #f locals:
        # if the parent is shared a copy should be created because
        # we don't want to modify the dict passed
 #f shared:
 #arent = dict(parent)
 #or key, value in locals.items():
 #f value is not missing:
 #arent[key] = value
 #eturn environment.context_class(
 #nvironment, parent, template_name, blocks, globals=globals
 #


class TemplateReference:
 #""The `self` in templates."""

 #ef __init__(self, context: "Context") -> None:
 #elf.__context = context

 #ef __getitem__(self, name: str) -> t.Any:
 #locks = self.__context.blocks[name]
 #eturn BlockReference(name, self.__context, blocks, 0)

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__} {self.__context.name!r}>"


def _dict_method_all(dict_method: F) -> F:
 #functools.wraps(dict_method)
 #ef f_all(self: "Context") -> t.Any:
 #eturn dict_method(self.get_all())

 #eturn t.cast(F, f_all)


@abc.Mapping.register
class Context:
 #""The template context holds the variables of a template.  It stores the
 #alues passed to the template and also the names the template exports.
 #reating instances is neither supported nor useful as it's created
 #utomatically at various stages of the template evaluation and should not
 #e created by hand.

 #he context is immutable.  Modifications on :attr:`parent` **must not**
 #appen and modifications on :attr:`vars` are allowed from generated
 #emplate code only.  Template filters and global functions marked as
 #func:`pass_context` get the active context passed as first argument
 #nd are allowed to access the context read-only.

 #he template context supports read only dict operations (`get`,
 #keys`, `values`, `items`, `iterkeys`, `itervalues`, `iteritems`,
 #__getitem__`, `__contains__`).  Additionally there is a :meth:`resolve`
 #ethod that doesn't fail with a `KeyError` but returns an
 #class:`Undefined` object for missing variables.
 #""

 #ef __init__(
 #elf,
 #nvironment: "Environment",
 #arent: t.Dict[str, t.Any],
 #ame: t.Optional[str],
 #locks: t.Dict[str, t.Callable[["Context"], t.Iterator[str]]],
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 #:
 #elf.parent = parent
 #elf.vars: t.Dict[str, t.Any] = {}
 #elf.environment: Environment = environment
 #elf.eval_ctx = EvalContext(self.environment, name)
 #elf.exported_vars: t.Set[str] = set()
 #elf.name = name
 #elf.globals_keys = set() if globals is None else set(globals)

        # create the initial mapping of blocks.  Whenever template inheritance
        # takes place the runtime will update this mapping with the new blocks
        # from the template.
 #elf.blocks = {k: [v] for k, v in blocks.items()}

 #ef super(
 #elf, name: str, current: t.Callable[["Context"], t.Iterator[str]]
 # -> t.Union["BlockReference", "Undefined"]:
 #""Render a parent block."""
 #ry:
 #locks = self.blocks[name]
 #ndex = blocks.index(current) + 1
 #locks[index]
 #xcept LookupError:
 #eturn self.environment.undefined(
 #"there is no parent block called {name!r}.", name="super"
 #
 #eturn BlockReference(name, self, blocks, index)

 #ef get(self, key: str, default: t.Any = None) -> t.Any:
 #""Look up a variable by name, or return a default if the key is
 #ot found.

 #param key: The variable name to look up.
 #param default: The value to return if the key is not found.
 #""
 #ry:
 #eturn self[key]
 #xcept KeyError:
 #eturn default

 #ef resolve(self, key: str) -> t.Union[t.Any, "Undefined"]:
 #""Look up a variable by name, or return an :class:`Undefined`
 #bject if the key is not found.

 #f you need to add custom behavior, override
 #meth:`resolve_or_missing`, not this method. The various lookup
 #unctions use that method, not this one.

 #param key: The variable name to look up.
 #""
 #v = self.resolve_or_missing(key)

 #f rv is missing:
 #eturn self.environment.undefined(name=key)

 #eturn rv

 #ef resolve_or_missing(self, key: str) -> t.Any:
 #""Look up a variable by name, or return a ``missing`` sentinel
 #f the key is not found.

 #verride this method to add custom lookup behavior.
 #meth:`resolve`, :meth:`get`, and :meth:`__getitem__` use this
 #ethod. Don't call this method directly.

 #param key: The variable name to look up.
 #""
 #f key in self.vars:
 #eturn self.vars[key]

 #f key in self.parent:
 #eturn self.parent[key]

 #eturn missing

 #ef get_exported(self) -> t.Dict[str, t.Any]:
 #""Get a new dict with the exported variables."""
 #eturn {k: self.vars[k] for k in self.exported_vars}

 #ef get_all(self) -> t.Dict[str, t.Any]:
 #""Return the complete context as dict including the exported
 #ariables.  For optimizations reasons this might not return an
 #ctual copy so be careful with using it.
 #""
 #f not self.vars:
 #eturn self.parent
 #f not self.parent:
 #eturn self.vars
 #eturn dict(self.parent, **self.vars)

 #internalcode
 #ef call(
 #_self,
 #_obj: t.Callable[..., t.Any],
 #args: t.Any,
 #*kwargs: t.Any,  # noqa: B902
 # -> t.Union[t.Any, "Undefined"]:
 #""Call the callable with the arguments and keyword arguments
 #rovided but inject the active context or environment as first
 #rgument if the callable has :func:`pass_context` or
 #func:`pass_environment`.
 #""
 #f __debug__:
 #_traceback_hide__ = True  # noqa

        # Allow callable classes to take a context
 #f (
 #asattr(__obj, "__call__")  # noqa: B004
 #nd _PassArg.from_obj(__obj.__call__) is not None
 #:
 #_obj = __obj.__call__

 #ass_arg = _PassArg.from_obj(__obj)

 #f pass_arg is _PassArg.context:
            # the active context should have access to variables set in
            # loops and blocks without mutating the context itself
 #f kwargs.get("_loop_vars"):
 #_self = __self.derived(kwargs["_loop_vars"])
 #f kwargs.get("_block_vars"):
 #_self = __self.derived(kwargs["_block_vars"])
 #rgs = (__self,) + args
 #lif pass_arg is _PassArg.eval_context:
 #rgs = (__self.eval_ctx,) + args
 #lif pass_arg is _PassArg.environment:
 #rgs = (__self.environment,) + args

 #wargs.pop("_block_vars", None)
 #wargs.pop("_loop_vars", None)

 #ry:
 #eturn __obj(*args, **kwargs)
 #xcept StopIteration:
 #eturn __self.environment.undefined(
 #value was undefined because a callable raised a"
 # StopIteration exception"
 #

 #ef derived(self, locals: t.Optional[t.Dict[str, t.Any]] = None) -> "Context":
 #""Internal helper function to create a derived context.  This is
 #sed in situations where the system needs a new context in the same
 #emplate that is independent.
 #""
 #ontext = new_context(
 #elf.environment, self.name, {}, self.get_all(), True, None, locals
 #
 #ontext.eval_ctx = self.eval_ctx
 #ontext.blocks.update((k, list(v)) for k, v in self.blocks.items())
 #eturn context

 #eys = _dict_method_all(dict.keys)
 #alues = _dict_method_all(dict.values)
 #tems = _dict_method_all(dict.items)

 #ef __contains__(self, name: str) -> bool:
 #eturn name in self.vars or name in self.parent

 #ef __getitem__(self, key: str) -> t.Any:
 #""Look up a variable by name with ``[]`` syntax, or raise a
 #`KeyError`` if the key is not found.
 #""
 #tem = self.resolve_or_missing(key)

 #f item is missing:
 #aise KeyError(key)

 #eturn item

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__} {self.get_all()!r} of {self.name!r}>"


class BlockReference:
 #""One block on a template reference."""

 #ef __init__(
 #elf,
 #ame: str,
 #ontext: "Context",
 #tack: t.List[t.Callable[["Context"], t.Iterator[str]]],
 #epth: int,
 # -> None:
 #elf.name = name
 #elf._context = context
 #elf._stack = stack
 #elf._depth = depth

 #property
 #ef super(self) -> t.Union["BlockReference", "Undefined"]:
 #""Super the block."""
 #f self._depth + 1 >= len(self._stack):
 #eturn self._context.environment.undefined(
 #"there is no parent block called {self.name!r}.", name="super"
 #
 #eturn BlockReference(self.name, self._context, self._stack, self._depth + 1)

 #internalcode
 #sync def _async_call(self) -> str:
 #v = self._context.environment.concat(  # type: ignore
 #x async for x in self._stack[self._depth](self._context)]  # type: ignore
 #

 #f self._context.eval_ctx.autoescape:
 #eturn Markup(rv)

 #eturn rv

 #internalcode
 #ef __call__(self) -> str:
 #f self._context.environment.is_async:
 #eturn self._async_call()  # type: ignore

 #v = self._context.environment.concat(  # type: ignore
 #elf._stack[self._depth](self._context)
 #

 #f self._context.eval_ctx.autoescape:
 #eturn Markup(rv)

 #eturn rv


class LoopContext:
 #""A wrapper iterable for dynamic ``for`` loops, with information
 #bout the loop and iteration.
 #""

    #: Current iteration of the loop, starting at 0.
 #ndex0 = -1

 #length: t.Optional[int] = None
 #after: t.Any = missing
 #current: t.Any = missing
 #before: t.Any = missing
 #last_changed_value: t.Any = missing

 #ef __init__(
 #elf,
 #terable: t.Iterable[V],
 #ndefined: t.Type["Undefined"],
 #ecurse: t.Optional["LoopRenderFunc"] = None,
 #epth0: int = 0,
 # -> None:
 #""
 #param iterable: Iterable to wrap.
 #param undefined: :class:`Undefined` class to use for next and
 #revious items.
 #param recurse: The function to render the loop body when the
 #oop is marked recursive.
 #param depth0: Incremented when looping recursively.
 #""
 #elf._iterable = iterable
 #elf._iterator = self._to_iterator(iterable)
 #elf._undefined = undefined
 #elf._recurse = recurse
        #: How many levels deep a recursive loop currently is, starting at 0.
 #elf.depth0 = depth0

 #staticmethod
 #ef _to_iterator(iterable: t.Iterable[V]) -> t.Iterator[V]:
 #eturn iter(iterable)

 #property
 #ef length(self) -> int:
 #""Length of the iterable.

 #f the iterable is a generator or otherwise does not have a
 #ize, it is eagerly evaluated to get a size.
 #""
 #f self._length is not None:
 #eturn self._length

 #ry:
 #elf._length = len(self._iterable)  # type: ignore
 #xcept TypeError:
 #terable = list(self._iterator)
 #elf._iterator = self._to_iterator(iterable)
 #elf._length = len(iterable) + self.index + (self._after is not missing)

 #eturn self._length

 #ef __len__(self) -> int:
 #eturn self.length

 #property
 #ef depth(self) -> int:
 #""How many levels deep a recursive loop currently is, starting at 1."""
 #eturn self.depth0 + 1

 #property
 #ef index(self) -> int:
 #""Current iteration of the loop, starting at 1."""
 #eturn self.index0 + 1

 #property
 #ef revindex0(self) -> int:
 #""Number of iterations from the end of the loop, ending at 0.

 #equires calculating :attr:`length`.
 #""
 #eturn self.length - self.index

 #property
 #ef revindex(self) -> int:
 #""Number of iterations from the end of the loop, ending at 1.

 #equires calculating :attr:`length`.
 #""
 #eturn self.length - self.index0

 #property
 #ef first(self) -> bool:
 #""Whether this is the first iteration of the loop."""
 #eturn self.index0 == 0

 #ef _peek_next(self) -> t.Any:
 #""Return the next element in the iterable, or :data:`missing`
 #f the iterable is exhausted. Only peeks one item ahead, caching
 #he result in :attr:`_last` for use in subsequent checks. The
 #ache is reset when :meth:`__next__` is called.
 #""
 #f self._after is not missing:
 #eturn self._after

 #elf._after = next(self._iterator, missing)
 #eturn self._after

 #property
 #ef last(self) -> bool:
 #""Whether this is the last iteration of the loop.

 #auses the iterable to advance early. See
 #func:`itertools.groupby` for issues this can cause.
 #he :func:`groupby` filter avoids that issue.
 #""
 #eturn self._peek_next() is missing

 #property
 #ef previtem(self) -> t.Union[t.Any, "Undefined"]:
 #""The item in the previous iteration. Undefined during the
 #irst iteration.
 #""
 #f self.first:
 #eturn self._undefined("there is no previous item")

 #eturn self._before

 #property
 #ef nextitem(self) -> t.Union[t.Any, "Undefined"]:
 #""The item in the next iteration. Undefined during the last
 #teration.

 #auses the iterable to advance early. See
 #func:`itertools.groupby` for issues this can cause.
 #he :func:`jinja-filters.groupby` filter avoids that issue.
 #""
 #v = self._peek_next()

 #f rv is missing:
 #eturn self._undefined("there is no next item")

 #eturn rv

 #ef cycle(self, *args: V) -> V:
 #""Return a value from the given args, cycling through based on
 #he current :attr:`index0`.

 #param args: One or more values to cycle through.
 #""
 #f not args:
 #aise TypeError("no items for cycling given")

 #eturn args[self.index0 % len(args)]

 #ef changed(self, *value: t.Any) -> bool:
 #""Return ``True`` if previously called with a different value
 #including when called for the first time).

 #param value: One or more values to compare to the last call.
 #""
 #f self._last_changed_value != value:
 #elf._last_changed_value = value
 #eturn True

 #eturn False

 #ef __iter__(self) -> "LoopContext":
 #eturn self

 #ef __next__(self) -> t.Tuple[t.Any, "LoopContext"]:
 #f self._after is not missing:
 #v = self._after
 #elf._after = missing
 #lse:
 #v = next(self._iterator)

 #elf.index0 += 1
 #elf._before = self._current
 #elf._current = rv
 #eturn rv, self

 #internalcode
 #ef __call__(self, iterable: t.Iterable[V]) -> str:
 #""When iterating over nested data, render the body of the loop
 #ecursively with the given inner iterable data.

 #he loop must have the ``recursive`` marker for this to work.
 #""
 #f self._recurse is None:
 #aise TypeError(
 #The loop must have the 'recursive' marker to be called recursively."
 #

 #eturn self._recurse(iterable, self._recurse, depth=self.depth)

 #ef __repr__(self) -> str:
 #eturn f"<{type(self).__name__} {self.index}/{self.length}>"


class AsyncLoopContext(LoopContext):
 #iterator: t.AsyncIterator[t.Any]  # type: ignore

 #staticmethod
 #ef _to_iterator(  # type: ignore
 #terable: t.Union[t.Iterable[V], t.AsyncIterable[V]],
 # -> t.AsyncIterator[V]:
 #eturn auto_aiter(iterable)

 #property
 #sync def length(self) -> int:  # type: ignore
 #f self._length is not None:
 #eturn self._length

 #ry:
 #elf._length = len(self._iterable)  # type: ignore
 #xcept TypeError:
 #terable = [x async for x in self._iterator]
 #elf._iterator = self._to_iterator(iterable)
 #elf._length = len(iterable) + self.index + (self._after is not missing)

 #eturn self._length

 #property
 #sync def revindex0(self) -> int:  # type: ignore
 #eturn await self.length - self.index

 #property
 #sync def revindex(self) -> int:  # type: ignore
 #eturn await self.length - self.index0

 #sync def _peek_next(self) -> t.Any:
 #f self._after is not missing:
 #eturn self._after

 #ry:
 #elf._after = await self._iterator.__anext__()
 #xcept StopAsyncIteration:
 #elf._after = missing

 #eturn self._after

 #property
 #sync def last(self) -> bool:  # type: ignore
 #eturn await self._peek_next() is missing

 #property
 #sync def nextitem(self) -> t.Union[t.Any, "Undefined"]:
 #v = await self._peek_next()

 #f rv is missing:
 #eturn self._undefined("there is no next item")

 #eturn rv

 #ef __aiter__(self) -> "AsyncLoopContext":
 #eturn self

 #sync def __anext__(self) -> t.Tuple[t.Any, "AsyncLoopContext"]:
 #f self._after is not missing:
 #v = self._after
 #elf._after = missing
 #lse:
 #v = await self._iterator.__anext__()

 #elf.index0 += 1
 #elf._before = self._current
 #elf._current = rv
 #eturn rv, self


class Macro:
 #""Wraps a macro function."""

 #ef __init__(
 #elf,
 #nvironment: "Environment",
 #unc: t.Callable[..., str],
 #ame: str,
 #rguments: t.List[str],
 #atch_kwargs: bool,
 #atch_varargs: bool,
 #aller: bool,
 #efault_autoescape: t.Optional[bool] = None,
 #:
 #elf._environment = environment
 #elf._func = func
 #elf._argument_count = len(arguments)
 #elf.name = name
 #elf.arguments = arguments
 #elf.catch_kwargs = catch_kwargs
 #elf.catch_varargs = catch_varargs
 #elf.caller = caller
 #elf.explicit_caller = "caller" in arguments

 #f default_autoescape is None:
 #f callable(environment.autoescape):
 #efault_autoescape = environment.autoescape(None)
 #lse:
 #efault_autoescape = environment.autoescape

 #elf._default_autoescape = default_autoescape

 #internalcode
 #pass_eval_context
 #ef __call__(self, *args: t.Any, **kwargs: t.Any) -> str:
        # This requires a bit of explanation,  In the past we used to
        # decide largely based on compile-time information if a macro is
        # safe or unsafe.  While there was a volatile mode it was largely
        # unused for deciding on escaping.  This turns out to be
        # problematic for macros because whether a macro is safe depends not
        # on the escape mode when it was defined, but rather when it was used.
        #
        # Because however we export macros from the module system and
        # there are historic callers that do not pass an eval context (and
        # will continue to not pass one), we need to perform an instance
        # check here.
        #
        # This is considered safe because an eval context is not a valid
        # argument to callables otherwise anyway.  Worst case here is
        # that if no eval context is passed we fall back to the compile
        # time autoescape flag.
 #f args and isinstance(args[0], EvalContext):
 #utoescape = args[0].autoescape
 #rgs = args[1:]
 #lse:
 #utoescape = self._default_autoescape

        # try to consume the positional arguments
 #rguments = list(args[: self._argument_count])
 #ff = len(arguments)

        # For information why this is necessary refer to the handling
        # of caller in the `macro_body` handler in the compiler.
 #ound_caller = False

        # if the number of arguments consumed is not the number of
        # arguments expected we start filling in keyword arguments
        # and defaults.
 #f off != self._argument_count:
 #or name in self.arguments[len(arguments) :]:
 #ry:
 #alue = kwargs.pop(name)
 #xcept KeyError:
 #alue = missing
 #f name == "caller":
 #ound_caller = True
 #rguments.append(value)
 #lse:
 #ound_caller = self.explicit_caller

        # it's important that the order of these arguments does not change
        # if not also changed in the compiler's `function_scoping` method.
        # the order is caller, keyword arguments, positional arguments!
 #f self.caller and not found_caller:
 #aller = kwargs.pop("caller", None)
 #f caller is None:
 #aller = self._environment.undefined("No caller defined", name="caller")
 #rguments.append(caller)

 #f self.catch_kwargs:
 #rguments.append(kwargs)
 #lif kwargs:
 #f "caller" in kwargs:
 #aise TypeError(
 #"macro {self.name!r} was invoked with two values for the special"
 # caller argument. This is most likely a bug."
 #
 #aise TypeError(
 #"macro {self.name!r} takes no keyword argument {next(iter(kwargs))!r}"
 #
 #f self.catch_varargs:
 #rguments.append(args[self._argument_count :])
 #lif len(args) > self._argument_count:
 #aise TypeError(
 #"macro {self.name!r} takes not more than"
 #" {len(self.arguments)} argument(s)"
 #

 #eturn self._invoke(arguments, autoescape)

 #sync def _async_invoke(self, arguments: t.List[t.Any], autoescape: bool) -> str:
 #v = await self._func(*arguments)  # type: ignore

 #f autoescape:
 #eturn Markup(rv)

 #eturn rv  # type: ignore

 #ef _invoke(self, arguments: t.List[t.Any], autoescape: bool) -> str:
 #f self._environment.is_async:
 #eturn self._async_invoke(arguments, autoescape)  # type: ignore

 #v = self._func(*arguments)

 #f autoescape:
 #v = Markup(rv)

 #eturn rv

 #ef __repr__(self) -> str:
 #ame = "anonymous" if self.name is None else repr(self.name)
 #eturn f"<{type(self).__name__} {name}>"


class Undefined:
 #""The default undefined type. This can be printed, iterated, and treated as
 # boolean. Any other operation will raise an :exc:`UndefinedError`.

 #>> foo = Undefined(name='foo')
 #>> str(foo)
 #'
 #>> not foo
 #rue
 #>> foo + 42
 #raceback (most recent call last):
 #..
 #inja2.exceptions.UndefinedError: 'foo' is undefined
 #""

 #_slots__ = (
 #_undefined_hint",
 #_undefined_obj",
 #_undefined_name",
 #_undefined_exception",
 #

 #ef __init__(
 #elf,
 #int: t.Optional[str] = None,
 #bj: t.Any = missing,
 #ame: t.Optional[str] = None,
 #xc: t.Type[TemplateRuntimeError] = UndefinedError,
 # -> None:
 #elf._undefined_hint = hint
 #elf._undefined_obj = obj
 #elf._undefined_name = name
 #elf._undefined_exception = exc

 #property
 #ef _undefined_message(self) -> str:
 #""Build a message about the undefined value based on how it was
 #ccessed.
 #""
 #f self._undefined_hint:
 #eturn self._undefined_hint

 #f self._undefined_obj is missing:
 #eturn f"{self._undefined_name!r} is undefined"

 #f not isinstance(self._undefined_name, str):
 #eturn (
 #"{object_type_repr(self._undefined_obj)} has no"
 #" element {self._undefined_name!r}"
 #

 #eturn (
 #"{object_type_repr(self._undefined_obj)!r} has no"
 #" attribute {self._undefined_name!r}"
 #

 #internalcode
 #ef _fail_with_undefined_error(
 #elf, *args: t.Any, **kwargs: t.Any
 # -> "te.NoReturn":
 #""Raise an :exc:`UndefinedError` when operations are performed
 #n the undefined value.
 #""
 #aise self._undefined_exception(self._undefined_message)

 #internalcode
 #ef __getattr__(self, name: str) -> t.Any:
        # Raise AttributeError on requests for names that appear to be unimplemented
        # dunder methods to keep Python's internal protocol probing behaviors working
        # properly in cases where another exception type could cause unexpected or
        # difficult-to-diagnose failures.
 #f name[:2] == "__" and name[-2:] == "__":
 #aise AttributeError(name)

 #eturn self._fail_with_undefined_error()

 #_add__ = __radd__ = __sub__ = __rsub__ = _fail_with_undefined_error
 #_mul__ = __rmul__ = __div__ = __rdiv__ = _fail_with_undefined_error
 #_truediv__ = __rtruediv__ = _fail_with_undefined_error
 #_floordiv__ = __rfloordiv__ = _fail_with_undefined_error
 #_mod__ = __rmod__ = _fail_with_undefined_error
 #_pos__ = __neg__ = _fail_with_undefined_error
 #_call__ = __getitem__ = _fail_with_undefined_error
 #_lt__ = __le__ = __gt__ = __ge__ = _fail_with_undefined_error
 #_int__ = __float__ = __complex__ = _fail_with_undefined_error
 #_pow__ = __rpow__ = _fail_with_undefined_error

 #ef __eq__(self, other: t.Any) -> bool:
 #eturn type(self) is type(other)

 #ef __ne__(self, other: t.Any) -> bool:
 #eturn not self.__eq__(other)

 #ef __hash__(self) -> int:
 #eturn id(type(self))

 #ef __str__(self) -> str:
 #eturn ""

 #ef __len__(self) -> int:
 #eturn 0

 #ef __iter__(self) -> t.Iterator[t.Any]:
 #ield from ()

 #sync def __aiter__(self) -> t.AsyncIterator[t.Any]:
 #or _ in ():
 #ield

 #ef __bool__(self) -> bool:
 #eturn False

 #ef __repr__(self) -> str:
 #eturn "Undefined"


def make_logging_undefined(
 #ogger: t.Optional["logging.Logger"] = None, base: t.Type[Undefined] = Undefined
) -> t.Type[Undefined]:
 #""Given a logger object this returns a new undefined class that will
 #og certain failures.  It will log iterations and printing.  If no
 #ogger is given a default logger is created.

 #xample::

 #ogger = logging.getLogger(__name__)
 #oggingUndefined = make_logging_undefined(
 #ogger=logger,
 #ase=Undefined
 #

 #. versionadded:: 2.8

 #param logger: the logger to use.  If not provided, a default logger
 #s created.
 #param base: the base class to add logging functionality to.  This
 #efaults to :class:`Undefined`.
 #""
 #f logger is None:
 #mport logging

 #ogger = logging.getLogger(__name__)
 #ogger.addHandler(logging.StreamHandler(sys.stderr))

 #ef _log_message(undef: Undefined) -> None:
 #ogger.warning("Template variable warning: %s", undef._undefined_message)

 #lass LoggingUndefined(base):  # type: ignore
 #_slots__ = ()

 #ef _fail_with_undefined_error(  # type: ignore
 #elf, *args: t.Any, **kwargs: t.Any
 # -> "te.NoReturn":
 #ry:
 #uper()._fail_with_undefined_error(*args, **kwargs)
 #xcept self._undefined_exception as e:
 #ogger.error("Template variable error: %s", e)  # type: ignore
 #aise e

 #ef __str__(self) -> str:
 #log_message(self)
 #eturn super().__str__()  # type: ignore

 #ef __iter__(self) -> t.Iterator[t.Any]:
 #log_message(self)
 #eturn super().__iter__()  # type: ignore

 #ef __bool__(self) -> bool:
 #log_message(self)
 #eturn super().__bool__()  # type: ignore

 #eturn LoggingUndefined


class ChainableUndefined(Undefined):
 #""An undefined that is chainable, where both ``__getattr__`` and
 #`__getitem__`` return itself rather than raising an
 #exc:`UndefinedError`.

 #>> foo = ChainableUndefined(name='foo')
 #>> str(foo.bar['baz'])
 #'
 #>> foo.bar['baz'] + 42
 #raceback (most recent call last):
 #..
 #inja2.exceptions.UndefinedError: 'foo' is undefined

 #. versionadded:: 2.11.0
 #""

 #_slots__ = ()

 #ef __html__(self) -> str:
 #eturn str(self)

 #ef __getattr__(self, name: str) -> "ChainableUndefined":
        # Raise AttributeError on requests for names that appear to be unimplemented
        # dunder methods to avoid confusing Python with truthy non-method objects that
        # do not implement the protocol being probed for. e.g., copy.copy(Undefined())
        # fails spectacularly if getattr(Undefined(), '__setstate__') returns an
        # Undefined object instead of raising AttributeError to signal that it does not
        # support that style of object initialization.
 #f name[:2] == "__" and name[-2:] == "__":
 #aise AttributeError(name)

 #eturn self

 #ef __getitem__(self, _name: str) -> "ChainableUndefined":  # type: ignore[override]
 #eturn self


class DebugUndefined(Undefined):
 #""An undefined that returns the debug info when printed.

 #>> foo = DebugUndefined(name='foo')
 #>> str(foo)
 #{{ foo }}'
 #>> not foo
 #rue
 #>> foo + 42
 #raceback (most recent call last):
 #..
 #inja2.exceptions.UndefinedError: 'foo' is undefined
 #""

 #_slots__ = ()

 #ef __str__(self) -> str:
 #f self._undefined_hint:
 #essage = f"undefined value printed: {self._undefined_hint}"

 #lif self._undefined_obj is missing:
 #essage = self._undefined_name  # type: ignore

 #lse:
 #essage = (
 #"no such element: {object_type_repr(self._undefined_obj)}"
 #"[{self._undefined_name!r}]"
 #

 #eturn f"{{{{ {message} }}}}"


class StrictUndefined(Undefined):
 #""An undefined that barks on print and iteration as well as boolean
 #ests and all kinds of comparisons.  In other words: you can do nothing
 #ith it except checking if it's defined using the `defined` test.

 #>> foo = StrictUndefined(name='foo')
 #>> str(foo)
 #raceback (most recent call last):
 #..
 #inja2.exceptions.UndefinedError: 'foo' is undefined
 #>> not foo
 #raceback (most recent call last):
 #..
 #inja2.exceptions.UndefinedError: 'foo' is undefined
 #>> foo + 42
 #raceback (most recent call last):
 #..
 #inja2.exceptions.UndefinedError: 'foo' is undefined
 #""

 #_slots__ = ()
 #_iter__ = __str__ = __len__ = Undefined._fail_with_undefined_error
 #_eq__ = __ne__ = __bool__ = __hash__ = Undefined._fail_with_undefined_error
 #_contains__ = Undefined._fail_with_undefined_error
