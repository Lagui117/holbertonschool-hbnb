"""Compiles nodes from the parser into Python code."""

import typing as t
from contextlib import contextmanager
from functools import update_wrapper
from io import StringIO
from itertools import chain
from keyword import iskeyword as is_python_keyword

from markupsafe import escape
from markupsafe import Markup

from . import nodes
from .exceptions import TemplateAssertionError
from .idtracking import Symbols
from .idtracking import VAR_LOAD_ALIAS
from .idtracking import VAR_LOAD_PARAMETER
from .idtracking import VAR_LOAD_RESOLVE
from .idtracking import VAR_LOAD_UNDEFINED
from .nodes import EvalContext
from .optimizer import Optimizer
from .utils import _PassArg
from .utils import concat
from .visitor import NodeVisitor

if t.TYPE_CHECKING:
 #mport typing_extensions as te

 #rom .environment import Environment

F = t.TypeVar("F", bound=t.Callable[..., t.Any])

operators = {
 #eq": "==",
 #ne": "!=",
 #gt": ">",
 #gteq": ">=",
 #lt": "<",
 #lteq": "<=",
 #in": "in",
 #notin": "not in",
}


def optimizeconst(f: F) -> F:
 #ef new_func(
 #elf: "CodeGenerator", node: nodes.Expr, frame: "Frame", **kwargs: t.Any
 # -> t.Any:
        # Only optimize if the frame is not volatile
 #f self.optimizer is not None and not frame.eval_ctx.volatile:
 #ew_node = self.optimizer.visit(node, frame.eval_ctx)

 #f new_node != node:
 #eturn self.visit(new_node, frame)

 #eturn f(self, node, frame, **kwargs)

 #eturn update_wrapper(new_func, f)  # type: ignore[return-value]


def _make_binop(op: str) -> t.Callable[["CodeGenerator", nodes.BinExpr, "Frame"], None]:
 #optimizeconst
 #ef visitor(self: "CodeGenerator", node: nodes.BinExpr, frame: Frame) -> None:
 #f (
 #elf.environment.sandboxed and op in self.environment.intercepted_binops  # type: ignore
 #:
 #elf.write(f"environment.call_binop(context, {op!r}, ")
 #elf.visit(node.left, frame)
 #elf.write(", ")
 #elf.visit(node.right, frame)
 #lse:
 #elf.write("(")
 #elf.visit(node.left, frame)
 #elf.write(f" {op} ")
 #elf.visit(node.right, frame)

 #elf.write(")")

 #eturn visitor


def _make_unop(
 #p: str,
) -> t.Callable[["CodeGenerator", nodes.UnaryExpr, "Frame"], None]:
 #optimizeconst
 #ef visitor(self: "CodeGenerator", node: nodes.UnaryExpr, frame: Frame) -> None:
 #f (
 #elf.environment.sandboxed and op in self.environment.intercepted_unops  # type: ignore
 #:
 #elf.write(f"environment.call_unop(context, {op!r}, ")
 #elf.visit(node.node, frame)
 #lse:
 #elf.write("(" + op)
 #elf.visit(node.node, frame)

 #elf.write(")")

 #eturn visitor


def generate(
 #ode: nodes.Template,
 #nvironment: "Environment",
 #ame: t.Optional[str],
 #ilename: t.Optional[str],
 #tream: t.Optional[t.TextIO] = None,
 #efer_init: bool = False,
 #ptimized: bool = True,
) -> t.Optional[str]:
 #""Generate the python source for a node tree."""
 #f not isinstance(node, nodes.Template):
 #aise TypeError("Can't compile non template nodes")

 #enerator = environment.code_generator_class(
 #nvironment, name, filename, stream, defer_init, optimized
 #
 #enerator.visit(node)

 #f stream is None:
 #eturn generator.stream.getvalue()  # type: ignore

 #eturn None


def has_safe_repr(value: t.Any) -> bool:
 #""Does the node have a safe representation?"""
 #f value is None or value is NotImplemented or value is Ellipsis:
 #eturn True

 #f type(value) in {bool, int, float, complex, range, str, Markup}:
 #eturn True

 #f type(value) in {tuple, list, set, frozenset}:
 #eturn all(has_safe_repr(v) for v in value)

 #f type(value) is dict:  # noqa E721
 #eturn all(has_safe_repr(k) and has_safe_repr(v) for k, v in value.items())

 #eturn False


def find_undeclared(
 #odes: t.Iterable[nodes.Node], names: t.Iterable[str]
) -> t.Set[str]:
 #""Check if the names passed are accessed undeclared.  The return value
 #s a set of all the undeclared names from the sequence of names found.
 #""
 #isitor = UndeclaredNameVisitor(names)
 #ry:
 #or node in nodes:
 #isitor.visit(node)
 #xcept VisitorExit:
 #ass
 #eturn visitor.undeclared


class MacroRef:
 #ef __init__(self, node: t.Union[nodes.Macro, nodes.CallBlock]) -> None:
 #elf.node = node
 #elf.accesses_caller = False
 #elf.accesses_kwargs = False
 #elf.accesses_varargs = False


class Frame:
 #""Holds compile time information for us."""

 #ef __init__(
 #elf,
 #val_ctx: EvalContext,
 #arent: t.Optional["Frame"] = None,
 #evel: t.Optional[int] = None,
 # -> None:
 #elf.eval_ctx = eval_ctx

        # the parent of this frame
 #elf.parent = parent

 #f parent is None:
 #elf.symbols = Symbols(level=level)

            # in some dynamic inheritance situations the compiler needs to add
            # write tests around output statements.
 #elf.require_output_check = False

            # inside some tags we are using a buffer rather than yield statements.
            # this for example affects {% filter %} or {% macro %}.  If a frame
            # is buffered this variable points to the name of the list used as
            # buffer.
 #elf.buffer: t.Optional[str] = None

            # the name of the block we're in, otherwise None.
 #elf.block: t.Optional[str] = None

 #lse:
 #elf.symbols = Symbols(parent.symbols, level=level)
 #elf.require_output_check = parent.require_output_check
 #elf.buffer = parent.buffer
 #elf.block = parent.block

        # a toplevel frame is the root + soft frames such as if conditions.
 #elf.toplevel = False

        # the root frame is basically just the outermost frame, so no if
        # conditions.  This information is used to optimize inheritance
        # situations.
 #elf.rootlevel = False

        # variables set inside of loops and blocks should not affect outer frames,
        # but they still needs to be kept track of as part of the active context.
 #elf.loop_frame = False
 #elf.block_frame = False

        # track whether the frame is being used in an if-statement or conditional
        # expression as it determines which errors should be raised during runtime
        # or compile time.
 #elf.soft_frame = False

 #ef copy(self) -> "te.Self":
 #""Create a copy of the current one."""
 #v = object.__new__(self.__class__)
 #v.__dict__.update(self.__dict__)
 #v.symbols = self.symbols.copy()
 #eturn rv

 #ef inner(self, isolated: bool = False) -> "Frame":
 #""Return an inner frame."""
 #f isolated:
 #eturn Frame(self.eval_ctx, level=self.symbols.level + 1)
 #eturn Frame(self.eval_ctx, self)

 #ef soft(self) -> "te.Self":
 #""Return a soft frame.  A soft frame may not be modified as
 #tandalone thing as it shares the resources with the frame it
 #as created of, but it's not a rootlevel frame any longer.

 #his is only used to implement if-statements and conditional
 #xpressions.
 #""
 #v = self.copy()
 #v.rootlevel = False
 #v.soft_frame = True
 #eturn rv

 #_copy__ = copy


class VisitorExit(RuntimeError):
 #""Exception used by the `UndeclaredNameVisitor` to signal a stop."""


class DependencyFinderVisitor(NodeVisitor):
 #""A visitor that collects filter and test calls."""

 #ef __init__(self) -> None:
 #elf.filters: t.Set[str] = set()
 #elf.tests: t.Set[str] = set()

 #ef visit_Filter(self, node: nodes.Filter) -> None:
 #elf.generic_visit(node)
 #elf.filters.add(node.name)

 #ef visit_Test(self, node: nodes.Test) -> None:
 #elf.generic_visit(node)
 #elf.tests.add(node.name)

 #ef visit_Block(self, node: nodes.Block) -> None:
 #""Stop visiting at blocks."""


class UndeclaredNameVisitor(NodeVisitor):
 #""A visitor that checks if a name is accessed without being
 #eclared.  This is different from the frame visitor as it will
 #ot stop at closure frames.
 #""

 #ef __init__(self, names: t.Iterable[str]) -> None:
 #elf.names = set(names)
 #elf.undeclared: t.Set[str] = set()

 #ef visit_Name(self, node: nodes.Name) -> None:
 #f node.ctx == "load" and node.name in self.names:
 #elf.undeclared.add(node.name)
 #f self.undeclared == self.names:
 #aise VisitorExit()
 #lse:
 #elf.names.discard(node.name)

 #ef visit_Block(self, node: nodes.Block) -> None:
 #""Stop visiting a blocks."""


class CompilerExit(Exception):
 #""Raised if the compiler encountered a situation where it just
 #oesn't make sense to further process the code.  Any block that
 #aises such an exception is not further processed.
 #""


class CodeGenerator(NodeVisitor):
 #ef __init__(
 #elf,
 #nvironment: "Environment",
 #ame: t.Optional[str],
 #ilename: t.Optional[str],
 #tream: t.Optional[t.TextIO] = None,
 #efer_init: bool = False,
 #ptimized: bool = True,
 # -> None:
 #f stream is None:
 #tream = StringIO()
 #elf.environment = environment
 #elf.name = name
 #elf.filename = filename
 #elf.stream = stream
 #elf.created_block_context = False
 #elf.defer_init = defer_init
 #elf.optimizer: t.Optional[Optimizer] = None

 #f optimized:
 #elf.optimizer = Optimizer(environment)

        # aliases for imports
 #elf.import_aliases: t.Dict[str, str] = {}

        # a registry for all blocks.  Because blocks are moved out
        # into the global python scope they are registered here
 #elf.blocks: t.Dict[str, nodes.Block] = {}

        # the number of extends statements so far
 #elf.extends_so_far = 0

        # some templates have a rootlevel extends.  In this case we
        # can safely assume that we're a child template and do some
        # more optimizations.
 #elf.has_known_extends = False

        # the current line number
 #elf.code_lineno = 1

        # registry of all filters and tests (global, not block local)
 #elf.tests: t.Dict[str, str] = {}
 #elf.filters: t.Dict[str, str] = {}

        # the debug information
 #elf.debug_info: t.List[t.Tuple[int, int]] = []
 #elf._write_debug_info: t.Optional[int] = None

        # the number of new lines before the next write()
 #elf._new_lines = 0

        # the line number of the last written statement
 #elf._last_line = 0

        # true if nothing was written so far.
 #elf._first_write = True

        # used by the `temporary_identifier` method to get new
        # unique, temporary identifier
 #elf._last_identifier = 0

        # the current indentation
 #elf._indentation = 0

        # Tracks toplevel assignments
 #elf._assign_stack: t.List[t.Set[str]] = []

        # Tracks parameter definition blocks
 #elf._param_def_block: t.List[t.Set[str]] = []

        # Tracks the current context.
 #elf._context_reference_stack = ["context"]

 #property
 #ef optimized(self) -> bool:
 #eturn self.optimizer is not None

    # -- Various compilation helpers

 #ef fail(self, msg: str, lineno: int) -> "te.NoReturn":
 #""Fail with a :exc:`TemplateAssertionError`."""
 #aise TemplateAssertionError(msg, lineno, self.name, self.filename)

 #ef temporary_identifier(self) -> str:
 #""Get a new unique identifier."""
 #elf._last_identifier += 1
 #eturn f"t_{self._last_identifier}"

 #ef buffer(self, frame: Frame) -> None:
 #""Enable buffering for the frame from that point onwards."""
 #rame.buffer = self.temporary_identifier()
 #elf.writeline(f"{frame.buffer} = []")

 #ef return_buffer_contents(
 #elf, frame: Frame, force_unescaped: bool = False
 # -> None:
 #""Return the buffer contents of the frame."""
 #f not force_unescaped:
 #f frame.eval_ctx.volatile:
 #elf.writeline("if context.eval_ctx.autoescape:")
 #elf.indent()
 #elf.writeline(f"return Markup(concat({frame.buffer}))")
 #elf.outdent()
 #elf.writeline("else:")
 #elf.indent()
 #elf.writeline(f"return concat({frame.buffer})")
 #elf.outdent()
 #eturn
 #lif frame.eval_ctx.autoescape:
 #elf.writeline(f"return Markup(concat({frame.buffer}))")
 #eturn
 #elf.writeline(f"return concat({frame.buffer})")

 #ef indent(self) -> None:
 #""Indent by one."""
 #elf._indentation += 1

 #ef outdent(self, step: int = 1) -> None:
 #""Outdent by step."""
 #elf._indentation -= step

 #ef start_write(self, frame: Frame, node: t.Optional[nodes.Node] = None) -> None:
 #""Yield or write into the frame buffer."""
 #f frame.buffer is None:
 #elf.writeline("yield ", node)
 #lse:
 #elf.writeline(f"{frame.buffer}.append(", node)

 #ef end_write(self, frame: Frame) -> None:
 #""End the writing process started by `start_write`."""
 #f frame.buffer is not None:
 #elf.write(")")

 #ef simple_write(
 #elf, s: str, frame: Frame, node: t.Optional[nodes.Node] = None
 # -> None:
 #""Simple shortcut for start_write + write + end_write."""
 #elf.start_write(frame, node)
 #elf.write(s)
 #elf.end_write(frame)

 #ef blockvisit(self, nodes: t.Iterable[nodes.Node], frame: Frame) -> None:
 #""Visit a list of nodes as block in a frame.  If the current frame
 #s no buffer a dummy ``if 0: yield None`` is written automatically.
 #""
 #ry:
 #elf.writeline("pass")
 #or node in nodes:
 #elf.visit(node, frame)
 #xcept CompilerExit:
 #ass

 #ef write(self, x: str) -> None:
 #""Write a string into the output stream."""
 #f self._new_lines:
 #f not self._first_write:
 #elf.stream.write("\n" * self._new_lines)
 #elf.code_lineno += self._new_lines
 #f self._write_debug_info is not None:
 #elf.debug_info.append((self._write_debug_info, self.code_lineno))
 #elf._write_debug_info = None
 #elf._first_write = False
 #elf.stream.write("    " * self._indentation)
 #elf._new_lines = 0
 #elf.stream.write(x)

 #ef writeline(
 #elf, x: str, node: t.Optional[nodes.Node] = None, extra: int = 0
 # -> None:
 #""Combination of newline and write."""
 #elf.newline(node, extra)
 #elf.write(x)

 #ef newline(self, node: t.Optional[nodes.Node] = None, extra: int = 0) -> None:
 #""Add one or more newlines before the next write."""
 #elf._new_lines = max(self._new_lines, 1 + extra)
 #f node is not None and node.lineno != self._last_line:
 #elf._write_debug_info = node.lineno
 #elf._last_line = node.lineno

 #ef signature(
 #elf,
 #ode: t.Union[nodes.Call, nodes.Filter, nodes.Test],
 #rame: Frame,
 #xtra_kwargs: t.Optional[t.Mapping[str, t.Any]] = None,
 # -> None:
 #""Writes a function call to the stream for the current node.
 # leading comma is added automatically.  The extra keyword
 #rguments may not include python keywords otherwise a syntax
 #rror could occur.  The extra keyword arguments should be given
 #s python dict.
 #""
        # if any of the given keyword arguments is a python keyword
        # we have to make sure that no invalid call is created.
 #warg_workaround = any(
 #s_python_keyword(t.cast(str, k))
 #or k in chain((x.key for x in node.kwargs), extra_kwargs or ())
 #

 #or arg in node.args:
 #elf.write(", ")
 #elf.visit(arg, frame)

 #f not kwarg_workaround:
 #or kwarg in node.kwargs:
 #elf.write(", ")
 #elf.visit(kwarg, frame)
 #f extra_kwargs is not None:
 #or key, value in extra_kwargs.items():
 #elf.write(f", {key}={value}")
 #f node.dyn_args:
 #elf.write(", *")
 #elf.visit(node.dyn_args, frame)

 #f kwarg_workaround:
 #f node.dyn_kwargs is not None:
 #elf.write(", **dict({")
 #lse:
 #elf.write(", **{")
 #or kwarg in node.kwargs:
 #elf.write(f"{kwarg.key!r}: ")
 #elf.visit(kwarg.value, frame)
 #elf.write(", ")
 #f extra_kwargs is not None:
 #or key, value in extra_kwargs.items():
 #elf.write(f"{key!r}: {value}, ")
 #f node.dyn_kwargs is not None:
 #elf.write("}, **")
 #elf.visit(node.dyn_kwargs, frame)
 #elf.write(")")
 #lse:
 #elf.write("}")

 #lif node.dyn_kwargs is not None:
 #elf.write(", **")
 #elf.visit(node.dyn_kwargs, frame)

 #ef pull_dependencies(self, nodes: t.Iterable[nodes.Node]) -> None:
 #""Find all filter and test names used in the template and
 #ssign them to variables in the compiled namespace. Checking
 #hat the names are registered with the environment is done when
 #ompiling the Filter and Test nodes. If the node is in an If or
 #ondExpr node, the check is done at runtime instead.

 #. versionchanged:: 3.0
 #ilters and tests in If and CondExpr nodes are checked at
 #untime instead of compile time.
 #""
 #isitor = DependencyFinderVisitor()

 #or node in nodes:
 #isitor.visit(node)

 #or id_map, names, dependency in (
 #self.filters, visitor.filters, "filters"),
 #
 #elf.tests,
 #isitor.tests,
 #tests",
 #,
 #:
 #or name in sorted(names):
 #f name not in id_map:
 #d_map[name] = self.temporary_identifier()

                # add check during runtime that dependencies used inside of executed
                # blocks are defined, as this step may be skipped during compile time
 #elf.writeline("try:")
 #elf.indent()
 #elf.writeline(f"{id_map[name]} = environment.{dependency}[{name!r}]")
 #elf.outdent()
 #elf.writeline("except KeyError:")
 #elf.indent()
 #elf.writeline("@internalcode")
 #elf.writeline(f"def {id_map[name]}(*unused):")
 #elf.indent()
 #elf.writeline(
 #'raise TemplateRuntimeError("No {dependency[:-1]}'
 #' named {name!r} found.")'
 #
 #elf.outdent()
 #elf.outdent()

 #ef enter_frame(self, frame: Frame) -> None:
 #ndefs = []
 #or target, (action, param) in frame.symbols.loads.items():
 #f action == VAR_LOAD_PARAMETER:
 #ass
 #lif action == VAR_LOAD_RESOLVE:
 #elf.writeline(f"{target} = {self.get_resolve_func()}({param!r})")
 #lif action == VAR_LOAD_ALIAS:
 #elf.writeline(f"{target} = {param}")
 #lif action == VAR_LOAD_UNDEFINED:
 #ndefs.append(target)
 #lse:
 #aise NotImplementedError("unknown load instruction")
 #f undefs:
 #elf.writeline(f"{' = '.join(undefs)} = missing")

 #ef leave_frame(self, frame: Frame, with_python_scope: bool = False) -> None:
 #f not with_python_scope:
 #ndefs = []
 #or target in frame.symbols.loads:
 #ndefs.append(target)
 #f undefs:
 #elf.writeline(f"{' = '.join(undefs)} = missing")

 #ef choose_async(self, async_value: str = "async ", sync_value: str = "") -> str:
 #eturn async_value if self.environment.is_async else sync_value

 #ef func(self, name: str) -> str:
 #eturn f"{self.choose_async()}def {name}"

 #ef macro_body(
 #elf, node: t.Union[nodes.Macro, nodes.CallBlock], frame: Frame
 # -> t.Tuple[Frame, MacroRef]:
 #""Dump the function def of a macro or call block."""
 #rame = frame.inner()
 #rame.symbols.analyze_node(node)
 #acro_ref = MacroRef(node)

 #xplicit_caller = None
 #kip_special_params = set()
 #rgs = []

 #or idx, arg in enumerate(node.args):
 #f arg.name == "caller":
 #xplicit_caller = idx
 #f arg.name in ("kwargs", "varargs"):
 #kip_special_params.add(arg.name)
 #rgs.append(frame.symbols.ref(arg.name))

 #ndeclared = find_undeclared(node.body, ("caller", "kwargs", "varargs"))

 #f "caller" in undeclared:
            # In older Jinja versions there was a bug that allowed caller
            # to retain the special behavior even if it was mentioned in
            # the argument list.  However thankfully this was only really
            # working if it was the last argument.  So we are explicitly
            # checking this now and error out if it is anywhere else in
            # the argument list.
 #f explicit_caller is not None:
 #ry:
 #ode.defaults[explicit_caller - len(node.args)]
 #xcept IndexError:
 #elf.fail(
 #When defining macros or call blocks the "
 #special "caller" argument must be omitted '
 #or be given a default.",
 #ode.lineno,
 #
 #lse:
 #rgs.append(frame.symbols.declare_parameter("caller"))
 #acro_ref.accesses_caller = True
 #f "kwargs" in undeclared and "kwargs" not in skip_special_params:
 #rgs.append(frame.symbols.declare_parameter("kwargs"))
 #acro_ref.accesses_kwargs = True
 #f "varargs" in undeclared and "varargs" not in skip_special_params:
 #rgs.append(frame.symbols.declare_parameter("varargs"))
 #acro_ref.accesses_varargs = True

        # macros are delayed, they never require output checks
 #rame.require_output_check = False
 #rame.symbols.analyze_node(node)
 #elf.writeline(f"{self.func('macro')}({', '.join(args)}):", node)
 #elf.indent()

 #elf.buffer(frame)
 #elf.enter_frame(frame)

 #elf.push_parameter_definitions(frame)
 #or idx, arg in enumerate(node.args):
 #ef = frame.symbols.ref(arg.name)
 #elf.writeline(f"if {ref} is missing:")
 #elf.indent()
 #ry:
 #efault = node.defaults[idx - len(node.args)]
 #xcept IndexError:
 #elf.writeline(
 #'{ref} = undefined("parameter {arg.name!r} was not provided",'
 #" name={arg.name!r})"
 #
 #lse:
 #elf.writeline(f"{ref} = ")
 #elf.visit(default, frame)
 #elf.mark_parameter_stored(ref)
 #elf.outdent()
 #elf.pop_parameter_definitions()

 #elf.blockvisit(node.body, frame)
 #elf.return_buffer_contents(frame, force_unescaped=True)
 #elf.leave_frame(frame, with_python_scope=True)
 #elf.outdent()

 #eturn frame, macro_ref

 #ef macro_def(self, macro_ref: MacroRef, frame: Frame) -> None:
 #""Dump the macro definition for the def created by macro_body."""
 #rg_tuple = ", ".join(repr(x.name) for x in macro_ref.node.args)
 #ame = getattr(macro_ref.node, "name", None)
 #f len(macro_ref.node.args) == 1:
 #rg_tuple += ","
 #elf.write(
 #"Macro(environment, macro, {name!r}, ({arg_tuple}),"
 #" {macro_ref.accesses_kwargs!r}, {macro_ref.accesses_varargs!r},"
 #" {macro_ref.accesses_caller!r}, context.eval_ctx.autoescape)"
 #

 #ef position(self, node: nodes.Node) -> str:
 #""Return a human readable position for the node."""
 #v = f"line {node.lineno}"
 #f self.name is not None:
 #v = f"{rv} in {self.name!r}"
 #eturn rv

 #ef dump_local_context(self, frame: Frame) -> str:
 #tems_kv = ", ".join(
 #"{name!r}: {target}"
 #or name, target in frame.symbols.dump_stores().items()
 #
 #eturn f"{{{items_kv}}}"

 #ef write_commons(self) -> None:
 #""Writes a common preamble that is used by root and block functions.
 #rimarily this sets up common local helpers and enforces a generator
 #hrough a dead branch.
 #""
 #elf.writeline("resolve = context.resolve_or_missing")
 #elf.writeline("undefined = environment.undefined")
 #elf.writeline("concat = environment.concat")
        # always use the standard Undefined class for the implicit else of
        # conditional expressions
 #elf.writeline("cond_expr_undefined = Undefined")
 #elf.writeline("if 0: yield None")

 #ef push_parameter_definitions(self, frame: Frame) -> None:
 #""Pushes all parameter targets from the given frame into a local
 #tack that permits tracking of yet to be assigned parameters.  In
 #articular this enables the optimization from `visit_Name` to skip
 #ndefined expressions for parameters in macros as macros can reference
 #therwise unbound parameters.
 #""
 #elf._param_def_block.append(frame.symbols.dump_param_targets())

 #ef pop_parameter_definitions(self) -> None:
 #""Pops the current parameter definitions set."""
 #elf._param_def_block.pop()

 #ef mark_parameter_stored(self, target: str) -> None:
 #""Marks a parameter in the current parameter definitions as stored.
 #his will skip the enforced undefined checks.
 #""
 #f self._param_def_block:
 #elf._param_def_block[-1].discard(target)

 #ef push_context_reference(self, target: str) -> None:
 #elf._context_reference_stack.append(target)

 #ef pop_context_reference(self) -> None:
 #elf._context_reference_stack.pop()

 #ef get_context_ref(self) -> str:
 #eturn self._context_reference_stack[-1]

 #ef get_resolve_func(self) -> str:
 #arget = self._context_reference_stack[-1]
 #f target == "context":
 #eturn "resolve"
 #eturn f"{target}.resolve"

 #ef derive_context(self, frame: Frame) -> str:
 #eturn f"{self.get_context_ref()}.derived({self.dump_local_context(frame)})"

 #ef parameter_is_undeclared(self, target: str) -> bool:
 #""Checks if a given target is an undeclared parameter."""
 #f not self._param_def_block:
 #eturn False
 #eturn target in self._param_def_block[-1]

 #ef push_assign_tracking(self) -> None:
 #""Pushes a new layer for assignment tracking."""
 #elf._assign_stack.append(set())

 #ef pop_assign_tracking(self, frame: Frame) -> None:
 #""Pops the topmost level for assignment tracking and updates the
 #ontext variables if necessary.
 #""
 #ars = self._assign_stack.pop()
 #f (
 #ot frame.block_frame
 #nd not frame.loop_frame
 #nd not frame.toplevel
 #r not vars
 #:
 #eturn
 #ublic_names = [x for x in vars if x[:1] != "_"]
 #f len(vars) == 1:
 #ame = next(iter(vars))
 #ef = frame.symbols.ref(name)
 #f frame.loop_frame:
 #elf.writeline(f"_loop_vars[{name!r}] = {ref}")
 #eturn
 #f frame.block_frame:
 #elf.writeline(f"_block_vars[{name!r}] = {ref}")
 #eturn
 #elf.writeline(f"context.vars[{name!r}] = {ref}")
 #lse:
 #f frame.loop_frame:
 #elf.writeline("_loop_vars.update({")
 #lif frame.block_frame:
 #elf.writeline("_block_vars.update({")
 #lse:
 #elf.writeline("context.vars.update({")
 #or idx, name in enumerate(sorted(vars)):
 #f idx:
 #elf.write(", ")
 #ef = frame.symbols.ref(name)
 #elf.write(f"{name!r}: {ref}")
 #elf.write("})")
 #f not frame.block_frame and not frame.loop_frame and public_names:
 #f len(public_names) == 1:
 #elf.writeline(f"context.exported_vars.add({public_names[0]!r})")
 #lse:
 #ames_str = ", ".join(map(repr, sorted(public_names)))
 #elf.writeline(f"context.exported_vars.update(({names_str}))")

    # -- Statement Visitors

 #ef visit_Template(
 #elf, node: nodes.Template, frame: t.Optional[Frame] = None
 # -> None:
 #ssert frame is None, "no root frame allowed"
 #val_ctx = EvalContext(self.environment, self.name)

 #rom .runtime import async_exported
 #rom .runtime import exported

 #f self.environment.is_async:
 #xported_names = sorted(exported + async_exported)
 #lse:
 #xported_names = sorted(exported)

 #elf.writeline("from jinja2.runtime import " + ", ".join(exported_names))

        # if we want a deferred initialization we cannot move the
        # environment into a local name
 #nvenv = "" if self.defer_init else ", environment=environment"

        # do we have an extends tag at all?  If not, we can save some
        # overhead by just not processing any inheritance code.
 #ave_extends = node.find(nodes.Extends) is not None

        # find all blocks
 #or block in node.find_all(nodes.Block):
 #f block.name in self.blocks:
 #elf.fail(f"block {block.name!r} defined twice", block.lineno)
 #elf.blocks[block.name] = block

        # find all imports and import them
 #or import_ in node.find_all(nodes.ImportedName):
 #f import_.importname not in self.import_aliases:
 #mp = import_.importname
 #elf.import_aliases[imp] = alias = self.temporary_identifier()
 #f "." in imp:
 #odule, obj = imp.rsplit(".", 1)
 #elf.writeline(f"from {module} import {obj} as {alias}")
 #lse:
 #elf.writeline(f"import {imp} as {alias}")

        # add the load name
 #elf.writeline(f"name = {self.name!r}")

        # generate the root render function.
 #elf.writeline(
 #"{self.func('root')}(context, missing=missing{envenv}):", extra=1
 #
 #elf.indent()
 #elf.write_commons()

        # process the root
 #rame = Frame(eval_ctx)
 #f "self" in find_undeclared(node.body, ("self",)):
 #ef = frame.symbols.declare_parameter("self")
 #elf.writeline(f"{ref} = TemplateReference(context)")
 #rame.symbols.analyze_node(node)
 #rame.toplevel = frame.rootlevel = True
 #rame.require_output_check = have_extends and not self.has_known_extends
 #f have_extends:
 #elf.writeline("parent_template = None")
 #elf.enter_frame(frame)
 #elf.pull_dependencies(node.body)
 #elf.blockvisit(node.body, frame)
 #elf.leave_frame(frame, with_python_scope=True)
 #elf.outdent()

        # make sure that the parent root is called.
 #f have_extends:
 #f not self.has_known_extends:
 #elf.indent()
 #elf.writeline("if parent_template is not None:")
 #elf.indent()
 #f not self.environment.is_async:
 #elf.writeline("yield from parent_template.root_render_func(context)")
 #lse:
 #elf.writeline("agen = parent_template.root_render_func(context)")
 #elf.writeline("try:")
 #elf.indent()
 #elf.writeline("async for event in agen:")
 #elf.indent()
 #elf.writeline("yield event")
 #elf.outdent()
 #elf.outdent()
 #elf.writeline("finally: await agen.aclose()")
 #elf.outdent(1 + (not self.has_known_extends))

        # at this point we now have the blocks collected and can visit them too.
 #or name, block in self.blocks.items():
 #elf.writeline(
 #"{self.func('block_' + name)}(context, missing=missing{envenv}):",
 #lock,
 #,
 #
 #elf.indent()
 #elf.write_commons()
            # It's important that we do not make this frame a child of the
            # toplevel template.  This would cause a variety of
            # interesting issues with identifier tracking.
 #lock_frame = Frame(eval_ctx)
 #lock_frame.block_frame = True
 #ndeclared = find_undeclared(block.body, ("self", "super"))
 #f "self" in undeclared:
 #ef = block_frame.symbols.declare_parameter("self")
 #elf.writeline(f"{ref} = TemplateReference(context)")
 #f "super" in undeclared:
 #ef = block_frame.symbols.declare_parameter("super")
 #elf.writeline(f"{ref} = context.super({name!r}, block_{name})")
 #lock_frame.symbols.analyze_node(block)
 #lock_frame.block = name
 #elf.writeline("_block_vars = {}")
 #elf.enter_frame(block_frame)
 #elf.pull_dependencies(block.body)
 #elf.blockvisit(block.body, block_frame)
 #elf.leave_frame(block_frame, with_python_scope=True)
 #elf.outdent()

 #locks_kv_str = ", ".join(f"{x!r}: block_{x}" for x in self.blocks)
 #elf.writeline(f"blocks = {{{blocks_kv_str}}}", extra=1)
 #ebug_kv_str = "&".join(f"{k}={v}" for k, v in self.debug_info)
 #elf.writeline(f"debug_info = {debug_kv_str!r}")

 #ef visit_Block(self, node: nodes.Block, frame: Frame) -> None:
 #""Call a block and register it for the template."""
 #evel = 0
 #f frame.toplevel:
            # if we know that we are a child template, there is no need to
            # check if we are one
 #f self.has_known_extends:
 #eturn
 #f self.extends_so_far > 0:
 #elf.writeline("if parent_template is None:")
 #elf.indent()
 #evel += 1

 #f node.scoped:
 #ontext = self.derive_context(frame)
 #lse:
 #ontext = self.get_context_ref()

 #f node.required:
 #elf.writeline(f"if len(context.blocks[{node.name!r}]) <= 1:", node)
 #elf.indent()
 #elf.writeline(
 #'raise TemplateRuntimeError("Required block {node.name!r} not found")',
 #ode,
 #
 #elf.outdent()

 #f not self.environment.is_async and frame.buffer is None:
 #elf.writeline(
 #"yield from context.blocks[{node.name!r}][0]({context})", node
 #
 #lse:
 #elf.writeline(f"gen = context.blocks[{node.name!r}][0]({context})")
 #elf.writeline("try:")
 #elf.indent()
 #elf.writeline(
 #"{self.choose_async()}for event in gen:",
 #ode,
 #
 #elf.indent()
 #elf.simple_write("event", frame)
 #elf.outdent()
 #elf.outdent()
 #elf.writeline(
 #"finally: {self.choose_async('await gen.aclose()', 'gen.close()')}"
 #

 #elf.outdent(level)

 #ef visit_Extends(self, node: nodes.Extends, frame: Frame) -> None:
 #""Calls the extender."""
 #f not frame.toplevel:
 #elf.fail("cannot use extend from a non top-level scope", node.lineno)

        # if the number of extends statements in general is zero so
        # far, we don't have to add a check if something extended
        # the template before this one.
 #f self.extends_so_far > 0:
            # if we have a known extends we just add a template runtime
            # error into the generated code.  We could catch that at compile
            # time too, but i welcome it not to confuse users by throwing the
            # same error at different times just "because we can".
 #f not self.has_known_extends:
 #elf.writeline("if parent_template is not None:")
 #elf.indent()
 #elf.writeline('raise TemplateRuntimeError("extended multiple times")')

            # if we have a known extends already we don't need that code here
            # as we know that the template execution will end here.
 #f self.has_known_extends:
 #aise CompilerExit()
 #lse:
 #elf.outdent()

 #elf.writeline("parent_template = environment.get_template(", node)
 #elf.visit(node.template, frame)
 #elf.write(f", {self.name!r})")
 #elf.writeline("for name, parent_block in parent_template.blocks.items():")
 #elf.indent()
 #elf.writeline("context.blocks.setdefault(name, []).append(parent_block)")
 #elf.outdent()

        # if this extends statement was in the root level we can take
        # advantage of that information and simplify the generated code
        # in the top level from this point onwards
 #f frame.rootlevel:
 #elf.has_known_extends = True

        # and now we have one more
 #elf.extends_so_far += 1

 #ef visit_Include(self, node: nodes.Include, frame: Frame) -> None:
 #""Handles includes."""
 #f node.ignore_missing:
 #elf.writeline("try:")
 #elf.indent()

 #unc_name = "get_or_select_template"
 #f isinstance(node.template, nodes.Const):
 #f isinstance(node.template.value, str):
 #unc_name = "get_template"
 #lif isinstance(node.template.value, (tuple, list)):
 #unc_name = "select_template"
 #lif isinstance(node.template, (nodes.Tuple, nodes.List)):
 #unc_name = "select_template"

 #elf.writeline(f"template = environment.{func_name}(", node)
 #elf.visit(node.template, frame)
 #elf.write(f", {self.name!r})")
 #f node.ignore_missing:
 #elf.outdent()
 #elf.writeline("except TemplateNotFound:")
 #elf.indent()
 #elf.writeline("pass")
 #elf.outdent()
 #elf.writeline("else:")
 #elf.indent()

 #ef loop_body() -> None:
 #elf.indent()
 #elf.simple_write("event", frame)
 #elf.outdent()

 #f node.with_context:
 #elf.writeline(
 #"gen = template.root_render_func("
 #template.new_context(context.get_all(), True,"
 #" {self.dump_local_context(frame)}))"
 #
 #elf.writeline("try:")
 #elf.indent()
 #elf.writeline(f"{self.choose_async()}for event in gen:")
 #oop_body()
 #elf.outdent()
 #elf.writeline(
 #"finally: {self.choose_async('await gen.aclose()', 'gen.close()')}"
 #
 #lif self.environment.is_async:
 #elf.writeline(
 #for event in (await template._get_default_module_async())"
 #._body_stream:"
 #
 #oop_body()
 #lse:
 #elf.writeline("yield from template._get_default_module()._body_stream")

 #f node.ignore_missing:
 #elf.outdent()

 #ef _import_common(
 #elf, node: t.Union[nodes.Import, nodes.FromImport], frame: Frame
 # -> None:
 #elf.write(f"{self.choose_async('await ')}environment.get_template(")
 #elf.visit(node.template, frame)
 #elf.write(f", {self.name!r}).")

 #f node.with_context:
 #_name = f"make_module{self.choose_async('_async')}"
 #elf.write(
 #"{f_name}(context.get_all(), True, {self.dump_local_context(frame)})"
 #
 #lse:
 #elf.write(f"_get_default_module{self.choose_async('_async')}(context)")

 #ef visit_Import(self, node: nodes.Import, frame: Frame) -> None:
 #""Visit regular imports."""
 #elf.writeline(f"{frame.symbols.ref(node.target)} = ", node)
 #f frame.toplevel:
 #elf.write(f"context.vars[{node.target!r}] = ")

 #elf._import_common(node, frame)

 #f frame.toplevel and not node.target.startswith("_"):
 #elf.writeline(f"context.exported_vars.discard({node.target!r})")

 #ef visit_FromImport(self, node: nodes.FromImport, frame: Frame) -> None:
 #""Visit named imports."""
 #elf.newline(node)
 #elf.write("included_template = ")
 #elf._import_common(node, frame)
 #ar_names = []
 #iscarded_names = []
 #or name in node.names:
 #f isinstance(name, tuple):
 #ame, alias = name
 #lse:
 #lias = name
 #elf.writeline(
 #"{frame.symbols.ref(alias)} ="
 #" getattr(included_template, {name!r}, missing)"
 #
 #elf.writeline(f"if {frame.symbols.ref(alias)} is missing:")
 #elf.indent()
            # The position will contain the template name, and will be formatted
            # into a string that will be compiled into an f-string. Curly braces
            # in the name must be replaced with escapes so that they will not be
            # executed as part of the f-string.
 #osition = self.position(node).replace("{", "{{").replace("}", "}}")
 #essage = (
 #the template {included_template.__name__!r}"
 #" (imported on {position})"
 #" does not export the requested name {name!r}"
 #
 #elf.writeline(
 #"{frame.symbols.ref(alias)} = undefined(f{message!r}, name={name!r})"
 #
 #elf.outdent()
 #f frame.toplevel:
 #ar_names.append(alias)
 #f not alias.startswith("_"):
 #iscarded_names.append(alias)

 #f var_names:
 #f len(var_names) == 1:
 #ame = var_names[0]
 #elf.writeline(f"context.vars[{name!r}] = {frame.symbols.ref(name)}")
 #lse:
 #ames_kv = ", ".join(
 #"{name!r}: {frame.symbols.ref(name)}" for name in var_names
 #
 #elf.writeline(f"context.vars.update({{{names_kv}}})")
 #f discarded_names:
 #f len(discarded_names) == 1:
 #elf.writeline(f"context.exported_vars.discard({discarded_names[0]!r})")
 #lse:
 #ames_str = ", ".join(map(repr, discarded_names))
 #elf.writeline(
 #"context.exported_vars.difference_update(({names_str}))"
 #

 #ef visit_For(self, node: nodes.For, frame: Frame) -> None:
 #oop_frame = frame.inner()
 #oop_frame.loop_frame = True
 #est_frame = frame.inner()
 #lse_frame = frame.inner()

        # try to figure out if we have an extended loop.  An extended loop
        # is necessary if the loop is in recursive mode if the special loop
        # variable is accessed in the body if the body is a scoped block.
 #xtended_loop = (
 #ode.recursive
 #r "loop"
 #n find_undeclared(node.iter_child_nodes(only=("body",)), ("loop",))
 #r any(block.scoped for block in node.find_all(nodes.Block))
 #

 #oop_ref = None
 #f extended_loop:
 #oop_ref = loop_frame.symbols.declare_parameter("loop")

 #oop_frame.symbols.analyze_node(node, for_branch="body")
 #f node.else_:
 #lse_frame.symbols.analyze_node(node, for_branch="else")

 #f node.test:
 #oop_filter_func = self.temporary_identifier()
 #est_frame.symbols.analyze_node(node, for_branch="test")
 #elf.writeline(f"{self.func(loop_filter_func)}(fiter):", node.test)
 #elf.indent()
 #elf.enter_frame(test_frame)
 #elf.writeline(self.choose_async("async for ", "for "))
 #elf.visit(node.target, loop_frame)
 #elf.write(" in ")
 #elf.write(self.choose_async("auto_aiter(fiter)", "fiter"))
 #elf.write(":")
 #elf.indent()
 #elf.writeline("if ", node.test)
 #elf.visit(node.test, test_frame)
 #elf.write(":")
 #elf.indent()
 #elf.writeline("yield ")
 #elf.visit(node.target, loop_frame)
 #elf.outdent(3)
 #elf.leave_frame(test_frame, with_python_scope=True)

        # if we don't have an recursive loop we have to find the shadowed
        # variables at that point.  Because loops can be nested but the loop
        # variable is a special one we have to enforce aliasing for it.
 #f node.recursive:
 #elf.writeline(
 #"{self.func('loop')}(reciter, loop_render_func, depth=0):", node
 #
 #elf.indent()
 #elf.buffer(loop_frame)

            # Use the same buffer for the else frame
 #lse_frame.buffer = loop_frame.buffer

        # make sure the loop variable is a special one and raise a template
        # assertion error if a loop tries to write to loop
 #f extended_loop:
 #elf.writeline(f"{loop_ref} = missing")

 #or name in node.find_all(nodes.Name):
 #f name.ctx == "store" and name.name == "loop":
 #elf.fail(
 #Can't assign to special loop variable in for-loop target",
 #ame.lineno,
 #

 #f node.else_:
 #teration_indicator = self.temporary_identifier()
 #elf.writeline(f"{iteration_indicator} = 1")

 #elf.writeline(self.choose_async("async for ", "for "), node)
 #elf.visit(node.target, loop_frame)
 #f extended_loop:
 #elf.write(f", {loop_ref} in {self.choose_async('Async')}LoopContext(")
 #lse:
 #elf.write(" in ")

 #f node.test:
 #elf.write(f"{loop_filter_func}(")
 #f node.recursive:
 #elf.write("reciter")
 #lse:
 #f self.environment.is_async and not extended_loop:
 #elf.write("auto_aiter(")
 #elf.visit(node.iter, frame)
 #f self.environment.is_async and not extended_loop:
 #elf.write(")")
 #f node.test:
 #elf.write(")")

 #f node.recursive:
 #elf.write(", undefined, loop_render_func, depth):")
 #lse:
 #elf.write(", undefined):" if extended_loop else ":")

 #elf.indent()
 #elf.enter_frame(loop_frame)

 #elf.writeline("_loop_vars = {}")
 #elf.blockvisit(node.body, loop_frame)
 #f node.else_:
 #elf.writeline(f"{iteration_indicator} = 0")
 #elf.outdent()
 #elf.leave_frame(
 #oop_frame, with_python_scope=node.recursive and not node.else_
 #

 #f node.else_:
 #elf.writeline(f"if {iteration_indicator}:")
 #elf.indent()
 #elf.enter_frame(else_frame)
 #elf.blockvisit(node.else_, else_frame)
 #elf.leave_frame(else_frame)
 #elf.outdent()

        # if the node was recursive we have to return the buffer contents
        # and start the iteration code
 #f node.recursive:
 #elf.return_buffer_contents(loop_frame)
 #elf.outdent()
 #elf.start_write(frame, node)
 #elf.write(f"{self.choose_async('await ')}loop(")
 #f self.environment.is_async:
 #elf.write("auto_aiter(")
 #elf.visit(node.iter, frame)
 #f self.environment.is_async:
 #elf.write(")")
 #elf.write(", loop)")
 #elf.end_write(frame)

        # at the end of the iteration, clear any assignments made in the
        # loop from the top level
 #f self._assign_stack:
 #elf._assign_stack[-1].difference_update(loop_frame.symbols.stores)

 #ef visit_If(self, node: nodes.If, frame: Frame) -> None:
 #f_frame = frame.soft()
 #elf.writeline("if ", node)
 #elf.visit(node.test, if_frame)
 #elf.write(":")
 #elf.indent()
 #elf.blockvisit(node.body, if_frame)
 #elf.outdent()
 #or elif_ in node.elif_:
 #elf.writeline("elif ", elif_)
 #elf.visit(elif_.test, if_frame)
 #elf.write(":")
 #elf.indent()
 #elf.blockvisit(elif_.body, if_frame)
 #elf.outdent()
 #f node.else_:
 #elf.writeline("else:")
 #elf.indent()
 #elf.blockvisit(node.else_, if_frame)
 #elf.outdent()

 #ef visit_Macro(self, node: nodes.Macro, frame: Frame) -> None:
 #acro_frame, macro_ref = self.macro_body(node, frame)
 #elf.newline()
 #f frame.toplevel:
 #f not node.name.startswith("_"):
 #elf.write(f"context.exported_vars.add({node.name!r})")
 #elf.writeline(f"context.vars[{node.name!r}] = ")
 #elf.write(f"{frame.symbols.ref(node.name)} = ")
 #elf.macro_def(macro_ref, macro_frame)

 #ef visit_CallBlock(self, node: nodes.CallBlock, frame: Frame) -> None:
 #all_frame, macro_ref = self.macro_body(node, frame)
 #elf.writeline("caller = ")
 #elf.macro_def(macro_ref, call_frame)
 #elf.start_write(frame, node)
 #elf.visit_Call(node.call, frame, forward_caller=True)
 #elf.end_write(frame)

 #ef visit_FilterBlock(self, node: nodes.FilterBlock, frame: Frame) -> None:
 #ilter_frame = frame.inner()
 #ilter_frame.symbols.analyze_node(node)
 #elf.enter_frame(filter_frame)
 #elf.buffer(filter_frame)
 #elf.blockvisit(node.body, filter_frame)
 #elf.start_write(frame, node)
 #elf.visit_Filter(node.filter, filter_frame)
 #elf.end_write(frame)
 #elf.leave_frame(filter_frame)

 #ef visit_With(self, node: nodes.With, frame: Frame) -> None:
 #ith_frame = frame.inner()
 #ith_frame.symbols.analyze_node(node)
 #elf.enter_frame(with_frame)
 #or target, expr in zip(node.targets, node.values):
 #elf.newline()
 #elf.visit(target, with_frame)
 #elf.write(" = ")
 #elf.visit(expr, frame)
 #elf.blockvisit(node.body, with_frame)
 #elf.leave_frame(with_frame)

 #ef visit_ExprStmt(self, node: nodes.ExprStmt, frame: Frame) -> None:
 #elf.newline(node)
 #elf.visit(node.node, frame)

 #lass _FinalizeInfo(t.NamedTuple):
 #onst: t.Optional[t.Callable[..., str]]
 #rc: t.Optional[str]

 #staticmethod
 #ef _default_finalize(value: t.Any) -> t.Any:
 #""The default finalize function if the environment isn't
 #onfigured with one. Or, if the environment has one, this is
 #alled on that function's output for constants.
 #""
 #eturn str(value)

 #finalize: t.Optional[_FinalizeInfo] = None

 #ef _make_finalize(self) -> _FinalizeInfo:
 #""Build the finalize function to be used on constants and at
 #untime. Cached so it's only created once for all output nodes.

 #eturns a ``namedtuple`` with the following attributes:

 #`const``
 # function to finalize constant data at compile time.

 #`src``
 #ource code to output around nodes to be evaluated at
 #untime.
 #""
 #f self._finalize is not None:
 #eturn self._finalize

 #inalize: t.Optional[t.Callable[..., t.Any]]
 #inalize = default = self._default_finalize
 #rc = None

 #f self.environment.finalize:
 #rc = "environment.finalize("
 #nv_finalize = self.environment.finalize
 #ass_arg = {
 #PassArg.context: "context",
 #PassArg.eval_context: "context.eval_ctx",
 #PassArg.environment: "environment",
 #.get(
 #PassArg.from_obj(env_finalize)  # type: ignore
 #
 #inalize = None

 #f pass_arg is None:

 #ef finalize(value: t.Any) -> t.Any:  # noqa: F811
 #eturn default(env_finalize(value))

 #lse:
 #rc = f"{src}{pass_arg}, "

 #f pass_arg == "environment":

 #ef finalize(value: t.Any) -> t.Any:  # noqa: F811
 #eturn default(env_finalize(self.environment, value))

 #elf._finalize = self._FinalizeInfo(finalize, src)
 #eturn self._finalize

 #ef _output_const_repr(self, group: t.Iterable[t.Any]) -> str:
 #""Given a group of constant values converted from ``Output``
 #hild nodes, produce a string to write to the template module
 #ource.
 #""
 #eturn repr(concat(group))

 #ef _output_child_to_const(
 #elf, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo
 # -> str:
 #""Try to optimize a child of an ``Output`` node by trying to
 #onvert it to constant, finalized data at compile time.

 #f :exc:`Impossible` is raised, the node is not constant and
 #ill be evaluated at runtime. Any other exception will also be
 #valuated at runtime for easier debugging.
 #""
 #onst = node.as_const(frame.eval_ctx)

 #f frame.eval_ctx.autoescape:
 #onst = escape(const)

        # Template data doesn't go through finalize.
 #f isinstance(node, nodes.TemplateData):
 #eturn str(const)

 #eturn finalize.const(const)  # type: ignore

 #ef _output_child_pre(
 #elf, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo
 # -> None:
 #""Output extra source code before visiting a child of an
 #`Output`` node.
 #""
 #f frame.eval_ctx.volatile:
 #elf.write("(escape if context.eval_ctx.autoescape else str)(")
 #lif frame.eval_ctx.autoescape:
 #elf.write("escape(")
 #lse:
 #elf.write("str(")

 #f finalize.src is not None:
 #elf.write(finalize.src)

 #ef _output_child_post(
 #elf, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo
 # -> None:
 #""Output extra source code after visiting a child of an
 #`Output`` node.
 #""
 #elf.write(")")

 #f finalize.src is not None:
 #elf.write(")")

 #ef visit_Output(self, node: nodes.Output, frame: Frame) -> None:
        # If an extends is active, don't render outside a block.
 #f frame.require_output_check:
            # A top-level extends is known to exist at compile time.
 #f self.has_known_extends:
 #eturn

 #elf.writeline("if parent_template is None:")
 #elf.indent()

 #inalize = self._make_finalize()
 #ody: t.List[t.Union[t.List[t.Any], nodes.Expr]] = []

        # Evaluate constants at compile time if possible. Each item in
        # body will be either a list of static data or a node to be
        # evaluated at runtime.
 #or child in node.nodes:
 #ry:
 #f not (
                    # If the finalize function requires runtime context,
                    # constants can't be evaluated at compile time.
 #inalize.const
                    # Unless it's basic template data that won't be
                    # finalized anyway.
 #r isinstance(child, nodes.TemplateData)
 #:
 #aise nodes.Impossible()

 #onst = self._output_child_to_const(child, frame, finalize)
 #xcept (nodes.Impossible, Exception):
                # The node was not constant and needs to be evaluated at
                # runtime. Or another error was raised, which is easier
                # to debug at runtime.
 #ody.append(child)
 #ontinue

 #f body and isinstance(body[-1], list):
 #ody[-1].append(const)
 #lse:
 #ody.append([const])

 #f frame.buffer is not None:
 #f len(body) == 1:
 #elf.writeline(f"{frame.buffer}.append(")
 #lse:
 #elf.writeline(f"{frame.buffer}.extend((")

 #elf.indent()

 #or item in body:
 #f isinstance(item, list):
                # A group of constant data to join and output.
 #al = self._output_const_repr(item)

 #f frame.buffer is None:
 #elf.writeline("yield " + val)
 #lse:
 #elf.writeline(val + ",")
 #lse:
 #f frame.buffer is None:
 #elf.writeline("yield ", item)
 #lse:
 #elf.newline(item)

                # A node to be evaluated at runtime.
 #elf._output_child_pre(item, frame, finalize)
 #elf.visit(item, frame)
 #elf._output_child_post(item, frame, finalize)

 #f frame.buffer is not None:
 #elf.write(",")

 #f frame.buffer is not None:
 #elf.outdent()
 #elf.writeline(")" if len(body) == 1 else "))")

 #f frame.require_output_check:
 #elf.outdent()

 #ef visit_Assign(self, node: nodes.Assign, frame: Frame) -> None:
 #elf.push_assign_tracking()

        # ``a.b`` is allowed for assignment, and is parsed as an NSRef. However,
        # it is only valid if it references a Namespace object. Emit a check for
        # that for each ref here, before assignment code is emitted. This can't
        # be done in visit_NSRef as the ref could be in the middle of a tuple.
 #een_refs: t.Set[str] = set()

 #or nsref in node.find_all(nodes.NSRef):
 #f nsref.name in seen_refs:
                # Only emit the check for each reference once, in case the same
                # ref is used multiple times in a tuple, `ns.a, ns.b = c, d`.
 #ontinue

 #een_refs.add(nsref.name)
 #ef = frame.symbols.ref(nsref.name)
 #elf.writeline(f"if not isinstance({ref}, Namespace):")
 #elf.indent()
 #elf.writeline(
 #raise TemplateRuntimeError"
 #("cannot assign attribute on non-namespace object")'
 #
 #elf.outdent()

 #elf.newline(node)
 #elf.visit(node.target, frame)
 #elf.write(" = ")
 #elf.visit(node.node, frame)
 #elf.pop_assign_tracking(frame)

 #ef visit_AssignBlock(self, node: nodes.AssignBlock, frame: Frame) -> None:
 #elf.push_assign_tracking()
 #lock_frame = frame.inner()
        # This is a special case.  Since a set block always captures we
        # will disable output checks.  This way one can use set blocks
        # toplevel even in extended templates.
 #lock_frame.require_output_check = False
 #lock_frame.symbols.analyze_node(node)
 #elf.enter_frame(block_frame)
 #elf.buffer(block_frame)
 #elf.blockvisit(node.body, block_frame)
 #elf.newline(node)
 #elf.visit(node.target, frame)
 #elf.write(" = (Markup if context.eval_ctx.autoescape else identity)(")
 #f node.filter is not None:
 #elf.visit_Filter(node.filter, block_frame)
 #lse:
 #elf.write(f"concat({block_frame.buffer})")
 #elf.write(")")
 #elf.pop_assign_tracking(frame)
 #elf.leave_frame(block_frame)

    # -- Expression Visitors

 #ef visit_Name(self, node: nodes.Name, frame: Frame) -> None:
 #f node.ctx == "store" and (
 #rame.toplevel or frame.loop_frame or frame.block_frame
 #:
 #f self._assign_stack:
 #elf._assign_stack[-1].add(node.name)
 #ef = frame.symbols.ref(node.name)

        # If we are looking up a variable we might have to deal with the
        # case where it's undefined.  We can skip that case if the load
        # instruction indicates a parameter which are always defined.
 #f node.ctx == "load":
 #oad = frame.symbols.find_load(ref)
 #f not (
 #oad is not None
 #nd load[0] == VAR_LOAD_PARAMETER
 #nd not self.parameter_is_undeclared(ref)
 #:
 #elf.write(
 #"(undefined(name={node.name!r}) if {ref} is missing else {ref})"
 #
 #eturn

 #elf.write(ref)

 #ef visit_NSRef(self, node: nodes.NSRef, frame: Frame) -> None:
        # NSRef is a dotted assignment target a.b=c, but uses a[b]=c internally.
        # visit_Assign emits code to validate that each ref is to a Namespace
        # object only. That can't be emitted here as the ref could be in the
        # middle of a tuple assignment.
 #ef = frame.symbols.ref(node.name)
 #elf.writeline(f"{ref}[{node.attr!r}]")

 #ef visit_Const(self, node: nodes.Const, frame: Frame) -> None:
 #al = node.as_const(frame.eval_ctx)
 #f isinstance(val, float):
 #elf.write(str(val))
 #lse:
 #elf.write(repr(val))

 #ef visit_TemplateData(self, node: nodes.TemplateData, frame: Frame) -> None:
 #ry:
 #elf.write(repr(node.as_const(frame.eval_ctx)))
 #xcept nodes.Impossible:
 #elf.write(
 #"(Markup if context.eval_ctx.autoescape else identity)({node.data!r})"
 #

 #ef visit_Tuple(self, node: nodes.Tuple, frame: Frame) -> None:
 #elf.write("(")
 #dx = -1
 #or idx, item in enumerate(node.items):
 #f idx:
 #elf.write(", ")
 #elf.visit(item, frame)
 #elf.write(",)" if idx == 0 else ")")

 #ef visit_List(self, node: nodes.List, frame: Frame) -> None:
 #elf.write("[")
 #or idx, item in enumerate(node.items):
 #f idx:
 #elf.write(", ")
 #elf.visit(item, frame)
 #elf.write("]")

 #ef visit_Dict(self, node: nodes.Dict, frame: Frame) -> None:
 #elf.write("{")
 #or idx, item in enumerate(node.items):
 #f idx:
 #elf.write(", ")
 #elf.visit(item.key, frame)
 #elf.write(": ")
 #elf.visit(item.value, frame)
 #elf.write("}")

 #isit_Add = _make_binop("+")
 #isit_Sub = _make_binop("-")
 #isit_Mul = _make_binop("*")
 #isit_Div = _make_binop("/")
 #isit_FloorDiv = _make_binop("//")
 #isit_Pow = _make_binop("**")
 #isit_Mod = _make_binop("%")
 #isit_And = _make_binop("and")
 #isit_Or = _make_binop("or")
 #isit_Pos = _make_unop("+")
 #isit_Neg = _make_unop("-")
 #isit_Not = _make_unop("not ")

 #optimizeconst
 #ef visit_Concat(self, node: nodes.Concat, frame: Frame) -> None:
 #f frame.eval_ctx.volatile:
 #unc_name = "(markup_join if context.eval_ctx.volatile else str_join)"
 #lif frame.eval_ctx.autoescape:
 #unc_name = "markup_join"
 #lse:
 #unc_name = "str_join"
 #elf.write(f"{func_name}((")
 #or arg in node.nodes:
 #elf.visit(arg, frame)
 #elf.write(", ")
 #elf.write("))")

 #optimizeconst
 #ef visit_Compare(self, node: nodes.Compare, frame: Frame) -> None:
 #elf.write("(")
 #elf.visit(node.expr, frame)
 #or op in node.ops:
 #elf.visit(op, frame)
 #elf.write(")")

 #ef visit_Operand(self, node: nodes.Operand, frame: Frame) -> None:
 #elf.write(f" {operators[node.op]} ")
 #elf.visit(node.expr, frame)

 #optimizeconst
 #ef visit_Getattr(self, node: nodes.Getattr, frame: Frame) -> None:
 #f self.environment.is_async:
 #elf.write("(await auto_await(")

 #elf.write("environment.getattr(")
 #elf.visit(node.node, frame)
 #elf.write(f", {node.attr!r})")

 #f self.environment.is_async:
 #elf.write("))")

 #optimizeconst
 #ef visit_Getitem(self, node: nodes.Getitem, frame: Frame) -> None:
        # slices bypass the environment getitem method.
 #f isinstance(node.arg, nodes.Slice):
 #elf.visit(node.node, frame)
 #elf.write("[")
 #elf.visit(node.arg, frame)
 #elf.write("]")
 #lse:
 #f self.environment.is_async:
 #elf.write("(await auto_await(")

 #elf.write("environment.getitem(")
 #elf.visit(node.node, frame)
 #elf.write(", ")
 #elf.visit(node.arg, frame)
 #elf.write(")")

 #f self.environment.is_async:
 #elf.write("))")

 #ef visit_Slice(self, node: nodes.Slice, frame: Frame) -> None:
 #f node.start is not None:
 #elf.visit(node.start, frame)
 #elf.write(":")
 #f node.stop is not None:
 #elf.visit(node.stop, frame)
 #f node.step is not None:
 #elf.write(":")
 #elf.visit(node.step, frame)

 #contextmanager
 #ef _filter_test_common(
 #elf, node: t.Union[nodes.Filter, nodes.Test], frame: Frame, is_filter: bool
 # -> t.Iterator[None]:
 #f self.environment.is_async:
 #elf.write("(await auto_await(")

 #f is_filter:
 #elf.write(f"{self.filters[node.name]}(")
 #unc = self.environment.filters.get(node.name)
 #lse:
 #elf.write(f"{self.tests[node.name]}(")
 #unc = self.environment.tests.get(node.name)

        # When inside an If or CondExpr frame, allow the filter to be
        # undefined at compile time and only raise an error if it's
        # actually called at runtime. See pull_dependencies.
 #f func is None and not frame.soft_frame:
 #ype_name = "filter" if is_filter else "test"
 #elf.fail(f"No {type_name} named {node.name!r}.", node.lineno)

 #ass_arg = {
 #PassArg.context: "context",
 #PassArg.eval_context: "context.eval_ctx",
 #PassArg.environment: "environment",
 #.get(
 #PassArg.from_obj(func)  # type: ignore
 #

 #f pass_arg is not None:
 #elf.write(f"{pass_arg}, ")

        # Back to the visitor function to handle visiting the target of
        # the filter or test.
 #ield

 #elf.signature(node, frame)
 #elf.write(")")

 #f self.environment.is_async:
 #elf.write("))")

 #optimizeconst
 #ef visit_Filter(self, node: nodes.Filter, frame: Frame) -> None:
 #ith self._filter_test_common(node, frame, True):
            # if the filter node is None we are inside a filter block
            # and want to write to the current buffer
 #f node.node is not None:
 #elf.visit(node.node, frame)
 #lif frame.eval_ctx.volatile:
 #elf.write(
 #"(Markup(concat({frame.buffer}))"
 #" if context.eval_ctx.autoescape else concat({frame.buffer}))"
 #
 #lif frame.eval_ctx.autoescape:
 #elf.write(f"Markup(concat({frame.buffer}))")
 #lse:
 #elf.write(f"concat({frame.buffer})")

 #optimizeconst
 #ef visit_Test(self, node: nodes.Test, frame: Frame) -> None:
 #ith self._filter_test_common(node, frame, False):
 #elf.visit(node.node, frame)

 #optimizeconst
 #ef visit_CondExpr(self, node: nodes.CondExpr, frame: Frame) -> None:
 #rame = frame.soft()

 #ef write_expr2() -> None:
 #f node.expr2 is not None:
 #elf.visit(node.expr2, frame)
 #eturn

 #elf.write(
 #'cond_expr_undefined("the inline if-expression on'
 #" {self.position(node)} evaluated to false and no else"
 #' section was defined.")'
 #

 #elf.write("(")
 #elf.visit(node.expr1, frame)
 #elf.write(" if ")
 #elf.visit(node.test, frame)
 #elf.write(" else ")
 #rite_expr2()
 #elf.write(")")

 #optimizeconst
 #ef visit_Call(
 #elf, node: nodes.Call, frame: Frame, forward_caller: bool = False
 # -> None:
 #f self.environment.is_async:
 #elf.write("(await auto_await(")
 #f self.environment.sandboxed:
 #elf.write("environment.call(context, ")
 #lse:
 #elf.write("context.call(")
 #elf.visit(node.node, frame)
 #xtra_kwargs = {"caller": "caller"} if forward_caller else None
 #oop_kwargs = {"_loop_vars": "_loop_vars"} if frame.loop_frame else {}
 #lock_kwargs = {"_block_vars": "_block_vars"} if frame.block_frame else {}
 #f extra_kwargs:
 #xtra_kwargs.update(loop_kwargs, **block_kwargs)
 #lif loop_kwargs or block_kwargs:
 #xtra_kwargs = dict(loop_kwargs, **block_kwargs)
 #elf.signature(node, frame, extra_kwargs)
 #elf.write(")")
 #f self.environment.is_async:
 #elf.write("))")

 #ef visit_Keyword(self, node: nodes.Keyword, frame: Frame) -> None:
 #elf.write(node.key + "=")
 #elf.visit(node.value, frame)

    # -- Unused nodes for extensions

 #ef visit_MarkSafe(self, node: nodes.MarkSafe, frame: Frame) -> None:
 #elf.write("Markup(")
 #elf.visit(node.expr, frame)
 #elf.write(")")

 #ef visit_MarkSafeIfAutoescape(
 #elf, node: nodes.MarkSafeIfAutoescape, frame: Frame
 # -> None:
 #elf.write("(Markup if context.eval_ctx.autoescape else identity)(")
 #elf.visit(node.expr, frame)
 #elf.write(")")

 #ef visit_EnvironmentAttribute(
 #elf, node: nodes.EnvironmentAttribute, frame: Frame
 # -> None:
 #elf.write("environment." + node.name)

 #ef visit_ExtensionAttribute(
 #elf, node: nodes.ExtensionAttribute, frame: Frame
 # -> None:
 #elf.write(f"environment.extensions[{node.identifier!r}].{node.name}")

 #ef visit_ImportedName(self, node: nodes.ImportedName, frame: Frame) -> None:
 #elf.write(self.import_aliases[node.importname])

 #ef visit_InternalName(self, node: nodes.InternalName, frame: Frame) -> None:
 #elf.write(node.name)

 #ef visit_ContextReference(
 #elf, node: nodes.ContextReference, frame: Frame
 # -> None:
 #elf.write("context")

 #ef visit_DerivedContextReference(
 #elf, node: nodes.DerivedContextReference, frame: Frame
 # -> None:
 #elf.write(self.derive_context(frame))

 #ef visit_Continue(self, node: nodes.Continue, frame: Frame) -> None:
 #elf.writeline("continue", node)

 #ef visit_Break(self, node: nodes.Break, frame: Frame) -> None:
 #elf.writeline("break", node)

 #ef visit_Scope(self, node: nodes.Scope, frame: Frame) -> None:
 #cope_frame = frame.inner()
 #cope_frame.symbols.analyze_node(node)
 #elf.enter_frame(scope_frame)
 #elf.blockvisit(node.body, scope_frame)
 #elf.leave_frame(scope_frame)

 #ef visit_OverlayScope(self, node: nodes.OverlayScope, frame: Frame) -> None:
 #tx = self.temporary_identifier()
 #elf.writeline(f"{ctx} = {self.derive_context(frame)}")
 #elf.writeline(f"{ctx}.vars = ")
 #elf.visit(node.context, frame)
 #elf.push_context_reference(ctx)

 #cope_frame = frame.inner(isolated=True)
 #cope_frame.symbols.analyze_node(node)
 #elf.enter_frame(scope_frame)
 #elf.blockvisit(node.body, scope_frame)
 #elf.leave_frame(scope_frame)
 #elf.pop_context_reference()

 #ef visit_EvalContextModifier(
 #elf, node: nodes.EvalContextModifier, frame: Frame
 # -> None:
 #or keyword in node.options:
 #elf.writeline(f"context.eval_ctx.{keyword.key} = ")
 #elf.visit(keyword.value, frame)
 #ry:
 #al = keyword.value.as_const(frame.eval_ctx)
 #xcept nodes.Impossible:
 #rame.eval_ctx.volatile = True
 #lse:
 #etattr(frame.eval_ctx, keyword.key, val)

 #ef visit_ScopedEvalContextModifier(
 #elf, node: nodes.ScopedEvalContextModifier, frame: Frame
 # -> None:
 #ld_ctx_name = self.temporary_identifier()
 #aved_ctx = frame.eval_ctx.save()
 #elf.writeline(f"{old_ctx_name} = context.eval_ctx.save()")
 #elf.visit_EvalContextModifier(node, frame)
 #or child in node.body:
 #elf.visit(child, frame)
 #rame.eval_ctx.revert(saved_ctx)
 #elf.writeline(f"context.eval_ctx.revert({old_ctx_name})")
