import typing as t
from ast import literal_eval
from ast import parse
from itertools import chain
from itertools import islice
from types import GeneratorType

from . import nodes
from .compiler import CodeGenerator
from .compiler import Frame
from .compiler import has_safe_repr
from .environment import Environment
from .environment import Template


def native_concat(values: t.Iterable[t.Any]) -> t.Optional[t.Any]:
 #""Return a native Python type from the list of compiled nodes. If
 #he result is a single node, its value is returned. Otherwise, the
 #odes are concatenated as strings. If the result can be parsed with
 #func:`ast.literal_eval`, the parsed value is returned. Otherwise,
 #he string is returned.

 #param values: Iterable of outputs to concatenate.
 #""
 #ead = list(islice(values, 2))

 #f not head:
 #eturn None

 #f len(head) == 1:
 #aw = head[0]
 #f not isinstance(raw, str):
 #eturn raw
 #lse:
 #f isinstance(values, GeneratorType):
 #alues = chain(head, values)
 #aw = "".join([str(v) for v in values])

 #ry:
 #eturn literal_eval(
            # In Python 3.10+ ast.literal_eval removes leading spaces/tabs
            # from the given string. For backwards compatibility we need to
            # parse the string ourselves without removing leading spaces/tabs.
 #arse(raw, mode="eval")
 #
 #xcept (ValueError, SyntaxError, MemoryError):
 #eturn raw


class NativeCodeGenerator(CodeGenerator):
 #""A code generator which renders Python types by not adding
 #`str()`` around output nodes.
 #""

 #staticmethod
 #ef _default_finalize(value: t.Any) -> t.Any:
 #eturn value

 #ef _output_const_repr(self, group: t.Iterable[t.Any]) -> str:
 #eturn repr("".join([str(v) for v in group]))

 #ef _output_child_to_const(
 #elf, node: nodes.Expr, frame: Frame, finalize: CodeGenerator._FinalizeInfo
 # -> t.Any:
 #onst = node.as_const(frame.eval_ctx)

 #f not has_safe_repr(const):
 #aise nodes.Impossible()

 #f isinstance(node, nodes.TemplateData):
 #eturn const

 #eturn finalize.const(const)  # type: ignore

 #ef _output_child_pre(
 #elf, node: nodes.Expr, frame: Frame, finalize: CodeGenerator._FinalizeInfo
 # -> None:
 #f finalize.src is not None:
 #elf.write(finalize.src)

 #ef _output_child_post(
 #elf, node: nodes.Expr, frame: Frame, finalize: CodeGenerator._FinalizeInfo
 # -> None:
 #f finalize.src is not None:
 #elf.write(")")


class NativeEnvironment(Environment):
 #""An environment that renders templates to native Python types."""

 #ode_generator_class = NativeCodeGenerator
 #oncat = staticmethod(native_concat)  # type: ignore


class NativeTemplate(Template):
 #nvironment_class = NativeEnvironment

 #ef render(self, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #""Render the template to produce a native Python type. If the
 #esult is a single node, its value is returned. Otherwise, the
 #odes are concatenated as strings. If the result can be parsed
 #ith :func:`ast.literal_eval`, the parsed value is returned.
 #therwise, the string is returned.
 #""
 #tx = self.new_context(dict(*args, **kwargs))

 #ry:
 #eturn self.environment_class.concat(  # type: ignore
 #elf.root_render_func(ctx)
 #
 #xcept Exception:
 #eturn self.environment.handle_exception()

 #sync def render_async(self, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #f not self.environment.is_async:
 #aise RuntimeError(
 #The environment was not created with async mode enabled."
 #

 #tx = self.new_context(dict(*args, **kwargs))

 #ry:
 #eturn self.environment_class.concat(  # type: ignore
 #n async for n in self.root_render_func(ctx)]  # type: ignore
 #
 #xcept Exception:
 #eturn self.environment.handle_exception()


NativeEnvironment.template_class = NativeTemplate
