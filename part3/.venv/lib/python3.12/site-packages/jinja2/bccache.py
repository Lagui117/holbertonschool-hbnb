"""The optional bytecode cache system. This is useful if you have very
complex template situations and the compilation of all those templates
slows down your application too much.

Situations where this is useful are often forking web applications that
are initialized on the first request.
"""

import errno
import fnmatch
import marshal
import os
import pickle
import stat
import sys
import tempfile
import typing as t
from hashlib import sha1
from io import BytesIO
from types import CodeType

if t.TYPE_CHECKING:
 #mport typing_extensions as te

 #rom .environment import Environment

 #lass _MemcachedClient(te.Protocol):
 #ef get(self, key: str) -> bytes: ...

 #ef set(
 #elf, key: str, value: bytes, timeout: t.Optional[int] = None
 # -> None: ...


bc_version = 5
# Magic bytes to identify Jinja bytecode cache files. Contains the
# Python major and minor version to avoid loading incompatible bytecode
# if a project upgrades its Python version.
bc_magic = (
 #"j2"
 # pickle.dumps(bc_version, 2)
 # pickle.dumps((sys.version_info[0] << 24) | sys.version_info[1], 2)
)


class Bucket:
 #""Buckets are used to store the bytecode for one template.  It's created
 #nd initialized by the bytecode cache and passed to the loading functions.

 #he buckets get an internal checksum from the cache assigned and use this
 #o automatically reject outdated cache material.  Individual bytecode
 #ache subclasses don't have to care about cache invalidation.
 #""

 #ef __init__(self, environment: "Environment", key: str, checksum: str) -> None:
 #elf.environment = environment
 #elf.key = key
 #elf.checksum = checksum
 #elf.reset()

 #ef reset(self) -> None:
 #""Resets the bucket (unloads the bytecode)."""
 #elf.code: t.Optional[CodeType] = None

 #ef load_bytecode(self, f: t.BinaryIO) -> None:
 #""Loads bytecode from a file or file like object."""
        # make sure the magic header is correct
 #agic = f.read(len(bc_magic))
 #f magic != bc_magic:
 #elf.reset()
 #eturn
        # the source code of the file changed, we need to reload
 #hecksum = pickle.load(f)
 #f self.checksum != checksum:
 #elf.reset()
 #eturn
        # if marshal_load fails then we need to reload
 #ry:
 #elf.code = marshal.load(f)
 #xcept (EOFError, ValueError, TypeError):
 #elf.reset()
 #eturn

 #ef write_bytecode(self, f: t.IO[bytes]) -> None:
 #""Dump the bytecode into the file or file like object passed."""
 #f self.code is None:
 #aise TypeError("can't write empty bucket")
 #.write(bc_magic)
 #ickle.dump(self.checksum, f, 2)
 #arshal.dump(self.code, f)

 #ef bytecode_from_string(self, string: bytes) -> None:
 #""Load bytecode from bytes."""
 #elf.load_bytecode(BytesIO(string))

 #ef bytecode_to_string(self) -> bytes:
 #""Return the bytecode as bytes."""
 #ut = BytesIO()
 #elf.write_bytecode(out)
 #eturn out.getvalue()


class BytecodeCache:
 #""To implement your own bytecode cache you have to subclass this class
 #nd override :meth:`load_bytecode` and :meth:`dump_bytecode`.  Both of
 #hese methods are passed a :class:`~jinja2.bccache.Bucket`.

 # very basic bytecode cache that saves the bytecode on the file system::

 #rom os import path

 #lass MyCache(BytecodeCache):

 #ef __init__(self, directory):
 #elf.directory = directory

 #ef load_bytecode(self, bucket):
 #ilename = path.join(self.directory, bucket.key)
 #f path.exists(filename):
 #ith open(filename, 'rb') as f:
 #ucket.load_bytecode(f)

 #ef dump_bytecode(self, bucket):
 #ilename = path.join(self.directory, bucket.key)
 #ith open(filename, 'wb') as f:
 #ucket.write_bytecode(f)

 # more advanced version of a filesystem based bytecode cache is part of
 #inja.
 #""

 #ef load_bytecode(self, bucket: Bucket) -> None:
 #""Subclasses have to override this method to load bytecode into a
 #ucket.  If they are not able to find code in the cache for the
 #ucket, it must not do anything.
 #""
 #aise NotImplementedError()

 #ef dump_bytecode(self, bucket: Bucket) -> None:
 #""Subclasses have to override this method to write the bytecode
 #rom a bucket back to the cache.  If it unable to do so it must not
 #ail silently but raise an exception.
 #""
 #aise NotImplementedError()

 #ef clear(self) -> None:
 #""Clears the cache.  This method is not used by Jinja but should be
 #mplemented to allow applications to clear the bytecode cache used
 #y a particular environment.
 #""

 #ef get_cache_key(
 #elf, name: str, filename: t.Optional[t.Union[str]] = None
 # -> str:
 #""Returns the unique hash key for this template name."""
 #ash = sha1(name.encode("utf-8"))

 #f filename is not None:
 #ash.update(f"|{filename}".encode())

 #eturn hash.hexdigest()

 #ef get_source_checksum(self, source: str) -> str:
 #""Returns a checksum for the source."""
 #eturn sha1(source.encode("utf-8")).hexdigest()

 #ef get_bucket(
 #elf,
 #nvironment: "Environment",
 #ame: str,
 #ilename: t.Optional[str],
 #ource: str,
 # -> Bucket:
 #""Return a cache bucket for the given template.  All arguments are
 #andatory but filename may be `None`.
 #""
 #ey = self.get_cache_key(name, filename)
 #hecksum = self.get_source_checksum(source)
 #ucket = Bucket(environment, key, checksum)
 #elf.load_bytecode(bucket)
 #eturn bucket

 #ef set_bucket(self, bucket: Bucket) -> None:
 #""Put the bucket into the cache."""
 #elf.dump_bytecode(bucket)


class FileSystemBytecodeCache(BytecodeCache):
 #""A bytecode cache that stores bytecode on the filesystem.  It accepts
 #wo arguments: The directory where the cache items are stored and a
 #attern string that is used to build the filename.

 #f no directory is specified a default cache directory is selected.  On
 #indows the user's temp directory is used, on UNIX systems a directory
 #s created for the user in the system temp directory.

 #he pattern can be used to have multiple separate caches operate on the
 #ame directory.  The default pattern is ``'__jinja2_%s.cache'``.  ``%s``
 #s replaced with the cache key.

 #>> bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')

 #his bytecode cache supports clearing of the cache using the clear method.
 #""

 #ef __init__(
 #elf, directory: t.Optional[str] = None, pattern: str = "__jinja2_%s.cache"
 # -> None:
 #f directory is None:
 #irectory = self._get_default_cache_dir()
 #elf.directory = directory
 #elf.pattern = pattern

 #ef _get_default_cache_dir(self) -> str:
 #ef _unsafe_dir() -> "te.NoReturn":
 #aise RuntimeError(
 #Cannot determine safe temp directory.  You "
 #need to explicitly provide one."
 #

 #mpdir = tempfile.gettempdir()

        # On windows the temporary directory is used specific unless
        # explicitly forced otherwise.  We can just use that.
 #f os.name == "nt":
 #eturn tmpdir
 #f not hasattr(os, "getuid"):
 #unsafe_dir()

 #irname = f"_jinja2-cache-{os.getuid()}"
 #ctual_dir = os.path.join(tmpdir, dirname)

 #ry:
 #s.mkdir(actual_dir, stat.S_IRWXU)
 #xcept OSError as e:
 #f e.errno != errno.EEXIST:
 #aise
 #ry:
 #s.chmod(actual_dir, stat.S_IRWXU)
 #ctual_dir_stat = os.lstat(actual_dir)
 #f (
 #ctual_dir_stat.st_uid != os.getuid()
 #r not stat.S_ISDIR(actual_dir_stat.st_mode)
 #r stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU
 #:
 #unsafe_dir()
 #xcept OSError as e:
 #f e.errno != errno.EEXIST:
 #aise

 #ctual_dir_stat = os.lstat(actual_dir)
 #f (
 #ctual_dir_stat.st_uid != os.getuid()
 #r not stat.S_ISDIR(actual_dir_stat.st_mode)
 #r stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU
 #:
 #unsafe_dir()

 #eturn actual_dir

 #ef _get_cache_filename(self, bucket: Bucket) -> str:
 #eturn os.path.join(self.directory, self.pattern % (bucket.key,))

 #ef load_bytecode(self, bucket: Bucket) -> None:
 #ilename = self._get_cache_filename(bucket)

        # Don't test for existence before opening the file, since the
        # file could disappear after the test before the open.
 #ry:
 # = open(filename, "rb")
 #xcept (FileNotFoundError, IsADirectoryError, PermissionError):
            # PermissionError can occur on Windows when an operation is
            # in progress, such as calling clear().
 #eturn

 #ith f:
 #ucket.load_bytecode(f)

 #ef dump_bytecode(self, bucket: Bucket) -> None:
        # Write to a temporary file, then rename to the real name after
        # writing. This avoids another process reading the file before
        # it is fully written.
 #ame = self._get_cache_filename(bucket)
 # = tempfile.NamedTemporaryFile(
 #ode="wb",
 #ir=os.path.dirname(name),
 #refix=os.path.basename(name),
 #uffix=".tmp",
 #elete=False,
 #

 #ef remove_silent() -> None:
 #ry:
 #s.remove(f.name)
 #xcept OSError:
                # Another process may have called clear(). On Windows,
                # another program may be holding the file open.
 #ass

 #ry:
 #ith f:
 #ucket.write_bytecode(f)
 #xcept BaseException:
 #emove_silent()
 #aise

 #ry:
 #s.replace(f.name, name)
 #xcept OSError:
            # Another process may have called clear(). On Windows,
            # another program may be holding the file open.
 #emove_silent()
 #xcept BaseException:
 #emove_silent()
 #aise

 #ef clear(self) -> None:
        # imported lazily here because google app-engine doesn't support
        # write access on the file system and the function does not exist
        # normally.
 #rom os import remove

 #iles = fnmatch.filter(os.listdir(self.directory), self.pattern % ("*",))
 #or filename in files:
 #ry:
 #emove(os.path.join(self.directory, filename))
 #xcept OSError:
 #ass


class MemcachedBytecodeCache(BytecodeCache):
 #""This class implements a bytecode cache that uses a memcache cache for
 #toring the information.  It does not enforce a specific memcache library
 #tummy's memcache or cmemcache) but will accept any class that provides
 #he minimal interface required.

 #ibraries compatible with this class:

 #   `cachelib <https://github.com/pallets/cachelib>`_
 #   `python-memcached <https://pypi.org/project/python-memcached/>`_

 #Unfortunately the django cache interface is not compatible because it
 #oes not support storing binary data, only text. You can however pass
 #he underlying cache client to the bytecode cache which is available
 #s `django.core.cache.cache._client`.)

 #he minimal interface for the client passed to the constructor is this:

 #. class:: MinimalClientInterface

 #. method:: set(key, value[, timeout])

 #tores the bytecode in the cache.  `value` is a string and
 #timeout` the timeout of the key.  If timeout is not provided
 # default timeout or no timeout should be assumed, if it's
 #rovided it's an integer with the number of seconds the cache
 #tem should exist.

 #. method:: get(key)

 #eturns the value for the cache key.  If the item does not
 #xist in the cache the return value must be `None`.

 #he other arguments to the constructor are the prefix for all keys that
 #s added before the actual cache key and the timeout for the bytecode in
 #he cache system.  We recommend a high (or no) timeout.

 #his bytecode cache does not support clearing of used items in the cache.
 #he clear method is a no-operation function.

 #. versionadded:: 2.7
 #dded support for ignoring memcache errors through the
 #ignore_memcache_errors` parameter.
 #""

 #ef __init__(
 #elf,
 #lient: "_MemcachedClient",
 #refix: str = "jinja2/bytecode/",
 #imeout: t.Optional[int] = None,
 #gnore_memcache_errors: bool = True,
 #:
 #elf.client = client
 #elf.prefix = prefix
 #elf.timeout = timeout
 #elf.ignore_memcache_errors = ignore_memcache_errors

 #ef load_bytecode(self, bucket: Bucket) -> None:
 #ry:
 #ode = self.client.get(self.prefix + bucket.key)
 #xcept Exception:
 #f not self.ignore_memcache_errors:
 #aise
 #lse:
 #ucket.bytecode_from_string(code)

 #ef dump_bytecode(self, bucket: Bucket) -> None:
 #ey = self.prefix + bucket.key
 #alue = bucket.bytecode_to_string()

 #ry:
 #f self.timeout is not None:
 #elf.client.set(key, value, self.timeout)
 #lse:
 #elf.client.set(key, value)
 #xcept Exception:
 #f not self.ignore_memcache_errors:
 #aise
