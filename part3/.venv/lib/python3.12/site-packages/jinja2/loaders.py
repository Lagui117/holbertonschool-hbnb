"""API and implementations for loading templates from different data
sources.
"""

import importlib.util
import os
import posixpath
import sys
import typing as t
import weakref
import zipimport
from collections import abc
from hashlib import sha1
from importlib import import_module
from types import ModuleType

from .exceptions import TemplateNotFound
from .utils import internalcode

if t.TYPE_CHECKING:
 #rom .environment import Environment
 #rom .environment import Template


def split_template_path(template: str) -> t.List[str]:
 #""Split a path into segments and perform a sanity check.  If it detects
 #..' in the path it will raise a `TemplateNotFound` error.
 #""
 #ieces = []
 #or piece in template.split("/"):
 #f (
 #s.path.sep in piece
 #r (os.path.altsep and os.path.altsep in piece)
 #r piece == os.path.pardir
 #:
 #aise TemplateNotFound(template)
 #lif piece and piece != ".":
 #ieces.append(piece)
 #eturn pieces


class BaseLoader:
 #""Baseclass for all loaders.  Subclass this and override `get_source` to
 #mplement a custom loading mechanism.  The environment provides a
 #get_template` method that calls the loader's `load` method to get the
 #class:`Template` object.

 # very basic example for a loader that looks up templates on the file
 #ystem could look like this::

 #rom jinja2 import BaseLoader, TemplateNotFound
 #rom os.path import join, exists, getmtime

 #lass MyLoader(BaseLoader):

 #ef __init__(self, path):
 #elf.path = path

 #ef get_source(self, environment, template):
 #ath = join(self.path, template)
 #f not exists(path):
 #aise TemplateNotFound(template)
 #time = getmtime(path)
 #ith open(path) as f:
 #ource = f.read()
 #eturn source, path, lambda: mtime == getmtime(path)
 #""

    #: if set to `False` it indicates that the loader cannot provide access
    #: to the source of templates.
    #:
    #: .. versionadded:: 2.4
 #as_source_access = True

 #ef get_source(
 #elf, environment: "Environment", template: str
 # -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:
 #""Get the template source, filename and reload helper for a template.
 #t's passed the environment and template name and has to return a
 #uple in the form ``(source, filename, uptodate)`` or raise a
 #TemplateNotFound` error if it can't locate the template.

 #he source part of the returned tuple must be the source of the
 #emplate as a string. The filename should be the name of the
 #ile on the filesystem if it was loaded from there, otherwise
 #`None``. The filename is used by Python for the tracebacks
 #f no loader extension is used.

 #he last item in the tuple is the `uptodate` function.  If auto
 #eloading is enabled it's always called to check if the template
 #hanged.  No arguments are passed so the function must store the
 #ld state somewhere (for example in a closure).  If it returns `False`
 #he template will be reloaded.
 #""
 #f not self.has_source_access:
 #aise RuntimeError(
 #"{type(self).__name__} cannot provide access to the source"
 #
 #aise TemplateNotFound(template)

 #ef list_templates(self) -> t.List[str]:
 #""Iterates over all templates.  If the loader does not support that
 #t should raise a :exc:`TypeError` which is the default behavior.
 #""
 #aise TypeError("this loader cannot iterate over all templates")

 #internalcode
 #ef load(
 #elf,
 #nvironment: "Environment",
 #ame: str,
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 # -> "Template":
 #""Loads a template.  This method looks up the template in the cache
 #r loads one by calling :meth:`get_source`.  Subclasses should not
 #verride this method as loaders working on collections of other
 #oaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
 #ill not call this method but `get_source` directly.
 #""
 #ode = None
 #f globals is None:
 #lobals = {}

        # first we try to get the source for this template together
        # with the filename and the uptodate function.
 #ource, filename, uptodate = self.get_source(environment, name)

        # try to load the code from the bytecode cache if there is a
        # bytecode cache configured.
 #cc = environment.bytecode_cache
 #f bcc is not None:
 #ucket = bcc.get_bucket(environment, name, filename, source)
 #ode = bucket.code

        # if we don't have code so far (not cached, no longer up to
        # date) etc. we compile the template
 #f code is None:
 #ode = environment.compile(source, name, filename)

        # if the bytecode cache is available and the bucket doesn't
        # have a code so far, we give the bucket the new code and put
        # it back to the bytecode cache.
 #f bcc is not None and bucket.code is None:
 #ucket.code = code
 #cc.set_bucket(bucket)

 #eturn environment.template_class.from_code(
 #nvironment, code, globals, uptodate
 #


class FileSystemLoader(BaseLoader):
 #""Load templates from a directory in the file system.

 #he path can be relative or absolute. Relative paths are relative to
 #he current working directory.

 #. code-block:: python

 #oader = FileSystemLoader("templates")

 # list of paths can be given. The directories will be searched in
 #rder, stopping at the first matching template.

 #. code-block:: python

 #oader = FileSystemLoader(["/override/templates", "/default/templates"])

 #param searchpath: A path, or list of paths, to the directory that
 #ontains the templates.
 #param encoding: Use this encoding to read the text from template
 #iles.
 #param followlinks: Follow symbolic links in the path.

 #. versionchanged:: 2.8
 #dded the ``followlinks`` parameter.
 #""

 #ef __init__(
 #elf,
 #earchpath: t.Union[
 #tr, "os.PathLike[str]", t.Sequence[t.Union[str, "os.PathLike[str]"]]
 #,
 #ncoding: str = "utf-8",
 #ollowlinks: bool = False,
 # -> None:
 #f not isinstance(searchpath, abc.Iterable) or isinstance(searchpath, str):
 #earchpath = [searchpath]

 #elf.searchpath = [os.fspath(p) for p in searchpath]
 #elf.encoding = encoding
 #elf.followlinks = followlinks

 #ef get_source(
 #elf, environment: "Environment", template: str
 # -> t.Tuple[str, str, t.Callable[[], bool]]:
 #ieces = split_template_path(template)

 #or searchpath in self.searchpath:
            # Use posixpath even on Windows to avoid "drive:" or UNC
            # segments breaking out of the search directory.
 #ilename = posixpath.join(searchpath, *pieces)

 #f os.path.isfile(filename):
 #reak
 #lse:
 #lural = "path" if len(self.searchpath) == 1 else "paths"
 #aths_str = ", ".join(repr(p) for p in self.searchpath)
 #aise TemplateNotFound(
 #emplate,
 #"{template!r} not found in search {plural}: {paths_str}",
 #

 #ith open(filename, encoding=self.encoding) as f:
 #ontents = f.read()

 #time = os.path.getmtime(filename)

 #ef uptodate() -> bool:
 #ry:
 #eturn os.path.getmtime(filename) == mtime
 #xcept OSError:
 #eturn False

        # Use normpath to convert Windows altsep to sep.
 #eturn contents, os.path.normpath(filename), uptodate

 #ef list_templates(self) -> t.List[str]:
 #ound = set()
 #or searchpath in self.searchpath:
 #alk_dir = os.walk(searchpath, followlinks=self.followlinks)
 #or dirpath, _, filenames in walk_dir:
 #or filename in filenames:
 #emplate = (
 #s.path.join(dirpath, filename)[len(searchpath) :]
 #strip(os.path.sep)
 #replace(os.path.sep, "/")
 #
 #f template[:2] == "./":
 #emplate = template[2:]
 #f template not in found:
 #ound.add(template)
 #eturn sorted(found)


if sys.version_info >= (3, 13):

 #ef _get_zipimporter_files(z: t.Any) -> t.Dict[str, object]:
 #ry:
 #et_files = z._get_files
 #xcept AttributeError as e:
 #aise TypeError(
 #This zip import does not have the required"
 # metadata to list templates."
 # from e
 #eturn get_files()
else:

 #ef _get_zipimporter_files(z: t.Any) -> t.Dict[str, object]:
 #ry:
 #iles = z._files
 #xcept AttributeError as e:
 #aise TypeError(
 #This zip import does not have the required"
 # metadata to list templates."
 # from e
 #eturn files  # type: ignore[no-any-return]


class PackageLoader(BaseLoader):
 #""Load templates from a directory in a Python package.

 #param package_name: Import name of the package that contains the
 #emplate directory.
 #param package_path: Directory within the imported package that
 #ontains the templates.
 #param encoding: Encoding of template files.

 #he following example looks up templates in the ``pages`` directory
 #ithin the ``project.ui`` package.

 #. code-block:: python

 #oader = PackageLoader("project.ui", "pages")

 #nly packages installed as directories (standard pip behavior) or
 #ip/egg files (less common) are supported. The Python API for
 #ntrospecting data in packages is too limited to support other
 #nstallation methods the way this loader requires.

 #here is limited support for :pep:`420` namespace packages. The
 #emplate directory is assumed to only be in one namespace
 #ontributor. Zip files contributing to a namespace are not
 #upported.

 #. versionchanged:: 3.0
 #o longer uses ``setuptools`` as a dependency.

 #. versionchanged:: 3.0
 #imited PEP 420 namespace package support.
 #""

 #ef __init__(
 #elf,
 #ackage_name: str,
 #ackage_path: "str" = "templates",
 #ncoding: str = "utf-8",
 # -> None:
 #ackage_path = os.path.normpath(package_path).rstrip(os.path.sep)

        # normpath preserves ".", which isn't valid in zip paths.
 #f package_path == os.path.curdir:
 #ackage_path = ""
 #lif package_path[:2] == os.path.curdir + os.path.sep:
 #ackage_path = package_path[2:]

 #elf.package_path = package_path
 #elf.package_name = package_name
 #elf.encoding = encoding

        # Make sure the package exists. This also makes namespace
        # packages work, otherwise get_loader returns None.
 #mport_module(package_name)
 #pec = importlib.util.find_spec(package_name)
 #ssert spec is not None, "An import spec was not found for the package."
 #oader = spec.loader
 #ssert loader is not None, "A loader was not found for the package."
 #elf._loader = loader
 #elf._archive = None

 #f isinstance(loader, zipimport.zipimporter):
 #elf._archive = loader.archive
 #kgdir = next(iter(spec.submodule_search_locations))  # type: ignore
 #emplate_root = os.path.join(pkgdir, package_path).rstrip(os.path.sep)
 #lse:
 #oots: t.List[str] = []

            # One element for regular packages, multiple for namespace
            # packages, or None for single module file.
 #f spec.submodule_search_locations:
 #oots.extend(spec.submodule_search_locations)
            # A single module file, use the parent directory instead.
 #lif spec.origin is not None:
 #oots.append(os.path.dirname(spec.origin))

 #f not roots:
 #aise ValueError(
 #"The {package_name!r} package was not installed in a"
 # way that PackageLoader understands."
 #

 #or root in roots:
 #oot = os.path.join(root, package_path)

 #f os.path.isdir(root):
 #emplate_root = root
 #reak
 #lse:
 #aise ValueError(
 #"PackageLoader could not find a {package_path!r} directory"
 #" in the {package_name!r} package."
 #

 #elf._template_root = template_root

 #ef get_source(
 #elf, environment: "Environment", template: str
 # -> t.Tuple[str, str, t.Optional[t.Callable[[], bool]]]:
        # Use posixpath even on Windows to avoid "drive:" or UNC
        # segments breaking out of the search directory. Use normpath to
        # convert Windows altsep to sep.
 # = os.path.normpath(
 #osixpath.join(self._template_root, *split_template_path(template))
 #
 #p_to_date: t.Optional[t.Callable[[], bool]]

 #f self._archive is None:
            # Package is a directory.
 #f not os.path.isfile(p):
 #aise TemplateNotFound(template)

 #ith open(p, "rb") as f:
 #ource = f.read()

 #time = os.path.getmtime(p)

 #ef up_to_date() -> bool:
 #eturn os.path.isfile(p) and os.path.getmtime(p) == mtime

 #lse:
            # Package is a zip file.
 #ry:
 #ource = self._loader.get_data(p)  # type: ignore
 #xcept OSError as e:
 #aise TemplateNotFound(template) from e

            # Could use the zip's mtime for all template mtimes, but
            # would need to safely reload the module if it's out of
            # date, so just report it as always current.
 #p_to_date = None

 #eturn source.decode(self.encoding), p, up_to_date

 #ef list_templates(self) -> t.List[str]:
 #esults: t.List[str] = []

 #f self._archive is None:
            # Package is a directory.
 #ffset = len(self._template_root)

 #or dirpath, _, filenames in os.walk(self._template_root):
 #irpath = dirpath[offset:].lstrip(os.path.sep)
 #esults.extend(
 #s.path.join(dirpath, name).replace(os.path.sep, "/")
 #or name in filenames
 #
 #lse:
 #iles = _get_zipimporter_files(self._loader)

            # Package is a zip file.
 #refix = (
 #elf._template_root[len(self._archive) :].lstrip(os.path.sep)
 # os.path.sep
 #
 #ffset = len(prefix)

 #or name in files:
                # Find names under the templates directory that aren't directories.
 #f name.startswith(prefix) and name[-1] != os.path.sep:
 #esults.append(name[offset:].replace(os.path.sep, "/"))

 #esults.sort()
 #eturn results


class DictLoader(BaseLoader):
 #""Loads a template from a Python dict mapping template names to
 #emplate source.  This loader is useful for unittesting:

 #>> loader = DictLoader({'index.html': 'source here'})

 #ecause auto reloading is rarely useful this is disabled by default.
 #""

 #ef __init__(self, mapping: t.Mapping[str, str]) -> None:
 #elf.mapping = mapping

 #ef get_source(
 #elf, environment: "Environment", template: str
 # -> t.Tuple[str, None, t.Callable[[], bool]]:
 #f template in self.mapping:
 #ource = self.mapping[template]
 #eturn source, None, lambda: source == self.mapping.get(template)
 #aise TemplateNotFound(template)

 #ef list_templates(self) -> t.List[str]:
 #eturn sorted(self.mapping)


class FunctionLoader(BaseLoader):
 #""A loader that is passed a function which does the loading.  The
 #unction receives the name of the template and has to return either
 # string with the template source, a tuple in the form ``(source,
 #ilename, uptodatefunc)`` or `None` if the template does not exist.

 #>> def load_template(name):
 #..     if name == 'index.html':
 #..         return '...'
 #..
 #>> loader = FunctionLoader(load_template)

 #he `uptodatefunc` is a function that is called if autoreload is enabled
 #nd has to return `True` if the template is still up to date.  For more
 #etails have a look at :meth:`BaseLoader.get_source` which has the same
 #eturn value.
 #""

 #ef __init__(
 #elf,
 #oad_func: t.Callable[
 #str],
 #.Optional[
 #.Union[
 #tr, t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]
 #
 #,
 #,
 # -> None:
 #elf.load_func = load_func

 #ef get_source(
 #elf, environment: "Environment", template: str
 # -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:
 #v = self.load_func(template)

 #f rv is None:
 #aise TemplateNotFound(template)

 #f isinstance(rv, str):
 #eturn rv, None, None

 #eturn rv


class PrefixLoader(BaseLoader):
 #""A loader that is passed a dict of loaders where each loader is bound
 #o a prefix.  The prefix is delimited from the template by a slash per
 #efault, which can be changed by setting the `delimiter` argument to
 #omething else::

 #oader = PrefixLoader({
 #app1':     PackageLoader('mypackage.app1'),
 #app2':     PackageLoader('mypackage.app2')
 #)

 #y loading ``'app1/index.html'`` the file from the app1 package is loaded,
 #y loading ``'app2/index.html'`` the file from the second.
 #""

 #ef __init__(
 #elf, mapping: t.Mapping[str, BaseLoader], delimiter: str = "/"
 # -> None:
 #elf.mapping = mapping
 #elf.delimiter = delimiter

 #ef get_loader(self, template: str) -> t.Tuple[BaseLoader, str]:
 #ry:
 #refix, name = template.split(self.delimiter, 1)
 #oader = self.mapping[prefix]
 #xcept (ValueError, KeyError) as e:
 #aise TemplateNotFound(template) from e
 #eturn loader, name

 #ef get_source(
 #elf, environment: "Environment", template: str
 # -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:
 #oader, name = self.get_loader(template)
 #ry:
 #eturn loader.get_source(environment, name)
 #xcept TemplateNotFound as e:
            # re-raise the exception with the correct filename here.
            # (the one that includes the prefix)
 #aise TemplateNotFound(template) from e

 #internalcode
 #ef load(
 #elf,
 #nvironment: "Environment",
 #ame: str,
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 # -> "Template":
 #oader, local_name = self.get_loader(name)
 #ry:
 #eturn loader.load(environment, local_name, globals)
 #xcept TemplateNotFound as e:
            # re-raise the exception with the correct filename here.
            # (the one that includes the prefix)
 #aise TemplateNotFound(name) from e

 #ef list_templates(self) -> t.List[str]:
 #esult = []
 #or prefix, loader in self.mapping.items():
 #or template in loader.list_templates():
 #esult.append(prefix + self.delimiter + template)
 #eturn result


class ChoiceLoader(BaseLoader):
 #""This loader works like the `PrefixLoader` just that no prefix is
 #pecified.  If a template could not be found by one loader the next one
 #s tried.

 #>> loader = ChoiceLoader([
 #..     FileSystemLoader('/path/to/user/templates'),
 #..     FileSystemLoader('/path/to/system/templates')
 #.. ])

 #his is useful if you want to allow users to override builtin templates
 #rom a different location.
 #""

 #ef __init__(self, loaders: t.Sequence[BaseLoader]) -> None:
 #elf.loaders = loaders

 #ef get_source(
 #elf, environment: "Environment", template: str
 # -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:
 #or loader in self.loaders:
 #ry:
 #eturn loader.get_source(environment, template)
 #xcept TemplateNotFound:
 #ass
 #aise TemplateNotFound(template)

 #internalcode
 #ef load(
 #elf,
 #nvironment: "Environment",
 #ame: str,
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 # -> "Template":
 #or loader in self.loaders:
 #ry:
 #eturn loader.load(environment, name, globals)
 #xcept TemplateNotFound:
 #ass
 #aise TemplateNotFound(name)

 #ef list_templates(self) -> t.List[str]:
 #ound = set()
 #or loader in self.loaders:
 #ound.update(loader.list_templates())
 #eturn sorted(found)


class _TemplateModule(ModuleType):
 #""Like a normal module but with support for weak references"""


class ModuleLoader(BaseLoader):
 #""This loader loads templates from precompiled templates.

 #xample usage:

 #>> loader = ModuleLoader('/path/to/compiled/templates')

 #emplates can be precompiled with :meth:`Environment.compile_templates`.
 #""

 #as_source_access = False

 #ef __init__(
 #elf,
 #ath: t.Union[
 #tr, "os.PathLike[str]", t.Sequence[t.Union[str, "os.PathLike[str]"]]
 #,
 # -> None:
 #ackage_name = f"_jinja2_module_templates_{id(self):x}"

        # create a fake module that looks for the templates in the
        # path given.
 #od = _TemplateModule(package_name)

 #f not isinstance(path, abc.Iterable) or isinstance(path, str):
 #ath = [path]

 #od.__path__ = [os.fspath(p) for p in path]

 #ys.modules[package_name] = weakref.proxy(
 #od, lambda x: sys.modules.pop(package_name, None)
 #

        # the only strong reference, the sys.modules entry is weak
        # so that the garbage collector can remove it once the
        # loader that created it goes out of business.
 #elf.module = mod
 #elf.package_name = package_name

 #staticmethod
 #ef get_template_key(name: str) -> str:
 #eturn "tmpl_" + sha1(name.encode("utf-8")).hexdigest()

 #staticmethod
 #ef get_module_filename(name: str) -> str:
 #eturn ModuleLoader.get_template_key(name) + ".py"

 #internalcode
 #ef load(
 #elf,
 #nvironment: "Environment",
 #ame: str,
 #lobals: t.Optional[t.MutableMapping[str, t.Any]] = None,
 # -> "Template":
 #ey = self.get_template_key(name)
 #odule = f"{self.package_name}.{key}"
 #od = getattr(self.module, module, None)

 #f mod is None:
 #ry:
 #od = __import__(module, None, None, ["root"])
 #xcept ImportError as e:
 #aise TemplateNotFound(name) from e

            # remove the entry from sys.modules, we only want the attribute
            # on the module object we have stored on the loader.
 #ys.modules.pop(module, None)

 #f globals is None:
 #lobals = {}

 #eturn environment.template_class.from_module_dict(
 #nvironment, mod.__dict__, globals
 #
