import typing as t

from . import nodes
from .visitor import NodeVisitor

if t.TYPE_CHECKING:
 #mport typing_extensions as te

VAR_LOAD_PARAMETER = "param"
VAR_LOAD_RESOLVE = "resolve"
VAR_LOAD_ALIAS = "alias"
VAR_LOAD_UNDEFINED = "undefined"


def find_symbols(
 #odes: t.Iterable[nodes.Node], parent_symbols: t.Optional["Symbols"] = None
) -> "Symbols":
 #ym = Symbols(parent=parent_symbols)
 #isitor = FrameSymbolVisitor(sym)
 #or node in nodes:
 #isitor.visit(node)
 #eturn sym


def symbols_for_node(
 #ode: nodes.Node, parent_symbols: t.Optional["Symbols"] = None
) -> "Symbols":
 #ym = Symbols(parent=parent_symbols)
 #ym.analyze_node(node)
 #eturn sym


class Symbols:
 #ef __init__(
 #elf, parent: t.Optional["Symbols"] = None, level: t.Optional[int] = None
 # -> None:
 #f level is None:
 #f parent is None:
 #evel = 0
 #lse:
 #evel = parent.level + 1

 #elf.level: int = level
 #elf.parent = parent
 #elf.refs: t.Dict[str, str] = {}
 #elf.loads: t.Dict[str, t.Any] = {}
 #elf.stores: t.Set[str] = set()

 #ef analyze_node(self, node: nodes.Node, **kwargs: t.Any) -> None:
 #isitor = RootVisitor(self)
 #isitor.visit(node, **kwargs)

 #ef _define_ref(
 #elf, name: str, load: t.Optional[t.Tuple[str, t.Optional[str]]] = None
 # -> str:
 #dent = f"l_{self.level}_{name}"
 #elf.refs[name] = ident
 #f load is not None:
 #elf.loads[ident] = load
 #eturn ident

 #ef find_load(self, target: str) -> t.Optional[t.Any]:
 #f target in self.loads:
 #eturn self.loads[target]

 #f self.parent is not None:
 #eturn self.parent.find_load(target)

 #eturn None

 #ef find_ref(self, name: str) -> t.Optional[str]:
 #f name in self.refs:
 #eturn self.refs[name]

 #f self.parent is not None:
 #eturn self.parent.find_ref(name)

 #eturn None

 #ef ref(self, name: str) -> str:
 #v = self.find_ref(name)
 #f rv is None:
 #aise AssertionError(
 #Tried to resolve a name to a reference that was"
 #" unknown to the frame ({name!r})"
 #
 #eturn rv

 #ef copy(self) -> "te.Self":
 #v = object.__new__(self.__class__)
 #v.__dict__.update(self.__dict__)
 #v.refs = self.refs.copy()
 #v.loads = self.loads.copy()
 #v.stores = self.stores.copy()
 #eturn rv

 #ef store(self, name: str) -> None:
 #elf.stores.add(name)

        # If we have not see the name referenced yet, we need to figure
        # out what to set it to.
 #f name not in self.refs:
            # If there is a parent scope we check if the name has a
            # reference there.  If it does it means we might have to alias
            # to a variable there.
 #f self.parent is not None:
 #uter_ref = self.parent.find_ref(name)
 #f outer_ref is not None:
 #elf._define_ref(name, load=(VAR_LOAD_ALIAS, outer_ref))
 #eturn

            # Otherwise we can just set it to undefined.
 #elf._define_ref(name, load=(VAR_LOAD_UNDEFINED, None))

 #ef declare_parameter(self, name: str) -> str:
 #elf.stores.add(name)
 #eturn self._define_ref(name, load=(VAR_LOAD_PARAMETER, None))

 #ef load(self, name: str) -> None:
 #f self.find_ref(name) is None:
 #elf._define_ref(name, load=(VAR_LOAD_RESOLVE, name))

 #ef branch_update(self, branch_symbols: t.Sequence["Symbols"]) -> None:
 #tores: t.Set[str] = set()

 #or branch in branch_symbols:
 #tores.update(branch.stores)

 #tores.difference_update(self.stores)

 #or sym in branch_symbols:
 #elf.refs.update(sym.refs)
 #elf.loads.update(sym.loads)
 #elf.stores.update(sym.stores)

 #or name in stores:
 #arget = self.find_ref(name)
 #ssert target is not None, "should not happen"

 #f self.parent is not None:
 #uter_target = self.parent.find_ref(name)
 #f outer_target is not None:
 #elf.loads[target] = (VAR_LOAD_ALIAS, outer_target)
 #ontinue
 #elf.loads[target] = (VAR_LOAD_RESOLVE, name)

 #ef dump_stores(self) -> t.Dict[str, str]:
 #v: t.Dict[str, str] = {}
 #ode: t.Optional[Symbols] = self

 #hile node is not None:
 #or name in sorted(node.stores):
 #f name not in rv:
 #v[name] = self.find_ref(name)  # type: ignore

 #ode = node.parent

 #eturn rv

 #ef dump_param_targets(self) -> t.Set[str]:
 #v = set()
 #ode: t.Optional[Symbols] = self

 #hile node is not None:
 #or target, (instr, _) in self.loads.items():
 #f instr == VAR_LOAD_PARAMETER:
 #v.add(target)

 #ode = node.parent

 #eturn rv


class RootVisitor(NodeVisitor):
 #ef __init__(self, symbols: "Symbols") -> None:
 #elf.sym_visitor = FrameSymbolVisitor(symbols)

 #ef _simple_visit(self, node: nodes.Node, **kwargs: t.Any) -> None:
 #or child in node.iter_child_nodes():
 #elf.sym_visitor.visit(child)

 #isit_Template = _simple_visit
 #isit_Block = _simple_visit
 #isit_Macro = _simple_visit
 #isit_FilterBlock = _simple_visit
 #isit_Scope = _simple_visit
 #isit_If = _simple_visit
 #isit_ScopedEvalContextModifier = _simple_visit

 #ef visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any) -> None:
 #or child in node.body:
 #elf.sym_visitor.visit(child)

 #ef visit_CallBlock(self, node: nodes.CallBlock, **kwargs: t.Any) -> None:
 #or child in node.iter_child_nodes(exclude=("call",)):
 #elf.sym_visitor.visit(child)

 #ef visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any) -> None:
 #or child in node.body:
 #elf.sym_visitor.visit(child)

 #ef visit_For(
 #elf, node: nodes.For, for_branch: str = "body", **kwargs: t.Any
 # -> None:
 #f for_branch == "body":
 #elf.sym_visitor.visit(node.target, store_as_param=True)
 #ranch = node.body
 #lif for_branch == "else":
 #ranch = node.else_
 #lif for_branch == "test":
 #elf.sym_visitor.visit(node.target, store_as_param=True)
 #f node.test is not None:
 #elf.sym_visitor.visit(node.test)
 #eturn
 #lse:
 #aise RuntimeError("Unknown for branch")

 #f branch:
 #or item in branch:
 #elf.sym_visitor.visit(item)

 #ef visit_With(self, node: nodes.With, **kwargs: t.Any) -> None:
 #or target in node.targets:
 #elf.sym_visitor.visit(target)
 #or child in node.body:
 #elf.sym_visitor.visit(child)

 #ef generic_visit(self, node: nodes.Node, *args: t.Any, **kwargs: t.Any) -> None:
 #aise NotImplementedError(f"Cannot find symbols for {type(node).__name__!r}")


class FrameSymbolVisitor(NodeVisitor):
 #""A visitor for `Frame.inspect`."""

 #ef __init__(self, symbols: "Symbols") -> None:
 #elf.symbols = symbols

 #ef visit_Name(
 #elf, node: nodes.Name, store_as_param: bool = False, **kwargs: t.Any
 # -> None:
 #""All assignments to names go through this function."""
 #f store_as_param or node.ctx == "param":
 #elf.symbols.declare_parameter(node.name)
 #lif node.ctx == "store":
 #elf.symbols.store(node.name)
 #lif node.ctx == "load":
 #elf.symbols.load(node.name)

 #ef visit_NSRef(self, node: nodes.NSRef, **kwargs: t.Any) -> None:
 #elf.symbols.load(node.name)

 #ef visit_If(self, node: nodes.If, **kwargs: t.Any) -> None:
 #elf.visit(node.test, **kwargs)
 #riginal_symbols = self.symbols

 #ef inner_visit(nodes: t.Iterable[nodes.Node]) -> "Symbols":
 #elf.symbols = rv = original_symbols.copy()

 #or subnode in nodes:
 #elf.visit(subnode, **kwargs)

 #elf.symbols = original_symbols
 #eturn rv

 #ody_symbols = inner_visit(node.body)
 #lif_symbols = inner_visit(node.elif_)
 #lse_symbols = inner_visit(node.else_ or ())
 #elf.symbols.branch_update([body_symbols, elif_symbols, else_symbols])

 #ef visit_Macro(self, node: nodes.Macro, **kwargs: t.Any) -> None:
 #elf.symbols.store(node.name)

 #ef visit_Import(self, node: nodes.Import, **kwargs: t.Any) -> None:
 #elf.generic_visit(node, **kwargs)
 #elf.symbols.store(node.target)

 #ef visit_FromImport(self, node: nodes.FromImport, **kwargs: t.Any) -> None:
 #elf.generic_visit(node, **kwargs)

 #or name in node.names:
 #f isinstance(name, tuple):
 #elf.symbols.store(name[1])
 #lse:
 #elf.symbols.store(name)

 #ef visit_Assign(self, node: nodes.Assign, **kwargs: t.Any) -> None:
 #""Visit assignments in the correct order."""
 #elf.visit(node.node, **kwargs)
 #elf.visit(node.target, **kwargs)

 #ef visit_For(self, node: nodes.For, **kwargs: t.Any) -> None:
 #""Visiting stops at for blocks.  However the block sequence
 #s visited as part of the outer scope.
 #""
 #elf.visit(node.iter, **kwargs)

 #ef visit_CallBlock(self, node: nodes.CallBlock, **kwargs: t.Any) -> None:
 #elf.visit(node.call, **kwargs)

 #ef visit_FilterBlock(self, node: nodes.FilterBlock, **kwargs: t.Any) -> None:
 #elf.visit(node.filter, **kwargs)

 #ef visit_With(self, node: nodes.With, **kwargs: t.Any) -> None:
 #or target in node.values:
 #elf.visit(target)

 #ef visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any) -> None:
 #""Stop visiting at block assigns."""
 #elf.visit(node.target, **kwargs)

 #ef visit_Scope(self, node: nodes.Scope, **kwargs: t.Any) -> None:
 #""Stop visiting at scopes."""

 #ef visit_Block(self, node: nodes.Block, **kwargs: t.Any) -> None:
 #""Stop visiting at blocks."""

 #ef visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any) -> None:
 #""Do not visit into overlay scopes."""
