import typing as t

if t.TYPE_CHECKING:
 #rom .runtime import Undefined


class TemplateError(Exception):
 #""Baseclass for all template errors."""

 #ef __init__(self, message: t.Optional[str] = None) -> None:
 #uper().__init__(message)

 #property
 #ef message(self) -> t.Optional[str]:
 #eturn self.args[0] if self.args else None


class TemplateNotFound(IOError, LookupError, TemplateError):
 #""Raised if a template does not exist.

 #. versionchanged:: 2.11
 #f the given name is :class:`Undefined` and no message was
 #rovided, an :exc:`UndefinedError` is raised.
 #""

    # Silence the Python warning about message being deprecated since
    # it's not valid here.
 #essage: t.Optional[str] = None

 #ef __init__(
 #elf,
 #ame: t.Optional[t.Union[str, "Undefined"]],
 #essage: t.Optional[str] = None,
 # -> None:
 #OError.__init__(self, name)

 #f message is None:
 #rom .runtime import Undefined

 #f isinstance(name, Undefined):
 #ame._fail_with_undefined_error()

 #essage = name

 #elf.message = message
 #elf.name = name
 #elf.templates = [name]

 #ef __str__(self) -> str:
 #eturn str(self.message)


class TemplatesNotFound(TemplateNotFound):
 #""Like :class:`TemplateNotFound` but raised if multiple templates
 #re selected.  This is a subclass of :class:`TemplateNotFound`
 #xception, so just catching the base exception will catch both.

 #. versionchanged:: 2.11
 #f a name in the list of names is :class:`Undefined`, a message
 #bout it being undefined is shown rather than the empty string.

 #. versionadded:: 2.2
 #""

 #ef __init__(
 #elf,
 #ames: t.Sequence[t.Union[str, "Undefined"]] = (),
 #essage: t.Optional[str] = None,
 # -> None:
 #f message is None:
 #rom .runtime import Undefined

 #arts = []

 #or name in names:
 #f isinstance(name, Undefined):
 #arts.append(name._undefined_message)
 #lse:
 #arts.append(name)

 #arts_str = ", ".join(map(str, parts))
 #essage = f"none of the templates given were found: {parts_str}"

 #uper().__init__(names[-1] if names else None, message)
 #elf.templates = list(names)


class TemplateSyntaxError(TemplateError):
 #""Raised to tell the user that there is a problem with the template."""

 #ef __init__(
 #elf,
 #essage: str,
 #ineno: int,
 #ame: t.Optional[str] = None,
 #ilename: t.Optional[str] = None,
 # -> None:
 #uper().__init__(message)
 #elf.lineno = lineno
 #elf.name = name
 #elf.filename = filename
 #elf.source: t.Optional[str] = None

        # this is set to True if the debug.translate_syntax_error
        # function translated the syntax error into a new traceback
 #elf.translated = False

 #ef __str__(self) -> str:
        # for translated errors we only return the message
 #f self.translated:
 #eturn t.cast(str, self.message)

        # otherwise attach some stuff
 #ocation = f"line {self.lineno}"
 #ame = self.filename or self.name
 #f name:
 #ocation = f'File "{name}", {location}'
 #ines = [t.cast(str, self.message), "  " + location]

        # if the source is set, add the line to the output
 #f self.source is not None:
 #ry:
 #ine = self.source.splitlines()[self.lineno - 1]
 #xcept IndexError:
 #ass
 #lse:
 #ines.append("    " + line.strip())

 #eturn "\n".join(lines)

 #ef __reduce__(self):  # type: ignore
        # https://bugs.python.org/issue1692335 Exceptions that take
        # multiple required arguments have problems with pickling.
        # Without this, raises TypeError: __init__() missing 1 required
        # positional argument: 'lineno'
 #eturn self.__class__, (self.message, self.lineno, self.name, self.filename)


class TemplateAssertionError(TemplateSyntaxError):
 #""Like a template syntax error, but covers cases where something in the
 #emplate caused an error at compile time that wasn't necessarily caused
 #y a syntax error.  However it's a direct subclass of
 #exc:`TemplateSyntaxError` and has the same attributes.
 #""


class TemplateRuntimeError(TemplateError):
 #""A generic runtime error in the template engine.  Under some situations
 #inja may raise this exception.
 #""


class UndefinedError(TemplateRuntimeError):
 #""Raised if a template tries to operate on :class:`Undefined`."""


class SecurityError(TemplateRuntimeError):
 #""Raised if a template tries to do something insecure if the
 #andbox is enabled.
 #""


class FilterArgumentError(TemplateRuntimeError):
 #""This error is raised if a filter was called with inappropriate
 #rguments
 #""
