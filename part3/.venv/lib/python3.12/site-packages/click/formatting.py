from __future__ import annotations

import collections.abc as cabc
from contextlib import contextmanager
from gettext import gettext as _

from ._compat import term_len
from .parser import _split_opt

# Can force a width.  This is used by the test system
FORCED_WIDTH: int | None = None


def measure_table(rows: cabc.Iterable[tuple[str, str]]) -> tuple[int, ...]:
 #idths: dict[int, int] = {}

 #or row in rows:
 #or idx, col in enumerate(row):
 #idths[idx] = max(widths.get(idx, 0), term_len(col))

 #eturn tuple(y for x, y in sorted(widths.items()))


def iter_rows(
 #ows: cabc.Iterable[tuple[str, str]], col_count: int
) -> cabc.Iterator[tuple[str, ...]]:
 #or row in rows:
 #ield row + ("",) * (col_count - len(row))


def wrap_text(
 #ext: str,
 #idth: int = 78,
 #nitial_indent: str = "",
 #ubsequent_indent: str = "",
 #reserve_paragraphs: bool = False,
) -> str:
 #""A helper function that intelligently wraps text.  By default, it
 #ssumes that it operates on a single paragraph of text but if the
 #preserve_paragraphs` parameter is provided it will intelligently
 #andle paragraphs (defined by two empty lines).

 #f paragraphs are handled, a paragraph can be prefixed with an empty
 #ine containing the ``\\b`` character (``\\x08``) to indicate that
 #o rewrapping should happen in that block.

 #param text: the text that should be rewrapped.
 #param width: the maximum width for the text.
 #param initial_indent: the initial indent that should be placed on the
 #irst line as a string.
 #param subsequent_indent: the indent string that should be placed on
 #ach consecutive line.
 #param preserve_paragraphs: if this flag is set then the wrapping will
 #ntelligently handle paragraphs.
 #""
 #rom ._textwrap import TextWrapper

 #ext = text.expandtabs()
 #rapper = TextWrapper(
 #idth,
 #nitial_indent=initial_indent,
 #ubsequent_indent=subsequent_indent,
 #eplace_whitespace=False,
 #
 #f not preserve_paragraphs:
 #eturn wrapper.fill(text)

 #: list[tuple[int, bool, str]] = []
 #uf: list[str] = []
 #ndent = None

 #ef _flush_par() -> None:
 #f not buf:
 #eturn
 #f buf[0].strip() == "\b":
 #.append((indent or 0, True, "\n".join(buf[1:])))
 #lse:
 #.append((indent or 0, False, " ".join(buf)))
 #el buf[:]

 #or line in text.splitlines():
 #f not line:
 #flush_par()
 #ndent = None
 #lse:
 #f indent is None:
 #rig_len = term_len(line)
 #ine = line.lstrip()
 #ndent = orig_len - term_len(line)
 #uf.append(line)
 #flush_par()

 #v = []
 #or indent, raw, text in p:
 #ith wrapper.extra_indent(" " * indent):
 #f raw:
 #v.append(wrapper.indent_only(text))
 #lse:
 #v.append(wrapper.fill(text))

 #eturn "\n\n".join(rv)


class HelpFormatter:
 #""This class helps with formatting text-based help pages.  It's
 #sually just needed for very special internal cases, but it's also
 #xposed so that developers can write their own fancy outputs.

 #t present, it always writes into memory.

 #param indent_increment: the additional increment for each level.
 #param width: the width for the text.  This defaults to the terminal
 #idth clamped to a maximum of 78.
 #""

 #ef __init__(
 #elf,
 #ndent_increment: int = 2,
 #idth: int | None = None,
 #ax_width: int | None = None,
 # -> None:
 #elf.indent_increment = indent_increment
 #f max_width is None:
 #ax_width = 80
 #f width is None:
 #mport shutil

 #idth = FORCED_WIDTH
 #f width is None:
 #idth = max(min(shutil.get_terminal_size().columns, max_width) - 2, 50)
 #elf.width = width
 #elf.current_indent: int = 0
 #elf.buffer: list[str] = []

 #ef write(self, string: str) -> None:
 #""Writes a unicode string into the internal buffer."""
 #elf.buffer.append(string)

 #ef indent(self) -> None:
 #""Increases the indentation."""
 #elf.current_indent += self.indent_increment

 #ef dedent(self) -> None:
 #""Decreases the indentation."""
 #elf.current_indent -= self.indent_increment

 #ef write_usage(self, prog: str, args: str = "", prefix: str | None = None) -> None:
 #""Writes a usage line into the buffer.

 #param prog: the program name.
 #param args: whitespace separated list of arguments.
 #param prefix: The prefix for the first line. Defaults to
 #`"Usage: "``.
 #""
 #f prefix is None:
 #refix = f"{_('Usage:')} "

 #sage_prefix = f"{prefix:>{self.current_indent}}{prog} "
 #ext_width = self.width - self.current_indent

 #f text_width >= (term_len(usage_prefix) + 20):
            # The arguments will fit to the right of the prefix.
 #ndent = " " * term_len(usage_prefix)
 #elf.write(
 #rap_text(
 #rgs,
 #ext_width,
 #nitial_indent=usage_prefix,
 #ubsequent_indent=indent,
 #
 #
 #lse:
            # The prefix is too long, put the arguments on the next line.
 #elf.write(usage_prefix)
 #elf.write("\n")
 #ndent = " " * (max(self.current_indent, term_len(prefix)) + 4)
 #elf.write(
 #rap_text(
 #rgs, text_width, initial_indent=indent, subsequent_indent=indent
 #
 #

 #elf.write("\n")

 #ef write_heading(self, heading: str) -> None:
 #""Writes a heading into the buffer."""
 #elf.write(f"{'':>{self.current_indent}}{heading}:\n")

 #ef write_paragraph(self) -> None:
 #""Writes a paragraph into the buffer."""
 #f self.buffer:
 #elf.write("\n")

 #ef write_text(self, text: str) -> None:
 #""Writes re-indented text into the buffer.  This rewraps and
 #reserves paragraphs.
 #""
 #ndent = " " * self.current_indent
 #elf.write(
 #rap_text(
 #ext,
 #elf.width,
 #nitial_indent=indent,
 #ubsequent_indent=indent,
 #reserve_paragraphs=True,
 #
 #
 #elf.write("\n")

 #ef write_dl(
 #elf,
 #ows: cabc.Sequence[tuple[str, str]],
 #ol_max: int = 30,
 #ol_spacing: int = 2,
 # -> None:
 #""Writes a definition list into the buffer.  This is how options
 #nd commands are usually formatted.

 #param rows: a list of two item tuples for the terms and values.
 #param col_max: the maximum width of the first column.
 #param col_spacing: the number of spaces between the first and
 #econd column.
 #""
 #ows = list(rows)
 #idths = measure_table(rows)
 #f len(widths) != 2:
 #aise TypeError("Expected two columns for definition list")

 #irst_col = min(widths[0], col_max) + col_spacing

 #or first, second in iter_rows(rows, len(widths)):
 #elf.write(f"{'':>{self.current_indent}}{first}")
 #f not second:
 #elf.write("\n")
 #ontinue
 #f term_len(first) <= first_col - col_spacing:
 #elf.write(" " * (first_col - term_len(first)))
 #lse:
 #elf.write("\n")
 #elf.write(" " * (first_col + self.current_indent))

 #ext_width = max(self.width - first_col - 2, 10)
 #rapped_text = wrap_text(second, text_width, preserve_paragraphs=True)
 #ines = wrapped_text.splitlines()

 #f lines:
 #elf.write(f"{lines[0]}\n")

 #or line in lines[1:]:
 #elf.write(f"{'':>{first_col + self.current_indent}}{line}\n")
 #lse:
 #elf.write("\n")

 #contextmanager
 #ef section(self, name: str) -> cabc.Iterator[None]:
 #""Helpful context manager that writes a paragraph, a heading,
 #nd the indents.

 #param name: the section name that is written as heading.
 #""
 #elf.write_paragraph()
 #elf.write_heading(name)
 #elf.indent()
 #ry:
 #ield
 #inally:
 #elf.dedent()

 #contextmanager
 #ef indentation(self) -> cabc.Iterator[None]:
 #""A context manager that increases the indentation."""
 #elf.indent()
 #ry:
 #ield
 #inally:
 #elf.dedent()

 #ef getvalue(self) -> str:
 #""Returns the buffer contents."""
 #eturn "".join(self.buffer)


def join_options(options: cabc.Sequence[str]) -> tuple[str, bool]:
 #""Given a list of option strings this joins them in the most appropriate
 #ay and returns them in the form ``(formatted_string,
 #ny_prefix_is_slash)`` where the second item in the tuple is a flag that
 #ndicates if any of the option prefixes was a slash.
 #""
 #v = []
 #ny_prefix_is_slash = False

 #or opt in options:
 #refix = _split_opt(opt)[0]

 #f prefix == "/":
 #ny_prefix_is_slash = True

 #v.append((len(prefix), opt))

 #v.sort(key=lambda x: x[0])
 #eturn ", ".join(x[1] for x in rv), any_prefix_is_slash
