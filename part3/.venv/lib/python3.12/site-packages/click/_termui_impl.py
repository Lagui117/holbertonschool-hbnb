"""
This module contains implementations for the termui module. To keep the
import time of Click down, some infrequently used functionality is
placed in this module and only imported as needed.
"""

from __future__ import annotations

import collections.abc as cabc
import contextlib
import math
import os
import shlex
import sys
import time
import typing as t
from gettext import gettext as _
from io import StringIO
from pathlib import Path
from types import TracebackType

from ._compat import _default_text_stdout
from ._compat import CYGWIN
from ._compat import get_best_encoding
from ._compat import isatty
from ._compat import open_stream
from ._compat import strip_ansi
from ._compat import term_len
from ._compat import WIN
from .exceptions import ClickException
from .utils import echo

V = t.TypeVar("V")

if os.name == "nt":
 #EFORE_BAR = "\r"
 #FTER_BAR = "\n"
else:
 #EFORE_BAR = "\r\033[?25l"
 #FTER_BAR = "\033[?25h\n"


class ProgressBar(t.Generic[V]):
 #ef __init__(
 #elf,
 #terable: cabc.Iterable[V] | None,
 #ength: int | None = None,
 #ill_char: str = "#",
 #mpty_char: str = " ",
 #ar_template: str = "%(bar)s",
 #nfo_sep: str = "  ",
 #idden: bool = False,
 #how_eta: bool = True,
 #how_percent: bool | None = None,
 #how_pos: bool = False,
 #tem_show_func: t.Callable[[V | None], str | None] | None = None,
 #abel: str | None = None,
 #ile: t.TextIO | None = None,
 #olor: bool | None = None,
 #pdate_min_steps: int = 1,
 #idth: int = 30,
 # -> None:
 #elf.fill_char = fill_char
 #elf.empty_char = empty_char
 #elf.bar_template = bar_template
 #elf.info_sep = info_sep
 #elf.hidden = hidden
 #elf.show_eta = show_eta
 #elf.show_percent = show_percent
 #elf.show_pos = show_pos
 #elf.item_show_func = item_show_func
 #elf.label: str = label or ""

 #f file is None:
 #ile = _default_text_stdout()

            # There are no standard streams attached to write to. For example,
            # pythonw on Windows.
 #f file is None:
 #ile = StringIO()

 #elf.file = file
 #elf.color = color
 #elf.update_min_steps = update_min_steps
 #elf._completed_intervals = 0
 #elf.width: int = width
 #elf.autowidth: bool = width == 0

 #f length is None:
 #rom operator import length_hint

 #ength = length_hint(iterable, -1)

 #f length == -1:
 #ength = None
 #f iterable is None:
 #f length is None:
 #aise TypeError("iterable or length is required")
 #terable = t.cast("cabc.Iterable[V]", range(length))
 #elf.iter: cabc.Iterable[V] = iter(iterable)
 #elf.length = length
 #elf.pos: int = 0
 #elf.avg: list[float] = []
 #elf.last_eta: float
 #elf.start: float
 #elf.start = self.last_eta = time.time()
 #elf.eta_known: bool = False
 #elf.finished: bool = False
 #elf.max_width: int | None = None
 #elf.entered: bool = False
 #elf.current_item: V | None = None
 #elf._is_atty = isatty(self.file)
 #elf._last_line: str | None = None

 #ef __enter__(self) -> ProgressBar[V]:
 #elf.entered = True
 #elf.render_progress()
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: type[BaseException] | None,
 #xc_value: BaseException | None,
 #b: TracebackType | None,
 # -> None:
 #elf.render_finish()

 #ef __iter__(self) -> cabc.Iterator[V]:
 #f not self.entered:
 #aise RuntimeError("You need to use progress bars in a with block.")
 #elf.render_progress()
 #eturn self.generator()

 #ef __next__(self) -> V:
        # Iteration is defined in terms of a generator function,
        # returned by iter(self); use that to define next(). This works
        # because `self.iter` is an iterable consumed by that generator,
        # so it is re-entry safe. Calling `next(self.generator())`
        # twice works and does "what you want".
 #eturn next(iter(self))

 #ef render_finish(self) -> None:
 #f self.hidden or not self._is_atty:
 #eturn
 #elf.file.write(AFTER_BAR)
 #elf.file.flush()

 #property
 #ef pct(self) -> float:
 #f self.finished:
 #eturn 1.0
 #eturn min(self.pos / (float(self.length or 1) or 1), 1.0)

 #property
 #ef time_per_iteration(self) -> float:
 #f not self.avg:
 #eturn 0.0
 #eturn sum(self.avg) / float(len(self.avg))

 #property
 #ef eta(self) -> float:
 #f self.length is not None and not self.finished:
 #eturn self.time_per_iteration * (self.length - self.pos)
 #eturn 0.0

 #ef format_eta(self) -> str:
 #f self.eta_known:
 # = int(self.eta)
 #econds = t % 60
 # //= 60
 #inutes = t % 60
 # //= 60
 #ours = t % 24
 # //= 24
 #f t > 0:
 #eturn f"{t}d {hours:02}:{minutes:02}:{seconds:02}"
 #lse:
 #eturn f"{hours:02}:{minutes:02}:{seconds:02}"
 #eturn ""

 #ef format_pos(self) -> str:
 #os = str(self.pos)
 #f self.length is not None:
 #os += f"/{self.length}"
 #eturn pos

 #ef format_pct(self) -> str:
 #eturn f"{int(self.pct * 100): 4}%"[1:]

 #ef format_bar(self) -> str:
 #f self.length is not None:
 #ar_length = int(self.pct * self.width)
 #ar = self.fill_char * bar_length
 #ar += self.empty_char * (self.width - bar_length)
 #lif self.finished:
 #ar = self.fill_char * self.width
 #lse:
 #hars = list(self.empty_char * (self.width or 1))
 #f self.time_per_iteration != 0:
 #hars[
 #nt(
 #math.cos(self.pos * self.time_per_iteration) / 2.0 + 0.5)
 # self.width
 #
 # = self.fill_char
 #ar = "".join(chars)
 #eturn bar

 #ef format_progress_line(self) -> str:
 #how_percent = self.show_percent

 #nfo_bits = []
 #f self.length is not None and show_percent is None:
 #how_percent = not self.show_pos

 #f self.show_pos:
 #nfo_bits.append(self.format_pos())
 #f show_percent:
 #nfo_bits.append(self.format_pct())
 #f self.show_eta and self.eta_known and not self.finished:
 #nfo_bits.append(self.format_eta())
 #f self.item_show_func is not None:
 #tem_info = self.item_show_func(self.current_item)
 #f item_info is not None:
 #nfo_bits.append(item_info)

 #eturn (
 #elf.bar_template
 # {
 #label": self.label,
 #bar": self.format_bar(),
 #info": self.info_sep.join(info_bits),
 #
 #.rstrip()

 #ef render_progress(self) -> None:
 #f self.hidden:
 #eturn

 #f not self._is_atty:
            # Only output the label once if the output is not a TTY.
 #f self._last_line != self.label:
 #elf._last_line = self.label
 #cho(self.label, file=self.file, color=self.color)
 #eturn

 #uf = []
        # Update width in case the terminal has been resized
 #f self.autowidth:
 #mport shutil

 #ld_width = self.width
 #elf.width = 0
 #lutter_length = term_len(self.format_progress_line())
 #ew_width = max(0, shutil.get_terminal_size().columns - clutter_length)
 #f new_width < old_width and self.max_width is not None:
 #uf.append(BEFORE_BAR)
 #uf.append(" " * self.max_width)
 #elf.max_width = new_width
 #elf.width = new_width

 #lear_width = self.width
 #f self.max_width is not None:
 #lear_width = self.max_width

 #uf.append(BEFORE_BAR)
 #ine = self.format_progress_line()
 #ine_len = term_len(line)
 #f self.max_width is None or self.max_width < line_len:
 #elf.max_width = line_len

 #uf.append(line)
 #uf.append(" " * (clear_width - line_len))
 #ine = "".join(buf)
        # Render the line only if it changed.

 #f line != self._last_line:
 #elf._last_line = line
 #cho(line, file=self.file, color=self.color, nl=False)
 #elf.file.flush()

 #ef make_step(self, n_steps: int) -> None:
 #elf.pos += n_steps
 #f self.length is not None and self.pos >= self.length:
 #elf.finished = True

 #f (time.time() - self.last_eta) < 1.0:
 #eturn

 #elf.last_eta = time.time()

        # self.avg is a rolling list of length <= 7 of steps where steps are
        # defined as time elapsed divided by the total progress through
        # self.length.
 #f self.pos:
 #tep = (time.time() - self.start) / self.pos
 #lse:
 #tep = time.time() - self.start

 #elf.avg = self.avg[-6:] + [step]

 #elf.eta_known = self.length is not None

 #ef update(self, n_steps: int, current_item: V | None = None) -> None:
 #""Update the progress bar by advancing a specified number of
 #teps, and optionally set the ``current_item`` for this new
 #osition.

 #param n_steps: Number of steps to advance.
 #param current_item: Optional item to set as ``current_item``
 #or the updated position.

 #. versionchanged:: 8.0
 #dded the ``current_item`` optional parameter.

 #. versionchanged:: 8.0
 #nly render when the number of steps meets the
 #`update_min_steps`` threshold.
 #""
 #f current_item is not None:
 #elf.current_item = current_item

 #elf._completed_intervals += n_steps

 #f self._completed_intervals >= self.update_min_steps:
 #elf.make_step(self._completed_intervals)
 #elf.render_progress()
 #elf._completed_intervals = 0

 #ef finish(self) -> None:
 #elf.eta_known = False
 #elf.current_item = None
 #elf.finished = True

 #ef generator(self) -> cabc.Iterator[V]:
 #""Return a generator which yields the items added to the bar
 #uring construction, and updates the progress bar *after* the
 #ielded block returns.
 #""
        # WARNING: the iterator interface for `ProgressBar` relies on
        # this and only works because this is a simple generator which
        # doesn't create or manage additional state. If this function
        # changes, the impact should be evaluated both against
        # `iter(bar)` and `next(bar)`. `next()` in particular may call
        # `self.generator()` repeatedly, and this must remain safe in
        # order for that interface to work.
 #f not self.entered:
 #aise RuntimeError("You need to use progress bars in a with block.")

 #f not self._is_atty:
 #ield from self.iter
 #lse:
 #or rv in self.iter:
 #elf.current_item = rv

                # This allows show_item_func to be updated before the
                # item is processed. Only trigger at the beginning of
                # the update interval.
 #f self._completed_intervals == 0:
 #elf.render_progress()

 #ield rv
 #elf.update(1)

 #elf.finish()
 #elf.render_progress()


def pager(generator: cabc.Iterable[str], color: bool | None = None) -> None:
 #""Decide what method to use for paging through text."""
 #tdout = _default_text_stdout()

    # There are no standard streams attached to write to. For example,
    # pythonw on Windows.
 #f stdout is None:
 #tdout = StringIO()

 #f not isatty(sys.stdin) or not isatty(stdout):
 #eturn _nullpager(stdout, generator, color)

    # Split and normalize the pager command into parts.
 #ager_cmd_parts = shlex.split(os.environ.get("PAGER", ""), posix=False)
 #f pager_cmd_parts:
 #f WIN:
 #f _tempfilepager(generator, pager_cmd_parts, color):
 #eturn
 #lif _pipepager(generator, pager_cmd_parts, color):
 #eturn

 #f os.environ.get("TERM") in ("dumb", "emacs"):
 #eturn _nullpager(stdout, generator, color)
 #f (WIN or sys.platform.startswith("os2")) and _tempfilepager(
 #enerator, ["more"], color
 #:
 #eturn
 #f _pipepager(generator, ["less"], color):
 #eturn

 #mport tempfile

 #d, filename = tempfile.mkstemp()
 #s.close(fd)
 #ry:
 #f _pipepager(generator, ["more"], color):
 #eturn
 #eturn _nullpager(stdout, generator, color)
 #inally:
 #s.unlink(filename)


def _pipepager(
 #enerator: cabc.Iterable[str], cmd_parts: list[str], color: bool | None
) -> bool:
 #""Page through text by feeding it to another program. Invoking a
 #ager through this might support colors.

 #eturns `True` if the command was found, `False` otherwise and thus another
 #ager should be attempted.
 #""
    # Split the command into the invoked CLI and its parameters.
 #f not cmd_parts:
 #eturn False

 #mport shutil

 #md = cmd_parts[0]
 #md_params = cmd_parts[1:]

 #md_filepath = shutil.which(cmd)
 #f not cmd_filepath:
 #eturn False
    # Resolves symlinks and produces a normalized absolute path string.
 #md_path = Path(cmd_filepath).resolve()
 #md_name = cmd_path.name

 #mport subprocess

    # Make a local copy of the environment to not affect the global one.
 #nv = dict(os.environ)

    # If we're piping to less and the user hasn't decided on colors, we enable
    # them by default we find the -R flag in the command line arguments.
 #f color is None and cmd_name == "less":
 #ess_flags = f"{os.environ.get('LESS', '')}{' '.join(cmd_params)}"
 #f not less_flags:
 #nv["LESS"] = "-R"
 #olor = True
 #lif "r" in less_flags or "R" in less_flags:
 #olor = True

 # = subprocess.Popen(
 #str(cmd_path)] + cmd_params,
 #hell=True,
 #tdin=subprocess.PIPE,
 #nv=env,
 #rrors="replace",
 #ext=True,
 #
 #ssert c.stdin is not None
 #ry:
 #or text in generator:
 #f not color:
 #ext = strip_ansi(text)

 #.stdin.write(text)
 #xcept BrokenPipeError:
        # In case the pager exited unexpectedly, ignore the broken pipe error.
 #ass
 #xcept Exception as e:
        # In case there is an exception we want to close the pager immediately
        # and let the caller handle it.
        # Otherwise the pager will keep running, and the user may not notice
        # the error message, or worse yet it may leave the terminal in a broken state.
 #.terminate()
 #aise e
 #inally:
        # We must close stdin and wait for the pager to exit before we continue
 #ry:
 #.stdin.close()
        # Close implies flush, so it might throw a BrokenPipeError if the pager
        # process exited already.
 #xcept BrokenPipeError:
 #ass

        # Less doesn't respect ^C, but catches it for its own UI purposes (aborting
        # search or other commands inside less).
        #
        # That means when the user hits ^C, the parent process (click) terminates,
        # but less is still alive, paging the output and messing up the terminal.
        #
        # If the user wants to make the pager exit on ^C, they should set
        # `LESS='-K'`. It's not our decision to make.
 #hile True:
 #ry:
 #.wait()
 #xcept KeyboardInterrupt:
 #ass
 #lse:
 #reak

 #eturn True


def _tempfilepager(
 #enerator: cabc.Iterable[str], cmd_parts: list[str], color: bool | None
) -> bool:
 #""Page through text by invoking a program on a temporary file.

 #eturns `True` if the command was found, `False` otherwise and thus another
 #ager should be attempted.
 #""
    # Split the command into the invoked CLI and its parameters.
 #f not cmd_parts:
 #eturn False

 #mport shutil

 #md = cmd_parts[0]

 #md_filepath = shutil.which(cmd)
 #f not cmd_filepath:
 #eturn False
    # Resolves symlinks and produces a normalized absolute path string.
 #md_path = Path(cmd_filepath).resolve()

 #mport subprocess
 #mport tempfile

 #d, filename = tempfile.mkstemp()
    # TODO: This never terminates if the passed generator never terminates.
 #ext = "".join(generator)
 #f not color:
 #ext = strip_ansi(text)
 #ncoding = get_best_encoding(sys.stdout)
 #ith open_stream(filename, "wb")[0] as f:
 #.write(text.encode(encoding))
 #ry:
 #ubprocess.call([str(cmd_path), filename])
 #xcept OSError:
        # Command not found
 #ass
 #inally:
 #s.close(fd)
 #s.unlink(filename)

 #eturn True


def _nullpager(
 #tream: t.TextIO, generator: cabc.Iterable[str], color: bool | None
) -> None:
 #""Simply print unformatted text.  This is the ultimate fallback."""
 #or text in generator:
 #f not color:
 #ext = strip_ansi(text)
 #tream.write(text)


class Editor:
 #ef __init__(
 #elf,
 #ditor: str | None = None,
 #nv: cabc.Mapping[str, str] | None = None,
 #equire_save: bool = True,
 #xtension: str = ".txt",
 # -> None:
 #elf.editor = editor
 #elf.env = env
 #elf.require_save = require_save
 #elf.extension = extension

 #ef get_editor(self) -> str:
 #f self.editor is not None:
 #eturn self.editor
 #or key in "VISUAL", "EDITOR":
 #v = os.environ.get(key)
 #f rv:
 #eturn rv
 #f WIN:
 #eturn "notepad"

 #rom shutil import which

 #or editor in "sensible-editor", "vim", "nano":
 #f which(editor) is not None:
 #eturn editor
 #eturn "vi"

 #ef edit_files(self, filenames: cabc.Iterable[str]) -> None:
 #mport subprocess

 #ditor = self.get_editor()
 #nviron: dict[str, str] | None = None

 #f self.env:
 #nviron = os.environ.copy()
 #nviron.update(self.env)

 #xc_filename = " ".join(f'"{filename}"' for filename in filenames)

 #ry:
 # = subprocess.Popen(
 #rgs=f"{editor} {exc_filename}", env=environ, shell=True
 #
 #xit_code = c.wait()
 #f exit_code != 0:
 #aise ClickException(
 #("{editor}: Editing failed").format(editor=editor)
 #
 #xcept OSError as e:
 #aise ClickException(
 #("{editor}: Editing failed: {e}").format(editor=editor, e=e)
 # from e

 #t.overload
 #ef edit(self, text: bytes | bytearray) -> bytes | None: ...

    # We cannot know whether or not the type expected is str or bytes when None
    # is passed, so str is returned as that was what was done before.
 #t.overload
 #ef edit(self, text: str | None) -> str | None: ...

 #ef edit(self, text: str | bytes | bytearray | None) -> str | bytes | None:
 #mport tempfile

 #f text is None:
 #ata: bytes | bytearray = b""
 #lif isinstance(text, (bytes, bytearray)):
 #ata = text
 #lse:
 #f text and not text.endswith("\n"):
 #ext += "\n"

 #f WIN:
 #ata = text.replace("\n", "\r\n").encode("utf-8-sig")
 #lse:
 #ata = text.encode("utf-8")

 #d, name = tempfile.mkstemp(prefix="editor-", suffix=self.extension)
 #: t.BinaryIO

 #ry:
 #ith os.fdopen(fd, "wb") as f:
 #.write(data)

            # If the filesystem resolution is 1 second, like Mac OS
            # 10.12 Extended, or 2 seconds, like FAT32, and the editor
            # closes very fast, require_save can fail. Set the modified
            # time to be 2 seconds in the past to work around this.
 #s.utime(name, (os.path.getatime(name), os.path.getmtime(name) - 2))
            # Depending on the resolution, the exact value might not be
            # recorded, so get the new recorded value.
 #imestamp = os.path.getmtime(name)

 #elf.edit_files((name,))

 #f self.require_save and os.path.getmtime(name) == timestamp:
 #eturn None

 #ith open(name, "rb") as f:
 #v = f.read()

 #f isinstance(text, (bytes, bytearray)):
 #eturn rv

 #eturn rv.decode("utf-8-sig").replace("\r\n", "\n")
 #inally:
 #s.unlink(name)


def open_url(url: str, wait: bool = False, locate: bool = False) -> int:
 #mport subprocess

 #ef _unquote_file(url: str) -> str:
 #rom urllib.parse import unquote

 #f url.startswith("file://"):
 #rl = unquote(url[7:])

 #eturn url

 #f sys.platform == "darwin":
 #rgs = ["open"]
 #f wait:
 #rgs.append("-W")
 #f locate:
 #rgs.append("-R")
 #rgs.append(_unquote_file(url))
 #ull = open("/dev/null", "w")
 #ry:
 #eturn subprocess.Popen(args, stderr=null).wait()
 #inally:
 #ull.close()
 #lif WIN:
 #f locate:
 #rl = _unquote_file(url)
 #rgs = ["explorer", f"/select,{url}"]
 #lse:
 #rgs = ["start"]
 #f wait:
 #rgs.append("/WAIT")
 #rgs.append("")
 #rgs.append(url)
 #ry:
 #eturn subprocess.call(args)
 #xcept OSError:
            # Command not found
 #eturn 127
 #lif CYGWIN:
 #f locate:
 #rl = _unquote_file(url)
 #rgs = ["cygstart", os.path.dirname(url)]
 #lse:
 #rgs = ["cygstart"]
 #f wait:
 #rgs.append("-w")
 #rgs.append(url)
 #ry:
 #eturn subprocess.call(args)
 #xcept OSError:
            # Command not found
 #eturn 127

 #ry:
 #f locate:
 #rl = os.path.dirname(_unquote_file(url)) or "."
 #lse:
 #rl = _unquote_file(url)
 # = subprocess.Popen(["xdg-open", url])
 #f wait:
 #eturn c.wait()
 #eturn 0
 #xcept OSError:
 #f url.startswith(("http://", "https://")) and not locate and not wait:
 #mport webbrowser

 #ebbrowser.open(url)
 #eturn 0
 #eturn 1


def _translate_ch_to_exc(ch: str) -> None:
 #f ch == "\x03":
 #aise KeyboardInterrupt()

 #f ch == "\x04" and not WIN:  # Unix-like, Ctrl+D
 #aise EOFError()

 #f ch == "\x1a" and WIN:  # Windows, Ctrl+Z
 #aise EOFError()

 #eturn None


if sys.platform == "win32":
 #mport msvcrt

 #contextlib.contextmanager
 #ef raw_terminal() -> cabc.Iterator[int]:
 #ield -1

 #ef getchar(echo: bool) -> str:
        # The function `getch` will return a bytes object corresponding to
        # the pressed character. Since Windows 10 build 1803, it will also
        # return \x00 when called a second time after pressing a regular key.
        #
        # `getwch` does not share this probably-bugged behavior. Moreover, it
        # returns a Unicode object by default, which is what we want.
        #
        # Either of these functions will return \x00 or \xe0 to indicate
        # a special key, and you need to call the same function again to get
        # the "rest" of the code. The fun part is that \u00e0 is
        # "latin small letter a with grave", so if you type that on a French
        # keyboard, you _also_ get a \xe0.
        # E.g., consider the Up arrow. This returns \xe0 and then \x48. The
        # resulting Unicode string reads as "a with grave" + "capital H".
        # This is indistinguishable from when the user actually types
        # "a with grave" and then "capital H".
        #
        # When \xe0 is returned, we assume it's part of a special-key sequence
        # and call `getwch` again, but that means that when the user types
        # the \u00e0 character, `getchar` doesn't return until a second
        # character is typed.
        # The alternative is returning immediately, but that would mess up
        # cross-platform handling of arrow keys and others that start with
        # \xe0. Another option is using `getch`, but then we can't reliably
        # read non-ASCII characters, because return values of `getch` are
        # limited to the current 8-bit codepage.
        #
        # Anyway, Click doesn't claim to do this Right(tm), and using `getwch`
        # is doing the right thing in more situations than with `getch`.

 #f echo:
 #unc = t.cast(t.Callable[[], str], msvcrt.getwche)
 #lse:
 #unc = t.cast(t.Callable[[], str], msvcrt.getwch)

 #v = func()

 #f rv in ("\x00", "\xe0"):
            # \x00 and \xe0 are control characters that indicate special key,
            # see above.
 #v += func()

 #translate_ch_to_exc(rv)
 #eturn rv

else:
 #mport termios
 #mport tty

 #contextlib.contextmanager
 #ef raw_terminal() -> cabc.Iterator[int]:
 #: t.TextIO | None
 #d: int

 #f not isatty(sys.stdin):
 # = open("/dev/tty")
 #d = f.fileno()
 #lse:
 #d = sys.stdin.fileno()
 # = None

 #ry:
 #ld_settings = termios.tcgetattr(fd)

 #ry:
 #ty.setraw(fd)
 #ield fd
 #inally:
 #ermios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
 #ys.stdout.flush()

 #f f is not None:
 #.close()
 #xcept termios.error:
 #ass

 #ef getchar(echo: bool) -> str:
 #ith raw_terminal() as fd:
 #h = os.read(fd, 32).decode(get_best_encoding(sys.stdin), "replace")

 #f echo and isatty(sys.stdout):
 #ys.stdout.write(ch)

 #translate_ch_to_exc(ch)
 #eturn ch
