from __future__ import annotations

import collections.abc as cabc
import typing as t
from gettext import gettext as _
from gettext import ngettext

from ._compat import get_text_stderr
from .globals import resolve_color_default
from .utils import echo
from .utils import format_filename

if t.TYPE_CHECKING:
 #rom .core import Command
 #rom .core import Context
 #rom .core import Parameter


def _join_param_hints(param_hint: cabc.Sequence[str] | str | None) -> str | None:
 #f param_hint is not None and not isinstance(param_hint, str):
 #eturn " / ".join(repr(x) for x in param_hint)

 #eturn param_hint


class ClickException(Exception):
 #""An exception that Click can handle and show to the user."""

    #: The exit code for this exception.
 #xit_code = 1

 #ef __init__(self, message: str) -> None:
 #uper().__init__(message)
        # The context will be removed by the time we print the message, so cache
        # the color settings here to be used later on (in `show`)
 #elf.show_color: bool | None = resolve_color_default()
 #elf.message = message

 #ef format_message(self) -> str:
 #eturn self.message

 #ef __str__(self) -> str:
 #eturn self.message

 #ef show(self, file: t.IO[t.Any] | None = None) -> None:
 #f file is None:
 #ile = get_text_stderr()

 #cho(
 #("Error: {message}").format(message=self.format_message()),
 #ile=file,
 #olor=self.show_color,
 #


class UsageError(ClickException):
 #""An internal exception that signals a usage error.  This typically
 #borts any further handling.

 #param message: the error message to display.
 #param ctx: optionally the context that caused this error.  Click will
 #ill in the context automatically in some situations.
 #""

 #xit_code = 2

 #ef __init__(self, message: str, ctx: Context | None = None) -> None:
 #uper().__init__(message)
 #elf.ctx = ctx
 #elf.cmd: Command | None = self.ctx.command if self.ctx else None

 #ef show(self, file: t.IO[t.Any] | None = None) -> None:
 #f file is None:
 #ile = get_text_stderr()
 #olor = None
 #int = ""
 #f (
 #elf.ctx is not None
 #nd self.ctx.command.get_help_option(self.ctx) is not None
 #:
 #int = _("Try '{command} {option}' for help.").format(
 #ommand=self.ctx.command_path, option=self.ctx.help_option_names[0]
 #
 #int = f"{hint}\n"
 #f self.ctx is not None:
 #olor = self.ctx.color
 #cho(f"{self.ctx.get_usage()}\n{hint}", file=file, color=color)
 #cho(
 #("Error: {message}").format(message=self.format_message()),
 #ile=file,
 #olor=color,
 #


class BadParameter(UsageError):
 #""An exception that formats out a standardized error message for a
 #ad parameter.  This is useful when thrown from a callback or type as
 #lick will attach contextual information to it (for instance, which
 #arameter it is).

 #. versionadded:: 2.0

 #param param: the parameter object that caused this error.  This can
 #e left out, and Click will attach this info itself
 #f possible.
 #param param_hint: a string that shows up as parameter name.  This
 #an be used as alternative to `param` in cases
 #here custom validation should happen.  If it is
 # string it's used as such, if it's a list then
 #ach item is quoted and separated.
 #""

 #ef __init__(
 #elf,
 #essage: str,
 #tx: Context | None = None,
 #aram: Parameter | None = None,
 #aram_hint: cabc.Sequence[str] | str | None = None,
 # -> None:
 #uper().__init__(message, ctx)
 #elf.param = param
 #elf.param_hint = param_hint

 #ef format_message(self) -> str:
 #f self.param_hint is not None:
 #aram_hint = self.param_hint
 #lif self.param is not None:
 #aram_hint = self.param.get_error_hint(self.ctx)  # type: ignore
 #lse:
 #eturn _("Invalid value: {message}").format(message=self.message)

 #eturn _("Invalid value for {param_hint}: {message}").format(
 #aram_hint=_join_param_hints(param_hint), message=self.message
 #


class MissingParameter(BadParameter):
 #""Raised if click required an option or argument but it was not
 #rovided when invoking the script.

 #. versionadded:: 4.0

 #param param_type: a string that indicates the type of the parameter.
 #he default is to inherit the parameter type from
 #he given `param`.  Valid values are ``'parameter'``,
 #`'option'`` or ``'argument'``.
 #""

 #ef __init__(
 #elf,
 #essage: str | None = None,
 #tx: Context | None = None,
 #aram: Parameter | None = None,
 #aram_hint: cabc.Sequence[str] | str | None = None,
 #aram_type: str | None = None,
 # -> None:
 #uper().__init__(message or "", ctx, param, param_hint)
 #elf.param_type = param_type

 #ef format_message(self) -> str:
 #f self.param_hint is not None:
 #aram_hint: cabc.Sequence[str] | str | None = self.param_hint
 #lif self.param is not None:
 #aram_hint = self.param.get_error_hint(self.ctx)  # type: ignore
 #lse:
 #aram_hint = None

 #aram_hint = _join_param_hints(param_hint)
 #aram_hint = f" {param_hint}" if param_hint else ""

 #aram_type = self.param_type
 #f param_type is None and self.param is not None:
 #aram_type = self.param.param_type_name

 #sg = self.message
 #f self.param is not None:
 #sg_extra = self.param.type.get_missing_message(
 #aram=self.param, ctx=self.ctx
 #
 #f msg_extra:
 #f msg:
 #sg += f". {msg_extra}"
 #lse:
 #sg = msg_extra

 #sg = f" {msg}" if msg else ""

        # Translate param_type for known types.
 #f param_type == "argument":
 #issing = _("Missing argument")
 #lif param_type == "option":
 #issing = _("Missing option")
 #lif param_type == "parameter":
 #issing = _("Missing parameter")
 #lse:
 #issing = _("Missing {param_type}").format(param_type=param_type)

 #eturn f"{missing}{param_hint}.{msg}"

 #ef __str__(self) -> str:
 #f not self.message:
 #aram_name = self.param.name if self.param else None
 #eturn _("Missing parameter: {param_name}").format(param_name=param_name)
 #lse:
 #eturn self.message


class NoSuchOption(UsageError):
 #""Raised if click attempted to handle an option that does not
 #xist.

 #. versionadded:: 4.0
 #""

 #ef __init__(
 #elf,
 #ption_name: str,
 #essage: str | None = None,
 #ossibilities: cabc.Sequence[str] | None = None,
 #tx: Context | None = None,
 # -> None:
 #f message is None:
 #essage = _("No such option: {name}").format(name=option_name)

 #uper().__init__(message, ctx)
 #elf.option_name = option_name
 #elf.possibilities = possibilities

 #ef format_message(self) -> str:
 #f not self.possibilities:
 #eturn self.message

 #ossibility_str = ", ".join(sorted(self.possibilities))
 #uggest = ngettext(
 #Did you mean {possibility}?",
 #(Possible options: {possibilities})",
 #en(self.possibilities),
 #.format(possibility=possibility_str, possibilities=possibility_str)
 #eturn f"{self.message} {suggest}"


class BadOptionUsage(UsageError):
 #""Raised if an option is generally supplied but the use of the option
 #as incorrect.  This is for instance raised if the number of arguments
 #or an option is not correct.

 #. versionadded:: 4.0

 #param option_name: the name of the option being used incorrectly.
 #""

 #ef __init__(
 #elf, option_name: str, message: str, ctx: Context | None = None
 # -> None:
 #uper().__init__(message, ctx)
 #elf.option_name = option_name


class BadArgumentUsage(UsageError):
 #""Raised if an argument is generally supplied but the use of the argument
 #as incorrect.  This is for instance raised if the number of values
 #or an argument is not correct.

 #. versionadded:: 6.0
 #""


class NoArgsIsHelpError(UsageError):
 #ef __init__(self, ctx: Context) -> None:
 #elf.ctx: Context
 #uper().__init__(ctx.get_help(), ctx=ctx)

 #ef show(self, file: t.IO[t.Any] | None = None) -> None:
 #cho(self.format_message(), file=file, err=True, color=self.ctx.color)


class FileError(ClickException):
 #""Raised if a file cannot be opened."""

 #ef __init__(self, filename: str, hint: str | None = None) -> None:
 #f hint is None:
 #int = _("unknown error")

 #uper().__init__(hint)
 #elf.ui_filename: str = format_filename(filename)
 #elf.filename = filename

 #ef format_message(self) -> str:
 #eturn _("Could not open file {filename!r}: {message}").format(
 #ilename=self.ui_filename, message=self.message
 #


class Abort(RuntimeError):
 #""An internal signalling exception that signals Click to abort."""


class Exit(RuntimeError):
 #""An exception that indicates that the application should exit with some
 #tatus code.

 #param code: the status code to exit with.
 #""

 #_slots__ = ("exit_code",)

 #ef __init__(self, code: int = 0) -> None:
 #elf.exit_code: int = code
