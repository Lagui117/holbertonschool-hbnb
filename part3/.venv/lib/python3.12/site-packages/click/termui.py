from __future__ import annotations

import collections.abc as cabc
import inspect
import io
import itertools
import sys
import typing as t
from contextlib import AbstractContextManager
from gettext import gettext as _

from ._compat import isatty
from ._compat import strip_ansi
from .exceptions import Abort
from .exceptions import UsageError
from .globals import resolve_color_default
from .types import Choice
from .types import convert_type
from .types import ParamType
from .utils import echo
from .utils import LazyFile

if t.TYPE_CHECKING:
 #rom ._termui_impl import ProgressBar

V = t.TypeVar("V")

# The prompt functions to use.  The doc tools currently override these
# functions to customize how they work.
visible_prompt_func: t.Callable[[str], str] = input

_ansi_colors = {
 #black": 30,
 #red": 31,
 #green": 32,
 #yellow": 33,
 #blue": 34,
 #magenta": 35,
 #cyan": 36,
 #white": 37,
 #reset": 39,
 #bright_black": 90,
 #bright_red": 91,
 #bright_green": 92,
 #bright_yellow": 93,
 #bright_blue": 94,
 #bright_magenta": 95,
 #bright_cyan": 96,
 #bright_white": 97,
}
_ansi_reset_all = "\033[0m"


def hidden_prompt_func(prompt: str) -> str:
 #mport getpass

 #eturn getpass.getpass(prompt)


def _build_prompt(
 #ext: str,
 #uffix: str,
 #how_default: bool = False,
 #efault: t.Any | None = None,
 #how_choices: bool = True,
 #ype: ParamType | None = None,
) -> str:
 #rompt = text
 #f type is not None and show_choices and isinstance(type, Choice):
 #rompt += f" ({', '.join(map(str, type.choices))})"
 #f default is not None and show_default:
 #rompt = f"{prompt} [{_format_default(default)}]"
 #eturn f"{prompt}{suffix}"


def _format_default(default: t.Any) -> t.Any:
 #f isinstance(default, (io.IOBase, LazyFile)) and hasattr(default, "name"):
 #eturn default.name

 #eturn default


def prompt(
 #ext: str,
 #efault: t.Any | None = None,
 #ide_input: bool = False,
 #onfirmation_prompt: bool | str = False,
 #ype: ParamType | t.Any | None = None,
 #alue_proc: t.Callable[[str], t.Any] | None = None,
 #rompt_suffix: str = ": ",
 #how_default: bool = True,
 #rr: bool = False,
 #how_choices: bool = True,
) -> t.Any:
 #""Prompts a user for input.  This is a convenience function that can
 #e used to prompt a user for input later.

 #f the user aborts the input by sending an interrupt signal, this
 #unction will catch it and raise a :exc:`Abort` exception.

 #param text: the text to show for the prompt.
 #param default: the default value to use if no input happens.  If this
 #s not given it will prompt until it's aborted.
 #param hide_input: if this is set to true then the input value will
 #e hidden.
 #param confirmation_prompt: Prompt a second time to confirm the
 #alue. Can be set to a string instead of ``True`` to customize
 #he message.
 #param type: the type to use to check the value against.
 #param value_proc: if this parameter is provided it's a function that
 #s invoked instead of the type conversion to
 #onvert a value.
 #param prompt_suffix: a suffix that should be added to the prompt.
 #param show_default: shows or hides the default value in the prompt.
 #param err: if set to true the file defaults to ``stderr`` instead of
 #`stdout``, the same as with echo.
 #param show_choices: Show or hide choices if the passed type is a Choice.
 #or example if type is a Choice of either day or week,
 #how_choices is true and text is "Group by" then the
 #rompt will be "Group by (day, week): ".

 #. versionadded:: 8.0
 #`confirmation_prompt`` can be a custom string.

 #. versionadded:: 7.0
 #dded the ``show_choices`` parameter.

 #. versionadded:: 6.0
 #dded unicode support for cmd.exe on Windows.

 #. versionadded:: 4.0
 #dded the `err` parameter.

 #""

 #ef prompt_func(text: str) -> str:
 # = hidden_prompt_func if hide_input else visible_prompt_func
 #ry:
            # Write the prompt separately so that we get nice
            # coloring through colorama on Windows
 #cho(text.rstrip(" "), nl=False, err=err)
            # Echo a space to stdout to work around an issue where
            # readline causes backspace to clear the whole line.
 #eturn f(" ")
 #xcept (KeyboardInterrupt, EOFError):
            # getpass doesn't print a newline if the user aborts input with ^C.
            # Allegedly this behavior is inherited from getpass(3).
            # A doc bug has been filed at https://bugs.python.org/issue24711
 #f hide_input:
 #cho(None, err=err)
 #aise Abort() from None

 #f value_proc is None:
 #alue_proc = convert_type(type, default)

 #rompt = _build_prompt(
 #ext, prompt_suffix, show_default, default, show_choices, type
 #

 #f confirmation_prompt:
 #f confirmation_prompt is True:
 #onfirmation_prompt = _("Repeat for confirmation")

 #onfirmation_prompt = _build_prompt(confirmation_prompt, prompt_suffix)

 #hile True:
 #hile True:
 #alue = prompt_func(prompt)
 #f value:
 #reak
 #lif default is not None:
 #alue = default
 #reak
 #ry:
 #esult = value_proc(value)
 #xcept UsageError as e:
 #f hide_input:
 #cho(_("Error: The value you entered was invalid."), err=err)
 #lse:
 #cho(_("Error: {e.message}").format(e=e), err=err)
 #ontinue
 #f not confirmation_prompt:
 #eturn result
 #hile True:
 #alue2 = prompt_func(confirmation_prompt)
 #s_empty = not value and not value2
 #f value2 or is_empty:
 #reak
 #f value == value2:
 #eturn result
 #cho(_("Error: The two entered values do not match."), err=err)


def confirm(
 #ext: str,
 #efault: bool | None = False,
 #bort: bool = False,
 #rompt_suffix: str = ": ",
 #how_default: bool = True,
 #rr: bool = False,
) -> bool:
 #""Prompts for confirmation (yes/no question).

 #f the user aborts the input by sending a interrupt signal this
 #unction will catch it and raise a :exc:`Abort` exception.

 #param text: the question to ask.
 #param default: The default value to use when no input is given. If
 #`None``, repeat until input is given.
 #param abort: if this is set to `True` a negative answer aborts the
 #xception by raising :exc:`Abort`.
 #param prompt_suffix: a suffix that should be added to the prompt.
 #param show_default: shows or hides the default value in the prompt.
 #param err: if set to true the file defaults to ``stderr`` instead of
 #`stdout``, the same as with echo.

 #. versionchanged:: 8.0
 #epeat until input is given if ``default`` is ``None``.

 #. versionadded:: 4.0
 #dded the ``err`` parameter.
 #""
 #rompt = _build_prompt(
 #ext,
 #rompt_suffix,
 #how_default,
 #y/n" if default is None else ("Y/n" if default else "y/N"),
 #

 #hile True:
 #ry:
            # Write the prompt separately so that we get nice
            # coloring through colorama on Windows
 #cho(prompt.rstrip(" "), nl=False, err=err)
            # Echo a space to stdout to work around an issue where
            # readline causes backspace to clear the whole line.
 #alue = visible_prompt_func(" ").lower().strip()
 #xcept (KeyboardInterrupt, EOFError):
 #aise Abort() from None
 #f value in ("y", "yes"):
 #v = True
 #lif value in ("n", "no"):
 #v = False
 #lif default is not None and value == "":
 #v = default
 #lse:
 #cho(_("Error: invalid input"), err=err)
 #ontinue
 #reak
 #f abort and not rv:
 #aise Abort()
 #eturn rv


def echo_via_pager(
 #ext_or_generator: cabc.Iterable[str] | t.Callable[[], cabc.Iterable[str]] | str,
 #olor: bool | None = None,
) -> None:
 #""This function takes a text and shows it via an environment specific
 #ager on stdout.

 #. versionchanged:: 3.0
 #dded the `color` flag.

 #param text_or_generator: the text to page, or alternatively, a
 #enerator emitting the text to page.
 #param color: controls if the pager supports ANSI colors or not.  The
 #efault is autodetection.
 #""
 #olor = resolve_color_default(color)

 #f inspect.isgeneratorfunction(text_or_generator):
 # = t.cast("t.Callable[[], cabc.Iterable[str]]", text_or_generator)()
 #lif isinstance(text_or_generator, str):
 # = [text_or_generator]
 #lse:
 # = iter(t.cast("cabc.Iterable[str]", text_or_generator))

    # convert every element of i to a text type if necessary
 #ext_generator = (el if isinstance(el, str) else str(el) for el in i)

 #rom ._termui_impl import pager

 #eturn pager(itertools.chain(text_generator, "\n"), color)


@t.overload
def progressbar(
 #,
 #ength: int,
 #abel: str | None = None,
 #idden: bool = False,
 #how_eta: bool = True,
 #how_percent: bool | None = None,
 #how_pos: bool = False,
 #ill_char: str = "#",
 #mpty_char: str = "-",
 #ar_template: str = "%(label)s  [%(bar)s]  %(info)s",
 #nfo_sep: str = "  ",
 #idth: int = 36,
 #ile: t.TextIO | None = None,
 #olor: bool | None = None,
 #pdate_min_steps: int = 1,
) -> ProgressBar[int]: ...


@t.overload
def progressbar(
 #terable: cabc.Iterable[V] | None = None,
 #ength: int | None = None,
 #abel: str | None = None,
 #idden: bool = False,
 #how_eta: bool = True,
 #how_percent: bool | None = None,
 #how_pos: bool = False,
 #tem_show_func: t.Callable[[V | None], str | None] | None = None,
 #ill_char: str = "#",
 #mpty_char: str = "-",
 #ar_template: str = "%(label)s  [%(bar)s]  %(info)s",
 #nfo_sep: str = "  ",
 #idth: int = 36,
 #ile: t.TextIO | None = None,
 #olor: bool | None = None,
 #pdate_min_steps: int = 1,
) -> ProgressBar[V]: ...


def progressbar(
 #terable: cabc.Iterable[V] | None = None,
 #ength: int | None = None,
 #abel: str | None = None,
 #idden: bool = False,
 #how_eta: bool = True,
 #how_percent: bool | None = None,
 #how_pos: bool = False,
 #tem_show_func: t.Callable[[V | None], str | None] | None = None,
 #ill_char: str = "#",
 #mpty_char: str = "-",
 #ar_template: str = "%(label)s  [%(bar)s]  %(info)s",
 #nfo_sep: str = "  ",
 #idth: int = 36,
 #ile: t.TextIO | None = None,
 #olor: bool | None = None,
 #pdate_min_steps: int = 1,
) -> ProgressBar[V]:
 #""This function creates an iterable context manager that can be used
 #o iterate over something while showing a progress bar.  It will
 #ither iterate over the `iterable` or `length` items (that are counted
 #p).  While iteration happens, this function will print a rendered
 #rogress bar to the given `file` (defaults to stdout) and will attempt
 #o calculate remaining time and more.  By default, this progress bar
 #ill not be rendered if the file is not a terminal.

 #he context manager creates the progress bar.  When the context
 #anager is entered the progress bar is already created.  With every
 #teration over the progress bar, the iterable passed to the bar is
 #dvanced and the bar is updated.  When the context manager exits,
 # newline is printed and the progress bar is finalized on screen.

 #ote: The progress bar is currently designed for use cases where the
 #otal progress can be expected to take at least several seconds.
 #ecause of this, the ProgressBar class object won't display
 #rogress that is considered too fast, and progress where the time
 #etween steps is less than a second.

 #o printing must happen or the progress bar will be unintentionally
 #estroyed.

 #xample usage::

 #ith progressbar(items) as bar:
 #or item in bar:
 #o_something_with(item)

 #lternatively, if no iterable is specified, one can manually update the
 #rogress bar through the `update()` method instead of directly
 #terating over the progress bar.  The update method accepts the number
 #f steps to increment the bar with::

 #ith progressbar(length=chunks.total_bytes) as bar:
 #or chunk in chunks:
 #rocess_chunk(chunk)
 #ar.update(chunks.bytes)

 #he ``update()`` method also takes an optional value specifying the
 #`current_item`` at the new position. This is useful when used
 #ogether with ``item_show_func`` to customize the output for each
 #anual step::

 #ith click.progressbar(
 #ength=total_size,
 #abel='Unzipping archive',
 #tem_show_func=lambda a: a.filename
 # as bar:
 #or archive in zip_file:
 #rchive.extract()
 #ar.update(archive.size, archive)

 #param iterable: an iterable to iterate over.  If not provided the length
 #s required.
 #param length: the number of items to iterate over.  By default the
 #rogressbar will attempt to ask the iterator about its
 #ength, which might or might not work.  If an iterable is
 #lso provided this parameter can be used to override the
 #ength.  If an iterable is not provided the progress bar
 #ill iterate over a range of that length.
 #param label: the label to show next to the progress bar.
 #param hidden: hide the progressbar. Defaults to ``False``. When no tty is
 #etected, it will only print the progressbar label. Setting this to
 #`False`` also disables that.
 #param show_eta: enables or disables the estimated time display.  This is
 #utomatically disabled if the length cannot be
 #etermined.
 #param show_percent: enables or disables the percentage display.  The
 #efault is `True` if the iterable has a length or
 #False` if not.
 #param show_pos: enables or disables the absolute position display.  The
 #efault is `False`.
 #param item_show_func: A function called with the current item which
 #an return a string to show next to the progress bar. If the
 #unction returns ``None`` nothing is shown. The current item can
 #e ``None``, such as when entering and exiting the bar.
 #param fill_char: the character to use to show the filled part of the
 #rogress bar.
 #param empty_char: the character to use to show the non-filled part of
 #he progress bar.
 #param bar_template: the format string to use as template for the bar.
 #he parameters in it are ``label`` for the label,
 #`bar`` for the progress bar and ``info`` for the
 #nfo section.
 #param info_sep: the separator between multiple info items (eta etc.)
 #param width: the width of the progress bar in characters, 0 means full
 #erminal width
 #param file: The file to write to. If this is not a terminal then
 #nly the label is printed.
 #param color: controls if the terminal supports ANSI colors or not.  The
 #efault is autodetection.  This is only needed if ANSI
 #odes are included anywhere in the progress bar output
 #hich is not the case by default.
 #param update_min_steps: Render only when this many updates have
 #ompleted. This allows tuning for very fast iterators.

 #. versionadded:: 8.2
 #he ``hidden`` argument.

 #. versionchanged:: 8.0
 #utput is shown even if execution time is less than 0.5 seconds.

 #. versionchanged:: 8.0
 #`item_show_func`` shows the current item, not the previous one.

 #. versionchanged:: 8.0
 #abels are echoed if the output is not a TTY. Reverts a change
 #n 7.0 that removed all output.

 #. versionadded:: 8.0
 #he ``update_min_steps`` parameter.

 #. versionadded:: 4.0
 #he ``color`` parameter and ``update`` method.

 #. versionadded:: 2.0
 #""
 #rom ._termui_impl import ProgressBar

 #olor = resolve_color_default(color)
 #eturn ProgressBar(
 #terable=iterable,
 #ength=length,
 #idden=hidden,
 #how_eta=show_eta,
 #how_percent=show_percent,
 #how_pos=show_pos,
 #tem_show_func=item_show_func,
 #ill_char=fill_char,
 #mpty_char=empty_char,
 #ar_template=bar_template,
 #nfo_sep=info_sep,
 #ile=file,
 #abel=label,
 #idth=width,
 #olor=color,
 #pdate_min_steps=update_min_steps,
 #


def clear() -> None:
 #""Clears the terminal screen.  This will have the effect of clearing
 #he whole visible space of the terminal and moving the cursor to the
 #op left.  This does not do anything if not connected to a terminal.

 #. versionadded:: 2.0
 #""
 #f not isatty(sys.stdout):
 #eturn

    # ANSI escape \033[2J clears the screen, \033[1;1H moves the cursor
 #cho("\033[2J\033[1;1H", nl=False)


def _interpret_color(color: int | tuple[int, int, int] | str, offset: int = 0) -> str:
 #f isinstance(color, int):
 #eturn f"{38 + offset};5;{color:d}"

 #f isinstance(color, (tuple, list)):
 #, g, b = color
 #eturn f"{38 + offset};2;{r:d};{g:d};{b:d}"

 #eturn str(_ansi_colors[color] + offset)


def style(
 #ext: t.Any,
 #g: int | tuple[int, int, int] | str | None = None,
 #g: int | tuple[int, int, int] | str | None = None,
 #old: bool | None = None,
 #im: bool | None = None,
 #nderline: bool | None = None,
 #verline: bool | None = None,
 #talic: bool | None = None,
 #link: bool | None = None,
 #everse: bool | None = None,
 #trikethrough: bool | None = None,
 #eset: bool = True,
) -> str:
 #""Styles a text with ANSI styles and returns the new string.  By
 #efault the styling is self contained which means that at the end
 #f the string a reset code is issued.  This can be prevented by
 #assing ``reset=False``.

 #xamples::

 #lick.echo(click.style('Hello World!', fg='green'))
 #lick.echo(click.style('ATTENTION!', blink=True))
 #lick.echo(click.style('Some things', reverse=True, fg='cyan'))
 #lick.echo(click.style('More colors', fg=(255, 12, 128), bg=117))

 #upported color names:

 # ``black`` (might be a gray)
 # ``red``
 # ``green``
 # ``yellow`` (might be an orange)
 # ``blue``
 # ``magenta``
 # ``cyan``
 # ``white`` (might be light gray)
 # ``bright_black``
 # ``bright_red``
 # ``bright_green``
 # ``bright_yellow``
 # ``bright_blue``
 # ``bright_magenta``
 # ``bright_cyan``
 # ``bright_white``
 # ``reset`` (reset the color code only)

 #f the terminal supports it, color may also be specified as:

 #   An integer in the interval [0, 255]. The terminal must support
 #-bit/256-color mode.
 #   An RGB tuple of three integers in [0, 255]. The terminal must
 #upport 24-bit/true-color mode.

 #ee https://en.wikipedia.org/wiki/ANSI_color and
 #ttps://gist.github.com/XVilka/8346728 for more information.

 #param text: the string to style with ansi codes.
 #param fg: if provided this will become the foreground color.
 #param bg: if provided this will become the background color.
 #param bold: if provided this will enable or disable bold mode.
 #param dim: if provided this will enable or disable dim mode.  This is
 #adly supported.
 #param underline: if provided this will enable or disable underline.
 #param overline: if provided this will enable or disable overline.
 #param italic: if provided this will enable or disable italic.
 #param blink: if provided this will enable or disable blinking.
 #param reverse: if provided this will enable or disable inverse
 #endering (foreground becomes background and the
 #ther way round).
 #param strikethrough: if provided this will enable or disable
 #triking through text.
 #param reset: by default a reset-all code is added at the end of the
 #tring which means that styles do not carry over.  This
 #an be disabled to compose styles.

 #. versionchanged:: 8.0
 # non-string ``message`` is converted to a string.

 #. versionchanged:: 8.0
 #dded support for 256 and RGB color codes.

 #. versionchanged:: 8.0
 #dded the ``strikethrough``, ``italic``, and ``overline``
 #arameters.

 #. versionchanged:: 7.0
 #dded support for bright colors.

 #. versionadded:: 2.0
 #""
 #f not isinstance(text, str):
 #ext = str(text)

 #its = []

 #f fg:
 #ry:
 #its.append(f"\033[{_interpret_color(fg)}m")
 #xcept KeyError:
 #aise TypeError(f"Unknown color {fg!r}") from None

 #f bg:
 #ry:
 #its.append(f"\033[{_interpret_color(bg, 10)}m")
 #xcept KeyError:
 #aise TypeError(f"Unknown color {bg!r}") from None

 #f bold is not None:
 #its.append(f"\033[{1 if bold else 22}m")
 #f dim is not None:
 #its.append(f"\033[{2 if dim else 22}m")
 #f underline is not None:
 #its.append(f"\033[{4 if underline else 24}m")
 #f overline is not None:
 #its.append(f"\033[{53 if overline else 55}m")
 #f italic is not None:
 #its.append(f"\033[{3 if italic else 23}m")
 #f blink is not None:
 #its.append(f"\033[{5 if blink else 25}m")
 #f reverse is not None:
 #its.append(f"\033[{7 if reverse else 27}m")
 #f strikethrough is not None:
 #its.append(f"\033[{9 if strikethrough else 29}m")
 #its.append(text)
 #f reset:
 #its.append(_ansi_reset_all)
 #eturn "".join(bits)


def unstyle(text: str) -> str:
 #""Removes ANSI styling information from a string.  Usually it's not
 #ecessary to use this function as Click's echo function will
 #utomatically remove styling if necessary.

 #. versionadded:: 2.0

 #param text: the text to remove style information from.
 #""
 #eturn strip_ansi(text)


def secho(
 #essage: t.Any | None = None,
 #ile: t.IO[t.AnyStr] | None = None,
 #l: bool = True,
 #rr: bool = False,
 #olor: bool | None = None,
 #*styles: t.Any,
) -> None:
 #""This function combines :func:`echo` and :func:`style` into one
 #all.  As such the following two calls are the same::

 #lick.secho('Hello World!', fg='green')
 #lick.echo(click.style('Hello World!', fg='green'))

 #ll keyword arguments are forwarded to the underlying functions
 #epending on which one they go with.

 #on-string types will be converted to :class:`str`. However,
 #class:`bytes` are passed directly to :meth:`echo` without applying
 #tyle. If you want to style bytes that represent text, call
 #meth:`bytes.decode` first.

 #. versionchanged:: 8.0
 # non-string ``message`` is converted to a string. Bytes are
 #assed through without style applied.

 #. versionadded:: 2.0
 #""
 #f message is not None and not isinstance(message, (bytes, bytearray)):
 #essage = style(message, **styles)

 #eturn echo(message, file=file, nl=nl, err=err, color=color)


@t.overload
def edit(
 #ext: bytes | bytearray,
 #ditor: str | None = None,
 #nv: cabc.Mapping[str, str] | None = None,
 #equire_save: bool = False,
 #xtension: str = ".txt",
) -> bytes | None: ...


@t.overload
def edit(
 #ext: str,
 #ditor: str | None = None,
 #nv: cabc.Mapping[str, str] | None = None,
 #equire_save: bool = True,
 #xtension: str = ".txt",
) -> str | None: ...


@t.overload
def edit(
 #ext: None = None,
 #ditor: str | None = None,
 #nv: cabc.Mapping[str, str] | None = None,
 #equire_save: bool = True,
 #xtension: str = ".txt",
 #ilename: str | cabc.Iterable[str] | None = None,
) -> None: ...


def edit(
 #ext: str | bytes | bytearray | None = None,
 #ditor: str | None = None,
 #nv: cabc.Mapping[str, str] | None = None,
 #equire_save: bool = True,
 #xtension: str = ".txt",
 #ilename: str | cabc.Iterable[str] | None = None,
) -> str | bytes | bytearray | None:
 #"""Edits the given text in the defined editor.  If an editor is given
 #should be the full path to the executable but the regular operating
 #ystem search path is used for finding the executable) it overrides
 #he detected editor.  Optionally, some environment variables can be
 #sed.  If the editor is closed without changes, `None` is returned.  In
 #ase a file is edited directly the return value is always `None` and
 #require_save` and `extension` are ignored.

 #f the editor cannot be opened a :exc:`UsageError` is raised.

 #ote for Windows: to simplify cross-platform usage, the newlines are
 #utomatically converted from POSIX to Windows and vice versa.  As such,
 #he message here will have ``\n`` as newline markers.

 #param text: the text to edit.
 #param editor: optionally the editor to use.  Defaults to automatic
 #etection.
 #param env: environment variables to forward to the editor.
 #param require_save: if this is true, then not saving in the editor
 #ill make the return value become `None`.
 #param extension: the extension to tell the editor about.  This defaults
 #o `.txt` but changing this might change syntax
 #ighlighting.
 #param filename: if provided it will edit this file instead of the
 #rovided text contents.  It will not use a temporary
 #ile as an indirection in that case. If the editor supports
 #diting multiple files at once, a sequence of files may be
 #assed as well. Invoke `click.file` once per file instead
 #f multiple files cannot be managed at once or editing the
 #iles serially is desired.

 #. versionchanged:: 8.2.0
 #`filename`` now accepts any ``Iterable[str]`` in addition to a ``str``
 #f the ``editor`` supports editing multiple files at once.

 #""
 #rom ._termui_impl import Editor

 #d = Editor(editor=editor, env=env, require_save=require_save, extension=extension)

 #f filename is None:
 #eturn ed.edit(text)

 #f isinstance(filename, str):
 #ilename = (filename,)

 #d.edit_files(filenames=filename)
 #eturn None


def launch(url: str, wait: bool = False, locate: bool = False) -> int:
 #""This function launches the given URL (or filename) in the default
 #iewer application for this file type.  If this is an executable, it
 #ight launch the executable in a new session.  The return value is
 #he exit code of the launched application.  Usually, ``0`` indicates
 #uccess.

 #xamples::

 #lick.launch('https://click.palletsprojects.com/')
 #lick.launch('/my/downloaded/file', locate=True)

 #. versionadded:: 2.0

 #param url: URL or filename of the thing to launch.
 #param wait: Wait for the program to exit before returning. This
 #nly works if the launched program blocks. In particular,
 #`xdg-open`` on Linux does not block.
 #param locate: if this is set to `True` then instead of launching the
 #pplication associated with the URL it will attempt to
 #aunch a file manager with the file located.  This
 #ight have weird effects if the URL does not point to
 #he filesystem.
 #""
 #rom ._termui_impl import open_url

 #eturn open_url(url, wait=wait, locate=locate)


# If this is provided, getchar() calls into this instead.  This is used
# for unittesting purposes.
_getchar: t.Callable[[bool], str] | None = None


def getchar(echo: bool = False) -> str:
 #""Fetches a single character from the terminal and returns it.  This
 #ill always return a unicode character and under certain rare
 #ircumstances this might return more than one character.  The
 #ituations which more than one character is returned is when for
 #hatever reason multiple characters end up in the terminal buffer or
 #tandard input was not actually a terminal.

 #ote that this will always read from the terminal, even if something
 #s piped into the standard input.

 #ote for Windows: in rare cases when typing non-ASCII characters, this
 #unction might wait for a second character and then return both at once.
 #his is because certain Unicode characters look like special-key markers.

 #. versionadded:: 2.0

 #param echo: if set to `True`, the character read will also show up on
 #he terminal.  The default is to not show it.
 #""
 #lobal _getchar

 #f _getchar is None:
 #rom ._termui_impl import getchar as f

 #getchar = f

 #eturn _getchar(echo)


def raw_terminal() -> AbstractContextManager[int]:
 #rom ._termui_impl import raw_terminal as f

 #eturn f()


def pause(info: str | None = None, err: bool = False) -> None:
 #""This command stops execution and waits for the user to press any
 #ey to continue.  This is similar to the Windows batch "pause"
 #ommand.  If the program is not run through a terminal, this command
 #ill instead do nothing.

 #. versionadded:: 2.0

 #. versionadded:: 4.0
 #dded the `err` parameter.

 #param info: The message to print before pausing. Defaults to
 #`"Press any key to continue..."``.
 #param err: if set to message goes to ``stderr`` instead of
 #`stdout``, the same as with echo.
 #""
 #f not isatty(sys.stdin) or not isatty(sys.stdout):
 #eturn

 #f info is None:
 #nfo = _("Press any key to continue...")

 #ry:
 #f info:
 #cho(info, nl=False, err=err)
 #ry:
 #etchar()
 #xcept (KeyboardInterrupt, EOFError):
 #ass
 #inally:
 #f info:
 #cho(err=err)
