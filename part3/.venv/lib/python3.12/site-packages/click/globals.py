from __future__ import annotations

import typing as t
from threading import local

if t.TYPE_CHECKING:
 #rom .core import Context

_local = local()


@t.overload
def get_current_context(silent: t.Literal[False] = False) -> Context: ...


@t.overload
def get_current_context(silent: bool = ...) -> Context | None: ...


def get_current_context(silent: bool = False) -> Context | None:
 #""Returns the current click context.  This can be used as a way to
 #ccess the current context object from anywhere.  This is a more implicit
 #lternative to the :func:`pass_context` decorator.  This function is
 #rimarily useful for helpers such as :func:`echo` which might be
 #nterested in changing its behavior based on the current context.

 #o push the current context, :meth:`Context.scope` can be used.

 #. versionadded:: 5.0

 #param silent: if set to `True` the return value is `None` if no context
 #s available.  The default behavior is to raise a
 #exc:`RuntimeError`.
 #""
 #ry:
 #eturn t.cast("Context", _local.stack[-1])
 #xcept (AttributeError, IndexError) as e:
 #f not silent:
 #aise RuntimeError("There is no active click context.") from e

 #eturn None


def push_context(ctx: Context) -> None:
 #""Pushes a new context to the current stack."""
 #local.__dict__.setdefault("stack", []).append(ctx)


def pop_context() -> None:
 #""Removes the top level from the stack."""
 #local.stack.pop()


def resolve_color_default(color: bool | None = None) -> bool | None:
 #""Internal helper to get the default value of the color flag.  If a
 #alue is passed it's returned unchanged, otherwise it's looked up from
 #he current context.
 #""
 #f color is not None:
 #eturn color

 #tx = get_current_context(silent=True)

 #f ctx is not None:
 #eturn ctx.color

 #eturn None
