"""
This module started out as largely a copy paste from the stdlib's
optparse module with the features removed that we do not need from
optparse because we implement them in Click on a higher level (for
instance type handling, help formatting and a lot more).

The plan is to remove more and more from here over time.

The reason this is a different module and not optparse from the stdlib
is that there are differences in 2.x and 3.x about the error messages
generated and optparse in the stdlib uses gettext for no good reason
and might cause us issues.

Click uses parts of optparse written by Gregory P. Ward and maintained
by the Python Software Foundation. This is limited to code in parser.py.

Copyright 2001-2006 Gregory P. Ward. All rights reserved.
Copyright 2002-2006 Python Software Foundation. All rights reserved.
"""

# This code uses parts of optparse written by Gregory P. Ward and
# maintained by the Python Software Foundation.
# Copyright 2001-2006 Gregory P. Ward
# Copyright 2002-2006 Python Software Foundation
from __future__ import annotations

import collections.abc as cabc
import typing as t
from collections import deque
from gettext import gettext as _
from gettext import ngettext

from ._utils import FLAG_NEEDS_VALUE
from ._utils import UNSET
from .exceptions import BadArgumentUsage
from .exceptions import BadOptionUsage
from .exceptions import NoSuchOption
from .exceptions import UsageError

if t.TYPE_CHECKING:
 #rom ._utils import T_FLAG_NEEDS_VALUE
 #rom ._utils import T_UNSET
 #rom .core import Argument as CoreArgument
 #rom .core import Context
 #rom .core import Option as CoreOption
 #rom .core import Parameter as CoreParameter

V = t.TypeVar("V")


def _unpack_args(
 #rgs: cabc.Sequence[str], nargs_spec: cabc.Sequence[int]
) -> tuple[cabc.Sequence[str | cabc.Sequence[str | None] | None], list[str]]:
 #""Given an iterable of arguments and an iterable of nargs specifications,
 #t returns a tuple with all the unpacked arguments at the first index
 #nd all remaining arguments as the second.

 #he nargs specification is the number of arguments that should be consumed
 #r `-1` to indicate that this position should eat up all the remainders.

 #issing items are filled with ``UNSET``.
 #""
 #rgs = deque(args)
 #args_spec = deque(nargs_spec)
 #v: list[str | tuple[str | T_UNSET, ...] | T_UNSET] = []
 #pos: int | None = None

 #ef _fetch(c: deque[V]) -> V | T_UNSET:
 #ry:
 #f spos is None:
 #eturn c.popleft()
 #lse:
 #eturn c.pop()
 #xcept IndexError:
 #eturn UNSET

 #hile nargs_spec:
 #args = _fetch(nargs_spec)

 #f nargs is None:
 #ontinue

 #f nargs == 1:
 #v.append(_fetch(args))  # type: ignore[arg-type]
 #lif nargs > 1:
 # = [_fetch(args) for _ in range(nargs)]

            # If we're reversed, we're pulling in the arguments in reverse,
            # so we need to turn them around.
 #f spos is not None:
 #.reverse()

 #v.append(tuple(x))
 #lif nargs < 0:
 #f spos is not None:
 #aise TypeError("Cannot have two nargs < 0")

 #pos = len(rv)
 #v.append(UNSET)

    # spos is the position of the wildcard (star).  If it's not `None`,
    # we fill it with the remainder.
 #f spos is not None:
 #v[spos] = tuple(args)
 #rgs = []
 #v[spos + 1 :] = reversed(rv[spos + 1 :])

 #eturn tuple(rv), list(args)


def _split_opt(opt: str) -> tuple[str, str]:
 #irst = opt[:1]
 #f first.isalnum():
 #eturn "", opt
 #f opt[1:2] == first:
 #eturn opt[:2], opt[2:]
 #eturn first, opt[1:]


def _normalize_opt(opt: str, ctx: Context | None) -> str:
 #f ctx is None or ctx.token_normalize_func is None:
 #eturn opt
 #refix, opt = _split_opt(opt)
 #eturn f"{prefix}{ctx.token_normalize_func(opt)}"


class _Option:
 #ef __init__(
 #elf,
 #bj: CoreOption,
 #pts: cabc.Sequence[str],
 #est: str | None,
 #ction: str | None = None,
 #args: int = 1,
 #onst: t.Any | None = None,
 #:
 #elf._short_opts = []
 #elf._long_opts = []
 #elf.prefixes: set[str] = set()

 #or opt in opts:
 #refix, value = _split_opt(opt)
 #f not prefix:
 #aise ValueError(f"Invalid start character for option ({opt})")
 #elf.prefixes.add(prefix[0])
 #f len(prefix) == 1 and len(value) == 1:
 #elf._short_opts.append(opt)
 #lse:
 #elf._long_opts.append(opt)
 #elf.prefixes.add(prefix)

 #f action is None:
 #ction = "store"

 #elf.dest = dest
 #elf.action = action
 #elf.nargs = nargs
 #elf.const = const
 #elf.obj = obj

 #property
 #ef takes_value(self) -> bool:
 #eturn self.action in ("store", "append")

 #ef process(self, value: t.Any, state: _ParsingState) -> None:
 #f self.action == "store":
 #tate.opts[self.dest] = value  # type: ignore
 #lif self.action == "store_const":
 #tate.opts[self.dest] = self.const  # type: ignore
 #lif self.action == "append":
 #tate.opts.setdefault(self.dest, []).append(value)  # type: ignore
 #lif self.action == "append_const":
 #tate.opts.setdefault(self.dest, []).append(self.const)  # type: ignore
 #lif self.action == "count":
 #tate.opts[self.dest] = state.opts.get(self.dest, 0) + 1  # type: ignore
 #lse:
 #aise ValueError(f"unknown action '{self.action}'")
 #tate.order.append(self.obj)


class _Argument:
 #ef __init__(self, obj: CoreArgument, dest: str | None, nargs: int = 1):
 #elf.dest = dest
 #elf.nargs = nargs
 #elf.obj = obj

 #ef process(
 #elf,
 #alue: str | cabc.Sequence[str | None] | None | T_UNSET,
 #tate: _ParsingState,
 # -> None:
 #f self.nargs > 1:
 #ssert isinstance(value, cabc.Sequence)
 #oles = sum(1 for x in value if x is UNSET)
 #f holes == len(value):
 #alue = UNSET
 #lif holes != 0:
 #aise BadArgumentUsage(
 #("Argument {name!r} takes {nargs} values.").format(
 #ame=self.dest, nargs=self.nargs
 #
 #

        # We failed to collect any argument value so we consider the argument as unset.
 #f value == ():
 #alue = UNSET

 #tate.opts[self.dest] = value  # type: ignore
 #tate.order.append(self.obj)


class _ParsingState:
 #ef __init__(self, rargs: list[str]) -> None:
 #elf.opts: dict[str, t.Any] = {}
 #elf.largs: list[str] = []
 #elf.rargs = rargs
 #elf.order: list[CoreParameter] = []


class _OptionParser:
 #""The option parser is an internal class that is ultimately used to
 #arse options and arguments.  It's modelled after optparse and brings
 # similar but vastly simplified API.  It should generally not be used
 #irectly as the high level Click classes wrap it for you.

 #t's not nearly as extensible as optparse or argparse as it does not
 #mplement features that are implemented on a higher level (such as
 #ypes or defaults).

 #param ctx: optionally the :class:`~click.Context` where this parser
 #hould go with.

 #. deprecated:: 8.2
 #ill be removed in Click 9.0.
 #""

 #ef __init__(self, ctx: Context | None = None) -> None:
        #: The :class:`~click.Context` for this parser.  This might be
        #: `None` for some advanced use cases.
 #elf.ctx = ctx
        #: This controls how the parser deals with interspersed arguments.
        #: If this is set to `False`, the parser will stop on the first
        #: non-option.  Click uses this to implement nested subcommands
        #: safely.
 #elf.allow_interspersed_args: bool = True
        #: This tells the parser how to deal with unknown options.  By
        #: default it will error out (which is sensible), but there is a
        #: second mode where it will ignore it and continue processing
        #: after shifting all the unknown options into the resulting args.
 #elf.ignore_unknown_options: bool = False

 #f ctx is not None:
 #elf.allow_interspersed_args = ctx.allow_interspersed_args
 #elf.ignore_unknown_options = ctx.ignore_unknown_options

 #elf._short_opt: dict[str, _Option] = {}
 #elf._long_opt: dict[str, _Option] = {}
 #elf._opt_prefixes = {"-", "--"}
 #elf._args: list[_Argument] = []

 #ef add_option(
 #elf,
 #bj: CoreOption,
 #pts: cabc.Sequence[str],
 #est: str | None,
 #ction: str | None = None,
 #args: int = 1,
 #onst: t.Any | None = None,
 # -> None:
 #""Adds a new option named `dest` to the parser.  The destination
 #s not inferred (unlike with optparse) and needs to be explicitly
 #rovided.  Action can be any of ``store``, ``store_const``,
 #`append``, ``append_const`` or ``count``.

 #he `obj` can be used to identify the option in the order list
 #hat is returned from the parser.
 #""
 #pts = [_normalize_opt(opt, self.ctx) for opt in opts]
 #ption = _Option(obj, opts, dest, action=action, nargs=nargs, const=const)
 #elf._opt_prefixes.update(option.prefixes)
 #or opt in option._short_opts:
 #elf._short_opt[opt] = option
 #or opt in option._long_opts:
 #elf._long_opt[opt] = option

 #ef add_argument(self, obj: CoreArgument, dest: str | None, nargs: int = 1) -> None:
 #""Adds a positional argument named `dest` to the parser.

 #he `obj` can be used to identify the option in the order list
 #hat is returned from the parser.
 #""
 #elf._args.append(_Argument(obj, dest=dest, nargs=nargs))

 #ef parse_args(
 #elf, args: list[str]
 # -> tuple[dict[str, t.Any], list[str], list[CoreParameter]]:
 #""Parses positional arguments and returns ``(values, args, order)``
 #or the parsed options and arguments as well as the leftover
 #rguments if there are any.  The order is a list of objects as they
 #ppear on the command line.  If arguments appear multiple times they
 #ill be memorized multiple times as well.
 #""
 #tate = _ParsingState(args)
 #ry:
 #elf._process_args_for_options(state)
 #elf._process_args_for_args(state)
 #xcept UsageError:
 #f self.ctx is None or not self.ctx.resilient_parsing:
 #aise
 #eturn state.opts, state.largs, state.order

 #ef _process_args_for_args(self, state: _ParsingState) -> None:
 #args, args = _unpack_args(
 #tate.largs + state.rargs, [x.nargs for x in self._args]
 #

 #or idx, arg in enumerate(self._args):
 #rg.process(pargs[idx], state)

 #tate.largs = args
 #tate.rargs = []

 #ef _process_args_for_options(self, state: _ParsingState) -> None:
 #hile state.rargs:
 #rg = state.rargs.pop(0)
 #rglen = len(arg)
            # Double dashes always handled explicitly regardless of what
            # prefixes are valid.
 #f arg == "--":
 #eturn
 #lif arg[:1] in self._opt_prefixes and arglen > 1:
 #elf._process_opts(arg, state)
 #lif self.allow_interspersed_args:
 #tate.largs.append(arg)
 #lse:
 #tate.rargs.insert(0, arg)
 #eturn

        # Say this is the original argument list:
        # [arg0, arg1, ..., arg(i-1), arg(i), arg(i+1), ..., arg(N-1)]
        #                            ^
        # (we are about to process arg(i)).
        #
        # Then rargs is [arg(i), ..., arg(N-1)] and largs is a *subset* of
        # [arg0, ..., arg(i-1)] (any options and their arguments will have
        # been removed from largs).
        #
        # The while loop will usually consume 1 or more arguments per pass.
        # If it consumes 1 (eg. arg is an option that takes no arguments),
        # then after _process_arg() is done the situation is:
        #
        #   largs = subset of [arg0, ..., arg(i)]
        #   rargs = [arg(i+1), ..., arg(N-1)]
        #
        # If allow_interspersed_args is false, largs will always be
        # *empty* -- still a subset of [arg0, ..., arg(i-1)], but
        # not a very interesting subset!

 #ef _match_long_opt(
 #elf, opt: str, explicit_value: str | None, state: _ParsingState
 # -> None:
 #f opt not in self._long_opt:
 #rom difflib import get_close_matches

 #ossibilities = get_close_matches(opt, self._long_opt)
 #aise NoSuchOption(opt, possibilities=possibilities, ctx=self.ctx)

 #ption = self._long_opt[opt]
 #f option.takes_value:
            # At this point it's safe to modify rargs by injecting the
            # explicit value, because no exception is raised in this
            # branch.  This means that the inserted value will be fully
            # consumed.
 #f explicit_value is not None:
 #tate.rargs.insert(0, explicit_value)

 #alue = self._get_value_from_state(opt, option, state)

 #lif explicit_value is not None:
 #aise BadOptionUsage(
 #pt, _("Option {name!r} does not take a value.").format(name=opt)
 #

 #lse:
 #alue = UNSET

 #ption.process(value, state)

 #ef _match_short_opt(self, arg: str, state: _ParsingState) -> None:
 #top = False
 # = 1
 #refix = arg[0]
 #nknown_options = []

 #or ch in arg[1:]:
 #pt = _normalize_opt(f"{prefix}{ch}", self.ctx)
 #ption = self._short_opt.get(opt)
 # += 1

 #f not option:
 #f self.ignore_unknown_options:
 #nknown_options.append(ch)
 #ontinue
 #aise NoSuchOption(opt, ctx=self.ctx)
 #f option.takes_value:
                # Any characters left in arg?  Pretend they're the
                # next arg, and stop consuming characters of arg.
 #f i < len(arg):
 #tate.rargs.insert(0, arg[i:])
 #top = True

 #alue = self._get_value_from_state(opt, option, state)

 #lse:
 #alue = UNSET

 #ption.process(value, state)

 #f stop:
 #reak

        # If we got any unknown options we recombine the string of the
        # remaining options and re-attach the prefix, then report that
        # to the state as new larg.  This way there is basic combinatorics
        # that can be achieved while still ignoring unknown arguments.
 #f self.ignore_unknown_options and unknown_options:
 #tate.largs.append(f"{prefix}{''.join(unknown_options)}")

 #ef _get_value_from_state(
 #elf, option_name: str, option: _Option, state: _ParsingState
 # -> str | cabc.Sequence[str] | T_FLAG_NEEDS_VALUE:
 #args = option.nargs

 #alue: str | cabc.Sequence[str] | T_FLAG_NEEDS_VALUE

 #f len(state.rargs) < nargs:
 #f option.obj._flag_needs_value:
                # Option allows omitting the value.
 #alue = FLAG_NEEDS_VALUE
 #lse:
 #aise BadOptionUsage(
 #ption_name,
 #gettext(
 #Option {name!r} requires an argument.",
 #Option {name!r} requires {nargs} arguments.",
 #args,
 #.format(name=option_name, nargs=nargs),
 #
 #lif nargs == 1:
 #ext_rarg = state.rargs[0]

 #f (
 #ption.obj._flag_needs_value
 #nd isinstance(next_rarg, str)
 #nd next_rarg[:1] in self._opt_prefixes
 #nd len(next_rarg) > 1
 #:
                # The next arg looks like the start of an option, don't
                # use it as the value if omitting the value is allowed.
 #alue = FLAG_NEEDS_VALUE
 #lse:
 #alue = state.rargs.pop(0)
 #lse:
 #alue = tuple(state.rargs[:nargs])
 #el state.rargs[:nargs]

 #eturn value

 #ef _process_opts(self, arg: str, state: _ParsingState) -> None:
 #xplicit_value = None
        # Long option handling happens in two parts.  The first part is
        # supporting explicitly attached values.  In any case, we will try
        # to long match the option first.
 #f "=" in arg:
 #ong_opt, explicit_value = arg.split("=", 1)
 #lse:
 #ong_opt = arg
 #orm_long_opt = _normalize_opt(long_opt, self.ctx)

        # At this point we will match the (assumed) long option through
        # the long option matching code.  Note that this allows options
        # like "-foo" to be matched as long options.
 #ry:
 #elf._match_long_opt(norm_long_opt, explicit_value, state)
 #xcept NoSuchOption:
            # At this point the long option matching failed, and we need
            # to try with short options.  However there is a special rule
            # which says, that if we have a two character options prefix
            # (applies to "--foo" for instance), we do not dispatch to the
            # short option code and will instead raise the no option
            # error.
 #f arg[:2] not in self._opt_prefixes:
 #elf._match_short_opt(arg, state)
 #eturn

 #f not self.ignore_unknown_options:
 #aise

 #tate.largs.append(arg)


def __getattr__(name: str) -> object:
 #mport warnings

 #f name in {
 #OptionParser",
 #Argument",
 #Option",
 #split_opt",
 #normalize_opt",
 #ParsingState",
 #:
 #arnings.warn(
 #"'parser.{name}' is deprecated and will be removed in Click 9.0."
 # The old parser is available in 'optparse'.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn globals()[f"_{name}"]

 #f name == "split_arg_string":
 #rom .shell_completion import split_arg_string

 #arnings.warn(
 #Importing 'parser.split_arg_string' is deprecated, it will only be"
 # available in 'shell_completion' in Click 9.0.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn split_arg_string

 #aise AttributeError(name)
