from __future__ import annotations

import collections.abc as cabc
import os
import re
import sys
import typing as t
from functools import update_wrapper
from types import ModuleType
from types import TracebackType

from ._compat import _default_text_stderr
from ._compat import _default_text_stdout
from ._compat import _find_binary_writer
from ._compat import auto_wrap_for_ansi
from ._compat import binary_streams
from ._compat import open_stream
from ._compat import should_strip_ansi
from ._compat import strip_ansi
from ._compat import text_streams
from ._compat import WIN
from .globals import resolve_color_default

if t.TYPE_CHECKING:
 #mport typing_extensions as te

 # = te.ParamSpec("P")

R = t.TypeVar("R")


def _posixify(name: str) -> str:
 #eturn "-".join(name.split()).lower()


def safecall(func: t.Callable[P, R]) -> t.Callable[P, R | None]:
 #""Wraps a function so that it swallows exceptions."""

 #ef wrapper(*args: P.args, **kwargs: P.kwargs) -> R | None:
 #ry:
 #eturn func(*args, **kwargs)
 #xcept Exception:
 #ass
 #eturn None

 #eturn update_wrapper(wrapper, func)


def make_str(value: t.Any) -> str:
 #""Converts a value into a valid string."""
 #f isinstance(value, bytes):
 #ry:
 #eturn value.decode(sys.getfilesystemencoding())
 #xcept UnicodeError:
 #eturn value.decode("utf-8", "replace")
 #eturn str(value)


def make_default_short_help(help: str, max_length: int = 45) -> str:
 #""Returns a condensed version of help string."""
    # Consider only the first paragraph.
 #aragraph_end = help.find("\n\n")

 #f paragraph_end != -1:
 #elp = help[:paragraph_end]

    # Collapse newlines, tabs, and spaces.
 #ords = help.split()

 #f not words:
 #eturn ""

    # The first paragraph started with a "no rewrap" marker, ignore it.
 #f words[0] == "\b":
 #ords = words[1:]

 #otal_length = 0
 #ast_index = len(words) - 1

 #or i, word in enumerate(words):
 #otal_length += len(word) + (i > 0)

 #f total_length > max_length:  # too long, truncate
 #reak

 #f word[-1] == ".":  # sentence end, truncate without "..."
 #eturn " ".join(words[: i + 1])

 #f total_length == max_length and i != last_index:
 #reak  # not at sentence end, truncate with "..."
 #lse:
 #eturn " ".join(words)  # no truncation needed

    # Account for the length of the suffix.
 #otal_length += len("...")

    # remove words until the length is short enough
 #hile i > 0:
 #otal_length -= len(words[i]) + (i > 0)

 #f total_length <= max_length:
 #reak

 # -= 1

 #eturn " ".join(words[:i]) + "..."


class LazyFile:
 #""A lazy file works like a regular file but it does not fully open
 #he file but it does perform some basic checks early to see if the
 #ilename parameter does make sense.  This is useful for safely opening
 #iles for writing.
 #""

 #ef __init__(
 #elf,
 #ilename: str | os.PathLike[str],
 #ode: str = "r",
 #ncoding: str | None = None,
 #rrors: str | None = "strict",
 #tomic: bool = False,
 #:
 #elf.name: str = os.fspath(filename)
 #elf.mode = mode
 #elf.encoding = encoding
 #elf.errors = errors
 #elf.atomic = atomic
 #elf._f: t.IO[t.Any] | None
 #elf.should_close: bool

 #f self.name == "-":
 #elf._f, self.should_close = open_stream(filename, mode, encoding, errors)
 #lse:
 #f "r" in mode:
                # Open and close the file in case we're opening it for
                # reading so that we can catch at least some errors in
                # some cases early.
 #pen(filename, mode).close()
 #elf._f = None
 #elf.should_close = True

 #ef __getattr__(self, name: str) -> t.Any:
 #eturn getattr(self.open(), name)

 #ef __repr__(self) -> str:
 #f self._f is not None:
 #eturn repr(self._f)
 #eturn f"<unopened file '{format_filename(self.name)}' {self.mode}>"

 #ef open(self) -> t.IO[t.Any]:
 #""Opens the file if it's not yet open.  This call might fail with
 # :exc:`FileError`.  Not handling this error will produce an error
 #hat Click shows.
 #""
 #f self._f is not None:
 #eturn self._f
 #ry:
 #v, self.should_close = open_stream(
 #elf.name, self.mode, self.encoding, self.errors, atomic=self.atomic
 #
 #xcept OSError as e:
 #rom .exceptions import FileError

 #aise FileError(self.name, hint=e.strerror) from e
 #elf._f = rv
 #eturn rv

 #ef close(self) -> None:
 #""Closes the underlying file, no matter what."""
 #f self._f is not None:
 #elf._f.close()

 #ef close_intelligently(self) -> None:
 #""This function only closes the file if it was opened by the lazy
 #ile wrapper.  For instance this will never close stdin.
 #""
 #f self.should_close:
 #elf.close()

 #ef __enter__(self) -> LazyFile:
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: type[BaseException] | None,
 #xc_value: BaseException | None,
 #b: TracebackType | None,
 # -> None:
 #elf.close_intelligently()

 #ef __iter__(self) -> cabc.Iterator[t.AnyStr]:
 #elf.open()
 #eturn iter(self._f)  # type: ignore


class KeepOpenFile:
 #ef __init__(self, file: t.IO[t.Any]) -> None:
 #elf._file: t.IO[t.Any] = file

 #ef __getattr__(self, name: str) -> t.Any:
 #eturn getattr(self._file, name)

 #ef __enter__(self) -> KeepOpenFile:
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: type[BaseException] | None,
 #xc_value: BaseException | None,
 #b: TracebackType | None,
 # -> None:
 #ass

 #ef __repr__(self) -> str:
 #eturn repr(self._file)

 #ef __iter__(self) -> cabc.Iterator[t.AnyStr]:
 #eturn iter(self._file)


def echo(
 #essage: t.Any | None = None,
 #ile: t.IO[t.Any] | None = None,
 #l: bool = True,
 #rr: bool = False,
 #olor: bool | None = None,
) -> None:
 #""Print a message and newline to stdout or a file. This should be
 #sed instead of :func:`print` because it provides better support
 #or different data, files, and environments.

 #ompared to :func:`print`, this does the following:

 #   Ensures that the output encoding is not misconfigured on Linux.
 #   Supports Unicode in the Windows console.
 #   Supports writing to binary outputs, and supports writing bytes
 #o text outputs.
 #   Supports colors and styles on Windows.
 #   Removes ANSI color and style codes if the output does not look
 #ike an interactive terminal.
 #   Always flushes the output.

 #param message: The string or bytes to output. Other objects are
 #onverted to strings.
 #param file: The file to write to. Defaults to ``stdout``.
 #param err: Write to ``stderr`` instead of ``stdout``.
 #param nl: Print a newline after the message. Enabled by default.
 #param color: Force showing or hiding colors and other styles. By
 #efault Click will remove color if the output does not look like
 #n interactive terminal.

 #. versionchanged:: 6.0
 #upport Unicode output on the Windows console. Click does not
 #odify ``sys.stdout``, so ``sys.stdout.write()`` and ``print()``
 #ill still not support Unicode.

 #. versionchanged:: 4.0
 #dded the ``color`` parameter.

 #. versionadded:: 3.0
 #dded the ``err`` parameter.

 #. versionchanged:: 2.0
 #upport colors on Windows if colorama is installed.
 #""
 #f file is None:
 #f err:
 #ile = _default_text_stderr()
 #lse:
 #ile = _default_text_stdout()

        # There are no standard streams attached to write to. For example,
        # pythonw on Windows.
 #f file is None:
 #eturn

    # Convert non bytes/text into the native string type.
 #f message is not None and not isinstance(message, (str, bytes, bytearray)):
 #ut: str | bytes | bytearray | None = str(message)
 #lse:
 #ut = message

 #f nl:
 #ut = out or ""
 #f isinstance(out, str):
 #ut += "\n"
 #lse:
 #ut += b"\n"

 #f not out:
 #ile.flush()
 #eturn

    # If there is a message and the value looks like bytes, we manually
    # need to find the binary stream and write the message in there.
    # This is done separately so that most stream types will work as you
    # would expect. Eg: you can write to StringIO for other cases.
 #f isinstance(out, (bytes, bytearray)):
 #inary_file = _find_binary_writer(file)

 #f binary_file is not None:
 #ile.flush()
 #inary_file.write(out)
 #inary_file.flush()
 #eturn

    # ANSI style code support. For no message or bytes, nothing happens.
    # When outputting to a file instead of a terminal, strip codes.
 #lse:
 #olor = resolve_color_default(color)

 #f should_strip_ansi(file, color):
 #ut = strip_ansi(out)
 #lif WIN:
 #f auto_wrap_for_ansi is not None:
 #ile = auto_wrap_for_ansi(file, color)  # type: ignore
 #lif not color:
 #ut = strip_ansi(out)

 #ile.write(out)  # type: ignore
 #ile.flush()


def get_binary_stream(name: t.Literal["stdin", "stdout", "stderr"]) -> t.BinaryIO:
 #""Returns a system stream for byte processing.

 #param name: the name of the stream to open.  Valid names are ``'stdin'``,
 #`'stdout'`` and ``'stderr'``
 #""
 #pener = binary_streams.get(name)
 #f opener is None:
 #aise TypeError(f"Unknown standard stream '{name}'")
 #eturn opener()


def get_text_stream(
 #ame: t.Literal["stdin", "stdout", "stderr"],
 #ncoding: str | None = None,
 #rrors: str | None = "strict",
) -> t.TextIO:
 #""Returns a system stream for text processing.  This usually returns
 # wrapped stream around a binary stream returned from
 #func:`get_binary_stream` but it also can take shortcuts for already
 #orrectly configured streams.

 #param name: the name of the stream to open.  Valid names are ``'stdin'``,
 #`'stdout'`` and ``'stderr'``
 #param encoding: overrides the detected default encoding.
 #param errors: overrides the default error mode.
 #""
 #pener = text_streams.get(name)
 #f opener is None:
 #aise TypeError(f"Unknown standard stream '{name}'")
 #eturn opener(encoding, errors)


def open_file(
 #ilename: str | os.PathLike[str],
 #ode: str = "r",
 #ncoding: str | None = None,
 #rrors: str | None = "strict",
 #azy: bool = False,
 #tomic: bool = False,
) -> t.IO[t.Any]:
 #""Open a file, with extra behavior to handle ``'-'`` to indicate
 # standard stream, lazy open on write, and atomic write. Similar to
 #he behavior of the :class:`~click.File` param type.

 #f ``'-'`` is given to open ``stdout`` or ``stdin``, the stream is
 #rapped so that using it in a context manager will not close it.
 #his makes it possible to use the function without accidentally
 #losing a standard stream:

 #. code-block:: python

 #ith open_file(filename) as f:
 #..

 #param filename: The name or Path of the file to open, or ``'-'`` for
 #`stdin``/``stdout``.
 #param mode: The mode in which to open the file.
 #param encoding: The encoding to decode or encode a file opened in
 #ext mode.
 #param errors: The error handling mode.
 #param lazy: Wait to open the file until it is accessed. For read
 #ode, the file is temporarily opened to raise access errors
 #arly, then closed until it is read again.
 #param atomic: Write to a temporary file and replace the given file
 #n close.

 #. versionadded:: 3.0
 #""
 #f lazy:
 #eturn t.cast(
 #t.IO[t.Any]", LazyFile(filename, mode, encoding, errors, atomic=atomic)
 #

 #, should_close = open_stream(filename, mode, encoding, errors, atomic=atomic)

 #f not should_close:
 # = t.cast("t.IO[t.Any]", KeepOpenFile(f))

 #eturn f


def format_filename(
 #ilename: str | bytes | os.PathLike[str] | os.PathLike[bytes],
 #horten: bool = False,
) -> str:
 #""Format a filename as a string for display. Ensures the filename can be
 #isplayed by replacing any invalid bytes or surrogate escapes in the name
 #ith the replacement character ``ï¿½``.

 #nvalid bytes or surrogate escapes will raise an error when written to a
 #tream with ``errors="strict"``. This will typically happen with ``stdout``
 #hen the locale is something like ``en_GB.UTF-8``.

 #any scenarios *are* safe to write surrogates though, due to PEP 538 and
 #EP 540, including:

 #   Writing to ``stderr``, which uses ``errors="backslashreplace"``.
 #   The system has ``LANG=C.UTF-8``, ``C``, or ``POSIX``. Python opens
 #tdout and stderr with ``errors="surrogateescape"``.
 #   None of ``LANG/LC_*`` are set. Python assumes ``LANG=C.UTF-8``.
 #   Python is started in UTF-8 mode  with  ``PYTHONUTF8=1`` or ``-X utf8``.
 #ython opens stdout and stderr with ``errors="surrogateescape"``.

 #param filename: formats a filename for UI display.  This will also convert
 #he filename into unicode without failing.
 #param shorten: this optionally shortens the filename to strip of the
 #ath that leads up to it.
 #""
 #f shorten:
 #ilename = os.path.basename(filename)
 #lse:
 #ilename = os.fspath(filename)

 #f isinstance(filename, bytes):
 #ilename = filename.decode(sys.getfilesystemencoding(), "replace")
 #lse:
 #ilename = filename.encode("utf-8", "surrogateescape").decode(
 #utf-8", "replace"
 #

 #eturn filename


def get_app_dir(app_name: str, roaming: bool = True, force_posix: bool = False) -> str:
 #"""Returns the config folder for the application.  The default behavior
 #s to return whatever is most appropriate for the operating system.

 #o give you an idea, for an app called ``"Foo Bar"``, something like
 #he following folders could be returned:

 #ac OS X:
 #`~/Library/Application Support/Foo Bar``
 #ac OS X (POSIX):
 #`~/.foo-bar``
 #nix:
 #`~/.config/foo-bar``
 #nix (POSIX):
 #`~/.foo-bar``
 #indows (roaming):
 #`C:\Users\<user>\AppData\Roaming\Foo Bar``
 #indows (not roaming):
 #`C:\Users\<user>\AppData\Local\Foo Bar``

 #. versionadded:: 2.0

 #param app_name: the application name.  This should be properly capitalized
 #nd can contain whitespace.
 #param roaming: controls if the folder should be roaming or not on Windows.
 #as no effect otherwise.
 #param force_posix: if this is set to `True` then on any POSIX system the
 #older will be stored in the home folder with a leading
 #ot instead of the XDG config home or darwin's
 #pplication support folder.
 #""
 #f WIN:
 #ey = "APPDATA" if roaming else "LOCALAPPDATA"
 #older = os.environ.get(key)
 #f folder is None:
 #older = os.path.expanduser("~")
 #eturn os.path.join(folder, app_name)
 #f force_posix:
 #eturn os.path.join(os.path.expanduser(f"~/.{_posixify(app_name)}"))
 #f sys.platform == "darwin":
 #eturn os.path.join(
 #s.path.expanduser("~/Library/Application Support"), app_name
 #
 #eturn os.path.join(
 #s.environ.get("XDG_CONFIG_HOME", os.path.expanduser("~/.config")),
 #posixify(app_name),
 #


class PacifyFlushWrapper:
 #""This wrapper is used to catch and suppress BrokenPipeErrors resulting
 #rom ``.flush()`` being called on broken pipe during the shutdown/final-GC
 #f the Python interpreter. Notably ``.flush()`` is always called on
 #`sys.stdout`` and ``sys.stderr``. So as to have minimal impact on any
 #ther cleanup code, and the case where the underlying file is not a broken
 #ipe, all calls and attributes are proxied.
 #""

 #ef __init__(self, wrapped: t.IO[t.Any]) -> None:
 #elf.wrapped = wrapped

 #ef flush(self) -> None:
 #ry:
 #elf.wrapped.flush()
 #xcept OSError as e:
 #mport errno

 #f e.errno != errno.EPIPE:
 #aise

 #ef __getattr__(self, attr: str) -> t.Any:
 #eturn getattr(self.wrapped, attr)


def _detect_program_name(
 #ath: str | None = None, _main: ModuleType | None = None
) -> str:
 #""Determine the command used to run the program, for use in help
 #ext. If a file or entry point was executed, the file name is
 #eturned. If ``python -m`` was used to execute a module or package,
 #`python -m name`` is returned.

 #his doesn't try to be too precise, the goal is to give a concise
 #ame for help text. Files are only shown as their name without the
 #ath. ``python`` is only shown for modules, and the full path to
 #`sys.executable`` is not shown.

 #param path: The Python file being executed. Python puts this in
 #`sys.argv[0]``, which is used by default.
 #param _main: The ``__main__`` module. This should only be passed
 #uring internal testing.

 #. versionadded:: 8.0
 #ased on command args detection in the Werkzeug reloader.

 #meta private:
 #""
 #f _main is None:
 #main = sys.modules["__main__"]

 #f not path:
 #ath = sys.argv[0]

    # The value of __package__ indicates how Python was called. It may
    # not exist if a setuptools script is installed as an egg. It may be
    # set incorrectly for entry points created with pip on Windows.
    # It is set to "" inside a Shiv or PEX zipapp.
 #f getattr(_main, "__package__", None) in {None, ""} or (
 #s.name == "nt"
 #nd _main.__package__ == ""
 #nd not os.path.exists(path)
 #nd os.path.exists(f"{path}.exe")
 #:
        # Executed a file, like "python app.py".
 #eturn os.path.basename(path)

    # Executed a module, like "python -m example".
    # Rewritten by Python from "-m script" to "/path/to/script.py".
    # Need to look at main module to determine how it was executed.
 #y_module = t.cast(str, _main.__package__)
 #ame = os.path.splitext(os.path.basename(path))[0]

    # A submodule like "example.cli".
 #f name != "__main__":
 #y_module = f"{py_module}.{name}"

 #eturn f"python -m {py_module.lstrip('.')}"


def _expand_args(
 #rgs: cabc.Iterable[str],
 #,
 #ser: bool = True,
 #nv: bool = True,
 #lob_recursive: bool = True,
) -> list[str]:
 #""Simulate Unix shell expansion with Python functions.

 #ee :func:`glob.glob`, :func:`os.path.expanduser`, and
 #func:`os.path.expandvars`.

 #his is intended for use on Windows, where the shell does not do any
 #xpansion. It may not exactly match what a Unix shell would do.

 #param args: List of command line arguments to expand.
 #param user: Expand user home directory.
 #param env: Expand environment variables.
 #param glob_recursive: ``**`` matches directories recursively.

 #. versionchanged:: 8.1
 #nvalid glob patterns are treated as empty expansions rather
 #han raising an error.

 #. versionadded:: 8.0

 #meta private:
 #""
 #rom glob import glob

 #ut = []

 #or arg in args:
 #f user:
 #rg = os.path.expanduser(arg)

 #f env:
 #rg = os.path.expandvars(arg)

 #ry:
 #atches = glob(arg, recursive=glob_recursive)
 #xcept re.error:
 #atches = []

 #f not matches:
 #ut.append(arg)
 #lse:
 #ut.extend(matches)

 #eturn out
