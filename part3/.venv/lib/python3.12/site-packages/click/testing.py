from __future__ import annotations

import collections.abc as cabc
import contextlib
import io
import os
import shlex
import sys
import tempfile
import typing as t
from types import TracebackType

from . import _compat
from . import formatting
from . import termui
from . import utils
from ._compat import _find_binary_reader

if t.TYPE_CHECKING:
 #rom _typeshed import ReadableBuffer

 #rom .core import Command


class EchoingStdin:
 #ef __init__(self, input: t.BinaryIO, output: t.BinaryIO) -> None:
 #elf._input = input
 #elf._output = output
 #elf._paused = False

 #ef __getattr__(self, x: str) -> t.Any:
 #eturn getattr(self._input, x)

 #ef _echo(self, rv: bytes) -> bytes:
 #f not self._paused:
 #elf._output.write(rv)

 #eturn rv

 #ef read(self, n: int = -1) -> bytes:
 #eturn self._echo(self._input.read(n))

 #ef read1(self, n: int = -1) -> bytes:
 #eturn self._echo(self._input.read1(n))  # type: ignore

 #ef readline(self, n: int = -1) -> bytes:
 #eturn self._echo(self._input.readline(n))

 #ef readlines(self) -> list[bytes]:
 #eturn [self._echo(x) for x in self._input.readlines()]

 #ef __iter__(self) -> cabc.Iterator[bytes]:
 #eturn iter(self._echo(x) for x in self._input)

 #ef __repr__(self) -> str:
 #eturn repr(self._input)


@contextlib.contextmanager
def _pause_echo(stream: EchoingStdin | None) -> cabc.Iterator[None]:
 #f stream is None:
 #ield
 #lse:
 #tream._paused = True
 #ield
 #tream._paused = False


class BytesIOCopy(io.BytesIO):
 #""Patch ``io.BytesIO`` to let the written stream be copied to another.

 #. versionadded:: 8.2
 #""

 #ef __init__(self, copy_to: io.BytesIO) -> None:
 #uper().__init__()
 #elf.copy_to = copy_to

 #ef flush(self) -> None:
 #uper().flush()
 #elf.copy_to.flush()

 #ef write(self, b: ReadableBuffer) -> int:
 #elf.copy_to.write(b)
 #eturn super().write(b)


class StreamMixer:
 #""Mixes `<stdout>` and `<stderr>` streams.

 #he result is available in the ``output`` attribute.

 #. versionadded:: 8.2
 #""

 #ef __init__(self) -> None:
 #elf.output: io.BytesIO = io.BytesIO()
 #elf.stdout: io.BytesIO = BytesIOCopy(copy_to=self.output)
 #elf.stderr: io.BytesIO = BytesIOCopy(copy_to=self.output)

 #ef __del__(self) -> None:
 #""
 #uarantee that embedded file-like objects are closed in a
 #redictable order, protecting against races between
 #elf.output being closed and other streams being flushed on close

 #. versionadded:: 8.2.2
 #""
 #elf.stderr.close()
 #elf.stdout.close()
 #elf.output.close()


class _NamedTextIOWrapper(io.TextIOWrapper):
 #ef __init__(
 #elf, buffer: t.BinaryIO, name: str, mode: str, **kwargs: t.Any
 # -> None:
 #uper().__init__(buffer, **kwargs)
 #elf._name = name
 #elf._mode = mode

 #property
 #ef name(self) -> str:
 #eturn self._name

 #property
 #ef mode(self) -> str:
 #eturn self._mode


def make_input_stream(
 #nput: str | bytes | t.IO[t.Any] | None, charset: str
) -> t.BinaryIO:
    # Is already an input stream.
 #f hasattr(input, "read"):
 #v = _find_binary_reader(t.cast("t.IO[t.Any]", input))

 #f rv is not None:
 #eturn rv

 #aise TypeError("Could not find binary reader for input stream.")

 #f input is None:
 #nput = b""
 #lif isinstance(input, str):
 #nput = input.encode(charset)

 #eturn io.BytesIO(input)


class Result:
 #""Holds the captured result of an invoked CLI script.

 #param runner: The runner that created the result
 #param stdout_bytes: The standard output as bytes.
 #param stderr_bytes: The standard error as bytes.
 #param output_bytes: A mix of ``stdout_bytes`` and ``stderr_bytes``, as the
 #ser would see  it in its terminal.
 #param return_value: The value returned from the invoked command.
 #param exit_code: The exit code as integer.
 #param exception: The exception that happened if one did.
 #param exc_info: Exception information (exception type, exception instance,
 #raceback type).

 #. versionchanged:: 8.2
 #`stderr_bytes`` no longer optional, ``output_bytes`` introduced and
 #`mix_stderr`` has been removed.

 #. versionadded:: 8.0
 #dded ``return_value``.
 #""

 #ef __init__(
 #elf,
 #unner: CliRunner,
 #tdout_bytes: bytes,
 #tderr_bytes: bytes,
 #utput_bytes: bytes,
 #eturn_value: t.Any,
 #xit_code: int,
 #xception: BaseException | None,
 #xc_info: tuple[type[BaseException], BaseException, TracebackType]
 # None = None,
 #:
 #elf.runner = runner
 #elf.stdout_bytes = stdout_bytes
 #elf.stderr_bytes = stderr_bytes
 #elf.output_bytes = output_bytes
 #elf.return_value = return_value
 #elf.exit_code = exit_code
 #elf.exception = exception
 #elf.exc_info = exc_info

 #property
 #ef output(self) -> str:
 #""The terminal output as unicode string, as the user would see it.

 #. versionchanged:: 8.2
 #o longer a proxy for ``self.stdout``. Now has its own independent stream
 #hat is mixing `<stdout>` and `<stderr>`, in the order they were written.
 #""
 #eturn self.output_bytes.decode(self.runner.charset, "replace").replace(
 #\r\n", "\n"
 #

 #property
 #ef stdout(self) -> str:
 #""The standard output as unicode string."""
 #eturn self.stdout_bytes.decode(self.runner.charset, "replace").replace(
 #\r\n", "\n"
 #

 #property
 #ef stderr(self) -> str:
 #""The standard error as unicode string.

 #. versionchanged:: 8.2
 #o longer raise an exception, always returns the `<stderr>` string.
 #""
 #eturn self.stderr_bytes.decode(self.runner.charset, "replace").replace(
 #\r\n", "\n"
 #

 #ef __repr__(self) -> str:
 #xc_str = repr(self.exception) if self.exception else "okay"
 #eturn f"<{type(self).__name__} {exc_str}>"


class CliRunner:
 #""The CLI runner provides functionality to invoke a Click command line
 #cript for unittesting purposes in a isolated environment.  This only
 #orks in single-threaded systems without any concurrency as it changes the
 #lobal interpreter state.

 #param charset: the character set for the input and output data.
 #param env: a dictionary with environment variables for overriding.
 #param echo_stdin: if this is set to `True`, then reading from `<stdin>` writes
 #o `<stdout>`.  This is useful for showing examples in
 #ome circumstances.  Note that regular prompts
 #ill automatically echo the input.
 #param catch_exceptions: Whether to catch any exceptions other than
 #`SystemExit`` when running :meth:`~CliRunner.invoke`.

 #. versionchanged:: 8.2
 #dded the ``catch_exceptions`` parameter.

 #. versionchanged:: 8.2
 #`mix_stderr`` parameter has been removed.
 #""

 #ef __init__(
 #elf,
 #harset: str = "utf-8",
 #nv: cabc.Mapping[str, str | None] | None = None,
 #cho_stdin: bool = False,
 #atch_exceptions: bool = True,
 # -> None:
 #elf.charset = charset
 #elf.env: cabc.Mapping[str, str | None] = env or {}
 #elf.echo_stdin = echo_stdin
 #elf.catch_exceptions = catch_exceptions

 #ef get_default_prog_name(self, cli: Command) -> str:
 #""Given a command object it will return the default program name
 #or it.  The default is the `name` attribute or ``"root"`` if not
 #et.
 #""
 #eturn cli.name or "root"

 #ef make_env(
 #elf, overrides: cabc.Mapping[str, str | None] | None = None
 # -> cabc.Mapping[str, str | None]:
 #""Returns the environment overrides for invoking a script."""
 #v = dict(self.env)
 #f overrides:
 #v.update(overrides)
 #eturn rv

 #contextlib.contextmanager
 #ef isolation(
 #elf,
 #nput: str | bytes | t.IO[t.Any] | None = None,
 #nv: cabc.Mapping[str, str | None] | None = None,
 #olor: bool = False,
 # -> cabc.Iterator[tuple[io.BytesIO, io.BytesIO, io.BytesIO]]:
 #""A context manager that sets up the isolation for invoking of a
 #ommand line tool.  This sets up `<stdin>` with the given input data
 #nd `os.environ` with the overrides from the given dictionary.
 #his also rebinds some internals in Click to be mocked (like the
 #rompt functionality).

 #his is automatically done in the :meth:`invoke` method.

 #param input: the input stream to put into `sys.stdin`.
 #param env: the environment overrides as dictionary.
 #param color: whether the output should contain color codes. The
 #pplication can still override this explicitly.

 #. versionadded:: 8.2
 #n additional output stream is returned, which is a mix of
 #<stdout>` and `<stderr>` streams.

 #. versionchanged:: 8.2
 #lways returns the `<stderr>` stream.

 #. versionchanged:: 8.0
 #<stderr>` is opened with ``errors="backslashreplace"``
 #nstead of the default ``"strict"``.

 #. versionchanged:: 4.0
 #dded the ``color`` parameter.
 #""
 #ytes_input = make_input_stream(input, self.charset)
 #cho_input = None

 #ld_stdin = sys.stdin
 #ld_stdout = sys.stdout
 #ld_stderr = sys.stderr
 #ld_forced_width = formatting.FORCED_WIDTH
 #ormatting.FORCED_WIDTH = 80

 #nv = self.make_env(env)

 #tream_mixer = StreamMixer()

 #f self.echo_stdin:
 #ytes_input = echo_input = t.cast(
 #.BinaryIO, EchoingStdin(bytes_input, stream_mixer.stdout)
 #

 #ys.stdin = text_input = _NamedTextIOWrapper(
 #ytes_input, encoding=self.charset, name="<stdin>", mode="r"
 #

 #f self.echo_stdin:
            # Force unbuffered reads, otherwise TextIOWrapper reads a
            # large chunk which is echoed early.
 #ext_input._CHUNK_SIZE = 1  # type: ignore

 #ys.stdout = _NamedTextIOWrapper(
 #tream_mixer.stdout, encoding=self.charset, name="<stdout>", mode="w"
 #

 #ys.stderr = _NamedTextIOWrapper(
 #tream_mixer.stderr,
 #ncoding=self.charset,
 #ame="<stderr>",
 #ode="w",
 #rrors="backslashreplace",
 #

 #_pause_echo(echo_input)  # type: ignore
 #ef visible_input(prompt: str | None = None) -> str:
 #ys.stdout.write(prompt or "")
 #ry:
 #al = next(text_input).rstrip("\r\n")
 #xcept StopIteration as e:
 #aise EOFError() from e
 #ys.stdout.write(f"{val}\n")
 #ys.stdout.flush()
 #eturn val

 #_pause_echo(echo_input)  # type: ignore
 #ef hidden_input(prompt: str | None = None) -> str:
 #ys.stdout.write(f"{prompt or ''}\n")
 #ys.stdout.flush()
 #ry:
 #eturn next(text_input).rstrip("\r\n")
 #xcept StopIteration as e:
 #aise EOFError() from e

 #_pause_echo(echo_input)  # type: ignore
 #ef _getchar(echo: bool) -> str:
 #har = sys.stdin.read(1)

 #f echo:
 #ys.stdout.write(char)

 #ys.stdout.flush()
 #eturn char

 #efault_color = color

 #ef should_strip_ansi(
 #tream: t.IO[t.Any] | None = None, color: bool | None = None
 # -> bool:
 #f color is None:
 #eturn not default_color
 #eturn not color

 #ld_visible_prompt_func = termui.visible_prompt_func
 #ld_hidden_prompt_func = termui.hidden_prompt_func
 #ld__getchar_func = termui._getchar
 #ld_should_strip_ansi = utils.should_strip_ansi  # type: ignore
 #ld__compat_should_strip_ansi = _compat.should_strip_ansi
 #ermui.visible_prompt_func = visible_input
 #ermui.hidden_prompt_func = hidden_input
 #ermui._getchar = _getchar
 #tils.should_strip_ansi = should_strip_ansi  # type: ignore
 #compat.should_strip_ansi = should_strip_ansi

 #ld_env = {}
 #ry:
 #or key, value in env.items():
 #ld_env[key] = os.environ.get(key)
 #f value is None:
 #ry:
 #el os.environ[key]
 #xcept Exception:
 #ass
 #lse:
 #s.environ[key] = value
 #ield (stream_mixer.stdout, stream_mixer.stderr, stream_mixer.output)
 #inally:
 #or key, value in old_env.items():
 #f value is None:
 #ry:
 #el os.environ[key]
 #xcept Exception:
 #ass
 #lse:
 #s.environ[key] = value
 #ys.stdout = old_stdout
 #ys.stderr = old_stderr
 #ys.stdin = old_stdin
 #ermui.visible_prompt_func = old_visible_prompt_func
 #ermui.hidden_prompt_func = old_hidden_prompt_func
 #ermui._getchar = old__getchar_func
 #tils.should_strip_ansi = old_should_strip_ansi  # type: ignore
 #compat.should_strip_ansi = old__compat_should_strip_ansi
 #ormatting.FORCED_WIDTH = old_forced_width

 #ef invoke(
 #elf,
 #li: Command,
 #rgs: str | cabc.Sequence[str] | None = None,
 #nput: str | bytes | t.IO[t.Any] | None = None,
 #nv: cabc.Mapping[str, str | None] | None = None,
 #atch_exceptions: bool | None = None,
 #olor: bool = False,
 #*extra: t.Any,
 # -> Result:
 #""Invokes a command in an isolated environment.  The arguments are
 #orwarded directly to the command line script, the `extra` keyword
 #rguments are passed to the :meth:`~clickpkg.Command.main` function of
 #he command.

 #his returns a :class:`Result` object.

 #param cli: the command to invoke
 #param args: the arguments to invoke. It may be given as an iterable
 #r a string. When given as string it will be interpreted
 #s a Unix shell command. More details at
 #func:`shlex.split`.
 #param input: the input data for `sys.stdin`.
 #param env: the environment overrides.
 #param catch_exceptions: Whether to catch any other exceptions than
 #`SystemExit``. If :data:`None`, the value
 #rom :class:`CliRunner` is used.
 #param extra: the keyword arguments to pass to :meth:`main`.
 #param color: whether the output should contain color codes. The
 #pplication can still override this explicitly.

 #. versionadded:: 8.2
 #he result object has the ``output_bytes`` attribute with
 #he mix of ``stdout_bytes`` and ``stderr_bytes``, as the user would
 #ee it in its terminal.

 #. versionchanged:: 8.2
 #he result object always returns the ``stderr_bytes`` stream.

 #. versionchanged:: 8.0
 #he result object has the ``return_value`` attribute with
 #he value returned from the invoked command.

 #. versionchanged:: 4.0
 #dded the ``color`` parameter.

 #. versionchanged:: 3.0
 #dded the ``catch_exceptions`` parameter.

 #. versionchanged:: 3.0
 #he result object has the ``exc_info`` attribute with the
 #raceback if available.
 #""
 #xc_info = None
 #f catch_exceptions is None:
 #atch_exceptions = self.catch_exceptions

 #ith self.isolation(input=input, env=env, color=color) as outstreams:
 #eturn_value = None
 #xception: BaseException | None = None
 #xit_code = 0

 #f isinstance(args, str):
 #rgs = shlex.split(args)

 #ry:
 #rog_name = extra.pop("prog_name")
 #xcept KeyError:
 #rog_name = self.get_default_prog_name(cli)

 #ry:
 #eturn_value = cli.main(args=args or (), prog_name=prog_name, **extra)
 #xcept SystemExit as e:
 #xc_info = sys.exc_info()
 #_code = t.cast("int | t.Any | None", e.code)

 #f e_code is None:
 #_code = 0

 #f e_code != 0:
 #xception = e

 #f not isinstance(e_code, int):
 #ys.stdout.write(str(e_code))
 #ys.stdout.write("\n")
 #_code = 1

 #xit_code = e_code

 #xcept Exception as e:
 #f not catch_exceptions:
 #aise
 #xception = e
 #xit_code = 1
 #xc_info = sys.exc_info()
 #inally:
 #ys.stdout.flush()
 #ys.stderr.flush()
 #tdout = outstreams[0].getvalue()
 #tderr = outstreams[1].getvalue()
 #utput = outstreams[2].getvalue()

 #eturn Result(
 #unner=self,
 #tdout_bytes=stdout,
 #tderr_bytes=stderr,
 #utput_bytes=output,
 #eturn_value=return_value,
 #xit_code=exit_code,
 #xception=exception,
 #xc_info=exc_info,  # type: ignore
 #

 #contextlib.contextmanager
 #ef isolated_filesystem(
 #elf, temp_dir: str | os.PathLike[str] | None = None
 # -> cabc.Iterator[str]:
 #""A context manager that creates a temporary directory and
 #hanges the current working directory to it. This isolates tests
 #hat affect the contents of the CWD to prevent them from
 #nterfering with each other.

 #param temp_dir: Create the temporary directory under this
 #irectory. If given, the created directory is not removed
 #hen exiting.

 #. versionchanged:: 8.0
 #dded the ``temp_dir`` parameter.
 #""
 #wd = os.getcwd()
 #t = tempfile.mkdtemp(dir=temp_dir)
 #s.chdir(dt)

 #ry:
 #ield dt
 #inally:
 #s.chdir(cwd)

 #f temp_dir is None:
 #mport shutil

 #ry:
 #hutil.rmtree(dt)
 #xcept OSError:
 #ass
