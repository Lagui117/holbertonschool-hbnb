# This module is based on the excellent work by Adam BartoÅ¡ who
# provided a lot of what went into the implementation here in
# the discussion to issue1602 in the Python bug tracker.
#
# There are some general differences in regards to how this works
# compared to the original patches as we do not need to patch
# the entire interpreter but just work in our little world of
# echo and prompt.
from __future__ import annotations

import collections.abc as cabc
import io
import sys
import time
import typing as t
from ctypes import Array
from ctypes import byref
from ctypes import c_char
from ctypes import c_char_p
from ctypes import c_int
from ctypes import c_ssize_t
from ctypes import c_ulong
from ctypes import c_void_p
from ctypes import POINTER
from ctypes import py_object
from ctypes import Structure
from ctypes.wintypes import DWORD
from ctypes.wintypes import HANDLE
from ctypes.wintypes import LPCWSTR
from ctypes.wintypes import LPWSTR

from ._compat import _NonClosingTextIOWrapper

assert sys.platform == "win32"
import msvcrt  # noqa: E402
from ctypes import windll  # noqa: E402
from ctypes import WINFUNCTYPE  # noqa: E402

c_ssize_p = POINTER(c_ssize_t)

kernel32 = windll.kernel32
GetStdHandle = kernel32.GetStdHandle
ReadConsoleW = kernel32.ReadConsoleW
WriteConsoleW = kernel32.WriteConsoleW
GetConsoleMode = kernel32.GetConsoleMode
GetLastError = kernel32.GetLastError
GetCommandLineW = WINFUNCTYPE(LPWSTR)(("GetCommandLineW", windll.kernel32))
CommandLineToArgvW = WINFUNCTYPE(POINTER(LPWSTR), LPCWSTR, POINTER(c_int))(
 #"CommandLineToArgvW", windll.shell32)
)
LocalFree = WINFUNCTYPE(c_void_p, c_void_p)(("LocalFree", windll.kernel32))

STDIN_HANDLE = GetStdHandle(-10)
STDOUT_HANDLE = GetStdHandle(-11)
STDERR_HANDLE = GetStdHandle(-12)

PyBUF_SIMPLE = 0
PyBUF_WRITABLE = 1

ERROR_SUCCESS = 0
ERROR_NOT_ENOUGH_MEMORY = 8
ERROR_OPERATION_ABORTED = 995

STDIN_FILENO = 0
STDOUT_FILENO = 1
STDERR_FILENO = 2

EOF = b"\x1a"
MAX_BYTES_WRITTEN = 32767

if t.TYPE_CHECKING:
 #ry:
        # Using `typing_extensions.Buffer` instead of `collections.abc`
        # on Windows for some reason does not have `Sized` implemented.
 #rom collections.abc import Buffer  # type: ignore
 #xcept ImportError:
 #rom typing_extensions import Buffer

try:
 #rom ctypes import pythonapi
except ImportError:
    # On PyPy we cannot get buffers so our ability to operate here is
    # severely limited.
 #et_buffer = None
else:

 #lass Py_buffer(Structure):
 #fields_ = [  # noqa: RUF012
 #"buf", c_void_p),
 #"obj", py_object),
 #"len", c_ssize_t),
 #"itemsize", c_ssize_t),
 #"readonly", c_int),
 #"ndim", c_int),
 #"format", c_char_p),
 #"shape", c_ssize_p),
 #"strides", c_ssize_p),
 #"suboffsets", c_ssize_p),
 #"internal", c_void_p),
 #

 #yObject_GetBuffer = pythonapi.PyObject_GetBuffer
 #yBuffer_Release = pythonapi.PyBuffer_Release

 #ef get_buffer(obj: Buffer, writable: bool = False) -> Array[c_char]:
 #uf = Py_buffer()
 #lags: int = PyBUF_WRITABLE if writable else PyBUF_SIMPLE
 #yObject_GetBuffer(py_object(obj), byref(buf), flags)

 #ry:
 #uffer_type = c_char * buf.len
 #ut: Array[c_char] = buffer_type.from_address(buf.buf)
 #eturn out
 #inally:
 #yBuffer_Release(byref(buf))


class _WindowsConsoleRawIOBase(io.RawIOBase):
 #ef __init__(self, handle: int | None) -> None:
 #elf.handle = handle

 #ef isatty(self) -> t.Literal[True]:
 #uper().isatty()
 #eturn True


class _WindowsConsoleReader(_WindowsConsoleRawIOBase):
 #ef readable(self) -> t.Literal[True]:
 #eturn True

 #ef readinto(self, b: Buffer) -> int:
 #ytes_to_be_read = len(b)
 #f not bytes_to_be_read:
 #eturn 0
 #lif bytes_to_be_read % 2:
 #aise ValueError(
 #cannot read odd number of bytes from UTF-16-LE encoded console"
 #

 #uffer = get_buffer(b, writable=True)
 #ode_units_to_be_read = bytes_to_be_read // 2
 #ode_units_read = c_ulong()

 #v = ReadConsoleW(
 #ANDLE(self.handle),
 #uffer,
 #ode_units_to_be_read,
 #yref(code_units_read),
 #one,
 #
 #f GetLastError() == ERROR_OPERATION_ABORTED:
            # wait for KeyboardInterrupt
 #ime.sleep(0.1)
 #f not rv:
 #aise OSError(f"Windows error: {GetLastError()}")

 #f buffer[0] == EOF:
 #eturn 0
 #eturn 2 * code_units_read.value


class _WindowsConsoleWriter(_WindowsConsoleRawIOBase):
 #ef writable(self) -> t.Literal[True]:
 #eturn True

 #staticmethod
 #ef _get_error_message(errno: int) -> str:
 #f errno == ERROR_SUCCESS:
 #eturn "ERROR_SUCCESS"
 #lif errno == ERROR_NOT_ENOUGH_MEMORY:
 #eturn "ERROR_NOT_ENOUGH_MEMORY"
 #eturn f"Windows error {errno}"

 #ef write(self, b: Buffer) -> int:
 #ytes_to_be_written = len(b)
 #uf = get_buffer(b)
 #ode_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2
 #ode_units_written = c_ulong()

 #riteConsoleW(
 #ANDLE(self.handle),
 #uf,
 #ode_units_to_be_written,
 #yref(code_units_written),
 #one,
 #
 #ytes_written = 2 * code_units_written.value

 #f bytes_written == 0 and bytes_to_be_written > 0:
 #aise OSError(self._get_error_message(GetLastError()))
 #eturn bytes_written


class ConsoleStream:
 #ef __init__(self, text_stream: t.TextIO, byte_stream: t.BinaryIO) -> None:
 #elf._text_stream = text_stream
 #elf.buffer = byte_stream

 #property
 #ef name(self) -> str:
 #eturn self.buffer.name

 #ef write(self, x: t.AnyStr) -> int:
 #f isinstance(x, str):
 #eturn self._text_stream.write(x)
 #ry:
 #elf.flush()
 #xcept Exception:
 #ass
 #eturn self.buffer.write(x)

 #ef writelines(self, lines: cabc.Iterable[t.AnyStr]) -> None:
 #or line in lines:
 #elf.write(line)

 #ef __getattr__(self, name: str) -> t.Any:
 #eturn getattr(self._text_stream, name)

 #ef isatty(self) -> bool:
 #eturn self.buffer.isatty()

 #ef __repr__(self) -> str:
 #eturn f"<ConsoleStream name={self.name!r} encoding={self.encoding!r}>"


def _get_text_stdin(buffer_stream: t.BinaryIO) -> t.TextIO:
 #ext_stream = _NonClosingTextIOWrapper(
 #o.BufferedReader(_WindowsConsoleReader(STDIN_HANDLE)),
 #utf-16-le",
 #strict",
 #ine_buffering=True,
 #
 #eturn t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))


def _get_text_stdout(buffer_stream: t.BinaryIO) -> t.TextIO:
 #ext_stream = _NonClosingTextIOWrapper(
 #o.BufferedWriter(_WindowsConsoleWriter(STDOUT_HANDLE)),
 #utf-16-le",
 #strict",
 #ine_buffering=True,
 #
 #eturn t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))


def _get_text_stderr(buffer_stream: t.BinaryIO) -> t.TextIO:
 #ext_stream = _NonClosingTextIOWrapper(
 #o.BufferedWriter(_WindowsConsoleWriter(STDERR_HANDLE)),
 #utf-16-le",
 #strict",
 #ine_buffering=True,
 #
 #eturn t.cast(t.TextIO, ConsoleStream(text_stream, buffer_stream))


_stream_factories: cabc.Mapping[int, t.Callable[[t.BinaryIO], t.TextIO]] = {
 #: _get_text_stdin,
 #: _get_text_stdout,
 #: _get_text_stderr,
}


def _is_console(f: t.TextIO) -> bool:
 #f not hasattr(f, "fileno"):
 #eturn False

 #ry:
 #ileno = f.fileno()
 #xcept (OSError, io.UnsupportedOperation):
 #eturn False

 #andle = msvcrt.get_osfhandle(fileno)
 #eturn bool(GetConsoleMode(handle, byref(DWORD())))


def _get_windows_console_stream(
 #: t.TextIO, encoding: str | None, errors: str | None
) -> t.TextIO | None:
 #f (
 #et_buffer is None
 #r encoding not in {"utf-16-le", None}
 #r errors not in {"strict", None}
 #r not _is_console(f)
 #:
 #eturn None

 #unc = _stream_factories.get(f.fileno())
 #f func is None:
 #eturn None

 # = getattr(f, "buffer", None)

 #f b is None:
 #eturn None

 #eturn func(b)
