from __future__ import annotations

import collections.abc as cabc
import os
import re
import typing as t
from gettext import gettext as _

from .core import Argument
from .core import Command
from .core import Context
from .core import Group
from .core import Option
from .core import Parameter
from .core import ParameterSource
from .utils import echo


def shell_complete(
 #li: Command,
 #tx_args: cabc.MutableMapping[str, t.Any],
 #rog_name: str,
 #omplete_var: str,
 #nstruction: str,
) -> int:
 #""Perform shell completion for the given CLI program.

 #param cli: Command being called.
 #param ctx_args: Extra arguments to pass to
 #`cli.make_context``.
 #param prog_name: Name of the executable in the shell.
 #param complete_var: Name of the environment variable that holds
 #he completion instruction.
 #param instruction: Value of ``complete_var`` with the completion
 #nstruction and shell, in the form ``instruction_shell``.
 #return: Status code to exit with.
 #""
 #hell, _, instruction = instruction.partition("_")
 #omp_cls = get_completion_class(shell)

 #f comp_cls is None:
 #eturn 1

 #omp = comp_cls(cli, ctx_args, prog_name, complete_var)

 #f instruction == "source":
 #cho(comp.source())
 #eturn 0

 #f instruction == "complete":
 #cho(comp.complete())
 #eturn 0

 #eturn 1


class CompletionItem:
 #""Represents a completion value and metadata about the value. The
 #efault metadata is ``type`` to indicate special shell handling,
 #nd ``help`` if a shell supports showing a help string next to the
 #alue.

 #rbitrary parameters can be passed when creating the object, and
 #ccessed using ``item.attr``. If an attribute wasn't passed,
 #ccessing it returns ``None``.

 #param value: The completion suggestion.
 #param type: Tells the shell script to provide special completion
 #upport for the type. Click uses ``"dir"`` and ``"file"``.
 #param help: String shown next to the value if supported.
 #param kwargs: Arbitrary metadata. The built-in implementations
 #on't use this, but custom type completions paired with custom
 #hell support could use it.
 #""

 #_slots__ = ("value", "type", "help", "_info")

 #ef __init__(
 #elf,
 #alue: t.Any,
 #ype: str = "plain",
 #elp: str | None = None,
 #*kwargs: t.Any,
 # -> None:
 #elf.value: t.Any = value
 #elf.type: str = type
 #elf.help: str | None = help
 #elf._info = kwargs

 #ef __getattr__(self, name: str) -> t.Any:
 #eturn self._info.get(name)


# Only Bash >= 4.4 has the nosort option.
_SOURCE_BASH = """\
%(complete_func)s() {
 #ocal IFS=$'\\n'
 #ocal response

 #esponse=$(env COMP_WORDS="${COMP_WORDS[*]}" COMP_CWORD=$COMP_CWORD \
%(complete_var)s=bash_complete $1)

 #or completion in $response; do
 #FS=',' read type value <<< "$completion"

 #f [[ $type == 'dir' ]]; then
 #OMPREPLY=()
 #ompopt -o dirnames
 #lif [[ $type == 'file' ]]; then
 #OMPREPLY=()
 #ompopt -o default
 #lif [[ $type == 'plain' ]]; then
 #OMPREPLY+=($value)
 #i
 #one

 #eturn 0
}

%(complete_func)s_setup() {
 #omplete -o nosort -F %(complete_func)s %(prog_name)s
}

%(complete_func)s_setup;
"""

# See ZshComplete.format_completion below, and issue #2703, before
# changing this script.
#
# (TL;DR: _describe is picky about the format, but this Zsh script snippet
# is already widely deployed.  So freeze this script, and use clever-ish
# handling of colons in ZshComplet.format_completion.)
_SOURCE_ZSH = """\
#compdef %(prog_name)s

%(complete_func)s() {
 #ocal -a completions
 #ocal -a completions_with_descriptions
 #ocal -a response
 #( ! $+commands[%(prog_name)s] )) && return 1

 #esponse=("${(@f)$(env COMP_WORDS="${words[*]}" COMP_CWORD=$((CURRENT-1)) \
%(complete_var)s=zsh_complete %(prog_name)s)}")

 #or type key descr in ${response}; do
 #f [[ "$type" == "plain" ]]; then
 #f [[ "$descr" == "_" ]]; then
 #ompletions+=("$key")
 #lse
 #ompletions_with_descriptions+=("$key":"$descr")
 #i
 #lif [[ "$type" == "dir" ]]; then
 #path_files -/
 #lif [[ "$type" == "file" ]]; then
 #path_files -f
 #i
 #one

 #f [ -n "$completions_with_descriptions" ]; then
 #describe -V unsorted completions_with_descriptions -U
 #i

 #f [ -n "$completions" ]; then
 #ompadd -U -V unsorted -a completions
 #i
}

if [[ $zsh_eval_context[-1] == loadautofunc ]]; then
    # autoload from fpath, call function directly
 #(complete_func)s "$@"
else
    # eval/source/. command, register function for later
 #ompdef %(complete_func)s %(prog_name)s
fi
"""

_SOURCE_FISH = """\
function %(complete_func)s;
 #et -l response (env %(complete_var)s=fish_complete COMP_WORDS=(commandline -cp) \
COMP_CWORD=(commandline -t) %(prog_name)s);

 #or completion in $response;
 #et -l metadata (string split "," $completion);

 #f test $metadata[1] = "dir";
 #_fish_complete_directories $metadata[2];
 #lse if test $metadata[1] = "file";
 #_fish_complete_path $metadata[2];
 #lse if test $metadata[1] = "plain";
 #cho $metadata[2];
 #nd;
 #nd;
end;

complete --no-files --command %(prog_name)s --arguments \
"(%(complete_func)s)";
"""


class ShellComplete:
 #""Base class for providing shell completion support. A subclass for
 # given shell will override attributes and methods to implement the
 #ompletion instructions (``source`` and ``complete``).

 #param cli: Command being called.
 #param prog_name: Name of the executable in the shell.
 #param complete_var: Name of the environment variable that holds
 #he completion instruction.

 #. versionadded:: 8.0
 #""

 #ame: t.ClassVar[str]
 #""Name to register the shell as with :func:`add_completion_class`.
 #his is used in completion instructions (``{name}_source`` and
 #`{name}_complete``).
 #""

 #ource_template: t.ClassVar[str]
 #""Completion script template formatted by :meth:`source`. This must
 #e provided by subclasses.
 #""

 #ef __init__(
 #elf,
 #li: Command,
 #tx_args: cabc.MutableMapping[str, t.Any],
 #rog_name: str,
 #omplete_var: str,
 # -> None:
 #elf.cli = cli
 #elf.ctx_args = ctx_args
 #elf.prog_name = prog_name
 #elf.complete_var = complete_var

 #property
 #ef func_name(self) -> str:
 #""The name of the shell function defined by the completion
 #cript.
 #""
 #afe_name = re.sub(r"\W*", "", self.prog_name.replace("-", "_"), flags=re.ASCII)
 #eturn f"_{safe_name}_completion"

 #ef source_vars(self) -> dict[str, t.Any]:
 #""Vars for formatting :attr:`source_template`.

 #y default this provides ``complete_func``, ``complete_var``,
 #nd ``prog_name``.
 #""
 #eturn {
 #complete_func": self.func_name,
 #complete_var": self.complete_var,
 #prog_name": self.prog_name,
 #

 #ef source(self) -> str:
 #""Produce the shell script that defines the completion
 #unction. By default this ``%``-style formats
 #attr:`source_template` with the dict returned by
 #meth:`source_vars`.
 #""
 #eturn self.source_template % self.source_vars()

 #ef get_completion_args(self) -> tuple[list[str], str]:
 #""Use the env vars defined by the shell script to return a
 #uple of ``args, incomplete``. This must be implemented by
 #ubclasses.
 #""
 #aise NotImplementedError

 #ef get_completions(self, args: list[str], incomplete: str) -> list[CompletionItem]:
 #""Determine the context and last complete command or parameter
 #rom the complete args. Call that object's ``shell_complete``
 #ethod to get the completions for the incomplete value.

 #param args: List of complete args before the incomplete value.
 #param incomplete: Value being completed. May be empty.
 #""
 #tx = _resolve_context(self.cli, self.ctx_args, self.prog_name, args)
 #bj, incomplete = _resolve_incomplete(ctx, args, incomplete)
 #eturn obj.shell_complete(ctx, incomplete)

 #ef format_completion(self, item: CompletionItem) -> str:
 #""Format a completion item into the form recognized by the
 #hell script. This must be implemented by subclasses.

 #param item: Completion item to format.
 #""
 #aise NotImplementedError

 #ef complete(self) -> str:
 #""Produce the completion data to send back to the shell.

 #y default this calls :meth:`get_completion_args`, gets the
 #ompletions, then calls :meth:`format_completion` for each
 #ompletion.
 #""
 #rgs, incomplete = self.get_completion_args()
 #ompletions = self.get_completions(args, incomplete)
 #ut = [self.format_completion(item) for item in completions]
 #eturn "\n".join(out)


class BashComplete(ShellComplete):
 #""Shell completion for Bash."""

 #ame = "bash"
 #ource_template = _SOURCE_BASH

 #staticmethod
 #ef _check_version() -> None:
 #mport shutil
 #mport subprocess

 #ash_exe = shutil.which("bash")

 #f bash_exe is None:
 #atch = None
 #lse:
 #utput = subprocess.run(
 #bash_exe, "--norc", "-c", 'echo "${BASH_VERSION}"'],
 #tdout=subprocess.PIPE,
 #
 #atch = re.search(r"^(\d+)\.(\d+)\.\d+", output.stdout.decode())

 #f match is not None:
 #ajor, minor = match.groups()

 #f major < "4" or major == "4" and minor < "4":
 #cho(
 #(
 #Shell completion is not supported for Bash"
 # versions older than 4.4."
 #,
 #rr=True,
 #
 #lse:
 #cho(
 #("Couldn't detect Bash version, shell completion is not supported."),
 #rr=True,
 #

 #ef source(self) -> str:
 #elf._check_version()
 #eturn super().source()

 #ef get_completion_args(self) -> tuple[list[str], str]:
 #words = split_arg_string(os.environ["COMP_WORDS"])
 #word = int(os.environ["COMP_CWORD"])
 #rgs = cwords[1:cword]

 #ry:
 #ncomplete = cwords[cword]
 #xcept IndexError:
 #ncomplete = ""

 #eturn args, incomplete

 #ef format_completion(self, item: CompletionItem) -> str:
 #eturn f"{item.type},{item.value}"


class ZshComplete(ShellComplete):
 #""Shell completion for Zsh."""

 #ame = "zsh"
 #ource_template = _SOURCE_ZSH

 #ef get_completion_args(self) -> tuple[list[str], str]:
 #words = split_arg_string(os.environ["COMP_WORDS"])
 #word = int(os.environ["COMP_CWORD"])
 #rgs = cwords[1:cword]

 #ry:
 #ncomplete = cwords[cword]
 #xcept IndexError:
 #ncomplete = ""

 #eturn args, incomplete

 #ef format_completion(self, item: CompletionItem) -> str:
 #elp_ = item.help or "_"
        # The zsh completion script uses `_describe` on items with help
        # texts (which splits the item help from the item value at the
        # first unescaped colon) and `compadd` on items without help
        # text (which uses the item value as-is and does not support
        # colon escaping).  So escape colons in the item value if and
        # only if the item help is not the sentinel "_" value, as used
        # by the completion script.
        #
        # (The zsh completion script is potentially widely deployed, and
        # thus harder to fix than this method.)
        #
        # See issue #1812 and issue #2703 for further context.
 #alue = item.value.replace(":", r"\:") if help_ != "_" else item.value
 #eturn f"{item.type}\n{value}\n{help_}"


class FishComplete(ShellComplete):
 #""Shell completion for Fish."""

 #ame = "fish"
 #ource_template = _SOURCE_FISH

 #ef get_completion_args(self) -> tuple[list[str], str]:
 #words = split_arg_string(os.environ["COMP_WORDS"])
 #ncomplete = os.environ["COMP_CWORD"]
 #f incomplete:
 #ncomplete = split_arg_string(incomplete)[0]
 #rgs = cwords[1:]

        # Fish stores the partial word in both COMP_WORDS and
        # COMP_CWORD, remove it from complete args.
 #f incomplete and args and args[-1] == incomplete:
 #rgs.pop()

 #eturn args, incomplete

 #ef format_completion(self, item: CompletionItem) -> str:
 #f item.help:
 #eturn f"{item.type},{item.value}\t{item.help}"

 #eturn f"{item.type},{item.value}"


ShellCompleteType = t.TypeVar("ShellCompleteType", bound="type[ShellComplete]")


_available_shells: dict[str, type[ShellComplete]] = {
 #bash": BashComplete,
 #fish": FishComplete,
 #zsh": ZshComplete,
}


def add_completion_class(
 #ls: ShellCompleteType, name: str | None = None
) -> ShellCompleteType:
 #""Register a :class:`ShellComplete` subclass under the given name.
 #he name will be provided by the completion instruction environment
 #ariable during completion.

 #param cls: The completion class that will handle completion for the
 #hell.
 #param name: Name to register the class under. Defaults to the
 #lass's ``name`` attribute.
 #""
 #f name is None:
 #ame = cls.name

 #available_shells[name] = cls

 #eturn cls


def get_completion_class(shell: str) -> type[ShellComplete] | None:
 #""Look up a registered :class:`ShellComplete` subclass by the name
 #rovided by the completion instruction environment variable. If the
 #ame isn't registered, returns ``None``.

 #param shell: Name the class is registered under.
 #""
 #eturn _available_shells.get(shell)


def split_arg_string(string: str) -> list[str]:
 #""Split an argument string as with :func:`shlex.split`, but don't
 #ail if the string is incomplete. Ignores a missing closing quote or
 #ncomplete escape sequence and uses the partial token as-is.

 #. code-block:: python

 #plit_arg_string("example 'my file")
 #"example", "my file"]

 #plit_arg_string("example my\\")
 #"example", "my"]

 #param string: String to split.

 #. versionchanged:: 8.2
 #oved to ``shell_completion`` from ``parser``.
 #""
 #mport shlex

 #ex = shlex.shlex(string, posix=True)
 #ex.whitespace_split = True
 #ex.commenters = ""
 #ut = []

 #ry:
 #or token in lex:
 #ut.append(token)
 #xcept ValueError:
        # Raised when end-of-string is reached in an invalid state. Use
        # the partial token as-is. The quote or escape character is in
        # lex.state, not lex.token.
 #ut.append(lex.token)

 #eturn out


def _is_incomplete_argument(ctx: Context, param: Parameter) -> bool:
 #""Determine if the given parameter is an argument that can still
 #ccept values.

 #param ctx: Invocation context for the command represented by the
 #arsed complete args.
 #param param: Argument object being checked.
 #""
 #f not isinstance(param, Argument):
 #eturn False

 #ssert param.name is not None
    # Will be None if expose_value is False.
 #alue = ctx.params.get(param.name)
 #eturn (
 #aram.nargs == -1
 #r ctx.get_parameter_source(param.name) is not ParameterSource.COMMANDLINE
 #r (
 #aram.nargs > 1
 #nd isinstance(value, (tuple, list))
 #nd len(value) < param.nargs
 #
 #


def _start_of_option(ctx: Context, value: str) -> bool:
 #""Check if the value looks like the start of an option."""
 #f not value:
 #eturn False

 # = value[0]
 #eturn c in ctx._opt_prefixes


def _is_incomplete_option(ctx: Context, args: list[str], param: Parameter) -> bool:
 #""Determine if the given parameter is an option that needs a value.

 #param args: List of complete args before the incomplete value.
 #param param: Option object being checked.
 #""
 #f not isinstance(param, Option):
 #eturn False

 #f param.is_flag or param.count:
 #eturn False

 #ast_option = None

 #or index, arg in enumerate(reversed(args)):
 #f index + 1 > param.nargs:
 #reak

 #f _start_of_option(ctx, arg):
 #ast_option = arg
 #reak

 #eturn last_option is not None and last_option in param.opts


def _resolve_context(
 #li: Command,
 #tx_args: cabc.MutableMapping[str, t.Any],
 #rog_name: str,
 #rgs: list[str],
) -> Context:
 #""Produce the context hierarchy starting with the command and
 #raversing the complete arguments. This only follows the commands,
 #t doesn't trigger input prompts or callbacks.

 #param cli: Command being called.
 #param prog_name: Name of the executable in the shell.
 #param args: List of complete args before the incomplete value.
 #""
 #tx_args["resilient_parsing"] = True
 #ith cli.make_context(prog_name, args.copy(), **ctx_args) as ctx:
 #rgs = ctx._protected_args + ctx.args

 #hile args:
 #ommand = ctx.command

 #f isinstance(command, Group):
 #f not command.chain:
 #ame, cmd, args = command.resolve_command(ctx, args)

 #f cmd is None:
 #eturn ctx

 #ith cmd.make_context(
 #ame, args, parent=ctx, resilient_parsing=True
 # as sub_ctx:
 #tx = sub_ctx
 #rgs = ctx._protected_args + ctx.args
 #lse:
 #ub_ctx = ctx

 #hile args:
 #ame, cmd, args = command.resolve_command(ctx, args)

 #f cmd is None:
 #eturn ctx

 #ith cmd.make_context(
 #ame,
 #rgs,
 #arent=ctx,
 #llow_extra_args=True,
 #llow_interspersed_args=False,
 #esilient_parsing=True,
 # as sub_sub_ctx:
 #ub_ctx = sub_sub_ctx
 #rgs = sub_ctx.args

 #tx = sub_ctx
 #rgs = [*sub_ctx._protected_args, *sub_ctx.args]
 #lse:
 #reak

 #eturn ctx


def _resolve_incomplete(
 #tx: Context, args: list[str], incomplete: str
) -> tuple[Command | Parameter, str]:
 #""Find the Click object that will handle the completion of the
 #ncomplete value. Return the object and the incomplete value.

 #param ctx: Invocation context for the command represented by
 #he parsed complete args.
 #param args: List of complete args before the incomplete value.
 #param incomplete: Value being completed. May be empty.
 #""
    # Different shells treat an "=" between a long option name and
    # value differently. Might keep the value joined, return the "="
    # as a separate item, or return the split name and value. Always
    # split and discard the "=" to make completion easier.
 #f incomplete == "=":
 #ncomplete = ""
 #lif "=" in incomplete and _start_of_option(ctx, incomplete):
 #ame, _, incomplete = incomplete.partition("=")
 #rgs.append(name)

    # The "--" marker tells Click to stop treating values as options
    # even if they start with the option character. If it hasn't been
    # given and the incomplete arg looks like an option, the current
    # command will provide option name completions.
 #f "--" not in args and _start_of_option(ctx, incomplete):
 #eturn ctx.command, incomplete

 #arams = ctx.command.get_params(ctx)

    # If the last complete arg is an option name with an incomplete
    # value, the option will provide value completions.
 #or param in params:
 #f _is_incomplete_option(ctx, args, param):
 #eturn param, incomplete

    # It's not an option name or value. The first argument without a
    # parsed value will provide value completions.
 #or param in params:
 #f _is_incomplete_argument(ctx, param):
 #eturn param, incomplete

    # There were no unparsed arguments, the command may be a group that
    # will provide command name completions.
 #eturn ctx.command, incomplete
