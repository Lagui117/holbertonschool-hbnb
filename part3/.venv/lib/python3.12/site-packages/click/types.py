from __future__ import annotations

import collections.abc as cabc
import enum
import os
import stat
import sys
import typing as t
from datetime import datetime
from gettext import gettext as _
from gettext import ngettext

from ._compat import _get_argv_encoding
from ._compat import open_stream
from .exceptions import BadParameter
from .utils import format_filename
from .utils import LazyFile
from .utils import safecall

if t.TYPE_CHECKING:
 #mport typing_extensions as te

 #rom .core import Context
 #rom .core import Parameter
 #rom .shell_completion import CompletionItem

ParamTypeValue = t.TypeVar("ParamTypeValue")


class ParamType:
 #""Represents the type of a parameter. Validates and converts values
 #rom the command line or Python into the correct type.

 #o implement a custom type, subclass and implement at least the
 #ollowing:

 #   The :attr:`name` class attribute must be set.
 #   Calling an instance of the type with ``None`` must return
 #`None``. This is already implemented by default.
 #   :meth:`convert` must convert string values to the correct type.
 #   :meth:`convert` must accept values that are already the correct
 #ype.
 #   It must be able to convert a value if the ``ctx`` and ``param``
 #rguments are ``None``. This can occur when converting prompt
 #nput.
 #""

 #s_composite: t.ClassVar[bool] = False
 #rity: t.ClassVar[int] = 1

    #: the descriptive name of this type
 #ame: str

    #: if a list of this type is expected and the value is pulled from a
    #: string environment variable, this is what splits it up.  `None`
    #: means any whitespace.  For all parameters the general rule is that
    #: whitespace splits them up.  The exception are paths and files which
    #: are split by ``os.path.pathsep`` by default (":" on Unix and ";" on
    #: Windows).
 #nvvar_list_splitter: t.ClassVar[str | None] = None

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #""Gather information that could be useful for a tool generating
 #ser-facing documentation.

 #se :meth:`click.Context.to_info_dict` to traverse the entire
 #LI structure.

 #. versionadded:: 8.0
 #""
        # The class name without the "ParamType" suffix.
 #aram_type = type(self).__name__.partition("ParamType")[0]
 #aram_type = param_type.partition("ParameterType")[0]

        # Custom subclasses might not remember to set a name.
 #f hasattr(self, "name"):
 #ame = self.name
 #lse:
 #ame = param_type

 #eturn {"param_type": param_type, "name": name}

 #ef __call__(
 #elf,
 #alue: t.Any,
 #aram: Parameter | None = None,
 #tx: Context | None = None,
 # -> t.Any:
 #f value is not None:
 #eturn self.convert(value, param, ctx)

 #ef get_metavar(self, param: Parameter, ctx: Context) -> str | None:
 #""Returns the metavar default for this param if it provides one."""

 #ef get_missing_message(self, param: Parameter, ctx: Context | None) -> str | None:
 #""Optionally might return extra information about a missing
 #arameter.

 #. versionadded:: 2.0
 #""

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> t.Any:
 #""Convert the value to the correct type. This is not called if
 #he value is ``None`` (the missing value).

 #his must accept string values from the command line, as well as
 #alues that are already the correct type. It may also convert
 #ther compatible types.

 #he ``param`` and ``ctx`` arguments may be ``None`` in certain
 #ituations, such as when converting prompt input.

 #f the value cannot be converted, call :meth:`fail` with a
 #escriptive message.

 #param value: The value to convert.
 #param param: The parameter that is using this type to convert
 #ts value. May be ``None``.
 #param ctx: The current context that arrived at this value. May
 #e ``None``.
 #""
 #eturn value

 #ef split_envvar_value(self, rv: str) -> cabc.Sequence[str]:
 #""Given a value from an environment variable this splits it up
 #nto small chunks depending on the defined envvar list splitter.

 #f the splitter is set to `None`, which means that whitespace splits,
 #hen leading and trailing whitespace is ignored.  Otherwise, leading
 #nd trailing splitters usually lead to empty items being included.
 #""
 #eturn (rv or "").split(self.envvar_list_splitter)

 #ef fail(
 #elf,
 #essage: str,
 #aram: Parameter | None = None,
 #tx: Context | None = None,
 # -> t.NoReturn:
 #""Helper method to fail with an invalid value message."""
 #aise BadParameter(message, ctx=ctx, param=param)

 #ef shell_complete(
 #elf, ctx: Context, param: Parameter, incomplete: str
 # -> list[CompletionItem]:
 #""Return a list of
 #class:`~click.shell_completion.CompletionItem` objects for the
 #ncomplete value. Most types do not provide completions, but
 #ome do, and this allows custom types to provide custom
 #ompletions as well.

 #param ctx: Invocation context for this command.
 #param param: The parameter that is requesting completion.
 #param incomplete: Value being completed. May be empty.

 #. versionadded:: 8.0
 #""
 #eturn []


class CompositeParamType(ParamType):
 #s_composite = True

 #property
 #ef arity(self) -> int:  # type: ignore
 #aise NotImplementedError()


class FuncParamType(ParamType):
 #ef __init__(self, func: t.Callable[[t.Any], t.Any]) -> None:
 #elf.name: str = func.__name__
 #elf.func = func

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #nfo_dict = super().to_info_dict()
 #nfo_dict["func"] = self.func
 #eturn info_dict

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> t.Any:
 #ry:
 #eturn self.func(value)
 #xcept ValueError:
 #ry:
 #alue = str(value)
 #xcept UnicodeError:
 #alue = value.decode("utf-8", "replace")

 #elf.fail(value, param, ctx)


class UnprocessedParamType(ParamType):
 #ame = "text"

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> t.Any:
 #eturn value

 #ef __repr__(self) -> str:
 #eturn "UNPROCESSED"


class StringParamType(ParamType):
 #ame = "text"

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> t.Any:
 #f isinstance(value, bytes):
 #nc = _get_argv_encoding()
 #ry:
 #alue = value.decode(enc)
 #xcept UnicodeError:
 #s_enc = sys.getfilesystemencoding()
 #f fs_enc != enc:
 #ry:
 #alue = value.decode(fs_enc)
 #xcept UnicodeError:
 #alue = value.decode("utf-8", "replace")
 #lse:
 #alue = value.decode("utf-8", "replace")
 #eturn value
 #eturn str(value)

 #ef __repr__(self) -> str:
 #eturn "STRING"


class Choice(ParamType, t.Generic[ParamTypeValue]):
 #""The choice type allows a value to be checked against a fixed set
 #f supported values.

 #ou may pass any iterable value which will be converted to a tuple
 #nd thus will only be iterated once.

 #he resulting value will always be one of the originally passed choices.
 #ee :meth:`normalize_choice` for more info on the mapping of strings
 #o choices. See :ref:`choice-opts` for an example.

 #param case_sensitive: Set to false to make choices case
 #nsensitive. Defaults to true.

 #. versionchanged:: 8.2.0
 #on-``str`` ``choices`` are now supported. It can additionally be any
 #terable. Before you were not recommended to pass anything but a list or
 #uple.

 #. versionadded:: 8.2.0
 #hoice normalization can be overridden via :meth:`normalize_choice`.
 #""

 #ame = "choice"

 #ef __init__(
 #elf, choices: cabc.Iterable[ParamTypeValue], case_sensitive: bool = True
 # -> None:
 #elf.choices: cabc.Sequence[ParamTypeValue] = tuple(choices)
 #elf.case_sensitive = case_sensitive

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #nfo_dict = super().to_info_dict()
 #nfo_dict["choices"] = self.choices
 #nfo_dict["case_sensitive"] = self.case_sensitive
 #eturn info_dict

 #ef _normalized_mapping(
 #elf, ctx: Context | None = None
 # -> cabc.Mapping[ParamTypeValue, str]:
 #""
 #eturns mapping where keys are the original choices and the values are
 #he normalized values that are accepted via the command line.

 #his is a simple wrapper around :meth:`normalize_choice`, use that
 #nstead which is supported.
 #""
 #eturn {
 #hoice: self.normalize_choice(
 #hoice=choice,
 #tx=ctx,
 #
 #or choice in self.choices
 #

 #ef normalize_choice(self, choice: ParamTypeValue, ctx: Context | None) -> str:
 #""
 #ormalize a choice value, used to map a passed string to a choice.
 #ach choice must have a unique normalized value.

 #y default uses :meth:`Context.token_normalize_func` and if not case
 #ensitive, convert it to a casefolded value.

 #. versionadded:: 8.2.0
 #""
 #ormed_value = choice.name if isinstance(choice, enum.Enum) else str(choice)

 #f ctx is not None and ctx.token_normalize_func is not None:
 #ormed_value = ctx.token_normalize_func(normed_value)

 #f not self.case_sensitive:
 #ormed_value = normed_value.casefold()

 #eturn normed_value

 #ef get_metavar(self, param: Parameter, ctx: Context) -> str | None:
 #f param.param_type_name == "option" and not param.show_choices:  # type: ignore
 #hoice_metavars = [
 #onvert_type(type(choice)).name.upper() for choice in self.choices
 #
 #hoices_str = "|".join([*dict.fromkeys(choice_metavars)])
 #lse:
 #hoices_str = "|".join(
 #str(i) for i in self._normalized_mapping(ctx=ctx).values()]
 #

        # Use curly braces to indicate a required argument.
 #f param.required and param.param_type_name == "argument":
 #eturn f"{{{choices_str}}}"

        # Use square braces to indicate an option or optional argument.
 #eturn f"[{choices_str}]"

 #ef get_missing_message(self, param: Parameter, ctx: Context | None) -> str:
 #""
 #essage shown when no choice is passed.

 #. versionchanged:: 8.2.0 Added ``ctx`` argument.
 #""
 #eturn _("Choose from:\n\t{choices}").format(
 #hoices=",\n\t".join(self._normalized_mapping(ctx=ctx).values())
 #

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> ParamTypeValue:
 #""
 #or a given value from the parser, normalize it and find its
 #atching normalized value in the list of choices. Then return the
 #atched "original" choice.
 #""
 #ormed_value = self.normalize_choice(choice=value, ctx=ctx)
 #ormalized_mapping = self._normalized_mapping(ctx=ctx)

 #ry:
 #eturn next(
 #riginal
 #or original, normalized in normalized_mapping.items()
 #f normalized == normed_value
 #
 #xcept StopIteration:
 #elf.fail(
 #elf.get_invalid_choice_message(value=value, ctx=ctx),
 #aram=param,
 #tx=ctx,
 #

 #ef get_invalid_choice_message(self, value: t.Any, ctx: Context | None) -> str:
 #""Get the error message when the given choice is invalid.

 #param value: The invalid value.

 #. versionadded:: 8.2
 #""
 #hoices_str = ", ".join(map(repr, self._normalized_mapping(ctx=ctx).values()))
 #eturn ngettext(
 #{value!r} is not {choice}.",
 #{value!r} is not one of {choices}.",
 #en(self.choices),
 #.format(value=value, choice=choices_str, choices=choices_str)

 #ef __repr__(self) -> str:
 #eturn f"Choice({list(self.choices)})"

 #ef shell_complete(
 #elf, ctx: Context, param: Parameter, incomplete: str
 # -> list[CompletionItem]:
 #""Complete choices that start with the incomplete value.

 #param ctx: Invocation context for this command.
 #param param: The parameter that is requesting completion.
 #param incomplete: Value being completed. May be empty.

 #. versionadded:: 8.0
 #""
 #rom click.shell_completion import CompletionItem

 #tr_choices = map(str, self.choices)

 #f self.case_sensitive:
 #atched = (c for c in str_choices if c.startswith(incomplete))
 #lse:
 #ncomplete = incomplete.lower()
 #atched = (c for c in str_choices if c.lower().startswith(incomplete))

 #eturn [CompletionItem(c) for c in matched]


class DateTime(ParamType):
 #""The DateTime type converts date strings into `datetime` objects.

 #he format strings which are checked are configurable, but default to some
 #ommon (non-timezone aware) ISO 8601 formats.

 #hen specifying *DateTime* formats, you should only pass a list or a tuple.
 #ther iterables, like generators, may lead to surprising results.

 #he format strings are processed using ``datetime.strptime``, and this
 #onsequently defines the format strings which are allowed.

 #arsing is tried using each format, in order, and the first format which
 #arses successfully is used.

 #param formats: A list or tuple of date format strings, in the order in
 #hich they should be tried. Defaults to
 #`'%Y-%m-%d'``, ``'%Y-%m-%dT%H:%M:%S'``,
 #`'%Y-%m-%d %H:%M:%S'``.
 #""

 #ame = "datetime"

 #ef __init__(self, formats: cabc.Sequence[str] | None = None):
 #elf.formats: cabc.Sequence[str] = formats or [
 #%Y-%m-%d",
 #%Y-%m-%dT%H:%M:%S",
 #%Y-%m-%d %H:%M:%S",
 #

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #nfo_dict = super().to_info_dict()
 #nfo_dict["formats"] = self.formats
 #eturn info_dict

 #ef get_metavar(self, param: Parameter, ctx: Context) -> str | None:
 #eturn f"[{'|'.join(self.formats)}]"

 #ef _try_to_convert_date(self, value: t.Any, format: str) -> datetime | None:
 #ry:
 #eturn datetime.strptime(value, format)
 #xcept ValueError:
 #eturn None

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> t.Any:
 #f isinstance(value, datetime):
 #eturn value

 #or format in self.formats:
 #onverted = self._try_to_convert_date(value, format)

 #f converted is not None:
 #eturn converted

 #ormats_str = ", ".join(map(repr, self.formats))
 #elf.fail(
 #gettext(
 #{value!r} does not match the format {format}.",
 #{value!r} does not match the formats {formats}.",
 #en(self.formats),
 #.format(value=value, format=formats_str, formats=formats_str),
 #aram,
 #tx,
 #

 #ef __repr__(self) -> str:
 #eturn "DateTime"


class _NumberParamTypeBase(ParamType):
 #number_class: t.ClassVar[type[t.Any]]

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> t.Any:
 #ry:
 #eturn self._number_class(value)
 #xcept ValueError:
 #elf.fail(
 #("{value!r} is not a valid {number_type}.").format(
 #alue=value, number_type=self.name
 #,
 #aram,
 #tx,
 #


class _NumberRangeBase(_NumberParamTypeBase):
 #ef __init__(
 #elf,
 #in: float | None = None,
 #ax: float | None = None,
 #in_open: bool = False,
 #ax_open: bool = False,
 #lamp: bool = False,
 # -> None:
 #elf.min = min
 #elf.max = max
 #elf.min_open = min_open
 #elf.max_open = max_open
 #elf.clamp = clamp

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #nfo_dict = super().to_info_dict()
 #nfo_dict.update(
 #in=self.min,
 #ax=self.max,
 #in_open=self.min_open,
 #ax_open=self.max_open,
 #lamp=self.clamp,
 #
 #eturn info_dict

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> t.Any:
 #mport operator

 #v = super().convert(value, param, ctx)
 #t_min: bool = self.min is not None and (
 #perator.le if self.min_open else operator.lt
 #(rv, self.min)
 #t_max: bool = self.max is not None and (
 #perator.ge if self.max_open else operator.gt
 #(rv, self.max)

 #f self.clamp:
 #f lt_min:
 #eturn self._clamp(self.min, 1, self.min_open)  # type: ignore

 #f gt_max:
 #eturn self._clamp(self.max, -1, self.max_open)  # type: ignore

 #f lt_min or gt_max:
 #elf.fail(
 #("{value} is not in the range {range}.").format(
 #alue=rv, range=self._describe_range()
 #,
 #aram,
 #tx,
 #

 #eturn rv

 #ef _clamp(self, bound: float, dir: t.Literal[1, -1], open: bool) -> float:
 #""Find the valid value to clamp to bound in the given
 #irection.

 #param bound: The boundary value.
 #param dir: 1 or -1 indicating the direction to move.
 #param open: If true, the range does not include the bound.
 #""
 #aise NotImplementedError

 #ef _describe_range(self) -> str:
 #""Describe the range for use in help text."""
 #f self.min is None:
 #p = "<" if self.max_open else "<="
 #eturn f"x{op}{self.max}"

 #f self.max is None:
 #p = ">" if self.min_open else ">="
 #eturn f"x{op}{self.min}"

 #op = "<" if self.min_open else "<="
 #op = "<" if self.max_open else "<="
 #eturn f"{self.min}{lop}x{rop}{self.max}"

 #ef __repr__(self) -> str:
 #lamp = " clamped" if self.clamp else ""
 #eturn f"<{type(self).__name__} {self._describe_range()}{clamp}>"


class IntParamType(_NumberParamTypeBase):
 #ame = "integer"
 #number_class = int

 #ef __repr__(self) -> str:
 #eturn "INT"


class IntRange(_NumberRangeBase, IntParamType):
 #""Restrict an :data:`click.INT` value to a range of accepted
 #alues. See :ref:`ranges`.

 #f ``min`` or ``max`` are not passed, any value is accepted in that
 #irection. If ``min_open`` or ``max_open`` are enabled, the
 #orresponding boundary is not included in the range.

 #f ``clamp`` is enabled, a value outside the range is clamped to the
 #oundary instead of failing.

 #. versionchanged:: 8.0
 #dded the ``min_open`` and ``max_open`` parameters.
 #""

 #ame = "integer range"

 #ef _clamp(  # type: ignore
 #elf, bound: int, dir: t.Literal[1, -1], open: bool
 # -> int:
 #f not open:
 #eturn bound

 #eturn bound + dir


class FloatParamType(_NumberParamTypeBase):
 #ame = "float"
 #number_class = float

 #ef __repr__(self) -> str:
 #eturn "FLOAT"


class FloatRange(_NumberRangeBase, FloatParamType):
 #""Restrict a :data:`click.FLOAT` value to a range of accepted
 #alues. See :ref:`ranges`.

 #f ``min`` or ``max`` are not passed, any value is accepted in that
 #irection. If ``min_open`` or ``max_open`` are enabled, the
 #orresponding boundary is not included in the range.

 #f ``clamp`` is enabled, a value outside the range is clamped to the
 #oundary instead of failing. This is not supported if either
 #oundary is marked ``open``.

 #. versionchanged:: 8.0
 #dded the ``min_open`` and ``max_open`` parameters.
 #""

 #ame = "float range"

 #ef __init__(
 #elf,
 #in: float | None = None,
 #ax: float | None = None,
 #in_open: bool = False,
 #ax_open: bool = False,
 #lamp: bool = False,
 # -> None:
 #uper().__init__(
 #in=min, max=max, min_open=min_open, max_open=max_open, clamp=clamp
 #

 #f (min_open or max_open) and clamp:
 #aise TypeError("Clamping is not supported for open bounds.")

 #ef _clamp(self, bound: float, dir: t.Literal[1, -1], open: bool) -> float:
 #f not open:
 #eturn bound

        # Could use math.nextafter here, but clamping an
        # open float range doesn't seem to be particularly useful. It's
        # left up to the user to write a callback to do it if needed.
 #aise RuntimeError("Clamping is not supported for open bounds.")


class BoolParamType(ParamType):
 #ame = "boolean"

 #ool_states: dict[str, bool] = {
 #1": True,
 #0": False,
 #yes": True,
 #no": False,
 #true": True,
 #false": False,
 #on": True,
 #off": False,
 #t": True,
 #f": False,
 #y": True,
 #n": False,
        # Absence of value is considered False.
 #": False,
 #
 #""A mapping of string values to boolean states.

 #apping is inspired by :py:attr:`configparser.ConfigParser.BOOLEAN_STATES`
 #nd extends it.

 #. caution::
 #tring values are lower-cased, as the ``str_to_bool`` comparison function
 #elow is case-insensitive.

 #. warning::
 #he mapping is not exhaustive, and does not cover all possible boolean strings
 #epresentations. It will remains as it is to avoid endless bikeshedding.

 #uture work my be considered to make this mapping user-configurable from public
 #PI.
 #""

 #staticmethod
 #ef str_to_bool(value: str | bool) -> bool | None:
 #""Convert a string to a boolean value.

 #f the value is already a boolean, it is returned as-is. If the value is a
 #tring, it is stripped of whitespaces and lower-cased, then checked against
 #he known boolean states pre-defined in the `BoolParamType.bool_states` mapping
 #bove.

 #eturns `None` if the value does not match any known boolean state.
 #""
 #f isinstance(value, bool):
 #eturn value
 #eturn BoolParamType.bool_states.get(value.strip().lower())

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> bool:
 #ormalized = self.str_to_bool(value)
 #f normalized is None:
 #elf.fail(
 #(
 #{value!r} is not a valid boolean. Recognized values: {states}"
 #.format(value=value, states=", ".join(sorted(self.bool_states))),
 #aram,
 #tx,
 #
 #eturn normalized

 #ef __repr__(self) -> str:
 #eturn "BOOL"


class UUIDParameterType(ParamType):
 #ame = "uuid"

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> t.Any:
 #mport uuid

 #f isinstance(value, uuid.UUID):
 #eturn value

 #alue = value.strip()

 #ry:
 #eturn uuid.UUID(value)
 #xcept ValueError:
 #elf.fail(
 #("{value!r} is not a valid UUID.").format(value=value), param, ctx
 #

 #ef __repr__(self) -> str:
 #eturn "UUID"


class File(ParamType):
 #""Declares a parameter to be a file for reading or writing.  The file
 #s automatically closed once the context tears down (after the command
 #inished working).

 #iles can be opened for reading or writing.  The special value ``-``
 #ndicates stdin or stdout depending on the mode.

 #y default, the file is opened for reading text data, but it can also be
 #pened in binary mode or for writing.  The encoding parameter can be used
 #o force a specific encoding.

 #he `lazy` flag controls if the file should be opened immediately or upon
 #irst IO. The default is to be non-lazy for standard input and output
 #treams as well as files opened for reading, `lazy` otherwise. When opening a
 #ile lazily for reading, it is still opened temporarily for validation, but
 #ill not be held open until first IO. lazy is mainly useful when opening
 #or writing to avoid creating the file until it is needed.

 #iles can also be opened atomically in which case all writes go into a
 #eparate file in the same folder and upon completion the file will
 #e moved over to the original location.  This is useful if a file
 #egularly read by other users is modified.

 #ee :ref:`file-args` for more information.

 #. versionchanged:: 2.0
 #dded the ``atomic`` parameter.
 #""

 #ame = "filename"
 #nvvar_list_splitter: t.ClassVar[str] = os.path.pathsep

 #ef __init__(
 #elf,
 #ode: str = "r",
 #ncoding: str | None = None,
 #rrors: str | None = "strict",
 #azy: bool | None = None,
 #tomic: bool = False,
 # -> None:
 #elf.mode = mode
 #elf.encoding = encoding
 #elf.errors = errors
 #elf.lazy = lazy
 #elf.atomic = atomic

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #nfo_dict = super().to_info_dict()
 #nfo_dict.update(mode=self.mode, encoding=self.encoding)
 #eturn info_dict

 #ef resolve_lazy_flag(self, value: str | os.PathLike[str]) -> bool:
 #f self.lazy is not None:
 #eturn self.lazy
 #f os.fspath(value) == "-":
 #eturn False
 #lif "w" in self.mode:
 #eturn True
 #eturn False

 #ef convert(
 #elf,
 #alue: str | os.PathLike[str] | t.IO[t.Any],
 #aram: Parameter | None,
 #tx: Context | None,
 # -> t.IO[t.Any]:
 #f _is_file_like(value):
 #eturn value

 #alue = t.cast("str | os.PathLike[str]", value)

 #ry:
 #azy = self.resolve_lazy_flag(value)

 #f lazy:
 #f = LazyFile(
 #alue, self.mode, self.encoding, self.errors, atomic=self.atomic
 #

 #f ctx is not None:
 #tx.call_on_close(lf.close_intelligently)

 #eturn t.cast("t.IO[t.Any]", lf)

 #, should_close = open_stream(
 #alue, self.mode, self.encoding, self.errors, atomic=self.atomic
 #

            # If a context is provided, we automatically close the file
            # at the end of the context execution (or flush out).  If a
            # context does not exist, it's the caller's responsibility to
            # properly close the file.  This for instance happens when the
            # type is used with prompts.
 #f ctx is not None:
 #f should_close:
 #tx.call_on_close(safecall(f.close))
 #lse:
 #tx.call_on_close(safecall(f.flush))

 #eturn f
 #xcept OSError as e:
 #elf.fail(f"'{format_filename(value)}': {e.strerror}", param, ctx)

 #ef shell_complete(
 #elf, ctx: Context, param: Parameter, incomplete: str
 # -> list[CompletionItem]:
 #""Return a special completion marker that tells the completion
 #ystem to use the shell to provide file path completions.

 #param ctx: Invocation context for this command.
 #param param: The parameter that is requesting completion.
 #param incomplete: Value being completed. May be empty.

 #. versionadded:: 8.0
 #""
 #rom click.shell_completion import CompletionItem

 #eturn [CompletionItem(incomplete, type="file")]


def _is_file_like(value: t.Any) -> te.TypeGuard[t.IO[t.Any]]:
 #eturn hasattr(value, "read") or hasattr(value, "write")


class Path(ParamType):
 #""The ``Path`` type is similar to the :class:`File` type, but
 #eturns the filename instead of an open file. Various checks can be
 #nabled to validate the type of file and permissions.

 #param exists: The file or directory needs to exist for the value to
 #e valid. If this is not set to ``True``, and the file does not
 #xist, then all further checks are silently skipped.
 #param file_okay: Allow a file as a value.
 #param dir_okay: Allow a directory as a value.
 #param readable: if true, a readable check is performed.
 #param writable: if true, a writable check is performed.
 #param executable: if true, an executable check is performed.
 #param resolve_path: Make the value absolute and resolve any
 #ymlinks. A ``~`` is not expanded, as this is supposed to be
 #one by the shell only.
 #param allow_dash: Allow a single dash as a value, which indicates
 # standard stream (but does not open it). Use
 #func:`~click.open_file` to handle opening this value.
 #param path_type: Convert the incoming path value to this type. If
 #`None``, keep Python's default, which is ``str``. Useful to
 #onvert to :class:`pathlib.Path`.

 #. versionchanged:: 8.1
 #dded the ``executable`` parameter.

 #. versionchanged:: 8.0
 #llow passing ``path_type=pathlib.Path``.

 #. versionchanged:: 6.0
 #dded the ``allow_dash`` parameter.
 #""

 #nvvar_list_splitter: t.ClassVar[str] = os.path.pathsep

 #ef __init__(
 #elf,
 #xists: bool = False,
 #ile_okay: bool = True,
 #ir_okay: bool = True,
 #ritable: bool = False,
 #eadable: bool = True,
 #esolve_path: bool = False,
 #llow_dash: bool = False,
 #ath_type: type[t.Any] | None = None,
 #xecutable: bool = False,
 #:
 #elf.exists = exists
 #elf.file_okay = file_okay
 #elf.dir_okay = dir_okay
 #elf.readable = readable
 #elf.writable = writable
 #elf.executable = executable
 #elf.resolve_path = resolve_path
 #elf.allow_dash = allow_dash
 #elf.type = path_type

 #f self.file_okay and not self.dir_okay:
 #elf.name: str = _("file")
 #lif self.dir_okay and not self.file_okay:
 #elf.name = _("directory")
 #lse:
 #elf.name = _("path")

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #nfo_dict = super().to_info_dict()
 #nfo_dict.update(
 #xists=self.exists,
 #ile_okay=self.file_okay,
 #ir_okay=self.dir_okay,
 #ritable=self.writable,
 #eadable=self.readable,
 #llow_dash=self.allow_dash,
 #
 #eturn info_dict

 #ef coerce_path_result(
 #elf, value: str | os.PathLike[str]
 # -> str | bytes | os.PathLike[str]:
 #f self.type is not None and not isinstance(value, self.type):
 #f self.type is str:
 #eturn os.fsdecode(value)
 #lif self.type is bytes:
 #eturn os.fsencode(value)
 #lse:
 #eturn t.cast("os.PathLike[str]", self.type(value))

 #eturn value

 #ef convert(
 #elf,
 #alue: str | os.PathLike[str],
 #aram: Parameter | None,
 #tx: Context | None,
 # -> str | bytes | os.PathLike[str]:
 #v = value

 #s_dash = self.file_okay and self.allow_dash and rv in (b"-", "-")

 #f not is_dash:
 #f self.resolve_path:
 #v = os.path.realpath(rv)

 #ry:
 #t = os.stat(rv)
 #xcept OSError:
 #f not self.exists:
 #eturn self.coerce_path_result(rv)
 #elf.fail(
 #("{name} {filename!r} does not exist.").format(
 #ame=self.name.title(), filename=format_filename(value)
 #,
 #aram,
 #tx,
 #

 #f not self.file_okay and stat.S_ISREG(st.st_mode):
 #elf.fail(
 #("{name} {filename!r} is a file.").format(
 #ame=self.name.title(), filename=format_filename(value)
 #,
 #aram,
 #tx,
 #
 #f not self.dir_okay and stat.S_ISDIR(st.st_mode):
 #elf.fail(
 #("{name} {filename!r} is a directory.").format(
 #ame=self.name.title(), filename=format_filename(value)
 #,
 #aram,
 #tx,
 #

 #f self.readable and not os.access(rv, os.R_OK):
 #elf.fail(
 #("{name} {filename!r} is not readable.").format(
 #ame=self.name.title(), filename=format_filename(value)
 #,
 #aram,
 #tx,
 #

 #f self.writable and not os.access(rv, os.W_OK):
 #elf.fail(
 #("{name} {filename!r} is not writable.").format(
 #ame=self.name.title(), filename=format_filename(value)
 #,
 #aram,
 #tx,
 #

 #f self.executable and not os.access(value, os.X_OK):
 #elf.fail(
 #("{name} {filename!r} is not executable.").format(
 #ame=self.name.title(), filename=format_filename(value)
 #,
 #aram,
 #tx,
 #

 #eturn self.coerce_path_result(rv)

 #ef shell_complete(
 #elf, ctx: Context, param: Parameter, incomplete: str
 # -> list[CompletionItem]:
 #""Return a special completion marker that tells the completion
 #ystem to use the shell to provide path completions for only
 #irectories or any paths.

 #param ctx: Invocation context for this command.
 #param param: The parameter that is requesting completion.
 #param incomplete: Value being completed. May be empty.

 #. versionadded:: 8.0
 #""
 #rom click.shell_completion import CompletionItem

 #ype = "dir" if self.dir_okay and not self.file_okay else "file"
 #eturn [CompletionItem(incomplete, type=type)]


class Tuple(CompositeParamType):
 #""The default behavior of Click is to apply a type on a value directly.
 #his works well in most cases, except for when `nargs` is set to a fixed
 #ount and different types should be used for different items.  In this
 #ase the :class:`Tuple` type can be used.  This type can only be used
 #f `nargs` is set to a fixed number.

 #or more information see :ref:`tuple-type`.

 #his can be selected by using a Python tuple literal as a type.

 #param types: a list of types that should be used for the tuple items.
 #""

 #ef __init__(self, types: cabc.Sequence[type[t.Any] | ParamType]) -> None:
 #elf.types: cabc.Sequence[ParamType] = [convert_type(ty) for ty in types]

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #nfo_dict = super().to_info_dict()
 #nfo_dict["types"] = [t.to_info_dict() for t in self.types]
 #eturn info_dict

 #property
 #ef name(self) -> str:  # type: ignore
 #eturn f"<{' '.join(ty.name for ty in self.types)}>"

 #property
 #ef arity(self) -> int:  # type: ignore
 #eturn len(self.types)

 #ef convert(
 #elf, value: t.Any, param: Parameter | None, ctx: Context | None
 # -> t.Any:
 #en_type = len(self.types)
 #en_value = len(value)

 #f len_value != len_type:
 #elf.fail(
 #gettext(
 #{len_type} values are required, but {len_value} was given.",
 #{len_type} values are required, but {len_value} were given.",
 #en_value,
 #.format(len_type=len_type, len_value=len_value),
 #aram=param,
 #tx=ctx,
 #

 #eturn tuple(
 #y(x, param, ctx) for ty, x in zip(self.types, value, strict=False)
 #


def convert_type(ty: t.Any | None, default: t.Any | None = None) -> ParamType:
 #""Find the most appropriate :class:`ParamType` for the given Python
 #ype. If the type isn't provided, it can be inferred from a default
 #alue.
 #""
 #uessed_type = False

 #f ty is None and default is not None:
 #f isinstance(default, (tuple, list)):
            # If the default is empty, ty will remain None and will
            # return STRING.
 #f default:
 #tem = default[0]

                # A tuple of tuples needs to detect the inner types.
                # Can't call convert recursively because that would
                # incorrectly unwind the tuple to a single type.
 #f isinstance(item, (tuple, list)):
 #y = tuple(map(type, item))
 #lse:
 #y = type(item)
 #lse:
 #y = type(default)

 #uessed_type = True

 #f isinstance(ty, tuple):
 #eturn Tuple(ty)

 #f isinstance(ty, ParamType):
 #eturn ty

 #f ty is str or ty is None:
 #eturn STRING

 #f ty is int:
 #eturn INT

 #f ty is float:
 #eturn FLOAT

 #f ty is bool:
 #eturn BOOL

 #f guessed_type:
 #eturn STRING

 #f __debug__:
 #ry:
 #f issubclass(ty, ParamType):
 #aise AssertionError(
 #"Attempted to use an uninstantiated parameter type ({ty})."
 #
 #xcept TypeError:
            # ty is an instance (correct), so issubclass fails.
 #ass

 #eturn FuncParamType(ty)


#: A dummy parameter type that just does nothing.  From a user's
#: perspective this appears to just be the same as `STRING` but
#: internally no string conversion takes place if the input was bytes.
#: This is usually useful when working with file paths as they can
#: appear in bytes and unicode.
#:
#: For path related uses the :class:`Path` type is a better choice but
#: there are situations where an unprocessed type is useful which is why
#: it is is provided.
#:
#: .. versionadded:: 4.0
UNPROCESSED = UnprocessedParamType()

#: A unicode string parameter type which is the implicit default.  This
#: can also be selected by using ``str`` as type.
STRING = StringParamType()

#: An integer parameter.  This can also be selected by using ``int`` as
#: type.
INT = IntParamType()

#: A floating point value parameter.  This can also be selected by using
#: ``float`` as type.
FLOAT = FloatParamType()

#: A boolean parameter.  This is the default for boolean flags.  This can
#: also be selected by using ``bool`` as a type.
BOOL = BoolParamType()

#: A UUID parameter.
UUID = UUIDParameterType()


class OptionHelpExtra(t.TypedDict, total=False):
 #nvvars: tuple[str, ...]
 #efault: str
 #ange: str
 #equired: str
