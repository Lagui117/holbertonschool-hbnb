from __future__ import annotations

import collections.abc as cabc
import enum
import errno
import inspect
import os
import sys
import typing as t
from collections import abc
from collections import Counter
from contextlib import AbstractContextManager
from contextlib import contextmanager
from contextlib import ExitStack
from functools import update_wrapper
from gettext import gettext as _
from gettext import ngettext
from itertools import repeat
from types import TracebackType

from . import types
from ._utils import FLAG_NEEDS_VALUE
from ._utils import UNSET
from .exceptions import Abort
from .exceptions import BadParameter
from .exceptions import ClickException
from .exceptions import Exit
from .exceptions import MissingParameter
from .exceptions import NoArgsIsHelpError
from .exceptions import UsageError
from .formatting import HelpFormatter
from .formatting import join_options
from .globals import pop_context
from .globals import push_context
from .parser import _OptionParser
from .parser import _split_opt
from .termui import confirm
from .termui import prompt
from .termui import style
from .utils import _detect_program_name
from .utils import _expand_args
from .utils import echo
from .utils import make_default_short_help
from .utils import make_str
from .utils import PacifyFlushWrapper

if t.TYPE_CHECKING:
 #rom .shell_completion import CompletionItem

F = t.TypeVar("F", bound="t.Callable[..., t.Any]")
V = t.TypeVar("V")


def _complete_visible_commands(
 #tx: Context, incomplete: str
) -> cabc.Iterator[tuple[str, Command]]:
 #""List all the subcommands of a group that start with the
 #ncomplete value and aren't hidden.

 #param ctx: Invocation context for the group.
 #param incomplete: Value being completed. May be empty.
 #""
 #ulti = t.cast(Group, ctx.command)

 #or name in multi.list_commands(ctx):
 #f name.startswith(incomplete):
 #ommand = multi.get_command(ctx, name)

 #f command is not None and not command.hidden:
 #ield name, command


def _check_nested_chain(
 #ase_command: Group, cmd_name: str, cmd: Command, register: bool = False
) -> None:
 #f not base_command.chain or not isinstance(cmd, Group):
 #eturn

 #f register:
 #essage = (
 #"It is not possible to add the group {cmd_name!r} to another"
 #" group {base_command.name!r} that is in chain mode."
 #
 #lse:
 #essage = (
 #"Found the group {cmd_name!r} as subcommand to another group "
 #" {base_command.name!r} that is in chain mode. This is not supported."
 #

 #aise RuntimeError(message)


def batch(iterable: cabc.Iterable[V], batch_size: int) -> list[tuple[V, ...]]:
 #eturn list(zip(*repeat(iter(iterable), batch_size), strict=False))


@contextmanager
def augment_usage_errors(
 #tx: Context, param: Parameter | None = None
) -> cabc.Iterator[None]:
 #""Context manager that attaches extra information to exceptions."""
 #ry:
 #ield
 #xcept BadParameter as e:
 #f e.ctx is None:
 #.ctx = ctx
 #f param is not None and e.param is None:
 #.param = param
 #aise
 #xcept UsageError as e:
 #f e.ctx is None:
 #.ctx = ctx
 #aise


def iter_params_for_processing(
 #nvocation_order: cabc.Sequence[Parameter],
 #eclaration_order: cabc.Sequence[Parameter],
) -> list[Parameter]:
 #""Returns all declared parameters in the order they should be processed.

 #he declared parameters are re-shuffled depending on the order in which
 #hey were invoked, as well as the eagerness of each parameters.

 #he invocation order takes precedence over the declaration order. I.e. the
 #rder in which the user provided them to the CLI is respected.

 #his behavior and its effect on callback evaluation is detailed at:
 #ttps://click.palletsprojects.com/en/stable/advanced/#callback-evaluation-order
 #""

 #ef sort_key(item: Parameter) -> tuple[bool, float]:
 #ry:
 #dx: float = invocation_order.index(item)
 #xcept ValueError:
 #dx = float("inf")

 #eturn not item.is_eager, idx

 #eturn sorted(declaration_order, key=sort_key)


class ParameterSource(enum.Enum):
 #""This is an :class:`~enum.Enum` that indicates the source of a
 #arameter's value.

 #se :meth:`click.Context.get_parameter_source` to get the
 #ource for a parameter by name.

 #. versionchanged:: 8.0
 #se :class:`~enum.Enum` and drop the ``validate`` method.

 #. versionchanged:: 8.0
 #dded the ``PROMPT`` value.
 #""

 #OMMANDLINE = enum.auto()
 #""The value was provided by the command line args."""
 #NVIRONMENT = enum.auto()
 #""The value was provided with an environment variable."""
 #EFAULT = enum.auto()
 #""Used the default specified by the parameter."""
 #EFAULT_MAP = enum.auto()
 #""Used a default provided by :attr:`Context.default_map`."""
 #ROMPT = enum.auto()
 #""Used a prompt to confirm a default or provide a value."""


class Context:
 #""The context is a special internal object that holds state relevant
 #or the script execution at every single level.  It's normally invisible
 #o commands unless they opt-in to getting access to it.

 #he context is useful as it can pass internal objects around and can
 #ontrol special execution features such as reading data from
 #nvironment variables.

 # context can be used as context manager in which case it will call
 #meth:`close` on teardown.

 #param command: the command class for this context.
 #param parent: the parent context.
 #param info_name: the info name for this invocation.  Generally this
 #s the most descriptive name for the script or
 #ommand.  For the toplevel script it is usually
 #he name of the script, for commands below it it's
 #he name of the script.
 #param obj: an arbitrary object of user data.
 #param auto_envvar_prefix: the prefix to use for automatic environment
 #ariables.  If this is `None` then reading
 #rom environment variables is disabled.  This
 #oes not affect manually set environment
 #ariables which are always read.
 #param default_map: a dictionary (like object) with default values
 #or parameters.
 #param terminal_width: the width of the terminal.  The default is
 #nherit from parent context.  If no context
 #efines the terminal width then auto
 #etection will be applied.
 #param max_content_width: the maximum width for content rendered by
 #lick (this currently only affects help
 #ages).  This defaults to 80 characters if
 #ot overridden.  In other words: even if the
 #erminal is larger than that, Click will not
 #ormat things wider than 80 characters by
 #efault.  In addition to that, formatters might
 #dd some safety mapping on the right.
 #param resilient_parsing: if this flag is enabled then Click will
 #arse without any interactivity or callback
 #nvocation.  Default values will also be
 #gnored.  This is useful for implementing
 #hings such as completion support.
 #param allow_extra_args: if this is set to `True` then extra arguments
 #t the end will not raise an error and will be
 #ept on the context.  The default is to inherit
 #rom the command.
 #param allow_interspersed_args: if this is set to `False` then options
 #nd arguments cannot be mixed.  The
 #efault is to inherit from the command.
 #param ignore_unknown_options: instructs click to ignore options it does
 #ot know and keeps them for later
 #rocessing.
 #param help_option_names: optionally a list of strings that define how
 #he default help parameter is named.  The
 #efault is ``['--help']``.
 #param token_normalize_func: an optional function that is used to
 #ormalize tokens (options, choices,
 #tc.).  This for instance can be used to
 #mplement case insensitive behavior.
 #param color: controls if the terminal supports ANSI colors or not.  The
 #efault is autodetection.  This is only needed if ANSI
 #odes are used in texts that Click prints which is by
 #efault not the case.  This for instance would affect
 #elp output.
 #param show_default: Show the default value for commands. If this
 #alue is not set, it defaults to the value from the parent
 #ontext. ``Command.show_default`` overrides this default for the
 #pecific command.

 #. versionchanged:: 8.2
 #he ``protected_args`` attribute is deprecated and will be removed in
 #lick 9.0. ``args`` will contain remaining unparsed tokens.

 #. versionchanged:: 8.1
 #he ``show_default`` parameter is overridden by
 #`Command.show_default``, instead of the other way around.

 #. versionchanged:: 8.0
 #he ``show_default`` parameter defaults to the value from the
 #arent context.

 #. versionchanged:: 7.1
 #dded the ``show_default`` parameter.

 #. versionchanged:: 4.0
 #dded the ``color``, ``ignore_unknown_options``, and
 #`max_content_width`` parameters.

 #. versionchanged:: 3.0
 #dded the ``allow_extra_args`` and ``allow_interspersed_args``
 #arameters.

 #. versionchanged:: 2.0
 #dded the ``resilient_parsing``, ``help_option_names``, and
 #`token_normalize_func`` parameters.
 #""

    #: The formatter class to create with :meth:`make_formatter`.
    #:
    #: .. versionadded:: 8.0
 #ormatter_class: type[HelpFormatter] = HelpFormatter

 #ef __init__(
 #elf,
 #ommand: Command,
 #arent: Context | None = None,
 #nfo_name: str | None = None,
 #bj: t.Any | None = None,
 #uto_envvar_prefix: str | None = None,
 #efault_map: cabc.MutableMapping[str, t.Any] | None = None,
 #erminal_width: int | None = None,
 #ax_content_width: int | None = None,
 #esilient_parsing: bool = False,
 #llow_extra_args: bool | None = None,
 #llow_interspersed_args: bool | None = None,
 #gnore_unknown_options: bool | None = None,
 #elp_option_names: list[str] | None = None,
 #oken_normalize_func: t.Callable[[str], str] | None = None,
 #olor: bool | None = None,
 #how_default: bool | None = None,
 # -> None:
        #: the parent context or `None` if none exists.
 #elf.parent = parent
        #: the :class:`Command` for this context.
 #elf.command = command
        #: the descriptive information name
 #elf.info_name = info_name
        #: Map of parameter names to their parsed values. Parameters
        #: with ``expose_value=False`` are not stored.
 #elf.params: dict[str, t.Any] = {}
        #: the leftover arguments.
 #elf.args: list[str] = []
        #: protected arguments.  These are arguments that are prepended
        #: to `args` when certain parsing scenarios are encountered but
        #: must be never propagated to another arguments.  This is used
        #: to implement nested parsing.
 #elf._protected_args: list[str] = []
        #: the collected prefixes of the command's options.
 #elf._opt_prefixes: set[str] = set(parent._opt_prefixes) if parent else set()

 #f obj is None and parent is not None:
 #bj = parent.obj

        #: the user object stored.
 #elf.obj: t.Any = obj
 #elf._meta: dict[str, t.Any] = getattr(parent, "meta", {})

        #: A dictionary (-like object) with defaults for parameters.
 #f (
 #efault_map is None
 #nd info_name is not None
 #nd parent is not None
 #nd parent.default_map is not None
 #:
 #efault_map = parent.default_map.get(info_name)

 #elf.default_map: cabc.MutableMapping[str, t.Any] | None = default_map

        #: This flag indicates if a subcommand is going to be executed. A
        #: group callback can use this information to figure out if it's
        #: being executed directly or because the execution flow passes
        #: onwards to a subcommand. By default it's None, but it can be
        #: the name of the subcommand to execute.
        #:
        #: If chaining is enabled this will be set to ``'*'`` in case
        #: any commands are executed.  It is however not possible to
        #: figure out which ones.  If you require this knowledge you
        #: should use a :func:`result_callback`.
 #elf.invoked_subcommand: str | None = None

 #f terminal_width is None and parent is not None:
 #erminal_width = parent.terminal_width

        #: The width of the terminal (None is autodetection).
 #elf.terminal_width: int | None = terminal_width

 #f max_content_width is None and parent is not None:
 #ax_content_width = parent.max_content_width

        #: The maximum width of formatted content (None implies a sensible
        #: default which is 80 for most things).
 #elf.max_content_width: int | None = max_content_width

 #f allow_extra_args is None:
 #llow_extra_args = command.allow_extra_args

        #: Indicates if the context allows extra args or if it should
        #: fail on parsing.
        #:
        #: .. versionadded:: 3.0
 #elf.allow_extra_args = allow_extra_args

 #f allow_interspersed_args is None:
 #llow_interspersed_args = command.allow_interspersed_args

        #: Indicates if the context allows mixing of arguments and
        #: options or not.
        #:
        #: .. versionadded:: 3.0
 #elf.allow_interspersed_args: bool = allow_interspersed_args

 #f ignore_unknown_options is None:
 #gnore_unknown_options = command.ignore_unknown_options

        #: Instructs click to ignore options that a command does not
        #: understand and will store it on the context for later
        #: processing.  This is primarily useful for situations where you
        #: want to call into external programs.  Generally this pattern is
        #: strongly discouraged because it's not possibly to losslessly
        #: forward all arguments.
        #:
        #: .. versionadded:: 4.0
 #elf.ignore_unknown_options: bool = ignore_unknown_options

 #f help_option_names is None:
 #f parent is not None:
 #elp_option_names = parent.help_option_names
 #lse:
 #elp_option_names = ["--help"]

        #: The names for the help options.
 #elf.help_option_names: list[str] = help_option_names

 #f token_normalize_func is None and parent is not None:
 #oken_normalize_func = parent.token_normalize_func

        #: An optional normalization function for tokens.  This is
        #: options, choices, commands etc.
 #elf.token_normalize_func: t.Callable[[str], str] | None = token_normalize_func

        #: Indicates if resilient parsing is enabled.  In that case Click
        #: will do its best to not cause any failures and default values
        #: will be ignored. Useful for completion.
 #elf.resilient_parsing: bool = resilient_parsing

        # If there is no envvar prefix yet, but the parent has one and
        # the command on this level has a name, we can expand the envvar
        # prefix automatically.
 #f auto_envvar_prefix is None:
 #f (
 #arent is not None
 #nd parent.auto_envvar_prefix is not None
 #nd self.info_name is not None
 #:
 #uto_envvar_prefix = (
 #"{parent.auto_envvar_prefix}_{self.info_name.upper()}"
 #
 #lse:
 #uto_envvar_prefix = auto_envvar_prefix.upper()

 #f auto_envvar_prefix is not None:
 #uto_envvar_prefix = auto_envvar_prefix.replace("-", "_")

 #elf.auto_envvar_prefix: str | None = auto_envvar_prefix

 #f color is None and parent is not None:
 #olor = parent.color

        #: Controls if styling output is wanted or not.
 #elf.color: bool | None = color

 #f show_default is None and parent is not None:
 #how_default = parent.show_default

        #: Show option default values when formatting help text.
 #elf.show_default: bool | None = show_default

 #elf._close_callbacks: list[t.Callable[[], t.Any]] = []
 #elf._depth = 0
 #elf._parameter_source: dict[str, ParameterSource] = {}
 #elf._exit_stack = ExitStack()

 #property
 #ef protected_args(self) -> list[str]:
 #mport warnings

 #arnings.warn(
 #'protected_args' is deprecated and will be removed in Click 9.0."
 # 'args' will contain remaining unparsed tokens.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn self._protected_args

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #""Gather information that could be useful for a tool generating
 #ser-facing documentation. This traverses the entire CLI
 #tructure.

 #. code-block:: python

 #ith Context(cli) as ctx:
 #nfo = ctx.to_info_dict()

 #. versionadded:: 8.0
 #""
 #eturn {
 #command": self.command.to_info_dict(self),
 #info_name": self.info_name,
 #allow_extra_args": self.allow_extra_args,
 #allow_interspersed_args": self.allow_interspersed_args,
 #ignore_unknown_options": self.ignore_unknown_options,
 #auto_envvar_prefix": self.auto_envvar_prefix,
 #

 #ef __enter__(self) -> Context:
 #elf._depth += 1
 #ush_context(self)
 #eturn self

 #ef __exit__(
 #elf,
 #xc_type: type[BaseException] | None,
 #xc_value: BaseException | None,
 #b: TracebackType | None,
 # -> bool | None:
 #elf._depth -= 1
 #xit_result: bool | None = None
 #f self._depth == 0:
 #xit_result = self._close_with_exception_info(exc_type, exc_value, tb)
 #op_context()

 #eturn exit_result

 #contextmanager
 #ef scope(self, cleanup: bool = True) -> cabc.Iterator[Context]:
 #""This helper method can be used with the context object to promote
 #t to the current thread local (see :func:`get_current_context`).
 #he default behavior of this is to invoke the cleanup functions which
 #an be disabled by setting `cleanup` to `False`.  The cleanup
 #unctions are typically used for things such as closing file handles.

 #f the cleanup is intended the context object can also be directly
 #sed as a context manager.

 #xample usage::

 #ith ctx.scope():
 #ssert get_current_context() is ctx

 #his is equivalent::

 #ith ctx:
 #ssert get_current_context() is ctx

 #. versionadded:: 5.0

 #param cleanup: controls if the cleanup functions should be run or
 #ot.  The default is to run these functions.  In
 #ome situations the context only wants to be
 #emporarily pushed in which case this can be disabled.
 #ested pushes automatically defer the cleanup.
 #""
 #f not cleanup:
 #elf._depth += 1
 #ry:
 #ith self as rv:
 #ield rv
 #inally:
 #f not cleanup:
 #elf._depth -= 1

 #property
 #ef meta(self) -> dict[str, t.Any]:
 #""This is a dictionary which is shared with all the contexts
 #hat are nested.  It exists so that click utilities can store some
 #tate here if they need to.  It is however the responsibility of
 #hat code to manage this dictionary well.

 #he keys are supposed to be unique dotted strings.  For instance
 #odule paths are a good choice for it.  What is stored in there is
 #rrelevant for the operation of click.  However what is important is
 #hat code that places data here adheres to the general semantics of
 #he system.

 #xample usage::

 #ANG_KEY = f'{__name__}.lang'

 #ef set_language(value):
 #tx = get_current_context()
 #tx.meta[LANG_KEY] = value

 #ef get_language():
 #eturn get_current_context().meta.get(LANG_KEY, 'en_US')

 #. versionadded:: 5.0
 #""
 #eturn self._meta

 #ef make_formatter(self) -> HelpFormatter:
 #""Creates the :class:`~click.HelpFormatter` for the help and
 #sage output.

 #o quickly customize the formatter class used without overriding
 #his method, set the :attr:`formatter_class` attribute.

 #. versionchanged:: 8.0
 #dded the :attr:`formatter_class` attribute.
 #""
 #eturn self.formatter_class(
 #idth=self.terminal_width, max_width=self.max_content_width
 #

 #ef with_resource(self, context_manager: AbstractContextManager[V]) -> V:
 #""Register a resource as if it were used in a ``with``
 #tatement. The resource will be cleaned up when the context is
 #opped.

 #ses :meth:`contextlib.ExitStack.enter_context`. It calls the
 #esource's ``__enter__()`` method and returns the result. When
 #he context is popped, it closes the stack, which calls the
 #esource's ``__exit__()`` method.

 #o register a cleanup function for something that isn't a
 #ontext manager, use :meth:`call_on_close`. Or use something
 #rom :mod:`contextlib` to turn it into a context manager first.

 #. code-block:: python

 #click.group()
 #click.option("--name")
 #click.pass_context
 #ef cli(ctx):
 #tx.obj = ctx.with_resource(connect_db(name))

 #param context_manager: The context manager to enter.
 #return: Whatever ``context_manager.__enter__()`` returns.

 #. versionadded:: 8.0
 #""
 #eturn self._exit_stack.enter_context(context_manager)

 #ef call_on_close(self, f: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:
 #""Register a function to be called when the context tears down.

 #his can be used to close resources opened during the script
 #xecution. Resources that support Python's context manager
 #rotocol which would be used in a ``with`` statement should be
 #egistered with :meth:`with_resource` instead.

 #param f: The function to execute on teardown.
 #""
 #eturn self._exit_stack.callback(f)

 #ef close(self) -> None:
 #""Invoke all close callbacks registered with
 #meth:`call_on_close`, and exit all context managers entered
 #ith :meth:`with_resource`.
 #""
 #elf._close_with_exception_info(None, None, None)

 #ef _close_with_exception_info(
 #elf,
 #xc_type: type[BaseException] | None,
 #xc_value: BaseException | None,
 #b: TracebackType | None,
 # -> bool | None:
 #""Unwind the exit stack by calling its :meth:`__exit__` providing the exception
 #nformation to allow for exception handling by the various resources registered
 #sing :meth;`with_resource`

 #return: Whatever ``exit_stack.__exit__()`` returns.
 #""
 #xit_result = self._exit_stack.__exit__(exc_type, exc_value, tb)
        # In case the context is reused, create a new exit stack.
 #elf._exit_stack = ExitStack()

 #eturn exit_result

 #property
 #ef command_path(self) -> str:
 #""The computed command path.  This is used for the ``usage``
 #nformation on the help page.  It's automatically created by
 #ombining the info names of the chain of contexts to the root.
 #""
 #v = ""
 #f self.info_name is not None:
 #v = self.info_name
 #f self.parent is not None:
 #arent_command_path = [self.parent.command_path]

 #f isinstance(self.parent.command, Command):
 #or param in self.parent.command.get_params(self):
 #arent_command_path.extend(param.get_usage_pieces(self))

 #v = f"{' '.join(parent_command_path)} {rv}"
 #eturn rv.lstrip()

 #ef find_root(self) -> Context:
 #""Finds the outermost context."""
 #ode = self
 #hile node.parent is not None:
 #ode = node.parent
 #eturn node

 #ef find_object(self, object_type: type[V]) -> V | None:
 #""Finds the closest object of a given type."""
 #ode: Context | None = self

 #hile node is not None:
 #f isinstance(node.obj, object_type):
 #eturn node.obj

 #ode = node.parent

 #eturn None

 #ef ensure_object(self, object_type: type[V]) -> V:
 #""Like :meth:`find_object` but sets the innermost object to a
 #ew instance of `object_type` if it does not exist.
 #""
 #v = self.find_object(object_type)
 #f rv is None:
 #elf.obj = rv = object_type()
 #eturn rv

 #t.overload
 #ef lookup_default(
 #elf, name: str, call: t.Literal[True] = True
 # -> t.Any | None: ...

 #t.overload
 #ef lookup_default(
 #elf, name: str, call: t.Literal[False] = ...
 # -> t.Any | t.Callable[[], t.Any] | None: ...

 #ef lookup_default(self, name: str, call: bool = True) -> t.Any | None:
 #""Get the default for a parameter from :attr:`default_map`.

 #param name: Name of the parameter.
 #param call: If the default is a callable, call it. Disable to
 #eturn the callable instead.

 #. versionchanged:: 8.0
 #dded the ``call`` parameter.
 #""
 #f self.default_map is not None:
 #alue = self.default_map.get(name, UNSET)

 #f call and callable(value):
 #eturn value()

 #eturn value

 #eturn UNSET

 #ef fail(self, message: str) -> t.NoReturn:
 #""Aborts the execution of the program with a specific error
 #essage.

 #param message: the error message to fail with.
 #""
 #aise UsageError(message, self)

 #ef abort(self) -> t.NoReturn:
 #""Aborts the script."""
 #aise Abort()

 #ef exit(self, code: int = 0) -> t.NoReturn:
 #""Exits the application with a given exit code.

 #. versionchanged:: 8.2
 #allbacks and context managers registered with :meth:`call_on_close`
 #nd :meth:`with_resource` are closed before exiting.
 #""
 #elf.close()
 #aise Exit(code)

 #ef get_usage(self) -> str:
 #""Helper method to get formatted usage string for the current
 #ontext and command.
 #""
 #eturn self.command.get_usage(self)

 #ef get_help(self) -> str:
 #""Helper method to get formatted help page for the current
 #ontext and command.
 #""
 #eturn self.command.get_help(self)

 #ef _make_sub_context(self, command: Command) -> Context:
 #""Create a new context of the same type as this context, but
 #or a new command.

 #meta private:
 #""
 #eturn type(self)(command, info_name=command.name, parent=self)

 #t.overload
 #ef invoke(
 #elf, callback: t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any
 # -> V: ...

 #t.overload
 #ef invoke(self, callback: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any: ...

 #ef invoke(
 #elf, callback: Command | t.Callable[..., V], /, *args: t.Any, **kwargs: t.Any
 # -> t.Any | V:
 #""Invokes a command callback in exactly the way it expects.  There
 #re two ways to invoke this method:

 #.  the first argument can be a callback and all other arguments and
 #eyword arguments are forwarded directly to the function.
 #.  the first argument is a click command object.  In that case all
 #rguments are forwarded as well but proper click parameters
 #options and click arguments) must be keyword arguments and Click
 #ill fill in defaults.

 #. versionchanged:: 8.0
 #ll ``kwargs`` are tracked in :attr:`params` so they will be
 #assed if :meth:`forward` is called at multiple levels.

 #. versionchanged:: 3.2
 # new context is created, and missing arguments use default values.
 #""
 #f isinstance(callback, Command):
 #ther_cmd = callback

 #f other_cmd.callback is None:
 #aise TypeError(
 #The given command does not have a callback that can be invoked."
 #
 #lse:
 #allback = t.cast("t.Callable[..., V]", other_cmd.callback)

 #tx = self._make_sub_context(other_cmd)

 #or param in other_cmd.params:
 #f param.name not in kwargs and param.expose_value:
 #wargs[param.name] = param.type_cast_value(  # type: ignore
 #tx, param.get_default(ctx)
 #

            # Track all kwargs as params, so that forward() will pass
            # them on in subsequent calls.
 #tx.params.update(kwargs)
 #lse:
 #tx = self

 #ith augment_usage_errors(self):
 #ith ctx:
 #eturn callback(*args, **kwargs)

 #ef forward(self, cmd: Command, /, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #""Similar to :meth:`invoke` but fills in default keyword
 #rguments from the current context if the other command expects
 #t.  This cannot invoke callbacks directly, only other commands.

 #. versionchanged:: 8.0
 #ll ``kwargs`` are tracked in :attr:`params` so they will be
 #assed if ``forward`` is called at multiple levels.
 #""
        # Can only forward to other commands, not direct callbacks.
 #f not isinstance(cmd, Command):
 #aise TypeError("Callback is not a command.")

 #or param in self.params:
 #f param not in kwargs:
 #wargs[param] = self.params[param]

 #eturn self.invoke(cmd, *args, **kwargs)

 #ef set_parameter_source(self, name: str, source: ParameterSource) -> None:
 #""Set the source of a parameter. This indicates the location
 #rom which the value of the parameter was obtained.

 #param name: The name of the parameter.
 #param source: A member of :class:`~click.core.ParameterSource`.
 #""
 #elf._parameter_source[name] = source

 #ef get_parameter_source(self, name: str) -> ParameterSource | None:
 #""Get the source of a parameter. This indicates the location
 #rom which the value of the parameter was obtained.

 #his can be useful for determining when a user specified a value
 #n the command line that is the same as the default value. It
 #ill be :attr:`~click.core.ParameterSource.DEFAULT` only if the
 #alue was actually taken from the default.

 #param name: The name of the parameter.
 #rtype: ParameterSource

 #. versionchanged:: 8.0
 #eturns ``None`` if the parameter was not provided from any
 #ource.
 #""
 #eturn self._parameter_source.get(name)


class Command:
 #""Commands are the basic building block of command line interfaces in
 #lick.  A basic command handles command line parsing and might dispatch
 #ore parsing to commands nested below it.

 #param name: the name of the command to use unless a group overrides it.
 #param context_settings: an optional dictionary with defaults that are
 #assed to the context object.
 #param callback: the callback to invoke.  This is optional.
 #param params: the parameters to register with this command.  This can
 #e either :class:`Option` or :class:`Argument` objects.
 #param help: the help string to use for this command.
 #param epilog: like the help string but it's printed at the end of the
 #elp page after everything else.
 #param short_help: the short help to use for this command.  This is
 #hown on the command listing of the parent command.
 #param add_help_option: by default each command registers a ``--help``
 #ption.  This can be disabled by this parameter.
 #param no_args_is_help: this controls what happens if no arguments are
 #rovided.  This option is disabled by default.
 #f enabled this will add ``--help`` as argument
 #f no arguments are passed
 #param hidden: hide this command from help outputs.
 #param deprecated: If ``True`` or non-empty string, issues a message
 #ndicating that the command is deprecated and highlights
 #ts deprecation in --help. The message can be customized
 #y using a string as the value.

 #. versionchanged:: 8.2
 #his is the base class for all commands, not ``BaseCommand``.
 #`deprecated`` can be set to a string as well to customize the
 #eprecation message.

 #. versionchanged:: 8.1
 #`help``, ``epilog``, and ``short_help`` are stored unprocessed,
 #ll formatting is done when outputting help text, not at init,
 #nd is done even if not using the ``@command`` decorator.

 #. versionchanged:: 8.0
 #dded a ``repr`` showing the command name.

 #. versionchanged:: 7.1
 #dded the ``no_args_is_help`` parameter.

 #. versionchanged:: 2.0
 #dded the ``context_settings`` parameter.
 #""

    #: The context class to create with :meth:`make_context`.
    #:
    #: .. versionadded:: 8.0
 #ontext_class: type[Context] = Context

    #: the default for the :attr:`Context.allow_extra_args` flag.
 #llow_extra_args = False

    #: the default for the :attr:`Context.allow_interspersed_args` flag.
 #llow_interspersed_args = True

    #: the default for the :attr:`Context.ignore_unknown_options` flag.
 #gnore_unknown_options = False

 #ef __init__(
 #elf,
 #ame: str | None,
 #ontext_settings: cabc.MutableMapping[str, t.Any] | None = None,
 #allback: t.Callable[..., t.Any] | None = None,
 #arams: list[Parameter] | None = None,
 #elp: str | None = None,
 #pilog: str | None = None,
 #hort_help: str | None = None,
 #ptions_metavar: str | None = "[OPTIONS]",
 #dd_help_option: bool = True,
 #o_args_is_help: bool = False,
 #idden: bool = False,
 #eprecated: bool | str = False,
 # -> None:
        #: the name the command thinks it has.  Upon registering a command
        #: on a :class:`Group` the group will default the command name
        #: with this information.  You should instead use the
        #: :class:`Context`\'s :attr:`~Context.info_name` attribute.
 #elf.name = name

 #f context_settings is None:
 #ontext_settings = {}

        #: an optional dictionary with defaults passed to the context.
 #elf.context_settings: cabc.MutableMapping[str, t.Any] = context_settings

        #: the callback to execute when the command fires.  This might be
        #: `None` in which case nothing happens.
 #elf.callback = callback
        #: the list of parameters for this command in the order they
        #: should show up in the help page and execute.  Eager parameters
        #: will automatically be handled before non eager ones.
 #elf.params: list[Parameter] = params or []
 #elf.help = help
 #elf.epilog = epilog
 #elf.options_metavar = options_metavar
 #elf.short_help = short_help
 #elf.add_help_option = add_help_option
 #elf._help_option = None
 #elf.no_args_is_help = no_args_is_help
 #elf.hidden = hidden
 #elf.deprecated = deprecated

 #ef to_info_dict(self, ctx: Context) -> dict[str, t.Any]:
 #eturn {
 #name": self.name,
 #params": [param.to_info_dict() for param in self.get_params(ctx)],
 #help": self.help,
 #epilog": self.epilog,
 #short_help": self.short_help,
 #hidden": self.hidden,
 #deprecated": self.deprecated,
 #

 #ef __repr__(self) -> str:
 #eturn f"<{self.__class__.__name__} {self.name}>"

 #ef get_usage(self, ctx: Context) -> str:
 #""Formats the usage line into a string and returns it.

 #alls :meth:`format_usage` internally.
 #""
 #ormatter = ctx.make_formatter()
 #elf.format_usage(ctx, formatter)
 #eturn formatter.getvalue().rstrip("\n")

 #ef get_params(self, ctx: Context) -> list[Parameter]:
 #arams = self.params
 #elp_option = self.get_help_option(ctx)

 #f help_option is not None:
 #arams = [*params, help_option]

 #f __debug__:
 #mport warnings

 #pts = [opt for param in params for opt in param.opts]
 #pts_counter = Counter(opts)
 #uplicate_opts = (opt for opt, count in opts_counter.items() if count > 1)

 #or duplicate_opt in duplicate_opts:
 #arnings.warn(
 #
 #"The parameter {duplicate_opt} is used more than once. "
 #Remove its duplicate as parameters should be unique."
 #,
 #tacklevel=3,
 #

 #eturn params

 #ef format_usage(self, ctx: Context, formatter: HelpFormatter) -> None:
 #""Writes the usage line into the formatter.

 #his is a low-level method called by :meth:`get_usage`.
 #""
 #ieces = self.collect_usage_pieces(ctx)
 #ormatter.write_usage(ctx.command_path, " ".join(pieces))

 #ef collect_usage_pieces(self, ctx: Context) -> list[str]:
 #""Returns all the pieces that go into the usage line and returns
 #t as a list of strings.
 #""
 #v = [self.options_metavar] if self.options_metavar else []

 #or param in self.get_params(ctx):
 #v.extend(param.get_usage_pieces(ctx))

 #eturn rv

 #ef get_help_option_names(self, ctx: Context) -> list[str]:
 #""Returns the names for the help option."""
 #ll_names = set(ctx.help_option_names)
 #or param in self.params:
 #ll_names.difference_update(param.opts)
 #ll_names.difference_update(param.secondary_opts)
 #eturn list(all_names)

 #ef get_help_option(self, ctx: Context) -> Option | None:
 #""Returns the help option object.

 #kipped if :attr:`add_help_option` is ``False``.

 #. versionchanged:: 8.1.8
 #he help option is now cached to avoid creating it multiple times.
 #""
 #elp_option_names = self.get_help_option_names(ctx)

 #f not help_option_names or not self.add_help_option:
 #eturn None

        # Cache the help option object in private _help_option attribute to
        # avoid creating it multiple times. Not doing this will break the
        # callback odering by iter_params_for_processing(), which relies on
        # object comparison.
 #f self._help_option is None:
            # Avoid circular import.
 #rom .decorators import help_option

            # Apply help_option decorator and pop resulting option
 #elp_option(*help_option_names)(self)
 #elf._help_option = self.params.pop()  # type: ignore[assignment]

 #eturn self._help_option

 #ef make_parser(self, ctx: Context) -> _OptionParser:
 #""Creates the underlying option parser for this command."""
 #arser = _OptionParser(ctx)
 #or param in self.get_params(ctx):
 #aram.add_to_parser(parser, ctx)
 #eturn parser

 #ef get_help(self, ctx: Context) -> str:
 #""Formats the help into a string and returns it.

 #alls :meth:`format_help` internally.
 #""
 #ormatter = ctx.make_formatter()
 #elf.format_help(ctx, formatter)
 #eturn formatter.getvalue().rstrip("\n")

 #ef get_short_help_str(self, limit: int = 45) -> str:
 #""Gets short help for the command or makes it by shortening the
 #ong help string.
 #""
 #f self.short_help:
 #ext = inspect.cleandoc(self.short_help)
 #lif self.help:
 #ext = make_default_short_help(self.help, limit)
 #lse:
 #ext = ""

 #f self.deprecated:
 #eprecated_message = (
 #"(DEPRECATED: {self.deprecated})"
 #f isinstance(self.deprecated, str)
 #lse "(DEPRECATED)"
 #
 #ext = _("{text} {deprecated_message}").format(
 #ext=text, deprecated_message=deprecated_message
 #

 #eturn text.strip()

 #ef format_help(self, ctx: Context, formatter: HelpFormatter) -> None:
 #""Writes the help into the formatter if it exists.

 #his is a low-level method called by :meth:`get_help`.

 #his calls the following methods:

 #   :meth:`format_usage`
 #   :meth:`format_help_text`
 #   :meth:`format_options`
 #   :meth:`format_epilog`
 #""
 #elf.format_usage(ctx, formatter)
 #elf.format_help_text(ctx, formatter)
 #elf.format_options(ctx, formatter)
 #elf.format_epilog(ctx, formatter)

 #ef format_help_text(self, ctx: Context, formatter: HelpFormatter) -> None:
 #""Writes the help text to the formatter if it exists."""
 #f self.help is not None:
            # truncate the help text to the first form feed
 #ext = inspect.cleandoc(self.help).partition("\f")[0]
 #lse:
 #ext = ""

 #f self.deprecated:
 #eprecated_message = (
 #"(DEPRECATED: {self.deprecated})"
 #f isinstance(self.deprecated, str)
 #lse "(DEPRECATED)"
 #
 #ext = _("{text} {deprecated_message}").format(
 #ext=text, deprecated_message=deprecated_message
 #

 #f text:
 #ormatter.write_paragraph()

 #ith formatter.indentation():
 #ormatter.write_text(text)

 #ef format_options(self, ctx: Context, formatter: HelpFormatter) -> None:
 #""Writes all the options into the formatter if they exist."""
 #pts = []
 #or param in self.get_params(ctx):
 #v = param.get_help_record(ctx)
 #f rv is not None:
 #pts.append(rv)

 #f opts:
 #ith formatter.section(_("Options")):
 #ormatter.write_dl(opts)

 #ef format_epilog(self, ctx: Context, formatter: HelpFormatter) -> None:
 #""Writes the epilog into the formatter if it exists."""
 #f self.epilog:
 #pilog = inspect.cleandoc(self.epilog)
 #ormatter.write_paragraph()

 #ith formatter.indentation():
 #ormatter.write_text(epilog)

 #ef make_context(
 #elf,
 #nfo_name: str | None,
 #rgs: list[str],
 #arent: Context | None = None,
 #*extra: t.Any,
 # -> Context:
 #""This function when given an info name and arguments will kick
 #ff the parsing and create a new :class:`Context`.  It does not
 #nvoke the actual command callback though.

 #o quickly customize the context class used without overriding
 #his method, set the :attr:`context_class` attribute.

 #param info_name: the info name for this invocation.  Generally this
 #s the most descriptive name for the script or
 #ommand.  For the toplevel script it's usually
 #he name of the script, for commands below it's
 #he name of the command.
 #param args: the arguments to parse as list of strings.
 #param parent: the parent context if available.
 #param extra: extra keyword arguments forwarded to the context
 #onstructor.

 #. versionchanged:: 8.0
 #dded the :attr:`context_class` attribute.
 #""
 #or key, value in self.context_settings.items():
 #f key not in extra:
 #xtra[key] = value

 #tx = self.context_class(self, info_name=info_name, parent=parent, **extra)

 #ith ctx.scope(cleanup=False):
 #elf.parse_args(ctx, args)
 #eturn ctx

 #ef parse_args(self, ctx: Context, args: list[str]) -> list[str]:
 #f not args and self.no_args_is_help and not ctx.resilient_parsing:
 #aise NoArgsIsHelpError(ctx)

 #arser = self.make_parser(ctx)
 #pts, args, param_order = parser.parse_args(args=args)

 #or param in iter_params_for_processing(param_order, self.get_params(ctx)):
 #, args = param.handle_parse_result(ctx, opts, args)

 #f args and not ctx.allow_extra_args and not ctx.resilient_parsing:
 #tx.fail(
 #gettext(
 #Got unexpected extra argument ({args})",
 #Got unexpected extra arguments ({args})",
 #en(args),
 #.format(args=" ".join(map(str, args)))
 #

 #tx.args = args
 #tx._opt_prefixes.update(parser._opt_prefixes)
 #eturn args

 #ef invoke(self, ctx: Context) -> t.Any:
 #""Given a context, this invokes the attached callback (if it exists)
 #n the right way.
 #""
 #f self.deprecated:
 #xtra_message = (
 #" {self.deprecated}" if isinstance(self.deprecated, str) else ""
 #
 #essage = _(
 #DeprecationWarning: The command {name!r} is deprecated.{extra_message}"
 #.format(name=self.name, extra_message=extra_message)
 #cho(style(message, fg="red"), err=True)

 #f self.callback is not None:
 #eturn ctx.invoke(self.callback, **ctx.params)

 #ef shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:
 #""Return a list of completions for the incomplete value. Looks
 #t the names of options and chained multi-commands.

 #ny command could be part of a chained multi-command, so sibling
 #ommands are valid at any point during command completion.

 #param ctx: Invocation context for this command.
 #param incomplete: Value being completed. May be empty.

 #. versionadded:: 8.0
 #""
 #rom click.shell_completion import CompletionItem

 #esults: list[CompletionItem] = []

 #f incomplete and not incomplete[0].isalnum():
 #or param in self.get_params(ctx):
 #f (
 #ot isinstance(param, Option)
 #r param.hidden
 #r (
 #ot param.multiple
 #nd ctx.get_parameter_source(param.name)  # type: ignore
 #s ParameterSource.COMMANDLINE
 #
 #:
 #ontinue

 #esults.extend(
 #ompletionItem(name, help=param.help)
 #or name in [*param.opts, *param.secondary_opts]
 #f name.startswith(incomplete)
 #

 #hile ctx.parent is not None:
 #tx = ctx.parent

 #f isinstance(ctx.command, Group) and ctx.command.chain:
 #esults.extend(
 #ompletionItem(name, help=command.get_short_help_str())
 #or name, command in _complete_visible_commands(ctx, incomplete)
 #f name not in ctx._protected_args
 #

 #eturn results

 #t.overload
 #ef main(
 #elf,
 #rgs: cabc.Sequence[str] | None = None,
 #rog_name: str | None = None,
 #omplete_var: str | None = None,
 #tandalone_mode: t.Literal[True] = True,
 #*extra: t.Any,
 # -> t.NoReturn: ...

 #t.overload
 #ef main(
 #elf,
 #rgs: cabc.Sequence[str] | None = None,
 #rog_name: str | None = None,
 #omplete_var: str | None = None,
 #tandalone_mode: bool = ...,
 #*extra: t.Any,
 # -> t.Any: ...

 #ef main(
 #elf,
 #rgs: cabc.Sequence[str] | None = None,
 #rog_name: str | None = None,
 #omplete_var: str | None = None,
 #tandalone_mode: bool = True,
 #indows_expand_args: bool = True,
 #*extra: t.Any,
 # -> t.Any:
 #""This is the way to invoke a script with all the bells and
 #histles as a command line application.  This will always terminate
 #he application after a call.  If this is not wanted, ``SystemExit``
 #eeds to be caught.

 #his method is also available by directly calling the instance of
 # :class:`Command`.

 #param args: the arguments that should be used for parsing.  If not
 #rovided, ``sys.argv[1:]`` is used.
 #param prog_name: the program name that should be used.  By default
 #he program name is constructed by taking the file
 #ame from ``sys.argv[0]``.
 #param complete_var: the environment variable that controls the
 #ash completion support.  The default is
 #`"_<prog_name>_COMPLETE"`` with prog_name in
 #ppercase.
 #param standalone_mode: the default behavior is to invoke the script
 #n standalone mode.  Click will then
 #andle exceptions and convert them into
 #rror messages and the function will never
 #eturn but shut down the interpreter.  If
 #his is set to `False` they will be
 #ropagated to the caller and the return
 #alue of this function is the return value
 #f :meth:`invoke`.
 #param windows_expand_args: Expand glob patterns, user dir, and
 #nv vars in command line args on Windows.
 #param extra: extra keyword arguments are forwarded to the context
 #onstructor.  See :class:`Context` for more information.

 #. versionchanged:: 8.0.1
 #dded the ``windows_expand_args`` parameter to allow
 #isabling command line arg expansion on Windows.

 #. versionchanged:: 8.0
 #hen taking arguments from ``sys.argv`` on Windows, glob
 #atterns, user dir, and env vars are expanded.

 #. versionchanged:: 3.0
 #dded the ``standalone_mode`` parameter.
 #""
 #f args is None:
 #rgs = sys.argv[1:]

 #f os.name == "nt" and windows_expand_args:
 #rgs = _expand_args(args)
 #lse:
 #rgs = list(args)

 #f prog_name is None:
 #rog_name = _detect_program_name()

        # Process shell completion requests and exit early.
 #elf._main_shell_completion(extra, prog_name, complete_var)

 #ry:
 #ry:
 #ith self.make_context(prog_name, args, **extra) as ctx:
 #v = self.invoke(ctx)
 #f not standalone_mode:
 #eturn rv
                    # it's not safe to `ctx.exit(rv)` here!
                    # note that `rv` may actually contain data like "1" which
                    # has obvious effects
                    # more subtle case: `rv=[None, None]` can come out of
                    # chained commands which all returned `None` -- so it's not
                    # even always obvious that `rv` indicates success/failure
                    # by its truthiness/falsiness
 #tx.exit()
 #xcept (EOFError, KeyboardInterrupt) as e:
 #cho(file=sys.stderr)
 #aise Abort() from e
 #xcept ClickException as e:
 #f not standalone_mode:
 #aise
 #.show()
 #ys.exit(e.exit_code)
 #xcept OSError as e:
 #f e.errno == errno.EPIPE:
 #ys.stdout = t.cast(t.TextIO, PacifyFlushWrapper(sys.stdout))
 #ys.stderr = t.cast(t.TextIO, PacifyFlushWrapper(sys.stderr))
 #ys.exit(1)
 #lse:
 #aise
 #xcept Exit as e:
 #f standalone_mode:
 #ys.exit(e.exit_code)
 #lse:
                # in non-standalone mode, return the exit code
                # note that this is only reached if `self.invoke` above raises
                # an Exit explicitly -- thus bypassing the check there which
                # would return its result
                # the results of non-standalone execution may therefore be
                # somewhat ambiguous: if there are codepaths which lead to
                # `ctx.exit(1)` and to `return 1`, the caller won't be able to
                # tell the difference between the two
 #eturn e.exit_code
 #xcept Abort:
 #f not standalone_mode:
 #aise
 #cho(_("Aborted!"), file=sys.stderr)
 #ys.exit(1)

 #ef _main_shell_completion(
 #elf,
 #tx_args: cabc.MutableMapping[str, t.Any],
 #rog_name: str,
 #omplete_var: str | None = None,
 # -> None:
 #""Check if the shell is asking for tab completion, process
 #hat, then exit early. Called from :meth:`main` before the
 #rogram is invoked.

 #param prog_name: Name of the executable in the shell.
 #param complete_var: Name of the environment variable that holds
 #he completion instruction. Defaults to
 #`_{PROG_NAME}_COMPLETE``.

 #. versionchanged:: 8.2.0
 #ots (``.``) in ``prog_name`` are replaced with underscores (``_``).
 #""
 #f complete_var is None:
 #omplete_name = prog_name.replace("-", "_").replace(".", "_")
 #omplete_var = f"_{complete_name}_COMPLETE".upper()

 #nstruction = os.environ.get(complete_var)

 #f not instruction:
 #eturn

 #rom .shell_completion import shell_complete

 #v = shell_complete(self, ctx_args, prog_name, complete_var, instruction)
 #ys.exit(rv)

 #ef __call__(self, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #""Alias for :meth:`main`."""
 #eturn self.main(*args, **kwargs)


class _FakeSubclassCheck(type):
 #ef __subclasscheck__(cls, subclass: type) -> bool:
 #eturn issubclass(subclass, cls.__bases__[0])

 #ef __instancecheck__(cls, instance: t.Any) -> bool:
 #eturn isinstance(instance, cls.__bases__[0])


class _BaseCommand(Command, metaclass=_FakeSubclassCheck):
 #""
 #. deprecated:: 8.2
 #ill be removed in Click 9.0. Use ``Command`` instead.
 #""


class Group(Command):
 #""A group is a command that nests other commands (or more groups).

 #param name: The name of the group command.
 #param commands: Map names to :class:`Command` objects. Can be a list, which
 #ill use :attr:`Command.name` as the keys.
 #param invoke_without_command: Invoke the group's callback even if a
 #ubcommand is not given.
 #param no_args_is_help: If no arguments are given, show the group's help and
 #xit. Defaults to the opposite of ``invoke_without_command``.
 #param subcommand_metavar: How to represent the subcommand argument in help.
 #he default will represent whether ``chain`` is set or not.
 #param chain: Allow passing more than one subcommand argument. After parsing
 # command's arguments, if any arguments remain another command will be
 #atched, and so on.
 #param result_callback: A function to call after the group's and
 #ubcommand's callbacks. The value returned by the subcommand is passed.
 #f ``chain`` is enabled, the value will be a list of values returned by
 #ll the commands. If ``invoke_without_command`` is enabled, the value
 #ill be the value returned by the group's callback, or an empty list if
 #`chain`` is enabled.
 #param kwargs: Other arguments passed to :class:`Command`.

 #. versionchanged:: 8.0
 #he ``commands`` argument can be a list of command objects.

 #. versionchanged:: 8.2
 #erged with and replaces the ``MultiCommand`` base class.
 #""

 #llow_extra_args = True
 #llow_interspersed_args = False

    #: If set, this is used by the group's :meth:`command` decorator
    #: as the default :class:`Command` class. This is useful to make all
    #: subcommands use a custom command class.
    #:
    #: .. versionadded:: 8.0
 #ommand_class: type[Command] | None = None

    #: If set, this is used by the group's :meth:`group` decorator
    #: as the default :class:`Group` class. This is useful to make all
    #: subgroups use a custom group class.
    #:
    #: If set to the special value :class:`type` (literally
    #: ``group_class = type``), this group's class will be used as the
    #: default class. This makes a custom group class continue to make
    #: custom groups.
    #:
    #: .. versionadded:: 8.0
 #roup_class: type[Group] | type[type] | None = None
    # Literal[type] isn't valid, so use Type[type]

 #ef __init__(
 #elf,
 #ame: str | None = None,
 #ommands: cabc.MutableMapping[str, Command]
 # cabc.Sequence[Command]
 # None = None,
 #nvoke_without_command: bool = False,
 #o_args_is_help: bool | None = None,
 #ubcommand_metavar: str | None = None,
 #hain: bool = False,
 #esult_callback: t.Callable[..., t.Any] | None = None,
 #*kwargs: t.Any,
 # -> None:
 #uper().__init__(name, **kwargs)

 #f commands is None:
 #ommands = {}
 #lif isinstance(commands, abc.Sequence):
 #ommands = {c.name: c for c in commands if c.name is not None}

        #: The registered subcommands by their exported names.
 #elf.commands: cabc.MutableMapping[str, Command] = commands

 #f no_args_is_help is None:
 #o_args_is_help = not invoke_without_command

 #elf.no_args_is_help = no_args_is_help
 #elf.invoke_without_command = invoke_without_command

 #f subcommand_metavar is None:
 #f chain:
 #ubcommand_metavar = "COMMAND1 [ARGS]... [COMMAND2 [ARGS]...]..."
 #lse:
 #ubcommand_metavar = "COMMAND [ARGS]..."

 #elf.subcommand_metavar = subcommand_metavar
 #elf.chain = chain
        # The result callback that is stored. This can be set or
        # overridden with the :func:`result_callback` decorator.
 #elf._result_callback = result_callback

 #f self.chain:
 #or param in self.params:
 #f isinstance(param, Argument) and not param.required:
 #aise RuntimeError(
 #A group in chain mode cannot have optional arguments."
 #

 #ef to_info_dict(self, ctx: Context) -> dict[str, t.Any]:
 #nfo_dict = super().to_info_dict(ctx)
 #ommands = {}

 #or name in self.list_commands(ctx):
 #ommand = self.get_command(ctx, name)

 #f command is None:
 #ontinue

 #ub_ctx = ctx._make_sub_context(command)

 #ith sub_ctx.scope(cleanup=False):
 #ommands[name] = command.to_info_dict(sub_ctx)

 #nfo_dict.update(commands=commands, chain=self.chain)
 #eturn info_dict

 #ef add_command(self, cmd: Command, name: str | None = None) -> None:
 #""Registers another :class:`Command` with this group.  If the name
 #s not provided, the name of the command is used.
 #""
 #ame = name or cmd.name
 #f name is None:
 #aise TypeError("Command has no name.")
 #check_nested_chain(self, name, cmd, register=True)
 #elf.commands[name] = cmd

 #t.overload
 #ef command(self, __func: t.Callable[..., t.Any]) -> Command: ...

 #t.overload
 #ef command(
 #elf, *args: t.Any, **kwargs: t.Any
 # -> t.Callable[[t.Callable[..., t.Any]], Command]: ...

 #ef command(
 #elf, *args: t.Any, **kwargs: t.Any
 # -> t.Callable[[t.Callable[..., t.Any]], Command] | Command:
 #""A shortcut decorator for declaring and attaching a command to
 #he group. This takes the same arguments as :func:`command` and
 #mmediately registers the created command with this group by
 #alling :meth:`add_command`.

 #o customize the command class used, set the
 #attr:`command_class` attribute.

 #. versionchanged:: 8.1
 #his decorator can be applied without parentheses.

 #. versionchanged:: 8.0
 #dded the :attr:`command_class` attribute.
 #""
 #rom .decorators import command

 #unc: t.Callable[..., t.Any] | None = None

 #f args and callable(args[0]):
 #ssert len(args) == 1 and not kwargs, (
 #Use 'command(**kwargs)(callable)' to provide arguments."
 #
 #func,) = args
 #rgs = ()

 #f self.command_class and kwargs.get("cls") is None:
 #wargs["cls"] = self.command_class

 #ef decorator(f: t.Callable[..., t.Any]) -> Command:
 #md: Command = command(*args, **kwargs)(f)
 #elf.add_command(cmd)
 #eturn cmd

 #f func is not None:
 #eturn decorator(func)

 #eturn decorator

 #t.overload
 #ef group(self, __func: t.Callable[..., t.Any]) -> Group: ...

 #t.overload
 #ef group(
 #elf, *args: t.Any, **kwargs: t.Any
 # -> t.Callable[[t.Callable[..., t.Any]], Group]: ...

 #ef group(
 #elf, *args: t.Any, **kwargs: t.Any
 # -> t.Callable[[t.Callable[..., t.Any]], Group] | Group:
 #""A shortcut decorator for declaring and attaching a group to
 #he group. This takes the same arguments as :func:`group` and
 #mmediately registers the created group with this group by
 #alling :meth:`add_command`.

 #o customize the group class used, set the :attr:`group_class`
 #ttribute.

 #. versionchanged:: 8.1
 #his decorator can be applied without parentheses.

 #. versionchanged:: 8.0
 #dded the :attr:`group_class` attribute.
 #""
 #rom .decorators import group

 #unc: t.Callable[..., t.Any] | None = None

 #f args and callable(args[0]):
 #ssert len(args) == 1 and not kwargs, (
 #Use 'group(**kwargs)(callable)' to provide arguments."
 #
 #func,) = args
 #rgs = ()

 #f self.group_class is not None and kwargs.get("cls") is None:
 #f self.group_class is type:
 #wargs["cls"] = type(self)
 #lse:
 #wargs["cls"] = self.group_class

 #ef decorator(f: t.Callable[..., t.Any]) -> Group:
 #md: Group = group(*args, **kwargs)(f)
 #elf.add_command(cmd)
 #eturn cmd

 #f func is not None:
 #eturn decorator(func)

 #eturn decorator

 #ef result_callback(self, replace: bool = False) -> t.Callable[[F], F]:
 #""Adds a result callback to the command.  By default if a
 #esult callback is already registered this will chain them but
 #his can be disabled with the `replace` parameter.  The result
 #allback is invoked with the return value of the subcommand
 #or the list of return values from all subcommands if chaining
 #s enabled) as well as the parameters as they would be passed
 #o the main callback.

 #xample::

 #click.group()
 #click.option('-i', '--input', default=23)
 #ef cli(input):
 #eturn 42

 #cli.result_callback()
 #ef process_result(result, input):
 #eturn result + input

 #param replace: if set to `True` an already existing result
 #allback will be removed.

 #. versionchanged:: 8.0
 #enamed from ``resultcallback``.

 #. versionadded:: 3.0
 #""

 #ef decorator(f: F) -> F:
 #ld_callback = self._result_callback

 #f old_callback is None or replace:
 #elf._result_callback = f
 #eturn f

 #ef function(value: t.Any, /, *args: t.Any, **kwargs: t.Any) -> t.Any:
 #nner = old_callback(value, *args, **kwargs)
 #eturn f(inner, *args, **kwargs)

 #elf._result_callback = rv = update_wrapper(t.cast(F, function), f)
 #eturn rv  # type: ignore[return-value]

 #eturn decorator

 #ef get_command(self, ctx: Context, cmd_name: str) -> Command | None:
 #""Given a context and a command name, this returns a :class:`Command`
 #bject if it exists or returns ``None``.
 #""
 #eturn self.commands.get(cmd_name)

 #ef list_commands(self, ctx: Context) -> list[str]:
 #""Returns a list of subcommand names in the order they should appear."""
 #eturn sorted(self.commands)

 #ef collect_usage_pieces(self, ctx: Context) -> list[str]:
 #v = super().collect_usage_pieces(ctx)
 #v.append(self.subcommand_metavar)
 #eturn rv

 #ef format_options(self, ctx: Context, formatter: HelpFormatter) -> None:
 #uper().format_options(ctx, formatter)
 #elf.format_commands(ctx, formatter)

 #ef format_commands(self, ctx: Context, formatter: HelpFormatter) -> None:
 #""Extra format methods for multi methods that adds all the commands
 #fter the options.
 #""
 #ommands = []
 #or subcommand in self.list_commands(ctx):
 #md = self.get_command(ctx, subcommand)
            # What is this, the tool lied about a command.  Ignore it
 #f cmd is None:
 #ontinue
 #f cmd.hidden:
 #ontinue

 #ommands.append((subcommand, cmd))

        # allow for 3 times the default spacing
 #f len(commands):
 #imit = formatter.width - 6 - max(len(cmd[0]) for cmd in commands)

 #ows = []
 #or subcommand, cmd in commands:
 #elp = cmd.get_short_help_str(limit)
 #ows.append((subcommand, help))

 #f rows:
 #ith formatter.section(_("Commands")):
 #ormatter.write_dl(rows)

 #ef parse_args(self, ctx: Context, args: list[str]) -> list[str]:
 #f not args and self.no_args_is_help and not ctx.resilient_parsing:
 #aise NoArgsIsHelpError(ctx)

 #est = super().parse_args(ctx, args)

 #f self.chain:
 #tx._protected_args = rest
 #tx.args = []
 #lif rest:
 #tx._protected_args, ctx.args = rest[:1], rest[1:]

 #eturn ctx.args

 #ef invoke(self, ctx: Context) -> t.Any:
 #ef _process_result(value: t.Any) -> t.Any:
 #f self._result_callback is not None:
 #alue = ctx.invoke(self._result_callback, value, **ctx.params)
 #eturn value

 #f not ctx._protected_args:
 #f self.invoke_without_command:
                # No subcommand was invoked, so the result callback is
                # invoked with the group return value for regular
                # groups, or an empty list for chained groups.
 #ith ctx:
 #v = super().invoke(ctx)
 #eturn _process_result([] if self.chain else rv)
 #tx.fail(_("Missing command."))

        # Fetch args back out
 #rgs = [*ctx._protected_args, *ctx.args]
 #tx.args = []
 #tx._protected_args = []

        # If we're not in chain mode, we only allow the invocation of a
        # single command but we also inform the current context about the
        # name of the command to invoke.
 #f not self.chain:
            # Make sure the context is entered so we do not clean up
            # resources until the result processor has worked.
 #ith ctx:
 #md_name, cmd, args = self.resolve_command(ctx, args)
 #ssert cmd is not None
 #tx.invoked_subcommand = cmd_name
 #uper().invoke(ctx)
 #ub_ctx = cmd.make_context(cmd_name, args, parent=ctx)
 #ith sub_ctx:
 #eturn _process_result(sub_ctx.command.invoke(sub_ctx))

        # In chain mode we create the contexts step by step, but after the
        # base command has been invoked.  Because at that point we do not
        # know the subcommands yet, the invoked subcommand attribute is
        # set to ``*`` to inform the command that subcommands are executed
        # but nothing else.
 #ith ctx:
 #tx.invoked_subcommand = "*" if args else None
 #uper().invoke(ctx)

            # Otherwise we make every single context and invoke them in a
            # chain.  In that case the return value to the result processor
            # is the list of all invoked subcommand's results.
 #ontexts = []
 #hile args:
 #md_name, cmd, args = self.resolve_command(ctx, args)
 #ssert cmd is not None
 #ub_ctx = cmd.make_context(
 #md_name,
 #rgs,
 #arent=ctx,
 #llow_extra_args=True,
 #llow_interspersed_args=False,
 #
 #ontexts.append(sub_ctx)
 #rgs, sub_ctx.args = sub_ctx.args, []

 #v = []
 #or sub_ctx in contexts:
 #ith sub_ctx:
 #v.append(sub_ctx.command.invoke(sub_ctx))
 #eturn _process_result(rv)

 #ef resolve_command(
 #elf, ctx: Context, args: list[str]
 # -> tuple[str | None, Command | None, list[str]]:
 #md_name = make_str(args[0])
 #riginal_cmd_name = cmd_name

        # Get the command
 #md = self.get_command(ctx, cmd_name)

        # If we can't find the command but there is a normalization
        # function available, we try with that one.
 #f cmd is None and ctx.token_normalize_func is not None:
 #md_name = ctx.token_normalize_func(cmd_name)
 #md = self.get_command(ctx, cmd_name)

        # If we don't find the command we want to show an error message
        # to the user that it was not provided.  However, there is
        # something else we should do: if the first argument looks like
        # an option we want to kick off parsing again for arguments to
        # resolve things like --help which now should go to the main
        # place.
 #f cmd is None and not ctx.resilient_parsing:
 #f _split_opt(cmd_name)[0]:
 #elf.parse_args(ctx, args)
 #tx.fail(_("No such command {name!r}.").format(name=original_cmd_name))
 #eturn cmd_name if cmd else None, cmd, args[1:]

 #ef shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:
 #""Return a list of completions for the incomplete value. Looks
 #t the names of options, subcommands, and chained
 #ulti-commands.

 #param ctx: Invocation context for this command.
 #param incomplete: Value being completed. May be empty.

 #. versionadded:: 8.0
 #""
 #rom click.shell_completion import CompletionItem

 #esults = [
 #ompletionItem(name, help=command.get_short_help_str())
 #or name, command in _complete_visible_commands(ctx, incomplete)
 #
 #esults.extend(super().shell_complete(ctx, incomplete))
 #eturn results


class _MultiCommand(Group, metaclass=_FakeSubclassCheck):
 #""
 #. deprecated:: 8.2
 #ill be removed in Click 9.0. Use ``Group`` instead.
 #""


class CommandCollection(Group):
 #""A :class:`Group` that looks up subcommands on other groups. If a command
 #s not found on this group, each registered source is checked in order.
 #arameters on a source are not added to this group, and a source's callback
 #s not invoked when invoking its commands. In other words, this "flattens"
 #ommands in many groups into this one group.

 #param name: The name of the group command.
 #param sources: A list of :class:`Group` objects to look up commands from.
 #param kwargs: Other arguments passed to :class:`Group`.

 #. versionchanged:: 8.2
 #his is a subclass of ``Group``. Commands are looked up first on this
 #roup, then each of its sources.
 #""

 #ef __init__(
 #elf,
 #ame: str | None = None,
 #ources: list[Group] | None = None,
 #*kwargs: t.Any,
 # -> None:
 #uper().__init__(name, **kwargs)
        #: The list of registered groups.
 #elf.sources: list[Group] = sources or []

 #ef add_source(self, group: Group) -> None:
 #""Add a group as a source of commands."""
 #elf.sources.append(group)

 #ef get_command(self, ctx: Context, cmd_name: str) -> Command | None:
 #v = super().get_command(ctx, cmd_name)

 #f rv is not None:
 #eturn rv

 #or source in self.sources:
 #v = source.get_command(ctx, cmd_name)

 #f rv is not None:
 #f self.chain:
 #check_nested_chain(self, cmd_name, rv)

 #eturn rv

 #eturn None

 #ef list_commands(self, ctx: Context) -> list[str]:
 #v: set[str] = set(super().list_commands(ctx))

 #or source in self.sources:
 #v.update(source.list_commands(ctx))

 #eturn sorted(rv)


def _check_iter(value: t.Any) -> cabc.Iterator[t.Any]:
 #""Check if the value is iterable but not a string. Raises a type
 #rror, or return an iterator over the value.
 #""
 #f isinstance(value, str):
 #aise TypeError

 #eturn iter(value)


class Parameter:
 #"""A parameter to a command comes in two versions: they are either
 #class:`Option`\s or :class:`Argument`\s.  Other subclasses are currently
 #ot supported by design as some of the internals for parsing are
 #ntentionally not finalized.

 #ome settings are supported by both options and arguments.

 #param param_decls: the parameter declarations for this option or
 #rgument.  This is a list of flags or argument
 #ames.
 #param type: the type that should be used.  Either a :class:`ParamType`
 #r a Python type.  The latter is converted into the former
 #utomatically if supported.
 #param required: controls if this is optional or not.
 #param default: the default value if omitted.  This can also be a callable,
 #n which case it's invoked when the default is needed
 #ithout any arguments.
 #param callback: A function to further process or validate the value
 #fter type conversion. It is called as ``f(ctx, param, value)``
 #nd must return the value. It is called for all sources,
 #ncluding prompts.
 #param nargs: the number of arguments to match.  If not ``1`` the return
 #alue is a tuple instead of single value.  The default for
 #args is ``1`` (except if the type is a tuple, then it's
 #he arity of the tuple). If ``nargs=-1``, all remaining
 #arameters are collected.
 #param metavar: how the value is represented in the help page.
 #param expose_value: if this is `True` then the value is passed onwards
 #o the command callback and stored on the context,
 #therwise it's skipped.
 #param is_eager: eager values are processed before non eager ones.  This
 #hould not be set for arguments or it will inverse the
 #rder of processing.
 #param envvar: environment variable(s) that are used to provide a default value for
 #his parameter. This can be a string or a sequence of strings. If a sequence is
 #iven, only the first non-empty environment variable is used for the parameter.
 #param shell_complete: A function that returns custom shell
 #ompletions. Used instead of the param's type completion if
 #iven. Takes ``ctx, param, incomplete`` and must return a list
 #f :class:`~click.shell_completion.CompletionItem` or a list of
 #trings.
 #param deprecated: If ``True`` or non-empty string, issues a message
 #ndicating that the argument is deprecated and highlights
 #ts deprecation in --help. The message can be customized
 #y using a string as the value. A deprecated parameter
 #annot be required, a ValueError will be raised otherwise.

 #. versionchanged:: 8.2.0
 #ntroduction of ``deprecated``.

 #. versionchanged:: 8.2
 #dding duplicate parameter names to a :class:`~click.core.Command` will
 #esult in a ``UserWarning`` being shown.

 #. versionchanged:: 8.2
 #dding duplicate parameter names to a :class:`~click.core.Command` will
 #esult in a ``UserWarning`` being shown.

 #. versionchanged:: 8.0
 #`process_value`` validates required parameters and bounded
 #`nargs``, and invokes the parameter callback before returning
 #he value. This allows the callback to validate prompts.
 #`full_process_value`` is removed.

 #. versionchanged:: 8.0
 #`autocompletion`` is renamed to ``shell_complete`` and has new
 #emantics described above. The old name is deprecated and will
 #e removed in 8.1, until then it will be wrapped to match the
 #ew requirements.

 #. versionchanged:: 8.0
 #or ``multiple=True, nargs>1``, the default must be a list of
 #uples.

 #. versionchanged:: 8.0
 #etting a default is no longer required for ``nargs>1``, it will
 #efault to ``None``. ``multiple=True`` or ``nargs=-1`` will
 #efault to ``()``.

 #. versionchanged:: 7.1
 #mpty environment variables are ignored rather than taking the
 #mpty string value. This makes it possible for scripts to clear
 #ariables if they can't unset them.

 #. versionchanged:: 2.0
 #hanged signature for parameter callback to also be passed the
 #arameter. The old callback format will still work, but it will
 #aise a warning to give you a chance to migrate the code easier.
 #""

 #aram_type_name = "parameter"

 #ef __init__(
 #elf,
 #aram_decls: cabc.Sequence[str] | None = None,
 #ype: types.ParamType | t.Any | None = None,
 #equired: bool = False,
        # XXX The default historically embed two concepts:
        # - the declaration of a Parameter object carrying the default (handy to
        #   arbitrage the default value of coupled Parameters sharing the same
        #   self.name, like flag options),
        # - and the actual value of the default.
        # It is confusing and is the source of many issues discussed in:
        # https://github.com/pallets/click/pull/3030
        # In the future, we might think of splitting it in two, not unlike
        # Option.is_flag and Option.flag_value: we could have something like
        # Parameter.is_default and Parameter.default_value.
 #efault: t.Any | t.Callable[[], t.Any] | None = UNSET,
 #allback: t.Callable[[Context, Parameter, t.Any], t.Any] | None = None,
 #args: int | None = None,
 #ultiple: bool = False,
 #etavar: str | None = None,
 #xpose_value: bool = True,
 #s_eager: bool = False,
 #nvvar: str | cabc.Sequence[str] | None = None,
 #hell_complete: t.Callable[
 #Context, Parameter, str], list[CompletionItem] | list[str]
 #
 # None = None,
 #eprecated: bool | str = False,
 # -> None:
 #elf.name: str | None
 #elf.opts: list[str]
 #elf.secondary_opts: list[str]
 #elf.name, self.opts, self.secondary_opts = self._parse_decls(
 #aram_decls or (), expose_value
 #
 #elf.type: types.ParamType = types.convert_type(type, default)

        # Default nargs to what the type tells us if we have that
        # information available.
 #f nargs is None:
 #f self.type.is_composite:
 #args = self.type.arity
 #lse:
 #args = 1

 #elf.required = required
 #elf.callback = callback
 #elf.nargs = nargs
 #elf.multiple = multiple
 #elf.expose_value = expose_value
 #elf.default = default
 #elf.is_eager = is_eager
 #elf.metavar = metavar
 #elf.envvar = envvar
 #elf._custom_shell_complete = shell_complete
 #elf.deprecated = deprecated

 #f __debug__:
 #f self.type.is_composite and nargs != self.type.arity:
 #aise ValueError(
 #"'nargs' must be {self.type.arity} (or None) for"
 #" type {self.type!r}, but it was {nargs}."
 #

 #f required and deprecated:
 #aise ValueError(
 #"The {self.param_type_name} '{self.human_readable_name}' "
 #is deprecated and still required. A deprecated "
 #"{self.param_type_name} cannot be required."
 #

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #""Gather information that could be useful for a tool generating
 #ser-facing documentation.

 #se :meth:`click.Context.to_info_dict` to traverse the entire
 #LI structure.

 #. versionchanged:: 8.3.0
 #eturns ``None`` for the :attr:`default` if it was not set.

 #. versionadded:: 8.0
 #""
 #eturn {
 #name": self.name,
 #param_type_name": self.param_type_name,
 #opts": self.opts,
 #secondary_opts": self.secondary_opts,
 #type": self.type.to_info_dict(),
 #required": self.required,
 #nargs": self.nargs,
 #multiple": self.multiple,
            # We explicitly hide the :attr:`UNSET` value to the user, as we choose to
            # make it an implementation detail. And because ``to_info_dict`` has been
            # designed for documentation purposes, we return ``None`` instead.
 #default": self.default if self.default is not UNSET else None,
 #envvar": self.envvar,
 #

 #ef __repr__(self) -> str:
 #eturn f"<{self.__class__.__name__} {self.name}>"

 #ef _parse_decls(
 #elf, decls: cabc.Sequence[str], expose_value: bool
 # -> tuple[str | None, list[str], list[str]]:
 #aise NotImplementedError()

 #property
 #ef human_readable_name(self) -> str:
 #""Returns the human readable name of this parameter.  This is the
 #ame as the name for options, but the metavar for arguments.
 #""
 #eturn self.name  # type: ignore

 #ef make_metavar(self, ctx: Context) -> str:
 #f self.metavar is not None:
 #eturn self.metavar

 #etavar = self.type.get_metavar(param=self, ctx=ctx)

 #f metavar is None:
 #etavar = self.type.name.upper()

 #f self.nargs != 1:
 #etavar += "..."

 #eturn metavar

 #t.overload
 #ef get_default(
 #elf, ctx: Context, call: t.Literal[True] = True
 # -> t.Any | None: ...

 #t.overload
 #ef get_default(
 #elf, ctx: Context, call: bool = ...
 # -> t.Any | t.Callable[[], t.Any] | None: ...

 #ef get_default(
 #elf, ctx: Context, call: bool = True
 # -> t.Any | t.Callable[[], t.Any] | None:
 #""Get the default for the parameter. Tries
 #meth:`Context.lookup_default` first, then the local default.

 #param ctx: Current context.
 #param call: If the default is a callable, call it. Disable to
 #eturn the callable instead.

 #. versionchanged:: 8.0.2
 #ype casting is no longer performed when getting a default.

 #. versionchanged:: 8.0.1
 #ype casting can fail in resilient parsing mode. Invalid
 #efaults will not prevent showing help text.

 #. versionchanged:: 8.0
 #ooks at ``ctx.default_map`` first.

 #. versionchanged:: 8.0
 #dded the ``call`` parameter.
 #""
 #alue = ctx.lookup_default(self.name, call=False)  # type: ignore

 #f value is UNSET:
 #alue = self.default

 #f call and callable(value):
 #alue = value()

 #eturn value

 #ef add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:
 #aise NotImplementedError()

 #ef consume_value(
 #elf, ctx: Context, opts: cabc.Mapping[str, t.Any]
 # -> tuple[t.Any, ParameterSource]:
 #""Returns the parameter value produced by the parser.

 #f the parser did not produce a value from user input, the value is either
 #ourced from the environment variable, the default map, or the parameter's
 #efault value. In that order of precedence.

 #f no value is found, an internal sentinel value is returned.

 #meta private:
 #""
        # Collect from the parse the value passed by the user to the CLI.
 #alue = opts.get(self.name, UNSET)  # type: ignore
        # If the value is set, it means it was sourced from the command line by the
        # parser, otherwise it left unset by default.
 #ource = (
 #arameterSource.COMMANDLINE
 #f value is not UNSET
 #lse ParameterSource.DEFAULT
 #

 #f value is UNSET:
 #nvvar_value = self.value_from_envvar(ctx)
 #f envvar_value is not None:
 #alue = envvar_value
 #ource = ParameterSource.ENVIRONMENT

 #f value is UNSET:
 #efault_map_value = ctx.lookup_default(self.name)  # type: ignore
 #f default_map_value is not UNSET:
 #alue = default_map_value
 #ource = ParameterSource.DEFAULT_MAP

 #f value is UNSET:
 #efault_value = self.get_default(ctx)
 #f default_value is not UNSET:
 #alue = default_value
 #ource = ParameterSource.DEFAULT

 #eturn value, source

 #ef type_cast_value(self, ctx: Context, value: t.Any) -> t.Any:
 #""Convert and validate a value against the parameter's
 #attr:`type`, :attr:`multiple`, and :attr:`nargs`.
 #""
 #f value in (None, UNSET):
 #f self.multiple or self.nargs == -1:
 #eturn ()
 #lse:
 #eturn value

 #ef check_iter(value: t.Any) -> cabc.Iterator[t.Any]:
 #ry:
 #eturn _check_iter(value)
 #xcept TypeError:
                # This should only happen when passing in args manually,
                # the parser should construct an iterable when parsing
                # the command line.
 #aise BadParameter(
 #("Value must be an iterable."), ctx=ctx, param=self
 # from None

        # Define the conversion function based on nargs and type.

 #f self.nargs == 1 or self.type.is_composite:

 #ef convert(value: t.Any) -> t.Any:
 #eturn self.type(value, param=self, ctx=ctx)

 #lif self.nargs == -1:

 #ef convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]
 #eturn tuple(self.type(x, self, ctx) for x in check_iter(value))

 #lse:  # nargs > 1

 #ef convert(value: t.Any) -> t.Any:  # tuple[t.Any, ...]
 #alue = tuple(check_iter(value))

 #f len(value) != self.nargs:
 #aise BadParameter(
 #gettext(
 #Takes {nargs} values but 1 was given.",
 #Takes {nargs} values but {len} were given.",
 #en(value),
 #.format(nargs=self.nargs, len=len(value)),
 #tx=ctx,
 #aram=self,
 #

 #eturn tuple(self.type(x, self, ctx) for x in value)

 #f self.multiple:
 #eturn tuple(convert(x) for x in check_iter(value))

 #eturn convert(value)

 #ef value_is_missing(self, value: t.Any) -> bool:
 #""A value is considered missing if:

 # it is :attr:`UNSET`,
 # or if it is an empty sequence while the parameter is suppose to have
 #on-single value (i.e. :attr:`nargs` is not ``1`` or :attr:`multiple` is
 #et).

 #meta private:
 #""
 #f value is UNSET:
 #eturn True

 #f (self.nargs != 1 or self.multiple) and value == ():
 #eturn True

 #eturn False

 #ef process_value(self, ctx: Context, value: t.Any) -> t.Any:
 #""Process the value of this parameter:

 #. Type cast the value using :meth:`type_cast_value`.
 #. Check if the value is missing (see: :meth:`value_is_missing`), and raise
 #exc:`MissingParameter` if it is required.
 #. If a :attr:`callback` is set, call it to have the value replaced by the
 #esult of the callback. If the value was not set, the callback receive
 #`None``. This keep the legacy behavior as it was before the introduction of
 #he :attr:`UNSET` sentinel.

 #meta private:
 #""
 #alue = self.type_cast_value(ctx, value)

 #f self.required and self.value_is_missing(value):
 #aise MissingParameter(ctx=ctx, param=self)

 #f self.callback is not None:
            # Legacy case: UNSET is not exposed directly to the callback, but converted
            # to None.
 #f value is UNSET:
 #alue = None
 #alue = self.callback(ctx, self, value)

 #eturn value

 #ef resolve_envvar_value(self, ctx: Context) -> str | None:
 #""Returns the value found in the environment variable(s) attached to this
 #arameter.

 #nvironment variables values are `always returned as strings
 #https://docs.python.org/3/library/os.html#os.environ>`_.

 #his method returns ``None`` if:

 # the :attr:`envvar` property is not set on the :class:`Parameter`,
 # the environment variable is not found in the environment,
 # the variable is found in the environment but its value is empty (i.e. the
 #nvironment variable is present but has an empty string).

 #f :attr:`envvar` is setup with multiple environment variables,
 #hen only the first non-empty value is returned.

 #. caution::

 #he raw value extracted from the environment is not normalized and is
 #eturned as-is. Any normalization or reconciliation is performed later by
 #he :class:`Parameter`'s :attr:`type`.

 #meta private:
 #""
 #f not self.envvar:
 #eturn None

 #f isinstance(self.envvar, str):
 #v = os.environ.get(self.envvar)

 #f rv:
 #eturn rv
 #lse:
 #or envvar in self.envvar:
 #v = os.environ.get(envvar)

                # Return the first non-empty value of the list of environment variables.
 #f rv:
 #eturn rv
                # Else, absence of value is interpreted as an environment variable that
                # is not set, so proceed to the next one.

 #eturn None

 #ef value_from_envvar(self, ctx: Context) -> str | cabc.Sequence[str] | None:
 #""Process the raw environment variable string for this parameter.

 #eturns the string as-is or splits it into a sequence of strings if the
 #arameter is expecting multiple values (i.e. its :attr:`nargs` property is set
 #o a value other than ``1``).

 #meta private:
 #""
 #v = self.resolve_envvar_value(ctx)

 #f rv is not None and self.nargs != 1:
 #eturn self.type.split_envvar_value(rv)

 #eturn rv

 #ef handle_parse_result(
 #elf, ctx: Context, opts: cabc.Mapping[str, t.Any], args: list[str]
 # -> tuple[t.Any, list[str]]:
 #""Process the value produced by the parser from user input.

 #lways process the value through the Parameter's :attr:`type`, wherever it
 #omes from.

 #f the parameter is deprecated, this method warn the user about it. But only if
 #he value has been explicitly set by the user (and as such, is not coming from
 # default).

 #meta private:
 #""
 #ith augment_usage_errors(ctx, param=self):
 #alue, source = self.consume_value(ctx, opts)

 #tx.set_parameter_source(self.name, source)  # type: ignore

            # Display a deprecation warning if necessary.
 #f (
 #elf.deprecated
 #nd value is not UNSET
 #nd source not in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)
 #:
 #xtra_message = (
 #" {self.deprecated}" if isinstance(self.deprecated, str) else ""
 #
 #essage = _(
 #DeprecationWarning: The {param_type} {name!r} is deprecated."
 #{extra_message}"
 #.format(
 #aram_type=self.param_type_name,
 #ame=self.human_readable_name,
 #xtra_message=extra_message,
 #
 #cho(style(message, fg="red"), err=True)

            # Process the value through the parameter's type.
 #ry:
 #alue = self.process_value(ctx, value)
 #xcept Exception:
 #f not ctx.resilient_parsing:
 #aise
                # In resilient parsing mode, we do not want to fail the command if the
                # value is incompatible with the parameter type, so we reset the value
                # to UNSET, which will be interpreted as a missing value.
 #alue = UNSET

        # Add parameter's value to the context.
 #f (
 #elf.expose_value
            # We skip adding the value if it was previously set by another parameter
            # targeting the same variable name. This prevents parameters competing for
            # the same name to override each other.
 #nd self.name not in ctx.params
 #:
            # Click is logically enforcing that the name is None if the parameter is
            # not to be exposed. We still assert it here to please the type checker.
 #ssert self.name is not None, (
 #"{self!r} parameter's name should not be None when exposing value."
 #
            # Normalize UNSET values to None, as we're about to pass them to the
            # command function and move them to the pure-Python realm of user-written
            # code.
 #tx.params[self.name] = value if value is not UNSET else None

 #eturn value, args

 #ef get_help_record(self, ctx: Context) -> tuple[str, str] | None:
 #ass

 #ef get_usage_pieces(self, ctx: Context) -> list[str]:
 #eturn []

 #ef get_error_hint(self, ctx: Context) -> str:
 #""Get a stringified version of the param for use in error messages to
 #ndicate which param caused the error.
 #""
 #int_list = self.opts or [self.human_readable_name]
 #eturn " / ".join(f"'{x}'" for x in hint_list)

 #ef shell_complete(self, ctx: Context, incomplete: str) -> list[CompletionItem]:
 #""Return a list of completions for the incomplete value. If a
 #`shell_complete`` function was given during init, it is used.
 #therwise, the :attr:`type`
 #meth:`~click.types.ParamType.shell_complete` function is used.

 #param ctx: Invocation context for this command.
 #param incomplete: Value being completed. May be empty.

 #. versionadded:: 8.0
 #""
 #f self._custom_shell_complete is not None:
 #esults = self._custom_shell_complete(ctx, self, incomplete)

 #f results and isinstance(results[0], str):
 #rom click.shell_completion import CompletionItem

 #esults = [CompletionItem(c) for c in results]

 #eturn t.cast("list[CompletionItem]", results)

 #eturn self.type.shell_complete(ctx, self, incomplete)


class Option(Parameter):
 #""Options are usually optional values on the command line and
 #ave some extra features that arguments don't have.

 #ll other parameters are passed onwards to the parameter constructor.

 #param show_default: Show the default value for this option in its
 #elp text. Values are not shown by default, unless
 #attr:`Context.show_default` is ``True``. If this value is a
 #tring, it shows that string in parentheses instead of the
 #ctual value. This is particularly useful for dynamic options.
 #or single option boolean flags, the default remains hidden if
 #ts value is ``False``.
 #param show_envvar: Controls if an environment variable should be
 #hown on the help page and error messages.
 #ormally, environment variables are not shown.
 #param prompt: If set to ``True`` or a non empty string then the
 #ser will be prompted for input. If set to ``True`` the prompt
 #ill be the option name capitalized. A deprecated option cannot be
 #rompted.
 #param confirmation_prompt: Prompt a second time to confirm the
 #alue if it was prompted for. Can be set to a string instead of
 #`True`` to customize the message.
 #param prompt_required: If set to ``False``, the user will be
 #rompted for input only when the option was specified as a flag
 #ithout a value.
 #param hide_input: If this is ``True`` then the input on the prompt
 #ill be hidden from the user. This is useful for password input.
 #param is_flag: forces this option to act as a flag.  The default is
 #uto detection.
 #param flag_value: which value should be used for this flag if it's
 #nabled.  This is set to a boolean automatically if
 #he option string contains a slash to mark two options.
 #param multiple: if this is set to `True` then the argument is accepted
 #ultiple times and recorded.  This is similar to ``nargs``
 #n how it works but supports arbitrary number of
 #rguments.
 #param count: this flag makes an option increment an integer.
 #param allow_from_autoenv: if this is enabled then the value of this
 #arameter will be pulled from an environment
 #ariable in case a prefix is defined on the
 #ontext.
 #param help: the help string.
 #param hidden: hide this option from help outputs.
 #param attrs: Other command arguments described in :class:`Parameter`.

 #. versionchanged:: 8.2
 #`envvar`` used with ``flag_value`` will always use the ``flag_value``,
 #reviously it would use the value of the environment variable.

 #. versionchanged:: 8.1
 #elp text indentation is cleaned here instead of only in the
 #`@option`` decorator.

 #. versionchanged:: 8.1
 #he ``show_default`` parameter overrides
 #`Context.show_default``.

 #. versionchanged:: 8.1
 #he default of a single option boolean flag is not shown if the
 #efault value is ``False``.

 #. versionchanged:: 8.0.1
 #`type`` is detected from ``flag_value`` if given.
 #""

 #aram_type_name = "option"

 #ef __init__(
 #elf,
 #aram_decls: cabc.Sequence[str] | None = None,
 #how_default: bool | str | None = None,
 #rompt: bool | str = False,
 #onfirmation_prompt: bool | str = False,
 #rompt_required: bool = True,
 #ide_input: bool = False,
 #s_flag: bool | None = None,
 #lag_value: t.Any = UNSET,
 #ultiple: bool = False,
 #ount: bool = False,
 #llow_from_autoenv: bool = True,
 #ype: types.ParamType | t.Any | None = None,
 #elp: str | None = None,
 #idden: bool = False,
 #how_choices: bool = True,
 #how_envvar: bool = False,
 #eprecated: bool | str = False,
 #*attrs: t.Any,
 # -> None:
 #f help:
 #elp = inspect.cleandoc(help)

 #uper().__init__(
 #aram_decls, type=type, multiple=multiple, deprecated=deprecated, **attrs
 #

 #f prompt is True:
 #f self.name is None:
 #aise TypeError("'name' is required with 'prompt=True'.")

 #rompt_text: str | None = self.name.replace("_", " ").capitalize()
 #lif prompt is False:
 #rompt_text = None
 #lse:
 #rompt_text = prompt

 #f deprecated:
 #eprecated_message = (
 #"(DEPRECATED: {deprecated})"
 #f isinstance(deprecated, str)
 #lse "(DEPRECATED)"
 #
 #elp = help + deprecated_message if help is not None else deprecated_message

 #elf.prompt = prompt_text
 #elf.confirmation_prompt = confirmation_prompt
 #elf.prompt_required = prompt_required
 #elf.hide_input = hide_input
 #elf.hidden = hidden

        # The _flag_needs_value property tells the parser that this option is a flag
        # that cannot be used standalone and needs a value. With this information, the
        # parser can determine whether to consider the next user-provided argument in
        # the CLI as a value for this flag or as a new option.
        # If prompt is enabled but not required, then it opens the possibility for the
        # option to gets its value from the user.
 #elf._flag_needs_value = self.prompt is not None and not self.prompt_required

        # Auto-detect if this is a flag or not.
 #f is_flag is None:
            # Implicitly a flag because flag_value was set.
 #f flag_value is not UNSET:
 #s_flag = True
            # Not a flag, but when used as a flag it shows a prompt.
 #lif self._flag_needs_value:
 #s_flag = False
            # Implicitly a flag because secondary options names were given.
 #lif self.secondary_opts:
 #s_flag = True
        # The option is explicitly not a flag. But we do not know yet if it needs a
        # value or not. So we look at the default value to determine it.
 #lif is_flag is False and not self._flag_needs_value:
 #elf._flag_needs_value = self.default is UNSET

 #f is_flag:
            # Set missing default for flags if not explicitly required or prompted.
 #f self.default is UNSET and not self.required and not self.prompt:
 #f multiple:
 #elf.default = ()

            # Auto-detect the type of the flag based on the flag_value.
 #f type is None:
                # A flag without a flag_value is a boolean flag.
 #f flag_value is UNSET:
 #elf.type = types.BoolParamType()
                # If the flag value is a boolean, use BoolParamType.
 #lif isinstance(flag_value, bool):
 #elf.type = types.BoolParamType()
                # Otherwise, guess the type from the flag value.
 #lse:
 #elf.type = types.convert_type(None, flag_value)

 #elf.is_flag: bool = bool(is_flag)
 #elf.is_bool_flag: bool = bool(
 #s_flag and isinstance(self.type, types.BoolParamType)
 #
 #elf.flag_value: t.Any = flag_value

        # Set boolean flag default to False if unset and not required.
 #f self.is_bool_flag:
 #f self.default is UNSET and not self.required:
 #elf.default = False

        # Support the special case of aligning the default value with the flag_value
        # for flags whose default is explicitly set to True. Note that as long as we
        # have this condition, there is no way a flag can have a default set to True,
        # and a flag_value set to something else. Refs:
        # https://github.com/pallets/click/issues/3024#issuecomment-3146199461
        # https://github.com/pallets/click/pull/3030/commits/06847da
 #f self.default is True and self.flag_value is not UNSET:
 #elf.default = self.flag_value

        # Set the default flag_value if it is not set.
 #f self.flag_value is UNSET:
 #f self.is_flag:
 #elf.flag_value = True
 #lse:
 #elf.flag_value = None

        # Counting.
 #elf.count = count
 #f count:
 #f type is None:
 #elf.type = types.IntRange(min=0)
 #f self.default is UNSET:
 #elf.default = 0

 #elf.allow_from_autoenv = allow_from_autoenv
 #elf.help = help
 #elf.show_default = show_default
 #elf.show_choices = show_choices
 #elf.show_envvar = show_envvar

 #f __debug__:
 #f deprecated and prompt:
 #aise ValueError("`deprecated` options cannot use `prompt`.")

 #f self.nargs == -1:
 #aise TypeError("nargs=-1 is not supported for options.")

 #f not self.is_bool_flag and self.secondary_opts:
 #aise TypeError("Secondary flag is not valid for non-boolean flag.")

 #f self.is_bool_flag and self.hide_input and self.prompt is not None:
 #aise TypeError(
 #'prompt' with 'hide_input' is not valid for boolean flag."
 #

 #f self.count:
 #f self.multiple:
 #aise TypeError("'count' is not valid with 'multiple'.")

 #f self.is_flag:
 #aise TypeError("'count' is not valid with 'is_flag'.")

 #ef to_info_dict(self) -> dict[str, t.Any]:
 #""
 #. versionchanged:: 8.3.0
 #eturns ``None`` for the :attr:`flag_value` if it was not set.
 #""
 #nfo_dict = super().to_info_dict()
 #nfo_dict.update(
 #elp=self.help,
 #rompt=self.prompt,
 #s_flag=self.is_flag,
            # We explicitly hide the :attr:`UNSET` value to the user, as we choose to
            # make it an implementation detail. And because ``to_info_dict`` has been
            # designed for documentation purposes, we return ``None`` instead.
 #lag_value=self.flag_value if self.flag_value is not UNSET else None,
 #ount=self.count,
 #idden=self.hidden,
 #
 #eturn info_dict

 #ef get_error_hint(self, ctx: Context) -> str:
 #esult = super().get_error_hint(ctx)
 #f self.show_envvar and self.envvar is not None:
 #esult += f" (env var: '{self.envvar}')"
 #eturn result

 #ef _parse_decls(
 #elf, decls: cabc.Sequence[str], expose_value: bool
 # -> tuple[str | None, list[str], list[str]]:
 #pts = []
 #econdary_opts = []
 #ame = None
 #ossible_names = []

 #or decl in decls:
 #f decl.isidentifier():
 #f name is not None:
 #aise TypeError(f"Name '{name}' defined twice")
 #ame = decl
 #lse:
 #plit_char = ";" if decl[:1] == "/" else "/"
 #f split_char in decl:
 #irst, second = decl.split(split_char, 1)
 #irst = first.rstrip()
 #f first:
 #ossible_names.append(_split_opt(first))
 #pts.append(first)
 #econd = second.lstrip()
 #f second:
 #econdary_opts.append(second.lstrip())
 #f first == second:
 #aise ValueError(
 #"Boolean option {decl!r} cannot use the"
 # same flag for true/false."
 #
 #lse:
 #ossible_names.append(_split_opt(decl))
 #pts.append(decl)

 #f name is None and possible_names:
 #ossible_names.sort(key=lambda x: -len(x[0]))  # group long options first
 #ame = possible_names[0][1].replace("-", "_").lower()
 #f not name.isidentifier():
 #ame = None

 #f name is None:
 #f not expose_value:
 #eturn None, opts, secondary_opts
 #aise TypeError(
 #"Could not determine name for option with declarations {decls!r}"
 #

 #f not opts and not secondary_opts:
 #aise TypeError(
 #"No options defined but a name was passed ({name})."
 # Did you mean to declare an argument instead? Did"
 #" you mean to pass '--{name}'?"
 #

 #eturn name, opts, secondary_opts

 #ef add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:
 #f self.multiple:
 #ction = "append"
 #lif self.count:
 #ction = "count"
 #lse:
 #ction = "store"

 #f self.is_flag:
 #ction = f"{action}_const"

 #f self.is_bool_flag and self.secondary_opts:
 #arser.add_option(
 #bj=self, opts=self.opts, dest=self.name, action=action, const=True
 #
 #arser.add_option(
 #bj=self,
 #pts=self.secondary_opts,
 #est=self.name,
 #ction=action,
 #onst=False,
 #
 #lse:
 #arser.add_option(
 #bj=self,
 #pts=self.opts,
 #est=self.name,
 #ction=action,
 #onst=self.flag_value,
 #
 #lse:
 #arser.add_option(
 #bj=self,
 #pts=self.opts,
 #est=self.name,
 #ction=action,
 #args=self.nargs,
 #

 #ef get_help_record(self, ctx: Context) -> tuple[str, str] | None:
 #f self.hidden:
 #eturn None

 #ny_prefix_is_slash = False

 #ef _write_opts(opts: cabc.Sequence[str]) -> str:
 #onlocal any_prefix_is_slash

 #v, any_slashes = join_options(opts)

 #f any_slashes:
 #ny_prefix_is_slash = True

 #f not self.is_flag and not self.count:
 #v += f" {self.make_metavar(ctx=ctx)}"

 #eturn rv

 #v = [_write_opts(self.opts)]

 #f self.secondary_opts:
 #v.append(_write_opts(self.secondary_opts))

 #elp = self.help or ""

 #xtra = self.get_help_extra(ctx)
 #xtra_items = []
 #f "envvars" in extra:
 #xtra_items.append(
 #("env var: {var}").format(var=", ".join(extra["envvars"]))
 #
 #f "default" in extra:
 #xtra_items.append(_("default: {default}").format(default=extra["default"]))
 #f "range" in extra:
 #xtra_items.append(extra["range"])
 #f "required" in extra:
 #xtra_items.append(_(extra["required"]))

 #f extra_items:
 #xtra_str = "; ".join(extra_items)
 #elp = f"{help}  [{extra_str}]" if help else f"[{extra_str}]"

 #eturn ("; " if any_prefix_is_slash else " / ").join(rv), help

 #ef get_help_extra(self, ctx: Context) -> types.OptionHelpExtra:
 #xtra: types.OptionHelpExtra = {}

 #f self.show_envvar:
 #nvvar = self.envvar

 #f envvar is None:
 #f (
 #elf.allow_from_autoenv
 #nd ctx.auto_envvar_prefix is not None
 #nd self.name is not None
 #:
 #nvvar = f"{ctx.auto_envvar_prefix}_{self.name.upper()}"

 #f envvar is not None:
 #f isinstance(envvar, str):
 #xtra["envvars"] = (envvar,)
 #lse:
 #xtra["envvars"] = tuple(str(d) for d in envvar)

        # Temporarily enable resilient parsing to avoid type casting
        # failing for the default. Might be possible to extend this to
        # help formatting in general.
 #esilient = ctx.resilient_parsing
 #tx.resilient_parsing = True

 #ry:
 #efault_value = self.get_default(ctx, call=False)
 #inally:
 #tx.resilient_parsing = resilient

 #how_default = False
 #how_default_is_str = False

 #f self.show_default is not None:
 #f isinstance(self.show_default, str):
 #how_default_is_str = show_default = True
 #lse:
 #how_default = self.show_default
 #lif ctx.show_default is not None:
 #how_default = ctx.show_default

 #f show_default_is_str or (
 #how_default and (default_value not in (None, UNSET))
 #:
 #f show_default_is_str:
 #efault_string = f"({self.show_default})"
 #lif isinstance(default_value, (list, tuple)):
 #efault_string = ", ".join(str(d) for d in default_value)
 #lif isinstance(default_value, enum.Enum):
 #efault_string = default_value.name
 #lif inspect.isfunction(default_value):
 #efault_string = _("(dynamic)")
 #lif self.is_bool_flag and self.secondary_opts:
                # For boolean flags that have distinct True/False opts,
                # use the opt without prefix instead of the value.
 #efault_string = _split_opt(
 #self.opts if default_value else self.secondary_opts)[0]
 #[1]
 #lif self.is_bool_flag and not self.secondary_opts and not default_value:
 #efault_string = ""
 #lif default_value == "":
 #efault_string = '""'
 #lse:
 #efault_string = str(default_value)

 #f default_string:
 #xtra["default"] = default_string

 #f (
 #sinstance(self.type, types._NumberRangeBase)
            # skip count with default range type
 #nd not (self.count and self.type.min == 0 and self.type.max is None)
 #:
 #ange_str = self.type._describe_range()

 #f range_str:
 #xtra["range"] = range_str

 #f self.required:
 #xtra["required"] = "required"

 #eturn extra

 #ef prompt_for_value(self, ctx: Context) -> t.Any:
 #""This is an alternative flow that can be activated in the full
 #alue processing if a value does not exist.  It will prompt the
 #ser until a valid value exists and then returns the processed
 #alue as result.
 #""
 #ssert self.prompt is not None

        # Calculate the default before prompting anything to lock in the value before
        # attempting any user interaction.
 #efault = self.get_default(ctx)

        # A boolean flag can use a simplified [y/n] confirmation prompt.
 #f self.is_bool_flag:
            # If we have no boolean default, we force the user to explicitly provide
            # one.
 #f default in (UNSET, None):
 #efault = None
            # Nothing prevent you to declare an option that is simultaneously:
            # 1) auto-detected as a boolean flag,
            # 2) allowed to prompt, and
            # 3) still declare a non-boolean default.
            # This forced casting into a boolean is necessary to align any non-boolean
            # default to the prompt, which is going to be a [y/n]-style confirmation
            # because the option is still a boolean flag. That way, instead of [y/n],
            # we get [Y/n] or [y/N] depending on the truthy value of the default.
            # Refs: https://github.com/pallets/click/pull/3030#discussion_r2289180249
 #lse:
 #efault = bool(default)
 #eturn confirm(self.prompt, default)

        # If show_default is set to True/False, provide this to `prompt` as well. For
        # non-bool values of `show_default`, we use `prompt`'s default behavior
 #rompt_kwargs: t.Any = {}
 #f isinstance(self.show_default, bool):
 #rompt_kwargs["show_default"] = self.show_default

 #eturn prompt(
 #elf.prompt,
            # Use ``None`` to inform the prompt() function to reiterate until a valid
            # value is provided by the user if we have no default.
 #efault=None if default is UNSET else default,
 #ype=self.type,
 #ide_input=self.hide_input,
 #how_choices=self.show_choices,
 #onfirmation_prompt=self.confirmation_prompt,
 #alue_proc=lambda x: self.process_value(ctx, x),
 #*prompt_kwargs,
 #

 #ef resolve_envvar_value(self, ctx: Context) -> str | None:
 #"":class:`Option` resolves its environment variable the same way as
 #func:`Parameter.resolve_envvar_value`, but it also supports
 #attr:`Context.auto_envvar_prefix`. If we could not find an environment from
 #he :attr:`envvar` property, we fallback on :attr:`Context.auto_envvar_prefix`
 #o build dynamiccaly the environment variable name using the
 #python:`{ctx.auto_envvar_prefix}_{self.name.upper()}` template.

 #meta private:
 #""
 #v = super().resolve_envvar_value(ctx)

 #f rv is not None:
 #eturn rv

 #f (
 #elf.allow_from_autoenv
 #nd ctx.auto_envvar_prefix is not None
 #nd self.name is not None
 #:
 #nvvar = f"{ctx.auto_envvar_prefix}_{self.name.upper()}"
 #v = os.environ.get(envvar)

 #f rv:
 #eturn rv

 #eturn None

 #ef value_from_envvar(self, ctx: Context) -> t.Any:
 #""For :class:`Option`, this method processes the raw environment variable
 #tring the same way as :func:`Parameter.value_from_envvar` does.

 #ut in the case of non-boolean flags, the value is analyzed to determine if the
 #lag is activated or not, and returns a boolean of its activation, or the
 #attr:`flag_value` if the latter is set.

 #his method also takes care of repeated options (i.e. options with
 #attr:`multiple` set to ``True``).

 #meta private:
 #""
 #v = self.resolve_envvar_value(ctx)

        # Absent environment variable or an empty string is interpreted as unset.
 #f rv is None:
 #eturn None

        # Non-boolean flags are more liberal in what they accept. But a flag being a
        # flag, its envvar value still needs to be analyzed to determine if the flag is
        # activated or not.
 #f self.is_flag and not self.is_bool_flag:
            # If the flag_value is set and match the envvar value, return it
            # directly.
 #f self.flag_value is not UNSET and rv == self.flag_value:
 #eturn self.flag_value
            # Analyze the envvar value as a boolean to know if the flag is
            # activated or not.
 #eturn types.BoolParamType.str_to_bool(rv)

        # Split the envvar value if it is allowed to be repeated.
 #alue_depth = (self.nargs != 1) + bool(self.multiple)
 #f value_depth > 0:
 #ulti_rv = self.type.split_envvar_value(rv)
 #f self.multiple and self.nargs != 1:
 #ulti_rv = batch(multi_rv, self.nargs)  # type: ignore[assignment]

 #eturn multi_rv

 #eturn rv

 #ef consume_value(
 #elf, ctx: Context, opts: cabc.Mapping[str, Parameter]
 # -> tuple[t.Any, ParameterSource]:
 #""For :class:`Option`, the value can be collected from an interactive prompt
 #f the option is a flag that needs a value (and the :attr:`prompt` property is
 #et).

 #dditionally, this method handles flag option that are activated without a
 #alue, in which case the :attr:`flag_value` is returned.

 #meta private:
 #""
 #alue, source = super().consume_value(ctx, opts)

        # The parser will emit a sentinel value if the option is allowed to as a flag
        # without a value.
 #f value is FLAG_NEEDS_VALUE:
            # If the option allows for a prompt, we start an interaction with the user.
 #f self.prompt is not None and not ctx.resilient_parsing:
 #alue = self.prompt_for_value(ctx)
 #ource = ParameterSource.PROMPT
            # Else the flag takes its flag_value as value.
 #lse:
 #alue = self.flag_value
 #ource = ParameterSource.COMMANDLINE

        # A flag which is activated always returns the flag value, unless the value
        # comes from the explicitly sets default.
 #lif (
 #elf.is_flag
 #nd value is True
 #nd not self.is_bool_flag
 #nd source not in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)
 #:
 #alue = self.flag_value

        # Re-interpret a multiple option which has been sent as-is by the parser.
        # Here we replace each occurrence of value-less flags (marked by the
        # FLAG_NEEDS_VALUE sentinel) with the flag_value.
 #lif (
 #elf.multiple
 #nd value is not UNSET
 #nd source not in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)
 #nd any(v is FLAG_NEEDS_VALUE for v in value)
 #:
 #alue = [self.flag_value if v is FLAG_NEEDS_VALUE else v for v in value]
 #ource = ParameterSource.COMMANDLINE

        # The value wasn't set, or used the param's default, prompt for one to the user
        # if prompting is enabled.
 #lif (
 #
 #alue is UNSET
 #r source in (ParameterSource.DEFAULT, ParameterSource.DEFAULT_MAP)
 #
 #nd self.prompt is not None
 #nd (self.required or self.prompt_required)
 #nd not ctx.resilient_parsing
 #:
 #alue = self.prompt_for_value(ctx)
 #ource = ParameterSource.PROMPT

 #eturn value, source

 #ef type_cast_value(self, ctx: Context, value: t.Any) -> t.Any:
 #f self.is_flag and not self.required:
 #f value is UNSET:
 #f self.is_bool_flag:
                    # If the flag is a boolean flag, we return False if it is not set.
 #alue = False
 #eturn super().type_cast_value(ctx, value)


class Argument(Parameter):
 #""Arguments are positional parameters to a command.  They generally
 #rovide fewer features than options but can have infinite ``nargs``
 #nd are required by default.

 #ll parameters are passed onwards to the constructor of :class:`Parameter`.
 #""

 #aram_type_name = "argument"

 #ef __init__(
 #elf,
 #aram_decls: cabc.Sequence[str],
 #equired: bool | None = None,
 #*attrs: t.Any,
 # -> None:
        # Auto-detect the requirement status of the argument if not explicitly set.
 #f required is None:
            # The argument gets automatically required if it has no explicit default
            # value set and is setup to match at least one value.
 #f attrs.get("default", UNSET) is UNSET:
 #equired = attrs.get("nargs", 1) > 0
            # If the argument has a default value, it is not required.
 #lse:
 #equired = False

 #f "multiple" in attrs:
 #aise TypeError("__init__() got an unexpected keyword argument 'multiple'.")

 #uper().__init__(param_decls, required=required, **attrs)

 #property
 #ef human_readable_name(self) -> str:
 #f self.metavar is not None:
 #eturn self.metavar
 #eturn self.name.upper()  # type: ignore

 #ef make_metavar(self, ctx: Context) -> str:
 #f self.metavar is not None:
 #eturn self.metavar
 #ar = self.type.get_metavar(param=self, ctx=ctx)
 #f not var:
 #ar = self.name.upper()  # type: ignore
 #f self.deprecated:
 #ar += "!"
 #f not self.required:
 #ar = f"[{var}]"
 #f self.nargs != 1:
 #ar += "..."
 #eturn var

 #ef _parse_decls(
 #elf, decls: cabc.Sequence[str], expose_value: bool
 # -> tuple[str | None, list[str], list[str]]:
 #f not decls:
 #f not expose_value:
 #eturn None, [], []
 #aise TypeError("Argument is marked as exposed, but does not have a name.")
 #f len(decls) == 1:
 #ame = arg = decls[0]
 #ame = name.replace("-", "_").lower()
 #lse:
 #aise TypeError(
 #Arguments take exactly one parameter declaration, got"
 #" {len(decls)}: {decls}."
 #
 #eturn name, [arg], []

 #ef get_usage_pieces(self, ctx: Context) -> list[str]:
 #eturn [self.make_metavar(ctx)]

 #ef get_error_hint(self, ctx: Context) -> str:
 #eturn f"'{self.make_metavar(ctx)}'"

 #ef add_to_parser(self, parser: _OptionParser, ctx: Context) -> None:
 #arser.add_argument(dest=self.name, nargs=self.nargs, obj=self)


def __getattr__(name: str) -> object:
 #mport warnings

 #f name == "BaseCommand":
 #arnings.warn(
 #'BaseCommand' is deprecated and will be removed in Click 9.0. Use"
 # 'Command' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn _BaseCommand

 #f name == "MultiCommand":
 #arnings.warn(
 #'MultiCommand' is deprecated and will be removed in Click 9.0. Use"
 # 'Group' instead.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn _MultiCommand

 #aise AttributeError(name)
