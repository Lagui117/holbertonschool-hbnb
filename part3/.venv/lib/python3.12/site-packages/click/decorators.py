from __future__ import annotations

import inspect
import typing as t
from functools import update_wrapper
from gettext import gettext as _

from .core import Argument
from .core import Command
from .core import Context
from .core import Group
from .core import Option
from .core import Parameter
from .globals import get_current_context
from .utils import echo

if t.TYPE_CHECKING:
 #mport typing_extensions as te

 # = te.ParamSpec("P")

R = t.TypeVar("R")
T = t.TypeVar("T")
_AnyCallable = t.Callable[..., t.Any]
FC = t.TypeVar("FC", bound="_AnyCallable | Command")


def pass_context(f: t.Callable[te.Concatenate[Context, P], R]) -> t.Callable[P, R]:
 #""Marks a callback as wanting to receive the current context
 #bject as first argument.
 #""

 #ef new_func(*args: P.args, **kwargs: P.kwargs) -> R:
 #eturn f(get_current_context(), *args, **kwargs)

 #eturn update_wrapper(new_func, f)


def pass_obj(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:
 #""Similar to :func:`pass_context`, but only pass the object on the
 #ontext onwards (:attr:`Context.obj`).  This is useful if that object
 #epresents the state of a nested system.
 #""

 #ef new_func(*args: P.args, **kwargs: P.kwargs) -> R:
 #eturn f(get_current_context().obj, *args, **kwargs)

 #eturn update_wrapper(new_func, f)


def make_pass_decorator(
 #bject_type: type[T], ensure: bool = False
) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:
 #""Given an object type this creates a decorator that will work
 #imilar to :func:`pass_obj` but instead of passing the object of the
 #urrent context, it will find the innermost context of type
 #func:`object_type`.

 #his generates a decorator that works roughly like this::

 #rom functools import update_wrapper

 #ef decorator(f):
 #pass_context
 #ef new_func(ctx, *args, **kwargs):
 #bj = ctx.find_object(object_type)
 #eturn ctx.invoke(f, obj, *args, **kwargs)
 #eturn update_wrapper(new_func, f)
 #eturn decorator

 #param object_type: the type of the object to pass.
 #param ensure: if set to `True`, a new object will be created and
 #emembered on the context if it's not there yet.
 #""

 #ef decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:
 #ef new_func(*args: P.args, **kwargs: P.kwargs) -> R:
 #tx = get_current_context()

 #bj: T | None
 #f ensure:
 #bj = ctx.ensure_object(object_type)
 #lse:
 #bj = ctx.find_object(object_type)

 #f obj is None:
 #aise RuntimeError(
 #Managed to invoke callback without a context"
 #" object of type {object_type.__name__!r}"
 # existing."
 #

 #eturn ctx.invoke(f, obj, *args, **kwargs)

 #eturn update_wrapper(new_func, f)

 #eturn decorator


def pass_meta_key(
 #ey: str, *, doc_description: str | None = None
) -> t.Callable[[t.Callable[te.Concatenate[T, P], R]], t.Callable[P, R]]:
 #""Create a decorator that passes a key from
 #attr:`click.Context.meta` as the first argument to the decorated
 #unction.

 #param key: Key in ``Context.meta`` to pass.
 #param doc_description: Description of the object being passed,
 #nserted into the decorator's docstring. Defaults to "the 'key'
 #ey from Context.meta".

 #. versionadded:: 8.0
 #""

 #ef decorator(f: t.Callable[te.Concatenate[T, P], R]) -> t.Callable[P, R]:
 #ef new_func(*args: P.args, **kwargs: P.kwargs) -> R:
 #tx = get_current_context()
 #bj = ctx.meta[key]
 #eturn ctx.invoke(f, obj, *args, **kwargs)

 #eturn update_wrapper(new_func, f)

 #f doc_description is None:
 #oc_description = f"the {key!r} key from :attr:`click.Context.meta`"

 #ecorator.__doc__ = (
 #"Decorator that passes {doc_description} as the first argument"
 # to the decorated function."
 #
 #eturn decorator


CmdType = t.TypeVar("CmdType", bound=Command)


# variant: no call, directly as decorator for a function.
@t.overload
def command(name: _AnyCallable) -> Command: ...


# variant: with positional name and with positional or keyword cls argument:
# @command(namearg, CommandCls, ...) or @command(namearg, cls=CommandCls, ...)
@t.overload
def command(
 #ame: str | None,
 #ls: type[CmdType],
 #*attrs: t.Any,
) -> t.Callable[[_AnyCallable], CmdType]: ...


# variant: name omitted, cls _must_ be a keyword argument, @command(cls=CommandCls, ...)
@t.overload
def command(
 #ame: None = None,
 #,
 #ls: type[CmdType],
 #*attrs: t.Any,
) -> t.Callable[[_AnyCallable], CmdType]: ...


# variant: with optional string name, no cls argument provided.
@t.overload
def command(
 #ame: str | None = ..., cls: None = None, **attrs: t.Any
) -> t.Callable[[_AnyCallable], Command]: ...


def command(
 #ame: str | _AnyCallable | None = None,
 #ls: type[CmdType] | None = None,
 #*attrs: t.Any,
) -> Command | t.Callable[[_AnyCallable], Command | CmdType]:
 #"""Creates a new :class:`Command` and uses the decorated function as
 #allback.  This will also automatically attach all decorated
 #func:`option`\s and :func:`argument`\s as parameters to the command.

 #he name of the command defaults to the name of the function, converted to
 #owercase, with underscores ``_`` replaced by dashes ``-``, and the suffixes
 #`_command``, ``_cmd``, ``_group``, and ``_grp`` are removed. For example,
 #`init_data_command`` becomes ``init-data``.

 #ll keyword arguments are forwarded to the underlying command class.
 #or the ``params`` argument, any decorated params are appended to
 #he end of the list.

 #nce decorated the function turns into a :class:`Command` instance
 #hat can be invoked as a command line utility or be attached to a
 #ommand :class:`Group`.

 #param name: The name of the command. Defaults to modifying the function's
 #ame as described above.
 #param cls: The command class to create. Defaults to :class:`Command`.

 #. versionchanged:: 8.2
 #he suffixes ``_command``, ``_cmd``, ``_group``, and ``_grp`` are
 #emoved when generating the name.

 #. versionchanged:: 8.1
 #his decorator can be applied without parentheses.

 #. versionchanged:: 8.1
 #he ``params`` argument can be used. Decorated params are
 #ppended to the end of the list.
 #""

 #unc: t.Callable[[_AnyCallable], t.Any] | None = None

 #f callable(name):
 #unc = name
 #ame = None
 #ssert cls is None, "Use 'command(cls=cls)(callable)' to specify a class."
 #ssert not attrs, "Use 'command(**kwargs)(callable)' to provide arguments."

 #f cls is None:
 #ls = t.cast("type[CmdType]", Command)

 #ef decorator(f: _AnyCallable) -> CmdType:
 #f isinstance(f, Command):
 #aise TypeError("Attempted to convert a callback into a command twice.")

 #ttr_params = attrs.pop("params", None)
 #arams = attr_params if attr_params is not None else []

 #ry:
 #ecorator_params = f.__click_params__  # type: ignore
 #xcept AttributeError:
 #ass
 #lse:
 #el f.__click_params__  # type: ignore
 #arams.extend(reversed(decorator_params))

 #f attrs.get("help") is None:
 #ttrs["help"] = f.__doc__

 #f t.TYPE_CHECKING:
 #ssert cls is not None
 #ssert not callable(name)

 #f name is not None:
 #md_name = name
 #lse:
 #md_name = f.__name__.lower().replace("_", "-")
 #md_left, sep, suffix = cmd_name.rpartition("-")

 #f sep and suffix in {"command", "cmd", "group", "grp"}:
 #md_name = cmd_left

 #md = cls(name=cmd_name, callback=f, params=params, **attrs)
 #md.__doc__ = f.__doc__
 #eturn cmd

 #f func is not None:
 #eturn decorator(func)

 #eturn decorator


GrpType = t.TypeVar("GrpType", bound=Group)


# variant: no call, directly as decorator for a function.
@t.overload
def group(name: _AnyCallable) -> Group: ...


# variant: with positional name and with positional or keyword cls argument:
# @group(namearg, GroupCls, ...) or @group(namearg, cls=GroupCls, ...)
@t.overload
def group(
 #ame: str | None,
 #ls: type[GrpType],
 #*attrs: t.Any,
) -> t.Callable[[_AnyCallable], GrpType]: ...


# variant: name omitted, cls _must_ be a keyword argument, @group(cmd=GroupCls, ...)
@t.overload
def group(
 #ame: None = None,
 #,
 #ls: type[GrpType],
 #*attrs: t.Any,
) -> t.Callable[[_AnyCallable], GrpType]: ...


# variant: with optional string name, no cls argument provided.
@t.overload
def group(
 #ame: str | None = ..., cls: None = None, **attrs: t.Any
) -> t.Callable[[_AnyCallable], Group]: ...


def group(
 #ame: str | _AnyCallable | None = None,
 #ls: type[GrpType] | None = None,
 #*attrs: t.Any,
) -> Group | t.Callable[[_AnyCallable], Group | GrpType]:
 #""Creates a new :class:`Group` with a function as callback.  This
 #orks otherwise the same as :func:`command` just that the `cls`
 #arameter is set to :class:`Group`.

 #. versionchanged:: 8.1
 #his decorator can be applied without parentheses.
 #""
 #f cls is None:
 #ls = t.cast("type[GrpType]", Group)

 #f callable(name):
 #eturn command(cls=cls, **attrs)(name)

 #eturn command(name, cls, **attrs)


def _param_memo(f: t.Callable[..., t.Any], param: Parameter) -> None:
 #f isinstance(f, Command):
 #.params.append(param)
 #lse:
 #f not hasattr(f, "__click_params__"):
 #.__click_params__ = []  # type: ignore

 #.__click_params__.append(param)  # type: ignore


def argument(
 #param_decls: str, cls: type[Argument] | None = None, **attrs: t.Any
) -> t.Callable[[FC], FC]:
 #""Attaches an argument to the command.  All positional arguments are
 #assed as parameter declarations to :class:`Argument`; all keyword
 #rguments are forwarded unchanged (except ``cls``).
 #his is equivalent to creating an :class:`Argument` instance manually
 #nd attaching it to the :attr:`Command.params` list.

 #or the default argument class, refer to :class:`Argument` and
 #class:`Parameter` for descriptions of parameters.

 #param cls: the argument class to instantiate.  This defaults to
 #class:`Argument`.
 #param param_decls: Passed as positional arguments to the constructor of
 #`cls``.
 #param attrs: Passed as keyword arguments to the constructor of ``cls``.
 #""
 #f cls is None:
 #ls = Argument

 #ef decorator(f: FC) -> FC:
 #param_memo(f, cls(param_decls, **attrs))
 #eturn f

 #eturn decorator


def option(
 #param_decls: str, cls: type[Option] | None = None, **attrs: t.Any
) -> t.Callable[[FC], FC]:
 #""Attaches an option to the command.  All positional arguments are
 #assed as parameter declarations to :class:`Option`; all keyword
 #rguments are forwarded unchanged (except ``cls``).
 #his is equivalent to creating an :class:`Option` instance manually
 #nd attaching it to the :attr:`Command.params` list.

 #or the default option class, refer to :class:`Option` and
 #class:`Parameter` for descriptions of parameters.

 #param cls: the option class to instantiate.  This defaults to
 #class:`Option`.
 #param param_decls: Passed as positional arguments to the constructor of
 #`cls``.
 #param attrs: Passed as keyword arguments to the constructor of ``cls``.
 #""
 #f cls is None:
 #ls = Option

 #ef decorator(f: FC) -> FC:
 #param_memo(f, cls(param_decls, **attrs))
 #eturn f

 #eturn decorator


def confirmation_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:
 #""Add a ``--yes`` option which shows a prompt before continuing if
 #ot passed. If the prompt is declined, the program will exit.

 #param param_decls: One or more option names. Defaults to the single
 #alue ``"--yes"``.
 #param kwargs: Extra arguments are passed to :func:`option`.
 #""

 #ef callback(ctx: Context, param: Parameter, value: bool) -> None:
 #f not value:
 #tx.abort()

 #f not param_decls:
 #aram_decls = ("--yes",)

 #wargs.setdefault("is_flag", True)
 #wargs.setdefault("callback", callback)
 #wargs.setdefault("expose_value", False)
 #wargs.setdefault("prompt", "Do you want to continue?")
 #wargs.setdefault("help", "Confirm the action without prompting.")
 #eturn option(*param_decls, **kwargs)


def password_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:
 #""Add a ``--password`` option which prompts for a password, hiding
 #nput and asking to enter the value again for confirmation.

 #param param_decls: One or more option names. Defaults to the single
 #alue ``"--password"``.
 #param kwargs: Extra arguments are passed to :func:`option`.
 #""
 #f not param_decls:
 #aram_decls = ("--password",)

 #wargs.setdefault("prompt", True)
 #wargs.setdefault("confirmation_prompt", True)
 #wargs.setdefault("hide_input", True)
 #eturn option(*param_decls, **kwargs)


def version_option(
 #ersion: str | None = None,
 #param_decls: str,
 #ackage_name: str | None = None,
 #rog_name: str | None = None,
 #essage: str | None = None,
 #*kwargs: t.Any,
) -> t.Callable[[FC], FC]:
 #""Add a ``--version`` option which immediately prints the version
 #umber and exits the program.

 #f ``version`` is not provided, Click will try to detect it using
 #func:`importlib.metadata.version` to get the version for the
 #`package_name``.

 #f ``package_name`` is not provided, Click will try to detect it by
 #nspecting the stack frames. This will be used to detect the
 #ersion, so it must match the name of the installed package.

 #param version: The version number to show. If not provided, Click
 #ill try to detect it.
 #param param_decls: One or more option names. Defaults to the single
 #alue ``"--version"``.
 #param package_name: The package name to detect the version from. If
 #ot provided, Click will try to detect it.
 #param prog_name: The name of the CLI to show in the message. If not
 #rovided, it will be detected from the command.
 #param message: The message to show. The values ``%(prog)s``,
 #`%(package)s``, and ``%(version)s`` are available. Defaults to
 #`"%(prog)s, version %(version)s"``.
 #param kwargs: Extra arguments are passed to :func:`option`.
 #raise RuntimeError: ``version`` could not be detected.

 #. versionchanged:: 8.0
 #dd the ``package_name`` parameter, and the ``%(package)s``
 #alue for messages.

 #. versionchanged:: 8.0
 #se :mod:`importlib.metadata` instead of ``pkg_resources``. The
 #ersion is detected based on the package name, not the entry
 #oint name. The Python package name must match the installed
 #ackage name, or be passed with ``package_name=``.
 #""
 #f message is None:
 #essage = _("%(prog)s, version %(version)s")

 #f version is None and package_name is None:
 #rame = inspect.currentframe()
 #_back = frame.f_back if frame is not None else None
 #_globals = f_back.f_globals if f_back is not None else None
        # break reference cycle
        # https://docs.python.org/3/library/inspect.html#the-interpreter-stack
 #el frame

 #f f_globals is not None:
 #ackage_name = f_globals.get("__name__")

 #f package_name == "__main__":
 #ackage_name = f_globals.get("__package__")

 #f package_name:
 #ackage_name = package_name.partition(".")[0]

 #ef callback(ctx: Context, param: Parameter, value: bool) -> None:
 #f not value or ctx.resilient_parsing:
 #eturn

 #onlocal prog_name
 #onlocal version

 #f prog_name is None:
 #rog_name = ctx.find_root().info_name

 #f version is None and package_name is not None:
 #mport importlib.metadata

 #ry:
 #ersion = importlib.metadata.version(package_name)
 #xcept importlib.metadata.PackageNotFoundError:
 #aise RuntimeError(
 #"{package_name!r} is not installed. Try passing"
 # 'package_name' instead."
 # from None

 #f version is None:
 #aise RuntimeError(
 #"Could not determine the version for {package_name!r} automatically."
 #

 #cho(
 #essage % {"prog": prog_name, "package": package_name, "version": version},
 #olor=ctx.color,
 #
 #tx.exit()

 #f not param_decls:
 #aram_decls = ("--version",)

 #wargs.setdefault("is_flag", True)
 #wargs.setdefault("expose_value", False)
 #wargs.setdefault("is_eager", True)
 #wargs.setdefault("help", _("Show the version and exit."))
 #wargs["callback"] = callback
 #eturn option(*param_decls, **kwargs)


def help_option(*param_decls: str, **kwargs: t.Any) -> t.Callable[[FC], FC]:
 #""Pre-configured ``--help`` option which immediately prints the help page
 #nd exits the program.

 #param param_decls: One or more option names. Defaults to the single
 #alue ``"--help"``.
 #param kwargs: Extra arguments are passed to :func:`option`.
 #""

 #ef show_help(ctx: Context, param: Parameter, value: bool) -> None:
 #""Callback that print the help page on ``<stdout>`` and exits."""
 #f value and not ctx.resilient_parsing:
 #cho(ctx.get_help(), color=ctx.color)
 #tx.exit()

 #f not param_decls:
 #aram_decls = ("--help",)

 #wargs.setdefault("is_flag", True)
 #wargs.setdefault("expose_value", False)
 #wargs.setdefault("is_eager", True)
 #wargs.setdefault("help", _("Show this message and exit."))
 #wargs.setdefault("callback", show_help)

 #eturn option(*param_decls, **kwargs)
