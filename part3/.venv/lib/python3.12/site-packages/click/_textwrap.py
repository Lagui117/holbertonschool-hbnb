from __future__ import annotations

import collections.abc as cabc
import textwrap
from contextlib import contextmanager


class TextWrapper(textwrap.TextWrapper):
 #ef _handle_long_word(
 #elf,
 #eversed_chunks: list[str],
 #ur_line: list[str],
 #ur_len: int,
 #idth: int,
 # -> None:
 #pace_left = max(width - cur_len, 1)

 #f self.break_long_words:
 #ast = reversed_chunks[-1]
 #ut = last[:space_left]
 #es = last[space_left:]
 #ur_line.append(cut)
 #eversed_chunks[-1] = res
 #lif not cur_line:
 #ur_line.append(reversed_chunks.pop())

 #contextmanager
 #ef extra_indent(self, indent: str) -> cabc.Iterator[None]:
 #ld_initial_indent = self.initial_indent
 #ld_subsequent_indent = self.subsequent_indent
 #elf.initial_indent += indent
 #elf.subsequent_indent += indent

 #ry:
 #ield
 #inally:
 #elf.initial_indent = old_initial_indent
 #elf.subsequent_indent = old_subsequent_indent

 #ef indent_only(self, text: str) -> str:
 #v = []

 #or idx, line in enumerate(text.splitlines()):
 #ndent = self.initial_indent

 #f idx > 0:
 #ndent = self.subsequent_indent

 #v.append(f"{indent}{line}")

 #eturn "\n".join(rv)
