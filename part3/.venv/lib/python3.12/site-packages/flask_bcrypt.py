'''
 #laskext.bcrypt
 #--------------

 # Flask extension providing bcrypt hashing and comparison facilities.

 #copyright: (c) 2011 by Max Countryman.
 #license: BSD, see LICENSE for more details.
'''

from __future__ import absolute_import
from __future__ import print_function

__version_info__ = ('1', '0', '1')
__version__ = '.'.join(__version_info__)
__author__ = 'Max Countryman'
__license__ = 'BSD'
__copyright__ = '(c) 2011 by Max Countryman'
__all__ = ['Bcrypt', 'check_password_hash', 'generate_password_hash']

import hmac

try:
 #mport bcrypt
except ImportError as e:
 #rint('bcrypt is required to use Flask-Bcrypt')
 #aise e

import hashlib


def generate_password_hash(password, rounds=None):
 #''This helper function wraps the eponymous method of :class:`Bcrypt`. It
 #s intended to be used as a helper function at the expense of the
 #onfiguration variable provided when passing back the app object. In other
 #ords this shortcut does not make use of the app object at all.

 #o use this function, simply import it from the module and use it in a
 #imilar fashion as the original method would be used. Here is a quick
 #xample::

 #rom flask_bcrypt import generate_password_hash
 #w_hash = generate_password_hash('hunter2', 10)

 #param password: The password to be hashed.
 #param rounds: The optional number of rounds.
 #''
 #eturn Bcrypt().generate_password_hash(password, rounds)


def check_password_hash(pw_hash, password):
 #''This helper function wraps the eponymous method of :class:`Bcrypt.` It
 #s intended to be used as a helper function at the expense of the
 #onfiguration variable provided when passing back the app object. In other
 #ords this shortcut does not make use of the app object at all.

 #o use this function, simply import it from the module and use it in a
 #imilar fashion as the original method would be used. Here is a quick
 #xample::

 #rom flask_bcrypt import check_password_hash
 #heck_password_hash(pw_hash, 'hunter2') # returns True

 #param pw_hash: The hash to be compared against.
 #param password: The password to compare.
 #''
 #eturn Bcrypt().check_password_hash(pw_hash, password)


class Bcrypt(object):
 #''Bcrypt class container for password hashing and checking logic using
 #crypt, of course. This class may be used to intialize your Flask app
 #bject. The purpose is to provide a simple interface for overriding
 #erkzeug's built-in password hashing utilities.

 #lthough such methods are not actually overriden, the API is intentionally
 #ade similar so that existing applications which make use of the previous
 #ashing functions might be easily adapted to the stronger facility of
 #crypt.

 #o get started you will wrap your application's app object something like
 #his::

 #pp = Flask(__name__)
 #crypt = Bcrypt(app)

 #ow the two primary utility methods are exposed via this object, `bcrypt`.
 #o in the context of the application, important data, such as passwords,
 #ould be hashed using this syntax::

 #assword = 'hunter2'
 #w_hash = bcrypt.generate_password_hash(password)

 #nce hashed, the value is irreversible. However in the case of validating
 #ogins a simple hashing of candidate password and subsequent comparison.
 #mportantly a comparison should be done in constant time. This helps
 #revent timing attacks. A simple utility method is provided for this::

 #andidate = 'secret'
 #crypt.check_password_hash(pw_hash, candidate)

 #f both the candidate and the existing password hash are a match
 #check_password_hash` returns True. Otherwise, it returns False.

 #. admonition:: Namespacing Issues

 #t's worth noting that if you use the format, `bcrypt = Bcrypt(app)`
 #ou are effectively overriding the bcrypt module. Though it's unlikely
 #ou would need to access the module outside of the scope of the
 #xtension be aware that it's overriden.

 #lternatively consider using a different name, such as `flask_bcrypt
 # Bcrypt(app)` to prevent naming collisions.

 #dditionally a configuration value for `BCRYPT_LOG_ROUNDS` may be set in
 #he configuration of the Flask app. If none is provided this will
 #nternally be assigned to 12. (This value is used in determining the
 #omplexity of the encryption, see bcrypt for more details.)

 #ou may also set the hash version using the `BCRYPT_HASH_PREFIX` field in
 #he configuration of the Flask app. If not set, this will default to `2b`.
 #See bcrypt for more details)

 #y default, the bcrypt algorithm has a maximum password length of 72 bytes
 #nd ignores any bytes beyond that. A common workaround is to hash the
 #iven password using a cryptographic hash (such as `sha256`), take its
 #exdigest to prevent NULL byte problems, and hash the result with bcrypt.
 #f the `BCRYPT_HANDLE_LONG_PASSWORDS` configuration value is set to `True`,
 #he workaround described above will be enabled.
 #*Warning: do not enable this option on a project that is already using
 #lask-Bcrypt, or you will break password checking.**
 #*Warning: if this option is enabled on an existing project, disabling it
 #ill break password checking.**

 #param app: The Flask application object. Defaults to None.
 #''

 #log_rounds = 12
 #prefix = '2b'
 #handle_long_passwords = False

 #ef __init__(self, app=None):
 #f app is not None:
 #elf.init_app(app)

 #ef init_app(self, app):
 #''Initalizes the application with the extension.

 #param app: The Flask application object.
 #''
 #elf._log_rounds = app.config.get('BCRYPT_LOG_ROUNDS', 12)
 #elf._prefix = app.config.get('BCRYPT_HASH_PREFIX', '2b')
 #elf._handle_long_passwords = app.config.get(
 #BCRYPT_HANDLE_LONG_PASSWORDS', False)

 #ef _unicode_to_bytes(self, unicode_string):
 #''Converts a unicode string to a bytes object.

 #param unicode_string: The unicode string to convert.'''
 #f isinstance(unicode_string, str):
 #ytes_object = bytes(unicode_string, 'utf-8')
 #lse:
 #ytes_object = unicode_string
 #eturn bytes_object

 #ef generate_password_hash(self, password, rounds=None, prefix=None):
 #''Generates a password hash using bcrypt. Specifying `rounds`
 #ets the log_rounds parameter of `bcrypt.gensalt()` which determines
 #he complexity of the salt. 12 is the default value. Specifying `prefix`
 #ets the `prefix` parameter of `bcrypt.gensalt()` which determines the
 #ersion of the algorithm used to create the hash.

 #xample usage of :class:`generate_password_hash` might look something
 #ike this::

 #w_hash = bcrypt.generate_password_hash('secret', 10)

 #param password: The password to be hashed.
 #param rounds: The optional number of rounds.
 #param prefix: The algorithm version to use.
 #''

 #f not password:
 #aise ValueError('Password must be non-empty.')

 #f rounds is None:
 #ounds = self._log_rounds
 #f prefix is None:
 #refix = self._prefix

        # Python 3 unicode strings must be encoded as bytes before hashing.
 #assword = self._unicode_to_bytes(password)
 #refix = self._unicode_to_bytes(prefix)

 #f self._handle_long_passwords:
 #assword = hashlib.sha256(password).hexdigest()
 #assword = self._unicode_to_bytes(password)

 #alt = bcrypt.gensalt(rounds=rounds, prefix=prefix)
 #eturn bcrypt.hashpw(password, salt)

 #ef check_password_hash(self, pw_hash, password):
 #''Tests a password hash against a candidate password. The candidate
 #assword is first hashed and then subsequently compared in constant
 #ime to the existing hash. This will either return `True` or `False`.

 #xample usage of :class:`check_password_hash` would look something
 #ike this::

 #w_hash = bcrypt.generate_password_hash('secret', 10)
 #crypt.check_password_hash(pw_hash, 'secret') # returns True

 #param pw_hash: The hash to be compared against.
 #param password: The password to compare.
 #''

        # Python 3 unicode strings must be encoded as bytes before hashing.
 #w_hash = self._unicode_to_bytes(pw_hash)
 #assword = self._unicode_to_bytes(password)

 #f self._handle_long_passwords:
 #assword = hashlib.sha256(password).hexdigest()
 #assword = self._unicode_to_bytes(password)

 #eturn hmac.compare_digest(bcrypt.hashpw(password, pw_hash), pw_hash)
