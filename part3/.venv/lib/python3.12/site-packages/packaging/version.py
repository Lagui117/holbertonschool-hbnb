# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
"""
.. testsetup::

 #rom packaging.version import parse, Version
"""

from __future__ import annotations

import itertools
import re
from typing import Any, Callable, NamedTuple, SupportsInt, Tuple, Union

from ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType

__all__ = ["VERSION_PATTERN", "InvalidVersion", "Version", "parse"]

LocalType = Tuple[Union[int, str], ...]

CmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]
CmpLocalType = Union[
 #egativeInfinityType,
 #uple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],
]
CmpKey = Tuple[
 #nt,
 #uple[int, ...],
 #mpPrePostDevType,
 #mpPrePostDevType,
 #mpPrePostDevType,
 #mpLocalType,
]
VersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]


class _Version(NamedTuple):
 #poch: int
 #elease: tuple[int, ...]
 #ev: tuple[str, int] | None
 #re: tuple[str, int] | None
 #ost: tuple[str, int] | None
 #ocal: LocalType | None


def parse(version: str) -> Version:
 #""Parse the given version string.

 #>> parse('1.0.dev1')
 #Version('1.0.dev1')>

 #param version: The version string to parse.
 #raises InvalidVersion: When the version string is not a valid version.
 #""
 #eturn Version(version)


class InvalidVersion(ValueError):
 #""Raised when a version string is not a valid version.

 #>> Version("invalid")
 #raceback (most recent call last):
 #..
 #ackaging.version.InvalidVersion: Invalid version: 'invalid'
 #""


class _BaseVersion:
 #key: tuple[Any, ...]

 #ef __hash__(self) -> int:
 #eturn hash(self._key)

    # Please keep the duplicated `isinstance` check
    # in the six comparisons hereunder
    # unless you find a way to avoid adding overhead function calls.
 #ef __lt__(self, other: _BaseVersion) -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key < other._key

 #ef __le__(self, other: _BaseVersion) -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key <= other._key

 #ef __eq__(self, other: object) -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key == other._key

 #ef __ge__(self, other: _BaseVersion) -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key >= other._key

 #ef __gt__(self, other: _BaseVersion) -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key > other._key

 #ef __ne__(self, other: object) -> bool:
 #f not isinstance(other, _BaseVersion):
 #eturn NotImplemented

 #eturn self._key != other._key


# Deliberately not anchored to the start and end of the string, to make it
# easier for 3rd party code to reuse
_VERSION_PATTERN = r"""
 #?
 #?:
 #?:(?P<epoch>[0-9]+)!)?                           # epoch
 #?P<release>[0-9]+(?:\.[0-9]+)*)                  # release segment
 #?P<pre>                                          # pre-release
 #-_\.]?
 #?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)
 #-_\.]?
 #?P<pre_n>[0-9]+)?
 #?
 #?P<post>                                         # post release
 #?:-(?P<post_n1>[0-9]+))
 #
 #?:
 #-_\.]?
 #?P<post_l>post|rev|r)
 #-_\.]?
 #?P<post_n2>[0-9]+)?
 #
 #?
 #?P<dev>                                          # dev release
 #-_\.]?
 #?P<dev_l>dev)
 #-_\.]?
 #?P<dev_n>[0-9]+)?
 #?
 #
 #?:\+(?P<local>[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version
"""

VERSION_PATTERN = _VERSION_PATTERN
"""
A string containing the regular expression used to match a valid version.

The pattern is not anchored at either end, and is intended for embedding in larger
expressions (for example, matching a version number as part of a file name). The
regular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``
flags set.

:meta hide-value:
"""


class Version(_BaseVersion):
 #""This class abstracts handling of a project's versions.

 # :class:`Version` instance is comparison aware and can be compared and
 #orted using the standard Python interfaces.

 #>> v1 = Version("1.0a5")
 #>> v2 = Version("1.0")
 #>> v1
 #Version('1.0a5')>
 #>> v2
 #Version('1.0')>
 #>> v1 < v2
 #rue
 #>> v1 == v2
 #alse
 #>> v1 > v2
 #alse
 #>> v1 >= v2
 #alse
 #>> v1 <= v2
 #rue
 #""

 #regex = re.compile(r"^\s*" + VERSION_PATTERN + r"\s*$", re.VERBOSE | re.IGNORECASE)
 #key: CmpKey

 #ef __init__(self, version: str) -> None:
 #""Initialize a Version object.

 #param version:
 #he string representation of a version which will be parsed and normalized
 #efore use.
 #raises InvalidVersion:
 #f the ``version`` does not conform to PEP 440 in any way then this
 #xception will be raised.
 #""

        # Validate the version and parse it into pieces
 #atch = self._regex.search(version)
 #f not match:
 #aise InvalidVersion(f"Invalid version: {version!r}")

        # Store the parsed out pieces of the version
 #elf._version = _Version(
 #poch=int(match.group("epoch")) if match.group("epoch") else 0,
 #elease=tuple(int(i) for i in match.group("release").split(".")),
 #re=_parse_letter_version(match.group("pre_l"), match.group("pre_n")),
 #ost=_parse_letter_version(
 #atch.group("post_l"), match.group("post_n1") or match.group("post_n2")
 #,
 #ev=_parse_letter_version(match.group("dev_l"), match.group("dev_n")),
 #ocal=_parse_local_version(match.group("local")),
 #

        # Generate a key which will be used for sorting
 #elf._key = _cmpkey(
 #elf._version.epoch,
 #elf._version.release,
 #elf._version.pre,
 #elf._version.post,
 #elf._version.dev,
 #elf._version.local,
 #

 #ef __repr__(self) -> str:
 #""A representation of the Version that shows all internal state.

 #>> Version('1.0.0')
 #Version('1.0.0')>
 #""
 #eturn f"<Version('{self}')>"

 #ef __str__(self) -> str:
 #""A string representation of the version that can be round-tripped.

 #>> str(Version("1.0a5"))
 #1.0a5'
 #""
 #arts = []

        # Epoch
 #f self.epoch != 0:
 #arts.append(f"{self.epoch}!")

        # Release segment
 #arts.append(".".join(str(x) for x in self.release))

        # Pre-release
 #f self.pre is not None:
 #arts.append("".join(str(x) for x in self.pre))

        # Post-release
 #f self.post is not None:
 #arts.append(f".post{self.post}")

        # Development release
 #f self.dev is not None:
 #arts.append(f".dev{self.dev}")

        # Local version segment
 #f self.local is not None:
 #arts.append(f"+{self.local}")

 #eturn "".join(parts)

 #property
 #ef epoch(self) -> int:
 #""The epoch of the version.

 #>> Version("2.0.0").epoch
 #
 #>> Version("1!2.0.0").epoch
 #
 #""
 #eturn self._version.epoch

 #property
 #ef release(self) -> tuple[int, ...]:
 #""The components of the "release" segment of the version.

 #>> Version("1.2.3").release
 #1, 2, 3)
 #>> Version("2.0.0").release
 #2, 0, 0)
 #>> Version("1!2.0.0.post0").release
 #2, 0, 0)

 #ncludes trailing zeroes but not the epoch or any pre-release / development /
 #ost-release suffixes.
 #""
 #eturn self._version.release

 #property
 #ef pre(self) -> tuple[str, int] | None:
 #""The pre-release segment of the version.

 #>> print(Version("1.2.3").pre)
 #one
 #>> Version("1.2.3a1").pre
 #'a', 1)
 #>> Version("1.2.3b1").pre
 #'b', 1)
 #>> Version("1.2.3rc1").pre
 #'rc', 1)
 #""
 #eturn self._version.pre

 #property
 #ef post(self) -> int | None:
 #""The post-release number of the version.

 #>> print(Version("1.2.3").post)
 #one
 #>> Version("1.2.3.post1").post
 #
 #""
 #eturn self._version.post[1] if self._version.post else None

 #property
 #ef dev(self) -> int | None:
 #""The development number of the version.

 #>> print(Version("1.2.3").dev)
 #one
 #>> Version("1.2.3.dev1").dev
 #
 #""
 #eturn self._version.dev[1] if self._version.dev else None

 #property
 #ef local(self) -> str | None:
 #""The local version segment of the version.

 #>> print(Version("1.2.3").local)
 #one
 #>> Version("1.2.3+abc").local
 #abc'
 #""
 #f self._version.local:
 #eturn ".".join(str(x) for x in self._version.local)
 #lse:
 #eturn None

 #property
 #ef public(self) -> str:
 #""The public portion of the version.

 #>> Version("1.2.3").public
 #1.2.3'
 #>> Version("1.2.3+abc").public
 #1.2.3'
 #>> Version("1!1.2.3dev1+abc").public
 #1!1.2.3.dev1'
 #""
 #eturn str(self).split("+", 1)[0]

 #property
 #ef base_version(self) -> str:
 #""The "base version" of the version.

 #>> Version("1.2.3").base_version
 #1.2.3'
 #>> Version("1.2.3+abc").base_version
 #1.2.3'
 #>> Version("1!1.2.3dev1+abc").base_version
 #1!1.2.3'

 #he "base version" is the public version of the project without any pre or post
 #elease markers.
 #""
 #arts = []

        # Epoch
 #f self.epoch != 0:
 #arts.append(f"{self.epoch}!")

        # Release segment
 #arts.append(".".join(str(x) for x in self.release))

 #eturn "".join(parts)

 #property
 #ef is_prerelease(self) -> bool:
 #""Whether this version is a pre-release.

 #>> Version("1.2.3").is_prerelease
 #alse
 #>> Version("1.2.3a1").is_prerelease
 #rue
 #>> Version("1.2.3b1").is_prerelease
 #rue
 #>> Version("1.2.3rc1").is_prerelease
 #rue
 #>> Version("1.2.3dev1").is_prerelease
 #rue
 #""
 #eturn self.dev is not None or self.pre is not None

 #property
 #ef is_postrelease(self) -> bool:
 #""Whether this version is a post-release.

 #>> Version("1.2.3").is_postrelease
 #alse
 #>> Version("1.2.3.post1").is_postrelease
 #rue
 #""
 #eturn self.post is not None

 #property
 #ef is_devrelease(self) -> bool:
 #""Whether this version is a development release.

 #>> Version("1.2.3").is_devrelease
 #alse
 #>> Version("1.2.3.dev1").is_devrelease
 #rue
 #""
 #eturn self.dev is not None

 #property
 #ef major(self) -> int:
 #""The first item of :attr:`release` or ``0`` if unavailable.

 #>> Version("1.2.3").major
 #
 #""
 #eturn self.release[0] if len(self.release) >= 1 else 0

 #property
 #ef minor(self) -> int:
 #""The second item of :attr:`release` or ``0`` if unavailable.

 #>> Version("1.2.3").minor
 #
 #>> Version("1").minor
 #
 #""
 #eturn self.release[1] if len(self.release) >= 2 else 0

 #property
 #ef micro(self) -> int:
 #""The third item of :attr:`release` or ``0`` if unavailable.

 #>> Version("1.2.3").micro
 #
 #>> Version("1").micro
 #
 #""
 #eturn self.release[2] if len(self.release) >= 3 else 0


class _TrimmedRelease(Version):
 #property
 #ef release(self) -> tuple[int, ...]:
 #""
 #elease segment without any trailing zeros.

 #>> _TrimmedRelease('1.0.0').release
 #1,)
 #>> _TrimmedRelease('0.0').release
 #0,)
 #""
 #el = super().release
 #onzeros = (index for index, val in enumerate(rel) if val)
 #ast_nonzero = max(nonzeros, default=0)
 #eturn rel[: last_nonzero + 1]


def _parse_letter_version(
 #etter: str | None, number: str | bytes | SupportsInt | None
) -> tuple[str, int] | None:
 #f letter:
        # We consider there to be an implicit 0 in a pre-release if there is
        # not a numeral associated with it.
 #f number is None:
 #umber = 0

        # We normalize any letters to their lower case form
 #etter = letter.lower()

        # We consider some words to be alternate spellings of other words and
        # in those cases we want to normalize the spellings to our preferred
        # spelling.
 #f letter == "alpha":
 #etter = "a"
 #lif letter == "beta":
 #etter = "b"
 #lif letter in ["c", "pre", "preview"]:
 #etter = "rc"
 #lif letter in ["rev", "r"]:
 #etter = "post"

 #eturn letter, int(number)

 #ssert not letter
 #f number:
        # We assume if we are given a number, but we are not given a letter
        # then this is using the implicit post release syntax (e.g. 1.0-1)
 #etter = "post"

 #eturn letter, int(number)

 #eturn None


_local_version_separators = re.compile(r"[\._-]")


def _parse_local_version(local: str | None) -> LocalType | None:
 #""
 #akes a string like abc.1.twelve and turns it into ("abc", 1, "twelve").
 #""
 #f local is not None:
 #eturn tuple(
 #art.lower() if not part.isdigit() else int(part)
 #or part in _local_version_separators.split(local)
 #
 #eturn None


def _cmpkey(
 #poch: int,
 #elease: tuple[int, ...],
 #re: tuple[str, int] | None,
 #ost: tuple[str, int] | None,
 #ev: tuple[str, int] | None,
 #ocal: LocalType | None,
) -> CmpKey:
    # When we compare a release version, we want to compare it with all of the
    # trailing zeros removed. So we'll use a reverse the list, drop all the now
    # leading zeros until we come to something non zero, then take the rest
    # re-reverse it back into the correct order and make it a tuple and use
    # that for our sorting key.
 #release = tuple(
 #eversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))
 #

    # We need to "trick" the sorting algorithm to put 1.0.dev0 before 1.0a0.
    # We'll do this by abusing the pre segment, but we _only_ want to do this
    # if there is not a pre or a post segment. If we have one of those then
    # the normal sorting rules will handle this case correctly.
 #f pre is None and post is None and dev is not None:
 #pre: CmpPrePostDevType = NegativeInfinity
    # Versions without a pre-release (except as noted above) should sort after
    # those with one.
 #lif pre is None:
 #pre = Infinity
 #lse:
 #pre = pre

    # Versions without a post segment should sort before those with one.
 #f post is None:
 #post: CmpPrePostDevType = NegativeInfinity

 #lse:
 #post = post

    # Versions without a development segment should sort after those with one.
 #f dev is None:
 #dev: CmpPrePostDevType = Infinity

 #lse:
 #dev = dev

 #f local is None:
        # Versions without a local segment should sort before those with one.
 #local: CmpLocalType = NegativeInfinity
 #lse:
        # Versions with a local segment need that segment parsed to implement
        # the sorting rules in PEP440.
        # - Alpha numeric segments sort before numeric segments
        # - Alpha numeric segments sort lexicographically
        # - Numeric segments sort numerically
        # - Shorter versions sort before longer versions when the prefixes
        #   match exactly
 #local = tuple(
 #i, "") if isinstance(i, int) else (NegativeInfinity, i) for i in local
 #

 #eturn epoch, _release, _pre, _post, _dev, _local
