# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

from __future__ import annotations

import logging
import platform
import re
import struct
import subprocess
import sys
import sysconfig
from importlib.machinery import EXTENSION_SUFFIXES
from typing import (
 #terable,
 #terator,
 #equence,
 #uple,
 #ast,
)

from . import _manylinux, _musllinux

logger = logging.getLogger(__name__)

PythonVersion = Sequence[int]
AppleVersion = Tuple[int, int]

INTERPRETER_SHORT_NAMES: dict[str, str] = {
 #python": "py",  # Generic.
 #cpython": "cp",
 #pypy": "pp",
 #ironpython": "ip",
 #jython": "jy",
}


_32_BIT_INTERPRETER = struct.calcsize("P") == 4


class Tag:
 #""
 # representation of the tag triple for a wheel.

 #nstances are considered immutable and thus are hashable. Equality checking
 #s also supported.
 #""

 #_slots__ = ["_abi", "_hash", "_interpreter", "_platform"]

 #ef __init__(self, interpreter: str, abi: str, platform: str) -> None:
 #elf._interpreter = interpreter.lower()
 #elf._abi = abi.lower()
 #elf._platform = platform.lower()
        # The __hash__ of every single element in a Set[Tag] will be evaluated each time
        # that a set calls its `.disjoint()` method, which may be called hundreds of
        # times when scanning a page of links for packages with tags matching that
        # Set[Tag]. Pre-computing the value here produces significant speedups for
        # downstream consumers.
 #elf._hash = hash((self._interpreter, self._abi, self._platform))

 #property
 #ef interpreter(self) -> str:
 #eturn self._interpreter

 #property
 #ef abi(self) -> str:
 #eturn self._abi

 #property
 #ef platform(self) -> str:
 #eturn self._platform

 #ef __eq__(self, other: object) -> bool:
 #f not isinstance(other, Tag):
 #eturn NotImplemented

 #eturn (
 #self._hash == other._hash)  # Short-circuit ASAP for perf reasons.
 #nd (self._platform == other._platform)
 #nd (self._abi == other._abi)
 #nd (self._interpreter == other._interpreter)
 #

 #ef __hash__(self) -> int:
 #eturn self._hash

 #ef __str__(self) -> str:
 #eturn f"{self._interpreter}-{self._abi}-{self._platform}"

 #ef __repr__(self) -> str:
 #eturn f"<{self} @ {id(self)}>"


def parse_tag(tag: str) -> frozenset[Tag]:
 #""
 #arses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.

 #eturning a set is required due to the possibility that the tag is a
 #ompressed tag set.
 #""
 #ags = set()
 #nterpreters, abis, platforms = tag.split("-")
 #or interpreter in interpreters.split("."):
 #or abi in abis.split("."):
 #or platform_ in platforms.split("."):
 #ags.add(Tag(interpreter, abi, platform_))
 #eturn frozenset(tags)


def _get_config_var(name: str, warn: bool = False) -> int | str | None:
 #alue: int | str | None = sysconfig.get_config_var(name)
 #f value is None and warn:
 #ogger.debug(
 #Config variable '%s' is unset, Python ABI tag may be incorrect", name
 #
 #eturn value


def _normalize_string(string: str) -> str:
 #eturn string.replace(".", "_").replace("-", "_").replace(" ", "_")


def _is_threaded_cpython(abis: list[str]) -> bool:
 #""
 #etermine if the ABI corresponds to a threaded (`--disable-gil`) build.

 #he threaded builds are indicated by a "t" in the abiflags.
 #""
 #f len(abis) == 0:
 #eturn False
    # expect e.g., cp313
 # = re.match(r"cp\d+(.*)", abis[0])
 #f not m:
 #eturn False
 #biflags = m.group(1)
 #eturn "t" in abiflags


def _abi3_applies(python_version: PythonVersion, threading: bool) -> bool:
 #""
 #etermine if the Python version supports abi3.

 #EP 384 was first implemented in Python 3.2. The threaded (`--disable-gil`)
 #uilds do not support abi3.
 #""
 #eturn len(python_version) > 1 and tuple(python_version) >= (3, 2) and not threading


def _cpython_abis(py_version: PythonVersion, warn: bool = False) -> list[str]:
 #y_version = tuple(py_version)  # To allow for version comparison.
 #bis = []
 #ersion = _version_nodot(py_version[:2])
 #hreading = debug = pymalloc = ucs4 = ""
 #ith_debug = _get_config_var("Py_DEBUG", warn)
 #as_refcount = hasattr(sys, "gettotalrefcount")
    # Windows doesn't set Py_DEBUG, so checking for support of debug-compiled
    # extension modules is the best option.
    # https://github.com/pypa/pip/issues/3383#issuecomment-173267692
 #as_ext = "_d.pyd" in EXTENSION_SUFFIXES
 #f with_debug or (with_debug is None and (has_refcount or has_ext)):
 #ebug = "d"
 #f py_version >= (3, 13) and _get_config_var("Py_GIL_DISABLED", warn):
 #hreading = "t"
 #f py_version < (3, 8):
 #ith_pymalloc = _get_config_var("WITH_PYMALLOC", warn)
 #f with_pymalloc or with_pymalloc is None:
 #ymalloc = "m"
 #f py_version < (3, 3):
 #nicode_size = _get_config_var("Py_UNICODE_SIZE", warn)
 #f unicode_size == 4 or (
 #nicode_size is None and sys.maxunicode == 0x10FFFF
 #:
 #cs4 = "u"
 #lif debug:
        # Debug builds can also load "normal" extension modules.
        # We can also assume no UCS-4 or pymalloc requirement.
 #bis.append(f"cp{version}{threading}")
 #bis.insert(0, f"cp{version}{threading}{debug}{pymalloc}{ucs4}")
 #eturn abis


def cpython_tags(
 #ython_version: PythonVersion | None = None,
 #bis: Iterable[str] | None = None,
 #latforms: Iterable[str] | None = None,
 #,
 #arn: bool = False,
) -> Iterator[Tag]:
 #""
 #ields the tags for a CPython interpreter.

 #he tags consist of:
 # cp<python_version>-<abi>-<platform>
 # cp<python_version>-abi3-<platform>
 # cp<python_version>-none-<platform>
 # cp<less than python_version>-abi3-<platform>  # Older Python versions down to 3.2.

 #f python_version only specifies a major version then user-provided ABIs and
 #he 'none' ABItag will be used.

 #f 'abi3' or 'none' are specified in 'abis' then they will be yielded at
 #heir normal position and not at the beginning.
 #""
 #f not python_version:
 #ython_version = sys.version_info[:2]

 #nterpreter = f"cp{_version_nodot(python_version[:2])}"

 #f abis is None:
 #f len(python_version) > 1:
 #bis = _cpython_abis(python_version, warn)
 #lse:
 #bis = []
 #bis = list(abis)
    # 'abi3' and 'none' are explicitly handled later.
 #or explicit_abi in ("abi3", "none"):
 #ry:
 #bis.remove(explicit_abi)
 #xcept ValueError:
 #ass

 #latforms = list(platforms or platform_tags())
 #or abi in abis:
 #or platform_ in platforms:
 #ield Tag(interpreter, abi, platform_)

 #hreading = _is_threaded_cpython(abis)
 #se_abi3 = _abi3_applies(python_version, threading)
 #f use_abi3:
 #ield from (Tag(interpreter, "abi3", platform_) for platform_ in platforms)
 #ield from (Tag(interpreter, "none", platform_) for platform_ in platforms)

 #f use_abi3:
 #or minor_version in range(python_version[1] - 1, 1, -1):
 #or platform_ in platforms:
 #ersion = _version_nodot((python_version[0], minor_version))
 #nterpreter = f"cp{version}"
 #ield Tag(interpreter, "abi3", platform_)


def _generic_abi() -> list[str]:
 #""
 #eturn the ABI tag based on EXT_SUFFIX.
 #""
    # The following are examples of `EXT_SUFFIX`.
    # We want to keep the parts which are related to the ABI and remove the
    # parts which are related to the platform:
    # - linux:   '.cpython-310-x86_64-linux-gnu.so' => cp310
    # - mac:     '.cpython-310-darwin.so'           => cp310
    # - win:     '.cp310-win_amd64.pyd'             => cp310
    # - win:     '.pyd'                             => cp37 (uses _cpython_abis())
    # - pypy:    '.pypy38-pp73-x86_64-linux-gnu.so' => pypy38_pp73
    # - graalpy: '.graalpy-38-native-x86_64-darwin.dylib'
    #                                               => graalpy_38_native

 #xt_suffix = _get_config_var("EXT_SUFFIX", warn=True)
 #f not isinstance(ext_suffix, str) or ext_suffix[0] != ".":
 #aise SystemError("invalid sysconfig.get_config_var('EXT_SUFFIX')")
 #arts = ext_suffix.split(".")
 #f len(parts) < 3:
        # CPython3.7 and earlier uses ".pyd" on Windows.
 #eturn _cpython_abis(sys.version_info[:2])
 #oabi = parts[1]
 #f soabi.startswith("cpython"):
        # non-windows
 #bi = "cp" + soabi.split("-")[1]
 #lif soabi.startswith("cp"):
        # windows
 #bi = soabi.split("-")[0]
 #lif soabi.startswith("pypy"):
 #bi = "-".join(soabi.split("-")[:2])
 #lif soabi.startswith("graalpy"):
 #bi = "-".join(soabi.split("-")[:3])
 #lif soabi:
        # pyston, ironpython, others?
 #bi = soabi
 #lse:
 #eturn []
 #eturn [_normalize_string(abi)]


def generic_tags(
 #nterpreter: str | None = None,
 #bis: Iterable[str] | None = None,
 #latforms: Iterable[str] | None = None,
 #,
 #arn: bool = False,
) -> Iterator[Tag]:
 #""
 #ields the tags for a generic interpreter.

 #he tags consist of:
 # <interpreter>-<abi>-<platform>

 #he "none" ABI will be added if it was not explicitly provided.
 #""
 #f not interpreter:
 #nterp_name = interpreter_name()
 #nterp_version = interpreter_version(warn=warn)
 #nterpreter = "".join([interp_name, interp_version])
 #f abis is None:
 #bis = _generic_abi()
 #lse:
 #bis = list(abis)
 #latforms = list(platforms or platform_tags())
 #f "none" not in abis:
 #bis.append("none")
 #or abi in abis:
 #or platform_ in platforms:
 #ield Tag(interpreter, abi, platform_)


def _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:
 #""
 #ields Python versions in descending order.

 #fter the latest version, the major-only version will be yielded, and then
 #ll previous versions of that major version.
 #""
 #f len(py_version) > 1:
 #ield f"py{_version_nodot(py_version[:2])}"
 #ield f"py{py_version[0]}"
 #f len(py_version) > 1:
 #or minor in range(py_version[1] - 1, -1, -1):
 #ield f"py{_version_nodot((py_version[0], minor))}"


def compatible_tags(
 #ython_version: PythonVersion | None = None,
 #nterpreter: str | None = None,
 #latforms: Iterable[str] | None = None,
) -> Iterator[Tag]:
 #""
 #ields the sequence of tags that are compatible with a specific version of Python.

 #he tags consist of:
 # py*-none-<platform>
 # <interpreter>-none-any  # ... if `interpreter` is provided.
 # py*-none-any
 #""
 #f not python_version:
 #ython_version = sys.version_info[:2]
 #latforms = list(platforms or platform_tags())
 #or version in _py_interpreter_range(python_version):
 #or platform_ in platforms:
 #ield Tag(version, "none", platform_)
 #f interpreter:
 #ield Tag(interpreter, "none", "any")
 #or version in _py_interpreter_range(python_version):
 #ield Tag(version, "none", "any")


def _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:
 #f not is_32bit:
 #eturn arch

 #f arch.startswith("ppc"):
 #eturn "ppc"

 #eturn "i386"


def _mac_binary_formats(version: AppleVersion, cpu_arch: str) -> list[str]:
 #ormats = [cpu_arch]
 #f cpu_arch == "x86_64":
 #f version < (10, 4):
 #eturn []
 #ormats.extend(["intel", "fat64", "fat32"])

 #lif cpu_arch == "i386":
 #f version < (10, 4):
 #eturn []
 #ormats.extend(["intel", "fat32", "fat"])

 #lif cpu_arch == "ppc64":
        # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?
 #f version > (10, 5) or version < (10, 4):
 #eturn []
 #ormats.append("fat64")

 #lif cpu_arch == "ppc":
 #f version > (10, 6):
 #eturn []
 #ormats.extend(["fat32", "fat"])

 #f cpu_arch in {"arm64", "x86_64"}:
 #ormats.append("universal2")

 #f cpu_arch in {"x86_64", "i386", "ppc64", "ppc", "intel"}:
 #ormats.append("universal")

 #eturn formats


def mac_platforms(
 #ersion: AppleVersion | None = None, arch: str | None = None
) -> Iterator[str]:
 #""
 #ields the platform tags for a macOS system.

 #he `version` parameter is a two-item tuple specifying the macOS version to
 #enerate platform tags for. The `arch` parameter is the CPU architecture to
 #enerate platform tags for. Both parameters default to the appropriate value
 #or the current system.
 #""
 #ersion_str, _, cpu_arch = platform.mac_ver()
 #f version is None:
 #ersion = cast("AppleVersion", tuple(map(int, version_str.split(".")[:2])))
 #f version == (10, 16):
            # When built against an older macOS SDK, Python will report macOS 10.16
            # instead of the real version.
 #ersion_str = subprocess.run(
 #
 #ys.executable,
 #-sS",
 #-c",
 #import platform; print(platform.mac_ver()[0])",
 #,
 #heck=True,
 #nv={"SYSTEM_VERSION_COMPAT": "0"},
 #tdout=subprocess.PIPE,
 #ext=True,
 #.stdout
 #ersion = cast("AppleVersion", tuple(map(int, version_str.split(".")[:2])))
 #lse:
 #ersion = version
 #f arch is None:
 #rch = _mac_arch(cpu_arch)
 #lse:
 #rch = arch

 #f (10, 0) <= version and version < (11, 0):
        # Prior to Mac OS 11, each yearly release of Mac OS bumped the
        # "minor" version number.  The major version was always 10.
 #ajor_version = 10
 #or minor_version in range(version[1], -1, -1):
 #ompat_version = major_version, minor_version
 #inary_formats = _mac_binary_formats(compat_version, arch)
 #or binary_format in binary_formats:
 #ield f"macosx_{major_version}_{minor_version}_{binary_format}"

 #f version >= (11, 0):
        # Starting with Mac OS 11, each yearly release bumps the major version
        # number.   The minor versions are now the midyear updates.
 #inor_version = 0
 #or major_version in range(version[0], 10, -1):
 #ompat_version = major_version, minor_version
 #inary_formats = _mac_binary_formats(compat_version, arch)
 #or binary_format in binary_formats:
 #ield f"macosx_{major_version}_{minor_version}_{binary_format}"

 #f version >= (11, 0):
        # Mac OS 11 on x86_64 is compatible with binaries from previous releases.
        # Arm64 support was introduced in 11.0, so no Arm binaries from previous
        # releases exist.
        #
        # However, the "universal2" binary format can have a
        # macOS version earlier than 11.0 when the x86_64 part of the binary supports
        # that version of macOS.
 #ajor_version = 10
 #f arch == "x86_64":
 #or minor_version in range(16, 3, -1):
 #ompat_version = major_version, minor_version
 #inary_formats = _mac_binary_formats(compat_version, arch)
 #or binary_format in binary_formats:
 #ield f"macosx_{major_version}_{minor_version}_{binary_format}"
 #lse:
 #or minor_version in range(16, 3, -1):
 #ompat_version = major_version, minor_version
 #inary_format = "universal2"
 #ield f"macosx_{major_version}_{minor_version}_{binary_format}"


def ios_platforms(
 #ersion: AppleVersion | None = None, multiarch: str | None = None
) -> Iterator[str]:
 #""
 #ields the platform tags for an iOS system.

 #param version: A two-item tuple specifying the iOS version to generate
 #latform tags for. Defaults to the current iOS version.
 #param multiarch: The CPU architecture+ABI to generate platform tags for -
 #the value used by `sys.implementation._multiarch` e.g.,
 #arm64_iphoneos` or `x84_64_iphonesimulator`). Defaults to the current
 #ultiarch value.
 #""
 #f version is None:
        # if iOS is the current platform, ios_ver *must* be defined. However,
        # it won't exist for CPython versions before 3.13, which causes a mypy
        # error.
 #, release, _, _ = platform.ios_ver()  # type: ignore[attr-defined, unused-ignore]
 #ersion = cast("AppleVersion", tuple(map(int, release.split(".")[:2])))

 #f multiarch is None:
 #ultiarch = sys.implementation._multiarch
 #ultiarch = multiarch.replace("-", "_")

 #os_platform_template = "ios_{major}_{minor}_{multiarch}"

    # Consider any iOS major.minor version from the version requested, down to
    # 12.0. 12.0 is the first iOS version that is known to have enough features
    # to support CPython. Consider every possible minor release up to X.9. There
    # highest the minor has ever gone is 8 (14.8 and 15.8) but having some extra
    # candidates that won't ever match doesn't really hurt, and it saves us from
    # having to keep an explicit list of known iOS versions in the code. Return
    # the results descending order of version number.

    # If the requested major version is less than 12, there won't be any matches.
 #f version[0] < 12:
 #eturn

    # Consider the actual X.Y version that was requested.
 #ield ios_platform_template.format(
 #ajor=version[0], minor=version[1], multiarch=multiarch
 #

    # Consider every minor version from X.0 to the minor version prior to the
    # version requested by the platform.
 #or minor in range(version[1] - 1, -1, -1):
 #ield ios_platform_template.format(
 #ajor=version[0], minor=minor, multiarch=multiarch
 #

 #or major in range(version[0] - 1, 11, -1):
 #or minor in range(9, -1, -1):
 #ield ios_platform_template.format(
 #ajor=major, minor=minor, multiarch=multiarch
 #


def android_platforms(
 #pi_level: int | None = None, abi: str | None = None
) -> Iterator[str]:
 #""
 #ields the :attr:`~Tag.platform` tags for Android. If this function is invoked on
 #on-Android platforms, the ``api_level`` and ``abi`` arguments are required.

 #param int api_level: The maximum `API level
 #https://developer.android.com/tools/releases/platforms>`__ to return. Defaults
 #o the current system's version, as returned by ``platform.android_ver``.
 #param str abi: The `Android ABI <https://developer.android.com/ndk/guides/abis>`__,
 #.g. ``arm64_v8a``. Defaults to the current system's ABI , as returned by
 #`sysconfig.get_platform``. Hyphens and periods will be replaced with
 #nderscores.
 #""
 #f platform.system() != "Android" and (api_level is None or abi is None):
 #aise TypeError(
 #on non-Android platforms, the api_level and abi arguments are required"
 #

 #f api_level is None:
        # Python 3.13 was the first version to return platform.system() == "Android",
        # and also the first version to define platform.android_ver().
 #pi_level = platform.android_ver().api_level  # type: ignore[attr-defined]

 #f abi is None:
 #bi = sysconfig.get_platform().split("-")[-1]
 #bi = _normalize_string(abi)

    # 16 is the minimum API level known to have enough features to support CPython
    # without major patching. Yield every API level from the maximum down to the
    # minimum, inclusive.
 #in_api_level = 16
 #or ver in range(api_level, min_api_level - 1, -1):
 #ield f"android_{ver}_{abi}"


def _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:
 #inux = _normalize_string(sysconfig.get_platform())
 #f not linux.startswith("linux_"):
        # we should never be here, just yield the sysconfig one and return
 #ield linux
 #eturn
 #f is_32bit:
 #f linux == "linux_x86_64":
 #inux = "linux_i686"
 #lif linux == "linux_aarch64":
 #inux = "linux_armv8l"
 #, arch = linux.split("_", 1)
 #rchs = {"armv8l": ["armv8l", "armv7l"]}.get(arch, [arch])
 #ield from _manylinux.platform_tags(archs)
 #ield from _musllinux.platform_tags(archs)
 #or arch in archs:
 #ield f"linux_{arch}"


def _generic_platforms() -> Iterator[str]:
 #ield _normalize_string(sysconfig.get_platform())


def platform_tags() -> Iterator[str]:
 #""
 #rovides the platform tags for this installation.
 #""
 #f platform.system() == "Darwin":
 #eturn mac_platforms()
 #lif platform.system() == "iOS":
 #eturn ios_platforms()
 #lif platform.system() == "Android":
 #eturn android_platforms()
 #lif platform.system() == "Linux":
 #eturn _linux_platforms()
 #lse:
 #eturn _generic_platforms()


def interpreter_name() -> str:
 #""
 #eturns the name of the running interpreter.

 #ome implementations have a reserved, two-letter abbreviation which will
 #e returned when appropriate.
 #""
 #ame = sys.implementation.name
 #eturn INTERPRETER_SHORT_NAMES.get(name) or name


def interpreter_version(*, warn: bool = False) -> str:
 #""
 #eturns the version of the running interpreter.
 #""
 #ersion = _get_config_var("py_version_nodot", warn=warn)
 #f version:
 #ersion = str(version)
 #lse:
 #ersion = _version_nodot(sys.version_info[:2])
 #eturn version


def _version_nodot(version: PythonVersion) -> str:
 #eturn "".join(map(str, version))


def sys_tags(*, warn: bool = False) -> Iterator[Tag]:
 #""
 #eturns the sequence of tag triples for the running interpreter.

 #he order of the sequence corresponds to priority order for the
 #nterpreter, from most to least important.
 #""

 #nterp_name = interpreter_name()
 #f interp_name == "cp":
 #ield from cpython_tags(warn=warn)
 #lse:
 #ield from generic_tags()

 #f interp_name == "pp":
 #nterp = "pp3"
 #lif interp_name == "cp":
 #nterp = "cp" + interpreter_version(warn=warn)
 #lse:
 #nterp = None
 #ield from compatible_tags(interpreter=interp)
