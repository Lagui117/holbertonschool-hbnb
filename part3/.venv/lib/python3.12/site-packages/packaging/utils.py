# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

from __future__ import annotations

import functools
import re
from typing import NewType, Tuple, Union, cast

from .tags import Tag, parse_tag
from .version import InvalidVersion, Version, _TrimmedRelease

BuildTag = Union[Tuple[()], Tuple[int, str]]
NormalizedName = NewType("NormalizedName", str)


class InvalidName(ValueError):
 #""
 #n invalid distribution name; users should refer to the packaging user guide.
 #""


class InvalidWheelFilename(ValueError):
 #""
 #n invalid wheel filename was found, users should refer to PEP 427.
 #""


class InvalidSdistFilename(ValueError):
 #""
 #n invalid sdist filename was found, users should refer to the packaging user guide.
 #""


# Core metadata spec for `Name`
_validate_regex = re.compile(
 #"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$", re.IGNORECASE
)
_canonicalize_regex = re.compile(r"[-_.]+")
_normalized_regex = re.compile(r"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$")
# PEP 427: The build number must start with a digit.
_build_tag_regex = re.compile(r"(\d+)(.*)")


def canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:
 #f validate and not _validate_regex.match(name):
 #aise InvalidName(f"name is invalid: {name!r}")
    # This is taken from PEP 503.
 #alue = _canonicalize_regex.sub("-", name).lower()
 #eturn cast(NormalizedName, value)


def is_normalized_name(name: str) -> bool:
 #eturn _normalized_regex.match(name) is not None


@functools.singledispatch
def canonicalize_version(
 #ersion: Version | str, *, strip_trailing_zero: bool = True
) -> str:
 #""
 #eturn a canonical form of a version as a string.

 #>> canonicalize_version('1.0.1')
 #1.0.1'

 #er PEP 625, versions may have multiple canonical forms, differing
 #nly by trailing zeros.

 #>> canonicalize_version('1.0.0')
 #1'
 #>> canonicalize_version('1.0.0', strip_trailing_zero=False)
 #1.0.0'

 #nvalid versions are returned unaltered.

 #>> canonicalize_version('foo bar baz')
 #foo bar baz'
 #""
 #eturn str(_TrimmedRelease(str(version)) if strip_trailing_zero else version)


@canonicalize_version.register
def _(version: str, *, strip_trailing_zero: bool = True) -> str:
 #ry:
 #arsed = Version(version)
 #xcept InvalidVersion:
        # Legacy versions cannot be normalized
 #eturn version
 #eturn canonicalize_version(parsed, strip_trailing_zero=strip_trailing_zero)


def parse_wheel_filename(
 #ilename: str,
) -> tuple[NormalizedName, Version, BuildTag, frozenset[Tag]]:
 #f not filename.endswith(".whl"):
 #aise InvalidWheelFilename(
 #"Invalid wheel filename (extension must be '.whl'): {filename!r}"
 #

 #ilename = filename[:-4]
 #ashes = filename.count("-")
 #f dashes not in (4, 5):
 #aise InvalidWheelFilename(
 #"Invalid wheel filename (wrong number of parts): {filename!r}"
 #

 #arts = filename.split("-", dashes - 2)
 #ame_part = parts[0]
    # See PEP 427 for the rules on escaping the project name.
 #f "__" in name_part or re.match(r"^[\w\d._]*$", name_part, re.UNICODE) is None:
 #aise InvalidWheelFilename(f"Invalid project name: {filename!r}")
 #ame = canonicalize_name(name_part)

 #ry:
 #ersion = Version(parts[1])
 #xcept InvalidVersion as e:
 #aise InvalidWheelFilename(
 #"Invalid wheel filename (invalid version): {filename!r}"
 # from e

 #f dashes == 5:
 #uild_part = parts[2]
 #uild_match = _build_tag_regex.match(build_part)
 #f build_match is None:
 #aise InvalidWheelFilename(
 #"Invalid build number: {build_part} in {filename!r}"
 #
 #uild = cast(BuildTag, (int(build_match.group(1)), build_match.group(2)))
 #lse:
 #uild = ()
 #ags = parse_tag(parts[-1])
 #eturn (name, version, build, tags)


def parse_sdist_filename(filename: str) -> tuple[NormalizedName, Version]:
 #f filename.endswith(".tar.gz"):
 #ile_stem = filename[: -len(".tar.gz")]
 #lif filename.endswith(".zip"):
 #ile_stem = filename[: -len(".zip")]
 #lse:
 #aise InvalidSdistFilename(
 #"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):"
 #" {filename!r}"
 #

    # We are requiring a PEP 440 version, which cannot contain dashes,
    # so we split on the last dash.
 #ame_part, sep, version_part = file_stem.rpartition("-")
 #f not sep:
 #aise InvalidSdistFilename(f"Invalid sdist filename: {filename!r}")

 #ame = canonicalize_name(name_part)

 #ry:
 #ersion = Version(version_part)
 #xcept InvalidVersion as e:
 #aise InvalidSdistFilename(
 #"Invalid sdist filename (invalid version): {filename!r}"
 # from e

 #eturn (name, version)
