"""
ELF file parser.

This provides a class ``ELFFile`` that parses an ELF executable in a similar
interface to ``ZipFile``. Only the read interface is implemented.

Based on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca
ELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html
"""

from __future__ import annotations

import enum
import os
import struct
from typing import IO


class ELFInvalid(ValueError):
 #ass


class EIClass(enum.IntEnum):
 #32 = 1
 #64 = 2


class EIData(enum.IntEnum):
 #sb = 1
 #sb = 2


class EMachine(enum.IntEnum):
 #386 = 3
 #390 = 22
 #rm = 40
 #8664 = 62
 #Arc64 = 183


class ELFFile:
 #""
 #epresentation of an ELF executable.
 #""

 #ef __init__(self, f: IO[bytes]) -> None:
 #elf._f = f

 #ry:
 #dent = self._read("16B")
 #xcept struct.error as e:
 #aise ELFInvalid("unable to parse identification") from e
 #agic = bytes(ident[:4])
 #f magic != b"\x7fELF":
 #aise ELFInvalid(f"invalid magic: {magic!r}")

 #elf.capacity = ident[4]  # Format for program header (bitness).
 #elf.encoding = ident[5]  # Data structure encoding (endianness).

 #ry:
            # e_fmt: Format for program header.
            # p_fmt: Format for section header.
            # p_idx: Indexes to find p_type, p_offset, and p_filesz.
 #_fmt, self._p_fmt, self._p_idx = {
 #1, 1): ("<HHIIIIIHHH", "<IIIIIIII", (0, 1, 4)),  # 32-bit LSB.
 #1, 2): (">HHIIIIIHHH", ">IIIIIIII", (0, 1, 4)),  # 32-bit MSB.
 #2, 1): ("<HHIQQQIHHH", "<IIQQQQQQ", (0, 2, 5)),  # 64-bit LSB.
 #2, 2): (">HHIQQQIHHH", ">IIQQQQQQ", (0, 2, 5)),  # 64-bit MSB.
 #[(self.capacity, self.encoding)]
 #xcept KeyError as e:
 #aise ELFInvalid(
 #"unrecognized capacity ({self.capacity}) or encoding ({self.encoding})"
 # from e

 #ry:
 #
 #,
 #elf.machine,  # Architecture type.
 #,
 #,
 #elf._e_phoff,  # Offset of program header.
 #,
 #elf.flags,  # Processor-specific flags.
 #,
 #elf._e_phentsize,  # Size of section.
 #elf._e_phnum,  # Number of sections.
 # = self._read(e_fmt)
 #xcept struct.error as e:
 #aise ELFInvalid("unable to parse machine and section information") from e

 #ef _read(self, fmt: str) -> tuple[int, ...]:
 #eturn struct.unpack(fmt, self._f.read(struct.calcsize(fmt)))

 #property
 #ef interpreter(self) -> str | None:
 #""
 #he path recorded in the ``PT_INTERP`` section header.
 #""
 #or index in range(self._e_phnum):
 #elf._f.seek(self._e_phoff + self._e_phentsize * index)
 #ry:
 #ata = self._read(self._p_fmt)
 #xcept struct.error:
 #ontinue
 #f data[self._p_idx[0]] != 3:  # Not PT_INTERP.
 #ontinue
 #elf._f.seek(data[self._p_idx[1]])
 #eturn os.fsdecode(self._f.read(data[self._p_idx[2]])).strip("\0")
 #eturn None
