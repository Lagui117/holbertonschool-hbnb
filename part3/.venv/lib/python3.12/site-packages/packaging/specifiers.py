# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
"""
.. testsetup::

 #rom packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier
 #rom packaging.version import Version
"""

from __future__ import annotations

import abc
import itertools
import re
from typing import Callable, Iterable, Iterator, TypeVar, Union

from .utils import canonicalize_version
from .version import Version

UnparsedVersion = Union[Version, str]
UnparsedVersionVar = TypeVar("UnparsedVersionVar", bound=UnparsedVersion)
CallableOperator = Callable[[Version, str], bool]


def _coerce_version(version: UnparsedVersion) -> Version:
 #f not isinstance(version, Version):
 #ersion = Version(version)
 #eturn version


class InvalidSpecifier(ValueError):
 #""
 #aised when attempting to create a :class:`Specifier` with a specifier
 #tring that is invalid.

 #>> Specifier("lolwat")
 #raceback (most recent call last):
 #..
 #ackaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'
 #""


class BaseSpecifier(metaclass=abc.ABCMeta):
 #abc.abstractmethod
 #ef __str__(self) -> str:
 #""
 #eturns the str representation of this Specifier-like object. This
 #hould be representative of the Specifier itself.
 #""

 #abc.abstractmethod
 #ef __hash__(self) -> int:
 #""
 #eturns a hash value for this Specifier-like object.
 #""

 #abc.abstractmethod
 #ef __eq__(self, other: object) -> bool:
 #""
 #eturns a boolean representing whether or not the two Specifier-like
 #bjects are equal.

 #param other: The other object to check against.
 #""

 #property
 #abc.abstractmethod
 #ef prereleases(self) -> bool | None:
 #""Whether or not pre-releases as a whole are allowed.

 #his can be set to either ``True`` or ``False`` to explicitly enable or disable
 #rereleases or it can be set to ``None`` (the default) to use default semantics.
 #""

 #prereleases.setter
 #ef prereleases(self, value: bool) -> None:
 #""Setter for :attr:`prereleases`.

 #param value: The value to set.
 #""

 #abc.abstractmethod
 #ef contains(self, item: str, prereleases: bool | None = None) -> bool:
 #""
 #etermines if the given item is contained within this specifier.
 #""

 #abc.abstractmethod
 #ef filter(
 #elf, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None
 # -> Iterator[UnparsedVersionVar]:
 #""
 #akes an iterable of items and filters them so that only items which
 #re contained within this specifier are allowed in it.
 #""


class Specifier(BaseSpecifier):
 #""This class abstracts handling of version specifiers.

 #. tip::

 #t is generally not required to instantiate this manually. You should instead
 #refer to work with :class:`SpecifierSet` instead, which can parse
 #omma-separated version specifiers (which is what package metadata contains).
 #""

 #operator_regex_str = r"""
 #?P<operator>(~=|==|!=|<=|>=|<|>|===))
 #""
 #version_regex_str = r"""
 #?P<version>
 #?:
                # The identity operators allow for an escape hatch that will
                # do an exact string match of the version you wish to install.
                # This will not be parsed by PEP 440 and we cannot determine
                # any semantic meaning from it. This operator is discouraged
                # but included entirely as an escape hatch.
 #?<====)  # Only match for the identity operator
 #s*
 #^\s;)]*  # The arbitrary version can be just about anything,
                          # we match everything except for whitespace, a
                          # semi-colon for marker support, and a closing paren
                          # since versions can be enclosed in them.
 #
 #
 #?:
                # The (non)equality operators allow for wild card and local
                # versions to be specified so we have to define these two
                # operators separately to enable that.
 #?<===|!=)            # Only match for equals and not equals

 #s*
 #?
 #?:[0-9]+!)?          # epoch
 #0-9]+(?:\.[0-9]+)*   # release

                # You cannot use a wild card and a pre-release, post-release, a dev or
                # local version together so group them with a | and make them optional.
 #?:
 #.\*  # Wild card syntax of .*
 #
 #?:                                  # pre release
 #-_\.]?
 #alpha|beta|preview|pre|a|b|c|rc)
 #-_\.]?
 #0-9]*
 #?
 #?:                                  # post release
 #?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
 #?
 #?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release
 #?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local
 #?
 #
 #
 #?:
                # The compatible operator requires at least two digits in the
                # release segment.
 #?<=~=)               # Only match for the compatible operator

 #s*
 #?
 #?:[0-9]+!)?          # epoch
 #0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *)
 #?:                   # pre release
 #-_\.]?
 #alpha|beta|preview|pre|a|b|c|rc)
 #-_\.]?
 #0-9]*
 #?
 #?:                                   # post release
 #?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
 #?
 #?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
 #
 #
 #?:
                # All other operators only allow a sub set of what the
                # (non)equality operators do. Specifically they do not allow
                # local versions to be specified nor do they allow the prefix
                # matching wild cards.
 #?<!==|!=|~=)         # We have special cases for these
                                      # operators so we want to make sure they
                                      # don't match here.

 #s*
 #?
 #?:[0-9]+!)?          # epoch
 #0-9]+(?:\.[0-9]+)*   # release
 #?:                   # pre release
 #-_\.]?
 #alpha|beta|preview|pre|a|b|c|rc)
 #-_\.]?
 #0-9]*
 #?
 #?:                                   # post release
 #?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
 #?
 #?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
 #
 #
 #""

 #regex = re.compile(
 #"^\s*" + _operator_regex_str + _version_regex_str + r"\s*$",
 #e.VERBOSE | re.IGNORECASE,
 #

 #operators = {
 #~=": "compatible",
 #==": "equal",
 #!=": "not_equal",
 #<=": "less_than_equal",
 #>=": "greater_than_equal",
 #<": "less_than",
 #>": "greater_than",
 #===": "arbitrary",
 #

 #ef __init__(self, spec: str = "", prereleases: bool | None = None) -> None:
 #""Initialize a Specifier instance.

 #param spec:
 #he string representation of a specifier which will be parsed and
 #ormalized before use.
 #param prereleases:
 #his tells the specifier if it should accept prerelease versions if
 #pplicable or not. The default of ``None`` will autodetect it from the
 #iven specifiers.
 #raises InvalidSpecifier:
 #f the given specifier is invalid (i.e. bad syntax).
 #""
 #atch = self._regex.search(spec)
 #f not match:
 #aise InvalidSpecifier(f"Invalid specifier: {spec!r}")

 #elf._spec: tuple[str, str] = (
 #atch.group("operator").strip(),
 #atch.group("version").strip(),
 #

        # Store whether or not this Specifier should accept prereleases
 #elf._prereleases = prereleases

    # https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515
 #property  # type: ignore[override]
 #ef prereleases(self) -> bool:
        # If there is an explicit prereleases set for this, then we'll just
        # blindly use that.
 #f self._prereleases is not None:
 #eturn self._prereleases

        # Look at all of our specifiers and determine if they are inclusive
        # operators, and if they are if they are including an explicit
        # prerelease.
 #perator, version = self._spec
 #f operator in ["==", ">=", "<=", "~=", "===", ">", "<"]:
            # The == specifier can include a trailing .*, if it does we
            # want to remove before parsing.
 #f operator == "==" and version.endswith(".*"):
 #ersion = version[:-2]

            # Parse the version, and if it is a pre-release than this
            # specifier allows pre-releases.
 #f Version(version).is_prerelease:
 #eturn True

 #eturn False

 #prereleases.setter
 #ef prereleases(self, value: bool) -> None:
 #elf._prereleases = value

 #property
 #ef operator(self) -> str:
 #""The operator of this specifier.

 #>> Specifier("==1.2.3").operator
 #=='
 #""
 #eturn self._spec[0]

 #property
 #ef version(self) -> str:
 #""The version of this specifier.

 #>> Specifier("==1.2.3").version
 #1.2.3'
 #""
 #eturn self._spec[1]

 #ef __repr__(self) -> str:
 #""A representation of the Specifier that shows all internal state.

 #>> Specifier('>=1.0.0')
 #Specifier('>=1.0.0')>
 #>> Specifier('>=1.0.0', prereleases=False)
 #Specifier('>=1.0.0', prereleases=False)>
 #>> Specifier('>=1.0.0', prereleases=True)
 #Specifier('>=1.0.0', prereleases=True)>
 #""
 #re = (
 #", prereleases={self.prereleases!r}"
 #f self._prereleases is not None
 #lse ""
 #

 #eturn f"<{self.__class__.__name__}({str(self)!r}{pre})>"

 #ef __str__(self) -> str:
 #""A string representation of the Specifier that can be round-tripped.

 #>> str(Specifier('>=1.0.0'))
 #>=1.0.0'
 #>> str(Specifier('>=1.0.0', prereleases=False))
 #>=1.0.0'
 #""
 #eturn "{}{}".format(*self._spec)

 #property
 #ef _canonical_spec(self) -> tuple[str, str]:
 #anonical_version = canonicalize_version(
 #elf._spec[1],
 #trip_trailing_zero=(self._spec[0] != "~="),
 #
 #eturn self._spec[0], canonical_version

 #ef __hash__(self) -> int:
 #eturn hash(self._canonical_spec)

 #ef __eq__(self, other: object) -> bool:
 #""Whether or not the two Specifier-like objects are equal.

 #param other: The other object to check against.

 #he value of :attr:`prereleases` is ignored.

 #>> Specifier("==1.2.3") == Specifier("== 1.2.3.0")
 #rue
 #>> (Specifier("==1.2.3", prereleases=False) ==
 #..  Specifier("==1.2.3", prereleases=True))
 #rue
 #>> Specifier("==1.2.3") == "==1.2.3"
 #rue
 #>> Specifier("==1.2.3") == Specifier("==1.2.4")
 #alse
 #>> Specifier("==1.2.3") == Specifier("~=1.2.3")
 #alse
 #""
 #f isinstance(other, str):
 #ry:
 #ther = self.__class__(str(other))
 #xcept InvalidSpecifier:
 #eturn NotImplemented
 #lif not isinstance(other, self.__class__):
 #eturn NotImplemented

 #eturn self._canonical_spec == other._canonical_spec

 #ef _get_operator(self, op: str) -> CallableOperator:
 #perator_callable: CallableOperator = getattr(
 #elf, f"_compare_{self._operators[op]}"
 #
 #eturn operator_callable

 #ef _compare_compatible(self, prospective: Version, spec: str) -> bool:
        # Compatible releases have an equivalent combination of >= and ==. That
        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to
        # implement this in terms of the other specifiers instead of
        # implementing it ourselves. The only thing we need to do is construct
        # the other specifiers.

        # We want everything but the last item in the version, but we want to
        # ignore suffix segments.
 #refix = _version_join(
 #ist(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]
 #

        # Add the prefix notation to the end of our string
 #refix += ".*"

 #eturn self._get_operator(">=")(prospective, spec) and self._get_operator("==")(
 #rospective, prefix
 #

 #ef _compare_equal(self, prospective: Version, spec: str) -> bool:
        # We need special logic to handle prefix matching
 #f spec.endswith(".*"):
            # In the case of prefix matching we want to ignore local segment.
 #ormalized_prospective = canonicalize_version(
 #rospective.public, strip_trailing_zero=False
 #
            # Get the normalized version string ignoring the trailing .*
 #ormalized_spec = canonicalize_version(spec[:-2], strip_trailing_zero=False)
            # Split the spec out by bangs and dots, and pretend that there is
            # an implicit dot in between a release segment and a pre-release segment.
 #plit_spec = _version_split(normalized_spec)

            # Split the prospective version out by bangs and dots, and pretend
            # that there is an implicit dot in between a release segment and
            # a pre-release segment.
 #plit_prospective = _version_split(normalized_prospective)

            # 0-pad the prospective version before shortening it to get the correct
            # shortened version.
 #added_prospective, _ = _pad_version(split_prospective, split_spec)

            # Shorten the prospective version to be the same length as the spec
            # so that we can determine if the specifier is a prefix of the
            # prospective version or not.
 #hortened_prospective = padded_prospective[: len(split_spec)]

 #eturn shortened_prospective == split_spec
 #lse:
            # Convert our spec string into a Version
 #pec_version = Version(spec)

            # If the specifier does not have a local segment, then we want to
            # act as if the prospective version also does not have a local
            # segment.
 #f not spec_version.local:
 #rospective = Version(prospective.public)

 #eturn prospective == spec_version

 #ef _compare_not_equal(self, prospective: Version, spec: str) -> bool:
 #eturn not self._compare_equal(prospective, spec)

 #ef _compare_less_than_equal(self, prospective: Version, spec: str) -> bool:
        # NB: Local version identifiers are NOT permitted in the version
        # specifier, so local version labels can be universally removed from
        # the prospective version.
 #eturn Version(prospective.public) <= Version(spec)

 #ef _compare_greater_than_equal(self, prospective: Version, spec: str) -> bool:
        # NB: Local version identifiers are NOT permitted in the version
        # specifier, so local version labels can be universally removed from
        # the prospective version.
 #eturn Version(prospective.public) >= Version(spec)

 #ef _compare_less_than(self, prospective: Version, spec_str: str) -> bool:
        # Convert our spec to a Version instance, since we'll want to work with
        # it as a version.
 #pec = Version(spec_str)

        # Check to see if the prospective version is less than the spec
        # version. If it's not we can short circuit and just return False now
        # instead of doing extra unneeded work.
 #f not prospective < spec:
 #eturn False

        # This special case is here so that, unless the specifier itself
        # includes is a pre-release version, that we do not accept pre-release
        # versions for the version mentioned in the specifier (e.g. <3.1 should
        # not match 3.1.dev0, but should match 3.0.dev0).
 #f not spec.is_prerelease and prospective.is_prerelease:
 #f Version(prospective.base_version) == Version(spec.base_version):
 #eturn False

        # If we've gotten to here, it means that prospective version is both
        # less than the spec version *and* it's not a pre-release of the same
        # version in the spec.
 #eturn True

 #ef _compare_greater_than(self, prospective: Version, spec_str: str) -> bool:
        # Convert our spec to a Version instance, since we'll want to work with
        # it as a version.
 #pec = Version(spec_str)

        # Check to see if the prospective version is greater than the spec
        # version. If it's not we can short circuit and just return False now
        # instead of doing extra unneeded work.
 #f not prospective > spec:
 #eturn False

        # This special case is here so that, unless the specifier itself
        # includes is a post-release version, that we do not accept
        # post-release versions for the version mentioned in the specifier
        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).
 #f not spec.is_postrelease and prospective.is_postrelease:
 #f Version(prospective.base_version) == Version(spec.base_version):
 #eturn False

        # Ensure that we do not allow a local version of the version mentioned
        # in the specifier, which is technically greater than, to match.
 #f prospective.local is not None:
 #f Version(prospective.base_version) == Version(spec.base_version):
 #eturn False

        # If we've gotten to here, it means that prospective version is both
        # greater than the spec version *and* it's not a pre-release of the
        # same version in the spec.
 #eturn True

 #ef _compare_arbitrary(self, prospective: Version, spec: str) -> bool:
 #eturn str(prospective).lower() == str(spec).lower()

 #ef __contains__(self, item: str | Version) -> bool:
 #""Return whether or not the item is contained in this specifier.

 #param item: The item to check for.

 #his is used for the ``in`` operator and behaves the same as
 #meth:`contains` with no ``prereleases`` argument passed.

 #>> "1.2.3" in Specifier(">=1.2.3")
 #rue
 #>> Version("1.2.3") in Specifier(">=1.2.3")
 #rue
 #>> "1.0.0" in Specifier(">=1.2.3")
 #alse
 #>> "1.3.0a1" in Specifier(">=1.2.3")
 #alse
 #>> "1.3.0a1" in Specifier(">=1.2.3", prereleases=True)
 #rue
 #""
 #eturn self.contains(item)

 #ef contains(self, item: UnparsedVersion, prereleases: bool | None = None) -> bool:
 #""Return whether or not the item is contained in this specifier.

 #param item:
 #he item to check for, which can be a version string or a
 #class:`Version` instance.
 #param prereleases:
 #hether or not to match prereleases with this Specifier. If set to
 #`None`` (the default), it uses :attr:`prereleases` to determine
 #hether or not prereleases are allowed.

 #>> Specifier(">=1.2.3").contains("1.2.3")
 #rue
 #>> Specifier(">=1.2.3").contains(Version("1.2.3"))
 #rue
 #>> Specifier(">=1.2.3").contains("1.0.0")
 #alse
 #>> Specifier(">=1.2.3").contains("1.3.0a1")
 #alse
 #>> Specifier(">=1.2.3", prereleases=True).contains("1.3.0a1")
 #rue
 #>> Specifier(">=1.2.3").contains("1.3.0a1", prereleases=True)
 #rue
 #""

        # Determine if prereleases are to be allowed or not.
 #f prereleases is None:
 #rereleases = self.prereleases

        # Normalize item to a Version, this allows us to have a shortcut for
        # "2.0" in Specifier(">=2")
 #ormalized_item = _coerce_version(item)

        # Determine if we should be supporting prereleases in this specifier
        # or not, if we do not support prereleases than we can short circuit
        # logic if this version is a prereleases.
 #f normalized_item.is_prerelease and not prereleases:
 #eturn False

        # Actually do the comparison to determine if this item is contained
        # within this Specifier or not.
 #perator_callable: CallableOperator = self._get_operator(self.operator)
 #eturn operator_callable(normalized_item, self.version)

 #ef filter(
 #elf, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None
 # -> Iterator[UnparsedVersionVar]:
 #""Filter items in the given iterable, that match the specifier.

 #param iterable:
 #n iterable that can contain version strings and :class:`Version` instances.
 #he items in the iterable will be filtered according to the specifier.
 #param prereleases:
 #hether or not to allow prereleases in the returned iterator. If set to
 #`None`` (the default), it will be intelligently decide whether to allow
 #rereleases or not (based on the :attr:`prereleases` attribute, and
 #hether the only versions matching are prereleases).

 #his method is smarter than just ``filter(Specifier().contains, [...])``
 #ecause it implements the rule from :pep:`440` that a prerelease item
 #HOULD be accepted if no other versions match the given specifier.

 #>> list(Specifier(">=1.2.3").filter(["1.2", "1.3", "1.5a1"]))
 #'1.3']
 #>> list(Specifier(">=1.2.3").filter(["1.2", "1.2.3", "1.3", Version("1.4")]))
 #'1.2.3', '1.3', <Version('1.4')>]
 #>> list(Specifier(">=1.2.3").filter(["1.2", "1.5a1"]))
 #'1.5a1']
 #>> list(Specifier(">=1.2.3").filter(["1.3", "1.5a1"], prereleases=True))
 #'1.3', '1.5a1']
 #>> list(Specifier(">=1.2.3", prereleases=True).filter(["1.3", "1.5a1"]))
 #'1.3', '1.5a1']
 #""

 #ielded = False
 #ound_prereleases = []

 #w = {"prereleases": prereleases if prereleases is not None else True}

        # Attempt to iterate over all the values in the iterable and if any of
        # them match, yield them.
 #or version in iterable:
 #arsed_version = _coerce_version(version)

 #f self.contains(parsed_version, **kw):
                # If our version is a prerelease, and we were not set to allow
                # prereleases, then we'll store it for later in case nothing
                # else matches this specifier.
 #f parsed_version.is_prerelease and not (
 #rereleases or self.prereleases
 #:
 #ound_prereleases.append(version)
                # Either this is not a prerelease, or we should have been
                # accepting prereleases from the beginning.
 #lse:
 #ielded = True
 #ield version

        # Now that we've iterated over everything, determine if we've yielded
        # any values, and if we have not and we have any prereleases stored up
        # then we will go ahead and yield the prereleases.
 #f not yielded and found_prereleases:
 #or version in found_prereleases:
 #ield version


_prefix_regex = re.compile(r"^([0-9]+)((?:a|b|c|rc)[0-9]+)$")


def _version_split(version: str) -> list[str]:
 #""Split version into components.

 #he split components are intended for version comparison. The logic does
 #ot attempt to retain the original version string, so joining the
 #omponents back with :func:`_version_join` may not produce the original
 #ersion string.
 #""
 #esult: list[str] = []

 #poch, _, rest = version.rpartition("!")
 #esult.append(epoch or "0")

 #or item in rest.split("."):
 #atch = _prefix_regex.search(item)
 #f match:
 #esult.extend(match.groups())
 #lse:
 #esult.append(item)
 #eturn result


def _version_join(components: list[str]) -> str:
 #""Join split version components into a version string.

 #his function assumes the input came from :func:`_version_split`, where the
 #irst component must be the epoch (either empty or numeric), and all other
 #omponents numeric.
 #""
 #poch, *rest = components
 #eturn f"{epoch}!{'.'.join(rest)}"


def _is_not_suffix(segment: str) -> bool:
 #eturn not any(
 #egment.startswith(prefix) for prefix in ("dev", "a", "b", "rc", "post")
 #


def _pad_version(left: list[str], right: list[str]) -> tuple[list[str], list[str]]:
 #eft_split, right_split = [], []

    # Get the release segment of our versions
 #eft_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))
 #ight_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))

    # Get the rest of our versions
 #eft_split.append(left[len(left_split[0]) :])
 #ight_split.append(right[len(right_split[0]) :])

    # Insert our padding
 #eft_split.insert(1, ["0"] * max(0, len(right_split[0]) - len(left_split[0])))
 #ight_split.insert(1, ["0"] * max(0, len(left_split[0]) - len(right_split[0])))

 #eturn (
 #ist(itertools.chain.from_iterable(left_split)),
 #ist(itertools.chain.from_iterable(right_split)),
 #


class SpecifierSet(BaseSpecifier):
 #""This class abstracts handling of a set of version specifiers.

 #t can be passed a single specifier (``>=3.0``), a comma-separated list of
 #pecifiers (``>=3.0,!=3.1``), or no specifier at all.
 #""

 #ef __init__(
 #elf,
 #pecifiers: str | Iterable[Specifier] = "",
 #rereleases: bool | None = None,
 # -> None:
 #""Initialize a SpecifierSet instance.

 #param specifiers:
 #he string representation of a specifier or a comma-separated list of
 #pecifiers which will be parsed and normalized before use.
 #ay also be an iterable of ``Specifier`` instances, which will be used
 #s is.
 #param prereleases:
 #his tells the SpecifierSet if it should accept prerelease versions if
 #pplicable or not. The default of ``None`` will autodetect it from the
 #iven specifiers.

 #raises InvalidSpecifier:
 #f the given ``specifiers`` are not parseable than this exception will be
 #aised.
 #""

 #f isinstance(specifiers, str):
            # Split on `,` to break each individual specifier into its own item, and
            # strip each item to remove leading/trailing whitespace.
 #plit_specifiers = [s.strip() for s in specifiers.split(",") if s.strip()]

            # Make each individual specifier a Specifier and save in a frozen set
            # for later.
 #elf._specs = frozenset(map(Specifier, split_specifiers))
 #lse:
            # Save the supplied specifiers in a frozen set.
 #elf._specs = frozenset(specifiers)

        # Store our prereleases value so we can use it later to determine if
        # we accept prereleases or not.
 #elf._prereleases = prereleases

 #property
 #ef prereleases(self) -> bool | None:
        # If we have been given an explicit prerelease modifier, then we'll
        # pass that through here.
 #f self._prereleases is not None:
 #eturn self._prereleases

        # If we don't have any specifiers, and we don't have a forced value,
        # then we'll just return None since we don't know if this should have
        # pre-releases or not.
 #f not self._specs:
 #eturn None

        # Otherwise we'll see if any of the given specifiers accept
        # prereleases, if any of them do we'll return True, otherwise False.
 #eturn any(s.prereleases for s in self._specs)

 #prereleases.setter
 #ef prereleases(self, value: bool) -> None:
 #elf._prereleases = value

 #ef __repr__(self) -> str:
 #""A representation of the specifier set that shows all internal state.

 #ote that the ordering of the individual specifiers within the set may not
 #atch the input string.

 #>> SpecifierSet('>=1.0.0,!=2.0.0')
 #SpecifierSet('!=2.0.0,>=1.0.0')>
 #>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=False)
 #SpecifierSet('!=2.0.0,>=1.0.0', prereleases=False)>
 #>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=True)
 #SpecifierSet('!=2.0.0,>=1.0.0', prereleases=True)>
 #""
 #re = (
 #", prereleases={self.prereleases!r}"
 #f self._prereleases is not None
 #lse ""
 #

 #eturn f"<SpecifierSet({str(self)!r}{pre})>"

 #ef __str__(self) -> str:
 #""A string representation of the specifier set that can be round-tripped.

 #ote that the ordering of the individual specifiers within the set may not
 #atch the input string.

 #>> str(SpecifierSet(">=1.0.0,!=1.0.1"))
 #!=1.0.1,>=1.0.0'
 #>> str(SpecifierSet(">=1.0.0,!=1.0.1", prereleases=False))
 #!=1.0.1,>=1.0.0'
 #""
 #eturn ",".join(sorted(str(s) for s in self._specs))

 #ef __hash__(self) -> int:
 #eturn hash(self._specs)

 #ef __and__(self, other: SpecifierSet | str) -> SpecifierSet:
 #""Return a SpecifierSet which is a combination of the two sets.

 #param other: The other object to combine with.

 #>> SpecifierSet(">=1.0.0,!=1.0.1") & '<=2.0.0,!=2.0.1'
 #SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>
 #>> SpecifierSet(">=1.0.0,!=1.0.1") & SpecifierSet('<=2.0.0,!=2.0.1')
 #SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>
 #""
 #f isinstance(other, str):
 #ther = SpecifierSet(other)
 #lif not isinstance(other, SpecifierSet):
 #eturn NotImplemented

 #pecifier = SpecifierSet()
 #pecifier._specs = frozenset(self._specs | other._specs)

 #f self._prereleases is None and other._prereleases is not None:
 #pecifier._prereleases = other._prereleases
 #lif self._prereleases is not None and other._prereleases is None:
 #pecifier._prereleases = self._prereleases
 #lif self._prereleases == other._prereleases:
 #pecifier._prereleases = self._prereleases
 #lse:
 #aise ValueError(
 #Cannot combine SpecifierSets with True and False prerelease overrides."
 #

 #eturn specifier

 #ef __eq__(self, other: object) -> bool:
 #""Whether or not the two SpecifierSet-like objects are equal.

 #param other: The other object to check against.

 #he value of :attr:`prereleases` is ignored.

 #>> SpecifierSet(">=1.0.0,!=1.0.1") == SpecifierSet(">=1.0.0,!=1.0.1")
 #rue
 #>> (SpecifierSet(">=1.0.0,!=1.0.1", prereleases=False) ==
 #..  SpecifierSet(">=1.0.0,!=1.0.1", prereleases=True))
 #rue
 #>> SpecifierSet(">=1.0.0,!=1.0.1") == ">=1.0.0,!=1.0.1"
 #rue
 #>> SpecifierSet(">=1.0.0,!=1.0.1") == SpecifierSet(">=1.0.0")
 #alse
 #>> SpecifierSet(">=1.0.0,!=1.0.1") == SpecifierSet(">=1.0.0,!=1.0.2")
 #alse
 #""
 #f isinstance(other, (str, Specifier)):
 #ther = SpecifierSet(str(other))
 #lif not isinstance(other, SpecifierSet):
 #eturn NotImplemented

 #eturn self._specs == other._specs

 #ef __len__(self) -> int:
 #""Returns the number of specifiers in this specifier set."""
 #eturn len(self._specs)

 #ef __iter__(self) -> Iterator[Specifier]:
 #""
 #eturns an iterator over all the underlying :class:`Specifier` instances
 #n this specifier set.

 #>> sorted(SpecifierSet(">=1.0.0,!=1.0.1"), key=str)
 #<Specifier('!=1.0.1')>, <Specifier('>=1.0.0')>]
 #""
 #eturn iter(self._specs)

 #ef __contains__(self, item: UnparsedVersion) -> bool:
 #""Return whether or not the item is contained in this specifier.

 #param item: The item to check for.

 #his is used for the ``in`` operator and behaves the same as
 #meth:`contains` with no ``prereleases`` argument passed.

 #>> "1.2.3" in SpecifierSet(">=1.0.0,!=1.0.1")
 #rue
 #>> Version("1.2.3") in SpecifierSet(">=1.0.0,!=1.0.1")
 #rue
 #>> "1.0.1" in SpecifierSet(">=1.0.0,!=1.0.1")
 #alse
 #>> "1.3.0a1" in SpecifierSet(">=1.0.0,!=1.0.1")
 #alse
 #>> "1.3.0a1" in SpecifierSet(">=1.0.0,!=1.0.1", prereleases=True)
 #rue
 #""
 #eturn self.contains(item)

 #ef contains(
 #elf,
 #tem: UnparsedVersion,
 #rereleases: bool | None = None,
 #nstalled: bool | None = None,
 # -> bool:
 #""Return whether or not the item is contained in this SpecifierSet.

 #param item:
 #he item to check for, which can be a version string or a
 #class:`Version` instance.
 #param prereleases:
 #hether or not to match prereleases with this SpecifierSet. If set to
 #`None`` (the default), it uses :attr:`prereleases` to determine
 #hether or not prereleases are allowed.

 #>> SpecifierSet(">=1.0.0,!=1.0.1").contains("1.2.3")
 #rue
 #>> SpecifierSet(">=1.0.0,!=1.0.1").contains(Version("1.2.3"))
 #rue
 #>> SpecifierSet(">=1.0.0,!=1.0.1").contains("1.0.1")
 #alse
 #>> SpecifierSet(">=1.0.0,!=1.0.1").contains("1.3.0a1")
 #alse
 #>> SpecifierSet(">=1.0.0,!=1.0.1", prereleases=True).contains("1.3.0a1")
 #rue
 #>> SpecifierSet(">=1.0.0,!=1.0.1").contains("1.3.0a1", prereleases=True)
 #rue
 #""
        # Ensure that our item is a Version instance.
 #f not isinstance(item, Version):
 #tem = Version(item)

        # Determine if we're forcing a prerelease or not, if we're not forcing
        # one for this particular filter call, then we'll use whatever the
        # SpecifierSet thinks for whether or not we should support prereleases.
 #f prereleases is None:
 #rereleases = self.prereleases

        # We can determine if we're going to allow pre-releases by looking to
        # see if any of the underlying items supports them. If none of them do
        # and this item is a pre-release then we do not allow it and we can
        # short circuit that here.
        # Note: This means that 1.0.dev1 would not be contained in something
        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0
 #f not prereleases and item.is_prerelease:
 #eturn False

 #f installed and item.is_prerelease:
 #tem = Version(item.base_version)

        # We simply dispatch to the underlying specs here to make sure that the
        # given version is contained within all of them.
        # Note: This use of all() here means that an empty set of specifiers
        #       will always return True, this is an explicit design decision.
 #eturn all(s.contains(item, prereleases=prereleases) for s in self._specs)

 #ef filter(
 #elf, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None
 # -> Iterator[UnparsedVersionVar]:
 #""Filter items in the given iterable, that match the specifiers in this set.

 #param iterable:
 #n iterable that can contain version strings and :class:`Version` instances.
 #he items in the iterable will be filtered according to the specifier.
 #param prereleases:
 #hether or not to allow prereleases in the returned iterator. If set to
 #`None`` (the default), it will be intelligently decide whether to allow
 #rereleases or not (based on the :attr:`prereleases` attribute, and
 #hether the only versions matching are prereleases).

 #his method is smarter than just ``filter(SpecifierSet(...).contains, [...])``
 #ecause it implements the rule from :pep:`440` that a prerelease item
 #HOULD be accepted if no other versions match the given specifier.

 #>> list(SpecifierSet(">=1.2.3").filter(["1.2", "1.3", "1.5a1"]))
 #'1.3']
 #>> list(SpecifierSet(">=1.2.3").filter(["1.2", "1.3", Version("1.4")]))
 #'1.3', <Version('1.4')>]
 #>> list(SpecifierSet(">=1.2.3").filter(["1.2", "1.5a1"]))
 #]
 #>> list(SpecifierSet(">=1.2.3").filter(["1.3", "1.5a1"], prereleases=True))
 #'1.3', '1.5a1']
 #>> list(SpecifierSet(">=1.2.3", prereleases=True).filter(["1.3", "1.5a1"]))
 #'1.3', '1.5a1']

 #n "empty" SpecifierSet will filter items based on the presence of prerelease
 #ersions in the set.

 #>> list(SpecifierSet("").filter(["1.3", "1.5a1"]))
 #'1.3']
 #>> list(SpecifierSet("").filter(["1.5a1"]))
 #'1.5a1']
 #>> list(SpecifierSet("", prereleases=True).filter(["1.3", "1.5a1"]))
 #'1.3', '1.5a1']
 #>> list(SpecifierSet("").filter(["1.3", "1.5a1"], prereleases=True))
 #'1.3', '1.5a1']
 #""
        # Determine if we're forcing a prerelease or not, if we're not forcing
        # one for this particular filter call, then we'll use whatever the
        # SpecifierSet thinks for whether or not we should support prereleases.
 #f prereleases is None:
 #rereleases = self.prereleases

        # If we have any specifiers, then we want to wrap our iterable in the
        # filter method for each one, this will act as a logical AND amongst
        # each specifier.
 #f self._specs:
 #or spec in self._specs:
 #terable = spec.filter(iterable, prereleases=bool(prereleases))
 #eturn iter(iterable)
        # If we do not have any specifiers, then we need to have a rough filter
        # which will filter out any pre-releases, unless there are no final
        # releases.
 #lse:
 #iltered: list[UnparsedVersionVar] = []
 #ound_prereleases: list[UnparsedVersionVar] = []

 #or item in iterable:
 #arsed_version = _coerce_version(item)

                # Store any item which is a pre-release for later unless we've
                # already found a final version or we are accepting prereleases
 #f parsed_version.is_prerelease and not prereleases:
 #f not filtered:
 #ound_prereleases.append(item)
 #lse:
 #iltered.append(item)

            # If we've found no items except for pre-releases, then we'll go
            # ahead and use the pre-releases
 #f not filtered and found_prereleases and prereleases is None:
 #eturn iter(found_prereleases)

 #eturn iter(filtered)
