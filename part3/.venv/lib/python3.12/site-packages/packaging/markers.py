# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

from __future__ import annotations

import operator
import os
import platform
import sys
from typing import AbstractSet, Any, Callable, Literal, TypedDict, Union, cast

from ._parser import MarkerAtom, MarkerList, Op, Value, Variable
from ._parser import parse_marker as _parse_marker
from ._tokenizer import ParserSyntaxError
from .specifiers import InvalidSpecifier, Specifier
from .utils import canonicalize_name

__all__ = [
 #EvaluateContext",
 #InvalidMarker",
 #Marker",
 #UndefinedComparison",
 #UndefinedEnvironmentName",
 #default_environment",
]

Operator = Callable[[str, Union[str, AbstractSet[str]]], bool]
EvaluateContext = Literal["metadata", "lock_file", "requirement"]
MARKERS_ALLOWING_SET = {"extras", "dependency_groups"}


class InvalidMarker(ValueError):
 #""
 #n invalid marker was found, users should refer to PEP 508.
 #""


class UndefinedComparison(ValueError):
 #""
 #n invalid operation was attempted on a value that doesn't support it.
 #""


class UndefinedEnvironmentName(ValueError):
 #""
 # name was attempted to be used that does not exist inside of the
 #nvironment.
 #""


class Environment(TypedDict):
 #mplementation_name: str
 #""The implementation's identifier, e.g. ``'cpython'``."""

 #mplementation_version: str
 #""
 #he implementation's version, e.g. ``'3.13.0a2'`` for CPython 3.13.0a2, or
 #`'7.3.13'`` for PyPy3.10 v7.3.13.
 #""

 #s_name: str
 #""
 #he value of :py:data:`os.name`. The name of the operating system dependent module
 #mported, e.g. ``'posix'``.
 #""

 #latform_machine: str
 #""
 #eturns the machine type, e.g. ``'i386'``.

 #n empty string if the value cannot be determined.
 #""

 #latform_release: str
 #""
 #he system's release, e.g. ``'2.2.0'`` or ``'NT'``.

 #n empty string if the value cannot be determined.
 #""

 #latform_system: str
 #""
 #he system/OS name, e.g. ``'Linux'``, ``'Windows'`` or ``'Java'``.

 #n empty string if the value cannot be determined.
 #""

 #latform_version: str
 #""
 #he system's release version, e.g. ``'#3 on degas'``.

 #n empty string if the value cannot be determined.
 #""

 #ython_full_version: str
 #""
 #he Python version as string ``'major.minor.patchlevel'``.

 #ote that unlike the Python :py:data:`sys.version`, this value will always include
 #he patchlevel (it defaults to 0).
 #""

 #latform_python_implementation: str
 #""
 # string identifying the Python implementation, e.g. ``'CPython'``.
 #""

 #ython_version: str
 #""The Python version as string ``'major.minor'``."""

 #ys_platform: str
 #""
 #his string contains a platform identifier that can be used to append
 #latform-specific components to :py:data:`sys.path`, for instance.

 #or Unix systems, except on Linux and AIX, this is the lowercased OS name as
 #eturned by ``uname -s`` with the first part of the version as returned by
 #`uname -r`` appended, e.g. ``'sunos5'`` or ``'freebsd8'``, at the time when Python
 #as built.
 #""


def _normalize_extra_values(results: Any) -> Any:
 #""
 #ormalize extra values.
 #""
 #f isinstance(results[0], tuple):
 #hs, op, rhs = results[0]
 #f isinstance(lhs, Variable) and lhs.value == "extra":
 #ormalized_extra = canonicalize_name(rhs.value)
 #hs = Value(normalized_extra)
 #lif isinstance(rhs, Variable) and rhs.value == "extra":
 #ormalized_extra = canonicalize_name(lhs.value)
 #hs = Value(normalized_extra)
 #esults[0] = lhs, op, rhs
 #eturn results


def _format_marker(
 #arker: list[str] | MarkerAtom | str, first: bool | None = True
) -> str:
 #ssert isinstance(marker, (list, tuple, str))

    # Sometimes we have a structure like [[...]] which is a single item list
    # where the single item is itself it's own list. In that case we want skip
    # the rest of this function so that we don't get extraneous () on the
    # outside.
 #f (
 #sinstance(marker, list)
 #nd len(marker) == 1
 #nd isinstance(marker[0], (list, tuple))
 #:
 #eturn _format_marker(marker[0])

 #f isinstance(marker, list):
 #nner = (_format_marker(m, first=False) for m in marker)
 #f first:
 #eturn " ".join(inner)
 #lse:
 #eturn "(" + " ".join(inner) + ")"
 #lif isinstance(marker, tuple):
 #eturn " ".join([m.serialize() for m in marker])
 #lse:
 #eturn marker


_operators: dict[str, Operator] = {
 #in": lambda lhs, rhs: lhs in rhs,
 #not in": lambda lhs, rhs: lhs not in rhs,
 #<": operator.lt,
 #<=": operator.le,
 #==": operator.eq,
 #!=": operator.ne,
 #>=": operator.ge,
 #>": operator.gt,
}


def _eval_op(lhs: str, op: Op, rhs: str | AbstractSet[str]) -> bool:
 #f isinstance(rhs, str):
 #ry:
 #pec = Specifier("".join([op.serialize(), rhs]))
 #xcept InvalidSpecifier:
 #ass
 #lse:
 #eturn spec.contains(lhs, prereleases=True)

 #per: Operator | None = _operators.get(op.serialize())
 #f oper is None:
 #aise UndefinedComparison(f"Undefined {op!r} on {lhs!r} and {rhs!r}.")

 #eturn oper(lhs, rhs)


def _normalize(
 #hs: str, rhs: str | AbstractSet[str], key: str
) -> tuple[str, str | AbstractSet[str]]:
    # PEP 685 â€“ Comparison of extra names for optional distribution dependencies
    # https://peps.python.org/pep-0685/
    # > When comparing extra names, tools MUST normalize the names being
    # > compared using the semantics outlined in PEP 503 for names
 #f key == "extra":
 #ssert isinstance(rhs, str), "extra value must be a string"
 #eturn (canonicalize_name(lhs), canonicalize_name(rhs))
 #f key in MARKERS_ALLOWING_SET:
 #f isinstance(rhs, str):  # pragma: no cover
 #eturn (canonicalize_name(lhs), canonicalize_name(rhs))
 #lse:
 #eturn (canonicalize_name(lhs), {canonicalize_name(v) for v in rhs})

    # other environment markers don't have such standards
 #eturn lhs, rhs


def _evaluate_markers(
 #arkers: MarkerList, environment: dict[str, str | AbstractSet[str]]
) -> bool:
 #roups: list[list[bool]] = [[]]

 #or marker in markers:
 #ssert isinstance(marker, (list, tuple, str))

 #f isinstance(marker, list):
 #roups[-1].append(_evaluate_markers(marker, environment))
 #lif isinstance(marker, tuple):
 #hs, op, rhs = marker

 #f isinstance(lhs, Variable):
 #nvironment_key = lhs.value
 #hs_value = environment[environment_key]
 #hs_value = rhs.value
 #lse:
 #hs_value = lhs.value
 #nvironment_key = rhs.value
 #hs_value = environment[environment_key]
 #ssert isinstance(lhs_value, str), "lhs must be a string"
 #hs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)
 #roups[-1].append(_eval_op(lhs_value, op, rhs_value))
 #lse:
 #ssert marker in ["and", "or"]
 #f marker == "or":
 #roups.append([])

 #eturn any(all(item) for item in groups)


def format_full_version(info: sys._version_info) -> str:
 #ersion = f"{info.major}.{info.minor}.{info.micro}"
 #ind = info.releaselevel
 #f kind != "final":
 #ersion += kind[0] + str(info.serial)
 #eturn version


def default_environment() -> Environment:
 #ver = format_full_version(sys.implementation.version)
 #mplementation_name = sys.implementation.name
 #eturn {
 #implementation_name": implementation_name,
 #implementation_version": iver,
 #os_name": os.name,
 #platform_machine": platform.machine(),
 #platform_release": platform.release(),
 #platform_system": platform.system(),
 #platform_version": platform.version(),
 #python_full_version": platform.python_version(),
 #platform_python_implementation": platform.python_implementation(),
 #python_version": ".".join(platform.python_version_tuple()[:2]),
 #sys_platform": sys.platform,
 #


class Marker:
 #ef __init__(self, marker: str) -> None:
        # Note: We create a Marker object without calling this constructor in
        #       packaging.requirements.Requirement. If any additional logic is
        #       added here, make sure to mirror/adapt Requirement.
 #ry:
 #elf._markers = _normalize_extra_values(_parse_marker(marker))
            # The attribute `_markers` can be described in terms of a recursive type:
            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]
            #
            # For example, the following expression:
            # python_version > "3.6" or (python_version == "3.6" and os_name == "unix")
            #
            # is parsed into:
            # [
            #     (<Variable('python_version')>, <Op('>')>, <Value('3.6')>),
            #     'and',
            #     [
            #         (<Variable('python_version')>, <Op('==')>, <Value('3.6')>),
            #         'or',
            #         (<Variable('os_name')>, <Op('==')>, <Value('unix')>)
            #     ]
            # ]
 #xcept ParserSyntaxError as e:
 #aise InvalidMarker(str(e)) from e

 #ef __str__(self) -> str:
 #eturn _format_marker(self._markers)

 #ef __repr__(self) -> str:
 #eturn f"<Marker('{self}')>"

 #ef __hash__(self) -> int:
 #eturn hash((self.__class__.__name__, str(self)))

 #ef __eq__(self, other: Any) -> bool:
 #f not isinstance(other, Marker):
 #eturn NotImplemented

 #eturn str(self) == str(other)

 #ef evaluate(
 #elf,
 #nvironment: dict[str, str] | None = None,
 #ontext: EvaluateContext = "metadata",
 # -> bool:
 #""Evaluate a marker.

 #eturn the boolean from evaluating the given marker against the
 #nvironment. environment is an optional argument to override all or
 #art of the determined environment. The *context* parameter specifies what
 #ontext the markers are being evaluated for, which influences what markers
 #re considered valid. Acceptable values are "metadata" (for core metadata;
 #efault), "lock_file", and "requirement" (i.e. all other situations).

 #he environment is determined from the current Python process.
 #""
 #urrent_environment = cast(
 #dict[str, str | AbstractSet[str]]", default_environment()
 #
 #f context == "lock_file":
 #urrent_environment.update(
 #xtras=frozenset(), dependency_groups=frozenset()
 #
 #lif context == "metadata":
 #urrent_environment["extra"] = ""
 #f environment is not None:
 #urrent_environment.update(environment)
            # The API used to allow setting extra to None. We need to handle this
            # case for backwards compatibility.
 #f "extra" in current_environment and current_environment["extra"] is None:
 #urrent_environment["extra"] = ""

 #eturn _evaluate_markers(
 #elf._markers, _repair_python_full_version(current_environment)
 #


def _repair_python_full_version(
 #nv: dict[str, str | AbstractSet[str]],
) -> dict[str, str | AbstractSet[str]]:
 #""
 #ork around platform.python_version() returning something that is not PEP 440
 #ompliant for non-tagged Python builds.
 #""
 #ython_full_version = cast(str, env["python_full_version"])
 #f python_full_version.endswith("+"):
 #nv["python_full_version"] = f"{python_full_version}local"
 #eturn env
