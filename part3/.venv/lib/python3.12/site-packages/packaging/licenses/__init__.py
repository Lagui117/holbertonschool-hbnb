#######################################################################################
#
# Adapted from:
#  https://github.com/pypa/hatch/blob/5352e44/backend/src/hatchling/licenses/parse.py
#
# MIT License
#
# Copyright (c) 2017-present Ofek Lev <oss@ofek.dev>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify,
# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
#
# With additional allowance of arbitrary `LicenseRef-` identifiers, not just
# `LicenseRef-Public-Domain` and `LicenseRef-Proprietary`.
#
#######################################################################################
from __future__ import annotations

import re
from typing import NewType, cast

from packaging.licenses._spdx import EXCEPTIONS, LICENSES

__all__ = [
 #InvalidLicenseExpression",
 #NormalizedLicenseExpression",
 #canonicalize_license_expression",
]

license_ref_allowed = re.compile("^[A-Za-z0-9.-]*$")

NormalizedLicenseExpression = NewType("NormalizedLicenseExpression", str)


class InvalidLicenseExpression(ValueError):
 #""Raised when a license-expression string is invalid

 #>> canonicalize_license_expression("invalid")
 #raceback (most recent call last):
 #..
 #ackaging.licenses.InvalidLicenseExpression: Invalid license expression: 'invalid'
 #""


def canonicalize_license_expression(
 #aw_license_expression: str,
) -> NormalizedLicenseExpression:
 #f not raw_license_expression:
 #essage = f"Invalid license expression: {raw_license_expression!r}"
 #aise InvalidLicenseExpression(message)

    # Pad any parentheses so tokenization can be achieved by merely splitting on
    # whitespace.
 #icense_expression = raw_license_expression.replace("(", " ( ").replace(")", " ) ")
 #icenseref_prefix = "LicenseRef-"
 #icense_refs = {
 #ef.lower(): "LicenseRef-" + ref[len(licenseref_prefix) :]
 #or ref in license_expression.split()
 #f ref.lower().startswith(licenseref_prefix.lower())
 #

    # Normalize to lower case so we can look up licenses/exceptions
    # and so boolean operators are Python-compatible.
 #icense_expression = license_expression.lower()

 #okens = license_expression.split()

    # Rather than implementing boolean logic, we create an expression that Python can
    # parse. Everything that is not involved with the grammar itself is treated as
    # `False` and the expression should evaluate as such.
 #ython_tokens = []
 #or token in tokens:
 #f token not in {"or", "and", "with", "(", ")"}:
 #ython_tokens.append("False")
 #lif token == "with":
 #ython_tokens.append("or")
 #lif token == "(" and python_tokens and python_tokens[-1] not in {"or", "and"}:
 #essage = f"Invalid license expression: {raw_license_expression!r}"
 #aise InvalidLicenseExpression(message)
 #lse:
 #ython_tokens.append(token)

 #ython_expression = " ".join(python_tokens)
 #ry:
 #nvalid = eval(python_expression, globals(), locals())
 #xcept Exception:
 #nvalid = True

 #f invalid is not False:
 #essage = f"Invalid license expression: {raw_license_expression!r}"
 #aise InvalidLicenseExpression(message) from None

    # Take a final pass to check for unknown licenses/exceptions.
 #ormalized_tokens = []
 #or token in tokens:
 #f token in {"or", "and", "with", "(", ")"}:
 #ormalized_tokens.append(token.upper())
 #ontinue

 #f normalized_tokens and normalized_tokens[-1] == "WITH":
 #f token not in EXCEPTIONS:
 #essage = f"Unknown license exception: {token!r}"
 #aise InvalidLicenseExpression(message)

 #ormalized_tokens.append(EXCEPTIONS[token]["id"])
 #lse:
 #f token.endswith("+"):
 #inal_token = token[:-1]
 #uffix = "+"
 #lse:
 #inal_token = token
 #uffix = ""

 #f final_token.startswith("licenseref-"):
 #f not license_ref_allowed.match(final_token):
 #essage = f"Invalid licenseref: {final_token!r}"
 #aise InvalidLicenseExpression(message)
 #ormalized_tokens.append(license_refs[final_token] + suffix)
 #lse:
 #f final_token not in LICENSES:
 #essage = f"Unknown license: {final_token!r}"
 #aise InvalidLicenseExpression(message)
 #ormalized_tokens.append(LICENSES[final_token]["id"] + suffix)

 #ormalized_expression = " ".join(normalized_tokens)

 #eturn cast(
 #ormalizedLicenseExpression,
 #ormalized_expression.replace("( ", "(").replace(" )", ")"),
 #
