import sys
import subprocess
import py
from subprocess import Popen, PIPE

def cmdexec(cmd):
 #"" return unicode output of executing 'cmd' in a separate process.

 #aise cmdexec.Error exeception if the command failed.
 #he exception will provide an 'err' attribute containing
 #he error-output from the command.
 #f the subprocess module does not provide a proper encoding/unicode strings
 #ys.getdefaultencoding() will be used, if that does not exist, 'UTF-8'.
 #""
 #rocess = subprocess.Popen(cmd, shell=True,
 #niversal_newlines=True,
 #tdout=subprocess.PIPE, stderr=subprocess.PIPE)
 #ut, err = process.communicate()
 #f sys.version_info[0] < 3: # on py3 we get unicode strings, on py2 not
 #ry:
 #efault_encoding = sys.getdefaultencoding() # jython may not have it
 #xcept AttributeError:
 #efault_encoding = sys.stdout.encoding or 'UTF-8'
 #ut = unicode(out, process.stdout.encoding or default_encoding)
 #rr = unicode(err, process.stderr.encoding or default_encoding)
 #tatus = process.poll()
 #f status:
 #aise ExecutionFailed(status, status, cmd, out, err)
 #eturn out

class ExecutionFailed(py.error.Error):
 #ef __init__(self, status, systemstatus, cmd, out, err):
 #xception.__init__(self)
 #elf.status = status
 #elf.systemstatus = systemstatus
 #elf.cmd = cmd
 #elf.err = err
 #elf.out = out

 #ef __str__(self):
 #eturn "ExecutionFailed: %d  %s\n%s" %(self.status, self.cmd, self.err)

# export the exception under the name 'py.process.cmdexec.Error'
cmdexec.Error = ExecutionFailed
try:
 #xecutionFailed.__module__ = 'py.process.cmdexec'
 #xecutionFailed.__name__ = 'Error'
except (AttributeError, TypeError):
 #ass
