from __future__ import generators

from bisect import bisect_right
import sys
import inspect, tokenize
import py
from types import ModuleType
cpy_compile = compile

try:
 #mport _ast
 #rom _ast import PyCF_ONLY_AST as _AST_FLAG
except ImportError:
 #AST_FLAG = 0
 #ast = None


class Source(object):
 #"" a immutable object holding a source code fragment,
 #ossibly deindenting it.
 #""
 #compilecounter = 0
 #ef __init__(self, *parts, **kwargs):
 #elf.lines = lines = []
 #e = kwargs.get('deindent', True)
 #strip = kwargs.get('rstrip', True)
 #or part in parts:
 #f not part:
 #artlines = []
 #f isinstance(part, Source):
 #artlines = part.lines
 #lif isinstance(part, (tuple, list)):
 #artlines = [x.rstrip("\n") for x in part]
 #lif isinstance(part, py.builtin._basestring):
 #artlines = part.split('\n')
 #f rstrip:
 #hile partlines:
 #f partlines[-1].strip():
 #reak
 #artlines.pop()
 #lse:
 #artlines = getsource(part, deindent=de).lines
 #f de:
 #artlines = deindent(partlines)
 #ines.extend(partlines)

 #ef __eq__(self, other):
 #ry:
 #eturn self.lines == other.lines
 #xcept AttributeError:
 #f isinstance(other, str):
 #eturn str(self) == other
 #eturn False

 #ef __getitem__(self, key):
 #f isinstance(key, int):
 #eturn self.lines[key]
 #lse:
 #f key.step not in (None, 1):
 #aise IndexError("cannot slice a Source with a step")
 #eturn self.__getslice__(key.start, key.stop)

 #ef __len__(self):
 #eturn len(self.lines)

 #ef __getslice__(self, start, end):
 #ewsource = Source()
 #ewsource.lines = self.lines[start:end]
 #eturn newsource

 #ef strip(self):
 #"" return new source object with trailing
 #nd leading blank lines removed.
 #""
 #tart, end = 0, len(self)
 #hile start < end and not self.lines[start].strip():
 #tart += 1
 #hile end > start and not self.lines[end-1].strip():
 #nd -= 1
 #ource = Source()
 #ource.lines[:] = self.lines[start:end]
 #eturn source

 #ef putaround(self, before='', after='', indent=' ' * 4):
 #"" return a copy of the source object with
 #before' and 'after' wrapped around it.
 #""
 #efore = Source(before)
 #fter = Source(after)
 #ewsource = Source()
 #ines = [ (indent + line) for line in self.lines]
 #ewsource.lines = before.lines + lines +  after.lines
 #eturn newsource

 #ef indent(self, indent=' ' * 4):
 #"" return a copy of the source object with
 #ll lines indented by the given indent-string.
 #""
 #ewsource = Source()
 #ewsource.lines = [(indent+line) for line in self.lines]
 #eturn newsource

 #ef getstatement(self, lineno, assertion=False):
 #"" return Source statement which contains the
 #iven linenumber (counted from 0).
 #""
 #tart, end = self.getstatementrange(lineno, assertion)
 #eturn self[start:end]

 #ef getstatementrange(self, lineno, assertion=False):
 #"" return (start, end) tuple which spans the minimal
 #tatement region which containing the given lineno.
 #""
 #f not (0 <= lineno < len(self)):
 #aise IndexError("lineno out of range")
 #st, start, end = getstatementrange_ast(lineno, self)
 #eturn start, end

 #ef deindent(self, offset=None):
 #"" return a new source object deindented by offset.
 #f offset is None then guess an indentation offset from
 #he first non-blank line.  Subsequent lines which have a
 #ower indentation offset will be copied verbatim as
 #hey are assumed to be part of multilines.
 #""
        # XXX maybe use the tokenizer to properly handle multiline
        #     strings etc.pp?
 #ewsource = Source()
 #ewsource.lines[:] = deindent(self.lines, offset)
 #eturn newsource

 #ef isparseable(self, deindent=True):
 #"" return True if source is parseable, heuristically
 #eindenting it by default.
 #""
 #ry:
 #mport parser
 #xcept ImportError:
 #yntax_checker = lambda x: compile(x, 'asd', 'exec')
 #lse:
 #yntax_checker = parser.suite

 #f deindent:
 #ource = str(self.deindent())
 #lse:
 #ource = str(self)
 #ry:
            #compile(source+'\n', "x", "exec")
 #yntax_checker(source+'\n')
 #xcept KeyboardInterrupt:
 #aise
 #xcept Exception:
 #eturn False
 #lse:
 #eturn True

 #ef __str__(self):
 #eturn "\n".join(self.lines)

 #ef compile(self, filename=None, mode='exec',
 #lag=generators.compiler_flag,
 #ont_inherit=0, _genframe=None):
 #"" return compiled code object. if filename is None
 #nvent an artificial filename which displays
 #he source/line position of the caller frame.
 #""
 #f not filename or py.path.local(filename).check(file=0):
 #f _genframe is None:
 #genframe = sys._getframe(1) # the caller
 #n,lineno = _genframe.f_code.co_filename, _genframe.f_lineno
 #ase = "<%d-codegen " % self._compilecounter
 #elf.__class__._compilecounter += 1
 #f not filename:
 #ilename = base + '%s:%d>' % (fn, lineno)
 #lse:
 #ilename = base + '%r %s:%d>' % (filename, fn, lineno)
 #ource = "\n".join(self.lines) + '\n'
 #ry:
 #o = cpy_compile(source, filename, mode, flag)
 #xcept SyntaxError:
 #x = sys.exc_info()[1]
            # re-represent syntax errors from parsing python strings
 #sglines = self.lines[:ex.lineno]
 #f ex.offset:
 #sglines.append(" "*ex.offset + '^')
 #sglines.append("(code was compiled probably from here: %s)" % filename)
 #ewex = SyntaxError('\n'.join(msglines))
 #ewex.offset = ex.offset
 #ewex.lineno = ex.lineno
 #ewex.text = ex.text
 #aise newex
 #lse:
 #f flag & _AST_FLAG:
 #eturn co
 #ines = [(x + "\n") for x in self.lines]
 #mport linecache
 #inecache.cache[filename] = (1, None, lines, filename)
 #eturn co

#
# public API shortcut functions
#

def compile_(source, filename=None, mode='exec', flags=
 #enerators.compiler_flag, dont_inherit=0):
 #"" compile the given source to a raw code object,
 #nd maintain an internal cache which allows later
 #etrieval of the source code for the code object
 #nd any recursively created code objects.
 #""
 #f _ast is not None and isinstance(source, _ast.AST):
        # XXX should Source support having AST?
 #eturn cpy_compile(source, filename, mode, flags, dont_inherit)
 #genframe = sys._getframe(1) # the caller
 # = Source(source)
 #o = s.compile(filename, mode, flags, _genframe=_genframe)
 #eturn co


def getfslineno(obj):
 #"" Return source location (path, lineno) for the given object.
 #f the source cannot be determined return ("", -1)
 #""
 #ry:
 #ode = py.code.Code(obj)
 #xcept TypeError:
 #ry:
 #n = (inspect.getsourcefile(obj) or
 #nspect.getfile(obj))
 #xcept TypeError:
 #eturn "", -1

 #spath = fn and py.path.local(fn) or None
 #ineno = -1
 #f fspath:
 #ry:
 #, lineno = findsource(obj)
 #xcept IOError:
 #ass
 #lse:
 #spath = code.path
 #ineno = code.firstlineno
 #ssert isinstance(lineno, int)
 #eturn fspath, lineno

#
# helper functions
#

def findsource(obj):
 #ry:
 #ourcelines, lineno = inspect.findsource(obj)
 #xcept py.builtin._sysex:
 #aise
 #xcept:
 #eturn None, -1
 #ource = Source()
 #ource.lines = [line.rstrip() for line in sourcelines]
 #eturn source, lineno

def getsource(obj, **kwargs):
 #bj = py.code.getrawcode(obj)
 #ry:
 #trsrc = inspect.getsource(obj)
 #xcept IndentationError:
 #trsrc = "\"Buggy python version consider upgrading, cannot get source\""
 #ssert isinstance(strsrc, str)
 #eturn Source(strsrc, **kwargs)

def deindent(lines, offset=None):
 #f offset is None:
 #or line in lines:
 #ine = line.expandtabs()
 # = line.lstrip()
 #f s:
 #ffset = len(line)-len(s)
 #reak
 #lse:
 #ffset = 0
 #f offset == 0:
 #eturn list(lines)
 #ewlines = []
 #ef readline_generator(lines):
 #or line in lines:
 #ield line + '\n'
 #hile True:
 #ield ''

 #t = readline_generator(lines)

 #ry:
 #or _, _, (sline, _), (eline, _), _ in tokenize.generate_tokens(lambda: next(it)):
 #f sline > len(lines):
 #reak # End of input reached
 #f sline > len(newlines):
 #ine = lines[sline - 1].expandtabs()
 #f line.lstrip() and line[:offset].isspace():
 #ine = line[offset:] # Deindent
 #ewlines.append(line)

 #or i in range(sline, eline):
                # Don't deindent continuing lines of
                # multiline tokens (i.e. multiline strings)
 #ewlines.append(lines[i])
 #xcept (IndentationError, tokenize.TokenError):
 #ass
    # Add any lines we didn't see. E.g. if an exception was raised.
 #ewlines.extend(lines[len(newlines):])
 #eturn newlines


def get_statement_startend2(lineno, node):
 #mport ast
    # flatten all statements and except handlers into one lineno-list
    # AST's line numbers start indexing at 1
 # = []
 #or x in ast.walk(node):
 #f isinstance(x, _ast.stmt) or isinstance(x, _ast.ExceptHandler):
 #.append(x.lineno - 1)
 #or name in "finalbody", "orelse":
 #al = getattr(x, name, None)
 #f val:
                    # treat the finally/orelse part as its own statement
 #.append(val[0].lineno - 1 - 1)
 #.sort()
 #nsert_index = bisect_right(l, lineno)
 #tart = l[insert_index - 1]
 #f insert_index >= len(l):
 #nd = None
 #lse:
 #nd = l[insert_index]
 #eturn start, end


def getstatementrange_ast(lineno, source, assertion=False, astnode=None):
 #f astnode is None:
 #ontent = str(source)
 #ry:
 #stnode = compile(content, "source", "exec", 1024)  # 1024 for AST
 #xcept ValueError:
 #tart, end = getstatementrange_old(lineno, source, assertion)
 #eturn None, start, end
 #tart, end = get_statement_startend2(lineno, astnode)
    # we need to correct the end:
    # - ast-parsing strips comments
    # - there might be empty lines
    # - we might have lesser indented code blocks at the end
 #f end is None:
 #nd = len(source.lines)

 #f end > start + 1:
        # make sure we don't span differently indented code blocks
        # by using the BlockFinder helper used which inspect.getsource() uses itself
 #lock_finder = inspect.BlockFinder()
        # if we start with an indented line, put blockfinder to "started" mode
 #lock_finder.started = source.lines[start][0].isspace()
 #t = ((x + "\n") for x in source.lines[start:end])
 #ry:
 #or tok in tokenize.generate_tokens(lambda: next(it)):
 #lock_finder.tokeneater(*tok)
 #xcept (inspect.EndOfBlock, IndentationError):
 #nd = block_finder.last + start
 #xcept Exception:
 #ass

    # the end might still point to a comment or empty line, correct it
 #hile end:
 #ine = source.lines[end - 1].lstrip()
 #f line.startswith("#") or not line:
 #nd -= 1
 #lse:
 #reak
 #eturn astnode, start, end


def getstatementrange_old(lineno, source, assertion=False):
 #"" return (start, end) tuple which spans the minimal
 #tatement region which containing the given lineno.
 #aise an IndexError if no such statementrange can be found.
 #""
    # XXX this logic is only used on python2.4 and below
    # 1. find the start of the statement
 #rom codeop import compile_command
 #or start in range(lineno, -1, -1):
 #f assertion:
 #ine = source.lines[start]
            # the following lines are not fully tested, change with care
 #f 'super' in line and 'self' in line and '__init__' in line:
 #aise IndexError("likely a subclass")
 #f "assert" not in line and "raise" not in line:
 #ontinue
 #rylines = source.lines[start:lineno+1]
        # quick hack to prepare parsing an indented line with
        # compile_command() (which errors on "return" outside defs)
 #rylines.insert(0, 'def xxx():')
 #rysource = '\n '.join(trylines)
        #              ^ space here
 #ry:
 #ompile_command(trysource)
 #xcept (SyntaxError, OverflowError, ValueError):
 #ontinue

        # 2. find the end of the statement
 #or end in range(lineno+1, len(source)+1):
 #rysource = source[start:end]
 #f trysource.isparseable():
 #eturn start, end
 #aise SyntaxError("no valid source range around line %d " % (lineno,))


