import py
import sys, inspect
from compiler import parse, ast, pycodegen
from py._code.assertion import BuiltinAssertionError, _format_explanation
import types

passthroughex = py.builtin._sysex

class Failure:
 #ef __init__(self, node):
 #elf.exc, self.value, self.tb = sys.exc_info()
 #elf.node = node

class View(object):
 #""View base class.

 #f C is a subclass of View, then C(x) creates a proxy object around
 #he object x.  The actual class of the proxy is not C in general,
 #ut a *subclass* of C determined by the rules below.  To avoid confusion
 #e call view class the class of the proxy (a subclass of C, so of View)
 #nd object class the class of x.

 #ttributes and methods not found in the proxy are automatically read on x.
 #ther operations like setting attributes are performed on the proxy, as
 #etermined by its view class.  The object x is available from the proxy
 #s its __obj__ attribute.

 #he view class selection is determined by the __view__ tuples and the
 #ptional __viewkey__ method.  By default, the selected view class is the
 #ost specific subclass of C whose __view__ mentions the class of x.
 #f no such subclass is found, the search proceeds with the parent
 #bject classes.  For example, C(True) will first look for a subclass
 #f C with __view__ = (..., bool, ...) and only if it doesn't find any
 #ook for one with __view__ = (..., int, ...), and then ..., object,...
 #f everything fails the class C itself is considered to be the default.

 #lternatively, the view class selection can be driven by another aspect
 #f the object x, instead of the class of x, by overriding __viewkey__.
 #ee last example at the end of this module.
 #""

 #viewcache = {}
 #_view__ = ()

 #ef __new__(rootclass, obj, *args, **kwds):
 #elf = object.__new__(rootclass)
 #elf.__obj__ = obj
 #elf.__rootclass__ = rootclass
 #ey = self.__viewkey__()
 #ry:
 #elf.__class__ = self._viewcache[key]
 #xcept KeyError:
 #elf.__class__ = self._selectsubclass(key)
 #eturn self

 #ef __getattr__(self, attr):
        # attributes not found in the normal hierarchy rooted on View
        # are looked up in the object's real class
 #eturn getattr(self.__obj__, attr)

 #ef __viewkey__(self):
 #eturn self.__obj__.__class__

 #ef __matchkey__(self, key, subclasses):
 #f inspect.isclass(key):
 #eys = inspect.getmro(key)
 #lse:
 #eys = [key]
 #or key in keys:
 #esult = [C for C in subclasses if key in C.__view__]
 #f result:
 #eturn result
 #eturn []

 #ef _selectsubclass(self, key):
 #ubclasses = list(enumsubclasses(self.__rootclass__))
 #or C in subclasses:
 #f not isinstance(C.__view__, tuple):
 #.__view__ = (C.__view__,)
 #hoices = self.__matchkey__(key, subclasses)
 #f not choices:
 #eturn self.__rootclass__
 #lif len(choices) == 1:
 #eturn choices[0]
 #lse:
            # combine the multiple choices
 #eturn type('?', tuple(choices), {})

 #ef __repr__(self):
 #eturn '%s(%r)' % (self.__rootclass__.__name__, self.__obj__)


def enumsubclasses(cls):
 #or subcls in cls.__subclasses__():
 #or subsubclass in enumsubclasses(subcls):
 #ield subsubclass
 #ield cls


class Interpretable(View):
 #""A parse tree node with a few extra methods."""
 #xplanation = None

 #ef is_builtin(self, frame):
 #eturn False

 #ef eval(self, frame):
        # fall-back for unknown expression nodes
 #ry:
 #xpr = ast.Expression(self.__obj__)
 #xpr.filename = '<eval>'
 #elf.__obj__.filename = '<eval>'
 #o = pycodegen.ExpressionCodeGenerator(expr).getCode()
 #esult = frame.eval(co)
 #xcept passthroughex:
 #aise
 #xcept:
 #aise Failure(self)
 #elf.result = result
 #elf.explanation = self.explanation or frame.repr(self.result)

 #ef run(self, frame):
        # fall-back for unknown statement nodes
 #ry:
 #xpr = ast.Module(None, ast.Stmt([self.__obj__]))
 #xpr.filename = '<run>'
 #o = pycodegen.ModuleCodeGenerator(expr).getCode()
 #rame.exec_(co)
 #xcept passthroughex:
 #aise
 #xcept:
 #aise Failure(self)

 #ef nice_explanation(self):
 #eturn _format_explanation(self.explanation)


class Name(Interpretable):
 #_view__ = ast.Name

 #ef is_local(self, frame):
 #ource = '%r in locals() is not globals()' % self.name
 #ry:
 #eturn frame.is_true(frame.eval(source))
 #xcept passthroughex:
 #aise
 #xcept:
 #eturn False

 #ef is_global(self, frame):
 #ource = '%r in globals()' % self.name
 #ry:
 #eturn frame.is_true(frame.eval(source))
 #xcept passthroughex:
 #aise
 #xcept:
 #eturn False

 #ef is_builtin(self, frame):
 #ource = '%r not in locals() and %r not in globals()' % (
 #elf.name, self.name)
 #ry:
 #eturn frame.is_true(frame.eval(source))
 #xcept passthroughex:
 #aise
 #xcept:
 #eturn False

 #ef eval(self, frame):
 #uper(Name, self).eval(frame)
 #f not self.is_local(frame):
 #elf.explanation = self.name

class Compare(Interpretable):
 #_view__ = ast.Compare

 #ef eval(self, frame):
 #xpr = Interpretable(self.expr)
 #xpr.eval(frame)
 #or operation, expr2 in self.ops:
 #f hasattr(self, 'result'):
                # shortcutting in chained expressions
 #f not frame.is_true(self.result):
 #reak
 #xpr2 = Interpretable(expr2)
 #xpr2.eval(frame)
 #elf.explanation = "%s %s %s" % (
 #xpr.explanation, operation, expr2.explanation)
 #ource = "__exprinfo_left %s __exprinfo_right" % operation
 #ry:
 #elf.result = frame.eval(source,
 #_exprinfo_left=expr.result,
 #_exprinfo_right=expr2.result)
 #xcept passthroughex:
 #aise
 #xcept:
 #aise Failure(self)
 #xpr = expr2

class And(Interpretable):
 #_view__ = ast.And

 #ef eval(self, frame):
 #xplanations = []
 #or expr in self.nodes:
 #xpr = Interpretable(expr)
 #xpr.eval(frame)
 #xplanations.append(expr.explanation)
 #elf.result = expr.result
 #f not frame.is_true(expr.result):
 #reak
 #elf.explanation = '(' + ' and '.join(explanations) + ')'

class Or(Interpretable):
 #_view__ = ast.Or

 #ef eval(self, frame):
 #xplanations = []
 #or expr in self.nodes:
 #xpr = Interpretable(expr)
 #xpr.eval(frame)
 #xplanations.append(expr.explanation)
 #elf.result = expr.result
 #f frame.is_true(expr.result):
 #reak
 #elf.explanation = '(' + ' or '.join(explanations) + ')'


# == Unary operations ==
keepalive = []
for astclass, astpattern in {
 #st.Not    : 'not __exprinfo_expr',
 #st.Invert : '(~__exprinfo_expr)',
 #.items():

 #lass UnaryArith(Interpretable):
 #_view__ = astclass

 #ef eval(self, frame, astpattern=astpattern):
 #xpr = Interpretable(self.expr)
 #xpr.eval(frame)
 #elf.explanation = astpattern.replace('__exprinfo_expr',
 #xpr.explanation)
 #ry:
 #elf.result = frame.eval(astpattern,
 #_exprinfo_expr=expr.result)
 #xcept passthroughex:
 #aise
 #xcept:
 #aise Failure(self)

 #eepalive.append(UnaryArith)

# == Binary operations ==
for astclass, astpattern in {
 #st.Add    : '(__exprinfo_left + __exprinfo_right)',
 #st.Sub    : '(__exprinfo_left - __exprinfo_right)',
 #st.Mul    : '(__exprinfo_left * __exprinfo_right)',
 #st.Div    : '(__exprinfo_left / __exprinfo_right)',
 #st.Mod    : '(__exprinfo_left % __exprinfo_right)',
 #st.Power  : '(__exprinfo_left ** __exprinfo_right)',
 #.items():

 #lass BinaryArith(Interpretable):
 #_view__ = astclass

 #ef eval(self, frame, astpattern=astpattern):
 #eft = Interpretable(self.left)
 #eft.eval(frame)
 #ight = Interpretable(self.right)
 #ight.eval(frame)
 #elf.explanation = (astpattern
 #replace('__exprinfo_left',  left .explanation)
 #replace('__exprinfo_right', right.explanation))
 #ry:
 #elf.result = frame.eval(astpattern,
 #_exprinfo_left=left.result,
 #_exprinfo_right=right.result)
 #xcept passthroughex:
 #aise
 #xcept:
 #aise Failure(self)

 #eepalive.append(BinaryArith)


class CallFunc(Interpretable):
 #_view__ = ast.CallFunc

 #ef is_bool(self, frame):
 #ource = 'isinstance(__exprinfo_value, bool)'
 #ry:
 #eturn frame.is_true(frame.eval(source,
 #_exprinfo_value=self.result))
 #xcept passthroughex:
 #aise
 #xcept:
 #eturn False

 #ef eval(self, frame):
 #ode = Interpretable(self.node)
 #ode.eval(frame)
 #xplanations = []
 #ars = {'__exprinfo_fn': node.result}
 #ource = '__exprinfo_fn('
 #or a in self.args:
 #f isinstance(a, ast.Keyword):
 #eyword = a.name
 # = a.expr
 #lse:
 #eyword = None
 # = Interpretable(a)
 #.eval(frame)
 #rgname = '__exprinfo_%d' % len(vars)
 #ars[argname] = a.result
 #f keyword is None:
 #ource += argname + ','
 #xplanations.append(a.explanation)
 #lse:
 #ource += '%s=%s,' % (keyword, argname)
 #xplanations.append('%s=%s' % (keyword, a.explanation))
 #f self.star_args:
 #tar_args = Interpretable(self.star_args)
 #tar_args.eval(frame)
 #rgname = '__exprinfo_star'
 #ars[argname] = star_args.result
 #ource += '*' + argname + ','
 #xplanations.append('*' + star_args.explanation)
 #f self.dstar_args:
 #star_args = Interpretable(self.dstar_args)
 #star_args.eval(frame)
 #rgname = '__exprinfo_kwds'
 #ars[argname] = dstar_args.result
 #ource += '**' + argname + ','
 #xplanations.append('**' + dstar_args.explanation)
 #elf.explanation = "%s(%s)" % (
 #ode.explanation, ', '.join(explanations))
 #f source.endswith(','):
 #ource = source[:-1]
 #ource += ')'
 #ry:
 #elf.result = frame.eval(source, **vars)
 #xcept passthroughex:
 #aise
 #xcept:
 #aise Failure(self)
 #f not node.is_builtin(frame) or not self.is_bool(frame):
 # = frame.repr(self.result)
 #elf.explanation = '%s\n{%s = %s\n}' % (r, r, self.explanation)

class Getattr(Interpretable):
 #_view__ = ast.Getattr

 #ef eval(self, frame):
 #xpr = Interpretable(self.expr)
 #xpr.eval(frame)
 #ource = '__exprinfo_expr.%s' % self.attrname
 #ry:
 #elf.result = frame.eval(source, __exprinfo_expr=expr.result)
 #xcept passthroughex:
 #aise
 #xcept:
 #aise Failure(self)
 #elf.explanation = '%s.%s' % (expr.explanation, self.attrname)
        # if the attribute comes from the instance, its value is interesting
 #ource = ('hasattr(__exprinfo_expr, "__dict__") and '
 #%r in __exprinfo_expr.__dict__' % self.attrname)
 #ry:
 #rom_instance = frame.is_true(
 #rame.eval(source, __exprinfo_expr=expr.result))
 #xcept passthroughex:
 #aise
 #xcept:
 #rom_instance = True
 #f from_instance:
 # = frame.repr(self.result)
 #elf.explanation = '%s\n{%s = %s\n}' % (r, r, self.explanation)

# == Re-interpretation of full statements ==

class Assert(Interpretable):
 #_view__ = ast.Assert

 #ef run(self, frame):
 #est = Interpretable(self.test)
 #est.eval(frame)
        # simplify 'assert False where False = ...'
 #f (test.explanation.startswith('False\n{False = ') and
 #est.explanation.endswith('\n}')):
 #est.explanation = test.explanation[15:-2]
        # print the result as  'assert <explanation>'
 #elf.result = test.result
 #elf.explanation = 'assert ' + test.explanation
 #f not frame.is_true(test.result):
 #ry:
 #aise BuiltinAssertionError
 #xcept passthroughex:
 #aise
 #xcept:
 #aise Failure(self)

class Assign(Interpretable):
 #_view__ = ast.Assign

 #ef run(self, frame):
 #xpr = Interpretable(self.expr)
 #xpr.eval(frame)
 #elf.result = expr.result
 #elf.explanation = '... = ' + expr.explanation
        # fall-back-run the rest of the assignment
 #ss = ast.Assign(self.nodes, ast.Name('__exprinfo_expr'))
 #od = ast.Module(None, ast.Stmt([ass]))
 #od.filename = '<run>'
 #o = pycodegen.ModuleCodeGenerator(mod).getCode()
 #ry:
 #rame.exec_(co, __exprinfo_expr=expr.result)
 #xcept passthroughex:
 #aise
 #xcept:
 #aise Failure(self)

class Discard(Interpretable):
 #_view__ = ast.Discard

 #ef run(self, frame):
 #xpr = Interpretable(self.expr)
 #xpr.eval(frame)
 #elf.result = expr.result
 #elf.explanation = expr.explanation

class Stmt(Interpretable):
 #_view__ = ast.Stmt

 #ef run(self, frame):
 #or stmt in self.nodes:
 #tmt = Interpretable(stmt)
 #tmt.run(frame)


def report_failure(e):
 #xplanation = e.node.nice_explanation()
 #f explanation:
 #xplanation = ", in: " + explanation
 #lse:
 #xplanation = ""
 #ys.stdout.write("%s: %s%s\n" % (e.exc.__name__, e.value, explanation))

def check(s, frame=None):
 #f frame is None:
 #rame = sys._getframe(1)
 #rame = py.code.Frame(frame)
 #xpr = parse(s, 'eval')
 #ssert isinstance(expr, ast.Expression)
 #ode = Interpretable(expr.node)
 #ry:
 #ode.eval(frame)
 #xcept passthroughex:
 #aise
 #xcept Failure:
 # = sys.exc_info()[1]
 #eport_failure(e)
 #lse:
 #f not frame.is_true(node.result):
 #ys.stderr.write("assertion failed: %s\n" % node.nice_explanation())


###########################################################
# API / Entry points
# #########################################################

def interpret(source, frame, should_fail=False):
 #odule = Interpretable(parse(source, 'exec').node)
    #print "got module", module
 #f isinstance(frame, types.FrameType):
 #rame = py.code.Frame(frame)
 #ry:
 #odule.run(frame)
 #xcept Failure:
 # = sys.exc_info()[1]
 #eturn getfailure(e)
 #xcept passthroughex:
 #aise
 #xcept:
 #mport traceback
 #raceback.print_exc()
 #f should_fail:
 #eturn ("(assertion failed, but when it was re-run for "
 #printing intermediate values, it did not fail.  Suggestions: "
 #compute assert expression before the assert or use --nomagic)")
 #lse:
 #eturn None

def getmsg(excinfo):
 #f isinstance(excinfo, tuple):
 #xcinfo = py.code.ExceptionInfo(excinfo)
    #frame, line = gettbline(tb)
    #frame = py.code.Frame(frame)
    #return interpret(line, frame)

 #b = excinfo.traceback[-1]
 #ource = str(tb.statement).strip()
 # = interpret(source, tb.frame, should_fail=True)
 #f not isinstance(x, str):
 #aise TypeError("interpret returned non-string %r" % (x,))
 #eturn x

def getfailure(e):
 #xplanation = e.node.nice_explanation()
 #f str(e.value):
 #ines = explanation.split('\n')
 #ines[0] += "  << %s" % (e.value,)
 #xplanation = '\n'.join(lines)
 #ext = "%s: %s" % (e.exc.__name__, explanation)
 #f text.startswith('AssertionError: assert '):
 #ext = text[16:]
 #eturn text

def run(s, frame=None):
 #f frame is None:
 #rame = sys._getframe(1)
 #rame = py.code.Frame(frame)
 #odule = Interpretable(parse(s, 'exec').node)
 #ry:
 #odule.run(frame)
 #xcept Failure:
 # = sys.exc_info()[1]
 #eport_failure(e)


if __name__ == '__main__':
    # example:
 #ef f():
 #eturn 5
 #ef g():
 #eturn 3
 #ef h(x):
 #eturn 'never'
 #heck("f() * g() == 5")
 #heck("not f()")
 #heck("not (f() and g() or 0)")
 #heck("f() == g()")
 # = 4
 #heck("i == f()")
 #heck("len(f()) == 0")
 #heck("isinstance(2+3+4, float)")

 #un("x = i")
 #heck("x == 5")

 #un("assert not f(), 'oops'")
 #un("a, b, c = 1, 2")
 #un("a, b, c = f()")

 #heck("max([f(),g()]) == 4")
 #heck("'hello'[g()] == 'h'")
 #un("'guk%d' % h(f())")
