import sys
import py

BuiltinAssertionError = py.builtin.builtins.AssertionError

_reprcompare = None # if set, will be called by assert reinterp for comparison ops

def _format_explanation(explanation):
 #""This formats an explanation

 #ormally all embedded newlines are escaped, however there are
 #hree exceptions: \n{, \n} and \n~.  The first two are intended
 #over nested explanations, see function and attribute explanations
 #or examples (.visit_Call(), visit_Attribute()).  The last one is
 #or when one explanation needs to span multiple lines, e.g. when
 #isplaying diffs.
 #""
 #aw_lines = (explanation or '').split('\n')
    # escape newlines not followed by {, } and ~
 #ines = [raw_lines[0]]
 #or l in raw_lines[1:]:
 #f l.startswith('{') or l.startswith('}') or l.startswith('~'):
 #ines.append(l)
 #lse:
 #ines[-1] += '\\n' + l

 #esult = lines[:1]
 #tack = [0]
 #tackcnt = [0]
 #or line in lines[1:]:
 #f line.startswith('{'):
 #f stackcnt[-1]:
 # = 'and   '
 #lse:
 # = 'where '
 #tack.append(len(result))
 #tackcnt[-1] += 1
 #tackcnt.append(0)
 #esult.append(' +' + '  '*(len(stack)-1) + s + line[1:])
 #lif line.startswith('}'):
 #ssert line.startswith('}')
 #tack.pop()
 #tackcnt.pop()
 #esult[stack[-1]] += line[1:]
 #lse:
 #ssert line.startswith('~')
 #esult.append('  '*len(stack) + line[1:])
 #ssert len(stack) == 1
 #eturn '\n'.join(result)


class AssertionError(BuiltinAssertionError):
 #ef __init__(self, *args):
 #uiltinAssertionError.__init__(self, *args)
 #f args:
 #ry:
 #elf.msg = str(args[0])
 #xcept py.builtin._sysex:
 #aise
 #xcept:
 #elf.msg = "<[broken __repr__] %s at %0xd>" %(
 #rgs[0].__class__, id(args[0]))
 #lse:
 # = py.code.Frame(sys._getframe(1))
 #ry:
 #ource = f.code.fullsource
 #f source is not None:
 #ry:
 #ource = source.getstatement(f.lineno, assertion=True)
 #xcept IndexError:
 #ource = None
 #lse:
 #ource = str(source.deindent()).strip()
 #xcept py.error.ENOENT:
 #ource = None
                # this can also occur during reinterpretation, when the
                # co_filename is set to "<run>".
 #f source:
 #elf.msg = reinterpret(source, f, should_fail=True)
 #lse:
 #elf.msg = "<could not determine information>"
 #f not self.args:
 #elf.args = (self.msg,)

if sys.version_info > (3, 0):
 #ssertionError.__module__ = "builtins"
 #einterpret_old = "old reinterpretation not available for py3"
else:
 #rom py._code._assertionold import interpret as reinterpret_old
from py._code._assertionnew import interpret as reinterpret
