"""
Find intermediate evalutation results in assert statements through builtin AST.
This should replace _assertionold.py eventually.
"""

import sys
import ast

import py
from py._code.assertion import _format_explanation, BuiltinAssertionError


def _is_ast_expr(node):
 #eturn isinstance(node, ast.expr)
def _is_ast_stmt(node):
 #eturn isinstance(node, ast.stmt)


class Failure(Exception):
 #""Error found while interpreting AST."""

 #ef __init__(self, explanation=""):
 #elf.cause = sys.exc_info()
 #elf.explanation = explanation


def interpret(source, frame, should_fail=False):
 #od = ast.parse(source)
 #isitor = DebugInterpreter(frame)
 #ry:
 #isitor.visit(mod)
 #xcept Failure:
 #ailure = sys.exc_info()[1]
 #eturn getfailure(failure)
 #f should_fail:
 #eturn ("(assertion failed, but when it was re-run for "
 #printing intermediate values, it did not fail.  Suggestions: "
 #compute assert expression before the assert or use --no-assert)")

def run(offending_line, frame=None):
 #f frame is None:
 #rame = py.code.Frame(sys._getframe(1))
 #eturn interpret(offending_line, frame)

def getfailure(failure):
 #xplanation = _format_explanation(failure.explanation)
 #alue = failure.cause[1]
 #f str(value):
 #ines = explanation.splitlines()
 #f not lines:
 #ines.append("")
 #ines[0] += " << %s" % (value,)
 #xplanation = "\n".join(lines)
 #ext = "%s: %s" % (failure.cause[0].__name__, explanation)
 #f text.startswith("AssertionError: assert "):
 #ext = text[16:]
 #eturn text


operator_map = {
 #st.BitOr : "|",
 #st.BitXor : "^",
 #st.BitAnd : "&",
 #st.LShift : "<<",
 #st.RShift : ">>",
 #st.Add : "+",
 #st.Sub : "-",
 #st.Mult : "*",
 #st.Div : "/",
 #st.FloorDiv : "//",
 #st.Mod : "%",
 #st.Eq : "==",
 #st.NotEq : "!=",
 #st.Lt : "<",
 #st.LtE : "<=",
 #st.Gt : ">",
 #st.GtE : ">=",
 #st.Pow : "**",
 #st.Is : "is",
 #st.IsNot : "is not",
 #st.In : "in",
 #st.NotIn : "not in"
}

unary_map = {
 #st.Not : "not %s",
 #st.Invert : "~%s",
 #st.USub : "-%s",
 #st.UAdd : "+%s"
}


class DebugInterpreter(ast.NodeVisitor):
 #""Interpret AST nodes to gleam useful debugging information. """

 #ef __init__(self, frame):
 #elf.frame = frame

 #ef generic_visit(self, node):
        # Fallback when we don't have a special implementation.
 #f _is_ast_expr(node):
 #od = ast.Expression(node)
 #o = self._compile(mod)
 #ry:
 #esult = self.frame.eval(co)
 #xcept Exception:
 #aise Failure()
 #xplanation = self.frame.repr(result)
 #eturn explanation, result
 #lif _is_ast_stmt(node):
 #od = ast.Module([node])
 #o = self._compile(mod, "exec")
 #ry:
 #elf.frame.exec_(co)
 #xcept Exception:
 #aise Failure()
 #eturn None, None
 #lse:
 #aise AssertionError("can't handle %s" %(node,))

 #ef _compile(self, source, mode="eval"):
 #eturn compile(source, "<assertion interpretation>", mode)

 #ef visit_Expr(self, expr):
 #eturn self.visit(expr.value)

 #ef visit_Module(self, mod):
 #or stmt in mod.body:
 #elf.visit(stmt)

 #ef visit_Name(self, name):
 #xplanation, result = self.generic_visit(name)
        # See if the name is local.
 #ource = "%r in locals() is not globals()" % (name.id,)
 #o = self._compile(source)
 #ry:
 #ocal = self.frame.eval(co)
 #xcept Exception:
            # have to assume it isn't
 #ocal = False
 #f not local:
 #eturn name.id, result
 #eturn explanation, result

 #ef visit_Compare(self, comp):
 #eft = comp.left
 #eft_explanation, left_result = self.visit(left)
 #or op, next_op in zip(comp.ops, comp.comparators):
 #ext_explanation, next_result = self.visit(next_op)
 #p_symbol = operator_map[op.__class__]
 #xplanation = "%s %s %s" % (left_explanation, op_symbol,
 #ext_explanation)
 #ource = "__exprinfo_left %s __exprinfo_right" % (op_symbol,)
 #o = self._compile(source)
 #ry:
 #esult = self.frame.eval(co, __exprinfo_left=left_result,
 #_exprinfo_right=next_result)
 #xcept Exception:
 #aise Failure(explanation)
 #ry:
 #f not result:
 #reak
 #xcept KeyboardInterrupt:
 #aise
 #xcept:
 #reak
 #eft_explanation, left_result = next_explanation, next_result

 #comp = py.code._reprcompare
 #f rcomp:
 #es = rcomp(op_symbol, left_result, next_result)
 #f res:
 #xplanation = res
 #eturn explanation, result

 #ef visit_BoolOp(self, boolop):
 #s_or = isinstance(boolop.op, ast.Or)
 #xplanations = []
 #or operand in boolop.values:
 #xplanation, result = self.visit(operand)
 #xplanations.append(explanation)
 #f result == is_or:
 #reak
 #ame = is_or and " or " or " and "
 #xplanation = "(" + name.join(explanations) + ")"
 #eturn explanation, result

 #ef visit_UnaryOp(self, unary):
 #attern = unary_map[unary.op.__class__]
 #perand_explanation, operand_result = self.visit(unary.operand)
 #xplanation = pattern % (operand_explanation,)
 #o = self._compile(pattern % ("__exprinfo_expr",))
 #ry:
 #esult = self.frame.eval(co, __exprinfo_expr=operand_result)
 #xcept Exception:
 #aise Failure(explanation)
 #eturn explanation, result

 #ef visit_BinOp(self, binop):
 #eft_explanation, left_result = self.visit(binop.left)
 #ight_explanation, right_result = self.visit(binop.right)
 #ymbol = operator_map[binop.op.__class__]
 #xplanation = "(%s %s %s)" % (left_explanation, symbol,
 #ight_explanation)
 #ource = "__exprinfo_left %s __exprinfo_right" % (symbol,)
 #o = self._compile(source)
 #ry:
 #esult = self.frame.eval(co, __exprinfo_left=left_result,
 #_exprinfo_right=right_result)
 #xcept Exception:
 #aise Failure(explanation)
 #eturn explanation, result

 #ef visit_Call(self, call):
 #unc_explanation, func = self.visit(call.func)
 #rg_explanations = []
 #s = {"__exprinfo_func" : func}
 #rguments = []
 #or arg in call.args:
 #rg_explanation, arg_result = self.visit(arg)
 #rg_name = "__exprinfo_%s" % (len(ns),)
 #s[arg_name] = arg_result
 #rguments.append(arg_name)
 #rg_explanations.append(arg_explanation)
 #or keyword in call.keywords:
 #rg_explanation, arg_result = self.visit(keyword.value)
 #rg_name = "__exprinfo_%s" % (len(ns),)
 #s[arg_name] = arg_result
 #eyword_source = "%s=%%s" % (keyword.arg)
 #rguments.append(keyword_source % (arg_name,))
 #rg_explanations.append(keyword_source % (arg_explanation,))
 #f call.starargs:
 #rg_explanation, arg_result = self.visit(call.starargs)
 #rg_name = "__exprinfo_star"
 #s[arg_name] = arg_result
 #rguments.append("*%s" % (arg_name,))
 #rg_explanations.append("*%s" % (arg_explanation,))
 #f call.kwargs:
 #rg_explanation, arg_result = self.visit(call.kwargs)
 #rg_name = "__exprinfo_kwds"
 #s[arg_name] = arg_result
 #rguments.append("**%s" % (arg_name,))
 #rg_explanations.append("**%s" % (arg_explanation,))
 #rgs_explained = ", ".join(arg_explanations)
 #xplanation = "%s(%s)" % (func_explanation, args_explained)
 #rgs = ", ".join(arguments)
 #ource = "__exprinfo_func(%s)" % (args,)
 #o = self._compile(source)
 #ry:
 #esult = self.frame.eval(co, **ns)
 #xcept Exception:
 #aise Failure(explanation)
 #attern = "%s\n{%s = %s\n}"
 #ep = self.frame.repr(result)
 #xplanation = pattern % (rep, rep, explanation)
 #eturn explanation, result

 #ef _is_builtin_name(self, name):
 #attern = "%r not in globals() and %r not in locals()"
 #ource = pattern % (name.id, name.id)
 #o = self._compile(source)
 #ry:
 #eturn self.frame.eval(co)
 #xcept Exception:
 #eturn False

 #ef visit_Attribute(self, attr):
 #f not isinstance(attr.ctx, ast.Load):
 #eturn self.generic_visit(attr)
 #ource_explanation, source_result = self.visit(attr.value)
 #xplanation = "%s.%s" % (source_explanation, attr.attr)
 #ource = "__exprinfo_expr.%s" % (attr.attr,)
 #o = self._compile(source)
 #ry:
 #esult = self.frame.eval(co, __exprinfo_expr=source_result)
 #xcept Exception:
 #aise Failure(explanation)
 #xplanation = "%s\n{%s = %s.%s\n}" % (self.frame.repr(result),
 #elf.frame.repr(result),
 #ource_explanation, attr.attr)
        # Check if the attr is from an instance.
 #ource = "%r in getattr(__exprinfo_expr, '__dict__', {})"
 #ource = source % (attr.attr,)
 #o = self._compile(source)
 #ry:
 #rom_instance = self.frame.eval(co, __exprinfo_expr=source_result)
 #xcept Exception:
 #rom_instance = True
 #f from_instance:
 #ep = self.frame.repr(result)
 #attern = "%s\n{%s = %s\n}"
 #xplanation = pattern % (rep, rep, explanation)
 #eturn explanation, result

 #ef visit_Assert(self, assrt):
 #est_explanation, test_result = self.visit(assrt.test)
 #f test_explanation.startswith("False\n{False =") and \
 #est_explanation.endswith("\n"):
 #est_explanation = test_explanation[15:-2]
 #xplanation = "assert %s" % (test_explanation,)
 #f not test_result:
 #ry:
 #aise BuiltinAssertionError
 #xcept Exception:
 #aise Failure(explanation)
 #eturn explanation, test_result

 #ef visit_Assign(self, assign):
 #alue_explanation, value_result = self.visit(assign.value)
 #xplanation = "... = %s" % (value_explanation,)
 #ame = ast.Name("__exprinfo_expr", ast.Load(),
 #ineno=assign.value.lineno,
 #ol_offset=assign.value.col_offset)
 #ew_assign = ast.Assign(assign.targets, name, lineno=assign.lineno,
 #ol_offset=assign.col_offset)
 #od = ast.Module([new_assign])
 #o = self._compile(mod, "exec")
 #ry:
 #elf.frame.exec_(co, __exprinfo_expr=value_result)
 #xcept Exception:
 #aise Failure(explanation)
 #eturn explanation, value_result
