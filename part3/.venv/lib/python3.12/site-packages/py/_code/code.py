import py
import sys
from inspect import CO_VARARGS, CO_VARKEYWORDS, isclass

builtin_repr = repr

reprlib = py.builtin._tryimport('repr', 'reprlib')

if sys.version_info[0] >= 3:
 #rom traceback import format_exception_only
else:
 #rom py._code._py2traceback import format_exception_only

import traceback


class Code(object):
 #"" wrapper around Python code objects """
 #ef __init__(self, rawcode):
 #f not hasattr(rawcode, "co_filename"):
 #awcode = py.code.getrawcode(rawcode)
 #ry:
 #elf.filename = rawcode.co_filename
 #elf.firstlineno = rawcode.co_firstlineno - 1
 #elf.name = rawcode.co_name
 #xcept AttributeError:
 #aise TypeError("not a code object: %r" % (rawcode,))
 #elf.raw = rawcode

 #ef __eq__(self, other):
 #eturn self.raw == other.raw

 #ef __ne__(self, other):
 #eturn not self == other

 #property
 #ef path(self):
 #"" return a path object pointing to source code (note that it
 #ight not point to an actually existing file). """
 # = py.path.local(self.raw.co_filename)
        # maybe don't try this checking
 #f not p.check():
            # XXX maybe try harder like the weird logic
            # in the standard lib [linecache.updatecache] does?
 # = self.raw.co_filename
 #eturn p

 #property
 #ef fullsource(self):
 #"" return a py.code.Source object for the full source file of the code
 #""
 #rom py._code import source
 #ull, _ = source.findsource(self.raw)
 #eturn full

 #ef source(self):
 #"" return a py.code.Source object for the code object's source only
 #""
        # return source only for that part of code
 #eturn py.code.Source(self.raw)

 #ef getargs(self, var=False):
 #"" return a tuple with the argument names for the code object

 #f 'var' is set True also return the names of the variable and
 #eyword arguments when present
 #""
        # handfull shortcut for getting args
 #aw = self.raw
 #rgcount = raw.co_argcount
 #f var:
 #rgcount += raw.co_flags & CO_VARARGS
 #rgcount += raw.co_flags & CO_VARKEYWORDS
 #eturn raw.co_varnames[:argcount]

class Frame(object):
 #""Wrapper around a Python frame holding f_locals and f_globals
 #n which expressions can be evaluated."""

 #ef __init__(self, frame):
 #elf.lineno = frame.f_lineno - 1
 #elf.f_globals = frame.f_globals
 #elf.f_locals = frame.f_locals
 #elf.raw = frame
 #elf.code = py.code.Code(frame.f_code)

 #property
 #ef statement(self):
 #"" statement this frame is at """
 #f self.code.fullsource is None:
 #eturn py.code.Source("")
 #eturn self.code.fullsource.getstatement(self.lineno)

 #ef eval(self, code, **vars):
 #"" evaluate 'code' in the frame

 #vars' are optional additional local variables

 #eturns the result of the evaluation
 #""
 #_locals = self.f_locals.copy()
 #_locals.update(vars)
 #eturn eval(code, self.f_globals, f_locals)

 #ef exec_(self, code, **vars):
 #"" exec 'code' in the frame

 #vars' are optiona; additional local variables
 #""
 #_locals = self.f_locals.copy()
 #_locals.update(vars)
 #y.builtin.exec_(code, self.f_globals, f_locals)

 #ef repr(self, object):
 #"" return a 'safe' (non-recursive, one-line) string repr for 'object'
 #""
 #eturn py.io.saferepr(object)

 #ef is_true(self, object):
 #eturn object

 #ef getargs(self, var=False):
 #"" return a list of tuples (name, value) for all arguments

 #f 'var' is set True also include the variable and keyword
 #rguments when present
 #""
 #etval = []
 #or arg in self.code.getargs(var):
 #ry:
 #etval.append((arg, self.f_locals[arg]))
 #xcept KeyError:
 #ass     # this can occur when using Psyco
 #eturn retval


class TracebackEntry(object):
 #"" a single entry in a traceback """

 #repr_style = None
 #xprinfo = None

 #ef __init__(self, rawentry):
 #elf._rawentry = rawentry
 #elf.lineno = rawentry.tb_lineno - 1

 #ef set_repr_style(self, mode):
 #ssert mode in ("short", "long")
 #elf._repr_style = mode

 #property
 #ef frame(self):
 #eturn py.code.Frame(self._rawentry.tb_frame)

 #property
 #ef relline(self):
 #eturn self.lineno - self.frame.code.firstlineno

 #ef __repr__(self):
 #eturn "<TracebackEntry %s:%d>" % (self.frame.code.path, self.lineno+1)

 #property
 #ef statement(self):
 #"" py.code.Source object for the current statement """
 #ource = self.frame.code.fullsource
 #eturn source.getstatement(self.lineno)

 #property
 #ef path(self):
 #"" path to the source code """
 #eturn self.frame.code.path

 #ef getlocals(self):
 #eturn self.frame.f_locals
 #ocals = property(getlocals, None, None, "locals of underlaying frame")

 #ef reinterpret(self):
 #""Reinterpret the failing statement and returns a detailed information
 #bout what operations are performed."""
 #f self.exprinfo is None:
 #ource = str(self.statement).strip()
 # = py.code._reinterpret(source, self.frame, should_fail=True)
 #f not isinstance(x, str):
 #aise TypeError("interpret returned non-string %r" % (x,))
 #elf.exprinfo = x
 #eturn self.exprinfo

 #ef getfirstlinesource(self):
        # on Jython this firstlineno can be -1 apparently
 #eturn max(self.frame.code.firstlineno, 0)

 #ef getsource(self, astcache=None):
 #"" return failing source code. """
        # we use the passed in astcache to not reparse asttrees
        # within exception info printing
 #rom py._code.source import getstatementrange_ast
 #ource = self.frame.code.fullsource
 #f source is None:
 #eturn None
 #ey = astnode = None
 #f astcache is not None:
 #ey = self.frame.code.path
 #f key is not None:
 #stnode = astcache.get(key, None)
 #tart = self.getfirstlinesource()
 #ry:
 #stnode, _, end = getstatementrange_ast(self.lineno, source,
 #stnode=astnode)
 #xcept SyntaxError:
 #nd = self.lineno + 1
 #lse:
 #f key is not None:
 #stcache[key] = astnode
 #eturn source[start:end]

 #ource = property(getsource)

 #ef ishidden(self):
 #"" return True if the current frame has a var __tracebackhide__
 #esolving to True

 #ostly for internal use
 #""
 #ry:
 #eturn self.frame.f_locals['__tracebackhide__']
 #xcept KeyError:
 #ry:
 #eturn self.frame.f_globals['__tracebackhide__']
 #xcept KeyError:
 #eturn False

 #ef __str__(self):
 #ry:
 #n = str(self.path)
 #xcept py.error.Error:
 #n = '???'
 #ame = self.frame.code.name
 #ry:
 #ine = str(self.statement).lstrip()
 #xcept KeyboardInterrupt:
 #aise
 #xcept:
 #ine = "???"
 #eturn "  File %r:%d in %s\n  %s\n" % (fn, self.lineno+1, name, line)

 #ef name(self):
 #eturn self.frame.code.raw.co_name
 #ame = property(name, None, None, "co_name of underlaying code")


class Traceback(list):
 #"" Traceback objects encapsulate and offer higher level
 #ccess to Traceback entries.
 #""
 #ntry = TracebackEntry

 #ef __init__(self, tb):
 #"" initialize from given python traceback object. """
 #f hasattr(tb, 'tb_next'):
 #ef f(cur):
 #hile cur is not None:
 #ield self.Entry(cur)
 #ur = cur.tb_next
 #ist.__init__(self, f(tb))
 #lse:
 #ist.__init__(self, tb)

 #ef cut(self, path=None, lineno=None, firstlineno=None, excludepath=None):
 #"" return a Traceback instance wrapping part of this Traceback

 #y provding any combination of path, lineno and firstlineno, the
 #irst frame to start the to-be-returned traceback is determined

 #his allows cutting the first part of a Traceback instance e.g.
 #or formatting reasons (removing some uninteresting bits that deal
 #ith handling of the exception/traceback)
 #""
 #or x in self:
 #ode = x.frame.code
 #odepath = code.path
 #f ((path is None or codepath == path) and
 #excludepath is None or not hasattr(codepath, 'relto') or
 #ot codepath.relto(excludepath)) and
 #lineno is None or x.lineno == lineno) and
 #firstlineno is None or x.frame.code.firstlineno == firstlineno)):
 #eturn Traceback(x._rawentry)
 #eturn self

 #ef __getitem__(self, key):
 #al = super(Traceback, self).__getitem__(key)
 #f isinstance(key, type(slice(0))):
 #al = self.__class__(val)
 #eturn val

 #ef filter(self, fn=lambda x: not x.ishidden()):
 #"" return a Traceback instance with certain items removed

 #n is a function that gets a single argument, a TracebackItem
 #nstance, and should return True when the item should be added
 #o the Traceback, False when not

 #y default this removes all the TracebackItems which are hidden
 #see ishidden() above)
 #""
 #eturn Traceback(filter(fn, self))

 #ef getcrashentry(self):
 #"" return last non-hidden traceback entry that lead
 #o the exception of a traceback.
 #""
 #or i in range(-1, -len(self)-1, -1):
 #ntry = self[i]
 #f not entry.ishidden():
 #eturn entry
 #eturn self[-1]

 #ef recursionindex(self):
 #"" return the index of the frame/TracebackItem where recursion
 #riginates if appropriate, None if no recursion occurred
 #""
 #ache = {}
 #or i, entry in enumerate(self):
            # id for the code.raw is needed to work around
            # the strange metaprogramming in the decorator lib from pypi
            # which generates code objects that have hash/value equality
            #XXX needs a test
 #ey = entry.frame.code.path, id(entry.frame.code.raw), entry.lineno
            #print "checking for recursion at", key
 # = cache.setdefault(key, [])
 #f l:
 # = entry.frame
 #oc = f.f_locals
 #or otherloc in l:
 #f f.is_true(f.eval(co_equal,
 #_recursioncache_locals_1=loc,
 #_recursioncache_locals_2=otherloc)):
 #eturn i
 #.append(entry.frame.f_locals)
 #eturn None

co_equal = compile('__recursioncache_locals_1 == __recursioncache_locals_2',
 #?', 'eval')

class ExceptionInfo(object):
 #"" wraps sys.exc_info() objects and offers
 #elp for navigating the traceback.
 #""
 #striptext = ''
 #ef __init__(self, tup=None, exprinfo=None):
 #f tup is None:
 #up = sys.exc_info()
 #f exprinfo is None and isinstance(tup[1], AssertionError):
 #xprinfo = getattr(tup[1], 'msg', None)
 #f exprinfo is None:
 #xprinfo = str(tup[1])
 #f exprinfo and exprinfo.startswith('assert '):
 #elf._striptext = 'AssertionError: '
 #elf._excinfo = tup
        #: the exception class
 #elf.type = tup[0]
        #: the exception instance
 #elf.value = tup[1]
        #: the exception raw traceback
 #elf.tb = tup[2]
        #: the exception type name
 #elf.typename = self.type.__name__
        #: the exception traceback (py.code.Traceback instance)
 #elf.traceback = py.code.Traceback(self.tb)

 #ef __repr__(self):
 #eturn "<ExceptionInfo %s tblen=%d>" % (
 #elf.typename, len(self.traceback))

 #ef exconly(self, tryshort=False):
 #"" return the exception as a string

 #hen 'tryshort' resolves to True, and the exception is a
 #y.code._AssertionError, only the actual exception part of
 #he exception representation is returned (so 'AssertionError: ' is
 #emoved from the beginning)
 #""
 #ines = format_exception_only(self.type, self.value)
 #ext = ''.join(lines)
 #ext = text.rstrip()
 #f tryshort:
 #f text.startswith(self._striptext):
 #ext = text[len(self._striptext):]
 #eturn text

 #ef errisinstance(self, exc):
 #"" return True if the exception is an instance of exc """
 #eturn isinstance(self.value, exc)

 #ef _getreprcrash(self):
 #xconly = self.exconly(tryshort=True)
 #ntry = self.traceback.getcrashentry()
 #ath, lineno = entry.frame.code.raw.co_filename, entry.lineno
 #eturn ReprFileLocation(path, lineno+1, exconly)

 #ef getrepr(self, showlocals=False, style="long",
 #bspath=False, tbfilter=True, funcargs=False):
 #"" return str()able representation of this exception info.
 #howlocals: show locals per traceback entry
 #tyle: long|short|no|native traceback style
 #bfilter: hide entries (where __tracebackhide__ is true)

 #n case of style==native, tbfilter and showlocals is ignored.
 #""
 #f style == 'native':
 #eturn ReprExceptionInfo(ReprTracebackNative(
 #raceback.format_exception(
 #elf.type,
 #elf.value,
 #elf.traceback[0]._rawentry,
 #), self._getreprcrash())

 #mt = FormattedExcinfo(
 #howlocals=showlocals, style=style,
 #bspath=abspath, tbfilter=tbfilter, funcargs=funcargs)
 #eturn fmt.repr_excinfo(self)

 #ef __str__(self):
 #ntry = self.traceback[-1]
 #oc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())
 #eturn str(loc)

 #ef __unicode__(self):
 #ntry = self.traceback[-1]
 #oc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())
 #eturn loc.__unicode__()


class FormattedExcinfo(object):
 #"" presenting information about failing Functions and Generators. """
    # for traceback entries
 #low_marker = ">"
 #ail_marker = "E"

 #ef __init__(self, showlocals=False, style="long",
 #bspath=True, tbfilter=True, funcargs=False):
 #elf.showlocals = showlocals
 #elf.style = style
 #elf.tbfilter = tbfilter
 #elf.funcargs = funcargs
 #elf.abspath = abspath
 #elf.astcache = {}

 #ef _getindent(self, source):
        # figure out indent for given source
 #ry:
 # = str(source.getstatement(len(source)-1))
 #xcept KeyboardInterrupt:
 #aise
 #xcept:
 #ry:
 # = str(source[-1])
 #xcept KeyboardInterrupt:
 #aise
 #xcept:
 #eturn 0
 #eturn 4 + (len(s) - len(s.lstrip()))

 #ef _getentrysource(self, entry):
 #ource = entry.getsource(self.astcache)
 #f source is not None:
 #ource = source.deindent()
 #eturn source

 #ef _saferepr(self, obj):
 #eturn py.io.saferepr(obj)

 #ef repr_args(self, entry):
 #f self.funcargs:
 #rgs = []
 #or argname, argvalue in entry.frame.getargs(var=True):
 #rgs.append((argname, self._saferepr(argvalue)))
 #eturn ReprFuncArgs(args)

 #ef get_source(self, source, line_index=-1, excinfo=None, short=False):
 #"" return formatted and marked up source lines. """
 #ines = []
 #f source is None or line_index >= len(source.lines):
 #ource = py.code.Source("???")
 #ine_index = 0
 #f line_index < 0:
 #ine_index += len(source)
 #pace_prefix = "    "
 #f short:
 #ines.append(space_prefix + source.lines[line_index].strip())
 #lse:
 #or line in source.lines[:line_index]:
 #ines.append(space_prefix + line)
 #ines.append(self.flow_marker + "   " + source.lines[line_index])
 #or line in source.lines[line_index+1:]:
 #ines.append(space_prefix + line)
 #f excinfo is not None:
 #ndent = 4 if short else self._getindent(source)
 #ines.extend(self.get_exconly(excinfo, indent=indent, markall=True))
 #eturn lines

 #ef get_exconly(self, excinfo, indent=4, markall=False):
 #ines = []
 #ndent = " " * indent
        # get the real exception information out
 #xlines = excinfo.exconly(tryshort=True).split('\n')
 #ailindent = self.fail_marker + indent[1:]
 #or line in exlines:
 #ines.append(failindent + line)
 #f not markall:
 #ailindent = indent
 #eturn lines

 #ef repr_locals(self, locals):
 #f self.showlocals:
 #ines = []
 #eys = [loc for loc in locals if loc[0] != "@"]
 #eys.sort()
 #or name in keys:
 #alue = locals[name]
 #f name == '__builtins__':
 #ines.append("__builtins__ = <builtins>")
 #lse:
                    # This formatting could all be handled by the
                    # _repr() function, which is only reprlib.Repr in
                    # disguise, so is very configurable.
 #tr_repr = self._saferepr(value)
                    #if len(str_repr) < 70 or not isinstance(value,
                    #                            (list, tuple, dict)):
 #ines.append("%-10s = %s" %(name, str_repr))
                    #else:
                    #    self._line("%-10s =\\" % (name,))
                    #    # XXX
                    #    pprint.pprint(value, stream=self.excinfowriter)
 #eturn ReprLocals(lines)

 #ef repr_traceback_entry(self, entry, excinfo=None):
 #ource = self._getentrysource(entry)
 #f source is None:
 #ource = py.code.Source("???")
 #ine_index = 0
 #lse:
            # entry.getfirstlinesource() can be -1, should be 0 on jython
 #ine_index = entry.lineno - max(entry.getfirstlinesource(), 0)

 #ines = []
 #tyle = entry._repr_style
 #f style is None:
 #tyle = self.style
 #f style in ("short", "long"):
 #hort = style == "short"
 #eprargs = self.repr_args(entry) if not short else None
 # = self.get_source(source, line_index, excinfo, short=short)
 #ines.extend(s)
 #f short:
 #essage = "in %s" %(entry.name)
 #lse:
 #essage = excinfo and excinfo.typename or ""
 #ath = self._makepath(entry.path)
 #ilelocrepr = ReprFileLocation(path, entry.lineno+1, message)
 #ocalsrepr = None
 #f not short:
 #ocalsrepr =  self.repr_locals(entry.locals)
 #eturn ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)
 #f excinfo:
 #ines.extend(self.get_exconly(excinfo, indent=4))
 #eturn ReprEntry(lines, None, None, None, style)

 #ef _makepath(self, path):
 #f not self.abspath:
 #ry:
 #p = py.path.local().bestrelpath(path)
 #xcept OSError:
 #eturn path
 #f len(np) < len(str(path)):
 #ath = np
 #eturn path

 #ef repr_traceback(self, excinfo):
 #raceback = excinfo.traceback
 #f self.tbfilter:
 #raceback = traceback.filter()
 #ecursionindex = None
 #f excinfo.errisinstance(RuntimeError):
 #f "maximum recursion depth exceeded" in str(excinfo.value):
 #ecursionindex = traceback.recursionindex()
 #ast = traceback[-1]
 #ntries = []
 #xtraline = None
 #or index, entry in enumerate(traceback):
 #info = (last == entry) and excinfo or None
 #eprentry = self.repr_traceback_entry(entry, einfo)
 #ntries.append(reprentry)
 #f index == recursionindex:
 #xtraline = "!!! Recursion detected (same locals & position)"
 #reak
 #eturn ReprTraceback(entries, extraline, style=self.style)

 #ef repr_excinfo(self, excinfo):
 #eprtraceback = self.repr_traceback(excinfo)
 #eprcrash = excinfo._getreprcrash()
 #eturn ReprExceptionInfo(reprtraceback, reprcrash)

class TerminalRepr:
 #ef __str__(self):
 # = self.__unicode__()
 #f sys.version_info[0] < 3:
 # = s.encode('utf-8')
 #eturn s

 #ef __unicode__(self):
        # FYI this is called from pytest-xdist's serialization of exception
        # information.
 #o = py.io.TextIO()
 #w = py.io.TerminalWriter(file=io)
 #elf.toterminal(tw)
 #eturn io.getvalue().strip()

 #ef __repr__(self):
 #eturn "<%s instance at %0x>" %(self.__class__, id(self))


class ReprExceptionInfo(TerminalRepr):
 #ef __init__(self, reprtraceback, reprcrash):
 #elf.reprtraceback = reprtraceback
 #elf.reprcrash = reprcrash
 #elf.sections = []

 #ef addsection(self, name, content, sep="-"):
 #elf.sections.append((name, content, sep))

 #ef toterminal(self, tw):
 #elf.reprtraceback.toterminal(tw)
 #or name, content, sep in self.sections:
 #w.sep(sep, name)
 #w.line(content)

class ReprTraceback(TerminalRepr):
 #ntrysep = "_ "

 #ef __init__(self, reprentries, extraline, style):
 #elf.reprentries = reprentries
 #elf.extraline = extraline
 #elf.style = style

 #ef toterminal(self, tw):
        # the entries might have different styles
 #ast_style = None
 #or i, entry in enumerate(self.reprentries):
 #f entry.style == "long":
 #w.line("")
 #ntry.toterminal(tw)
 #f i < len(self.reprentries) - 1:
 #ext_entry = self.reprentries[i+1]
 #f entry.style == "long" or \
 #ntry.style == "short" and next_entry.style == "long":
 #w.sep(self.entrysep)

 #f self.extraline:
 #w.line(self.extraline)

class ReprTracebackNative(ReprTraceback):
 #ef __init__(self, tblines):
 #elf.style = "native"
 #elf.reprentries = [ReprEntryNative(tblines)]
 #elf.extraline = None

class ReprEntryNative(TerminalRepr):
 #tyle = "native"

 #ef __init__(self, tblines):
 #elf.lines = tblines

 #ef toterminal(self, tw):
 #w.write("".join(self.lines))

class ReprEntry(TerminalRepr):
 #ocalssep = "_ "

 #ef __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):
 #elf.lines = lines
 #elf.reprfuncargs = reprfuncargs
 #elf.reprlocals = reprlocals
 #elf.reprfileloc = filelocrepr
 #elf.style = style

 #ef toterminal(self, tw):
 #f self.style == "short":
 #elf.reprfileloc.toterminal(tw)
 #or line in self.lines:
 #ed = line.startswith("E   ")
 #w.line(line, bold=True, red=red)
            #tw.line("")
 #eturn
 #f self.reprfuncargs:
 #elf.reprfuncargs.toterminal(tw)
 #or line in self.lines:
 #ed = line.startswith("E   ")
 #w.line(line, bold=True, red=red)
 #f self.reprlocals:
            #tw.sep(self.localssep, "Locals")
 #w.line("")
 #elf.reprlocals.toterminal(tw)
 #f self.reprfileloc:
 #f self.lines:
 #w.line("")
 #elf.reprfileloc.toterminal(tw)

 #ef __str__(self):
 #eturn "%s\n%s\n%s" % ("\n".join(self.lines),
 #elf.reprlocals,
 #elf.reprfileloc)

class ReprFileLocation(TerminalRepr):
 #ef __init__(self, path, lineno, message):
 #elf.path = str(path)
 #elf.lineno = lineno
 #elf.message = message

 #ef toterminal(self, tw):
        # filename and lineno output for each entry,
        # using an output format that most editors unterstand
 #sg = self.message
 # = msg.find("\n")
 #f i != -1:
 #sg = msg[:i]
 #w.line("%s:%s: %s" %(self.path, self.lineno, msg))

class ReprLocals(TerminalRepr):
 #ef __init__(self, lines):
 #elf.lines = lines

 #ef toterminal(self, tw):
 #or line in self.lines:
 #w.line(line)

class ReprFuncArgs(TerminalRepr):
 #ef __init__(self, args):
 #elf.args = args

 #ef toterminal(self, tw):
 #f self.args:
 #inesofar = ""
 #or name, value in self.args:
 #s = "%s = %s" %(name, value)
 #f len(ns) + len(linesofar) + 2 > tw.fullwidth:
 #f linesofar:
 #w.line(linesofar)
 #inesofar =  ns
 #lse:
 #f linesofar:
 #inesofar += ", " + ns
 #lse:
 #inesofar = ns
 #f linesofar:
 #w.line(linesofar)
 #w.line("")



oldbuiltins = {}

def patch_builtins(assertion=True, compile=True):
 #"" put compile and AssertionError builtins to Python's builtins. """
 #f assertion:
 #rom py._code import assertion
 # = oldbuiltins.setdefault('AssertionError', [])
 #.append(py.builtin.builtins.AssertionError)
 #y.builtin.builtins.AssertionError = assertion.AssertionError
 #f compile:
 # = oldbuiltins.setdefault('compile', [])
 #.append(py.builtin.builtins.compile)
 #y.builtin.builtins.compile = py.code.compile

def unpatch_builtins(assertion=True, compile=True):
 #"" remove compile and AssertionError builtins from Python builtins. """
 #f assertion:
 #y.builtin.builtins.AssertionError = oldbuiltins['AssertionError'].pop()
 #f compile:
 #y.builtin.builtins.compile = oldbuiltins['compile'].pop()

def getrawcode(obj, trycall=True):
 #"" return code object for given function. """
 #ry:
 #eturn obj.__code__
 #xcept AttributeError:
 #bj = getattr(obj, 'im_func', obj)
 #bj = getattr(obj, 'func_code', obj)
 #bj = getattr(obj, 'f_code', obj)
 #bj = getattr(obj, '__code__', obj)
 #f trycall and not hasattr(obj, 'co_firstlineno'):
 #f hasattr(obj, '__call__') and not isclass(obj):
 # = getrawcode(obj.__call__, trycall=False)
 #f hasattr(x, 'co_firstlineno'):
 #eturn x
 #eturn obj

