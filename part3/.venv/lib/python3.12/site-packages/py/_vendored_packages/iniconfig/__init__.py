""" brain-dead simple parser for ini-style files.
(C) Ronny Pfannschmidt, Holger Krekel -- MIT licensed
"""
__all__ = ['IniConfig', 'ParseError']

COMMENTCHARS = "#;"


class ParseError(Exception):
 #ef __init__(self, path, lineno, msg):
 #xception.__init__(self, path, lineno, msg)
 #elf.path = path
 #elf.lineno = lineno
 #elf.msg = msg

 #ef __str__(self):
 #eturn "%s:%s: %s" % (self.path, self.lineno+1, self.msg)


class SectionWrapper(object):
 #ef __init__(self, config, name):
 #elf.config = config
 #elf.name = name

 #ef lineof(self, name):
 #eturn self.config.lineof(self.name, name)

 #ef get(self, key, default=None, convert=str):
 #eturn self.config.get(self.name, key,
 #onvert=convert, default=default)

 #ef __getitem__(self, key):
 #eturn self.config.sections[self.name][key]

 #ef __iter__(self):
 #ection = self.config.sections.get(self.name, [])

 #ef lineof(key):
 #eturn self.config.lineof(self.name, key)
 #or name in sorted(section, key=lineof):
 #ield name

 #ef items(self):
 #or name in self:
 #ield name, self[name]


class IniConfig(object):
 #ef __init__(self, path, data=None):
 #elf.path = str(path)  # convenience
 #f data is None:
 # = open(self.path)
 #ry:
 #okens = self._parse(iter(f))
 #inally:
 #.close()
 #lse:
 #okens = self._parse(data.splitlines(True))

 #elf._sources = {}
 #elf.sections = {}

 #or lineno, section, name, value in tokens:
 #f section is None:
 #elf._raise(lineno, 'no section header defined')
 #elf._sources[section, name] = lineno
 #f name is None:
 #f section in self.sections:
 #elf._raise(lineno, 'duplicate section %r' % (section, ))
 #elf.sections[section] = {}
 #lse:
 #f name in self.sections[section]:
 #elf._raise(lineno, 'duplicate name %r' % (name, ))
 #elf.sections[section][name] = value

 #ef _raise(self, lineno, msg):
 #aise ParseError(self.path, lineno, msg)

 #ef _parse(self, line_iter):
 #esult = []
 #ection = None
 #or lineno, line in enumerate(line_iter):
 #ame, data = self._parseline(line, lineno)
            # new value
 #f name is not None and data is not None:
 #esult.append((lineno, section, name, data))
            # new section
 #lif name is not None and data is None:
 #f not name:
 #elf._raise(lineno, 'empty section name')
 #ection = name
 #esult.append((lineno, section, None, None))
            # continuation
 #lif name is None and data is not None:
 #f not result:
 #elf._raise(lineno, 'unexpected value continuation')
 #ast = result.pop()
 #ast_name, last_data = last[-2:]
 #f last_name is None:
 #elf._raise(lineno, 'unexpected value continuation')

 #f last_data:
 #ata = '%s\n%s' % (last_data, data)
 #esult.append(last[:-1] + (data,))
 #eturn result

 #ef _parseline(self, line, lineno):
        # blank lines
 #f iscommentline(line):
 #ine = ""
 #lse:
 #ine = line.rstrip()
 #f not line:
 #eturn None, None
        # section
 #f line[0] == '[':
 #ealline = line
 #or c in COMMENTCHARS:
 #ine = line.split(c)[0].rstrip()
 #f line[-1] == "]":
 #eturn line[1:-1], None
 #eturn None, realline.strip()
        # value
 #lif not line[0].isspace():
 #ry:
 #ame, value = line.split('=', 1)
 #f ":" in name:
 #aise ValueError()
 #xcept ValueError:
 #ry:
 #ame, value = line.split(":", 1)
 #xcept ValueError:
 #elf._raise(lineno, 'unexpected line: %r' % line)
 #eturn name.strip(), value.strip()
        # continuation
 #lse:
 #eturn None, line.strip()

 #ef lineof(self, section, name=None):
 #ineno = self._sources.get((section, name))
 #f lineno is not None:
 #eturn lineno + 1

 #ef get(self, section, name, default=None, convert=str):
 #ry:
 #eturn convert(self.sections[section][name])
 #xcept KeyError:
 #eturn default

 #ef __getitem__(self, name):
 #f name not in self.sections:
 #aise KeyError(name)
 #eturn SectionWrapper(self, name)

 #ef __iter__(self):
 #or name in sorted(self.sections, key=self.lineof):
 #ield SectionWrapper(self, name)

 #ef __contains__(self, arg):
 #eturn arg in self.sections


def iscommentline(line):
 # = line.lstrip()[:1]
 #eturn c in COMMENTCHARS
