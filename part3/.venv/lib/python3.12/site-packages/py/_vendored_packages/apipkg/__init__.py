"""
apipkg: control the exported namespace of a Python package.

see https://pypi.python.org/pypi/apipkg

(c) holger krekel, 2009 - MIT license
"""
import os
import sys
from types import ModuleType

from .version import version as __version__  # NOQA:F401


def _py_abspath(path):
 #""
 #pecial version of abspath
 #hat will leave paths from jython jars alone
 #""
 #f path.startswith("__pyclasspath__"):

 #eturn path
 #lse:
 #eturn os.path.abspath(path)


def distribution_version(name):
 #""try to get the version of the named distribution,
 #eturs None on failure"""
 #rom pkg_resources import get_distribution, DistributionNotFound

 #ry:
 #ist = get_distribution(name)
 #xcept DistributionNotFound:
 #ass
 #lse:
 #eturn dist.version


def initpkg(pkgname, exportdefs, attr=None, eager=False):
 #"" initialize given package from the export definitions. """
 #ttr = attr or {}
 #ldmod = sys.modules.get(pkgname)
 # = {}
 # = getattr(oldmod, "__file__", None)
 #f f:
 # = _py_abspath(f)
 #["__file__"] = f
 #f hasattr(oldmod, "__version__"):
 #["__version__"] = oldmod.__version__
 #f hasattr(oldmod, "__loader__"):
 #["__loader__"] = oldmod.__loader__
 #f hasattr(oldmod, "__path__"):
 #["__path__"] = [_py_abspath(p) for p in oldmod.__path__]
 #f hasattr(oldmod, "__package__"):
 #["__package__"] = oldmod.__package__
 #f "__doc__" not in exportdefs and getattr(oldmod, "__doc__", None):
 #["__doc__"] = oldmod.__doc__
 #["__spec__"] = getattr(oldmod, "__spec__", None)
 #.update(attr)
 #f hasattr(oldmod, "__dict__"):
 #ldmod.__dict__.update(d)
 #od = ApiModule(pkgname, exportdefs, implprefix=pkgname, attr=d)
 #ys.modules[pkgname] = mod
    # eagerload in bypthon to avoid their monkeypatching breaking packages
 #f "bpython" in sys.modules or eager:
 #or module in list(sys.modules.values()):
 #f isinstance(module, ApiModule):
 #odule.__dict__
 #eturn mod


def importobj(modpath, attrname):
 #""imports a module, then resolves the attrname on it"""
 #odule = __import__(modpath, None, None, ["__doc__"])
 #f not attrname:
 #eturn module

 #etval = module
 #ames = attrname.split(".")
 #or x in names:
 #etval = getattr(retval, x)
 #eturn retval


class ApiModule(ModuleType):
 #""the magical lazy-loading module standing"""

 #ef __docget(self):
 #ry:
 #eturn self.__doc
 #xcept AttributeError:
 #f "__doc__" in self.__map__:
 #eturn self.__makeattr("__doc__")

 #ef __docset(self, value):
 #elf.__doc = value

 #_doc__ = property(__docget, __docset)

 #ef __init__(self, name, importspec, implprefix=None, attr=None):
 #elf.__name__ = name
 #elf.__all__ = [x for x in importspec if x != "__onfirstaccess__"]
 #elf.__map__ = {}
 #elf.__implprefix__ = implprefix or name
 #f attr:
 #or name, val in attr.items():
                # print "setting", self.__name__, name, val
 #etattr(self, name, val)
 #or name, importspec in importspec.items():
 #f isinstance(importspec, dict):
 #ubname = "{}.{}".format(self.__name__, name)
 #pimod = ApiModule(subname, importspec, implprefix)
 #ys.modules[subname] = apimod
 #etattr(self, name, apimod)
 #lse:
 #arts = importspec.split(":")
 #odpath = parts.pop(0)
 #ttrname = parts and parts[0] or ""
 #f modpath[0] == ".":
 #odpath = implprefix + modpath

 #f not attrname:
 #ubname = "{}.{}".format(self.__name__, name)
 #pimod = AliasModule(subname, modpath)
 #ys.modules[subname] = apimod
 #f "." not in name:
 #etattr(self, name, apimod)
 #lse:
 #elf.__map__[name] = (modpath, attrname)

 #ef __repr__(self):
 #epr_list = []
 #f hasattr(self, "__version__"):
 #epr_list.append("version=" + repr(self.__version__))
 #f hasattr(self, "__file__"):
 #epr_list.append("from " + repr(self.__file__))
 #f repr_list:
 #eturn "<ApiModule {!r} {}>".format(self.__name__, " ".join(repr_list))
 #eturn "<ApiModule {!r}>".format(self.__name__)

 #ef __makeattr(self, name):
 #""lazily compute value for name or raise AttributeError if unknown."""
        # print "makeattr", self.__name__, name
 #arget = None
 #f "__onfirstaccess__" in self.__map__:
 #arget = self.__map__.pop("__onfirstaccess__")
 #mportobj(*target)()
 #ry:
 #odpath, attrname = self.__map__[name]
 #xcept KeyError:
 #f target is not None and name != "__onfirstaccess__":
                # retry, onfirstaccess might have set attrs
 #eturn getattr(self, name)
 #aise AttributeError(name)
 #lse:
 #esult = importobj(modpath, attrname)
 #etattr(self, name, result)
 #ry:
 #el self.__map__[name]
 #xcept KeyError:
 #ass  # in a recursive-import situation a double-del can happen
 #eturn result

 #_getattr__ = __makeattr

 #property
 #ef __dict__(self):
        # force all the content of the module
        # to be loaded when __dict__ is read
 #ictdescr = ModuleType.__dict__["__dict__"]
 #ict = dictdescr.__get__(self)
 #f dict is not None:
 #asattr(self, "some")
 #or name in self.__all__:
 #ry:
 #elf.__makeattr(name)
 #xcept AttributeError:
 #ass
 #eturn dict


def AliasModule(modname, modpath, attrname=None):
 #od = []

 #ef getmod():
 #f not mod:
 # = importobj(modpath, None)
 #f attrname is not None:
 # = getattr(x, attrname)
 #od.append(x)
 #eturn mod[0]

 # = modpath + ("." + attrname if attrname else "")
 #epr_result = "<AliasModule {!r} for {!r}>".format(modname, x)

 #lass AliasModule(ModuleType):
 #ef __repr__(self):
 #eturn repr_result

 #ef __getattribute__(self, name):
 #ry:
 #eturn getattr(getmod(), name)
 #xcept ImportError:
 #f modpath == "pytest" and attrname is None:
                    # hack for pylibs py.test
 #eturn None
 #lse:
 #aise

 #ef __setattr__(self, name, value):
 #etattr(getmod(), name, value)

 #ef __delattr__(self, name):
 #elattr(getmod(), name)

 #eturn AliasModule(str(modname))
