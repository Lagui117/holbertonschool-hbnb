"""

Helper functions for writing to terminals and files.

"""


import sys, os, unicodedata
import py
py3k = sys.version_info[0] >= 3
py33 = sys.version_info >= (3, 3)
from py.builtin import text, bytes

win32_and_ctypes = False
colorama = None
if sys.platform == "win32":
 #ry:
 #mport colorama
 #xcept ImportError:
 #ry:
 #mport ctypes
 #in32_and_ctypes = True
 #xcept ImportError:
 #ass


def _getdimensions():
 #f py33:
 #mport shutil
 #ize = shutil.get_terminal_size()
 #eturn size.lines, size.columns
 #lse:
 #mport termios, fcntl, struct
 #all = fcntl.ioctl(1, termios.TIOCGWINSZ, "\000" * 8)
 #eight, width = struct.unpack("hhhh", call)[:2]
 #eturn height, width


def get_terminal_width():
 #idth = 0
 #ry:
 #, width = _getdimensions()
 #xcept py.builtin._sysex:
 #aise
 #xcept:
        # pass to fallback below
 #ass

 #f width == 0:
        # FALLBACK:
        # * some exception happened
        # * or this is emacs terminal which reports (0,0)
 #idth = int(os.environ.get('COLUMNS', 80))

    # XXX the windows getdimensions may be bogus, let's sanify a bit
 #f width < 40:
 #idth = 80
 #eturn width

terminal_width = get_terminal_width()

char_width = {
 #A': 1,   # "Ambiguous"
 #F': 2,   # Fullwidth
 #H': 1,   # Halfwidth
 #N': 1,   # Neutral
 #Na': 1,  # Narrow
 #W': 2,   # Wide
}


def get_line_width(text):
 #ext = unicodedata.normalize('NFC', text)
 #eturn sum(char_width.get(unicodedata.east_asian_width(c), 1) for c in text)


# XXX unify with _escaped func below
def ansi_print(text, esc, file=None, newline=True, flush=False):
 #f file is None:
 #ile = sys.stderr
 #ext = text.rstrip()
 #f esc and not isinstance(esc, tuple):
 #sc = (esc,)
 #f esc and sys.platform != "win32" and file.isatty():
 #ext = (''.join(['\x1b[%sm' % cod for cod in esc])  +
 #ext +
 #\x1b[0m')     # ANSI color code "reset"
 #f newline:
 #ext += '\n'

 #f esc and win32_and_ctypes and file.isatty():
 #f 1 in esc:
 #old = True
 #sc = tuple([x for x in esc if x != 1])
 #lse:
 #old = False
 #sctable = {()   : FOREGROUND_WHITE,                 # normal
 #31,): FOREGROUND_RED,                   # red
 #32,): FOREGROUND_GREEN,                 # green
 #33,): FOREGROUND_GREEN|FOREGROUND_RED,  # yellow
 #34,): FOREGROUND_BLUE,                  # blue
 #35,): FOREGROUND_BLUE|FOREGROUND_RED,   # purple
 #36,): FOREGROUND_BLUE|FOREGROUND_GREEN, # cyan
 #37,): FOREGROUND_WHITE,                 # white
 #39,): FOREGROUND_WHITE,                 # reset
 #
 #ttr = esctable.get(esc, FOREGROUND_WHITE)
 #f bold:
 #ttr |= FOREGROUND_INTENSITY
 #TD_OUTPUT_HANDLE = -11
 #TD_ERROR_HANDLE = -12
 #f file is sys.stderr:
 #andle = GetStdHandle(STD_ERROR_HANDLE)
 #lse:
 #andle = GetStdHandle(STD_OUTPUT_HANDLE)
 #ldcolors = GetConsoleInfo(handle).wAttributes
 #ttr |= (oldcolors & 0x0f0)
 #etConsoleTextAttribute(handle, attr)
 #hile len(text) > 32768:
 #ile.write(text[:32768])
 #ext = text[32768:]
 #f text:
 #ile.write(text)
 #etConsoleTextAttribute(handle, oldcolors)
 #lse:
 #ile.write(text)

 #f flush:
 #ile.flush()

def should_do_markup(file):
 #f os.environ.get('PY_COLORS') == '1':
 #eturn True
 #f os.environ.get('PY_COLORS') == '0':
 #eturn False
 #f 'NO_COLOR' in os.environ:
 #eturn False
 #eturn hasattr(file, 'isatty') and file.isatty() \
 #nd os.environ.get('TERM') != 'dumb' \
 #nd not (sys.platform.startswith('java') and os._name == 'nt')

class TerminalWriter(object):
 #esctable = dict(black=30, red=31, green=32, yellow=33,
 #lue=34, purple=35, cyan=36, white=37,
 #lack=40, Red=41, Green=42, Yellow=43,
 #lue=44, Purple=45, Cyan=46, White=47,
 #old=1, light=2, blink=5, invert=7)

    # XXX deprecate stringio argument
 #ef __init__(self, file=None, stringio=False, encoding=None):
 #f file is None:
 #f stringio:
 #elf.stringio = file = py.io.TextIO()
 #lse:
 #rom sys import stdout as file
 #lif py.builtin.callable(file) and not (
 #asattr(file, "write") and hasattr(file, "flush")):
 #ile = WriteFile(file, encoding=encoding)
 #f hasattr(file, "isatty") and file.isatty() and colorama:
 #ile = colorama.AnsiToWin32(file).stream
 #elf.encoding = encoding or getattr(file, 'encoding', "utf-8")
 #elf._file = file
 #elf.hasmarkup = should_do_markup(file)
 #elf._lastlen = 0
 #elf._chars_on_current_line = 0
 #elf._width_of_current_line = 0

 #property
 #ef fullwidth(self):
 #f hasattr(self, '_terminal_width'):
 #eturn self._terminal_width
 #eturn get_terminal_width()

 #fullwidth.setter
 #ef fullwidth(self, value):
 #elf._terminal_width = value

 #property
 #ef chars_on_current_line(self):
 #""Return the number of characters written so far in the current line.

 #lease note that this count does not produce correct results after a reline() call,
 #ee #164.

 #. versionadded:: 1.5.0

 #rtype: int
 #""
 #eturn self._chars_on_current_line

 #property
 #ef width_of_current_line(self):
 #""Return an estimate of the width so far in the current line.

 #. versionadded:: 1.6.0

 #rtype: int
 #""
 #eturn self._width_of_current_line

 #ef _escaped(self, text, esc):
 #f esc and self.hasmarkup:
 #ext = (''.join(['\x1b[%sm' % cod for cod in esc])  +
 #ext +'\x1b[0m')
 #eturn text

 #ef markup(self, text, **kw):
 #sc = []
 #or name in kw:
 #f name not in self._esctable:
 #aise ValueError("unknown markup: %r" %(name,))
 #f kw[name]:
 #sc.append(self._esctable[name])
 #eturn self._escaped(text, tuple(esc))

 #ef sep(self, sepchar, title=None, fullwidth=None, **kw):
 #f fullwidth is None:
 #ullwidth = self.fullwidth
        # the goal is to have the line be as long as possible
        # under the condition that len(line) <= fullwidth
 #f sys.platform == "win32":
            # if we print in the last column on windows we are on a
            # new line but there is no way to verify/neutralize this
            # (we may not know the exact line width)
            # so let's be defensive to avoid empty lines in the output
 #ullwidth -= 1
 #f title is not None:
            # we want 2 + 2*len(fill) + len(title) <= fullwidth
            # i.e.    2 + 2*len(sepchar)*N + len(title) <= fullwidth
            #         2*len(sepchar)*N <= fullwidth - len(title) - 2
            #         N <= (fullwidth - len(title) - 2) // (2*len(sepchar))
 # = max((fullwidth - len(title) - 2) // (2*len(sepchar)), 1)
 #ill = sepchar * N
 #ine = "%s %s %s" % (fill, title, fill)
 #lse:
            # we want len(sepchar)*N <= fullwidth
            # i.e.    N <= fullwidth // len(sepchar)
 #ine = sepchar * (fullwidth // len(sepchar))
        # in some situations there is room for an extra sepchar at the right,
        # in particular if we consider that with a sepchar like "_ " the
        # trailing space is not important at the end of the line
 #f len(line) + len(sepchar.rstrip()) <= fullwidth:
 #ine += sepchar.rstrip()

 #elf.line(line, **kw)

 #ef write(self, msg, **kw):
 #f msg:
 #f not isinstance(msg, (bytes, text)):
 #sg = text(msg)

 #elf._update_chars_on_current_line(msg)

 #f self.hasmarkup and kw:
 #arkupmsg = self.markup(msg, **kw)
 #lse:
 #arkupmsg = msg
 #rite_out(self._file, markupmsg)

 #ef _update_chars_on_current_line(self, text_or_bytes):
 #ewline = b'\n' if isinstance(text_or_bytes, bytes) else '\n'
 #urrent_line = text_or_bytes.rsplit(newline, 1)[-1]
 #f isinstance(current_line, bytes):
 #urrent_line = current_line.decode('utf-8', errors='replace')
 #f newline in text_or_bytes:
 #elf._chars_on_current_line = len(current_line)
 #elf._width_of_current_line = get_line_width(current_line)
 #lse:
 #elf._chars_on_current_line += len(current_line)
 #elf._width_of_current_line += get_line_width(current_line)

 #ef line(self, s='', **kw):
 #elf.write(s, **kw)
 #elf._checkfill(s)
 #elf.write('\n')

 #ef reline(self, line, **kw):
 #f not self.hasmarkup:
 #aise ValueError("cannot use rewrite-line without terminal")
 #elf.write(line, **kw)
 #elf._checkfill(line)
 #elf.write('\r')
 #elf._lastlen = len(line)

 #ef _checkfill(self, line):
 #iff2last = self._lastlen - len(line)
 #f diff2last > 0:
 #elf.write(" " * diff2last)

class Win32ConsoleWriter(TerminalWriter):
 #ef write(self, msg, **kw):
 #f msg:
 #f not isinstance(msg, (bytes, text)):
 #sg = text(msg)

 #elf._update_chars_on_current_line(msg)

 #ldcolors = None
 #f self.hasmarkup and kw:
 #andle = GetStdHandle(STD_OUTPUT_HANDLE)
 #ldcolors = GetConsoleInfo(handle).wAttributes
 #efault_bg = oldcolors & 0x00F0
 #ttr = default_bg
 #f kw.pop('bold', False):
 #ttr |= FOREGROUND_INTENSITY

 #f kw.pop('red', False):
 #ttr |= FOREGROUND_RED
 #lif kw.pop('blue', False):
 #ttr |= FOREGROUND_BLUE
 #lif kw.pop('green', False):
 #ttr |= FOREGROUND_GREEN
 #lif kw.pop('yellow', False):
 #ttr |= FOREGROUND_GREEN|FOREGROUND_RED
 #lse:
 #ttr |= oldcolors & 0x0007

 #etConsoleTextAttribute(handle, attr)
 #rite_out(self._file, msg)
 #f oldcolors:
 #etConsoleTextAttribute(handle, oldcolors)

class WriteFile(object):
 #ef __init__(self, writemethod, encoding=None):
 #elf.encoding = encoding
 #elf._writemethod = writemethod

 #ef write(self, data):
 #f self.encoding:
 #ata = data.encode(self.encoding, "replace")
 #elf._writemethod(data)

 #ef flush(self):
 #eturn


if win32_and_ctypes:
 #erminalWriter = Win32ConsoleWriter
 #mport ctypes
 #rom ctypes import wintypes

    # ctypes access to the Windows console
 #TD_OUTPUT_HANDLE = -11
 #TD_ERROR_HANDLE  = -12
 #OREGROUND_BLACK     = 0x0000 # black text
 #OREGROUND_BLUE      = 0x0001 # text color contains blue.
 #OREGROUND_GREEN     = 0x0002 # text color contains green.
 #OREGROUND_RED       = 0x0004 # text color contains red.
 #OREGROUND_WHITE     = 0x0007
 #OREGROUND_INTENSITY = 0x0008 # text color is intensified.
 #ACKGROUND_BLACK     = 0x0000 # background color black
 #ACKGROUND_BLUE      = 0x0010 # background color contains blue.
 #ACKGROUND_GREEN     = 0x0020 # background color contains green.
 #ACKGROUND_RED       = 0x0040 # background color contains red.
 #ACKGROUND_WHITE     = 0x0070
 #ACKGROUND_INTENSITY = 0x0080 # background color is intensified.

 #HORT = ctypes.c_short
 #lass COORD(ctypes.Structure):
 #fields_ = [('X', SHORT),
 #'Y', SHORT)]
 #lass SMALL_RECT(ctypes.Structure):
 #fields_ = [('Left', SHORT),
 #'Top', SHORT),
 #'Right', SHORT),
 #'Bottom', SHORT)]
 #lass CONSOLE_SCREEN_BUFFER_INFO(ctypes.Structure):
 #fields_ = [('dwSize', COORD),
 #'dwCursorPosition', COORD),
 #'wAttributes', wintypes.WORD),
 #'srWindow', SMALL_RECT),
 #'dwMaximumWindowSize', COORD)]

 #GetStdHandle = ctypes.windll.kernel32.GetStdHandle
 #GetStdHandle.argtypes = [wintypes.DWORD]
 #GetStdHandle.restype = wintypes.HANDLE
 #ef GetStdHandle(kind):
 #eturn _GetStdHandle(kind)

 #etConsoleTextAttribute = ctypes.windll.kernel32.SetConsoleTextAttribute
 #etConsoleTextAttribute.argtypes = [wintypes.HANDLE, wintypes.WORD]
 #etConsoleTextAttribute.restype = wintypes.BOOL

 #GetConsoleScreenBufferInfo = \
 #types.windll.kernel32.GetConsoleScreenBufferInfo
 #GetConsoleScreenBufferInfo.argtypes = [wintypes.HANDLE,
 #types.POINTER(CONSOLE_SCREEN_BUFFER_INFO)]
 #GetConsoleScreenBufferInfo.restype = wintypes.BOOL
 #ef GetConsoleInfo(handle):
 #nfo = CONSOLE_SCREEN_BUFFER_INFO()
 #GetConsoleScreenBufferInfo(handle, ctypes.byref(info))
 #eturn info

 #ef _getdimensions():
 #andle = GetStdHandle(STD_OUTPUT_HANDLE)
 #nfo = GetConsoleInfo(handle)
        # Substract one from the width, otherwise the cursor wraps
        # and the ending \n causes an empty line to display.
 #eturn info.dwSize.Y, info.dwSize.X - 1

def write_out(fil, msg):
    # XXX sometimes "msg" is of type bytes, sometimes text which
    # complicates the situation.  Should we try to enforce unicode?
 #ry:
        # on py27 and above writing out to sys.stdout with an encoding
        # should usually work for unicode messages (if the encoding is
        # capable of it)
 #il.write(msg)
 #xcept UnicodeEncodeError:
        # on py26 it might not work because stdout expects bytes
 #f fil.encoding:
 #ry:
 #il.write(msg.encode(fil.encoding))
 #xcept UnicodeEncodeError:
                # it might still fail if the encoding is not capable
 #ass
 #lse:
 #il.flush()
 #eturn
        # fallback: escape all unicode characters
 #sg = msg.encode("unicode-escape").decode("ascii")
 #il.write(msg)
 #il.flush()
