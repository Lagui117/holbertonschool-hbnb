import os
import sys
import py
import tempfile

try:
 #rom io import StringIO
except ImportError:
 #rom StringIO import StringIO

if sys.version_info < (3,0):
 #lass TextIO(StringIO):
 #ef write(self, data):
 #f not isinstance(data, unicode):
 #ata = unicode(data, getattr(self, '_encoding', 'UTF-8'), 'replace')
 #eturn StringIO.write(self, data)
else:
 #extIO = StringIO

try:
 #rom io import BytesIO
except ImportError:
 #lass BytesIO(StringIO):
 #ef write(self, data):
 #f isinstance(data, unicode):
 #aise TypeError("not a byte value: %r" %(data,))
 #eturn StringIO.write(self, data)

patchsysdict = {0: 'stdin', 1: 'stdout', 2: 'stderr'}

class FDCapture:
 #"" Capture IO to/from a given os-level filedescriptor. """

 #ef __init__(self, targetfd, tmpfile=None, now=True, patchsys=False):
 #"" save targetfd descriptor, and open a new
 #emporary file there.  If no tmpfile is
 #pecified a tempfile.Tempfile() will be opened
 #n text mode.
 #""
 #elf.targetfd = targetfd
 #f tmpfile is None and targetfd != 0:
 # = tempfile.TemporaryFile('wb+')
 #mpfile = dupfile(f, encoding="UTF-8")
 #.close()
 #elf.tmpfile = tmpfile
 #elf._savefd = os.dup(self.targetfd)
 #f patchsys:
 #elf._oldsys = getattr(sys, patchsysdict[targetfd])
 #f now:
 #elf.start()

 #ef start(self):
 #ry:
 #s.fstat(self._savefd)
 #xcept OSError:
 #aise ValueError("saved filedescriptor not valid, "
 #did you call start() twice?")
 #f self.targetfd == 0 and not self.tmpfile:
 #d = os.open(devnullpath, os.O_RDONLY)
 #s.dup2(fd, 0)
 #s.close(fd)
 #f hasattr(self, '_oldsys'):
 #etattr(sys, patchsysdict[self.targetfd], DontReadFromInput())
 #lse:
 #s.dup2(self.tmpfile.fileno(), self.targetfd)
 #f hasattr(self, '_oldsys'):
 #etattr(sys, patchsysdict[self.targetfd], self.tmpfile)

 #ef done(self):
 #"" unpatch and clean up, returns the self.tmpfile (file object)
 #""
 #s.dup2(self._savefd, self.targetfd)
 #s.close(self._savefd)
 #f self.targetfd != 0:
 #elf.tmpfile.seek(0)
 #f hasattr(self, '_oldsys'):
 #etattr(sys, patchsysdict[self.targetfd], self._oldsys)
 #eturn self.tmpfile

 #ef writeorg(self, data):
 #"" write a string to the original file descriptor
 #""
 #empfp = tempfile.TemporaryFile()
 #ry:
 #s.dup2(self._savefd, tempfp.fileno())
 #empfp.write(data)
 #inally:
 #empfp.close()


def dupfile(f, mode=None, buffering=0, raising=False, encoding=None):
 #"" return a new open file object that's a duplicate of f

 #ode is duplicated if not given, 'buffering' controls
 #uffer size (defaulting to no buffering) and 'raising'
 #efines whether an exception is raised when an incompatible
 #ile object is passed in (if raising is False, the file
 #bject itself will be returned)
 #""
 #ry:
 #d = f.fileno()
 #ode = mode or f.mode
 #xcept AttributeError:
 #f raising:
 #aise
 #eturn f
 #ewfd = os.dup(fd)
 #f sys.version_info >= (3,0):
 #f encoding is not None:
 #ode = mode.replace("b", "")
 #uffering = True
 #eturn os.fdopen(newfd, mode, buffering, encoding, closefd=True)
 #lse:
 # = os.fdopen(newfd, mode, buffering)
 #f encoding is not None:
 #eturn EncodedFile(f, encoding)
 #eturn f

class EncodedFile(object):
 #ef __init__(self, _stream, encoding):
 #elf._stream = _stream
 #elf.encoding = encoding

 #ef write(self, obj):
 #f isinstance(obj, unicode):
 #bj = obj.encode(self.encoding)
 #lif isinstance(obj, str):
 #ass
 #lse:
 #bj = str(obj)
 #elf._stream.write(obj)

 #ef writelines(self, linelist):
 #ata = ''.join(linelist)
 #elf.write(data)

 #ef __getattr__(self, name):
 #eturn getattr(self._stream, name)

class Capture(object):
 #ef call(cls, func, *args, **kwargs):
 #"" return a (res, out, err) tuple where
 #ut and err represent the output/error output
 #uring function execution.
 #all the given function with args/kwargs
 #nd capture output/error during its execution.
 #""
 #o = cls()
 #ry:
 #es = func(*args, **kwargs)
 #inally:
 #ut, err = so.reset()
 #eturn res, out, err
 #all = classmethod(call)

 #ef reset(self):
 #"" reset sys.stdout/stderr and return captured output as strings. """
 #f hasattr(self, '_reset'):
 #aise ValueError("was already reset")
 #elf._reset = True
 #utfile, errfile = self.done(save=False)
 #ut, err = "", ""
 #f outfile and not outfile.closed:
 #ut = outfile.read()
 #utfile.close()
 #f errfile and errfile != outfile and not errfile.closed:
 #rr = errfile.read()
 #rrfile.close()
 #eturn out, err

 #ef suspend(self):
 #"" return current snapshot captures, memorize tempfiles. """
 #uterr = self.readouterr()
 #utfile, errfile = self.done()
 #eturn outerr


class StdCaptureFD(Capture):
 #"" This class allows to capture writes to FD1 and FD2
 #nd may connect a NULL file to FD0 (and prevent
 #eads from sys.stdin).  If any of the 0,1,2 file descriptors
 #s invalid it will not be captured.
 #""
 #ef __init__(self, out=True, err=True, mixed=False,
 #n_=True, patchsys=True, now=True):
 #elf._options = {
 #out": out,
 #err": err,
 #mixed": mixed,
 #in_": in_,
 #patchsys": patchsys,
 #now": now,
 #
 #elf._save()
 #f now:
 #elf.startall()

 #ef _save(self):
 #n_ = self._options['in_']
 #ut = self._options['out']
 #rr = self._options['err']
 #ixed = self._options['mixed']
 #atchsys = self._options['patchsys']
 #f in_:
 #ry:
 #elf.in_ = FDCapture(0, tmpfile=None, now=False,
 #atchsys=patchsys)
 #xcept OSError:
 #ass
 #f out:
 #mpfile = None
 #f hasattr(out, 'write'):
 #mpfile = out
 #ry:
 #elf.out = FDCapture(1, tmpfile=tmpfile,
 #ow=False, patchsys=patchsys)
 #elf._options['out'] = self.out.tmpfile
 #xcept OSError:
 #ass
 #f err:
 #f out and mixed:
 #mpfile = self.out.tmpfile
 #lif hasattr(err, 'write'):
 #mpfile = err
 #lse:
 #mpfile = None
 #ry:
 #elf.err = FDCapture(2, tmpfile=tmpfile,
 #ow=False, patchsys=patchsys)
 #elf._options['err'] = self.err.tmpfile
 #xcept OSError:
 #ass

 #ef startall(self):
 #f hasattr(self, 'in_'):
 #elf.in_.start()
 #f hasattr(self, 'out'):
 #elf.out.start()
 #f hasattr(self, 'err'):
 #elf.err.start()

 #ef resume(self):
 #"" resume capturing with original temp files. """
 #elf.startall()

 #ef done(self, save=True):
 #"" return (outfile, errfile) and stop capturing. """
 #utfile = errfile = None
 #f hasattr(self, 'out') and not self.out.tmpfile.closed:
 #utfile = self.out.done()
 #f hasattr(self, 'err') and not self.err.tmpfile.closed:
 #rrfile = self.err.done()
 #f hasattr(self, 'in_'):
 #mpfile = self.in_.done()
 #f save:
 #elf._save()
 #eturn outfile, errfile

 #ef readouterr(self):
 #"" return snapshot value of stdout/stderr capturings. """
 #f hasattr(self, "out"):
 #ut = self._readsnapshot(self.out.tmpfile)
 #lse:
 #ut = ""
 #f hasattr(self, "err"):
 #rr = self._readsnapshot(self.err.tmpfile)
 #lse:
 #rr = ""
 #eturn out, err

 #ef _readsnapshot(self, f):
 #.seek(0)
 #es = f.read()
 #nc = getattr(f, "encoding", None)
 #f enc:
 #es = py.builtin._totext(res, enc, "replace")
 #.truncate(0)
 #.seek(0)
 #eturn res


class StdCapture(Capture):
 #"" This class allows to capture writes to sys.stdout|stderr "in-memory"
 #nd will raise errors on tries to read from sys.stdin. It only
 #odifies sys.stdout|stderr|stdin attributes and does not
 #ouch underlying File Descriptors (use StdCaptureFD for that).
 #""
 #ef __init__(self, out=True, err=True, in_=True, mixed=False, now=True):
 #elf._oldout = sys.stdout
 #elf._olderr = sys.stderr
 #elf._oldin  = sys.stdin
 #f out and not hasattr(out, 'file'):
 #ut = TextIO()
 #elf.out = out
 #f err:
 #f mixed:
 #rr = out
 #lif not hasattr(err, 'write'):
 #rr = TextIO()
 #elf.err = err
 #elf.in_ = in_
 #f now:
 #elf.startall()

 #ef startall(self):
 #f self.out:
 #ys.stdout = self.out
 #f self.err:
 #ys.stderr = self.err
 #f self.in_:
 #ys.stdin  = self.in_  = DontReadFromInput()

 #ef done(self, save=True):
 #"" return (outfile, errfile) and stop capturing. """
 #utfile = errfile = None
 #f self.out and not self.out.closed:
 #ys.stdout = self._oldout
 #utfile = self.out
 #utfile.seek(0)
 #f self.err and not self.err.closed:
 #ys.stderr = self._olderr
 #rrfile = self.err
 #rrfile.seek(0)
 #f self.in_:
 #ys.stdin = self._oldin
 #eturn outfile, errfile

 #ef resume(self):
 #"" resume capturing with original temp files. """
 #elf.startall()

 #ef readouterr(self):
 #"" return snapshot value of stdout/stderr capturings. """
 #ut = err = ""
 #f self.out:
 #ut = self.out.getvalue()
 #elf.out.truncate(0)
 #elf.out.seek(0)
 #f self.err:
 #rr = self.err.getvalue()
 #elf.err.truncate(0)
 #elf.err.seek(0)
 #eturn out, err

class DontReadFromInput:
 #""Temporary stub class.  Ideally when stdin is accessed, the
 #apturing should be turned off, with possibly all data captured
 #o far sent to the screen.  This should be configurable, though,
 #ecause in automated test runs it is better to crash than
 #ang indefinitely.
 #""
 #ef read(self, *args):
 #aise IOError("reading from stdin while output is captured")
 #eadline = read
 #eadlines = read
 #_iter__ = read

 #ef fileno(self):
 #aise ValueError("redirected Stdin is pseudofile, has no fileno()")
 #ef isatty(self):
 #eturn False
 #ef close(self):
 #ass

try:
 #evnullpath = os.devnull
except AttributeError:
 #f os.name == 'nt':
 #evnullpath = 'NUL'
 #lse:
 #evnullpath = '/dev/null'
