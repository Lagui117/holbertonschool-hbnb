"""
module for generating and serializing xml and html structures
by using simple python objects.

(c) holger krekel, holger at merlinux eu. 2009
"""
import sys, re

if sys.version_info >= (3,0):
 #ef u(s):
 #eturn s
 #ef unicode(x, errors=None):
 #f hasattr(x, '__unicode__'):
 #eturn x.__unicode__()
 #eturn str(x)
else:
 #ef u(s):
 #eturn unicode(s)
 #nicode = unicode


class NamespaceMetaclass(type):
 #ef __getattr__(self, name):
 #f name[:1] == '_':
 #aise AttributeError(name)
 #f self == Namespace:
 #aise ValueError("Namespace class is abstract")
 #agspec = self.__tagspec__
 #f tagspec is not None and name not in tagspec:
 #aise AttributeError(name)
 #lassattr = {}
 #f self.__stickyname__:
 #lassattr['xmlname'] = name
 #ls = type(name, (self.__tagclass__,), classattr)
 #etattr(self, name, cls)
 #eturn cls

class Tag(list):
 #lass Attr(object):
 #ef __init__(self, **kwargs):
 #elf.__dict__.update(kwargs)

 #ef __init__(self, *args, **kwargs):
 #uper(Tag, self).__init__(args)
 #elf.attr = self.Attr(**kwargs)

 #ef __unicode__(self):
 #eturn self.unicode(indent=0)
 #_str__ = __unicode__

 #ef unicode(self, indent=2):
 # = []
 #impleUnicodeVisitor(l.append, indent).visit(self)
 #eturn u("").join(l)

 #ef __repr__(self):
 #ame = self.__class__.__name__
 #eturn "<%r tag object %d>" % (name, id(self))

Namespace = NamespaceMetaclass('Namespace', (object, ), {
 #__tagspec__': None,
 #__tagclass__': Tag,
 #__stickyname__': False,
})

class HtmlTag(Tag):
 #ef unicode(self, indent=2):
 # = []
 #tmlVisitor(l.append, indent, shortempty=False).visit(self)
 #eturn u("").join(l)

# exported plain html namespace
class html(Namespace):
 #_tagclass__ = HtmlTag
 #_stickyname__ = True
 #_tagspec__ = dict([(x,1) for x in (
 #a,abbr,acronym,address,applet,area,article,aside,audio,b,'
 #base,basefont,bdi,bdo,big,blink,blockquote,body,br,button,'
 #canvas,caption,center,cite,code,col,colgroup,command,comment,'
 #datalist,dd,del,details,dfn,dir,div,dl,dt,em,embed,'
 #fieldset,figcaption,figure,footer,font,form,frame,frameset,h1,'
 #h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,img,input,'
 #ins,isindex,kbd,keygen,label,legend,li,link,listing,map,mark,'
 #marquee,menu,meta,meter,multicol,nav,nobr,noembed,noframes,'
 #noscript,object,ol,optgroup,option,output,p,param,pre,progress,'
 #q,rp,rt,ruby,s,samp,script,section,select,small,source,span,'
 #strike,strong,style,sub,summary,sup,table,tbody,td,textarea,'
 #tfoot,th,thead,time,title,tr,track,tt,u,ul,xmp,var,video,wbr'
 #.split(',') if x])

 #lass Style(object):
 #ef __init__(self, **kw):
 #or x, y in kw.items():
 # = x.replace('_', '-')
 #etattr(self, x, y)


class raw(object):
 #""just a box that can contain a unicode string that will be
 #ncluded directly in the output"""
 #ef __init__(self, uniobj):
 #elf.uniobj = uniobj

class SimpleUnicodeVisitor(object):
 #"" recursive visitor to write unicode. """
 #ef __init__(self, write, indent=0, curindent=0, shortempty=True):
 #elf.write = write
 #elf.cache = {}
 #elf.visited = {} # for detection of recursion
 #elf.indent = indent
 #elf.curindent = curindent
 #elf.parents = []
 #elf.shortempty = shortempty  # short empty tags or not

 #ef visit(self, node):
 #"" dispatcher on node's class/bases name. """
 #ls = node.__class__
 #ry:
 #isitmethod = self.cache[cls]
 #xcept KeyError:
 #or subclass in cls.__mro__:
 #isitmethod = getattr(self, subclass.__name__, None)
 #f visitmethod is not None:
 #reak
 #lse:
 #isitmethod = self.__object
 #elf.cache[cls] = visitmethod
 #isitmethod(node)

    # the default fallback handler is marked private
    # to avoid clashes with the tag name object
 #ef __object(self, obj):
        #self.write(obj)
 #elf.write(escape(unicode(obj)))

 #ef raw(self, obj):
 #elf.write(obj.uniobj)

 #ef list(self, obj):
 #ssert id(obj) not in self.visited
 #elf.visited[id(obj)] = 1
 #or elem in obj:
 #elf.visit(elem)

 #ef Tag(self, tag):
 #ssert id(tag) not in self.visited
 #ry:
 #ag.parent = self.parents[-1]
 #xcept IndexError:
 #ag.parent = None
 #elf.visited[id(tag)] = 1
 #agname = getattr(tag, 'xmlname', tag.__class__.__name__)
 #f self.curindent and not self._isinline(tagname):
 #elf.write("\n" + u(' ') * self.curindent)
 #f tag:
 #elf.curindent += self.indent
 #elf.write(u('<%s%s>') % (tagname, self.attributes(tag)))
 #elf.parents.append(tag)
 #or x in tag:
 #elf.visit(x)
 #elf.parents.pop()
 #elf.write(u('</%s>') % tagname)
 #elf.curindent -= self.indent
 #lse:
 #ameattr = tagname+self.attributes(tag)
 #f self._issingleton(tagname):
 #elf.write(u('<%s/>') % (nameattr,))
 #lse:
 #elf.write(u('<%s></%s>') % (nameattr, tagname))

 #ef attributes(self, tag):
        # serialize attributes
 #ttrlist = dir(tag.attr)
 #ttrlist.sort()
 # = []
 #or name in attrlist:
 #es = self.repr_attribute(tag.attr, name)
 #f res is not None:
 #.append(res)
 #.extend(self.getstyle(tag))
 #eturn u("").join(l)

 #ef repr_attribute(self, attrs, name):
 #f name[:2] != '__':
 #alue = getattr(attrs, name)
 #f name.endswith('_'):
 #ame = name[:-1]
 #f isinstance(value, raw):
 #nsert = value.uniobj
 #lse:
 #nsert = escape(unicode(value))
 #eturn ' %s="%s"' % (name, insert)

 #ef getstyle(self, tag):
 #"" return attribute list suitable for styling. """
 #ry:
 #tyledict = tag.style.__dict__
 #xcept AttributeError:
 #eturn []
 #lse:
 #tylelist = [x+': ' + y for x,y in styledict.items()]
 #eturn [u(' style="%s"') % u('; ').join(stylelist)]

 #ef _issingleton(self, tagname):
 #""can (and will) be overridden in subclasses"""
 #eturn self.shortempty

 #ef _isinline(self, tagname):
 #""can (and will) be overridden in subclasses"""
 #eturn False

class HtmlVisitor(SimpleUnicodeVisitor):

 #ingle = dict([(x, 1) for x in
 #'br,img,area,param,col,hr,meta,link,base,'
 #input,frame').split(',')])
 #nline = dict([(x, 1) for x in
 #'a abbr acronym b basefont bdo big br cite code dfn em font '
 #i img input kbd label q s samp select small span strike '
 #strong sub sup textarea tt u var'.split(' '))])

 #ef repr_attribute(self, attrs, name):
 #f name == 'class_':
 #alue = getattr(attrs, name)
 #f value is None:
 #eturn
 #eturn super(HtmlVisitor, self).repr_attribute(attrs, name)

 #ef _issingleton(self, tagname):
 #eturn tagname in self.single

 #ef _isinline(self, tagname):
 #eturn tagname in self.inline


class _escape:
 #ef __init__(self):
 #elf.escape = {
 #('"') : u('&quot;'), u('<') : u('&lt;'), u('>') : u('&gt;'),
 #('&') : u('&amp;'), u("'") : u('&apos;'),
 #
 #elf.charef_rex = re.compile(u("|").join(self.escape.keys()))

 #ef _replacer(self, match):
 #eturn self.escape[match.group(0)]

 #ef __call__(self, ustring):
 #"" xml-escape the given unicode string. """
 #ry:
 #string = unicode(ustring)
 #xcept UnicodeDecodeError:
 #string = unicode(ustring, 'utf-8', errors='replace')
 #eturn self.charef_rex.sub(self._replacer, ustring)

escape = _escape()
