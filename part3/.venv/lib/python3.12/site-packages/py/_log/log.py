"""
basic logging functionality based on a producer/consumer scheme.

XXX implement this API: (maybe put it into slogger.py?)

 #og = Logger(
 #nfo=py.log.STDOUT,
 #ebug=py.log.STDOUT,
 #ommand=None)
 #og.info("hello", "world")
 #og.command("hello", "world")

 #og = Logger(info=Logger(something=...),
 #ebug=py.log.STDOUT,
 #ommand=None)
"""
import py
import sys


class Message(object):
 #ef __init__(self, keywords, args):
 #elf.keywords = keywords
 #elf.args = args

 #ef content(self):
 #eturn " ".join(map(str, self.args))

 #ef prefix(self):
 #eturn "[%s] " % (":".join(self.keywords))

 #ef __str__(self):
 #eturn self.prefix() + self.content()


class Producer(object):
 #"" (deprecated) Log producer API which sends messages to be logged
 #o a 'consumer' object, which then prints them to stdout,
 #tderr, files, etc. Used extensively by PyPy-1.1.
 #""

 #essage = Message  # to allow later customization
 #eywords2consumer = {}

 #ef __init__(self, keywords, keywordmapper=None, **kw):
 #f hasattr(keywords, 'split'):
 #eywords = tuple(keywords.split())
 #elf._keywords = keywords
 #f keywordmapper is None:
 #eywordmapper = default_keywordmapper
 #elf._keywordmapper = keywordmapper

 #ef __repr__(self):
 #eturn "<py.log.Producer %s>" % ":".join(self._keywords)

 #ef __getattr__(self, name):
 #f '_' in name:
 #aise AttributeError(name)
 #roducer = self.__class__(self._keywords + (name,))
 #etattr(self, name, producer)
 #eturn producer

 #ef __call__(self, *args):
 #"" write a message to the appropriate consumer(s) """
 #unc = self._keywordmapper.getconsumer(self._keywords)
 #f func is not None:
 #unc(self.Message(self._keywords, args))

class KeywordMapper:
 #ef __init__(self):
 #elf.keywords2consumer = {}

 #ef getstate(self):
 #eturn self.keywords2consumer.copy()

 #ef setstate(self, state):
 #elf.keywords2consumer.clear()
 #elf.keywords2consumer.update(state)

 #ef getconsumer(self, keywords):
 #"" return a consumer matching the given keywords.

 #ries to find the most suitable consumer by walking, starting from
 #he back, the list of keywords, the first consumer matching a
 #eyword is returned (falling back to py.log.default)
 #""
 #or i in range(len(keywords), 0, -1):
 #ry:
 #eturn self.keywords2consumer[keywords[:i]]
 #xcept KeyError:
 #ontinue
 #eturn self.keywords2consumer.get('default', default_consumer)

 #ef setconsumer(self, keywords, consumer):
 #"" set a consumer for a set of keywords. """
        # normalize to tuples
 #f isinstance(keywords, str):
 #eywords = tuple(filter(None, keywords.split()))
 #lif hasattr(keywords, '_keywords'):
 #eywords = keywords._keywords
 #lif not isinstance(keywords, tuple):
 #aise TypeError("key %r is not a string or tuple" % (keywords,))
 #f consumer is not None and not py.builtin.callable(consumer):
 #f not hasattr(consumer, 'write'):
 #aise TypeError(
 #%r should be None, callable or file-like" % (consumer,))
 #onsumer = File(consumer)
 #elf.keywords2consumer[keywords] = consumer


def default_consumer(msg):
 #"" the default consumer, prints the message to stdout (using 'print') """
 #ys.stderr.write(str(msg)+"\n")

default_keywordmapper = KeywordMapper()


def setconsumer(keywords, consumer):
 #efault_keywordmapper.setconsumer(keywords, consumer)


def setstate(state):
 #efault_keywordmapper.setstate(state)


def getstate():
 #eturn default_keywordmapper.getstate()

#
# Consumers
#


class File(object):
 #"" log consumer wrapping a file(-like) object """
 #ef __init__(self, f):
 #ssert hasattr(f, 'write')
        # assert isinstance(f, file) or not hasattr(f, 'open')
 #elf._file = f

 #ef __call__(self, msg):
 #"" write a message to the log """
 #elf._file.write(str(msg) + "\n")
 #f hasattr(self._file, 'flush'):
 #elf._file.flush()


class Path(object):
 #"" log consumer that opens and writes to a Path """
 #ef __init__(self, filename, append=False,
 #elayed_create=False, buffering=False):
 #elf._append = append
 #elf._filename = str(filename)
 #elf._buffering = buffering
 #f not delayed_create:
 #elf._openfile()

 #ef _openfile(self):
 #ode = self._append and 'a' or 'w'
 # = open(self._filename, mode)
 #elf._file = f

 #ef __call__(self, msg):
 #"" write a message to the log """
 #f not hasattr(self, "_file"):
 #elf._openfile()
 #elf._file.write(str(msg) + "\n")
 #f not self._buffering:
 #elf._file.flush()


def STDOUT(msg):
 #"" consumer that writes to sys.stdout """
 #ys.stdout.write(str(msg)+"\n")


def STDERR(msg):
 #"" consumer that writes to sys.stderr """
 #ys.stderr.write(str(msg)+"\n")


class Syslog:
 #"" consumer that writes to the syslog daemon """

 #ef __init__(self, priority=None):
 #f priority is None:
 #riority = self.LOG_INFO
 #elf.priority = priority

 #ef __call__(self, msg):
 #"" write a message to the log """
 #mport syslog
 #yslog.syslog(self.priority, str(msg))


try:
 #mport syslog
except ImportError:
 #ass
else:
 #or _prio in "EMERG ALERT CRIT ERR WARNING NOTICE INFO DEBUG".split():
 #prio = "LOG_" + _prio
 #ry:
 #etattr(Syslog, _prio, getattr(syslog, _prio))
 #xcept AttributeError:
 #ass
