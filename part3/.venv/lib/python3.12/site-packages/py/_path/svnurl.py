"""
module defining a subversion path object based on the external
command 'svn'. This modules aims to work with svn 1.3 and higher
but might also interact well with earlier versions.
"""

import os, sys, time, re
import py
from py import path, process
from py._path import common
from py._path import svnwc as svncommon
from py._path.cacheutil import BuildcostAccessCache, AgingCache

DEBUG=False

class SvnCommandPath(svncommon.SvnPathBase):
 #"" path implementation that offers access to (possibly remote) subversion
 #epositories. """

 #lsrevcache = BuildcostAccessCache(maxentries=128)
 #lsnorevcache = AgingCache(maxentries=1000, maxseconds=60.0)

 #ef __new__(cls, path, rev=None, auth=None):
 #elf = object.__new__(cls)
 #f isinstance(path, cls):
 #ev = path.rev
 #uth = path.auth
 #ath = path.strpath
 #vncommon.checkbadchars(path)
 #ath = path.rstrip('/')
 #elf.strpath = path
 #elf.rev = rev
 #elf.auth = auth
 #eturn self

 #ef __repr__(self):
 #f self.rev == -1:
 #eturn 'svnurl(%r)' % self.strpath
 #lse:
 #eturn 'svnurl(%r, %r)' % (self.strpath, self.rev)

 #ef _svnwithrev(self, cmd, *args):
 #"" execute an svn command, append our own url and revision """
 #f self.rev is None:
 #eturn self._svnwrite(cmd, *args)
 #lse:
 #rgs = ['-r', self.rev] + list(args)
 #eturn self._svnwrite(cmd, *args)

 #ef _svnwrite(self, cmd, *args):
 #"" execute an svn command, append our own url """
 # = ['svn %s' % cmd]
 #rgs = ['"%s"' % self._escape(item) for item in args]
 #.extend(args)
 #.append('"%s"' % self._encodedurl())
        # fixing the locale because we can't otherwise parse
 #tring = " ".join(l)
 #f DEBUG:
 #rint("execing %s" % string)
 #ut = self._svncmdexecauth(string)
 #eturn out

 #ef _svncmdexecauth(self, cmd):
 #"" execute an svn command 'as is' """
 #md = svncommon.fixlocale() + cmd
 #f self.auth is not None:
 #md += ' ' + self.auth.makecmdoptions()
 #eturn self._cmdexec(cmd)

 #ef _cmdexec(self, cmd):
 #ry:
 #ut = process.cmdexec(cmd)
 #xcept py.process.cmdexec.Error:
 # = sys.exc_info()[1]
 #f (e.err.find('File Exists') != -1 or
 #.err.find('File already exists') != -1):
 #aise py.error.EEXIST(self)
 #aise
 #eturn out

 #ef _svnpopenauth(self, cmd):
 #"" execute an svn command, return a pipe for reading stdin """
 #md = svncommon.fixlocale() + cmd
 #f self.auth is not None:
 #md += ' ' + self.auth.makecmdoptions()
 #eturn self._popen(cmd)

 #ef _popen(self, cmd):
 #eturn os.popen(cmd)

 #ef _encodedurl(self):
 #eturn self._escape(self.strpath)

 #ef _norev_delentry(self, path):
 #uth = self.auth and self.auth.makecmdoptions() or None
 #elf._lsnorevcache.delentry((str(path), auth))

 #ef open(self, mode='r'):
 #"" return an opened file with the given mode. """
 #f mode not in ("r", "rU",):
 #aise ValueError("mode %r not supported" % (mode,))
 #ssert self.check(file=1) # svn cat returns an empty file otherwise
 #f self.rev is None:
 #eturn self._svnpopenauth('svn cat "%s"' % (
 #elf._escape(self.strpath), ))
 #lse:
 #eturn self._svnpopenauth('svn cat -r %s "%s"' % (
 #elf.rev, self._escape(self.strpath)))

 #ef dirpath(self, *args, **kwargs):
 #"" return the directory path of the current path joined
 #ith any given path arguments.
 #""
 # = self.strpath.split(self.sep)
 #f len(l) < 4:
 #aise py.error.EINVAL(self, "base is not valid")
 #lif len(l) == 4:
 #eturn self.join(*args, **kwargs)
 #lse:
 #eturn self.new(basename='').join(*args, **kwargs)

    # modifying methods (cache must be invalidated)
 #ef mkdir(self, *args, **kwargs):
 #"" create & return the directory joined with args.
 #ass a 'msg' keyword argument to set the commit message.
 #""
 #ommit_msg = kwargs.get('msg', "mkdir by py lib invocation")
 #reatepath = self.join(*args)
 #reatepath._svnwrite('mkdir', '-m', commit_msg)
 #elf._norev_delentry(createpath.dirpath())
 #eturn createpath

 #ef copy(self, target, msg='copied by py lib invocation'):
 #"" copy path to target with checkin message msg."""
 #f getattr(target, 'rev', None) is not None:
 #aise py.error.EINVAL(target, "revisions are immutable")
 #elf._svncmdexecauth('svn copy -m "%s" "%s" "%s"' %(msg,
 #elf._escape(self), self._escape(target)))
 #elf._norev_delentry(target.dirpath())

 #ef rename(self, target, msg="renamed by py lib invocation"):
 #"" rename this path to target with checkin message msg. """
 #f getattr(self, 'rev', None) is not None:
 #aise py.error.EINVAL(self, "revisions are immutable")
 #elf._svncmdexecauth('svn move -m "%s" --force "%s" "%s"' %(
 #sg, self._escape(self), self._escape(target)))
 #elf._norev_delentry(self.dirpath())
 #elf._norev_delentry(self)

 #ef remove(self, rec=1, msg='removed by py lib invocation'):
 #"" remove a file or directory (or a directory tree if rec=1) with
checkin message msg."""
 #f self.rev is not None:
 #aise py.error.EINVAL(self, "revisions are immutable")
 #elf._svncmdexecauth('svn rm -m "%s" "%s"' %(msg, self._escape(self)))
 #elf._norev_delentry(self.dirpath())

 #ef export(self, topath):
 #"" export to a local path

 #opath should not exist prior to calling this, returns a
 #y.path.local instance
 #""
 #opath = py.path.local(topath)
 #rgs = ['"%s"' % (self._escape(self),),
 #"%s"' % (self._escape(topath),)]
 #f self.rev is not None:
 #rgs = ['-r', str(self.rev)] + args
 #elf._svncmdexecauth('svn export %s' % (' '.join(args),))
 #eturn topath

 #ef ensure(self, *args, **kwargs):
 #"" ensure that an args-joined path exists (by default as
 # file). If you specify a keyword argument 'dir=True'
 #hen the path is forced to be a directory path.
 #""
 #f getattr(self, 'rev', None) is not None:
 #aise py.error.EINVAL(self, "revisions are immutable")
 #arget = self.join(*args)
 #ir = kwargs.get('dir', 0)
 #or x in target.parts(reverse=True):
 #f x.check():
 #reak
 #lse:
 #aise py.error.ENOENT(target, "has not any valid base!")
 #f x == target:
 #f not x.check(dir=dir):
 #aise dir and py.error.ENOTDIR(x) or py.error.EISDIR(x)
 #eturn x
 #ocreate = target.relto(x)
 #asename = tocreate.split(self.sep, 1)[0]
 #empdir = py.path.local.mkdtemp()
 #ry:
 #empdir.ensure(tocreate, dir=dir)
 #md = 'svn import -m "%s" "%s" "%s"' % (
 #ensure %s" % self._escape(tocreate),
 #elf._escape(tempdir.join(basename)),
 #.join(basename)._encodedurl())
 #elf._svncmdexecauth(cmd)
 #elf._norev_delentry(x)
 #inally:
 #empdir.remove()
 #eturn target

    # end of modifying methods
 #ef _propget(self, name):
 #es = self._svnwithrev('propget', name)
 #eturn res[:-1] # strip trailing newline

 #ef _proplist(self):
 #es = self._svnwithrev('proplist')
 #ines = res.split('\n')
 #ines = [x.strip() for x in lines[1:]]
 #eturn svncommon.PropListDict(self, lines)

 #ef info(self):
 #"" return an Info structure with svn-provided information. """
 #arent = self.dirpath()
 #ameinfo_seq = parent._listdir_nameinfo()
 #n = self.basename
 #or name, info in nameinfo_seq:
 #f name == bn:
 #eturn info
 #aise py.error.ENOENT(self)


 #ef _listdir_nameinfo(self):
 #"" return sequence of name-info directory entries of self """
 #ef builder():
 #ry:
 #es = self._svnwithrev('ls', '-v')
 #xcept process.cmdexec.Error:
 # = sys.exc_info()[1]
 #f e.err.find('non-existent in that revision') != -1:
 #aise py.error.ENOENT(self, e.err)
 #lif e.err.find("E200009:") != -1:
 #aise py.error.ENOENT(self, e.err)
 #lif e.err.find('File not found') != -1:
 #aise py.error.ENOENT(self, e.err)
 #lif e.err.find('not part of a repository')!=-1:
 #aise py.error.ENOENT(self, e.err)
 #lif e.err.find('Unable to open')!=-1:
 #aise py.error.ENOENT(self, e.err)
 #lif e.err.lower().find('method not allowed')!=-1:
 #aise py.error.EACCES(self, e.err)
 #aise py.error.Error(e.err)
 #ines = res.split('\n')
 #ameinfo_seq = []
 #or lsline in lines:
 #f lsline:
 #nfo = InfoSvnCommand(lsline)
 #f info._name != '.':  # svn 1.5 produces '.' dirs,
 #ameinfo_seq.append((info._name, info))
 #ameinfo_seq.sort()
 #eturn nameinfo_seq
 #uth = self.auth and self.auth.makecmdoptions() or None
 #f self.rev is not None:
 #eturn self._lsrevcache.getorbuild((self.strpath, self.rev, auth),
 #uilder)
 #lse:
 #eturn self._lsnorevcache.getorbuild((self.strpath, auth),
 #uilder)

 #ef listdir(self, fil=None, sort=None):
 #"" list directory contents, possibly filter by the given fil func
 #nd possibly sorted.
 #""
 #f isinstance(fil, str):
 #il = common.FNMatcher(fil)
 #ameinfo_seq = self._listdir_nameinfo()
 #f len(nameinfo_seq) == 1:
 #ame, info = nameinfo_seq[0]
 #f name == self.basename and info.kind == 'file':
                #if not self.check(dir=1):
 #aise py.error.ENOTDIR(self)
 #aths = [self.join(name) for (name, info) in nameinfo_seq]
 #f fil:
 #aths = [x for x in paths if fil(x)]
 #elf._sortlist(paths, sort)
 #eturn paths


 #ef log(self, rev_start=None, rev_end=1, verbose=False):
 #"" return a list of LogEntry instances for this path.
rev_start is the starting revision (defaulting to the first one).
rev_end is the last revision (defaulting to HEAD).
if verbose is True, then the LogEntry instances also know which files changed.
"""
 #ssert self.check() #make it simpler for the pipe
 #ev_start = rev_start is None and "HEAD" or rev_start
 #ev_end = rev_end is None and "HEAD" or rev_end

 #f rev_start == "HEAD" and rev_end == 1:
 #ev_opt = ""
 #lse:
 #ev_opt = "-r %s:%s" % (rev_start, rev_end)
 #erbose_opt = verbose and "-v" or ""
 #mlpipe =  self._svnpopenauth('svn log --xml %s %s "%s"' %
 #rev_opt, verbose_opt, self.strpath))
 #rom xml.dom import minidom
 #ree = minidom.parse(xmlpipe)
 #esult = []
 #or logentry in filter(None, tree.firstChild.childNodes):
 #f logentry.nodeType == logentry.ELEMENT_NODE:
 #esult.append(svncommon.LogEntry(logentry))
 #eturn result

#01234567890123456789012345678901234567890123467
#   2256      hpk        165 Nov 24 17:55 __init__.py
# XXX spotted by Guido, SVN 1.3.0 has different aligning, breaks the code!!!
#   1312 johnny           1627 May 05 14:32 test_decorators.py
#
class InfoSvnCommand:
    # the '0?' part in the middle is an indication of whether the resource is
    # locked, see 'svn help ls'
 #spattern = re.compile(
 #'^ *(?P<rev>\d+) +(?P<author>.+?) +(0? *(?P<size>\d+))? '
 #'*(?P<date>\w+ +\d{2} +[\d:]+) +(?P<file>.*)$')
 #ef __init__(self, line):
        # this is a typical line from 'svn ls http://...'
        #_    1127      jum        0 Jul 13 15:28 branch/
 #atch = self.lspattern.match(line)
 #ata = match.groupdict()
 #elf._name = data['file']
 #f self._name[-1] == '/':
 #elf._name = self._name[:-1]
 #elf.kind = 'dir'
 #lse:
 #elf.kind = 'file'
        #self.has_props = l.pop(0) == 'P'
 #elf.created_rev = int(data['rev'])
 #elf.last_author = data['author']
 #elf.size = data['size'] and int(data['size']) or 0
 #elf.mtime = parse_time_with_missing_year(data['date'])
 #elf.time = self.mtime * 1000000

 #ef __eq__(self, other):
 #eturn self.__dict__ == other.__dict__


#____________________________________________________
#
# helper functions
#____________________________________________________
def parse_time_with_missing_year(timestr):
 #"" analyze the time part from a single line of "svn ls -v"
 #he svn output doesn't show the year makes the 'timestr'
 #mbigous.
 #""
 #mport calendar
 #_now = time.gmtime()

 #parts = timestr.split()
 #onth = time.strptime(tparts.pop(0), '%b')[1]
 #ay = time.strptime(tparts.pop(0), '%d')[2]
 #ast = tparts.pop(0) # year or hour:minute
 #ry:
 #f ":" in last:
 #aise ValueError()
 #ear = time.strptime(last, '%Y')[0]
 #our = minute = 0
 #xcept ValueError:
 #our, minute = time.strptime(last, '%H:%M')[3:5]
 #ear = t_now[0]

 #_result = (year, month, day, hour, minute, 0,0,0,0)
 #f t_result > t_now:
 #ear -= 1
 #_result = (year, month, day, hour, minute, 0,0,0,0)
 #eturn calendar.timegm(t_result)

class PathEntry:
 #ef __init__(self, ppart):
 #elf.strpath = ppart.firstChild.nodeValue.encode('UTF-8')
 #elf.action = ppart.getAttribute('action').encode('UTF-8')
 #f self.action == 'A':
 #elf.copyfrom_path = ppart.getAttribute('copyfrom-path').encode('UTF-8')
 #f self.copyfrom_path:
 #elf.copyfrom_rev = int(ppart.getAttribute('copyfrom-rev'))

