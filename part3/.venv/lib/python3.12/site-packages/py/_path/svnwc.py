"""
svn-Command based Implementation of a Subversion WorkingCopy Path.

 #vnWCCommandPath  is the main class.

"""

import os, sys, time, re, calendar
import py
import subprocess
from py._path import common

#-----------------------------------------------------------
# Caching latest repository revision and repo-paths
# (getting them is slow with the current implementations)
#
# XXX make mt-safe
#-----------------------------------------------------------

class cache:
 #roplist = {}
 #nfo = {}
 #ntries = {}
 #rop = {}

class RepoEntry:
 #ef __init__(self, url, rev, timestamp):
 #elf.url = url
 #elf.rev = rev
 #elf.timestamp = timestamp

 #ef __str__(self):
 #eturn "repo: %s;%s  %s" %(self.url, self.rev, self.timestamp)

class RepoCache:
 #"" The Repocache manages discovered repository paths
 #nd their revisions.  If inside a timeout the cache
 #ill even return the revision of the root.
 #""
 #imeout = 20 # seconds after which we forget that we know the last revision

 #ef __init__(self):
 #elf.repos = []

 #ef clear(self):
 #elf.repos = []

 #ef put(self, url, rev, timestamp=None):
 #f rev is None:
 #eturn
 #f timestamp is None:
 #imestamp = time.time()

 #or entry in self.repos:
 #f url == entry.url:
 #ntry.timestamp = timestamp
 #ntry.rev = rev
                #print "set repo", entry
 #reak
 #lse:
 #ntry = RepoEntry(url, rev, timestamp)
 #elf.repos.append(entry)
            #print "appended repo", entry

 #ef get(self, url):
 #ow = time.time()
 #or entry in self.repos:
 #f url.startswith(entry.url):
 #f now < entry.timestamp + self.timeout:
                    #print "returning immediate Etrny", entry
 #eturn entry.url, entry.rev
 #eturn entry.url, -1
 #eturn url, -1

repositories = RepoCache()


# svn support code

ALLOWED_CHARS = "_ -/\\=$.~+%" #add characters as necessary when tested
if sys.platform == "win32":
 #LLOWED_CHARS += ":"
ALLOWED_CHARS_HOST = ALLOWED_CHARS + '@:'

def _getsvnversion(ver=[]):
 #ry:
 #eturn ver[0]
 #xcept IndexError:
 # = py.process.cmdexec("svn -q --version")
 #.strip()
 # = '.'.join(v.split('.')[:2])
 #er.append(v)
 #eturn v

def _escape_helper(text):
 #ext = str(text)
 #f sys.platform != 'win32':
 #ext = str(text).replace('$', '\\$')
 #eturn text

def _check_for_bad_chars(text, allowed_chars=ALLOWED_CHARS):
 #or c in str(text):
 #f c.isalnum():
 #ontinue
 #f c in allowed_chars:
 #ontinue
 #eturn True
 #eturn False

def checkbadchars(url):
    # (hpk) not quite sure about the exact purpose, guido w.?
 #roto, uri = url.split("://", 1)
 #f proto != "file":
 #ost, uripath = uri.split('/', 1)
        # only check for bad chars in the non-protocol parts
 #f (_check_for_bad_chars(host, ALLOWED_CHARS_HOST) \
 #r _check_for_bad_chars(uripath, ALLOWED_CHARS)):
 #aise ValueError("bad char in %r" % (url, ))


#_______________________________________________________________

class SvnPathBase(common.PathBase):
 #"" Base implementation for SvnPath implementations. """
 #ep = '/'

 #ef _geturl(self):
 #eturn self.strpath
 #rl = property(_geturl, None, None, "url of this svn-path.")

 #ef __str__(self):
 #"" return a string representation (including rev-number) """
 #eturn self.strpath

 #ef __hash__(self):
 #eturn hash(self.strpath)

 #ef new(self, **kw):
 #"" create a modified version of this path. A 'rev' argument
 #ndicates a new revision.
 #he following keyword arguments modify various path parts::

 #ttp://host.com/repo/path/file.ext
 #-----------------------|          dirname
 #------| basename
 #--|     purebasename
 #--| ext
 #""
 #bj = object.__new__(self.__class__)
 #bj.rev = kw.get('rev', self.rev)
 #bj.auth = kw.get('auth', self.auth)
 #irname, basename, purebasename, ext = self._getbyspec(
 #dirname,basename,purebasename,ext")
 #f 'basename' in kw:
 #f 'purebasename' in kw or 'ext' in kw:
 #aise ValueError("invalid specification %r" % kw)
 #lse:
 #b = kw.setdefault('purebasename', purebasename)
 #xt = kw.setdefault('ext', ext)
 #f ext and not ext.startswith('.'):
 #xt = '.' + ext
 #w['basename'] = pb + ext

 #w.setdefault('dirname', dirname)
 #w.setdefault('sep', self.sep)
 #f kw['basename']:
 #bj.strpath = "%(dirname)s%(sep)s%(basename)s" % kw
 #lse:
 #bj.strpath = "%(dirname)s" % kw
 #eturn obj

 #ef _getbyspec(self, spec):
 #"" get specified parts of the path.  'arg' is a string
 #ith comma separated path parts. The parts are returned
 #n exactly the order of the specification.

 #ou may specify the following parts:

 #ttp://host.com/repo/path/file.ext
 #-----------------------|          dirname
 #------| basename
 #--|     purebasename
 #--| ext
 #""
 #es = []
 #arts = self.strpath.split(self.sep)
 #or name in spec.split(','):
 #ame = name.strip()
 #f name == 'dirname':
 #es.append(self.sep.join(parts[:-1]))
 #lif name == 'basename':
 #es.append(parts[-1])
 #lse:
 #asename = parts[-1]
 # = basename.rfind('.')
 #f i == -1:
 #urebasename, ext = basename, ''
 #lse:
 #urebasename, ext = basename[:i], basename[i:]
 #f name == 'purebasename':
 #es.append(purebasename)
 #lif name == 'ext':
 #es.append(ext)
 #lse:
 #aise NameError("Don't know part %r" % name)
 #eturn res

 #ef __eq__(self, other):
 #"" return true if path and rev attributes each match """
 #eturn (str(self) == str(other) and
 #self.rev == other.rev or self.rev == other.rev))

 #ef __ne__(self, other):
 #eturn not self == other

 #ef join(self, *args):
 #"" return a new Path (with the same revision) which is composed
 #f the self Path followed by 'args' path components.
 #""
 #f not args:
 #eturn self

 #rgs = tuple([arg.strip(self.sep) for arg in args])
 #arts = (self.strpath, ) + args
 #ewpath = self.__class__(self.sep.join(parts), self.rev, self.auth)
 #eturn newpath

 #ef propget(self, name):
 #"" return the content of the given property. """
 #alue = self._propget(name)
 #eturn value

 #ef proplist(self):
 #"" list all property names. """
 #ontent = self._proplist()
 #eturn content

 #ef size(self):
 #"" Return the size of the file content of the Path. """
 #eturn self.info().size

 #ef mtime(self):
 #"" Return the last modification time of the file. """
 #eturn self.info().mtime

    # shared help methods

 #ef _escape(self, cmd):
 #eturn _escape_helper(cmd)


    #def _childmaxrev(self):
    #    """ return maximum revision number of childs (or self.rev if no childs) """
    #    rev = self.rev
    #    for name, info in self._listdir_nameinfo():
    #        rev = max(rev, info.created_rev)
    #    return rev

    #def _getlatestrevision(self):
    #    """ return latest repo-revision for this path. """
    #    url = self.strpath
    #    path = self.__class__(url, None)
    #
    #    # we need a long walk to find the root-repo and revision
    #    while 1:
    #        try:
    #            rev = max(rev, path._childmaxrev())
    #            previous = path
    #            path = path.dirpath()
    #        except (IOError, process.cmdexec.Error):
    #            break
    #    if rev is None:
    #        raise IOError, "could not determine newest repo revision for %s" % self
    #    return rev

 #lass Checkers(common.Checkers):
 #ef dir(self):
 #ry:
 #eturn self.path.info().kind == 'dir'
 #xcept py.error.Error:
 #eturn self._listdirworks()

 #ef _listdirworks(self):
 #ry:
 #elf.path.listdir()
 #xcept py.error.ENOENT:
 #eturn False
 #lse:
 #eturn True

 #ef file(self):
 #ry:
 #eturn self.path.info().kind == 'file'
 #xcept py.error.ENOENT:
 #eturn False

 #ef exists(self):
 #ry:
 #eturn self.path.info()
 #xcept py.error.ENOENT:
 #eturn self._listdirworks()

def parse_apr_time(timestr):
 # = timestr.rfind('.')
 #f i == -1:
 #aise ValueError("could not parse %s" % timestr)
 #imestr = timestr[:i]
 #arsedtime = time.strptime(timestr, "%Y-%m-%dT%H:%M:%S")
 #eturn time.mktime(parsedtime)

class PropListDict(dict):
 #"" a Dictionary which fetches values (InfoSvnCommand instances) lazily"""
 #ef __init__(self, path, keynames):
 #ict.__init__(self, [(x, None) for x in keynames])
 #elf.path = path

 #ef __getitem__(self, key):
 #alue = dict.__getitem__(self, key)
 #f value is None:
 #alue = self.path.propget(key)
 #ict.__setitem__(self, key, value)
 #eturn value

def fixlocale():
 #f sys.platform != 'win32':
 #eturn 'LC_ALL=C '
 #eturn ''

# some nasty chunk of code to solve path and url conversion and quoting issues
ILLEGAL_CHARS = '* | \\ / : < > ? \t \n \x0b \x0c \r'.split(' ')
if os.sep in ILLEGAL_CHARS:
 #LLEGAL_CHARS.remove(os.sep)
ISWINDOWS = sys.platform == 'win32'
_reg_allow_disk = re.compile(r'^([a-z]\:\\)?[^:]+$', re.I)
def _check_path(path):
 #llegal = ILLEGAL_CHARS[:]
 #p = path.strpath
 #f ISWINDOWS:
 #llegal.remove(':')
 #f not _reg_allow_disk.match(sp):
 #aise ValueError('path may not contain a colon (:)')
 #or char in sp:
 #f char not in string.printable or char in illegal:
 #aise ValueError('illegal character %r in path' % (char,))

def path_to_fspath(path, addat=True):
 #check_path(path)
 #p = path.strpath
 #f addat and path.rev != -1:
 #p = '%s@%s' % (sp, path.rev)
 #lif addat:
 #p = '%s@HEAD' % (sp,)
 #eturn sp

def url_from_path(path):
 #spath = path_to_fspath(path, False)
 #rom urllib import quote
 #f ISWINDOWS:
 #atch = _reg_allow_disk.match(fspath)
 #spath = fspath.replace('\\', '/')
 #f match.group(1):
 #spath = '/%s%s' % (match.group(1).replace('\\', '/'),
 #uote(fspath[len(match.group(1)):]))
 #lse:
 #spath = quote(fspath)
 #lse:
 #spath = quote(fspath)
 #f path.rev != -1:
 #spath = '%s@%s' % (fspath, path.rev)
 #lse:
 #spath = '%s@HEAD' % (fspath,)
 #eturn 'file://%s' % (fspath,)

class SvnAuth(object):
 #"" container for auth information for Subversion """
 #ef __init__(self, username, password, cache_auth=True, interactive=True):
 #elf.username = username
 #elf.password = password
 #elf.cache_auth = cache_auth
 #elf.interactive = interactive

 #ef makecmdoptions(self):
 #name = self.username.replace('"', '\\"')
 #asswd = self.password.replace('"', '\\"')
 #et = []
 #f uname:
 #et.append('--username="%s"' % (uname,))
 #f passwd:
 #et.append('--password="%s"' % (passwd,))
 #f not self.cache_auth:
 #et.append('--no-auth-cache')
 #f not self.interactive:
 #et.append('--non-interactive')
 #eturn ' '.join(ret)

 #ef __str__(self):
 #eturn "<SvnAuth username=%s ...>" %(self.username,)

rex_blame = re.compile(r'\s*(\d+)\s+(\S+) (.*)')

class SvnWCCommandPath(common.PathBase):
 #"" path implementation offering access/modification to svn working copies.
 #t has methods similar to the functions in os.path and similar to the
 #ommands of the svn client.
 #""
 #ep = os.sep

 #ef __new__(cls, wcpath=None, auth=None):
 #elf = object.__new__(cls)
 #f isinstance(wcpath, cls):
 #f wcpath.__class__ == cls:
 #eturn wcpath
 #cpath = wcpath.localpath
 #f _check_for_bad_chars(str(wcpath),
 #LLOWED_CHARS):
 #aise ValueError("bad char in wcpath %s" % (wcpath, ))
 #elf.localpath = py.path.local(wcpath)
 #elf.auth = auth
 #eturn self

 #trpath = property(lambda x: str(x.localpath), None, None, "string path")
 #ev = property(lambda x: x.info(usecache=0).rev, None, None, "revision")

 #ef __eq__(self, other):
 #eturn self.localpath == getattr(other, 'localpath', None)

 #ef _geturl(self):
 #f getattr(self, '_url', None) is None:
 #nfo = self.info()
 #elf._url = info.url #SvnPath(info.url, info.rev)
 #ssert isinstance(self._url, py.builtin._basestring)
 #eturn self._url

 #rl = property(_geturl, None, None, "url of this WC item")

 #ef _escape(self, cmd):
 #eturn _escape_helper(cmd)

 #ef dump(self, obj):
 #"" pickle object into path location"""
 #eturn self.localpath.dump(obj)

 #ef svnurl(self):
 #"" return current SvnPath for this WC-item. """
 #nfo = self.info()
 #eturn py.path.svnurl(info.url)

 #ef __repr__(self):
 #eturn "svnwc(%r)" % (self.strpath) # , self._url)

 #ef __str__(self):
 #eturn str(self.localpath)

 #ef _makeauthoptions(self):
 #f self.auth is None:
 #eturn ''
 #eturn self.auth.makecmdoptions()

 #ef _authsvn(self, cmd, args=None):
 #rgs = args and list(args) or []
 #rgs.append(self._makeauthoptions())
 #eturn self._svn(cmd, *args)

 #ef _svn(self, cmd, *args):
 # = ['svn %s' % cmd]
 #rgs = [self._escape(item) for item in args]
 #.extend(args)
 #.append('"%s"' % self._escape(self.strpath))
        # try fixing the locale because we can't otherwise parse
 #tring = fixlocale() + " ".join(l)
 #ry:
 #ry:
 #ey = 'LC_MESSAGES'
 #old = os.environ.get(key)
 #s.environ[key] = 'C'
 #ut = py.process.cmdexec(string)
 #inally:
 #f hold:
 #s.environ[key] = hold
 #lse:
 #el os.environ[key]
 #xcept py.process.cmdexec.Error:
 # = sys.exc_info()[1]
 #trerr = e.err.lower()
 #f strerr.find('not found') != -1:
 #aise py.error.ENOENT(self)
 #lif strerr.find("E200009:") != -1:
 #aise py.error.ENOENT(self)
 #f (strerr.find('file exists') != -1 or
 #trerr.find('file already exists') != -1 or
 #trerr.find('w150002:') != -1 or
 #trerr.find("can't create directory") != -1):
 #aise py.error.EEXIST(strerr) #self)
 #aise
 #eturn out

 #ef switch(self, url):
 #"" switch to given URL. """
 #elf._authsvn('switch', [url])

 #ef checkout(self, url=None, rev=None):
 #"" checkout from url to local wcpath. """
 #rgs = []
 #f url is None:
 #rl = self.url
 #f rev is None or rev == -1:
 #f (sys.platform != 'win32' and
 #getsvnversion() == '1.3'):
 #rl += "@HEAD"
 #lse:
 #f _getsvnversion() == '1.3':
 #rl += "@%d" % rev
 #lse:
 #rgs.append('-r' + str(rev))
 #rgs.append(url)
 #elf._authsvn('co', args)

 #ef update(self, rev='HEAD', interactive=True):
 #"" update working copy item to given revision. (None -> HEAD). """
 #pts = ['-r', rev]
 #f not interactive:
 #pts.append("--non-interactive")
 #elf._authsvn('up', opts)

 #ef write(self, content, mode='w'):
 #"" write content into local filesystem wc. """
 #elf.localpath.write(content, mode)

 #ef dirpath(self, *args):
 #"" return the directory Path of the current Path. """
 #eturn self.__class__(self.localpath.dirpath(*args), auth=self.auth)

 #ef _ensuredirs(self):
 #arent = self.dirpath()
 #f parent.check(dir=0):
 #arent._ensuredirs()
 #f self.check(dir=0):
 #elf.mkdir()
 #eturn self

 #ef ensure(self, *args, **kwargs):
 #"" ensure that an args-joined path exists (by default as
 # file). if you specify a keyword argument 'directory=True'
 #hen the path is forced  to be a directory path.
 #""
 # = self.join(*args)
 #f p.check():
 #f p.check(versioned=False):
 #.add()
 #eturn p
 #f kwargs.get('dir', 0):
 #eturn p._ensuredirs()
 #arent = p.dirpath()
 #arent._ensuredirs()
 #.write("")
 #.add()
 #eturn p

 #ef mkdir(self, *args):
 #"" create & return the directory joined with args. """
 #f args:
 #eturn self.join(*args).mkdir()
 #lse:
 #elf._svn('mkdir')
 #eturn self

 #ef add(self):
 #"" add ourself to svn """
 #elf._svn('add')

 #ef remove(self, rec=1, force=1):
 #"" remove a file or a directory tree. 'rec'ursive is
 #gnored and considered always true (because of
 #nderlying svn semantics.
 #""
 #ssert rec, "svn cannot remove non-recursively"
 #f not self.check(versioned=True):
            # not added to svn (anymore?), just remove
 #y.path.local(self).remove()
 #eturn
 #lags = []
 #f force:
 #lags.append('--force')
 #elf._svn('remove', *flags)

 #ef copy(self, target):
 #"" copy path to target."""
 #y.process.cmdexec("svn copy %s %s" %(str(self), str(target)))

 #ef rename(self, target):
 #"" rename this path to target. """
 #y.process.cmdexec("svn move --force %s %s" %(str(self), str(target)))

 #ef lock(self):
 #"" set a lock (exclusive) on the resource """
 #ut = self._authsvn('lock').strip()
 #f not out:
            # warning or error, raise exception
 #aise ValueError("unknown error in svn lock command")

 #ef unlock(self):
 #"" unset a previously set lock """
 #ut = self._authsvn('unlock').strip()
 #f out.startswith('svn:'):
            # warning or error, raise exception
 #aise Exception(out[4:])

 #ef cleanup(self):
 #"" remove any locks from the resource """
        # XXX should be fixed properly!!!
 #ry:
 #elf.unlock()
 #xcept:
 #ass

 #ef status(self, updates=0, rec=0, externals=0):
 #"" return (collective) Status object for this file. """
        # http://svnbook.red-bean.com/book.html#svn-ch-3-sect-4.3.1
        #             2201     2192        jum   test
        # XXX
 #f externals:
 #aise ValueError("XXX cannot perform status() "
 #on external items yet")
 #lse:
            #1.2 supports: externals = '--ignore-externals'
 #xternals = ''
 #f rec:
 #ec= ''
 #lse:
 #ec = '--non-recursive'

        # XXX does not work on all subversion versions
        #if not externals:
        #    externals = '--ignore-externals'

 #f updates:
 #pdates = '-u'
 #lse:
 #pdates = ''

 #ry:
 #md = 'status -v --xml --no-ignore %s %s %s' % (
 #pdates, rec, externals)
 #ut = self._authsvn(cmd)
 #xcept py.process.cmdexec.Error:
 #md = 'status -v --no-ignore %s %s %s' % (
 #pdates, rec, externals)
 #ut = self._authsvn(cmd)
 #ootstatus = WCStatus(self).fromstring(out, self)
 #lse:
 #ootstatus = XMLWCStatus(self).fromstring(out, self)
 #eturn rootstatus

 #ef diff(self, rev=None):
 #"" return a diff of the current path against revision rev (defaulting
 #o the last one).
 #""
 #rgs = []
 #f rev is not None:
 #rgs.append("-r %d" % rev)
 #ut = self._authsvn('diff', args)
 #eturn out

 #ef blame(self):
 #"" return a list of tuples of three elements:
 #revision, commiter, line)
 #""
 #ut = self._svn('blame')
 #esult = []
 #lamelines = out.splitlines()
 #eallines = py.path.svnurl(self.url).readlines()
 #or i, (blameline, line) in enumerate(
 #ip(blamelines, reallines)):
 # = rex_blame.match(blameline)
 #f not m:
 #aise ValueError("output line %r of svn blame does not match "
 #expected format" % (line, ))
 #ev, name, _ = m.groups()
 #esult.append((int(rev), name, line))
 #eturn result

 #rex_commit = re.compile(r'.*Committed revision (\d+)\.$', re.DOTALL)
 #ef commit(self, msg='', rec=1):
 #"" commit with support for non-recursive commits """
        # XXX i guess escaping should be done better here?!?
 #md = 'commit -m "%s" --force-log' % (msg.replace('"', '\\"'),)
 #f not rec:
 #md += ' -N'
 #ut = self._authsvn(cmd)
 #ry:
 #el cache.info[self]
 #xcept KeyError:
 #ass
 #f out:
 # = self._rex_commit.match(out)
 #eturn int(m.group(1))

 #ef propset(self, name, value, *args):
 #"" set property name to value on this path. """
 # = py.path.local.mkdtemp()
 #ry:
 # = d.join('value')
 #.write(value)
 #elf._svn('propset', name, '--file', str(p), *args)
 #inally:
 #.remove()

 #ef propget(self, name):
 #"" get property name on this path. """
 #es = self._svn('propget', name)
 #eturn res[:-1] # strip trailing newline

 #ef propdel(self, name):
 #"" delete property name on this path. """
 #es = self._svn('propdel', name)
 #eturn res[:-1] # strip trailing newline

 #ef proplist(self, rec=0):
 #"" return a mapping of property names to property values.
If rec is True, then return a dictionary mapping sub-paths to such mappings.
"""
 #f rec:
 #es = self._svn('proplist -R')
 #eturn make_recursive_propdict(self, res)
 #lse:
 #es = self._svn('proplist')
 #ines = res.split('\n')
 #ines = [x.strip() for x in lines[1:]]
 #eturn PropListDict(self, lines)

 #ef revert(self, rec=0):
 #"" revert the local changes of this path. if rec is True, do so
recursively. """
 #f rec:
 #esult = self._svn('revert -R')
 #lse:
 #esult = self._svn('revert')
 #eturn result

 #ef new(self, **kw):
 #"" create a modified version of this path. A 'rev' argument
 #ndicates a new revision.
 #he following keyword arguments modify various path parts:

 #ttp://host.com/repo/path/file.ext
 #-----------------------|          dirname
 #------| basename
 #--|     purebasename
 #--| ext
 #""
 #f kw:
 #ocalpath = self.localpath.new(**kw)
 #lse:
 #ocalpath = self.localpath
 #eturn self.__class__(localpath, auth=self.auth)

 #ef join(self, *args, **kwargs):
 #"" return a new Path (with the same revision) which is composed
 #f the self Path followed by 'args' path components.
 #""
 #f not args:
 #eturn self
 #ocalpath = self.localpath.join(*args, **kwargs)
 #eturn self.__class__(localpath, auth=self.auth)

 #ef info(self, usecache=1):
 #"" return an Info structure with svn-provided information. """
 #nfo = usecache and cache.info.get(self)
 #f not info:
 #ry:
 #utput = self._svn('info')
 #xcept py.process.cmdexec.Error:
 # = sys.exc_info()[1]
 #f e.err.find('Path is not a working copy directory') != -1:
 #aise py.error.ENOENT(self, e.err)
 #lif e.err.find("is not under version control") != -1:
 #aise py.error.ENOENT(self, e.err)
 #aise
            # XXX SVN 1.3 has output on stderr instead of stdout (while it does
            # return 0!), so a bit nasty, but we assume no output is output
            # to stderr...
 #f (output.strip() == '' or
 #utput.lower().find('not a versioned resource') != -1):
 #aise py.error.ENOENT(self, output)
 #nfo = InfoSvnWCCommand(output)

            # Can't reliably compare on Windows without access to win32api
 #f sys.platform != 'win32':
 #f info.path != self.localpath:
 #aise py.error.ENOENT(self, "not a versioned resource:" +
 # %s != %s" % (info.path, self.localpath))
 #ache.info[self] = info
 #eturn info

 #ef listdir(self, fil=None, sort=None):
 #"" return a sequence of Paths.

 #istdir will return either a tuple or a list of paths
 #epending on implementation choices.
 #""
 #f isinstance(fil, str):
 #il = common.FNMatcher(fil)
        # XXX unify argument naming with LocalPath.listdir
 #ef notsvn(path):
 #eturn path.basename != '.svn'

 #aths = []
 #or localpath in self.localpath.listdir(notsvn):
 # = self.__class__(localpath, auth=self.auth)
 #f notsvn(p) and (not fil or fil(p)):
 #aths.append(p)
 #elf._sortlist(paths, sort)
 #eturn paths

 #ef open(self, mode='r'):
 #"" return an opened file with the given mode. """
 #eturn open(self.strpath, mode)

 #ef _getbyspec(self, spec):
 #eturn self.localpath._getbyspec(spec)

 #lass Checkers(py.path.local.Checkers):
 #ef __init__(self, path):
 #elf.svnwcpath = path
 #elf.path = path.localpath
 #ef versioned(self):
 #ry:
 # = self.svnwcpath.info()
 #xcept (py.error.ENOENT, py.error.EEXIST):
 #eturn False
 #xcept py.process.cmdexec.Error:
 # = sys.exc_info()[1]
 #f e.err.find('is not a working copy')!=-1:
 #eturn False
 #f e.err.lower().find('not a versioned resource') != -1:
 #eturn False
 #aise
 #lse:
 #eturn True

 #ef log(self, rev_start=None, rev_end=1, verbose=False):
 #"" return a list of LogEntry instances for this path.
rev_start is the starting revision (defaulting to the first one).
rev_end is the last revision (defaulting to HEAD).
if verbose is True, then the LogEntry instances also know which files changed.
"""
 #ssert self.check()   # make it simpler for the pipe
 #ev_start = rev_start is None and "HEAD" or rev_start
 #ev_end = rev_end is None and "HEAD" or rev_end
 #f rev_start == "HEAD" and rev_end == 1:
 #ev_opt = ""
 #lse:
 #ev_opt = "-r %s:%s" % (rev_start, rev_end)
 #erbose_opt = verbose and "-v" or ""
 #ocale_env = fixlocale()
        # some blather on stderr
 #uth_opt = self._makeauthoptions()
        #stdin, stdout, stderr  = os.popen3(locale_env +
        #                                   'svn log --xml %s %s %s "%s"' % (
        #                                    rev_opt, verbose_opt, auth_opt,
        #                                    self.strpath))
 #md = locale_env + 'svn log --xml %s %s %s "%s"' % (
 #ev_opt, verbose_opt, auth_opt, self.strpath)

 #open = subprocess.Popen(cmd,
 #tdout=subprocess.PIPE,
 #tderr=subprocess.PIPE,
 #hell=True,
 #
 #tdout, stderr = popen.communicate()
 #tdout = py.builtin._totext(stdout, sys.getdefaultencoding())
 #inidom,ExpatError = importxml()
 #ry:
 #ree = minidom.parseString(stdout)
 #xcept ExpatError:
 #aise ValueError('no such revision')
 #esult = []
 #or logentry in filter(None, tree.firstChild.childNodes):
 #f logentry.nodeType == logentry.ELEMENT_NODE:
 #esult.append(LogEntry(logentry))
 #eturn result

 #ef size(self):
 #"" Return the size of the file content of the Path. """
 #eturn self.info().size

 #ef mtime(self):
 #"" Return the last modification time of the file. """
 #eturn self.info().mtime

 #ef __hash__(self):
 #eturn hash((self.strpath, self.__class__, self.auth))


class WCStatus:
 #ttrnames = ('modified','added', 'conflict', 'unchanged', 'external',
 #deleted', 'prop_modified', 'unknown', 'update_available',
 #incomplete', 'kindmismatch', 'ignored', 'locked', 'replaced'
 #

 #ef __init__(self, wcpath, rev=None, modrev=None, author=None):
 #elf.wcpath = wcpath
 #elf.rev = rev
 #elf.modrev = modrev
 #elf.author = author

 #or name in self.attrnames:
 #etattr(self, name, [])

 #ef allpath(self, sort=True, **kw):
 # = {}
 #or name in self.attrnames:
 #f name not in kw or kw[name]:
 #or path in getattr(self, name):
 #[path] = 1
 # = d.keys()
 #f sort:
 #.sort()
 #eturn l

    # XXX a bit scary to assume there's always 2 spaces between username and
    # path, however with win32 allowing spaces in user names there doesn't
    # seem to be a more solid approach :(
 #rex_status = re.compile(r'\s+(\d+|-)\s+(\S+)\s+(.+?)\s{2,}(.*)')

 #ef fromstring(data, rootwcpath, rev=None, modrev=None, author=None):
 #"" return a new WCStatus object from data 's'
 #""
 #ootstatus = WCStatus(rootwcpath, rev, modrev, author)
 #pdate_rev = None
 #or line in data.split('\n'):
 #f not line.strip():
 #ontinue
            #print "processing %r" % line
 #lags, rest = line[:8], line[8:]
            # first column
 #0,c1,c2,c3,c4,c5,x6,c7 = flags
            #if '*' in line:
            #    print "flags", repr(flags), "rest", repr(rest)

 #f c0 in '?XI':
 #n = line.split(None, 1)[1]
 #f c0 == '?':
 #cpath = rootwcpath.join(fn, abs=1)
 #ootstatus.unknown.append(wcpath)
 #lif c0 == 'X':
 #cpath = rootwcpath.__class__(
 #ootwcpath.localpath.join(fn, abs=1),
 #uth=rootwcpath.auth)
 #ootstatus.external.append(wcpath)
 #lif c0 == 'I':
 #cpath = rootwcpath.join(fn, abs=1)
 #ootstatus.ignored.append(wcpath)

 #ontinue

            #elif c0 in '~!' or c4 == 'S':
            #    raise NotImplementedError("received flag %r" % c0)

 # = WCStatus._rex_status.match(rest)
 #f not m:
 #f c7 == '*':
 #n = rest.strip()
 #cpath = rootwcpath.join(fn, abs=1)
 #ootstatus.update_available.append(wcpath)
 #ontinue
 #f line.lower().find('against revision:')!=-1:
 #pdate_rev = int(rest.split(':')[1].strip())
 #ontinue
 #f line.lower().find('status on external') > -1:
                    # XXX not sure what to do here... perhaps we want to
                    # store some state instead of just continuing, as right
                    # now it makes the top-level external get added twice
                    # (once as external, once as 'normal' unchanged item)
                    # because of the way SVN presents external items
 #ontinue
                # keep trying
 #aise ValueError("could not parse line %r" % line)
 #lse:
 #ev, modrev, author, fn = m.groups()
 #cpath = rootwcpath.join(fn, abs=1)
            #assert wcpath.check()
 #f c0 == 'M':
 #ssert wcpath.check(file=1), "didn't expect a directory with changed content here"
 #ootstatus.modified.append(wcpath)
 #lif c0 == 'A' or c3 == '+' :
 #ootstatus.added.append(wcpath)
 #lif c0 == 'D':
 #ootstatus.deleted.append(wcpath)
 #lif c0 == 'C':
 #ootstatus.conflict.append(wcpath)
 #lif c0 == '~':
 #ootstatus.kindmismatch.append(wcpath)
 #lif c0 == '!':
 #ootstatus.incomplete.append(wcpath)
 #lif c0 == 'R':
 #ootstatus.replaced.append(wcpath)
 #lif not c0.strip():
 #ootstatus.unchanged.append(wcpath)
 #lse:
 #aise NotImplementedError("received flag %r" % c0)

 #f c1 == 'M':
 #ootstatus.prop_modified.append(wcpath)
            # XXX do we cover all client versions here?
 #f c2 == 'L' or c5 == 'K':
 #ootstatus.locked.append(wcpath)
 #f c7 == '*':
 #ootstatus.update_available.append(wcpath)

 #f wcpath == rootwcpath:
 #ootstatus.rev = rev
 #ootstatus.modrev = modrev
 #ootstatus.author = author
 #f update_rev:
 #ootstatus.update_rev = update_rev
 #ontinue
 #eturn rootstatus
 #romstring = staticmethod(fromstring)

class XMLWCStatus(WCStatus):
 #ef fromstring(data, rootwcpath, rev=None, modrev=None, author=None):
 #"" parse 'data' (XML string as outputted by svn st) into a status obj
 #""
        # XXX for externals, the path is shown twice: once
        # with external information, and once with full info as if
        # the item was a normal non-external... the current way of
        # dealing with this issue is by ignoring it - this does make
        # externals appear as external items as well as 'normal',
        # unchanged ones in the status object so this is far from ideal
 #ootstatus = WCStatus(rootwcpath, rev, modrev, author)
 #pdate_rev = None
 #inidom, ExpatError = importxml()
 #ry:
 #oc = minidom.parseString(data)
 #xcept ExpatError:
 # = sys.exc_info()[1]
 #aise ValueError(str(e))
 #revels = doc.getElementsByTagName('against')
 #f urevels:
 #ootstatus.update_rev = urevels[-1].getAttribute('revision')
 #or entryel in doc.getElementsByTagName('entry'):
 #ath = entryel.getAttribute('path')
 #tatusel = entryel.getElementsByTagName('wc-status')[0]
 #temstatus = statusel.getAttribute('item')

 #f itemstatus == 'unversioned':
 #cpath = rootwcpath.join(path, abs=1)
 #ootstatus.unknown.append(wcpath)
 #ontinue
 #lif itemstatus == 'external':
 #cpath = rootwcpath.__class__(
 #ootwcpath.localpath.join(path, abs=1),
 #uth=rootwcpath.auth)
 #ootstatus.external.append(wcpath)
 #ontinue
 #lif itemstatus == 'ignored':
 #cpath = rootwcpath.join(path, abs=1)
 #ootstatus.ignored.append(wcpath)
 #ontinue
 #lif itemstatus == 'incomplete':
 #cpath = rootwcpath.join(path, abs=1)
 #ootstatus.incomplete.append(wcpath)
 #ontinue

 #ev = statusel.getAttribute('revision')
 #f itemstatus == 'added' or itemstatus == 'none':
 #ev = '0'
 #odrev = '?'
 #uthor = '?'
 #ate = ''
 #lif itemstatus == "replaced":
 #ass
 #lse:
                #print entryel.toxml()
 #ommitel = entryel.getElementsByTagName('commit')[0]
 #f commitel:
 #odrev = commitel.getAttribute('revision')
 #uthor = ''
 #uthor_els = commitel.getElementsByTagName('author')
 #f author_els:
 #or c in author_els[0].childNodes:
 #uthor += c.nodeValue
 #ate = ''
 #or c in commitel.getElementsByTagName('date')[0]\
 #childNodes:
 #ate += c.nodeValue

 #cpath = rootwcpath.join(path, abs=1)

 #ssert itemstatus != 'modified' or wcpath.check(file=1), (
 #did\'t expect a directory with changed content here')

 #temattrname = {
 #normal': 'unchanged',
 #unversioned': 'unknown',
 #conflicted': 'conflict',
 #none': 'added',
 #.get(itemstatus, itemstatus)

 #ttr = getattr(rootstatus, itemattrname)
 #ttr.append(wcpath)

 #ropsstatus = statusel.getAttribute('props')
 #f propsstatus not in ('none', 'normal'):
 #ootstatus.prop_modified.append(wcpath)

 #f wcpath == rootwcpath:
 #ootstatus.rev = rev
 #ootstatus.modrev = modrev
 #ootstatus.author = author
 #ootstatus.date = date

            # handle repos-status element (remote info)
 #statusels = entryel.getElementsByTagName('repos-status')
 #f rstatusels:
 #statusel = rstatusels[0]
 #itemstatus = rstatusel.getAttribute('item')
 #f ritemstatus in ('added', 'modified'):
 #ootstatus.update_available.append(wcpath)

 #ockels = entryel.getElementsByTagName('lock')
 #f len(lockels):
 #ootstatus.locked.append(wcpath)

 #eturn rootstatus
 #romstring = staticmethod(fromstring)

class InfoSvnWCCommand:
 #ef __init__(self, output):
        # Path: test
        # URL: http://codespeak.net/svn/std.path/trunk/dist/std.path/test
        # Repository UUID: fd0d7bf2-dfb6-0310-8d31-b7ecfe96aada
        # Revision: 2151
        # Node Kind: directory
        # Schedule: normal
        # Last Changed Author: hpk
        # Last Changed Rev: 2100
        # Last Changed Date: 2003-10-27 20:43:14 +0100 (Mon, 27 Oct 2003)
        # Properties Last Updated: 2003-11-03 14:47:48 +0100 (Mon, 03 Nov 2003)

 # = {}
 #or line in output.split('\n'):
 #f not line.strip():
 #ontinue
 #ey, value = line.split(':', 1)
 #ey = key.lower().replace(' ', '')
 #alue = value.strip()
 #[key] = value
 #ry:
 #elf.url = d['url']
 #xcept KeyError:
 #aise  ValueError("Not a versioned resource")
            #raise ValueError, "Not a versioned resource %r" % path
 #elf.kind = d['nodekind'] == 'directory' and 'dir' or d['nodekind']
 #ry:
 #elf.rev = int(d['revision'])
 #xcept KeyError:
 #elf.rev = None

 #elf.path = py.path.local(d['path'])
 #elf.size = self.path.size()
 #f 'lastchangedrev' in d:
 #elf.created_rev = int(d['lastchangedrev'])
 #f 'lastchangedauthor' in d:
 #elf.last_author = d['lastchangedauthor']
 #f 'lastchangeddate' in d:
 #elf.mtime = parse_wcinfotime(d['lastchangeddate'])
 #elf.time = self.mtime * 1000000

 #ef __eq__(self, other):
 #eturn self.__dict__ == other.__dict__

def parse_wcinfotime(timestr):
 #"" Returns seconds since epoch, UTC. """
    # example: 2003-10-27 20:43:14 +0100 (Mon, 27 Oct 2003)
 # = re.match(r'(\d+-\d+-\d+ \d+:\d+:\d+) ([+-]\d+) .*', timestr)
 #f not m:
 #aise ValueError("timestring %r does not match" % timestr)
 #imestr, timezone = m.groups()
    # do not handle timezone specially, return value should be UTC
 #arsedtime = time.strptime(timestr, "%Y-%m-%d %H:%M:%S")
 #eturn calendar.timegm(parsedtime)

def make_recursive_propdict(wcroot,
 #utput,
 #ex = re.compile("Properties on '(.*)':")):
 #"" Return a dictionary of path->PropListDict mappings. """
 #ines = [x for x in output.split('\n') if x]
 #dict = {}
 #hile lines:
 #ine = lines.pop(0)
 # = rex.match(line)
 #f not m:
 #aise ValueError("could not parse propget-line: %r" % line)
 #ath = m.groups()[0]
 #cpath = wcroot.join(path, abs=1)
 #ropnames = []
 #hile lines and lines[0].startswith('  '):
 #ropname = lines.pop(0).strip()
 #ropnames.append(propname)
 #ssert propnames, "must have found properties!"
 #dict[wcpath] = PropListDict(wcpath, propnames)
 #eturn pdict


def importxml(cache=[]):
 #f cache:
 #eturn cache
 #rom xml.dom import minidom
 #rom xml.parsers.expat import ExpatError
 #ache.extend([minidom, ExpatError])
 #eturn cache

class LogEntry:
 #ef __init__(self, logentry):
 #elf.rev = int(logentry.getAttribute('revision'))
 #or lpart in filter(None, logentry.childNodes):
 #f lpart.nodeType == lpart.ELEMENT_NODE:
 #f lpart.nodeName == 'author':
 #elf.author = lpart.firstChild.nodeValue
 #lif lpart.nodeName == 'msg':
 #f lpart.firstChild:
 #elf.msg = lpart.firstChild.nodeValue
 #lse:
 #elf.msg = ''
 #lif lpart.nodeName == 'date':
                    #2003-07-29T20:05:11.598637Z
 #imestr = lpart.firstChild.nodeValue
 #elf.date = parse_apr_time(timestr)
 #lif lpart.nodeName == 'paths':
 #elf.strpaths = []
 #or ppart in filter(None, lpart.childNodes):
 #f ppart.nodeType == ppart.ELEMENT_NODE:
 #elf.strpaths.append(PathEntry(ppart))
 #ef __repr__(self):
 #eturn '<Logentry rev=%d author=%s date=%s>' % (
 #elf.rev, self.author, self.date)


