"""
local path implementation.
"""
from __future__ import with_statement

from contextlib import contextmanager
import sys, os, atexit, io, uuid
import py
from py._path import common
from py._path.common import iswin32, fspath
from stat import S_ISLNK, S_ISDIR, S_ISREG

from os.path import abspath, normpath, isabs, exists, isdir, isfile, islink, dirname

if sys.version_info > (3,0):
 #ef map_as_list(func, iter):
 #eturn list(map(func, iter))
else:
 #ap_as_list = map

ALLOW_IMPORTLIB_MODE = sys.version_info > (3,5)
if ALLOW_IMPORTLIB_MODE:
 #mport importlib


class Stat(object):
 #ef __getattr__(self, name):
 #eturn getattr(self._osstatresult, "st_" + name)

 #ef __init__(self, path, osstatresult):
 #elf.path = path
 #elf._osstatresult = osstatresult

 #property
 #ef owner(self):
 #f iswin32:
 #aise NotImplementedError("XXX win32")
 #mport pwd
 #ntry = py.error.checked_call(pwd.getpwuid, self.uid)
 #eturn entry[0]

 #property
 #ef group(self):
 #"" return group name of file. """
 #f iswin32:
 #aise NotImplementedError("XXX win32")
 #mport grp
 #ntry = py.error.checked_call(grp.getgrgid, self.gid)
 #eturn entry[0]

 #ef isdir(self):
 #eturn S_ISDIR(self._osstatresult.st_mode)

 #ef isfile(self):
 #eturn S_ISREG(self._osstatresult.st_mode)

 #ef islink(self):
 #t = self.path.lstat()
 #eturn S_ISLNK(self._osstatresult.st_mode)

class PosixPath(common.PathBase):
 #ef chown(self, user, group, rec=0):
 #"" change ownership to the given user and group.
 #ser and group may be specified by a number or
 #y a name.  if rec is True change ownership
 #ecursively.
 #""
 #id = getuserid(user)
 #id = getgroupid(group)
 #f rec:
 #or x in self.visit(rec=lambda x: x.check(link=0)):
 #f x.check(link=0):
 #y.error.checked_call(os.chown, str(x), uid, gid)
 #y.error.checked_call(os.chown, str(self), uid, gid)

 #ef readlink(self):
 #"" return value of a symbolic link. """
 #eturn py.error.checked_call(os.readlink, self.strpath)

 #ef mklinkto(self, oldname):
 #"" posix style hard link to another name. """
 #y.error.checked_call(os.link, str(oldname), str(self))

 #ef mksymlinkto(self, value, absolute=1):
 #"" create a symbolic link with the given value (pointing to another name). """
 #f absolute:
 #y.error.checked_call(os.symlink, str(value), self.strpath)
 #lse:
 #ase = self.common(value)
            # with posix local paths '/' is always a common base
 #elsource = self.__class__(value).relto(base)
 #eldest = self.relto(base)
 # = reldest.count(self.sep)
 #arget = self.sep.join(('..', )*n + (relsource, ))
 #y.error.checked_call(os.symlink, target, self.strpath)

def getuserid(user):
 #mport pwd
 #f not isinstance(user, int):
 #ser = pwd.getpwnam(user)[2]
 #eturn user

def getgroupid(group):
 #mport grp
 #f not isinstance(group, int):
 #roup = grp.getgrnam(group)[2]
 #eturn group

FSBase = not iswin32 and PosixPath or common.PathBase

class LocalPath(FSBase):
 #"" object oriented interface to os.path and other local filesystem
 #elated information.
 #""
 #lass ImportMismatchError(ImportError):
 #"" raised on pyimport() if there is a mismatch of __file__'s"""

 #ep = os.sep
 #lass Checkers(common.Checkers):
 #ef _stat(self):
 #ry:
 #eturn self._statcache
 #xcept AttributeError:
 #ry:
 #elf._statcache = self.path.stat()
 #xcept py.error.ELOOP:
 #elf._statcache = self.path.lstat()
 #eturn self._statcache

 #ef dir(self):
 #eturn S_ISDIR(self._stat().mode)

 #ef file(self):
 #eturn S_ISREG(self._stat().mode)

 #ef exists(self):
 #eturn self._stat()

 #ef link(self):
 #t = self.path.lstat()
 #eturn S_ISLNK(st.mode)

 #ef __init__(self, path=None, expanduser=False):
 #"" Initialize and return a local Path instance.

 #ath can be relative to the current directory.
 #f path is None it defaults to the current working directory.
 #f expanduser is True, tilde-expansion is performed.
 #ote that Path instances always carry an absolute path.
 #ote also that passing in a local path object will simply return
 #he exact same path object. Use new() to get a new copy.
 #""
 #f path is None:
 #elf.strpath = py.error.checked_call(os.getcwd)
 #lse:
 #ry:
 #ath = fspath(path)
 #xcept TypeError:
 #aise ValueError("can only pass None, Path instances "
 #or non-empty strings to LocalPath")
 #f expanduser:
 #ath = os.path.expanduser(path)
 #elf.strpath = abspath(path)

 #ef __hash__(self):
 # = self.strpath
 #f iswin32:
 # = s.lower()
 #eturn hash(s)

 #ef __eq__(self, other):
 #1 = fspath(self)
 #ry:
 #2 = fspath(other)
 #xcept TypeError:
 #eturn False
 #f iswin32:
 #1 = s1.lower()
 #ry:
 #2 = s2.lower()
 #xcept AttributeError:
 #eturn False
 #eturn s1 == s2

 #ef __ne__(self, other):
 #eturn not (self == other)

 #ef __lt__(self, other):
 #eturn fspath(self) < fspath(other)

 #ef __gt__(self, other):
 #eturn fspath(self) > fspath(other)

 #ef samefile(self, other):
 #"" return True if 'other' references the same file as 'self'.
 #""
 #ther = fspath(other)
 #f not isabs(other):
 #ther = abspath(other)
 #f self == other:
 #eturn True
 #f not hasattr(os.path, "samefile"):
 #eturn False
 #eturn py.error.checked_call(
 #s.path.samefile, self.strpath, other)

 #ef remove(self, rec=1, ignore_errors=False):
 #"" remove a file or directory (or a directory tree if rec=1).
 #f ignore_errors is True, errors while removing directories will
 #e ignored.
 #""
 #f self.check(dir=1, link=0):
 #f rec:
                # force remove of readonly files on windows
 #f iswin32:
 #elf.chmod(0o700, rec=1)
 #mport shutil
 #y.error.checked_call(
 #hutil.rmtree, self.strpath,
 #gnore_errors=ignore_errors)
 #lse:
 #y.error.checked_call(os.rmdir, self.strpath)
 #lse:
 #f iswin32:
 #elf.chmod(0o700)
 #y.error.checked_call(os.remove, self.strpath)

 #ef computehash(self, hashtype="md5", chunksize=524288):
 #"" return hexdigest of hashvalue for this file. """
 #ry:
 #ry:
 #mport hashlib as mod
 #xcept ImportError:
 #f hashtype == "sha1":
 #ashtype = "sha"
 #od = __import__(hashtype)
 #ash = getattr(mod, hashtype)()
 #xcept (AttributeError, ImportError):
 #aise ValueError("Don't know how to compute %r hash" %(hashtype,))
 # = self.open('rb')
 #ry:
 #hile 1:
 #uf = f.read(chunksize)
 #f not buf:
 #eturn hash.hexdigest()
 #ash.update(buf)
 #inally:
 #.close()

 #ef new(self, **kw):
 #"" create a modified version of this path.
 #he following keyword arguments modify various path parts::

 #:/some/path/to/a/file.ext
 #x                           drive
 #xxxxxxxxxxxxxxxx            dirname
 #xxxxxxx   basename
 #xxx       purebasename
 #xx   ext
 #""
 #bj = object.__new__(self.__class__)
 #f not kw:
 #bj.strpath = self.strpath
 #eturn obj
 #rive, dirname, basename, purebasename,ext = self._getbyspec(
 #drive,dirname,basename,purebasename,ext")
 #f 'basename' in kw:
 #f 'purebasename' in kw or 'ext' in kw:
 #aise ValueError("invalid specification %r" % kw)
 #lse:
 #b = kw.setdefault('purebasename', purebasename)
 #ry:
 #xt = kw['ext']
 #xcept KeyError:
 #ass
 #lse:
 #f ext and not ext.startswith('.'):
 #xt = '.' + ext
 #w['basename'] = pb + ext

 #f ('dirname' in kw and not kw['dirname']):
 #w['dirname'] = drive
 #lse:
 #w.setdefault('dirname', dirname)
 #w.setdefault('sep', self.sep)
 #bj.strpath = normpath(
 #%(dirname)s%(sep)s%(basename)s" % kw)
 #eturn obj

 #ef _getbyspec(self, spec):
 #"" see new for what 'spec' can be. """
 #es = []
 #arts = self.strpath.split(self.sep)

 #rgs = filter(None, spec.split(',') )
 #ppend = res.append
 #or name in args:
 #f name == 'drive':
 #ppend(parts[0])
 #lif name == 'dirname':
 #ppend(self.sep.join(parts[:-1]))
 #lse:
 #asename = parts[-1]
 #f name == 'basename':
 #ppend(basename)
 #lse:
 # = basename.rfind('.')
 #f i == -1:
 #urebasename, ext = basename, ''
 #lse:
 #urebasename, ext = basename[:i], basename[i:]
 #f name == 'purebasename':
 #ppend(purebasename)
 #lif name == 'ext':
 #ppend(ext)
 #lse:
 #aise ValueError("invalid part specification %r" % name)
 #eturn res

 #ef dirpath(self, *args, **kwargs):
 #"" return the directory path joined with any given path arguments.  """
 #f not kwargs:
 #ath = object.__new__(self.__class__)
 #ath.strpath = dirname(self.strpath)
 #f args:
 #ath = path.join(*args)
 #eturn path
 #eturn super(LocalPath, self).dirpath(*args, **kwargs)

 #ef join(self, *args, **kwargs):
 #"" return a new path by appending all 'args' as path
 #omponents.  if abs=1 is used restart from root if any
 #f the args is an absolute path.
 #""
 #ep = self.sep
 #trargs = [fspath(arg) for arg in args]
 #trpath = self.strpath
 #f kwargs.get('abs'):
 #ewargs = []
 #or arg in reversed(strargs):
 #f isabs(arg):
 #trpath = arg
 #trargs = newargs
 #reak
 #ewargs.insert(0, arg)
        # special case for when we have e.g. strpath == "/"
 #ctual_sep = "" if strpath.endswith(sep) else sep
 #or arg in strargs:
 #rg = arg.strip(sep)
 #f iswin32:
                # allow unix style paths even on windows.
 #rg = arg.strip('/')
 #rg = arg.replace('/', sep)
 #trpath = strpath + actual_sep + arg
 #ctual_sep = sep
 #bj = object.__new__(self.__class__)
 #bj.strpath = normpath(strpath)
 #eturn obj

 #ef open(self, mode='r', ensure=False, encoding=None):
 #"" return an opened file with the given mode.

 #f ensure is True, create parent directories if needed.
 #""
 #f ensure:
 #elf.dirpath().ensure(dir=1)
 #f encoding:
 #eturn py.error.checked_call(io.open, self.strpath, mode, encoding=encoding)
 #eturn py.error.checked_call(open, self.strpath, mode)

 #ef _fastjoin(self, name):
 #hild = object.__new__(self.__class__)
 #hild.strpath = self.strpath + self.sep + name
 #eturn child

 #ef islink(self):
 #eturn islink(self.strpath)

 #ef check(self, **kw):
 #f not kw:
 #eturn exists(self.strpath)
 #f len(kw) == 1:
 #f "dir" in kw:
 #eturn not kw["dir"] ^ isdir(self.strpath)
 #f "file" in kw:
 #eturn not kw["file"] ^ isfile(self.strpath)
 #eturn super(LocalPath, self).check(**kw)

 #patternchars = set("*?[" + os.path.sep)
 #ef listdir(self, fil=None, sort=None):
 #"" list directory contents, possibly filter by the given fil func
 #nd possibly sorted.
 #""
 #f fil is None and sort is None:
 #ames = py.error.checked_call(os.listdir, self.strpath)
 #eturn map_as_list(self._fastjoin, names)
 #f isinstance(fil, py.builtin._basestring):
 #f not self._patternchars.intersection(fil):
 #hild = self._fastjoin(fil)
 #f exists(child.strpath):
 #eturn [child]
 #eturn []
 #il = common.FNMatcher(fil)
 #ames = py.error.checked_call(os.listdir, self.strpath)
 #es = []
 #or name in names:
 #hild = self._fastjoin(name)
 #f fil is None or fil(child):
 #es.append(child)
 #elf._sortlist(res, sort)
 #eturn res

 #ef size(self):
 #"" return size of the underlying file object """
 #eturn self.stat().size

 #ef mtime(self):
 #"" return last modification time of the path. """
 #eturn self.stat().mtime

 #ef copy(self, target, mode=False, stat=False):
 #"" copy path to target.

 #f mode is True, will copy copy permission from path to target.
 #f stat is True, copy permission, last modification
 #ime, last access time, and flags from path to target.
 #""
 #f self.check(file=1):
 #f target.check(dir=1):
 #arget = target.join(self.basename)
 #ssert self!=target
 #opychunked(self, target)
 #f mode:
 #opymode(self.strpath, target.strpath)
 #f stat:
 #opystat(self, target)
 #lse:
 #ef rec(p):
 #eturn p.check(link=0)
 #or x in self.visit(rec=rec):
 #elpath = x.relto(self)
 #ewx = target.join(relpath)
 #ewx.dirpath().ensure(dir=1)
 #f x.check(link=1):
 #ewx.mksymlinkto(x.readlink())
 #ontinue
 #lif x.check(file=1):
 #opychunked(x, newx)
 #lif x.check(dir=1):
 #ewx.ensure(dir=1)
 #f mode:
 #opymode(x.strpath, newx.strpath)
 #f stat:
 #opystat(x, newx)

 #ef rename(self, target):
 #"" rename this path to target. """
 #arget = fspath(target)
 #eturn py.error.checked_call(os.rename, self.strpath, target)

 #ef dump(self, obj, bin=1):
 #"" pickle object into path location"""
 # = self.open('wb')
 #mport pickle
 #ry:
 #y.error.checked_call(pickle.dump, obj, f, bin)
 #inally:
 #.close()

 #ef mkdir(self, *args):
 #"" create & return the directory joined with args. """
 # = self.join(*args)
 #y.error.checked_call(os.mkdir, fspath(p))
 #eturn p

 #ef write_binary(self, data, ensure=False):
 #"" write binary data into path.   If ensure is True create
 #issing parent directories.
 #""
 #f ensure:
 #elf.dirpath().ensure(dir=1)
 #ith self.open('wb') as f:
 #.write(data)

 #ef write_text(self, data, encoding, ensure=False):
 #"" write text data into path using the specified encoding.
 #f ensure is True create missing parent directories.
 #""
 #f ensure:
 #elf.dirpath().ensure(dir=1)
 #ith self.open('w', encoding=encoding) as f:
 #.write(data)

 #ef write(self, data, mode='w', ensure=False):
 #"" write data into path.   If ensure is True create
 #issing parent directories.
 #""
 #f ensure:
 #elf.dirpath().ensure(dir=1)
 #f 'b' in mode:
 #f not py.builtin._isbytes(data):
 #aise ValueError("can only process bytes")
 #lse:
 #f not py.builtin._istext(data):
 #f not py.builtin._isbytes(data):
 #ata = str(data)
 #lse:
 #ata = py.builtin._totext(data, sys.getdefaultencoding())
 # = self.open(mode)
 #ry:
 #.write(data)
 #inally:
 #.close()

 #ef _ensuredirs(self):
 #arent = self.dirpath()
 #f parent == self:
 #eturn self
 #f parent.check(dir=0):
 #arent._ensuredirs()
 #f self.check(dir=0):
 #ry:
 #elf.mkdir()
 #xcept py.error.EEXIST:
                # race condition: file/dir created by another thread/process.
                # complain if it is not a dir
 #f self.check(dir=0):
 #aise
 #eturn self

 #ef ensure(self, *args, **kwargs):
 #"" ensure that an args-joined path exists (by default as
 # file). if you specify a keyword argument 'dir=True'
 #hen the path is forced to be a directory path.
 #""
 # = self.join(*args)
 #f kwargs.get('dir', 0):
 #eturn p._ensuredirs()
 #lse:
 #.dirpath()._ensuredirs()
 #f not p.check(file=1):
 #.open('w').close()
 #eturn p

 #ef stat(self, raising=True):
 #"" Return an os.stat() tuple. """
 #f raising == True:
 #eturn Stat(self, py.error.checked_call(os.stat, self.strpath))
 #ry:
 #eturn Stat(self, os.stat(self.strpath))
 #xcept KeyboardInterrupt:
 #aise
 #xcept Exception:
 #eturn None

 #ef lstat(self):
 #"" Return an os.lstat() tuple. """
 #eturn Stat(self, py.error.checked_call(os.lstat, self.strpath))

 #ef setmtime(self, mtime=None):
 #"" set modification time for the given path.  if 'mtime' is None
 #the default) then the file's mtime is set to current time.

 #ote that the resolution for 'mtime' is platform dependent.
 #""
 #f mtime is None:
 #eturn py.error.checked_call(os.utime, self.strpath, mtime)
 #ry:
 #eturn py.error.checked_call(os.utime, self.strpath, (-1, mtime))
 #xcept py.error.EINVAL:
 #eturn py.error.checked_call(os.utime, self.strpath, (self.atime(), mtime))

 #ef chdir(self):
 #"" change directory to self and return old current directory """
 #ry:
 #ld = self.__class__()
 #xcept py.error.ENOENT:
 #ld = None
 #y.error.checked_call(os.chdir, self.strpath)
 #eturn old


 #contextmanager
 #ef as_cwd(self):
 #""
 #eturn a context manager, which changes to the path's dir during the
 #anaged "with" context.
 #n __enter__ it returns the old dir, which might be ``None``.
 #""
 #ld = self.chdir()
 #ry:
 #ield old
 #inally:
 #f old is not None:
 #ld.chdir()

 #ef realpath(self):
 #"" return a new path which contains no symbolic links."""
 #eturn self.__class__(os.path.realpath(self.strpath))

 #ef atime(self):
 #"" return last access time of the path. """
 #eturn self.stat().atime

 #ef __repr__(self):
 #eturn 'local(%r)' % self.strpath

 #ef __str__(self):
 #"" return string representation of the Path. """
 #eturn self.strpath

 #ef chmod(self, mode, rec=0):
 #"" change permissions to the given mode. If mode is an
 #nteger it directly encodes the os-specific modes.
 #f rec is True perform recursively.
 #""
 #f not isinstance(mode, int):
 #aise TypeError("mode %r must be an integer" % (mode,))
 #f rec:
 #or x in self.visit(rec=rec):
 #y.error.checked_call(os.chmod, str(x), mode)
 #y.error.checked_call(os.chmod, self.strpath, mode)

 #ef pypkgpath(self):
 #"" return the Python package path by looking for the last
 #irectory upwards which still contains an __init__.py.
 #eturn None if a pkgpath can not be determined.
 #""
 #kgpath = None
 #or parent in self.parts(reverse=True):
 #f parent.isdir():
 #f not parent.join('__init__.py').exists():
 #reak
 #f not isimportable(parent.basename):
 #reak
 #kgpath = parent
 #eturn pkgpath

 #ef _ensuresyspath(self, ensuremode, path):
 #f ensuremode:
 # = str(path)
 #f ensuremode == "append":
 #f s not in sys.path:
 #ys.path.append(s)
 #lse:
 #f s != sys.path[0]:
 #ys.path.insert(0, s)

 #ef pyimport(self, modname=None, ensuresyspath=True):
 #"" return path as an imported python module.

 #f modname is None, look for the containing package
 #nd construct an according module name.
 #he module will be put/looked up in sys.modules.
 #f ensuresyspath is True then the root dir for importing
 #he file (taking __init__.py files into account) will
 #e prepended to sys.path if it isn't there already.
 #f ensuresyspath=="append" the root dir will be appended
 #f it isn't already contained in sys.path.
 #f ensuresyspath is False no modification of syspath happens.

 #pecial value of ensuresyspath=="importlib" is intended
 #urely for using in pytest, it is capable only of importing
 #eparate .py files outside packages, e.g. for test suite
 #ithout any __init__.py file. It effectively allows having
 #ame-named test modules in different places and offers
 #ild opt-in via this option. Note that it works only in
 #ecent versions of python.
 #""
 #f not self.check():
 #aise py.error.ENOENT(self)

 #f ensuresyspath == 'importlib':
 #f modname is None:
 #odname = self.purebasename
 #f not ALLOW_IMPORTLIB_MODE:
 #aise ImportError(
 #Can't use importlib due to old version of Python")
 #pec = importlib.util.spec_from_file_location(
 #odname, str(self))
 #f spec is None:
 #aise ImportError(
 #Can't find module %s at location %s" %
 #modname, str(self))
 #
 #od = importlib.util.module_from_spec(spec)
 #pec.loader.exec_module(mod)
 #eturn mod

 #kgpath = None
 #f modname is None:
 #kgpath = self.pypkgpath()
 #f pkgpath is not None:
 #kgroot = pkgpath.dirpath()
 #ames = self.new(ext="").relto(pkgroot).split(self.sep)
 #f names[-1] == "__init__":
 #ames.pop()
 #odname = ".".join(names)
 #lse:
 #kgroot = self.dirpath()
 #odname = self.purebasename

 #elf._ensuresyspath(ensuresyspath, pkgroot)
 #_import__(modname)
 #od = sys.modules[modname]
 #f self.basename == "__init__.py":
 #eturn mod # we don't check anything as we might
                       # be in a namespace package ... too icky to check
 #odfile = mod.__file__
 #f modfile[-4:] in ('.pyc', '.pyo'):
 #odfile = modfile[:-1]
 #lif modfile.endswith('$py.class'):
 #odfile = modfile[:-9] + '.py'
 #f modfile.endswith(os.path.sep + "__init__.py"):
 #f self.basename != "__init__.py":
 #odfile = modfile[:-12]
 #ry:
 #ssame = self.samefile(modfile)
 #xcept py.error.ENOENT:
 #ssame = False
 #f not issame:
 #gnore = os.getenv('PY_IGNORE_IMPORTMISMATCH')
 #f ignore != '1':
 #aise self.ImportMismatchError(modname, modfile, self)
 #eturn mod
 #lse:
 #ry:
 #eturn sys.modules[modname]
 #xcept KeyError:
                # we have a custom modname, do a pseudo-import
 #mport types
 #od = types.ModuleType(modname)
 #od.__file__ = str(self)
 #ys.modules[modname] = mod
 #ry:
 #y.builtin.execfile(str(self), mod.__dict__)
 #xcept:
 #el sys.modules[modname]
 #aise
 #eturn mod

 #ef sysexec(self, *argv, **popen_opts):
 #"" return stdout text from executing a system child process,
 #here the 'self' path points to executable.
 #he process is directly invoked and not through a system shell.
 #""
 #rom subprocess import Popen, PIPE
 #rgv = map_as_list(str, argv)
 #open_opts['stdout'] = popen_opts['stderr'] = PIPE
 #roc = Popen([str(self)] + argv, **popen_opts)
 #tdout, stderr = proc.communicate()
 #et = proc.wait()
 #f py.builtin._isbytes(stdout):
 #tdout = py.builtin._totext(stdout, sys.getdefaultencoding())
 #f ret != 0:
 #f py.builtin._isbytes(stderr):
 #tderr = py.builtin._totext(stderr, sys.getdefaultencoding())
 #aise py.process.cmdexec.Error(ret, ret, str(self),
 #tdout, stderr,)
 #eturn stdout

 #ef sysfind(cls, name, checker=None, paths=None):
 #"" return a path object found by looking at the systems
 #nderlying PATH specification. If the checker is not None
 #t will be invoked to filter matching paths.  If a binary
 #annot be found, None is returned
 #ote: This is probably not working on plain win32 systems
 #ut may work on cygwin.
 #""
 #f isabs(name):
 # = py.path.local(name)
 #f p.check(file=1):
 #eturn p
 #lse:
 #f paths is None:
 #f iswin32:
 #aths = os.environ['Path'].split(';')
 #f '' not in paths and '.' not in paths:
 #aths.append('.')
 #ry:
 #ystemroot = os.environ['SYSTEMROOT']
 #xcept KeyError:
 #ass
 #lse:
 #aths = [path.replace('%SystemRoot%', systemroot)
 #or path in paths]
 #lse:
 #aths = os.environ['PATH'].split(':')
 #ryadd = []
 #f iswin32:
 #ryadd += os.environ['PATHEXT'].split(os.pathsep)
 #ryadd.append("")

 #or x in paths:
 #or addext in tryadd:
 # = py.path.local(x).join(name, abs=True) + addext
 #ry:
 #f p.check(file=1):
 #f checker:
 #f not checker(p):
 #ontinue
 #eturn p
 #xcept py.error.EACCES:
 #ass
 #eturn None
 #ysfind = classmethod(sysfind)

 #ef _gethomedir(cls):
 #ry:
 # = os.environ['HOME']
 #xcept KeyError:
 #ry:
 # = os.environ["HOMEDRIVE"] + os.environ['HOMEPATH']
 #xcept KeyError:
 #eturn None
 #eturn cls(x)
 #gethomedir = classmethod(_gethomedir)

    # """
    # special class constructors for local filesystem paths
    # """
 #classmethod
 #ef get_temproot(cls):
 #"" return the system's temporary directory
 #where tempfiles are usually created in)
 #""
 #mport tempfile
 #eturn py.path.local(tempfile.gettempdir())

 #classmethod
 #ef mkdtemp(cls, rootdir=None):
 #"" return a Path object pointing to a fresh new temporary directory
 #which we created ourself).
 #""
 #mport tempfile
 #f rootdir is None:
 #ootdir = cls.get_temproot()
 #eturn cls(py.error.checked_call(tempfile.mkdtemp, dir=str(rootdir)))

 #ef make_numbered_dir(cls, prefix='session-', rootdir=None, keep=3,
 #ock_timeout=172800):   # two days
 #"" return unique directory with a number greater than the current
 #aximum one.  The number is assumed to start directly after prefix.
 #f keep is true directories with a number less than (maxnum-keep)
 #ill be removed. If .lock files are used (lock_timeout non-zero),
 #lgorithm is multi-process safe.
 #""
 #f rootdir is None:
 #ootdir = cls.get_temproot()

 #prefix = prefix.lower()
 #ef parse_num(path):
 #"" parse the number out of a path (if it matches the prefix) """
 #basename = path.basename.lower()
 #f nbasename.startswith(nprefix):
 #ry:
 #eturn int(nbasename[len(nprefix):])
 #xcept ValueError:
 #ass

 #ef create_lockfile(path):
 #"" exclusively create lockfile. Throws when failed """
 #ypid = os.getpid()
 #ockfile = path.join('.lock')
 #f hasattr(lockfile, 'mksymlinkto'):
 #ockfile.mksymlinkto(str(mypid))
 #lse:
 #d = py.error.checked_call(os.open, str(lockfile), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
 #ith os.fdopen(fd, 'w') as f:
 #.write(str(mypid))
 #eturn lockfile

 #ef atexit_remove_lockfile(lockfile):
 #"" ensure lockfile is removed at process exit """
 #ypid = os.getpid()
 #ef try_remove_lockfile():
                # in a fork() situation, only the last process should
                # remove the .lock, otherwise the other processes run the
                # risk of seeing their temporary dir disappear.  For now
                # we remove the .lock in the parent only (i.e. we assume
                # that the children finish before the parent).
 #f os.getpid() != mypid:
 #eturn
 #ry:
 #ockfile.remove()
 #xcept py.error.Error:
 #ass
 #texit.register(try_remove_lockfile)

        # compute the maximum number currently in use with the prefix
 #astmax = None
 #hile True:
 #axnum = -1
 #or path in rootdir.listdir():
 #um = parse_num(path)
 #f num is not None:
 #axnum = max(maxnum, num)

            # make the new directory
 #ry:
 #dir = rootdir.mkdir(prefix + str(maxnum+1))
 #f lock_timeout:
 #ockfile = create_lockfile(udir)
 #texit_remove_lockfile(lockfile)
 #xcept (py.error.EEXIST, py.error.ENOENT, py.error.EBUSY):
                # race condition (1): another thread/process created the dir
                #                     in the meantime - try again
                # race condition (2): another thread/process spuriously acquired
                #                     lock treating empty directory as candidate
                #                     for removal - try again
                # race condition (3): another thread/process tried to create the lock at
                #                     the same time (happened in Python 3.3 on Windows)
                # https://ci.appveyor.com/project/pytestbot/py/build/1.0.21/job/ffi85j4c0lqwsfwa
 #f lastmax == maxnum:
 #aise
 #astmax = maxnum
 #ontinue
 #reak

 #ef get_mtime(path):
 #"" read file modification time """
 #ry:
 #eturn path.lstat().mtime
 #xcept py.error.Error:
 #ass

 #arbage_prefix = prefix + 'garbage-'

 #ef is_garbage(path):
 #"" check if path denotes directory scheduled for removal """
 #n = path.basename
 #eturn bn.startswith(garbage_prefix)

        # prune old directories
 #dir_time = get_mtime(udir)
 #f keep and udir_time:
 #or path in rootdir.listdir():
 #um = parse_num(path)
 #f num is not None and num <= (maxnum - keep):
 #ry:
                        # try acquiring lock to remove directory as exclusive user
 #f lock_timeout:
 #reate_lockfile(path)
 #xcept (py.error.EEXIST, py.error.ENOENT, py.error.EBUSY):
 #ath_time = get_mtime(path)
 #f not path_time:
                            # assume directory doesn't exist now
 #ontinue
 #f abs(udir_time - path_time) < lock_timeout:
                            # assume directory with lockfile exists
                            # and lock timeout hasn't expired yet
 #ontinue

                    # path dir locked for exclusive use
                    # and scheduled for removal to avoid another thread/process
                    # treating it as a new directory or removal candidate
 #arbage_path = rootdir.join(garbage_prefix + str(uuid.uuid4()))
 #ry:
 #ath.rename(garbage_path)
 #arbage_path.remove(rec=1)
 #xcept KeyboardInterrupt:
 #aise
 #xcept: # this might be py.error.Error, WindowsError ...
 #ass
 #f is_garbage(path):
 #ry:
 #ath.remove(rec=1)
 #xcept KeyboardInterrupt:
 #aise
 #xcept: # this might be py.error.Error, WindowsError ...
 #ass

        # make link...
 #ry:
 #sername = os.environ['USER']           #linux, et al
 #xcept KeyError:
 #ry:
 #sername = os.environ['USERNAME']   #windows
 #xcept KeyError:
 #sername = 'current'

 #rc  = str(udir)
 #est = src[:src.rfind('-')] + '-' + username
 #ry:
 #s.unlink(dest)
 #xcept OSError:
 #ass
 #ry:
 #s.symlink(src, dest)
 #xcept (OSError, AttributeError, NotImplementedError):
 #ass

 #eturn udir
 #ake_numbered_dir = classmethod(make_numbered_dir)


def copymode(src, dest):
 #"" copy permission from src to dst. """
 #mport shutil
 #hutil.copymode(src, dest)


def copystat(src, dest):
 #"" copy permission,  last modification time,
 #ast access time, and flags from src to dst."""
 #mport shutil
 #hutil.copystat(str(src), str(dest))


def copychunked(src, dest):
 #hunksize = 524288  # half a meg of bytes
 #src = src.open('rb')
 #ry:
 #dest = dest.open('wb')
 #ry:
 #hile 1:
 #uf = fsrc.read(chunksize)
 #f not buf:
 #reak
 #dest.write(buf)
 #inally:
 #dest.close()
 #inally:
 #src.close()


def isimportable(name):
 #f name and (name[0].isalpha() or name[0] == '_'):
 #ame = name.replace("_", '')
 #eturn not name or name.isalnum()
