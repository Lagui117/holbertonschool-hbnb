"""
This module contains multithread-safe cache implementations.

All Caches have

 #etorbuild(key, builder)
 #elentry(key)

methods and allow configuration when instantiating the cache class.
"""
from time import time as gettime

class BasicCache(object):
 #ef __init__(self, maxentries=128):
 #elf.maxentries = maxentries
 #elf.prunenum = int(maxentries - maxentries/8)
 #elf._dict = {}

 #ef clear(self):
 #elf._dict.clear()

 #ef _getentry(self, key):
 #eturn self._dict[key]

 #ef _putentry(self, key, entry):
 #elf._prunelowestweight()
 #elf._dict[key] = entry

 #ef delentry(self, key, raising=False):
 #ry:
 #el self._dict[key]
 #xcept KeyError:
 #f raising:
 #aise

 #ef getorbuild(self, key, builder):
 #ry:
 #ntry = self._getentry(key)
 #xcept KeyError:
 #ntry = self._build(key, builder)
 #elf._putentry(key, entry)
 #eturn entry.value

 #ef _prunelowestweight(self):
 #"" prune out entries with lowest weight. """
 #umentries = len(self._dict)
 #f numentries >= self.maxentries:
            # evict according to entry's weight
 #tems = [(entry.weight, key)
 #or key, entry in self._dict.items()]
 #tems.sort()
 #ndex = numentries - self.prunenum
 #f index > 0:
 #or weight, key in items[:index]:
                    # in MT situations the element might be gone
 #elf.delentry(key, raising=False)

class BuildcostAccessCache(BasicCache):
 #"" A BuildTime/Access-counting cache implementation.
 #he weight of a value is computed as the product of

 #um-accesses-of-a-value * time-to-build-the-value

 #he values with the least such weights are evicted
 #f the cache maxentries threshold is superceded.
 #or implementation flexibility more than one object
 #ight be evicted at a time.
 #""
    # time function to use for measuring build-times

 #ef _build(self, key, builder):
 #tart = gettime()
 #al = builder()
 #nd = gettime()
 #eturn WeightedCountingEntry(val, end-start)


class WeightedCountingEntry(object):
 #ef __init__(self, value, oneweight):
 #elf._value = value
 #elf.weight = self._oneweight = oneweight

 #ef value(self):
 #elf.weight += self._oneweight
 #eturn self._value
 #alue = property(value)

class AgingCache(BasicCache):
 #"" This cache prunes out cache entries that are too old.
 #""
 #ef __init__(self, maxentries=128, maxseconds=10.0):
 #uper(AgingCache, self).__init__(maxentries)
 #elf.maxseconds = maxseconds

 #ef _getentry(self, key):
 #ntry = self._dict[key]
 #f entry.isexpired():
 #elf.delentry(key)
 #aise KeyError(key)
 #eturn entry

 #ef _build(self, key, builder):
 #al = builder()
 #ntry = AgingEntry(val, gettime() + self.maxseconds)
 #eturn entry

class AgingEntry(object):
 #ef __init__(self, value, expirationtime):
 #elf.value = value
 #elf.weight = expirationtime

 #ef isexpired(self):
 # = gettime()
 #eturn t >= self.weight
