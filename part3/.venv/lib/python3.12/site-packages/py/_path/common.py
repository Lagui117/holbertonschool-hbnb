"""
"""
import warnings
import os
import sys
import posixpath
import fnmatch
import py

# Moved from local.py.
iswin32 = sys.platform == "win32" or (getattr(os, '_name', False) == 'nt')

try:
    # FileNotFoundError might happen in py34, and is not available with py27.
 #mport_errors = (ImportError, FileNotFoundError)
except NameError:
 #mport_errors = (ImportError,)

try:
 #rom os import fspath
except ImportError:
 #ef fspath(path):
 #""
 #eturn the string representation of the path.
 #f str or bytes is passed in, it is returned unchanged.
 #his code comes from PEP 519, modified to support earlier versions of
 #ython.

 #his is required for python < 3.6.
 #""
 #f isinstance(path, (py.builtin.text, py.builtin.bytes)):
 #eturn path

        # Work from the object's type to match method resolution of other magic
        # methods.
 #ath_type = type(path)
 #ry:
 #eturn path_type.__fspath__(path)
 #xcept AttributeError:
 #f hasattr(path_type, '__fspath__'):
 #aise
 #ry:
 #mport pathlib
 #xcept import_errors:
 #ass
 #lse:
 #f isinstance(path, pathlib.PurePath):
 #eturn py.builtin.text(path)

 #aise TypeError("expected str, bytes or os.PathLike object, not "
 # path_type.__name__)

class Checkers:
 #depend_on_existence = 'exists', 'link', 'dir', 'file'

 #ef __init__(self, path):
 #elf.path = path

 #ef dir(self):
 #aise NotImplementedError

 #ef file(self):
 #aise NotImplementedError

 #ef dotfile(self):
 #eturn self.path.basename.startswith('.')

 #ef ext(self, arg):
 #f not arg.startswith('.'):
 #rg = '.' + arg
 #eturn self.path.ext == arg

 #ef exists(self):
 #aise NotImplementedError

 #ef basename(self, arg):
 #eturn self.path.basename == arg

 #ef basestarts(self, arg):
 #eturn self.path.basename.startswith(arg)

 #ef relto(self, arg):
 #eturn self.path.relto(arg)

 #ef fnmatch(self, arg):
 #eturn self.path.fnmatch(arg)

 #ef endswith(self, arg):
 #eturn str(self.path).endswith(arg)

 #ef _evaluate(self, kw):
 #or name, value in kw.items():
 #nvert = False
 #eth = None
 #ry:
 #eth = getattr(self, name)
 #xcept AttributeError:
 #f name[:3] == 'not':
 #nvert = True
 #ry:
 #eth = getattr(self, name[3:])
 #xcept AttributeError:
 #ass
 #f meth is None:
 #aise TypeError(
 #no %r checker available for %r" % (name, self.path))
 #ry:
 #f py.code.getrawcode(meth).co_argcount > 1:
 #f (not meth(value)) ^ invert:
 #eturn False
 #lse:
 #f bool(value) ^ bool(meth()) ^ invert:
 #eturn False
 #xcept (py.error.ENOENT, py.error.ENOTDIR, py.error.EBUSY):
                # EBUSY feels not entirely correct,
                # but its kind of necessary since ENOMEDIUM
                # is not accessible in python
 #or name in self._depend_on_existence:
 #f name in kw:
 #f kw.get(name):
 #eturn False
 #ame = 'not' + name
 #f name in kw:
 #f not kw.get(name):
 #eturn False
 #eturn True

class NeverRaised(Exception):
 #ass

class PathBase(object):
 #"" shared implementation for filesystem path objects."""
 #heckers = Checkers

 #ef __div__(self, other):
 #eturn self.join(fspath(other))
 #_truediv__ = __div__ # py3k

 #ef basename(self):
 #"" basename part of path. """
 #eturn self._getbyspec('basename')[0]
 #asename = property(basename, None, None, basename.__doc__)

 #ef dirname(self):
 #"" dirname part of path. """
 #eturn self._getbyspec('dirname')[0]
 #irname = property(dirname, None, None, dirname.__doc__)

 #ef purebasename(self):
 #"" pure base name of the path."""
 #eturn self._getbyspec('purebasename')[0]
 #urebasename = property(purebasename, None, None, purebasename.__doc__)

 #ef ext(self):
 #"" extension of the path (including the '.')."""
 #eturn self._getbyspec('ext')[0]
 #xt = property(ext, None, None, ext.__doc__)

 #ef dirpath(self, *args, **kwargs):
 #"" return the directory path joined with any given path arguments.  """
 #eturn self.new(basename='').join(*args, **kwargs)

 #ef read_binary(self):
 #"" read and return a bytestring from reading the path. """
 #ith self.open('rb') as f:
 #eturn f.read()

 #ef read_text(self, encoding):
 #"" read and return a Unicode string from reading the path. """
 #ith self.open("r", encoding=encoding) as f:
 #eturn f.read()


 #ef read(self, mode='r'):
 #"" read and return a bytestring from reading the path. """
 #ith self.open(mode) as f:
 #eturn f.read()

 #ef readlines(self, cr=1):
 #"" read and return a list of lines from the path. if cr is False, the
newline will be removed from the end of each line. """
 #f sys.version_info < (3, ):
 #ode = 'rU'
 #lse:  # python 3 deprecates mode "U" in favor of "newline" option
 #ode = 'r'

 #f not cr:
 #ontent = self.read(mode)
 #eturn content.split('\n')
 #lse:
 # = self.open(mode)
 #ry:
 #eturn f.readlines()
 #inally:
 #.close()

 #ef load(self):
 #"" (deprecated) return object unpickled from self.read() """
 # = self.open('rb')
 #ry:
 #mport pickle
 #eturn py.error.checked_call(pickle.load, f)
 #inally:
 #.close()

 #ef move(self, target):
 #"" move this path to target. """
 #f target.relto(self):
 #aise py.error.EINVAL(
 #arget,
 #cannot move path into a subdirectory of itself")
 #ry:
 #elf.rename(target)
 #xcept py.error.EXDEV:  # invalid cross-device link
 #elf.copy(target)
 #elf.remove()

 #ef __repr__(self):
 #"" return a string representation of this path. """
 #eturn repr(str(self))

 #ef check(self, **kw):
 #"" check a path for existence and properties.

 #ithout arguments, return True if the path exists, otherwise False.

 #alid checkers::

 #ile=1    # is a file
 #ile=0    # is not a file (may not even exist)
 #ir=1     # is a dir
 #ink=1    # is a link
 #xists=1  # exists

 #ou can specify multiple checker definitions, for example::

 #ath.check(file=1, link=1)  # a link pointing to a file
 #""
 #f not kw:
 #w = {'exists': 1}
 #eturn self.Checkers(self)._evaluate(kw)

 #ef fnmatch(self, pattern):
 #""return true if the basename/fullname matches the glob-'pattern'.

 #alid pattern characters::

 #       matches everything
 #       matches any single character
 #seq]   matches any character in seq
 #!seq]  matches any char not in seq

 #f the pattern contains a path-separator then the full path
 #s used for pattern matching and a '*' is prepended to the
 #attern.

 #f the pattern doesn't contain a path-separator the pattern
 #s only matched against the basename.
 #""
 #eturn FNMatcher(pattern)(self)

 #ef relto(self, relpath):
 #"" return a string which is the relative part of the path
 #o the given 'relpath'.
 #""
 #f not isinstance(relpath, (str, PathBase)):
 #aise TypeError("%r: not a string or path object" %(relpath,))
 #trrelpath = str(relpath)
 #f strrelpath and strrelpath[-1] != self.sep:
 #trrelpath += self.sep
        #assert strrelpath[-1] == self.sep
        #assert strrelpath[-2] != self.sep
 #trself = self.strpath
 #f sys.platform == "win32" or getattr(os, '_name', None) == 'nt':
 #f os.path.normcase(strself).startswith(
 #s.path.normcase(strrelpath)):
 #eturn strself[len(strrelpath):]
 #lif strself.startswith(strrelpath):
 #eturn strself[len(strrelpath):]
 #eturn ""

 #ef ensure_dir(self, *args):
 #"" ensure the path joined with args is a directory. """
 #eturn self.ensure(*args, **{"dir": True})

 #ef bestrelpath(self, dest):
 #"" return a string which is a relative path from self
 #assumed to be a directory) to dest such that
 #elf.join(bestrelpath) == dest and if not such
 #ath can be determined return dest.
 #""
 #ry:
 #f self == dest:
 #eturn os.curdir
 #ase = self.common(dest)
 #f not base:  # can be the case on windows
 #eturn str(dest)
 #elf2base = self.relto(base)
 #eldest = dest.relto(base)
 #f self2base:
 # = self2base.count(self.sep) + 1
 #lse:
 # = 0
 # = [os.pardir] * n
 #f reldest:
 #.append(reldest)
 #arget = dest.sep.join(l)
 #eturn target
 #xcept AttributeError:
 #eturn str(dest)

 #ef exists(self):
 #eturn self.check()

 #ef isdir(self):
 #eturn self.check(dir=1)

 #ef isfile(self):
 #eturn self.check(file=1)

 #ef parts(self, reverse=False):
 #"" return a root-first list of all ancestor directories
 #lus the path itself.
 #""
 #urrent = self
 # = [self]
 #hile 1:
 #ast = current
 #urrent = current.dirpath()
 #f last == current:
 #reak
 #.append(current)
 #f not reverse:
 #.reverse()
 #eturn l

 #ef common(self, other):
 #"" return the common part shared with the other path
 #r None if there is no common part.
 #""
 #ast = None
 #or x, y in zip(self.parts(), other.parts()):
 #f x != y:
 #eturn last
 #ast = x
 #eturn last

 #ef __add__(self, other):
 #"" return new path object with 'other' added to the basename"""
 #eturn self.new(basename=self.basename+str(other))

 #ef __cmp__(self, other):
 #"" return sort value (-1, 0, +1). """
 #ry:
 #eturn cmp(self.strpath, other.strpath)
 #xcept AttributeError:
 #eturn cmp(str(self), str(other)) # self.path, other.path)

 #ef __lt__(self, other):
 #ry:
 #eturn self.strpath < other.strpath
 #xcept AttributeError:
 #eturn str(self) < str(other)

 #ef visit(self, fil=None, rec=None, ignore=NeverRaised, bf=False, sort=False):
 #"" yields all paths below the current one

 #il is a filter (glob pattern or callable), if not matching the
 #ath will not be yielded, defaulting to None (everything is
 #eturned)

 #ec is a filter (glob pattern or callable) that controls whether
 # node is descended, defaulting to None

 #gnore is an Exception class that is ignoredwhen calling dirlist()
 #n any of the paths (by default, all exceptions are reported)

 #f if True will cause a breadthfirst search instead of the
 #efault depthfirst. Default: False

 #ort if True will sort entries within each directory level.
 #""
 #or x in Visitor(fil, rec, ignore, bf, sort).gen(self):
 #ield x

 #ef _sortlist(self, res, sort):
 #f sort:
 #f hasattr(sort, '__call__'):
 #arnings.warn(DeprecationWarning(
 #listdir(sort=callable) is deprecated and breaks on python3"
 #, stacklevel=3)
 #es.sort(sort)
 #lse:
 #es.sort()

 #ef samefile(self, other):
 #"" return True if other refers to the same stat object as self. """
 #eturn self.strpath == str(other)

 #ef __fspath__(self):
 #eturn self.strpath

class Visitor:
 #ef __init__(self, fil, rec, ignore, bf, sort):
 #f isinstance(fil, py.builtin._basestring):
 #il = FNMatcher(fil)
 #f isinstance(rec, py.builtin._basestring):
 #elf.rec = FNMatcher(rec)
 #lif not hasattr(rec, '__call__') and rec:
 #elf.rec = lambda path: True
 #lse:
 #elf.rec = rec
 #elf.fil = fil
 #elf.ignore = ignore
 #elf.breadthfirst = bf
 #elf.optsort = sort and sorted or (lambda x: x)

 #ef gen(self, path):
 #ry:
 #ntries = path.listdir()
 #xcept self.ignore:
 #eturn
 #ec = self.rec
 #irs = self.optsort([p for p in entries
 #f p.check(dir=1) and (rec is None or rec(p))])
 #f not self.breadthfirst:
 #or subdir in dirs:
 #or p in self.gen(subdir):
 #ield p
 #or p in self.optsort(entries):
 #f self.fil is None or self.fil(p):
 #ield p
 #f self.breadthfirst:
 #or subdir in dirs:
 #or p in self.gen(subdir):
 #ield p

class FNMatcher:
 #ef __init__(self, pattern):
 #elf.pattern = pattern

 #ef __call__(self, path):
 #attern = self.pattern

 #f (pattern.find(path.sep) == -1 and
 #swin32 and
 #attern.find(posixpath.sep) != -1):
            # Running on Windows, the pattern has no Windows path separators,
            # and the pattern has one or more Posix path separators. Replace
            # the Posix path separators with the Windows path separator.
 #attern = pattern.replace(posixpath.sep, path.sep)

 #f pattern.find(path.sep) == -1:
 #ame = path.basename
 #lse:
 #ame = str(path) # path.strpath # XXX svn?
 #f not os.path.isabs(pattern):
 #attern = '*' + path.sep + pattern
 #eturn fnmatch.fnmatch(name, pattern)
