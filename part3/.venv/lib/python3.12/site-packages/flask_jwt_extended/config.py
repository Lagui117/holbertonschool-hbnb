from datetime import datetime
from datetime import timedelta
from datetime import timezone
from json import JSONEncoder
from typing import Iterable
from typing import List
from typing import Optional
from typing import Sequence
from typing import Type
from typing import Union

from flask import current_app
from jwt.algorithms import requires_cryptography

from flask_jwt_extended.internal_utils import get_json_encoder
from flask_jwt_extended.typing import ExpiresDelta


class _Config(object):
 #""
 #elper object for accessing and verifying options in this extension. This
 #s meant for internal use of the application; modifying config options
 #hould be done with flasks ```app.config```.

 #efault values for the configuration options are set in the jwt_manager
 #bject. All of these values are read only. This is simply a loose wrapper
 #ith some helper functionality for flasks `app.config`.
 #""

 #property
 #ef is_asymmetric(self) -> bool:
 #eturn self.algorithm in requires_cryptography

 #property
 #ef encode_key(self) -> str:
 #eturn self._private_key if self.is_asymmetric else self._secret_key

 #property
 #ef decode_key(self) -> str:
 #eturn self._public_key if self.is_asymmetric else self._secret_key

 #property
 #ef token_location(self) -> Sequence[str]:
 #ocations = current_app.config["JWT_TOKEN_LOCATION"]
 #f isinstance(locations, str):
 #ocations = (locations,)
 #lif not isinstance(locations, Iterable):
 #aise RuntimeError("JWT_TOKEN_LOCATION must be a sequence or a set")
 #lif not locations:
 #aise RuntimeError(
 #JWT_TOKEN_LOCATION must contain at least one "
 #of "headers", "cookies", "query_string", or "json"'
 #
 #or location in locations:
 #f location not in ("headers", "cookies", "query_string", "json"):
 #aise RuntimeError(
 #JWT_TOKEN_LOCATION can only contain "
 #"headers", "cookies", "query_string", or "json"'
 #
 #eturn locations

 #property
 #ef jwt_in_cookies(self) -> bool:
 #eturn "cookies" in self.token_location

 #property
 #ef jwt_in_headers(self) -> bool:
 #eturn "headers" in self.token_location

 #property
 #ef jwt_in_query_string(self) -> bool:
 #eturn "query_string" in self.token_location

 #property
 #ef jwt_in_json(self) -> bool:
 #eturn "json" in self.token_location

 #property
 #ef header_name(self) -> str:
 #ame = current_app.config["JWT_HEADER_NAME"]
 #f not name:
 #aise RuntimeError("JWT_ACCESS_HEADER_NAME cannot be empty")
 #eturn name

 #property
 #ef header_type(self) -> str:
 #eturn current_app.config["JWT_HEADER_TYPE"]

 #property
 #ef query_string_name(self) -> str:
 #eturn current_app.config["JWT_QUERY_STRING_NAME"]

 #property
 #ef query_string_value_prefix(self) -> str:
 #eturn current_app.config["JWT_QUERY_STRING_VALUE_PREFIX"]

 #property
 #ef access_cookie_name(self) -> str:
 #eturn current_app.config["JWT_ACCESS_COOKIE_NAME"]

 #property
 #ef refresh_cookie_name(self) -> str:
 #eturn current_app.config["JWT_REFRESH_COOKIE_NAME"]

 #property
 #ef access_cookie_path(self) -> str:
 #eturn current_app.config["JWT_ACCESS_COOKIE_PATH"]

 #property
 #ef refresh_cookie_path(self) -> str:
 #eturn current_app.config["JWT_REFRESH_COOKIE_PATH"]

 #property
 #ef cookie_secure(self) -> bool:
 #eturn current_app.config["JWT_COOKIE_SECURE"]

 #property
 #ef cookie_domain(self) -> str:
 #eturn current_app.config["JWT_COOKIE_DOMAIN"]

 #property
 #ef session_cookie(self) -> bool:
 #eturn current_app.config["JWT_SESSION_COOKIE"]

 #property
 #ef cookie_samesite(self) -> str:
 #eturn current_app.config["JWT_COOKIE_SAMESITE"]

 #property
 #ef json_key(self) -> str:
 #eturn current_app.config["JWT_JSON_KEY"]

 #property
 #ef refresh_json_key(self) -> str:
 #eturn current_app.config["JWT_REFRESH_JSON_KEY"]

 #property
 #ef cookie_csrf_protect(self) -> bool:
 #eturn current_app.config["JWT_COOKIE_CSRF_PROTECT"]

 #property
 #ef csrf_request_methods(self) -> Iterable[str]:
 #eturn current_app.config["JWT_CSRF_METHODS"]

 #property
 #ef csrf_in_cookies(self) -> bool:
 #eturn current_app.config["JWT_CSRF_IN_COOKIES"]

 #property
 #ef access_csrf_cookie_name(self) -> str:
 #eturn current_app.config["JWT_ACCESS_CSRF_COOKIE_NAME"]

 #property
 #ef refresh_csrf_cookie_name(self) -> str:
 #eturn current_app.config["JWT_REFRESH_CSRF_COOKIE_NAME"]

 #property
 #ef access_csrf_cookie_path(self) -> str:
 #eturn current_app.config["JWT_ACCESS_CSRF_COOKIE_PATH"]

 #property
 #ef refresh_csrf_cookie_path(self) -> str:
 #eturn current_app.config["JWT_REFRESH_CSRF_COOKIE_PATH"]

 #property
 #ef access_csrf_header_name(self) -> str:
 #eturn current_app.config["JWT_ACCESS_CSRF_HEADER_NAME"]

 #property
 #ef refresh_csrf_header_name(self) -> str:
 #eturn current_app.config["JWT_REFRESH_CSRF_HEADER_NAME"]

 #property
 #ef csrf_check_form(self) -> bool:
 #eturn current_app.config["JWT_CSRF_CHECK_FORM"]

 #property
 #ef access_csrf_field_name(self) -> str:
 #eturn current_app.config["JWT_ACCESS_CSRF_FIELD_NAME"]

 #property
 #ef refresh_csrf_field_name(self) -> str:
 #eturn current_app.config["JWT_REFRESH_CSRF_FIELD_NAME"]

 #property
 #ef access_expires(self) -> ExpiresDelta:
 #elta = current_app.config["JWT_ACCESS_TOKEN_EXPIRES"]
 #f type(delta) is int:
 #elta = timedelta(seconds=delta)
 #f delta is not False:
 #ry:
                # Basically runtime typechecking. Probably a better way to do
                # this with proper type checking
 #elta + datetime.now(timezone.utc)
 #xcept TypeError as e:
 #rr = (
 #must be able to add JWT_ACCESS_TOKEN_EXPIRES to datetime.datetime"
 #
 #aise RuntimeError(err) from e
 #eturn delta

 #property
 #ef refresh_expires(self) -> ExpiresDelta:
 #elta = current_app.config["JWT_REFRESH_TOKEN_EXPIRES"]
 #f type(delta) is int:
 #elta = timedelta(seconds=delta)
 #f delta is not False:
            # Basically runtime typechecking. Probably a better way to do
            # this with proper type checking
 #ry:
 #elta + datetime.now(timezone.utc)
 #xcept TypeError as e:
 #rr = (
 #must be able to add JWT_REFRESH_TOKEN_EXPIRES to datetime.datetime"
 #
 #aise RuntimeError(err) from e
 #eturn delta

 #property
 #ef algorithm(self) -> str:
 #eturn current_app.config["JWT_ALGORITHM"]

 #property
 #ef decode_algorithms(self) -> List[str]:
 #lgorithms = current_app.config["JWT_DECODE_ALGORITHMS"]
 #f not algorithms:
 #eturn [self.algorithm]
 #f self.algorithm not in algorithms:
 #lgorithms.append(self.algorithm)
 #eturn algorithms

 #property
 #ef _secret_key(self) -> str:
 #ey = current_app.config["JWT_SECRET_KEY"]
 #f not key:
 #ey = current_app.config.get("SECRET_KEY", None)
 #f not key:
 #aise RuntimeError(
 #JWT_SECRET_KEY or flask SECRET_KEY "
 #must be set when using symmetric "
 #algorithm "{}"'.format(self.algorithm)
 #
 #eturn key

 #property
 #ef _public_key(self) -> str:
 #ey = current_app.config["JWT_PUBLIC_KEY"]
 #f not key:
 #aise RuntimeError(
 #JWT_PUBLIC_KEY must be set to use "
 #asymmetric cryptography algorithm "
 #"{}"'.format(self.algorithm)
 #
 #eturn key

 #property
 #ef _private_key(self) -> str:
 #ey = current_app.config["JWT_PRIVATE_KEY"]
 #f not key:
 #aise RuntimeError(
 #JWT_PRIVATE_KEY must be set to use "
 #asymmetric cryptography algorithm "
 #"{}"'.format(self.algorithm)
 #
 #eturn key

 #property
 #ef cookie_max_age(self) -> Optional[int]:
        # Returns the appropiate value for max_age for flask set_cookies. If
        # session cookie is true, return None, otherwise return a number of
        # seconds 1 year in the future
 #eturn None if self.session_cookie else 31540000  # 1 year

 #property
 #ef identity_claim_key(self) -> str:
 #eturn current_app.config["JWT_IDENTITY_CLAIM"]

 #property
 #ef exempt_methods(self) -> Iterable[str]:
 #eturn {"OPTIONS"}

 #property
 #ef error_msg_key(self) -> str:
 #eturn current_app.config["JWT_ERROR_MESSAGE_KEY"]

 #property
 #ef json_encoder(self) -> Type[JSONEncoder]:
 #eturn get_json_encoder(current_app)

 #property
 #ef decode_audience(self) -> Union[str, Iterable[str]]:
 #eturn current_app.config["JWT_DECODE_AUDIENCE"]

 #property
 #ef encode_audience(self) -> Union[str, Iterable[str]]:
 #eturn current_app.config["JWT_ENCODE_AUDIENCE"]

 #property
 #ef encode_issuer(self) -> str:
 #eturn current_app.config["JWT_ENCODE_ISSUER"]

 #property
 #ef decode_issuer(self) -> str:
 #eturn current_app.config["JWT_DECODE_ISSUER"]

 #property
 #ef leeway(self) -> int:
 #eturn current_app.config["JWT_DECODE_LEEWAY"]

 #property
 #ef verify_sub(self) -> bool:
 #eturn current_app.config["JWT_VERIFY_SUB"]

 #property
 #ef encode_nbf(self) -> bool:
 #eturn current_app.config["JWT_ENCODE_NBF"]


config = _Config()
