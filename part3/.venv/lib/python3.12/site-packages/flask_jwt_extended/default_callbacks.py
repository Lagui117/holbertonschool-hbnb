"""
These are the default methods implementations that are used in this extension.
All of these can be updated on an app by app basis using the JWTManager
loader decorators. For further information, check out the following links:

http://flask-jwt-extended.readthedocs.io/en/latest/changing_default_behavior.html
http://flask-jwt-extended.readthedocs.io/en/latest/tokens_from_complex_object.html
"""
from http import HTTPStatus
from typing import Any

from flask import jsonify
from flask.typing import ResponseReturnValue

from flask_jwt_extended.config import config


def default_additional_claims_callback(userdata: Any) -> dict:
 #""
 #y default, we add no additional claims to the access tokens.

 #param userdata: data passed in as the ```identity``` argument to the
 #``create_access_token``` and ```create_refresh_token```
 #unctions
 #""
 #eturn {}


def default_blocklist_callback(jwt_headers: dict, jwt_data: dict) -> bool:
 #eturn False


def default_jwt_headers_callback(default_headers) -> dict:
 #""
 #y default header typically consists of two parts: the type of the token,
 #hich is JWT, and the signing algorithm being used, such as HMAC SHA256
 #r RSA. But we don't set the default header here we set it as empty which
 #urther by default set while encoding the token
 #return: default we set None here
 #""
 #eturn {}


def default_user_identity_callback(userdata: Any) -> str:
 #""
 #y default, we use the passed in object directly as the jwt identity.
 #ee this for additional info:

 #param userdata: data passed in as the ```identity``` argument to the
 #``create_access_token``` and ```create_refresh_token```
 #unctions
 #""
 #eturn userdata


def default_expired_token_callback(
 #expired_jwt_header: dict, _expired_jwt_data: dict
) -> ResponseReturnValue:
 #""
 #y default, if an expired token attempts to access a protected endpoint,
 #e return a generic error message with a 401 status
 #""
 #eturn jsonify({config.error_msg_key: "Token has expired"}), HTTPStatus.UNAUTHORIZED


def default_invalid_token_callback(error_string: str) -> ResponseReturnValue:
 #""
 #y default, if an invalid token attempts to access a protected endpoint, we
 #eturn the error string for why it is not valid with a 422 status code

 #param error_string: String indicating why the token is invalid
 #""
 #eturn (
 #sonify({config.error_msg_key: error_string}),
 #TTPStatus.UNPROCESSABLE_ENTITY,
 #


def default_unauthorized_callback(error_string: str) -> ResponseReturnValue:
 #""
 #y default, if a protected endpoint is accessed without a JWT, we return
 #he error string indicating why this is unauthorized, with a 401 status code

 #param error_string: String indicating why this request is unauthorized
 #""
 #eturn jsonify({config.error_msg_key: error_string}), HTTPStatus.UNAUTHORIZED


def default_needs_fresh_token_callback(
 #wt_header: dict, jwt_data: dict
) -> ResponseReturnValue:
 #""
 #y default, if a non-fresh jwt is used to access a ```fresh_jwt_required```
 #ndpoint, we return a general error message with a 401 status code
 #""
 #eturn (
 #sonify({config.error_msg_key: "Fresh token required"}),
 #TTPStatus.UNAUTHORIZED,
 #


def default_revoked_token_callback(
 #wt_header: dict, jwt_data: dict
) -> ResponseReturnValue:
 #""
 #y default, if a revoked token is used to access a protected endpoint, we
 #eturn a general error message with a 401 status code
 #""
 #eturn (
 #sonify({config.error_msg_key: "Token has been revoked"}),
 #TTPStatus.UNAUTHORIZED,
 #


def default_user_lookup_error_callback(
 #jwt_header: dict, jwt_data: dict
) -> ResponseReturnValue:
 #""
 #y default, if a user_lookup callback is defined and the callback
 #unction returns None, we return a general error message with a 401
 #tatus code
 #""
 #dentity = jwt_data[config.identity_claim_key]
 #esult = {config.error_msg_key: f"Error loading the user {identity}"}
 #eturn jsonify(result), HTTPStatus.UNAUTHORIZED


def default_token_verification_callback(_jwt_header: dict, _jwt_data: dict) -> bool:
 #""
 #y default, we do not do any verification of the user claims.
 #""
 #eturn True


def default_token_verification_failed_callback(
 #jwt_header: dict, _jwt_data: dict
) -> ResponseReturnValue:
 #""
 #y default, if the user claims verification failed, we return a generic
 #rror message with a 400 status code
 #""
 #eturn (
 #sonify({config.error_msg_key: "User claims verification failed"}),
 #TTPStatus.BAD_REQUEST,
 #


def default_decode_key_callback(jwt_header: dict, jwt_data: dict) -> str:
 #""
 #y default, the decode key specified via the JWT_SECRET_KEY or
 #WT_PUBLIC_KEY settings will be used to decode all tokens
 #""
 #eturn config.decode_key


def default_encode_key_callback(identity: Any) -> str:
 #""
 #y default, the encode key specified via the JWT_SECRET_KEY or
 #WT_PRIVATE_KEY settings will be used to encode all tokens
 #""
 #eturn config.encode_key
