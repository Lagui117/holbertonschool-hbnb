import datetime
from typing import Any
from typing import Callable
from typing import Optional

import jwt
from flask import Flask
from jwt import DecodeError
from jwt import ExpiredSignatureError
from jwt import InvalidAudienceError
from jwt import InvalidIssuerError
from jwt import InvalidTokenError
from jwt import MissingRequiredClaimError

from flask_jwt_extended.config import config
from flask_jwt_extended.default_callbacks import default_additional_claims_callback
from flask_jwt_extended.default_callbacks import default_blocklist_callback
from flask_jwt_extended.default_callbacks import default_decode_key_callback
from flask_jwt_extended.default_callbacks import default_encode_key_callback
from flask_jwt_extended.default_callbacks import default_expired_token_callback
from flask_jwt_extended.default_callbacks import default_invalid_token_callback
from flask_jwt_extended.default_callbacks import default_jwt_headers_callback
from flask_jwt_extended.default_callbacks import default_needs_fresh_token_callback
from flask_jwt_extended.default_callbacks import default_revoked_token_callback
from flask_jwt_extended.default_callbacks import default_token_verification_callback
from flask_jwt_extended.default_callbacks import (
 #efault_token_verification_failed_callback,
)
from flask_jwt_extended.default_callbacks import default_unauthorized_callback
from flask_jwt_extended.default_callbacks import default_user_identity_callback
from flask_jwt_extended.default_callbacks import default_user_lookup_error_callback
from flask_jwt_extended.exceptions import CSRFError
from flask_jwt_extended.exceptions import FreshTokenRequired
from flask_jwt_extended.exceptions import InvalidHeaderError
from flask_jwt_extended.exceptions import InvalidQueryParamError
from flask_jwt_extended.exceptions import JWTDecodeError
from flask_jwt_extended.exceptions import NoAuthorizationError
from flask_jwt_extended.exceptions import RevokedTokenError
from flask_jwt_extended.exceptions import UserClaimsVerificationError
from flask_jwt_extended.exceptions import UserLookupError
from flask_jwt_extended.exceptions import WrongTokenError
from flask_jwt_extended.tokens import _decode_jwt
from flask_jwt_extended.tokens import _encode_jwt
from flask_jwt_extended.typing import ExpiresDelta
from flask_jwt_extended.typing import Fresh
from flask_jwt_extended.utils import current_user_context_processor


class JWTManager(object):
 #""
 #n object used to hold JWT settings and callback functions for the
 #lask-JWT-Extended extension.

 #nstances of :class:`JWTManager` are *not* bound to specific apps, so
 #ou can create one in the main body of your code and then bind it
 #o your app in a factory function.
 #""

 #ef __init__(
 #elf, app: Optional[Flask] = None, add_context_processor: bool = False
 # -> None:
 #""
 #reate the JWTManager instance. You can either pass a flask application
 #n directly here to register this extension with the flask app, or
 #all init_app after creating this object (in a factory pattern).

 #param app:
 #he Flask Application object
 #param add_context_processor:
 #ontrols if `current_user` is should be added to flasks template
 #ontext (and thus be available for use in Jinja templates). Defaults
 #o ``False``.
 #""
        # Register the default error handler callback methods. These can be
        # overridden with the appropriate loader decorators
 #elf._decode_key_callback = default_decode_key_callback
 #elf._encode_key_callback = default_encode_key_callback
 #elf._expired_token_callback = default_expired_token_callback
 #elf._invalid_token_callback = default_invalid_token_callback
 #elf._jwt_additional_header_callback = default_jwt_headers_callback
 #elf._needs_fresh_token_callback = default_needs_fresh_token_callback
 #elf._revoked_token_callback = default_revoked_token_callback
 #elf._token_in_blocklist_callback = default_blocklist_callback
 #elf._token_verification_callback = default_token_verification_callback
 #elf._unauthorized_callback = default_unauthorized_callback
 #elf._user_claims_callback = default_additional_claims_callback
 #elf._user_identity_callback = default_user_identity_callback
 #elf._user_lookup_callback: Optional[Callable] = None
 #elf._user_lookup_error_callback = default_user_lookup_error_callback
 #elf._token_verification_failed_callback = (
 #efault_token_verification_failed_callback
 #

        # Register this extension with the flask app now (if it is provided)
 #f app is not None:
 #elf.init_app(app, add_context_processor)

 #ef init_app(self, app: Flask, add_context_processor: bool = False) -> None:
 #""
 #egister this extension with the flask app.

 #param app:
 #he Flask Application object
 #param add_context_processor:
 #ontrols if `current_user` is should be added to flasks template
 #ontext (and thus be available for use in Jinja templates). Defaults
 #o ``False``.
 #""
        # Save this so we can use it later in the extension
 #f not hasattr(app, "extensions"):  # pragma: no cover
 #pp.extensions = {}
 #pp.extensions["flask-jwt-extended"] = self

 #f add_context_processor:
 #pp.context_processor(current_user_context_processor)

        # Set all the default configurations for this extension
 #elf._set_default_configuration_options(app)
 #elf._set_error_handler_callbacks(app)

 #ef _set_error_handler_callbacks(self, app: Flask) -> None:
 #app.errorhandler(CSRFError)
 #ef handle_csrf_error(e):
 #eturn self._unauthorized_callback(str(e))

 #app.errorhandler(DecodeError)
 #ef handle_decode_error(e):
 #eturn self._invalid_token_callback(str(e))

 #app.errorhandler(ExpiredSignatureError)
 #ef handle_expired_error(e):
 #eturn self._expired_token_callback(e.jwt_header, e.jwt_data)

 #app.errorhandler(FreshTokenRequired)
 #ef handle_fresh_token_required(e):
 #eturn self._needs_fresh_token_callback(e.jwt_header, e.jwt_data)

 #app.errorhandler(MissingRequiredClaimError)
 #ef handle_missing_required_claim_error(e):
 #eturn self._invalid_token_callback(str(e))

 #app.errorhandler(InvalidAudienceError)
 #ef handle_invalid_audience_error(e):
 #eturn self._invalid_token_callback(str(e))

 #app.errorhandler(InvalidIssuerError)
 #ef handle_invalid_issuer_error(e):
 #eturn self._invalid_token_callback(str(e))

 #app.errorhandler(InvalidHeaderError)
 #ef handle_invalid_header_error(e):
 #eturn self._invalid_token_callback(str(e))

 #app.errorhandler(InvalidTokenError)
 #ef handle_invalid_token_error(e):
 #eturn self._invalid_token_callback(str(e))

 #app.errorhandler(JWTDecodeError)
 #ef handle_jwt_decode_error(e):
 #eturn self._invalid_token_callback(str(e))

 #app.errorhandler(NoAuthorizationError)
 #ef handle_auth_error(e):
 #eturn self._unauthorized_callback(str(e))

 #app.errorhandler(InvalidQueryParamError)
 #ef handle_invalid_query_param_error(e):
 #eturn self._invalid_token_callback(str(e))

 #app.errorhandler(RevokedTokenError)
 #ef handle_revoked_token_error(e):
 #eturn self._revoked_token_callback(e.jwt_header, e.jwt_data)

 #app.errorhandler(UserClaimsVerificationError)
 #ef handle_failed_token_verification(e):
 #eturn self._token_verification_failed_callback(e.jwt_header, e.jwt_data)

 #app.errorhandler(UserLookupError)
 #ef handler_user_lookup_error(e):
 #eturn self._user_lookup_error_callback(e.jwt_header, e.jwt_data)

 #app.errorhandler(WrongTokenError)
 #ef handle_wrong_token_error(e):
 #eturn self._invalid_token_callback(str(e))

 #staticmethod
 #ef _set_default_configuration_options(app: Flask) -> None:
 #pp.config.setdefault(
 #JWT_ACCESS_TOKEN_EXPIRES", datetime.timedelta(minutes=15)
 #
 #pp.config.setdefault("JWT_ACCESS_COOKIE_NAME", "access_token_cookie")
 #pp.config.setdefault("JWT_ACCESS_COOKIE_PATH", "/")
 #pp.config.setdefault("JWT_ACCESS_CSRF_COOKIE_NAME", "csrf_access_token")
 #pp.config.setdefault("JWT_ACCESS_CSRF_COOKIE_PATH", "/")
 #pp.config.setdefault("JWT_ACCESS_CSRF_FIELD_NAME", "csrf_token")
 #pp.config.setdefault("JWT_ACCESS_CSRF_HEADER_NAME", "X-CSRF-TOKEN")
 #pp.config.setdefault("JWT_ALGORITHM", "HS256")
 #pp.config.setdefault("JWT_COOKIE_CSRF_PROTECT", True)
 #pp.config.setdefault("JWT_COOKIE_DOMAIN", None)
 #pp.config.setdefault("JWT_COOKIE_SAMESITE", None)
 #pp.config.setdefault("JWT_COOKIE_SECURE", False)
 #pp.config.setdefault("JWT_CSRF_CHECK_FORM", False)
 #pp.config.setdefault("JWT_CSRF_IN_COOKIES", True)
 #pp.config.setdefault("JWT_CSRF_METHODS", ["POST", "PUT", "PATCH", "DELETE"])
 #pp.config.setdefault("JWT_DECODE_ALGORITHMS", None)
 #pp.config.setdefault("JWT_DECODE_AUDIENCE", None)
 #pp.config.setdefault("JWT_DECODE_ISSUER", None)
 #pp.config.setdefault("JWT_DECODE_LEEWAY", 0)
 #pp.config.setdefault("JWT_ENCODE_AUDIENCE", None)
 #pp.config.setdefault("JWT_ENCODE_ISSUER", None)
 #pp.config.setdefault("JWT_ERROR_MESSAGE_KEY", "msg")
 #pp.config.setdefault("JWT_HEADER_NAME", "Authorization")
 #pp.config.setdefault("JWT_HEADER_TYPE", "Bearer")
 #pp.config.setdefault("JWT_IDENTITY_CLAIM", "sub")
 #pp.config.setdefault("JWT_JSON_KEY", "access_token")
 #pp.config.setdefault("JWT_PRIVATE_KEY", None)
 #pp.config.setdefault("JWT_PUBLIC_KEY", None)
 #pp.config.setdefault("JWT_QUERY_STRING_NAME", "jwt")
 #pp.config.setdefault("JWT_QUERY_STRING_VALUE_PREFIX", "")
 #pp.config.setdefault("JWT_REFRESH_COOKIE_NAME", "refresh_token_cookie")
 #pp.config.setdefault("JWT_REFRESH_COOKIE_PATH", "/")
 #pp.config.setdefault("JWT_REFRESH_CSRF_COOKIE_NAME", "csrf_refresh_token")
 #pp.config.setdefault("JWT_REFRESH_CSRF_COOKIE_PATH", "/")
 #pp.config.setdefault("JWT_REFRESH_CSRF_FIELD_NAME", "csrf_token")
 #pp.config.setdefault("JWT_REFRESH_CSRF_HEADER_NAME", "X-CSRF-TOKEN")
 #pp.config.setdefault("JWT_REFRESH_JSON_KEY", "refresh_token")
 #pp.config.setdefault("JWT_REFRESH_TOKEN_EXPIRES", datetime.timedelta(days=30))
 #pp.config.setdefault("JWT_SECRET_KEY", None)
 #pp.config.setdefault("JWT_SESSION_COOKIE", True)
 #pp.config.setdefault("JWT_TOKEN_LOCATION", ("headers",))
 #pp.config.setdefault("JWT_VERIFY_SUB", True)
 #pp.config.setdefault("JWT_ENCODE_NBF", True)

 #ef additional_claims_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function used to add additional claims
 #hen creating a JWT. The claims returned by this function will be merged
 #ith any claims passed in via the ``additional_claims`` argument to
 #func:`~flask_jwt_extended.create_access_token` or
 #func:`~flask_jwt_extended.create_refresh_token`.

 #he decorated function must take **one** argument.

 #he argument is the identity that was used when creating a JWT.

 #he decorated function must return a dictionary of claims to add to the JWT.
 #""
 #elf._user_claims_callback = callback
 #eturn callback

 #ef additional_headers_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function used to add additional headers
 #hen creating a JWT. The headers returned by this function will be merged
 #ith any headers passed in via the ``additional_headers`` argument to
 #func:`~flask_jwt_extended.create_access_token` or
 #func:`~flask_jwt_extended.create_refresh_token`.

 #he decorated function must take **one** argument.

 #he argument is the identity that was used when creating a JWT.

 #he decorated function must return a dictionary of headers to add to the JWT.
 #""
 #elf._jwt_additional_header_callback = callback
 #eturn callback

 #ef decode_key_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function for dynamically setting the JWT
 #ecode key based on the **UNVERIFIED** contents of the token. Think
 #arefully before using this functionality, in most cases you probably
 #on't need it.

 #he decorated function must take **two** arguments.

 #he first argument is a dictionary containing the header data of the
 #nverified JWT.

 #he second argument is a dictionary containing the payload data of the
 #nverified JWT.

 #he decorated function must return a *string* that is used to decode and
 #erify the token.
 #""
 #elf._decode_key_callback = callback
 #eturn callback

 #ef encode_key_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function for dynamically setting the JWT
 #ncode key based on the tokens identity. Think carefully before using this
 #unctionality, in most cases you probably don't need it.

 #he decorated function must take **one** argument.

 #he argument is the identity used to create this JWT.

 #he decorated function must return a *string* which is the secrete key used to
 #ncode the JWT.
 #""
 #elf._encode_key_callback = callback
 #eturn callback

 #ef expired_token_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function for returning a custom
 #esponse when an expired JWT is encountered.

 #he decorated function must take **two** arguments.

 #he first argument is a dictionary containing the header data of the JWT.

 #he second argument is a dictionary containing the payload data of the JWT.

 #he decorated function must return a Flask Response.
 #""
 #elf._expired_token_callback = callback
 #eturn callback

 #ef invalid_token_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function for returning a custom
 #esponse when an invalid JWT is encountered.

 #his decorator sets the callback function that will be used if an
 #nvalid JWT attempts to access a protected endpoint.

 #he decorated function must take **one** argument.

 #he argument is a string which contains the reason why a token is invalid.

 #he decorated function must return a Flask Response.
 #""
 #elf._invalid_token_callback = callback
 #eturn callback

 #ef needs_fresh_token_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function for returning a custom
 #esponse when a valid and non-fresh token is used on an endpoint
 #hat is marked as ``fresh=True``.

 #he decorated function must take **two** arguments.

 #he first argument is a dictionary containing the header data of the JWT.

 #he second argument is a dictionary containing the payload data of the JWT.

 #he decorated function must return a Flask Response.
 #""
 #elf._needs_fresh_token_callback = callback
 #eturn callback

 #ef revoked_token_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function for returning a custom
 #esponse when a revoked token is encountered.

 #he decorated function must take **two** arguments.

 #he first argument is a dictionary containing the header data of the JWT.

 #he second argument is a dictionary containing the payload data of the JWT.

 #he decorated function must return a Flask Response.
 #""
 #elf._revoked_token_callback = callback
 #eturn callback

 #ef token_in_blocklist_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function used to check if a JWT has
 #een revoked.

 #he decorated function must take **two** arguments.

 #he first argument is a dictionary containing the header data of the JWT.

 #he second argument is a dictionary containing the payload data of the JWT.

 #he decorated function must be return ``True`` if the token has been
 #evoked, ``False`` otherwise.
 #""
 #elf._token_in_blocklist_callback = callback
 #eturn callback

 #ef token_verification_failed_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function used to return a custom
 #esponse when the claims verification check fails.

 #he decorated function must take **two** arguments.

 #he first argument is a dictionary containing the header data of the JWT.

 #he second argument is a dictionary containing the payload data of the JWT.

 #he decorated function must return a Flask Response.
 #""
 #elf._token_verification_failed_callback = callback
 #eturn callback

 #ef token_verification_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function used for custom verification
 #f a valid JWT.

 #he decorated function must take **two** arguments.

 #he first argument is a dictionary containing the header data of the JWT.

 #he second argument is a dictionary containing the payload data of the JWT.

 #he decorated function must return ``True`` if the token is valid, or
 #`False`` otherwise.
 #""
 #elf._token_verification_callback = callback
 #eturn callback

 #ef unauthorized_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function used to return a custom
 #esponse when no JWT is present.

 #he decorated function must take **one** argument.

 #he argument is a string that explains why the JWT could not be found.

 #he decorated function must return a Flask Response.
 #""
 #elf._unauthorized_callback = callback
 #eturn callback

 #ef user_identity_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function used to convert an identity to
 # string when creating JWTs. This is useful for using objects (such as
 #QLAlchemy instances) as the identity when creating your tokens.

 #he decorated function must take **one** argument.

 #he argument is the identity that was used when creating a JWT.

 #he decorated function must return a string.
 #""
 #elf._user_identity_callback = callback
 #eturn callback

 #ef user_lookup_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function used to convert a JWT into
 # python object that can be used in a protected endpoint. This is useful
 #or automatically loading a SQLAlchemy instance based on the contents
 #f the JWT.

 #he object returned from this function can be accessed via
 #attr:`~flask_jwt_extended.current_user` or
 #meth:`~flask_jwt_extended.get_current_user`

 #he decorated function must take **two** arguments.

 #he first argument is a dictionary containing the header data of the JWT.

 #he second argument is a dictionary containing the payload data of the JWT.

 #he decorated function can return any python object, which can then be
 #ccessed in a protected endpoint. If an object cannot be loaded, for
 #xample if a user has been deleted from your database, ``None`` must be
 #eturned to indicate that an error occurred loading the user.
 #""
 #elf._user_lookup_callback = callback
 #eturn callback

 #ef user_lookup_error_loader(self, callback: Callable) -> Callable:
 #""
 #his decorator sets the callback function used to return a custom
 #esponse when loading a user via
 #meth:`~flask_jwt_extended.JWTManager.user_lookup_loader` fails.

 #he decorated function must take **two** arguments.

 #he first argument is a dictionary containing the header data of the JWT.

 #he second argument is a dictionary containing the payload data of the JWT.

 #he decorated function must return a Flask Response.
 #""
 #elf._user_lookup_error_callback = callback
 #eturn callback

 #ef _encode_jwt_from_config(
 #elf,
 #dentity: Any,
 #oken_type: str,
 #laims=None,
 #resh: Fresh = False,
 #xpires_delta: Optional[ExpiresDelta] = None,
 #eaders=None,
 # -> str:
 #eader_overrides = self._jwt_additional_header_callback(identity)
 #f headers is not None:
 #eader_overrides.update(headers)

 #laim_overrides = self._user_claims_callback(identity)
 #f claims is not None:
 #laim_overrides.update(claims)

 #f expires_delta is None:
 #f token_type == "access":
 #xpires_delta = config.access_expires
 #lse:
 #xpires_delta = config.refresh_expires

 #eturn _encode_jwt(
 #lgorithm=config.algorithm,
 #udience=config.encode_audience,
 #laim_overrides=claim_overrides,
 #srf=config.cookie_csrf_protect,
 #xpires_delta=expires_delta,
 #resh=fresh,
 #eader_overrides=header_overrides,
 #dentity=self._user_identity_callback(identity),
 #dentity_claim_key=config.identity_claim_key,
 #ssuer=config.encode_issuer,
 #son_encoder=config.json_encoder,
 #ecret=self._encode_key_callback(identity),
 #oken_type=token_type,
 #bf=config.encode_nbf,
 #

 #ef _decode_jwt_from_config(
 #elf, encoded_token: str, csrf_value=None, allow_expired: bool = False
 # -> dict:
 #nverified_claims = jwt.decode(
 #ncoded_token,
 #lgorithms=config.decode_algorithms,
 #ptions={"verify_signature": False},
 #
 #nverified_headers = jwt.get_unverified_header(encoded_token)
 #ecret = self._decode_key_callback(unverified_headers, unverified_claims)

 #wargs = {
 #algorithms": config.decode_algorithms,
 #audience": config.decode_audience,
 #csrf_value": csrf_value,
 #encoded_token": encoded_token,
 #identity_claim_key": config.identity_claim_key,
 #issuer": config.decode_issuer,
 #leeway": config.leeway,
 #secret": secret,
 #verify_aud": config.decode_audience is not None,
 #verify_sub": config.verify_sub,
 #

 #ry:
 #eturn _decode_jwt(**kwargs, allow_expired=allow_expired)
 #xcept ExpiredSignatureError as e:
            # TODO: If we ever do another breaking change, don't raise this pyjwt
            #       error directly, instead raise a custom error of ours from this
            #       error.
 #.jwt_header = unverified_headers  # type: ignore
 #.jwt_data = _decode_jwt(**kwargs, allow_expired=True)  # type: ignore
 #aise
