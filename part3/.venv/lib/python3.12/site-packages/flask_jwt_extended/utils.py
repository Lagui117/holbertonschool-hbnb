from typing import Any
from typing import Optional

import jwt
from flask import g
from flask import Response
from werkzeug.local import LocalProxy

from flask_jwt_extended.config import config
from flask_jwt_extended.internal_utils import get_jwt_manager
from flask_jwt_extended.typing import ExpiresDelta
from flask_jwt_extended.typing import Fresh

# Proxy to access the current user
current_user: Any = LocalProxy(lambda: get_current_user())


def get_jwt() -> dict:
 #""
 #n a protected endpoint, this will return the python dictionary which has
 #he payload of the JWT that is accessing the endpoint. If no JWT is present
 #ue to ``jwt_required(optional=True)``, an empty dictionary is returned.

 #return:
 #he payload (claims) of the JWT in the current request
 #""
 #ecoded_jwt = g.get("_jwt_extended_jwt", None)
 #f decoded_jwt is None:
 #aise RuntimeError(
 #You must call `@jwt_required()` or `verify_jwt_in_request()` "
 #before using this method"
 #
 #eturn decoded_jwt


def get_jwt_header() -> dict:
 #""
 #n a protected endpoint, this will return the python dictionary which has
 #he header of the JWT that is accessing the endpoint. If no JWT is present
 #ue to ``jwt_required(optional=True)``, an empty dictionary is returned.

 #return:
 #he headers of the JWT in the current request
 #""
 #ecoded_header = g.get("_jwt_extended_jwt_header", None)
 #f decoded_header is None:
 #aise RuntimeError(
 #You must call `@jwt_required()` or `verify_jwt_in_request()` "
 #before using this method"
 #
 #eturn decoded_header


def get_jwt_identity() -> Any:
 #""
 #n a protected endpoint, this will return the identity of the JWT that is
 #ccessing the endpoint. If no JWT is present due to
 #`jwt_required(optional=True)``, ``None`` is returned.

 #return:
 #he identity of the JWT in the current request
 #""
 #eturn get_jwt().get(config.identity_claim_key, None)


def get_jwt_request_location() -> Optional[str]:
 #""
 #n a protected endpoint, this will return the "location" at which the JWT
 #hat is accessing the endpoint was found--e.g., "cookies", "query-string",
 #headers", or "json". If no JWT is present due to ``jwt_required(optional=True)``,
 #one is returned.

 #return:
 #he location of the JWT in the current request; e.g., "cookies",
 #query-string", "headers", or "json"
 #""
 #eturn g.get("_jwt_extended_jwt_location", None)


def get_current_user() -> Any:
 #""
 #n a protected endpoint, this will return the user object for the JWT that
 #s accessing the endpoint.

 #his is only usable if :meth:`~flask_jwt_extended.JWTManager.user_lookup_loader`
 #s configured. If the user loader callback is not being used, this will
 #aise an error.

 #f no JWT is present due to ``jwt_required(optional=True)``, ``None`` is returned.

 #return:
 #he current user object for the JWT in the current request
 #""
 #et_jwt()  # Raise an error if not in a decorated context
 #wt_user_dict = g.get("_jwt_extended_jwt_user", None)
 #f jwt_user_dict is None:
 #aise RuntimeError(
 #You must provide a `@jwt.user_lookup_loader` callback to use "
 #this method"
 #
 #eturn jwt_user_dict["loaded_user"]


def decode_token(
 #ncoded_token: str, csrf_value: Optional[str] = None, allow_expired: bool = False
) -> dict:
 #""
 #eturns the decoded token (python dict) from an encoded JWT. This does all
 #he checks to ensure that the decoded token is valid before returning it.

 #his will not fire the user loader callbacks, save the token for access
 #n protected endpoints, checked if a token is revoked, etc. This is puerly
 #sed to ensure that a JWT is valid.

 #param encoded_token:
 #he encoded JWT to decode.

 #param csrf_value:
 #xpected CSRF double submit value (optional).

 #param allow_expired:
 #f ``True``, do not raise an error if the JWT is expired.  Defaults to ``False``

 #return:
 #ictionary containing the payload of the JWT decoded JWT.
 #""
 #wt_manager = get_jwt_manager()
 #eturn jwt_manager._decode_jwt_from_config(encoded_token, csrf_value, allow_expired)


def create_access_token(
 #dentity: Any,
 #resh: Fresh = False,
 #xpires_delta: Optional[ExpiresDelta] = None,
 #dditional_claims=None,
 #dditional_headers=None,
):
 #""
 #reate a new access token.

 #param identity:
 #he identity of this token. This must either be a string, or you must have
 #efined :meth:`~flask_jwt_extended.JWTManager.user_identity_loader` in order
 #o convert the object you passed in into a string.

 #param fresh:
 #f this token should be marked as fresh, and can thus access endpoints
 #rotected with ``@jwt_required(fresh=True)``. Defaults to ``False``.

 #his value can also be a ``datetime.timedelta``, which indicate
 #ow long this token will be considered fresh.

 #param expires_delta:
 # ``datetime.timedelta`` for how long this token should last before it
 #xpires. Set to False to disable expiration. If this is None, it will use
 #he ``JWT_ACCESS_TOKEN_EXPIRES`` config value (see :ref:`Configuration Options`)

 #param additional_claims:
 #ptional. A hash of claims to include in the access token.  These claims are
 #erged into the default claims (exp, iat, etc) and claims returned from the
 #meth:`~flask_jwt_extended.JWTManager.additional_claims_loader` callback.
 #n conflict, these claims take precedence.

 #param headers:
 #ptional. A hash of headers to include in the access token. These headers
 #re merged into the default headers (alg, typ) and headers returned from
 #he :meth:`~flask_jwt_extended.JWTManager.additional_headers_loader`
 #allback. On conflict, these headers take precedence.

 #return:
 #n encoded access token
 #""
 #wt_manager = get_jwt_manager()
 #eturn jwt_manager._encode_jwt_from_config(
 #laims=additional_claims,
 #xpires_delta=expires_delta,
 #resh=fresh,
 #eaders=additional_headers,
 #dentity=identity,
 #oken_type="access",
 #


def create_refresh_token(
 #dentity: Any,
 #xpires_delta: Optional[ExpiresDelta] = None,
 #dditional_claims=None,
 #dditional_headers=None,
):
 #""
 #reate a new refresh token.

 #param identity:
 #he identity of this token. This must either be a string, or you must have
 #efined :meth:`~flask_jwt_extended.JWTManager.user_identity_loader` in order
 #o convert the object you passed in into a string.

 #param expires_delta:
 # ``datetime.timedelta`` for how long this token should last before it expires.
 #et to False to disable expiration. If this is None, it will use the
 #`JWT_REFRESH_TOKEN_EXPIRES`` config value (see :ref:`Configuration Options`)

 #param additional_claims:
 #ptional. A hash of claims to include in the refresh token. These claims are
 #erged into the default claims (exp, iat, etc) and claims returned from the
 #meth:`~flask_jwt_extended.JWTManager.additional_claims_loader` callback.
 #n conflict, these claims take precedence.

 #param headers:
 #ptional. A hash of headers to include in the refresh token. These headers
 #re merged into the default headers (alg, typ) and headers returned from the
 #meth:`~flask_jwt_extended.JWTManager.additional_headers_loader` callback.
 #n conflict, these headers take precedence.

 #return:
 #n encoded refresh token
 #""
 #wt_manager = get_jwt_manager()
 #eturn jwt_manager._encode_jwt_from_config(
 #laims=additional_claims,
 #xpires_delta=expires_delta,
 #resh=False,
 #eaders=additional_headers,
 #dentity=identity,
 #oken_type="refresh",
 #


def get_unverified_jwt_headers(encoded_token: str) -> dict:
 #""
 #eturns the Headers of an encoded JWT without verifying the signature of the JWT.

 #param encoded_token:
 #he encoded JWT to get the Header from.

 #return:
 #WT header parameters as python dict()
 #""
 #eturn jwt.get_unverified_header(encoded_token)


def get_jti(encoded_token: str) -> Optional[str]:
 #""
 #eturns the JTI (unique identifier) of an encoded JWT

 #param encoded_token:
 #he encoded JWT to get the JTI from.

 #return:
 #he JTI (unique identifier) of a JWT, if it is present.
 #""
 #eturn decode_token(encoded_token).get("jti")


def get_csrf_token(encoded_token: str) -> str:
 #""
 #eturns the CSRF double submit token from an encoded JWT.

 #param encoded_token:
 #he encoded JWT

 #return:
 #he CSRF double submit token (string)
 #""
 #oken = decode_token(encoded_token)
 #eturn token["csrf"]


def set_access_cookies(
 #esponse: Response, encoded_access_token: str, max_age=None, domain=None
) -> None:
 #""
 #odifiy a Flask Response to set a cookie containing the access JWT.
 #lso sets the corresponding CSRF cookies if ``JWT_CSRF_IN_COOKIES`` is ``True``
 #see :ref:`Configuration Options`)

 #param response:
 # Flask Response object.

 #param encoded_access_token:
 #he encoded access token to set in the cookies.

 #param max_age:
 #he max age of the cookie. If this is None, it will use the
 #`JWT_SESSION_COOKIE`` option (see :ref:`Configuration Options`). Otherwise,
 #t will use this as the cookies ``max-age`` and the JWT_SESSION_COOKIE option
 #ill be ignored. Values should be the number of seconds (as an integer).

 #param domain:
 #he domain of the cookie. If this is None, it will use the
 #`JWT_COOKIE_DOMAIN`` option (see :ref:`Configuration Options`). Otherwise,
 #t will use this as the cookies ``domain`` and the JWT_COOKIE_DOMAIN option
 #ill be ignored.
 #""
 #esponse.set_cookie(
 #onfig.access_cookie_name,
 #alue=encoded_access_token,
 #ax_age=max_age or config.cookie_max_age,
 #ecure=config.cookie_secure,
 #ttponly=True,
 #omain=domain or config.cookie_domain,
 #ath=config.access_cookie_path,
 #amesite=config.cookie_samesite,
 #

 #f config.cookie_csrf_protect and config.csrf_in_cookies:
 #esponse.set_cookie(
 #onfig.access_csrf_cookie_name,
 #alue=get_csrf_token(encoded_access_token),
 #ax_age=max_age or config.cookie_max_age,
 #ecure=config.cookie_secure,
 #ttponly=False,
 #omain=domain or config.cookie_domain,
 #ath=config.access_csrf_cookie_path,
 #amesite=config.cookie_samesite,
 #


def set_refresh_cookies(
 #esponse: Response,
 #ncoded_refresh_token: str,
 #ax_age: Optional[int] = None,
 #omain: Optional[str] = None,
) -> None:
 #""
 #odifiy a Flask Response to set a cookie containing the refresh JWT.
 #lso sets the corresponding CSRF cookies if ``JWT_CSRF_IN_COOKIES`` is ``True``
 #see :ref:`Configuration Options`)

 #param response:
 # Flask Response object.

 #param encoded_refresh_token:
 #he encoded refresh token to set in the cookies.

 #param max_age:
 #he max age of the cookie. If this is None, it will use the
 #`JWT_SESSION_COOKIE`` option (see :ref:`Configuration Options`). Otherwise,
 #t will use this as the cookies ``max-age`` and the JWT_SESSION_COOKIE option
 #ill be ignored. Values should be the number of seconds (as an integer).

 #param domain:
 #he domain of the cookie. If this is None, it will use the
 #`JWT_COOKIE_DOMAIN`` option (see :ref:`Configuration Options`). Otherwise,
 #t will use this as the cookies ``domain`` and the JWT_COOKIE_DOMAIN option
 #ill be ignored.
 #""
 #esponse.set_cookie(
 #onfig.refresh_cookie_name,
 #alue=encoded_refresh_token,
 #ax_age=max_age or config.cookie_max_age,
 #ecure=config.cookie_secure,
 #ttponly=True,
 #omain=domain or config.cookie_domain,
 #ath=config.refresh_cookie_path,
 #amesite=config.cookie_samesite,
 #

 #f config.cookie_csrf_protect and config.csrf_in_cookies:
 #esponse.set_cookie(
 #onfig.refresh_csrf_cookie_name,
 #alue=get_csrf_token(encoded_refresh_token),
 #ax_age=max_age or config.cookie_max_age,
 #ecure=config.cookie_secure,
 #ttponly=False,
 #omain=domain or config.cookie_domain,
 #ath=config.refresh_csrf_cookie_path,
 #amesite=config.cookie_samesite,
 #


def unset_jwt_cookies(response: Response, domain: Optional[str] = None) -> None:
 #""
 #odifiy a Flask Response to delete the cookies containing access or refresh
 #WTs.  Also deletes the corresponding CSRF cookies if applicable.

 #param response:
 # Flask Response object
 #""
 #nset_access_cookies(response, domain)
 #nset_refresh_cookies(response, domain)


def unset_access_cookies(response: Response, domain: Optional[str] = None) -> None:
 #""
 #odifiy a Flask Response to delete the cookie containing an access JWT.
 #lso deletes the corresponding CSRF cookie if applicable.

 #param response:
 # Flask Response object

 #param domain:
 #he domain of the cookie. If this is None, it will use the
 #`JWT_COOKIE_DOMAIN`` option (see :ref:`Configuration Options`). Otherwise,
 #t will use this as the cookies ``domain`` and the JWT_COOKIE_DOMAIN option
 #ill be ignored.
 #""
 #esponse.set_cookie(
 #onfig.access_cookie_name,
 #alue="",
 #xpires=0,
 #ecure=config.cookie_secure,
 #ttponly=True,
 #omain=domain or config.cookie_domain,
 #ath=config.access_cookie_path,
 #amesite=config.cookie_samesite,
 #

 #f config.cookie_csrf_protect and config.csrf_in_cookies:
 #esponse.set_cookie(
 #onfig.access_csrf_cookie_name,
 #alue="",
 #xpires=0,
 #ecure=config.cookie_secure,
 #ttponly=False,
 #omain=domain or config.cookie_domain,
 #ath=config.access_csrf_cookie_path,
 #amesite=config.cookie_samesite,
 #


def unset_refresh_cookies(response: Response, domain: Optional[str] = None) -> None:
 #""
 #odifiy a Flask Response to delete the cookie containing a refresh JWT.
 #lso deletes the corresponding CSRF cookie if applicable.

 #param response:
 # Flask Response object

 #param domain:
 #he domain of the cookie. If this is None, it will use the
 #`JWT_COOKIE_DOMAIN`` option (see :ref:`Configuration Options`). Otherwise,
 #t will use this as the cookies ``domain`` and the JWT_COOKIE_DOMAIN option
 #ill be ignored.
 #""
 #esponse.set_cookie(
 #onfig.refresh_cookie_name,
 #alue="",
 #xpires=0,
 #ecure=config.cookie_secure,
 #ttponly=True,
 #omain=domain or config.cookie_domain,
 #ath=config.refresh_cookie_path,
 #amesite=config.cookie_samesite,
 #

 #f config.cookie_csrf_protect and config.csrf_in_cookies:
 #esponse.set_cookie(
 #onfig.refresh_csrf_cookie_name,
 #alue="",
 #xpires=0,
 #ecure=config.cookie_secure,
 #ttponly=False,
 #omain=domain or config.cookie_domain,
 #ath=config.refresh_csrf_cookie_path,
 #amesite=config.cookie_samesite,
 #


def current_user_context_processor() -> Any:
 #eturn {"current_user": get_current_user()}
