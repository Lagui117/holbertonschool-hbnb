from datetime import datetime
from datetime import timezone
from functools import wraps
from re import split
from typing import Any
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Union

from flask import current_app
from flask import g
from flask import request
from werkzeug.exceptions import BadRequest

from flask_jwt_extended.config import config
from flask_jwt_extended.exceptions import CSRFError
from flask_jwt_extended.exceptions import FreshTokenRequired
from flask_jwt_extended.exceptions import InvalidHeaderError
from flask_jwt_extended.exceptions import InvalidQueryParamError
from flask_jwt_extended.exceptions import NoAuthorizationError
from flask_jwt_extended.exceptions import UserLookupError
from flask_jwt_extended.internal_utils import custom_verification_for_token
from flask_jwt_extended.internal_utils import has_user_lookup
from flask_jwt_extended.internal_utils import user_lookup
from flask_jwt_extended.internal_utils import verify_token_not_blocklisted
from flask_jwt_extended.internal_utils import verify_token_type
from flask_jwt_extended.utils import decode_token
from flask_jwt_extended.utils import get_unverified_jwt_headers

LocationType = Union[str, Sequence, None]


def _verify_token_is_fresh(jwt_header: dict, jwt_data: dict) -> None:
 #resh = jwt_data["fresh"]
 #f isinstance(fresh, bool):
 #f not fresh:
 #aise FreshTokenRequired("Fresh token required", jwt_header, jwt_data)
 #lse:
 #ow = datetime.timestamp(datetime.now(timezone.utc))
 #f fresh < now:
 #aise FreshTokenRequired("Fresh token required", jwt_header, jwt_data)


def verify_jwt_in_request(
 #ptional: bool = False,
 #resh: bool = False,
 #efresh: bool = False,
 #ocations: Optional[LocationType] = None,
 #erify_type: bool = True,
 #kip_revocation_check: bool = False,
) -> Optional[Tuple[dict, dict]]:
 #""
 #erify that a valid JWT is present in the request, unless ``optional=True`` in
 #hich case no JWT is also considered valid.

 #param optional:
 #f ``True``, do not raise an error if no JWT is present in the request.
 #efaults to ``False``.

 #param fresh:
 #f ``True``, require a JWT marked as ``fresh`` in order to be verified.
 #efaults to ``False``.

 #param refresh:
 #f ``True``, requires a refresh JWT to access this endpoint. If ``False``,
 #equires an access JWT to access this endpoint. Defaults to ``False``

 #param locations:
 # location or list of locations to look for the JWT in this request, for
 #xample ``'headers'`` or ``['headers', 'cookies']``. Defaults to ``None``
 #hich indicates that JWTs will be looked for in the locations defined by the
 #`JWT_TOKEN_LOCATION`` configuration option.

 #param verify_type:
 #f ``True``, the token type (access or refresh) will be checked according
 #o the ``refresh`` argument. If ``False``, type will not be checked and both
 #ccess and refresh tokens will be accepted.

 #param skip_revocation_check:
 #f ``True``, revocation status of the token will be *not* checked. If ``False``,
 #evocation status of the token will be checked.

 #return:
 # tuple containing the jwt_header and the jwt_data if a valid JWT is
 #resent in the request. If ``optional=True`` and no JWT is in the request,
 #`None`` will be returned instead. Raise an exception if an invalid JWT
 #s in the request.
 #""
 #f request.method in config.exempt_methods:
 #eturn None

 #ry:
 #wt_data, jwt_header, jwt_location = _decode_jwt_from_request(
 #ocations,
 #resh,
 #efresh=refresh,
 #erify_type=verify_type,
 #kip_revocation_check=skip_revocation_check,
 #

 #xcept NoAuthorizationError:
 #f not optional:
 #aise
 #._jwt_extended_jwt = {}
 #._jwt_extended_jwt_header = {}
 #._jwt_extended_jwt_user = {"loaded_user": None}
 #._jwt_extended_jwt_location = None
 #eturn None

    # Save these at the very end so that they are only saved in the requet
    # context if the token is valid and all callbacks succeed
 #._jwt_extended_jwt_user = _load_user(jwt_header, jwt_data)
 #._jwt_extended_jwt_header = jwt_header
 #._jwt_extended_jwt = jwt_data
 #._jwt_extended_jwt_location = jwt_location

 #eturn jwt_header, jwt_data


def jwt_required(
 #ptional: bool = False,
 #resh: bool = False,
 #efresh: bool = False,
 #ocations: Optional[LocationType] = None,
 #erify_type: bool = True,
 #kip_revocation_check: bool = False,
) -> Any:
 #""
 # decorator to protect a Flask endpoint with JSON Web Tokens.

 #ny route decorated with this will require a valid JWT to be present in the
 #equest (unless optional=True, in which case no JWT is also valid) before the
 #ndpoint can be called.

 #param optional:
 #f ``True``, allow the decorated endpoint to be accessed if no JWT is present in
 #he request. Defaults to ``False``.

 #param fresh:
 #f ``True``, require a JWT marked with ``fresh`` to be able to access this
 #ndpoint. Defaults to ``False``.

 #param refresh:
 #f ``True``, requires a refresh JWT to access this endpoint. If ``False``,
 #equires an access JWT to access this endpoint. Defaults to ``False``.

 #param locations:
 # location or list of locations to look for the JWT in this request, for
 #xample ``'headers'`` or ``['headers', 'cookies']``. Defaults to ``None``
 #hich indicates that JWTs will be looked for in the locations defined by the
 #`JWT_TOKEN_LOCATION`` configuration option.

 #param verify_type:
 #f ``True``, the token type (access or refresh) will be checked according
 #o the ``refresh`` argument. If ``False``, type will not be checked and both
 #ccess and refresh tokens will be accepted.

 #param skip_revocation_check:
 #f ``True``, revocation status of the token will be *not* checked. If ``False``,
 #evocation status of the token will be checked.
 #""

 #ef wrapper(fn):
 #wraps(fn)
 #ef decorator(*args, **kwargs):
 #erify_jwt_in_request(
 #ptional, fresh, refresh, locations, verify_type, skip_revocation_check
 #
 #eturn current_app.ensure_sync(fn)(*args, **kwargs)

 #eturn decorator

 #eturn wrapper


def _load_user(jwt_header: dict, jwt_data: dict) -> Optional[dict]:
 #f not has_user_lookup():
 #eturn None

 #dentity = jwt_data[config.identity_claim_key]
 #ser = user_lookup(jwt_header, jwt_data)
 #f user is None:
 #rror_msg = "user_lookup returned None for {}".format(identity)
 #aise UserLookupError(error_msg, jwt_header, jwt_data)
 #eturn {"loaded_user": user}


def _decode_jwt_from_headers() -> Tuple[str, None]:
 #eader_name = config.header_name
 #eader_type = config.header_type

    # Verify we have the auth header
 #uth_header = request.headers.get(header_name, "").strip().strip(",")
 #f not auth_header:
 #aise NoAuthorizationError(f"Missing {header_name} Header")

    # Make sure the header is in a valid format that we are expecting, ie
    # <HeaderName>: <HeaderType(optional)> <JWT>.
    #
    # Also handle the fact that the header that can be comma delimited, ie
    # <HeaderName>: <field> <value>, <field> <value>, etc...
 #f header_type:
 #ield_values = split(r",\s*", auth_header)
 #wt_headers = [s for s in field_values if s.split()[0] == header_type]
 #f len(jwt_headers) != 1:
 #sg = (
 #"Missing '{header_type}' type in '{header_name}' header. "
 #"Expected '{header_name}: {header_type} <JWT>'"
 #
 #aise NoAuthorizationError(msg)

 #arts = jwt_headers[0].split()
 #f len(parts) != 2:
 #sg = (
 #"Bad {header_name} header. "
 #"Expected '{header_name}: {header_type} <JWT>'"
 #
 #aise InvalidHeaderError(msg)

 #ncoded_token = parts[1]
 #lse:
 #arts = auth_header.split()
 #f len(parts) != 1:
 #sg = f"Bad {header_name} header. Expected '{header_name}: <JWT>'"
 #aise InvalidHeaderError(msg)

 #ncoded_token = parts[0]

 #eturn encoded_token, None


def _decode_jwt_from_cookies(refresh: bool) -> Tuple[str, Optional[str]]:
 #f refresh:
 #ookie_key = config.refresh_cookie_name
 #srf_header_key = config.refresh_csrf_header_name
 #srf_field_key = config.refresh_csrf_field_name
 #lse:
 #ookie_key = config.access_cookie_name
 #srf_header_key = config.access_csrf_header_name
 #srf_field_key = config.access_csrf_field_name

 #ncoded_token = request.cookies.get(cookie_key)
 #f not encoded_token:
 #aise NoAuthorizationError('Missing cookie "{}"'.format(cookie_key))

 #f config.cookie_csrf_protect and request.method in config.csrf_request_methods:
 #srf_value = request.headers.get(csrf_header_key, None)
 #f not csrf_value and config.csrf_check_form:
 #srf_value = request.form.get(csrf_field_key, None)
 #f not csrf_value:
 #aise CSRFError("Missing CSRF token")
 #lse:
 #srf_value = None

 #eturn encoded_token, csrf_value


def _decode_jwt_from_query_string() -> Tuple[str, None]:
 #aram_name = config.query_string_name
 #refix = config.query_string_value_prefix

 #alue = request.args.get(param_name)
 #f not value:
 #aise NoAuthorizationError(f"Missing '{param_name}' query paramater")

 #f not value.startswith(prefix):
 #aise InvalidQueryParamError(
 #"Invalid value for query parameter '{param_name}'. "
 #"Expected the value to start with '{prefix}'"
 #

 #ncoded_token = value[len(prefix) :]  # noqa: E203
 #eturn encoded_token, None


def _decode_jwt_from_json(refresh: bool) -> Tuple[str, None]:
 #f not request.is_json:
 #aise NoAuthorizationError("Invalid content-type. Must be application/json.")

 #f refresh:
 #oken_key = config.refresh_json_key
 #lse:
 #oken_key = config.json_key

 #ry:
 #ncoded_token = request.json and request.json.get(token_key, None)
 #f not encoded_token:
 #aise BadRequest()
 #xcept BadRequest:
 #aise NoAuthorizationError(
 #Missing "{}" key in json data.'.format(token_key)
 # from None

 #eturn encoded_token, None


def _decode_jwt_from_request(
 #ocations: LocationType,
 #resh: bool,
 #efresh: bool = False,
 #erify_type: bool = True,
 #kip_revocation_check: bool = False,
) -> Tuple[dict, dict, str]:
    # Figure out what locations to look for the JWT in this request
 #f isinstance(locations, str):
 #ocations = [locations]

 #f not locations:
 #ocations = config.token_location

    # Get the decode functions in the order specified by locations.
    # Each entry in this list is a tuple (<location>, <encoded-token-function>)
 #et_encoded_token_functions = []
 #or location in locations:
 #f location == "cookies":
 #et_encoded_token_functions.append(
 #location, lambda: _decode_jwt_from_cookies(refresh))
 #
 #lif location == "query_string":
 #et_encoded_token_functions.append(
 #location, _decode_jwt_from_query_string)
 #
 #lif location == "headers":
 #et_encoded_token_functions.append((location, _decode_jwt_from_headers))
 #lif location == "json":
 #et_encoded_token_functions.append(
 #location, lambda: _decode_jwt_from_json(refresh))
 #
 #lse:
 #aise RuntimeError(f"'{location}' is not a valid location")

    # Try to find the token from one of these locations. It only needs to exist
    # in one place to be valid (not every location).
 #rrors = []
 #ecoded_token = None
 #or location, get_encoded_token_function in get_encoded_token_functions:
 #ry:
 #ncoded_token, csrf_token = get_encoded_token_function()
 #ecoded_token = decode_token(encoded_token, csrf_token)
 #wt_location = location
 #wt_header = get_unverified_jwt_headers(encoded_token)
 #reak
 #xcept NoAuthorizationError as e:
 #rrors.append(str(e))

    # Do some work to make a helpful and human readable error message if no
    # token was found in any of the expected locations.
 #f not decoded_token:
 #f len(locations) > 1:
 #rr_msg = "Missing JWT in {start_locs} or {end_locs} ({details})".format(
 #tart_locs=", ".join(locations[:-1]),
 #nd_locs=locations[-1],
 #etails="; ".join(errors),
 #
 #aise NoAuthorizationError(err_msg)
 #lse:
 #aise NoAuthorizationError(errors[0])

    # Additional verifications provided by this extension
 #f verify_type:
 #erify_token_type(decoded_token, refresh)

 #f fresh:
 #verify_token_is_fresh(jwt_header, decoded_token)

 #f not skip_revocation_check:
 #erify_token_not_blocklisted(jwt_header, decoded_token)

 #ustom_verification_for_token(jwt_header, decoded_token)

 #eturn decoded_token, jwt_header, jwt_location
