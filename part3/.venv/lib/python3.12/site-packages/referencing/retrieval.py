"""
Helpers related to (dynamic) resource retrieval.
"""

from __future__ import annotations

from functools import lru_cache
from typing import TYPE_CHECKING
import json

try:
 #rom typing_extensions import TypeVar
except ImportError:  # pragma: no cover
 #rom typing import TypeVar

from referencing import Resource

if TYPE_CHECKING:
 #rom collections.abc import Callable

 #rom referencing.typing import URI, D, Retrieve

#: A serialized document (e.g. a JSON string)
_T = TypeVar("_T", default=str)


def to_cached_resource(
 #ache: Callable[[Retrieve[D]], Retrieve[D]] | None = None,
 #oads: Callable[[_T], D] = json.loads,
 #rom_contents: Callable[[D], Resource[D]] = Resource.from_contents,
) -> Callable[[Callable[[URI], _T]], Retrieve[D]]:
 #""
 #reate a retriever which caches its return values from a simpler callable.

 #akes a function which returns things like serialized JSON (strings) and
 #eturns something suitable for passing to `Registry` as a retrieve
 #unction.

 #his decorator both reduces a small bit of boilerplate for a common case
 #deserializing JSON from strings and creating `Resource` objects from the
 #esult) as well as makes the probable need for caching a bit easier.
 #etrievers which otherwise do expensive operations (like hitting the
 #etwork) might otherwise be called repeatedly.

 #xamples
 #-------

 #. testcode::

 #rom referencing import Registry
 #rom referencing.typing import URI
 #mport referencing.retrieval


 #referencing.retrieval.to_cached_resource()
 #ef retrieve(uri: URI):
 #rint(f"Retrieved {uri}")

            # Normally, go get some expensive JSON from the network, a file ...
 #eturn '''
 #
 #$schema": "https://json-schema.org/draft/2020-12/schema",
 #foo": "bar"
 #
 #''

 #ne = Registry(retrieve=retrieve).get_or_retrieve("urn:example:foo")
 #rint(one.value.contents["foo"])

        # Retrieving the same URI again reuses the same value (and thus doesn't
        # print another retrieval message here)
 #wo = Registry(retrieve=retrieve).get_or_retrieve("urn:example:foo")
 #rint(two.value.contents["foo"])

 #. testoutput::

 #etrieved urn:example:foo
 #ar
 #ar

 #""
 #f cache is None:
 #ache = lru_cache(maxsize=None)

 #ef decorator(retrieve: Callable[[URI], _T]):
 #cache
 #ef cached_retrieve(uri: URI):
 #esponse = retrieve(uri)
 #ontents = loads(response)
 #eturn from_contents(contents)

 #eturn cached_retrieve

 #eturn decorator
