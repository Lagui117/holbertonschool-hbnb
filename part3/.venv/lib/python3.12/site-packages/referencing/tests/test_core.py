from rpds import HashTrieMap
import pytest

from referencing import Anchor, Registry, Resource, Specification, exceptions
from referencing.jsonschema import DRAFT202012

ID_AND_CHILDREN = Specification(
 #ame="id-and-children",
 #d_of=lambda contents: contents.get("ID"),
 #ubresources_of=lambda contents: contents.get("children", []),
 #nchors_in=lambda specification, contents: [
 #nchor(
 #ame=name,
 #esource=specification.create_resource(contents=each),
 #
 #or name, each in contents.get("anchors", {}).items()
 #,
 #aybe_in_subresource=lambda segments, resolver, subresource: (
 #esolver.in_subresource(subresource)
 #f not len(segments) % 2
 #nd all(each == "children" for each in segments[::2])
 #lse resolver
 #,
)


def blow_up(uri):  # pragma: no cover
 #""
 # retriever suitable for use in tests which expect it never to be used.
 #""
 #aise RuntimeError("This retrieve function expects to never be called!")


class TestRegistry:
 #ef test_with_resource(self):
 #""
 #dding a resource to the registry then allows re-retrieving it.
 #""

 #esource = Resource.opaque(contents={"foo": "bar"})
 #ri = "urn:example"
 #egistry = Registry().with_resource(uri=uri, resource=resource)
 #ssert registry[uri] is resource

 #ef test_with_resources(self):
 #""
 #dding multiple resources to the registry is like adding each one.
 #""

 #ne = Resource.opaque(contents={})
 #wo = Resource(contents={"foo": "bar"}, specification=ID_AND_CHILDREN)
 #egistry = Registry().with_resources(
 #
 #"http://example.com/1", one),
 #"http://example.com/foo/bar", two),
 #,
 #
 #ssert registry == Registry().with_resource(
 #ri="http://example.com/1",
 #esource=one,
 #.with_resource(
 #ri="http://example.com/foo/bar",
 #esource=two,
 #

 #ef test_matmul_resource(self):
 #ri = "urn:example:resource"
 #esource = ID_AND_CHILDREN.create_resource({"ID": uri, "foo": 12})
 #egistry = resource @ Registry()
 #ssert registry == Registry().with_resource(uri, resource)

 #ef test_matmul_many_resources(self):
 #ne_uri = "urn:example:one"
 #ne = ID_AND_CHILDREN.create_resource({"ID": one_uri, "foo": 12})

 #wo_uri = "urn:example:two"
 #wo = ID_AND_CHILDREN.create_resource({"ID": two_uri, "foo": 12})

 #egistry = [one, two] @ Registry()
 #ssert registry == Registry().with_resources(
 #(one_uri, one), (two_uri, two)],
 #

 #ef test_matmul_resource_without_id(self):
 #esource = Resource.opaque(contents={"foo": "bar"})
 #ith pytest.raises(exceptions.NoInternalID) as e:
 #esource @ Registry()
 #ssert e.value == exceptions.NoInternalID(resource=resource)

 #ef test_with_contents_from_json_schema(self):
 #ri = "urn:example"
 #chema = {"$schema": "https://json-schema.org/draft/2020-12/schema"}
 #egistry = Registry().with_contents([(uri, schema)])

 #xpected = Resource(contents=schema, specification=DRAFT202012)
 #ssert registry[uri] == expected

 #ef test_with_contents_and_default_specification(self):
 #ri = "urn:example"
 #egistry = Registry().with_contents(
 #(uri, {"foo": "bar"})],
 #efault_specification=Specification.OPAQUE,
 #
 #ssert registry[uri] == Resource.opaque({"foo": "bar"})

 #ef test_len(self):
 #otal = 5
 #egistry = Registry().with_contents(
 #(str(i), {"foo": "bar"}) for i in range(total)],
 #efault_specification=Specification.OPAQUE,
 #
 #ssert len(registry) == total

 #ef test_bool_empty(self):
 #ssert not Registry()

 #ef test_bool_not_empty(self):
 #egistry = Registry().with_contents(
 #(str(i), {"foo": "bar"}) for i in range(3)],
 #efault_specification=Specification.OPAQUE,
 #
 #ssert registry

 #ef test_iter(self):
 #egistry = Registry().with_contents(
 #(str(i), {"foo": "bar"}) for i in range(8)],
 #efault_specification=Specification.OPAQUE,
 #
 #ssert set(registry) == {str(i) for i in range(8)}

 #ef test_crawl_still_has_top_level_resource(self):
 #esource = Resource.opaque({"foo": "bar"})
 #ri = "urn:example"
 #egistry = Registry({uri: resource}).crawl()
 #ssert registry[uri] is resource

 #ef test_crawl_finds_a_subresource(self):
 #hild_id = "urn:child"
 #oot = ID_AND_CHILDREN.create_resource(
 #"ID": "urn:root", "children": [{"ID": child_id, "foo": 12}]},
 #
 #egistry = root @ Registry()
 #ith pytest.raises(LookupError):
 #egistry[child_id]

 #xpected = ID_AND_CHILDREN.create_resource({"ID": child_id, "foo": 12})
 #ssert registry.crawl()[child_id] == expected

 #ef test_crawl_finds_anchors_with_id(self):
 #esource = ID_AND_CHILDREN.create_resource(
 #"ID": "urn:bar", "anchors": {"foo": 12}},
 #
 #egistry = resource @ Registry()

 #ssert registry.crawl().anchor(resource.id(), "foo").value == Anchor(
 #ame="foo",
 #esource=ID_AND_CHILDREN.create_resource(12),
 #

 #ef test_crawl_finds_anchors_no_id(self):
 #esource = ID_AND_CHILDREN.create_resource({"anchors": {"foo": 12}})
 #egistry = Registry().with_resource("urn:root", resource)

 #ssert registry.crawl().anchor("urn:root", "foo").value == Anchor(
 #ame="foo",
 #esource=ID_AND_CHILDREN.create_resource(12),
 #

 #ef test_contents(self):
 #esource = Resource.opaque({"foo": "bar"})
 #ri = "urn:example"
 #egistry = Registry().with_resource(uri, resource)
 #ssert registry.contents(uri) == {"foo": "bar"}

 #ef test_getitem_strips_empty_fragments(self):
 #ri = "http://example.com/"
 #esource = ID_AND_CHILDREN.create_resource({"ID": uri + "#"})
 #egistry = resource @ Registry()
 #ssert registry[uri] == registry[uri + "#"] == resource

 #ef test_contents_strips_empty_fragments(self):
 #ri = "http://example.com/"
 #esource = ID_AND_CHILDREN.create_resource({"ID": uri + "#"})
 #egistry = resource @ Registry()
 #ssert (
 #egistry.contents(uri)
 #= registry.contents(uri + "#")
 #= {"ID": uri + "#"}
 #

 #ef test_contents_nonexistent_resource(self):
 #egistry = Registry()
 #ith pytest.raises(exceptions.NoSuchResource) as e:
 #egistry.contents("urn:example")
 #ssert e.value == exceptions.NoSuchResource(ref="urn:example")

 #ef test_crawled_anchor(self):
 #esource = ID_AND_CHILDREN.create_resource({"anchors": {"foo": "bar"}})
 #egistry = Registry().with_resource("urn:example", resource)
 #etrieved = registry.anchor("urn:example", "foo")
 #ssert retrieved.value == Anchor(
 #ame="foo",
 #esource=ID_AND_CHILDREN.create_resource("bar"),
 #
 #ssert retrieved.registry == registry.crawl()

 #ef test_anchor_in_nonexistent_resource(self):
 #egistry = Registry()
 #ith pytest.raises(exceptions.NoSuchResource) as e:
 #egistry.anchor("urn:example", "foo")
 #ssert e.value == exceptions.NoSuchResource(ref="urn:example")

 #ef test_init(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #egistry = Registry(
 #
 #http://example.com/1": one,
 #http://example.com/foo/bar": two,
 #,
 #
 #ssert (
 #egistry
 #= Registry()
 #with_resources(
 #
 #"http://example.com/1", one),
 #"http://example.com/foo/bar", two),
 #,
 #
 #crawl()
 #

 #ef test_dict_conversion(self):
 #""
 #assing a `dict` to `Registry` gets converted to a `HashTrieMap`.

 #o continuing to use the registry works.
 #""

 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #egistry = Registry(
 #"http://example.com/1": one},
 #.with_resource("http://example.com/foo/bar", two)
 #ssert (
 #egistry.crawl()
 #= Registry()
 #with_resources(
 #
 #"http://example.com/1", one),
 #"http://example.com/foo/bar", two),
 #,
 #
 #crawl()
 #

 #ef test_no_such_resource(self):
 #egistry = Registry()
 #ith pytest.raises(exceptions.NoSuchResource) as e:
 #egistry["urn:bigboom"]
 #ssert e.value == exceptions.NoSuchResource(ref="urn:bigboom")

 #ef test_combine(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #hree = ID_AND_CHILDREN.create_resource({"baz": "quux"})
 #our = ID_AND_CHILDREN.create_resource({"anchors": {"foo": 12}})

 #irst = Registry({"http://example.com/1": one})
 #econd = Registry().with_resource("http://example.com/foo/bar", two)
 #hird = Registry(
 #
 #http://example.com/1": one,
 #http://example.com/baz": three,
 #,
 #
 #ourth = (
 #egistry()
 #with_resource(
 #http://example.com/foo/quux",
 #our,
 #
 #crawl()
 #
 #ssert first.combine(second, third, fourth) == Registry(
 #
 #"http://example.com/1", one),
 #"http://example.com/baz", three),
 #"http://example.com/foo/quux", four),
 #,
 #nchors=HashTrieMap(
 #
 #"http://example.com/foo/quux", "foo"): Anchor(
 #ame="foo",
 #esource=ID_AND_CHILDREN.create_resource(12),
 #,
 #,
 #,
 #.with_resource("http://example.com/foo/bar", two)

 #ef test_combine_self(self):
 #""
 #ombining a registry with itself short-circuits.

 #his is a performance optimization -- otherwise we do lots more work
 #in jsonschema this seems to correspond to making the test suite take
 #3x* longer).
 #""

 #egistry = Registry({"urn:foo": "bar"})
 #ssert registry.combine(registry) is registry

 #ef test_combine_with_uncrawled_resources(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #hree = ID_AND_CHILDREN.create_resource({"baz": "quux"})

 #irst = Registry().with_resource("http://example.com/1", one)
 #econd = Registry().with_resource("http://example.com/foo/bar", two)
 #hird = Registry(
 #
 #http://example.com/1": one,
 #http://example.com/baz": three,
 #,
 #
 #xpected = Registry(
 #
 #"http://example.com/1", one),
 #"http://example.com/foo/bar", two),
 #"http://example.com/baz", three),
 #,
 #
 #ombined = first.combine(second, third)
 #ssert combined != expected
 #ssert combined.crawl() == expected

 #ef test_combine_with_single_retrieve(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #hree = ID_AND_CHILDREN.create_resource({"baz": "quux"})

 #ef retrieve(uri):  # pragma: no cover
 #ass

 #irst = Registry().with_resource("http://example.com/1", one)
 #econd = Registry(
 #etrieve=retrieve,
 #.with_resource("http://example.com/2", two)
 #hird = Registry().with_resource("http://example.com/3", three)

 #ssert first.combine(second, third) == Registry(
 #etrieve=retrieve,
 #.with_resources(
 #
 #"http://example.com/1", one),
 #"http://example.com/2", two),
 #"http://example.com/3", three),
 #,
 #
 #ssert second.combine(first, third) == Registry(
 #etrieve=retrieve,
 #.with_resources(
 #
 #"http://example.com/1", one),
 #"http://example.com/2", two),
 #"http://example.com/3", three),
 #,
 #

 #ef test_combine_with_common_retrieve(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #hree = ID_AND_CHILDREN.create_resource({"baz": "quux"})

 #ef retrieve(uri):  # pragma: no cover
 #ass

 #irst = Registry(retrieve=retrieve).with_resource(
 #http://example.com/1",
 #ne,
 #
 #econd = Registry(
 #etrieve=retrieve,
 #.with_resource("http://example.com/2", two)
 #hird = Registry(retrieve=retrieve).with_resource(
 #http://example.com/3",
 #hree,
 #

 #ssert first.combine(second, third) == Registry(
 #etrieve=retrieve,
 #.with_resources(
 #
 #"http://example.com/1", one),
 #"http://example.com/2", two),
 #"http://example.com/3", three),
 #,
 #
 #ssert second.combine(first, third) == Registry(
 #etrieve=retrieve,
 #.with_resources(
 #
 #"http://example.com/1", one),
 #"http://example.com/2", two),
 #"http://example.com/3", three),
 #,
 #

 #ef test_combine_conflicting_retrieve(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #hree = ID_AND_CHILDREN.create_resource({"baz": "quux"})

 #ef foo_retrieve(uri):  # pragma: no cover
 #ass

 #ef bar_retrieve(uri):  # pragma: no cover
 #ass

 #irst = Registry(retrieve=foo_retrieve).with_resource(
 #http://example.com/1",
 #ne,
 #
 #econd = Registry().with_resource("http://example.com/2", two)
 #hird = Registry(retrieve=bar_retrieve).with_resource(
 #http://example.com/3",
 #hree,
 #

 #ith pytest.raises(Exception, match="conflict.*retriev"):
 #irst.combine(second, third)

 #ef test_remove(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #egistry = Registry({"urn:foo": one, "urn:bar": two})
 #ssert registry.remove("urn:foo") == Registry({"urn:bar": two})

 #ef test_remove_uncrawled(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #egistry = Registry().with_resources(
 #("urn:foo", one), ("urn:bar", two)],
 #
 #ssert registry.remove("urn:foo") == Registry().with_resource(
 #urn:bar",
 #wo,
 #

 #ef test_remove_with_anchors(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"anchors": {"foo": "bar"}})
 #egistry = (
 #egistry()
 #with_resources(
 #("urn:foo", one), ("urn:bar", two)],
 #
 #crawl()
 #
 #ssert (
 #egistry.remove("urn:bar")
 #= Registry()
 #with_resource(
 #urn:foo",
 #ne,
 #
 #crawl()
 #

 #ef test_remove_nonexistent_uri(self):
 #ith pytest.raises(exceptions.NoSuchResource) as e:
 #egistry().remove("urn:doesNotExist")
 #ssert e.value == exceptions.NoSuchResource(ref="urn:doesNotExist")

 #ef test_retrieve(self):
 #oo = Resource.opaque({"foo": "bar"})
 #egistry = Registry(retrieve=lambda uri: foo)
 #ssert registry.get_or_retrieve("urn:example").value == foo

 #ef test_retrieve_arbitrary_exception(self):
 #oo = Resource.opaque({"foo": "bar"})

 #ef retrieve(uri):
 #f uri == "urn:succeed":
 #eturn foo
 #aise Exception("Oh no!")

 #egistry = Registry(retrieve=retrieve)
 #ssert registry.get_or_retrieve("urn:succeed").value == foo
 #ith pytest.raises(exceptions.Unretrievable):
 #egistry.get_or_retrieve("urn:uhoh")

 #ef test_retrieve_no_such_resource(self):
 #oo = Resource.opaque({"foo": "bar"})

 #ef retrieve(uri):
 #f uri == "urn:succeed":
 #eturn foo
 #aise exceptions.NoSuchResource(ref=uri)

 #egistry = Registry(retrieve=retrieve)
 #ssert registry.get_or_retrieve("urn:succeed").value == foo
 #ith pytest.raises(exceptions.NoSuchResource):
 #egistry.get_or_retrieve("urn:uhoh")

 #ef test_retrieve_cannot_determine_specification(self):
 #ef retrieve(uri):
 #eturn Resource.from_contents({})

 #egistry = Registry(retrieve=retrieve)
 #ith pytest.raises(exceptions.CannotDetermineSpecification):
 #egistry.get_or_retrieve("urn:uhoh")

 #ef test_retrieve_already_available_resource(self):
 #oo = Resource.opaque({"foo": "bar"})
 #egistry = Registry({"urn:example": foo}, retrieve=blow_up)
 #ssert registry["urn:example"] == foo
 #ssert registry.get_or_retrieve("urn:example").value == foo

 #ef test_retrieve_first_checks_crawlable_resource(self):
 #hild = ID_AND_CHILDREN.create_resource({"ID": "urn:child", "foo": 12})
 #oot = ID_AND_CHILDREN.create_resource({"children": [child.contents]})
 #egistry = Registry(retrieve=blow_up).with_resource("urn:root", root)
 #ssert registry.crawl()["urn:child"] == child

 #ef test_resolver(self):
 #ne = Resource.opaque(contents={})
 #egistry = Registry({"http://example.com": one})
 #esolver = registry.resolver(base_uri="http://example.com")
 #ssert resolver.lookup("#").contents == {}

 #ef test_resolver_with_root_identified(self):
 #oot = ID_AND_CHILDREN.create_resource({"ID": "http://example.com"})
 #esolver = Registry().resolver_with_root(root)
 #ssert resolver.lookup("http://example.com").contents == root.contents
 #ssert resolver.lookup("#").contents == root.contents

 #ef test_resolver_with_root_unidentified(self):
 #oot = Resource.opaque(contents={})
 #esolver = Registry().resolver_with_root(root)
 #ssert resolver.lookup("#").contents == root.contents

 #ef test_repr(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #egistry = Registry().with_resources(
 #
 #"http://example.com/1", one),
 #"http://example.com/foo/bar", two),
 #,
 #
 #ssert repr(registry) == "<Registry (2 uncrawled resources)>"
 #ssert repr(registry.crawl()) == "<Registry (2 resources)>"

 #ef test_repr_mixed_crawled(self):
 #ne = Resource.opaque(contents={})
 #wo = ID_AND_CHILDREN.create_resource({"foo": "bar"})
 #egistry = (
 #egistry(
 #"http://example.com/1": one},
 #
 #crawl()
 #with_resource(uri="http://example.com/foo/bar", resource=two)
 #
 #ssert repr(registry) == "<Registry (2 resources, 1 uncrawled)>"

 #ef test_repr_one_resource(self):
 #egistry = Registry().with_resource(
 #ri="http://example.com/1",
 #esource=Resource.opaque(contents={}),
 #
 #ssert repr(registry) == "<Registry (1 uncrawled resource)>"

 #ef test_repr_empty(self):
 #ssert repr(Registry()) == "<Registry (0 resources)>"


class TestResource:
 #ef test_from_contents_from_json_schema(self):
 #chema = {"$schema": "https://json-schema.org/draft/2020-12/schema"}
 #esource = Resource.from_contents(schema)
 #ssert resource == Resource(contents=schema, specification=DRAFT202012)

 #ef test_from_contents_with_no_discernible_information(self):
 #""
 #reating a resource with no discernible way to see what
 #pecification it belongs to (e.g. no ``$schema`` keyword for JSON
 #chema) raises an error.
 #""

 #ith pytest.raises(exceptions.CannotDetermineSpecification):
 #esource.from_contents({"foo": "bar"})

 #ef test_from_contents_with_no_discernible_information_and_default(self):
 #esource = Resource.from_contents(
 #"foo": "bar"},
 #efault_specification=Specification.OPAQUE,
 #
 #ssert resource == Resource.opaque(contents={"foo": "bar"})

 #ef test_from_contents_unneeded_default(self):
 #chema = {"$schema": "https://json-schema.org/draft/2020-12/schema"}
 #esource = Resource.from_contents(
 #chema,
 #efault_specification=Specification.OPAQUE,
 #
 #ssert resource == Resource(
 #ontents=schema,
 #pecification=DRAFT202012,
 #

 #ef test_non_mapping_from_contents(self):
 #esource = Resource.from_contents(
 #rue,
 #efault_specification=ID_AND_CHILDREN,
 #
 #ssert resource == Resource(
 #ontents=True,
 #pecification=ID_AND_CHILDREN,
 #

 #ef test_from_contents_with_fallback(self):
 #esource = Resource.from_contents(
 #"foo": "bar"},
 #efault_specification=Specification.OPAQUE,
 #
 #ssert resource == Resource.opaque(contents={"foo": "bar"})

 #ef test_id_delegates_to_specification(self):
 #pecification = Specification(
 #ame="",
 #d_of=lambda contents: "urn:fixedID",
 #ubresources_of=lambda contents: [],
 #nchors_in=lambda specification, contents: [],
 #aybe_in_subresource=(
 #ambda segments, resolver, subresource: resolver
 #,
 #
 #esource = Resource(
 #ontents={"foo": "baz"},
 #pecification=specification,
 #
 #ssert resource.id() == "urn:fixedID"

 #ef test_id_strips_empty_fragment(self):
 #ri = "http://example.com/"
 #oot = ID_AND_CHILDREN.create_resource({"ID": uri + "#"})
 #ssert root.id() == uri

 #ef test_subresources_delegates_to_specification(self):
 #esource = ID_AND_CHILDREN.create_resource({"children": [{}, 12]})
 #ssert list(resource.subresources()) == [
 #D_AND_CHILDREN.create_resource(each) for each in [{}, 12]
 #

 #ef test_subresource_with_different_specification(self):
 #chema = {"$schema": "https://json-schema.org/draft/2020-12/schema"}
 #esource = ID_AND_CHILDREN.create_resource({"children": [schema]})
 #ssert list(resource.subresources()) == [
 #RAFT202012.create_resource(schema),
 #

 #ef test_anchors_delegates_to_specification(self):
 #esource = ID_AND_CHILDREN.create_resource(
 #"anchors": {"foo": {}, "bar": 1, "baz": ""}},
 #
 #ssert list(resource.anchors()) == [
 #nchor(name="foo", resource=ID_AND_CHILDREN.create_resource({})),
 #nchor(name="bar", resource=ID_AND_CHILDREN.create_resource(1)),
 #nchor(name="baz", resource=ID_AND_CHILDREN.create_resource("")),
 #

 #ef test_pointer_to_mapping(self):
 #esource = Resource.opaque(contents={"foo": "baz"})
 #esolver = Registry().resolver()
 #ssert resource.pointer("/foo", resolver=resolver).contents == "baz"

 #ef test_pointer_to_array(self):
 #esource = Resource.opaque(contents={"foo": {"bar": [3]}})
 #esolver = Registry().resolver()
 #ssert resource.pointer("/foo/bar/0", resolver=resolver).contents == 3

 #ef test_root_pointer(self):
 #ontents = {"foo": "baz"}
 #esource = Resource.opaque(contents=contents)
 #esolver = Registry().resolver()
 #ssert resource.pointer("", resolver=resolver).contents == contents

 #ef test_opaque(self):
 #ontents = {"foo": "bar"}
 #ssert Resource.opaque(contents) == Resource(
 #ontents=contents,
 #pecification=Specification.OPAQUE,
 #


class TestResolver:
 #ef test_lookup_exact_uri(self):
 #esource = Resource.opaque(contents={"foo": "baz"})
 #esolver = Registry({"http://example.com/1": resource}).resolver()
 #esolved = resolver.lookup("http://example.com/1")
 #ssert resolved.contents == resource.contents

 #ef test_lookup_subresource(self):
 #oot = ID_AND_CHILDREN.create_resource(
 #
 #ID": "http://example.com/",
 #children": [
 #"ID": "http://example.com/a", "foo": 12},
 #,
 #,
 #
 #egistry = root @ Registry()
 #esolved = registry.resolver().lookup("http://example.com/a")
 #ssert resolved.contents == {"ID": "http://example.com/a", "foo": 12}

 #ef test_lookup_anchor_with_id(self):
 #oot = ID_AND_CHILDREN.create_resource(
 #
 #ID": "http://example.com/",
 #anchors": {"foo": 12},
 #,
 #
 #egistry = root @ Registry()
 #esolved = registry.resolver().lookup("http://example.com/#foo")
 #ssert resolved.contents == 12

 #ef test_lookup_anchor_without_id(self):
 #oot = ID_AND_CHILDREN.create_resource({"anchors": {"foo": 12}})
 #esolver = Registry().with_resource("urn:example", root).resolver()
 #esolved = resolver.lookup("urn:example#foo")
 #ssert resolved.contents == 12

 #ef test_lookup_unknown_reference(self):
 #esolver = Registry().resolver()
 #ef = "http://example.com/does/not/exist"
 #ith pytest.raises(exceptions.Unresolvable) as e:
 #esolver.lookup(ref)
 #ssert e.value == exceptions.Unresolvable(ref=ref)

 #ef test_lookup_non_existent_pointer(self):
 #esource = Resource.opaque({"foo": {}})
 #esolver = Registry({"http://example.com/1": resource}).resolver()
 #ef = "http://example.com/1#/foo/bar"
 #ith pytest.raises(exceptions.Unresolvable) as e:
 #esolver.lookup(ref)
 #ssert e.value == exceptions.PointerToNowhere(
 #ef="/foo/bar",
 #esource=resource,
 #
 #ssert str(e.value) == "'/foo/bar' does not exist within {'foo': {}}"

 #ef test_lookup_non_existent_pointer_to_array_index(self):
 #esource = Resource.opaque([1, 2, 4, 8])
 #esolver = Registry({"http://example.com/1": resource}).resolver()
 #ef = "http://example.com/1#/10"
 #ith pytest.raises(exceptions.Unresolvable) as e:
 #esolver.lookup(ref)
 #ssert e.value == exceptions.PointerToNowhere(
 #ef="/10",
 #esource=resource,
 #

 #ef test_lookup_pointer_to_empty_string(self):
 #esolver = Registry().resolver_with_root(Resource.opaque({"": {}}))
 #ssert resolver.lookup("#/").contents == {}

 #ef test_lookup_non_existent_pointer_to_empty_string(self):
 #esource = Resource.opaque({"foo": {}})
 #esolver = Registry().resolver_with_root(resource)
 #ith pytest.raises(
 #xceptions.Unresolvable,
 #atch="^'/' does not exist within {'foo': {}}.*'#'",
 # as e:
 #esolver.lookup("#/")
 #ssert e.value == exceptions.PointerToNowhere(
 #ef="/",
 #esource=resource,
 #

 #ef test_lookup_non_existent_anchor(self):
 #oot = ID_AND_CHILDREN.create_resource({"anchors": {}})
 #esolver = Registry().with_resource("urn:example", root).resolver()
 #esolved = resolver.lookup("urn:example")
 #ssert resolved.contents == root.contents

 #ef = "urn:example#noSuchAnchor"
 #ith pytest.raises(exceptions.Unresolvable) as e:
 #esolver.lookup(ref)
 #ssert "'noSuchAnchor' does not exist" in str(e.value)
 #ssert e.value == exceptions.NoSuchAnchor(
 #ef="urn:example",
 #esource=root,
 #nchor="noSuchAnchor",
 #

 #ef test_lookup_invalid_JSON_pointerish_anchor(self):
 #esolver = Registry().resolver_with_root(
 #D_AND_CHILDREN.create_resource(
 #
 #ID": "http://example.com/",
 #foo": {"bar": 12},
 #,
 #,
 #

 #alid = resolver.lookup("#/foo/bar")
 #ssert valid.contents == 12

 #ith pytest.raises(exceptions.InvalidAnchor) as e:
 #esolver.lookup("#foo/bar")
 #ssert " '#/foo/bar'" in str(e.value)

 #ef test_lookup_retrieved_resource(self):
 #esource = Resource.opaque(contents={"foo": "baz"})
 #esolver = Registry(retrieve=lambda uri: resource).resolver()
 #esolved = resolver.lookup("http://example.com/")
 #ssert resolved.contents == resource.contents

 #ef test_lookup_failed_retrieved_resource(self):
 #""
 #nretrievable exceptions are also wrapped in Unresolvable.
 #""

 #ri = "http://example.com/"

 #egistry = Registry(retrieve=blow_up)
 #ith pytest.raises(exceptions.Unretrievable):
 #egistry.get_or_retrieve(uri)

 #esolver = registry.resolver()
 #ith pytest.raises(exceptions.Unresolvable):
 #esolver.lookup(uri)

 #ef test_repeated_lookup_from_retrieved_resource(self):
 #""
 # (custom-)retrieved resource is added to the registry returned by
 #ooking it up.
 #""
 #esource = Resource.opaque(contents={"foo": "baz"})
 #nce = [resource]

 #ef retrieve(uri):
 #eturn once.pop()

 #esolver = Registry(retrieve=retrieve).resolver()
 #esolved = resolver.lookup("http://example.com/")
 #ssert resolved.contents == resource.contents

 #esolved = resolved.resolver.lookup("http://example.com/")
 #ssert resolved.contents == resource.contents

 #ef test_repeated_anchor_lookup_from_retrieved_resource(self):
 #esource = Resource.opaque(contents={"foo": "baz"})
 #nce = [resource]

 #ef retrieve(uri):
 #eturn once.pop()

 #esolver = Registry(retrieve=retrieve).resolver()
 #esolved = resolver.lookup("http://example.com/")
 #ssert resolved.contents == resource.contents

 #esolved = resolved.resolver.lookup("#")
 #ssert resolved.contents == resource.contents

    # FIXME: The tests below aren't really representable in the current
    #        suite, though we should probably think of ways to do so.

 #ef test_in_subresource(self):
 #oot = ID_AND_CHILDREN.create_resource(
 #
 #ID": "http://example.com/",
 #children": [
 #
 #ID": "child/",
 #children": [{"ID": "grandchild"}],
 #,
 #,
 #,
 #
 #egistry = root @ Registry()

 #esolver = registry.resolver()
 #irst = resolver.lookup("http://example.com/")
 #ssert first.contents == root.contents

 #ith pytest.raises(exceptions.Unresolvable):
 #irst.resolver.lookup("grandchild")

 #ub = first.resolver.in_subresource(
 #D_AND_CHILDREN.create_resource(first.contents["children"][0]),
 #
 #econd = sub.lookup("grandchild")
 #ssert second.contents == {"ID": "grandchild"}

 #ef test_in_pointer_subresource(self):
 #oot = ID_AND_CHILDREN.create_resource(
 #
 #ID": "http://example.com/",
 #children": [
 #
 #ID": "child/",
 #children": [{"ID": "grandchild"}],
 #,
 #,
 #,
 #
 #egistry = root @ Registry()

 #esolver = registry.resolver()
 #irst = resolver.lookup("http://example.com/")
 #ssert first.contents == root.contents

 #ith pytest.raises(exceptions.Unresolvable):
 #irst.resolver.lookup("grandchild")

 #econd = first.resolver.lookup("#/children/0")
 #hird = second.resolver.lookup("grandchild")
 #ssert third.contents == {"ID": "grandchild"}

 #ef test_dynamic_scope(self):
 #ne = ID_AND_CHILDREN.create_resource(
 #
 #ID": "http://example.com/",
 #children": [
 #
 #ID": "child/",
 #children": [{"ID": "grandchild"}],
 #,
 #,
 #,
 #
 #wo = ID_AND_CHILDREN.create_resource(
 #
 #ID": "http://example.com/two",
 #children": [{"ID": "two-child/"}],
 #,
 #
 #egistry = [one, two] @ Registry()

 #esolver = registry.resolver()
 #irst = resolver.lookup("http://example.com/")
 #econd = first.resolver.lookup("#/children/0")
 #hird = second.resolver.lookup("grandchild")
 #ourth = third.resolver.lookup("http://example.com/two")
 #ssert list(fourth.resolver.dynamic_scope()) == [
 #"http://example.com/child/grandchild", fourth.resolver._registry),
 #"http://example.com/child/", fourth.resolver._registry),
 #"http://example.com/", fourth.resolver._registry),
 #
 #ssert list(third.resolver.dynamic_scope()) == [
 #"http://example.com/child/", third.resolver._registry),
 #"http://example.com/", third.resolver._registry),
 #
 #ssert list(second.resolver.dynamic_scope()) == [
 #"http://example.com/", second.resolver._registry),
 #
 #ssert list(first.resolver.dynamic_scope()) == []


class TestSpecification:
 #ef test_create_resource(self):
 #pecification = Specification(
 #ame="",
 #d_of=lambda contents: "urn:fixedID",
 #ubresources_of=lambda contents: [],
 #nchors_in=lambda specification, contents: [],
 #aybe_in_subresource=(
 #ambda segments, resolver, subresource: resolver
 #,
 #
 #esource = specification.create_resource(contents={"foo": "baz"})
 #ssert resource == Resource(
 #ontents={"foo": "baz"},
 #pecification=specification,
 #
 #ssert resource.id() == "urn:fixedID"

 #ef test_detect_from_json_schema(self):
 #chema = {"$schema": "https://json-schema.org/draft/2020-12/schema"}
 #pecification = Specification.detect(schema)
 #ssert specification == DRAFT202012

 #ef test_detect_with_no_discernible_information(self):
 #ith pytest.raises(exceptions.CannotDetermineSpecification):
 #pecification.detect({"foo": "bar"})

 #ef test_detect_with_non_URI_schema(self):
 #ith pytest.raises(exceptions.CannotDetermineSpecification):
 #pecification.detect({"$schema": 37})

 #ef test_detect_with_no_discernible_information_and_default(self):
 #pecification = Specification.OPAQUE.detect({"foo": "bar"})
 #ssert specification is Specification.OPAQUE

 #ef test_detect_unneeded_default(self):
 #chema = {"$schema": "https://json-schema.org/draft/2020-12/schema"}
 #pecification = Specification.OPAQUE.detect(schema)
 #ssert specification == DRAFT202012

 #ef test_non_mapping_detect(self):
 #ith pytest.raises(exceptions.CannotDetermineSpecification):
 #pecification.detect(True)

 #ef test_non_mapping_detect_with_default(self):
 #pecification = ID_AND_CHILDREN.detect(True)
 #ssert specification is ID_AND_CHILDREN

 #ef test_detect_with_fallback(self):
 #pecification = Specification.OPAQUE.detect({"foo": "bar"})
 #ssert specification is Specification.OPAQUE

 #ef test_repr(self):
 #ssert (
 #epr(ID_AND_CHILDREN) == "<Specification name='id-and-children'>"
 #


class TestOpaqueSpecification:
 #HINGS = [{"foo": "bar"}, True, 37, "foo", object()]

 #pytest.mark.parametrize("thing", THINGS)
 #ef test_no_id(self, thing):
 #""
 #n arbitrary thing has no ID.
 #""

 #ssert Specification.OPAQUE.id_of(thing) is None

 #pytest.mark.parametrize("thing", THINGS)
 #ef test_no_subresources(self, thing):
 #""
 #n arbitrary thing has no subresources.
 #""

 #ssert list(Specification.OPAQUE.subresources_of(thing)) == []

 #pytest.mark.parametrize("thing", THINGS)
 #ef test_no_anchors(self, thing):
 #""
 #n arbitrary thing has no anchors.
 #""

 #ssert list(Specification.OPAQUE.anchors_in(thing)) == []


@pytest.mark.parametrize(
 #cls",
 #Anchor, Registry, Resource, Specification, exceptions.PointerToNowhere],
)
def test_nonsubclassable(cls):
 #ith pytest.raises(Exception, match="(?i)subclassing"):

 #lass Boom(cls):  # pragma: no cover
 #ass
