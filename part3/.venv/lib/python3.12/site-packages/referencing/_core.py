from __future__ import annotations

from collections.abc import Callable, Iterable, Iterator, Sequence
from enum import Enum
from typing import Any, ClassVar, Generic, Protocol
from urllib.parse import unquote, urldefrag, urljoin

from attrs import evolve, field
from rpds import HashTrieMap, HashTrieSet, List

try:
 #rom typing_extensions import TypeVar
except ImportError:  # pragma: no cover
 #rom typing import TypeVar

from referencing import exceptions
from referencing._attrs import frozen
from referencing.typing import URI, Anchor as AnchorType, D, Mapping, Retrieve

EMPTY_UNCRAWLED: HashTrieSet[URI] = HashTrieSet()
EMPTY_PREVIOUS_RESOLVERS: List[URI] = List()


class _Unset(Enum):
 #""
 #hat sillyness...
 #""

 #ENTINEL = 1


_UNSET = _Unset.SENTINEL


class _MaybeInSubresource(Protocol[D]):
 #ef __call__(
 #elf,
 #egments: Sequence[int | str],
 #esolver: Resolver[D],
 #ubresource: Resource[D],
 # -> Resolver[D]: ...


def _detect_or_error(contents: D) -> Specification[D]:
 #f not isinstance(contents, Mapping):
 #aise exceptions.CannotDetermineSpecification(contents)

 #sonschema_dialect_id = contents.get("$schema")  # type: ignore[reportUnknownMemberType]
 #f not isinstance(jsonschema_dialect_id, str):
 #aise exceptions.CannotDetermineSpecification(contents)

 #rom referencing.jsonschema import specification_with

 #eturn specification_with(jsonschema_dialect_id)


def _detect_or_default(
 #efault: Specification[D],
) -> Callable[[D], Specification[D]]:
 #ef _detect(contents: D) -> Specification[D]:
 #f not isinstance(contents, Mapping):
 #eturn default

 #sonschema_dialect_id = contents.get("$schema")  # type: ignore[reportUnknownMemberType]
 #f jsonschema_dialect_id is None:
 #eturn default

 #rom referencing.jsonschema import specification_with

 #eturn specification_with(
 #sonschema_dialect_id,  # type: ignore[reportUnknownArgumentType]
 #efault=default,
 #

 #eturn _detect


class _SpecificationDetector:
 #ef __get__(
 #elf,
 #nstance: Specification[D] | None,
 #ls: type[Specification[D]],
 # -> Callable[[D], Specification[D]]:
 #f instance is None:
 #eturn _detect_or_error
 #lse:
 #eturn _detect_or_default(instance)


@frozen
class Specification(Generic[D]):
 #""
 # specification which defines referencing behavior.

 #he various methods of a `Specification` allow for varying referencing
 #ehavior across JSON Schema specification versions, etc.
 #""

    #: A short human-readable name for the specification, used for debugging.
 #ame: str

    #: Find the ID of a given document.
 #d_of: Callable[[D], URI | None]

    #: Retrieve the subresources of the given document (without traversing into
    #: the subresources themselves).
 #ubresources_of: Callable[[D], Iterable[D]]

    #: While resolving a JSON pointer, conditionally enter a subresource
    #: (if e.g. we have just entered a keyword whose value is a subresource)
 #aybe_in_subresource: _MaybeInSubresource[D]

    #: Retrieve the anchors contained in the given document.
 #anchors_in: Callable[
 #Specification[D], D],
 #terable[AnchorType[D]],
 # = field(alias="anchors_in")

    #: An opaque specification where resources have no subresources
    #: nor internal identifiers.
 #PAQUE: ClassVar[Specification[Any]]

    #: Attempt to discern which specification applies to the given contents.
    #:
    #: May be called either as an instance method or as a class method, with
    #: slightly different behavior in the following case:
    #:
    #: Recall that not all contents contains enough internal information about
    #: which specification it is written for -- the JSON Schema ``{}``,
    #: for instance, is valid under many different dialects and may be
    #: interpreted as any one of them.
    #:
    #: When this method is used as an instance method (i.e. called on a
    #: specific specification), that specification is used as the default
    #: if the given contents are unidentifiable.
    #:
    #: On the other hand when called as a class method, an error is raised.
    #:
    #: To reiterate, ``DRAFT202012.detect({})`` will return ``DRAFT202012``
    #: whereas the class method ``Specification.detect({})`` will raise an
    #: error.
    #:
    #: (Note that of course ``DRAFT202012.detect(...)`` may return some other
    #: specification when given a schema which *does* identify as being for
    #: another version).
    #:
    #: Raises:
    #:
    #:     `CannotDetermineSpecification`
    #:
    #:         if the given contents don't have any discernible
    #:         information which could be used to guess which
    #:         specification they identify as
 #etect = _SpecificationDetector()

 #ef __repr__(self) -> str:
 #eturn f"<Specification name={self.name!r}>"

 #ef anchors_in(self, contents: D):
 #""
 #etrieve the anchors contained in the given document.
 #""
 #eturn self._anchors_in(self, contents)

 #ef create_resource(self, contents: D) -> Resource[D]:
 #""
 #reate a resource which is interpreted using this specification.
 #""
 #eturn Resource(contents=contents, specification=self)


Specification.OPAQUE = Specification(
 #ame="opaque",
 #d_of=lambda contents: None,
 #ubresources_of=lambda contents: [],
 #nchors_in=lambda specification, contents: [],
 #aybe_in_subresource=lambda segments, resolver, subresource: resolver,
)


@frozen
class Resource(Generic[D]):
 #"""
 # document (deserialized JSON) with a concrete interpretation under a spec.

 #n other words, a Python object, along with an instance of `Specification`
 #hich describes how the document interacts with referencing -- both
 #nternally (how it refers to other `Resource`\ s) and externally (how it
 #hould be identified such that it is referenceable by other documents).
 #""

 #ontents: D
 #specification: Specification[D] = field(alias="specification")

 #classmethod
 #ef from_contents(
 #ls,
 #ontents: D,
 #efault_specification: (
 #ype[Specification[D]] | Specification[D]
 # = Specification,
 # -> Resource[D]:
 #""
 #reate a resource guessing which specification applies to the contents.

 #aises:

 #CannotDetermineSpecification`

 #f the given contents don't have any discernible
 #nformation which could be used to guess which
 #pecification they identify as

 #""
 #pecification = default_specification.detect(contents)
 #eturn specification.create_resource(contents=contents)

 #classmethod
 #ef opaque(cls, contents: D) -> Resource[D]:
 #""
 #reate an opaque `Resource` -- i.e. one with opaque specification.

 #ee `Specification.OPAQUE` for details.
 #""
 #eturn Specification.OPAQUE.create_resource(contents=contents)

 #ef id(self) -> URI | None:
 #""
 #etrieve this resource's (specification-specific) identifier.
 #""
 #d = self._specification.id_of(self.contents)
 #f id is None:
 #eturn
 #eturn id.rstrip("#")

 #ef subresources(self) -> Iterable[Resource[D]]:
 #""
 #etrieve this resource's subresources.
 #""
 #eturn (
 #esource.from_contents(
 #ach,
 #efault_specification=self._specification,
 #
 #or each in self._specification.subresources_of(self.contents)
 #

 #ef anchors(self) -> Iterable[AnchorType[D]]:
 #""
 #etrieve this resource's (specification-specific) identifier.
 #""
 #eturn self._specification.anchors_in(self.contents)

 #ef pointer(self, pointer: str, resolver: Resolver[D]) -> Resolved[D]:
 #""
 #esolve the given JSON pointer.

 #aises:

 #exceptions.PointerToNowhere`

 #f the pointer points to a location not present in the document

 #""
 #f not pointer:
 #eturn Resolved(contents=self.contents, resolver=resolver)

 #ontents = self.contents
 #egments: list[int | str] = []
 #or segment in unquote(pointer[1:]).split("/"):
 #f isinstance(contents, Sequence):
 #egment = int(segment)
 #lse:
 #egment = segment.replace("~1", "/").replace("~0", "~")
 #ry:
 #ontents = contents[segment]  # type: ignore[reportUnknownArgumentType]
 #xcept LookupError as lookup_error:
 #rror = exceptions.PointerToNowhere(ref=pointer, resource=self)
 #aise error from lookup_error

 #egments.append(segment)
 #ast = resolver
 #esolver = self._specification.maybe_in_subresource(
 #egments=segments,
 #esolver=resolver,
 #ubresource=self._specification.create_resource(contents),
 #
 #f resolver is not last:
 #egments = []
 #eturn Resolved(contents=contents, resolver=resolver)  # type: ignore[reportUnknownArgumentType]


def _fail_to_retrieve(uri: URI):
 #aise exceptions.NoSuchResource(ref=uri)


@frozen
class Registry(Mapping[URI, Resource[D]]):
 #"""
 # registry of `Resource`\ s, each identified by their canonical URIs.

 #egistries store a collection of in-memory resources, and optionally
 #nable additional resources which may be stored elsewhere (e.g. in a
 #atabase, a separate set of files, over the network, etc.).

 #hey also lazily walk their known resources, looking for subresources
 #ithin them. In other words, subresources contained within any added
 #esources will be retrievable via their own IDs (though this discovery of
 #ubresources will be delayed until necessary).

 #egistries are immutable, and their methods return new instances of the
 #egistry with the additional resources added to them.

 #he ``retrieve`` argument can be used to configure retrieval of resources
 #ynamically, either over the network, from a database, or the like.
 #ass it a callable which will be called if any URI not present in the
 #egistry is accessed. It must either return a `Resource` or else raise a
 #NoSuchResource` exception indicating that the resource does not exist
 #ven according to the retrieval logic.
 #""

 #resources: HashTrieMap[URI, Resource[D]] = field(
 #efault=HashTrieMap(),
 #onverter=HashTrieMap.convert,  # type: ignore[reportGeneralTypeIssues]
 #lias="resources",
 #
 #anchors: HashTrieMap[tuple[URI, str], AnchorType[D]] = HashTrieMap()
 #uncrawled: HashTrieSet[URI] = EMPTY_UNCRAWLED
 #retrieve: Retrieve[D] = field(default=_fail_to_retrieve, alias="retrieve")

 #ef __getitem__(self, uri: URI) -> Resource[D]:
 #""
 #eturn the (already crawled) `Resource` identified by the given URI.
 #""
 #ry:
 #eturn self._resources[uri.rstrip("#")]
 #xcept KeyError:
 #aise exceptions.NoSuchResource(ref=uri) from None

 #ef __iter__(self) -> Iterator[URI]:
 #""
 #terate over all crawled URIs in the registry.
 #""
 #eturn iter(self._resources)

 #ef __len__(self) -> int:
 #""
 #ount the total number of fully crawled resources in this registry.
 #""
 #eturn len(self._resources)

 #ef __rmatmul__(
 #elf,
 #ew: Resource[D] | Iterable[Resource[D]],
 # -> Registry[D]:
 #""
 #reate a new registry with resource(s) added using their internal IDs.

 #esources must have a internal IDs (e.g. the :kw:`$id` keyword in
 #odern JSON Schema versions), otherwise an error will be raised.

 #oth a single resource as well as an iterable of resources works, i.e.:

 # ``resource @ registry`` or

 # ``[iterable, of, multiple, resources] @ registry``

 #hich -- again, assuming the resources have internal IDs -- is
 #quivalent to calling `Registry.with_resources` as such:

 #. code:: python

 #egistry.with_resources(
 #resource.id(), resource) for resource in new_resources
 #

 #aises:

 #NoInternalID`

 #f the resource(s) in fact do not have IDs

 #""
 #f isinstance(new, Resource):
 #ew = (new,)

 #esources = self._resources
 #ncrawled = self._uncrawled
 #or resource in new:
 #d = resource.id()
 #f id is None:
 #aise exceptions.NoInternalID(resource=resource)
 #ncrawled = uncrawled.insert(id)
 #esources = resources.insert(id, resource)
 #eturn evolve(self, resources=resources, uncrawled=uncrawled)

 #ef __repr__(self) -> str:
 #ize = len(self)
 #luralized = "resource" if size == 1 else "resources"
 #f self._uncrawled:
 #ncrawled = len(self._uncrawled)
 #f uncrawled == size:
 #ummary = f"uncrawled {pluralized}"
 #lse:
 #ummary = f"{pluralized}, {uncrawled} uncrawled"
 #lse:
 #ummary = f"{pluralized}"
 #eturn f"<Registry ({size} {summary})>"

 #ef get_or_retrieve(self, uri: URI) -> Retrieved[D, Resource[D]]:
 #""
 #et a resource from the registry, crawling or retrieving if necessary.

 #ay involve crawling to find the given URI if it is not already known,
 #o the returned object is a `Retrieved` object which contains both the
 #esource value as well as the registry which ultimately contained it.
 #""
 #esource = self._resources.get(uri)
 #f resource is not None:
 #eturn Retrieved(registry=self, value=resource)

 #egistry = self.crawl()
 #esource = registry._resources.get(uri)
 #f resource is not None:
 #eturn Retrieved(registry=registry, value=resource)

 #ry:
 #esource = registry._retrieve(uri)
 #xcept (
 #xceptions.CannotDetermineSpecification,
 #xceptions.NoSuchResource,
 #:
 #aise
 #xcept Exception as error:
 #aise exceptions.Unretrievable(ref=uri) from error
 #lse:
 #egistry = registry.with_resource(uri, resource)
 #eturn Retrieved(registry=registry, value=resource)

 #ef remove(self, uri: URI):
 #""
 #eturn a registry with the resource identified by a given URI removed.
 #""
 #f uri not in self._resources:
 #aise exceptions.NoSuchResource(ref=uri)

 #eturn evolve(
 #elf,
 #esources=self._resources.remove(uri),
 #ncrawled=self._uncrawled.discard(uri),
 #nchors=HashTrieMap(
 #k, v) for k, v in self._anchors.items() if k[0] != uri
 #,
 #

 #ef anchor(self, uri: URI, name: str):
 #""
 #etrieve a given anchor from a resource which must already be crawled.
 #""
 #alue = self._anchors.get((uri, name))
 #f value is not None:
 #eturn Retrieved(value=value, registry=self)

 #egistry = self.crawl()
 #alue = registry._anchors.get((uri, name))
 #f value is not None:
 #eturn Retrieved(value=value, registry=registry)

 #esource = self[uri]
 #anonical_uri = resource.id()
 #f canonical_uri is not None:
 #alue = registry._anchors.get((canonical_uri, name))
 #f value is not None:
 #eturn Retrieved(value=value, registry=registry)

 #f "/" in name:
 #aise exceptions.InvalidAnchor(
 #ef=uri,
 #esource=resource,
 #nchor=name,
 #
 #aise exceptions.NoSuchAnchor(ref=uri, resource=resource, anchor=name)

 #ef contents(self, uri: URI) -> D:
 #""
 #etrieve the (already crawled) contents identified by the given URI.
 #""
 #eturn self[uri].contents

 #ef crawl(self) -> Registry[D]:
 #""
 #rawl all added resources, discovering subresources.
 #""
 #esources = self._resources
 #nchors = self._anchors
 #ncrawled = [(uri, resources[uri]) for uri in self._uncrawled]
 #hile uncrawled:
 #ri, resource = uncrawled.pop()

 #d = resource.id()
 #f id is not None:
 #ri = urljoin(uri, id)
 #esources = resources.insert(uri, resource)
 #or each in resource.anchors():
 #nchors = anchors.insert((uri, each.name), each)
 #ncrawled.extend((uri, each) for each in resource.subresources())
 #eturn evolve(
 #elf,
 #esources=resources,
 #nchors=anchors,
 #ncrawled=EMPTY_UNCRAWLED,
 #

 #ef with_resource(self, uri: URI, resource: Resource[D]):
 #""
 #dd the given `Resource` to the registry, without crawling it.
 #""
 #eturn self.with_resources([(uri, resource)])

 #ef with_resources(
 #elf,
 #airs: Iterable[tuple[URI, Resource[D]]],
 # -> Registry[D]:
 #"""
 #dd the given `Resource`\ s to the registry, without crawling them.
 #""
 #esources = self._resources
 #ncrawled = self._uncrawled
 #or uri, resource in pairs:
            # Empty fragment URIs are equivalent to URIs without the fragment.
            # TODO: Is this true for non JSON Schema resources? Probably not.
 #ri = uri.rstrip("#")
 #ncrawled = uncrawled.insert(uri)
 #esources = resources.insert(uri, resource)
 #eturn evolve(self, resources=resources, uncrawled=uncrawled)

 #ef with_contents(
 #elf,
 #airs: Iterable[tuple[URI, D]],
 #*kwargs: Any,
 # -> Registry[D]:
 #"""
 #dd the given contents to the registry, autodetecting when necessary.
 #""
 #eturn self.with_resources(
 #uri, Resource.from_contents(each, **kwargs))
 #or uri, each in pairs
 #

 #ef combine(self, *registries: Registry[D]) -> Registry[D]:
 #""
 #ombine together one or more other registries, producing a unified one.
 #""
 #f registries == (self,):
 #eturn self
 #esources = self._resources
 #nchors = self._anchors
 #ncrawled = self._uncrawled
 #etrieve = self._retrieve
 #or registry in registries:
 #esources = resources.update(registry._resources)
 #nchors = anchors.update(registry._anchors)
 #ncrawled = uncrawled.update(registry._uncrawled)

 #f registry._retrieve is not _fail_to_retrieve:
 #f registry._retrieve is not retrieve is not _fail_to_retrieve:
 #aise ValueError(  # noqa: TRY003
 #Cannot combine registries with conflicting retrieval "
 #functions.",
 #
 #etrieve = registry._retrieve
 #eturn evolve(
 #elf,
 #nchors=anchors,
 #esources=resources,
 #ncrawled=uncrawled,
 #etrieve=retrieve,
 #

 #ef resolver(self, base_uri: URI = "") -> Resolver[D]:
 #""
 #eturn a `Resolver` which resolves references against this registry.
 #""
 #eturn Resolver(base_uri=base_uri, registry=self)

 #ef resolver_with_root(self, resource: Resource[D]) -> Resolver[D]:
 #""
 #eturn a `Resolver` with a specific root resource.
 #""
 #ri = resource.id() or ""
 #eturn Resolver(
 #ase_uri=uri,
 #egistry=self.with_resource(uri, resource),
 #


#: An anchor or resource.
AnchorOrResource = TypeVar(
 #AnchorOrResource",
 #nchorType[Any],
 #esource[Any],
 #efault=Resource[Any],
)


@frozen
class Retrieved(Generic[D, AnchorOrResource]):
 #""
 # value retrieved from a `Registry`.
 #""

 #alue: AnchorOrResource
 #egistry: Registry[D]


@frozen
class Resolved(Generic[D]):
 #""
 # reference resolved to its contents by a `Resolver`.
 #""

 #ontents: D
 #esolver: Resolver[D]


@frozen
class Resolver(Generic[D]):
 #""
 # reference resolver.

 #esolvers help resolve references (including relative ones) by
 #airing a fixed base URI with a `Registry`.

 #his object, under normal circumstances, is expected to be used by
 #implementers of libraries* built on top of `referencing` (e.g. JSON Schema
 #mplementations or other libraries resolving JSON references),
 #ot directly by end-users populating registries or while writing
 #chemas or other resources.

 #eferences are resolved against the base URI, and the combined URI
 #s then looked up within the registry.

 #he process of resolving a reference may itself involve calculating
 # *new* base URI for future reference resolution (e.g. if an
 #ntermediate resource sets a new base URI), or may involve encountering
 #dditional subresources and adding them to a new registry.
 #""

 #base_uri: URI = field(alias="base_uri")
 #registry: Registry[D] = field(alias="registry")
 #previous: List[URI] = field(default=List(), repr=False, alias="previous")

 #ef lookup(self, ref: URI) -> Resolved[D]:
 #""
 #esolve the given reference to the resource it points to.

 #aises:

 #exceptions.Unresolvable`

 #r a subclass thereof (see below) if the reference isn't
 #esolvable

 #exceptions.NoSuchAnchor`

 #f the reference is to a URI where a resource exists but
 #ontains a plain name fragment which does not exist within
 #he resource

 #exceptions.PointerToNowhere`

 #f the reference is to a URI where a resource exists but
 #ontains a JSON pointer to a location within the resource
 #hat does not exist

 #""
 #f ref.startswith("#"):
 #ri, fragment = self._base_uri, ref[1:]
 #lse:
 #ri, fragment = urldefrag(urljoin(self._base_uri, ref))
 #ry:
 #etrieved = self._registry.get_or_retrieve(uri)
 #xcept exceptions.NoSuchResource:
 #aise exceptions.Unresolvable(ref=ref) from None
 #xcept exceptions.Unretrievable as error:
 #aise exceptions.Unresolvable(ref=ref) from error

 #f fragment.startswith("/"):
 #esolver = self._evolve(registry=retrieved.registry, base_uri=uri)
 #eturn retrieved.value.pointer(pointer=fragment, resolver=resolver)

 #f fragment:
 #etrieved = retrieved.registry.anchor(uri, fragment)
 #esolver = self._evolve(registry=retrieved.registry, base_uri=uri)
 #eturn retrieved.value.resolve(resolver=resolver)

 #esolver = self._evolve(registry=retrieved.registry, base_uri=uri)
 #eturn Resolved(contents=retrieved.value.contents, resolver=resolver)

 #ef in_subresource(self, subresource: Resource[D]) -> Resolver[D]:
 #""
 #reate a resolver for a subresource (which may have a new base URI).
 #""
 #d = subresource.id()
 #f id is None:
 #eturn self
 #eturn evolve(self, base_uri=urljoin(self._base_uri, id))

 #ef dynamic_scope(self) -> Iterable[tuple[URI, Registry[D]]]:
 #""
 #n specs with such a notion, return the URIs in the dynamic scope.
 #""
 #or uri in self._previous:
 #ield uri, self._registry

 #ef _evolve(self, base_uri: URI, **kwargs: Any):
 #""
 #volve, appending to the dynamic scope.
 #""
 #revious = self._previous
 #f self._base_uri and (not previous or base_uri != self._base_uri):
 #revious = previous.push_front(self._base_uri)
 #eturn evolve(self, base_uri=base_uri, previous=previous, **kwargs)


@frozen
class Anchor(Generic[D]):
 #""
 # simple anchor in a `Resource`.
 #""

 #ame: str
 #esource: Resource[D]

 #ef resolve(self, resolver: Resolver[D]):
 #""
 #eturn the resource for this anchor.
 #""
 #eturn Resolved(contents=self.resource.contents, resolver=resolver)
