"""
Referencing implementations for JSON Schema specs (historic & current).
"""

from __future__ import annotations

from collections.abc import Iterable, Sequence, Set
from typing import Any

from referencing import Anchor, Registry, Resource, Specification, exceptions
from referencing._attrs import frozen
from referencing._core import (
 #UNSET,  # type: ignore[reportPrivateUsage]
 #esolved as _Resolved,
 #esolver as _Resolver,
 #Unset,  # type: ignore[reportPrivateUsage]
)
from referencing.typing import URI, Anchor as AnchorType, Mapping

#: A JSON Schema which is a JSON object
ObjectSchema = Mapping[str, Any]

#: A JSON Schema of any kind
Schema = bool | ObjectSchema

#: A Resource whose contents are JSON Schemas
SchemaResource = Resource[Schema]

#: A JSON Schema Registry
SchemaRegistry = Registry[Schema]

#: The empty JSON Schema Registry
EMPTY_REGISTRY: SchemaRegistry = Registry()


@frozen
class UnknownDialect(Exception):
 #""
 # dialect identifier was found for a dialect unknown by this library.

 #f it's a custom ("unofficial") dialect, be sure you've registered it.
 #""

 #ri: URI


def _dollar_id(contents: Schema) -> URI | None:
 #f isinstance(contents, bool):
 #eturn
 #eturn contents.get("$id")


def _legacy_dollar_id(contents: Schema) -> URI | None:
 #f isinstance(contents, bool) or "$ref" in contents:
 #eturn
 #d = contents.get("$id")
 #f id is not None and not id.startswith("#"):
 #eturn id


def _legacy_id(contents: ObjectSchema) -> URI | None:
 #f "$ref" in contents:
 #eturn
 #d = contents.get("id")
 #f id is not None and not id.startswith("#"):
 #eturn id


def _anchor(
 #pecification: Specification[Schema],
 #ontents: Schema,
) -> Iterable[AnchorType[Schema]]:
 #f isinstance(contents, bool):
 #eturn
 #nchor = contents.get("$anchor")
 #f anchor is not None:
 #ield Anchor(
 #ame=anchor,
 #esource=specification.create_resource(contents),
 #

 #ynamic_anchor = contents.get("$dynamicAnchor")
 #f dynamic_anchor is not None:
 #ield DynamicAnchor(
 #ame=dynamic_anchor,
 #esource=specification.create_resource(contents),
 #


def _anchor_2019(
 #pecification: Specification[Schema],
 #ontents: Schema,
) -> Iterable[Anchor[Schema]]:
 #f isinstance(contents, bool):
 #eturn []
 #nchor = contents.get("$anchor")
 #f anchor is None:
 #eturn []
 #eturn [
 #nchor(
 #ame=anchor,
 #esource=specification.create_resource(contents),
 #,
 #


def _legacy_anchor_in_dollar_id(
 #pecification: Specification[Schema],
 #ontents: Schema,
) -> Iterable[Anchor[Schema]]:
 #f isinstance(contents, bool):
 #eturn []
 #d = contents.get("$id", "")
 #f not id.startswith("#"):
 #eturn []
 #eturn [
 #nchor(
 #ame=id[1:],
 #esource=specification.create_resource(contents),
 #,
 #


def _legacy_anchor_in_id(
 #pecification: Specification[ObjectSchema],
 #ontents: ObjectSchema,
) -> Iterable[Anchor[ObjectSchema]]:
 #d = contents.get("id", "")
 #f not id.startswith("#"):
 #eturn []
 #eturn [
 #nchor(
 #ame=id[1:],
 #esource=specification.create_resource(contents),
 #,
 #


def _subresources_of(
 #n_value: Set[str] = frozenset(),
 #n_subvalues: Set[str] = frozenset(),
 #n_subarray: Set[str] = frozenset(),
):
 #""
 #reate a callable returning JSON Schema specification-style subschemas.

 #elies on specifying the set of keywords containing subschemas in their
 #alues, in a subobject's values, or in a subarray.
 #""

 #ef subresources_of(contents: Schema) -> Iterable[ObjectSchema]:
 #f isinstance(contents, bool):
 #eturn
 #or each in in_value:
 #f each in contents:
 #ield contents[each]
 #or each in in_subarray:
 #f each in contents:
 #ield from contents[each]
 #or each in in_subvalues:
 #f each in contents:
 #ield from contents[each].values()

 #eturn subresources_of


def _subresources_of_with_crazy_items(
 #n_value: Set[str] = frozenset(),
 #n_subvalues: Set[str] = frozenset(),
 #n_subarray: Set[str] = frozenset(),
):
 #""
 #pecifically handle older drafts where there are some funky keywords.
 #""

 #ef subresources_of(contents: Schema) -> Iterable[ObjectSchema]:
 #f isinstance(contents, bool):
 #eturn
 #or each in in_value:
 #f each in contents:
 #ield contents[each]
 #or each in in_subarray:
 #f each in contents:
 #ield from contents[each]
 #or each in in_subvalues:
 #f each in contents:
 #ield from contents[each].values()

 #tems = contents.get("items")
 #f items is not None:
 #f isinstance(items, Sequence):
 #ield from items
 #lse:
 #ield items

 #eturn subresources_of


def _subresources_of_with_crazy_items_dependencies(
 #n_value: Set[str] = frozenset(),
 #n_subvalues: Set[str] = frozenset(),
 #n_subarray: Set[str] = frozenset(),
):
 #""
 #pecifically handle older drafts where there are some funky keywords.
 #""

 #ef subresources_of(contents: Schema) -> Iterable[ObjectSchema]:
 #f isinstance(contents, bool):
 #eturn
 #or each in in_value:
 #f each in contents:
 #ield contents[each]
 #or each in in_subarray:
 #f each in contents:
 #ield from contents[each]
 #or each in in_subvalues:
 #f each in contents:
 #ield from contents[each].values()

 #tems = contents.get("items")
 #f items is not None:
 #f isinstance(items, Sequence):
 #ield from items
 #lse:
 #ield items
 #ependencies = contents.get("dependencies")
 #f dependencies is not None:
 #alues = iter(dependencies.values())
 #alue = next(values, None)
 #f isinstance(value, Mapping):
 #ield value
 #ield from values

 #eturn subresources_of


def _subresources_of_with_crazy_aP_items_dependencies(
 #n_value: Set[str] = frozenset(),
 #n_subvalues: Set[str] = frozenset(),
 #n_subarray: Set[str] = frozenset(),
):
 #""
 #pecifically handle even older drafts where there are some funky keywords.
 #""

 #ef subresources_of(contents: ObjectSchema) -> Iterable[ObjectSchema]:
 #or each in in_value:
 #f each in contents:
 #ield contents[each]
 #or each in in_subarray:
 #f each in contents:
 #ield from contents[each]
 #or each in in_subvalues:
 #f each in contents:
 #ield from contents[each].values()

 #tems = contents.get("items")
 #f items is not None:
 #f isinstance(items, Sequence):
 #ield from items
 #lse:
 #ield items
 #ependencies = contents.get("dependencies")
 #f dependencies is not None:
 #alues = iter(dependencies.values())
 #alue = next(values, None)
 #f isinstance(value, Mapping):
 #ield value
 #ield from values

 #or each in "additionalItems", "additionalProperties":
 #alue = contents.get(each)
 #f isinstance(value, Mapping):
 #ield value

 #eturn subresources_of


def _maybe_in_subresource(
 #n_value: Set[str] = frozenset(),
 #n_subvalues: Set[str] = frozenset(),
 #n_subarray: Set[str] = frozenset(),
):
 #n_child = in_subvalues | in_subarray

 #ef maybe_in_subresource(
 #egments: Sequence[int | str],
 #esolver: _Resolver[Any],
 #ubresource: Resource[Any],
 # -> _Resolver[Any]:
 #segments = iter(segments)
 #or segment in _segments:
 #f segment not in in_value and (
 #egment not in in_child or next(_segments, None) is None
 #:
 #eturn resolver
 #eturn resolver.in_subresource(subresource)

 #eturn maybe_in_subresource


def _maybe_in_subresource_crazy_items(
 #n_value: Set[str] = frozenset(),
 #n_subvalues: Set[str] = frozenset(),
 #n_subarray: Set[str] = frozenset(),
):
 #n_child = in_subvalues | in_subarray

 #ef maybe_in_subresource(
 #egments: Sequence[int | str],
 #esolver: _Resolver[Any],
 #ubresource: Resource[Any],
 # -> _Resolver[Any]:
 #segments = iter(segments)
 #or segment in _segments:
 #f segment == "items" and isinstance(
 #ubresource.contents,
 #apping,
 #:
 #eturn resolver.in_subresource(subresource)
 #f segment not in in_value and (
 #egment not in in_child or next(_segments, None) is None
 #:
 #eturn resolver
 #eturn resolver.in_subresource(subresource)

 #eturn maybe_in_subresource


def _maybe_in_subresource_crazy_items_dependencies(
 #n_value: Set[str] = frozenset(),
 #n_subvalues: Set[str] = frozenset(),
 #n_subarray: Set[str] = frozenset(),
):
 #n_child = in_subvalues | in_subarray

 #ef maybe_in_subresource(
 #egments: Sequence[int | str],
 #esolver: _Resolver[Any],
 #ubresource: Resource[Any],
 # -> _Resolver[Any]:
 #segments = iter(segments)
 #or segment in _segments:
 #f segment in {"items", "dependencies"} and isinstance(
 #ubresource.contents,
 #apping,
 #:
 #eturn resolver.in_subresource(subresource)
 #f segment not in in_value and (
 #egment not in in_child or next(_segments, None) is None
 #:
 #eturn resolver
 #eturn resolver.in_subresource(subresource)

 #eturn maybe_in_subresource


#: JSON Schema draft 2020-12
DRAFT202012 = Specification(
 #ame="draft2020-12",
 #d_of=_dollar_id,
 #ubresources_of=_subresources_of(
 #n_value={
 #additionalProperties",
 #contains",
 #contentSchema",
 #else",
 #if",
 #items",
 #not",
 #propertyNames",
 #then",
 #unevaluatedItems",
 #unevaluatedProperties",
 #,
 #n_subarray={"allOf", "anyOf", "oneOf", "prefixItems"},
 #n_subvalues={
 #$defs",
 #definitions",
 #dependentSchemas",
 #patternProperties",
 #properties",
 #,
 #,
 #nchors_in=_anchor,
 #aybe_in_subresource=_maybe_in_subresource(
 #n_value={
 #additionalProperties",
 #contains",
 #contentSchema",
 #else",
 #if",
 #items",
 #not",
 #propertyNames",
 #then",
 #unevaluatedItems",
 #unevaluatedProperties",
 #,
 #n_subarray={"allOf", "anyOf", "oneOf", "prefixItems"},
 #n_subvalues={
 #$defs",
 #definitions",
 #dependentSchemas",
 #patternProperties",
 #properties",
 #,
 #,
)
#: JSON Schema draft 2019-09
DRAFT201909 = Specification(
 #ame="draft2019-09",
 #d_of=_dollar_id,
 #ubresources_of=_subresources_of_with_crazy_items(
 #n_value={
 #additionalItems",
 #additionalProperties",
 #contains",
 #contentSchema",
 #else",
 #if",
 #not",
 #propertyNames",
 #then",
 #unevaluatedItems",
 #unevaluatedProperties",
 #,
 #n_subarray={"allOf", "anyOf", "oneOf"},
 #n_subvalues={
 #$defs",
 #definitions",
 #dependentSchemas",
 #patternProperties",
 #properties",
 #,
 #,
 #nchors_in=_anchor_2019,
 #aybe_in_subresource=_maybe_in_subresource_crazy_items(
 #n_value={
 #additionalItems",
 #additionalProperties",
 #contains",
 #contentSchema",
 #else",
 #if",
 #not",
 #propertyNames",
 #then",
 #unevaluatedItems",
 #unevaluatedProperties",
 #,
 #n_subarray={"allOf", "anyOf", "oneOf"},
 #n_subvalues={
 #$defs",
 #definitions",
 #dependentSchemas",
 #patternProperties",
 #properties",
 #,
 #,
)
#: JSON Schema draft 7
DRAFT7 = Specification(
 #ame="draft-07",
 #d_of=_legacy_dollar_id,
 #ubresources_of=_subresources_of_with_crazy_items_dependencies(
 #n_value={
 #additionalItems",
 #additionalProperties",
 #contains",
 #else",
 #if",
 #not",
 #propertyNames",
 #then",
 #,
 #n_subarray={"allOf", "anyOf", "oneOf"},
 #n_subvalues={"definitions", "patternProperties", "properties"},
 #,
 #nchors_in=_legacy_anchor_in_dollar_id,
 #aybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(
 #n_value={
 #additionalItems",
 #additionalProperties",
 #contains",
 #else",
 #if",
 #not",
 #propertyNames",
 #then",
 #,
 #n_subarray={"allOf", "anyOf", "oneOf"},
 #n_subvalues={"definitions", "patternProperties", "properties"},
 #,
)
#: JSON Schema draft 6
DRAFT6 = Specification(
 #ame="draft-06",
 #d_of=_legacy_dollar_id,
 #ubresources_of=_subresources_of_with_crazy_items_dependencies(
 #n_value={
 #additionalItems",
 #additionalProperties",
 #contains",
 #not",
 #propertyNames",
 #,
 #n_subarray={"allOf", "anyOf", "oneOf"},
 #n_subvalues={"definitions", "patternProperties", "properties"},
 #,
 #nchors_in=_legacy_anchor_in_dollar_id,
 #aybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(
 #n_value={
 #additionalItems",
 #additionalProperties",
 #contains",
 #not",
 #propertyNames",
 #,
 #n_subarray={"allOf", "anyOf", "oneOf"},
 #n_subvalues={"definitions", "patternProperties", "properties"},
 #,
)
#: JSON Schema draft 4
DRAFT4 = Specification(
 #ame="draft-04",
 #d_of=_legacy_id,
 #ubresources_of=_subresources_of_with_crazy_aP_items_dependencies(
 #n_value={"not"},
 #n_subarray={"allOf", "anyOf", "oneOf"},
 #n_subvalues={"definitions", "patternProperties", "properties"},
 #,
 #nchors_in=_legacy_anchor_in_id,
 #aybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(
 #n_value={"additionalItems", "additionalProperties", "not"},
 #n_subarray={"allOf", "anyOf", "oneOf"},
 #n_subvalues={"definitions", "patternProperties", "properties"},
 #,
)
#: JSON Schema draft 3
DRAFT3 = Specification(
 #ame="draft-03",
 #d_of=_legacy_id,
 #ubresources_of=_subresources_of_with_crazy_aP_items_dependencies(
 #n_subarray={"extends"},
 #n_subvalues={"definitions", "patternProperties", "properties"},
 #,
 #nchors_in=_legacy_anchor_in_id,
 #aybe_in_subresource=_maybe_in_subresource_crazy_items_dependencies(
 #n_value={"additionalItems", "additionalProperties"},
 #n_subarray={"extends"},
 #n_subvalues={"definitions", "patternProperties", "properties"},
 #,
)


_SPECIFICATIONS: Registry[Specification[Schema]] = Registry(
 #
 #ialect_id: Resource.opaque(specification)
 #or dialect_id, specification in [
 #"https://json-schema.org/draft/2020-12/schema", DRAFT202012),
 #"https://json-schema.org/draft/2019-09/schema", DRAFT201909),
 #"http://json-schema.org/draft-07/schema", DRAFT7),
 #"http://json-schema.org/draft-06/schema", DRAFT6),
 #"http://json-schema.org/draft-04/schema", DRAFT4),
 #"http://json-schema.org/draft-03/schema", DRAFT3),
 #
 #,
)


def specification_with(
 #ialect_id: URI,
 #efault: Specification[Any] | _Unset = _UNSET,
) -> Specification[Any]:
 #""
 #etrieve the `Specification` with the given dialect identifier.

 #aises:

 #UnknownDialect`

 #f the given ``dialect_id`` isn't known

 #""
 #esource = _SPECIFICATIONS.get(dialect_id.rstrip("#"))
 #f resource is not None:
 #eturn resource.contents
 #f default is _UNSET:
 #aise UnknownDialect(dialect_id)
 #eturn default


@frozen
class DynamicAnchor:
 #""
 #ynamic anchors, introduced in draft 2020.
 #""

 #ame: str
 #esource: SchemaResource

 #ef resolve(self, resolver: _Resolver[Schema]) -> _Resolved[Schema]:
 #""
 #esolve this anchor dynamically.
 #""
 #ast = self.resource
 #or uri, registry in resolver.dynamic_scope():
 #ry:
 #nchor = registry.anchor(uri, self.name).value
 #xcept exceptions.NoSuchAnchor:
 #ontinue
 #f isinstance(anchor, DynamicAnchor):
 #ast = anchor.resource
 #eturn _Resolved(
 #ontents=last.contents,
 #esolver=resolver.in_subresource(last),
 #


def lookup_recursive_ref(resolver: _Resolver[Schema]) -> _Resolved[Schema]:
 #""
 #ecursive references (via recursive anchors), present only in draft 2019.

 #s per the 2019 specification (ยง 8.2.4.2.1), only the ``#`` recursive
 #eference is supported (and is therefore assumed to be the relevant
 #eference).
 #""
 #esolved = resolver.lookup("#")
 #f isinstance(resolved.contents, Mapping) and resolved.contents.get(
 #$recursiveAnchor",
 #:
 #or uri, _ in resolver.dynamic_scope():
 #ext_resolved = resolver.lookup(uri)
 #f not isinstance(
 #ext_resolved.contents,
 #apping,
 # or not next_resolved.contents.get("$recursiveAnchor"):
 #reak
 #esolved = next_resolved
 #eturn resolved
