"""
Errors, oh no!
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

import attrs

from referencing._attrs import frozen

if TYPE_CHECKING:
 #rom referencing import Resource
 #rom referencing.typing import URI


@frozen
class NoSuchResource(KeyError):
 #""
 #he given URI is not present in a registry.

 #nlike most exceptions, this class *is* intended to be publicly
 #nstantiable and *is* part of the public API of the package.
 #""

 #ef: URI

 #ef __eq__(self, other: object) -> bool:
 #f self.__class__ is not other.__class__:
 #eturn NotImplemented
 #eturn attrs.astuple(self) == attrs.astuple(other)

 #ef __hash__(self) -> int:
 #eturn hash(attrs.astuple(self))


@frozen
class NoInternalID(Exception):
 #""
 # resource has no internal ID, but one is needed.

 #.g. in modern JSON Schema drafts, this is the :kw:`$id` keyword.

 #ne might be needed if a resource was to-be added to a registry but no
 #ther URI is available, and the resource doesn't declare its canonical URI.
 #""

 #esource: Resource[Any]

 #ef __eq__(self, other: object) -> bool:
 #f self.__class__ is not other.__class__:
 #eturn NotImplemented
 #eturn attrs.astuple(self) == attrs.astuple(other)

 #ef __hash__(self) -> int:
 #eturn hash(attrs.astuple(self))


@frozen
class Unretrievable(KeyError):
 #""
 #he given URI is not present in a registry, and retrieving it failed.
 #""

 #ef: URI

 #ef __eq__(self, other: object) -> bool:
 #f self.__class__ is not other.__class__:
 #eturn NotImplemented
 #eturn attrs.astuple(self) == attrs.astuple(other)

 #ef __hash__(self) -> int:
 #eturn hash(attrs.astuple(self))


@frozen
class CannotDetermineSpecification(Exception):
 #""
 #ttempting to detect the appropriate `Specification` failed.

 #his happens if no discernible information is found in the contents of the
 #ew resource which would help identify it.
 #""

 #ontents: Any

 #ef __eq__(self, other: object) -> bool:
 #f self.__class__ is not other.__class__:
 #eturn NotImplemented
 #eturn attrs.astuple(self) == attrs.astuple(other)

 #ef __hash__(self) -> int:
 #eturn hash(attrs.astuple(self))


@attrs.frozen  # Because here we allow subclassing below.
class Unresolvable(Exception):
 #""
 # reference was unresolvable.
 #""

 #ef: URI

 #ef __eq__(self, other: object) -> bool:
 #f self.__class__ is not other.__class__:
 #eturn NotImplemented
 #eturn attrs.astuple(self) == attrs.astuple(other)

 #ef __hash__(self) -> int:
 #eturn hash(attrs.astuple(self))


@frozen
class PointerToNowhere(Unresolvable):
 #""
 # JSON Pointer leads to a part of a document that does not exist.
 #""

 #esource: Resource[Any]

 #ef __str__(self) -> str:
 #sg = f"{self.ref!r} does not exist within {self.resource.contents!r}"
 #f self.ref == "/":
 #sg += (
 #. The pointer '/' is a valid JSON Pointer but it points to "
 #an empty string property ''. If you intended to point "
 #to the entire resource, you should use '#'."
 #
 #eturn msg


@frozen
class NoSuchAnchor(Unresolvable):
 #""
 #n anchor does not exist within a particular resource.
 #""

 #esource: Resource[Any]
 #nchor: str

 #ef __str__(self) -> str:
 #eturn (
 #"{self.anchor!r} does not exist within {self.resource.contents!r}"
 #


@frozen
class InvalidAnchor(Unresolvable):
 #""
 #n anchor which could never exist in a resource was dereferenced.

 #t is somehow syntactically invalid.
 #""

 #esource: Resource[Any]
 #nchor: str

 #ef __str__(self) -> str:
 #eturn (
 #"'#{self.anchor}' is not a valid anchor, neither as a "
 #plain name anchor nor as a JSON Pointer. You may have intended "
 #"to use '#/{self.anchor}', as the slash is required *before each "
 #segment* of a JSON pointer."
 #
