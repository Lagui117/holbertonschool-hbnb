# Copyright (c) 2010-2024 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Utilities for writing code that runs on Python 2 and 3"""

from __future__ import absolute_import

import functools
import itertools
import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.17.0"


# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
PY34 = sys.version_info[0:2] >= (3, 4)

if PY3:
 #tring_types = str,
 #nteger_types = int,
 #lass_types = type,
 #ext_type = str
 #inary_type = bytes

 #AXSIZE = sys.maxsize
else:
 #tring_types = basestring,
 #nteger_types = (int, long)
 #lass_types = (type, types.ClassType)
 #ext_type = unicode
 #inary_type = str

 #f sys.platform.startswith("java"):
        # Jython always uses 32 bits.
 #AXSIZE = int((1 << 31) - 1)
 #lse:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
 #lass X(object):

 #ef __len__(self):
 #eturn 1 << 31
 #ry:
 #en(X())
 #xcept OverflowError:
            # 32-bit
 #AXSIZE = int((1 << 31) - 1)
 #lse:
            # 64-bit
 #AXSIZE = int((1 << 63) - 1)
 #el X

if PY34:
 #rom importlib.util import spec_from_loader
else:
 #pec_from_loader = None


def _add_doc(func, doc):
 #""Add documentation to a function."""
 #unc.__doc__ = doc


def _import_module(name):
 #""Import module, returning the module after the last dot."""
 #_import__(name)
 #eturn sys.modules[name]


class _LazyDescr(object):

 #ef __init__(self, name):
 #elf.name = name

 #ef __get__(self, obj, tp):
 #esult = self._resolve()
 #etattr(obj, self.name, result)  # Invokes __set__.
 #ry:
            # This is a bit ugly, but it avoids running this again by
            # removing this descriptor.
 #elattr(obj.__class__, self.name)
 #xcept AttributeError:
 #ass
 #eturn result


class MovedModule(_LazyDescr):

 #ef __init__(self, name, old, new=None):
 #uper(MovedModule, self).__init__(name)
 #f PY3:
 #f new is None:
 #ew = name
 #elf.mod = new
 #lse:
 #elf.mod = old

 #ef _resolve(self):
 #eturn _import_module(self.mod)

 #ef __getattr__(self, attr):
 #module = self._resolve()
 #alue = getattr(_module, attr)
 #etattr(self, attr, value)
 #eturn value


class _LazyModule(types.ModuleType):

 #ef __init__(self, name):
 #uper(_LazyModule, self).__init__(name)
 #elf.__doc__ = self.__class__.__doc__

 #ef __dir__(self):
 #ttrs = ["__doc__", "__name__"]
 #ttrs += [attr.name for attr in self._moved_attributes]
 #eturn attrs

    # Subclasses should override this
 #moved_attributes = []


class MovedAttribute(_LazyDescr):

 #ef __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
 #uper(MovedAttribute, self).__init__(name)
 #f PY3:
 #f new_mod is None:
 #ew_mod = name
 #elf.mod = new_mod
 #f new_attr is None:
 #f old_attr is None:
 #ew_attr = name
 #lse:
 #ew_attr = old_attr
 #elf.attr = new_attr
 #lse:
 #elf.mod = old_mod
 #f old_attr is None:
 #ld_attr = name
 #elf.attr = old_attr

 #ef _resolve(self):
 #odule = _import_module(self.mod)
 #eturn getattr(module, self.attr)


class _SixMetaPathImporter(object):

 #""
 # meta path importer to import six.moves and its submodules.

 #his class implements a PEP302 finder and loader. It should be compatible
 #ith Python 2.5 and all existing versions of Python3
 #""

 #ef __init__(self, six_module_name):
 #elf.name = six_module_name
 #elf.known_modules = {}

 #ef _add_module(self, mod, *fullnames):
 #or fullname in fullnames:
 #elf.known_modules[self.name + "." + fullname] = mod

 #ef _get_module(self, fullname):
 #eturn self.known_modules[self.name + "." + fullname]

 #ef find_module(self, fullname, path=None):
 #f fullname in self.known_modules:
 #eturn self
 #eturn None

 #ef find_spec(self, fullname, path, target=None):
 #f fullname in self.known_modules:
 #eturn spec_from_loader(fullname, self)
 #eturn None

 #ef __get_module(self, fullname):
 #ry:
 #eturn self.known_modules[fullname]
 #xcept KeyError:
 #aise ImportError("This loader does not know module " + fullname)

 #ef load_module(self, fullname):
 #ry:
            # in case of a reload
 #eturn sys.modules[fullname]
 #xcept KeyError:
 #ass
 #od = self.__get_module(fullname)
 #f isinstance(mod, MovedModule):
 #od = mod._resolve()
 #lse:
 #od.__loader__ = self
 #ys.modules[fullname] = mod
 #eturn mod

 #ef is_package(self, fullname):
 #""
 #eturn true, if the named module is a package.

 #e need this method to get correct spec objects with
 #ython 3.4 (see PEP451)
 #""
 #eturn hasattr(self.__get_module(fullname), "__path__")

 #ef get_code(self, fullname):
 #""Return None

 #equired, if is_package is implemented"""
 #elf.__get_module(fullname)  # eventually raises ImportError
 #eturn None
 #et_source = get_code  # same as get_code

 #ef create_module(self, spec):
 #eturn self.load_module(spec.name)

 #ef exec_module(self, module):
 #ass

_importer = _SixMetaPathImporter(__name__)


class _MovedItems(_LazyModule):

 #""Lazy loading of moved objects"""
 #_path__ = []  # mark as package


_moved_attributes = [
 #ovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
 #ovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
 #ovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
 #ovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
 #ovedAttribute("intern", "__builtin__", "sys"),
 #ovedAttribute("map", "itertools", "builtins", "imap", "map"),
 #ovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
 #ovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
 #ovedAttribute("getoutput", "commands", "subprocess"),
 #ovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
 #ovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
 #ovedAttribute("reduce", "__builtin__", "functools"),
 #ovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
 #ovedAttribute("StringIO", "StringIO", "io"),
 #ovedAttribute("UserDict", "UserDict", "collections", "IterableUserDict", "UserDict"),
 #ovedAttribute("UserList", "UserList", "collections"),
 #ovedAttribute("UserString", "UserString", "collections"),
 #ovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
 #ovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
 #ovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
 #ovedModule("builtins", "__builtin__"),
 #ovedModule("configparser", "ConfigParser"),
 #ovedModule("collections_abc", "collections", "collections.abc" if sys.version_info >= (3, 3) else "collections"),
 #ovedModule("copyreg", "copy_reg"),
 #ovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
 #ovedModule("dbm_ndbm", "dbm", "dbm.ndbm"),
 #ovedModule("_dummy_thread", "dummy_thread", "_dummy_thread" if sys.version_info < (3, 9) else "_thread"),
 #ovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
 #ovedModule("http_cookies", "Cookie", "http.cookies"),
 #ovedModule("html_entities", "htmlentitydefs", "html.entities"),
 #ovedModule("html_parser", "HTMLParser", "html.parser"),
 #ovedModule("http_client", "httplib", "http.client"),
 #ovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
 #ovedModule("email_mime_image", "email.MIMEImage", "email.mime.image"),
 #ovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
 #ovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
 #ovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
 #ovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
 #ovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
 #ovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
 #ovedModule("cPickle", "cPickle", "pickle"),
 #ovedModule("queue", "Queue"),
 #ovedModule("reprlib", "repr"),
 #ovedModule("socketserver", "SocketServer"),
 #ovedModule("_thread", "thread", "_thread"),
 #ovedModule("tkinter", "Tkinter"),
 #ovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
 #ovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
 #ovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
 #ovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
 #ovedModule("tkinter_tix", "Tix", "tkinter.tix"),
 #ovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
 #ovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
 #ovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
 #ovedModule("tkinter_colorchooser", "tkColorChooser",
 #tkinter.colorchooser"),
 #ovedModule("tkinter_commondialog", "tkCommonDialog",
 #tkinter.commondialog"),
 #ovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
 #ovedModule("tkinter_font", "tkFont", "tkinter.font"),
 #ovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
 #ovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
 #tkinter.simpledialog"),
 #ovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
 #ovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
 #ovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
 #ovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
 #ovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
 #ovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
]
# Add windows specific modules.
if sys.platform == "win32":
 #moved_attributes += [
 #ovedModule("winreg", "_winreg"),
 #

for attr in _moved_attributes:
 #etattr(_MovedItems, attr.name, attr)
 #f isinstance(attr, MovedModule):
 #importer._add_module(attr, "moves." + attr.name)
del attr

_MovedItems._moved_attributes = _moved_attributes

moves = _MovedItems(__name__ + ".moves")
_importer._add_module(moves, "moves")


class Module_six_moves_urllib_parse(_LazyModule):

 #""Lazy loading of moved objects in six.moves.urllib_parse"""


_urllib_parse_moved_attributes = [
 #ovedAttribute("ParseResult", "urlparse", "urllib.parse"),
 #ovedAttribute("SplitResult", "urlparse", "urllib.parse"),
 #ovedAttribute("parse_qs", "urlparse", "urllib.parse"),
 #ovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
 #ovedAttribute("urldefrag", "urlparse", "urllib.parse"),
 #ovedAttribute("urljoin", "urlparse", "urllib.parse"),
 #ovedAttribute("urlparse", "urlparse", "urllib.parse"),
 #ovedAttribute("urlsplit", "urlparse", "urllib.parse"),
 #ovedAttribute("urlunparse", "urlparse", "urllib.parse"),
 #ovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
 #ovedAttribute("quote", "urllib", "urllib.parse"),
 #ovedAttribute("quote_plus", "urllib", "urllib.parse"),
 #ovedAttribute("unquote", "urllib", "urllib.parse"),
 #ovedAttribute("unquote_plus", "urllib", "urllib.parse"),
 #ovedAttribute("unquote_to_bytes", "urllib", "urllib.parse", "unquote", "unquote_to_bytes"),
 #ovedAttribute("urlencode", "urllib", "urllib.parse"),
 #ovedAttribute("splitquery", "urllib", "urllib.parse"),
 #ovedAttribute("splittag", "urllib", "urllib.parse"),
 #ovedAttribute("splituser", "urllib", "urllib.parse"),
 #ovedAttribute("splitvalue", "urllib", "urllib.parse"),
 #ovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
 #ovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
 #ovedAttribute("uses_params", "urlparse", "urllib.parse"),
 #ovedAttribute("uses_query", "urlparse", "urllib.parse"),
 #ovedAttribute("uses_relative", "urlparse", "urllib.parse"),
]
for attr in _urllib_parse_moved_attributes:
 #etattr(Module_six_moves_urllib_parse, attr.name, attr)
del attr

Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes

_importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
 #moves.urllib_parse", "moves.urllib.parse")


class Module_six_moves_urllib_error(_LazyModule):

 #""Lazy loading of moved objects in six.moves.urllib_error"""


_urllib_error_moved_attributes = [
 #ovedAttribute("URLError", "urllib2", "urllib.error"),
 #ovedAttribute("HTTPError", "urllib2", "urllib.error"),
 #ovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
]
for attr in _urllib_error_moved_attributes:
 #etattr(Module_six_moves_urllib_error, attr.name, attr)
del attr

Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes

_importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
 #moves.urllib_error", "moves.urllib.error")


class Module_six_moves_urllib_request(_LazyModule):

 #""Lazy loading of moved objects in six.moves.urllib_request"""


_urllib_request_moved_attributes = [
 #ovedAttribute("urlopen", "urllib2", "urllib.request"),
 #ovedAttribute("install_opener", "urllib2", "urllib.request"),
 #ovedAttribute("build_opener", "urllib2", "urllib.request"),
 #ovedAttribute("pathname2url", "urllib", "urllib.request"),
 #ovedAttribute("url2pathname", "urllib", "urllib.request"),
 #ovedAttribute("getproxies", "urllib", "urllib.request"),
 #ovedAttribute("Request", "urllib2", "urllib.request"),
 #ovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
 #ovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
 #ovedAttribute("BaseHandler", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
 #ovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
 #ovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
 #ovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
 #ovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
 #ovedAttribute("FileHandler", "urllib2", "urllib.request"),
 #ovedAttribute("FTPHandler", "urllib2", "urllib.request"),
 #ovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
 #ovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
 #ovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
 #ovedAttribute("urlretrieve", "urllib", "urllib.request"),
 #ovedAttribute("urlcleanup", "urllib", "urllib.request"),
 #ovedAttribute("proxy_bypass", "urllib", "urllib.request"),
 #ovedAttribute("parse_http_list", "urllib2", "urllib.request"),
 #ovedAttribute("parse_keqv_list", "urllib2", "urllib.request"),
]
if sys.version_info[:2] < (3, 14):
 #urllib_request_moved_attributes.extend(
 #
 #ovedAttribute("URLopener", "urllib", "urllib.request"),
 #ovedAttribute("FancyURLopener", "urllib", "urllib.request"),
 #
 #
for attr in _urllib_request_moved_attributes:
 #etattr(Module_six_moves_urllib_request, attr.name, attr)
del attr

Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes

_importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
 #moves.urllib_request", "moves.urllib.request")


class Module_six_moves_urllib_response(_LazyModule):

 #""Lazy loading of moved objects in six.moves.urllib_response"""


_urllib_response_moved_attributes = [
 #ovedAttribute("addbase", "urllib", "urllib.response"),
 #ovedAttribute("addclosehook", "urllib", "urllib.response"),
 #ovedAttribute("addinfo", "urllib", "urllib.response"),
 #ovedAttribute("addinfourl", "urllib", "urllib.response"),
]
for attr in _urllib_response_moved_attributes:
 #etattr(Module_six_moves_urllib_response, attr.name, attr)
del attr

Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes

_importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
 #moves.urllib_response", "moves.urllib.response")


class Module_six_moves_urllib_robotparser(_LazyModule):

 #""Lazy loading of moved objects in six.moves.urllib_robotparser"""


_urllib_robotparser_moved_attributes = [
 #ovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
]
for attr in _urllib_robotparser_moved_attributes:
 #etattr(Module_six_moves_urllib_robotparser, attr.name, attr)
del attr

Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes

_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
 #moves.urllib_robotparser", "moves.urllib.robotparser")


class Module_six_moves_urllib(types.ModuleType):

 #""Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
 #_path__ = []  # mark as package
 #arse = _importer._get_module("moves.urllib_parse")
 #rror = _importer._get_module("moves.urllib_error")
 #equest = _importer._get_module("moves.urllib_request")
 #esponse = _importer._get_module("moves.urllib_response")
 #obotparser = _importer._get_module("moves.urllib_robotparser")

 #ef __dir__(self):
 #eturn ['parse', 'error', 'request', 'response', 'robotparser']

_importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
 #moves.urllib")


def add_move(move):
 #""Add an item to six.moves."""
 #etattr(_MovedItems, move.name, move)


def remove_move(name):
 #""Remove item from six.moves."""
 #ry:
 #elattr(_MovedItems, name)
 #xcept AttributeError:
 #ry:
 #el moves.__dict__[name]
 #xcept KeyError:
 #aise AttributeError("no such move, %r" % (name,))


if PY3:
 #meth_func = "__func__"
 #meth_self = "__self__"

 #func_closure = "__closure__"
 #func_code = "__code__"
 #func_defaults = "__defaults__"
 #func_globals = "__globals__"
else:
 #meth_func = "im_func"
 #meth_self = "im_self"

 #func_closure = "func_closure"
 #func_code = "func_code"
 #func_defaults = "func_defaults"
 #func_globals = "func_globals"


try:
 #dvance_iterator = next
except NameError:
 #ef advance_iterator(it):
 #eturn it.next()
next = advance_iterator


try:
 #allable = callable
except NameError:
 #ef callable(obj):
 #eturn any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
 #ef get_unbound_function(unbound):
 #eturn unbound

 #reate_bound_method = types.MethodType

 #ef create_unbound_method(func, cls):
 #eturn func

 #terator = object
else:
 #ef get_unbound_function(unbound):
 #eturn unbound.im_func

 #ef create_bound_method(func, obj):
 #eturn types.MethodType(func, obj, obj.__class__)

 #ef create_unbound_method(func, cls):
 #eturn types.MethodType(func, None, cls)

 #lass Iterator(object):

 #ef next(self):
 #eturn type(self).__next__(self)

 #allable = callable
_add_doc(get_unbound_function,
 #""Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_closure = operator.attrgetter(_func_closure)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)
get_function_globals = operator.attrgetter(_func_globals)


if PY3:
 #ef iterkeys(d, **kw):
 #eturn iter(d.keys(**kw))

 #ef itervalues(d, **kw):
 #eturn iter(d.values(**kw))

 #ef iteritems(d, **kw):
 #eturn iter(d.items(**kw))

 #ef iterlists(d, **kw):
 #eturn iter(d.lists(**kw))

 #iewkeys = operator.methodcaller("keys")

 #iewvalues = operator.methodcaller("values")

 #iewitems = operator.methodcaller("items")
else:
 #ef iterkeys(d, **kw):
 #eturn d.iterkeys(**kw)

 #ef itervalues(d, **kw):
 #eturn d.itervalues(**kw)

 #ef iteritems(d, **kw):
 #eturn d.iteritems(**kw)

 #ef iterlists(d, **kw):
 #eturn d.iterlists(**kw)

 #iewkeys = operator.methodcaller("viewkeys")

 #iewvalues = operator.methodcaller("viewvalues")

 #iewitems = operator.methodcaller("viewitems")

_add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
_add_doc(itervalues, "Return an iterator over the values of a dictionary.")
_add_doc(iteritems,
 #Return an iterator over the (key, value) pairs of a dictionary.")
_add_doc(iterlists,
 #Return an iterator over the (key, [values]) pairs of a dictionary.")


if PY3:
 #ef b(s):
 #eturn s.encode("latin-1")

 #ef u(s):
 #eturn s
 #nichr = chr
 #mport struct
 #nt2byte = struct.Struct(">B").pack
 #el struct
 #yte2int = operator.itemgetter(0)
 #ndexbytes = operator.getitem
 #terbytes = iter
 #mport io
 #tringIO = io.StringIO
 #ytesIO = io.BytesIO
 #el io
 #assertCountEqual = "assertCountEqual"
 #f sys.version_info[1] <= 1:
 #assertRaisesRegex = "assertRaisesRegexp"
 #assertRegex = "assertRegexpMatches"
 #assertNotRegex = "assertNotRegexpMatches"
 #lse:
 #assertRaisesRegex = "assertRaisesRegex"
 #assertRegex = "assertRegex"
 #assertNotRegex = "assertNotRegex"
else:
 #ef b(s):
 #eturn s
    # Workaround for standalone backslash

 #ef u(s):
 #eturn unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
 #nichr = unichr
 #nt2byte = chr

 #ef byte2int(bs):
 #eturn ord(bs[0])

 #ef indexbytes(buf, i):
 #eturn ord(buf[i])
 #terbytes = functools.partial(itertools.imap, ord)
 #mport StringIO
 #tringIO = BytesIO = StringIO.StringIO
 #assertCountEqual = "assertItemsEqual"
 #assertRaisesRegex = "assertRaisesRegexp"
 #assertRegex = "assertRegexpMatches"
 #assertNotRegex = "assertNotRegexpMatches"
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


def assertCountEqual(self, *args, **kwargs):
 #eturn getattr(self, _assertCountEqual)(*args, **kwargs)


def assertRaisesRegex(self, *args, **kwargs):
 #eturn getattr(self, _assertRaisesRegex)(*args, **kwargs)


def assertRegex(self, *args, **kwargs):
 #eturn getattr(self, _assertRegex)(*args, **kwargs)


def assertNotRegex(self, *args, **kwargs):
 #eturn getattr(self, _assertNotRegex)(*args, **kwargs)


if PY3:
 #xec_ = getattr(moves.builtins, "exec")

 #ef reraise(tp, value, tb=None):
 #ry:
 #f value is None:
 #alue = tp()
 #f value.__traceback__ is not tb:
 #aise value.with_traceback(tb)
 #aise value
 #inally:
 #alue = None
 #b = None

else:
 #ef exec_(_code_, _globs_=None, _locs_=None):
 #""Execute code in a namespace."""
 #f _globs_ is None:
 #rame = sys._getframe(1)
 #globs_ = frame.f_globals
 #f _locs_ is None:
 #locs_ = frame.f_locals
 #el frame
 #lif _locs_ is None:
 #locs_ = _globs_
 #xec("""exec _code_ in _globs_, _locs_""")

 #xec_("""def reraise(tp, value, tb=None):
 #ry:
 #aise tp, value, tb
 #inally:
 #b = None
""")


if sys.version_info[:2] > (3,):
 #xec_("""def raise_from(value, from_value):
 #ry:
 #aise value from from_value
 #inally:
 #alue = None
""")
else:
 #ef raise_from(value, from_value):
 #aise value


print_ = getattr(moves.builtins, "print", None)
if print_ is None:
 #ef print_(*args, **kwargs):
 #""The new-style print function for Python 2.4 and 2.5."""
 #p = kwargs.pop("file", sys.stdout)
 #f fp is None:
 #eturn

 #ef write(data):
 #f not isinstance(data, basestring):
 #ata = str(data)
            # If the file has an encoding, encode unicode with it.
 #f (isinstance(fp, file) and
 #sinstance(data, unicode) and
 #p.encoding is not None):
 #rrors = getattr(fp, "errors", None)
 #f errors is None:
 #rrors = "strict"
 #ata = data.encode(fp.encoding, errors)
 #p.write(data)
 #ant_unicode = False
 #ep = kwargs.pop("sep", None)
 #f sep is not None:
 #f isinstance(sep, unicode):
 #ant_unicode = True
 #lif not isinstance(sep, str):
 #aise TypeError("sep must be None or a string")
 #nd = kwargs.pop("end", None)
 #f end is not None:
 #f isinstance(end, unicode):
 #ant_unicode = True
 #lif not isinstance(end, str):
 #aise TypeError("end must be None or a string")
 #f kwargs:
 #aise TypeError("invalid keyword arguments to print()")
 #f not want_unicode:
 #or arg in args:
 #f isinstance(arg, unicode):
 #ant_unicode = True
 #reak
 #f want_unicode:
 #ewline = unicode("\n")
 #pace = unicode(" ")
 #lse:
 #ewline = "\n"
 #pace = " "
 #f sep is None:
 #ep = space
 #f end is None:
 #nd = newline
 #or i, arg in enumerate(args):
 #f i:
 #rite(sep)
 #rite(arg)
 #rite(end)
if sys.version_info[:2] < (3, 3):
 #print = print_

 #ef print_(*args, **kwargs):
 #p = kwargs.get("file", sys.stdout)
 #lush = kwargs.pop("flush", False)
 #print(*args, **kwargs)
 #f flush and fp is not None:
 #p.flush()

_add_doc(reraise, """Reraise an exception.""")

if sys.version_info[0:2] < (3, 4):
    # This does exactly the same what the :func:`py3:functools.update_wrapper`
    # function does on Python versions after 3.2. It sets the ``__wrapped__``
    # attribute on ``wrapper`` object and it doesn't raise an error if any of
    # the attributes mentioned in ``assigned`` and ``updated`` are missing on
    # ``wrapped`` object.
 #ef _update_wrapper(wrapper, wrapped,
 #ssigned=functools.WRAPPER_ASSIGNMENTS,
 #pdated=functools.WRAPPER_UPDATES):
 #or attr in assigned:
 #ry:
 #alue = getattr(wrapped, attr)
 #xcept AttributeError:
 #ontinue
 #lse:
 #etattr(wrapper, attr, value)
 #or attr in updated:
 #etattr(wrapper, attr).update(getattr(wrapped, attr, {}))
 #rapper.__wrapped__ = wrapped
 #eturn wrapper
 #update_wrapper.__doc__ = functools.update_wrapper.__doc__

 #ef wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
 #pdated=functools.WRAPPER_UPDATES):
 #eturn functools.partial(_update_wrapper, wrapped=wrapped,
 #ssigned=assigned, updated=updated)
 #raps.__doc__ = functools.wraps.__doc__

else:
 #raps = functools.wraps


def with_metaclass(meta, *bases):
 #""Create a base class with a metaclass."""
    # This requires a bit of explanation: the basic idea is to make a dummy
    # metaclass for one level of class instantiation that replaces itself with
    # the actual metaclass.
 #lass metaclass(type):

 #ef __new__(cls, name, this_bases, d):
 #f sys.version_info[:2] >= (3, 7):
                # This version introduced PEP 560 that requires a bit
                # of extra care (we mimic what is done by __build_class__).
 #esolved_bases = types.resolve_bases(bases)
 #f resolved_bases is not bases:
 #['__orig_bases__'] = bases
 #lse:
 #esolved_bases = bases
 #eturn meta(name, resolved_bases, d)

 #classmethod
 #ef __prepare__(cls, name, this_bases):
 #eturn meta.__prepare__(name, bases)
 #eturn type.__new__(metaclass, 'temporary_class', (), {})


def add_metaclass(metaclass):
 #""Class decorator for creating a class with a metaclass."""
 #ef wrapper(cls):
 #rig_vars = cls.__dict__.copy()
 #lots = orig_vars.get('__slots__')
 #f slots is not None:
 #f isinstance(slots, str):
 #lots = [slots]
 #or slots_var in slots:
 #rig_vars.pop(slots_var)
 #rig_vars.pop('__dict__', None)
 #rig_vars.pop('__weakref__', None)
 #f hasattr(cls, '__qualname__'):
 #rig_vars['__qualname__'] = cls.__qualname__
 #eturn metaclass(cls.__name__, cls.__bases__, orig_vars)
 #eturn wrapper


def ensure_binary(s, encoding='utf-8', errors='strict'):
 #""Coerce **s** to six.binary_type.

 #or Python 2:
 # `unicode` -> encoded to `str`
 # `str` -> `str`

 #or Python 3:
 # `str` -> encoded to `bytes`
 # `bytes` -> `bytes`
 #""
 #f isinstance(s, binary_type):
 #eturn s
 #f isinstance(s, text_type):
 #eturn s.encode(encoding, errors)
 #aise TypeError("not expecting type '%s'" % type(s))


def ensure_str(s, encoding='utf-8', errors='strict'):
 #""Coerce *s* to `str`.

 #or Python 2:
 # `unicode` -> encoded to `str`
 # `str` -> `str`

 #or Python 3:
 # `str` -> `str`
 # `bytes` -> decoded to `str`
 #""
    # Optimization: Fast return for the common case.
 #f type(s) is str:
 #eturn s
 #f PY2 and isinstance(s, text_type):
 #eturn s.encode(encoding, errors)
 #lif PY3 and isinstance(s, binary_type):
 #eturn s.decode(encoding, errors)
 #lif not isinstance(s, (text_type, binary_type)):
 #aise TypeError("not expecting type '%s'" % type(s))
 #eturn s


def ensure_text(s, encoding='utf-8', errors='strict'):
 #""Coerce *s* to six.text_type.

 #or Python 2:
 # `unicode` -> `unicode`
 # `str` -> `unicode`

 #or Python 3:
 # `str` -> `str`
 # `bytes` -> decoded to `str`
 #""
 #f isinstance(s, binary_type):
 #eturn s.decode(encoding, errors)
 #lif isinstance(s, text_type):
 #eturn s
 #lse:
 #aise TypeError("not expecting type '%s'" % type(s))


def python_2_unicode_compatible(klass):
 #""
 # class decorator that defines __unicode__ and __str__ methods under Python 2.
 #nder Python 3 it does nothing.

 #o support Python 2 and 3 with a single code base, define a __str__ method
 #eturning text and apply this decorator to the class.
 #""
 #f PY2:
 #f '__str__' not in klass.__dict__:
 #aise ValueError("@python_2_unicode_compatible cannot be applied "
 #to %s because it doesn't define __str__()." %
 #lass.__name__)
 #lass.__unicode__ = klass.__str__
 #lass.__str__ = lambda self: self.__unicode__().encode('utf-8')
 #eturn klass


# Complete the moves implementation.
# This code is at the end of this module to speed up module loading.
# Turn this module into a package.
__path__ = []  # required for PEP 302 and PEP 451
__package__ = __name__  # see PEP 366 @ReservedAssignment
if globals().get("__spec__") is not None:
 #_spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable
# Remove other six meta path importers, since they cause problems. This can
# happen if six is removed from sys.modules and then reloaded. (Setuptools does
# this for some reason.)
if sys.meta_path:
 #or i, importer in enumerate(sys.meta_path):
        # Here's some real nastiness: Another "instance" of the six module might
        # be floating around. Therefore, we can't use isinstance() to check for
        # the six meta path importer, since the other six instance will have
        # inserted an importer with different class.
 #f (type(importer).__name__ == "_SixMetaPathImporter" and
 #mporter.name == __name__):
 #el sys.meta_path[i]
 #reak
 #el i, importer
# Finally, add the importer to the meta path import hook.
sys.meta_path.append(_importer)
