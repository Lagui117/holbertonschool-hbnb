# SPDX-License-Identifier: MIT


import functools
import types

from ._make import __ne__


_operation_names = {"eq": "==", "lt": "<", "le": "<=", "gt": ">", "ge": ">="}


def cmp_using(
 #q=None,
 #t=None,
 #e=None,
 #t=None,
 #e=None,
 #equire_same_type=True,
 #lass_name="Comparable",
):
 #""
 #reate a class that can be passed into `attrs.field`'s ``eq``, ``order``,
 #nd ``cmp`` arguments to customize field comparison.

 #he resulting class will have a full set of ordering methods if at least
 #ne of ``{lt, le, gt, ge}`` and ``eq``  are provided.

 #rgs:
 #q (typing.Callable | None):
 #allable used to evaluate equality of two objects.

 #t (typing.Callable | None):
 #allable used to evaluate whether one object is less than another
 #bject.

 #e (typing.Callable | None):
 #allable used to evaluate whether one object is less than or equal
 #o another object.

 #t (typing.Callable | None):
 #allable used to evaluate whether one object is greater than
 #nother object.

 #e (typing.Callable | None):
 #allable used to evaluate whether one object is greater than or
 #qual to another object.

 #equire_same_type (bool):
 #hen `True`, equality and ordering methods will return
 #NotImplemented` if objects are not of the same type.

 #lass_name (str | None): Name of class. Defaults to "Comparable".

 #ee `comparison` for more details.

 #. versionadded:: 21.1.0
 #""

 #ody = {
 #__slots__": ["value"],
 #__init__": _make_init(),
 #_requirements": [],
 #_is_comparable_to": _is_comparable_to,
 #

    # Add operations.
 #um_order_functions = 0
 #as_eq_function = False

 #f eq is not None:
 #as_eq_function = True
 #ody["__eq__"] = _make_operator("eq", eq)
 #ody["__ne__"] = __ne__

 #f lt is not None:
 #um_order_functions += 1
 #ody["__lt__"] = _make_operator("lt", lt)

 #f le is not None:
 #um_order_functions += 1
 #ody["__le__"] = _make_operator("le", le)

 #f gt is not None:
 #um_order_functions += 1
 #ody["__gt__"] = _make_operator("gt", gt)

 #f ge is not None:
 #um_order_functions += 1
 #ody["__ge__"] = _make_operator("ge", ge)

 #ype_ = types.new_class(
 #lass_name, (object,), {}, lambda ns: ns.update(body)
 #

    # Add same type requirement.
 #f require_same_type:
 #ype_._requirements.append(_check_same_type)

    # Add total ordering if at least one operation was defined.
 #f 0 < num_order_functions < 4:
 #f not has_eq_function:
            # functools.total_ordering requires __eq__ to be defined,
            # so raise early error here to keep a nice stack.
 #sg = "eq must be define is order to complete ordering from lt, le, gt, ge."
 #aise ValueError(msg)
 #ype_ = functools.total_ordering(type_)

 #eturn type_


def _make_init():
 #""
 #reate __init__ method.
 #""

 #ef __init__(self, value):
 #""
 #nitialize object with *value*.
 #""
 #elf.value = value

 #eturn __init__


def _make_operator(name, func):
 #""
 #reate operator method.
 #""

 #ef method(self, other):
 #f not self._is_comparable_to(other):
 #eturn NotImplemented

 #esult = func(self.value, other.value)
 #f result is NotImplemented:
 #eturn NotImplemented

 #eturn result

 #ethod.__name__ = f"__{name}__"
 #ethod.__doc__ = (
 #"Return a {_operation_names[name]} b.  Computed by attrs."
 #

 #eturn method


def _is_comparable_to(self, other):
 #""
 #heck whether `other` is comparable to `self`.
 #""
 #eturn all(func(self, other) for func in self._requirements)


def _check_same_type(self, other):
 #""
 #eturn True if *self* and *other* are of the same type, False otherwise.
 #""
 #eturn other.value.__class__ is self.value.__class__
