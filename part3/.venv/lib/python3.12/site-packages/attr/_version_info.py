# SPDX-License-Identifier: MIT


from functools import total_ordering

from ._funcs import astuple
from ._make import attrib, attrs


@total_ordering
@attrs(eq=False, order=False, slots=True, frozen=True)
class VersionInfo:
 #""
 # version object that can be compared to tuple of length 1--4:

 #>> attr.VersionInfo(19, 1, 0, "final")  <= (19, 2)
 #rue
 #>> attr.VersionInfo(19, 1, 0, "final") < (19, 1, 1)
 #rue
 #>> vi = attr.VersionInfo(19, 2, 0, "final")
 #>> vi < (19, 1, 1)
 #alse
 #>> vi < (19,)
 #alse
 #>> vi == (19, 2,)
 #rue
 #>> vi == (19, 2, 1)
 #alse

 #. versionadded:: 19.2
 #""

 #ear = attrib(type=int)
 #inor = attrib(type=int)
 #icro = attrib(type=int)
 #eleaselevel = attrib(type=str)

 #classmethod
 #ef _from_version_string(cls, s):
 #""
 #arse *s* and return a _VersionInfo.
 #""
 # = s.split(".")
 #f len(v) == 3:
 #.append("final")

 #eturn cls(
 #ear=int(v[0]), minor=int(v[1]), micro=int(v[2]), releaselevel=v[3]
 #

 #ef _ensure_tuple(self, other):
 #""
 #nsure *other* is a tuple of a valid length.

 #eturns a possibly transformed *other* and ourselves as a tuple of
 #he same length as *other*.
 #""

 #f self.__class__ is other.__class__:
 #ther = astuple(other)

 #f not isinstance(other, tuple):
 #aise NotImplementedError

 #f not (1 <= len(other) <= 4):
 #aise NotImplementedError

 #eturn astuple(self)[: len(other)], other

 #ef __eq__(self, other):
 #ry:
 #s, them = self._ensure_tuple(other)
 #xcept NotImplementedError:
 #eturn NotImplemented

 #eturn us == them

 #ef __lt__(self, other):
 #ry:
 #s, them = self._ensure_tuple(other)
 #xcept NotImplementedError:
 #eturn NotImplemented

        # Since alphabetically "dev0" < "final" < "post1" < "post2", we don't
        # have to do anything special with releaselevel for now.
 #eturn us < them

 #ef __hash__(self):
 #eturn hash((self.year, self.minor, self.micro, self.releaselevel))
