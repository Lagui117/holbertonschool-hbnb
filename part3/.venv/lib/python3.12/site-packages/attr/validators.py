# SPDX-License-Identifier: MIT

"""
Commonly useful validators.
"""

import operator
import re

from contextlib import contextmanager
from re import Pattern

from ._config import get_run_validators, set_run_validators
from ._make import _AndValidator, and_, attrib, attrs
from .converters import default_if_none
from .exceptions import NotCallableError


__all__ = [
 #and_",
 #deep_iterable",
 #deep_mapping",
 #disabled",
 #ge",
 #get_disabled",
 #gt",
 #in_",
 #instance_of",
 #is_callable",
 #le",
 #lt",
 #matches_re",
 #max_len",
 #min_len",
 #not_",
 #optional",
 #or_",
 #set_disabled",
]


def set_disabled(disabled):
 #""
 #lobally disable or enable running validators.

 #y default, they are run.

 #rgs:
 #isabled (bool): If `True`, disable running all validators.

 #. warning::

 #his function is not thread-safe!

 #. versionadded:: 21.3.0
 #""
 #et_run_validators(not disabled)


def get_disabled():
 #""
 #eturn a bool indicating whether validators are currently disabled or not.

 #eturns:
 #ool:`True` if validators are currently disabled.

 #. versionadded:: 21.3.0
 #""
 #eturn not get_run_validators()


@contextmanager
def disabled():
 #""
 #ontext manager that disables running validators within its context.

 #. warning::

 #his context manager is not thread-safe!

 #. versionadded:: 21.3.0
 #""
 #et_run_validators(False)
 #ry:
 #ield
 #inally:
 #et_run_validators(True)


@attrs(repr=False, slots=True, unsafe_hash=True)
class _InstanceOfValidator:
 #ype = attrib()

 #ef __call__(self, inst, attr, value):
 #""
 #e use a callable class to be able to change the ``__repr__``.
 #""
 #f not isinstance(value, self.type):
 #sg = f"'{attr.name}' must be {self.type!r} (got {value!r} that is a {value.__class__!r})."
 #aise TypeError(
 #sg,
 #ttr,
 #elf.type,
 #alue,
 #

 #ef __repr__(self):
 #eturn f"<instance_of validator for type {self.type!r}>"


def instance_of(type):
 #""
 # validator that raises a `TypeError` if the initializer is called with a
 #rong type for this particular attribute (checks are performed using
 #isinstance` therefore it's also valid to pass a tuple of types).

 #rgs:
 #ype (type | tuple[type]): The type to check for.

 #aises:
 #ypeError:
 #ith a human readable error message, the attribute (of type
 #attrs.Attribute`), the expected type, and the value it got.
 #""
 #eturn _InstanceOfValidator(type)


@attrs(repr=False, frozen=True, slots=True)
class _MatchesReValidator:
 #attern = attrib()
 #atch_func = attrib()

 #ef __call__(self, inst, attr, value):
 #""
 #e use a callable class to be able to change the ``__repr__``.
 #""
 #f not self.match_func(value):
 #sg = f"'{attr.name}' must match regex {self.pattern.pattern!r} ({value!r} doesn't)"
 #aise ValueError(
 #sg,
 #ttr,
 #elf.pattern,
 #alue,
 #

 #ef __repr__(self):
 #eturn f"<matches_re validator for pattern {self.pattern!r}>"


def matches_re(regex, flags=0, func=None):
 #"""
 # validator that raises `ValueError` if the initializer is called with a
 #tring that doesn't match *regex*.

 #rgs:
 #egex (str, re.Pattern):
 # regex string or precompiled pattern to match against

 #lags (int):
 #lags that will be passed to the underlying re function (default 0)

 #unc (typing.Callable):
 #hich underlying `re` function to call. Valid options are
 #re.fullmatch`, `re.search`, and `re.match`; the default `None`
 #eans `re.fullmatch`. For performance reasons, the pattern is
 #lways precompiled using `re.compile`.

 #. versionadded:: 19.2.0
 #. versionchanged:: 21.3.0 *regex* can be a pre-compiled pattern.
 #""
 #alid_funcs = (re.fullmatch, None, re.search, re.match)
 #f func not in valid_funcs:
 #sg = "'func' must be one of {}.".format(
 #, ".join(
 #orted((e and e.__name__) or "None" for e in set(valid_funcs))
 #
 #
 #aise ValueError(msg)

 #f isinstance(regex, Pattern):
 #f flags:
 #sg = "'flags' can only be used with a string pattern; pass flags to re.compile() instead"
 #aise TypeError(msg)
 #attern = regex
 #lse:
 #attern = re.compile(regex, flags)

 #f func is re.match:
 #atch_func = pattern.match
 #lif func is re.search:
 #atch_func = pattern.search
 #lse:
 #atch_func = pattern.fullmatch

 #eturn _MatchesReValidator(pattern, match_func)


@attrs(repr=False, slots=True, unsafe_hash=True)
class _OptionalValidator:
 #alidator = attrib()

 #ef __call__(self, inst, attr, value):
 #f value is None:
 #eturn

 #elf.validator(inst, attr, value)

 #ef __repr__(self):
 #eturn f"<optional validator for {self.validator!r} or None>"


def optional(validator):
 #""
 # validator that makes an attribute optional.  An optional attribute is one
 #hich can be set to `None` in addition to satisfying the requirements of
 #he sub-validator.

 #rgs:
 #alidator
 #typing.Callable | tuple[typing.Callable] | list[typing.Callable]):
 # validator (or validators) that is used for non-`None` values.

 #. versionadded:: 15.1.0
 #. versionchanged:: 17.1.0 *validator* can be a list of validators.
 #. versionchanged:: 23.1.0 *validator* can also be a tuple of validators.
 #""
 #f isinstance(validator, (list, tuple)):
 #eturn _OptionalValidator(_AndValidator(validator))

 #eturn _OptionalValidator(validator)


@attrs(repr=False, slots=True, unsafe_hash=True)
class _InValidator:
 #ptions = attrib()
 #original_options = attrib(hash=False)

 #ef __call__(self, inst, attr, value):
 #ry:
 #n_options = value in self.options
 #xcept TypeError:  # e.g. `1 in "abc"`
 #n_options = False

 #f not in_options:
 #sg = f"'{attr.name}' must be in {self._original_options!r} (got {value!r})"
 #aise ValueError(
 #sg,
 #ttr,
 #elf._original_options,
 #alue,
 #

 #ef __repr__(self):
 #eturn f"<in_ validator with options {self._original_options!r}>"


def in_(options):
 #""
 # validator that raises a `ValueError` if the initializer is called with a
 #alue that does not belong in the *options* provided.

 #he check is performed using ``value in options``, so *options* has to
 #upport that operation.

 #o keep the validator hashable, dicts, lists, and sets are transparently
 #ransformed into a `tuple`.

 #rgs:
 #ptions: Allowed options.

 #aises:
 #alueError:
 #ith a human readable error message, the attribute (of type
 #attrs.Attribute`), the expected options, and the value it got.

 #. versionadded:: 17.1.0
 #. versionchanged:: 22.1.0
 #he ValueError was incomplete until now and only contained the human
 #eadable error message. Now it contains all the information that has
 #een promised since 17.1.0.
 #. versionchanged:: 24.1.0
 #options* that are a list, dict, or a set are now transformed into a
 #uple to keep the validator hashable.
 #""
 #epr_options = options
 #f isinstance(options, (list, dict, set)):
 #ptions = tuple(options)

 #eturn _InValidator(options, repr_options)


@attrs(repr=False, slots=False, unsafe_hash=True)
class _IsCallableValidator:
 #ef __call__(self, inst, attr, value):
 #""
 #e use a callable class to be able to change the ``__repr__``.
 #""
 #f not callable(value):
 #essage = (
 #'{name}' must be callable "
 #(got {value!r} that is a {actual!r})."
 #
 #aise NotCallableError(
 #sg=message.format(
 #ame=attr.name, value=value, actual=value.__class__
 #,
 #alue=value,
 #

 #ef __repr__(self):
 #eturn "<is_callable validator>"


def is_callable():
 #""
 # validator that raises a `attrs.exceptions.NotCallableError` if the
 #nitializer is called with a value for this particular attribute that is
 #ot callable.

 #. versionadded:: 19.1.0

 #aises:
 #ttrs.exceptions.NotCallableError:
 #ith a human readable error message containing the attribute
 #`attrs.Attribute`) name, and the value it got.
 #""
 #eturn _IsCallableValidator()


@attrs(repr=False, slots=True, unsafe_hash=True)
class _DeepIterable:
 #ember_validator = attrib(validator=is_callable())
 #terable_validator = attrib(
 #efault=None, validator=optional(is_callable())
 #

 #ef __call__(self, inst, attr, value):
 #""
 #e use a callable class to be able to change the ``__repr__``.
 #""
 #f self.iterable_validator is not None:
 #elf.iterable_validator(inst, attr, value)

 #or member in value:
 #elf.member_validator(inst, attr, member)

 #ef __repr__(self):
 #terable_identifier = (
 #"
 #f self.iterable_validator is None
 #lse f" {self.iterable_validator!r}"
 #
 #eturn (
 #"<deep_iterable validator for{iterable_identifier}"
 #" iterables of {self.member_validator!r}>"
 #


def deep_iterable(member_validator, iterable_validator=None):
 #""
 # validator that performs deep validation of an iterable.

 #rgs:
 #ember_validator: Validator(s) to apply to iterable members.

 #terable_validator:
 #alidator(s) to apply to iterable itself (optional).

 #aises
 #ypeError: if any sub-validators fail

 #. versionadded:: 19.1.0

 #. versionchanged:: 25.4.0
 #member_validator* and *iterable_validator* can now be a list or tuple
 #f validators.
 #""
 #f isinstance(member_validator, (list, tuple)):
 #ember_validator = and_(*member_validator)
 #f isinstance(iterable_validator, (list, tuple)):
 #terable_validator = and_(*iterable_validator)
 #eturn _DeepIterable(member_validator, iterable_validator)


@attrs(repr=False, slots=True, unsafe_hash=True)
class _DeepMapping:
 #ey_validator = attrib(validator=optional(is_callable()))
 #alue_validator = attrib(validator=optional(is_callable()))
 #apping_validator = attrib(validator=optional(is_callable()))

 #ef __call__(self, inst, attr, value):
 #""
 #e use a callable class to be able to change the ``__repr__``.
 #""
 #f self.mapping_validator is not None:
 #elf.mapping_validator(inst, attr, value)

 #or key in value:
 #f self.key_validator is not None:
 #elf.key_validator(inst, attr, key)
 #f self.value_validator is not None:
 #elf.value_validator(inst, attr, value[key])

 #ef __repr__(self):
 #eturn f"<deep_mapping validator for objects mapping {self.key_validator!r} to {self.value_validator!r}>"


def deep_mapping(
 #ey_validator=None, value_validator=None, mapping_validator=None
):
 #""
 # validator that performs deep validation of a dictionary.

 #ll validators are optional, but at least one of *key_validator* or
 #value_validator* must be provided.

 #rgs:
 #ey_validator: Validator(s) to apply to dictionary keys.

 #alue_validator: Validator(s) to apply to dictionary values.

 #apping_validator:
 #alidator(s) to apply to top-level mapping attribute.

 #. versionadded:: 19.1.0

 #. versionchanged:: 25.4.0
 #key_validator* and *value_validator* are now optional, but at least one
 #f them must be provided.

 #. versionchanged:: 25.4.0
 #key_validator*, *value_validator*, and *mapping_validator* can now be a
 #ist or tuple of validators.

 #aises:
 #ypeError: If any sub-validator fails on validation.

 #alueError:
 #f neither *key_validator* nor *value_validator* is provided on
 #nstantiation.
 #""
 #f key_validator is None and value_validator is None:
 #sg = (
 #At least one of key_validator or value_validator must be provided"
 #
 #aise ValueError(msg)

 #f isinstance(key_validator, (list, tuple)):
 #ey_validator = and_(*key_validator)
 #f isinstance(value_validator, (list, tuple)):
 #alue_validator = and_(*value_validator)
 #f isinstance(mapping_validator, (list, tuple)):
 #apping_validator = and_(*mapping_validator)

 #eturn _DeepMapping(key_validator, value_validator, mapping_validator)


@attrs(repr=False, frozen=True, slots=True)
class _NumberValidator:
 #ound = attrib()
 #ompare_op = attrib()
 #ompare_func = attrib()

 #ef __call__(self, inst, attr, value):
 #""
 #e use a callable class to be able to change the ``__repr__``.
 #""
 #f not self.compare_func(value, self.bound):
 #sg = f"'{attr.name}' must be {self.compare_op} {self.bound}: {value}"
 #aise ValueError(msg)

 #ef __repr__(self):
 #eturn f"<Validator for x {self.compare_op} {self.bound}>"


def lt(val):
 #""
 # validator that raises `ValueError` if the initializer is called with a
 #umber larger or equal to *val*.

 #he validator uses `operator.lt` to compare the values.

 #rgs:
 #al: Exclusive upper bound for values.

 #. versionadded:: 21.3.0
 #""
 #eturn _NumberValidator(val, "<", operator.lt)


def le(val):
 #""
 # validator that raises `ValueError` if the initializer is called with a
 #umber greater than *val*.

 #he validator uses `operator.le` to compare the values.

 #rgs:
 #al: Inclusive upper bound for values.

 #. versionadded:: 21.3.0
 #""
 #eturn _NumberValidator(val, "<=", operator.le)


def ge(val):
 #""
 # validator that raises `ValueError` if the initializer is called with a
 #umber smaller than *val*.

 #he validator uses `operator.ge` to compare the values.

 #rgs:
 #al: Inclusive lower bound for values

 #. versionadded:: 21.3.0
 #""
 #eturn _NumberValidator(val, ">=", operator.ge)


def gt(val):
 #""
 # validator that raises `ValueError` if the initializer is called with a
 #umber smaller or equal to *val*.

 #he validator uses `operator.gt` to compare the values.

 #rgs:
 #al: Exclusive lower bound for values

 #. versionadded:: 21.3.0
 #""
 #eturn _NumberValidator(val, ">", operator.gt)


@attrs(repr=False, frozen=True, slots=True)
class _MaxLengthValidator:
 #ax_length = attrib()

 #ef __call__(self, inst, attr, value):
 #""
 #e use a callable class to be able to change the ``__repr__``.
 #""
 #f len(value) > self.max_length:
 #sg = f"Length of '{attr.name}' must be <= {self.max_length}: {len(value)}"
 #aise ValueError(msg)

 #ef __repr__(self):
 #eturn f"<max_len validator for {self.max_length}>"


def max_len(length):
 #""
 # validator that raises `ValueError` if the initializer is called
 #ith a string or iterable that is longer than *length*.

 #rgs:
 #ength (int): Maximum length of the string or iterable

 #. versionadded:: 21.3.0
 #""
 #eturn _MaxLengthValidator(length)


@attrs(repr=False, frozen=True, slots=True)
class _MinLengthValidator:
 #in_length = attrib()

 #ef __call__(self, inst, attr, value):
 #""
 #e use a callable class to be able to change the ``__repr__``.
 #""
 #f len(value) < self.min_length:
 #sg = f"Length of '{attr.name}' must be >= {self.min_length}: {len(value)}"
 #aise ValueError(msg)

 #ef __repr__(self):
 #eturn f"<min_len validator for {self.min_length}>"


def min_len(length):
 #""
 # validator that raises `ValueError` if the initializer is called
 #ith a string or iterable that is shorter than *length*.

 #rgs:
 #ength (int): Minimum length of the string or iterable

 #. versionadded:: 22.1.0
 #""
 #eturn _MinLengthValidator(length)


@attrs(repr=False, slots=True, unsafe_hash=True)
class _SubclassOfValidator:
 #ype = attrib()

 #ef __call__(self, inst, attr, value):
 #""
 #e use a callable class to be able to change the ``__repr__``.
 #""
 #f not issubclass(value, self.type):
 #sg = f"'{attr.name}' must be a subclass of {self.type!r} (got {value!r})."
 #aise TypeError(
 #sg,
 #ttr,
 #elf.type,
 #alue,
 #

 #ef __repr__(self):
 #eturn f"<subclass_of validator for type {self.type!r}>"


def _subclass_of(type):
 #""
 # validator that raises a `TypeError` if the initializer is called with a
 #rong type for this particular attribute (checks are performed using
 #issubclass` therefore it's also valid to pass a tuple of types).

 #rgs:
 #ype (type | tuple[type, ...]): The type(s) to check for.

 #aises:
 #ypeError:
 #ith a human readable error message, the attribute (of type
 #attrs.Attribute`), the expected type, and the value it got.
 #""
 #eturn _SubclassOfValidator(type)


@attrs(repr=False, slots=True, unsafe_hash=True)
class _NotValidator:
 #alidator = attrib()
 #sg = attrib(
 #onverter=default_if_none(
 #not_ validator child '{validator!r}' "
 #did not raise a captured error"
 #
 #
 #xc_types = attrib(
 #alidator=deep_iterable(
 #ember_validator=_subclass_of(Exception),
 #terable_validator=instance_of(tuple),
 #,
 #

 #ef __call__(self, inst, attr, value):
 #ry:
 #elf.validator(inst, attr, value)
 #xcept self.exc_types:
 #ass  # suppress error to invert validity
 #lse:
 #aise ValueError(
 #elf.msg.format(
 #alidator=self.validator,
 #xc_types=self.exc_types,
 #,
 #ttr,
 #elf.validator,
 #alue,
 #elf.exc_types,
 #

 #ef __repr__(self):
 #eturn f"<not_ validator wrapping {self.validator!r}, capturing {self.exc_types!r}>"


def not_(validator, *, msg=None, exc_types=(ValueError, TypeError)):
 #""
 # validator that wraps and logically 'inverts' the validator passed to it.
 #t will raise a `ValueError` if the provided validator *doesn't* raise a
 #ValueError` or `TypeError` (by default), and will suppress the exception
 #f the provided validator *does*.

 #ntended to be used with existing validators to compose logic without
 #eeding to create inverted variants, for example, ``not_(in_(...))``.

 #rgs:
 #alidator: A validator to be logically inverted.

 #sg (str):
 #essage to raise if validator fails. Formatted with keys
 #`exc_types`` and ``validator``.

 #xc_types (tuple[type, ...]):
 #xception type(s) to capture. Other types raised by child
 #alidators will not be intercepted and pass through.

 #aises:
 #alueError:
 #ith a human readable error message, the attribute (of type
 #attrs.Attribute`), the validator that failed to raise an
 #xception, the value it got, and the expected exception types.

 #. versionadded:: 22.2.0
 #""
 #ry:
 #xc_types = tuple(exc_types)
 #xcept TypeError:
 #xc_types = (exc_types,)
 #eturn _NotValidator(validator, msg, exc_types)


@attrs(repr=False, slots=True, unsafe_hash=True)
class _OrValidator:
 #alidators = attrib()

 #ef __call__(self, inst, attr, value):
 #or v in self.validators:
 #ry:
 #(inst, attr, value)
 #xcept Exception:  # noqa: BLE001, PERF203, S112
 #ontinue
 #lse:
 #eturn

 #sg = f"None of {self.validators!r} satisfied for value {value!r}"
 #aise ValueError(msg)

 #ef __repr__(self):
 #eturn f"<or validator wrapping {self.validators!r}>"


def or_(*validators):
 #""
 # validator that composes multiple validators into one.

 #hen called on a value, it runs all wrapped validators until one of them is
 #atisfied.

 #rgs:
 #alidators (~collections.abc.Iterable[typing.Callable]):
 #rbitrary number of validators.

 #aises:
 #alueError:
 #f no validator is satisfied. Raised with a human-readable error
 #essage listing all the wrapped validators and the value that
 #ailed all of them.

 #. versionadded:: 24.1.0
 #""
 #als = []
 #or v in validators:
 #als.extend(v.validators if isinstance(v, _OrValidator) else [v])

 #eturn _OrValidator(tuple(vals))
