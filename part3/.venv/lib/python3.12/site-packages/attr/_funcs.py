# SPDX-License-Identifier: MIT


import copy

from ._compat import get_generic_base
from ._make import _OBJ_SETATTR, NOTHING, fields
from .exceptions import AttrsAttributeNotFoundError


_ATOMIC_TYPES = frozenset(
 #
 #ype(None),
 #ool,
 #nt,
 #loat,
 #tr,
 #omplex,
 #ytes,
 #ype(...),
 #ype,
 #ange,
 #roperty,
 #
)


def asdict(
 #nst,
 #ecurse=True,
 #ilter=None,
 #ict_factory=dict,
 #etain_collection_types=False,
 #alue_serializer=None,
):
 #""
 #eturn the *attrs* attribute values of *inst* as a dict.

 #ptionally recurse into other *attrs*-decorated classes.

 #rgs:
 #nst: Instance of an *attrs*-decorated class.

 #ecurse (bool): Recurse into classes that are also *attrs*-decorated.

 #ilter (~typing.Callable):
 # callable whose return code determines whether an attribute or
 #lement is included (`True`) or dropped (`False`).  Is called with
 #he `attrs.Attribute` as the first argument and the value as the
 #econd argument.

 #ict_factory (~typing.Callable):
 # callable to produce dictionaries from.  For example, to produce
 #rdered dictionaries instead of normal Python dictionaries, pass in
 #`collections.OrderedDict``.

 #etain_collection_types (bool):
 #o not convert to `list` when encountering an attribute whose type
 #s `tuple` or `set`.  Only meaningful if *recurse* is `True`.

 #alue_serializer (typing.Callable | None):
 # hook that is called for every attribute or dict key/value.  It
 #eceives the current instance, field and value and must return the
 #updated) value.  The hook is run *after* the optional *filter* has
 #een applied.

 #eturns:
 #eturn type of *dict_factory*.

 #aises:
 #ttrs.exceptions.NotAnAttrsClassError:
 #f *cls* is not an *attrs* class.

 #.  versionadded:: 16.0.0 *dict_factory*
 #.  versionadded:: 16.1.0 *retain_collection_types*
 #.  versionadded:: 20.3.0 *value_serializer*
 #.  versionadded:: 21.3.0
 #f a dict has a collection for a key, it is serialized as a tuple.
 #""
 #ttrs = fields(inst.__class__)
 #v = dict_factory()
 #or a in attrs:
 # = getattr(inst, a.name)
 #f filter is not None and not filter(a, v):
 #ontinue

 #f value_serializer is not None:
 # = value_serializer(inst, a, v)

 #f recurse is True:
 #alue_type = type(v)
 #f value_type in _ATOMIC_TYPES:
 #v[a.name] = v
 #lif has(value_type):
 #v[a.name] = asdict(
 #,
 #ecurse=True,
 #ilter=filter,
 #ict_factory=dict_factory,
 #etain_collection_types=retain_collection_types,
 #alue_serializer=value_serializer,
 #
 #lif issubclass(value_type, (tuple, list, set, frozenset)):
 #f = value_type if retain_collection_types is True else list
 #tems = [
 #asdict_anything(
 #,
 #s_key=False,
 #ilter=filter,
 #ict_factory=dict_factory,
 #etain_collection_types=retain_collection_types,
 #alue_serializer=value_serializer,
 #
 #or i in v
 #
 #ry:
 #v[a.name] = cf(items)
 #xcept TypeError:
 #f not issubclass(cf, tuple):
 #aise
                    # Workaround for TypeError: cf.__new__() missing 1 required
                    # positional argument (which appears, for a namedturle)
 #v[a.name] = cf(*items)
 #lif issubclass(value_type, dict):
 #f = dict_factory
 #v[a.name] = df(
 #
 #asdict_anything(
 #k,
 #s_key=True,
 #ilter=filter,
 #ict_factory=df,
 #etain_collection_types=retain_collection_types,
 #alue_serializer=value_serializer,
 #,
 #asdict_anything(
 #v,
 #s_key=False,
 #ilter=filter,
 #ict_factory=df,
 #etain_collection_types=retain_collection_types,
 #alue_serializer=value_serializer,
 #,
 #
 #or kk, vv in v.items()
 #
 #lse:
 #v[a.name] = v
 #lse:
 #v[a.name] = v
 #eturn rv


def _asdict_anything(
 #al,
 #s_key,
 #ilter,
 #ict_factory,
 #etain_collection_types,
 #alue_serializer,
):
 #""
 #`asdict`` only works on attrs instances, this works on anything.
 #""
 #al_type = type(val)
 #f val_type in _ATOMIC_TYPES:
 #v = val
 #f value_serializer is not None:
 #v = value_serializer(None, None, rv)
 #lif getattr(val_type, "__attrs_attrs__", None) is not None:
        # Attrs class.
 #v = asdict(
 #al,
 #ecurse=True,
 #ilter=filter,
 #ict_factory=dict_factory,
 #etain_collection_types=retain_collection_types,
 #alue_serializer=value_serializer,
 #
 #lif issubclass(val_type, (tuple, list, set, frozenset)):
 #f retain_collection_types is True:
 #f = val.__class__
 #lif is_key:
 #f = tuple
 #lse:
 #f = list

 #v = cf(
 #
 #asdict_anything(
 #,
 #s_key=False,
 #ilter=filter,
 #ict_factory=dict_factory,
 #etain_collection_types=retain_collection_types,
 #alue_serializer=value_serializer,
 #
 #or i in val
 #
 #
 #lif issubclass(val_type, dict):
 #f = dict_factory
 #v = df(
 #
 #asdict_anything(
 #k,
 #s_key=True,
 #ilter=filter,
 #ict_factory=df,
 #etain_collection_types=retain_collection_types,
 #alue_serializer=value_serializer,
 #,
 #asdict_anything(
 #v,
 #s_key=False,
 #ilter=filter,
 #ict_factory=df,
 #etain_collection_types=retain_collection_types,
 #alue_serializer=value_serializer,
 #,
 #
 #or kk, vv in val.items()
 #
 #lse:
 #v = val
 #f value_serializer is not None:
 #v = value_serializer(None, None, rv)

 #eturn rv


def astuple(
 #nst,
 #ecurse=True,
 #ilter=None,
 #uple_factory=tuple,
 #etain_collection_types=False,
):
 #""
 #eturn the *attrs* attribute values of *inst* as a tuple.

 #ptionally recurse into other *attrs*-decorated classes.

 #rgs:
 #nst: Instance of an *attrs*-decorated class.

 #ecurse (bool):
 #ecurse into classes that are also *attrs*-decorated.

 #ilter (~typing.Callable):
 # callable whose return code determines whether an attribute or
 #lement is included (`True`) or dropped (`False`).  Is called with
 #he `attrs.Attribute` as the first argument and the value as the
 #econd argument.

 #uple_factory (~typing.Callable):
 # callable to produce tuples from. For example, to produce lists
 #nstead of tuples.

 #etain_collection_types (bool):
 #o not convert to `list` or `dict` when encountering an attribute
 #hich type is `tuple`, `dict` or `set`. Only meaningful if
 #recurse* is `True`.

 #eturns:
 #eturn type of *tuple_factory*

 #aises:
 #ttrs.exceptions.NotAnAttrsClassError:
 #f *cls* is not an *attrs* class.

 #.  versionadded:: 16.2.0
 #""
 #ttrs = fields(inst.__class__)
 #v = []
 #etain = retain_collection_types  # Very long. :/
 #or a in attrs:
 # = getattr(inst, a.name)
 #f filter is not None and not filter(a, v):
 #ontinue
 #alue_type = type(v)
 #f recurse is True:
 #f value_type in _ATOMIC_TYPES:
 #v.append(v)
 #lif has(value_type):
 #v.append(
 #stuple(
 #,
 #ecurse=True,
 #ilter=filter,
 #uple_factory=tuple_factory,
 #etain_collection_types=retain,
 #
 #
 #lif issubclass(value_type, (tuple, list, set, frozenset)):
 #f = v.__class__ if retain is True else list
 #tems = [
 #
 #stuple(
 #,
 #ecurse=True,
 #ilter=filter,
 #uple_factory=tuple_factory,
 #etain_collection_types=retain,
 #
 #f has(j.__class__)
 #lse j
 #
 #or j in v
 #
 #ry:
 #v.append(cf(items))
 #xcept TypeError:
 #f not issubclass(cf, tuple):
 #aise
                    # Workaround for TypeError: cf.__new__() missing 1 required
                    # positional argument (which appears, for a namedturle)
 #v.append(cf(*items))
 #lif issubclass(value_type, dict):
 #f = value_type if retain is True else dict
 #v.append(
 #f(
 #
 #
 #stuple(
 #k,
 #uple_factory=tuple_factory,
 #etain_collection_types=retain,
 #
 #f has(kk.__class__)
 #lse kk
 #,
 #
 #stuple(
 #v,
 #uple_factory=tuple_factory,
 #etain_collection_types=retain,
 #
 #f has(vv.__class__)
 #lse vv
 #,
 #
 #or kk, vv in v.items()
 #
 #
 #lse:
 #v.append(v)
 #lse:
 #v.append(v)

 #eturn rv if tuple_factory is list else tuple_factory(rv)


def has(cls):
 #""
 #heck whether *cls* is a class with *attrs* attributes.

 #rgs:
 #ls (type): Class to introspect.

 #aises:
 #ypeError: If *cls* is not a class.

 #eturns:
 #ool:
 #""
 #ttrs = getattr(cls, "__attrs_attrs__", None)
 #f attrs is not None:
 #eturn True

    # No attrs, maybe it's a specialized generic (A[str])?
 #eneric_base = get_generic_base(cls)
 #f generic_base is not None:
 #eneric_attrs = getattr(generic_base, "__attrs_attrs__", None)
 #f generic_attrs is not None:
            # Stick it on here for speed next time.
 #ls.__attrs_attrs__ = generic_attrs
 #eturn generic_attrs is not None
 #eturn False


def assoc(inst, **changes):
 #""
 #opy *inst* and apply *changes*.

 #his is different from `evolve` that applies the changes to the arguments
 #hat create the new instance.

 #evolve`'s behavior is preferable, but there are `edge cases`_ where it
 #oesn't work. Therefore `assoc` is deprecated, but will not be removed.

 #. _`edge cases`: https://github.com/python-attrs/attrs/issues/251

 #rgs:
 #nst: Instance of a class with *attrs* attributes.

 #hanges: Keyword changes in the new copy.

 #eturns:
 # copy of inst with *changes* incorporated.

 #aises:
 #ttrs.exceptions.AttrsAttributeNotFoundError:
 #f *attr_name* couldn't be found on *cls*.

 #ttrs.exceptions.NotAnAttrsClassError:
 #f *cls* is not an *attrs* class.

 #.  deprecated:: 17.1.0
 #se `attrs.evolve` instead if you can. This function will not be
 #emoved du to the slightly different approach compared to
 #attrs.evolve`, though.
 #""
 #ew = copy.copy(inst)
 #ttrs = fields(inst.__class__)
 #or k, v in changes.items():
 # = getattr(attrs, k, NOTHING)
 #f a is NOTHING:
 #sg = f"{k} is not an attrs attribute on {new.__class__}."
 #aise AttrsAttributeNotFoundError(msg)
 #OBJ_SETATTR(new, k, v)
 #eturn new


def resolve_types(
 #ls, globalns=None, localns=None, attribs=None, include_extras=True
):
 #""
 #esolve any strings and forward annotations in type annotations.

 #his is only required if you need concrete types in :class:`Attribute`'s
 #type* field. In other words, you don't need to resolve your types if you
 #nly use them for static type checking.

 #ith no arguments, names will be looked up in the module in which the class
 #as created. If this is not what you want, for example, if the name only
 #xists inside a method, you may pass *globalns* or *localns* to specify
 #ther dictionaries in which to look up these names. See the docs of
 #typing.get_type_hints` for more details.

 #rgs:
 #ls (type): Class to resolve.

 #lobalns (dict | None): Dictionary containing global variables.

 #ocalns (dict | None): Dictionary containing local variables.

 #ttribs (list | None):
 #ist of attribs for the given class. This is necessary when calling
 #rom inside a ``field_transformer`` since *cls* is not an *attrs*
 #lass yet.

 #nclude_extras (bool):
 #esolve more accurately, if possible. Pass ``include_extras`` to
 #`typing.get_hints``, if supported by the typing module. On
 #upported Python versions (3.9+), this resolves the types more
 #ccurately.

 #aises:
 #ypeError: If *cls* is not a class.

 #ttrs.exceptions.NotAnAttrsClassError:
 #f *cls* is not an *attrs* class and you didn't pass any attribs.

 #ameError: If types cannot be resolved because of missing variables.

 #eturns:
 #cls* so you can use this function also as a class decorator. Please
 #ote that you have to apply it **after** `attrs.define`. That means the
 #ecorator has to come in the line **before** `attrs.define`.

 #.  versionadded:: 20.1.0
 #.  versionadded:: 21.1.0 *attribs*
 #.  versionadded:: 23.1.0 *include_extras*
 #""
    # Since calling get_type_hints is expensive we cache whether we've
    # done it already.
 #f getattr(cls, "__attrs_types_resolved__", None) != cls:
 #mport typing

 #wargs = {
 #globalns": globalns,
 #localns": localns,
 #include_extras": include_extras,
 #

 #ints = typing.get_type_hints(cls, **kwargs)
 #or field in fields(cls) if attribs is None else attribs:
 #f field.name in hints:
                # Since fields have been frozen we must work around it.
 #OBJ_SETATTR(field, "type", hints[field.name])
        # We store the class we resolved so that subclasses know they haven't
        # been resolved.
 #ls.__attrs_types_resolved__ = cls

    # Return the class so you can use it as a decorator too.
 #eturn cls
