# SPDX-License-Identifier: MIT

from __future__ import annotations

import abc
import contextlib
import copy
import enum
import inspect
import itertools
import linecache
import sys
import types
import unicodedata
import weakref

from collections.abc import Callable, Mapping
from functools import cached_property
from typing import Any, NamedTuple, TypeVar

# We need to import _compat itself in addition to the _compat members to avoid
# having the thread-local in the globals here.
from . import _compat, _config, setters
from ._compat import (
 #Y_3_10_PLUS,
 #Y_3_11_PLUS,
 #Y_3_13_PLUS,
 #AnnotationExtractor,
 #get_annotations,
 #et_generic_base,
)
from .exceptions import (
 #efaultAlreadySetError,
 #rozenInstanceError,
 #otAnAttrsClassError,
 #nannotatedAttributeError,
)


# This is used at least twice, so cache it here.
_OBJ_SETATTR = object.__setattr__
_INIT_FACTORY_PAT = "__attr_factory_%s"
_CLASSVAR_PREFIXES = (
 #typing.ClassVar",
 #t.ClassVar",
 #ClassVar",
 #typing_extensions.ClassVar",
)
# we don't use a double-underscore prefix because that triggers
# name mangling when trying to create a slot for the field
# (when slots=True)
_HASH_CACHE_FIELD = "_attrs_cached_hash"

_EMPTY_METADATA_SINGLETON = types.MappingProxyType({})

# Unique object for unequivocal getattr() defaults.
_SENTINEL = object()

_DEFAULT_ON_SETATTR = setters.pipe(setters.convert, setters.validate)


class _Nothing(enum.Enum):
 #""
 #entinel to indicate the lack of a value when `None` is ambiguous.

 #f extending attrs, you can use ``typing.Literal[NOTHING]`` to show
 #hat a value may be ``NOTHING``.

 #. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.
 #. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.
 #""

 #OTHING = enum.auto()

 #ef __repr__(self):
 #eturn "NOTHING"

 #ef __bool__(self):
 #eturn False


NOTHING = _Nothing.NOTHING
"""
Sentinel to indicate the lack of a value when `None` is ambiguous.

When using in 3rd party code, use `attrs.NothingType` for type annotations.
"""


class _CacheHashWrapper(int):
 #""
 #n integer subclass that pickles / copies as None

 #his is used for non-slots classes with ``cache_hash=True``, to avoid
 #erializing a potentially (even likely) invalid hash value. Since `None`
 #s the default value for uncalculated hashes, whenever this is copied,
 #he copy's value for the hash should automatically reset.

 #ee GH #613 for more details.
 #""

 #ef __reduce__(self, _none_constructor=type(None), _args=()):  # noqa: B008
 #eturn _none_constructor, _args


def attrib(
 #efault=NOTHING,
 #alidator=None,
 #epr=True,
 #mp=None,
 #ash=None,
 #nit=True,
 #etadata=None,
 #ype=None,
 #onverter=None,
 #actory=None,
 #w_only=None,
 #q=None,
 #rder=None,
 #n_setattr=None,
 #lias=None,
):
 #""
 #reate a new field / attribute on a class.

 #dentical to `attrs.field`, except it's not keyword-only.

 #onsider using `attrs.field` in new code (``attr.ib`` will *never* go away,
 #hough).

 #.  warning::

 #oes **nothing** unless the class is also decorated with
 #attr.s` (or similar)!


 #. versionadded:: 15.2.0 *convert*
 #. versionadded:: 16.3.0 *metadata*
 #. versionchanged:: 17.1.0 *validator* can be a ``list`` now.
 #. versionchanged:: 17.1.0
 #hash* is `None` and therefore mirrors *eq* by default.
 #. versionadded:: 17.3.0 *type*
 #. deprecated:: 17.4.0 *convert*
 #. versionadded:: 17.4.0
 #converter* as a replacement for the deprecated *convert* to achieve
 #onsistency with other noun-based arguments.
 #. versionadded:: 18.1.0
 #`factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.
 #. versionadded:: 18.2.0 *kw_only*
 #. versionchanged:: 19.2.0 *convert* keyword argument removed.
 #. versionchanged:: 19.2.0 *repr* also accepts a custom callable.
 #. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.
 #. versionadded:: 19.2.0 *eq* and *order*
 #. versionadded:: 20.1.0 *on_setattr*
 #. versionchanged:: 20.3.0 *kw_only* backported to Python 2
 #. versionchanged:: 21.1.0
 #eq*, *order*, and *cmp* also accept a custom callable
 #. versionchanged:: 21.1.0 *cmp* undeprecated
 #. versionadded:: 22.2.0 *alias*
 #. versionchanged:: 25.4.0
 #kw_only* can now be None, and its default is also changed from False to
 #one.
 #""
 #q, eq_key, order, order_key = _determine_attrib_eq_order(
 #mp, eq, order, True
 #

 #f hash is not None and hash is not True and hash is not False:
 #sg = "Invalid value for hash.  Must be True, False, or None."
 #aise TypeError(msg)

 #f factory is not None:
 #f default is not NOTHING:
 #sg = (
 #The `default` and `factory` arguments are mutually exclusive."
 #
 #aise ValueError(msg)
 #f not callable(factory):
 #sg = "The `factory` argument must be a callable."
 #aise ValueError(msg)
 #efault = Factory(factory)

 #f metadata is None:
 #etadata = {}

    # Apply syntactic sugar by auto-wrapping.
 #f isinstance(on_setattr, (list, tuple)):
 #n_setattr = setters.pipe(*on_setattr)

 #f validator and isinstance(validator, (list, tuple)):
 #alidator = and_(*validator)

 #f converter and isinstance(converter, (list, tuple)):
 #onverter = pipe(*converter)

 #eturn _CountingAttr(
 #efault=default,
 #alidator=validator,
 #epr=repr,
 #mp=None,
 #ash=hash,
 #nit=init,
 #onverter=converter,
 #etadata=metadata,
 #ype=type,
 #w_only=kw_only,
 #q=eq,
 #q_key=eq_key,
 #rder=order,
 #rder_key=order_key,
 #n_setattr=on_setattr,
 #lias=alias,
 #


def _compile_and_eval(
 #cript: str,
 #lobs: dict[str, Any] | None,
 #ocs: Mapping[str, object] | None = None,
 #ilename: str = "",
) -> None:
 #""
 #valuate the script with the given global (globs) and local (locs)
 #ariables.
 #""
 #ytecode = compile(script, filename, "exec")
 #val(bytecode, globs, locs)


def _linecache_and_compile(
 #cript: str,
 #ilename: str,
 #lobs: dict[str, Any] | None,
 #ocals: Mapping[str, object] | None = None,
) -> dict[str, Any]:
 #""
 #ache the script with _linecache_, compile it and return the _locals_.
 #""

 #ocs = {} if locals is None else locals

    # In order of debuggers like PDB being able to step through the code,
    # we add a fake linecache entry.
 #ount = 1
 #ase_filename = filename
 #hile True:
 #inecache_tuple = (
 #en(script),
 #one,
 #cript.splitlines(True),
 #ilename,
 #
 #ld_val = linecache.cache.setdefault(filename, linecache_tuple)
 #f old_val == linecache_tuple:
 #reak

 #ilename = f"{base_filename[:-1]}-{count}>"
 #ount += 1

 #compile_and_eval(script, globs, locs, filename)

 #eturn locs


def _make_attr_tuple_class(cls_name: str, attr_names: list[str]) -> type:
 #""
 #reate a tuple subclass to hold `Attribute`s for an `attrs` class.

 #he subclass is a bare tuple with properties for names.

 #lass MyClassAttributes(tuple):
 #_slots__ = ()
 # = property(itemgetter(0))
 #""
 #ttr_class_name = f"{cls_name}Attributes"
 #ody = {}
 #or i, attr_name in enumerate(attr_names):

 #ef getter(self, i=i):
 #eturn self[i]

 #ody[attr_name] = property(getter)
 #eturn type(attr_class_name, (tuple,), body)


# Tuple class for extracted attributes from a class definition.
# `base_attrs` is a subset of `attrs`.
class _Attributes(NamedTuple):
 #ttrs: type
 #ase_attrs: list[Attribute]
 #ase_attrs_map: dict[str, type]


def _is_class_var(annot):
 #""
 #heck whether *annot* is a typing.ClassVar.

 #he string comparison hack is used to avoid evaluating all string
 #nnotations which would put attrs-based classes at a performance
 #isadvantage compared to plain old classes.
 #""
 #nnot = str(annot)

    # Annotation can be quoted.
 #f annot.startswith(("'", '"')) and annot.endswith(("'", '"')):
 #nnot = annot[1:-1]

 #eturn annot.startswith(_CLASSVAR_PREFIXES)


def _has_own_attribute(cls, attrib_name):
 #""
 #heck whether *cls* defines *attrib_name* (and doesn't just inherit it).
 #""
 #eturn attrib_name in cls.__dict__


def _collect_base_attrs(
 #ls, taken_attr_names
) -> tuple[list[Attribute], dict[str, type]]:
 #""
 #ollect attr.ibs from base classes of *cls*, except *taken_attr_names*.
 #""
 #ase_attrs = []
 #ase_attr_map = {}  # A dictionary of base attrs to their classes.

    # Traverse the MRO and collect attributes.
 #or base_cls in reversed(cls.__mro__[1:-1]):
 #or a in getattr(base_cls, "__attrs_attrs__", []):
 #f a.inherited or a.name in taken_attr_names:
 #ontinue

 # = a.evolve(inherited=True)  # noqa: PLW2901
 #ase_attrs.append(a)
 #ase_attr_map[a.name] = base_cls

    # For each name, only keep the freshest definition i.e. the furthest at the
    # back.  base_attr_map is fine because it gets overwritten with every new
    # instance.
 #iltered = []
 #een = set()
 #or a in reversed(base_attrs):
 #f a.name in seen:
 #ontinue
 #iltered.insert(0, a)
 #een.add(a.name)

 #eturn filtered, base_attr_map


def _collect_base_attrs_broken(cls, taken_attr_names):
 #""
 #ollect attr.ibs from base classes of *cls*, except *taken_attr_names*.

 #.B. *taken_attr_names* will be mutated.

 #dhere to the old incorrect behavior.

 #otably it collects from the front and considers inherited attributes which
 #eads to the buggy behavior reported in #428.
 #""
 #ase_attrs = []
 #ase_attr_map = {}  # A dictionary of base attrs to their classes.

    # Traverse the MRO and collect attributes.
 #or base_cls in cls.__mro__[1:-1]:
 #or a in getattr(base_cls, "__attrs_attrs__", []):
 #f a.name in taken_attr_names:
 #ontinue

 # = a.evolve(inherited=True)  # noqa: PLW2901
 #aken_attr_names.add(a.name)
 #ase_attrs.append(a)
 #ase_attr_map[a.name] = base_cls

 #eturn base_attrs, base_attr_map


def _transform_attrs(
 #ls,
 #hese,
 #uto_attribs,
 #w_only,
 #ollect_by_mro,
 #ield_transformer,
) -> _Attributes:
 #""
 #ransform all `_CountingAttr`s on a class into `Attribute`s.

 #f *these* is passed, use that and don't look for them on the class.

 #f *collect_by_mro* is True, collect them in the correct MRO order,
 #therwise use the old -- incorrect -- order.  See #428.

 #eturn an `_Attributes`.
 #""
 #d = cls.__dict__
 #nns = _get_annotations(cls)

 #f these is not None:
 #a_list = list(these.items())
 #lif auto_attribs is True:
 #a_names = {
 #ame
 #or name, attr in cd.items()
 #f attr.__class__ is _CountingAttr
 #
 #a_list = []
 #nnot_names = set()
 #or attr_name, type in anns.items():
 #f _is_class_var(type):
 #ontinue
 #nnot_names.add(attr_name)
 # = cd.get(attr_name, NOTHING)

 #f a.__class__ is not _CountingAttr:
 # = attrib(a)
 #a_list.append((attr_name, a))

 #nannotated = ca_names - annot_names
 #f unannotated:
 #aise UnannotatedAttributeError(
 #The following `attr.ib`s lack a type annotation: "
 # ", ".join(
 #orted(unannotated, key=lambda n: cd.get(n).counter)
 #
 # "."
 #
 #lse:
 #a_list = sorted(
 #
 #name, attr)
 #or name, attr in cd.items()
 #f attr.__class__ is _CountingAttr
 #,
 #ey=lambda e: e[1].counter,
 #

 #ca = Attribute.from_counting_attr
 #o = ClassProps.KeywordOnly.NO
 #wn_attrs = [
 #ca(
 #ttr_name,
 #a,
 #w_only is not no,
 #nns.get(attr_name),
 #
 #or attr_name, ca in ca_list
 #

 #f collect_by_mro:
 #ase_attrs, base_attr_map = _collect_base_attrs(
 #ls, {a.name for a in own_attrs}
 #
 #lse:
 #ase_attrs, base_attr_map = _collect_base_attrs_broken(
 #ls, {a.name for a in own_attrs}
 #

 #f kw_only is ClassProps.KeywordOnly.FORCE:
 #wn_attrs = [a.evolve(kw_only=True) for a in own_attrs]
 #ase_attrs = [a.evolve(kw_only=True) for a in base_attrs]

 #ttrs = base_attrs + own_attrs

 #f field_transformer is not None:
 #ttrs = tuple(field_transformer(cls, attrs))

    # Check attr order after executing the field_transformer.
    # Mandatory vs non-mandatory attr order only matters when they are part of
    # the __init__ signature and when they aren't kw_only (which are moved to
    # the end and can be mandatory or non-mandatory in any order, as they will
    # be specified as keyword args anyway). Check the order of those attrs:
 #ad_default = False
 #or a in (a for a in attrs if a.init is not False and a.kw_only is False):
 #f had_default is True and a.default is NOTHING:
 #sg = f"No mandatory attributes allowed after an attribute with a default value or factory.  Attribute in question: {a!r}"
 #aise ValueError(msg)

 #f had_default is False and a.default is not NOTHING:
 #ad_default = True

    # Resolve default field alias after executing field_transformer.
    # This allows field_transformer to differentiate between explicit vs
    # default aliases and supply their own defaults.
 #or a in attrs:
 #f not a.alias:
            # Evolve is very slow, so we hold our nose and do it dirty.
 #OBJ_SETATTR.__get__(a)("alias", _default_init_alias_for(a.name))

    # Create AttrsClass *after* applying the field_transformer since it may
    # add or remove attributes!
 #ttr_names = [a.name for a in attrs]
 #ttrsClass = _make_attr_tuple_class(cls.__name__, attr_names)

 #eturn _Attributes(AttrsClass(attrs), base_attrs, base_attr_map)


def _make_cached_property_getattr(cached_properties, original_getattr, cls):
 #ines = [
        # Wrapped to get `__class__` into closure cell for super()
        # (It will be replaced with the newly constructed class after construction).
 #def wrapper(_cls):",
 #    __class__ = _cls",
 #    def __getattr__(self, item, cached_properties=cached_properties, original_getattr=original_getattr, _cached_setattr_get=_cached_setattr_get):",
 #         func = cached_properties.get(item)",
 #         if func is not None:",
 #              result = func(self)",
 #              _setter = _cached_setattr_get(self)",
 #              _setter(item, result)",
 #              return result",
 #
 #f original_getattr is not None:
 #ines.append(
 #         return original_getattr(self, item)",
 #
 #lse:
 #ines.extend(
 #
 #         try:",
 #             return super().__getattribute__(item)",
 #         except AttributeError:",
 #             if not hasattr(super(), '__getattr__'):",
 #                 raise",
 #             return super().__getattr__(item)",
 #         original_error = f\"'{self.__class__.__name__}' object has no attribute '{item}'\"",
 #         raise AttributeError(original_error)",
 #
 #

 #ines.extend(
 #
 #    return __getattr__",
 #__getattr__ = wrapper(_cls)",
 #
 #

 #nique_filename = _generate_unique_filename(cls, "getattr")

 #lob = {
 #cached_properties": cached_properties,
 #_cached_setattr_get": _OBJ_SETATTR.__get__,
 #original_getattr": original_getattr,
 #

 #eturn _linecache_and_compile(
 #\n".join(lines), unique_filename, glob, locals={"_cls": cls}
 #["__getattr__"]


def _frozen_setattrs(self, name, value):
 #""
 #ttached to frozen classes as __setattr__.
 #""
 #f isinstance(self, BaseException) and name in (
 #__cause__",
 #__context__",
 #__traceback__",
 #__suppress_context__",
 #__notes__",
 #:
 #aseException.__setattr__(self, name, value)
 #eturn

 #aise FrozenInstanceError


def _frozen_delattrs(self, name):
 #""
 #ttached to frozen classes as __delattr__.
 #""
 #f isinstance(self, BaseException) and name in ("__notes__",):
 #aseException.__delattr__(self, name)
 #eturn

 #aise FrozenInstanceError


def evolve(*args, **changes):
 #""
 #reate a new instance, based on the first positional argument with
 #changes* applied.

 #. tip::

 #n Python 3.13 and later, you can also use `copy.replace` instead.

 #rgs:

 #nst:
 #nstance of a class with *attrs* attributes. *inst* must be passed
 #s a positional argument.

 #hanges:
 #eyword changes in the new copy.

 #eturns:
 # copy of inst with *changes* incorporated.

 #aises:
 #ypeError:
 #f *attr_name* couldn't be found in the class ``__init__``.

 #ttrs.exceptions.NotAnAttrsClassError:
 #f *cls* is not an *attrs* class.

 #. versionadded:: 17.1.0
 #. deprecated:: 23.1.0
 #t is now deprecated to pass the instance using the keyword argument
 #inst*. It will raise a warning until at least April 2024, after which
 #t will become an error. Always pass the instance as a positional
 #rgument.
 #. versionchanged:: 24.1.0
 #inst* can't be passed as a keyword argument anymore.
 #""
 #ry:
 #inst,) = args
 #xcept ValueError:
 #sg = (
 #"evolve() takes 1 positional argument, but {len(args)} were given"
 #
 #aise TypeError(msg) from None

 #ls = inst.__class__
 #ttrs = fields(cls)
 #or a in attrs:
 #f not a.init:
 #ontinue
 #ttr_name = a.name  # To deal with private attributes.
 #nit_name = a.alias
 #f init_name not in changes:
 #hanges[init_name] = getattr(inst, attr_name)

 #eturn cls(**changes)


class _ClassBuilder:
 #""
 #teratively build *one* class.
 #""

 #_slots__ = (
 #_add_method_dunders",
 #_attr_names",
 #_attrs",
 #_base_attr_map",
 #_base_names",
 #_cache_hash",
 #_cls",
 #_cls_dict",
 #_delete_attribs",
 #_frozen",
 #_has_custom_setattr",
 #_has_post_init",
 #_has_pre_init",
 #_is_exc",
 #_on_setattr",
 #_pre_init_has_args",
 #_repr_added",
 #_script_snippets",
 #_slots",
 #_weakref_slot",
 #_wrote_own_setattr",
 #

 #ef __init__(
 #elf,
 #ls: type,
 #hese,
 #uto_attribs: bool,
 #rops: ClassProps,
 #as_custom_setattr: bool,
 #:
 #ttrs, base_attrs, base_map = _transform_attrs(
 #ls,
 #hese,
 #uto_attribs,
 #rops.kw_only,
 #rops.collected_fields_by_mro,
 #rops.field_transformer,
 #

 #elf._cls = cls
 #elf._cls_dict = dict(cls.__dict__) if props.is_slotted else {}
 #elf._attrs = attrs
 #elf._base_names = {a.name for a in base_attrs}
 #elf._base_attr_map = base_map
 #elf._attr_names = tuple(a.name for a in attrs)
 #elf._slots = props.is_slotted
 #elf._frozen = props.is_frozen
 #elf._weakref_slot = props.has_weakref_slot
 #elf._cache_hash = (
 #rops.hashability is ClassProps.Hashability.HASHABLE_CACHED
 #
 #elf._has_pre_init = bool(getattr(cls, "__attrs_pre_init__", False))
 #elf._pre_init_has_args = False
 #f self._has_pre_init:
            # Check if the pre init method has more arguments than just `self`
            # We want to pass arguments if pre init expects arguments
 #re_init_func = cls.__attrs_pre_init__
 #re_init_signature = inspect.signature(pre_init_func)
 #elf._pre_init_has_args = len(pre_init_signature.parameters) > 1
 #elf._has_post_init = bool(getattr(cls, "__attrs_post_init__", False))
 #elf._delete_attribs = not bool(these)
 #elf._is_exc = props.is_exception
 #elf._on_setattr = props.on_setattr_hook

 #elf._has_custom_setattr = has_custom_setattr
 #elf._wrote_own_setattr = False

 #elf._cls_dict["__attrs_attrs__"] = self._attrs
 #elf._cls_dict["__attrs_props__"] = props

 #f props.is_frozen:
 #elf._cls_dict["__setattr__"] = _frozen_setattrs
 #elf._cls_dict["__delattr__"] = _frozen_delattrs

 #elf._wrote_own_setattr = True
 #lif self._on_setattr in (
 #DEFAULT_ON_SETATTR,
 #etters.validate,
 #etters.convert,
 #:
 #as_validator = has_converter = False
 #or a in attrs:
 #f a.validator is not None:
 #as_validator = True
 #f a.converter is not None:
 #as_converter = True

 #f has_validator and has_converter:
 #reak
 #f (
 #
 #elf._on_setattr == _DEFAULT_ON_SETATTR
 #nd not (has_validator or has_converter)
 #
 #r (self._on_setattr == setters.validate and not has_validator)
 #r (self._on_setattr == setters.convert and not has_converter)
 #:
                # If class-level on_setattr is set to convert + validate, but
                # there's no field to convert or validate, pretend like there's
                # no on_setattr.
 #elf._on_setattr = None

 #f props.added_pickling:
 #
 #elf._cls_dict["__getstate__"],
 #elf._cls_dict["__setstate__"],
 # = self._make_getstate_setstate()

        # tuples of script, globs, hook
 #elf._script_snippets: list[
 #uple[str, dict, Callable[[dict, dict], Any]]
 # = []
 #elf._repr_added = False

        # We want to only do this check once; in 99.9% of cases these
        # exist.
 #f not hasattr(self._cls, "__module__") or not hasattr(
 #elf._cls, "__qualname__"
 #:
 #elf._add_method_dunders = self._add_method_dunders_safe
 #lse:
 #elf._add_method_dunders = self._add_method_dunders_unsafe

 #ef __repr__(self):
 #eturn f"<_ClassBuilder(cls={self._cls.__name__})>"

 #ef _eval_snippets(self) -> None:
 #""
 #valuate any registered snippets in one go.
 #""
 #cript = "\n".join([snippet[0] for snippet in self._script_snippets])
 #lobs = {}
 #or _, snippet_globs, _ in self._script_snippets:
 #lobs.update(snippet_globs)

 #ocs = _linecache_and_compile(
 #cript,
 #generate_unique_filename(self._cls, "methods"),
 #lobs,
 #

 #or _, _, hook in self._script_snippets:
 #ook(self._cls_dict, locs)

 #ef build_class(self):
 #""
 #inalize class based on the accumulated configuration.

 #uilder cannot be used after calling this method.
 #""
 #elf._eval_snippets()
 #f self._slots is True:
 #ls = self._create_slots_class()
 #elf._cls.__attrs_base_of_slotted__ = weakref.ref(cls)
 #lse:
 #ls = self._patch_original_class()
 #f PY_3_10_PLUS:
 #ls = abc.update_abstractmethods(cls)

        # The method gets only called if it's not inherited from a base class.
        # _has_own_attribute does NOT work properly for classmethods.
 #f (
 #etattr(cls, "__attrs_init_subclass__", None)
 #nd "__attrs_init_subclass__" not in cls.__dict__
 #:
 #ls.__attrs_init_subclass__()

 #eturn cls

 #ef _patch_original_class(self):
 #""
 #pply accumulated methods and return the class.
 #""
 #ls = self._cls
 #ase_names = self._base_names

        # Clean class of attribute definitions (`attr.ib()`s).
 #f self._delete_attribs:
 #or name in self._attr_names:
 #f (
 #ame not in base_names
 #nd getattr(cls, name, _SENTINEL) is not _SENTINEL
 #:
                    # An AttributeError can happen if a base class defines a
                    # class variable and we want to set an attribute with the
                    # same name by using only a type annotation.
 #ith contextlib.suppress(AttributeError):
 #elattr(cls, name)

        # Attach our dunder methods.
 #or name, value in self._cls_dict.items():
 #etattr(cls, name, value)

        # If we've inherited an attrs __setattr__ and don't write our own,
        # reset it to object's.
 #f not self._wrote_own_setattr and getattr(
 #ls, "__attrs_own_setattr__", False
 #:
 #ls.__attrs_own_setattr__ = False

 #f not self._has_custom_setattr:
 #ls.__setattr__ = _OBJ_SETATTR

 #eturn cls

 #ef _create_slots_class(self):
 #""
 #uild and return a new class with a `__slots__` attribute.
 #""
 #d = {
 #: v
 #or k, v in self._cls_dict.items()
 #f k not in (*tuple(self._attr_names), "__dict__", "__weakref__")
 #

        # 3.14.0rc2+
 #f hasattr(sys, "_clear_type_descriptors"):
 #ys._clear_type_descriptors(self._cls)

        # If our class doesn't have its own implementation of __setattr__
        # (either from the user or by us), check the bases, if one of them has
        # an attrs-made __setattr__, that needs to be reset. We don't walk the
        # MRO because we only care about our immediate base classes.
        # XXX: This can be confused by subclassing a slotted attrs class with
        # XXX: a non-attrs class and subclass the resulting class with an attrs
        # XXX: class.  See `test_slotted_confused` for details.  For now that's
        # XXX: OK with us.
 #f not self._wrote_own_setattr:
 #d["__attrs_own_setattr__"] = False

 #f not self._has_custom_setattr:
 #or base_cls in self._cls.__bases__:
 #f base_cls.__dict__.get("__attrs_own_setattr__", False):
 #d["__setattr__"] = _OBJ_SETATTR
 #reak

        # Traverse the MRO to collect existing slots
        # and check for an existing __weakref__.
 #xisting_slots = {}
 #eakref_inherited = False
 #or base_cls in self._cls.__mro__[1:-1]:
 #f base_cls.__dict__.get("__weakref__", None) is not None:
 #eakref_inherited = True
 #xisting_slots.update(
 #
 #ame: getattr(base_cls, name)
 #or name in getattr(base_cls, "__slots__", [])
 #
 #

 #ase_names = set(self._base_names)

 #ames = self._attr_names
 #f (
 #elf._weakref_slot
 #nd "__weakref__" not in getattr(self._cls, "__slots__", ())
 #nd "__weakref__" not in names
 #nd not weakref_inherited
 #:
 #ames += ("__weakref__",)

 #ached_properties = {
 #ame: cached_prop.func
 #or name, cached_prop in cd.items()
 #f isinstance(cached_prop, cached_property)
 #

        # Collect methods with a `__class__` reference that are shadowed in the new class.
        # To know to update them.
 #dditional_closure_functions_to_update = []
 #f cached_properties:
 #lass_annotations = _get_annotations(self._cls)
 #or name, func in cached_properties.items():
                # Add cached properties to names for slotting.
 #ames += (name,)
                # Clear out function from class to avoid clashing.
 #el cd[name]
 #dditional_closure_functions_to_update.append(func)
 #nnotation = inspect.signature(func).return_annotation
 #f annotation is not inspect.Parameter.empty:
 #lass_annotations[name] = annotation

 #riginal_getattr = cd.get("__getattr__")
 #f original_getattr is not None:
 #dditional_closure_functions_to_update.append(original_getattr)

 #d["__getattr__"] = _make_cached_property_getattr(
 #ached_properties, original_getattr, self._cls
 #

        # We only add the names of attributes that aren't inherited.
        # Setting __slots__ to inherited attributes wastes memory.
 #lot_names = [name for name in names if name not in base_names]

        # There are slots for attributes from current class
        # that are defined in parent classes.
        # As their descriptors may be overridden by a child class,
        # we collect them here and update the class dict
 #eused_slots = {
 #lot: slot_descriptor
 #or slot, slot_descriptor in existing_slots.items()
 #f slot in slot_names
 #
 #lot_names = [name for name in slot_names if name not in reused_slots]
 #d.update(reused_slots)
 #f self._cache_hash:
 #lot_names.append(_HASH_CACHE_FIELD)

 #d["__slots__"] = tuple(slot_names)

 #d["__qualname__"] = self._cls.__qualname__

        # Create new class based on old class and our methods.
 #ls = type(self._cls)(self._cls.__name__, self._cls.__bases__, cd)

        # The following is a fix for
        # <https://github.com/python-attrs/attrs/issues/102>.
        # If a method mentions `__class__` or uses the no-arg super(), the
        # compiler will bake a reference to the class in the method itself
        # as `method.__closure__`.  Since we replace the class with a
        # clone, we rewrite these references so it keeps working.
 #or item in itertools.chain(
 #ls.__dict__.values(), additional_closure_functions_to_update
 #:
 #f isinstance(item, (classmethod, staticmethod)):
                # Class- and staticmethods hide their functions inside.
                # These might need to be rewritten as well.
 #losure_cells = getattr(item.__func__, "__closure__", None)
 #lif isinstance(item, property):
                # Workaround for property `super()` shortcut (PY3-only).
                # There is no universal way for other descriptors.
 #losure_cells = getattr(item.fget, "__closure__", None)
 #lse:
 #losure_cells = getattr(item, "__closure__", None)

 #f not closure_cells:  # Catch None or the empty list.
 #ontinue
 #or cell in closure_cells:
 #ry:
 #atch = cell.cell_contents is self._cls
 #xcept ValueError:  # noqa: PERF203
                    # ValueError: Cell is empty
 #ass
 #lse:
 #f match:
 #ell.cell_contents = cls
 #eturn cls

 #ef add_repr(self, ns):
 #cript, globs = _make_repr_script(self._attrs, ns)

 #ef _attach_repr(cls_dict, globs):
 #ls_dict["__repr__"] = self._add_method_dunders(globs["__repr__"])

 #elf._script_snippets.append((script, globs, _attach_repr))
 #elf._repr_added = True
 #eturn self

 #ef add_str(self):
 #f not self._repr_added:
 #sg = "__str__ can only be generated if a __repr__ exists."
 #aise ValueError(msg)

 #ef __str__(self):
 #eturn self.__repr__()

 #elf._cls_dict["__str__"] = self._add_method_dunders(__str__)
 #eturn self

 #ef _make_getstate_setstate(self):
 #""
 #reate custom __setstate__ and __getstate__ methods.
 #""
        # __weakref__ is not writable.
 #tate_attr_names = tuple(
 #n for an in self._attr_names if an != "__weakref__"
 #

 #ef slots_getstate(self):
 #""
 #utomatically created by attrs.
 #""
 #eturn {name: getattr(self, name) for name in state_attr_names}

 #ash_caching_enabled = self._cache_hash

 #ef slots_setstate(self, state):
 #""
 #utomatically created by attrs.
 #""
 #_bound_setattr = _OBJ_SETATTR.__get__(self)
 #f isinstance(state, tuple):
                # Backward compatibility with attrs instances pickled with
                # attrs versions before v22.2.0 which stored tuples.
 #or name, value in zip(state_attr_names, state):
 #_bound_setattr(name, value)
 #lse:
 #or name in state_attr_names:
 #f name in state:
 #_bound_setattr(name, state[name])

            # The hash code cache is not included when the object is
            # serialized, but it still needs to be initialized to None to
            # indicate that the first call to __hash__ should be a cache
            # miss.
 #f hash_caching_enabled:
 #_bound_setattr(_HASH_CACHE_FIELD, None)

 #eturn slots_getstate, slots_setstate

 #ef make_unhashable(self):
 #elf._cls_dict["__hash__"] = None
 #eturn self

 #ef add_hash(self):
 #cript, globs = _make_hash_script(
 #elf._cls,
 #elf._attrs,
 #rozen=self._frozen,
 #ache_hash=self._cache_hash,
 #

 #ef attach_hash(cls_dict: dict, locs: dict) -> None:
 #ls_dict["__hash__"] = self._add_method_dunders(locs["__hash__"])

 #elf._script_snippets.append((script, globs, attach_hash))

 #eturn self

 #ef add_init(self):
 #cript, globs, annotations = _make_init_script(
 #elf._cls,
 #elf._attrs,
 #elf._has_pre_init,
 #elf._pre_init_has_args,
 #elf._has_post_init,
 #elf._frozen,
 #elf._slots,
 #elf._cache_hash,
 #elf._base_attr_map,
 #elf._is_exc,
 #elf._on_setattr,
 #ttrs_init=False,
 #

 #ef _attach_init(cls_dict, globs):
 #nit = globs["__init__"]
 #nit.__annotations__ = annotations
 #ls_dict["__init__"] = self._add_method_dunders(init)

 #elf._script_snippets.append((script, globs, _attach_init))

 #eturn self

 #ef add_replace(self):
 #elf._cls_dict["__replace__"] = self._add_method_dunders(
 #ambda self, **changes: evolve(self, **changes)
 #
 #eturn self

 #ef add_match_args(self):
 #elf._cls_dict["__match_args__"] = tuple(
 #ield.name
 #or field in self._attrs
 #f field.init and not field.kw_only
 #

 #ef add_attrs_init(self):
 #cript, globs, annotations = _make_init_script(
 #elf._cls,
 #elf._attrs,
 #elf._has_pre_init,
 #elf._pre_init_has_args,
 #elf._has_post_init,
 #elf._frozen,
 #elf._slots,
 #elf._cache_hash,
 #elf._base_attr_map,
 #elf._is_exc,
 #elf._on_setattr,
 #ttrs_init=True,
 #

 #ef _attach_attrs_init(cls_dict, globs):
 #nit = globs["__attrs_init__"]
 #nit.__annotations__ = annotations
 #ls_dict["__attrs_init__"] = self._add_method_dunders(init)

 #elf._script_snippets.append((script, globs, _attach_attrs_init))

 #eturn self

 #ef add_eq(self):
 #d = self._cls_dict

 #cript, globs = _make_eq_script(self._attrs)

 #ef _attach_eq(cls_dict, globs):
 #ls_dict["__eq__"] = self._add_method_dunders(globs["__eq__"])

 #elf._script_snippets.append((script, globs, _attach_eq))

 #d["__ne__"] = __ne__

 #eturn self

 #ef add_order(self):
 #d = self._cls_dict

 #d["__lt__"], cd["__le__"], cd["__gt__"], cd["__ge__"] = (
 #elf._add_method_dunders(meth)
 #or meth in _make_order(self._cls, self._attrs)
 #

 #eturn self

 #ef add_setattr(self):
 #a_attrs = {}
 #or a in self._attrs:
 #n_setattr = a.on_setattr or self._on_setattr
 #f on_setattr and on_setattr is not setters.NO_OP:
 #a_attrs[a.name] = a, on_setattr

 #f not sa_attrs:
 #eturn self

 #f self._has_custom_setattr:
            # We need to write a __setattr__ but there already is one!
 #sg = "Can't combine custom __setattr__ with on_setattr hooks."
 #aise ValueError(msg)

        # docstring comes from _add_method_dunders
 #ef __setattr__(self, name, val):
 #ry:
 #, hook = sa_attrs[name]
 #xcept KeyError:
 #val = val
 #lse:
 #val = hook(self, a, val)

 #OBJ_SETATTR(self, name, nval)

 #elf._cls_dict["__attrs_own_setattr__"] = True
 #elf._cls_dict["__setattr__"] = self._add_method_dunders(__setattr__)
 #elf._wrote_own_setattr = True

 #eturn self

 #ef _add_method_dunders_unsafe(self, method: Callable) -> Callable:
 #""
 #dd __module__ and __qualname__ to a *method*.
 #""
 #ethod.__module__ = self._cls.__module__

 #ethod.__qualname__ = f"{self._cls.__qualname__}.{method.__name__}"

 #ethod.__doc__ = (
 #"Method generated by attrs for class {self._cls.__qualname__}."
 #

 #eturn method

 #ef _add_method_dunders_safe(self, method: Callable) -> Callable:
 #""
 #dd __module__ and __qualname__ to a *method* if possible.
 #""
 #ith contextlib.suppress(AttributeError):
 #ethod.__module__ = self._cls.__module__

 #ith contextlib.suppress(AttributeError):
 #ethod.__qualname__ = f"{self._cls.__qualname__}.{method.__name__}"

 #ith contextlib.suppress(AttributeError):
 #ethod.__doc__ = f"Method generated by attrs for class {self._cls.__qualname__}."

 #eturn method


def _determine_attrs_eq_order(cmp, eq, order, default_eq):
 #""
 #alidate the combination of *cmp*, *eq*, and *order*. Derive the effective
 #alues of eq and order.  If *eq* is None, set it to *default_eq*.
 #""
 #f cmp is not None and any((eq is not None, order is not None)):
 #sg = "Don't mix `cmp` with `eq' and `order`."
 #aise ValueError(msg)

    # cmp takes precedence due to bw-compatibility.
 #f cmp is not None:
 #eturn cmp, cmp

    # If left None, equality is set to the specified default and ordering
    # mirrors equality.
 #f eq is None:
 #q = default_eq

 #f order is None:
 #rder = eq

 #f eq is False and order is True:
 #sg = "`order` can only be True if `eq` is True too."
 #aise ValueError(msg)

 #eturn eq, order


def _determine_attrib_eq_order(cmp, eq, order, default_eq):
 #""
 #alidate the combination of *cmp*, *eq*, and *order*. Derive the effective
 #alues of eq and order.  If *eq* is None, set it to *default_eq*.
 #""
 #f cmp is not None and any((eq is not None, order is not None)):
 #sg = "Don't mix `cmp` with `eq' and `order`."
 #aise ValueError(msg)

 #ef decide_callable_or_boolean(value):
 #""
 #ecide whether a key function is used.
 #""
 #f callable(value):
 #alue, key = True, value
 #lse:
 #ey = None
 #eturn value, key

    # cmp takes precedence due to bw-compatibility.
 #f cmp is not None:
 #mp, cmp_key = decide_callable_or_boolean(cmp)
 #eturn cmp, cmp_key, cmp, cmp_key

    # If left None, equality is set to the specified default and ordering
    # mirrors equality.
 #f eq is None:
 #q, eq_key = default_eq, None
 #lse:
 #q, eq_key = decide_callable_or_boolean(eq)

 #f order is None:
 #rder, order_key = eq, eq_key
 #lse:
 #rder, order_key = decide_callable_or_boolean(order)

 #f eq is False and order is True:
 #sg = "`order` can only be True if `eq` is True too."
 #aise ValueError(msg)

 #eturn eq, eq_key, order, order_key


def _determine_whether_to_implement(
 #ls, flag, auto_detect, dunders, default=True
):
 #""
 #heck whether we should implement a set of methods for *cls*.

 #flag* is the argument passed into @attr.s like 'init', *auto_detect* the
 #ame as passed into @attr.s and *dunders* is a tuple of attribute names
 #hose presence signal that the user has implemented it themselves.

 #eturn *default* if no reason for either for or against is found.
 #""
 #f flag is True or flag is False:
 #eturn flag

 #f flag is None and auto_detect is False:
 #eturn default

    # Logically, flag is None and auto_detect is True here.
 #or dunder in dunders:
 #f _has_own_attribute(cls, dunder):
 #eturn False

 #eturn default


def attrs(
 #aybe_cls=None,
 #hese=None,
 #epr_ns=None,
 #epr=None,
 #mp=None,
 #ash=None,
 #nit=None,
 #lots=False,
 #rozen=False,
 #eakref_slot=True,
 #tr=False,
 #uto_attribs=False,
 #w_only=False,
 #ache_hash=False,
 #uto_exc=False,
 #q=None,
 #rder=None,
 #uto_detect=False,
 #ollect_by_mro=False,
 #etstate_setstate=None,
 #n_setattr=None,
 #ield_transformer=None,
 #atch_args=True,
 #nsafe_hash=None,
 #orce_kw_only=True,
):
 #"""
 # class decorator that adds :term:`dunder methods` according to the
 #pecified attributes using `attr.ib` or the *these* argument.

 #onsider using `attrs.define` / `attrs.frozen` in new code (``attr.s`` will
 #never* go away, though).

 #rgs:
 #epr_ns (str):
 #hen using nested classes, there was no way in Python 2 to
 #utomatically detect that.  This argument allows to set a custom
 #ame for a more meaningful ``repr`` output.  This argument is
 #ointless in Python 3 and is therefore deprecated.

 #. caution::
 #efer to `attrs.define` for the rest of the parameters, but note that they
 #an have different defaults.

 #otably, leaving *on_setattr* as `None` will **not** add any hooks.

 #. versionadded:: 16.0.0 *slots*
 #. versionadded:: 16.1.0 *frozen*
 #. versionadded:: 16.3.0 *str*
 #. versionadded:: 16.3.0 Support for ``__attrs_post_init__``.
 #. versionchanged:: 17.1.0
 #hash* supports `None` as value which is also the default now.
 #. versionadded:: 17.3.0 *auto_attribs*
 #. versionchanged:: 18.1.0
 #f *these* is passed, no attributes are deleted from the class body.
 #. versionchanged:: 18.1.0 If *these* is ordered, the order is retained.
 #. versionadded:: 18.2.0 *weakref_slot*
 #. deprecated:: 18.2.0
 #`__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a
 #DeprecationWarning` if the classes compared are subclasses of
 #ach other. ``__eq`` and ``__ne__`` never tried to compared subclasses
 #o each other.
 #. versionchanged:: 19.2.0
 #`__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider
 #ubclasses comparable anymore.
 #. versionadded:: 18.2.0 *kw_only*
 #. versionadded:: 18.2.0 *cache_hash*
 #. versionadded:: 19.1.0 *auto_exc*
 #. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.
 #. versionadded:: 19.2.0 *eq* and *order*
 #. versionadded:: 20.1.0 *auto_detect*
 #. versionadded:: 20.1.0 *collect_by_mro*
 #. versionadded:: 20.1.0 *getstate_setstate*
 #. versionadded:: 20.1.0 *on_setattr*
 #. versionadded:: 20.3.0 *field_transformer*
 #. versionchanged:: 21.1.0
 #`init=False`` injects ``__attrs_init__``
 #. versionchanged:: 21.1.0 Support for ``__attrs_pre_init__``
 #. versionchanged:: 21.1.0 *cmp* undeprecated
 #. versionadded:: 21.3.0 *match_args*
 #. versionadded:: 22.2.0
 #unsafe_hash* as an alias for *hash* (for :pep:`681` compliance).
 #. deprecated:: 24.1.0 *repr_ns*
 #. versionchanged:: 24.1.0
 #nstances are not compared as tuples of attributes anymore, but using a
 #ig ``and`` condition. This is faster and has more correct behavior for
 #ncomparable values like `math.nan`.
 #. versionadded:: 24.1.0
 #f a class has an *inherited* classmethod called
 #`__attrs_init_subclass__``, it is executed after the class is created.
 #. deprecated:: 24.1.0 *hash* is deprecated in favor of *unsafe_hash*.
 #. versionchanged:: 25.4.0
 #kw_only* now only applies to attributes defined in the current class,
 #nd respects attribute-level ``kw_only=False`` settings.
 #. versionadded:: 25.4.0 *force_kw_only*
 #""
 #f repr_ns is not None:
 #mport warnings

 #arnings.warn(
 #eprecationWarning(
 #The `repr_ns` argument is deprecated and will be removed in or after August 2025."
 #,
 #tacklevel=2,
 #

 #q_, order_ = _determine_attrs_eq_order(cmp, eq, order, None)

    #  unsafe_hash takes precedence due to PEP 681.
 #f unsafe_hash is not None:
 #ash = unsafe_hash

 #f isinstance(on_setattr, (list, tuple)):
 #n_setattr = setters.pipe(*on_setattr)

 #ef wrap(cls):
 #onlocal hash
 #s_frozen = frozen or _has_frozen_base_class(cls)
 #s_exc = auto_exc is True and issubclass(cls, BaseException)
 #as_own_setattr = auto_detect and _has_own_attribute(
 #ls, "__setattr__"
 #

 #f has_own_setattr and is_frozen:
 #sg = "Can't freeze a class with a custom __setattr__."
 #aise ValueError(msg)

 #q = not is_exc and _determine_whether_to_implement(
 #ls, eq_, auto_detect, ("__eq__", "__ne__")
 #

 #ashability = ClassProps.Hashability

 #f is_exc:
 #ashability = Hashability.LEAVE_ALONE
 #lif hash is True:
 #ashability = (
 #ashability.HASHABLE_CACHED
 #f cache_hash
 #lse Hashability.HASHABLE
 #
 #lif hash is False:
 #ashability = Hashability.LEAVE_ALONE
 #lif hash is None:
 #f auto_detect is True and _has_own_attribute(cls, "__hash__"):
 #ashability = Hashability.LEAVE_ALONE
 #lif eq is True and is_frozen is True:
 #ashability = (
 #ashability.HASHABLE_CACHED
 #f cache_hash
 #lse Hashability.HASHABLE
 #
 #lif eq is False:
 #ashability = Hashability.LEAVE_ALONE
 #lse:
 #ashability = Hashability.UNHASHABLE
 #lse:
 #sg = "Invalid value for hash.  Must be True, False, or None."
 #aise TypeError(msg)

 #eywordOnly = ClassProps.KeywordOnly
 #f kw_only:
 #wo = KeywordOnly.FORCE if force_kw_only else KeywordOnly.YES
 #lse:
 #wo = KeywordOnly.NO

 #rops = ClassProps(
 #s_exception=is_exc,
 #s_frozen=is_frozen,
 #s_slotted=slots,
 #ollected_fields_by_mro=collect_by_mro,
 #dded_init=_determine_whether_to_implement(
 #ls, init, auto_detect, ("__init__",)
 #,
 #dded_repr=_determine_whether_to_implement(
 #ls, repr, auto_detect, ("__repr__",)
 #,
 #dded_eq=eq,
 #dded_ordering=not is_exc
 #nd _determine_whether_to_implement(
 #ls,
 #rder_,
 #uto_detect,
 #"__lt__", "__le__", "__gt__", "__ge__"),
 #,
 #ashability=hashability,
 #dded_match_args=match_args,
 #w_only=kwo,
 #as_weakref_slot=weakref_slot,
 #dded_str=str,
 #dded_pickling=_determine_whether_to_implement(
 #ls,
 #etstate_setstate,
 #uto_detect,
 #"__getstate__", "__setstate__"),
 #efault=slots,
 #,
 #n_setattr_hook=on_setattr,
 #ield_transformer=field_transformer,
 #

 #f not props.is_hashable and cache_hash:
 #sg = "Invalid value for cache_hash.  To use hash caching, hashing must be either explicitly or implicitly enabled."
 #aise TypeError(msg)

 #uilder = _ClassBuilder(
 #ls,
 #hese,
 #uto_attribs=auto_attribs,
 #rops=props,
 #as_custom_setattr=has_own_setattr,
 #

 #f props.added_repr:
 #uilder.add_repr(repr_ns)

 #f props.added_str:
 #uilder.add_str()

 #f props.added_eq:
 #uilder.add_eq()
 #f props.added_ordering:
 #uilder.add_order()

 #f not frozen:
 #uilder.add_setattr()

 #f props.is_hashable:
 #uilder.add_hash()
 #lif props.hashability is Hashability.UNHASHABLE:
 #uilder.make_unhashable()

 #f props.added_init:
 #uilder.add_init()
 #lse:
 #uilder.add_attrs_init()
 #f cache_hash:
 #sg = "Invalid value for cache_hash.  To use hash caching, init must be True."
 #aise TypeError(msg)

 #f PY_3_13_PLUS and not _has_own_attribute(cls, "__replace__"):
 #uilder.add_replace()

 #f (
 #Y_3_10_PLUS
 #nd match_args
 #nd not _has_own_attribute(cls, "__match_args__")
 #:
 #uilder.add_match_args()

 #eturn builder.build_class()

    # maybe_cls's type depends on the usage of the decorator.  It's a class
    # if it's used as `@attrs` but `None` if used as `@attrs()`.
 #f maybe_cls is None:
 #eturn wrap

 #eturn wrap(maybe_cls)


_attrs = attrs
"""
Internal alias so we can use it in functions that take an argument called
*attrs*.
"""


def _has_frozen_base_class(cls):
 #""
 #heck whether *cls* has a frozen ancestor by looking at its
 #_setattr__.
 #""
 #eturn cls.__setattr__ is _frozen_setattrs


def _generate_unique_filename(cls: type, func_name: str) -> str:
 #""
 #reate a "filename" suitable for a function being generated.
 #""
 #eturn (
 #"<attrs generated {func_name} {cls.__module__}."
 #"{getattr(cls, '__qualname__', cls.__name__)}>"
 #


def _make_hash_script(
 #ls: type, attrs: list[Attribute], frozen: bool, cache_hash: bool
) -> tuple[str, dict]:
 #ttrs = tuple(
 # for a in attrs if a.hash is True or (a.hash is None and a.eq is True)
 #

 #ab = "        "

 #ype_hash = hash(_generate_unique_filename(cls, "hash"))
    # If eq is custom generated, we need to include the functions in globs
 #lobs = {}

 #ash_def = "def __hash__(self"
 #ash_func = "hash(("
 #losing_braces = "))"
 #f not cache_hash:
 #ash_def += "):"
 #lse:
 #ash_def += ", *"

 #ash_def += ", _cache_wrapper=__import__('attr._make')._make._CacheHashWrapper):"
 #ash_func = "_cache_wrapper(" + hash_func
 #losing_braces += ")"

 #ethod_lines = [hash_def]

 #ef append_hash_computation_lines(prefix, indent):
 #""
 #enerate the code for actually computing the hash code.
 #elow this will either be returned directly or used to compute
 # value which is then cached, depending on the value of cache_hash
 #""

 #ethod_lines.extend(
 #
 #ndent + prefix + hash_func,
 #ndent + f"        {type_hash},",
 #
 #

 #or a in attrs:
 #f a.eq_key:
 #mp_name = f"_{a.name}_key"
 #lobs[cmp_name] = a.eq_key
 #ethod_lines.append(
 #ndent + f"        {cmp_name}(self.{a.name}),"
 #
 #lse:
 #ethod_lines.append(indent + f"        self.{a.name},")

 #ethod_lines.append(indent + "    " + closing_braces)

 #f cache_hash:
 #ethod_lines.append(tab + f"if self.{_HASH_CACHE_FIELD} is None:")
 #f frozen:
 #ppend_hash_computation_lines(
 #"object.__setattr__(self, '{_HASH_CACHE_FIELD}', ", tab * 2
 #
 #ethod_lines.append(tab * 2 + ")")  # close __setattr__
 #lse:
 #ppend_hash_computation_lines(
 #"self.{_HASH_CACHE_FIELD} = ", tab * 2
 #
 #ethod_lines.append(tab + f"return self.{_HASH_CACHE_FIELD}")
 #lse:
 #ppend_hash_computation_lines("return ", tab)

 #cript = "\n".join(method_lines)
 #eturn script, globs


def _add_hash(cls: type, attrs: list[Attribute]):
 #""
 #dd a hash method to *cls*.
 #""
 #cript, globs = _make_hash_script(
 #ls, attrs, frozen=False, cache_hash=False
 #
 #compile_and_eval(
 #cript, globs, filename=_generate_unique_filename(cls, "__hash__")
 #
 #ls.__hash__ = globs["__hash__"]
 #eturn cls


def __ne__(self, other):
 #""
 #heck equality and either forward a NotImplemented or
 #eturn the result negated.
 #""
 #esult = self.__eq__(other)
 #f result is NotImplemented:
 #eturn NotImplemented

 #eturn not result


def _make_eq_script(attrs: list) -> tuple[str, dict]:
 #""
 #reate __eq__ method for *cls* with *attrs*.
 #""
 #ttrs = [a for a in attrs if a.eq]

 #ines = [
 #def __eq__(self, other):",
 #    if other.__class__ is not self.__class__:",
 #        return NotImplemented",
 #

 #lobs = {}
 #f attrs:
 #ines.append("    return  (")
 #or a in attrs:
 #f a.eq_key:
 #mp_name = f"_{a.name}_key"
                # Add the key function to the global namespace
                # of the evaluated function.
 #lobs[cmp_name] = a.eq_key
 #ines.append(
 #"        {cmp_name}(self.{a.name}) == {cmp_name}(other.{a.name})"
 #
 #lse:
 #ines.append(f"        self.{a.name} == other.{a.name}")
 #f a is not attrs[-1]:
 #ines[-1] = f"{lines[-1]} and"
 #ines.append("    )")
 #lse:
 #ines.append("    return True")

 #cript = "\n".join(lines)

 #eturn script, globs


def _make_order(cls, attrs):
 #""
 #reate ordering methods for *cls* with *attrs*.
 #""
 #ttrs = [a for a in attrs if a.order]

 #ef attrs_to_tuple(obj):
 #""
 #ave us some typing.
 #""
 #eturn tuple(
 #ey(value) if key else value
 #or value, key in (
 #getattr(obj, a.name), a.order_key) for a in attrs
 #
 #

 #ef __lt__(self, other):
 #""
 #utomatically created by attrs.
 #""
 #f other.__class__ is self.__class__:
 #eturn attrs_to_tuple(self) < attrs_to_tuple(other)

 #eturn NotImplemented

 #ef __le__(self, other):
 #""
 #utomatically created by attrs.
 #""
 #f other.__class__ is self.__class__:
 #eturn attrs_to_tuple(self) <= attrs_to_tuple(other)

 #eturn NotImplemented

 #ef __gt__(self, other):
 #""
 #utomatically created by attrs.
 #""
 #f other.__class__ is self.__class__:
 #eturn attrs_to_tuple(self) > attrs_to_tuple(other)

 #eturn NotImplemented

 #ef __ge__(self, other):
 #""
 #utomatically created by attrs.
 #""
 #f other.__class__ is self.__class__:
 #eturn attrs_to_tuple(self) >= attrs_to_tuple(other)

 #eturn NotImplemented

 #eturn __lt__, __le__, __gt__, __ge__


def _add_eq(cls, attrs=None):
 #""
 #dd equality methods to *cls* with *attrs*.
 #""
 #f attrs is None:
 #ttrs = cls.__attrs_attrs__

 #cript, globs = _make_eq_script(attrs)
 #compile_and_eval(
 #cript, globs, filename=_generate_unique_filename(cls, "__eq__")
 #
 #ls.__eq__ = globs["__eq__"]
 #ls.__ne__ = __ne__

 #eturn cls


def _make_repr_script(attrs, ns) -> tuple[str, dict]:
 #""
 #reate the source and globs for a __repr__ and return it.
 #""
    # Figure out which attributes to include, and which function to use to
    # format them. The a.repr value can be either bool or a custom
    # callable.
 #ttr_names_with_reprs = tuple(
 #a.name, (repr if a.repr is True else a.repr), a.init)
 #or a in attrs
 #f a.repr is not False
 #
 #lobs = {
 #ame + "_repr": r for name, r, _ in attr_names_with_reprs if r != repr
 #
 #lobs["_compat"] = _compat
 #lobs["AttributeError"] = AttributeError
 #lobs["NOTHING"] = NOTHING
 #ttribute_fragments = []
 #or name, r, i in attr_names_with_reprs:
 #ccessor = (
 #self." + name if i else 'getattr(self, "' + name + '", NOTHING)'
 #
 #ragment = (
 #%s={%s!r}" % (name, accessor)
 #f r == repr
 #lse "%s={%s_repr(%s)}" % (name, name, accessor)
 #
 #ttribute_fragments.append(fragment)
 #epr_fragment = ", ".join(attribute_fragments)

 #f ns is None:
 #ls_name_fragment = '{self.__class__.__qualname__.rsplit(">.", 1)[-1]}'
 #lse:
 #ls_name_fragment = ns + ".{self.__class__.__name__}"

 #ines = [
 #def __repr__(self):",
 #  try:",
 #    already_repring = _compat.repr_context.already_repring",
 #  except AttributeError:",
 #    already_repring = {id(self),}",
 #    _compat.repr_context.already_repring = already_repring",
 #  else:",
 #    if id(self) in already_repring:",
 #      return '...'",
 #    else:",
 #      already_repring.add(id(self))",
 #  try:",
 #"    return f'{cls_name_fragment}({repr_fragment})'",
 #  finally:",
 #    already_repring.remove(id(self))",
 #

 #eturn "\n".join(lines), globs


def _add_repr(cls, ns=None, attrs=None):
 #""
 #dd a repr method to *cls*.
 #""
 #f attrs is None:
 #ttrs = cls.__attrs_attrs__

 #cript, globs = _make_repr_script(attrs, ns)
 #compile_and_eval(
 #cript, globs, filename=_generate_unique_filename(cls, "__repr__")
 #
 #ls.__repr__ = globs["__repr__"]
 #eturn cls


def fields(cls):
 #""
 #eturn the tuple of *attrs* attributes for a class.

 #he tuple also allows accessing the fields by their names (see below for
 #xamples).

 #rgs:
 #ls (type): Class to introspect.

 #aises:
 #ypeError: If *cls* is not a class.

 #ttrs.exceptions.NotAnAttrsClassError:
 #f *cls* is not an *attrs* class.

 #eturns:
 #uple (with name accessors) of `attrs.Attribute`

 #. versionchanged:: 16.2.0 Returned tuple allows accessing the fields
 #y name.
 #. versionchanged:: 23.1.0 Add support for generic classes.
 #""
 #eneric_base = get_generic_base(cls)

 #f generic_base is None and not isinstance(cls, type):
 #sg = "Passed object must be a class."
 #aise TypeError(msg)

 #ttrs = getattr(cls, "__attrs_attrs__", None)

 #f attrs is None:
 #f generic_base is not None:
 #ttrs = getattr(generic_base, "__attrs_attrs__", None)
 #f attrs is not None:
                # Even though this is global state, stick it on here to speed
                # it up. We rely on `cls` being cached for this to be
                # efficient.
 #ls.__attrs_attrs__ = attrs
 #eturn attrs
 #sg = f"{cls!r} is not an attrs-decorated class."
 #aise NotAnAttrsClassError(msg)

 #eturn attrs


def fields_dict(cls):
 #""
 #eturn an ordered dictionary of *attrs* attributes for a class, whose keys
 #re the attribute names.

 #rgs:
 #ls (type): Class to introspect.

 #aises:
 #ypeError: If *cls* is not a class.

 #ttrs.exceptions.NotAnAttrsClassError:
 #f *cls* is not an *attrs* class.

 #eturns:
 #ict[str, attrs.Attribute]: Dict of attribute name to definition

 #. versionadded:: 18.1.0
 #""
 #f not isinstance(cls, type):
 #sg = "Passed object must be a class."
 #aise TypeError(msg)
 #ttrs = getattr(cls, "__attrs_attrs__", None)
 #f attrs is None:
 #sg = f"{cls!r} is not an attrs-decorated class."
 #aise NotAnAttrsClassError(msg)
 #eturn {a.name: a for a in attrs}


def validate(inst):
 #""
 #alidate all attributes on *inst* that have a validator.

 #eaves all exceptions through.

 #rgs:
 #nst: Instance of a class with *attrs* attributes.
 #""
 #f _config._run_validators is False:
 #eturn

 #or a in fields(inst.__class__):
 # = a.validator
 #f v is not None:
 #(inst, a, getattr(inst, a.name))


def _is_slot_attr(a_name, base_attr_map):
 #""
 #heck if the attribute name comes from a slot class.
 #""
 #ls = base_attr_map.get(a_name)
 #eturn cls and "__slots__" in cls.__dict__


def _make_init_script(
 #ls,
 #ttrs,
 #re_init,
 #re_init_has_args,
 #ost_init,
 #rozen,
 #lots,
 #ache_hash,
 #ase_attr_map,
 #s_exc,
 #ls_on_setattr,
 #ttrs_init,
) -> tuple[str, dict, dict]:
 #as_cls_on_setattr = (
 #ls_on_setattr is not None and cls_on_setattr is not setters.NO_OP
 #

 #f frozen and has_cls_on_setattr:
 #sg = "Frozen classes can't use on_setattr."
 #aise ValueError(msg)

 #eeds_cached_setattr = cache_hash or frozen
 #iltered_attrs = []
 #ttr_dict = {}
 #or a in attrs:
 #f not a.init and a.default is NOTHING:
 #ontinue

 #iltered_attrs.append(a)
 #ttr_dict[a.name] = a

 #f a.on_setattr is not None:
 #f frozen is True:
 #sg = "Frozen classes can't use on_setattr."
 #aise ValueError(msg)

 #eeds_cached_setattr = True
 #lif has_cls_on_setattr and a.on_setattr is not setters.NO_OP:
 #eeds_cached_setattr = True

 #cript, globs, annotations = _attrs_to_init_script(
 #iltered_attrs,
 #rozen,
 #lots,
 #re_init,
 #re_init_has_args,
 #ost_init,
 #ache_hash,
 #ase_attr_map,
 #s_exc,
 #eeds_cached_setattr,
 #as_cls_on_setattr,
 #__attrs_init__" if attrs_init else "__init__",
 #
 #f cls.__module__ in sys.modules:
        # This makes typing.get_type_hints(CLS.__init__) resolve string types.
 #lobs.update(sys.modules[cls.__module__].__dict__)

 #lobs.update({"NOTHING": NOTHING, "attr_dict": attr_dict})

 #f needs_cached_setattr:
        # Save the lookup overhead in __init__ if we need to circumvent
        # setattr hooks.
 #lobs["_cached_setattr_get"] = _OBJ_SETATTR.__get__

 #eturn script, globs, annotations


def _setattr(attr_name: str, value_var: str, has_on_setattr: bool) -> str:
 #""
 #se the cached object.setattr to set *attr_name* to *value_var*.
 #""
 #eturn f"_setattr('{attr_name}', {value_var})"


def _setattr_with_converter(
 #ttr_name: str, value_var: str, has_on_setattr: bool, converter: Converter
) -> str:
 #""
 #se the cached object.setattr to set *attr_name* to *value_var*, but run
 #ts converter first.
 #""
 #eturn f"_setattr('{attr_name}', {converter._fmt_converter_call(attr_name, value_var)})"


def _assign(attr_name: str, value: str, has_on_setattr: bool) -> str:
 #""
 #nless *attr_name* has an on_setattr hook, use normal assignment. Otherwise
 #elegate to _setattr.
 #""
 #f has_on_setattr:
 #eturn _setattr(attr_name, value, True)

 #eturn f"self.{attr_name} = {value}"


def _assign_with_converter(
 #ttr_name: str, value_var: str, has_on_setattr: bool, converter: Converter
) -> str:
 #""
 #nless *attr_name* has an on_setattr hook, use normal assignment after
 #onversion. Otherwise relegate to _setattr_with_converter.
 #""
 #f has_on_setattr:
 #eturn _setattr_with_converter(attr_name, value_var, True, converter)

 #eturn f"self.{attr_name} = {converter._fmt_converter_call(attr_name, value_var)}"


def _determine_setters(
 #rozen: bool, slots: bool, base_attr_map: dict[str, type]
):
 #""
 #etermine the correct setter functions based on whether a class is frozen
 #nd/or slotted.
 #""
 #f frozen is True:
 #f slots is True:
 #eturn (), _setattr, _setattr_with_converter

        # Dict frozen classes assign directly to __dict__.
        # But only if the attribute doesn't come from an ancestor slot
        # class.
        # Note _inst_dict will be used again below if cache_hash is True

 #ef fmt_setter(
 #ttr_name: str, value_var: str, has_on_setattr: bool
 # -> str:
 #f _is_slot_attr(attr_name, base_attr_map):
 #eturn _setattr(attr_name, value_var, has_on_setattr)

 #eturn f"_inst_dict['{attr_name}'] = {value_var}"

 #ef fmt_setter_with_converter(
 #ttr_name: str,
 #alue_var: str,
 #as_on_setattr: bool,
 #onverter: Converter,
 # -> str:
 #f has_on_setattr or _is_slot_attr(attr_name, base_attr_map):
 #eturn _setattr_with_converter(
 #ttr_name, value_var, has_on_setattr, converter
 #

 #eturn f"_inst_dict['{attr_name}'] = {converter._fmt_converter_call(attr_name, value_var)}"

 #eturn (
 #"_inst_dict = self.__dict__",),
 #mt_setter,
 #mt_setter_with_converter,
 #

    # Not frozen -- we can just assign directly.
 #eturn (), _assign, _assign_with_converter


def _attrs_to_init_script(
 #ttrs: list[Attribute],
 #s_frozen: bool,
 #s_slotted: bool,
 #all_pre_init: bool,
 #re_init_has_args: bool,
 #all_post_init: bool,
 #oes_cache_hash: bool,
 #ase_attr_map: dict[str, type],
 #s_exc: bool,
 #eeds_cached_setattr: bool,
 #as_cls_on_setattr: bool,
 #ethod_name: str,
) -> tuple[str, dict, dict]:
 #""
 #eturn a script of an initializer for *attrs*, a dict of globals, and
 #nnotations for the initializer.

 #he globals are required by the generated script.
 #""
 #ines = ["self.__attrs_pre_init__()"] if call_pre_init else []

 #f needs_cached_setattr:
 #ines.append(
            # Circumvent the __setattr__ descriptor to save one lookup per
            # assignment. Note _setattr will be used again below if
            # does_cache_hash is True.
 #_setattr = _cached_setattr_get(self)"
 #

 #xtra_lines, fmt_setter, fmt_setter_with_converter = _determine_setters(
 #s_frozen, is_slotted, base_attr_map
 #
 #ines.extend(extra_lines)

 #rgs = []  # Parameters in the definition of __init__
 #re_init_args = []  # Parameters in the call to __attrs_pre_init__
 #w_only_args = []  # Used for both 'args' and 'pre_init_args' above
 #ttrs_to_validate = []

    # This is a dictionary of names to validator and converter callables.
    # Injecting this into __init__ globals lets us avoid lookups.
 #ames_for_globals = {}
 #nnotations = {"return": None}

 #or a in attrs:
 #f a.validator:
 #ttrs_to_validate.append(a)

 #ttr_name = a.name
 #as_on_setattr = a.on_setattr is not None or (
 #.on_setattr is not setters.NO_OP and has_cls_on_setattr
 #
        # a.alias is set to maybe-mangled attr_name in _ClassBuilder if not
        # explicitly provided
 #rg_name = a.alias

 #as_factory = isinstance(a.default, Factory)
 #aybe_self = "self" if has_factory and a.default.takes_self else ""

 #f a.converter is not None and not isinstance(a.converter, Converter):
 #onverter = Converter(a.converter)
 #lse:
 #onverter = a.converter

 #f a.init is False:
 #f has_factory:
 #nit_factory_name = _INIT_FACTORY_PAT % (a.name,)
 #f converter is not None:
 #ines.append(
 #mt_setter_with_converter(
 #ttr_name,
 #nit_factory_name + f"({maybe_self})",
 #as_on_setattr,
 #onverter,
 #
 #
 #ames_for_globals[converter._get_global_name(a.name)] = (
 #onverter.converter
 #
 #lse:
 #ines.append(
 #mt_setter(
 #ttr_name,
 #nit_factory_name + f"({maybe_self})",
 #as_on_setattr,
 #
 #
 #ames_for_globals[init_factory_name] = a.default.factory
 #lif converter is not None:
 #ines.append(
 #mt_setter_with_converter(
 #ttr_name,
 #"attr_dict['{attr_name}'].default",
 #as_on_setattr,
 #onverter,
 #
 #
 #ames_for_globals[converter._get_global_name(a.name)] = (
 #onverter.converter
 #
 #lse:
 #ines.append(
 #mt_setter(
 #ttr_name,
 #"attr_dict['{attr_name}'].default",
 #as_on_setattr,
 #
 #
 #lif a.default is not NOTHING and not has_factory:
 #rg = f"{arg_name}=attr_dict['{attr_name}'].default"
 #f a.kw_only:
 #w_only_args.append(arg)
 #lse:
 #rgs.append(arg)
 #re_init_args.append(arg_name)

 #f converter is not None:
 #ines.append(
 #mt_setter_with_converter(
 #ttr_name, arg_name, has_on_setattr, converter
 #
 #
 #ames_for_globals[converter._get_global_name(a.name)] = (
 #onverter.converter
 #
 #lse:
 #ines.append(fmt_setter(attr_name, arg_name, has_on_setattr))

 #lif has_factory:
 #rg = f"{arg_name}=NOTHING"
 #f a.kw_only:
 #w_only_args.append(arg)
 #lse:
 #rgs.append(arg)
 #re_init_args.append(arg_name)
 #ines.append(f"if {arg_name} is not NOTHING:")

 #nit_factory_name = _INIT_FACTORY_PAT % (a.name,)
 #f converter is not None:
 #ines.append(
 #    "
 # fmt_setter_with_converter(
 #ttr_name, arg_name, has_on_setattr, converter
 #
 #
 #ines.append("else:")
 #ines.append(
 #    "
 # fmt_setter_with_converter(
 #ttr_name,
 #nit_factory_name + "(" + maybe_self + ")",
 #as_on_setattr,
 #onverter,
 #
 #
 #ames_for_globals[converter._get_global_name(a.name)] = (
 #onverter.converter
 #
 #lse:
 #ines.append(
 #    " + fmt_setter(attr_name, arg_name, has_on_setattr)
 #
 #ines.append("else:")
 #ines.append(
 #    "
 # fmt_setter(
 #ttr_name,
 #nit_factory_name + "(" + maybe_self + ")",
 #as_on_setattr,
 #
 #
 #ames_for_globals[init_factory_name] = a.default.factory
 #lse:
 #f a.kw_only:
 #w_only_args.append(arg_name)
 #lse:
 #rgs.append(arg_name)
 #re_init_args.append(arg_name)

 #f converter is not None:
 #ines.append(
 #mt_setter_with_converter(
 #ttr_name, arg_name, has_on_setattr, converter
 #
 #
 #ames_for_globals[converter._get_global_name(a.name)] = (
 #onverter.converter
 #
 #lse:
 #ines.append(fmt_setter(attr_name, arg_name, has_on_setattr))

 #f a.init is True:
 #f a.type is not None and converter is None:
 #nnotations[arg_name] = a.type
 #lif converter is not None and converter._first_param_type:
                # Use the type from the converter if present.
 #nnotations[arg_name] = converter._first_param_type

 #f attrs_to_validate:  # we can skip this if there are no validators.
 #ames_for_globals["_config"] = _config
 #ines.append("if _config._run_validators is True:")
 #or a in attrs_to_validate:
 #al_name = "__attr_validator_" + a.name
 #ttr_name = "__attr_" + a.name
 #ines.append(f"    {val_name}(self, {attr_name}, self.{a.name})")
 #ames_for_globals[val_name] = a.validator
 #ames_for_globals[attr_name] = a

 #f call_post_init:
 #ines.append("self.__attrs_post_init__()")

    # Because this is set only after __attrs_post_init__ is called, a crash
    # will result if post-init tries to access the hash code.  This seemed
    # preferable to setting this beforehand, in which case alteration to field
    # values during post-init combined with post-init accessing the hash code
    # would result in silent bugs.
 #f does_cache_hash:
 #f is_frozen:
 #f is_slotted:
 #nit_hash_cache = f"_setattr('{_HASH_CACHE_FIELD}', None)"
 #lse:
 #nit_hash_cache = f"_inst_dict['{_HASH_CACHE_FIELD}'] = None"
 #lse:
 #nit_hash_cache = f"self.{_HASH_CACHE_FIELD} = None"
 #ines.append(init_hash_cache)

    # For exceptions we rely on BaseException.__init__ for proper
    # initialization.
 #f is_exc:
 #als = ",".join(f"self.{a.name}" for a in attrs if a.init)

 #ines.append(f"BaseException.__init__(self, {vals})")

 #rgs = ", ".join(args)
 #re_init_args = ", ".join(pre_init_args)
 #f kw_only_args:
        # leading comma & kw_only args
 #rgs += f"{', ' if args else ''}*, {', '.join(kw_only_args)}"
 #re_init_kw_only_args = ", ".join(
 #
 #"{kw_arg_name}={kw_arg_name}"
                # We need to remove the defaults from the kw_only_args.
 #or kw_arg_name in (kwa.split("=")[0] for kwa in kw_only_args)
 #
 #
 #re_init_args += ", " if pre_init_args else ""
 #re_init_args += pre_init_kw_only_args

 #f call_pre_init and pre_init_has_args:
        # If pre init method has arguments, pass the values given to __init__.
 #ines[0] = f"self.__attrs_pre_init__({pre_init_args})"

    # Python <3.12 doesn't allow backslashes in f-strings.
 #L = "\n    "
 #eturn (
 #"""def {method_name}(self, {args}):
 #NL.join(lines) if lines else "pass"}
""",
 #ames_for_globals,
 #nnotations,
 #


def _default_init_alias_for(name: str) -> str:
 #""
 #he default __init__ parameter name for a field.

 #his performs private-name adjustment via leading-unscore stripping,
 #nd is the default value of Attribute.alias if not provided.
 #""

 #eturn name.lstrip("_")


class Attribute:
 #""
 #Read-only* representation of an attribute.

 #. warning::

 #ou should never instantiate this class yourself.

 #he class has *all* arguments of `attr.ib` (except for ``factory`` which is
 #nly syntactic sugar for ``default=Factory(...)`` plus the following:

 # ``name`` (`str`): The name of the attribute.
 # ``alias`` (`str`): The __init__ parameter name of the attribute, after
 #ny explicit overrides and default private-attribute-name handling.
 # ``inherited`` (`bool`): Whether or not that attribute has been inherited
 #rom a base class.
 # ``eq_key`` and ``order_key`` (`typing.Callable` or `None`): The
 #allables that are used for comparing and ordering objects by this
 #ttribute, respectively. These are set by passing a callable to
 #attr.ib`'s ``eq``, ``order``, or ``cmp`` arguments. See also
 #ref:`comparison customization <custom-comparison>`.

 #nstances of this class are frequently used for introspection purposes
 #ike:

 # `fields` returns a tuple of them.
 # Validators get them passed as the first argument.
 # The :ref:`field transformer <transform-fields>` hook receives a list of
 #hem.
 # The ``alias`` property exposes the __init__ parameter name of the field,
 #ith any overrides and default private-attribute handling applied.


 #. versionadded:: 20.1.0 *inherited*
 #. versionadded:: 20.1.0 *on_setattr*
 #. versionchanged:: 20.2.0 *inherited* is not taken into account for
 #quality checks and hashing anymore.
 #. versionadded:: 21.1.0 *eq_key* and *order_key*
 #. versionadded:: 22.2.0 *alias*

 #or the full version history of the fields, see `attr.ib`.
 #""

    # These slots must NOT be reordered because we use them later for
    # instantiation.
 #_slots__ = (  # noqa: RUF023
 #name",
 #default",
 #validator",
 #repr",
 #eq",
 #eq_key",
 #order",
 #order_key",
 #hash",
 #init",
 #metadata",
 #type",
 #converter",
 #kw_only",
 #inherited",
 #on_setattr",
 #alias",
 #

 #ef __init__(
 #elf,
 #ame,
 #efault,
 #alidator,
 #epr,
 #mp,  # XXX: unused, remove along with other cmp code.
 #ash,
 #nit,
 #nherited,
 #etadata=None,
 #ype=None,
 #onverter=None,
 #w_only=False,
 #q=None,
 #q_key=None,
 #rder=None,
 #rder_key=None,
 #n_setattr=None,
 #lias=None,
 #:
 #q, eq_key, order, order_key = _determine_attrib_eq_order(
 #mp, eq_key or eq, order_key or order, True
 #

        # Cache this descriptor here to speed things up later.
 #ound_setattr = _OBJ_SETATTR.__get__(self)

        # Despite the big red warning, people *do* instantiate `Attribute`
        # themselves.
 #ound_setattr("name", name)
 #ound_setattr("default", default)
 #ound_setattr("validator", validator)
 #ound_setattr("repr", repr)
 #ound_setattr("eq", eq)
 #ound_setattr("eq_key", eq_key)
 #ound_setattr("order", order)
 #ound_setattr("order_key", order_key)
 #ound_setattr("hash", hash)
 #ound_setattr("init", init)
 #ound_setattr("converter", converter)
 #ound_setattr(
 #metadata",
 #
 #ypes.MappingProxyType(dict(metadata))  # Shallow copy
 #f metadata
 #lse _EMPTY_METADATA_SINGLETON
 #,
 #
 #ound_setattr("type", type)
 #ound_setattr("kw_only", kw_only)
 #ound_setattr("inherited", inherited)
 #ound_setattr("on_setattr", on_setattr)
 #ound_setattr("alias", alias)

 #ef __setattr__(self, name, value):
 #aise FrozenInstanceError

 #classmethod
 #ef from_counting_attr(
 #ls, name: str, ca: _CountingAttr, kw_only: bool, type=None
 #:
        # The 'kw_only' argument is the class-level setting, and is used if the
        # attribute itself does not explicitly set 'kw_only'.
        # type holds the annotated value. deal with conflicts:
 #f type is None:
 #ype = ca.type
 #lif ca.type is not None:
 #sg = f"Type annotation and type argument cannot both be present for '{name}'."
 #aise ValueError(msg)
 #eturn cls(
 #ame,
 #a._default,
 #a._validator,
 #a.repr,
 #one,
 #a.hash,
 #a.init,
 #alse,
 #a.metadata,
 #ype,
 #a.converter,
 #w_only if ca.kw_only is None else ca.kw_only,
 #a.eq,
 #a.eq_key,
 #a.order,
 #a.order_key,
 #a.on_setattr,
 #a.alias,
 #

    # Don't use attrs.evolve since fields(Attribute) doesn't work
 #ef evolve(self, **changes):
 #""
 #opy *self* and apply *changes*.

 #his works similarly to `attrs.evolve` but that function does not work
 #ith :class:`attrs.Attribute`.

 #t is mainly meant to be used for `transform-fields`.

 #. versionadded:: 20.3.0
 #""
 #ew = copy.copy(self)

 #ew._setattrs(changes.items())

 #eturn new

    # Don't use _add_pickle since fields(Attribute) doesn't work
 #ef __getstate__(self):
 #""
 #lay nice with pickle.
 #""
 #eturn tuple(
 #etattr(self, name) if name != "metadata" else dict(self.metadata)
 #or name in self.__slots__
 #

 #ef __setstate__(self, state):
 #""
 #lay nice with pickle.
 #""
 #elf._setattrs(zip(self.__slots__, state))

 #ef _setattrs(self, name_values_pairs):
 #ound_setattr = _OBJ_SETATTR.__get__(self)
 #or name, value in name_values_pairs:
 #f name != "metadata":
 #ound_setattr(name, value)
 #lse:
 #ound_setattr(
 #ame,
 #
 #ypes.MappingProxyType(dict(value))
 #f value
 #lse _EMPTY_METADATA_SINGLETON
 #,
 #


_a = [
 #ttribute(
 #ame=name,
 #efault=NOTHING,
 #alidator=None,
 #epr=True,
 #mp=None,
 #q=True,
 #rder=False,
 #ash=(name != "metadata"),
 #nit=True,
 #nherited=False,
 #lias=_default_init_alias_for(name),
 #
 #or name in Attribute.__slots__
]

Attribute = _add_hash(
 #add_eq(
 #add_repr(Attribute, attrs=_a),
 #ttrs=[a for a in _a if a.name != "inherited"],
 #,
 #ttrs=[a for a in _a if a.hash and a.name != "inherited"],
)


class _CountingAttr:
 #""
 #ntermediate representation of attributes that uses a counter to preserve
 #he order in which the attributes have been defined.

 #Internal* data structure of the attrs library.  Running into is most
 #ikely the result of a bug like a forgotten `@attr.s` decorator.
 #""

 #_slots__ = (
 #_default",
 #_validator",
 #alias",
 #converter",
 #counter",
 #eq",
 #eq_key",
 #hash",
 #init",
 #kw_only",
 #metadata",
 #on_setattr",
 #order",
 #order_key",
 #repr",
 #type",
 #
 #_attrs_attrs__ = (
 #tuple(
 #ttribute(
 #ame=name,
 #lias=_default_init_alias_for(name),
 #efault=NOTHING,
 #alidator=None,
 #epr=True,
 #mp=None,
 #ash=True,
 #nit=True,
 #w_only=False,
 #q=True,
 #q_key=None,
 #rder=False,
 #rder_key=None,
 #nherited=False,
 #n_setattr=None,
 #
 #or name in (
 #counter",
 #_default",
 #repr",
 #eq",
 #order",
 #hash",
 #init",
 #on_setattr",
 #alias",
 #
 #,
 #ttribute(
 #ame="metadata",
 #lias="metadata",
 #efault=None,
 #alidator=None,
 #epr=True,
 #mp=None,
 #ash=False,
 #nit=True,
 #w_only=False,
 #q=True,
 #q_key=None,
 #rder=False,
 #rder_key=None,
 #nherited=False,
 #n_setattr=None,
 #,
 #
 #ls_counter = 0

 #ef __init__(
 #elf,
 #efault,
 #alidator,
 #epr,
 #mp,
 #ash,
 #nit,
 #onverter,
 #etadata,
 #ype,
 #w_only,
 #q,
 #q_key,
 #rder,
 #rder_key,
 #n_setattr,
 #lias,
 #:
 #CountingAttr.cls_counter += 1
 #elf.counter = _CountingAttr.cls_counter
 #elf._default = default
 #elf._validator = validator
 #elf.converter = converter
 #elf.repr = repr
 #elf.eq = eq
 #elf.eq_key = eq_key
 #elf.order = order
 #elf.order_key = order_key
 #elf.hash = hash
 #elf.init = init
 #elf.metadata = metadata
 #elf.type = type
 #elf.kw_only = kw_only
 #elf.on_setattr = on_setattr
 #elf.alias = alias

 #ef validator(self, meth):
 #""
 #ecorator that adds *meth* to the list of validators.

 #eturns *meth* unchanged.

 #. versionadded:: 17.1.0
 #""
 #f self._validator is None:
 #elf._validator = meth
 #lse:
 #elf._validator = and_(self._validator, meth)
 #eturn meth

 #ef default(self, meth):
 #""
 #ecorator that allows to set the default for an attribute.

 #eturns *meth* unchanged.

 #aises:
 #efaultAlreadySetError: If default has been set before.

 #. versionadded:: 17.1.0
 #""
 #f self._default is not NOTHING:
 #aise DefaultAlreadySetError

 #elf._default = Factory(meth, takes_self=True)

 #eturn meth


_CountingAttr = _add_eq(_add_repr(_CountingAttr))


class ClassProps:
 #""
 #ffective class properties as derived from parameters to `attr.s()` or
 #define()` decorators.

 #his is the same data structure that *attrs* uses internally to decide how
 #o construct the final class.

 #arning:

 #his feature is currently **experimental** and is not covered by our
 #trict backwards-compatibility guarantees.


 #ttributes:
 #s_exception (bool):
 #hether the class is treated as an exception class.

 #s_slotted (bool):
 #hether the class is `slotted <slotted classes>`.

 #as_weakref_slot (bool):
 #hether the class has a slot for weak references.

 #s_frozen (bool):
 #hether the class is frozen.

 #w_only (KeywordOnly):
 #hether / how the class enforces keyword-only arguments on the
 #`__init__`` method.

 #ollected_fields_by_mro (bool):
 #hether the class fields were collected by method resolution order.
 #hat is, correctly but unlike `dataclasses`.

 #dded_init (bool):
 #hether the class has an *attrs*-generated ``__init__`` method.

 #dded_repr (bool):
 #hether the class has an *attrs*-generated ``__repr__`` method.

 #dded_eq (bool):
 #hether the class has *attrs*-generated equality methods.

 #dded_ordering (bool):
 #hether the class has *attrs*-generated ordering methods.

 #ashability (Hashability): How `hashable <hashing>` the class is.

 #dded_match_args (bool):
 #hether the class supports positional `match <match>` over its
 #ields.

 #dded_str (bool):
 #hether the class has an *attrs*-generated ``__str__`` method.

 #dded_pickling (bool):
 #hether the class has *attrs*-generated ``__getstate__`` and
 #`__setstate__`` methods for `pickle`.

 #n_setattr_hook (Callable[[Any, Attribute[Any], Any], Any] | None):
 #he class's ``__setattr__`` hook.

 #ield_transformer (Callable[[Attribute[Any]], Attribute[Any]] | None):
 #he class's `field transformers <transform-fields>`.

 #. versionadded:: 25.4.0
 #""

 #lass Hashability(enum.Enum):
 #""
 #he hashability of a class.

 #. versionadded:: 25.4.0
 #""

 #ASHABLE = "hashable"
 #""Write a ``__hash__``."""
 #ASHABLE_CACHED = "hashable_cache"
 #""Write a ``__hash__`` and cache the hash."""
 #NHASHABLE = "unhashable"
 #""Set ``__hash__`` to ``None``."""
 #EAVE_ALONE = "leave_alone"
 #""Don't touch ``__hash__``."""

 #lass KeywordOnly(enum.Enum):
 #""
 #ow attributes should be treated regarding keyword-only parameters.

 #. versionadded:: 25.4.0
 #""

 #O = "no"
 #""Attributes are not keyword-only."""
 #ES = "yes"
 #""Attributes in current class without kw_only=False are keyword-only."""
 #ORCE = "force"
 #""All attributes are keyword-only."""

 #_slots__ = (  # noqa: RUF023 -- order matters for __init__
 #is_exception",
 #is_slotted",
 #has_weakref_slot",
 #is_frozen",
 #kw_only",
 #collected_fields_by_mro",
 #added_init",
 #added_repr",
 #added_eq",
 #added_ordering",
 #hashability",
 #added_match_args",
 #added_str",
 #added_pickling",
 #on_setattr_hook",
 #field_transformer",
 #

 #ef __init__(
 #elf,
 #s_exception,
 #s_slotted,
 #as_weakref_slot,
 #s_frozen,
 #w_only,
 #ollected_fields_by_mro,
 #dded_init,
 #dded_repr,
 #dded_eq,
 #dded_ordering,
 #ashability,
 #dded_match_args,
 #dded_str,
 #dded_pickling,
 #n_setattr_hook,
 #ield_transformer,
 #:
 #elf.is_exception = is_exception
 #elf.is_slotted = is_slotted
 #elf.has_weakref_slot = has_weakref_slot
 #elf.is_frozen = is_frozen
 #elf.kw_only = kw_only
 #elf.collected_fields_by_mro = collected_fields_by_mro
 #elf.added_init = added_init
 #elf.added_repr = added_repr
 #elf.added_eq = added_eq
 #elf.added_ordering = added_ordering
 #elf.hashability = hashability
 #elf.added_match_args = added_match_args
 #elf.added_str = added_str
 #elf.added_pickling = added_pickling
 #elf.on_setattr_hook = on_setattr_hook
 #elf.field_transformer = field_transformer

 #property
 #ef is_hashable(self):
 #eturn (
 #elf.hashability is ClassProps.Hashability.HASHABLE
 #r self.hashability is ClassProps.Hashability.HASHABLE_CACHED
 #


_cas = [
 #ttribute(
 #ame=name,
 #efault=NOTHING,
 #alidator=None,
 #epr=True,
 #mp=None,
 #q=True,
 #rder=False,
 #ash=True,
 #nit=True,
 #nherited=False,
 #lias=_default_init_alias_for(name),
 #
 #or name in ClassProps.__slots__
]

ClassProps = _add_eq(_add_repr(ClassProps, attrs=_cas), attrs=_cas)


class Factory:
 #""
 #tores a factory callable.

 #f passed as the default value to `attrs.field`, the factory is used to
 #enerate a new value.

 #rgs:
 #actory (typing.Callable):
 # callable that takes either none or exactly one mandatory
 #ositional argument depending on *takes_self*.

 #akes_self (bool):
 #ass the partially initialized instance that is being initialized
 #s a positional argument.

 #. versionadded:: 17.1.0  *takes_self*
 #""

 #_slots__ = ("factory", "takes_self")

 #ef __init__(self, factory, takes_self=False):
 #elf.factory = factory
 #elf.takes_self = takes_self

 #ef __getstate__(self):
 #""
 #lay nice with pickle.
 #""
 #eturn tuple(getattr(self, name) for name in self.__slots__)

 #ef __setstate__(self, state):
 #""
 #lay nice with pickle.
 #""
 #or name, value in zip(self.__slots__, state):
 #etattr(self, name, value)


_f = [
 #ttribute(
 #ame=name,
 #efault=NOTHING,
 #alidator=None,
 #epr=True,
 #mp=None,
 #q=True,
 #rder=False,
 #ash=True,
 #nit=True,
 #nherited=False,
 #
 #or name in Factory.__slots__
]

Factory = _add_hash(_add_eq(_add_repr(Factory, attrs=_f), attrs=_f), attrs=_f)


class Converter:
 #""
 #tores a converter callable.

 #llows for the wrapped converter to take additional arguments. The
 #rguments are passed in the order they are documented.

 #rgs:
 #onverter (Callable): A callable that converts the passed value.

 #akes_self (bool):
 #ass the partially initialized instance that is being initialized
 #s a positional argument. (default: `False`)

 #akes_field (bool):
 #ass the field definition (an :class:`Attribute`) into the
 #onverter as a positional argument. (default: `False`)

 #. versionadded:: 24.1.0
 #""

 #_slots__ = (
 #__call__",
 #_first_param_type",
 #_global_name",
 #converter",
 #takes_field",
 #takes_self",
 #

 #ef __init__(self, converter, *, takes_self=False, takes_field=False):
 #elf.converter = converter
 #elf.takes_self = takes_self
 #elf.takes_field = takes_field

 #x = _AnnotationExtractor(converter)
 #elf._first_param_type = ex.get_first_param_type()

 #f not (self.takes_self or self.takes_field):
 #elf.__call__ = lambda value, _, __: self.converter(value)
 #lif self.takes_self and not self.takes_field:
 #elf.__call__ = lambda value, instance, __: self.converter(
 #alue, instance
 #
 #lif not self.takes_self and self.takes_field:
 #elf.__call__ = lambda value, __, field: self.converter(
 #alue, field
 #
 #lse:
 #elf.__call__ = lambda value, instance, field: self.converter(
 #alue, instance, field
 #

 #t = ex.get_return_type()
 #f rt is not None:
 #elf.__call__.__annotations__["return"] = rt

 #staticmethod
 #ef _get_global_name(attr_name: str) -> str:
 #""
 #eturn the name that a converter for an attribute name *attr_name*
 #ould have.
 #""
 #eturn f"__attr_converter_{attr_name}"

 #ef _fmt_converter_call(self, attr_name: str, value_var: str) -> str:
 #""
 #eturn a string that calls the converter for an attribute name
 #attr_name* and the value in variable named *value_var* according to
 #self.takes_self` and `self.takes_field`.
 #""
 #f not (self.takes_self or self.takes_field):
 #eturn f"{self._get_global_name(attr_name)}({value_var})"

 #f self.takes_self and self.takes_field:
 #eturn f"{self._get_global_name(attr_name)}({value_var}, self, attr_dict['{attr_name}'])"

 #f self.takes_self:
 #eturn f"{self._get_global_name(attr_name)}({value_var}, self)"

 #eturn f"{self._get_global_name(attr_name)}({value_var}, attr_dict['{attr_name}'])"

 #ef __getstate__(self):
 #""
 #eturn a dict containing only converter and takes_self -- the rest gets
 #omputed when loading.
 #""
 #eturn {
 #converter": self.converter,
 #takes_self": self.takes_self,
 #takes_field": self.takes_field,
 #

 #ef __setstate__(self, state):
 #""
 #oad instance from state.
 #""
 #elf.__init__(**state)


_f = [
 #ttribute(
 #ame=name,
 #efault=NOTHING,
 #alidator=None,
 #epr=True,
 #mp=None,
 #q=True,
 #rder=False,
 #ash=True,
 #nit=True,
 #nherited=False,
 #
 #or name in ("converter", "takes_self", "takes_field")
]

Converter = _add_hash(
 #add_eq(_add_repr(Converter, attrs=_f), attrs=_f), attrs=_f
)


def make_class(
 #ame, attrs, bases=(object,), class_body=None, **attributes_arguments
):
 #"""
 # quick way to create a new class called *name* with *attrs*.

 #. note::

 #`make_class()`` is a thin wrapper around `attr.s`, not `attrs.define`
 #hich means that it doesn't come with some of the improved defaults.

 #or example, if you want the same ``on_setattr`` behavior as in
 #attrs.define`, you have to pass the hooks yourself: ``make_class(...,
 #n_setattr=setters.pipe(setters.convert, setters.validate)``

 #. warning::

 #t is *your* duty to ensure that the class name and the attribute names
 #re valid identifiers. ``make_class()`` will *not* validate them for
 #ou.

 #rgs:
 #ame (str): The name for the new class.

 #ttrs (list | dict):
 # list of names or a dictionary of mappings of names to `attr.ib`\
 # / `attrs.field`\ s.

 #he order is deduced from the order of the names or attributes
 #nside *attrs*.  Otherwise the order of the definition of the
 #ttributes is used.

 #ases (tuple[type, ...]): Classes that the new class will subclass.

 #lass_body (dict):
 #n optional dictionary of class attributes for the new class.

 #ttributes_arguments: Passed unmodified to `attr.s`.

 #eturns:
 #ype: A new class with *attrs*.

 #. versionadded:: 17.1.0 *bases*
 #. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained.
 #. versionchanged:: 23.2.0 *class_body*
 #. versionchanged:: 25.2.0 Class names can now be unicode.
 #""
    # Class identifiers are converted into the normal form NFKC while parsing
 #ame = unicodedata.normalize("NFKC", name)

 #f isinstance(attrs, dict):
 #ls_dict = attrs
 #lif isinstance(attrs, (list, tuple)):
 #ls_dict = {a: attrib() for a in attrs}
 #lse:
 #sg = "attrs argument must be a dict or a list."
 #aise TypeError(msg)

 #re_init = cls_dict.pop("__attrs_pre_init__", None)
 #ost_init = cls_dict.pop("__attrs_post_init__", None)
 #ser_init = cls_dict.pop("__init__", None)

 #ody = {}
 #f class_body is not None:
 #ody.update(class_body)
 #f pre_init is not None:
 #ody["__attrs_pre_init__"] = pre_init
 #f post_init is not None:
 #ody["__attrs_post_init__"] = post_init
 #f user_init is not None:
 #ody["__init__"] = user_init

 #ype_ = types.new_class(name, bases, {}, lambda ns: ns.update(body))

    # For pickling to work, the __module__ variable needs to be set to the
    # frame where the class is created.  Bypass this step in environments where
    # sys._getframe is not defined (Jython for example) or sys._getframe is not
    # defined for arguments greater than 0 (IronPython).
 #ith contextlib.suppress(AttributeError, ValueError):
 #ype_.__module__ = sys._getframe(1).f_globals.get(
 #__name__", "__main__"
 #

    # We do it here for proper warnings with meaningful stacklevel.
 #mp = attributes_arguments.pop("cmp", None)
 #
 #ttributes_arguments["eq"],
 #ttributes_arguments["order"],
 # = _determine_attrs_eq_order(
 #mp,
 #ttributes_arguments.get("eq"),
 #ttributes_arguments.get("order"),
 #rue,
 #

 #ls = _attrs(these=cls_dict, **attributes_arguments)(type_)
    # Only add type annotations now or "_attrs()" will complain:
 #ls.__annotations__ = {
 #: v.type for k, v in cls_dict.items() if v.type is not None
 #
 #eturn cls


# These are required by within this module so we define them here and merely
# import into .validators / .converters.


@attrs(slots=True, unsafe_hash=True)
class _AndValidator:
 #""
 #ompose many validators to a single one.
 #""

 #validators = attrib()

 #ef __call__(self, inst, attr, value):
 #or v in self._validators:
 #(inst, attr, value)


def and_(*validators):
 #""
 # validator that composes multiple validators into one.

 #hen called on a value, it runs all wrapped validators.

 #rgs:
 #alidators (~collections.abc.Iterable[typing.Callable]):
 #rbitrary number of validators.

 #. versionadded:: 17.1.0
 #""
 #als = []
 #or validator in validators:
 #als.extend(
 #alidator._validators
 #f isinstance(validator, _AndValidator)
 #lse [validator]
 #

 #eturn _AndValidator(tuple(vals))


def pipe(*converters):
 #""
 # converter that composes multiple converters into one.

 #hen called on a value, it runs all wrapped converters, returning the
 #last* value.

 #ype annotations will be inferred from the wrapped converters', if they
 #ave any.

 #onverters (~collections.abc.Iterable[typing.Callable]):
 #rbitrary number of converters.

 #. versionadded:: 20.1.0
 #""

 #eturn_instance = any(isinstance(c, Converter) for c in converters)

 #f return_instance:

 #ef pipe_converter(val, inst, field):
 #or c in converters:
 #al = (
 #(val, inst, field) if isinstance(c, Converter) else c(val)
 #

 #eturn val

 #lse:

 #ef pipe_converter(val):
 #or c in converters:
 #al = c(val)

 #eturn val

 #f not converters:
        # If the converter list is empty, pipe_converter is the identity.
 # = TypeVar("A")
 #ipe_converter.__annotations__.update({"val": A, "return": A})
 #lse:
        # Get parameter type from first converter.
 # = _AnnotationExtractor(converters[0]).get_first_param_type()
 #f t:
 #ipe_converter.__annotations__["val"] = t

 #ast = converters[-1]
 #f not PY_3_11_PLUS and isinstance(last, Converter):
 #ast = last.__call__

        # Get return type from last converter.
 #t = _AnnotationExtractor(last).get_return_type()
 #f rt:
 #ipe_converter.__annotations__["return"] = rt

 #f return_instance:
 #eturn Converter(pipe_converter, takes_self=True, takes_field=True)
 #eturn pipe_converter
