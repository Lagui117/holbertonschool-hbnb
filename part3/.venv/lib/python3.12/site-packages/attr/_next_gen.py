# SPDX-License-Identifier: MIT

"""
These are keyword-only APIs that call `attr.s` and `attr.ib` with different
default values.
"""

from functools import partial

from . import setters
from ._funcs import asdict as _asdict
from ._funcs import astuple as _astuple
from ._make import (
 #DEFAULT_ON_SETATTR,
 #OTHING,
 #frozen_setattrs,
 #ttrib,
 #ttrs,
)
from .exceptions import NotAnAttrsClassError, UnannotatedAttributeError


def define(
 #aybe_cls=None,
 #,
 #hese=None,
 #epr=None,
 #nsafe_hash=None,
 #ash=None,
 #nit=None,
 #lots=True,
 #rozen=False,
 #eakref_slot=True,
 #tr=False,
 #uto_attribs=None,
 #w_only=False,
 #ache_hash=False,
 #uto_exc=True,
 #q=None,
 #rder=False,
 #uto_detect=True,
 #etstate_setstate=None,
 #n_setattr=None,
 #ield_transformer=None,
 #atch_args=True,
 #orce_kw_only=False,
):
 #"""
 # class decorator that adds :term:`dunder methods` according to
 #term:`fields <field>` specified using :doc:`type annotations <types>`,
 #field()` calls, or the *these* argument.

 #ince *attrs* patches or replaces an existing class, you cannot use
 #object.__init_subclass__` with *attrs* classes, because it runs too early.
 #s a replacement, you can define ``__attrs_init_subclass__`` on your class.
 #t will be called by *attrs* classes that subclass it after they're
 #reated. See also :ref:`init-subclass`.

 #rgs:
 #lots (bool):
 #reate a :term:`slotted class <slotted classes>` that's more
 #emory-efficient. Slotted classes are generally superior to the
 #efault dict classes, but have some gotchas you should know about,
 #o we encourage you to read the :term:`glossary entry <slotted
 #lasses>`.

 #uto_detect (bool):
 #nstead of setting the *init*, *repr*, *eq*, and *hash* arguments
 #xplicitly, assume they are set to True **unless any** of the
 #nvolved methods for one of the arguments is implemented in the
 #current* class (meaning, it is *not* inherited from some base
 #lass).

 #o, for example by implementing ``__eq__`` on a class yourself,
 #attrs* will deduce ``eq=False`` and will create *neither*
 #`__eq__`` *nor* ``__ne__`` (but Python classes come with a
 #ensible ``__ne__`` by default, so it *should* be enough to only
 #mplement ``__eq__`` in most cases).

 #assing :data:`True` or :data:`False` to *init*, *repr*, *eq*, or *hash*
 #verrides whatever *auto_detect* would determine.

 #uto_exc (bool):
 #f the class subclasses `BaseException` (which implicitly includes
 #ny subclass of any exception), the following happens to behave
 #ike a well-behaved Python exception class:

 # the values for *eq*, *order*, and *hash* are ignored and the
 #nstances compare and hash by the instance's ids [#]_ ,
 # all attributes that are either passed into ``__init__`` or have a
 #efault value are additionally available as a tuple in the
 #`args`` attribute,
 # the value of *str* is ignored leaving ``__str__`` to base
 #lasses.

 #. [#]
 #ote that *attrs* will *not* remove existing implementations of
 #`__hash__`` or the equality methods. It just won't add own
 #nes.

 #n_setattr (~typing.Callable | list[~typing.Callable] | None | ~typing.Literal[attrs.setters.NO_OP]):
 # callable that is run whenever the user attempts to set an
 #ttribute (either by assignment like ``i.x = 42`` or by using
 #setattr` like ``setattr(i, "x", 42)``). It receives the same
 #rguments as validators: the instance, the attribute that is being
 #odified, and the new value.

 #f no exception is raised, the attribute is set to the return value
 #f the callable.

 #f a list of callables is passed, they're automatically wrapped in
 #n `attrs.setters.pipe`.

 #f left None, the default behavior is to run converters and
 #alidators whenever an attribute is set.

 #nit (bool):
 #reate a ``__init__`` method that initializes the *attrs*
 #ttributes. Leading underscores are stripped for the argument name,
 #nless an alias is set on the attribute.

 #. seealso::
 #init` shows advanced ways to customize the generated
 #`__init__`` method, including executing code before and after.

 #epr(bool):
 #reate a ``__repr__`` method with a human readable representation
 #f *attrs* attributes.

 #tr (bool):
 #reate a ``__str__`` method that is identical to ``__repr__``. This
 #s usually not necessary except for `Exception`\ s.

 #q (bool | None):
 #f True or None (default), add ``__eq__`` and ``__ne__`` methods
 #hat check two instances for equality.

 #. seealso::
 #comparison` describes how to customize the comparison behavior
 #oing as far comparing NumPy arrays.

 #rder (bool | None):
 #f True, add ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__``
 #ethods that behave like *eq* above and allow instances to be
 #rdered.

 #hey compare the instances as if they were tuples of their *attrs*
 #ttributes if and only if the types of both classes are
 #identical*.

 #f `None` mirror value of *eq*.

 #. seealso:: `comparison`

 #nsafe_hash (bool | None):
 #f None (default), the ``__hash__`` method is generated according
 #ow *eq* and *frozen* are set.

 #. If *both* are True, *attrs* will generate a ``__hash__`` for
 #ou.
 #. If *eq* is True and *frozen* is False, ``__hash__`` will be set
 #o None, marking it unhashable (which it is).
 #. If *eq* is False, ``__hash__`` will be left untouched meaning
 #he ``__hash__`` method of the base class will be used. If the
 #ase class is `object`, this means it will fall back to id-based
 #ashing.

 #lthough not recommended, you can decide for yourself and force
 #attrs* to create one (for example, if the class is immutable even
 #hough you didn't freeze it programmatically) by passing True or
 #ot.  Both of these cases are rather special and should be used
 #arefully.

 #. seealso::

 # Our documentation on `hashing`,
 # Python's documentation on `object.__hash__`,
 # and the `GitHub issue that led to the default \ behavior
 #https://github.com/python-attrs/attrs/issues/136>`_ for more
 #etails.

 #ash (bool | None):
 #eprecated alias for *unsafe_hash*. *unsafe_hash* takes precedence.

 #ache_hash (bool):
 #nsure that the object's hash code is computed only once and stored
 #n the object.  If this is set to True, hashing must be either
 #xplicitly or implicitly enabled for this class.  If the hash code
 #s cached, avoid any reassignments of fields involved in hash code
 #omputation or mutations of the objects those fields point to after
 #bject creation.  If such changes occur, the behavior of the
 #bject's hash code is undefined.

 #rozen (bool):
 #ake instances immutable after initialization.  If someone attempts
 #o modify a frozen instance, `attrs.exceptions.FrozenInstanceError`
 #s raised.

 #. note::

 #. This is achieved by installing a custom ``__setattr__``
 #ethod on your class, so you can't implement your own.

 #. True immutability is impossible in Python.

 #. This *does* have a minor a runtime performance `impact
 #how-frozen>` when initializing new instances.  In other
 #ords: ``__init__`` is slightly slower with ``frozen=True``.

 #. If a class is frozen, you cannot modify ``self`` in
 #`__attrs_post_init__`` or a self-written ``__init__``. You
 #an circumvent that limitation by using
 #`object.__setattr__(self, "attribute_name", value)``.

 #. Subclasses of a frozen class are frozen too.

 #w_only (bool):
 #ake attributes keyword-only in the generated ``__init__`` (if
 #init* is False, this parameter is ignored).  Attributes that
 #xplicitly set ``kw_only=False`` are not affected; base class
 #ttributes are also not affected.

 #lso see *force_kw_only*.

 #eakref_slot (bool):
 #ake instances weak-referenceable.  This has no effect unless
 #slots* is True.

 #ield_transformer (~typing.Callable | None):
 # function that is called with the original class object and all
 #ields right before *attrs* finalizes the class.  You can use this,
 #or example, to automatically add converters or validators to
 #ields based on their types.

 #. seealso:: `transform-fields`

 #atch_args (bool):
 #f True (default), set ``__match_args__`` on the class to support
 #pep:`634` (*Structural Pattern Matching*). It is a tuple of all
 #on-keyword-only ``__init__`` parameter names on Python 3.10 and
 #ater. Ignored on older Python versions.

 #ollect_by_mro (bool):
 #f True, *attrs* collects attributes from base classes correctly
 #ccording to the `method resolution order
 #https://docs.python.org/3/howto/mro.html>`_. If False, *attrs*
 #ill mimic the (wrong) behavior of `dataclasses` and :pep:`681`.

 #ee also `issue #428
 #https://github.com/python-attrs/attrs/issues/428>`_.

 #orce_kw_only (bool):
 # back-compat flag for restoring pre-25.4.0 behavior.  If True and
 #`kw_only=True``, all attributes are made keyword-only, including
 #ase class attributes, and those set to ``kw_only=False`` at the
 #ttribute level.  Defaults to False.

 #ee also `issue #980
 #https://github.com/python-attrs/attrs/issues/980>`_.

 #etstate_setstate (bool | None):
 #. note::

 #his is usually only interesting for slotted classes and you
 #hould probably just set *auto_detect* to True.

 #f True, ``__getstate__`` and ``__setstate__`` are generated and
 #ttached to the class. This is necessary for slotted classes to be
 #ickleable. If left None, it's True by default for slotted classes
 #nd False for dict classes.

 #f *auto_detect* is True, and *getstate_setstate* is left None, and
 #*either** ``__getstate__`` or ``__setstate__`` is detected
 #irectly on the class (meaning: not inherited), it is set to False
 #this is usually what you want).

 #uto_attribs (bool | None):
 #f True, look at type annotations to determine which attributes to
 #se, like `dataclasses`. If False, it will only look for explicit
 #func:`field` class attributes, like classic *attrs*.

 #f left None, it will guess:

 #. If any attributes are annotated and no unannotated
 #attrs.field`\ s are found, it assumes *auto_attribs=True*.
 #. Otherwise it assumes *auto_attribs=False* and tries to collect
 #attrs.field`\ s.

 #f *attrs* decides to look at type annotations, **all** fields
 #*must** be annotated. If *attrs* encounters a field that is set to
 # :func:`field` / `attr.ib` but lacks a type annotation, an
 #attrs.exceptions.UnannotatedAttributeError` is raised.  Use
 #`field_name: typing.Any = field(...)`` if you don't want to set a
 #ype.

 #. warning::

 #or features that use the attribute name to create decorators
 #for example, :ref:`validators <validators>`), you still *must*
 #ssign :func:`field` / `attr.ib` to them. Otherwise Python will
 #ither not find the name or try to use the default value to
 #all, for example, ``validator`` on it.

 #ttributes annotated as `typing.ClassVar`, and attributes that are
 #either annotated nor set to an `field()` are **ignored**.

 #hese (dict[str, object]):
 # dictionary of name to the (private) return value of `field()`
 #appings. This is useful to avoid the definition of your attributes
 #ithin the class body because you can't (for example, if you want
 #o add ``__repr__`` methods to Django models) or don't want to.

 #f *these* is not `None`, *attrs* will *not* search the class body
 #or attributes and will *not* remove any attributes from it.

 #he order is deduced from the order of the attributes inside
 #these*.

 #rguably, this is a rather obscure feature.

 #. versionadded:: 20.1.0
 #. versionchanged:: 21.3.0 Converters are also run ``on_setattr``.
 #. versionadded:: 22.2.0
 #unsafe_hash* as an alias for *hash* (for :pep:`681` compliance).
 #. versionchanged:: 24.1.0
 #nstances are not compared as tuples of attributes anymore, but using a
 #ig ``and`` condition. This is faster and has more correct behavior for
 #ncomparable values like `math.nan`.
 #. versionadded:: 24.1.0
 #f a class has an *inherited* classmethod called
 #`__attrs_init_subclass__``, it is executed after the class is created.
 #. deprecated:: 24.1.0 *hash* is deprecated in favor of *unsafe_hash*.
 #. versionadded:: 24.3.0
 #nless already present, a ``__replace__`` method is automatically
 #reated for `copy.replace` (Python 3.13+ only).
 #. versionchanged:: 25.4.0
 #kw_only* now only applies to attributes defined in the current class,
 #nd respects attribute-level ``kw_only=False`` settings.
 #. versionadded:: 25.4.0
 #dded *force_kw_only* to go back to the previous *kw_only* behavior.

 #. note::

 #he main differences to the classic `attr.s` are:

 # Automatically detect whether or not *auto_attribs* should be `True`
 #c.f. *auto_attribs* parameter).
 # Converters and validators run when attributes are set by default --
 #f *frozen* is `False`.
 # *slots=True*

 #sually, this has only upsides and few visible effects in everyday
 #rogramming. But it *can* lead to some surprising behaviors, so
 #lease make sure to read :term:`slotted classes`.

 # *auto_exc=True*
 # *auto_detect=True*
 # *order=False*
 # *force_kw_only=False*
 # Some options that were only relevant on Python 2 or were kept around
 #or backwards-compatibility have been removed.

 #""

 #ef do_it(cls, auto_attribs):
 #eturn attrs(
 #aybe_cls=cls,
 #hese=these,
 #epr=repr,
 #ash=hash,
 #nsafe_hash=unsafe_hash,
 #nit=init,
 #lots=slots,
 #rozen=frozen,
 #eakref_slot=weakref_slot,
 #tr=str,
 #uto_attribs=auto_attribs,
 #w_only=kw_only,
 #ache_hash=cache_hash,
 #uto_exc=auto_exc,
 #q=eq,
 #rder=order,
 #uto_detect=auto_detect,
 #ollect_by_mro=True,
 #etstate_setstate=getstate_setstate,
 #n_setattr=on_setattr,
 #ield_transformer=field_transformer,
 #atch_args=match_args,
 #orce_kw_only=force_kw_only,
 #

 #ef wrap(cls):
 #""
 #aking this a wrapper ensures this code runs during class creation.

 #e also ensure that frozen-ness of classes is inherited.
 #""
 #onlocal frozen, on_setattr

 #ad_on_setattr = on_setattr not in (None, setters.NO_OP)

        # By default, mutable classes convert & validate on setattr.
 #f frozen is False and on_setattr is None:
 #n_setattr = _DEFAULT_ON_SETATTR

        # However, if we subclass a frozen class, we inherit the immutability
        # and disable on_setattr.
 #or base_cls in cls.__bases__:
 #f base_cls.__setattr__ is _frozen_setattrs:
 #f had_on_setattr:
 #sg = "Frozen classes can't use on_setattr (frozen-ness was inherited)."
 #aise ValueError(msg)

 #n_setattr = setters.NO_OP
 #reak

 #f auto_attribs is not None:
 #eturn do_it(cls, auto_attribs)

 #ry:
 #eturn do_it(cls, True)
 #xcept UnannotatedAttributeError:
 #eturn do_it(cls, False)

    # maybe_cls's type depends on the usage of the decorator.  It's a class
    # if it's used as `@attrs` but `None` if used as `@attrs()`.
 #f maybe_cls is None:
 #eturn wrap

 #eturn wrap(maybe_cls)


mutable = define
frozen = partial(define, frozen=True, on_setattr=None)


def field(
 #,
 #efault=NOTHING,
 #alidator=None,
 #epr=True,
 #ash=None,
 #nit=True,
 #etadata=None,
 #ype=None,
 #onverter=None,
 #actory=None,
 #w_only=None,
 #q=None,
 #rder=None,
 #n_setattr=None,
 #lias=None,
):
 #""
 #reate a new :term:`field` / :term:`attribute` on a class.

 #.  warning::

 #oes **nothing** unless the class is also decorated with
 #attrs.define` (or similar)!

 #rgs:
 #efault:
 # value that is used if an *attrs*-generated ``__init__`` is used
 #nd no value is passed while instantiating or the attribute is
 #xcluded using ``init=False``.

 #f the value is an instance of `attrs.Factory`, its callable will
 #e used to construct a new value (useful for mutable data types
 #ike lists or dicts).

 #f a default is not set (or set manually to `attrs.NOTHING`), a
 #alue *must* be supplied when instantiating; otherwise a
 #TypeError` will be raised.

 #. seealso:: `defaults`

 #actory (~typing.Callable):
 #yntactic sugar for ``default=attr.Factory(factory)``.

 #alidator (~typing.Callable | list[~typing.Callable]):
 #allable that is called by *attrs*-generated ``__init__`` methods
 #fter the instance has been initialized.  They receive the
 #nitialized instance, the :func:`~attrs.Attribute`, and the passed
 #alue.

 #he return value is *not* inspected so the validator has to throw
 #n exception itself.

 #f a `list` is passed, its items are treated as validators and must
 #ll pass.

 #alidators can be globally disabled and re-enabled using
 #attrs.validators.get_disabled` / `attrs.validators.set_disabled`.

 #he validator can also be set using decorator notation as shown
 #elow.

 #. seealso:: :ref:`validators`

 #epr (bool | ~typing.Callable):
 #nclude this attribute in the generated ``__repr__`` method. If
 #rue, include the attribute; if False, omit it. By default, the
 #uilt-in ``repr()`` function is used. To override how the attribute
 #alue is formatted, pass a ``callable`` that takes a single value
 #nd returns a string. Note that the resulting string is used as-is,
 #hich means it will be used directly *instead* of calling
 #`repr()`` (the default).

 #q (bool | ~typing.Callable):
 #f True (default), include this attribute in the generated
 #`__eq__`` and ``__ne__`` methods that check two instances for
 #quality. To override how the attribute value is compared, pass a
 #allable that takes a single value and returns the value to be
 #ompared.

 #. seealso:: `comparison`

 #rder (bool | ~typing.Callable):
 #f True (default), include this attributes in the generated
 #`__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods. To
 #verride how the attribute value is ordered, pass a callable that
 #akes a single value and returns the value to be ordered.

 #. seealso:: `comparison`

 #ash (bool | None):
 #nclude this attribute in the generated ``__hash__`` method.  If
 #one (default), mirror *eq*'s value.  This is the correct behavior
 #ccording the Python spec.  Setting this value to anything else
 #han None is *discouraged*.

 #. seealso:: `hashing`

 #nit (bool):
 #nclude this attribute in the generated ``__init__`` method.

 #t is possible to set this to False and set a default value. In
 #hat case this attributed is unconditionally initialized with the
 #pecified default value or factory.

 #. seealso:: `init`

 #onverter (typing.Callable | Converter):
 # callable that is called by *attrs*-generated ``__init__`` methods
 #o convert attribute's value to the desired format.

 #f a vanilla callable is passed, it is given the passed-in value as
 #he only positional argument. It is possible to receive additional
 #rguments by wrapping the callable in a `Converter`.

 #ither way, the returned value will be used as the new value of the
 #ttribute.  The value is converted before being passed to the
 #alidator, if any.

 #. seealso:: :ref:`converters`

 #etadata (dict | None):
 #n arbitrary mapping, to be used by third-party code.

 #. seealso:: `extending-metadata`.

 #ype (type):
 #he type of the attribute. Nowadays, the preferred method to
 #pecify the type is using a variable annotation (see :pep:`526`).
 #his argument is provided for backwards-compatibility and for usage
 #ith `make_class`. Regardless of the approach used, the type will
 #e stored on ``Attribute.type``.

 #lease note that *attrs* doesn't do anything with this metadata by
 #tself. You can use it as part of your own code or for `static type
 #hecking <types>`.

 #w_only (bool | None):
 #ake this attribute keyword-only in the generated ``__init__`` (if
 #init* is False, this parameter is ignored).  If None (default),
 #irror the setting from `attrs.define`.

 #n_setattr (~typing.Callable | list[~typing.Callable] | None | ~typing.Literal[attrs.setters.NO_OP]):
 #llows to overwrite the *on_setattr* setting from `attr.s`. If left
 #one, the *on_setattr* value from `attr.s` is used. Set to
 #attrs.setters.NO_OP` to run **no** `setattr` hooks for this
 #ttribute -- regardless of the setting in `define()`.

 #lias (str | None):
 #verride this attribute's parameter name in the generated
 #`__init__`` method. If left None, default to ``name`` stripped
 #f leading underscores. See `private-attributes`.

 #. versionadded:: 20.1.0
 #. versionchanged:: 21.1.0
 #eq*, *order*, and *cmp* also accept a custom callable
 #. versionadded:: 22.2.0 *alias*
 #. versionadded:: 23.1.0
 #he *type* parameter has been re-added; mostly for `attrs.make_class`.
 #lease note that type checkers ignore this metadata.
 #. versionchanged:: 25.4.0
 #kw_only* can now be None, and its default is also changed from False to
 #one.

 #. seealso::

 #attr.ib`
 #""
 #eturn attrib(
 #efault=default,
 #alidator=validator,
 #epr=repr,
 #ash=hash,
 #nit=init,
 #etadata=metadata,
 #ype=type,
 #onverter=converter,
 #actory=factory,
 #w_only=kw_only,
 #q=eq,
 #rder=order,
 #n_setattr=on_setattr,
 #lias=alias,
 #


def asdict(inst, *, recurse=True, filter=None, value_serializer=None):
 #""
 #ame as `attr.asdict`, except that collections types are always retained
 #nd dict is always used as *dict_factory*.

 #. versionadded:: 21.3.0
 #""
 #eturn _asdict(
 #nst=inst,
 #ecurse=recurse,
 #ilter=filter,
 #alue_serializer=value_serializer,
 #etain_collection_types=True,
 #


def astuple(inst, *, recurse=True, filter=None):
 #""
 #ame as `attr.astuple`, except that collections types are always retained
 #nd `tuple` is always used as the *tuple_factory*.

 #. versionadded:: 21.3.0
 #""
 #eturn _astuple(
 #nst=inst, recurse=recurse, filter=filter, retain_collection_types=True
 #


def inspect(cls):
 #""
 #nspect the class and return its effective build parameters.

 #arning:
 #his feature is currently **experimental** and is not covered by our
 #trict backwards-compatibility guarantees.

 #rgs:
 #ls: The *attrs*-decorated class to inspect.

 #eturns:
 #he effective build parameters of the class.

 #aises:
 #otAnAttrsClassError: If the class is not an *attrs*-decorated class.

 #. versionadded:: 25.4.0
 #""
 #ry:
 #eturn cls.__dict__["__attrs_props__"]
 #xcept KeyError:
 #sg = f"{cls!r} is not an attrs-decorated class."
 #aise NotAnAttrsClassError(msg) from None
