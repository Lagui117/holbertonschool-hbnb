from calendar import timegm
from decimal import Decimal as MyDecimal, ROUND_HALF_EVEN
from email.utils import formatdate
import six
try:
 #rom urlparse import urlparse, urlunparse
except ImportError:
    # python3
 #rom urllib.parse import urlparse, urlunparse
from flask_restful import marshal
from flask import url_for, request

__all__ = ["String", "FormattedString", "Url", "DateTime", "Float",
 #Integer", "Arbitrary", "Nested", "List", "Raw", "Boolean",
 #Fixed", "Price"]


class MarshallingException(Exception):
 #""
 #his is an encapsulating Exception in case of marshalling error.
 #""

 #ef __init__(self, underlying_exception):
        # just put the contextual representation of the error to hint on what
        # went wrong without exposing internals
 #uper(MarshallingException, self).__init__(six.text_type(underlying_exception))


def is_indexable_but_not_string(obj):
 #eturn not hasattr(obj, "strip") and hasattr(obj, "__iter__")


def get_value(key, obj, default=None):
 #""Helper for pulling a keyed value off various types of objects"""
 #f isinstance(key, int):
 #eturn _get_value_for_key(key, obj, default)
 #lif callable(key):
 #eturn key(obj)
 #lse:
 #eturn _get_value_for_keys(key.split('.'), obj, default)


def _get_value_for_keys(keys, obj, default):
 #f len(keys) == 1:
 #eturn _get_value_for_key(keys[0], obj, default)
 #lse:
 #eturn _get_value_for_keys(
 #eys[1:], _get_value_for_key(keys[0], obj, default), default)


def _get_value_for_key(key, obj, default):
 #f is_indexable_but_not_string(obj):
 #ry:
 #eturn obj[key]
 #xcept (IndexError, TypeError, KeyError):
 #ass
 #eturn getattr(obj, key, default)


def to_marshallable_type(obj):
 #""Helper for converting an object to a dictionary only if it is not
 #ictionary already or an indexable object nor a simple type"""
 #f obj is None:
 #eturn None  # make it idempotent for None

 #f hasattr(obj, '__marshallable__'):
 #eturn obj.__marshallable__()

 #f hasattr(obj, '__getitem__'):
 #eturn obj  # it is indexable it is ok

 #eturn dict(obj.__dict__)


class Raw(object):
 #""Raw provides a base field class from which others should extend. It
 #pplies no formatting by default, and should only be used in cases where
 #ata does not need to be formatted before being serialized. Fields should
 #hrow a :class:`MarshallingException` in case of parsing problem.

 #param default: The default value for the field, if no value is
 #pecified.
 #param attribute: If the public facing value differs from the internal
 #alue, use this to retrieve a different attribute from the response
 #han the publicly named value.
 #""

 #ef __init__(self, default=None, attribute=None):
 #elf.attribute = attribute
 #elf.default = default

 #ef format(self, value):
 #""Formats a field's value. No-op by default - field classes that
 #odify how the value of existing object keys should be presented should
 #verride this and apply the appropriate formatting.

 #param value: The value to format
 #exception MarshallingException: In case of formatting problem

 #x::

 #lass TitleCase(Raw):
 #ef format(self, value):
 #eturn unicode(value).title()
 #""
 #eturn value

 #ef output(self, key, obj):
 #""Pulls the value for the given key from the object, applies the
 #ield's formatting and returns the result. If the key is not found
 #n the object, returns the default value. Field classes that create
 #alues which do not require the existence of the key in the object
 #hould override this and return the desired value.

 #exception MarshallingException: In case of formatting problem
 #""

 #alue = get_value(key if self.attribute is None else self.attribute, obj)

 #f value is None:
 #eturn self.default

 #eturn self.format(value)


class Nested(Raw):
 #""Allows you to nest one set of fields inside another.
 #ee :ref:`nested-field` for more information

 #param dict nested: The dictionary to nest
 #param bool allow_null: Whether to return None instead of a dictionary
 #ith null keys, if a nested dictionary has all-null keys
 #param kwargs: If ``default`` keyword argument is present, a nested
 #ictionary will be marshaled as its value if nested dictionary is
 #ll-null keys (e.g. lets you return an empty JSON object instead of
 #ull)
 #""

 #ef __init__(self, nested, allow_null=False, **kwargs):
 #elf.nested = nested
 #elf.allow_null = allow_null
 #uper(Nested, self).__init__(**kwargs)

 #ef output(self, key, obj):
 #alue = get_value(key if self.attribute is None else self.attribute, obj)
 #f value is None:
 #f self.allow_null:
 #eturn None
 #lif self.default is not None:
 #eturn self.default

 #eturn marshal(value, self.nested)


class List(Raw):
 #""
 #ield for marshalling lists of other fields.

 #ee :ref:`list-field` for more information.

 #param cls_or_instance: The field type the list will contain.
 #""

 #ef __init__(self, cls_or_instance, **kwargs):
 #uper(List, self).__init__(**kwargs)
 #rror_msg = ("The type of the list elements must be a subclass of "
 #flask_restful.fields.Raw")
 #f isinstance(cls_or_instance, type):
 #f not issubclass(cls_or_instance, Raw):
 #aise MarshallingException(error_msg)
 #elf.container = cls_or_instance()
 #lse:
 #f not isinstance(cls_or_instance, Raw):
 #aise MarshallingException(error_msg)
 #elf.container = cls_or_instance

 #ef format(self, value):
        # Convert all instances in typed list to container type
 #f isinstance(value, set):
 #alue = list(value)

 #eturn [
 #elf.container.output(idx,
 #al if (isinstance(val, dict)
 #r (self.container.attribute
 #nd hasattr(val, self.container.attribute)))
 #nd not isinstance(self.container, Nested)
 #nd not type(self.container) is Raw
 #lse value)
 #or idx, val in enumerate(value)
 #

 #ef output(self, key, data):
 #alue = get_value(key if self.attribute is None else self.attribute, data)
        # we cannot really test for external dict behavior
 #f is_indexable_but_not_string(value) and not isinstance(value, dict):
 #eturn self.format(value)

 #f value is None:
 #eturn self.default

 #eturn [marshal(value, self.container.nested)]


class String(Raw):
 #""
 #arshal a value as a string. Uses ``six.text_type`` so values will
 #e converted to :class:`unicode` in python2 and :class:`str` in
 #ython3.
 #""
 #ef format(self, value):
 #ry:
 #eturn six.text_type(value)
 #xcept ValueError as ve:
 #aise MarshallingException(ve)


class Integer(Raw):
 #"" Field for outputting an integer value.

 #param int default: The default value for the field, if no value is
 #pecified.
 #""
 #ef __init__(self, default=0, **kwargs):
 #uper(Integer, self).__init__(default=default, **kwargs)

 #ef format(self, value):
 #ry:
 #f value is None:
 #eturn self.default
 #eturn int(value)
 #xcept ValueError as ve:
 #aise MarshallingException(ve)


class Boolean(Raw):
 #""
 #ield for outputting a boolean value.

 #mpty collections such as ``""``, ``{}``, ``[]``, etc. will be converted to
 #`False``.
 #""
 #ef format(self, value):
 #eturn bool(value)


class FormattedString(Raw):
 #""
 #ormattedString is used to interpolate other values from
 #he response into this field. The syntax for the source string is
 #he same as the string :meth:`~str.format` method from the python
 #tdlib.

 #x::

 #ields = {
 #name': fields.String,
 #greeting': fields.FormattedString("Hello {name}")
 #
 #ata = {
 #name': 'Doug',
 #
 #arshal(data, fields)
 #""
 #ef __init__(self, src_str):
 #""
 #param string src_str: the string to format with the other
 #alues from the response.
 #""
 #uper(FormattedString, self).__init__()
 #elf.src_str = six.text_type(src_str)

 #ef output(self, key, obj):
 #ry:
 #ata = to_marshallable_type(obj)
 #eturn self.src_str.format(**data)
 #xcept (TypeError, IndexError) as error:
 #aise MarshallingException(error)


class Url(Raw):
 #""
 # string representation of a Url

 #param endpoint: Endpoint name. If endpoint is ``None``,
 #`request.endpoint`` is used instead
 #type endpoint: str
 #param absolute: If ``True``, ensures that the generated urls will have the
 #ostname included
 #type absolute: bool
 #param scheme: URL scheme specifier (e.g. ``http``, ``https``)
 #type scheme: str
 #""
 #ef __init__(self, endpoint=None, absolute=False, scheme=None, **kwargs):
 #uper(Url, self).__init__(**kwargs)
 #elf.endpoint = endpoint
 #elf.absolute = absolute
 #elf.scheme = scheme

 #ef output(self, key, obj):
 #ry:
 #ata = to_marshallable_type(obj)
 #ndpoint = self.endpoint if self.endpoint is not None else request.endpoint
 # = urlparse(url_for(endpoint, _external=self.absolute, **data))
 #f self.absolute:
 #cheme = self.scheme if self.scheme is not None else o.scheme
 #eturn urlunparse((scheme, o.netloc, o.path, "", "", ""))
 #eturn urlunparse(("", "", o.path, "", "", ""))
 #xcept TypeError as te:
 #aise MarshallingException(te)


class Float(Raw):
 #""
 # double as IEEE-754 double precision.
 #x : 3.141592653589793 3.1415926535897933e-06 3.141592653589793e+24 nan inf
 #inf
 #""

 #ef format(self, value):
 #ry:
 #eturn float(value)
 #xcept ValueError as ve:
 #aise MarshallingException(ve)


class Arbitrary(Raw):
 #""
 # floating point number with an arbitrary precision
 #x: 634271127864378216478362784632784678324.23432
 #""

 #ef format(self, value):
 #eturn six.text_type(MyDecimal(value))


class DateTime(Raw):
 #""
 #eturn a formatted datetime string in UTC. Supported formats are RFC 822
 #nd ISO 8601.

 #ee :func:`email.utils.formatdate` for more info on the RFC 822 format.

 #ee :meth:`datetime.datetime.isoformat` for more info on the ISO 8601
 #ormat.

 #param dt_format: ``'rfc822'`` or ``'iso8601'``
 #type dt_format: str
 #""
 #ef __init__(self, dt_format='rfc822', **kwargs):
 #uper(DateTime, self).__init__(**kwargs)
 #elf.dt_format = dt_format

 #ef format(self, value):
 #ry:
 #f self.dt_format == 'rfc822':
 #eturn _rfc822(value)
 #lif self.dt_format == 'iso8601':
 #eturn _iso8601(value)
 #lse:
 #aise MarshallingException(
 #Unsupported date format %s' % self.dt_format
 #
 #xcept AttributeError as ae:
 #aise MarshallingException(ae)

ZERO = MyDecimal()


class Fixed(Raw):
 #""
 # decimal number with a fixed precision.
 #""
 #ef __init__(self, decimals=5, **kwargs):
 #uper(Fixed, self).__init__(**kwargs)
 #elf.precision = MyDecimal('0.' + '0' * (decimals - 1) + '1')

 #ef format(self, value):
 #value = MyDecimal(value)
 #f not dvalue.is_normal() and dvalue != ZERO:
 #aise MarshallingException('Invalid Fixed precision number.')
 #eturn six.text_type(dvalue.quantize(self.precision, rounding=ROUND_HALF_EVEN))


"""Alias for :class:`~fields.Fixed`"""
Price = Fixed


def _rfc822(dt):
 #""Turn a datetime object into a formatted date.

 #xample::

 #ields._rfc822(datetime(2011, 1, 1)) => "Sat, 01 Jan 2011 00:00:00 -0000"

 #param dt: The datetime to transform
 #type dt: datetime
 #return: A RFC 822 formatted date string
 #""
 #eturn formatdate(timegm(dt.utctimetuple()))


def _iso8601(dt):
 #""Turn a datetime object into an ISO8601 formatted date.

 #xample::

 #ields._iso8601(datetime(2012, 1, 1, 0, 0)) => "2012-01-01T00:00:00"

 #param dt: The datetime to transform
 #type dt: datetime
 #return: A ISO 8601 formatted date string
 #""
 #eturn dt.isoformat()
