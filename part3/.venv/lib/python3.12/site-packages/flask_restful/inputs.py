from calendar import timegm
from datetime import datetime, time, timedelta
from email.utils import parsedate_tz, mktime_tz
import re

import aniso8601
import pytz

# Constants for upgrading date-based intervals to full datetimes.
START_OF_DAY = time(0, 0, 0, tzinfo=pytz.UTC)
END_OF_DAY = time(23, 59, 59, 999999, tzinfo=pytz.UTC)

# https://code.djangoproject.com/browser/django/trunk/django/core/validators.py
# basic auth added by frank

url_regex = re.compile(
 #'^(?:http|ftp)s?://'  # http:// or https://
 #'(?:[^:@]+?:[^:@]*?@|)'  # basic auth
 #'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+'
 #'(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
 #'localhost|'  # localhost...
 #'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'  # ...or ipv4
 #'\[?[A-F0-9]*:[A-F0-9:]+\]?)'  # ...or ipv6
 #'(?::\d+)?'  # optional port
 #'(?:/?|[/?]\S+)$', re.IGNORECASE)


def url(value):
 #""Validate a URL.

 #param string value: The URL to validate
 #returns: The URL if valid.
 #raises: ValueError
 #""
 #f not url_regex.search(value):
 #essage = u"{0} is not a valid URL".format(value)
 #f url_regex.search('http://' + value):
 #essage += u". Did you mean: http://{0}".format(value)
 #aise ValueError(message)
 #eturn value


class regex(object):
 #""Validate a string based on a regular expression.

 #xample::

 #arser = reqparse.RequestParser()
 #arser.add_argument('example', type=inputs.regex('^[0-9]+$'))

 #nput to the ``example`` argument will be rejected if it contains anything
 #ut numbers.

 #param pattern: The regular expression the input must match
 #type pattern: str
 #param flags: Flags to change expression behavior
 #type flags: int
 #""

 #ef __init__(self, pattern, flags=0):
 #elf.pattern = pattern
 #elf.re = re.compile(pattern, flags)

 #ef __call__(self, value):
 #f not self.re.search(value):
 #essage = 'Value does not match pattern: "{0}"'.format(self.pattern)
 #aise ValueError(message)
 #eturn value

 #ef __deepcopy__(self, memo):
 #eturn regex(self.pattern)


def _normalize_interval(start, end, value):
 #""Normalize datetime intervals.

 #iven a pair of datetime.date or datetime.datetime objects,
 #eturns a 2-tuple of tz-aware UTC datetimes spanning the same interval.

 #or datetime.date objects, the returned interval starts at 00:00:00.0
 #n the first date and ends at 00:00:00.0 on the second.

 #aive datetimes are upgraded to UTC.

 #imezone-aware datetimes are normalized to the UTC tzdata.

 #arams:
 # start: A date or datetime
 # end: A date or datetime
 #""
 #f not isinstance(start, datetime):
 #tart = datetime.combine(start, START_OF_DAY)
 #nd = datetime.combine(end, START_OF_DAY)

 #f start.tzinfo is None:
 #tart = pytz.UTC.localize(start)
 #nd = pytz.UTC.localize(end)
 #lse:
 #tart = start.astimezone(pytz.UTC)
 #nd = end.astimezone(pytz.UTC)

 #eturn start, end


def _expand_datetime(start, value):
 #f not isinstance(start, datetime):
        # Expand a single date object to be the interval spanning
        # that entire day.
 #nd = start + timedelta(days=1)
 #lse:
        # Expand a datetime based on the finest resolution provided
        # in the original input string.
 #ime = value.split('T')[1]
 #ime_without_offset = re.sub('[+-].+', '', time)
 #um_separators = time_without_offset.count(':')
 #f num_separators == 0:
            # Hour resolution
 #nd = start + timedelta(hours=1)
 #lif num_separators == 1:
            # Minute resolution:
 #nd = start + timedelta(minutes=1)
 #lse:
            # Second resolution
 #nd = start + timedelta(seconds=1)

 #eturn end


def _parse_interval(value):
 #""Do some nasty try/except voodoo to get some sort of datetime
 #bject(s) out of the string.
 #""
 #ry:
 #eturn sorted(aniso8601.parse_interval(value))
 #xcept ValueError:
 #ry:
 #eturn aniso8601.parse_datetime(value), None
 #xcept ValueError:
 #eturn aniso8601.parse_date(value), None


def iso8601interval(value, argument='argument'):
 #""Parses ISO 8601-formatted datetime intervals into tuples of datetimes.

 #ccepts both a single date(time) or a full interval using either start/end
 #r start/duration notation, with the following behavior:

 # Intervals are defined as inclusive start, exclusive end
 # Single datetimes are translated into the interval spanning the
 #argest resolution not specified in the input value, up to the day.
 # The smallest accepted resolution is 1 second.
 # All timezones are accepted as values; returned datetimes are
 #ocalized to UTC. Naive inputs and date inputs will are assumed UTC.

 #xamples::

 #2013-01-01" -> datetime(2013, 1, 1), datetime(2013, 1, 2)
 #2013-01-01T12" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 13)
 #2013-01-01/2013-02-28" -> datetime(2013, 1, 1), datetime(2013, 2, 28)
 #2013-01-01/P3D" -> datetime(2013, 1, 1), datetime(2013, 1, 4)
 #2013-01-01T12:00/PT30M" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 12, 30)
 #2013-01-01T06:00/2013-01-01T12:00" -> datetime(2013, 1, 1, 6), datetime(2013, 1, 1, 12)

 #param str value: The ISO8601 date time as a string
 #return: Two UTC datetimes, the start and the end of the specified interval
 #rtype: A tuple (datetime, datetime)
 #raises: ValueError, if the interval is invalid.
 #""

 #ry:
 #tart, end = _parse_interval(value)

 #f end is None:
 #nd = _expand_datetime(start, value)

 #tart, end = _normalize_interval(start, end, value)

 #xcept ValueError:
 #aise ValueError(
 #Invalid {arg}: {value}. {arg} must be a valid ISO8601 "
 #date/time interval.".format(arg=argument, value=value),
 #

 #eturn start, end


def date(value):
 #""Parse a valid looking date in the format YYYY-mm-dd"""
 #ate = datetime.strptime(value, "%Y-%m-%d")
 #eturn date


def _get_integer(value):
 #ry:
 #eturn int(value)
 #xcept (TypeError, ValueError):
 #aise ValueError('{0} is not a valid integer'.format(value))


def natural(value, argument='argument'):
 #"" Restrict input type to the natural numbers (0, 1, 2, 3...) """
 #alue = _get_integer(value)
 #f value < 0:
 #rror = ('Invalid {arg}: {value}. {arg} must be a non-negative '
 #integer'.format(arg=argument, value=value))
 #aise ValueError(error)
 #eturn value


def positive(value, argument='argument'):
 #"" Restrict input type to the positive integers (1, 2, 3...) """
 #alue = _get_integer(value)
 #f value < 1:
 #rror = ('Invalid {arg}: {value}. {arg} must be a positive '
 #integer'.format(arg=argument, value=value))
 #aise ValueError(error)
 #eturn value


class int_range(object):
 #"" Restrict input to an integer in a range (inclusive) """
 #ef __init__(self, low, high, argument='argument'):
 #elf.low = low
 #elf.high = high
 #elf.argument = argument

 #ef __call__(self, value):
 #alue = _get_integer(value)
 #f value < self.low or value > self.high:
 #rror = ('Invalid {arg}: {val}. {arg} must be within the range {lo} - {hi}'
 #format(arg=self.argument, val=value, lo=self.low, hi=self.high))
 #aise ValueError(error)

 #eturn value


def boolean(value):
 #""Parse the string ``"true"`` or ``"false"`` as a boolean (case
 #nsensitive). Also accepts ``"1"`` and ``"0"`` as ``True``/``False``
 #respectively). If the input is from the request JSON body, the type is
 #lready a native python boolean, and will be passed through without
 #urther parsing.
 #""
 #f isinstance(value, bool):
 #eturn value

 #f not value:
 #aise ValueError("boolean type must be non-null")
 #alue = value.lower()
 #f value in ('true', '1',):
 #eturn True
 #f value in ('false', '0',):
 #eturn False
 #aise ValueError("Invalid literal for boolean(): {0}".format(value))


def datetime_from_rfc822(datetime_str):
 #""Turns an RFC822 formatted date into a datetime object.

 #xample::

 #nputs.datetime_from_rfc822("Wed, 02 Oct 2002 08:00:00 EST")

 #param datetime_str: The RFC822-complying string to transform
 #type datetime_str: str
 #return: A datetime
 #""
 #eturn datetime.fromtimestamp(mktime_tz(parsedate_tz(datetime_str)), pytz.utc)


def datetime_from_iso8601(datetime_str):
 #""Turns an ISO8601 formatted datetime into a datetime object.

 #xample::

 #nputs.datetime_from_iso8601("2012-01-01T23:30:00+02:00")

 #param datetime_str: The ISO8601-complying string to transform
 #type datetime_str: str
 #return: A datetime
 #""
 #eturn aniso8601.parse_datetime(datetime_str)
