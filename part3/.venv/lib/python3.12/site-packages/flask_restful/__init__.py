from __future__ import absolute_import
from functools import wraps, partial
from flask import request, url_for, current_app
from flask import abort as original_flask_abort
from flask import make_response as original_flask_make_response
from flask.views import MethodView
from flask.signals import got_request_exception
from werkzeug.datastructures import Headers
from werkzeug.exceptions import HTTPException, MethodNotAllowed, NotFound, NotAcceptable, InternalServerError
from werkzeug.wrappers import Response as ResponseBase
from flask_restful.utils import http_status_message, unpack, OrderedDict
from flask_restful.representations.json import output_json
import sys
from types import MethodType
import operator
try:
 #rom collections.abc import Mapping
except ImportError:
 #rom collections import Mapping


__all__ = ('Api', 'Resource', 'marshal', 'marshal_with', 'marshal_with_field', 'abort')


def abort(http_status_code, **kwargs):
 #""Raise a HTTPException for the given http_status_code. Attach any keyword
 #rguments to the exception for later processing.
 #""
    #noinspection PyUnresolvedReferences
 #ry:
 #riginal_flask_abort(http_status_code)
 #xcept HTTPException as e:
 #f len(kwargs):
 #.data = kwargs
 #aise

DEFAULT_REPRESENTATIONS = [('application/json', output_json)]


class Api(object):
 #""
 #he main entry point for the application.
 #ou need to initialize it with a Flask Application: ::

 #>> app = Flask(__name__)
 #>> api = restful.Api(app)

 #lternatively, you can use :meth:`init_app` to set the Flask application
 #fter it has been constructed.

 #param app: the Flask application object
 #type app: flask.Flask or flask.Blueprint
 #param prefix: Prefix all routes with a value, eg v1 or 2010-04-01
 #type prefix: str
 #param default_mediatype: The default media type to return
 #type default_mediatype: str
 #param decorators: Decorators to attach to every resource
 #type decorators: list
 #param catch_all_404s: Use :meth:`handle_error`
 #o handle 404 errors throughout your app
 #param serve_challenge_on_401: Whether to serve a challenge response to
 #lients on receiving 401. This usually leads to a username/password
 #opup in web browsers.
 #param url_part_order: A string that controls the order that the pieces
 #f the url are concatenated when the full url is constructed.  'b'
 #s the blueprint (or blueprint registration) prefix, 'a' is the api
 #refix, and 'e' is the path component the endpoint is added with
 #type catch_all_404s: bool
 #param errors: A dictionary to define a custom response for each
 #xception or error raised during a request
 #type errors: dict

 #""

 #ef __init__(self, app=None, prefix='',
 #efault_mediatype='application/json', decorators=None,
 #atch_all_404s=False, serve_challenge_on_401=False,
 #rl_part_order='bae', errors=None):
 #elf.representations = OrderedDict(DEFAULT_REPRESENTATIONS)
 #elf.urls = {}
 #elf.prefix = prefix
 #elf.default_mediatype = default_mediatype
 #elf.decorators = decorators if decorators else []
 #elf.catch_all_404s = catch_all_404s
 #elf.serve_challenge_on_401 = serve_challenge_on_401
 #elf.url_part_order = url_part_order
 #elf.errors = errors or {}
 #elf.blueprint_setup = None
 #elf.endpoints = set()
 #elf.resources = []
 #elf.app = None
 #elf.blueprint = None

 #f app is not None:
 #elf.app = app
 #elf.init_app(app)

 #ef init_app(self, app):
 #""Initialize this class with the given :class:`flask.Flask`
 #pplication or :class:`flask.Blueprint` object.

 #param app: the Flask application or blueprint object
 #type app: flask.Flask
 #type app: flask.Blueprint

 #xamples::

 #pi = Api()
 #pi.add_resource(...)
 #pi.init_app(app)

 #""
        # If app is a blueprint, defer the initialization
 #ry:
 #pp.record(self._deferred_blueprint_init)
        # Flask.Blueprint has a 'record' attribute, Flask.Api does not
 #xcept AttributeError:
 #elf._init_app(app)
 #lse:
 #elf.blueprint = app

 #ef _complete_url(self, url_part, registration_prefix):
 #""This method is used to defer the construction of the final url in
 #he case that the Api is created with a Blueprint.

 #param url_part: The part of the url the endpoint is registered with
 #param registration_prefix: The part of the url contributed by the
 #lueprint.  Generally speaking, BlueprintSetupState.url_prefix
 #""
 #arts = {
 #b': registration_prefix,
 #a': self.prefix,
 #e': url_part
 #
 #eturn ''.join(parts[key] for key in self.url_part_order if parts[key])

 #staticmethod
 #ef _blueprint_setup_add_url_rule_patch(blueprint_setup, rule, endpoint=None, view_func=None, **options):
 #""Method used to patch BlueprintSetupState.add_url_rule for setup
 #tate instance corresponding to this Api instance.  Exists primarily
 #o enable _complete_url's function.

 #param blueprint_setup: The BlueprintSetupState instance (self)
 #param rule: A string or callable that takes a string and returns a
 #tring(_complete_url) that is the url rule for the endpoint
 #eing registered
 #param endpoint: See BlueprintSetupState.add_url_rule
 #param view_func: See BlueprintSetupState.add_url_rule
 #param **options: See BlueprintSetupState.add_url_rule
 #""

 #f callable(rule):
 #ule = rule(blueprint_setup.url_prefix)
 #lif blueprint_setup.url_prefix:
 #ule = blueprint_setup.url_prefix + rule
 #ptions.setdefault('subdomain', blueprint_setup.subdomain)
 #f endpoint is None:
 #ndpoint = view_func.__name__
 #efaults = blueprint_setup.url_defaults
 #f 'defaults' in options:
 #efaults = dict(defaults, **options.pop('defaults'))
 #lueprint_setup.app.add_url_rule(rule, '%s.%s' % (blueprint_setup.blueprint.name, endpoint),
 #iew_func, defaults=defaults, **options)

 #ef _deferred_blueprint_init(self, setup_state):
 #""Synchronize prefix between blueprint/api and registration options, then
 #erform initialization with setup_state.app :class:`flask.Flask` object.
 #hen a :class:`flask_restful.Api` object is initialized with a blueprint,
 #his method is recorded on the blueprint to be run when the blueprint is later
 #egistered to a :class:`flask.Flask` object.  This method also monkeypatches
 #lueprintSetupState.add_url_rule with _blueprint_setup_add_url_rule_patch.

 #param setup_state: The setup state object passed to deferred functions
 #uring blueprint registration
 #type setup_state: flask.blueprints.BlueprintSetupState

 #""

 #elf.blueprint_setup = setup_state
 #f setup_state.add_url_rule.__name__ != '_blueprint_setup_add_url_rule_patch':
 #etup_state._original_add_url_rule = setup_state.add_url_rule
 #etup_state.add_url_rule = MethodType(Api._blueprint_setup_add_url_rule_patch,
 #etup_state)
 #f not setup_state.first_registration:
 #aise ValueError('flask-restful blueprints can only be registered once.')
 #elf._init_app(setup_state.app)

 #ef _init_app(self, app):
 #""Perform initialization actions with the given :class:`flask.Flask`
 #bject.

 #param app: The flask application object
 #type app: flask.Flask
 #""
 #pp.handle_exception = partial(self.error_router, app.handle_exception)
 #pp.handle_user_exception = partial(self.error_router, app.handle_user_exception)

 #f len(self.resources) > 0:
 #or resource, urls, kwargs in self.resources:
 #elf._register_view(app, resource, *urls, **kwargs)

 #ef owns_endpoint(self, endpoint):
 #""Tests if an endpoint name (not path) belongs to this Api.  Takes
 #n to account the Blueprint name part of the endpoint name.

 #param endpoint: The name of the endpoint being checked
 #return: bool
 #""

 #f self.blueprint:
 #f endpoint.startswith(self.blueprint.name):
 #ndpoint = endpoint.split(self.blueprint.name + '.', 1)[-1]
 #lse:
 #eturn False
 #eturn endpoint in self.endpoints

 #ef _should_use_fr_error_handler(self):
 #"" Determine if error should be handled with FR or default Flask

 #he goal is to return Flask error handlers for non-FR-related routes,
 #nd FR errors (with the correct media type) for FR endpoints. This
 #ethod currently handles 404 and 405 errors.

 #return: bool
 #""
 #dapter = current_app.create_url_adapter(request)

 #ry:
 #dapter.match()
 #xcept MethodNotAllowed as e:
            # Check if the other HTTP methods at this url would hit the Api
 #alid_route_method = e.valid_methods[0]
 #ule, _ = adapter.match(method=valid_route_method, return_rule=True)
 #eturn self.owns_endpoint(rule.endpoint)
 #xcept NotFound:
 #eturn self.catch_all_404s
 #xcept:
            # Werkzeug throws other kinds of exceptions, such as Redirect
 #ass

 #ef _has_fr_route(self):
 #""Encapsulating the rules for whether the request was to a Flask endpoint"""
        # 404's, 405's, which might not have a url_rule
 #f self._should_use_fr_error_handler():
 #eturn True
        # for all other errors, just check if FR dispatched the route
 #f not request.url_rule:
 #eturn False
 #eturn self.owns_endpoint(request.url_rule.endpoint)

 #ef error_router(self, original_handler, e):
 #""This function decides whether the error occured in a flask-restful
 #ndpoint or not. If it happened in a flask-restful endpoint, our
 #andler will be dispatched. If it happened in an unrelated view, the
 #pp's original error handler will be dispatched.
 #n the event that the error occurred in a flask-restful endpoint but
 #he local handler can't resolve the situation, the router will fall
 #ack onto the original_handler as last resort.

 #param original_handler: the original Flask error handler for the app
 #type original_handler: function
 #param e: the exception raised while handling the request
 #type e: Exception

 #""
 #f self._has_fr_route():
 #ry:
 #eturn self.handle_error(e)
 #xcept Exception:
 #ass  # Fall through to original handler
 #eturn original_handler(e)

 #ef handle_error(self, e):
 #""Error handler for the API transforms a raised exception into a Flask
 #esponse, with the appropriate HTTP status code and body.

 #param e: the raised Exception object
 #type e: Exception

 #""
 #ot_request_exception.send(current_app._get_current_object(), exception=e)

 #f not isinstance(e, HTTPException) and current_app.propagate_exceptions:
 #xc_type, exc_value, tb = sys.exc_info()
 #f exc_value is e:
 #aise
 #lse:
 #aise e

 #eaders = Headers()
 #f isinstance(e, HTTPException):
 #f e.response is not None:
                # If HTTPException is initialized with a response, then return e.get_response().
                # This prevents specified error response from being overridden.
                # eg. HTTPException(response=Response("Hello World"))
 #esp = e.get_response()
 #eturn resp

 #ode = e.code
 #efault_data = {
 #message': getattr(e, 'description', http_status_message(code))
 #
 #eaders = e.get_response().headers
 #lse:
 #ode = 500
 #efault_data = {
 #message': http_status_message(code),
 #

        # Werkzeug exceptions generate a content-length header which is added
        # to the response in addition to the actual content-length header
        # https://github.com/flask-restful/flask-restful/issues/534
 #emove_headers = ('Content-Length',)

 #or header in remove_headers:
 #eaders.pop(header, None)

 #ata = getattr(e, 'data', default_data)

 #f code and code >= 500:
 #xc_info = sys.exc_info()
 #f exc_info[1] is None:
 #xc_info = None
 #urrent_app.log_exception(exc_info)

 #rror_cls_name = type(e).__name__
 #f error_cls_name in self.errors:
 #ustom_data = self.errors.get(error_cls_name, {})
 #ode = custom_data.get('status', 500)
 #ata.update(custom_data)

 #f code == 406 and self.default_mediatype is None:
            # if we are handling NotAcceptable (406), make sure that
            # make_response uses a representation we support as the
            # default mediatype (so that make_response doesn't throw
            # another NotAcceptable error).
 #upported_mediatypes = list(self.representations.keys())
 #allback_mediatype = supported_mediatypes[0] if supported_mediatypes else "text/plain"
 #esp = self.make_response(
 #ata,
 #ode,
 #eaders,
 #allback_mediatype = fallback_mediatype
 #
 #lse:
 #esp = self.make_response(data, code, headers)

 #f code == 401:
 #esp = self.unauthorized(resp)
 #eturn resp

 #ef mediatypes_method(self):
 #""Return a method that returns a list of mediatypes
 #""
 #eturn lambda resource_cls: self.mediatypes() + [self.default_mediatype]

 #ef add_resource(self, resource, *urls, **kwargs):
 #""Adds a resource to the api.

 #param resource: the class name of your resource
 #type resource: :class:`Type[Resource]`

 #param urls: one or more url routes to match for the resource, standard
 #lask routing rules apply.  Any url variables will be
 #assed to the resource method as args.
 #type urls: str

 #param endpoint: endpoint name (defaults to :meth:`Resource.__name__.lower`
 #an be used to reference this route in :class:`fields.Url` fields
 #type endpoint: str

 #param resource_class_args: args to be forwarded to the constructor of
 #he resource.
 #type resource_class_args: tuple

 #param resource_class_kwargs: kwargs to be forwarded to the constructor
 #f the resource.
 #type resource_class_kwargs: dict

 #dditional keyword arguments not specified above will be passed as-is
 #o :meth:`flask.Flask.add_url_rule`.

 #xamples::

 #pi.add_resource(HelloWorld, '/', '/hello')
 #pi.add_resource(Foo, '/foo', endpoint="foo")
 #pi.add_resource(FooSpecial, '/special/foo', endpoint="foo")

 #""
 #f self.app is not None:
 #elf._register_view(self.app, resource, *urls, **kwargs)
 #lse:
 #elf.resources.append((resource, urls, kwargs))

 #ef resource(self, *urls, **kwargs):
 #""Wraps a :class:`~flask_restful.Resource` class, adding it to the
 #pi. Parameters are the same as :meth:`~flask_restful.Api.add_resource`.

 #xample::

 #pp = Flask(__name__)
 #pi = restful.Api(app)

 #api.resource('/foo')
 #lass Foo(Resource):
 #ef get(self):
 #eturn 'Hello, World!'

 #""
 #ef decorator(cls):
 #elf.add_resource(cls, *urls, **kwargs)
 #eturn cls
 #eturn decorator

 #ef _register_view(self, app, resource, *urls, **kwargs):
 #ndpoint = kwargs.pop('endpoint', None) or resource.__name__.lower()
 #elf.endpoints.add(endpoint)
 #esource_class_args = kwargs.pop('resource_class_args', ())
 #esource_class_kwargs = kwargs.pop('resource_class_kwargs', {})

        # NOTE: 'view_functions' is cleaned up from Blueprint class in Flask 1.0
 #f endpoint in getattr(app, 'view_functions', {}):
 #revious_view_class = app.view_functions[endpoint].__dict__['view_class']

            # if you override the endpoint with a different class, avoid the collision by raising an exception
 #f previous_view_class != resource:
 #aise ValueError('This endpoint (%s) is already set to the class %s.' % (endpoint, previous_view_class.__name__))

 #esource.mediatypes = self.mediatypes_method()  # Hacky
 #esource.endpoint = endpoint
 #esource_func = self.output(resource.as_view(endpoint, *resource_class_args,
 #*resource_class_kwargs))

 #or decorator in self.decorators:
 #esource_func = decorator(resource_func)

 #or url in urls:
            # If this Api has a blueprint
 #f self.blueprint:
                # And this Api has been setup
 #f self.blueprint_setup:
                    # Set the rule to a string directly, as the blueprint is already
                    # set up.
 #elf.blueprint_setup.add_url_rule(url, view_func=resource_func, **kwargs)
 #ontinue
 #lse:
                    # Set the rule to a function that expects the blueprint prefix
                    # to construct the final url.  Allows deferment of url finalization
                    # in the case that the associated Blueprint has not yet been
                    # registered to an application, so we can wait for the registration
                    # prefix
 #ule = partial(self._complete_url, url)
 #lse:
                # If we've got no Blueprint, just build a url with no prefix
 #ule = self._complete_url(url, '')
            # Add the url to the application or blueprint
 #pp.add_url_rule(rule, view_func=resource_func, **kwargs)

 #ef output(self, resource):
 #""Wraps a resource (as a flask view function), for cases where the
 #esource does not directly return a response object

 #param resource: The resource as a flask view function
 #""
 #wraps(resource)
 #ef wrapper(*args, **kwargs):
 #esp = resource(*args, **kwargs)
 #f isinstance(resp, ResponseBase):  # There may be a better way to test
 #eturn resp
 #ata, code, headers = unpack(resp)
 #eturn self.make_response(data, code, headers=headers)
 #eturn wrapper

 #ef url_for(self, resource, **values):
 #""Generates a URL to the given resource.

 #orks like :func:`flask.url_for`."""
 #ndpoint = resource.endpoint
 #f self.blueprint:
 #ndpoint = '{0}.{1}'.format(self.blueprint.name, endpoint)
 #eturn url_for(endpoint, **values)

 #ef make_response(self, data, *args, **kwargs):
 #""Looks up the representation transformer for the requested media
 #ype, invoking the transformer to create a response object. This
 #efaults to default_mediatype if no transformer is found for the
 #equested mediatype. If default_mediatype is None, a 406 Not
 #cceptable response will be sent as per RFC 2616 section 14.1

 #param data: Python object containing response data to be transformed
 #""
 #efault_mediatype = kwargs.pop('fallback_mediatype', None) or self.default_mediatype
 #ediatype = request.accept_mimetypes.best_match(
 #elf.representations,
 #efault=default_mediatype,
 #
 #f mediatype is None:
 #aise NotAcceptable()
 #f mediatype in self.representations:
 #esp = self.representations[mediatype](data, *args, **kwargs)
 #esp.headers['Content-Type'] = mediatype
 #eturn resp
 #lif mediatype == 'text/plain':
 #esp = original_flask_make_response(str(data), *args, **kwargs)
 #esp.headers['Content-Type'] = 'text/plain'
 #eturn resp
 #lse:
 #aise InternalServerError()

 #ef mediatypes(self):
 #""Returns a list of requested mediatypes sent in the Accept header"""
 #eturn [h for h, q in sorted(request.accept_mimetypes,
 #ey=operator.itemgetter(1), reverse=True)]

 #ef representation(self, mediatype):
 #""Allows additional representation transformers to be declared for the
 #pi. Transformers are functions that must be decorated with this
 #ethod, passing the mediatype the transformer represents. Three
 #rguments are passed to the transformer:

 # The data to be represented in the response body
 # The http status code
 # A dictionary of headers

 #he transformer should convert the data appropriately for the mediatype
 #nd return a Flask response object.

 #x::

 #api.representation('application/xml')
 #ef xml(data, code, headers):
 #esp = make_response(convert_data_to_xml(data), code)
 #esp.headers.extend(headers)
 #eturn resp
 #""
 #ef wrapper(func):
 #elf.representations[mediatype] = func
 #eturn func
 #eturn wrapper

 #ef unauthorized(self, response):
 #"" Given a response, change it to ask for credentials """

 #f self.serve_challenge_on_401:
 #ealm = current_app.config.get("HTTP_BASIC_AUTH_REALM", "flask-restful")
 #hallenge = u"{0} realm=\"{1}\"".format("Basic", realm)

 #esponse.headers['WWW-Authenticate'] = challenge
 #eturn response


class Resource(MethodView):
 #""
 #epresents an abstract RESTful resource. Concrete resources should
 #xtend from this class and expose methods for each supported HTTP
 #ethod. If a resource is invoked with an unsupported HTTP method,
 #he API will return a response with status 405 Method Not Allowed.
 #therwise the appropriate method is called and passed all arguments
 #rom the url rule used when adding the resource to an Api instance. See
 #meth:`~flask_restful.Api.add_resource` for details.
 #""
 #epresentations = None
 #ethod_decorators = []

 #ef dispatch_request(self, *args, **kwargs):

        # Taken from flask
        #noinspection PyUnresolvedReferences
 #eth = getattr(self, request.method.lower(), None)
 #f meth is None and request.method == 'HEAD':
 #eth = getattr(self, 'get', None)
 #ssert meth is not None, 'Unimplemented method %r' % request.method

 #f isinstance(self.method_decorators, Mapping):
 #ecorators = self.method_decorators.get(request.method.lower(), [])
 #lse:
 #ecorators = self.method_decorators

 #or decorator in decorators:
 #eth = decorator(meth)

 #esp = meth(*args, **kwargs)

 #f isinstance(resp, ResponseBase):  # There may be a better way to test
 #eturn resp

 #epresentations = self.representations or OrderedDict()

        #noinspection PyUnresolvedReferences
 #ediatype = request.accept_mimetypes.best_match(representations, default=None)
 #f mediatype in representations:
 #ata, code, headers = unpack(resp)
 #esp = representations[mediatype](data, code, headers)
 #esp.headers['Content-Type'] = mediatype
 #eturn resp

 #eturn resp


def marshal(data, fields, envelope=None):
 #""Takes raw data (in the form of a dict, list, object) and a dict of
 #ields to output and filters the data based on those fields.

 #param data: the actual object(s) from which the fields are taken from
 #param fields: a dict of whose keys will make up the final serialized
 #esponse output
 #param envelope: optional key that will be used to envelop the serialized
 #esponse


 #>> from flask_restful import fields, marshal
 #>> data = { 'a': 100, 'b': 'foo' }
 #>> mfields = { 'a': fields.Raw }

 #>> marshal(data, mfields)
 #rderedDict([('a', 100)])

 #>> marshal(data, mfields, envelope='data')
 #rderedDict([('data', OrderedDict([('a', 100)]))])

 #""

 #ef make(cls):
 #f isinstance(cls, type):
 #eturn cls()
 #eturn cls

 #f isinstance(data, (list, tuple)):
 #eturn (OrderedDict([(envelope, [marshal(d, fields) for d in data])])
 #f envelope else [marshal(d, fields) for d in data])

 #tems = ((k, marshal(data, v) if isinstance(v, dict)
 #lse make(v).output(k, data))
 #or k, v in fields.items())
 #eturn OrderedDict([(envelope, OrderedDict(items))]) if envelope else OrderedDict(items)


class marshal_with(object):
 #""A decorator that apply marshalling to the return values of your methods.

 #>> from flask_restful import fields, marshal_with
 #>> mfields = { 'a': fields.Raw }
 #>> @marshal_with(mfields)
 #.. def get():
 #..     return { 'a': 100, 'b': 'foo' }
 #..
 #..
 #>> get()
 #rderedDict([('a', 100)])

 #>> @marshal_with(mfields, envelope='data')
 #.. def get():
 #..     return { 'a': 100, 'b': 'foo' }
 #..
 #..
 #>> get()
 #rderedDict([('data', OrderedDict([('a', 100)]))])

 #ee :meth:`flask_restful.marshal`
 #""
 #ef __init__(self, fields, envelope=None):
 #""
 #param fields: a dict of whose keys will make up the final
 #erialized response output
 #param envelope: optional key that will be used to envelop the serialized
 #esponse
 #""
 #elf.fields = fields
 #elf.envelope = envelope

 #ef __call__(self, f):
 #wraps(f)
 #ef wrapper(*args, **kwargs):
 #esp = f(*args, **kwargs)
 #f isinstance(resp, tuple):
 #ata, code, headers = unpack(resp)
 #eturn marshal(data, self.fields, self.envelope), code, headers
 #lse:
 #eturn marshal(resp, self.fields, self.envelope)
 #eturn wrapper


class marshal_with_field(object):
 #""
 # decorator that formats the return values of your methods with a single field.

 #>> from flask_restful import marshal_with_field, fields
 #>> @marshal_with_field(fields.List(fields.Integer))
 #.. def get():
 #..     return ['1', 2, 3.0]
 #..
 #>> get()
 #1, 2, 3]

 #ee :meth:`flask_restful.marshal_with`
 #""
 #ef __init__(self, field):
 #""
 #param field: a single field with which to marshal the output.
 #""
 #f isinstance(field, type):
 #elf.field = field()
 #lse:
 #elf.field = field

 #ef __call__(self, f):
 #wraps(f)
 #ef wrapper(*args, **kwargs):
 #esp = f(*args, **kwargs)

 #f isinstance(resp, tuple):
 #ata, code, headers = unpack(resp)
 #eturn self.field.format(data), code, headers
 #eturn self.field.format(resp)

 #eturn wrapper
