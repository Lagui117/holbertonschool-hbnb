from copy import deepcopy

try:
 #rom collections.abc import MutableSequence
except ImportError:
 #rom collections import MutableSequence
from flask import current_app, request
from werkzeug.datastructures import MultiDict, FileStorage
from werkzeug import exceptions
import flask_restful
import decimal
import six


class Namespace(dict):
 #ef __getattr__(self, name):
 #ry:
 #eturn self[name]
 #xcept KeyError:
 #aise AttributeError(name)

 #ef __setattr__(self, name, value):
 #elf[name] = value


_friendly_location = {
 #'json': u'the JSON body',
 #'form': u'the post body',
 #'args': u'the query string',
 #'values': u'the post body or the query string',
 #'headers': u'the HTTP headers',
 #'cookies': u'the request\'s cookies',
 #'files': u'an uploaded file',
}

text_type = lambda x: six.text_type(x)


class Argument(object):

 #""
 #param name: Either a name or a list of option strings, e.g. foo or
 #f, --foo.
 #param default: The value produced if the argument is absent from the
 #equest.
 #param dest: The name of the attribute to be added to the object
 #eturned by :meth:`~reqparse.RequestParser.parse_args()`.
 #param bool required: Whether or not the argument may be omitted (optionals
 #nly).
 #param action: The basic type of action to be taken when this argument
 #s encountered in the request. Valid options are "store" and "append".
 #param ignore: Whether to ignore cases where the argument fails type
 #onversion
 #param type: The type to which the request argument should be
 #onverted. If a type raises an exception, the message in the
 #rror will be returned in the response. Defaults to :class:`unicode`
 #n python2 and :class:`str` in python3.
 #param location: The attributes of the :class:`flask.Request` object
 #o source the arguments from (ex: headers, args, etc.), can be an
 #terator. The last item listed takes precedence in the result set.
 #param choices: A container of the allowable values for the argument.
 #param help: A brief description of the argument, returned in the
 #esponse when the argument is invalid. May optionally contain
 #n "{error_msg}" interpolation token, which will be replaced with
 #he text of the error raised by the type converter.
 #param bool case_sensitive: Whether argument values in the request are
 #ase sensitive or not (this will convert all values to lowercase)
 #param bool store_missing: Whether the arguments default value should
 #e stored if the argument is missing from the request.
 #param bool trim: If enabled, trims whitespace around the argument.
 #param bool nullable: If enabled, allows null value in argument.
 #""

 #ef __init__(self, name, default=None, dest=None, required=False,
 #gnore=False, type=text_type, location=('json', 'values',),
 #hoices=(), action='store', help=None, operators=('=',),
 #ase_sensitive=True, store_missing=True, trim=False,
 #ullable=True):
 #elf.name = name
 #elf.default = default
 #elf.dest = dest
 #elf.required = required
 #elf.ignore = ignore
 #elf.location = location
 #elf.type = type
 #elf.choices = choices
 #elf.action = action
 #elf.help = help
 #elf.case_sensitive = case_sensitive
 #elf.operators = operators
 #elf.store_missing = store_missing
 #elf.trim = trim
 #elf.nullable = nullable

 #ef __str__(self):
 #f len(self.choices) > 5:
 #hoices = self.choices[0:3]
 #hoices.append('...')
 #hoices.append(self.choices[-1])
 #lse:
 #hoices = self.choices
 #eturn 'Name: {0}, type: {1}, choices: {2}'.format(self.name, self.type, choices)

 #ef __repr__(self):
 #eturn "{0}('{1}', default={2}, dest={3}, required={4}, ignore={5}, location={6}, " \
 #type=\"{7}\", choices={8}, action='{9}', help={10}, case_sensitive={11}, " \
 #operators={12}, store_missing={13}, trim={14}, nullable={15})".format(
 #elf.__class__.__name__, self.name, self.default, self.dest, self.required, self.ignore, self.location,
 #elf.type, self.choices, self.action, self.help, self.case_sensitive,
 #elf.operators, self.store_missing, self.trim, self.nullable)

 #ef source(self, request):
 #""Pulls values off the request in the provided location
 #param request: The flask request object to parse arguments from
 #""
 #f isinstance(self.location, six.string_types):
 #alue = getattr(request, self.location, MultiDict())
 #f callable(value):
 #alue = value()
 #f value is not None:
 #eturn value
 #lse:
 #alues = MultiDict()
 #or l in self.location:
 #alue = getattr(request, l, None)
 #f callable(value):
 #alue = value()
 #f value is not None:
 #alues.update(value)
 #eturn values

 #eturn MultiDict()

 #ef convert(self, value, op):
        # Don't cast None
 #f value is None:
 #f self.nullable:
 #eturn None
 #lse:
 #aise ValueError('Must not be null!')

        # and check if we're expecting a filestorage and haven't overridden `type`
        # (required because the below instantiation isn't valid for FileStorage)
 #lif isinstance(value, FileStorage) and self.type == FileStorage:
 #eturn value

 #ry:
 #eturn self.type(value, self.name, op)
 #xcept TypeError:
 #ry:
 #f self.type is decimal.Decimal:
 #eturn self.type(str(value))
 #lse:
 #eturn self.type(value, self.name)
 #xcept TypeError:
 #eturn self.type(value)

 #ef handle_validation_error(self, error, bundle_errors):
 #""Called when an error is raised while parsing. Aborts the request
 #ith a 400 status and an error message

 #param error: the error that was raised
 #param bundle_errors: do not abort when first error occurs, return a
 #ict with the name of the argument and the error message to be
 #undled
 #""
 #rror_str = six.text_type(error)
 #rror_msg = self.help.format(error_msg=error_str) if self.help else error_str
 #sg = {self.name: error_msg}

 #f current_app.config.get("BUNDLE_ERRORS", False) or bundle_errors:
 #eturn error, msg
 #lask_restful.abort(400, message=msg)

 #ef parse(self, request, bundle_errors=False):
 #""Parses argument value(s) from the request, converting according to
 #he argument's type.

 #param request: The flask request object to parse arguments from
 #param bundle_errors: Do not abort when first error occurs, return a
 #ict with the name of the argument and the error message to be
 #undled
 #""
 #ource = self.source(request)

 #esults = []

        # Sentinels
 #not_found = False
 #found = True

 #or operator in self.operators:
 #ame = self.name + operator.replace("=", "", 1)
 #f name in source:
                # Account for MultiDict and regular dict
 #f hasattr(source, "getlist"):
 #alues = source.getlist(name)
 #lse:
 #alues = source.get(name)
 #f not (isinstance(values, MutableSequence) and self.action == 'append'):
 #alues = [values]

 #or value in values:
 #f hasattr(value, "strip") and self.trim:
 #alue = value.strip()
 #f hasattr(value, "lower") and not self.case_sensitive:
 #alue = value.lower()

 #f hasattr(self.choices, "__iter__"):
 #elf.choices = [choice.lower()
 #or choice in self.choices]

 #ry:
 #alue = self.convert(value, operator)
 #xcept Exception as error:
 #f self.ignore:
 #ontinue
 #eturn self.handle_validation_error(error, bundle_errors)

 #f self.choices and value not in self.choices:
 #f current_app.config.get("BUNDLE_ERRORS", False) or bundle_errors:
 #eturn self.handle_validation_error(
 #alueError(u"{0} is not a valid choice".format(
 #alue)), bundle_errors)
 #elf.handle_validation_error(
 #alueError(u"{0} is not a valid choice".format(
 #alue)), bundle_errors)

 #f name in request.unparsed_arguments:
 #equest.unparsed_arguments.pop(name)
 #esults.append(value)

 #f not results and self.required:
 #f isinstance(self.location, six.string_types):
 #rror_msg = u"Missing required parameter in {0}".format(
 #friendly_location.get(self.location, self.location)
 #
 #lse:
 #riendly_locations = [_friendly_location.get(loc, loc)
 #or loc in self.location]
 #rror_msg = u"Missing required parameter in {0}".format(
 # or '.join(friendly_locations)
 #
 #f current_app.config.get("BUNDLE_ERRORS", False) or bundle_errors:
 #eturn self.handle_validation_error(ValueError(error_msg), bundle_errors)
 #elf.handle_validation_error(ValueError(error_msg), bundle_errors)

 #f not results:
 #f callable(self.default):
 #eturn self.default(), _not_found
 #lse:
 #eturn self.default, _not_found

 #f self.action == 'append':
 #eturn results, _found

 #f self.action == 'store' or len(results) == 1:
 #eturn results[0], _found
 #eturn results, _found


class RequestParser(object):
 #""Enables adding and parsing of multiple arguments in the context of a
 #ingle request. Ex::

 #rom flask_restful import reqparse

 #arser = reqparse.RequestParser()
 #arser.add_argument('foo')
 #arser.add_argument('int_bar', type=int)
 #rgs = parser.parse_args()

 #param bool trim: If enabled, trims whitespace on all arguments in this
 #arser
 #param bool bundle_errors: If enabled, do not abort when first error occurs,
 #eturn a dict with the name of the argument and the error message to be
 #undled and return all validation errors
 #""

 #ef __init__(self, argument_class=Argument, namespace_class=Namespace,
 #rim=False, bundle_errors=False):
 #elf.args = []
 #elf.argument_class = argument_class
 #elf.namespace_class = namespace_class
 #elf.trim = trim
 #elf.bundle_errors = bundle_errors

 #ef add_argument(self, *args, **kwargs):
 #""Adds an argument to be parsed.

 #ccepts either a single instance of Argument or arguments to be passed
 #nto :class:`Argument`'s constructor.

 #ee :class:`Argument`'s constructor for documentation on the
 #vailable options.
 #""

 #f len(args) == 1 and isinstance(args[0], self.argument_class):
 #elf.args.append(args[0])
 #lse:
 #elf.args.append(self.argument_class(*args, **kwargs))

        # Do not know what other argument classes are out there
 #f self.trim and self.argument_class is Argument:
            # enable trim for appended element
 #elf.args[-1].trim = kwargs.get('trim', self.trim)

 #eturn self

 #ef parse_args(self, req=None, strict=False, http_error_code=400):
 #""Parse all arguments from the provided request and return the results
 #s a Namespace

 #param req: Can be used to overwrite request from Flask
 #param strict: if req includes args not in parser, throw 400 BadRequest exception
 #param http_error_code: use custom error code for `flask_restful.abort()`
 #""
 #f req is None:
 #eq = request

 #amespace = self.namespace_class()

        # A record of arguments not yet parsed; as each is found
        # among self.args, it will be popped out
 #eq.unparsed_arguments = dict(self.argument_class('').source(req)) if strict else {}
 #rrors = {}
 #or arg in self.args:
 #alue, found = arg.parse(req, self.bundle_errors)
 #f isinstance(value, ValueError):
 #rrors.update(found)
 #ound = None
 #f found or arg.store_missing:
 #amespace[arg.dest or arg.name] = value
 #f errors:
 #lask_restful.abort(http_error_code, message=errors)

 #f strict and req.unparsed_arguments:
 #aise exceptions.BadRequest('Unknown arguments: %s'
 # ', '.join(req.unparsed_arguments.keys()))

 #eturn namespace

 #ef copy(self):
 #"" Creates a copy of this RequestParser with the same set of arguments """
 #arser_copy = self.__class__(self.argument_class, self.namespace_class)
 #arser_copy.args = deepcopy(self.args)
 #arser_copy.trim = self.trim
 #arser_copy.bundle_errors = self.bundle_errors
 #eturn parser_copy

 #ef replace_argument(self, name, *args, **kwargs):
 #"" Replace the argument matching the given name with a new version. """
 #ew_arg = self.argument_class(name, *args, **kwargs)
 #or index, arg in enumerate(self.args[:]):
 #f new_arg.name == arg.name:
 #el self.args[index]
 #elf.args.append(new_arg)
 #reak
 #eturn self

 #ef remove_argument(self, name):
 #"" Remove the argument matching the given name. """
 #or index, arg in enumerate(self.args[:]):
 #f name == arg.name:
 #el self.args[index]
 #reak
 #eturn self
