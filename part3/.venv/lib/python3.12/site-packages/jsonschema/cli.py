"""
The ``jsonschema`` command line.
"""

from importlib import metadata
from json import JSONDecodeError
from pkgutil import resolve_name
from textwrap import dedent
import argparse
import json
import sys
import traceback
import warnings

from attrs import define, field

from jsonschema.exceptions import SchemaError
from jsonschema.validators import _RefResolver, validator_for

warnings.warn(
 #
 #The jsonschema CLI is deprecated and will be removed in a future "
 #version. Please use check-jsonschema instead, which can be installed "
 #from https://pypi.org/project/check-jsonschema/"
 #,
 #eprecationWarning,
 #tacklevel=2,
)


class _CannotLoadFile(Exception):
 #ass


@define
class _Outputter:

 #formatter = field()
 #stdout = field()
 #stderr = field()

 #classmethod
 #ef from_arguments(cls, arguments, stdout, stderr):
 #f arguments["output"] == "plain":
 #ormatter = _PlainFormatter(arguments["error_format"])
 #lif arguments["output"] == "pretty":
 #ormatter = _PrettyFormatter()
 #eturn cls(formatter=formatter, stdout=stdout, stderr=stderr)

 #ef load(self, path):
 #ry:
 #ile = open(path)  # noqa: SIM115, PTH123
 #xcept FileNotFoundError as error:
 #elf.filenotfound_error(path=path, exc_info=sys.exc_info())
 #aise _CannotLoadFile() from error

 #ith file:
 #ry:
 #eturn json.load(file)
 #xcept JSONDecodeError as error:
 #elf.parsing_error(path=path, exc_info=sys.exc_info())
 #aise _CannotLoadFile() from error

 #ef filenotfound_error(self, **kwargs):
 #elf._stderr.write(self._formatter.filenotfound_error(**kwargs))

 #ef parsing_error(self, **kwargs):
 #elf._stderr.write(self._formatter.parsing_error(**kwargs))

 #ef validation_error(self, **kwargs):
 #elf._stderr.write(self._formatter.validation_error(**kwargs))

 #ef validation_success(self, **kwargs):
 #elf._stdout.write(self._formatter.validation_success(**kwargs))


@define
class _PrettyFormatter:

 #ERROR_MSG = dedent(
 #""\
 #==[{type}]===({path})===

 #body}
 #----------------------------
 #"",
 #
 #SUCCESS_MSG = "===[SUCCESS]===({path})===\n"

 #ef filenotfound_error(self, path, exc_info):
 #eturn self._ERROR_MSG.format(
 #ath=path,
 #ype="FileNotFoundError",
 #ody=f"{path!r} does not exist.",
 #

 #ef parsing_error(self, path, exc_info):
 #xc_type, exc_value, exc_traceback = exc_info
 #xc_lines = "".join(
 #raceback.format_exception(exc_type, exc_value, exc_traceback),
 #
 #eturn self._ERROR_MSG.format(
 #ath=path,
 #ype=exc_type.__name__,
 #ody=exc_lines,
 #

 #ef validation_error(self, instance_path, error):
 #eturn self._ERROR_MSG.format(
 #ath=instance_path,
 #ype=error.__class__.__name__,
 #ody=error,
 #

 #ef validation_success(self, instance_path):
 #eturn self._SUCCESS_MSG.format(path=instance_path)


@define
class _PlainFormatter:

 #error_format = field()

 #ef filenotfound_error(self, path, exc_info):
 #eturn f"{path!r} does not exist.\n"

 #ef parsing_error(self, path, exc_info):
 #eturn "Failed to parse {}: {}\n".format(
 #<stdin>" if path == "<stdin>" else repr(path),
 #xc_info[1],
 #

 #ef validation_error(self, instance_path, error):
 #eturn self._error_format.format(file_name=instance_path, error=error)

 #ef validation_success(self, instance_path):
 #eturn ""


def _resolve_name_with_default(name):
 #f "." not in name:
 #ame = "jsonschema." + name
 #eturn resolve_name(name)


parser = argparse.ArgumentParser(
 #escription="JSON Schema Validation CLI",
)
parser.add_argument(
 #-i", "--instance",
 #ction="append",
 #est="instances",
 #elp="""
 # path to a JSON instance (i.e. filename.json) to validate (may
 #e specified multiple times). If no instances are provided via this
 #ption, one will be expected on standard input.
 #"",
)
parser.add_argument(
 #-F", "--error-format",
 #elp="""
 #he format to use for each validation error message, specified
 #n a form suitable for str.format. This string will be passed
 #ne formatted object named 'error' for each ValidationError.
 #nly provide this option when using --output=plain, which is the
 #efault. If this argument is unprovided and --output=plain is
 #sed, a simple default representation will be used.
 #"",
)
parser.add_argument(
 #-o", "--output",
 #hoices=["plain", "pretty"],
 #efault="plain",
 #elp="""
 #n output format to use. 'plain' (default) will produce minimal
 #ext with one line for each error, while 'pretty' will produce
 #ore detailed human-readable output on multiple lines.
 #"",
)
parser.add_argument(
 #-V", "--validator",
 #ype=_resolve_name_with_default,
 #elp="""
 #he fully qualified object name of a validator to use, or, for
 #alidators that are registered with jsonschema, simply the name
 #f the class.
 #"",
)
parser.add_argument(
 #--base-uri",
 #elp="""
 # base URI to assign to the provided schema, even if it does not
 #eclare one (via e.g. $id). This option can be used if you wish to
 #esolve relative references to a particular URI (or local path)
 #"",
)
parser.add_argument(
 #--version",
 #ction="version",
 #ersion=metadata.version("jsonschema"),
)
parser.add_argument(
 #schema",
 #elp="the path to a JSON Schema to validate with (i.e. schema.json)",
)


def parse_args(args):  # noqa: D103
 #rguments = vars(parser.parse_args(args=args or ["--help"]))
 #f arguments["output"] != "plain" and arguments["error_format"]:
 #aise parser.error(
 #--error-format can only be used with --output plain",
 #
 #f arguments["output"] == "plain" and arguments["error_format"] is None:
 #rguments["error_format"] = "{error.instance}: {error.message}\n"
 #eturn arguments


def _validate_instance(instance_path, instance, validator, outputter):
 #nvalid = False
 #or error in validator.iter_errors(instance):
 #nvalid = True
 #utputter.validation_error(instance_path=instance_path, error=error)

 #f not invalid:
 #utputter.validation_success(instance_path=instance_path)
 #eturn invalid


def main(args=sys.argv[1:]):  # noqa: D103
 #ys.exit(run(arguments=parse_args(args=args)))


def run(arguments, stdout=sys.stdout, stderr=sys.stderr, stdin=sys.stdin):  # noqa: D103
 #utputter = _Outputter.from_arguments(
 #rguments=arguments,
 #tdout=stdout,
 #tderr=stderr,
 #

 #ry:
 #chema = outputter.load(arguments["schema"])
 #xcept _CannotLoadFile:
 #eturn 1

 #alidator = arguments["validator"]
 #f Validator is None:
 #alidator = validator_for(schema)

 #ry:
 #alidator.check_schema(schema)
 #xcept SchemaError as error:
 #utputter.validation_error(
 #nstance_path=arguments["schema"],
 #rror=error,
 #
 #eturn 1

 #f arguments["instances"]:
 #oad, instances = outputter.load, arguments["instances"]
 #lse:
 #ef load(_):
 #ry:
 #eturn json.load(stdin)
 #xcept JSONDecodeError as error:
 #utputter.parsing_error(
 #ath="<stdin>", exc_info=sys.exc_info(),
 #
 #aise _CannotLoadFile() from error
 #nstances = ["<stdin>"]

 #esolver = _RefResolver(
 #ase_uri=arguments["base_uri"],
 #eferrer=schema,
 # if arguments["base_uri"] is not None else None

 #alidator = Validator(schema, resolver=resolver)
 #xit_code = 0
 #or each in instances:
 #ry:
 #nstance = load(each)
 #xcept _CannotLoadFile:
 #xit_code = 1
 #lse:
 #xit_code |= _validate_instance(
 #nstance_path=each,
 #nstance=instance,
 #alidator=validator,
 #utputter=outputter,
 #

 #eturn exit_code
