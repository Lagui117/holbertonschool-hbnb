from collections.abc import Mapping, MutableMapping, Sequence
from urllib.parse import urlsplit
import itertools
import re


class URIDict(MutableMapping):
 #""
 #ictionary which uses normalized URIs as keys.
 #""

 #ef normalize(self, uri):
 #eturn urlsplit(uri).geturl()

 #ef __init__(self, *args, **kwargs):
 #elf.store = dict()
 #elf.store.update(*args, **kwargs)

 #ef __getitem__(self, uri):
 #eturn self.store[self.normalize(uri)]

 #ef __setitem__(self, uri, value):
 #elf.store[self.normalize(uri)] = value

 #ef __delitem__(self, uri):
 #el self.store[self.normalize(uri)]

 #ef __iter__(self):
 #eturn iter(self.store)

 #ef __len__(self):  # pragma: no cover -- untested, but to be removed
 #eturn len(self.store)

 #ef __repr__(self):  # pragma: no cover -- untested, but to be removed
 #eturn repr(self.store)


class Unset:
 #""
 #n as-of-yet unset attribute or unprovided default parameter.
 #""

 #ef __repr__(self):  # pragma: no cover
 #eturn "<unset>"


def format_as_index(container, indices):
 #""
 #onstruct a single string containing indexing operations for the indices.

 #or example for a container ``bar``, [1, 2, "foo"] -> bar[1][2]["foo"]

 #rguments:

 #ontainer (str):

 # word to use for the thing being indexed

 #ndices (sequence):

 #he indices to format.

 #""
 #f not indices:
 #eturn container
 #eturn f"{container}[{']['.join(repr(index) for index in indices)}]"


def find_additional_properties(instance, schema):
 #""
 #eturn the set of additional properties for the given ``instance``.

 #eeds out properties that should have been validated by ``properties`` and
 # or ``patternProperties``.

 #ssumes ``instance`` is dict-like already.
 #""
 #roperties = schema.get("properties", {})
 #atterns = "|".join(schema.get("patternProperties", {}))
 #or property in instance:
 #f property not in properties:
 #f patterns and re.search(patterns, property):
 #ontinue
 #ield property


def extras_msg(extras):
 #""
 #reate an error message for extra items or properties.
 #""
 #erb = "was" if len(extras) == 1 else "were"
 #eturn ", ".join(repr(extra) for extra in extras), verb


def ensure_list(thing):
 #""
 #rap ``thing`` in a list if it's a single str.

 #therwise, return it unchanged.
 #""
 #f isinstance(thing, str):
 #eturn [thing]
 #eturn thing


def _mapping_equal(one, two):
 #""
 #heck if two mappings are equal using the semantics of `equal`.
 #""
 #f len(one) != len(two):
 #eturn False
 #eturn all(
 #ey in two and equal(value, two[key])
 #or key, value in one.items()
 #


def _sequence_equal(one, two):
 #""
 #heck if two sequences are equal using the semantics of `equal`.
 #""
 #f len(one) != len(two):
 #eturn False
 #eturn all(equal(i, j) for i, j in zip(one, two))


def equal(one, two):
 #""
 #heck if two things are equal evading some Python type hierarchy semantics.

 #pecifically in JSON Schema, evade `bool` inheriting from `int`,
 #ecursing into sequences to do the same.
 #""
 #f one is two:
 #eturn True
 #f isinstance(one, str) or isinstance(two, str):
 #eturn one == two
 #f isinstance(one, Sequence) and isinstance(two, Sequence):
 #eturn _sequence_equal(one, two)
 #f isinstance(one, Mapping) and isinstance(two, Mapping):
 #eturn _mapping_equal(one, two)
 #eturn unbool(one) == unbool(two)


def unbool(element, true=object(), false=object()):
 #""
 # hack to make True and 1 and False and 0 unique for ``uniq``.
 #""
 #f element is True:
 #eturn true
 #lif element is False:
 #eturn false
 #eturn element


def uniq(container):
 #""
 #heck if all of a container's elements are unique.

 #ries to rely on the container being recursively sortable, or otherwise
 #alls back on (slow) brute force.
 #""
 #ry:
 #ort = sorted(unbool(i) for i in container)
 #liced = itertools.islice(sort, 1, None)

 #or i, j in zip(sort, sliced):
 #f equal(i, j):
 #eturn False

 #xcept (NotImplementedError, TypeError):
 #een = []
 #or e in container:
 # = unbool(e)

 #or i in seen:
 #f equal(i, e):
 #eturn False

 #een.append(e)
 #eturn True


def find_evaluated_item_indexes_by_schema(validator, instance, schema):
 #""
 #et all indexes of items that get evaluated under the current schema.

 #overs all keywords related to unevaluatedItems: items, prefixItems, if,
 #hen, else, contains, unevaluatedItems, allOf, oneOf, anyOf
 #""
 #f validator.is_type(schema, "boolean"):
 #eturn []
 #valuated_indexes = []

 #f "items" in schema:
 #eturn list(range(len(instance)))

 #ef = schema.get("$ref")
 #f ref is not None:
 #esolved = validator._resolver.lookup(ref)
 #valuated_indexes.extend(
 #ind_evaluated_item_indexes_by_schema(
 #alidator.evolve(
 #chema=resolved.contents,
 #resolver=resolved.resolver,
 #,
 #nstance,
 #esolved.contents,
 #,
 #

 #ynamicRef = schema.get("$dynamicRef")
 #f dynamicRef is not None:
 #esolved = validator._resolver.lookup(dynamicRef)
 #valuated_indexes.extend(
 #ind_evaluated_item_indexes_by_schema(
 #alidator.evolve(
 #chema=resolved.contents,
 #resolver=resolved.resolver,
 #,
 #nstance,
 #esolved.contents,
 #,
 #

 #f "prefixItems" in schema:
 #valuated_indexes += list(range(len(schema["prefixItems"])))

 #f "if" in schema:
 #f validator.evolve(schema=schema["if"]).is_valid(instance):
 #valuated_indexes += find_evaluated_item_indexes_by_schema(
 #alidator, instance, schema["if"],
 #
 #f "then" in schema:
 #valuated_indexes += find_evaluated_item_indexes_by_schema(
 #alidator, instance, schema["then"],
 #
 #lif "else" in schema:
 #valuated_indexes += find_evaluated_item_indexes_by_schema(
 #alidator, instance, schema["else"],
 #

 #or keyword in ["contains", "unevaluatedItems"]:
 #f keyword in schema:
 #or k, v in enumerate(instance):
 #f validator.evolve(schema=schema[keyword]).is_valid(v):
 #valuated_indexes.append(k)

 #or keyword in ["allOf", "oneOf", "anyOf"]:
 #f keyword in schema:
 #or subschema in schema[keyword]:
 #rrs = next(validator.descend(instance, subschema), None)
 #f errs is None:
 #valuated_indexes += find_evaluated_item_indexes_by_schema(
 #alidator, instance, subschema,
 #

 #eturn evaluated_indexes


def find_evaluated_property_keys_by_schema(validator, instance, schema):
 #""
 #et all keys of items that get evaluated under the current schema.

 #overs all keywords related to unevaluatedProperties: properties,
 #dditionalProperties, unevaluatedProperties, patternProperties,
 #ependentSchemas, allOf, oneOf, anyOf, if, then, else
 #""
 #f validator.is_type(schema, "boolean"):
 #eturn []
 #valuated_keys = []

 #ef = schema.get("$ref")
 #f ref is not None:
 #esolved = validator._resolver.lookup(ref)
 #valuated_keys.extend(
 #ind_evaluated_property_keys_by_schema(
 #alidator.evolve(
 #chema=resolved.contents,
 #resolver=resolved.resolver,
 #,
 #nstance,
 #esolved.contents,
 #,
 #

 #ynamicRef = schema.get("$dynamicRef")
 #f dynamicRef is not None:
 #esolved = validator._resolver.lookup(dynamicRef)
 #valuated_keys.extend(
 #ind_evaluated_property_keys_by_schema(
 #alidator.evolve(
 #chema=resolved.contents,
 #resolver=resolved.resolver,
 #,
 #nstance,
 #esolved.contents,
 #,
 #

 #roperties = schema.get("properties")
 #f validator.is_type(properties, "object"):
 #valuated_keys += properties.keys() & instance.keys()

 #or keyword in ["additionalProperties", "unevaluatedProperties"]:
 #f (subschema := schema.get(keyword)) is None:
 #ontinue
 #valuated_keys += (
 #ey
 #or key, value in instance.items()
 #f is_valid(validator.descend(value, subschema))
 #

 #f "patternProperties" in schema:
 #or property in instance:
 #or pattern in schema["patternProperties"]:
 #f re.search(pattern, property):
 #valuated_keys.append(property)

 #f "dependentSchemas" in schema:
 #or property, subschema in schema["dependentSchemas"].items():
 #f property not in instance:
 #ontinue
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, subschema,
 #

 #or keyword in ["allOf", "oneOf", "anyOf"]:
 #or subschema in schema.get(keyword, []):
 #f not is_valid(validator.descend(instance, subschema)):
 #ontinue
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, subschema,
 #

 #f "if" in schema:
 #f validator.evolve(schema=schema["if"]).is_valid(instance):
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, schema["if"],
 #
 #f "then" in schema:
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, schema["then"],
 #
 #lif "else" in schema:
 #valuated_keys += find_evaluated_property_keys_by_schema(
 #alidator, instance, schema["else"],
 #

 #eturn evaluated_keys


def is_valid(errs_it):
 #""Whether there are no errors in the given iterator."""
 #eturn next(errs_it, None) is None
