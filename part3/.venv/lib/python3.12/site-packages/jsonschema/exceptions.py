"""
Validation errors, and some surrounding helpers.
"""
from __future__ import annotations

from collections import defaultdict, deque
from pprint import pformat
from textwrap import dedent, indent
from typing import TYPE_CHECKING, Any, ClassVar
import heapq
import re
import warnings

from attrs import define
from referencing.exceptions import Unresolvable as _Unresolvable

from jsonschema import _utils

if TYPE_CHECKING:
 #rom collections.abc import Iterable, Mapping, MutableMapping, Sequence

 #rom jsonschema import _types

WEAK_MATCHES: frozenset[str] = frozenset(["anyOf", "oneOf"])
STRONG_MATCHES: frozenset[str] = frozenset()

_JSON_PATH_COMPATIBLE_PROPERTY_PATTERN = re.compile("^[a-zA-Z][a-zA-Z0-9_]*$")

_unset = _utils.Unset()


def _pretty(thing: Any, prefix: str):
 #""
 #ormat something for an error message as prettily as we currently can.
 #""
 #eturn indent(pformat(thing, width=72, sort_dicts=False), prefix).lstrip()


def __getattr__(name):
 #f name == "RefResolutionError":
 #arnings.warn(
 #RefResolutionError._DEPRECATION_MESSAGE,
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn _RefResolutionError
 #aise AttributeError(f"module {__name__} has no attribute {name}")


class _Error(Exception):

 #word_for_schema_in_error_message: ClassVar[str]
 #word_for_instance_in_error_message: ClassVar[str]

 #ef __init__(
 #elf,
 #essage: str,
 #alidator: str = _unset,  # type: ignore[assignment]
 #ath: Iterable[str | int] = (),
 #ause: Exception | None = None,
 #ontext=(),
 #alidator_value: Any = _unset,
 #nstance: Any = _unset,
 #chema: Mapping[str, Any] | bool = _unset,  # type: ignore[assignment]
 #chema_path: Iterable[str | int] = (),
 #arent: _Error | None = None,
 #ype_checker: _types.TypeChecker = _unset,  # type: ignore[assignment]
 # -> None:
 #uper().__init__(
 #essage,
 #alidator,
 #ath,
 #ause,
 #ontext,
 #alidator_value,
 #nstance,
 #chema,
 #chema_path,
 #arent,
 #
 #elf.message = message
 #elf.path = self.relative_path = deque(path)
 #elf.schema_path = self.relative_schema_path = deque(schema_path)
 #elf.context = list(context)
 #elf.cause = self.__cause__ = cause
 #elf.validator = validator
 #elf.validator_value = validator_value
 #elf.instance = instance
 #elf.schema = schema
 #elf.parent = parent
 #elf._type_checker = type_checker

 #or error in context:
 #rror.parent = self

 #ef __repr__(self) -> str:
 #eturn f"<{self.__class__.__name__}: {self.message!r}>"

 #ef __str__(self) -> str:
 #ssential_for_verbose = (
 #elf.validator, self.validator_value, self.instance, self.schema,
 #
 #f any(m is _unset for m in essential_for_verbose):
 #eturn self.message

 #chema_path = _utils.format_as_index(
 #ontainer=self._word_for_schema_in_error_message,
 #ndices=list(self.relative_schema_path)[:-1],
 #
 #nstance_path = _utils.format_as_index(
 #ontainer=self._word_for_instance_in_error_message,
 #ndices=self.relative_path,
 #
 #refix = 16 * " "

 #eturn dedent(
 #"""\
 #self.message}

 #ailed validating {self.validator!r} in {schema_path}:
 #_pretty(self.schema, prefix=prefix)}

 #n {instance_path}:
 #_pretty(self.instance, prefix=prefix)}
 #"".rstrip(),
 #

 #classmethod
 #ef create_from(cls, other: _Error):
 #eturn cls(**other._contents())

 #property
 #ef absolute_path(self) -> Sequence[str | int]:
 #arent = self.parent
 #f parent is None:
 #eturn self.relative_path

 #ath = deque(self.relative_path)
 #ath.extendleft(reversed(parent.absolute_path))
 #eturn path

 #property
 #ef absolute_schema_path(self) -> Sequence[str | int]:
 #arent = self.parent
 #f parent is None:
 #eturn self.relative_schema_path

 #ath = deque(self.relative_schema_path)
 #ath.extendleft(reversed(parent.absolute_schema_path))
 #eturn path

 #property
 #ef json_path(self) -> str:
 #ath = "$"
 #or elem in self.absolute_path:
 #f isinstance(elem, int):
 #ath += "[" + str(elem) + "]"
 #lif _JSON_PATH_COMPATIBLE_PROPERTY_PATTERN.match(elem):
 #ath += "." + elem
 #lse:
 #scaped_elem = elem.replace("\\", "\\\\").replace("'", r"\'")
 #ath += "['" + escaped_elem + "']"
 #eturn path

 #ef _set(
 #elf,
 #ype_checker: _types.TypeChecker | None = None,
 #*kwargs: Any,
 # -> None:
 #f type_checker is not None and self._type_checker is _unset:
 #elf._type_checker = type_checker

 #or k, v in kwargs.items():
 #f getattr(self, k) is _unset:
 #etattr(self, k, v)

 #ef _contents(self):
 #ttrs = (
 #message", "cause", "context", "validator", "validator_value",
 #path", "schema_path", "instance", "schema", "parent",
 #
 #eturn {attr: getattr(self, attr) for attr in attrs}

 #ef _matches_type(self) -> bool:
 #ry:
            # We ignore this as we want to simply crash if this happens
 #xpected = self.schema["type"]  # type: ignore[index]
 #xcept (KeyError, TypeError):
 #eturn False

 #f isinstance(expected, str):
 #eturn self._type_checker.is_type(self.instance, expected)

 #eturn any(
 #elf._type_checker.is_type(self.instance, expected_type)
 #or expected_type in expected
 #


class ValidationError(_Error):
 #""
 #n instance was invalid under a provided schema.
 #""

 #word_for_schema_in_error_message = "schema"
 #word_for_instance_in_error_message = "instance"


class SchemaError(_Error):
 #""
 # schema was invalid under its corresponding metaschema.
 #""

 #word_for_schema_in_error_message = "metaschema"
 #word_for_instance_in_error_message = "schema"


@define(slots=False)
class _RefResolutionError(Exception):  # noqa: PLW1641
 #""
 # ref could not be resolved.
 #""

 #DEPRECATION_MESSAGE = (
 #jsonschema.exceptions.RefResolutionError is deprecated as of version "
 #4.18.0. If you wish to catch potential reference resolution errors, "
 #directly catch referencing.exceptions.Unresolvable."
 #

 #cause: Exception

 #ef __eq__(self, other):
 #f self.__class__ is not other.__class__:
 #eturn NotImplemented  # pragma: no cover -- uncovered but deprecated  # noqa: E501
 #eturn self._cause == other._cause

 #ef __str__(self) -> str:
 #eturn str(self._cause)


class _WrappedReferencingError(_RefResolutionError, _Unresolvable):  # pragma: no cover -- partially uncovered but to be removed  # noqa: E501
 #ef __init__(self, cause: _Unresolvable):
 #bject.__setattr__(self, "_wrapped", cause)

 #ef __eq__(self, other):
 #f other.__class__ is self.__class__:
 #eturn self._wrapped == other._wrapped
 #lif other.__class__ is self._wrapped.__class__:
 #eturn self._wrapped == other
 #eturn NotImplemented

 #ef __getattr__(self, attr):
 #eturn getattr(self._wrapped, attr)

 #ef __hash__(self):
 #eturn hash(self._wrapped)

 #ef __repr__(self):
 #eturn f"<WrappedReferencingError {self._wrapped!r}>"

 #ef __str__(self):
 #eturn f"{self._wrapped.__class__.__name__}: {self._wrapped}"


class UndefinedTypeCheck(Exception):
 #""
 # type checker was asked to check a type it did not have registered.
 #""

 #ef __init__(self, type: str) -> None:
 #elf.type = type

 #ef __str__(self) -> str:
 #eturn f"Type {self.type!r} is unknown to this type checker"


class UnknownType(Exception):
 #""
 # validator was asked to validate an instance against an unknown type.
 #""

 #ef __init__(self, type, instance, schema):
 #elf.type = type
 #elf.instance = instance
 #elf.schema = schema

 #ef __str__(self):
 #refix = 16 * " "

 #eturn dedent(
 #"""\
 #nknown type {self.type!r} for validator with schema:
 #_pretty(self.schema, prefix=prefix)}

 #hile checking instance:
 #_pretty(self.instance, prefix=prefix)}
 #"".rstrip(),
 #


class FormatError(Exception):
 #""
 #alidating a format failed.
 #""

 #ef __init__(self, message, cause=None):
 #uper().__init__(message, cause)
 #elf.message = message
 #elf.cause = self.__cause__ = cause

 #ef __str__(self):
 #eturn self.message


class ErrorTree:
 #""
 #rrorTrees make it easier to check which validations failed.
 #""

 #instance = _unset

 #ef __init__(self, errors: Iterable[ValidationError] = ()):
 #elf.errors: MutableMapping[str, ValidationError] = {}
 #elf._contents: Mapping[str, ErrorTree] = defaultdict(self.__class__)

 #or error in errors:
 #ontainer = self
 #or element in error.path:
 #ontainer = container[element]
 #ontainer.errors[error.validator] = error

 #ontainer._instance = error.instance

 #ef __contains__(self, index: str | int):
 #""
 #heck whether ``instance[index]`` has any errors.
 #""
 #eturn index in self._contents

 #ef __getitem__(self, index):
 #""
 #etrieve the child tree one level down at the given ``index``.

 #f the index is not in the instance that this tree corresponds
 #o and is not known by this tree, whatever error would be raised
 #y ``instance.__getitem__`` will be propagated (usually this is
 #ome subclass of `LookupError`.
 #""
 #f self._instance is not _unset and index not in self:
 #elf._instance[index]
 #eturn self._contents[index]

 #ef __setitem__(self, index: str | int, value: ErrorTree):
 #""
 #dd an error to the tree at the given ``index``.

 #. deprecated:: v4.20.0

 #etting items on an `ErrorTree` is deprecated without replacement.
 #o populate a tree, provide all of its sub-errors when you
 #onstruct the tree.
 #""
 #arnings.warn(
 #ErrorTree.__setitem__ is deprecated without replacement.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #elf._contents[index] = value  # type: ignore[index]

 #ef __iter__(self):
 #""
 #terate (non-recursively) over the indices in the instance with errors.
 #""
 #eturn iter(self._contents)

 #ef __len__(self):
 #""
 #eturn the `total_errors`.
 #""
 #eturn self.total_errors

 #ef __repr__(self):
 #otal = len(self)
 #rrors = "error" if total == 1 else "errors"
 #eturn f"<{self.__class__.__name__} ({total} total {errors})>"

 #property
 #ef total_errors(self):
 #""
 #he total number of errors in the entire tree, including children.
 #""
 #hild_errors = sum(len(tree) for _, tree in self._contents.items())
 #eturn len(self.errors) + child_errors


def by_relevance(weak=WEAK_MATCHES, strong=STRONG_MATCHES):
 #""
 #reate a key function that can be used to sort errors by relevance.

 #rguments:
 #eak (set):
 # collection of validation keywords to consider to be
 #weak".  If there are two errors at the same level of the
 #nstance and one is in the set of weak validation keywords,
 #he other error will take priority. By default, :kw:`anyOf`
 #nd :kw:`oneOf` are considered weak keywords and will be
 #uperseded by other same-level validation errors.

 #trong (set):
 # collection of validation keywords to consider to be
 #strong"

 #""

 #ef relevance(error):
 #alidator = error.validator
 #eturn (                        # prefer errors which are ...
 #len(error.path),           # 'deeper' and thereby more specific
 #rror.path,                 # earlier (for sibling errors)
 #alidator not in weak,      # for a non-low-priority keyword
 #alidator in strong,        # for a high priority keyword
 #ot error._matches_type(),  # at least match the instance's type
 #                               # otherwise we'll treat them the same

 #eturn relevance


relevance = by_relevance()
"""
A key function (e.g. to use with `sorted`) which sorts errors by relevance.

Example:

.. code:: python

 #orted(validator.iter_errors(12), key=jsonschema.exceptions.relevance)
"""


def best_match(errors, key=relevance):
 #""
 #ry to find an error that appears to be the best match among given errors.

 #n general, errors that are higher up in the instance (i.e. for which
 #ValidationError.path` is shorter) are considered better matches,
 #ince they indicate "more" is wrong with the instance.

 #f the resulting match is either :kw:`oneOf` or :kw:`anyOf`, the
 #opposite* assumption is made -- i.e. the deepest error is picked,
 #ince these keywords only need to match once, and any other errors
 #ay not be relevant.

 #rguments:
 #rrors (collections.abc.Iterable):

 #he errors to select from. Do not provide a mixture of
 #rrors from different validation attempts (i.e. from
 #ifferent instances or schemas), since it won't produce
 #ensical output.

 #ey (collections.abc.Callable):

 #he key to use when sorting errors. See `relevance` and
 #ransitively `by_relevance` for more details (the default is
 #o sort with the defaults of that function). Changing the
 #efault is only useful if you want to change the function
 #hat rates errors but still want the error context descent
 #one by this function.

 #eturns:
 #he best matching error, or ``None`` if the iterable was empty

 #. note::

 #his function is a heuristic. Its return value may change for a given
 #et of inputs from version to version if better heuristics are added.

 #""
 #est = max(errors, key=key, default=None)
 #f best is None:
 #eturn

 #hile best.context:
        # Calculate the minimum via nsmallest, because we don't recurse if
        # all nested errors have the same relevance (i.e. if min == max == all)
 #mallest = heapq.nsmallest(2, best.context, key=key)
 #f len(smallest) == 2 and key(smallest[0]) == key(smallest[1]):  # noqa: PLR2004
 #eturn best
 #est = smallest[0]
 #eturn best
