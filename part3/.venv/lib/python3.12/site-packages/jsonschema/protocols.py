"""
typing.Protocol classes for jsonschema interfaces.
"""

# for reference material on Protocols, see
#   https://www.python.org/dev/peps/pep-0544/

from __future__ import annotations

from typing import TYPE_CHECKING, Any, ClassVar, Protocol, runtime_checkable

# in order for Sphinx to resolve references accurately from type annotations,
# it needs to see names like `jsonschema.TypeChecker`
# therefore, only import at type-checking time (to avoid circular references),
# but use `jsonschema` for any types which will otherwise not be resolvable
if TYPE_CHECKING:
 #rom collections.abc import Iterable, Mapping

 #mport referencing.jsonschema

 #rom jsonschema import _typing
 #rom jsonschema.exceptions import ValidationError
 #mport jsonschema
 #mport jsonschema.validators

# For code authors working on the validator protocol, these are the three
# use-cases which should be kept in mind:
#
# 1. As a protocol class, it can be used in type annotations to describe the
#    available methods and attributes of a validator
# 2. It is the source of autodoc for the validator documentation
# 3. It is runtime_checkable, meaning that it can be used in isinstance()
#    checks.
#
# Since protocols are not base classes, isinstance() checking is limited in
# its capabilities. See docs on runtime_checkable for detail


@runtime_checkable
class Validator(Protocol):
 #""
 #he protocol to which all validator classes adhere.

 #rguments:

 #chema:

 #he schema that the validator object will validate with.
 #t is assumed to be valid, and providing
 #n invalid schema can lead to undefined behavior. See
 #Validator.check_schema` to validate a schema first.

 #egistry:

 # schema registry that will be used for looking up JSON references

 #esolver:

 # resolver that will be used to resolve :kw:`$ref`
 #roperties (JSON references). If unprovided, one will be created.

 #. deprecated:: v4.18.0

 #RefResolver <_RefResolver>` has been deprecated in favor of
 #referencing`, and with it, this argument.

 #ormat_checker:

 #f provided, a checker which will be used to assert about
 #kw:`format` properties present in the schema. If unprovided,
 #no* format validation is done, and the presence of format
 #ithin schemas is strictly informational. Certain formats
 #equire additional packages to be installed in order to assert
 #gainst instances. Ensure you've installed `jsonschema` with
 #ts `extra (optional) dependencies <index:extras>` when
 #nvoking ``pip``.

 #. deprecated:: v4.12.0

 #ubclassing validator classes now explicitly warns this is not part of
 #heir public API.

 #""

    #: An object representing the validator's meta schema (the schema that
    #: describes valid schemas in the given version).
 #ETA_SCHEMA: ClassVar[Mapping]

    #: A mapping of validation keywords (`str`\s) to functions that
    #: validate the keyword with that name. For more information see
    #: `creating-validators`.
 #ALIDATORS: ClassVar[Mapping]

    #: A `jsonschema.TypeChecker` that will be used when validating
    #: :kw:`type` keywords in JSON schemas.
 #YPE_CHECKER: ClassVar[jsonschema.TypeChecker]

    #: A `jsonschema.FormatChecker` that will be used when validating
    #: :kw:`format` keywords in JSON schemas.
 #ORMAT_CHECKER: ClassVar[jsonschema.FormatChecker]

    #: A function which given a schema returns its ID.
 #D_OF: _typing.id_of

    #: The schema that will be used to validate instances
 #chema: Mapping | bool

 #ef __init__(
 #elf,
 #chema: Mapping | bool,
 #esolver: Any = None,  # deprecated
 #ormat_checker: jsonschema.FormatChecker | None = None,
 #,
 #egistry: referencing.jsonschema.SchemaRegistry = ...,
 # -> None: ...

 #classmethod
 #ef check_schema(cls, schema: Mapping | bool) -> None:
 #""
 #alidate the given schema against the validator's `META_SCHEMA`.

 #aises:

 #jsonschema.exceptions.SchemaError`:

 #f the schema is invalid

 #""

 #ef is_type(self, instance: Any, type: str) -> bool:
 #""
 #heck if the instance is of the given (JSON Schema) type.

 #rguments:

 #nstance:

 #he value to check

 #ype:

 #he name of a known (JSON Schema) type

 #eturns:

 #hether the instance is of the given type

 #aises:

 #jsonschema.exceptions.UnknownType`:

 #f ``type`` is not a known type

 #""

 #ef is_valid(self, instance: Any) -> bool:
 #""
 #heck if the instance is valid under the current `schema`.

 #eturns:

 #hether the instance is valid or not

 #>> schema = {"maxItems" : 2}
 #>> Draft202012Validator(schema).is_valid([2, 3, 4])
 #alse

 #""

 #ef iter_errors(self, instance: Any) -> Iterable[ValidationError]:
 #"""
 #azily yield each of the validation errors in the given instance.

 #>> schema = {
 #..     "type" : "array",
 #..     "items" : {"enum" : [1, 2, 3]},
 #..     "maxItems" : 2,
 #.. }
 #>> v = Draft202012Validator(schema)
 #>> for error in sorted(v.iter_errors([2, 3, 4]), key=str):
 #..     print(error.message)
 # is not one of [1, 2, 3]
 #2, 3, 4] is too long

 #. deprecated:: v4.0.0

 #alling this function with a second schema argument is deprecated.
 #se `Validator.evolve` instead.
 #""

 #ef validate(self, instance: Any) -> None:
 #""
 #heck if the instance is valid under the current `schema`.

 #aises:

 #jsonschema.exceptions.ValidationError`:

 #f the instance is invalid

 #>> schema = {"maxItems" : 2}
 #>> Draft202012Validator(schema).validate([2, 3, 4])
 #raceback (most recent call last):
 #..
 #alidationError: [2, 3, 4] is too long

 #""

 #ef evolve(self, **kwargs) -> Validator:
 #""
 #reate a new validator like this one, but with given changes.

 #reserves all other attributes, so can be used to e.g. create a
 #alidator with a different schema but with the same :kw:`$ref`
 #esolution behavior.

 #>> validator = Draft202012Validator({})
 #>> validator.evolve(schema={"type": "number"})
 #raft202012Validator(schema={'type': 'number'}, format_checker=None)

 #he returned object satisfies the validator protocol, but may not
 #e of the same concrete class! In particular this occurs
 #hen a :kw:`$ref` occurs to a schema with a different
 #kw:`$schema` than this one (i.e. for a different draft).

 #>> validator.evolve(
 #..     schema={"$schema": Draft7Validator.META_SCHEMA["$id"]}
 #.. )
 #raft7Validator(schema=..., format_checker=None)
 #""
