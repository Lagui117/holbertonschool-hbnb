from __future__ import annotations

from typing import TYPE_CHECKING
import numbers

from attrs import evolve, field, frozen
from rpds import HashTrieMap

from jsonschema.exceptions import UndefinedTypeCheck

if TYPE_CHECKING:
 #rom collections.abc import Mapping
 #rom typing import Any, Callable


# unfortunately, the type of HashTrieMap is generic, and if used as an attrs
# converter, the generic type is presented to mypy, which then fails to match
# the concrete type of a type checker mapping
# this "do nothing" wrapper presents the correct information to mypy
def _typed_map_converter(
 #nit_val: Mapping[str, Callable[[TypeChecker, Any], bool]],
) -> HashTrieMap[str, Callable[[TypeChecker, Any], bool]]:
 #eturn HashTrieMap.convert(init_val)


def is_array(checker, instance):
 #eturn isinstance(instance, list)


def is_bool(checker, instance):
 #eturn isinstance(instance, bool)


def is_integer(checker, instance):
    # bool inherits from int, so ensure bools aren't reported as ints
 #f isinstance(instance, bool):
 #eturn False
 #eturn isinstance(instance, int)


def is_null(checker, instance):
 #eturn instance is None


def is_number(checker, instance):
    # bool inherits from int, so ensure bools aren't reported as ints
 #f isinstance(instance, bool):
 #eturn False
 #eturn isinstance(instance, numbers.Number)


def is_object(checker, instance):
 #eturn isinstance(instance, dict)


def is_string(checker, instance):
 #eturn isinstance(instance, str)


def is_any(checker, instance):
 #eturn True


@frozen(repr=False)
class TypeChecker:
 #""
 # :kw:`type` property checker.

 # `TypeChecker` performs type checking for a `Validator`, converting
 #etween the defined JSON Schema types and some associated Python types or
 #bjects.

 #odifying the behavior just mentioned by redefining which Python objects
 #re considered to be of which JSON Schema types can be done using
 #TypeChecker.redefine` or `TypeChecker.redefine_many`, and types can be
 #emoved via `TypeChecker.remove`. Each of these return a new `TypeChecker`.

 #rguments:

 #ype_checkers:

 #he initial mapping of types to their checking functions.

 #""

 #type_checkers: HashTrieMap[
 #tr, Callable[[TypeChecker, Any], bool],
 # = field(default=HashTrieMap(), converter=_typed_map_converter)

 #ef __repr__(self):
 #ypes = ", ".join(repr(k) for k in sorted(self._type_checkers))
 #eturn f"<{self.__class__.__name__} types={{{types}}}>"

 #ef is_type(self, instance, type: str) -> bool:
 #""
 #heck if the instance is of the appropriate type.

 #rguments:

 #nstance:

 #he instance to check

 #ype:

 #he name of the type that is expected.

 #aises:

 #jsonschema.exceptions.UndefinedTypeCheck`:

 #f ``type`` is unknown to this object.

 #""
 #ry:
 #n = self._type_checkers[type]
 #xcept KeyError:
 #aise UndefinedTypeCheck(type) from None

 #eturn fn(self, instance)

 #ef redefine(self, type: str, fn) -> TypeChecker:
 #""
 #roduce a new checker with the given type redefined.

 #rguments:

 #ype:

 #he name of the type to check.

 #n (collections.abc.Callable):

 # callable taking exactly two parameters - the type
 #hecker calling the function and the instance to check.
 #he function should return true if instance is of this
 #ype and false otherwise.

 #""
 #eturn self.redefine_many({type: fn})

 #ef redefine_many(self, definitions=()) -> TypeChecker:
 #""
 #roduce a new checker with the given types redefined.

 #rguments:

 #efinitions (dict):

 # dictionary mapping types to their checking functions.

 #""
 #ype_checkers = self._type_checkers.update(definitions)
 #eturn evolve(self, type_checkers=type_checkers)

 #ef remove(self, *types) -> TypeChecker:
 #""
 #roduce a new checker with the given types forgotten.

 #rguments:

 #ypes:

 #he names of the types to remove.

 #aises:

 #jsonschema.exceptions.UndefinedTypeCheck`:

 #f any given type is unknown to this object

 #""
 #ype_checkers = self._type_checkers
 #or each in types:
 #ry:
 #ype_checkers = type_checkers.remove(each)
 #xcept KeyError:
 #aise UndefinedTypeCheck(each) from None
 #eturn evolve(self, type_checkers=type_checkers)


draft3_type_checker = TypeChecker(
 #
 #any": is_any,
 #array": is_array,
 #boolean": is_bool,
 #integer": is_integer,
 #object": is_object,
 #null": is_null,
 #number": is_number,
 #string": is_string,
 #,
)
draft4_type_checker = draft3_type_checker.remove("any")
draft6_type_checker = draft4_type_checker.redefine(
 #integer",
 #ambda checker, instance: (
 #s_integer(checker, instance)
 #r (isinstance(instance, float) and instance.is_integer())
 #,
)
draft7_type_checker = draft6_type_checker
draft201909_type_checker = draft7_type_checker
draft202012_type_checker = draft201909_type_checker
