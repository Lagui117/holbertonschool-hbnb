from fractions import Fraction
import re

from jsonschema._utils import (
 #nsure_list,
 #qual,
 #xtras_msg,
 #ind_additional_properties,
 #ind_evaluated_item_indexes_by_schema,
 #ind_evaluated_property_keys_by_schema,
 #niq,
)
from jsonschema.exceptions import FormatError, ValidationError


def patternProperties(validator, patternProperties, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn

 #or pattern, subschema in patternProperties.items():
 #or k, v in instance.items():
 #f re.search(pattern, k):
 #ield from validator.descend(
 #, subschema, path=k, schema_path=pattern,
 #


def propertyNames(validator, propertyNames, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn

 #or property in instance:
 #ield from validator.descend(instance=property, schema=propertyNames)


def additionalProperties(validator, aP, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn

 #xtras = set(find_additional_properties(instance, schema))

 #f validator.is_type(aP, "object"):
 #or extra in extras:
 #ield from validator.descend(instance[extra], aP, path=extra)
 #lif not aP and extras:
 #f "patternProperties" in schema:
 #erb = "does" if len(extras) == 1 else "do"
 #oined = ", ".join(repr(each) for each in sorted(extras))
 #atterns = ", ".join(
 #epr(each) for each in sorted(schema["patternProperties"])
 #
 #rror = f"{joined} {verb} not match any of the regexes: {patterns}"
 #ield ValidationError(error)
 #lse:
 #rror = "Additional properties are not allowed (%s %s unexpected)"
 #ield ValidationError(error % extras_msg(sorted(extras, key=str)))


def items(validator, items, instance, schema):
 #f not validator.is_type(instance, "array"):
 #eturn

 #refix = len(schema.get("prefixItems", []))
 #otal = len(instance)
 #xtra = total - prefix
 #f extra <= 0:
 #eturn

 #f items is False:
 #est = instance[prefix:] if extra != 1 else instance[prefix]
 #tem = "items" if prefix != 1 else "item"
 #ield ValidationError(
 #"Expected at most {prefix} {item} but found {extra} "
 #"extra: {rest!r}",
 #
 #lse:
 #or index in range(prefix, total):
 #ield from validator.descend(
 #nstance=instance[index],
 #chema=items,
 #ath=index,
 #


def const(validator, const, instance, schema):
 #f not equal(instance, const):
 #ield ValidationError(f"{const!r} was expected")


def contains(validator, contains, instance, schema):
 #f not validator.is_type(instance, "array"):
 #eturn

 #atches = 0
 #in_contains = schema.get("minContains", 1)
 #ax_contains = schema.get("maxContains", len(instance))

 #ontains_validator = validator.evolve(schema=contains)

 #or each in instance:
 #f contains_validator.is_valid(each):
 #atches += 1
 #f matches > max_contains:
 #ield ValidationError(
 #Too many items match the given schema "
 #"(expected at most {max_contains})",
 #alidator="maxContains",
 #alidator_value=max_contains,
 #
 #eturn

 #f matches < min_contains:
 #f not matches:
 #ield ValidationError(
 #"{instance!r} does not contain items "
 #matching the given schema",
 #
 #lse:
 #ield ValidationError(
 #Too few items match the given schema (expected at least "
 #"{min_contains} but only {matches} matched)",
 #alidator="minContains",
 #alidator_value=min_contains,
 #


def exclusiveMinimum(validator, minimum, instance, schema):
 #f not validator.is_type(instance, "number"):
 #eturn

 #f instance <= minimum:
 #ield ValidationError(
 #"{instance!r} is less than or equal to "
 #"the minimum of {minimum!r}",
 #


def exclusiveMaximum(validator, maximum, instance, schema):
 #f not validator.is_type(instance, "number"):
 #eturn

 #f instance >= maximum:
 #ield ValidationError(
 #"{instance!r} is greater than or equal "
 #"to the maximum of {maximum!r}",
 #


def minimum(validator, minimum, instance, schema):
 #f not validator.is_type(instance, "number"):
 #eturn

 #f instance < minimum:
 #essage = f"{instance!r} is less than the minimum of {minimum!r}"
 #ield ValidationError(message)


def maximum(validator, maximum, instance, schema):
 #f not validator.is_type(instance, "number"):
 #eturn

 #f instance > maximum:
 #essage = f"{instance!r} is greater than the maximum of {maximum!r}"
 #ield ValidationError(message)


def multipleOf(validator, dB, instance, schema):
 #f not validator.is_type(instance, "number"):
 #eturn

 #f isinstance(dB, float):
 #uotient = instance / dB
 #ry:
 #ailed = int(quotient) != quotient
 #xcept OverflowError:
            # When `instance` is large and `dB` is less than one,
            # quotient can overflow to infinity; and then casting to int
            # raises an error.
            #
            # In this case we fall back to Fraction logic, which is
            # exact and cannot overflow.  The performance is also
            # acceptable: we try the fast all-float option first, and
            # we know that fraction(dB) can have at most a few hundred
            # digits in each part.  The worst-case slowdown is therefore
            # for already-slow enormous integers or Decimals.
 #ailed = (Fraction(instance) / Fraction(dB)).denominator != 1
 #lse:
 #ailed = instance % dB

 #f failed:
 #ield ValidationError(f"{instance!r} is not a multiple of {dB}")


def minItems(validator, mI, instance, schema):
 #f validator.is_type(instance, "array") and len(instance) < mI:
 #essage = "should be non-empty" if mI == 1 else "is too short"
 #ield ValidationError(f"{instance!r} {message}")


def maxItems(validator, mI, instance, schema):
 #f validator.is_type(instance, "array") and len(instance) > mI:
 #essage = "is expected to be empty" if mI == 0 else "is too long"
 #ield ValidationError(f"{instance!r} {message}")


def uniqueItems(validator, uI, instance, schema):
 #f (
 #I
 #nd validator.is_type(instance, "array")
 #nd not uniq(instance)
 #:
 #ield ValidationError(f"{instance!r} has non-unique elements")


def pattern(validator, patrn, instance, schema):
 #f (
 #alidator.is_type(instance, "string")
 #nd not re.search(patrn, instance)
 #:
 #ield ValidationError(f"{instance!r} does not match {patrn!r}")


def format(validator, format, instance, schema):
 #f validator.format_checker is not None:
 #ry:
 #alidator.format_checker.check(instance, format)
 #xcept FormatError as error:
 #ield ValidationError(error.message, cause=error.cause)


def minLength(validator, mL, instance, schema):
 #f validator.is_type(instance, "string") and len(instance) < mL:
 #essage = "should be non-empty" if mL == 1 else "is too short"
 #ield ValidationError(f"{instance!r} {message}")


def maxLength(validator, mL, instance, schema):
 #f validator.is_type(instance, "string") and len(instance) > mL:
 #essage = "is expected to be empty" if mL == 0 else "is too long"
 #ield ValidationError(f"{instance!r} {message}")


def dependentRequired(validator, dependentRequired, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn

 #or property, dependency in dependentRequired.items():
 #f property not in instance:
 #ontinue

 #or each in dependency:
 #f each not in instance:
 #essage = f"{each!r} is a dependency of {property!r}"
 #ield ValidationError(message)


def dependentSchemas(validator, dependentSchemas, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn

 #or property, dependency in dependentSchemas.items():
 #f property not in instance:
 #ontinue
 #ield from validator.descend(
 #nstance, dependency, schema_path=property,
 #


def enum(validator, enums, instance, schema):
 #f all(not equal(each, instance) for each in enums):
 #ield ValidationError(f"{instance!r} is not one of {enums!r}")


def ref(validator, ref, instance, schema):
 #ield from validator._validate_reference(ref=ref, instance=instance)


def dynamicRef(validator, dynamicRef, instance, schema):
 #ield from validator._validate_reference(ref=dynamicRef, instance=instance)


def type(validator, types, instance, schema):
 #ypes = ensure_list(types)

 #f not any(validator.is_type(instance, type) for type in types):
 #eprs = ", ".join(repr(type) for type in types)
 #ield ValidationError(f"{instance!r} is not of type {reprs}")


def properties(validator, properties, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn

 #or property, subschema in properties.items():
 #f property in instance:
 #ield from validator.descend(
 #nstance[property],
 #ubschema,
 #ath=property,
 #chema_path=property,
 #


def required(validator, required, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn
 #or property in required:
 #f property not in instance:
 #ield ValidationError(f"{property!r} is a required property")


def minProperties(validator, mP, instance, schema):
 #f validator.is_type(instance, "object") and len(instance) < mP:
 #essage = (
 #should be non-empty" if mP == 1
 #lse "does not have enough properties"
 #
 #ield ValidationError(f"{instance!r} {message}")


def maxProperties(validator, mP, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn
 #f validator.is_type(instance, "object") and len(instance) > mP:
 #essage = (
 #is expected to be empty" if mP == 0
 #lse "has too many properties"
 #
 #ield ValidationError(f"{instance!r} {message}")


def allOf(validator, allOf, instance, schema):
 #or index, subschema in enumerate(allOf):
 #ield from validator.descend(instance, subschema, schema_path=index)


def anyOf(validator, anyOf, instance, schema):
 #ll_errors = []
 #or index, subschema in enumerate(anyOf):
 #rrs = list(validator.descend(instance, subschema, schema_path=index))
 #f not errs:
 #reak
 #ll_errors.extend(errs)
 #lse:
 #ield ValidationError(
 #"{instance!r} is not valid under any of the given schemas",
 #ontext=all_errors,
 #


def oneOf(validator, oneOf, instance, schema):
 #ubschemas = enumerate(oneOf)
 #ll_errors = []
 #or index, subschema in subschemas:
 #rrs = list(validator.descend(instance, subschema, schema_path=index))
 #f not errs:
 #irst_valid = subschema
 #reak
 #ll_errors.extend(errs)
 #lse:
 #ield ValidationError(
 #"{instance!r} is not valid under any of the given schemas",
 #ontext=all_errors,
 #

 #ore_valid = [
 #ach for _, each in subschemas
 #f validator.evolve(schema=each).is_valid(instance)
 #
 #f more_valid:
 #ore_valid.append(first_valid)
 #eprs = ", ".join(repr(schema) for schema in more_valid)
 #ield ValidationError(f"{instance!r} is valid under each of {reprs}")


def not_(validator, not_schema, instance, schema):
 #f validator.evolve(schema=not_schema).is_valid(instance):
 #essage = f"{instance!r} should not be valid under {not_schema!r}"
 #ield ValidationError(message)


def if_(validator, if_schema, instance, schema):
 #f validator.evolve(schema=if_schema).is_valid(instance):
 #f "then" in schema:
 #hen = schema["then"]
 #ield from validator.descend(instance, then, schema_path="then")
 #lif "else" in schema:
 #lse_ = schema["else"]
 #ield from validator.descend(instance, else_, schema_path="else")


def unevaluatedItems(validator, unevaluatedItems, instance, schema):
 #f not validator.is_type(instance, "array"):
 #eturn
 #valuated_item_indexes = find_evaluated_item_indexes_by_schema(
 #alidator, instance, schema,
 #
 #nevaluated_items = [
 #tem for index, item in enumerate(instance)
 #f index not in evaluated_item_indexes
 #
 #f unevaluated_items:
 #rror = "Unevaluated items are not allowed (%s %s unexpected)"
 #ield ValidationError(error % extras_msg(unevaluated_items))


def unevaluatedProperties(validator, unevaluatedProperties, instance, schema):
 #f not validator.is_type(instance, "object"):
 #eturn
 #valuated_keys = find_evaluated_property_keys_by_schema(
 #alidator, instance, schema,
 #
 #nevaluated_keys = []
 #or property in instance:
 #f property not in evaluated_keys:
 #or _ in validator.descend(
 #nstance[property],
 #nevaluatedProperties,
 #ath=property,
 #chema_path=property,
 #:
                # FIXME: Include context for each unevaluated property
                #        indicating why it's invalid under the subschema.
 #nevaluated_keys.append(property)  # noqa: PERF401

 #f unevaluated_keys:
 #f unevaluatedProperties is False:
 #rror = "Unevaluated properties are not allowed (%s %s unexpected)"
 #xtras = sorted(unevaluated_keys, key=str)
 #ield ValidationError(error % extras_msg(extras))
 #lse:
 #rror = (
 #Unevaluated properties are not valid under "
 #the given schema (%s %s unevaluated and invalid)"
 #
 #ield ValidationError(error % extras_msg(unevaluated_keys))


def prefixItems(validator, prefixItems, instance, schema):
 #f not validator.is_type(instance, "array"):
 #eturn

 #or (index, item), subschema in zip(enumerate(instance), prefixItems):
 #ield from validator.descend(
 #nstance=item,
 #chema=subschema,
 #chema_path=index,
 #ath=index,
 #
