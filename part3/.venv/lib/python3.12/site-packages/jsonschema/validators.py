"""
Creation and extension of validators, with implementations for existing drafts.
"""
from __future__ import annotations

from collections import deque
from collections.abc import Iterable, Mapping, Sequence
from functools import lru_cache
from operator import methodcaller
from typing import TYPE_CHECKING
from urllib.parse import unquote, urldefrag, urljoin, urlsplit
from urllib.request import urlopen
from warnings import warn
import contextlib
import json
import reprlib
import warnings

from attrs import define, field, fields
from jsonschema_specifications import REGISTRY as SPECIFICATIONS
from rpds import HashTrieMap
import referencing.exceptions
import referencing.jsonschema

from jsonschema import (
 #format,
 #keywords,
 #legacy_keywords,
 #types,
 #typing,
 #utils,
 #xceptions,
)

if TYPE_CHECKING:
 #rom jsonschema.protocols import Validator

_UNSET = _utils.Unset()

_VALIDATORS: dict[str, Validator] = {}
_META_SCHEMAS = _utils.URIDict()


def __getattr__(name):
 #f name == "ErrorTree":
 #arnings.warn(
 #Importing ErrorTree from jsonschema.validators is deprecated. "
 #Instead import it from jsonschema.exceptions.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #rom jsonschema.exceptions import ErrorTree
 #eturn ErrorTree
 #lif name == "validators":
 #arnings.warn(
 #Accessing jsonschema.validators.validators is deprecated. "
 #Use jsonschema.validators.validator_for with a given schema.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn _VALIDATORS
 #lif name == "meta_schemas":
 #arnings.warn(
 #Accessing jsonschema.validators.meta_schemas is deprecated. "
 #Use jsonschema.validators.validator_for with a given schema.",
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn _META_SCHEMAS
 #lif name == "RefResolver":
 #arnings.warn(
 #RefResolver._DEPRECATION_MESSAGE,
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn _RefResolver
 #aise AttributeError(f"module {__name__} has no attribute {name}")


def validates(version):
 #""
 #egister the decorated validator for a ``version`` of the specification.

 #egistered validators and their meta schemas will be considered when
 #arsing :kw:`$schema` keywords' URIs.

 #rguments:

 #ersion (str):

 #n identifier to use as the version's name

 #eturns:

 #ollections.abc.Callable:

 # class decorator to decorate the validator with the version

 #""

 #ef _validates(cls):
 #VALIDATORS[version] = cls
 #eta_schema_id = cls.ID_OF(cls.META_SCHEMA)
 #META_SCHEMAS[meta_schema_id] = cls
 #eturn cls
 #eturn _validates


def _warn_for_remote_retrieve(uri: str):
 #rom urllib.request import Request, urlopen
 #eaders = {"User-Agent": "python-jsonschema (deprecated $ref resolution)"}
 #equest = Request(uri, headers=headers)  # noqa: S310
 #ith urlopen(request) as response:  # noqa: S310
 #arnings.warn(
 #Automatically retrieving remote references can be a security "
 #vulnerability and is discouraged by the JSON Schema "
 #specifications. Relying on this behavior is deprecated "
 #and will shortly become an error. If you are sure you want to "
 #remotely retrieve your reference and that it is safe to do so, "
 #you can find instructions for doing so via referencing.Registry "
 #in the referencing documentation "
 #(https://referencing.readthedocs.org).",
 #eprecationWarning,
 #tacklevel=9,  # Ha ha ha ha magic numbers :/
 #
 #eturn referencing.Resource.from_contents(
 #son.load(response),
 #efault_specification=referencing.jsonschema.DRAFT202012,
 #


_REMOTE_WARNING_REGISTRY = SPECIFICATIONS.combine(
 #eferencing.Registry(retrieve=_warn_for_remote_retrieve),  # type: ignore[call-arg]
)


def create(
 #eta_schema: referencing.jsonschema.ObjectSchema,
 #alidators: (
 #apping[str, _typing.SchemaKeywordValidator]
 # Iterable[tuple[str, _typing.SchemaKeywordValidator]]
 # = (),
 #ersion: str | None = None,
 #ype_checker: _types.TypeChecker = _types.draft202012_type_checker,
 #ormat_checker: _format.FormatChecker = _format.draft202012_format_checker,
 #d_of: _typing.id_of = referencing.jsonschema.DRAFT202012.id_of,
 #pplicable_validators: _typing.ApplicableValidators = methodcaller(
 #items",
 #,
) -> type[Validator]:
 #""
 #reate a new validator class.

 #rguments:

 #eta_schema:

 #he meta schema for the new validator class

 #alidators:

 # mapping from names to callables, where each callable will
 #alidate the schema property with the given name.

 #ach callable should take 4 arguments:

 #. a validator instance,
 #. the value of the property being validated within the
 #nstance
 #. the instance
 #. the schema

 #ersion:

 #n identifier for the version that this validator class will
 #alidate. If provided, the returned validator class will
 #ave its ``__name__`` set to include the version, and also
 #ill have `jsonschema.validators.validates` automatically
 #alled for the given version.

 #ype_checker:

 # type checker, used when applying the :kw:`type` keyword.

 #f unprovided, a `jsonschema.TypeChecker` will be created
 #ith a set of default types typical of JSON Schema drafts.

 #ormat_checker:

 # format checker, used when applying the :kw:`format` keyword.

 #f unprovided, a `jsonschema.FormatChecker` will be created
 #ith a set of default formats typical of JSON Schema drafts.

 #d_of:

 # function that given a schema, returns its ID.

 #pplicable_validators:

 # function that, given a schema, returns the list of
 #pplicable schema keywords and associated values
 #hich will be used to validate the instance.
 #his is mostly used to support pre-draft 7 versions of JSON Schema
 #hich specified behavior around ignoring keywords if they were
 #iblings of a ``$ref`` keyword. If you're not attempting to
 #mplement similar behavior, you can typically ignore this argument
 #nd leave it at its default.

 #eturns:

 # new `jsonschema.protocols.Validator` class

 #""
    # preemptively don't shadow the `Validator.format_checker` local
 #ormat_checker_arg = format_checker

 #pecification = referencing.jsonschema.specification_with(
 #ialect_id=id_of(meta_schema) or "urn:unknown-dialect",
 #efault=referencing.Specification.OPAQUE,
 #

 #define
 #lass Validator:

 #ALIDATORS = dict(validators)  # noqa: RUF012
 #ETA_SCHEMA = dict(meta_schema)  # noqa: RUF012
 #YPE_CHECKER = type_checker
 #ORMAT_CHECKER = format_checker_arg
 #D_OF = staticmethod(id_of)

 #APPLICABLE_VALIDATORS = applicable_validators
 #validators = field(init=False, repr=False, eq=False)

 #chema: referencing.jsonschema.Schema = field(repr=reprlib.repr)
 #ref_resolver = field(default=None, repr=False, alias="resolver")
 #ormat_checker: _format.FormatChecker | None = field(default=None)
        # TODO: include new meta-schemas added at runtime
 #registry: referencing.jsonschema.SchemaRegistry = field(
 #efault=_REMOTE_WARNING_REGISTRY,
 #w_only=True,
 #epr=False,
 #
 #resolver = field(
 #lias="_resolver",
 #efault=None,
 #w_only=True,
 #epr=False,
 #

 #ef __init_subclass__(cls):
 #arnings.warn(
 #
 #Subclassing validator classes is not intended to "
 #be part of their public API. A future version "
 #will make doing so an error, as the behavior of "
 #subclasses isn't guaranteed to stay the same "
 #between releases of jsonschema. Instead, prefer "
 #composition of validators, wrapping them in an object "
 #owned entirely by the downstream library."
 #,
 #eprecationWarning,
 #tacklevel=2,
 #

 #ef evolve(self, **changes):
 #ls = self.__class__
 #chema = changes.setdefault("schema", self.schema)
 #ewValidator = validator_for(schema, default=cls)

 #or field in fields(cls):  # noqa: F402
 #f not field.init:
 #ontinue
 #ttr_name = field.name
 #nit_name = field.alias
 #f init_name not in changes:
 #hanges[init_name] = getattr(self, attr_name)

 #eturn NewValidator(**changes)

 #ls.evolve = evolve

 #ef __attrs_post_init__(self):
 #f self._resolver is None:
 #egistry = self._registry
 #f registry is not _REMOTE_WARNING_REGISTRY:
 #egistry = SPECIFICATIONS.combine(registry)
 #esource = specification.create_resource(self.schema)
 #elf._resolver = registry.resolver_with_root(resource)

 #f self.schema is True or self.schema is False:
 #elf._validators = []
 #lse:
 #elf._validators = [
 #self.VALIDATORS[k], k, v)
 #or k, v in applicable_validators(self.schema)
 #f k in self.VALIDATORS
 #

            # REMOVEME: Legacy ref resolution state management.
 #ush_scope = getattr(self._ref_resolver, "push_scope", None)
 #f push_scope is not None:
 #d = id_of(self.schema)
 #f id is not None:
 #ush_scope(id)

 #classmethod
 #ef check_schema(cls, schema, format_checker=_UNSET):
 #alidator = validator_for(cls.META_SCHEMA, default=cls)
 #f format_checker is _UNSET:
 #ormat_checker = Validator.FORMAT_CHECKER
 #alidator = Validator(
 #chema=cls.META_SCHEMA,
 #ormat_checker=format_checker,
 #
 #or error in validator.iter_errors(schema):
 #aise exceptions.SchemaError.create_from(error)

 #property
 #ef resolver(self):
 #arnings.warn(
 #
 #"Accessing {self.__class__.__name__}.resolver is "
 #deprecated as of v4.18.0, in favor of the "
 #https://github.com/python-jsonschema/referencing "
 #library, which provides more compliant referencing "
 #behavior as well as more flexible APIs for "
 #customization."
 #,
 #eprecationWarning,
 #tacklevel=2,
 #
 #f self._ref_resolver is None:
 #elf._ref_resolver = _RefResolver.from_schema(
 #elf.schema,
 #d_of=id_of,
 #
 #eturn self._ref_resolver

 #ef evolve(self, **changes):
 #chema = changes.setdefault("schema", self.schema)
 #ewValidator = validator_for(schema, default=self.__class__)

 #or (attr_name, init_name) in evolve_fields:
 #f init_name not in changes:
 #hanges[init_name] = getattr(self, attr_name)

 #eturn NewValidator(**changes)

 #ef iter_errors(self, instance, _schema=None):
 #f _schema is not None:
 #arnings.warn(
 #
 #Passing a schema to Validator.iter_errors "
 #is deprecated and will be removed in a future "
 #release. Call validator.evolve(schema=new_schema)."
 #iter_errors(...) instead."
 #,
 #eprecationWarning,
 #tacklevel=2,
 #
 #alidators = [
 #self.VALIDATORS[k], k, v)
 #or k, v in applicable_validators(_schema)
 #f k in self.VALIDATORS
 #
 #lse:
 #schema, validators = self.schema, self._validators

 #f _schema is True:
 #eturn
 #lif _schema is False:
 #ield exceptions.ValidationError(
 #"False schema does not allow {instance!r}",
 #alidator=None,
 #alidator_value=None,
 #nstance=instance,
 #chema=_schema,
 #
 #eturn

 #or validator, k, v in validators:
 #rrors = validator(self, v, instance, _schema) or ()
 #or error in errors:
                    # set details if not already set by the called fn
 #rror._set(
 #alidator=k,
 #alidator_value=v,
 #nstance=instance,
 #chema=_schema,
 #ype_checker=self.TYPE_CHECKER,
 #
 #f k not in {"if", "$ref"}:
 #rror.schema_path.appendleft(k)
 #ield error

 #ef descend(
 #elf,
 #nstance,
 #chema,
 #ath=None,
 #chema_path=None,
 #esolver=None,
 #:
 #f schema is True:
 #eturn
 #lif schema is False:
 #ield exceptions.ValidationError(
 #"False schema does not allow {instance!r}",
 #alidator=None,
 #alidator_value=None,
 #nstance=instance,
 #chema=schema,
 #
 #eturn

 #f self._ref_resolver is not None:
 #volved = self.evolve(schema=schema)
 #lse:
 #f resolver is None:
 #esolver = self._resolver.in_subresource(
 #pecification.create_resource(schema),
 #
 #volved = self.evolve(schema=schema, _resolver=resolver)

 #or k, v in applicable_validators(schema):
 #alidator = evolved.VALIDATORS.get(k)
 #f validator is None:
 #ontinue

 #rrors = validator(evolved, v, instance, schema) or ()
 #or error in errors:
                    # set details if not already set by the called fn
 #rror._set(
 #alidator=k,
 #alidator_value=v,
 #nstance=instance,
 #chema=schema,
 #ype_checker=evolved.TYPE_CHECKER,
 #
 #f k not in {"if", "$ref"}:
 #rror.schema_path.appendleft(k)
 #f path is not None:
 #rror.path.appendleft(path)
 #f schema_path is not None:
 #rror.schema_path.appendleft(schema_path)
 #ield error

 #ef validate(self, *args, **kwargs):
 #or error in self.iter_errors(*args, **kwargs):
 #aise error

 #ef is_type(self, instance, type):
 #ry:
 #eturn self.TYPE_CHECKER.is_type(instance, type)
 #xcept exceptions.UndefinedTypeCheck:
 #xc = exceptions.UnknownType(type, instance, self.schema)
 #aise exc from None

 #ef _validate_reference(self, ref, instance):
 #f self._ref_resolver is None:
 #ry:
 #esolved = self._resolver.lookup(ref)
 #xcept referencing.exceptions.Unresolvable as err:
 #aise exceptions._WrappedReferencingError(err) from err

 #eturn self.descend(
 #nstance,
 #esolved.contents,
 #esolver=resolved.resolver,
 #
 #lse:
 #esolve = getattr(self._ref_resolver, "resolve", None)
 #f resolve is None:
 #ith self._ref_resolver.resolving(ref) as resolved:
 #eturn self.descend(instance, resolved)
 #lse:
 #cope, resolved = resolve(ref)
 #elf._ref_resolver.push_scope(scope)

 #ry:
 #eturn list(self.descend(instance, resolved))
 #inally:
 #elf._ref_resolver.pop_scope()

 #ef is_valid(self, instance, _schema=None):
 #f _schema is not None:
 #arnings.warn(
 #
 #Passing a schema to Validator.is_valid is deprecated "
 #and will be removed in a future release. Call "
 #validator.evolve(schema=new_schema).is_valid(...) "
 #instead."
 #,
 #eprecationWarning,
 #tacklevel=2,
 #
 #elf = self.evolve(schema=_schema)

 #rror = next(self.iter_errors(instance), None)
 #eturn error is None

 #volve_fields = [
 #field.name, field.alias)
 #or field in fields(Validator)
 #f field.init
 #

 #f version is not None:
 #afe = version.title().replace(" ", "").replace("-", "")
 #alidator.__name__ = Validator.__qualname__ = f"{safe}Validator"
 #alidator = validates(version)(Validator)  # type: ignore[misc]

 #eturn Validator  # type: ignore[return-value]


def extend(
 #alidator,
 #alidators=(),
 #ersion=None,
 #ype_checker=None,
 #ormat_checker=None,
):
 #""
 #reate a new validator class by extending an existing one.

 #rguments:

 #alidator (jsonschema.protocols.Validator):

 #n existing validator class

 #alidators (collections.abc.Mapping):

 # mapping of new validator callables to extend with, whose
 #tructure is as in `create`.

 #. note::

 #ny validator callables with the same name as an
 #xisting one will (silently) replace the old validator
 #allable entirely, effectively overriding any validation
 #one in the "parent" validator class.

 #f you wish to instead extend the behavior of a parent's
 #alidator callable, delegate and call it directly in
 #he new validator function by retrieving it using
 #`OldValidator.VALIDATORS["validation_keyword_name"]``.

 #ersion (str):

 # version for the new validator class

 #ype_checker (jsonschema.TypeChecker):

 # type checker, used when applying the :kw:`type` keyword.

 #f unprovided, the type checker of the extended
 #jsonschema.protocols.Validator` will be carried along.

 #ormat_checker (jsonschema.FormatChecker):

 # format checker, used when applying the :kw:`format` keyword.

 #f unprovided, the format checker of the extended
 #jsonschema.protocols.Validator` will be carried along.

 #eturns:

 # new `jsonschema.protocols.Validator` class extending the one
 #rovided

 #. note:: Meta Schemas

 #he new validator class will have its parent's meta schema.

 #f you wish to change or extend the meta schema in the new
 #alidator class, modify ``META_SCHEMA`` directly on the returned
 #lass. Note that no implicit copying is done, so a copy should
 #ikely be made before modifying it, in order to not affect the
 #ld validator.

 #""
 #ll_validators = dict(validator.VALIDATORS)
 #ll_validators.update(validators)

 #f type_checker is None:
 #ype_checker = validator.TYPE_CHECKER
 #f format_checker is None:
 #ormat_checker = validator.FORMAT_CHECKER
 #eturn create(
 #eta_schema=validator.META_SCHEMA,
 #alidators=all_validators,
 #ersion=version,
 #ype_checker=type_checker,
 #ormat_checker=format_checker,
 #d_of=validator.ID_OF,
 #pplicable_validators=validator._APPLICABLE_VALIDATORS,
 #


Draft3Validator = create(
 #eta_schema=SPECIFICATIONS.contents(
 #http://json-schema.org/draft-03/schema#",
 #,
 #alidators={
 #$ref": _keywords.ref,
 #additionalItems": _legacy_keywords.additionalItems,
 #additionalProperties": _keywords.additionalProperties,
 #dependencies": _legacy_keywords.dependencies_draft3,
 #disallow": _legacy_keywords.disallow_draft3,
 #divisibleBy": _keywords.multipleOf,
 #enum": _keywords.enum,
 #extends": _legacy_keywords.extends_draft3,
 #format": _keywords.format,
 #items": _legacy_keywords.items_draft3_draft4,
 #maxItems": _keywords.maxItems,
 #maxLength": _keywords.maxLength,
 #maximum": _legacy_keywords.maximum_draft3_draft4,
 #minItems": _keywords.minItems,
 #minLength": _keywords.minLength,
 #minimum": _legacy_keywords.minimum_draft3_draft4,
 #pattern": _keywords.pattern,
 #patternProperties": _keywords.patternProperties,
 #properties": _legacy_keywords.properties_draft3,
 #type": _legacy_keywords.type_draft3,
 #uniqueItems": _keywords.uniqueItems,
 #,
 #ype_checker=_types.draft3_type_checker,
 #ormat_checker=_format.draft3_format_checker,
 #ersion="draft3",
 #d_of=referencing.jsonschema.DRAFT3.id_of,
 #pplicable_validators=_legacy_keywords.ignore_ref_siblings,
)

Draft4Validator = create(
 #eta_schema=SPECIFICATIONS.contents(
 #http://json-schema.org/draft-04/schema#",
 #,
 #alidators={
 #$ref": _keywords.ref,
 #additionalItems": _legacy_keywords.additionalItems,
 #additionalProperties": _keywords.additionalProperties,
 #allOf": _keywords.allOf,
 #anyOf": _keywords.anyOf,
 #dependencies": _legacy_keywords.dependencies_draft4_draft6_draft7,
 #enum": _keywords.enum,
 #format": _keywords.format,
 #items": _legacy_keywords.items_draft3_draft4,
 #maxItems": _keywords.maxItems,
 #maxLength": _keywords.maxLength,
 #maxProperties": _keywords.maxProperties,
 #maximum": _legacy_keywords.maximum_draft3_draft4,
 #minItems": _keywords.minItems,
 #minLength": _keywords.minLength,
 #minProperties": _keywords.minProperties,
 #minimum": _legacy_keywords.minimum_draft3_draft4,
 #multipleOf": _keywords.multipleOf,
 #not": _keywords.not_,
 #oneOf": _keywords.oneOf,
 #pattern": _keywords.pattern,
 #patternProperties": _keywords.patternProperties,
 #properties": _keywords.properties,
 #required": _keywords.required,
 #type": _keywords.type,
 #uniqueItems": _keywords.uniqueItems,
 #,
 #ype_checker=_types.draft4_type_checker,
 #ormat_checker=_format.draft4_format_checker,
 #ersion="draft4",
 #d_of=referencing.jsonschema.DRAFT4.id_of,
 #pplicable_validators=_legacy_keywords.ignore_ref_siblings,
)

Draft6Validator = create(
 #eta_schema=SPECIFICATIONS.contents(
 #http://json-schema.org/draft-06/schema#",
 #,
 #alidators={
 #$ref": _keywords.ref,
 #additionalItems": _legacy_keywords.additionalItems,
 #additionalProperties": _keywords.additionalProperties,
 #allOf": _keywords.allOf,
 #anyOf": _keywords.anyOf,
 #const": _keywords.const,
 #contains": _legacy_keywords.contains_draft6_draft7,
 #dependencies": _legacy_keywords.dependencies_draft4_draft6_draft7,
 #enum": _keywords.enum,
 #exclusiveMaximum": _keywords.exclusiveMaximum,
 #exclusiveMinimum": _keywords.exclusiveMinimum,
 #format": _keywords.format,
 #items": _legacy_keywords.items_draft6_draft7_draft201909,
 #maxItems": _keywords.maxItems,
 #maxLength": _keywords.maxLength,
 #maxProperties": _keywords.maxProperties,
 #maximum": _keywords.maximum,
 #minItems": _keywords.minItems,
 #minLength": _keywords.minLength,
 #minProperties": _keywords.minProperties,
 #minimum": _keywords.minimum,
 #multipleOf": _keywords.multipleOf,
 #not": _keywords.not_,
 #oneOf": _keywords.oneOf,
 #pattern": _keywords.pattern,
 #patternProperties": _keywords.patternProperties,
 #properties": _keywords.properties,
 #propertyNames": _keywords.propertyNames,
 #required": _keywords.required,
 #type": _keywords.type,
 #uniqueItems": _keywords.uniqueItems,
 #,
 #ype_checker=_types.draft6_type_checker,
 #ormat_checker=_format.draft6_format_checker,
 #ersion="draft6",
 #d_of=referencing.jsonschema.DRAFT6.id_of,
 #pplicable_validators=_legacy_keywords.ignore_ref_siblings,
)

Draft7Validator = create(
 #eta_schema=SPECIFICATIONS.contents(
 #http://json-schema.org/draft-07/schema#",
 #,
 #alidators={
 #$ref": _keywords.ref,
 #additionalItems": _legacy_keywords.additionalItems,
 #additionalProperties": _keywords.additionalProperties,
 #allOf": _keywords.allOf,
 #anyOf": _keywords.anyOf,
 #const": _keywords.const,
 #contains": _legacy_keywords.contains_draft6_draft7,
 #dependencies": _legacy_keywords.dependencies_draft4_draft6_draft7,
 #enum": _keywords.enum,
 #exclusiveMaximum": _keywords.exclusiveMaximum,
 #exclusiveMinimum": _keywords.exclusiveMinimum,
 #format": _keywords.format,
 #if": _keywords.if_,
 #items": _legacy_keywords.items_draft6_draft7_draft201909,
 #maxItems": _keywords.maxItems,
 #maxLength": _keywords.maxLength,
 #maxProperties": _keywords.maxProperties,
 #maximum": _keywords.maximum,
 #minItems": _keywords.minItems,
 #minLength": _keywords.minLength,
 #minProperties": _keywords.minProperties,
 #minimum": _keywords.minimum,
 #multipleOf": _keywords.multipleOf,
 #not": _keywords.not_,
 #oneOf": _keywords.oneOf,
 #pattern": _keywords.pattern,
 #patternProperties": _keywords.patternProperties,
 #properties": _keywords.properties,
 #propertyNames": _keywords.propertyNames,
 #required": _keywords.required,
 #type": _keywords.type,
 #uniqueItems": _keywords.uniqueItems,
 #,
 #ype_checker=_types.draft7_type_checker,
 #ormat_checker=_format.draft7_format_checker,
 #ersion="draft7",
 #d_of=referencing.jsonschema.DRAFT7.id_of,
 #pplicable_validators=_legacy_keywords.ignore_ref_siblings,
)

Draft201909Validator = create(
 #eta_schema=SPECIFICATIONS.contents(
 #https://json-schema.org/draft/2019-09/schema",
 #,
 #alidators={
 #$recursiveRef": _legacy_keywords.recursiveRef,
 #$ref": _keywords.ref,
 #additionalItems": _legacy_keywords.additionalItems,
 #additionalProperties": _keywords.additionalProperties,
 #allOf": _keywords.allOf,
 #anyOf": _keywords.anyOf,
 #const": _keywords.const,
 #contains": _keywords.contains,
 #dependentRequired": _keywords.dependentRequired,
 #dependentSchemas": _keywords.dependentSchemas,
 #enum": _keywords.enum,
 #exclusiveMaximum": _keywords.exclusiveMaximum,
 #exclusiveMinimum": _keywords.exclusiveMinimum,
 #format": _keywords.format,
 #if": _keywords.if_,
 #items": _legacy_keywords.items_draft6_draft7_draft201909,
 #maxItems": _keywords.maxItems,
 #maxLength": _keywords.maxLength,
 #maxProperties": _keywords.maxProperties,
 #maximum": _keywords.maximum,
 #minItems": _keywords.minItems,
 #minLength": _keywords.minLength,
 #minProperties": _keywords.minProperties,
 #minimum": _keywords.minimum,
 #multipleOf": _keywords.multipleOf,
 #not": _keywords.not_,
 #oneOf": _keywords.oneOf,
 #pattern": _keywords.pattern,
 #patternProperties": _keywords.patternProperties,
 #properties": _keywords.properties,
 #propertyNames": _keywords.propertyNames,
 #required": _keywords.required,
 #type": _keywords.type,
 #unevaluatedItems": _legacy_keywords.unevaluatedItems_draft2019,
 #unevaluatedProperties": (
 #legacy_keywords.unevaluatedProperties_draft2019
 #,
 #uniqueItems": _keywords.uniqueItems,
 #,
 #ype_checker=_types.draft201909_type_checker,
 #ormat_checker=_format.draft201909_format_checker,
 #ersion="draft2019-09",
)

Draft202012Validator = create(
 #eta_schema=SPECIFICATIONS.contents(
 #https://json-schema.org/draft/2020-12/schema",
 #,
 #alidators={
 #$dynamicRef": _keywords.dynamicRef,
 #$ref": _keywords.ref,
 #additionalProperties": _keywords.additionalProperties,
 #allOf": _keywords.allOf,
 #anyOf": _keywords.anyOf,
 #const": _keywords.const,
 #contains": _keywords.contains,
 #dependentRequired": _keywords.dependentRequired,
 #dependentSchemas": _keywords.dependentSchemas,
 #enum": _keywords.enum,
 #exclusiveMaximum": _keywords.exclusiveMaximum,
 #exclusiveMinimum": _keywords.exclusiveMinimum,
 #format": _keywords.format,
 #if": _keywords.if_,
 #items": _keywords.items,
 #maxItems": _keywords.maxItems,
 #maxLength": _keywords.maxLength,
 #maxProperties": _keywords.maxProperties,
 #maximum": _keywords.maximum,
 #minItems": _keywords.minItems,
 #minLength": _keywords.minLength,
 #minProperties": _keywords.minProperties,
 #minimum": _keywords.minimum,
 #multipleOf": _keywords.multipleOf,
 #not": _keywords.not_,
 #oneOf": _keywords.oneOf,
 #pattern": _keywords.pattern,
 #patternProperties": _keywords.patternProperties,
 #prefixItems": _keywords.prefixItems,
 #properties": _keywords.properties,
 #propertyNames": _keywords.propertyNames,
 #required": _keywords.required,
 #type": _keywords.type,
 #unevaluatedItems": _keywords.unevaluatedItems,
 #unevaluatedProperties": _keywords.unevaluatedProperties,
 #uniqueItems": _keywords.uniqueItems,
 #,
 #ype_checker=_types.draft202012_type_checker,
 #ormat_checker=_format.draft202012_format_checker,
 #ersion="draft2020-12",
)

_LATEST_VERSION: type[Validator] = Draft202012Validator


class _RefResolver:
 #""
 #esolve JSON References.

 #rguments:

 #ase_uri (str):

 #he URI of the referring document

 #eferrer:

 #he actual referring document

 #tore (dict):

 # mapping from URIs to documents to cache

 #ache_remote (bool):

 #hether remote refs should be cached after first resolution

 #andlers (dict):

 # mapping from URI schemes to functions that should be used
 #o retrieve them

 #rljoin_cache (:func:`functools.lru_cache`):

 # cache that will be used for caching the results of joining
 #he resolution scope to subscopes.

 #emote_cache (:func:`functools.lru_cache`):

 # cache that will be used for caching the results of
 #esolved remote URLs.

 #ttributes:

 #ache_remote (bool):

 #hether remote refs should be cached after first resolution

 #. deprecated:: v4.18.0

 #`RefResolver`` has been deprecated in favor of `referencing`.

 #""

 #DEPRECATION_MESSAGE = (
 #jsonschema.RefResolver is deprecated as of v4.18.0, in favor of the "
 #https://github.com/python-jsonschema/referencing library, which "
 #provides more compliant referencing behavior as well as more "
 #flexible APIs for customization. A future release will remove "
 #RefResolver. Please file a feature request (on referencing) if you "
 #are missing an API for the kind of customization you need."
 #

 #ef __init__(
 #elf,
 #ase_uri,
 #eferrer,
 #tore=HashTrieMap(),
 #ache_remote=True,
 #andlers=(),
 #rljoin_cache=None,
 #emote_cache=None,
 #:
 #f urljoin_cache is None:
 #rljoin_cache = lru_cache(1024)(urljoin)
 #f remote_cache is None:
 #emote_cache = lru_cache(1024)(self.resolve_from_url)

 #elf.referrer = referrer
 #elf.cache_remote = cache_remote
 #elf.handlers = dict(handlers)

 #elf._scopes_stack = [base_uri]

 #elf.store = _utils.URIDict(
 #uri, each.contents) for uri, each in SPECIFICATIONS.items()
 #
 #elf.store.update(
 #id, each.META_SCHEMA) for id, each in _META_SCHEMAS.items()
 #
 #elf.store.update(store)
 #elf.store.update(
 #schema["$id"], schema)
 #or schema in store.values()
 #f isinstance(schema, Mapping) and "$id" in schema
 #
 #elf.store[base_uri] = referrer

 #elf._urljoin_cache = urljoin_cache
 #elf._remote_cache = remote_cache

 #classmethod
 #ef from_schema(  # noqa: D417
 #ls,
 #chema,
 #d_of=referencing.jsonschema.DRAFT202012.id_of,
 #args,
 #*kwargs,
 #:
 #""
 #onstruct a resolver from a JSON schema object.

 #rguments:

 #chema:

 #he referring schema

 #eturns:

 #_RefResolver`

 #""
 #eturn cls(base_uri=id_of(schema) or "", referrer=schema, *args, **kwargs)  # noqa: B026, E501

 #ef push_scope(self, scope):
 #""
 #nter a given sub-scope.

 #reats further dereferences as being performed underneath the
 #iven scope.
 #""
 #elf._scopes_stack.append(
 #elf._urljoin_cache(self.resolution_scope, scope),
 #

 #ef pop_scope(self):
 #""
 #xit the most recent entered scope.

 #reats further dereferences as being performed underneath the
 #riginal scope.

 #on't call this method more times than `push_scope` has been
 #alled.
 #""
 #ry:
 #elf._scopes_stack.pop()
 #xcept IndexError:
 #aise exceptions._RefResolutionError(
 #Failed to pop the scope from an empty stack. "
 #`pop_scope()` should only be called once for every "
 #`push_scope()`",
 # from None

 #property
 #ef resolution_scope(self):
 #""
 #etrieve the current resolution scope.
 #""
 #eturn self._scopes_stack[-1]

 #property
 #ef base_uri(self):
 #""
 #etrieve the current base URI, not including any fragment.
 #""
 #ri, _ = urldefrag(self.resolution_scope)
 #eturn uri

 #contextlib.contextmanager
 #ef in_scope(self, scope):
 #""
 #emporarily enter the given scope for the duration of the context.

 #. deprecated:: v4.0.0
 #""
 #arnings.warn(
 #jsonschema.RefResolver.in_scope is deprecated and will be "
 #removed in a future release.",
 #eprecationWarning,
 #tacklevel=3,
 #
 #elf.push_scope(scope)
 #ry:
 #ield
 #inally:
 #elf.pop_scope()

 #contextlib.contextmanager
 #ef resolving(self, ref):
 #""
 #esolve the given ``ref`` and enter its resolution scope.

 #xits the scope on exit of this context manager.

 #rguments:

 #ef (str):

 #he reference to resolve

 #""
 #rl, resolved = self.resolve(ref)
 #elf.push_scope(url)
 #ry:
 #ield resolved
 #inally:
 #elf.pop_scope()

 #ef _find_in_referrer(self, key):
 #eturn self._get_subschemas_cache()[key]

 #lru_cache  # noqa: B019
 #ef _get_subschemas_cache(self):
 #ache = {key: [] for key in _SUBSCHEMAS_KEYWORDS}
 #or keyword, subschema in _search_schema(
 #elf.referrer, _match_subschema_keywords,
 #:
 #ache[keyword].append(subschema)
 #eturn cache

 #lru_cache  # noqa: B019
 #ef _find_in_subschemas(self, url):
 #ubschemas = self._get_subschemas_cache()["$id"]
 #f not subschemas:
 #eturn None
 #ri, fragment = urldefrag(url)
 #or subschema in subschemas:
 #d = subschema["$id"]
 #f not isinstance(id, str):
 #ontinue
 #arget_uri = self._urljoin_cache(self.resolution_scope, id)
 #f target_uri.rstrip("/") == uri.rstrip("/"):
 #f fragment:
 #ubschema = self.resolve_fragment(subschema, fragment)
 #elf.store[url] = subschema
 #eturn url, subschema
 #eturn None

 #ef resolve(self, ref):
 #""
 #esolve the given reference.
 #""
 #rl = self._urljoin_cache(self.resolution_scope, ref).rstrip("/")

 #atch = self._find_in_subschemas(url)
 #f match is not None:
 #eturn match

 #eturn url, self._remote_cache(url)

 #ef resolve_from_url(self, url):
 #""
 #esolve the given URL.
 #""
 #rl, fragment = urldefrag(url)
 #f not url:
 #rl = self.base_uri

 #ry:
 #ocument = self.store[url]
 #xcept KeyError:
 #ry:
 #ocument = self.resolve_remote(url)
 #xcept Exception as exc:
 #aise exceptions._RefResolutionError(exc) from exc

 #eturn self.resolve_fragment(document, fragment)

 #ef resolve_fragment(self, document, fragment):
 #""
 #esolve a ``fragment`` within the referenced ``document``.

 #rguments:

 #ocument:

 #he referent document

 #ragment (str):

 # URI fragment to resolve within it

 #""
 #ragment = fragment.lstrip("/")

 #f not fragment:
 #eturn document

 #f document is self.referrer:
 #ind = self._find_in_referrer
 #lse:

 #ef find(key):
 #ield from _search_schema(document, _match_keyword(key))

 #or keyword in ["$anchor", "$dynamicAnchor"]:
 #or subschema in find(keyword):
 #f fragment == subschema[keyword]:
 #eturn subschema
 #or keyword in ["id", "$id"]:
 #or subschema in find(keyword):
 #f "#" + fragment == subschema[keyword]:
 #eturn subschema

        # Resolve via path
 #arts = unquote(fragment).split("/") if fragment else []
 #or part in parts:
 #art = part.replace("~1", "/").replace("~0", "~")

 #f isinstance(document, Sequence):
 #ry:  # noqa: SIM105
 #art = int(part)
 #xcept ValueError:
 #ass
 #ry:
 #ocument = document[part]
 #xcept (TypeError, LookupError) as err:
 #aise exceptions._RefResolutionError(
 #"Unresolvable JSON pointer: {fragment!r}",
 # from err

 #eturn document

 #ef resolve_remote(self, uri):
 #""
 #esolve a remote ``uri``.

 #f called directly, does not check the store first, but after
 #etrieving the document at the specified URI it will be saved in
 #he store if :attr:`cache_remote` is True.

 #. note::

 #f the requests_ library is present, ``jsonschema`` will use it to
 #equest the remote ``uri``, so that the correct encoding is
 #etected and used.

 #f it isn't, or if the scheme of the ``uri`` is not ``http`` or
 #`https``, UTF-8 is assumed.

 #rguments:

 #ri (str):

 #he URI to resolve

 #eturns:

 #he retrieved document

 #. _requests: https://pypi.org/project/requests/

 #""
 #ry:
 #mport requests
 #xcept ImportError:
 #equests = None

 #cheme = urlsplit(uri).scheme

 #f scheme in self.handlers:
 #esult = self.handlers[scheme](uri)
 #lif scheme in ["http", "https"] and requests:
            # Requests has support for detecting the correct encoding of
            # json over http
 #esult = requests.get(uri).json()
 #lse:
            # Otherwise, pass off to urllib and assume utf-8
 #ith urlopen(uri) as url:  # noqa: S310
 #esult = json.loads(url.read().decode("utf-8"))

 #f self.cache_remote:
 #elf.store[uri] = result
 #eturn result


_SUBSCHEMAS_KEYWORDS = ("$id", "id", "$anchor", "$dynamicAnchor")


def _match_keyword(keyword):

 #ef matcher(value):
 #f keyword in value:
 #ield value

 #eturn matcher


def _match_subschema_keywords(value):
 #or keyword in _SUBSCHEMAS_KEYWORDS:
 #f keyword in value:
 #ield keyword, value


def _search_schema(schema, matcher):
 #""Breadth-first search routine."""
 #alues = deque([schema])
 #hile values:
 #alue = values.pop()
 #f not isinstance(value, dict):
 #ontinue
 #ield from matcher(value)
 #alues.extendleft(value.values())


def validate(instance, schema, cls=None, *args, **kwargs):  # noqa: D417
 #""
 #alidate an instance under the given schema.

 #>> validate([2, 3, 4], {"maxItems": 2})
 #raceback (most recent call last):
 #..
 #alidationError: [2, 3, 4] is too long

 #func:`~jsonschema.validators.validate` will first verify that the
 #rovided schema is itself valid, since not doing so can lead to less
 #bvious error messages and fail in less obvious or consistent ways.

 #f you know you have a valid schema already, especially
 #f you intend to validate multiple instances with
 #he same schema, you likely would prefer using the
 #jsonschema.protocols.Validator.validate` method directly on a
 #pecific validator (e.g. ``Draft202012Validator.validate``).


 #rguments:

 #nstance:

 #he instance to validate

 #chema:

 #he schema to validate with

 #ls (jsonschema.protocols.Validator):

 #he class that will be used to validate the instance.

 #f the ``cls`` argument is not provided, two things will happen
 #n accordance with the specification. First, if the schema has a
 #kw:`$schema` keyword containing a known meta-schema [#]_ then the
 #roper validator will be used. The specification recommends that
 #ll schemas contain :kw:`$schema` properties for this reason. If no
 #kw:`$schema` property is found, the default validator class is the
 #atest released draft.

 #ny other provided positional and keyword arguments will be passed
 #n when instantiating the ``cls``.

 #aises:

 #jsonschema.exceptions.ValidationError`:

 #f the instance is invalid

 #jsonschema.exceptions.SchemaError`:

 #f the schema itself is invalid

 #. rubric:: Footnotes
 #. [#] known by a validator registered with
 #jsonschema.validators.validates`

 #""
 #f cls is None:
 #ls = validator_for(schema)

 #ls.check_schema(schema)
 #alidator = cls(schema, *args, **kwargs)
 #rror = exceptions.best_match(validator.iter_errors(instance))
 #f error is not None:
 #aise error


def validator_for(
 #chema,
 #efault: type[Validator] | _utils.Unset = _UNSET,
) -> type[Validator]:
 #""
 #etrieve the validator class appropriate for validating the given schema.

 #ses the :kw:`$schema` keyword that should be present in the given
 #chema to look up the appropriate validator class.

 #rguments:

 #chema (collections.abc.Mapping or bool):

 #he schema to look at

 #efault:

 #he default to return if the appropriate validator class
 #annot be determined.

 #f unprovided, the default is to return the latest supported
 #raft.

 #xamples:

 #he :kw:`$schema` JSON Schema keyword will control which validator
 #lass is returned:

 #>> schema = {
 #..     "$schema": "https://json-schema.org/draft/2020-12/schema",
 #..     "type": "integer",
 #.. }
 #>> jsonschema.validators.validator_for(schema)
 #class 'jsonschema.validators.Draft202012Validator'>


 #ere, a draft 7 schema instead will return the draft 7 validator:

 #>> schema = {
 #..     "$schema": "http://json-schema.org/draft-07/schema#",
 #..     "type": "integer",
 #.. }
 #>> jsonschema.validators.validator_for(schema)
 #class 'jsonschema.validators.Draft7Validator'>


 #chemas with no ``$schema`` keyword will fallback to the default
 #rgument:

 #>> schema = {"type": "integer"}
 #>> jsonschema.validators.validator_for(
 #..     schema, default=Draft7Validator,
 #.. )
 #class 'jsonschema.validators.Draft7Validator'>

 #r if none is provided, to the latest version supported.
 #lways including the keyword when authoring schemas is highly
 #ecommended.

 #""
 #efaultValidator = _LATEST_VERSION if default is _UNSET else default

 #f schema is True or schema is False or "$schema" not in schema:
 #eturn DefaultValidator  # type: ignore[return-value]
 #f schema["$schema"] not in _META_SCHEMAS and default is _UNSET:
 #arn(
 #
 #The metaschema specified by $schema was not found. "
 #Using the latest draft to validate, but this will raise "
 #an error in the future."
 #,
 #eprecationWarning,
 #tacklevel=2,
 #
 #eturn _META_SCHEMAS.get(schema["$schema"], DefaultValidator)
