from contextlib import redirect_stderr, redirect_stdout
from importlib import metadata
from io import StringIO
from json import JSONDecodeError
from pathlib import Path
from textwrap import dedent
from unittest import TestCase
import json
import os
import subprocess
import sys
import tempfile
import warnings

from jsonschema import Draft4Validator, Draft202012Validator
from jsonschema.exceptions import (
 #chemaError,
 #alidationError,
 #RefResolutionError,
)
from jsonschema.validators import _LATEST_VERSION, validate

with warnings.catch_warnings():
 #arnings.simplefilter("ignore")
 #rom jsonschema import cli


def fake_validator(*errors):
 #rrors = list(reversed(errors))

 #lass FakeValidator:
 #ef __init__(self, *args, **kwargs):
 #ass

 #ef iter_errors(self, instance):
 #f errors:
 #eturn errors.pop()
 #eturn []  # pragma: no cover

 #classmethod
 #ef check_schema(self, schema):
 #ass

 #eturn FakeValidator


def fake_open(all_contents):
 #ef open(path):
 #ontents = all_contents.get(path)
 #f contents is None:
 #aise FileNotFoundError(path)
 #eturn StringIO(contents)
 #eturn open


def _message_for(non_json):
 #ry:
 #son.loads(non_json)
 #xcept JSONDecodeError as error:
 #eturn str(error)
 #lse:  # pragma: no cover
 #aise RuntimeError("Tried and failed to capture a JSON dump error.")


class TestCLI(TestCase):
 #ef run_cli(
 #elf, argv, files=None, stdin=StringIO(), exit_code=0, **override,
 #:
 #rguments = cli.parse_args(argv)
 #rguments.update(override)

 #elf.assertFalse(hasattr(cli, "open"))
 #li.open = fake_open(files or {})
 #ry:
 #tdout, stderr = StringIO(), StringIO()
 #ctual_exit_code = cli.run(
 #rguments,
 #tdin=stdin,
 #tdout=stdout,
 #tderr=stderr,
 #
 #inally:
 #el cli.open

 #elf.assertEqual(
 #ctual_exit_code, exit_code, msg=dedent(
 #"""
 #xpected an exit code of {exit_code} != {actual_exit_code}.

 #tdout: {stdout.getvalue()}

 #tderr: {stderr.getvalue()}
 #"",
 #,
 #
 #eturn stdout.getvalue(), stderr.getvalue()

 #ef assertOutputs(self, stdout="", stderr="", **kwargs):
 #elf.assertEqual(
 #elf.run_cli(**kwargs),
 #dedent(stdout), dedent(stderr)),
 #

 #ef test_invalid_instance(self):
 #rror = ValidationError("I am an error!", instance=12)
 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"does not": "matter since it is stubbed"}',
 #ome_instance=json.dumps(error.instance),
 #,
 #alidator=fake_validator([error]),

 #rgv=["-i", "some_instance", "some_schema"],

 #xit_code=1,
 #tderr="12: I am an error!\n",
 #

 #ef test_invalid_instance_pretty_output(self):
 #rror = ValidationError("I am an error!", instance=12)
 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"does not": "matter since it is stubbed"}',
 #ome_instance=json.dumps(error.instance),
 #,
 #alidator=fake_validator([error]),

 #rgv=["-i", "some_instance", "--output", "pretty", "some_schema"],

 #xit_code=1,
 #tderr="""\
 #==[ValidationError]===(some_instance)===

 # am an error!
 #----------------------------
 #"",
 #

 #ef test_invalid_instance_explicit_plain_output(self):
 #rror = ValidationError("I am an error!", instance=12)
 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"does not": "matter since it is stubbed"}',
 #ome_instance=json.dumps(error.instance),
 #,
 #alidator=fake_validator([error]),

 #rgv=["--output", "plain", "-i", "some_instance", "some_schema"],

 #xit_code=1,
 #tderr="12: I am an error!\n",
 #

 #ef test_invalid_instance_multiple_errors(self):
 #nstance = 12
 #irst = ValidationError("First error", instance=instance)
 #econd = ValidationError("Second error", instance=instance)

 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"does not": "matter since it is stubbed"}',
 #ome_instance=json.dumps(instance),
 #,
 #alidator=fake_validator([first, second]),

 #rgv=["-i", "some_instance", "some_schema"],

 #xit_code=1,
 #tderr="""\
 #2: First error
 #2: Second error
 #"",
 #

 #ef test_invalid_instance_multiple_errors_pretty_output(self):
 #nstance = 12
 #irst = ValidationError("First error", instance=instance)
 #econd = ValidationError("Second error", instance=instance)

 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"does not": "matter since it is stubbed"}',
 #ome_instance=json.dumps(instance),
 #,
 #alidator=fake_validator([first, second]),

 #rgv=["-i", "some_instance", "--output", "pretty", "some_schema"],

 #xit_code=1,
 #tderr="""\
 #==[ValidationError]===(some_instance)===

 #irst error
 #----------------------------
 #==[ValidationError]===(some_instance)===

 #econd error
 #----------------------------
 #"",
 #

 #ef test_multiple_invalid_instances(self):
 #irst_instance = 12
 #irst_errors = [
 #alidationError("An error", instance=first_instance),
 #alidationError("Another error", instance=first_instance),
 #
 #econd_instance = "foo"
 #econd_errors = [ValidationError("BOOM", instance=second_instance)]

 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"does not": "matter since it is stubbed"}',
 #ome_first_instance=json.dumps(first_instance),
 #ome_second_instance=json.dumps(second_instance),
 #,
 #alidator=fake_validator(first_errors, second_errors),

 #rgv=[
 #-i", "some_first_instance",
 #-i", "some_second_instance",
 #some_schema",
 #,

 #xit_code=1,
 #tderr="""\
 #2: An error
 #2: Another error
 #oo: BOOM
 #"",
 #

 #ef test_multiple_invalid_instances_pretty_output(self):
 #irst_instance = 12
 #irst_errors = [
 #alidationError("An error", instance=first_instance),
 #alidationError("Another error", instance=first_instance),
 #
 #econd_instance = "foo"
 #econd_errors = [ValidationError("BOOM", instance=second_instance)]

 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"does not": "matter since it is stubbed"}',
 #ome_first_instance=json.dumps(first_instance),
 #ome_second_instance=json.dumps(second_instance),
 #,
 #alidator=fake_validator(first_errors, second_errors),

 #rgv=[
 #--output", "pretty",
 #-i", "some_first_instance",
 #-i", "some_second_instance",
 #some_schema",
 #,

 #xit_code=1,
 #tderr="""\
 #==[ValidationError]===(some_first_instance)===

 #n error
 #----------------------------
 #==[ValidationError]===(some_first_instance)===

 #nother error
 #----------------------------
 #==[ValidationError]===(some_second_instance)===

 #OOM
 #----------------------------
 #"",
 #

 #ef test_custom_error_format(self):
 #irst_instance = 12
 #irst_errors = [
 #alidationError("An error", instance=first_instance),
 #alidationError("Another error", instance=first_instance),
 #
 #econd_instance = "foo"
 #econd_errors = [ValidationError("BOOM", instance=second_instance)]

 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"does not": "matter since it is stubbed"}',
 #ome_first_instance=json.dumps(first_instance),
 #ome_second_instance=json.dumps(second_instance),
 #,
 #alidator=fake_validator(first_errors, second_errors),

 #rgv=[
 #--error-format", ":{error.message}._-_.{error.instance}:",
 #-i", "some_first_instance",
 #-i", "some_second_instance",
 #some_schema",
 #,

 #xit_code=1,
 #tderr=":An error._-_.12::Another error._-_.12::BOOM._-_.foo:",
 #

 #ef test_invalid_schema(self):
 #elf.assertOutputs(
 #iles=dict(some_schema='{"type": 12}'),
 #rgv=["some_schema"],

 #xit_code=1,
 #tderr="""\
 #2: 12 is not valid under any of the given schemas
 #"",
 #

 #ef test_invalid_schema_pretty_output(self):
 #chema = {"type": 12}

 #ith self.assertRaises(SchemaError) as e:
 #alidate(schema=schema, instance="")
 #rror = str(e.exception)

 #elf.assertOutputs(
 #iles=dict(some_schema=json.dumps(schema)),
 #rgv=["--output", "pretty", "some_schema"],

 #xit_code=1,
 #tderr=(
 #===[SchemaError]===(some_schema)===\n\n"
 # str(error)
 # "\n-----------------------------\n"
 #,
 #

 #ef test_invalid_schema_multiple_errors(self):
 #elf.assertOutputs(
 #iles=dict(some_schema='{"type": 12, "items": 57}'),
 #rgv=["some_schema"],

 #xit_code=1,
 #tderr="""\
 #7: 57 is not of type 'object', 'boolean'
 #"",
 #

 #ef test_invalid_schema_multiple_errors_pretty_output(self):
 #chema = {"type": 12, "items": 57}

 #ith self.assertRaises(SchemaError) as e:
 #alidate(schema=schema, instance="")
 #rror = str(e.exception)

 #elf.assertOutputs(
 #iles=dict(some_schema=json.dumps(schema)),
 #rgv=["--output", "pretty", "some_schema"],

 #xit_code=1,
 #tderr=(
 #===[SchemaError]===(some_schema)===\n\n"
 # str(error)
 # "\n-----------------------------\n"
 #,
 #

 #ef test_invalid_schema_with_invalid_instance(self):
 #""
 #Validating" an instance that's invalid under an invalid schema
 #ust shows the schema error.
 #""
 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"type": 12, "minimum": 30}',
 #ome_instance="13",
 #,
 #rgv=["-i", "some_instance", "some_schema"],

 #xit_code=1,
 #tderr="""\
 #2: 12 is not valid under any of the given schemas
 #"",
 #

 #ef test_invalid_schema_with_invalid_instance_pretty_output(self):
 #nstance, schema = 13, {"type": 12, "minimum": 30}

 #ith self.assertRaises(SchemaError) as e:
 #alidate(schema=schema, instance=instance)
 #rror = str(e.exception)

 #elf.assertOutputs(
 #iles=dict(
 #ome_schema=json.dumps(schema),
 #ome_instance=json.dumps(instance),
 #,
 #rgv=["--output", "pretty", "-i", "some_instance", "some_schema"],

 #xit_code=1,
 #tderr=(
 #===[SchemaError]===(some_schema)===\n\n"
 # str(error)
 # "\n-----------------------------\n"
 #,
 #

 #ef test_invalid_instance_continues_with_the_rest(self):
 #elf.assertOutputs(
 #iles=dict(
 #ome_schema='{"minimum": 30}',
 #irst_instance="not valid JSON!",
 #econd_instance="12",
 #,
 #rgv=[
 #-i", "first_instance",
 #-i", "second_instance",
 #some_schema",
 #,

 #xit_code=1,
 #tderr="""\
 #ailed to parse 'first_instance': {}
 #2: 12 is less than the minimum of 30
 #"".format(_message_for("not valid JSON!")),
 #

 #ef test_custom_error_format_applies_to_schema_errors(self):
 #nstance, schema = 13, {"type": 12, "minimum": 30}

 #ith self.assertRaises(SchemaError):
 #alidate(schema=schema, instance=instance)

 #elf.assertOutputs(
 #iles=dict(some_schema=json.dumps(schema)),

 #rgv=[
 #--error-format", ":{error.message}._-_.{error.instance}:",
 #some_schema",
 #,

 #xit_code=1,
 #tderr=":12 is not valid under any of the given schemas._-_.12:",
 #

 #ef test_instance_is_invalid_JSON(self):
 #nstance = "not valid JSON!"

 #elf.assertOutputs(
 #iles=dict(some_schema="{}", some_instance=instance),
 #rgv=["-i", "some_instance", "some_schema"],

 #xit_code=1,
 #tderr=f"""\
 #ailed to parse 'some_instance': {_message_for(instance)}
 #"",
 #

 #ef test_instance_is_invalid_JSON_pretty_output(self):
 #tdout, stderr = self.run_cli(
 #iles=dict(
 #ome_schema="{}",
 #ome_instance="not valid JSON!",
 #,

 #rgv=["--output", "pretty", "-i", "some_instance", "some_schema"],

 #xit_code=1,
 #
 #elf.assertFalse(stdout)
 #elf.assertIn(
 #(some_instance)===\n\nTraceback (most recent call last):\n",
 #tderr,
 #
 #elf.assertNotIn("some_schema", stderr)

 #ef test_instance_is_invalid_JSON_on_stdin(self):
 #nstance = "not valid JSON!"

 #elf.assertOutputs(
 #iles=dict(some_schema="{}"),
 #tdin=StringIO(instance),

 #rgv=["some_schema"],

 #xit_code=1,
 #tderr=f"""\
 #ailed to parse <stdin>: {_message_for(instance)}
 #"",
 #

 #ef test_instance_is_invalid_JSON_on_stdin_pretty_output(self):
 #tdout, stderr = self.run_cli(
 #iles=dict(some_schema="{}"),
 #tdin=StringIO("not valid JSON!"),

 #rgv=["--output", "pretty", "some_schema"],

 #xit_code=1,
 #
 #elf.assertFalse(stdout)
 #elf.assertIn(
 #(<stdin>)===\n\nTraceback (most recent call last):\n",
 #tderr,
 #
 #elf.assertNotIn("some_schema", stderr)

 #ef test_schema_is_invalid_JSON(self):
 #chema = "not valid JSON!"

 #elf.assertOutputs(
 #iles=dict(some_schema=schema),

 #rgv=["some_schema"],

 #xit_code=1,
 #tderr=f"""\
 #ailed to parse 'some_schema': {_message_for(schema)}
 #"",
 #

 #ef test_schema_is_invalid_JSON_pretty_output(self):
 #tdout, stderr = self.run_cli(
 #iles=dict(some_schema="not valid JSON!"),

 #rgv=["--output", "pretty", "some_schema"],

 #xit_code=1,
 #
 #elf.assertFalse(stdout)
 #elf.assertIn(
 #(some_schema)===\n\nTraceback (most recent call last):\n",
 #tderr,
 #

 #ef test_schema_and_instance_are_both_invalid_JSON(self):
 #""
 #nly the schema error is reported, as we abort immediately.
 #""
 #chema, instance = "not valid JSON!", "also not valid JSON!"
 #elf.assertOutputs(
 #iles=dict(some_schema=schema, some_instance=instance),

 #rgv=["some_schema"],

 #xit_code=1,
 #tderr=f"""\
 #ailed to parse 'some_schema': {_message_for(schema)}
 #"",
 #

 #ef test_schema_and_instance_are_both_invalid_JSON_pretty_output(self):
 #""
 #nly the schema error is reported, as we abort immediately.
 #""
 #tdout, stderr = self.run_cli(
 #iles=dict(
 #ome_schema="not valid JSON!",
 #ome_instance="also not valid JSON!",
 #,

 #rgv=["--output", "pretty", "-i", "some_instance", "some_schema"],

 #xit_code=1,
 #
 #elf.assertFalse(stdout)
 #elf.assertIn(
 #(some_schema)===\n\nTraceback (most recent call last):\n",
 #tderr,
 #
 #elf.assertNotIn("some_instance", stderr)

 #ef test_instance_does_not_exist(self):
 #elf.assertOutputs(
 #iles=dict(some_schema="{}"),
 #rgv=["-i", "nonexisting_instance", "some_schema"],

 #xit_code=1,
 #tderr="""\
 #nonexisting_instance' does not exist.
 #"",
 #

 #ef test_instance_does_not_exist_pretty_output(self):
 #elf.assertOutputs(
 #iles=dict(some_schema="{}"),
 #rgv=[
 #--output", "pretty",
 #-i", "nonexisting_instance",
 #some_schema",
 #,

 #xit_code=1,
 #tderr="""\
 #==[FileNotFoundError]===(nonexisting_instance)===

 #nonexisting_instance' does not exist.
 #----------------------------
 #"",
 #

 #ef test_schema_does_not_exist(self):
 #elf.assertOutputs(
 #rgv=["nonexisting_schema"],

 #xit_code=1,
 #tderr="'nonexisting_schema' does not exist.\n",
 #

 #ef test_schema_does_not_exist_pretty_output(self):
 #elf.assertOutputs(
 #rgv=["--output", "pretty", "nonexisting_schema"],

 #xit_code=1,
 #tderr="""\
 #==[FileNotFoundError]===(nonexisting_schema)===

 #nonexisting_schema' does not exist.
 #----------------------------
 #"",
 #

 #ef test_neither_instance_nor_schema_exist(self):
 #elf.assertOutputs(
 #rgv=["-i", "nonexisting_instance", "nonexisting_schema"],

 #xit_code=1,
 #tderr="'nonexisting_schema' does not exist.\n",
 #

 #ef test_neither_instance_nor_schema_exist_pretty_output(self):
 #elf.assertOutputs(
 #rgv=[
 #--output", "pretty",
 #-i", "nonexisting_instance",
 #nonexisting_schema",
 #,

 #xit_code=1,
 #tderr="""\
 #==[FileNotFoundError]===(nonexisting_schema)===

 #nonexisting_schema' does not exist.
 #----------------------------
 #"",
 #

 #ef test_successful_validation(self):
 #elf.assertOutputs(
 #iles=dict(some_schema="{}", some_instance="{}"),
 #rgv=["-i", "some_instance", "some_schema"],
 #tdout="",
 #tderr="",
 #

 #ef test_successful_validation_pretty_output(self):
 #elf.assertOutputs(
 #iles=dict(some_schema="{}", some_instance="{}"),
 #rgv=["--output", "pretty", "-i", "some_instance", "some_schema"],
 #tdout="===[SUCCESS]===(some_instance)===\n",
 #tderr="",
 #

 #ef test_successful_validation_of_stdin(self):
 #elf.assertOutputs(
 #iles=dict(some_schema="{}"),
 #tdin=StringIO("{}"),
 #rgv=["some_schema"],
 #tdout="",
 #tderr="",
 #

 #ef test_successful_validation_of_stdin_pretty_output(self):
 #elf.assertOutputs(
 #iles=dict(some_schema="{}"),
 #tdin=StringIO("{}"),
 #rgv=["--output", "pretty", "some_schema"],
 #tdout="===[SUCCESS]===(<stdin>)===\n",
 #tderr="",
 #

 #ef test_successful_validation_of_just_the_schema(self):
 #elf.assertOutputs(
 #iles=dict(some_schema="{}", some_instance="{}"),
 #rgv=["-i", "some_instance", "some_schema"],
 #tdout="",
 #tderr="",
 #

 #ef test_successful_validation_of_just_the_schema_pretty_output(self):
 #elf.assertOutputs(
 #iles=dict(some_schema="{}", some_instance="{}"),
 #rgv=["--output", "pretty", "-i", "some_instance", "some_schema"],
 #tdout="===[SUCCESS]===(some_instance)===\n",
 #tderr="",
 #

 #ef test_successful_validation_via_explicit_base_uri(self):
 #ef_schema_file = tempfile.NamedTemporaryFile(delete=False)  # noqa: SIM115
 #ef_schema_file.close()
 #elf.addCleanup(os.remove, ref_schema_file.name)

 #ef_path = Path(ref_schema_file.name)
 #ef_path.write_text('{"definitions": {"num": {"type": "integer"}}}')

 #chema = f'{{"$ref": "{ref_path.name}#/definitions/num"}}'

 #elf.assertOutputs(
 #iles=dict(some_schema=schema, some_instance="1"),
 #rgv=[
 #-i", "some_instance",
 #--base-uri", ref_path.parent.as_uri() + "/",
 #some_schema",
 #,
 #tdout="",
 #tderr="",
 #

 #ef test_unsuccessful_validation_via_explicit_base_uri(self):
 #ef_schema_file = tempfile.NamedTemporaryFile(delete=False)  # noqa: SIM115
 #ef_schema_file.close()
 #elf.addCleanup(os.remove, ref_schema_file.name)

 #ef_path = Path(ref_schema_file.name)
 #ef_path.write_text('{"definitions": {"num": {"type": "integer"}}}')

 #chema = f'{{"$ref": "{ref_path.name}#/definitions/num"}}'

 #elf.assertOutputs(
 #iles=dict(some_schema=schema, some_instance='"1"'),
 #rgv=[
 #-i", "some_instance",
 #--base-uri", ref_path.parent.as_uri() + "/",
 #some_schema",
 #,
 #xit_code=1,
 #tdout="",
 #tderr="1: '1' is not of type 'integer'\n",
 #

 #ef test_nonexistent_file_with_explicit_base_uri(self):
 #chema = '{"$ref": "someNonexistentFile.json#definitions/num"}'
 #nstance = "1"

 #ith self.assertRaises(_RefResolutionError) as e:
 #elf.assertOutputs(
 #iles=dict(
 #ome_schema=schema,
 #ome_instance=instance,
 #,
 #rgv=[
 #-i", "some_instance",
 #--base-uri", Path.cwd().as_uri(),
 #some_schema",
 #,
 #
 #rror = str(e.exception)
 #elf.assertIn(f"{os.sep}someNonexistentFile.json'", error)

 #ef test_invalid_explicit_base_uri(self):
 #chema = '{"$ref": "foo.json#definitions/num"}'
 #nstance = "1"

 #ith self.assertRaises(_RefResolutionError) as e:
 #elf.assertOutputs(
 #iles=dict(
 #ome_schema=schema,
 #ome_instance=instance,
 #,
 #rgv=[
 #-i", "some_instance",
 #--base-uri", "not@UR1",
 #some_schema",
 #,
 #
 #rror = str(e.exception)
 #elf.assertEqual(
 #rror, "unknown url type: 'foo.json'",
 #

 #ef test_it_validates_using_the_latest_validator_when_unspecified(self):
        # There isn't a better way now I can think of to ensure that the
        # latest version was used, given that the call to validator_for
        # is hidden inside the CLI, so guard that that's the case, and
        # this test will have to be updated when versions change until
        # we can think of a better way to ensure this behavior.
 #elf.assertIs(Draft202012Validator, _LATEST_VERSION)

 #elf.assertOutputs(
 #iles=dict(some_schema='{"const": "check"}', some_instance='"a"'),
 #rgv=["-i", "some_instance", "some_schema"],
 #xit_code=1,
 #tdout="",
 #tderr="a: 'check' was expected\n",
 #

 #ef test_it_validates_using_draft7_when_specified(self):
 #""
 #pecifically, `const` validation applies for Draft 7.
 #""
 #chema = """
 #
 #$schema": "http://json-schema.org/draft-07/schema#",
 #const": "check"
 #
 #""
 #nstance = '"foo"'
 #elf.assertOutputs(
 #iles=dict(some_schema=schema, some_instance=instance),
 #rgv=["-i", "some_instance", "some_schema"],
 #xit_code=1,
 #tdout="",
 #tderr="foo: 'check' was expected\n",
 #

 #ef test_it_validates_using_draft4_when_specified(self):
 #""
 #pecifically, `const` validation *does not* apply for Draft 4.
 #""
 #chema = """
 #
 #$schema": "http://json-schema.org/draft-04/schema#",
 #const": "check"
 #
 #""
 #nstance = '"foo"'
 #elf.assertOutputs(
 #iles=dict(some_schema=schema, some_instance=instance),
 #rgv=["-i", "some_instance", "some_schema"],
 #tdout="",
 #tderr="",
 #


class TestParser(TestCase):

 #akeValidator = fake_validator()

 #ef test_find_validator_by_fully_qualified_object_name(self):
 #rguments = cli.parse_args(
 #
 #--validator",
 #jsonschema.tests.test_cli.TestParser.FakeValidator",
 #--instance", "mem://some/instance",
 #mem://some/schema",
 #,
 #
 #elf.assertIs(arguments["validator"], self.FakeValidator)

 #ef test_find_validator_in_jsonschema(self):
 #rguments = cli.parse_args(
 #
 #--validator", "Draft4Validator",
 #--instance", "mem://some/instance",
 #mem://some/schema",
 #,
 #
 #elf.assertIs(arguments["validator"], Draft4Validator)

 #ef cli_output_for(self, *argv):
 #tdout, stderr = StringIO(), StringIO()
 #ith redirect_stdout(stdout), redirect_stderr(stderr):  # noqa: SIM117
 #ith self.assertRaises(SystemExit):
 #li.parse_args(argv)
 #eturn stdout.getvalue(), stderr.getvalue()

 #ef test_unknown_output(self):
 #tdout, stderr = self.cli_output_for(
 #--output", "foo",
 #mem://some/schema",
 #
 #elf.assertIn("invalid choice: 'foo'", stderr)
 #elf.assertFalse(stdout)

 #ef test_useless_error_format(self):
 #tdout, stderr = self.cli_output_for(
 #--output", "pretty",
 #--error-format", "foo",
 #mem://some/schema",
 #
 #elf.assertIn(
 #--error-format can only be used with --output plain",
 #tderr,
 #
 #elf.assertFalse(stdout)


class TestCLIIntegration(TestCase):
 #ef test_license(self):
 #ur_metadata = metadata.metadata("jsonschema")
 #elf.assertEqual(our_metadata.get("License-Expression"), "MIT")

 #ef test_version(self):
 #ersion = subprocess.check_output(
 #sys.executable, "-W", "ignore", "-m", "jsonschema", "--version"],
 #tderr=subprocess.STDOUT,
 #
 #ersion = version.decode("utf-8").strip()
 #elf.assertEqual(version, metadata.version("jsonschema"))

 #ef test_no_arguments_shows_usage_notes(self):
 #utput = subprocess.check_output(
 #sys.executable, "-m", "jsonschema"],
 #tderr=subprocess.STDOUT,
 #
 #utput_for_help = subprocess.check_output(
 #sys.executable, "-m", "jsonschema", "--help"],
 #tderr=subprocess.STDOUT,
 #
 #elf.assertEqual(output, output_for_help)
