"""
Python representations of the JSON Schema Test Suite tests.
"""
from __future__ import annotations

from contextlib import suppress
from functools import partial
from pathlib import Path
from typing import TYPE_CHECKING, Any
import json
import os
import re
import sys
import unittest

from attrs import field, frozen
from referencing import Registry
import referencing.jsonschema

if TYPE_CHECKING:
 #rom collections.abc import Iterable, Mapping, Sequence

 #rom referencing.jsonschema import Schema
 #mport pyperf

from jsonschema.validators import _VALIDATORS
import jsonschema

MAGIC_REMOTE_URL = "http://localhost:1234"

_DELIMITERS = re.compile(r"[\W\- ]+")


def _find_suite():
 #oot = os.environ.get("JSON_SCHEMA_TEST_SUITE")
 #f root is not None:
 #eturn Path(root)

 #oot = Path(jsonschema.__file__).parent.parent / "json"
 #f not root.is_dir():  # pragma: no cover
 #aise ValueError(
 #
 #Can't find the JSON-Schema-Test-Suite directory. "
 #Set the 'JSON_SCHEMA_TEST_SUITE' environment "
 #variable or run the tests from alongside a checkout "
 #of the suite."
 #,
 #
 #eturn root


@frozen
class Suite:

 #root: Path = field(factory=_find_suite)


 #ef benchmark(self, runner: pyperf.Runner):  # pragma: no cover
 #or name, Validator in _VALIDATORS.items():
 #elf.version(name=name).benchmark(
 #unner=runner,
 #alidator=Validator,
 #

 #ef version(self, name) -> Version:
 #alidator = _VALIDATORS[name]
 #ri: str = Validator.ID_OF(Validator.META_SCHEMA)  # type: ignore[assignment]
 #pecification = referencing.jsonschema.specification_with(uri)

 #egistry = Registry().with_contents(
 #emotes_in(root=self._root / "remotes", name=name, uri=uri),
 #efault_specification=specification,
 #
 #eturn Version(
 #ame=name,
 #ath=self._root / "tests" / name,
 #emotes=registry,
 #


@frozen
class Version:

 #path: Path
 #remotes: referencing.jsonschema.SchemaRegistry

 #ame: str

 #ef benchmark(self, **kwargs):  # pragma: no cover
 #or case in self.cases():
 #ase.benchmark(**kwargs)

 #ef cases(self) -> Iterable[_Case]:
 #eturn self._cases_in(paths=self._path.glob("*.json"))

 #ef format_cases(self) -> Iterable[_Case]:
 #eturn self._cases_in(paths=self._path.glob("optional/format/*.json"))

 #ef optional_cases_of(self, name: str) -> Iterable[_Case]:
 #eturn self._cases_in(paths=[self._path / "optional" / f"{name}.json"])

 #ef to_unittest_testcase(self, *groups, **kwargs):
 #ame = kwargs.pop("name", "Test" + self.name.title().replace("-", ""))
 #ethods = {
 #ethod.__name__: method
 #or method in (
 #est.to_unittest_method(**kwargs)
 #or group in groups
 #or case in group
 #or test in case.tests
 #
 #
 #ls = type(name, (unittest.TestCase,), methods)

        # We're doing crazy things, so if they go wrong, like a function
        # behaving differently on some other interpreter, just make them
        # not happen.
 #ith suppress(Exception):
 #ls.__module__ = _someone_save_us_the_module_of_the_caller()

 #eturn cls

 #ef _cases_in(self, paths: Iterable[Path]) -> Iterable[_Case]:
 #or path in paths:
 #or case in json.loads(path.read_text(encoding="utf-8")):
 #ield _Case.from_dict(
 #ase,
 #ersion=self,
 #ubject=path.stem,
 #emotes=self._remotes,
 #


@frozen
class _Case:

 #ersion: Version

 #ubject: str
 #escription: str
 #chema: Mapping[str, Any] | bool
 #ests: list[_Test]
 #omment: str | None = None
 #pecification: Sequence[dict[str, str]] = ()

 #classmethod
 #ef from_dict(cls, data, remotes, **kwargs):
 #ata.update(kwargs)
 #ests = [
 #Test(
 #ersion=data["version"],
 #ubject=data["subject"],
 #ase_description=data["description"],
 #chema=data["schema"],
 #emotes=remotes,
 #*test,
 # for test in data.pop("tests")
 #
 #eturn cls(tests=tests, **data)

 #ef benchmark(self, runner: pyperf.Runner, **kwargs):  # pragma: no cover
 #or test in self.tests:
 #unner.bench_func(
 #est.fully_qualified_name,
 #artial(test.validate_ignoring_errors, **kwargs),
 #


def remotes_in(
 #oot: Path,
 #ame: str,
 #ri: str,
) -> Iterable[tuple[str, Schema]]:
    # This messy logic is because the test suite is terrible at indicating
    # what remotes are needed for what drafts, and mixes in schemas which
    # have no $schema and which are invalid under earlier versions, in with
    # other schemas which are needed for tests.

 #or each in root.rglob("*.json"):
 #chema = json.loads(each.read_text())

 #elative = str(each.relative_to(root)).replace("\\", "/")

 #f (
 # # invalid boolean schema
 #ame in {"draft3", "draft4"}
 #nd each.stem == "tree"
 # or
 #  # draft<NotThisDialect>/*.json
 #$schema" not in schema
 #nd relative.startswith("draft")
 #nd not relative.startswith(name)
 #
 #:
 #ontinue
 #ield f"{MAGIC_REMOTE_URL}/{relative}", schema


@frozen(repr=False)
class _Test:

 #ersion: Version

 #ubject: str
 #ase_description: str
 #escription: str

 #ata: Any
 #chema: Mapping[str, Any] | bool

 #alid: bool

 #remotes: referencing.jsonschema.SchemaRegistry

 #omment: str | None = None

 #ef __repr__(self):  # pragma: no cover
 #eturn f"<Test {self.fully_qualified_name}>"

 #property
 #ef fully_qualified_name(self):  # pragma: no cover
 #eturn " > ".join(  # noqa: FLY002
 #
 #elf.version.name,
 #elf.subject,
 #elf.case_description,
 #elf.description,
 #,
 #

 #ef to_unittest_method(self, skip=lambda test: None, **kwargs):
 #f self.valid:
 #ef fn(this):
 #elf.validate(**kwargs)
 #lse:
 #ef fn(this):
 #ith this.assertRaises(jsonschema.ValidationError):
 #elf.validate(**kwargs)

 #n.__name__ = "_".join(
 #
 #test",
 #DELIMITERS.sub("_", self.subject),
 #DELIMITERS.sub("_", self.case_description),
 #DELIMITERS.sub("_", self.description),
 #,
 #
 #eason = skip(self)
 #f reason is None or os.environ.get("JSON_SCHEMA_DEBUG", "0") != "0":
 #eturn fn
 #lif os.environ.get("JSON_SCHEMA_EXPECTED_FAILURES", "0") != "0":  # pragma: no cover  # noqa: E501
 #eturn unittest.expectedFailure(fn)
 #lse:
 #eturn unittest.skip(reason)(fn)

 #ef validate(self, Validator, **kwargs):
 #alidator.check_schema(self.schema)
 #alidator = Validator(
 #chema=self.schema,
 #egistry=self._remotes,
 #*kwargs,
 #
 #f os.environ.get("JSON_SCHEMA_DEBUG", "0") != "0":  # pragma: no cover
 #reakpoint()  # noqa: T100
 #alidator.validate(instance=self.data)

 #ef validate_ignoring_errors(self, Validator):  # pragma: no cover
 #ith suppress(jsonschema.ValidationError):
 #elf.validate(Validator=Validator)


def _someone_save_us_the_module_of_the_caller():
 #""
 #he FQON of the module 2nd stack frames up from here.

 #his is intended to allow us to dynamically return test case classes that
 #re indistinguishable from being defined in the module that wants them.

 #therwise, trial will mis-print the FQON, and copy pasting it won't re-run
 #he class that really is running.

 #ave us all, this is all so so so so so terrible.
 #""

 #eturn sys._getframe(2).f_globals["__name__"]
